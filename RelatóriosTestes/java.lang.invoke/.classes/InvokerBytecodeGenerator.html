


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: InvokerBytecodeGenerator</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang.invoke</a> ]
</div>

<h1>Coverage Summary for Class: InvokerBytecodeGenerator (java.lang.invoke)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InvokerBytecodeGenerator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 71)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 675)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InvokerBytecodeGenerator$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokerBytecodeGenerator$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokerBytecodeGenerator$CpPatch</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 694)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang.invoke;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import jdk.internal.org.objectweb.asm.ClassWriter;
<i>29</i>&nbsp;import jdk.internal.org.objectweb.asm.Label;
<i>30</i>&nbsp;import jdk.internal.org.objectweb.asm.MethodVisitor;
<i>31</i>&nbsp;import jdk.internal.org.objectweb.asm.Opcodes;
<i>32</i>&nbsp;import jdk.internal.org.objectweb.asm.Type;
<i>33</i>&nbsp;import sun.invoke.util.VerifyAccess;
<i>34</i>&nbsp;import sun.invoke.util.VerifyType;
<i>35</i>&nbsp;import sun.invoke.util.Wrapper;
<i>36</i>&nbsp;import sun.reflect.misc.ReflectUtil;
<i>37</i>&nbsp;
<i>38</i>&nbsp;import java.io.File;
<i>39</i>&nbsp;import java.io.FileOutputStream;
<i>40</i>&nbsp;import java.io.IOException;
<i>41</i>&nbsp;import java.lang.reflect.Modifier;
<i>42</i>&nbsp;import java.util.ArrayList;
<i>43</i>&nbsp;import java.util.Arrays;
<i>44</i>&nbsp;import java.util.HashMap;
<i>45</i>&nbsp;import java.util.stream.Stream;
<i>46</i>&nbsp;
<i>47</i>&nbsp;import static java.lang.invoke.LambdaForm.BasicType;
<i>48</i>&nbsp;import static java.lang.invoke.LambdaForm.BasicType.*;
<b class="nc"><i>49</i>&nbsp;import static java.lang.invoke.LambdaForm.*;</b>
<i>50</i>&nbsp;import static java.lang.invoke.MethodHandleNatives.Constants.*;
<i>51</i>&nbsp;import static java.lang.invoke.MethodHandleStatics.*;
<i>52</i>&nbsp;
<i>53</i>&nbsp;/**
<i>54</i>&nbsp; * Code generation backend for LambdaForm.
<i>55</i>&nbsp; * &lt;p&gt;
<i>56</i>&nbsp; * @author John Rose, JSR 292 EG
<i>57</i>&nbsp; */
<i>58</i>&nbsp;class InvokerBytecodeGenerator {
<i>59</i>&nbsp;    /** Define class names for convenience. */
<i>60</i>&nbsp;    private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
<i>61</i>&nbsp;    private static final String MHI     = &quot;java/lang/invoke/MethodHandleImpl&quot;;
<i>62</i>&nbsp;    private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
<i>63</i>&nbsp;    private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
<i>64</i>&nbsp;    private static final String CLS     = &quot;java/lang/Class&quot;;
<i>65</i>&nbsp;    private static final String OBJ     = &quot;java/lang/Object&quot;;
<i>66</i>&nbsp;    private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
<i>67</i>&nbsp;
<i>68</i>&nbsp;    private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
<i>69</i>&nbsp;    private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
<i>70</i>&nbsp;
<i>71</i>&nbsp;    private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
<i>72</i>&nbsp;    private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
<i>73</i>&nbsp;    private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
<i>74</i>&nbsp;    private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
<i>75</i>&nbsp;    private static final String CLASS_PREFIX = LF + &quot;$&quot;;
<i>76</i>&nbsp;    private static final String SOURCE_PREFIX = &quot;LambdaForm$&quot;;
<i>77</i>&nbsp;
<i>78</i>&nbsp;    /** Name of its super class*/
<i>79</i>&nbsp;    static final String INVOKER_SUPER_NAME = OBJ;
<i>80</i>&nbsp;
<i>81</i>&nbsp;    /** Name of new class */
<i>82</i>&nbsp;    private final String className;
<i>83</i>&nbsp;
<i>84</i>&nbsp;    private final LambdaForm lambdaForm;
<i>85</i>&nbsp;    private final String     invokerName;
<i>86</i>&nbsp;    private final MethodType invokerType;
<i>87</i>&nbsp;
<b class="nc"><i>88</i>&nbsp;    /** Info about local variables in compiled lambda form */</b>
<b class="nc"><i>89</i>&nbsp;    private int[]       localsMap;    // index</b>
<i>90</i>&nbsp;    private Class&lt;?&gt;[]  localClasses; // type
<i>91</i>&nbsp;
<i>92</i>&nbsp;    /** ASM bytecode generation. */
<b class="nc"><i>93</i>&nbsp;    private ClassWriter cw;</b>
<b class="nc"><i>94</i>&nbsp;    private MethodVisitor mv;</b>
<b class="nc"><i>95</i>&nbsp;</b>
<b class="nc"><i>96</i>&nbsp;    /** Single element internal class name lookup cache. */</b>
<b class="nc"><i>97</i>&nbsp;    private Class&lt;?&gt; lastClass;</b>
<i>98</i>&nbsp;    private String lastInternalName;
<b class="nc"><i>99</i>&nbsp;</b>
<b class="nc"><i>100</i>&nbsp;    private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();</b>
<i>101</i>&nbsp;    private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
<b class="nc"><i>102</i>&nbsp;</b>
<b class="nc"><i>103</i>&nbsp;    /** Main constructor; other constructors delegate to this one. */</b>
<b class="nc"><i>104</i>&nbsp;    private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,</b>
<b class="nc"><i>105</i>&nbsp;                                     String className, String invokerName, MethodType invokerType) {</b>
<b class="nc"><i>106</i>&nbsp;        int p = invokerName.indexOf(&#39;.&#39;);</b>
<b class="nc"><i>107</i>&nbsp;        if (p &gt; -1) {</b>
<i>108</i>&nbsp;            className = invokerName.substring(0, p);
<b class="nc"><i>109</i>&nbsp;            invokerName = invokerName.substring(p + 1);</b>
<b class="nc"><i>110</i>&nbsp;        }</b>
<i>111</i>&nbsp;        if (DUMP_CLASS_FILES) {
<i>112</i>&nbsp;            className = makeDumpableClassName(className);
<i>113</i>&nbsp;        }
<i>114</i>&nbsp;        this.className  = className;
<b class="nc"><i>115</i>&nbsp;        this.lambdaForm = lambdaForm;</b>
<i>116</i>&nbsp;        this.invokerName = invokerName;
<i>117</i>&nbsp;        this.invokerType = invokerType;
<b class="nc"><i>118</i>&nbsp;        this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots</b>
<b class="nc"><i>119</i>&nbsp;        this.localClasses = new Class&lt;?&gt;[localsMapSize+1];</b>
<b class="nc"><i>120</i>&nbsp;    }</b>
<b class="nc"><i>121</i>&nbsp;</b>
<b class="nc"><i>122</i>&nbsp;    /** For generating LambdaForm interpreter entry points. */</b>
<i>123</i>&nbsp;    private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
<i>124</i>&nbsp;        this(null, invokerType.parameterCount(),
<i>125</i>&nbsp;             className, invokerName, invokerType);
<i>126</i>&nbsp;        // Create an array to map name indexes to locals indexes.
<i>127</i>&nbsp;        for (int i = 0; i &lt; localsMap.length; i++) {
<b class="nc"><i>128</i>&nbsp;            localsMap[i] = invokerType.parameterSlotCount() - invokerType.parameterSlotDepth(i);</b>
<i>129</i>&nbsp;        }
<i>130</i>&nbsp;    }
<b class="nc"><i>131</i>&nbsp;</b>
<b class="nc"><i>132</i>&nbsp;    /** For generating customized code for a single LambdaForm. */</b>
<b class="nc"><i>133</i>&nbsp;    private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {</b>
<b class="nc"><i>134</i>&nbsp;        this(className, form.lambdaName(), form, invokerType);</b>
<b class="nc"><i>135</i>&nbsp;    }</b>
<b class="nc"><i>136</i>&nbsp;</b>
<b class="nc"><i>137</i>&nbsp;    /** For generating customized code for a single LambdaForm. */</b>
<i>138</i>&nbsp;    InvokerBytecodeGenerator(String className, String invokerName,
<i>139</i>&nbsp;            LambdaForm form, MethodType invokerType) {
<i>140</i>&nbsp;        this(form, form.names.length,
<i>141</i>&nbsp;             className, invokerName, invokerType);
<i>142</i>&nbsp;        // Create an array to map name indexes to locals indexes.
<i>143</i>&nbsp;        Name[] names = form.names;
<i>144</i>&nbsp;        for (int i = 0, index = 0; i &lt; localsMap.length; i++) {
<i>145</i>&nbsp;            localsMap[i] = index;
<i>146</i>&nbsp;            if (i &lt; names.length) {
<i>147</i>&nbsp;                BasicType type = names[i].type();
<i>148</i>&nbsp;                index += type.basicTypeSlots();
<b class="nc"><i>149</i>&nbsp;            }</b>
<b class="nc"><i>150</i>&nbsp;        }</b>
<i>151</i>&nbsp;    }
<b class="nc"><i>152</i>&nbsp;</b>
<b class="nc"><i>153</i>&nbsp;    /** instance counters for dumped classes */</b>
<b class="nc"><i>154</i>&nbsp;    private static final HashMap&lt;String,Integer&gt; DUMP_CLASS_FILES_COUNTERS;</b>
<i>155</i>&nbsp;    /** debugging flag for saving generated class files */
<b class="nc"><i>156</i>&nbsp;    private static final File DUMP_CLASS_FILES_DIR;</b>
<b class="nc"><i>157</i>&nbsp;</b>
<b class="nc"><i>158</i>&nbsp;    static {</b>
<b class="nc"><i>159</i>&nbsp;        if (DUMP_CLASS_FILES) {</b>
<b class="nc"><i>160</i>&nbsp;            DUMP_CLASS_FILES_COUNTERS = new HashMap&lt;&gt;();</b>
<i>161</i>&nbsp;            try {
<b class="nc"><i>162</i>&nbsp;                File dumpDir = new File(&quot;DUMP_CLASS_FILES&quot;);</b>
<b class="nc"><i>163</i>&nbsp;                if (!dumpDir.exists()) {</b>
<i>164</i>&nbsp;                    dumpDir.mkdirs();
<i>165</i>&nbsp;                }
<i>166</i>&nbsp;                DUMP_CLASS_FILES_DIR = dumpDir;
<i>167</i>&nbsp;                System.out.println(&quot;Dumping class files to &quot;+DUMP_CLASS_FILES_DIR+&quot;/...&quot;);
<b class="nc"><i>168</i>&nbsp;            } catch (Exception e) {</b>
<b class="nc"><i>169</i>&nbsp;                throw newInternalError(e);</b>
<b class="nc"><i>170</i>&nbsp;            }</b>
<i>171</i>&nbsp;        } else {
<i>172</i>&nbsp;            DUMP_CLASS_FILES_COUNTERS = null;
<b class="nc"><i>173</i>&nbsp;            DUMP_CLASS_FILES_DIR = null;</b>
<i>174</i>&nbsp;        }
<b class="nc"><i>175</i>&nbsp;    }</b>
<b class="nc"><i>176</i>&nbsp;</b>
<b class="nc"><i>177</i>&nbsp;    private void maybeDump(final byte[] classFile) {</b>
<b class="nc"><i>178</i>&nbsp;        if (DUMP_CLASS_FILES) {</b>
<b class="nc"><i>179</i>&nbsp;            maybeDump(CLASS_PREFIX + className, classFile);</b>
<b class="nc"><i>180</i>&nbsp;        }</b>
<b class="nc"><i>181</i>&nbsp;    }</b>
<b class="nc"><i>182</i>&nbsp;</b>
<b class="nc"><i>183</i>&nbsp;    // Also used from BoundMethodHandle</b>
<i>184</i>&nbsp;    static void maybeDump(final String className, final byte[] classFile) {
<i>185</i>&nbsp;        if (DUMP_CLASS_FILES) {
<i>186</i>&nbsp;            java.security.AccessController.doPrivileged(
<i>187</i>&nbsp;            new java.security.PrivilegedAction&lt;&gt;() {
<i>188</i>&nbsp;                public Void run() {
<i>189</i>&nbsp;                    try {
<i>190</i>&nbsp;                        String dumpName = className.replace(&#39;.&#39;,&#39;/&#39;);
<i>191</i>&nbsp;                        File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+&quot;.class&quot;);
<i>192</i>&nbsp;                        System.out.println(&quot;dump: &quot; + dumpFile);
<b class="nc"><i>193</i>&nbsp;                        dumpFile.getParentFile().mkdirs();</b>
<b class="nc"><i>194</i>&nbsp;                        FileOutputStream file = new FileOutputStream(dumpFile);</b>
<b class="nc"><i>195</i>&nbsp;                        file.write(classFile);</b>
<b class="nc"><i>196</i>&nbsp;                        file.close();</b>
<b class="nc"><i>197</i>&nbsp;                        return null;</b>
<b class="nc"><i>198</i>&nbsp;                    } catch (IOException ex) {</b>
<b class="nc"><i>199</i>&nbsp;                        throw newInternalError(ex);</b>
<b class="nc"><i>200</i>&nbsp;                    }</b>
<b class="nc"><i>201</i>&nbsp;                }</b>
<b class="nc"><i>202</i>&nbsp;            });</b>
<i>203</i>&nbsp;        }
<i>204</i>&nbsp;    }
<i>205</i>&nbsp;
<i>206</i>&nbsp;    private static String makeDumpableClassName(String className) {
<i>207</i>&nbsp;        Integer ctr;
<i>208</i>&nbsp;        synchronized (DUMP_CLASS_FILES_COUNTERS) {
<b class="nc"><i>209</i>&nbsp;            ctr = DUMP_CLASS_FILES_COUNTERS.get(className);</b>
<b class="nc"><i>210</i>&nbsp;            if (ctr == null)  ctr = 0;</b>
<b class="nc"><i>211</i>&nbsp;            DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);</b>
<b class="nc"><i>212</i>&nbsp;        }</b>
<i>213</i>&nbsp;        String sfx = ctr.toString();
<i>214</i>&nbsp;        while (sfx.length() &lt; 3)
<b class="nc"><i>215</i>&nbsp;            sfx = &quot;0&quot;+sfx;</b>
<i>216</i>&nbsp;        className += sfx;
<i>217</i>&nbsp;        return className;
<i>218</i>&nbsp;    }
<b class="nc"><i>219</i>&nbsp;</b>
<i>220</i>&nbsp;    class CpPatch {
<b class="nc"><i>221</i>&nbsp;        final int index;</b>
<i>222</i>&nbsp;        final Object value;
<i>223</i>&nbsp;        CpPatch(int index, Object value) {
<b class="nc"><i>224</i>&nbsp;            this.index = index;</b>
<b class="nc"><i>225</i>&nbsp;            this.value = value;</b>
<b class="nc"><i>226</i>&nbsp;        }</b>
<b class="nc"><i>227</i>&nbsp;        public String toString() {</b>
<i>228</i>&nbsp;            return &quot;CpPatch/index=&quot;+index+&quot;,value=&quot;+value;
<i>229</i>&nbsp;        }
<b class="nc"><i>230</i>&nbsp;    }</b>
<b class="nc"><i>231</i>&nbsp;</b>
<b class="nc"><i>232</i>&nbsp;    private final ArrayList&lt;CpPatch&gt; cpPatches = new ArrayList&lt;&gt;();</b>
<i>233</i>&nbsp;
<i>234</i>&nbsp;    private int cph = 0;  // for counting constant placeholders
<i>235</i>&nbsp;
<b class="nc"><i>236</i>&nbsp;    String constantPlaceholder(Object arg) {</b>
<b class="nc"><i>237</i>&nbsp;        String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;</b>
<b class="nc"><i>238</i>&nbsp;        if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + debugString(arg) + &quot;&gt;&gt;&quot;;</b>
<b class="nc"><i>239</i>&nbsp;        // TODO check if arg is already in the constant pool</b>
<b class="nc"><i>240</i>&nbsp;        // insert placeholder in CP and remember the patch</b>
<b class="nc"><i>241</i>&nbsp;        int index = cw.newConst((Object) cpPlaceholder);</b>
<b class="nc"><i>242</i>&nbsp;        cpPatches.add(new CpPatch(index, arg));</b>
<b class="nc"><i>243</i>&nbsp;        return cpPlaceholder;</b>
<i>244</i>&nbsp;    }
<i>245</i>&nbsp;
<i>246</i>&nbsp;    Object[] cpPatches(byte[] classFile) {
<b class="nc"><i>247</i>&nbsp;        int size = getConstantPoolSize(classFile);</b>
<b class="nc"><i>248</i>&nbsp;        Object[] res = new Object[size];</b>
<b class="nc"><i>249</i>&nbsp;        for (CpPatch p : cpPatches) {</b>
<b class="nc"><i>250</i>&nbsp;            if (p.index &gt;= size)</b>
<b class="nc"><i>251</i>&nbsp;                throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));</b>
<b class="nc"><i>252</i>&nbsp;            res[p.index] = p.value;</b>
<i>253</i>&nbsp;        }
<b class="nc"><i>254</i>&nbsp;        return res;</b>
<i>255</i>&nbsp;    }
<i>256</i>&nbsp;
<i>257</i>&nbsp;    private static String debugString(Object arg) {
<i>258</i>&nbsp;        if (arg instanceof MethodHandle) {
<i>259</i>&nbsp;            MethodHandle mh = (MethodHandle) arg;
<i>260</i>&nbsp;            MemberName member = mh.internalMemberName();
<i>261</i>&nbsp;            if (member != null)
<i>262</i>&nbsp;                return member.toString();
<i>263</i>&nbsp;            return mh.debugString();
<i>264</i>&nbsp;        }
<i>265</i>&nbsp;        return arg.toString();
<i>266</i>&nbsp;    }
<i>267</i>&nbsp;
<i>268</i>&nbsp;    /**
<b class="nc"><i>269</i>&nbsp;     * Extract the number of constant pool entries from a given class file.</b>
<i>270</i>&nbsp;     *
<i>271</i>&nbsp;     * @param classFile the bytes of the class file in question.
<i>272</i>&nbsp;     * @return the number of entries in the constant pool.
<i>273</i>&nbsp;     */
<i>274</i>&nbsp;    private static int getConstantPoolSize(byte[] classFile) {
<i>275</i>&nbsp;        // The first few bytes:
<b class="nc"><i>276</i>&nbsp;        // u4 magic;</b>
<b class="nc"><i>277</i>&nbsp;        // u2 minor_version;</b>
<i>278</i>&nbsp;        // u2 major_version;
<i>279</i>&nbsp;        // u2 constant_pool_count;
<i>280</i>&nbsp;        return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);
<i>281</i>&nbsp;    }
<i>282</i>&nbsp;
<i>283</i>&nbsp;    /**
<b class="nc"><i>284</i>&nbsp;     * Extract the MemberName of a newly-defined method.</b>
<b class="nc"><i>285</i>&nbsp;     */</b>
<b class="nc"><i>286</i>&nbsp;    private MemberName loadMethod(byte[] classFile) {</b>
<i>287</i>&nbsp;        Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));
<i>288</i>&nbsp;        return resolveInvokerMember(invokerClass, invokerName, invokerType);
<i>289</i>&nbsp;    }
<b class="nc"><i>290</i>&nbsp;</b>
<i>291</i>&nbsp;    /**
<i>292</i>&nbsp;     * Define a given class as anonymous class in the runtime system.
<i>293</i>&nbsp;     */
<b class="nc"><i>294</i>&nbsp;    private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {</b>
<b class="nc"><i>295</i>&nbsp;        Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);</b>
<b class="nc"><i>296</i>&nbsp;        UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.</b>
<b class="nc"><i>297</i>&nbsp;        return invokerClass;</b>
<i>298</i>&nbsp;    }
<b class="nc"><i>299</i>&nbsp;</b>
<i>300</i>&nbsp;    private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {
<i>301</i>&nbsp;        MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
<i>302</i>&nbsp;        try {
<i>303</i>&nbsp;            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
<i>304</i>&nbsp;        } catch (ReflectiveOperationException e) {
<i>305</i>&nbsp;            throw newInternalError(e);
<i>306</i>&nbsp;        }
<b class="nc"><i>307</i>&nbsp;        return member;</b>
<b class="nc"><i>308</i>&nbsp;    }</b>
<b class="nc"><i>309</i>&nbsp;</b>
<i>310</i>&nbsp;    /**
<b class="nc"><i>311</i>&nbsp;     * Set up class file generation.</b>
<b class="nc"><i>312</i>&nbsp;     */</b>
<i>313</i>&nbsp;    private ClassWriter classFilePrologue() {
<i>314</i>&nbsp;        final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<i>315</i>&nbsp;        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
<i>316</i>&nbsp;        cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
<i>317</i>&nbsp;                CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
<i>318</i>&nbsp;        cw.visitSource(SOURCE_PREFIX + className, null);
<b class="nc"><i>319</i>&nbsp;        return cw;</b>
<b class="nc"><i>320</i>&nbsp;    }</b>
<i>321</i>&nbsp;
<i>322</i>&nbsp;    private void methodPrologue() {
<i>323</i>&nbsp;        String invokerDesc = invokerType.toMethodDescriptorString();
<i>324</i>&nbsp;        mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);
<i>325</i>&nbsp;    }
<i>326</i>&nbsp;
<b class="nc"><i>327</i>&nbsp;    /**</b>
<b class="nc"><i>328</i>&nbsp;     * Tear down class file generation.</b>
<i>329</i>&nbsp;     */
<i>330</i>&nbsp;    private void methodEpilogue() {
<b class="nc"><i>331</i>&nbsp;        mv.visitMaxs(0, 0);</b>
<b class="nc"><i>332</i>&nbsp;        mv.visitEnd();</b>
<i>333</i>&nbsp;    }
<i>334</i>&nbsp;
<b class="nc"><i>335</i>&nbsp;    /*</b>
<b class="nc"><i>336</i>&nbsp;     * Low-level emit helpers.</b>
<b class="nc"><i>337</i>&nbsp;     */</b>
<b class="nc"><i>338</i>&nbsp;    private void emitConst(Object con) {</b>
<b class="nc"><i>339</i>&nbsp;        if (con == null) {</b>
<i>340</i>&nbsp;            mv.visitInsn(Opcodes.ACONST_NULL);
<i>341</i>&nbsp;            return;
<i>342</i>&nbsp;        }
<b class="nc"><i>343</i>&nbsp;        if (con instanceof Integer) {</b>
<b class="nc"><i>344</i>&nbsp;            emitIconstInsn((int) con);</b>
<b class="nc"><i>345</i>&nbsp;            return;</b>
<b class="nc"><i>346</i>&nbsp;        }</b>
<b class="nc"><i>347</i>&nbsp;        if (con instanceof Byte) {</b>
<i>348</i>&nbsp;            emitIconstInsn((byte)con);
<i>349</i>&nbsp;            return;
<i>350</i>&nbsp;        }
<b class="nc"><i>351</i>&nbsp;        if (con instanceof Short) {</b>
<b class="nc"><i>352</i>&nbsp;            emitIconstInsn((short)con);</b>
<b class="nc"><i>353</i>&nbsp;            return;</b>
<b class="nc"><i>354</i>&nbsp;        }</b>
<b class="nc"><i>355</i>&nbsp;        if (con instanceof Character) {</b>
<i>356</i>&nbsp;            emitIconstInsn((char)con);
<i>357</i>&nbsp;            return;
<i>358</i>&nbsp;        }
<b class="nc"><i>359</i>&nbsp;        if (con instanceof Long) {</b>
<b class="nc"><i>360</i>&nbsp;            long x = (long) con;</b>
<i>361</i>&nbsp;            short sx = (short)x;
<i>362</i>&nbsp;            if (x == sx) {
<i>363</i>&nbsp;                if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
<b class="nc"><i>364</i>&nbsp;                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);</b>
<i>365</i>&nbsp;                } else {
<i>366</i>&nbsp;                    emitIconstInsn((int) x);
<i>367</i>&nbsp;                    mv.visitInsn(Opcodes.I2L);
<i>368</i>&nbsp;                }
<b class="nc"><i>369</i>&nbsp;                return;</b>
<b class="nc"><i>370</i>&nbsp;            }</b>
<b class="nc"><i>371</i>&nbsp;        }</b>
<b class="nc"><i>372</i>&nbsp;        if (con instanceof Float) {</b>
<b class="nc"><i>373</i>&nbsp;            float x = (float) con;</b>
<b class="nc"><i>374</i>&nbsp;            short sx = (short)x;</b>
<b class="nc"><i>375</i>&nbsp;            if (x == sx) {</b>
<i>376</i>&nbsp;                if (sx &gt;= 0 &amp;&amp; sx &lt;= 2) {
<b class="nc"><i>377</i>&nbsp;                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);</b>
<b class="nc"><i>378</i>&nbsp;                } else {</b>
<b class="nc"><i>379</i>&nbsp;                    emitIconstInsn((int) x);</b>
<b class="nc"><i>380</i>&nbsp;                    mv.visitInsn(Opcodes.I2F);</b>
<i>381</i>&nbsp;                }
<b class="nc"><i>382</i>&nbsp;                return;</b>
<i>383</i>&nbsp;            }
<i>384</i>&nbsp;        }
<i>385</i>&nbsp;        if (con instanceof Double) {
<b class="nc"><i>386</i>&nbsp;            double x = (double) con;</b>
<i>387</i>&nbsp;            short sx = (short)x;
<i>388</i>&nbsp;            if (x == sx) {
<i>389</i>&nbsp;                if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
<i>390</i>&nbsp;                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);
<i>391</i>&nbsp;                } else {
<i>392</i>&nbsp;                    emitIconstInsn((int) x);
<b class="nc"><i>393</i>&nbsp;                    mv.visitInsn(Opcodes.I2D);</b>
<b class="nc"><i>394</i>&nbsp;                }</b>
<i>395</i>&nbsp;                return;
<i>396</i>&nbsp;            }
<i>397</i>&nbsp;        }
<b class="nc"><i>398</i>&nbsp;        if (con instanceof Boolean) {</b>
<b class="nc"><i>399</i>&nbsp;            emitIconstInsn((boolean) con ? 1 : 0);</b>
<b class="nc"><i>400</i>&nbsp;            return;</b>
<b class="nc"><i>401</i>&nbsp;        }</b>
<b class="nc"><i>402</i>&nbsp;        // fall through:</b>
<b class="nc"><i>403</i>&nbsp;        mv.visitLdcInsn(con);</b>
<i>404</i>&nbsp;    }
<b class="nc"><i>405</i>&nbsp;</b>
<i>406</i>&nbsp;    private void emitIconstInsn(final int cst) {
<i>407</i>&nbsp;        if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
<i>408</i>&nbsp;            mv.visitInsn(Opcodes.ICONST_0 + cst);
<b class="nc"><i>409</i>&nbsp;        } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {</b>
<i>410</i>&nbsp;            mv.visitIntInsn(Opcodes.BIPUSH, cst);
<i>411</i>&nbsp;        } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
<i>412</i>&nbsp;            mv.visitIntInsn(Opcodes.SIPUSH, cst);
<b class="nc"><i>413</i>&nbsp;        } else {</b>
<b class="nc"><i>414</i>&nbsp;            mv.visitLdcInsn(cst);</b>
<i>415</i>&nbsp;        }
<i>416</i>&nbsp;    }
<i>417</i>&nbsp;
<b class="nc"><i>418</i>&nbsp;    /*</b>
<b class="nc"><i>419</i>&nbsp;     * NOTE: These load/store methods use the localsMap to find the correct index!</b>
<b class="nc"><i>420</i>&nbsp;     */</b>
<b class="nc"><i>421</i>&nbsp;    private void emitLoadInsn(BasicType type, int index) {</b>
<b class="nc"><i>422</i>&nbsp;        int opcode = loadInsnOpcode(type);</b>
<b class="nc"><i>423</i>&nbsp;        mv.visitVarInsn(opcode, localsMap[index]);</b>
<i>424</i>&nbsp;    }
<b class="nc"><i>425</i>&nbsp;</b>
<i>426</i>&nbsp;    private int loadInsnOpcode(BasicType type) throws InternalError {
<i>427</i>&nbsp;        switch (type) {
<i>428</i>&nbsp;            case I_TYPE: return Opcodes.ILOAD;
<b class="nc"><i>429</i>&nbsp;            case J_TYPE: return Opcodes.LLOAD;</b>
<i>430</i>&nbsp;            case F_TYPE: return Opcodes.FLOAD;
<i>431</i>&nbsp;            case D_TYPE: return Opcodes.DLOAD;
<i>432</i>&nbsp;            case L_TYPE: return Opcodes.ALOAD;
<b class="nc"><i>433</i>&nbsp;            default:</b>
<b class="nc"><i>434</i>&nbsp;                throw new InternalError(&quot;unknown type: &quot; + type);</b>
<b class="nc"><i>435</i>&nbsp;        }</b>
<b class="nc"><i>436</i>&nbsp;    }</b>
<b class="nc"><i>437</i>&nbsp;    private void emitAloadInsn(int index) {</b>
<b class="nc"><i>438</i>&nbsp;        emitLoadInsn(L_TYPE, index);</b>
<b class="nc"><i>439</i>&nbsp;    }</b>
<b class="nc"><i>440</i>&nbsp;</b>
<b class="nc"><i>441</i>&nbsp;    private void emitStoreInsn(BasicType type, int index) {</b>
<b class="nc"><i>442</i>&nbsp;        int opcode = storeInsnOpcode(type);</b>
<b class="nc"><i>443</i>&nbsp;        mv.visitVarInsn(opcode, localsMap[index]);</b>
<i>444</i>&nbsp;    }
<i>445</i>&nbsp;
<i>446</i>&nbsp;    private int storeInsnOpcode(BasicType type) throws InternalError {
<i>447</i>&nbsp;        switch (type) {
<b class="nc"><i>448</i>&nbsp;            case I_TYPE: return Opcodes.ISTORE;</b>
<i>449</i>&nbsp;            case J_TYPE: return Opcodes.LSTORE;
<b class="nc"><i>450</i>&nbsp;            case F_TYPE: return Opcodes.FSTORE;</b>
<b class="nc"><i>451</i>&nbsp;            case D_TYPE: return Opcodes.DSTORE;</b>
<b class="nc"><i>452</i>&nbsp;            case L_TYPE: return Opcodes.ASTORE;</b>
<b class="nc"><i>453</i>&nbsp;            default:</b>
<b class="nc"><i>454</i>&nbsp;                throw new InternalError(&quot;unknown type: &quot; + type);</b>
<b class="nc"><i>455</i>&nbsp;        }</b>
<b class="nc"><i>456</i>&nbsp;    }</b>
<b class="nc"><i>457</i>&nbsp;    private void emitAstoreInsn(int index) {</b>
<b class="nc"><i>458</i>&nbsp;        emitStoreInsn(L_TYPE, index);</b>
<b class="nc"><i>459</i>&nbsp;    }</b>
<b class="nc"><i>460</i>&nbsp;</b>
<i>461</i>&nbsp;    private byte arrayTypeCode(Wrapper elementType) {
<b class="nc"><i>462</i>&nbsp;        switch (elementType) {</b>
<i>463</i>&nbsp;            case BOOLEAN: return Opcodes.T_BOOLEAN;
<i>464</i>&nbsp;            case BYTE:    return Opcodes.T_BYTE;
<i>465</i>&nbsp;            case CHAR:    return Opcodes.T_CHAR;
<i>466</i>&nbsp;            case SHORT:   return Opcodes.T_SHORT;
<b class="nc"><i>467</i>&nbsp;            case INT:     return Opcodes.T_INT;</b>
<b class="nc"><i>468</i>&nbsp;            case LONG:    return Opcodes.T_LONG;</b>
<b class="nc"><i>469</i>&nbsp;            case FLOAT:   return Opcodes.T_FLOAT;</b>
<b class="nc"><i>470</i>&nbsp;            case DOUBLE:  return Opcodes.T_DOUBLE;</b>
<b class="nc"><i>471</i>&nbsp;            case OBJECT:  return 0; // in place of Opcodes.T_OBJECT</b>
<b class="nc"><i>472</i>&nbsp;            default:      throw new InternalError();</b>
<b class="nc"><i>473</i>&nbsp;        }</b>
<b class="nc"><i>474</i>&nbsp;    }</b>
<b class="nc"><i>475</i>&nbsp;</b>
<i>476</i>&nbsp;    private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {
<i>477</i>&nbsp;        assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);
<b class="nc"><i>478</i>&nbsp;        int xas;</b>
<b class="nc"><i>479</i>&nbsp;        switch (tcode) {</b>
<b class="nc"><i>480</i>&nbsp;            case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;</b>
<i>481</i>&nbsp;            case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;
<b class="nc"><i>482</i>&nbsp;            case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;</b>
<i>483</i>&nbsp;            case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;
<i>484</i>&nbsp;            case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;
<b class="nc"><i>485</i>&nbsp;            case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;</b>
<b class="nc"><i>486</i>&nbsp;            case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;</b>
<b class="nc"><i>487</i>&nbsp;            case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;</b>
<i>488</i>&nbsp;            case 0:                 xas = Opcodes.AASTORE; break;
<i>489</i>&nbsp;            default:      throw new InternalError();
<i>490</i>&nbsp;        }
<i>491</i>&nbsp;        return xas - Opcodes.AASTORE + aaop;
<i>492</i>&nbsp;    }
<i>493</i>&nbsp;
<i>494</i>&nbsp;    /**
<i>495</i>&nbsp;     * Emit a boxing call.
<b class="nc"><i>496</i>&nbsp;     *</b>
<b class="nc"><i>497</i>&nbsp;     * @param wrapper primitive type class to box.</b>
<b class="nc"><i>498</i>&nbsp;     */</b>
<b class="nc"><i>499</i>&nbsp;    private void emitBoxing(Wrapper wrapper) {</b>
<i>500</i>&nbsp;        String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();
<i>501</i>&nbsp;        String name  = &quot;valueOf&quot;;
<i>502</i>&nbsp;        String desc  = &quot;(&quot; + wrapper.basicTypeChar() + &quot;)L&quot; + owner + &quot;;&quot;;
<i>503</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);
<i>504</i>&nbsp;    }
<i>505</i>&nbsp;
<i>506</i>&nbsp;    /**
<i>507</i>&nbsp;     * Emit an unboxing call (plus preceding checkcast).
<b class="nc"><i>508</i>&nbsp;     *</b>
<b class="nc"><i>509</i>&nbsp;     * @param wrapper wrapper type class to unbox.</b>
<b class="nc"><i>510</i>&nbsp;     */</b>
<b class="nc"><i>511</i>&nbsp;    private void emitUnboxing(Wrapper wrapper) {</b>
<b class="nc"><i>512</i>&nbsp;        String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();</b>
<i>513</i>&nbsp;        String name  = wrapper.primitiveSimpleName() + &quot;Value&quot;;
<i>514</i>&nbsp;        String desc  = &quot;()&quot; + wrapper.basicTypeChar();
<i>515</i>&nbsp;        emitReferenceCast(wrapper.wrapperType(), null);
<i>516</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);
<i>517</i>&nbsp;    }
<i>518</i>&nbsp;
<i>519</i>&nbsp;    /**
<i>520</i>&nbsp;     * Emit an implicit conversion for an argument which must be of the given pclass.
<i>521</i>&nbsp;     * This is usually a no-op, except when pclass is a subword type or a reference other than Object or an interface.
<i>522</i>&nbsp;     *
<i>523</i>&nbsp;     * @param ptype type of value present on stack
<b class="nc"><i>524</i>&nbsp;     * @param pclass type of value required on stack</b>
<b class="nc"><i>525</i>&nbsp;     * @param arg compile-time representation of value on stack (Node, constant) or null if none</b>
<i>526</i>&nbsp;     */
<b class="nc"><i>527</i>&nbsp;    private void emitImplicitConversion(BasicType ptype, Class&lt;?&gt; pclass, Object arg) {</b>
<i>528</i>&nbsp;        assert(basicType(pclass) == ptype);  // boxing/unboxing handled by caller
<b class="nc"><i>529</i>&nbsp;        if (pclass == ptype.basicTypeClass() &amp;&amp; ptype != L_TYPE)</b>
<b class="nc"><i>530</i>&nbsp;            return;   // nothing to do</b>
<b class="nc"><i>531</i>&nbsp;        switch (ptype) {</b>
<i>532</i>&nbsp;            case L_TYPE:
<i>533</i>&nbsp;                if (VerifyType.isNullConversion(Object.class, pclass, false)) {
<b class="nc"><i>534</i>&nbsp;                    if (PROFILE_LEVEL &gt; 0)</b>
<i>535</i>&nbsp;                        emitReferenceCast(Object.class, arg);
<i>536</i>&nbsp;                    return;
<b class="nc"><i>537</i>&nbsp;                }</b>
<b class="nc"><i>538</i>&nbsp;                emitReferenceCast(pclass, arg);</b>
<i>539</i>&nbsp;                return;
<i>540</i>&nbsp;            case I_TYPE:
<b class="nc"><i>541</i>&nbsp;                if (!VerifyType.isNullConversion(int.class, pclass, false))</b>
<i>542</i>&nbsp;                    emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));
<i>543</i>&nbsp;                return;
<i>544</i>&nbsp;        }
<i>545</i>&nbsp;        throw newInternalError(&quot;bad implicit conversion: tc=&quot;+ptype+&quot;: &quot;+pclass);
<b class="nc"><i>546</i>&nbsp;    }</b>
<b class="nc"><i>547</i>&nbsp;</b>
<b class="nc"><i>548</i>&nbsp;    /** Update localClasses type map.  Return true if the information is already present. */</b>
<b class="nc"><i>549</i>&nbsp;    private boolean assertStaticType(Class&lt;?&gt; cls, Name n) {</b>
<b class="nc"><i>550</i>&nbsp;        int local = n.index();</b>
<b class="nc"><i>551</i>&nbsp;        Class&lt;?&gt; aclass = localClasses[local];</b>
<i>552</i>&nbsp;        if (aclass != null &amp;&amp; (aclass == cls || cls.isAssignableFrom(aclass))) {
<b class="nc"><i>553</i>&nbsp;            return true;  // type info is already present</b>
<i>554</i>&nbsp;        } else if (aclass == null || aclass.isAssignableFrom(cls)) {
<i>555</i>&nbsp;            localClasses[local] = cls;  // type info can be improved
<i>556</i>&nbsp;        }
<b class="nc"><i>557</i>&nbsp;        return false;</b>
<b class="nc"><i>558</i>&nbsp;    }</b>
<b class="nc"><i>559</i>&nbsp;</b>
<b class="nc"><i>560</i>&nbsp;    private void emitReferenceCast(Class&lt;?&gt; cls, Object arg) {</b>
<i>561</i>&nbsp;        Name writeBack = null;  // local to write back result
<b class="nc"><i>562</i>&nbsp;        if (arg instanceof Name) {</b>
<i>563</i>&nbsp;            Name n = (Name) arg;
<b class="nc"><i>564</i>&nbsp;            if (lambdaForm.useCount(n) &gt; 1) {</b>
<i>565</i>&nbsp;                // This guy gets used more than once.
<i>566</i>&nbsp;                writeBack = n;
<b class="nc"><i>567</i>&nbsp;                if (assertStaticType(cls, n)) {</b>
<b class="nc"><i>568</i>&nbsp;                    return; // this cast was already performed</b>
<b class="nc"><i>569</i>&nbsp;                }</b>
<b class="nc"><i>570</i>&nbsp;            }</b>
<b class="nc"><i>571</i>&nbsp;        }</b>
<b class="nc"><i>572</i>&nbsp;        if (isStaticallyNameable(cls)) {</b>
<b class="nc"><i>573</i>&nbsp;            String sig = getInternalName(cls);</b>
<b class="nc"><i>574</i>&nbsp;            mv.visitTypeInsn(Opcodes.CHECKCAST, sig);</b>
<b class="nc"><i>575</i>&nbsp;        } else {</b>
<b class="nc"><i>576</i>&nbsp;            mv.visitLdcInsn(constantPlaceholder(cls));</b>
<b class="nc"><i>577</i>&nbsp;            mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);</b>
<b class="nc"><i>578</i>&nbsp;            mv.visitInsn(Opcodes.SWAP);</b>
<i>579</i>&nbsp;            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
<b class="nc"><i>580</i>&nbsp;            if (Object[].class.isAssignableFrom(cls))</b>
<b class="nc"><i>581</i>&nbsp;                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);</b>
<b class="nc"><i>582</i>&nbsp;            else if (PROFILE_LEVEL &gt; 0)</b>
<i>583</i>&nbsp;                mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);
<i>584</i>&nbsp;        }
<i>585</i>&nbsp;        if (writeBack != null) {
<i>586</i>&nbsp;            mv.visitInsn(Opcodes.DUP);
<i>587</i>&nbsp;            emitAstoreInsn(writeBack.index());
<i>588</i>&nbsp;        }
<i>589</i>&nbsp;    }
<i>590</i>&nbsp;
<b class="nc"><i>591</i>&nbsp;    /**</b>
<b class="nc"><i>592</i>&nbsp;     * Emits an actual return instruction conforming to the given return type.</b>
<b class="nc"><i>593</i>&nbsp;     */</b>
<b class="nc"><i>594</i>&nbsp;    private void emitReturnInsn(BasicType type) {</b>
<b class="nc"><i>595</i>&nbsp;        int opcode;</b>
<b class="nc"><i>596</i>&nbsp;        switch (type) {</b>
<b class="nc"><i>597</i>&nbsp;        case I_TYPE:  opcode = Opcodes.IRETURN;  break;</b>
<i>598</i>&nbsp;        case J_TYPE:  opcode = Opcodes.LRETURN;  break;
<b class="nc"><i>599</i>&nbsp;        case F_TYPE:  opcode = Opcodes.FRETURN;  break;</b>
<i>600</i>&nbsp;        case D_TYPE:  opcode = Opcodes.DRETURN;  break;
<b class="nc"><i>601</i>&nbsp;        case L_TYPE:  opcode = Opcodes.ARETURN;  break;</b>
<i>602</i>&nbsp;        case V_TYPE:  opcode = Opcodes.RETURN;   break;
<i>603</i>&nbsp;        default:
<i>604</i>&nbsp;            throw new InternalError(&quot;unknown return type: &quot; + type);
<b class="nc"><i>605</i>&nbsp;        }</b>
<b class="nc"><i>606</i>&nbsp;        mv.visitInsn(opcode);</b>
<b class="nc"><i>607</i>&nbsp;    }</b>
<b class="nc"><i>608</i>&nbsp;</b>
<b class="nc"><i>609</i>&nbsp;    private String getInternalName(Class&lt;?&gt; c) {</b>
<b class="nc"><i>610</i>&nbsp;        if (c == Object.class)             return OBJ;</b>
<i>611</i>&nbsp;        else if (c == Object[].class)      return OBJARY;
<i>612</i>&nbsp;        else if (c == Class.class)         return CLS;
<i>613</i>&nbsp;        else if (c == MethodHandle.class)  return MH;
<i>614</i>&nbsp;        assert(VerifyAccess.isTypeVisible(c, Object.class)) : c.getName();
<i>615</i>&nbsp;
<i>616</i>&nbsp;        if (c == lastClass) {
<b class="nc"><i>617</i>&nbsp;            return lastInternalName;</b>
<b class="nc"><i>618</i>&nbsp;        }</b>
<i>619</i>&nbsp;        lastClass = c;
<i>620</i>&nbsp;        return lastInternalName = c.getName().replace(&#39;.&#39;, &#39;/&#39;);
<i>621</i>&nbsp;    }
<i>622</i>&nbsp;
<i>623</i>&nbsp;    private static MemberName resolveFrom(String name, MethodType type, Class&lt;?&gt; holder) {
<b class="nc"><i>624</i>&nbsp;        MemberName member = new MemberName(holder, name, type, REF_invokeStatic);</b>
<b class="nc"><i>625</i>&nbsp;        MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder);</b>
<b class="nc"><i>626</i>&nbsp;        if (TRACE_RESOLVE) {</b>
<b class="nc"><i>627</i>&nbsp;            System.out.println(&quot;[LF_RESOLVE] &quot; + holder.getName() + &quot; &quot; + name + &quot; &quot; +</b>
<i>628</i>&nbsp;                    shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? &quot; (success)&quot; : &quot; (fail)&quot;) );
<i>629</i>&nbsp;        }
<i>630</i>&nbsp;        return resolvedMember;
<i>631</i>&nbsp;    }
<i>632</i>&nbsp;
<i>633</i>&nbsp;    private static MemberName lookupPregenerated(LambdaForm form, MethodType invokerType) {
<b class="nc"><i>634</i>&nbsp;        if (form.customized != null) {</b>
<i>635</i>&nbsp;            // No pre-generated version for customized LF
<i>636</i>&nbsp;            return null;
<b class="nc"><i>637</i>&nbsp;        }</b>
<i>638</i>&nbsp;        String name = form.kind.methodName;
<i>639</i>&nbsp;        switch (form.kind) {
<b class="nc"><i>640</i>&nbsp;            case BOUND_REINVOKER: {</b>
<i>641</i>&nbsp;                name = name + &quot;_&quot; + BoundMethodHandle.speciesDataFor(form).key();
<b class="nc"><i>642</i>&nbsp;                return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);</b>
<i>643</i>&nbsp;            }
<b class="nc"><i>644</i>&nbsp;            case DELEGATE:                  return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);</b>
<i>645</i>&nbsp;            case ZERO:                      // fall-through
<b class="nc"><i>646</i>&nbsp;            case IDENTITY: {</b>
<i>647</i>&nbsp;                name = name + &quot;_&quot; + form.returnType().basicTypeChar();
<i>648</i>&nbsp;                return resolveFrom(name, invokerType, LambdaForm.Holder.class);
<b class="nc"><i>649</i>&nbsp;            }</b>
<i>650</i>&nbsp;            case EXACT_INVOKER:             // fall-through
<i>651</i>&nbsp;            case EXACT_LINKER:              // fall-through
<i>652</i>&nbsp;            case LINK_TO_CALL_SITE:         // fall-through
<i>653</i>&nbsp;            case LINK_TO_TARGET_METHOD:     // fall-through
<b class="nc"><i>654</i>&nbsp;            case GENERIC_INVOKER:           // fall-through</b>
<b class="nc"><i>655</i>&nbsp;            case GENERIC_LINKER:            return resolveFrom(name, invokerType.basicType(), Invokers.Holder.class);</b>
<b class="nc"><i>656</i>&nbsp;            case GET_OBJECT:                // fall-through</b>
<b class="nc"><i>657</i>&nbsp;            case GET_BOOLEAN:               // fall-through</b>
<i>658</i>&nbsp;            case GET_BYTE:                  // fall-through
<i>659</i>&nbsp;            case GET_CHAR:                  // fall-through
<i>660</i>&nbsp;            case GET_SHORT:                 // fall-through
<i>661</i>&nbsp;            case GET_INT:                   // fall-through
<b class="nc"><i>662</i>&nbsp;            case GET_LONG:                  // fall-through</b>
<b class="nc"><i>663</i>&nbsp;            case GET_FLOAT:                 // fall-through</b>
<b class="nc"><i>664</i>&nbsp;            case GET_DOUBLE:                // fall-through</b>
<i>665</i>&nbsp;            case PUT_OBJECT:                // fall-through
<b class="nc"><i>666</i>&nbsp;            case PUT_BOOLEAN:               // fall-through</b>
<b class="nc"><i>667</i>&nbsp;            case PUT_BYTE:                  // fall-through</b>
<b class="nc"><i>668</i>&nbsp;            case PUT_CHAR:                  // fall-through</b>
<b class="nc"><i>669</i>&nbsp;            case PUT_SHORT:                 // fall-through</b>
<i>670</i>&nbsp;            case PUT_INT:                   // fall-through
<b class="nc"><i>671</i>&nbsp;            case PUT_LONG:                  // fall-through</b>
<b class="nc"><i>672</i>&nbsp;            case PUT_FLOAT:                 // fall-through</b>
<b class="nc"><i>673</i>&nbsp;            case PUT_DOUBLE:                // fall-through</b>
<b class="nc"><i>674</i>&nbsp;            case DIRECT_NEW_INVOKE_SPECIAL: // fall-through</b>
<b class="nc"><i>675</i>&nbsp;            case DIRECT_INVOKE_INTERFACE:   // fall-through</b>
<i>676</i>&nbsp;            case DIRECT_INVOKE_SPECIAL:     // fall-through
<b class="nc"><i>677</i>&nbsp;            case DIRECT_INVOKE_SPECIAL_IFC: // fall-through</b>
<b class="nc"><i>678</i>&nbsp;            case DIRECT_INVOKE_STATIC:      // fall-through</b>
<b class="nc"><i>679</i>&nbsp;            case DIRECT_INVOKE_STATIC_INIT: // fall-through</b>
<i>680</i>&nbsp;            case DIRECT_INVOKE_VIRTUAL:     return resolveFrom(name, invokerType, DirectMethodHandle.Holder.class);
<b class="nc"><i>681</i>&nbsp;        }</b>
<b class="nc"><i>682</i>&nbsp;        return null;</b>
<b class="nc"><i>683</i>&nbsp;    }</b>
<b class="nc"><i>684</i>&nbsp;</b>
<i>685</i>&nbsp;    /**
<b class="nc"><i>686</i>&nbsp;     * Generate customized bytecode for a given LambdaForm.</b>
<b class="nc"><i>687</i>&nbsp;     */</b>
<b class="nc"><i>688</i>&nbsp;    static MemberName generateCustomizedCode(LambdaForm form, MethodType invokerType) {</b>
<b class="nc"><i>689</i>&nbsp;        MemberName pregenerated = lookupPregenerated(form, invokerType);</b>
<i>690</i>&nbsp;        if (pregenerated != null)  return pregenerated; // pre-generated bytecode
<i>691</i>&nbsp;
<i>692</i>&nbsp;        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;MH&quot;, form, invokerType);
<b class="nc"><i>693</i>&nbsp;        return g.loadMethod(g.generateCustomizedCodeBytes());</b>
<b class="nc"><i>694</i>&nbsp;    }</b>
<i>695</i>&nbsp;
<b class="nc"><i>696</i>&nbsp;    /** Generates code to check that actual receiver and LambdaForm matches */</b>
<b class="nc"><i>697</i>&nbsp;    private boolean checkActualReceiver() {</b>
<i>698</i>&nbsp;        // Expects MethodHandle on the stack and actual receiver MethodHandle in slot #0
<b class="nc"><i>699</i>&nbsp;        mv.visitInsn(Opcodes.DUP);</b>
<b class="nc"><i>700</i>&nbsp;        mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);</b>
<b class="nc"><i>701</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, &quot;assertSame&quot;, LLV_SIG, false);</b>
<i>702</i>&nbsp;        return true;
<b class="nc"><i>703</i>&nbsp;    }</b>
<b class="nc"><i>704</i>&nbsp;</b>
<b class="nc"><i>705</i>&nbsp;    static String className(String cn) {</b>
<i>706</i>&nbsp;        assert checkClassName(cn): &quot;Class not found: &quot; + cn;
<i>707</i>&nbsp;        return cn;
<b class="nc"><i>708</i>&nbsp;    }</b>
<i>709</i>&nbsp;
<b class="nc"><i>710</i>&nbsp;    static boolean checkClassName(String cn) {</b>
<i>711</i>&nbsp;        Type tp = Type.getType(cn);
<i>712</i>&nbsp;        // additional sanity so only valid &quot;L;&quot; descriptors work
<b class="nc"><i>713</i>&nbsp;        if (tp.getSort() != Type.OBJECT) {</b>
<b class="nc"><i>714</i>&nbsp;            return false;</b>
<b class="nc"><i>715</i>&nbsp;        }</b>
<i>716</i>&nbsp;        try {
<b class="nc"><i>717</i>&nbsp;            Class&lt;?&gt; c = Class.forName(tp.getClassName(), false, null);</b>
<i>718</i>&nbsp;            return true;
<i>719</i>&nbsp;        } catch (ClassNotFoundException e) {
<i>720</i>&nbsp;            return false;
<i>721</i>&nbsp;        }
<b class="nc"><i>722</i>&nbsp;    }</b>
<i>723</i>&nbsp;
<b class="nc"><i>724</i>&nbsp;    static final String  LF_HIDDEN_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Hidden;&quot;);</b>
<b class="nc"><i>725</i>&nbsp;    static final String  LF_COMPILED_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;);</b>
<i>726</i>&nbsp;    static final String  FORCEINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;);
<b class="nc"><i>727</i>&nbsp;    static final String  DONTINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/DontInline;&quot;);</b>
<b class="nc"><i>728</i>&nbsp;    static final String  INJECTEDPROFILE_SIG = className(&quot;Ljava/lang/invoke/InjectedProfile;&quot;);</b>
<b class="nc"><i>729</i>&nbsp;</b>
<i>730</i>&nbsp;    /**
<i>731</i>&nbsp;     * Generate an invoker method for the passed {@link LambdaForm}.
<b class="nc"><i>732</i>&nbsp;     */</b>
<b class="nc"><i>733</i>&nbsp;    private byte[] generateCustomizedCodeBytes() {</b>
<i>734</i>&nbsp;        classFilePrologue();
<i>735</i>&nbsp;        addMethod();
<b class="nc"><i>736</i>&nbsp;        bogusMethod(lambdaForm);</b>
<b class="nc"><i>737</i>&nbsp;</b>
<b class="nc"><i>738</i>&nbsp;        final byte[] classFile = toByteArray();</b>
<b class="nc"><i>739</i>&nbsp;        maybeDump(classFile);</b>
<b class="nc"><i>740</i>&nbsp;        return classFile;</b>
<b class="nc"><i>741</i>&nbsp;    }</b>
<b class="nc"><i>742</i>&nbsp;</b>
<i>743</i>&nbsp;    void setClassWriter(ClassWriter cw) {
<b class="nc"><i>744</i>&nbsp;        this.cw = cw;</b>
<i>745</i>&nbsp;    }
<i>746</i>&nbsp;
<i>747</i>&nbsp;    void addMethod() {
<i>748</i>&nbsp;        methodPrologue();
<i>749</i>&nbsp;
<i>750</i>&nbsp;        // Suppress this method in backtraces displayed to the user.
<b class="nc"><i>751</i>&nbsp;        mv.visitAnnotation(LF_HIDDEN_SIG, true);</b>
<i>752</i>&nbsp;
<i>753</i>&nbsp;        // Mark this method as a compiled LambdaForm
<b class="nc"><i>754</i>&nbsp;        mv.visitAnnotation(LF_COMPILED_SIG, true);</b>
<b class="nc"><i>755</i>&nbsp;</b>
<b class="nc"><i>756</i>&nbsp;        if (lambdaForm.forceInline) {</b>
<b class="nc"><i>757</i>&nbsp;            // Force inlining of this invoker method.</b>
<i>758</i>&nbsp;            mv.visitAnnotation(FORCEINLINE_SIG, true);
<i>759</i>&nbsp;        } else {
<i>760</i>&nbsp;            mv.visitAnnotation(DONTINLINE_SIG, true);
<i>761</i>&nbsp;        }
<i>762</i>&nbsp;
<i>763</i>&nbsp;        constantPlaceholder(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.
<i>764</i>&nbsp;
<i>765</i>&nbsp;        if (lambdaForm.customized != null) {
<i>766</i>&nbsp;            // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
<i>767</i>&nbsp;            // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
<b class="nc"><i>768</i>&nbsp;            // It enables more efficient code generation in some situations, since embedded constants</b>
<i>769</i>&nbsp;            // are compile-time constants for JIT compiler.
<i>770</i>&nbsp;            mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));
<b class="nc"><i>771</i>&nbsp;            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);</b>
<b class="nc"><i>772</i>&nbsp;            assert(checkActualReceiver()); // expects MethodHandle on top of the stack</b>
<i>773</i>&nbsp;            mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
<i>774</i>&nbsp;        }
<b class="nc"><i>775</i>&nbsp;</b>
<i>776</i>&nbsp;        // iterate over the form&#39;s names, generating bytecode instructions for each
<i>777</i>&nbsp;        // start iterating at the first name following the arguments
<i>778</i>&nbsp;        Name onStack = null;
<i>779</i>&nbsp;        for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {
<i>780</i>&nbsp;            Name name = lambdaForm.names[i];
<i>781</i>&nbsp;
<i>782</i>&nbsp;            emitStoreResult(onStack);
<i>783</i>&nbsp;            onStack = name;  // unless otherwise modified below
<b class="nc"><i>784</i>&nbsp;            MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();</b>
<i>785</i>&nbsp;            switch (intr) {
<i>786</i>&nbsp;                case SELECT_ALTERNATIVE:
<i>787</i>&nbsp;                    assert lambdaForm.isSelectAlternative(i);
<b class="nc"><i>788</i>&nbsp;                    if (PROFILE_GWT) {</b>
<b class="nc"><i>789</i>&nbsp;                        assert(name.arguments[0] instanceof Name &amp;&amp;</b>
<b class="nc"><i>790</i>&nbsp;                                ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, &quot;profileBoolean&quot;));</b>
<b class="nc"><i>791</i>&nbsp;                        mv.visitAnnotation(INJECTEDPROFILE_SIG, true);</b>
<b class="nc"><i>792</i>&nbsp;                    }</b>
<b class="nc"><i>793</i>&nbsp;                    onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);</b>
<b class="nc"><i>794</i>&nbsp;                    i++;  // skip MH.invokeBasic of the selectAlternative result</b>
<b class="nc"><i>795</i>&nbsp;                    continue;</b>
<b class="nc"><i>796</i>&nbsp;                case GUARD_WITH_CATCH:</b>
<b class="nc"><i>797</i>&nbsp;                    assert lambdaForm.isGuardWithCatch(i);</b>
<b class="nc"><i>798</i>&nbsp;                    onStack = emitGuardWithCatch(i);</b>
<b class="nc"><i>799</i>&nbsp;                    i += 2; // jump to the end of GWC idiom</b>
<b class="nc"><i>800</i>&nbsp;                    continue;</b>
<b class="nc"><i>801</i>&nbsp;                case TRY_FINALLY:</b>
<b class="nc"><i>802</i>&nbsp;                    assert lambdaForm.isTryFinally(i);</b>
<b class="nc"><i>803</i>&nbsp;                    onStack = emitTryFinally(i);</b>
<b class="nc"><i>804</i>&nbsp;                    i += 2; // jump to the end of the TF idiom</b>
<b class="nc"><i>805</i>&nbsp;                    continue;</b>
<b class="nc"><i>806</i>&nbsp;                case LOOP:</b>
<b class="nc"><i>807</i>&nbsp;                    assert lambdaForm.isLoop(i);</b>
<b class="nc"><i>808</i>&nbsp;                    onStack = emitLoop(i);</b>
<b class="nc"><i>809</i>&nbsp;                    i += 2; // jump to the end of the LOOP idiom</b>
<i>810</i>&nbsp;                    continue;
<i>811</i>&nbsp;                case NEW_ARRAY:
<i>812</i>&nbsp;                    Class&lt;?&gt; rtype = name.function.methodType().returnType();
<b class="nc"><i>813</i>&nbsp;                    if (isStaticallyNameable(rtype)) {</b>
<b class="nc"><i>814</i>&nbsp;                        emitNewArray(name);</b>
<b class="nc"><i>815</i>&nbsp;                        continue;</b>
<b class="nc"><i>816</i>&nbsp;                    }</b>
<b class="nc"><i>817</i>&nbsp;                    break;</b>
<b class="nc"><i>818</i>&nbsp;                case ARRAY_LOAD:</b>
<b class="nc"><i>819</i>&nbsp;                    emitArrayLoad(name);</b>
<b class="nc"><i>820</i>&nbsp;                    continue;</b>
<i>821</i>&nbsp;                case ARRAY_STORE:
<b class="nc"><i>822</i>&nbsp;                    emitArrayStore(name);</b>
<b class="nc"><i>823</i>&nbsp;                    continue;</b>
<b class="nc"><i>824</i>&nbsp;                case ARRAY_LENGTH:</b>
<b class="nc"><i>825</i>&nbsp;                    emitArrayLength(name);</b>
<b class="nc"><i>826</i>&nbsp;                    continue;</b>
<b class="nc"><i>827</i>&nbsp;                case IDENTITY:</b>
<b class="nc"><i>828</i>&nbsp;                    assert(name.arguments.length == 1);</b>
<b class="nc"><i>829</i>&nbsp;                    emitPushArguments(name, 0);</b>
<b class="nc"><i>830</i>&nbsp;                    continue;</b>
<i>831</i>&nbsp;                case ZERO:
<b class="nc"><i>832</i>&nbsp;                    assert(name.arguments.length == 0);</b>
<i>833</i>&nbsp;                    emitConst(name.type.basicTypeWrapper().zero());
<i>834</i>&nbsp;                    continue;
<i>835</i>&nbsp;                case NONE:
<b class="nc"><i>836</i>&nbsp;                    // no intrinsic associated</b>
<i>837</i>&nbsp;                    break;
<i>838</i>&nbsp;                default:
<i>839</i>&nbsp;                    throw newInternalError(&quot;Unknown intrinsic: &quot;+intr);
<i>840</i>&nbsp;            }
<i>841</i>&nbsp;
<i>842</i>&nbsp;            MemberName member = name.function.member();
<b class="nc"><i>843</i>&nbsp;            if (isStaticallyInvocable(member)) {</b>
<b class="nc"><i>844</i>&nbsp;                emitStaticInvoke(member, name);</b>
<b class="nc"><i>845</i>&nbsp;            } else {</b>
<b class="nc"><i>846</i>&nbsp;                emitInvoke(name);</b>
<i>847</i>&nbsp;            }
<b class="nc"><i>848</i>&nbsp;        }</b>
<b class="nc"><i>849</i>&nbsp;</b>
<i>850</i>&nbsp;        // return statement
<b class="nc"><i>851</i>&nbsp;        emitReturn(onStack);</b>
<b class="nc"><i>852</i>&nbsp;</b>
<i>853</i>&nbsp;        methodEpilogue();
<i>854</i>&nbsp;    }
<b class="nc"><i>855</i>&nbsp;</b>
<i>856</i>&nbsp;    /*
<i>857</i>&nbsp;     * @throws BytecodeGenerationException if something goes wrong when
<b class="nc"><i>858</i>&nbsp;     *         generating the byte code</b>
<i>859</i>&nbsp;     */
<i>860</i>&nbsp;    private byte[] toByteArray() {
<i>861</i>&nbsp;        try {
<b class="nc"><i>862</i>&nbsp;            return cw.toByteArray();</b>
<i>863</i>&nbsp;        } catch (RuntimeException e) {
<i>864</i>&nbsp;            throw new BytecodeGenerationException(e);
<b class="nc"><i>865</i>&nbsp;        }</b>
<b class="nc"><i>866</i>&nbsp;    }</b>
<b class="nc"><i>867</i>&nbsp;</b>
<b class="nc"><i>868</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<i>869</i>&nbsp;    static final class BytecodeGenerationException extends RuntimeException {
<b class="nc"><i>870</i>&nbsp;        BytecodeGenerationException(Exception cause) {</b>
<b class="nc"><i>871</i>&nbsp;            super(cause);</b>
<i>872</i>&nbsp;        }
<i>873</i>&nbsp;    }
<b class="nc"><i>874</i>&nbsp;</b>
<b class="nc"><i>875</i>&nbsp;    void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }</b>
<b class="nc"><i>876</i>&nbsp;    void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }</b>
<b class="nc"><i>877</i>&nbsp;    void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }</b>
<b class="nc"><i>878</i>&nbsp;</b>
<i>879</i>&nbsp;    void emitArrayOp(Name name, int arrayOpcode) {
<i>880</i>&nbsp;        assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;
<i>881</i>&nbsp;        Class&lt;?&gt; elementType = name.function.methodType().parameterType(0).getComponentType();
<i>882</i>&nbsp;        assert elementType != null;
<i>883</i>&nbsp;        emitPushArguments(name, 0);
<b class="nc"><i>884</i>&nbsp;        if (arrayOpcode != Opcodes.ARRAYLENGTH &amp;&amp; elementType.isPrimitive()) {</b>
<b class="nc"><i>885</i>&nbsp;            Wrapper w = Wrapper.forPrimitiveType(elementType);</b>
<i>886</i>&nbsp;            arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);
<i>887</i>&nbsp;        }
<i>888</i>&nbsp;        mv.visitInsn(arrayOpcode);
<b class="nc"><i>889</i>&nbsp;    }</b>
<b class="nc"><i>890</i>&nbsp;</b>
<b class="nc"><i>891</i>&nbsp;    /**</b>
<b class="nc"><i>892</i>&nbsp;     * Emit an invoke for the given name.</b>
<b class="nc"><i>893</i>&nbsp;     */</b>
<b class="nc"><i>894</i>&nbsp;    void emitInvoke(Name name) {</b>
<b class="nc"><i>895</i>&nbsp;        assert(!name.isLinkerMethodInvoke());  // should use the static path for these</b>
<b class="nc"><i>896</i>&nbsp;        if (true) {</b>
<i>897</i>&nbsp;            // push receiver
<i>898</i>&nbsp;            MethodHandle target = name.function.resolvedHandle();
<b class="nc"><i>899</i>&nbsp;            assert(target != null) : name.exprString();</b>
<b class="nc"><i>900</i>&nbsp;            mv.visitLdcInsn(constantPlaceholder(target));</b>
<b class="nc"><i>901</i>&nbsp;            emitReferenceCast(MethodHandle.class, target);</b>
<b class="nc"><i>902</i>&nbsp;        } else {</b>
<b class="nc"><i>903</i>&nbsp;            // load receiver</b>
<b class="nc"><i>904</i>&nbsp;            emitAloadInsn(0);</b>
<i>905</i>&nbsp;            emitReferenceCast(MethodHandle.class, null);
<b class="nc"><i>906</i>&nbsp;            mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);</b>
<b class="nc"><i>907</i>&nbsp;            mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);</b>
<b class="nc"><i>908</i>&nbsp;            // TODO more to come</b>
<i>909</i>&nbsp;        }
<i>910</i>&nbsp;
<b class="nc"><i>911</i>&nbsp;        // push arguments</b>
<b class="nc"><i>912</i>&nbsp;        emitPushArguments(name, 0);</b>
<b class="nc"><i>913</i>&nbsp;</b>
<b class="nc"><i>914</i>&nbsp;        // invocation</b>
<b class="nc"><i>915</i>&nbsp;        MethodType type = name.function.methodType();</b>
<i>916</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
<i>917</i>&nbsp;    }
<b class="nc"><i>918</i>&nbsp;</b>
<i>919</i>&nbsp;    private static Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {
<i>920</i>&nbsp;        // Sample classes from each package we are willing to bind to statically:
<b class="nc"><i>921</i>&nbsp;        java.lang.Object.class,</b>
<b class="nc"><i>922</i>&nbsp;        java.util.Arrays.class,</b>
<b class="nc"><i>923</i>&nbsp;        jdk.internal.misc.Unsafe.class</b>
<b class="nc"><i>924</i>&nbsp;        //MethodHandle.class already covered</b>
<b class="nc"><i>925</i>&nbsp;    };</b>
<b class="nc"><i>926</i>&nbsp;</b>
<b class="nc"><i>927</i>&nbsp;    static boolean isStaticallyInvocable(NamedFunction ... functions) {</b>
<b class="nc"><i>928</i>&nbsp;        for (NamedFunction nf : functions) {</b>
<b class="nc"><i>929</i>&nbsp;            if (!isStaticallyInvocable(nf.member())) {</b>
<i>930</i>&nbsp;                return false;
<b class="nc"><i>931</i>&nbsp;            }</b>
<i>932</i>&nbsp;        }
<i>933</i>&nbsp;        return true;
<i>934</i>&nbsp;    }
<i>935</i>&nbsp;
<i>936</i>&nbsp;    static boolean isStaticallyInvocable(Name name) {
<i>937</i>&nbsp;        return isStaticallyInvocable(name.function.member());
<b class="nc"><i>938</i>&nbsp;    }</b>
<b class="nc"><i>939</i>&nbsp;</b>
<b class="nc"><i>940</i>&nbsp;    static boolean isStaticallyInvocable(MemberName member) {</b>
<i>941</i>&nbsp;        if (member == null)  return false;
<i>942</i>&nbsp;        if (member.isConstructor())  return false;
<b class="nc"><i>943</i>&nbsp;        Class&lt;?&gt; cls = member.getDeclaringClass();</b>
<b class="nc"><i>944</i>&nbsp;        // Fast-path non-private members declared by MethodHandles, which is a common</b>
<i>945</i>&nbsp;        // case
<i>946</i>&nbsp;        if (MethodHandle.class.isAssignableFrom(cls) &amp;&amp; !member.isPrivate()) {
<i>947</i>&nbsp;            assert(isStaticallyInvocableType(member.getMethodOrFieldType()));
<i>948</i>&nbsp;            return true;
<i>949</i>&nbsp;        }
<i>950</i>&nbsp;        if (cls.isArray() || cls.isPrimitive())
<b class="nc"><i>951</i>&nbsp;            return false;  // FIXME</b>
<b class="nc"><i>952</i>&nbsp;        if (cls.isAnonymousClass() || cls.isLocalClass())</b>
<b class="nc"><i>953</i>&nbsp;            return false;  // inner class of some sort</b>
<b class="nc"><i>954</i>&nbsp;        if (cls.getClassLoader() != MethodHandle.class.getClassLoader())</b>
<b class="nc"><i>955</i>&nbsp;            return false;  // not on BCP</b>
<b class="nc"><i>956</i>&nbsp;        if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</b>
<b class="nc"><i>957</i>&nbsp;            return false;</b>
<i>958</i>&nbsp;        if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
<i>959</i>&nbsp;            return false;
<i>960</i>&nbsp;        if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
<i>961</i>&nbsp;            return true;   // in java.lang.invoke package
<i>962</i>&nbsp;        if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))
<i>963</i>&nbsp;            return true;
<b class="nc"><i>964</i>&nbsp;        return false;</b>
<b class="nc"><i>965</i>&nbsp;    }</b>
<b class="nc"><i>966</i>&nbsp;</b>
<b class="nc"><i>967</i>&nbsp;    private static boolean isStaticallyInvocableType(MethodType mtype) {</b>
<b class="nc"><i>968</i>&nbsp;        if (!isStaticallyNameable(mtype.returnType()))</b>
<b class="nc"><i>969</i>&nbsp;            return false;</b>
<b class="nc"><i>970</i>&nbsp;        for (Class&lt;?&gt; ptype : mtype.parameterArray())</b>
<b class="nc"><i>971</i>&nbsp;            if (!isStaticallyNameable(ptype))</b>
<b class="nc"><i>972</i>&nbsp;                return false;</b>
<i>973</i>&nbsp;        return true;
<i>974</i>&nbsp;    }
<i>975</i>&nbsp;
<i>976</i>&nbsp;    static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
<i>977</i>&nbsp;        if (cls == Object.class)
<i>978</i>&nbsp;            return true;
<i>979</i>&nbsp;        if (MethodHandle.class.isAssignableFrom(cls)) {
<i>980</i>&nbsp;            assert(!ReflectUtil.isVMAnonymousClass(cls));
<i>981</i>&nbsp;            return true;
<b class="nc"><i>982</i>&nbsp;        }</b>
<b class="nc"><i>983</i>&nbsp;        while (cls.isArray())</b>
<b class="nc"><i>984</i>&nbsp;            cls = cls.getComponentType();</b>
<b class="nc"><i>985</i>&nbsp;        if (cls.isPrimitive())</b>
<b class="nc"><i>986</i>&nbsp;            return true;  // int[].class, for example</b>
<b class="nc"><i>987</i>&nbsp;        if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</b>
<b class="nc"><i>988</i>&nbsp;            return false;</b>
<i>989</i>&nbsp;        // could use VerifyAccess.isClassAccessible but the following is a safe approximation
<i>990</i>&nbsp;        if (cls.getClassLoader() != Object.class.getClassLoader())
<i>991</i>&nbsp;            return false;
<i>992</i>&nbsp;        if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
<i>993</i>&nbsp;            return true;
<i>994</i>&nbsp;        if (!Modifier.isPublic(cls.getModifiers()))
<i>995</i>&nbsp;            return false;
<i>996</i>&nbsp;        for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {
<i>997</i>&nbsp;            if (VerifyAccess.isSamePackage(pkgcls, cls))
<i>998</i>&nbsp;                return true;
<b class="nc"><i>999</i>&nbsp;        }</b>
<b class="nc"><i>1000</i>&nbsp;        return false;</b>
<b class="nc"><i>1001</i>&nbsp;    }</b>
<b class="nc"><i>1002</i>&nbsp;</b>
<b class="nc"><i>1003</i>&nbsp;    void emitStaticInvoke(Name name) {</b>
<b class="nc"><i>1004</i>&nbsp;        emitStaticInvoke(name.function.member(), name);</b>
<b class="nc"><i>1005</i>&nbsp;    }</b>
<b class="nc"><i>1006</i>&nbsp;</b>
<b class="nc"><i>1007</i>&nbsp;    /**</b>
<b class="nc"><i>1008</i>&nbsp;     * Emit an invoke for the given name, using the MemberName directly.</b>
<b class="nc"><i>1009</i>&nbsp;     */</b>
<i>1010</i>&nbsp;    void emitStaticInvoke(MemberName member, Name name) {
<i>1011</i>&nbsp;        assert(member.equals(name.function.member()));
<i>1012</i>&nbsp;        Class&lt;?&gt; defc = member.getDeclaringClass();
<i>1013</i>&nbsp;        String cname = getInternalName(defc);
<i>1014</i>&nbsp;        String mname = member.getName();
<i>1015</i>&nbsp;        String mtype;
<i>1016</i>&nbsp;        byte refKind = member.getReferenceKind();
<i>1017</i>&nbsp;        if (refKind == REF_invokeSpecial) {
<i>1018</i>&nbsp;            // in order to pass the verifier, we need to convert this to invokevirtual in all cases
<i>1019</i>&nbsp;            assert(member.canBeStaticallyBound()) : member;
<i>1020</i>&nbsp;            refKind = REF_invokeVirtual;
<i>1021</i>&nbsp;        }
<i>1022</i>&nbsp;
<i>1023</i>&nbsp;        assert(!(member.getDeclaringClass().isInterface() &amp;&amp; refKind == REF_invokeVirtual));
<b class="nc"><i>1024</i>&nbsp;</b>
<i>1025</i>&nbsp;        // push arguments
<b class="nc"><i>1026</i>&nbsp;        emitPushArguments(name, 0);</b>
<i>1027</i>&nbsp;
<b class="nc"><i>1028</i>&nbsp;        // invocation</b>
<b class="nc"><i>1029</i>&nbsp;        if (member.isMethod()) {</b>
<i>1030</i>&nbsp;            mtype = member.getMethodType().toMethodDescriptorString();
<i>1031</i>&nbsp;            mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,
<b class="nc"><i>1032</i>&nbsp;                               member.getDeclaringClass().isInterface());</b>
<i>1033</i>&nbsp;        } else {
<i>1034</i>&nbsp;            mtype = MethodType.toFieldDescriptorString(member.getFieldType());
<b class="nc"><i>1035</i>&nbsp;            mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);</b>
<i>1036</i>&nbsp;        }
<i>1037</i>&nbsp;        // Issue a type assertion for the result, so we can avoid casts later.
<b class="nc"><i>1038</i>&nbsp;        if (name.type == L_TYPE) {</b>
<b class="nc"><i>1039</i>&nbsp;            Class&lt;?&gt; rtype = member.getInvocationType().returnType();</b>
<b class="nc"><i>1040</i>&nbsp;            assert(!rtype.isPrimitive());</b>
<b class="nc"><i>1041</i>&nbsp;            if (rtype != Object.class &amp;&amp; !rtype.isInterface()) {</b>
<i>1042</i>&nbsp;                assertStaticType(rtype, name);
<i>1043</i>&nbsp;            }
<b class="nc"><i>1044</i>&nbsp;        }</b>
<i>1045</i>&nbsp;    }
<i>1046</i>&nbsp;
<b class="nc"><i>1047</i>&nbsp;    void emitNewArray(Name name) throws InternalError {</b>
<i>1048</i>&nbsp;        Class&lt;?&gt; rtype = name.function.methodType().returnType();
<i>1049</i>&nbsp;        if (name.arguments.length == 0) {
<b class="nc"><i>1050</i>&nbsp;            // The array will be a constant.</b>
<b class="nc"><i>1051</i>&nbsp;            Object emptyArray;</b>
<b class="nc"><i>1052</i>&nbsp;            try {</b>
<b class="nc"><i>1053</i>&nbsp;                emptyArray = name.function.resolvedHandle().invoke();</b>
<i>1054</i>&nbsp;            } catch (Throwable ex) {
<i>1055</i>&nbsp;                throw uncaughtException(ex);
<b class="nc"><i>1056</i>&nbsp;            }</b>
<i>1057</i>&nbsp;            assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
<b class="nc"><i>1058</i>&nbsp;            assert(emptyArray.getClass() == rtype);  // exact typing</b>
<i>1059</i>&nbsp;            mv.visitLdcInsn(constantPlaceholder(emptyArray));
<b class="nc"><i>1060</i>&nbsp;            emitReferenceCast(rtype, emptyArray);</b>
<i>1061</i>&nbsp;            return;
<i>1062</i>&nbsp;        }
<i>1063</i>&nbsp;        Class&lt;?&gt; arrayElementType = rtype.getComponentType();
<i>1064</i>&nbsp;        assert(arrayElementType != null);
<i>1065</i>&nbsp;        emitIconstInsn(name.arguments.length);
<i>1066</i>&nbsp;        int xas = Opcodes.AASTORE;
<i>1067</i>&nbsp;        if (!arrayElementType.isPrimitive()) {
<i>1068</i>&nbsp;            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));
<i>1069</i>&nbsp;        } else {
<i>1070</i>&nbsp;            byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));
<i>1071</i>&nbsp;            xas = arrayInsnOpcode(tc, xas);
<i>1072</i>&nbsp;            mv.visitIntInsn(Opcodes.NEWARRAY, tc);
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;        // store arguments
<i>1075</i>&nbsp;        for (int i = 0; i &lt; name.arguments.length; i++) {
<i>1076</i>&nbsp;            mv.visitInsn(Opcodes.DUP);
<i>1077</i>&nbsp;            emitIconstInsn(i);
<i>1078</i>&nbsp;            emitPushArgument(name, i);
<i>1079</i>&nbsp;            mv.visitInsn(xas);
<i>1080</i>&nbsp;        }
<i>1081</i>&nbsp;        // the array is left on the stack
<i>1082</i>&nbsp;        assertStaticType(rtype, name);
<i>1083</i>&nbsp;    }
<b class="nc"><i>1084</i>&nbsp;    int refKindOpcode(byte refKind) {</b>
<b class="nc"><i>1085</i>&nbsp;        switch (refKind) {</b>
<b class="nc"><i>1086</i>&nbsp;        case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;</b>
<i>1087</i>&nbsp;        case REF_invokeStatic:       return Opcodes.INVOKESTATIC;
<b class="nc"><i>1088</i>&nbsp;        case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;</b>
<b class="nc"><i>1089</i>&nbsp;        case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;</b>
<b class="nc"><i>1090</i>&nbsp;        case REF_getField:           return Opcodes.GETFIELD;</b>
<b class="nc"><i>1091</i>&nbsp;        case REF_putField:           return Opcodes.PUTFIELD;</b>
<i>1092</i>&nbsp;        case REF_getStatic:          return Opcodes.GETSTATIC;
<b class="nc"><i>1093</i>&nbsp;        case REF_putStatic:          return Opcodes.PUTSTATIC;</b>
<b class="nc"><i>1094</i>&nbsp;        }</b>
<b class="nc"><i>1095</i>&nbsp;        throw new InternalError(&quot;refKind=&quot;+refKind);</b>
<b class="nc"><i>1096</i>&nbsp;    }</b>
<i>1097</i>&nbsp;
<b class="nc"><i>1098</i>&nbsp;    /**</b>
<i>1099</i>&nbsp;     * Emit bytecode for the selectAlternative idiom.
<i>1100</i>&nbsp;     *
<b class="nc"><i>1101</i>&nbsp;     * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithTest):</b>
<i>1102</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<b class="nc"><i>1103</i>&nbsp;     *   Lambda(a0:L,a1:I)=&gt;{</b>
<b class="nc"><i>1104</i>&nbsp;     *     t2:I=foo.test(a1:I);</b>
<b class="nc"><i>1105</i>&nbsp;     *     t3:L=MethodHandleImpl.selectAlternative(t2:I,(MethodHandle(int)int),(MethodHandle(int)int));</b>
<b class="nc"><i>1106</i>&nbsp;     *     t4:I=MethodHandle.invokeBasic(t3:L,a1:I);t4:I}</b>
<b class="nc"><i>1107</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<i>1108</i>&nbsp;     */
<i>1109</i>&nbsp;    private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {
<b class="nc"><i>1110</i>&nbsp;        assert isStaticallyInvocable(invokeBasicName);</b>
<i>1111</i>&nbsp;
<i>1112</i>&nbsp;        Name receiver = (Name) invokeBasicName.arguments[0];
<b class="nc"><i>1113</i>&nbsp;</b>
<i>1114</i>&nbsp;        Label L_fallback = new Label();
<b class="nc"><i>1115</i>&nbsp;        Label L_done     = new Label();</b>
<b class="nc"><i>1116</i>&nbsp;</b>
<b class="nc"><i>1117</i>&nbsp;        // load test result</b>
<b class="nc"><i>1118</i>&nbsp;        emitPushArgument(selectAlternativeName, 0);</b>
<b class="nc"><i>1119</i>&nbsp;</b>
<i>1120</i>&nbsp;        // if_icmpne L_fallback
<i>1121</i>&nbsp;        mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);
<i>1122</i>&nbsp;
<b class="nc"><i>1123</i>&nbsp;        // invoke selectAlternativeName.arguments[1]</b>
<b class="nc"><i>1124</i>&nbsp;        Class&lt;?&gt;[] preForkClasses = localClasses.clone();</b>
<b class="nc"><i>1125</i>&nbsp;        emitPushArgument(selectAlternativeName, 1);  // get 2nd argument of selectAlternative</b>
<b class="nc"><i>1126</i>&nbsp;        emitAstoreInsn(receiver.index());  // store the MH in the receiver slot</b>
<b class="nc"><i>1127</i>&nbsp;        emitStaticInvoke(invokeBasicName);</b>
<b class="nc"><i>1128</i>&nbsp;</b>
<i>1129</i>&nbsp;        // goto L_done
<b class="nc"><i>1130</i>&nbsp;        mv.visitJumpInsn(Opcodes.GOTO, L_done);</b>
<b class="nc"><i>1131</i>&nbsp;</b>
<i>1132</i>&nbsp;        // L_fallback:
<b class="nc"><i>1133</i>&nbsp;        mv.visitLabel(L_fallback);</b>
<i>1134</i>&nbsp;
<b class="nc"><i>1135</i>&nbsp;        // invoke selectAlternativeName.arguments[2]</b>
<i>1136</i>&nbsp;        System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);
<i>1137</i>&nbsp;        emitPushArgument(selectAlternativeName, 2);  // get 3rd argument of selectAlternative
<i>1138</i>&nbsp;        emitAstoreInsn(receiver.index());  // store the MH in the receiver slot
<b class="nc"><i>1139</i>&nbsp;        emitStaticInvoke(invokeBasicName);</b>
<i>1140</i>&nbsp;
<i>1141</i>&nbsp;        // L_done:
<i>1142</i>&nbsp;        mv.visitLabel(L_done);
<b class="nc"><i>1143</i>&nbsp;        // for now do not bother to merge typestate; just reset to the dominator state</b>
<b class="nc"><i>1144</i>&nbsp;        System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);</b>
<i>1145</i>&nbsp;
<i>1146</i>&nbsp;        return invokeBasicName;  // return what&#39;s on stack
<i>1147</i>&nbsp;    }
<i>1148</i>&nbsp;
<b class="nc"><i>1149</i>&nbsp;    /**</b>
<b class="nc"><i>1150</i>&nbsp;      * Emit bytecode for the guardWithCatch idiom.</b>
<b class="nc"><i>1151</i>&nbsp;      *</b>
<i>1152</i>&nbsp;      * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithCatch):
<i>1153</i>&nbsp;      * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1154</i>&nbsp;      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L,a6:L,a7:L)=&gt;{
<b class="nc"><i>1155</i>&nbsp;      *    t8:L=MethodHandle.invokeBasic(a4:L,a6:L,a7:L);</b>
<b class="nc"><i>1156</i>&nbsp;      *    t9:L=MethodHandleImpl.guardWithCatch(a1:L,a2:L,a3:L,t8:L);</b>
<b class="nc"><i>1157</i>&nbsp;      *   t10:I=MethodHandle.invokeBasic(a5:L,t9:L);t10:I}</b>
<b class="nc"><i>1158</i>&nbsp;      * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1159</i>&nbsp;      *</b>
<b class="nc"><i>1160</i>&nbsp;      * It is compiled into bytecode equivalent of the following code:</b>
<b class="nc"><i>1161</i>&nbsp;      * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<i>1162</i>&nbsp;      *  try {
<b class="nc"><i>1163</i>&nbsp;      *      return a1.invokeBasic(a6, a7);</b>
<b class="nc"><i>1164</i>&nbsp;      *  } catch (Throwable e) {</b>
<i>1165</i>&nbsp;      *      if (!a2.isInstance(e)) throw e;
<b class="nc"><i>1166</i>&nbsp;      *      return a3.invokeBasic(ex, a6, a7);</b>
<b class="nc"><i>1167</i>&nbsp;      *  }}</b>
<i>1168</i>&nbsp;      */
<i>1169</i>&nbsp;    private Name emitGuardWithCatch(int pos) {
<i>1170</i>&nbsp;        Name args    = lambdaForm.names[pos];
<i>1171</i>&nbsp;        Name invoker = lambdaForm.names[pos+1];
<i>1172</i>&nbsp;        Name result  = lambdaForm.names[pos+2];
<i>1173</i>&nbsp;
<i>1174</i>&nbsp;        Label L_startBlock = new Label();
<i>1175</i>&nbsp;        Label L_endBlock = new Label();
<b class="nc"><i>1176</i>&nbsp;        Label L_handler = new Label();</b>
<i>1177</i>&nbsp;        Label L_done = new Label();
<b class="nc"><i>1178</i>&nbsp;</b>
<i>1179</i>&nbsp;        Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
<i>1180</i>&nbsp;        MethodType type = args.function.resolvedHandle().type()
<i>1181</i>&nbsp;                              .dropParameterTypes(0,1)
<i>1182</i>&nbsp;                              .changeReturnType(returnType);
<i>1183</i>&nbsp;
<i>1184</i>&nbsp;        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, &quot;java/lang/Throwable&quot;);
<i>1185</i>&nbsp;
<i>1186</i>&nbsp;        // Normal case
<b class="nc"><i>1187</i>&nbsp;        mv.visitLabel(L_startBlock);</b>
<b class="nc"><i>1188</i>&nbsp;        // load target</b>
<b class="nc"><i>1189</i>&nbsp;        emitPushArgument(invoker, 0);</b>
<b class="nc"><i>1190</i>&nbsp;        emitPushArguments(args, 1); // skip 1st argument: method handle</b>
<i>1191</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
<b class="nc"><i>1192</i>&nbsp;        mv.visitLabel(L_endBlock);</b>
<i>1193</i>&nbsp;        mv.visitJumpInsn(Opcodes.GOTO, L_done);
<i>1194</i>&nbsp;
<b class="nc"><i>1195</i>&nbsp;        // Exceptional case</b>
<i>1196</i>&nbsp;        mv.visitLabel(L_handler);
<i>1197</i>&nbsp;
<b class="nc"><i>1198</i>&nbsp;        // Check exception&#39;s type</b>
<b class="nc"><i>1199</i>&nbsp;        mv.visitInsn(Opcodes.DUP);</b>
<i>1200</i>&nbsp;        // load exception class
<i>1201</i>&nbsp;        emitPushArgument(invoker, 1);
<b class="nc"><i>1202</i>&nbsp;        mv.visitInsn(Opcodes.SWAP);</b>
<i>1203</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;isInstance&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false);
<i>1204</i>&nbsp;        Label L_rethrow = new Label();
<b class="nc"><i>1205</i>&nbsp;        mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);</b>
<i>1206</i>&nbsp;
<i>1207</i>&nbsp;        // Invoke catcher
<i>1208</i>&nbsp;        // load catcher
<i>1209</i>&nbsp;        emitPushArgument(invoker, 2);
<i>1210</i>&nbsp;        mv.visitInsn(Opcodes.SWAP);
<i>1211</i>&nbsp;        emitPushArguments(args, 1); // skip 1st argument: method handle
<i>1212</i>&nbsp;        MethodType catcherType = type.insertParameterTypes(0, Throwable.class);
<i>1213</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, catcherType.basicType().toMethodDescriptorString(), false);
<i>1214</i>&nbsp;        mv.visitJumpInsn(Opcodes.GOTO, L_done);
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;        mv.visitLabel(L_rethrow);
<i>1217</i>&nbsp;        mv.visitInsn(Opcodes.ATHROW);
<i>1218</i>&nbsp;
<i>1219</i>&nbsp;        mv.visitLabel(L_done);
<i>1220</i>&nbsp;
<i>1221</i>&nbsp;        return result;
<i>1222</i>&nbsp;    }
<i>1223</i>&nbsp;
<i>1224</i>&nbsp;    /**
<b class="nc"><i>1225</i>&nbsp;     * Emit bytecode for the tryFinally idiom.</b>
<i>1226</i>&nbsp;     * &lt;p&gt;
<i>1227</i>&nbsp;     * The pattern looks like (Cf. MethodHandleImpl.makeTryFinally):
<i>1228</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<b class="nc"><i>1229</i>&nbsp;     * // a0: BMH</b>
<i>1230</i>&nbsp;     * // a1: target, a2: cleanup
<b class="nc"><i>1231</i>&nbsp;     * // a3: box, a4: unbox</b>
<i>1232</i>&nbsp;     * // a5 (and following): arguments
<i>1233</i>&nbsp;     * tryFinally=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L)=&gt;{
<b class="nc"><i>1234</i>&nbsp;     *   t6:L=MethodHandle.invokeBasic(a3:L,a5:L);         // box the arguments into an Object[]</b>
<i>1235</i>&nbsp;     *   t7:L=MethodHandleImpl.tryFinally(a1:L,a2:L,t6:L); // call the tryFinally executor
<b class="nc"><i>1236</i>&nbsp;     *   t8:L=MethodHandle.invokeBasic(a4:L,t7:L);t8:L}    // unbox the result; return the result</b>
<b class="nc"><i>1237</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<i>1238</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1239</i>&nbsp;     * It is compiled into bytecode equivalent to the following code:</b>
<i>1240</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1241</i>&nbsp;     * Throwable t;
<i>1242</i>&nbsp;     * Object r;
<b class="nc"><i>1243</i>&nbsp;     * try {</b>
<b class="nc"><i>1244</i>&nbsp;     *     r = a1.invokeBasic(a5);</b>
<i>1245</i>&nbsp;     * } catch (Throwable thrown) {
<b class="nc"><i>1246</i>&nbsp;     *     t = thrown;</b>
<b class="nc"><i>1247</i>&nbsp;     *     throw t;</b>
<b class="nc"><i>1248</i>&nbsp;     * } finally {</b>
<b class="nc"><i>1249</i>&nbsp;     *     r = a2.invokeBasic(t, r, a5);</b>
<i>1250</i>&nbsp;     * }
<i>1251</i>&nbsp;     * return r;
<i>1252</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<b class="nc"><i>1253</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1254</i>&nbsp;     * Specifically, the bytecode will have the following form (the stack effects are given for the beginnings of</b>
<b class="nc"><i>1255</i>&nbsp;     * blocks, and for the situations after executing the given instruction - the code will have a slightly different</b>
<b class="nc"><i>1256</i>&nbsp;     * shape if the return type is {@code void}):</b>
<i>1257</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1258</i>&nbsp;     * TRY:                 (--)
<i>1259</i>&nbsp;     *                      load target                             (-- target)
<b class="nc"><i>1260</i>&nbsp;     *                      load args                               (-- args... target)</b>
<b class="nc"><i>1261</i>&nbsp;     *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)</b>
<b class="nc"><i>1262</i>&nbsp;     * FINALLY_NORMAL:      (-- r)</b>
<b class="nc"><i>1263</i>&nbsp;     *                      load cleanup                            (-- cleanup r)</b>
<i>1264</i>&nbsp;     *                      SWAP                                    (-- r cleanup)
<i>1265</i>&nbsp;     *                      ACONST_NULL                             (-- t r cleanup)
<i>1266</i>&nbsp;     *                      SWAP                                    (-- r t cleanup)
<b class="nc"><i>1267</i>&nbsp;     *                      load args                               (-- args... r t cleanup)</b>
<i>1268</i>&nbsp;     *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r)
<i>1269</i>&nbsp;     *                      GOTO DONE
<b class="nc"><i>1270</i>&nbsp;     * CATCH:               (-- t)</b>
<b class="nc"><i>1271</i>&nbsp;     *                      DUP                                     (-- t t)</b>
<i>1272</i>&nbsp;     * FINALLY_EXCEPTIONAL: (-- t t)
<i>1273</i>&nbsp;     *                      load cleanup                            (-- cleanup t t)
<i>1274</i>&nbsp;     *                      SWAP                                    (-- t cleanup t)
<i>1275</i>&nbsp;     *                      load default for r                      (-- r t cleanup t)
<i>1276</i>&nbsp;     *                      load args                               (-- args... r t cleanup t)
<i>1277</i>&nbsp;     *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r t)
<b class="nc"><i>1278</i>&nbsp;     *                      POP                                     (-- t)</b>
<b class="nc"><i>1279</i>&nbsp;     *                      ATHROW</b>
<b class="nc"><i>1280</i>&nbsp;     * DONE:                (-- r)</b>
<b class="nc"><i>1281</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1282</i>&nbsp;     */</b>
<b class="nc"><i>1283</i>&nbsp;    private Name emitTryFinally(int pos) {</b>
<b class="nc"><i>1284</i>&nbsp;        Name args    = lambdaForm.names[pos];</b>
<b class="nc"><i>1285</i>&nbsp;        Name invoker = lambdaForm.names[pos+1];</b>
<i>1286</i>&nbsp;        Name result  = lambdaForm.names[pos+2];
<i>1287</i>&nbsp;
<b class="nc"><i>1288</i>&nbsp;        Label lFrom = new Label();</b>
<b class="nc"><i>1289</i>&nbsp;        Label lTo = new Label();</b>
<b class="nc"><i>1290</i>&nbsp;        Label lCatch = new Label();</b>
<b class="nc"><i>1291</i>&nbsp;        Label lDone = new Label();</b>
<i>1292</i>&nbsp;
<i>1293</i>&nbsp;        Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
<i>1294</i>&nbsp;        boolean isNonVoid = returnType != void.class;
<i>1295</i>&nbsp;        MethodType type = args.function.resolvedHandle().type()
<b class="nc"><i>1296</i>&nbsp;                .dropParameterTypes(0,1)</b>
<b class="nc"><i>1297</i>&nbsp;                .changeReturnType(returnType);</b>
<b class="nc"><i>1298</i>&nbsp;        MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);</b>
<b class="nc"><i>1299</i>&nbsp;        if (isNonVoid) {</b>
<b class="nc"><i>1300</i>&nbsp;            cleanupType = cleanupType.insertParameterTypes(1, returnType);</b>
<i>1301</i>&nbsp;        }
<i>1302</i>&nbsp;        String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();
<i>1303</i>&nbsp;
<i>1304</i>&nbsp;        // exception handler table
<i>1305</i>&nbsp;        mv.visitTryCatchBlock(lFrom, lTo, lCatch, &quot;java/lang/Throwable&quot;);
<i>1306</i>&nbsp;
<i>1307</i>&nbsp;        // TRY:
<b class="nc"><i>1308</i>&nbsp;        mv.visitLabel(lFrom);</b>
<b class="nc"><i>1309</i>&nbsp;        emitPushArgument(invoker, 0); // load target</b>
<b class="nc"><i>1310</i>&nbsp;        emitPushArguments(args, 1); // load args (skip 0: method handle)</b>
<b class="nc"><i>1311</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);</b>
<b class="nc"><i>1312</i>&nbsp;        mv.visitLabel(lTo);</b>
<b class="nc"><i>1313</i>&nbsp;</b>
<i>1314</i>&nbsp;        // FINALLY_NORMAL:
<i>1315</i>&nbsp;        emitPushArgument(invoker, 1); // load cleanup
<i>1316</i>&nbsp;        if (isNonVoid) {
<b class="nc"><i>1317</i>&nbsp;            mv.visitInsn(Opcodes.SWAP);</b>
<i>1318</i>&nbsp;        }
<i>1319</i>&nbsp;        mv.visitInsn(Opcodes.ACONST_NULL);
<b class="nc"><i>1320</i>&nbsp;        if (isNonVoid) {</b>
<i>1321</i>&nbsp;            mv.visitInsn(Opcodes.SWAP);
<i>1322</i>&nbsp;        }
<b class="nc"><i>1323</i>&nbsp;        emitPushArguments(args, 1); // load args (skip 0: method handle)</b>
<i>1324</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
<i>1325</i>&nbsp;        mv.visitJumpInsn(Opcodes.GOTO, lDone);
<b class="nc"><i>1326</i>&nbsp;</b>
<b class="nc"><i>1327</i>&nbsp;        // CATCH:</b>
<i>1328</i>&nbsp;        mv.visitLabel(lCatch);
<i>1329</i>&nbsp;        mv.visitInsn(Opcodes.DUP);
<b class="nc"><i>1330</i>&nbsp;</b>
<b class="nc"><i>1331</i>&nbsp;        // FINALLY_EXCEPTIONAL:</b>
<b class="nc"><i>1332</i>&nbsp;        emitPushArgument(invoker, 1); // load cleanup</b>
<b class="nc"><i>1333</i>&nbsp;        mv.visitInsn(Opcodes.SWAP);</b>
<b class="nc"><i>1334</i>&nbsp;        if (isNonVoid) {</b>
<i>1335</i>&nbsp;            emitZero(BasicType.basicType(returnType)); // load default for result
<b class="nc"><i>1336</i>&nbsp;        }</b>
<b class="nc"><i>1337</i>&nbsp;        emitPushArguments(args, 1); // load args (skip 0: method handle)</b>
<i>1338</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
<b class="nc"><i>1339</i>&nbsp;        if (isNonVoid) {</b>
<i>1340</i>&nbsp;            mv.visitInsn(Opcodes.POP);
<i>1341</i>&nbsp;        }
<b class="nc"><i>1342</i>&nbsp;        mv.visitInsn(Opcodes.ATHROW);</b>
<b class="nc"><i>1343</i>&nbsp;</b>
<b class="nc"><i>1344</i>&nbsp;        // DONE:</b>
<b class="nc"><i>1345</i>&nbsp;        mv.visitLabel(lDone);</b>
<i>1346</i>&nbsp;
<i>1347</i>&nbsp;        return result;
<b class="nc"><i>1348</i>&nbsp;    }</b>
<b class="nc"><i>1349</i>&nbsp;</b>
<b class="nc"><i>1350</i>&nbsp;    /**</b>
<i>1351</i>&nbsp;     * Emit bytecode for the loop idiom.
<i>1352</i>&nbsp;     * &lt;p&gt;
<i>1353</i>&nbsp;     * The pattern looks like (Cf. MethodHandleImpl.loop):
<b class="nc"><i>1354</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<i>1355</i>&nbsp;     * // a0: BMH
<b class="nc"><i>1356</i>&nbsp;     * // a1: LoopClauses (containing an array of arrays: inits, steps, preds, finis)</b>
<b class="nc"><i>1357</i>&nbsp;     * // a2: box, a3: unbox</b>
<i>1358</i>&nbsp;     * // a4 (and following): arguments
<b class="nc"><i>1359</i>&nbsp;     * loop=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L)=&gt;{</b>
<b class="nc"><i>1360</i>&nbsp;     *   t5:L=MethodHandle.invokeBasic(a2:L,a4:L);          // box the arguments into an Object[]</b>
<b class="nc"><i>1361</i>&nbsp;     *   t6:L=MethodHandleImpl.loop(bt:L,a1:L,t5:L);        // call the loop executor (with supplied types in bt)</b>
<i>1362</i>&nbsp;     *   t7:L=MethodHandle.invokeBasic(a3:L,t6:L);t7:L}     // unbox the result; return the result
<i>1363</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1364</i>&nbsp;     * &lt;p&gt;
<i>1365</i>&nbsp;     * It is compiled into bytecode equivalent to the code seen in {@link MethodHandleImpl#loop(BasicType[],
<i>1366</i>&nbsp;     * MethodHandleImpl.LoopClauses, Object...)}, with the difference that no arrays
<i>1367</i>&nbsp;     * will be used for local state storage. Instead, the local state will be mapped to actual stack slots.
<b class="nc"><i>1368</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1369</i>&nbsp;     * Bytecode generation applies an unrolling scheme to enable better bytecode generation regarding local state type</b>
<b class="nc"><i>1370</i>&nbsp;     * handling. The generated bytecode will have the following form ({@code void} types are ignored for convenience).</b>
<b class="nc"><i>1371</i>&nbsp;     * Assume there are {@code C} clauses in the loop.</b>
<i>1372</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1373</i>&nbsp;     * PREINIT: ALOAD_1
<i>1374</i>&nbsp;     *          CHECKCAST LoopClauses
<b class="nc"><i>1375</i>&nbsp;     *          GETFIELD LoopClauses.clauses</b>
<b class="nc"><i>1376</i>&nbsp;     *          ASTORE clauseDataIndex          // place the clauses 2-dimensional array on the stack</b>
<i>1377</i>&nbsp;     * INIT:    (INIT_SEQ for clause 1)
<i>1378</i>&nbsp;     *          ...
<b class="nc"><i>1379</i>&nbsp;     *          (INIT_SEQ for clause C)</b>
<i>1380</i>&nbsp;     * LOOP:    (LOOP_SEQ for clause 1)
<i>1381</i>&nbsp;     *          ...
<b class="nc"><i>1382</i>&nbsp;     *          (LOOP_SEQ for clause C)</b>
<i>1383</i>&nbsp;     *          GOTO LOOP
<i>1384</i>&nbsp;     * DONE:    ...
<b class="nc"><i>1385</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<i>1386</i>&nbsp;     * &lt;p&gt;
<i>1387</i>&nbsp;     * The {@code INIT_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has
<b class="nc"><i>1388</i>&nbsp;     * the following shape. Assume slot {@code vx} is used to hold the state for clause {@code x}.</b>
<b class="nc"><i>1389</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<b class="nc"><i>1390</i>&nbsp;     * INIT_SEQ_x:  ALOAD clauseDataIndex</b>
<b class="nc"><i>1391</i>&nbsp;     *              ICONST_0</b>
<i>1392</i>&nbsp;     *              AALOAD      // load the inits array
<i>1393</i>&nbsp;     *              ICONST x
<b class="nc"><i>1394</i>&nbsp;     *              AALOAD      // load the init handle for clause x</b>
<b class="nc"><i>1395</i>&nbsp;     *              load args</b>
<b class="nc"><i>1396</i>&nbsp;     *              INVOKEVIRTUAL MethodHandle.invokeBasic</b>
<b class="nc"><i>1397</i>&nbsp;     *              store vx</b>
<b class="nc"><i>1398</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1399</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1400</i>&nbsp;     * The {@code LOOP_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has</b>
<i>1401</i>&nbsp;     * the following shape. Again, assume slot {@code vx} is used to hold the state for clause {@code x}.
<i>1402</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1403</i>&nbsp;     * LOOP_SEQ_x:  ALOAD clauseDataIndex
<i>1404</i>&nbsp;     *              ICONST_1
<b class="nc"><i>1405</i>&nbsp;     *              AALOAD              // load the steps array</b>
<b class="nc"><i>1406</i>&nbsp;     *              ICONST x</b>
<i>1407</i>&nbsp;     *              AALOAD              // load the step handle for clause x
<i>1408</i>&nbsp;     *              load locals
<b class="nc"><i>1409</i>&nbsp;     *              load args</b>
<b class="nc"><i>1410</i>&nbsp;     *              INVOKEVIRTUAL MethodHandle.invokeBasic</b>
<b class="nc"><i>1411</i>&nbsp;     *              store vx</b>
<b class="nc"><i>1412</i>&nbsp;     *              ALOAD clauseDataIndex</b>
<i>1413</i>&nbsp;     *              ICONST_2
<b class="nc"><i>1414</i>&nbsp;     *              AALOAD              // load the preds array</b>
<b class="nc"><i>1415</i>&nbsp;     *              ICONST x</b>
<i>1416</i>&nbsp;     *              AALOAD              // load the pred handle for clause x
<i>1417</i>&nbsp;     *              load locals
<i>1418</i>&nbsp;     *              load args
<b class="nc"><i>1419</i>&nbsp;     *              INVOKEVIRTUAL MethodHandle.invokeBasic</b>
<b class="nc"><i>1420</i>&nbsp;     *              IFNE LOOP_SEQ_x+1   // predicate returned false -&gt; jump to next clause</b>
<i>1421</i>&nbsp;     *              ALOAD clauseDataIndex
<b class="nc"><i>1422</i>&nbsp;     *              ICONST_3</b>
<i>1423</i>&nbsp;     *              AALOAD              // load the finis array
<b class="nc"><i>1424</i>&nbsp;     *              ICONST x</b>
<b class="nc"><i>1425</i>&nbsp;     *              AALOAD              // load the fini handle for clause x</b>
<i>1426</i>&nbsp;     *              load locals
<b class="nc"><i>1427</i>&nbsp;     *              load args</b>
<b class="nc"><i>1428</i>&nbsp;     *              INVOKEVIRTUAL MethodHandle.invokeBasic</b>
<b class="nc"><i>1429</i>&nbsp;     *              GOTO DONE           // jump beyond end of clauses to return from loop</b>
<i>1430</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1431</i>&nbsp;     */
<i>1432</i>&nbsp;    private Name emitLoop(int pos) {
<i>1433</i>&nbsp;        Name args    = lambdaForm.names[pos];
<i>1434</i>&nbsp;        Name invoker = lambdaForm.names[pos+1];
<i>1435</i>&nbsp;        Name result  = lambdaForm.names[pos+2];
<i>1436</i>&nbsp;
<b class="nc"><i>1437</i>&nbsp;        // extract clause and loop-local state types</b>
<b class="nc"><i>1438</i>&nbsp;        // find the type info in the loop invocation</b>
<b class="nc"><i>1439</i>&nbsp;        BasicType[] loopClauseTypes = (BasicType[]) invoker.arguments[0];</b>
<b class="nc"><i>1440</i>&nbsp;        Class&lt;?&gt;[] loopLocalStateTypes = Stream.of(loopClauseTypes).</b>
<b class="nc"><i>1441</i>&nbsp;                filter(bt -&gt; bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class&lt;?&gt;[]::new);</b>
<i>1442</i>&nbsp;        Class&lt;?&gt;[] localTypes = new Class&lt;?&gt;[loopLocalStateTypes.length + 1];
<b class="nc"><i>1443</i>&nbsp;        localTypes[0] = MethodHandleImpl.LoopClauses.class;</b>
<b class="nc"><i>1444</i>&nbsp;        System.arraycopy(loopLocalStateTypes, 0, localTypes, 1, loopLocalStateTypes.length);</b>
<b class="nc"><i>1445</i>&nbsp;</b>
<i>1446</i>&nbsp;        final int clauseDataIndex = extendLocalsMap(localTypes);
<i>1447</i>&nbsp;        final int firstLoopStateIndex = clauseDataIndex + 1;
<i>1448</i>&nbsp;
<i>1449</i>&nbsp;        Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
<i>1450</i>&nbsp;        MethodType loopType = args.function.resolvedHandle().type()
<i>1451</i>&nbsp;                .dropParameterTypes(0,1)
<i>1452</i>&nbsp;                .changeReturnType(returnType);
<i>1453</i>&nbsp;        MethodType loopHandleType = loopType.insertParameterTypes(0, loopLocalStateTypes);
<i>1454</i>&nbsp;        MethodType predType = loopHandleType.changeReturnType(boolean.class);
<i>1455</i>&nbsp;        MethodType finiType = loopHandleType;
<i>1456</i>&nbsp;
<i>1457</i>&nbsp;        final int nClauses = loopClauseTypes.length;
<i>1458</i>&nbsp;
<i>1459</i>&nbsp;        // indices to invoker arguments to load method handle arrays
<i>1460</i>&nbsp;        final int inits = 1;
<i>1461</i>&nbsp;        final int steps = 2;
<i>1462</i>&nbsp;        final int preds = 3;
<i>1463</i>&nbsp;        final int finis = 4;
<i>1464</i>&nbsp;
<i>1465</i>&nbsp;        Label lLoop = new Label();
<i>1466</i>&nbsp;        Label lDone = new Label();
<i>1467</i>&nbsp;        Label lNext;
<i>1468</i>&nbsp;
<i>1469</i>&nbsp;        // PREINIT:
<i>1470</i>&nbsp;        emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);
<i>1471</i>&nbsp;        mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, &quot;clauses&quot;, MHARY2);
<i>1472</i>&nbsp;        emitAstoreInsn(clauseDataIndex);
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;        // INIT:
<i>1475</i>&nbsp;        for (int c = 0, state = 0; c &lt; nClauses; ++c) {
<i>1476</i>&nbsp;            MethodType cInitType = loopType.changeReturnType(loopClauseTypes[c].basicTypeClass());
<i>1477</i>&nbsp;            emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,
<i>1478</i>&nbsp;                    firstLoopStateIndex);
<i>1479</i>&nbsp;            if (cInitType.returnType() != void.class) {
<i>1480</i>&nbsp;                emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);
<i>1481</i>&nbsp;                ++state;
<i>1482</i>&nbsp;            }
<i>1483</i>&nbsp;        }
<i>1484</i>&nbsp;
<i>1485</i>&nbsp;        // LOOP:
<i>1486</i>&nbsp;        mv.visitLabel(lLoop);
<i>1487</i>&nbsp;
<i>1488</i>&nbsp;        for (int c = 0, state = 0; c &lt; nClauses; ++c) {
<i>1489</i>&nbsp;            lNext = new Label();
<i>1490</i>&nbsp;
<i>1491</i>&nbsp;            MethodType stepType = loopHandleType.changeReturnType(loopClauseTypes[c].basicTypeClass());
<i>1492</i>&nbsp;            boolean isVoid = stepType.returnType() == void.class;
<i>1493</i>&nbsp;
<i>1494</i>&nbsp;            // invoke loop step
<i>1495</i>&nbsp;            emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,
<i>1496</i>&nbsp;                    firstLoopStateIndex);
<i>1497</i>&nbsp;            if (!isVoid) {
<i>1498</i>&nbsp;                emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);
<i>1499</i>&nbsp;                ++state;
<i>1500</i>&nbsp;            }
<i>1501</i>&nbsp;
<i>1502</i>&nbsp;            // invoke loop predicate
<i>1503</i>&nbsp;            emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,
<i>1504</i>&nbsp;                    firstLoopStateIndex);
<i>1505</i>&nbsp;            mv.visitJumpInsn(Opcodes.IFNE, lNext);
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;            // invoke fini
<i>1508</i>&nbsp;            emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,
<i>1509</i>&nbsp;                    firstLoopStateIndex);
<i>1510</i>&nbsp;            mv.visitJumpInsn(Opcodes.GOTO, lDone);
<i>1511</i>&nbsp;
<i>1512</i>&nbsp;            // this is the beginning of the next loop clause
<i>1513</i>&nbsp;            mv.visitLabel(lNext);
<i>1514</i>&nbsp;        }
<i>1515</i>&nbsp;
<i>1516</i>&nbsp;        mv.visitJumpInsn(Opcodes.GOTO, lLoop);
<i>1517</i>&nbsp;
<i>1518</i>&nbsp;        // DONE:
<i>1519</i>&nbsp;        mv.visitLabel(lDone);
<i>1520</i>&nbsp;
<i>1521</i>&nbsp;        return result;
<i>1522</i>&nbsp;    }
<i>1523</i>&nbsp;
<i>1524</i>&nbsp;    private int extendLocalsMap(Class&lt;?&gt;[] types) {
<i>1525</i>&nbsp;        int firstSlot = localsMap.length - 1;
<i>1526</i>&nbsp;        localsMap = Arrays.copyOf(localsMap, localsMap.length + types.length);
<i>1527</i>&nbsp;        localClasses = Arrays.copyOf(localClasses, localClasses.length + types.length);
<i>1528</i>&nbsp;        System.arraycopy(types, 0, localClasses, firstSlot, types.length);
<i>1529</i>&nbsp;        int index = localsMap[firstSlot - 1] + 1;
<i>1530</i>&nbsp;        int lastSlots = 0;
<i>1531</i>&nbsp;        for (int i = 0; i &lt; types.length; ++i) {
<i>1532</i>&nbsp;            localsMap[firstSlot + i] = index;
<i>1533</i>&nbsp;            lastSlots = BasicType.basicType(localClasses[firstSlot + i]).basicTypeSlots();
<i>1534</i>&nbsp;            index += lastSlots;
<i>1535</i>&nbsp;        }
<i>1536</i>&nbsp;        localsMap[localsMap.length - 1] = index - lastSlots;
<i>1537</i>&nbsp;        return firstSlot;
<i>1538</i>&nbsp;    }
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;    private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,
<i>1541</i>&nbsp;                                      MethodType type, Class&lt;?&gt;[] loopLocalStateTypes, int clauseDataSlot,
<i>1542</i>&nbsp;                                      int firstLoopStateSlot) {
<i>1543</i>&nbsp;        // load handle for clause
<i>1544</i>&nbsp;        emitPushClauseArray(clauseDataSlot, handles);
<i>1545</i>&nbsp;        emitIconstInsn(clause);
<i>1546</i>&nbsp;        mv.visitInsn(Opcodes.AALOAD);
<i>1547</i>&nbsp;        // load loop state (preceding the other arguments)
<i>1548</i>&nbsp;        if (pushLocalState) {
<i>1549</i>&nbsp;            for (int s = 0; s &lt; loopLocalStateTypes.length; ++s) {
<i>1550</i>&nbsp;                emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);
<i>1551</i>&nbsp;            }
<i>1552</i>&nbsp;        }
<i>1553</i>&nbsp;        // load loop args (skip 0: method handle)
<i>1554</i>&nbsp;        emitPushArguments(args, 1);
<i>1555</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.toMethodDescriptorString(), false);
<i>1556</i>&nbsp;    }
<i>1557</i>&nbsp;
<i>1558</i>&nbsp;    private void emitPushClauseArray(int clauseDataSlot, int which) {
<i>1559</i>&nbsp;        emitAloadInsn(clauseDataSlot);
<i>1560</i>&nbsp;        emitIconstInsn(which - 1);
<i>1561</i>&nbsp;        mv.visitInsn(Opcodes.AALOAD);
<i>1562</i>&nbsp;    }
<i>1563</i>&nbsp;
<i>1564</i>&nbsp;    private void emitZero(BasicType type) {
<i>1565</i>&nbsp;        switch (type) {
<i>1566</i>&nbsp;            case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;
<i>1567</i>&nbsp;            case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;
<i>1568</i>&nbsp;            case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;
<i>1569</i>&nbsp;            case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;
<i>1570</i>&nbsp;            case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;
<i>1571</i>&nbsp;            default: throw new InternalError(&quot;unknown type: &quot; + type);
<i>1572</i>&nbsp;        }
<i>1573</i>&nbsp;    }
<i>1574</i>&nbsp;
<i>1575</i>&nbsp;    private void emitPushArguments(Name args, int start) {
<i>1576</i>&nbsp;        MethodType type = args.function.methodType();
<i>1577</i>&nbsp;        for (int i = start; i &lt; args.arguments.length; i++) {
<i>1578</i>&nbsp;            emitPushArgument(type.parameterType(i), args.arguments[i]);
<i>1579</i>&nbsp;        }
<i>1580</i>&nbsp;    }
<i>1581</i>&nbsp;
<i>1582</i>&nbsp;    private void emitPushArgument(Name name, int paramIndex) {
<i>1583</i>&nbsp;        Object arg = name.arguments[paramIndex];
<i>1584</i>&nbsp;        Class&lt;?&gt; ptype = name.function.methodType().parameterType(paramIndex);
<i>1585</i>&nbsp;        emitPushArgument(ptype, arg);
<i>1586</i>&nbsp;    }
<i>1587</i>&nbsp;
<i>1588</i>&nbsp;    private void emitPushArgument(Class&lt;?&gt; ptype, Object arg) {
<i>1589</i>&nbsp;        BasicType bptype = basicType(ptype);
<i>1590</i>&nbsp;        if (arg instanceof Name) {
<i>1591</i>&nbsp;            Name n = (Name) arg;
<i>1592</i>&nbsp;            emitLoadInsn(n.type, n.index());
<i>1593</i>&nbsp;            emitImplicitConversion(n.type, ptype, n);
<i>1594</i>&nbsp;        } else if ((arg == null || arg instanceof String) &amp;&amp; bptype == L_TYPE) {
<i>1595</i>&nbsp;            emitConst(arg);
<i>1596</i>&nbsp;        } else {
<i>1597</i>&nbsp;            if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
<i>1598</i>&nbsp;                emitConst(arg);
<i>1599</i>&nbsp;            } else {
<i>1600</i>&nbsp;                mv.visitLdcInsn(constantPlaceholder(arg));
<i>1601</i>&nbsp;                emitImplicitConversion(L_TYPE, ptype, arg);
<i>1602</i>&nbsp;            }
<i>1603</i>&nbsp;        }
<i>1604</i>&nbsp;    }
<i>1605</i>&nbsp;
<i>1606</i>&nbsp;    /**
<i>1607</i>&nbsp;     * Store the name to its local, if necessary.
<i>1608</i>&nbsp;     */
<i>1609</i>&nbsp;    private void emitStoreResult(Name name) {
<i>1610</i>&nbsp;        if (name != null &amp;&amp; name.type != V_TYPE) {
<i>1611</i>&nbsp;            // non-void: actually assign
<i>1612</i>&nbsp;            emitStoreInsn(name.type, name.index());
<i>1613</i>&nbsp;        }
<i>1614</i>&nbsp;    }
<i>1615</i>&nbsp;
<i>1616</i>&nbsp;    /**
<i>1617</i>&nbsp;     * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
<i>1618</i>&nbsp;     */
<i>1619</i>&nbsp;    private void emitReturn(Name onStack) {
<i>1620</i>&nbsp;        // return statement
<i>1621</i>&nbsp;        Class&lt;?&gt; rclass = invokerType.returnType();
<i>1622</i>&nbsp;        BasicType rtype = lambdaForm.returnType();
<i>1623</i>&nbsp;        assert(rtype == basicType(rclass));  // must agree
<i>1624</i>&nbsp;        if (rtype == V_TYPE) {
<i>1625</i>&nbsp;            // void
<i>1626</i>&nbsp;            mv.visitInsn(Opcodes.RETURN);
<i>1627</i>&nbsp;            // it doesn&#39;t matter what rclass is; the JVM will discard any value
<i>1628</i>&nbsp;        } else {
<i>1629</i>&nbsp;            LambdaForm.Name rn = lambdaForm.names[lambdaForm.result];
<i>1630</i>&nbsp;
<i>1631</i>&nbsp;            // put return value on the stack if it is not already there
<i>1632</i>&nbsp;            if (rn != onStack) {
<i>1633</i>&nbsp;                emitLoadInsn(rtype, lambdaForm.result);
<i>1634</i>&nbsp;            }
<i>1635</i>&nbsp;
<i>1636</i>&nbsp;            emitImplicitConversion(rtype, rclass, rn);
<i>1637</i>&nbsp;
<i>1638</i>&nbsp;            // generate actual return statement
<i>1639</i>&nbsp;            emitReturnInsn(rtype);
<i>1640</i>&nbsp;        }
<i>1641</i>&nbsp;    }
<i>1642</i>&nbsp;
<i>1643</i>&nbsp;    /**
<i>1644</i>&nbsp;     * Emit a type conversion bytecode casting from &quot;from&quot; to &quot;to&quot;.
<i>1645</i>&nbsp;     */
<i>1646</i>&nbsp;    private void emitPrimCast(Wrapper from, Wrapper to) {
<i>1647</i>&nbsp;        // Here&#39;s how.
<i>1648</i>&nbsp;        // -   indicates forbidden
<i>1649</i>&nbsp;        // &lt;-&gt; indicates implicit
<i>1650</i>&nbsp;        //      to ----&gt; boolean  byte     short    char     int      long     float    double
<i>1651</i>&nbsp;        // from boolean    &lt;-&gt;        -        -        -        -        -        -        -
<i>1652</i>&nbsp;        //      byte        -       &lt;-&gt;       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
<i>1653</i>&nbsp;        //      short       -       i2b       &lt;-&gt;      i2c      &lt;-&gt;      i2l      i2f      i2d
<i>1654</i>&nbsp;        //      char        -       i2b       i2s      &lt;-&gt;      &lt;-&gt;      i2l      i2f      i2d
<i>1655</i>&nbsp;        //      int         -       i2b       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
<i>1656</i>&nbsp;        //      long        -     l2i,i2b   l2i,i2s  l2i,i2c    l2i      &lt;-&gt;      l2f      l2d
<i>1657</i>&nbsp;        //      float       -     f2i,i2b   f2i,i2s  f2i,i2c    f2i      f2l      &lt;-&gt;      f2d
<i>1658</i>&nbsp;        //      double      -     d2i,i2b   d2i,i2s  d2i,i2c    d2i      d2l      d2f      &lt;-&gt;
<i>1659</i>&nbsp;        if (from == to) {
<i>1660</i>&nbsp;            // no cast required, should be dead code anyway
<i>1661</i>&nbsp;            return;
<i>1662</i>&nbsp;        }
<i>1663</i>&nbsp;        if (from.isSubwordOrInt()) {
<i>1664</i>&nbsp;            // cast from {byte,short,char,int} to anything
<i>1665</i>&nbsp;            emitI2X(to);
<i>1666</i>&nbsp;        } else {
<i>1667</i>&nbsp;            // cast from {long,float,double} to anything
<i>1668</i>&nbsp;            if (to.isSubwordOrInt()) {
<i>1669</i>&nbsp;                // cast to {byte,short,char,int}
<i>1670</i>&nbsp;                emitX2I(from);
<i>1671</i>&nbsp;                if (to.bitWidth() &lt; 32) {
<i>1672</i>&nbsp;                    // targets other than int require another conversion
<i>1673</i>&nbsp;                    emitI2X(to);
<i>1674</i>&nbsp;                }
<i>1675</i>&nbsp;            } else {
<i>1676</i>&nbsp;                // cast to {long,float,double} - this is verbose
<i>1677</i>&nbsp;                boolean error = false;
<i>1678</i>&nbsp;                switch (from) {
<i>1679</i>&nbsp;                case LONG:
<i>1680</i>&nbsp;                    switch (to) {
<i>1681</i>&nbsp;                    case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;
<i>1682</i>&nbsp;                    case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;
<i>1683</i>&nbsp;                    default:      error = true;               break;
<i>1684</i>&nbsp;                    }
<i>1685</i>&nbsp;                    break;
<i>1686</i>&nbsp;                case FLOAT:
<i>1687</i>&nbsp;                    switch (to) {
<i>1688</i>&nbsp;                    case LONG :   mv.visitInsn(Opcodes.F2L);  break;
<i>1689</i>&nbsp;                    case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;
<i>1690</i>&nbsp;                    default:      error = true;               break;
<i>1691</i>&nbsp;                    }
<i>1692</i>&nbsp;                    break;
<i>1693</i>&nbsp;                case DOUBLE:
<i>1694</i>&nbsp;                    switch (to) {
<i>1695</i>&nbsp;                    case LONG :   mv.visitInsn(Opcodes.D2L);  break;
<i>1696</i>&nbsp;                    case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;
<i>1697</i>&nbsp;                    default:      error = true;               break;
<i>1698</i>&nbsp;                    }
<i>1699</i>&nbsp;                    break;
<i>1700</i>&nbsp;                default:
<i>1701</i>&nbsp;                    error = true;
<i>1702</i>&nbsp;                    break;
<i>1703</i>&nbsp;                }
<i>1704</i>&nbsp;                if (error) {
<i>1705</i>&nbsp;                    throw new IllegalStateException(&quot;unhandled prim cast: &quot; + from + &quot;2&quot; + to);
<i>1706</i>&nbsp;                }
<i>1707</i>&nbsp;            }
<i>1708</i>&nbsp;        }
<i>1709</i>&nbsp;    }
<i>1710</i>&nbsp;
<i>1711</i>&nbsp;    private void emitI2X(Wrapper type) {
<i>1712</i>&nbsp;        switch (type) {
<i>1713</i>&nbsp;        case BYTE:    mv.visitInsn(Opcodes.I2B);  break;
<i>1714</i>&nbsp;        case SHORT:   mv.visitInsn(Opcodes.I2S);  break;
<i>1715</i>&nbsp;        case CHAR:    mv.visitInsn(Opcodes.I2C);  break;
<i>1716</i>&nbsp;        case INT:     /* naught */                break;
<i>1717</i>&nbsp;        case LONG:    mv.visitInsn(Opcodes.I2L);  break;
<i>1718</i>&nbsp;        case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;
<i>1719</i>&nbsp;        case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;
<i>1720</i>&nbsp;        case BOOLEAN:
<i>1721</i>&nbsp;            // For compatibility with ValueConversions and explicitCastArguments:
<i>1722</i>&nbsp;            mv.visitInsn(Opcodes.ICONST_1);
<i>1723</i>&nbsp;            mv.visitInsn(Opcodes.IAND);
<i>1724</i>&nbsp;            break;
<i>1725</i>&nbsp;        default:   throw new InternalError(&quot;unknown type: &quot; + type);
<i>1726</i>&nbsp;        }
<i>1727</i>&nbsp;    }
<i>1728</i>&nbsp;
<i>1729</i>&nbsp;    private void emitX2I(Wrapper type) {
<i>1730</i>&nbsp;        switch (type) {
<i>1731</i>&nbsp;        case LONG:    mv.visitInsn(Opcodes.L2I);  break;
<i>1732</i>&nbsp;        case FLOAT:   mv.visitInsn(Opcodes.F2I);  break;
<i>1733</i>&nbsp;        case DOUBLE:  mv.visitInsn(Opcodes.D2I);  break;
<i>1734</i>&nbsp;        default:      throw new InternalError(&quot;unknown type: &quot; + type);
<i>1735</i>&nbsp;        }
<i>1736</i>&nbsp;    }
<i>1737</i>&nbsp;
<i>1738</i>&nbsp;    /**
<i>1739</i>&nbsp;     * Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
<i>1740</i>&nbsp;     */
<i>1741</i>&nbsp;    static MemberName generateLambdaFormInterpreterEntryPoint(MethodType mt) {
<i>1742</i>&nbsp;        assert(isValidSignature(basicTypeSignature(mt)));
<i>1743</i>&nbsp;        String name = &quot;interpret_&quot;+basicTypeChar(mt.returnType());
<i>1744</i>&nbsp;        MethodType type = mt;  // includes leading argument
<i>1745</i>&nbsp;        type = type.changeParameterType(0, MethodHandle.class);
<i>1746</i>&nbsp;        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;LFI&quot;, name, type);
<i>1747</i>&nbsp;        return g.loadMethod(g.generateLambdaFormInterpreterEntryPointBytes());
<i>1748</i>&nbsp;    }
<i>1749</i>&nbsp;
<i>1750</i>&nbsp;    private byte[] generateLambdaFormInterpreterEntryPointBytes() {
<i>1751</i>&nbsp;        classFilePrologue();
<i>1752</i>&nbsp;        methodPrologue();
<i>1753</i>&nbsp;
<i>1754</i>&nbsp;        // Suppress this method in backtraces displayed to the user.
<i>1755</i>&nbsp;        mv.visitAnnotation(LF_HIDDEN_SIG, true);
<i>1756</i>&nbsp;
<i>1757</i>&nbsp;        // Don&#39;t inline the interpreter entry.
<i>1758</i>&nbsp;        mv.visitAnnotation(DONTINLINE_SIG, true);
<i>1759</i>&nbsp;
<i>1760</i>&nbsp;        // create parameter array
<i>1761</i>&nbsp;        emitIconstInsn(invokerType.parameterCount());
<i>1762</i>&nbsp;        mv.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);
<i>1763</i>&nbsp;
<i>1764</i>&nbsp;        // fill parameter array
<i>1765</i>&nbsp;        for (int i = 0; i &lt; invokerType.parameterCount(); i++) {
<i>1766</i>&nbsp;            Class&lt;?&gt; ptype = invokerType.parameterType(i);
<i>1767</i>&nbsp;            mv.visitInsn(Opcodes.DUP);
<i>1768</i>&nbsp;            emitIconstInsn(i);
<i>1769</i>&nbsp;            emitLoadInsn(basicType(ptype), i);
<i>1770</i>&nbsp;            // box if primitive type
<i>1771</i>&nbsp;            if (ptype.isPrimitive()) {
<i>1772</i>&nbsp;                emitBoxing(Wrapper.forPrimitiveType(ptype));
<i>1773</i>&nbsp;            }
<i>1774</i>&nbsp;            mv.visitInsn(Opcodes.AASTORE);
<i>1775</i>&nbsp;        }
<i>1776</i>&nbsp;        // invoke
<i>1777</i>&nbsp;        emitAloadInsn(0);
<i>1778</i>&nbsp;        mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);
<i>1779</i>&nbsp;        mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable
<i>1780</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
<i>1781</i>&nbsp;
<i>1782</i>&nbsp;        // maybe unbox
<i>1783</i>&nbsp;        Class&lt;?&gt; rtype = invokerType.returnType();
<i>1784</i>&nbsp;        if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {
<i>1785</i>&nbsp;            emitUnboxing(Wrapper.forPrimitiveType(rtype));
<i>1786</i>&nbsp;        }
<i>1787</i>&nbsp;
<i>1788</i>&nbsp;        // return statement
<i>1789</i>&nbsp;        emitReturnInsn(basicType(rtype));
<i>1790</i>&nbsp;
<i>1791</i>&nbsp;        methodEpilogue();
<i>1792</i>&nbsp;        bogusMethod(invokerType);
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;        final byte[] classFile = cw.toByteArray();
<i>1795</i>&nbsp;        maybeDump(classFile);
<i>1796</i>&nbsp;        return classFile;
<i>1797</i>&nbsp;    }
<i>1798</i>&nbsp;
<i>1799</i>&nbsp;    /**
<i>1800</i>&nbsp;     * Generate bytecode for a NamedFunction invoker.
<i>1801</i>&nbsp;     */
<i>1802</i>&nbsp;    static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
<i>1803</i>&nbsp;        MethodType invokerType = NamedFunction.INVOKER_METHOD_TYPE;
<i>1804</i>&nbsp;        String invokerName = &quot;invoke_&quot; + shortenSignature(basicTypeSignature(typeForm.erasedType()));
<i>1805</i>&nbsp;        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);
<i>1806</i>&nbsp;        return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));
<i>1807</i>&nbsp;    }
<i>1808</i>&nbsp;
<i>1809</i>&nbsp;    private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
<i>1810</i>&nbsp;        MethodType dstType = typeForm.erasedType();
<i>1811</i>&nbsp;        classFilePrologue();
<i>1812</i>&nbsp;        methodPrologue();
<i>1813</i>&nbsp;
<i>1814</i>&nbsp;        // Suppress this method in backtraces displayed to the user.
<i>1815</i>&nbsp;        mv.visitAnnotation(LF_HIDDEN_SIG, true);
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;        // Force inlining of this invoker method.
<i>1818</i>&nbsp;        mv.visitAnnotation(FORCEINLINE_SIG, true);
<i>1819</i>&nbsp;
<i>1820</i>&nbsp;        // Load receiver
<i>1821</i>&nbsp;        emitAloadInsn(0);
<i>1822</i>&nbsp;
<i>1823</i>&nbsp;        // Load arguments from array
<i>1824</i>&nbsp;        for (int i = 0; i &lt; dstType.parameterCount(); i++) {
<i>1825</i>&nbsp;            emitAloadInsn(1);
<i>1826</i>&nbsp;            emitIconstInsn(i);
<i>1827</i>&nbsp;            mv.visitInsn(Opcodes.AALOAD);
<i>1828</i>&nbsp;
<i>1829</i>&nbsp;            // Maybe unbox
<i>1830</i>&nbsp;            Class&lt;?&gt; dptype = dstType.parameterType(i);
<i>1831</i>&nbsp;            if (dptype.isPrimitive()) {
<i>1832</i>&nbsp;                Wrapper dstWrapper = Wrapper.forBasicType(dptype);
<i>1833</i>&nbsp;                Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  // narrow subword from int
<i>1834</i>&nbsp;                emitUnboxing(srcWrapper);
<i>1835</i>&nbsp;                emitPrimCast(srcWrapper, dstWrapper);
<i>1836</i>&nbsp;            }
<i>1837</i>&nbsp;        }
<i>1838</i>&nbsp;
<i>1839</i>&nbsp;        // Invoke
<i>1840</i>&nbsp;        String targetDesc = dstType.basicType().toMethodDescriptorString();
<i>1841</i>&nbsp;        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc, false);
<i>1842</i>&nbsp;
<i>1843</i>&nbsp;        // Box primitive types
<i>1844</i>&nbsp;        Class&lt;?&gt; rtype = dstType.returnType();
<i>1845</i>&nbsp;        if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {
<i>1846</i>&nbsp;            Wrapper srcWrapper = Wrapper.forBasicType(rtype);
<i>1847</i>&nbsp;            Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int
<i>1848</i>&nbsp;            // boolean casts not allowed
<i>1849</i>&nbsp;            emitPrimCast(srcWrapper, dstWrapper);
<i>1850</i>&nbsp;            emitBoxing(dstWrapper);
<i>1851</i>&nbsp;        }
<i>1852</i>&nbsp;
<i>1853</i>&nbsp;        // If the return type is void we return a null reference.
<i>1854</i>&nbsp;        if (rtype == void.class) {
<i>1855</i>&nbsp;            mv.visitInsn(Opcodes.ACONST_NULL);
<i>1856</i>&nbsp;        }
<i>1857</i>&nbsp;        emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
<i>1858</i>&nbsp;
<i>1859</i>&nbsp;        methodEpilogue();
<i>1860</i>&nbsp;        bogusMethod(dstType);
<i>1861</i>&nbsp;
<i>1862</i>&nbsp;        final byte[] classFile = cw.toByteArray();
<i>1863</i>&nbsp;        maybeDump(classFile);
<i>1864</i>&nbsp;        return classFile;
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    /**
<i>1868</i>&nbsp;     * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
<i>1869</i>&nbsp;     * for debugging purposes.
<i>1870</i>&nbsp;     */
<i>1871</i>&nbsp;    private void bogusMethod(Object os) {
<i>1872</i>&nbsp;        if (DUMP_CLASS_FILES) {
<i>1873</i>&nbsp;            mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);
<i>1874</i>&nbsp;            mv.visitLdcInsn(os.toString());
<i>1875</i>&nbsp;            mv.visitInsn(Opcodes.POP);
<i>1876</i>&nbsp;            mv.visitInsn(Opcodes.RETURN);
<i>1877</i>&nbsp;            mv.visitMaxs(0, 0);
<i>1878</i>&nbsp;            mv.visitEnd();
<i>1879</i>&nbsp;        }
<i>1880</i>&nbsp;    }
<i>1881</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
