


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MethodHandleImpl</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang.invoke</a> ]
</div>

<h1>Coverage Summary for Class: MethodHandleImpl (java.lang.invoke)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodHandleImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 71)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 562)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodHandleImpl$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$ArrayAccessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$ArrayAccessor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$AsVarargsCollector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$BindCaller</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 65)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$BindCaller$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$BindCaller$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$BindCaller$T</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$CountingWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$Intrinsic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$IntrinsicMethodHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$Lazy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandleImpl$WrappedMember</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 148)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 830)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang.invoke;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import jdk.internal.misc.JavaLangInvokeAccess;
<i>29</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>30</i>&nbsp;import jdk.internal.org.objectweb.asm.AnnotationVisitor;
<i>31</i>&nbsp;import jdk.internal.org.objectweb.asm.ClassWriter;
<i>32</i>&nbsp;import jdk.internal.org.objectweb.asm.MethodVisitor;
<i>33</i>&nbsp;import jdk.internal.reflect.CallerSensitive;
<i>34</i>&nbsp;import jdk.internal.reflect.Reflection;
<i>35</i>&nbsp;import jdk.internal.vm.annotation.ForceInline;
<i>36</i>&nbsp;import jdk.internal.vm.annotation.Stable;
<i>37</i>&nbsp;import sun.invoke.empty.Empty;
<i>38</i>&nbsp;import sun.invoke.util.ValueConversions;
<i>39</i>&nbsp;import sun.invoke.util.VerifyType;
<i>40</i>&nbsp;import sun.invoke.util.Wrapper;
<i>41</i>&nbsp;
<i>42</i>&nbsp;import java.lang.reflect.Array;
<i>43</i>&nbsp;import java.util.Arrays;
<i>44</i>&nbsp;import java.util.Collections;
<i>45</i>&nbsp;import java.util.Iterator;
<i>46</i>&nbsp;import java.util.List;
<i>47</i>&nbsp;import java.util.Map;
<i>48</i>&nbsp;import java.util.function.Function;
<b class="nc"><i>49</i>&nbsp;import java.util.stream.Stream;</b>
<i>50</i>&nbsp;
<i>51</i>&nbsp;import static java.lang.invoke.LambdaForm.*;
<i>52</i>&nbsp;import static java.lang.invoke.MethodHandleStatics.*;
<b class="nc"><i>53</i>&nbsp;import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;</b>
<b class="nc"><i>54</i>&nbsp;import static jdk.internal.org.objectweb.asm.Opcodes.*;</b>
<i>55</i>&nbsp;
<i>56</i>&nbsp;/**
<b class="nc"><i>57</i>&nbsp; * Trusted implementation code for MethodHandle.</b>
<b class="nc"><i>58</i>&nbsp; * @author jrose</b>
<i>59</i>&nbsp; */
<i>60</i>&nbsp;/*non-public*/ abstract class MethodHandleImpl {
<b class="nc"><i>61</i>&nbsp;</b>
<i>62</i>&nbsp;    /// Factory methods to create method handles:
<i>63</i>&nbsp;
<i>64</i>&nbsp;    static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {
<i>65</i>&nbsp;        if (arrayClass == Object[].class) {
<i>66</i>&nbsp;            return ArrayAccess.objectAccessor(access);
<i>67</i>&nbsp;        }
<b class="nc"><i>68</i>&nbsp;        if (!arrayClass.isArray())</b>
<i>69</i>&nbsp;            throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);
<i>70</i>&nbsp;        MethodHandle[] cache = ArrayAccessor.TYPED_ACCESSORS.get(arrayClass);
<i>71</i>&nbsp;        int cacheIndex = ArrayAccess.cacheIndex(access);
<b class="nc"><i>72</i>&nbsp;        MethodHandle mh = cache[cacheIndex];</b>
<b class="nc"><i>73</i>&nbsp;        if (mh != null)  return mh;</b>
<b class="nc"><i>74</i>&nbsp;        mh = ArrayAccessor.getAccessor(arrayClass, access);</b>
<b class="nc"><i>75</i>&nbsp;        MethodType correctType = ArrayAccessor.correctType(arrayClass, access);</b>
<b class="nc"><i>76</i>&nbsp;        if (mh.type() != correctType) {</b>
<b class="nc"><i>77</i>&nbsp;            assert(mh.type().parameterType(0) == Object[].class);</b>
<b class="nc"><i>78</i>&nbsp;            /* if access == SET */ assert(access != ArrayAccess.SET || mh.type().parameterType(2) == Object.class);</b>
<b class="nc"><i>79</i>&nbsp;            /* if access == GET */ assert(access != ArrayAccess.GET ||</b>
<b class="nc"><i>80</i>&nbsp;                    (mh.type().returnType() == Object.class &amp;&amp;</b>
<b class="nc"><i>81</i>&nbsp;                     correctType.parameterType(0).getComponentType() == correctType.returnType()));</b>
<b class="nc"><i>82</i>&nbsp;            // safe to view non-strictly, because element type follows from array type</b>
<b class="nc"><i>83</i>&nbsp;            mh = mh.viewAsType(correctType, false);</b>
<b class="nc"><i>84</i>&nbsp;        }</b>
<b class="nc"><i>85</i>&nbsp;        mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));</b>
<i>86</i>&nbsp;        // Atomically update accessor cache.
<b class="nc"><i>87</i>&nbsp;        synchronized(cache) {</b>
<i>88</i>&nbsp;            if (cache[cacheIndex] == null) {
<b class="nc"><i>89</i>&nbsp;                cache[cacheIndex] = mh;</b>
<i>90</i>&nbsp;            } else {
<b class="nc"><i>91</i>&nbsp;                // Throw away newly constructed accessor and use cached version.</b>
<b class="nc"><i>92</i>&nbsp;                mh = cache[cacheIndex];</b>
<b class="nc"><i>93</i>&nbsp;            }</b>
<i>94</i>&nbsp;        }
<i>95</i>&nbsp;        return mh;
<b class="nc"><i>96</i>&nbsp;    }</b>
<i>97</i>&nbsp;
<b class="nc"><i>98</i>&nbsp;    enum ArrayAccess {</b>
<b class="nc"><i>99</i>&nbsp;        GET, SET, LENGTH;</b>
<i>100</i>&nbsp;
<i>101</i>&nbsp;        // As ArrayAccess and ArrayAccessor have a circular dependency, the ArrayAccess properties cannot be stored in
<b class="nc"><i>102</i>&nbsp;        // final fields.</b>
<i>103</i>&nbsp;
<i>104</i>&nbsp;        static String opName(ArrayAccess a) {
<b class="nc"><i>105</i>&nbsp;            switch (a) {</b>
<b class="nc"><i>106</i>&nbsp;                case GET: return &quot;getElement&quot;;</b>
<i>107</i>&nbsp;                case SET: return &quot;setElement&quot;;
<i>108</i>&nbsp;                case LENGTH: return &quot;length&quot;;
<b class="nc"><i>109</i>&nbsp;            }</b>
<i>110</i>&nbsp;            throw unmatchedArrayAccess(a);
<i>111</i>&nbsp;        }
<i>112</i>&nbsp;
<i>113</i>&nbsp;        static MethodHandle objectAccessor(ArrayAccess a) {
<b class="nc"><i>114</i>&nbsp;            switch (a) {</b>
<b class="nc"><i>115</i>&nbsp;                case GET: return ArrayAccessor.OBJECT_ARRAY_GETTER;</b>
<b class="nc"><i>116</i>&nbsp;                case SET: return ArrayAccessor.OBJECT_ARRAY_SETTER;</b>
<i>117</i>&nbsp;                case LENGTH: return ArrayAccessor.OBJECT_ARRAY_LENGTH;
<b class="nc"><i>118</i>&nbsp;            }</b>
<b class="nc"><i>119</i>&nbsp;            throw unmatchedArrayAccess(a);</b>
<i>120</i>&nbsp;        }
<i>121</i>&nbsp;
<b class="nc"><i>122</i>&nbsp;        static int cacheIndex(ArrayAccess a) {</b>
<b class="nc"><i>123</i>&nbsp;            switch (a) {</b>
<b class="nc"><i>124</i>&nbsp;                case GET: return ArrayAccessor.GETTER_INDEX;</b>
<b class="nc"><i>125</i>&nbsp;                case SET: return ArrayAccessor.SETTER_INDEX;</b>
<b class="nc"><i>126</i>&nbsp;                case LENGTH: return ArrayAccessor.LENGTH_INDEX;</b>
<b class="nc"><i>127</i>&nbsp;            }</b>
<b class="nc"><i>128</i>&nbsp;            throw unmatchedArrayAccess(a);</b>
<b class="nc"><i>129</i>&nbsp;        }</b>
<b class="nc"><i>130</i>&nbsp;</b>
<i>131</i>&nbsp;        static Intrinsic intrinsic(ArrayAccess a) {
<b class="nc"><i>132</i>&nbsp;            switch (a) {</b>
<b class="nc"><i>133</i>&nbsp;                case GET: return Intrinsic.ARRAY_LOAD;</b>
<b class="nc"><i>134</i>&nbsp;                case SET: return Intrinsic.ARRAY_STORE;</b>
<b class="nc"><i>135</i>&nbsp;                case LENGTH: return Intrinsic.ARRAY_LENGTH;</b>
<b class="nc"><i>136</i>&nbsp;            }</b>
<b class="nc"><i>137</i>&nbsp;            throw unmatchedArrayAccess(a);</b>
<b class="nc"><i>138</i>&nbsp;        }</b>
<b class="nc"><i>139</i>&nbsp;    }</b>
<b class="nc"><i>140</i>&nbsp;</b>
<i>141</i>&nbsp;    static InternalError unmatchedArrayAccess(ArrayAccess a) {
<i>142</i>&nbsp;        return newInternalError(&quot;should not reach here (unmatched ArrayAccess: &quot; + a + &quot;)&quot;);
<b class="nc"><i>143</i>&nbsp;    }</b>
<b class="nc"><i>144</i>&nbsp;</b>
<b class="nc"><i>145</i>&nbsp;    static final class ArrayAccessor {</b>
<i>146</i>&nbsp;        /// Support for array element and length access
<i>147</i>&nbsp;        static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;
<b class="nc"><i>148</i>&nbsp;        static final ClassValue&lt;MethodHandle[]&gt; TYPED_ACCESSORS</b>
<b class="nc"><i>149</i>&nbsp;                = new ClassValue&lt;MethodHandle[]&gt;() {</b>
<b class="nc"><i>150</i>&nbsp;                    @Override</b>
<b class="nc"><i>151</i>&nbsp;                    protected MethodHandle[] computeValue(Class&lt;?&gt; type) {</b>
<b class="nc"><i>152</i>&nbsp;                        return new MethodHandle[INDEX_LIMIT];</b>
<i>153</i>&nbsp;                    }
<b class="nc"><i>154</i>&nbsp;                };</b>
<b class="nc"><i>155</i>&nbsp;        static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;</b>
<b class="nc"><i>156</i>&nbsp;        static {</b>
<i>157</i>&nbsp;            MethodHandle[] cache = TYPED_ACCESSORS.get(Object[].class);
<i>158</i>&nbsp;            cache[GETTER_INDEX] = OBJECT_ARRAY_GETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.GET),    Intrinsic.ARRAY_LOAD);
<b class="nc"><i>159</i>&nbsp;            cache[SETTER_INDEX] = OBJECT_ARRAY_SETTER = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.SET),    Intrinsic.ARRAY_STORE);</b>
<b class="nc"><i>160</i>&nbsp;            cache[LENGTH_INDEX] = OBJECT_ARRAY_LENGTH = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.LENGTH), Intrinsic.ARRAY_LENGTH);</b>
<b class="nc"><i>161</i>&nbsp;</b>
<b class="nc"><i>162</i>&nbsp;            assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_GETTER.internalMemberName()));</b>
<i>163</i>&nbsp;            assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_SETTER.internalMemberName()));
<i>164</i>&nbsp;            assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_LENGTH.internalMemberName()));
<b class="nc"><i>165</i>&nbsp;        }</b>
<b class="nc"><i>166</i>&nbsp;</b>
<i>167</i>&nbsp;        static int     getElementI(int[]     a, int i)            { return              a[i]; }
<b class="nc"><i>168</i>&nbsp;        static long    getElementJ(long[]    a, int i)            { return              a[i]; }</b>
<b class="nc"><i>169</i>&nbsp;        static float   getElementF(float[]   a, int i)            { return              a[i]; }</b>
<b class="nc"><i>170</i>&nbsp;        static double  getElementD(double[]  a, int i)            { return              a[i]; }</b>
<i>171</i>&nbsp;        static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }
<i>172</i>&nbsp;        static byte    getElementB(byte[]    a, int i)            { return              a[i]; }
<i>173</i>&nbsp;        static short   getElementS(short[]   a, int i)            { return              a[i]; }
<i>174</i>&nbsp;        static char    getElementC(char[]    a, int i)            { return              a[i]; }
<i>175</i>&nbsp;        static Object  getElementL(Object[]  a, int i)            { return              a[i]; }
<i>176</i>&nbsp;
<i>177</i>&nbsp;        static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }
<i>178</i>&nbsp;        static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }
<i>179</i>&nbsp;        static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }
<i>180</i>&nbsp;        static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }
<i>181</i>&nbsp;        static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }
<i>182</i>&nbsp;        static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }
<i>183</i>&nbsp;        static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }
<i>184</i>&nbsp;        static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }
<i>185</i>&nbsp;        static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }
<i>186</i>&nbsp;
<i>187</i>&nbsp;        static int     lengthI(int[]     a)                       { return a.length; }
<i>188</i>&nbsp;        static int     lengthJ(long[]    a)                       { return a.length; }
<i>189</i>&nbsp;        static int     lengthF(float[]   a)                       { return a.length; }
<i>190</i>&nbsp;        static int     lengthD(double[]  a)                       { return a.length; }
<b class="nc"><i>191</i>&nbsp;        static int     lengthZ(boolean[] a)                       { return a.length; }</b>
<b class="nc"><i>192</i>&nbsp;        static int     lengthB(byte[]    a)                       { return a.length; }</b>
<b class="nc"><i>193</i>&nbsp;        static int     lengthS(short[]   a)                       { return a.length; }</b>
<b class="nc"><i>194</i>&nbsp;        static int     lengthC(char[]    a)                       { return a.length; }</b>
<i>195</i>&nbsp;        static int     lengthL(Object[]  a)                       { return a.length; }
<i>196</i>&nbsp;
<i>197</i>&nbsp;        static String name(Class&lt;?&gt; arrayClass, ArrayAccess access) {
<b class="nc"><i>198</i>&nbsp;            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</b>
<b class="nc"><i>199</i>&nbsp;            if (elemClass == null)  throw newIllegalArgumentException(&quot;not an array&quot;, arrayClass);</b>
<b class="nc"><i>200</i>&nbsp;            return ArrayAccess.opName(access) + Wrapper.basicTypeChar(elemClass);</b>
<i>201</i>&nbsp;        }
<b class="nc"><i>202</i>&nbsp;        static MethodType type(Class&lt;?&gt; arrayClass, ArrayAccess access) {</b>
<i>203</i>&nbsp;            Class&lt;?&gt; elemClass = arrayClass.getComponentType();
<i>204</i>&nbsp;            Class&lt;?&gt; arrayArgClass = arrayClass;
<i>205</i>&nbsp;            if (!elemClass.isPrimitive()) {
<i>206</i>&nbsp;                arrayArgClass = Object[].class;
<b class="nc"><i>207</i>&nbsp;                elemClass = Object.class;</b>
<b class="nc"><i>208</i>&nbsp;            }</b>
<b class="nc"><i>209</i>&nbsp;            switch (access) {</b>
<b class="nc"><i>210</i>&nbsp;                case GET:    return MethodType.methodType(elemClass,  arrayArgClass, int.class);</b>
<b class="nc"><i>211</i>&nbsp;                case SET:    return MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);</b>
<b class="nc"><i>212</i>&nbsp;                case LENGTH: return MethodType.methodType(int.class,  arrayArgClass);</b>
<b class="nc"><i>213</i>&nbsp;            }</b>
<i>214</i>&nbsp;            throw unmatchedArrayAccess(access);
<i>215</i>&nbsp;        }
<b class="nc"><i>216</i>&nbsp;        static MethodType correctType(Class&lt;?&gt; arrayClass, ArrayAccess access) {</b>
<b class="nc"><i>217</i>&nbsp;            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</b>
<b class="nc"><i>218</i>&nbsp;            switch (access) {</b>
<i>219</i>&nbsp;                case GET:    return MethodType.methodType(elemClass,  arrayClass, int.class);
<b class="nc"><i>220</i>&nbsp;                case SET:    return MethodType.methodType(void.class, arrayClass, int.class, elemClass);</b>
<b class="nc"><i>221</i>&nbsp;                case LENGTH: return MethodType.methodType(int.class,  arrayClass);</b>
<i>222</i>&nbsp;            }
<b class="nc"><i>223</i>&nbsp;            throw unmatchedArrayAccess(access);</b>
<i>224</i>&nbsp;        }
<b class="nc"><i>225</i>&nbsp;        static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, ArrayAccess access) {</b>
<b class="nc"><i>226</i>&nbsp;            String     name = name(arrayClass, access);</b>
<b class="nc"><i>227</i>&nbsp;            MethodType type = type(arrayClass, access);</b>
<i>228</i>&nbsp;            try {
<b class="nc"><i>229</i>&nbsp;                return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);</b>
<b class="nc"><i>230</i>&nbsp;            } catch (ReflectiveOperationException ex) {</b>
<b class="nc"><i>231</i>&nbsp;                throw uncaughtException(ex);</b>
<b class="nc"><i>232</i>&nbsp;            }</b>
<i>233</i>&nbsp;        }
<b class="nc"><i>234</i>&nbsp;    }</b>
<b class="nc"><i>235</i>&nbsp;</b>
<i>236</i>&nbsp;    /**
<b class="nc"><i>237</i>&nbsp;     * Create a JVM-level adapter method handle to conform the given method</b>
<b class="nc"><i>238</i>&nbsp;     * handle to the similar newType, using only pairwise argument conversions.</b>
<b class="nc"><i>239</i>&nbsp;     * For each argument, convert incoming argument to the exact type needed.</b>
<i>240</i>&nbsp;     * The argument conversions allowed are casting, boxing and unboxing,
<b class="nc"><i>241</i>&nbsp;     * integral widening or narrowing, and floating point widening or narrowing.</b>
<i>242</i>&nbsp;     * @param srcType required call type
<b class="nc"><i>243</i>&nbsp;     * @param target original method handle</b>
<i>244</i>&nbsp;     * @param strict if true, only asType conversions are allowed; if false, explicitCastArguments conversions allowed
<b class="nc"><i>245</i>&nbsp;     * @param monobox if true, unboxing conversions are assumed to be exactly typed (Integer to int only, not long or double)</b>
<b class="nc"><i>246</i>&nbsp;     * @return an adapter to the original handle with the desired new type,</b>
<b class="nc"><i>247</i>&nbsp;     *          or the original target if the types are already identical</b>
<b class="nc"><i>248</i>&nbsp;     *          or null if the adaptation cannot be made</b>
<b class="nc"><i>249</i>&nbsp;     */</b>
<b class="nc"><i>250</i>&nbsp;    static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,</b>
<b class="nc"><i>251</i>&nbsp;                                            boolean strict, boolean monobox) {</b>
<b class="nc"><i>252</i>&nbsp;        MethodType dstType = target.type();</b>
<b class="nc"><i>253</i>&nbsp;        if (srcType == dstType)</b>
<b class="nc"><i>254</i>&nbsp;            return target;</b>
<i>255</i>&nbsp;        return makePairwiseConvertByEditor(target, srcType, strict, monobox);
<i>256</i>&nbsp;    }
<b class="nc"><i>257</i>&nbsp;</b>
<b class="nc"><i>258</i>&nbsp;    private static int countNonNull(Object[] array) {</b>
<b class="nc"><i>259</i>&nbsp;        int count = 0;</b>
<i>260</i>&nbsp;        for (Object x : array) {
<i>261</i>&nbsp;            if (x != null)  ++count;
<i>262</i>&nbsp;        }
<i>263</i>&nbsp;        return count;
<b class="nc"><i>264</i>&nbsp;    }</b>
<i>265</i>&nbsp;
<b class="nc"><i>266</i>&nbsp;    static MethodHandle makePairwiseConvertByEditor(MethodHandle target, MethodType srcType,</b>
<b class="nc"><i>267</i>&nbsp;                                                    boolean strict, boolean monobox) {</b>
<b class="nc"><i>268</i>&nbsp;        Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);</b>
<b class="nc"><i>269</i>&nbsp;        int convCount = countNonNull(convSpecs);</b>
<b class="nc"><i>270</i>&nbsp;        if (convCount == 0)</b>
<b class="nc"><i>271</i>&nbsp;            return target.viewAsType(srcType, strict);</b>
<b class="nc"><i>272</i>&nbsp;        MethodType basicSrcType = srcType.basicType();</b>
<b class="nc"><i>273</i>&nbsp;        MethodType midType = target.type().basicType();</b>
<i>274</i>&nbsp;        BoundMethodHandle mh = target.rebind();
<i>275</i>&nbsp;        // FIXME: Reduce number of bindings when there is more than one Class conversion.
<i>276</i>&nbsp;        // FIXME: Reduce number of bindings when there are repeated conversions.
<i>277</i>&nbsp;        for (int i = 0; i &lt; convSpecs.length-1; i++) {
<b class="nc"><i>278</i>&nbsp;            Object convSpec = convSpecs[i];</b>
<b class="nc"><i>279</i>&nbsp;            if (convSpec == null)  continue;</b>
<b class="nc"><i>280</i>&nbsp;            MethodHandle fn;</b>
<b class="nc"><i>281</i>&nbsp;            if (convSpec instanceof Class) {</b>
<b class="nc"><i>282</i>&nbsp;                fn = getConstantHandle(MH_cast).bindTo(convSpec);</b>
<i>283</i>&nbsp;            } else {
<i>284</i>&nbsp;                fn = (MethodHandle) convSpec;
<b class="nc"><i>285</i>&nbsp;            }</b>
<b class="nc"><i>286</i>&nbsp;            Class&lt;?&gt; newType = basicSrcType.parameterType(i);</b>
<i>287</i>&nbsp;            if (--convCount == 0)
<i>288</i>&nbsp;                midType = srcType;
<i>289</i>&nbsp;            else
<b class="nc"><i>290</i>&nbsp;                midType = midType.changeParameterType(i, newType);</b>
<i>291</i>&nbsp;            LambdaForm form2 = mh.editor().filterArgumentForm(1+i, BasicType.basicType(newType));
<b class="nc"><i>292</i>&nbsp;            mh = mh.copyWithExtendL(midType, form2, fn);</b>
<b class="nc"><i>293</i>&nbsp;            mh = mh.rebind();</b>
<b class="nc"><i>294</i>&nbsp;        }</b>
<b class="nc"><i>295</i>&nbsp;        Object convSpec = convSpecs[convSpecs.length-1];</b>
<i>296</i>&nbsp;        if (convSpec != null) {
<b class="nc"><i>297</i>&nbsp;            MethodHandle fn;</b>
<b class="nc"><i>298</i>&nbsp;            if (convSpec instanceof Class) {</b>
<i>299</i>&nbsp;                if (convSpec == void.class)
<i>300</i>&nbsp;                    fn = null;
<i>301</i>&nbsp;                else
<b class="nc"><i>302</i>&nbsp;                    fn = getConstantHandle(MH_cast).bindTo(convSpec);</b>
<b class="nc"><i>303</i>&nbsp;            } else {</b>
<b class="nc"><i>304</i>&nbsp;                fn = (MethodHandle) convSpec;</b>
<b class="nc"><i>305</i>&nbsp;            }</b>
<b class="nc"><i>306</i>&nbsp;            Class&lt;?&gt; newType = basicSrcType.returnType();</b>
<b class="nc"><i>307</i>&nbsp;            assert(--convCount == 0);</b>
<i>308</i>&nbsp;            midType = srcType;
<b class="nc"><i>309</i>&nbsp;            if (fn != null) {</b>
<b class="nc"><i>310</i>&nbsp;                mh = mh.rebind();  // rebind if too complex</b>
<b class="nc"><i>311</i>&nbsp;                LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), false);</b>
<b class="nc"><i>312</i>&nbsp;                mh = mh.copyWithExtendL(midType, form2, fn);</b>
<i>313</i>&nbsp;            } else {
<i>314</i>&nbsp;                LambdaForm form2 = mh.editor().filterReturnForm(BasicType.basicType(newType), true);
<i>315</i>&nbsp;                mh = mh.copyWith(midType, form2);
<b class="nc"><i>316</i>&nbsp;            }</b>
<b class="nc"><i>317</i>&nbsp;        }</b>
<i>318</i>&nbsp;        assert(convCount == 0);
<b class="nc"><i>319</i>&nbsp;        assert(mh.type().equals(srcType));</b>
<b class="nc"><i>320</i>&nbsp;        return mh;</b>
<b class="nc"><i>321</i>&nbsp;    }</b>
<i>322</i>&nbsp;
<i>323</i>&nbsp;    static MethodHandle makePairwiseConvertIndirect(MethodHandle target, MethodType srcType,
<b class="nc"><i>324</i>&nbsp;                                                    boolean strict, boolean monobox) {</b>
<b class="nc"><i>325</i>&nbsp;        assert(target.type().parameterCount() == srcType.parameterCount());</b>
<b class="nc"><i>326</i>&nbsp;        // Calculate extra arguments (temporaries) required in the names array.</b>
<b class="nc"><i>327</i>&nbsp;        Object[] convSpecs = computeValueConversions(srcType, target.type(), strict, monobox);</b>
<b class="nc"><i>328</i>&nbsp;        final int INARG_COUNT = srcType.parameterCount();</b>
<b class="nc"><i>329</i>&nbsp;        int convCount = countNonNull(convSpecs);</b>
<b class="nc"><i>330</i>&nbsp;        boolean retConv = (convSpecs[INARG_COUNT] != null);</b>
<b class="nc"><i>331</i>&nbsp;        boolean retVoid = srcType.returnType() == void.class;</b>
<b class="nc"><i>332</i>&nbsp;        if (retConv &amp;&amp; retVoid) {</b>
<i>333</i>&nbsp;            convCount -= 1;
<b class="nc"><i>334</i>&nbsp;            retConv = false;</b>
<i>335</i>&nbsp;        }
<b class="nc"><i>336</i>&nbsp;</b>
<b class="nc"><i>337</i>&nbsp;        final int IN_MH         = 0;</b>
<b class="nc"><i>338</i>&nbsp;        final int INARG_BASE    = 1;</b>
<i>339</i>&nbsp;        final int INARG_LIMIT   = INARG_BASE + INARG_COUNT;
<i>340</i>&nbsp;        final int NAME_LIMIT    = INARG_LIMIT + convCount + 1;
<b class="nc"><i>341</i>&nbsp;        final int RETURN_CONV   = (!retConv ? -1         : NAME_LIMIT - 1);</b>
<b class="nc"><i>342</i>&nbsp;        final int OUT_CALL      = (!retConv ? NAME_LIMIT : RETURN_CONV) - 1;</b>
<i>343</i>&nbsp;        final int RESULT        = (retVoid ? -1 : NAME_LIMIT - 1);
<i>344</i>&nbsp;
<i>345</i>&nbsp;        // Now build a LambdaForm.
<i>346</i>&nbsp;        MethodType lambdaType = srcType.basicType().invokerType();
<i>347</i>&nbsp;        Name[] names = arguments(NAME_LIMIT - INARG_LIMIT, lambdaType);
<i>348</i>&nbsp;
<i>349</i>&nbsp;        // Collect the arguments to the outgoing call, maybe with conversions:
<i>350</i>&nbsp;        final int OUTARG_BASE = 0;  // target MH is Name.function, name Name.arguments[0]
<i>351</i>&nbsp;        Object[] outArgs = new Object[OUTARG_BASE + INARG_COUNT];
<i>352</i>&nbsp;
<i>353</i>&nbsp;        int nameCursor = INARG_LIMIT;
<i>354</i>&nbsp;        for (int i = 0; i &lt; INARG_COUNT; i++) {
<b class="nc"><i>355</i>&nbsp;            Object convSpec = convSpecs[i];</b>
<b class="nc"><i>356</i>&nbsp;            if (convSpec == null) {</b>
<b class="nc"><i>357</i>&nbsp;                // do nothing: difference is trivial</b>
<i>358</i>&nbsp;                outArgs[OUTARG_BASE + i] = names[INARG_BASE + i];
<i>359</i>&nbsp;                continue;
<i>360</i>&nbsp;            }
<b class="nc"><i>361</i>&nbsp;</b>
<i>362</i>&nbsp;            Name conv;
<i>363</i>&nbsp;            if (convSpec instanceof Class) {
<i>364</i>&nbsp;                Class&lt;?&gt; convClass = (Class&lt;?&gt;) convSpec;
<i>365</i>&nbsp;                conv = new Name(getConstantHandle(MH_cast), convClass, names[INARG_BASE + i]);
<b class="nc"><i>366</i>&nbsp;            } else {</b>
<b class="nc"><i>367</i>&nbsp;                MethodHandle fn = (MethodHandle) convSpec;</b>
<b class="nc"><i>368</i>&nbsp;                conv = new Name(fn, names[INARG_BASE + i]);</b>
<b class="nc"><i>369</i>&nbsp;            }</b>
<b class="nc"><i>370</i>&nbsp;            assert(names[nameCursor] == null);</b>
<b class="nc"><i>371</i>&nbsp;            names[nameCursor++] = conv;</b>
<b class="nc"><i>372</i>&nbsp;            assert(outArgs[OUTARG_BASE + i] == null);</b>
<b class="nc"><i>373</i>&nbsp;            outArgs[OUTARG_BASE + i] = conv;</b>
<i>374</i>&nbsp;        }
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;        // Build argument array for the call.</b>
<i>377</i>&nbsp;        assert(nameCursor == OUT_CALL);
<i>378</i>&nbsp;        names[OUT_CALL] = new Name(target, outArgs);
<i>379</i>&nbsp;
<b class="nc"><i>380</i>&nbsp;        Object convSpec = convSpecs[INARG_COUNT];</b>
<i>381</i>&nbsp;        if (!retConv) {
<i>382</i>&nbsp;            assert(OUT_CALL == names.length-1);
<i>383</i>&nbsp;        } else {
<i>384</i>&nbsp;            Name conv;
<i>385</i>&nbsp;            if (convSpec == void.class) {
<i>386</i>&nbsp;                conv = new Name(LambdaForm.constantZero(BasicType.basicType(srcType.returnType())));
<i>387</i>&nbsp;            } else if (convSpec instanceof Class) {
<i>388</i>&nbsp;                Class&lt;?&gt; convClass = (Class&lt;?&gt;) convSpec;
<i>389</i>&nbsp;                conv = new Name(getConstantHandle(MH_cast), convClass, names[OUT_CALL]);
<b class="nc"><i>390</i>&nbsp;            } else {</b>
<b class="nc"><i>391</i>&nbsp;                MethodHandle fn = (MethodHandle) convSpec;</b>
<b class="nc"><i>392</i>&nbsp;                if (fn.type().parameterCount() == 0)</b>
<i>393</i>&nbsp;                    conv = new Name(fn);  // don&#39;t pass retval to void conversion
<b class="nc"><i>394</i>&nbsp;                else</b>
<b class="nc"><i>395</i>&nbsp;                    conv = new Name(fn, names[OUT_CALL]);</b>
<b class="nc"><i>396</i>&nbsp;            }</b>
<b class="nc"><i>397</i>&nbsp;            assert(names[RETURN_CONV] == null);</b>
<i>398</i>&nbsp;            names[RETURN_CONV] = conv;
<b class="nc"><i>399</i>&nbsp;            assert(RETURN_CONV == names.length-1);</b>
<i>400</i>&nbsp;        }
<i>401</i>&nbsp;
<b class="nc"><i>402</i>&nbsp;        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, RESULT, Kind.CONVERT);</b>
<b class="nc"><i>403</i>&nbsp;        return SimpleMethodHandle.make(srcType, form);</b>
<b class="nc"><i>404</i>&nbsp;    }</b>
<b class="nc"><i>405</i>&nbsp;</b>
<b class="nc"><i>406</i>&nbsp;    static Object[] computeValueConversions(MethodType srcType, MethodType dstType,</b>
<i>407</i>&nbsp;                                            boolean strict, boolean monobox) {
<b class="nc"><i>408</i>&nbsp;        final int INARG_COUNT = srcType.parameterCount();</b>
<b class="nc"><i>409</i>&nbsp;        Object[] convSpecs = new Object[INARG_COUNT+1];</b>
<b class="nc"><i>410</i>&nbsp;        for (int i = 0; i &lt;= INARG_COUNT; i++) {</b>
<i>411</i>&nbsp;            boolean isRet = (i == INARG_COUNT);
<b class="nc"><i>412</i>&nbsp;            Class&lt;?&gt; src = isRet ? dstType.returnType() : srcType.parameterType(i);</b>
<i>413</i>&nbsp;            Class&lt;?&gt; dst = isRet ? srcType.returnType() : dstType.parameterType(i);
<b class="nc"><i>414</i>&nbsp;            if (!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict)) {</b>
<b class="nc"><i>415</i>&nbsp;                convSpecs[i] = valueConversion(src, dst, strict, monobox);</b>
<b class="nc"><i>416</i>&nbsp;            }</b>
<b class="nc"><i>417</i>&nbsp;        }</b>
<i>418</i>&nbsp;        return convSpecs;
<b class="nc"><i>419</i>&nbsp;    }</b>
<i>420</i>&nbsp;    static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType,
<i>421</i>&nbsp;                                            boolean strict) {
<i>422</i>&nbsp;        return makePairwiseConvert(target, srcType, strict, /*monobox=*/ false);
<i>423</i>&nbsp;    }
<b class="nc"><i>424</i>&nbsp;</b>
<b class="nc"><i>425</i>&nbsp;    /**</b>
<b class="nc"><i>426</i>&nbsp;     * Find a conversion function from the given source to the given destination.</b>
<i>427</i>&nbsp;     * This conversion function will be used as a LF NamedFunction.
<b class="nc"><i>428</i>&nbsp;     * Return a Class object if a simple cast is needed.</b>
<i>429</i>&nbsp;     * Return void.class if void is involved.
<i>430</i>&nbsp;     */
<i>431</i>&nbsp;    static Object valueConversion(Class&lt;?&gt; src, Class&lt;?&gt; dst, boolean strict, boolean monobox) {
<i>432</i>&nbsp;        assert(!VerifyType.isNullConversion(src, dst, /*keepInterfaces=*/ strict));  // caller responsibility
<b class="nc"><i>433</i>&nbsp;        if (dst == void.class)</b>
<i>434</i>&nbsp;            return dst;
<b class="nc"><i>435</i>&nbsp;        MethodHandle fn;</b>
<b class="nc"><i>436</i>&nbsp;        if (src.isPrimitive()) {</b>
<i>437</i>&nbsp;            if (src == void.class) {
<i>438</i>&nbsp;                return void.class;  // caller must recognize this specially
<i>439</i>&nbsp;            } else if (dst.isPrimitive()) {
<b class="nc"><i>440</i>&nbsp;                // Examples: int-&gt;byte, byte-&gt;int, boolean-&gt;int (!strict)</b>
<b class="nc"><i>441</i>&nbsp;                fn = ValueConversions.convertPrimitive(src, dst);</b>
<b class="nc"><i>442</i>&nbsp;            } else {</b>
<b class="nc"><i>443</i>&nbsp;                // Examples: int-&gt;Integer, boolean-&gt;Object, float-&gt;Number</b>
<b class="nc"><i>444</i>&nbsp;                Wrapper wsrc = Wrapper.forPrimitiveType(src);</b>
<b class="nc"><i>445</i>&nbsp;                fn = ValueConversions.boxExact(wsrc);</b>
<i>446</i>&nbsp;                assert(fn.type().parameterType(0) == wsrc.primitiveType());
<i>447</i>&nbsp;                assert(fn.type().returnType() == wsrc.wrapperType());
<b class="nc"><i>448</i>&nbsp;                if (!VerifyType.isNullConversion(wsrc.wrapperType(), dst, strict)) {</b>
<i>449</i>&nbsp;                    // Corner case, such as int-&gt;Long, which will probably fail.
<i>450</i>&nbsp;                    MethodType mt = MethodType.methodType(dst, src);
<i>451</i>&nbsp;                    if (strict)
<i>452</i>&nbsp;                        fn = fn.asType(mt);
<i>453</i>&nbsp;                    else
<b class="nc"><i>454</i>&nbsp;                        fn = MethodHandleImpl.makePairwiseConvert(fn, mt, /*strict=*/ false);</b>
<i>455</i>&nbsp;                }
<i>456</i>&nbsp;            }
<b class="nc"><i>457</i>&nbsp;        } else if (dst.isPrimitive()) {</b>
<b class="nc"><i>458</i>&nbsp;            Wrapper wdst = Wrapper.forPrimitiveType(dst);</b>
<b class="nc"><i>459</i>&nbsp;            if (monobox || src == wdst.wrapperType()) {</b>
<b class="nc"><i>460</i>&nbsp;                // Use a strongly-typed unboxer, if possible.</b>
<i>461</i>&nbsp;                fn = ValueConversions.unboxExact(wdst, strict);
<i>462</i>&nbsp;            } else {
<i>463</i>&nbsp;                // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int, Byte-&gt;int
<i>464</i>&nbsp;                // must include additional conversions
<b class="nc"><i>465</i>&nbsp;                // src must be examined at runtime, to detect Byte, Character, etc.</b>
<i>466</i>&nbsp;                fn = (strict
<i>467</i>&nbsp;                        ? ValueConversions.unboxWiden(wdst)
<i>468</i>&nbsp;                        : ValueConversions.unboxCast(wdst));
<i>469</i>&nbsp;            }
<b class="nc"><i>470</i>&nbsp;        } else {</b>
<i>471</i>&nbsp;            // Simple reference conversion.
<i>472</i>&nbsp;            // Note:  Do not check for a class hierarchy relation
<i>473</i>&nbsp;            // between src and dst.  In all cases a &#39;null&#39; argument
<i>474</i>&nbsp;            // will pass the cast conversion.
<b class="nc"><i>475</i>&nbsp;            return dst;</b>
<i>476</i>&nbsp;        }
<i>477</i>&nbsp;        assert(fn.type().parameterCount() &lt;= 1) : &quot;pc&quot;+Arrays.asList(src.getSimpleName(), dst.getSimpleName(), fn);
<i>478</i>&nbsp;        return fn;
<i>479</i>&nbsp;    }
<b class="nc"><i>480</i>&nbsp;</b>
<b class="nc"><i>481</i>&nbsp;    static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {</b>
<i>482</i>&nbsp;        MethodType type = target.type();
<i>483</i>&nbsp;        int last = type.parameterCount() - 1;
<i>484</i>&nbsp;        if (type.parameterType(last) != arrayType)
<i>485</i>&nbsp;            target = target.asType(type.changeParameterType(last, arrayType));
<b class="nc"><i>486</i>&nbsp;        target = target.asFixedArity();  // make sure this attribute is turned off</b>
<b class="nc"><i>487</i>&nbsp;        return new AsVarargsCollector(target, arrayType);</b>
<b class="nc"><i>488</i>&nbsp;    }</b>
<b class="nc"><i>489</i>&nbsp;</b>
<b class="nc"><i>490</i>&nbsp;    private static final class AsVarargsCollector extends DelegatingMethodHandle {</b>
<i>491</i>&nbsp;        private final MethodHandle target;
<b class="nc"><i>492</i>&nbsp;        private final Class&lt;?&gt; arrayType;</b>
<i>493</i>&nbsp;        private @Stable MethodHandle asCollectorCache;
<i>494</i>&nbsp;
<b class="nc"><i>495</i>&nbsp;        AsVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {</b>
<b class="nc"><i>496</i>&nbsp;            this(target.type(), target, arrayType);</b>
<b class="nc"><i>497</i>&nbsp;        }</b>
<i>498</i>&nbsp;        AsVarargsCollector(MethodType type, MethodHandle target, Class&lt;?&gt; arrayType) {
<b class="nc"><i>499</i>&nbsp;            super(type, target);</b>
<i>500</i>&nbsp;            this.target = target;
<i>501</i>&nbsp;            this.arrayType = arrayType;
<b class="nc"><i>502</i>&nbsp;        }</b>
<b class="nc"><i>503</i>&nbsp;</b>
<b class="nc"><i>504</i>&nbsp;        @Override</b>
<b class="nc"><i>505</i>&nbsp;        public boolean isVarargsCollector() {</b>
<b class="nc"><i>506</i>&nbsp;            return true;</b>
<b class="nc"><i>507</i>&nbsp;        }</b>
<b class="nc"><i>508</i>&nbsp;</b>
<i>509</i>&nbsp;        @Override
<i>510</i>&nbsp;        protected MethodHandle getTarget() {
<i>511</i>&nbsp;            return target;
<i>512</i>&nbsp;        }
<b class="nc"><i>513</i>&nbsp;</b>
<b class="nc"><i>514</i>&nbsp;        @Override</b>
<i>515</i>&nbsp;        public MethodHandle asFixedArity() {
<b class="nc"><i>516</i>&nbsp;            return target;</b>
<b class="nc"><i>517</i>&nbsp;        }</b>
<b class="nc"><i>518</i>&nbsp;</b>
<b class="nc"><i>519</i>&nbsp;        @Override</b>
<b class="nc"><i>520</i>&nbsp;        MethodHandle setVarargs(MemberName member) {</b>
<i>521</i>&nbsp;            if (member.isVarargs())  return this;
<i>522</i>&nbsp;            return asFixedArity();
<i>523</i>&nbsp;        }
<i>524</i>&nbsp;
<i>525</i>&nbsp;        @Override
<i>526</i>&nbsp;        public MethodHandle withVarargs(boolean makeVarargs) {
<b class="nc"><i>527</i>&nbsp;            if (makeVarargs)  return this;</b>
<i>528</i>&nbsp;            return asFixedArity();
<b class="nc"><i>529</i>&nbsp;        }</b>
<b class="nc"><i>530</i>&nbsp;</b>
<b class="nc"><i>531</i>&nbsp;        @Override</b>
<b class="nc"><i>532</i>&nbsp;        public MethodHandle asTypeUncached(MethodType newType) {</b>
<i>533</i>&nbsp;            MethodType type = this.type();
<b class="nc"><i>534</i>&nbsp;            int collectArg = type.parameterCount() - 1;</b>
<i>535</i>&nbsp;            int newArity = newType.parameterCount();
<b class="nc"><i>536</i>&nbsp;            if (newArity == collectArg+1 &amp;&amp;</b>
<b class="nc"><i>537</i>&nbsp;                type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {</b>
<i>538</i>&nbsp;                // if arity and trailing parameter are compatible, do normal thing
<b class="nc"><i>539</i>&nbsp;                return asTypeCache = asFixedArity().asType(newType);</b>
<b class="nc"><i>540</i>&nbsp;            }</b>
<b class="nc"><i>541</i>&nbsp;            // check cache</b>
<b class="nc"><i>542</i>&nbsp;            MethodHandle acc = asCollectorCache;</b>
<i>543</i>&nbsp;            if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)
<b class="nc"><i>544</i>&nbsp;                return asTypeCache = acc.asType(newType);</b>
<b class="nc"><i>545</i>&nbsp;            // build and cache a collector</b>
<b class="nc"><i>546</i>&nbsp;            int arrayLength = newArity - collectArg;</b>
<i>547</i>&nbsp;            MethodHandle collector;
<b class="nc"><i>548</i>&nbsp;            try {</b>
<b class="nc"><i>549</i>&nbsp;                collector = asFixedArity().asCollector(arrayType, arrayLength);</b>
<b class="nc"><i>550</i>&nbsp;                assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;</b>
<b class="nc"><i>551</i>&nbsp;            } catch (IllegalArgumentException ex) {</b>
<b class="nc"><i>552</i>&nbsp;                throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);</b>
<b class="nc"><i>553</i>&nbsp;            }</b>
<i>554</i>&nbsp;            asCollectorCache = collector;
<b class="nc"><i>555</i>&nbsp;            return asTypeCache = collector.asType(newType);</b>
<b class="nc"><i>556</i>&nbsp;        }</b>
<i>557</i>&nbsp;
<i>558</i>&nbsp;        @Override
<b class="nc"><i>559</i>&nbsp;        boolean viewAsTypeChecks(MethodType newType, boolean strict) {</b>
<i>560</i>&nbsp;            super.viewAsTypeChecks(newType, true);
<i>561</i>&nbsp;            if (strict) return true;
<b class="nc"><i>562</i>&nbsp;            // extra assertion for non-strict checks:</b>
<b class="nc"><i>563</i>&nbsp;            assert (type().lastParameterType().getComponentType()</b>
<b class="nc"><i>564</i>&nbsp;                    .isAssignableFrom(</b>
<b class="nc"><i>565</i>&nbsp;                            newType.lastParameterType().getComponentType()))</b>
<i>566</i>&nbsp;                    : Arrays.asList(this, newType);
<b class="nc"><i>567</i>&nbsp;            return true;</b>
<i>568</i>&nbsp;        }
<b class="nc"><i>569</i>&nbsp;</b>
<b class="nc"><i>570</i>&nbsp;        @Override</b>
<i>571</i>&nbsp;        public Object invokeWithArguments(Object... arguments) throws Throwable {
<i>572</i>&nbsp;            MethodType type = this.type();
<i>573</i>&nbsp;            int argc;
<b class="nc"><i>574</i>&nbsp;            final int MAX_SAFE = 127;  // 127 longs require 254 slots, which is safe to spread</b>
<b class="nc"><i>575</i>&nbsp;            if (arguments == null</b>
<b class="nc"><i>576</i>&nbsp;                    || (argc = arguments.length) &lt;= MAX_SAFE</b>
<b class="nc"><i>577</i>&nbsp;                    || argc &lt; type.parameterCount()) {</b>
<b class="nc"><i>578</i>&nbsp;                return super.invokeWithArguments(arguments);</b>
<b class="nc"><i>579</i>&nbsp;            }</b>
<b class="nc"><i>580</i>&nbsp;</b>
<b class="nc"><i>581</i>&nbsp;            // a jumbo invocation requires more explicit reboxing of the trailing arguments</b>
<i>582</i>&nbsp;            int uncollected = type.parameterCount() - 1;
<i>583</i>&nbsp;            Class&lt;?&gt; elemType = arrayType.getComponentType();
<b class="nc"><i>584</i>&nbsp;            int collected = argc - uncollected;</b>
<i>585</i>&nbsp;            Object collArgs = (elemType == Object.class)
<i>586</i>&nbsp;                ? new Object[collected] : Array.newInstance(elemType, collected);
<i>587</i>&nbsp;            if (!elemType.isPrimitive()) {
<i>588</i>&nbsp;                // simple cast:  just do some casting
<i>589</i>&nbsp;                try {
<i>590</i>&nbsp;                    System.arraycopy(arguments, uncollected, collArgs, 0, collected);
<b class="nc"><i>591</i>&nbsp;                } catch (ArrayStoreException ex) {</b>
<b class="nc"><i>592</i>&nbsp;                    return super.invokeWithArguments(arguments);</b>
<i>593</i>&nbsp;                }
<i>594</i>&nbsp;            } else {
<i>595</i>&nbsp;                // corner case of flat array requires reflection (or specialized copy loop)
<i>596</i>&nbsp;                MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
<i>597</i>&nbsp;                try {
<i>598</i>&nbsp;                    for (int i = 0; i &lt; collected; i++) {
<i>599</i>&nbsp;                        arraySetter.invoke(collArgs, i, arguments[uncollected + i]);
<i>600</i>&nbsp;                    }
<i>601</i>&nbsp;                } catch (WrongMethodTypeException|ClassCastException ex) {
<i>602</i>&nbsp;                    return super.invokeWithArguments(arguments);
<i>603</i>&nbsp;                }
<i>604</i>&nbsp;            }
<i>605</i>&nbsp;
<i>606</i>&nbsp;            // chop the jumbo list down to size and call in non-varargs mode
<i>607</i>&nbsp;            Object[] newArgs = new Object[uncollected + 1];
<i>608</i>&nbsp;            System.arraycopy(arguments, 0, newArgs, 0, uncollected);
<i>609</i>&nbsp;            newArgs[uncollected] = collArgs;
<b class="nc"><i>610</i>&nbsp;            return asFixedArity().invokeWithArguments(newArgs);</b>
<b class="nc"><i>611</i>&nbsp;        }</b>
<i>612</i>&nbsp;    }
<i>613</i>&nbsp;
<b class="nc"><i>614</i>&nbsp;    /** Factory method:  Spread selected argument. */</b>
<b class="nc"><i>615</i>&nbsp;    static MethodHandle makeSpreadArguments(MethodHandle target,</b>
<i>616</i>&nbsp;                                            Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
<b class="nc"><i>617</i>&nbsp;        MethodType targetType = target.type();</b>
<b class="nc"><i>618</i>&nbsp;</b>
<i>619</i>&nbsp;        for (int i = 0; i &lt; spreadArgCount; i++) {
<b class="nc"><i>620</i>&nbsp;            Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);</b>
<b class="nc"><i>621</i>&nbsp;            if (arg == null)  arg = Object.class;</b>
<b class="nc"><i>622</i>&nbsp;            targetType = targetType.changeParameterType(spreadArgPos + i, arg);</b>
<b class="nc"><i>623</i>&nbsp;        }</b>
<i>624</i>&nbsp;        target = target.asType(targetType);
<b class="nc"><i>625</i>&nbsp;</b>
<b class="nc"><i>626</i>&nbsp;        MethodType srcType = targetType</b>
<b class="nc"><i>627</i>&nbsp;                .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);</b>
<b class="nc"><i>628</i>&nbsp;        // Now build a LambdaForm.</b>
<b class="nc"><i>629</i>&nbsp;        MethodType lambdaType = srcType.invokerType();</b>
<b class="nc"><i>630</i>&nbsp;        Name[] names = arguments(spreadArgCount + 2, lambdaType);</b>
<b class="nc"><i>631</i>&nbsp;        int nameCursor = lambdaType.parameterCount();</b>
<b class="nc"><i>632</i>&nbsp;        int[] indexes = new int[targetType.parameterCount()];</b>
<b class="nc"><i>633</i>&nbsp;</b>
<b class="nc"><i>634</i>&nbsp;        for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {</b>
<i>635</i>&nbsp;            Class&lt;?&gt; src = lambdaType.parameterType(i);
<b class="nc"><i>636</i>&nbsp;            if (i == spreadArgPos) {</b>
<b class="nc"><i>637</i>&nbsp;                // Spread the array.</b>
<b class="nc"><i>638</i>&nbsp;                MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);</b>
<i>639</i>&nbsp;                Name array = names[argIndex];
<b class="nc"><i>640</i>&nbsp;                names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);</b>
<b class="nc"><i>641</i>&nbsp;                for (int j = 0; j &lt; spreadArgCount; i++, j++) {</b>
<b class="nc"><i>642</i>&nbsp;                    indexes[i] = nameCursor;</b>
<i>643</i>&nbsp;                    names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);
<i>644</i>&nbsp;                }
<i>645</i>&nbsp;            } else if (i &lt; indexes.length) {
<i>646</i>&nbsp;                indexes[i] = argIndex;
<i>647</i>&nbsp;            }
<i>648</i>&nbsp;        }
<b class="nc"><i>649</i>&nbsp;        assert(nameCursor == names.length-1);  // leave room for the final call</b>
<b class="nc"><i>650</i>&nbsp;</b>
<b class="nc"><i>651</i>&nbsp;        // Build argument array for the call.</b>
<b class="nc"><i>652</i>&nbsp;        Name[] targetArgs = new Name[targetType.parameterCount()];</b>
<b class="nc"><i>653</i>&nbsp;        for (int i = 0; i &lt; targetType.parameterCount(); i++) {</b>
<b class="nc"><i>654</i>&nbsp;            int idx = indexes[i];</b>
<b class="nc"><i>655</i>&nbsp;            targetArgs[i] = names[idx];</b>
<b class="nc"><i>656</i>&nbsp;        }</b>
<b class="nc"><i>657</i>&nbsp;        names[names.length - 1] = new Name(target, (Object[]) targetArgs);</b>
<i>658</i>&nbsp;
<i>659</i>&nbsp;        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);
<i>660</i>&nbsp;        return SimpleMethodHandle.make(srcType, form);
<i>661</i>&nbsp;    }
<i>662</i>&nbsp;
<i>663</i>&nbsp;    static void checkSpreadArgument(Object av, int n) {
<b class="nc"><i>664</i>&nbsp;        if (av == null &amp;&amp; n == 0) {</b>
<b class="nc"><i>665</i>&nbsp;            return;</b>
<b class="nc"><i>666</i>&nbsp;        } else if (av == null) {</b>
<b class="nc"><i>667</i>&nbsp;            throw new NullPointerException(&quot;null array reference&quot;);</b>
<i>668</i>&nbsp;        } else if (av instanceof Object[]) {
<b class="nc"><i>669</i>&nbsp;            int len = ((Object[])av).length;</b>
<b class="nc"><i>670</i>&nbsp;            if (len == n)  return;</b>
<i>671</i>&nbsp;        } else {
<i>672</i>&nbsp;            int len = java.lang.reflect.Array.getLength(av);
<i>673</i>&nbsp;            if (len == n)  return;
<i>674</i>&nbsp;        }
<b class="nc"><i>675</i>&nbsp;        // fall through to error:</b>
<b class="nc"><i>676</i>&nbsp;        throw newIllegalArgumentException(&quot;array is not of length &quot;+n);</b>
<b class="nc"><i>677</i>&nbsp;    }</b>
<b class="nc"><i>678</i>&nbsp;</b>
<b class="nc"><i>679</i>&nbsp;    /** Factory method:  Collect or filter selected argument(s). */</b>
<b class="nc"><i>680</i>&nbsp;    static MethodHandle makeCollectArguments(MethodHandle target,</b>
<b class="nc"><i>681</i>&nbsp;                MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {</b>
<b class="nc"><i>682</i>&nbsp;        MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r</b>
<b class="nc"><i>683</i>&nbsp;        MethodType collectorType = collector.type();    // (b...)=&gt;c</b>
<i>684</i>&nbsp;        int collectArgCount = collectorType.parameterCount();
<b class="nc"><i>685</i>&nbsp;        Class&lt;?&gt; collectValType = collectorType.returnType();</b>
<b class="nc"><i>686</i>&nbsp;        int collectValCount = (collectValType == void.class ? 0 : 1);</b>
<b class="nc"><i>687</i>&nbsp;        MethodType srcType = targetType                 // (a..., [b...])=&gt;r</b>
<b class="nc"><i>688</i>&nbsp;                .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);</b>
<i>689</i>&nbsp;        if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r
<b class="nc"><i>690</i>&nbsp;            srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());</b>
<b class="nc"><i>691</i>&nbsp;        }</b>
<b class="nc"><i>692</i>&nbsp;        // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]</b>
<b class="nc"><i>693</i>&nbsp;        // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]</b>
<b class="nc"><i>694</i>&nbsp;        // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]</b>
<i>695</i>&nbsp;
<b class="nc"><i>696</i>&nbsp;        // Now build a LambdaForm.</b>
<b class="nc"><i>697</i>&nbsp;        MethodType lambdaType = srcType.invokerType();</b>
<i>698</i>&nbsp;        Name[] names = arguments(2, lambdaType);
<i>699</i>&nbsp;        final int collectNamePos = names.length - 2;
<i>700</i>&nbsp;        final int targetNamePos  = names.length - 1;
<i>701</i>&nbsp;
<i>702</i>&nbsp;        Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);
<b class="nc"><i>703</i>&nbsp;        names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);</b>
<b class="nc"><i>704</i>&nbsp;</b>
<i>705</i>&nbsp;        // Build argument array for the target.
<b class="nc"><i>706</i>&nbsp;        // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].</b>
<i>707</i>&nbsp;        // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
<i>708</i>&nbsp;        Name[] targetArgs = new Name[targetType.parameterCount()];
<i>709</i>&nbsp;        int inputArgPos  = 1;  // incoming LF args to copy to target
<i>710</i>&nbsp;        int targetArgPos = 0;  // fill pointer for targetArgs
<i>711</i>&nbsp;        int chunk = collectArgPos;  // |headArgs|
<i>712</i>&nbsp;        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
<i>713</i>&nbsp;        inputArgPos  += chunk;
<i>714</i>&nbsp;        targetArgPos += chunk;
<b class="nc"><i>715</i>&nbsp;        if (collectValType != void.class) {</b>
<i>716</i>&nbsp;            targetArgs[targetArgPos++] = names[collectNamePos];
<b class="nc"><i>717</i>&nbsp;        }</b>
<b class="nc"><i>718</i>&nbsp;        chunk = collectArgCount;</b>
<i>719</i>&nbsp;        if (retainOriginalArgs) {
<b class="nc"><i>720</i>&nbsp;            System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);</b>
<b class="nc"><i>721</i>&nbsp;            targetArgPos += chunk;   // optionally pass on the collected chunk</b>
<b class="nc"><i>722</i>&nbsp;        }</b>
<i>723</i>&nbsp;        inputArgPos += chunk;
<i>724</i>&nbsp;        chunk = targetArgs.length - targetArgPos;  // all the rest
<i>725</i>&nbsp;        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);
<i>726</i>&nbsp;        assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also
<i>727</i>&nbsp;        names[targetNamePos] = new Name(target, (Object[]) targetArgs);
<i>728</i>&nbsp;
<b class="nc"><i>729</i>&nbsp;        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);</b>
<b class="nc"><i>730</i>&nbsp;        return SimpleMethodHandle.make(srcType, form);</b>
<b class="nc"><i>731</i>&nbsp;    }</b>
<b class="nc"><i>732</i>&nbsp;</b>
<i>733</i>&nbsp;    @LambdaForm.Hidden
<i>734</i>&nbsp;    static
<b class="nc"><i>735</i>&nbsp;    MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {</b>
<b class="nc"><i>736</i>&nbsp;        if (testResult) {</b>
<i>737</i>&nbsp;            return target;
<b class="nc"><i>738</i>&nbsp;        } else {</b>
<b class="nc"><i>739</i>&nbsp;            return fallback;</b>
<b class="nc"><i>740</i>&nbsp;        }</b>
<i>741</i>&nbsp;    }
<b class="nc"><i>742</i>&nbsp;</b>
<b class="nc"><i>743</i>&nbsp;    // Intrinsified by C2. Counters are used during parsing to calculate branch frequencies.</b>
<i>744</i>&nbsp;    @LambdaForm.Hidden
<b class="nc"><i>745</i>&nbsp;    @jdk.internal.HotSpotIntrinsicCandidate</b>
<b class="nc"><i>746</i>&nbsp;    static</b>
<b class="nc"><i>747</i>&nbsp;    boolean profileBoolean(boolean result, int[] counters) {</b>
<b class="nc"><i>748</i>&nbsp;        // Profile is int[2] where [0] and [1] correspond to false and true occurrences respectively.</b>
<b class="nc"><i>749</i>&nbsp;        int idx = result ? 1 : 0;</b>
<i>750</i>&nbsp;        try {
<i>751</i>&nbsp;            counters[idx] = Math.addExact(counters[idx], 1);
<i>752</i>&nbsp;        } catch (ArithmeticException e) {
<i>753</i>&nbsp;            // Avoid continuous overflow by halving the problematic count.
<i>754</i>&nbsp;            counters[idx] = counters[idx] / 2;
<b class="nc"><i>755</i>&nbsp;        }</b>
<b class="nc"><i>756</i>&nbsp;        return result;</b>
<i>757</i>&nbsp;    }
<b class="nc"><i>758</i>&nbsp;</b>
<i>759</i>&nbsp;    // Intrinsified by C2. Returns true if obj is a compile-time constant.
<i>760</i>&nbsp;    @LambdaForm.Hidden
<i>761</i>&nbsp;    @jdk.internal.HotSpotIntrinsicCandidate
<i>762</i>&nbsp;    static
<i>763</i>&nbsp;    boolean isCompileConstant(Object obj) {
<i>764</i>&nbsp;        return false;
<i>765</i>&nbsp;    }
<i>766</i>&nbsp;
<i>767</i>&nbsp;    static
<b class="nc"><i>768</i>&nbsp;    MethodHandle makeGuardWithTest(MethodHandle test,</b>
<b class="nc"><i>769</i>&nbsp;                                   MethodHandle target,</b>
<i>770</i>&nbsp;                                   MethodHandle fallback) {
<i>771</i>&nbsp;        MethodType type = target.type();
<i>772</i>&nbsp;        assert(test.type().equals(type.changeReturnType(boolean.class)) &amp;&amp; fallback.type().equals(type));
<i>773</i>&nbsp;        MethodType basicType = type.basicType();
<i>774</i>&nbsp;        LambdaForm form = makeGuardWithTestForm(basicType);
<b class="nc"><i>775</i>&nbsp;        BoundMethodHandle mh;</b>
<i>776</i>&nbsp;        try {
<i>777</i>&nbsp;            if (PROFILE_GWT) {
<b class="nc"><i>778</i>&nbsp;                int[] counts = new int[2];</b>
<i>779</i>&nbsp;                mh = (BoundMethodHandle)
<i>780</i>&nbsp;                        BoundMethodHandle.speciesData_LLLL().factory().invokeBasic(type, form,
<i>781</i>&nbsp;                                (Object) test, (Object) profile(target), (Object) profile(fallback), counts);
<i>782</i>&nbsp;            } else {
<i>783</i>&nbsp;                mh = (BoundMethodHandle)
<i>784</i>&nbsp;                        BoundMethodHandle.speciesData_LLL().factory().invokeBasic(type, form,
<b class="nc"><i>785</i>&nbsp;                                (Object) test, (Object) profile(target), (Object) profile(fallback));</b>
<i>786</i>&nbsp;            }
<i>787</i>&nbsp;        } catch (Throwable ex) {
<b class="nc"><i>788</i>&nbsp;            throw uncaughtException(ex);</b>
<i>789</i>&nbsp;        }
<i>790</i>&nbsp;        assert(mh.type() == type);
<i>791</i>&nbsp;        return mh;
<i>792</i>&nbsp;    }
<i>793</i>&nbsp;
<i>794</i>&nbsp;
<i>795</i>&nbsp;    static
<i>796</i>&nbsp;    MethodHandle profile(MethodHandle target) {
<i>797</i>&nbsp;        if (DONT_INLINE_THRESHOLD &gt;= 0) {
<i>798</i>&nbsp;            return makeBlockInliningWrapper(target);
<b class="nc"><i>799</i>&nbsp;        } else {</b>
<i>800</i>&nbsp;            return target;
<i>801</i>&nbsp;        }
<i>802</i>&nbsp;    }
<i>803</i>&nbsp;
<i>804</i>&nbsp;    /**
<i>805</i>&nbsp;     * Block inlining during JIT-compilation of a target method handle if it hasn&#39;t been invoked enough times.
<i>806</i>&nbsp;     * Corresponding LambdaForm has @DontInline when compiled into bytecode.
<i>807</i>&nbsp;     */
<i>808</i>&nbsp;    static
<i>809</i>&nbsp;    MethodHandle makeBlockInliningWrapper(MethodHandle target) {
<b class="nc"><i>810</i>&nbsp;        LambdaForm lform;</b>
<b class="nc"><i>811</i>&nbsp;        if (DONT_INLINE_THRESHOLD &gt; 0) {</b>
<b class="nc"><i>812</i>&nbsp;            lform = Makers.PRODUCE_BLOCK_INLINING_FORM.apply(target);</b>
<b class="nc"><i>813</i>&nbsp;        } else {</b>
<b class="nc"><i>814</i>&nbsp;            lform = Makers.PRODUCE_REINVOKER_FORM.apply(target);</b>
<b class="nc"><i>815</i>&nbsp;        }</b>
<i>816</i>&nbsp;        return new CountingWrapper(target, lform,
<i>817</i>&nbsp;                Makers.PRODUCE_BLOCK_INLINING_FORM, Makers.PRODUCE_REINVOKER_FORM,
<i>818</i>&nbsp;                                   DONT_INLINE_THRESHOLD);
<i>819</i>&nbsp;    }
<i>820</i>&nbsp;
<b class="nc"><i>821</i>&nbsp;    private final static class Makers {</b>
<i>822</i>&nbsp;        /** Constructs reinvoker lambda form which block inlining during JIT-compilation for a particular method handle */
<i>823</i>&nbsp;        static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_BLOCK_INLINING_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {
<i>824</i>&nbsp;            @Override
<i>825</i>&nbsp;            public LambdaForm apply(MethodHandle target) {
<b class="nc"><i>826</i>&nbsp;                return DelegatingMethodHandle.makeReinvokerForm(target,</b>
<i>827</i>&nbsp;                                   MethodTypeForm.LF_DELEGATE_BLOCK_INLINING, CountingWrapper.class, false,
<b class="nc"><i>828</i>&nbsp;                                   DelegatingMethodHandle.NF_getTarget, CountingWrapper.NF_maybeStopCounting);</b>
<i>829</i>&nbsp;            }
<b class="nc"><i>830</i>&nbsp;        };</b>
<b class="nc"><i>831</i>&nbsp;</b>
<b class="nc"><i>832</i>&nbsp;        /** Constructs simple reinvoker lambda form for a particular method handle */</b>
<b class="nc"><i>833</i>&nbsp;        static final Function&lt;MethodHandle, LambdaForm&gt; PRODUCE_REINVOKER_FORM = new Function&lt;MethodHandle, LambdaForm&gt;() {</b>
<i>834</i>&nbsp;            @Override
<b class="nc"><i>835</i>&nbsp;            public LambdaForm apply(MethodHandle target) {</b>
<i>836</i>&nbsp;                return DelegatingMethodHandle.makeReinvokerForm(target,
<i>837</i>&nbsp;                        MethodTypeForm.LF_DELEGATE, DelegatingMethodHandle.class, DelegatingMethodHandle.NF_getTarget);
<i>838</i>&nbsp;            }
<b class="nc"><i>839</i>&nbsp;        };</b>
<i>840</i>&nbsp;
<b class="nc"><i>841</i>&nbsp;        /** Maker of type-polymorphic varargs */</b>
<b class="nc"><i>842</i>&nbsp;        static final ClassValue&lt;MethodHandle[]&gt; TYPED_COLLECTORS = new ClassValue&lt;MethodHandle[]&gt;() {</b>
<b class="nc"><i>843</i>&nbsp;            @Override</b>
<i>844</i>&nbsp;            protected MethodHandle[] computeValue(Class&lt;?&gt; type) {
<b class="nc"><i>845</i>&nbsp;                return new MethodHandle[MAX_JVM_ARITY + 1];</b>
<i>846</i>&nbsp;            }
<i>847</i>&nbsp;        };
<b class="nc"><i>848</i>&nbsp;    }</b>
<b class="nc"><i>849</i>&nbsp;</b>
<i>850</i>&nbsp;    /**
<i>851</i>&nbsp;     * Counting method handle. It has 2 states: counting and non-counting.
<i>852</i>&nbsp;     * It is in counting state for the first n invocations and then transitions to non-counting state.
<i>853</i>&nbsp;     * Behavior in counting and non-counting states is determined by lambda forms produced by
<i>854</i>&nbsp;     * countingFormProducer &amp; nonCountingFormProducer respectively.
<b class="nc"><i>855</i>&nbsp;     */</b>
<b class="nc"><i>856</i>&nbsp;    static class CountingWrapper extends DelegatingMethodHandle {</b>
<i>857</i>&nbsp;        private final MethodHandle target;
<b class="nc"><i>858</i>&nbsp;        private int count;</b>
<b class="nc"><i>859</i>&nbsp;        private Function&lt;MethodHandle, LambdaForm&gt; countingFormProducer;</b>
<b class="nc"><i>860</i>&nbsp;        private Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer;</b>
<i>861</i>&nbsp;        private volatile boolean isCounting;
<i>862</i>&nbsp;
<i>863</i>&nbsp;        private CountingWrapper(MethodHandle target, LambdaForm lform,
<i>864</i>&nbsp;                                Function&lt;MethodHandle, LambdaForm&gt; countingFromProducer,
<i>865</i>&nbsp;                                Function&lt;MethodHandle, LambdaForm&gt; nonCountingFormProducer,
<b class="nc"><i>866</i>&nbsp;                                int count) {</b>
<i>867</i>&nbsp;            super(target.type(), lform);
<b class="nc"><i>868</i>&nbsp;            this.target = target;</b>
<b class="nc"><i>869</i>&nbsp;            this.count = count;</b>
<b class="nc"><i>870</i>&nbsp;            this.countingFormProducer = countingFromProducer;</b>
<b class="nc"><i>871</i>&nbsp;            this.nonCountingFormProducer = nonCountingFormProducer;</b>
<i>872</i>&nbsp;            this.isCounting = (count &gt; 0);
<i>873</i>&nbsp;        }
<i>874</i>&nbsp;
<i>875</i>&nbsp;        @Hidden
<i>876</i>&nbsp;        @Override
<b class="nc"><i>877</i>&nbsp;        protected MethodHandle getTarget() {</b>
<b class="nc"><i>878</i>&nbsp;            return target;</b>
<i>879</i>&nbsp;        }
<i>880</i>&nbsp;
<b class="nc"><i>881</i>&nbsp;        @Override</b>
<b class="nc"><i>882</i>&nbsp;        public MethodHandle asTypeUncached(MethodType newType) {</b>
<b class="nc"><i>883</i>&nbsp;            MethodHandle newTarget = target.asType(newType);</b>
<b class="nc"><i>884</i>&nbsp;            MethodHandle wrapper;</b>
<b class="nc"><i>885</i>&nbsp;            if (isCounting) {</b>
<b class="nc"><i>886</i>&nbsp;                LambdaForm lform;</b>
<b class="nc"><i>887</i>&nbsp;                lform = countingFormProducer.apply(newTarget);</b>
<b class="nc"><i>888</i>&nbsp;                wrapper = new CountingWrapper(newTarget, lform, countingFormProducer, nonCountingFormProducer, DONT_INLINE_THRESHOLD);</b>
<b class="nc"><i>889</i>&nbsp;            } else {</b>
<b class="nc"><i>890</i>&nbsp;                wrapper = newTarget; // no need for a counting wrapper anymore</b>
<b class="nc"><i>891</i>&nbsp;            }</b>
<b class="nc"><i>892</i>&nbsp;            return (asTypeCache = wrapper);</b>
<i>893</i>&nbsp;        }
<b class="nc"><i>894</i>&nbsp;</b>
<b class="nc"><i>895</i>&nbsp;        // Customize target if counting happens for too long.</b>
<i>896</i>&nbsp;        private int invocations = CUSTOMIZE_THRESHOLD;
<b class="nc"><i>897</i>&nbsp;        private void maybeCustomizeTarget() {</b>
<b class="nc"><i>898</i>&nbsp;            int c = invocations;</b>
<b class="nc"><i>899</i>&nbsp;            if (c &gt;= 0) {</b>
<b class="nc"><i>900</i>&nbsp;                if (c == 1) {</b>
<b class="nc"><i>901</i>&nbsp;                    target.customize();</b>
<b class="nc"><i>902</i>&nbsp;                }</b>
<b class="nc"><i>903</i>&nbsp;                invocations = c - 1;</b>
<b class="nc"><i>904</i>&nbsp;            }</b>
<b class="nc"><i>905</i>&nbsp;        }</b>
<i>906</i>&nbsp;
<b class="nc"><i>907</i>&nbsp;        boolean countDown() {</b>
<i>908</i>&nbsp;            int c = count;
<i>909</i>&nbsp;            maybeCustomizeTarget();
<b class="nc"><i>910</i>&nbsp;            if (c &lt;= 1) {</b>
<b class="nc"><i>911</i>&nbsp;                // Try to limit number of updates. MethodHandle.updateForm() doesn&#39;t guarantee LF update visibility.</b>
<b class="nc"><i>912</i>&nbsp;                if (isCounting) {</b>
<i>913</i>&nbsp;                    isCounting = false;
<i>914</i>&nbsp;                    return true;
<b class="nc"><i>915</i>&nbsp;                } else {</b>
<b class="nc"><i>916</i>&nbsp;                    return false;</b>
<i>917</i>&nbsp;                }
<i>918</i>&nbsp;            } else {
<b class="nc"><i>919</i>&nbsp;                count = c - 1;</b>
<i>920</i>&nbsp;                return false;
<i>921</i>&nbsp;            }
<b class="nc"><i>922</i>&nbsp;        }</b>
<b class="nc"><i>923</i>&nbsp;</b>
<i>924</i>&nbsp;        @Hidden
<b class="nc"><i>925</i>&nbsp;        static void maybeStopCounting(Object o1) {</b>
<i>926</i>&nbsp;             CountingWrapper wrapper = (CountingWrapper) o1;
<b class="nc"><i>927</i>&nbsp;             if (wrapper.countDown()) {</b>
<i>928</i>&nbsp;                 // Reached invocation threshold. Replace counting behavior with a non-counting one.
<i>929</i>&nbsp;                 LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);
<i>930</i>&nbsp;                 lform.compileToBytecode(); // speed up warmup by avoiding LF interpretation again after transition
<i>931</i>&nbsp;                 wrapper.updateForm(lform);
<i>932</i>&nbsp;             }
<i>933</i>&nbsp;        }
<i>934</i>&nbsp;
<i>935</i>&nbsp;        static final NamedFunction NF_maybeStopCounting;
<i>936</i>&nbsp;        static {
<i>937</i>&nbsp;            Class&lt;?&gt; THIS_CLASS = CountingWrapper.class;
<i>938</i>&nbsp;            try {
<i>939</i>&nbsp;                NF_maybeStopCounting = new NamedFunction(THIS_CLASS.getDeclaredMethod(&quot;maybeStopCounting&quot;, Object.class));
<i>940</i>&nbsp;            } catch (ReflectiveOperationException ex) {
<i>941</i>&nbsp;                throw newInternalError(ex);
<i>942</i>&nbsp;            }
<i>943</i>&nbsp;        }
<i>944</i>&nbsp;    }
<i>945</i>&nbsp;
<i>946</i>&nbsp;    static
<i>947</i>&nbsp;    LambdaForm makeGuardWithTestForm(MethodType basicType) {
<i>948</i>&nbsp;        LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWT);
<i>949</i>&nbsp;        if (lform != null)  return lform;
<i>950</i>&nbsp;        final int THIS_MH      = 0;  // the BMH_LLL
<i>951</i>&nbsp;        final int ARG_BASE     = 1;  // start of incoming arguments
<b class="nc"><i>952</i>&nbsp;        final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();</b>
<i>953</i>&nbsp;        int nameCursor = ARG_LIMIT;
<b class="nc"><i>954</i>&nbsp;        final int GET_TEST     = nameCursor++;</b>
<b class="nc"><i>955</i>&nbsp;        final int GET_TARGET   = nameCursor++;</b>
<b class="nc"><i>956</i>&nbsp;        final int GET_FALLBACK = nameCursor++;</b>
<i>957</i>&nbsp;        final int GET_COUNTERS = PROFILE_GWT ? nameCursor++ : -1;
<i>958</i>&nbsp;        final int CALL_TEST    = nameCursor++;
<i>959</i>&nbsp;        final int PROFILE      = (GET_COUNTERS != -1) ? nameCursor++ : -1;
<b class="nc"><i>960</i>&nbsp;        final int TEST         = nameCursor-1; // previous statement: either PROFILE or CALL_TEST</b>
<i>961</i>&nbsp;        final int SELECT_ALT   = nameCursor++;
<b class="nc"><i>962</i>&nbsp;        final int CALL_TARGET  = nameCursor++;</b>
<b class="nc"><i>963</i>&nbsp;        assert(CALL_TARGET == SELECT_ALT+1);  // must be true to trigger IBG.emitSelectAlternative</b>
<b class="nc"><i>964</i>&nbsp;</b>
<b class="nc"><i>965</i>&nbsp;        MethodType lambdaType = basicType.invokerType();</b>
<b class="nc"><i>966</i>&nbsp;        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);</b>
<b class="nc"><i>967</i>&nbsp;</b>
<b class="nc"><i>968</i>&nbsp;        BoundMethodHandle.SpeciesData data =</b>
<b class="nc"><i>969</i>&nbsp;                (GET_COUNTERS != -1) ? BoundMethodHandle.speciesData_LLLL()</b>
<b class="nc"><i>970</i>&nbsp;                                     : BoundMethodHandle.speciesData_LLL();</b>
<i>971</i>&nbsp;        names[THIS_MH] = names[THIS_MH].withConstraint(data);
<b class="nc"><i>972</i>&nbsp;        names[GET_TEST]     = new Name(data.getterFunction(0), names[THIS_MH]);</b>
<i>973</i>&nbsp;        names[GET_TARGET]   = new Name(data.getterFunction(1), names[THIS_MH]);
<b class="nc"><i>974</i>&nbsp;        names[GET_FALLBACK] = new Name(data.getterFunction(2), names[THIS_MH]);</b>
<b class="nc"><i>975</i>&nbsp;        if (GET_COUNTERS != -1) {</b>
<b class="nc"><i>976</i>&nbsp;            names[GET_COUNTERS] = new Name(data.getterFunction(3), names[THIS_MH]);</b>
<b class="nc"><i>977</i>&nbsp;        }</b>
<b class="nc"><i>978</i>&nbsp;        Object[] invokeArgs = Arrays.copyOfRange(names, 0, ARG_LIMIT, Object[].class);</b>
<b class="nc"><i>979</i>&nbsp;</b>
<b class="nc"><i>980</i>&nbsp;        // call test</b>
<i>981</i>&nbsp;        MethodType testType = basicType.changeReturnType(boolean.class).basicType();
<i>982</i>&nbsp;        invokeArgs[0] = names[GET_TEST];
<i>983</i>&nbsp;        names[CALL_TEST] = new Name(testType, invokeArgs);
<i>984</i>&nbsp;
<b class="nc"><i>985</i>&nbsp;        // profile branch</b>
<b class="nc"><i>986</i>&nbsp;        if (PROFILE != -1) {</b>
<b class="nc"><i>987</i>&nbsp;            names[PROFILE] = new Name(getFunction(NF_profileBoolean), names[CALL_TEST], names[GET_COUNTERS]);</b>
<b class="nc"><i>988</i>&nbsp;        }</b>
<b class="nc"><i>989</i>&nbsp;        // call selectAlternative</b>
<b class="nc"><i>990</i>&nbsp;        names[SELECT_ALT] = new Name(new NamedFunction(getConstantHandle(MH_selectAlternative), Intrinsic.SELECT_ALTERNATIVE), names[TEST], names[GET_TARGET], names[GET_FALLBACK]);</b>
<i>991</i>&nbsp;
<i>992</i>&nbsp;        // call target or fallback
<b class="nc"><i>993</i>&nbsp;        invokeArgs[0] = names[SELECT_ALT];</b>
<b class="nc"><i>994</i>&nbsp;        names[CALL_TARGET] = new Name(basicType, invokeArgs);</b>
<i>995</i>&nbsp;
<i>996</i>&nbsp;        lform = new LambdaForm(lambdaType.parameterCount(), names, /*forceInline=*/true, Kind.GUARD);
<b class="nc"><i>997</i>&nbsp;</b>
<b class="nc"><i>998</i>&nbsp;        return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWT, lform);</b>
<b class="nc"><i>999</i>&nbsp;    }</b>
<i>1000</i>&nbsp;
<b class="nc"><i>1001</i>&nbsp;    /**</b>
<i>1002</i>&nbsp;     * The LambdaForm shape for catchException combinator is the following:
<b class="nc"><i>1003</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<i>1004</i>&nbsp;     *  guardWithCatch=Lambda(a0:L,a1:L,a2:L)=&gt;{
<i>1005</i>&nbsp;     *    t3:L=BoundMethodHandle$Species_LLLLL.argL0(a0:L);
<i>1006</i>&nbsp;     *    t4:L=BoundMethodHandle$Species_LLLLL.argL1(a0:L);
<i>1007</i>&nbsp;     *    t5:L=BoundMethodHandle$Species_LLLLL.argL2(a0:L);
<i>1008</i>&nbsp;     *    t6:L=BoundMethodHandle$Species_LLLLL.argL3(a0:L);
<i>1009</i>&nbsp;     *    t7:L=BoundMethodHandle$Species_LLLLL.argL4(a0:L);
<b class="nc"><i>1010</i>&nbsp;     *    t8:L=MethodHandle.invokeBasic(t6:L,a1:L,a2:L);</b>
<b class="nc"><i>1011</i>&nbsp;     *    t9:L=MethodHandleImpl.guardWithCatch(t3:L,t4:L,t5:L,t8:L);</b>
<i>1012</i>&nbsp;     *   t10:I=MethodHandle.invokeBasic(t7:L,t9:L);t10:I}
<i>1013</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1014</i>&nbsp;     *
<b class="nc"><i>1015</i>&nbsp;     * argL0 and argL2 are target and catcher method handles. argL1 is exception class.</b>
<b class="nc"><i>1016</i>&nbsp;     * argL3 and argL4 are auxiliary method handles: argL3 boxes arguments and wraps them into Object[]</b>
<i>1017</i>&nbsp;     * (ValueConversions.array()) and argL4 unboxes result if necessary (ValueConversions.unbox()).
<i>1018</i>&nbsp;     *
<b class="nc"><i>1019</i>&nbsp;     * Having t8 and t10 passed outside and not hardcoded into a lambda form allows to share lambda forms</b>
<b class="nc"><i>1020</i>&nbsp;     * among catchException combinators with the same basic type.</b>
<b class="nc"><i>1021</i>&nbsp;     */</b>
<b class="nc"><i>1022</i>&nbsp;    private static LambdaForm makeGuardWithCatchForm(MethodType basicType) {</b>
<i>1023</i>&nbsp;        MethodType lambdaType = basicType.invokerType();
<b class="nc"><i>1024</i>&nbsp;</b>
<b class="nc"><i>1025</i>&nbsp;        LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_GWC);</b>
<b class="nc"><i>1026</i>&nbsp;        if (lform != null) {</b>
<i>1027</i>&nbsp;            return lform;
<b class="nc"><i>1028</i>&nbsp;        }</b>
<i>1029</i>&nbsp;        final int THIS_MH      = 0;  // the BMH_LLLLL
<i>1030</i>&nbsp;        final int ARG_BASE     = 1;  // start of incoming arguments
<b class="nc"><i>1031</i>&nbsp;        final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();</b>
<i>1032</i>&nbsp;
<i>1033</i>&nbsp;        int nameCursor = ARG_LIMIT;
<b class="nc"><i>1034</i>&nbsp;        final int GET_TARGET       = nameCursor++;</b>
<b class="nc"><i>1035</i>&nbsp;        final int GET_CLASS        = nameCursor++;</b>
<i>1036</i>&nbsp;        final int GET_CATCHER      = nameCursor++;
<b class="nc"><i>1037</i>&nbsp;        final int GET_COLLECT_ARGS = nameCursor++;</b>
<b class="nc"><i>1038</i>&nbsp;        final int GET_UNBOX_RESULT = nameCursor++;</b>
<b class="nc"><i>1039</i>&nbsp;        final int BOXED_ARGS       = nameCursor++;</b>
<b class="nc"><i>1040</i>&nbsp;        final int TRY_CATCH        = nameCursor++;</b>
<b class="nc"><i>1041</i>&nbsp;        final int UNBOX_RESULT     = nameCursor++;</b>
<i>1042</i>&nbsp;
<i>1043</i>&nbsp;        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
<i>1044</i>&nbsp;
<i>1045</i>&nbsp;        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();
<i>1046</i>&nbsp;        names[THIS_MH]          = names[THIS_MH].withConstraint(data);
<i>1047</i>&nbsp;        names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
<i>1048</i>&nbsp;        names[GET_CLASS]        = new Name(data.getterFunction(1), names[THIS_MH]);
<i>1049</i>&nbsp;        names[GET_CATCHER]      = new Name(data.getterFunction(2), names[THIS_MH]);
<i>1050</i>&nbsp;        names[GET_COLLECT_ARGS] = new Name(data.getterFunction(3), names[THIS_MH]);
<i>1051</i>&nbsp;        names[GET_UNBOX_RESULT] = new Name(data.getterFunction(4), names[THIS_MH]);
<i>1052</i>&nbsp;
<b class="nc"><i>1053</i>&nbsp;        // FIXME: rework argument boxing/result unboxing logic for LF interpretation</b>
<b class="nc"><i>1054</i>&nbsp;</b>
<b class="nc"><i>1055</i>&nbsp;        // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);</b>
<b class="nc"><i>1056</i>&nbsp;        MethodType collectArgsType = basicType.changeReturnType(Object.class);</b>
<i>1057</i>&nbsp;        MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
<i>1058</i>&nbsp;        Object[] args = new Object[invokeBasic.type().parameterCount()];
<i>1059</i>&nbsp;        args[0] = names[GET_COLLECT_ARGS];
<i>1060</i>&nbsp;        System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
<i>1061</i>&nbsp;        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.GUARD_WITH_CATCH), args);
<i>1062</i>&nbsp;
<b class="nc"><i>1063</i>&nbsp;        // t_{i+1}:L=MethodHandleImpl.guardWithCatch(target:L,exType:L,catcher:L,t_{i}:L);</b>
<b class="nc"><i>1064</i>&nbsp;        Object[] gwcArgs = new Object[] {names[GET_TARGET], names[GET_CLASS], names[GET_CATCHER], names[BOXED_ARGS]};</b>
<b class="nc"><i>1065</i>&nbsp;        names[TRY_CATCH] = new Name(getFunction(NF_guardWithCatch), gwcArgs);</b>
<b class="nc"><i>1066</i>&nbsp;</b>
<i>1067</i>&nbsp;        // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
<i>1068</i>&nbsp;        MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
<i>1069</i>&nbsp;        Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_CATCH]};
<i>1070</i>&nbsp;        names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
<b class="nc"><i>1071</i>&nbsp;</b>
<b class="nc"><i>1072</i>&nbsp;        lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);</b>
<b class="nc"><i>1073</i>&nbsp;</b>
<b class="nc"><i>1074</i>&nbsp;        return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_GWC, lform);</b>
<b class="nc"><i>1075</i>&nbsp;    }</b>
<b class="nc"><i>1076</i>&nbsp;</b>
<i>1077</i>&nbsp;    static
<b class="nc"><i>1078</i>&nbsp;    MethodHandle makeGuardWithCatch(MethodHandle target,</b>
<i>1079</i>&nbsp;                                    Class&lt;? extends Throwable&gt; exType,
<i>1080</i>&nbsp;                                    MethodHandle catcher) {
<b class="nc"><i>1081</i>&nbsp;        MethodType type = target.type();</b>
<i>1082</i>&nbsp;        LambdaForm form = makeGuardWithCatchForm(type.basicType());
<b class="nc"><i>1083</i>&nbsp;</b>
<i>1084</i>&nbsp;        // Prepare auxiliary method handles used during LambdaForm interpretation.
<i>1085</i>&nbsp;        // Box arguments and wrap them into Object[]: ValueConversions.array().
<b class="nc"><i>1086</i>&nbsp;        MethodType varargsType = type.changeReturnType(Object[].class);</b>
<b class="nc"><i>1087</i>&nbsp;        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);</b>
<b class="nc"><i>1088</i>&nbsp;        MethodHandle unboxResult = unboxResultHandle(type.returnType());</b>
<b class="nc"><i>1089</i>&nbsp;</b>
<b class="nc"><i>1090</i>&nbsp;        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLLL();</b>
<i>1091</i>&nbsp;        BoundMethodHandle mh;
<b class="nc"><i>1092</i>&nbsp;        try {</b>
<b class="nc"><i>1093</i>&nbsp;            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) exType,</b>
<b class="nc"><i>1094</i>&nbsp;                    (Object) catcher, (Object) collectArgs, (Object) unboxResult);</b>
<i>1095</i>&nbsp;        } catch (Throwable ex) {
<b class="nc"><i>1096</i>&nbsp;            throw uncaughtException(ex);</b>
<b class="nc"><i>1097</i>&nbsp;        }</b>
<b class="nc"><i>1098</i>&nbsp;        assert(mh.type() == type);</b>
<b class="nc"><i>1099</i>&nbsp;        return mh;</b>
<b class="nc"><i>1100</i>&nbsp;    }</b>
<b class="nc"><i>1101</i>&nbsp;</b>
<b class="nc"><i>1102</i>&nbsp;    /**</b>
<b class="nc"><i>1103</i>&nbsp;     * Intrinsified during LambdaForm compilation</b>
<b class="nc"><i>1104</i>&nbsp;     * (see {@link InvokerBytecodeGenerator#emitGuardWithCatch emitGuardWithCatch}).</b>
<i>1105</i>&nbsp;     */
<i>1106</i>&nbsp;    @LambdaForm.Hidden
<i>1107</i>&nbsp;    static Object guardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher,
<i>1108</i>&nbsp;                                 Object... av) throws Throwable {
<i>1109</i>&nbsp;        // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
<i>1110</i>&nbsp;        try {
<i>1111</i>&nbsp;            return target.asFixedArity().invokeWithArguments(av);
<i>1112</i>&nbsp;        } catch (Throwable t) {
<i>1113</i>&nbsp;            if (!exType.isInstance(t)) throw t;
<i>1114</i>&nbsp;            return catcher.asFixedArity().invokeWithArguments(prepend(av, t));
<i>1115</i>&nbsp;        }
<i>1116</i>&nbsp;    }
<b class="nc"><i>1117</i>&nbsp;</b>
<i>1118</i>&nbsp;    /** Prepend elements to an array. */
<i>1119</i>&nbsp;    @LambdaForm.Hidden
<i>1120</i>&nbsp;    private static Object[] prepend(Object[] array, Object... elems) {
<i>1121</i>&nbsp;        int nArray = array.length;
<b class="nc"><i>1122</i>&nbsp;        int nElems = elems.length;</b>
<i>1123</i>&nbsp;        Object[] newArray = new Object[nArray + nElems];
<i>1124</i>&nbsp;        System.arraycopy(elems, 0, newArray, 0, nElems);
<i>1125</i>&nbsp;        System.arraycopy(array, 0, newArray, nElems, nArray);
<b class="nc"><i>1126</i>&nbsp;        return newArray;</b>
<b class="nc"><i>1127</i>&nbsp;    }</b>
<b class="nc"><i>1128</i>&nbsp;</b>
<b class="nc"><i>1129</i>&nbsp;    static</b>
<b class="nc"><i>1130</i>&nbsp;    MethodHandle throwException(MethodType type) {</b>
<b class="nc"><i>1131</i>&nbsp;        assert(Throwable.class.isAssignableFrom(type.parameterType(0)));</b>
<i>1132</i>&nbsp;        int arity = type.parameterCount();
<i>1133</i>&nbsp;        if (arity &gt; 1) {
<b class="nc"><i>1134</i>&nbsp;            MethodHandle mh = throwException(type.dropParameterTypes(1, arity));</b>
<i>1135</i>&nbsp;            mh = MethodHandles.dropArguments(mh, 1, Arrays.copyOfRange(type.parameterArray(), 1, arity));
<b class="nc"><i>1136</i>&nbsp;            return mh;</b>
<b class="nc"><i>1137</i>&nbsp;        }</b>
<i>1138</i>&nbsp;        return makePairwiseConvert(getFunction(NF_throwException).resolvedHandle(), type, false, true);
<i>1139</i>&nbsp;    }
<i>1140</i>&nbsp;
<b class="nc"><i>1141</i>&nbsp;    static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }</b>
<b class="nc"><i>1142</i>&nbsp;</b>
<b class="nc"><i>1143</i>&nbsp;    static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];</b>
<i>1144</i>&nbsp;    static MethodHandle fakeMethodHandleInvoke(MemberName method) {
<b class="nc"><i>1145</i>&nbsp;        int idx;</b>
<b class="nc"><i>1146</i>&nbsp;        assert(method.isMethodHandleInvoke());</b>
<b class="nc"><i>1147</i>&nbsp;        switch (method.getName()) {</b>
<i>1148</i>&nbsp;        case &quot;invoke&quot;:       idx = 0; break;
<i>1149</i>&nbsp;        case &quot;invokeExact&quot;:  idx = 1; break;
<b class="nc"><i>1150</i>&nbsp;        default:             throw new InternalError(method.getName());</b>
<i>1151</i>&nbsp;        }
<b class="nc"><i>1152</i>&nbsp;        MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];</b>
<b class="nc"><i>1153</i>&nbsp;        if (mh != null)  return mh;</b>
<b class="nc"><i>1154</i>&nbsp;        MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,</b>
<b class="nc"><i>1155</i>&nbsp;                                                MethodHandle.class, Object[].class);</b>
<b class="nc"><i>1156</i>&nbsp;        mh = throwException(type);</b>
<i>1157</i>&nbsp;        mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));
<i>1158</i>&nbsp;        if (!method.getInvocationType().equals(mh.type()))
<b class="nc"><i>1159</i>&nbsp;            throw new InternalError(method.toString());</b>
<b class="nc"><i>1160</i>&nbsp;        mh = mh.withInternalMemberName(method, false);</b>
<b class="nc"><i>1161</i>&nbsp;        mh = mh.withVarargs(true);</b>
<b class="nc"><i>1162</i>&nbsp;        assert(method.isVarargs());</b>
<b class="nc"><i>1163</i>&nbsp;        FAKE_METHOD_HANDLE_INVOKE[idx] = mh;</b>
<i>1164</i>&nbsp;        return mh;
<i>1165</i>&nbsp;    }
<b class="nc"><i>1166</i>&nbsp;    static MethodHandle fakeVarHandleInvoke(MemberName method) {</b>
<b class="nc"><i>1167</i>&nbsp;        // TODO caching, is it necessary?</b>
<b class="nc"><i>1168</i>&nbsp;        MethodType type = MethodType.methodType(method.getReturnType(), UnsupportedOperationException.class,</b>
<b class="nc"><i>1169</i>&nbsp;                                                VarHandle.class, Object[].class);</b>
<b class="nc"><i>1170</i>&nbsp;        MethodHandle mh = throwException(type);</b>
<b class="nc"><i>1171</i>&nbsp;        mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke VarHandle&quot;));</b>
<i>1172</i>&nbsp;        if (!method.getInvocationType().equals(mh.type()))
<b class="nc"><i>1173</i>&nbsp;            throw new InternalError(method.toString());</b>
<i>1174</i>&nbsp;        mh = mh.withInternalMemberName(method, false);
<b class="nc"><i>1175</i>&nbsp;        mh = mh.asVarargsCollector(Object[].class);</b>
<i>1176</i>&nbsp;        assert(method.isVarargs());
<i>1177</i>&nbsp;        return mh;
<i>1178</i>&nbsp;    }
<i>1179</i>&nbsp;
<i>1180</i>&nbsp;    /**
<b class="nc"><i>1181</i>&nbsp;     * Create an alias for the method handle which, when called,</b>
<b class="nc"><i>1182</i>&nbsp;     * appears to be called from the same class loader and protection domain</b>
<b class="nc"><i>1183</i>&nbsp;     * as hostClass.</b>
<b class="nc"><i>1184</i>&nbsp;     * This is an expensive no-op unless the method which is called</b>
<b class="nc"><i>1185</i>&nbsp;     * is sensitive to its caller.  A small number of system methods</b>
<b class="nc"><i>1186</i>&nbsp;     * are in this category, including Class.forName and Method.invoke.</b>
<b class="nc"><i>1187</i>&nbsp;     */</b>
<b class="nc"><i>1188</i>&nbsp;    static</b>
<i>1189</i>&nbsp;    MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
<i>1190</i>&nbsp;        return BindCaller.bindCaller(mh, hostClass);
<i>1191</i>&nbsp;    }
<i>1192</i>&nbsp;
<i>1193</i>&nbsp;    // Put the whole mess into its own nested class.
<i>1194</i>&nbsp;    // That way we can lazily load the code and set up the constants.
<b class="nc"><i>1195</i>&nbsp;    private static class BindCaller {</b>
<b class="nc"><i>1196</i>&nbsp;        private static MethodType INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);</b>
<b class="nc"><i>1197</i>&nbsp;</b>
<b class="nc"><i>1198</i>&nbsp;        static</b>
<b class="nc"><i>1199</i>&nbsp;        MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {</b>
<b class="nc"><i>1200</i>&nbsp;            // Code in the boot layer should now be careful while creating method handles or</b>
<i>1201</i>&nbsp;            // functional interface instances created from method references to @CallerSensitive  methods,
<i>1202</i>&nbsp;            // it needs to be ensured the handles or interface instances are kept safe and are not passed
<i>1203</i>&nbsp;            // from the boot layer to untrusted code.
<i>1204</i>&nbsp;            if (hostClass == null
<b class="nc"><i>1205</i>&nbsp;                ||    (hostClass.isArray() ||</b>
<b class="nc"><i>1206</i>&nbsp;                       hostClass.isPrimitive() ||</b>
<i>1207</i>&nbsp;                       hostClass.getName().startsWith(&quot;java.lang.invoke.&quot;))) {
<b class="nc"><i>1208</i>&nbsp;                throw new InternalError();  // does not happen, and should not anyway</b>
<b class="nc"><i>1209</i>&nbsp;            }</b>
<b class="nc"><i>1210</i>&nbsp;            // For simplicity, convert mh to a varargs-like method.</b>
<b class="nc"><i>1211</i>&nbsp;            MethodHandle vamh = prepareForInvoker(mh);</b>
<b class="nc"><i>1212</i>&nbsp;            // Cache the result of makeInjectedInvoker once per argument class.</b>
<b class="nc"><i>1213</i>&nbsp;            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);</b>
<b class="nc"><i>1214</i>&nbsp;            return restoreToType(bccInvoker.bindTo(vamh), mh, hostClass);</b>
<i>1215</i>&nbsp;        }
<i>1216</i>&nbsp;
<i>1217</i>&nbsp;        private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
<i>1218</i>&nbsp;            try {
<i>1219</i>&nbsp;                Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(hostClass, INJECTED_INVOKER_TEMPLATE, null);
<i>1220</i>&nbsp;                assert checkInjectedInvoker(hostClass, invokerClass);
<b class="nc"><i>1221</i>&nbsp;                return IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);</b>
<b class="nc"><i>1222</i>&nbsp;            } catch (ReflectiveOperationException ex) {</b>
<b class="nc"><i>1223</i>&nbsp;                throw uncaughtException(ex);</b>
<b class="nc"><i>1224</i>&nbsp;            }</b>
<b class="nc"><i>1225</i>&nbsp;        }</b>
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;        private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {
<i>1228</i>&nbsp;            @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
<i>1229</i>&nbsp;                return makeInjectedInvoker(hostClass);
<b class="nc"><i>1230</i>&nbsp;            }</b>
<b class="nc"><i>1231</i>&nbsp;        };</b>
<i>1232</i>&nbsp;
<i>1233</i>&nbsp;        // Adapt mh so that it can be called directly from an injected invoker:
<b class="nc"><i>1234</i>&nbsp;        private static MethodHandle prepareForInvoker(MethodHandle mh) {</b>
<b class="nc"><i>1235</i>&nbsp;            mh = mh.asFixedArity();</b>
<b class="nc"><i>1236</i>&nbsp;            MethodType mt = mh.type();</b>
<b class="nc"><i>1237</i>&nbsp;            int arity = mt.parameterCount();</b>
<b class="nc"><i>1238</i>&nbsp;            MethodHandle vamh = mh.asType(mt.generic());</b>
<b class="nc"><i>1239</i>&nbsp;            vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames</b>
<b class="nc"><i>1240</i>&nbsp;            vamh = vamh.asSpreader(Object[].class, arity);</b>
<b class="nc"><i>1241</i>&nbsp;            vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames</b>
<b class="nc"><i>1242</i>&nbsp;            return vamh;</b>
<b class="nc"><i>1243</i>&nbsp;        }</b>
<b class="nc"><i>1244</i>&nbsp;</b>
<b class="nc"><i>1245</i>&nbsp;        // Undo the adapter effect of prepareForInvoker:</b>
<b class="nc"><i>1246</i>&nbsp;        private static MethodHandle restoreToType(MethodHandle vamh,</b>
<b class="nc"><i>1247</i>&nbsp;                                                  MethodHandle original,</b>
<b class="nc"><i>1248</i>&nbsp;                                                  Class&lt;?&gt; hostClass) {</b>
<i>1249</i>&nbsp;            MethodType type = original.type();
<i>1250</i>&nbsp;            MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());
<b class="nc"><i>1251</i>&nbsp;            MemberName member = original.internalMemberName();</b>
<i>1252</i>&nbsp;            mh = mh.asType(type);
<i>1253</i>&nbsp;            mh = new WrappedMember(mh, type, member, original.isInvokeSpecial(), hostClass);
<i>1254</i>&nbsp;            return mh;
<b class="nc"><i>1255</i>&nbsp;        }</b>
<i>1256</i>&nbsp;
<i>1257</i>&nbsp;        private static boolean checkInjectedInvoker(Class&lt;?&gt; hostClass, Class&lt;?&gt; invokerClass) {
<b class="nc"><i>1258</i>&nbsp;            assert (hostClass.getClassLoader() == invokerClass.getClassLoader()) : hostClass.getName()+&quot; (CL)&quot;;</b>
<i>1259</i>&nbsp;            try {
<i>1260</i>&nbsp;                assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+&quot; (PD)&quot;;
<i>1261</i>&nbsp;            } catch (SecurityException ex) {
<i>1262</i>&nbsp;                // Self-check was blocked by security manager. This is OK.
<i>1263</i>&nbsp;            }
<i>1264</i>&nbsp;            try {
<b class="nc"><i>1265</i>&nbsp;                // Test the invoker to ensure that it really injects into the right place.</b>
<i>1266</i>&nbsp;                MethodHandle invoker = IMPL_LOOKUP.findStatic(invokerClass, &quot;invoke_V&quot;, INVOKER_MT);
<i>1267</i>&nbsp;                MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
<i>1268</i>&nbsp;                return (boolean)invoker.invoke(vamh, new Object[]{ invokerClass });
<i>1269</i>&nbsp;            } catch (Throwable ex) {
<i>1270</i>&nbsp;                throw new InternalError(ex);
<i>1271</i>&nbsp;            }
<i>1272</i>&nbsp;        }
<i>1273</i>&nbsp;
<b class="nc"><i>1274</i>&nbsp;        private static final MethodHandle MH_checkCallerClass;</b>
<b class="nc"><i>1275</i>&nbsp;        static {</b>
<b class="nc"><i>1276</i>&nbsp;            final Class&lt;?&gt; THIS_CLASS = BindCaller.class;</b>
<b class="nc"><i>1277</i>&nbsp;            assert(checkCallerClass(THIS_CLASS));</b>
<b class="nc"><i>1278</i>&nbsp;            try {</b>
<i>1279</i>&nbsp;                MH_checkCallerClass = IMPL_LOOKUP
<i>1280</i>&nbsp;                    .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,
<i>1281</i>&nbsp;                                MethodType.methodType(boolean.class, Class.class));
<i>1282</i>&nbsp;                assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS));
<b class="nc"><i>1283</i>&nbsp;            } catch (Throwable ex) {</b>
<i>1284</i>&nbsp;                throw new InternalError(ex);
<i>1285</i>&nbsp;            }
<i>1286</i>&nbsp;        }
<b class="nc"><i>1287</i>&nbsp;</b>
<i>1288</i>&nbsp;        @CallerSensitive
<i>1289</i>&nbsp;        @ForceInline // to ensure Reflection.getCallerClass optimization
<i>1290</i>&nbsp;        private static boolean checkCallerClass(Class&lt;?&gt; expected) {
<b class="nc"><i>1291</i>&nbsp;            // This method is called via MH_checkCallerClass and so it&#39;s correct to ask for the immediate caller here.</b>
<i>1292</i>&nbsp;            Class&lt;?&gt; actual = Reflection.getCallerClass();
<i>1293</i>&nbsp;            if (actual != expected)
<i>1294</i>&nbsp;                throw new InternalError(&quot;found &quot; + actual.getName() + &quot;, expected &quot; + expected.getName());
<b class="nc"><i>1295</i>&nbsp;            return true;</b>
<i>1296</i>&nbsp;        }
<i>1297</i>&nbsp;
<i>1298</i>&nbsp;        private static final byte[] INJECTED_INVOKER_TEMPLATE = generateInvokerTemplate();
<i>1299</i>&nbsp;
<i>1300</i>&nbsp;        /** Produces byte code for a class that is used as an injected invoker. */
<b class="nc"><i>1301</i>&nbsp;        private static byte[] generateInvokerTemplate() {</b>
<i>1302</i>&nbsp;            ClassWriter cw = new ClassWriter(0);
<i>1303</i>&nbsp;
<i>1304</i>&nbsp;            // private static class InjectedInvoker {
<i>1305</i>&nbsp;            //     @Hidden
<b class="nc"><i>1306</i>&nbsp;            //     static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {</b>
<b class="nc"><i>1307</i>&nbsp;            //        return vamh.invokeExact(args);</b>
<b class="nc"><i>1308</i>&nbsp;            //     }</b>
<i>1309</i>&nbsp;            // }
<i>1310</i>&nbsp;            cw.visit(52, ACC_PRIVATE | ACC_SUPER, &quot;InjectedInvoker&quot;, null, &quot;java/lang/Object&quot;, null);
<i>1311</i>&nbsp;
<i>1312</i>&nbsp;            MethodVisitor mv = cw.visitMethod(ACC_STATIC, &quot;invoke_V&quot;,
<b class="nc"><i>1313</i>&nbsp;                          &quot;(Ljava/lang/invoke/MethodHandle;[Ljava/lang/Object;)Ljava/lang/Object;&quot;,</b>
<b class="nc"><i>1314</i>&nbsp;                          null, null);</b>
<b class="nc"><i>1315</i>&nbsp;</b>
<b class="nc"><i>1316</i>&nbsp;            // Suppress invoker method in stack traces.</b>
<b class="nc"><i>1317</i>&nbsp;            AnnotationVisitor av0 = mv.visitAnnotation(&quot;Ljava/lang/invoke/LambdaForm$Hidden;&quot;, true);</b>
<b class="nc"><i>1318</i>&nbsp;            av0.visitEnd();</b>
<b class="nc"><i>1319</i>&nbsp;</b>
<b class="nc"><i>1320</i>&nbsp;            mv.visitCode();</b>
<b class="nc"><i>1321</i>&nbsp;            mv.visitVarInsn(ALOAD, 0);</b>
<i>1322</i>&nbsp;            mv.visitVarInsn(ALOAD, 1);
<i>1323</i>&nbsp;            mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;, &quot;invokeExact&quot;,
<i>1324</i>&nbsp;                               &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
<i>1325</i>&nbsp;            mv.visitInsn(ARETURN);
<i>1326</i>&nbsp;            mv.visitMaxs(2, 2);
<i>1327</i>&nbsp;            mv.visitEnd();
<i>1328</i>&nbsp;
<i>1329</i>&nbsp;            cw.visitEnd();
<i>1330</i>&nbsp;            return cw.toByteArray();
<b class="nc"><i>1331</i>&nbsp;        }</b>
<b class="nc"><i>1332</i>&nbsp;    }</b>
<b class="nc"><i>1333</i>&nbsp;</b>
<i>1334</i>&nbsp;    /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
<i>1335</i>&nbsp;    private static final class WrappedMember extends DelegatingMethodHandle {
<i>1336</i>&nbsp;        private final MethodHandle target;
<i>1337</i>&nbsp;        private final MemberName member;
<b class="nc"><i>1338</i>&nbsp;        private final Class&lt;?&gt; callerClass;</b>
<i>1339</i>&nbsp;        private final boolean isInvokeSpecial;
<i>1340</i>&nbsp;
<i>1341</i>&nbsp;        private WrappedMember(MethodHandle target, MethodType type,
<i>1342</i>&nbsp;                              MemberName member, boolean isInvokeSpecial,
<b class="nc"><i>1343</i>&nbsp;                              Class&lt;?&gt; callerClass) {</b>
<i>1344</i>&nbsp;            super(type, target);
<i>1345</i>&nbsp;            this.target = target;
<i>1346</i>&nbsp;            this.member = member;
<i>1347</i>&nbsp;            this.callerClass = callerClass;
<i>1348</i>&nbsp;            this.isInvokeSpecial = isInvokeSpecial;
<i>1349</i>&nbsp;        }
<b class="nc"><i>1350</i>&nbsp;</b>
<i>1351</i>&nbsp;        @Override
<i>1352</i>&nbsp;        MemberName internalMemberName() {
<i>1353</i>&nbsp;            return member;
<i>1354</i>&nbsp;        }
<b class="nc"><i>1355</i>&nbsp;        @Override</b>
<i>1356</i>&nbsp;        Class&lt;?&gt; internalCallerClass() {
<i>1357</i>&nbsp;            return callerClass;
<i>1358</i>&nbsp;        }
<i>1359</i>&nbsp;        @Override
<i>1360</i>&nbsp;        boolean isInvokeSpecial() {
<b class="nc"><i>1361</i>&nbsp;            return isInvokeSpecial;</b>
<b class="nc"><i>1362</i>&nbsp;        }</b>
<b class="nc"><i>1363</i>&nbsp;        @Override</b>
<b class="nc"><i>1364</i>&nbsp;        protected MethodHandle getTarget() {</b>
<i>1365</i>&nbsp;            return target;
<b class="nc"><i>1366</i>&nbsp;        }</b>
<i>1367</i>&nbsp;        @Override
<i>1368</i>&nbsp;        public MethodHandle asTypeUncached(MethodType newType) {
<i>1369</i>&nbsp;            // This MH is an alias for target, except for the MemberName
<i>1370</i>&nbsp;            // Drop the MemberName if there is any conversion.
<b class="nc"><i>1371</i>&nbsp;            return asTypeCache = target.asType(newType);</b>
<b class="nc"><i>1372</i>&nbsp;        }</b>
<b class="nc"><i>1373</i>&nbsp;    }</b>
<i>1374</i>&nbsp;
<i>1375</i>&nbsp;    static MethodHandle makeWrappedMember(MethodHandle target, MemberName member, boolean isInvokeSpecial) {
<i>1376</i>&nbsp;        if (member.equals(target.internalMemberName()) &amp;&amp; isInvokeSpecial == target.isInvokeSpecial())
<b class="nc"><i>1377</i>&nbsp;            return target;</b>
<i>1378</i>&nbsp;        return new WrappedMember(target, target.type(), member, isInvokeSpecial, null);
<i>1379</i>&nbsp;    }
<i>1380</i>&nbsp;
<i>1381</i>&nbsp;    /** Intrinsic IDs */
<i>1382</i>&nbsp;    /*non-public*/
<b class="nc"><i>1383</i>&nbsp;    enum Intrinsic {</b>
<b class="nc"><i>1384</i>&nbsp;        SELECT_ALTERNATIVE,</b>
<b class="nc"><i>1385</i>&nbsp;        GUARD_WITH_CATCH,</b>
<i>1386</i>&nbsp;        TRY_FINALLY,
<b class="nc"><i>1387</i>&nbsp;        LOOP,</b>
<b class="nc"><i>1388</i>&nbsp;        NEW_ARRAY,</b>
<b class="nc"><i>1389</i>&nbsp;        ARRAY_LOAD,</b>
<i>1390</i>&nbsp;        ARRAY_STORE,
<i>1391</i>&nbsp;        ARRAY_LENGTH,
<i>1392</i>&nbsp;        IDENTITY,
<b class="nc"><i>1393</i>&nbsp;        ZERO,</b>
<b class="nc"><i>1394</i>&nbsp;        NONE // no intrinsic associated</b>
<b class="nc"><i>1395</i>&nbsp;    }</b>
<i>1396</i>&nbsp;
<b class="nc"><i>1397</i>&nbsp;    /** Mark arbitrary method handle as intrinsic.</b>
<i>1398</i>&nbsp;     * InvokerBytecodeGenerator uses this info to produce more efficient bytecode shape. */
<b class="nc"><i>1399</i>&nbsp;    static final class IntrinsicMethodHandle extends DelegatingMethodHandle {</b>
<i>1400</i>&nbsp;        private final MethodHandle target;
<b class="nc"><i>1401</i>&nbsp;        private final Intrinsic intrinsicName;</b>
<i>1402</i>&nbsp;
<b class="nc"><i>1403</i>&nbsp;        IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName) {</b>
<i>1404</i>&nbsp;            super(target.type(), target);
<i>1405</i>&nbsp;            this.target = target;
<b class="nc"><i>1406</i>&nbsp;            this.intrinsicName = intrinsicName;</b>
<i>1407</i>&nbsp;        }
<i>1408</i>&nbsp;
<b class="nc"><i>1409</i>&nbsp;        @Override</b>
<i>1410</i>&nbsp;        protected MethodHandle getTarget() {
<i>1411</i>&nbsp;            return target;
<b class="nc"><i>1412</i>&nbsp;        }</b>
<i>1413</i>&nbsp;
<i>1414</i>&nbsp;        @Override
<b class="nc"><i>1415</i>&nbsp;        Intrinsic intrinsicName() {</b>
<i>1416</i>&nbsp;            return intrinsicName;
<i>1417</i>&nbsp;        }
<i>1418</i>&nbsp;
<b class="nc"><i>1419</i>&nbsp;        @Override</b>
<i>1420</i>&nbsp;        public MethodHandle asTypeUncached(MethodType newType) {
<i>1421</i>&nbsp;            // This MH is an alias for target, except for the intrinsic name
<i>1422</i>&nbsp;            // Drop the name if there is any conversion.
<b class="nc"><i>1423</i>&nbsp;            return asTypeCache = target.asType(newType);</b>
<i>1424</i>&nbsp;        }
<b class="nc"><i>1425</i>&nbsp;</b>
<i>1426</i>&nbsp;        @Override
<b class="nc"><i>1427</i>&nbsp;        String internalProperties() {</b>
<b class="nc"><i>1428</i>&nbsp;            return super.internalProperties() +</b>
<b class="nc"><i>1429</i>&nbsp;                    &quot;\n&amp; Intrinsic=&quot;+intrinsicName;</b>
<b class="nc"><i>1430</i>&nbsp;        }</b>
<b class="nc"><i>1431</i>&nbsp;</b>
<b class="nc"><i>1432</i>&nbsp;        @Override</b>
<b class="nc"><i>1433</i>&nbsp;        public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {</b>
<i>1434</i>&nbsp;            if (intrinsicName == Intrinsic.IDENTITY) {
<i>1435</i>&nbsp;                MethodType resultType = type().asCollectorType(arrayType, type().parameterCount() - 1, arrayLength);
<i>1436</i>&nbsp;                MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
<i>1437</i>&nbsp;                return newArray.asType(resultType);
<i>1438</i>&nbsp;            }
<b class="nc"><i>1439</i>&nbsp;            return super.asCollector(arrayType, arrayLength);</b>
<b class="nc"><i>1440</i>&nbsp;        }</b>
<b class="nc"><i>1441</i>&nbsp;    }</b>
<i>1442</i>&nbsp;
<i>1443</i>&nbsp;    static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName) {
<b class="nc"><i>1444</i>&nbsp;        if (intrinsicName == target.intrinsicName())</b>
<b class="nc"><i>1445</i>&nbsp;            return target;</b>
<b class="nc"><i>1446</i>&nbsp;        return new IntrinsicMethodHandle(target, intrinsicName);</b>
<b class="nc"><i>1447</i>&nbsp;    }</b>
<i>1448</i>&nbsp;
<i>1449</i>&nbsp;    static MethodHandle makeIntrinsic(MethodType type, LambdaForm form, Intrinsic intrinsicName) {
<b class="nc"><i>1450</i>&nbsp;        return new IntrinsicMethodHandle(SimpleMethodHandle.make(type, form), intrinsicName);</b>
<i>1451</i>&nbsp;    }
<i>1452</i>&nbsp;
<i>1453</i>&nbsp;    /// Collection of multiple arguments.
<b class="nc"><i>1454</i>&nbsp;</b>
<i>1455</i>&nbsp;    private static MethodHandle findCollector(String name, int nargs, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
<b class="nc"><i>1456</i>&nbsp;        MethodType type = MethodType.genericMethodType(nargs)</b>
<i>1457</i>&nbsp;                .changeReturnType(rtype)
<b class="nc"><i>1458</i>&nbsp;                .insertParameterTypes(0, ptypes);</b>
<i>1459</i>&nbsp;        try {
<b class="nc"><i>1460</i>&nbsp;            return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);</b>
<i>1461</i>&nbsp;        } catch (ReflectiveOperationException ex) {
<i>1462</i>&nbsp;            return null;
<b class="nc"><i>1463</i>&nbsp;        }</b>
<i>1464</i>&nbsp;    }
<i>1465</i>&nbsp;
<b class="nc"><i>1466</i>&nbsp;    private static final Object[] NO_ARGS_ARRAY = {};</b>
<i>1467</i>&nbsp;    private static Object[] makeArray(Object... args) { return args; }
<i>1468</i>&nbsp;    private static Object[] array() { return NO_ARGS_ARRAY; }
<b class="nc"><i>1469</i>&nbsp;    private static Object[] array(Object a0)</b>
<i>1470</i>&nbsp;                { return makeArray(a0); }
<i>1471</i>&nbsp;    private static Object[] array(Object a0, Object a1)
<b class="nc"><i>1472</i>&nbsp;                { return makeArray(a0, a1); }</b>
<i>1473</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2)
<i>1474</i>&nbsp;                { return makeArray(a0, a1, a2); }
<i>1475</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3)
<b class="nc"><i>1476</i>&nbsp;                { return makeArray(a0, a1, a2, a3); }</b>
<i>1477</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
<i>1478</i>&nbsp;                                  Object a4)
<i>1479</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4); }
<b class="nc"><i>1480</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,</b>
<i>1481</i>&nbsp;                                  Object a4, Object a5)
<i>1482</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4, a5); }
<i>1483</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,
<i>1484</i>&nbsp;                                  Object a4, Object a5, Object a6)
<b class="nc"><i>1485</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4, a5, a6); }</b>
<b class="nc"><i>1486</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,</b>
<i>1487</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7)
<b class="nc"><i>1488</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }</b>
<b class="nc"><i>1489</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,</b>
<b class="nc"><i>1490</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7,</b>
<b class="nc"><i>1491</i>&nbsp;                                  Object a8)</b>
<b class="nc"><i>1492</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }</b>
<b class="nc"><i>1493</i>&nbsp;    private static Object[] array(Object a0, Object a1, Object a2, Object a3,</b>
<i>1494</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7,
<i>1495</i>&nbsp;                                  Object a8, Object a9)
<i>1496</i>&nbsp;                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
<b class="nc"><i>1497</i>&nbsp;</b>
<b class="nc"><i>1498</i>&nbsp;    private static final int ARRAYS_COUNT = 11;</b>
<b class="nc"><i>1499</i>&nbsp;    private static final @Stable MethodHandle[] ARRAYS = new MethodHandle[MAX_ARITY + 1];</b>
<i>1500</i>&nbsp;
<i>1501</i>&nbsp;    // filling versions of the above:
<i>1502</i>&nbsp;    // using Integer len instead of int len and no varargs to avoid bootstrapping problems
<i>1503</i>&nbsp;    private static Object[] fillNewArray(Integer len, Object[] /*not ...*/ args) {
<i>1504</i>&nbsp;        Object[] a = new Object[len];
<i>1505</i>&nbsp;        fillWithArguments(a, 0, args);
<b class="nc"><i>1506</i>&nbsp;        return a;</b>
<b class="nc"><i>1507</i>&nbsp;    }</b>
<b class="nc"><i>1508</i>&nbsp;    private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] /*not ...*/ args) {</b>
<b class="nc"><i>1509</i>&nbsp;        Object[] a = Arrays.copyOf(example, len);</b>
<b class="nc"><i>1510</i>&nbsp;        assert(a.getClass() != Object[].class);</b>
<b class="nc"><i>1511</i>&nbsp;        fillWithArguments(a, 0, args);</b>
<b class="nc"><i>1512</i>&nbsp;        return a;</b>
<b class="nc"><i>1513</i>&nbsp;    }</b>
<b class="nc"><i>1514</i>&nbsp;    private static void fillWithArguments(Object[] a, int pos, Object... args) {</b>
<i>1515</i>&nbsp;        System.arraycopy(args, 0, a, pos, args.length);
<i>1516</i>&nbsp;    }
<i>1517</i>&nbsp;    // using Integer pos instead of int pos to avoid bootstrapping problems
<b class="nc"><i>1518</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0)</b>
<b class="nc"><i>1519</i>&nbsp;                { fillWithArguments(a, pos, a0); return a; }</b>
<i>1520</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)
<i>1521</i>&nbsp;                { fillWithArguments(a, pos, a0, a1); return a; }
<i>1522</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)
<i>1523</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2); return a; }
<b class="nc"><i>1524</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)</b>
<i>1525</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }
<i>1526</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
<i>1527</i>&nbsp;                                  Object a4)
<i>1528</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }
<i>1529</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
<i>1530</i>&nbsp;                                  Object a4, Object a5)
<b class="nc"><i>1531</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }</b>
<b class="nc"><i>1532</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,</b>
<b class="nc"><i>1533</i>&nbsp;                                  Object a4, Object a5, Object a6)</b>
<b class="nc"><i>1534</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }</b>
<b class="nc"><i>1535</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,</b>
<b class="nc"><i>1536</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7)</b>
<b class="nc"><i>1537</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }</b>
<b class="nc"><i>1538</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,</b>
<b class="nc"><i>1539</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7,</b>
<i>1540</i>&nbsp;                                  Object a8)
<b class="nc"><i>1541</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }</b>
<i>1542</i>&nbsp;    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,
<b class="nc"><i>1543</i>&nbsp;                                  Object a4, Object a5, Object a6, Object a7,</b>
<b class="nc"><i>1544</i>&nbsp;                                  Object a8, Object a9)</b>
<i>1545</i>&nbsp;                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }
<b class="nc"><i>1546</i>&nbsp;</b>
<b class="nc"><i>1547</i>&nbsp;    private static final int FILL_ARRAYS_COUNT = 11; // current number of fillArray methods</b>
<i>1548</i>&nbsp;    private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];
<i>1549</i>&nbsp;
<i>1550</i>&nbsp;    private static MethodHandle getFillArray(int count) {
<b class="nc"><i>1551</i>&nbsp;        assert (count &gt; 0 &amp;&amp; count &lt; FILL_ARRAYS_COUNT);</b>
<i>1552</i>&nbsp;        MethodHandle mh = FILL_ARRAYS[count];
<i>1553</i>&nbsp;        if (mh != null) {
<i>1554</i>&nbsp;            return mh;
<i>1555</i>&nbsp;        }
<i>1556</i>&nbsp;        mh = findCollector(&quot;fillArray&quot;, count, Object[].class, Integer.class, Object[].class);
<b class="nc"><i>1557</i>&nbsp;        FILL_ARRAYS[count] = mh;</b>
<b class="nc"><i>1558</i>&nbsp;        return mh;</b>
<b class="nc"><i>1559</i>&nbsp;    }</b>
<b class="nc"><i>1560</i>&nbsp;</b>
<b class="nc"><i>1561</i>&nbsp;    private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {</b>
<i>1562</i>&nbsp;        Object a = w.makeArray(boxes.length);
<i>1563</i>&nbsp;        w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);
<b class="nc"><i>1564</i>&nbsp;        return a;</b>
<b class="nc"><i>1565</i>&nbsp;    }</b>
<i>1566</i>&nbsp;
<i>1567</i>&nbsp;    /** Return a method handle that takes the indicated number of Object
<b class="nc"><i>1568</i>&nbsp;     *  arguments and returns an Object array of them, as if for varargs.</b>
<b class="nc"><i>1569</i>&nbsp;     */</b>
<b class="nc"><i>1570</i>&nbsp;    static MethodHandle varargsArray(int nargs) {</b>
<b class="nc"><i>1571</i>&nbsp;        MethodHandle mh = ARRAYS[nargs];</b>
<b class="nc"><i>1572</i>&nbsp;        if (mh != null) {</b>
<i>1573</i>&nbsp;            return mh;
<b class="nc"><i>1574</i>&nbsp;        }</b>
<b class="nc"><i>1575</i>&nbsp;        if (nargs &lt; ARRAYS_COUNT) {</b>
<i>1576</i>&nbsp;            mh = findCollector(&quot;array&quot;, nargs, Object[].class);
<i>1577</i>&nbsp;        } else {
<b class="nc"><i>1578</i>&nbsp;            mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),</b>
<b class="nc"><i>1579</i>&nbsp;                    getConstantHandle(MH_arrayIdentity), nargs);</b>
<b class="nc"><i>1580</i>&nbsp;        }</b>
<b class="nc"><i>1581</i>&nbsp;        assert(assertCorrectArity(mh, nargs));</b>
<b class="nc"><i>1582</i>&nbsp;        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);</b>
<b class="nc"><i>1583</i>&nbsp;        return ARRAYS[nargs] = mh;</b>
<i>1584</i>&nbsp;    }
<i>1585</i>&nbsp;
<i>1586</i>&nbsp;    private static boolean assertCorrectArity(MethodHandle mh, int arity) {
<i>1587</i>&nbsp;        assert(mh.type().parameterCount() == arity) : &quot;arity != &quot;+arity+&quot;: &quot;+mh;
<i>1588</i>&nbsp;        return true;
<b class="nc"><i>1589</i>&nbsp;    }</b>
<b class="nc"><i>1590</i>&nbsp;</b>
<i>1591</i>&nbsp;    // Array identity function (used as getConstantHandle(MH_arrayIdentity)).
<b class="nc"><i>1592</i>&nbsp;    static &lt;T&gt; T[] identity(T[] x) {</b>
<i>1593</i>&nbsp;        return x;
<i>1594</i>&nbsp;    }
<i>1595</i>&nbsp;
<b class="nc"><i>1596</i>&nbsp;    private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {</b>
<b class="nc"><i>1597</i>&nbsp;        // Build up the result mh as a sequence of fills like this:</b>
<i>1598</i>&nbsp;        //   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))
<i>1599</i>&nbsp;        // The various fill(_,10*I,___*[J]) are reusable.
<b class="nc"><i>1600</i>&nbsp;        int leftLen = Math.min(nargs, LEFT_ARGS);  // absorb some arguments immediately</b>
<i>1601</i>&nbsp;        int rightLen = nargs - leftLen;
<i>1602</i>&nbsp;        MethodHandle leftCollector = newArray.bindTo(nargs);
<i>1603</i>&nbsp;        leftCollector = leftCollector.asCollector(Object[].class, leftLen);
<i>1604</i>&nbsp;        MethodHandle mh = finisher;
<i>1605</i>&nbsp;        if (rightLen &gt; 0) {
<i>1606</i>&nbsp;            MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);
<i>1607</i>&nbsp;            if (mh.equals(getConstantHandle(MH_arrayIdentity)))
<i>1608</i>&nbsp;                mh = rightFiller;
<i>1609</i>&nbsp;            else
<i>1610</i>&nbsp;                mh = MethodHandles.collectArguments(mh, 0, rightFiller);
<b class="nc"><i>1611</i>&nbsp;        }</b>
<b class="nc"><i>1612</i>&nbsp;        if (mh.equals(getConstantHandle(MH_arrayIdentity)))</b>
<i>1613</i>&nbsp;            mh = leftCollector;
<b class="nc"><i>1614</i>&nbsp;        else</b>
<b class="nc"><i>1615</i>&nbsp;            mh = MethodHandles.collectArguments(mh, 0, leftCollector);</b>
<i>1616</i>&nbsp;        return mh;
<b class="nc"><i>1617</i>&nbsp;    }</b>
<b class="nc"><i>1618</i>&nbsp;</b>
<b class="nc"><i>1619</i>&nbsp;    private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;</b>
<b class="nc"><i>1620</i>&nbsp;    private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];</b>
<i>1621</i>&nbsp;    /** fill_array_to_right(N).invoke(a, argL..arg[N-1])
<b class="nc"><i>1622</i>&nbsp;     *  fills a[L]..a[N-1] with corresponding arguments,</b>
<b class="nc"><i>1623</i>&nbsp;     *  and then returns a.  The value L is a global constant (LEFT_ARGS).</b>
<i>1624</i>&nbsp;     */
<b class="nc"><i>1625</i>&nbsp;    private static MethodHandle fillToRight(int nargs) {</b>
<b class="nc"><i>1626</i>&nbsp;        MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];</b>
<b class="nc"><i>1627</i>&nbsp;        if (filler != null)  return filler;</b>
<b class="nc"><i>1628</i>&nbsp;        filler = buildFiller(nargs);</b>
<b class="nc"><i>1629</i>&nbsp;        assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));</b>
<b class="nc"><i>1630</i>&nbsp;        return FILL_ARRAY_TO_RIGHT[nargs] = filler;</b>
<b class="nc"><i>1631</i>&nbsp;    }</b>
<b class="nc"><i>1632</i>&nbsp;    private static MethodHandle buildFiller(int nargs) {</b>
<b class="nc"><i>1633</i>&nbsp;        if (nargs &lt;= LEFT_ARGS)</b>
<b class="nc"><i>1634</i>&nbsp;            return getConstantHandle(MH_arrayIdentity);  // no args to fill; return the array unchanged</b>
<b class="nc"><i>1635</i>&nbsp;        // we need room for both mh and a in mh.invoke(a, arg*[nargs])</b>
<b class="nc"><i>1636</i>&nbsp;        final int CHUNK = LEFT_ARGS;</b>
<b class="nc"><i>1637</i>&nbsp;        int rightLen = nargs % CHUNK;</b>
<b class="nc"><i>1638</i>&nbsp;        int midLen = nargs - rightLen;</b>
<b class="nc"><i>1639</i>&nbsp;        if (rightLen == 0) {</b>
<b class="nc"><i>1640</i>&nbsp;            midLen = nargs - (rightLen = CHUNK);</b>
<i>1641</i>&nbsp;            if (FILL_ARRAY_TO_RIGHT[midLen] == null) {
<b class="nc"><i>1642</i>&nbsp;                // build some precursors from left to right</b>
<b class="nc"><i>1643</i>&nbsp;                for (int j = LEFT_ARGS % CHUNK; j &lt; midLen; j += CHUNK)</b>
<b class="nc"><i>1644</i>&nbsp;                    if (j &gt; LEFT_ARGS)  fillToRight(j);</b>
<b class="nc"><i>1645</i>&nbsp;            }</b>
<b class="nc"><i>1646</i>&nbsp;        }</b>
<b class="nc"><i>1647</i>&nbsp;        if (midLen &lt; LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);</b>
<i>1648</i>&nbsp;        assert(rightLen &gt; 0);
<i>1649</i>&nbsp;        MethodHandle midFill = fillToRight(midLen);  // recursive fill
<i>1650</i>&nbsp;        MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  // [midLen..nargs-1]
<b class="nc"><i>1651</i>&nbsp;        assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);</b>
<b class="nc"><i>1652</i>&nbsp;        assert(rightFill.type().parameterCount() == 1 + rightLen);</b>
<b class="nc"><i>1653</i>&nbsp;</b>
<i>1654</i>&nbsp;        // Combine the two fills:
<i>1655</i>&nbsp;        //   right(mid(a, x10..x19), x20..x23)
<i>1656</i>&nbsp;        // The final product will look like this:
<b class="nc"><i>1657</i>&nbsp;        //   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)</b>
<b class="nc"><i>1658</i>&nbsp;        if (midLen == LEFT_ARGS)</b>
<i>1659</i>&nbsp;            return rightFill;
<i>1660</i>&nbsp;        else
<b class="nc"><i>1661</i>&nbsp;            return MethodHandles.collectArguments(rightFill, 0, midFill);</b>
<i>1662</i>&nbsp;    }
<i>1663</i>&nbsp;
<i>1664</i>&nbsp;    static final int MAX_JVM_ARITY = 255;  // limit imposed by the JVM
<i>1665</i>&nbsp;
<i>1666</i>&nbsp;    /** Return a method handle that takes the indicated number of
<i>1667</i>&nbsp;     *  typed arguments and returns an array of them.
<i>1668</i>&nbsp;     *  The type argument is the array type.
<i>1669</i>&nbsp;     */
<i>1670</i>&nbsp;    static MethodHandle varargsArray(Class&lt;?&gt; arrayType, int nargs) {
<i>1671</i>&nbsp;        Class&lt;?&gt; elemType = arrayType.getComponentType();
<i>1672</i>&nbsp;        if (elemType == null)  throw new IllegalArgumentException(&quot;not an array: &quot;+arrayType);
<i>1673</i>&nbsp;        // FIXME: Need more special casing and caching here.
<i>1674</i>&nbsp;        if (nargs &gt;= MAX_JVM_ARITY/2 - 1) {
<i>1675</i>&nbsp;            int slots = nargs;
<i>1676</i>&nbsp;            final int MAX_ARRAY_SLOTS = MAX_JVM_ARITY - 1;  // 1 for receiver MH
<i>1677</i>&nbsp;            if (slots &lt;= MAX_ARRAY_SLOTS &amp;&amp; elemType.isPrimitive())
<i>1678</i>&nbsp;                slots *= Wrapper.forPrimitiveType(elemType).stackSlots();
<i>1679</i>&nbsp;            if (slots &gt; MAX_ARRAY_SLOTS)
<i>1680</i>&nbsp;                throw new IllegalArgumentException(&quot;too many arguments: &quot;+arrayType.getSimpleName()+&quot;, length &quot;+nargs);
<i>1681</i>&nbsp;        }
<i>1682</i>&nbsp;        if (elemType == Object.class)
<i>1683</i>&nbsp;            return varargsArray(nargs);
<i>1684</i>&nbsp;        // other cases:  primitive arrays, subtypes of Object[]
<i>1685</i>&nbsp;        MethodHandle cache[] = Makers.TYPED_COLLECTORS.get(elemType);
<i>1686</i>&nbsp;        MethodHandle mh = nargs &lt; cache.length ? cache[nargs] : null;
<i>1687</i>&nbsp;        if (mh != null)  return mh;
<i>1688</i>&nbsp;        if (nargs == 0) {
<i>1689</i>&nbsp;            Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);
<i>1690</i>&nbsp;            mh = MethodHandles.constant(arrayType, example);
<i>1691</i>&nbsp;        } else if (elemType.isPrimitive()) {
<i>1692</i>&nbsp;            MethodHandle builder = getConstantHandle(MH_fillNewArray);
<i>1693</i>&nbsp;            MethodHandle producer = buildArrayProducer(arrayType);
<i>1694</i>&nbsp;            mh = buildVarargsArray(builder, producer, nargs);
<i>1695</i>&nbsp;        } else {
<i>1696</i>&nbsp;            Class&lt;? extends Object[]&gt; objArrayType = arrayType.asSubclass(Object[].class);
<i>1697</i>&nbsp;            Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);
<i>1698</i>&nbsp;            MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);
<i>1699</i>&nbsp;            MethodHandle producer = getConstantHandle(MH_arrayIdentity); // must be weakly typed
<i>1700</i>&nbsp;            mh = buildVarargsArray(builder, producer, nargs);
<i>1701</i>&nbsp;        }
<i>1702</i>&nbsp;        mh = mh.asType(MethodType.methodType(arrayType, Collections.&lt;Class&lt;?&gt;&gt;nCopies(nargs, elemType)));
<i>1703</i>&nbsp;        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);
<i>1704</i>&nbsp;        assert(assertCorrectArity(mh, nargs));
<i>1705</i>&nbsp;        if (nargs &lt; cache.length)
<i>1706</i>&nbsp;            cache[nargs] = mh;
<i>1707</i>&nbsp;        return mh;
<i>1708</i>&nbsp;    }
<i>1709</i>&nbsp;
<i>1710</i>&nbsp;    private static MethodHandle buildArrayProducer(Class&lt;?&gt; arrayType) {
<i>1711</i>&nbsp;        Class&lt;?&gt; elemType = arrayType.getComponentType();
<i>1712</i>&nbsp;        assert(elemType.isPrimitive());
<i>1713</i>&nbsp;        return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));
<i>1714</i>&nbsp;    }
<i>1715</i>&nbsp;
<i>1716</i>&nbsp;    /*non-public*/ static void assertSame(Object mh1, Object mh2) {
<i>1717</i>&nbsp;        if (mh1 != mh2) {
<i>1718</i>&nbsp;            String msg = String.format(&quot;mh1 != mh2: mh1 = %s (form: %s); mh2 = %s (form: %s)&quot;,
<i>1719</i>&nbsp;                    mh1, ((MethodHandle)mh1).form,
<i>1720</i>&nbsp;                    mh2, ((MethodHandle)mh2).form);
<i>1721</i>&nbsp;            throw newInternalError(msg);
<i>1722</i>&nbsp;        }
<i>1723</i>&nbsp;    }
<i>1724</i>&nbsp;
<i>1725</i>&nbsp;    // Local constant functions:
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;    /* non-public */
<i>1728</i>&nbsp;    static final byte NF_checkSpreadArgument = 0,
<i>1729</i>&nbsp;            NF_guardWithCatch = 1,
<i>1730</i>&nbsp;            NF_throwException = 2,
<i>1731</i>&nbsp;            NF_tryFinally = 3,
<i>1732</i>&nbsp;            NF_loop = 4,
<i>1733</i>&nbsp;            NF_profileBoolean = 5,
<i>1734</i>&nbsp;            NF_LIMIT = 6;
<i>1735</i>&nbsp;
<i>1736</i>&nbsp;    private static final @Stable NamedFunction[] NFS = new NamedFunction[NF_LIMIT];
<i>1737</i>&nbsp;
<i>1738</i>&nbsp;    static NamedFunction getFunction(byte func) {
<i>1739</i>&nbsp;        NamedFunction nf = NFS[func];
<i>1740</i>&nbsp;        if (nf != null) {
<i>1741</i>&nbsp;            return nf;
<i>1742</i>&nbsp;        }
<i>1743</i>&nbsp;        return NFS[func] = createFunction(func);
<i>1744</i>&nbsp;    }
<i>1745</i>&nbsp;
<i>1746</i>&nbsp;    private static NamedFunction createFunction(byte func) {
<i>1747</i>&nbsp;        try {
<i>1748</i>&nbsp;            switch (func) {
<i>1749</i>&nbsp;                case NF_checkSpreadArgument:
<i>1750</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1751</i>&nbsp;                            .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));
<i>1752</i>&nbsp;                case NF_guardWithCatch:
<i>1753</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1754</i>&nbsp;                            .getDeclaredMethod(&quot;guardWithCatch&quot;, MethodHandle.class, Class.class,
<i>1755</i>&nbsp;                                    MethodHandle.class, Object[].class));
<i>1756</i>&nbsp;                case NF_tryFinally:
<i>1757</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1758</i>&nbsp;                            .getDeclaredMethod(&quot;tryFinally&quot;, MethodHandle.class, MethodHandle.class, Object[].class));
<i>1759</i>&nbsp;                case NF_loop:
<i>1760</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1761</i>&nbsp;                            .getDeclaredMethod(&quot;loop&quot;, BasicType[].class, LoopClauses.class, Object[].class));
<i>1762</i>&nbsp;                case NF_throwException:
<i>1763</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1764</i>&nbsp;                            .getDeclaredMethod(&quot;throwException&quot;, Throwable.class));
<i>1765</i>&nbsp;                case NF_profileBoolean:
<i>1766</i>&nbsp;                    return new NamedFunction(MethodHandleImpl.class
<i>1767</i>&nbsp;                            .getDeclaredMethod(&quot;profileBoolean&quot;, boolean.class, int[].class));
<i>1768</i>&nbsp;                default:
<i>1769</i>&nbsp;                    throw new InternalError(&quot;Undefined function: &quot; + func);
<i>1770</i>&nbsp;            }
<i>1771</i>&nbsp;        } catch (ReflectiveOperationException ex) {
<i>1772</i>&nbsp;            throw newInternalError(ex);
<i>1773</i>&nbsp;        }
<i>1774</i>&nbsp;    }
<i>1775</i>&nbsp;
<i>1776</i>&nbsp;    static {
<i>1777</i>&nbsp;        SharedSecrets.setJavaLangInvokeAccess(new JavaLangInvokeAccess() {
<i>1778</i>&nbsp;            @Override
<i>1779</i>&nbsp;            public Object newMemberName() {
<i>1780</i>&nbsp;                return new MemberName();
<i>1781</i>&nbsp;            }
<i>1782</i>&nbsp;
<i>1783</i>&nbsp;            @Override
<i>1784</i>&nbsp;            public String getName(Object mname) {
<i>1785</i>&nbsp;                MemberName memberName = (MemberName)mname;
<i>1786</i>&nbsp;                return memberName.getName();
<i>1787</i>&nbsp;            }
<i>1788</i>&nbsp;            @Override
<i>1789</i>&nbsp;            public Class&lt;?&gt; getDeclaringClass(Object mname) {
<i>1790</i>&nbsp;                MemberName memberName = (MemberName)mname;
<i>1791</i>&nbsp;                return memberName.getDeclaringClass();
<i>1792</i>&nbsp;            }
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;            @Override
<i>1795</i>&nbsp;            public MethodType getMethodType(Object mname) {
<i>1796</i>&nbsp;                MemberName memberName = (MemberName)mname;
<i>1797</i>&nbsp;                return memberName.getMethodType();
<i>1798</i>&nbsp;            }
<i>1799</i>&nbsp;
<i>1800</i>&nbsp;            @Override
<i>1801</i>&nbsp;            public String getMethodDescriptor(Object mname) {
<i>1802</i>&nbsp;                MemberName memberName = (MemberName)mname;
<i>1803</i>&nbsp;                return memberName.getMethodDescriptor();
<i>1804</i>&nbsp;            }
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;            @Override
<i>1807</i>&nbsp;            public boolean isNative(Object mname) {
<i>1808</i>&nbsp;                MemberName memberName = (MemberName)mname;
<i>1809</i>&nbsp;                return memberName.isNative();
<i>1810</i>&nbsp;            }
<i>1811</i>&nbsp;
<i>1812</i>&nbsp;            @Override
<i>1813</i>&nbsp;            public byte[] generateDirectMethodHandleHolderClassBytes(
<i>1814</i>&nbsp;                    String className, MethodType[] methodTypes, int[] types) {
<i>1815</i>&nbsp;                return GenerateJLIClassesHelper
<i>1816</i>&nbsp;                        .generateDirectMethodHandleHolderClassBytes(
<i>1817</i>&nbsp;                                className, methodTypes, types);
<i>1818</i>&nbsp;            }
<i>1819</i>&nbsp;
<i>1820</i>&nbsp;            @Override
<i>1821</i>&nbsp;            public byte[] generateDelegatingMethodHandleHolderClassBytes(
<i>1822</i>&nbsp;                    String className, MethodType[] methodTypes) {
<i>1823</i>&nbsp;                return GenerateJLIClassesHelper
<i>1824</i>&nbsp;                        .generateDelegatingMethodHandleHolderClassBytes(
<i>1825</i>&nbsp;                                className, methodTypes);
<i>1826</i>&nbsp;            }
<i>1827</i>&nbsp;
<i>1828</i>&nbsp;            @Override
<i>1829</i>&nbsp;            public Map.Entry&lt;String, byte[]&gt; generateConcreteBMHClassBytes(
<i>1830</i>&nbsp;                    final String types) {
<i>1831</i>&nbsp;                return GenerateJLIClassesHelper
<i>1832</i>&nbsp;                        .generateConcreteBMHClassBytes(types);
<i>1833</i>&nbsp;            }
<i>1834</i>&nbsp;
<i>1835</i>&nbsp;            @Override
<i>1836</i>&nbsp;            public byte[] generateBasicFormsClassBytes(final String className) {
<i>1837</i>&nbsp;                return GenerateJLIClassesHelper
<i>1838</i>&nbsp;                        .generateBasicFormsClassBytes(className);
<i>1839</i>&nbsp;            }
<i>1840</i>&nbsp;
<i>1841</i>&nbsp;            @Override
<i>1842</i>&nbsp;            public byte[] generateInvokersHolderClassBytes(final String className,
<i>1843</i>&nbsp;                    MethodType[] invokerMethodTypes,
<i>1844</i>&nbsp;                    MethodType[] callSiteMethodTypes) {
<i>1845</i>&nbsp;                return GenerateJLIClassesHelper
<i>1846</i>&nbsp;                        .generateInvokersHolderClassBytes(className,
<i>1847</i>&nbsp;                                invokerMethodTypes, callSiteMethodTypes);
<i>1848</i>&nbsp;            }
<i>1849</i>&nbsp;
<i>1850</i>&nbsp;        });
<i>1851</i>&nbsp;    }
<i>1852</i>&nbsp;
<i>1853</i>&nbsp;    /** Result unboxing: ValueConversions.unbox() OR ValueConversions.identity() OR ValueConversions.ignore(). */
<i>1854</i>&nbsp;    private static MethodHandle unboxResultHandle(Class&lt;?&gt; returnType) {
<i>1855</i>&nbsp;        if (returnType.isPrimitive()) {
<i>1856</i>&nbsp;            if (returnType == void.class) {
<i>1857</i>&nbsp;                return ValueConversions.ignore();
<i>1858</i>&nbsp;            } else {
<i>1859</i>&nbsp;                Wrapper w = Wrapper.forPrimitiveType(returnType);
<i>1860</i>&nbsp;                return ValueConversions.unboxExact(w);
<i>1861</i>&nbsp;            }
<i>1862</i>&nbsp;        } else {
<i>1863</i>&nbsp;            return MethodHandles.identity(Object.class);
<i>1864</i>&nbsp;        }
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    /**
<i>1868</i>&nbsp;     * Assembles a loop method handle from the given handles and type information.
<i>1869</i>&nbsp;     *
<i>1870</i>&nbsp;     * @param tloop the return type of the loop.
<i>1871</i>&nbsp;     * @param targs types of the arguments to be passed to the loop.
<i>1872</i>&nbsp;     * @param init sanitized array of initializers for loop-local variables.
<i>1873</i>&nbsp;     * @param step sanitited array of loop bodies.
<i>1874</i>&nbsp;     * @param pred sanitized array of predicates.
<i>1875</i>&nbsp;     * @param fini sanitized array of loop finalizers.
<i>1876</i>&nbsp;     *
<i>1877</i>&nbsp;     * @return a handle that, when invoked, will execute the loop.
<i>1878</i>&nbsp;     */
<i>1879</i>&nbsp;    static MethodHandle makeLoop(Class&lt;?&gt; tloop, List&lt;Class&lt;?&gt;&gt; targs, List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step,
<i>1880</i>&nbsp;                                 List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini) {
<i>1881</i>&nbsp;        MethodType type = MethodType.methodType(tloop, targs);
<i>1882</i>&nbsp;        BasicType[] initClauseTypes =
<i>1883</i>&nbsp;                init.stream().map(h -&gt; h.type().returnType()).map(BasicType::basicType).toArray(BasicType[]::new);
<i>1884</i>&nbsp;        LambdaForm form = makeLoopForm(type.basicType(), initClauseTypes);
<i>1885</i>&nbsp;
<i>1886</i>&nbsp;        // Prepare auxiliary method handles used during LambdaForm interpretation.
<i>1887</i>&nbsp;        // Box arguments and wrap them into Object[]: ValueConversions.array().
<i>1888</i>&nbsp;        MethodType varargsType = type.changeReturnType(Object[].class);
<i>1889</i>&nbsp;        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
<i>1890</i>&nbsp;        MethodHandle unboxResult = unboxResultHandle(tloop);
<i>1891</i>&nbsp;
<i>1892</i>&nbsp;        LoopClauses clauseData =
<i>1893</i>&nbsp;                new LoopClauses(new MethodHandle[][]{toArray(init), toArray(step), toArray(pred), toArray(fini)});
<i>1894</i>&nbsp;        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
<i>1895</i>&nbsp;        BoundMethodHandle mh;
<i>1896</i>&nbsp;        try {
<i>1897</i>&nbsp;            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) clauseData,
<i>1898</i>&nbsp;                    (Object) collectArgs, (Object) unboxResult);
<i>1899</i>&nbsp;        } catch (Throwable ex) {
<i>1900</i>&nbsp;            throw uncaughtException(ex);
<i>1901</i>&nbsp;        }
<i>1902</i>&nbsp;        assert(mh.type() == type);
<i>1903</i>&nbsp;        return mh;
<i>1904</i>&nbsp;    }
<i>1905</i>&nbsp;
<i>1906</i>&nbsp;    private static MethodHandle[] toArray(List&lt;MethodHandle&gt; l) {
<i>1907</i>&nbsp;        return l.toArray(new MethodHandle[0]);
<i>1908</i>&nbsp;    }
<i>1909</i>&nbsp;
<i>1910</i>&nbsp;    /**
<i>1911</i>&nbsp;     * Loops introduce some complexity as they can have additional local state. Hence, LambdaForms for loops are
<i>1912</i>&nbsp;     * generated from a template. The LambdaForm template shape for the loop combinator is as follows (assuming one
<i>1913</i>&nbsp;     * reference parameter passed in {@code a1}, and a reference return type, with the return value represented by
<i>1914</i>&nbsp;     * {@code t12}):
<i>1915</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1916</i>&nbsp;     *  loop=Lambda(a0:L,a1:L)=&gt;{
<i>1917</i>&nbsp;     *    t2:L=BoundMethodHandle$Species_L3.argL0(a0:L);    // LoopClauses holding init, step, pred, fini handles
<i>1918</i>&nbsp;     *    t3:L=BoundMethodHandle$Species_L3.argL1(a0:L);    // helper handle to box the arguments into an Object[]
<i>1919</i>&nbsp;     *    t4:L=BoundMethodHandle$Species_L3.argL2(a0:L);    // helper handle to unbox the result
<i>1920</i>&nbsp;     *    t5:L=MethodHandle.invokeBasic(t3:L,a1:L);         // box the arguments into an Object[]
<i>1921</i>&nbsp;     *    t6:L=MethodHandleImpl.loop(null,t2:L,t3:L);       // call the loop executor
<i>1922</i>&nbsp;     *    t7:L=MethodHandle.invokeBasic(t4:L,t6:L);t7:L}    // unbox the result; return the result
<i>1923</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1924</i>&nbsp;     * &lt;p&gt;
<i>1925</i>&nbsp;     * {@code argL0} is a LoopClauses instance holding, in a 2-dimensional array, the init, step, pred, and fini method
<i>1926</i>&nbsp;     * handles. {@code argL1} and {@code argL2} are auxiliary method handles: {@code argL1} boxes arguments and wraps
<i>1927</i>&nbsp;     * them into {@code Object[]} ({@code ValueConversions.array()}), and {@code argL2} unboxes the result if necessary
<i>1928</i>&nbsp;     * ({@code ValueConversions.unbox()}).
<i>1929</i>&nbsp;     * &lt;p&gt;
<i>1930</i>&nbsp;     * Having {@code t3} and {@code t4} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
<i>1931</i>&nbsp;     * forms among loop combinators with the same basic type.
<i>1932</i>&nbsp;     * &lt;p&gt;
<i>1933</i>&nbsp;     * The above template is instantiated by using the {@link LambdaFormEditor} to replace the {@code null} argument to
<i>1934</i>&nbsp;     * the {@code loop} invocation with the {@code BasicType} array describing the loop clause types. This argument is
<i>1935</i>&nbsp;     * ignored in the loop invoker, but will be extracted and used in {@linkplain InvokerBytecodeGenerator#emitLoop(int)
<i>1936</i>&nbsp;     * bytecode generation}.
<i>1937</i>&nbsp;     */
<i>1938</i>&nbsp;    private static LambdaForm makeLoopForm(MethodType basicType, BasicType[] localVarTypes) {
<i>1939</i>&nbsp;        MethodType lambdaType = basicType.invokerType();
<i>1940</i>&nbsp;
<i>1941</i>&nbsp;        final int THIS_MH = 0;  // the BMH_LLL
<i>1942</i>&nbsp;        final int ARG_BASE = 1; // start of incoming arguments
<i>1943</i>&nbsp;        final int ARG_LIMIT = ARG_BASE + basicType.parameterCount();
<i>1944</i>&nbsp;
<i>1945</i>&nbsp;        int nameCursor = ARG_LIMIT;
<i>1946</i>&nbsp;        final int GET_CLAUSE_DATA = nameCursor++;
<i>1947</i>&nbsp;        final int GET_COLLECT_ARGS = nameCursor++;
<i>1948</i>&nbsp;        final int GET_UNBOX_RESULT = nameCursor++;
<i>1949</i>&nbsp;        final int BOXED_ARGS = nameCursor++;
<i>1950</i>&nbsp;        final int LOOP = nameCursor++;
<i>1951</i>&nbsp;        final int UNBOX_RESULT = nameCursor++;
<i>1952</i>&nbsp;
<i>1953</i>&nbsp;        LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_LOOP);
<i>1954</i>&nbsp;        if (lform == null) {
<i>1955</i>&nbsp;            Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
<i>1956</i>&nbsp;
<i>1957</i>&nbsp;            BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLL();
<i>1958</i>&nbsp;            names[THIS_MH] = names[THIS_MH].withConstraint(data);
<i>1959</i>&nbsp;            names[GET_CLAUSE_DATA] = new Name(data.getterFunction(0), names[THIS_MH]);
<i>1960</i>&nbsp;            names[GET_COLLECT_ARGS] = new Name(data.getterFunction(1), names[THIS_MH]);
<i>1961</i>&nbsp;            names[GET_UNBOX_RESULT] = new Name(data.getterFunction(2), names[THIS_MH]);
<i>1962</i>&nbsp;
<i>1963</i>&nbsp;            // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
<i>1964</i>&nbsp;            MethodType collectArgsType = basicType.changeReturnType(Object.class);
<i>1965</i>&nbsp;            MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
<i>1966</i>&nbsp;            Object[] args = new Object[invokeBasic.type().parameterCount()];
<i>1967</i>&nbsp;            args[0] = names[GET_COLLECT_ARGS];
<i>1968</i>&nbsp;            System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);
<i>1969</i>&nbsp;            names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.LOOP), args);
<i>1970</i>&nbsp;
<i>1971</i>&nbsp;            // t_{i+1}:L=MethodHandleImpl.loop(localTypes:L,clauses:L,t_{i}:L);
<i>1972</i>&nbsp;            Object[] lArgs =
<i>1973</i>&nbsp;                    new Object[]{null, // placeholder for BasicType[] localTypes - will be added by LambdaFormEditor
<i>1974</i>&nbsp;                            names[GET_CLAUSE_DATA], names[BOXED_ARGS]};
<i>1975</i>&nbsp;            names[LOOP] = new Name(getFunction(NF_loop), lArgs);
<i>1976</i>&nbsp;
<i>1977</i>&nbsp;            // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
<i>1978</i>&nbsp;            MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
<i>1979</i>&nbsp;            Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[LOOP]};
<i>1980</i>&nbsp;            names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;            lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_LOOP,
<i>1983</i>&nbsp;                    new LambdaForm(lambdaType.parameterCount(), names, Kind.LOOP));
<i>1984</i>&nbsp;        }
<i>1985</i>&nbsp;
<i>1986</i>&nbsp;        // BOXED_ARGS is the index into the names array where the loop idiom starts
<i>1987</i>&nbsp;        return lform.editor().noteLoopLocalTypesForm(BOXED_ARGS, localVarTypes);
<i>1988</i>&nbsp;    }
<i>1989</i>&nbsp;
<i>1990</i>&nbsp;    static class LoopClauses {
<i>1991</i>&nbsp;        @Stable final MethodHandle[][] clauses;
<i>1992</i>&nbsp;        LoopClauses(MethodHandle[][] clauses) {
<i>1993</i>&nbsp;            assert clauses.length == 4;
<i>1994</i>&nbsp;            this.clauses = clauses;
<i>1995</i>&nbsp;        }
<i>1996</i>&nbsp;        @Override
<i>1997</i>&nbsp;        public String toString() {
<i>1998</i>&nbsp;            StringBuffer sb = new StringBuffer(&quot;LoopClauses -- &quot;);
<i>1999</i>&nbsp;            for (int i = 0; i &lt; 4; ++i) {
<i>2000</i>&nbsp;                if (i &gt; 0) {
<i>2001</i>&nbsp;                    sb.append(&quot;       &quot;);
<i>2002</i>&nbsp;                }
<i>2003</i>&nbsp;                sb.append(&#39;&lt;&#39;).append(i).append(&quot;&gt;: &quot;);
<i>2004</i>&nbsp;                MethodHandle[] hs = clauses[i];
<i>2005</i>&nbsp;                for (int j = 0; j &lt; hs.length; ++j) {
<i>2006</i>&nbsp;                    if (j &gt; 0) {
<i>2007</i>&nbsp;                        sb.append(&quot;          &quot;);
<i>2008</i>&nbsp;                    }
<i>2009</i>&nbsp;                    sb.append(&#39;*&#39;).append(j).append(&quot;: &quot;).append(hs[j]).append(&#39;\n&#39;);
<i>2010</i>&nbsp;                }
<i>2011</i>&nbsp;            }
<i>2012</i>&nbsp;            sb.append(&quot; --\n&quot;);
<i>2013</i>&nbsp;            return sb.toString();
<i>2014</i>&nbsp;        }
<i>2015</i>&nbsp;    }
<i>2016</i>&nbsp;
<i>2017</i>&nbsp;    /**
<i>2018</i>&nbsp;     * Intrinsified during LambdaForm compilation
<i>2019</i>&nbsp;     * (see {@link InvokerBytecodeGenerator#emitLoop(int)}).
<i>2020</i>&nbsp;     */
<i>2021</i>&nbsp;    @LambdaForm.Hidden
<i>2022</i>&nbsp;    static Object loop(BasicType[] localTypes, LoopClauses clauseData, Object... av) throws Throwable {
<i>2023</i>&nbsp;        final MethodHandle[] init = clauseData.clauses[0];
<i>2024</i>&nbsp;        final MethodHandle[] step = clauseData.clauses[1];
<i>2025</i>&nbsp;        final MethodHandle[] pred = clauseData.clauses[2];
<i>2026</i>&nbsp;        final MethodHandle[] fini = clauseData.clauses[3];
<i>2027</i>&nbsp;        int varSize = (int) Stream.of(init).filter(h -&gt; h.type().returnType() != void.class).count();
<i>2028</i>&nbsp;        int nArgs = init[0].type().parameterCount();
<i>2029</i>&nbsp;        Object[] varsAndArgs = new Object[varSize + nArgs];
<i>2030</i>&nbsp;        for (int i = 0, v = 0; i &lt; init.length; ++i) {
<i>2031</i>&nbsp;            MethodHandle ih = init[i];
<i>2032</i>&nbsp;            if (ih.type().returnType() == void.class) {
<i>2033</i>&nbsp;                ih.invokeWithArguments(av);
<i>2034</i>&nbsp;            } else {
<i>2035</i>&nbsp;                varsAndArgs[v++] = ih.invokeWithArguments(av);
<i>2036</i>&nbsp;            }
<i>2037</i>&nbsp;        }
<i>2038</i>&nbsp;        System.arraycopy(av, 0, varsAndArgs, varSize, nArgs);
<i>2039</i>&nbsp;        final int nSteps = step.length;
<i>2040</i>&nbsp;        for (; ; ) {
<i>2041</i>&nbsp;            for (int i = 0, v = 0; i &lt; nSteps; ++i) {
<i>2042</i>&nbsp;                MethodHandle p = pred[i];
<i>2043</i>&nbsp;                MethodHandle s = step[i];
<i>2044</i>&nbsp;                MethodHandle f = fini[i];
<i>2045</i>&nbsp;                if (s.type().returnType() == void.class) {
<i>2046</i>&nbsp;                    s.invokeWithArguments(varsAndArgs);
<i>2047</i>&nbsp;                } else {
<i>2048</i>&nbsp;                    varsAndArgs[v++] = s.invokeWithArguments(varsAndArgs);
<i>2049</i>&nbsp;                }
<i>2050</i>&nbsp;                if (!(boolean) p.invokeWithArguments(varsAndArgs)) {
<i>2051</i>&nbsp;                    return f.invokeWithArguments(varsAndArgs);
<i>2052</i>&nbsp;                }
<i>2053</i>&nbsp;            }
<i>2054</i>&nbsp;        }
<i>2055</i>&nbsp;    }
<i>2056</i>&nbsp;
<i>2057</i>&nbsp;    /**
<i>2058</i>&nbsp;     * This method is bound as the predicate in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
<i>2059</i>&nbsp;     * MethodHandle) counting loops}.
<i>2060</i>&nbsp;     *
<i>2061</i>&nbsp;     * @param limit the upper bound of the parameter, statically bound at loop creation time.
<i>2062</i>&nbsp;     * @param counter the counter parameter, passed in during loop execution.
<i>2063</i>&nbsp;     *
<i>2064</i>&nbsp;     * @return whether the counter has reached the limit.
<i>2065</i>&nbsp;     */
<i>2066</i>&nbsp;    static boolean countedLoopPredicate(int limit, int counter) {
<i>2067</i>&nbsp;        return counter &lt; limit;
<i>2068</i>&nbsp;    }
<i>2069</i>&nbsp;
<i>2070</i>&nbsp;    /**
<i>2071</i>&nbsp;     * This method is bound as the step function in {@linkplain MethodHandles#countedLoop(MethodHandle, MethodHandle,
<i>2072</i>&nbsp;     * MethodHandle) counting loops} to increment the counter.
<i>2073</i>&nbsp;     *
<i>2074</i>&nbsp;     * @param limit the upper bound of the loop counter (ignored).
<i>2075</i>&nbsp;     * @param counter the loop counter.
<i>2076</i>&nbsp;     *
<i>2077</i>&nbsp;     * @return the loop counter incremented by 1.
<i>2078</i>&nbsp;     */
<i>2079</i>&nbsp;    static int countedLoopStep(int limit, int counter) {
<i>2080</i>&nbsp;        return counter + 1;
<i>2081</i>&nbsp;    }
<i>2082</i>&nbsp;
<i>2083</i>&nbsp;    /**
<i>2084</i>&nbsp;     * This is bound to initialize the loop-local iterator in {@linkplain MethodHandles#iteratedLoop iterating loops}.
<i>2085</i>&nbsp;     *
<i>2086</i>&nbsp;     * @param it the {@link Iterable} over which the loop iterates.
<i>2087</i>&nbsp;     *
<i>2088</i>&nbsp;     * @return an {@link Iterator} over the argument&#39;s elements.
<i>2089</i>&nbsp;     */
<i>2090</i>&nbsp;    static Iterator&lt;?&gt; initIterator(Iterable&lt;?&gt; it) {
<i>2091</i>&nbsp;        return it.iterator();
<i>2092</i>&nbsp;    }
<i>2093</i>&nbsp;
<i>2094</i>&nbsp;    /**
<i>2095</i>&nbsp;     * This method is bound as the predicate in {@linkplain MethodHandles#iteratedLoop iterating loops}.
<i>2096</i>&nbsp;     *
<i>2097</i>&nbsp;     * @param it the iterator to be checked.
<i>2098</i>&nbsp;     *
<i>2099</i>&nbsp;     * @return {@code true} iff there are more elements to iterate over.
<i>2100</i>&nbsp;     */
<i>2101</i>&nbsp;    static boolean iteratePredicate(Iterator&lt;?&gt; it) {
<i>2102</i>&nbsp;        return it.hasNext();
<i>2103</i>&nbsp;    }
<i>2104</i>&nbsp;
<i>2105</i>&nbsp;    /**
<i>2106</i>&nbsp;     * This method is bound as the step for retrieving the current value from the iterator in {@linkplain
<i>2107</i>&nbsp;     * MethodHandles#iteratedLoop iterating loops}.
<i>2108</i>&nbsp;     *
<i>2109</i>&nbsp;     * @param it the iterator.
<i>2110</i>&nbsp;     *
<i>2111</i>&nbsp;     * @return the next element from the iterator.
<i>2112</i>&nbsp;     */
<i>2113</i>&nbsp;    static Object iterateNext(Iterator&lt;?&gt; it) {
<i>2114</i>&nbsp;        return it.next();
<i>2115</i>&nbsp;    }
<i>2116</i>&nbsp;
<i>2117</i>&nbsp;    /**
<i>2118</i>&nbsp;     * Makes a {@code try-finally} handle that conforms to the type constraints.
<i>2119</i>&nbsp;     *
<i>2120</i>&nbsp;     * @param target the target to execute in a {@code try-finally} block.
<i>2121</i>&nbsp;     * @param cleanup the cleanup to execute in the {@code finally} block.
<i>2122</i>&nbsp;     * @param rtype the result type of the entire construct.
<i>2123</i>&nbsp;     * @param argTypes the types of the arguments.
<i>2124</i>&nbsp;     *
<i>2125</i>&nbsp;     * @return a handle on the constructed {@code try-finally} block.
<i>2126</i>&nbsp;     */
<i>2127</i>&nbsp;    static MethodHandle makeTryFinally(MethodHandle target, MethodHandle cleanup, Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; argTypes) {
<i>2128</i>&nbsp;        MethodType type = MethodType.methodType(rtype, argTypes);
<i>2129</i>&nbsp;        LambdaForm form = makeTryFinallyForm(type.basicType());
<i>2130</i>&nbsp;
<i>2131</i>&nbsp;        // Prepare auxiliary method handles used during LambdaForm interpretation.
<i>2132</i>&nbsp;        // Box arguments and wrap them into Object[]: ValueConversions.array().
<i>2133</i>&nbsp;        MethodType varargsType = type.changeReturnType(Object[].class);
<i>2134</i>&nbsp;        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);
<i>2135</i>&nbsp;        MethodHandle unboxResult = unboxResultHandle(rtype);
<i>2136</i>&nbsp;
<i>2137</i>&nbsp;        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
<i>2138</i>&nbsp;        BoundMethodHandle mh;
<i>2139</i>&nbsp;        try {
<i>2140</i>&nbsp;            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) target, (Object) cleanup,
<i>2141</i>&nbsp;                    (Object) collectArgs, (Object) unboxResult);
<i>2142</i>&nbsp;        } catch (Throwable ex) {
<i>2143</i>&nbsp;            throw uncaughtException(ex);
<i>2144</i>&nbsp;        }
<i>2145</i>&nbsp;        assert(mh.type() == type);
<i>2146</i>&nbsp;        return mh;
<i>2147</i>&nbsp;    }
<i>2148</i>&nbsp;
<i>2149</i>&nbsp;    /**
<i>2150</i>&nbsp;     * The LambdaForm shape for the tryFinally combinator is as follows (assuming one reference parameter passed in
<i>2151</i>&nbsp;     * {@code a1}, and a reference return type, with the return value represented by {@code t8}):
<i>2152</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>2153</i>&nbsp;     *  tryFinally=Lambda(a0:L,a1:L)=&gt;{
<i>2154</i>&nbsp;     *    t2:L=BoundMethodHandle$Species_LLLL.argL0(a0:L);  // target method handle
<i>2155</i>&nbsp;     *    t3:L=BoundMethodHandle$Species_LLLL.argL1(a0:L);  // cleanup method handle
<i>2156</i>&nbsp;     *    t4:L=BoundMethodHandle$Species_LLLL.argL2(a0:L);  // helper handle to box the arguments into an Object[]
<i>2157</i>&nbsp;     *    t5:L=BoundMethodHandle$Species_LLLL.argL3(a0:L);  // helper handle to unbox the result
<i>2158</i>&nbsp;     *    t6:L=MethodHandle.invokeBasic(t4:L,a1:L);         // box the arguments into an Object[]
<i>2159</i>&nbsp;     *    t7:L=MethodHandleImpl.tryFinally(t2:L,t3:L,t6:L); // call the tryFinally executor
<i>2160</i>&nbsp;     *    t8:L=MethodHandle.invokeBasic(t5:L,t7:L);t8:L}    // unbox the result; return the result
<i>2161</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>2162</i>&nbsp;     * &lt;p&gt;
<i>2163</i>&nbsp;     * {@code argL0} and {@code argL1} are the target and cleanup method handles.
<i>2164</i>&nbsp;     * {@code argL2} and {@code argL3} are auxiliary method handles: {@code argL2} boxes arguments and wraps them into
<i>2165</i>&nbsp;     * {@code Object[]} ({@code ValueConversions.array()}), and {@code argL3} unboxes the result if necessary
<i>2166</i>&nbsp;     * ({@code ValueConversions.unbox()}).
<i>2167</i>&nbsp;     * &lt;p&gt;
<i>2168</i>&nbsp;     * Having {@code t4} and {@code t5} passed in via a BMH and not hardcoded in the lambda form allows to share lambda
<i>2169</i>&nbsp;     * forms among tryFinally combinators with the same basic type.
<i>2170</i>&nbsp;     */
<i>2171</i>&nbsp;    private static LambdaForm makeTryFinallyForm(MethodType basicType) {
<i>2172</i>&nbsp;        MethodType lambdaType = basicType.invokerType();
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;        LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_TF);
<i>2175</i>&nbsp;        if (lform != null) {
<i>2176</i>&nbsp;            return lform;
<i>2177</i>&nbsp;        }
<i>2178</i>&nbsp;        final int THIS_MH      = 0;  // the BMH_LLLL
<i>2179</i>&nbsp;        final int ARG_BASE     = 1;  // start of incoming arguments
<i>2180</i>&nbsp;        final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();
<i>2181</i>&nbsp;
<i>2182</i>&nbsp;        int nameCursor = ARG_LIMIT;
<i>2183</i>&nbsp;        final int GET_TARGET       = nameCursor++;
<i>2184</i>&nbsp;        final int GET_CLEANUP      = nameCursor++;
<i>2185</i>&nbsp;        final int GET_COLLECT_ARGS = nameCursor++;
<i>2186</i>&nbsp;        final int GET_UNBOX_RESULT = nameCursor++;
<i>2187</i>&nbsp;        final int BOXED_ARGS       = nameCursor++;
<i>2188</i>&nbsp;        final int TRY_FINALLY      = nameCursor++;
<i>2189</i>&nbsp;        final int UNBOX_RESULT     = nameCursor++;
<i>2190</i>&nbsp;
<i>2191</i>&nbsp;        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);
<i>2192</i>&nbsp;
<i>2193</i>&nbsp;        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();
<i>2194</i>&nbsp;        names[THIS_MH]          = names[THIS_MH].withConstraint(data);
<i>2195</i>&nbsp;        names[GET_TARGET]       = new Name(data.getterFunction(0), names[THIS_MH]);
<i>2196</i>&nbsp;        names[GET_CLEANUP]      = new Name(data.getterFunction(1), names[THIS_MH]);
<i>2197</i>&nbsp;        names[GET_COLLECT_ARGS] = new Name(data.getterFunction(2), names[THIS_MH]);
<i>2198</i>&nbsp;        names[GET_UNBOX_RESULT] = new Name(data.getterFunction(3), names[THIS_MH]);
<i>2199</i>&nbsp;
<i>2200</i>&nbsp;        // t_{i}:L=MethodHandle.invokeBasic(collectArgs:L,a1:L,...);
<i>2201</i>&nbsp;        MethodType collectArgsType = basicType.changeReturnType(Object.class);
<i>2202</i>&nbsp;        MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);
<i>2203</i>&nbsp;        Object[] args = new Object[invokeBasic.type().parameterCount()];
<i>2204</i>&nbsp;        args[0] = names[GET_COLLECT_ARGS];
<i>2205</i>&nbsp;        System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT-ARG_BASE);
<i>2206</i>&nbsp;        names[BOXED_ARGS] = new Name(new NamedFunction(invokeBasic, Intrinsic.TRY_FINALLY), args);
<i>2207</i>&nbsp;
<i>2208</i>&nbsp;        // t_{i+1}:L=MethodHandleImpl.tryFinally(target:L,exType:L,catcher:L,t_{i}:L);
<i>2209</i>&nbsp;        Object[] tfArgs = new Object[] {names[GET_TARGET], names[GET_CLEANUP], names[BOXED_ARGS]};
<i>2210</i>&nbsp;        names[TRY_FINALLY] = new Name(getFunction(NF_tryFinally), tfArgs);
<i>2211</i>&nbsp;
<i>2212</i>&nbsp;        // t_{i+2}:I=MethodHandle.invokeBasic(unbox:L,t_{i+1}:L);
<i>2213</i>&nbsp;        MethodHandle invokeBasicUnbox = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));
<i>2214</i>&nbsp;        Object[] unboxArgs  = new Object[] {names[GET_UNBOX_RESULT], names[TRY_FINALLY]};
<i>2215</i>&nbsp;        names[UNBOX_RESULT] = new Name(invokeBasicUnbox, unboxArgs);
<i>2216</i>&nbsp;
<i>2217</i>&nbsp;        lform = new LambdaForm(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);
<i>2218</i>&nbsp;
<i>2219</i>&nbsp;        return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_TF, lform);
<i>2220</i>&nbsp;    }
<i>2221</i>&nbsp;
<i>2222</i>&nbsp;    /**
<i>2223</i>&nbsp;     * Intrinsified during LambdaForm compilation
<i>2224</i>&nbsp;     * (see {@link InvokerBytecodeGenerator#emitTryFinally emitTryFinally}).
<i>2225</i>&nbsp;     */
<i>2226</i>&nbsp;    @LambdaForm.Hidden
<i>2227</i>&nbsp;    static Object tryFinally(MethodHandle target, MethodHandle cleanup, Object... av) throws Throwable {
<i>2228</i>&nbsp;        Throwable t = null;
<i>2229</i>&nbsp;        Object r = null;
<i>2230</i>&nbsp;        try {
<i>2231</i>&nbsp;            r = target.invokeWithArguments(av);
<i>2232</i>&nbsp;        } catch (Throwable thrown) {
<i>2233</i>&nbsp;            t = thrown;
<i>2234</i>&nbsp;            throw t;
<i>2235</i>&nbsp;        } finally {
<i>2236</i>&nbsp;            Object[] args = target.type().returnType() == void.class ? prepend(av, t) : prepend(av, t, r);
<i>2237</i>&nbsp;            r = cleanup.invokeWithArguments(args);
<i>2238</i>&nbsp;        }
<i>2239</i>&nbsp;        return r;
<i>2240</i>&nbsp;    }
<i>2241</i>&nbsp;
<i>2242</i>&nbsp;    // Indexes into constant method handles:
<i>2243</i>&nbsp;    static final int
<i>2244</i>&nbsp;            MH_cast                  =  0,
<i>2245</i>&nbsp;            MH_selectAlternative     =  1,
<i>2246</i>&nbsp;            MH_copyAsPrimitiveArray  =  2,
<i>2247</i>&nbsp;            MH_fillNewTypedArray     =  3,
<i>2248</i>&nbsp;            MH_fillNewArray          =  4,
<i>2249</i>&nbsp;            MH_arrayIdentity         =  5,
<i>2250</i>&nbsp;            MH_countedLoopPred       =  6,
<i>2251</i>&nbsp;            MH_countedLoopStep       =  7,
<i>2252</i>&nbsp;            MH_initIterator          =  8,
<i>2253</i>&nbsp;            MH_iteratePred           =  9,
<i>2254</i>&nbsp;            MH_iterateNext           = 10,
<i>2255</i>&nbsp;            MH_Array_newInstance     = 11,
<i>2256</i>&nbsp;            MH_LIMIT                 = 12;
<i>2257</i>&nbsp;
<i>2258</i>&nbsp;    static MethodHandle getConstantHandle(int idx) {
<i>2259</i>&nbsp;        MethodHandle handle = HANDLES[idx];
<i>2260</i>&nbsp;        if (handle != null) {
<i>2261</i>&nbsp;            return handle;
<i>2262</i>&nbsp;        }
<i>2263</i>&nbsp;        return setCachedHandle(idx, makeConstantHandle(idx));
<i>2264</i>&nbsp;    }
<i>2265</i>&nbsp;
<i>2266</i>&nbsp;    private static synchronized MethodHandle setCachedHandle(int idx, final MethodHandle method) {
<i>2267</i>&nbsp;        // Simulate a CAS, to avoid racy duplication of results.
<i>2268</i>&nbsp;        MethodHandle prev = HANDLES[idx];
<i>2269</i>&nbsp;        if (prev != null) {
<i>2270</i>&nbsp;            return prev;
<i>2271</i>&nbsp;        }
<i>2272</i>&nbsp;        HANDLES[idx] = method;
<i>2273</i>&nbsp;        return method;
<i>2274</i>&nbsp;    }
<i>2275</i>&nbsp;
<i>2276</i>&nbsp;    // Local constant method handles:
<i>2277</i>&nbsp;    private static final @Stable MethodHandle[] HANDLES = new MethodHandle[MH_LIMIT];
<i>2278</i>&nbsp;
<i>2279</i>&nbsp;    private static MethodHandle makeConstantHandle(int idx) {
<i>2280</i>&nbsp;        try {
<i>2281</i>&nbsp;            switch (idx) {
<i>2282</i>&nbsp;                case MH_cast:
<i>2283</i>&nbsp;                    return IMPL_LOOKUP.findVirtual(Class.class, &quot;cast&quot;,
<i>2284</i>&nbsp;                            MethodType.methodType(Object.class, Object.class));
<i>2285</i>&nbsp;                case MH_copyAsPrimitiveArray:
<i>2286</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;copyAsPrimitiveArray&quot;,
<i>2287</i>&nbsp;                            MethodType.methodType(Object.class, Wrapper.class, Object[].class));
<i>2288</i>&nbsp;                case MH_arrayIdentity:
<i>2289</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;identity&quot;,
<i>2290</i>&nbsp;                            MethodType.methodType(Object[].class, Object[].class));
<i>2291</i>&nbsp;                case MH_fillNewArray:
<i>2292</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewArray&quot;,
<i>2293</i>&nbsp;                            MethodType.methodType(Object[].class, Integer.class, Object[].class));
<i>2294</i>&nbsp;                case MH_fillNewTypedArray:
<i>2295</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;fillNewTypedArray&quot;,
<i>2296</i>&nbsp;                            MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));
<i>2297</i>&nbsp;                case MH_selectAlternative:
<i>2298</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,
<i>2299</i>&nbsp;                            MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));
<i>2300</i>&nbsp;                case MH_countedLoopPred:
<i>2301</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopPredicate&quot;,
<i>2302</i>&nbsp;                            MethodType.methodType(boolean.class, int.class, int.class));
<i>2303</i>&nbsp;                case MH_countedLoopStep:
<i>2304</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;countedLoopStep&quot;,
<i>2305</i>&nbsp;                            MethodType.methodType(int.class, int.class, int.class));
<i>2306</i>&nbsp;                case MH_initIterator:
<i>2307</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;initIterator&quot;,
<i>2308</i>&nbsp;                            MethodType.methodType(Iterator.class, Iterable.class));
<i>2309</i>&nbsp;                case MH_iteratePred:
<i>2310</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iteratePredicate&quot;,
<i>2311</i>&nbsp;                            MethodType.methodType(boolean.class, Iterator.class));
<i>2312</i>&nbsp;                case MH_iterateNext:
<i>2313</i>&nbsp;                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;iterateNext&quot;,
<i>2314</i>&nbsp;                            MethodType.methodType(Object.class, Iterator.class));
<i>2315</i>&nbsp;                case MH_Array_newInstance:
<i>2316</i>&nbsp;                    return IMPL_LOOKUP.findStatic(Array.class, &quot;newInstance&quot;,
<i>2317</i>&nbsp;                            MethodType.methodType(Object.class, Class.class, int.class));
<i>2318</i>&nbsp;            }
<i>2319</i>&nbsp;        } catch (ReflectiveOperationException ex) {
<i>2320</i>&nbsp;            throw newInternalError(ex);
<i>2321</i>&nbsp;        }
<i>2322</i>&nbsp;        throw newInternalError(&quot;Unknown function index: &quot; + idx);
<i>2323</i>&nbsp;    }
<i>2324</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
