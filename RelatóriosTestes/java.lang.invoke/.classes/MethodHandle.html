


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MethodHandle</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang.invoke</a> ]
</div>

<h1>Coverage Summary for Class: MethodHandle (java.lang.invoke)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 136)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang.invoke;
<i>27</i>&nbsp;
<i>28</i>&nbsp;
<i>29</i>&nbsp;import jdk.internal.HotSpotIntrinsicCandidate;
<i>30</i>&nbsp;
<i>31</i>&nbsp;import java.util.Arrays;
<i>32</i>&nbsp;import java.util.Objects;
<i>33</i>&nbsp;
<i>34</i>&nbsp;import static java.lang.invoke.MethodHandleStatics.*;
<i>35</i>&nbsp;
<i>36</i>&nbsp;/**
<i>37</i>&nbsp; * A method handle is a typed, directly executable reference to an underlying method,
<i>38</i>&nbsp; * constructor, field, or similar low-level operation, with optional
<i>39</i>&nbsp; * transformations of arguments or return values.
<i>40</i>&nbsp; * These transformations are quite general, and include such patterns as
<i>41</i>&nbsp; * {@linkplain #asType conversion},
<i>42</i>&nbsp; * {@linkplain #bindTo insertion},
<i>43</i>&nbsp; * {@linkplain java.lang.invoke.MethodHandles#dropArguments deletion},
<i>44</i>&nbsp; * and {@linkplain java.lang.invoke.MethodHandles#filterArguments substitution}.
<i>45</i>&nbsp; *
<i>46</i>&nbsp; * &lt;h1&gt;Method handle contents&lt;/h1&gt;
<i>47</i>&nbsp; * Method handles are dynamically and strongly typed according to their parameter and return types.
<i>48</i>&nbsp; * They are not distinguished by the name or the defining class of their underlying methods.
<i>49</i>&nbsp; * A method handle must be invoked using a symbolic type descriptor which matches
<i>50</i>&nbsp; * the method handle&#39;s own {@linkplain #type() type descriptor}.
<i>51</i>&nbsp; * &lt;p&gt;
<i>52</i>&nbsp; * Every method handle reports its type descriptor via the {@link #type() type} accessor.
<i>53</i>&nbsp; * This type descriptor is a {@link java.lang.invoke.MethodType MethodType} object,
<i>54</i>&nbsp; * whose structure is a series of classes, one of which is
<i>55</i>&nbsp; * the return type of the method (or {@code void.class} if none).
<i>56</i>&nbsp; * &lt;p&gt;
<i>57</i>&nbsp; * A method handle&#39;s type controls the types of invocations it accepts,
<i>58</i>&nbsp; * and the kinds of transformations that apply to it.
<i>59</i>&nbsp; * &lt;p&gt;
<i>60</i>&nbsp; * A method handle contains a pair of special invoker methods
<i>61</i>&nbsp; * called {@link #invokeExact invokeExact} and {@link #invoke invoke}.
<i>62</i>&nbsp; * Both invoker methods provide direct access to the method handle&#39;s
<i>63</i>&nbsp; * underlying method, constructor, field, or other operation,
<i>64</i>&nbsp; * as modified by transformations of arguments and return values.
<i>65</i>&nbsp; * Both invokers accept calls which exactly match the method handle&#39;s own type.
<i>66</i>&nbsp; * The plain, inexact invoker also accepts a range of other call types.
<i>67</i>&nbsp; * &lt;p&gt;
<i>68</i>&nbsp; * Method handles are immutable and have no visible state.
<i>69</i>&nbsp; * Of course, they can be bound to underlying methods or data which exhibit state.
<i>70</i>&nbsp; * With respect to the Java Memory Model, any method handle will behave
<i>71</i>&nbsp; * as if all of its (internal) fields are final variables.  This means that any method
<i>72</i>&nbsp; * handle made visible to the application will always be fully formed.
<i>73</i>&nbsp; * This is true even if the method handle is published through a shared
<i>74</i>&nbsp; * variable in a data race.
<i>75</i>&nbsp; * &lt;p&gt;
<i>76</i>&nbsp; * Method handles cannot be subclassed by the user.
<i>77</i>&nbsp; * Implementations may (or may not) create internal subclasses of {@code MethodHandle}
<i>78</i>&nbsp; * which may be visible via the {@link java.lang.Object#getClass Object.getClass}
<i>79</i>&nbsp; * operation.  The programmer should not draw conclusions about a method handle
<i>80</i>&nbsp; * from its specific class, as the method handle class hierarchy (if any)
<i>81</i>&nbsp; * may change from time to time or across implementations from different vendors.
<i>82</i>&nbsp; *
<i>83</i>&nbsp; * &lt;h1&gt;Method handle compilation&lt;/h1&gt;
<i>84</i>&nbsp; * A Java method call expression naming {@code invokeExact} or {@code invoke}
<i>85</i>&nbsp; * can invoke a method handle from Java source code.
<i>86</i>&nbsp; * From the viewpoint of source code, these methods can take any arguments
<i>87</i>&nbsp; * and their result can be cast to any return type.
<i>88</i>&nbsp; * Formally this is accomplished by giving the invoker methods
<i>89</i>&nbsp; * {@code Object} return types and variable arity {@code Object} arguments,
<i>90</i>&nbsp; * but they have an additional quality called &lt;em&gt;signature polymorphism&lt;/em&gt;
<i>91</i>&nbsp; * which connects this freedom of invocation directly to the JVM execution stack.
<i>92</i>&nbsp; * &lt;p&gt;
<i>93</i>&nbsp; * As is usual with virtual methods, source-level calls to {@code invokeExact}
<i>94</i>&nbsp; * and {@code invoke} compile to an {@code invokevirtual} instruction.
<i>95</i>&nbsp; * More unusually, the compiler must record the actual argument types,
<i>96</i>&nbsp; * and may not perform method invocation conversions on the arguments.
<i>97</i>&nbsp; * Instead, it must generate instructions that push them on the stack according
<i>98</i>&nbsp; * to their own unconverted types.  The method handle object itself is pushed on
<i>99</i>&nbsp; * the stack before the arguments.
<i>100</i>&nbsp; * The compiler then generates an {@code invokevirtual} instruction that invokes
<i>101</i>&nbsp; * the method handle with a symbolic type descriptor which describes the argument
<i>102</i>&nbsp; * and return types.
<i>103</i>&nbsp; * &lt;p&gt;
<i>104</i>&nbsp; * To issue a complete symbolic type descriptor, the compiler must also determine
<i>105</i>&nbsp; * the return type.  This is based on a cast on the method invocation expression,
<i>106</i>&nbsp; * if there is one, or else {@code Object} if the invocation is an expression,
<i>107</i>&nbsp; * or else {@code void} if the invocation is a statement.
<i>108</i>&nbsp; * The cast may be to a primitive type (but not {@code void}).
<i>109</i>&nbsp; * &lt;p&gt;
<i>110</i>&nbsp; * As a corner case, an uncasted {@code null} argument is given
<i>111</i>&nbsp; * a symbolic type descriptor of {@code java.lang.Void}.
<i>112</i>&nbsp; * The ambiguity with the type {@code Void} is harmless, since there are no references of type
<i>113</i>&nbsp; * {@code Void} except the null reference.
<i>114</i>&nbsp; *
<i>115</i>&nbsp; * &lt;h1&gt;Method handle invocation&lt;/h1&gt;
<i>116</i>&nbsp; * The first time an {@code invokevirtual} instruction is executed
<i>117</i>&nbsp; * it is linked by symbolically resolving the names in the instruction
<i>118</i>&nbsp; * and verifying that the method call is statically legal.
<i>119</i>&nbsp; * This also holds for calls to {@code invokeExact} and {@code invoke}.
<i>120</i>&nbsp; * In this case, the symbolic type descriptor emitted by the compiler is checked for
<i>121</i>&nbsp; * correct syntax, and names it contains are resolved.
<i>122</i>&nbsp; * Thus, an {@code invokevirtual} instruction which invokes
<i>123</i>&nbsp; * a method handle will always link, as long
<i>124</i>&nbsp; * as the symbolic type descriptor is syntactically well-formed
<i>125</i>&nbsp; * and the types exist.
<i>126</i>&nbsp; * &lt;p&gt;
<i>127</i>&nbsp; * When the {@code invokevirtual} is executed after linking,
<i>128</i>&nbsp; * the receiving method handle&#39;s type is first checked by the JVM
<i>129</i>&nbsp; * to ensure that it matches the symbolic type descriptor.
<i>130</i>&nbsp; * If the type match fails, it means that the method which the
<i>131</i>&nbsp; * caller is invoking is not present on the individual
<i>132</i>&nbsp; * method handle being invoked.
<i>133</i>&nbsp; * &lt;p&gt;
<i>134</i>&nbsp; * In the case of {@code invokeExact}, the type descriptor of the invocation
<i>135</i>&nbsp; * (after resolving symbolic type names) must exactly match the method type
<i>136</i>&nbsp; * of the receiving method handle.
<i>137</i>&nbsp; * In the case of plain, inexact {@code invoke}, the resolved type descriptor
<i>138</i>&nbsp; * must be a valid argument to the receiver&#39;s {@link #asType asType} method.
<i>139</i>&nbsp; * Thus, plain {@code invoke} is more permissive than {@code invokeExact}.
<i>140</i>&nbsp; * &lt;p&gt;
<i>141</i>&nbsp; * After type matching, a call to {@code invokeExact} directly
<i>142</i>&nbsp; * and immediately invoke the method handle&#39;s underlying method
<i>143</i>&nbsp; * (or other behavior, as the case may be).
<i>144</i>&nbsp; * &lt;p&gt;
<i>145</i>&nbsp; * A call to plain {@code invoke} works the same as a call to
<i>146</i>&nbsp; * {@code invokeExact}, if the symbolic type descriptor specified by the caller
<i>147</i>&nbsp; * exactly matches the method handle&#39;s own type.
<i>148</i>&nbsp; * If there is a type mismatch, {@code invoke} attempts
<i>149</i>&nbsp; * to adjust the type of the receiving method handle,
<i>150</i>&nbsp; * as if by a call to {@link #asType asType},
<i>151</i>&nbsp; * to obtain an exactly invokable method handle {@code M2}.
<i>152</i>&nbsp; * This allows a more powerful negotiation of method type
<i>153</i>&nbsp; * between caller and callee.
<i>154</i>&nbsp; * &lt;p&gt;
<i>155</i>&nbsp; * (&lt;em&gt;Note:&lt;/em&gt; The adjusted method handle {@code M2} is not directly observable,
<i>156</i>&nbsp; * and implementations are therefore not required to materialize it.)
<i>157</i>&nbsp; *
<i>158</i>&nbsp; * &lt;h1&gt;Invocation checking&lt;/h1&gt;
<i>159</i>&nbsp; * In typical programs, method handle type matching will usually succeed.
<i>160</i>&nbsp; * But if a match fails, the JVM will throw a {@link WrongMethodTypeException},
<i>161</i>&nbsp; * either directly (in the case of {@code invokeExact}) or indirectly as if
<i>162</i>&nbsp; * by a failed call to {@code asType} (in the case of {@code invoke}).
<i>163</i>&nbsp; * &lt;p&gt;
<i>164</i>&nbsp; * Thus, a method type mismatch which might show up as a linkage error
<i>165</i>&nbsp; * in a statically typed program can show up as
<i>166</i>&nbsp; * a dynamic {@code WrongMethodTypeException}
<i>167</i>&nbsp; * in a program which uses method handles.
<i>168</i>&nbsp; * &lt;p&gt;
<i>169</i>&nbsp; * Because method types contain &quot;live&quot; {@code Class} objects,
<i>170</i>&nbsp; * method type matching takes into account both type names and class loaders.
<i>171</i>&nbsp; * Thus, even if a method handle {@code M} is created in one
<i>172</i>&nbsp; * class loader {@code L1} and used in another {@code L2},
<i>173</i>&nbsp; * method handle calls are type-safe, because the caller&#39;s symbolic type
<i>174</i>&nbsp; * descriptor, as resolved in {@code L2},
<i>175</i>&nbsp; * is matched against the original callee method&#39;s symbolic type descriptor,
<i>176</i>&nbsp; * as resolved in {@code L1}.
<i>177</i>&nbsp; * The resolution in {@code L1} happens when {@code M} is created
<i>178</i>&nbsp; * and its type is assigned, while the resolution in {@code L2} happens
<i>179</i>&nbsp; * when the {@code invokevirtual} instruction is linked.
<i>180</i>&nbsp; * &lt;p&gt;
<i>181</i>&nbsp; * Apart from type descriptor checks,
<i>182</i>&nbsp; * a method handle&#39;s capability to call its underlying method is unrestricted.
<i>183</i>&nbsp; * If a method handle is formed on a non-public method by a class
<i>184</i>&nbsp; * that has access to that method, the resulting handle can be used
<i>185</i>&nbsp; * in any place by any caller who receives a reference to it.
<i>186</i>&nbsp; * &lt;p&gt;
<i>187</i>&nbsp; * Unlike with the Core Reflection API, where access is checked every time
<i>188</i>&nbsp; * a reflective method is invoked,
<i>189</i>&nbsp; * method handle access checking is performed
<i>190</i>&nbsp; * &lt;a href=&quot;MethodHandles.Lookup.html#access&quot;&gt;when the method handle is created&lt;/a&gt;.
<i>191</i>&nbsp; * In the case of {@code ldc} (see below), access checking is performed as part of linking
<i>192</i>&nbsp; * the constant pool entry underlying the constant method handle.
<i>193</i>&nbsp; * &lt;p&gt;
<i>194</i>&nbsp; * Thus, handles to non-public methods, or to methods in non-public classes,
<i>195</i>&nbsp; * should generally be kept secret.
<i>196</i>&nbsp; * They should not be passed to untrusted code unless their use from
<i>197</i>&nbsp; * the untrusted code would be harmless.
<i>198</i>&nbsp; *
<i>199</i>&nbsp; * &lt;h1&gt;Method handle creation&lt;/h1&gt;
<i>200</i>&nbsp; * Java code can create a method handle that directly accesses
<i>201</i>&nbsp; * any method, constructor, or field that is accessible to that code.
<i>202</i>&nbsp; * This is done via a reflective, capability-based API called
<i>203</i>&nbsp; * {@link java.lang.invoke.MethodHandles.Lookup MethodHandles.Lookup}.
<i>204</i>&nbsp; * For example, a static method handle can be obtained
<i>205</i>&nbsp; * from {@link java.lang.invoke.MethodHandles.Lookup#findStatic Lookup.findStatic}.
<i>206</i>&nbsp; * There are also conversion methods from Core Reflection API objects,
<i>207</i>&nbsp; * such as {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
<i>208</i>&nbsp; * &lt;p&gt;
<i>209</i>&nbsp; * Like classes and strings, method handles that correspond to accessible
<i>210</i>&nbsp; * fields, methods, and constructors can also be represented directly
<i>211</i>&nbsp; * in a class file&#39;s constant pool as constants to be loaded by {@code ldc} bytecodes.
<i>212</i>&nbsp; * A new type of constant pool entry, {@code CONSTANT_MethodHandle},
<i>213</i>&nbsp; * refers directly to an associated {@code CONSTANT_Methodref},
<i>214</i>&nbsp; * {@code CONSTANT_InterfaceMethodref}, or {@code CONSTANT_Fieldref}
<i>215</i>&nbsp; * constant pool entry.
<i>216</i>&nbsp; * (For full details on method handle constants,
<i>217</i>&nbsp; * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
<i>218</i>&nbsp; * &lt;p&gt;
<i>219</i>&nbsp; * Method handles produced by lookups or constant loads from methods or
<i>220</i>&nbsp; * constructors with the variable arity modifier bit ({@code 0x0080})
<i>221</i>&nbsp; * have a corresponding variable arity, as if they were defined with
<i>222</i>&nbsp; * the help of {@link #asVarargsCollector asVarargsCollector}
<i>223</i>&nbsp; * or {@link #withVarargs withVarargs}.
<i>224</i>&nbsp; * &lt;p&gt;
<i>225</i>&nbsp; * A method reference may refer either to a static or non-static method.
<i>226</i>&nbsp; * In the non-static case, the method handle type includes an explicit
<i>227</i>&nbsp; * receiver argument, prepended before any other arguments.
<i>228</i>&nbsp; * In the method handle&#39;s type, the initial receiver argument is typed
<i>229</i>&nbsp; * according to the class under which the method was initially requested.
<i>230</i>&nbsp; * (E.g., if a non-static method handle is obtained via {@code ldc},
<i>231</i>&nbsp; * the type of the receiver is the class named in the constant pool entry.)
<i>232</i>&nbsp; * &lt;p&gt;
<i>233</i>&nbsp; * Method handle constants are subject to the same link-time access checks
<i>234</i>&nbsp; * their corresponding bytecode instructions, and the {@code ldc} instruction
<i>235</i>&nbsp; * will throw corresponding linkage errors if the bytecode behaviors would
<i>236</i>&nbsp; * throw such errors.
<i>237</i>&nbsp; * &lt;p&gt;
<i>238</i>&nbsp; * As a corollary of this, access to protected members is restricted
<i>239</i>&nbsp; * to receivers only of the accessing class, or one of its subclasses,
<i>240</i>&nbsp; * and the accessing class must in turn be a subclass (or package sibling)
<i>241</i>&nbsp; * of the protected member&#39;s defining class.
<i>242</i>&nbsp; * If a method reference refers to a protected non-static method or field
<i>243</i>&nbsp; * of a class outside the current package, the receiver argument will
<i>244</i>&nbsp; * be narrowed to the type of the accessing class.
<i>245</i>&nbsp; * &lt;p&gt;
<i>246</i>&nbsp; * When a method handle to a virtual method is invoked, the method is
<i>247</i>&nbsp; * always looked up in the receiver (that is, the first argument).
<i>248</i>&nbsp; * &lt;p&gt;
<i>249</i>&nbsp; * A non-virtual method handle to a specific virtual method implementation
<i>250</i>&nbsp; * can also be created.  These do not perform virtual lookup based on
<i>251</i>&nbsp; * receiver type.  Such a method handle simulates the effect of
<i>252</i>&nbsp; * an {@code invokespecial} instruction to the same method.
<i>253</i>&nbsp; * A non-virtual method handle can also be created to simulate the effect
<i>254</i>&nbsp; * of an {@code invokevirtual} or {@code invokeinterface} instruction on
<i>255</i>&nbsp; * a private method (as applicable).
<i>256</i>&nbsp; *
<i>257</i>&nbsp; * &lt;h1&gt;Usage examples&lt;/h1&gt;
<i>258</i>&nbsp; * Here are some examples of usage:
<i>259</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>260</i>&nbsp;Object x, y; String s; int i;
<i>261</i>&nbsp;MethodType mt; MethodHandle mh;
<i>262</i>&nbsp;MethodHandles.Lookup lookup = MethodHandles.lookup();
<i>263</i>&nbsp;// mt is (char,char)String
<i>264</i>&nbsp;mt = MethodType.methodType(String.class, char.class, char.class);
<i>265</i>&nbsp;mh = lookup.findVirtual(String.class, &quot;replace&quot;, mt);
<i>266</i>&nbsp;s = (String) mh.invokeExact(&quot;daddy&quot;,&#39;d&#39;,&#39;n&#39;);
<i>267</i>&nbsp;// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
<i>268</i>&nbsp;assertEquals(s, &quot;nanny&quot;);
<i>269</i>&nbsp;// weakly typed invocation (using MHs.invoke)
<i>270</i>&nbsp;s = (String) mh.invokeWithArguments(&quot;sappy&quot;, &#39;p&#39;, &#39;v&#39;);
<i>271</i>&nbsp;assertEquals(s, &quot;savvy&quot;);
<i>272</i>&nbsp;// mt is (Object[])List
<i>273</i>&nbsp;mt = MethodType.methodType(java.util.List.class, Object[].class);
<i>274</i>&nbsp;mh = lookup.findStatic(java.util.Arrays.class, &quot;asList&quot;, mt);
<i>275</i>&nbsp;assert(mh.isVarargsCollector());
<i>276</i>&nbsp;x = mh.invoke(&quot;one&quot;, &quot;two&quot;);
<i>277</i>&nbsp;// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
<i>278</i>&nbsp;assertEquals(x, java.util.Arrays.asList(&quot;one&quot;,&quot;two&quot;));
<i>279</i>&nbsp;// mt is (Object,Object,Object)Object
<i>280</i>&nbsp;mt = MethodType.genericMethodType(3);
<i>281</i>&nbsp;mh = mh.asType(mt);
<i>282</i>&nbsp;x = mh.invokeExact((Object)1, (Object)2, (Object)3);
<i>283</i>&nbsp;// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
<i>284</i>&nbsp;assertEquals(x, java.util.Arrays.asList(1,2,3));
<i>285</i>&nbsp;// mt is ()int
<i>286</i>&nbsp;mt = MethodType.methodType(int.class);
<i>287</i>&nbsp;mh = lookup.findVirtual(java.util.List.class, &quot;size&quot;, mt);
<i>288</i>&nbsp;i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
<i>289</i>&nbsp;// invokeExact(Ljava/util/List;)I
<i>290</i>&nbsp;assert(i == 3);
<i>291</i>&nbsp;mt = MethodType.methodType(void.class, String.class);
<i>292</i>&nbsp;mh = lookup.findVirtual(java.io.PrintStream.class, &quot;println&quot;, mt);
<i>293</i>&nbsp;mh.invokeExact(System.out, &quot;Hello, world.&quot;);
<i>294</i>&nbsp;// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
<i>295</i>&nbsp; * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>296</i>&nbsp; * Each of the above calls to {@code invokeExact} or plain {@code invoke}
<i>297</i>&nbsp; * generates a single invokevirtual instruction with
<i>298</i>&nbsp; * the symbolic type descriptor indicated in the following comment.
<i>299</i>&nbsp; * In these examples, the helper method {@code assertEquals} is assumed to
<i>300</i>&nbsp; * be a method which calls {@link java.util.Objects#equals(Object,Object) Objects.equals}
<i>301</i>&nbsp; * on its arguments, and asserts that the result is true.
<i>302</i>&nbsp; *
<i>303</i>&nbsp; * &lt;h1&gt;Exceptions&lt;/h1&gt;
<i>304</i>&nbsp; * The methods {@code invokeExact} and {@code invoke} are declared
<i>305</i>&nbsp; * to throw {@link java.lang.Throwable Throwable},
<i>306</i>&nbsp; * which is to say that there is no static restriction on what a method handle
<i>307</i>&nbsp; * can throw.  Since the JVM does not distinguish between checked
<i>308</i>&nbsp; * and unchecked exceptions (other than by their class, of course),
<i>309</i>&nbsp; * there is no particular effect on bytecode shape from ascribing
<i>310</i>&nbsp; * checked exceptions to method handle invocations.  But in Java source
<i>311</i>&nbsp; * code, methods which perform method handle calls must either explicitly
<i>312</i>&nbsp; * throw {@code Throwable}, or else must catch all
<i>313</i>&nbsp; * throwables locally, rethrowing only those which are legal in the context,
<i>314</i>&nbsp; * and wrapping ones which are illegal.
<i>315</i>&nbsp; *
<i>316</i>&nbsp; * &lt;h1&gt;&lt;a id=&quot;sigpoly&quot;&gt;&lt;/a&gt;Signature polymorphism&lt;/h1&gt;
<i>317</i>&nbsp; * The unusual compilation and linkage behavior of
<i>318</i>&nbsp; * {@code invokeExact} and plain {@code invoke}
<i>319</i>&nbsp; * is referenced by the term &lt;em&gt;signature polymorphism&lt;/em&gt;.
<i>320</i>&nbsp; * As defined in the Java Language Specification,
<i>321</i>&nbsp; * a signature polymorphic method is one which can operate with
<i>322</i>&nbsp; * any of a wide range of call signatures and return types.
<i>323</i>&nbsp; * &lt;p&gt;
<i>324</i>&nbsp; * In source code, a call to a signature polymorphic method will
<i>325</i>&nbsp; * compile, regardless of the requested symbolic type descriptor.
<i>326</i>&nbsp; * As usual, the Java compiler emits an {@code invokevirtual}
<i>327</i>&nbsp; * instruction with the given symbolic type descriptor against the named method.
<i>328</i>&nbsp; * The unusual part is that the symbolic type descriptor is derived from
<i>329</i>&nbsp; * the actual argument and return types, not from the method declaration.
<i>330</i>&nbsp; * &lt;p&gt;
<i>331</i>&nbsp; * When the JVM processes bytecode containing signature polymorphic calls,
<i>332</i>&nbsp; * it will successfully link any such call, regardless of its symbolic type descriptor.
<i>333</i>&nbsp; * (In order to retain type safety, the JVM will guard such calls with suitable
<i>334</i>&nbsp; * dynamic type checks, as described elsewhere.)
<i>335</i>&nbsp; * &lt;p&gt;
<i>336</i>&nbsp; * Bytecode generators, including the compiler back end, are required to emit
<i>337</i>&nbsp; * untransformed symbolic type descriptors for these methods.
<i>338</i>&nbsp; * Tools which determine symbolic linkage are required to accept such
<i>339</i>&nbsp; * untransformed descriptors, without reporting linkage errors.
<i>340</i>&nbsp; *
<i>341</i>&nbsp; * &lt;h1&gt;Interoperation between method handles and the Core Reflection API&lt;/h1&gt;
<i>342</i>&nbsp; * Using factory methods in the {@link java.lang.invoke.MethodHandles.Lookup Lookup} API,
<i>343</i>&nbsp; * any class member represented by a Core Reflection API object
<i>344</i>&nbsp; * can be converted to a behaviorally equivalent method handle.
<i>345</i>&nbsp; * For example, a reflective {@link java.lang.reflect.Method Method} can
<i>346</i>&nbsp; * be converted to a method handle using
<i>347</i>&nbsp; * {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect}.
<i>348</i>&nbsp; * The resulting method handles generally provide more direct and efficient
<i>349</i>&nbsp; * access to the underlying class members.
<i>350</i>&nbsp; * &lt;p&gt;
<i>351</i>&nbsp; * As a special case,
<i>352</i>&nbsp; * when the Core Reflection API is used to view the signature polymorphic
<i>353</i>&nbsp; * methods {@code invokeExact} or plain {@code invoke} in this class,
<i>354</i>&nbsp; * they appear as ordinary non-polymorphic methods.
<i>355</i>&nbsp; * Their reflective appearance, as viewed by
<i>356</i>&nbsp; * {@link java.lang.Class#getDeclaredMethod Class.getDeclaredMethod},
<i>357</i>&nbsp; * is unaffected by their special status in this API.
<i>358</i>&nbsp; * For example, {@link java.lang.reflect.Method#getModifiers Method.getModifiers}
<i>359</i>&nbsp; * will report exactly those modifier bits required for any similarly
<i>360</i>&nbsp; * declared method, including in this case {@code native} and {@code varargs} bits.
<i>361</i>&nbsp; * &lt;p&gt;
<i>362</i>&nbsp; * As with any reflected method, these methods (when reflected) may be
<i>363</i>&nbsp; * invoked via {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.
<i>364</i>&nbsp; * However, such reflective calls do not result in method handle invocations.
<i>365</i>&nbsp; * Such a call, if passed the required argument
<i>366</i>&nbsp; * (a single one, of type {@code Object[]}), will ignore the argument and
<i>367</i>&nbsp; * will throw an {@code UnsupportedOperationException}.
<i>368</i>&nbsp; * &lt;p&gt;
<i>369</i>&nbsp; * Since {@code invokevirtual} instructions can natively
<i>370</i>&nbsp; * invoke method handles under any symbolic type descriptor, this reflective view conflicts
<i>371</i>&nbsp; * with the normal presentation of these methods via bytecodes.
<i>372</i>&nbsp; * Thus, these two native methods, when reflectively viewed by
<i>373</i>&nbsp; * {@code Class.getDeclaredMethod}, may be regarded as placeholders only.
<i>374</i>&nbsp; * &lt;p&gt;
<i>375</i>&nbsp; * In order to obtain an invoker method for a particular type descriptor,
<i>376</i>&nbsp; * use {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker},
<i>377</i>&nbsp; * or {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}.
<i>378</i>&nbsp; * The {@link java.lang.invoke.MethodHandles.Lookup#findVirtual Lookup.findVirtual}
<i>379</i>&nbsp; * API is also able to return a method handle
<i>380</i>&nbsp; * to call {@code invokeExact} or plain {@code invoke},
<i>381</i>&nbsp; * for any specified type descriptor .
<i>382</i>&nbsp; *
<i>383</i>&nbsp; * &lt;h1&gt;Interoperation between method handles and Java generics&lt;/h1&gt;
<i>384</i>&nbsp; * A method handle can be obtained on a method, constructor, or field
<i>385</i>&nbsp; * which is declared with Java generic types.
<i>386</i>&nbsp; * As with the Core Reflection API, the type of the method handle
<i>387</i>&nbsp; * will constructed from the erasure of the source-level type.
<i>388</i>&nbsp; * When a method handle is invoked, the types of its arguments
<i>389</i>&nbsp; * or the return value cast type may be generic types or type instances.
<i>390</i>&nbsp; * If this occurs, the compiler will replace those
<i>391</i>&nbsp; * types by their erasures when it constructs the symbolic type descriptor
<i>392</i>&nbsp; * for the {@code invokevirtual} instruction.
<i>393</i>&nbsp; * &lt;p&gt;
<i>394</i>&nbsp; * Method handles do not represent
<i>395</i>&nbsp; * their function-like types in terms of Java parameterized (generic) types,
<i>396</i>&nbsp; * because there are three mismatches between function-like types and parameterized
<i>397</i>&nbsp; * Java types.
<i>398</i>&nbsp; * &lt;ul&gt;
<i>399</i>&nbsp; * &lt;li&gt;Method types range over all possible arities,
<i>400</i>&nbsp; * from no arguments to up to the  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;maximum number&lt;/a&gt; of allowed arguments.
<i>401</i>&nbsp; * Generics are not variadic, and so cannot represent this.&lt;/li&gt;
<i>402</i>&nbsp; * &lt;li&gt;Method types can specify arguments of primitive types,
<i>403</i>&nbsp; * which Java generic types cannot range over.&lt;/li&gt;
<i>404</i>&nbsp; * &lt;li&gt;Higher order functions over method handles (combinators) are
<i>405</i>&nbsp; * often generic across a wide range of function types, including
<i>406</i>&nbsp; * those of multiple arities.  It is impossible to represent such
<i>407</i>&nbsp; * genericity with a Java type parameter.&lt;/li&gt;
<i>408</i>&nbsp; * &lt;/ul&gt;
<i>409</i>&nbsp; *
<i>410</i>&nbsp; * &lt;h1&gt;&lt;a id=&quot;maxarity&quot;&gt;&lt;/a&gt;Arity limits&lt;/h1&gt;
<i>411</i>&nbsp; * The JVM imposes on all methods and constructors of any kind an absolute
<i>412</i>&nbsp; * limit of 255 stacked arguments.  This limit can appear more restrictive
<i>413</i>&nbsp; * in certain cases:
<i>414</i>&nbsp; * &lt;ul&gt;
<i>415</i>&nbsp; * &lt;li&gt;A {@code long} or {@code double} argument counts (for purposes of arity limits) as two argument slots.
<i>416</i>&nbsp; * &lt;li&gt;A non-static method consumes an extra argument for the object on which the method is called.
<i>417</i>&nbsp; * &lt;li&gt;A constructor consumes an extra argument for the object which is being constructed.
<i>418</i>&nbsp; * &lt;li&gt;Since a method handle&amp;rsquo;s {@code invoke} method (or other signature-polymorphic method) is non-virtual,
<i>419</i>&nbsp; *     it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object.
<i>420</i>&nbsp; * &lt;/ul&gt;
<b class="nc"><i>421</i>&nbsp; * These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments.</b>
<b class="nc"><i>422</i>&nbsp; * For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it.</b>
<i>423</i>&nbsp; * Attempts to create method handles with impossible method types lead to an {@link IllegalArgumentException}.
<i>424</i>&nbsp; * In particular, a method handle&amp;rsquo;s type must not have an arity of the exact maximum 255.
<i>425</i>&nbsp; *
<i>426</i>&nbsp; * @see MethodType
<i>427</i>&nbsp; * @see MethodHandles
<i>428</i>&nbsp; * @author John Rose, JSR 292 EG
<i>429</i>&nbsp; * @since 1.7
<i>430</i>&nbsp; */
<i>431</i>&nbsp;public abstract class MethodHandle {
<i>432</i>&nbsp;
<i>433</i>&nbsp;    /**
<i>434</i>&nbsp;     * Internal marker interface which distinguishes (to the Java compiler)
<i>435</i>&nbsp;     * those methods which are &lt;a href=&quot;MethodHandle.html#sigpoly&quot;&gt;signature polymorphic&lt;/a&gt;.
<i>436</i>&nbsp;     */
<i>437</i>&nbsp;    @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
<i>438</i>&nbsp;    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
<i>439</i>&nbsp;    @interface PolymorphicSignature { }
<i>440</i>&nbsp;
<i>441</i>&nbsp;    private final MethodType type;
<i>442</i>&nbsp;    /*private*/ final LambdaForm form;
<i>443</i>&nbsp;    // form is not private so that invokers can easily fetch it
<i>444</i>&nbsp;    /*private*/ MethodHandle asTypeCache;
<i>445</i>&nbsp;    // asTypeCache is not private so that invokers can easily fetch it
<b class="nc"><i>446</i>&nbsp;    /*non-public*/ byte customizationCount;</b>
<i>447</i>&nbsp;    // customizationCount should be accessible from invokers
<i>448</i>&nbsp;
<i>449</i>&nbsp;    /**
<i>450</i>&nbsp;     * Reports the type of this method handle.
<i>451</i>&nbsp;     * Every invocation of this method handle via {@code invokeExact} must exactly match this type.
<i>452</i>&nbsp;     * @return the method handle type
<i>453</i>&nbsp;     */
<i>454</i>&nbsp;    public MethodType type() {
<b class="nc"><i>455</i>&nbsp;        return type;</b>
<b class="nc"><i>456</i>&nbsp;    }</b>
<b class="nc"><i>457</i>&nbsp;</b>
<b class="nc"><i>458</i>&nbsp;    /**</b>
<b class="nc"><i>459</i>&nbsp;     * Package-private constructor for the method handle implementation hierarchy.</b>
<i>460</i>&nbsp;     * Method handle inheritance will be contained completely within
<b class="nc"><i>461</i>&nbsp;     * the {@code java.lang.invoke} package.</b>
<i>462</i>&nbsp;     */
<i>463</i>&nbsp;    // @param type type (permanently assigned) of the new method handle
<i>464</i>&nbsp;    /*non-public*/ MethodHandle(MethodType type, LambdaForm form) {
<i>465</i>&nbsp;        this.type = Objects.requireNonNull(type);
<i>466</i>&nbsp;        this.form = Objects.requireNonNull(form).uncustomize();
<i>467</i>&nbsp;
<i>468</i>&nbsp;        this.form.prepare();  // TO DO:  Try to delay this step until just before invocation.
<i>469</i>&nbsp;    }
<i>470</i>&nbsp;
<i>471</i>&nbsp;    /**
<i>472</i>&nbsp;     * Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match.
<i>473</i>&nbsp;     * The symbolic type descriptor at the call site of {@code invokeExact} must
<i>474</i>&nbsp;     * exactly match this method handle&#39;s {@link #type() type}.
<i>475</i>&nbsp;     * No conversions are allowed on arguments or return values.
<i>476</i>&nbsp;     * &lt;p&gt;
<i>477</i>&nbsp;     * When this method is observed via the Core Reflection API,
<i>478</i>&nbsp;     * it will appear as a single native method, taking an object array and returning an object.
<i>479</i>&nbsp;     * If this native method is invoked directly via
<i>480</i>&nbsp;     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
<i>481</i>&nbsp;     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
<i>482</i>&nbsp;     * it will throw an {@code UnsupportedOperationException}.
<i>483</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>484</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>485</i>&nbsp;     * @throws WrongMethodTypeException if the target&#39;s type is not identical with the caller&#39;s symbolic type descriptor
<i>486</i>&nbsp;     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call
<i>487</i>&nbsp;     */
<i>488</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>489</i>&nbsp;    public final native @PolymorphicSignature Object invokeExact(Object... args) throws Throwable;
<i>490</i>&nbsp;
<i>491</i>&nbsp;    /**
<i>492</i>&nbsp;     * Invokes the method handle, allowing any caller type descriptor,
<i>493</i>&nbsp;     * and optionally performing conversions on arguments and return values.
<i>494</i>&nbsp;     * &lt;p&gt;
<i>495</i>&nbsp;     * If the call site&#39;s symbolic type descriptor exactly matches this method handle&#39;s {@link #type() type},
<i>496</i>&nbsp;     * the call proceeds as if by {@link #invokeExact invokeExact}.
<i>497</i>&nbsp;     * &lt;p&gt;
<i>498</i>&nbsp;     * Otherwise, the call proceeds as if this method handle were first
<i>499</i>&nbsp;     * adjusted by calling {@link #asType asType} to adjust this method handle
<i>500</i>&nbsp;     * to the required type, and then the call proceeds as if by
<i>501</i>&nbsp;     * {@link #invokeExact invokeExact} on the adjusted method handle.
<i>502</i>&nbsp;     * &lt;p&gt;
<i>503</i>&nbsp;     * There is no guarantee that the {@code asType} call is actually made.
<i>504</i>&nbsp;     * If the JVM can predict the results of making the call, it may perform
<i>505</i>&nbsp;     * adaptations directly on the caller&#39;s arguments,
<i>506</i>&nbsp;     * and call the target method handle according to its own exact type.
<i>507</i>&nbsp;     * &lt;p&gt;
<i>508</i>&nbsp;     * The resolved type descriptor at the call site of {@code invoke} must
<i>509</i>&nbsp;     * be a valid argument to the receivers {@code asType} method.
<i>510</i>&nbsp;     * In particular, the caller must specify the same argument arity
<i>511</i>&nbsp;     * as the callee&#39;s type,
<i>512</i>&nbsp;     * if the callee is not a {@linkplain #asVarargsCollector variable arity collector}.
<i>513</i>&nbsp;     * &lt;p&gt;
<i>514</i>&nbsp;     * When this method is observed via the Core Reflection API,
<i>515</i>&nbsp;     * it will appear as a single native method, taking an object array and returning an object.
<i>516</i>&nbsp;     * If this native method is invoked directly via
<i>517</i>&nbsp;     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}, via JNI,
<i>518</i>&nbsp;     * or indirectly via {@link java.lang.invoke.MethodHandles.Lookup#unreflect Lookup.unreflect},
<i>519</i>&nbsp;     * it will throw an {@code UnsupportedOperationException}.
<i>520</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>521</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>522</i>&nbsp;     * @throws WrongMethodTypeException if the target&#39;s type cannot be adjusted to the caller&#39;s symbolic type descriptor
<i>523</i>&nbsp;     * @throws ClassCastException if the target&#39;s type can be adjusted to the caller, but a reference cast fails
<i>524</i>&nbsp;     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call
<i>525</i>&nbsp;     */
<i>526</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>527</i>&nbsp;    public final native @PolymorphicSignature Object invoke(Object... args) throws Throwable;
<i>528</i>&nbsp;
<i>529</i>&nbsp;    /**
<i>530</i>&nbsp;     * Private method for trusted invocation of a method handle respecting simplified signatures.
<i>531</i>&nbsp;     * Type mismatches will not throw {@code WrongMethodTypeException}, but could crash the JVM.
<i>532</i>&nbsp;     * &lt;p&gt;
<i>533</i>&nbsp;     * The caller signature is restricted to the following basic types:
<i>534</i>&nbsp;     * Object, int, long, float, double, and void return.
<i>535</i>&nbsp;     * &lt;p&gt;
<i>536</i>&nbsp;     * The caller is responsible for maintaining type correctness by ensuring
<i>537</i>&nbsp;     * that the each outgoing argument value is a member of the range of the corresponding
<i>538</i>&nbsp;     * callee argument type.
<i>539</i>&nbsp;     * (The caller should therefore issue appropriate casts and integer narrowing
<i>540</i>&nbsp;     * operations on outgoing argument values.)
<i>541</i>&nbsp;     * The caller can assume that the incoming result value is part of the range
<i>542</i>&nbsp;     * of the callee&#39;s return type.
<i>543</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>544</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>545</i>&nbsp;     */
<i>546</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>547</i>&nbsp;    /*non-public*/ final native @PolymorphicSignature Object invokeBasic(Object... args) throws Throwable;
<i>548</i>&nbsp;
<i>549</i>&nbsp;    /**
<i>550</i>&nbsp;     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeVirtual}.
<i>551</i>&nbsp;     * The caller signature is restricted to basic types as with {@code invokeBasic}.
<i>552</i>&nbsp;     * The trailing (not leading) argument must be a MemberName.
<i>553</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>554</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>555</i>&nbsp;     */
<i>556</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>557</i>&nbsp;    /*non-public*/ static native @PolymorphicSignature Object linkToVirtual(Object... args) throws Throwable;
<i>558</i>&nbsp;
<i>559</i>&nbsp;    /**
<i>560</i>&nbsp;     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeStatic}.
<i>561</i>&nbsp;     * The caller signature is restricted to basic types as with {@code invokeBasic}.
<i>562</i>&nbsp;     * The trailing (not leading) argument must be a MemberName.
<i>563</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>564</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>565</i>&nbsp;     */
<i>566</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>567</i>&nbsp;    /*non-public*/ static native @PolymorphicSignature Object linkToStatic(Object... args) throws Throwable;
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /**
<i>570</i>&nbsp;     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeSpecial}.
<i>571</i>&nbsp;     * The caller signature is restricted to basic types as with {@code invokeBasic}.
<i>572</i>&nbsp;     * The trailing (not leading) argument must be a MemberName.
<i>573</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>574</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>575</i>&nbsp;     */
<i>576</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>577</i>&nbsp;    /*non-public*/ static native @PolymorphicSignature Object linkToSpecial(Object... args) throws Throwable;
<i>578</i>&nbsp;
<i>579</i>&nbsp;    /**
<i>580</i>&nbsp;     * Private method for trusted invocation of a MemberName of kind {@code REF_invokeInterface}.
<i>581</i>&nbsp;     * The caller signature is restricted to basic types as with {@code invokeBasic}.
<i>582</i>&nbsp;     * The trailing (not leading) argument must be a MemberName.
<i>583</i>&nbsp;     * @param args the signature-polymorphic parameter list, statically represented using varargs
<i>584</i>&nbsp;     * @return the signature-polymorphic result, statically represented using {@code Object}
<i>585</i>&nbsp;     */
<i>586</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>587</i>&nbsp;    /*non-public*/ static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;
<i>588</i>&nbsp;
<i>589</i>&nbsp;    /**
<i>590</i>&nbsp;     * Performs a variable arity invocation, passing the arguments in the given array
<i>591</i>&nbsp;     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
<i>592</i>&nbsp;     * which mentions only the type {@code Object}, and whose actual argument count is the length
<i>593</i>&nbsp;     * of the argument array.
<i>594</i>&nbsp;     * &lt;p&gt;
<i>595</i>&nbsp;     * Specifically, execution proceeds as if by the following steps,
<i>596</i>&nbsp;     * although the methods are not guaranteed to be called if the JVM
<i>597</i>&nbsp;     * can predict their effects.
<i>598</i>&nbsp;     * &lt;ul&gt;
<i>599</i>&nbsp;     * &lt;li&gt;Determine the length of the argument array as {@code N}.
<i>600</i>&nbsp;     *     For a null reference, {@code N=0}. &lt;/li&gt;
<i>601</i>&nbsp;     * &lt;li&gt;Collect the {@code N} elements of the array as a logical
<i>602</i>&nbsp;     *     argument list, each argument statically typed as an {@code Object}. &lt;/li&gt;
<i>603</i>&nbsp;     * &lt;li&gt;Determine, as {@code M}, the parameter count of the type of this
<i>604</i>&nbsp;     *     method handle. &lt;/li&gt;
<i>605</i>&nbsp;     * &lt;li&gt;Determine the general type {@code TN} of {@code N} arguments or
<i>606</i>&nbsp;     *     {@code M} arguments, if smaller than {@code N}, as
<i>607</i>&nbsp;     *     {@code TN=MethodType.genericMethodType(Math.min(N, M))}.&lt;/li&gt;
<i>608</i>&nbsp;     * &lt;li&gt;If {@code N} is greater than {@code M}, perform the following
<i>609</i>&nbsp;     *     checks and actions to shorten the logical argument list: &lt;ul&gt;
<i>610</i>&nbsp;     *     &lt;li&gt;Check that this method handle has variable arity with a
<i>611</i>&nbsp;     *         {@linkplain MethodType#lastParameterType trailing parameter}
<i>612</i>&nbsp;     *         of some array type {@code A[]}.  If not, fail with a
<i>613</i>&nbsp;     *         {@code WrongMethodTypeException}. &lt;/li&gt;
<i>614</i>&nbsp;     *     &lt;li&gt;Collect the trailing elements (there are {@code N-M+1} of them)
<i>615</i>&nbsp;     *         from the logical argument list into a single array of
<i>616</i>&nbsp;     *         type {@code A[]}, using {@code asType} conversions to
<i>617</i>&nbsp;     *         convert each trailing argument to type {@code A}. &lt;/li&gt;
<i>618</i>&nbsp;     *     &lt;li&gt;If any of these conversions proves impossible, fail with either
<i>619</i>&nbsp;     *         a {@code ClassCastException} if any trailing element cannot be
<i>620</i>&nbsp;     *         cast to {@code A} or a {@code NullPointerException} if any
<i>621</i>&nbsp;     *         trailing element is {@code null} and {@code A} is not a reference
<i>622</i>&nbsp;     *         type. &lt;/li&gt;
<i>623</i>&nbsp;     *     &lt;li&gt;Replace the logical arguments gathered into the array of
<i>624</i>&nbsp;     *         type {@code A[]} with the array itself, thus shortening
<i>625</i>&nbsp;     *         the argument list to length {@code M}. This final argument
<b class="nc"><i>626</i>&nbsp;     *         retains the static type {@code A[]}.&lt;/li&gt;</b>
<b class="nc"><i>627</i>&nbsp;     *     &lt;li&gt;Adjust the type {@code TN} by changing the {@code N}th</b>
<i>628</i>&nbsp;     *         parameter type from {@code Object} to {@code A[]}.
<i>629</i>&nbsp;     *     &lt;/ul&gt;
<i>630</i>&nbsp;     * &lt;li&gt;Force the original target method handle {@code MH0} to the
<i>631</i>&nbsp;     *     required type, as {@code MH1 = MH0.asType(TN)}. &lt;/li&gt;
<i>632</i>&nbsp;     * &lt;li&gt;Spread the argument list into {@code N} separate arguments {@code A0, ...}. &lt;/li&gt;
<i>633</i>&nbsp;     * &lt;li&gt;Invoke the type-adjusted method handle on the unpacked arguments:
<i>634</i>&nbsp;     *     MH1.invokeExact(A0, ...). &lt;/li&gt;
<i>635</i>&nbsp;     * &lt;li&gt;Take the return value as an {@code Object} reference. &lt;/li&gt;
<i>636</i>&nbsp;     * &lt;/ul&gt;
<i>637</i>&nbsp;     * &lt;p&gt;
<i>638</i>&nbsp;     * If the target method handle has variable arity, and the argument list is longer
<i>639</i>&nbsp;     * than that arity, the excess arguments, starting at the position of the trailing
<i>640</i>&nbsp;     * array argument, will be gathered (if possible, as if by {@code asType} conversions)
<i>641</i>&nbsp;     * into an array of the appropriate type, and invocation will proceed on the
<i>642</i>&nbsp;     * shortened argument list.
<i>643</i>&nbsp;     * In this way, &lt;em&gt;jumbo argument lists&lt;/em&gt; which would spread into more
<i>644</i>&nbsp;     * than 254 slots can still be processed uniformly.
<i>645</i>&nbsp;     * &lt;p&gt;
<i>646</i>&nbsp;     * Unlike the {@link #invoke(Object...) generic} invocation mode, which can
<i>647</i>&nbsp;     * &quot;recycle&quot; an array argument, passing it directly to the target method,
<i>648</i>&nbsp;     * this invocation mode &lt;em&gt;always&lt;/em&gt; creates a new array parameter, even
<b class="nc"><i>649</i>&nbsp;     * if the original array passed to {@code invokeWithArguments} would have</b>
<i>650</i>&nbsp;     * been acceptable as a direct argument to the target method.
<i>651</i>&nbsp;     * Even if the number {@code M} of actual arguments is the arity {@code N},
<i>652</i>&nbsp;     * and the last argument is dynamically a suitable array of type {@code A[]},
<i>653</i>&nbsp;     * it will still be boxed into a new one-element array, since the call
<i>654</i>&nbsp;     * site statically types the argument as {@code Object}, not an array type.
<i>655</i>&nbsp;     * This is not a special rule for this method, but rather a regular effect
<i>656</i>&nbsp;     * of the {@linkplain #asVarargsCollector rules for variable-arity invocation}.
<i>657</i>&nbsp;     * &lt;p&gt;
<i>658</i>&nbsp;     * Because of the action of the {@code asType} step, the following argument
<i>659</i>&nbsp;     * conversions are applied as necessary:
<i>660</i>&nbsp;     * &lt;ul&gt;
<i>661</i>&nbsp;     * &lt;li&gt;reference casting
<i>662</i>&nbsp;     * &lt;li&gt;unboxing
<i>663</i>&nbsp;     * &lt;li&gt;widening primitive conversions
<i>664</i>&nbsp;     * &lt;li&gt;variable arity conversion
<i>665</i>&nbsp;     * &lt;/ul&gt;
<i>666</i>&nbsp;     * &lt;p&gt;
<i>667</i>&nbsp;     * The result returned by the call is boxed if it is a primitive,
<i>668</i>&nbsp;     * or forced to null if the return type is void.
<i>669</i>&nbsp;     * &lt;p&gt;
<i>670</i>&nbsp;     * Unlike the signature polymorphic methods {@code invokeExact} and {@code invoke},
<i>671</i>&nbsp;     * {@code invokeWithArguments} can be accessed normally via the Core Reflection API and JNI.
<i>672</i>&nbsp;     * It can therefore be used as a bridge between native or reflective code and method handles.
<i>673</i>&nbsp;     * @apiNote
<i>674</i>&nbsp;     * This call is approximately equivalent to the following code:
<i>675</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>676</i>&nbsp;     * // for jumbo argument lists, adapt varargs explicitly:
<i>677</i>&nbsp;     * int N = (arguments == null? 0: arguments.length);
<i>678</i>&nbsp;     * int M = this.type.parameterCount();
<i>679</i>&nbsp;     * int MAX_SAFE = 127;  // 127 longs require 254 slots, which is OK
<i>680</i>&nbsp;     * if (N &gt; MAX_SAFE &amp;&amp; N &gt; M &amp;&amp; this.isVarargsCollector()) {
<i>681</i>&nbsp;     *   Class&lt;?&gt; arrayType = this.type().lastParameterType();
<i>682</i>&nbsp;     *   Class&lt;?&gt; elemType = arrayType.getComponentType();
<i>683</i>&nbsp;     *   if (elemType != null) {
<i>684</i>&nbsp;     *     Object args2 = Array.newInstance(elemType, M);
<i>685</i>&nbsp;     *     MethodHandle arraySetter = MethodHandles.arrayElementSetter(arrayType);
<i>686</i>&nbsp;     *     for (int i = 0; i &lt; M; i++) {
<i>687</i>&nbsp;     *       arraySetter.invoke(args2, i, arguments[M-1 + i]);
<i>688</i>&nbsp;     *     }
<i>689</i>&nbsp;     *     arguments = Arrays.copyOf(arguments, M);
<i>690</i>&nbsp;     *     arguments[M-1] = args2;
<i>691</i>&nbsp;     *     return this.asFixedArity().invokeWithArguments(arguments);
<i>692</i>&nbsp;     *   }
<i>693</i>&nbsp;     * } // done with explicit varargs processing
<i>694</i>&nbsp;     *
<i>695</i>&nbsp;     * // Handle fixed arity and non-jumbo variable arity invocation.
<i>696</i>&nbsp;     * MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);
<i>697</i>&nbsp;     * Object result = invoker.invokeExact(this, arguments);
<i>698</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>699</i>&nbsp;     *
<i>700</i>&nbsp;     * @param arguments the arguments to pass to the target
<i>701</i>&nbsp;     * @return the result returned by the target
<i>702</i>&nbsp;     * @throws ClassCastException if an argument cannot be converted by reference casting
<i>703</i>&nbsp;     * @throws WrongMethodTypeException if the target&#39;s type cannot be adjusted to take the given number of {@code Object} arguments
<i>704</i>&nbsp;     * @throws Throwable anything thrown by the target method invocation
<i>705</i>&nbsp;     * @see MethodHandles#spreadInvoker
<i>706</i>&nbsp;     */
<i>707</i>&nbsp;    public Object invokeWithArguments(Object... arguments) throws Throwable {
<i>708</i>&nbsp;        // Note: Jumbo argument lists are handled in the variable-arity subclass.
<i>709</i>&nbsp;        MethodType invocationType = MethodType.genericMethodType(arguments == null ? 0 : arguments.length);
<i>710</i>&nbsp;        return invocationType.invokers().spreadInvoker(0).invokeExact(asType(invocationType), arguments);
<i>711</i>&nbsp;    }
<i>712</i>&nbsp;
<i>713</i>&nbsp;    /**
<i>714</i>&nbsp;     * Performs a variable arity invocation, passing the arguments in the given list
<i>715</i>&nbsp;     * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
<i>716</i>&nbsp;     * which mentions only the type {@code Object}, and whose actual argument count is the length
<i>717</i>&nbsp;     * of the argument list.
<i>718</i>&nbsp;     * &lt;p&gt;
<i>719</i>&nbsp;     * This method is also equivalent to the following code:
<i>720</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>721</i>&nbsp;     *   invokeWithArguments(arguments.toArray())
<i>722</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>723</i>&nbsp;     * &lt;p&gt;
<i>724</i>&nbsp;     * Jumbo-sized lists are acceptable if this method handle has variable arity.
<i>725</i>&nbsp;     * See {@link #invokeWithArguments(Object[])} for details.
<i>726</i>&nbsp;     *
<i>727</i>&nbsp;     * @param arguments the arguments to pass to the target
<i>728</i>&nbsp;     * @return the result returned by the target
<i>729</i>&nbsp;     * @throws NullPointerException if {@code arguments} is a null reference
<i>730</i>&nbsp;     * @throws ClassCastException if an argument cannot be converted by reference casting
<i>731</i>&nbsp;     * @throws WrongMethodTypeException if the target&#39;s type cannot be adjusted to take the given number of {@code Object} arguments
<i>732</i>&nbsp;     * @throws Throwable anything thrown by the target method invocation
<i>733</i>&nbsp;     */
<i>734</i>&nbsp;    public Object invokeWithArguments(java.util.List&lt;?&gt; arguments) throws Throwable {
<i>735</i>&nbsp;        return invokeWithArguments(arguments.toArray());
<i>736</i>&nbsp;    }
<i>737</i>&nbsp;
<i>738</i>&nbsp;    /**
<i>739</i>&nbsp;     * Produces an adapter method handle which adapts the type of the
<i>740</i>&nbsp;     * current method handle to a new type.
<i>741</i>&nbsp;     * The resulting method handle is guaranteed to report a type
<i>742</i>&nbsp;     * which is equal to the desired new type.
<i>743</i>&nbsp;     * &lt;p&gt;
<i>744</i>&nbsp;     * If the original type and new type are equal, returns {@code this}.
<i>745</i>&nbsp;     * &lt;p&gt;
<i>746</i>&nbsp;     * The new method handle, when invoked, will perform the following
<i>747</i>&nbsp;     * steps:
<i>748</i>&nbsp;     * &lt;ul&gt;
<i>749</i>&nbsp;     * &lt;li&gt;Convert the incoming argument list to match the original
<i>750</i>&nbsp;     *     method handle&#39;s argument list.
<i>751</i>&nbsp;     * &lt;li&gt;Invoke the original method handle on the converted argument list.
<i>752</i>&nbsp;     * &lt;li&gt;Convert any result returned by the original method handle
<b class="nc"><i>753</i>&nbsp;     *     to the return type of new method handle.</b>
<b class="nc"><i>754</i>&nbsp;     * &lt;/ul&gt;</b>
<i>755</i>&nbsp;     * &lt;p&gt;
<i>756</i>&nbsp;     * This method provides the crucial behavioral difference between
<b class="nc"><i>757</i>&nbsp;     * {@link #invokeExact invokeExact} and plain, inexact {@link #invoke invoke}.</b>
<b class="nc"><i>758</i>&nbsp;     * The two methods</b>
<b class="nc"><i>759</i>&nbsp;     * perform the same steps when the caller&#39;s type descriptor exactly matches</b>
<i>760</i>&nbsp;     * the callee&#39;s, but when the types differ, plain {@link #invoke invoke}
<b class="nc"><i>761</i>&nbsp;     * also calls {@code asType} (or some internal equivalent) in order</b>
<i>762</i>&nbsp;     * to match up the caller&#39;s and callee&#39;s types.
<i>763</i>&nbsp;     * &lt;p&gt;
<i>764</i>&nbsp;     * If the current method is a variable arity method handle
<b class="nc"><i>765</i>&nbsp;     * argument list conversion may involve the conversion and collection</b>
<b class="nc"><i>766</i>&nbsp;     * of several arguments into an array, as</b>
<b class="nc"><i>767</i>&nbsp;     * {@linkplain #asVarargsCollector described elsewhere}.</b>
<i>768</i>&nbsp;     * In every other case, all conversions are applied &lt;em&gt;pairwise&lt;/em&gt;,
<b class="nc"><i>769</i>&nbsp;     * which means that each argument or return value is converted to</b>
<i>770</i>&nbsp;     * exactly one argument or return value (or no return value).
<i>771</i>&nbsp;     * The applied conversions are defined by consulting
<i>772</i>&nbsp;     * the corresponding component types of the old and new
<i>773</i>&nbsp;     * method handle types.
<b class="nc"><i>774</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>775</i>&nbsp;     * Let &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; be corresponding new and old parameter types,</b>
<b class="nc"><i>776</i>&nbsp;     * or old and new return types.  Specifically, for some valid index {@code i}, let</b>
<i>777</i>&nbsp;     * &lt;em&gt;T0&lt;/em&gt;{@code =newType.parameterType(i)} and &lt;em&gt;T1&lt;/em&gt;{@code =this.type().parameterType(i)}.
<i>778</i>&nbsp;     * Or else, going the other way for return values, let
<i>779</i>&nbsp;     * &lt;em&gt;T0&lt;/em&gt;{@code =this.type().returnType()} and &lt;em&gt;T1&lt;/em&gt;{@code =newType.returnType()}.
<i>780</i>&nbsp;     * If the types are the same, the new method handle makes no change
<i>781</i>&nbsp;     * to the corresponding argument or return value (if any).
<i>782</i>&nbsp;     * Otherwise, one of the following conversions is applied
<i>783</i>&nbsp;     * if possible:
<i>784</i>&nbsp;     * &lt;ul&gt;
<i>785</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, then a cast to &lt;em&gt;T1&lt;/em&gt; is applied.
<i>786</i>&nbsp;     *     (The types do not need to be related in any particular way.
<i>787</i>&nbsp;     *     This is because a dynamic value of null can convert to any reference type.)
<i>788</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives, then a Java method invocation
<i>789</i>&nbsp;     *     conversion (JLS 5.3) is applied, if one exists.
<i>790</i>&nbsp;     *     (Specifically, &lt;em&gt;T0&lt;/em&gt; must convert to &lt;em&gt;T1&lt;/em&gt; by a widening primitive conversion.)
<i>791</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a primitive and &lt;em&gt;T1&lt;/em&gt; a reference,
<i>792</i>&nbsp;     *     a Java casting conversion (JLS 5.5) is applied if one exists.
<i>793</i>&nbsp;     *     (Specifically, the value is boxed from &lt;em&gt;T0&lt;/em&gt; to its wrapper class,
<i>794</i>&nbsp;     *     which is then widened as needed to &lt;em&gt;T1&lt;/em&gt;.)
<i>795</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
<i>796</i>&nbsp;     *     conversion will be applied at runtime, possibly followed
<i>797</i>&nbsp;     *     by a Java method invocation conversion (JLS 5.3)
<i>798</i>&nbsp;     *     on the primitive value.  (These are the primitive widening conversions.)
<i>799</i>&nbsp;     *     &lt;em&gt;T0&lt;/em&gt; must be a wrapper class or a supertype of one.
<i>800</i>&nbsp;     *     (In the case where &lt;em&gt;T0&lt;/em&gt; is Object, these are the conversions
<i>801</i>&nbsp;     *     allowed by {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}.)
<i>802</i>&nbsp;     *     The unboxing conversion must have a possibility of success, which means that
<i>803</i>&nbsp;     *     if &lt;em&gt;T0&lt;/em&gt; is not itself a wrapper class, there must exist at least one
<i>804</i>&nbsp;     *     wrapper class &lt;em&gt;TW&lt;/em&gt; which is a subtype of &lt;em&gt;T0&lt;/em&gt; and whose unboxed
<i>805</i>&nbsp;     *     primitive value can be widened to &lt;em&gt;T1&lt;/em&gt;.
<i>806</i>&nbsp;     * &lt;li&gt;If the return type &lt;em&gt;T1&lt;/em&gt; is marked as void, any returned value is discarded
<i>807</i>&nbsp;     * &lt;li&gt;If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a reference, a null value is introduced.
<i>808</i>&nbsp;     * &lt;li&gt;If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a primitive,
<i>809</i>&nbsp;     *     a zero value is introduced.
<i>810</i>&nbsp;     * &lt;/ul&gt;
<i>811</i>&nbsp;     * (&lt;em&gt;Note:&lt;/em&gt; Both &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; may be regarded as static types,
<i>812</i>&nbsp;     * because neither corresponds specifically to the &lt;em&gt;dynamic type&lt;/em&gt; of any
<i>813</i>&nbsp;     * actual argument or return value.)
<i>814</i>&nbsp;     * &lt;p&gt;
<i>815</i>&nbsp;     * The method handle conversion cannot be made if any one of the required
<i>816</i>&nbsp;     * pairwise conversions cannot be made.
<i>817</i>&nbsp;     * &lt;p&gt;
<i>818</i>&nbsp;     * At runtime, the conversions applied to reference arguments
<i>819</i>&nbsp;     * or return values may require additional runtime checks which can fail.
<i>820</i>&nbsp;     * An unboxing operation may fail because the original reference is null,
<i>821</i>&nbsp;     * causing a {@link java.lang.NullPointerException NullPointerException}.
<i>822</i>&nbsp;     * An unboxing operation or a reference cast may also fail on a reference
<i>823</i>&nbsp;     * to an object of the wrong type,
<i>824</i>&nbsp;     * causing a {@link java.lang.ClassCastException ClassCastException}.
<i>825</i>&nbsp;     * Although an unboxing operation may accept several kinds of wrappers,
<i>826</i>&nbsp;     * if none are available, a {@code ClassCastException} will be thrown.
<i>827</i>&nbsp;     *
<i>828</i>&nbsp;     * @param newType the expected type of the new method handle
<i>829</i>&nbsp;     * @return a method handle which delegates to {@code this} after performing
<i>830</i>&nbsp;     *           any necessary argument conversions, and arranges for any
<i>831</i>&nbsp;     *           necessary return value conversions
<i>832</i>&nbsp;     * @throws NullPointerException if {@code newType} is a null reference
<i>833</i>&nbsp;     * @throws WrongMethodTypeException if the conversion cannot be made
<i>834</i>&nbsp;     * @see MethodHandles#explicitCastArguments
<i>835</i>&nbsp;     */
<i>836</i>&nbsp;    public MethodHandle asType(MethodType newType) {
<i>837</i>&nbsp;        // Fast path alternative to a heavyweight {@code asType} call.
<i>838</i>&nbsp;        // Return &#39;this&#39; if the conversion will be a no-op.
<i>839</i>&nbsp;        if (newType == type) {
<i>840</i>&nbsp;            return this;
<i>841</i>&nbsp;        }
<i>842</i>&nbsp;        // Return &#39;this.asTypeCache&#39; if the conversion is already memoized.
<i>843</i>&nbsp;        MethodHandle atc = asTypeCached(newType);
<i>844</i>&nbsp;        if (atc != null) {
<i>845</i>&nbsp;            return atc;
<i>846</i>&nbsp;        }
<i>847</i>&nbsp;        return asTypeUncached(newType);
<i>848</i>&nbsp;    }
<i>849</i>&nbsp;
<i>850</i>&nbsp;    private MethodHandle asTypeCached(MethodType newType) {
<i>851</i>&nbsp;        MethodHandle atc = asTypeCache;
<i>852</i>&nbsp;        if (atc != null &amp;&amp; newType == atc.type) {
<i>853</i>&nbsp;            return atc;
<i>854</i>&nbsp;        }
<i>855</i>&nbsp;        return null;
<i>856</i>&nbsp;    }
<i>857</i>&nbsp;
<i>858</i>&nbsp;    /** Override this to change asType behavior. */
<i>859</i>&nbsp;    /*non-public*/ MethodHandle asTypeUncached(MethodType newType) {
<i>860</i>&nbsp;        if (!type.isConvertibleTo(newType))
<i>861</i>&nbsp;            throw new WrongMethodTypeException(&quot;cannot convert &quot;+this+&quot; to &quot;+newType);
<i>862</i>&nbsp;        return asTypeCache = MethodHandleImpl.makePairwiseConvert(this, newType, true);
<i>863</i>&nbsp;    }
<i>864</i>&nbsp;
<i>865</i>&nbsp;    /**
<i>866</i>&nbsp;     * Makes an &lt;em&gt;array-spreading&lt;/em&gt; method handle, which accepts a trailing array argument
<i>867</i>&nbsp;     * and spreads its elements as positional arguments.
<i>868</i>&nbsp;     * The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
<b class="nc"><i>869</i>&nbsp;     * the current method handle.  The type of the adapter will be</b>
<b class="nc"><i>870</i>&nbsp;     * the same as the type of the target, except that the final</b>
<b class="nc"><i>871</i>&nbsp;     * {@code arrayLength} parameters of the target&#39;s type are replaced</b>
<b class="nc"><i>872</i>&nbsp;     * by a single array parameter of type {@code arrayType}.</b>
<b class="nc"><i>873</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>874</i>&nbsp;     * If the array element type differs from any of the corresponding</b>
<b class="nc"><i>875</i>&nbsp;     * argument types on the original target,</b>
<b class="nc"><i>876</i>&nbsp;     * the original target is adapted to take the array elements directly,</b>
<i>877</i>&nbsp;     * as if by a call to {@link #asType asType}.
<i>878</i>&nbsp;     * &lt;p&gt;
<i>879</i>&nbsp;     * When called, the adapter replaces a trailing array argument
<i>880</i>&nbsp;     * by the array&#39;s elements, each as its own argument to the target.
<i>881</i>&nbsp;     * (The order of the arguments is preserved.)
<i>882</i>&nbsp;     * They are converted pairwise by casting and/or unboxing
<i>883</i>&nbsp;     * to the types of the trailing parameters of the target.
<b class="nc"><i>884</i>&nbsp;     * Finally the target is called.</b>
<b class="nc"><i>885</i>&nbsp;     * What the target eventually returns is returned unchanged by the adapter.</b>
<b class="nc"><i>886</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>887</i>&nbsp;     * Before calling the target, the adapter verifies that the array</b>
<b class="nc"><i>888</i>&nbsp;     * contains exactly enough elements to provide a correct argument count</b>
<b class="nc"><i>889</i>&nbsp;     * to the target method handle.</b>
<b class="nc"><i>890</i>&nbsp;     * (The array may also be null when zero elements are required.)</b>
<b class="nc"><i>891</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>892</i>&nbsp;     * When the adapter is called, the length of the supplied {@code array}</b>
<b class="nc"><i>893</i>&nbsp;     * argument is queried as if by {@code array.length} or {@code arraylength}</b>
<b class="nc"><i>894</i>&nbsp;     * bytecode. If the adapter accepts a zero-length trailing array argument,</b>
<b class="nc"><i>895</i>&nbsp;     * the supplied {@code array} argument can either be a zero-length array or</b>
<b class="nc"><i>896</i>&nbsp;     * {@code null}; otherwise, the adapter will throw a {@code NullPointerException}</b>
<b class="nc"><i>897</i>&nbsp;     * if the array is {@code null} and throw an {@link IllegalArgumentException}</b>
<i>898</i>&nbsp;     * if the array does not have the correct number of elements.
<i>899</i>&nbsp;     * &lt;p&gt;
<i>900</i>&nbsp;     * Here are some simple examples of array-spreading method handles:
<b class="nc"><i>901</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<b class="nc"><i>902</i>&nbsp;MethodHandle equals = publicLookup()</b>
<b class="nc"><i>903</i>&nbsp;  .findVirtual(String.class, &quot;equals&quot;, methodType(boolean.class, Object.class));</b>
<i>904</i>&nbsp;assert( (boolean) equals.invokeExact(&quot;me&quot;, (Object)&quot;me&quot;));
<b class="nc"><i>905</i>&nbsp;assert(!(boolean) equals.invokeExact(&quot;me&quot;, (Object)&quot;thee&quot;));</b>
<b class="nc"><i>906</i>&nbsp;// spread both arguments from a 2-array:</b>
<i>907</i>&nbsp;MethodHandle eq2 = equals.asSpreader(Object[].class, 2);
<i>908</i>&nbsp;assert( (boolean) eq2.invokeExact(new Object[]{ &quot;me&quot;, &quot;me&quot; }));
<i>909</i>&nbsp;assert(!(boolean) eq2.invokeExact(new Object[]{ &quot;me&quot;, &quot;thee&quot; }));
<b class="nc"><i>910</i>&nbsp;// try to spread from anything but a 2-array:</b>
<b class="nc"><i>911</i>&nbsp;for (int n = 0; n &lt;= 10; n++) {</b>
<b class="nc"><i>912</i>&nbsp;  Object[] badArityArgs = (n == 2 ? new Object[0] : new Object[n]);</b>
<b class="nc"><i>913</i>&nbsp;  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }</b>
<b class="nc"><i>914</i>&nbsp;  catch (IllegalArgumentException ex) { } // OK</b>
<b class="nc"><i>915</i>&nbsp;}</b>
<b class="nc"><i>916</i>&nbsp;// spread both arguments from a String array:</b>
<b class="nc"><i>917</i>&nbsp;MethodHandle eq2s = equals.asSpreader(String[].class, 2);</b>
<i>918</i>&nbsp;assert( (boolean) eq2s.invokeExact(new String[]{ &quot;me&quot;, &quot;me&quot; }));
<b class="nc"><i>919</i>&nbsp;assert(!(boolean) eq2s.invokeExact(new String[]{ &quot;me&quot;, &quot;thee&quot; }));</b>
<i>920</i>&nbsp;// spread second arguments from a 1-array:
<i>921</i>&nbsp;MethodHandle eq1 = equals.asSpreader(Object[].class, 1);
<i>922</i>&nbsp;assert( (boolean) eq1.invokeExact(&quot;me&quot;, new Object[]{ &quot;me&quot; }));
<i>923</i>&nbsp;assert(!(boolean) eq1.invokeExact(&quot;me&quot;, new Object[]{ &quot;thee&quot; }));
<i>924</i>&nbsp;// spread no arguments from a 0-array or null:
<i>925</i>&nbsp;MethodHandle eq0 = equals.asSpreader(Object[].class, 0);
<i>926</i>&nbsp;assert( (boolean) eq0.invokeExact(&quot;me&quot;, (Object)&quot;me&quot;, new Object[0]));
<i>927</i>&nbsp;assert(!(boolean) eq0.invokeExact(&quot;me&quot;, (Object)&quot;thee&quot;, (Object[])null));
<i>928</i>&nbsp;// asSpreader and asCollector are approximate inverses:
<i>929</i>&nbsp;for (int n = 0; n &lt;= 2; n++) {
<i>930</i>&nbsp;    for (Class&lt;?&gt; a : new Class&lt;?&gt;[]{Object[].class, String[].class, CharSequence[].class}) {
<i>931</i>&nbsp;        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);
<i>932</i>&nbsp;        assert( (boolean) equals2.invokeWithArguments(&quot;me&quot;, &quot;me&quot;));
<i>933</i>&nbsp;        assert(!(boolean) equals2.invokeWithArguments(&quot;me&quot;, &quot;thee&quot;));
<i>934</i>&nbsp;    }
<i>935</i>&nbsp;}
<i>936</i>&nbsp;MethodHandle caToString = publicLookup()
<i>937</i>&nbsp;  .findStatic(Arrays.class, &quot;toString&quot;, methodType(String.class, char[].class));
<i>938</i>&nbsp;assertEquals(&quot;[A, B, C]&quot;, (String) caToString.invokeExact(&quot;ABC&quot;.toCharArray()));
<i>939</i>&nbsp;MethodHandle caString3 = caToString.asCollector(char[].class, 3);
<i>940</i>&nbsp;assertEquals(&quot;[A, B, C]&quot;, (String) caString3.invokeExact(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;));
<i>941</i>&nbsp;MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);
<i>942</i>&nbsp;assertEquals(&quot;[A, B, C]&quot;, (String) caToString2.invokeExact(&#39;A&#39;, &quot;BC&quot;.toCharArray()));
<i>943</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>944</i>&nbsp;     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments
<i>945</i>&nbsp;     * @param arrayLength the number of arguments to spread from an incoming array argument
<i>946</i>&nbsp;     * @return a new method handle which spreads its final array argument,
<i>947</i>&nbsp;     *         before calling the original method handle
<i>948</i>&nbsp;     * @throws NullPointerException if {@code arrayType} is a null reference
<i>949</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayType} is not an array type,
<i>950</i>&nbsp;     *         or if target does not have at least
<i>951</i>&nbsp;     *         {@code arrayLength} parameter types,
<i>952</i>&nbsp;     *         or if {@code arrayLength} is negative,
<i>953</i>&nbsp;     *         or if the resulting method handle&#39;s type would have
<i>954</i>&nbsp;     *         &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>955</i>&nbsp;     * @throws WrongMethodTypeException if the implied {@code asType} call fails
<i>956</i>&nbsp;     * @see #asCollector
<i>957</i>&nbsp;     */
<i>958</i>&nbsp;    public MethodHandle asSpreader(Class&lt;?&gt; arrayType, int arrayLength) {
<i>959</i>&nbsp;        return asSpreader(type().parameterCount() - arrayLength, arrayType, arrayLength);
<i>960</i>&nbsp;    }
<i>961</i>&nbsp;
<i>962</i>&nbsp;    /**
<i>963</i>&nbsp;     * Makes an &lt;em&gt;array-spreading&lt;/em&gt; method handle, which accepts an array argument at a given position and spreads
<i>964</i>&nbsp;     * its elements as positional arguments in place of the array. The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
<i>965</i>&nbsp;     * the current method handle. The type of the adapter will be the same as the type of the target, except that the
<i>966</i>&nbsp;     * {@code arrayLength} parameters of the target&#39;s type, starting at the zero-based position {@code spreadArgPos},
<i>967</i>&nbsp;     * are replaced by a single array parameter of type {@code arrayType}.
<i>968</i>&nbsp;     * &lt;p&gt;
<i>969</i>&nbsp;     * This method behaves very much like {@link #asSpreader(Class, int)}, but accepts an additional {@code spreadArgPos}
<i>970</i>&nbsp;     * argument to indicate at which position in the parameter list the spreading should take place.
<i>971</i>&nbsp;     *
<i>972</i>&nbsp;     * @apiNote Example:
<i>973</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>974</i>&nbsp;    MethodHandle compare = LOOKUP.findStatic(Objects.class, &quot;compare&quot;, methodType(int.class, Object.class, Object.class, Comparator.class));
<i>975</i>&nbsp;    MethodHandle compare2FromArray = compare.asSpreader(0, Object[].class, 2);
<i>976</i>&nbsp;    Object[] ints = new Object[]{3, 9, 7, 7};
<i>977</i>&nbsp;    Comparator&lt;Integer&gt; cmp = (a, b) -&gt; a - b;
<i>978</i>&nbsp;    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 0, 2), cmp) &lt; 0);
<i>979</i>&nbsp;    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 1, 3), cmp) &gt; 0);
<i>980</i>&nbsp;    assertTrue((int) compare2FromArray.invoke(Arrays.copyOfRange(ints, 2, 4), cmp) == 0);
<i>981</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>982</i>&nbsp;     * @param spreadArgPos the position (zero-based index) in the argument list at which spreading should start.
<i>983</i>&nbsp;     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments
<i>984</i>&nbsp;     * @param arrayLength the number of arguments to spread from an incoming array argument
<i>985</i>&nbsp;     * @return a new method handle which spreads an array argument at a given position,
<i>986</i>&nbsp;     *         before calling the original method handle
<i>987</i>&nbsp;     * @throws NullPointerException if {@code arrayType} is a null reference
<i>988</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayType} is not an array type,
<i>989</i>&nbsp;     *         or if target does not have at least
<i>990</i>&nbsp;     *         {@code arrayLength} parameter types,
<i>991</i>&nbsp;     *         or if {@code arrayLength} is negative,
<i>992</i>&nbsp;     *         or if {@code spreadArgPos} has an illegal value (negative, or together with arrayLength exceeding the
<i>993</i>&nbsp;     *         number of arguments),
<i>994</i>&nbsp;     *         or if the resulting method handle&#39;s type would have
<b class="nc"><i>995</i>&nbsp;     *         &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;</b>
<b class="nc"><i>996</i>&nbsp;     * @throws WrongMethodTypeException if the implied {@code asType} call fails</b>
<b class="nc"><i>997</i>&nbsp;     *</b>
<b class="nc"><i>998</i>&nbsp;     * @see #asSpreader(Class, int)</b>
<b class="nc"><i>999</i>&nbsp;     * @since 9</b>
<b class="nc"><i>1000</i>&nbsp;     */</b>
<b class="nc"><i>1001</i>&nbsp;    public MethodHandle asSpreader(int spreadArgPos, Class&lt;?&gt; arrayType, int arrayLength) {</b>
<b class="nc"><i>1002</i>&nbsp;        MethodType postSpreadType = asSpreaderChecks(arrayType, spreadArgPos, arrayLength);</b>
<i>1003</i>&nbsp;        MethodHandle afterSpread = this.asType(postSpreadType);
<b class="nc"><i>1004</i>&nbsp;        BoundMethodHandle mh = afterSpread.rebind();</b>
<b class="nc"><i>1005</i>&nbsp;        LambdaForm lform = mh.editor().spreadArgumentsForm(1 + spreadArgPos, arrayType, arrayLength);</b>
<i>1006</i>&nbsp;        MethodType preSpreadType = postSpreadType.replaceParameterTypes(spreadArgPos, spreadArgPos + arrayLength, arrayType);
<i>1007</i>&nbsp;        return mh.copyWith(preSpreadType, lform);
<i>1008</i>&nbsp;    }
<i>1009</i>&nbsp;
<i>1010</i>&nbsp;    /**
<i>1011</i>&nbsp;     * See if {@code asSpreader} can be validly called with the given arguments.
<i>1012</i>&nbsp;     * Return the type of the method handle call after spreading but before conversions.
<b class="nc"><i>1013</i>&nbsp;     */</b>
<b class="nc"><i>1014</i>&nbsp;    private MethodType asSpreaderChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</b>
<b class="nc"><i>1015</i>&nbsp;        spreadArrayChecks(arrayType, arrayLength);</b>
<b class="nc"><i>1016</i>&nbsp;        int nargs = type().parameterCount();</b>
<b class="nc"><i>1017</i>&nbsp;        if (nargs &lt; arrayLength || arrayLength &lt; 0)</b>
<b class="nc"><i>1018</i>&nbsp;            throw newIllegalArgumentException(&quot;bad spread array length&quot;);</b>
<i>1019</i>&nbsp;        if (pos &lt; 0 || pos + arrayLength &gt; nargs) {
<b class="nc"><i>1020</i>&nbsp;            throw newIllegalArgumentException(&quot;bad spread position&quot;);</b>
<i>1021</i>&nbsp;        }
<i>1022</i>&nbsp;        Class&lt;?&gt; arrayElement = arrayType.getComponentType();
<i>1023</i>&nbsp;        MethodType mtype = type();
<i>1024</i>&nbsp;        boolean match = true, fail = false;
<i>1025</i>&nbsp;        for (int i = pos; i &lt; pos + arrayLength; i++) {
<i>1026</i>&nbsp;            Class&lt;?&gt; ptype = mtype.parameterType(i);
<i>1027</i>&nbsp;            if (ptype != arrayElement) {
<i>1028</i>&nbsp;                match = false;
<i>1029</i>&nbsp;                if (!MethodType.canConvert(arrayElement, ptype)) {
<i>1030</i>&nbsp;                    fail = true;
<i>1031</i>&nbsp;                    break;
<i>1032</i>&nbsp;                }
<i>1033</i>&nbsp;            }
<i>1034</i>&nbsp;        }
<i>1035</i>&nbsp;        if (match)  return mtype;
<i>1036</i>&nbsp;        MethodType needType = mtype.asSpreaderType(arrayType, pos, arrayLength);
<i>1037</i>&nbsp;        if (!fail)  return needType;
<i>1038</i>&nbsp;        // elicit an error:
<i>1039</i>&nbsp;        this.asType(needType);
<i>1040</i>&nbsp;        throw newInternalError(&quot;should not return&quot;);
<i>1041</i>&nbsp;    }
<i>1042</i>&nbsp;
<i>1043</i>&nbsp;    private void spreadArrayChecks(Class&lt;?&gt; arrayType, int arrayLength) {
<i>1044</i>&nbsp;        Class&lt;?&gt; arrayElement = arrayType.getComponentType();
<i>1045</i>&nbsp;        if (arrayElement == null)
<i>1046</i>&nbsp;            throw newIllegalArgumentException(&quot;not an array type&quot;, arrayType);
<i>1047</i>&nbsp;        if ((arrayLength &amp; 0x7F) != arrayLength) {
<i>1048</i>&nbsp;            if ((arrayLength &amp; 0xFF) != arrayLength)
<i>1049</i>&nbsp;                throw newIllegalArgumentException(&quot;array length is not legal&quot;, arrayLength);
<i>1050</i>&nbsp;            assert(arrayLength &gt;= 128);
<i>1051</i>&nbsp;            if (arrayElement == long.class ||
<i>1052</i>&nbsp;                arrayElement == double.class)
<i>1053</i>&nbsp;                throw newIllegalArgumentException(&quot;array length is not legal for long[] or double[]&quot;, arrayLength);
<i>1054</i>&nbsp;        }
<i>1055</i>&nbsp;    }
<i>1056</i>&nbsp;    /**
<i>1057</i>&nbsp;      * Adapts this method handle to be {@linkplain #asVarargsCollector variable arity}
<i>1058</i>&nbsp;      * if the boolean flag is true, else {@linkplain #asFixedArity fixed arity}.
<i>1059</i>&nbsp;      * If the method handle is already of the proper arity mode, it is returned
<i>1060</i>&nbsp;      * unchanged.
<i>1061</i>&nbsp;      * @apiNote
<i>1062</i>&nbsp;      * &lt;p&gt;This method is sometimes useful when adapting a method handle that
<i>1063</i>&nbsp;      * may be variable arity, to ensure that the resulting adapter is also
<i>1064</i>&nbsp;      * variable arity if and only if the original handle was.  For example,
<i>1065</i>&nbsp;      * this code changes the first argument of a handle {@code mh} to {@code int} without
<i>1066</i>&nbsp;      * disturbing its variable arity property:
<i>1067</i>&nbsp;      * {@code mh.asType(mh.type().changeParameterType(0,int.class))
<i>1068</i>&nbsp;      *     .withVarargs(mh.isVarargsCollector())}
<i>1069</i>&nbsp;      * &lt;p&gt;
<i>1070</i>&nbsp;      * This call is approximately equivalent to the following code:
<i>1071</i>&nbsp;      * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1072</i>&nbsp;      * if (makeVarargs == isVarargsCollector())
<i>1073</i>&nbsp;      *   return this;
<i>1074</i>&nbsp;      * else if (makeVarargs)
<i>1075</i>&nbsp;      *   return asVarargsCollector(type().lastParameterType());
<i>1076</i>&nbsp;      * else
<i>1077</i>&nbsp;      *   return return asFixedArity();
<i>1078</i>&nbsp;      * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1079</i>&nbsp;      * @param makeVarargs true if the return method handle should have variable arity behavior
<i>1080</i>&nbsp;      * @return a method handle of the same type, with possibly adjusted variable arity behavior
<i>1081</i>&nbsp;      * @throws IllegalArgumentException if {@code makeVarargs} is true and
<i>1082</i>&nbsp;      *         this method handle does not have a trailing array parameter
<i>1083</i>&nbsp;      * @since 9
<i>1084</i>&nbsp;      * @see #asVarargsCollector
<i>1085</i>&nbsp;      * @see #asFixedArity
<i>1086</i>&nbsp;     */
<i>1087</i>&nbsp;    public MethodHandle withVarargs(boolean makeVarargs) {
<i>1088</i>&nbsp;        assert(!isVarargsCollector());  // subclass responsibility
<i>1089</i>&nbsp;        if (makeVarargs) {
<i>1090</i>&nbsp;           return asVarargsCollector(type().lastParameterType());
<i>1091</i>&nbsp;        } else {
<i>1092</i>&nbsp;            return this;
<i>1093</i>&nbsp;        }
<i>1094</i>&nbsp;    }
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;    /**
<i>1097</i>&nbsp;     * Makes an &lt;em&gt;array-collecting&lt;/em&gt; method handle, which accepts a given number of trailing
<i>1098</i>&nbsp;     * positional arguments and collects them into an array argument.
<i>1099</i>&nbsp;     * The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
<i>1100</i>&nbsp;     * the current method handle.  The type of the adapter will be
<i>1101</i>&nbsp;     * the same as the type of the target, except that a single trailing
<i>1102</i>&nbsp;     * parameter (usually of type {@code arrayType}) is replaced by
<i>1103</i>&nbsp;     * {@code arrayLength} parameters whose type is element type of {@code arrayType}.
<i>1104</i>&nbsp;     * &lt;p&gt;
<i>1105</i>&nbsp;     * If the array type differs from the final argument type on the original target,
<i>1106</i>&nbsp;     * the original target is adapted to take the array type directly,
<i>1107</i>&nbsp;     * as if by a call to {@link #asType asType}.
<i>1108</i>&nbsp;     * &lt;p&gt;
<i>1109</i>&nbsp;     * When called, the adapter replaces its trailing {@code arrayLength}
<i>1110</i>&nbsp;     * arguments by a single new array of type {@code arrayType}, whose elements
<i>1111</i>&nbsp;     * comprise (in order) the replaced arguments.
<i>1112</i>&nbsp;     * Finally the target is called.
<i>1113</i>&nbsp;     * What the target eventually returns is returned unchanged by the adapter.
<i>1114</i>&nbsp;     * &lt;p&gt;
<i>1115</i>&nbsp;     * (The array may also be a shared constant when {@code arrayLength} is zero.)
<i>1116</i>&nbsp;     * &lt;p&gt;
<i>1117</i>&nbsp;     * (&lt;em&gt;Note:&lt;/em&gt; The {@code arrayType} is often identical to the
<i>1118</i>&nbsp;     * {@linkplain MethodType#lastParameterType last parameter type}
<i>1119</i>&nbsp;     * of the original target.
<i>1120</i>&nbsp;     * It is an explicit argument for symmetry with {@code asSpreader}, and also
<i>1121</i>&nbsp;     * to allow the target to use a simple {@code Object} as its last parameter type.)
<i>1122</i>&nbsp;     * &lt;p&gt;
<i>1123</i>&nbsp;     * In order to create a collecting adapter which is not restricted to a particular
<i>1124</i>&nbsp;     * number of collected arguments, use {@link #asVarargsCollector asVarargsCollector}
<i>1125</i>&nbsp;     * or {@link #withVarargs withVarargs} instead.
<i>1126</i>&nbsp;     * &lt;p&gt;
<i>1127</i>&nbsp;     * Here are some examples of array-collecting method handles:
<i>1128</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1129</i>&nbsp;MethodHandle deepToString = publicLookup()
<i>1130</i>&nbsp;  .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));
<i>1131</i>&nbsp;assertEquals(&quot;[won]&quot;,   (String) deepToString.invokeExact(new Object[]{&quot;won&quot;}));
<i>1132</i>&nbsp;MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);
<i>1133</i>&nbsp;assertEquals(methodType(String.class, Object.class), ts1.type());
<i>1134</i>&nbsp;//assertEquals(&quot;[won]&quot;, (String) ts1.invokeExact(         new Object[]{&quot;won&quot;})); //FAIL
<i>1135</i>&nbsp;assertEquals(&quot;[[won]]&quot;, (String) ts1.invokeExact((Object) new Object[]{&quot;won&quot;}));
<i>1136</i>&nbsp;// arrayType can be a subtype of Object[]
<i>1137</i>&nbsp;MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
<i>1138</i>&nbsp;assertEquals(methodType(String.class, String.class, String.class), ts2.type());
<i>1139</i>&nbsp;assertEquals(&quot;[two, too]&quot;, (String) ts2.invokeExact(&quot;two&quot;, &quot;too&quot;));
<i>1140</i>&nbsp;MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);
<i>1141</i>&nbsp;assertEquals(&quot;[]&quot;, (String) ts0.invokeExact());
<i>1142</i>&nbsp;// collectors can be nested, Lisp-style
<i>1143</i>&nbsp;MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);
<i>1144</i>&nbsp;assertEquals(&quot;[A, B, [C, D]]&quot;, ((String) ts22.invokeExact((Object)&#39;A&#39;, (Object)&quot;B&quot;, &quot;C&quot;, &quot;D&quot;)));
<i>1145</i>&nbsp;// arrayType can be any primitive array type
<i>1146</i>&nbsp;MethodHandle bytesToString = publicLookup()
<i>1147</i>&nbsp;  .findStatic(Arrays.class, &quot;toString&quot;, methodType(String.class, byte[].class))
<i>1148</i>&nbsp;  .asCollector(byte[].class, 3);
<i>1149</i>&nbsp;assertEquals(&quot;[1, 2, 3]&quot;, (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));
<i>1150</i>&nbsp;MethodHandle longsToString = publicLookup()
<i>1151</i>&nbsp;  .findStatic(Arrays.class, &quot;toString&quot;, methodType(String.class, long[].class))
<i>1152</i>&nbsp;  .asCollector(long[].class, 1);
<i>1153</i>&nbsp;assertEquals(&quot;[123]&quot;, (String) longsToString.invokeExact((long)123));
<i>1154</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1155</i>&nbsp;     * &lt;p&gt;
<i>1156</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>1157</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>1158</i>&nbsp;     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments
<i>1159</i>&nbsp;     * @param arrayLength the number of arguments to collect into a new array argument
<i>1160</i>&nbsp;     * @return a new method handle which collects some trailing argument
<i>1161</i>&nbsp;     *         into an array, before calling the original method handle
<i>1162</i>&nbsp;     * @throws NullPointerException if {@code arrayType} is a null reference
<i>1163</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayType} is not an array type
<i>1164</i>&nbsp;     *         or {@code arrayType} is not assignable to this method handle&#39;s trailing parameter type,
<i>1165</i>&nbsp;     *         or {@code arrayLength} is not a legal array size,
<i>1166</i>&nbsp;     *         or the resulting method handle&#39;s type would have
<i>1167</i>&nbsp;     *         &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>1168</i>&nbsp;     * @throws WrongMethodTypeException if the implied {@code asType} call fails
<i>1169</i>&nbsp;     * @see #asSpreader
<i>1170</i>&nbsp;     * @see #asVarargsCollector
<i>1171</i>&nbsp;     */
<i>1172</i>&nbsp;    public MethodHandle asCollector(Class&lt;?&gt; arrayType, int arrayLength) {
<i>1173</i>&nbsp;        return asCollector(type().parameterCount() - 1, arrayType, arrayLength);
<b class="nc"><i>1174</i>&nbsp;    }</b>
<b class="nc"><i>1175</i>&nbsp;</b>
<b class="nc"><i>1176</i>&nbsp;    /**</b>
<b class="nc"><i>1177</i>&nbsp;     * Makes an &lt;em&gt;array-collecting&lt;/em&gt; method handle, which accepts a given number of positional arguments starting</b>
<b class="nc"><i>1178</i>&nbsp;     * at a given position, and collects them into an array argument. The new method handle adapts, as its</b>
<i>1179</i>&nbsp;     * &lt;i&gt;target&lt;/i&gt;, the current method handle. The type of the adapter will be the same as the type of the target,
<i>1180</i>&nbsp;     * except that the parameter at the position indicated by {@code collectArgPos} (usually of type {@code arrayType})
<i>1181</i>&nbsp;     * is replaced by {@code arrayLength} parameters whose type is element type of {@code arrayType}.
<i>1182</i>&nbsp;     * &lt;p&gt;
<i>1183</i>&nbsp;     * This method behaves very much like {@link #asCollector(Class, int)}, but differs in that its {@code
<i>1184</i>&nbsp;     * collectArgPos} argument indicates at which position in the parameter list arguments should be collected. This
<i>1185</i>&nbsp;     * index is zero-based.
<i>1186</i>&nbsp;     *
<i>1187</i>&nbsp;     * @apiNote Examples:
<i>1188</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1189</i>&nbsp;    StringWriter swr = new StringWriter();
<i>1190</i>&nbsp;    MethodHandle swWrite = LOOKUP.findVirtual(StringWriter.class, &quot;write&quot;, methodType(void.class, char[].class, int.class, int.class)).bindTo(swr);
<i>1191</i>&nbsp;    MethodHandle swWrite4 = swWrite.asCollector(0, char[].class, 4);
<i>1192</i>&nbsp;    swWrite4.invoke(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, 1, 2);
<i>1193</i>&nbsp;    assertEquals(&quot;BC&quot;, swr.toString());
<i>1194</i>&nbsp;    swWrite4.invoke(&#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, 0, 4);
<i>1195</i>&nbsp;    assertEquals(&quot;BCPQRS&quot;, swr.toString());
<i>1196</i>&nbsp;    swWrite4.invoke(&#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, 3, 1);
<b class="nc"><i>1197</i>&nbsp;    assertEquals(&quot;BCPQRSZ&quot;, swr.toString());</b>
<i>1198</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1199</i>&nbsp;     * &lt;p&gt;
<i>1200</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>1201</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>1202</i>&nbsp;     * @param collectArgPos the zero-based position in the parameter list at which to start collecting.
<i>1203</i>&nbsp;     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments
<i>1204</i>&nbsp;     * @param arrayLength the number of arguments to collect into a new array argument
<i>1205</i>&nbsp;     * @return a new method handle which collects some arguments
<i>1206</i>&nbsp;     *         into an array, before calling the original method handle
<i>1207</i>&nbsp;     * @throws NullPointerException if {@code arrayType} is a null reference
<i>1208</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayType} is not an array type
<i>1209</i>&nbsp;     *         or {@code arrayType} is not assignable to this method handle&#39;s array parameter type,
<i>1210</i>&nbsp;     *         or {@code arrayLength} is not a legal array size,
<i>1211</i>&nbsp;     *         or {@code collectArgPos} has an illegal value (negative, or greater than the number of arguments),
<i>1212</i>&nbsp;     *         or the resulting method handle&#39;s type would have
<i>1213</i>&nbsp;     *         &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>1214</i>&nbsp;     * @throws WrongMethodTypeException if the implied {@code asType} call fails
<i>1215</i>&nbsp;     *
<i>1216</i>&nbsp;     * @see #asCollector(Class, int)
<i>1217</i>&nbsp;     * @since 9
<i>1218</i>&nbsp;     */
<i>1219</i>&nbsp;    public MethodHandle asCollector(int collectArgPos, Class&lt;?&gt; arrayType, int arrayLength) {
<i>1220</i>&nbsp;        asCollectorChecks(arrayType, collectArgPos, arrayLength);
<i>1221</i>&nbsp;        BoundMethodHandle mh = rebind();
<i>1222</i>&nbsp;        MethodType resultType = type().asCollectorType(arrayType, collectArgPos, arrayLength);
<i>1223</i>&nbsp;        MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);
<i>1224</i>&nbsp;        LambdaForm lform = mh.editor().collectArgumentArrayForm(1 + collectArgPos, newArray);
<i>1225</i>&nbsp;        if (lform != null) {
<i>1226</i>&nbsp;            return mh.copyWith(resultType, lform);
<i>1227</i>&nbsp;        }
<i>1228</i>&nbsp;        lform = mh.editor().collectArgumentsForm(1 + collectArgPos, newArray.type().basicType());
<i>1229</i>&nbsp;        return mh.copyWithExtendL(resultType, lform, newArray);
<i>1230</i>&nbsp;    }
<i>1231</i>&nbsp;
<i>1232</i>&nbsp;    /**
<i>1233</i>&nbsp;     * See if {@code asCollector} can be validly called with the given arguments.
<i>1234</i>&nbsp;     * Return false if the last parameter is not an exact match to arrayType.
<i>1235</i>&nbsp;     */
<i>1236</i>&nbsp;    /*non-public*/ boolean asCollectorChecks(Class&lt;?&gt; arrayType, int pos, int arrayLength) {
<i>1237</i>&nbsp;        spreadArrayChecks(arrayType, arrayLength);
<i>1238</i>&nbsp;        int nargs = type().parameterCount();
<i>1239</i>&nbsp;        if (pos &lt; 0 || pos &gt;= nargs) {
<i>1240</i>&nbsp;            throw newIllegalArgumentException(&quot;bad collect position&quot;);
<i>1241</i>&nbsp;        }
<i>1242</i>&nbsp;        if (nargs != 0) {
<i>1243</i>&nbsp;            Class&lt;?&gt; param = type().parameterType(pos);
<b class="nc"><i>1244</i>&nbsp;            if (param == arrayType)  return true;</b>
<b class="nc"><i>1245</i>&nbsp;            if (param.isAssignableFrom(arrayType))  return false;</b>
<i>1246</i>&nbsp;        }
<i>1247</i>&nbsp;        throw newIllegalArgumentException(&quot;array type not assignable to argument&quot;, this, arrayType);
<i>1248</i>&nbsp;    }
<i>1249</i>&nbsp;
<i>1250</i>&nbsp;    /**
<i>1251</i>&nbsp;     * Makes a &lt;em&gt;variable arity&lt;/em&gt; adapter which is able to accept
<i>1252</i>&nbsp;     * any number of trailing positional arguments and collect them
<i>1253</i>&nbsp;     * into an array argument.
<i>1254</i>&nbsp;     * &lt;p&gt;
<i>1255</i>&nbsp;     * The type and behavior of the adapter will be the same as
<i>1256</i>&nbsp;     * the type and behavior of the target, except that certain
<i>1257</i>&nbsp;     * {@code invoke} and {@code asType} requests can lead to
<i>1258</i>&nbsp;     * trailing positional arguments being collected into target&#39;s
<i>1259</i>&nbsp;     * trailing parameter.
<i>1260</i>&nbsp;     * Also, the
<i>1261</i>&nbsp;     * {@linkplain MethodType#lastParameterType last parameter type}
<i>1262</i>&nbsp;     * of the adapter will be
<i>1263</i>&nbsp;     * {@code arrayType}, even if the target has a different
<i>1264</i>&nbsp;     * last parameter type.
<i>1265</i>&nbsp;     * &lt;p&gt;
<i>1266</i>&nbsp;     * This transformation may return {@code this} if the method handle is
<i>1267</i>&nbsp;     * already of variable arity and its trailing parameter type
<i>1268</i>&nbsp;     * is identical to {@code arrayType}.
<i>1269</i>&nbsp;     * &lt;p&gt;
<i>1270</i>&nbsp;     * When called with {@link #invokeExact invokeExact}, the adapter invokes
<i>1271</i>&nbsp;     * the target with no argument changes.
<i>1272</i>&nbsp;     * (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a
<i>1273</i>&nbsp;     * {@linkplain #asCollector fixed arity collector},
<i>1274</i>&nbsp;     * since it accepts a whole array of indeterminate length,
<i>1275</i>&nbsp;     * rather than a fixed number of arguments.)
<b class="nc"><i>1276</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1277</i>&nbsp;     * When called with plain, inexact {@link #invoke invoke}, if the caller</b>
<i>1278</i>&nbsp;     * type is the same as the adapter, the adapter invokes the target as with
<i>1279</i>&nbsp;     * {@code invokeExact}.
<i>1280</i>&nbsp;     * (This is the normal behavior for {@code invoke} when types match.)
<i>1281</i>&nbsp;     * &lt;p&gt;
<i>1282</i>&nbsp;     * Otherwise, if the caller and adapter arity are the same, and the
<i>1283</i>&nbsp;     * trailing parameter type of the caller is a reference type identical to
<i>1284</i>&nbsp;     * or assignable to the trailing parameter type of the adapter,
<i>1285</i>&nbsp;     * the arguments and return values are converted pairwise,
<i>1286</i>&nbsp;     * as if by {@link #asType asType} on a fixed arity
<i>1287</i>&nbsp;     * method handle.
<i>1288</i>&nbsp;     * &lt;p&gt;
<i>1289</i>&nbsp;     * Otherwise, the arities differ, or the adapter&#39;s trailing parameter
<i>1290</i>&nbsp;     * type is not assignable from the corresponding caller type.
<i>1291</i>&nbsp;     * In this case, the adapter replaces all trailing arguments from
<i>1292</i>&nbsp;     * the original trailing argument position onward, by
<i>1293</i>&nbsp;     * a new array of type {@code arrayType}, whose elements
<i>1294</i>&nbsp;     * comprise (in order) the replaced arguments.
<i>1295</i>&nbsp;     * &lt;p&gt;
<i>1296</i>&nbsp;     * The caller type must provides as least enough arguments,
<b class="nc"><i>1297</i>&nbsp;     * and of the correct type, to satisfy the target&#39;s requirement for</b>
<b class="nc"><i>1298</i>&nbsp;     * positional arguments before the trailing array argument.</b>
<i>1299</i>&nbsp;     * Thus, the caller must supply, at a minimum, {@code N-1} arguments,
<i>1300</i>&nbsp;     * where {@code N} is the arity of the target.
<b class="nc"><i>1301</i>&nbsp;     * Also, there must exist conversions from the incoming arguments</b>
<i>1302</i>&nbsp;     * to the target&#39;s arguments.
<i>1303</i>&nbsp;     * As with other uses of plain {@code invoke}, if these basic
<i>1304</i>&nbsp;     * requirements are not fulfilled, a {@code WrongMethodTypeException}
<i>1305</i>&nbsp;     * may be thrown.
<i>1306</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1307</i>&nbsp;     * In all cases, what the target eventually returns is returned unchanged by the adapter.</b>
<i>1308</i>&nbsp;     * &lt;p&gt;
<i>1309</i>&nbsp;     * In the final case, it is exactly as if the target method handle were
<i>1310</i>&nbsp;     * temporarily adapted with a {@linkplain #asCollector fixed arity collector}
<i>1311</i>&nbsp;     * to the arity required by the caller type.
<i>1312</i>&nbsp;     * (As with {@code asCollector}, if the array length is zero,
<i>1313</i>&nbsp;     * a shared constant may be used instead of a new array.
<i>1314</i>&nbsp;     * If the implied call to {@code asCollector} would throw
<i>1315</i>&nbsp;     * an {@code IllegalArgumentException} or {@code WrongMethodTypeException},
<i>1316</i>&nbsp;     * the call to the variable arity adapter must throw
<b class="nc"><i>1317</i>&nbsp;     * {@code WrongMethodTypeException}.)</b>
<i>1318</i>&nbsp;     * &lt;p&gt;
<i>1319</i>&nbsp;     * The behavior of {@link #asType asType} is also specialized for
<i>1320</i>&nbsp;     * variable arity adapters, to maintain the invariant that
<i>1321</i>&nbsp;     * plain, inexact {@code invoke} is always equivalent to an {@code asType}
<b class="nc"><i>1322</i>&nbsp;     * call to adjust the target type, followed by {@code invokeExact}.</b>
<b class="nc"><i>1323</i>&nbsp;     * Therefore, a variable arity adapter responds</b>
<b class="nc"><i>1324</i>&nbsp;     * to an {@code asType} request by building a fixed arity collector,</b>
<b class="nc"><i>1325</i>&nbsp;     * if and only if the adapter and requested type differ either</b>
<i>1326</i>&nbsp;     * in arity or trailing argument type.
<b class="nc"><i>1327</i>&nbsp;     * The resulting fixed arity collector has its type further adjusted</b>
<i>1328</i>&nbsp;     * (if necessary) to the requested type by pairwise conversion,
<i>1329</i>&nbsp;     * as if by another application of {@code asType}.
<i>1330</i>&nbsp;     * &lt;p&gt;
<i>1331</i>&nbsp;     * When a method handle is obtained by executing an {@code ldc} instruction
<i>1332</i>&nbsp;     * of a {@code CONSTANT_MethodHandle} constant, and the target method is marked
<i>1333</i>&nbsp;     * as a variable arity method (with the modifier bit {@code 0x0080}),
<i>1334</i>&nbsp;     * the method handle will accept multiple arities, as if the method handle
<i>1335</i>&nbsp;     * constant were created by means of a call to {@code asVarargsCollector}.
<b class="nc"><i>1336</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1337</i>&nbsp;     * In order to create a collecting adapter which collects a predetermined</b>
<b class="nc"><i>1338</i>&nbsp;     * number of arguments, and whose type reflects this predetermined number,</b>
<b class="nc"><i>1339</i>&nbsp;     * use {@link #asCollector asCollector} instead.</b>
<i>1340</i>&nbsp;     * &lt;p&gt;
<i>1341</i>&nbsp;     * No method handle transformations produce new method handles with
<i>1342</i>&nbsp;     * variable arity, unless they are documented as doing so.
<i>1343</i>&nbsp;     * Therefore, besides {@code asVarargsCollector} and {@code withVarargs},
<b class="nc"><i>1344</i>&nbsp;     * all methods in {@code MethodHandle} and {@code MethodHandles}</b>
<b class="nc"><i>1345</i>&nbsp;     * will return a method handle with fixed arity,</b>
<b class="nc"><i>1346</i>&nbsp;     * except in the cases where they are specified to return their original</b>
<i>1347</i>&nbsp;     * operand (e.g., {@code asType} of the method handle&#39;s own type).
<b class="nc"><i>1348</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1349</i>&nbsp;     * Calling {@code asVarargsCollector} on a method handle which is already</b>
<i>1350</i>&nbsp;     * of variable arity will produce a method handle with the same type and behavior.
<b class="nc"><i>1351</i>&nbsp;     * It may (or may not) return the original variable arity method handle.</b>
<i>1352</i>&nbsp;     * &lt;p&gt;
<i>1353</i>&nbsp;     * Here is an example, of a list-making variable arity method handle:
<i>1354</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1355</i>&nbsp;MethodHandle deepToString = publicLookup()
<i>1356</i>&nbsp;  .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));
<i>1357</i>&nbsp;MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);
<b class="nc"><i>1358</i>&nbsp;assertEquals(&quot;[won]&quot;,   (String) ts1.invokeExact(    new Object[]{&quot;won&quot;}));</b>
<i>1359</i>&nbsp;assertEquals(&quot;[won]&quot;,   (String) ts1.invoke(         new Object[]{&quot;won&quot;}));
<i>1360</i>&nbsp;assertEquals(&quot;[won]&quot;,   (String) ts1.invoke(                      &quot;won&quot; ));
<i>1361</i>&nbsp;assertEquals(&quot;[[won]]&quot;, (String) ts1.invoke((Object) new Object[]{&quot;won&quot;}));
<i>1362</i>&nbsp;// findStatic of Arrays.asList(...) produces a variable arity method handle:
<b class="nc"><i>1363</i>&nbsp;MethodHandle asList = publicLookup()</b>
<i>1364</i>&nbsp;  .findStatic(Arrays.class, &quot;asList&quot;, methodType(List.class, Object[].class));
<i>1365</i>&nbsp;assertEquals(methodType(List.class, Object[].class), asList.type());
<i>1366</i>&nbsp;assert(asList.isVarargsCollector());
<i>1367</i>&nbsp;assertEquals(&quot;[]&quot;, asList.invoke().toString());
<b class="nc"><i>1368</i>&nbsp;assertEquals(&quot;[1]&quot;, asList.invoke(1).toString());</b>
<i>1369</i>&nbsp;assertEquals(&quot;[two, too]&quot;, asList.invoke(&quot;two&quot;, &quot;too&quot;).toString());
<i>1370</i>&nbsp;String[] argv = { &quot;three&quot;, &quot;thee&quot;, &quot;tee&quot; };
<i>1371</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, asList.invoke(argv).toString());
<i>1372</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, asList.invoke((Object[])argv).toString());
<i>1373</i>&nbsp;List ls = (List) asList.invoke((Object)argv);
<b class="nc"><i>1374</i>&nbsp;assertEquals(1, ls.size());</b>
<i>1375</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, Arrays.toString((Object[])ls.get(0)));
<i>1376</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1377</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>1378</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<b class="nc"><i>1379</i>&nbsp;     * These rules are designed as a dynamically-typed variation</b>
<b class="nc"><i>1380</i>&nbsp;     * of the Java rules for variable arity methods.</b>
<b class="nc"><i>1381</i>&nbsp;     * In both cases, callers to a variable arity method or method handle</b>
<i>1382</i>&nbsp;     * can either pass zero or more positional arguments, or else pass
<b class="nc"><i>1383</i>&nbsp;     * pre-collected arrays of any length.  Users should be aware of the</b>
<i>1384</i>&nbsp;     * special role of the final argument, and of the effect of a
<i>1385</i>&nbsp;     * type match on that final argument, which determines whether
<b class="nc"><i>1386</i>&nbsp;     * or not a single trailing argument is interpreted as a whole</b>
<b class="nc"><i>1387</i>&nbsp;     * array or a single element of an array to be collected.</b>
<b class="nc"><i>1388</i>&nbsp;     * Note that the dynamic type of the trailing argument has no</b>
<i>1389</i>&nbsp;     * effect on this decision, only a comparison between the symbolic
<i>1390</i>&nbsp;     * type descriptor of the call site and the type descriptor of the method handle.)
<i>1391</i>&nbsp;     *
<i>1392</i>&nbsp;     * @param arrayType often {@code Object[]}, the type of the array argument which will collect the arguments
<i>1393</i>&nbsp;     * @return a new method handle which can collect any number of trailing arguments
<b class="nc"><i>1394</i>&nbsp;     *         into an array, before calling the original method handle</b>
<i>1395</i>&nbsp;     * @throws NullPointerException if {@code arrayType} is a null reference
<i>1396</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayType} is not an array type
<i>1397</i>&nbsp;     *         or {@code arrayType} is not assignable to this method handle&#39;s trailing parameter type
<i>1398</i>&nbsp;     * @see #asCollector
<b class="nc"><i>1399</i>&nbsp;     * @see #isVarargsCollector</b>
<i>1400</i>&nbsp;     * @see #withVarargs
<i>1401</i>&nbsp;     * @see #asFixedArity
<i>1402</i>&nbsp;     */
<i>1403</i>&nbsp;    public MethodHandle asVarargsCollector(Class&lt;?&gt; arrayType) {
<i>1404</i>&nbsp;        Objects.requireNonNull(arrayType);
<b class="nc"><i>1405</i>&nbsp;        boolean lastMatch = asCollectorChecks(arrayType, type().parameterCount() - 1, 0);</b>
<i>1406</i>&nbsp;        if (isVarargsCollector() &amp;&amp; lastMatch)
<i>1407</i>&nbsp;            return this;
<i>1408</i>&nbsp;        return MethodHandleImpl.makeVarargsCollector(this, arrayType);
<i>1409</i>&nbsp;    }
<i>1410</i>&nbsp;
<i>1411</i>&nbsp;    /**
<i>1412</i>&nbsp;     * Determines if this method handle
<i>1413</i>&nbsp;     * supports {@linkplain #asVarargsCollector variable arity} calls.
<i>1414</i>&nbsp;     * Such method handles arise from the following sources:
<i>1415</i>&nbsp;     * &lt;ul&gt;
<i>1416</i>&nbsp;     * &lt;li&gt;a call to {@linkplain #asVarargsCollector asVarargsCollector}
<i>1417</i>&nbsp;     * &lt;li&gt;a call to a {@linkplain java.lang.invoke.MethodHandles.Lookup lookup method}
<i>1418</i>&nbsp;     *     which resolves to a variable arity Java method or constructor
<i>1419</i>&nbsp;     * &lt;li&gt;an {@code ldc} instruction of a {@code CONSTANT_MethodHandle}
<i>1420</i>&nbsp;     *     which resolves to a variable arity Java method or constructor
<i>1421</i>&nbsp;     * &lt;/ul&gt;
<i>1422</i>&nbsp;     * @return true if this method handle accepts more than one arity of plain, inexact {@code invoke} calls
<i>1423</i>&nbsp;     * @see #asVarargsCollector
<i>1424</i>&nbsp;     * @see #asFixedArity
<i>1425</i>&nbsp;     */
<i>1426</i>&nbsp;    public boolean isVarargsCollector() {
<i>1427</i>&nbsp;        return false;
<i>1428</i>&nbsp;    }
<i>1429</i>&nbsp;
<b class="nc"><i>1430</i>&nbsp;    /**</b>
<b class="nc"><i>1431</i>&nbsp;     * Makes a &lt;em&gt;fixed arity&lt;/em&gt; method handle which is otherwise</b>
<b class="nc"><i>1432</i>&nbsp;     * equivalent to the current method handle.</b>
<b class="nc"><i>1433</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1434</i>&nbsp;     * If the current method handle is not of</b>
<i>1435</i>&nbsp;     * {@linkplain #asVarargsCollector variable arity},
<i>1436</i>&nbsp;     * the current method handle is returned.
<i>1437</i>&nbsp;     * This is true even if the current method handle
<i>1438</i>&nbsp;     * could not be a valid input to {@code asVarargsCollector}.
<i>1439</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1440</i>&nbsp;     * Otherwise, the resulting fixed-arity method handle has the same</b>
<b class="nc"><i>1441</i>&nbsp;     * type and behavior of the current method handle,</b>
<b class="nc"><i>1442</i>&nbsp;     * except that {@link #isVarargsCollector isVarargsCollector}</b>
<b class="nc"><i>1443</i>&nbsp;     * will be false.</b>
<b class="nc"><i>1444</i>&nbsp;     * The fixed-arity method handle may (or may not) be the</b>
<i>1445</i>&nbsp;     * a previous argument to {@code asVarargsCollector}.
<i>1446</i>&nbsp;     * &lt;p&gt;
<i>1447</i>&nbsp;     * Here is an example, of a list-making variable arity method handle:
<i>1448</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1449</i>&nbsp;MethodHandle asListVar = publicLookup()
<i>1450</i>&nbsp;  .findStatic(Arrays.class, &quot;asList&quot;, methodType(List.class, Object[].class))
<b class="nc"><i>1451</i>&nbsp;  .asVarargsCollector(Object[].class);</b>
<b class="nc"><i>1452</i>&nbsp;MethodHandle asListFix = asListVar.asFixedArity();</b>
<b class="nc"><i>1453</i>&nbsp;assertEquals(&quot;[1]&quot;, asListVar.invoke(1).toString());</b>
<b class="nc"><i>1454</i>&nbsp;Exception caught = null;</b>
<i>1455</i>&nbsp;try { asListFix.invoke((Object)1); }
<i>1456</i>&nbsp;catch (Exception ex) { caught = ex; }
<i>1457</i>&nbsp;assert(caught instanceof ClassCastException);
<i>1458</i>&nbsp;assertEquals(&quot;[two, too]&quot;, asListVar.invoke(&quot;two&quot;, &quot;too&quot;).toString());
<i>1459</i>&nbsp;try { asListFix.invoke(&quot;two&quot;, &quot;too&quot;); }
<i>1460</i>&nbsp;catch (Exception ex) { caught = ex; }
<i>1461</i>&nbsp;assert(caught instanceof WrongMethodTypeException);
<i>1462</i>&nbsp;Object[] argv = { &quot;three&quot;, &quot;thee&quot;, &quot;tee&quot; };
<i>1463</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, asListVar.invoke(argv).toString());
<i>1464</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, asListFix.invoke(argv).toString());
<i>1465</i>&nbsp;assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());
<i>1466</i>&nbsp;assertEquals(&quot;[three, thee, tee]&quot;, asListFix.invoke((Object)argv).toString());
<i>1467</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1468</i>&nbsp;     *
<i>1469</i>&nbsp;     * @return a new method handle which accepts only a fixed number of arguments
<i>1470</i>&nbsp;     * @see #asVarargsCollector
<i>1471</i>&nbsp;     * @see #isVarargsCollector
<i>1472</i>&nbsp;     * @see #withVarargs
<i>1473</i>&nbsp;     */
<i>1474</i>&nbsp;    public MethodHandle asFixedArity() {
<i>1475</i>&nbsp;        assert(!isVarargsCollector());
<i>1476</i>&nbsp;        return this;
<i>1477</i>&nbsp;    }
<i>1478</i>&nbsp;
<i>1479</i>&nbsp;    /**
<i>1480</i>&nbsp;     * Binds a value {@code x} to the first argument of a method handle, without invoking it.
<i>1481</i>&nbsp;     * The new method handle adapts, as its &lt;i&gt;target&lt;/i&gt;,
<i>1482</i>&nbsp;     * the current method handle by binding it to the given argument.
<i>1483</i>&nbsp;     * The type of the bound handle will be
<i>1484</i>&nbsp;     * the same as the type of the target, except that a single leading
<i>1485</i>&nbsp;     * reference parameter will be omitted.
<i>1486</i>&nbsp;     * &lt;p&gt;
<i>1487</i>&nbsp;     * When called, the bound handle inserts the given value {@code x}
<i>1488</i>&nbsp;     * as a new leading argument to the target.  The other arguments are
<i>1489</i>&nbsp;     * also passed unchanged.
<i>1490</i>&nbsp;     * What the target eventually returns is returned unchanged by the bound handle.
<i>1491</i>&nbsp;     * &lt;p&gt;
<i>1492</i>&nbsp;     * The reference {@code x} must be convertible to the first parameter
<i>1493</i>&nbsp;     * type of the target.
<i>1494</i>&nbsp;     * &lt;p&gt;
<i>1495</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt;  Because method handles are immutable, the target method handle
<i>1496</i>&nbsp;     * retains its original type and behavior.
<i>1497</i>&nbsp;     * &lt;p&gt;
<i>1498</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>1499</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>1500</i>&nbsp;     * @param x  the value to bind to the first argument of the target
<i>1501</i>&nbsp;     * @return a new method handle which prepends the given value to the incoming
<i>1502</i>&nbsp;     *         argument list, before calling the original method handle
<i>1503</i>&nbsp;     * @throws IllegalArgumentException if the target does not have a
<i>1504</i>&nbsp;     *         leading parameter type that is a reference type
<i>1505</i>&nbsp;     * @throws ClassCastException if {@code x} cannot be converted
<i>1506</i>&nbsp;     *         to the leading parameter type of the target
<i>1507</i>&nbsp;     * @see MethodHandles#insertArguments
<i>1508</i>&nbsp;     */
<i>1509</i>&nbsp;    public MethodHandle bindTo(Object x) {
<i>1510</i>&nbsp;        x = type.leadingReferenceParameter().cast(x);  // throw CCE if needed
<i>1511</i>&nbsp;        return bindArgumentL(0, x);
<i>1512</i>&nbsp;    }
<i>1513</i>&nbsp;
<i>1514</i>&nbsp;    /**
<i>1515</i>&nbsp;     * Returns a string representation of the method handle,
<i>1516</i>&nbsp;     * starting with the string {@code &quot;MethodHandle&quot;} and
<i>1517</i>&nbsp;     * ending with the string representation of the method handle&#39;s type.
<i>1518</i>&nbsp;     * In other words, this method returns a string equal to the value of:
<i>1519</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1520</i>&nbsp;     * &quot;MethodHandle&quot; + type().toString()
<i>1521</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1522</i>&nbsp;     * &lt;p&gt;
<i>1523</i>&nbsp;     * (&lt;em&gt;Note:&lt;/em&gt;  Future releases of this API may add further information
<i>1524</i>&nbsp;     * to the string representation.
<i>1525</i>&nbsp;     * Therefore, the present syntax should not be parsed by applications.)
<i>1526</i>&nbsp;     *
<i>1527</i>&nbsp;     * @return a string representation of the method handle
<i>1528</i>&nbsp;     */
<i>1529</i>&nbsp;    @Override
<i>1530</i>&nbsp;    public String toString() {
<i>1531</i>&nbsp;        if (DEBUG_METHOD_HANDLE_NAMES)  return &quot;MethodHandle&quot;+debugString();
<i>1532</i>&nbsp;        return standardString();
<i>1533</i>&nbsp;    }
<i>1534</i>&nbsp;    String standardString() {
<i>1535</i>&nbsp;        return &quot;MethodHandle&quot;+type;
<i>1536</i>&nbsp;    }
<i>1537</i>&nbsp;    /** Return a string with a several lines describing the method handle structure.
<i>1538</i>&nbsp;     *  This string would be suitable for display in an IDE debugger.
<i>1539</i>&nbsp;     */
<i>1540</i>&nbsp;    String debugString() {
<i>1541</i>&nbsp;        return type+&quot; : &quot;+internalForm()+internalProperties();
<i>1542</i>&nbsp;    }
<i>1543</i>&nbsp;
<i>1544</i>&nbsp;    //// Implementation methods.
<i>1545</i>&nbsp;    //// Sub-classes can override these default implementations.
<i>1546</i>&nbsp;    //// All these methods assume arguments are already validated.
<i>1547</i>&nbsp;
<i>1548</i>&nbsp;    // Other transforms to do:  convert, explicitCast, permute, drop, filter, fold, GWT, catch
<i>1549</i>&nbsp;
<i>1550</i>&nbsp;    BoundMethodHandle bindArgumentL(int pos, Object value) {
<i>1551</i>&nbsp;        return rebind().bindArgumentL(pos, value);
<i>1552</i>&nbsp;    }
<i>1553</i>&nbsp;
<i>1554</i>&nbsp;    /*non-public*/
<i>1555</i>&nbsp;    MethodHandle setVarargs(MemberName member) throws IllegalAccessException {
<i>1556</i>&nbsp;        if (!member.isVarargs())  return this;
<i>1557</i>&nbsp;        try {
<i>1558</i>&nbsp;            return this.withVarargs(true);
<i>1559</i>&nbsp;        } catch (IllegalArgumentException ex) {
<i>1560</i>&nbsp;            throw member.makeAccessException(&quot;cannot make variable arity&quot;, null);
<i>1561</i>&nbsp;        }
<i>1562</i>&nbsp;    }
<i>1563</i>&nbsp;
<i>1564</i>&nbsp;    /*non-public*/
<i>1565</i>&nbsp;    MethodHandle viewAsType(MethodType newType, boolean strict) {
<i>1566</i>&nbsp;        // No actual conversions, just a new view of the same method.
<i>1567</i>&nbsp;        // Note that this operation must not produce a DirectMethodHandle,
<i>1568</i>&nbsp;        // because retyped DMHs, like any transformed MHs,
<i>1569</i>&nbsp;        // cannot be cracked into MethodHandleInfo.
<i>1570</i>&nbsp;        assert viewAsTypeChecks(newType, strict);
<i>1571</i>&nbsp;        BoundMethodHandle mh = rebind();
<i>1572</i>&nbsp;        return mh.copyWith(newType, mh.form);
<i>1573</i>&nbsp;    }
<i>1574</i>&nbsp;
<i>1575</i>&nbsp;    /*non-public*/
<i>1576</i>&nbsp;    boolean viewAsTypeChecks(MethodType newType, boolean strict) {
<i>1577</i>&nbsp;        if (strict) {
<i>1578</i>&nbsp;            assert(type().isViewableAs(newType, true))
<i>1579</i>&nbsp;                : Arrays.asList(this, newType);
<i>1580</i>&nbsp;        } else {
<i>1581</i>&nbsp;            assert(type().basicType().isViewableAs(newType.basicType(), true))
<i>1582</i>&nbsp;                : Arrays.asList(this, newType);
<i>1583</i>&nbsp;        }
<i>1584</i>&nbsp;        return true;
<i>1585</i>&nbsp;    }
<i>1586</i>&nbsp;
<i>1587</i>&nbsp;    // Decoding
<i>1588</i>&nbsp;
<i>1589</i>&nbsp;    /*non-public*/
<i>1590</i>&nbsp;    LambdaForm internalForm() {
<i>1591</i>&nbsp;        return form;
<i>1592</i>&nbsp;    }
<i>1593</i>&nbsp;
<i>1594</i>&nbsp;    /*non-public*/
<i>1595</i>&nbsp;    MemberName internalMemberName() {
<i>1596</i>&nbsp;        return null;  // DMH returns DMH.member
<i>1597</i>&nbsp;    }
<i>1598</i>&nbsp;
<i>1599</i>&nbsp;    /*non-public*/
<i>1600</i>&nbsp;    Class&lt;?&gt; internalCallerClass() {
<i>1601</i>&nbsp;        return null;  // caller-bound MH for @CallerSensitive method returns caller
<i>1602</i>&nbsp;    }
<i>1603</i>&nbsp;
<i>1604</i>&nbsp;    /*non-public*/
<i>1605</i>&nbsp;    MethodHandleImpl.Intrinsic intrinsicName() {
<i>1606</i>&nbsp;        // no special intrinsic meaning to most MHs
<i>1607</i>&nbsp;        return MethodHandleImpl.Intrinsic.NONE;
<i>1608</i>&nbsp;    }
<i>1609</i>&nbsp;
<i>1610</i>&nbsp;    /*non-public*/
<i>1611</i>&nbsp;    MethodHandle withInternalMemberName(MemberName member, boolean isInvokeSpecial) {
<i>1612</i>&nbsp;        if (member != null) {
<i>1613</i>&nbsp;            return MethodHandleImpl.makeWrappedMember(this, member, isInvokeSpecial);
<i>1614</i>&nbsp;        } else if (internalMemberName() == null) {
<i>1615</i>&nbsp;            // The required internaMemberName is null, and this MH (like most) doesn&#39;t have one.
<i>1616</i>&nbsp;            return this;
<i>1617</i>&nbsp;        } else {
<i>1618</i>&nbsp;            // The following case is rare. Mask the internalMemberName by wrapping the MH in a BMH.
<i>1619</i>&nbsp;            MethodHandle result = rebind();
<i>1620</i>&nbsp;            assert (result.internalMemberName() == null);
<i>1621</i>&nbsp;            return result;
<i>1622</i>&nbsp;        }
<i>1623</i>&nbsp;    }
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;    /*non-public*/
<i>1626</i>&nbsp;    boolean isInvokeSpecial() {
<i>1627</i>&nbsp;        return false;  // DMH.Special returns true
<i>1628</i>&nbsp;    }
<i>1629</i>&nbsp;
<i>1630</i>&nbsp;    /*non-public*/
<i>1631</i>&nbsp;    Object internalValues() {
<i>1632</i>&nbsp;        return null;
<i>1633</i>&nbsp;    }
<i>1634</i>&nbsp;
<i>1635</i>&nbsp;    /*non-public*/
<i>1636</i>&nbsp;    Object internalProperties() {
<i>1637</i>&nbsp;        // Override to something to follow this.form, like &quot;\n&amp; FOO=bar&quot;
<i>1638</i>&nbsp;        return &quot;&quot;;
<i>1639</i>&nbsp;    }
<i>1640</i>&nbsp;
<i>1641</i>&nbsp;    //// Method handle implementation methods.
<i>1642</i>&nbsp;    //// Sub-classes can override these default implementations.
<i>1643</i>&nbsp;    //// All these methods assume arguments are already validated.
<i>1644</i>&nbsp;
<i>1645</i>&nbsp;    /*non-public*/
<i>1646</i>&nbsp;    abstract MethodHandle copyWith(MethodType mt, LambdaForm lf);
<i>1647</i>&nbsp;
<i>1648</i>&nbsp;    /** Require this method handle to be a BMH, or else replace it with a &quot;wrapper&quot; BMH.
<i>1649</i>&nbsp;     *  Many transforms are implemented only for BMHs.
<i>1650</i>&nbsp;     *  @return a behaviorally equivalent BMH
<i>1651</i>&nbsp;     */
<i>1652</i>&nbsp;    abstract BoundMethodHandle rebind();
<i>1653</i>&nbsp;
<i>1654</i>&nbsp;    /**
<i>1655</i>&nbsp;     * Replace the old lambda form of this method handle with a new one.
<i>1656</i>&nbsp;     * The new one must be functionally equivalent to the old one.
<i>1657</i>&nbsp;     * Threads may continue running the old form indefinitely,
<i>1658</i>&nbsp;     * but it is likely that the new one will be preferred for new executions.
<i>1659</i>&nbsp;     * Use with discretion.
<i>1660</i>&nbsp;     */
<i>1661</i>&nbsp;    /*non-public*/
<i>1662</i>&nbsp;    void updateForm(LambdaForm newForm) {
<i>1663</i>&nbsp;        assert(newForm.customized == null || newForm.customized == this);
<i>1664</i>&nbsp;        if (form == newForm)  return;
<i>1665</i>&nbsp;        newForm.prepare();  // as in MethodHandle.&lt;init&gt;
<i>1666</i>&nbsp;        UNSAFE.putObject(this, FORM_OFFSET, newForm);
<i>1667</i>&nbsp;        UNSAFE.fullFence();
<i>1668</i>&nbsp;    }
<i>1669</i>&nbsp;
<i>1670</i>&nbsp;    /** Craft a LambdaForm customized for this particular MethodHandle */
<i>1671</i>&nbsp;    /*non-public*/
<i>1672</i>&nbsp;    void customize() {
<i>1673</i>&nbsp;        final LambdaForm form = this.form;
<i>1674</i>&nbsp;        if (form.customized == null) {
<i>1675</i>&nbsp;            LambdaForm newForm = form.customize(this);
<i>1676</i>&nbsp;            updateForm(newForm);
<i>1677</i>&nbsp;        } else {
<i>1678</i>&nbsp;            assert(form.customized == this);
<i>1679</i>&nbsp;        }
<i>1680</i>&nbsp;    }
<i>1681</i>&nbsp;
<i>1682</i>&nbsp;    private static final long FORM_OFFSET
<i>1683</i>&nbsp;            = UNSAFE.objectFieldOffset(MethodHandle.class, &quot;form&quot;);
<i>1684</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
