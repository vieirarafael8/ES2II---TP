


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MethodType</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang.invoke</a> ]
</div>

<h1>Coverage Summary for Class: MethodType (java.lang.invoke)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 73)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 314)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodType$ConcurrentWeakInternSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodType$ConcurrentWeakInternSet$WeakEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 81)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 344)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang.invoke;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import jdk.internal.vm.annotation.Stable;
<i>29</i>&nbsp;import sun.invoke.util.Wrapper;
<i>30</i>&nbsp;import java.lang.ref.WeakReference;
<i>31</i>&nbsp;import java.lang.ref.Reference;
<i>32</i>&nbsp;import java.lang.ref.ReferenceQueue;
<i>33</i>&nbsp;import java.util.Arrays;
<i>34</i>&nbsp;import java.util.Collections;
<i>35</i>&nbsp;import java.util.List;
<i>36</i>&nbsp;import java.util.Objects;
<i>37</i>&nbsp;import java.util.StringJoiner;
<i>38</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>39</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>40</i>&nbsp;import sun.invoke.util.BytecodeDescriptor;
<i>41</i>&nbsp;import static java.lang.invoke.MethodHandleStatics.*;
<i>42</i>&nbsp;import sun.invoke.util.VerifyType;
<i>43</i>&nbsp;
<i>44</i>&nbsp;/**
<i>45</i>&nbsp; * A method type represents the arguments and return type accepted and
<i>46</i>&nbsp; * returned by a method handle, or the arguments and return type passed
<i>47</i>&nbsp; * and expected  by a method handle caller.  Method types must be properly
<i>48</i>&nbsp; * matched between a method handle and all its callers,
<i>49</i>&nbsp; * and the JVM&#39;s operations enforce this matching at, specifically
<i>50</i>&nbsp; * during calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}
<i>51</i>&nbsp; * and {@link MethodHandle#invoke MethodHandle.invoke}, and during execution
<i>52</i>&nbsp; * of {@code invokedynamic} instructions.
<i>53</i>&nbsp; * &lt;p&gt;
<i>54</i>&nbsp; * The structure is a return type accompanied by any number of parameter types.
<i>55</i>&nbsp; * The types (primitive, {@code void}, and reference) are represented by {@link Class} objects.
<i>56</i>&nbsp; * (For ease of exposition, we treat {@code void} as if it were a type.
<i>57</i>&nbsp; * In fact, it denotes the absence of a return type.)
<i>58</i>&nbsp; * &lt;p&gt;
<i>59</i>&nbsp; * All instances of {@code MethodType} are immutable.
<i>60</i>&nbsp; * Two instances are completely interchangeable if they compare equal.
<i>61</i>&nbsp; * Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
<i>62</i>&nbsp; * &lt;p&gt;
<i>63</i>&nbsp; * This type can be created only by factory methods.
<i>64</i>&nbsp; * All factory methods may cache values, though caching is not guaranteed.
<i>65</i>&nbsp; * Some factory methods are static, while others are virtual methods which
<i>66</i>&nbsp; * modify precursor method types, e.g., by changing a selected parameter.
<i>67</i>&nbsp; * &lt;p&gt;
<i>68</i>&nbsp; * Factory methods which operate on groups of parameter types
<i>69</i>&nbsp; * are systematically presented in two versions, so that both Java arrays and
<i>70</i>&nbsp; * Java lists can be used to work with groups of parameter types.
<i>71</i>&nbsp; * The query methods {@code parameterArray} and {@code parameterList}
<i>72</i>&nbsp; * also provide a choice between arrays and lists.
<i>73</i>&nbsp; * &lt;p&gt;
<i>74</i>&nbsp; * {@code MethodType} objects are sometimes derived from bytecode instructions
<i>75</i>&nbsp; * such as {@code invokedynamic}, specifically from the type descriptor strings associated
<i>76</i>&nbsp; * with the instructions in a class file&#39;s constant pool.
<i>77</i>&nbsp; * &lt;p&gt;
<i>78</i>&nbsp; * Like classes and strings, method types can also be represented directly
<i>79</i>&nbsp; * in a class file&#39;s constant pool as constants.
<i>80</i>&nbsp; * A method type may be loaded by an {@code ldc} instruction which refers
<i>81</i>&nbsp; * to a suitable {@code CONSTANT_MethodType} constant pool entry.
<i>82</i>&nbsp; * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
<i>83</i>&nbsp; * (For full details on method type constants,
<i>84</i>&nbsp; * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
<i>85</i>&nbsp; * &lt;p&gt;
<i>86</i>&nbsp; * When the JVM materializes a {@code MethodType} from a descriptor string,
<i>87</i>&nbsp; * all classes named in the descriptor must be accessible, and will be loaded.
<i>88</i>&nbsp; * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
<i>89</i>&nbsp; * This loading may occur at any time before the {@code MethodType} object is first derived.
<b class="nc"><i>90</i>&nbsp; * @author John Rose, JSR 292 EG</b>
<i>91</i>&nbsp; * @since 1.7
<i>92</i>&nbsp; */
<i>93</i>&nbsp;public final
<i>94</i>&nbsp;class MethodType implements java.io.Serializable {
<i>95</i>&nbsp;    private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}
<i>96</i>&nbsp;
<i>97</i>&nbsp;    // The rtype and ptypes fields define the structural identity of the method type:
<i>98</i>&nbsp;    private final @Stable Class&lt;?&gt;   rtype;
<i>99</i>&nbsp;    private final @Stable Class&lt;?&gt;[] ptypes;
<i>100</i>&nbsp;
<i>101</i>&nbsp;    // The remaining fields are caches of various sorts:
<i>102</i>&nbsp;    private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
<i>103</i>&nbsp;    private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version
<i>104</i>&nbsp;    private @Stable Invokers invokers;   // cache of handy higher-order adapters
<i>105</i>&nbsp;    private @Stable String methodDescriptor;  // cache for toMethodDescriptorString
<i>106</i>&nbsp;
<b class="nc"><i>107</i>&nbsp;    /**</b>
<b class="nc"><i>108</i>&nbsp;     * Constructor that performs no copying or validation.</b>
<b class="nc"><i>109</i>&nbsp;     * Should only be called from the factory method makeImpl</b>
<b class="nc"><i>110</i>&nbsp;     */</b>
<i>111</i>&nbsp;    private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
<b class="nc"><i>112</i>&nbsp;        this.rtype = rtype;</b>
<i>113</i>&nbsp;        this.ptypes = ptypes;
<i>114</i>&nbsp;    }
<i>115</i>&nbsp;
<i>116</i>&nbsp;    /*trusted*/ MethodTypeForm form() { return form; }
<i>117</i>&nbsp;    /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }
<i>118</i>&nbsp;    /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }
<i>119</i>&nbsp;
<b class="nc"><i>120</i>&nbsp;    void setForm(MethodTypeForm f) { form = f; }</b>
<b class="nc"><i>121</i>&nbsp;</b>
<b class="nc"><i>122</i>&nbsp;    /** This number, mandated by the JVM spec as 255,</b>
<i>123</i>&nbsp;     *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
<i>124</i>&nbsp;     *  that any Java method can receive in its argument list.
<b class="nc"><i>125</i>&nbsp;     *  It limits both JVM signatures and method type objects.</b>
<b class="nc"><i>126</i>&nbsp;     *  The longest possible invocation will look like</b>
<b class="nc"><i>127</i>&nbsp;     *  {@code staticMethod(arg1, arg2, ..., arg255)} or</b>
<i>128</i>&nbsp;     *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
<b class="nc"><i>129</i>&nbsp;     */</b>
<i>130</i>&nbsp;    /*non-public*/ static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.
<i>131</i>&nbsp;
<i>132</i>&nbsp;    /** This number is the maximum arity of a method handle, 254.
<i>133</i>&nbsp;     *  It is derived from the absolute JVM-imposed arity by subtracting one,
<i>134</i>&nbsp;     *  which is the slot occupied by the method handle itself at the
<i>135</i>&nbsp;     *  beginning of the argument list used to invoke the method handle.
<i>136</i>&nbsp;     *  The longest possible invocation will look like
<i>137</i>&nbsp;     *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
<i>138</i>&nbsp;     */
<i>139</i>&nbsp;    // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
<i>140</i>&nbsp;    /*non-public*/ static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver
<i>141</i>&nbsp;
<i>142</i>&nbsp;    /** This number is the maximum arity of a method handle invoker, 253.
<i>143</i>&nbsp;     *  It is derived from the absolute JVM-imposed arity by subtracting two,
<i>144</i>&nbsp;     *  which are the slots occupied by invoke method handle, and the
<i>145</i>&nbsp;     *  target method handle, which are both at the beginning of the argument
<i>146</i>&nbsp;     *  list used to invoke the target method handle.
<i>147</i>&nbsp;     *  The longest possible invocation will look like
<i>148</i>&nbsp;     *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
<i>149</i>&nbsp;     */
<i>150</i>&nbsp;    /*non-public*/ static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker
<i>151</i>&nbsp;
<i>152</i>&nbsp;    private static void checkRtype(Class&lt;?&gt; rtype) {
<i>153</i>&nbsp;        Objects.requireNonNull(rtype);
<i>154</i>&nbsp;    }
<i>155</i>&nbsp;    private static void checkPtype(Class&lt;?&gt; ptype) {
<i>156</i>&nbsp;        Objects.requireNonNull(ptype);
<i>157</i>&nbsp;        if (ptype == void.class)
<i>158</i>&nbsp;            throw newIllegalArgumentException(&quot;parameter type cannot be void&quot;);
<i>159</i>&nbsp;    }
<i>160</i>&nbsp;    /** Return number of extra slots (count of long/double args). */
<i>161</i>&nbsp;    private static int checkPtypes(Class&lt;?&gt;[] ptypes) {
<b class="nc"><i>162</i>&nbsp;        int slots = 0;</b>
<i>163</i>&nbsp;        for (Class&lt;?&gt; ptype : ptypes) {
<i>164</i>&nbsp;            checkPtype(ptype);
<b class="nc"><i>165</i>&nbsp;            if (ptype == double.class || ptype == long.class) {</b>
<b class="nc"><i>166</i>&nbsp;                slots++;</b>
<b class="nc"><i>167</i>&nbsp;            }</b>
<i>168</i>&nbsp;        }
<i>169</i>&nbsp;        checkSlotCount(ptypes.length + slots);
<i>170</i>&nbsp;        return slots;
<b class="nc"><i>171</i>&nbsp;    }</b>
<b class="nc"><i>172</i>&nbsp;</b>
<b class="nc"><i>173</i>&nbsp;    static {</b>
<b class="nc"><i>174</i>&nbsp;        // MAX_JVM_ARITY must be power of 2 minus 1 for following code trick to work:</b>
<b class="nc"><i>175</i>&nbsp;        assert((MAX_JVM_ARITY &amp; (MAX_JVM_ARITY+1)) == 0);</b>
<i>176</i>&nbsp;    }
<i>177</i>&nbsp;    static void checkSlotCount(int count) {
<b class="nc"><i>178</i>&nbsp;        if ((count &amp; MAX_JVM_ARITY) != count)</b>
<b class="nc"><i>179</i>&nbsp;            throw newIllegalArgumentException(&quot;bad parameter count &quot;+count);</b>
<i>180</i>&nbsp;    }
<i>181</i>&nbsp;    private static IndexOutOfBoundsException newIndexOutOfBoundsException(Object num) {
<i>182</i>&nbsp;        if (num instanceof Integer)  num = &quot;bad index: &quot;+num;
<i>183</i>&nbsp;        return new IndexOutOfBoundsException(num.toString());
<b class="nc"><i>184</i>&nbsp;    }</b>
<b class="nc"><i>185</i>&nbsp;</b>
<i>186</i>&nbsp;    static final ConcurrentWeakInternSet&lt;MethodType&gt; internTable = new ConcurrentWeakInternSet&lt;&gt;();
<i>187</i>&nbsp;
<b class="nc"><i>188</i>&nbsp;    static final Class&lt;?&gt;[] NO_PTYPES = {};</b>
<b class="nc"><i>189</i>&nbsp;</b>
<i>190</i>&nbsp;    /**
<i>191</i>&nbsp;     * Finds or creates an instance of the given method type.
<b class="nc"><i>192</i>&nbsp;     * @param rtype  the return type</b>
<i>193</i>&nbsp;     * @param ptypes the parameter types
<b class="nc"><i>194</i>&nbsp;     * @return a method type with the given components</b>
<i>195</i>&nbsp;     * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
<i>196</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
<i>197</i>&nbsp;     */
<i>198</i>&nbsp;    public static
<i>199</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
<i>200</i>&nbsp;        return makeImpl(rtype, ptypes, false);
<i>201</i>&nbsp;    }
<i>202</i>&nbsp;
<i>203</i>&nbsp;    /**
<i>204</i>&nbsp;     * Finds or creates a method type with the given components.
<i>205</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<b class="nc"><i>206</i>&nbsp;     * @param rtype  the return type</b>
<i>207</i>&nbsp;     * @param ptypes the parameter types
<i>208</i>&nbsp;     * @return a method type with the given components
<i>209</i>&nbsp;     * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
<i>210</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
<i>211</i>&nbsp;     */
<i>212</i>&nbsp;    public static
<i>213</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {
<i>214</i>&nbsp;        boolean notrust = false;  // random List impl. could return evil ptypes array
<i>215</i>&nbsp;        return makeImpl(rtype, listToArray(ptypes), notrust);
<i>216</i>&nbsp;    }
<i>217</i>&nbsp;
<i>218</i>&nbsp;    private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
<i>219</i>&nbsp;        // sanity check the size before the toArray call, since size might be huge
<b class="nc"><i>220</i>&nbsp;        checkSlotCount(ptypes.size());</b>
<b class="nc"><i>221</i>&nbsp;        return ptypes.toArray(NO_PTYPES);</b>
<i>222</i>&nbsp;    }
<i>223</i>&nbsp;
<i>224</i>&nbsp;    /**
<i>225</i>&nbsp;     * Finds or creates a method type with the given components.
<b class="nc"><i>226</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.</b>
<b class="nc"><i>227</i>&nbsp;     * The leading parameter type is prepended to the remaining array.</b>
<i>228</i>&nbsp;     * @param rtype  the return type
<i>229</i>&nbsp;     * @param ptype0 the first parameter type
<i>230</i>&nbsp;     * @param ptypes the remaining parameter types
<i>231</i>&nbsp;     * @return a method type with the given components
<i>232</i>&nbsp;     * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
<i>233</i>&nbsp;     * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
<i>234</i>&nbsp;     */
<i>235</i>&nbsp;    public static
<i>236</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {
<i>237</i>&nbsp;        Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];
<i>238</i>&nbsp;        ptypes1[0] = ptype0;
<i>239</i>&nbsp;        System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
<i>240</i>&nbsp;        return makeImpl(rtype, ptypes1, true);
<i>241</i>&nbsp;    }
<i>242</i>&nbsp;
<b class="nc"><i>243</i>&nbsp;    /**</b>
<b class="nc"><i>244</i>&nbsp;     * Finds or creates a method type with the given components.</b>
<b class="nc"><i>245</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.</b>
<b class="nc"><i>246</i>&nbsp;     * The resulting method has no parameter types.</b>
<i>247</i>&nbsp;     * @param rtype  the return type
<i>248</i>&nbsp;     * @return a method type with the given return value
<i>249</i>&nbsp;     * @throws NullPointerException if {@code rtype} is null
<i>250</i>&nbsp;     */
<i>251</i>&nbsp;    public static
<i>252</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype) {
<i>253</i>&nbsp;        return makeImpl(rtype, NO_PTYPES, true);
<i>254</i>&nbsp;    }
<i>255</i>&nbsp;
<i>256</i>&nbsp;    /**
<i>257</i>&nbsp;     * Finds or creates a method type with the given components.
<i>258</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<b class="nc"><i>259</i>&nbsp;     * The resulting method has the single given parameter type.</b>
<i>260</i>&nbsp;     * @param rtype  the return type
<i>261</i>&nbsp;     * @param ptype0 the parameter type
<i>262</i>&nbsp;     * @return a method type with the given return value and parameter type
<i>263</i>&nbsp;     * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
<i>264</i>&nbsp;     * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
<i>265</i>&nbsp;     */
<i>266</i>&nbsp;    public static
<i>267</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {
<i>268</i>&nbsp;        return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);
<i>269</i>&nbsp;    }
<i>270</i>&nbsp;
<i>271</i>&nbsp;    /**
<i>272</i>&nbsp;     * Finds or creates a method type with the given components.
<i>273</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<b class="nc"><i>274</i>&nbsp;     * The resulting method has the same parameter types as {@code ptypes},</b>
<i>275</i>&nbsp;     * and the specified return type.
<i>276</i>&nbsp;     * @param rtype  the return type
<i>277</i>&nbsp;     * @param ptypes the method type which supplies the parameter types
<i>278</i>&nbsp;     * @return a method type with the given components
<i>279</i>&nbsp;     * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
<i>280</i>&nbsp;     */
<i>281</i>&nbsp;    public static
<i>282</i>&nbsp;    MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {
<i>283</i>&nbsp;        return makeImpl(rtype, ptypes.ptypes, true);
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;    /**
<i>287</i>&nbsp;     * Sole factory method to find or create an interned method type.
<i>288</i>&nbsp;     * @param rtype desired return type
<b class="nc"><i>289</i>&nbsp;     * @param ptypes desired parameter types</b>
<i>290</i>&nbsp;     * @param trusted whether the ptypes can be used without cloning
<i>291</i>&nbsp;     * @return the unique method type of the desired structure
<i>292</i>&nbsp;     */
<i>293</i>&nbsp;    /*trusted*/ static
<i>294</i>&nbsp;    MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {
<i>295</i>&nbsp;        if (ptypes.length == 0) {
<i>296</i>&nbsp;            ptypes = NO_PTYPES; trusted = true;
<i>297</i>&nbsp;        }
<i>298</i>&nbsp;        MethodType primordialMT = new MethodType(rtype, ptypes);
<i>299</i>&nbsp;        MethodType mt = internTable.get(primordialMT);
<i>300</i>&nbsp;        if (mt != null)
<b class="nc"><i>301</i>&nbsp;            return mt;</b>
<b class="nc"><i>302</i>&nbsp;</b>
<b class="nc"><i>303</i>&nbsp;        // promote the object to the Real Thing, and reprobe</b>
<b class="nc"><i>304</i>&nbsp;        MethodType.checkRtype(rtype);</b>
<b class="nc"><i>305</i>&nbsp;        if (trusted) {</b>
<i>306</i>&nbsp;            MethodType.checkPtypes(ptypes);
<b class="nc"><i>307</i>&nbsp;            mt = primordialMT;</b>
<i>308</i>&nbsp;        } else {
<b class="nc"><i>309</i>&nbsp;            // Make defensive copy then validate</b>
<b class="nc"><i>310</i>&nbsp;            ptypes = Arrays.copyOf(ptypes, ptypes.length);</b>
<i>311</i>&nbsp;            MethodType.checkPtypes(ptypes);
<b class="nc"><i>312</i>&nbsp;            mt = new MethodType(rtype, ptypes);</b>
<i>313</i>&nbsp;        }
<i>314</i>&nbsp;        mt.form = MethodTypeForm.findForm(mt);
<i>315</i>&nbsp;        return internTable.add(mt);
<i>316</i>&nbsp;    }
<i>317</i>&nbsp;    private static final @Stable MethodType[] objectOnlyTypes = new MethodType[20];
<i>318</i>&nbsp;
<i>319</i>&nbsp;    /**
<i>320</i>&nbsp;     * Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array.
<i>321</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>322</i>&nbsp;     * All parameters and the return type will be {@code Object},
<i>323</i>&nbsp;     * except the final array parameter if any, which will be {@code Object[]}.
<i>324</i>&nbsp;     * @param objectArgCount number of parameters (excluding the final array parameter if any)
<i>325</i>&nbsp;     * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
<i>326</i>&nbsp;     * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
<i>327</i>&nbsp;     * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
<b class="nc"><i>328</i>&nbsp;     * @see #genericMethodType(int)</b>
<b class="nc"><i>329</i>&nbsp;     */</b>
<b class="nc"><i>330</i>&nbsp;    public static</b>
<b class="nc"><i>331</i>&nbsp;    MethodType genericMethodType(int objectArgCount, boolean finalArray) {</b>
<b class="nc"><i>332</i>&nbsp;        MethodType mt;</b>
<b class="nc"><i>333</i>&nbsp;        checkSlotCount(objectArgCount);</b>
<i>334</i>&nbsp;        int ivarargs = (!finalArray ? 0 : 1);
<b class="nc"><i>335</i>&nbsp;        int ootIndex = objectArgCount*2 + ivarargs;</b>
<b class="nc"><i>336</i>&nbsp;        if (ootIndex &lt; objectOnlyTypes.length) {</b>
<b class="nc"><i>337</i>&nbsp;            mt = objectOnlyTypes[ootIndex];</b>
<b class="nc"><i>338</i>&nbsp;            if (mt != null)  return mt;</b>
<b class="nc"><i>339</i>&nbsp;        }</b>
<b class="nc"><i>340</i>&nbsp;        Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[objectArgCount + ivarargs];</b>
<i>341</i>&nbsp;        Arrays.fill(ptypes, Object.class);
<b class="nc"><i>342</i>&nbsp;        if (ivarargs != 0)  ptypes[objectArgCount] = Object[].class;</b>
<i>343</i>&nbsp;        mt = makeImpl(Object.class, ptypes, true);
<i>344</i>&nbsp;        if (ootIndex &lt; objectOnlyTypes.length) {
<i>345</i>&nbsp;            objectOnlyTypes[ootIndex] = mt;     // cache it here also!
<i>346</i>&nbsp;        }
<i>347</i>&nbsp;        return mt;
<i>348</i>&nbsp;    }
<i>349</i>&nbsp;
<i>350</i>&nbsp;    /**
<i>351</i>&nbsp;     * Finds or creates a method type whose components are all {@code Object}.
<i>352</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>353</i>&nbsp;     * All parameters and the return type will be Object.
<i>354</i>&nbsp;     * @param objectArgCount number of parameters
<i>355</i>&nbsp;     * @return a generally applicable method type, for all calls of the given argument count
<b class="nc"><i>356</i>&nbsp;     * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255</b>
<i>357</i>&nbsp;     * @see #genericMethodType(int, boolean)
<i>358</i>&nbsp;     */
<i>359</i>&nbsp;    public static
<i>360</i>&nbsp;    MethodType genericMethodType(int objectArgCount) {
<i>361</i>&nbsp;        return genericMethodType(objectArgCount, false);
<i>362</i>&nbsp;    }
<i>363</i>&nbsp;
<i>364</i>&nbsp;    /**
<i>365</i>&nbsp;     * Finds or creates a method type with a single different parameter type.
<i>366</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>367</i>&nbsp;     * @param num    the index (zero-based) of the parameter type to change
<i>368</i>&nbsp;     * @param nptype a new parameter type to replace the old one with
<i>369</i>&nbsp;     * @return the same type, except with the selected parameter changed
<b class="nc"><i>370</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}</b>
<b class="nc"><i>371</i>&nbsp;     * @throws IllegalArgumentException if {@code nptype} is {@code void.class}</b>
<b class="nc"><i>372</i>&nbsp;     * @throws NullPointerException if {@code nptype} is null</b>
<b class="nc"><i>373</i>&nbsp;     */</b>
<b class="nc"><i>374</i>&nbsp;    public MethodType changeParameterType(int num, Class&lt;?&gt; nptype) {</b>
<i>375</i>&nbsp;        if (parameterType(num) == nptype)  return this;
<i>376</i>&nbsp;        checkPtype(nptype);
<i>377</i>&nbsp;        Class&lt;?&gt;[] nptypes = ptypes.clone();
<i>378</i>&nbsp;        nptypes[num] = nptype;
<i>379</i>&nbsp;        return makeImpl(rtype, nptypes, true);
<i>380</i>&nbsp;    }
<i>381</i>&nbsp;
<i>382</i>&nbsp;    /**
<i>383</i>&nbsp;     * Finds or creates a method type with additional parameter types.
<i>384</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>385</i>&nbsp;     * @param num    the position (zero-based) of the inserted parameter type(s)
<i>386</i>&nbsp;     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
<i>387</i>&nbsp;     * @return the same type, except with the selected parameter(s) inserted
<i>388</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}
<b class="nc"><i>389</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}</b>
<b class="nc"><i>390</i>&nbsp;     *                                  or if the resulting method type would have more than 255 parameter slots</b>
<b class="nc"><i>391</i>&nbsp;     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null</b>
<b class="nc"><i>392</i>&nbsp;     */</b>
<b class="nc"><i>393</i>&nbsp;    public MethodType insertParameterTypes(int num, Class&lt;?&gt;... ptypesToInsert) {</b>
<b class="nc"><i>394</i>&nbsp;        int len = ptypes.length;</b>
<b class="nc"><i>395</i>&nbsp;        if (num &lt; 0 || num &gt; len)</b>
<b class="nc"><i>396</i>&nbsp;            throw newIndexOutOfBoundsException(num);</b>
<b class="nc"><i>397</i>&nbsp;        int ins = checkPtypes(ptypesToInsert);</b>
<b class="nc"><i>398</i>&nbsp;        checkSlotCount(parameterSlotCount() + ptypesToInsert.length + ins);</b>
<b class="nc"><i>399</i>&nbsp;        int ilen = ptypesToInsert.length;</b>
<i>400</i>&nbsp;        if (ilen == 0)  return this;
<i>401</i>&nbsp;        Class&lt;?&gt;[] nptypes = new Class&lt;?&gt;[len + ilen];
<i>402</i>&nbsp;        if (num &gt; 0) {
<i>403</i>&nbsp;            System.arraycopy(ptypes, 0, nptypes, 0, num);
<i>404</i>&nbsp;        }
<i>405</i>&nbsp;        System.arraycopy(ptypesToInsert, 0, nptypes, num, ilen);
<i>406</i>&nbsp;        if (num &lt; len) {
<i>407</i>&nbsp;            System.arraycopy(ptypes, num, nptypes, num+ilen, len-num);
<i>408</i>&nbsp;        }
<i>409</i>&nbsp;        return makeImpl(rtype, nptypes, true);
<i>410</i>&nbsp;    }
<i>411</i>&nbsp;
<b class="nc"><i>412</i>&nbsp;    /**</b>
<i>413</i>&nbsp;     * Finds or creates a method type with additional parameter types.
<i>414</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>415</i>&nbsp;     * @param ptypesToInsert zero or more new parameter types to insert after the end of the parameter list
<i>416</i>&nbsp;     * @return the same type, except with the selected parameter(s) appended
<i>417</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
<i>418</i>&nbsp;     *                                  or if the resulting method type would have more than 255 parameter slots
<i>419</i>&nbsp;     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
<i>420</i>&nbsp;     */
<i>421</i>&nbsp;    public MethodType appendParameterTypes(Class&lt;?&gt;... ptypesToInsert) {
<i>422</i>&nbsp;        return insertParameterTypes(parameterCount(), ptypesToInsert);
<i>423</i>&nbsp;    }
<i>424</i>&nbsp;
<i>425</i>&nbsp;    /**
<i>426</i>&nbsp;     * Finds or creates a method type with additional parameter types.
<b class="nc"><i>427</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.</b>
<i>428</i>&nbsp;     * @param num    the position (zero-based) of the inserted parameter type(s)
<i>429</i>&nbsp;     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
<i>430</i>&nbsp;     * @return the same type, except with the selected parameter(s) inserted
<i>431</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}
<i>432</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
<i>433</i>&nbsp;     *                                  or if the resulting method type would have more than 255 parameter slots
<i>434</i>&nbsp;     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
<i>435</i>&nbsp;     */
<i>436</i>&nbsp;    public MethodType insertParameterTypes(int num, List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
<i>437</i>&nbsp;        return insertParameterTypes(num, listToArray(ptypesToInsert));
<i>438</i>&nbsp;    }
<i>439</i>&nbsp;
<b class="nc"><i>440</i>&nbsp;    /**</b>
<i>441</i>&nbsp;     * Finds or creates a method type with additional parameter types.
<i>442</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>443</i>&nbsp;     * @param ptypesToInsert zero or more new parameter types to insert after the end of the parameter list
<i>444</i>&nbsp;     * @return the same type, except with the selected parameter(s) appended
<i>445</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
<i>446</i>&nbsp;     *                                  or if the resulting method type would have more than 255 parameter slots
<i>447</i>&nbsp;     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
<i>448</i>&nbsp;     */
<i>449</i>&nbsp;    public MethodType appendParameterTypes(List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
<i>450</i>&nbsp;        return insertParameterTypes(parameterCount(), ptypesToInsert);
<i>451</i>&nbsp;    }
<i>452</i>&nbsp;
<i>453</i>&nbsp;     /**
<i>454</i>&nbsp;     * Finds or creates a method type with modified parameter types.
<i>455</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>456</i>&nbsp;     * @param start  the position (zero-based) of the first replaced parameter type(s)
<i>457</i>&nbsp;     * @param end    the position (zero-based) after the last replaced parameter type(s)
<b class="nc"><i>458</i>&nbsp;     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list</b>
<b class="nc"><i>459</i>&nbsp;     * @return the same type, except with the selected parameter(s) replaced</b>
<b class="nc"><i>460</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}</b>
<b class="nc"><i>461</i>&nbsp;     *                                  or if {@code end} is negative or greater than {@code parameterCount()}</b>
<b class="nc"><i>462</i>&nbsp;     *                                  or if {@code start} is greater than {@code end}</b>
<b class="nc"><i>463</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}</b>
<b class="nc"><i>464</i>&nbsp;     *                                  or if the resulting method type would have more than 255 parameter slots</b>
<b class="nc"><i>465</i>&nbsp;     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null</b>
<b class="nc"><i>466</i>&nbsp;     */</b>
<i>467</i>&nbsp;    /*non-public*/ MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {
<i>468</i>&nbsp;        if (start == end)
<i>469</i>&nbsp;            return insertParameterTypes(start, ptypesToInsert);
<i>470</i>&nbsp;        int len = ptypes.length;
<i>471</i>&nbsp;        if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))
<i>472</i>&nbsp;            throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);
<i>473</i>&nbsp;        int ilen = ptypesToInsert.length;
<i>474</i>&nbsp;        if (ilen == 0)
<b class="nc"><i>475</i>&nbsp;            return dropParameterTypes(start, end);</b>
<b class="nc"><i>476</i>&nbsp;        return dropParameterTypes(start, end).insertParameterTypes(start, ptypesToInsert);</b>
<b class="nc"><i>477</i>&nbsp;    }</b>
<b class="nc"><i>478</i>&nbsp;</b>
<b class="nc"><i>479</i>&nbsp;    /** Replace the last arrayLength parameter types with the component type of arrayType.</b>
<b class="nc"><i>480</i>&nbsp;     * @param arrayType any array type</b>
<i>481</i>&nbsp;     * @param pos position at which to spread
<b class="nc"><i>482</i>&nbsp;     * @param arrayLength the number of parameter types to change</b>
<b class="nc"><i>483</i>&nbsp;     * @return the resulting type</b>
<b class="nc"><i>484</i>&nbsp;     */</b>
<i>485</i>&nbsp;    /*non-public*/ MethodType asSpreaderType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {
<b class="nc"><i>486</i>&nbsp;        assert(parameterCount() &gt;= arrayLength);</b>
<i>487</i>&nbsp;        int spreadPos = pos;
<i>488</i>&nbsp;        if (arrayLength == 0)  return this;  // nothing to change
<b class="nc"><i>489</i>&nbsp;        if (arrayType == Object[].class) {</b>
<b class="nc"><i>490</i>&nbsp;            if (isGeneric())  return this;  // nothing to change</b>
<b class="nc"><i>491</i>&nbsp;            if (spreadPos == 0) {</b>
<b class="nc"><i>492</i>&nbsp;                // no leading arguments to preserve; go generic</b>
<b class="nc"><i>493</i>&nbsp;                MethodType res = genericMethodType(arrayLength);</b>
<b class="nc"><i>494</i>&nbsp;                if (rtype != Object.class) {</b>
<b class="nc"><i>495</i>&nbsp;                    res = res.changeReturnType(rtype);</b>
<i>496</i>&nbsp;                }
<i>497</i>&nbsp;                return res;
<b class="nc"><i>498</i>&nbsp;            }</b>
<i>499</i>&nbsp;        }
<i>500</i>&nbsp;        Class&lt;?&gt; elemType = arrayType.getComponentType();
<i>501</i>&nbsp;        assert(elemType != null);
<i>502</i>&nbsp;        for (int i = spreadPos; i &lt; spreadPos + arrayLength; i++) {
<i>503</i>&nbsp;            if (ptypes[i] != elemType) {
<i>504</i>&nbsp;                Class&lt;?&gt;[] fixedPtypes = ptypes.clone();
<i>505</i>&nbsp;                Arrays.fill(fixedPtypes, i, spreadPos + arrayLength, elemType);
<b class="nc"><i>506</i>&nbsp;                return methodType(rtype, fixedPtypes);</b>
<b class="nc"><i>507</i>&nbsp;            }</b>
<b class="nc"><i>508</i>&nbsp;        }</b>
<b class="nc"><i>509</i>&nbsp;        return this;  // arguments check out; no change</b>
<i>510</i>&nbsp;    }
<i>511</i>&nbsp;
<i>512</i>&nbsp;    /** Return the leading parameter type, which must exist and be a reference.
<i>513</i>&nbsp;     *  @return the leading parameter type, after error checks
<i>514</i>&nbsp;     */
<i>515</i>&nbsp;    /*non-public*/ Class&lt;?&gt; leadingReferenceParameter() {
<i>516</i>&nbsp;        Class&lt;?&gt; ptype;
<i>517</i>&nbsp;        if (ptypes.length == 0 ||
<b class="nc"><i>518</i>&nbsp;            (ptype = ptypes[0]).isPrimitive())</b>
<b class="nc"><i>519</i>&nbsp;            throw newIllegalArgumentException(&quot;no leading reference parameter&quot;);</b>
<i>520</i>&nbsp;        return ptype;
<b class="nc"><i>521</i>&nbsp;    }</b>
<b class="nc"><i>522</i>&nbsp;</b>
<b class="nc"><i>523</i>&nbsp;    /** Delete the last parameter type and replace it with arrayLength copies of the component type of arrayType.</b>
<b class="nc"><i>524</i>&nbsp;     * @param arrayType any array type</b>
<i>525</i>&nbsp;     * @param pos position at which to insert parameters
<i>526</i>&nbsp;     * @param arrayLength the number of parameter types to insert
<b class="nc"><i>527</i>&nbsp;     * @return the resulting type</b>
<b class="nc"><i>528</i>&nbsp;     */</b>
<b class="nc"><i>529</i>&nbsp;    /*non-public*/ MethodType asCollectorType(Class&lt;?&gt; arrayType, int pos, int arrayLength) {</b>
<i>530</i>&nbsp;        assert(parameterCount() &gt;= 1);
<b class="nc"><i>531</i>&nbsp;        assert(pos &lt; ptypes.length);</b>
<b class="nc"><i>532</i>&nbsp;        assert(ptypes[pos].isAssignableFrom(arrayType));</b>
<i>533</i>&nbsp;        MethodType res;
<b class="nc"><i>534</i>&nbsp;        if (arrayType == Object[].class) {</b>
<i>535</i>&nbsp;            res = genericMethodType(arrayLength);
<i>536</i>&nbsp;            if (rtype != Object.class) {
<i>537</i>&nbsp;                res = res.changeReturnType(rtype);
<i>538</i>&nbsp;            }
<i>539</i>&nbsp;        } else {
<i>540</i>&nbsp;            Class&lt;?&gt; elemType = arrayType.getComponentType();
<i>541</i>&nbsp;            assert(elemType != null);
<i>542</i>&nbsp;            res = methodType(rtype, Collections.nCopies(arrayLength, elemType));
<i>543</i>&nbsp;        }
<i>544</i>&nbsp;        if (ptypes.length == 1) {
<i>545</i>&nbsp;            return res;
<i>546</i>&nbsp;        } else {
<i>547</i>&nbsp;            // insert after (if need be), then before
<i>548</i>&nbsp;            if (pos &lt; ptypes.length - 1) {
<b class="nc"><i>549</i>&nbsp;                res = res.insertParameterTypes(arrayLength, Arrays.copyOfRange(ptypes, pos + 1, ptypes.length));</b>
<b class="nc"><i>550</i>&nbsp;            }</b>
<b class="nc"><i>551</i>&nbsp;            return res.insertParameterTypes(0, Arrays.copyOf(ptypes, pos));</b>
<b class="nc"><i>552</i>&nbsp;        }</b>
<i>553</i>&nbsp;    }
<b class="nc"><i>554</i>&nbsp;</b>
<b class="nc"><i>555</i>&nbsp;    /**</b>
<i>556</i>&nbsp;     * Finds or creates a method type with some parameter types omitted.
<b class="nc"><i>557</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.</b>
<i>558</i>&nbsp;     * @param start  the index (zero-based) of the first parameter type to remove
<i>559</i>&nbsp;     * @param end    the index (greater than {@code start}) of the first parameter type after not to remove
<b class="nc"><i>560</i>&nbsp;     * @return the same type, except with the selected parameter(s) removed</b>
<i>561</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}
<i>562</i>&nbsp;     *                                  or if {@code end} is negative or greater than {@code parameterCount()}
<b class="nc"><i>563</i>&nbsp;     *                                  or if {@code start} is greater than {@code end}</b>
<i>564</i>&nbsp;     */
<b class="nc"><i>565</i>&nbsp;    public MethodType dropParameterTypes(int start, int end) {</b>
<i>566</i>&nbsp;        int len = ptypes.length;
<b class="nc"><i>567</i>&nbsp;        if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))</b>
<b class="nc"><i>568</i>&nbsp;            throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);</b>
<b class="nc"><i>569</i>&nbsp;        if (start == end)  return this;</b>
<i>570</i>&nbsp;        Class&lt;?&gt;[] nptypes;
<i>571</i>&nbsp;        if (start == 0) {
<b class="nc"><i>572</i>&nbsp;            if (end == len) {</b>
<i>573</i>&nbsp;                // drop all parameters
<i>574</i>&nbsp;                nptypes = NO_PTYPES;
<i>575</i>&nbsp;            } else {
<i>576</i>&nbsp;                // drop initial parameter(s)
<i>577</i>&nbsp;                nptypes = Arrays.copyOfRange(ptypes, end, len);
<i>578</i>&nbsp;            }
<i>579</i>&nbsp;        } else {
<i>580</i>&nbsp;            if (end == len) {
<i>581</i>&nbsp;                // drop trailing parameter(s)
<i>582</i>&nbsp;                nptypes = Arrays.copyOfRange(ptypes, 0, start);
<b class="nc"><i>583</i>&nbsp;            } else {</b>
<b class="nc"><i>584</i>&nbsp;                int tail = len - end;</b>
<i>585</i>&nbsp;                nptypes = Arrays.copyOfRange(ptypes, 0, start + tail);
<i>586</i>&nbsp;                System.arraycopy(ptypes, end, nptypes, start, tail);
<i>587</i>&nbsp;            }
<i>588</i>&nbsp;        }
<i>589</i>&nbsp;        return makeImpl(rtype, nptypes, true);
<i>590</i>&nbsp;    }
<i>591</i>&nbsp;
<i>592</i>&nbsp;    /**
<b class="nc"><i>593</i>&nbsp;     * Finds or creates a method type with a different return type.</b>
<i>594</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>595</i>&nbsp;     * @param nrtype a return parameter type to replace the old one with
<i>596</i>&nbsp;     * @return the same type, except with the return type change
<i>597</i>&nbsp;     * @throws NullPointerException if {@code nrtype} is null
<i>598</i>&nbsp;     */
<i>599</i>&nbsp;    public MethodType changeReturnType(Class&lt;?&gt; nrtype) {
<i>600</i>&nbsp;        if (returnType() == nrtype)  return this;
<i>601</i>&nbsp;        return makeImpl(nrtype, ptypes, true);
<i>602</i>&nbsp;    }
<i>603</i>&nbsp;
<b class="nc"><i>604</i>&nbsp;    /**</b>
<i>605</i>&nbsp;     * Reports if this type contains a primitive argument or return value.
<i>606</i>&nbsp;     * The return type {@code void} counts as a primitive.
<i>607</i>&nbsp;     * @return true if any of the types are primitives
<i>608</i>&nbsp;     */
<i>609</i>&nbsp;    public boolean hasPrimitives() {
<i>610</i>&nbsp;        return form.hasPrimitives();
<i>611</i>&nbsp;    }
<i>612</i>&nbsp;
<i>613</i>&nbsp;    /**
<b class="nc"><i>614</i>&nbsp;     * Reports if this type contains a wrapper argument or return value.</b>
<i>615</i>&nbsp;     * Wrappers are types which box primitive values, such as {@link Integer}.
<i>616</i>&nbsp;     * The reference type {@code java.lang.Void} counts as a wrapper,
<i>617</i>&nbsp;     * if it occurs as a return type.
<i>618</i>&nbsp;     * @return true if any of the types are wrappers
<i>619</i>&nbsp;     */
<i>620</i>&nbsp;    public boolean hasWrappers() {
<i>621</i>&nbsp;        return unwrap() != this;
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;    /**</b>
<i>625</i>&nbsp;     * Erases all reference types to {@code Object}.
<i>626</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>627</i>&nbsp;     * All primitive types (including {@code void}) will remain unchanged.
<i>628</i>&nbsp;     * @return a version of the original type with all reference types replaced
<i>629</i>&nbsp;     */
<i>630</i>&nbsp;    public MethodType erase() {
<b class="nc"><i>631</i>&nbsp;        return form.erasedType();</b>
<i>632</i>&nbsp;    }
<i>633</i>&nbsp;
<i>634</i>&nbsp;    /**
<i>635</i>&nbsp;     * Erases all reference types to {@code Object}, and all subword types to {@code int}.
<i>636</i>&nbsp;     * This is the reduced type polymorphism used by private methods
<i>637</i>&nbsp;     * such as {@link MethodHandle#invokeBasic invokeBasic}.
<i>638</i>&nbsp;     * @return a version of the original type with all reference and subword types replaced
<i>639</i>&nbsp;     */
<i>640</i>&nbsp;    /*non-public*/ MethodType basicType() {
<i>641</i>&nbsp;        return form.basicType();
<b class="nc"><i>642</i>&nbsp;    }</b>
<i>643</i>&nbsp;
<i>644</i>&nbsp;    private static final @Stable Class&lt;?&gt;[] METHOD_HANDLE_ARRAY
<i>645</i>&nbsp;            = new Class&lt;?&gt;[] { MethodHandle.class };
<b class="nc"><i>646</i>&nbsp;</b>
<i>647</i>&nbsp;    /**
<i>648</i>&nbsp;     * @return a version of the original type with MethodHandle prepended as the first argument
<i>649</i>&nbsp;     */
<i>650</i>&nbsp;    /*non-public*/ MethodType invokerType() {
<i>651</i>&nbsp;        return insertParameterTypes(0, METHOD_HANDLE_ARRAY);
<i>652</i>&nbsp;    }
<i>653</i>&nbsp;
<i>654</i>&nbsp;    /**
<i>655</i>&nbsp;     * Converts all types, both reference and primitive, to {@code Object}.
<i>656</i>&nbsp;     * Convenience method for {@link #genericMethodType(int) genericMethodType}.
<i>657</i>&nbsp;     * The expression {@code type.wrap().erase()} produces the same value
<i>658</i>&nbsp;     * as {@code type.generic()}.
<b class="nc"><i>659</i>&nbsp;     * @return a version of the original type with all types replaced</b>
<i>660</i>&nbsp;     */
<i>661</i>&nbsp;    public MethodType generic() {
<i>662</i>&nbsp;        return genericMethodType(parameterCount());
<i>663</i>&nbsp;    }
<i>664</i>&nbsp;
<i>665</i>&nbsp;    /*non-public*/ boolean isGeneric() {
<i>666</i>&nbsp;        return this == erase() &amp;&amp; !hasPrimitives();
<i>667</i>&nbsp;    }
<i>668</i>&nbsp;
<i>669</i>&nbsp;    /**
<b class="nc"><i>670</i>&nbsp;     * Converts all primitive types to their corresponding wrapper types.</b>
<b class="nc"><i>671</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.</b>
<i>672</i>&nbsp;     * All reference types (including wrapper types) will remain unchanged.
<i>673</i>&nbsp;     * A {@code void} return type is changed to the type {@code java.lang.Void}.
<i>674</i>&nbsp;     * The expression {@code type.wrap().erase()} produces the same value
<b class="nc"><i>675</i>&nbsp;     * as {@code type.generic()}.</b>
<b class="nc"><i>676</i>&nbsp;     * @return a version of the original type with all primitive types replaced</b>
<b class="nc"><i>677</i>&nbsp;     */</b>
<i>678</i>&nbsp;    public MethodType wrap() {
<b class="nc"><i>679</i>&nbsp;        return hasPrimitives() ? wrapWithPrims(this) : this;</b>
<b class="nc"><i>680</i>&nbsp;    }</b>
<b class="nc"><i>681</i>&nbsp;</b>
<i>682</i>&nbsp;    /**
<b class="nc"><i>683</i>&nbsp;     * Converts all wrapper types to their corresponding primitive types.</b>
<i>684</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<i>685</i>&nbsp;     * All primitive types (including {@code void}) will remain unchanged.
<i>686</i>&nbsp;     * A return type of {@code java.lang.Void} is changed to {@code void}.
<b class="nc"><i>687</i>&nbsp;     * @return a version of the original type with all wrapper types replaced</b>
<b class="nc"><i>688</i>&nbsp;     */</b>
<b class="nc"><i>689</i>&nbsp;    public MethodType unwrap() {</b>
<i>690</i>&nbsp;        MethodType noprims = !hasPrimitives() ? this : wrapWithPrims(this);
<b class="nc"><i>691</i>&nbsp;        return unwrapWithNoPrims(noprims);</b>
<b class="nc"><i>692</i>&nbsp;    }</b>
<b class="nc"><i>693</i>&nbsp;</b>
<b class="nc"><i>694</i>&nbsp;    private static MethodType wrapWithPrims(MethodType pt) {</b>
<i>695</i>&nbsp;        assert(pt.hasPrimitives());
<b class="nc"><i>696</i>&nbsp;        MethodType wt = pt.wrapAlt;</b>
<i>697</i>&nbsp;        if (wt == null) {
<i>698</i>&nbsp;            // fill in lazily
<i>699</i>&nbsp;            wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);
<i>700</i>&nbsp;            assert(wt != null);
<i>701</i>&nbsp;            pt.wrapAlt = wt;
<i>702</i>&nbsp;        }
<i>703</i>&nbsp;        return wt;
<i>704</i>&nbsp;    }
<i>705</i>&nbsp;
<b class="nc"><i>706</i>&nbsp;    private static MethodType unwrapWithNoPrims(MethodType wt) {</b>
<i>707</i>&nbsp;        assert(!wt.hasPrimitives());
<i>708</i>&nbsp;        MethodType uwt = wt.wrapAlt;
<i>709</i>&nbsp;        if (uwt == null) {
<i>710</i>&nbsp;            // fill in lazily
<i>711</i>&nbsp;            uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);
<i>712</i>&nbsp;            if (uwt == null)
<b class="nc"><i>713</i>&nbsp;                uwt = wt;    // type has no wrappers or prims at all</b>
<i>714</i>&nbsp;            wt.wrapAlt = uwt;
<i>715</i>&nbsp;        }
<i>716</i>&nbsp;        return uwt;
<i>717</i>&nbsp;    }
<i>718</i>&nbsp;
<i>719</i>&nbsp;    /**
<b class="nc"><i>720</i>&nbsp;     * Returns the parameter type at the specified index, within this method type.</b>
<i>721</i>&nbsp;     * @param num the index (zero-based) of the desired parameter type
<i>722</i>&nbsp;     * @return the selected parameter type
<i>723</i>&nbsp;     * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
<i>724</i>&nbsp;     */
<i>725</i>&nbsp;    public Class&lt;?&gt; parameterType(int num) {
<i>726</i>&nbsp;        return ptypes[num];
<i>727</i>&nbsp;    }
<i>728</i>&nbsp;    /**
<b class="nc"><i>729</i>&nbsp;     * Returns the number of parameter types in this method type.</b>
<i>730</i>&nbsp;     * @return the number of parameter types
<i>731</i>&nbsp;     */
<i>732</i>&nbsp;    public int parameterCount() {
<b class="nc"><i>733</i>&nbsp;        return ptypes.length;</b>
<b class="nc"><i>734</i>&nbsp;    }</b>
<i>735</i>&nbsp;    /**
<i>736</i>&nbsp;     * Returns the return type of this method type.
<i>737</i>&nbsp;     * @return the return type
<i>738</i>&nbsp;     */
<i>739</i>&nbsp;    public Class&lt;?&gt; returnType() {
<i>740</i>&nbsp;        return rtype;
<i>741</i>&nbsp;    }
<i>742</i>&nbsp;
<b class="nc"><i>743</i>&nbsp;    /**</b>
<i>744</i>&nbsp;     * Presents the parameter types as a list (a convenience method).
<i>745</i>&nbsp;     * The list will be immutable.
<i>746</i>&nbsp;     * @return the parameter types (as an immutable list)
<i>747</i>&nbsp;     */
<i>748</i>&nbsp;    public List&lt;Class&lt;?&gt;&gt; parameterList() {
<i>749</i>&nbsp;        return Collections.unmodifiableList(Arrays.asList(ptypes.clone()));
<i>750</i>&nbsp;    }
<i>751</i>&nbsp;
<i>752</i>&nbsp;    /**
<i>753</i>&nbsp;     * Returns the last parameter type of this method type.
<i>754</i>&nbsp;     * If this type has no parameters, the sentinel value
<b class="nc"><i>755</i>&nbsp;     * {@code void.class} is returned instead.</b>
<i>756</i>&nbsp;     * @apiNote
<i>757</i>&nbsp;     * &lt;p&gt;
<i>758</i>&nbsp;     * The sentinel value is chosen so that reflective queries can be
<b class="nc"><i>759</i>&nbsp;     * made directly against the result value.</b>
<b class="nc"><i>760</i>&nbsp;     * The sentinel value cannot be confused with a real parameter,</b>
<i>761</i>&nbsp;     * since {@code void} is never acceptable as a parameter type.
<i>762</i>&nbsp;     * For variable arity invocation modes, the expression
<i>763</i>&nbsp;     * {@link Class#getComponentType lastParameterType().getComponentType()}
<i>764</i>&nbsp;     * is useful to query the type of the &quot;varargs&quot; parameter.
<i>765</i>&nbsp;     * @return the last parameter type if any, else {@code void.class}
<i>766</i>&nbsp;     * @since 10
<i>767</i>&nbsp;     */
<i>768</i>&nbsp;    public Class&lt;?&gt; lastParameterType() {
<i>769</i>&nbsp;        int len = ptypes.length;
<i>770</i>&nbsp;        return len == 0 ? void.class : ptypes[len-1];
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /**
<i>774</i>&nbsp;     * Presents the parameter types as an array (a convenience method).
<b class="nc"><i>775</i>&nbsp;     * Changes to the array will not result in changes to the type.</b>
<b class="nc"><i>776</i>&nbsp;     * @return the parameter types (as a fresh copy if necessary)</b>
<b class="nc"><i>777</i>&nbsp;     */</b>
<b class="nc"><i>778</i>&nbsp;    public Class&lt;?&gt;[] parameterArray() {</b>
<i>779</i>&nbsp;        return ptypes.clone();
<i>780</i>&nbsp;    }
<i>781</i>&nbsp;
<i>782</i>&nbsp;    /**
<i>783</i>&nbsp;     * Compares the specified object with this type for equality.
<i>784</i>&nbsp;     * That is, it returns {@code true} if and only if the specified object
<i>785</i>&nbsp;     * is also a method type with exactly the same parameters and return type.
<i>786</i>&nbsp;     * @param x object to compare
<i>787</i>&nbsp;     * @see Object#equals(Object)
<i>788</i>&nbsp;     */
<i>789</i>&nbsp;    @Override
<i>790</i>&nbsp;    public boolean equals(Object x) {
<i>791</i>&nbsp;        return this == x || x instanceof MethodType &amp;&amp; equals((MethodType)x);
<i>792</i>&nbsp;    }
<b class="nc"><i>793</i>&nbsp;</b>
<b class="nc"><i>794</i>&nbsp;    private boolean equals(MethodType that) {</b>
<b class="nc"><i>795</i>&nbsp;        return this.rtype == that.rtype</b>
<b class="nc"><i>796</i>&nbsp;            &amp;&amp; Arrays.equals(this.ptypes, that.ptypes);</b>
<b class="nc"><i>797</i>&nbsp;    }</b>
<i>798</i>&nbsp;
<b class="nc"><i>799</i>&nbsp;    /**</b>
<b class="nc"><i>800</i>&nbsp;     * Returns the hash code value for this method type.</b>
<b class="nc"><i>801</i>&nbsp;     * It is defined to be the same as the hashcode of a List</b>
<i>802</i>&nbsp;     * whose elements are the return type followed by the
<i>803</i>&nbsp;     * parameter types.
<i>804</i>&nbsp;     * @return the hash code value for this method type
<i>805</i>&nbsp;     * @see Object#hashCode()
<i>806</i>&nbsp;     * @see #equals(Object)
<i>807</i>&nbsp;     * @see List#hashCode()
<i>808</i>&nbsp;     */
<b class="nc"><i>809</i>&nbsp;    @Override</b>
<b class="nc"><i>810</i>&nbsp;    public int hashCode() {</b>
<b class="nc"><i>811</i>&nbsp;      int hashCode = 31 + rtype.hashCode();</b>
<i>812</i>&nbsp;      for (Class&lt;?&gt; ptype : ptypes)
<i>813</i>&nbsp;          hashCode = 31*hashCode + ptype.hashCode();
<i>814</i>&nbsp;      return hashCode;
<i>815</i>&nbsp;    }
<b class="nc"><i>816</i>&nbsp;</b>
<b class="nc"><i>817</i>&nbsp;    /**</b>
<b class="nc"><i>818</i>&nbsp;     * Returns a string representation of the method type,</b>
<b class="nc"><i>819</i>&nbsp;     * of the form {@code &quot;(PT0,PT1...)RT&quot;}.</b>
<b class="nc"><i>820</i>&nbsp;     * The string representation of a method type is a</b>
<b class="nc"><i>821</i>&nbsp;     * parenthesis enclosed, comma separated list of type names,</b>
<b class="nc"><i>822</i>&nbsp;     * followed immediately by the return type.</b>
<b class="nc"><i>823</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>824</i>&nbsp;     * Each type is represented by its</b>
<b class="nc"><i>825</i>&nbsp;     * {@link java.lang.Class#getSimpleName simple name}.</b>
<i>826</i>&nbsp;     */
<b class="nc"><i>827</i>&nbsp;    @Override</b>
<i>828</i>&nbsp;    public String toString() {
<i>829</i>&nbsp;        StringJoiner sj = new StringJoiner(&quot;,&quot;, &quot;(&quot;,
<i>830</i>&nbsp;                &quot;)&quot; + rtype.getSimpleName());
<b class="nc"><i>831</i>&nbsp;        for (int i = 0; i &lt; ptypes.length; i++) {</b>
<b class="nc"><i>832</i>&nbsp;            sj.add(ptypes[i].getSimpleName());</b>
<b class="nc"><i>833</i>&nbsp;        }</b>
<i>834</i>&nbsp;        return sj.toString();
<b class="nc"><i>835</i>&nbsp;    }</b>
<b class="nc"><i>836</i>&nbsp;</b>
<b class="nc"><i>837</i>&nbsp;    /** True if my parameter list is effectively identical to the given full list,</b>
<b class="nc"><i>838</i>&nbsp;     *  after skipping the given number of my own initial parameters.</b>
<b class="nc"><i>839</i>&nbsp;     *  In other words, after disregarding {@code skipPos} parameters,</b>
<b class="nc"><i>840</i>&nbsp;     *  my remaining parameter list is no longer than the {@code fullList}, and</b>
<b class="nc"><i>841</i>&nbsp;     *  is equal to the same-length initial sublist of {@code fullList}.</b>
<i>842</i>&nbsp;     */
<b class="nc"><i>843</i>&nbsp;    /*non-public*/</b>
<b class="nc"><i>844</i>&nbsp;    boolean effectivelyIdenticalParameters(int skipPos, List&lt;Class&lt;?&gt;&gt; fullList) {</b>
<b class="nc"><i>845</i>&nbsp;        int myLen = ptypes.length, fullLen = fullList.size();</b>
<b class="nc"><i>846</i>&nbsp;        if (skipPos &gt; myLen || myLen - skipPos &gt; fullLen)</b>
<b class="nc"><i>847</i>&nbsp;            return false;</b>
<b class="nc"><i>848</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; myList = Arrays.asList(ptypes);</b>
<i>849</i>&nbsp;        if (skipPos != 0) {
<b class="nc"><i>850</i>&nbsp;            myList = myList.subList(skipPos, myLen);</b>
<b class="nc"><i>851</i>&nbsp;            myLen -= skipPos;</b>
<i>852</i>&nbsp;        }
<i>853</i>&nbsp;        if (fullLen == myLen)
<b class="nc"><i>854</i>&nbsp;            return myList.equals(fullList);</b>
<b class="nc"><i>855</i>&nbsp;        else</b>
<i>856</i>&nbsp;            return myList.equals(fullList.subList(0, myLen));
<b class="nc"><i>857</i>&nbsp;    }</b>
<i>858</i>&nbsp;
<i>859</i>&nbsp;    /** True if the old return type can always be viewed (w/o casting) under new return type,
<i>860</i>&nbsp;     *  and the new parameters can be viewed (w/o casting) under the old parameter types.
<i>861</i>&nbsp;     */
<i>862</i>&nbsp;    /*non-public*/
<i>863</i>&nbsp;    boolean isViewableAs(MethodType newType, boolean keepInterfaces) {
<i>864</i>&nbsp;        if (!VerifyType.isNullConversion(returnType(), newType.returnType(), keepInterfaces))
<b class="nc"><i>865</i>&nbsp;            return false;</b>
<b class="nc"><i>866</i>&nbsp;        if (form == newType.form &amp;&amp; form.erasedType == this)</b>
<b class="nc"><i>867</i>&nbsp;            return true;  // my reference parameters are all Object</b>
<i>868</i>&nbsp;        if (ptypes == newType.ptypes)
<b class="nc"><i>869</i>&nbsp;            return true;</b>
<b class="nc"><i>870</i>&nbsp;        int argc = parameterCount();</b>
<b class="nc"><i>871</i>&nbsp;        if (argc != newType.parameterCount())</b>
<b class="nc"><i>872</i>&nbsp;            return false;</b>
<i>873</i>&nbsp;        for (int i = 0; i &lt; argc; i++) {
<b class="nc"><i>874</i>&nbsp;            if (!VerifyType.isNullConversion(newType.parameterType(i), parameterType(i), keepInterfaces))</b>
<b class="nc"><i>875</i>&nbsp;                return false;</b>
<b class="nc"><i>876</i>&nbsp;        }</b>
<b class="nc"><i>877</i>&nbsp;        return true;</b>
<i>878</i>&nbsp;    }
<i>879</i>&nbsp;    /*non-public*/
<b class="nc"><i>880</i>&nbsp;    boolean isConvertibleTo(MethodType newType) {</b>
<i>881</i>&nbsp;        MethodTypeForm oldForm = this.form();
<i>882</i>&nbsp;        MethodTypeForm newForm = newType.form();
<i>883</i>&nbsp;        if (oldForm == newForm)
<i>884</i>&nbsp;            // same parameter count, same primitive/object mix
<i>885</i>&nbsp;            return true;
<i>886</i>&nbsp;        if (!canConvert(returnType(), newType.returnType()))
<i>887</i>&nbsp;            return false;
<i>888</i>&nbsp;        Class&lt;?&gt;[] srcTypes = newType.ptypes;
<i>889</i>&nbsp;        Class&lt;?&gt;[] dstTypes = ptypes;
<i>890</i>&nbsp;        if (srcTypes == dstTypes)
<i>891</i>&nbsp;            return true;
<i>892</i>&nbsp;        int argc;
<i>893</i>&nbsp;        if ((argc = srcTypes.length) != dstTypes.length)
<i>894</i>&nbsp;            return false;
<i>895</i>&nbsp;        if (argc &lt;= 1) {
<i>896</i>&nbsp;            if (argc == 1 &amp;&amp; !canConvert(srcTypes[0], dstTypes[0]))
<i>897</i>&nbsp;                return false;
<b class="nc"><i>898</i>&nbsp;            return true;</b>
<b class="nc"><i>899</i>&nbsp;        }</b>
<i>900</i>&nbsp;        if ((oldForm.primitiveParameterCount() == 0 &amp;&amp; oldForm.erasedType == this) ||
<i>901</i>&nbsp;            (newForm.primitiveParameterCount() == 0 &amp;&amp; newForm.erasedType == newType)) {
<b class="nc"><i>902</i>&nbsp;            // Somewhat complicated test to avoid a loop of 2 or more trips.</b>
<b class="nc"><i>903</i>&nbsp;            // If either type has only Object parameters, we know we can convert.</b>
<i>904</i>&nbsp;            assert(canConvertParameters(srcTypes, dstTypes));
<b class="nc"><i>905</i>&nbsp;            return true;</b>
<i>906</i>&nbsp;        }
<i>907</i>&nbsp;        return canConvertParameters(srcTypes, dstTypes);
<b class="nc"><i>908</i>&nbsp;    }</b>
<i>909</i>&nbsp;
<i>910</i>&nbsp;    /** Returns true if MHs.explicitCastArguments produces the same result as MH.asType.
<i>911</i>&nbsp;     *  If the type conversion is impossible for either, the result should be false.
<i>912</i>&nbsp;     */
<b class="nc"><i>913</i>&nbsp;    /*non-public*/</b>
<b class="nc"><i>914</i>&nbsp;    boolean explicitCastEquivalentToAsType(MethodType newType) {</b>
<b class="nc"><i>915</i>&nbsp;        if (this == newType)  return true;</b>
<i>916</i>&nbsp;        if (!explicitCastEquivalentToAsType(rtype, newType.rtype)) {
<i>917</i>&nbsp;            return false;
<b class="nc"><i>918</i>&nbsp;        }</b>
<i>919</i>&nbsp;        Class&lt;?&gt;[] srcTypes = newType.ptypes;
<i>920</i>&nbsp;        Class&lt;?&gt;[] dstTypes = ptypes;
<i>921</i>&nbsp;        if (dstTypes == srcTypes) {
<i>922</i>&nbsp;            return true;
<i>923</i>&nbsp;        }
<b class="nc"><i>924</i>&nbsp;        assert(dstTypes.length == srcTypes.length);</b>
<i>925</i>&nbsp;        for (int i = 0; i &lt; dstTypes.length; i++) {
<b class="nc"><i>926</i>&nbsp;            if (!explicitCastEquivalentToAsType(srcTypes[i], dstTypes[i])) {</b>
<i>927</i>&nbsp;                return false;
<i>928</i>&nbsp;            }
<b class="nc"><i>929</i>&nbsp;        }</b>
<b class="nc"><i>930</i>&nbsp;        return true;</b>
<b class="nc"><i>931</i>&nbsp;    }</b>
<i>932</i>&nbsp;
<b class="nc"><i>933</i>&nbsp;    /** Reports true if the src can be converted to the dst, by both asType and MHs.eCE,</b>
<i>934</i>&nbsp;     *  and with the same effect.
<i>935</i>&nbsp;     *  MHs.eCA has the following &quot;upgrades&quot; to MH.asType:
<b class="nc"><i>936</i>&nbsp;     *  1. interfaces are unchecked (that is, treated as if aliased to Object)</b>
<i>937</i>&nbsp;     *     Therefore, {@code Object-&gt;CharSequence} is possible in both cases but has different semantics
<b class="nc"><i>938</i>&nbsp;     *  2. the full matrix of primitive-to-primitive conversions is supported</b>
<i>939</i>&nbsp;     *     Narrowing like {@code long-&gt;byte} and basic-typing like {@code boolean-&gt;int}
<b class="nc"><i>940</i>&nbsp;     *     are not supported by asType, but anything supported by asType is equivalent</b>
<b class="nc"><i>941</i>&nbsp;     *     with MHs.eCE.</b>
<i>942</i>&nbsp;     *  3a. unboxing conversions can be followed by the full matrix of primitive conversions
<i>943</i>&nbsp;     *  3b. unboxing of null is permitted (creates a zero primitive value)
<i>944</i>&nbsp;     * Other than interfaces, reference-to-reference conversions are the same.
<i>945</i>&nbsp;     * Boxing primitives to references is the same for both operators.
<i>946</i>&nbsp;     */
<i>947</i>&nbsp;    private static boolean explicitCastEquivalentToAsType(Class&lt;?&gt; src, Class&lt;?&gt; dst) {
<b class="nc"><i>948</i>&nbsp;        if (src == dst || dst == Object.class || dst == void.class)  return true;</b>
<b class="nc"><i>949</i>&nbsp;        if (src.isPrimitive()) {</b>
<i>950</i>&nbsp;            // Could be a prim/prim conversion, where casting is a strict superset.
<i>951</i>&nbsp;            // Or a boxing conversion, which is always to an exact wrapper class.
<i>952</i>&nbsp;            return canConvert(src, dst);
<i>953</i>&nbsp;        } else if (dst.isPrimitive()) {
<i>954</i>&nbsp;            // Unboxing behavior is different between MHs.eCA &amp; MH.asType (see 3b).
<b class="nc"><i>955</i>&nbsp;            return false;</b>
<b class="nc"><i>956</i>&nbsp;        } else {</b>
<i>957</i>&nbsp;            // R-&gt;R always works, but we have to avoid a check-cast to an interface.
<b class="nc"><i>958</i>&nbsp;            return !dst.isInterface() || dst.isAssignableFrom(src);</b>
<i>959</i>&nbsp;        }
<i>960</i>&nbsp;    }
<i>961</i>&nbsp;
<i>962</i>&nbsp;    private boolean canConvertParameters(Class&lt;?&gt;[] srcTypes, Class&lt;?&gt;[] dstTypes) {
<i>963</i>&nbsp;        for (int i = 0; i &lt; srcTypes.length; i++) {
<i>964</i>&nbsp;            if (!canConvert(srcTypes[i], dstTypes[i])) {
<i>965</i>&nbsp;                return false;
<i>966</i>&nbsp;            }
<b class="nc"><i>967</i>&nbsp;        }</b>
<i>968</i>&nbsp;        return true;
<i>969</i>&nbsp;    }
<b class="nc"><i>970</i>&nbsp;</b>
<i>971</i>&nbsp;    /*non-public*/
<i>972</i>&nbsp;    static boolean canConvert(Class&lt;?&gt; src, Class&lt;?&gt; dst) {
<i>973</i>&nbsp;        // short-circuit a few cases:
<i>974</i>&nbsp;        if (src == dst || src == Object.class || dst == Object.class)  return true;
<i>975</i>&nbsp;        // the remainder of this logic is documented in MethodHandle.asType
<i>976</i>&nbsp;        if (src.isPrimitive()) {
<i>977</i>&nbsp;            // can force void to an explicit null, a la reflect.Method.invoke
<i>978</i>&nbsp;            // can also force void to a primitive zero, by analogy
<i>979</i>&nbsp;            if (src == void.class)  return true;  //or !dst.isPrimitive()?
<i>980</i>&nbsp;            Wrapper sw = Wrapper.forPrimitiveType(src);
<i>981</i>&nbsp;            if (dst.isPrimitive()) {
<i>982</i>&nbsp;                // P-&gt;P must widen
<i>983</i>&nbsp;                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);
<i>984</i>&nbsp;            } else {
<i>985</i>&nbsp;                // P-&gt;R must box and widen
<i>986</i>&nbsp;                return dst.isAssignableFrom(sw.wrapperType());
<b class="nc"><i>987</i>&nbsp;            }</b>
<i>988</i>&nbsp;        } else if (dst.isPrimitive()) {
<i>989</i>&nbsp;            // any value can be dropped
<i>990</i>&nbsp;            if (dst == void.class)  return true;
<b class="nc"><i>991</i>&nbsp;            Wrapper dw = Wrapper.forPrimitiveType(dst);</b>
<b class="nc"><i>992</i>&nbsp;            // R-&gt;P must be able to unbox (from a dynamically chosen type) and widen</b>
<b class="nc"><i>993</i>&nbsp;            // For example:</b>
<b class="nc"><i>994</i>&nbsp;            //   Byte/Number/Comparable/Object -&gt; dw:Byte -&gt; byte.</b>
<i>995</i>&nbsp;            //   Character/Comparable/Object -&gt; dw:Character -&gt; char
<i>996</i>&nbsp;            //   Boolean/Comparable/Object -&gt; dw:Boolean -&gt; boolean
<i>997</i>&nbsp;            // This means that dw must be cast-compatible with src.
<i>998</i>&nbsp;            if (src.isAssignableFrom(dw.wrapperType())) {
<i>999</i>&nbsp;                return true;
<i>1000</i>&nbsp;            }
<i>1001</i>&nbsp;            // The above does not work if the source reference is strongly typed
<i>1002</i>&nbsp;            // to a wrapper whose primitive must be widened.  For example:
<i>1003</i>&nbsp;            //   Byte -&gt; unbox:byte -&gt; short/int/long/float/double
<i>1004</i>&nbsp;            //   Character -&gt; unbox:char -&gt; int/long/float/double
<i>1005</i>&nbsp;            if (Wrapper.isWrapperType(src) &amp;&amp;
<i>1006</i>&nbsp;                dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {
<i>1007</i>&nbsp;                // can unbox from src and then widen to dst
<i>1008</i>&nbsp;                return true;
<i>1009</i>&nbsp;            }
<i>1010</i>&nbsp;            // We have already covered cases which arise due to runtime unboxing
<i>1011</i>&nbsp;            // of a reference type which covers several wrapper types:
<i>1012</i>&nbsp;            //   Object -&gt; cast:Integer -&gt; unbox:int -&gt; long/float/double
<i>1013</i>&nbsp;            //   Serializable -&gt; cast:Byte -&gt; unbox:byte -&gt; byte/short/int/long/float/double
<i>1014</i>&nbsp;            // An marginal case is Number -&gt; dw:Character -&gt; char, which would be OK if there were a
<i>1015</i>&nbsp;            // subclass of Number which wraps a value that can convert to char.
<i>1016</i>&nbsp;            // Since there is none, we don&#39;t need an extra check here to cover char or boolean.
<i>1017</i>&nbsp;            return false;
<i>1018</i>&nbsp;        } else {
<i>1019</i>&nbsp;            // R-&gt;R always works, since null is always valid dynamically
<i>1020</i>&nbsp;            return true;
<b class="nc"><i>1021</i>&nbsp;        }</b>
<b class="nc"><i>1022</i>&nbsp;    }</b>
<b class="nc"><i>1023</i>&nbsp;</b>
<i>1024</i>&nbsp;    /// Queries which have to do with the bytecode architecture
<i>1025</i>&nbsp;
<i>1026</i>&nbsp;    /** Reports the number of JVM stack slots required to invoke a method
<i>1027</i>&nbsp;     * of this type.  Note that (for historical reasons) the JVM requires
<i>1028</i>&nbsp;     * a second stack slot to pass long and double arguments.
<i>1029</i>&nbsp;     * So this method returns {@link #parameterCount() parameterCount} plus the
<i>1030</i>&nbsp;     * number of long and double parameters (if any).
<i>1031</i>&nbsp;     * &lt;p&gt;
<i>1032</i>&nbsp;     * This method is included for the benefit of applications that must
<i>1033</i>&nbsp;     * generate bytecodes that process method handles and invokedynamic.
<i>1034</i>&nbsp;     * @return the number of JVM stack slots for this type&#39;s parameters
<i>1035</i>&nbsp;     */
<i>1036</i>&nbsp;    /*non-public*/ int parameterSlotCount() {
<b class="nc"><i>1037</i>&nbsp;        return form.parameterSlotCount();</b>
<i>1038</i>&nbsp;    }
<i>1039</i>&nbsp;
<i>1040</i>&nbsp;    /*non-public*/ Invokers invokers() {
<i>1041</i>&nbsp;        Invokers inv = invokers;
<i>1042</i>&nbsp;        if (inv != null)  return inv;
<i>1043</i>&nbsp;        invokers = inv = new Invokers(this);
<i>1044</i>&nbsp;        return inv;
<i>1045</i>&nbsp;    }
<i>1046</i>&nbsp;
<i>1047</i>&nbsp;    /** Reports the number of JVM stack slots which carry all parameters including and after
<i>1048</i>&nbsp;     * the given position, which must be in the range of 0 to
<i>1049</i>&nbsp;     * {@code parameterCount} inclusive.  Successive parameters are
<i>1050</i>&nbsp;     * more shallowly stacked, and parameters are indexed in the bytecodes
<i>1051</i>&nbsp;     * according to their trailing edge.  Thus, to obtain the depth
<i>1052</i>&nbsp;     * in the outgoing call stack of parameter {@code N}, obtain
<i>1053</i>&nbsp;     * the {@code parameterSlotDepth} of its trailing edge
<i>1054</i>&nbsp;     * at position {@code N+1}.
<i>1055</i>&nbsp;     * &lt;p&gt;
<i>1056</i>&nbsp;     * Parameters of type {@code long} and {@code double} occupy
<i>1057</i>&nbsp;     * two stack slots (for historical reasons) and all others occupy one.
<i>1058</i>&nbsp;     * Therefore, the number returned is the number of arguments
<i>1059</i>&nbsp;     * &lt;em&gt;including&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the given parameter,
<i>1060</i>&nbsp;     * &lt;em&gt;plus&lt;/em&gt; the number of long or double arguments
<i>1061</i>&nbsp;     * at or after the argument for the given parameter.
<i>1062</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1063</i>&nbsp;     * This method is included for the benefit of applications that must</b>
<b class="nc"><i>1064</i>&nbsp;     * generate bytecodes that process method handles and invokedynamic.</b>
<b class="nc"><i>1065</i>&nbsp;     * @param num an index (zero-based, inclusive) within the parameter types</b>
<b class="nc"><i>1066</i>&nbsp;     * @return the index of the (shallowest) JVM stack slot transmitting the</b>
<b class="nc"><i>1067</i>&nbsp;     *         given parameter</b>
<b class="nc"><i>1068</i>&nbsp;     * @throws IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}</b>
<b class="nc"><i>1069</i>&nbsp;     */</b>
<b class="nc"><i>1070</i>&nbsp;    /*non-public*/ int parameterSlotDepth(int num) {</b>
<b class="nc"><i>1071</i>&nbsp;        if (num &lt; 0 || num &gt; ptypes.length)</b>
<i>1072</i>&nbsp;            parameterType(num);  // force a range check
<i>1073</i>&nbsp;        return form.parameterToArgSlot(num-1);
<i>1074</i>&nbsp;    }
<i>1075</i>&nbsp;
<i>1076</i>&nbsp;    /** Reports the number of JVM stack slots required to receive a return value
<i>1077</i>&nbsp;     * from a method of this type.
<i>1078</i>&nbsp;     * If the {@link #returnType() return type} is void, it will be zero,
<i>1079</i>&nbsp;     * else if the return type is long or double, it will be two, else one.
<i>1080</i>&nbsp;     * &lt;p&gt;
<i>1081</i>&nbsp;     * This method is included for the benefit of applications that must
<i>1082</i>&nbsp;     * generate bytecodes that process method handles and invokedynamic.
<i>1083</i>&nbsp;     * @return the number of JVM stack slots (0, 1, or 2) for this type&#39;s return value
<i>1084</i>&nbsp;     * Will be removed for PFD.
<i>1085</i>&nbsp;     */
<i>1086</i>&nbsp;    /*non-public*/ int returnSlotCount() {
<i>1087</i>&nbsp;        return form.returnSlotCount();
<b class="nc"><i>1088</i>&nbsp;    }</b>
<b class="nc"><i>1089</i>&nbsp;</b>
<b class="nc"><i>1090</i>&nbsp;    /**</b>
<b class="nc"><i>1091</i>&nbsp;     * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.</b>
<i>1092</i>&nbsp;     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
<b class="nc"><i>1093</i>&nbsp;     * Any class or interface name embedded in the descriptor string</b>
<i>1094</i>&nbsp;     * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}
<i>1095</i>&nbsp;     * on the given loader (or if it is null, on the system class loader).
<i>1096</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1097</i>&nbsp;     * Note that it is possible to encounter method types which cannot be</b>
<i>1098</i>&nbsp;     * constructed by this method, because their component types are
<i>1099</i>&nbsp;     * not all reachable from a common class loader.
<i>1100</i>&nbsp;     * &lt;p&gt;
<i>1101</i>&nbsp;     * This method is included for the benefit of applications that must
<i>1102</i>&nbsp;     * generate bytecodes that process method handles and {@code invokedynamic}.
<i>1103</i>&nbsp;     * @param descriptor a bytecode-level type descriptor string &quot;(T...)T&quot;
<i>1104</i>&nbsp;     * @param loader the class loader in which to look up the types
<b class="nc"><i>1105</i>&nbsp;     * @return a method type matching the bytecode-level type descriptor</b>
<i>1106</i>&nbsp;     * @throws NullPointerException if the string is null
<i>1107</i>&nbsp;     * @throws IllegalArgumentException if the string is not well-formed
<i>1108</i>&nbsp;     * @throws TypeNotPresentException if a named type cannot be found
<i>1109</i>&nbsp;     */
<i>1110</i>&nbsp;    public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
<i>1111</i>&nbsp;        throws IllegalArgumentException, TypeNotPresentException
<i>1112</i>&nbsp;    {
<i>1113</i>&nbsp;        return fromDescriptor(descriptor,
<i>1114</i>&nbsp;                              (loader == null) ? ClassLoader.getSystemClassLoader() : loader);
<i>1115</i>&nbsp;    }
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;    /**
<i>1118</i>&nbsp;     * Same as {@link #fromMethodDescriptorString(String, ClassLoader)}, but
<i>1119</i>&nbsp;     * {@code null} ClassLoader means the bootstrap loader is used here.
<i>1120</i>&nbsp;     * &lt;p&gt;
<i>1121</i>&nbsp;     * IMPORTANT: This method is preferable for JDK internal use as it more
<i>1122</i>&nbsp;     * correctly interprets {@code null} ClassLoader than
<i>1123</i>&nbsp;     * {@link #fromMethodDescriptorString(String, ClassLoader)}.
<i>1124</i>&nbsp;     * Use of this method also avoids early initialization issues when system
<i>1125</i>&nbsp;     * ClassLoader is not initialized yet.
<i>1126</i>&nbsp;     */
<i>1127</i>&nbsp;    static MethodType fromDescriptor(String descriptor, ClassLoader loader)
<b class="nc"><i>1128</i>&nbsp;        throws IllegalArgumentException, TypeNotPresentException</b>
<b class="nc"><i>1129</i>&nbsp;    {</b>
<b class="nc"><i>1130</i>&nbsp;        if (!descriptor.startsWith(&quot;(&quot;) ||  // also generates NPE if needed</b>
<i>1131</i>&nbsp;            descriptor.indexOf(&#39;)&#39;) &lt; 0 ||
<i>1132</i>&nbsp;            descriptor.indexOf(&#39;.&#39;) &gt;= 0)
<i>1133</i>&nbsp;            throw newIllegalArgumentException(&quot;not a method descriptor: &quot;+descriptor);
<i>1134</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; types = BytecodeDescriptor.parseMethod(descriptor, loader);
<i>1135</i>&nbsp;        Class&lt;?&gt; rtype = types.remove(types.size() - 1);
<i>1136</i>&nbsp;        Class&lt;?&gt;[] ptypes = listToArray(types);
<i>1137</i>&nbsp;        return makeImpl(rtype, ptypes, true);
<i>1138</i>&nbsp;    }
<i>1139</i>&nbsp;
<i>1140</i>&nbsp;    /**
<i>1141</i>&nbsp;     * Produces a bytecode descriptor representation of the method type.
<i>1142</i>&nbsp;     * &lt;p&gt;
<i>1143</i>&nbsp;     * Note that this is not a strict inverse of {@link #fromMethodDescriptorString fromMethodDescriptorString}.
<i>1144</i>&nbsp;     * Two distinct classes which share a common name but have different class loaders
<i>1145</i>&nbsp;     * will appear identical when viewed within descriptor strings.
<i>1146</i>&nbsp;     * &lt;p&gt;
<i>1147</i>&nbsp;     * This method is included for the benefit of applications that must
<b class="nc"><i>1148</i>&nbsp;     * generate bytecodes that process method handles and {@code invokedynamic}.</b>
<i>1149</i>&nbsp;     * {@link #fromMethodDescriptorString(java.lang.String, java.lang.ClassLoader) fromMethodDescriptorString},
<b class="nc"><i>1150</i>&nbsp;     * because the latter requires a suitable class loader argument.</b>
<b class="nc"><i>1151</i>&nbsp;     * @return the bytecode type descriptor representation</b>
<i>1152</i>&nbsp;     */
<i>1153</i>&nbsp;    public String toMethodDescriptorString() {
<i>1154</i>&nbsp;        String desc = methodDescriptor;
<b class="nc"><i>1155</i>&nbsp;        if (desc == null) {</b>
<b class="nc"><i>1156</i>&nbsp;            desc = BytecodeDescriptor.unparseMethod(this.rtype, this.ptypes);</b>
<i>1157</i>&nbsp;            methodDescriptor = desc;
<b class="nc"><i>1158</i>&nbsp;        }</b>
<b class="nc"><i>1159</i>&nbsp;        return desc;</b>
<i>1160</i>&nbsp;    }
<i>1161</i>&nbsp;
<i>1162</i>&nbsp;    /*non-public*/ static String toFieldDescriptorString(Class&lt;?&gt; cls) {
<i>1163</i>&nbsp;        return BytecodeDescriptor.unparse(cls);
<i>1164</i>&nbsp;    }
<i>1165</i>&nbsp;
<b class="nc"><i>1166</i>&nbsp;    /// Serialization.</b>
<b class="nc"><i>1167</i>&nbsp;</b>
<b class="nc"><i>1168</i>&nbsp;    /**</b>
<i>1169</i>&nbsp;     * There are no serializable fields for {@code MethodType}.
<i>1170</i>&nbsp;     */
<i>1171</i>&nbsp;    private static final java.io.ObjectStreamField[] serialPersistentFields = { };
<i>1172</i>&nbsp;
<b class="nc"><i>1173</i>&nbsp;    /**</b>
<b class="nc"><i>1174</i>&nbsp;     * Save the {@code MethodType} instance to a stream.</b>
<b class="nc"><i>1175</i>&nbsp;     *</b>
<b class="nc"><i>1176</i>&nbsp;     * @serialData</b>
<i>1177</i>&nbsp;     * For portability, the serialized format does not refer to named fields.
<i>1178</i>&nbsp;     * Instead, the return type and parameter type arrays are written directly
<i>1179</i>&nbsp;     * from the {@code writeObject} method, using two calls to {@code s.writeObject}
<i>1180</i>&nbsp;     * as follows:
<i>1181</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1182</i>&nbsp;s.writeObject(this.returnType());
<b class="nc"><i>1183</i>&nbsp;s.writeObject(this.parameterArray());</b>
<b class="nc"><i>1184</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1185</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1186</i>&nbsp;     * The deserialized field values are checked as if they were</b>
<b class="nc"><i>1187</i>&nbsp;     * provided to the factory method {@link #methodType(Class,Class[]) methodType}.</b>
<b class="nc"><i>1188</i>&nbsp;     * For example, null values, or {@code void} parameter types,</b>
<b class="nc"><i>1189</i>&nbsp;     * will lead to exceptions during deserialization.</b>
<i>1190</i>&nbsp;     * @param s the stream to write the object to
<i>1191</i>&nbsp;     * @throws java.io.IOException if there is a problem writing the object
<i>1192</i>&nbsp;     */
<i>1193</i>&nbsp;    private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
<i>1194</i>&nbsp;        s.defaultWriteObject();  // requires serialPersistentFields to be an empty array
<i>1195</i>&nbsp;        s.writeObject(returnType());
<i>1196</i>&nbsp;        s.writeObject(parameterArray());
<i>1197</i>&nbsp;    }
<i>1198</i>&nbsp;
<i>1199</i>&nbsp;    /**
<i>1200</i>&nbsp;     * Reconstitute the {@code MethodType} instance from a stream (that is,
<b class="nc"><i>1201</i>&nbsp;     * deserialize it).</b>
<i>1202</i>&nbsp;     * This instance is a scratch object with bogus final fields.
<i>1203</i>&nbsp;     * It provides the parameters to the factory method called by
<i>1204</i>&nbsp;     * {@link #readResolve readResolve}.
<i>1205</i>&nbsp;     * After that call it is discarded.
<i>1206</i>&nbsp;     * @param s the stream to read the object from
<i>1207</i>&nbsp;     * @throws java.io.IOException if there is a problem reading the object
<i>1208</i>&nbsp;     * @throws ClassNotFoundException if one of the component classes cannot be resolved
<i>1209</i>&nbsp;     * @see #readResolve
<i>1210</i>&nbsp;     * @see #writeObject
<i>1211</i>&nbsp;     */
<i>1212</i>&nbsp;    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<i>1213</i>&nbsp;        // Assign temporary defaults in case this object escapes
<b class="nc"><i>1214</i>&nbsp;        MethodType_init(void.class, NO_PTYPES);</b>
<b class="nc"><i>1215</i>&nbsp;</b>
<b class="nc"><i>1216</i>&nbsp;        s.defaultReadObject();  // requires serialPersistentFields to be an empty array</b>
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;        Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();
<i>1219</i>&nbsp;        Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();
<i>1220</i>&nbsp;        parameterArray = parameterArray.clone();  // make sure it is unshared
<i>1221</i>&nbsp;
<i>1222</i>&nbsp;        // Assign deserialized values
<i>1223</i>&nbsp;        MethodType_init(returnType, parameterArray);
<i>1224</i>&nbsp;    }
<i>1225</i>&nbsp;
<i>1226</i>&nbsp;    // Initialization of state for deserialization only
<b class="nc"><i>1227</i>&nbsp;    private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {</b>
<b class="nc"><i>1228</i>&nbsp;        // In order to communicate these values to readResolve, we must</b>
<i>1229</i>&nbsp;        // store them into the implementation-specific final fields.
<b class="nc"><i>1230</i>&nbsp;        checkRtype(rtype);</b>
<b class="nc"><i>1231</i>&nbsp;        checkPtypes(ptypes);</b>
<b class="nc"><i>1232</i>&nbsp;        UNSAFE.putObject(this, OffsetHolder.rtypeOffset, rtype);</b>
<b class="nc"><i>1233</i>&nbsp;        UNSAFE.putObject(this, OffsetHolder.ptypesOffset, ptypes);</b>
<b class="nc"><i>1234</i>&nbsp;    }</b>
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;    // Support for resetting final fields while deserializing. Implement Holder
<b class="nc"><i>1237</i>&nbsp;    // pattern to make the rarely needed offset calculation lazy.</b>
<i>1238</i>&nbsp;    private static class OffsetHolder {
<i>1239</i>&nbsp;        static final long rtypeOffset
<i>1240</i>&nbsp;                = UNSAFE.objectFieldOffset(MethodType.class, &quot;rtype&quot;);
<i>1241</i>&nbsp;
<i>1242</i>&nbsp;        static final long ptypesOffset
<i>1243</i>&nbsp;                = UNSAFE.objectFieldOffset(MethodType.class, &quot;ptypes&quot;);
<i>1244</i>&nbsp;    }
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;    /**
<i>1247</i>&nbsp;     * Resolves and initializes a {@code MethodType} object
<i>1248</i>&nbsp;     * after serialization.
<i>1249</i>&nbsp;     * @return the fully initialized {@code MethodType} object
<b class="nc"><i>1250</i>&nbsp;     */</b>
<i>1251</i>&nbsp;    private Object readResolve() {
<i>1252</i>&nbsp;        // Do not use a trusted path for deserialization:
<i>1253</i>&nbsp;        //    return makeImpl(rtype, ptypes, true);
<i>1254</i>&nbsp;        // Verify all operands, and make sure ptypes is unshared:
<i>1255</i>&nbsp;        try {
<i>1256</i>&nbsp;            return methodType(rtype, ptypes);
<b class="nc"><i>1257</i>&nbsp;        } finally {</b>
<i>1258</i>&nbsp;            // Re-assign defaults in case this object escapes
<b class="nc"><i>1259</i>&nbsp;            MethodType_init(void.class, NO_PTYPES);</b>
<b class="nc"><i>1260</i>&nbsp;        }</b>
<b class="nc"><i>1261</i>&nbsp;    }</b>
<b class="nc"><i>1262</i>&nbsp;</b>
<b class="nc"><i>1263</i>&nbsp;    /**</b>
<i>1264</i>&nbsp;     * Simple implementation of weak concurrent intern set.
<i>1265</i>&nbsp;     *
<i>1266</i>&nbsp;     * @param &lt;T&gt; interned type
<i>1267</i>&nbsp;     */
<b class="nc"><i>1268</i>&nbsp;    private static class ConcurrentWeakInternSet&lt;T&gt; {</b>
<b class="nc"><i>1269</i>&nbsp;</b>
<i>1270</i>&nbsp;        private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
<i>1271</i>&nbsp;        private final ReferenceQueue&lt;T&gt; stale;
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;        public ConcurrentWeakInternSet() {
<i>1274</i>&nbsp;            this.map = new ConcurrentHashMap&lt;&gt;(512);
<i>1275</i>&nbsp;            this.stale = new ReferenceQueue&lt;&gt;();
<i>1276</i>&nbsp;        }
<i>1277</i>&nbsp;
<b class="nc"><i>1278</i>&nbsp;        /**</b>
<b class="nc"><i>1279</i>&nbsp;         * Get the existing interned element.</b>
<i>1280</i>&nbsp;         * This method returns null if no element is interned.
<i>1281</i>&nbsp;         *
<i>1282</i>&nbsp;         * @param elem element to look up
<b class="nc"><i>1283</i>&nbsp;         * @return the interned element</b>
<b class="nc"><i>1284</i>&nbsp;         */</b>
<i>1285</i>&nbsp;        public T get(T elem) {
<i>1286</i>&nbsp;            if (elem == null) throw new NullPointerException();
<i>1287</i>&nbsp;            expungeStaleElements();
<i>1288</i>&nbsp;
<b class="nc"><i>1289</i>&nbsp;            WeakEntry&lt;T&gt; value = map.get(new WeakEntry&lt;&gt;(elem));</b>
<b class="nc"><i>1290</i>&nbsp;            if (value != null) {</b>
<b class="nc"><i>1291</i>&nbsp;                T res = value.get();</b>
<b class="nc"><i>1292</i>&nbsp;                if (res != null) {</b>
<i>1293</i>&nbsp;                    return res;
<b class="nc"><i>1294</i>&nbsp;                }</b>
<i>1295</i>&nbsp;            }
<i>1296</i>&nbsp;            return null;
<i>1297</i>&nbsp;        }
<i>1298</i>&nbsp;
<b class="nc"><i>1299</i>&nbsp;        /**</b>
<i>1300</i>&nbsp;         * Interns the element.
<i>1301</i>&nbsp;         * Always returns non-null element, matching the one in the intern set.
<i>1302</i>&nbsp;         * Under the race against another add(), it can return &lt;i&gt;different&lt;/i&gt;
<i>1303</i>&nbsp;         * element, if another thread beats us to interning it.
<i>1304</i>&nbsp;         *
<i>1305</i>&nbsp;         * @param elem element to add
<i>1306</i>&nbsp;         * @return element that was actually added
<i>1307</i>&nbsp;         */
<i>1308</i>&nbsp;        public T add(T elem) {
<i>1309</i>&nbsp;            if (elem == null) throw new NullPointerException();
<i>1310</i>&nbsp;
<i>1311</i>&nbsp;            // Playing double race here, and so spinloop is required.
<i>1312</i>&nbsp;            // First race is with two concurrent updaters.
<i>1313</i>&nbsp;            // Second race is with GC purging weak ref under our feet.
<i>1314</i>&nbsp;            // Hopefully, we almost always end up with a single pass.
<i>1315</i>&nbsp;            T interned;
<i>1316</i>&nbsp;            WeakEntry&lt;T&gt; e = new WeakEntry&lt;&gt;(elem, stale);
<i>1317</i>&nbsp;            do {
<i>1318</i>&nbsp;                expungeStaleElements();
<i>1319</i>&nbsp;                WeakEntry&lt;T&gt; exist = map.putIfAbsent(e, e);
<i>1320</i>&nbsp;                interned = (exist == null) ? elem : exist.get();
<i>1321</i>&nbsp;            } while (interned == null);
<i>1322</i>&nbsp;            return interned;
<i>1323</i>&nbsp;        }
<i>1324</i>&nbsp;
<i>1325</i>&nbsp;        private void expungeStaleElements() {
<i>1326</i>&nbsp;            Reference&lt;? extends T&gt; reference;
<i>1327</i>&nbsp;            while ((reference = stale.poll()) != null) {
<i>1328</i>&nbsp;                map.remove(reference);
<i>1329</i>&nbsp;            }
<i>1330</i>&nbsp;        }
<i>1331</i>&nbsp;
<i>1332</i>&nbsp;        private static class WeakEntry&lt;T&gt; extends WeakReference&lt;T&gt; {
<i>1333</i>&nbsp;
<i>1334</i>&nbsp;            public final int hashcode;
<i>1335</i>&nbsp;
<i>1336</i>&nbsp;            public WeakEntry(T key, ReferenceQueue&lt;T&gt; queue) {
<i>1337</i>&nbsp;                super(key, queue);
<i>1338</i>&nbsp;                hashcode = key.hashCode();
<i>1339</i>&nbsp;            }
<i>1340</i>&nbsp;
<i>1341</i>&nbsp;            public WeakEntry(T key) {
<i>1342</i>&nbsp;                super(key);
<i>1343</i>&nbsp;                hashcode = key.hashCode();
<i>1344</i>&nbsp;            }
<i>1345</i>&nbsp;
<i>1346</i>&nbsp;            @Override
<i>1347</i>&nbsp;            public boolean equals(Object obj) {
<i>1348</i>&nbsp;                if (obj instanceof WeakEntry) {
<i>1349</i>&nbsp;                    Object that = ((WeakEntry) obj).get();
<i>1350</i>&nbsp;                    Object mine = get();
<i>1351</i>&nbsp;                    return (that == null || mine == null) ? (this == obj) : mine.equals(that);
<i>1352</i>&nbsp;                }
<i>1353</i>&nbsp;                return false;
<i>1354</i>&nbsp;            }
<i>1355</i>&nbsp;
<i>1356</i>&nbsp;            @Override
<i>1357</i>&nbsp;            public int hashCode() {
<i>1358</i>&nbsp;                return hashcode;
<i>1359</i>&nbsp;            }
<i>1360</i>&nbsp;
<i>1361</i>&nbsp;        }
<i>1362</i>&nbsp;    }
<i>1363</i>&nbsp;
<i>1364</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
