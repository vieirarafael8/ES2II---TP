


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: MethodHandles</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang.invoke</a> ]
</div>

<h1>Coverage Summary for Class: MethodHandles (java.lang.invoke)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodHandles</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 325)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodHandles$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodHandles$Lookup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 360)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 101)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 686)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang.invoke;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>29</i>&nbsp;import jdk.internal.module.IllegalAccessLogger;
<i>30</i>&nbsp;import jdk.internal.org.objectweb.asm.ClassReader;
<i>31</i>&nbsp;import jdk.internal.reflect.CallerSensitive;
<i>32</i>&nbsp;import jdk.internal.reflect.Reflection;
<i>33</i>&nbsp;import jdk.internal.vm.annotation.ForceInline;
<i>34</i>&nbsp;import sun.invoke.util.ValueConversions;
<i>35</i>&nbsp;import sun.invoke.util.VerifyAccess;
<i>36</i>&nbsp;import sun.invoke.util.Wrapper;
<i>37</i>&nbsp;import sun.reflect.misc.ReflectUtil;
<i>38</i>&nbsp;import sun.security.util.SecurityConstants;
<i>39</i>&nbsp;
<i>40</i>&nbsp;import java.lang.invoke.LambdaForm.BasicType;
<i>41</i>&nbsp;import java.lang.reflect.Constructor;
<i>42</i>&nbsp;import java.lang.reflect.Field;
<i>43</i>&nbsp;import java.lang.reflect.Member;
<i>44</i>&nbsp;import java.lang.reflect.Method;
<i>45</i>&nbsp;import java.lang.reflect.Modifier;
<i>46</i>&nbsp;import java.lang.reflect.ReflectPermission;
<i>47</i>&nbsp;import java.nio.ByteOrder;
<i>48</i>&nbsp;import java.security.AccessController;
<i>49</i>&nbsp;import java.security.PrivilegedAction;
<i>50</i>&nbsp;import java.security.ProtectionDomain;
<i>51</i>&nbsp;import java.util.ArrayList;
<i>52</i>&nbsp;import java.util.Arrays;
<i>53</i>&nbsp;import java.util.BitSet;
<i>54</i>&nbsp;import java.util.Iterator;
<i>55</i>&nbsp;import java.util.List;
<i>56</i>&nbsp;import java.util.Objects;
<i>57</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>58</i>&nbsp;import java.util.stream.Collectors;
<i>59</i>&nbsp;import java.util.stream.Stream;
<i>60</i>&nbsp;
<b class="nc"><i>61</i>&nbsp;import static java.lang.invoke.MethodHandleImpl.Intrinsic;</b>
<i>62</i>&nbsp;import static java.lang.invoke.MethodHandleNatives.Constants.*;
<b class="nc"><i>63</i>&nbsp;import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;</b>
<i>64</i>&nbsp;import static java.lang.invoke.MethodType.methodType;
<b class="nc"><i>65</i>&nbsp;</b>
<b class="nc"><i>66</i>&nbsp;/**</b>
<i>67</i>&nbsp; * This class consists exclusively of static methods that operate on or return
<i>68</i>&nbsp; * method handles. They fall into several categories:
<i>69</i>&nbsp; * &lt;ul&gt;
<i>70</i>&nbsp; * &lt;li&gt;Lookup methods which help create method handles for methods and fields.
<i>71</i>&nbsp; * &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
<i>72</i>&nbsp; * &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
<i>73</i>&nbsp; * &lt;/ul&gt;
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * @author John Rose, JSR 292 EG
<i>76</i>&nbsp; * @since 1.7
<i>77</i>&nbsp; */
<i>78</i>&nbsp;public class MethodHandles {
<i>79</i>&nbsp;
<i>80</i>&nbsp;    private MethodHandles() { }  // do not instantiate
<i>81</i>&nbsp;
<i>82</i>&nbsp;    static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
<i>83</i>&nbsp;
<i>84</i>&nbsp;    // See IMPL_LOOKUP below.
<i>85</i>&nbsp;
<i>86</i>&nbsp;    //// Method handle creation from ordinary methods.
<i>87</i>&nbsp;
<i>88</i>&nbsp;    /**
<i>89</i>&nbsp;     * Returns a {@link Lookup lookup object} with
<i>90</i>&nbsp;     * full capabilities to emulate all supported bytecode behaviors of the caller.
<i>91</i>&nbsp;     * These capabilities include &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt; to the caller.
<i>92</i>&nbsp;     * Factory methods on the lookup object can create
<i>93</i>&nbsp;     * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handles&lt;/a&gt;
<b class="nc"><i>94</i>&nbsp;     * for any member that the caller has access to via bytecodes,</b>
<i>95</i>&nbsp;     * including protected and private fields and methods.
<i>96</i>&nbsp;     * This lookup object is a &lt;em&gt;capability&lt;/em&gt; which may be delegated to trusted agents.
<i>97</i>&nbsp;     * Do not store it in place where untrusted code can access it.
<i>98</i>&nbsp;     * &lt;p&gt;
<i>99</i>&nbsp;     * This method is caller sensitive, which means that it may return different
<i>100</i>&nbsp;     * values to different callers.
<i>101</i>&nbsp;     * @return a lookup object for the caller of this method, with private access
<i>102</i>&nbsp;     */
<i>103</i>&nbsp;    @CallerSensitive
<i>104</i>&nbsp;    @ForceInline // to ensure Reflection.getCallerClass optimization
<i>105</i>&nbsp;    public static Lookup lookup() {
<i>106</i>&nbsp;        return new Lookup(Reflection.getCallerClass());
<i>107</i>&nbsp;    }
<i>108</i>&nbsp;
<i>109</i>&nbsp;    /**
<i>110</i>&nbsp;     * This reflected$lookup method is the alternate implementation of
<i>111</i>&nbsp;     * the lookup method when being invoked by reflection.
<i>112</i>&nbsp;     */
<i>113</i>&nbsp;    @CallerSensitive
<i>114</i>&nbsp;    private static Lookup reflected$lookup() {
<i>115</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>116</i>&nbsp;        if (caller.getClassLoader() == null) {
<i>117</i>&nbsp;            throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+caller);
<b class="nc"><i>118</i>&nbsp;        }</b>
<i>119</i>&nbsp;        return new Lookup(caller);
<i>120</i>&nbsp;    }
<i>121</i>&nbsp;
<i>122</i>&nbsp;    /**
<i>123</i>&nbsp;     * Returns a {@link Lookup lookup object} which is trusted minimally.
<i>124</i>&nbsp;     * The lookup has the {@code PUBLIC} and {@code UNCONDITIONAL} modes.
<i>125</i>&nbsp;     * It can only be used to create method handles to public members of
<i>126</i>&nbsp;     * public classes in packages that are exported unconditionally.
<i>127</i>&nbsp;     * &lt;p&gt;
<i>128</i>&nbsp;     * As a matter of pure convention, the {@linkplain Lookup#lookupClass() lookup class}
<i>129</i>&nbsp;     * of this lookup object will be {@link java.lang.Object}.
<i>130</i>&nbsp;     *
<i>131</i>&nbsp;     * @apiNote The use of Object is conventional, and because the lookup modes are
<i>132</i>&nbsp;     * limited, there is no special access provided to the internals of Object, its package
<i>133</i>&nbsp;     * or its module. Consequently, the lookup context of this lookup object will be the
<i>134</i>&nbsp;     * bootstrap class loader, which means it cannot find user classes.
<i>135</i>&nbsp;     *
<i>136</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>137</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<i>138</i>&nbsp;     * The lookup class can be changed to any other class {@code C} using an expression of the form
<i>139</i>&nbsp;     * {@link Lookup#in publicLookup().in(C.class)}.
<i>140</i>&nbsp;     * but may change the lookup context by virtue of changing the class loader.
<i>141</i>&nbsp;     * A public lookup object is always subject to
<i>142</i>&nbsp;     * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;security manager checks&lt;/a&gt;.
<i>143</i>&nbsp;     * Also, it cannot access
<i>144</i>&nbsp;     * &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive methods&lt;/a&gt;.
<b class="nc"><i>145</i>&nbsp;     * @return a lookup object which is trusted minimally</b>
<b class="nc"><i>146</i>&nbsp;     *</b>
<b class="nc"><i>147</i>&nbsp;     * @revised 9</b>
<b class="nc"><i>148</i>&nbsp;     * @spec JPMS</b>
<i>149</i>&nbsp;     */
<i>150</i>&nbsp;    public static Lookup publicLookup() {
<b class="nc"><i>151</i>&nbsp;        return Lookup.PUBLIC_LOOKUP;</b>
<i>152</i>&nbsp;    }
<i>153</i>&nbsp;
<i>154</i>&nbsp;    /**
<i>155</i>&nbsp;     * Returns a {@link Lookup lookup object} with full capabilities to emulate all
<i>156</i>&nbsp;     * supported bytecode behaviors, including &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;
<i>157</i>&nbsp;     * private access&lt;/a&gt;, on a target class.
<i>158</i>&nbsp;     * This method checks that a caller, specified as a {@code Lookup} object, is allowed to
<i>159</i>&nbsp;     * do &lt;em&gt;deep reflection&lt;/em&gt; on the target class. If {@code m1} is the module containing
<i>160</i>&nbsp;     * the {@link Lookup#lookupClass() lookup class}, and {@code m2} is the module containing
<i>161</i>&nbsp;     * the target class, then this check ensures that
<i>162</i>&nbsp;     * &lt;ul&gt;
<i>163</i>&nbsp;     *     &lt;li&gt;{@code m1} {@link Module#canRead reads} {@code m2}.&lt;/li&gt;
<i>164</i>&nbsp;     *     &lt;li&gt;{@code m2} {@link Module#isOpen(String,Module) opens} the package containing
<i>165</i>&nbsp;     *     the target class to at least {@code m1}.&lt;/li&gt;
<i>166</i>&nbsp;     *     &lt;li&gt;The lookup has the {@link Lookup#MODULE MODULE} lookup mode.&lt;/li&gt;
<i>167</i>&nbsp;     * &lt;/ul&gt;
<i>168</i>&nbsp;     * &lt;p&gt;
<i>169</i>&nbsp;     * If there is a security manager, its {@code checkPermission} method is called to
<i>170</i>&nbsp;     * check {@code ReflectPermission(&quot;suppressAccessChecks&quot;)}.
<i>171</i>&nbsp;     * @apiNote The {@code MODULE} lookup mode serves to authenticate that the lookup object
<i>172</i>&nbsp;     * was created by code in the caller module (or derived from a lookup object originally
<i>173</i>&nbsp;     * created by the caller). A lookup object with the {@code MODULE} lookup mode can be
<i>174</i>&nbsp;     * shared with trusted parties without giving away {@code PRIVATE} and {@code PACKAGE}
<i>175</i>&nbsp;     * access to the caller.
<i>176</i>&nbsp;     * @param targetClass the target class
<i>177</i>&nbsp;     * @param lookup the caller lookup object
<i>178</i>&nbsp;     * @return a lookup object for the target class, with private access
<i>179</i>&nbsp;     * @throws IllegalArgumentException if {@code targetClass} is a primitve type or array class
<i>180</i>&nbsp;     * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
<i>181</i>&nbsp;     * @throws IllegalAccessException if the access check specified above fails
<i>182</i>&nbsp;     * @throws SecurityException if denied by the security manager
<i>183</i>&nbsp;     * @since 9
<i>184</i>&nbsp;     * @spec JPMS
<i>185</i>&nbsp;     * @see Lookup#dropLookupMode
<i>186</i>&nbsp;     */
<i>187</i>&nbsp;    public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup lookup) throws IllegalAccessException {
<i>188</i>&nbsp;        SecurityManager sm = System.getSecurityManager();
<i>189</i>&nbsp;        if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
<i>190</i>&nbsp;        if (targetClass.isPrimitive())
<i>191</i>&nbsp;            throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
<i>192</i>&nbsp;        if (targetClass.isArray())
<i>193</i>&nbsp;            throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
<i>194</i>&nbsp;        Module targetModule = targetClass.getModule();
<i>195</i>&nbsp;        Module callerModule = lookup.lookupClass().getModule();
<i>196</i>&nbsp;        if (!callerModule.canRead(targetModule))
<i>197</i>&nbsp;            throw new IllegalAccessException(callerModule + &quot; does not read &quot; + targetModule);
<i>198</i>&nbsp;        if (targetModule.isNamed()) {
<i>199</i>&nbsp;            String pn = targetClass.getPackageName();
<i>200</i>&nbsp;            assert pn.length() &gt; 0 : &quot;unnamed package cannot be in named module&quot;;
<i>201</i>&nbsp;            if (!targetModule.isOpen(pn, callerModule))
<i>202</i>&nbsp;                throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);
<i>203</i>&nbsp;        }
<i>204</i>&nbsp;        if ((lookup.lookupModes() &amp; Lookup.MODULE) == 0)
<i>205</i>&nbsp;            throw new IllegalAccessException(&quot;lookup does not have MODULE lookup mode&quot;);
<i>206</i>&nbsp;        if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
<i>207</i>&nbsp;            IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
<i>208</i>&nbsp;            if (logger != null) {
<i>209</i>&nbsp;                logger.logIfOpenedForIllegalAccess(lookup, targetClass);
<i>210</i>&nbsp;            }
<i>211</i>&nbsp;        }
<i>212</i>&nbsp;        return new Lookup(targetClass);
<i>213</i>&nbsp;    }
<i>214</i>&nbsp;
<i>215</i>&nbsp;    /**
<i>216</i>&nbsp;     * Performs an unchecked &quot;crack&quot; of a
<i>217</i>&nbsp;     * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
<i>218</i>&nbsp;     * The result is as if the user had obtained a lookup object capable enough
<i>219</i>&nbsp;     * to crack the target method handle, called
<i>220</i>&nbsp;     * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
<i>221</i>&nbsp;     * on the target to obtain its symbolic reference, and then called
<i>222</i>&nbsp;     * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
<i>223</i>&nbsp;     * to resolve the symbolic reference to a member.
<i>224</i>&nbsp;     * &lt;p&gt;
<i>225</i>&nbsp;     * If there is a security manager, its {@code checkPermission} method
<i>226</i>&nbsp;     * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
<i>227</i>&nbsp;     * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
<i>228</i>&nbsp;     * @param target a direct method handle to crack into symbolic reference components
<i>229</i>&nbsp;     * @param expected a class object representing the desired result type {@code T}
<i>230</i>&nbsp;     * @return a reference to the method, constructor, or field object
<i>231</i>&nbsp;     * @exception SecurityException if the caller is not privileged to call {@code setAccessible}
<i>232</i>&nbsp;     * @exception NullPointerException if either argument is {@code null}
<i>233</i>&nbsp;     * @exception IllegalArgumentException if the target is not a direct method handle
<i>234</i>&nbsp;     * @exception ClassCastException if the member is not of the expected type
<i>235</i>&nbsp;     * @since 1.8
<i>236</i>&nbsp;     */
<i>237</i>&nbsp;    public static &lt;T extends Member&gt; T
<i>238</i>&nbsp;    reflectAs(Class&lt;T&gt; expected, MethodHandle target) {
<i>239</i>&nbsp;        SecurityManager smgr = System.getSecurityManager();
<i>240</i>&nbsp;        if (smgr != null)  smgr.checkPermission(ACCESS_PERMISSION);
<i>241</i>&nbsp;        Lookup lookup = Lookup.IMPL_LOOKUP;  // use maximally privileged lookup
<i>242</i>&nbsp;        return lookup.revealDirect(target).reflectAs(expected, lookup);
<i>243</i>&nbsp;    }
<i>244</i>&nbsp;    // Copied from AccessibleObject, as used by Method.setAccessible, etc.:
<i>245</i>&nbsp;    private static final java.security.Permission ACCESS_PERMISSION =
<i>246</i>&nbsp;        new ReflectPermission(&quot;suppressAccessChecks&quot;);
<i>247</i>&nbsp;
<i>248</i>&nbsp;    /**
<i>249</i>&nbsp;     * A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
<i>250</i>&nbsp;     * when the creation requires access checking.
<i>251</i>&nbsp;     * Method handles do not perform
<i>252</i>&nbsp;     * access checks when they are called, but rather when they are created.
<i>253</i>&nbsp;     * Therefore, method handle access
<i>254</i>&nbsp;     * restrictions must be enforced when a method handle is created.
<i>255</i>&nbsp;     * The caller class against which those restrictions are enforced
<i>256</i>&nbsp;     * is known as the {@linkplain #lookupClass() lookup class}.
<i>257</i>&nbsp;     * &lt;p&gt;
<i>258</i>&nbsp;     * A lookup class which needs to create method handles will call
<i>259</i>&nbsp;     * {@link MethodHandles#lookup() MethodHandles.lookup} to create a factory for itself.
<i>260</i>&nbsp;     * When the {@code Lookup} factory object is created, the identity of the lookup class is
<i>261</i>&nbsp;     * determined, and securely stored in the {@code Lookup} object.
<i>262</i>&nbsp;     * The lookup class (or its delegates) may then use factory methods
<i>263</i>&nbsp;     * on the {@code Lookup} object to create method handles for access-checked members.
<i>264</i>&nbsp;     * This includes all methods, constructors, and fields which are allowed to the lookup class,
<i>265</i>&nbsp;     * even private ones.
<i>266</i>&nbsp;     *
<i>267</i>&nbsp;     * &lt;h1&gt;&lt;a id=&quot;lookups&quot;&gt;&lt;/a&gt;Lookup Factory Methods&lt;/h1&gt;
<i>268</i>&nbsp;     * The factory methods on a {@code Lookup} object correspond to all major
<i>269</i>&nbsp;     * use cases for methods, constructors, and fields.
<i>270</i>&nbsp;     * Each method handle created by a factory method is the functional
<i>271</i>&nbsp;     * equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
<i>272</i>&nbsp;     * (Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)
<i>273</i>&nbsp;     * Here is a summary of the correspondence between these factory methods and
<i>274</i>&nbsp;     * the behavior of the resulting method handles:
<i>275</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<i>276</i>&nbsp;     * &lt;caption style=&quot;display:none&quot;&gt;lookup method behaviors&lt;/caption&gt;
<i>277</i>&nbsp;     * &lt;thead&gt;
<i>278</i>&nbsp;     * &lt;tr&gt;
<i>279</i>&nbsp;     *     &lt;th scope=&quot;col&quot;&gt;&lt;a id=&quot;equiv&quot;&gt;&lt;/a&gt;lookup expression&lt;/th&gt;
<i>280</i>&nbsp;     *     &lt;th scope=&quot;col&quot;&gt;member&lt;/th&gt;
<i>281</i>&nbsp;     *     &lt;th scope=&quot;col&quot;&gt;bytecode behavior&lt;/th&gt;
<i>282</i>&nbsp;     * &lt;/tr&gt;
<i>283</i>&nbsp;     * &lt;/thead&gt;
<i>284</i>&nbsp;     * &lt;tbody&gt;
<i>285</i>&nbsp;     * &lt;tr&gt;
<i>286</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<i>287</i>&nbsp;     *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) this.f;}&lt;/td&gt;
<i>288</i>&nbsp;     * &lt;/tr&gt;
<i>289</i>&nbsp;     * &lt;tr&gt;
<i>290</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<i>291</i>&nbsp;     *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (T) C.f;}&lt;/td&gt;
<i>292</i>&nbsp;     * &lt;/tr&gt;
<i>293</i>&nbsp;     * &lt;tr&gt;
<i>294</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<i>295</i>&nbsp;     *     &lt;td&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code this.f = x;}&lt;/td&gt;
<i>296</i>&nbsp;     * &lt;/tr&gt;
<i>297</i>&nbsp;     * &lt;tr&gt;
<i>298</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,&quot;f&quot;,FT.class)}&lt;/th&gt;
<i>299</i>&nbsp;     *     &lt;td&gt;{@code static}&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code C.f = arg;}&lt;/td&gt;
<i>300</i>&nbsp;     * &lt;/tr&gt;
<i>301</i>&nbsp;     * &lt;tr&gt;
<i>302</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
<i>303</i>&nbsp;     *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) this.m(arg*);}&lt;/td&gt;
<i>304</i>&nbsp;     * &lt;/tr&gt;
<i>305</i>&nbsp;     * &lt;tr&gt;
<i>306</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,&quot;m&quot;,MT)}&lt;/th&gt;
<i>307</i>&nbsp;     *     &lt;td&gt;{@code static}&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) C.m(arg*);}&lt;/td&gt;
<i>308</i>&nbsp;     * &lt;/tr&gt;
<i>309</i>&nbsp;     * &lt;tr&gt;
<i>310</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,&quot;m&quot;,MT,this.class)}&lt;/th&gt;
<i>311</i>&nbsp;     *     &lt;td&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) super.m(arg*);}&lt;/td&gt;
<i>312</i>&nbsp;     * &lt;/tr&gt;
<i>313</i>&nbsp;     * &lt;tr&gt;
<i>314</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)}&lt;/th&gt;
<i>315</i>&nbsp;     *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code new C(arg*);}&lt;/td&gt;
<i>316</i>&nbsp;     * &lt;/tr&gt;
<i>317</i>&nbsp;     * &lt;tr&gt;
<i>318</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)}&lt;/th&gt;
<i>319</i>&nbsp;     *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code (FT) aField.get(thisOrNull);}&lt;/td&gt;
<i>320</i>&nbsp;     * &lt;/tr&gt;
<i>321</i>&nbsp;     * &lt;tr&gt;
<i>322</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)}&lt;/th&gt;
<i>323</i>&nbsp;     *     &lt;td&gt;({@code static})?&lt;br&gt;{@code FT f;}&lt;/td&gt;&lt;td&gt;{@code aField.set(thisOrNull, arg);}&lt;/td&gt;
<i>324</i>&nbsp;     * &lt;/tr&gt;
<i>325</i>&nbsp;     * &lt;tr&gt;
<i>326</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
<i>327</i>&nbsp;     *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
<i>328</i>&nbsp;     * &lt;/tr&gt;
<i>329</i>&nbsp;     * &lt;tr&gt;
<i>330</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)}&lt;/th&gt;
<i>331</i>&nbsp;     *     &lt;td&gt;{@code C(A*);}&lt;/td&gt;&lt;td&gt;{@code (C) aConstructor.newInstance(arg*);}&lt;/td&gt;
<i>332</i>&nbsp;     * &lt;/tr&gt;
<i>333</i>&nbsp;     * &lt;tr&gt;
<i>334</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)}&lt;/th&gt;
<i>335</i>&nbsp;     *     &lt;td&gt;({@code static})?&lt;br&gt;{@code T m(A*);}&lt;/td&gt;&lt;td&gt;{@code (T) aMethod.invoke(thisOrNull, arg*);}&lt;/td&gt;
<i>336</i>&nbsp;     * &lt;/tr&gt;
<i>337</i>&nbsp;     * &lt;tr&gt;
<i>338</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@link java.lang.invoke.MethodHandles.Lookup#findClass lookup.findClass(&quot;C&quot;)}&lt;/th&gt;
<i>339</i>&nbsp;     *     &lt;td&gt;{@code class C { ... }}&lt;/td&gt;&lt;td&gt;{@code C.class;}&lt;/td&gt;
<i>340</i>&nbsp;     * &lt;/tr&gt;
<i>341</i>&nbsp;     * &lt;/tbody&gt;
<i>342</i>&nbsp;     * &lt;/table&gt;
<i>343</i>&nbsp;     *
<i>344</i>&nbsp;     * Here, the type {@code C} is the class or interface being searched for a member,
<i>345</i>&nbsp;     * documented as a parameter named {@code refc} in the lookup methods.
<i>346</i>&nbsp;     * The method type {@code MT} is composed from the return type {@code T}
<i>347</i>&nbsp;     * and the sequence of argument types {@code A*}.
<i>348</i>&nbsp;     * The constructor also has a sequence of argument types {@code A*} and
<i>349</i>&nbsp;     * is deemed to return the newly-created object of type {@code C}.
<i>350</i>&nbsp;     * Both {@code MT} and the field type {@code FT} are documented as a parameter named {@code type}.
<i>351</i>&nbsp;     * The formal parameter {@code this} stands for the self-reference of type {@code C};
<i>352</i>&nbsp;     * if it is present, it is always the leading argument to the method handle invocation.
<i>353</i>&nbsp;     * (In the case of some {@code protected} members, {@code this} may be
<i>354</i>&nbsp;     * restricted in type to the lookup class; see below.)
<i>355</i>&nbsp;     * The name {@code arg} stands for all the other method handle arguments.
<i>356</i>&nbsp;     * In the code examples for the Core Reflection API, the name {@code thisOrNull}
<i>357</i>&nbsp;     * stands for a null reference if the accessed method or field is static,
<i>358</i>&nbsp;     * and {@code this} otherwise.
<i>359</i>&nbsp;     * The names {@code aMethod}, {@code aField}, and {@code aConstructor} stand
<i>360</i>&nbsp;     * for reflective objects corresponding to the given members.
<i>361</i>&nbsp;     * &lt;p&gt;
<i>362</i>&nbsp;     * The bytecode behavior for a {@code findClass} operation is a load of a constant class,
<i>363</i>&nbsp;     * as if by {@code ldc CONSTANT_Class}.
<i>364</i>&nbsp;     * The behavior is represented, not as a method handle, but directly as a {@code Class} constant.
<i>365</i>&nbsp;     * &lt;p&gt;
<i>366</i>&nbsp;     * In cases where the given member is of variable arity (i.e., a method or constructor)
<i>367</i>&nbsp;     * the returned method handle will also be of {@linkplain MethodHandle#asVarargsCollector variable arity}.
<i>368</i>&nbsp;     * In all other cases, the returned method handle will be of fixed arity.
<i>369</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>370</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<i>371</i>&nbsp;     * The equivalence between looked-up method handles and underlying
<i>372</i>&nbsp;     * class members and bytecode behaviors
<i>373</i>&nbsp;     * can break down in a few ways:
<i>374</i>&nbsp;     * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
<i>375</i>&nbsp;     * &lt;li&gt;If {@code C} is not symbolically accessible from the lookup class&#39;s loader,
<i>376</i>&nbsp;     * the lookup can still succeed, even when there is no equivalent
<i>377</i>&nbsp;     * Java expression or bytecoded constant.
<i>378</i>&nbsp;     * &lt;li&gt;Likewise, if {@code T} or {@code MT}
<i>379</i>&nbsp;     * is not symbolically accessible from the lookup class&#39;s loader,
<i>380</i>&nbsp;     * the lookup can still succeed.
<i>381</i>&nbsp;     * For example, lookups for {@code MethodHandle.invokeExact} and
<i>382</i>&nbsp;     * {@code MethodHandle.invoke} will always succeed, regardless of requested type.
<i>383</i>&nbsp;     * &lt;li&gt;If there is a security manager installed, it can forbid the lookup
<i>384</i>&nbsp;     * on various grounds (&lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;see below&lt;/a&gt;).
<i>385</i>&nbsp;     * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}
<i>386</i>&nbsp;     * constant is not subject to security manager checks.
<i>387</i>&nbsp;     * &lt;li&gt;If the looked-up method has a
<i>388</i>&nbsp;     * &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;very large arity&lt;/a&gt;,
<i>389</i>&nbsp;     * the method handle creation may fail, due to the method handle
<i>390</i>&nbsp;     * type having too many parameters.
<i>391</i>&nbsp;     * &lt;/ul&gt;
<i>392</i>&nbsp;     *
<i>393</i>&nbsp;     * &lt;h1&gt;&lt;a id=&quot;access&quot;&gt;&lt;/a&gt;Access checking&lt;/h1&gt;
<i>394</i>&nbsp;     * Access checks are applied in the factory methods of {@code Lookup},
<i>395</i>&nbsp;     * when a method handle is created.
<i>396</i>&nbsp;     * This is a key difference from the Core Reflection API, since
<i>397</i>&nbsp;     * {@link java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
<i>398</i>&nbsp;     * performs access checking against every caller, on every call.
<i>399</i>&nbsp;     * &lt;p&gt;
<i>400</i>&nbsp;     * All access checks start from a {@code Lookup} object, which
<i>401</i>&nbsp;     * compares its recorded lookup class against all requests to
<i>402</i>&nbsp;     * create method handles.
<i>403</i>&nbsp;     * A single {@code Lookup} object can be used to create any number
<i>404</i>&nbsp;     * of access-checked method handles, all checked against a single
<i>405</i>&nbsp;     * lookup class.
<i>406</i>&nbsp;     * &lt;p&gt;
<i>407</i>&nbsp;     * A {@code Lookup} object can be shared with other trusted code,
<i>408</i>&nbsp;     * such as a metaobject protocol.
<i>409</i>&nbsp;     * A shared {@code Lookup} object delegates the capability
<i>410</i>&nbsp;     * to create method handles on private members of the lookup class.
<i>411</i>&nbsp;     * Even if privileged code uses the {@code Lookup} object,
<i>412</i>&nbsp;     * the access checking is confined to the privileges of the
<i>413</i>&nbsp;     * original lookup class.
<i>414</i>&nbsp;     * &lt;p&gt;
<i>415</i>&nbsp;     * A lookup can fail, because
<i>416</i>&nbsp;     * the containing class is not accessible to the lookup class, or
<i>417</i>&nbsp;     * because the desired class member is missing, or because the
<i>418</i>&nbsp;     * desired class member is not accessible to the lookup class, or
<i>419</i>&nbsp;     * because the lookup object is not trusted enough to access the member.
<i>420</i>&nbsp;     * In any of these cases, a {@code ReflectiveOperationException} will be
<i>421</i>&nbsp;     * thrown from the attempted lookup.  The exact class will be one of
<i>422</i>&nbsp;     * the following:
<i>423</i>&nbsp;     * &lt;ul&gt;
<i>424</i>&nbsp;     * &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
<i>425</i>&nbsp;     * &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
<i>426</i>&nbsp;     * &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
<i>427</i>&nbsp;     * &lt;/ul&gt;
<i>428</i>&nbsp;     * &lt;p&gt;
<i>429</i>&nbsp;     * In general, the conditions under which a method handle may be
<i>430</i>&nbsp;     * looked up for a method {@code M} are no more restrictive than the conditions
<i>431</i>&nbsp;     * under which the lookup class could have compiled, verified, and resolved a call to {@code M}.
<i>432</i>&nbsp;     * Where the JVM would raise exceptions like {@code NoSuchMethodError},
<i>433</i>&nbsp;     * a method handle lookup will generally raise a corresponding
<i>434</i>&nbsp;     * checked exception, such as {@code NoSuchMethodException}.
<i>435</i>&nbsp;     * And the effect of invoking the method handle resulting from the lookup
<i>436</i>&nbsp;     * is &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;exactly equivalent&lt;/a&gt;
<i>437</i>&nbsp;     * to executing the compiled, verified, and resolved call to {@code M}.
<i>438</i>&nbsp;     * The same point is true of fields and constructors.
<i>439</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>440</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<i>441</i>&nbsp;     * Access checks only apply to named and reflected methods,
<i>442</i>&nbsp;     * constructors, and fields.
<i>443</i>&nbsp;     * Other method handle creation methods, such as
<i>444</i>&nbsp;     * {@link MethodHandle#asType MethodHandle.asType},
<i>445</i>&nbsp;     * do not require any access checks, and are used
<i>446</i>&nbsp;     * independently of any {@code Lookup} object.
<i>447</i>&nbsp;     * &lt;p&gt;
<i>448</i>&nbsp;     * If the desired member is {@code protected}, the usual JVM rules apply,
<i>449</i>&nbsp;     * including the requirement that the lookup class must be either be in the
<i>450</i>&nbsp;     * same package as the desired member, or must inherit that member.
<i>451</i>&nbsp;     * (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.)
<i>452</i>&nbsp;     * In addition, if the desired member is a non-static field or method
<i>453</i>&nbsp;     * in a different package, the resulting method handle may only be applied
<i>454</i>&nbsp;     * to objects of the lookup class or one of its subclasses.
<i>455</i>&nbsp;     * This requirement is enforced by narrowing the type of the leading
<i>456</i>&nbsp;     * {@code this} parameter from {@code C}
<i>457</i>&nbsp;     * (which will necessarily be a superclass of the lookup class)
<i>458</i>&nbsp;     * to the lookup class itself.
<i>459</i>&nbsp;     * &lt;p&gt;
<i>460</i>&nbsp;     * The JVM imposes a similar requirement on {@code invokespecial} instruction,
<i>461</i>&nbsp;     * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
<i>462</i>&nbsp;     * the current class.  Again, this requirement is enforced by narrowing the
<i>463</i>&nbsp;     * type of the leading parameter to the resulting method handle.
<i>464</i>&nbsp;     * (See the Java Virtual Machine Specification, section 4.10.1.9.)
<i>465</i>&nbsp;     * &lt;p&gt;
<i>466</i>&nbsp;     * The JVM represents constructors and static initializer blocks as internal methods
<i>467</i>&nbsp;     * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
<i>468</i>&nbsp;     * The internal syntax of invocation instructions allows them to refer to such internal
<i>469</i>&nbsp;     * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
<i>470</i>&nbsp;     * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
<i>471</i>&nbsp;     * &lt;p&gt;
<i>472</i>&nbsp;     * If the relationship between nested types is expressed directly through the
<i>473</i>&nbsp;     * {@code NestHost} and {@code NestMembers} attributes
<i>474</i>&nbsp;     * (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29),
<i>475</i>&nbsp;     * then the associated {@code Lookup} object provides direct access to
<i>476</i>&nbsp;     * the lookup class and all of its nestmates
<i>477</i>&nbsp;     * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
<i>478</i>&nbsp;     * Otherwise, access between nested classes is obtained by the Java compiler creating
<i>479</i>&nbsp;     * a wrapper method to access a private method of another class in the same nest.
<i>480</i>&nbsp;     * For example, a nested class {@code C.D}
<i>481</i>&nbsp;     * can access private members within other related classes such as
<i>482</i>&nbsp;     * {@code C}, {@code C.D.E}, or {@code C.B},
<i>483</i>&nbsp;     * but the Java compiler may need to generate wrapper methods in
<i>484</i>&nbsp;     * those related classes.  In such cases, a {@code Lookup} object on
<i>485</i>&nbsp;     * {@code C.E} would be unable to access those private members.
<i>486</i>&nbsp;     * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
<i>487</i>&nbsp;     * which can transform a lookup on {@code C.E} into one on any of those other
<i>488</i>&nbsp;     * classes, without special elevation of privilege.
<i>489</i>&nbsp;     * &lt;p&gt;
<i>490</i>&nbsp;     * The accesses permitted to a given lookup object may be limited,
<i>491</i>&nbsp;     * according to its set of {@link #lookupModes lookupModes},
<i>492</i>&nbsp;     * to a subset of members normally accessible to the lookup class.
<i>493</i>&nbsp;     * For example, the {@link MethodHandles#publicLookup publicLookup}
<i>494</i>&nbsp;     * method produces a lookup object which is only allowed to access
<i>495</i>&nbsp;     * public members in public classes of exported packages.
<i>496</i>&nbsp;     * The caller sensitive method {@link MethodHandles#lookup lookup}
<i>497</i>&nbsp;     * produces a lookup object with full capabilities relative to
<i>498</i>&nbsp;     * its caller class, to emulate all supported bytecode behaviors.
<i>499</i>&nbsp;     * Also, the {@link Lookup#in Lookup.in} method may produce a lookup object
<i>500</i>&nbsp;     * with fewer access modes than the original lookup object.
<i>501</i>&nbsp;     *
<i>502</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>503</i>&nbsp;     * &lt;a id=&quot;privacc&quot;&gt;&lt;/a&gt;
<i>504</i>&nbsp;     * &lt;em&gt;Discussion of private access:&lt;/em&gt;
<i>505</i>&nbsp;     * We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
<i>506</i>&nbsp;     * if its {@linkplain #lookupModes lookup modes}
<i>507</i>&nbsp;     * include the possibility of accessing {@code private} members
<i>508</i>&nbsp;     * (which includes the private members of nestmates).
<i>509</i>&nbsp;     * As documented in the relevant methods elsewhere,
<i>510</i>&nbsp;     * only lookups with private access possess the following capabilities:
<i>511</i>&nbsp;     * &lt;ul style=&quot;font-size:smaller;&quot;&gt;
<b class="nc"><i>512</i>&nbsp;     * &lt;li&gt;access private fields, methods, and constructors of the lookup class and its nestmates</b>
<i>513</i>&nbsp;     * &lt;li&gt;create method handles which invoke &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt; methods,
<i>514</i>&nbsp;     *     such as {@code Class.forName}
<i>515</i>&nbsp;     * &lt;li&gt;create method handles which {@link Lookup#findSpecial emulate invokespecial} instructions
<i>516</i>&nbsp;     * &lt;li&gt;avoid &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;package access checks&lt;/a&gt;
<i>517</i>&nbsp;     *     for classes accessible to the lookup class
<i>518</i>&nbsp;     * &lt;li&gt;create {@link Lookup#in delegated lookup objects} which have private access to other classes
<i>519</i>&nbsp;     *     within the same package member
<i>520</i>&nbsp;     * &lt;/ul&gt;
<i>521</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>522</i>&nbsp;     * Each of these permissions is a consequence of the fact that a lookup object
<i>523</i>&nbsp;     * with private access can be securely traced back to an originating class,
<i>524</i>&nbsp;     * whose &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; and Java language access permissions
<i>525</i>&nbsp;     * can be reliably determined and emulated by method handles.
<i>526</i>&nbsp;     *
<i>527</i>&nbsp;     * &lt;h1&gt;&lt;a id=&quot;secmgr&quot;&gt;&lt;/a&gt;Security manager interactions&lt;/h1&gt;
<i>528</i>&nbsp;     * Although bytecode instructions can only refer to classes in
<i>529</i>&nbsp;     * a related class loader, this API can search for methods in any
<i>530</i>&nbsp;     * class, as long as a reference to its {@code Class} object is
<i>531</i>&nbsp;     * available.  Such cross-loader references are also possible with the
<i>532</i>&nbsp;     * Core Reflection API, and are impossible to bytecode instructions
<i>533</i>&nbsp;     * such as {@code invokestatic} or {@code getfield}.
<i>534</i>&nbsp;     * There is a {@linkplain java.lang.SecurityManager security manager API}
<i>535</i>&nbsp;     * to allow applications to check such cross-loader references.
<i>536</i>&nbsp;     * These checks apply to both the {@code MethodHandles.Lookup} API
<i>537</i>&nbsp;     * and the Core Reflection API
<i>538</i>&nbsp;     * (as found on {@link java.lang.Class Class}).
<i>539</i>&nbsp;     * &lt;p&gt;
<i>540</i>&nbsp;     * If a security manager is present, member and class lookups are subject to
<i>541</i>&nbsp;     * additional checks.
<i>542</i>&nbsp;     * From one to three calls are made to the security manager.
<i>543</i>&nbsp;     * Any of these calls can refuse access by throwing a
<i>544</i>&nbsp;     * {@link java.lang.SecurityException SecurityException}.
<i>545</i>&nbsp;     * Define {@code smgr} as the security manager,
<i>546</i>&nbsp;     * {@code lookc} as the lookup class of the current lookup object,
<i>547</i>&nbsp;     * {@code refc} as the containing class in which the member
<i>548</i>&nbsp;     * is being sought, and {@code defc} as the class in which the
<i>549</i>&nbsp;     * member is actually defined.
<i>550</i>&nbsp;     * (If a class or other type is being accessed,
<i>551</i>&nbsp;     * the {@code refc} and {@code defc} values are the class itself.)
<b class="nc"><i>552</i>&nbsp;     * The value {@code lookc} is defined as &lt;em&gt;not present&lt;/em&gt;</b>
<b class="nc"><i>553</i>&nbsp;     * if the current lookup object does not have</b>
<i>554</i>&nbsp;     * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;.
<i>555</i>&nbsp;     * The calls are made according to the following rules:
<i>556</i>&nbsp;     * &lt;ul&gt;
<i>557</i>&nbsp;     * &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
<i>558</i>&nbsp;     *     If {@code lookc} is not present, or if its class loader is not
<i>559</i>&nbsp;     *     the same as or an ancestor of the class loader of {@code refc},
<i>560</i>&nbsp;     *     then {@link SecurityManager#checkPackageAccess
<i>561</i>&nbsp;     *     smgr.checkPackageAccess(refcPkg)} is called,
<i>562</i>&nbsp;     *     where {@code refcPkg} is the package of {@code refc}.
<i>563</i>&nbsp;     * &lt;li&gt;&lt;b&gt;Step 2a:&lt;/b&gt;
<i>564</i>&nbsp;     *     If the retrieved member is not public and
<i>565</i>&nbsp;     *     {@code lookc} is not present, then
<b class="nc"><i>566</i>&nbsp;     *     {@link SecurityManager#checkPermission smgr.checkPermission}</b>
<i>567</i>&nbsp;     *     with {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)} is called.
<i>568</i>&nbsp;     * &lt;li&gt;&lt;b&gt;Step 2b:&lt;/b&gt;
<i>569</i>&nbsp;     *     If the retrieved class has a {@code null} class loader,
<i>570</i>&nbsp;     *     and {@code lookc} is not present, then
<b class="nc"><i>571</i>&nbsp;     *     {@link SecurityManager#checkPermission smgr.checkPermission}</b>
<i>572</i>&nbsp;     *     with {@code RuntimePermission(&quot;getClassLoader&quot;)} is called.
<i>573</i>&nbsp;     * &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
<i>574</i>&nbsp;     *     If the retrieved member is not public,
<i>575</i>&nbsp;     *     and if {@code lookc} is not present,
<i>576</i>&nbsp;     *     and if {@code defc} and {@code refc} are different,
<i>577</i>&nbsp;     *     then {@link SecurityManager#checkPackageAccess
<i>578</i>&nbsp;     *     smgr.checkPackageAccess(defcPkg)} is called,
<i>579</i>&nbsp;     *     where {@code defcPkg} is the package of {@code defc}.
<i>580</i>&nbsp;     * &lt;/ul&gt;
<i>581</i>&nbsp;     * Security checks are performed after other access checks have passed.
<i>582</i>&nbsp;     * Therefore, the above rules presuppose a member or class that is public,
<i>583</i>&nbsp;     * or else that is being accessed from a lookup class that has
<i>584</i>&nbsp;     * rights to access the member or class.
<i>585</i>&nbsp;     *
<i>586</i>&nbsp;     * &lt;h1&gt;&lt;a id=&quot;callsens&quot;&gt;&lt;/a&gt;Caller sensitive methods&lt;/h1&gt;
<i>587</i>&nbsp;     * A small number of Java methods have a special property called caller sensitivity.
<i>588</i>&nbsp;     * A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
<i>589</i>&nbsp;     * identity of its immediate caller.
<i>590</i>&nbsp;     * &lt;p&gt;
<i>591</i>&nbsp;     * If a method handle for a caller-sensitive method is requested,
<i>592</i>&nbsp;     * the general rules for &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;bytecode behaviors&lt;/a&gt; apply,
<b class="nc"><i>593</i>&nbsp;     * but they take account of the lookup class in a special way.</b>
<i>594</i>&nbsp;     * The resulting method handle behaves as if it were called
<i>595</i>&nbsp;     * from an instruction contained in the lookup class,
<i>596</i>&nbsp;     * so that the caller-sensitive method detects the lookup class.
<i>597</i>&nbsp;     * (By contrast, the invoker of the method handle is disregarded.)
<i>598</i>&nbsp;     * Thus, in the case of caller-sensitive methods,
<i>599</i>&nbsp;     * different lookup classes may give rise to
<i>600</i>&nbsp;     * differently behaving method handles.
<i>601</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>602</i>&nbsp;     * In cases where the lookup object is</b>
<i>603</i>&nbsp;     * {@link MethodHandles#publicLookup() publicLookup()},
<b class="nc"><i>604</i>&nbsp;     * or some other lookup object without</b>
<i>605</i>&nbsp;     * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;,
<i>606</i>&nbsp;     * the lookup class is disregarded.
<b class="nc"><i>607</i>&nbsp;     * In such cases, no caller-sensitive method handle can be created,</b>
<b class="nc"><i>608</i>&nbsp;     * access is forbidden, and the lookup fails with an</b>
<b class="nc"><i>609</i>&nbsp;     * {@code IllegalAccessException}.</b>
<i>610</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>611</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<i>612</i>&nbsp;     * For example, the caller-sensitive method
<i>613</i>&nbsp;     * {@link java.lang.Class#forName(String) Class.forName(x)}
<i>614</i>&nbsp;     * can return varying classes or throw varying exceptions,
<i>615</i>&nbsp;     * depending on the class loader of the class that calls it.
<i>616</i>&nbsp;     * A public lookup of {@code Class.forName} will fail, because
<i>617</i>&nbsp;     * there is no reasonable way to determine its bytecode behavior.
<i>618</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>619</i>&nbsp;     * If an application caches method handles for broad sharing,
<i>620</i>&nbsp;     * it should use {@code publicLookup()} to create them.
<i>621</i>&nbsp;     * If there is a lookup of {@code Class.forName}, it will fail,
<i>622</i>&nbsp;     * and the application must take appropriate action in that case.
<i>623</i>&nbsp;     * It may be that a later lookup, perhaps during the invocation of a
<i>624</i>&nbsp;     * bootstrap method, can incorporate the specific identity
<i>625</i>&nbsp;     * of the caller, making the method accessible.
<i>626</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>627</i>&nbsp;     * The function {@code MethodHandles.lookup} is caller sensitive
<i>628</i>&nbsp;     * so that there can be a secure foundation for lookups.
<i>629</i>&nbsp;     * Nearly all other methods in the JSR 292 API rely on lookup
<i>630</i>&nbsp;     * objects to check access requests.
<i>631</i>&nbsp;     *
<i>632</i>&nbsp;     * @revised 9
<i>633</i>&nbsp;     */
<i>634</i>&nbsp;    public static final
<i>635</i>&nbsp;    class Lookup {
<i>636</i>&nbsp;        /** The class on behalf of whom the lookup is being performed. */
<b class="nc"><i>637</i>&nbsp;        private final Class&lt;?&gt; lookupClass;</b>
<b class="nc"><i>638</i>&nbsp;</b>
<b class="nc"><i>639</i>&nbsp;        /** The allowed sorts of members which may be looked up (PUBLIC, etc.). */</b>
<b class="nc"><i>640</i>&nbsp;        private final int allowedModes;</b>
<b class="nc"><i>641</i>&nbsp;</b>
<b class="nc"><i>642</i>&nbsp;        /** A single-bit mask representing {@code public} access,</b>
<b class="nc"><i>643</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.</b>
<b class="nc"><i>644</i>&nbsp;         *  The value, {@code 0x01}, happens to be the same as the value of the</b>
<b class="nc"><i>645</i>&nbsp;         *  {@code public} {@linkplain java.lang.reflect.Modifier#PUBLIC modifier bit}.</b>
<i>646</i>&nbsp;         */
<i>647</i>&nbsp;        public static final int PUBLIC = Modifier.PUBLIC;
<b class="nc"><i>648</i>&nbsp;</b>
<b class="nc"><i>649</i>&nbsp;        /** A single-bit mask representing {@code private} access,</b>
<b class="nc"><i>650</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.</b>
<i>651</i>&nbsp;         *  The value, {@code 0x02}, happens to be the same as the value of the
<b class="nc"><i>652</i>&nbsp;         *  {@code private} {@linkplain java.lang.reflect.Modifier#PRIVATE modifier bit}.</b>
<b class="nc"><i>653</i>&nbsp;         */</b>
<i>654</i>&nbsp;        public static final int PRIVATE = Modifier.PRIVATE;
<i>655</i>&nbsp;
<b class="nc"><i>656</i>&nbsp;        /** A single-bit mask representing {@code protected} access,</b>
<i>657</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.
<b class="nc"><i>658</i>&nbsp;         *  The value, {@code 0x04}, happens to be the same as the value of the</b>
<b class="nc"><i>659</i>&nbsp;         *  {@code protected} {@linkplain java.lang.reflect.Modifier#PROTECTED modifier bit}.</b>
<i>660</i>&nbsp;         */
<i>661</i>&nbsp;        public static final int PROTECTED = Modifier.PROTECTED;
<i>662</i>&nbsp;
<b class="nc"><i>663</i>&nbsp;        /** A single-bit mask representing {@code package} access (default access),</b>
<i>664</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.
<i>665</i>&nbsp;         *  The value is {@code 0x08}, which does not correspond meaningfully to
<i>666</i>&nbsp;         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
<i>667</i>&nbsp;         */
<i>668</i>&nbsp;        public static final int PACKAGE = Modifier.STATIC;
<b class="nc"><i>669</i>&nbsp;</b>
<i>670</i>&nbsp;        /** A single-bit mask representing {@code module} access (default access),
<i>671</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.
<b class="nc"><i>672</i>&nbsp;         *  The value is {@code 0x10}, which does not correspond meaningfully to</b>
<i>673</i>&nbsp;         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.
<i>674</i>&nbsp;         *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
<b class="nc"><i>675</i>&nbsp;         *  with this lookup mode can access all public types in the module of the</b>
<b class="nc"><i>676</i>&nbsp;         *  lookup class and public types in packages exported by other modules</b>
<b class="nc"><i>677</i>&nbsp;         *  to the module of the lookup class.</b>
<i>678</i>&nbsp;         *  @since 9
<i>679</i>&nbsp;         *  @spec JPMS
<i>680</i>&nbsp;         */
<b class="nc"><i>681</i>&nbsp;        public static final int MODULE = PACKAGE &lt;&lt; 1;</b>
<b class="nc"><i>682</i>&nbsp;</b>
<b class="nc"><i>683</i>&nbsp;        /** A single-bit mask representing {@code unconditional} access</b>
<b class="nc"><i>684</i>&nbsp;         *  which may contribute to the result of {@link #lookupModes lookupModes}.</b>
<b class="nc"><i>685</i>&nbsp;         *  The value is {@code 0x20}, which does not correspond meaningfully to</b>
<b class="nc"><i>686</i>&nbsp;         *  any particular {@linkplain java.lang.reflect.Modifier modifier bit}.</b>
<i>687</i>&nbsp;         *  A {@code Lookup} with this lookup mode assumes {@linkplain
<i>688</i>&nbsp;         *  java.lang.Module#canRead(java.lang.Module) readability}.
<i>689</i>&nbsp;         *  In conjunction with the {@code PUBLIC} modifier bit, a {@code Lookup}
<i>690</i>&nbsp;         *  with this lookup mode can access all public members of public types
<i>691</i>&nbsp;         *  of all modules where the type is in a package that is {@link
<i>692</i>&nbsp;         *  java.lang.Module#isExported(String) exported unconditionally}.
<i>693</i>&nbsp;         *  @since 9
<i>694</i>&nbsp;         *  @spec JPMS
<i>695</i>&nbsp;         *  @see #publicLookup()
<i>696</i>&nbsp;         */
<i>697</i>&nbsp;        public static final int UNCONDITIONAL = PACKAGE &lt;&lt; 2;
<i>698</i>&nbsp;
<i>699</i>&nbsp;        private static final int ALL_MODES = (PUBLIC | PRIVATE | PROTECTED | PACKAGE | MODULE | UNCONDITIONAL);
<i>700</i>&nbsp;        private static final int FULL_POWER_MODES = (ALL_MODES &amp; ~UNCONDITIONAL);
<i>701</i>&nbsp;        private static final int TRUSTED   = -1;
<i>702</i>&nbsp;
<i>703</i>&nbsp;        private static int fixmods(int mods) {
<i>704</i>&nbsp;            mods &amp;= (ALL_MODES - PACKAGE - MODULE - UNCONDITIONAL);
<i>705</i>&nbsp;            return (mods != 0) ? mods : (PACKAGE | MODULE | UNCONDITIONAL);
<i>706</i>&nbsp;        }
<i>707</i>&nbsp;
<i>708</i>&nbsp;        /** Tells which class is performing the lookup.  It is this class against
<i>709</i>&nbsp;         *  which checks are performed for visibility and access permissions.
<i>710</i>&nbsp;         *  &lt;p&gt;
<i>711</i>&nbsp;         *  The class implies a maximum level of access permission,
<i>712</i>&nbsp;         *  but the permissions may be additionally limited by the bitmask
<i>713</i>&nbsp;         *  {@link #lookupModes lookupModes}, which controls whether non-public members
<i>714</i>&nbsp;         *  can be accessed.
<i>715</i>&nbsp;         *  @return the lookup class, on behalf of which this lookup object finds members
<i>716</i>&nbsp;         */
<i>717</i>&nbsp;        public Class&lt;?&gt; lookupClass() {
<i>718</i>&nbsp;            return lookupClass;
<i>719</i>&nbsp;        }
<i>720</i>&nbsp;
<b class="nc"><i>721</i>&nbsp;        // This is just for calling out to MethodHandleImpl.</b>
<b class="nc"><i>722</i>&nbsp;        private Class&lt;?&gt; lookupClassOrNull() {</b>
<i>723</i>&nbsp;            return (allowedModes == TRUSTED) ? null : lookupClass;
<b class="nc"><i>724</i>&nbsp;        }</b>
<i>725</i>&nbsp;
<b class="nc"><i>726</i>&nbsp;        /** Tells which access-protection classes of members this lookup object can produce.</b>
<i>727</i>&nbsp;         *  The result is a bit-mask of the bits
<b class="nc"><i>728</i>&nbsp;         *  {@linkplain #PUBLIC PUBLIC (0x01)},</b>
<i>729</i>&nbsp;         *  {@linkplain #PRIVATE PRIVATE (0x02)},
<b class="nc"><i>730</i>&nbsp;         *  {@linkplain #PROTECTED PROTECTED (0x04)},</b>
<i>731</i>&nbsp;         *  {@linkplain #PACKAGE PACKAGE (0x08)},
<b class="nc"><i>732</i>&nbsp;         *  {@linkplain #MODULE MODULE (0x10)},</b>
<i>733</i>&nbsp;         *  and {@linkplain #UNCONDITIONAL UNCONDITIONAL (0x20)}.
<b class="nc"><i>734</i>&nbsp;         *  &lt;p&gt;</b>
<i>735</i>&nbsp;         *  A freshly-created lookup object
<b class="nc"><i>736</i>&nbsp;         *  on the {@linkplain java.lang.invoke.MethodHandles#lookup() caller&#39;s class} has</b>
<b class="nc"><i>737</i>&nbsp;         *  all possible bits set, except {@code UNCONDITIONAL}.</b>
<b class="nc"><i>738</i>&nbsp;         *  A lookup object on a new lookup class</b>
<i>739</i>&nbsp;         *  {@linkplain java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object}
<i>740</i>&nbsp;         *  may have some mode bits set to zero.
<i>741</i>&nbsp;         *  Mode bits can also be
<i>742</i>&nbsp;         *  {@linkplain java.lang.invoke.MethodHandles.Lookup#dropLookupMode directly cleared}.
<i>743</i>&nbsp;         *  Once cleared, mode bits cannot be restored from the downgraded lookup object.
<i>744</i>&nbsp;         *  The purpose of this is to restrict access via the new lookup object,
<i>745</i>&nbsp;         *  so that it can access only names which can be reached by the original
<i>746</i>&nbsp;         *  lookup object, and also by the new lookup class.
<i>747</i>&nbsp;         *  @return the lookup modes, which limit the kinds of access performed by this lookup object
<i>748</i>&nbsp;         *  @see #in
<i>749</i>&nbsp;         *  @see #dropLookupMode
<i>750</i>&nbsp;         *
<i>751</i>&nbsp;         *  @revised 9
<i>752</i>&nbsp;         *  @spec JPMS
<i>753</i>&nbsp;         */
<i>754</i>&nbsp;        public int lookupModes() {
<i>755</i>&nbsp;            return allowedModes &amp; ALL_MODES;
<i>756</i>&nbsp;        }
<i>757</i>&nbsp;
<i>758</i>&nbsp;        /** Embody the current class (the lookupClass) as a lookup class
<i>759</i>&nbsp;         * for method handle creation.
<i>760</i>&nbsp;         * Must be called by from a method in this package,
<i>761</i>&nbsp;         * which in turn is called by a method not in this package.
<i>762</i>&nbsp;         */
<i>763</i>&nbsp;        Lookup(Class&lt;?&gt; lookupClass) {
<i>764</i>&nbsp;            this(lookupClass, FULL_POWER_MODES);
<i>765</i>&nbsp;            // make sure we haven&#39;t accidentally picked up a privileged class:
<i>766</i>&nbsp;            checkUnprivilegedlookupClass(lookupClass);
<i>767</i>&nbsp;        }
<i>768</i>&nbsp;
<i>769</i>&nbsp;        private Lookup(Class&lt;?&gt; lookupClass, int allowedModes) {
<i>770</i>&nbsp;            this.lookupClass = lookupClass;
<i>771</i>&nbsp;            this.allowedModes = allowedModes;
<i>772</i>&nbsp;        }
<i>773</i>&nbsp;
<i>774</i>&nbsp;        /**
<i>775</i>&nbsp;         * Creates a lookup on the specified new lookup class.
<i>776</i>&nbsp;         * The resulting object will report the specified
<i>777</i>&nbsp;         * class as its own {@link #lookupClass() lookupClass}.
<i>778</i>&nbsp;         * &lt;p&gt;
<i>779</i>&nbsp;         * However, the resulting {@code Lookup} object is guaranteed
<b class="nc"><i>780</i>&nbsp;         * to have no more access capabilities than the original.</b>
<b class="nc"><i>781</i>&nbsp;         * In particular, access capabilities can be lost as follows:&lt;ul&gt;</b>
<i>782</i>&nbsp;         * &lt;li&gt;If the old lookup class is in a {@link Module#isNamed() named} module, and
<i>783</i>&nbsp;         * the new lookup class is in a different module {@code M}, then no members, not
<i>784</i>&nbsp;         * even public members in {@code M}&#39;s exported packages, will be accessible.
<i>785</i>&nbsp;         * The exception to this is when this lookup is {@link #publicLookup()
<i>786</i>&nbsp;         * publicLookup}, in which case {@code PUBLIC} access is not lost.
<i>787</i>&nbsp;         * &lt;li&gt;If the old lookup class is in an unnamed module, and the new lookup class
<i>788</i>&nbsp;         * is a different module then {@link #MODULE MODULE} access is lost.
<i>789</i>&nbsp;         * &lt;li&gt;If the new lookup class differs from the old one then {@code UNCONDITIONAL} is lost.
<i>790</i>&nbsp;         * &lt;li&gt;If the new lookup class is in a different package
<i>791</i>&nbsp;         * than the old one, protected and default (package) members will not be accessible.
<i>792</i>&nbsp;         * &lt;li&gt;If the new lookup class is not within the same package member
<i>793</i>&nbsp;         * as the old one, private members will not be accessible, and protected members
<i>794</i>&nbsp;         * will not be accessible by virtue of inheritance.
<i>795</i>&nbsp;         * (Protected members may continue to be accessible because of package sharing.)
<i>796</i>&nbsp;         * &lt;li&gt;If the new lookup class is not accessible to the old lookup class,
<i>797</i>&nbsp;         * then no members, not even public members, will be accessible.
<i>798</i>&nbsp;         * (In all other cases, public members will continue to be accessible.)
<i>799</i>&nbsp;         * &lt;/ul&gt;
<i>800</i>&nbsp;         * &lt;p&gt;
<i>801</i>&nbsp;         * The resulting lookup&#39;s capabilities for loading classes
<i>802</i>&nbsp;         * (used during {@link #findClass} invocations)
<i>803</i>&nbsp;         * are determined by the lookup class&#39; loader,
<i>804</i>&nbsp;         * which may change due to this operation.
<i>805</i>&nbsp;         *
<i>806</i>&nbsp;         * @param requestedLookupClass the desired lookup class for the new lookup object
<i>807</i>&nbsp;         * @return a lookup object which reports the desired lookup class, or the same object
<i>808</i>&nbsp;         * if there is no change
<i>809</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>810</i>&nbsp;         *
<i>811</i>&nbsp;         * @revised 9
<i>812</i>&nbsp;         * @spec JPMS
<i>813</i>&nbsp;         */
<i>814</i>&nbsp;        public Lookup in(Class&lt;?&gt; requestedLookupClass) {
<i>815</i>&nbsp;            Objects.requireNonNull(requestedLookupClass);
<i>816</i>&nbsp;            if (allowedModes == TRUSTED)  // IMPL_LOOKUP can make any lookup at all
<i>817</i>&nbsp;                return new Lookup(requestedLookupClass, FULL_POWER_MODES);
<i>818</i>&nbsp;            if (requestedLookupClass == this.lookupClass)
<i>819</i>&nbsp;                return this;  // keep same capabilities
<i>820</i>&nbsp;            int newModes = (allowedModes &amp; FULL_POWER_MODES);
<i>821</i>&nbsp;            if (!VerifyAccess.isSameModule(this.lookupClass, requestedLookupClass)) {
<i>822</i>&nbsp;                // Need to drop all access when teleporting from a named module to another
<i>823</i>&nbsp;                // module. The exception is publicLookup where PUBLIC is not lost.
<i>824</i>&nbsp;                if (this.lookupClass.getModule().isNamed()
<i>825</i>&nbsp;                    &amp;&amp; (this.allowedModes &amp; UNCONDITIONAL) == 0)
<i>826</i>&nbsp;                    newModes = 0;
<i>827</i>&nbsp;                else
<i>828</i>&nbsp;                    newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);
<i>829</i>&nbsp;            }
<i>830</i>&nbsp;            if ((newModes &amp; PACKAGE) != 0
<i>831</i>&nbsp;                &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
<i>832</i>&nbsp;                newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
<i>833</i>&nbsp;            }
<i>834</i>&nbsp;            // Allow nestmate lookups to be created without special privilege:
<i>835</i>&nbsp;            if ((newModes &amp; PRIVATE) != 0
<i>836</i>&nbsp;                &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
<i>837</i>&nbsp;                newModes &amp;= ~(PRIVATE|PROTECTED);
<i>838</i>&nbsp;            }
<i>839</i>&nbsp;            if ((newModes &amp; PUBLIC) != 0
<i>840</i>&nbsp;                &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, allowedModes)) {
<i>841</i>&nbsp;                // The requested class it not accessible from the lookup class.
<i>842</i>&nbsp;                // No permissions.
<i>843</i>&nbsp;                newModes = 0;
<i>844</i>&nbsp;            }
<i>845</i>&nbsp;
<i>846</i>&nbsp;            checkUnprivilegedlookupClass(requestedLookupClass);
<i>847</i>&nbsp;            return new Lookup(requestedLookupClass, newModes);
<i>848</i>&nbsp;        }
<i>849</i>&nbsp;
<i>850</i>&nbsp;
<i>851</i>&nbsp;        /**
<i>852</i>&nbsp;         * Creates a lookup on the same lookup class which this lookup object
<i>853</i>&nbsp;         * finds members, but with a lookup mode that has lost the given lookup mode.
<i>854</i>&nbsp;         * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
<i>855</i>&nbsp;         * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED} or {@link #PRIVATE PRIVATE}.
<b class="nc"><i>856</i>&nbsp;         * {@link #PROTECTED PROTECTED} and {@link #UNCONDITIONAL UNCONDITIONAL} are always</b>
<b class="nc"><i>857</i>&nbsp;         * dropped and so the resulting lookup mode will never have these access capabilities.</b>
<b class="nc"><i>858</i>&nbsp;         * When dropping {@code PACKAGE} then the resulting lookup will not have {@code PACKAGE}</b>
<i>859</i>&nbsp;         * or {@code PRIVATE} access. When dropping {@code MODULE} then the resulting lookup will
<b class="nc"><i>860</i>&nbsp;         * not have {@code MODULE}, {@code PACKAGE}, or {@code PRIVATE} access. If {@code PUBLIC}</b>
<b class="nc"><i>861</i>&nbsp;         * is dropped then the resulting lookup has no access.</b>
<b class="nc"><i>862</i>&nbsp;         * @param modeToDrop the lookup mode to drop</b>
<i>863</i>&nbsp;         * @return a lookup object which lacks the indicated mode, or the same object if there is no change
<i>864</i>&nbsp;         * @throws IllegalArgumentException if {@code modeToDrop} is not one of {@code PUBLIC},
<i>865</i>&nbsp;         * {@code MODULE}, {@code PACKAGE}, {@code PROTECTED}, {@code PRIVATE} or {@code UNCONDITIONAL}
<b class="nc"><i>866</i>&nbsp;         * @see MethodHandles#privateLookupIn</b>
<b class="nc"><i>867</i>&nbsp;         * @since 9</b>
<b class="nc"><i>868</i>&nbsp;         */</b>
<b class="nc"><i>869</i>&nbsp;        public Lookup dropLookupMode(int modeToDrop) {</b>
<b class="nc"><i>870</i>&nbsp;            int oldModes = lookupModes();</b>
<b class="nc"><i>871</i>&nbsp;            int newModes = oldModes &amp; ~(modeToDrop | PROTECTED | UNCONDITIONAL);</b>
<i>872</i>&nbsp;            switch (modeToDrop) {
<i>873</i>&nbsp;                case PUBLIC: newModes &amp;= ~(ALL_MODES); break;
<i>874</i>&nbsp;                case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
<i>875</i>&nbsp;                case PACKAGE: newModes &amp;= ~(PRIVATE); break;
<i>876</i>&nbsp;                case PROTECTED:
<i>877</i>&nbsp;                case PRIVATE:
<i>878</i>&nbsp;                case UNCONDITIONAL: break;
<i>879</i>&nbsp;                default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
<i>880</i>&nbsp;            }
<i>881</i>&nbsp;            if (newModes == oldModes) return this;  // return self if no change
<i>882</i>&nbsp;            return new Lookup(lookupClass(), newModes);
<i>883</i>&nbsp;        }
<i>884</i>&nbsp;
<i>885</i>&nbsp;        /**
<i>886</i>&nbsp;         * Defines a class to the same class loader and in the same runtime package and
<i>887</i>&nbsp;         * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
<i>888</i>&nbsp;         * {@linkplain #lookupClass() lookup class}.
<i>889</i>&nbsp;         *
<i>890</i>&nbsp;         * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
<i>891</i>&nbsp;         * {@link #PACKAGE PACKAGE} access as default (package) members will be
<i>892</i>&nbsp;         * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
<i>893</i>&nbsp;         * that the lookup object was created by a caller in the runtime package (or derived
<i>894</i>&nbsp;         * from a lookup originally created by suitably privileged code to a target class in
<i>895</i>&nbsp;         * the runtime package). &lt;/p&gt;
<i>896</i>&nbsp;         *
<i>897</i>&nbsp;         * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
<i>898</i>&nbsp;         * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
<i>899</i>&nbsp;         * same package as the lookup class. &lt;/p&gt;
<i>900</i>&nbsp;         *
<i>901</i>&nbsp;         * &lt;p&gt; This method does not run the class initializer. The class initializer may
<i>902</i>&nbsp;         * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
<i>903</i>&nbsp;         * Specification&lt;/em&gt;. &lt;/p&gt;
<i>904</i>&nbsp;         *
<i>905</i>&nbsp;         * &lt;p&gt; If there is a security manager, its {@code checkPermission} method is first called
<i>906</i>&nbsp;         * to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
<i>907</i>&nbsp;         *
<i>908</i>&nbsp;         * @param bytes the class bytes
<i>909</i>&nbsp;         * @return the {@code Class} object for the class
<i>910</i>&nbsp;         * @throws IllegalArgumentException the bytes are for a class in a different package
<i>911</i>&nbsp;         * to the lookup class
<i>912</i>&nbsp;         * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
<i>913</i>&nbsp;         * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
<i>914</i>&nbsp;         * verified ({@code VerifyError}), is already defined, or another linkage error occurs
<i>915</i>&nbsp;         * @throws SecurityException if denied by the security manager
<i>916</i>&nbsp;         * @throws NullPointerException if {@code bytes} is {@code null}
<i>917</i>&nbsp;         * @since 9
<i>918</i>&nbsp;         * @spec JPMS
<i>919</i>&nbsp;         * @see Lookup#privateLookupIn
<b class="nc"><i>920</i>&nbsp;         * @see Lookup#dropLookupMode</b>
<b class="nc"><i>921</i>&nbsp;         * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)</b>
<i>922</i>&nbsp;         */
<b class="nc"><i>923</i>&nbsp;        public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {</b>
<b class="nc"><i>924</i>&nbsp;            SecurityManager sm = System.getSecurityManager();</b>
<b class="nc"><i>925</i>&nbsp;            if (sm != null)</b>
<i>926</i>&nbsp;                sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
<i>927</i>&nbsp;            if ((lookupModes() &amp; PACKAGE) == 0)
<i>928</i>&nbsp;                throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);
<i>929</i>&nbsp;            assert (lookupModes() &amp; (MODULE|PUBLIC)) != 0;
<i>930</i>&nbsp;
<i>931</i>&nbsp;            // parse class bytes to get class name (in internal form)
<i>932</i>&nbsp;            bytes = bytes.clone();
<i>933</i>&nbsp;            String name;
<i>934</i>&nbsp;            try {
<i>935</i>&nbsp;                ClassReader reader = new ClassReader(bytes);
<i>936</i>&nbsp;                name = reader.getClassName();
<i>937</i>&nbsp;            } catch (RuntimeException e) {
<i>938</i>&nbsp;                // ASM exceptions are poorly specified
<i>939</i>&nbsp;                ClassFormatError cfe = new ClassFormatError();
<i>940</i>&nbsp;                cfe.initCause(e);
<i>941</i>&nbsp;                throw cfe;
<i>942</i>&nbsp;            }
<i>943</i>&nbsp;
<i>944</i>&nbsp;            // get package and class name in binary form
<i>945</i>&nbsp;            String cn, pn;
<i>946</i>&nbsp;            int index = name.lastIndexOf(&#39;/&#39;);
<i>947</i>&nbsp;            if (index == -1) {
<i>948</i>&nbsp;                cn = name;
<i>949</i>&nbsp;                pn = &quot;&quot;;
<i>950</i>&nbsp;            } else {
<i>951</i>&nbsp;                cn = name.replace(&#39;/&#39;, &#39;.&#39;);
<i>952</i>&nbsp;                pn = cn.substring(0, index);
<i>953</i>&nbsp;            }
<i>954</i>&nbsp;            if (!pn.equals(lookupClass.getPackageName())) {
<i>955</i>&nbsp;                throw new IllegalArgumentException(&quot;Class not in same package as lookup class&quot;);
<i>956</i>&nbsp;            }
<i>957</i>&nbsp;
<i>958</i>&nbsp;            // invoke the class loader&#39;s defineClass method
<i>959</i>&nbsp;            ClassLoader loader = lookupClass.getClassLoader();
<i>960</i>&nbsp;            ProtectionDomain pd = (loader != null) ? lookupClassProtectionDomain() : null;
<i>961</i>&nbsp;            String source = &quot;__Lookup_defineClass__&quot;;
<i>962</i>&nbsp;            Class&lt;?&gt; clazz = SharedSecrets.getJavaLangAccess().defineClass(loader, cn, bytes, pd, source);
<i>963</i>&nbsp;            assert clazz.getClassLoader() == lookupClass.getClassLoader()
<i>964</i>&nbsp;                    &amp;&amp; clazz.getPackageName().equals(lookupClass.getPackageName())
<i>965</i>&nbsp;                    &amp;&amp; protectionDomain(clazz) == lookupClassProtectionDomain();
<i>966</i>&nbsp;            return clazz;
<i>967</i>&nbsp;        }
<i>968</i>&nbsp;
<i>969</i>&nbsp;        private ProtectionDomain lookupClassProtectionDomain() {
<i>970</i>&nbsp;            ProtectionDomain pd = cachedProtectionDomain;
<i>971</i>&nbsp;            if (pd == null) {
<i>972</i>&nbsp;                cachedProtectionDomain = pd = protectionDomain(lookupClass);
<i>973</i>&nbsp;            }
<i>974</i>&nbsp;            return pd;
<i>975</i>&nbsp;        }
<i>976</i>&nbsp;
<i>977</i>&nbsp;        private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {
<i>978</i>&nbsp;            PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;
<i>979</i>&nbsp;            return AccessController.doPrivileged(pa);
<i>980</i>&nbsp;        }
<i>981</i>&nbsp;
<i>982</i>&nbsp;        // cached protection domain
<i>983</i>&nbsp;        private volatile ProtectionDomain cachedProtectionDomain;
<i>984</i>&nbsp;
<i>985</i>&nbsp;
<i>986</i>&nbsp;        // Make sure outer class is initialized first.
<i>987</i>&nbsp;        static { IMPL_NAMES.getClass(); }
<i>988</i>&nbsp;
<i>989</i>&nbsp;        /** Package-private version of lookup which is trusted. */
<i>990</i>&nbsp;        static final Lookup IMPL_LOOKUP = new Lookup(Object.class, TRUSTED);
<i>991</i>&nbsp;
<i>992</i>&nbsp;        /** Version of lookup which is trusted minimally.
<i>993</i>&nbsp;         *  It can only be used to create method handles to publicly accessible
<i>994</i>&nbsp;         *  members in packages that are exported unconditionally.
<i>995</i>&nbsp;         */
<i>996</i>&nbsp;        static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, (PUBLIC|UNCONDITIONAL));
<i>997</i>&nbsp;
<i>998</i>&nbsp;        private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
<i>999</i>&nbsp;            String name = lookupClass.getName();
<i>1000</i>&nbsp;            if (name.startsWith(&quot;java.lang.invoke.&quot;))
<i>1001</i>&nbsp;                throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
<b class="nc"><i>1002</i>&nbsp;        }</b>
<b class="nc"><i>1003</i>&nbsp;</b>
<b class="nc"><i>1004</i>&nbsp;        /**</b>
<b class="nc"><i>1005</i>&nbsp;         * Displays the name of the class from which lookups are to be made.</b>
<i>1006</i>&nbsp;         * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
<i>1007</i>&nbsp;         * If there are restrictions on the access permitted to this lookup,
<i>1008</i>&nbsp;         * this is indicated by adding a suffix to the class name, consisting
<i>1009</i>&nbsp;         * of a slash and a keyword.  The keyword represents the strongest
<i>1010</i>&nbsp;         * allowed access, and is chosen as follows:
<i>1011</i>&nbsp;         * &lt;ul&gt;
<i>1012</i>&nbsp;         * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
<i>1013</i>&nbsp;         * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
<i>1014</i>&nbsp;         * &lt;li&gt;If only public access and unconditional access are allowed, the suffix is &quot;/publicLookup&quot;.
<i>1015</i>&nbsp;         * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
<i>1016</i>&nbsp;         * &lt;li&gt;If only public, module and package access are allowed, the suffix is &quot;/package&quot;.
<i>1017</i>&nbsp;         * &lt;li&gt;If only public, module, package, and private access are allowed, the suffix is &quot;/private&quot;.
<i>1018</i>&nbsp;         * &lt;/ul&gt;
<i>1019</i>&nbsp;         * If none of the above cases apply, it is the case that full
<i>1020</i>&nbsp;         * access (public, module, package, private, and protected) is allowed.
<i>1021</i>&nbsp;         * In this case, no suffix is added.
<i>1022</i>&nbsp;         * This is true only of an object obtained originally from
<i>1023</i>&nbsp;         * {@link java.lang.invoke.MethodHandles#lookup MethodHandles.lookup}.
<i>1024</i>&nbsp;         * Objects created by {@link java.lang.invoke.MethodHandles.Lookup#in Lookup.in}
<i>1025</i>&nbsp;         * always have restricted access, and will display a suffix.
<b class="nc"><i>1026</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1027</i>&nbsp;         * (It may seem strange that protected access should be</b>
<i>1028</i>&nbsp;         * stronger than private access.  Viewed independently from
<i>1029</i>&nbsp;         * package access, protected access is the first to be lost,
<i>1030</i>&nbsp;         * because it requires a direct subclass relationship between
<i>1031</i>&nbsp;         * caller and callee.)
<i>1032</i>&nbsp;         * @see #in
<i>1033</i>&nbsp;         *
<i>1034</i>&nbsp;         * @revised 9
<i>1035</i>&nbsp;         * @spec JPMS
<i>1036</i>&nbsp;         */
<i>1037</i>&nbsp;        @Override
<i>1038</i>&nbsp;        public String toString() {
<i>1039</i>&nbsp;            String cname = lookupClass.getName();
<i>1040</i>&nbsp;            switch (allowedModes) {
<i>1041</i>&nbsp;            case 0:  // no privileges
<i>1042</i>&nbsp;                return cname + &quot;/noaccess&quot;;
<i>1043</i>&nbsp;            case PUBLIC:
<i>1044</i>&nbsp;                return cname + &quot;/public&quot;;
<i>1045</i>&nbsp;            case PUBLIC|UNCONDITIONAL:
<i>1046</i>&nbsp;                return cname  + &quot;/publicLookup&quot;;
<i>1047</i>&nbsp;            case PUBLIC|MODULE:
<b class="nc"><i>1048</i>&nbsp;                return cname + &quot;/module&quot;;</b>
<b class="nc"><i>1049</i>&nbsp;            case PUBLIC|MODULE|PACKAGE:</b>
<i>1050</i>&nbsp;                return cname + &quot;/package&quot;;
<i>1051</i>&nbsp;            case FULL_POWER_MODES &amp; ~PROTECTED:
<i>1052</i>&nbsp;                return cname + &quot;/private&quot;;
<i>1053</i>&nbsp;            case FULL_POWER_MODES:
<i>1054</i>&nbsp;                return cname;
<i>1055</i>&nbsp;            case TRUSTED:
<i>1056</i>&nbsp;                return &quot;/trusted&quot;;  // internal only; not exported
<i>1057</i>&nbsp;            default:  // Should not happen, but it&#39;s a bitfield...
<i>1058</i>&nbsp;                cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
<i>1059</i>&nbsp;                assert(false) : cname;
<i>1060</i>&nbsp;                return cname;
<i>1061</i>&nbsp;            }
<i>1062</i>&nbsp;        }
<i>1063</i>&nbsp;
<i>1064</i>&nbsp;        /**
<i>1065</i>&nbsp;         * Produces a method handle for a static method.
<i>1066</i>&nbsp;         * The type of the method handle will be that of the method.
<i>1067</i>&nbsp;         * (Since static methods do not take receivers, there is no
<i>1068</i>&nbsp;         * additional receiver argument inserted into the method handle type,
<i>1069</i>&nbsp;         * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
<i>1070</i>&nbsp;         * The method and all its argument types must be accessible to the lookup object.
<i>1071</i>&nbsp;         * &lt;p&gt;
<b class="nc"><i>1072</i>&nbsp;         * The returned method handle will have</b>
<b class="nc"><i>1073</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if</b>
<i>1074</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1075</i>&nbsp;         * &lt;p&gt;
<i>1076</i>&nbsp;         * If the returned method handle is invoked, the method&#39;s class will
<i>1077</i>&nbsp;         * be initialized, if it has not already been initialized.
<i>1078</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<i>1079</i>&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1080</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>1081</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>1082</i>&nbsp;...
<i>1083</i>&nbsp;MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
<i>1084</i>&nbsp;  &quot;asList&quot;, methodType(List.class, Object[].class));
<i>1085</i>&nbsp;assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
<i>1086</i>&nbsp;         * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1087</i>&nbsp;         * @param refc the class from which the method is accessed
<i>1088</i>&nbsp;         * @param name the name of the method
<i>1089</i>&nbsp;         * @param type the type of the method
<i>1090</i>&nbsp;         * @return the desired method handle
<i>1091</i>&nbsp;         * @throws NoSuchMethodException if the method does not exist
<i>1092</i>&nbsp;         * @throws IllegalAccessException if access checking fails,
<i>1093</i>&nbsp;         *                                or if the method is not {@code static},
<i>1094</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit
<i>1095</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails
<b class="nc"><i>1096</i>&nbsp;         * @exception SecurityException if a security manager is present and it</b>
<b class="nc"><i>1097</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</b>
<i>1098</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1099</i>&nbsp;         */
<i>1100</i>&nbsp;        public
<i>1101</i>&nbsp;        MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
<i>1102</i>&nbsp;            MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<i>1103</i>&nbsp;            return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerClass(method));
<i>1104</i>&nbsp;        }
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;        /**
<i>1107</i>&nbsp;         * Produces a method handle for a virtual method.
<i>1108</i>&nbsp;         * The type of the method handle will be that of the method,
<i>1109</i>&nbsp;         * with the receiver type (usually {@code refc}) prepended.
<i>1110</i>&nbsp;         * The method and all its argument types must be accessible to the lookup object.
<i>1111</i>&nbsp;         * &lt;p&gt;
<i>1112</i>&nbsp;         * When called, the handle will treat the first argument as a receiver
<i>1113</i>&nbsp;         * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
<i>1114</i>&nbsp;         * implementation to enter.
<i>1115</i>&nbsp;         * For private methods the named method in {@code refc} will be invoked on the receiver.
<i>1116</i>&nbsp;         * (The dispatching action is identical with that performed by an
<i>1117</i>&nbsp;         * {@code invokevirtual} or {@code invokeinterface} instruction.)
<i>1118</i>&nbsp;         * &lt;p&gt;
<i>1119</i>&nbsp;         * The first argument will be of type {@code refc} if the lookup
<i>1120</i>&nbsp;         * class has full privileges to access the member.  Otherwise
<i>1121</i>&nbsp;         * the member must be {@code protected} and the first argument
<i>1122</i>&nbsp;         * will be restricted in type to the lookup class.
<i>1123</i>&nbsp;         * &lt;p&gt;
<i>1124</i>&nbsp;         * The returned method handle will have
<i>1125</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
<i>1126</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1127</i>&nbsp;         * &lt;p&gt;
<i>1128</i>&nbsp;         * Because of the general &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;equivalence&lt;/a&gt; between {@code invokevirtual}
<i>1129</i>&nbsp;         * instructions and method handles produced by {@code findVirtual},
<i>1130</i>&nbsp;         * if the class is {@code MethodHandle} and the name string is
<i>1131</i>&nbsp;         * {@code invokeExact} or {@code invoke}, the resulting
<i>1132</i>&nbsp;         * method handle is equivalent to one produced by
<i>1133</i>&nbsp;         * {@link java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker} or
<i>1134</i>&nbsp;         * {@link java.lang.invoke.MethodHandles#invoker MethodHandles.invoker}
<i>1135</i>&nbsp;         * with the same {@code type} argument.
<i>1136</i>&nbsp;         * &lt;p&gt;
<i>1137</i>&nbsp;         * If the class is {@code VarHandle} and the name string corresponds to
<i>1138</i>&nbsp;         * the name of a signature-polymorphic access mode method, the resulting
<i>1139</i>&nbsp;         * method handle is equivalent to one produced by
<i>1140</i>&nbsp;         * {@link java.lang.invoke.MethodHandles#varHandleInvoker} with
<i>1141</i>&nbsp;         * the access mode corresponding to the name string and with the same
<i>1142</i>&nbsp;         * {@code type} arguments.
<i>1143</i>&nbsp;         * &lt;p&gt;
<i>1144</i>&nbsp;         * &lt;b&gt;Example:&lt;/b&gt;
<i>1145</i>&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>1146</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>1147</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>1148</i>&nbsp;...
<b class="nc"><i>1149</i>&nbsp;MethodHandle MH_concat = publicLookup().findVirtual(String.class,</b>
<b class="nc"><i>1150</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));</b>
<b class="nc"><i>1151</i>&nbsp;MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,</b>
<b class="nc"><i>1152</i>&nbsp;  &quot;hashCode&quot;, methodType(int.class));</b>
<i>1153</i>&nbsp;MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
<i>1154</i>&nbsp;  &quot;hashCode&quot;, methodType(int.class));
<i>1155</i>&nbsp;assertEquals(&quot;xy&quot;, (String) MH_concat.invokeExact(&quot;x&quot;, &quot;y&quot;));
<i>1156</i>&nbsp;assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode.invokeExact((Object)&quot;xy&quot;));
<i>1157</i>&nbsp;assertEquals(&quot;xy&quot;.hashCode(), (int) MH_hashCode_String.invokeExact(&quot;xy&quot;));
<i>1158</i>&nbsp;// interface method:
<i>1159</i>&nbsp;MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
<i>1160</i>&nbsp;  &quot;subSequence&quot;, methodType(CharSequence.class, int.class, int.class));
<i>1161</i>&nbsp;assertEquals(&quot;def&quot;, MH_subSequence.invoke(&quot;abcdefghi&quot;, 3, 6).toString());
<i>1162</i>&nbsp;// constructor &quot;internal method&quot; must be accessed differently:
<i>1163</i>&nbsp;MethodType MT_newString = methodType(void.class); //()V for new String()
<i>1164</i>&nbsp;try { assertEquals(&quot;impossible&quot;, lookup()
<i>1165</i>&nbsp;        .findVirtual(String.class, &quot;&lt;init&gt;&quot;, MT_newString));
<i>1166</i>&nbsp; } catch (NoSuchMethodException ex) { } // OK
<i>1167</i>&nbsp;MethodHandle MH_newString = publicLookup()
<i>1168</i>&nbsp;  .findConstructor(String.class, MT_newString);
<i>1169</i>&nbsp;assertEquals(&quot;&quot;, (String) MH_newString.invokeExact());
<i>1170</i>&nbsp;         * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1171</i>&nbsp;         *
<i>1172</i>&nbsp;         * @param refc the class or interface from which the method is accessed
<i>1173</i>&nbsp;         * @param name the name of the method
<i>1174</i>&nbsp;         * @param type the type of the method, with the receiver argument omitted
<i>1175</i>&nbsp;         * @return the desired method handle
<i>1176</i>&nbsp;         * @throws NoSuchMethodException if the method does not exist
<i>1177</i>&nbsp;         * @throws IllegalAccessException if access checking fails,
<i>1178</i>&nbsp;         *                                or if the method is {@code static},
<i>1179</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit
<i>1180</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails
<i>1181</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<b class="nc"><i>1182</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</b>
<b class="nc"><i>1183</i>&nbsp;         * @throws NullPointerException if any argument is null</b>
<b class="nc"><i>1184</i>&nbsp;         */</b>
<i>1185</i>&nbsp;        public MethodHandle findVirtual(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
<b class="nc"><i>1186</i>&nbsp;            if (refc == MethodHandle.class) {</b>
<b class="nc"><i>1187</i>&nbsp;                MethodHandle mh = findVirtualForMH(name, type);</b>
<b class="nc"><i>1188</i>&nbsp;                if (mh != null)  return mh;</b>
<b class="nc"><i>1189</i>&nbsp;            } else if (refc == VarHandle.class) {</b>
<b class="nc"><i>1190</i>&nbsp;                MethodHandle mh = findVirtualForVH(name, type);</b>
<b class="nc"><i>1191</i>&nbsp;                if (mh != null)  return mh;</b>
<b class="nc"><i>1192</i>&nbsp;            }</b>
<i>1193</i>&nbsp;            byte refKind = (refc.isInterface() ? REF_invokeInterface : REF_invokeVirtual);
<i>1194</i>&nbsp;            MemberName method = resolveOrFail(refKind, refc, name, type);
<i>1195</i>&nbsp;            return getDirectMethod(refKind, refc, method, findBoundCallerClass(method));
<b class="nc"><i>1196</i>&nbsp;        }</b>
<b class="nc"><i>1197</i>&nbsp;        private MethodHandle findVirtualForMH(String name, MethodType type) {</b>
<b class="nc"><i>1198</i>&nbsp;            // these names require special lookups because of the implicit MethodType argument</b>
<i>1199</i>&nbsp;            if (&quot;invoke&quot;.equals(name))
<i>1200</i>&nbsp;                return invoker(type);
<i>1201</i>&nbsp;            if (&quot;invokeExact&quot;.equals(name))
<i>1202</i>&nbsp;                return exactInvoker(type);
<i>1203</i>&nbsp;            assert(!MemberName.isMethodHandleInvokeName(name));
<i>1204</i>&nbsp;            return null;
<i>1205</i>&nbsp;        }
<i>1206</i>&nbsp;        private MethodHandle findVirtualForVH(String name, MethodType type) {
<i>1207</i>&nbsp;            try {
<i>1208</i>&nbsp;                return varHandleInvoker(VarHandle.AccessMode.valueFromMethodName(name), type);
<i>1209</i>&nbsp;            } catch (IllegalArgumentException e) {
<i>1210</i>&nbsp;                return null;
<i>1211</i>&nbsp;            }
<i>1212</i>&nbsp;        }
<i>1213</i>&nbsp;
<i>1214</i>&nbsp;        /**
<i>1215</i>&nbsp;         * Produces a method handle which creates an object and initializes it, using
<i>1216</i>&nbsp;         * the constructor of the specified type.
<i>1217</i>&nbsp;         * The parameter types of the method handle will be those of the constructor,
<i>1218</i>&nbsp;         * while the return type will be a reference to the constructor&#39;s class.
<i>1219</i>&nbsp;         * The constructor and all its argument types must be accessible to the lookup object.
<i>1220</i>&nbsp;         * &lt;p&gt;
<i>1221</i>&nbsp;         * The requested type must have a return type of {@code void}.
<i>1222</i>&nbsp;         * (This is consistent with the JVM&#39;s treatment of constructor type descriptors.)
<i>1223</i>&nbsp;         * &lt;p&gt;
<i>1224</i>&nbsp;         * The returned method handle will have
<i>1225</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
<i>1226</i>&nbsp;         * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1227</i>&nbsp;         * &lt;p&gt;
<i>1228</i>&nbsp;         * If the returned method handle is invoked, the constructor&#39;s class will
<i>1229</i>&nbsp;         * be initialized, if it has not already been initialized.
<i>1230</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<b class="nc"><i>1231</i>&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<b class="nc"><i>1232</i>&nbsp;import static java.lang.invoke.MethodHandles.*;</b>
<b class="nc"><i>1233</i>&nbsp;import static java.lang.invoke.MethodType.*;</b>
<b class="nc"><i>1234</i>&nbsp;...</b>
<i>1235</i>&nbsp;MethodHandle MH_newArrayList = publicLookup().findConstructor(
<b class="nc"><i>1236</i>&nbsp;  ArrayList.class, methodType(void.class, Collection.class));</b>
<i>1237</i>&nbsp;Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
<i>1238</i>&nbsp;Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
<i>1239</i>&nbsp;assert(orig != copy);
<i>1240</i>&nbsp;assertEquals(orig, copy);
<i>1241</i>&nbsp;// a variable-arity constructor:
<i>1242</i>&nbsp;MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
<i>1243</i>&nbsp;  ProcessBuilder.class, methodType(void.class, String[].class));
<i>1244</i>&nbsp;ProcessBuilder pb = (ProcessBuilder)
<i>1245</i>&nbsp;  MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
<i>1246</i>&nbsp;assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
<i>1247</i>&nbsp;         * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>1248</i>&nbsp;         * @param refc the class or interface from which the method is accessed
<i>1249</i>&nbsp;         * @param type the type of the method, with the receiver argument omitted, and a void return type
<i>1250</i>&nbsp;         * @return the desired method handle
<i>1251</i>&nbsp;         * @throws NoSuchMethodException if the constructor does not exist
<i>1252</i>&nbsp;         * @throws IllegalAccessException if access checking fails
<i>1253</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit
<i>1254</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails
<i>1255</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1256</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1257</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1258</i>&nbsp;         */
<i>1259</i>&nbsp;        public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
<i>1260</i>&nbsp;            if (refc.isArray()) {
<i>1261</i>&nbsp;                throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
<i>1262</i>&nbsp;            }
<i>1263</i>&nbsp;            String name = &quot;&lt;init&gt;&quot;;
<b class="nc"><i>1264</i>&nbsp;            MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);</b>
<b class="nc"><i>1265</i>&nbsp;            return getDirectConstructor(refc, ctor);</b>
<b class="nc"><i>1266</i>&nbsp;        }</b>
<b class="nc"><i>1267</i>&nbsp;</b>
<i>1268</i>&nbsp;        /**
<i>1269</i>&nbsp;         * Looks up a class by name from the lookup context defined by this {@code Lookup} object. The static
<i>1270</i>&nbsp;         * initializer of the class is not run.
<i>1271</i>&nbsp;         * &lt;p&gt;
<i>1272</i>&nbsp;         * The lookup context here is determined by the {@linkplain #lookupClass() lookup class}, its class
<i>1273</i>&nbsp;         * loader, and the {@linkplain #lookupModes() lookup modes}. In particular, the method first attempts to
<i>1274</i>&nbsp;         * load the requested class, and then determines whether the class is accessible to this lookup object.
<i>1275</i>&nbsp;         *
<i>1276</i>&nbsp;         * @param targetName the fully qualified name of the class to be looked up.
<i>1277</i>&nbsp;         * @return the requested class.
<i>1278</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1279</i>&nbsp;         *            &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1280</i>&nbsp;         * @throws LinkageError if the linkage fails
<i>1281</i>&nbsp;         * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
<i>1282</i>&nbsp;         * @throws IllegalAccessException if the class is not accessible, using the allowed access
<i>1283</i>&nbsp;         * modes.
<i>1284</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1285</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1286</i>&nbsp;         * @since 9
<i>1287</i>&nbsp;         */
<i>1288</i>&nbsp;        public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
<b class="nc"><i>1289</i>&nbsp;            Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());</b>
<i>1290</i>&nbsp;            return accessClass(targetClass);
<i>1291</i>&nbsp;        }
<b class="nc"><i>1292</i>&nbsp;</b>
<b class="nc"><i>1293</i>&nbsp;        /**</b>
<b class="nc"><i>1294</i>&nbsp;         * Determines if a class can be accessed from the lookup context defined by this {@code Lookup} object. The</b>
<b class="nc"><i>1295</i>&nbsp;         * static initializer of the class is not run.</b>
<b class="nc"><i>1296</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1297</i>&nbsp;         * The lookup context here is determined by the {@linkplain #lookupClass() lookup class} and the</b>
<i>1298</i>&nbsp;         * {@linkplain #lookupModes() lookup modes}.
<i>1299</i>&nbsp;         *
<i>1300</i>&nbsp;         * @param targetClass the class to be access-checked
<i>1301</i>&nbsp;         *
<i>1302</i>&nbsp;         * @return the class that has been access-checked
<i>1303</i>&nbsp;         *
<i>1304</i>&nbsp;         * @throws IllegalAccessException if the class is not accessible from the lookup class, using the allowed access
<i>1305</i>&nbsp;         * modes.
<i>1306</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1307</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1308</i>&nbsp;         * @since 9
<i>1309</i>&nbsp;         */
<i>1310</i>&nbsp;        public Class&lt;?&gt; accessClass(Class&lt;?&gt; targetClass) throws IllegalAccessException {
<i>1311</i>&nbsp;            if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, allowedModes)) {
<i>1312</i>&nbsp;                throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);
<i>1313</i>&nbsp;            }
<i>1314</i>&nbsp;            checkSecurityManager(targetClass, null);
<i>1315</i>&nbsp;            return targetClass;
<i>1316</i>&nbsp;        }
<i>1317</i>&nbsp;
<i>1318</i>&nbsp;        /**
<b class="nc"><i>1319</i>&nbsp;         * Produces an early-bound method handle for a virtual method.</b>
<i>1320</i>&nbsp;         * It will bypass checks for overriding methods on the receiver,
<i>1321</i>&nbsp;         * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
<i>1322</i>&nbsp;         * instruction from within the explicitly specified {@code specialCaller}.
<i>1323</i>&nbsp;         * The type of the method handle will be that of the method,
<i>1324</i>&nbsp;         * with a suitably restricted receiver type prepended.
<i>1325</i>&nbsp;         * (The receiver type will be {@code specialCaller} or a subtype.)
<i>1326</i>&nbsp;         * The method and all its argument types must be accessible
<i>1327</i>&nbsp;         * to the lookup object.
<i>1328</i>&nbsp;         * &lt;p&gt;
<i>1329</i>&nbsp;         * Before method resolution,
<i>1330</i>&nbsp;         * if the explicitly specified caller class is not identical with the
<i>1331</i>&nbsp;         * lookup class, or if this lookup object does not have
<i>1332</i>&nbsp;         * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;
<i>1333</i>&nbsp;         * privileges, the access fails.
<i>1334</i>&nbsp;         * &lt;p&gt;
<i>1335</i>&nbsp;         * The returned method handle will have
<i>1336</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
<i>1337</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1338</i>&nbsp;         * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>1339</i>&nbsp;         * &lt;em&gt;(Note:  JVM internal methods named {@code &quot;&lt;init&gt;&quot;} are not visible to this API,
<i>1340</i>&nbsp;         * even though the {@code invokespecial} instruction can refer to them
<b class="nc"><i>1341</i>&nbsp;         * in special circumstances.  Use {@link #findConstructor findConstructor}</b>
<b class="nc"><i>1342</i>&nbsp;         * to access instance initialization methods in a safe manner.)&lt;/em&gt;</b>
<b class="nc"><i>1343</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;</b>
<b class="nc"><i>1344</i>&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<b class="nc"><i>1345</i>&nbsp;import static java.lang.invoke.MethodHandles.*;</b>
<b class="nc"><i>1346</i>&nbsp;import static java.lang.invoke.MethodType.*;</b>
<b class="nc"><i>1347</i>&nbsp;...</b>
<i>1348</i>&nbsp;static class Listie extends ArrayList {
<i>1349</i>&nbsp;  public String toString() { return &quot;[wee Listie]&quot;; }
<i>1350</i>&nbsp;  static Lookup lookup() { return MethodHandles.lookup(); }
<b class="nc"><i>1351</i>&nbsp;}</b>
<b class="nc"><i>1352</i>&nbsp;...</b>
<i>1353</i>&nbsp;// no access to constructor via invokeSpecial:
<b class="nc"><i>1354</i>&nbsp;MethodHandle MH_newListie = Listie.lookup()</b>
<i>1355</i>&nbsp;  .findConstructor(Listie.class, methodType(void.class));
<i>1356</i>&nbsp;Listie l = (Listie) MH_newListie.invokeExact();
<b class="nc"><i>1357</i>&nbsp;try { assertEquals(&quot;impossible&quot;, Listie.lookup().findSpecial(</b>
<b class="nc"><i>1358</i>&nbsp;        Listie.class, &quot;&lt;init&gt;&quot;, methodType(void.class), Listie.class));</b>
<b class="nc"><i>1359</i>&nbsp; } catch (NoSuchMethodException ex) { } // OK</b>
<b class="nc"><i>1360</i>&nbsp;// access to super and self methods via invokeSpecial:</b>
<b class="nc"><i>1361</i>&nbsp;MethodHandle MH_super = Listie.lookup().findSpecial(</b>
<b class="nc"><i>1362</i>&nbsp;  ArrayList.class, &quot;toString&quot; , methodType(String.class), Listie.class);</b>
<b class="nc"><i>1363</i>&nbsp;MethodHandle MH_this = Listie.lookup().findSpecial(</b>
<b class="nc"><i>1364</i>&nbsp;  Listie.class, &quot;toString&quot; , methodType(String.class), Listie.class);</b>
<b class="nc"><i>1365</i>&nbsp;MethodHandle MH_duper = Listie.lookup().findSpecial(</b>
<i>1366</i>&nbsp;  Object.class, &quot;toString&quot; , methodType(String.class), Listie.class);
<i>1367</i>&nbsp;assertEquals(&quot;[]&quot;, (String) MH_super.invokeExact(l));
<b class="nc"><i>1368</i>&nbsp;assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(l));</b>
<i>1369</i>&nbsp;assertEquals(&quot;[]&quot;, (String) MH_duper.invokeExact(l)); // ArrayList method
<i>1370</i>&nbsp;try { assertEquals(&quot;inaccessible&quot;, Listie.lookup().findSpecial(
<i>1371</i>&nbsp;        String.class, &quot;toString&quot;, methodType(String.class), Listie.class));
<i>1372</i>&nbsp; } catch (IllegalAccessException ex) { } // OK
<i>1373</i>&nbsp;Listie subl = new Listie() { public String toString() { return &quot;[subclass]&quot;; } };
<b class="nc"><i>1374</i>&nbsp;assertEquals(&quot;&quot;+l, (String) MH_this.invokeExact(subl)); // Listie method</b>
<b class="nc"><i>1375</i>&nbsp;         * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1376</i>&nbsp;         *</b>
<b class="nc"><i>1377</i>&nbsp;         * @param refc the class or interface from which the method is accessed</b>
<i>1378</i>&nbsp;         * @param name the name of the method (which must not be &quot;&amp;lt;init&amp;gt;&quot;)
<i>1379</i>&nbsp;         * @param type the type of the method, with the receiver argument omitted
<i>1380</i>&nbsp;         * @param specialCaller the proposed calling class to perform the {@code invokespecial}
<i>1381</i>&nbsp;         * @return the desired method handle
<b class="nc"><i>1382</i>&nbsp;         * @throws NoSuchMethodException if the method does not exist</b>
<b class="nc"><i>1383</i>&nbsp;         * @throws IllegalAccessException if access checking fails,</b>
<b class="nc"><i>1384</i>&nbsp;         *                                or if the method is {@code static},</b>
<b class="nc"><i>1385</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit</b>
<b class="nc"><i>1386</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails</b>
<i>1387</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1388</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1389</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1390</i>&nbsp;         */
<b class="nc"><i>1391</i>&nbsp;        public MethodHandle findSpecial(Class&lt;?&gt; refc, String name, MethodType type,</b>
<b class="nc"><i>1392</i>&nbsp;                                        Class&lt;?&gt; specialCaller) throws NoSuchMethodException, IllegalAccessException {</b>
<b class="nc"><i>1393</i>&nbsp;            checkSpecialCaller(specialCaller, refc);</b>
<b class="nc"><i>1394</i>&nbsp;            Lookup specialLookup = this.in(specialCaller);</b>
<i>1395</i>&nbsp;            MemberName method = specialLookup.resolveOrFail(REF_invokeSpecial, refc, name, type);
<i>1396</i>&nbsp;            return specialLookup.getDirectMethod(REF_invokeSpecial, refc, method, findBoundCallerClass(method));
<i>1397</i>&nbsp;        }
<i>1398</i>&nbsp;
<b class="nc"><i>1399</i>&nbsp;        /**</b>
<b class="nc"><i>1400</i>&nbsp;         * Produces a method handle giving read access to a non-static field.</b>
<b class="nc"><i>1401</i>&nbsp;         * The type of the method handle will have a return type of the field&#39;s</b>
<b class="nc"><i>1402</i>&nbsp;         * value type.</b>
<i>1403</i>&nbsp;         * The method handle&#39;s single argument will be the instance containing
<i>1404</i>&nbsp;         * the field.
<i>1405</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup class.
<i>1406</i>&nbsp;         * @param refc the class or interface from which the method is accessed
<b class="nc"><i>1407</i>&nbsp;         * @param name the field&#39;s name</b>
<b class="nc"><i>1408</i>&nbsp;         * @param type the field&#39;s type</b>
<i>1409</i>&nbsp;         * @return a method handle which can load values from the field
<i>1410</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist
<i>1411</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<i>1412</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1413</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1414</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1415</i>&nbsp;         * @see #findVarHandle(Class, String, Class)
<i>1416</i>&nbsp;         */
<i>1417</i>&nbsp;        public MethodHandle findGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<b class="nc"><i>1418</i>&nbsp;            MemberName field = resolveOrFail(REF_getField, refc, name, type);</b>
<b class="nc"><i>1419</i>&nbsp;            return getDirectField(REF_getField, refc, field);</b>
<i>1420</i>&nbsp;        }
<b class="nc"><i>1421</i>&nbsp;</b>
<b class="nc"><i>1422</i>&nbsp;        /**</b>
<i>1423</i>&nbsp;         * Produces a method handle giving write access to a non-static field.
<b class="nc"><i>1424</i>&nbsp;         * The type of the method handle will have a void return type.</b>
<i>1425</i>&nbsp;         * The method handle will take two arguments, the instance containing
<i>1426</i>&nbsp;         * the field, and the value to be stored.
<b class="nc"><i>1427</i>&nbsp;         * The second argument will be of the field&#39;s value type.</b>
<i>1428</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup class.
<i>1429</i>&nbsp;         * @param refc the class or interface from which the method is accessed
<i>1430</i>&nbsp;         * @param name the field&#39;s name
<b class="nc"><i>1431</i>&nbsp;         * @param type the field&#39;s type</b>
<i>1432</i>&nbsp;         * @return a method handle which can store values into the field
<i>1433</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist
<i>1434</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<i>1435</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1436</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1437</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1438</i>&nbsp;         * @see #findVarHandle(Class, String, Class)
<i>1439</i>&nbsp;         */
<b class="nc"><i>1440</i>&nbsp;        public MethodHandle findSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {</b>
<b class="nc"><i>1441</i>&nbsp;            MemberName field = resolveOrFail(REF_putField, refc, name, type);</b>
<b class="nc"><i>1442</i>&nbsp;            return getDirectField(REF_putField, refc, field);</b>
<i>1443</i>&nbsp;        }
<i>1444</i>&nbsp;
<b class="nc"><i>1445</i>&nbsp;        /**</b>
<b class="nc"><i>1446</i>&nbsp;         * Produces a VarHandle giving access to a non-static field {@code name}</b>
<b class="nc"><i>1447</i>&nbsp;         * of type {@code type} declared in a class of type {@code recv}.</b>
<b class="nc"><i>1448</i>&nbsp;         * The VarHandle&#39;s variable type is {@code type} and it has one</b>
<i>1449</i>&nbsp;         * coordinate type, {@code recv}.
<i>1450</i>&nbsp;         * &lt;p&gt;
<i>1451</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup
<b class="nc"><i>1452</i>&nbsp;         * class.</b>
<b class="nc"><i>1453</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1454</i>&nbsp;         * Certain access modes of the returned VarHandle are unsupported under</b>
<i>1455</i>&nbsp;         * the following conditions:
<i>1456</i>&nbsp;         * &lt;ul&gt;
<i>1457</i>&nbsp;         * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
<b class="nc"><i>1458</i>&nbsp;         *     update, numeric atomic update, and bitwise atomic update access</b>
<b class="nc"><i>1459</i>&nbsp;         *     modes are unsupported.</b>
<b class="nc"><i>1460</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code byte},</b>
<i>1461</i>&nbsp;         *     {@code short}, {@code char}, {@code int}, {@code long},
<i>1462</i>&nbsp;         *     {@code float}, or {@code double} then numeric atomic update
<i>1463</i>&nbsp;         *     access modes are unsupported.
<i>1464</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code boolean},
<b class="nc"><i>1465</i>&nbsp;         *     {@code byte}, {@code short}, {@code char}, {@code int} or</b>
<i>1466</i>&nbsp;         *     {@code long} then bitwise atomic update access modes are
<b class="nc"><i>1467</i>&nbsp;         *     unsupported.</b>
<b class="nc"><i>1468</i>&nbsp;         * &lt;/ul&gt;</b>
<b class="nc"><i>1469</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1470</i>&nbsp;         * If the field is declared {@code volatile} then the returned VarHandle</b>
<b class="nc"><i>1471</i>&nbsp;         * will override access to the field (effectively ignore the</b>
<b class="nc"><i>1472</i>&nbsp;         * {@code volatile} declaration) in accordance to its specified</b>
<i>1473</i>&nbsp;         * access modes.
<b class="nc"><i>1474</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1475</i>&nbsp;         * If the field type is {@code float} or {@code double} then numeric</b>
<i>1476</i>&nbsp;         * and atomic update access modes compare values using their bitwise
<i>1477</i>&nbsp;         * representation (see {@link Float#floatToRawIntBits} and
<i>1478</i>&nbsp;         * {@link Double#doubleToRawLongBits}, respectively).
<b class="nc"><i>1479</i>&nbsp;         * @apiNote</b>
<i>1480</i>&nbsp;         * Bitwise comparison of {@code float} values or {@code double} values,
<b class="nc"><i>1481</i>&nbsp;         * as performed by the numeric and atomic update access modes, differ</b>
<b class="nc"><i>1482</i>&nbsp;         * from the primitive {@code ==} operator and the {@link Float#equals}</b>
<i>1483</i>&nbsp;         * and {@link Double#equals} methods, specifically with respect to
<b class="nc"><i>1484</i>&nbsp;         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.</b>
<b class="nc"><i>1485</i>&nbsp;         * Care should be taken when performing a compare and set or a compare</b>
<i>1486</i>&nbsp;         * and exchange operation with such values since the operation may
<i>1487</i>&nbsp;         * unexpectedly fail.
<i>1488</i>&nbsp;         * There are many possible NaN values that are considered to be
<i>1489</i>&nbsp;         * {@code NaN} in Java, although no IEEE 754 floating-point operation
<b class="nc"><i>1490</i>&nbsp;         * provided by Java can distinguish between them.  Operation failure can</b>
<b class="nc"><i>1491</i>&nbsp;         * occur if the expected or witness value is a NaN value and it is</b>
<b class="nc"><i>1492</i>&nbsp;         * transformed (perhaps in a platform specific manner) into another NaN</b>
<b class="nc"><i>1493</i>&nbsp;         * value, and thus has a different bitwise representation (see</b>
<b class="nc"><i>1494</i>&nbsp;         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more</b>
<b class="nc"><i>1495</i>&nbsp;         * details).</b>
<b class="nc"><i>1496</i>&nbsp;         * The values {@code -0.0} and {@code +0.0} have different bitwise</b>
<i>1497</i>&nbsp;         * representations but are considered equal when using the primitive
<b class="nc"><i>1498</i>&nbsp;         * {@code ==} operator.  Operation failure can occur if, for example, a</b>
<b class="nc"><i>1499</i>&nbsp;         * numeric algorithm computes an expected value to be say {@code -0.0}</b>
<b class="nc"><i>1500</i>&nbsp;         * and previously computed the witness value to be say {@code +0.0}.</b>
<i>1501</i>&nbsp;         * @param recv the receiver class, of type {@code R}, that declares the
<i>1502</i>&nbsp;         * non-static field
<i>1503</i>&nbsp;         * @param name the field&#39;s name
<i>1504</i>&nbsp;         * @param type the field&#39;s type, of type {@code T}
<i>1505</i>&nbsp;         * @return a VarHandle giving access to non-static fields.
<i>1506</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist
<i>1507</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is {@code static}
<i>1508</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1509</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1510</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1511</i>&nbsp;         * @since 9
<i>1512</i>&nbsp;         */
<i>1513</i>&nbsp;        public VarHandle findVarHandle(Class&lt;?&gt; recv, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<b class="nc"><i>1514</i>&nbsp;            MemberName getField = resolveOrFail(REF_getField, recv, name, type);</b>
<i>1515</i>&nbsp;            MemberName putField = resolveOrFail(REF_putField, recv, name, type);
<b class="nc"><i>1516</i>&nbsp;            return getFieldVarHandle(REF_getField, REF_putField, recv, getField, putField);</b>
<i>1517</i>&nbsp;        }
<b class="nc"><i>1518</i>&nbsp;</b>
<i>1519</i>&nbsp;        /**
<b class="nc"><i>1520</i>&nbsp;         * Produces a method handle giving read access to a static field.</b>
<b class="nc"><i>1521</i>&nbsp;         * The type of the method handle will have a return type of the field&#39;s</b>
<b class="nc"><i>1522</i>&nbsp;         * value type.</b>
<b class="nc"><i>1523</i>&nbsp;         * The method handle will take no arguments.</b>
<i>1524</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup class.
<b class="nc"><i>1525</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1526</i>&nbsp;         * If the returned method handle is invoked, the field&#39;s class will</b>
<b class="nc"><i>1527</i>&nbsp;         * be initialized, if it has not already been initialized.</b>
<b class="nc"><i>1528</i>&nbsp;         * @param refc the class or interface from which the method is accessed</b>
<i>1529</i>&nbsp;         * @param name the field&#39;s name
<i>1530</i>&nbsp;         * @param type the field&#39;s type
<i>1531</i>&nbsp;         * @return a method handle which can load values from the field
<b class="nc"><i>1532</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist</b>
<b class="nc"><i>1533</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}</b>
<i>1534</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1535</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<b class="nc"><i>1536</i>&nbsp;         * @throws NullPointerException if any argument is null</b>
<i>1537</i>&nbsp;         */
<i>1538</i>&nbsp;        public MethodHandle findStaticGetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<i>1539</i>&nbsp;            MemberName field = resolveOrFail(REF_getStatic, refc, name, type);
<b class="nc"><i>1540</i>&nbsp;            return getDirectField(REF_getStatic, refc, field);</b>
<b class="nc"><i>1541</i>&nbsp;        }</b>
<i>1542</i>&nbsp;
<b class="nc"><i>1543</i>&nbsp;        /**</b>
<i>1544</i>&nbsp;         * Produces a method handle giving write access to a static field.
<b class="nc"><i>1545</i>&nbsp;         * The type of the method handle will have a void return type.</b>
<b class="nc"><i>1546</i>&nbsp;         * The method handle will take a single</b>
<b class="nc"><i>1547</i>&nbsp;         * argument, of the field&#39;s value type, the value to be stored.</b>
<i>1548</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup class.
<b class="nc"><i>1549</i>&nbsp;         * &lt;p&gt;</b>
<i>1550</i>&nbsp;         * If the returned method handle is invoked, the field&#39;s class will
<b class="nc"><i>1551</i>&nbsp;         * be initialized, if it has not already been initialized.</b>
<b class="nc"><i>1552</i>&nbsp;         * @param refc the class or interface from which the method is accessed</b>
<b class="nc"><i>1553</i>&nbsp;         * @param name the field&#39;s name</b>
<b class="nc"><i>1554</i>&nbsp;         * @param type the field&#39;s type</b>
<b class="nc"><i>1555</i>&nbsp;         * @return a method handle which can store values into the field</b>
<b class="nc"><i>1556</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist</b>
<b class="nc"><i>1557</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}</b>
<b class="nc"><i>1558</i>&nbsp;         * @exception SecurityException if a security manager is present and it</b>
<b class="nc"><i>1559</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</b>
<i>1560</i>&nbsp;         * @throws NullPointerException if any argument is null
<i>1561</i>&nbsp;         */
<i>1562</i>&nbsp;        public MethodHandle findStaticSetter(Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<i>1563</i>&nbsp;            MemberName field = resolveOrFail(REF_putStatic, refc, name, type);
<i>1564</i>&nbsp;            return getDirectField(REF_putStatic, refc, field);
<b class="nc"><i>1565</i>&nbsp;        }</b>
<b class="nc"><i>1566</i>&nbsp;</b>
<b class="nc"><i>1567</i>&nbsp;        /**</b>
<b class="nc"><i>1568</i>&nbsp;         * Produces a VarHandle giving access to a static field {@code name} of</b>
<i>1569</i>&nbsp;         * type {@code type} declared in a class of type {@code decl}.
<i>1570</i>&nbsp;         * The VarHandle&#39;s variable type is {@code type} and it has no
<b class="nc"><i>1571</i>&nbsp;         * coordinate types.</b>
<b class="nc"><i>1572</i>&nbsp;         * &lt;p&gt;</b>
<i>1573</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup
<i>1574</i>&nbsp;         * class.
<i>1575</i>&nbsp;         * &lt;p&gt;
<i>1576</i>&nbsp;         * If the returned VarHandle is operated on, the declaring class will be
<i>1577</i>&nbsp;         * initialized, if it has not already been initialized.
<b class="nc"><i>1578</i>&nbsp;         * &lt;p&gt;</b>
<i>1579</i>&nbsp;         * Certain access modes of the returned VarHandle are unsupported under
<b class="nc"><i>1580</i>&nbsp;         * the following conditions:</b>
<b class="nc"><i>1581</i>&nbsp;         * &lt;ul&gt;</b>
<i>1582</i>&nbsp;         * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
<i>1583</i>&nbsp;         *     update, numeric atomic update, and bitwise atomic update access
<b class="nc"><i>1584</i>&nbsp;         *     modes are unsupported.</b>
<b class="nc"><i>1585</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code byte},</b>
<i>1586</i>&nbsp;         *     {@code short}, {@code char}, {@code int}, {@code long},
<i>1587</i>&nbsp;         *     {@code float}, or {@code double}, then numeric atomic update
<b class="nc"><i>1588</i>&nbsp;         *     access modes are unsupported.</b>
<i>1589</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code boolean},
<b class="nc"><i>1590</i>&nbsp;         *     {@code byte}, {@code short}, {@code char}, {@code int} or</b>
<b class="nc"><i>1591</i>&nbsp;         *     {@code long} then bitwise atomic update access modes are</b>
<i>1592</i>&nbsp;         *     unsupported.
<b class="nc"><i>1593</i>&nbsp;         * &lt;/ul&gt;</b>
<b class="nc"><i>1594</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1595</i>&nbsp;         * If the field is declared {@code volatile} then the returned VarHandle</b>
<b class="nc"><i>1596</i>&nbsp;         * will override access to the field (effectively ignore the</b>
<b class="nc"><i>1597</i>&nbsp;         * {@code volatile} declaration) in accordance to its specified</b>
<b class="nc"><i>1598</i>&nbsp;         * access modes.</b>
<i>1599</i>&nbsp;         * &lt;p&gt;
<i>1600</i>&nbsp;         * If the field type is {@code float} or {@code double} then numeric
<i>1601</i>&nbsp;         * and atomic update access modes compare values using their bitwise
<i>1602</i>&nbsp;         * representation (see {@link Float#floatToRawIntBits} and
<i>1603</i>&nbsp;         * {@link Double#doubleToRawLongBits}, respectively).
<i>1604</i>&nbsp;         * @apiNote
<b class="nc"><i>1605</i>&nbsp;         * Bitwise comparison of {@code float} values or {@code double} values,</b>
<i>1606</i>&nbsp;         * as performed by the numeric and atomic update access modes, differ
<i>1607</i>&nbsp;         * from the primitive {@code ==} operator and the {@link Float#equals}
<i>1608</i>&nbsp;         * and {@link Double#equals} methods, specifically with respect to
<i>1609</i>&nbsp;         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
<i>1610</i>&nbsp;         * Care should be taken when performing a compare and set or a compare
<b class="nc"><i>1611</i>&nbsp;         * and exchange operation with such values since the operation may</b>
<i>1612</i>&nbsp;         * unexpectedly fail.
<i>1613</i>&nbsp;         * There are many possible NaN values that are considered to be
<i>1614</i>&nbsp;         * {@code NaN} in Java, although no IEEE 754 floating-point operation
<i>1615</i>&nbsp;         * provided by Java can distinguish between them.  Operation failure can
<i>1616</i>&nbsp;         * occur if the expected or witness value is a NaN value and it is
<b class="nc"><i>1617</i>&nbsp;         * transformed (perhaps in a platform specific manner) into another NaN</b>
<i>1618</i>&nbsp;         * value, and thus has a different bitwise representation (see
<i>1619</i>&nbsp;         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
<i>1620</i>&nbsp;         * details).
<i>1621</i>&nbsp;         * The values {@code -0.0} and {@code +0.0} have different bitwise
<i>1622</i>&nbsp;         * representations but are considered equal when using the primitive
<b class="nc"><i>1623</i>&nbsp;         * {@code ==} operator.  Operation failure can occur if, for example, a</b>
<i>1624</i>&nbsp;         * numeric algorithm computes an expected value to be say {@code -0.0}
<b class="nc"><i>1625</i>&nbsp;         * and previously computed the witness value to be say {@code +0.0}.</b>
<b class="nc"><i>1626</i>&nbsp;         * @param decl the class that declares the static field</b>
<b class="nc"><i>1627</i>&nbsp;         * @param name the field&#39;s name</b>
<i>1628</i>&nbsp;         * @param type the field&#39;s type, of type {@code T}
<b class="nc"><i>1629</i>&nbsp;         * @return a VarHandle giving access to a static field</b>
<b class="nc"><i>1630</i>&nbsp;         * @throws NoSuchFieldException if the field does not exist</b>
<b class="nc"><i>1631</i>&nbsp;         * @throws IllegalAccessException if access checking fails, or if the field is not {@code static}</b>
<b class="nc"><i>1632</i>&nbsp;         * @exception SecurityException if a security manager is present and it</b>
<b class="nc"><i>1633</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</b>
<b class="nc"><i>1634</i>&nbsp;         * @throws NullPointerException if any argument is null</b>
<i>1635</i>&nbsp;         * @since 9
<i>1636</i>&nbsp;         */
<i>1637</i>&nbsp;        public VarHandle findStaticVarHandle(Class&lt;?&gt; decl, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<i>1638</i>&nbsp;            MemberName getField = resolveOrFail(REF_getStatic, decl, name, type);
<i>1639</i>&nbsp;            MemberName putField = resolveOrFail(REF_putStatic, decl, name, type);
<i>1640</i>&nbsp;            return getFieldVarHandle(REF_getStatic, REF_putStatic, decl, getField, putField);
<i>1641</i>&nbsp;        }
<b class="nc"><i>1642</i>&nbsp;</b>
<i>1643</i>&nbsp;        /**
<i>1644</i>&nbsp;         * Produces an early-bound method handle for a non-static method.
<b class="nc"><i>1645</i>&nbsp;         * The receiver must have a supertype {@code defc} in which a method</b>
<b class="nc"><i>1646</i>&nbsp;         * of the given name and type is accessible to the lookup class.</b>
<b class="nc"><i>1647</i>&nbsp;         * The method and all its argument types must be accessible to the lookup object.</b>
<b class="nc"><i>1648</i>&nbsp;         * The type of the method handle will be that of the method,</b>
<i>1649</i>&nbsp;         * without any insertion of an additional receiver parameter.
<b class="nc"><i>1650</i>&nbsp;         * The given receiver will be bound into the method handle,</b>
<b class="nc"><i>1651</i>&nbsp;         * so that every call to the method handle will invoke the</b>
<i>1652</i>&nbsp;         * requested method on the given receiver.
<b class="nc"><i>1653</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1654</i>&nbsp;         * The returned method handle will have</b>
<b class="nc"><i>1655</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if</b>
<i>1656</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set
<b class="nc"><i>1657</i>&nbsp;         * &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument.</b>
<i>1658</i>&nbsp;         * (If the trailing array argument is the only argument,
<i>1659</i>&nbsp;         * the given receiver value will be bound to it.)
<b class="nc"><i>1660</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1661</i>&nbsp;         * This is almost equivalent to the following code, with some differences noted below:</b>
<i>1662</i>&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;{@code
<b class="nc"><i>1663</i>&nbsp;import static java.lang.invoke.MethodHandles.*;</b>
<i>1664</i>&nbsp;import static java.lang.invoke.MethodType.*;
<b class="nc"><i>1665</i>&nbsp;...</b>
<b class="nc"><i>1666</i>&nbsp;MethodHandle mh0 = lookup().findVirtual(defc, name, type);</b>
<b class="nc"><i>1667</i>&nbsp;MethodHandle mh1 = mh0.bindTo(receiver);</b>
<i>1668</i>&nbsp;mh1 = mh1.withVarargs(mh0.isVarargsCollector());
<b class="nc"><i>1669</i>&nbsp;return mh1;</b>
<b class="nc"><i>1670</i>&nbsp;         * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>1671</i>&nbsp;         * where {@code defc} is either {@code receiver.getClass()} or a super</b>
<i>1672</i>&nbsp;         * type of that class, in which the requested method is accessible
<i>1673</i>&nbsp;         * to the lookup class.
<i>1674</i>&nbsp;         * (Unlike {@code bind}, {@code bindTo} does not preserve variable arity.
<i>1675</i>&nbsp;         * Also, {@code bindTo} may throw a {@code ClassCastException} in instances where {@code bind} would
<b class="nc"><i>1676</i>&nbsp;         * throw an {@code IllegalAccessException}, as in the case where the member is {@code protected} and</b>
<b class="nc"><i>1677</i>&nbsp;         * the receiver is restricted by {@code findVirtual} to the lookup class.)</b>
<b class="nc"><i>1678</i>&nbsp;         * @param receiver the object from which the method is accessed</b>
<b class="nc"><i>1679</i>&nbsp;         * @param name the name of the method</b>
<b class="nc"><i>1680</i>&nbsp;         * @param type the type of the method, with the receiver argument omitted</b>
<b class="nc"><i>1681</i>&nbsp;         * @return the desired method handle</b>
<i>1682</i>&nbsp;         * @throws NoSuchMethodException if the method does not exist
<b class="nc"><i>1683</i>&nbsp;         * @throws IllegalAccessException if access checking fails</b>
<i>1684</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit
<i>1685</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails
<i>1686</i>&nbsp;         * @exception SecurityException if a security manager is present and it
<i>1687</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<b class="nc"><i>1688</i>&nbsp;         * @throws NullPointerException if any argument is null</b>
<i>1689</i>&nbsp;         * @see MethodHandle#bindTo
<i>1690</i>&nbsp;         * @see #findVirtual
<i>1691</i>&nbsp;         */
<i>1692</i>&nbsp;        public MethodHandle bind(Object receiver, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
<b class="nc"><i>1693</i>&nbsp;            Class&lt;? extends Object&gt; refc = receiver.getClass(); // may get NPE</b>
<i>1694</i>&nbsp;            MemberName method = resolveOrFail(REF_invokeSpecial, refc, name, type);
<i>1695</i>&nbsp;            MethodHandle mh = getDirectMethodNoRestrictInvokeSpecial(refc, method, findBoundCallerClass(method));
<i>1696</i>&nbsp;            if (!mh.type().leadingReferenceParameter().isAssignableFrom(receiver.getClass())) {
<i>1697</i>&nbsp;                throw new IllegalAccessException(&quot;The restricted defining class &quot; +
<b class="nc"><i>1698</i>&nbsp;                                                 mh.type().leadingReferenceParameter().getName() +</b>
<i>1699</i>&nbsp;                                                 &quot; is not assignable from receiver class &quot; +
<b class="nc"><i>1700</i>&nbsp;                                                 receiver.getClass().getName());</b>
<b class="nc"><i>1701</i>&nbsp;            }</b>
<b class="nc"><i>1702</i>&nbsp;            return mh.bindArgumentL(0, receiver).setVarargs(method);</b>
<b class="nc"><i>1703</i>&nbsp;        }</b>
<b class="nc"><i>1704</i>&nbsp;</b>
<b class="nc"><i>1705</i>&nbsp;        /**</b>
<b class="nc"><i>1706</i>&nbsp;         * Makes a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;</b>
<b class="nc"><i>1707</i>&nbsp;         * to &lt;i&gt;m&lt;/i&gt;, if the lookup class has permission.</b>
<i>1708</i>&nbsp;         * If &lt;i&gt;m&lt;/i&gt; is non-static, the receiver argument is treated as an initial argument.
<i>1709</i>&nbsp;         * If &lt;i&gt;m&lt;/i&gt; is virtual, overriding is respected on every call.
<i>1710</i>&nbsp;         * Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
<i>1711</i>&nbsp;         * The type of the method handle will be that of the method,
<b class="nc"><i>1712</i>&nbsp;         * with the receiver type prepended (but only if it is non-static).</b>
<i>1713</i>&nbsp;         * If the method&#39;s {@code accessible} flag is not set,
<i>1714</i>&nbsp;         * access checking is performed immediately on behalf of the lookup class.
<i>1715</i>&nbsp;         * If &lt;i&gt;m&lt;/i&gt; is not public, do not share the resulting handle with untrusted parties.
<i>1716</i>&nbsp;         * &lt;p&gt;
<b class="nc"><i>1717</i>&nbsp;         * The returned method handle will have</b>
<i>1718</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
<i>1719</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1720</i>&nbsp;         * &lt;p&gt;
<i>1721</i>&nbsp;         * If &lt;i&gt;m&lt;/i&gt; is static, and
<b class="nc"><i>1722</i>&nbsp;         * if the returned method handle is invoked, the method&#39;s class will</b>
<b class="nc"><i>1723</i>&nbsp;         * be initialized, if it has not already been initialized.</b>
<i>1724</i>&nbsp;         * @param m the reflected method
<b class="nc"><i>1725</i>&nbsp;         * @return a method handle which can invoke the reflected method</b>
<b class="nc"><i>1726</i>&nbsp;         * @throws IllegalAccessException if access checking fails</b>
<b class="nc"><i>1727</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit</b>
<b class="nc"><i>1728</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails</b>
<i>1729</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>1730</i>&nbsp;         */
<i>1731</i>&nbsp;        public MethodHandle unreflect(Method m) throws IllegalAccessException {
<i>1732</i>&nbsp;            if (m.getDeclaringClass() == MethodHandle.class) {
<i>1733</i>&nbsp;                MethodHandle mh = unreflectForMH(m);
<i>1734</i>&nbsp;                if (mh != null)  return mh;
<b class="nc"><i>1735</i>&nbsp;            }</b>
<b class="nc"><i>1736</i>&nbsp;            if (m.getDeclaringClass() == VarHandle.class) {</b>
<b class="nc"><i>1737</i>&nbsp;                MethodHandle mh = unreflectForVH(m);</b>
<b class="nc"><i>1738</i>&nbsp;                if (mh != null)  return mh;</b>
<b class="nc"><i>1739</i>&nbsp;            }</b>
<b class="nc"><i>1740</i>&nbsp;            MemberName method = new MemberName(m);</b>
<b class="nc"><i>1741</i>&nbsp;            byte refKind = method.getReferenceKind();</b>
<i>1742</i>&nbsp;            if (refKind == REF_invokeSpecial)
<i>1743</i>&nbsp;                refKind = REF_invokeVirtual;
<b class="nc"><i>1744</i>&nbsp;            assert(method.isMethod());</b>
<b class="nc"><i>1745</i>&nbsp;            @SuppressWarnings(&quot;deprecation&quot;)</b>
<b class="nc"><i>1746</i>&nbsp;            Lookup lookup = m.isAccessible() ? IMPL_LOOKUP : this;</b>
<b class="nc"><i>1747</i>&nbsp;            return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerClass(method));</b>
<i>1748</i>&nbsp;        }
<i>1749</i>&nbsp;        private MethodHandle unreflectForMH(Method m) {
<b class="nc"><i>1750</i>&nbsp;            // these names require special lookups because they throw UnsupportedOperationException</b>
<b class="nc"><i>1751</i>&nbsp;            if (MemberName.isMethodHandleInvokeName(m.getName()))</b>
<b class="nc"><i>1752</i>&nbsp;                return MethodHandleImpl.fakeMethodHandleInvoke(new MemberName(m));</b>
<b class="nc"><i>1753</i>&nbsp;            return null;</b>
<b class="nc"><i>1754</i>&nbsp;        }</b>
<b class="nc"><i>1755</i>&nbsp;        private MethodHandle unreflectForVH(Method m) {</b>
<b class="nc"><i>1756</i>&nbsp;            // these names require special lookups because they throw UnsupportedOperationException</b>
<i>1757</i>&nbsp;            if (MemberName.isVarHandleMethodInvokeName(m.getName()))
<b class="nc"><i>1758</i>&nbsp;                return MethodHandleImpl.fakeVarHandleInvoke(new MemberName(m));</b>
<b class="nc"><i>1759</i>&nbsp;            return null;</b>
<i>1760</i>&nbsp;        }
<i>1761</i>&nbsp;
<b class="nc"><i>1762</i>&nbsp;        /**</b>
<i>1763</i>&nbsp;         * Produces a method handle for a reflected method.
<i>1764</i>&nbsp;         * It will bypass checks for overriding methods on the receiver,
<i>1765</i>&nbsp;         * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if called&lt;/a&gt; from an {@code invokespecial}
<b class="nc"><i>1766</i>&nbsp;         * instruction from within the explicitly specified {@code specialCaller}.</b>
<b class="nc"><i>1767</i>&nbsp;         * The type of the method handle will be that of the method,</b>
<i>1768</i>&nbsp;         * with a suitably restricted receiver type prepended.
<b class="nc"><i>1769</i>&nbsp;         * (The receiver type will be {@code specialCaller} or a subtype.)</b>
<b class="nc"><i>1770</i>&nbsp;         * If the method&#39;s {@code accessible} flag is not set,</b>
<b class="nc"><i>1771</i>&nbsp;         * access checking is performed immediately on behalf of the lookup class,</b>
<b class="nc"><i>1772</i>&nbsp;         * as if {@code invokespecial} instruction were being linked.</b>
<b class="nc"><i>1773</i>&nbsp;         * &lt;p&gt;</b>
<i>1774</i>&nbsp;         * Before method resolution,
<b class="nc"><i>1775</i>&nbsp;         * if the explicitly specified caller class is not identical with the</b>
<b class="nc"><i>1776</i>&nbsp;         * lookup class, or if this lookup object does not have</b>
<b class="nc"><i>1777</i>&nbsp;         * &lt;a href=&quot;MethodHandles.Lookup.html#privacc&quot;&gt;private access&lt;/a&gt;</b>
<b class="nc"><i>1778</i>&nbsp;         * privileges, the access fails.</b>
<b class="nc"><i>1779</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1780</i>&nbsp;         * The returned method handle will have</b>
<b class="nc"><i>1781</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if</b>
<i>1782</i>&nbsp;         * the method&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<b class="nc"><i>1783</i>&nbsp;         * @param m the reflected method</b>
<b class="nc"><i>1784</i>&nbsp;         * @param specialCaller the class nominally calling the method</b>
<i>1785</i>&nbsp;         * @return a method handle which can invoke the reflected method
<i>1786</i>&nbsp;         * @throws IllegalAccessException if access checking fails,
<i>1787</i>&nbsp;         *                                or if the method is {@code static},
<b class="nc"><i>1788</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit</b>
<b class="nc"><i>1789</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails</b>
<b class="nc"><i>1790</i>&nbsp;         * @throws NullPointerException if any argument is null</b>
<b class="nc"><i>1791</i>&nbsp;         */</b>
<b class="nc"><i>1792</i>&nbsp;        public MethodHandle unreflectSpecial(Method m, Class&lt;?&gt; specialCaller) throws IllegalAccessException {</b>
<b class="nc"><i>1793</i>&nbsp;            checkSpecialCaller(specialCaller, null);</b>
<b class="nc"><i>1794</i>&nbsp;            Lookup specialLookup = this.in(specialCaller);</b>
<i>1795</i>&nbsp;            MemberName method = new MemberName(m, true);
<i>1796</i>&nbsp;            assert(method.isMethod());
<i>1797</i>&nbsp;            // ignore m.isAccessible:  this is a new kind of access
<i>1798</i>&nbsp;            return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerClass(method));
<b class="nc"><i>1799</i>&nbsp;        }</b>
<b class="nc"><i>1800</i>&nbsp;</b>
<b class="nc"><i>1801</i>&nbsp;        /**</b>
<b class="nc"><i>1802</i>&nbsp;         * Produces a method handle for a reflected constructor.</b>
<b class="nc"><i>1803</i>&nbsp;         * The type of the method handle will be that of the constructor,</b>
<b class="nc"><i>1804</i>&nbsp;         * with the return type changed to the declaring class.</b>
<i>1805</i>&nbsp;         * The method handle will perform a {@code newInstance} operation,
<i>1806</i>&nbsp;         * creating a new instance of the constructor&#39;s class on the
<b class="nc"><i>1807</i>&nbsp;         * arguments passed to the method handle.</b>
<i>1808</i>&nbsp;         * &lt;p&gt;
<i>1809</i>&nbsp;         * If the constructor&#39;s {@code accessible} flag is not set,
<b class="nc"><i>1810</i>&nbsp;         * access checking is performed immediately on behalf of the lookup class.</b>
<i>1811</i>&nbsp;         * &lt;p&gt;
<i>1812</i>&nbsp;         * The returned method handle will have
<i>1813</i>&nbsp;         * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
<i>1814</i>&nbsp;         * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
<i>1815</i>&nbsp;         * &lt;p&gt;
<i>1816</i>&nbsp;         * If the returned method handle is invoked, the constructor&#39;s class will
<i>1817</i>&nbsp;         * be initialized, if it has not already been initialized.
<i>1818</i>&nbsp;         * @param c the reflected constructor
<i>1819</i>&nbsp;         * @return a method handle which can invoke the reflected constructor
<i>1820</i>&nbsp;         * @throws IllegalAccessException if access checking fails
<i>1821</i>&nbsp;         *                                or if the method&#39;s variable arity modifier bit
<i>1822</i>&nbsp;         *                                is set and {@code asVarargsCollector} fails
<i>1823</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>1824</i>&nbsp;         */
<b class="nc"><i>1825</i>&nbsp;        public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {</b>
<i>1826</i>&nbsp;            MemberName ctor = new MemberName(c);
<i>1827</i>&nbsp;            assert(ctor.isConstructor());
<i>1828</i>&nbsp;            @SuppressWarnings(&quot;deprecation&quot;)
<i>1829</i>&nbsp;            Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<i>1830</i>&nbsp;            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);
<i>1831</i>&nbsp;        }
<i>1832</i>&nbsp;
<i>1833</i>&nbsp;        /**
<i>1834</i>&nbsp;         * Produces a method handle giving read access to a reflected field.
<i>1835</i>&nbsp;         * The type of the method handle will have a return type of the field&#39;s
<i>1836</i>&nbsp;         * value type.
<i>1837</i>&nbsp;         * If the field is static, the method handle will take no arguments.
<i>1838</i>&nbsp;         * Otherwise, its single argument will be the instance containing
<i>1839</i>&nbsp;         * the field.
<b class="nc"><i>1840</i>&nbsp;         * If the field&#39;s {@code accessible} flag is not set,</b>
<i>1841</i>&nbsp;         * access checking is performed immediately on behalf of the lookup class.
<i>1842</i>&nbsp;         * &lt;p&gt;
<i>1843</i>&nbsp;         * If the field is static, and
<i>1844</i>&nbsp;         * if the returned method handle is invoked, the field&#39;s class will
<i>1845</i>&nbsp;         * be initialized, if it has not already been initialized.
<i>1846</i>&nbsp;         * @param f the reflected field
<i>1847</i>&nbsp;         * @return a method handle which can load values from the reflected field
<i>1848</i>&nbsp;         * @throws IllegalAccessException if access checking fails
<i>1849</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>1850</i>&nbsp;         */
<i>1851</i>&nbsp;        public MethodHandle unreflectGetter(Field f) throws IllegalAccessException {
<i>1852</i>&nbsp;            return unreflectField(f, false);
<i>1853</i>&nbsp;        }
<i>1854</i>&nbsp;        private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
<i>1855</i>&nbsp;            MemberName field = new MemberName(f, isSetter);
<i>1856</i>&nbsp;            assert(isSetter
<i>1857</i>&nbsp;                    ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
<i>1858</i>&nbsp;                    : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
<i>1859</i>&nbsp;            @SuppressWarnings(&quot;deprecation&quot;)
<i>1860</i>&nbsp;            Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
<i>1861</i>&nbsp;            return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);
<i>1862</i>&nbsp;        }
<i>1863</i>&nbsp;
<i>1864</i>&nbsp;        /**
<i>1865</i>&nbsp;         * Produces a method handle giving write access to a reflected field.
<i>1866</i>&nbsp;         * The type of the method handle will have a void return type.
<i>1867</i>&nbsp;         * If the field is static, the method handle will take a single
<i>1868</i>&nbsp;         * argument, of the field&#39;s value type, the value to be stored.
<i>1869</i>&nbsp;         * Otherwise, the two arguments will be the instance containing
<i>1870</i>&nbsp;         * the field, and the value to be stored.
<i>1871</i>&nbsp;         * If the field&#39;s {@code accessible} flag is not set,
<i>1872</i>&nbsp;         * access checking is performed immediately on behalf of the lookup class.
<i>1873</i>&nbsp;         * &lt;p&gt;
<i>1874</i>&nbsp;         * If the field is static, and
<i>1875</i>&nbsp;         * if the returned method handle is invoked, the field&#39;s class will
<i>1876</i>&nbsp;         * be initialized, if it has not already been initialized.
<i>1877</i>&nbsp;         * @param f the reflected field
<i>1878</i>&nbsp;         * @return a method handle which can store values into the reflected field
<i>1879</i>&nbsp;         * @throws IllegalAccessException if access checking fails
<i>1880</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>1881</i>&nbsp;         */
<i>1882</i>&nbsp;        public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
<i>1883</i>&nbsp;            return unreflectField(f, true);
<i>1884</i>&nbsp;        }
<i>1885</i>&nbsp;
<i>1886</i>&nbsp;        /**
<i>1887</i>&nbsp;         * Produces a VarHandle giving access to a reflected field {@code f}
<i>1888</i>&nbsp;         * of type {@code T} declared in a class of type {@code R}.
<i>1889</i>&nbsp;         * The VarHandle&#39;s variable type is {@code T}.
<i>1890</i>&nbsp;         * If the field is non-static the VarHandle has one coordinate type,
<i>1891</i>&nbsp;         * {@code R}.  Otherwise, the field is static, and the VarHandle has no
<i>1892</i>&nbsp;         * coordinate types.
<b class="nc"><i>1893</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>1894</i>&nbsp;         * Access checking is performed immediately on behalf of the lookup</b>
<b class="nc"><i>1895</i>&nbsp;         * class, regardless of the value of the field&#39;s {@code accessible}</b>
<b class="nc"><i>1896</i>&nbsp;         * flag.</b>
<i>1897</i>&nbsp;         * &lt;p&gt;
<i>1898</i>&nbsp;         * If the field is static, and if the returned VarHandle is operated
<i>1899</i>&nbsp;         * on, the field&#39;s declaring class will be initialized, if it has not
<i>1900</i>&nbsp;         * already been initialized.
<i>1901</i>&nbsp;         * &lt;p&gt;
<i>1902</i>&nbsp;         * Certain access modes of the returned VarHandle are unsupported under
<i>1903</i>&nbsp;         * the following conditions:
<i>1904</i>&nbsp;         * &lt;ul&gt;
<i>1905</i>&nbsp;         * &lt;li&gt;if the field is declared {@code final}, then the write, atomic
<i>1906</i>&nbsp;         *     update, numeric atomic update, and bitwise atomic update access
<i>1907</i>&nbsp;         *     modes are unsupported.
<i>1908</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code byte},
<i>1909</i>&nbsp;         *     {@code short}, {@code char}, {@code int}, {@code long},
<i>1910</i>&nbsp;         *     {@code float}, or {@code double} then numeric atomic update
<i>1911</i>&nbsp;         *     access modes are unsupported.
<i>1912</i>&nbsp;         * &lt;li&gt;if the field type is anything other than {@code boolean},
<i>1913</i>&nbsp;         *     {@code byte}, {@code short}, {@code char}, {@code int} or
<i>1914</i>&nbsp;         *     {@code long} then bitwise atomic update access modes are
<i>1915</i>&nbsp;         *     unsupported.
<i>1916</i>&nbsp;         * &lt;/ul&gt;
<i>1917</i>&nbsp;         * &lt;p&gt;
<i>1918</i>&nbsp;         * If the field is declared {@code volatile} then the returned VarHandle
<i>1919</i>&nbsp;         * will override access to the field (effectively ignore the
<i>1920</i>&nbsp;         * {@code volatile} declaration) in accordance to its specified
<i>1921</i>&nbsp;         * access modes.
<i>1922</i>&nbsp;         * &lt;p&gt;
<i>1923</i>&nbsp;         * If the field type is {@code float} or {@code double} then numeric
<i>1924</i>&nbsp;         * and atomic update access modes compare values using their bitwise
<i>1925</i>&nbsp;         * representation (see {@link Float#floatToRawIntBits} and
<i>1926</i>&nbsp;         * {@link Double#doubleToRawLongBits}, respectively).
<i>1927</i>&nbsp;         * @apiNote
<i>1928</i>&nbsp;         * Bitwise comparison of {@code float} values or {@code double} values,
<i>1929</i>&nbsp;         * as performed by the numeric and atomic update access modes, differ
<i>1930</i>&nbsp;         * from the primitive {@code ==} operator and the {@link Float#equals}
<i>1931</i>&nbsp;         * and {@link Double#equals} methods, specifically with respect to
<i>1932</i>&nbsp;         * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
<i>1933</i>&nbsp;         * Care should be taken when performing a compare and set or a compare
<i>1934</i>&nbsp;         * and exchange operation with such values since the operation may
<i>1935</i>&nbsp;         * unexpectedly fail.
<b class="nc"><i>1936</i>&nbsp;         * There are many possible NaN values that are considered to be</b>
<i>1937</i>&nbsp;         * {@code NaN} in Java, although no IEEE 754 floating-point operation
<i>1938</i>&nbsp;         * provided by Java can distinguish between them.  Operation failure can
<i>1939</i>&nbsp;         * occur if the expected or witness value is a NaN value and it is
<i>1940</i>&nbsp;         * transformed (perhaps in a platform specific manner) into another NaN
<i>1941</i>&nbsp;         * value, and thus has a different bitwise representation (see
<i>1942</i>&nbsp;         * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
<i>1943</i>&nbsp;         * details).
<i>1944</i>&nbsp;         * The values {@code -0.0} and {@code +0.0} have different bitwise
<i>1945</i>&nbsp;         * representations but are considered equal when using the primitive
<i>1946</i>&nbsp;         * {@code ==} operator.  Operation failure can occur if, for example, a
<i>1947</i>&nbsp;         * numeric algorithm computes an expected value to be say {@code -0.0}
<i>1948</i>&nbsp;         * and previously computed the witness value to be say {@code +0.0}.
<i>1949</i>&nbsp;         * @param f the reflected field, with a field of type {@code T}, and
<i>1950</i>&nbsp;         * a declaring class of type {@code R}
<i>1951</i>&nbsp;         * @return a VarHandle giving access to non-static fields or a static
<i>1952</i>&nbsp;         * field
<i>1953</i>&nbsp;         * @throws IllegalAccessException if access checking fails
<i>1954</i>&nbsp;         * @throws NullPointerException if the argument is null
<i>1955</i>&nbsp;         * @since 9
<i>1956</i>&nbsp;         */
<i>1957</i>&nbsp;        public VarHandle unreflectVarHandle(Field f) throws IllegalAccessException {
<i>1958</i>&nbsp;            MemberName getField = new MemberName(f, false);
<i>1959</i>&nbsp;            MemberName putField = new MemberName(f, true);
<i>1960</i>&nbsp;            return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),
<i>1961</i>&nbsp;                                                      f.getDeclaringClass(), getField, putField);
<i>1962</i>&nbsp;        }
<i>1963</i>&nbsp;
<i>1964</i>&nbsp;        /**
<i>1965</i>&nbsp;         * Cracks a &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;
<i>1966</i>&nbsp;         * created by this lookup object or a similar one.
<i>1967</i>&nbsp;         * Security and access checks are performed to ensure that this lookup object
<i>1968</i>&nbsp;         * is capable of reproducing the target method handle.
<i>1969</i>&nbsp;         * This means that the cracking may fail if target is a direct method handle
<i>1970</i>&nbsp;         * but was created by an unrelated lookup object.
<i>1971</i>&nbsp;         * This can happen if the method handle is &lt;a href=&quot;MethodHandles.Lookup.html#callsens&quot;&gt;caller sensitive&lt;/a&gt;
<i>1972</i>&nbsp;         * and was created by a lookup object for a different class.
<i>1973</i>&nbsp;         * @param target a direct method handle to crack into symbolic reference components
<i>1974</i>&nbsp;         * @return a symbolic reference which can be used to reconstruct this method handle from this lookup object
<b class="nc"><i>1975</i>&nbsp;         * @exception SecurityException if a security manager is present and it</b>
<i>1976</i>&nbsp;         *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
<i>1977</i>&nbsp;         * @throws IllegalArgumentException if the target is not a direct method handle or if access checking fails
<i>1978</i>&nbsp;         * @exception NullPointerException if the target is {@code null}
<i>1979</i>&nbsp;         * @see MethodHandleInfo
<b class="nc"><i>1980</i>&nbsp;         * @since 1.8</b>
<i>1981</i>&nbsp;         */
<i>1982</i>&nbsp;        public MethodHandleInfo revealDirect(MethodHandle target) {
<i>1983</i>&nbsp;            MemberName member = target.internalMemberName();
<i>1984</i>&nbsp;            if (member == null || (!member.isResolved() &amp;&amp;
<i>1985</i>&nbsp;                                   !member.isMethodHandleInvoke() &amp;&amp;
<i>1986</i>&nbsp;                                   !member.isVarHandleMethodInvoke()))
<i>1987</i>&nbsp;                throw newIllegalArgumentException(&quot;not a direct method handle&quot;);
<i>1988</i>&nbsp;            Class&lt;?&gt; defc = member.getDeclaringClass();
<i>1989</i>&nbsp;            byte refKind = member.getReferenceKind();
<i>1990</i>&nbsp;            assert(MethodHandleNatives.refKindIsValid(refKind));
<i>1991</i>&nbsp;            if (refKind == REF_invokeSpecial &amp;&amp; !target.isInvokeSpecial())
<i>1992</i>&nbsp;                // Devirtualized method invocation is usually formally virtual.
<i>1993</i>&nbsp;                // To avoid creating extra MemberName objects for this common case,
<i>1994</i>&nbsp;                // we encode this extra degree of freedom using MH.isInvokeSpecial.
<i>1995</i>&nbsp;                refKind = REF_invokeVirtual;
<i>1996</i>&nbsp;            if (refKind == REF_invokeVirtual &amp;&amp; defc.isInterface())
<i>1997</i>&nbsp;                // Symbolic reference is through interface but resolves to Object method (toString, etc.)
<i>1998</i>&nbsp;                refKind = REF_invokeInterface;
<i>1999</i>&nbsp;            // Check SM permissions and member access before cracking.
<i>2000</i>&nbsp;            try {
<i>2001</i>&nbsp;                checkAccess(refKind, defc, member);
<i>2002</i>&nbsp;                checkSecurityManager(defc, member);
<i>2003</i>&nbsp;            } catch (IllegalAccessException ex) {
<i>2004</i>&nbsp;                throw new IllegalArgumentException(ex);
<i>2005</i>&nbsp;            }
<i>2006</i>&nbsp;            if (allowedModes != TRUSTED &amp;&amp; member.isCallerSensitive()) {
<i>2007</i>&nbsp;                Class&lt;?&gt; callerClass = target.internalCallerClass();
<i>2008</i>&nbsp;                if (!hasPrivateAccess() || callerClass != lookupClass())
<i>2009</i>&nbsp;                    throw new IllegalArgumentException(&quot;method handle is caller sensitive: &quot;+callerClass);
<i>2010</i>&nbsp;            }
<i>2011</i>&nbsp;            // Produce the handle to the results.
<i>2012</i>&nbsp;            return new InfoFromMemberName(this, member, refKind);
<i>2013</i>&nbsp;        }
<i>2014</i>&nbsp;
<i>2015</i>&nbsp;        /// Helper methods, all package-private.
<i>2016</i>&nbsp;
<i>2017</i>&nbsp;        MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, Class&lt;?&gt; type) throws NoSuchFieldException, IllegalAccessException {
<i>2018</i>&nbsp;            checkSymbolicClass(refc);  // do this before attempting to resolve
<i>2019</i>&nbsp;            Objects.requireNonNull(name);
<i>2020</i>&nbsp;            Objects.requireNonNull(type);
<i>2021</i>&nbsp;            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
<i>2022</i>&nbsp;                                            NoSuchFieldException.class);
<i>2023</i>&nbsp;        }
<i>2024</i>&nbsp;
<i>2025</i>&nbsp;        MemberName resolveOrFail(byte refKind, Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
<i>2026</i>&nbsp;            checkSymbolicClass(refc);  // do this before attempting to resolve
<i>2027</i>&nbsp;            Objects.requireNonNull(name);
<i>2028</i>&nbsp;            Objects.requireNonNull(type);
<i>2029</i>&nbsp;            checkMethodName(refKind, name);  // NPE check on name
<i>2030</i>&nbsp;            return IMPL_NAMES.resolveOrFail(refKind, new MemberName(refc, name, type, refKind), lookupClassOrNull(),
<b class="nc"><i>2031</i>&nbsp;                                            NoSuchMethodException.class);</b>
<i>2032</i>&nbsp;        }
<b class="nc"><i>2033</i>&nbsp;</b>
<b class="nc"><i>2034</i>&nbsp;        MemberName resolveOrFail(byte refKind, MemberName member) throws ReflectiveOperationException {</b>
<b class="nc"><i>2035</i>&nbsp;            checkSymbolicClass(member.getDeclaringClass());  // do this before attempting to resolve</b>
<b class="nc"><i>2036</i>&nbsp;            Objects.requireNonNull(member.getName());</b>
<i>2037</i>&nbsp;            Objects.requireNonNull(member.getType());
<b class="nc"><i>2038</i>&nbsp;            return IMPL_NAMES.resolveOrFail(refKind, member, lookupClassOrNull(),</b>
<i>2039</i>&nbsp;                                            ReflectiveOperationException.class);
<i>2040</i>&nbsp;        }
<i>2041</i>&nbsp;
<b class="nc"><i>2042</i>&nbsp;        MemberName resolveOrNull(byte refKind, MemberName member) {</b>
<b class="nc"><i>2043</i>&nbsp;            // do this before attempting to resolve</b>
<i>2044</i>&nbsp;            if (!isClassAccessible(member.getDeclaringClass())) {
<i>2045</i>&nbsp;                return null;
<i>2046</i>&nbsp;            }
<i>2047</i>&nbsp;            Objects.requireNonNull(member.getName());
<i>2048</i>&nbsp;            Objects.requireNonNull(member.getType());
<i>2049</i>&nbsp;            return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
<i>2050</i>&nbsp;        }
<i>2051</i>&nbsp;
<i>2052</i>&nbsp;        void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
<i>2053</i>&nbsp;            if (!isClassAccessible(refc)) {
<i>2054</i>&nbsp;                throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
<i>2055</i>&nbsp;            }
<i>2056</i>&nbsp;        }
<i>2057</i>&nbsp;
<i>2058</i>&nbsp;        boolean isClassAccessible(Class&lt;?&gt; refc) {
<i>2059</i>&nbsp;            Objects.requireNonNull(refc);
<i>2060</i>&nbsp;            Class&lt;?&gt; caller = lookupClassOrNull();
<i>2061</i>&nbsp;            return caller == null || VerifyAccess.isClassAccessible(refc, caller, allowedModes);
<i>2062</i>&nbsp;        }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;        /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
<i>2065</i>&nbsp;        void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<i>2066</i>&nbsp;            if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)
<i>2067</i>&nbsp;                throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);
<i>2068</i>&nbsp;        }
<i>2069</i>&nbsp;
<i>2070</i>&nbsp;
<i>2071</i>&nbsp;        /**
<i>2072</i>&nbsp;         * Find my trustable caller class if m is a caller sensitive method.
<i>2073</i>&nbsp;         * If this lookup object has private access, then the caller class is the lookupClass.
<i>2074</i>&nbsp;         * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
<i>2075</i>&nbsp;         */
<i>2076</i>&nbsp;        Class&lt;?&gt; findBoundCallerClass(MemberName m) throws IllegalAccessException {
<i>2077</i>&nbsp;            Class&lt;?&gt; callerClass = null;
<i>2078</i>&nbsp;            if (MethodHandleNatives.isCallerSensitive(m)) {
<i>2079</i>&nbsp;                // Only lookups with private access are allowed to resolve caller-sensitive methods
<i>2080</i>&nbsp;                if (hasPrivateAccess()) {
<i>2081</i>&nbsp;                    callerClass = lookupClass;
<i>2082</i>&nbsp;                } else {
<i>2083</i>&nbsp;                    throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
<i>2084</i>&nbsp;                }
<i>2085</i>&nbsp;            }
<i>2086</i>&nbsp;            return callerClass;
<i>2087</i>&nbsp;        }
<i>2088</i>&nbsp;
<i>2089</i>&nbsp;        /**
<i>2090</i>&nbsp;         * Returns {@code true} if this lookup has {@code PRIVATE} access.
<i>2091</i>&nbsp;         * @return {@code true} if this lookup has {@code PRIVATE} access.
<i>2092</i>&nbsp;         * @since 9
<i>2093</i>&nbsp;         */
<i>2094</i>&nbsp;        public boolean hasPrivateAccess() {
<i>2095</i>&nbsp;            return (allowedModes &amp; PRIVATE) != 0;
<i>2096</i>&nbsp;        }
<i>2097</i>&nbsp;
<i>2098</i>&nbsp;        /**
<i>2099</i>&nbsp;         * Perform necessary &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;access checks&lt;/a&gt;.
<i>2100</i>&nbsp;         * Determines a trustable caller class to compare with refc, the symbolic reference class.
<i>2101</i>&nbsp;         * If this lookup object has private access, then the caller class is the lookupClass.
<i>2102</i>&nbsp;         */
<i>2103</i>&nbsp;        void checkSecurityManager(Class&lt;?&gt; refc, MemberName m) {
<i>2104</i>&nbsp;            SecurityManager smgr = System.getSecurityManager();
<i>2105</i>&nbsp;            if (smgr == null)  return;
<i>2106</i>&nbsp;            if (allowedModes == TRUSTED)  return;
<i>2107</i>&nbsp;
<b class="nc"><i>2108</i>&nbsp;            // Step 1:</b>
<b class="nc"><i>2109</i>&nbsp;            boolean fullPowerLookup = hasPrivateAccess();</b>
<b class="nc"><i>2110</i>&nbsp;            if (!fullPowerLookup ||</b>
<i>2111</i>&nbsp;                !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {
<b class="nc"><i>2112</i>&nbsp;                ReflectUtil.checkPackageAccess(refc);</b>
<b class="nc"><i>2113</i>&nbsp;            }</b>
<b class="nc"><i>2114</i>&nbsp;</b>
<b class="nc"><i>2115</i>&nbsp;            if (m == null) {  // findClass or accessClass</b>
<i>2116</i>&nbsp;                // Step 2b:
<i>2117</i>&nbsp;                if (!fullPowerLookup) {
<i>2118</i>&nbsp;                    smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
<i>2119</i>&nbsp;                }
<b class="nc"><i>2120</i>&nbsp;                return;</b>
<b class="nc"><i>2121</i>&nbsp;            }</b>
<i>2122</i>&nbsp;
<i>2123</i>&nbsp;            // Step 2a:
<i>2124</i>&nbsp;            if (m.isPublic()) return;
<i>2125</i>&nbsp;            if (!fullPowerLookup) {
<i>2126</i>&nbsp;                smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
<i>2127</i>&nbsp;            }
<b class="nc"><i>2128</i>&nbsp;</b>
<b class="nc"><i>2129</i>&nbsp;            // Step 3:</b>
<b class="nc"><i>2130</i>&nbsp;            Class&lt;?&gt; defc = m.getDeclaringClass();</b>
<i>2131</i>&nbsp;            if (!fullPowerLookup &amp;&amp; defc != refc) {
<i>2132</i>&nbsp;                ReflectUtil.checkPackageAccess(defc);
<b class="nc"><i>2133</i>&nbsp;            }</b>
<i>2134</i>&nbsp;        }
<b class="nc"><i>2135</i>&nbsp;</b>
<b class="nc"><i>2136</i>&nbsp;        void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {</b>
<b class="nc"><i>2137</i>&nbsp;            boolean wantStatic = (refKind == REF_invokeStatic);</b>
<i>2138</i>&nbsp;            String message;
<b class="nc"><i>2139</i>&nbsp;            if (m.isConstructor())</b>
<b class="nc"><i>2140</i>&nbsp;                message = &quot;expected a method, not a constructor&quot;;</b>
<b class="nc"><i>2141</i>&nbsp;            else if (!m.isMethod())</b>
<i>2142</i>&nbsp;                message = &quot;expected a method&quot;;
<b class="nc"><i>2143</i>&nbsp;            else if (wantStatic != m.isStatic())</b>
<b class="nc"><i>2144</i>&nbsp;                message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;</b>
<b class="nc"><i>2145</i>&nbsp;            else</b>
<b class="nc"><i>2146</i>&nbsp;                { checkAccess(refKind, refc, m); return; }</b>
<b class="nc"><i>2147</i>&nbsp;            throw m.makeAccessException(message, this);</b>
<b class="nc"><i>2148</i>&nbsp;        }</b>
<i>2149</i>&nbsp;
<i>2150</i>&nbsp;        void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
<b class="nc"><i>2151</i>&nbsp;            boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);</b>
<i>2152</i>&nbsp;            String message;
<b class="nc"><i>2153</i>&nbsp;            if (wantStatic != m.isStatic())</b>
<b class="nc"><i>2154</i>&nbsp;                message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;</b>
<b class="nc"><i>2155</i>&nbsp;            else</b>
<i>2156</i>&nbsp;                { checkAccess(refKind, refc, m); return; }
<b class="nc"><i>2157</i>&nbsp;            throw m.makeAccessException(message, this);</b>
<b class="nc"><i>2158</i>&nbsp;        }</b>
<b class="nc"><i>2159</i>&nbsp;</b>
<b class="nc"><i>2160</i>&nbsp;        /** Check public/protected/private bits on the symbolic reference class and its member. */</b>
<i>2161</i>&nbsp;        void checkAccess(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
<b class="nc"><i>2162</i>&nbsp;            assert(m.referenceKindIsConsistentWith(refKind) &amp;&amp;</b>
<i>2163</i>&nbsp;                   MethodHandleNatives.refKindIsValid(refKind) &amp;&amp;
<b class="nc"><i>2164</i>&nbsp;                   (MethodHandleNatives.refKindIsField(refKind) == m.isField()));</b>
<i>2165</i>&nbsp;            int allowedModes = this.allowedModes;
<b class="nc"><i>2166</i>&nbsp;            if (allowedModes == TRUSTED)  return;</b>
<b class="nc"><i>2167</i>&nbsp;            int mods = m.getModifiers();</b>
<b class="nc"><i>2168</i>&nbsp;            if (Modifier.isProtected(mods) &amp;&amp;</b>
<b class="nc"><i>2169</i>&nbsp;                    refKind == REF_invokeVirtual &amp;&amp;</b>
<i>2170</i>&nbsp;                    m.getDeclaringClass() == Object.class &amp;&amp;
<i>2171</i>&nbsp;                    m.getName().equals(&quot;clone&quot;) &amp;&amp;
<i>2172</i>&nbsp;                    refc.isArray()) {
<i>2173</i>&nbsp;                // The JVM does this hack also.
<i>2174</i>&nbsp;                // (See ClassVerifier::verify_invoke_instructions
<i>2175</i>&nbsp;                // and LinkResolver::check_method_accessability.)
<i>2176</i>&nbsp;                // Because the JVM does not allow separate methods on array types,
<i>2177</i>&nbsp;                // there is no separate method for int[].clone.
<i>2178</i>&nbsp;                // All arrays simply inherit Object.clone.
<i>2179</i>&nbsp;                // But for access checking logic, we make Object.clone
<i>2180</i>&nbsp;                // (normally protected) appear to be public.
<b class="nc"><i>2181</i>&nbsp;                // Later on, when the DirectMethodHandle is created,</b>
<b class="nc"><i>2182</i>&nbsp;                // its leading argument will be restricted to the</b>
<b class="nc"><i>2183</i>&nbsp;                // requested array type.</b>
<b class="nc"><i>2184</i>&nbsp;                // N.B. The return type is not adjusted, because</b>
<b class="nc"><i>2185</i>&nbsp;                // that is *not* the bytecode behavior.</b>
<b class="nc"><i>2186</i>&nbsp;                mods ^= Modifier.PROTECTED | Modifier.PUBLIC;</b>
<i>2187</i>&nbsp;            }
<b class="nc"><i>2188</i>&nbsp;            if (Modifier.isProtected(mods) &amp;&amp; refKind == REF_newInvokeSpecial) {</b>
<b class="nc"><i>2189</i>&nbsp;                // cannot &quot;new&quot; a protected ctor in a different package</b>
<b class="nc"><i>2190</i>&nbsp;                mods ^= Modifier.PROTECTED;</b>
<i>2191</i>&nbsp;            }
<b class="nc"><i>2192</i>&nbsp;            if (Modifier.isFinal(mods) &amp;&amp;</b>
<i>2193</i>&nbsp;                    MethodHandleNatives.refKindIsSetter(refKind))
<b class="nc"><i>2194</i>&nbsp;                throw m.makeAccessException(&quot;unexpected set of a final field&quot;, this);</b>
<b class="nc"><i>2195</i>&nbsp;            int requestedModes = fixmods(mods);  // adjust 0 =&gt; PACKAGE</b>
<b class="nc"><i>2196</i>&nbsp;            if ((requestedModes &amp; allowedModes) != 0) {</b>
<i>2197</i>&nbsp;                if (VerifyAccess.isMemberAccessible(refc, m.getDeclaringClass(),
<i>2198</i>&nbsp;                                                    mods, lookupClass(), allowedModes))
<b class="nc"><i>2199</i>&nbsp;                    return;</b>
<b class="nc"><i>2200</i>&nbsp;            } else {</b>
<b class="nc"><i>2201</i>&nbsp;                // Protected members can also be checked as if they were package-private.</b>
<b class="nc"><i>2202</i>&nbsp;                if ((requestedModes &amp; PROTECTED) != 0 &amp;&amp; (allowedModes &amp; PACKAGE) != 0</b>
<b class="nc"><i>2203</i>&nbsp;                        &amp;&amp; VerifyAccess.isSamePackage(m.getDeclaringClass(), lookupClass()))</b>
<i>2204</i>&nbsp;                    return;
<b class="nc"><i>2205</i>&nbsp;            }</b>
<i>2206</i>&nbsp;            throw m.makeAccessException(accessFailedMessage(refc, m), this);
<i>2207</i>&nbsp;        }
<b class="nc"><i>2208</i>&nbsp;</b>
<b class="nc"><i>2209</i>&nbsp;        String accessFailedMessage(Class&lt;?&gt; refc, MemberName m) {</b>
<b class="nc"><i>2210</i>&nbsp;            Class&lt;?&gt; defc = m.getDeclaringClass();</b>
<b class="nc"><i>2211</i>&nbsp;            int mods = m.getModifiers();</b>
<b class="nc"><i>2212</i>&nbsp;            // check the class first:</b>
<i>2213</i>&nbsp;            boolean classOK = (Modifier.isPublic(defc.getModifiers()) &amp;&amp;
<b class="nc"><i>2214</i>&nbsp;                               (defc == refc ||</b>
<b class="nc"><i>2215</i>&nbsp;                                Modifier.isPublic(refc.getModifiers())));</b>
<i>2216</i>&nbsp;            if (!classOK &amp;&amp; (allowedModes &amp; PACKAGE) != 0) {
<b class="nc"><i>2217</i>&nbsp;                classOK = (VerifyAccess.isClassAccessible(defc, lookupClass(), FULL_POWER_MODES) &amp;&amp;</b>
<i>2218</i>&nbsp;                           (defc == refc ||
<b class="nc"><i>2219</i>&nbsp;                            VerifyAccess.isClassAccessible(refc, lookupClass(), FULL_POWER_MODES)));</b>
<b class="nc"><i>2220</i>&nbsp;            }</b>
<b class="nc"><i>2221</i>&nbsp;            if (!classOK)</b>
<b class="nc"><i>2222</i>&nbsp;                return &quot;class is not public&quot;;</b>
<i>2223</i>&nbsp;            if (Modifier.isPublic(mods))
<b class="nc"><i>2224</i>&nbsp;                return &quot;access to public member failed&quot;;  // (how?, module not readable?)</b>
<i>2225</i>&nbsp;            if (Modifier.isPrivate(mods))
<i>2226</i>&nbsp;                return &quot;member is private&quot;;
<i>2227</i>&nbsp;            if (Modifier.isProtected(mods))
<i>2228</i>&nbsp;                return &quot;member is protected&quot;;
<b class="nc"><i>2229</i>&nbsp;            return &quot;member is private to package&quot;;</b>
<b class="nc"><i>2230</i>&nbsp;        }</b>
<i>2231</i>&nbsp;
<b class="nc"><i>2232</i>&nbsp;        private void checkSpecialCaller(Class&lt;?&gt; specialCaller, Class&lt;?&gt; refc) throws IllegalAccessException {</b>
<b class="nc"><i>2233</i>&nbsp;            int allowedModes = this.allowedModes;</b>
<b class="nc"><i>2234</i>&nbsp;            if (allowedModes == TRUSTED)  return;</b>
<b class="nc"><i>2235</i>&nbsp;            if (!hasPrivateAccess()</b>
<b class="nc"><i>2236</i>&nbsp;                || (specialCaller != lookupClass()</b>
<b class="nc"><i>2237</i>&nbsp;                       // ensure non-abstract methods in superinterfaces can be special-invoked</b>
<b class="nc"><i>2238</i>&nbsp;                    &amp;&amp; !(refc != null &amp;&amp; refc.isInterface() &amp;&amp; refc.isAssignableFrom(specialCaller))))</b>
<i>2239</i>&nbsp;                throw new MemberName(specialCaller).
<b class="nc"><i>2240</i>&nbsp;                    makeAccessException(&quot;no private access for invokespecial&quot;, this);</b>
<b class="nc"><i>2241</i>&nbsp;        }</b>
<b class="nc"><i>2242</i>&nbsp;</b>
<b class="nc"><i>2243</i>&nbsp;        private boolean restrictProtectedReceiver(MemberName method) {</b>
<i>2244</i>&nbsp;            // The accessing class only has the right to use a protected member
<i>2245</i>&nbsp;            // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
<b class="nc"><i>2246</i>&nbsp;            if (!method.isProtected() || method.isStatic()</b>
<i>2247</i>&nbsp;                || allowedModes == TRUSTED
<b class="nc"><i>2248</i>&nbsp;                || method.getDeclaringClass() == lookupClass()</b>
<i>2249</i>&nbsp;                || VerifyAccess.isSamePackage(method.getDeclaringClass(), lookupClass()))
<i>2250</i>&nbsp;                return false;
<i>2251</i>&nbsp;            return true;
<i>2252</i>&nbsp;        }
<i>2253</i>&nbsp;        private MethodHandle restrictReceiver(MemberName method, DirectMethodHandle mh, Class&lt;?&gt; caller) throws IllegalAccessException {
<i>2254</i>&nbsp;            assert(!method.isStatic());
<i>2255</i>&nbsp;            // receiver type of mh is too wide; narrow to caller
<i>2256</i>&nbsp;            if (!method.getDeclaringClass().isAssignableFrom(caller)) {
<i>2257</i>&nbsp;                throw method.makeAccessException(&quot;caller class must be a subclass below the method&quot;, caller);
<i>2258</i>&nbsp;            }
<i>2259</i>&nbsp;            MethodType rawType = mh.type();
<i>2260</i>&nbsp;            if (caller.isAssignableFrom(rawType.parameterType(0))) return mh; // no need to restrict; already narrow
<i>2261</i>&nbsp;            MethodType narrowType = rawType.changeParameterType(0, caller);
<i>2262</i>&nbsp;            assert(!mh.isVarargsCollector());  // viewAsType will lose varargs-ness
<i>2263</i>&nbsp;            assert(mh.viewAsTypeChecks(narrowType, true));
<i>2264</i>&nbsp;            return mh.copyWith(narrowType, mh.form);
<i>2265</i>&nbsp;        }
<i>2266</i>&nbsp;
<i>2267</i>&nbsp;        /** Check access and get the requested method. */
<b class="nc"><i>2268</i>&nbsp;        private MethodHandle getDirectMethod(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</b>
<b class="nc"><i>2269</i>&nbsp;            final boolean doRestrict    = true;</b>
<b class="nc"><i>2270</i>&nbsp;            final boolean checkSecurity = true;</b>
<b class="nc"><i>2271</i>&nbsp;            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);</b>
<b class="nc"><i>2272</i>&nbsp;        }</b>
<b class="nc"><i>2273</i>&nbsp;        /** Check access and get the requested method, for invokespecial with no restriction on the application of narrowing rules. */</b>
<b class="nc"><i>2274</i>&nbsp;        private MethodHandle getDirectMethodNoRestrictInvokeSpecial(Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {</b>
<b class="nc"><i>2275</i>&nbsp;            final boolean doRestrict    = false;</b>
<i>2276</i>&nbsp;            final boolean checkSecurity = true;
<b class="nc"><i>2277</i>&nbsp;            return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, boundCallerClass);</b>
<b class="nc"><i>2278</i>&nbsp;        }</b>
<b class="nc"><i>2279</i>&nbsp;        /** Check access and get the requested method, eliding security manager checks. */</b>
<i>2280</i>&nbsp;        private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName method, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {
<i>2281</i>&nbsp;            final boolean doRestrict    = true;
<i>2282</i>&nbsp;            final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<i>2283</i>&nbsp;            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, boundCallerClass);
<i>2284</i>&nbsp;        }
<i>2285</i>&nbsp;        /** Common code for all methods; do not call directly except from immediately above. */
<i>2286</i>&nbsp;        private MethodHandle getDirectMethodCommon(byte refKind, Class&lt;?&gt; refc, MemberName method,
<i>2287</i>&nbsp;                                                   boolean checkSecurity,
<i>2288</i>&nbsp;                                                   boolean doRestrict, Class&lt;?&gt; boundCallerClass) throws IllegalAccessException {
<i>2289</i>&nbsp;
<i>2290</i>&nbsp;            checkMethod(refKind, refc, method);
<i>2291</i>&nbsp;            // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
<b class="nc"><i>2292</i>&nbsp;            if (checkSecurity)</b>
<b class="nc"><i>2293</i>&nbsp;                checkSecurityManager(refc, method);</b>
<b class="nc"><i>2294</i>&nbsp;            assert(!method.isMethodHandleInvoke());</b>
<b class="nc"><i>2295</i>&nbsp;</b>
<b class="nc"><i>2296</i>&nbsp;            if (refKind == REF_invokeSpecial &amp;&amp;</b>
<i>2297</i>&nbsp;                refc != lookupClass() &amp;&amp;
<b class="nc"><i>2298</i>&nbsp;                !refc.isInterface() &amp;&amp;</b>
<b class="nc"><i>2299</i>&nbsp;                refc != lookupClass().getSuperclass() &amp;&amp;</b>
<i>2300</i>&nbsp;                refc.isAssignableFrom(lookupClass())) {
<b class="nc"><i>2301</i>&nbsp;                assert(!method.getName().equals(&quot;&lt;init&gt;&quot;));  // not this code path</b>
<b class="nc"><i>2302</i>&nbsp;</b>
<i>2303</i>&nbsp;                // Per JVMS 6.5, desc. of invokespecial instruction:
<b class="nc"><i>2304</i>&nbsp;                // If the method is in a superclass of the LC,</b>
<i>2305</i>&nbsp;                // and if our original search was above LC.super,
<b class="nc"><i>2306</i>&nbsp;                // repeat the search (symbolic lookup) from LC.super</b>
<b class="nc"><i>2307</i>&nbsp;                // and continue with the direct superclass of that class,</b>
<b class="nc"><i>2308</i>&nbsp;                // and so forth, until a match is found or no further superclasses exist.</b>
<i>2309</i>&nbsp;                // FIXME: MemberName.resolve should handle this instead.
<i>2310</i>&nbsp;                Class&lt;?&gt; refcAsSuper = lookupClass();
<i>2311</i>&nbsp;                MemberName m2;
<b class="nc"><i>2312</i>&nbsp;                do {</b>
<b class="nc"><i>2313</i>&nbsp;                    refcAsSuper = refcAsSuper.getSuperclass();</b>
<b class="nc"><i>2314</i>&nbsp;                    m2 = new MemberName(refcAsSuper,</b>
<b class="nc"><i>2315</i>&nbsp;                                        method.getName(),</b>
<i>2316</i>&nbsp;                                        method.getMethodType(),
<b class="nc"><i>2317</i>&nbsp;                                        REF_invokeSpecial);</b>
<b class="nc"><i>2318</i>&nbsp;                    m2 = IMPL_NAMES.resolveOrNull(refKind, m2, lookupClassOrNull());</b>
<b class="nc"><i>2319</i>&nbsp;                } while (m2 == null &amp;&amp;         // no method is found yet</b>
<b class="nc"><i>2320</i>&nbsp;                         refc != refcAsSuper); // search up to refc</b>
<i>2321</i>&nbsp;                if (m2 == null)  throw new InternalError(method.toString());
<b class="nc"><i>2322</i>&nbsp;                method = m2;</b>
<i>2323</i>&nbsp;                refc = refcAsSuper;
<b class="nc"><i>2324</i>&nbsp;                // redo basic checks</b>
<b class="nc"><i>2325</i>&nbsp;                checkMethod(refKind, refc, method);</b>
<b class="nc"><i>2326</i>&nbsp;            }</b>
<i>2327</i>&nbsp;
<i>2328</i>&nbsp;            DirectMethodHandle dmh = DirectMethodHandle.make(refKind, refc, method, lookupClass());
<i>2329</i>&nbsp;            MethodHandle mh = dmh;
<i>2330</i>&nbsp;            // Optionally narrow the receiver argument to lookupClass using restrictReceiver.
<b class="nc"><i>2331</i>&nbsp;            if ((doRestrict &amp;&amp; refKind == REF_invokeSpecial) ||</b>
<b class="nc"><i>2332</i>&nbsp;                    (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp; restrictProtectedReceiver(method))) {</b>
<b class="nc"><i>2333</i>&nbsp;                mh = restrictReceiver(method, dmh, lookupClass());</b>
<i>2334</i>&nbsp;            }
<i>2335</i>&nbsp;            mh = maybeBindCaller(method, mh, boundCallerClass);
<i>2336</i>&nbsp;            mh = mh.setVarargs(method);
<i>2337</i>&nbsp;            return mh;
<i>2338</i>&nbsp;        }
<i>2339</i>&nbsp;        private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh,
<i>2340</i>&nbsp;                                             Class&lt;?&gt; boundCallerClass)
<i>2341</i>&nbsp;                                             throws IllegalAccessException {
<i>2342</i>&nbsp;            if (allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))
<i>2343</i>&nbsp;                return mh;
<i>2344</i>&nbsp;            Class&lt;?&gt; hostClass = lookupClass;
<i>2345</i>&nbsp;            if (!hasPrivateAccess())  // caller must have private access
<i>2346</i>&nbsp;                hostClass = boundCallerClass;  // boundCallerClass came from a security manager style stack walk
<i>2347</i>&nbsp;            MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, hostClass);
<i>2348</i>&nbsp;            // Note: caller will apply varargs after this step happens.
<i>2349</i>&nbsp;            return cbmh;
<i>2350</i>&nbsp;        }
<i>2351</i>&nbsp;        /** Check access and get the requested field. */
<i>2352</i>&nbsp;        private MethodHandle getDirectField(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
<i>2353</i>&nbsp;            final boolean checkSecurity = true;
<i>2354</i>&nbsp;            return getDirectFieldCommon(refKind, refc, field, checkSecurity);
<i>2355</i>&nbsp;        }
<i>2356</i>&nbsp;        /** Check access and get the requested field, eliding security manager checks. */
<i>2357</i>&nbsp;        private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class&lt;?&gt; refc, MemberName field) throws IllegalAccessException {
<i>2358</i>&nbsp;            final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<i>2359</i>&nbsp;            return getDirectFieldCommon(refKind, refc, field, checkSecurity);
<i>2360</i>&nbsp;        }
<i>2361</i>&nbsp;        /** Common code for all fields; do not call directly except from immediately above. */
<i>2362</i>&nbsp;        private MethodHandle getDirectFieldCommon(byte refKind, Class&lt;?&gt; refc, MemberName field,
<i>2363</i>&nbsp;                                                  boolean checkSecurity) throws IllegalAccessException {
<i>2364</i>&nbsp;            checkField(refKind, refc, field);
<i>2365</i>&nbsp;            // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
<i>2366</i>&nbsp;            if (checkSecurity)
<i>2367</i>&nbsp;                checkSecurityManager(refc, field);
<b class="nc"><i>2368</i>&nbsp;            DirectMethodHandle dmh = DirectMethodHandle.make(refc, field);</b>
<b class="nc"><i>2369</i>&nbsp;            boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(refKind) &amp;&amp;</b>
<b class="nc"><i>2370</i>&nbsp;                                    restrictProtectedReceiver(field));</b>
<b class="nc"><i>2371</i>&nbsp;            if (doRestrict)</b>
<b class="nc"><i>2372</i>&nbsp;                return restrictReceiver(field, dmh, lookupClass());</b>
<b class="nc"><i>2373</i>&nbsp;            return dmh;</b>
<b class="nc"><i>2374</i>&nbsp;        }</b>
<b class="nc"><i>2375</i>&nbsp;        private VarHandle getFieldVarHandle(byte getRefKind, byte putRefKind,</b>
<b class="nc"><i>2376</i>&nbsp;                                            Class&lt;?&gt; refc, MemberName getField, MemberName putField)</b>
<i>2377</i>&nbsp;                throws IllegalAccessException {
<b class="nc"><i>2378</i>&nbsp;            final boolean checkSecurity = true;</b>
<b class="nc"><i>2379</i>&nbsp;            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);</b>
<i>2380</i>&nbsp;        }
<i>2381</i>&nbsp;        private VarHandle getFieldVarHandleNoSecurityManager(byte getRefKind, byte putRefKind,
<b class="nc"><i>2382</i>&nbsp;                                                             Class&lt;?&gt; refc, MemberName getField, MemberName putField)</b>
<i>2383</i>&nbsp;                throws IllegalAccessException {
<i>2384</i>&nbsp;            final boolean checkSecurity = false;
<i>2385</i>&nbsp;            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);
<i>2386</i>&nbsp;        }
<b class="nc"><i>2387</i>&nbsp;        private VarHandle getFieldVarHandleCommon(byte getRefKind, byte putRefKind,</b>
<i>2388</i>&nbsp;                                                  Class&lt;?&gt; refc, MemberName getField, MemberName putField,
<b class="nc"><i>2389</i>&nbsp;                                                  boolean checkSecurity) throws IllegalAccessException {</b>
<b class="nc"><i>2390</i>&nbsp;            assert getField.isStatic() == putField.isStatic();</b>
<b class="nc"><i>2391</i>&nbsp;            assert getField.isGetter() &amp;&amp; putField.isSetter();</b>
<b class="nc"><i>2392</i>&nbsp;            assert MethodHandleNatives.refKindIsStatic(getRefKind) == MethodHandleNatives.refKindIsStatic(putRefKind);</b>
<b class="nc"><i>2393</i>&nbsp;            assert MethodHandleNatives.refKindIsGetter(getRefKind) &amp;&amp; MethodHandleNatives.refKindIsSetter(putRefKind);</b>
<b class="nc"><i>2394</i>&nbsp;</b>
<b class="nc"><i>2395</i>&nbsp;            checkField(getRefKind, refc, getField);</b>
<i>2396</i>&nbsp;            if (checkSecurity)
<i>2397</i>&nbsp;                checkSecurityManager(refc, getField);
<i>2398</i>&nbsp;
<i>2399</i>&nbsp;            if (!putField.isFinal()) {
<b class="nc"><i>2400</i>&nbsp;                // A VarHandle does not support updates to final fields, any</b>
<b class="nc"><i>2401</i>&nbsp;                // such VarHandle to a final field will be read-only and</b>
<b class="nc"><i>2402</i>&nbsp;                // therefore the following write-based accessibility checks are</b>
<b class="nc"><i>2403</i>&nbsp;                // only required for non-final fields</b>
<b class="nc"><i>2404</i>&nbsp;                checkField(putRefKind, refc, putField);</b>
<b class="nc"><i>2405</i>&nbsp;                if (checkSecurity)</b>
<b class="nc"><i>2406</i>&nbsp;                    checkSecurityManager(refc, putField);</b>
<b class="nc"><i>2407</i>&nbsp;            }</b>
<i>2408</i>&nbsp;
<i>2409</i>&nbsp;            boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(getRefKind) &amp;&amp;
<i>2410</i>&nbsp;                                  restrictProtectedReceiver(getField));
<i>2411</i>&nbsp;            if (doRestrict) {
<i>2412</i>&nbsp;                assert !getField.isStatic();
<i>2413</i>&nbsp;                // receiver type of VarHandle is too wide; narrow to caller
<i>2414</i>&nbsp;                if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
<i>2415</i>&nbsp;                    throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
<i>2416</i>&nbsp;                }
<i>2417</i>&nbsp;                refc = lookupClass();
<i>2418</i>&nbsp;            }
<i>2419</i>&nbsp;            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(), this.allowedModes == TRUSTED);
<i>2420</i>&nbsp;        }
<i>2421</i>&nbsp;        /** Check access and get the requested constructor. */
<i>2422</i>&nbsp;        private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
<i>2423</i>&nbsp;            final boolean checkSecurity = true;
<i>2424</i>&nbsp;            return getDirectConstructorCommon(refc, ctor, checkSecurity);
<i>2425</i>&nbsp;        }
<i>2426</i>&nbsp;        /** Check access and get the requested constructor, eliding security manager checks. */
<i>2427</i>&nbsp;        private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
<i>2428</i>&nbsp;            final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
<i>2429</i>&nbsp;            return getDirectConstructorCommon(refc, ctor, checkSecurity);
<i>2430</i>&nbsp;        }
<i>2431</i>&nbsp;        /** Common code for all constructors; do not call directly except from immediately above. */
<i>2432</i>&nbsp;        private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
<i>2433</i>&nbsp;                                                  boolean checkSecurity) throws IllegalAccessException {
<i>2434</i>&nbsp;            assert(ctor.isConstructor());
<i>2435</i>&nbsp;            checkAccess(REF_newInvokeSpecial, refc, ctor);
<i>2436</i>&nbsp;            // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
<i>2437</i>&nbsp;            if (checkSecurity)
<i>2438</i>&nbsp;                checkSecurityManager(refc, ctor);
<i>2439</i>&nbsp;            assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
<i>2440</i>&nbsp;            return DirectMethodHandle.make(ctor).setVarargs(ctor);
<i>2441</i>&nbsp;        }
<i>2442</i>&nbsp;
<i>2443</i>&nbsp;        /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
<i>2444</i>&nbsp;         */
<i>2445</i>&nbsp;        /*non-public*/
<i>2446</i>&nbsp;        MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type) throws ReflectiveOperationException {
<i>2447</i>&nbsp;            if (!(type instanceof Class || type instanceof MethodType))
<i>2448</i>&nbsp;                throw new InternalError(&quot;unresolved MemberName&quot;);
<i>2449</i>&nbsp;            MemberName member = new MemberName(refKind, defc, name, type);
<i>2450</i>&nbsp;            MethodHandle mh = LOOKASIDE_TABLE.get(member);
<i>2451</i>&nbsp;            if (mh != null) {
<i>2452</i>&nbsp;                checkSymbolicClass(defc);
<i>2453</i>&nbsp;                return mh;
<b class="nc"><i>2454</i>&nbsp;            }</b>
<b class="nc"><i>2455</i>&nbsp;            if (defc == MethodHandle.class &amp;&amp; refKind == REF_invokeVirtual) {</b>
<b class="nc"><i>2456</i>&nbsp;                // Treat MethodHandle.invoke and invokeExact specially.</b>
<b class="nc"><i>2457</i>&nbsp;                mh = findVirtualForMH(member.getName(), member.getMethodType());</b>
<b class="nc"><i>2458</i>&nbsp;                if (mh != null) {</b>
<b class="nc"><i>2459</i>&nbsp;                    return mh;</b>
<b class="nc"><i>2460</i>&nbsp;                }</b>
<b class="nc"><i>2461</i>&nbsp;            } else if (defc == VarHandle.class &amp;&amp; refKind == REF_invokeVirtual) {</b>
<b class="nc"><i>2462</i>&nbsp;                // Treat signature-polymorphic methods on VarHandle specially.</b>
<b class="nc"><i>2463</i>&nbsp;                mh = findVirtualForVH(member.getName(), member.getMethodType());</b>
<b class="nc"><i>2464</i>&nbsp;                if (mh != null) {</b>
<b class="nc"><i>2465</i>&nbsp;                    return mh;</b>
<b class="nc"><i>2466</i>&nbsp;                }</b>
<i>2467</i>&nbsp;            }
<i>2468</i>&nbsp;            MemberName resolved = resolveOrFail(refKind, member);
<i>2469</i>&nbsp;            mh = getDirectMethodForConstant(refKind, defc, resolved);
<b class="nc"><i>2470</i>&nbsp;            if (mh instanceof DirectMethodHandle</b>
<b class="nc"><i>2471</i>&nbsp;                    &amp;&amp; canBeCached(refKind, defc, resolved)) {</b>
<i>2472</i>&nbsp;                MemberName key = mh.internalMemberName();
<i>2473</i>&nbsp;                if (key != null) {
<i>2474</i>&nbsp;                    key = key.asNormalOriginal();
<b class="nc"><i>2475</i>&nbsp;                }</b>
<b class="nc"><i>2476</i>&nbsp;                if (member.equals(key)) {  // better safe than sorry</b>
<b class="nc"><i>2477</i>&nbsp;                    LOOKASIDE_TABLE.put(key, (DirectMethodHandle) mh);</b>
<b class="nc"><i>2478</i>&nbsp;                }</b>
<b class="nc"><i>2479</i>&nbsp;            }</b>
<b class="nc"><i>2480</i>&nbsp;            return mh;</b>
<b class="nc"><i>2481</i>&nbsp;        }</b>
<i>2482</i>&nbsp;        private
<b class="nc"><i>2483</i>&nbsp;        boolean canBeCached(byte refKind, Class&lt;?&gt; defc, MemberName member) {</b>
<i>2484</i>&nbsp;            if (refKind == REF_invokeSpecial) {
<i>2485</i>&nbsp;                return false;
<i>2486</i>&nbsp;            }
<i>2487</i>&nbsp;            if (!Modifier.isPublic(defc.getModifiers()) ||
<i>2488</i>&nbsp;                    !Modifier.isPublic(member.getDeclaringClass().getModifiers()) ||
<i>2489</i>&nbsp;                    !member.isPublic() ||
<i>2490</i>&nbsp;                    member.isCallerSensitive()) {
<i>2491</i>&nbsp;                return false;
<i>2492</i>&nbsp;            }
<i>2493</i>&nbsp;            ClassLoader loader = defc.getClassLoader();
<i>2494</i>&nbsp;            if (loader != null) {
<i>2495</i>&nbsp;                ClassLoader sysl = ClassLoader.getSystemClassLoader();
<i>2496</i>&nbsp;                boolean found = false;
<i>2497</i>&nbsp;                while (sysl != null) {
<i>2498</i>&nbsp;                    if (loader == sysl) { found = true; break; }
<i>2499</i>&nbsp;                    sysl = sysl.getParent();
<i>2500</i>&nbsp;                }
<i>2501</i>&nbsp;                if (!found) {
<i>2502</i>&nbsp;                    return false;
<i>2503</i>&nbsp;                }
<i>2504</i>&nbsp;            }
<i>2505</i>&nbsp;            try {
<i>2506</i>&nbsp;                MemberName resolved2 = publicLookup().resolveOrNull(refKind,
<i>2507</i>&nbsp;                    new MemberName(refKind, defc, member.getName(), member.getType()));
<i>2508</i>&nbsp;                if (resolved2 == null) {
<i>2509</i>&nbsp;                    return false;
<i>2510</i>&nbsp;                }
<i>2511</i>&nbsp;                checkSecurityManager(defc, resolved2);
<i>2512</i>&nbsp;            } catch (SecurityException ex) {
<i>2513</i>&nbsp;                return false;
<i>2514</i>&nbsp;            }
<i>2515</i>&nbsp;            return true;
<i>2516</i>&nbsp;        }
<i>2517</i>&nbsp;        private
<i>2518</i>&nbsp;        MethodHandle getDirectMethodForConstant(byte refKind, Class&lt;?&gt; defc, MemberName member)
<i>2519</i>&nbsp;                throws ReflectiveOperationException {
<i>2520</i>&nbsp;            if (MethodHandleNatives.refKindIsField(refKind)) {
<i>2521</i>&nbsp;                return getDirectFieldNoSecurityManager(refKind, defc, member);
<i>2522</i>&nbsp;            } else if (MethodHandleNatives.refKindIsMethod(refKind)) {
<i>2523</i>&nbsp;                return getDirectMethodNoSecurityManager(refKind, defc, member, lookupClass);
<i>2524</i>&nbsp;            } else if (refKind == REF_newInvokeSpecial) {
<i>2525</i>&nbsp;                return getDirectConstructorNoSecurityManager(defc, member);
<i>2526</i>&nbsp;            }
<i>2527</i>&nbsp;            // oops
<i>2528</i>&nbsp;            throw newIllegalArgumentException(&quot;bad MethodHandle constant #&quot;+member);
<i>2529</i>&nbsp;        }
<i>2530</i>&nbsp;
<i>2531</i>&nbsp;        static ConcurrentHashMap&lt;MemberName, DirectMethodHandle&gt; LOOKASIDE_TABLE = new ConcurrentHashMap&lt;&gt;();
<i>2532</i>&nbsp;    }
<i>2533</i>&nbsp;
<i>2534</i>&nbsp;    /**
<b class="nc"><i>2535</i>&nbsp;     * Produces a method handle constructing arrays of a desired type,</b>
<i>2536</i>&nbsp;     * as if by the {@code anewarray} bytecode.
<i>2537</i>&nbsp;     * The return type of the method handle will be the array type.
<i>2538</i>&nbsp;     * The type of its sole argument will be {@code int}, which specifies the size of the array.
<i>2539</i>&nbsp;     *
<i>2540</i>&nbsp;     * &lt;p&gt; If the returned method handle is invoked with a negative
<i>2541</i>&nbsp;     * array size, a {@code NegativeArraySizeException} will be thrown.
<i>2542</i>&nbsp;     *
<i>2543</i>&nbsp;     * @param arrayClass an array type
<i>2544</i>&nbsp;     * @return a method handle which can create arrays of the given type
<i>2545</i>&nbsp;     * @throws NullPointerException if the argument is {@code null}
<i>2546</i>&nbsp;     * @throws IllegalArgumentException if {@code arrayClass} is not an array type
<i>2547</i>&nbsp;     * @see java.lang.reflect.Array#newInstance(Class, int)
<i>2548</i>&nbsp;     * @jvms 6.5 {@code anewarray} Instruction
<i>2549</i>&nbsp;     * @since 9
<i>2550</i>&nbsp;     */
<i>2551</i>&nbsp;    public static
<i>2552</i>&nbsp;    MethodHandle arrayConstructor(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<i>2553</i>&nbsp;        if (!arrayClass.isArray()) {
<i>2554</i>&nbsp;            throw newIllegalArgumentException(&quot;not an array class: &quot; + arrayClass.getName());
<i>2555</i>&nbsp;        }
<i>2556</i>&nbsp;        MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).
<i>2557</i>&nbsp;                bindTo(arrayClass.getComponentType());
<i>2558</i>&nbsp;        return ani.asType(ani.type().changeReturnType(arrayClass));
<i>2559</i>&nbsp;    }
<i>2560</i>&nbsp;
<i>2561</i>&nbsp;    /**
<i>2562</i>&nbsp;     * Produces a method handle returning the length of an array,
<i>2563</i>&nbsp;     * as if by the {@code arraylength} bytecode.
<i>2564</i>&nbsp;     * The type of the method handle will have {@code int} as return type,
<i>2565</i>&nbsp;     * and its sole argument will be the array type.
<i>2566</i>&nbsp;     *
<i>2567</i>&nbsp;     * &lt;p&gt; If the returned method handle is invoked with a {@code null}
<i>2568</i>&nbsp;     * array reference, a {@code NullPointerException} will be thrown.
<i>2569</i>&nbsp;     *
<i>2570</i>&nbsp;     * @param arrayClass an array type
<i>2571</i>&nbsp;     * @return a method handle which can retrieve the length of an array of the given array type
<i>2572</i>&nbsp;     * @throws NullPointerException if the argument is {@code null}
<i>2573</i>&nbsp;     * @throws IllegalArgumentException if arrayClass is not an array type
<i>2574</i>&nbsp;     * @jvms 6.5 {@code arraylength} Instruction
<i>2575</i>&nbsp;     * @since 9
<i>2576</i>&nbsp;     */
<i>2577</i>&nbsp;    public static
<i>2578</i>&nbsp;    MethodHandle arrayLength(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<i>2579</i>&nbsp;        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.LENGTH);
<i>2580</i>&nbsp;    }
<i>2581</i>&nbsp;
<i>2582</i>&nbsp;    /**
<i>2583</i>&nbsp;     * Produces a method handle giving read access to elements of an array,
<i>2584</i>&nbsp;     * as if by the {@code aaload} bytecode.
<i>2585</i>&nbsp;     * The type of the method handle will have a return type of the array&#39;s
<i>2586</i>&nbsp;     * element type.  Its first argument will be the array type,
<i>2587</i>&nbsp;     * and the second will be {@code int}.
<i>2588</i>&nbsp;     *
<i>2589</i>&nbsp;     * &lt;p&gt; When the returned method handle is invoked,
<i>2590</i>&nbsp;     * the array reference and array index are checked.
<i>2591</i>&nbsp;     * A {@code NullPointerException} will be thrown if the array reference
<i>2592</i>&nbsp;     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
<i>2593</i>&nbsp;     * thrown if the index is negative or if it is greater than or equal to
<i>2594</i>&nbsp;     * the length of the array.
<i>2595</i>&nbsp;     *
<i>2596</i>&nbsp;     * @param arrayClass an array type
<i>2597</i>&nbsp;     * @return a method handle which can load values from the given array type
<i>2598</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>2599</i>&nbsp;     * @throws  IllegalArgumentException if arrayClass is not an array type
<i>2600</i>&nbsp;     * @jvms 6.5 {@code aaload} Instruction
<i>2601</i>&nbsp;     */
<i>2602</i>&nbsp;    public static
<i>2603</i>&nbsp;    MethodHandle arrayElementGetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<i>2604</i>&nbsp;        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.GET);
<b class="nc"><i>2605</i>&nbsp;    }</b>
<b class="nc"><i>2606</i>&nbsp;</b>
<b class="nc"><i>2607</i>&nbsp;    /**</b>
<b class="nc"><i>2608</i>&nbsp;     * Produces a method handle giving write access to elements of an array,</b>
<b class="nc"><i>2609</i>&nbsp;     * as if by the {@code astore} bytecode.</b>
<b class="nc"><i>2610</i>&nbsp;     * The type of the method handle will have a void return type.</b>
<b class="nc"><i>2611</i>&nbsp;     * Its last argument will be the array&#39;s element type.</b>
<i>2612</i>&nbsp;     * The first and second arguments will be the array type and int.
<b class="nc"><i>2613</i>&nbsp;     *</b>
<i>2614</i>&nbsp;     * &lt;p&gt; When the returned method handle is invoked,
<i>2615</i>&nbsp;     * the array reference and array index are checked.
<i>2616</i>&nbsp;     * A {@code NullPointerException} will be thrown if the array reference
<i>2617</i>&nbsp;     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
<b class="nc"><i>2618</i>&nbsp;     * thrown if the index is negative or if it is greater than or equal to</b>
<b class="nc"><i>2619</i>&nbsp;     * the length of the array.</b>
<b class="nc"><i>2620</i>&nbsp;     *</b>
<b class="nc"><i>2621</i>&nbsp;     * @param arrayClass the class of an array</b>
<b class="nc"><i>2622</i>&nbsp;     * @return a method handle which can store values into the array type</b>
<b class="nc"><i>2623</i>&nbsp;     * @throws NullPointerException if the argument is null</b>
<b class="nc"><i>2624</i>&nbsp;     * @throws IllegalArgumentException if arrayClass is not an array type</b>
<b class="nc"><i>2625</i>&nbsp;     * @jvms 6.5 {@code aastore} Instruction</b>
<b class="nc"><i>2626</i>&nbsp;     */</b>
<i>2627</i>&nbsp;    public static
<i>2628</i>&nbsp;    MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<i>2629</i>&nbsp;        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
<b class="nc"><i>2630</i>&nbsp;    }</b>
<b class="nc"><i>2631</i>&nbsp;</b>
<b class="nc"><i>2632</i>&nbsp;    /**</b>
<b class="nc"><i>2633</i>&nbsp;     * Produces a VarHandle giving access to elements of an array of type</b>
<i>2634</i>&nbsp;     * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
<i>2635</i>&nbsp;     * of {@code arrayClass} and the list of coordinate types is
<i>2636</i>&nbsp;     * {@code (arrayClass, int)}, where the {@code int} coordinate type
<b class="nc"><i>2637</i>&nbsp;     * corresponds to an argument that is an index into an array.</b>
<b class="nc"><i>2638</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2639</i>&nbsp;     * Certain access modes of the returned VarHandle are unsupported under</b>
<b class="nc"><i>2640</i>&nbsp;     * the following conditions:</b>
<b class="nc"><i>2641</i>&nbsp;     * &lt;ul&gt;</b>
<i>2642</i>&nbsp;     * &lt;li&gt;if the component type is anything other than {@code byte},
<i>2643</i>&nbsp;     *     {@code short}, {@code char}, {@code int}, {@code long},
<i>2644</i>&nbsp;     *     {@code float}, or {@code double} then numeric atomic update access
<i>2645</i>&nbsp;     *     modes are unsupported.
<i>2646</i>&nbsp;     * &lt;li&gt;if the field type is anything other than {@code boolean},
<i>2647</i>&nbsp;     *     {@code byte}, {@code short}, {@code char}, {@code int} or
<i>2648</i>&nbsp;     *     {@code long} then bitwise atomic update access modes are
<i>2649</i>&nbsp;     *     unsupported.
<i>2650</i>&nbsp;     * &lt;/ul&gt;
<i>2651</i>&nbsp;     * &lt;p&gt;
<i>2652</i>&nbsp;     * If the component type is {@code float} or {@code double} then numeric
<i>2653</i>&nbsp;     * and atomic update access modes compare values using their bitwise
<i>2654</i>&nbsp;     * representation (see {@link Float#floatToRawIntBits} and
<i>2655</i>&nbsp;     * {@link Double#doubleToRawLongBits}, respectively).
<i>2656</i>&nbsp;     *
<i>2657</i>&nbsp;     * &lt;p&gt; When the returned {@code VarHandle} is invoked,
<i>2658</i>&nbsp;     * the array reference and array index are checked.
<i>2659</i>&nbsp;     * A {@code NullPointerException} will be thrown if the array reference
<i>2660</i>&nbsp;     * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
<i>2661</i>&nbsp;     * thrown if the index is negative or if it is greater than or equal to
<i>2662</i>&nbsp;     * the length of the array.
<i>2663</i>&nbsp;     *
<i>2664</i>&nbsp;     * @apiNote
<i>2665</i>&nbsp;     * Bitwise comparison of {@code float} values or {@code double} values,
<i>2666</i>&nbsp;     * as performed by the numeric and atomic update access modes, differ
<i>2667</i>&nbsp;     * from the primitive {@code ==} operator and the {@link Float#equals}
<i>2668</i>&nbsp;     * and {@link Double#equals} methods, specifically with respect to
<i>2669</i>&nbsp;     * comparing NaN values or comparing {@code -0.0} with {@code +0.0}.
<i>2670</i>&nbsp;     * Care should be taken when performing a compare and set or a compare
<i>2671</i>&nbsp;     * and exchange operation with such values since the operation may
<i>2672</i>&nbsp;     * unexpectedly fail.
<i>2673</i>&nbsp;     * There are many possible NaN values that are considered to be
<i>2674</i>&nbsp;     * {@code NaN} in Java, although no IEEE 754 floating-point operation
<i>2675</i>&nbsp;     * provided by Java can distinguish between them.  Operation failure can
<i>2676</i>&nbsp;     * occur if the expected or witness value is a NaN value and it is
<i>2677</i>&nbsp;     * transformed (perhaps in a platform specific manner) into another NaN
<i>2678</i>&nbsp;     * value, and thus has a different bitwise representation (see
<i>2679</i>&nbsp;     * {@link Float#intBitsToFloat} or {@link Double#longBitsToDouble} for more
<i>2680</i>&nbsp;     * details).
<i>2681</i>&nbsp;     * The values {@code -0.0} and {@code +0.0} have different bitwise
<i>2682</i>&nbsp;     * representations but are considered equal when using the primitive
<i>2683</i>&nbsp;     * {@code ==} operator.  Operation failure can occur if, for example, a
<i>2684</i>&nbsp;     * numeric algorithm computes an expected value to be say {@code -0.0}
<i>2685</i>&nbsp;     * and previously computed the witness value to be say {@code +0.0}.
<i>2686</i>&nbsp;     * @param arrayClass the class of an array, of type {@code T[]}
<i>2687</i>&nbsp;     * @return a VarHandle giving access to elements of an array
<i>2688</i>&nbsp;     * @throws NullPointerException if the arrayClass is null
<i>2689</i>&nbsp;     * @throws IllegalArgumentException if arrayClass is not an array type
<i>2690</i>&nbsp;     * @since 9
<i>2691</i>&nbsp;     */
<i>2692</i>&nbsp;    public static
<i>2693</i>&nbsp;    VarHandle arrayElementVarHandle(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<i>2694</i>&nbsp;        return VarHandles.makeArrayElementHandle(arrayClass);
<i>2695</i>&nbsp;    }
<i>2696</i>&nbsp;
<i>2697</i>&nbsp;    /**
<i>2698</i>&nbsp;     * Produces a VarHandle giving access to elements of a {@code byte[]} array
<i>2699</i>&nbsp;     * viewed as if it were a different primitive array type, such as
<i>2700</i>&nbsp;     * {@code int[]} or {@code long[]}.
<i>2701</i>&nbsp;     * The VarHandle&#39;s variable type is the component type of
<i>2702</i>&nbsp;     * {@code viewArrayClass} and the list of coordinate types is
<i>2703</i>&nbsp;     * {@code (byte[], int)}, where the {@code int} coordinate type
<i>2704</i>&nbsp;     * corresponds to an argument that is an index into a {@code byte[]} array.
<i>2705</i>&nbsp;     * The returned VarHandle accesses bytes at an index in a {@code byte[]}
<i>2706</i>&nbsp;     * array, composing bytes to or from a value of the component type of
<i>2707</i>&nbsp;     * {@code viewArrayClass} according to the given endianness.
<i>2708</i>&nbsp;     * &lt;p&gt;
<i>2709</i>&nbsp;     * The supported component types (variables types) are {@code short},
<i>2710</i>&nbsp;     * {@code char}, {@code int}, {@code long}, {@code float} and
<i>2711</i>&nbsp;     * {@code double}.
<i>2712</i>&nbsp;     * &lt;p&gt;
<i>2713</i>&nbsp;     * Access of bytes at a given index will result in an
<i>2714</i>&nbsp;     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
<i>2715</i>&nbsp;     * or greater than the {@code byte[]} array length minus the size (in bytes)
<i>2716</i>&nbsp;     * of {@code T}.
<i>2717</i>&nbsp;     * &lt;p&gt;
<i>2718</i>&nbsp;     * Access of bytes at an index may be aligned or misaligned for {@code T},
<i>2719</i>&nbsp;     * with respect to the underlying memory address, {@code A} say, associated
<i>2720</i>&nbsp;     * with the array and index.
<i>2721</i>&nbsp;     * If access is misaligned then access for anything other than the
<i>2722</i>&nbsp;     * {@code get} and {@code set} access modes will result in an
<i>2723</i>&nbsp;     * {@code IllegalStateException}.  In such cases atomic access is only
<i>2724</i>&nbsp;     * guaranteed with respect to the largest power of two that divides the GCD
<i>2725</i>&nbsp;     * of {@code A} and the size (in bytes) of {@code T}.
<i>2726</i>&nbsp;     * If access is aligned then following access modes are supported and are
<i>2727</i>&nbsp;     * guaranteed to support atomic access:
<i>2728</i>&nbsp;     * &lt;ul&gt;
<i>2729</i>&nbsp;     * &lt;li&gt;read write access modes for all {@code T}, with the exception of
<i>2730</i>&nbsp;     *     access modes {@code get} and {@code set} for {@code long} and
<i>2731</i>&nbsp;     *     {@code double} on 32-bit platforms.
<i>2732</i>&nbsp;     * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
<i>2733</i>&nbsp;     *     {@code float} or {@code double}.
<i>2734</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2735</i>&nbsp;     *     types for certain currently unsupported access modes.)
<i>2736</i>&nbsp;     * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
<i>2737</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2738</i>&nbsp;     *     numeric types for certain currently unsupported access modes.)
<i>2739</i>&nbsp;     * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
<i>2740</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2741</i>&nbsp;     *     numeric types for certain currently unsupported access modes.)
<i>2742</i>&nbsp;     * &lt;/ul&gt;
<i>2743</i>&nbsp;     * &lt;p&gt;
<i>2744</i>&nbsp;     * Misaligned access, and therefore atomicity guarantees, may be determined
<i>2745</i>&nbsp;     * for {@code byte[]} arrays without operating on a specific array.  Given
<i>2746</i>&nbsp;     * an {@code index}, {@code T} and it&#39;s corresponding boxed type,
<i>2747</i>&nbsp;     * {@code T_BOX}, misalignment may be determined as follows:
<i>2748</i>&nbsp;     * &lt;pre&gt;{@code
<i>2749</i>&nbsp;     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
<i>2750</i>&nbsp;     * int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
<i>2751</i>&nbsp;     *     alignmentOffset(0, sizeOfT);
<b class="nc"><i>2752</i>&nbsp;     * int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;</b>
<b class="nc"><i>2753</i>&nbsp;     * boolean isMisaligned = misalignedAtIndex != 0;</b>
<b class="nc"><i>2754</i>&nbsp;     * }&lt;/pre&gt;</b>
<i>2755</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2756</i>&nbsp;     * If the variable type is {@code float} or {@code double} then atomic</b>
<b class="nc"><i>2757</i>&nbsp;     * update access modes compare values using their bitwise representation</b>
<b class="nc"><i>2758</i>&nbsp;     * (see {@link Float#floatToRawIntBits} and</b>
<b class="nc"><i>2759</i>&nbsp;     * {@link Double#doubleToRawLongBits}, respectively).</b>
<i>2760</i>&nbsp;     * @param viewArrayClass the view array class, with a component type of
<i>2761</i>&nbsp;     * type {@code T}
<b class="nc"><i>2762</i>&nbsp;     * @param byteOrder the endianness of the view array elements, as</b>
<b class="nc"><i>2763</i>&nbsp;     * stored in the underlying {@code byte} array</b>
<i>2764</i>&nbsp;     * @return a VarHandle giving access to elements of a {@code byte[]} array
<i>2765</i>&nbsp;     * viewed as if elements corresponding to the components type of the view
<i>2766</i>&nbsp;     * array class
<b class="nc"><i>2767</i>&nbsp;     * @throws NullPointerException if viewArrayClass or byteOrder is null</b>
<b class="nc"><i>2768</i>&nbsp;     * @throws IllegalArgumentException if viewArrayClass is not an array type</b>
<b class="nc"><i>2769</i>&nbsp;     * @throws UnsupportedOperationException if the component type of</b>
<b class="nc"><i>2770</i>&nbsp;     * viewArrayClass is not supported as a variable type</b>
<b class="nc"><i>2771</i>&nbsp;     * @since 9</b>
<b class="nc"><i>2772</i>&nbsp;     */</b>
<i>2773</i>&nbsp;    public static
<b class="nc"><i>2774</i>&nbsp;    VarHandle byteArrayViewVarHandle(Class&lt;?&gt; viewArrayClass,</b>
<b class="nc"><i>2775</i>&nbsp;                                     ByteOrder byteOrder) throws IllegalArgumentException {</b>
<i>2776</i>&nbsp;        Objects.requireNonNull(byteOrder);
<b class="nc"><i>2777</i>&nbsp;        return VarHandles.byteArrayViewHandle(viewArrayClass,</b>
<i>2778</i>&nbsp;                                              byteOrder == ByteOrder.BIG_ENDIAN);
<i>2779</i>&nbsp;    }
<i>2780</i>&nbsp;
<i>2781</i>&nbsp;    /**
<i>2782</i>&nbsp;     * Produces a VarHandle giving access to elements of a {@code ByteBuffer}
<i>2783</i>&nbsp;     * viewed as if it were an array of elements of a different primitive
<i>2784</i>&nbsp;     * component type to that of {@code byte}, such as {@code int[]} or
<i>2785</i>&nbsp;     * {@code long[]}.
<i>2786</i>&nbsp;     * The VarHandle&#39;s variable type is the component type of
<i>2787</i>&nbsp;     * {@code viewArrayClass} and the list of coordinate types is
<i>2788</i>&nbsp;     * {@code (ByteBuffer, int)}, where the {@code int} coordinate type
<i>2789</i>&nbsp;     * corresponds to an argument that is an index into a {@code byte[]} array.
<i>2790</i>&nbsp;     * The returned VarHandle accesses bytes at an index in a
<i>2791</i>&nbsp;     * {@code ByteBuffer}, composing bytes to or from a value of the component
<i>2792</i>&nbsp;     * type of {@code viewArrayClass} according to the given endianness.
<i>2793</i>&nbsp;     * &lt;p&gt;
<i>2794</i>&nbsp;     * The supported component types (variables types) are {@code short},
<i>2795</i>&nbsp;     * {@code char}, {@code int}, {@code long}, {@code float} and
<i>2796</i>&nbsp;     * {@code double}.
<i>2797</i>&nbsp;     * &lt;p&gt;
<i>2798</i>&nbsp;     * Access will result in a {@code ReadOnlyBufferException} for anything
<i>2799</i>&nbsp;     * other than the read access modes if the {@code ByteBuffer} is read-only.
<i>2800</i>&nbsp;     * &lt;p&gt;
<i>2801</i>&nbsp;     * Access of bytes at a given index will result in an
<i>2802</i>&nbsp;     * {@code IndexOutOfBoundsException} if the index is less than {@code 0}
<i>2803</i>&nbsp;     * or greater than the {@code ByteBuffer} limit minus the size (in bytes) of
<i>2804</i>&nbsp;     * {@code T}.
<i>2805</i>&nbsp;     * &lt;p&gt;
<i>2806</i>&nbsp;     * Access of bytes at an index may be aligned or misaligned for {@code T},
<i>2807</i>&nbsp;     * with respect to the underlying memory address, {@code A} say, associated
<i>2808</i>&nbsp;     * with the {@code ByteBuffer} and index.
<i>2809</i>&nbsp;     * If access is misaligned then access for anything other than the
<i>2810</i>&nbsp;     * {@code get} and {@code set} access modes will result in an
<i>2811</i>&nbsp;     * {@code IllegalStateException}.  In such cases atomic access is only
<i>2812</i>&nbsp;     * guaranteed with respect to the largest power of two that divides the GCD
<i>2813</i>&nbsp;     * of {@code A} and the size (in bytes) of {@code T}.
<i>2814</i>&nbsp;     * If access is aligned then following access modes are supported and are
<i>2815</i>&nbsp;     * guaranteed to support atomic access:
<i>2816</i>&nbsp;     * &lt;ul&gt;
<i>2817</i>&nbsp;     * &lt;li&gt;read write access modes for all {@code T}, with the exception of
<i>2818</i>&nbsp;     *     access modes {@code get} and {@code set} for {@code long} and
<i>2819</i>&nbsp;     *     {@code double} on 32-bit platforms.
<i>2820</i>&nbsp;     * &lt;li&gt;atomic update access modes for {@code int}, {@code long},
<i>2821</i>&nbsp;     *     {@code float} or {@code double}.
<i>2822</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2823</i>&nbsp;     *     types for certain currently unsupported access modes.)
<i>2824</i>&nbsp;     * &lt;li&gt;numeric atomic update access modes for {@code int} and {@code long}.
<i>2825</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2826</i>&nbsp;     *     numeric types for certain currently unsupported access modes.)
<i>2827</i>&nbsp;     * &lt;li&gt;bitwise atomic update access modes for {@code int} and {@code long}.
<i>2828</i>&nbsp;     *     (Future major platform releases of the JDK may support additional
<i>2829</i>&nbsp;     *     numeric types for certain currently unsupported access modes.)
<i>2830</i>&nbsp;     * &lt;/ul&gt;
<i>2831</i>&nbsp;     * &lt;p&gt;
<i>2832</i>&nbsp;     * Misaligned access, and therefore atomicity guarantees, may be determined
<i>2833</i>&nbsp;     * for a {@code ByteBuffer}, {@code bb} (direct or otherwise), an
<i>2834</i>&nbsp;     * {@code index}, {@code T} and it&#39;s corresponding boxed type,
<i>2835</i>&nbsp;     * {@code T_BOX}, as follows:
<i>2836</i>&nbsp;     * &lt;pre&gt;{@code
<i>2837</i>&nbsp;     * int sizeOfT = T_BOX.BYTES;  // size in bytes of T
<i>2838</i>&nbsp;     * ByteBuffer bb = ...
<b class="nc"><i>2839</i>&nbsp;     * int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);</b>
<b class="nc"><i>2840</i>&nbsp;     * boolean isMisaligned = misalignedAtIndex != 0;</b>
<b class="nc"><i>2841</i>&nbsp;     * }&lt;/pre&gt;</b>
<b class="nc"><i>2842</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2843</i>&nbsp;     * If the variable type is {@code float} or {@code double} then atomic</b>
<b class="nc"><i>2844</i>&nbsp;     * update access modes compare values using their bitwise representation</b>
<b class="nc"><i>2845</i>&nbsp;     * (see {@link Float#floatToRawIntBits} and</b>
<b class="nc"><i>2846</i>&nbsp;     * {@link Double#doubleToRawLongBits}, respectively).</b>
<b class="nc"><i>2847</i>&nbsp;     * @param viewArrayClass the view array class, with a component type of</b>
<i>2848</i>&nbsp;     * type {@code T}
<i>2849</i>&nbsp;     * @param byteOrder the endianness of the view array elements, as
<i>2850</i>&nbsp;     * stored in the underlying {@code ByteBuffer} (Note this overrides the
<b class="nc"><i>2851</i>&nbsp;     * endianness of a {@code ByteBuffer})</b>
<b class="nc"><i>2852</i>&nbsp;     * @return a VarHandle giving access to elements of a {@code ByteBuffer}</b>
<b class="nc"><i>2853</i>&nbsp;     * viewed as if elements corresponding to the components type of the view</b>
<i>2854</i>&nbsp;     * array class
<b class="nc"><i>2855</i>&nbsp;     * @throws NullPointerException if viewArrayClass or byteOrder is null</b>
<b class="nc"><i>2856</i>&nbsp;     * @throws IllegalArgumentException if viewArrayClass is not an array type</b>
<i>2857</i>&nbsp;     * @throws UnsupportedOperationException if the component type of
<i>2858</i>&nbsp;     * viewArrayClass is not supported as a variable type
<i>2859</i>&nbsp;     * @since 9
<i>2860</i>&nbsp;     */
<i>2861</i>&nbsp;    public static
<i>2862</i>&nbsp;    VarHandle byteBufferViewVarHandle(Class&lt;?&gt; viewArrayClass,
<i>2863</i>&nbsp;                                      ByteOrder byteOrder) throws IllegalArgumentException {
<i>2864</i>&nbsp;        Objects.requireNonNull(byteOrder);
<i>2865</i>&nbsp;        return VarHandles.makeByteBufferViewHandle(viewArrayClass,
<i>2866</i>&nbsp;                                                   byteOrder == ByteOrder.BIG_ENDIAN);
<i>2867</i>&nbsp;    }
<i>2868</i>&nbsp;
<i>2869</i>&nbsp;
<i>2870</i>&nbsp;    /// method handle invocation (reflective style)
<i>2871</i>&nbsp;
<i>2872</i>&nbsp;    /**
<i>2873</i>&nbsp;     * Produces a method handle which will invoke any method handle of the
<i>2874</i>&nbsp;     * given {@code type}, with a given number of trailing arguments replaced by
<i>2875</i>&nbsp;     * a single trailing {@code Object[]} array.
<i>2876</i>&nbsp;     * The resulting invoker will be a method handle with the following
<i>2877</i>&nbsp;     * arguments:
<i>2878</i>&nbsp;     * &lt;ul&gt;
<i>2879</i>&nbsp;     * &lt;li&gt;a single {@code MethodHandle} target
<i>2880</i>&nbsp;     * &lt;li&gt;zero or more leading values (counted by {@code leadingArgCount})
<i>2881</i>&nbsp;     * &lt;li&gt;an {@code Object[]} array containing trailing arguments
<i>2882</i>&nbsp;     * &lt;/ul&gt;
<i>2883</i>&nbsp;     * &lt;p&gt;
<i>2884</i>&nbsp;     * The invoker will invoke its target like a call to {@link MethodHandle#invoke invoke} with
<i>2885</i>&nbsp;     * the indicated {@code type}.
<i>2886</i>&nbsp;     * That is, if the target is exactly of the given {@code type}, it will behave
<i>2887</i>&nbsp;     * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle#asType asType}
<i>2888</i>&nbsp;     * is used to convert the target to the required {@code type}.
<i>2889</i>&nbsp;     * &lt;p&gt;
<i>2890</i>&nbsp;     * The type of the returned invoker will not be the given {@code type}, but rather
<i>2891</i>&nbsp;     * will have all parameters except the first {@code leadingArgCount}
<i>2892</i>&nbsp;     * replaced by a single array of type {@code Object[]}, which will be
<i>2893</i>&nbsp;     * the final parameter.
<i>2894</i>&nbsp;     * &lt;p&gt;
<i>2895</i>&nbsp;     * Before invoking its target, the invoker will spread the final array, apply
<i>2896</i>&nbsp;     * reference casts as necessary, and unbox and widen primitive arguments.
<i>2897</i>&nbsp;     * If, when the invoker is called, the supplied array argument does
<i>2898</i>&nbsp;     * not have the correct number of elements, the invoker will throw
<i>2899</i>&nbsp;     * an {@link IllegalArgumentException} instead of invoking the target.
<i>2900</i>&nbsp;     * &lt;p&gt;
<i>2901</i>&nbsp;     * This method is equivalent to the following code (though it may be more efficient):
<i>2902</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>2903</i>&nbsp;MethodHandle invoker = MethodHandles.invoker(type);
<i>2904</i>&nbsp;int spreadArgCount = type.parameterCount() - leadingArgCount;
<i>2905</i>&nbsp;invoker = invoker.asSpreader(Object[].class, spreadArgCount);
<i>2906</i>&nbsp;return invoker;
<i>2907</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>2908</i>&nbsp;     * This method throws no reflective or security exceptions.
<i>2909</i>&nbsp;     * @param type the desired target type
<i>2910</i>&nbsp;     * @param leadingArgCount number of fixed arguments, to be passed unchanged to the target
<i>2911</i>&nbsp;     * @return a method handle suitable for invoking any method handle of the given type
<i>2912</i>&nbsp;     * @throws NullPointerException if {@code type} is null
<i>2913</i>&nbsp;     * @throws IllegalArgumentException if {@code leadingArgCount} is not in
<i>2914</i>&nbsp;     *                  the range from 0 to {@code type.parameterCount()} inclusive,
<i>2915</i>&nbsp;     *                  or if the resulting method handle&#39;s type would have
<i>2916</i>&nbsp;     *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>2917</i>&nbsp;     */
<i>2918</i>&nbsp;    public static
<i>2919</i>&nbsp;    MethodHandle spreadInvoker(MethodType type, int leadingArgCount) {
<i>2920</i>&nbsp;        if (leadingArgCount &lt; 0 || leadingArgCount &gt; type.parameterCount())
<i>2921</i>&nbsp;            throw newIllegalArgumentException(&quot;bad argument count&quot;, leadingArgCount);
<i>2922</i>&nbsp;        type = type.asSpreaderType(Object[].class, leadingArgCount, type.parameterCount() - leadingArgCount);
<i>2923</i>&nbsp;        return type.invokers().spreadInvoker(leadingArgCount);
<i>2924</i>&nbsp;    }
<i>2925</i>&nbsp;
<i>2926</i>&nbsp;    /**
<i>2927</i>&nbsp;     * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
<i>2928</i>&nbsp;     * invoke any method handle of the given type, as if by {@link MethodHandle#invokeExact invokeExact}.
<i>2929</i>&nbsp;     * The resulting invoker will have a type which is
<i>2930</i>&nbsp;     * exactly equal to the desired type, except that it will accept
<i>2931</i>&nbsp;     * an additional leading argument of type {@code MethodHandle}.
<i>2932</i>&nbsp;     * &lt;p&gt;
<i>2933</i>&nbsp;     * This method is equivalent to the following code (though it may be more efficient):
<i>2934</i>&nbsp;     * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invokeExact&quot;, type)}
<i>2935</i>&nbsp;     *
<i>2936</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<b class="nc"><i>2937</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;</b>
<b class="nc"><i>2938</i>&nbsp;     * Invoker method handles can be useful when working with variable method handles</b>
<b class="nc"><i>2939</i>&nbsp;     * of unknown types.</b>
<b class="nc"><i>2940</i>&nbsp;     * For example, to emulate an {@code invokeExact} call to a variable method</b>
<b class="nc"><i>2941</i>&nbsp;     * handle {@code M}, extract its type {@code T},</b>
<b class="nc"><i>2942</i>&nbsp;     * look up the invoker method {@code X} for {@code T},</b>
<i>2943</i>&nbsp;     * and call the invoker method, as {@code X.invoke(T, A...)}.
<b class="nc"><i>2944</i>&nbsp;     * (It would not work to call {@code X.invokeExact}, since the type {@code T}</b>
<b class="nc"><i>2945</i>&nbsp;     * is unknown.)</b>
<b class="nc"><i>2946</i>&nbsp;     * If spreading, collecting, or other argument transformations are required,</b>
<b class="nc"><i>2947</i>&nbsp;     * they can be applied once to the invoker {@code X} and reused on many {@code M}</b>
<b class="nc"><i>2948</i>&nbsp;     * method handle values, as long as they are compatible with the type of {@code X}.</b>
<b class="nc"><i>2949</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;</b>
<i>2950</i>&nbsp;     * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
<i>2951</i>&nbsp;     * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
<i>2952</i>&nbsp;     * on the declared {@code invokeExact} or {@code invoke} method will raise an
<b class="nc"><i>2953</i>&nbsp;     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;</b>
<b class="nc"><i>2954</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2955</i>&nbsp;     * This method throws no reflective or security exceptions.</b>
<b class="nc"><i>2956</i>&nbsp;     * @param type the desired target type</b>
<b class="nc"><i>2957</i>&nbsp;     * @return a method handle suitable for invoking any method handle of the given type</b>
<b class="nc"><i>2958</i>&nbsp;     * @throws IllegalArgumentException if the resulting method handle&#39;s type would have</b>
<b class="nc"><i>2959</i>&nbsp;     *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;</b>
<i>2960</i>&nbsp;     */
<b class="nc"><i>2961</i>&nbsp;    public static</b>
<b class="nc"><i>2962</i>&nbsp;    MethodHandle exactInvoker(MethodType type) {</b>
<b class="nc"><i>2963</i>&nbsp;        return type.invokers().exactInvoker();</b>
<b class="nc"><i>2964</i>&nbsp;    }</b>
<b class="nc"><i>2965</i>&nbsp;</b>
<b class="nc"><i>2966</i>&nbsp;    /**</b>
<i>2967</i>&nbsp;     * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
<i>2968</i>&nbsp;     * invoke any method handle compatible with the given type, as if by {@link MethodHandle#invoke invoke}.
<i>2969</i>&nbsp;     * The resulting invoker will have a type which is
<i>2970</i>&nbsp;     * exactly equal to the desired type, except that it will accept
<i>2971</i>&nbsp;     * an additional leading argument of type {@code MethodHandle}.
<i>2972</i>&nbsp;     * &lt;p&gt;
<i>2973</i>&nbsp;     * Before invoking its target, if the target differs from the expected type,
<i>2974</i>&nbsp;     * the invoker will apply reference casts as
<i>2975</i>&nbsp;     * necessary and box, unbox, or widen primitive values, as if by {@link MethodHandle#asType asType}.
<i>2976</i>&nbsp;     * Similarly, the return value will be converted as necessary.
<i>2977</i>&nbsp;     * If the target is a {@linkplain MethodHandle#asVarargsCollector variable arity method handle},
<i>2978</i>&nbsp;     * the required arity conversion will be made, again as if by {@link MethodHandle#asType asType}.
<i>2979</i>&nbsp;     * &lt;p&gt;
<i>2980</i>&nbsp;     * This method is equivalent to the following code (though it may be more efficient):
<i>2981</i>&nbsp;     * {@code publicLookup().findVirtual(MethodHandle.class, &quot;invoke&quot;, type)}
<i>2982</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>2983</i>&nbsp;     * &lt;em&gt;Discussion:&lt;/em&gt;
<i>2984</i>&nbsp;     * A {@linkplain MethodType#genericMethodType general method type} is one which
<i>2985</i>&nbsp;     * mentions only {@code Object} arguments and return values.
<i>2986</i>&nbsp;     * An invoker for such a type is capable of calling any method handle
<i>2987</i>&nbsp;     * of the same arity as the general type.
<i>2988</i>&nbsp;     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
<i>2989</i>&nbsp;     * &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
<i>2990</i>&nbsp;     * An attempt to call {@linkplain java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke}
<i>2991</i>&nbsp;     * on the declared {@code invokeExact} or {@code invoke} method will raise an
<i>2992</i>&nbsp;     * {@link java.lang.UnsupportedOperationException UnsupportedOperationException}.)&lt;/em&gt;
<i>2993</i>&nbsp;     * &lt;p&gt;
<i>2994</i>&nbsp;     * This method throws no reflective or security exceptions.
<i>2995</i>&nbsp;     * @param type the desired target type
<i>2996</i>&nbsp;     * @return a method handle suitable for invoking any method handle convertible to the given type
<i>2997</i>&nbsp;     * @throws IllegalArgumentException if the resulting method handle&#39;s type would have
<i>2998</i>&nbsp;     *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>2999</i>&nbsp;     */
<i>3000</i>&nbsp;    public static
<i>3001</i>&nbsp;    MethodHandle invoker(MethodType type) {
<i>3002</i>&nbsp;        return type.invokers().genericInvoker();
<i>3003</i>&nbsp;    }
<i>3004</i>&nbsp;
<b class="nc"><i>3005</i>&nbsp;    /**</b>
<b class="nc"><i>3006</i>&nbsp;     * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to</b>
<b class="nc"><i>3007</i>&nbsp;     * invoke a signature-polymorphic access mode method on any VarHandle whose</b>
<b class="nc"><i>3008</i>&nbsp;     * associated access mode type is compatible with the given type.</b>
<b class="nc"><i>3009</i>&nbsp;     * The resulting invoker will have a type which is exactly equal to the</b>
<b class="nc"><i>3010</i>&nbsp;     * desired given type, except that it will accept an additional leading</b>
<b class="nc"><i>3011</i>&nbsp;     * argument of type {@code VarHandle}.</b>
<b class="nc"><i>3012</i>&nbsp;     *</b>
<b class="nc"><i>3013</i>&nbsp;     * @param accessMode the VarHandle access mode</b>
<b class="nc"><i>3014</i>&nbsp;     * @param type the desired target type</b>
<b class="nc"><i>3015</i>&nbsp;     * @return a method handle suitable for invoking an access mode method of</b>
<b class="nc"><i>3016</i>&nbsp;     *         any VarHandle whose access mode type is of the given type.</b>
<b class="nc"><i>3017</i>&nbsp;     * @since 9</b>
<b class="nc"><i>3018</i>&nbsp;     */</b>
<b class="nc"><i>3019</i>&nbsp;    static public</b>
<i>3020</i>&nbsp;    MethodHandle varHandleExactInvoker(VarHandle.AccessMode accessMode, MethodType type) {
<b class="nc"><i>3021</i>&nbsp;        return type.invokers().varHandleMethodExactInvoker(accessMode);</b>
<i>3022</i>&nbsp;    }
<i>3023</i>&nbsp;
<i>3024</i>&nbsp;    /**
<b class="nc"><i>3025</i>&nbsp;     * Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to</b>
<i>3026</i>&nbsp;     * invoke a signature-polymorphic access mode method on any VarHandle whose
<i>3027</i>&nbsp;     * associated access mode type is compatible with the given type.
<i>3028</i>&nbsp;     * The resulting invoker will have a type which is exactly equal to the
<i>3029</i>&nbsp;     * desired given type, except that it will accept an additional leading
<i>3030</i>&nbsp;     * argument of type {@code VarHandle}.
<i>3031</i>&nbsp;     * &lt;p&gt;
<i>3032</i>&nbsp;     * Before invoking its target, if the access mode type differs from the
<i>3033</i>&nbsp;     * desired given type, the invoker will apply reference casts as necessary
<i>3034</i>&nbsp;     * and box, unbox, or widen primitive values, as if by
<i>3035</i>&nbsp;     * {@link MethodHandle#asType asType}.  Similarly, the return value will be
<i>3036</i>&nbsp;     * converted as necessary.
<i>3037</i>&nbsp;     * &lt;p&gt;
<i>3038</i>&nbsp;     * This method is equivalent to the following code (though it may be more
<i>3039</i>&nbsp;     * efficient): {@code publicLookup().findVirtual(VarHandle.class, accessMode.name(), type)}
<i>3040</i>&nbsp;     *
<i>3041</i>&nbsp;     * @param accessMode the VarHandle access mode
<i>3042</i>&nbsp;     * @param type the desired target type
<i>3043</i>&nbsp;     * @return a method handle suitable for invoking an access mode method of
<i>3044</i>&nbsp;     *         any VarHandle whose access mode type is convertible to the given
<i>3045</i>&nbsp;     *         type.
<i>3046</i>&nbsp;     * @since 9
<i>3047</i>&nbsp;     */
<i>3048</i>&nbsp;    static public
<i>3049</i>&nbsp;    MethodHandle varHandleInvoker(VarHandle.AccessMode accessMode, MethodType type) {
<i>3050</i>&nbsp;        return type.invokers().varHandleMethodInvoker(accessMode);
<i>3051</i>&nbsp;    }
<i>3052</i>&nbsp;
<i>3053</i>&nbsp;    static /*non-public*/
<i>3054</i>&nbsp;    MethodHandle basicInvoker(MethodType type) {
<i>3055</i>&nbsp;        return type.invokers().basicInvoker();
<i>3056</i>&nbsp;    }
<i>3057</i>&nbsp;
<i>3058</i>&nbsp;     /// method handle modification (creation from other method handles)
<i>3059</i>&nbsp;
<i>3060</i>&nbsp;    /**
<i>3061</i>&nbsp;     * Produces a method handle which adapts the type of the
<i>3062</i>&nbsp;     * given method handle to a new type by pairwise argument and return type conversion.
<i>3063</i>&nbsp;     * The original type and new type must have the same number of arguments.
<i>3064</i>&nbsp;     * The resulting method handle is guaranteed to report a type
<i>3065</i>&nbsp;     * which is equal to the desired new type.
<i>3066</i>&nbsp;     * &lt;p&gt;
<i>3067</i>&nbsp;     * If the original type and new type are equal, returns target.
<i>3068</i>&nbsp;     * &lt;p&gt;
<i>3069</i>&nbsp;     * The same conversions are allowed as for {@link MethodHandle#asType MethodHandle.asType},
<i>3070</i>&nbsp;     * and some additional conversions are also applied if those conversions fail.
<i>3071</i>&nbsp;     * Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
<i>3072</i>&nbsp;     * if possible, before or instead of any conversions done by {@code asType}:
<i>3073</i>&nbsp;     * &lt;ul&gt;
<i>3074</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
<b class="nc"><i>3075</i>&nbsp;     *     then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.</b>
<b class="nc"><i>3076</i>&nbsp;     *     (This treatment of interfaces follows the usage of the bytecode verifier.)</b>
<b class="nc"><i>3077</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,</b>
<b class="nc"><i>3078</i>&nbsp;     *     the boolean is converted to a byte value, 1 for true, 0 for false.</b>
<b class="nc"><i>3079</i>&nbsp;     *     (This treatment follows the usage of the bytecode verifier.)</b>
<b class="nc"><i>3080</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,</b>
<b class="nc"><i>3081</i>&nbsp;     *     &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),</b>
<b class="nc"><i>3082</i>&nbsp;     *     and the low order bit of the result is tested, as if by {@code (x &amp; 1) != 0}.</b>
<b class="nc"><i>3083</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,</b>
<b class="nc"><i>3084</i>&nbsp;     *     then a Java casting conversion (JLS 5.5) is applied.</b>
<b class="nc"><i>3085</i>&nbsp;     *     (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by</b>
<b class="nc"><i>3086</i>&nbsp;     *     widening and/or narrowing.)</b>
<b class="nc"><i>3087</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing</b>
<b class="nc"><i>3088</i>&nbsp;     *     conversion will be applied at runtime, possibly followed</b>
<b class="nc"><i>3089</i>&nbsp;     *     by a Java casting conversion (JLS 5.5) on the primitive value,</b>
<b class="nc"><i>3090</i>&nbsp;     *     possibly followed by a conversion from byte to boolean by testing</b>
<i>3091</i>&nbsp;     *     the low-order bit.
<b class="nc"><i>3092</i>&nbsp;     * &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,</b>
<i>3093</i>&nbsp;     *     and if the reference is null at runtime, a zero value is introduced.
<i>3094</i>&nbsp;     * &lt;/ul&gt;
<i>3095</i>&nbsp;     * @param target the method handle to invoke after arguments are retyped
<i>3096</i>&nbsp;     * @param newType the expected type of the new method handle
<i>3097</i>&nbsp;     * @return a method handle which delegates to the target after performing
<i>3098</i>&nbsp;     *           any necessary argument conversions, and arranges for any
<i>3099</i>&nbsp;     *           necessary return value conversions
<i>3100</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>3101</i>&nbsp;     * @throws WrongMethodTypeException if the conversion cannot be made
<i>3102</i>&nbsp;     * @see MethodHandle#asType
<i>3103</i>&nbsp;     */
<i>3104</i>&nbsp;    public static
<i>3105</i>&nbsp;    MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
<i>3106</i>&nbsp;        explicitCastArgumentsChecks(target, newType);
<i>3107</i>&nbsp;        // use the asTypeCache when possible:
<i>3108</i>&nbsp;        MethodType oldType = target.type();
<b class="nc"><i>3109</i>&nbsp;        if (oldType == newType)  return target;</b>
<b class="nc"><i>3110</i>&nbsp;        if (oldType.explicitCastEquivalentToAsType(newType)) {</b>
<b class="nc"><i>3111</i>&nbsp;            return target.asFixedArity().asType(newType);</b>
<i>3112</i>&nbsp;        }
<i>3113</i>&nbsp;        return MethodHandleImpl.makePairwiseConvert(target, newType, false);
<i>3114</i>&nbsp;    }
<i>3115</i>&nbsp;
<i>3116</i>&nbsp;    private static void explicitCastArgumentsChecks(MethodHandle target, MethodType newType) {
<i>3117</i>&nbsp;        if (target.type().parameterCount() != newType.parameterCount()) {
<i>3118</i>&nbsp;            throw new WrongMethodTypeException(&quot;cannot explicitly cast &quot; + target + &quot; to &quot; + newType);
<i>3119</i>&nbsp;        }
<i>3120</i>&nbsp;    }
<i>3121</i>&nbsp;
<i>3122</i>&nbsp;    /**
<i>3123</i>&nbsp;     * Produces a method handle which adapts the calling sequence of the
<i>3124</i>&nbsp;     * given method handle to a new type, by reordering the arguments.
<i>3125</i>&nbsp;     * The resulting method handle is guaranteed to report a type
<i>3126</i>&nbsp;     * which is equal to the desired new type.
<i>3127</i>&nbsp;     * &lt;p&gt;
<i>3128</i>&nbsp;     * The given array controls the reordering.
<i>3129</i>&nbsp;     * Call {@code #I} the number of incoming parameters (the value
<i>3130</i>&nbsp;     * {@code newType.parameterCount()}, and call {@code #O} the number
<i>3131</i>&nbsp;     * of outgoing parameters (the value {@code target.type().parameterCount()}).
<i>3132</i>&nbsp;     * Then the length of the reordering array must be {@code #O},
<i>3133</i>&nbsp;     * and each element must be a non-negative number less than {@code #I}.
<i>3134</i>&nbsp;     * For every {@code N} less than {@code #O}, the {@code N}-th
<i>3135</i>&nbsp;     * outgoing argument will be taken from the {@code I}-th incoming
<i>3136</i>&nbsp;     * argument, where {@code I} is {@code reorder[N]}.
<i>3137</i>&nbsp;     * &lt;p&gt;
<i>3138</i>&nbsp;     * No argument or return value conversions are applied.
<i>3139</i>&nbsp;     * The type of each incoming argument, as determined by {@code newType},
<i>3140</i>&nbsp;     * must be identical to the type of the corresponding outgoing parameter
<i>3141</i>&nbsp;     * or parameters in the target method handle.
<i>3142</i>&nbsp;     * The return type of {@code newType} must be identical to the return
<i>3143</i>&nbsp;     * type of the original target.
<i>3144</i>&nbsp;     * &lt;p&gt;
<i>3145</i>&nbsp;     * The reordering array need not specify an actual permutation.
<i>3146</i>&nbsp;     * An incoming argument will be duplicated if its index appears
<i>3147</i>&nbsp;     * more than once in the array, and an incoming argument will be dropped
<i>3148</i>&nbsp;     * if its index does not appear in the array.
<i>3149</i>&nbsp;     * As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
<i>3150</i>&nbsp;     * incoming arguments which are not mentioned in the reordering array
<i>3151</i>&nbsp;     * may be of any type, as determined only by {@code newType}.
<i>3152</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3153</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3154</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3155</i>&nbsp;...
<i>3156</i>&nbsp;MethodType intfn1 = methodType(int.class, int.class);
<i>3157</i>&nbsp;MethodType intfn2 = methodType(int.class, int.class, int.class);
<i>3158</i>&nbsp;MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
<i>3159</i>&nbsp;assert(sub.type().equals(intfn2));
<i>3160</i>&nbsp;MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
<i>3161</i>&nbsp;MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
<i>3162</i>&nbsp;assert((int)rsub.invokeExact(1, 100) == 99);
<i>3163</i>&nbsp;MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
<i>3164</i>&nbsp;assert(add.type().equals(intfn2));
<i>3165</i>&nbsp;MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
<i>3166</i>&nbsp;assert(twice.type().equals(intfn1));
<i>3167</i>&nbsp;assert((int)twice.invokeExact(21) == 42);
<i>3168</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3169</i>&nbsp;     * &lt;p&gt;
<i>3170</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>3171</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>3172</i>&nbsp;     * @param target the method handle to invoke after arguments are reordered
<i>3173</i>&nbsp;     * @param newType the expected type of the new method handle
<i>3174</i>&nbsp;     * @param reorder an index array which controls the reordering
<i>3175</i>&nbsp;     * @return a method handle which delegates to the target after it
<i>3176</i>&nbsp;     *           drops unused arguments and moves and/or duplicates the other arguments
<i>3177</i>&nbsp;     * @throws NullPointerException if any argument is null
<i>3178</i>&nbsp;     * @throws IllegalArgumentException if the index array length is not equal to
<i>3179</i>&nbsp;     *                  the arity of the target, or if any index array element
<i>3180</i>&nbsp;     *                  not a valid index for a parameter of {@code newType},
<i>3181</i>&nbsp;     *                  or if two corresponding parameter types in
<i>3182</i>&nbsp;     *                  {@code target.type()} and {@code newType} are not identical,
<i>3183</i>&nbsp;     */
<i>3184</i>&nbsp;    public static
<i>3185</i>&nbsp;    MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
<i>3186</i>&nbsp;        reorder = reorder.clone();  // get a private copy
<i>3187</i>&nbsp;        MethodType oldType = target.type();
<i>3188</i>&nbsp;        permuteArgumentChecks(reorder, newType, oldType);
<i>3189</i>&nbsp;        // first detect dropped arguments and handle them separately
<i>3190</i>&nbsp;        int[] originalReorder = reorder;
<i>3191</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>3192</i>&nbsp;        LambdaForm form = result.form;
<i>3193</i>&nbsp;        int newArity = newType.parameterCount();
<i>3194</i>&nbsp;        // Normalize the reordering into a real permutation,
<i>3195</i>&nbsp;        // by removing duplicates and adding dropped elements.
<i>3196</i>&nbsp;        // This somewhat improves lambda form caching, as well
<i>3197</i>&nbsp;        // as simplifying the transform by breaking it up into steps.
<i>3198</i>&nbsp;        for (int ddIdx; (ddIdx = findFirstDupOrDrop(reorder, newArity)) != 0; ) {
<i>3199</i>&nbsp;            if (ddIdx &gt; 0) {
<i>3200</i>&nbsp;                // We found a duplicated entry at reorder[ddIdx].
<i>3201</i>&nbsp;                // Example:  (x,y,z)-&gt;asList(x,y,z)
<i>3202</i>&nbsp;                // permuted by [1*,0,1] =&gt; (a0,a1)=&gt;asList(a1,a0,a1)
<i>3203</i>&nbsp;                // permuted by [0,1,0*] =&gt; (a0,a1)=&gt;asList(a0,a1,a0)
<i>3204</i>&nbsp;                // The starred element corresponds to the argument
<i>3205</i>&nbsp;                // deleted by the dupArgumentForm transform.
<i>3206</i>&nbsp;                int srcPos = ddIdx, dstPos = srcPos, dupVal = reorder[srcPos];
<i>3207</i>&nbsp;                boolean killFirst = false;
<i>3208</i>&nbsp;                for (int val; (val = reorder[--dstPos]) != dupVal; ) {
<i>3209</i>&nbsp;                    // Set killFirst if the dup is larger than an intervening position.
<i>3210</i>&nbsp;                    // This will remove at least one inversion from the permutation.
<i>3211</i>&nbsp;                    if (dupVal &gt; val) killFirst = true;
<i>3212</i>&nbsp;                }
<i>3213</i>&nbsp;                if (!killFirst) {
<i>3214</i>&nbsp;                    srcPos = dstPos;
<i>3215</i>&nbsp;                    dstPos = ddIdx;
<i>3216</i>&nbsp;                }
<i>3217</i>&nbsp;                form = form.editor().dupArgumentForm(1 + srcPos, 1 + dstPos);
<i>3218</i>&nbsp;                assert (reorder[srcPos] == reorder[dstPos]);
<i>3219</i>&nbsp;                oldType = oldType.dropParameterTypes(dstPos, dstPos + 1);
<i>3220</i>&nbsp;                // contract the reordering by removing the element at dstPos
<i>3221</i>&nbsp;                int tailPos = dstPos + 1;
<i>3222</i>&nbsp;                System.arraycopy(reorder, tailPos, reorder, dstPos, reorder.length - tailPos);
<i>3223</i>&nbsp;                reorder = Arrays.copyOf(reorder, reorder.length - 1);
<i>3224</i>&nbsp;            } else {
<i>3225</i>&nbsp;                int dropVal = ~ddIdx, insPos = 0;
<i>3226</i>&nbsp;                while (insPos &lt; reorder.length &amp;&amp; reorder[insPos] &lt; dropVal) {
<i>3227</i>&nbsp;                    // Find first element of reorder larger than dropVal.
<i>3228</i>&nbsp;                    // This is where we will insert the dropVal.
<i>3229</i>&nbsp;                    insPos += 1;
<i>3230</i>&nbsp;                }
<i>3231</i>&nbsp;                Class&lt;?&gt; ptype = newType.parameterType(dropVal);
<i>3232</i>&nbsp;                form = form.editor().addArgumentForm(1 + insPos, BasicType.basicType(ptype));
<i>3233</i>&nbsp;                oldType = oldType.insertParameterTypes(insPos, ptype);
<i>3234</i>&nbsp;                // expand the reordering by inserting an element at insPos
<i>3235</i>&nbsp;                int tailPos = insPos + 1;
<i>3236</i>&nbsp;                reorder = Arrays.copyOf(reorder, reorder.length + 1);
<i>3237</i>&nbsp;                System.arraycopy(reorder, insPos, reorder, tailPos, reorder.length - tailPos);
<i>3238</i>&nbsp;                reorder[insPos] = dropVal;
<i>3239</i>&nbsp;            }
<i>3240</i>&nbsp;            assert (permuteArgumentChecks(reorder, newType, oldType));
<i>3241</i>&nbsp;        }
<i>3242</i>&nbsp;        assert (reorder.length == newArity);  // a perfect permutation
<i>3243</i>&nbsp;        // Note:  This may cache too many distinct LFs. Consider backing off to varargs code.
<i>3244</i>&nbsp;        form = form.editor().permuteArgumentsForm(1, reorder);
<i>3245</i>&nbsp;        if (newType == result.type() &amp;&amp; form == result.internalForm())
<i>3246</i>&nbsp;            return result;
<i>3247</i>&nbsp;        return result.copyWith(newType, form);
<i>3248</i>&nbsp;    }
<i>3249</i>&nbsp;
<i>3250</i>&nbsp;    /**
<i>3251</i>&nbsp;     * Return an indication of any duplicate or omission in reorder.
<i>3252</i>&nbsp;     * If the reorder contains a duplicate entry, return the index of the second occurrence.
<i>3253</i>&nbsp;     * Otherwise, return ~(n), for the first n in [0..newArity-1] that is not present in reorder.
<i>3254</i>&nbsp;     * Otherwise, return zero.
<i>3255</i>&nbsp;     * If an element not in [0..newArity-1] is encountered, return reorder.length.
<i>3256</i>&nbsp;     */
<i>3257</i>&nbsp;    private static int findFirstDupOrDrop(int[] reorder, int newArity) {
<i>3258</i>&nbsp;        final int BIT_LIMIT = 63;  // max number of bits in bit mask
<i>3259</i>&nbsp;        if (newArity &lt; BIT_LIMIT) {
<i>3260</i>&nbsp;            long mask = 0;
<i>3261</i>&nbsp;            for (int i = 0; i &lt; reorder.length; i++) {
<i>3262</i>&nbsp;                int arg = reorder[i];
<i>3263</i>&nbsp;                if (arg &gt;= newArity) {
<i>3264</i>&nbsp;                    return reorder.length;
<i>3265</i>&nbsp;                }
<i>3266</i>&nbsp;                long bit = 1L &lt;&lt; arg;
<i>3267</i>&nbsp;                if ((mask &amp; bit) != 0) {
<i>3268</i>&nbsp;                    return i;  // &gt;0 indicates a dup
<i>3269</i>&nbsp;                }
<i>3270</i>&nbsp;                mask |= bit;
<i>3271</i>&nbsp;            }
<i>3272</i>&nbsp;            if (mask == (1L &lt;&lt; newArity) - 1) {
<i>3273</i>&nbsp;                assert(Long.numberOfTrailingZeros(Long.lowestOneBit(~mask)) == newArity);
<i>3274</i>&nbsp;                return 0;
<i>3275</i>&nbsp;            }
<i>3276</i>&nbsp;            // find first zero
<i>3277</i>&nbsp;            long zeroBit = Long.lowestOneBit(~mask);
<i>3278</i>&nbsp;            int zeroPos = Long.numberOfTrailingZeros(zeroBit);
<i>3279</i>&nbsp;            assert(zeroPos &lt;= newArity);
<i>3280</i>&nbsp;            if (zeroPos == newArity) {
<i>3281</i>&nbsp;                return 0;
<i>3282</i>&nbsp;            }
<i>3283</i>&nbsp;            return ~zeroPos;
<i>3284</i>&nbsp;        } else {
<i>3285</i>&nbsp;            // same algorithm, different bit set
<i>3286</i>&nbsp;            BitSet mask = new BitSet(newArity);
<i>3287</i>&nbsp;            for (int i = 0; i &lt; reorder.length; i++) {
<i>3288</i>&nbsp;                int arg = reorder[i];
<i>3289</i>&nbsp;                if (arg &gt;= newArity) {
<i>3290</i>&nbsp;                    return reorder.length;
<i>3291</i>&nbsp;                }
<i>3292</i>&nbsp;                if (mask.get(arg)) {
<i>3293</i>&nbsp;                    return i;  // &gt;0 indicates a dup
<i>3294</i>&nbsp;                }
<i>3295</i>&nbsp;                mask.set(arg);
<i>3296</i>&nbsp;            }
<i>3297</i>&nbsp;            int zeroPos = mask.nextClearBit(0);
<i>3298</i>&nbsp;            assert(zeroPos &lt;= newArity);
<i>3299</i>&nbsp;            if (zeroPos == newArity) {
<i>3300</i>&nbsp;                return 0;
<i>3301</i>&nbsp;            }
<i>3302</i>&nbsp;            return ~zeroPos;
<i>3303</i>&nbsp;        }
<i>3304</i>&nbsp;    }
<i>3305</i>&nbsp;
<i>3306</i>&nbsp;    private static boolean permuteArgumentChecks(int[] reorder, MethodType newType, MethodType oldType) {
<i>3307</i>&nbsp;        if (newType.returnType() != oldType.returnType())
<i>3308</i>&nbsp;            throw newIllegalArgumentException(&quot;return types do not match&quot;,
<i>3309</i>&nbsp;                    oldType, newType);
<i>3310</i>&nbsp;        if (reorder.length == oldType.parameterCount()) {
<i>3311</i>&nbsp;            int limit = newType.parameterCount();
<i>3312</i>&nbsp;            boolean bad = false;
<i>3313</i>&nbsp;            for (int j = 0; j &lt; reorder.length; j++) {
<i>3314</i>&nbsp;                int i = reorder[j];
<i>3315</i>&nbsp;                if (i &lt; 0 || i &gt;= limit) {
<i>3316</i>&nbsp;                    bad = true; break;
<i>3317</i>&nbsp;                }
<i>3318</i>&nbsp;                Class&lt;?&gt; src = newType.parameterType(i);
<i>3319</i>&nbsp;                Class&lt;?&gt; dst = oldType.parameterType(j);
<i>3320</i>&nbsp;                if (src != dst)
<i>3321</i>&nbsp;                    throw newIllegalArgumentException(&quot;parameter types do not match after reorder&quot;,
<i>3322</i>&nbsp;                            oldType, newType);
<i>3323</i>&nbsp;            }
<i>3324</i>&nbsp;            if (!bad)  return true;
<i>3325</i>&nbsp;        }
<i>3326</i>&nbsp;        throw newIllegalArgumentException(&quot;bad reorder array: &quot;+Arrays.toString(reorder));
<i>3327</i>&nbsp;    }
<i>3328</i>&nbsp;
<i>3329</i>&nbsp;    /**
<i>3330</i>&nbsp;     * Produces a method handle of the requested return type which returns the given
<i>3331</i>&nbsp;     * constant value every time it is invoked.
<i>3332</i>&nbsp;     * &lt;p&gt;
<i>3333</i>&nbsp;     * Before the method handle is returned, the passed-in value is converted to the requested type.
<i>3334</i>&nbsp;     * If the requested type is primitive, widening primitive conversions are attempted,
<i>3335</i>&nbsp;     * else reference conversions are attempted.
<i>3336</i>&nbsp;     * &lt;p&gt;The returned method handle is equivalent to {@code identity(type).bindTo(value)}.
<i>3337</i>&nbsp;     * @param type the return type of the desired method handle
<i>3338</i>&nbsp;     * @param value the value to return
<i>3339</i>&nbsp;     * @return a method handle of the given return type and no arguments, which always returns the given value
<i>3340</i>&nbsp;     * @throws NullPointerException if the {@code type} argument is null
<i>3341</i>&nbsp;     * @throws ClassCastException if the value cannot be converted to the required return type
<i>3342</i>&nbsp;     * @throws IllegalArgumentException if the given type is {@code void.class}
<i>3343</i>&nbsp;     */
<i>3344</i>&nbsp;    public static
<i>3345</i>&nbsp;    MethodHandle constant(Class&lt;?&gt; type, Object value) {
<i>3346</i>&nbsp;        if (type.isPrimitive()) {
<i>3347</i>&nbsp;            if (type == void.class)
<i>3348</i>&nbsp;                throw newIllegalArgumentException(&quot;void type&quot;);
<i>3349</i>&nbsp;            Wrapper w = Wrapper.forPrimitiveType(type);
<i>3350</i>&nbsp;            value = w.convert(value, type);
<i>3351</i>&nbsp;            if (w.zero().equals(value))
<i>3352</i>&nbsp;                return zero(w, type);
<i>3353</i>&nbsp;            return insertArguments(identity(type), 0, value);
<i>3354</i>&nbsp;        } else {
<i>3355</i>&nbsp;            if (value == null)
<i>3356</i>&nbsp;                return zero(Wrapper.OBJECT, type);
<i>3357</i>&nbsp;            return identity(type).bindTo(value);
<i>3358</i>&nbsp;        }
<i>3359</i>&nbsp;    }
<i>3360</i>&nbsp;
<i>3361</i>&nbsp;    /**
<i>3362</i>&nbsp;     * Produces a method handle which returns its sole argument when invoked.
<i>3363</i>&nbsp;     * @param type the type of the sole parameter and return value of the desired method handle
<i>3364</i>&nbsp;     * @return a unary method handle which accepts and returns the given type
<i>3365</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>3366</i>&nbsp;     * @throws IllegalArgumentException if the given type is {@code void.class}
<i>3367</i>&nbsp;     */
<i>3368</i>&nbsp;    public static
<i>3369</i>&nbsp;    MethodHandle identity(Class&lt;?&gt; type) {
<i>3370</i>&nbsp;        Wrapper btw = (type.isPrimitive() ? Wrapper.forPrimitiveType(type) : Wrapper.OBJECT);
<i>3371</i>&nbsp;        int pos = btw.ordinal();
<i>3372</i>&nbsp;        MethodHandle ident = IDENTITY_MHS[pos];
<i>3373</i>&nbsp;        if (ident == null) {
<i>3374</i>&nbsp;            ident = setCachedMethodHandle(IDENTITY_MHS, pos, makeIdentity(btw.primitiveType()));
<i>3375</i>&nbsp;        }
<i>3376</i>&nbsp;        if (ident.type().returnType() == type)
<i>3377</i>&nbsp;            return ident;
<i>3378</i>&nbsp;        // something like identity(Foo.class); do not bother to intern these
<i>3379</i>&nbsp;        assert (btw == Wrapper.OBJECT);
<i>3380</i>&nbsp;        return makeIdentity(type);
<i>3381</i>&nbsp;    }
<i>3382</i>&nbsp;
<i>3383</i>&nbsp;    /**
<i>3384</i>&nbsp;     * Produces a constant method handle of the requested return type which
<i>3385</i>&nbsp;     * returns the default value for that type every time it is invoked.
<i>3386</i>&nbsp;     * The resulting constant method handle will have no side effects.
<i>3387</i>&nbsp;     * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
<i>3388</i>&nbsp;     * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
<i>3389</i>&nbsp;     * since {@code explicitCastArguments} converts {@code null} to default values.
<i>3390</i>&nbsp;     * @param type the expected return type of the desired method handle
<i>3391</i>&nbsp;     * @return a constant method handle that takes no arguments
<i>3392</i>&nbsp;     *         and returns the default value of the given type (or void, if the type is void)
<i>3393</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>3394</i>&nbsp;     * @see MethodHandles#constant
<i>3395</i>&nbsp;     * @see MethodHandles#empty
<i>3396</i>&nbsp;     * @see MethodHandles#explicitCastArguments
<i>3397</i>&nbsp;     * @since 9
<i>3398</i>&nbsp;     */
<i>3399</i>&nbsp;    public static MethodHandle zero(Class&lt;?&gt; type) {
<i>3400</i>&nbsp;        Objects.requireNonNull(type);
<i>3401</i>&nbsp;        return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);
<i>3402</i>&nbsp;    }
<i>3403</i>&nbsp;
<i>3404</i>&nbsp;    private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
<i>3405</i>&nbsp;        return type == void.class ? zero(type) : identity(type);
<i>3406</i>&nbsp;    }
<i>3407</i>&nbsp;
<i>3408</i>&nbsp;    /**
<i>3409</i>&nbsp;     * Produces a method handle of the requested type which ignores any arguments, does nothing,
<i>3410</i>&nbsp;     * and returns a suitable default depending on the return type.
<i>3411</i>&nbsp;     * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
<i>3412</i>&nbsp;     * &lt;p&gt;The returned method handle is equivalent to
<i>3413</i>&nbsp;     * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
<i>3414</i>&nbsp;     *
<i>3415</i>&nbsp;     * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
<i>3416</i>&nbsp;     * {@code guardWithTest(pred, target, empty(target.type())}.
<i>3417</i>&nbsp;     * @param type the type of the desired method handle
<i>3418</i>&nbsp;     * @return a constant method handle of the given type, which returns a default value of the given return type
<i>3419</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>3420</i>&nbsp;     * @see MethodHandles#zero
<i>3421</i>&nbsp;     * @see MethodHandles#constant
<i>3422</i>&nbsp;     * @since 9
<i>3423</i>&nbsp;     */
<i>3424</i>&nbsp;    public static  MethodHandle empty(MethodType type) {
<i>3425</i>&nbsp;        Objects.requireNonNull(type);
<i>3426</i>&nbsp;        return dropArguments(zero(type.returnType()), 0, type.parameterList());
<i>3427</i>&nbsp;    }
<i>3428</i>&nbsp;
<i>3429</i>&nbsp;    private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
<i>3430</i>&nbsp;    private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<i>3431</i>&nbsp;        MethodType mtype = methodType(ptype, ptype);
<i>3432</i>&nbsp;        LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
<i>3433</i>&nbsp;        return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
<i>3434</i>&nbsp;    }
<i>3435</i>&nbsp;
<i>3436</i>&nbsp;    private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
<i>3437</i>&nbsp;        int pos = btw.ordinal();
<i>3438</i>&nbsp;        MethodHandle zero = ZERO_MHS[pos];
<i>3439</i>&nbsp;        if (zero == null) {
<i>3440</i>&nbsp;            zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
<i>3441</i>&nbsp;        }
<i>3442</i>&nbsp;        if (zero.type().returnType() == rtype)
<i>3443</i>&nbsp;            return zero;
<i>3444</i>&nbsp;        assert(btw == Wrapper.OBJECT);
<i>3445</i>&nbsp;        return makeZero(rtype);
<i>3446</i>&nbsp;    }
<i>3447</i>&nbsp;    private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
<i>3448</i>&nbsp;    private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
<i>3449</i>&nbsp;        MethodType mtype = methodType(rtype);
<i>3450</i>&nbsp;        LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
<i>3451</i>&nbsp;        return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
<i>3452</i>&nbsp;    }
<i>3453</i>&nbsp;
<i>3454</i>&nbsp;    private static synchronized MethodHandle setCachedMethodHandle(MethodHandle[] cache, int pos, MethodHandle value) {
<i>3455</i>&nbsp;        // Simulate a CAS, to avoid racy duplication of results.
<i>3456</i>&nbsp;        MethodHandle prev = cache[pos];
<i>3457</i>&nbsp;        if (prev != null) return prev;
<i>3458</i>&nbsp;        return cache[pos] = value;
<i>3459</i>&nbsp;    }
<i>3460</i>&nbsp;
<i>3461</i>&nbsp;    /**
<i>3462</i>&nbsp;     * Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
<i>3463</i>&nbsp;     * in advance of the method handle&#39;s invocation.
<i>3464</i>&nbsp;     * The formal parameters to the target corresponding to the bound
<i>3465</i>&nbsp;     * arguments are called &lt;em&gt;bound parameters&lt;/em&gt;.
<i>3466</i>&nbsp;     * Returns a new method handle which saves away the bound arguments.
<i>3467</i>&nbsp;     * When it is invoked, it receives arguments for any non-bound parameters,
<i>3468</i>&nbsp;     * binds the saved arguments to their corresponding parameters,
<i>3469</i>&nbsp;     * and calls the original target.
<i>3470</i>&nbsp;     * &lt;p&gt;
<i>3471</i>&nbsp;     * The type of the new method handle will drop the types for the bound
<i>3472</i>&nbsp;     * parameters from the original target type, since the new method handle
<i>3473</i>&nbsp;     * will no longer require those arguments to be supplied by its callers.
<i>3474</i>&nbsp;     * &lt;p&gt;
<i>3475</i>&nbsp;     * Each given argument object must match the corresponding bound parameter type.
<i>3476</i>&nbsp;     * If a bound parameter type is a primitive, the argument object
<i>3477</i>&nbsp;     * must be a wrapper, and will be unboxed to produce the primitive value.
<i>3478</i>&nbsp;     * &lt;p&gt;
<i>3479</i>&nbsp;     * The {@code pos} argument selects which parameters are to be bound.
<i>3480</i>&nbsp;     * It may range between zero and &lt;i&gt;N-L&lt;/i&gt; (inclusively),
<i>3481</i>&nbsp;     * where &lt;i&gt;N&lt;/i&gt; is the arity of the target method handle
<i>3482</i>&nbsp;     * and &lt;i&gt;L&lt;/i&gt; is the length of the values array.
<i>3483</i>&nbsp;     * &lt;p&gt;
<i>3484</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>3485</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>3486</i>&nbsp;     * @param target the method handle to invoke after the argument is inserted
<i>3487</i>&nbsp;     * @param pos where to insert the argument (zero for the first)
<i>3488</i>&nbsp;     * @param values the series of arguments to insert
<i>3489</i>&nbsp;     * @return a method handle which inserts an additional argument,
<i>3490</i>&nbsp;     *         before calling the original method handle
<i>3491</i>&nbsp;     * @throws NullPointerException if the target or the {@code values} array is null
<i>3492</i>&nbsp;     * @throws IllegalArgumentException if (@code pos) is less than {@code 0} or greater than
<i>3493</i>&nbsp;     *         {@code N - L} where {@code N} is the arity of the target method handle and {@code L}
<i>3494</i>&nbsp;     *         is the length of the values array.
<i>3495</i>&nbsp;     * @throws ClassCastException if an argument does not match the corresponding bound parameter
<i>3496</i>&nbsp;     *         type.
<i>3497</i>&nbsp;     * @see MethodHandle#bindTo
<i>3498</i>&nbsp;     */
<i>3499</i>&nbsp;    public static
<i>3500</i>&nbsp;    MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {
<i>3501</i>&nbsp;        int insCount = values.length;
<i>3502</i>&nbsp;        Class&lt;?&gt;[] ptypes = insertArgumentsChecks(target, insCount, pos);
<i>3503</i>&nbsp;        if (insCount == 0)  return target;
<i>3504</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>3505</i>&nbsp;        for (int i = 0; i &lt; insCount; i++) {
<i>3506</i>&nbsp;            Object value = values[i];
<i>3507</i>&nbsp;            Class&lt;?&gt; ptype = ptypes[pos+i];
<i>3508</i>&nbsp;            if (ptype.isPrimitive()) {
<i>3509</i>&nbsp;                result = insertArgumentPrimitive(result, pos, ptype, value);
<i>3510</i>&nbsp;            } else {
<i>3511</i>&nbsp;                value = ptype.cast(value);  // throw CCE if needed
<i>3512</i>&nbsp;                result = result.bindArgumentL(pos, value);
<i>3513</i>&nbsp;            }
<i>3514</i>&nbsp;        }
<i>3515</i>&nbsp;        return result;
<i>3516</i>&nbsp;    }
<i>3517</i>&nbsp;
<i>3518</i>&nbsp;    private static BoundMethodHandle insertArgumentPrimitive(BoundMethodHandle result, int pos,
<i>3519</i>&nbsp;                                                             Class&lt;?&gt; ptype, Object value) {
<i>3520</i>&nbsp;        Wrapper w = Wrapper.forPrimitiveType(ptype);
<i>3521</i>&nbsp;        // perform unboxing and/or primitive conversion
<i>3522</i>&nbsp;        value = w.convert(value, ptype);
<i>3523</i>&nbsp;        switch (w) {
<i>3524</i>&nbsp;        case INT:     return result.bindArgumentI(pos, (int)value);
<i>3525</i>&nbsp;        case LONG:    return result.bindArgumentJ(pos, (long)value);
<i>3526</i>&nbsp;        case FLOAT:   return result.bindArgumentF(pos, (float)value);
<i>3527</i>&nbsp;        case DOUBLE:  return result.bindArgumentD(pos, (double)value);
<i>3528</i>&nbsp;        default:      return result.bindArgumentI(pos, ValueConversions.widenSubword(value));
<i>3529</i>&nbsp;        }
<i>3530</i>&nbsp;    }
<i>3531</i>&nbsp;
<i>3532</i>&nbsp;    private static Class&lt;?&gt;[] insertArgumentsChecks(MethodHandle target, int insCount, int pos) throws RuntimeException {
<i>3533</i>&nbsp;        MethodType oldType = target.type();
<i>3534</i>&nbsp;        int outargs = oldType.parameterCount();
<i>3535</i>&nbsp;        int inargs  = outargs - insCount;
<i>3536</i>&nbsp;        if (inargs &lt; 0)
<i>3537</i>&nbsp;            throw newIllegalArgumentException(&quot;too many values to insert&quot;);
<i>3538</i>&nbsp;        if (pos &lt; 0 || pos &gt; inargs)
<i>3539</i>&nbsp;            throw newIllegalArgumentException(&quot;no argument type to append&quot;);
<i>3540</i>&nbsp;        return oldType.ptypes();
<i>3541</i>&nbsp;    }
<i>3542</i>&nbsp;
<i>3543</i>&nbsp;    /**
<i>3544</i>&nbsp;     * Produces a method handle which will discard some dummy arguments
<i>3545</i>&nbsp;     * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
<i>3546</i>&nbsp;     * The type of the new method handle will be the same as the target&#39;s type,
<i>3547</i>&nbsp;     * except it will also include the dummy argument types,
<i>3548</i>&nbsp;     * at some given position.
<i>3549</i>&nbsp;     * &lt;p&gt;
<i>3550</i>&nbsp;     * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
<i>3551</i>&nbsp;     * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
<i>3552</i>&nbsp;     * If {@code pos} is zero, the dummy arguments will precede
<i>3553</i>&nbsp;     * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
<i>3554</i>&nbsp;     * they will come after.
<i>3555</i>&nbsp;     * &lt;p&gt;
<i>3556</i>&nbsp;     * &lt;b&gt;Example:&lt;/b&gt;
<i>3557</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3558</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3559</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3560</i>&nbsp;...
<i>3561</i>&nbsp;MethodHandle cat = lookup().findVirtual(String.class,
<i>3562</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));
<i>3563</i>&nbsp;assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
<i>3564</i>&nbsp;MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
<i>3565</i>&nbsp;MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
<i>3566</i>&nbsp;assertEquals(bigType, d0.type());
<i>3567</i>&nbsp;assertEquals(&quot;yz&quot;, (String) d0.invokeExact(123, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
<i>3568</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3569</i>&nbsp;     * &lt;p&gt;
<i>3570</i>&nbsp;     * This method is also equivalent to the following code:
<i>3571</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>3572</i>&nbsp;     * {@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
<i>3573</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>3574</i>&nbsp;     * @param target the method handle to invoke after the arguments are dropped
<i>3575</i>&nbsp;     * @param valueTypes the type(s) of the argument(s) to drop
<i>3576</i>&nbsp;     * @param pos position of first argument to drop (zero for the leftmost)
<i>3577</i>&nbsp;     * @return a method handle which drops arguments of the given types,
<i>3578</i>&nbsp;     *         before calling the original method handle
<i>3579</i>&nbsp;     * @throws NullPointerException if the target is null,
<i>3580</i>&nbsp;     *                              or if the {@code valueTypes} list or any of its elements is null
<i>3581</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
<i>3582</i>&nbsp;     *                  or if {@code pos} is negative or greater than the arity of the target,
<i>3583</i>&nbsp;     *                  or if the new method handle&#39;s type would have too many parameters
<i>3584</i>&nbsp;     */
<i>3585</i>&nbsp;    public static
<i>3586</i>&nbsp;    MethodHandle dropArguments(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
<i>3587</i>&nbsp;        return dropArguments0(target, pos, copyTypes(valueTypes.toArray()));
<i>3588</i>&nbsp;    }
<i>3589</i>&nbsp;
<i>3590</i>&nbsp;    private static List&lt;Class&lt;?&gt;&gt; copyTypes(Object[] array) {
<i>3591</i>&nbsp;        return Arrays.asList(Arrays.copyOf(array, array.length, Class[].class));
<i>3592</i>&nbsp;    }
<i>3593</i>&nbsp;
<i>3594</i>&nbsp;    private static
<i>3595</i>&nbsp;    MethodHandle dropArguments0(MethodHandle target, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
<i>3596</i>&nbsp;        MethodType oldType = target.type();  // get NPE
<i>3597</i>&nbsp;        int dropped = dropArgumentChecks(oldType, pos, valueTypes);
<i>3598</i>&nbsp;        MethodType newType = oldType.insertParameterTypes(pos, valueTypes);
<i>3599</i>&nbsp;        if (dropped == 0)  return target;
<i>3600</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>3601</i>&nbsp;        LambdaForm lform = result.form;
<i>3602</i>&nbsp;        int insertFormArg = 1 + pos;
<i>3603</i>&nbsp;        for (Class&lt;?&gt; ptype : valueTypes) {
<i>3604</i>&nbsp;            lform = lform.editor().addArgumentForm(insertFormArg++, BasicType.basicType(ptype));
<i>3605</i>&nbsp;        }
<i>3606</i>&nbsp;        result = result.copyWith(newType, lform);
<i>3607</i>&nbsp;        return result;
<i>3608</i>&nbsp;    }
<i>3609</i>&nbsp;
<i>3610</i>&nbsp;    private static int dropArgumentChecks(MethodType oldType, int pos, List&lt;Class&lt;?&gt;&gt; valueTypes) {
<i>3611</i>&nbsp;        int dropped = valueTypes.size();
<i>3612</i>&nbsp;        MethodType.checkSlotCount(dropped);
<i>3613</i>&nbsp;        int outargs = oldType.parameterCount();
<i>3614</i>&nbsp;        int inargs  = outargs + dropped;
<i>3615</i>&nbsp;        if (pos &lt; 0 || pos &gt; outargs)
<i>3616</i>&nbsp;            throw newIllegalArgumentException(&quot;no argument type to remove&quot;
<i>3617</i>&nbsp;                    + Arrays.asList(oldType, pos, valueTypes, inargs, outargs)
<i>3618</i>&nbsp;                    );
<i>3619</i>&nbsp;        return dropped;
<i>3620</i>&nbsp;    }
<i>3621</i>&nbsp;
<i>3622</i>&nbsp;    /**
<i>3623</i>&nbsp;     * Produces a method handle which will discard some dummy arguments
<i>3624</i>&nbsp;     * before calling some other specified &lt;i&gt;target&lt;/i&gt; method handle.
<i>3625</i>&nbsp;     * The type of the new method handle will be the same as the target&#39;s type,
<i>3626</i>&nbsp;     * except it will also include the dummy argument types,
<i>3627</i>&nbsp;     * at some given position.
<i>3628</i>&nbsp;     * &lt;p&gt;
<i>3629</i>&nbsp;     * The {@code pos} argument may range between zero and &lt;i&gt;N&lt;/i&gt;,
<i>3630</i>&nbsp;     * where &lt;i&gt;N&lt;/i&gt; is the arity of the target.
<i>3631</i>&nbsp;     * If {@code pos} is zero, the dummy arguments will precede
<i>3632</i>&nbsp;     * the target&#39;s real arguments; if {@code pos} is &lt;i&gt;N&lt;/i&gt;
<i>3633</i>&nbsp;     * they will come after.
<i>3634</i>&nbsp;     * @apiNote
<i>3635</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3636</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3637</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3638</i>&nbsp;...
<i>3639</i>&nbsp;MethodHandle cat = lookup().findVirtual(String.class,
<i>3640</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));
<i>3641</i>&nbsp;assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
<i>3642</i>&nbsp;MethodHandle d0 = dropArguments(cat, 0, String.class);
<i>3643</i>&nbsp;assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
<i>3644</i>&nbsp;MethodHandle d1 = dropArguments(cat, 1, String.class);
<i>3645</i>&nbsp;assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
<i>3646</i>&nbsp;MethodHandle d2 = dropArguments(cat, 2, String.class);
<i>3647</i>&nbsp;assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;));
<i>3648</i>&nbsp;MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
<i>3649</i>&nbsp;assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));
<i>3650</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3651</i>&nbsp;     * &lt;p&gt;
<i>3652</i>&nbsp;     * This method is also equivalent to the following code:
<i>3653</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>3654</i>&nbsp;     * {@link #dropArguments(MethodHandle,int,List) dropArguments}{@code (target, pos, Arrays.asList(valueTypes))}
<i>3655</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>3656</i>&nbsp;     * @param target the method handle to invoke after the arguments are dropped
<i>3657</i>&nbsp;     * @param valueTypes the type(s) of the argument(s) to drop
<i>3658</i>&nbsp;     * @param pos position of first argument to drop (zero for the leftmost)
<i>3659</i>&nbsp;     * @return a method handle which drops arguments of the given types,
<i>3660</i>&nbsp;     *         before calling the original method handle
<i>3661</i>&nbsp;     * @throws NullPointerException if the target is null,
<i>3662</i>&nbsp;     *                              or if the {@code valueTypes} array or any of its elements is null
<i>3663</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code valueTypes} is {@code void.class},
<i>3664</i>&nbsp;     *                  or if {@code pos} is negative or greater than the arity of the target,
<i>3665</i>&nbsp;     *                  or if the new method handle&#39;s type would have
<i>3666</i>&nbsp;     *                  &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>3667</i>&nbsp;     */
<i>3668</i>&nbsp;    public static
<i>3669</i>&nbsp;    MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes) {
<i>3670</i>&nbsp;        return dropArguments0(target, pos, copyTypes(valueTypes));
<i>3671</i>&nbsp;    }
<i>3672</i>&nbsp;
<i>3673</i>&nbsp;    // private version which allows caller some freedom with error handling
<i>3674</i>&nbsp;    private static MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos,
<i>3675</i>&nbsp;                                      boolean nullOnFailure) {
<i>3676</i>&nbsp;        newTypes = copyTypes(newTypes.toArray());
<i>3677</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; oldTypes = target.type().parameterList();
<i>3678</i>&nbsp;        int match = oldTypes.size();
<i>3679</i>&nbsp;        if (skip != 0) {
<i>3680</i>&nbsp;            if (skip &lt; 0 || skip &gt; match) {
<i>3681</i>&nbsp;                throw newIllegalArgumentException(&quot;illegal skip&quot;, skip, target);
<i>3682</i>&nbsp;            }
<i>3683</i>&nbsp;            oldTypes = oldTypes.subList(skip, match);
<i>3684</i>&nbsp;            match -= skip;
<i>3685</i>&nbsp;        }
<i>3686</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; addTypes = newTypes;
<i>3687</i>&nbsp;        int add = addTypes.size();
<i>3688</i>&nbsp;        if (pos != 0) {
<i>3689</i>&nbsp;            if (pos &lt; 0 || pos &gt; add) {
<i>3690</i>&nbsp;                throw newIllegalArgumentException(&quot;illegal pos&quot;, pos, newTypes);
<i>3691</i>&nbsp;            }
<i>3692</i>&nbsp;            addTypes = addTypes.subList(pos, add);
<i>3693</i>&nbsp;            add -= pos;
<i>3694</i>&nbsp;            assert(addTypes.size() == add);
<i>3695</i>&nbsp;        }
<i>3696</i>&nbsp;        // Do not add types which already match the existing arguments.
<i>3697</i>&nbsp;        if (match &gt; add || !oldTypes.equals(addTypes.subList(0, match))) {
<i>3698</i>&nbsp;            if (nullOnFailure) {
<i>3699</i>&nbsp;                return null;
<i>3700</i>&nbsp;            }
<i>3701</i>&nbsp;            throw newIllegalArgumentException(&quot;argument lists do not match&quot;, oldTypes, newTypes);
<i>3702</i>&nbsp;        }
<i>3703</i>&nbsp;        addTypes = addTypes.subList(match, add);
<i>3704</i>&nbsp;        add -= match;
<i>3705</i>&nbsp;        assert(addTypes.size() == add);
<i>3706</i>&nbsp;        // newTypes:     (   P*[pos], M*[match], A*[add] )
<i>3707</i>&nbsp;        // target: ( S*[skip],        M*[match]  )
<i>3708</i>&nbsp;        MethodHandle adapter = target;
<i>3709</i>&nbsp;        if (add &gt; 0) {
<i>3710</i>&nbsp;            adapter = dropArguments0(adapter, skip+ match, addTypes);
<i>3711</i>&nbsp;        }
<i>3712</i>&nbsp;        // adapter: (S*[skip],        M*[match], A*[add] )
<i>3713</i>&nbsp;        if (pos &gt; 0) {
<i>3714</i>&nbsp;            adapter = dropArguments0(adapter, skip, newTypes.subList(0, pos));
<i>3715</i>&nbsp;        }
<i>3716</i>&nbsp;        // adapter: (S*[skip], P*[pos], M*[match], A*[add] )
<i>3717</i>&nbsp;        return adapter;
<i>3718</i>&nbsp;    }
<i>3719</i>&nbsp;
<i>3720</i>&nbsp;    /**
<i>3721</i>&nbsp;     * Adapts a target method handle to match the given parameter type list. If necessary, adds dummy arguments. Some
<i>3722</i>&nbsp;     * leading parameters can be skipped before matching begins. The remaining types in the {@code target}&#39;s parameter
<i>3723</i>&nbsp;     * type list must be a sub-list of the {@code newTypes} type list at the starting position {@code pos}. The
<i>3724</i>&nbsp;     * resulting handle will have the target handle&#39;s parameter type list, with any non-matching parameter types (before
<i>3725</i>&nbsp;     * or after the matching sub-list) inserted in corresponding positions of the target&#39;s original parameters, as if by
<i>3726</i>&nbsp;     * {@link #dropArguments(MethodHandle, int, Class[])}.
<i>3727</i>&nbsp;     * &lt;p&gt;
<i>3728</i>&nbsp;     * The resulting handle will have the same return type as the target handle.
<i>3729</i>&nbsp;     * &lt;p&gt;
<i>3730</i>&nbsp;     * In more formal terms, assume these two type lists:&lt;ul&gt;
<i>3731</i>&nbsp;     * &lt;li&gt;The target handle has the parameter type list {@code S..., M...}, with as many types in {@code S} as
<i>3732</i>&nbsp;     * indicated by {@code skip}. The {@code M} types are those that are supposed to match part of the given type list,
<i>3733</i>&nbsp;     * {@code newTypes}.
<i>3734</i>&nbsp;     * &lt;li&gt;The {@code newTypes} list contains types {@code P..., M..., A...}, with as many types in {@code P} as
<i>3735</i>&nbsp;     * indicated by {@code pos}. The {@code M} types are precisely those that the {@code M} types in the target handle&#39;s
<i>3736</i>&nbsp;     * parameter type list are supposed to match. The types in {@code A} are additional types found after the matching
<i>3737</i>&nbsp;     * sub-list.
<i>3738</i>&nbsp;     * &lt;/ul&gt;
<i>3739</i>&nbsp;     * Given these assumptions, the result of an invocation of {@code dropArgumentsToMatch} will have the parameter type
<i>3740</i>&nbsp;     * list {@code S..., P..., M..., A...}, with the {@code P} and {@code A} types inserted as if by
<i>3741</i>&nbsp;     * {@link #dropArguments(MethodHandle, int, Class[])}.
<i>3742</i>&nbsp;     *
<i>3743</i>&nbsp;     * @apiNote
<i>3744</i>&nbsp;     * Two method handles whose argument lists are &quot;effectively identical&quot; (i.e., identical in a common prefix) may be
<i>3745</i>&nbsp;     * mutually converted to a common type by two calls to {@code dropArgumentsToMatch}, as follows:
<i>3746</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3747</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3748</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3749</i>&nbsp;...
<i>3750</i>&nbsp;...
<i>3751</i>&nbsp;MethodHandle h0 = constant(boolean.class, true);
<i>3752</i>&nbsp;MethodHandle h1 = lookup().findVirtual(String.class, &quot;concat&quot;, methodType(String.class, String.class));
<i>3753</i>&nbsp;MethodType bigType = h1.type().insertParameterTypes(1, String.class, int.class);
<i>3754</i>&nbsp;MethodHandle h2 = dropArguments(h1, 0, bigType.parameterList());
<i>3755</i>&nbsp;if (h1.type().parameterCount() &lt; h2.type().parameterCount())
<i>3756</i>&nbsp;    h1 = dropArgumentsToMatch(h1, 0, h2.type().parameterList(), 0);  // lengthen h1
<i>3757</i>&nbsp;else
<i>3758</i>&nbsp;    h2 = dropArgumentsToMatch(h2, 0, h1.type().parameterList(), 0);    // lengthen h2
<i>3759</i>&nbsp;MethodHandle h3 = guardWithTest(h0, h1, h2);
<i>3760</i>&nbsp;assertEquals(&quot;xy&quot;, h3.invoke(&quot;x&quot;, &quot;y&quot;, 1, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;));
<i>3761</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3762</i>&nbsp;     * @param target the method handle to adapt
<i>3763</i>&nbsp;     * @param skip number of targets parameters to disregard (they will be unchanged)
<i>3764</i>&nbsp;     * @param newTypes the list of types to match {@code target}&#39;s parameter type list to
<i>3765</i>&nbsp;     * @param pos place in {@code newTypes} where the non-skipped target parameters must occur
<i>3766</i>&nbsp;     * @return a possibly adapted method handle
<i>3767</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>3768</i>&nbsp;     * @throws IllegalArgumentException if any element of {@code newTypes} is {@code void.class},
<i>3769</i>&nbsp;     *         or if {@code skip} is negative or greater than the arity of the target,
<i>3770</i>&nbsp;     *         or if {@code pos} is negative or greater than the newTypes list size,
<i>3771</i>&nbsp;     *         or if {@code newTypes} does not contain the {@code target}&#39;s non-skipped parameter types at position
<i>3772</i>&nbsp;     *         {@code pos}.
<i>3773</i>&nbsp;     * @since 9
<i>3774</i>&nbsp;     */
<i>3775</i>&nbsp;    public static
<i>3776</i>&nbsp;    MethodHandle dropArgumentsToMatch(MethodHandle target, int skip, List&lt;Class&lt;?&gt;&gt; newTypes, int pos) {
<i>3777</i>&nbsp;        Objects.requireNonNull(target);
<i>3778</i>&nbsp;        Objects.requireNonNull(newTypes);
<i>3779</i>&nbsp;        return dropArgumentsToMatch(target, skip, newTypes, pos, false);
<i>3780</i>&nbsp;    }
<i>3781</i>&nbsp;
<i>3782</i>&nbsp;    /**
<i>3783</i>&nbsp;     * Adapts a target method handle by pre-processing
<i>3784</i>&nbsp;     * one or more of its arguments, each with its own unary filter function,
<i>3785</i>&nbsp;     * and then calling the target with each pre-processed argument
<i>3786</i>&nbsp;     * replaced by the result of its corresponding filter function.
<i>3787</i>&nbsp;     * &lt;p&gt;
<i>3788</i>&nbsp;     * The pre-processing is performed by one or more method handles,
<i>3789</i>&nbsp;     * specified in the elements of the {@code filters} array.
<i>3790</i>&nbsp;     * The first element of the filter array corresponds to the {@code pos}
<i>3791</i>&nbsp;     * argument of the target, and so on in sequence.
<i>3792</i>&nbsp;     * The filter functions are invoked in left to right order.
<i>3793</i>&nbsp;     * &lt;p&gt;
<i>3794</i>&nbsp;     * Null arguments in the array are treated as identity functions,
<i>3795</i>&nbsp;     * and the corresponding arguments left unchanged.
<i>3796</i>&nbsp;     * (If there are no non-null elements in the array, the original target is returned.)
<i>3797</i>&nbsp;     * Each filter is applied to the corresponding argument of the adapter.
<i>3798</i>&nbsp;     * &lt;p&gt;
<i>3799</i>&nbsp;     * If a filter {@code F} applies to the {@code N}th argument of
<i>3800</i>&nbsp;     * the target, then {@code F} must be a method handle which
<i>3801</i>&nbsp;     * takes exactly one argument.  The type of {@code F}&#39;s sole argument
<i>3802</i>&nbsp;     * replaces the corresponding argument type of the target
<i>3803</i>&nbsp;     * in the resulting adapted method handle.
<i>3804</i>&nbsp;     * The return type of {@code F} must be identical to the corresponding
<i>3805</i>&nbsp;     * parameter type of the target.
<i>3806</i>&nbsp;     * &lt;p&gt;
<i>3807</i>&nbsp;     * It is an error if there are elements of {@code filters}
<i>3808</i>&nbsp;     * (null or not)
<i>3809</i>&nbsp;     * which do not correspond to argument positions in the target.
<i>3810</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<i>3811</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3812</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3813</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3814</i>&nbsp;...
<i>3815</i>&nbsp;MethodHandle cat = lookup().findVirtual(String.class,
<i>3816</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));
<i>3817</i>&nbsp;MethodHandle upcase = lookup().findVirtual(String.class,
<i>3818</i>&nbsp;  &quot;toUpperCase&quot;, methodType(String.class));
<i>3819</i>&nbsp;assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));
<i>3820</i>&nbsp;MethodHandle f0 = filterArguments(cat, 0, upcase);
<i>3821</i>&nbsp;assertEquals(&quot;Xy&quot;, (String) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // Xy
<i>3822</i>&nbsp;MethodHandle f1 = filterArguments(cat, 1, upcase);
<i>3823</i>&nbsp;assertEquals(&quot;xY&quot;, (String) f1.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xY
<i>3824</i>&nbsp;MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
<i>3825</i>&nbsp;assertEquals(&quot;XY&quot;, (String) f2.invokeExact(&quot;x&quot;, &quot;y&quot;)); // XY
<i>3826</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3827</i>&nbsp;     * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>3828</i>&nbsp;     * denotes the return type of both the {@code target} and resulting adapter.
<i>3829</i>&nbsp;     * {@code P}/{@code p} and {@code B}/{@code b} represent the types and values
<i>3830</i>&nbsp;     * of the parameters and arguments that precede and follow the filter position
<i>3831</i>&nbsp;     * {@code pos}, respectively. {@code A[i]}/{@code a[i]} stand for the types and
<i>3832</i>&nbsp;     * values of the filtered parameters and arguments; they also represent the
<i>3833</i>&nbsp;     * return types of the {@code filter[i]} handles. The latter accept arguments
<i>3834</i>&nbsp;     * {@code v[i]} of type {@code V[i]}, which also appear in the signature of
<i>3835</i>&nbsp;     * the resulting adapter.
<i>3836</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3837</i>&nbsp;     * T target(P... p, A[i]... a[i], B... b);
<i>3838</i>&nbsp;     * A[i] filter[i](V[i]);
<i>3839</i>&nbsp;     * T adapter(P... p, V[i]... v[i], B... b) {
<i>3840</i>&nbsp;     *   return target(p..., filter[i](v[i])..., b...);
<i>3841</i>&nbsp;     * }
<i>3842</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3843</i>&nbsp;     * &lt;p&gt;
<i>3844</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>3845</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>3846</i>&nbsp;     *
<i>3847</i>&nbsp;     * @param target the method handle to invoke after arguments are filtered
<i>3848</i>&nbsp;     * @param pos the position of the first argument to filter
<i>3849</i>&nbsp;     * @param filters method handles to call initially on filtered arguments
<i>3850</i>&nbsp;     * @return method handle which incorporates the specified argument filtering logic
<i>3851</i>&nbsp;     * @throws NullPointerException if the target is null
<i>3852</i>&nbsp;     *                              or if the {@code filters} array is null
<i>3853</i>&nbsp;     * @throws IllegalArgumentException if a non-null element of {@code filters}
<i>3854</i>&nbsp;     *          does not match a corresponding argument type of target as described above,
<i>3855</i>&nbsp;     *          or if the {@code pos+filters.length} is greater than {@code target.type().parameterCount()},
<i>3856</i>&nbsp;     *          or if the resulting method handle&#39;s type would have
<i>3857</i>&nbsp;     *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>3858</i>&nbsp;     */
<i>3859</i>&nbsp;    public static
<i>3860</i>&nbsp;    MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {
<i>3861</i>&nbsp;        filterArgumentsCheckArity(target, pos, filters);
<i>3862</i>&nbsp;        MethodHandle adapter = target;
<i>3863</i>&nbsp;        // process filters in reverse order so that the invocation of
<i>3864</i>&nbsp;        // the resulting adapter will invoke the filters in left-to-right order
<i>3865</i>&nbsp;        for (int i = filters.length - 1; i &gt;= 0; --i) {
<i>3866</i>&nbsp;            MethodHandle filter = filters[i];
<i>3867</i>&nbsp;            if (filter == null)  continue;  // ignore null elements of filters
<i>3868</i>&nbsp;            adapter = filterArgument(adapter, pos + i, filter);
<i>3869</i>&nbsp;        }
<i>3870</i>&nbsp;        return adapter;
<i>3871</i>&nbsp;    }
<i>3872</i>&nbsp;
<i>3873</i>&nbsp;    /*non-public*/ static
<i>3874</i>&nbsp;    MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle filter) {
<i>3875</i>&nbsp;        filterArgumentChecks(target, pos, filter);
<i>3876</i>&nbsp;        MethodType targetType = target.type();
<i>3877</i>&nbsp;        MethodType filterType = filter.type();
<i>3878</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>3879</i>&nbsp;        Class&lt;?&gt; newParamType = filterType.parameterType(0);
<i>3880</i>&nbsp;        LambdaForm lform = result.editor().filterArgumentForm(1 + pos, BasicType.basicType(newParamType));
<i>3881</i>&nbsp;        MethodType newType = targetType.changeParameterType(pos, newParamType);
<i>3882</i>&nbsp;        result = result.copyWithExtendL(newType, lform, filter);
<i>3883</i>&nbsp;        return result;
<i>3884</i>&nbsp;    }
<i>3885</i>&nbsp;
<i>3886</i>&nbsp;    private static void filterArgumentsCheckArity(MethodHandle target, int pos, MethodHandle[] filters) {
<i>3887</i>&nbsp;        MethodType targetType = target.type();
<i>3888</i>&nbsp;        int maxPos = targetType.parameterCount();
<i>3889</i>&nbsp;        if (pos + filters.length &gt; maxPos)
<i>3890</i>&nbsp;            throw newIllegalArgumentException(&quot;too many filters&quot;);
<i>3891</i>&nbsp;    }
<i>3892</i>&nbsp;
<i>3893</i>&nbsp;    private static void filterArgumentChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
<i>3894</i>&nbsp;        MethodType targetType = target.type();
<i>3895</i>&nbsp;        MethodType filterType = filter.type();
<i>3896</i>&nbsp;        if (filterType.parameterCount() != 1
<i>3897</i>&nbsp;            || filterType.returnType() != targetType.parameterType(pos))
<i>3898</i>&nbsp;            throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
<i>3899</i>&nbsp;    }
<i>3900</i>&nbsp;
<i>3901</i>&nbsp;    /**
<i>3902</i>&nbsp;     * Adapts a target method handle by pre-processing
<i>3903</i>&nbsp;     * a sub-sequence of its arguments with a filter (another method handle).
<i>3904</i>&nbsp;     * The pre-processed arguments are replaced by the result (if any) of the
<i>3905</i>&nbsp;     * filter function.
<i>3906</i>&nbsp;     * The target is then called on the modified (usually shortened) argument list.
<i>3907</i>&nbsp;     * &lt;p&gt;
<i>3908</i>&nbsp;     * If the filter returns a value, the target must accept that value as
<i>3909</i>&nbsp;     * its argument in position {@code pos}, preceded and/or followed by
<i>3910</i>&nbsp;     * any arguments not passed to the filter.
<i>3911</i>&nbsp;     * If the filter returns void, the target must accept all arguments
<i>3912</i>&nbsp;     * not passed to the filter.
<i>3913</i>&nbsp;     * No arguments are reordered, and a result returned from the filter
<i>3914</i>&nbsp;     * replaces (in order) the whole subsequence of arguments originally
<i>3915</i>&nbsp;     * passed to the adapter.
<i>3916</i>&nbsp;     * &lt;p&gt;
<i>3917</i>&nbsp;     * The argument types (if any) of the filter
<i>3918</i>&nbsp;     * replace zero or one argument types of the target, at position {@code pos},
<i>3919</i>&nbsp;     * in the resulting adapted method handle.
<i>3920</i>&nbsp;     * The return type of the filter (if any) must be identical to the
<i>3921</i>&nbsp;     * argument type of the target at position {@code pos}, and that target argument
<i>3922</i>&nbsp;     * is supplied by the return value of the filter.
<i>3923</i>&nbsp;     * &lt;p&gt;
<i>3924</i>&nbsp;     * In all cases, {@code pos} must be greater than or equal to zero, and
<i>3925</i>&nbsp;     * {@code pos} must also be less than or equal to the target&#39;s arity.
<i>3926</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<i>3927</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3928</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>3929</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>3930</i>&nbsp;...
<i>3931</i>&nbsp;MethodHandle deepToString = publicLookup()
<i>3932</i>&nbsp;  .findStatic(Arrays.class, &quot;deepToString&quot;, methodType(String.class, Object[].class));
<i>3933</i>&nbsp;
<i>3934</i>&nbsp;MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
<i>3935</i>&nbsp;assertEquals(&quot;[strange]&quot;, (String) ts1.invokeExact(&quot;strange&quot;));
<i>3936</i>&nbsp;
<i>3937</i>&nbsp;MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
<i>3938</i>&nbsp;assertEquals(&quot;[up, down]&quot;, (String) ts2.invokeExact(&quot;up&quot;, &quot;down&quot;));
<i>3939</i>&nbsp;
<i>3940</i>&nbsp;MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
<i>3941</i>&nbsp;MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
<i>3942</i>&nbsp;assertEquals(&quot;[top, [up, down], strange]&quot;,
<i>3943</i>&nbsp;             (String) ts3_ts2.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
<i>3944</i>&nbsp;
<i>3945</i>&nbsp;MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
<i>3946</i>&nbsp;assertEquals(&quot;[top, [up, down], [strange]]&quot;,
<i>3947</i>&nbsp;             (String) ts3_ts2_ts1.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;));
<i>3948</i>&nbsp;
<i>3949</i>&nbsp;MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
<i>3950</i>&nbsp;assertEquals(&quot;[top, [[up, down, strange], charm], bottom]&quot;,
<i>3951</i>&nbsp;             (String) ts3_ts2_ts3.invokeExact(&quot;top&quot;, &quot;up&quot;, &quot;down&quot;, &quot;strange&quot;, &quot;charm&quot;, &quot;bottom&quot;));
<i>3952</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3953</i>&nbsp;     * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>3954</i>&nbsp;     * represents the return type of the {@code target} and resulting adapter.
<i>3955</i>&nbsp;     * {@code V}/{@code v} stand for the return type and value of the
<i>3956</i>&nbsp;     * {@code filter}, which are also found in the signature and arguments of
<i>3957</i>&nbsp;     * the {@code target}, respectively, unless {@code V} is {@code void}.
<i>3958</i>&nbsp;     * {@code A}/{@code a} and {@code C}/{@code c} represent the parameter types
<i>3959</i>&nbsp;     * and values preceding and following the collection position, {@code pos},
<i>3960</i>&nbsp;     * in the {@code target}&#39;s signature. They also turn up in the resulting
<i>3961</i>&nbsp;     * adapter&#39;s signature and arguments, where they surround
<i>3962</i>&nbsp;     * {@code B}/{@code b}, which represent the parameter types and arguments
<i>3963</i>&nbsp;     * to the {@code filter} (if any).
<i>3964</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3965</i>&nbsp;     * T target(A...,V,C...);
<i>3966</i>&nbsp;     * V filter(B...);
<i>3967</i>&nbsp;     * T adapter(A... a,B... b,C... c) {
<i>3968</i>&nbsp;     *   V v = filter(b...);
<i>3969</i>&nbsp;     *   return target(a...,v,c...);
<i>3970</i>&nbsp;     * }
<i>3971</i>&nbsp;     * // and if the filter has no arguments:
<i>3972</i>&nbsp;     * T target2(A...,V,C...);
<i>3973</i>&nbsp;     * V filter2();
<i>3974</i>&nbsp;     * T adapter2(A... a,C... c) {
<i>3975</i>&nbsp;     *   V v = filter2();
<i>3976</i>&nbsp;     *   return target2(a...,v,c...);
<i>3977</i>&nbsp;     * }
<i>3978</i>&nbsp;     * // and if the filter has a void return:
<i>3979</i>&nbsp;     * T target3(A...,C...);
<i>3980</i>&nbsp;     * void filter3(B...);
<i>3981</i>&nbsp;     * T adapter3(A... a,B... b,C... c) {
<i>3982</i>&nbsp;     *   filter3(b...);
<i>3983</i>&nbsp;     *   return target3(a...,c...);
<i>3984</i>&nbsp;     * }
<i>3985</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3986</i>&nbsp;     * &lt;p&gt;
<i>3987</i>&nbsp;     * A collection adapter {@code collectArguments(mh, 0, coll)} is equivalent to
<i>3988</i>&nbsp;     * one which first &quot;folds&quot; the affected arguments, and then drops them, in separate
<i>3989</i>&nbsp;     * steps as follows:
<i>3990</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>3991</i>&nbsp;     * mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
<i>3992</i>&nbsp;     * mh = MethodHandles.foldArguments(mh, coll); //step 1
<i>3993</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>3994</i>&nbsp;     * If the target method handle consumes no arguments besides than the result
<i>3995</i>&nbsp;     * (if any) of the filter {@code coll}, then {@code collectArguments(mh, 0, coll)}
<i>3996</i>&nbsp;     * is equivalent to {@code filterReturnValue(coll, mh)}.
<i>3997</i>&nbsp;     * If the filter method handle {@code coll} consumes one argument and produces
<i>3998</i>&nbsp;     * a non-void result, then {@code collectArguments(mh, N, coll)}
<i>3999</i>&nbsp;     * is equivalent to {@code filterArguments(mh, N, coll)}.
<i>4000</i>&nbsp;     * Other equivalences are possible but would require argument permutation.
<i>4001</i>&nbsp;     * &lt;p&gt;
<i>4002</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>4003</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>4004</i>&nbsp;     *
<i>4005</i>&nbsp;     * @param target the method handle to invoke after filtering the subsequence of arguments
<i>4006</i>&nbsp;     * @param pos the position of the first adapter argument to pass to the filter,
<i>4007</i>&nbsp;     *            and/or the target argument which receives the result of the filter
<i>4008</i>&nbsp;     * @param filter method handle to call on the subsequence of arguments
<i>4009</i>&nbsp;     * @return method handle which incorporates the specified argument subsequence filtering logic
<i>4010</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>4011</i>&nbsp;     * @throws IllegalArgumentException if the return type of {@code filter}
<i>4012</i>&nbsp;     *          is non-void and is not the same as the {@code pos} argument of the target,
<i>4013</i>&nbsp;     *          or if {@code pos} is not between 0 and the target&#39;s arity, inclusive,
<i>4014</i>&nbsp;     *          or if the resulting method handle&#39;s type would have
<i>4015</i>&nbsp;     *          &lt;a href=&quot;MethodHandle.html#maxarity&quot;&gt;too many parameters&lt;/a&gt;
<i>4016</i>&nbsp;     * @see MethodHandles#foldArguments
<i>4017</i>&nbsp;     * @see MethodHandles#filterArguments
<i>4018</i>&nbsp;     * @see MethodHandles#filterReturnValue
<i>4019</i>&nbsp;     */
<i>4020</i>&nbsp;    public static
<i>4021</i>&nbsp;    MethodHandle collectArguments(MethodHandle target, int pos, MethodHandle filter) {
<i>4022</i>&nbsp;        MethodType newType = collectArgumentsChecks(target, pos, filter);
<i>4023</i>&nbsp;        MethodType collectorType = filter.type();
<i>4024</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>4025</i>&nbsp;        LambdaForm lform;
<i>4026</i>&nbsp;        if (collectorType.returnType().isArray() &amp;&amp; filter.intrinsicName() == Intrinsic.NEW_ARRAY) {
<i>4027</i>&nbsp;            lform = result.editor().collectArgumentArrayForm(1 + pos, filter);
<i>4028</i>&nbsp;            if (lform != null) {
<i>4029</i>&nbsp;                return result.copyWith(newType, lform);
<i>4030</i>&nbsp;            }
<i>4031</i>&nbsp;        }
<i>4032</i>&nbsp;        lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());
<i>4033</i>&nbsp;        return result.copyWithExtendL(newType, lform, filter);
<i>4034</i>&nbsp;    }
<i>4035</i>&nbsp;
<i>4036</i>&nbsp;    private static MethodType collectArgumentsChecks(MethodHandle target, int pos, MethodHandle filter) throws RuntimeException {
<i>4037</i>&nbsp;        MethodType targetType = target.type();
<i>4038</i>&nbsp;        MethodType filterType = filter.type();
<i>4039</i>&nbsp;        Class&lt;?&gt; rtype = filterType.returnType();
<i>4040</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; filterArgs = filterType.parameterList();
<i>4041</i>&nbsp;        if (rtype == void.class) {
<i>4042</i>&nbsp;            return targetType.insertParameterTypes(pos, filterArgs);
<i>4043</i>&nbsp;        }
<i>4044</i>&nbsp;        if (rtype != targetType.parameterType(pos)) {
<i>4045</i>&nbsp;            throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
<i>4046</i>&nbsp;        }
<i>4047</i>&nbsp;        return targetType.dropParameterTypes(pos, pos+1).insertParameterTypes(pos, filterArgs);
<i>4048</i>&nbsp;    }
<i>4049</i>&nbsp;
<i>4050</i>&nbsp;    /**
<i>4051</i>&nbsp;     * Adapts a target method handle by post-processing
<i>4052</i>&nbsp;     * its return value (if any) with a filter (another method handle).
<i>4053</i>&nbsp;     * The result of the filter is returned from the adapter.
<i>4054</i>&nbsp;     * &lt;p&gt;
<i>4055</i>&nbsp;     * If the target returns a value, the filter must accept that value as
<i>4056</i>&nbsp;     * its only argument.
<i>4057</i>&nbsp;     * If the target returns void, the filter must accept no arguments.
<i>4058</i>&nbsp;     * &lt;p&gt;
<i>4059</i>&nbsp;     * The return type of the filter
<i>4060</i>&nbsp;     * replaces the return type of the target
<i>4061</i>&nbsp;     * in the resulting adapted method handle.
<i>4062</i>&nbsp;     * The argument type of the filter (if any) must be identical to the
<i>4063</i>&nbsp;     * return type of the target.
<i>4064</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<i>4065</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4066</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>4067</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>4068</i>&nbsp;...
<i>4069</i>&nbsp;MethodHandle cat = lookup().findVirtual(String.class,
<i>4070</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));
<i>4071</i>&nbsp;MethodHandle length = lookup().findVirtual(String.class,
<i>4072</i>&nbsp;  &quot;length&quot;, methodType(int.class));
<i>4073</i>&nbsp;System.out.println((String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;)); // xy
<i>4074</i>&nbsp;MethodHandle f0 = filterReturnValue(cat, length);
<i>4075</i>&nbsp;System.out.println((int) f0.invokeExact(&quot;x&quot;, &quot;y&quot;)); // 2
<i>4076</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4077</i>&nbsp;     * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code,
<i>4078</i>&nbsp;     * {@code T}/{@code t} represent the result type and value of the
<i>4079</i>&nbsp;     * {@code target}; {@code V}, the result type of the {@code filter}; and
<i>4080</i>&nbsp;     * {@code A}/{@code a}, the types and values of the parameters and arguments
<i>4081</i>&nbsp;     * of the {@code target} as well as the resulting adapter.
<i>4082</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4083</i>&nbsp;     * T target(A...);
<i>4084</i>&nbsp;     * V filter(T);
<i>4085</i>&nbsp;     * V adapter(A... a) {
<i>4086</i>&nbsp;     *   T t = target(a...);
<i>4087</i>&nbsp;     *   return filter(t);
<i>4088</i>&nbsp;     * }
<i>4089</i>&nbsp;     * // and if the target has a void return:
<i>4090</i>&nbsp;     * void target2(A...);
<i>4091</i>&nbsp;     * V filter2();
<i>4092</i>&nbsp;     * V adapter2(A... a) {
<i>4093</i>&nbsp;     *   target2(a...);
<i>4094</i>&nbsp;     *   return filter2();
<i>4095</i>&nbsp;     * }
<i>4096</i>&nbsp;     * // and if the filter has a void return:
<i>4097</i>&nbsp;     * T target3(A...);
<i>4098</i>&nbsp;     * void filter3(V);
<i>4099</i>&nbsp;     * void adapter3(A... a) {
<i>4100</i>&nbsp;     *   T t = target3(a...);
<i>4101</i>&nbsp;     *   filter3(t);
<i>4102</i>&nbsp;     * }
<i>4103</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4104</i>&nbsp;     * &lt;p&gt;
<i>4105</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>4106</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>4107</i>&nbsp;     * @param target the method handle to invoke before filtering the return value
<i>4108</i>&nbsp;     * @param filter method handle to call on the return value
<i>4109</i>&nbsp;     * @return method handle which incorporates the specified return value filtering logic
<i>4110</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>4111</i>&nbsp;     * @throws IllegalArgumentException if the argument list of {@code filter}
<i>4112</i>&nbsp;     *          does not match the return type of target as described above
<i>4113</i>&nbsp;     */
<i>4114</i>&nbsp;    public static
<i>4115</i>&nbsp;    MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {
<i>4116</i>&nbsp;        MethodType targetType = target.type();
<i>4117</i>&nbsp;        MethodType filterType = filter.type();
<i>4118</i>&nbsp;        filterReturnValueChecks(targetType, filterType);
<i>4119</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>4120</i>&nbsp;        BasicType rtype = BasicType.basicType(filterType.returnType());
<i>4121</i>&nbsp;        LambdaForm lform = result.editor().filterReturnForm(rtype, false);
<i>4122</i>&nbsp;        MethodType newType = targetType.changeReturnType(filterType.returnType());
<i>4123</i>&nbsp;        result = result.copyWithExtendL(newType, lform, filter);
<i>4124</i>&nbsp;        return result;
<i>4125</i>&nbsp;    }
<i>4126</i>&nbsp;
<i>4127</i>&nbsp;    private static void filterReturnValueChecks(MethodType targetType, MethodType filterType) throws RuntimeException {
<i>4128</i>&nbsp;        Class&lt;?&gt; rtype = targetType.returnType();
<i>4129</i>&nbsp;        int filterValues = filterType.parameterCount();
<i>4130</i>&nbsp;        if (filterValues == 0
<i>4131</i>&nbsp;                ? (rtype != void.class)
<i>4132</i>&nbsp;                : (rtype != filterType.parameterType(0) || filterValues != 1))
<i>4133</i>&nbsp;            throw newIllegalArgumentException(&quot;target and filter types do not match&quot;, targetType, filterType);
<i>4134</i>&nbsp;    }
<i>4135</i>&nbsp;
<i>4136</i>&nbsp;    /**
<i>4137</i>&nbsp;     * Adapts a target method handle by pre-processing
<i>4138</i>&nbsp;     * some of its arguments, and then calling the target with
<i>4139</i>&nbsp;     * the result of the pre-processing, inserted into the original
<i>4140</i>&nbsp;     * sequence of arguments.
<i>4141</i>&nbsp;     * &lt;p&gt;
<i>4142</i>&nbsp;     * The pre-processing is performed by {@code combiner}, a second method handle.
<i>4143</i>&nbsp;     * Of the arguments passed to the adapter, the first {@code N} arguments
<i>4144</i>&nbsp;     * are copied to the combiner, which is then called.
<i>4145</i>&nbsp;     * (Here, {@code N} is defined as the parameter count of the combiner.)
<i>4146</i>&nbsp;     * After this, control passes to the target, with any result
<i>4147</i>&nbsp;     * from the combiner inserted before the original {@code N} incoming
<i>4148</i>&nbsp;     * arguments.
<i>4149</i>&nbsp;     * &lt;p&gt;
<i>4150</i>&nbsp;     * If the combiner returns a value, the first parameter type of the target
<i>4151</i>&nbsp;     * must be identical with the return type of the combiner, and the next
<i>4152</i>&nbsp;     * {@code N} parameter types of the target must exactly match the parameters
<i>4153</i>&nbsp;     * of the combiner.
<i>4154</i>&nbsp;     * &lt;p&gt;
<i>4155</i>&nbsp;     * If the combiner has a void return, no result will be inserted,
<i>4156</i>&nbsp;     * and the first {@code N} parameter types of the target
<i>4157</i>&nbsp;     * must exactly match the parameters of the combiner.
<i>4158</i>&nbsp;     * &lt;p&gt;
<i>4159</i>&nbsp;     * The resulting adapter is the same type as the target, except that the
<i>4160</i>&nbsp;     * first parameter type is dropped,
<i>4161</i>&nbsp;     * if it corresponds to the result of the combiner.
<i>4162</i>&nbsp;     * &lt;p&gt;
<i>4163</i>&nbsp;     * (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
<i>4164</i>&nbsp;     * that either the combiner or the target does not wish to receive.
<i>4165</i>&nbsp;     * If some of the incoming arguments are destined only for the combiner,
<i>4166</i>&nbsp;     * consider using {@link MethodHandle#asCollector asCollector} instead, since those
<i>4167</i>&nbsp;     * arguments will not need to be live on the stack on entry to the
<i>4168</i>&nbsp;     * target.)
<i>4169</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
<i>4170</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4171</i>&nbsp;import static java.lang.invoke.MethodHandles.*;
<i>4172</i>&nbsp;import static java.lang.invoke.MethodType.*;
<i>4173</i>&nbsp;...
<i>4174</i>&nbsp;MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
<i>4175</i>&nbsp;  &quot;println&quot;, methodType(void.class, String.class))
<i>4176</i>&nbsp;    .bindTo(System.out);
<i>4177</i>&nbsp;MethodHandle cat = lookup().findVirtual(String.class,
<i>4178</i>&nbsp;  &quot;concat&quot;, methodType(String.class, String.class));
<i>4179</i>&nbsp;assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
<i>4180</i>&nbsp;MethodHandle catTrace = foldArguments(cat, trace);
<i>4181</i>&nbsp;// also prints &quot;boo&quot;:
<i>4182</i>&nbsp;assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
<i>4183</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4184</i>&nbsp;     * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>4185</i>&nbsp;     * represents the result type of the {@code target} and resulting adapter.
<i>4186</i>&nbsp;     * {@code V}/{@code v} represent the type and value of the parameter and argument
<i>4187</i>&nbsp;     * of {@code target} that precedes the folding position; {@code V} also is
<i>4188</i>&nbsp;     * the result type of the {@code combiner}. {@code A}/{@code a} denote the
<i>4189</i>&nbsp;     * types and values of the {@code N} parameters and arguments at the folding
<i>4190</i>&nbsp;     * position. {@code B}/{@code b} represent the types and values of the
<i>4191</i>&nbsp;     * {@code target} parameters and arguments that follow the folded parameters
<i>4192</i>&nbsp;     * and arguments.
<i>4193</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4194</i>&nbsp;     * // there are N arguments in A...
<i>4195</i>&nbsp;     * T target(V, A[N]..., B...);
<i>4196</i>&nbsp;     * V combiner(A...);
<i>4197</i>&nbsp;     * T adapter(A... a, B... b) {
<i>4198</i>&nbsp;     *   V v = combiner(a...);
<i>4199</i>&nbsp;     *   return target(v, a..., b...);
<i>4200</i>&nbsp;     * }
<i>4201</i>&nbsp;     * // and if the combiner has a void return:
<i>4202</i>&nbsp;     * T target2(A[N]..., B...);
<i>4203</i>&nbsp;     * void combiner2(A...);
<i>4204</i>&nbsp;     * T adapter2(A... a, B... b) {
<i>4205</i>&nbsp;     *   combiner2(a...);
<i>4206</i>&nbsp;     *   return target2(a..., b...);
<i>4207</i>&nbsp;     * }
<i>4208</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4209</i>&nbsp;     * &lt;p&gt;
<i>4210</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>4211</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>4212</i>&nbsp;     * @param target the method handle to invoke after arguments are combined
<i>4213</i>&nbsp;     * @param combiner method handle to call initially on the incoming arguments
<i>4214</i>&nbsp;     * @return method handle which incorporates the specified argument folding logic
<i>4215</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>4216</i>&nbsp;     * @throws IllegalArgumentException if {@code combiner}&#39;s return type
<i>4217</i>&nbsp;     *          is non-void and not the same as the first argument type of
<i>4218</i>&nbsp;     *          the target, or if the initial {@code N} argument types
<i>4219</i>&nbsp;     *          of the target
<i>4220</i>&nbsp;     *          (skipping one matching the {@code combiner}&#39;s return type)
<i>4221</i>&nbsp;     *          are not identical with the argument types of {@code combiner}
<i>4222</i>&nbsp;     */
<i>4223</i>&nbsp;    public static
<i>4224</i>&nbsp;    MethodHandle foldArguments(MethodHandle target, MethodHandle combiner) {
<i>4225</i>&nbsp;        return foldArguments(target, 0, combiner);
<i>4226</i>&nbsp;    }
<i>4227</i>&nbsp;
<i>4228</i>&nbsp;    /**
<i>4229</i>&nbsp;     * Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
<i>4230</i>&nbsp;     * calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
<i>4231</i>&nbsp;     * before the folded arguments.
<i>4232</i>&nbsp;     * &lt;p&gt;
<i>4233</i>&nbsp;     * This method is closely related to {@link #foldArguments(MethodHandle, MethodHandle)}, but allows to control the
<i>4234</i>&nbsp;     * position in the parameter list at which folding takes place. The argument controlling this, {@code pos}, is a
<i>4235</i>&nbsp;     * zero-based index. The aforementioned method {@link #foldArguments(MethodHandle, MethodHandle)} assumes position
<i>4236</i>&nbsp;     * 0.
<i>4237</i>&nbsp;     *
<i>4238</i>&nbsp;     * @apiNote Example:
<i>4239</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4240</i>&nbsp;    import static java.lang.invoke.MethodHandles.*;
<i>4241</i>&nbsp;    import static java.lang.invoke.MethodType.*;
<i>4242</i>&nbsp;    ...
<i>4243</i>&nbsp;    MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
<i>4244</i>&nbsp;    &quot;println&quot;, methodType(void.class, String.class))
<i>4245</i>&nbsp;    .bindTo(System.out);
<i>4246</i>&nbsp;    MethodHandle cat = lookup().findVirtual(String.class,
<i>4247</i>&nbsp;    &quot;concat&quot;, methodType(String.class, String.class));
<i>4248</i>&nbsp;    assertEquals(&quot;boojum&quot;, (String) cat.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
<i>4249</i>&nbsp;    MethodHandle catTrace = foldArguments(cat, 1, trace);
<i>4250</i>&nbsp;    // also prints &quot;jum&quot;:
<i>4251</i>&nbsp;    assertEquals(&quot;boojum&quot;, (String) catTrace.invokeExact(&quot;boo&quot;, &quot;jum&quot;));
<i>4252</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4253</i>&nbsp;     * &lt;p&gt;Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>4254</i>&nbsp;     * represents the result type of the {@code target} and resulting adapter.
<i>4255</i>&nbsp;     * {@code V}/{@code v} represent the type and value of the parameter and argument
<i>4256</i>&nbsp;     * of {@code target} that precedes the folding position; {@code V} also is
<i>4257</i>&nbsp;     * the result type of the {@code combiner}. {@code A}/{@code a} denote the
<i>4258</i>&nbsp;     * types and values of the {@code N} parameters and arguments at the folding
<i>4259</i>&nbsp;     * position. {@code Z}/{@code z} and {@code B}/{@code b} represent the types
<i>4260</i>&nbsp;     * and values of the {@code target} parameters and arguments that precede and
<i>4261</i>&nbsp;     * follow the folded parameters and arguments starting at {@code pos},
<i>4262</i>&nbsp;     * respectively.
<i>4263</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4264</i>&nbsp;     * // there are N arguments in A...
<i>4265</i>&nbsp;     * T target(Z..., V, A[N]..., B...);
<i>4266</i>&nbsp;     * V combiner(A...);
<i>4267</i>&nbsp;     * T adapter(Z... z, A... a, B... b) {
<i>4268</i>&nbsp;     *   V v = combiner(a...);
<i>4269</i>&nbsp;     *   return target(z..., v, a..., b...);
<i>4270</i>&nbsp;     * }
<i>4271</i>&nbsp;     * // and if the combiner has a void return:
<i>4272</i>&nbsp;     * T target2(Z..., A[N]..., B...);
<i>4273</i>&nbsp;     * void combiner2(A...);
<i>4274</i>&nbsp;     * T adapter2(Z... z, A... a, B... b) {
<i>4275</i>&nbsp;     *   combiner2(a...);
<i>4276</i>&nbsp;     *   return target2(z..., a..., b...);
<i>4277</i>&nbsp;     * }
<i>4278</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4279</i>&nbsp;     * &lt;p&gt;
<i>4280</i>&nbsp;     * &lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a {@linkplain MethodHandle#asVarargsCollector
<i>4281</i>&nbsp;     * variable-arity method handle}, even if the original target method handle was.
<i>4282</i>&nbsp;     *
<i>4283</i>&nbsp;     * @param target the method handle to invoke after arguments are combined
<i>4284</i>&nbsp;     * @param pos the position at which to start folding and at which to insert the folding result; if this is {@code
<i>4285</i>&nbsp;     *            0}, the effect is the same as for {@link #foldArguments(MethodHandle, MethodHandle)}.
<i>4286</i>&nbsp;     * @param combiner method handle to call initially on the incoming arguments
<i>4287</i>&nbsp;     * @return method handle which incorporates the specified argument folding logic
<i>4288</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>4289</i>&nbsp;     * @throws IllegalArgumentException if either of the following two conditions holds:
<i>4290</i>&nbsp;     *          (1) {@code combiner}&#39;s return type is non-{@code void} and not the same as the argument type at position
<i>4291</i>&nbsp;     *              {@code pos} of the target signature;
<i>4292</i>&nbsp;     *          (2) the {@code N} argument types at position {@code pos} of the target signature (skipping one matching
<i>4293</i>&nbsp;     *              the {@code combiner}&#39;s return type) are not identical with the argument types of {@code combiner}.
<i>4294</i>&nbsp;     *
<i>4295</i>&nbsp;     * @see #foldArguments(MethodHandle, MethodHandle)
<i>4296</i>&nbsp;     * @since 9
<i>4297</i>&nbsp;     */
<i>4298</i>&nbsp;    public static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner) {
<i>4299</i>&nbsp;        MethodType targetType = target.type();
<i>4300</i>&nbsp;        MethodType combinerType = combiner.type();
<i>4301</i>&nbsp;        Class&lt;?&gt; rtype = foldArgumentChecks(pos, targetType, combinerType);
<i>4302</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>4303</i>&nbsp;        boolean dropResult = rtype == void.class;
<i>4304</i>&nbsp;        LambdaForm lform = result.editor().foldArgumentsForm(1 + pos, dropResult, combinerType.basicType());
<i>4305</i>&nbsp;        MethodType newType = targetType;
<i>4306</i>&nbsp;        if (!dropResult) {
<i>4307</i>&nbsp;            newType = newType.dropParameterTypes(pos, pos + 1);
<i>4308</i>&nbsp;        }
<i>4309</i>&nbsp;        result = result.copyWithExtendL(newType, lform, combiner);
<i>4310</i>&nbsp;        return result;
<i>4311</i>&nbsp;    }
<i>4312</i>&nbsp;
<i>4313</i>&nbsp;    /**
<i>4314</i>&nbsp;     * As {@see foldArguments(MethodHandle, int, MethodHandle)}, but with the
<i>4315</i>&nbsp;     * added capability of selecting the arguments from the targets parameters
<i>4316</i>&nbsp;     * to call the combiner with. This allows us to avoid some simple cases of
<i>4317</i>&nbsp;     * permutations and padding the combiner with dropArguments to select the
<i>4318</i>&nbsp;     * right argument, which may ultimately produce fewer intermediaries.
<i>4319</i>&nbsp;     */
<i>4320</i>&nbsp;    static MethodHandle foldArguments(MethodHandle target, int pos, MethodHandle combiner, int ... argPositions) {
<i>4321</i>&nbsp;        MethodType targetType = target.type();
<i>4322</i>&nbsp;        MethodType combinerType = combiner.type();
<i>4323</i>&nbsp;        Class&lt;?&gt; rtype = foldArgumentChecks(pos, targetType, combinerType, argPositions);
<i>4324</i>&nbsp;        BoundMethodHandle result = target.rebind();
<i>4325</i>&nbsp;        boolean dropResult = rtype == void.class;
<i>4326</i>&nbsp;        LambdaForm lform = result.editor().foldArgumentsForm(1 + pos, dropResult, combinerType.basicType(), argPositions);
<i>4327</i>&nbsp;        MethodType newType = targetType;
<i>4328</i>&nbsp;        if (!dropResult) {
<i>4329</i>&nbsp;            newType = newType.dropParameterTypes(pos, pos + 1);
<i>4330</i>&nbsp;        }
<i>4331</i>&nbsp;        result = result.copyWithExtendL(newType, lform, combiner);
<i>4332</i>&nbsp;        return result;
<i>4333</i>&nbsp;    }
<i>4334</i>&nbsp;
<i>4335</i>&nbsp;    private static Class&lt;?&gt; foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType) {
<i>4336</i>&nbsp;        int foldArgs   = combinerType.parameterCount();
<i>4337</i>&nbsp;        Class&lt;?&gt; rtype = combinerType.returnType();
<i>4338</i>&nbsp;        int foldVals = rtype == void.class ? 0 : 1;
<i>4339</i>&nbsp;        int afterInsertPos = foldPos + foldVals;
<i>4340</i>&nbsp;        boolean ok = (targetType.parameterCount() &gt;= afterInsertPos + foldArgs);
<i>4341</i>&nbsp;        if (ok) {
<i>4342</i>&nbsp;            for (int i = 0; i &lt; foldArgs; i++) {
<i>4343</i>&nbsp;                if (combinerType.parameterType(i) != targetType.parameterType(i + afterInsertPos)) {
<i>4344</i>&nbsp;                    ok = false;
<i>4345</i>&nbsp;                    break;
<i>4346</i>&nbsp;                }
<i>4347</i>&nbsp;            }
<i>4348</i>&nbsp;        }
<i>4349</i>&nbsp;        if (ok &amp;&amp; foldVals != 0 &amp;&amp; combinerType.returnType() != targetType.parameterType(foldPos))
<i>4350</i>&nbsp;            ok = false;
<i>4351</i>&nbsp;        if (!ok)
<i>4352</i>&nbsp;            throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
<i>4353</i>&nbsp;        return rtype;
<i>4354</i>&nbsp;    }
<i>4355</i>&nbsp;
<i>4356</i>&nbsp;    private static Class&lt;?&gt; foldArgumentChecks(int foldPos, MethodType targetType, MethodType combinerType, int ... argPos) {
<i>4357</i>&nbsp;        int foldArgs = combinerType.parameterCount();
<i>4358</i>&nbsp;        if (argPos.length != foldArgs) {
<i>4359</i>&nbsp;            throw newIllegalArgumentException(&quot;combiner and argument map must be equal size&quot;, combinerType, argPos.length);
<i>4360</i>&nbsp;        }
<i>4361</i>&nbsp;        Class&lt;?&gt; rtype = combinerType.returnType();
<i>4362</i>&nbsp;        int foldVals = rtype == void.class ? 0 : 1;
<i>4363</i>&nbsp;        boolean ok = true;
<i>4364</i>&nbsp;        for (int i = 0; i &lt; foldArgs; i++) {
<i>4365</i>&nbsp;            int arg = argPos[i];
<i>4366</i>&nbsp;            if (arg &lt; 0 || arg &gt; targetType.parameterCount()) {
<i>4367</i>&nbsp;                throw newIllegalArgumentException(&quot;arg outside of target parameterRange&quot;, targetType, arg);
<i>4368</i>&nbsp;            }
<i>4369</i>&nbsp;            if (combinerType.parameterType(i) != targetType.parameterType(arg)) {
<i>4370</i>&nbsp;                throw newIllegalArgumentException(&quot;target argument type at position &quot; + arg
<i>4371</i>&nbsp;                        + &quot; must match combiner argument type at index &quot; + i + &quot;: &quot; + targetType
<i>4372</i>&nbsp;                        + &quot; -&gt; &quot; + combinerType + &quot;, map: &quot; + Arrays.toString(argPos));
<i>4373</i>&nbsp;            }
<i>4374</i>&nbsp;        }
<i>4375</i>&nbsp;        if (ok &amp;&amp; foldVals != 0 &amp;&amp; combinerType.returnType() != targetType.parameterType(foldPos)) {
<i>4376</i>&nbsp;            ok = false;
<i>4377</i>&nbsp;        }
<i>4378</i>&nbsp;        if (!ok)
<i>4379</i>&nbsp;            throw misMatchedTypes(&quot;target and combiner types&quot;, targetType, combinerType);
<i>4380</i>&nbsp;        return rtype;
<i>4381</i>&nbsp;    }
<i>4382</i>&nbsp;
<i>4383</i>&nbsp;    /**
<i>4384</i>&nbsp;     * Makes a method handle which adapts a target method handle,
<i>4385</i>&nbsp;     * by guarding it with a test, a boolean-valued method handle.
<i>4386</i>&nbsp;     * If the guard fails, a fallback handle is called instead.
<i>4387</i>&nbsp;     * All three method handles must have the same corresponding
<i>4388</i>&nbsp;     * argument and return types, except that the return type
<i>4389</i>&nbsp;     * of the test must be boolean, and the test is allowed
<i>4390</i>&nbsp;     * to have fewer arguments than the other two method handles.
<i>4391</i>&nbsp;     * &lt;p&gt;
<i>4392</i>&nbsp;     * Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>4393</i>&nbsp;     * represents the uniform result type of the three involved handles;
<i>4394</i>&nbsp;     * {@code A}/{@code a}, the types and values of the {@code target}
<i>4395</i>&nbsp;     * parameters and arguments that are consumed by the {@code test}; and
<i>4396</i>&nbsp;     * {@code B}/{@code b}, those types and values of the {@code target}
<i>4397</i>&nbsp;     * parameters and arguments that are not consumed by the {@code test}.
<i>4398</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4399</i>&nbsp;     * boolean test(A...);
<i>4400</i>&nbsp;     * T target(A...,B...);
<i>4401</i>&nbsp;     * T fallback(A...,B...);
<i>4402</i>&nbsp;     * T adapter(A... a,B... b) {
<i>4403</i>&nbsp;     *   if (test(a...))
<i>4404</i>&nbsp;     *     return target(a..., b...);
<i>4405</i>&nbsp;     *   else
<i>4406</i>&nbsp;     *     return fallback(a..., b...);
<i>4407</i>&nbsp;     * }
<i>4408</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4409</i>&nbsp;     * Note that the test arguments ({@code a...} in the pseudocode) cannot
<i>4410</i>&nbsp;     * be modified by execution of the test, and so are passed unchanged
<i>4411</i>&nbsp;     * from the caller to the target or fallback as appropriate.
<i>4412</i>&nbsp;     * @param test method handle used for test, must return boolean
<i>4413</i>&nbsp;     * @param target method handle to call if test passes
<i>4414</i>&nbsp;     * @param fallback method handle to call if test fails
<i>4415</i>&nbsp;     * @return method handle which incorporates the specified if/then/else logic
<i>4416</i>&nbsp;     * @throws NullPointerException if any argument is null
<i>4417</i>&nbsp;     * @throws IllegalArgumentException if {@code test} does not return boolean,
<i>4418</i>&nbsp;     *          or if all three method types do not match (with the return
<i>4419</i>&nbsp;     *          type of {@code test} changed to match that of the target).
<i>4420</i>&nbsp;     */
<i>4421</i>&nbsp;    public static
<i>4422</i>&nbsp;    MethodHandle guardWithTest(MethodHandle test,
<i>4423</i>&nbsp;                               MethodHandle target,
<i>4424</i>&nbsp;                               MethodHandle fallback) {
<i>4425</i>&nbsp;        MethodType gtype = test.type();
<i>4426</i>&nbsp;        MethodType ttype = target.type();
<i>4427</i>&nbsp;        MethodType ftype = fallback.type();
<i>4428</i>&nbsp;        if (!ttype.equals(ftype))
<i>4429</i>&nbsp;            throw misMatchedTypes(&quot;target and fallback types&quot;, ttype, ftype);
<i>4430</i>&nbsp;        if (gtype.returnType() != boolean.class)
<i>4431</i>&nbsp;            throw newIllegalArgumentException(&quot;guard type is not a predicate &quot;+gtype);
<i>4432</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; targs = ttype.parameterList();
<i>4433</i>&nbsp;        test = dropArgumentsToMatch(test, 0, targs, 0, true);
<i>4434</i>&nbsp;        if (test == null) {
<i>4435</i>&nbsp;            throw misMatchedTypes(&quot;target and test types&quot;, ttype, gtype);
<i>4436</i>&nbsp;        }
<i>4437</i>&nbsp;        return MethodHandleImpl.makeGuardWithTest(test, target, fallback);
<i>4438</i>&nbsp;    }
<i>4439</i>&nbsp;
<i>4440</i>&nbsp;    static &lt;T&gt; RuntimeException misMatchedTypes(String what, T t1, T t2) {
<i>4441</i>&nbsp;        return newIllegalArgumentException(what + &quot; must match: &quot; + t1 + &quot; != &quot; + t2);
<i>4442</i>&nbsp;    }
<i>4443</i>&nbsp;
<i>4444</i>&nbsp;    /**
<i>4445</i>&nbsp;     * Makes a method handle which adapts a target method handle,
<i>4446</i>&nbsp;     * by running it inside an exception handler.
<i>4447</i>&nbsp;     * If the target returns normally, the adapter returns that value.
<i>4448</i>&nbsp;     * If an exception matching the specified type is thrown, the fallback
<i>4449</i>&nbsp;     * handle is called instead on the exception, plus the original arguments.
<i>4450</i>&nbsp;     * &lt;p&gt;
<i>4451</i>&nbsp;     * The target and handler must have the same corresponding
<i>4452</i>&nbsp;     * argument and return types, except that handler may omit trailing arguments
<i>4453</i>&nbsp;     * (similarly to the predicate in {@link #guardWithTest guardWithTest}).
<i>4454</i>&nbsp;     * Also, the handler must have an extra leading parameter of {@code exType} or a supertype.
<i>4455</i>&nbsp;     * &lt;p&gt;
<i>4456</i>&nbsp;     * Here is pseudocode for the resulting adapter. In the code, {@code T}
<i>4457</i>&nbsp;     * represents the return type of the {@code target} and {@code handler},
<i>4458</i>&nbsp;     * and correspondingly that of the resulting adapter; {@code A}/{@code a},
<i>4459</i>&nbsp;     * the types and values of arguments to the resulting handle consumed by
<i>4460</i>&nbsp;     * {@code handler}; and {@code B}/{@code b}, those of arguments to the
<i>4461</i>&nbsp;     * resulting handle discarded by {@code handler}.
<i>4462</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4463</i>&nbsp;     * T target(A..., B...);
<i>4464</i>&nbsp;     * T handler(ExType, A...);
<i>4465</i>&nbsp;     * T adapter(A... a, B... b) {
<i>4466</i>&nbsp;     *   try {
<i>4467</i>&nbsp;     *     return target(a..., b...);
<i>4468</i>&nbsp;     *   } catch (ExType ex) {
<i>4469</i>&nbsp;     *     return handler(ex, a...);
<i>4470</i>&nbsp;     *   }
<i>4471</i>&nbsp;     * }
<i>4472</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4473</i>&nbsp;     * Note that the saved arguments ({@code a...} in the pseudocode) cannot
<i>4474</i>&nbsp;     * be modified by execution of the target, and so are passed unchanged
<i>4475</i>&nbsp;     * from the caller to the handler, if the handler is invoked.
<i>4476</i>&nbsp;     * &lt;p&gt;
<i>4477</i>&nbsp;     * The target and handler must return the same type, even if the handler
<i>4478</i>&nbsp;     * always throws.  (This might happen, for instance, because the handler
<i>4479</i>&nbsp;     * is simulating a {@code finally} clause).
<i>4480</i>&nbsp;     * To create such a throwing handler, compose the handler creation logic
<i>4481</i>&nbsp;     * with {@link #throwException throwException},
<i>4482</i>&nbsp;     * in order to create a method handle of the correct return type.
<i>4483</i>&nbsp;     * @param target method handle to call
<i>4484</i>&nbsp;     * @param exType the type of exception which the handler will catch
<i>4485</i>&nbsp;     * @param handler method handle to call if a matching exception is thrown
<i>4486</i>&nbsp;     * @return method handle which incorporates the specified try/catch logic
<i>4487</i>&nbsp;     * @throws NullPointerException if any argument is null
<i>4488</i>&nbsp;     * @throws IllegalArgumentException if {@code handler} does not accept
<i>4489</i>&nbsp;     *          the given exception type, or if the method handle types do
<i>4490</i>&nbsp;     *          not match in their return types and their
<i>4491</i>&nbsp;     *          corresponding parameters
<i>4492</i>&nbsp;     * @see MethodHandles#tryFinally(MethodHandle, MethodHandle)
<i>4493</i>&nbsp;     */
<i>4494</i>&nbsp;    public static
<i>4495</i>&nbsp;    MethodHandle catchException(MethodHandle target,
<i>4496</i>&nbsp;                                Class&lt;? extends Throwable&gt; exType,
<i>4497</i>&nbsp;                                MethodHandle handler) {
<i>4498</i>&nbsp;        MethodType ttype = target.type();
<i>4499</i>&nbsp;        MethodType htype = handler.type();
<i>4500</i>&nbsp;        if (!Throwable.class.isAssignableFrom(exType))
<i>4501</i>&nbsp;            throw new ClassCastException(exType.getName());
<i>4502</i>&nbsp;        if (htype.parameterCount() &lt; 1 ||
<i>4503</i>&nbsp;            !htype.parameterType(0).isAssignableFrom(exType))
<i>4504</i>&nbsp;            throw newIllegalArgumentException(&quot;handler does not accept exception type &quot;+exType);
<i>4505</i>&nbsp;        if (htype.returnType() != ttype.returnType())
<i>4506</i>&nbsp;            throw misMatchedTypes(&quot;target and handler return types&quot;, ttype, htype);
<i>4507</i>&nbsp;        handler = dropArgumentsToMatch(handler, 1, ttype.parameterList(), 0, true);
<i>4508</i>&nbsp;        if (handler == null) {
<i>4509</i>&nbsp;            throw misMatchedTypes(&quot;target and handler types&quot;, ttype, htype);
<i>4510</i>&nbsp;        }
<i>4511</i>&nbsp;        return MethodHandleImpl.makeGuardWithCatch(target, exType, handler);
<i>4512</i>&nbsp;    }
<i>4513</i>&nbsp;
<i>4514</i>&nbsp;    /**
<i>4515</i>&nbsp;     * Produces a method handle which will throw exceptions of the given {@code exType}.
<i>4516</i>&nbsp;     * The method handle will accept a single argument of {@code exType},
<i>4517</i>&nbsp;     * and immediately throw it as an exception.
<i>4518</i>&nbsp;     * The method type will nominally specify a return of {@code returnType}.
<i>4519</i>&nbsp;     * The return type may be anything convenient:  It doesn&#39;t matter to the
<i>4520</i>&nbsp;     * method handle&#39;s behavior, since it will never return normally.
<i>4521</i>&nbsp;     * @param returnType the return type of the desired method handle
<i>4522</i>&nbsp;     * @param exType the parameter type of the desired method handle
<i>4523</i>&nbsp;     * @return method handle which can throw the given exceptions
<i>4524</i>&nbsp;     * @throws NullPointerException if either argument is null
<i>4525</i>&nbsp;     */
<i>4526</i>&nbsp;    public static
<i>4527</i>&nbsp;    MethodHandle throwException(Class&lt;?&gt; returnType, Class&lt;? extends Throwable&gt; exType) {
<i>4528</i>&nbsp;        if (!Throwable.class.isAssignableFrom(exType))
<i>4529</i>&nbsp;            throw new ClassCastException(exType.getName());
<i>4530</i>&nbsp;        return MethodHandleImpl.throwException(methodType(returnType, exType));
<i>4531</i>&nbsp;    }
<i>4532</i>&nbsp;
<i>4533</i>&nbsp;    /**
<i>4534</i>&nbsp;     * Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
<i>4535</i>&nbsp;     * iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
<i>4536</i>&nbsp;     * delivers the loop&#39;s result, which is the return value of the resulting handle.
<i>4537</i>&nbsp;     * &lt;p&gt;
<i>4538</i>&nbsp;     * Intuitively, every loop is formed by one or more &quot;clauses&quot;, each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
<i>4539</i>&nbsp;     * exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
<i>4540</i>&nbsp;     * variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
<i>4541</i>&nbsp;     * terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
<i>4542</i>&nbsp;     * &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable {@code v} of type {@code V}.
<i>4543</i>&nbsp;     * &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable {@code v}.
<i>4544</i>&nbsp;     * &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
<i>4545</i>&nbsp;     * &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop&#39;s return value.
<i>4546</i>&nbsp;     * &lt;/ul&gt;
<i>4547</i>&nbsp;     * The full sequence of all iteration variable types, in clause order, will be notated as {@code (V...)}.
<i>4548</i>&nbsp;     * The values themselves will be {@code (v...)}.  When we speak of &quot;parameter lists&quot;, we will usually
<i>4549</i>&nbsp;     * be referring to types, but in some contexts (describing execution) the lists will be of actual values.
<i>4550</i>&nbsp;     * &lt;p&gt;
<i>4551</i>&nbsp;     * Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in
<i>4552</i>&nbsp;     * this case. See below for a detailed description.
<i>4553</i>&nbsp;     * &lt;p&gt;
<i>4554</i>&nbsp;     * &lt;em&gt;Parameters optional everywhere:&lt;/em&gt;
<i>4555</i>&nbsp;     * Each clause function is allowed but not required to accept a parameter for each iteration variable {@code v}.
<i>4556</i>&nbsp;     * As an exception, the init functions cannot take any {@code v} parameters,
<i>4557</i>&nbsp;     * because those values are not yet computed when the init functions are executed.
<i>4558</i>&nbsp;     * Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take.
<i>4559</i>&nbsp;     * In fact, any clause function may take no arguments at all.
<i>4560</i>&nbsp;     * &lt;p&gt;
<i>4561</i>&nbsp;     * &lt;em&gt;Loop parameters:&lt;/em&gt;
<i>4562</i>&nbsp;     * A clause function may take all the iteration variable values it is entitled to, in which case
<i>4563</i>&nbsp;     * it may also take more trailing parameters. Such extra values are called &lt;em&gt;loop parameters&lt;/em&gt;,
<i>4564</i>&nbsp;     * with their types and values notated as {@code (A...)} and {@code (a...)}.
<i>4565</i>&nbsp;     * These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed.
<i>4566</i>&nbsp;     * (Since init functions do not accept iteration variables {@code v}, any parameter to an
<i>4567</i>&nbsp;     * init function is automatically a loop parameter {@code a}.)
<i>4568</i>&nbsp;     * As with iteration variables, clause functions are allowed but not required to accept loop parameters.
<i>4569</i>&nbsp;     * These loop parameters act as loop-invariant values visible across the whole loop.
<i>4570</i>&nbsp;     * &lt;p&gt;
<i>4571</i>&nbsp;     * &lt;em&gt;Parameters visible everywhere:&lt;/em&gt;
<i>4572</i>&nbsp;     * Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full
<i>4573</i>&nbsp;     * list {@code (v... a...)} of current iteration variable values and incoming loop parameters.
<i>4574</i>&nbsp;     * The init functions can observe initial pre-loop state, in the form {@code (a...)}.
<i>4575</i>&nbsp;     * Most clause functions will not need all of this information, but they will be formally connected to it
<i>4576</i>&nbsp;     * as if by {@link #dropArguments}.
<i>4577</i>&nbsp;     * &lt;a id=&quot;astar&quot;&gt;&lt;/a&gt;
<i>4578</i>&nbsp;     * More specifically, we shall use the notation {@code (V*)} to express an arbitrary prefix of a full
<i>4579</i>&nbsp;     * sequence {@code (V...)} (and likewise for {@code (v*)}, {@code (A*)}, {@code (a*)}).
<i>4580</i>&nbsp;     * In that notation, the general form of an init function parameter list
<i>4581</i>&nbsp;     * is {@code (A*)}, and the general form of a non-init function parameter list is {@code (V*)} or {@code (V... A*)}.
<i>4582</i>&nbsp;     * &lt;p&gt;
<i>4583</i>&nbsp;     * &lt;em&gt;Checking clause structure:&lt;/em&gt;
<i>4584</i>&nbsp;     * Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the
<i>4585</i>&nbsp;     * loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word &quot;must&quot;
<i>4586</i>&nbsp;     * corresponds to a place where {@link IllegalArgumentException} will be thrown if the required constraint is not
<i>4587</i>&nbsp;     * met by the inputs to the loop combinator.
<i>4588</i>&nbsp;     * &lt;p&gt;
<i>4589</i>&nbsp;     * &lt;em&gt;Effectively identical sequences:&lt;/em&gt;
<i>4590</i>&nbsp;     * &lt;a id=&quot;effid&quot;&gt;&lt;/a&gt;
<i>4591</i>&nbsp;     * A parameter list {@code A} is defined to be &lt;em&gt;effectively identical&lt;/em&gt; to another parameter list {@code B}
<i>4592</i>&nbsp;     * if {@code A} and {@code B} are identical, or if {@code A} is shorter and is identical with a proper prefix of {@code B}.
<i>4593</i>&nbsp;     * When speaking of an unordered set of parameter lists, we say they the set is &quot;effectively identical&quot;
<i>4594</i>&nbsp;     * as a whole if the set contains a longest list, and all members of the set are effectively identical to
<i>4595</i>&nbsp;     * that longest list.
<i>4596</i>&nbsp;     * For example, any set of type sequences of the form {@code (V*)} is effectively identical,
<i>4597</i>&nbsp;     * and the same is true if more sequences of the form {@code (V... A*)} are added.
<i>4598</i>&nbsp;     * &lt;p&gt;
<i>4599</i>&nbsp;     * &lt;em&gt;Step 0: Determine clause structure.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4600</i>&nbsp;     * &lt;li&gt;The clause array (of type {@code MethodHandle[][]}) must be non-{@code null} and contain at least one element.
<i>4601</i>&nbsp;     * &lt;li&gt;The clause array may not contain {@code null}s or sub-arrays longer than four elements.
<i>4602</i>&nbsp;     * &lt;li&gt;Clauses shorter than four elements are treated as if they were padded by {@code null} elements to length
<i>4603</i>&nbsp;     * four. Padding takes place by appending elements to the array.
<i>4604</i>&nbsp;     * &lt;li&gt;Clauses with all {@code null}s are disregarded.
<i>4605</i>&nbsp;     * &lt;li&gt;Each clause is treated as a four-tuple of functions, called &quot;init&quot;, &quot;step&quot;, &quot;pred&quot;, and &quot;fini&quot;.
<i>4606</i>&nbsp;     * &lt;/ol&gt;
<i>4607</i>&nbsp;     * &lt;p&gt;
<i>4608</i>&nbsp;     * &lt;em&gt;Step 1A: Determine iteration variable types {@code (V...)}.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4609</i>&nbsp;     * &lt;li&gt;The iteration variable type for each clause is determined using the clause&#39;s init and step return types.
<i>4610</i>&nbsp;     * &lt;li&gt;If both functions are omitted, there is no iteration variable for the corresponding clause ({@code void} is
<i>4611</i>&nbsp;     * used as the type to indicate that). If one of them is omitted, the other&#39;s return type defines the clause&#39;s
<i>4612</i>&nbsp;     * iteration variable type. If both are given, the common return type (they must be identical) defines the clause&#39;s
<i>4613</i>&nbsp;     * iteration variable type.
<i>4614</i>&nbsp;     * &lt;li&gt;Form the list of return types (in clause order), omitting all occurrences of {@code void}.
<i>4615</i>&nbsp;     * &lt;li&gt;This list of types is called the &quot;iteration variable types&quot; ({@code (V...)}).
<i>4616</i>&nbsp;     * &lt;/ol&gt;
<i>4617</i>&nbsp;     * &lt;p&gt;
<i>4618</i>&nbsp;     * &lt;em&gt;Step 1B: Determine loop parameters {@code (A...)}.&lt;/em&gt;&lt;ul&gt;
<i>4619</i>&nbsp;     * &lt;li&gt;Examine and collect init function parameter lists (which are of the form {@code (A*)}).
<i>4620</i>&nbsp;     * &lt;li&gt;Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types.
<i>4621</i>&nbsp;     * (They must have the form {@code (V... A*)}; collect the {@code (A*)} parts only.)
<i>4622</i>&nbsp;     * &lt;li&gt;Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types.
<i>4623</i>&nbsp;     * (These types will checked in step 2, along with all the clause function types.)
<i>4624</i>&nbsp;     * &lt;li&gt;Omitted clause functions are ignored.  (Equivalently, they are deemed to have empty parameter lists.)
<i>4625</i>&nbsp;     * &lt;li&gt;All of the collected parameter lists must be effectively identical.
<i>4626</i>&nbsp;     * &lt;li&gt;The longest parameter list (which is necessarily unique) is called the &quot;external parameter list&quot; ({@code (A...)}).
<i>4627</i>&nbsp;     * &lt;li&gt;If there is no such parameter list, the external parameter list is taken to be the empty sequence.
<i>4628</i>&nbsp;     * &lt;li&gt;The combined list consisting of iteration variable types followed by the external parameter types is called
<i>4629</i>&nbsp;     * the &quot;internal parameter list&quot;.
<i>4630</i>&nbsp;     * &lt;/ul&gt;
<i>4631</i>&nbsp;     * &lt;p&gt;
<i>4632</i>&nbsp;     * &lt;em&gt;Step 1C: Determine loop return type.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4633</i>&nbsp;     * &lt;li&gt;Examine fini function return types, disregarding omitted fini functions.
<i>4634</i>&nbsp;     * &lt;li&gt;If there are no fini functions, the loop return type is {@code void}.
<i>4635</i>&nbsp;     * &lt;li&gt;Otherwise, the common return type {@code R} of the fini functions (their return types must be identical) defines the loop return
<i>4636</i>&nbsp;     * type.
<i>4637</i>&nbsp;     * &lt;/ol&gt;
<i>4638</i>&nbsp;     * &lt;p&gt;
<i>4639</i>&nbsp;     * &lt;em&gt;Step 1D: Check other types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4640</i>&nbsp;     * &lt;li&gt;There must be at least one non-omitted pred function.
<i>4641</i>&nbsp;     * &lt;li&gt;Every non-omitted pred function must have a {@code boolean} return type.
<i>4642</i>&nbsp;     * &lt;/ol&gt;
<i>4643</i>&nbsp;     * &lt;p&gt;
<i>4644</i>&nbsp;     * &lt;em&gt;Step 2: Determine parameter lists.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4645</i>&nbsp;     * &lt;li&gt;The parameter list for the resulting loop handle will be the external parameter list {@code (A...)}.
<i>4646</i>&nbsp;     * &lt;li&gt;The parameter list for init functions will be adjusted to the external parameter list.
<i>4647</i>&nbsp;     * (Note that their parameter lists are already effectively identical to this list.)
<i>4648</i>&nbsp;     * &lt;li&gt;The parameter list for every non-omitted, non-init (step, pred, and fini) function must be
<i>4649</i>&nbsp;     * effectively identical to the internal parameter list {@code (V... A...)}.
<i>4650</i>&nbsp;     * &lt;/ol&gt;
<i>4651</i>&nbsp;     * &lt;p&gt;
<i>4652</i>&nbsp;     * &lt;em&gt;Step 3: Fill in omitted functions.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4653</i>&nbsp;     * &lt;li&gt;If an init function is omitted, use a {@linkplain #empty default value} for the clause&#39;s iteration variable
<i>4654</i>&nbsp;     * type.
<i>4655</i>&nbsp;     * &lt;li&gt;If a step function is omitted, use an {@linkplain #identity identity function} of the clause&#39;s iteration
<i>4656</i>&nbsp;     * variable type; insert dropped argument parameters before the identity function parameter for the non-{@code void}
<i>4657</i>&nbsp;     * iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)
<i>4658</i>&nbsp;     * &lt;li&gt;If a pred function is omitted, use a constant {@code true} function. (This will keep the loop going, as far
<i>4659</i>&nbsp;     * as this clause is concerned.  Note that in such cases the corresponding fini function is unreachable.)
<i>4660</i>&nbsp;     * &lt;li&gt;If a fini function is omitted, use a {@linkplain #empty default value} for the
<i>4661</i>&nbsp;     * loop return type.
<i>4662</i>&nbsp;     * &lt;/ol&gt;
<i>4663</i>&nbsp;     * &lt;p&gt;
<i>4664</i>&nbsp;     * &lt;em&gt;Step 4: Fill in missing parameter types.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4665</i>&nbsp;     * &lt;li&gt;At this point, every init function parameter list is effectively identical to the external parameter list {@code (A...)},
<i>4666</i>&nbsp;     * but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.
<i>4667</i>&nbsp;     * &lt;li&gt;At this point, every non-init function parameter list is effectively identical to the internal parameter
<i>4668</i>&nbsp;     * list {@code (V... A...)}, but some lists may be shorter. For every non-init function with a short parameter list,
<i>4669</i>&nbsp;     * pad out the end of the list.
<i>4670</i>&nbsp;     * &lt;li&gt;Argument lists are padded out by {@linkplain #dropArgumentsToMatch(MethodHandle, int, List, int) dropping unused trailing arguments}.
<i>4671</i>&nbsp;     * &lt;/ol&gt;
<i>4672</i>&nbsp;     * &lt;p&gt;
<i>4673</i>&nbsp;     * &lt;em&gt;Final observations.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4674</i>&nbsp;     * &lt;li&gt;After these steps, all clauses have been adjusted by supplying omitted functions and arguments.
<i>4675</i>&nbsp;     * &lt;li&gt;All init functions have a common parameter type list {@code (A...)}, which the final loop handle will also have.
<i>4676</i>&nbsp;     * &lt;li&gt;All fini functions have a common return type {@code R}, which the final loop handle will also have.
<i>4677</i>&nbsp;     * &lt;li&gt;All non-init functions have a common parameter type list {@code (V... A...)}, of
<i>4678</i>&nbsp;     * (non-{@code void}) iteration variables {@code V} followed by loop parameters.
<i>4679</i>&nbsp;     * &lt;li&gt;Each pair of init and step functions agrees in their return type {@code V}.
<i>4680</i>&nbsp;     * &lt;li&gt;Each non-init function will be able to observe the current values {@code (v...)} of all iteration variables.
<i>4681</i>&nbsp;     * &lt;li&gt;Every function will be able to observe the incoming values {@code (a...)} of all loop parameters.
<i>4682</i>&nbsp;     * &lt;/ol&gt;
<i>4683</i>&nbsp;     * &lt;p&gt;
<i>4684</i>&nbsp;     * &lt;em&gt;Example.&lt;/em&gt; As a consequence of step 1A above, the {@code loop} combinator has the following property:
<i>4685</i>&nbsp;     * &lt;ul&gt;
<i>4686</i>&nbsp;     * &lt;li&gt;Given {@code N} clauses {@code Cn = {null, Sn, Pn}} with {@code n = 1..N}.
<i>4687</i>&nbsp;     * &lt;li&gt;Suppose predicate handles {@code Pn} are either {@code null} or have no parameters.
<i>4688</i>&nbsp;     * (Only one {@code Pn} has to be non-{@code null}.)
<i>4689</i>&nbsp;     * &lt;li&gt;Suppose step handles {@code Sn} have signatures {@code (B1..BX)Rn}, for some constant {@code X&gt;=N}.
<i>4690</i>&nbsp;     * &lt;li&gt;Suppose {@code Q} is the count of non-void types {@code Rn}, and {@code (V1...VQ)} is the sequence of those types.
<i>4691</i>&nbsp;     * &lt;li&gt;It must be that {@code Vn == Bn} for {@code n = 1..min(X,Q)}.
<i>4692</i>&nbsp;     * &lt;li&gt;The parameter types {@code Vn} will be interpreted as loop-local state elements {@code (V...)}.
<i>4693</i>&nbsp;     * &lt;li&gt;Any remaining types {@code BQ+1..BX} (if {@code Q&lt;X}) will determine
<i>4694</i>&nbsp;     * the resulting loop handle&#39;s parameter types {@code (A...)}.
<i>4695</i>&nbsp;     * &lt;/ul&gt;
<i>4696</i>&nbsp;     * In this example, the loop handle parameters {@code (A...)} were derived from the step functions,
<i>4697</i>&nbsp;     * which is natural if most of the loop computation happens in the steps.  For some loops,
<i>4698</i>&nbsp;     * the burden of computation might be heaviest in the pred functions, and so the pred functions
<i>4699</i>&nbsp;     * might need to accept the loop parameter values.  For loops with complex exit logic, the fini
<i>4700</i>&nbsp;     * functions might need to accept loop parameters, and likewise for loops with complex entry logic,
<i>4701</i>&nbsp;     * where the init functions will need the extra parameters.  For such reasons, the rules for
<i>4702</i>&nbsp;     * determining these parameters are as symmetric as possible, across all clause parts.
<i>4703</i>&nbsp;     * In general, the loop parameters function as common invariant values across the whole
<i>4704</i>&nbsp;     * loop, while the iteration variables function as common variant values, or (if there is
<i>4705</i>&nbsp;     * no step function) as internal loop invariant temporaries.
<i>4706</i>&nbsp;     * &lt;p&gt;
<i>4707</i>&nbsp;     * &lt;em&gt;Loop execution.&lt;/em&gt;&lt;ol type=&quot;a&quot;&gt;
<i>4708</i>&nbsp;     * &lt;li&gt;When the loop is called, the loop input values are saved in locals, to be passed to
<i>4709</i>&nbsp;     * every clause function. These locals are loop invariant.
<i>4710</i>&nbsp;     * &lt;li&gt;Each init function is executed in clause order (passing the external arguments {@code (a...)})
<i>4711</i>&nbsp;     * and the non-{@code void} values are saved (as the iteration variables {@code (v...)}) into locals.
<i>4712</i>&nbsp;     * These locals will be loop varying (unless their steps behave as identity functions, as noted above).
<i>4713</i>&nbsp;     * &lt;li&gt;All function executions (except init functions) will be passed the internal parameter list, consisting of
<i>4714</i>&nbsp;     * the non-{@code void} iteration values {@code (v...)} (in clause order) and then the loop inputs {@code (a...)}
<i>4715</i>&nbsp;     * (in argument order).
<i>4716</i>&nbsp;     * &lt;li&gt;The step and pred functions are then executed, in clause order (step before pred), until a pred function
<i>4717</i>&nbsp;     * returns {@code false}.
<i>4718</i>&nbsp;     * &lt;li&gt;The non-{@code void} result from a step function call is used to update the corresponding value in the
<i>4719</i>&nbsp;     * sequence {@code (v...)} of loop variables.
<i>4720</i>&nbsp;     * The updated value is immediately visible to all subsequent function calls.
<i>4721</i>&nbsp;     * &lt;li&gt;If a pred function returns {@code false}, the corresponding fini function is called, and the resulting value
<i>4722</i>&nbsp;     * (of type {@code R}) is returned from the loop as a whole.
<i>4723</i>&nbsp;     * &lt;li&gt;If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit
<i>4724</i>&nbsp;     * except by throwing an exception.
<i>4725</i>&nbsp;     * &lt;/ol&gt;
<i>4726</i>&nbsp;     * &lt;p&gt;
<i>4727</i>&nbsp;     * &lt;em&gt;Usage tips.&lt;/em&gt;
<i>4728</i>&nbsp;     * &lt;ul&gt;
<i>4729</i>&nbsp;     * &lt;li&gt;Although each step function will receive the current values of &lt;em&gt;all&lt;/em&gt; the loop variables,
<i>4730</i>&nbsp;     * sometimes a step function only needs to observe the current value of its own variable.
<i>4731</i>&nbsp;     * In that case, the step function may need to explicitly {@linkplain #dropArguments drop all preceding loop variables}.
<i>4732</i>&nbsp;     * This will require mentioning their types, in an expression like {@code dropArguments(step, 0, V0.class, ...)}.
<i>4733</i>&nbsp;     * &lt;li&gt;Loop variables are not required to vary; they can be loop invariant.  A clause can create
<i>4734</i>&nbsp;     * a loop invariant by a suitable init function with no step, pred, or fini function.  This may be
<i>4735</i>&nbsp;     * useful to &quot;wire&quot; an incoming loop argument into the step or pred function of an adjacent loop variable.
<i>4736</i>&nbsp;     * &lt;li&gt;If some of the clause functions are virtual methods on an instance, the instance
<i>4737</i>&nbsp;     * itself can be conveniently placed in an initial invariant loop &quot;variable&quot;, using an initial clause
<i>4738</i>&nbsp;     * like {@code new MethodHandle[]{identity(ObjType.class)}}.  In that case, the instance reference
<i>4739</i>&nbsp;     * will be the first iteration variable value, and it will be easy to use virtual
<i>4740</i>&nbsp;     * methods as clause parts, since all of them will take a leading instance reference matching that value.
<i>4741</i>&nbsp;     * &lt;/ul&gt;
<i>4742</i>&nbsp;     * &lt;p&gt;
<i>4743</i>&nbsp;     * Here is pseudocode for the resulting loop handle. As above, {@code V} and {@code v} represent the types
<i>4744</i>&nbsp;     * and values of loop variables; {@code A} and {@code a} represent arguments passed to the whole loop;
<i>4745</i>&nbsp;     * and {@code R} is the common result type of all finalizers as well as of the resulting loop.
<i>4746</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4747</i>&nbsp;     * V... init...(A...);
<i>4748</i>&nbsp;     * boolean pred...(V..., A...);
<i>4749</i>&nbsp;     * V... step...(V..., A...);
<i>4750</i>&nbsp;     * R fini...(V..., A...);
<i>4751</i>&nbsp;     * R loop(A... a) {
<i>4752</i>&nbsp;     *   V... v... = init...(a...);
<i>4753</i>&nbsp;     *   for (;;) {
<i>4754</i>&nbsp;     *     for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
<i>4755</i>&nbsp;     *       v = s(v..., a...);
<i>4756</i>&nbsp;     *       if (!p(v..., a...)) {
<i>4757</i>&nbsp;     *         return f(v..., a...);
<i>4758</i>&nbsp;     *       }
<i>4759</i>&nbsp;     *     }
<i>4760</i>&nbsp;     *   }
<i>4761</i>&nbsp;     * }
<i>4762</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4763</i>&nbsp;     * Note that the parameter type lists {@code (V...)} and {@code (A...)} have been expanded
<i>4764</i>&nbsp;     * to their full length, even though individual clause functions may neglect to take them all.
<i>4765</i>&nbsp;     * As noted above, missing parameters are filled in as if by {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}.
<i>4766</i>&nbsp;     *
<i>4767</i>&nbsp;     * @apiNote Example:
<i>4768</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4769</i>&nbsp;     * // iterative implementation of the factorial function as a loop handle
<i>4770</i>&nbsp;     * static int one(int k) { return 1; }
<i>4771</i>&nbsp;     * static int inc(int i, int acc, int k) { return i + 1; }
<i>4772</i>&nbsp;     * static int mult(int i, int acc, int k) { return i * acc; }
<i>4773</i>&nbsp;     * static boolean pred(int i, int acc, int k) { return i &lt; k; }
<i>4774</i>&nbsp;     * static int fin(int i, int acc, int k) { return acc; }
<i>4775</i>&nbsp;     * // assume MH_one, MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
<i>4776</i>&nbsp;     * // null initializer for counter, should initialize to 0
<i>4777</i>&nbsp;     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
<i>4778</i>&nbsp;     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
<i>4779</i>&nbsp;     * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
<i>4780</i>&nbsp;     * assertEquals(120, loop.invoke(5));
<i>4781</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4782</i>&nbsp;     * The same example, dropping arguments and using combinators:
<i>4783</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4784</i>&nbsp;     * // simplified implementation of the factorial function as a loop handle
<i>4785</i>&nbsp;     * static int inc(int i) { return i + 1; } // drop acc, k
<i>4786</i>&nbsp;     * static int mult(int i, int acc) { return i * acc; } //drop k
<i>4787</i>&nbsp;     * static boolean cmp(int i, int k) { return i &lt; k; }
<i>4788</i>&nbsp;     * // assume MH_inc, MH_mult, and MH_cmp are handles to the above methods
<i>4789</i>&nbsp;     * // null initializer for counter, should initialize to 0
<i>4790</i>&nbsp;     * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
<i>4791</i>&nbsp;     * MethodHandle MH_pred = MethodHandles.dropArguments(MH_cmp, 1, int.class); // drop acc
<i>4792</i>&nbsp;     * MethodHandle MH_fin = MethodHandles.dropArguments(MethodHandles.identity(int.class), 0, int.class); // drop i
<i>4793</i>&nbsp;     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
<i>4794</i>&nbsp;     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
<i>4795</i>&nbsp;     * MethodHandle loop = MethodHandles.loop(counterClause, accumulatorClause);
<i>4796</i>&nbsp;     * assertEquals(720, loop.invoke(6));
<i>4797</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4798</i>&nbsp;     * A similar example, using a helper object to hold a loop parameter:
<i>4799</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>4800</i>&nbsp;     * // instance-based implementation of the factorial function as a loop handle
<i>4801</i>&nbsp;     * static class FacLoop {
<i>4802</i>&nbsp;     *   final int k;
<i>4803</i>&nbsp;     *   FacLoop(int k) { this.k = k; }
<i>4804</i>&nbsp;     *   int inc(int i) { return i + 1; }
<i>4805</i>&nbsp;     *   int mult(int i, int acc) { return i * acc; }
<i>4806</i>&nbsp;     *   boolean pred(int i) { return i &lt; k; }
<i>4807</i>&nbsp;     *   int fin(int i, int acc) { return acc; }
<i>4808</i>&nbsp;     * }
<i>4809</i>&nbsp;     * // assume MH_FacLoop is a handle to the constructor
<i>4810</i>&nbsp;     * // assume MH_inc, MH_mult, MH_pred, and MH_fin are handles to the above methods
<i>4811</i>&nbsp;     * // null initializer for counter, should initialize to 0
<i>4812</i>&nbsp;     * MethodHandle MH_one = MethodHandles.constant(int.class, 1);
<i>4813</i>&nbsp;     * MethodHandle[] instanceClause = new MethodHandle[]{MH_FacLoop};
<i>4814</i>&nbsp;     * MethodHandle[] counterClause = new MethodHandle[]{null, MH_inc};
<i>4815</i>&nbsp;     * MethodHandle[] accumulatorClause = new MethodHandle[]{MH_one, MH_mult, MH_pred, MH_fin};
<i>4816</i>&nbsp;     * MethodHandle loop = MethodHandles.loop(instanceClause, counterClause, accumulatorClause);
<i>4817</i>&nbsp;     * assertEquals(5040, loop.invoke(7));
<i>4818</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>4819</i>&nbsp;     *
<i>4820</i>&nbsp;     * @param clauses an array of arrays (4-tuples) of {@link MethodHandle}s adhering to the rules described above.
<i>4821</i>&nbsp;     *
<i>4822</i>&nbsp;     * @return a method handle embodying the looping behavior as defined by the arguments.
<i>4823</i>&nbsp;     *
<i>4824</i>&nbsp;     * @throws IllegalArgumentException in case any of the constraints described above is violated.
<i>4825</i>&nbsp;     *
<i>4826</i>&nbsp;     * @see MethodHandles#whileLoop(MethodHandle, MethodHandle, MethodHandle)
<i>4827</i>&nbsp;     * @see MethodHandles#doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
<i>4828</i>&nbsp;     * @see MethodHandles#countedLoop(MethodHandle, MethodHandle, MethodHandle)
<i>4829</i>&nbsp;     * @see MethodHandles#iteratedLoop(MethodHandle, MethodHandle, MethodHandle)
<i>4830</i>&nbsp;     * @since 9
<i>4831</i>&nbsp;     */
<i>4832</i>&nbsp;    public static MethodHandle loop(MethodHandle[]... clauses) {
<i>4833</i>&nbsp;        // Step 0: determine clause structure.
<i>4834</i>&nbsp;        loopChecks0(clauses);
<i>4835</i>&nbsp;
<i>4836</i>&nbsp;        List&lt;MethodHandle&gt; init = new ArrayList&lt;&gt;();
<i>4837</i>&nbsp;        List&lt;MethodHandle&gt; step = new ArrayList&lt;&gt;();
<i>4838</i>&nbsp;        List&lt;MethodHandle&gt; pred = new ArrayList&lt;&gt;();
<i>4839</i>&nbsp;        List&lt;MethodHandle&gt; fini = new ArrayList&lt;&gt;();
<i>4840</i>&nbsp;
<i>4841</i>&nbsp;        Stream.of(clauses).filter(c -&gt; Stream.of(c).anyMatch(Objects::nonNull)).forEach(clause -&gt; {
<i>4842</i>&nbsp;            init.add(clause[0]); // all clauses have at least length 1
<i>4843</i>&nbsp;            step.add(clause.length &lt;= 1 ? null : clause[1]);
<i>4844</i>&nbsp;            pred.add(clause.length &lt;= 2 ? null : clause[2]);
<i>4845</i>&nbsp;            fini.add(clause.length &lt;= 3 ? null : clause[3]);
<i>4846</i>&nbsp;        });
<i>4847</i>&nbsp;
<i>4848</i>&nbsp;        assert Stream.of(init, step, pred, fini).map(List::size).distinct().count() == 1;
<i>4849</i>&nbsp;        final int nclauses = init.size();
<i>4850</i>&nbsp;
<i>4851</i>&nbsp;        // Step 1A: determine iteration variables (V...).
<i>4852</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; iterationVariableTypes = new ArrayList&lt;&gt;();
<i>4853</i>&nbsp;        for (int i = 0; i &lt; nclauses; ++i) {
<i>4854</i>&nbsp;            MethodHandle in = init.get(i);
<i>4855</i>&nbsp;            MethodHandle st = step.get(i);
<i>4856</i>&nbsp;            if (in == null &amp;&amp; st == null) {
<i>4857</i>&nbsp;                iterationVariableTypes.add(void.class);
<i>4858</i>&nbsp;            } else if (in != null &amp;&amp; st != null) {
<i>4859</i>&nbsp;                loopChecks1a(i, in, st);
<i>4860</i>&nbsp;                iterationVariableTypes.add(in.type().returnType());
<i>4861</i>&nbsp;            } else {
<i>4862</i>&nbsp;                iterationVariableTypes.add(in == null ? st.type().returnType() : in.type().returnType());
<i>4863</i>&nbsp;            }
<i>4864</i>&nbsp;        }
<i>4865</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; commonPrefix = iterationVariableTypes.stream().filter(t -&gt; t != void.class).
<i>4866</i>&nbsp;                collect(Collectors.toList());
<i>4867</i>&nbsp;
<i>4868</i>&nbsp;        // Step 1B: determine loop parameters (A...).
<i>4869</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; commonSuffix = buildCommonSuffix(init, step, pred, fini, commonPrefix.size());
<i>4870</i>&nbsp;        loopChecks1b(init, commonSuffix);
<i>4871</i>&nbsp;
<i>4872</i>&nbsp;        // Step 1C: determine loop return type.
<i>4873</i>&nbsp;        // Step 1D: check other types.
<i>4874</i>&nbsp;        final Class&lt;?&gt; loopReturnType = fini.stream().filter(Objects::nonNull).map(MethodHandle::type).
<i>4875</i>&nbsp;                map(MethodType::returnType).findFirst().orElse(void.class);
<i>4876</i>&nbsp;        loopChecks1cd(pred, fini, loopReturnType);
<i>4877</i>&nbsp;
<i>4878</i>&nbsp;        // Step 2: determine parameter lists.
<i>4879</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; commonParameterSequence = new ArrayList&lt;&gt;(commonPrefix);
<i>4880</i>&nbsp;        commonParameterSequence.addAll(commonSuffix);
<i>4881</i>&nbsp;        loopChecks2(step, pred, fini, commonParameterSequence);
<i>4882</i>&nbsp;
<i>4883</i>&nbsp;        // Step 3: fill in omitted functions.
<i>4884</i>&nbsp;        for (int i = 0; i &lt; nclauses; ++i) {
<i>4885</i>&nbsp;            Class&lt;?&gt; t = iterationVariableTypes.get(i);
<i>4886</i>&nbsp;            if (init.get(i) == null) {
<i>4887</i>&nbsp;                init.set(i, empty(methodType(t, commonSuffix)));
<i>4888</i>&nbsp;            }
<i>4889</i>&nbsp;            if (step.get(i) == null) {
<i>4890</i>&nbsp;                step.set(i, dropArgumentsToMatch(identityOrVoid(t), 0, commonParameterSequence, i));
<i>4891</i>&nbsp;            }
<i>4892</i>&nbsp;            if (pred.get(i) == null) {
<i>4893</i>&nbsp;                pred.set(i, dropArguments0(constant(boolean.class, true), 0, commonParameterSequence));
<i>4894</i>&nbsp;            }
<i>4895</i>&nbsp;            if (fini.get(i) == null) {
<i>4896</i>&nbsp;                fini.set(i, empty(methodType(t, commonParameterSequence)));
<i>4897</i>&nbsp;            }
<i>4898</i>&nbsp;        }
<i>4899</i>&nbsp;
<i>4900</i>&nbsp;        // Step 4: fill in missing parameter types.
<i>4901</i>&nbsp;        // Also convert all handles to fixed-arity handles.
<i>4902</i>&nbsp;        List&lt;MethodHandle&gt; finit = fixArities(fillParameterTypes(init, commonSuffix));
<i>4903</i>&nbsp;        List&lt;MethodHandle&gt; fstep = fixArities(fillParameterTypes(step, commonParameterSequence));
<i>4904</i>&nbsp;        List&lt;MethodHandle&gt; fpred = fixArities(fillParameterTypes(pred, commonParameterSequence));
<i>4905</i>&nbsp;        List&lt;MethodHandle&gt; ffini = fixArities(fillParameterTypes(fini, commonParameterSequence));
<i>4906</i>&nbsp;
<i>4907</i>&nbsp;        assert finit.stream().map(MethodHandle::type).map(MethodType::parameterList).
<i>4908</i>&nbsp;                allMatch(pl -&gt; pl.equals(commonSuffix));
<i>4909</i>&nbsp;        assert Stream.of(fstep, fpred, ffini).flatMap(List::stream).map(MethodHandle::type).map(MethodType::parameterList).
<i>4910</i>&nbsp;                allMatch(pl -&gt; pl.equals(commonParameterSequence));
<i>4911</i>&nbsp;
<i>4912</i>&nbsp;        return MethodHandleImpl.makeLoop(loopReturnType, commonSuffix, finit, fstep, fpred, ffini);
<i>4913</i>&nbsp;    }
<i>4914</i>&nbsp;
<i>4915</i>&nbsp;    private static void loopChecks0(MethodHandle[][] clauses) {
<i>4916</i>&nbsp;        if (clauses == null || clauses.length == 0) {
<i>4917</i>&nbsp;            throw newIllegalArgumentException(&quot;null or no clauses passed&quot;);
<i>4918</i>&nbsp;        }
<i>4919</i>&nbsp;        if (Stream.of(clauses).anyMatch(Objects::isNull)) {
<i>4920</i>&nbsp;            throw newIllegalArgumentException(&quot;null clauses are not allowed&quot;);
<i>4921</i>&nbsp;        }
<i>4922</i>&nbsp;        if (Stream.of(clauses).anyMatch(c -&gt; c.length &gt; 4)) {
<i>4923</i>&nbsp;            throw newIllegalArgumentException(&quot;All loop clauses must be represented as MethodHandle arrays with at most 4 elements.&quot;);
<i>4924</i>&nbsp;        }
<i>4925</i>&nbsp;    }
<i>4926</i>&nbsp;
<i>4927</i>&nbsp;    private static void loopChecks1a(int i, MethodHandle in, MethodHandle st) {
<i>4928</i>&nbsp;        if (in.type().returnType() != st.type().returnType()) {
<i>4929</i>&nbsp;            throw misMatchedTypes(&quot;clause &quot; + i + &quot;: init and step return types&quot;, in.type().returnType(),
<i>4930</i>&nbsp;                    st.type().returnType());
<i>4931</i>&nbsp;        }
<i>4932</i>&nbsp;    }
<i>4933</i>&nbsp;
<i>4934</i>&nbsp;    private static List&lt;Class&lt;?&gt;&gt; longestParameterList(Stream&lt;MethodHandle&gt; mhs, int skipSize) {
<i>4935</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; empty = List.of();
<i>4936</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; longest = mhs.filter(Objects::nonNull).
<i>4937</i>&nbsp;                // take only those that can contribute to a common suffix because they are longer than the prefix
<i>4938</i>&nbsp;                        map(MethodHandle::type).
<i>4939</i>&nbsp;                        filter(t -&gt; t.parameterCount() &gt; skipSize).
<i>4940</i>&nbsp;                        map(MethodType::parameterList).
<i>4941</i>&nbsp;                        reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
<i>4942</i>&nbsp;        return longest.size() == 0 ? empty : longest.subList(skipSize, longest.size());
<i>4943</i>&nbsp;    }
<i>4944</i>&nbsp;
<i>4945</i>&nbsp;    private static List&lt;Class&lt;?&gt;&gt; longestParameterList(List&lt;List&lt;Class&lt;?&gt;&gt;&gt; lists) {
<i>4946</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; empty = List.of();
<i>4947</i>&nbsp;        return lists.stream().reduce((p, q) -&gt; p.size() &gt;= q.size() ? p : q).orElse(empty);
<i>4948</i>&nbsp;    }
<i>4949</i>&nbsp;
<i>4950</i>&nbsp;    private static List&lt;Class&lt;?&gt;&gt; buildCommonSuffix(List&lt;MethodHandle&gt; init, List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, int cpSize) {
<i>4951</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; longest1 = longestParameterList(Stream.of(step, pred, fini).flatMap(List::stream), cpSize);
<i>4952</i>&nbsp;        final List&lt;Class&lt;?&gt;&gt; longest2 = longestParameterList(init.stream(), 0);
<i>4953</i>&nbsp;        return longestParameterList(Arrays.asList(longest1, longest2));
<i>4954</i>&nbsp;    }
<i>4955</i>&nbsp;
<i>4956</i>&nbsp;    private static void loopChecks1b(List&lt;MethodHandle&gt; init, List&lt;Class&lt;?&gt;&gt; commonSuffix) {
<i>4957</i>&nbsp;        if (init.stream().filter(Objects::nonNull).map(MethodHandle::type).
<i>4958</i>&nbsp;                anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonSuffix))) {
<i>4959</i>&nbsp;            throw newIllegalArgumentException(&quot;found non-effectively identical init parameter type lists: &quot; + init +
<i>4960</i>&nbsp;                    &quot; (common suffix: &quot; + commonSuffix + &quot;)&quot;);
<i>4961</i>&nbsp;        }
<i>4962</i>&nbsp;    }
<i>4963</i>&nbsp;
<i>4964</i>&nbsp;    private static void loopChecks1cd(List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, Class&lt;?&gt; loopReturnType) {
<i>4965</i>&nbsp;        if (fini.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
<i>4966</i>&nbsp;                anyMatch(t -&gt; t != loopReturnType)) {
<i>4967</i>&nbsp;            throw newIllegalArgumentException(&quot;found non-identical finalizer return types: &quot; + fini + &quot; (return type: &quot; +
<i>4968</i>&nbsp;                    loopReturnType + &quot;)&quot;);
<i>4969</i>&nbsp;        }
<i>4970</i>&nbsp;
<i>4971</i>&nbsp;        if (!pred.stream().filter(Objects::nonNull).findFirst().isPresent()) {
<i>4972</i>&nbsp;            throw newIllegalArgumentException(&quot;no predicate found&quot;, pred);
<i>4973</i>&nbsp;        }
<i>4974</i>&nbsp;        if (pred.stream().filter(Objects::nonNull).map(MethodHandle::type).map(MethodType::returnType).
<i>4975</i>&nbsp;                anyMatch(t -&gt; t != boolean.class)) {
<i>4976</i>&nbsp;            throw newIllegalArgumentException(&quot;predicates must have boolean return type&quot;, pred);
<i>4977</i>&nbsp;        }
<i>4978</i>&nbsp;    }
<i>4979</i>&nbsp;
<i>4980</i>&nbsp;    private static void loopChecks2(List&lt;MethodHandle&gt; step, List&lt;MethodHandle&gt; pred, List&lt;MethodHandle&gt; fini, List&lt;Class&lt;?&gt;&gt; commonParameterSequence) {
<i>4981</i>&nbsp;        if (Stream.of(step, pred, fini).flatMap(List::stream).filter(Objects::nonNull).map(MethodHandle::type).
<i>4982</i>&nbsp;                anyMatch(t -&gt; !t.effectivelyIdenticalParameters(0, commonParameterSequence))) {
<i>4983</i>&nbsp;            throw newIllegalArgumentException(&quot;found non-effectively identical parameter type lists:\nstep: &quot; + step +
<i>4984</i>&nbsp;                    &quot;\npred: &quot; + pred + &quot;\nfini: &quot; + fini + &quot; (common parameter sequence: &quot; + commonParameterSequence + &quot;)&quot;);
<i>4985</i>&nbsp;        }
<i>4986</i>&nbsp;    }
<i>4987</i>&nbsp;
<i>4988</i>&nbsp;    private static List&lt;MethodHandle&gt; fillParameterTypes(List&lt;MethodHandle&gt; hs, final List&lt;Class&lt;?&gt;&gt; targetParams) {
<i>4989</i>&nbsp;        return hs.stream().map(h -&gt; {
<i>4990</i>&nbsp;            int pc = h.type().parameterCount();
<i>4991</i>&nbsp;            int tpsize = targetParams.size();
<i>4992</i>&nbsp;            return pc &lt; tpsize ? dropArguments0(h, pc, targetParams.subList(pc, tpsize)) : h;
<i>4993</i>&nbsp;        }).collect(Collectors.toList());
<i>4994</i>&nbsp;    }
<i>4995</i>&nbsp;
<i>4996</i>&nbsp;    private static List&lt;MethodHandle&gt; fixArities(List&lt;MethodHandle&gt; hs) {
<i>4997</i>&nbsp;        return hs.stream().map(MethodHandle::asFixedArity).collect(Collectors.toList());
<i>4998</i>&nbsp;    }
<i>4999</i>&nbsp;
<i>5000</i>&nbsp;    /**
<i>5001</i>&nbsp;     * Constructs a {@code while} loop from an initializer, a body, and a predicate.
<i>5002</i>&nbsp;     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
<i>5003</i>&nbsp;     * &lt;p&gt;
<i>5004</i>&nbsp;     * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
<i>5005</i>&nbsp;     * method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate
<i>5006</i>&nbsp;     * evaluates to {@code true}).
<i>5007</i>&nbsp;     * The loop will terminate once the predicate evaluates to {@code false} (the body will not be executed in this case).
<i>5008</i>&nbsp;     * &lt;p&gt;
<i>5009</i>&nbsp;     * The {@code init} handle describes the initial value of an additional optional loop-local variable.
<i>5010</i>&nbsp;     * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
<i>5011</i>&nbsp;     * and updated with the value returned from its invocation. The result of loop execution will be
<i>5012</i>&nbsp;     * the final value of the additional loop-local variable (if present).
<i>5013</i>&nbsp;     * &lt;p&gt;
<i>5014</i>&nbsp;     * The following rules hold for these argument handles:&lt;ul&gt;
<i>5015</i>&nbsp;     * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
<i>5016</i>&nbsp;     * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
<i>5017</i>&nbsp;     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
<i>5018</i>&nbsp;     * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
<i>5019</i>&nbsp;     * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
<i>5020</i>&nbsp;     * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
<i>5021</i>&nbsp;     * It will constrain the parameter lists of the other loop parts.
<i>5022</i>&nbsp;     * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
<i>5023</i>&nbsp;     * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
<i>5024</i>&nbsp;     * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
<i>5025</i>&nbsp;     * additional state variable of the loop.
<i>5026</i>&nbsp;     * The body must both accept and return a value of this type {@code V}.
<i>5027</i>&nbsp;     * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
<i>5028</i>&nbsp;     * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
<i>5029</i>&nbsp;     * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
<i>5030</i>&nbsp;     * to the external parameter list {@code (A...)}.
<i>5031</i>&nbsp;     * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
<i>5032</i>&nbsp;     * {@linkplain #empty default value}.
<i>5033</i>&nbsp;     * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
<i>5034</i>&nbsp;     * Its parameter list (either empty or of the form {@code (V A*)}) must be
<i>5035</i>&nbsp;     * effectively identical to the internal parameter list.
<i>5036</i>&nbsp;     * &lt;/ul&gt;
<i>5037</i>&nbsp;     * &lt;p&gt;
<i>5038</i>&nbsp;     * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
<i>5039</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
<i>5040</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
<i>5041</i>&nbsp;     * from the external parameter list.
<i>5042</i>&nbsp;     * &lt;/ul&gt;
<i>5043</i>&nbsp;     * &lt;p&gt;
<i>5044</i>&nbsp;     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
<i>5045</i>&nbsp;     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
<i>5046</i>&nbsp;     * passed to the loop.
<i>5047</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5048</i>&nbsp;     * V init(A...);
<i>5049</i>&nbsp;     * boolean pred(V, A...);
<i>5050</i>&nbsp;     * V body(V, A...);
<i>5051</i>&nbsp;     * V whileLoop(A... a...) {
<i>5052</i>&nbsp;     *   V v = init(a...);
<i>5053</i>&nbsp;     *   while (pred(v, a...)) {
<i>5054</i>&nbsp;     *     v = body(v, a...);
<i>5055</i>&nbsp;     *   }
<i>5056</i>&nbsp;     *   return v;
<i>5057</i>&nbsp;     * }
<i>5058</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5059</i>&nbsp;     *
<i>5060</i>&nbsp;     * @apiNote Example:
<i>5061</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5062</i>&nbsp;     * // implement the zip function for lists as a loop handle
<i>5063</i>&nbsp;     * static List&lt;String&gt; initZip(Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return new ArrayList&lt;&gt;(); }
<i>5064</i>&nbsp;     * static boolean zipPred(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) { return a.hasNext() &amp;&amp; b.hasNext(); }
<i>5065</i>&nbsp;     * static List&lt;String&gt; zipStep(List&lt;String&gt; zip, Iterator&lt;String&gt; a, Iterator&lt;String&gt; b) {
<i>5066</i>&nbsp;     *   zip.add(a.next());
<i>5067</i>&nbsp;     *   zip.add(b.next());
<i>5068</i>&nbsp;     *   return zip;
<i>5069</i>&nbsp;     * }
<i>5070</i>&nbsp;     * // assume MH_initZip, MH_zipPred, and MH_zipStep are handles to the above methods
<i>5071</i>&nbsp;     * MethodHandle loop = MethodHandles.whileLoop(MH_initZip, MH_zipPred, MH_zipStep);
<i>5072</i>&nbsp;     * List&lt;String&gt; a = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
<i>5073</i>&nbsp;     * List&lt;String&gt; b = Arrays.asList(&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;);
<i>5074</i>&nbsp;     * List&lt;String&gt; zipped = Arrays.asList(&quot;a&quot;, &quot;e&quot;, &quot;b&quot;, &quot;f&quot;, &quot;c&quot;, &quot;g&quot;, &quot;d&quot;, &quot;h&quot;);
<i>5075</i>&nbsp;     * assertEquals(zipped, (List&lt;String&gt;) loop.invoke(a.iterator(), b.iterator()));
<i>5076</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5077</i>&nbsp;     *
<i>5078</i>&nbsp;     *
<i>5079</i>&nbsp;     * @apiNote The implementation of this method can be expressed as follows:
<i>5080</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5081</i>&nbsp;     * MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
<i>5082</i>&nbsp;     *     MethodHandle fini = (body.type().returnType() == void.class
<i>5083</i>&nbsp;     *                         ? null : identity(body.type().returnType()));
<i>5084</i>&nbsp;     *     MethodHandle[]
<i>5085</i>&nbsp;     *         checkExit = { null, null, pred, fini },
<i>5086</i>&nbsp;     *         varBody   = { init, body };
<i>5087</i>&nbsp;     *     return loop(checkExit, varBody);
<i>5088</i>&nbsp;     * }
<i>5089</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5090</i>&nbsp;     *
<i>5091</i>&nbsp;     * @param init optional initializer, providing the initial value of the loop variable.
<i>5092</i>&nbsp;     *             May be {@code null}, implying a default initial value.  See above for other constraints.
<i>5093</i>&nbsp;     * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
<i>5094</i>&nbsp;     *             above for other constraints.
<i>5095</i>&nbsp;     * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
<i>5096</i>&nbsp;     *             See above for other constraints.
<i>5097</i>&nbsp;     *
<i>5098</i>&nbsp;     * @return a method handle implementing the {@code while} loop as described by the arguments.
<i>5099</i>&nbsp;     * @throws IllegalArgumentException if the rules for the arguments are violated.
<i>5100</i>&nbsp;     * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
<i>5101</i>&nbsp;     *
<i>5102</i>&nbsp;     * @see #loop(MethodHandle[][])
<i>5103</i>&nbsp;     * @see #doWhileLoop(MethodHandle, MethodHandle, MethodHandle)
<i>5104</i>&nbsp;     * @since 9
<i>5105</i>&nbsp;     */
<i>5106</i>&nbsp;    public static MethodHandle whileLoop(MethodHandle init, MethodHandle pred, MethodHandle body) {
<i>5107</i>&nbsp;        whileLoopChecks(init, pred, body);
<i>5108</i>&nbsp;        MethodHandle fini = identityOrVoid(body.type().returnType());
<i>5109</i>&nbsp;        MethodHandle[] checkExit = { null, null, pred, fini };
<i>5110</i>&nbsp;        MethodHandle[] varBody = { init, body };
<i>5111</i>&nbsp;        return loop(checkExit, varBody);
<i>5112</i>&nbsp;    }
<i>5113</i>&nbsp;
<i>5114</i>&nbsp;    /**
<i>5115</i>&nbsp;     * Constructs a {@code do-while} loop from an initializer, a body, and a predicate.
<i>5116</i>&nbsp;     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
<i>5117</i>&nbsp;     * &lt;p&gt;
<i>5118</i>&nbsp;     * The {@code pred} handle describes the loop condition; and {@code body}, its body. The loop resulting from this
<i>5119</i>&nbsp;     * method will, in each iteration, first execute its body and then evaluate the predicate.
<i>5120</i>&nbsp;     * The loop will terminate once the predicate evaluates to {@code false} after an execution of the body.
<i>5121</i>&nbsp;     * &lt;p&gt;
<i>5122</i>&nbsp;     * The {@code init} handle describes the initial value of an additional optional loop-local variable.
<i>5123</i>&nbsp;     * In each iteration, this loop-local variable, if present, will be passed to the {@code body}
<i>5124</i>&nbsp;     * and updated with the value returned from its invocation. The result of loop execution will be
<i>5125</i>&nbsp;     * the final value of the additional loop-local variable (if present).
<i>5126</i>&nbsp;     * &lt;p&gt;
<i>5127</i>&nbsp;     * The following rules hold for these argument handles:&lt;ul&gt;
<i>5128</i>&nbsp;     * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
<i>5129</i>&nbsp;     * {@code (V A...)V}, where {@code V} is non-{@code void}, or else {@code (A...)void}.
<i>5130</i>&nbsp;     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
<i>5131</i>&nbsp;     * and we will write {@code (V A...)V} with the understanding that a {@code void} type {@code V}
<i>5132</i>&nbsp;     * is quietly dropped from the parameter list, leaving {@code (A...)V}.)
<i>5133</i>&nbsp;     * &lt;li&gt;The parameter list {@code (V A...)} of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
<i>5134</i>&nbsp;     * It will constrain the parameter lists of the other loop parts.
<i>5135</i>&nbsp;     * &lt;li&gt;If the iteration variable type {@code V} is dropped from the internal parameter list, the resulting shorter
<i>5136</i>&nbsp;     * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
<i>5137</i>&nbsp;     * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
<i>5138</i>&nbsp;     * additional state variable of the loop.
<i>5139</i>&nbsp;     * The body must both accept and return a value of this type {@code V}.
<i>5140</i>&nbsp;     * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
<i>5141</i>&nbsp;     * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
<i>5142</i>&nbsp;     * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
<i>5143</i>&nbsp;     * to the external parameter list {@code (A...)}.
<i>5144</i>&nbsp;     * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
<i>5145</i>&nbsp;     * {@linkplain #empty default value}.
<i>5146</i>&nbsp;     * &lt;li&gt;The {@code pred} handle must not be {@code null}.  It must have {@code boolean} as its return type.
<i>5147</i>&nbsp;     * Its parameter list (either empty or of the form {@code (V A*)}) must be
<i>5148</i>&nbsp;     * effectively identical to the internal parameter list.
<i>5149</i>&nbsp;     * &lt;/ul&gt;
<i>5150</i>&nbsp;     * &lt;p&gt;
<i>5151</i>&nbsp;     * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
<i>5152</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
<i>5153</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
<i>5154</i>&nbsp;     * from the external parameter list.
<i>5155</i>&nbsp;     * &lt;/ul&gt;
<i>5156</i>&nbsp;     * &lt;p&gt;
<i>5157</i>&nbsp;     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
<i>5158</i>&nbsp;     * the sole loop variable as well as the result type of the loop; and {@code A}/{@code a}, that of the argument
<i>5159</i>&nbsp;     * passed to the loop.
<i>5160</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5161</i>&nbsp;     * V init(A...);
<i>5162</i>&nbsp;     * boolean pred(V, A...);
<i>5163</i>&nbsp;     * V body(V, A...);
<i>5164</i>&nbsp;     * V doWhileLoop(A... a...) {
<i>5165</i>&nbsp;     *   V v = init(a...);
<i>5166</i>&nbsp;     *   do {
<i>5167</i>&nbsp;     *     v = body(v, a...);
<i>5168</i>&nbsp;     *   } while (pred(v, a...));
<i>5169</i>&nbsp;     *   return v;
<i>5170</i>&nbsp;     * }
<i>5171</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5172</i>&nbsp;     *
<i>5173</i>&nbsp;     * @apiNote Example:
<i>5174</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5175</i>&nbsp;     * // int i = 0; while (i &lt; limit) { ++i; } return i; =&gt; limit
<i>5176</i>&nbsp;     * static int zero(int limit) { return 0; }
<i>5177</i>&nbsp;     * static int step(int i, int limit) { return i + 1; }
<i>5178</i>&nbsp;     * static boolean pred(int i, int limit) { return i &lt; limit; }
<i>5179</i>&nbsp;     * // assume MH_zero, MH_step, and MH_pred are handles to the above methods
<i>5180</i>&nbsp;     * MethodHandle loop = MethodHandles.doWhileLoop(MH_zero, MH_step, MH_pred);
<i>5181</i>&nbsp;     * assertEquals(23, loop.invoke(23));
<i>5182</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5183</i>&nbsp;     *
<i>5184</i>&nbsp;     *
<i>5185</i>&nbsp;     * @apiNote The implementation of this method can be expressed as follows:
<i>5186</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5187</i>&nbsp;     * MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
<i>5188</i>&nbsp;     *     MethodHandle fini = (body.type().returnType() == void.class
<i>5189</i>&nbsp;     *                         ? null : identity(body.type().returnType()));
<i>5190</i>&nbsp;     *     MethodHandle[] clause = { init, body, pred, fini };
<i>5191</i>&nbsp;     *     return loop(clause);
<i>5192</i>&nbsp;     * }
<i>5193</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5194</i>&nbsp;     *
<i>5195</i>&nbsp;     * @param init optional initializer, providing the initial value of the loop variable.
<i>5196</i>&nbsp;     *             May be {@code null}, implying a default initial value.  See above for other constraints.
<i>5197</i>&nbsp;     * @param body body of the loop, which may not be {@code null}. It controls the loop parameters and result type.
<i>5198</i>&nbsp;     *             See above for other constraints.
<i>5199</i>&nbsp;     * @param pred condition for the loop, which may not be {@code null}. Its result type must be {@code boolean}. See
<i>5200</i>&nbsp;     *             above for other constraints.
<i>5201</i>&nbsp;     *
<i>5202</i>&nbsp;     * @return a method handle implementing the {@code while} loop as described by the arguments.
<i>5203</i>&nbsp;     * @throws IllegalArgumentException if the rules for the arguments are violated.
<i>5204</i>&nbsp;     * @throws NullPointerException if {@code pred} or {@code body} are {@code null}.
<i>5205</i>&nbsp;     *
<i>5206</i>&nbsp;     * @see #loop(MethodHandle[][])
<i>5207</i>&nbsp;     * @see #whileLoop(MethodHandle, MethodHandle, MethodHandle)
<i>5208</i>&nbsp;     * @since 9
<i>5209</i>&nbsp;     */
<i>5210</i>&nbsp;    public static MethodHandle doWhileLoop(MethodHandle init, MethodHandle body, MethodHandle pred) {
<i>5211</i>&nbsp;        whileLoopChecks(init, pred, body);
<i>5212</i>&nbsp;        MethodHandle fini = identityOrVoid(body.type().returnType());
<i>5213</i>&nbsp;        MethodHandle[] clause = {init, body, pred, fini };
<i>5214</i>&nbsp;        return loop(clause);
<i>5215</i>&nbsp;    }
<i>5216</i>&nbsp;
<i>5217</i>&nbsp;    private static void whileLoopChecks(MethodHandle init, MethodHandle pred, MethodHandle body) {
<i>5218</i>&nbsp;        Objects.requireNonNull(pred);
<i>5219</i>&nbsp;        Objects.requireNonNull(body);
<i>5220</i>&nbsp;        MethodType bodyType = body.type();
<i>5221</i>&nbsp;        Class&lt;?&gt; returnType = bodyType.returnType();
<i>5222</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
<i>5223</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; outerList = innerList;
<i>5224</i>&nbsp;        if (returnType == void.class) {
<i>5225</i>&nbsp;            // OK
<i>5226</i>&nbsp;        } else if (innerList.size() == 0 || innerList.get(0) != returnType) {
<i>5227</i>&nbsp;            // leading V argument missing =&gt; error
<i>5228</i>&nbsp;            MethodType expected = bodyType.insertParameterTypes(0, returnType);
<i>5229</i>&nbsp;            throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
<i>5230</i>&nbsp;        } else {
<i>5231</i>&nbsp;            outerList = innerList.subList(1, innerList.size());
<i>5232</i>&nbsp;        }
<i>5233</i>&nbsp;        MethodType predType = pred.type();
<i>5234</i>&nbsp;        if (predType.returnType() != boolean.class ||
<i>5235</i>&nbsp;                !predType.effectivelyIdenticalParameters(0, innerList)) {
<i>5236</i>&nbsp;            throw misMatchedTypes(&quot;loop predicate&quot;, predType, methodType(boolean.class, innerList));
<i>5237</i>&nbsp;        }
<i>5238</i>&nbsp;        if (init != null) {
<i>5239</i>&nbsp;            MethodType initType = init.type();
<i>5240</i>&nbsp;            if (initType.returnType() != returnType ||
<i>5241</i>&nbsp;                    !initType.effectivelyIdenticalParameters(0, outerList)) {
<i>5242</i>&nbsp;                throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
<i>5243</i>&nbsp;            }
<i>5244</i>&nbsp;        }
<i>5245</i>&nbsp;    }
<i>5246</i>&nbsp;
<i>5247</i>&nbsp;    /**
<i>5248</i>&nbsp;     * Constructs a loop that runs a given number of iterations.
<i>5249</i>&nbsp;     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
<i>5250</i>&nbsp;     * &lt;p&gt;
<i>5251</i>&nbsp;     * The number of iterations is determined by the {@code iterations} handle evaluation result.
<i>5252</i>&nbsp;     * The loop counter {@code i} is an extra loop iteration variable of type {@code int}.
<i>5253</i>&nbsp;     * It will be initialized to 0 and incremented by 1 in each iteration.
<i>5254</i>&nbsp;     * &lt;p&gt;
<i>5255</i>&nbsp;     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
<i>5256</i>&nbsp;     * of that type is also present.  This variable is initialized using the optional {@code init} handle,
<i>5257</i>&nbsp;     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
<i>5258</i>&nbsp;     * &lt;p&gt;
<i>5259</i>&nbsp;     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
<i>5260</i>&nbsp;     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
<i>5261</i>&nbsp;     * iteration variable.
<i>5262</i>&nbsp;     * The result of the loop handle execution will be the final {@code V} value of that variable
<i>5263</i>&nbsp;     * (or {@code void} if there is no {@code V} variable).
<i>5264</i>&nbsp;     * &lt;p&gt;
<i>5265</i>&nbsp;     * The following rules hold for the argument handles:&lt;ul&gt;
<i>5266</i>&nbsp;     * &lt;li&gt;The {@code iterations} handle must not be {@code null}, and must return
<i>5267</i>&nbsp;     * the type {@code int}, referred to here as {@code I} in parameter type lists.
<i>5268</i>&nbsp;     * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
<i>5269</i>&nbsp;     * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
<i>5270</i>&nbsp;     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
<i>5271</i>&nbsp;     * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
<i>5272</i>&nbsp;     * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
<i>5273</i>&nbsp;     * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
<i>5274</i>&nbsp;     * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
<i>5275</i>&nbsp;     * It will constrain the parameter lists of the other loop parts.
<i>5276</i>&nbsp;     * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
<i>5277</i>&nbsp;     * with no additional {@code A} types, then the internal parameter list is extended by
<i>5278</i>&nbsp;     * the argument types {@code A...} of the {@code iterations} handle.
<i>5279</i>&nbsp;     * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
<i>5280</i>&nbsp;     * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
<i>5281</i>&nbsp;     * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
<i>5282</i>&nbsp;     * additional state variable of the loop.
<i>5283</i>&nbsp;     * The body must both accept a leading parameter and return a value of this type {@code V}.
<i>5284</i>&nbsp;     * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
<i>5285</i>&nbsp;     * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
<i>5286</i>&nbsp;     * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
<i>5287</i>&nbsp;     * to the external parameter list {@code (A...)}.
<i>5288</i>&nbsp;     * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
<i>5289</i>&nbsp;     * {@linkplain #empty default value}.
<i>5290</i>&nbsp;     * &lt;li&gt;The parameter list of {@code iterations} (of some form {@code (A*)}) must be
<i>5291</i>&nbsp;     * effectively identical to the external parameter list {@code (A...)}.
<i>5292</i>&nbsp;     * &lt;/ul&gt;
<i>5293</i>&nbsp;     * &lt;p&gt;
<i>5294</i>&nbsp;     * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
<i>5295</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
<i>5296</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
<i>5297</i>&nbsp;     * from the external parameter list.
<i>5298</i>&nbsp;     * &lt;/ul&gt;
<i>5299</i>&nbsp;     * &lt;p&gt;
<i>5300</i>&nbsp;     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
<i>5301</i>&nbsp;     * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
<i>5302</i>&nbsp;     * arguments passed to the loop.
<i>5303</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5304</i>&nbsp;     * int iterations(A...);
<i>5305</i>&nbsp;     * V init(A...);
<i>5306</i>&nbsp;     * V body(V, int, A...);
<i>5307</i>&nbsp;     * V countedLoop(A... a...) {
<i>5308</i>&nbsp;     *   int end = iterations(a...);
<i>5309</i>&nbsp;     *   V v = init(a...);
<i>5310</i>&nbsp;     *   for (int i = 0; i &lt; end; ++i) {
<i>5311</i>&nbsp;     *     v = body(v, i, a...);
<i>5312</i>&nbsp;     *   }
<i>5313</i>&nbsp;     *   return v;
<i>5314</i>&nbsp;     * }
<i>5315</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5316</i>&nbsp;     *
<i>5317</i>&nbsp;     * @apiNote Example with a fully conformant body method:
<i>5318</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5319</i>&nbsp;     * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
<i>5320</i>&nbsp;     * // =&gt; a variation on a well known theme
<i>5321</i>&nbsp;     * static String step(String v, int counter, String init) { return &quot;na &quot; + v; }
<i>5322</i>&nbsp;     * // assume MH_step is a handle to the method above
<i>5323</i>&nbsp;     * MethodHandle fit13 = MethodHandles.constant(int.class, 13);
<i>5324</i>&nbsp;     * MethodHandle start = MethodHandles.identity(String.class);
<i>5325</i>&nbsp;     * MethodHandle loop = MethodHandles.countedLoop(fit13, start, MH_step);
<i>5326</i>&nbsp;     * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;Lambdaman!&quot;));
<i>5327</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5328</i>&nbsp;     *
<i>5329</i>&nbsp;     * @apiNote Example with the simplest possible body method type,
<i>5330</i>&nbsp;     * and passing the number of iterations to the loop invocation:
<i>5331</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5332</i>&nbsp;     * // String s = &quot;Lambdaman!&quot;; for (int i = 0; i &lt; 13; ++i) { s = &quot;na &quot; + s; } return s;
<i>5333</i>&nbsp;     * // =&gt; a variation on a well known theme
<i>5334</i>&nbsp;     * static String step(String v, int counter ) { return &quot;na &quot; + v; }
<i>5335</i>&nbsp;     * // assume MH_step is a handle to the method above
<i>5336</i>&nbsp;     * MethodHandle count = MethodHandles.dropArguments(MethodHandles.identity(int.class), 1, String.class);
<i>5337</i>&nbsp;     * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class);
<i>5338</i>&nbsp;     * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i) -&gt; &quot;na &quot; + v
<i>5339</i>&nbsp;     * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;Lambdaman!&quot;));
<i>5340</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5341</i>&nbsp;     *
<i>5342</i>&nbsp;     * @apiNote Example that treats the number of iterations, string to append to, and string to append
<i>5343</i>&nbsp;     * as loop parameters:
<i>5344</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5345</i>&nbsp;     * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
<i>5346</i>&nbsp;     * // =&gt; a variation on a well known theme
<i>5347</i>&nbsp;     * static String step(String v, int counter, int iterations_, String pre, String start_) { return pre + &quot; &quot; + v; }
<i>5348</i>&nbsp;     * // assume MH_step is a handle to the method above
<i>5349</i>&nbsp;     * MethodHandle count = MethodHandles.identity(int.class);
<i>5350</i>&nbsp;     * MethodHandle start = MethodHandles.dropArguments(MethodHandles.identity(String.class), 0, int.class, String.class);
<i>5351</i>&nbsp;     * MethodHandle loop = MethodHandles.countedLoop(count, start, MH_step);  // (v, i, _, pre, _) -&gt; pre + &quot; &quot; + v
<i>5352</i>&nbsp;     * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(13, &quot;na&quot;, &quot;Lambdaman!&quot;));
<i>5353</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5354</i>&nbsp;     *
<i>5355</i>&nbsp;     * @apiNote Example that illustrates the usage of {@link #dropArgumentsToMatch(MethodHandle, int, List, int)}
<i>5356</i>&nbsp;     * to enforce a loop type:
<i>5357</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5358</i>&nbsp;     * // String s = &quot;Lambdaman!&quot;, t = &quot;na&quot;; for (int i = 0; i &lt; 13; ++i) { s = t + &quot; &quot; + s; } return s;
<i>5359</i>&nbsp;     * // =&gt; a variation on a well known theme
<i>5360</i>&nbsp;     * static String step(String v, int counter, String pre) { return pre + &quot; &quot; + v; }
<i>5361</i>&nbsp;     * // assume MH_step is a handle to the method above
<i>5362</i>&nbsp;     * MethodType loopType = methodType(String.class, String.class, int.class, String.class);
<i>5363</i>&nbsp;     * MethodHandle count = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(int.class),    0, loopType.parameterList(), 1);
<i>5364</i>&nbsp;     * MethodHandle start = MethodHandles.dropArgumentsToMatch(MethodHandles.identity(String.class), 0, loopType.parameterList(), 2);
<i>5365</i>&nbsp;     * MethodHandle body  = MethodHandles.dropArgumentsToMatch(MH_step,                              2, loopType.parameterList(), 0);
<i>5366</i>&nbsp;     * MethodHandle loop = MethodHandles.countedLoop(count, start, body);  // (v, i, pre, _, _) -&gt; pre + &quot; &quot; + v
<i>5367</i>&nbsp;     * assertEquals(&quot;na na na na na na na na na na na na na Lambdaman!&quot;, loop.invoke(&quot;na&quot;, 13, &quot;Lambdaman!&quot;));
<i>5368</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5369</i>&nbsp;     *
<i>5370</i>&nbsp;     * @apiNote The implementation of this method can be expressed as follows:
<i>5371</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5372</i>&nbsp;     * MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
<i>5373</i>&nbsp;     *     return countedLoop(empty(iterations.type()), iterations, init, body);
<i>5374</i>&nbsp;     * }
<i>5375</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5376</i>&nbsp;     *
<i>5377</i>&nbsp;     * @param iterations a non-{@code null} handle to return the number of iterations this loop should run. The handle&#39;s
<i>5378</i>&nbsp;     *                   result type must be {@code int}. See above for other constraints.
<i>5379</i>&nbsp;     * @param init optional initializer, providing the initial value of the loop variable.
<i>5380</i>&nbsp;     *             May be {@code null}, implying a default initial value.  See above for other constraints.
<i>5381</i>&nbsp;     * @param body body of the loop, which may not be {@code null}.
<i>5382</i>&nbsp;     *             It controls the loop parameters and result type in the standard case (see above for details).
<i>5383</i>&nbsp;     *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
<i>5384</i>&nbsp;     *             and may accept any number of additional types.
<i>5385</i>&nbsp;     *             See above for other constraints.
<i>5386</i>&nbsp;     *
<i>5387</i>&nbsp;     * @return a method handle representing the loop.
<i>5388</i>&nbsp;     * @throws NullPointerException if either of the {@code iterations} or {@code body} handles is {@code null}.
<i>5389</i>&nbsp;     * @throws IllegalArgumentException if any argument violates the rules formulated above.
<i>5390</i>&nbsp;     *
<i>5391</i>&nbsp;     * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle, MethodHandle)
<i>5392</i>&nbsp;     * @since 9
<i>5393</i>&nbsp;     */
<i>5394</i>&nbsp;    public static MethodHandle countedLoop(MethodHandle iterations, MethodHandle init, MethodHandle body) {
<i>5395</i>&nbsp;        return countedLoop(empty(iterations.type()), iterations, init, body);
<i>5396</i>&nbsp;    }
<i>5397</i>&nbsp;
<i>5398</i>&nbsp;    /**
<i>5399</i>&nbsp;     * Constructs a loop that counts over a range of numbers.
<i>5400</i>&nbsp;     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
<i>5401</i>&nbsp;     * &lt;p&gt;
<i>5402</i>&nbsp;     * The loop counter {@code i} is a loop iteration variable of type {@code int}.
<i>5403</i>&nbsp;     * The {@code start} and {@code end} handles determine the start (inclusive) and end (exclusive)
<i>5404</i>&nbsp;     * values of the loop counter.
<i>5405</i>&nbsp;     * The loop counter will be initialized to the {@code int} value returned from the evaluation of the
<i>5406</i>&nbsp;     * {@code start} handle and run to the value returned from {@code end} (exclusively) with a step width of 1.
<i>5407</i>&nbsp;     * &lt;p&gt;
<i>5408</i>&nbsp;     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
<i>5409</i>&nbsp;     * of that type is also present.  This variable is initialized using the optional {@code init} handle,
<i>5410</i>&nbsp;     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
<i>5411</i>&nbsp;     * &lt;p&gt;
<i>5412</i>&nbsp;     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
<i>5413</i>&nbsp;     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
<i>5414</i>&nbsp;     * iteration variable.
<i>5415</i>&nbsp;     * The result of the loop handle execution will be the final {@code V} value of that variable
<i>5416</i>&nbsp;     * (or {@code void} if there is no {@code V} variable).
<i>5417</i>&nbsp;     * &lt;p&gt;
<i>5418</i>&nbsp;     * The following rules hold for the argument handles:&lt;ul&gt;
<i>5419</i>&nbsp;     * &lt;li&gt;The {@code start} and {@code end} handles must not be {@code null}, and must both return
<i>5420</i>&nbsp;     * the common type {@code int}, referred to here as {@code I} in parameter type lists.
<i>5421</i>&nbsp;     * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
<i>5422</i>&nbsp;     * {@code (V I A...)V}, where {@code V} is non-{@code void}, or else {@code (I A...)void}.
<i>5423</i>&nbsp;     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
<i>5424</i>&nbsp;     * and we will write {@code (V I A...)V} with the understanding that a {@code void} type {@code V}
<i>5425</i>&nbsp;     * is quietly dropped from the parameter list, leaving {@code (I A...)V}.)
<i>5426</i>&nbsp;     * &lt;li&gt;The parameter list {@code (V I A...)} of the body contributes to a list
<i>5427</i>&nbsp;     * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
<i>5428</i>&nbsp;     * It will constrain the parameter lists of the other loop parts.
<i>5429</i>&nbsp;     * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code I} types,
<i>5430</i>&nbsp;     * with no additional {@code A} types, then the internal parameter list is extended by
<i>5431</i>&nbsp;     * the argument types {@code A...} of the {@code end} handle.
<i>5432</i>&nbsp;     * &lt;li&gt;If the iteration variable types {@code (V I)} are dropped from the internal parameter list, the resulting shorter
<i>5433</i>&nbsp;     * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
<i>5434</i>&nbsp;     * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
<i>5435</i>&nbsp;     * additional state variable of the loop.
<i>5436</i>&nbsp;     * The body must both accept a leading parameter and return a value of this type {@code V}.
<i>5437</i>&nbsp;     * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
<i>5438</i>&nbsp;     * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
<i>5439</i>&nbsp;     * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
<i>5440</i>&nbsp;     * to the external parameter list {@code (A...)}.
<i>5441</i>&nbsp;     * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
<i>5442</i>&nbsp;     * {@linkplain #empty default value}.
<i>5443</i>&nbsp;     * &lt;li&gt;The parameter list of {@code start} (of some form {@code (A*)}) must be
<i>5444</i>&nbsp;     * effectively identical to the external parameter list {@code (A...)}.
<i>5445</i>&nbsp;     * &lt;li&gt;Likewise, the parameter list of {@code end} must be effectively identical
<i>5446</i>&nbsp;     * to the external parameter list.
<i>5447</i>&nbsp;     * &lt;/ul&gt;
<i>5448</i>&nbsp;     * &lt;p&gt;
<i>5449</i>&nbsp;     * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
<i>5450</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
<i>5451</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
<i>5452</i>&nbsp;     * from the external parameter list.
<i>5453</i>&nbsp;     * &lt;/ul&gt;
<i>5454</i>&nbsp;     * &lt;p&gt;
<i>5455</i>&nbsp;     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
<i>5456</i>&nbsp;     * the second loop variable as well as the result type of the loop; and {@code A...}/{@code a...} represent
<i>5457</i>&nbsp;     * arguments passed to the loop.
<i>5458</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5459</i>&nbsp;     * int start(A...);
<i>5460</i>&nbsp;     * int end(A...);
<i>5461</i>&nbsp;     * V init(A...);
<i>5462</i>&nbsp;     * V body(V, int, A...);
<i>5463</i>&nbsp;     * V countedLoop(A... a...) {
<i>5464</i>&nbsp;     *   int e = end(a...);
<i>5465</i>&nbsp;     *   int s = start(a...);
<i>5466</i>&nbsp;     *   V v = init(a...);
<i>5467</i>&nbsp;     *   for (int i = s; i &lt; e; ++i) {
<i>5468</i>&nbsp;     *     v = body(v, i, a...);
<i>5469</i>&nbsp;     *   }
<i>5470</i>&nbsp;     *   return v;
<i>5471</i>&nbsp;     * }
<i>5472</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5473</i>&nbsp;     *
<i>5474</i>&nbsp;     * @apiNote The implementation of this method can be expressed as follows:
<i>5475</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5476</i>&nbsp;     * MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
<i>5477</i>&nbsp;     *     MethodHandle returnVar = dropArguments(identity(init.type().returnType()), 0, int.class, int.class);
<i>5478</i>&nbsp;     *     // assume MH_increment and MH_predicate are handles to implementation-internal methods with
<i>5479</i>&nbsp;     *     // the following semantics:
<i>5480</i>&nbsp;     *     // MH_increment: (int limit, int counter) -&gt; counter + 1
<i>5481</i>&nbsp;     *     // MH_predicate: (int limit, int counter) -&gt; counter &lt; limit
<i>5482</i>&nbsp;     *     Class&lt;?&gt; counterType = start.type().returnType();  // int
<i>5483</i>&nbsp;     *     Class&lt;?&gt; returnType = body.type().returnType();
<i>5484</i>&nbsp;     *     MethodHandle incr = MH_increment, pred = MH_predicate, retv = null;
<i>5485</i>&nbsp;     *     if (returnType != void.class) {  // ignore the V variable
<i>5486</i>&nbsp;     *         incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
<i>5487</i>&nbsp;     *         pred = dropArguments(pred, 1, returnType);  // ditto
<i>5488</i>&nbsp;     *         retv = dropArguments(identity(returnType), 0, counterType); // ignore limit
<i>5489</i>&nbsp;     *     }
<i>5490</i>&nbsp;     *     body = dropArguments(body, 0, counterType);  // ignore the limit variable
<i>5491</i>&nbsp;     *     MethodHandle[]
<i>5492</i>&nbsp;     *         loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
<i>5493</i>&nbsp;     *         bodyClause = { init, body },            // v = init(); v = body(v, i)
<i>5494</i>&nbsp;     *         indexVar   = { start, incr };           // i = start(); i = i + 1
<i>5495</i>&nbsp;     *     return loop(loopLimit, bodyClause, indexVar);
<i>5496</i>&nbsp;     * }
<i>5497</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5498</i>&nbsp;     *
<i>5499</i>&nbsp;     * @param start a non-{@code null} handle to return the start value of the loop counter, which must be {@code int}.
<i>5500</i>&nbsp;     *              See above for other constraints.
<i>5501</i>&nbsp;     * @param end a non-{@code null} handle to return the end value of the loop counter (the loop will run to
<i>5502</i>&nbsp;     *            {@code end-1}). The result type must be {@code int}. See above for other constraints.
<i>5503</i>&nbsp;     * @param init optional initializer, providing the initial value of the loop variable.
<i>5504</i>&nbsp;     *             May be {@code null}, implying a default initial value.  See above for other constraints.
<i>5505</i>&nbsp;     * @param body body of the loop, which may not be {@code null}.
<i>5506</i>&nbsp;     *             It controls the loop parameters and result type in the standard case (see above for details).
<i>5507</i>&nbsp;     *             It must accept its own return type (if non-void) plus an {@code int} parameter (for the counter),
<i>5508</i>&nbsp;     *             and may accept any number of additional types.
<i>5509</i>&nbsp;     *             See above for other constraints.
<i>5510</i>&nbsp;     *
<i>5511</i>&nbsp;     * @return a method handle representing the loop.
<i>5512</i>&nbsp;     * @throws NullPointerException if any of the {@code start}, {@code end}, or {@code body} handles is {@code null}.
<i>5513</i>&nbsp;     * @throws IllegalArgumentException if any argument violates the rules formulated above.
<i>5514</i>&nbsp;     *
<i>5515</i>&nbsp;     * @see #countedLoop(MethodHandle, MethodHandle, MethodHandle)
<i>5516</i>&nbsp;     * @since 9
<i>5517</i>&nbsp;     */
<i>5518</i>&nbsp;    public static MethodHandle countedLoop(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
<i>5519</i>&nbsp;        countedLoopChecks(start, end, init, body);
<i>5520</i>&nbsp;        Class&lt;?&gt; counterType = start.type().returnType();  // int, but who&#39;s counting?
<i>5521</i>&nbsp;        Class&lt;?&gt; limitType   = end.type().returnType();    // yes, int again
<i>5522</i>&nbsp;        Class&lt;?&gt; returnType  = body.type().returnType();
<i>5523</i>&nbsp;        MethodHandle incr = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopStep);
<i>5524</i>&nbsp;        MethodHandle pred = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_countedLoopPred);
<i>5525</i>&nbsp;        MethodHandle retv = null;
<i>5526</i>&nbsp;        if (returnType != void.class) {
<i>5527</i>&nbsp;            incr = dropArguments(incr, 1, returnType);  // (limit, v, i) =&gt; (limit, i)
<i>5528</i>&nbsp;            pred = dropArguments(pred, 1, returnType);  // ditto
<i>5529</i>&nbsp;            retv = dropArguments(identity(returnType), 0, counterType);
<i>5530</i>&nbsp;        }
<i>5531</i>&nbsp;        body = dropArguments(body, 0, counterType);  // ignore the limit variable
<i>5532</i>&nbsp;        MethodHandle[]
<i>5533</i>&nbsp;            loopLimit  = { end, null, pred, retv }, // limit = end(); i &lt; limit || return v
<i>5534</i>&nbsp;            bodyClause = { init, body },            // v = init(); v = body(v, i)
<i>5535</i>&nbsp;            indexVar   = { start, incr };           // i = start(); i = i + 1
<i>5536</i>&nbsp;        return loop(loopLimit, bodyClause, indexVar);
<i>5537</i>&nbsp;    }
<i>5538</i>&nbsp;
<i>5539</i>&nbsp;    private static void countedLoopChecks(MethodHandle start, MethodHandle end, MethodHandle init, MethodHandle body) {
<i>5540</i>&nbsp;        Objects.requireNonNull(start);
<i>5541</i>&nbsp;        Objects.requireNonNull(end);
<i>5542</i>&nbsp;        Objects.requireNonNull(body);
<i>5543</i>&nbsp;        Class&lt;?&gt; counterType = start.type().returnType();
<i>5544</i>&nbsp;        if (counterType != int.class) {
<i>5545</i>&nbsp;            MethodType expected = start.type().changeReturnType(int.class);
<i>5546</i>&nbsp;            throw misMatchedTypes(&quot;start function&quot;, start.type(), expected);
<i>5547</i>&nbsp;        } else if (end.type().returnType() != counterType) {
<i>5548</i>&nbsp;            MethodType expected = end.type().changeReturnType(counterType);
<i>5549</i>&nbsp;            throw misMatchedTypes(&quot;end function&quot;, end.type(), expected);
<i>5550</i>&nbsp;        }
<i>5551</i>&nbsp;        MethodType bodyType = body.type();
<i>5552</i>&nbsp;        Class&lt;?&gt; returnType = bodyType.returnType();
<i>5553</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; innerList = bodyType.parameterList();
<i>5554</i>&nbsp;        // strip leading V value if present
<i>5555</i>&nbsp;        int vsize = (returnType == void.class ? 0 : 1);
<i>5556</i>&nbsp;        if (vsize != 0 &amp;&amp; (innerList.size() == 0 || innerList.get(0) != returnType)) {
<i>5557</i>&nbsp;            // argument list has no &quot;V&quot; =&gt; error
<i>5558</i>&nbsp;            MethodType expected = bodyType.insertParameterTypes(0, returnType);
<i>5559</i>&nbsp;            throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
<i>5560</i>&nbsp;        } else if (innerList.size() &lt;= vsize || innerList.get(vsize) != counterType) {
<i>5561</i>&nbsp;            // missing I type =&gt; error
<i>5562</i>&nbsp;            MethodType expected = bodyType.insertParameterTypes(vsize, counterType);
<i>5563</i>&nbsp;            throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
<i>5564</i>&nbsp;        }
<i>5565</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; outerList = innerList.subList(vsize + 1, innerList.size());
<i>5566</i>&nbsp;        if (outerList.isEmpty()) {
<i>5567</i>&nbsp;            // special case; take lists from end handle
<i>5568</i>&nbsp;            outerList = end.type().parameterList();
<i>5569</i>&nbsp;            innerList = bodyType.insertParameterTypes(vsize + 1, outerList).parameterList();
<i>5570</i>&nbsp;        }
<i>5571</i>&nbsp;        MethodType expected = methodType(counterType, outerList);
<i>5572</i>&nbsp;        if (!start.type().effectivelyIdenticalParameters(0, outerList)) {
<i>5573</i>&nbsp;            throw misMatchedTypes(&quot;start parameter types&quot;, start.type(), expected);
<i>5574</i>&nbsp;        }
<i>5575</i>&nbsp;        if (end.type() != start.type() &amp;&amp;
<i>5576</i>&nbsp;            !end.type().effectivelyIdenticalParameters(0, outerList)) {
<i>5577</i>&nbsp;            throw misMatchedTypes(&quot;end parameter types&quot;, end.type(), expected);
<i>5578</i>&nbsp;        }
<i>5579</i>&nbsp;        if (init != null) {
<i>5580</i>&nbsp;            MethodType initType = init.type();
<i>5581</i>&nbsp;            if (initType.returnType() != returnType ||
<i>5582</i>&nbsp;                !initType.effectivelyIdenticalParameters(0, outerList)) {
<i>5583</i>&nbsp;                throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, outerList));
<i>5584</i>&nbsp;            }
<i>5585</i>&nbsp;        }
<i>5586</i>&nbsp;    }
<i>5587</i>&nbsp;
<i>5588</i>&nbsp;    /**
<i>5589</i>&nbsp;     * Constructs a loop that ranges over the values produced by an {@code Iterator&lt;T&gt;}.
<i>5590</i>&nbsp;     * This is a convenience wrapper for the {@linkplain #loop(MethodHandle[][]) generic loop combinator}.
<i>5591</i>&nbsp;     * &lt;p&gt;
<i>5592</i>&nbsp;     * The iterator itself will be determined by the evaluation of the {@code iterator} handle.
<i>5593</i>&nbsp;     * Each value it produces will be stored in a loop iteration variable of type {@code T}.
<i>5594</i>&nbsp;     * &lt;p&gt;
<i>5595</i>&nbsp;     * If the {@code body} handle returns a non-{@code void} type {@code V}, a leading loop iteration variable
<i>5596</i>&nbsp;     * of that type is also present.  This variable is initialized using the optional {@code init} handle,
<i>5597</i>&nbsp;     * or to the {@linkplain #empty default value} of type {@code V} if that handle is {@code null}.
<i>5598</i>&nbsp;     * &lt;p&gt;
<i>5599</i>&nbsp;     * In each iteration, the iteration variables are passed to an invocation of the {@code body} handle.
<i>5600</i>&nbsp;     * A non-{@code void} value returned from the body (of type {@code V}) updates the leading
<i>5601</i>&nbsp;     * iteration variable.
<i>5602</i>&nbsp;     * The result of the loop handle execution will be the final {@code V} value of that variable
<i>5603</i>&nbsp;     * (or {@code void} if there is no {@code V} variable).
<i>5604</i>&nbsp;     * &lt;p&gt;
<i>5605</i>&nbsp;     * The following rules hold for the argument handles:&lt;ul&gt;
<i>5606</i>&nbsp;     * &lt;li&gt;The {@code body} handle must not be {@code null}; its type must be of the form
<i>5607</i>&nbsp;     * {@code (V T A...)V}, where {@code V} is non-{@code void}, or else {@code (T A...)void}.
<i>5608</i>&nbsp;     * (In the {@code void} case, we assign the type {@code void} to the name {@code V},
<i>5609</i>&nbsp;     * and we will write {@code (V T A...)V} with the understanding that a {@code void} type {@code V}
<i>5610</i>&nbsp;     * is quietly dropped from the parameter list, leaving {@code (T A...)V}.)
<i>5611</i>&nbsp;     * &lt;li&gt;The parameter list {@code (V T A...)} of the body contributes to a list
<i>5612</i>&nbsp;     * of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
<i>5613</i>&nbsp;     * It will constrain the parameter lists of the other loop parts.
<i>5614</i>&nbsp;     * &lt;li&gt;As a special case, if the body contributes only {@code V} and {@code T} types,
<i>5615</i>&nbsp;     * with no additional {@code A} types, then the internal parameter list is extended by
<i>5616</i>&nbsp;     * the argument types {@code A...} of the {@code iterator} handle; if it is {@code null} the
<i>5617</i>&nbsp;     * single type {@code Iterable} is added and constitutes the {@code A...} list.
<i>5618</i>&nbsp;     * &lt;li&gt;If the iteration variable types {@code (V T)} are dropped from the internal parameter list, the resulting shorter
<i>5619</i>&nbsp;     * list {@code (A...)} is called the &lt;em&gt;external parameter list&lt;/em&gt;.
<i>5620</i>&nbsp;     * &lt;li&gt;The body return type {@code V}, if non-{@code void}, determines the type of an
<i>5621</i>&nbsp;     * additional state variable of the loop.
<i>5622</i>&nbsp;     * The body must both accept a leading parameter and return a value of this type {@code V}.
<i>5623</i>&nbsp;     * &lt;li&gt;If {@code init} is non-{@code null}, it must have return type {@code V}.
<i>5624</i>&nbsp;     * Its parameter list (of some &lt;a href=&quot;MethodHandles.html#astar&quot;&gt;form {@code (A*)}&lt;/a&gt;) must be
<i>5625</i>&nbsp;     * &lt;a href=&quot;MethodHandles.html#effid&quot;&gt;effectively identical&lt;/a&gt;
<i>5626</i>&nbsp;     * to the external parameter list {@code (A...)}.
<i>5627</i>&nbsp;     * &lt;li&gt;If {@code init} is {@code null}, the loop variable will be initialized to its
<i>5628</i>&nbsp;     * {@linkplain #empty default value}.
<i>5629</i>&nbsp;     * &lt;li&gt;If the {@code iterator} handle is non-{@code null}, it must have the return
<i>5630</i>&nbsp;     * type {@code java.util.Iterator} or a subtype thereof.
<i>5631</i>&nbsp;     * The iterator it produces when the loop is executed will be assumed
<i>5632</i>&nbsp;     * to yield values which can be converted to type {@code T}.
<i>5633</i>&nbsp;     * &lt;li&gt;The parameter list of an {@code iterator} that is non-{@code null} (of some form {@code (A*)}) must be
<i>5634</i>&nbsp;     * effectively identical to the external parameter list {@code (A...)}.
<i>5635</i>&nbsp;     * &lt;li&gt;If {@code iterator} is {@code null} it defaults to a method handle which behaves
<i>5636</i>&nbsp;     * like {@link java.lang.Iterable#iterator()}.  In that case, the internal parameter list
<i>5637</i>&nbsp;     * {@code (V T A...)} must have at least one {@code A} type, and the default iterator
<i>5638</i>&nbsp;     * handle parameter is adjusted to accept the leading {@code A} type, as if by
<i>5639</i>&nbsp;     * the {@link MethodHandle#asType asType} conversion method.
<i>5640</i>&nbsp;     * The leading {@code A} type must be {@code Iterable} or a subtype thereof.
<i>5641</i>&nbsp;     * This conversion step, done at loop construction time, must not throw a {@code WrongMethodTypeException}.
<i>5642</i>&nbsp;     * &lt;/ul&gt;
<i>5643</i>&nbsp;     * &lt;p&gt;
<i>5644</i>&nbsp;     * The type {@code T} may be either a primitive or reference.
<i>5645</i>&nbsp;     * Since type {@code Iterator&lt;T&gt;} is erased in the method handle representation to the raw type {@code Iterator},
<i>5646</i>&nbsp;     * the {@code iteratedLoop} combinator adjusts the leading argument type for {@code body} to {@code Object}
<i>5647</i>&nbsp;     * as if by the {@link MethodHandle#asType asType} conversion method.
<i>5648</i>&nbsp;     * Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur
<i>5649</i>&nbsp;     * as the result of dynamic conversions performed by {@link MethodHandle#asType(MethodType)}.
<i>5650</i>&nbsp;     * &lt;p&gt;
<i>5651</i>&nbsp;     * The resulting loop handle&#39;s result type and parameter signature are determined as follows:&lt;ul&gt;
<i>5652</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s result type is the result type {@code V} of the body.
<i>5653</i>&nbsp;     * &lt;li&gt;The loop handle&#39;s parameter types are the types {@code (A...)},
<i>5654</i>&nbsp;     * from the external parameter list.
<i>5655</i>&nbsp;     * &lt;/ul&gt;
<i>5656</i>&nbsp;     * &lt;p&gt;
<i>5657</i>&nbsp;     * Here is pseudocode for the resulting loop handle. In the code, {@code V}/{@code v} represent the type / value of
<i>5658</i>&nbsp;     * the loop variable as well as the result type of the loop; {@code T}/{@code t}, that of the elements of the
<i>5659</i>&nbsp;     * structure the loop iterates over, and {@code A...}/{@code a...} represent arguments passed to the loop.
<i>5660</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5661</i>&nbsp;     * Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
<i>5662</i>&nbsp;     * V init(A...);
<i>5663</i>&nbsp;     * V body(V,T,A...);
<i>5664</i>&nbsp;     * V iteratedLoop(A... a...) {
<i>5665</i>&nbsp;     *   Iterator&lt;T&gt; it = iterator(a...);
<i>5666</i>&nbsp;     *   V v = init(a...);
<i>5667</i>&nbsp;     *   while (it.hasNext()) {
<i>5668</i>&nbsp;     *     T t = it.next();
<i>5669</i>&nbsp;     *     v = body(v, t, a...);
<i>5670</i>&nbsp;     *   }
<i>5671</i>&nbsp;     *   return v;
<i>5672</i>&nbsp;     * }
<i>5673</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5674</i>&nbsp;     *
<i>5675</i>&nbsp;     * @apiNote Example:
<i>5676</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5677</i>&nbsp;     * // get an iterator from a list
<i>5678</i>&nbsp;     * static List&lt;String&gt; reverseStep(List&lt;String&gt; r, String e) {
<i>5679</i>&nbsp;     *   r.add(0, e);
<i>5680</i>&nbsp;     *   return r;
<i>5681</i>&nbsp;     * }
<i>5682</i>&nbsp;     * static List&lt;String&gt; newArrayList() { return new ArrayList&lt;&gt;(); }
<i>5683</i>&nbsp;     * // assume MH_reverseStep and MH_newArrayList are handles to the above methods
<i>5684</i>&nbsp;     * MethodHandle loop = MethodHandles.iteratedLoop(null, MH_newArrayList, MH_reverseStep);
<i>5685</i>&nbsp;     * List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
<i>5686</i>&nbsp;     * List&lt;String&gt; reversedList = Arrays.asList(&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;);
<i>5687</i>&nbsp;     * assertEquals(reversedList, (List&lt;String&gt;) loop.invoke(list));
<i>5688</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5689</i>&nbsp;     *
<i>5690</i>&nbsp;     * @apiNote The implementation of this method can be expressed approximately as follows:
<i>5691</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5692</i>&nbsp;     * MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
<i>5693</i>&nbsp;     *     // assume MH_next, MH_hasNext, MH_startIter are handles to methods of Iterator/Iterable
<i>5694</i>&nbsp;     *     Class&lt;?&gt; returnType = body.type().returnType();
<i>5695</i>&nbsp;     *     Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
<i>5696</i>&nbsp;     *     MethodHandle nextVal = MH_next.asType(MH_next.type().changeReturnType(ttype));
<i>5697</i>&nbsp;     *     MethodHandle retv = null, step = body, startIter = iterator;
<i>5698</i>&nbsp;     *     if (returnType != void.class) {
<i>5699</i>&nbsp;     *         // the simple thing first:  in (I V A...), drop the I to get V
<i>5700</i>&nbsp;     *         retv = dropArguments(identity(returnType), 0, Iterator.class);
<i>5701</i>&nbsp;     *         // body type signature (V T A...), internal loop types (I V A...)
<i>5702</i>&nbsp;     *         step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
<i>5703</i>&nbsp;     *     }
<i>5704</i>&nbsp;     *     if (startIter == null)  startIter = MH_getIter;
<i>5705</i>&nbsp;     *     MethodHandle[]
<i>5706</i>&nbsp;     *         iterVar    = { startIter, null, MH_hasNext, retv }, // it = iterator; while (it.hasNext())
<i>5707</i>&nbsp;     *         bodyClause = { init, filterArguments(step, 0, nextVal) };  // v = body(v, t, a)
<i>5708</i>&nbsp;     *     return loop(iterVar, bodyClause);
<i>5709</i>&nbsp;     * }
<i>5710</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5711</i>&nbsp;     *
<i>5712</i>&nbsp;     * @param iterator an optional handle to return the iterator to start the loop.
<i>5713</i>&nbsp;     *                 If non-{@code null}, the handle must return {@link java.util.Iterator} or a subtype.
<i>5714</i>&nbsp;     *                 See above for other constraints.
<i>5715</i>&nbsp;     * @param init optional initializer, providing the initial value of the loop variable.
<i>5716</i>&nbsp;     *             May be {@code null}, implying a default initial value.  See above for other constraints.
<i>5717</i>&nbsp;     * @param body body of the loop, which may not be {@code null}.
<i>5718</i>&nbsp;     *             It controls the loop parameters and result type in the standard case (see above for details).
<i>5719</i>&nbsp;     *             It must accept its own return type (if non-void) plus a {@code T} parameter (for the iterated values),
<i>5720</i>&nbsp;     *             and may accept any number of additional types.
<i>5721</i>&nbsp;     *             See above for other constraints.
<i>5722</i>&nbsp;     *
<i>5723</i>&nbsp;     * @return a method handle embodying the iteration loop functionality.
<i>5724</i>&nbsp;     * @throws NullPointerException if the {@code body} handle is {@code null}.
<i>5725</i>&nbsp;     * @throws IllegalArgumentException if any argument violates the above requirements.
<i>5726</i>&nbsp;     *
<i>5727</i>&nbsp;     * @since 9
<i>5728</i>&nbsp;     */
<i>5729</i>&nbsp;    public static MethodHandle iteratedLoop(MethodHandle iterator, MethodHandle init, MethodHandle body) {
<i>5730</i>&nbsp;        Class&lt;?&gt; iterableType = iteratedLoopChecks(iterator, init, body);
<i>5731</i>&nbsp;        Class&lt;?&gt; returnType = body.type().returnType();
<i>5732</i>&nbsp;        MethodHandle hasNext = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iteratePred);
<i>5733</i>&nbsp;        MethodHandle nextRaw = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_iterateNext);
<i>5734</i>&nbsp;        MethodHandle startIter;
<i>5735</i>&nbsp;        MethodHandle nextVal;
<i>5736</i>&nbsp;        {
<i>5737</i>&nbsp;            MethodType iteratorType;
<i>5738</i>&nbsp;            if (iterator == null) {
<i>5739</i>&nbsp;                // derive argument type from body, if available, else use Iterable
<i>5740</i>&nbsp;                startIter = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_initIterator);
<i>5741</i>&nbsp;                iteratorType = startIter.type().changeParameterType(0, iterableType);
<i>5742</i>&nbsp;            } else {
<i>5743</i>&nbsp;                // force return type to the internal iterator class
<i>5744</i>&nbsp;                iteratorType = iterator.type().changeReturnType(Iterator.class);
<i>5745</i>&nbsp;                startIter = iterator;
<i>5746</i>&nbsp;            }
<i>5747</i>&nbsp;            Class&lt;?&gt; ttype = body.type().parameterType(returnType == void.class ? 0 : 1);
<i>5748</i>&nbsp;            MethodType nextValType = nextRaw.type().changeReturnType(ttype);
<i>5749</i>&nbsp;
<i>5750</i>&nbsp;            // perform the asType transforms under an exception transformer, as per spec.:
<i>5751</i>&nbsp;            try {
<i>5752</i>&nbsp;                startIter = startIter.asType(iteratorType);
<i>5753</i>&nbsp;                nextVal = nextRaw.asType(nextValType);
<i>5754</i>&nbsp;            } catch (WrongMethodTypeException ex) {
<i>5755</i>&nbsp;                throw new IllegalArgumentException(ex);
<i>5756</i>&nbsp;            }
<i>5757</i>&nbsp;        }
<i>5758</i>&nbsp;
<i>5759</i>&nbsp;        MethodHandle retv = null, step = body;
<i>5760</i>&nbsp;        if (returnType != void.class) {
<i>5761</i>&nbsp;            // the simple thing first:  in (I V A...), drop the I to get V
<i>5762</i>&nbsp;            retv = dropArguments(identity(returnType), 0, Iterator.class);
<i>5763</i>&nbsp;            // body type signature (V T A...), internal loop types (I V A...)
<i>5764</i>&nbsp;            step = swapArguments(body, 0, 1);  // swap V &lt;-&gt; T
<i>5765</i>&nbsp;        }
<i>5766</i>&nbsp;
<i>5767</i>&nbsp;        MethodHandle[]
<i>5768</i>&nbsp;            iterVar    = { startIter, null, hasNext, retv },
<i>5769</i>&nbsp;            bodyClause = { init, filterArgument(step, 0, nextVal) };
<i>5770</i>&nbsp;        return loop(iterVar, bodyClause);
<i>5771</i>&nbsp;    }
<i>5772</i>&nbsp;
<i>5773</i>&nbsp;    private static Class&lt;?&gt; iteratedLoopChecks(MethodHandle iterator, MethodHandle init, MethodHandle body) {
<i>5774</i>&nbsp;        Objects.requireNonNull(body);
<i>5775</i>&nbsp;        MethodType bodyType = body.type();
<i>5776</i>&nbsp;        Class&lt;?&gt; returnType = bodyType.returnType();
<i>5777</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; internalParamList = bodyType.parameterList();
<i>5778</i>&nbsp;        // strip leading V value if present
<i>5779</i>&nbsp;        int vsize = (returnType == void.class ? 0 : 1);
<i>5780</i>&nbsp;        if (vsize != 0 &amp;&amp; (internalParamList.size() == 0 || internalParamList.get(0) != returnType)) {
<i>5781</i>&nbsp;            // argument list has no &quot;V&quot; =&gt; error
<i>5782</i>&nbsp;            MethodType expected = bodyType.insertParameterTypes(0, returnType);
<i>5783</i>&nbsp;            throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
<i>5784</i>&nbsp;        } else if (internalParamList.size() &lt;= vsize) {
<i>5785</i>&nbsp;            // missing T type =&gt; error
<i>5786</i>&nbsp;            MethodType expected = bodyType.insertParameterTypes(vsize, Object.class);
<i>5787</i>&nbsp;            throw misMatchedTypes(&quot;body function&quot;, bodyType, expected);
<i>5788</i>&nbsp;        }
<i>5789</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; externalParamList = internalParamList.subList(vsize + 1, internalParamList.size());
<i>5790</i>&nbsp;        Class&lt;?&gt; iterableType = null;
<i>5791</i>&nbsp;        if (iterator != null) {
<i>5792</i>&nbsp;            // special case; if the body handle only declares V and T then
<i>5793</i>&nbsp;            // the external parameter list is obtained from iterator handle
<i>5794</i>&nbsp;            if (externalParamList.isEmpty()) {
<i>5795</i>&nbsp;                externalParamList = iterator.type().parameterList();
<i>5796</i>&nbsp;            }
<i>5797</i>&nbsp;            MethodType itype = iterator.type();
<i>5798</i>&nbsp;            if (!Iterator.class.isAssignableFrom(itype.returnType())) {
<i>5799</i>&nbsp;                throw newIllegalArgumentException(&quot;iteratedLoop first argument must have Iterator return type&quot;);
<i>5800</i>&nbsp;            }
<i>5801</i>&nbsp;            if (!itype.effectivelyIdenticalParameters(0, externalParamList)) {
<i>5802</i>&nbsp;                MethodType expected = methodType(itype.returnType(), externalParamList);
<i>5803</i>&nbsp;                throw misMatchedTypes(&quot;iterator parameters&quot;, itype, expected);
<i>5804</i>&nbsp;            }
<i>5805</i>&nbsp;        } else {
<i>5806</i>&nbsp;            if (externalParamList.isEmpty()) {
<i>5807</i>&nbsp;                // special case; if the iterator handle is null and the body handle
<i>5808</i>&nbsp;                // only declares V and T then the external parameter list consists
<i>5809</i>&nbsp;                // of Iterable
<i>5810</i>&nbsp;                externalParamList = Arrays.asList(Iterable.class);
<i>5811</i>&nbsp;                iterableType = Iterable.class;
<i>5812</i>&nbsp;            } else {
<i>5813</i>&nbsp;                // special case; if the iterator handle is null and the external
<i>5814</i>&nbsp;                // parameter list is not empty then the first parameter must be
<i>5815</i>&nbsp;                // assignable to Iterable
<i>5816</i>&nbsp;                iterableType = externalParamList.get(0);
<i>5817</i>&nbsp;                if (!Iterable.class.isAssignableFrom(iterableType)) {
<i>5818</i>&nbsp;                    throw newIllegalArgumentException(
<i>5819</i>&nbsp;                            &quot;inferred first loop argument must inherit from Iterable: &quot; + iterableType);
<i>5820</i>&nbsp;                }
<i>5821</i>&nbsp;            }
<i>5822</i>&nbsp;        }
<i>5823</i>&nbsp;        if (init != null) {
<i>5824</i>&nbsp;            MethodType initType = init.type();
<i>5825</i>&nbsp;            if (initType.returnType() != returnType ||
<i>5826</i>&nbsp;                    !initType.effectivelyIdenticalParameters(0, externalParamList)) {
<i>5827</i>&nbsp;                throw misMatchedTypes(&quot;loop initializer&quot;, initType, methodType(returnType, externalParamList));
<i>5828</i>&nbsp;            }
<i>5829</i>&nbsp;        }
<i>5830</i>&nbsp;        return iterableType;  // help the caller a bit
<i>5831</i>&nbsp;    }
<i>5832</i>&nbsp;
<i>5833</i>&nbsp;    /*non-public*/ static MethodHandle swapArguments(MethodHandle mh, int i, int j) {
<i>5834</i>&nbsp;        // there should be a better way to uncross my wires
<i>5835</i>&nbsp;        int arity = mh.type().parameterCount();
<i>5836</i>&nbsp;        int[] order = new int[arity];
<i>5837</i>&nbsp;        for (int k = 0; k &lt; arity; k++)  order[k] = k;
<i>5838</i>&nbsp;        order[i] = j; order[j] = i;
<i>5839</i>&nbsp;        Class&lt;?&gt;[] types = mh.type().parameterArray();
<i>5840</i>&nbsp;        Class&lt;?&gt; ti = types[i]; types[i] = types[j]; types[j] = ti;
<i>5841</i>&nbsp;        MethodType swapType = methodType(mh.type().returnType(), types);
<i>5842</i>&nbsp;        return permuteArguments(mh, swapType, order);
<i>5843</i>&nbsp;    }
<i>5844</i>&nbsp;
<i>5845</i>&nbsp;    /**
<i>5846</i>&nbsp;     * Makes a method handle that adapts a {@code target} method handle by wrapping it in a {@code try-finally} block.
<i>5847</i>&nbsp;     * Another method handle, {@code cleanup}, represents the functionality of the {@code finally} block. Any exception
<i>5848</i>&nbsp;     * thrown during the execution of the {@code target} handle will be passed to the {@code cleanup} handle. The
<i>5849</i>&nbsp;     * exception will be rethrown, unless {@code cleanup} handle throws an exception first.  The
<i>5850</i>&nbsp;     * value returned from the {@code cleanup} handle&#39;s execution will be the result of the execution of the
<i>5851</i>&nbsp;     * {@code try-finally} handle.
<i>5852</i>&nbsp;     * &lt;p&gt;
<i>5853</i>&nbsp;     * The {@code cleanup} handle will be passed one or two additional leading arguments.
<i>5854</i>&nbsp;     * The first is the exception thrown during the
<i>5855</i>&nbsp;     * execution of the {@code target} handle, or {@code null} if no exception was thrown.
<i>5856</i>&nbsp;     * The second is the result of the execution of the {@code target} handle, or, if it throws an exception,
<i>5857</i>&nbsp;     * a {@code null}, zero, or {@code false} value of the required type is supplied as a placeholder.
<i>5858</i>&nbsp;     * The second argument is not present if the {@code target} handle has a {@code void} return type.
<i>5859</i>&nbsp;     * (Note that, except for argument type conversions, combinators represent {@code void} values in parameter lists
<i>5860</i>&nbsp;     * by omitting the corresponding paradoxical arguments, not by inserting {@code null} or zero values.)
<i>5861</i>&nbsp;     * &lt;p&gt;
<i>5862</i>&nbsp;     * The {@code target} and {@code cleanup} handles must have the same corresponding argument and return types, except
<i>5863</i>&nbsp;     * that the {@code cleanup} handle may omit trailing arguments. Also, the {@code cleanup} handle must have one or
<i>5864</i>&nbsp;     * two extra leading parameters:&lt;ul&gt;
<i>5865</i>&nbsp;     * &lt;li&gt;a {@code Throwable}, which will carry the exception thrown by the {@code target} handle (if any); and
<i>5866</i>&nbsp;     * &lt;li&gt;a parameter of the same type as the return type of both {@code target} and {@code cleanup}, which will carry
<i>5867</i>&nbsp;     * the result from the execution of the {@code target} handle.
<i>5868</i>&nbsp;     * This parameter is not present if the {@code target} returns {@code void}.
<i>5869</i>&nbsp;     * &lt;/ul&gt;
<i>5870</i>&nbsp;     * &lt;p&gt;
<i>5871</i>&nbsp;     * The pseudocode for the resulting adapter looks as follows. In the code, {@code V} represents the result type of
<i>5872</i>&nbsp;     * the {@code try/finally} construct; {@code A}/{@code a}, the types and values of arguments to the resulting
<i>5873</i>&nbsp;     * handle consumed by the cleanup; and {@code B}/{@code b}, those of arguments to the resulting handle discarded by
<i>5874</i>&nbsp;     * the cleanup.
<i>5875</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>5876</i>&nbsp;     * V target(A..., B...);
<i>5877</i>&nbsp;     * V cleanup(Throwable, V, A...);
<i>5878</i>&nbsp;     * V adapter(A... a, B... b) {
<i>5879</i>&nbsp;     *   V result = (zero value for V);
<i>5880</i>&nbsp;     *   Throwable throwable = null;
<i>5881</i>&nbsp;     *   try {
<i>5882</i>&nbsp;     *     result = target(a..., b...);
<i>5883</i>&nbsp;     *   } catch (Throwable t) {
<i>5884</i>&nbsp;     *     throwable = t;
<i>5885</i>&nbsp;     *     throw t;
<i>5886</i>&nbsp;     *   } finally {
<i>5887</i>&nbsp;     *     result = cleanup(throwable, result, a...);
<i>5888</i>&nbsp;     *   }
<i>5889</i>&nbsp;     *   return result;
<i>5890</i>&nbsp;     * }
<i>5891</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>5892</i>&nbsp;     * &lt;p&gt;
<i>5893</i>&nbsp;     * Note that the saved arguments ({@code a...} in the pseudocode) cannot
<i>5894</i>&nbsp;     * be modified by execution of the target, and so are passed unchanged
<i>5895</i>&nbsp;     * from the caller to the cleanup, if it is invoked.
<i>5896</i>&nbsp;     * &lt;p&gt;
<i>5897</i>&nbsp;     * The target and cleanup must return the same type, even if the cleanup
<i>5898</i>&nbsp;     * always throws.
<i>5899</i>&nbsp;     * To create such a throwing cleanup, compose the cleanup logic
<i>5900</i>&nbsp;     * with {@link #throwException throwException},
<i>5901</i>&nbsp;     * in order to create a method handle of the correct return type.
<i>5902</i>&nbsp;     * &lt;p&gt;
<i>5903</i>&nbsp;     * Note that {@code tryFinally} never converts exceptions into normal returns.
<i>5904</i>&nbsp;     * In rare cases where exceptions must be converted in that way, first wrap
<i>5905</i>&nbsp;     * the target with {@link #catchException(MethodHandle, Class, MethodHandle)}
<i>5906</i>&nbsp;     * to capture an outgoing exception, and then wrap with {@code tryFinally}.
<i>5907</i>&nbsp;     * &lt;p&gt;
<i>5908</i>&nbsp;     * It is recommended that the first parameter type of {@code cleanup} be
<i>5909</i>&nbsp;     * declared {@code Throwable} rather than a narrower subtype.  This ensures
<i>5910</i>&nbsp;     * {@code cleanup} will always be invoked with whatever exception that
<i>5911</i>&nbsp;     * {@code target} throws.  Declaring a narrower type may result in a
<i>5912</i>&nbsp;     * {@code ClassCastException} being thrown by the {@code try-finally}
<i>5913</i>&nbsp;     * handle if the type of the exception thrown by {@code target} is not
<i>5914</i>&nbsp;     * assignable to the first parameter type of {@code cleanup}.  Note that
<i>5915</i>&nbsp;     * various exception types of {@code VirtualMachineError},
<i>5916</i>&nbsp;     * {@code LinkageError}, and {@code RuntimeException} can in principle be
<i>5917</i>&nbsp;     * thrown by almost any kind of Java code, and a finally clause that
<i>5918</i>&nbsp;     * catches (say) only {@code IOException} would mask any of the others
<i>5919</i>&nbsp;     * behind a {@code ClassCastException}.
<i>5920</i>&nbsp;     *
<i>5921</i>&nbsp;     * @param target the handle whose execution is to be wrapped in a {@code try} block.
<i>5922</i>&nbsp;     * @param cleanup the handle that is invoked in the finally block.
<i>5923</i>&nbsp;     *
<i>5924</i>&nbsp;     * @return a method handle embodying the {@code try-finally} block composed of the two arguments.
<i>5925</i>&nbsp;     * @throws NullPointerException if any argument is null
<i>5926</i>&nbsp;     * @throws IllegalArgumentException if {@code cleanup} does not accept
<i>5927</i>&nbsp;     *          the required leading arguments, or if the method handle types do
<i>5928</i>&nbsp;     *          not match in their return types and their
<i>5929</i>&nbsp;     *          corresponding trailing parameters
<i>5930</i>&nbsp;     *
<i>5931</i>&nbsp;     * @see MethodHandles#catchException(MethodHandle, Class, MethodHandle)
<i>5932</i>&nbsp;     * @since 9
<i>5933</i>&nbsp;     */
<i>5934</i>&nbsp;    public static MethodHandle tryFinally(MethodHandle target, MethodHandle cleanup) {
<i>5935</i>&nbsp;        List&lt;Class&lt;?&gt;&gt; targetParamTypes = target.type().parameterList();
<i>5936</i>&nbsp;        Class&lt;?&gt; rtype = target.type().returnType();
<i>5937</i>&nbsp;
<i>5938</i>&nbsp;        tryFinallyChecks(target, cleanup);
<i>5939</i>&nbsp;
<i>5940</i>&nbsp;        // Match parameter lists: if the cleanup has a shorter parameter list than the target, add ignored arguments.
<i>5941</i>&nbsp;        // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
<i>5942</i>&nbsp;        // target parameter list.
<i>5943</i>&nbsp;        cleanup = dropArgumentsToMatch(cleanup, (rtype == void.class ? 1 : 2), targetParamTypes, 0);
<i>5944</i>&nbsp;
<i>5945</i>&nbsp;        // Ensure that the intrinsic type checks the instance thrown by the
<i>5946</i>&nbsp;        // target against the first parameter of cleanup
<i>5947</i>&nbsp;        cleanup = cleanup.asType(cleanup.type().changeParameterType(0, Throwable.class));
<i>5948</i>&nbsp;
<i>5949</i>&nbsp;        // Use asFixedArity() to avoid unnecessary boxing of last argument for VarargsCollector case.
<i>5950</i>&nbsp;        return MethodHandleImpl.makeTryFinally(target.asFixedArity(), cleanup.asFixedArity(), rtype, targetParamTypes);
<i>5951</i>&nbsp;    }
<i>5952</i>&nbsp;
<i>5953</i>&nbsp;    private static void tryFinallyChecks(MethodHandle target, MethodHandle cleanup) {
<i>5954</i>&nbsp;        Class&lt;?&gt; rtype = target.type().returnType();
<i>5955</i>&nbsp;        if (rtype != cleanup.type().returnType()) {
<i>5956</i>&nbsp;            throw misMatchedTypes(&quot;target and return types&quot;, cleanup.type().returnType(), rtype);
<i>5957</i>&nbsp;        }
<i>5958</i>&nbsp;        MethodType cleanupType = cleanup.type();
<i>5959</i>&nbsp;        if (!Throwable.class.isAssignableFrom(cleanupType.parameterType(0))) {
<i>5960</i>&nbsp;            throw misMatchedTypes(&quot;cleanup first argument and Throwable&quot;, cleanup.type(), Throwable.class);
<i>5961</i>&nbsp;        }
<i>5962</i>&nbsp;        if (rtype != void.class &amp;&amp; cleanupType.parameterType(1) != rtype) {
<i>5963</i>&nbsp;            throw misMatchedTypes(&quot;cleanup second argument and target return type&quot;, cleanup.type(), rtype);
<i>5964</i>&nbsp;        }
<i>5965</i>&nbsp;        // The cleanup parameter list (minus the leading Throwable and result parameters) must be a sublist of the
<i>5966</i>&nbsp;        // target parameter list.
<i>5967</i>&nbsp;        int cleanupArgIndex = rtype == void.class ? 1 : 2;
<i>5968</i>&nbsp;        if (!cleanupType.effectivelyIdenticalParameters(cleanupArgIndex, target.type().parameterList())) {
<i>5969</i>&nbsp;            throw misMatchedTypes(&quot;cleanup parameters after (Throwable,result) and target parameter list prefix&quot;,
<i>5970</i>&nbsp;                    cleanup.type(), target.type());
<i>5971</i>&nbsp;        }
<i>5972</i>&nbsp;    }
<i>5973</i>&nbsp;
<i>5974</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
