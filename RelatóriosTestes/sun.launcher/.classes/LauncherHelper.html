


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: LauncherHelper</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.launcher</a> ]
</div>

<h1>Coverage Summary for Class: LauncherHelper (sun.launcher)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LauncherHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 228)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LauncherHelper$FXHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LauncherHelper$ResourceBundleHolder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LauncherHelper$SizePrefix</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LauncherHelper$StdArg</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 284)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.launcher;
<i>27</i>&nbsp;
<i>28</i>&nbsp;/*
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any API supported by Sun Microsystems.
<i>31</i>&nbsp; *  If you write code that depends on this, you do so at your own
<i>32</i>&nbsp; *  risk.  This code and its internal interfaces are subject to change
<i>33</i>&nbsp; *  or deletion without notice.&lt;/b&gt;
<i>34</i>&nbsp; *
<i>35</i>&nbsp; */
<i>36</i>&nbsp;
<i>37</i>&nbsp;/**
<i>38</i>&nbsp; * A utility package for the java(1), javaw(1) launchers.
<i>39</i>&nbsp; * The following are helper methods that the native launcher uses
<i>40</i>&nbsp; * to perform checks etc. using JNI, see src/share/bin/java.c
<i>41</i>&nbsp; */
<i>42</i>&nbsp;import java.io.File;
<i>43</i>&nbsp;import java.io.IOException;
<i>44</i>&nbsp;import java.io.PrintStream;
<i>45</i>&nbsp;import java.io.UnsupportedEncodingException;
<i>46</i>&nbsp;import java.lang.module.Configuration;
<i>47</i>&nbsp;import java.lang.module.ModuleDescriptor;
<i>48</i>&nbsp;import java.lang.module.ModuleDescriptor.Requires;
<i>49</i>&nbsp;import java.lang.module.ModuleDescriptor.Exports;
<i>50</i>&nbsp;import java.lang.module.ModuleDescriptor.Opens;
<i>51</i>&nbsp;import java.lang.module.ModuleDescriptor.Provides;
<i>52</i>&nbsp;import java.lang.module.ModuleFinder;
<i>53</i>&nbsp;import java.lang.module.ModuleReference;
<i>54</i>&nbsp;import java.lang.module.ResolvedModule;
<i>55</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>56</i>&nbsp;import java.lang.reflect.Method;
<i>57</i>&nbsp;import java.lang.reflect.Modifier;
<i>58</i>&nbsp;import java.math.BigDecimal;
<i>59</i>&nbsp;import java.math.RoundingMode;
<i>60</i>&nbsp;import java.net.URI;
<i>61</i>&nbsp;import java.nio.charset.Charset;
<i>62</i>&nbsp;import java.nio.file.DirectoryStream;
<i>63</i>&nbsp;import java.nio.file.Files;
<i>64</i>&nbsp;import java.nio.file.Path;
<i>65</i>&nbsp;import java.text.Normalizer;
<i>66</i>&nbsp;import java.text.MessageFormat;
<i>67</i>&nbsp;import java.util.ArrayList;
<i>68</i>&nbsp;import java.util.Collections;
<i>69</i>&nbsp;import java.util.Comparator;
<b class="nc"><i>70</i>&nbsp;import java.util.Iterator;</b>
<b class="nc"><i>71</i>&nbsp;import java.util.List;</b>
<i>72</i>&nbsp;import java.util.Locale;
<i>73</i>&nbsp;import java.util.Locale.Category;
<b class="nc"><i>74</i>&nbsp;import java.util.Optional;</b>
<i>75</i>&nbsp;import java.util.Properties;
<i>76</i>&nbsp;import java.util.ResourceBundle;
<i>77</i>&nbsp;import java.util.Set;
<i>78</i>&nbsp;import java.util.TreeSet;
<i>79</i>&nbsp;import java.util.jar.Attributes;
<i>80</i>&nbsp;import java.util.jar.JarFile;
<i>81</i>&nbsp;import java.util.jar.Manifest;
<i>82</i>&nbsp;import java.util.stream.Collectors;
<b class="nc"><i>83</i>&nbsp;import java.util.stream.Stream;</b>
<i>84</i>&nbsp;
<i>85</i>&nbsp;import jdk.internal.misc.VM;
<i>86</i>&nbsp;import jdk.internal.module.ModuleBootstrap;
<b class="nc"><i>87</i>&nbsp;import jdk.internal.module.Modules;</b>
<i>88</i>&nbsp;import jdk.internal.platform.Container;
<b class="nc"><i>89</i>&nbsp;import jdk.internal.platform.Metrics;</b>
<i>90</i>&nbsp;
<i>91</i>&nbsp;
<b class="nc"><i>92</i>&nbsp;public final class LauncherHelper {</b>
<i>93</i>&nbsp;
<i>94</i>&nbsp;    // No instantiation
<i>95</i>&nbsp;    private LauncherHelper() {}
<i>96</i>&nbsp;
<i>97</i>&nbsp;    // used to identify JavaFX applications
<i>98</i>&nbsp;    private static final String JAVAFX_APPLICATION_MARKER =
<i>99</i>&nbsp;            &quot;JavaFX-Application-Class&quot;;
<i>100</i>&nbsp;    private static final String JAVAFX_APPLICATION_CLASS_NAME =
<i>101</i>&nbsp;            &quot;javafx.application.Application&quot;;
<i>102</i>&nbsp;    private static final String JAVAFX_FXHELPER_CLASS_NAME_SUFFIX =
<i>103</i>&nbsp;            &quot;sun.launcher.LauncherHelper$FXHelper&quot;;
<i>104</i>&nbsp;    private static final String LAUNCHER_AGENT_CLASS = &quot;Launcher-Agent-Class&quot;;
<i>105</i>&nbsp;    private static final String MAIN_CLASS = &quot;Main-Class&quot;;
<i>106</i>&nbsp;    private static final String ADD_EXPORTS = &quot;Add-Exports&quot;;
<i>107</i>&nbsp;    private static final String ADD_OPENS = &quot;Add-Opens&quot;;
<i>108</i>&nbsp;
<i>109</i>&nbsp;    private static StringBuilder outBuf = new StringBuilder();
<i>110</i>&nbsp;
<i>111</i>&nbsp;    private static final String INDENT = &quot;    &quot;;
<i>112</i>&nbsp;    private static final String VM_SETTINGS     = &quot;VM settings:&quot;;
<i>113</i>&nbsp;    private static final String PROP_SETTINGS   = &quot;Property settings:&quot;;
<i>114</i>&nbsp;    private static final String LOCALE_SETTINGS = &quot;Locale settings:&quot;;
<i>115</i>&nbsp;
<i>116</i>&nbsp;    // sync with java.c and jdk.internal.misc.VM
<i>117</i>&nbsp;    private static final String diagprop = &quot;sun.java.launcher.diag&quot;;
<i>118</i>&nbsp;    static final boolean trace = VM.getSavedProperty(diagprop) != null;
<i>119</i>&nbsp;
<i>120</i>&nbsp;    private static final String defaultBundleName =
<b class="nc"><i>121</i>&nbsp;            &quot;sun.launcher.resources.launcher&quot;;</b>
<b class="nc"><i>122</i>&nbsp;    private static class ResourceBundleHolder {</b>
<b class="nc"><i>123</i>&nbsp;        private static final ResourceBundle RB =</b>
<b class="nc"><i>124</i>&nbsp;                ResourceBundle.getBundle(defaultBundleName);</b>
<i>125</i>&nbsp;    }
<b class="nc"><i>126</i>&nbsp;    private static PrintStream ostream;</b>
<i>127</i>&nbsp;    private static Class&lt;?&gt; appClass; // application class, for GUI/reporting purposes
<b class="nc"><i>128</i>&nbsp;</b>
<i>129</i>&nbsp;    /*
<b class="nc"><i>130</i>&nbsp;     * A method called by the launcher to print out the standard settings,</b>
<i>131</i>&nbsp;     * by default -XshowSettings is equivalent to -XshowSettings:all,
<b class="nc"><i>132</i>&nbsp;     * Specific information may be gotten by using suboptions with possible</b>
<b class="nc"><i>133</i>&nbsp;     * values vm, properties and locale.</b>
<i>134</i>&nbsp;     *
<b class="nc"><i>135</i>&nbsp;     * printToStderr: choose between stdout and stderr</b>
<b class="nc"><i>136</i>&nbsp;     *</b>
<i>137</i>&nbsp;     * optionFlag: specifies which options to print default is all other
<b class="nc"><i>138</i>&nbsp;     *    possible values are vm, properties, locale.</b>
<i>139</i>&nbsp;     *
<b class="nc"><i>140</i>&nbsp;     * initialHeapSize: in bytes, as set by the launcher, a zero-value indicates</b>
<b class="nc"><i>141</i>&nbsp;     *    this code should determine this value, using a suitable method or</b>
<i>142</i>&nbsp;     *    the line could be omitted.
<i>143</i>&nbsp;     *
<i>144</i>&nbsp;     * maxHeapSize: in bytes, as set by the launcher, a zero-value indicates
<i>145</i>&nbsp;     *    this code should determine this value, using a suitable method.
<i>146</i>&nbsp;     *
<i>147</i>&nbsp;     * stackSize: in bytes, as set by the launcher, a zero-value indicates
<i>148</i>&nbsp;     *    this code determine this value, using a suitable method or omit the
<i>149</i>&nbsp;     *    line entirely.
<i>150</i>&nbsp;     */
<i>151</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)
<i>152</i>&nbsp;    static void showSettings(boolean printToStderr, String optionFlag,
<b class="nc"><i>153</i>&nbsp;            long initialHeapSize, long maxHeapSize, long stackSize) {</b>
<b class="nc"><i>154</i>&nbsp;</b>
<b class="nc"><i>155</i>&nbsp;        initOutput(printToStderr);</b>
<b class="nc"><i>156</i>&nbsp;        String opts[] = optionFlag.split(&quot;:&quot;);</b>
<i>157</i>&nbsp;        String optStr = (opts.length &gt; 1 &amp;&amp; opts[1] != null)
<b class="nc"><i>158</i>&nbsp;                ? opts[1].trim()</b>
<b class="nc"><i>159</i>&nbsp;                : &quot;all&quot;;</b>
<b class="nc"><i>160</i>&nbsp;        switch (optStr) {</b>
<i>161</i>&nbsp;            case &quot;vm&quot;:
<b class="nc"><i>162</i>&nbsp;                printVmSettings(initialHeapSize, maxHeapSize, stackSize);</b>
<b class="nc"><i>163</i>&nbsp;                break;</b>
<b class="nc"><i>164</i>&nbsp;            case &quot;properties&quot;:</b>
<i>165</i>&nbsp;                printProperties();
<b class="nc"><i>166</i>&nbsp;                break;</b>
<b class="nc"><i>167</i>&nbsp;            case &quot;locale&quot;:</b>
<i>168</i>&nbsp;                printLocale();
<b class="nc"><i>169</i>&nbsp;                break;</b>
<i>170</i>&nbsp;            case &quot;system&quot;:
<b class="nc"><i>171</i>&nbsp;                if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {</b>
<b class="nc"><i>172</i>&nbsp;                    printSystemMetrics();</b>
<b class="nc"><i>173</i>&nbsp;                    break;</b>
<i>174</i>&nbsp;                }
<i>175</i>&nbsp;            default:
<i>176</i>&nbsp;                printVmSettings(initialHeapSize, maxHeapSize, stackSize);
<i>177</i>&nbsp;                printProperties();
<i>178</i>&nbsp;                printLocale();
<i>179</i>&nbsp;                if (System.getProperty(&quot;os.name&quot;).contains(&quot;Linux&quot;)) {
<b class="nc"><i>180</i>&nbsp;                    printSystemMetrics();</b>
<b class="nc"><i>181</i>&nbsp;                }</b>
<b class="nc"><i>182</i>&nbsp;                break;</b>
<b class="nc"><i>183</i>&nbsp;        }</b>
<b class="nc"><i>184</i>&nbsp;    }</b>
<b class="nc"><i>185</i>&nbsp;</b>
<b class="nc"><i>186</i>&nbsp;    /*</b>
<b class="nc"><i>187</i>&nbsp;     * prints the main vm settings subopt/section</b>
<b class="nc"><i>188</i>&nbsp;     */</b>
<i>189</i>&nbsp;    private static void printVmSettings(
<i>190</i>&nbsp;            long initialHeapSize, long maxHeapSize,
<i>191</i>&nbsp;            long stackSize) {
<b class="nc"><i>192</i>&nbsp;</b>
<i>193</i>&nbsp;        ostream.println(VM_SETTINGS);
<i>194</i>&nbsp;        if (stackSize != 0L) {
<i>195</i>&nbsp;            ostream.println(INDENT + &quot;Stack Size: &quot; +
<b class="nc"><i>196</i>&nbsp;                    SizePrefix.scaleValue(stackSize));</b>
<b class="nc"><i>197</i>&nbsp;        }</b>
<b class="nc"><i>198</i>&nbsp;        if (initialHeapSize != 0L) {</b>
<b class="nc"><i>199</i>&nbsp;             ostream.println(INDENT + &quot;Min. Heap Size: &quot; +</b>
<i>200</i>&nbsp;                    SizePrefix.scaleValue(initialHeapSize));
<b class="nc"><i>201</i>&nbsp;        }</b>
<b class="nc"><i>202</i>&nbsp;        if (maxHeapSize != 0L) {</b>
<i>203</i>&nbsp;            ostream.println(INDENT + &quot;Max. Heap Size: &quot; +
<b class="nc"><i>204</i>&nbsp;                    SizePrefix.scaleValue(maxHeapSize));</b>
<b class="nc"><i>205</i>&nbsp;        } else {</b>
<i>206</i>&nbsp;            ostream.println(INDENT + &quot;Max. Heap Size (Estimated): &quot;
<i>207</i>&nbsp;                    + SizePrefix.scaleValue(Runtime.getRuntime().maxMemory()));
<i>208</i>&nbsp;        }
<b class="nc"><i>209</i>&nbsp;        ostream.println(INDENT + &quot;Using VM: &quot;</b>
<i>210</i>&nbsp;                + System.getProperty(&quot;java.vm.name&quot;));
<i>211</i>&nbsp;        ostream.println();
<i>212</i>&nbsp;    }
<b class="nc"><i>213</i>&nbsp;</b>
<i>214</i>&nbsp;    /*
<i>215</i>&nbsp;     * prints the properties subopt/section
<b class="nc"><i>216</i>&nbsp;     */</b>
<b class="nc"><i>217</i>&nbsp;    private static void printProperties() {</b>
<i>218</i>&nbsp;        Properties p = System.getProperties();
<i>219</i>&nbsp;        ostream.println(PROP_SETTINGS);
<b class="nc"><i>220</i>&nbsp;        List&lt;String&gt; sortedPropertyKeys = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>221</i>&nbsp;        sortedPropertyKeys.addAll(p.stringPropertyNames());</b>
<b class="nc"><i>222</i>&nbsp;        Collections.sort(sortedPropertyKeys);</b>
<b class="nc"><i>223</i>&nbsp;        for (String x : sortedPropertyKeys) {</b>
<b class="nc"><i>224</i>&nbsp;            printPropertyValue(x, p.getProperty(x));</b>
<b class="nc"><i>225</i>&nbsp;        }</b>
<i>226</i>&nbsp;        ostream.println();
<b class="nc"><i>227</i>&nbsp;    }</b>
<i>228</i>&nbsp;
<i>229</i>&nbsp;    private static boolean isPath(String key) {
<i>230</i>&nbsp;        return key.endsWith(&quot;.dirs&quot;) || key.endsWith(&quot;.path&quot;);
<i>231</i>&nbsp;    }
<i>232</i>&nbsp;
<i>233</i>&nbsp;    private static void printPropertyValue(String key, String value) {
<i>234</i>&nbsp;        ostream.print(INDENT + key + &quot; = &quot;);
<i>235</i>&nbsp;        if (key.equals(&quot;line.separator&quot;)) {
<b class="nc"><i>236</i>&nbsp;            for (byte b : value.getBytes()) {</b>
<b class="nc"><i>237</i>&nbsp;                switch (b) {</b>
<b class="nc"><i>238</i>&nbsp;                    case 0xd:</b>
<b class="nc"><i>239</i>&nbsp;                        ostream.print(&quot;\\r &quot;);</b>
<b class="nc"><i>240</i>&nbsp;                        break;</b>
<b class="nc"><i>241</i>&nbsp;                    case 0xa:</b>
<b class="nc"><i>242</i>&nbsp;                        ostream.print(&quot;\\n &quot;);</b>
<b class="nc"><i>243</i>&nbsp;                        break;</b>
<b class="nc"><i>244</i>&nbsp;                    default:</b>
<b class="nc"><i>245</i>&nbsp;                        // print any bizzare line separators in hex, but really</b>
<i>246</i>&nbsp;                        // shouldn&#39;t happen.
<i>247</i>&nbsp;                        ostream.printf(&quot;0x%02X&quot;, b &amp; 0xff);
<i>248</i>&nbsp;                        break;
<b class="nc"><i>249</i>&nbsp;                }</b>
<b class="nc"><i>250</i>&nbsp;            }</b>
<b class="nc"><i>251</i>&nbsp;            ostream.println();</b>
<i>252</i>&nbsp;            return;
<i>253</i>&nbsp;        }
<i>254</i>&nbsp;        if (!isPath(key)) {
<i>255</i>&nbsp;            ostream.println(value);
<b class="nc"><i>256</i>&nbsp;            return;</b>
<b class="nc"><i>257</i>&nbsp;        }</b>
<b class="nc"><i>258</i>&nbsp;        String[] values = value.split(System.getProperty(&quot;path.separator&quot;));</b>
<i>259</i>&nbsp;        boolean first = true;
<i>260</i>&nbsp;        for (String s : values) {
<b class="nc"><i>261</i>&nbsp;            if (first) { // first line treated specially</b>
<b class="nc"><i>262</i>&nbsp;                ostream.println(s);</b>
<b class="nc"><i>263</i>&nbsp;                first = false;</b>
<b class="nc"><i>264</i>&nbsp;            } else { // following lines prefix with indents</b>
<b class="nc"><i>265</i>&nbsp;                ostream.println(INDENT + INDENT + s);</b>
<b class="nc"><i>266</i>&nbsp;            }</b>
<b class="nc"><i>267</i>&nbsp;        }</b>
<b class="nc"><i>268</i>&nbsp;    }</b>
<i>269</i>&nbsp;
<i>270</i>&nbsp;    /*
<b class="nc"><i>271</i>&nbsp;     * prints the locale subopt/section</b>
<b class="nc"><i>272</i>&nbsp;     */</b>
<b class="nc"><i>273</i>&nbsp;    private static void printLocale() {</b>
<i>274</i>&nbsp;        Locale locale = Locale.getDefault();
<i>275</i>&nbsp;        ostream.println(LOCALE_SETTINGS);
<i>276</i>&nbsp;        ostream.println(INDENT + &quot;default locale = &quot; +
<i>277</i>&nbsp;                locale.getDisplayName());
<b class="nc"><i>278</i>&nbsp;        ostream.println(INDENT + &quot;default display locale = &quot; +</b>
<i>279</i>&nbsp;                Locale.getDefault(Category.DISPLAY).getDisplayName());
<b class="nc"><i>280</i>&nbsp;        ostream.println(INDENT + &quot;default format locale = &quot; +</b>
<b class="nc"><i>281</i>&nbsp;                Locale.getDefault(Category.FORMAT).getDisplayName());</b>
<b class="nc"><i>282</i>&nbsp;        printLocales();</b>
<b class="nc"><i>283</i>&nbsp;        ostream.println();</b>
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;    private static void printLocales() {
<b class="nc"><i>287</i>&nbsp;        Locale[] tlocales = Locale.getAvailableLocales();</b>
<b class="nc"><i>288</i>&nbsp;        final int len = tlocales == null ? 0 : tlocales.length;</b>
<b class="nc"><i>289</i>&nbsp;        if (len &lt; 1 ) {</b>
<i>290</i>&nbsp;            return;
<i>291</i>&nbsp;        }
<i>292</i>&nbsp;        // Locale does not implement Comparable so we convert it to String
<b class="nc"><i>293</i>&nbsp;        // and sort it for pretty printing.</b>
<b class="nc"><i>294</i>&nbsp;        Set&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</b>
<i>295</i>&nbsp;        for (Locale l : tlocales) {
<i>296</i>&nbsp;            sortedSet.add(l.toString());
<i>297</i>&nbsp;        }
<i>298</i>&nbsp;
<i>299</i>&nbsp;        ostream.print(INDENT + &quot;available locales = &quot;);
<i>300</i>&nbsp;        Iterator&lt;String&gt; iter = sortedSet.iterator();
<i>301</i>&nbsp;        final int last = len - 1;
<b class="nc"><i>302</i>&nbsp;        for (int i = 0 ; iter.hasNext() ; i++) {</b>
<b class="nc"><i>303</i>&nbsp;            String s = iter.next();</b>
<b class="nc"><i>304</i>&nbsp;            ostream.print(s);</b>
<b class="nc"><i>305</i>&nbsp;            if (i != last) {</b>
<b class="nc"><i>306</i>&nbsp;                ostream.print(&quot;, &quot;);</b>
<b class="nc"><i>307</i>&nbsp;            }</b>
<i>308</i>&nbsp;            // print columns of 8
<b class="nc"><i>309</i>&nbsp;            if ((i + 1) % 8 == 0) {</b>
<i>310</i>&nbsp;                ostream.println();
<i>311</i>&nbsp;                ostream.print(INDENT + INDENT);
<i>312</i>&nbsp;            }
<i>313</i>&nbsp;        }
<i>314</i>&nbsp;    }
<i>315</i>&nbsp;
<i>316</i>&nbsp;    public static void printSystemMetrics() {
<i>317</i>&nbsp;        Metrics c = Container.metrics();
<i>318</i>&nbsp;
<b class="nc"><i>319</i>&nbsp;        ostream.println(&quot;Operating System Metrics:&quot;);</b>
<b class="nc"><i>320</i>&nbsp;</b>
<i>321</i>&nbsp;        if (c == null) {
<i>322</i>&nbsp;            ostream.println(INDENT + &quot;No metrics available for this platform&quot;);
<i>323</i>&nbsp;            return;
<i>324</i>&nbsp;        }
<i>325</i>&nbsp;
<i>326</i>&nbsp;        ostream.println(INDENT + &quot;Provider: &quot; + c.getProvider());
<i>327</i>&nbsp;        ostream.println(INDENT + &quot;Effective CPU Count: &quot; + c.getEffectiveCpuCount());
<i>328</i>&nbsp;        ostream.println(INDENT + &quot;CPU Period: &quot; + c.getCpuPeriod() +
<i>329</i>&nbsp;               (c.getCpuPeriod() == -1 ? &quot;&quot; : &quot;us&quot;));
<i>330</i>&nbsp;        ostream.println(INDENT + &quot;CPU Quota: &quot; + c.getCpuQuota() +
<b class="nc"><i>331</i>&nbsp;               (c.getCpuQuota() == -1 ? &quot;&quot; : &quot;us&quot;));</b>
<i>332</i>&nbsp;        ostream.println(INDENT + &quot;CPU Shares: &quot; + c.getCpuShares());
<b class="nc"><i>333</i>&nbsp;</b>
<b class="nc"><i>334</i>&nbsp;        int cpus[] = c.getCpuSetCpus();</b>
<b class="nc"><i>335</i>&nbsp;        ostream.println(INDENT + &quot;List of Processors, &quot;</b>
<b class="nc"><i>336</i>&nbsp;                + cpus.length + &quot; total: &quot;);</b>
<i>337</i>&nbsp;
<i>338</i>&nbsp;        ostream.print(INDENT);
<i>339</i>&nbsp;        for (int i = 0; i &lt; cpus.length; i++) {
<i>340</i>&nbsp;            ostream.print(cpus[i] + &quot; &quot;);
<i>341</i>&nbsp;        }
<i>342</i>&nbsp;        if (cpus.length &gt; 0) {
<i>343</i>&nbsp;            ostream.println(&quot;&quot;);
<b class="nc"><i>344</i>&nbsp;        }</b>
<i>345</i>&nbsp;
<i>346</i>&nbsp;        cpus = c.getEffectiveCpuSetCpus();
<i>347</i>&nbsp;        ostream.println(INDENT + &quot;List of Effective Processors, &quot;
<i>348</i>&nbsp;                + cpus.length + &quot; total: &quot;);
<i>349</i>&nbsp;
<i>350</i>&nbsp;        ostream.print(INDENT);
<i>351</i>&nbsp;        for (int i = 0; i &lt; cpus.length; i++) {
<i>352</i>&nbsp;            ostream.print(cpus[i] + &quot; &quot;);
<b class="nc"><i>353</i>&nbsp;        }</b>
<i>354</i>&nbsp;        if (cpus.length &gt; 0) {
<i>355</i>&nbsp;            ostream.println(&quot;&quot;);
<i>356</i>&nbsp;        }
<i>357</i>&nbsp;
<i>358</i>&nbsp;        int mems[] = c.getCpuSetMems();
<i>359</i>&nbsp;        ostream.println(INDENT + &quot;List of Memory Nodes, &quot;
<i>360</i>&nbsp;                + mems.length + &quot; total: &quot;);
<i>361</i>&nbsp;
<b class="nc"><i>362</i>&nbsp;        ostream.print(INDENT);</b>
<i>363</i>&nbsp;        for (int i = 0; i &lt; mems.length; i++) {
<b class="nc"><i>364</i>&nbsp;            ostream.print(mems[i] + &quot; &quot;);</b>
<b class="nc"><i>365</i>&nbsp;        }</b>
<b class="nc"><i>366</i>&nbsp;        if (mems.length &gt; 0) {</b>
<b class="nc"><i>367</i>&nbsp;            ostream.println(&quot;&quot;);</b>
<i>368</i>&nbsp;        }
<i>369</i>&nbsp;
<i>370</i>&nbsp;        mems = c.getEffectiveCpuSetMems();
<i>371</i>&nbsp;        ostream.println(INDENT + &quot;List of Available Memory Nodes, &quot;
<i>372</i>&nbsp;                + mems.length + &quot; total: &quot;);
<i>373</i>&nbsp;
<i>374</i>&nbsp;        ostream.print(INDENT);
<i>375</i>&nbsp;        for (int i = 0; i &lt; mems.length; i++) {
<b class="nc"><i>376</i>&nbsp;            ostream.print(mems[i] + &quot; &quot;);</b>
<b class="nc"><i>377</i>&nbsp;        }</b>
<i>378</i>&nbsp;        if (mems.length &gt; 0) {
<b class="nc"><i>379</i>&nbsp;            ostream.println(&quot;&quot;);</b>
<i>380</i>&nbsp;        }
<i>381</i>&nbsp;
<i>382</i>&nbsp;        ostream.println(INDENT + &quot;CPUSet Memory Pressure Enabled: &quot;
<i>383</i>&nbsp;                + c.isCpuSetMemoryPressureEnabled());
<i>384</i>&nbsp;
<i>385</i>&nbsp;        long limit = c.getMemoryLimit();
<b class="nc"><i>386</i>&nbsp;        ostream.println(INDENT + &quot;Memory Limit: &quot; +</b>
<b class="nc"><i>387</i>&nbsp;                ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));</b>
<i>388</i>&nbsp;
<b class="nc"><i>389</i>&nbsp;        limit = c.getMemorySoftLimit();</b>
<b class="nc"><i>390</i>&nbsp;        ostream.println(INDENT + &quot;Memory Soft Limit: &quot; +</b>
<i>391</i>&nbsp;                ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
<i>392</i>&nbsp;
<i>393</i>&nbsp;        limit = c.getMemoryAndSwapLimit();
<i>394</i>&nbsp;        ostream.println(INDENT + &quot;Memory &amp; Swap Limit: &quot; +
<i>395</i>&nbsp;                ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
<b class="nc"><i>396</i>&nbsp;</b>
<i>397</i>&nbsp;        limit = c.getKernelMemoryLimit();
<i>398</i>&nbsp;        ostream.println(INDENT + &quot;Kernel Memory Limit: &quot; +
<i>399</i>&nbsp;                ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));
<b class="nc"><i>400</i>&nbsp;</b>
<b class="nc"><i>401</i>&nbsp;        limit = c.getTcpMemoryLimit();</b>
<b class="nc"><i>402</i>&nbsp;        ostream.println(INDENT + &quot;TCP Memory Limit: &quot; +</b>
<b class="nc"><i>403</i>&nbsp;                ((limit &gt;= 0) ? SizePrefix.scaleValue(limit) : &quot;Unlimited&quot;));</b>
<b class="nc"><i>404</i>&nbsp;</b>
<i>405</i>&nbsp;        ostream.println(INDENT + &quot;Out Of Memory Killer Enabled: &quot;
<b class="nc"><i>406</i>&nbsp;                + c.isMemoryOOMKillEnabled());</b>
<b class="nc"><i>407</i>&nbsp;</b>
<b class="nc"><i>408</i>&nbsp;        ostream.println(&quot;&quot;);</b>
<i>409</i>&nbsp;    }
<b class="nc"><i>410</i>&nbsp;</b>
<b class="nc"><i>411</i>&nbsp;    private enum SizePrefix {</b>
<b class="nc"><i>412</i>&nbsp;</b>
<i>413</i>&nbsp;        KILO(1024, &quot;K&quot;),
<i>414</i>&nbsp;        MEGA(1024 * 1024, &quot;M&quot;),
<i>415</i>&nbsp;        GIGA(1024 * 1024 * 1024, &quot;G&quot;),
<i>416</i>&nbsp;        TERA(1024L * 1024L * 1024L * 1024L, &quot;T&quot;);
<i>417</i>&nbsp;        long size;
<i>418</i>&nbsp;        String abbrev;
<i>419</i>&nbsp;
<b class="nc"><i>420</i>&nbsp;        SizePrefix(long size, String abbrev) {</b>
<i>421</i>&nbsp;            this.size = size;
<b class="nc"><i>422</i>&nbsp;            this.abbrev = abbrev;</b>
<i>423</i>&nbsp;        }
<i>424</i>&nbsp;
<b class="nc"><i>425</i>&nbsp;        private static String scale(long v, SizePrefix prefix) {</b>
<b class="nc"><i>426</i>&nbsp;            return BigDecimal.valueOf(v).divide(BigDecimal.valueOf(prefix.size),</b>
<b class="nc"><i>427</i>&nbsp;                    2, RoundingMode.HALF_EVEN).toPlainString() + prefix.abbrev;</b>
<i>428</i>&nbsp;        }
<b class="nc"><i>429</i>&nbsp;        /*</b>
<i>430</i>&nbsp;         * scale the incoming values to a human readable form, represented as
<i>431</i>&nbsp;         * K, M, G and T, see java.c parse_size for the scaled values and
<i>432</i>&nbsp;         * suffixes. The lowest possible scaled value is Kilo.
<i>433</i>&nbsp;         */
<i>434</i>&nbsp;        static String scaleValue(long v) {
<i>435</i>&nbsp;            if (v &lt; MEGA.size) {
<i>436</i>&nbsp;                return scale(v, KILO);
<i>437</i>&nbsp;            } else if (v &lt; GIGA.size) {
<i>438</i>&nbsp;                return scale(v, MEGA);
<i>439</i>&nbsp;            } else if (v &lt; TERA.size) {
<b class="nc"><i>440</i>&nbsp;                return scale(v, GIGA);</b>
<b class="nc"><i>441</i>&nbsp;            } else {</b>
<i>442</i>&nbsp;                return scale(v, TERA);
<b class="nc"><i>443</i>&nbsp;            }</b>
<b class="nc"><i>444</i>&nbsp;        }</b>
<b class="nc"><i>445</i>&nbsp;    }</b>
<i>446</i>&nbsp;
<b class="nc"><i>447</i>&nbsp;    /**</b>
<i>448</i>&nbsp;     * A private helper method to get a localized message and also
<i>449</i>&nbsp;     * apply any arguments that we might pass.
<b class="nc"><i>450</i>&nbsp;     */</b>
<i>451</i>&nbsp;    private static String getLocalizedMessage(String key, Object... args) {
<i>452</i>&nbsp;        String msg = ResourceBundleHolder.RB.getString(key);
<i>453</i>&nbsp;        return (args != null) ? MessageFormat.format(msg, args) : msg;
<i>454</i>&nbsp;    }
<i>455</i>&nbsp;
<i>456</i>&nbsp;    /**
<i>457</i>&nbsp;     * The java -help message is split into 3 parts, an invariant, followed
<i>458</i>&nbsp;     * by a set of platform dependent variant messages, finally an invariant
<i>459</i>&nbsp;     * set of lines.
<i>460</i>&nbsp;     * This method initializes the help message for the first time, and also
<i>461</i>&nbsp;     * assembles the invariant header part of the message.
<i>462</i>&nbsp;     */
<i>463</i>&nbsp;    static void initHelpMessage(String progname) {
<i>464</i>&nbsp;        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.header&quot;,
<i>465</i>&nbsp;                (progname == null) ? &quot;java&quot; : progname ));
<i>466</i>&nbsp;    }
<i>467</i>&nbsp;
<i>468</i>&nbsp;    /**
<i>469</i>&nbsp;     * Appends the vm selection messages to the header, already created.
<i>470</i>&nbsp;     * initHelpSystem must already be called.
<i>471</i>&nbsp;     */
<i>472</i>&nbsp;    static void appendVmSelectMessage(String vm1, String vm2) {
<i>473</i>&nbsp;        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.vmselect&quot;,
<i>474</i>&nbsp;                vm1, vm2));
<i>475</i>&nbsp;    }
<i>476</i>&nbsp;
<i>477</i>&nbsp;    /**
<b class="nc"><i>478</i>&nbsp;     * Appends the vm synoym message to the header, already created.</b>
<i>479</i>&nbsp;     * initHelpSystem must be called before using this method.
<b class="nc"><i>480</i>&nbsp;     */</b>
<b class="nc"><i>481</i>&nbsp;    static void appendVmSynonymMessage(String vm1, String vm2) {</b>
<i>482</i>&nbsp;        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.hotspot&quot;,
<b class="nc"><i>483</i>&nbsp;                vm1, vm2));</b>
<b class="nc"><i>484</i>&nbsp;    }</b>
<i>485</i>&nbsp;
<b class="nc"><i>486</i>&nbsp;    /**</b>
<b class="nc"><i>487</i>&nbsp;     * Appends the last invariant part to the previously created messages,</b>
<i>488</i>&nbsp;     * and finishes up the printing to the desired output stream.
<i>489</i>&nbsp;     * initHelpSystem must be called before using this method.
<b class="nc"><i>490</i>&nbsp;     */</b>
<i>491</i>&nbsp;    static void printHelpMessage(boolean printToStderr) {
<b class="nc"><i>492</i>&nbsp;        initOutput(printToStderr);</b>
<b class="nc"><i>493</i>&nbsp;        outBuf = outBuf.append(getLocalizedMessage(&quot;java.launcher.opt.footer&quot;,</b>
<i>494</i>&nbsp;                File.pathSeparator));
<b class="nc"><i>495</i>&nbsp;        ostream.println(outBuf.toString());</b>
<b class="nc"><i>496</i>&nbsp;    }</b>
<b class="nc"><i>497</i>&nbsp;</b>
<b class="nc"><i>498</i>&nbsp;    /**</b>
<i>499</i>&nbsp;     * Prints the Xusage text to the desired output stream.
<i>500</i>&nbsp;     */
<i>501</i>&nbsp;    static void printXUsageMessage(boolean printToStderr) {
<i>502</i>&nbsp;        initOutput(printToStderr);
<b class="nc"><i>503</i>&nbsp;        ostream.println(getLocalizedMessage(&quot;java.launcher.X.usage&quot;,</b>
<b class="nc"><i>504</i>&nbsp;                File.pathSeparator));</b>
<b class="nc"><i>505</i>&nbsp;        if (System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;)) {</b>
<b class="nc"><i>506</i>&nbsp;            ostream.println(getLocalizedMessage(&quot;java.launcher.X.macosx.usage&quot;,</b>
<i>507</i>&nbsp;                        File.pathSeparator));
<b class="nc"><i>508</i>&nbsp;        }</b>
<i>509</i>&nbsp;    }
<b class="nc"><i>510</i>&nbsp;</b>
<i>511</i>&nbsp;    static void initOutput(boolean printToStderr) {
<b class="nc"><i>512</i>&nbsp;        ostream =  (printToStderr) ? System.err : System.out;</b>
<i>513</i>&nbsp;    }
<i>514</i>&nbsp;
<i>515</i>&nbsp;    static void initOutput(PrintStream ps) {
<i>516</i>&nbsp;        ostream = ps;
<i>517</i>&nbsp;    }
<i>518</i>&nbsp;
<b class="nc"><i>519</i>&nbsp;    static String getMainClassFromJar(String jarname) {</b>
<b class="nc"><i>520</i>&nbsp;        String mainValue;</b>
<i>521</i>&nbsp;        try (JarFile jarFile = new JarFile(jarname)) {
<b class="nc"><i>522</i>&nbsp;            Manifest manifest = jarFile.getManifest();</b>
<b class="nc"><i>523</i>&nbsp;            if (manifest == null) {</b>
<i>524</i>&nbsp;                abort(null, &quot;java.launcher.jar.error2&quot;, jarname);
<i>525</i>&nbsp;            }
<b class="nc"><i>526</i>&nbsp;            Attributes mainAttrs = manifest.getMainAttributes();</b>
<b class="nc"><i>527</i>&nbsp;            if (mainAttrs == null) {</b>
<i>528</i>&nbsp;                abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
<i>529</i>&nbsp;            }
<i>530</i>&nbsp;
<i>531</i>&nbsp;            // Main-Class
<i>532</i>&nbsp;            mainValue = mainAttrs.getValue(MAIN_CLASS);
<i>533</i>&nbsp;            if (mainValue == null) {
<i>534</i>&nbsp;                abort(null, &quot;java.launcher.jar.error3&quot;, jarname);
<i>535</i>&nbsp;            }
<i>536</i>&nbsp;
<b class="nc"><i>537</i>&nbsp;            // Launcher-Agent-Class (only check for this when Main-Class present)</b>
<i>538</i>&nbsp;            String agentClass = mainAttrs.getValue(LAUNCHER_AGENT_CLASS);
<i>539</i>&nbsp;            if (agentClass != null) {
<i>540</i>&nbsp;                ModuleLayer.boot().findModule(&quot;java.instrument&quot;).ifPresent(m -&gt; {
<i>541</i>&nbsp;                    try {
<i>542</i>&nbsp;                        String cn = &quot;sun.instrument.InstrumentationImpl&quot;;
<i>543</i>&nbsp;                        Class&lt;?&gt; clazz = Class.forName(cn, false, null);
<b class="nc"><i>544</i>&nbsp;                        Method loadAgent = clazz.getMethod(&quot;loadAgent&quot;, String.class);</b>
<b class="nc"><i>545</i>&nbsp;                        loadAgent.invoke(null, jarname);</b>
<i>546</i>&nbsp;                    } catch (Throwable e) {
<b class="nc"><i>547</i>&nbsp;                        if (e instanceof InvocationTargetException) e = e.getCause();</b>
<i>548</i>&nbsp;                        abort(e, &quot;java.launcher.jar.error4&quot;, jarname);
<i>549</i>&nbsp;                    }
<b class="nc"><i>550</i>&nbsp;                });</b>
<i>551</i>&nbsp;            }
<i>552</i>&nbsp;
<i>553</i>&nbsp;            // Add-Exports and Add-Opens
<i>554</i>&nbsp;            String exports = mainAttrs.getValue(ADD_EXPORTS);
<i>555</i>&nbsp;            if (exports != null) {
<i>556</i>&nbsp;                addExportsOrOpens(exports, false);
<b class="nc"><i>557</i>&nbsp;            }</b>
<b class="nc"><i>558</i>&nbsp;            String opens = mainAttrs.getValue(ADD_OPENS);</b>
<b class="nc"><i>559</i>&nbsp;            if (opens != null) {</b>
<b class="nc"><i>560</i>&nbsp;                addExportsOrOpens(opens, true);</b>
<i>561</i>&nbsp;            }
<b class="nc"><i>562</i>&nbsp;</b>
<b class="nc"><i>563</i>&nbsp;            /*</b>
<b class="nc"><i>564</i>&nbsp;             * Hand off to FXHelper if it detects a JavaFX application</b>
<i>565</i>&nbsp;             * This must be done after ensuring a Main-Class entry
<i>566</i>&nbsp;             * exists to enforce compliance with the jar specification
<i>567</i>&nbsp;             */
<i>568</i>&nbsp;            if (mainAttrs.containsKey(
<b class="nc"><i>569</i>&nbsp;                    new Attributes.Name(JAVAFX_APPLICATION_MARKER))) {</b>
<b class="nc"><i>570</i>&nbsp;                FXHelper.setFXLaunchParameters(jarname, LM_JAR);</b>
<i>571</i>&nbsp;                return FXHelper.class.getName();
<i>572</i>&nbsp;            }
<i>573</i>&nbsp;
<i>574</i>&nbsp;            return mainValue.trim();
<i>575</i>&nbsp;        } catch (IOException ioe) {
<i>576</i>&nbsp;            abort(ioe, &quot;java.launcher.jar.error1&quot;, jarname);
<b class="nc"><i>577</i>&nbsp;        }</b>
<b class="nc"><i>578</i>&nbsp;        return null;</b>
<b class="nc"><i>579</i>&nbsp;    }</b>
<b class="nc"><i>580</i>&nbsp;</b>
<i>581</i>&nbsp;    /**
<i>582</i>&nbsp;     * Process the Add-Exports or Add-Opens value. The value is
<b class="nc"><i>583</i>&nbsp;     * {@code &lt;module&gt;/&lt;package&gt; ( &lt;module&gt;/&lt;package&gt;)*}.</b>
<i>584</i>&nbsp;     */
<i>585</i>&nbsp;    static void addExportsOrOpens(String value, boolean open) {
<b class="nc"><i>586</i>&nbsp;        for (String moduleAndPackage : value.split(&quot; &quot;)) {</b>
<b class="nc"><i>587</i>&nbsp;            String[] s = moduleAndPackage.trim().split(&quot;/&quot;);</b>
<b class="nc"><i>588</i>&nbsp;            if (s.length == 2) {</b>
<i>589</i>&nbsp;                String mn = s[0];
<b class="nc"><i>590</i>&nbsp;                String pn = s[1];</b>
<i>591</i>&nbsp;                ModuleLayer.boot()
<i>592</i>&nbsp;                    .findModule(mn)
<i>593</i>&nbsp;                    .filter(m -&gt; m.getDescriptor().packages().contains(pn))
<b class="nc"><i>594</i>&nbsp;                    .ifPresent(m -&gt; {</b>
<b class="nc"><i>595</i>&nbsp;                        if (open) {</b>
<b class="nc"><i>596</i>&nbsp;                            Modules.addOpensToAllUnnamed(m, pn);</b>
<i>597</i>&nbsp;                        } else {
<b class="nc"><i>598</i>&nbsp;                            Modules.addExportsToAllUnnamed(m, pn);</b>
<i>599</i>&nbsp;                        }
<i>600</i>&nbsp;                    });
<i>601</i>&nbsp;            }
<b class="nc"><i>602</i>&nbsp;        }</b>
<b class="nc"><i>603</i>&nbsp;    }</b>
<b class="nc"><i>604</i>&nbsp;</b>
<i>605</i>&nbsp;    // From src/share/bin/java.c:
<b class="nc"><i>606</i>&nbsp;    //   enum LaunchMode { LM_UNKNOWN = 0, LM_CLASS, LM_JAR, LM_MODULE, LM_SOURCE }</b>
<b class="nc"><i>607</i>&nbsp;</b>
<b class="nc"><i>608</i>&nbsp;    private static final int LM_UNKNOWN = 0;</b>
<i>609</i>&nbsp;    private static final int LM_CLASS   = 1;
<b class="nc"><i>610</i>&nbsp;    private static final int LM_JAR     = 2;</b>
<b class="nc"><i>611</i>&nbsp;    private static final int LM_MODULE  = 3;</b>
<b class="nc"><i>612</i>&nbsp;    private static final int LM_SOURCE  = 4;</b>
<b class="nc"><i>613</i>&nbsp;</b>
<b class="nc"><i>614</i>&nbsp;    static void abort(Throwable t, String msgKey, Object... args) {</b>
<b class="nc"><i>615</i>&nbsp;        if (msgKey != null) {</b>
<i>616</i>&nbsp;            ostream.println(getLocalizedMessage(msgKey, args));
<b class="nc"><i>617</i>&nbsp;        }</b>
<b class="nc"><i>618</i>&nbsp;        if (trace) {</b>
<b class="nc"><i>619</i>&nbsp;            if (t != null) {</b>
<b class="nc"><i>620</i>&nbsp;                t.printStackTrace();</b>
<b class="nc"><i>621</i>&nbsp;            } else {</b>
<b class="nc"><i>622</i>&nbsp;                Thread.dumpStack();</b>
<b class="nc"><i>623</i>&nbsp;            }</b>
<b class="nc"><i>624</i>&nbsp;        }</b>
<b class="nc"><i>625</i>&nbsp;        System.exit(1);</b>
<i>626</i>&nbsp;    }
<b class="nc"><i>627</i>&nbsp;</b>
<b class="nc"><i>628</i>&nbsp;    /**</b>
<b class="nc"><i>629</i>&nbsp;     * This method:</b>
<b class="nc"><i>630</i>&nbsp;     * 1. Loads the main class from the module or class path</b>
<b class="nc"><i>631</i>&nbsp;     * 2. Checks the public static void main method.</b>
<i>632</i>&nbsp;     * 3. If the main class extends FX Application then call on FXHelper to
<b class="nc"><i>633</i>&nbsp;     * perform the launch.</b>
<b class="nc"><i>634</i>&nbsp;     *</b>
<b class="nc"><i>635</i>&nbsp;     * @param printToStderr if set, all output will be routed to stderr</b>
<i>636</i>&nbsp;     * @param mode LaunchMode as determined by the arguments passed on the
<b class="nc"><i>637</i>&nbsp;     *             command line</b>
<b class="nc"><i>638</i>&nbsp;     * @param what the module name[/class], JAR file, or the main class</b>
<b class="nc"><i>639</i>&nbsp;     *             depending on the mode</b>
<i>640</i>&nbsp;     *
<b class="nc"><i>641</i>&nbsp;     * @return the application&#39;s main class</b>
<b class="nc"><i>642</i>&nbsp;     */</b>
<b class="nc"><i>643</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)</b>
<b class="nc"><i>644</i>&nbsp;    public static Class&lt;?&gt; checkAndLoadMain(boolean printToStderr,</b>
<i>645</i>&nbsp;                                            int mode,
<i>646</i>&nbsp;                                            String what) {
<b class="nc"><i>647</i>&nbsp;        initOutput(printToStderr);</b>
<i>648</i>&nbsp;
<i>649</i>&nbsp;        Class&lt;?&gt; mainClass = null;
<i>650</i>&nbsp;        switch (mode) {
<i>651</i>&nbsp;            case LM_MODULE: case LM_SOURCE:
<i>652</i>&nbsp;                mainClass = loadModuleMainClass(what);
<i>653</i>&nbsp;                break;
<b class="nc"><i>654</i>&nbsp;            default:</b>
<b class="nc"><i>655</i>&nbsp;                mainClass = loadMainClass(mode, what);</b>
<b class="nc"><i>656</i>&nbsp;                break;</b>
<i>657</i>&nbsp;        }
<i>658</i>&nbsp;
<i>659</i>&nbsp;        // record the real main class for UI purposes
<i>660</i>&nbsp;        // neither method above can return null, they will abort()
<b class="nc"><i>661</i>&nbsp;        appClass = mainClass;</b>
<b class="nc"><i>662</i>&nbsp;</b>
<b class="nc"><i>663</i>&nbsp;        /*</b>
<i>664</i>&nbsp;         * Check if FXHelper can launch it using the FX launcher. In an FX app,
<i>665</i>&nbsp;         * the main class may or may not have a main method, so do this before
<b class="nc"><i>666</i>&nbsp;         * validating the main class.</b>
<i>667</i>&nbsp;         */
<i>668</i>&nbsp;        if (JAVAFX_FXHELPER_CLASS_NAME_SUFFIX.equals(mainClass.getName()) ||
<i>669</i>&nbsp;            doesExtendFXApplication(mainClass)) {
<b class="nc"><i>670</i>&nbsp;            // Will abort() if there are problems with FX runtime</b>
<i>671</i>&nbsp;            FXHelper.setFXLaunchParameters(what, mode);
<i>672</i>&nbsp;            mainClass = FXHelper.class;
<i>673</i>&nbsp;        }
<i>674</i>&nbsp;
<i>675</i>&nbsp;        validateMainClass(mainClass);
<i>676</i>&nbsp;        return mainClass;
<i>677</i>&nbsp;    }
<i>678</i>&nbsp;
<i>679</i>&nbsp;    /**
<i>680</i>&nbsp;     * Returns the main class for a module. The query is either a module name
<i>681</i>&nbsp;     * or module-name/main-class. For the former then the module&#39;s main class
<i>682</i>&nbsp;     * is obtained from the module descriptor (MainClass attribute).
<i>683</i>&nbsp;     */
<i>684</i>&nbsp;    private static Class&lt;?&gt; loadModuleMainClass(String what) {
<i>685</i>&nbsp;        int i = what.indexOf(&#39;/&#39;);
<i>686</i>&nbsp;        String mainModule;
<i>687</i>&nbsp;        String mainClass;
<i>688</i>&nbsp;        if (i == -1) {
<i>689</i>&nbsp;            mainModule = what;
<i>690</i>&nbsp;            mainClass = null;
<i>691</i>&nbsp;        } else {
<i>692</i>&nbsp;            mainModule = what.substring(0, i);
<i>693</i>&nbsp;            mainClass = what.substring(i+1);
<i>694</i>&nbsp;        }
<i>695</i>&nbsp;
<b class="nc"><i>696</i>&nbsp;        // main module is in the boot layer</b>
<b class="nc"><i>697</i>&nbsp;        ModuleLayer layer = ModuleLayer.boot();</b>
<i>698</i>&nbsp;        Optional&lt;Module&gt; om = layer.findModule(mainModule);
<b class="nc"><i>699</i>&nbsp;        if (!om.isPresent()) {</b>
<b class="nc"><i>700</i>&nbsp;            // should not happen</b>
<i>701</i>&nbsp;            throw new InternalError(&quot;Module &quot; + mainModule + &quot; not in boot Layer&quot;);
<i>702</i>&nbsp;        }
<i>703</i>&nbsp;        Module m = om.get();
<i>704</i>&nbsp;
<i>705</i>&nbsp;        // get main class
<i>706</i>&nbsp;        if (mainClass == null) {
<i>707</i>&nbsp;            Optional&lt;String&gt; omc = m.getDescriptor().mainClass();
<i>708</i>&nbsp;            if (!omc.isPresent()) {
<i>709</i>&nbsp;                abort(null, &quot;java.launcher.module.error1&quot;, mainModule);
<b class="nc"><i>710</i>&nbsp;            }</b>
<i>711</i>&nbsp;            mainClass = omc.get();
<i>712</i>&nbsp;        }
<i>713</i>&nbsp;
<i>714</i>&nbsp;        // load the class from the module
<i>715</i>&nbsp;        Class&lt;?&gt; c = null;
<b class="nc"><i>716</i>&nbsp;        try {</b>
<i>717</i>&nbsp;            c = Class.forName(m, mainClass);
<i>718</i>&nbsp;            if (c == null &amp;&amp; System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
<i>719</i>&nbsp;                    &amp;&amp; Normalizer.isNormalized(mainClass, Normalizer.Form.NFD)) {
<b class="nc"><i>720</i>&nbsp;</b>
<b class="nc"><i>721</i>&nbsp;                String cn = Normalizer.normalize(mainClass, Normalizer.Form.NFC);</b>
<b class="nc"><i>722</i>&nbsp;                c = Class.forName(m, cn);</b>
<i>723</i>&nbsp;            }
<b class="nc"><i>724</i>&nbsp;        } catch (LinkageError le) {</b>
<b class="nc"><i>725</i>&nbsp;            abort(null, &quot;java.launcher.module.error3&quot;, mainClass, m.getName(),</b>
<i>726</i>&nbsp;                    le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
<b class="nc"><i>727</i>&nbsp;        }</b>
<b class="nc"><i>728</i>&nbsp;        if (c == null) {</b>
<b class="nc"><i>729</i>&nbsp;            abort(null, &quot;java.launcher.module.error2&quot;, mainClass, mainModule);</b>
<i>730</i>&nbsp;        }
<b class="nc"><i>731</i>&nbsp;</b>
<b class="nc"><i>732</i>&nbsp;        System.setProperty(&quot;jdk.module.main.class&quot;, c.getName());</b>
<i>733</i>&nbsp;        return c;
<b class="nc"><i>734</i>&nbsp;    }</b>
<b class="nc"><i>735</i>&nbsp;</b>
<i>736</i>&nbsp;    /**
<b class="nc"><i>737</i>&nbsp;     * Loads the main class from the class path (LM_CLASS or LM_JAR).</b>
<b class="nc"><i>738</i>&nbsp;     */</b>
<i>739</i>&nbsp;    private static Class&lt;?&gt; loadMainClass(int mode, String what) {
<i>740</i>&nbsp;        // get the class name
<b class="nc"><i>741</i>&nbsp;        String cn;</b>
<i>742</i>&nbsp;        switch (mode) {
<i>743</i>&nbsp;            case LM_CLASS:
<i>744</i>&nbsp;                cn = what;
<i>745</i>&nbsp;                break;
<i>746</i>&nbsp;            case LM_JAR:
<i>747</i>&nbsp;                cn = getMainClassFromJar(what);
<i>748</i>&nbsp;                break;
<i>749</i>&nbsp;            default:
<i>750</i>&nbsp;                // should never happen
<b class="nc"><i>751</i>&nbsp;                throw new InternalError(&quot;&quot; + mode + &quot;: Unknown launch mode&quot;);</b>
<b class="nc"><i>752</i>&nbsp;        }</b>
<b class="nc"><i>753</i>&nbsp;</b>
<b class="nc"><i>754</i>&nbsp;        // load the main class</b>
<i>755</i>&nbsp;        cn = cn.replace(&#39;/&#39;, &#39;.&#39;);
<i>756</i>&nbsp;        Class&lt;?&gt; mainClass = null;
<b class="nc"><i>757</i>&nbsp;        ClassLoader scl = ClassLoader.getSystemClassLoader();</b>
<i>758</i>&nbsp;        try {
<i>759</i>&nbsp;            try {
<i>760</i>&nbsp;                mainClass = Class.forName(cn, false, scl);
<b class="nc"><i>761</i>&nbsp;            } catch (NoClassDefFoundError | ClassNotFoundException cnfe) {</b>
<i>762</i>&nbsp;                if (System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;)
<i>763</i>&nbsp;                        &amp;&amp; Normalizer.isNormalized(cn, Normalizer.Form.NFD)) {
<b class="nc"><i>764</i>&nbsp;                    try {</b>
<i>765</i>&nbsp;                        // On Mac OS X since all names with diacritical marks are
<i>766</i>&nbsp;                        // given as decomposed it is possible that main class name
<b class="nc"><i>767</i>&nbsp;                        // comes incorrectly from the command line and we have</b>
<i>768</i>&nbsp;                        // to re-compose it
<i>769</i>&nbsp;                        String ncn = Normalizer.normalize(cn, Normalizer.Form.NFC);
<i>770</i>&nbsp;                        mainClass = Class.forName(ncn, false, scl);
<i>771</i>&nbsp;                    } catch (NoClassDefFoundError | ClassNotFoundException cnfe1) {
<i>772</i>&nbsp;                        abort(cnfe1, &quot;java.launcher.cls.error1&quot;, cn,
<i>773</i>&nbsp;                                cnfe1.getClass().getCanonicalName(), cnfe1.getMessage());
<i>774</i>&nbsp;                    }
<i>775</i>&nbsp;                } else {
<i>776</i>&nbsp;                    abort(cnfe, &quot;java.launcher.cls.error1&quot;, cn,
<i>777</i>&nbsp;                            cnfe.getClass().getCanonicalName(), cnfe.getMessage());
<i>778</i>&nbsp;                }
<i>779</i>&nbsp;            }
<i>780</i>&nbsp;        } catch (LinkageError le) {
<i>781</i>&nbsp;            abort(le, &quot;java.launcher.cls.error6&quot;, cn,
<i>782</i>&nbsp;                    le.getClass().getName() + &quot;: &quot; + le.getLocalizedMessage());
<i>783</i>&nbsp;        }
<i>784</i>&nbsp;        return mainClass;
<i>785</i>&nbsp;    }
<i>786</i>&nbsp;
<i>787</i>&nbsp;    /*
<i>788</i>&nbsp;     * Accessor method called by the launcher after getting the main class via
<i>789</i>&nbsp;     * checkAndLoadMain(). The &quot;application class&quot; is the class that is finally
<i>790</i>&nbsp;     * executed to start the application and in this case is used to report
<i>791</i>&nbsp;     * the correct application name, typically for UI purposes.
<i>792</i>&nbsp;     */
<i>793</i>&nbsp;    public static Class&lt;?&gt; getApplicationClass() {
<i>794</i>&nbsp;        return appClass;
<i>795</i>&nbsp;    }
<i>796</i>&nbsp;
<i>797</i>&nbsp;    /*
<i>798</i>&nbsp;     * Check if the given class is a JavaFX Application class. This is done
<i>799</i>&nbsp;     * in a way that does not cause the Application class to load or throw
<i>800</i>&nbsp;     * ClassNotFoundException if the JavaFX runtime is not available.
<i>801</i>&nbsp;     */
<i>802</i>&nbsp;    private static boolean doesExtendFXApplication(Class&lt;?&gt; mainClass) {
<i>803</i>&nbsp;        for (Class&lt;?&gt; sc = mainClass.getSuperclass(); sc != null;
<i>804</i>&nbsp;                sc = sc.getSuperclass()) {
<i>805</i>&nbsp;            if (sc.getName().equals(JAVAFX_APPLICATION_CLASS_NAME)) {
<i>806</i>&nbsp;                return true;
<i>807</i>&nbsp;            }
<i>808</i>&nbsp;        }
<i>809</i>&nbsp;        return false;
<i>810</i>&nbsp;    }
<i>811</i>&nbsp;
<i>812</i>&nbsp;    // Check the existence and signature of main and abort if incorrect
<i>813</i>&nbsp;    static void validateMainClass(Class&lt;?&gt; mainClass) {
<i>814</i>&nbsp;        Method mainMethod = null;
<i>815</i>&nbsp;        try {
<i>816</i>&nbsp;            mainMethod = mainClass.getMethod(&quot;main&quot;, String[].class);
<i>817</i>&nbsp;        } catch (NoSuchMethodException nsme) {
<i>818</i>&nbsp;            // invalid main or not FX application, abort with an error
<i>819</i>&nbsp;            abort(null, &quot;java.launcher.cls.error4&quot;, mainClass.getName(),
<i>820</i>&nbsp;                  JAVAFX_APPLICATION_CLASS_NAME);
<i>821</i>&nbsp;        } catch (Throwable e) {
<i>822</i>&nbsp;            if (mainClass.getModule().isNamed()) {
<i>823</i>&nbsp;                abort(e, &quot;java.launcher.module.error5&quot;,
<i>824</i>&nbsp;                      mainClass.getName(), mainClass.getModule(),
<i>825</i>&nbsp;                      e.getClass().getName(), e.getLocalizedMessage());
<i>826</i>&nbsp;            } else {
<i>827</i>&nbsp;                abort(e, &quot;java.launcher.cls.error7&quot;, mainClass.getName(),
<i>828</i>&nbsp;                      e.getClass().getName(), e.getLocalizedMessage());
<i>829</i>&nbsp;            }
<i>830</i>&nbsp;        }
<i>831</i>&nbsp;
<i>832</i>&nbsp;        /*
<i>833</i>&nbsp;         * getMethod (above) will choose the correct method, based
<i>834</i>&nbsp;         * on its name and parameter type, however, we still have to
<i>835</i>&nbsp;         * ensure that the method is static and returns a void.
<i>836</i>&nbsp;         */
<i>837</i>&nbsp;        int mod = mainMethod.getModifiers();
<i>838</i>&nbsp;        if (!Modifier.isStatic(mod)) {
<i>839</i>&nbsp;            abort(null, &quot;java.launcher.cls.error2&quot;, &quot;static&quot;,
<i>840</i>&nbsp;                  mainMethod.getDeclaringClass().getName());
<i>841</i>&nbsp;        }
<i>842</i>&nbsp;        if (mainMethod.getReturnType() != java.lang.Void.TYPE) {
<i>843</i>&nbsp;            abort(null, &quot;java.launcher.cls.error3&quot;,
<i>844</i>&nbsp;                  mainMethod.getDeclaringClass().getName());
<i>845</i>&nbsp;        }
<i>846</i>&nbsp;    }
<i>847</i>&nbsp;
<i>848</i>&nbsp;    private static final String encprop = &quot;sun.jnu.encoding&quot;;
<i>849</i>&nbsp;    private static String encoding = null;
<i>850</i>&nbsp;    private static boolean isCharsetSupported = false;
<i>851</i>&nbsp;
<i>852</i>&nbsp;    /*
<i>853</i>&nbsp;     * converts a c or a byte array to a platform specific string,
<i>854</i>&nbsp;     * previously implemented as a native method in the launcher.
<i>855</i>&nbsp;     */
<i>856</i>&nbsp;    static String makePlatformString(boolean printToStderr, byte[] inArray) {
<i>857</i>&nbsp;        initOutput(printToStderr);
<i>858</i>&nbsp;        if (encoding == null) {
<i>859</i>&nbsp;            encoding = System.getProperty(encprop);
<i>860</i>&nbsp;            isCharsetSupported = Charset.isSupported(encoding);
<i>861</i>&nbsp;        }
<i>862</i>&nbsp;        try {
<i>863</i>&nbsp;            String out = isCharsetSupported
<i>864</i>&nbsp;                    ? new String(inArray, encoding)
<i>865</i>&nbsp;                    : new String(inArray);
<i>866</i>&nbsp;            return out;
<i>867</i>&nbsp;        } catch (UnsupportedEncodingException uee) {
<i>868</i>&nbsp;            abort(uee, null);
<i>869</i>&nbsp;        }
<i>870</i>&nbsp;        return null; // keep the compiler happy
<i>871</i>&nbsp;    }
<i>872</i>&nbsp;
<i>873</i>&nbsp;    static String[] expandArgs(String[] argArray) {
<i>874</i>&nbsp;        List&lt;StdArg&gt; aList = new ArrayList&lt;&gt;();
<i>875</i>&nbsp;        for (String x : argArray) {
<i>876</i>&nbsp;            aList.add(new StdArg(x));
<i>877</i>&nbsp;        }
<i>878</i>&nbsp;        return expandArgs(aList);
<i>879</i>&nbsp;    }
<i>880</i>&nbsp;
<i>881</i>&nbsp;    static String[] expandArgs(List&lt;StdArg&gt; argList) {
<i>882</i>&nbsp;        ArrayList&lt;String&gt; out = new ArrayList&lt;&gt;();
<i>883</i>&nbsp;        if (trace) {
<i>884</i>&nbsp;            System.err.println(&quot;Incoming arguments:&quot;);
<i>885</i>&nbsp;        }
<i>886</i>&nbsp;        for (StdArg a : argList) {
<i>887</i>&nbsp;            if (trace) {
<i>888</i>&nbsp;                System.err.println(a);
<i>889</i>&nbsp;            }
<i>890</i>&nbsp;            if (a.needsExpansion) {
<i>891</i>&nbsp;                File x = new File(a.arg);
<i>892</i>&nbsp;                File parent = x.getParentFile();
<i>893</i>&nbsp;                String glob = x.getName();
<i>894</i>&nbsp;                if (parent == null) {
<i>895</i>&nbsp;                    parent = new File(&quot;.&quot;);
<i>896</i>&nbsp;                }
<i>897</i>&nbsp;                try (DirectoryStream&lt;Path&gt; dstream =
<i>898</i>&nbsp;                        Files.newDirectoryStream(parent.toPath(), glob)) {
<i>899</i>&nbsp;                    int entries = 0;
<i>900</i>&nbsp;                    for (Path p : dstream) {
<i>901</i>&nbsp;                        out.add(p.normalize().toString());
<i>902</i>&nbsp;                        entries++;
<i>903</i>&nbsp;                    }
<i>904</i>&nbsp;                    if (entries == 0) {
<i>905</i>&nbsp;                        out.add(a.arg);
<i>906</i>&nbsp;                    }
<i>907</i>&nbsp;                } catch (Exception e) {
<i>908</i>&nbsp;                    out.add(a.arg);
<i>909</i>&nbsp;                    if (trace) {
<i>910</i>&nbsp;                        System.err.println(&quot;Warning: passing argument as-is &quot; + a);
<i>911</i>&nbsp;                        System.err.print(e);
<i>912</i>&nbsp;                    }
<i>913</i>&nbsp;                }
<i>914</i>&nbsp;            } else {
<i>915</i>&nbsp;                out.add(a.arg);
<i>916</i>&nbsp;            }
<i>917</i>&nbsp;        }
<i>918</i>&nbsp;        String[] oarray = new String[out.size()];
<i>919</i>&nbsp;        out.toArray(oarray);
<i>920</i>&nbsp;
<i>921</i>&nbsp;        if (trace) {
<i>922</i>&nbsp;            System.err.println(&quot;Expanded arguments:&quot;);
<i>923</i>&nbsp;            for (String x : oarray) {
<i>924</i>&nbsp;                System.err.println(x);
<i>925</i>&nbsp;            }
<i>926</i>&nbsp;        }
<i>927</i>&nbsp;        return oarray;
<i>928</i>&nbsp;    }
<i>929</i>&nbsp;
<i>930</i>&nbsp;    /* duplicate of the native StdArg struct */
<i>931</i>&nbsp;    private static class StdArg {
<i>932</i>&nbsp;        final String arg;
<i>933</i>&nbsp;        final boolean needsExpansion;
<i>934</i>&nbsp;        StdArg(String arg, boolean expand) {
<i>935</i>&nbsp;            this.arg = arg;
<i>936</i>&nbsp;            this.needsExpansion = expand;
<i>937</i>&nbsp;        }
<i>938</i>&nbsp;        // protocol: first char indicates whether expansion is required
<i>939</i>&nbsp;        // &#39;T&#39; = true ; needs expansion
<i>940</i>&nbsp;        // &#39;F&#39; = false; needs no expansion
<i>941</i>&nbsp;        StdArg(String in) {
<i>942</i>&nbsp;            this.arg = in.substring(1);
<i>943</i>&nbsp;            needsExpansion = in.charAt(0) == &#39;T&#39;;
<i>944</i>&nbsp;        }
<i>945</i>&nbsp;        public String toString() {
<i>946</i>&nbsp;            return &quot;StdArg{&quot; + &quot;arg=&quot; + arg + &quot;, needsExpansion=&quot; + needsExpansion + &#39;}&#39;;
<i>947</i>&nbsp;        }
<i>948</i>&nbsp;    }
<i>949</i>&nbsp;
<i>950</i>&nbsp;    static final class FXHelper {
<i>951</i>&nbsp;
<i>952</i>&nbsp;        private static final String JAVAFX_GRAPHICS_MODULE_NAME =
<i>953</i>&nbsp;                &quot;javafx.graphics&quot;;
<i>954</i>&nbsp;
<i>955</i>&nbsp;        private static final String JAVAFX_LAUNCHER_CLASS_NAME =
<i>956</i>&nbsp;                &quot;com.sun.javafx.application.LauncherImpl&quot;;
<i>957</i>&nbsp;
<i>958</i>&nbsp;        /*
<i>959</i>&nbsp;         * The launch method used to invoke the JavaFX launcher. These must
<i>960</i>&nbsp;         * match the strings used in the launchApplication method.
<i>961</i>&nbsp;         *
<i>962</i>&nbsp;         * Command line                 JavaFX-App-Class  Launch mode  FX Launch mode
<i>963</i>&nbsp;         * java -cp fxapp.jar FXClass   N/A               LM_CLASS     &quot;LM_CLASS&quot;
<i>964</i>&nbsp;         * java -cp somedir FXClass     N/A               LM_CLASS     &quot;LM_CLASS&quot;
<i>965</i>&nbsp;         * java -jar fxapp.jar          Present           LM_JAR       &quot;LM_JAR&quot;
<i>966</i>&nbsp;         * java -jar fxapp.jar          Not Present       LM_JAR       &quot;LM_JAR&quot;
<i>967</i>&nbsp;         * java -m module/class [1]     N/A               LM_MODULE    &quot;LM_MODULE&quot;
<i>968</i>&nbsp;         * java -m module               N/A               LM_MODULE    &quot;LM_MODULE&quot;
<i>969</i>&nbsp;         *
<i>970</i>&nbsp;         * [1] - JavaFX-Application-Class is ignored when modular args are used, even
<i>971</i>&nbsp;         * if present in a modular jar
<i>972</i>&nbsp;         */
<i>973</i>&nbsp;        private static final String JAVAFX_LAUNCH_MODE_CLASS = &quot;LM_CLASS&quot;;
<i>974</i>&nbsp;        private static final String JAVAFX_LAUNCH_MODE_JAR = &quot;LM_JAR&quot;;
<i>975</i>&nbsp;        private static final String JAVAFX_LAUNCH_MODE_MODULE = &quot;LM_MODULE&quot;;
<i>976</i>&nbsp;
<i>977</i>&nbsp;        /*
<i>978</i>&nbsp;         * FX application launcher and launch method, so we can launch
<i>979</i>&nbsp;         * applications with no main method.
<i>980</i>&nbsp;         */
<i>981</i>&nbsp;        private static String fxLaunchName = null;
<i>982</i>&nbsp;        private static String fxLaunchMode = null;
<i>983</i>&nbsp;
<i>984</i>&nbsp;        private static Class&lt;?&gt; fxLauncherClass    = null;
<i>985</i>&nbsp;        private static Method   fxLauncherMethod   = null;
<i>986</i>&nbsp;
<i>987</i>&nbsp;        /*
<i>988</i>&nbsp;         * Set the launch params according to what was passed to LauncherHelper
<i>989</i>&nbsp;         * so we can use the same launch mode for FX. Abort if there is any
<i>990</i>&nbsp;         * issue with loading the FX runtime or with the launcher method.
<i>991</i>&nbsp;         */
<i>992</i>&nbsp;        private static void setFXLaunchParameters(String what, int mode) {
<i>993</i>&nbsp;
<i>994</i>&nbsp;            // find the module with the FX launcher
<i>995</i>&nbsp;            Optional&lt;Module&gt; om = ModuleLayer.boot().findModule(JAVAFX_GRAPHICS_MODULE_NAME);
<i>996</i>&nbsp;            if (!om.isPresent()) {
<i>997</i>&nbsp;                abort(null, &quot;java.launcher.cls.error5&quot;);
<i>998</i>&nbsp;            }
<i>999</i>&nbsp;
<i>1000</i>&nbsp;            // load the FX launcher class
<i>1001</i>&nbsp;            fxLauncherClass = Class.forName(om.get(), JAVAFX_LAUNCHER_CLASS_NAME);
<i>1002</i>&nbsp;            if (fxLauncherClass == null) {
<i>1003</i>&nbsp;                abort(null, &quot;java.launcher.cls.error5&quot;);
<i>1004</i>&nbsp;            }
<i>1005</i>&nbsp;
<i>1006</i>&nbsp;            try {
<i>1007</i>&nbsp;                /*
<i>1008</i>&nbsp;                 * signature must be:
<i>1009</i>&nbsp;                 * public static void launchApplication(String launchName,
<i>1010</i>&nbsp;                 *     String launchMode, String[] args);
<i>1011</i>&nbsp;                 */
<i>1012</i>&nbsp;                fxLauncherMethod = fxLauncherClass.getMethod(&quot;launchApplication&quot;,
<i>1013</i>&nbsp;                        String.class, String.class, String[].class);
<i>1014</i>&nbsp;
<i>1015</i>&nbsp;                // verify launcher signature as we do when validating the main method
<i>1016</i>&nbsp;                int mod = fxLauncherMethod.getModifiers();
<i>1017</i>&nbsp;                if (!Modifier.isStatic(mod)) {
<i>1018</i>&nbsp;                    abort(null, &quot;java.launcher.javafx.error1&quot;);
<i>1019</i>&nbsp;                }
<i>1020</i>&nbsp;                if (fxLauncherMethod.getReturnType() != java.lang.Void.TYPE) {
<i>1021</i>&nbsp;                    abort(null, &quot;java.launcher.javafx.error1&quot;);
<i>1022</i>&nbsp;                }
<i>1023</i>&nbsp;            } catch (NoSuchMethodException ex) {
<i>1024</i>&nbsp;                abort(ex, &quot;java.launcher.cls.error5&quot;, ex);
<i>1025</i>&nbsp;            }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;            fxLaunchName = what;
<i>1028</i>&nbsp;            switch (mode) {
<i>1029</i>&nbsp;                case LM_CLASS:
<i>1030</i>&nbsp;                    fxLaunchMode = JAVAFX_LAUNCH_MODE_CLASS;
<i>1031</i>&nbsp;                    break;
<i>1032</i>&nbsp;                case LM_JAR:
<i>1033</i>&nbsp;                    fxLaunchMode = JAVAFX_LAUNCH_MODE_JAR;
<i>1034</i>&nbsp;                    break;
<i>1035</i>&nbsp;                case LM_MODULE:
<i>1036</i>&nbsp;                    fxLaunchMode = JAVAFX_LAUNCH_MODE_MODULE;
<i>1037</i>&nbsp;                    break;
<i>1038</i>&nbsp;                default:
<i>1039</i>&nbsp;                    // should not have gotten this far...
<i>1040</i>&nbsp;                    throw new InternalError(mode + &quot;: Unknown launch mode&quot;);
<i>1041</i>&nbsp;            }
<i>1042</i>&nbsp;        }
<i>1043</i>&nbsp;
<i>1044</i>&nbsp;        public static void main(String... args) throws Exception {
<i>1045</i>&nbsp;            if (fxLauncherMethod == null
<i>1046</i>&nbsp;                    || fxLaunchMode == null
<i>1047</i>&nbsp;                    || fxLaunchName == null) {
<i>1048</i>&nbsp;                throw new RuntimeException(&quot;Invalid JavaFX launch parameters&quot;);
<i>1049</i>&nbsp;            }
<i>1050</i>&nbsp;            // launch appClass via fxLauncherMethod
<i>1051</i>&nbsp;            fxLauncherMethod.invoke(null,
<i>1052</i>&nbsp;                    new Object[] {fxLaunchName, fxLaunchMode, args});
<i>1053</i>&nbsp;        }
<i>1054</i>&nbsp;    }
<i>1055</i>&nbsp;
<i>1056</i>&nbsp;    /**
<i>1057</i>&nbsp;     * Called by the launcher to list the observable modules.
<i>1058</i>&nbsp;     */
<i>1059</i>&nbsp;    static void listModules() {
<i>1060</i>&nbsp;        initOutput(System.out);
<i>1061</i>&nbsp;
<i>1062</i>&nbsp;        ModuleBootstrap.limitedFinder().findAll().stream()
<i>1063</i>&nbsp;            .sorted(new JrtFirstComparator())
<i>1064</i>&nbsp;            .forEach(LauncherHelper::showModule);
<i>1065</i>&nbsp;    }
<i>1066</i>&nbsp;
<i>1067</i>&nbsp;    /**
<i>1068</i>&nbsp;     * Called by the launcher to show the resolved modules
<i>1069</i>&nbsp;     */
<i>1070</i>&nbsp;    static void showResolvedModules() {
<i>1071</i>&nbsp;        initOutput(System.out);
<i>1072</i>&nbsp;
<i>1073</i>&nbsp;        ModuleLayer bootLayer = ModuleLayer.boot();
<i>1074</i>&nbsp;        Configuration cf = bootLayer.configuration();
<i>1075</i>&nbsp;
<i>1076</i>&nbsp;        cf.modules().stream()
<i>1077</i>&nbsp;            .map(ResolvedModule::reference)
<i>1078</i>&nbsp;            .sorted(new JrtFirstComparator())
<i>1079</i>&nbsp;            .forEach(LauncherHelper::showModule);
<i>1080</i>&nbsp;    }
<i>1081</i>&nbsp;
<i>1082</i>&nbsp;    /**
<i>1083</i>&nbsp;     * Called by the launcher to describe a module
<i>1084</i>&nbsp;     */
<i>1085</i>&nbsp;    static void describeModule(String moduleName) {
<i>1086</i>&nbsp;        initOutput(System.out);
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;        ModuleFinder finder = ModuleBootstrap.limitedFinder();
<i>1089</i>&nbsp;        ModuleReference mref = finder.find(moduleName).orElse(null);
<i>1090</i>&nbsp;        if (mref == null) {
<i>1091</i>&nbsp;            abort(null, &quot;java.launcher.module.error4&quot;, moduleName);
<i>1092</i>&nbsp;        }
<i>1093</i>&nbsp;        ModuleDescriptor md = mref.descriptor();
<i>1094</i>&nbsp;
<i>1095</i>&nbsp;        // one-line summary
<i>1096</i>&nbsp;        showModule(mref);
<i>1097</i>&nbsp;
<i>1098</i>&nbsp;        // unqualified exports (sorted by package)
<i>1099</i>&nbsp;        md.exports().stream()
<i>1100</i>&nbsp;            .filter(e -&gt; !e.isQualified())
<i>1101</i>&nbsp;            .sorted(Comparator.comparing(Exports::source))
<i>1102</i>&nbsp;            .map(e -&gt; Stream.concat(Stream.of(e.source()),
<i>1103</i>&nbsp;                                    toStringStream(e.modifiers()))
<i>1104</i>&nbsp;                    .collect(Collectors.joining(&quot; &quot;)))
<i>1105</i>&nbsp;            .forEach(sourceAndMods -&gt; ostream.format(&quot;exports %s%n&quot;, sourceAndMods));
<i>1106</i>&nbsp;
<i>1107</i>&nbsp;        // dependences
<i>1108</i>&nbsp;        for (Requires r : md.requires()) {
<i>1109</i>&nbsp;            String nameAndMods = Stream.concat(Stream.of(r.name()),
<i>1110</i>&nbsp;                                               toStringStream(r.modifiers()))
<i>1111</i>&nbsp;                    .collect(Collectors.joining(&quot; &quot;));
<i>1112</i>&nbsp;            ostream.format(&quot;requires %s&quot;, nameAndMods);
<i>1113</i>&nbsp;            finder.find(r.name())
<i>1114</i>&nbsp;                .map(ModuleReference::descriptor)
<i>1115</i>&nbsp;                .filter(ModuleDescriptor::isAutomatic)
<i>1116</i>&nbsp;                .ifPresent(any -&gt; ostream.print(&quot; automatic&quot;));
<i>1117</i>&nbsp;            ostream.println();
<i>1118</i>&nbsp;        }
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;        // service use and provides
<i>1121</i>&nbsp;        for (String s : md.uses()) {
<i>1122</i>&nbsp;            ostream.format(&quot;uses %s%n&quot;, s);
<i>1123</i>&nbsp;        }
<i>1124</i>&nbsp;        for (Provides ps : md.provides()) {
<i>1125</i>&nbsp;            String names = ps.providers().stream().collect(Collectors.joining(&quot; &quot;));
<i>1126</i>&nbsp;            ostream.format(&quot;provides %s with %s%n&quot;, ps.service(), names);
<i>1127</i>&nbsp;
<i>1128</i>&nbsp;        }
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;        // qualified exports
<i>1131</i>&nbsp;        for (Exports e : md.exports()) {
<i>1132</i>&nbsp;            if (e.isQualified()) {
<i>1133</i>&nbsp;                String who = e.targets().stream().collect(Collectors.joining(&quot; &quot;));
<i>1134</i>&nbsp;                ostream.format(&quot;qualified exports %s to %s%n&quot;, e.source(), who);
<i>1135</i>&nbsp;            }
<i>1136</i>&nbsp;        }
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;        // open packages
<i>1139</i>&nbsp;        for (Opens opens: md.opens()) {
<i>1140</i>&nbsp;            if (opens.isQualified())
<i>1141</i>&nbsp;                ostream.print(&quot;qualified &quot;);
<i>1142</i>&nbsp;            String sourceAndMods = Stream.concat(Stream.of(opens.source()),
<i>1143</i>&nbsp;                                                 toStringStream(opens.modifiers()))
<i>1144</i>&nbsp;                    .collect(Collectors.joining(&quot; &quot;));
<i>1145</i>&nbsp;            ostream.format(&quot;opens %s&quot;, sourceAndMods);
<i>1146</i>&nbsp;            if (opens.isQualified()) {
<i>1147</i>&nbsp;                String who = opens.targets().stream().collect(Collectors.joining(&quot; &quot;));
<i>1148</i>&nbsp;                ostream.format(&quot; to %s&quot;, who);
<i>1149</i>&nbsp;            }
<i>1150</i>&nbsp;            ostream.println();
<i>1151</i>&nbsp;        }
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;        // non-exported/non-open packages
<i>1154</i>&nbsp;        Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
<i>1155</i>&nbsp;        md.exports().stream().map(Exports::source).forEach(concealed::remove);
<i>1156</i>&nbsp;        md.opens().stream().map(Opens::source).forEach(concealed::remove);
<i>1157</i>&nbsp;        concealed.forEach(p -&gt; ostream.format(&quot;contains %s%n&quot;, p));
<i>1158</i>&nbsp;    }
<i>1159</i>&nbsp;
<i>1160</i>&nbsp;    /**
<i>1161</i>&nbsp;     * Prints a single line with the module name, version and modifiers
<i>1162</i>&nbsp;     */
<i>1163</i>&nbsp;    private static void showModule(ModuleReference mref) {
<i>1164</i>&nbsp;        ModuleDescriptor md = mref.descriptor();
<i>1165</i>&nbsp;        ostream.print(md.toNameAndVersion());
<i>1166</i>&nbsp;        mref.location()
<i>1167</i>&nbsp;                .filter(uri -&gt; !isJrt(uri))
<i>1168</i>&nbsp;                .ifPresent(uri -&gt; ostream.format(&quot; %s&quot;, uri));
<i>1169</i>&nbsp;        if (md.isOpen())
<i>1170</i>&nbsp;            ostream.print(&quot; open&quot;);
<i>1171</i>&nbsp;        if (md.isAutomatic())
<i>1172</i>&nbsp;            ostream.print(&quot; automatic&quot;);
<i>1173</i>&nbsp;        ostream.println();
<i>1174</i>&nbsp;    }
<i>1175</i>&nbsp;
<i>1176</i>&nbsp;    /**
<i>1177</i>&nbsp;     * A ModuleReference comparator that considers modules in the run-time
<i>1178</i>&nbsp;     * image to be less than modules than not in the run-time image.
<i>1179</i>&nbsp;     */
<i>1180</i>&nbsp;    private static class JrtFirstComparator implements Comparator&lt;ModuleReference&gt; {
<i>1181</i>&nbsp;        private final Comparator&lt;ModuleReference&gt; real;
<i>1182</i>&nbsp;
<i>1183</i>&nbsp;        JrtFirstComparator() {
<i>1184</i>&nbsp;            this.real = Comparator.comparing(ModuleReference::descriptor);
<i>1185</i>&nbsp;        }
<i>1186</i>&nbsp;
<i>1187</i>&nbsp;        @Override
<i>1188</i>&nbsp;        public int compare(ModuleReference a, ModuleReference b) {
<i>1189</i>&nbsp;            if (isJrt(a)) {
<i>1190</i>&nbsp;                return isJrt(b) ? real.compare(a, b) : -1;
<i>1191</i>&nbsp;            } else {
<i>1192</i>&nbsp;                return isJrt(b) ? 1 : real.compare(a, b);
<i>1193</i>&nbsp;            }
<i>1194</i>&nbsp;        }
<i>1195</i>&nbsp;    }
<i>1196</i>&nbsp;
<i>1197</i>&nbsp;    private static &lt;T&gt; Stream&lt;String&gt; toStringStream(Set&lt;T&gt; s) {
<i>1198</i>&nbsp;        return s.stream().map(e -&gt; e.toString().toLowerCase());
<i>1199</i>&nbsp;    }
<i>1200</i>&nbsp;
<i>1201</i>&nbsp;    private static boolean isJrt(ModuleReference mref) {
<i>1202</i>&nbsp;        return isJrt(mref.location().orElse(null));
<i>1203</i>&nbsp;    }
<i>1204</i>&nbsp;
<i>1205</i>&nbsp;    private static boolean isJrt(URI uri) {
<i>1206</i>&nbsp;        return (uri != null &amp;&amp; uri.getScheme().equalsIgnoreCase(&quot;jrt&quot;));
<i>1207</i>&nbsp;    }
<i>1208</i>&nbsp;
<i>1209</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
