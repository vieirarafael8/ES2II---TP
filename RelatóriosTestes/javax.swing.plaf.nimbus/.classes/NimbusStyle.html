


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: NimbusStyle</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.plaf.nimbus</a> ]
</div>

<h1>Coverage Summary for Class: NimbusStyle (javax.swing.plaf.nimbus)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">NimbusStyle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 313)
  </span>
</td>
</tr>
  <tr>
    <td class="name">NimbusStyle$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NimbusStyle$CacheKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NimbusStyle$RuntimeState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">NimbusStyle$Values</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 345)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.plaf.nimbus;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import javax.swing.Painter;
<i>28</i>&nbsp;
<i>29</i>&nbsp;import javax.swing.JComponent;
<i>30</i>&nbsp;import javax.swing.UIDefaults;
<i>31</i>&nbsp;import javax.swing.UIManager;
<i>32</i>&nbsp;import javax.swing.plaf.ColorUIResource;
<i>33</i>&nbsp;import javax.swing.plaf.synth.ColorType;
<i>34</i>&nbsp;import static javax.swing.plaf.synth.SynthConstants.*;
<i>35</i>&nbsp;import javax.swing.plaf.synth.SynthContext;
<i>36</i>&nbsp;import javax.swing.plaf.synth.SynthPainter;
<i>37</i>&nbsp;import javax.swing.plaf.synth.SynthStyle;
<i>38</i>&nbsp;import java.awt.Color;
<i>39</i>&nbsp;import java.awt.Font;
<i>40</i>&nbsp;import java.awt.Insets;
<i>41</i>&nbsp;import java.lang.ref.WeakReference;
<i>42</i>&nbsp;import java.util.ArrayList;
<i>43</i>&nbsp;import java.util.Collections;
<i>44</i>&nbsp;import java.util.Comparator;
<i>45</i>&nbsp;import java.util.HashMap;
<i>46</i>&nbsp;import java.util.List;
<i>47</i>&nbsp;import java.util.Map;
<i>48</i>&nbsp;import java.util.TreeMap;
<i>49</i>&nbsp;
<i>50</i>&nbsp;/**
<i>51</i>&nbsp; * &lt;p&gt;A SynthStyle implementation used by Nimbus. Each Region that has been
<i>52</i>&nbsp; * registered with the NimbusLookAndFeel will have an associated NimbusStyle.
<i>53</i>&nbsp; * Third party components that are registered with the NimbusLookAndFeel will
<i>54</i>&nbsp; * therefore be handed a NimbusStyle from the look and feel from the
<i>55</i>&nbsp; * #getStyle(JComponent, Region) method.&lt;/p&gt;
<i>56</i>&nbsp; *
<i>57</i>&nbsp; * &lt;p&gt;This class properly reads and retrieves values placed in the UIDefaults
<i>58</i>&nbsp; * according to the standard Nimbus naming conventions. It will create and
<i>59</i>&nbsp; * retrieve painters, fonts, colors, and other data stored there.&lt;/p&gt;
<i>60</i>&nbsp; *
<i>61</i>&nbsp; * &lt;p&gt;NimbusStyle also supports the ability to override settings on a per
<i>62</i>&nbsp; * component basis. NimbusStyle checks the component&#39;s client property map for
<i>63</i>&nbsp; * &quot;Nimbus.Overrides&quot;. If the value associated with this key is an instance of
<i>64</i>&nbsp; * UIDefaults, then the values in that defaults table will override the standard
<i>65</i>&nbsp; * Nimbus defaults in UIManager, but for that component instance only.&lt;/p&gt;
<i>66</i>&nbsp; *
<i>67</i>&nbsp; * &lt;p&gt;Optionally, you may specify the client property
<i>68</i>&nbsp; * &quot;Nimbus.Overrides.InheritDefaults&quot;. If true, this client property indicates
<i>69</i>&nbsp; * that the defaults located in UIManager should first be read, and then
<i>70</i>&nbsp; * replaced with defaults located in the component client properties. If false,
<i>71</i>&nbsp; * then only the defaults located in the component client property map will
<i>72</i>&nbsp; * be used. If not specified, it is assumed to be true.&lt;/p&gt;
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * &lt;p&gt;You must specify &quot;Nimbus.Overrides&quot; for &quot;Nimbus.Overrides.InheritDefaults&quot;
<i>75</i>&nbsp; * to have any effect. &quot;Nimbus.Overrides&quot; indicates whether there are any
<i>76</i>&nbsp; * overrides, while &quot;Nimbus.Overrides.InheritDefaults&quot; indicates whether those
<i>77</i>&nbsp; * overrides should first be initialized with the defaults from UIManager.&lt;/p&gt;
<i>78</i>&nbsp; *
<i>79</i>&nbsp; * &lt;p&gt;The NimbusStyle is reloaded whenever a property change event is fired
<i>80</i>&nbsp; * for a component for &quot;Nimbus.Overrides&quot; or &quot;Nimbus.Overrides.InheritDefaults&quot;.
<i>81</i>&nbsp; * So for example, setting a new UIDefaults on a component would cause the
<i>82</i>&nbsp; * style to be reloaded.&lt;/p&gt;
<i>83</i>&nbsp; *
<i>84</i>&nbsp; * &lt;p&gt;The values are only read out of UIManager once, and then cached. If
<i>85</i>&nbsp; * you need to read the values again (for example, if the UI is being reloaded),
<i>86</i>&nbsp; * then discard this NimbusStyle and read a new one from NimbusLookAndFeel
<i>87</i>&nbsp; * using NimbusLookAndFeel.getStyle.&lt;/p&gt;
<i>88</i>&nbsp; *
<i>89</i>&nbsp; * &lt;p&gt;The primary API of interest in this class for 3rd party component authors
<i>90</i>&nbsp; * are the three methods which retrieve painters: #getBackgroundPainter,
<i>91</i>&nbsp; * #getForegroundPainter, and #getBorderPainter.&lt;/p&gt;
<i>92</i>&nbsp; *
<i>93</i>&nbsp; * &lt;p&gt;NimbusStyle allows you to specify custom states, or modify the order of
<i>94</i>&nbsp; * states. Synth (and thus Nimbus) has the concept of a &quot;state&quot;. For example,
<i>95</i>&nbsp; * a JButton might be in the &quot;MOUSE_OVER&quot; state, or the &quot;ENABLED&quot; state, or the
<i>96</i>&nbsp; * &quot;DISABLED&quot; state. These are all &quot;standard&quot; states which are defined in synth,
<i>97</i>&nbsp; * and which apply to all synth Regions.&lt;/p&gt;
<i>98</i>&nbsp; *
<i>99</i>&nbsp; * &lt;p&gt;Sometimes, however, you need to have a custom state. For example, you
<i>100</i>&nbsp; * want JButton to render differently if it&#39;s parent is a JToolbar. In Nimbus,
<i>101</i>&nbsp; * you specify these custom states by including a special key in UIDefaults.
<i>102</i>&nbsp; * The following UIDefaults entries define three states for this button:&lt;/p&gt;
<i>103</i>&nbsp; *
<i>104</i>&nbsp; * &lt;pre&gt;&lt;code&gt;
<i>105</i>&nbsp; *     JButton.States = Enabled, Disabled, Toolbar
<i>106</i>&nbsp; *     JButton[Enabled].backgroundPainter = somePainter
<i>107</i>&nbsp; *     JButton[Disabled].background = BLUE
<i>108</i>&nbsp; *     JButton[Toolbar].backgroundPainter = someOtherPaint
<i>109</i>&nbsp; * &lt;/code&gt;&lt;/pre&gt;
<i>110</i>&nbsp; *
<i>111</i>&nbsp; * &lt;p&gt;As you can see, the &lt;code&gt;JButton.States&lt;/code&gt; entry lists the states
<i>112</i>&nbsp; * that the JButton style will support. You then specify the settings for
<i>113</i>&nbsp; * each state. If you do not specify the &lt;code&gt;JButton.States&lt;/code&gt; entry,
<i>114</i>&nbsp; * then the standard Synth states will be assumed. If you specify the entry
<i>115</i>&nbsp; * but the list of states is empty or null, then the standard synth states
<i>116</i>&nbsp; * will be assumed.&lt;/p&gt;
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * @author Richard Bair
<i>119</i>&nbsp; * @author Jasper Potts
<i>120</i>&nbsp; */
<b class="nc"><i>121</i>&nbsp;public final class NimbusStyle extends SynthStyle {</b>
<i>122</i>&nbsp;    /* Keys and scales for large/small/mini components, based on Apples sizes */
<i>123</i>&nbsp;    /** Large key */
<i>124</i>&nbsp;    public static final String LARGE_KEY = &quot;large&quot;;
<i>125</i>&nbsp;    /** Small key */
<i>126</i>&nbsp;    public static final String SMALL_KEY = &quot;small&quot;;
<i>127</i>&nbsp;    /** Mini key */
<i>128</i>&nbsp;    public static final String MINI_KEY = &quot;mini&quot;;
<i>129</i>&nbsp;    /** Large scale */
<i>130</i>&nbsp;    public static final double LARGE_SCALE = 1.15;
<i>131</i>&nbsp;    /** Small scale */
<i>132</i>&nbsp;    public static final double SMALL_SCALE = 0.857;
<i>133</i>&nbsp;    /** Mini scale */
<i>134</i>&nbsp;    public static final double MINI_SCALE = 0.714;
<i>135</i>&nbsp;
<i>136</i>&nbsp;    /**
<b class="nc"><i>137</i>&nbsp;     * Special constant used for performance reasons during the get() method.</b>
<i>138</i>&nbsp;     * If get() runs through all of the search locations and determines that
<i>139</i>&nbsp;     * there is no value, then NULL will be placed into the values map. This way
<i>140</i>&nbsp;     * on subsequent lookups it will simply extract NULL, see it, and return
<i>141</i>&nbsp;     * null rather than continuing the lookup procedure.
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    private static final Object NULL = &#39;\0&#39;;
<i>144</i>&nbsp;    /**
<i>145</i>&nbsp;     * &lt;p&gt;The Color to return from getColorForState if it would otherwise have
<i>146</i>&nbsp;     * returned null.&lt;/p&gt;
<i>147</i>&nbsp;     *
<i>148</i>&nbsp;     * &lt;p&gt;Returning null from getColorForState is a very bad thing, as it causes
<i>149</i>&nbsp;     * the AWT peer for the component to install a SystemColor, which is not a
<b class="nc"><i>150</i>&nbsp;     * UIResource. As a result, if &lt;code&gt;null&lt;/code&gt; is returned from</b>
<i>151</i>&nbsp;     * getColorForState, then thereafter the color is not updated for other
<i>152</i>&nbsp;     * states or on LAF changes or updates. This DEFAULT_COLOR is used to
<i>153</i>&nbsp;     * ensure that a ColorUIResource is always returned from
<i>154</i>&nbsp;     * getColorForState.&lt;/p&gt;
<b class="nc"><i>155</i>&nbsp;     */</b>
<b class="nc"><i>156</i>&nbsp;    private static final Color DEFAULT_COLOR = new ColorUIResource(Color.BLACK);</b>
<i>157</i>&nbsp;    /**
<i>158</i>&nbsp;     * Simple Comparator for ordering the RuntimeStates according to their
<b class="nc"><i>159</i>&nbsp;     * rank.</b>
<i>160</i>&nbsp;     */
<i>161</i>&nbsp;    private static final Comparator&lt;RuntimeState&gt; STATE_COMPARATOR =
<i>162</i>&nbsp;        new Comparator&lt;RuntimeState&gt;() {
<i>163</i>&nbsp;            @Override
<i>164</i>&nbsp;            public int compare(RuntimeState a, RuntimeState b) {
<i>165</i>&nbsp;                return a.state - b.state;
<i>166</i>&nbsp;            }
<i>167</i>&nbsp;        };
<i>168</i>&nbsp;    /**
<i>169</i>&nbsp;     * The prefix for the component or region that this NimbusStyle
<i>170</i>&nbsp;     * represents. This prefix is used to lookup state in the UIManager.
<i>171</i>&nbsp;     * It should be something like Button or Slider.Thumb or &quot;MyButton&quot; or
<i>172</i>&nbsp;     * ComboBox.&quot;ComboBox.arrowButton&quot; or &quot;MyComboBox&quot;.&quot;ComboBox.arrowButton&quot;
<i>173</i>&nbsp;     */
<i>174</i>&nbsp;    private String prefix;
<i>175</i>&nbsp;    /**
<i>176</i>&nbsp;     * The SynthPainter that will be returned from this NimbusStyle. The
<i>177</i>&nbsp;     * SynthPainter returned will be a SynthPainterImpl, which will in turn
<i>178</i>&nbsp;     * delegate back to this NimbusStyle for the proper Painter (not
<i>179</i>&nbsp;     * SynthPainter) to use for painting the foreground, background, or border.
<i>180</i>&nbsp;     */
<i>181</i>&nbsp;    private SynthPainter painter;
<i>182</i>&nbsp;    /**
<i>183</i>&nbsp;     * Data structure containing all of the defaults, insets, states, and other
<i>184</i>&nbsp;     * values associated with this style. This instance refers to default
<i>185</i>&nbsp;     * values, and are used when no overrides are discovered in the client
<i>186</i>&nbsp;     * properties of a component. These values are lazily created on first
<i>187</i>&nbsp;     * access.
<i>188</i>&nbsp;     */
<b class="nc"><i>189</i>&nbsp;    private Values values;</b>
<i>190</i>&nbsp;
<i>191</i>&nbsp;    /**
<i>192</i>&nbsp;     * A temporary CacheKey used to perform lookups. This pattern avoids
<i>193</i>&nbsp;     * creating useless garbage keys, or concatenating strings, etc.
<i>194</i>&nbsp;     */
<i>195</i>&nbsp;    private CacheKey tmpKey = new CacheKey(&quot;&quot;, 0);
<i>196</i>&nbsp;
<i>197</i>&nbsp;    /**
<i>198</i>&nbsp;     * Some NimbusStyles are created for a specific component only. In Nimbus,
<i>199</i>&nbsp;     * this happens whenever the component has as a client property a
<i>200</i>&nbsp;     * UIDefaults which overrides (or supplements) those defaults found in
<i>201</i>&nbsp;     * UIManager.
<i>202</i>&nbsp;     */
<i>203</i>&nbsp;    private WeakReference&lt;JComponent&gt; component;
<i>204</i>&nbsp;
<i>205</i>&nbsp;    /**
<i>206</i>&nbsp;     * Create a new NimbusStyle. Only the prefix must be supplied. At the
<i>207</i>&nbsp;     * appropriate time, installDefaults will be called. At that point, all of
<i>208</i>&nbsp;     * the state information will be pulled from UIManager and stored locally
<i>209</i>&nbsp;     * within this style.
<i>210</i>&nbsp;     *
<i>211</i>&nbsp;     * @param prefix Something like Button or Slider.Thumb or
<b class="nc"><i>212</i>&nbsp;     *        org.jdesktop.swingx.JXStatusBar or ComboBox.&quot;ComboBox.arrowButton&quot;</b>
<b class="nc"><i>213</i>&nbsp;     * @param c an optional reference to a component that this NimbusStyle</b>
<b class="nc"><i>214</i>&nbsp;     *        should be associated with. This is only used when the component</b>
<i>215</i>&nbsp;     *        has Nimbus overrides registered in its client properties and
<b class="nc"><i>216</i>&nbsp;     *        should be null otherwise.</b>
<b class="nc"><i>217</i>&nbsp;     */</b>
<i>218</i>&nbsp;    NimbusStyle(String prefix, JComponent c) {
<i>219</i>&nbsp;        if (c != null) {
<i>220</i>&nbsp;            this.component = new WeakReference&lt;JComponent&gt;(c);
<i>221</i>&nbsp;        }
<i>222</i>&nbsp;        this.prefix = prefix;
<i>223</i>&nbsp;        this.painter = new SynthPainterImpl(this);
<i>224</i>&nbsp;    }
<i>225</i>&nbsp;
<i>226</i>&nbsp;    /**
<b class="nc"><i>227</i>&nbsp;     * {@inheritDoc}</b>
<i>228</i>&nbsp;     *
<i>229</i>&nbsp;     * Overridden to cause this style to populate itself with data from
<i>230</i>&nbsp;     * UIDefaults, if necessary.
<b class="nc"><i>231</i>&nbsp;     */</b>
<i>232</i>&nbsp;    @Override public void installDefaults(SynthContext ctx) {
<i>233</i>&nbsp;        validate();
<i>234</i>&nbsp;
<i>235</i>&nbsp;        //delegate to the superclass to install defaults such as background,
<i>236</i>&nbsp;        //foreground, font, and opaque onto the swing component.
<i>237</i>&nbsp;        super.installDefaults(ctx);
<i>238</i>&nbsp;    }
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /**
<b class="nc"><i>241</i>&nbsp;     * Pulls data out of UIDefaults, if it has not done so already, and sets</b>
<i>242</i>&nbsp;     * up the internal state.
<i>243</i>&nbsp;     */
<i>244</i>&nbsp;    private void validate() {
<i>245</i>&nbsp;        // a non-null values object is the flag we use to determine whether
<i>246</i>&nbsp;        // to reparse from UIManager.
<b class="nc"><i>247</i>&nbsp;        if (values != null) return;</b>
<i>248</i>&nbsp;
<i>249</i>&nbsp;        // reconstruct this NimbusStyle based on the entries in the UIManager
<b class="nc"><i>250</i>&nbsp;        // and possibly based on any overrides within the component&#39;s</b>
<b class="nc"><i>251</i>&nbsp;        // client properties (assuming such a component exists and contains</b>
<i>252</i>&nbsp;        // any Nimbus.Overrides)
<i>253</i>&nbsp;        values = new Values();
<i>254</i>&nbsp;
<i>255</i>&nbsp;        Map&lt;String, Object&gt; defaults =
<b class="nc"><i>256</i>&nbsp;                ((NimbusLookAndFeel) UIManager.getLookAndFeel()).</b>
<i>257</i>&nbsp;                        getDefaultsForPrefix(prefix);
<i>258</i>&nbsp;
<b class="nc"><i>259</i>&nbsp;        // inspect the client properties for the key &quot;Nimbus.Overrides&quot;. If the</b>
<b class="nc"><i>260</i>&nbsp;        // value is an instance of UIDefaults, then these defaults are used</b>
<b class="nc"><i>261</i>&nbsp;        // in place of, or in addition to, the defaults in UIManager.</b>
<i>262</i>&nbsp;        if (component != null) {
<b class="nc"><i>263</i>&nbsp;            // We know component.get() is non-null here, as if the component</b>
<b class="nc"><i>264</i>&nbsp;            // were GC&#39;ed, we wouldn&#39;t be processing its style.</b>
<b class="nc"><i>265</i>&nbsp;            Object o = component.get().getClientProperty(&quot;Nimbus.Overrides&quot;);</b>
<b class="nc"><i>266</i>&nbsp;            if (o instanceof UIDefaults) {</b>
<b class="nc"><i>267</i>&nbsp;                Object i = component.get().getClientProperty(</b>
<b class="nc"><i>268</i>&nbsp;                        &quot;Nimbus.Overrides.InheritDefaults&quot;);</b>
<b class="nc"><i>269</i>&nbsp;                boolean inherit = i instanceof Boolean ? (Boolean)i : true;</b>
<b class="nc"><i>270</i>&nbsp;                UIDefaults d = (UIDefaults)o;</b>
<i>271</i>&nbsp;                TreeMap&lt;String, Object&gt; map = new TreeMap&lt;String, Object&gt;();
<i>272</i>&nbsp;                for (Object obj : d.keySet()) {
<b class="nc"><i>273</i>&nbsp;                    if (obj instanceof String) {</b>
<b class="nc"><i>274</i>&nbsp;                        String key = (String)obj;</b>
<b class="nc"><i>275</i>&nbsp;                        if (key.startsWith(prefix)) {</b>
<i>276</i>&nbsp;                            map.put(key, d.get(key));
<b class="nc"><i>277</i>&nbsp;                        }</b>
<i>278</i>&nbsp;                    }
<i>279</i>&nbsp;                }
<i>280</i>&nbsp;                if (inherit) {
<i>281</i>&nbsp;                    defaults.putAll(map);
<i>282</i>&nbsp;                } else {
<i>283</i>&nbsp;                    defaults = map;
<i>284</i>&nbsp;                }
<i>285</i>&nbsp;            }
<b class="nc"><i>286</i>&nbsp;        }</b>
<i>287</i>&nbsp;
<b class="nc"><i>288</i>&nbsp;        //a list of the different types of states used by this style. This</b>
<i>289</i>&nbsp;        //list may contain only &quot;standard&quot; states (those defined by Synth),
<i>290</i>&nbsp;        //or it may contain custom states, or it may contain only &quot;standard&quot;
<b class="nc"><i>291</i>&nbsp;        //states but list them in a non-standard order.</b>
<i>292</i>&nbsp;        List&lt;State&lt;?&gt;&gt; states = new ArrayList&lt;&gt;();
<i>293</i>&nbsp;        //a map of state name to code
<i>294</i>&nbsp;        Map&lt;String,Integer&gt; stateCodes = new HashMap&lt;&gt;();
<i>295</i>&nbsp;        //This is a list of runtime &quot;state&quot; context objects. These contain
<i>296</i>&nbsp;        //the values associated with each state.
<i>297</i>&nbsp;        List&lt;RuntimeState&gt; runtimeStates = new ArrayList&lt;&gt;();
<b class="nc"><i>298</i>&nbsp;</b>
<b class="nc"><i>299</i>&nbsp;        //determine whether there are any custom states, or custom state</b>
<b class="nc"><i>300</i>&nbsp;        //order. If so, then read all those custom states and define the</b>
<b class="nc"><i>301</i>&nbsp;        //&quot;values&quot; stateTypes to be a non-null array.</b>
<b class="nc"><i>302</i>&nbsp;        //Otherwise, let the &quot;values&quot; stateTypes be null to indicate that</b>
<b class="nc"><i>303</i>&nbsp;        //there are no custom states or custom state ordering</b>
<i>304</i>&nbsp;        String statesString = (String)defaults.get(prefix + &quot;.States&quot;);
<i>305</i>&nbsp;        if (statesString != null) {
<b class="nc"><i>306</i>&nbsp;            String s[] = statesString.split(&quot;,&quot;);</b>
<b class="nc"><i>307</i>&nbsp;            for (int i=0; i&lt;s.length; i++) {</b>
<b class="nc"><i>308</i>&nbsp;                s[i] = s[i].trim();</b>
<b class="nc"><i>309</i>&nbsp;                if (!State.isStandardStateName(s[i])) {</b>
<i>310</i>&nbsp;                    //this is a non-standard state name, so look for the
<b class="nc"><i>311</i>&nbsp;                    //custom state associated with it</b>
<b class="nc"><i>312</i>&nbsp;                    String stateName = prefix + &quot;.&quot; + s[i];</b>
<i>313</i>&nbsp;                    State&lt;?&gt; customState = (State)defaults.get(stateName);
<i>314</i>&nbsp;                    if (customState != null) {
<i>315</i>&nbsp;                        states.add(customState);
<i>316</i>&nbsp;                    }
<i>317</i>&nbsp;                } else {
<i>318</i>&nbsp;                    states.add(State.getStandardState(s[i]));
<b class="nc"><i>319</i>&nbsp;                }</b>
<b class="nc"><i>320</i>&nbsp;            }</b>
<i>321</i>&nbsp;
<i>322</i>&nbsp;            //if there were any states defined, then set the stateTypes array
<i>323</i>&nbsp;            //to be non-null. Otherwise, leave it null (meaning, use the
<b class="nc"><i>324</i>&nbsp;            //standard synth states).</b>
<b class="nc"><i>325</i>&nbsp;            if (states.size() &gt; 0) {</b>
<b class="nc"><i>326</i>&nbsp;                values.stateTypes = states.toArray(new State&lt;?&gt;[states.size()]);</b>
<b class="nc"><i>327</i>&nbsp;            }</b>
<b class="nc"><i>328</i>&nbsp;</b>
<b class="nc"><i>329</i>&nbsp;            //assign codes for each of the state types</b>
<i>330</i>&nbsp;            int code = 1;
<i>331</i>&nbsp;            for (State&lt;?&gt; state : states) {
<i>332</i>&nbsp;                stateCodes.put(state.getName(), code);
<i>333</i>&nbsp;                code &lt;&lt;= 1;
<i>334</i>&nbsp;            }
<i>335</i>&nbsp;        } else {
<b class="nc"><i>336</i>&nbsp;            //since there were no custom states defined, setup the list of</b>
<b class="nc"><i>337</i>&nbsp;            //standard synth states. Note that the &quot;v.stateTypes&quot; is not</b>
<b class="nc"><i>338</i>&nbsp;            //being set here, indicating that at runtime the state selection</b>
<b class="nc"><i>339</i>&nbsp;            //routines should use standard synth states instead of custom</b>
<b class="nc"><i>340</i>&nbsp;            //states. I do need to popuplate this temp list now though, so that</b>
<b class="nc"><i>341</i>&nbsp;            //the remainder of this method will function as expected.</b>
<b class="nc"><i>342</i>&nbsp;            states.add(State.Enabled);</b>
<i>343</i>&nbsp;            states.add(State.MouseOver);
<i>344</i>&nbsp;            states.add(State.Pressed);
<b class="nc"><i>345</i>&nbsp;            states.add(State.Disabled);</b>
<b class="nc"><i>346</i>&nbsp;            states.add(State.Focused);</b>
<b class="nc"><i>347</i>&nbsp;            states.add(State.Selected);</b>
<b class="nc"><i>348</i>&nbsp;            states.add(State.Default);</b>
<b class="nc"><i>349</i>&nbsp;</b>
<b class="nc"><i>350</i>&nbsp;            //assign codes for the states</b>
<b class="nc"><i>351</i>&nbsp;            stateCodes.put(&quot;Enabled&quot;, ENABLED);</b>
<i>352</i>&nbsp;            stateCodes.put(&quot;MouseOver&quot;, MOUSE_OVER);
<i>353</i>&nbsp;            stateCodes.put(&quot;Pressed&quot;, PRESSED);
<i>354</i>&nbsp;            stateCodes.put(&quot;Disabled&quot;, DISABLED);
<b class="nc"><i>355</i>&nbsp;            stateCodes.put(&quot;Focused&quot;, FOCUSED);</b>
<i>356</i>&nbsp;            stateCodes.put(&quot;Selected&quot;, SELECTED);
<i>357</i>&nbsp;            stateCodes.put(&quot;Default&quot;, DEFAULT);
<i>358</i>&nbsp;        }
<b class="nc"><i>359</i>&nbsp;</b>
<i>360</i>&nbsp;        //Now iterate over all the keys in the defaults table
<i>361</i>&nbsp;        for (String key : defaults.keySet()) {
<b class="nc"><i>362</i>&nbsp;            //The key is something like JButton.Enabled.backgroundPainter,</b>
<i>363</i>&nbsp;            //or JButton.States, or JButton.background.
<b class="nc"><i>364</i>&nbsp;            //Remove the &quot;JButton.&quot; portion of the key</b>
<i>365</i>&nbsp;            String temp = key.substring(prefix.length());
<i>366</i>&nbsp;            //if there is a &quot; or : then we skip it because it is a subregion
<i>367</i>&nbsp;            //of some kind
<i>368</i>&nbsp;            if (temp.indexOf(&#39;&quot;&#39;) != -1 || temp.indexOf(&#39;:&#39;) != -1) continue;
<i>369</i>&nbsp;            //remove the separator
<i>370</i>&nbsp;            temp = temp.substring(1);
<i>371</i>&nbsp;            //At this point, temp may be any of the following:
<b class="nc"><i>372</i>&nbsp;            //background</b>
<b class="nc"><i>373</i>&nbsp;            //[Enabled].background</b>
<b class="nc"><i>374</i>&nbsp;            //[Enabled+MouseOver].background</b>
<b class="nc"><i>375</i>&nbsp;            //property.foo</b>
<i>376</i>&nbsp;
<b class="nc"><i>377</i>&nbsp;            //parse out the states and the property</b>
<i>378</i>&nbsp;            String stateString = null;
<b class="nc"><i>379</i>&nbsp;            String property = null;</b>
<b class="nc"><i>380</i>&nbsp;            int bracketIndex = temp.indexOf(&#39;]&#39;);</b>
<i>381</i>&nbsp;            if (bracketIndex &lt; 0) {
<i>382</i>&nbsp;                //there is not a state string, so property = temp
<i>383</i>&nbsp;                property = temp;
<i>384</i>&nbsp;            } else {
<b class="nc"><i>385</i>&nbsp;                stateString = temp.substring(0, bracketIndex);</b>
<i>386</i>&nbsp;                property = temp.substring(bracketIndex + 2);
<i>387</i>&nbsp;            }
<i>388</i>&nbsp;
<i>389</i>&nbsp;            //now that I have the state (if any) and the property, get the
<i>390</i>&nbsp;            //value for this property and install it where it belongs
<i>391</i>&nbsp;            if (stateString == null) {
<b class="nc"><i>392</i>&nbsp;                //there was no state, just a property. Check for the custom</b>
<b class="nc"><i>393</i>&nbsp;                //&quot;contentMargins&quot; property (which is handled specially by</b>
<b class="nc"><i>394</i>&nbsp;                //Synth/Nimbus). Also check for the property being &quot;States&quot;,</b>
<i>395</i>&nbsp;                //in which case it is not a real property and should be ignored.
<i>396</i>&nbsp;                //otherwise, assume it is a property and install it on the
<b class="nc"><i>397</i>&nbsp;                //values object</b>
<i>398</i>&nbsp;                if (&quot;contentMargins&quot;.equals(property)) {
<i>399</i>&nbsp;                    values.contentMargins = (Insets)defaults.get(key);
<i>400</i>&nbsp;                } else if (&quot;States&quot;.equals(property)) {
<i>401</i>&nbsp;                    //ignore
<i>402</i>&nbsp;                } else {
<i>403</i>&nbsp;                    values.defaults.put(property, defaults.get(key));
<b class="nc"><i>404</i>&nbsp;                }</b>
<i>405</i>&nbsp;            } else {
<i>406</i>&nbsp;                //it is possible that the developer has a malformed UIDefaults
<b class="nc"><i>407</i>&nbsp;                //entry, such that something was specified in the place of</b>
<i>408</i>&nbsp;                //the State portion of the key but it wasn&#39;t a state. In this
<i>409</i>&nbsp;                //case, skip will be set to true
<b class="nc"><i>410</i>&nbsp;                boolean skip = false;</b>
<i>411</i>&nbsp;                //this variable keeps track of the int value associated with
<i>412</i>&nbsp;                //the state. See SynthState for details.
<b class="nc"><i>413</i>&nbsp;                int componentState = 0;</b>
<b class="nc"><i>414</i>&nbsp;                //Multiple states may be specified in the string, such as</b>
<b class="nc"><i>415</i>&nbsp;                //Enabled+MouseOver</b>
<i>416</i>&nbsp;                String[] stateParts = stateString.split(&quot;\\+&quot;);
<i>417</i>&nbsp;                //For each state, we need to find the State object associated
<i>418</i>&nbsp;                //with it, or skip it if it cannot be found.
<b class="nc"><i>419</i>&nbsp;                for (String s : stateParts) {</b>
<b class="nc"><i>420</i>&nbsp;                    if (stateCodes.containsKey(s)) {</b>
<i>421</i>&nbsp;                        componentState |= stateCodes.get(s);
<i>422</i>&nbsp;                    } else {
<i>423</i>&nbsp;                        //Was not a state. Maybe it was a subregion or something
<b class="nc"><i>424</i>&nbsp;                        //skip it.</b>
<i>425</i>&nbsp;                        skip = true;
<i>426</i>&nbsp;                        break;
<b class="nc"><i>427</i>&nbsp;                    }</b>
<b class="nc"><i>428</i>&nbsp;                }</b>
<b class="nc"><i>429</i>&nbsp;</b>
<b class="nc"><i>430</i>&nbsp;                if (skip) continue;</b>
<b class="nc"><i>431</i>&nbsp;</b>
<i>432</i>&nbsp;                //find the RuntimeState for this State
<b class="nc"><i>433</i>&nbsp;                RuntimeState rs = null;</b>
<i>434</i>&nbsp;                for (RuntimeState s : runtimeStates) {
<i>435</i>&nbsp;                    if (s.state == componentState) {
<b class="nc"><i>436</i>&nbsp;                        rs = s;</b>
<b class="nc"><i>437</i>&nbsp;                        break;</b>
<b class="nc"><i>438</i>&nbsp;                    }</b>
<i>439</i>&nbsp;                }
<i>440</i>&nbsp;
<i>441</i>&nbsp;                //couldn&#39;t find the runtime state, so create a new one
<i>442</i>&nbsp;                if (rs == null) {
<i>443</i>&nbsp;                    rs = new RuntimeState(componentState, stateString);
<i>444</i>&nbsp;                    runtimeStates.add(rs);
<i>445</i>&nbsp;                }
<b class="nc"><i>446</i>&nbsp;</b>
<b class="nc"><i>447</i>&nbsp;                //check for a couple special properties, such as for the</b>
<b class="nc"><i>448</i>&nbsp;                //painters. If these are found, then set the specially on</b>
<b class="nc"><i>449</i>&nbsp;                //the runtime state. Else, it is just a normal property,</b>
<b class="nc"><i>450</i>&nbsp;                //so put it in the UIDefaults associated with that runtime</b>
<b class="nc"><i>451</i>&nbsp;                //state</b>
<i>452</i>&nbsp;                if (&quot;backgroundPainter&quot;.equals(property)) {
<b class="nc"><i>453</i>&nbsp;                    rs.backgroundPainter = getPainter(defaults, key);</b>
<i>454</i>&nbsp;                } else if (&quot;foregroundPainter&quot;.equals(property)) {
<i>455</i>&nbsp;                    rs.foregroundPainter = getPainter(defaults, key);
<b class="nc"><i>456</i>&nbsp;                } else if (&quot;borderPainter&quot;.equals(property)) {</b>
<i>457</i>&nbsp;                    rs.borderPainter = getPainter(defaults, key);
<i>458</i>&nbsp;                } else {
<i>459</i>&nbsp;                    rs.defaults.put(property, defaults.get(key));
<b class="nc"><i>460</i>&nbsp;                }</b>
<i>461</i>&nbsp;            }
<i>462</i>&nbsp;        }
<b class="nc"><i>463</i>&nbsp;</b>
<i>464</i>&nbsp;        //now that I&#39;ve collected all the runtime states, I&#39;ll sort them based
<i>465</i>&nbsp;        //on their integer &quot;state&quot; (see SynthState for how this works).
<i>466</i>&nbsp;        Collections.sort(runtimeStates, STATE_COMPARATOR);
<b class="nc"><i>467</i>&nbsp;</b>
<b class="nc"><i>468</i>&nbsp;        //finally, set the array of runtime states on the values object</b>
<b class="nc"><i>469</i>&nbsp;        values.states = runtimeStates.toArray(new RuntimeState[runtimeStates.size()]);</b>
<i>470</i>&nbsp;    }
<b class="nc"><i>471</i>&nbsp;</b>
<i>472</i>&nbsp;    private Painter&lt;Object&gt; getPainter(Map&lt;String, Object&gt; defaults, String key) {
<i>473</i>&nbsp;        Object p = defaults.get(key);
<i>474</i>&nbsp;        if (p instanceof UIDefaults.LazyValue) {
<i>475</i>&nbsp;            p = ((UIDefaults.LazyValue)p).createValue(UIManager.getDefaults());
<i>476</i>&nbsp;        }
<i>477</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>478</i>&nbsp;        Painter&lt;Object&gt; tmp = (p instanceof Painter ? (Painter)p : null);
<i>479</i>&nbsp;        return tmp;
<i>480</i>&nbsp;    }
<b class="nc"><i>481</i>&nbsp;</b>
<b class="nc"><i>482</i>&nbsp;    /**</b>
<i>483</i>&nbsp;     * {@inheritDoc}
<i>484</i>&nbsp;     *
<b class="nc"><i>485</i>&nbsp;     * Overridden to cause this style to populate itself with data from</b>
<i>486</i>&nbsp;     * UIDefaults, if necessary.
<b class="nc"><i>487</i>&nbsp;     */</b>
<b class="nc"><i>488</i>&nbsp;    @Override public Insets getInsets(SynthContext ctx, Insets in) {</b>
<b class="nc"><i>489</i>&nbsp;        if (in == null) {</b>
<i>490</i>&nbsp;            in = new Insets(0, 0, 0, 0);
<b class="nc"><i>491</i>&nbsp;        }</b>
<b class="nc"><i>492</i>&nbsp;</b>
<b class="nc"><i>493</i>&nbsp;        Values v = getValues(ctx);</b>
<b class="nc"><i>494</i>&nbsp;</b>
<i>495</i>&nbsp;        if (v.contentMargins == null) {
<i>496</i>&nbsp;            in.bottom = in.top = in.left = in.right = 0;
<b class="nc"><i>497</i>&nbsp;            return in;</b>
<i>498</i>&nbsp;        } else {
<b class="nc"><i>499</i>&nbsp;            in.bottom = v.contentMargins.bottom;</b>
<b class="nc"><i>500</i>&nbsp;            in.top = v.contentMargins.top;</b>
<b class="nc"><i>501</i>&nbsp;            in.left = v.contentMargins.left;</b>
<b class="nc"><i>502</i>&nbsp;            in.right = v.contentMargins.right;</b>
<b class="nc"><i>503</i>&nbsp;            // Account for scale</b>
<b class="nc"><i>504</i>&nbsp;            // The key &quot;JComponent.sizeVariant&quot; is used to match Apple&#39;s LAF</b>
<b class="nc"><i>505</i>&nbsp;            String scaleKey = (String)ctx.getComponent().getClientProperty(</b>
<b class="nc"><i>506</i>&nbsp;                    &quot;JComponent.sizeVariant&quot;);</b>
<b class="nc"><i>507</i>&nbsp;            if (scaleKey != null){</b>
<b class="nc"><i>508</i>&nbsp;                if (LARGE_KEY.equals(scaleKey)){</b>
<b class="nc"><i>509</i>&nbsp;                    in.bottom *= LARGE_SCALE;</b>
<b class="nc"><i>510</i>&nbsp;                    in.top *= LARGE_SCALE;</b>
<b class="nc"><i>511</i>&nbsp;                    in.left *= LARGE_SCALE;</b>
<b class="nc"><i>512</i>&nbsp;                    in.right *= LARGE_SCALE;</b>
<b class="nc"><i>513</i>&nbsp;                } else if (SMALL_KEY.equals(scaleKey)){</b>
<b class="nc"><i>514</i>&nbsp;                    in.bottom *= SMALL_SCALE;</b>
<i>515</i>&nbsp;                    in.top *= SMALL_SCALE;
<i>516</i>&nbsp;                    in.left *= SMALL_SCALE;
<b class="nc"><i>517</i>&nbsp;                    in.right *= SMALL_SCALE;</b>
<i>518</i>&nbsp;                } else if (MINI_KEY.equals(scaleKey)){
<i>519</i>&nbsp;                    in.bottom *= MINI_SCALE;
<i>520</i>&nbsp;                    in.top *= MINI_SCALE;
<i>521</i>&nbsp;                    in.left *= MINI_SCALE;
<i>522</i>&nbsp;                    in.right *= MINI_SCALE;
<i>523</i>&nbsp;                }
<i>524</i>&nbsp;            }
<i>525</i>&nbsp;            return in;
<i>526</i>&nbsp;        }
<i>527</i>&nbsp;    }
<i>528</i>&nbsp;
<i>529</i>&nbsp;    /**
<i>530</i>&nbsp;     * {@inheritDoc}
<i>531</i>&nbsp;     *
<i>532</i>&nbsp;     * &lt;p&gt;Overridden to cause this style to populate itself with data from
<i>533</i>&nbsp;     * UIDefaults, if necessary.&lt;/p&gt;
<i>534</i>&nbsp;     *
<i>535</i>&nbsp;     * &lt;p&gt;In addition, NimbusStyle handles ColorTypes slightly differently from
<i>536</i>&nbsp;     * Synth.&lt;/p&gt;
<i>537</i>&nbsp;     * &lt;ul&gt;
<i>538</i>&nbsp;     *  &lt;li&gt;ColorType.BACKGROUND will equate to the color stored in UIDefaults
<i>539</i>&nbsp;     *      named &quot;background&quot;.&lt;/li&gt;
<i>540</i>&nbsp;     *  &lt;li&gt;ColorType.TEXT_BACKGROUND will equate to the color stored in
<b class="nc"><i>541</i>&nbsp;     *      UIDefaults named &quot;textBackground&quot;.&lt;/li&gt;</b>
<b class="nc"><i>542</i>&nbsp;     *  &lt;li&gt;ColorType.FOREGROUND will equate to the color stored in UIDefaults</b>
<b class="nc"><i>543</i>&nbsp;     *      named &quot;textForeground&quot;.&lt;/li&gt;</b>
<b class="nc"><i>544</i>&nbsp;     *  &lt;li&gt;ColorType.TEXT_FOREGROUND will equate to the color stored in</b>
<i>545</i>&nbsp;     *      UIDefaults named &quot;textForeground&quot;.&lt;/li&gt;
<b class="nc"><i>546</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>547</i>&nbsp;     */</b>
<b class="nc"><i>548</i>&nbsp;    @Override protected Color getColorForState(SynthContext ctx, ColorType type) {</b>
<b class="nc"><i>549</i>&nbsp;        String key = null;</b>
<b class="nc"><i>550</i>&nbsp;        if (type == ColorType.BACKGROUND) {</b>
<b class="nc"><i>551</i>&nbsp;            key = &quot;background&quot;;</b>
<b class="nc"><i>552</i>&nbsp;        } else if (type == ColorType.FOREGROUND) {</b>
<b class="nc"><i>553</i>&nbsp;            //map FOREGROUND as TEXT_FOREGROUND</b>
<b class="nc"><i>554</i>&nbsp;            key = &quot;textForeground&quot;;</b>
<i>555</i>&nbsp;        } else if (type == ColorType.TEXT_BACKGROUND) {
<b class="nc"><i>556</i>&nbsp;            key = &quot;textBackground&quot;;</b>
<i>557</i>&nbsp;        } else if (type == ColorType.TEXT_FOREGROUND) {
<b class="nc"><i>558</i>&nbsp;            key = &quot;textForeground&quot;;</b>
<i>559</i>&nbsp;        } else if (type == ColorType.FOCUS) {
<b class="nc"><i>560</i>&nbsp;            key = &quot;focus&quot;;</b>
<b class="nc"><i>561</i>&nbsp;        } else if (type != null) {</b>
<i>562</i>&nbsp;            key = type.toString();
<i>563</i>&nbsp;        } else {
<i>564</i>&nbsp;            return DEFAULT_COLOR;
<i>565</i>&nbsp;        }
<i>566</i>&nbsp;        Color c = (Color) get(ctx, key);
<i>567</i>&nbsp;        //if all else fails, return a default color (which is a ColorUIResource)
<i>568</i>&nbsp;        if (c == null) c = DEFAULT_COLOR;
<i>569</i>&nbsp;        return c;
<i>570</i>&nbsp;    }
<i>571</i>&nbsp;
<i>572</i>&nbsp;    /**
<b class="nc"><i>573</i>&nbsp;     * {@inheritDoc}</b>
<b class="nc"><i>574</i>&nbsp;     *</b>
<i>575</i>&nbsp;     * Overridden to cause this style to populate itself with data from
<i>576</i>&nbsp;     * UIDefaults, if necessary. If a value named &quot;font&quot; is not found in
<i>577</i>&nbsp;     * UIDefaults, then the &quot;defaultFont&quot; font in UIDefaults will be returned
<b class="nc"><i>578</i>&nbsp;     * instead.</b>
<i>579</i>&nbsp;     */
<b class="nc"><i>580</i>&nbsp;    @Override protected Font getFontForState(SynthContext ctx) {</b>
<b class="nc"><i>581</i>&nbsp;        Font f = (Font)get(ctx, &quot;font&quot;);</b>
<b class="nc"><i>582</i>&nbsp;        if (f == null) f = UIManager.getFont(&quot;defaultFont&quot;);</b>
<b class="nc"><i>583</i>&nbsp;</b>
<b class="nc"><i>584</i>&nbsp;        // Account for scale</b>
<b class="nc"><i>585</i>&nbsp;        // The key &quot;JComponent.sizeVariant&quot; is used to match Apple&#39;s LAF</b>
<b class="nc"><i>586</i>&nbsp;        String scaleKey = (String)ctx.getComponent().getClientProperty(</b>
<i>587</i>&nbsp;                &quot;JComponent.sizeVariant&quot;);
<i>588</i>&nbsp;        if (scaleKey != null){
<b class="nc"><i>589</i>&nbsp;            if (LARGE_KEY.equals(scaleKey)){</b>
<i>590</i>&nbsp;                f = f.deriveFont(Math.round(f.getSize2D()*LARGE_SCALE));
<i>591</i>&nbsp;            } else if (SMALL_KEY.equals(scaleKey)){
<i>592</i>&nbsp;                f = f.deriveFont(Math.round(f.getSize2D()*SMALL_SCALE));
<i>593</i>&nbsp;            } else if (MINI_KEY.equals(scaleKey)){
<i>594</i>&nbsp;                f = f.deriveFont(Math.round(f.getSize2D()*MINI_SCALE));
<i>595</i>&nbsp;            }
<i>596</i>&nbsp;        }
<i>597</i>&nbsp;        return f;
<i>598</i>&nbsp;    }
<b class="nc"><i>599</i>&nbsp;</b>
<i>600</i>&nbsp;    /**
<i>601</i>&nbsp;     * {@inheritDoc}
<i>602</i>&nbsp;     *
<i>603</i>&nbsp;     * Returns the SynthPainter for this style, which ends up delegating to
<i>604</i>&nbsp;     * the Painters installed in this style.
<i>605</i>&nbsp;     */
<i>606</i>&nbsp;    @Override public SynthPainter getPainter(SynthContext ctx) {
<i>607</i>&nbsp;        return painter;
<i>608</i>&nbsp;    }
<i>609</i>&nbsp;
<i>610</i>&nbsp;    /**
<b class="nc"><i>611</i>&nbsp;     * {@inheritDoc}</b>
<b class="nc"><i>612</i>&nbsp;     *</b>
<i>613</i>&nbsp;     * Overridden to cause this style to populate itself with data from
<b class="nc"><i>614</i>&nbsp;     * UIDefaults, if necessary. If opacity is not specified in UI defaults,</b>
<b class="nc"><i>615</i>&nbsp;     * then it defaults to being non-opaque.</b>
<i>616</i>&nbsp;     */
<i>617</i>&nbsp;    @Override public boolean isOpaque(SynthContext ctx) {
<i>618</i>&nbsp;        // Force Table CellRenderers to be opaque
<i>619</i>&nbsp;        if (&quot;Table.cellRenderer&quot;.equals(ctx.getComponent().getName())) {
<i>620</i>&nbsp;            return true;
<i>621</i>&nbsp;        }
<i>622</i>&nbsp;        Boolean opaque = (Boolean)get(ctx, &quot;opaque&quot;);
<i>623</i>&nbsp;        return opaque == null ? false : opaque;
<i>624</i>&nbsp;    }
<i>625</i>&nbsp;
<i>626</i>&nbsp;    /**
<i>627</i>&nbsp;     * {@inheritDoc}
<i>628</i>&nbsp;     *
<i>629</i>&nbsp;     * &lt;p&gt;Overridden to cause this style to populate itself with data from
<i>630</i>&nbsp;     * UIDefaults, if necessary.&lt;/p&gt;
<i>631</i>&nbsp;     *
<i>632</i>&nbsp;     * &lt;p&gt;Properties in UIDefaults may be specified in a chained manner. For
<i>633</i>&nbsp;     * example:
<i>634</i>&nbsp;     * &lt;pre&gt;
<i>635</i>&nbsp;     * background
<i>636</i>&nbsp;     * Button.opacity
<i>637</i>&nbsp;     * Button.Enabled.foreground
<i>638</i>&nbsp;     * Button.Enabled+Selected.background
<i>639</i>&nbsp;     * &lt;/pre&gt;
<i>640</i>&nbsp;     *
<i>641</i>&nbsp;     * &lt;p&gt;In this example, suppose you were in the Enabled+Selected state and
<i>642</i>&nbsp;     * searched for &quot;foreground&quot;. In this case, we first check for
<i>643</i>&nbsp;     * Button.Enabled+Selected.foreground, but no such color exists. We then
<i>644</i>&nbsp;     * fall back to the next valid state, in this case,
<i>645</i>&nbsp;     * Button.Enabled.foreground, and have a match. So we return it.&lt;/p&gt;
<i>646</i>&nbsp;     *
<i>647</i>&nbsp;     * &lt;p&gt;Again, if we were in the state Enabled and looked for &quot;background&quot;, we
<i>648</i>&nbsp;     * wouldn&#39;t find it in Button.Enabled, or in Button, but would at the top
<i>649</i>&nbsp;     * level in UIManager. So we return that value.&lt;/p&gt;
<i>650</i>&nbsp;     *
<i>651</i>&nbsp;     * &lt;p&gt;One special note: the &quot;key&quot; passed to this method could be of the form
<b class="nc"><i>652</i>&nbsp;     * &quot;background&quot; or &quot;Button.background&quot; where &quot;Button&quot; equals the prefix</b>
<i>653</i>&nbsp;     * passed to the NimbusStyle constructor. In either case, it looks for
<i>654</i>&nbsp;     * &quot;background&quot;.&lt;/p&gt;
<b class="nc"><i>655</i>&nbsp;     *</b>
<b class="nc"><i>656</i>&nbsp;     * @param ctx SynthContext identifying requester</b>
<i>657</i>&nbsp;     * @param key must not be null
<b class="nc"><i>658</i>&nbsp;     */</b>
<b class="nc"><i>659</i>&nbsp;    @Override public Object get(SynthContext ctx, Object key) {</b>
<i>660</i>&nbsp;        Values v = getValues(ctx);
<i>661</i>&nbsp;
<b class="nc"><i>662</i>&nbsp;        // strip off the prefix, if there is one.</b>
<b class="nc"><i>663</i>&nbsp;        String fullKey = key.toString();</b>
<b class="nc"><i>664</i>&nbsp;        String partialKey = fullKey.substring(fullKey.indexOf(&#39;.&#39;) + 1);</b>
<b class="nc"><i>665</i>&nbsp;</b>
<i>666</i>&nbsp;        Object obj = null;
<b class="nc"><i>667</i>&nbsp;        int xstate = getExtendedState(ctx, v);</b>
<b class="nc"><i>668</i>&nbsp;</b>
<b class="nc"><i>669</i>&nbsp;        // check the cache</b>
<b class="nc"><i>670</i>&nbsp;        tmpKey.init(partialKey, xstate);</b>
<b class="nc"><i>671</i>&nbsp;        obj = v.cache.get(tmpKey);</b>
<i>672</i>&nbsp;        boolean wasInCache = obj != null;
<i>673</i>&nbsp;        if (!wasInCache){
<b class="nc"><i>674</i>&nbsp;            // Search exact matching states and then lesser matching states</b>
<b class="nc"><i>675</i>&nbsp;            RuntimeState s = null;</b>
<i>676</i>&nbsp;            int[] lastIndex = new int[] {-1};
<i>677</i>&nbsp;            while (obj == null &amp;&amp;
<i>678</i>&nbsp;                    (s = getNextState(v.states, lastIndex, xstate)) != null) {
<b class="nc"><i>679</i>&nbsp;                obj = s.defaults.get(partialKey);</b>
<i>680</i>&nbsp;            }
<b class="nc"><i>681</i>&nbsp;            // Search Region Defaults</b>
<b class="nc"><i>682</i>&nbsp;            if (obj == null &amp;&amp; v.defaults != null) {</b>
<i>683</i>&nbsp;                obj = v.defaults.get(partialKey);
<i>684</i>&nbsp;            }
<b class="nc"><i>685</i>&nbsp;            // return found object</b>
<i>686</i>&nbsp;            // Search UIManager Defaults
<i>687</i>&nbsp;            if (obj == null) obj = UIManager.get(fullKey);
<i>688</i>&nbsp;            // Search Synth Defaults for InputMaps
<b class="nc"><i>689</i>&nbsp;            if (obj == null &amp;&amp; partialKey.equals(&quot;focusInputMap&quot;)) {</b>
<i>690</i>&nbsp;                obj = super.get(ctx, fullKey);
<i>691</i>&nbsp;            }
<i>692</i>&nbsp;            // if all we got was a null, store this fact for later use
<i>693</i>&nbsp;            v.cache.put(new CacheKey(partialKey, xstate),
<i>694</i>&nbsp;                    obj == null ? NULL : obj);
<i>695</i>&nbsp;        }
<i>696</i>&nbsp;        // return found object
<i>697</i>&nbsp;        return obj == NULL ? null : obj;
<i>698</i>&nbsp;    }
<i>699</i>&nbsp;
<i>700</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>701</i>&nbsp;    private static Painter&lt;Object&gt; paintFilter(@SuppressWarnings(&quot;rawtypes&quot;) Painter painter) {
<b class="nc"><i>702</i>&nbsp;        return (Painter&lt;Object&gt;) painter;</b>
<b class="nc"><i>703</i>&nbsp;    }</b>
<b class="nc"><i>704</i>&nbsp;</b>
<i>705</i>&nbsp;
<i>706</i>&nbsp;    /**
<b class="nc"><i>707</i>&nbsp;     * Gets the appropriate background Painter, if there is one, for the state</b>
<b class="nc"><i>708</i>&nbsp;     * specified in the given SynthContext. This method does appropriate</b>
<b class="nc"><i>709</i>&nbsp;     * fallback searching, as described in #get.</b>
<i>710</i>&nbsp;     *
<i>711</i>&nbsp;     * @param ctx The SynthContext. Must not be null.
<b class="nc"><i>712</i>&nbsp;     * @return The background painter associated for the given state, or null if</b>
<b class="nc"><i>713</i>&nbsp;     * none could be found.</b>
<b class="nc"><i>714</i>&nbsp;     */</b>
<b class="nc"><i>715</i>&nbsp;    public Painter&lt;Object&gt; getBackgroundPainter(SynthContext ctx) {</b>
<b class="nc"><i>716</i>&nbsp;        Values v = getValues(ctx);</b>
<b class="nc"><i>717</i>&nbsp;        int xstate = getExtendedState(ctx, v);</b>
<i>718</i>&nbsp;        Painter&lt;Object&gt; p = null;
<i>719</i>&nbsp;
<b class="nc"><i>720</i>&nbsp;        // check the cache</b>
<b class="nc"><i>721</i>&nbsp;        tmpKey.init(&quot;backgroundPainter$$instance&quot;, xstate);</b>
<b class="nc"><i>722</i>&nbsp;        p = paintFilter((Painter)v.cache.get(tmpKey));</b>
<i>723</i>&nbsp;        if (p != null) return p;
<b class="nc"><i>724</i>&nbsp;</b>
<i>725</i>&nbsp;        // not in cache, so lookup and store in cache
<i>726</i>&nbsp;        RuntimeState s = null;
<i>727</i>&nbsp;        int[] lastIndex = new int[] {-1};
<i>728</i>&nbsp;        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {
<i>729</i>&nbsp;            if (s.backgroundPainter != null) {
<i>730</i>&nbsp;                p = paintFilter(s.backgroundPainter);
<i>731</i>&nbsp;                break;
<i>732</i>&nbsp;            }
<i>733</i>&nbsp;        }
<i>734</i>&nbsp;        if (p == null) p = paintFilter((Painter)get(ctx, &quot;backgroundPainter&quot;));
<i>735</i>&nbsp;        if (p != null) {
<i>736</i>&nbsp;            v.cache.put(new CacheKey(&quot;backgroundPainter$$instance&quot;, xstate), p);
<b class="nc"><i>737</i>&nbsp;        }</b>
<b class="nc"><i>738</i>&nbsp;        return p;</b>
<b class="nc"><i>739</i>&nbsp;    }</b>
<i>740</i>&nbsp;
<i>741</i>&nbsp;    /**
<b class="nc"><i>742</i>&nbsp;     * Gets the appropriate foreground Painter, if there is one, for the state</b>
<b class="nc"><i>743</i>&nbsp;     * specified in the given SynthContext. This method does appropriate</b>
<b class="nc"><i>744</i>&nbsp;     * fallback searching, as described in #get.</b>
<i>745</i>&nbsp;     *
<i>746</i>&nbsp;     * @param ctx The SynthContext. Must not be null.
<b class="nc"><i>747</i>&nbsp;     * @return The foreground painter associated for the given state, or null if</b>
<b class="nc"><i>748</i>&nbsp;     * none could be found.</b>
<b class="nc"><i>749</i>&nbsp;     */</b>
<b class="nc"><i>750</i>&nbsp;    public Painter&lt;Object&gt; getForegroundPainter(SynthContext ctx) {</b>
<b class="nc"><i>751</i>&nbsp;        Values v = getValues(ctx);</b>
<b class="nc"><i>752</i>&nbsp;        int xstate = getExtendedState(ctx, v);</b>
<i>753</i>&nbsp;        Painter&lt;Object&gt; p = null;
<i>754</i>&nbsp;
<b class="nc"><i>755</i>&nbsp;        // check the cache</b>
<b class="nc"><i>756</i>&nbsp;        tmpKey.init(&quot;foregroundPainter$$instance&quot;, xstate);</b>
<b class="nc"><i>757</i>&nbsp;        p = paintFilter((Painter)v.cache.get(tmpKey));</b>
<i>758</i>&nbsp;        if (p != null) return p;
<b class="nc"><i>759</i>&nbsp;</b>
<i>760</i>&nbsp;        // not in cache, so lookup and store in cache
<i>761</i>&nbsp;        RuntimeState s = null;
<i>762</i>&nbsp;        int[] lastIndex = new int[] {-1};
<i>763</i>&nbsp;        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {
<i>764</i>&nbsp;            if (s.foregroundPainter != null) {
<i>765</i>&nbsp;                p = paintFilter(s.foregroundPainter);
<i>766</i>&nbsp;                break;
<i>767</i>&nbsp;            }
<i>768</i>&nbsp;        }
<i>769</i>&nbsp;        if (p == null) p = paintFilter((Painter)get(ctx, &quot;foregroundPainter&quot;));
<i>770</i>&nbsp;        if (p != null) {
<i>771</i>&nbsp;            v.cache.put(new CacheKey(&quot;foregroundPainter$$instance&quot;, xstate), p);
<b class="nc"><i>772</i>&nbsp;        }</b>
<b class="nc"><i>773</i>&nbsp;        return p;</b>
<b class="nc"><i>774</i>&nbsp;    }</b>
<i>775</i>&nbsp;
<i>776</i>&nbsp;    /**
<b class="nc"><i>777</i>&nbsp;     * Gets the appropriate border Painter, if there is one, for the state</b>
<b class="nc"><i>778</i>&nbsp;     * specified in the given SynthContext. This method does appropriate</b>
<b class="nc"><i>779</i>&nbsp;     * fallback searching, as described in #get.</b>
<i>780</i>&nbsp;     *
<i>781</i>&nbsp;     * @param ctx The SynthContext. Must not be null.
<b class="nc"><i>782</i>&nbsp;     * @return The border painter associated for the given state, or null if</b>
<b class="nc"><i>783</i>&nbsp;     * none could be found.</b>
<b class="nc"><i>784</i>&nbsp;     */</b>
<b class="nc"><i>785</i>&nbsp;    public Painter&lt;Object&gt; getBorderPainter(SynthContext ctx) {</b>
<b class="nc"><i>786</i>&nbsp;        Values v = getValues(ctx);</b>
<b class="nc"><i>787</i>&nbsp;        int xstate = getExtendedState(ctx, v);</b>
<i>788</i>&nbsp;        Painter&lt;Object&gt; p = null;
<i>789</i>&nbsp;
<b class="nc"><i>790</i>&nbsp;        // check the cache</b>
<b class="nc"><i>791</i>&nbsp;        tmpKey.init(&quot;borderPainter$$instance&quot;, xstate);</b>
<b class="nc"><i>792</i>&nbsp;        p = paintFilter((Painter)v.cache.get(tmpKey));</b>
<i>793</i>&nbsp;        if (p != null) return p;
<b class="nc"><i>794</i>&nbsp;</b>
<i>795</i>&nbsp;        // not in cache, so lookup and store in cache
<i>796</i>&nbsp;        RuntimeState s = null;
<i>797</i>&nbsp;        int[] lastIndex = new int[] {-1};
<i>798</i>&nbsp;        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {
<i>799</i>&nbsp;            if (s.borderPainter != null) {
<i>800</i>&nbsp;                p = paintFilter(s.borderPainter);
<i>801</i>&nbsp;                break;
<i>802</i>&nbsp;            }
<i>803</i>&nbsp;        }
<i>804</i>&nbsp;        if (p == null) p = paintFilter((Painter)get(ctx, &quot;borderPainter&quot;));
<i>805</i>&nbsp;        if (p != null) {
<b class="nc"><i>806</i>&nbsp;            v.cache.put(new CacheKey(&quot;borderPainter$$instance&quot;, xstate), p);</b>
<b class="nc"><i>807</i>&nbsp;        }</b>
<i>808</i>&nbsp;        return p;
<i>809</i>&nbsp;    }
<i>810</i>&nbsp;
<i>811</i>&nbsp;    /**
<i>812</i>&nbsp;     * Utility method which returns the proper Values based on the given
<i>813</i>&nbsp;     * SynthContext. Ensures that parsing of the values has occurred, or
<i>814</i>&nbsp;     * reoccurs as necessary.
<i>815</i>&nbsp;     *
<i>816</i>&nbsp;     * @param ctx The SynthContext
<i>817</i>&nbsp;     * @return a non-null values reference
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    private Values getValues(SynthContext ctx) {
<i>820</i>&nbsp;        validate();
<i>821</i>&nbsp;        return values;
<b class="nc"><i>822</i>&nbsp;    }</b>
<b class="nc"><i>823</i>&nbsp;</b>
<b class="nc"><i>824</i>&nbsp;    /**</b>
<b class="nc"><i>825</i>&nbsp;     * Simple utility method that searches the given array of Strings for the</b>
<i>826</i>&nbsp;     * given string. This method is only called from getExtendedState if
<i>827</i>&nbsp;     * the developer has specified a specific state for the component to be
<b class="nc"><i>828</i>&nbsp;     * in (ie, has &quot;wedged&quot; the component in that state) by specifying</b>
<i>829</i>&nbsp;     * they client property &quot;Nimbus.State&quot;.
<i>830</i>&nbsp;     *
<i>831</i>&nbsp;     * @param names a non-null array of strings
<i>832</i>&nbsp;     * @param name the name to look for in the array
<i>833</i>&nbsp;     * @return true or false based on whether the given name is in the array
<i>834</i>&nbsp;     */
<i>835</i>&nbsp;    private boolean contains(String[] names, String name) {
<i>836</i>&nbsp;        assert name != null;
<i>837</i>&nbsp;        for (int i=0; i&lt;names.length; i++) {
<i>838</i>&nbsp;            if (name.equals(names[i])) {
<i>839</i>&nbsp;                return true;
<i>840</i>&nbsp;            }
<i>841</i>&nbsp;        }
<i>842</i>&nbsp;        return false;
<i>843</i>&nbsp;    }
<i>844</i>&nbsp;
<i>845</i>&nbsp;    /**
<i>846</i>&nbsp;     * &lt;p&gt;Gets the extended state for a given synth context. Nimbus supports the
<i>847</i>&nbsp;     * ability to define custom states. The algorithm used for choosing what
<i>848</i>&nbsp;     * style information to use for a given state requires a single integer
<i>849</i>&nbsp;     * bit string where each bit in the integer represents a different state
<i>850</i>&nbsp;     * that the component is in. This method uses the componentState as
<i>851</i>&nbsp;     * reported in the SynthContext, in addition to custom states, to determine
<i>852</i>&nbsp;     * what this extended state is.&lt;/p&gt;
<i>853</i>&nbsp;     *
<i>854</i>&nbsp;     * &lt;p&gt;In addition, this method checks the component in the given context
<b class="nc"><i>855</i>&nbsp;     * for a client property called &quot;Nimbus.State&quot;. If one exists, then it will</b>
<b class="nc"><i>856</i>&nbsp;     * decompose the String associated with that property to determine what</b>
<b class="nc"><i>857</i>&nbsp;     * state to return. In this way, the developer can force a component to be</b>
<i>858</i>&nbsp;     * in a specific state, regardless of what the &quot;real&quot; state of the component
<i>859</i>&nbsp;     * is.&lt;/p&gt;
<i>860</i>&nbsp;     *
<i>861</i>&nbsp;     * &lt;p&gt;The string associated with &quot;Nimbus.State&quot; would be of the form:
<b class="nc"><i>862</i>&nbsp;     * &lt;pre&gt;Enabled+CustomState+MouseOver&lt;/pre&gt;&lt;/p&gt;</b>
<b class="nc"><i>863</i>&nbsp;     *</b>
<b class="nc"><i>864</i>&nbsp;     * @param ctx</b>
<b class="nc"><i>865</i>&nbsp;     * @param v</b>
<b class="nc"><i>866</i>&nbsp;     * @return</b>
<i>867</i>&nbsp;     */
<b class="nc"><i>868</i>&nbsp;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})</b>
<b class="nc"><i>869</i>&nbsp;    private int getExtendedState(SynthContext ctx, Values v) {</b>
<b class="nc"><i>870</i>&nbsp;        JComponent c = ctx.getComponent();</b>
<i>871</i>&nbsp;        int xstate = 0;
<i>872</i>&nbsp;        int mask = 1;
<i>873</i>&nbsp;        //check for the Nimbus.State client property
<b class="nc"><i>874</i>&nbsp;        //Performance NOTE: getClientProperty ends up inside a synchronized</b>
<b class="nc"><i>875</i>&nbsp;        //block, so there is some potential for performance issues here, however</b>
<b class="nc"><i>876</i>&nbsp;        //I&#39;m not certain that there is one on a modern VM.</b>
<i>877</i>&nbsp;        Object property = c.getClientProperty(&quot;Nimbus.State&quot;);
<b class="nc"><i>878</i>&nbsp;        if (property != null) {</b>
<i>879</i>&nbsp;            String stateNames = property.toString();
<i>880</i>&nbsp;            String[] states = stateNames.split(&quot;\\+&quot;);
<b class="nc"><i>881</i>&nbsp;            if (v.stateTypes == null){</b>
<i>882</i>&nbsp;                // standard states only
<i>883</i>&nbsp;                for (String stateStr : states) {
<b class="nc"><i>884</i>&nbsp;                    State.StandardState s = State.getStandardState(stateStr);</b>
<i>885</i>&nbsp;                    if (s != null) xstate |= s.getState();
<i>886</i>&nbsp;                }
<i>887</i>&nbsp;            } else {
<b class="nc"><i>888</i>&nbsp;                // custom states</b>
<b class="nc"><i>889</i>&nbsp;                for (State&lt;?&gt; s : v.stateTypes) {</b>
<b class="nc"><i>890</i>&nbsp;                    if (contains(states, s.getName())) {</b>
<b class="nc"><i>891</i>&nbsp;                        xstate |= mask;</b>
<i>892</i>&nbsp;                    }
<b class="nc"><i>893</i>&nbsp;                    mask &lt;&lt;= 1;</b>
<i>894</i>&nbsp;                }
<i>895</i>&nbsp;            }
<b class="nc"><i>896</i>&nbsp;        } else {</b>
<i>897</i>&nbsp;            //if there are no custom states defined, then simply return the
<i>898</i>&nbsp;            //state that Synth reported
<i>899</i>&nbsp;            if (v.stateTypes == null) return ctx.getComponentState();
<i>900</i>&nbsp;
<i>901</i>&nbsp;            //there are custom states on this values, so I&#39;ll have to iterate
<i>902</i>&nbsp;            //over them all and return a custom extended state
<i>903</i>&nbsp;            int state = ctx.getComponentState();
<i>904</i>&nbsp;            for (State s : v.stateTypes) {
<i>905</i>&nbsp;                if (s.isInState(c, state)) {
<i>906</i>&nbsp;                    xstate |= mask;
<i>907</i>&nbsp;                }
<i>908</i>&nbsp;                mask &lt;&lt;= 1;
<i>909</i>&nbsp;            }
<i>910</i>&nbsp;        }
<i>911</i>&nbsp;        return xstate;
<i>912</i>&nbsp;    }
<i>913</i>&nbsp;
<i>914</i>&nbsp;    /**
<i>915</i>&nbsp;     * &lt;p&gt;Gets the RuntimeState that most closely matches the state in the given
<i>916</i>&nbsp;     * context, but is less specific than the given &quot;lastState&quot;. Essentially,
<i>917</i>&nbsp;     * this allows you to search for the next best state.&lt;/p&gt;
<i>918</i>&nbsp;     *
<i>919</i>&nbsp;     * &lt;p&gt;For example, if you had the following three states:
<i>920</i>&nbsp;     * &lt;pre&gt;
<i>921</i>&nbsp;     * Enabled
<i>922</i>&nbsp;     * Enabled+Pressed
<i>923</i>&nbsp;     * Disabled
<i>924</i>&nbsp;     * &lt;/pre&gt;
<i>925</i>&nbsp;     * And you wanted to find the state that best represented
<i>926</i>&nbsp;     * ENABLED+PRESSED+FOCUSED and &lt;code&gt;lastState&lt;/code&gt; was null (or an
<i>927</i>&nbsp;     * empty array, or an array with a single int with index == -1), then
<i>928</i>&nbsp;     * Enabled+Pressed would be returned. If you then call this method again but
<i>929</i>&nbsp;     * pass the index of Enabled+Pressed as the &quot;lastState&quot;, then
<i>930</i>&nbsp;     * Enabled would be returned. If you call this method a third time and pass
<i>931</i>&nbsp;     * the index of Enabled in as the &lt;code&gt;lastState&lt;/code&gt;, then null would be
<i>932</i>&nbsp;     * returned.&lt;/p&gt;
<i>933</i>&nbsp;     *
<i>934</i>&nbsp;     * &lt;p&gt;The actual code path for determining the proper state is the same as
<i>935</i>&nbsp;     * in Synth.&lt;/p&gt;
<i>936</i>&nbsp;     *
<i>937</i>&nbsp;     * @param lastState a 1 element array, allowing me to do pass-by-reference.
<i>938</i>&nbsp;     */
<i>939</i>&nbsp;    private RuntimeState getNextState(RuntimeState[] states,
<i>940</i>&nbsp;                                      int[] lastState,
<i>941</i>&nbsp;                                      int xstate) {
<i>942</i>&nbsp;        // Use the StateInfo with the most bits that matches that of state.
<i>943</i>&nbsp;        // If there are none, then fallback to
<b class="nc"><i>944</i>&nbsp;        // the StateInfo with a state of 0, indicating it&#39;ll match anything.</b>
<b class="nc"><i>945</i>&nbsp;</b>
<b class="nc"><i>946</i>&nbsp;        // Consider if we have 3 StateInfos a, b and c with states:</b>
<b class="nc"><i>947</i>&nbsp;        // SELECTED, SELECTED | ENABLED, 0</b>
<i>948</i>&nbsp;        //
<i>949</i>&nbsp;        // Input                          Return Value
<i>950</i>&nbsp;        // -----                          ------------
<b class="nc"><i>951</i>&nbsp;        // SELECTED                       a</b>
<b class="nc"><i>952</i>&nbsp;        // SELECTED | ENABLED             b</b>
<b class="nc"><i>953</i>&nbsp;        // MOUSE_OVER                     c</b>
<b class="nc"><i>954</i>&nbsp;        // SELECTED | ENABLED | FOCUSED   b</b>
<b class="nc"><i>955</i>&nbsp;        // ENABLED                        c</b>
<i>956</i>&nbsp;
<i>957</i>&nbsp;        if (states != null &amp;&amp; states.length &gt; 0) {
<i>958</i>&nbsp;            int bestCount = 0;
<b class="nc"><i>959</i>&nbsp;            int bestIndex = -1;</b>
<b class="nc"><i>960</i>&nbsp;            int wildIndex = -1;</b>
<i>961</i>&nbsp;
<i>962</i>&nbsp;            //if xstate is 0, then search for the runtime state with component
<i>963</i>&nbsp;            //state of 0. That is, find the exact match and return it.
<i>964</i>&nbsp;            if (xstate == 0) {
<i>965</i>&nbsp;                for (int counter = states.length - 1; counter &gt;= 0; counter--) {
<i>966</i>&nbsp;                    if (states[counter].state == 0) {
<i>967</i>&nbsp;                        lastState[0] = counter;
<b class="nc"><i>968</i>&nbsp;                        return states[counter];</b>
<i>969</i>&nbsp;                    }
<i>970</i>&nbsp;                }
<b class="nc"><i>971</i>&nbsp;                //an exact match couldn&#39;t be found, so there was no match.</b>
<b class="nc"><i>972</i>&nbsp;                lastState[0] = -1;</b>
<i>973</i>&nbsp;                return null;
<b class="nc"><i>974</i>&nbsp;            }</b>
<b class="nc"><i>975</i>&nbsp;</b>
<b class="nc"><i>976</i>&nbsp;            //xstate is some value != 0</b>
<i>977</i>&nbsp;
<b class="nc"><i>978</i>&nbsp;            //determine from which index to start looking. If lastState[0] is -1</b>
<i>979</i>&nbsp;            //then we know to start from the end of the state array. Otherwise,
<i>980</i>&nbsp;            //we start at the lastIndex - 1.
<i>981</i>&nbsp;            int lastStateIndex = lastState == null || lastState[0] == -1 ?
<i>982</i>&nbsp;                states.length : lastState[0];
<i>983</i>&nbsp;
<i>984</i>&nbsp;            for (int counter = lastStateIndex - 1; counter &gt;= 0; counter--) {
<b class="nc"><i>985</i>&nbsp;                int oState = states[counter].state;</b>
<b class="nc"><i>986</i>&nbsp;</b>
<b class="nc"><i>987</i>&nbsp;                if (oState == 0) {</b>
<i>988</i>&nbsp;                    if (wildIndex == -1) {
<b class="nc"><i>989</i>&nbsp;                        wildIndex = counter;</b>
<b class="nc"><i>990</i>&nbsp;                    }</b>
<b class="nc"><i>991</i>&nbsp;                } else if ((xstate &amp; oState) == oState) {</b>
<b class="nc"><i>992</i>&nbsp;                    // This is key, we need to make sure all bits of the</b>
<b class="nc"><i>993</i>&nbsp;                    // StateInfo match, otherwise a StateInfo with</b>
<b class="nc"><i>994</i>&nbsp;                    // SELECTED | ENABLED would match ENABLED, which we</b>
<b class="nc"><i>995</i>&nbsp;                    // don&#39;t want.</b>
<i>996</i>&nbsp;                    int bitCount = Integer.bitCount(oState);
<i>997</i>&nbsp;                    if (bitCount &gt; bestCount) {
<i>998</i>&nbsp;                        bestIndex = counter;
<b class="nc"><i>999</i>&nbsp;                        bestCount = bitCount;</b>
<b class="nc"><i>1000</i>&nbsp;                    }</b>
<b class="nc"><i>1001</i>&nbsp;                }</b>
<i>1002</i>&nbsp;            }
<b class="nc"><i>1003</i>&nbsp;            if (bestIndex != -1) {</b>
<b class="nc"><i>1004</i>&nbsp;                lastState[0] = bestIndex;</b>
<b class="nc"><i>1005</i>&nbsp;                return states[bestIndex];</b>
<i>1006</i>&nbsp;            }
<i>1007</i>&nbsp;            if (wildIndex != -1) {
<b class="nc"><i>1008</i>&nbsp;                lastState[0] = wildIndex;</b>
<b class="nc"><i>1009</i>&nbsp;                return states[wildIndex];</b>
<i>1010</i>&nbsp;            }
<i>1011</i>&nbsp;        }
<i>1012</i>&nbsp;        lastState[0] = -1;
<i>1013</i>&nbsp;        return null;
<i>1014</i>&nbsp;    }
<i>1015</i>&nbsp;
<i>1016</i>&nbsp;    /**
<i>1017</i>&nbsp;     * Contains values such as the UIDefaults and painters associated with
<i>1018</i>&nbsp;     * a state. Whereas &lt;code&gt;State&lt;/code&gt; represents a distinct state that a
<b class="nc"><i>1019</i>&nbsp;     * component can be in (such as Enabled), this class represents the colors,</b>
<i>1020</i>&nbsp;     * fonts, painters, etc associated with some state for this
<i>1021</i>&nbsp;     * style.
<i>1022</i>&nbsp;     */
<i>1023</i>&nbsp;    private final class RuntimeState implements Cloneable {
<i>1024</i>&nbsp;        int state;
<b class="nc"><i>1025</i>&nbsp;        Painter&lt;Object&gt; backgroundPainter;</b>
<i>1026</i>&nbsp;        Painter&lt;Object&gt; foregroundPainter;
<b class="nc"><i>1027</i>&nbsp;        Painter&lt;Object&gt; borderPainter;</b>
<b class="nc"><i>1028</i>&nbsp;        String stateName;</b>
<b class="nc"><i>1029</i>&nbsp;        UIDefaults defaults = new UIDefaults(10, .7f);</b>
<i>1030</i>&nbsp;
<i>1031</i>&nbsp;        private RuntimeState(int state, String stateName) {
<i>1032</i>&nbsp;            this.state = state;
<i>1033</i>&nbsp;            this.stateName = stateName;
<b class="nc"><i>1034</i>&nbsp;        }</b>
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;        @Override
<i>1037</i>&nbsp;        public String toString() {
<i>1038</i>&nbsp;            return stateName;
<b class="nc"><i>1039</i>&nbsp;        }</b>
<b class="nc"><i>1040</i>&nbsp;</b>
<b class="nc"><i>1041</i>&nbsp;        @Override</b>
<b class="nc"><i>1042</i>&nbsp;        public RuntimeState clone() {</b>
<b class="nc"><i>1043</i>&nbsp;            RuntimeState clone = new RuntimeState(state, stateName);</b>
<b class="nc"><i>1044</i>&nbsp;            clone.backgroundPainter = backgroundPainter;</b>
<i>1045</i>&nbsp;            clone.foregroundPainter = foregroundPainter;
<i>1046</i>&nbsp;            clone.borderPainter = borderPainter;
<i>1047</i>&nbsp;            clone.defaults.putAll(defaults);
<i>1048</i>&nbsp;            return clone;
<i>1049</i>&nbsp;        }
<i>1050</i>&nbsp;    }
<i>1051</i>&nbsp;
<i>1052</i>&nbsp;    /**
<b class="nc"><i>1053</i>&nbsp;     * Essentially a struct of data for a style. A default instance of this</b>
<i>1054</i>&nbsp;     * class is used by NimbusStyle. Additional instances exist for each
<i>1055</i>&nbsp;     * component that has overrides.
<i>1056</i>&nbsp;     */
<i>1057</i>&nbsp;    private static final class Values {
<b class="nc"><i>1058</i>&nbsp;        /**</b>
<i>1059</i>&nbsp;         * The list of State types. A State represents a type of state, such
<i>1060</i>&nbsp;         * as Enabled, Default, WindowFocused, etc. These can be custom states.
<i>1061</i>&nbsp;         */
<i>1062</i>&nbsp;        State&lt;?&gt;[] stateTypes = null;
<i>1063</i>&nbsp;        /**
<b class="nc"><i>1064</i>&nbsp;         * The list of actual runtime state representations. These can represent things such</b>
<i>1065</i>&nbsp;         * as Enabled + Focused. Thus, they differ from States in that they contain
<i>1066</i>&nbsp;         * several states together, and have associated properties, data, etc.
<i>1067</i>&nbsp;         */
<i>1068</i>&nbsp;        RuntimeState[] states = null;
<i>1069</i>&nbsp;        /**
<i>1070</i>&nbsp;         * The content margins for this region.
<i>1071</i>&nbsp;         */
<b class="nc"><i>1072</i>&nbsp;        Insets contentMargins;</b>
<i>1073</i>&nbsp;        /**
<i>1074</i>&nbsp;         * Defaults on the region/component level.
<i>1075</i>&nbsp;         */
<i>1076</i>&nbsp;        UIDefaults defaults = new UIDefaults(10, .7f);
<i>1077</i>&nbsp;        /**
<i>1078</i>&nbsp;         * Simple cache. After a value has been looked up, it is stored
<i>1079</i>&nbsp;         * in this cache for later retrieval. The key is a concatenation of
<i>1080</i>&nbsp;         * the property being looked up, two dollar signs, and the extended
<b class="nc"><i>1081</i>&nbsp;         * state. So for example:</b>
<i>1082</i>&nbsp;         *
<i>1083</i>&nbsp;         * foo.bar$$2353
<i>1084</i>&nbsp;         */
<i>1085</i>&nbsp;        Map&lt;CacheKey,Object&gt; cache = new HashMap&lt;CacheKey,Object&gt;();
<i>1086</i>&nbsp;    }
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;    /**
<i>1089</i>&nbsp;     * This implementation presupposes that key is never null and that
<i>1090</i>&nbsp;     * the two keys being checked for equality are never null
<i>1091</i>&nbsp;     */
<b class="nc"><i>1092</i>&nbsp;    private static final class CacheKey {</b>
<b class="nc"><i>1093</i>&nbsp;        private String key;</b>
<i>1094</i>&nbsp;        private int xstate;
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;        CacheKey(Object key, int xstate) {
<b class="nc"><i>1097</i>&nbsp;            init(key, xstate);</b>
<b class="nc"><i>1098</i>&nbsp;        }</b>
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;        void init(Object key, int xstate) {
<i>1101</i>&nbsp;            this.key = key.toString();
<i>1102</i>&nbsp;            this.xstate = xstate;
<b class="nc"><i>1103</i>&nbsp;        }</b>
<b class="nc"><i>1104</i>&nbsp;</b>
<b class="nc"><i>1105</i>&nbsp;        @Override</b>
<b class="nc"><i>1106</i>&nbsp;        public boolean equals(Object obj) {</b>
<b class="nc"><i>1107</i>&nbsp;            final CacheKey other = (CacheKey) obj;</b>
<i>1108</i>&nbsp;            if (obj == null) return false;
<i>1109</i>&nbsp;            if (this.xstate != other.xstate) return false;
<i>1110</i>&nbsp;            if (!this.key.equals(other.key)) return false;
<i>1111</i>&nbsp;            return true;
<b class="nc"><i>1112</i>&nbsp;        }</b>
<b class="nc"><i>1113</i>&nbsp;</b>
<b class="nc"><i>1114</i>&nbsp;        @Override</b>
<b class="nc"><i>1115</i>&nbsp;        public int hashCode() {</b>
<i>1116</i>&nbsp;            int hash = 3;
<i>1117</i>&nbsp;            hash = 29 * hash + this.key.hashCode();
<i>1118</i>&nbsp;            hash = 29 * hash + this.xstate;
<i>1119</i>&nbsp;            return hash;
<i>1120</i>&nbsp;        }
<i>1121</i>&nbsp;    }
<i>1122</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:16</div>
</div>
</body>
</html>
