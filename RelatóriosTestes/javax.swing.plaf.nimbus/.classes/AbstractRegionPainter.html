


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: AbstractRegionPainter</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.plaf.nimbus</a> ]
</div>

<h1>Coverage Summary for Class: AbstractRegionPainter (javax.swing.plaf.nimbus)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AbstractRegionPainter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 175)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AbstractRegionPainter$PaintContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AbstractRegionPainter$PaintContext$CacheMode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 203)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.plaf.nimbus;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.awt.*;
<i>28</i>&nbsp;import java.awt.image.*;
<i>29</i>&nbsp;import java.lang.reflect.Method;
<i>30</i>&nbsp;import javax.swing.*;
<i>31</i>&nbsp;import javax.swing.plaf.UIResource;
<i>32</i>&nbsp;import javax.swing.Painter;
<i>33</i>&nbsp;import java.awt.print.PrinterGraphics;
<i>34</i>&nbsp;import sun.reflect.misc.MethodUtil;
<i>35</i>&nbsp;
<i>36</i>&nbsp;/**
<i>37</i>&nbsp; * Convenient base class for defining Painter instances for rendering a
<i>38</i>&nbsp; * region or component in Nimbus.
<i>39</i>&nbsp; *
<i>40</i>&nbsp; * @author Jasper Potts
<i>41</i>&nbsp; * @author Richard Bair
<i>42</i>&nbsp; */
<i>43</i>&nbsp;public abstract class AbstractRegionPainter implements Painter&lt;JComponent&gt; {
<i>44</i>&nbsp;    /**
<i>45</i>&nbsp;     * PaintContext, which holds a lot of the state needed for cache hinting and x/y value decoding
<i>46</i>&nbsp;     * The data contained within the context is typically only computed once and reused over
<i>47</i>&nbsp;     * multiple paint calls, whereas the other values (w, h, f, leftWidth, etc) are recomputed
<i>48</i>&nbsp;     * for each call to paint.
<i>49</i>&nbsp;     *
<i>50</i>&nbsp;     * This field is retrieved from subclasses on each paint operation. It is up
<i>51</i>&nbsp;     * to the subclass to compute and cache the PaintContext over multiple calls.
<i>52</i>&nbsp;     */
<i>53</i>&nbsp;    private PaintContext ctx;
<i>54</i>&nbsp;    /**
<i>55</i>&nbsp;     * The scaling factor. Recomputed on each call to paint.
<i>56</i>&nbsp;     */
<i>57</i>&nbsp;    private float f;
<i>58</i>&nbsp;    /*
<i>59</i>&nbsp;      Various metrics used for decoding x/y values based on the canvas size
<i>60</i>&nbsp;      and stretching insets.
<i>61</i>&nbsp;
<i>62</i>&nbsp;      On each call to paint, we first ask the subclass for the PaintContext.
<i>63</i>&nbsp;      From the context we get the canvas size and stretching insets, and whether
<i>64</i>&nbsp;      the algorithm should be &quot;inverted&quot;, meaning the center section remains
<i>65</i>&nbsp;      a fixed size and the other sections scale.
<i>66</i>&nbsp;
<i>67</i>&nbsp;      We then use these values to compute a series of metrics (listed below)
<i>68</i>&nbsp;      which are used to decode points in a specific axis (x or y).
<i>69</i>&nbsp;
<i>70</i>&nbsp;      The leftWidth represents the distance from the left edge of the region
<i>71</i>&nbsp;      to the first stretching inset, after accounting for any scaling factor
<i>72</i>&nbsp;      (such as DPI scaling). The centerWidth is the distance between the leftWidth
<i>73</i>&nbsp;      and the rightWidth. The rightWidth is the distance from the right edge,
<i>74</i>&nbsp;      to the right inset (after scaling has been applied).
<i>75</i>&nbsp;
<i>76</i>&nbsp;      The same logic goes for topHeight, centerHeight, and bottomHeight.
<i>77</i>&nbsp;
<i>78</i>&nbsp;      The leftScale represents the proportion of the width taken by the left section.
<i>79</i>&nbsp;      The same logic is applied to the other scales.
<i>80</i>&nbsp;
<i>81</i>&nbsp;      The various widths/heights are used to decode control points. The
<i>82</i>&nbsp;      various scales are used to decode bezier handles (or anchors).
<i>83</i>&nbsp;    */
<i>84</i>&nbsp;    /**
<i>85</i>&nbsp;     * The width of the left section. Recomputed on each call to paint.
<i>86</i>&nbsp;     */
<i>87</i>&nbsp;    private float leftWidth;
<i>88</i>&nbsp;    /**
<i>89</i>&nbsp;     * The height of the top section. Recomputed on each call to paint.
<i>90</i>&nbsp;     */
<i>91</i>&nbsp;    private float topHeight;
<i>92</i>&nbsp;    /**
<i>93</i>&nbsp;     * The width of the center section. Recomputed on each call to paint.
<i>94</i>&nbsp;     */
<i>95</i>&nbsp;    private float centerWidth;
<i>96</i>&nbsp;    /**
<i>97</i>&nbsp;     * The height of the center section. Recomputed on each call to paint.
<i>98</i>&nbsp;     */
<i>99</i>&nbsp;    private float centerHeight;
<i>100</i>&nbsp;    /**
<i>101</i>&nbsp;     * The width of the right section. Recomputed on each call to paint.
<i>102</i>&nbsp;     */
<i>103</i>&nbsp;    private float rightWidth;
<i>104</i>&nbsp;    /**
<i>105</i>&nbsp;     * The height of the bottom section. Recomputed on each call to paint.
<i>106</i>&nbsp;     */
<i>107</i>&nbsp;    private float bottomHeight;
<i>108</i>&nbsp;    /**
<i>109</i>&nbsp;     * The scaling factor to use for the left section. Recomputed on each call to paint.
<i>110</i>&nbsp;     */
<i>111</i>&nbsp;    private float leftScale;
<i>112</i>&nbsp;    /**
<i>113</i>&nbsp;     * The scaling factor to use for the top section. Recomputed on each call to paint.
<i>114</i>&nbsp;     */
<i>115</i>&nbsp;    private float topScale;
<i>116</i>&nbsp;    /**
<i>117</i>&nbsp;     * The scaling factor to use for the center section, in the horizontal
<i>118</i>&nbsp;     * direction. Recomputed on each call to paint.
<i>119</i>&nbsp;     */
<i>120</i>&nbsp;    private float centerHScale;
<i>121</i>&nbsp;    /**
<i>122</i>&nbsp;     * The scaling factor to use for the center section, in the vertical
<i>123</i>&nbsp;     * direction. Recomputed on each call to paint.
<i>124</i>&nbsp;     */
<i>125</i>&nbsp;    private float centerVScale;
<i>126</i>&nbsp;    /**
<i>127</i>&nbsp;     * The scaling factor to use for the right section. Recomputed on each call to paint.
<i>128</i>&nbsp;     */
<i>129</i>&nbsp;    private float rightScale;
<i>130</i>&nbsp;    /**
<i>131</i>&nbsp;     * The scaling factor to use for the bottom section. Recomputed on each call to paint.
<i>132</i>&nbsp;     */
<i>133</i>&nbsp;    private float bottomScale;
<i>134</i>&nbsp;
<i>135</i>&nbsp;    /**
<i>136</i>&nbsp;     * Create a new AbstractRegionPainter
<i>137</i>&nbsp;     */
<b class="nc"><i>138</i>&nbsp;    protected AbstractRegionPainter() { }</b>
<i>139</i>&nbsp;
<i>140</i>&nbsp;    /**
<i>141</i>&nbsp;     * {@inheritDoc}
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    @Override
<i>144</i>&nbsp;    public final void paint(Graphics2D g, JComponent c, int w, int h) {
<i>145</i>&nbsp;        //don&#39;t render if the width/height are too small
<b class="nc"><i>146</i>&nbsp;        if (w &lt;= 0 || h &lt;=0) return;</b>
<i>147</i>&nbsp;
<b class="nc"><i>148</i>&nbsp;        Object[] extendedCacheKeys = getExtendedCacheKeys(c);</b>
<b class="nc"><i>149</i>&nbsp;        ctx = getPaintContext();</b>
<b class="nc"><i>150</i>&nbsp;        PaintContext.CacheMode cacheMode = ctx == null ? PaintContext.CacheMode.NO_CACHING : ctx.cacheMode;</b>
<b class="nc"><i>151</i>&nbsp;        if (cacheMode == PaintContext.CacheMode.NO_CACHING ||</b>
<b class="nc"><i>152</i>&nbsp;                !ImageCache.getInstance().isImageCachable(w, h) ||</b>
<i>153</i>&nbsp;                g instanceof PrinterGraphics) {
<i>154</i>&nbsp;            // no caching so paint directly
<b class="nc"><i>155</i>&nbsp;            paint0(g, c, w, h, extendedCacheKeys);</b>
<b class="nc"><i>156</i>&nbsp;        } else if (cacheMode == PaintContext.CacheMode.FIXED_SIZES) {</b>
<b class="nc"><i>157</i>&nbsp;            paintWithFixedSizeCaching(g, c, w, h, extendedCacheKeys);</b>
<i>158</i>&nbsp;        } else {
<i>159</i>&nbsp;            // 9 Square caching
<b class="nc"><i>160</i>&nbsp;            paintWith9SquareCaching(g, ctx, c, w, h, extendedCacheKeys);</b>
<i>161</i>&nbsp;        }
<i>162</i>&nbsp;    }
<i>163</i>&nbsp;
<i>164</i>&nbsp;    /**
<i>165</i>&nbsp;     * Get any extra attributes which the painter implementation would like
<i>166</i>&nbsp;     * to include in the image cache lookups. This is checked for every call
<i>167</i>&nbsp;     * of the paint(g, c, w, h) method.
<i>168</i>&nbsp;     *
<i>169</i>&nbsp;     * @param c The component on the current paint call
<i>170</i>&nbsp;     * @return Array of extra objects to be included in the cache key
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    protected Object[] getExtendedCacheKeys(JComponent c) {
<b class="nc"><i>173</i>&nbsp;        return null;</b>
<i>174</i>&nbsp;    }
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /**
<i>177</i>&nbsp;     * &lt;p&gt;Gets the PaintContext for this painting operation. This method is called on every
<i>178</i>&nbsp;     * paint, and so should be fast and produce no garbage. The PaintContext contains
<i>179</i>&nbsp;     * information such as cache hints. It also contains data necessary for decoding
<i>180</i>&nbsp;     * points at runtime, such as the stretching insets, the canvas size at which the
<i>181</i>&nbsp;     * encoded points were defined, and whether the stretching insets are inverted.&lt;/p&gt;
<i>182</i>&nbsp;     *
<i>183</i>&nbsp;     * &lt;p&gt; This method allows for subclasses to package the painting of different states
<i>184</i>&nbsp;     * with possibly different canvas sizes, etc, into one AbstractRegionPainter implementation.&lt;/p&gt;
<i>185</i>&nbsp;     *
<i>186</i>&nbsp;     * @return a PaintContext associated with this paint operation.
<i>187</i>&nbsp;     */
<i>188</i>&nbsp;    protected abstract PaintContext getPaintContext();
<i>189</i>&nbsp;
<i>190</i>&nbsp;    /**
<i>191</i>&nbsp;     * &lt;p&gt;Configures the given Graphics2D. Often, rendering hints or compositing rules are
<i>192</i>&nbsp;     * applied to a Graphics2D object prior to painting, which should affect all of the
<i>193</i>&nbsp;     * subsequent painting operations. This method provides a convenient hook for configuring
<i>194</i>&nbsp;     * the Graphics object prior to rendering, regardless of whether the render operation is
<i>195</i>&nbsp;     * performed to an intermediate buffer or directly to the display.&lt;/p&gt;
<i>196</i>&nbsp;     *
<i>197</i>&nbsp;     * @param g The Graphics2D object to configure. Will not be null.
<i>198</i>&nbsp;     */
<i>199</i>&nbsp;    protected void configureGraphics(Graphics2D g) {
<b class="nc"><i>200</i>&nbsp;        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</b>
<i>201</i>&nbsp;    }
<i>202</i>&nbsp;
<i>203</i>&nbsp;    /**
<i>204</i>&nbsp;     * Actually performs the painting operation. Subclasses must implement this method.
<i>205</i>&nbsp;     * The graphics object passed may represent the actual surface being rendered to,
<i>206</i>&nbsp;     * or it may be an intermediate buffer. It has also been pre-translated. Simply render
<i>207</i>&nbsp;     * the component as if it were located at 0, 0 and had a width of &lt;code&gt;width&lt;/code&gt;
<i>208</i>&nbsp;     * and a height of &lt;code&gt;height&lt;/code&gt;. For performance reasons, you may want to read
<i>209</i>&nbsp;     * the clip from the Graphics2D object and only render within that space.
<i>210</i>&nbsp;     *
<i>211</i>&nbsp;     * @param g The Graphics2D surface to paint to
<i>212</i>&nbsp;     * @param c The JComponent related to the drawing event. For example, if the
<i>213</i>&nbsp;     *          region being rendered is Button, then &lt;code&gt;c&lt;/code&gt; will be a
<i>214</i>&nbsp;     *          JButton. If the region being drawn is ScrollBarSlider, then the
<i>215</i>&nbsp;     *          component will be JScrollBar. This value may be null.
<i>216</i>&nbsp;     * @param width The width of the region to paint. Note that in the case of
<i>217</i>&nbsp;     *              painting the foreground, this value may differ from c.getWidth().
<i>218</i>&nbsp;     * @param height The height of the region to paint. Note that in the case of
<i>219</i>&nbsp;     *               painting the foreground, this value may differ from c.getHeight().
<i>220</i>&nbsp;     * @param extendedCacheKeys The result of the call to getExtendedCacheKeys()
<i>221</i>&nbsp;     */
<i>222</i>&nbsp;    protected abstract void doPaint(Graphics2D g, JComponent c, int width,
<i>223</i>&nbsp;                                    int height, Object[] extendedCacheKeys);
<i>224</i>&nbsp;
<i>225</i>&nbsp;    /**
<i>226</i>&nbsp;     * Decodes and returns a float value representing the actual pixel location for
<i>227</i>&nbsp;     * the given encoded X value.
<i>228</i>&nbsp;     *
<i>229</i>&nbsp;     * @param x an encoded x value (0...1, or 1...2, or 2...3)
<i>230</i>&nbsp;     * @return the decoded x value
<i>231</i>&nbsp;     * @throws IllegalArgumentException
<i>232</i>&nbsp;     *      if {@code x &lt; 0} or {@code x &gt; 3}
<i>233</i>&nbsp;     */
<i>234</i>&nbsp;    protected final float decodeX(float x) {
<b class="nc"><i>235</i>&nbsp;        if (x &gt;= 0 &amp;&amp; x &lt;= 1) {</b>
<b class="nc"><i>236</i>&nbsp;            return x * leftWidth;</b>
<b class="nc"><i>237</i>&nbsp;        } else if (x &gt; 1 &amp;&amp; x &lt; 2) {</b>
<b class="nc"><i>238</i>&nbsp;            return ((x-1) * centerWidth) + leftWidth;</b>
<b class="nc"><i>239</i>&nbsp;        } else if (x &gt;= 2 &amp;&amp; x &lt;= 3) {</b>
<b class="nc"><i>240</i>&nbsp;            return ((x-2) * rightWidth) + leftWidth + centerWidth;</b>
<i>241</i>&nbsp;        } else {
<b class="nc"><i>242</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid x&quot;);</b>
<i>243</i>&nbsp;        }
<i>244</i>&nbsp;    }
<i>245</i>&nbsp;
<i>246</i>&nbsp;    /**
<i>247</i>&nbsp;     * Decodes and returns a float value representing the actual pixel location for
<i>248</i>&nbsp;     * the given encoded y value.
<i>249</i>&nbsp;     *
<i>250</i>&nbsp;     * @param y an encoded y value (0...1, or 1...2, or 2...3)
<i>251</i>&nbsp;     * @return the decoded y value
<i>252</i>&nbsp;     * @throws IllegalArgumentException
<i>253</i>&nbsp;     *      if {@code y &lt; 0} or {@code y &gt; 3}
<i>254</i>&nbsp;     */
<i>255</i>&nbsp;    protected final float decodeY(float y) {
<b class="nc"><i>256</i>&nbsp;        if (y &gt;= 0 &amp;&amp; y &lt;= 1) {</b>
<b class="nc"><i>257</i>&nbsp;            return y * topHeight;</b>
<b class="nc"><i>258</i>&nbsp;        } else if (y &gt; 1 &amp;&amp; y &lt; 2) {</b>
<b class="nc"><i>259</i>&nbsp;            return ((y-1) * centerHeight) + topHeight;</b>
<b class="nc"><i>260</i>&nbsp;        } else if (y &gt;= 2 &amp;&amp; y &lt;= 3) {</b>
<b class="nc"><i>261</i>&nbsp;            return ((y-2) * bottomHeight) + topHeight + centerHeight;</b>
<i>262</i>&nbsp;        } else {
<b class="nc"><i>263</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid y&quot;);</b>
<i>264</i>&nbsp;        }
<i>265</i>&nbsp;    }
<i>266</i>&nbsp;
<i>267</i>&nbsp;    /**
<i>268</i>&nbsp;     * Decodes and returns a float value representing the actual pixel location for
<i>269</i>&nbsp;     * the anchor point given the encoded X value of the control point, and the offset
<i>270</i>&nbsp;     * distance to the anchor from that control point.
<i>271</i>&nbsp;     *
<i>272</i>&nbsp;     * @param x an encoded x value of the bezier control point (0...1, or 1...2, or 2...3)
<i>273</i>&nbsp;     * @param dx the offset distance to the anchor from the control point x
<i>274</i>&nbsp;     * @return the decoded x location of the control point
<i>275</i>&nbsp;     * @throws IllegalArgumentException
<i>276</i>&nbsp;     *      if {@code x &lt; 0} or {@code x &gt; 3}
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    protected final float decodeAnchorX(float x, float dx) {
<b class="nc"><i>279</i>&nbsp;        if (x &gt;= 0 &amp;&amp; x &lt;= 1) {</b>
<b class="nc"><i>280</i>&nbsp;            return decodeX(x) + (dx * leftScale);</b>
<b class="nc"><i>281</i>&nbsp;        } else if (x &gt; 1 &amp;&amp; x &lt; 2) {</b>
<b class="nc"><i>282</i>&nbsp;            return decodeX(x) + (dx * centerHScale);</b>
<b class="nc"><i>283</i>&nbsp;        } else if (x &gt;= 2 &amp;&amp; x &lt;= 3) {</b>
<b class="nc"><i>284</i>&nbsp;            return decodeX(x) + (dx * rightScale);</b>
<i>285</i>&nbsp;        } else {
<b class="nc"><i>286</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid x&quot;);</b>
<i>287</i>&nbsp;        }
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;    /**
<i>291</i>&nbsp;     * Decodes and returns a float value representing the actual pixel location for
<i>292</i>&nbsp;     * the anchor point given the encoded Y value of the control point, and the offset
<i>293</i>&nbsp;     * distance to the anchor from that control point.
<i>294</i>&nbsp;     *
<i>295</i>&nbsp;     * @param y an encoded y value of the bezier control point (0...1, or 1...2, or 2...3)
<i>296</i>&nbsp;     * @param dy the offset distance to the anchor from the control point y
<i>297</i>&nbsp;     * @return the decoded y position of the control point
<i>298</i>&nbsp;     * @throws IllegalArgumentException
<i>299</i>&nbsp;     *      if {@code y &lt; 0} or {@code y &gt; 3}
<i>300</i>&nbsp;     */
<i>301</i>&nbsp;    protected final float decodeAnchorY(float y, float dy) {
<b class="nc"><i>302</i>&nbsp;        if (y &gt;= 0 &amp;&amp; y &lt;= 1) {</b>
<b class="nc"><i>303</i>&nbsp;            return decodeY(y) + (dy * topScale);</b>
<b class="nc"><i>304</i>&nbsp;        } else if (y &gt; 1 &amp;&amp; y &lt; 2) {</b>
<b class="nc"><i>305</i>&nbsp;            return decodeY(y) + (dy * centerVScale);</b>
<b class="nc"><i>306</i>&nbsp;        } else if (y &gt;= 2 &amp;&amp; y &lt;= 3) {</b>
<b class="nc"><i>307</i>&nbsp;            return decodeY(y) + (dy * bottomScale);</b>
<i>308</i>&nbsp;        } else {
<b class="nc"><i>309</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid y&quot;);</b>
<i>310</i>&nbsp;        }
<i>311</i>&nbsp;    }
<i>312</i>&nbsp;
<i>313</i>&nbsp;    /**
<i>314</i>&nbsp;     * Decodes and returns a color, which is derived from a base color in UI
<i>315</i>&nbsp;     * defaults.
<i>316</i>&nbsp;     *
<i>317</i>&nbsp;     * @param key     A key corresponding to the value in the UI Defaults table
<i>318</i>&nbsp;     *                of UIManager where the base color is defined
<i>319</i>&nbsp;     * @param hOffset The hue offset used for derivation.
<i>320</i>&nbsp;     * @param sOffset The saturation offset used for derivation.
<i>321</i>&nbsp;     * @param bOffset The brightness offset used for derivation.
<i>322</i>&nbsp;     * @param aOffset The alpha offset used for derivation. Between 0...255
<i>323</i>&nbsp;     * @return The derived color, whose color value will change if the parent
<i>324</i>&nbsp;     *         uiDefault color changes.
<i>325</i>&nbsp;     */
<i>326</i>&nbsp;    protected final Color decodeColor(String key, float hOffset, float sOffset,
<i>327</i>&nbsp;                                      float bOffset, int aOffset) {
<b class="nc"><i>328</i>&nbsp;        if (UIManager.getLookAndFeel() instanceof NimbusLookAndFeel){</b>
<b class="nc"><i>329</i>&nbsp;            NimbusLookAndFeel laf = (NimbusLookAndFeel) UIManager.getLookAndFeel();</b>
<b class="nc"><i>330</i>&nbsp;            return laf.getDerivedColor(key, hOffset, sOffset, bOffset, aOffset, true);</b>
<i>331</i>&nbsp;        } else {
<i>332</i>&nbsp;            // can not give a right answer as painter sould not be used outside
<i>333</i>&nbsp;            // of nimbus laf but do the best we can
<b class="nc"><i>334</i>&nbsp;            return Color.getHSBColor(hOffset,sOffset,bOffset);</b>
<i>335</i>&nbsp;        }
<i>336</i>&nbsp;    }
<i>337</i>&nbsp;
<i>338</i>&nbsp;    /**
<i>339</i>&nbsp;     * Decodes and returns a color, which is derived from a offset between two
<i>340</i>&nbsp;     * other colors.
<i>341</i>&nbsp;     *
<i>342</i>&nbsp;     * @param color1   The first color
<i>343</i>&nbsp;     * @param color2   The second color
<i>344</i>&nbsp;     * @param midPoint The offset between color 1 and color 2, a value of 0.0 is
<i>345</i>&nbsp;     *                 color 1 and 1.0 is color 2;
<i>346</i>&nbsp;     * @return The derived color
<i>347</i>&nbsp;     */
<i>348</i>&nbsp;    protected final Color decodeColor(Color color1, Color color2,
<i>349</i>&nbsp;                                      float midPoint) {
<b class="nc"><i>350</i>&nbsp;        return new Color(NimbusLookAndFeel.deriveARGB(color1, color2, midPoint));</b>
<i>351</i>&nbsp;    }
<i>352</i>&nbsp;
<i>353</i>&nbsp;    /**
<i>354</i>&nbsp;     * Given parameters for creating a LinearGradientPaint, this method will
<i>355</i>&nbsp;     * create and return a linear gradient paint. One primary purpose for this
<i>356</i>&nbsp;     * method is to avoid creating a LinearGradientPaint where the start and
<i>357</i>&nbsp;     * end points are equal. In such a case, the end y point is slightly
<i>358</i>&nbsp;     * increased to avoid the overlap.
<i>359</i>&nbsp;     *
<i>360</i>&nbsp;     * @param x1 x1
<i>361</i>&nbsp;     * @param y1 y1
<i>362</i>&nbsp;     * @param x2 x2
<i>363</i>&nbsp;     * @param y2 y2
<i>364</i>&nbsp;     * @param midpoints the midpoints
<i>365</i>&nbsp;     * @param colors the colors
<i>366</i>&nbsp;     * @return a valid LinearGradientPaint. This method never returns null.
<i>367</i>&nbsp;     * @throws NullPointerException
<i>368</i>&nbsp;     *      if {@code midpoints} array is null,
<i>369</i>&nbsp;     *      or {@code colors} array is null,
<i>370</i>&nbsp;     * @throws IllegalArgumentException
<i>371</i>&nbsp;     *      if start and end points are the same points,
<i>372</i>&nbsp;     *      or {@code midpoints.length != colors.length},
<i>373</i>&nbsp;     *      or {@code colors} is less than 2 in size,
<i>374</i>&nbsp;     *      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
<i>375</i>&nbsp;     *      or the {@code midpoints} are not provided in strictly increasing order
<i>376</i>&nbsp;     */
<i>377</i>&nbsp;    protected final LinearGradientPaint decodeGradient(float x1, float y1, float x2, float y2, float[] midpoints, Color[] colors) {
<b class="nc"><i>378</i>&nbsp;        if (x1 == x2 &amp;&amp; y1 == y2) {</b>
<b class="nc"><i>379</i>&nbsp;            y2 += .00001f;</b>
<i>380</i>&nbsp;        }
<b class="nc"><i>381</i>&nbsp;        return new LinearGradientPaint(x1, y1, x2, y2, midpoints, colors);</b>
<i>382</i>&nbsp;    }
<i>383</i>&nbsp;
<i>384</i>&nbsp;    /**
<i>385</i>&nbsp;     * Given parameters for creating a RadialGradientPaint, this method will
<i>386</i>&nbsp;     * create and return a radial gradient paint. One primary purpose for this
<i>387</i>&nbsp;     * method is to avoid creating a RadialGradientPaint where the radius
<i>388</i>&nbsp;     * is non-positive. In such a case, the radius is just slightly
<i>389</i>&nbsp;     * increased to avoid 0.
<i>390</i>&nbsp;     *
<i>391</i>&nbsp;     * @param x x-coordinate
<i>392</i>&nbsp;     * @param y y-coordinate
<i>393</i>&nbsp;     * @param r radius
<i>394</i>&nbsp;     * @param midpoints the midpoints
<i>395</i>&nbsp;     * @param colors the colors
<i>396</i>&nbsp;     * @return a valid RadialGradientPaint. This method never returns null.
<i>397</i>&nbsp;     * @throws NullPointerException
<i>398</i>&nbsp;     *      if {@code midpoints} array is null,
<i>399</i>&nbsp;     *      or {@code colors} array is null
<i>400</i>&nbsp;     * @throws IllegalArgumentException
<i>401</i>&nbsp;     *      if {@code r} is non-positive,
<i>402</i>&nbsp;     *      or {@code midpoints.length != colors.length},
<i>403</i>&nbsp;     *      or {@code colors} is less than 2 in size,
<i>404</i>&nbsp;     *      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
<i>405</i>&nbsp;     *      or the {@code midpoints} are not provided in strictly increasing order
<i>406</i>&nbsp;     */
<i>407</i>&nbsp;    protected final RadialGradientPaint decodeRadialGradient(float x, float y, float r, float[] midpoints, Color[] colors) {
<b class="nc"><i>408</i>&nbsp;        if (r == 0f) {</b>
<b class="nc"><i>409</i>&nbsp;            r = .00001f;</b>
<i>410</i>&nbsp;        }
<b class="nc"><i>411</i>&nbsp;        return new RadialGradientPaint(x, y, r, midpoints, colors);</b>
<i>412</i>&nbsp;    }
<i>413</i>&nbsp;
<i>414</i>&nbsp;    /**
<i>415</i>&nbsp;     * Get a color property from the given JComponent. First checks for a
<i>416</i>&nbsp;     * &lt;code&gt;getXXX()&lt;/code&gt; method and if that fails checks for a client
<i>417</i>&nbsp;     * property with key &lt;code&gt;property&lt;/code&gt;. If that still fails to return
<i>418</i>&nbsp;     * a Color then &lt;code&gt;defaultColor&lt;/code&gt; is returned.
<i>419</i>&nbsp;     *
<i>420</i>&nbsp;     * @param c The component to get the color property from
<i>421</i>&nbsp;     * @param property The name of a bean style property or client property
<i>422</i>&nbsp;     * @param defaultColor The color to return if no color was obtained from
<i>423</i>&nbsp;     *        the component.
<i>424</i>&nbsp;     * @param saturationOffset additively modifies the HSB saturation component
<i>425</i>&nbsp;     * of the color returned (ignored if default color is returned).
<i>426</i>&nbsp;     * @param brightnessOffset additively modifies the HSB brightness component
<i>427</i>&nbsp;     * of the color returned (ignored if default color is returned).
<i>428</i>&nbsp;     * @param alphaOffset additively modifies the ARGB alpha component of the
<i>429</i>&nbsp;     * color returned (ignored if default color is returned).
<i>430</i>&nbsp;     *
<b class="nc"><i>431</i>&nbsp;     * @return The color that was obtained from the component or defaultColor</b>
<b class="nc"><i>432</i>&nbsp;     */</b>
<i>433</i>&nbsp;    protected final Color getComponentColor(JComponent c, String property,
<b class="nc"><i>434</i>&nbsp;                                            Color defaultColor,</b>
<b class="nc"><i>435</i>&nbsp;                                            float saturationOffset,</b>
<b class="nc"><i>436</i>&nbsp;                                            float brightnessOffset,</b>
<b class="nc"><i>437</i>&nbsp;                                            int alphaOffset) {</b>
<b class="nc"><i>438</i>&nbsp;        Color color = null;</b>
<b class="nc"><i>439</i>&nbsp;        if (c != null) {</b>
<b class="nc"><i>440</i>&nbsp;            // handle some special cases for performance</b>
<b class="nc"><i>441</i>&nbsp;            if (&quot;background&quot;.equals(property)) {</b>
<b class="nc"><i>442</i>&nbsp;                color = c.getBackground();</b>
<b class="nc"><i>443</i>&nbsp;            } else if (&quot;foreground&quot;.equals(property)) {</b>
<b class="nc"><i>444</i>&nbsp;                color = c.getForeground();</b>
<b class="nc"><i>445</i>&nbsp;            } else if (c instanceof JList &amp;&amp; &quot;selectionForeground&quot;.equals(property)) {</b>
<i>446</i>&nbsp;                color = ((JList) c).getSelectionForeground();
<b class="nc"><i>447</i>&nbsp;            } else if (c instanceof JList &amp;&amp; &quot;selectionBackground&quot;.equals(property)) {</b>
<i>448</i>&nbsp;                color = ((JList) c).getSelectionBackground();
<b class="nc"><i>449</i>&nbsp;            } else if (c instanceof JTable &amp;&amp; &quot;selectionForeground&quot;.equals(property)) {</b>
<b class="nc"><i>450</i>&nbsp;                color = ((JTable) c).getSelectionForeground();</b>
<b class="nc"><i>451</i>&nbsp;            } else if (c instanceof JTable &amp;&amp; &quot;selectionBackground&quot;.equals(property)) {</b>
<i>452</i>&nbsp;                color = ((JTable) c).getSelectionBackground();
<i>453</i>&nbsp;            } else {
<i>454</i>&nbsp;                String s = &quot;get&quot; + Character.toUpperCase(property.charAt(0)) + property.substring(1);
<i>455</i>&nbsp;                try {
<b class="nc"><i>456</i>&nbsp;                    Method method = MethodUtil.getMethod(c.getClass(), s, null);</b>
<b class="nc"><i>457</i>&nbsp;                    color = (Color) MethodUtil.invoke(method, c, null);</b>
<b class="nc"><i>458</i>&nbsp;                } catch (Exception e) {</b>
<b class="nc"><i>459</i>&nbsp;                    //don&#39;t do anything, it just didn&#39;t work, that&#39;s all.</b>
<b class="nc"><i>460</i>&nbsp;                    //This could be a normal occurance if you use a property</b>
<i>461</i>&nbsp;                    //name referring to a key in clientProperties instead of
<i>462</i>&nbsp;                    //a real property
<i>463</i>&nbsp;                }
<i>464</i>&nbsp;                if (color == null) {
<i>465</i>&nbsp;                    Object value = c.getClientProperty(property);
<i>466</i>&nbsp;                    if (value instanceof Color) {
<i>467</i>&nbsp;                        color = (Color) value;
<i>468</i>&nbsp;                    }
<i>469</i>&nbsp;                }
<i>470</i>&nbsp;            }
<b class="nc"><i>471</i>&nbsp;        }</b>
<b class="nc"><i>472</i>&nbsp;        // we return the defaultColor if the color found is null, or if</b>
<b class="nc"><i>473</i>&nbsp;        // it is a UIResource. This is done because the color for the</b>
<b class="nc"><i>474</i>&nbsp;        // ENABLED state is set on the component, but you don&#39;t want to use</b>
<b class="nc"><i>475</i>&nbsp;        // that color for the over state. So we only respect the color</b>
<b class="nc"><i>476</i>&nbsp;        // specified for the property if it was set by the user, as opposed</b>
<b class="nc"><i>477</i>&nbsp;        // to set by us.</b>
<b class="nc"><i>478</i>&nbsp;        if (color == null || color instanceof UIResource) {</b>
<i>479</i>&nbsp;            return defaultColor;
<b class="nc"><i>480</i>&nbsp;        } else if (saturationOffset != 0 || brightnessOffset != 0 || alphaOffset != 0) {</b>
<i>481</i>&nbsp;            float[] tmp = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
<i>482</i>&nbsp;            tmp[1] = clamp(tmp[1] + saturationOffset);
<i>483</i>&nbsp;            tmp[2] = clamp(tmp[2] + brightnessOffset);
<i>484</i>&nbsp;            int alpha = clamp(color.getAlpha() + alphaOffset);
<i>485</i>&nbsp;            return new Color((Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) &amp; 0xFFFFFF) | (alpha &lt;&lt;24));
<i>486</i>&nbsp;        } else {
<i>487</i>&nbsp;            return color;
<i>488</i>&nbsp;        }
<i>489</i>&nbsp;    }
<b class="nc"><i>490</i>&nbsp;</b>
<b class="nc"><i>491</i>&nbsp;    /**</b>
<b class="nc"><i>492</i>&nbsp;     * A class encapsulating state useful when painting. Generally, instances of this</b>
<i>493</i>&nbsp;     * class are created once, and reused for each paint request without modification.
<i>494</i>&nbsp;     * This class contains values useful when hinting the cache engine, and when decoding
<b class="nc"><i>495</i>&nbsp;     * control points and bezier curve anchors.</b>
<i>496</i>&nbsp;     */
<i>497</i>&nbsp;    protected static class PaintContext {
<i>498</i>&nbsp;        /**
<i>499</i>&nbsp;         * Cache mode.
<i>500</i>&nbsp;         */
<i>501</i>&nbsp;        protected static enum CacheMode {
<i>502</i>&nbsp;            /** No caching.*/
<i>503</i>&nbsp;            NO_CACHING,
<i>504</i>&nbsp;            /** Fixed sizes.*/
<i>505</i>&nbsp;            FIXED_SIZES,
<i>506</i>&nbsp;            /** Nine square scale.*/
<i>507</i>&nbsp;            NINE_SQUARE_SCALE
<i>508</i>&nbsp;        }
<i>509</i>&nbsp;
<i>510</i>&nbsp;        private static Insets EMPTY_INSETS = new Insets(0, 0, 0, 0);
<i>511</i>&nbsp;
<i>512</i>&nbsp;        private Insets stretchingInsets;
<i>513</i>&nbsp;        private Dimension canvasSize;
<i>514</i>&nbsp;        private boolean inverted;
<i>515</i>&nbsp;        private CacheMode cacheMode;
<i>516</i>&nbsp;        private double maxHorizontalScaleFactor;
<i>517</i>&nbsp;        private double maxVerticalScaleFactor;
<i>518</i>&nbsp;
<i>519</i>&nbsp;        private float a; // insets.left
<i>520</i>&nbsp;        private float b; // canvasSize.width - insets.right
<i>521</i>&nbsp;        private float c; // insets.top
<i>522</i>&nbsp;        private float d; // canvasSize.height - insets.bottom;
<i>523</i>&nbsp;        private float aPercent; // only used if inverted == true
<b class="nc"><i>524</i>&nbsp;        private float bPercent; // only used if inverted == true</b>
<i>525</i>&nbsp;        private float cPercent; // only used if inverted == true
<i>526</i>&nbsp;        private float dPercent; // only used if inverted == true
<i>527</i>&nbsp;
<i>528</i>&nbsp;        /**
<i>529</i>&nbsp;         * Creates a new PaintContext which does not attempt to cache or scale any cached
<i>530</i>&nbsp;         * images.
<i>531</i>&nbsp;         *
<i>532</i>&nbsp;         * @param insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.
<i>533</i>&nbsp;         * @param canvasSize The size of the canvas used when encoding the various x/y values. May be null.
<i>534</i>&nbsp;         *                   If null, then it is assumed that there are no encoded values, and any calls
<i>535</i>&nbsp;         *                   to one of the &quot;decode&quot; methods will return the passed in value.
<i>536</i>&nbsp;         * @param inverted Whether to &quot;invert&quot; the meaning of the 9-square grid and stretching insets
<i>537</i>&nbsp;         */
<i>538</i>&nbsp;        public PaintContext(Insets insets, Dimension canvasSize, boolean inverted) {
<i>539</i>&nbsp;            this(insets, canvasSize, inverted, null, 1, 1);
<i>540</i>&nbsp;        }
<i>541</i>&nbsp;
<i>542</i>&nbsp;        /**
<i>543</i>&nbsp;         * Creates a new PaintContext.
<i>544</i>&nbsp;         *
<i>545</i>&nbsp;         * @param insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.
<b class="nc"><i>546</i>&nbsp;         * @param canvasSize The size of the canvas used when encoding the various x/y values. May be null.</b>
<b class="nc"><i>547</i>&nbsp;         *                   If null, then it is assumed that there are no encoded values, and any calls</b>
<b class="nc"><i>548</i>&nbsp;         *                   to one of the &quot;decode&quot; methods will return the passed in value.</b>
<i>549</i>&nbsp;         * @param inverted Whether to &quot;invert&quot; the meaning of the 9-square grid and stretching insets
<i>550</i>&nbsp;         * @param cacheMode A hint as to which caching mode to use. If null, then set to no caching.
<b class="nc"><i>551</i>&nbsp;         * @param maxH The maximum scale in the horizontal direction to use before punting and redrawing from scratch.</b>
<b class="nc"><i>552</i>&nbsp;         *             For example, if maxH is 2, then we will attempt to scale any cached images up to 2x the canvas</b>
<b class="nc"><i>553</i>&nbsp;         *             width before redrawing from scratch. Reasonable maxH values may improve painting performance.</b>
<b class="nc"><i>554</i>&nbsp;         *             If set too high, then you may get poor looking graphics at higher zoom levels. Must be &amp;gt;= 1.</b>
<b class="nc"><i>555</i>&nbsp;         * @param maxV The maximum scale in the vertical direction to use before punting and redrawing from scratch.</b>
<b class="nc"><i>556</i>&nbsp;         *             For example, if maxV is 2, then we will attempt to scale any cached images up to 2x the canvas</b>
<i>557</i>&nbsp;         *             height before redrawing from scratch. Reasonable maxV values may improve painting performance.
<b class="nc"><i>558</i>&nbsp;         *             If set too high, then you may get poor looking graphics at higher zoom levels. Must be &amp;gt;= 1.</b>
<b class="nc"><i>559</i>&nbsp;         */</b>
<b class="nc"><i>560</i>&nbsp;        public PaintContext(Insets insets, Dimension canvasSize, boolean inverted,</b>
<b class="nc"><i>561</i>&nbsp;                            CacheMode cacheMode, double maxH, double maxV) {</b>
<b class="nc"><i>562</i>&nbsp;            if (maxH &lt; 1 || maxV &lt; 1) {</b>
<b class="nc"><i>563</i>&nbsp;                throw new IllegalArgumentException(&quot;Both maxH and maxV must be &gt;= 1&quot;);</b>
<b class="nc"><i>564</i>&nbsp;            }</b>
<b class="nc"><i>565</i>&nbsp;</b>
<b class="nc"><i>566</i>&nbsp;            this.stretchingInsets = insets == null ? EMPTY_INSETS : insets;</b>
<b class="nc"><i>567</i>&nbsp;            this.canvasSize = canvasSize;</b>
<b class="nc"><i>568</i>&nbsp;            this.inverted = inverted;</b>
<b class="nc"><i>569</i>&nbsp;            this.cacheMode = cacheMode == null ? CacheMode.NO_CACHING : cacheMode;</b>
<b class="nc"><i>570</i>&nbsp;            this.maxHorizontalScaleFactor = maxH;</b>
<b class="nc"><i>571</i>&nbsp;            this.maxVerticalScaleFactor = maxV;</b>
<i>572</i>&nbsp;
<i>573</i>&nbsp;            if (canvasSize != null) {
<i>574</i>&nbsp;                a = stretchingInsets.left;
<i>575</i>&nbsp;                b = canvasSize.width - stretchingInsets.right;
<i>576</i>&nbsp;                c = stretchingInsets.top;
<i>577</i>&nbsp;                d = canvasSize.height - stretchingInsets.bottom;
<i>578</i>&nbsp;                this.canvasSize = canvasSize;
<i>579</i>&nbsp;                this.inverted = inverted;
<i>580</i>&nbsp;                if (inverted) {
<i>581</i>&nbsp;                    float available = canvasSize.width - (b - a);
<i>582</i>&nbsp;                    aPercent = available &gt; 0f ? a / available : 0f;
<b class="nc"><i>583</i>&nbsp;                    bPercent = available &gt; 0f ? b / available : 0f;</b>
<b class="nc"><i>584</i>&nbsp;                    available = canvasSize.height - (d - c);</b>
<b class="nc"><i>585</i>&nbsp;                    cPercent = available &gt; 0f ? c / available : 0f;</b>
<b class="nc"><i>586</i>&nbsp;                    dPercent = available &gt; 0f ? d / available : 0f;</b>
<b class="nc"><i>587</i>&nbsp;                }</b>
<b class="nc"><i>588</i>&nbsp;            }</b>
<i>589</i>&nbsp;        }
<i>590</i>&nbsp;    }
<i>591</i>&nbsp;
<i>592</i>&nbsp;    //---------------------- private methods
<b class="nc"><i>593</i>&nbsp;</b>
<b class="nc"><i>594</i>&nbsp;    //initializes the class to prepare it for being able to decode points</b>
<i>595</i>&nbsp;    private void prepare(float w, float h) {
<b class="nc"><i>596</i>&nbsp;        //if no PaintContext has been specified, reset the values and bail</b>
<b class="nc"><i>597</i>&nbsp;        //also bail if the canvasSize was not set (since decoding will not work)</b>
<b class="nc"><i>598</i>&nbsp;        if (ctx == null || ctx.canvasSize == null) {</b>
<b class="nc"><i>599</i>&nbsp;            f = 1f;</b>
<b class="nc"><i>600</i>&nbsp;            leftWidth = centerWidth = rightWidth = 0f;</b>
<b class="nc"><i>601</i>&nbsp;            topHeight = centerHeight = bottomHeight = 0f;</b>
<b class="nc"><i>602</i>&nbsp;            leftScale = centerHScale = rightScale = 0f;</b>
<b class="nc"><i>603</i>&nbsp;            topScale = centerVScale = bottomScale = 0f;</b>
<b class="nc"><i>604</i>&nbsp;            return;</b>
<b class="nc"><i>605</i>&nbsp;        }</b>
<b class="nc"><i>606</i>&nbsp;</b>
<b class="nc"><i>607</i>&nbsp;        //calculate the scaling factor, and the sizes for the various 9-square sections</b>
<b class="nc"><i>608</i>&nbsp;        Number scale = (Number)UIManager.get(&quot;scale&quot;);</b>
<b class="nc"><i>609</i>&nbsp;        f = scale == null ? 1f : scale.floatValue();</b>
<b class="nc"><i>610</i>&nbsp;</b>
<b class="nc"><i>611</i>&nbsp;        if (ctx.inverted) {</b>
<i>612</i>&nbsp;            centerWidth = (ctx.b - ctx.a) * f;
<i>613</i>&nbsp;            float availableSpace = w - centerWidth;
<b class="nc"><i>614</i>&nbsp;            leftWidth = availableSpace * ctx.aPercent;</b>
<b class="nc"><i>615</i>&nbsp;            rightWidth = availableSpace * ctx.bPercent;</b>
<b class="nc"><i>616</i>&nbsp;            centerHeight = (ctx.d - ctx.c) * f;</b>
<b class="nc"><i>617</i>&nbsp;            availableSpace = h - centerHeight;</b>
<b class="nc"><i>618</i>&nbsp;            topHeight = availableSpace * ctx.cPercent;</b>
<b class="nc"><i>619</i>&nbsp;            bottomHeight = availableSpace * ctx.dPercent;</b>
<i>620</i>&nbsp;        } else {
<i>621</i>&nbsp;            leftWidth = ctx.a * f;
<i>622</i>&nbsp;            rightWidth = (float)(ctx.canvasSize.getWidth() - ctx.b) * f;
<i>623</i>&nbsp;            centerWidth = w - leftWidth - rightWidth;
<i>624</i>&nbsp;            topHeight = ctx.c * f;
<i>625</i>&nbsp;            bottomHeight = (float)(ctx.canvasSize.getHeight() - ctx.d) * f;
<b class="nc"><i>626</i>&nbsp;            centerHeight = h - topHeight - bottomHeight;</b>
<b class="nc"><i>627</i>&nbsp;        }</b>
<b class="nc"><i>628</i>&nbsp;</b>
<i>629</i>&nbsp;        leftScale = ctx.a == 0f ? 0f : leftWidth / ctx.a;
<b class="nc"><i>630</i>&nbsp;        centerHScale = (ctx.b - ctx.a) == 0f ? 0f : centerWidth / (ctx.b - ctx.a);</b>
<b class="nc"><i>631</i>&nbsp;        rightScale = (ctx.canvasSize.width - ctx.b) == 0f ? 0f : rightWidth / (ctx.canvasSize.width - ctx.b);</b>
<i>632</i>&nbsp;        topScale = ctx.c == 0f ? 0f : topHeight / ctx.c;
<i>633</i>&nbsp;        centerVScale = (ctx.d - ctx.c) == 0f ? 0f : centerHeight / (ctx.d - ctx.c);
<i>634</i>&nbsp;        bottomScale = (ctx.canvasSize.height - ctx.d) == 0f ? 0f : bottomHeight / (ctx.canvasSize.height - ctx.d);
<b class="nc"><i>635</i>&nbsp;    }</b>
<b class="nc"><i>636</i>&nbsp;</b>
<b class="nc"><i>637</i>&nbsp;    private void paintWith9SquareCaching(Graphics2D g, PaintContext ctx,</b>
<b class="nc"><i>638</i>&nbsp;                                         JComponent c, int w, int h,</b>
<b class="nc"><i>639</i>&nbsp;                                         Object[] extendedCacheKeys) {</b>
<b class="nc"><i>640</i>&nbsp;        // check if we can scale to the requested size</b>
<i>641</i>&nbsp;        Dimension canvas = ctx.canvasSize;
<i>642</i>&nbsp;        Insets insets = ctx.stretchingInsets;
<b class="nc"><i>643</i>&nbsp;        if (w &lt;= (canvas.width * ctx.maxHorizontalScaleFactor) &amp;&amp; h &lt;= (canvas.height * ctx.maxVerticalScaleFactor)) {</b>
<b class="nc"><i>644</i>&nbsp;            // get image at canvas size</b>
<b class="nc"><i>645</i>&nbsp;            VolatileImage img = getImage(g.getDeviceConfiguration(), c, canvas.width, canvas.height, extendedCacheKeys);</b>
<i>646</i>&nbsp;            if (img != null) {
<b class="nc"><i>647</i>&nbsp;                // calculate dst inserts</b>
<i>648</i>&nbsp;                // todo: destination inserts need to take into acount scale factor for high dpi. Note: You can use f for this, I think
<b class="nc"><i>649</i>&nbsp;                Insets dstInsets;</b>
<i>650</i>&nbsp;                if (ctx.inverted){
<b class="nc"><i>651</i>&nbsp;                    int leftRight = (w-(canvas.width-(insets.left+insets.right)))/2;</b>
<i>652</i>&nbsp;                    int topBottom = (h-(canvas.height-(insets.top+insets.bottom)))/2;
<b class="nc"><i>653</i>&nbsp;                    dstInsets = new Insets(topBottom,leftRight,topBottom,leftRight);</b>
<i>654</i>&nbsp;                } else {
<b class="nc"><i>655</i>&nbsp;                    dstInsets = insets;</b>
<i>656</i>&nbsp;                }
<i>657</i>&nbsp;                // paint 9 square scaled
<i>658</i>&nbsp;                Object oldScaleingHints = g.getRenderingHint(RenderingHints.KEY_INTERPOLATION);
<i>659</i>&nbsp;                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
<i>660</i>&nbsp;                ImageScalingHelper.paint(g, 0, 0, w, h, img, insets, dstInsets,
<b class="nc"><i>661</i>&nbsp;                        ImageScalingHelper.PaintType.PAINT9_STRETCH, ImageScalingHelper.PAINT_ALL);</b>
<b class="nc"><i>662</i>&nbsp;                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,</b>
<i>663</i>&nbsp;                    oldScaleingHints!=null?oldScaleingHints:RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
<b class="nc"><i>664</i>&nbsp;            } else {</b>
<i>665</i>&nbsp;                // render directly
<i>666</i>&nbsp;                paint0(g, c, w, h, extendedCacheKeys);
<b class="nc"><i>667</i>&nbsp;            }</b>
<i>668</i>&nbsp;        } else {
<i>669</i>&nbsp;            // paint directly
<i>670</i>&nbsp;            paint0(g, c, w, h, extendedCacheKeys);
<i>671</i>&nbsp;        }
<i>672</i>&nbsp;    }
<i>673</i>&nbsp;
<b class="nc"><i>674</i>&nbsp;    private void paintWithFixedSizeCaching(Graphics2D g, JComponent c, int w,</b>
<i>675</i>&nbsp;                                           int h, Object[] extendedCacheKeys) {
<b class="nc"><i>676</i>&nbsp;        VolatileImage img = getImage(g.getDeviceConfiguration(), c, w, h, extendedCacheKeys);</b>
<i>677</i>&nbsp;        if (img != null) {
<b class="nc"><i>678</i>&nbsp;            //render cached image</b>
<i>679</i>&nbsp;            g.drawImage(img, 0, 0, null);
<i>680</i>&nbsp;        } else {
<b class="nc"><i>681</i>&nbsp;            // render directly</b>
<b class="nc"><i>682</i>&nbsp;            paint0(g, c, w, h, extendedCacheKeys);</b>
<b class="nc"><i>683</i>&nbsp;        }</b>
<i>684</i>&nbsp;    }
<i>685</i>&nbsp;
<i>686</i>&nbsp;    /** Gets the rendered image for this painter at the requested size, either from cache or create a new one */
<b class="nc"><i>687</i>&nbsp;    private VolatileImage getImage(GraphicsConfiguration config, JComponent c,</b>
<i>688</i>&nbsp;                                   int w, int h, Object[] extendedCacheKeys) {
<i>689</i>&nbsp;        ImageCache imageCache = ImageCache.getInstance();
<b class="nc"><i>690</i>&nbsp;        //get the buffer for this component</b>
<i>691</i>&nbsp;        VolatileImage buffer = (VolatileImage) imageCache.getImage(config, w, h, this, extendedCacheKeys);
<i>692</i>&nbsp;
<b class="nc"><i>693</i>&nbsp;        int renderCounter = 0; //to avoid any potential, though unlikely, infinite loop</b>
<b class="nc"><i>694</i>&nbsp;        do {</b>
<b class="nc"><i>695</i>&nbsp;            //validate the buffer so we can check for surface loss</b>
<i>696</i>&nbsp;            int bufferStatus = VolatileImage.IMAGE_INCOMPATIBLE;
<i>697</i>&nbsp;            if (buffer != null) {
<b class="nc"><i>698</i>&nbsp;                bufferStatus = buffer.validate(config);</b>
<i>699</i>&nbsp;            }
<i>700</i>&nbsp;
<b class="nc"><i>701</i>&nbsp;            //If the buffer status is incompatible or restored, then we need to re-render to the volatile image</b>
<i>702</i>&nbsp;            if (bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE || bufferStatus == VolatileImage.IMAGE_RESTORED) {
<i>703</i>&nbsp;                //if the buffer is null (hasn&#39;t been created), or isn&#39;t the right size, or has lost its contents,
<b class="nc"><i>704</i>&nbsp;                //then recreate the buffer</b>
<i>705</i>&nbsp;                if (buffer == null || buffer.getWidth() != w || buffer.getHeight() != h ||
<b class="nc"><i>706</i>&nbsp;                        bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE) {</b>
<b class="nc"><i>707</i>&nbsp;                    //clear any resources related to the old back buffer</b>
<b class="nc"><i>708</i>&nbsp;                    if (buffer != null) {</b>
<b class="nc"><i>709</i>&nbsp;                        buffer.flush();</b>
<i>710</i>&nbsp;                        buffer = null;
<b class="nc"><i>711</i>&nbsp;                    }</b>
<i>712</i>&nbsp;                    //recreate the buffer
<b class="nc"><i>713</i>&nbsp;                    buffer = config.createCompatibleVolatileImage(w, h,</b>
<i>714</i>&nbsp;                            Transparency.TRANSLUCENT);
<b class="nc"><i>715</i>&nbsp;                    // put in cache for future</b>
<i>716</i>&nbsp;                    imageCache.setImage(buffer, config, w, h, this, extendedCacheKeys);
<b class="nc"><i>717</i>&nbsp;                }</b>
<i>718</i>&nbsp;                //create the graphics context with which to paint to the buffer
<b class="nc"><i>719</i>&nbsp;                Graphics2D bg = buffer.createGraphics();</b>
<i>720</i>&nbsp;                //clear the background before configuring the graphics
<i>721</i>&nbsp;                bg.setComposite(AlphaComposite.Clear);
<i>722</i>&nbsp;                bg.fillRect(0, 0, w, h);
<i>723</i>&nbsp;                bg.setComposite(AlphaComposite.SrcOver);
<i>724</i>&nbsp;                configureGraphics(bg);
<i>725</i>&nbsp;                // paint the painter into buffer
<i>726</i>&nbsp;                paint0(bg, c, w, h, extendedCacheKeys);
<i>727</i>&nbsp;                //close buffer graphics
<b class="nc"><i>728</i>&nbsp;                bg.dispose();</b>
<b class="nc"><i>729</i>&nbsp;            }</b>
<b class="nc"><i>730</i>&nbsp;        } while (buffer.contentsLost() &amp;&amp; renderCounter++ &lt; 3);</b>
<b class="nc"><i>731</i>&nbsp;        // check if we failed</b>
<b class="nc"><i>732</i>&nbsp;        if (renderCounter == 3) return null;</b>
<i>733</i>&nbsp;        // return image
<i>734</i>&nbsp;        return buffer;
<i>735</i>&nbsp;    }
<b class="nc"><i>736</i>&nbsp;</b>
<b class="nc"><i>737</i>&nbsp;    //convenience method which creates a temporary graphics object by creating a</b>
<b class="nc"><i>738</i>&nbsp;    //clone of the passed in one, configuring it, drawing with it, disposing it.</b>
<b class="nc"><i>739</i>&nbsp;    //These steps have to be taken to ensure that any hints set on the graphics</b>
<i>740</i>&nbsp;    //are removed subsequent to painting.
<b class="nc"><i>741</i>&nbsp;    private void paint0(Graphics2D g, JComponent c, int width, int height,</b>
<i>742</i>&nbsp;                        Object[] extendedCacheKeys) {
<i>743</i>&nbsp;        prepare(width, height);
<i>744</i>&nbsp;        g = (Graphics2D)g.create();
<b class="nc"><i>745</i>&nbsp;        configureGraphics(g);</b>
<b class="nc"><i>746</i>&nbsp;        doPaint(g, c, width, height, extendedCacheKeys);</b>
<b class="nc"><i>747</i>&nbsp;        g.dispose();</b>
<b class="nc"><i>748</i>&nbsp;    }</b>
<i>749</i>&nbsp;
<b class="nc"><i>750</i>&nbsp;    private float clamp(float value) {</b>
<i>751</i>&nbsp;        if (value &lt; 0) {
<i>752</i>&nbsp;            value = 0;
<i>753</i>&nbsp;        } else if (value &gt; 1) {
<i>754</i>&nbsp;            value = 1;
<i>755</i>&nbsp;        }
<i>756</i>&nbsp;        return value;
<i>757</i>&nbsp;    }
<i>758</i>&nbsp;
<i>759</i>&nbsp;    private int clamp(int value) {
<i>760</i>&nbsp;        if (value &lt; 0) {
<i>761</i>&nbsp;            value = 0;
<i>762</i>&nbsp;        } else if (value &gt; 255) {
<i>763</i>&nbsp;            value = 255;
<i>764</i>&nbsp;        }
<i>765</i>&nbsp;        return value;
<i>766</i>&nbsp;    }
<i>767</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:16</div>
</div>
</body>
</html>
