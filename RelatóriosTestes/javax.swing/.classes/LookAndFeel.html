


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: LookAndFeel</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing</a> ]
</div>

<h1>Coverage Summary for Class: LookAndFeel (javax.swing)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LookAndFeel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 64)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javax.swing;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.Font;
<i>29</i>&nbsp;import java.awt.event.InputEvent;
<i>30</i>&nbsp;import java.awt.event.KeyEvent;
<i>31</i>&nbsp;import java.awt.Color;
<i>32</i>&nbsp;import java.awt.Component;
<i>33</i>&nbsp;import java.awt.SystemColor;
<i>34</i>&nbsp;import java.awt.Toolkit;
<i>35</i>&nbsp;import sun.awt.SunToolkit;
<i>36</i>&nbsp;
<i>37</i>&nbsp;import javax.swing.text.*;
<i>38</i>&nbsp;import javax.swing.border.*;
<i>39</i>&nbsp;import javax.swing.plaf.*;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import java.net.URL;
<i>42</i>&nbsp;import sun.swing.SwingUtilities2;
<i>43</i>&nbsp;import sun.swing.DefaultLayoutStyle;
<i>44</i>&nbsp;import sun.swing.ImageIconUIResource;
<i>45</i>&nbsp;
<i>46</i>&nbsp;import java.util.StringTokenizer;
<i>47</i>&nbsp;
<i>48</i>&nbsp;
<i>49</i>&nbsp;/**
<i>50</i>&nbsp; * {@code LookAndFeel}, as the name implies, encapsulates a look and
<i>51</i>&nbsp; * feel. Beyond installing a look and feel most developers never need to
<i>52</i>&nbsp; * interact directly with {@code LookAndFeel}. In general only developers
<i>53</i>&nbsp; * creating a custom look and feel need to concern themselves with this class.
<i>54</i>&nbsp; * &lt;p&gt;
<i>55</i>&nbsp; * Swing is built upon the foundation that each {@code JComponent}
<i>56</i>&nbsp; * subclass has an implementation of a specific {@code ComponentUI}
<i>57</i>&nbsp; * subclass. The {@code ComponentUI} is often referred to as &quot;the ui&quot;,
<i>58</i>&nbsp; * &quot;component ui&quot;, or &quot;look and feel delegate&quot;. The {@code ComponentUI}
<i>59</i>&nbsp; * subclass is responsible for providing the look and feel specific
<i>60</i>&nbsp; * functionality of the component. For example, {@code JTree} requires
<i>61</i>&nbsp; * an implementation of the {@code ComponentUI} subclass {@code
<i>62</i>&nbsp; * TreeUI}. The implementation of the specific {@code
<i>63</i>&nbsp; * ComponentUI} subclass is provided by the {@code LookAndFeel}. Each
<i>64</i>&nbsp; * {@code JComponent} subclass identifies the {@code ComponentUI}
<i>65</i>&nbsp; * subclass it requires by way of the {@code JComponent} method {@code
<i>66</i>&nbsp; * getUIClassID}.
<i>67</i>&nbsp; * &lt;p&gt;
<i>68</i>&nbsp; * Each {@code LookAndFeel} implementation must provide
<i>69</i>&nbsp; * an implementation of the appropriate {@code ComponentUI} subclass by
<i>70</i>&nbsp; * specifying a value for each of Swing&#39;s ui class ids in the {@code
<i>71</i>&nbsp; * UIDefaults} object returned from {@code getDefaults}. For example,
<i>72</i>&nbsp; * {@code BasicLookAndFeel} uses {@code BasicTreeUI} as the concrete
<i>73</i>&nbsp; * implementation for {@code TreeUI}. This is accomplished by {@code
<i>74</i>&nbsp; * BasicLookAndFeel} providing the key-value pair {@code
<i>75</i>&nbsp; * &quot;TreeUI&quot;-&quot;javax.swing.plaf.basic.BasicTreeUI&quot;}, in the
<i>76</i>&nbsp; * {@code UIDefaults} returned from {@code getDefaults}. Refer to
<i>77</i>&nbsp; * {@link UIDefaults#getUI(JComponent)} for details on how the implementation
<i>78</i>&nbsp; * of the {@code ComponentUI} subclass is obtained.
<i>79</i>&nbsp; * &lt;p&gt;
<i>80</i>&nbsp; * When a {@code LookAndFeel} is installed the {@code UIManager} does
<i>81</i>&nbsp; * not check that an entry exists for all ui class ids. As such,
<i>82</i>&nbsp; * random exceptions will occur if the current look and feel has not
<i>83</i>&nbsp; * provided a value for a particular ui class id and an instance of
<i>84</i>&nbsp; * the {@code JComponent} subclass is created.
<i>85</i>&nbsp; *
<i>86</i>&nbsp; * &lt;h2&gt;Recommendations for Look and Feels&lt;/h2&gt;
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * As noted in {@code UIManager} each {@code LookAndFeel} has the opportunity
<i>89</i>&nbsp; * to provide a set of defaults that are layered in with developer and
<i>90</i>&nbsp; * system defaults. Some of Swing&#39;s components require the look and feel
<i>91</i>&nbsp; * to provide a specific set of defaults. These are documented in the
<i>92</i>&nbsp; * classes that require the specific default.
<i>93</i>&nbsp; *
<i>94</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;defaultRecommendation&quot;&gt;ComponentUIs and defaults&lt;/a&gt;&lt;/h3&gt;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * All {@code ComponentUIs} typically need to set various properties
<i>97</i>&nbsp; * on the {@code JComponent} the {@code ComponentUI} is providing the
<i>98</i>&nbsp; * look and feel for. This is typically done when the {@code
<i>99</i>&nbsp; * ComponentUI} is installed on the {@code JComponent}. Setting a
<i>100</i>&nbsp; * property should only be done if the developer has not set the
<i>101</i>&nbsp; * property. For non-primitive values it is recommended that the
<i>102</i>&nbsp; * {@code ComponentUI} only change the property on the {@code
<i>103</i>&nbsp; * JComponent} if the current value is {@code null} or implements
<i>104</i>&nbsp; * {@code UIResource}. If the current value is {@code null} or
<i>105</i>&nbsp; * implements {@code UIResource} it indicates the property has not
<i>106</i>&nbsp; * been set by the developer, and the ui is free to change it.  For
<i>107</i>&nbsp; * example, {@code BasicButtonUI.installDefaults} only changes the
<i>108</i>&nbsp; * font on the {@code JButton} if the return value from {@code
<i>109</i>&nbsp; * button.getFont()} is {@code null} or implements {@code
<i>110</i>&nbsp; * UIResource}. On the other hand if {@code button.getFont()} returned
<i>111</i>&nbsp; * a {@code non-null} value that did not implement {@code UIResource}
<i>112</i>&nbsp; * then {@code BasicButtonUI.installDefaults} would not change the
<i>113</i>&nbsp; * {@code JButton}&#39;s font.
<i>114</i>&nbsp; * &lt;p&gt;
<i>115</i>&nbsp; * For primitive values, such as {@code opaque}, the method {@code
<i>116</i>&nbsp; * installProperty} should be invoked.  {@code installProperty} only changes
<i>117</i>&nbsp; * the corresponding property if the value has not been changed by the
<i>118</i>&nbsp; * developer.
<i>119</i>&nbsp; * &lt;p&gt;
<i>120</i>&nbsp; * {@code ComponentUI} implementations should use the various install methods
<i>121</i>&nbsp; * provided by this class as they handle the necessary checking and install
<i>122</i>&nbsp; * the property using the recommended guidelines.
<i>123</i>&nbsp; *
<i>124</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;exceptions&quot;&gt;&lt;/a&gt;Exceptions&lt;/h3&gt;
<i>125</i>&nbsp; *
<i>126</i>&nbsp; * All of the install methods provided by {@code LookAndFeel} need to
<i>127</i>&nbsp; * access the defaults if the value of the property being changed is
<i>128</i>&nbsp; * {@code null} or a {@code UIResource}. For example, installing the
<i>129</i>&nbsp; * font does the following:
<i>130</i>&nbsp; * &lt;pre&gt;
<i>131</i>&nbsp; *   JComponent c;
<i>132</i>&nbsp; *   Font font = c.getFont();
<i>133</i>&nbsp; *   if (font == null || (font instanceof UIResource)) {
<i>134</i>&nbsp; *       c.setFont(UIManager.getFont(&quot;fontKey&quot;));
<i>135</i>&nbsp; *   }
<i>136</i>&nbsp; * &lt;/pre&gt;
<i>137</i>&nbsp; * If the font is {@code null} or a {@code UIResource}, the
<i>138</i>&nbsp; * defaults table is queried with the key {@code fontKey}. All of
<i>139</i>&nbsp; * {@code UIDefault&#39;s} get methods throw a {@code
<i>140</i>&nbsp; * NullPointerException} if passed in {@code null}. As such, unless
<i>141</i>&nbsp; * otherwise noted each of the various install methods of {@code
<i>142</i>&nbsp; * LookAndFeel} throw a {@code NullPointerException} if the current
<i>143</i>&nbsp; * value is {@code null} or a {@code UIResource} and the supplied
<i>144</i>&nbsp; * defaults key is {@code null}. In addition, unless otherwise specified
<i>145</i>&nbsp; * all of the {@code install} methods throw a {@code NullPointerException} if
<i>146</i>&nbsp; * a {@code null} component is passed in.
<i>147</i>&nbsp; *
<i>148</i>&nbsp; * @author Tom Ball
<i>149</i>&nbsp; * @author Hans Muller
<i>150</i>&nbsp; * @since 1.2
<b class="nc"><i>151</i>&nbsp; */</b>
<i>152</i>&nbsp;public abstract class LookAndFeel
<i>153</i>&nbsp;{
<i>154</i>&nbsp;
<i>155</i>&nbsp;    /**
<i>156</i>&nbsp;     * Convenience method for setting a component&#39;s foreground
<i>157</i>&nbsp;     * and background color properties with values from the
<i>158</i>&nbsp;     * defaults.  The properties are only set if the current
<i>159</i>&nbsp;     * value is either {@code null} or a {@code UIResource}.
<i>160</i>&nbsp;     *
<i>161</i>&nbsp;     * @param c component to set the colors on
<i>162</i>&nbsp;     * @param defaultBgName key for the background
<i>163</i>&nbsp;     * @param defaultFgName key for the foreground
<i>164</i>&nbsp;     *
<i>165</i>&nbsp;     * @see #installColorsAndFont
<i>166</i>&nbsp;     * @see UIManager#getColor
<i>167</i>&nbsp;     * @throws NullPointerException as described in
<i>168</i>&nbsp;     *         &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;
<i>169</i>&nbsp;     */
<i>170</i>&nbsp;    public static void installColors(JComponent c,
<i>171</i>&nbsp;                                     String defaultBgName,
<i>172</i>&nbsp;                                     String defaultFgName)
<b class="nc"><i>173</i>&nbsp;    {</b>
<b class="nc"><i>174</i>&nbsp;        Color bg = c.getBackground();</b>
<b class="nc"><i>175</i>&nbsp;        if (bg == null || bg instanceof UIResource) {</b>
<i>176</i>&nbsp;            c.setBackground(UIManager.getColor(defaultBgName));
<i>177</i>&nbsp;        }
<b class="nc"><i>178</i>&nbsp;</b>
<b class="nc"><i>179</i>&nbsp;        Color fg = c.getForeground();</b>
<b class="nc"><i>180</i>&nbsp;        if (fg == null || fg instanceof UIResource) {</b>
<i>181</i>&nbsp;            c.setForeground(UIManager.getColor(defaultFgName));
<i>182</i>&nbsp;        }
<i>183</i>&nbsp;    }
<i>184</i>&nbsp;
<i>185</i>&nbsp;
<i>186</i>&nbsp;    /**
<i>187</i>&nbsp;     * Convenience method for setting a component&#39;s foreground,
<i>188</i>&nbsp;     * background and font properties with values from the
<i>189</i>&nbsp;     * defaults.  The properties are only set if the current
<i>190</i>&nbsp;     * value is either {@code null} or a {@code UIResource}.
<i>191</i>&nbsp;     *
<i>192</i>&nbsp;     * @param c component set to the colors and font on
<i>193</i>&nbsp;     * @param defaultBgName key for the background
<i>194</i>&nbsp;     * @param defaultFgName key for the foreground
<i>195</i>&nbsp;     * @param defaultFontName key for the font
<i>196</i>&nbsp;     * @throws NullPointerException as described in
<i>197</i>&nbsp;     *         &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;
<i>198</i>&nbsp;     *
<i>199</i>&nbsp;     * @see #installColors
<i>200</i>&nbsp;     * @see UIManager#getColor
<i>201</i>&nbsp;     * @see UIManager#getFont
<i>202</i>&nbsp;     */
<i>203</i>&nbsp;    public static void installColorsAndFont(JComponent c,
<i>204</i>&nbsp;                                         String defaultBgName,
<i>205</i>&nbsp;                                         String defaultFgName,
<b class="nc"><i>206</i>&nbsp;                                         String defaultFontName) {</b>
<b class="nc"><i>207</i>&nbsp;        Font f = c.getFont();</b>
<b class="nc"><i>208</i>&nbsp;        if (f == null || f instanceof UIResource) {</b>
<i>209</i>&nbsp;            c.setFont(UIManager.getFont(defaultFontName));
<i>210</i>&nbsp;        }
<b class="nc"><i>211</i>&nbsp;</b>
<i>212</i>&nbsp;        installColors(c, defaultBgName, defaultFgName);
<i>213</i>&nbsp;    }
<i>214</i>&nbsp;
<i>215</i>&nbsp;
<i>216</i>&nbsp;    /**
<i>217</i>&nbsp;     * Convenience method for setting a component&#39;s border property with
<i>218</i>&nbsp;     * a value from the defaults. The border is only set if the border is
<i>219</i>&nbsp;     * {@code null} or an instance of {@code UIResource}.
<i>220</i>&nbsp;     *
<i>221</i>&nbsp;     * @param c component to set the border on
<i>222</i>&nbsp;     * @param defaultBorderName key specifying the border
<i>223</i>&nbsp;     * @throws NullPointerException as described in
<i>224</i>&nbsp;     *         &lt;a href=&quot;#exceptions&quot;&gt;exceptions&lt;/a&gt;
<i>225</i>&nbsp;     */
<b class="nc"><i>226</i>&nbsp;    public static void installBorder(JComponent c, String defaultBorderName) {</b>
<b class="nc"><i>227</i>&nbsp;        Border b = c.getBorder();</b>
<b class="nc"><i>228</i>&nbsp;        if (b == null || b instanceof UIResource) {</b>
<i>229</i>&nbsp;            c.setBorder(UIManager.getBorder(defaultBorderName));
<i>230</i>&nbsp;        }
<i>231</i>&nbsp;    }
<i>232</i>&nbsp;
<i>233</i>&nbsp;
<i>234</i>&nbsp;    /**
<i>235</i>&nbsp;     * Convenience method for uninstalling a border. If the border of
<i>236</i>&nbsp;     * the component is a {@code UIResource}, it is set to {@code
<i>237</i>&nbsp;     * null}.
<i>238</i>&nbsp;     *
<i>239</i>&nbsp;     * @param c component to uninstall the border on
<i>240</i>&nbsp;     * @throws NullPointerException if {@code c} is {@code null}
<i>241</i>&nbsp;     */
<b class="nc"><i>242</i>&nbsp;    public static void uninstallBorder(JComponent c) {</b>
<b class="nc"><i>243</i>&nbsp;        if (c.getBorder() instanceof UIResource) {</b>
<i>244</i>&nbsp;            c.setBorder(null);
<i>245</i>&nbsp;        }
<i>246</i>&nbsp;    }
<i>247</i>&nbsp;
<i>248</i>&nbsp;    /**
<i>249</i>&nbsp;     * Convenience method for installing a property with the specified name
<i>250</i>&nbsp;     * and value on a component if that property has not already been set
<i>251</i>&nbsp;     * by the developer.  This method is intended to be used by
<i>252</i>&nbsp;     * ui delegate instances that need to specify a default value for a
<i>253</i>&nbsp;     * property of primitive type (boolean, int, ..), but do not wish
<i>254</i>&nbsp;     * to override a value set by the client.  Since primitive property
<i>255</i>&nbsp;     * values cannot be wrapped with the {@code UIResource} marker, this method
<i>256</i>&nbsp;     * uses private state to determine whether the property has been set
<i>257</i>&nbsp;     * by the client.
<i>258</i>&nbsp;     *
<i>259</i>&nbsp;     * @throws IllegalArgumentException if the specified property is not
<i>260</i>&nbsp;     *         one which can be set using this method
<i>261</i>&nbsp;     * @throws ClassCastException if the property value has not been set
<i>262</i>&nbsp;     *         by the developer and the type does not match the property&#39;s type
<i>263</i>&nbsp;     * @throws NullPointerException if {@code c} is {@code null}, or the
<i>264</i>&nbsp;     *         named property has not been set by the developer and
<i>265</i>&nbsp;     *         {@code propertyValue} is {@code null}
<i>266</i>&nbsp;     * @param c target component to set the property on
<i>267</i>&nbsp;     * @param propertyName name of the property to set
<i>268</i>&nbsp;     * @param propertyValue value of the property
<i>269</i>&nbsp;     * @since 1.5
<i>270</i>&nbsp;     */
<i>271</i>&nbsp;    public static void installProperty(JComponent c,
<i>272</i>&nbsp;                                       String propertyName, Object propertyValue) {
<i>273</i>&nbsp;        // this is a special case because the JPasswordField&#39;s ancestor hierarchy
<i>274</i>&nbsp;        // includes a class outside of javax.swing, thus we cannot call setUIProperty
<b class="nc"><i>275</i>&nbsp;        // directly.</b>
<b class="nc"><i>276</i>&nbsp;        if (SunToolkit.isInstanceOf(c, &quot;javax.swing.JPasswordField&quot;)) {</b>
<b class="nc"><i>277</i>&nbsp;            if (!((JPasswordField)c).customSetUIProperty(propertyName, propertyValue)) {</b>
<i>278</i>&nbsp;                c.setUIProperty(propertyName, propertyValue);
<i>279</i>&nbsp;            }
<b class="nc"><i>280</i>&nbsp;        } else {</b>
<i>281</i>&nbsp;            c.setUIProperty(propertyName, propertyValue);
<i>282</i>&nbsp;        }
<i>283</i>&nbsp;    }
<i>284</i>&nbsp;
<i>285</i>&nbsp;    /**
<i>286</i>&nbsp;     * Convenience method for building an array of {@code
<i>287</i>&nbsp;     * KeyBindings}. While this method is not deprecated, developers
<i>288</i>&nbsp;     * should instead use {@code ActionMap} and {@code InputMap} for
<i>289</i>&nbsp;     * supplying key bindings.
<i>290</i>&nbsp;     * &lt;p&gt;
<i>291</i>&nbsp;     * This method returns an array of {@code KeyBindings}, one for each
<i>292</i>&nbsp;     * alternating {@code key-action} pair in {@code keyBindingList}.
<i>293</i>&nbsp;     * A {@code key} can either be a {@code String} in the format
<i>294</i>&nbsp;     * specified by the &lt;code&gt;KeyStroke.getKeyStroke&lt;/code&gt; method, or
<i>295</i>&nbsp;     * a {@code KeyStroke}. The {@code action} part of the pair is a
<i>296</i>&nbsp;     * {@code String} that corresponds to the name of the {@code
<i>297</i>&nbsp;     * Action}.
<i>298</i>&nbsp;     * &lt;p&gt;
<i>299</i>&nbsp;     * The following example illustrates creating a {@code KeyBinding} array
<i>300</i>&nbsp;     * from six alternating {@code key-action} pairs:
<i>301</i>&nbsp;     * &lt;pre&gt;
<i>302</i>&nbsp;     *  JTextComponent.KeyBinding[] multilineBindings = makeKeyBindings( new Object[] {
<i>303</i>&nbsp;     *          &quot;UP&quot;, DefaultEditorKit.upAction,
<i>304</i>&nbsp;     *        &quot;DOWN&quot;, DefaultEditorKit.downAction,
<i>305</i>&nbsp;     *     &quot;PAGE_UP&quot;, DefaultEditorKit.pageUpAction,
<i>306</i>&nbsp;     *   &quot;PAGE_DOWN&quot;, DefaultEditorKit.pageDownAction,
<i>307</i>&nbsp;     *       &quot;ENTER&quot;, DefaultEditorKit.insertBreakAction,
<i>308</i>&nbsp;     *         &quot;TAB&quot;, DefaultEditorKit.insertTabAction
<i>309</i>&nbsp;     *  });
<i>310</i>&nbsp;     * &lt;/pre&gt;
<i>311</i>&nbsp;     * If {@code keyBindingList&#39;s} length is odd, the last element is
<i>312</i>&nbsp;     * ignored.
<i>313</i>&nbsp;     * &lt;p&gt;
<i>314</i>&nbsp;     * Supplying a {@code null} value for either the {@code key} or
<i>315</i>&nbsp;     * {@code action} part of the {@code key-action} pair results in
<i>316</i>&nbsp;     * creating a {@code KeyBinding} with the corresponding value
<i>317</i>&nbsp;     * {@code null}. As other parts of Swing&#39;s expect {@code non-null} values
<i>318</i>&nbsp;     * in a {@code KeyBinding}, you should avoid supplying {@code null} as
<i>319</i>&nbsp;     * either the {@code key} or {@code action} part of the {@code key-action}
<i>320</i>&nbsp;     * pair.
<i>321</i>&nbsp;     *
<i>322</i>&nbsp;     * @param keyBindingList an array of {@code key-action} pairs
<i>323</i>&nbsp;     * @return an array of {@code KeyBindings}
<i>324</i>&nbsp;     * @throws NullPointerException if {@code keyBindingList} is {@code null}
<i>325</i>&nbsp;     * @throws ClassCastException if the {@code key} part of the pair is
<i>326</i>&nbsp;     *         not a {@code KeyStroke} or {@code String}, or the
<i>327</i>&nbsp;     *         {@code action} part of the pair is not a {@code String}
<i>328</i>&nbsp;     * @see ActionMap
<i>329</i>&nbsp;     * @see InputMap
<i>330</i>&nbsp;     * @see KeyStroke#getKeyStroke
<i>331</i>&nbsp;     */
<i>332</i>&nbsp;    public static JTextComponent.KeyBinding[] makeKeyBindings(Object[] keyBindingList)
<b class="nc"><i>333</i>&nbsp;    {</b>
<i>334</i>&nbsp;        JTextComponent.KeyBinding[] rv = new JTextComponent.KeyBinding[keyBindingList.length / 2];
<b class="nc"><i>335</i>&nbsp;</b>
<b class="nc"><i>336</i>&nbsp;        for(int i = 0; i &lt; rv.length; i ++) {</b>
<b class="nc"><i>337</i>&nbsp;            Object o = keyBindingList[2 * i];</b>
<i>338</i>&nbsp;            KeyStroke keystroke = (o instanceof KeyStroke)
<b class="nc"><i>339</i>&nbsp;                ? (KeyStroke) o</b>
<b class="nc"><i>340</i>&nbsp;                : KeyStroke.getKeyStroke((String) o);</b>
<b class="nc"><i>341</i>&nbsp;            String action = (String) keyBindingList[2 * i + 1];</b>
<i>342</i>&nbsp;            rv[i] = new JTextComponent.KeyBinding(keystroke, action);
<i>343</i>&nbsp;        }
<b class="nc"><i>344</i>&nbsp;</b>
<i>345</i>&nbsp;        return rv;
<i>346</i>&nbsp;    }
<i>347</i>&nbsp;
<i>348</i>&nbsp;    /**
<i>349</i>&nbsp;     * Creates an {@code InputMapUIResource} from &lt;code&gt;keys&lt;/code&gt;. This is
<i>350</i>&nbsp;     * a convenience method for creating a new {@code InputMapUIResource},
<i>351</i>&nbsp;     * invoking {@code loadKeyBindings(map, keys)}, and returning the
<i>352</i>&nbsp;     * {@code InputMapUIResource}.
<i>353</i>&nbsp;     *
<i>354</i>&nbsp;     * @param keys alternating pairs of {@code keystroke-action key}
<i>355</i>&nbsp;     *        pairs as described in {@link #loadKeyBindings}
<i>356</i>&nbsp;     * @return newly created and populated {@code InputMapUIResource}
<i>357</i>&nbsp;     * @see #loadKeyBindings
<i>358</i>&nbsp;     *
<i>359</i>&nbsp;     * @since 1.3
<i>360</i>&nbsp;     */
<b class="nc"><i>361</i>&nbsp;    public static InputMap makeInputMap(Object[] keys) {</b>
<b class="nc"><i>362</i>&nbsp;        InputMap retMap = new InputMapUIResource();</b>
<b class="nc"><i>363</i>&nbsp;        loadKeyBindings(retMap, keys);</b>
<i>364</i>&nbsp;        return retMap;
<i>365</i>&nbsp;    }
<i>366</i>&nbsp;
<i>367</i>&nbsp;    /**
<i>368</i>&nbsp;     * Creates a {@code ComponentInputMapUIResource} from
<i>369</i>&nbsp;     * &lt;code&gt;keys&lt;/code&gt;. This is a convenience method for creating a
<i>370</i>&nbsp;     * new {@code ComponentInputMapUIResource}, invoking {@code
<i>371</i>&nbsp;     * loadKeyBindings(map, keys)}, and returning the {@code
<i>372</i>&nbsp;     * ComponentInputMapUIResource}.
<i>373</i>&nbsp;     *
<i>374</i>&nbsp;     * @param c component to create the {@code ComponentInputMapUIResource}
<i>375</i>&nbsp;     *          with
<i>376</i>&nbsp;     * @param keys alternating pairs of {@code keystroke-action key}
<i>377</i>&nbsp;     *        pairs as described in {@link #loadKeyBindings}
<i>378</i>&nbsp;     * @return newly created and populated {@code InputMapUIResource}
<i>379</i>&nbsp;     * @throws IllegalArgumentException if {@code c} is {@code null}
<i>380</i>&nbsp;     *
<i>381</i>&nbsp;     * @see #loadKeyBindings
<i>382</i>&nbsp;     * @see ComponentInputMapUIResource
<i>383</i>&nbsp;     *
<i>384</i>&nbsp;     * @since 1.3
<i>385</i>&nbsp;     */
<i>386</i>&nbsp;    public static ComponentInputMap makeComponentInputMap(JComponent c,
<b class="nc"><i>387</i>&nbsp;                                                          Object[] keys) {</b>
<b class="nc"><i>388</i>&nbsp;        ComponentInputMap retMap = new ComponentInputMapUIResource(c);</b>
<b class="nc"><i>389</i>&nbsp;        loadKeyBindings(retMap, keys);</b>
<i>390</i>&nbsp;        return retMap;
<i>391</i>&nbsp;    }
<i>392</i>&nbsp;
<i>393</i>&nbsp;
<i>394</i>&nbsp;    /**
<i>395</i>&nbsp;     * Populates an {@code InputMap} with the specified bindings.
<i>396</i>&nbsp;     * The bindings are supplied as a list of alternating
<i>397</i>&nbsp;     * {@code keystroke-action key} pairs. The {@code keystroke} is either
<i>398</i>&nbsp;     * an instance of {@code KeyStroke}, or a {@code String}
<i>399</i>&nbsp;     * that identifies the {@code KeyStroke} for the binding. Refer
<i>400</i>&nbsp;     * to {@code KeyStroke.getKeyStroke(String)} for the specific
<i>401</i>&nbsp;     * format. The {@code action key} part of the pair is the key
<i>402</i>&nbsp;     * registered in the {@code InputMap} for the {@code KeyStroke}.
<i>403</i>&nbsp;     * &lt;p&gt;
<i>404</i>&nbsp;     * The following illustrates loading an {@code InputMap} with two
<i>405</i>&nbsp;     * {@code key-action} pairs:
<i>406</i>&nbsp;     * &lt;pre&gt;
<i>407</i>&nbsp;     *   LookAndFeel.loadKeyBindings(inputMap, new Object[] {
<i>408</i>&nbsp;     *     &quot;control X&quot;, &quot;cut&quot;,
<i>409</i>&nbsp;     *     &quot;control V&quot;, &quot;paste&quot;
<i>410</i>&nbsp;     *   });
<i>411</i>&nbsp;     * &lt;/pre&gt;
<i>412</i>&nbsp;     * &lt;p&gt;
<i>413</i>&nbsp;     * Supplying a {@code null} list of bindings ({@code keys}) does not
<i>414</i>&nbsp;     * change {@code retMap} in any way.
<i>415</i>&nbsp;     * &lt;p&gt;
<i>416</i>&nbsp;     * Specifying a {@code null} {@code action key} results in
<i>417</i>&nbsp;     * removing the {@code keystroke&#39;s} entry from the {@code InputMap}.
<i>418</i>&nbsp;     * A {@code null} {@code keystroke} is ignored.
<i>419</i>&nbsp;     *
<i>420</i>&nbsp;     * @param retMap {@code InputMap} to add the {@code key-action}
<i>421</i>&nbsp;     *               pairs to
<i>422</i>&nbsp;     * @param keys bindings to add to {@code retMap}
<i>423</i>&nbsp;     * @throws NullPointerException if {@code keys} is
<i>424</i>&nbsp;     *         {@code non-null}, not empty, and {@code retMap} is
<i>425</i>&nbsp;     *         {@code null}
<i>426</i>&nbsp;     *
<i>427</i>&nbsp;     * @see KeyStroke#getKeyStroke(String)
<i>428</i>&nbsp;     * @see InputMap
<i>429</i>&nbsp;     *
<i>430</i>&nbsp;     * @since 1.3
<i>431</i>&nbsp;     */
<b class="nc"><i>432</i>&nbsp;    public static void loadKeyBindings(InputMap retMap, Object[] keys) {</b>
<b class="nc"><i>433</i>&nbsp;        if (keys != null) {</b>
<b class="nc"><i>434</i>&nbsp;            for (int counter = 0, maxCounter = keys.length;</b>
<b class="nc"><i>435</i>&nbsp;                 counter &lt; maxCounter; counter++) {</b>
<b class="nc"><i>436</i>&nbsp;                Object keyStrokeO = keys[counter++];</b>
<i>437</i>&nbsp;                KeyStroke ks = (keyStrokeO instanceof KeyStroke) ?
<b class="nc"><i>438</i>&nbsp;                                (KeyStroke)keyStrokeO :</b>
<b class="nc"><i>439</i>&nbsp;                                KeyStroke.getKeyStroke((String)keyStrokeO);</b>
<i>440</i>&nbsp;                retMap.put(ks, keys[counter]);
<i>441</i>&nbsp;            }
<i>442</i>&nbsp;        }
<i>443</i>&nbsp;    }
<i>444</i>&nbsp;
<i>445</i>&nbsp;    /**
<i>446</i>&nbsp;     * Creates and returns a {@code UIDefault.LazyValue} that loads an
<i>447</i>&nbsp;     * image. The returned value is an implementation of {@code
<i>448</i>&nbsp;     * UIDefaults.LazyValue}. When {@code createValue} is invoked on
<i>449</i>&nbsp;     * the returned object, the image is loaded. If the image is {@code
<i>450</i>&nbsp;     * non-null}, it is then wrapped in an {@code Icon} that implements {@code
<i>451</i>&nbsp;     * UIResource}. The image is loaded using {@code
<i>452</i>&nbsp;     * Class.getResourceAsStream(gifFile)}.
<i>453</i>&nbsp;     * &lt;p&gt;
<i>454</i>&nbsp;     * This method does not check the arguments in any way. It is
<i>455</i>&nbsp;     * strongly recommended that {@code non-null} values are supplied else
<i>456</i>&nbsp;     * exceptions may occur when {@code createValue} is invoked on the
<i>457</i>&nbsp;     * returned object.
<i>458</i>&nbsp;     *
<i>459</i>&nbsp;     * @param baseClass {@code Class} used to load the resource
<i>460</i>&nbsp;     * @param gifFile path to the image to load
<i>461</i>&nbsp;     * @return a {@code UIDefaults.LazyValue}; when resolved the
<i>462</i>&nbsp;     *         {@code LazyValue} loads the specified image
<i>463</i>&nbsp;     * @see UIDefaults.LazyValue
<i>464</i>&nbsp;     * @see Icon
<i>465</i>&nbsp;     * @see Class#getResourceAsStream(String)
<i>466</i>&nbsp;     */
<b class="nc"><i>467</i>&nbsp;    public static Object makeIcon(final Class&lt;?&gt; baseClass, final String gifFile) {</b>
<i>468</i>&nbsp;        return SwingUtilities2.makeIcon_Unprivileged(baseClass, baseClass, gifFile);
<i>469</i>&nbsp;    }
<i>470</i>&nbsp;
<i>471</i>&nbsp;    /**
<i>472</i>&nbsp;     * Returns the &lt;code&gt;LayoutStyle&lt;/code&gt; for this look
<i>473</i>&nbsp;     * and feel.  This never returns {@code null}.
<i>474</i>&nbsp;     * &lt;p&gt;
<i>475</i>&nbsp;     * You generally don&#39;t use the &lt;code&gt;LayoutStyle&lt;/code&gt; from
<i>476</i>&nbsp;     * the look and feel, instead use the &lt;code&gt;LayoutStyle&lt;/code&gt;
<i>477</i>&nbsp;     * method &lt;code&gt;getInstance&lt;/code&gt;.
<i>478</i>&nbsp;     *
<i>479</i>&nbsp;     * @see LayoutStyle#getInstance
<i>480</i>&nbsp;     * @return the &lt;code&gt;LayoutStyle&lt;/code&gt; for this look and feel
<i>481</i>&nbsp;     * @since 1.6
<i>482</i>&nbsp;     */
<b class="nc"><i>483</i>&nbsp;    public LayoutStyle getLayoutStyle() {</b>
<i>484</i>&nbsp;        return DefaultLayoutStyle.getInstance();
<i>485</i>&nbsp;    }
<i>486</i>&nbsp;
<i>487</i>&nbsp;    /**
<i>488</i>&nbsp;     * Invoked when the user attempts an invalid operation,
<i>489</i>&nbsp;     * such as pasting into an uneditable &lt;code&gt;JTextField&lt;/code&gt;
<i>490</i>&nbsp;     * that has focus. The default implementation beeps. Subclasses
<i>491</i>&nbsp;     * that wish different behavior should override this and provide
<i>492</i>&nbsp;     * the additional feedback.
<i>493</i>&nbsp;     *
<i>494</i>&nbsp;     * @param component the &lt;code&gt;Component&lt;/code&gt; the error occurred in,
<i>495</i>&nbsp;     *                  may be &lt;code&gt;null&lt;/code&gt;
<i>496</i>&nbsp;     *                  indicating the error condition is not directly
<i>497</i>&nbsp;     *                  associated with a &lt;code&gt;Component&lt;/code&gt;
<i>498</i>&nbsp;     * @since 1.4
<i>499</i>&nbsp;     */
<b class="nc"><i>500</i>&nbsp;    public void provideErrorFeedback(Component component) {</b>
<b class="nc"><i>501</i>&nbsp;        Toolkit toolkit = null;</b>
<b class="nc"><i>502</i>&nbsp;        if (component != null) {</b>
<i>503</i>&nbsp;            toolkit = component.getToolkit();
<b class="nc"><i>504</i>&nbsp;        } else {</b>
<i>505</i>&nbsp;            toolkit = Toolkit.getDefaultToolkit();
<b class="nc"><i>506</i>&nbsp;        }</b>
<i>507</i>&nbsp;        toolkit.beep();
<i>508</i>&nbsp;    } // provideErrorFeedback()
<i>509</i>&nbsp;
<i>510</i>&nbsp;    /**
<i>511</i>&nbsp;     * Returns the value of the specified system desktop property by
<i>512</i>&nbsp;     * invoking &lt;code&gt;Toolkit.getDefaultToolkit().getDesktopProperty()&lt;/code&gt;.
<i>513</i>&nbsp;     * If the value of the specified property is {@code null},
<i>514</i>&nbsp;     * {@code fallbackValue} is returned.
<i>515</i>&nbsp;     *
<i>516</i>&nbsp;     * @param systemPropertyName the name of the system desktop property being queried
<i>517</i>&nbsp;     * @param fallbackValue the object to be returned as the value if the system value is null
<i>518</i>&nbsp;     * @return the current value of the desktop property
<i>519</i>&nbsp;     *
<i>520</i>&nbsp;     * @see java.awt.Toolkit#getDesktopProperty
<i>521</i>&nbsp;     *
<i>522</i>&nbsp;     * @since 1.4
<i>523</i>&nbsp;     */
<b class="nc"><i>524</i>&nbsp;    public static Object getDesktopPropertyValue(String systemPropertyName, Object fallbackValue) {</b>
<b class="nc"><i>525</i>&nbsp;        Object value = Toolkit.getDefaultToolkit().getDesktopProperty(systemPropertyName);</b>
<b class="nc"><i>526</i>&nbsp;        if (value == null) {</b>
<b class="nc"><i>527</i>&nbsp;            return fallbackValue;</b>
<b class="nc"><i>528</i>&nbsp;        } else if (value instanceof Color) {</b>
<b class="nc"><i>529</i>&nbsp;            return new ColorUIResource((Color)value);</b>
<b class="nc"><i>530</i>&nbsp;        } else if (value instanceof Font) {</b>
<i>531</i>&nbsp;            return new FontUIResource((Font)value);
<b class="nc"><i>532</i>&nbsp;        }</b>
<i>533</i>&nbsp;        return value;
<i>534</i>&nbsp;    }
<i>535</i>&nbsp;
<i>536</i>&nbsp;    /**
<i>537</i>&nbsp;     * Returns an &lt;code&gt;Icon&lt;/code&gt; with a disabled appearance.
<i>538</i>&nbsp;     * This method is used to generate a disabled &lt;code&gt;Icon&lt;/code&gt; when
<i>539</i>&nbsp;     * one has not been specified.  For example, if you create a
<i>540</i>&nbsp;     * &lt;code&gt;JButton&lt;/code&gt; and only specify an &lt;code&gt;Icon&lt;/code&gt; via
<i>541</i>&nbsp;     * &lt;code&gt;setIcon&lt;/code&gt; this method will be called to generate the
<i>542</i>&nbsp;     * disabled &lt;code&gt;Icon&lt;/code&gt;. If {@code null} is passed as
<i>543</i>&nbsp;     * &lt;code&gt;icon&lt;/code&gt; this method returns {@code null}.
<i>544</i>&nbsp;     * &lt;p&gt;
<i>545</i>&nbsp;     * Some look and feels might not render the disabled {@code Icon}, in which
<i>546</i>&nbsp;     * case they will ignore this.
<i>547</i>&nbsp;     *
<i>548</i>&nbsp;     * @param component {@code JComponent} that will display the {@code Icon},
<i>549</i>&nbsp;     *         may be {@code null}
<i>550</i>&nbsp;     * @param icon {@code Icon} to generate the disabled icon from
<i>551</i>&nbsp;     * @return disabled {@code Icon}, or {@code null} if a suitable
<i>552</i>&nbsp;     *         {@code Icon} can not be generated
<i>553</i>&nbsp;     * @since 1.5
<i>554</i>&nbsp;     */
<b class="nc"><i>555</i>&nbsp;    public Icon getDisabledIcon(JComponent component, Icon icon) {</b>
<b class="nc"><i>556</i>&nbsp;        if (icon instanceof ImageIcon) {</b>
<b class="nc"><i>557</i>&nbsp;            return new ImageIconUIResource(GrayFilter.</b>
<i>558</i>&nbsp;                   createDisabledImage(((ImageIcon)icon).getImage()));
<b class="nc"><i>559</i>&nbsp;        }</b>
<i>560</i>&nbsp;        return null;
<i>561</i>&nbsp;    }
<i>562</i>&nbsp;
<i>563</i>&nbsp;    /**
<i>564</i>&nbsp;     * Returns an &lt;code&gt;Icon&lt;/code&gt; for use by disabled
<i>565</i>&nbsp;     * components that are also selected. This method is used to generate an
<i>566</i>&nbsp;     * &lt;code&gt;Icon&lt;/code&gt; for components that are in both the disabled and
<i>567</i>&nbsp;     * selected states but do not have a specific &lt;code&gt;Icon&lt;/code&gt; for this
<i>568</i>&nbsp;     * state.  For example, if you create a &lt;code&gt;JButton&lt;/code&gt; and only
<i>569</i>&nbsp;     * specify an &lt;code&gt;Icon&lt;/code&gt; via &lt;code&gt;setIcon&lt;/code&gt; this method
<i>570</i>&nbsp;     * will be called to generate the disabled and selected
<i>571</i>&nbsp;     * &lt;code&gt;Icon&lt;/code&gt;. If {@code null} is passed as &lt;code&gt;icon&lt;/code&gt; this
<i>572</i>&nbsp;     * methods returns {@code null}.
<i>573</i>&nbsp;     * &lt;p&gt;
<i>574</i>&nbsp;     * Some look and feels might not render the disabled and selected
<i>575</i>&nbsp;     * {@code Icon}, in which case they will ignore this.
<i>576</i>&nbsp;     *
<i>577</i>&nbsp;     * @param component {@code JComponent} that will display the {@code Icon},
<i>578</i>&nbsp;     *        may be {@code null}
<i>579</i>&nbsp;     * @param icon {@code Icon} to generate disabled and selected icon from
<i>580</i>&nbsp;     * @return disabled and selected icon, or {@code null} if a suitable
<i>581</i>&nbsp;     *         {@code Icon} can not be generated.
<i>582</i>&nbsp;     * @since 1.5
<i>583</i>&nbsp;     */
<b class="nc"><i>584</i>&nbsp;    public Icon getDisabledSelectedIcon(JComponent component, Icon icon) {</b>
<i>585</i>&nbsp;        return getDisabledIcon(component, icon);
<i>586</i>&nbsp;    }
<i>587</i>&nbsp;
<i>588</i>&nbsp;    /**
<i>589</i>&nbsp;     * Return a short string that identifies this look and feel, e.g.
<i>590</i>&nbsp;     * &quot;CDE/Motif&quot;.  This string should be appropriate for a menu item.
<i>591</i>&nbsp;     * Distinct look and feels should have different names, e.g.
<i>592</i>&nbsp;     * a subclass of MotifLookAndFeel that changes the way a few components
<i>593</i>&nbsp;     * are rendered should be called &quot;CDE/Motif My Way&quot;; something
<i>594</i>&nbsp;     * that would be useful to a user trying to select a L&amp;amp;F from a list
<i>595</i>&nbsp;     * of names.
<i>596</i>&nbsp;     *
<i>597</i>&nbsp;     * @return short identifier for the look and feel
<i>598</i>&nbsp;     */
<i>599</i>&nbsp;    public abstract String getName();
<i>600</i>&nbsp;
<i>601</i>&nbsp;
<i>602</i>&nbsp;    /**
<i>603</i>&nbsp;     * Return a string that identifies this look and feel.  This string
<i>604</i>&nbsp;     * will be used by applications/services that want to recognize
<i>605</i>&nbsp;     * well known look and feel implementations.  Presently
<i>606</i>&nbsp;     * the well known names are &quot;Motif&quot;, &quot;Windows&quot;, &quot;Mac&quot;, &quot;Metal&quot;.  Note
<i>607</i>&nbsp;     * that a LookAndFeel derived from a well known superclass
<i>608</i>&nbsp;     * that doesn&#39;t make any fundamental changes to the look or feel
<i>609</i>&nbsp;     * shouldn&#39;t override this method.
<i>610</i>&nbsp;     *
<i>611</i>&nbsp;     * @return identifier for the look and feel
<i>612</i>&nbsp;     */
<i>613</i>&nbsp;    public abstract String getID();
<i>614</i>&nbsp;
<i>615</i>&nbsp;
<i>616</i>&nbsp;    /**
<i>617</i>&nbsp;     * Return a one line description of this look and feel implementation,
<i>618</i>&nbsp;     * e.g. &quot;The CDE/Motif Look and Feel&quot;.   This string is intended for
<i>619</i>&nbsp;     * the user, e.g. in the title of a window or in a ToolTip message.
<i>620</i>&nbsp;     *
<i>621</i>&nbsp;     * @return short description for the look and feel
<i>622</i>&nbsp;     */
<i>623</i>&nbsp;    public abstract String getDescription();
<i>624</i>&nbsp;
<i>625</i>&nbsp;
<i>626</i>&nbsp;    /**
<i>627</i>&nbsp;     * Returns {@code true} if the &lt;code&gt;LookAndFeel&lt;/code&gt; returned
<i>628</i>&nbsp;     * &lt;code&gt;RootPaneUI&lt;/code&gt; instances support providing {@code Window}
<i>629</i>&nbsp;     * decorations in a &lt;code&gt;JRootPane&lt;/code&gt;.
<i>630</i>&nbsp;     * &lt;p&gt;
<i>631</i>&nbsp;     * The default implementation returns {@code false}, subclasses that
<i>632</i>&nbsp;     * support {@code Window} decorations should override this and return
<i>633</i>&nbsp;     * {@code true}.
<i>634</i>&nbsp;     *
<i>635</i>&nbsp;     * @return {@code true} if the {@code RootPaneUI} instances created by
<i>636</i>&nbsp;     *         this look and feel support client side decorations
<i>637</i>&nbsp;     * @see JDialog#setDefaultLookAndFeelDecorated
<i>638</i>&nbsp;     * @see JFrame#setDefaultLookAndFeelDecorated
<i>639</i>&nbsp;     * @see JRootPane#setWindowDecorationStyle
<i>640</i>&nbsp;     * @since 1.4
<i>641</i>&nbsp;     */
<b class="nc"><i>642</i>&nbsp;    public boolean getSupportsWindowDecorations() {</b>
<i>643</i>&nbsp;        return false;
<i>644</i>&nbsp;    }
<i>645</i>&nbsp;
<i>646</i>&nbsp;    /**
<i>647</i>&nbsp;     * If the underlying platform has a &quot;native&quot; look and feel, and
<i>648</i>&nbsp;     * this is an implementation of it, return {@code true}.  For
<i>649</i>&nbsp;     * example, when the underlying platform is Solaris running CDE
<i>650</i>&nbsp;     * a CDE/Motif look and feel implementation would return {@code
<i>651</i>&nbsp;     * true}.
<i>652</i>&nbsp;     *
<i>653</i>&nbsp;     * @return {@code true} if this look and feel represents the underlying
<i>654</i>&nbsp;     *         platform look and feel
<i>655</i>&nbsp;     */
<i>656</i>&nbsp;    public abstract boolean isNativeLookAndFeel();
<i>657</i>&nbsp;
<i>658</i>&nbsp;
<i>659</i>&nbsp;    /**
<i>660</i>&nbsp;     * Return {@code true} if the underlying platform supports and or permits
<i>661</i>&nbsp;     * this look and feel.  This method returns {@code false} if the look
<i>662</i>&nbsp;     * and feel depends on special resources or legal agreements that
<i>663</i>&nbsp;     * aren&#39;t defined for the current platform.
<i>664</i>&nbsp;     *
<i>665</i>&nbsp;     *
<i>666</i>&nbsp;     * @return {@code true} if this is a supported look and feel
<i>667</i>&nbsp;     * @see UIManager#setLookAndFeel
<i>668</i>&nbsp;     */
<i>669</i>&nbsp;    public abstract boolean isSupportedLookAndFeel();
<i>670</i>&nbsp;
<i>671</i>&nbsp;
<i>672</i>&nbsp;    /**
<i>673</i>&nbsp;     * Initializes the look and feel. While this method is public,
<i>674</i>&nbsp;     * it should only be invoked by the {@code UIManager} when a
<i>675</i>&nbsp;     * look and feel is installed as the current look and feel. This
<i>676</i>&nbsp;     * method is invoked before the {@code UIManager} invokes
<i>677</i>&nbsp;     * {@code getDefaults}. This method is intended to perform any
<i>678</i>&nbsp;     * initialization for the look and feel. Subclasses
<i>679</i>&nbsp;     * should do any one-time setup they need here, rather than
<i>680</i>&nbsp;     * in a static initializer, because look and feel class objects
<i>681</i>&nbsp;     * may be loaded just to discover that {@code isSupportedLookAndFeel()}
<i>682</i>&nbsp;     * returns {@code false}.
<i>683</i>&nbsp;     *
<i>684</i>&nbsp;     * @see #uninitialize
<i>685</i>&nbsp;     * @see UIManager#setLookAndFeel
<i>686</i>&nbsp;     */
<i>687</i>&nbsp;    public void initialize() {
<i>688</i>&nbsp;    }
<i>689</i>&nbsp;
<i>690</i>&nbsp;
<i>691</i>&nbsp;    /**
<i>692</i>&nbsp;     * Uninitializes the look and feel. While this method is public,
<i>693</i>&nbsp;     * it should only be invoked by the {@code UIManager} when
<i>694</i>&nbsp;     * the look and feel is uninstalled. For example,
<i>695</i>&nbsp;     * {@code UIManager.setLookAndFeel} invokes this when the look and
<i>696</i>&nbsp;     * feel is changed.
<i>697</i>&nbsp;     * &lt;p&gt;
<i>698</i>&nbsp;     * Subclasses may choose to free up some resources here.
<i>699</i>&nbsp;     *
<i>700</i>&nbsp;     * @see #initialize
<i>701</i>&nbsp;     * @see UIManager#setLookAndFeel
<i>702</i>&nbsp;     */
<i>703</i>&nbsp;    public void uninitialize() {
<i>704</i>&nbsp;    }
<i>705</i>&nbsp;
<i>706</i>&nbsp;    /**
<i>707</i>&nbsp;     * Returns the look and feel defaults. While this method is public,
<i>708</i>&nbsp;     * it should only be invoked by the {@code UIManager} when the
<i>709</i>&nbsp;     * look and feel is set as the current look and feel and after
<i>710</i>&nbsp;     * {@code initialize} has been invoked.
<i>711</i>&nbsp;     *
<i>712</i>&nbsp;     * @return the look and feel defaults
<i>713</i>&nbsp;     * @see #initialize
<i>714</i>&nbsp;     * @see #uninitialize
<i>715</i>&nbsp;     * @see UIManager#setLookAndFeel
<i>716</i>&nbsp;     */
<b class="nc"><i>717</i>&nbsp;    public UIDefaults getDefaults() {</b>
<i>718</i>&nbsp;        return null;
<i>719</i>&nbsp;    }
<i>720</i>&nbsp;
<i>721</i>&nbsp;    /**
<i>722</i>&nbsp;     * Returns a string that displays and identifies this
<i>723</i>&nbsp;     * object&#39;s properties.
<i>724</i>&nbsp;     *
<i>725</i>&nbsp;     * @return a String representation of this object
<i>726</i>&nbsp;     */
<b class="nc"><i>727</i>&nbsp;    public String toString() {</b>
<i>728</i>&nbsp;        return &quot;[&quot; + getDescription() + &quot; - &quot; + getClass().getName() + &quot;]&quot;;
<i>729</i>&nbsp;    }
<i>730</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
