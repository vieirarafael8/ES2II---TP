


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: JTree</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing</a> ]
</div>

<h1>Coverage Summary for Class: JTree (javax.swing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JTree</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 156)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 855)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JTree$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$AccessibleJTree</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 142)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$AccessibleJTree$AccessibleJTreeNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 377)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$DropLocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$DynamicUtilTreeNode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$EmptySelectionModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$TreeModelHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$TreeSelectionRedirector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTree$TreeTimer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 263)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1477)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.awt.*;
<i>28</i>&nbsp;import java.awt.event.*;
<i>29</i>&nbsp;import java.beans.JavaBean;
<i>30</i>&nbsp;import java.beans.BeanProperty;
<i>31</i>&nbsp;import java.beans.ConstructorProperties;
<i>32</i>&nbsp;import java.beans.PropertyChangeEvent;
<i>33</i>&nbsp;import java.beans.PropertyChangeListener;
<i>34</i>&nbsp;import java.io.*;
<i>35</i>&nbsp;import java.util.*;
<i>36</i>&nbsp;import javax.swing.event.*;
<i>37</i>&nbsp;import javax.swing.plaf.*;
<i>38</i>&nbsp;import javax.swing.tree.*;
<i>39</i>&nbsp;import javax.swing.text.Position;
<i>40</i>&nbsp;import javax.accessibility.*;
<i>41</i>&nbsp;
<i>42</i>&nbsp;import sun.awt.AWTAccessor;
<i>43</i>&nbsp;import sun.awt.AWTAccessor.MouseEventAccessor;
<i>44</i>&nbsp;import sun.swing.SwingUtilities2;
<i>45</i>&nbsp;import sun.swing.SwingUtilities2.Section;
<i>46</i>&nbsp;import static sun.swing.SwingUtilities2.Section.*;
<i>47</i>&nbsp;
<i>48</i>&nbsp;/**
<i>49</i>&nbsp; * A control that displays a set of hierarchical data as an outline.
<i>50</i>&nbsp; * You can find task-oriented documentation and examples of using trees in
<i>51</i>&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;,
<i>52</i>&nbsp; * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
<i>53</i>&nbsp; * &lt;p&gt;
<i>54</i>&nbsp; * A specific node in a tree can be identified either by a
<i>55</i>&nbsp; * &lt;code&gt;TreePath&lt;/code&gt; (an object
<i>56</i>&nbsp; * that encapsulates a node and all of its ancestors), or by its
<i>57</i>&nbsp; * display row, where each row in the display area displays one node.
<i>58</i>&nbsp; * An &lt;i&gt;expanded&lt;/i&gt; node is a non-leaf node (as identified by
<i>59</i>&nbsp; * &lt;code&gt;TreeModel.isLeaf(node)&lt;/code&gt; returning false) that will displays
<i>60</i>&nbsp; * its children when all its ancestors are &lt;i&gt;expanded&lt;/i&gt;.
<i>61</i>&nbsp; * A &lt;i&gt;collapsed&lt;/i&gt;
<i>62</i>&nbsp; * node is one which hides them. A &lt;i&gt;hidden&lt;/i&gt; node is one which is
<i>63</i>&nbsp; * under a collapsed ancestor. All of a &lt;i&gt;viewable&lt;/i&gt; nodes parents
<i>64</i>&nbsp; * are expanded, but may or may not be displayed. A &lt;i&gt;displayed&lt;/i&gt; node
<i>65</i>&nbsp; * is both viewable and in the display area, where it can be seen.
<i>66</i>&nbsp; * &lt;/p&gt;
<i>67</i>&nbsp; * The following &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean &quot;displayed&quot;:
<i>68</i>&nbsp; * &lt;ul&gt;
<i>69</i>&nbsp; * &lt;li&gt;&lt;code&gt;isRootVisible()&lt;/code&gt;
<i>70</i>&nbsp; * &lt;li&gt;&lt;code&gt;setRootVisible()&lt;/code&gt;
<i>71</i>&nbsp; * &lt;li&gt;&lt;code&gt;scrollPathToVisible()&lt;/code&gt;
<i>72</i>&nbsp; * &lt;li&gt;&lt;code&gt;scrollRowToVisible()&lt;/code&gt;
<i>73</i>&nbsp; * &lt;li&gt;&lt;code&gt;getVisibleRowCount()&lt;/code&gt;
<i>74</i>&nbsp; * &lt;li&gt;&lt;code&gt;setVisibleRowCount()&lt;/code&gt;
<i>75</i>&nbsp; * &lt;/ul&gt;
<i>76</i>&nbsp; * The next group of &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean
<i>77</i>&nbsp; * &quot;viewable&quot; (under an expanded parent):
<i>78</i>&nbsp; * &lt;ul&gt;
<i>79</i>&nbsp; * &lt;li&gt;&lt;code&gt;isVisible()&lt;/code&gt;
<i>80</i>&nbsp; * &lt;li&gt;&lt;code&gt;makeVisible()&lt;/code&gt;
<i>81</i>&nbsp; * &lt;/ul&gt;
<i>82</i>&nbsp; * If you are interested in knowing when the selection changes implement
<i>83</i>&nbsp; * the &lt;code&gt;TreeSelectionListener&lt;/code&gt; interface and add the instance
<i>84</i>&nbsp; * using the method &lt;code&gt;addTreeSelectionListener&lt;/code&gt;.
<i>85</i>&nbsp; * &lt;code&gt;valueChanged&lt;/code&gt; will be invoked when the
<i>86</i>&nbsp; * selection changes, that is if the user clicks twice on the same
<i>87</i>&nbsp; * node &lt;code&gt;valueChanged&lt;/code&gt; will only be invoked once.
<i>88</i>&nbsp; * &lt;p&gt;
<i>89</i>&nbsp; * If you are interested in detecting either double-click events or when
<i>90</i>&nbsp; * a user clicks on a node, regardless of whether or not it was selected,
<i>91</i>&nbsp; * we recommend you do the following:
<i>92</i>&nbsp; * &lt;/p&gt;
<i>93</i>&nbsp; * &lt;pre&gt;
<i>94</i>&nbsp; * final JTree tree = ...;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * MouseListener ml = new MouseAdapter() {
<i>97</i>&nbsp; *     public void &lt;b&gt;mousePressed&lt;/b&gt;(MouseEvent e) {
<i>98</i>&nbsp; *         int selRow = tree.getRowForLocation(e.getX(), e.getY());
<i>99</i>&nbsp; *         TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
<i>100</i>&nbsp; *         if(selRow != -1) {
<i>101</i>&nbsp; *             if(e.getClickCount() == 1) {
<i>102</i>&nbsp; *                 mySingleClick(selRow, selPath);
<i>103</i>&nbsp; *             }
<i>104</i>&nbsp; *             else if(e.getClickCount() == 2) {
<i>105</i>&nbsp; *                 myDoubleClick(selRow, selPath);
<i>106</i>&nbsp; *             }
<i>107</i>&nbsp; *         }
<i>108</i>&nbsp; *     }
<i>109</i>&nbsp; * };
<i>110</i>&nbsp; * tree.addMouseListener(ml);
<i>111</i>&nbsp; * &lt;/pre&gt;
<i>112</i>&nbsp; * NOTE: This example obtains both the path and row, but you only need to
<i>113</i>&nbsp; * get the one you&#39;re interested in.
<i>114</i>&nbsp; * &lt;p&gt;
<i>115</i>&nbsp; * To use &lt;code&gt;JTree&lt;/code&gt; to display compound nodes
<i>116</i>&nbsp; * (for example, nodes containing both
<i>117</i>&nbsp; * a graphic icon and text), subclass {@link TreeCellRenderer} and use
<i>118</i>&nbsp; * {@link #setCellRenderer} to tell the tree to use it. To edit such nodes,
<i>119</i>&nbsp; * subclass {@link TreeCellEditor} and use {@link #setCellEditor}.
<i>120</i>&nbsp; * &lt;/p&gt;
<i>121</i>&nbsp; * &lt;p&gt;
<i>122</i>&nbsp; * Like all &lt;code&gt;JComponent&lt;/code&gt; classes, you can use {@link InputMap} and
<i>123</i>&nbsp; * {@link ActionMap}
<i>124</i>&nbsp; * to associate an {@link Action} object with a {@link KeyStroke}
<i>125</i>&nbsp; * and execute the action under specified conditions.
<i>126</i>&nbsp; * &lt;/p&gt;
<i>127</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
<i>128</i>&nbsp; * information see &lt;a
<i>129</i>&nbsp; * href=&quot;package-summary.html#threading&quot;&gt;Swing&#39;s Threading
<i>130</i>&nbsp; * Policy&lt;/a&gt;.
<i>131</i>&nbsp; * &lt;p&gt;
<i>132</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>133</i>&nbsp; * Serialized objects of this class will not be compatible with
<i>134</i>&nbsp; * future Swing releases. The current serialization support is
<i>135</i>&nbsp; * appropriate for short term storage or RMI between applications running
<i>136</i>&nbsp; * the same version of Swing.  As of 1.4, support for long term storage
<i>137</i>&nbsp; * of all JavaBeans&amp;trade;
<i>138</i>&nbsp; * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>139</i>&nbsp; * Please see {@link java.beans.XMLEncoder}.
<i>140</i>&nbsp; *&lt;/p&gt;
<i>141</i>&nbsp; *
<i>142</i>&nbsp; * @author Rob Davis
<i>143</i>&nbsp; * @author Ray Ryan
<i>144</i>&nbsp; * @author Scott Violet
<b class="nc"><i>145</i>&nbsp; * @since 1.2</b>
<b class="nc"><i>146</i>&nbsp; */</b>
<i>147</i>&nbsp;@JavaBean(defaultProperty = &quot;UI&quot;, description = &quot;A component that displays a set of hierarchical data as an outline.&quot;)
<i>148</i>&nbsp;@SwingContainer(false)
<i>149</i>&nbsp;@SuppressWarnings(&quot;serial&quot;)
<i>150</i>&nbsp;public class JTree extends JComponent implements Scrollable, Accessible
<i>151</i>&nbsp;{
<i>152</i>&nbsp;    /**
<i>153</i>&nbsp;     * @see #getUIClassID
<i>154</i>&nbsp;     * @see #readObject
<i>155</i>&nbsp;     */
<i>156</i>&nbsp;    private static final String uiClassID = &quot;TreeUI&quot;;
<i>157</i>&nbsp;
<i>158</i>&nbsp;    /**
<i>159</i>&nbsp;     * The model that defines the tree displayed by this object.
<i>160</i>&nbsp;     */
<i>161</i>&nbsp;    protected transient TreeModel        treeModel;
<i>162</i>&nbsp;
<i>163</i>&nbsp;    /**
<i>164</i>&nbsp;     * Models the set of selected nodes in this tree.
<i>165</i>&nbsp;     */
<i>166</i>&nbsp;    protected transient TreeSelectionModel selectionModel;
<i>167</i>&nbsp;
<i>168</i>&nbsp;    /**
<i>169</i>&nbsp;     * True if the root node is displayed, false if its children are
<i>170</i>&nbsp;     * the highest visible nodes.
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    protected boolean                    rootVisible;
<i>173</i>&nbsp;
<i>174</i>&nbsp;    /**
<i>175</i>&nbsp;     * The cell used to draw nodes. If &lt;code&gt;null&lt;/code&gt;, the UI uses a default
<i>176</i>&nbsp;     * &lt;code&gt;cellRenderer&lt;/code&gt;.
<i>177</i>&nbsp;     */
<i>178</i>&nbsp;    protected transient TreeCellRenderer  cellRenderer;
<i>179</i>&nbsp;
<i>180</i>&nbsp;    /**
<b class="nc"><i>181</i>&nbsp;     * Height to use for each display row. If this is &amp;lt;= 0 the renderer</b>
<i>182</i>&nbsp;     * determines the height for each row.
<i>183</i>&nbsp;     */
<i>184</i>&nbsp;    protected int                         rowHeight;
<i>185</i>&nbsp;    private boolean                       rowHeightSet = false;
<i>186</i>&nbsp;
<i>187</i>&nbsp;    /**
<i>188</i>&nbsp;     * Maps from &lt;code&gt;TreePath&lt;/code&gt; to &lt;code&gt;Boolean&lt;/code&gt;
<i>189</i>&nbsp;     * indicating whether or not the
<i>190</i>&nbsp;     * particular path is expanded. This ONLY indicates whether a
<i>191</i>&nbsp;     * given path is expanded, and NOT if it is visible or not. That
<i>192</i>&nbsp;     * information must be determined by visiting all the parent
<i>193</i>&nbsp;     * paths and seeing if they are visible.
<i>194</i>&nbsp;     */
<i>195</i>&nbsp;    private transient Hashtable&lt;TreePath, Boolean&gt; expandedState;
<i>196</i>&nbsp;
<i>197</i>&nbsp;
<i>198</i>&nbsp;    /**
<i>199</i>&nbsp;     * True if handles are displayed at the topmost level of the tree.
<i>200</i>&nbsp;     * &lt;p&gt;
<i>201</i>&nbsp;     * A handle is a small icon that displays adjacent to the node which
<i>202</i>&nbsp;     * allows the user to click once to expand or collapse the node. A
<i>203</i>&nbsp;     * common interface shows a plus sign (+) for a node which can be
<i>204</i>&nbsp;     * expanded and a minus sign (-) for a node which can be collapsed.
<i>205</i>&nbsp;     * Handles are always shown for nodes below the topmost level.
<i>206</i>&nbsp;     * &lt;p&gt;
<i>207</i>&nbsp;     * If the &lt;code&gt;rootVisible&lt;/code&gt; setting specifies that the root
<i>208</i>&nbsp;     * node is to be displayed, then that is the only node at the topmost
<i>209</i>&nbsp;     * level. If the root node is not displayed, then all of its
<i>210</i>&nbsp;     * children are at the topmost level of the tree. Handles are
<i>211</i>&nbsp;     * always displayed for nodes other than the topmost.
<i>212</i>&nbsp;     * &lt;p&gt;
<i>213</i>&nbsp;     * If the root node isn&#39;t visible, it is generally a good to make
<i>214</i>&nbsp;     * this value true. Otherwise, the tree looks exactly like a list,
<i>215</i>&nbsp;     * and users may not know that the &quot;list entries&quot; are actually
<i>216</i>&nbsp;     * tree nodes.
<b class="nc"><i>217</i>&nbsp;     *</b>
<i>218</i>&nbsp;     * @see #rootVisible
<i>219</i>&nbsp;     */
<i>220</i>&nbsp;    protected boolean           showsRootHandles;
<i>221</i>&nbsp;    private boolean             showsRootHandlesSet = false;
<i>222</i>&nbsp;
<i>223</i>&nbsp;    /**
<i>224</i>&nbsp;     * Creates a new event and passed it off the
<i>225</i>&nbsp;     * &lt;code&gt;selectionListeners&lt;/code&gt;.
<i>226</i>&nbsp;     */
<i>227</i>&nbsp;    protected transient TreeSelectionRedirector selectionRedirector;
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Editor for the entries.  Default is &lt;code&gt;null&lt;/code&gt;
<i>231</i>&nbsp;     * (tree is not editable).
<i>232</i>&nbsp;     */
<i>233</i>&nbsp;    protected transient TreeCellEditor          cellEditor;
<i>234</i>&nbsp;
<i>235</i>&nbsp;    /**
<i>236</i>&nbsp;     * Is the tree editable? Default is false.
<i>237</i>&nbsp;     */
<i>238</i>&nbsp;    protected boolean                 editable;
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /**
<i>241</i>&nbsp;     * Is this tree a large model? This is a code-optimization setting.
<i>242</i>&nbsp;     * A large model can be used when the cell height is the same for all
<i>243</i>&nbsp;     * nodes. The UI will then cache very little information and instead
<i>244</i>&nbsp;     * continually message the model. Without a large model the UI caches
<i>245</i>&nbsp;     * most of the information, resulting in fewer method calls to the model.
<i>246</i>&nbsp;     * &lt;p&gt;
<i>247</i>&nbsp;     * This value is only a suggestion to the UI. Not all UIs will
<i>248</i>&nbsp;     * take advantage of it. Default value is false.
<i>249</i>&nbsp;     */
<i>250</i>&nbsp;    protected boolean                 largeModel;
<i>251</i>&nbsp;
<i>252</i>&nbsp;    /**
<i>253</i>&nbsp;     * Number of rows to make visible at one time. This value is used for
<i>254</i>&nbsp;     * the &lt;code&gt;Scrollable&lt;/code&gt; interface. It determines the preferred
<i>255</i>&nbsp;     * size of the display area.
<i>256</i>&nbsp;     */
<i>257</i>&nbsp;    protected int                     visibleRowCount;
<i>258</i>&nbsp;
<i>259</i>&nbsp;    /**
<i>260</i>&nbsp;     * If true, when editing is to be stopped by way of selection changing,
<i>261</i>&nbsp;     * data in tree changing or other means &lt;code&gt;stopCellEditing&lt;/code&gt;
<i>262</i>&nbsp;     * is invoked, and changes are saved. If false,
<i>263</i>&nbsp;     * &lt;code&gt;cancelCellEditing&lt;/code&gt; is invoked, and changes
<i>264</i>&nbsp;     * are discarded. Default is false.
<i>265</i>&nbsp;     */
<i>266</i>&nbsp;    protected boolean                 invokesStopCellEditing;
<i>267</i>&nbsp;
<i>268</i>&nbsp;    /**
<b class="nc"><i>269</i>&nbsp;     * If true, when a node is expanded, as many of the descendants are</b>
<i>270</i>&nbsp;     * scrolled to be visible.
<i>271</i>&nbsp;     */
<i>272</i>&nbsp;    protected boolean                 scrollsOnExpand;
<i>273</i>&nbsp;    private boolean                   scrollsOnExpandSet = false;
<i>274</i>&nbsp;
<i>275</i>&nbsp;    /**
<i>276</i>&nbsp;     * Number of mouse clicks before a node is expanded.
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    protected int                     toggleClickCount;
<i>279</i>&nbsp;
<i>280</i>&nbsp;    /**
<i>281</i>&nbsp;     * Updates the &lt;code&gt;expandedState&lt;/code&gt;.
<i>282</i>&nbsp;     */
<i>283</i>&nbsp;    protected transient TreeModelListener       treeModelListener;
<i>284</i>&nbsp;
<i>285</i>&nbsp;    /**
<i>286</i>&nbsp;     * Used when &lt;code&gt;setExpandedState&lt;/code&gt; is invoked,
<i>287</i>&nbsp;     * will be a &lt;code&gt;Stack&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt;s.
<i>288</i>&nbsp;     */
<i>289</i>&nbsp;    private transient Stack&lt;Stack&lt;TreePath&gt;&gt; expandedStack;
<i>290</i>&nbsp;
<i>291</i>&nbsp;    /**
<i>292</i>&nbsp;     * Lead selection path, may not be &lt;code&gt;null&lt;/code&gt;.
<i>293</i>&nbsp;     */
<i>294</i>&nbsp;    private TreePath                  leadPath;
<i>295</i>&nbsp;
<i>296</i>&nbsp;    /**
<i>297</i>&nbsp;     * Anchor path.
<i>298</i>&nbsp;     */
<i>299</i>&nbsp;    private TreePath                  anchorPath;
<i>300</i>&nbsp;
<i>301</i>&nbsp;    /**
<i>302</i>&nbsp;     * True if paths in the selection should be expanded.
<i>303</i>&nbsp;     */
<i>304</i>&nbsp;    private boolean                   expandsSelectedPaths;
<i>305</i>&nbsp;
<i>306</i>&nbsp;    /**
<i>307</i>&nbsp;     * This is set to true for the life of the &lt;code&gt;setUI&lt;/code&gt; call.
<i>308</i>&nbsp;     */
<i>309</i>&nbsp;    private boolean                   settingUI;
<i>310</i>&nbsp;
<i>311</i>&nbsp;    /** If true, mouse presses on selections initiate a drag operation. */
<i>312</i>&nbsp;    private boolean dragEnabled;
<b class="nc"><i>313</i>&nbsp;</b>
<i>314</i>&nbsp;    /**
<i>315</i>&nbsp;     * The drop mode for this component.
<i>316</i>&nbsp;     */
<i>317</i>&nbsp;    private DropMode dropMode = DropMode.USE_SELECTION;
<i>318</i>&nbsp;
<i>319</i>&nbsp;    /**
<i>320</i>&nbsp;     * The drop location.
<i>321</i>&nbsp;     */
<i>322</i>&nbsp;    private transient DropLocation dropLocation;
<i>323</i>&nbsp;
<i>324</i>&nbsp;    /**
<i>325</i>&nbsp;     * Flag to indicate UI update is in progress
<i>326</i>&nbsp;     */
<b class="nc"><i>327</i>&nbsp;    private transient boolean updateInProgress;</b>
<i>328</i>&nbsp;
<i>329</i>&nbsp;    /**
<i>330</i>&nbsp;     * A subclass of &lt;code&gt;TransferHandler.DropLocation&lt;/code&gt; representing
<i>331</i>&nbsp;     * a drop location for a &lt;code&gt;JTree&lt;/code&gt;.
<b class="nc"><i>332</i>&nbsp;     *</b>
<b class="nc"><i>333</i>&nbsp;     * @see #getDropLocation</b>
<b class="nc"><i>334</i>&nbsp;     * @since 1.6</b>
<i>335</i>&nbsp;     */
<i>336</i>&nbsp;    public static final class DropLocation extends TransferHandler.DropLocation {
<i>337</i>&nbsp;        private final TreePath path;
<i>338</i>&nbsp;        private final int index;
<i>339</i>&nbsp;
<i>340</i>&nbsp;        private DropLocation(Point p, TreePath path, int index) {
<i>341</i>&nbsp;            super(p);
<i>342</i>&nbsp;            this.path = path;
<i>343</i>&nbsp;            this.index = index;
<i>344</i>&nbsp;        }
<i>345</i>&nbsp;
<i>346</i>&nbsp;        /**
<i>347</i>&nbsp;         * Returns the index where the dropped data should be inserted
<i>348</i>&nbsp;         * with respect to the path returned by &lt;code&gt;getPath()&lt;/code&gt;.
<i>349</i>&nbsp;         * &lt;p&gt;
<i>350</i>&nbsp;         * For drop modes &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt; and
<i>351</i>&nbsp;         * &lt;code&gt;DropMode.ON&lt;/code&gt;, this index is unimportant (and it will
<i>352</i>&nbsp;         * always be &lt;code&gt;-1&lt;/code&gt;) as the only interesting data is the
<i>353</i>&nbsp;         * path over which the drop operation occurred.
<i>354</i>&nbsp;         * &lt;p&gt;
<i>355</i>&nbsp;         * For drop mode &lt;code&gt;DropMode.INSERT&lt;/code&gt;, this index
<i>356</i>&nbsp;         * indicates the index at which the data should be inserted into
<i>357</i>&nbsp;         * the parent path represented by &lt;code&gt;getPath()&lt;/code&gt;.
<i>358</i>&nbsp;         * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over the
<i>359</i>&nbsp;         * parent itself, and in most cases should be treated as inserting
<i>360</i>&nbsp;         * into either the beginning or the end of the parent&#39;s list of
<i>361</i>&nbsp;         * children.
<b class="nc"><i>362</i>&nbsp;         * &lt;p&gt;</b>
<i>363</i>&nbsp;         * For &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, this value will be
<i>364</i>&nbsp;         * an insert index, as described above, or &lt;code&gt;-1&lt;/code&gt; if
<i>365</i>&nbsp;         * the drop occurred over the path itself.
<i>366</i>&nbsp;         *
<i>367</i>&nbsp;         * @return the child index
<i>368</i>&nbsp;         * @see #getPath
<i>369</i>&nbsp;         */
<i>370</i>&nbsp;        public int getChildIndex() {
<i>371</i>&nbsp;            return index;
<i>372</i>&nbsp;        }
<i>373</i>&nbsp;
<i>374</i>&nbsp;        /**
<i>375</i>&nbsp;         * Returns the path where dropped data should be placed in the
<i>376</i>&nbsp;         * tree.
<i>377</i>&nbsp;         * &lt;p&gt;
<i>378</i>&nbsp;         * Interpretation of this value depends on the drop mode set on the
<i>379</i>&nbsp;         * component. If the drop mode is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;
<i>380</i>&nbsp;         * or &lt;code&gt;DropMode.ON&lt;/code&gt;, the return value is the path in the
<i>381</i>&nbsp;         * tree over which the data has been (or will be) dropped.
<i>382</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; indicates that the drop is over empty space,
<i>383</i>&nbsp;         * not associated with a particular path.
<i>384</i>&nbsp;         * &lt;p&gt;
<i>385</i>&nbsp;         * If the drop mode is &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value
<i>386</i>&nbsp;         * refers to the path that should become the parent of the new data,
<i>387</i>&nbsp;         * in which case &lt;code&gt;getChildIndex()&lt;/code&gt; indicates where the
<i>388</i>&nbsp;         * new item should be inserted into this parent path. A
<i>389</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; path indicates that no parent path has been
<i>390</i>&nbsp;         * determined, which can happen for multiple reasons:
<i>391</i>&nbsp;         * &lt;ul&gt;
<i>392</i>&nbsp;         *    &lt;li&gt;The tree has no model
<i>393</i>&nbsp;         *    &lt;li&gt;There is no root in the tree
<i>394</i>&nbsp;         *    &lt;li&gt;The root is collapsed
<i>395</i>&nbsp;         *    &lt;li&gt;The root is a leaf node
<i>396</i>&nbsp;         * &lt;/ul&gt;
<i>397</i>&nbsp;         * It is up to the developer to decide if and how they wish to handle
<i>398</i>&nbsp;         * the &lt;code&gt;null&lt;/code&gt; case.
<i>399</i>&nbsp;         * &lt;p&gt;
<i>400</i>&nbsp;         * If the drop mode is &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;,
<b class="nc"><i>401</i>&nbsp;         * &lt;code&gt;getChildIndex&lt;/code&gt; can be used to determine whether the</b>
<i>402</i>&nbsp;         * drop is on top of the path itself (&lt;code&gt;-1&lt;/code&gt;) or the index
<i>403</i>&nbsp;         * at which it should be inserted into the path (values other than
<i>404</i>&nbsp;         * &lt;code&gt;-1&lt;/code&gt;).
<i>405</i>&nbsp;         *
<i>406</i>&nbsp;         * @return the drop path
<i>407</i>&nbsp;         * @see #getChildIndex
<i>408</i>&nbsp;         */
<i>409</i>&nbsp;        public TreePath getPath() {
<i>410</i>&nbsp;            return path;
<i>411</i>&nbsp;        }
<i>412</i>&nbsp;
<b class="nc"><i>413</i>&nbsp;        /**</b>
<b class="nc"><i>414</i>&nbsp;         * Returns a string representation of this drop location.</b>
<i>415</i>&nbsp;         * This method is intended to be used for debugging purposes,
<i>416</i>&nbsp;         * and the content and format of the returned string may vary
<i>417</i>&nbsp;         * between implementations.
<i>418</i>&nbsp;         *
<i>419</i>&nbsp;         * @return a string representation of this drop location
<i>420</i>&nbsp;         */
<i>421</i>&nbsp;        public String toString() {
<i>422</i>&nbsp;            return getClass().getName()
<b class="nc"><i>423</i>&nbsp;                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;</b>
<i>424</i>&nbsp;                   + &quot;path=&quot; + path + &quot;,&quot;
<i>425</i>&nbsp;                   + &quot;childIndex=&quot; + index + &quot;]&quot;;
<i>426</i>&nbsp;        }
<b class="nc"><i>427</i>&nbsp;    }</b>
<b class="nc"><i>428</i>&nbsp;</b>
<b class="nc"><i>429</i>&nbsp;    /**</b>
<i>430</i>&nbsp;     * The row to expand during DnD.
<i>431</i>&nbsp;     */
<i>432</i>&nbsp;    private int expandRow = -1;
<b class="nc"><i>433</i>&nbsp;</b>
<i>434</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>435</i>&nbsp;    private class TreeTimer extends Timer {
<i>436</i>&nbsp;        public TreeTimer() {
<i>437</i>&nbsp;            super(2000, null);
<i>438</i>&nbsp;            setRepeats(false);
<i>439</i>&nbsp;        }
<i>440</i>&nbsp;
<i>441</i>&nbsp;        public void fireActionPerformed(ActionEvent ae) {
<i>442</i>&nbsp;            JTree.this.expandRow(expandRow);
<i>443</i>&nbsp;        }
<i>444</i>&nbsp;    }
<i>445</i>&nbsp;
<i>446</i>&nbsp;    /**
<i>447</i>&nbsp;     * A timer to expand nodes during drop.
<i>448</i>&nbsp;     */
<i>449</i>&nbsp;    private TreeTimer dropTimer;
<i>450</i>&nbsp;
<i>451</i>&nbsp;    /**
<i>452</i>&nbsp;     * When &lt;code&gt;addTreeExpansionListener&lt;/code&gt; is invoked,
<i>453</i>&nbsp;     * and &lt;code&gt;settingUI&lt;/code&gt; is true, this ivar gets set to the passed in
<i>454</i>&nbsp;     * &lt;code&gt;Listener&lt;/code&gt;. This listener is then notified first in
<b class="nc"><i>455</i>&nbsp;     * &lt;code&gt;fireTreeCollapsed&lt;/code&gt; and &lt;code&gt;fireTreeExpanded&lt;/code&gt;.</b>
<i>456</i>&nbsp;     * &lt;p&gt;This is an ugly workaround for a way to have the UI listener
<i>457</i>&nbsp;     * get notified before other listeners.
<i>458</i>&nbsp;     */
<i>459</i>&nbsp;    private transient TreeExpansionListener     uiTreeExpansionListener;
<i>460</i>&nbsp;
<i>461</i>&nbsp;    /**
<i>462</i>&nbsp;     * Max number of stacks to keep around.
<i>463</i>&nbsp;     */
<i>464</i>&nbsp;    private static int                TEMP_STACK_SIZE = 11;
<i>465</i>&nbsp;
<i>466</i>&nbsp;    //
<i>467</i>&nbsp;    // Bound property names
<i>468</i>&nbsp;    //
<i>469</i>&nbsp;    /** Bound property name for &lt;code&gt;cellRenderer&lt;/code&gt;. */
<i>470</i>&nbsp;    public static final String        CELL_RENDERER_PROPERTY = &quot;cellRenderer&quot;;
<i>471</i>&nbsp;    /** Bound property name for &lt;code&gt;treeModel&lt;/code&gt;. */
<i>472</i>&nbsp;    public static final String        TREE_MODEL_PROPERTY = &quot;model&quot;;
<i>473</i>&nbsp;    /** Bound property name for &lt;code&gt;rootVisible&lt;/code&gt;. */
<i>474</i>&nbsp;    public static final String        ROOT_VISIBLE_PROPERTY = &quot;rootVisible&quot;;
<i>475</i>&nbsp;    /** Bound property name for &lt;code&gt;showsRootHandles&lt;/code&gt;. */
<i>476</i>&nbsp;    public static final String        SHOWS_ROOT_HANDLES_PROPERTY = &quot;showsRootHandles&quot;;
<i>477</i>&nbsp;    /** Bound property name for &lt;code&gt;rowHeight&lt;/code&gt;. */
<i>478</i>&nbsp;    public static final String        ROW_HEIGHT_PROPERTY = &quot;rowHeight&quot;;
<i>479</i>&nbsp;    /** Bound property name for &lt;code&gt;cellEditor&lt;/code&gt;. */
<i>480</i>&nbsp;    public static final String        CELL_EDITOR_PROPERTY = &quot;cellEditor&quot;;
<i>481</i>&nbsp;    /** Bound property name for &lt;code&gt;editable&lt;/code&gt;. */
<i>482</i>&nbsp;    public static final String        EDITABLE_PROPERTY = &quot;editable&quot;;
<i>483</i>&nbsp;    /** Bound property name for &lt;code&gt;largeModel&lt;/code&gt;. */
<i>484</i>&nbsp;    public static final String        LARGE_MODEL_PROPERTY = &quot;largeModel&quot;;
<i>485</i>&nbsp;    /** Bound property name for selectionModel. */
<i>486</i>&nbsp;    public static final String        SELECTION_MODEL_PROPERTY = &quot;selectionModel&quot;;
<i>487</i>&nbsp;    /** Bound property name for &lt;code&gt;visibleRowCount&lt;/code&gt;. */
<i>488</i>&nbsp;    public static final String        VISIBLE_ROW_COUNT_PROPERTY = &quot;visibleRowCount&quot;;
<i>489</i>&nbsp;    /** Bound property name for &lt;code&gt;messagesStopCellEditing&lt;/code&gt;. */
<i>490</i>&nbsp;    public static final String        INVOKES_STOP_CELL_EDITING_PROPERTY = &quot;invokesStopCellEditing&quot;;
<i>491</i>&nbsp;    /** Bound property name for &lt;code&gt;scrollsOnExpand&lt;/code&gt;. */
<i>492</i>&nbsp;    public static final String        SCROLLS_ON_EXPAND_PROPERTY = &quot;scrollsOnExpand&quot;;
<i>493</i>&nbsp;    /** Bound property name for &lt;code&gt;toggleClickCount&lt;/code&gt;. */
<i>494</i>&nbsp;    public static final String        TOGGLE_CLICK_COUNT_PROPERTY = &quot;toggleClickCount&quot;;
<i>495</i>&nbsp;    /** Bound property name for &lt;code&gt;leadSelectionPath&lt;/code&gt;.
<i>496</i>&nbsp;     * @since 1.3 */
<i>497</i>&nbsp;    public static final String        LEAD_SELECTION_PATH_PROPERTY = &quot;leadSelectionPath&quot;;
<i>498</i>&nbsp;    /** Bound property name for anchor selection path.
<i>499</i>&nbsp;     * @since 1.3 */
<i>500</i>&nbsp;    public static final String        ANCHOR_SELECTION_PATH_PROPERTY = &quot;anchorSelectionPath&quot;;
<i>501</i>&nbsp;    /** Bound property name for expands selected paths property
<i>502</i>&nbsp;     * @since 1.3 */
<i>503</i>&nbsp;    public static final String        EXPANDS_SELECTED_PATHS_PROPERTY = &quot;expandsSelectedPaths&quot;;
<b class="nc"><i>504</i>&nbsp;</b>
<i>505</i>&nbsp;
<i>506</i>&nbsp;    /**
<b class="nc"><i>507</i>&nbsp;     * Creates and returns a sample &lt;code&gt;TreeModel&lt;/code&gt;.</b>
<b class="nc"><i>508</i>&nbsp;     * Used primarily for beanbuilders to show something interesting.</b>
<b class="nc"><i>509</i>&nbsp;     *</b>
<b class="nc"><i>510</i>&nbsp;     * @return the default &lt;code&gt;TreeModel&lt;/code&gt;</b>
<b class="nc"><i>511</i>&nbsp;     */</b>
<b class="nc"><i>512</i>&nbsp;    protected static TreeModel getDefaultTreeModel() {</b>
<i>513</i>&nbsp;        DefaultMutableTreeNode      root = new DefaultMutableTreeNode(&quot;JTree&quot;);
<b class="nc"><i>514</i>&nbsp;        DefaultMutableTreeNode      parent;</b>
<b class="nc"><i>515</i>&nbsp;</b>
<b class="nc"><i>516</i>&nbsp;        parent = new DefaultMutableTreeNode(&quot;colors&quot;);</b>
<b class="nc"><i>517</i>&nbsp;        root.add(parent);</b>
<b class="nc"><i>518</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;blue&quot;));</b>
<b class="nc"><i>519</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;violet&quot;));</b>
<i>520</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;red&quot;));
<b class="nc"><i>521</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;yellow&quot;));</b>
<b class="nc"><i>522</i>&nbsp;</b>
<b class="nc"><i>523</i>&nbsp;        parent = new DefaultMutableTreeNode(&quot;sports&quot;);</b>
<b class="nc"><i>524</i>&nbsp;        root.add(parent);</b>
<b class="nc"><i>525</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;basketball&quot;));</b>
<b class="nc"><i>526</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;soccer&quot;));</b>
<b class="nc"><i>527</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;football&quot;));</b>
<i>528</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;hockey&quot;));
<i>529</i>&nbsp;
<i>530</i>&nbsp;        parent = new DefaultMutableTreeNode(&quot;food&quot;);
<i>531</i>&nbsp;        root.add(parent);
<i>532</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;hot dogs&quot;));
<i>533</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;pizza&quot;));
<i>534</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;ravioli&quot;));
<i>535</i>&nbsp;        parent.add(new DefaultMutableTreeNode(&quot;bananas&quot;));
<i>536</i>&nbsp;        return new DefaultTreeModel(root);
<i>537</i>&nbsp;    }
<i>538</i>&nbsp;
<i>539</i>&nbsp;    /**
<i>540</i>&nbsp;     * Returns a &lt;code&gt;TreeModel&lt;/code&gt; wrapping the specified object.
<i>541</i>&nbsp;     * If the object is:&lt;ul&gt;
<i>542</i>&nbsp;     * &lt;li&gt;an array of &lt;code&gt;Object&lt;/code&gt;s,
<i>543</i>&nbsp;     * &lt;li&gt;a &lt;code&gt;Hashtable&lt;/code&gt;, or
<i>544</i>&nbsp;     * &lt;li&gt;a &lt;code&gt;Vector&lt;/code&gt;
<i>545</i>&nbsp;     * &lt;/ul&gt;then a new root node is created with each of the incoming
<i>546</i>&nbsp;     * objects as children. Otherwise, a new root is created with
<b class="nc"><i>547</i>&nbsp;     * a value of {@code &quot;root&quot;}.</b>
<i>548</i>&nbsp;     *
<b class="nc"><i>549</i>&nbsp;     * @param value  the &lt;code&gt;Object&lt;/code&gt; used as the foundation for</b>
<b class="nc"><i>550</i>&nbsp;     *          the &lt;code&gt;TreeModel&lt;/code&gt;</b>
<i>551</i>&nbsp;     * @return a &lt;code&gt;TreeModel&lt;/code&gt; wrapping the specified object
<i>552</i>&nbsp;     */
<b class="nc"><i>553</i>&nbsp;    protected static TreeModel createTreeModel(Object value) {</b>
<i>554</i>&nbsp;        DefaultMutableTreeNode           root;
<b class="nc"><i>555</i>&nbsp;</b>
<i>556</i>&nbsp;        if((value instanceof Object[]) || (value instanceof Hashtable) ||
<i>557</i>&nbsp;           (value instanceof Vector)) {
<i>558</i>&nbsp;            root = new DefaultMutableTreeNode(&quot;root&quot;);
<i>559</i>&nbsp;            DynamicUtilTreeNode.createChildren(root, value);
<i>560</i>&nbsp;        }
<i>561</i>&nbsp;        else {
<i>562</i>&nbsp;            root = new DynamicUtilTreeNode(&quot;root&quot;, value);
<i>563</i>&nbsp;        }
<i>564</i>&nbsp;        return new DefaultTreeModel(root, false);
<i>565</i>&nbsp;    }
<b class="nc"><i>566</i>&nbsp;</b>
<i>567</i>&nbsp;    /**
<i>568</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; with a sample model.
<i>569</i>&nbsp;     * The default model used by the tree defines a leaf node as any node
<i>570</i>&nbsp;     * without children.
<i>571</i>&nbsp;     *
<i>572</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>573</i>&nbsp;     */
<i>574</i>&nbsp;    public JTree() {
<i>575</i>&nbsp;        this(getDefaultTreeModel());
<i>576</i>&nbsp;    }
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; with each element of the
<b class="nc"><i>580</i>&nbsp;     * specified array as the</b>
<b class="nc"><i>581</i>&nbsp;     * child of a new root node which is not displayed.</b>
<b class="nc"><i>582</i>&nbsp;     * By default, the tree defines a leaf node as any node without</b>
<b class="nc"><i>583</i>&nbsp;     * children.</b>
<i>584</i>&nbsp;     *
<i>585</i>&nbsp;     * @param value  an array of &lt;code&gt;Object&lt;/code&gt;s
<i>586</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>587</i>&nbsp;     */
<i>588</i>&nbsp;    public JTree(Object[] value) {
<i>589</i>&nbsp;        this(createTreeModel(value));
<i>590</i>&nbsp;        this.setRootVisible(false);
<i>591</i>&nbsp;        this.setShowsRootHandles(true);
<i>592</i>&nbsp;        expandRoot();
<i>593</i>&nbsp;    }
<i>594</i>&nbsp;
<i>595</i>&nbsp;    /**
<b class="nc"><i>596</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; with each element of the specified</b>
<b class="nc"><i>597</i>&nbsp;     * &lt;code&gt;Vector&lt;/code&gt; as the</b>
<b class="nc"><i>598</i>&nbsp;     * child of a new root node which is not displayed. By default, the</b>
<b class="nc"><i>599</i>&nbsp;     * tree defines a leaf node as any node without children.</b>
<i>600</i>&nbsp;     *
<i>601</i>&nbsp;     * @param value  a &lt;code&gt;Vector&lt;/code&gt;
<i>602</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>603</i>&nbsp;     */
<i>604</i>&nbsp;    public JTree(Vector&lt;?&gt; value) {
<i>605</i>&nbsp;        this(createTreeModel(value));
<i>606</i>&nbsp;        this.setRootVisible(false);
<i>607</i>&nbsp;        this.setShowsRootHandles(true);
<i>608</i>&nbsp;        expandRoot();
<i>609</i>&nbsp;    }
<i>610</i>&nbsp;
<i>611</i>&nbsp;    /**
<i>612</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; created from a &lt;code&gt;Hashtable&lt;/code&gt;
<b class="nc"><i>613</i>&nbsp;     * which does not display with root.</b>
<b class="nc"><i>614</i>&nbsp;     * Each value-half of the key/value pairs in the &lt;code&gt;HashTable&lt;/code&gt;</b>
<b class="nc"><i>615</i>&nbsp;     * becomes a child of the new root node. By default, the tree defines</b>
<b class="nc"><i>616</i>&nbsp;     * a leaf node as any node without children.</b>
<i>617</i>&nbsp;     *
<i>618</i>&nbsp;     * @param value  a &lt;code&gt;Hashtable&lt;/code&gt;
<i>619</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>620</i>&nbsp;     */
<i>621</i>&nbsp;    public JTree(Hashtable&lt;?,?&gt; value) {
<i>622</i>&nbsp;        this(createTreeModel(value));
<i>623</i>&nbsp;        this.setRootVisible(false);
<i>624</i>&nbsp;        this.setShowsRootHandles(true);
<i>625</i>&nbsp;        expandRoot();
<i>626</i>&nbsp;    }
<i>627</i>&nbsp;
<i>628</i>&nbsp;    /**
<b class="nc"><i>629</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; with the specified</b>
<i>630</i>&nbsp;     * &lt;code&gt;TreeNode&lt;/code&gt; as its root,
<i>631</i>&nbsp;     * which displays the root node.
<i>632</i>&nbsp;     * By default, the tree defines a leaf node as any node without children.
<i>633</i>&nbsp;     *
<i>634</i>&nbsp;     * @param root  a &lt;code&gt;TreeNode&lt;/code&gt; object
<i>635</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>636</i>&nbsp;     */
<i>637</i>&nbsp;    public JTree(TreeNode root) {
<i>638</i>&nbsp;        this(root, false);
<i>639</i>&nbsp;    }
<i>640</i>&nbsp;
<i>641</i>&nbsp;    /**
<i>642</i>&nbsp;     * Returns a &lt;code&gt;JTree&lt;/code&gt; with the specified &lt;code&gt;TreeNode&lt;/code&gt;
<i>643</i>&nbsp;     * as its root, which
<i>644</i>&nbsp;     * displays the root node and which decides whether a node is a
<b class="nc"><i>645</i>&nbsp;     * leaf node in the specified manner.</b>
<i>646</i>&nbsp;     *
<i>647</i>&nbsp;     * @param root  a &lt;code&gt;TreeNode&lt;/code&gt; object
<i>648</i>&nbsp;     * @param asksAllowsChildren  if false, any node without children is a
<i>649</i>&nbsp;     *              leaf node; if true, only nodes that do not allow
<i>650</i>&nbsp;     *              children are leaf nodes
<i>651</i>&nbsp;     * @see DefaultTreeModel#asksAllowsChildren
<i>652</i>&nbsp;     */
<i>653</i>&nbsp;    public JTree(TreeNode root, boolean asksAllowsChildren) {
<i>654</i>&nbsp;        this(new DefaultTreeModel(root, asksAllowsChildren));
<i>655</i>&nbsp;    }
<b class="nc"><i>656</i>&nbsp;</b>
<b class="nc"><i>657</i>&nbsp;    /**</b>
<b class="nc"><i>658</i>&nbsp;     * Returns an instance of &lt;code&gt;JTree&lt;/code&gt; which displays the root node</b>
<b class="nc"><i>659</i>&nbsp;     * -- the tree is created using the specified data model.</b>
<b class="nc"><i>660</i>&nbsp;     *</b>
<b class="nc"><i>661</i>&nbsp;     * @param newModel  the &lt;code&gt;TreeModel&lt;/code&gt; to use as the data model</b>
<b class="nc"><i>662</i>&nbsp;     */</b>
<b class="nc"><i>663</i>&nbsp;    @ConstructorProperties({&quot;model&quot;})</b>
<b class="nc"><i>664</i>&nbsp;    public JTree(TreeModel newModel) {</b>
<b class="nc"><i>665</i>&nbsp;        super();</b>
<b class="nc"><i>666</i>&nbsp;        expandedStack = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</b>
<b class="nc"><i>667</i>&nbsp;        toggleClickCount = 2;</b>
<b class="nc"><i>668</i>&nbsp;        expandedState = new Hashtable&lt;TreePath, Boolean&gt;();</b>
<b class="nc"><i>669</i>&nbsp;        setLayout(null);</b>
<b class="nc"><i>670</i>&nbsp;        rowHeight = 16;</b>
<i>671</i>&nbsp;        visibleRowCount = 20;
<i>672</i>&nbsp;        rootVisible = true;
<i>673</i>&nbsp;        selectionModel = new DefaultTreeSelectionModel();
<i>674</i>&nbsp;        cellRenderer = null;
<i>675</i>&nbsp;        scrollsOnExpand = true;
<i>676</i>&nbsp;        setOpaque(true);
<i>677</i>&nbsp;        expandsSelectedPaths = true;
<i>678</i>&nbsp;        updateUI();
<b class="nc"><i>679</i>&nbsp;        setModel(newModel);</b>
<i>680</i>&nbsp;    }
<i>681</i>&nbsp;
<i>682</i>&nbsp;    /**
<i>683</i>&nbsp;     * Returns the L&amp;amp;F object that renders this component.
<i>684</i>&nbsp;     *
<i>685</i>&nbsp;     * @return the &lt;code&gt;TreeUI&lt;/code&gt; object that renders this component
<i>686</i>&nbsp;     */
<i>687</i>&nbsp;    public TreeUI getUI() {
<i>688</i>&nbsp;        return (TreeUI)ui;
<i>689</i>&nbsp;    }
<i>690</i>&nbsp;
<i>691</i>&nbsp;    /**
<i>692</i>&nbsp;     * Sets the L&amp;amp;F object that renders this component.
<i>693</i>&nbsp;     * &lt;p&gt;
<i>694</i>&nbsp;     * This is a bound property.
<i>695</i>&nbsp;     *
<b class="nc"><i>696</i>&nbsp;     * @param ui  the &lt;code&gt;TreeUI&lt;/code&gt; L&amp;amp;F object</b>
<b class="nc"><i>697</i>&nbsp;     * @see UIDefaults#getUI</b>
<b class="nc"><i>698</i>&nbsp;     */</b>
<i>699</i>&nbsp;    @BeanProperty(hidden = true, visualUpdate = true, description
<b class="nc"><i>700</i>&nbsp;            = &quot;The UI object that implements the Component&#39;s LookAndFeel.&quot;)</b>
<i>701</i>&nbsp;    public void setUI(TreeUI ui) {
<i>702</i>&nbsp;        if (this.ui != ui) {
<b class="nc"><i>703</i>&nbsp;            settingUI = true;</b>
<b class="nc"><i>704</i>&nbsp;            uiTreeExpansionListener = null;</b>
<i>705</i>&nbsp;            try {
<i>706</i>&nbsp;                super.setUI(ui);
<i>707</i>&nbsp;            }
<i>708</i>&nbsp;            finally {
<i>709</i>&nbsp;                settingUI = false;
<i>710</i>&nbsp;            }
<i>711</i>&nbsp;        }
<i>712</i>&nbsp;    }
<i>713</i>&nbsp;
<i>714</i>&nbsp;    /**
<i>715</i>&nbsp;     * Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.
<b class="nc"><i>716</i>&nbsp;     * Replaces the current UI object with the latest version from the</b>
<i>717</i>&nbsp;     * &lt;code&gt;UIManager&lt;/code&gt;.
<b class="nc"><i>718</i>&nbsp;     *</b>
<b class="nc"><i>719</i>&nbsp;     * @see JComponent#updateUI</b>
<i>720</i>&nbsp;     */
<i>721</i>&nbsp;    public void updateUI() {
<i>722</i>&nbsp;        if (!updateInProgress) {
<i>723</i>&nbsp;
<i>724</i>&nbsp;            updateInProgress = true;
<i>725</i>&nbsp;
<i>726</i>&nbsp;            try {
<i>727</i>&nbsp;                setUI((TreeUI)UIManager.getUI(this));
<i>728</i>&nbsp;
<i>729</i>&nbsp;                SwingUtilities.updateRendererOrEditorUI(getCellRenderer());
<i>730</i>&nbsp;                SwingUtilities.updateRendererOrEditorUI(getCellEditor());
<b class="nc"><i>731</i>&nbsp;            } finally {</b>
<i>732</i>&nbsp;                updateInProgress = false;
<i>733</i>&nbsp;            }
<i>734</i>&nbsp;        }
<i>735</i>&nbsp;    }
<i>736</i>&nbsp;
<i>737</i>&nbsp;
<i>738</i>&nbsp;    /**
<i>739</i>&nbsp;     * Returns the name of the L&amp;amp;F class that renders this component.
<i>740</i>&nbsp;     *
<i>741</i>&nbsp;     * @return the string &quot;TreeUI&quot;
<b class="nc"><i>742</i>&nbsp;     * @see JComponent#getUIClassID</b>
<i>743</i>&nbsp;     * @see UIDefaults#getUI
<i>744</i>&nbsp;     */
<i>745</i>&nbsp;    @BeanProperty(bound = false)
<i>746</i>&nbsp;    public String getUIClassID() {
<i>747</i>&nbsp;        return uiClassID;
<i>748</i>&nbsp;    }
<i>749</i>&nbsp;
<i>750</i>&nbsp;
<i>751</i>&nbsp;    /**
<i>752</i>&nbsp;     * Returns the current &lt;code&gt;TreeCellRenderer&lt;/code&gt;
<i>753</i>&nbsp;     *  that is rendering each cell.
<i>754</i>&nbsp;     *
<i>755</i>&nbsp;     * @return the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that is rendering each cell
<i>756</i>&nbsp;     */
<i>757</i>&nbsp;    public TreeCellRenderer getCellRenderer() {
<b class="nc"><i>758</i>&nbsp;        return cellRenderer;</b>
<i>759</i>&nbsp;    }
<b class="nc"><i>760</i>&nbsp;</b>
<b class="nc"><i>761</i>&nbsp;    /**</b>
<b class="nc"><i>762</i>&nbsp;     * Sets the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that will be used to</b>
<i>763</i>&nbsp;     * draw each cell.
<i>764</i>&nbsp;     * &lt;p&gt;
<i>765</i>&nbsp;     * This is a bound property.
<i>766</i>&nbsp;     *
<i>767</i>&nbsp;     * @param x  the &lt;code&gt;TreeCellRenderer&lt;/code&gt; that is to render each cell
<i>768</i>&nbsp;     */
<i>769</i>&nbsp;    @BeanProperty(description
<i>770</i>&nbsp;            = &quot;The TreeCellRenderer that will be used to draw each cell.&quot;)
<i>771</i>&nbsp;    public void setCellRenderer(TreeCellRenderer x) {
<i>772</i>&nbsp;        TreeCellRenderer oldValue = cellRenderer;
<i>773</i>&nbsp;
<i>774</i>&nbsp;        cellRenderer = x;
<i>775</i>&nbsp;        firePropertyChange(CELL_RENDERER_PROPERTY, oldValue, cellRenderer);
<i>776</i>&nbsp;        invalidate();
<i>777</i>&nbsp;    }
<b class="nc"><i>778</i>&nbsp;</b>
<i>779</i>&nbsp;    /**
<b class="nc"><i>780</i>&nbsp;      * Determines whether the tree is editable. Fires a property</b>
<b class="nc"><i>781</i>&nbsp;      * change event if the new setting is different from the existing</b>
<b class="nc"><i>782</i>&nbsp;      * setting.</b>
<b class="nc"><i>783</i>&nbsp;     * &lt;p&gt;</b>
<i>784</i>&nbsp;     * This is a bound property.
<i>785</i>&nbsp;      *
<i>786</i>&nbsp;      * @param flag  a boolean value, true if the tree is editable
<i>787</i>&nbsp;      */
<i>788</i>&nbsp;    @BeanProperty(description
<i>789</i>&nbsp;            = &quot;Whether the tree is editable.&quot;)
<i>790</i>&nbsp;    public void setEditable(boolean flag) {
<i>791</i>&nbsp;        boolean                 oldValue = this.editable;
<i>792</i>&nbsp;
<i>793</i>&nbsp;        this.editable = flag;
<i>794</i>&nbsp;        firePropertyChange(EDITABLE_PROPERTY, oldValue, flag);
<i>795</i>&nbsp;        if (accessibleContext != null) {
<b class="nc"><i>796</i>&nbsp;            accessibleContext.firePropertyChange(</b>
<i>797</i>&nbsp;                AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>798</i>&nbsp;                (oldValue ? AccessibleState.EDITABLE : null),
<i>799</i>&nbsp;                (flag ? AccessibleState.EDITABLE : null));
<i>800</i>&nbsp;        }
<i>801</i>&nbsp;    }
<i>802</i>&nbsp;
<i>803</i>&nbsp;    /**
<i>804</i>&nbsp;     * Returns true if the tree is editable.
<i>805</i>&nbsp;     *
<i>806</i>&nbsp;     * @return true if the tree is editable
<i>807</i>&nbsp;     */
<i>808</i>&nbsp;    public boolean isEditable() {
<i>809</i>&nbsp;        return editable;
<i>810</i>&nbsp;    }
<i>811</i>&nbsp;
<i>812</i>&nbsp;    /**
<i>813</i>&nbsp;     * Sets the cell editor.  A &lt;code&gt;null&lt;/code&gt; value implies that the
<b class="nc"><i>814</i>&nbsp;     * tree cannot be edited.  If this represents a change in the</b>
<i>815</i>&nbsp;     * &lt;code&gt;cellEditor&lt;/code&gt;, the &lt;code&gt;propertyChange&lt;/code&gt;
<b class="nc"><i>816</i>&nbsp;     * method is invoked on all listeners.</b>
<b class="nc"><i>817</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>818</i>&nbsp;     * This is a bound property.</b>
<i>819</i>&nbsp;     *
<i>820</i>&nbsp;     * @param cellEditor the &lt;code&gt;TreeCellEditor&lt;/code&gt; to use
<i>821</i>&nbsp;     */
<i>822</i>&nbsp;    @BeanProperty(description
<i>823</i>&nbsp;            = &quot;The cell editor. A null value implies the tree cannot be edited.&quot;)
<i>824</i>&nbsp;    public void setCellEditor(TreeCellEditor cellEditor) {
<i>825</i>&nbsp;        TreeCellEditor        oldEditor = this.cellEditor;
<i>826</i>&nbsp;
<i>827</i>&nbsp;        this.cellEditor = cellEditor;
<b class="nc"><i>828</i>&nbsp;        firePropertyChange(CELL_EDITOR_PROPERTY, oldEditor, cellEditor);</b>
<i>829</i>&nbsp;        invalidate();
<i>830</i>&nbsp;    }
<i>831</i>&nbsp;
<i>832</i>&nbsp;    /**
<i>833</i>&nbsp;     * Returns the editor used to edit entries in the tree.
<i>834</i>&nbsp;     *
<i>835</i>&nbsp;     * @return the &lt;code&gt;TreeCellEditor&lt;/code&gt; in use,
<i>836</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if the tree cannot be edited
<b class="nc"><i>837</i>&nbsp;     */</b>
<i>838</i>&nbsp;    public TreeCellEditor getCellEditor() {
<i>839</i>&nbsp;        return cellEditor;
<i>840</i>&nbsp;    }
<i>841</i>&nbsp;
<i>842</i>&nbsp;    /**
<i>843</i>&nbsp;     * Returns the &lt;code&gt;TreeModel&lt;/code&gt; that is providing the data.
<i>844</i>&nbsp;     *
<i>845</i>&nbsp;     * @return the &lt;code&gt;TreeModel&lt;/code&gt; that is providing the data
<i>846</i>&nbsp;     */
<i>847</i>&nbsp;    public TreeModel getModel() {
<i>848</i>&nbsp;        return treeModel;
<i>849</i>&nbsp;    }
<i>850</i>&nbsp;
<b class="nc"><i>851</i>&nbsp;    /**</b>
<i>852</i>&nbsp;     * Sets the &lt;code&gt;TreeModel&lt;/code&gt; that will provide the data.
<b class="nc"><i>853</i>&nbsp;     * &lt;p&gt;</b>
<i>854</i>&nbsp;     * This is a bound property.
<b class="nc"><i>855</i>&nbsp;     *</b>
<b class="nc"><i>856</i>&nbsp;     * @param newModel the &lt;code&gt;TreeModel&lt;/code&gt; that is to provide the data</b>
<i>857</i>&nbsp;     */
<b class="nc"><i>858</i>&nbsp;    @BeanProperty(description</b>
<b class="nc"><i>859</i>&nbsp;            = &quot;The TreeModel that will provide the data.&quot;)</b>
<b class="nc"><i>860</i>&nbsp;    public void setModel(TreeModel newModel) {</b>
<i>861</i>&nbsp;        clearSelection();
<b class="nc"><i>862</i>&nbsp;</b>
<b class="nc"><i>863</i>&nbsp;        TreeModel oldModel = treeModel;</b>
<i>864</i>&nbsp;
<i>865</i>&nbsp;        if(treeModel != null &amp;&amp; treeModelListener != null)
<i>866</i>&nbsp;            treeModel.removeTreeModelListener(treeModelListener);
<b class="nc"><i>867</i>&nbsp;</b>
<b class="nc"><i>868</i>&nbsp;        if (accessibleContext != null) {</b>
<b class="nc"><i>869</i>&nbsp;            if (treeModel != null) {</b>
<b class="nc"><i>870</i>&nbsp;                treeModel.removeTreeModelListener((TreeModelListener)accessibleContext);</b>
<b class="nc"><i>871</i>&nbsp;            }</b>
<b class="nc"><i>872</i>&nbsp;            if (newModel != null) {</b>
<b class="nc"><i>873</i>&nbsp;                newModel.addTreeModelListener((TreeModelListener)accessibleContext);</b>
<i>874</i>&nbsp;            }
<b class="nc"><i>875</i>&nbsp;        }</b>
<b class="nc"><i>876</i>&nbsp;</b>
<b class="nc"><i>877</i>&nbsp;        treeModel = newModel;</b>
<b class="nc"><i>878</i>&nbsp;        clearToggledPaths();</b>
<i>879</i>&nbsp;        if(treeModel != null) {
<i>880</i>&nbsp;            if(treeModelListener == null)
<i>881</i>&nbsp;                treeModelListener = createTreeModelListener();
<b class="nc"><i>882</i>&nbsp;            if(treeModelListener != null)</b>
<b class="nc"><i>883</i>&nbsp;                treeModel.addTreeModelListener(treeModelListener);</b>
<i>884</i>&nbsp;
<i>885</i>&nbsp;            // Mark the root as expanded, if it isn&#39;t a leaf.
<i>886</i>&nbsp;            Object treeRoot = treeModel.getRoot();
<i>887</i>&nbsp;            if(treeRoot != null &amp;&amp;
<i>888</i>&nbsp;               !treeModel.isLeaf(treeRoot)) {
<i>889</i>&nbsp;                expandedState.put(new TreePath(treeRoot),
<i>890</i>&nbsp;                                    Boolean.TRUE);
<i>891</i>&nbsp;            }
<i>892</i>&nbsp;        }
<b class="nc"><i>893</i>&nbsp;        firePropertyChange(TREE_MODEL_PROPERTY, oldModel, treeModel);</b>
<i>894</i>&nbsp;        invalidate();
<i>895</i>&nbsp;    }
<i>896</i>&nbsp;
<i>897</i>&nbsp;    /**
<i>898</i>&nbsp;     * Returns true if the root node of the tree is displayed.
<i>899</i>&nbsp;     *
<i>900</i>&nbsp;     * @return true if the root node of the tree is displayed
<i>901</i>&nbsp;     * @see #rootVisible
<i>902</i>&nbsp;     */
<i>903</i>&nbsp;    public boolean isRootVisible() {
<i>904</i>&nbsp;        return rootVisible;
<i>905</i>&nbsp;    }
<i>906</i>&nbsp;
<i>907</i>&nbsp;    /**
<i>908</i>&nbsp;     * Determines whether or not the root node from
<i>909</i>&nbsp;     * the &lt;code&gt;TreeModel&lt;/code&gt; is visible.
<b class="nc"><i>910</i>&nbsp;     * &lt;p&gt;</b>
<i>911</i>&nbsp;     * This is a bound property.
<b class="nc"><i>912</i>&nbsp;     *</b>
<b class="nc"><i>913</i>&nbsp;     * @param rootVisible true if the root node of the tree is to be displayed</b>
<b class="nc"><i>914</i>&nbsp;     * @see #rootVisible</b>
<b class="nc"><i>915</i>&nbsp;     */</b>
<i>916</i>&nbsp;    @BeanProperty(description
<i>917</i>&nbsp;            = &quot;Whether or not the root node from the TreeModel is visible.&quot;)
<i>918</i>&nbsp;    public void setRootVisible(boolean rootVisible) {
<i>919</i>&nbsp;        boolean                oldValue = this.rootVisible;
<i>920</i>&nbsp;
<i>921</i>&nbsp;        this.rootVisible = rootVisible;
<i>922</i>&nbsp;        firePropertyChange(ROOT_VISIBLE_PROPERTY, oldValue, this.rootVisible);
<i>923</i>&nbsp;        if (accessibleContext != null) {
<i>924</i>&nbsp;            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();
<i>925</i>&nbsp;        }
<i>926</i>&nbsp;    }
<i>927</i>&nbsp;
<i>928</i>&nbsp;    /**
<i>929</i>&nbsp;     * Sets the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property,
<i>930</i>&nbsp;     * which specifies whether the node handles should be displayed.
<i>931</i>&nbsp;     * The default value of this property depends on the constructor
<i>932</i>&nbsp;     * used to create the &lt;code&gt;JTree&lt;/code&gt;.
<i>933</i>&nbsp;     * Some look and feels might not support handles;
<i>934</i>&nbsp;     * they will ignore this property.
<i>935</i>&nbsp;     * &lt;p&gt;
<i>936</i>&nbsp;     * This is a bound property.
<i>937</i>&nbsp;     *
<i>938</i>&nbsp;     * @param newValue &lt;code&gt;true&lt;/code&gt; if root handles should be displayed;
<b class="nc"><i>939</i>&nbsp;     *                 otherwise, &lt;code&gt;false&lt;/code&gt;</b>
<b class="nc"><i>940</i>&nbsp;     * @see #showsRootHandles</b>
<i>941</i>&nbsp;     * @see #getShowsRootHandles
<b class="nc"><i>942</i>&nbsp;     */</b>
<b class="nc"><i>943</i>&nbsp;    @BeanProperty(description</b>
<b class="nc"><i>944</i>&nbsp;            = &quot;Whether the node handles are to be displayed.&quot;)</b>
<i>945</i>&nbsp;    public void setShowsRootHandles(boolean newValue) {
<b class="nc"><i>946</i>&nbsp;        boolean                oldValue = showsRootHandles;</b>
<b class="nc"><i>947</i>&nbsp;        TreeModel              model = getModel();</b>
<i>948</i>&nbsp;
<b class="nc"><i>949</i>&nbsp;        showsRootHandles = newValue;</b>
<i>950</i>&nbsp;        showsRootHandlesSet = true;
<i>951</i>&nbsp;        firePropertyChange(SHOWS_ROOT_HANDLES_PROPERTY, oldValue,
<i>952</i>&nbsp;                           showsRootHandles);
<i>953</i>&nbsp;        if (accessibleContext != null) {
<i>954</i>&nbsp;            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();
<i>955</i>&nbsp;        }
<i>956</i>&nbsp;        invalidate();
<i>957</i>&nbsp;    }
<i>958</i>&nbsp;
<i>959</i>&nbsp;    /**
<b class="nc"><i>960</i>&nbsp;     * Returns the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property.</b>
<i>961</i>&nbsp;     *
<i>962</i>&nbsp;     * @return the value of the &lt;code&gt;showsRootHandles&lt;/code&gt; property
<i>963</i>&nbsp;     * @see #showsRootHandles
<i>964</i>&nbsp;     */
<i>965</i>&nbsp;    public boolean getShowsRootHandles()
<i>966</i>&nbsp;    {
<i>967</i>&nbsp;        return showsRootHandles;
<i>968</i>&nbsp;    }
<i>969</i>&nbsp;
<i>970</i>&nbsp;    /**
<i>971</i>&nbsp;     * Sets the height of each cell, in pixels.  If the specified value
<i>972</i>&nbsp;     * is less than or equal to zero the current cell renderer is
<i>973</i>&nbsp;     * queried for each row&#39;s height.
<i>974</i>&nbsp;     * &lt;p&gt;
<i>975</i>&nbsp;     * This is a bound property.
<i>976</i>&nbsp;     *
<b class="nc"><i>977</i>&nbsp;     * @param rowHeight the height of each cell, in pixels</b>
<i>978</i>&nbsp;     */
<b class="nc"><i>979</i>&nbsp;    @BeanProperty(description</b>
<b class="nc"><i>980</i>&nbsp;            = &quot;The height of each cell.&quot;)</b>
<b class="nc"><i>981</i>&nbsp;    public void setRowHeight(int rowHeight)</b>
<b class="nc"><i>982</i>&nbsp;    {</b>
<i>983</i>&nbsp;        int                oldValue = this.rowHeight;
<i>984</i>&nbsp;
<i>985</i>&nbsp;        this.rowHeight = rowHeight;
<i>986</i>&nbsp;        rowHeightSet = true;
<i>987</i>&nbsp;        firePropertyChange(ROW_HEIGHT_PROPERTY, oldValue, this.rowHeight);
<i>988</i>&nbsp;        invalidate();
<i>989</i>&nbsp;    }
<i>990</i>&nbsp;
<i>991</i>&nbsp;    /**
<i>992</i>&nbsp;     * Returns the height of each row.  If the returned value is less than
<b class="nc"><i>993</i>&nbsp;     * or equal to 0 the height for each row is determined by the</b>
<i>994</i>&nbsp;     * renderer.
<i>995</i>&nbsp;     *
<i>996</i>&nbsp;     * @return the height of each row
<i>997</i>&nbsp;     */
<i>998</i>&nbsp;    public int getRowHeight()
<i>999</i>&nbsp;    {
<i>1000</i>&nbsp;        return rowHeight;
<i>1001</i>&nbsp;    }
<i>1002</i>&nbsp;
<b class="nc"><i>1003</i>&nbsp;    /**</b>
<i>1004</i>&nbsp;     * Returns true if the height of each display row is a fixed size.
<i>1005</i>&nbsp;     *
<i>1006</i>&nbsp;     * @return true if the height of each row is a fixed size
<i>1007</i>&nbsp;     */
<i>1008</i>&nbsp;    @BeanProperty(bound = false)
<i>1009</i>&nbsp;    public boolean isFixedRowHeight()
<i>1010</i>&nbsp;    {
<i>1011</i>&nbsp;        return (rowHeight &gt; 0);
<i>1012</i>&nbsp;    }
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;    /**
<i>1015</i>&nbsp;     * Specifies whether the UI should use a large model.
<i>1016</i>&nbsp;     * (Not all UIs will implement this.) Fires a property change
<i>1017</i>&nbsp;     * for the LARGE_MODEL_PROPERTY.
<i>1018</i>&nbsp;     * &lt;p&gt;
<i>1019</i>&nbsp;     * This is a bound property.
<i>1020</i>&nbsp;     *
<b class="nc"><i>1021</i>&nbsp;     * @param newValue true to suggest a large model to the UI</b>
<i>1022</i>&nbsp;     * @see #largeModel
<b class="nc"><i>1023</i>&nbsp;     */</b>
<b class="nc"><i>1024</i>&nbsp;    @BeanProperty(description</b>
<i>1025</i>&nbsp;            = &quot;Whether the UI should use a large model.&quot;)
<i>1026</i>&nbsp;    public void setLargeModel(boolean newValue) {
<i>1027</i>&nbsp;        boolean                oldValue = largeModel;
<i>1028</i>&nbsp;
<i>1029</i>&nbsp;        largeModel = newValue;
<i>1030</i>&nbsp;        firePropertyChange(LARGE_MODEL_PROPERTY, oldValue, newValue);
<i>1031</i>&nbsp;    }
<i>1032</i>&nbsp;
<i>1033</i>&nbsp;    /**
<b class="nc"><i>1034</i>&nbsp;     * Returns true if the tree is configured for a large model.</b>
<i>1035</i>&nbsp;     *
<i>1036</i>&nbsp;     * @return true if a large model is suggested
<i>1037</i>&nbsp;     * @see #largeModel
<i>1038</i>&nbsp;     */
<i>1039</i>&nbsp;    public boolean isLargeModel() {
<i>1040</i>&nbsp;        return largeModel;
<i>1041</i>&nbsp;    }
<i>1042</i>&nbsp;
<i>1043</i>&nbsp;    /**
<i>1044</i>&nbsp;     * Determines what happens when editing is interrupted by selecting
<i>1045</i>&nbsp;     * another node in the tree, a change in the tree&#39;s data, or by some
<i>1046</i>&nbsp;     * other means. Setting this property to &lt;code&gt;true&lt;/code&gt; causes the
<i>1047</i>&nbsp;     * changes to be automatically saved when editing is interrupted.
<i>1048</i>&nbsp;     * &lt;p&gt;
<i>1049</i>&nbsp;     * Fires a property change for the INVOKES_STOP_CELL_EDITING_PROPERTY.
<i>1050</i>&nbsp;     *
<i>1051</i>&nbsp;     * @param newValue true means that &lt;code&gt;stopCellEditing&lt;/code&gt; is invoked
<i>1052</i>&nbsp;     *        when editing is interrupted, and data is saved; false means that
<i>1053</i>&nbsp;     *        &lt;code&gt;cancelCellEditing&lt;/code&gt; is invoked, and changes are lost
<i>1054</i>&nbsp;     */
<b class="nc"><i>1055</i>&nbsp;    @BeanProperty(description</b>
<i>1056</i>&nbsp;            = &quot;Determines what happens when editing is interrupted, selecting another node in the tree, &quot;
<b class="nc"><i>1057</i>&nbsp;            + &quot;a change in the tree&#39;s data, or some other means.&quot;)</b>
<b class="nc"><i>1058</i>&nbsp;    public void setInvokesStopCellEditing(boolean newValue) {</b>
<i>1059</i>&nbsp;        boolean                  oldValue = invokesStopCellEditing;
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;        invokesStopCellEditing = newValue;
<i>1062</i>&nbsp;        firePropertyChange(INVOKES_STOP_CELL_EDITING_PROPERTY, oldValue,
<i>1063</i>&nbsp;                           newValue);
<i>1064</i>&nbsp;    }
<i>1065</i>&nbsp;
<i>1066</i>&nbsp;    /**
<i>1067</i>&nbsp;     * Returns the indicator that tells what happens when editing is
<i>1068</i>&nbsp;     * interrupted.
<i>1069</i>&nbsp;     *
<i>1070</i>&nbsp;     * @return the indicator that tells what happens when editing is
<b class="nc"><i>1071</i>&nbsp;     *         interrupted</b>
<i>1072</i>&nbsp;     * @see #setInvokesStopCellEditing
<i>1073</i>&nbsp;     */
<i>1074</i>&nbsp;    public boolean getInvokesStopCellEditing() {
<i>1075</i>&nbsp;        return invokesStopCellEditing;
<i>1076</i>&nbsp;    }
<i>1077</i>&nbsp;
<i>1078</i>&nbsp;    /**
<i>1079</i>&nbsp;     * Sets the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property,
<i>1080</i>&nbsp;     * which determines whether the
<i>1081</i>&nbsp;     * tree might scroll to show previously hidden children.
<i>1082</i>&nbsp;     * If this property is &lt;code&gt;true&lt;/code&gt; (the default),
<i>1083</i>&nbsp;     * when a node expands
<i>1084</i>&nbsp;     * the tree can use scrolling to make
<i>1085</i>&nbsp;     * the maximum possible number of the node&#39;s descendants visible.
<i>1086</i>&nbsp;     * In some look and feels, trees might not need to scroll when expanded;
<i>1087</i>&nbsp;     * those look and feels will ignore this property.
<i>1088</i>&nbsp;     * &lt;p&gt;
<i>1089</i>&nbsp;     * This is a bound property.
<i>1090</i>&nbsp;     *
<i>1091</i>&nbsp;     * @param newValue &lt;code&gt;false&lt;/code&gt; to disable scrolling on expansion;
<i>1092</i>&nbsp;     *                 &lt;code&gt;true&lt;/code&gt; to enable it
<i>1093</i>&nbsp;     * @see #getScrollsOnExpand
<i>1094</i>&nbsp;     */
<i>1095</i>&nbsp;    @BeanProperty(description
<b class="nc"><i>1096</i>&nbsp;            = &quot;Indicates if a node descendant should be scrolled when expanded.&quot;)</b>
<i>1097</i>&nbsp;    public void setScrollsOnExpand(boolean newValue) {
<b class="nc"><i>1098</i>&nbsp;        boolean           oldValue = scrollsOnExpand;</b>
<b class="nc"><i>1099</i>&nbsp;</b>
<b class="nc"><i>1100</i>&nbsp;        scrollsOnExpand = newValue;</b>
<i>1101</i>&nbsp;        scrollsOnExpandSet = true;
<i>1102</i>&nbsp;        firePropertyChange(SCROLLS_ON_EXPAND_PROPERTY, oldValue,
<i>1103</i>&nbsp;                           newValue);
<i>1104</i>&nbsp;    }
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;    /**
<i>1107</i>&nbsp;     * Returns the value of the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property.
<i>1108</i>&nbsp;     *
<i>1109</i>&nbsp;     * @return the value of the &lt;code&gt;scrollsOnExpand&lt;/code&gt; property
<b class="nc"><i>1110</i>&nbsp;     */</b>
<i>1111</i>&nbsp;    public boolean getScrollsOnExpand() {
<i>1112</i>&nbsp;        return scrollsOnExpand;
<i>1113</i>&nbsp;    }
<i>1114</i>&nbsp;
<i>1115</i>&nbsp;    /**
<i>1116</i>&nbsp;     * Sets the number of mouse clicks before a node will expand or close.
<i>1117</i>&nbsp;     * The default is two.
<i>1118</i>&nbsp;     * &lt;p&gt;
<i>1119</i>&nbsp;     * This is a bound property.
<i>1120</i>&nbsp;     *
<i>1121</i>&nbsp;     * @param clickCount the number of mouse clicks to get a node expanded or closed
<i>1122</i>&nbsp;     * @since 1.3
<i>1123</i>&nbsp;     */
<i>1124</i>&nbsp;    @BeanProperty(description
<b class="nc"><i>1125</i>&nbsp;            = &quot;Number of clicks before a node will expand/collapse.&quot;)</b>
<i>1126</i>&nbsp;    public void setToggleClickCount(int clickCount) {
<b class="nc"><i>1127</i>&nbsp;        int         oldCount = toggleClickCount;</b>
<b class="nc"><i>1128</i>&nbsp;</b>
<i>1129</i>&nbsp;        toggleClickCount = clickCount;
<i>1130</i>&nbsp;        firePropertyChange(TOGGLE_CLICK_COUNT_PROPERTY, oldCount,
<i>1131</i>&nbsp;                           clickCount);
<i>1132</i>&nbsp;    }
<i>1133</i>&nbsp;
<i>1134</i>&nbsp;    /**
<i>1135</i>&nbsp;     * Returns the number of mouse clicks needed to expand or close a node.
<i>1136</i>&nbsp;     *
<i>1137</i>&nbsp;     * @return number of mouse clicks before node is expanded
<i>1138</i>&nbsp;     * @since 1.3
<b class="nc"><i>1139</i>&nbsp;     */</b>
<i>1140</i>&nbsp;    public int getToggleClickCount() {
<i>1141</i>&nbsp;        return toggleClickCount;
<i>1142</i>&nbsp;    }
<i>1143</i>&nbsp;
<i>1144</i>&nbsp;    /**
<i>1145</i>&nbsp;     * Configures the &lt;code&gt;expandsSelectedPaths&lt;/code&gt; property. If
<i>1146</i>&nbsp;     * true, any time the selection is changed, either via the
<i>1147</i>&nbsp;     * &lt;code&gt;TreeSelectionModel&lt;/code&gt;, or the cover methods provided by
<i>1148</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt;, the &lt;code&gt;TreePath&lt;/code&gt;s parents will be
<i>1149</i>&nbsp;     * expanded to make them visible (visible meaning the parent path is
<i>1150</i>&nbsp;     * expanded, not necessarily in the visible rectangle of the
<i>1151</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt;). If false, when the selection
<i>1152</i>&nbsp;     * changes the nodes parent is not made visible (all its parents expanded).
<i>1153</i>&nbsp;     * This is useful if you wish to have your selection model maintain paths
<i>1154</i>&nbsp;     * that are not always visible (all parents expanded).
<i>1155</i>&nbsp;     * &lt;p&gt;
<i>1156</i>&nbsp;     * This is a bound property.
<i>1157</i>&nbsp;     *
<i>1158</i>&nbsp;     * @param newValue the new value for &lt;code&gt;expandsSelectedPaths&lt;/code&gt;
<i>1159</i>&nbsp;     *
<i>1160</i>&nbsp;     * @since 1.3
<i>1161</i>&nbsp;     */
<i>1162</i>&nbsp;    @BeanProperty(description
<i>1163</i>&nbsp;            = &quot;Indicates whether changes to the selection should make the parent of the path visible.&quot;)
<i>1164</i>&nbsp;    public void setExpandsSelectedPaths(boolean newValue) {
<b class="nc"><i>1165</i>&nbsp;        boolean         oldValue = expandsSelectedPaths;</b>
<i>1166</i>&nbsp;
<b class="nc"><i>1167</i>&nbsp;        expandsSelectedPaths = newValue;</b>
<b class="nc"><i>1168</i>&nbsp;        firePropertyChange(EXPANDS_SELECTED_PATHS_PROPERTY, oldValue,</b>
<i>1169</i>&nbsp;                           newValue);
<i>1170</i>&nbsp;    }
<i>1171</i>&nbsp;
<i>1172</i>&nbsp;    /**
<i>1173</i>&nbsp;     * Returns the &lt;code&gt;expandsSelectedPaths&lt;/code&gt; property.
<i>1174</i>&nbsp;     * @return true if selection changes result in the parent path being
<i>1175</i>&nbsp;     *         expanded
<i>1176</i>&nbsp;     * @since 1.3
<i>1177</i>&nbsp;     * @see #setExpandsSelectedPaths
<i>1178</i>&nbsp;     */
<i>1179</i>&nbsp;    public boolean getExpandsSelectedPaths() {
<b class="nc"><i>1180</i>&nbsp;        return expandsSelectedPaths;</b>
<i>1181</i>&nbsp;    }
<i>1182</i>&nbsp;
<i>1183</i>&nbsp;    /**
<i>1184</i>&nbsp;     * Turns on or off automatic drag handling. In order to enable automatic
<i>1185</i>&nbsp;     * drag handling, this property should be set to {@code true}, and the
<i>1186</i>&nbsp;     * tree&#39;s {@code TransferHandler} needs to be {@code non-null}.
<i>1187</i>&nbsp;     * The default value of the {@code dragEnabled} property is {@code false}.
<i>1188</i>&nbsp;     * &lt;p&gt;
<i>1189</i>&nbsp;     * The job of honoring this property, and recognizing a user drag gesture,
<i>1190</i>&nbsp;     * lies with the look and feel implementation, and in particular, the tree&#39;s
<i>1191</i>&nbsp;     * {@code TreeUI}. When automatic drag handling is enabled, most look and
<i>1192</i>&nbsp;     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
<i>1193</i>&nbsp;     * drag and drop operation whenever the user presses the mouse button over
<i>1194</i>&nbsp;     * an item and then moves the mouse a few pixels. Setting this property to
<i>1195</i>&nbsp;     * {@code true} can therefore have a subtle effect on how selections behave.
<i>1196</i>&nbsp;     * &lt;p&gt;
<i>1197</i>&nbsp;     * If a look and feel is used that ignores this property, you can still
<i>1198</i>&nbsp;     * begin a drag and drop operation by calling {@code exportAsDrag} on the
<i>1199</i>&nbsp;     * tree&#39;s {@code TransferHandler}.
<i>1200</i>&nbsp;     *
<i>1201</i>&nbsp;     * @param b whether or not to enable automatic drag handling
<i>1202</i>&nbsp;     * @exception HeadlessException if
<i>1203</i>&nbsp;     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
<i>1204</i>&nbsp;     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
<i>1205</i>&nbsp;     *            returns &lt;code&gt;true&lt;/code&gt;
<i>1206</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless
<i>1207</i>&nbsp;     * @see #getDragEnabled
<i>1208</i>&nbsp;     * @see #setTransferHandler
<i>1209</i>&nbsp;     * @see TransferHandler
<i>1210</i>&nbsp;     * @since 1.4
<i>1211</i>&nbsp;     */
<i>1212</i>&nbsp;    @BeanProperty(bound = false, description
<i>1213</i>&nbsp;            = &quot;determines whether automatic drag handling is enabled&quot;)
<i>1214</i>&nbsp;    public void setDragEnabled(boolean b) {
<i>1215</i>&nbsp;        checkDragEnabled(b);
<i>1216</i>&nbsp;        dragEnabled = b;
<b class="nc"><i>1217</i>&nbsp;    }</b>
<b class="nc"><i>1218</i>&nbsp;</b>
<i>1219</i>&nbsp;    private static void checkDragEnabled(boolean b) {
<b class="nc"><i>1220</i>&nbsp;        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {</b>
<i>1221</i>&nbsp;            throw new HeadlessException();
<i>1222</i>&nbsp;        }
<i>1223</i>&nbsp;    }
<i>1224</i>&nbsp;
<i>1225</i>&nbsp;    /**
<i>1226</i>&nbsp;     * Returns whether or not automatic drag handling is enabled.
<i>1227</i>&nbsp;     *
<i>1228</i>&nbsp;     * @return the value of the {@code dragEnabled} property
<i>1229</i>&nbsp;     * @see #setDragEnabled
<i>1230</i>&nbsp;     * @since 1.4
<b class="nc"><i>1231</i>&nbsp;     */</b>
<i>1232</i>&nbsp;    public boolean getDragEnabled() {
<i>1233</i>&nbsp;        return dragEnabled;
<i>1234</i>&nbsp;    }
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;    /**
<i>1237</i>&nbsp;     * Sets the drop mode for this component. For backward compatibility,
<i>1238</i>&nbsp;     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
<i>1239</i>&nbsp;     * Usage of one of the other modes is recommended, however, for an
<i>1240</i>&nbsp;     * improved user experience. &lt;code&gt;DropMode.ON&lt;/code&gt;, for instance,
<i>1241</i>&nbsp;     * offers similar behavior of showing items as selected, but does so without
<i>1242</i>&nbsp;     * affecting the actual selection in the tree.
<i>1243</i>&nbsp;     * &lt;p&gt;
<i>1244</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt; supports the following drop modes:
<i>1245</i>&nbsp;     * &lt;ul&gt;
<i>1246</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
<i>1247</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.ON&lt;/code&gt;&lt;/li&gt;
<i>1248</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
<i>1249</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;&lt;/li&gt;
<i>1250</i>&nbsp;     * &lt;/ul&gt;
<i>1251</i>&nbsp;     * &lt;p&gt;
<i>1252</i>&nbsp;     * The drop mode is only meaningful if this component has a
<i>1253</i>&nbsp;     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
<i>1254</i>&nbsp;     *
<i>1255</i>&nbsp;     * @param dropMode the drop mode to use
<i>1256</i>&nbsp;     * @throws IllegalArgumentException if the drop mode is unsupported
<i>1257</i>&nbsp;     *         or &lt;code&gt;null&lt;/code&gt;
<i>1258</i>&nbsp;     * @see #getDropMode
<i>1259</i>&nbsp;     * @see #getDropLocation
<i>1260</i>&nbsp;     * @see #setTransferHandler
<i>1261</i>&nbsp;     * @see TransferHandler
<i>1262</i>&nbsp;     * @since 1.6
<b class="nc"><i>1263</i>&nbsp;     */</b>
<b class="nc"><i>1264</i>&nbsp;    public final void setDropMode(DropMode dropMode) {</b>
<i>1265</i>&nbsp;        checkDropMode(dropMode);
<i>1266</i>&nbsp;        this.dropMode = dropMode;
<i>1267</i>&nbsp;    }
<i>1268</i>&nbsp;
<b class="nc"><i>1269</i>&nbsp;    private static void checkDropMode(DropMode dropMode) {</b>
<i>1270</i>&nbsp;        if (dropMode != null) {
<i>1271</i>&nbsp;            switch (dropMode) {
<i>1272</i>&nbsp;                case USE_SELECTION:
<i>1273</i>&nbsp;                case ON:
<b class="nc"><i>1274</i>&nbsp;                case INSERT:</b>
<i>1275</i>&nbsp;                case ON_OR_INSERT:
<i>1276</i>&nbsp;                    return;
<i>1277</i>&nbsp;            }
<i>1278</i>&nbsp;        }
<i>1279</i>&nbsp;
<i>1280</i>&nbsp;        throw new IllegalArgumentException(dropMode +
<i>1281</i>&nbsp;                &quot;: Unsupported drop mode for tree&quot;);
<i>1282</i>&nbsp;    }
<i>1283</i>&nbsp;
<i>1284</i>&nbsp;    /**
<b class="nc"><i>1285</i>&nbsp;     * Returns the drop mode for this component.</b>
<i>1286</i>&nbsp;     *
<i>1287</i>&nbsp;     * @return the drop mode for this component
<i>1288</i>&nbsp;     * @see #setDropMode
<i>1289</i>&nbsp;     * @since 1.6
<i>1290</i>&nbsp;     */
<i>1291</i>&nbsp;    public final DropMode getDropMode() {
<i>1292</i>&nbsp;        return dropMode;
<i>1293</i>&nbsp;    }
<i>1294</i>&nbsp;
<i>1295</i>&nbsp;    /**
<b class="nc"><i>1296</i>&nbsp;     * Calculates a drop location in this component, representing where a</b>
<i>1297</i>&nbsp;     * drop at the given point should insert data.
<b class="nc"><i>1298</i>&nbsp;     *</b>
<b class="nc"><i>1299</i>&nbsp;     * @param p the point to calculate a drop location for</b>
<b class="nc"><i>1300</i>&nbsp;     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;</b>
<b class="nc"><i>1301</i>&nbsp;     */</b>
<b class="nc"><i>1302</i>&nbsp;    DropLocation dropLocationForPoint(Point p) {</b>
<i>1303</i>&nbsp;        DropLocation location = null;
<i>1304</i>&nbsp;
<i>1305</i>&nbsp;        int row = getClosestRowForLocation(p.x, p.y);
<b class="nc"><i>1306</i>&nbsp;        Rectangle bounds = getRowBounds(row);</b>
<i>1307</i>&nbsp;        TreeModel model = getModel();
<i>1308</i>&nbsp;        Object root = (model == null) ? null : model.getRoot();
<i>1309</i>&nbsp;        TreePath rootPath = (root == null) ? null : new TreePath(root);
<b class="nc"><i>1310</i>&nbsp;</b>
<i>1311</i>&nbsp;        TreePath child;
<i>1312</i>&nbsp;        TreePath parent;
<b class="nc"><i>1313</i>&nbsp;        boolean outside = row == -1</b>
<b class="nc"><i>1314</i>&nbsp;                          || p.y &lt; bounds.y</b>
<i>1315</i>&nbsp;                          || p.y &gt;= bounds.y + bounds.height;
<b class="nc"><i>1316</i>&nbsp;</b>
<i>1317</i>&nbsp;        switch(dropMode) {
<i>1318</i>&nbsp;            case USE_SELECTION:
<b class="nc"><i>1319</i>&nbsp;            case ON:</b>
<i>1320</i>&nbsp;                if (outside) {
<i>1321</i>&nbsp;                    location = new DropLocation(p, null, -1);
<b class="nc"><i>1322</i>&nbsp;                } else {</b>
<b class="nc"><i>1323</i>&nbsp;                    location = new DropLocation(p, getPathForRow(row), -1);</b>
<b class="nc"><i>1324</i>&nbsp;                }</b>
<i>1325</i>&nbsp;
<b class="nc"><i>1326</i>&nbsp;                break;</b>
<i>1327</i>&nbsp;            case INSERT:
<i>1328</i>&nbsp;            case ON_OR_INSERT:
<b class="nc"><i>1329</i>&nbsp;                if (row == -1) {</b>
<i>1330</i>&nbsp;                    if (root != null &amp;&amp; !model.isLeaf(root) &amp;&amp; isExpanded(rootPath)) {
<i>1331</i>&nbsp;                        location = new DropLocation(p, rootPath, 0);
<b class="nc"><i>1332</i>&nbsp;                    } else {</b>
<b class="nc"><i>1333</i>&nbsp;                        location = new DropLocation(p, null, -1);</b>
<i>1334</i>&nbsp;                    }
<b class="nc"><i>1335</i>&nbsp;</b>
<b class="nc"><i>1336</i>&nbsp;                    break;</b>
<b class="nc"><i>1337</i>&nbsp;                }</b>
<b class="nc"><i>1338</i>&nbsp;</b>
<b class="nc"><i>1339</i>&nbsp;                boolean checkOn = dropMode == DropMode.ON_OR_INSERT</b>
<b class="nc"><i>1340</i>&nbsp;                                  || !model.isLeaf(getPathForRow(row).getLastPathComponent());</b>
<b class="nc"><i>1341</i>&nbsp;</b>
<b class="nc"><i>1342</i>&nbsp;                Section section = SwingUtilities2.liesInVertical(bounds, p, checkOn);</b>
<b class="nc"><i>1343</i>&nbsp;                if(section == LEADING) {</b>
<i>1344</i>&nbsp;                    child = getPathForRow(row);
<b class="nc"><i>1345</i>&nbsp;                    parent = child.getParentPath();</b>
<b class="nc"><i>1346</i>&nbsp;                } else if (section == TRAILING) {</b>
<b class="nc"><i>1347</i>&nbsp;                    int index = row + 1;</b>
<i>1348</i>&nbsp;                    if (index &gt;= getRowCount()) {
<i>1349</i>&nbsp;                        if (model.isLeaf(root) || !isExpanded(rootPath)) {
<b class="nc"><i>1350</i>&nbsp;                            location = new DropLocation(p, null, -1);</b>
<i>1351</i>&nbsp;                        } else {
<i>1352</i>&nbsp;                            parent = rootPath;
<b class="nc"><i>1353</i>&nbsp;                            index = model.getChildCount(root);</b>
<b class="nc"><i>1354</i>&nbsp;                            location = new DropLocation(p, parent, index);</b>
<b class="nc"><i>1355</i>&nbsp;                        }</b>
<b class="nc"><i>1356</i>&nbsp;</b>
<b class="nc"><i>1357</i>&nbsp;                        break;</b>
<b class="nc"><i>1358</i>&nbsp;                    }</b>
<i>1359</i>&nbsp;
<i>1360</i>&nbsp;                    child = getPathForRow(index);
<b class="nc"><i>1361</i>&nbsp;                    parent = child.getParentPath();</b>
<b class="nc"><i>1362</i>&nbsp;                    TreePath prev = getPathForRow(row).getParentPath();</b>
<b class="nc"><i>1363</i>&nbsp;                    if (prev != null &amp;&amp; !prev.equals(parent)) {</b>
<b class="nc"><i>1364</i>&nbsp;                        location = new DropLocation(p, prev,</b>
<b class="nc"><i>1365</i>&nbsp;                              model.getChildCount(prev.getLastPathComponent()));</b>
<b class="nc"><i>1366</i>&nbsp;                        break;</b>
<i>1367</i>&nbsp;                    }
<b class="nc"><i>1368</i>&nbsp;</b>
<i>1369</i>&nbsp;                } else {
<i>1370</i>&nbsp;                    assert checkOn;
<b class="nc"><i>1371</i>&nbsp;                    location = new DropLocation(p, getPathForRow(row), -1);</b>
<i>1372</i>&nbsp;                    break;
<b class="nc"><i>1373</i>&nbsp;                }</b>
<i>1374</i>&nbsp;
<i>1375</i>&nbsp;                if (parent != null) {
<b class="nc"><i>1376</i>&nbsp;                    location = new DropLocation(p, parent,</b>
<b class="nc"><i>1377</i>&nbsp;                        model.getIndexOfChild(parent.getLastPathComponent(),</b>
<i>1378</i>&nbsp;                                              child.getLastPathComponent()));
<i>1379</i>&nbsp;                } else if (checkOn || !model.isLeaf(root)) {
<b class="nc"><i>1380</i>&nbsp;                    location = new DropLocation(p, rootPath, -1);</b>
<b class="nc"><i>1381</i>&nbsp;                } else {</b>
<b class="nc"><i>1382</i>&nbsp;                    location = new DropLocation(p, null, -1);</b>
<b class="nc"><i>1383</i>&nbsp;                }</b>
<i>1384</i>&nbsp;
<i>1385</i>&nbsp;                break;
<i>1386</i>&nbsp;            default:
<b class="nc"><i>1387</i>&nbsp;                assert false : &quot;Unexpected drop mode&quot;;</b>
<i>1388</i>&nbsp;        }
<i>1389</i>&nbsp;
<i>1390</i>&nbsp;        if (outside || row != expandRow) {
<i>1391</i>&nbsp;            cancelDropTimer();
<i>1392</i>&nbsp;        }
<i>1393</i>&nbsp;
<i>1394</i>&nbsp;        if (!outside &amp;&amp; row != expandRow) {
<i>1395</i>&nbsp;            if (isCollapsed(row)) {
<i>1396</i>&nbsp;                expandRow = row;
<i>1397</i>&nbsp;                startDropTimer();
<i>1398</i>&nbsp;            }
<i>1399</i>&nbsp;        }
<i>1400</i>&nbsp;
<i>1401</i>&nbsp;        return location;
<i>1402</i>&nbsp;    }
<i>1403</i>&nbsp;
<i>1404</i>&nbsp;    /**
<i>1405</i>&nbsp;     * Called to set or clear the drop location during a DnD operation.
<i>1406</i>&nbsp;     * In some cases, the component may need to use it&#39;s internal selection
<i>1407</i>&nbsp;     * temporarily to indicate the drop location. To help facilitate this,
<i>1408</i>&nbsp;     * this method returns and accepts as a parameter a state object.
<i>1409</i>&nbsp;     * This state object can be used to store, and later restore, the selection
<i>1410</i>&nbsp;     * state. Whatever this method returns will be passed back to it in
<i>1411</i>&nbsp;     * future calls, as the state parameter. If it wants the DnD system to
<i>1412</i>&nbsp;     * continue storing the same state, it must pass it back every time.
<i>1413</i>&nbsp;     * Here&#39;s how this is used:
<i>1414</i>&nbsp;     * &lt;p&gt;
<i>1415</i>&nbsp;     * Let&#39;s say that on the first call to this method the component decides
<i>1416</i>&nbsp;     * to save some state (because it is about to use the selection to show
<i>1417</i>&nbsp;     * a drop index). It can return a state object to the caller encapsulating
<i>1418</i>&nbsp;     * any saved selection state. On a second call, let&#39;s say the drop location
<i>1419</i>&nbsp;     * is being changed to something else. The component doesn&#39;t need to
<i>1420</i>&nbsp;     * restore anything yet, so it simply passes back the same state object
<i>1421</i>&nbsp;     * to have the DnD system continue storing it. Finally, let&#39;s say this
<i>1422</i>&nbsp;     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
<i>1423</i>&nbsp;     * is finished with this component for now, meaning it should restore
<i>1424</i>&nbsp;     * state. At this point, it can use the state parameter to restore
<i>1425</i>&nbsp;     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there&#39;s
<i>1426</i>&nbsp;     * no longer anything to store.
<b class="nc"><i>1427</i>&nbsp;     *</b>
<b class="nc"><i>1428</i>&nbsp;     * @param location the drop location (as calculated by</b>
<i>1429</i>&nbsp;     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>1430</i>&nbsp;     *        if there&#39;s no longer a valid drop location</b>
<b class="nc"><i>1431</i>&nbsp;     * @param state the state object saved earlier for this component,</b>
<b class="nc"><i>1432</i>&nbsp;     *        or &lt;code&gt;null&lt;/code&gt;</b>
<b class="nc"><i>1433</i>&nbsp;     * @param forDrop whether or not the method is being called because an</b>
<b class="nc"><i>1434</i>&nbsp;     *        actual drop occurred</b>
<b class="nc"><i>1435</i>&nbsp;     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none</b>
<i>1436</i>&nbsp;     */
<i>1437</i>&nbsp;    Object setDropLocation(TransferHandler.DropLocation location,
<b class="nc"><i>1438</i>&nbsp;                           Object state,</b>
<b class="nc"><i>1439</i>&nbsp;                           boolean forDrop) {</b>
<b class="nc"><i>1440</i>&nbsp;</b>
<b class="nc"><i>1441</i>&nbsp;        Object retVal = null;</b>
<i>1442</i>&nbsp;        DropLocation treeLocation = (DropLocation)location;
<i>1443</i>&nbsp;
<b class="nc"><i>1444</i>&nbsp;        if (dropMode == DropMode.USE_SELECTION) {</b>
<b class="nc"><i>1445</i>&nbsp;            if (treeLocation == null) {</b>
<b class="nc"><i>1446</i>&nbsp;                if (!forDrop &amp;&amp; state != null) {</b>
<b class="nc"><i>1447</i>&nbsp;                    setSelectionPaths(((TreePath[][])state)[0]);</b>
<i>1448</i>&nbsp;                    setAnchorSelectionPath(((TreePath[][])state)[1][0]);
<i>1449</i>&nbsp;                    setLeadSelectionPath(((TreePath[][])state)[1][1]);
<b class="nc"><i>1450</i>&nbsp;                }</b>
<i>1451</i>&nbsp;            } else {
<i>1452</i>&nbsp;                if (dropLocation == null) {
<i>1453</i>&nbsp;                    TreePath[] paths = getSelectionPaths();
<b class="nc"><i>1454</i>&nbsp;                    if (paths == null) {</b>
<b class="nc"><i>1455</i>&nbsp;                        paths = new TreePath[0];</b>
<b class="nc"><i>1456</i>&nbsp;                    }</b>
<i>1457</i>&nbsp;
<b class="nc"><i>1458</i>&nbsp;                    retVal = new TreePath[][] {paths,</b>
<i>1459</i>&nbsp;                            {getAnchorSelectionPath(), getLeadSelectionPath()}};
<i>1460</i>&nbsp;                } else {
<i>1461</i>&nbsp;                    retVal = state;
<i>1462</i>&nbsp;                }
<i>1463</i>&nbsp;
<i>1464</i>&nbsp;                setSelectionPath(treeLocation.getPath());
<i>1465</i>&nbsp;            }
<b class="nc"><i>1466</i>&nbsp;        }</b>
<b class="nc"><i>1467</i>&nbsp;</b>
<i>1468</i>&nbsp;        DropLocation old = dropLocation;
<i>1469</i>&nbsp;        dropLocation = treeLocation;
<i>1470</i>&nbsp;        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);
<i>1471</i>&nbsp;
<i>1472</i>&nbsp;        return retVal;
<i>1473</i>&nbsp;    }
<i>1474</i>&nbsp;
<i>1475</i>&nbsp;    /**
<i>1476</i>&nbsp;     * Called to indicate to this component that DnD is done.
<i>1477</i>&nbsp;     * Allows for us to cancel the expand timer.
<i>1478</i>&nbsp;     */
<i>1479</i>&nbsp;    void dndDone() {
<i>1480</i>&nbsp;        cancelDropTimer();
<i>1481</i>&nbsp;        dropTimer = null;
<i>1482</i>&nbsp;    }
<i>1483</i>&nbsp;
<i>1484</i>&nbsp;    /**
<i>1485</i>&nbsp;     * Returns the location that this component should visually indicate
<i>1486</i>&nbsp;     * as the drop location during a DnD operation over the component,
<i>1487</i>&nbsp;     * or {@code null} if no location is to currently be shown.
<i>1488</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1489</i>&nbsp;     * This method is not meant for querying the drop location</b>
<i>1490</i>&nbsp;     * from a {@code TransferHandler}, as the drop location is only
<i>1491</i>&nbsp;     * set after the {@code TransferHandler}&#39;s &lt;code&gt;canImport&lt;/code&gt;
<i>1492</i>&nbsp;     * has returned and has allowed for the location to be shown.
<b class="nc"><i>1493</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1494</i>&nbsp;     * When this property changes, a property change event with</b>
<i>1495</i>&nbsp;     * name &quot;dropLocation&quot; is fired by the component.
<b class="nc"><i>1496</i>&nbsp;     *</b>
<i>1497</i>&nbsp;     * @return the drop location
<i>1498</i>&nbsp;     * @see #setDropMode
<i>1499</i>&nbsp;     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
<b class="nc"><i>1500</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>1501</i>&nbsp;     */</b>
<b class="nc"><i>1502</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>1503</i>&nbsp;    public final DropLocation getDropLocation() {
<i>1504</i>&nbsp;        return dropLocation;
<i>1505</i>&nbsp;    }
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;    private void startDropTimer() {
<i>1508</i>&nbsp;        if (dropTimer == null) {
<i>1509</i>&nbsp;            dropTimer = new TreeTimer();
<i>1510</i>&nbsp;        }
<i>1511</i>&nbsp;        dropTimer.start();
<i>1512</i>&nbsp;    }
<i>1513</i>&nbsp;
<i>1514</i>&nbsp;    private void cancelDropTimer() {
<i>1515</i>&nbsp;        if (dropTimer != null &amp;&amp; dropTimer.isRunning()) {
<b class="nc"><i>1516</i>&nbsp;            expandRow = -1;</b>
<i>1517</i>&nbsp;            dropTimer.stop();
<i>1518</i>&nbsp;        }
<i>1519</i>&nbsp;    }
<i>1520</i>&nbsp;
<i>1521</i>&nbsp;    /**
<i>1522</i>&nbsp;     * Returns &lt;code&gt;isEditable&lt;/code&gt;. This is invoked from the UI before
<i>1523</i>&nbsp;     * editing begins to insure that the given path can be edited. This
<i>1524</i>&nbsp;     * is provided as an entry point for subclassers to add filtered
<i>1525</i>&nbsp;     * editing without having to resort to creating a new editor.
<i>1526</i>&nbsp;     *
<i>1527</i>&nbsp;     * @param path a {@code TreePath} identifying a node
<i>1528</i>&nbsp;     * @return true if every parent node and the node itself is editable
<i>1529</i>&nbsp;     * @see #isEditable
<i>1530</i>&nbsp;     */
<i>1531</i>&nbsp;    public boolean isPathEditable(TreePath path) {
<i>1532</i>&nbsp;        return isEditable();
<i>1533</i>&nbsp;    }
<i>1534</i>&nbsp;
<i>1535</i>&nbsp;    /**
<b class="nc"><i>1536</i>&nbsp;     * Overrides &lt;code&gt;JComponent&lt;/code&gt;&#39;s &lt;code&gt;getToolTipText&lt;/code&gt;</b>
<i>1537</i>&nbsp;     * method in order to allow
<b class="nc"><i>1538</i>&nbsp;     * renderer&#39;s tips to be used if it has text set.</b>
<b class="nc"><i>1539</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1540</i>&nbsp;     * NOTE: For &lt;code&gt;JTree&lt;/code&gt; to properly display tooltips of its</b>
<b class="nc"><i>1541</i>&nbsp;     * renderers, &lt;code&gt;JTree&lt;/code&gt; must be a registered component with the</b>
<i>1542</i>&nbsp;     * &lt;code&gt;ToolTipManager&lt;/code&gt;.  This can be done by invoking
<b class="nc"><i>1543</i>&nbsp;     * &lt;code&gt;ToolTipManager.sharedInstance().registerComponent(tree)&lt;/code&gt;.</b>
<b class="nc"><i>1544</i>&nbsp;     * This is not done automatically!</b>
<b class="nc"><i>1545</i>&nbsp;     *</b>
<b class="nc"><i>1546</i>&nbsp;     * @param event the &lt;code&gt;MouseEvent&lt;/code&gt; that initiated the</b>
<b class="nc"><i>1547</i>&nbsp;     *          &lt;code&gt;ToolTip&lt;/code&gt; display</b>
<b class="nc"><i>1548</i>&nbsp;     * @return a string containing the  tooltip or &lt;code&gt;null&lt;/code&gt;</b>
<i>1549</i>&nbsp;     *          if &lt;code&gt;event&lt;/code&gt; is null
<i>1550</i>&nbsp;     */
<b class="nc"><i>1551</i>&nbsp;    public String getToolTipText(MouseEvent event) {</b>
<i>1552</i>&nbsp;        String tip = null;
<b class="nc"><i>1553</i>&nbsp;</b>
<i>1554</i>&nbsp;        if(event != null) {
<b class="nc"><i>1555</i>&nbsp;            Point p = event.getPoint();</b>
<b class="nc"><i>1556</i>&nbsp;            int selRow = getRowForLocation(p.x, p.y);</b>
<b class="nc"><i>1557</i>&nbsp;            TreeCellRenderer       r = getCellRenderer();</b>
<b class="nc"><i>1558</i>&nbsp;</b>
<i>1559</i>&nbsp;            if(selRow != -1 &amp;&amp; r != null) {
<b class="nc"><i>1560</i>&nbsp;                TreePath     path = getPathForRow(selRow);</b>
<b class="nc"><i>1561</i>&nbsp;                Object       lastPath = path.getLastPathComponent();</b>
<b class="nc"><i>1562</i>&nbsp;                Component    rComponent = r.getTreeCellRendererComponent</b>
<b class="nc"><i>1563</i>&nbsp;                    (this, lastPath, isRowSelected(selRow),</b>
<i>1564</i>&nbsp;                     isExpanded(selRow), getModel().isLeaf(lastPath), selRow,
<i>1565</i>&nbsp;                     true);
<b class="nc"><i>1566</i>&nbsp;</b>
<i>1567</i>&nbsp;                if(rComponent instanceof JComponent) {
<i>1568</i>&nbsp;                    MouseEvent      newEvent;
<i>1569</i>&nbsp;                    Rectangle       pathBounds = getPathBounds(path);
<i>1570</i>&nbsp;
<b class="nc"><i>1571</i>&nbsp;                    p.translate(-pathBounds.x, -pathBounds.y);</b>
<b class="nc"><i>1572</i>&nbsp;                    @SuppressWarnings(&quot;deprecation&quot;)</b>
<i>1573</i>&nbsp;                    final int modifiers = event.getModifiers();
<b class="nc"><i>1574</i>&nbsp;                    newEvent = new MouseEvent(rComponent, event.getID(),</b>
<i>1575</i>&nbsp;                                          event.getWhen(), modifiers,
<i>1576</i>&nbsp;                                              p.x, p.y,
<i>1577</i>&nbsp;                                              event.getXOnScreen(),
<i>1578</i>&nbsp;                                              event.getYOnScreen(),
<i>1579</i>&nbsp;                                              event.getClickCount(),
<i>1580</i>&nbsp;                                              event.isPopupTrigger(),
<i>1581</i>&nbsp;                                              MouseEvent.NOBUTTON);
<i>1582</i>&nbsp;                    MouseEventAccessor meAccessor =
<i>1583</i>&nbsp;                        AWTAccessor.getMouseEventAccessor();
<i>1584</i>&nbsp;                    meAccessor.setCausedByTouchEvent(newEvent,
<i>1585</i>&nbsp;                        meAccessor.isCausedByTouchEvent(event));
<i>1586</i>&nbsp;
<i>1587</i>&nbsp;                    tip = ((JComponent)rComponent).getToolTipText(newEvent);
<i>1588</i>&nbsp;                }
<i>1589</i>&nbsp;            }
<i>1590</i>&nbsp;        }
<i>1591</i>&nbsp;        // No tip from the renderer get our own tip
<i>1592</i>&nbsp;        if (tip == null) {
<i>1593</i>&nbsp;            tip = getToolTipText();
<i>1594</i>&nbsp;        }
<b class="nc"><i>1595</i>&nbsp;        return tip;</b>
<b class="nc"><i>1596</i>&nbsp;    }</b>
<b class="nc"><i>1597</i>&nbsp;</b>
<b class="nc"><i>1598</i>&nbsp;    /**</b>
<i>1599</i>&nbsp;     * Called by the renderers to convert the specified value to
<i>1600</i>&nbsp;     * text. This implementation returns &lt;code&gt;value.toString&lt;/code&gt;, ignoring
<b class="nc"><i>1601</i>&nbsp;     * all other arguments. To control the conversion, subclass this</b>
<i>1602</i>&nbsp;     * method and use any of the arguments you need.
<i>1603</i>&nbsp;     *
<i>1604</i>&nbsp;     * @param value the &lt;code&gt;Object&lt;/code&gt; to convert to text
<i>1605</i>&nbsp;     * @param selected true if the node is selected
<i>1606</i>&nbsp;     * @param expanded true if the node is expanded
<i>1607</i>&nbsp;     * @param leaf  true if the node is a leaf node
<i>1608</i>&nbsp;     * @param row  an integer specifying the node&#39;s display row, where 0 is
<i>1609</i>&nbsp;     *             the first row in the display
<i>1610</i>&nbsp;     * @param hasFocus true if the node has the focus
<i>1611</i>&nbsp;     * @return the &lt;code&gt;String&lt;/code&gt; representation of the node&#39;s value
<i>1612</i>&nbsp;     */
<i>1613</i>&nbsp;    public String convertValueToText(Object value, boolean selected,
<i>1614</i>&nbsp;                                     boolean expanded, boolean leaf, int row,
<i>1615</i>&nbsp;                                     boolean hasFocus) {
<i>1616</i>&nbsp;        if(value != null) {
<i>1617</i>&nbsp;            String sValue = value.toString();
<b class="nc"><i>1618</i>&nbsp;            if (sValue != null) {</b>
<i>1619</i>&nbsp;                return sValue;
<b class="nc"><i>1620</i>&nbsp;            }</b>
<b class="nc"><i>1621</i>&nbsp;        }</b>
<b class="nc"><i>1622</i>&nbsp;        return &quot;&quot;;</b>
<i>1623</i>&nbsp;    }
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;    //
<i>1626</i>&nbsp;    // The following are convenience methods that get forwarded to the
<i>1627</i>&nbsp;    // current TreeUI.
<i>1628</i>&nbsp;    //
<i>1629</i>&nbsp;
<i>1630</i>&nbsp;    /**
<i>1631</i>&nbsp;     * Returns the number of viewable nodes. A node is viewable if all of its
<i>1632</i>&nbsp;     * parents are expanded. The root is only included in this count if
<i>1633</i>&nbsp;     * {@code isRootVisible()} is {@code true}. This returns {@code 0} if
<b class="nc"><i>1634</i>&nbsp;     * the UI has not been set.</b>
<i>1635</i>&nbsp;     *
<i>1636</i>&nbsp;     * @return the number of viewable nodes
<i>1637</i>&nbsp;     */
<i>1638</i>&nbsp;    @BeanProperty(bound = false)
<i>1639</i>&nbsp;    public int getRowCount() {
<i>1640</i>&nbsp;        TreeUI            tree = getUI();
<i>1641</i>&nbsp;
<i>1642</i>&nbsp;        if(tree != null)
<i>1643</i>&nbsp;            return tree.getRowCount(this);
<i>1644</i>&nbsp;        return 0;
<i>1645</i>&nbsp;    }
<i>1646</i>&nbsp;
<b class="nc"><i>1647</i>&nbsp;    /**</b>
<i>1648</i>&nbsp;     * Selects the node identified by the specified path. If any
<i>1649</i>&nbsp;     * component of the path is hidden (under a collapsed node), and
<i>1650</i>&nbsp;     * &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true it is
<i>1651</i>&nbsp;     * exposed (made viewable).
<i>1652</i>&nbsp;     *
<i>1653</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; specifying the node to select
<i>1654</i>&nbsp;     */
<i>1655</i>&nbsp;    public void setSelectionPath(TreePath path) {
<i>1656</i>&nbsp;        getSelectionModel().setSelectionPath(path);
<i>1657</i>&nbsp;    }
<i>1658</i>&nbsp;
<i>1659</i>&nbsp;    /**
<i>1660</i>&nbsp;     * Selects the nodes identified by the specified array of paths.
<i>1661</i>&nbsp;     * If any component in any of the paths is hidden (under a collapsed
<i>1662</i>&nbsp;     * node), and &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true
<i>1663</i>&nbsp;     * it is exposed (made viewable).
<b class="nc"><i>1664</i>&nbsp;     *</b>
<i>1665</i>&nbsp;     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that specifies
<b class="nc"><i>1666</i>&nbsp;     *          the nodes to select</b>
<b class="nc"><i>1667</i>&nbsp;     */</b>
<i>1668</i>&nbsp;    public void setSelectionPaths(TreePath[] paths) {
<b class="nc"><i>1669</i>&nbsp;        getSelectionModel().setSelectionPaths(paths);</b>
<b class="nc"><i>1670</i>&nbsp;    }</b>
<b class="nc"><i>1671</i>&nbsp;</b>
<i>1672</i>&nbsp;    /**
<i>1673</i>&nbsp;     * Sets the path identifies as the lead. The lead may not be selected.
<i>1674</i>&nbsp;     * The lead is not maintained by &lt;code&gt;JTree&lt;/code&gt;,
<i>1675</i>&nbsp;     * rather the UI will update it.
<i>1676</i>&nbsp;     * &lt;p&gt;
<i>1677</i>&nbsp;     * This is a bound property.
<i>1678</i>&nbsp;     *
<i>1679</i>&nbsp;     * @param newPath  the new lead path
<i>1680</i>&nbsp;     * @since 1.3
<i>1681</i>&nbsp;     */
<i>1682</i>&nbsp;    @BeanProperty(description
<i>1683</i>&nbsp;            = &quot;Lead selection path&quot;)
<i>1684</i>&nbsp;    public void setLeadSelectionPath(TreePath newPath) {
<i>1685</i>&nbsp;        TreePath          oldValue = leadPath;
<i>1686</i>&nbsp;
<i>1687</i>&nbsp;        leadPath = newPath;
<i>1688</i>&nbsp;        firePropertyChange(LEAD_SELECTION_PATH_PROPERTY, oldValue, newPath);
<b class="nc"><i>1689</i>&nbsp;</b>
<i>1690</i>&nbsp;        // Fire the active descendant property change here since the
<b class="nc"><i>1691</i>&nbsp;        // leadPath got set, this is triggered both in case node</b>
<b class="nc"><i>1692</i>&nbsp;        // selection changed and node focus changed</b>
<i>1693</i>&nbsp;        if (accessibleContext != null){
<i>1694</i>&nbsp;            ((AccessibleJTree)accessibleContext).
<i>1695</i>&nbsp;                fireActiveDescendantPropertyChange(oldValue, newPath);
<i>1696</i>&nbsp;        }
<i>1697</i>&nbsp;    }
<i>1698</i>&nbsp;
<i>1699</i>&nbsp;    /**
<i>1700</i>&nbsp;     * Sets the path identified as the anchor.
<i>1701</i>&nbsp;     * The anchor is not maintained by &lt;code&gt;JTree&lt;/code&gt;, rather the UI will
<b class="nc"><i>1702</i>&nbsp;     * update it.</b>
<i>1703</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1704</i>&nbsp;     * This is a bound property.</b>
<i>1705</i>&nbsp;     *
<i>1706</i>&nbsp;     * @param newPath  the new anchor path
<i>1707</i>&nbsp;     * @since 1.3
<i>1708</i>&nbsp;     */
<i>1709</i>&nbsp;    @BeanProperty(description
<i>1710</i>&nbsp;            = &quot;Anchor selection path&quot;)
<i>1711</i>&nbsp;    public void setAnchorSelectionPath(TreePath newPath) {
<i>1712</i>&nbsp;        TreePath          oldValue = anchorPath;
<i>1713</i>&nbsp;
<i>1714</i>&nbsp;        anchorPath = newPath;
<i>1715</i>&nbsp;        firePropertyChange(ANCHOR_SELECTION_PATH_PROPERTY, oldValue, newPath);
<i>1716</i>&nbsp;    }
<i>1717</i>&nbsp;
<i>1718</i>&nbsp;    /**
<i>1719</i>&nbsp;     * Selects the node at the specified row in the display.
<b class="nc"><i>1720</i>&nbsp;     *</b>
<i>1721</i>&nbsp;     * @param row  the row to select, where 0 is the first row in
<b class="nc"><i>1722</i>&nbsp;     *             the display</b>
<b class="nc"><i>1723</i>&nbsp;     */</b>
<b class="nc"><i>1724</i>&nbsp;    public void setSelectionRow(int row) {</b>
<i>1725</i>&nbsp;        int[]             rows = { row };
<b class="nc"><i>1726</i>&nbsp;</b>
<b class="nc"><i>1727</i>&nbsp;        setSelectionRows(rows);</b>
<i>1728</i>&nbsp;    }
<b class="nc"><i>1729</i>&nbsp;</b>
<i>1730</i>&nbsp;    /**
<i>1731</i>&nbsp;     * Selects the nodes corresponding to each of the specified rows
<i>1732</i>&nbsp;     * in the display. If a particular element of &lt;code&gt;rows&lt;/code&gt; is
<i>1733</i>&nbsp;     * &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt;, it will be ignored.
<i>1734</i>&nbsp;     * If none of the elements
<i>1735</i>&nbsp;     * in &lt;code&gt;rows&lt;/code&gt; are valid rows, the selection will
<i>1736</i>&nbsp;     * be cleared. That is it will be as if &lt;code&gt;clearSelection&lt;/code&gt;
<i>1737</i>&nbsp;     * was invoked.
<i>1738</i>&nbsp;     *
<i>1739</i>&nbsp;     * @param rows  an array of ints specifying the rows to select,
<i>1740</i>&nbsp;     *              where 0 indicates the first row in the display
<i>1741</i>&nbsp;     */
<i>1742</i>&nbsp;    public void setSelectionRows(int[] rows) {
<i>1743</i>&nbsp;        TreeUI               ui = getUI();
<i>1744</i>&nbsp;
<i>1745</i>&nbsp;        if(ui != null &amp;&amp; rows != null) {
<b class="nc"><i>1746</i>&nbsp;            int                  numRows = rows.length;</b>
<i>1747</i>&nbsp;            TreePath[]           paths = new TreePath[numRows];
<i>1748</i>&nbsp;
<i>1749</i>&nbsp;            for(int counter = 0; counter &lt; numRows; counter++) {
<i>1750</i>&nbsp;                paths[counter] = ui.getPathForRow(this, rows[counter]);
<i>1751</i>&nbsp;            }
<i>1752</i>&nbsp;            setSelectionPaths(paths);
<i>1753</i>&nbsp;        }
<i>1754</i>&nbsp;    }
<i>1755</i>&nbsp;
<i>1756</i>&nbsp;    /**
<i>1757</i>&nbsp;     * Adds the node identified by the specified &lt;code&gt;TreePath&lt;/code&gt;
<i>1758</i>&nbsp;     * to the current selection. If any component of the path isn&#39;t
<i>1759</i>&nbsp;     * viewable, and &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true it is
<i>1760</i>&nbsp;     * made viewable.
<i>1761</i>&nbsp;     * &lt;p&gt;
<i>1762</i>&nbsp;     * Note that &lt;code&gt;JTree&lt;/code&gt; does not allow duplicate nodes to
<b class="nc"><i>1763</i>&nbsp;     * exist as children under the same parent -- each sibling must be</b>
<i>1764</i>&nbsp;     * a unique object.
<i>1765</i>&nbsp;     *
<i>1766</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; to add
<i>1767</i>&nbsp;     */
<i>1768</i>&nbsp;    public void addSelectionPath(TreePath path) {
<i>1769</i>&nbsp;        getSelectionModel().addSelectionPath(path);
<i>1770</i>&nbsp;    }
<i>1771</i>&nbsp;
<i>1772</i>&nbsp;    /**
<b class="nc"><i>1773</i>&nbsp;     * Adds each path in the array of paths to the current selection. If</b>
<i>1774</i>&nbsp;     * any component of any of the paths isn&#39;t viewable and
<b class="nc"><i>1775</i>&nbsp;     * &lt;code&gt;getExpandsSelectedPaths&lt;/code&gt; is true, it is</b>
<i>1776</i>&nbsp;     * made viewable.
<i>1777</i>&nbsp;     * &lt;p&gt;
<i>1778</i>&nbsp;     * Note that &lt;code&gt;JTree&lt;/code&gt; does not allow duplicate nodes to
<i>1779</i>&nbsp;     * exist as children under the same parent -- each sibling must be
<i>1780</i>&nbsp;     * a unique object.
<i>1781</i>&nbsp;     *
<i>1782</i>&nbsp;     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that specifies
<i>1783</i>&nbsp;     *          the nodes to add
<i>1784</i>&nbsp;     */
<b class="nc"><i>1785</i>&nbsp;    public void addSelectionPaths(TreePath[] paths) {</b>
<i>1786</i>&nbsp;        getSelectionModel().addSelectionPaths(paths);
<b class="nc"><i>1787</i>&nbsp;    }</b>
<b class="nc"><i>1788</i>&nbsp;</b>
<b class="nc"><i>1789</i>&nbsp;    /**</b>
<i>1790</i>&nbsp;     * Adds the path at the specified row to the current selection.
<b class="nc"><i>1791</i>&nbsp;     *</b>
<b class="nc"><i>1792</i>&nbsp;     * @param row  an integer specifying the row of the node to add,</b>
<b class="nc"><i>1793</i>&nbsp;     *             where 0 is the first row in the display</b>
<i>1794</i>&nbsp;     */
<i>1795</i>&nbsp;    public void addSelectionRow(int row) {
<i>1796</i>&nbsp;        int[]      rows = { row };
<i>1797</i>&nbsp;
<i>1798</i>&nbsp;        addSelectionRows(rows);
<i>1799</i>&nbsp;    }
<i>1800</i>&nbsp;
<i>1801</i>&nbsp;    /**
<i>1802</i>&nbsp;     * Adds the paths at each of the specified rows to the current selection.
<i>1803</i>&nbsp;     *
<i>1804</i>&nbsp;     * @param rows  an array of ints specifying the rows to add,
<i>1805</i>&nbsp;     *              where 0 indicates the first row in the display
<i>1806</i>&nbsp;     */
<i>1807</i>&nbsp;    public void addSelectionRows(int[] rows) {
<b class="nc"><i>1808</i>&nbsp;        TreeUI             ui = getUI();</b>
<i>1809</i>&nbsp;
<b class="nc"><i>1810</i>&nbsp;        if(ui != null &amp;&amp; rows != null) {</b>
<b class="nc"><i>1811</i>&nbsp;            int                  numRows = rows.length;</b>
<b class="nc"><i>1812</i>&nbsp;            TreePath[]           paths = new TreePath[numRows];</b>
<i>1813</i>&nbsp;
<i>1814</i>&nbsp;            for(int counter = 0; counter &lt; numRows; counter++)
<i>1815</i>&nbsp;                paths[counter] = ui.getPathForRow(this, rows[counter]);
<i>1816</i>&nbsp;            addSelectionPaths(paths);
<i>1817</i>&nbsp;        }
<i>1818</i>&nbsp;    }
<i>1819</i>&nbsp;
<b class="nc"><i>1820</i>&nbsp;    /**</b>
<i>1821</i>&nbsp;     * Returns the last path component of the selected path. This is
<i>1822</i>&nbsp;     * a convenience method for
<i>1823</i>&nbsp;     * {@code getSelectionModel().getSelectionPath().getLastPathComponent()}.
<i>1824</i>&nbsp;     * This is typically only useful if the selection has one path.
<i>1825</i>&nbsp;     *
<i>1826</i>&nbsp;     * @return the last path component of the selected path, or
<i>1827</i>&nbsp;     *         &lt;code&gt;null&lt;/code&gt; if nothing is selected
<i>1828</i>&nbsp;     * @see TreePath#getLastPathComponent
<b class="nc"><i>1829</i>&nbsp;     */</b>
<i>1830</i>&nbsp;    @BeanProperty(bound = false)
<i>1831</i>&nbsp;    public Object getLastSelectedPathComponent() {
<i>1832</i>&nbsp;        TreePath     selPath = getSelectionModel().getSelectionPath();
<i>1833</i>&nbsp;
<i>1834</i>&nbsp;        if(selPath != null)
<i>1835</i>&nbsp;            return selPath.getLastPathComponent();
<i>1836</i>&nbsp;        return null;
<i>1837</i>&nbsp;    }
<i>1838</i>&nbsp;
<b class="nc"><i>1839</i>&nbsp;    /**</b>
<i>1840</i>&nbsp;     * Returns the path identified as the lead.
<i>1841</i>&nbsp;     * @return path identified as the lead
<i>1842</i>&nbsp;     */
<i>1843</i>&nbsp;    public TreePath getLeadSelectionPath() {
<i>1844</i>&nbsp;        return leadPath;
<i>1845</i>&nbsp;    }
<i>1846</i>&nbsp;
<i>1847</i>&nbsp;    /**
<i>1848</i>&nbsp;     * Returns the path identified as the anchor.
<b class="nc"><i>1849</i>&nbsp;     * @return path identified as the anchor</b>
<i>1850</i>&nbsp;     * @since 1.3
<b class="nc"><i>1851</i>&nbsp;     */</b>
<i>1852</i>&nbsp;    public TreePath getAnchorSelectionPath() {
<i>1853</i>&nbsp;        return anchorPath;
<i>1854</i>&nbsp;    }
<i>1855</i>&nbsp;
<i>1856</i>&nbsp;    /**
<i>1857</i>&nbsp;     * Returns the path to the first selected node.
<i>1858</i>&nbsp;     *
<i>1859</i>&nbsp;     * @return the &lt;code&gt;TreePath&lt;/code&gt; for the first selected node,
<i>1860</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if nothing is currently selected
<i>1861</i>&nbsp;     */
<i>1862</i>&nbsp;    public TreePath getSelectionPath() {
<i>1863</i>&nbsp;        return getSelectionModel().getSelectionPath();
<i>1864</i>&nbsp;    }
<b class="nc"><i>1865</i>&nbsp;</b>
<i>1866</i>&nbsp;    /**
<i>1867</i>&nbsp;     * Returns the paths of all selected values.
<i>1868</i>&nbsp;     *
<i>1869</i>&nbsp;     * @return an array of &lt;code&gt;TreePath&lt;/code&gt; objects indicating the selected
<i>1870</i>&nbsp;     *         nodes, or &lt;code&gt;null&lt;/code&gt; if nothing is currently selected
<i>1871</i>&nbsp;     */
<i>1872</i>&nbsp;    public TreePath[] getSelectionPaths() {
<i>1873</i>&nbsp;        TreePath[] selectionPaths = getSelectionModel().getSelectionPaths();
<b class="nc"><i>1874</i>&nbsp;</b>
<i>1875</i>&nbsp;        return (selectionPaths != null &amp;&amp; selectionPaths.length &gt; 0) ? selectionPaths : null;
<i>1876</i>&nbsp;    }
<i>1877</i>&nbsp;
<i>1878</i>&nbsp;    /**
<i>1879</i>&nbsp;     * Returns all of the currently selected rows. This method is simply
<i>1880</i>&nbsp;     * forwarded to the &lt;code&gt;TreeSelectionModel&lt;/code&gt;.
<i>1881</i>&nbsp;     * If nothing is selected &lt;code&gt;null&lt;/code&gt; or an empty array will
<i>1882</i>&nbsp;     * be returned, based on the &lt;code&gt;TreeSelectionModel&lt;/code&gt;
<i>1883</i>&nbsp;     * implementation.
<b class="nc"><i>1884</i>&nbsp;     *</b>
<i>1885</i>&nbsp;     * @return an array of integers that identifies all currently selected rows
<i>1886</i>&nbsp;     *         where 0 is the first row in the display
<i>1887</i>&nbsp;     */
<i>1888</i>&nbsp;    public int[] getSelectionRows() {
<i>1889</i>&nbsp;        return getSelectionModel().getSelectionRows();
<i>1890</i>&nbsp;    }
<i>1891</i>&nbsp;
<i>1892</i>&nbsp;    /**
<i>1893</i>&nbsp;     * Returns the number of nodes selected.
<b class="nc"><i>1894</i>&nbsp;     *</b>
<i>1895</i>&nbsp;     * @return the number of nodes selected
<i>1896</i>&nbsp;     */
<i>1897</i>&nbsp;    @BeanProperty(bound = false)
<i>1898</i>&nbsp;    public int getSelectionCount() {
<i>1899</i>&nbsp;        return selectionModel.getSelectionCount();
<i>1900</i>&nbsp;    }
<i>1901</i>&nbsp;
<i>1902</i>&nbsp;    /**
<i>1903</i>&nbsp;     * Returns the smallest selected row. If the selection is empty, or
<i>1904</i>&nbsp;     * none of the selected paths are viewable, {@code -1} is returned.
<b class="nc"><i>1905</i>&nbsp;     *</b>
<i>1906</i>&nbsp;     * @return the smallest selected row
<b class="nc"><i>1907</i>&nbsp;     */</b>
<b class="nc"><i>1908</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>1909</i>&nbsp;    public int getMinSelectionRow() {
<b class="nc"><i>1910</i>&nbsp;        return getSelectionModel().getMinSelectionRow();</b>
<i>1911</i>&nbsp;    }
<i>1912</i>&nbsp;
<i>1913</i>&nbsp;    /**
<i>1914</i>&nbsp;     * Returns the largest selected row. If the selection is empty, or
<i>1915</i>&nbsp;     * none of the selected paths are viewable, {@code -1} is returned.
<i>1916</i>&nbsp;     *
<i>1917</i>&nbsp;     * @return the largest selected row
<i>1918</i>&nbsp;     */
<i>1919</i>&nbsp;    @BeanProperty(bound = false)
<b class="nc"><i>1920</i>&nbsp;    public int getMaxSelectionRow() {</b>
<i>1921</i>&nbsp;        return getSelectionModel().getMaxSelectionRow();
<i>1922</i>&nbsp;    }
<i>1923</i>&nbsp;
<i>1924</i>&nbsp;    /**
<i>1925</i>&nbsp;     * Returns the row index corresponding to the lead path.
<i>1926</i>&nbsp;     *
<i>1927</i>&nbsp;     * @return an integer giving the row index of the lead path,
<i>1928</i>&nbsp;     *          where 0 is the first row in the display; or -1
<i>1929</i>&nbsp;     *          if &lt;code&gt;leadPath&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1930</i>&nbsp;     */
<b class="nc"><i>1931</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>1932</i>&nbsp;    public int getLeadSelectionRow() {
<i>1933</i>&nbsp;        TreePath leadPath = getLeadSelectionPath();
<i>1934</i>&nbsp;
<i>1935</i>&nbsp;        if (leadPath != null) {
<i>1936</i>&nbsp;            return getRowForPath(leadPath);
<i>1937</i>&nbsp;        }
<i>1938</i>&nbsp;        return -1;
<i>1939</i>&nbsp;    }
<i>1940</i>&nbsp;
<i>1941</i>&nbsp;    /**
<i>1942</i>&nbsp;     * Returns true if the item identified by the path is currently selected.
<i>1943</i>&nbsp;     *
<i>1944</i>&nbsp;     * @param path a &lt;code&gt;TreePath&lt;/code&gt; identifying a node
<i>1945</i>&nbsp;     * @return true if the node is selected
<i>1946</i>&nbsp;     */
<i>1947</i>&nbsp;    public boolean isPathSelected(TreePath path) {
<i>1948</i>&nbsp;        return getSelectionModel().isPathSelected(path);
<i>1949</i>&nbsp;    }
<b class="nc"><i>1950</i>&nbsp;</b>
<b class="nc"><i>1951</i>&nbsp;    /**</b>
<i>1952</i>&nbsp;     * Returns true if the node identified by row is selected.
<b class="nc"><i>1953</i>&nbsp;     *</b>
<b class="nc"><i>1954</i>&nbsp;     * @param row  an integer specifying a display row, where 0 is the first</b>
<i>1955</i>&nbsp;     *             row in the display
<i>1956</i>&nbsp;     * @return true if the node is selected
<i>1957</i>&nbsp;     */
<b class="nc"><i>1958</i>&nbsp;    public boolean isRowSelected(int row) {</b>
<b class="nc"><i>1959</i>&nbsp;        return getSelectionModel().isRowSelected(row);</b>
<b class="nc"><i>1960</i>&nbsp;    }</b>
<b class="nc"><i>1961</i>&nbsp;</b>
<i>1962</i>&nbsp;    /**
<i>1963</i>&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the descendants of the
<i>1964</i>&nbsp;     * path &lt;code&gt;parent&lt;/code&gt; that
<b class="nc"><i>1965</i>&nbsp;     * are currently expanded. If &lt;code&gt;parent&lt;/code&gt; is not currently</b>
<b class="nc"><i>1966</i>&nbsp;     * expanded, this will return &lt;code&gt;null&lt;/code&gt;.</b>
<b class="nc"><i>1967</i>&nbsp;     * If you expand/collapse nodes while</b>
<b class="nc"><i>1968</i>&nbsp;     * iterating over the returned &lt;code&gt;Enumeration&lt;/code&gt;</b>
<b class="nc"><i>1969</i>&nbsp;     * this may not return all</b>
<i>1970</i>&nbsp;     * the expanded paths, or may return paths that are no longer expanded.
<b class="nc"><i>1971</i>&nbsp;     *</b>
<i>1972</i>&nbsp;     * @param parent  the path which is to be examined
<i>1973</i>&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the descendents of
<i>1974</i>&nbsp;     *          &lt;code&gt;parent&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if
<b class="nc"><i>1975</i>&nbsp;     *          &lt;code&gt;parent&lt;/code&gt; is not currently expanded</b>
<b class="nc"><i>1976</i>&nbsp;     */</b>
<b class="nc"><i>1977</i>&nbsp;    public Enumeration&lt;TreePath&gt; getExpandedDescendants(TreePath parent) {</b>
<i>1978</i>&nbsp;        if(!isExpanded(parent))
<b class="nc"><i>1979</i>&nbsp;            return null;</b>
<i>1980</i>&nbsp;
<i>1981</i>&nbsp;        Enumeration&lt;TreePath&gt; toggledPaths = expandedState.keys();
<i>1982</i>&nbsp;        Vector&lt;TreePath&gt; elements = null;
<i>1983</i>&nbsp;        TreePath          path;
<i>1984</i>&nbsp;        Object            value;
<i>1985</i>&nbsp;
<i>1986</i>&nbsp;        if(toggledPaths != null) {
<i>1987</i>&nbsp;            while(toggledPaths.hasMoreElements()) {
<b class="nc"><i>1988</i>&nbsp;                path = toggledPaths.nextElement();</b>
<i>1989</i>&nbsp;                value = expandedState.get(path);
<i>1990</i>&nbsp;                // Add the path if it is expanded, a descendant of parent,
<i>1991</i>&nbsp;                // and it is visible (all parents expanded). This is rather
<i>1992</i>&nbsp;                // expensive!
<i>1993</i>&nbsp;                if(path != parent &amp;&amp; value != null &amp;&amp;
<i>1994</i>&nbsp;                   ((Boolean)value).booleanValue() &amp;&amp;
<i>1995</i>&nbsp;                   parent.isDescendant(path) &amp;&amp; isVisible(path)) {
<i>1996</i>&nbsp;                    if (elements == null) {
<i>1997</i>&nbsp;                        elements = new Vector&lt;TreePath&gt;();
<i>1998</i>&nbsp;                    }
<i>1999</i>&nbsp;                    elements.addElement(path);
<b class="nc"><i>2000</i>&nbsp;                }</b>
<b class="nc"><i>2001</i>&nbsp;            }</b>
<i>2002</i>&nbsp;        }
<i>2003</i>&nbsp;        if (elements == null) {
<i>2004</i>&nbsp;            Set&lt;TreePath&gt; empty = Collections.emptySet();
<b class="nc"><i>2005</i>&nbsp;            return Collections.enumeration(empty);</b>
<b class="nc"><i>2006</i>&nbsp;        }</b>
<b class="nc"><i>2007</i>&nbsp;        return elements.elements();</b>
<b class="nc"><i>2008</i>&nbsp;    }</b>
<i>2009</i>&nbsp;
<b class="nc"><i>2010</i>&nbsp;    /**</b>
<i>2011</i>&nbsp;     * Returns true if the node identified by the path has ever been
<i>2012</i>&nbsp;     * expanded.
<i>2013</i>&nbsp;     *
<i>2014</i>&nbsp;     * @param path a {@code TreePath} identifying a node
<i>2015</i>&nbsp;     * @return true if the &lt;code&gt;path&lt;/code&gt; has ever been expanded
<i>2016</i>&nbsp;     */
<i>2017</i>&nbsp;    public boolean hasBeenExpanded(TreePath path) {
<i>2018</i>&nbsp;        return (path != null &amp;&amp; expandedState.get(path) != null);
<i>2019</i>&nbsp;    }
<i>2020</i>&nbsp;
<i>2021</i>&nbsp;    /**
<b class="nc"><i>2022</i>&nbsp;     * Returns true if the node identified by the path is currently expanded,</b>
<i>2023</i>&nbsp;     *
<b class="nc"><i>2024</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; specifying the node to check</b>
<b class="nc"><i>2025</i>&nbsp;     * @return false if any of the nodes in the node&#39;s path are collapsed,</b>
<i>2026</i>&nbsp;     *               true if all nodes in the path are expanded
<b class="nc"><i>2027</i>&nbsp;     */</b>
<b class="nc"><i>2028</i>&nbsp;    public boolean isExpanded(TreePath path) {</b>
<i>2029</i>&nbsp;
<b class="nc"><i>2030</i>&nbsp;        if(path == null)</b>
<i>2031</i>&nbsp;            return false;
<i>2032</i>&nbsp;        Object  value;
<b class="nc"><i>2033</i>&nbsp;</b>
<i>2034</i>&nbsp;        do{
<i>2035</i>&nbsp;            value = expandedState.get(path);
<i>2036</i>&nbsp;            if(value == null || !((Boolean)value).booleanValue())
<i>2037</i>&nbsp;                return false;
<i>2038</i>&nbsp;        } while( (path=path.getParentPath())!=null );
<i>2039</i>&nbsp;
<i>2040</i>&nbsp;        return true;
<i>2041</i>&nbsp;    }
<i>2042</i>&nbsp;
<i>2043</i>&nbsp;    /**
<i>2044</i>&nbsp;     * Returns true if the node at the specified display row is currently
<i>2045</i>&nbsp;     * expanded.
<b class="nc"><i>2046</i>&nbsp;     *</b>
<i>2047</i>&nbsp;     * @param row  the row to check, where 0 is the first row in the
<i>2048</i>&nbsp;     *             display
<i>2049</i>&nbsp;     * @return true if the node is currently expanded, otherwise false
<i>2050</i>&nbsp;     */
<i>2051</i>&nbsp;    public boolean isExpanded(int row) {
<i>2052</i>&nbsp;        TreeUI                  tree = getUI();
<i>2053</i>&nbsp;
<i>2054</i>&nbsp;        if(tree != null) {
<i>2055</i>&nbsp;            TreePath         path = tree.getPathForRow(this, row);
<i>2056</i>&nbsp;
<b class="nc"><i>2057</i>&nbsp;            if(path != null) {</b>
<i>2058</i>&nbsp;                Boolean value = expandedState.get(path);
<i>2059</i>&nbsp;
<i>2060</i>&nbsp;                return (value != null &amp;&amp; value.booleanValue());
<i>2061</i>&nbsp;            }
<i>2062</i>&nbsp;        }
<i>2063</i>&nbsp;        return false;
<i>2064</i>&nbsp;    }
<i>2065</i>&nbsp;
<b class="nc"><i>2066</i>&nbsp;    /**</b>
<b class="nc"><i>2067</i>&nbsp;     * Returns true if the value identified by path is currently collapsed,</b>
<i>2068</i>&nbsp;     * this will return false if any of the values in path are currently
<b class="nc"><i>2069</i>&nbsp;     * not being displayed.</b>
<b class="nc"><i>2070</i>&nbsp;     *</b>
<i>2071</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; to check
<i>2072</i>&nbsp;     * @return true if any of the nodes in the node&#39;s path are collapsed,
<i>2073</i>&nbsp;     *               false if all nodes in the path are expanded
<i>2074</i>&nbsp;     */
<i>2075</i>&nbsp;    public boolean isCollapsed(TreePath path) {
<i>2076</i>&nbsp;        return !isExpanded(path);
<i>2077</i>&nbsp;    }
<i>2078</i>&nbsp;
<i>2079</i>&nbsp;    /**
<i>2080</i>&nbsp;     * Returns true if the node at the specified display row is collapsed.
<i>2081</i>&nbsp;     *
<i>2082</i>&nbsp;     * @param row  the row to check, where 0 is the first row in the
<b class="nc"><i>2083</i>&nbsp;     *             display</b>
<b class="nc"><i>2084</i>&nbsp;     * @return true if the node is currently collapsed, otherwise false</b>
<i>2085</i>&nbsp;     */
<b class="nc"><i>2086</i>&nbsp;    public boolean isCollapsed(int row) {</b>
<b class="nc"><i>2087</i>&nbsp;        return !isExpanded(row);</b>
<i>2088</i>&nbsp;    }
<b class="nc"><i>2089</i>&nbsp;</b>
<i>2090</i>&nbsp;    /**
<b class="nc"><i>2091</i>&nbsp;     * Ensures that the node identified by path is currently viewable.</b>
<i>2092</i>&nbsp;     *
<i>2093</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; to make visible
<i>2094</i>&nbsp;     */
<i>2095</i>&nbsp;    public void makeVisible(TreePath path) {
<i>2096</i>&nbsp;        if(path != null) {
<i>2097</i>&nbsp;            TreePath        parentPath = path.getParentPath();
<i>2098</i>&nbsp;
<i>2099</i>&nbsp;            if(parentPath != null) {
<i>2100</i>&nbsp;                expandPath(parentPath);
<i>2101</i>&nbsp;            }
<i>2102</i>&nbsp;        }
<i>2103</i>&nbsp;    }
<i>2104</i>&nbsp;
<i>2105</i>&nbsp;    /**
<i>2106</i>&nbsp;     * Returns true if the value identified by path is currently viewable,
<i>2107</i>&nbsp;     * which means it is either the root or all of its parents are expanded.
<b class="nc"><i>2108</i>&nbsp;     * Otherwise, this method returns false.</b>
<i>2109</i>&nbsp;     *
<b class="nc"><i>2110</i>&nbsp;     * @param path {@code TreePath} identifying a node</b>
<b class="nc"><i>2111</i>&nbsp;     * @return true if the node is viewable, otherwise false</b>
<b class="nc"><i>2112</i>&nbsp;     */</b>
<i>2113</i>&nbsp;    public boolean isVisible(TreePath path) {
<i>2114</i>&nbsp;        if(path != null) {
<i>2115</i>&nbsp;            TreePath        parentPath = path.getParentPath();
<i>2116</i>&nbsp;
<i>2117</i>&nbsp;            if(parentPath != null)
<i>2118</i>&nbsp;                return isExpanded(parentPath);
<i>2119</i>&nbsp;            // Root.
<i>2120</i>&nbsp;            return true;
<i>2121</i>&nbsp;        }
<i>2122</i>&nbsp;        return false;
<i>2123</i>&nbsp;    }
<b class="nc"><i>2124</i>&nbsp;</b>
<i>2125</i>&nbsp;    /**
<i>2126</i>&nbsp;     * Returns the &lt;code&gt;Rectangle&lt;/code&gt; that the specified node will be drawn
<i>2127</i>&nbsp;     * into. Returns &lt;code&gt;null&lt;/code&gt; if any component in the path is hidden
<i>2128</i>&nbsp;     * (under a collapsed parent).
<i>2129</i>&nbsp;     * &lt;p&gt;
<i>2130</i>&nbsp;     * Note:&lt;br&gt;
<i>2131</i>&nbsp;     * This method returns a valid rectangle, even if the specified
<i>2132</i>&nbsp;     * node is not currently displayed.
<i>2133</i>&nbsp;     *
<i>2134</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; identifying the node
<i>2135</i>&nbsp;     * @return the &lt;code&gt;Rectangle&lt;/code&gt; the node is drawn in,
<i>2136</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>2137</i>&nbsp;     */</b>
<b class="nc"><i>2138</i>&nbsp;    public Rectangle getPathBounds(TreePath path) {</b>
<i>2139</i>&nbsp;        TreeUI                   tree = getUI();
<b class="nc"><i>2140</i>&nbsp;</b>
<i>2141</i>&nbsp;        if(tree != null)
<b class="nc"><i>2142</i>&nbsp;            return tree.getPathBounds(this, path);</b>
<b class="nc"><i>2143</i>&nbsp;        return null;</b>
<b class="nc"><i>2144</i>&nbsp;    }</b>
<b class="nc"><i>2145</i>&nbsp;</b>
<i>2146</i>&nbsp;    /**
<i>2147</i>&nbsp;     * Returns the &lt;code&gt;Rectangle&lt;/code&gt; that the node at the specified row is
<i>2148</i>&nbsp;     * drawn in.
<i>2149</i>&nbsp;     *
<i>2150</i>&nbsp;     * @param row  the row to be drawn, where 0 is the first row in the
<i>2151</i>&nbsp;     *             display
<i>2152</i>&nbsp;     * @return the &lt;code&gt;Rectangle&lt;/code&gt; the node is drawn in
<i>2153</i>&nbsp;     */
<i>2154</i>&nbsp;    public Rectangle getRowBounds(int row) {
<i>2155</i>&nbsp;        return getPathBounds(getPathForRow(row));
<i>2156</i>&nbsp;    }
<i>2157</i>&nbsp;
<i>2158</i>&nbsp;    /**
<i>2159</i>&nbsp;     * Makes sure all the path components in path are expanded (except
<i>2160</i>&nbsp;     * for the last path component) and scrolls so that the
<b class="nc"><i>2161</i>&nbsp;     * node identified by the path is displayed. Only works when this</b>
<i>2162</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt; is contained in a &lt;code&gt;JScrollPane&lt;/code&gt;.
<i>2163</i>&nbsp;     *
<i>2164</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying the node to
<i>2165</i>&nbsp;     *          bring into view
<i>2166</i>&nbsp;     */
<i>2167</i>&nbsp;    public void scrollPathToVisible(TreePath path) {
<i>2168</i>&nbsp;        if(path != null) {
<i>2169</i>&nbsp;            makeVisible(path);
<i>2170</i>&nbsp;
<i>2171</i>&nbsp;            Rectangle          bounds = getPathBounds(path);
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;            if(bounds != null) {
<i>2174</i>&nbsp;                scrollRectToVisible(bounds);
<b class="nc"><i>2175</i>&nbsp;                if (accessibleContext != null) {</b>
<i>2176</i>&nbsp;                    ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();
<b class="nc"><i>2177</i>&nbsp;                }</b>
<b class="nc"><i>2178</i>&nbsp;            }</b>
<b class="nc"><i>2179</i>&nbsp;        }</b>
<i>2180</i>&nbsp;    }
<i>2181</i>&nbsp;
<i>2182</i>&nbsp;    /**
<i>2183</i>&nbsp;     * Scrolls the item identified by row until it is displayed. The minimum
<i>2184</i>&nbsp;     * of amount of scrolling necessary to bring the row into view
<i>2185</i>&nbsp;     * is performed. Only works when this &lt;code&gt;JTree&lt;/code&gt; is contained in a
<i>2186</i>&nbsp;     * &lt;code&gt;JScrollPane&lt;/code&gt;.
<i>2187</i>&nbsp;     *
<i>2188</i>&nbsp;     * @param row  an integer specifying the row to scroll, where 0 is the
<i>2189</i>&nbsp;     *             first row in the display
<i>2190</i>&nbsp;     */
<i>2191</i>&nbsp;    public void scrollRowToVisible(int row) {
<b class="nc"><i>2192</i>&nbsp;        scrollPathToVisible(getPathForRow(row));</b>
<i>2193</i>&nbsp;    }
<b class="nc"><i>2194</i>&nbsp;</b>
<b class="nc"><i>2195</i>&nbsp;    /**</b>
<b class="nc"><i>2196</i>&nbsp;     * Returns the path for the specified row.  If &lt;code&gt;row&lt;/code&gt; is</b>
<i>2197</i>&nbsp;     * not visible, or a {@code TreeUI} has not been set, &lt;code&gt;null&lt;/code&gt;
<i>2198</i>&nbsp;     * is returned.
<i>2199</i>&nbsp;     *
<i>2200</i>&nbsp;     * @param row  an integer specifying a row
<i>2201</i>&nbsp;     * @return the &lt;code&gt;TreePath&lt;/code&gt; to the specified node,
<i>2202</i>&nbsp;     *          &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;row &amp;lt; 0&lt;/code&gt;
<i>2203</i>&nbsp;     *          or &lt;code&gt;row &amp;gt;= getRowCount()&lt;/code&gt;
<i>2204</i>&nbsp;     */
<i>2205</i>&nbsp;    @BeanProperty(bound = false)
<i>2206</i>&nbsp;    public TreePath getPathForRow(int row) {
<i>2207</i>&nbsp;        TreeUI                  tree = getUI();
<b class="nc"><i>2208</i>&nbsp;</b>
<i>2209</i>&nbsp;        if(tree != null)
<b class="nc"><i>2210</i>&nbsp;            return tree.getPathForRow(this, row);</b>
<b class="nc"><i>2211</i>&nbsp;        return null;</b>
<b class="nc"><i>2212</i>&nbsp;    }</b>
<i>2213</i>&nbsp;
<i>2214</i>&nbsp;    /**
<i>2215</i>&nbsp;     * Returns the row that displays the node identified by the specified
<i>2216</i>&nbsp;     * path.
<i>2217</i>&nbsp;     *
<i>2218</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
<i>2219</i>&nbsp;     * @return an integer specifying the display row, where 0 is the first
<i>2220</i>&nbsp;     *         row in the display, or -1 if any of the elements in path
<i>2221</i>&nbsp;     *         are hidden under a collapsed parent.
<i>2222</i>&nbsp;     */
<i>2223</i>&nbsp;    public int getRowForPath(TreePath path) {
<i>2224</i>&nbsp;        TreeUI                  tree = getUI();
<i>2225</i>&nbsp;
<i>2226</i>&nbsp;        if(tree != null)
<b class="nc"><i>2227</i>&nbsp;            return tree.getRowForPath(this, path);</b>
<i>2228</i>&nbsp;        return -1;
<i>2229</i>&nbsp;    }
<i>2230</i>&nbsp;
<i>2231</i>&nbsp;    /**
<i>2232</i>&nbsp;     * Ensures that the node identified by the specified path is
<i>2233</i>&nbsp;     * expanded and viewable. If the last item in the path is a
<i>2234</i>&nbsp;     * leaf, this will have no effect.
<i>2235</i>&nbsp;     *
<i>2236</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
<b class="nc"><i>2237</i>&nbsp;     */</b>
<i>2238</i>&nbsp;    public void expandPath(TreePath path) {
<i>2239</i>&nbsp;        // Only expand if not leaf!
<i>2240</i>&nbsp;        TreeModel          model = getModel();
<i>2241</i>&nbsp;
<i>2242</i>&nbsp;        if(path != null &amp;&amp; model != null &amp;&amp;
<i>2243</i>&nbsp;           !model.isLeaf(path.getLastPathComponent())) {
<i>2244</i>&nbsp;            setExpandedState(path, true);
<i>2245</i>&nbsp;        }
<i>2246</i>&nbsp;    }
<i>2247</i>&nbsp;
<i>2248</i>&nbsp;    /**
<i>2249</i>&nbsp;     * Ensures that the node in the specified row is expanded and
<b class="nc"><i>2250</i>&nbsp;     * viewable.</b>
<i>2251</i>&nbsp;     * &lt;p&gt;
<i>2252</i>&nbsp;     * If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this
<i>2253</i>&nbsp;     * will have no effect.
<i>2254</i>&nbsp;     *
<i>2255</i>&nbsp;     * @param row  an integer specifying a display row, where 0 is the
<i>2256</i>&nbsp;     *             first row in the display
<i>2257</i>&nbsp;     */
<i>2258</i>&nbsp;    public void expandRow(int row) {
<i>2259</i>&nbsp;        expandPath(getPathForRow(row));
<i>2260</i>&nbsp;    }
<i>2261</i>&nbsp;
<i>2262</i>&nbsp;    /**
<b class="nc"><i>2263</i>&nbsp;     * Ensures that the node identified by the specified path is</b>
<i>2264</i>&nbsp;     * collapsed and viewable.
<b class="nc"><i>2265</i>&nbsp;     *</b>
<b class="nc"><i>2266</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node</b>
<i>2267</i>&nbsp;      */
<b class="nc"><i>2268</i>&nbsp;    public void collapsePath(TreePath path) {</b>
<i>2269</i>&nbsp;        setExpandedState(path, false);
<i>2270</i>&nbsp;    }
<b class="nc"><i>2271</i>&nbsp;</b>
<i>2272</i>&nbsp;    /**
<b class="nc"><i>2273</i>&nbsp;     * Ensures that the node in the specified row is collapsed.</b>
<i>2274</i>&nbsp;     * &lt;p&gt;
<i>2275</i>&nbsp;     * If &lt;code&gt;row&lt;/code&gt; is &amp;lt; 0 or &amp;gt;= &lt;code&gt;getRowCount&lt;/code&gt; this
<i>2276</i>&nbsp;     * will have no effect.
<i>2277</i>&nbsp;     *
<i>2278</i>&nbsp;     * @param row  an integer specifying a display row, where 0 is the
<i>2279</i>&nbsp;     *             first row in the display
<i>2280</i>&nbsp;      */
<i>2281</i>&nbsp;    public void collapseRow(int row) {
<i>2282</i>&nbsp;        collapsePath(getPathForRow(row));
<i>2283</i>&nbsp;    }
<i>2284</i>&nbsp;
<i>2285</i>&nbsp;    /**
<i>2286</i>&nbsp;     * Returns the path for the node at the specified location.
<i>2287</i>&nbsp;     *
<b class="nc"><i>2288</i>&nbsp;     * @param x an integer giving the number of pixels horizontally from</b>
<i>2289</i>&nbsp;     *          the left edge of the display area, minus any left margin
<i>2290</i>&nbsp;     * @param y an integer giving the number of pixels vertically from
<i>2291</i>&nbsp;     *          the top of the display area, minus any top margin
<i>2292</i>&nbsp;     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node at that location
<i>2293</i>&nbsp;     */
<i>2294</i>&nbsp;    public TreePath getPathForLocation(int x, int y) {
<i>2295</i>&nbsp;        TreePath          closestPath = getClosestPathForLocation(x, y);
<i>2296</i>&nbsp;
<i>2297</i>&nbsp;        if(closestPath != null) {
<i>2298</i>&nbsp;            Rectangle       pathBounds = getPathBounds(closestPath);
<i>2299</i>&nbsp;
<i>2300</i>&nbsp;            if(pathBounds != null &amp;&amp;
<i>2301</i>&nbsp;               x &gt;= pathBounds.x &amp;&amp; x &lt; (pathBounds.x + pathBounds.width) &amp;&amp;
<i>2302</i>&nbsp;               y &gt;= pathBounds.y &amp;&amp; y &lt; (pathBounds.y + pathBounds.height))
<i>2303</i>&nbsp;                return closestPath;
<i>2304</i>&nbsp;        }
<i>2305</i>&nbsp;        return null;
<i>2306</i>&nbsp;    }
<i>2307</i>&nbsp;
<i>2308</i>&nbsp;    /**
<b class="nc"><i>2309</i>&nbsp;     * Returns the row for the specified location.</b>
<i>2310</i>&nbsp;     *
<b class="nc"><i>2311</i>&nbsp;     * @param x an integer giving the number of pixels horizontally from</b>
<b class="nc"><i>2312</i>&nbsp;     *          the left edge of the display area, minus any left margin</b>
<b class="nc"><i>2313</i>&nbsp;     * @param y an integer giving the number of pixels vertically from</b>
<i>2314</i>&nbsp;     *          the top of the display area, minus any top margin
<i>2315</i>&nbsp;     * @return the row corresponding to the location, or -1 if the
<i>2316</i>&nbsp;     *         location is not within the bounds of a displayed cell
<i>2317</i>&nbsp;     * @see #getClosestRowForLocation
<i>2318</i>&nbsp;     */
<i>2319</i>&nbsp;    public int getRowForLocation(int x, int y) {
<i>2320</i>&nbsp;        return getRowForPath(getPathForLocation(x, y));
<i>2321</i>&nbsp;    }
<i>2322</i>&nbsp;
<i>2323</i>&nbsp;    /**
<i>2324</i>&nbsp;     * Returns the path to the node that is closest to x,y.  If
<i>2325</i>&nbsp;     * no nodes are currently viewable, or there is no model, returns
<i>2326</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt;, otherwise it always returns a valid path.  To test if
<i>2327</i>&nbsp;     * the node is exactly at x, y, get the node&#39;s bounds and
<i>2328</i>&nbsp;     * test x, y against that.
<i>2329</i>&nbsp;     *
<i>2330</i>&nbsp;     * @param x an integer giving the number of pixels horizontally from
<i>2331</i>&nbsp;     *          the left edge of the display area, minus any left margin
<i>2332</i>&nbsp;     * @param y an integer giving the number of pixels vertically from
<i>2333</i>&nbsp;     *          the top of the display area, minus any top margin
<b class="nc"><i>2334</i>&nbsp;     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node closest to that location,</b>
<i>2335</i>&nbsp;     *          &lt;code&gt;null&lt;/code&gt; if nothing is viewable or there is no model
<i>2336</i>&nbsp;     *
<i>2337</i>&nbsp;     * @see #getPathForLocation
<i>2338</i>&nbsp;     * @see #getPathBounds
<i>2339</i>&nbsp;     */
<i>2340</i>&nbsp;    public TreePath getClosestPathForLocation(int x, int y) {
<i>2341</i>&nbsp;        TreeUI                  tree = getUI();
<i>2342</i>&nbsp;
<i>2343</i>&nbsp;        if(tree != null)
<i>2344</i>&nbsp;            return tree.getClosestPathForLocation(this, x, y);
<b class="nc"><i>2345</i>&nbsp;        return null;</b>
<i>2346</i>&nbsp;    }
<b class="nc"><i>2347</i>&nbsp;</b>
<b class="nc"><i>2348</i>&nbsp;    /**</b>
<b class="nc"><i>2349</i>&nbsp;     * Returns the row to the node that is closest to x,y.  If no nodes</b>
<i>2350</i>&nbsp;     * are viewable or there is no model, returns -1. Otherwise,
<i>2351</i>&nbsp;     * it always returns a valid row.  To test if the returned object is
<i>2352</i>&nbsp;     * exactly at x, y, get the bounds for the node at the returned
<i>2353</i>&nbsp;     * row and test x, y against that.
<i>2354</i>&nbsp;     *
<i>2355</i>&nbsp;     * @param x an integer giving the number of pixels horizontally from
<i>2356</i>&nbsp;     *          the left edge of the display area, minus any left margin
<i>2357</i>&nbsp;     * @param y an integer giving the number of pixels vertically from
<i>2358</i>&nbsp;     *          the top of the display area, minus any top margin
<i>2359</i>&nbsp;     * @return the row closest to the location, -1 if nothing is
<i>2360</i>&nbsp;     *         viewable or there is no model
<i>2361</i>&nbsp;     *
<i>2362</i>&nbsp;     * @see #getRowForLocation
<i>2363</i>&nbsp;     * @see #getRowBounds
<i>2364</i>&nbsp;     */
<i>2365</i>&nbsp;    public int getClosestRowForLocation(int x, int y) {
<i>2366</i>&nbsp;        return getRowForPath(getClosestPathForLocation(x, y));
<i>2367</i>&nbsp;    }
<b class="nc"><i>2368</i>&nbsp;</b>
<i>2369</i>&nbsp;    /**
<b class="nc"><i>2370</i>&nbsp;     * Returns true if the tree is being edited. The item that is being</b>
<b class="nc"><i>2371</i>&nbsp;     * edited can be obtained using &lt;code&gt;getSelectionPath&lt;/code&gt;.</b>
<b class="nc"><i>2372</i>&nbsp;     *</b>
<i>2373</i>&nbsp;     * @return true if the user is currently editing a node
<i>2374</i>&nbsp;     * @see #getSelectionPath
<i>2375</i>&nbsp;     */
<i>2376</i>&nbsp;    @BeanProperty(bound = false)
<i>2377</i>&nbsp;    public boolean isEditing() {
<i>2378</i>&nbsp;        TreeUI                  tree = getUI();
<i>2379</i>&nbsp;
<b class="nc"><i>2380</i>&nbsp;        if(tree != null)</b>
<i>2381</i>&nbsp;            return tree.isEditing(this);
<b class="nc"><i>2382</i>&nbsp;        return false;</b>
<b class="nc"><i>2383</i>&nbsp;    }</b>
<i>2384</i>&nbsp;
<i>2385</i>&nbsp;    /**
<i>2386</i>&nbsp;     * Ends the current editing session.
<i>2387</i>&nbsp;     * (The &lt;code&gt;DefaultTreeCellEditor&lt;/code&gt;
<i>2388</i>&nbsp;     * object saves any edits that are currently in progress on a cell.
<i>2389</i>&nbsp;     * Other implementations may operate differently.)
<i>2390</i>&nbsp;     * Has no effect if the tree isn&#39;t being edited.
<i>2391</i>&nbsp;     * &lt;blockquote&gt;
<i>2392</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt;&lt;br&gt;
<i>2393</i>&nbsp;     * To make edit-saves automatic whenever the user changes
<i>2394</i>&nbsp;     * their position in the tree, use {@link #setInvokesStopCellEditing}.
<b class="nc"><i>2395</i>&nbsp;     * &lt;/blockquote&gt;</b>
<i>2396</i>&nbsp;     *
<b class="nc"><i>2397</i>&nbsp;     * @return true if editing was in progress and is now stopped,</b>
<b class="nc"><i>2398</i>&nbsp;     *              false if editing was not in progress</b>
<i>2399</i>&nbsp;     */
<i>2400</i>&nbsp;    public boolean stopEditing() {
<i>2401</i>&nbsp;        TreeUI                  tree = getUI();
<i>2402</i>&nbsp;
<i>2403</i>&nbsp;        if(tree != null)
<i>2404</i>&nbsp;            return tree.stopEditing(this);
<i>2405</i>&nbsp;        return false;
<i>2406</i>&nbsp;    }
<b class="nc"><i>2407</i>&nbsp;</b>
<i>2408</i>&nbsp;    /**
<b class="nc"><i>2409</i>&nbsp;     * Cancels the current editing session. Has no effect if the</b>
<b class="nc"><i>2410</i>&nbsp;     * tree isn&#39;t being edited.</b>
<b class="nc"><i>2411</i>&nbsp;     */</b>
<i>2412</i>&nbsp;    public void  cancelEditing() {
<i>2413</i>&nbsp;        TreeUI                  tree = getUI();
<i>2414</i>&nbsp;
<i>2415</i>&nbsp;        if(tree != null)
<i>2416</i>&nbsp;            tree.cancelEditing(this);
<i>2417</i>&nbsp;    }
<i>2418</i>&nbsp;
<i>2419</i>&nbsp;    /**
<i>2420</i>&nbsp;     * Selects the node identified by the specified path and initiates
<i>2421</i>&nbsp;     * editing.  The edit-attempt fails if the &lt;code&gt;CellEditor&lt;/code&gt;
<i>2422</i>&nbsp;     * does not allow
<i>2423</i>&nbsp;     * editing for the specified item.
<i>2424</i>&nbsp;     *
<i>2425</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
<i>2426</i>&nbsp;     */
<i>2427</i>&nbsp;    public void startEditingAtPath(TreePath path) {
<i>2428</i>&nbsp;        TreeUI                  tree = getUI();
<i>2429</i>&nbsp;
<i>2430</i>&nbsp;        if(tree != null)
<i>2431</i>&nbsp;            tree.startEditingAtPath(this, path);
<i>2432</i>&nbsp;    }
<i>2433</i>&nbsp;
<i>2434</i>&nbsp;    /**
<i>2435</i>&nbsp;     * Returns the path to the element that is currently being edited.
<i>2436</i>&nbsp;     *
<i>2437</i>&nbsp;     * @return  the &lt;code&gt;TreePath&lt;/code&gt; for the node being edited
<b class="nc"><i>2438</i>&nbsp;     */</b>
<b class="nc"><i>2439</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>2440</i>&nbsp;    public TreePath getEditingPath() {
<b class="nc"><i>2441</i>&nbsp;        TreeUI                  tree = getUI();</b>
<i>2442</i>&nbsp;
<b class="nc"><i>2443</i>&nbsp;        if(tree != null)</b>
<b class="nc"><i>2444</i>&nbsp;            return tree.getEditingPath(this);</b>
<b class="nc"><i>2445</i>&nbsp;        return null;</b>
<i>2446</i>&nbsp;    }
<b class="nc"><i>2447</i>&nbsp;</b>
<b class="nc"><i>2448</i>&nbsp;    //</b>
<b class="nc"><i>2449</i>&nbsp;    // Following are primarily convenience methods for mapping from</b>
<i>2450</i>&nbsp;    // row based selections to path selections.  Sometimes it is
<i>2451</i>&nbsp;    // easier to deal with these than paths (mouse downs, key downs
<b class="nc"><i>2452</i>&nbsp;    // usually just deal with index based selections).</b>
<b class="nc"><i>2453</i>&nbsp;    // Since row based selections require a UI many of these won&#39;t work</b>
<b class="nc"><i>2454</i>&nbsp;    // without one.</b>
<i>2455</i>&nbsp;    //
<b class="nc"><i>2456</i>&nbsp;</b>
<i>2457</i>&nbsp;    /**
<i>2458</i>&nbsp;     * Sets the tree&#39;s selection model. When a &lt;code&gt;null&lt;/code&gt; value is
<b class="nc"><i>2459</i>&nbsp;     * specified an empty</b>
<b class="nc"><i>2460</i>&nbsp;     * &lt;code&gt;selectionModel&lt;/code&gt; is used, which does not allow selections.</b>
<i>2461</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2462</i>&nbsp;     * This is a bound property.</b>
<i>2463</i>&nbsp;     *
<i>2464</i>&nbsp;     * @param selectionModel the &lt;code&gt;TreeSelectionModel&lt;/code&gt; to use,
<i>2465</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; to disable selections
<i>2466</i>&nbsp;     * @see TreeSelectionModel
<i>2467</i>&nbsp;     */
<i>2468</i>&nbsp;    @BeanProperty(description
<i>2469</i>&nbsp;            = &quot;The tree&#39;s selection model.&quot;)
<i>2470</i>&nbsp;    public void setSelectionModel(TreeSelectionModel selectionModel) {
<i>2471</i>&nbsp;        if(selectionModel == null)
<i>2472</i>&nbsp;            selectionModel = EmptySelectionModel.sharedInstance();
<i>2473</i>&nbsp;
<i>2474</i>&nbsp;        TreeSelectionModel         oldValue = this.selectionModel;
<i>2475</i>&nbsp;
<b class="nc"><i>2476</i>&nbsp;        if (this.selectionModel != null &amp;&amp; selectionRedirector != null) {</b>
<i>2477</i>&nbsp;            this.selectionModel.removeTreeSelectionListener
<i>2478</i>&nbsp;                                (selectionRedirector);
<i>2479</i>&nbsp;        }
<i>2480</i>&nbsp;        if (accessibleContext != null) {
<i>2481</i>&nbsp;           this.selectionModel.removeTreeSelectionListener((TreeSelectionListener)accessibleContext);
<i>2482</i>&nbsp;           selectionModel.addTreeSelectionListener((TreeSelectionListener)accessibleContext);
<i>2483</i>&nbsp;        }
<i>2484</i>&nbsp;
<i>2485</i>&nbsp;        this.selectionModel = selectionModel;
<i>2486</i>&nbsp;        if (selectionRedirector != null) {
<i>2487</i>&nbsp;            this.selectionModel.addTreeSelectionListener(selectionRedirector);
<i>2488</i>&nbsp;        }
<i>2489</i>&nbsp;        firePropertyChange(SELECTION_MODEL_PROPERTY, oldValue,
<i>2490</i>&nbsp;                           this.selectionModel);
<i>2491</i>&nbsp;
<i>2492</i>&nbsp;        if (accessibleContext != null) {
<i>2493</i>&nbsp;            accessibleContext.firePropertyChange(
<i>2494</i>&nbsp;                    AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
<i>2495</i>&nbsp;                    Boolean.valueOf(false), Boolean.valueOf(true));
<i>2496</i>&nbsp;        }
<i>2497</i>&nbsp;    }
<i>2498</i>&nbsp;
<i>2499</i>&nbsp;    /**
<i>2500</i>&nbsp;     * Returns the model for selections. This should always return a
<i>2501</i>&nbsp;     * non-&lt;code&gt;null&lt;/code&gt; value. If you don&#39;t want to allow anything
<i>2502</i>&nbsp;     * to be selected
<i>2503</i>&nbsp;     * set the selection model to &lt;code&gt;null&lt;/code&gt;, which forces an empty
<i>2504</i>&nbsp;     * selection model to be used.
<i>2505</i>&nbsp;     *
<b class="nc"><i>2506</i>&nbsp;     * @return the model for selections</b>
<b class="nc"><i>2507</i>&nbsp;     * @see #setSelectionModel</b>
<b class="nc"><i>2508</i>&nbsp;     */</b>
<b class="nc"><i>2509</i>&nbsp;    public TreeSelectionModel getSelectionModel() {</b>
<i>2510</i>&nbsp;        return selectionModel;
<b class="nc"><i>2511</i>&nbsp;    }</b>
<b class="nc"><i>2512</i>&nbsp;</b>
<b class="nc"><i>2513</i>&nbsp;    /**</b>
<b class="nc"><i>2514</i>&nbsp;     * Returns the paths (inclusive) between the specified rows. If</b>
<b class="nc"><i>2515</i>&nbsp;     * the specified indices are within the viewable set of rows, or</b>
<i>2516</i>&nbsp;     * bound the viewable set of rows, then the indices are
<b class="nc"><i>2517</i>&nbsp;     * constrained by the viewable set of rows. If the specified</b>
<b class="nc"><i>2518</i>&nbsp;     * indices are not within the viewable set of rows, or do not</b>
<b class="nc"><i>2519</i>&nbsp;     * bound the viewable set of rows, then an empty array is</b>
<i>2520</i>&nbsp;     * returned. For example, if the row count is {@code 10}, and this
<b class="nc"><i>2521</i>&nbsp;     * method is invoked with {@code -1, 20}, then the specified</b>
<i>2522</i>&nbsp;     * indices are constrained to the viewable set of rows, and this is
<i>2523</i>&nbsp;     * treated as if invoked with {@code 0, 9}. On the other hand, if
<b class="nc"><i>2524</i>&nbsp;     * this were invoked with {@code -10, -1}, then the specified</b>
<i>2525</i>&nbsp;     * indices do not bound the viewable set of rows, and an empty
<i>2526</i>&nbsp;     * array is returned.
<i>2527</i>&nbsp;     * &lt;p&gt;
<i>2528</i>&nbsp;     * The parameters are not order dependent. That is, {@code
<i>2529</i>&nbsp;     * getPathBetweenRows(x, y)} is equivalent to
<i>2530</i>&nbsp;     * {@code getPathBetweenRows(y, x)}.
<i>2531</i>&nbsp;     * &lt;p&gt;
<i>2532</i>&nbsp;     * An empty array is returned if the row count is {@code 0}, or
<i>2533</i>&nbsp;     * the specified indices do not bound the viewable set of rows.
<i>2534</i>&nbsp;     *
<i>2535</i>&nbsp;     * @param index0 the first index in the range
<i>2536</i>&nbsp;     * @param index1 the last index in the range
<i>2537</i>&nbsp;     * @return the paths (inclusive) between the specified row indices
<i>2538</i>&nbsp;     */
<i>2539</i>&nbsp;    protected TreePath[] getPathBetweenRows(int index0, int index1) {
<i>2540</i>&nbsp;        TreeUI           tree = getUI();
<i>2541</i>&nbsp;        if (tree != null) {
<i>2542</i>&nbsp;            int rowCount = getRowCount();
<i>2543</i>&nbsp;            if (rowCount &gt; 0 &amp;&amp; !((index0 &lt; 0 &amp;&amp; index1 &lt; 0) ||
<i>2544</i>&nbsp;                                  (index0 &gt;= rowCount &amp;&amp; index1 &gt;= rowCount))){
<i>2545</i>&nbsp;                index0 = Math.min(rowCount - 1, Math.max(index0, 0));
<i>2546</i>&nbsp;                index1 = Math.min(rowCount - 1, Math.max(index1, 0));
<i>2547</i>&nbsp;                int minIndex = Math.min(index0, index1);
<b class="nc"><i>2548</i>&nbsp;                int maxIndex = Math.max(index0, index1);</b>
<i>2549</i>&nbsp;                TreePath[] selection = new TreePath[
<b class="nc"><i>2550</i>&nbsp;                        maxIndex - minIndex + 1];</b>
<i>2551</i>&nbsp;                for(int counter = minIndex; counter &lt;= maxIndex; counter++) {
<i>2552</i>&nbsp;                    selection[counter - minIndex] =
<i>2553</i>&nbsp;                            tree.getPathForRow(this, counter);
<i>2554</i>&nbsp;                }
<i>2555</i>&nbsp;                return selection;
<i>2556</i>&nbsp;            }
<i>2557</i>&nbsp;        }
<i>2558</i>&nbsp;        return new TreePath[0];
<i>2559</i>&nbsp;    }
<i>2560</i>&nbsp;
<i>2561</i>&nbsp;    /**
<i>2562</i>&nbsp;     * Selects the rows in the specified interval (inclusive). If
<i>2563</i>&nbsp;     * the specified indices are within the viewable set of rows, or bound
<i>2564</i>&nbsp;     * the viewable set of rows, then the specified rows are constrained by
<i>2565</i>&nbsp;     * the viewable set of rows. If the specified indices are not within the
<i>2566</i>&nbsp;     * viewable set of rows, or do not bound the viewable set of rows, then
<i>2567</i>&nbsp;     * the selection is cleared. For example, if the row count is {@code
<i>2568</i>&nbsp;     * 10}, and this method is invoked with {@code -1, 20}, then the
<i>2569</i>&nbsp;     * specified indices bounds the viewable range, and this is treated as
<i>2570</i>&nbsp;     * if invoked with {@code 0, 9}. On the other hand, if this were
<i>2571</i>&nbsp;     * invoked with {@code -10, -1}, then the specified indices do not
<i>2572</i>&nbsp;     * bound the viewable set of rows, and the selection is cleared.
<i>2573</i>&nbsp;     * &lt;p&gt;
<i>2574</i>&nbsp;     * The parameters are not order dependent. That is, {@code
<b class="nc"><i>2575</i>&nbsp;     * setSelectionInterval(x, y)} is equivalent to</b>
<i>2576</i>&nbsp;     * {@code setSelectionInterval(y, x)}.
<b class="nc"><i>2577</i>&nbsp;     *</b>
<b class="nc"><i>2578</i>&nbsp;     * @param index0 the first index in the range to select</b>
<i>2579</i>&nbsp;     * @param index1 the last index in the range to select
<i>2580</i>&nbsp;    */
<i>2581</i>&nbsp;    public void setSelectionInterval(int index0, int index1) {
<i>2582</i>&nbsp;        TreePath[]         paths = getPathBetweenRows(index0, index1);
<i>2583</i>&nbsp;
<i>2584</i>&nbsp;        this.getSelectionModel().setSelectionPaths(paths);
<i>2585</i>&nbsp;    }
<i>2586</i>&nbsp;
<i>2587</i>&nbsp;    /**
<i>2588</i>&nbsp;     * Adds the specified rows (inclusive) to the selection. If the
<i>2589</i>&nbsp;     * specified indices are within the viewable set of rows, or bound
<i>2590</i>&nbsp;     * the viewable set of rows, then the specified indices are
<i>2591</i>&nbsp;     * constrained by the viewable set of rows. If the indices are not
<i>2592</i>&nbsp;     * within the viewable set of rows, or do not bound the viewable
<i>2593</i>&nbsp;     * set of rows, then the selection is unchanged. For example, if
<i>2594</i>&nbsp;     * the row count is {@code 10}, and this method is invoked with
<i>2595</i>&nbsp;     * {@code -1, 20}, then the specified indices bounds the viewable
<i>2596</i>&nbsp;     * range, and this is treated as if invoked with {@code 0, 9}. On
<i>2597</i>&nbsp;     * the other hand, if this were invoked with {@code -10, -1}, then
<i>2598</i>&nbsp;     * the specified indices do not bound the viewable set of rows,
<i>2599</i>&nbsp;     * and the selection is unchanged.
<i>2600</i>&nbsp;     * &lt;p&gt;
<i>2601</i>&nbsp;     * The parameters are not order dependent. That is, {@code
<i>2602</i>&nbsp;     * addSelectionInterval(x, y)} is equivalent to
<b class="nc"><i>2603</i>&nbsp;     * {@code addSelectionInterval(y, x)}.</b>
<i>2604</i>&nbsp;     *
<b class="nc"><i>2605</i>&nbsp;     * @param index0 the first index in the range to add to the selection</b>
<b class="nc"><i>2606</i>&nbsp;     * @param index1 the last index in the range to add to the selection</b>
<i>2607</i>&nbsp;     */
<i>2608</i>&nbsp;    public void addSelectionInterval(int index0, int index1) {
<i>2609</i>&nbsp;        TreePath[]         paths = getPathBetweenRows(index0, index1);
<i>2610</i>&nbsp;
<i>2611</i>&nbsp;        if (paths != null &amp;&amp; paths.length &gt; 0) {
<i>2612</i>&nbsp;            this.getSelectionModel().addSelectionPaths(paths);
<i>2613</i>&nbsp;        }
<i>2614</i>&nbsp;    }
<i>2615</i>&nbsp;
<i>2616</i>&nbsp;    /**
<b class="nc"><i>2617</i>&nbsp;     * Removes the specified rows (inclusive) from the selection. If</b>
<i>2618</i>&nbsp;     * the specified indices are within the viewable set of rows, or bound
<i>2619</i>&nbsp;     * the viewable set of rows, then the specified indices are constrained by
<i>2620</i>&nbsp;     * the viewable set of rows. If the specified indices are not within the
<i>2621</i>&nbsp;     * viewable set of rows, or do not bound the viewable set of rows, then
<i>2622</i>&nbsp;     * the selection is unchanged. For example, if the row count is {@code
<i>2623</i>&nbsp;     * 10}, and this method is invoked with {@code -1, 20}, then the
<i>2624</i>&nbsp;     * specified range bounds the viewable range, and this is treated as
<i>2625</i>&nbsp;     * if invoked with {@code 0, 9}. On the other hand, if this were
<i>2626</i>&nbsp;     * invoked with {@code -10, -1}, then the specified range does not
<i>2627</i>&nbsp;     * bound the viewable set of rows, and the selection is unchanged.
<b class="nc"><i>2628</i>&nbsp;     * &lt;p&gt;</b>
<i>2629</i>&nbsp;     * The parameters are not order dependent. That is, {@code
<i>2630</i>&nbsp;     * removeSelectionInterval(x, y)} is equivalent to
<i>2631</i>&nbsp;     * {@code removeSelectionInterval(y, x)}.
<i>2632</i>&nbsp;     *
<i>2633</i>&nbsp;     * @param index0 the first row to remove from the selection
<i>2634</i>&nbsp;     * @param index1 the last row to remove from the selection
<i>2635</i>&nbsp;     */
<i>2636</i>&nbsp;    public void removeSelectionInterval(int index0, int index1) {
<i>2637</i>&nbsp;        TreePath[]         paths = getPathBetweenRows(index0, index1);
<b class="nc"><i>2638</i>&nbsp;</b>
<i>2639</i>&nbsp;        if (paths != null &amp;&amp; paths.length &gt; 0) {
<b class="nc"><i>2640</i>&nbsp;            this.getSelectionModel().removeSelectionPaths(paths);</b>
<i>2641</i>&nbsp;        }
<i>2642</i>&nbsp;    }
<i>2643</i>&nbsp;
<i>2644</i>&nbsp;    /**
<i>2645</i>&nbsp;     * Removes the node identified by the specified path from the current
<i>2646</i>&nbsp;     * selection.
<i>2647</i>&nbsp;     *
<i>2648</i>&nbsp;     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; identifying a node
<i>2649</i>&nbsp;     */
<i>2650</i>&nbsp;    public void removeSelectionPath(TreePath path) {
<b class="nc"><i>2651</i>&nbsp;        this.getSelectionModel().removeSelectionPath(path);</b>
<i>2652</i>&nbsp;    }
<b class="nc"><i>2653</i>&nbsp;</b>
<b class="nc"><i>2654</i>&nbsp;    /**</b>
<b class="nc"><i>2655</i>&nbsp;     * Removes the nodes identified by the specified paths from the</b>
<i>2656</i>&nbsp;     * current selection.
<b class="nc"><i>2657</i>&nbsp;     *</b>
<b class="nc"><i>2658</i>&nbsp;     * @param paths an array of &lt;code&gt;TreePath&lt;/code&gt; objects that</b>
<b class="nc"><i>2659</i>&nbsp;     *              specifies the nodes to remove</b>
<i>2660</i>&nbsp;     */
<i>2661</i>&nbsp;    public void removeSelectionPaths(TreePath[] paths) {
<i>2662</i>&nbsp;        this.getSelectionModel().removeSelectionPaths(paths);
<i>2663</i>&nbsp;    }
<i>2664</i>&nbsp;
<i>2665</i>&nbsp;    /**
<i>2666</i>&nbsp;     * Removes the row at the index &lt;code&gt;row&lt;/code&gt; from the current
<b class="nc"><i>2667</i>&nbsp;     * selection.</b>
<i>2668</i>&nbsp;     *
<i>2669</i>&nbsp;     * @param row  the row to remove
<i>2670</i>&nbsp;     */
<i>2671</i>&nbsp;    public void removeSelectionRow(int row) {
<i>2672</i>&nbsp;        int[]             rows = { row };
<i>2673</i>&nbsp;
<i>2674</i>&nbsp;        removeSelectionRows(rows);
<i>2675</i>&nbsp;    }
<b class="nc"><i>2676</i>&nbsp;</b>
<i>2677</i>&nbsp;    /**
<i>2678</i>&nbsp;     * Removes the rows that are selected at each of the specified
<i>2679</i>&nbsp;     * rows.
<i>2680</i>&nbsp;     *
<i>2681</i>&nbsp;     * @param rows  an array of ints specifying display rows, where 0 is
<i>2682</i>&nbsp;     *             the first row in the display
<i>2683</i>&nbsp;     */
<i>2684</i>&nbsp;    public void removeSelectionRows(int[] rows) {
<i>2685</i>&nbsp;        TreeUI             ui = getUI();
<i>2686</i>&nbsp;
<b class="nc"><i>2687</i>&nbsp;        if(ui != null &amp;&amp; rows != null) {</b>
<b class="nc"><i>2688</i>&nbsp;            int                  numRows = rows.length;</b>
<i>2689</i>&nbsp;            TreePath[]           paths = new TreePath[numRows];
<b class="nc"><i>2690</i>&nbsp;</b>
<i>2691</i>&nbsp;            for(int counter = 0; counter &lt; numRows; counter++)
<i>2692</i>&nbsp;                paths[counter] = ui.getPathForRow(this, rows[counter]);
<i>2693</i>&nbsp;            removeSelectionPaths(paths);
<i>2694</i>&nbsp;        }
<i>2695</i>&nbsp;    }
<i>2696</i>&nbsp;
<i>2697</i>&nbsp;    /**
<i>2698</i>&nbsp;     * Clears the selection.
<b class="nc"><i>2699</i>&nbsp;     */</b>
<b class="nc"><i>2700</i>&nbsp;    public void clearSelection() {</b>
<b class="nc"><i>2701</i>&nbsp;        getSelectionModel().clearSelection();</b>
<i>2702</i>&nbsp;    }
<i>2703</i>&nbsp;
<i>2704</i>&nbsp;    /**
<i>2705</i>&nbsp;     * Returns true if the selection is currently empty.
<i>2706</i>&nbsp;     *
<i>2707</i>&nbsp;     * @return true if the selection is currently empty
<i>2708</i>&nbsp;     */
<i>2709</i>&nbsp;    @BeanProperty(bound = false)
<i>2710</i>&nbsp;    public boolean isSelectionEmpty() {
<i>2711</i>&nbsp;        return getSelectionModel().isSelectionEmpty();
<i>2712</i>&nbsp;    }
<i>2713</i>&nbsp;
<b class="nc"><i>2714</i>&nbsp;    /**</b>
<i>2715</i>&nbsp;     * Adds a listener for &lt;code&gt;TreeExpansion&lt;/code&gt; events.
<i>2716</i>&nbsp;     *
<i>2717</i>&nbsp;     * @param tel a TreeExpansionListener that will be notified when
<i>2718</i>&nbsp;     *            a tree node is expanded or collapsed (a &quot;negative
<i>2719</i>&nbsp;     *            expansion&quot;)
<i>2720</i>&nbsp;     */
<i>2721</i>&nbsp;    public void addTreeExpansionListener(TreeExpansionListener tel) {
<i>2722</i>&nbsp;        if (settingUI) {
<i>2723</i>&nbsp;            uiTreeExpansionListener = tel;
<i>2724</i>&nbsp;        }
<b class="nc"><i>2725</i>&nbsp;        listenerList.add(TreeExpansionListener.class, tel);</b>
<i>2726</i>&nbsp;    }
<i>2727</i>&nbsp;
<i>2728</i>&nbsp;    /**
<i>2729</i>&nbsp;     * Removes a listener for &lt;code&gt;TreeExpansion&lt;/code&gt; events.
<i>2730</i>&nbsp;     *
<i>2731</i>&nbsp;     * @param tel the &lt;code&gt;TreeExpansionListener&lt;/code&gt; to remove
<i>2732</i>&nbsp;     */
<i>2733</i>&nbsp;    public void removeTreeExpansionListener(TreeExpansionListener tel) {
<b class="nc"><i>2734</i>&nbsp;        listenerList.remove(TreeExpansionListener.class, tel);</b>
<i>2735</i>&nbsp;        if (uiTreeExpansionListener == tel) {
<i>2736</i>&nbsp;            uiTreeExpansionListener = null;
<i>2737</i>&nbsp;        }
<i>2738</i>&nbsp;    }
<i>2739</i>&nbsp;
<i>2740</i>&nbsp;    /**
<i>2741</i>&nbsp;     * Returns an array of all the &lt;code&gt;TreeExpansionListener&lt;/code&gt;s added
<i>2742</i>&nbsp;     * to this JTree with addTreeExpansionListener().
<i>2743</i>&nbsp;     *
<i>2744</i>&nbsp;     * @return all of the &lt;code&gt;TreeExpansionListener&lt;/code&gt;s added or an empty
<i>2745</i>&nbsp;     *         array if no listeners have been added
<b class="nc"><i>2746</i>&nbsp;     * @since 1.4</b>
<i>2747</i>&nbsp;     */
<i>2748</i>&nbsp;    @BeanProperty(bound = false)
<i>2749</i>&nbsp;    public TreeExpansionListener[] getTreeExpansionListeners() {
<i>2750</i>&nbsp;        return listenerList.getListeners(TreeExpansionListener.class);
<i>2751</i>&nbsp;    }
<i>2752</i>&nbsp;
<i>2753</i>&nbsp;    /**
<i>2754</i>&nbsp;     * Adds a listener for &lt;code&gt;TreeWillExpand&lt;/code&gt; events.
<i>2755</i>&nbsp;     *
<i>2756</i>&nbsp;     * @param tel a &lt;code&gt;TreeWillExpandListener&lt;/code&gt; that will be notified
<i>2757</i>&nbsp;     *            when a tree node will be expanded or collapsed (a &quot;negative
<i>2758</i>&nbsp;     *            expansion&quot;)
<i>2759</i>&nbsp;     */
<b class="nc"><i>2760</i>&nbsp;    public void addTreeWillExpandListener(TreeWillExpandListener tel) {</b>
<b class="nc"><i>2761</i>&nbsp;        listenerList.add(TreeWillExpandListener.class, tel);</b>
<b class="nc"><i>2762</i>&nbsp;    }</b>
<b class="nc"><i>2763</i>&nbsp;</b>
<b class="nc"><i>2764</i>&nbsp;    /**</b>
<i>2765</i>&nbsp;     * Removes a listener for &lt;code&gt;TreeWillExpand&lt;/code&gt; events.
<i>2766</i>&nbsp;     *
<i>2767</i>&nbsp;     * @param tel the &lt;code&gt;TreeWillExpandListener&lt;/code&gt; to remove
<b class="nc"><i>2768</i>&nbsp;     */</b>
<b class="nc"><i>2769</i>&nbsp;    public void removeTreeWillExpandListener(TreeWillExpandListener tel) {</b>
<i>2770</i>&nbsp;        listenerList.remove(TreeWillExpandListener.class, tel);
<i>2771</i>&nbsp;    }
<b class="nc"><i>2772</i>&nbsp;</b>
<b class="nc"><i>2773</i>&nbsp;    /**</b>
<b class="nc"><i>2774</i>&nbsp;     * Returns an array of all the &lt;code&gt;TreeWillExpandListener&lt;/code&gt;s added</b>
<b class="nc"><i>2775</i>&nbsp;     * to this JTree with addTreeWillExpandListener().</b>
<i>2776</i>&nbsp;     *
<i>2777</i>&nbsp;     * @return all of the &lt;code&gt;TreeWillExpandListener&lt;/code&gt;s added or an empty
<i>2778</i>&nbsp;     *         array if no listeners have been added
<i>2779</i>&nbsp;     * @since 1.4
<i>2780</i>&nbsp;     */
<i>2781</i>&nbsp;    @BeanProperty(bound = false)
<i>2782</i>&nbsp;    public TreeWillExpandListener[] getTreeWillExpandListeners() {
<i>2783</i>&nbsp;        return listenerList.getListeners(TreeWillExpandListener.class);
<i>2784</i>&nbsp;    }
<i>2785</i>&nbsp;
<i>2786</i>&nbsp;    /**
<i>2787</i>&nbsp;     * Notifies all listeners that have registered interest for
<i>2788</i>&nbsp;     * notification on this event type.  The event instance
<i>2789</i>&nbsp;     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
<i>2790</i>&nbsp;     *
<b class="nc"><i>2791</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was</b>
<b class="nc"><i>2792</i>&nbsp;     *          expanded</b>
<b class="nc"><i>2793</i>&nbsp;     * @see EventListenerList</b>
<b class="nc"><i>2794</i>&nbsp;     */</b>
<b class="nc"><i>2795</i>&nbsp;     public void fireTreeExpanded(TreePath path) {</b>
<i>2796</i>&nbsp;        // Guaranteed to return a non-null array
<i>2797</i>&nbsp;        Object[] listeners = listenerList.getListenerList();
<i>2798</i>&nbsp;        TreeExpansionEvent e = null;
<b class="nc"><i>2799</i>&nbsp;        if (uiTreeExpansionListener != null) {</b>
<b class="nc"><i>2800</i>&nbsp;            e = new TreeExpansionEvent(this, path);</b>
<i>2801</i>&nbsp;            uiTreeExpansionListener.treeExpanded(e);
<i>2802</i>&nbsp;        }
<b class="nc"><i>2803</i>&nbsp;        // Process the listeners last to first, notifying</b>
<b class="nc"><i>2804</i>&nbsp;        // those that are interested in this event</b>
<b class="nc"><i>2805</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {</b>
<b class="nc"><i>2806</i>&nbsp;            if (listeners[i]==TreeExpansionListener.class &amp;&amp;</b>
<i>2807</i>&nbsp;                listeners[i + 1] != uiTreeExpansionListener) {
<i>2808</i>&nbsp;                // Lazily create the event:
<i>2809</i>&nbsp;                if (e == null)
<i>2810</i>&nbsp;                    e = new TreeExpansionEvent(this, path);
<i>2811</i>&nbsp;                ((TreeExpansionListener)listeners[i+1]).
<i>2812</i>&nbsp;                    treeExpanded(e);
<i>2813</i>&nbsp;            }
<i>2814</i>&nbsp;        }
<i>2815</i>&nbsp;    }
<i>2816</i>&nbsp;
<i>2817</i>&nbsp;    /**
<i>2818</i>&nbsp;     * Notifies all listeners that have registered interest for
<i>2819</i>&nbsp;     * notification on this event type.  The event instance
<i>2820</i>&nbsp;     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
<i>2821</i>&nbsp;     *
<b class="nc"><i>2822</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was</b>
<b class="nc"><i>2823</i>&nbsp;     *          collapsed</b>
<i>2824</i>&nbsp;     * @see EventListenerList
<i>2825</i>&nbsp;     */
<b class="nc"><i>2826</i>&nbsp;    public void fireTreeCollapsed(TreePath path) {</b>
<b class="nc"><i>2827</i>&nbsp;        // Guaranteed to return a non-null array</b>
<i>2828</i>&nbsp;        Object[] listeners = listenerList.getListenerList();
<b class="nc"><i>2829</i>&nbsp;        TreeExpansionEvent e = null;</b>
<b class="nc"><i>2830</i>&nbsp;        if (uiTreeExpansionListener != null) {</b>
<b class="nc"><i>2831</i>&nbsp;            e = new TreeExpansionEvent(this, path);</b>
<b class="nc"><i>2832</i>&nbsp;            uiTreeExpansionListener.treeCollapsed(e);</b>
<i>2833</i>&nbsp;        }
<i>2834</i>&nbsp;        // Process the listeners last to first, notifying
<i>2835</i>&nbsp;        // those that are interested in this event
<i>2836</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {
<i>2837</i>&nbsp;            if (listeners[i]==TreeExpansionListener.class &amp;&amp;
<i>2838</i>&nbsp;                listeners[i + 1] != uiTreeExpansionListener) {
<i>2839</i>&nbsp;                // Lazily create the event:
<i>2840</i>&nbsp;                if (e == null)
<i>2841</i>&nbsp;                    e = new TreeExpansionEvent(this, path);
<i>2842</i>&nbsp;                ((TreeExpansionListener)listeners[i+1]).
<i>2843</i>&nbsp;                    treeCollapsed(e);
<i>2844</i>&nbsp;            }
<i>2845</i>&nbsp;        }
<i>2846</i>&nbsp;    }
<i>2847</i>&nbsp;
<b class="nc"><i>2848</i>&nbsp;    /**</b>
<b class="nc"><i>2849</i>&nbsp;     * Notifies all listeners that have registered interest for</b>
<i>2850</i>&nbsp;     * notification on this event type.  The event instance
<i>2851</i>&nbsp;     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
<b class="nc"><i>2852</i>&nbsp;     *</b>
<b class="nc"><i>2853</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was</b>
<i>2854</i>&nbsp;     *          expanded
<b class="nc"><i>2855</i>&nbsp;     * @throws ExpandVetoException if the expansion is prevented from occurring</b>
<b class="nc"><i>2856</i>&nbsp;     * @see EventListenerList</b>
<b class="nc"><i>2857</i>&nbsp;     */</b>
<b class="nc"><i>2858</i>&nbsp;     public void fireTreeWillExpand(TreePath path) throws ExpandVetoException {</b>
<i>2859</i>&nbsp;        // Guaranteed to return a non-null array
<i>2860</i>&nbsp;        Object[] listeners = listenerList.getListenerList();
<i>2861</i>&nbsp;        TreeExpansionEvent e = null;
<i>2862</i>&nbsp;        // Process the listeners last to first, notifying
<i>2863</i>&nbsp;        // those that are interested in this event
<i>2864</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {
<i>2865</i>&nbsp;            if (listeners[i]==TreeWillExpandListener.class) {
<i>2866</i>&nbsp;                // Lazily create the event:
<i>2867</i>&nbsp;                if (e == null)
<i>2868</i>&nbsp;                    e = new TreeExpansionEvent(this, path);
<i>2869</i>&nbsp;                ((TreeWillExpandListener)listeners[i+1]).
<i>2870</i>&nbsp;                    treeWillExpand(e);
<b class="nc"><i>2871</i>&nbsp;            }</b>
<b class="nc"><i>2872</i>&nbsp;        }</b>
<i>2873</i>&nbsp;    }
<b class="nc"><i>2874</i>&nbsp;</b>
<b class="nc"><i>2875</i>&nbsp;    /**</b>
<i>2876</i>&nbsp;     * Notifies all listeners that have registered interest for
<i>2877</i>&nbsp;     * notification on this event type.  The event instance
<i>2878</i>&nbsp;     * is lazily created using the &lt;code&gt;path&lt;/code&gt; parameter.
<i>2879</i>&nbsp;     *
<i>2880</i>&nbsp;     * @param path the &lt;code&gt;TreePath&lt;/code&gt; indicating the node that was
<i>2881</i>&nbsp;     *          expanded
<i>2882</i>&nbsp;     * @throws ExpandVetoException if the collapse is prevented from occurring
<i>2883</i>&nbsp;     * @see EventListenerList
<i>2884</i>&nbsp;     */
<b class="nc"><i>2885</i>&nbsp;     public void fireTreeWillCollapse(TreePath path) throws ExpandVetoException {</b>
<b class="nc"><i>2886</i>&nbsp;        // Guaranteed to return a non-null array</b>
<i>2887</i>&nbsp;        Object[] listeners = listenerList.getListenerList();
<b class="nc"><i>2888</i>&nbsp;        TreeExpansionEvent e = null;</b>
<b class="nc"><i>2889</i>&nbsp;        // Process the listeners last to first, notifying</b>
<b class="nc"><i>2890</i>&nbsp;        // those that are interested in this event</b>
<i>2891</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {
<i>2892</i>&nbsp;            if (listeners[i]==TreeWillExpandListener.class) {
<i>2893</i>&nbsp;                // Lazily create the event:
<i>2894</i>&nbsp;                if (e == null)
<i>2895</i>&nbsp;                    e = new TreeExpansionEvent(this, path);
<i>2896</i>&nbsp;                ((TreeWillExpandListener)listeners[i+1]).
<i>2897</i>&nbsp;                    treeWillCollapse(e);
<i>2898</i>&nbsp;            }
<i>2899</i>&nbsp;        }
<i>2900</i>&nbsp;    }
<i>2901</i>&nbsp;
<i>2902</i>&nbsp;    /**
<b class="nc"><i>2903</i>&nbsp;     * Adds a listener for &lt;code&gt;TreeSelection&lt;/code&gt; events.</b>
<i>2904</i>&nbsp;     *
<i>2905</i>&nbsp;     * @param tsl the &lt;code&gt;TreeSelectionListener&lt;/code&gt; that will be notified
<i>2906</i>&nbsp;     *            when a node is selected or deselected (a &quot;negative
<i>2907</i>&nbsp;     *            selection&quot;)
<i>2908</i>&nbsp;     */
<i>2909</i>&nbsp;    public void addTreeSelectionListener(TreeSelectionListener tsl) {
<i>2910</i>&nbsp;        listenerList.add(TreeSelectionListener.class,tsl);
<i>2911</i>&nbsp;        if(listenerList.getListenerCount(TreeSelectionListener.class) != 0
<i>2912</i>&nbsp;           &amp;&amp; selectionRedirector == null) {
<i>2913</i>&nbsp;            selectionRedirector = new TreeSelectionRedirector();
<i>2914</i>&nbsp;            selectionModel.addTreeSelectionListener(selectionRedirector);
<i>2915</i>&nbsp;        }
<i>2916</i>&nbsp;    }
<i>2917</i>&nbsp;
<b class="nc"><i>2918</i>&nbsp;    /**</b>
<i>2919</i>&nbsp;     * Removes a &lt;code&gt;TreeSelection&lt;/code&gt; listener.
<i>2920</i>&nbsp;     *
<b class="nc"><i>2921</i>&nbsp;     * @param tsl the &lt;code&gt;TreeSelectionListener&lt;/code&gt; to remove</b>
<i>2922</i>&nbsp;     */
<b class="nc"><i>2923</i>&nbsp;    public void removeTreeSelectionListener(TreeSelectionListener tsl) {</b>
<i>2924</i>&nbsp;        listenerList.remove(TreeSelectionListener.class,tsl);
<i>2925</i>&nbsp;        if(listenerList.getListenerCount(TreeSelectionListener.class) == 0
<i>2926</i>&nbsp;           &amp;&amp; selectionRedirector != null) {
<b class="nc"><i>2927</i>&nbsp;            selectionModel.removeTreeSelectionListener</b>
<i>2928</i>&nbsp;                (selectionRedirector);
<i>2929</i>&nbsp;            selectionRedirector = null;
<i>2930</i>&nbsp;        }
<i>2931</i>&nbsp;    }
<i>2932</i>&nbsp;
<i>2933</i>&nbsp;    /**
<i>2934</i>&nbsp;     * Returns an array of all the &lt;code&gt;TreeSelectionListener&lt;/code&gt;s added
<i>2935</i>&nbsp;     * to this JTree with addTreeSelectionListener().
<i>2936</i>&nbsp;     *
<i>2937</i>&nbsp;     * @return all of the &lt;code&gt;TreeSelectionListener&lt;/code&gt;s added or an empty
<i>2938</i>&nbsp;     *         array if no listeners have been added
<i>2939</i>&nbsp;     * @since 1.4
<b class="nc"><i>2940</i>&nbsp;     */</b>
<b class="nc"><i>2941</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>2942</i>&nbsp;    public TreeSelectionListener[] getTreeSelectionListeners() {
<i>2943</i>&nbsp;        return listenerList.getListeners(TreeSelectionListener.class);
<i>2944</i>&nbsp;    }
<i>2945</i>&nbsp;
<i>2946</i>&nbsp;    /**
<i>2947</i>&nbsp;     * Notifies all listeners that have registered interest for
<i>2948</i>&nbsp;     * notification on this event type.
<i>2949</i>&nbsp;     *
<i>2950</i>&nbsp;     * @param e the &lt;code&gt;TreeSelectionEvent&lt;/code&gt; to be fired;
<i>2951</i>&nbsp;     *          generated by the
<i>2952</i>&nbsp;     *          &lt;code&gt;TreeSelectionModel&lt;/code&gt;
<i>2953</i>&nbsp;     *          when a node is selected or deselected
<i>2954</i>&nbsp;     * @see EventListenerList
<i>2955</i>&nbsp;     */
<i>2956</i>&nbsp;    protected void fireValueChanged(TreeSelectionEvent e) {
<i>2957</i>&nbsp;        // Guaranteed to return a non-null array
<b class="nc"><i>2958</i>&nbsp;        Object[] listeners = listenerList.getListenerList();</b>
<i>2959</i>&nbsp;        // Process the listeners last to first, notifying
<b class="nc"><i>2960</i>&nbsp;        // those that are interested in this event</b>
<b class="nc"><i>2961</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {</b>
<i>2962</i>&nbsp;            // TreeSelectionEvent e = null;
<b class="nc"><i>2963</i>&nbsp;            if (listeners[i]==TreeSelectionListener.class) {</b>
<b class="nc"><i>2964</i>&nbsp;                // Lazily create the event:</b>
<b class="nc"><i>2965</i>&nbsp;                // if (e == null)</b>
<i>2966</i>&nbsp;                // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<i>2967</i>&nbsp;                ((TreeSelectionListener)listeners[i+1]).valueChanged(e);
<i>2968</i>&nbsp;            }
<i>2969</i>&nbsp;        }
<i>2970</i>&nbsp;    }
<i>2971</i>&nbsp;
<i>2972</i>&nbsp;    /**
<i>2973</i>&nbsp;     * Sent when the tree has changed enough that we need to resize
<i>2974</i>&nbsp;     * the bounds, but not enough that we need to remove the
<b class="nc"><i>2975</i>&nbsp;     * expanded node set (e.g nodes were expanded or collapsed, or</b>
<i>2976</i>&nbsp;     * nodes were inserted into the tree). You should never have to
<i>2977</i>&nbsp;     * invoke this, the UI will invoke this as it needs to.
<i>2978</i>&nbsp;     */
<i>2979</i>&nbsp;    public void treeDidChange() {
<i>2980</i>&nbsp;        revalidate();
<i>2981</i>&nbsp;        repaint();
<b class="nc"><i>2982</i>&nbsp;    }</b>
<i>2983</i>&nbsp;
<b class="nc"><i>2984</i>&nbsp;    /**</b>
<b class="nc"><i>2985</i>&nbsp;     * Sets the number of rows that are to be displayed.</b>
<i>2986</i>&nbsp;     * This will only work if the tree is contained in a
<i>2987</i>&nbsp;     * &lt;code&gt;JScrollPane&lt;/code&gt;,
<i>2988</i>&nbsp;     * and will adjust the preferred size and size of that scrollpane.
<i>2989</i>&nbsp;     * &lt;p&gt;
<i>2990</i>&nbsp;     * This is a bound property.
<i>2991</i>&nbsp;     *
<i>2992</i>&nbsp;     * @param newCount the number of rows to display
<i>2993</i>&nbsp;     */
<i>2994</i>&nbsp;    @BeanProperty(description
<i>2995</i>&nbsp;            = &quot;The number of rows that are to be displayed.&quot;)
<i>2996</i>&nbsp;    public void setVisibleRowCount(int newCount) {
<i>2997</i>&nbsp;        int                 oldCount = visibleRowCount;
<i>2998</i>&nbsp;
<i>2999</i>&nbsp;        visibleRowCount = newCount;
<i>3000</i>&nbsp;        firePropertyChange(VISIBLE_ROW_COUNT_PROPERTY, oldCount,
<i>3001</i>&nbsp;                           visibleRowCount);
<i>3002</i>&nbsp;        invalidate();
<i>3003</i>&nbsp;        if (accessibleContext != null) {
<i>3004</i>&nbsp;            ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();
<i>3005</i>&nbsp;        }
<i>3006</i>&nbsp;    }
<i>3007</i>&nbsp;
<b class="nc"><i>3008</i>&nbsp;    /**</b>
<b class="nc"><i>3009</i>&nbsp;     * Returns the number of rows that are displayed in the display area.</b>
<b class="nc"><i>3010</i>&nbsp;     *</b>
<i>3011</i>&nbsp;     * @return the number of rows displayed
<b class="nc"><i>3012</i>&nbsp;     */</b>
<b class="nc"><i>3013</i>&nbsp;    public int getVisibleRowCount() {</b>
<i>3014</i>&nbsp;        return visibleRowCount;
<b class="nc"><i>3015</i>&nbsp;    }</b>
<i>3016</i>&nbsp;
<i>3017</i>&nbsp;    /**
<i>3018</i>&nbsp;     * Expands the root path, assuming the current TreeModel has been set.
<b class="nc"><i>3019</i>&nbsp;     */</b>
<b class="nc"><i>3020</i>&nbsp;    private void expandRoot() {</b>
<i>3021</i>&nbsp;        TreeModel   model = getModel();
<b class="nc"><i>3022</i>&nbsp;        if(model != null &amp;&amp; model.getRoot() != null) {</b>
<b class="nc"><i>3023</i>&nbsp;            expandPath(new TreePath(model.getRoot()));</b>
<b class="nc"><i>3024</i>&nbsp;        }</b>
<b class="nc"><i>3025</i>&nbsp;    }</b>
<i>3026</i>&nbsp;
<b class="nc"><i>3027</i>&nbsp;    /**</b>
<b class="nc"><i>3028</i>&nbsp;     * Returns the TreePath to the next tree element that</b>
<i>3029</i>&nbsp;     * begins with a prefix. To handle the conversion of a
<b class="nc"><i>3030</i>&nbsp;     * &lt;code&gt;TreePath&lt;/code&gt; into a String, &lt;code&gt;convertValueToText&lt;/code&gt;</b>
<b class="nc"><i>3031</i>&nbsp;     * is used.</b>
<b class="nc"><i>3032</i>&nbsp;     *</b>
<i>3033</i>&nbsp;     * @param prefix the string to test for a match
<i>3034</i>&nbsp;     * @param startingRow the row for starting the search
<i>3035</i>&nbsp;     * @param bias the search direction, either
<i>3036</i>&nbsp;     * Position.Bias.Forward or Position.Bias.Backward.
<b class="nc"><i>3037</i>&nbsp;     * @return the TreePath of the next tree element that</b>
<i>3038</i>&nbsp;     * starts with the prefix; otherwise null
<b class="nc"><i>3039</i>&nbsp;     * @exception IllegalArgumentException if prefix is null</b>
<i>3040</i>&nbsp;     * or startingRow is out of bounds
<b class="nc"><i>3041</i>&nbsp;     * @since 1.4</b>
<b class="nc"><i>3042</i>&nbsp;     */</b>
<b class="nc"><i>3043</i>&nbsp;    public TreePath getNextMatch(String prefix, int startingRow,</b>
<i>3044</i>&nbsp;                                 Position.Bias bias) {
<i>3045</i>&nbsp;
<b class="nc"><i>3046</i>&nbsp;        int max = getRowCount();</b>
<b class="nc"><i>3047</i>&nbsp;        if (prefix == null) {</b>
<b class="nc"><i>3048</i>&nbsp;            throw new IllegalArgumentException();</b>
<i>3049</i>&nbsp;        }
<i>3050</i>&nbsp;        if (startingRow &lt; 0 || startingRow &gt;= max) {
<b class="nc"><i>3051</i>&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc"><i>3052</i>&nbsp;        }</b>
<b class="nc"><i>3053</i>&nbsp;        prefix = prefix.toUpperCase();</b>
<i>3054</i>&nbsp;
<i>3055</i>&nbsp;        // start search from the next/previous element froom the
<b class="nc"><i>3056</i>&nbsp;        // selected element</b>
<b class="nc"><i>3057</i>&nbsp;        int increment = (bias == Position.Bias.Forward) ? 1 : -1;</b>
<b class="nc"><i>3058</i>&nbsp;        int row = startingRow;</b>
<i>3059</i>&nbsp;        do {
<i>3060</i>&nbsp;            TreePath path = getPathForRow(row);
<b class="nc"><i>3061</i>&nbsp;            String text = convertValueToText(</b>
<i>3062</i>&nbsp;                path.getLastPathComponent(), isRowSelected(row),
<b class="nc"><i>3063</i>&nbsp;                isExpanded(row), true, row, false);</b>
<b class="nc"><i>3064</i>&nbsp;</b>
<b class="nc"><i>3065</i>&nbsp;            if (text.toUpperCase().startsWith(prefix)) {</b>
<i>3066</i>&nbsp;                return path;
<i>3067</i>&nbsp;            }
<b class="nc"><i>3068</i>&nbsp;            row = (row + increment + max) % max;</b>
<b class="nc"><i>3069</i>&nbsp;        } while (row != startingRow);</b>
<b class="nc"><i>3070</i>&nbsp;        return null;</b>
<b class="nc"><i>3071</i>&nbsp;    }</b>
<b class="nc"><i>3072</i>&nbsp;</b>
<b class="nc"><i>3073</i>&nbsp;    // Serialization support.</b>
<i>3074</i>&nbsp;    private void writeObject(ObjectOutputStream s) throws IOException {
<i>3075</i>&nbsp;        Vector&lt;Object&gt; values = new Vector&lt;Object&gt;();
<i>3076</i>&nbsp;
<i>3077</i>&nbsp;        s.defaultWriteObject();
<i>3078</i>&nbsp;        // Save the cellRenderer, if its Serializable.
<i>3079</i>&nbsp;        if(cellRenderer != null &amp;&amp; cellRenderer instanceof Serializable) {
<b class="nc"><i>3080</i>&nbsp;            values.addElement(&quot;cellRenderer&quot;);</b>
<i>3081</i>&nbsp;            values.addElement(cellRenderer);
<i>3082</i>&nbsp;        }
<i>3083</i>&nbsp;        // Save the cellEditor, if its Serializable.
<b class="nc"><i>3084</i>&nbsp;        if(cellEditor != null &amp;&amp; cellEditor instanceof Serializable) {</b>
<i>3085</i>&nbsp;            values.addElement(&quot;cellEditor&quot;);
<b class="nc"><i>3086</i>&nbsp;            values.addElement(cellEditor);</b>
<i>3087</i>&nbsp;        }
<b class="nc"><i>3088</i>&nbsp;        // Save the treeModel, if its Serializable.</b>
<b class="nc"><i>3089</i>&nbsp;        if(treeModel != null &amp;&amp; treeModel instanceof Serializable) {</b>
<b class="nc"><i>3090</i>&nbsp;            values.addElement(&quot;treeModel&quot;);</b>
<i>3091</i>&nbsp;            values.addElement(treeModel);
<b class="nc"><i>3092</i>&nbsp;        }</b>
<b class="nc"><i>3093</i>&nbsp;        // Save the selectionModel, if its Serializable.</b>
<b class="nc"><i>3094</i>&nbsp;        if(selectionModel != null &amp;&amp; selectionModel instanceof Serializable) {</b>
<b class="nc"><i>3095</i>&nbsp;            values.addElement(&quot;selectionModel&quot;);</b>
<i>3096</i>&nbsp;            values.addElement(selectionModel);
<b class="nc"><i>3097</i>&nbsp;        }</b>
<b class="nc"><i>3098</i>&nbsp;</b>
<b class="nc"><i>3099</i>&nbsp;        Object      expandedData = getArchivableExpandedState();</b>
<b class="nc"><i>3100</i>&nbsp;</b>
<i>3101</i>&nbsp;        if(expandedData != null) {
<b class="nc"><i>3102</i>&nbsp;            values.addElement(&quot;expandedState&quot;);</b>
<b class="nc"><i>3103</i>&nbsp;            values.addElement(expandedData);</b>
<b class="nc"><i>3104</i>&nbsp;        }</b>
<b class="nc"><i>3105</i>&nbsp;</b>
<i>3106</i>&nbsp;        s.writeObject(values);
<b class="nc"><i>3107</i>&nbsp;        if (getUIClassID().equals(uiClassID)) {</b>
<b class="nc"><i>3108</i>&nbsp;            byte count = JComponent.getWriteObjCounter(this);</b>
<b class="nc"><i>3109</i>&nbsp;            JComponent.setWriteObjCounter(this, --count);</b>
<b class="nc"><i>3110</i>&nbsp;            if (count == 0 &amp;&amp; ui != null) {</b>
<i>3111</i>&nbsp;                ui.installUI(this);
<b class="nc"><i>3112</i>&nbsp;            }</b>
<b class="nc"><i>3113</i>&nbsp;        }</b>
<b class="nc"><i>3114</i>&nbsp;    }</b>
<b class="nc"><i>3115</i>&nbsp;</b>
<i>3116</i>&nbsp;    private void readObject(ObjectInputStream s)
<i>3117</i>&nbsp;        throws IOException, ClassNotFoundException {
<b class="nc"><i>3118</i>&nbsp;        ObjectInputStream.GetField f = s.readFields();</b>
<b class="nc"><i>3119</i>&nbsp;</b>
<b class="nc"><i>3120</i>&nbsp;        rootVisible = f.get(&quot;rootVisible&quot;, false);</b>
<i>3121</i>&nbsp;        rowHeight = f.get(&quot;rowHeight&quot;, 0);
<i>3122</i>&nbsp;        rowHeightSet = f.get(&quot;rowHeightSet&quot;, false);
<b class="nc"><i>3123</i>&nbsp;        showsRootHandles = f.get(&quot;showsRootHandles&quot;, false);</b>
<b class="nc"><i>3124</i>&nbsp;        showsRootHandlesSet = f.get(&quot;showsRootHandlesSet&quot;, false);</b>
<b class="nc"><i>3125</i>&nbsp;        editable = f.get(&quot;editable&quot;, false);</b>
<b class="nc"><i>3126</i>&nbsp;        largeModel = f.get(&quot;largeModel&quot;, false);</b>
<i>3127</i>&nbsp;        visibleRowCount = f.get(&quot;visibleRowCount&quot;, 0);
<i>3128</i>&nbsp;        invokesStopCellEditing = f.get(&quot;invokesStopCellEditing&quot;, false);
<i>3129</i>&nbsp;        scrollsOnExpand = f.get(&quot;scrollsOnExpand&quot;, false);
<i>3130</i>&nbsp;        scrollsOnExpandSet = f.get(&quot;scrollsOnExpandSet&quot;, false);
<i>3131</i>&nbsp;        toggleClickCount = f.get(&quot;toggleClickCount&quot;, 0);
<i>3132</i>&nbsp;        leadPath = (TreePath) f.get(&quot;leadPath&quot;, null);
<i>3133</i>&nbsp;        anchorPath = (TreePath) f.get(&quot;anchorPath&quot;, null);
<i>3134</i>&nbsp;        expandsSelectedPaths = f.get(&quot;expandsSelectedPaths&quot;, false);
<i>3135</i>&nbsp;        settingUI = f.get(&quot;settingUI&quot;, false);
<b class="nc"><i>3136</i>&nbsp;        boolean newDragEnabled = f.get(&quot;dragEnabled&quot;, false);</b>
<i>3137</i>&nbsp;        checkDragEnabled(newDragEnabled);
<b class="nc"><i>3138</i>&nbsp;        dragEnabled = newDragEnabled;</b>
<b class="nc"><i>3139</i>&nbsp;        DropMode newDropMode = (DropMode) f.get(&quot;dropMode&quot;,</b>
<i>3140</i>&nbsp;                DropMode.USE_SELECTION);
<b class="nc"><i>3141</i>&nbsp;        checkDropMode(newDropMode);</b>
<b class="nc"><i>3142</i>&nbsp;        dropMode = newDropMode;</b>
<i>3143</i>&nbsp;
<b class="nc"><i>3144</i>&nbsp;        expandRow = f.get(&quot;expandRow&quot;, -1);</b>
<b class="nc"><i>3145</i>&nbsp;        dropTimer = (TreeTimer) f.get(&quot;dropTimer&quot;, null);</b>
<i>3146</i>&nbsp;
<i>3147</i>&nbsp;        // Create an instance of expanded state.
<i>3148</i>&nbsp;
<b class="nc"><i>3149</i>&nbsp;        expandedState = new Hashtable&lt;TreePath, Boolean&gt;();</b>
<b class="nc"><i>3150</i>&nbsp;</b>
<b class="nc"><i>3151</i>&nbsp;        expandedStack = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</b>
<b class="nc"><i>3152</i>&nbsp;</b>
<b class="nc"><i>3153</i>&nbsp;        Vector&lt;?&gt;          values = (Vector)s.readObject();</b>
<b class="nc"><i>3154</i>&nbsp;        int             indexCounter = 0;</b>
<b class="nc"><i>3155</i>&nbsp;        int             maxCounter = values.size();</b>
<i>3156</i>&nbsp;
<b class="nc"><i>3157</i>&nbsp;        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</b>
<b class="nc"><i>3158</i>&nbsp;           equals(&quot;cellRenderer&quot;)) {</b>
<i>3159</i>&nbsp;            cellRenderer = (TreeCellRenderer)values.elementAt(++indexCounter);
<i>3160</i>&nbsp;            indexCounter++;
<b class="nc"><i>3161</i>&nbsp;        }</b>
<i>3162</i>&nbsp;        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).
<i>3163</i>&nbsp;           equals(&quot;cellEditor&quot;)) {
<i>3164</i>&nbsp;            cellEditor = (TreeCellEditor)values.elementAt(++indexCounter);
<i>3165</i>&nbsp;            indexCounter++;
<i>3166</i>&nbsp;        }
<i>3167</i>&nbsp;        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).
<i>3168</i>&nbsp;           equals(&quot;treeModel&quot;)) {
<b class="nc"><i>3169</i>&nbsp;            treeModel = (TreeModel)values.elementAt(++indexCounter);</b>
<b class="nc"><i>3170</i>&nbsp;            indexCounter++;</b>
<i>3171</i>&nbsp;        }
<b class="nc"><i>3172</i>&nbsp;        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</b>
<b class="nc"><i>3173</i>&nbsp;           equals(&quot;selectionModel&quot;)) {</b>
<i>3174</i>&nbsp;            selectionModel = (TreeSelectionModel)values.elementAt(++indexCounter);
<i>3175</i>&nbsp;            indexCounter++;
<i>3176</i>&nbsp;        }
<b class="nc"><i>3177</i>&nbsp;        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</b>
<b class="nc"><i>3178</i>&nbsp;           equals(&quot;expandedState&quot;)) {</b>
<b class="nc"><i>3179</i>&nbsp;            unarchiveExpandedState(values.elementAt(++indexCounter));</b>
<b class="nc"><i>3180</i>&nbsp;            indexCounter++;</b>
<i>3181</i>&nbsp;        }
<i>3182</i>&nbsp;        // Reinstall the redirector.
<i>3183</i>&nbsp;        if(listenerList.getListenerCount(TreeSelectionListener.class) != 0) {
<i>3184</i>&nbsp;            selectionRedirector = new TreeSelectionRedirector();
<i>3185</i>&nbsp;            selectionModel.addTreeSelectionListener(selectionRedirector);
<i>3186</i>&nbsp;        }
<i>3187</i>&nbsp;        // Listener to TreeModel.
<i>3188</i>&nbsp;        if(treeModel != null) {
<i>3189</i>&nbsp;            treeModelListener = createTreeModelListener();
<i>3190</i>&nbsp;            if(treeModelListener != null)
<i>3191</i>&nbsp;                treeModel.addTreeModelListener(treeModelListener);
<b class="nc"><i>3192</i>&nbsp;        }</b>
<b class="nc"><i>3193</i>&nbsp;    }</b>
<b class="nc"><i>3194</i>&nbsp;</b>
<b class="nc"><i>3195</i>&nbsp;    /**</b>
<b class="nc"><i>3196</i>&nbsp;     * Returns an object that can be archived indicating what nodes are</b>
<i>3197</i>&nbsp;     * expanded and what aren&#39;t. The objects from the model are NOT
<b class="nc"><i>3198</i>&nbsp;     * written out.</b>
<b class="nc"><i>3199</i>&nbsp;     */</b>
<b class="nc"><i>3200</i>&nbsp;    private Object getArchivableExpandedState() {</b>
<b class="nc"><i>3201</i>&nbsp;        TreeModel       model = getModel();</b>
<b class="nc"><i>3202</i>&nbsp;</b>
<b class="nc"><i>3203</i>&nbsp;        if(model != null) {</b>
<i>3204</i>&nbsp;            Enumeration&lt;TreePath&gt; paths = expandedState.keys();
<b class="nc"><i>3205</i>&nbsp;</b>
<i>3206</i>&nbsp;            if(paths != null) {
<b class="nc"><i>3207</i>&nbsp;                Vector&lt;Object&gt; state = new Vector&lt;Object&gt;();</b>
<i>3208</i>&nbsp;
<i>3209</i>&nbsp;                while(paths.hasMoreElements()) {
<i>3210</i>&nbsp;                    TreePath path = paths.nextElement();
<i>3211</i>&nbsp;                    Object     archivePath;
<i>3212</i>&nbsp;
<i>3213</i>&nbsp;                    try {
<i>3214</i>&nbsp;                        archivePath = getModelIndexsForPath(path);
<i>3215</i>&nbsp;                    } catch (Error error) {
<i>3216</i>&nbsp;                        archivePath = null;
<b class="nc"><i>3217</i>&nbsp;                    }</b>
<b class="nc"><i>3218</i>&nbsp;                    if(archivePath != null) {</b>
<i>3219</i>&nbsp;                        state.addElement(archivePath);
<b class="nc"><i>3220</i>&nbsp;                        state.addElement(expandedState.get(path));</b>
<i>3221</i>&nbsp;                    }
<b class="nc"><i>3222</i>&nbsp;                }</b>
<b class="nc"><i>3223</i>&nbsp;                return state;</b>
<i>3224</i>&nbsp;            }
<b class="nc"><i>3225</i>&nbsp;        }</b>
<b class="nc"><i>3226</i>&nbsp;        return null;</b>
<b class="nc"><i>3227</i>&nbsp;    }</b>
<b class="nc"><i>3228</i>&nbsp;</b>
<i>3229</i>&nbsp;    /**
<b class="nc"><i>3230</i>&nbsp;     * Updates the expanded state of nodes in the tree based on the</b>
<i>3231</i>&nbsp;     * previously archived state &lt;code&gt;state&lt;/code&gt;.
<b class="nc"><i>3232</i>&nbsp;     */</b>
<b class="nc"><i>3233</i>&nbsp;    private void unarchiveExpandedState(Object state) {</b>
<b class="nc"><i>3234</i>&nbsp;        if(state instanceof Vector) {</b>
<b class="nc"><i>3235</i>&nbsp;            Vector&lt;?&gt;          paths = (Vector)state;</b>
<b class="nc"><i>3236</i>&nbsp;</b>
<i>3237</i>&nbsp;            for(int counter = paths.size() - 1; counter &gt;= 0; counter--) {
<b class="nc"><i>3238</i>&nbsp;                Boolean        eState = (Boolean)paths.elementAt(counter--);</b>
<i>3239</i>&nbsp;                TreePath       path;
<i>3240</i>&nbsp;
<i>3241</i>&nbsp;                try {
<i>3242</i>&nbsp;                    path = getPathForIndexs((int[])paths.elementAt(counter));
<i>3243</i>&nbsp;                    if(path != null)
<i>3244</i>&nbsp;                        expandedState.put(path, eState);
<i>3245</i>&nbsp;                } catch (Error error) {}
<i>3246</i>&nbsp;            }
<i>3247</i>&nbsp;        }
<i>3248</i>&nbsp;    }
<i>3249</i>&nbsp;
<i>3250</i>&nbsp;    /**
<i>3251</i>&nbsp;     * Returns an array of integers specifying the indexs of the
<i>3252</i>&nbsp;     * components in the &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;path&lt;/code&gt; is
<i>3253</i>&nbsp;     * the root, this will return an empty array.  If &lt;code&gt;path&lt;/code&gt;
<i>3254</i>&nbsp;     * is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be returned.
<b class="nc"><i>3255</i>&nbsp;     */</b>
<i>3256</i>&nbsp;    private int[] getModelIndexsForPath(TreePath path) {
<i>3257</i>&nbsp;        if(path != null) {
<i>3258</i>&nbsp;            TreeModel   model = getModel();
<i>3259</i>&nbsp;            int         count = path.getPathCount();
<i>3260</i>&nbsp;            int[]       indexs = new int[count - 1];
<b class="nc"><i>3261</i>&nbsp;            Object      parent = model.getRoot();</b>
<i>3262</i>&nbsp;
<i>3263</i>&nbsp;            for(int counter = 1; counter &lt; count; counter++) {
<i>3264</i>&nbsp;                indexs[counter - 1] = model.getIndexOfChild
<i>3265</i>&nbsp;                                   (parent, path.getPathComponent(counter));
<i>3266</i>&nbsp;                parent = path.getPathComponent(counter);
<i>3267</i>&nbsp;                if(indexs[counter - 1] &lt; 0)
<i>3268</i>&nbsp;                    return null;
<i>3269</i>&nbsp;            }
<b class="nc"><i>3270</i>&nbsp;            return indexs;</b>
<i>3271</i>&nbsp;        }
<i>3272</i>&nbsp;        return null;
<i>3273</i>&nbsp;    }
<i>3274</i>&nbsp;
<i>3275</i>&nbsp;    /**
<i>3276</i>&nbsp;     * Returns a &lt;code&gt;TreePath&lt;/code&gt; created by obtaining the children
<i>3277</i>&nbsp;     * for each of the indices in &lt;code&gt;indexs&lt;/code&gt;. If &lt;code&gt;indexs&lt;/code&gt;
<i>3278</i>&nbsp;     * or the &lt;code&gt;TreeModel&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, it will return
<i>3279</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt;.
<i>3280</i>&nbsp;     */
<i>3281</i>&nbsp;    private TreePath getPathForIndexs(int[] indexs) {
<i>3282</i>&nbsp;        if(indexs == null)
<i>3283</i>&nbsp;            return null;
<i>3284</i>&nbsp;
<i>3285</i>&nbsp;        TreeModel    model = getModel();
<i>3286</i>&nbsp;
<i>3287</i>&nbsp;        if(model == null)
<i>3288</i>&nbsp;            return null;
<i>3289</i>&nbsp;
<i>3290</i>&nbsp;        int          count = indexs.length;
<i>3291</i>&nbsp;
<i>3292</i>&nbsp;        Object       parent = model.getRoot();
<i>3293</i>&nbsp;        if (parent == null)
<i>3294</i>&nbsp;            return null;
<i>3295</i>&nbsp;
<i>3296</i>&nbsp;        TreePath     parentPath = new TreePath(parent);
<i>3297</i>&nbsp;        for(int counter = 0; counter &lt; count; counter++) {
<i>3298</i>&nbsp;            parent = model.getChild(parent, indexs[counter]);
<i>3299</i>&nbsp;            if(parent == null)
<i>3300</i>&nbsp;                return null;
<i>3301</i>&nbsp;            parentPath = parentPath.pathByAddingChild(parent);
<i>3302</i>&nbsp;        }
<i>3303</i>&nbsp;        return parentPath;
<i>3304</i>&nbsp;    }
<i>3305</i>&nbsp;
<i>3306</i>&nbsp;    /**
<i>3307</i>&nbsp;     * &lt;code&gt;EmptySelectionModel&lt;/code&gt; is a &lt;code&gt;TreeSelectionModel&lt;/code&gt;
<i>3308</i>&nbsp;     * that does not allow anything to be selected.
<i>3309</i>&nbsp;     * &lt;p&gt;
<i>3310</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>3311</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>3312</i>&nbsp;     * future Swing releases. The current serialization support is
<i>3313</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>3314</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>3315</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>3316</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>3317</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<i>3318</i>&nbsp;     */
<i>3319</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>3320</i>&nbsp;    protected static class EmptySelectionModel extends
<i>3321</i>&nbsp;              DefaultTreeSelectionModel
<i>3322</i>&nbsp;    {
<i>3323</i>&nbsp;        /**
<i>3324</i>&nbsp;         * The single instance of {@code EmptySelectionModel}.
<i>3325</i>&nbsp;         */
<i>3326</i>&nbsp;        protected static final EmptySelectionModel sharedInstance =
<i>3327</i>&nbsp;            new EmptySelectionModel();
<i>3328</i>&nbsp;
<i>3329</i>&nbsp;        /**
<i>3330</i>&nbsp;         * Returns the single instance of {@code EmptySelectionModel}.
<i>3331</i>&nbsp;         *
<i>3332</i>&nbsp;         * @return single instance of {@code EmptySelectionModel}
<i>3333</i>&nbsp;         */
<i>3334</i>&nbsp;        public static EmptySelectionModel sharedInstance() {
<i>3335</i>&nbsp;            return sharedInstance;
<i>3336</i>&nbsp;        }
<i>3337</i>&nbsp;
<i>3338</i>&nbsp;        /**
<i>3339</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3340</i>&nbsp;         * does not allow a selection.
<i>3341</i>&nbsp;         *
<i>3342</i>&nbsp;         * @param paths the paths to select; this is ignored
<i>3343</i>&nbsp;         */
<i>3344</i>&nbsp;        public void setSelectionPaths(TreePath[] paths) {}
<i>3345</i>&nbsp;
<i>3346</i>&nbsp;        /**
<i>3347</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3348</i>&nbsp;         * does not allow a selection.
<i>3349</i>&nbsp;         *
<i>3350</i>&nbsp;         * @param paths the paths to add to the selection; this is ignored
<i>3351</i>&nbsp;         */
<i>3352</i>&nbsp;        public void addSelectionPaths(TreePath[] paths) {}
<i>3353</i>&nbsp;
<i>3354</i>&nbsp;        /**
<i>3355</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3356</i>&nbsp;         * does not allow a selection.
<i>3357</i>&nbsp;         *
<i>3358</i>&nbsp;         * @param paths the paths to remove; this is ignored
<i>3359</i>&nbsp;         */
<i>3360</i>&nbsp;        public void removeSelectionPaths(TreePath[] paths) {}
<i>3361</i>&nbsp;
<i>3362</i>&nbsp;        /**
<i>3363</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3364</i>&nbsp;         * does not allow a selection.
<i>3365</i>&nbsp;         *
<i>3366</i>&nbsp;         * @param mode the selection mode; this is ignored
<i>3367</i>&nbsp;         * @since 1.7
<i>3368</i>&nbsp;         */
<i>3369</i>&nbsp;        public void setSelectionMode(int mode) {
<i>3370</i>&nbsp;        }
<i>3371</i>&nbsp;
<i>3372</i>&nbsp;        /**
<i>3373</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3374</i>&nbsp;         * does not allow a selection.
<i>3375</i>&nbsp;         *
<i>3376</i>&nbsp;         * @param mapper the {@code RowMapper} instance; this is ignored
<b class="nc"><i>3377</i>&nbsp;         * @since 1.7</b>
<i>3378</i>&nbsp;         */
<i>3379</i>&nbsp;        public void setRowMapper(RowMapper mapper) {
<i>3380</i>&nbsp;        }
<i>3381</i>&nbsp;
<i>3382</i>&nbsp;        /**
<i>3383</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3384</i>&nbsp;         * does not allow a selection.
<i>3385</i>&nbsp;         *
<i>3386</i>&nbsp;         * @param listener the listener to add; this is ignored
<i>3387</i>&nbsp;         * @since 1.7
<i>3388</i>&nbsp;         */
<i>3389</i>&nbsp;        public void addTreeSelectionListener(TreeSelectionListener listener) {
<b class="nc"><i>3390</i>&nbsp;        }</b>
<b class="nc"><i>3391</i>&nbsp;</b>
<i>3392</i>&nbsp;        /**
<i>3393</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3394</i>&nbsp;         * does not allow a selection.
<i>3395</i>&nbsp;         *
<i>3396</i>&nbsp;         * @param listener the listener to remove; this is ignored
<i>3397</i>&nbsp;         * @since 1.7
<i>3398</i>&nbsp;         */
<i>3399</i>&nbsp;        public void removeTreeSelectionListener(
<i>3400</i>&nbsp;                TreeSelectionListener listener) {
<i>3401</i>&nbsp;        }
<i>3402</i>&nbsp;
<i>3403</i>&nbsp;        /**
<i>3404</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<i>3405</i>&nbsp;         * does not allow a selection.
<i>3406</i>&nbsp;         *
<b class="nc"><i>3407</i>&nbsp;         * @param listener the listener to add; this is ignored</b>
<b class="nc"><i>3408</i>&nbsp;         * @since 1.7</b>
<b class="nc"><i>3409</i>&nbsp;         */</b>
<i>3410</i>&nbsp;        public void addPropertyChangeListener(
<b class="nc"><i>3411</i>&nbsp;                                PropertyChangeListener listener) {</b>
<b class="nc"><i>3412</i>&nbsp;        }</b>
<i>3413</i>&nbsp;
<b class="nc"><i>3414</i>&nbsp;        /**</b>
<i>3415</i>&nbsp;         * This is overriden to do nothing; {@code EmptySelectionModel}
<b class="nc"><i>3416</i>&nbsp;         * does not allow a selection.</b>
<b class="nc"><i>3417</i>&nbsp;         *</b>
<i>3418</i>&nbsp;         * @param listener the listener to remove; this is ignored
<b class="nc"><i>3419</i>&nbsp;         * @since 1.7</b>
<b class="nc"><i>3420</i>&nbsp;         */</b>
<b class="nc"><i>3421</i>&nbsp;        public void removePropertyChangeListener(</b>
<b class="nc"><i>3422</i>&nbsp;                                PropertyChangeListener listener) {</b>
<i>3423</i>&nbsp;        }
<b class="nc"><i>3424</i>&nbsp;    }</b>
<b class="nc"><i>3425</i>&nbsp;</b>
<b class="nc"><i>3426</i>&nbsp;</b>
<b class="nc"><i>3427</i>&nbsp;    /**</b>
<b class="nc"><i>3428</i>&nbsp;     * Handles creating a new &lt;code&gt;TreeSelectionEvent&lt;/code&gt; with the</b>
<i>3429</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt; as the
<i>3430</i>&nbsp;     * source and passing it off to all the listeners.
<i>3431</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>3432</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;</b>
<b class="nc"><i>3433</i>&nbsp;     * Serialized objects of this class will not be compatible with</b>
<i>3434</i>&nbsp;     * future Swing releases. The current serialization support is
<i>3435</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<b class="nc"><i>3436</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage</b>
<i>3437</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>3438</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>3439</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<i>3440</i>&nbsp;     */
<i>3441</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>3442</i>&nbsp;    protected class TreeSelectionRedirector implements Serializable,
<i>3443</i>&nbsp;                    TreeSelectionListener
<i>3444</i>&nbsp;    {
<i>3445</i>&nbsp;        /**
<i>3446</i>&nbsp;         * Invoked by the &lt;code&gt;TreeSelectionModel&lt;/code&gt; when the
<i>3447</i>&nbsp;         * selection changes.
<i>3448</i>&nbsp;         *
<i>3449</i>&nbsp;         * @param e the &lt;code&gt;TreeSelectionEvent&lt;/code&gt; generated by the
<i>3450</i>&nbsp;         *              &lt;code&gt;TreeSelectionModel&lt;/code&gt;
<i>3451</i>&nbsp;         */
<i>3452</i>&nbsp;        public void valueChanged(TreeSelectionEvent e) {
<i>3453</i>&nbsp;            TreeSelectionEvent       newE;
<i>3454</i>&nbsp;
<b class="nc"><i>3455</i>&nbsp;            newE = (TreeSelectionEvent)e.cloneWithSource(JTree.this);</b>
<i>3456</i>&nbsp;            fireValueChanged(newE);
<b class="nc"><i>3457</i>&nbsp;        }</b>
<b class="nc"><i>3458</i>&nbsp;    } // End of class JTree.TreeSelectionRedirector</b>
<i>3459</i>&nbsp;
<b class="nc"><i>3460</i>&nbsp;    //</b>
<b class="nc"><i>3461</i>&nbsp;    // Scrollable interface</b>
<b class="nc"><i>3462</i>&nbsp;    //</b>
<b class="nc"><i>3463</i>&nbsp;</b>
<i>3464</i>&nbsp;    /**
<b class="nc"><i>3465</i>&nbsp;     * Returns the preferred display size of a &lt;code&gt;JTree&lt;/code&gt;. The height is</b>
<i>3466</i>&nbsp;     * determined from &lt;code&gt;getVisibleRowCount&lt;/code&gt; and the width
<b class="nc"><i>3467</i>&nbsp;     * is the current preferred width.</b>
<i>3468</i>&nbsp;     *
<b class="nc"><i>3469</i>&nbsp;     * @return a &lt;code&gt;Dimension&lt;/code&gt; object containing the preferred size</b>
<b class="nc"><i>3470</i>&nbsp;     */</b>
<b class="nc"><i>3471</i>&nbsp;    @BeanProperty(bound = false)</b>
<b class="nc"><i>3472</i>&nbsp;    public Dimension getPreferredScrollableViewportSize() {</b>
<i>3473</i>&nbsp;        int                 width = getPreferredSize().width;
<i>3474</i>&nbsp;        int                 visRows = getVisibleRowCount();
<i>3475</i>&nbsp;        int                 height = -1;
<b class="nc"><i>3476</i>&nbsp;</b>
<i>3477</i>&nbsp;        if(isFixedRowHeight())
<i>3478</i>&nbsp;            height = visRows * getRowHeight();
<b class="nc"><i>3479</i>&nbsp;        else {</b>
<i>3480</i>&nbsp;            TreeUI          ui = getUI();
<b class="nc"><i>3481</i>&nbsp;</b>
<i>3482</i>&nbsp;            if (ui != null &amp;&amp; visRows &gt; 0) {
<i>3483</i>&nbsp;                int rc = ui.getRowCount(this);
<i>3484</i>&nbsp;
<i>3485</i>&nbsp;                if (rc &gt;= visRows) {
<i>3486</i>&nbsp;                    Rectangle bounds = getRowBounds(visRows - 1);
<i>3487</i>&nbsp;                    if (bounds != null) {
<i>3488</i>&nbsp;                        height = bounds.y + bounds.height;
<i>3489</i>&nbsp;                    }
<i>3490</i>&nbsp;                }
<i>3491</i>&nbsp;                else if (rc &gt; 0) {
<i>3492</i>&nbsp;                    Rectangle bounds = getRowBounds(0);
<i>3493</i>&nbsp;                    if (bounds != null) {
<i>3494</i>&nbsp;                        height = bounds.height * visRows;
<i>3495</i>&nbsp;                    }
<i>3496</i>&nbsp;                }
<i>3497</i>&nbsp;            }
<i>3498</i>&nbsp;            if (height == -1) {
<b class="nc"><i>3499</i>&nbsp;                height = 16 * visRows;</b>
<i>3500</i>&nbsp;            }
<i>3501</i>&nbsp;        }
<i>3502</i>&nbsp;        return new Dimension(width, height);
<i>3503</i>&nbsp;    }
<i>3504</i>&nbsp;
<i>3505</i>&nbsp;    /**
<i>3506</i>&nbsp;     * Returns the amount to increment when scrolling. The amount is
<i>3507</i>&nbsp;     * the height of the first displayed row that isn&#39;t completely in view
<i>3508</i>&nbsp;     * or, if it is totally displayed, the height of the next row in the
<i>3509</i>&nbsp;     * scrolling direction.
<i>3510</i>&nbsp;     *
<i>3511</i>&nbsp;     * @param visibleRect the view area visible within the viewport
<i>3512</i>&nbsp;     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt;
<b class="nc"><i>3513</i>&nbsp;     *          or &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;</b>
<b class="nc"><i>3514</i>&nbsp;     * @param direction less than zero to scroll up/left,</b>
<b class="nc"><i>3515</i>&nbsp;     *          greater than zero for down/right</b>
<i>3516</i>&nbsp;     * @return the &quot;unit&quot; increment for scrolling in the specified direction
<b class="nc"><i>3517</i>&nbsp;     * @see JScrollBar#setUnitIncrement(int)</b>
<i>3518</i>&nbsp;     */
<i>3519</i>&nbsp;    public int getScrollableUnitIncrement(Rectangle visibleRect,
<i>3520</i>&nbsp;                                          int orientation, int direction) {
<i>3521</i>&nbsp;        if(orientation == SwingConstants.VERTICAL) {
<i>3522</i>&nbsp;            Rectangle       rowBounds;
<i>3523</i>&nbsp;            int             firstIndex = getClosestRowForLocation
<i>3524</i>&nbsp;                                         (0, visibleRect.y);
<i>3525</i>&nbsp;
<i>3526</i>&nbsp;            if(firstIndex != -1) {
<i>3527</i>&nbsp;                rowBounds = getRowBounds(firstIndex);
<i>3528</i>&nbsp;                if(rowBounds.y != visibleRect.y) {
<i>3529</i>&nbsp;                    if(direction &lt; 0) {
<b class="nc"><i>3530</i>&nbsp;                        // UP</b>
<b class="nc"><i>3531</i>&nbsp;                        return Math.max(0, (visibleRect.y - rowBounds.y));</b>
<b class="nc"><i>3532</i>&nbsp;                    }</b>
<i>3533</i>&nbsp;                    return (rowBounds.y + rowBounds.height - visibleRect.y);
<b class="nc"><i>3534</i>&nbsp;                }</b>
<i>3535</i>&nbsp;                if(direction &lt; 0) { // UP
<i>3536</i>&nbsp;                    if(firstIndex != 0) {
<i>3537</i>&nbsp;                        rowBounds = getRowBounds(firstIndex - 1);
<i>3538</i>&nbsp;                        return rowBounds.height;
<i>3539</i>&nbsp;                    }
<i>3540</i>&nbsp;                }
<i>3541</i>&nbsp;                else {
<i>3542</i>&nbsp;                    return rowBounds.height;
<i>3543</i>&nbsp;                }
<i>3544</i>&nbsp;            }
<i>3545</i>&nbsp;            return 0;
<i>3546</i>&nbsp;        }
<b class="nc"><i>3547</i>&nbsp;        return 4;</b>
<i>3548</i>&nbsp;    }
<i>3549</i>&nbsp;
<b class="nc"><i>3550</i>&nbsp;</b>
<i>3551</i>&nbsp;    /**
<b class="nc"><i>3552</i>&nbsp;     * Returns the amount for a block increment, which is the height or</b>
<b class="nc"><i>3553</i>&nbsp;     * width of &lt;code&gt;visibleRect&lt;/code&gt;, based on &lt;code&gt;orientation&lt;/code&gt;.</b>
<i>3554</i>&nbsp;     *
<i>3555</i>&nbsp;     * @param visibleRect the view area visible within the viewport
<b class="nc"><i>3556</i>&nbsp;     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt;</b>
<i>3557</i>&nbsp;     *          or &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;
<i>3558</i>&nbsp;     * @param direction less than zero to scroll up/left,
<i>3559</i>&nbsp;     *          greater than zero for down/right.
<b class="nc"><i>3560</i>&nbsp;     * @return the &quot;block&quot; increment for scrolling in the specified direction</b>
<b class="nc"><i>3561</i>&nbsp;     * @see JScrollBar#setBlockIncrement(int)</b>
<b class="nc"><i>3562</i>&nbsp;     */</b>
<i>3563</i>&nbsp;    public int getScrollableBlockIncrement(Rectangle visibleRect,
<i>3564</i>&nbsp;                                           int orientation, int direction) {
<b class="nc"><i>3565</i>&nbsp;        return (orientation == SwingConstants.VERTICAL) ? visibleRect.height :</b>
<b class="nc"><i>3566</i>&nbsp;            visibleRect.width;</b>
<i>3567</i>&nbsp;    }
<i>3568</i>&nbsp;
<b class="nc"><i>3569</i>&nbsp;    /**</b>
<b class="nc"><i>3570</i>&nbsp;     * Returns false to indicate that the width of the viewport does not</b>
<b class="nc"><i>3571</i>&nbsp;     * determine the width of the table, unless the preferred width of</b>
<i>3572</i>&nbsp;     * the tree is smaller than the viewports width.  In other words:
<b class="nc"><i>3573</i>&nbsp;     * ensure that the tree is never smaller than its viewport.</b>
<b class="nc"><i>3574</i>&nbsp;     *</b>
<i>3575</i>&nbsp;     * @return whether the tree should track the width of the viewport
<i>3576</i>&nbsp;     * @see Scrollable#getScrollableTracksViewportWidth
<b class="nc"><i>3577</i>&nbsp;     */</b>
<b class="nc"><i>3578</i>&nbsp;    @BeanProperty(bound = false)</b>
<b class="nc"><i>3579</i>&nbsp;    public boolean getScrollableTracksViewportWidth() {</b>
<b class="nc"><i>3580</i>&nbsp;        Container parent = SwingUtilities.getUnwrappedParent(this);</b>
<b class="nc"><i>3581</i>&nbsp;        if (parent instanceof JViewport) {</b>
<b class="nc"><i>3582</i>&nbsp;            return parent.getWidth() &gt; getPreferredSize().width;</b>
<i>3583</i>&nbsp;        }
<i>3584</i>&nbsp;        return false;
<i>3585</i>&nbsp;    }
<i>3586</i>&nbsp;
<i>3587</i>&nbsp;    /**
<b class="nc"><i>3588</i>&nbsp;     * Returns false to indicate that the height of the viewport does not</b>
<b class="nc"><i>3589</i>&nbsp;     * determine the height of the table, unless the preferred height</b>
<b class="nc"><i>3590</i>&nbsp;     * of the tree is smaller than the viewports height.  In other words:</b>
<i>3591</i>&nbsp;     * ensure that the tree is never smaller than its viewport.
<i>3592</i>&nbsp;     *
<b class="nc"><i>3593</i>&nbsp;     * @return whether the tree should track the height of the viewport</b>
<i>3594</i>&nbsp;     * @see Scrollable#getScrollableTracksViewportHeight
<b class="nc"><i>3595</i>&nbsp;     */</b>
<i>3596</i>&nbsp;    @BeanProperty(bound = false)
<b class="nc"><i>3597</i>&nbsp;    public boolean getScrollableTracksViewportHeight() {</b>
<i>3598</i>&nbsp;        Container parent = SwingUtilities.getUnwrappedParent(this);
<b class="nc"><i>3599</i>&nbsp;        if (parent instanceof JViewport) {</b>
<i>3600</i>&nbsp;            return parent.getHeight() &gt; getPreferredSize().height;
<b class="nc"><i>3601</i>&nbsp;        }</b>
<i>3602</i>&nbsp;        return false;
<b class="nc"><i>3603</i>&nbsp;    }</b>
<b class="nc"><i>3604</i>&nbsp;</b>
<b class="nc"><i>3605</i>&nbsp;    /**</b>
<b class="nc"><i>3606</i>&nbsp;     * Sets the expanded state of this &lt;code&gt;JTree&lt;/code&gt;.</b>
<b class="nc"><i>3607</i>&nbsp;     * If &lt;code&gt;state&lt;/code&gt; is</b>
<i>3608</i>&nbsp;     * true, all parents of &lt;code&gt;path&lt;/code&gt; and path are marked as
<b class="nc"><i>3609</i>&nbsp;     * expanded. If &lt;code&gt;state&lt;/code&gt; is false, all parents of</b>
<i>3610</i>&nbsp;     * &lt;code&gt;path&lt;/code&gt; are marked EXPANDED, but &lt;code&gt;path&lt;/code&gt; itself
<b class="nc"><i>3611</i>&nbsp;     * is marked collapsed.&lt;p&gt;</b>
<b class="nc"><i>3612</i>&nbsp;     * This will fail if a &lt;code&gt;TreeWillExpandListener&lt;/code&gt; vetos it.</b>
<b class="nc"><i>3613</i>&nbsp;     *</b>
<i>3614</i>&nbsp;     * @param path a {@code TreePath} identifying a node
<i>3615</i>&nbsp;     * @param state if {@code true}, all parents of @{code path} and path are marked as expanded.
<b class="nc"><i>3616</i>&nbsp;     *              Otherwise, all parents of {@code path} are marked EXPANDED,</b>
<i>3617</i>&nbsp;     *              but {@code path} itself is marked collapsed.
<i>3618</i>&nbsp;     */
<b class="nc"><i>3619</i>&nbsp;    protected void setExpandedState(TreePath path, boolean state) {</b>
<i>3620</i>&nbsp;        if(path != null) {
<b class="nc"><i>3621</i>&nbsp;            // Make sure all parents of path are expanded.</b>
<i>3622</i>&nbsp;            Stack&lt;TreePath&gt; stack;
<b class="nc"><i>3623</i>&nbsp;            TreePath parentPath = path.getParentPath();</b>
<i>3624</i>&nbsp;
<b class="nc"><i>3625</i>&nbsp;            if (expandedStack.size() == 0) {</b>
<i>3626</i>&nbsp;                stack = new Stack&lt;TreePath&gt;();
<b class="nc"><i>3627</i>&nbsp;            }</b>
<b class="nc"><i>3628</i>&nbsp;            else {</b>
<b class="nc"><i>3629</i>&nbsp;                stack = expandedStack.pop();</b>
<b class="nc"><i>3630</i>&nbsp;            }</b>
<b class="nc"><i>3631</i>&nbsp;</b>
<b class="nc"><i>3632</i>&nbsp;            try {</b>
<i>3633</i>&nbsp;                while(parentPath != null) {
<i>3634</i>&nbsp;                    if(isExpanded(parentPath)) {
<i>3635</i>&nbsp;                        parentPath = null;
<i>3636</i>&nbsp;                    }
<i>3637</i>&nbsp;                    else {
<i>3638</i>&nbsp;                        stack.push(parentPath);
<i>3639</i>&nbsp;                        parentPath = parentPath.getParentPath();
<i>3640</i>&nbsp;                    }
<i>3641</i>&nbsp;                }
<i>3642</i>&nbsp;                for(int counter = stack.size() - 1; counter &gt;= 0; counter--) {
<i>3643</i>&nbsp;                    parentPath = stack.pop();
<i>3644</i>&nbsp;                    if(!isExpanded(parentPath)) {
<i>3645</i>&nbsp;                        try {
<i>3646</i>&nbsp;                            fireTreeWillExpand(parentPath);
<b class="nc"><i>3647</i>&nbsp;                        } catch (ExpandVetoException eve) {</b>
<b class="nc"><i>3648</i>&nbsp;                            // Expand vetoed!</b>
<i>3649</i>&nbsp;                            return;
<b class="nc"><i>3650</i>&nbsp;                        }</b>
<b class="nc"><i>3651</i>&nbsp;                        expandedState.put(parentPath, Boolean.TRUE);</b>
<i>3652</i>&nbsp;                        fireTreeExpanded(parentPath);
<b class="nc"><i>3653</i>&nbsp;                        if (accessibleContext != null) {</b>
<b class="nc"><i>3654</i>&nbsp;                            ((AccessibleJTree)accessibleContext).</b>
<b class="nc"><i>3655</i>&nbsp;                                              fireVisibleDataPropertyChange();</b>
<b class="nc"><i>3656</i>&nbsp;                        }</b>
<b class="nc"><i>3657</i>&nbsp;                    }</b>
<b class="nc"><i>3658</i>&nbsp;                }</b>
<i>3659</i>&nbsp;            }
<i>3660</i>&nbsp;            finally {
<i>3661</i>&nbsp;                if (expandedStack.size() &lt; TEMP_STACK_SIZE) {
<i>3662</i>&nbsp;                    stack.removeAllElements();
<i>3663</i>&nbsp;                    expandedStack.push(stack);
<i>3664</i>&nbsp;                }
<i>3665</i>&nbsp;            }
<i>3666</i>&nbsp;            if(!state) {
<i>3667</i>&nbsp;                // collapse last path.
<i>3668</i>&nbsp;                Object          cValue = expandedState.get(path);
<i>3669</i>&nbsp;
<i>3670</i>&nbsp;                if(cValue != null &amp;&amp; ((Boolean)cValue).booleanValue()) {
<i>3671</i>&nbsp;                    try {
<i>3672</i>&nbsp;                        fireTreeWillCollapse(path);
<i>3673</i>&nbsp;                    }
<i>3674</i>&nbsp;                    catch (ExpandVetoException eve) {
<b class="nc"><i>3675</i>&nbsp;                        return;</b>
<b class="nc"><i>3676</i>&nbsp;                    }</b>
<b class="nc"><i>3677</i>&nbsp;                    expandedState.put(path, Boolean.FALSE);</b>
<b class="nc"><i>3678</i>&nbsp;                    fireTreeCollapsed(path);</b>
<i>3679</i>&nbsp;                    if (removeDescendantSelectedPaths(path, false) &amp;&amp;
<b class="nc"><i>3680</i>&nbsp;                        !isPathSelected(path)) {</b>
<b class="nc"><i>3681</i>&nbsp;                        // A descendant was selected, select the parent.</b>
<b class="nc"><i>3682</i>&nbsp;                        addSelectionPath(path);</b>
<i>3683</i>&nbsp;                    }
<i>3684</i>&nbsp;                    if (accessibleContext != null) {
<b class="nc"><i>3685</i>&nbsp;                        ((AccessibleJTree)accessibleContext).</b>
<i>3686</i>&nbsp;                                    fireVisibleDataPropertyChange();
<i>3687</i>&nbsp;                    }
<i>3688</i>&nbsp;                }
<i>3689</i>&nbsp;            }
<i>3690</i>&nbsp;            else {
<i>3691</i>&nbsp;                // Expand last path.
<i>3692</i>&nbsp;                Object          cValue = expandedState.get(path);
<i>3693</i>&nbsp;
<b class="nc"><i>3694</i>&nbsp;                if(cValue == null || !((Boolean)cValue).booleanValue()) {</b>
<i>3695</i>&nbsp;                    try {
<i>3696</i>&nbsp;                        fireTreeWillExpand(path);
<i>3697</i>&nbsp;                    }
<i>3698</i>&nbsp;                    catch (ExpandVetoException eve) {
<i>3699</i>&nbsp;                        return;
<i>3700</i>&nbsp;                    }
<i>3701</i>&nbsp;                    expandedState.put(path, Boolean.TRUE);
<i>3702</i>&nbsp;                    fireTreeExpanded(path);
<i>3703</i>&nbsp;                    if (accessibleContext != null) {
<i>3704</i>&nbsp;                        ((AccessibleJTree)accessibleContext).
<i>3705</i>&nbsp;                                          fireVisibleDataPropertyChange();
<i>3706</i>&nbsp;                    }
<b class="nc"><i>3707</i>&nbsp;                }</b>
<i>3708</i>&nbsp;            }
<i>3709</i>&nbsp;        }
<i>3710</i>&nbsp;    }
<i>3711</i>&nbsp;
<i>3712</i>&nbsp;    /**
<i>3713</i>&nbsp;     * Returns an {@code Enumeration} of {@code TreePaths}
<i>3714</i>&nbsp;     * that have been expanded that
<i>3715</i>&nbsp;     * are descendants of {@code parent}.
<i>3716</i>&nbsp;     *
<i>3717</i>&nbsp;     * @param parent a path
<i>3718</i>&nbsp;     * @return the {@code Enumeration} of {@code TreePaths}
<i>3719</i>&nbsp;     */
<b class="nc"><i>3720</i>&nbsp;    protected Enumeration&lt;TreePath&gt;</b>
<i>3721</i>&nbsp;        getDescendantToggledPaths(TreePath parent)
<b class="nc"><i>3722</i>&nbsp;    {</b>
<b class="nc"><i>3723</i>&nbsp;        if(parent == null)</b>
<b class="nc"><i>3724</i>&nbsp;            return null;</b>
<i>3725</i>&nbsp;
<b class="nc"><i>3726</i>&nbsp;        Vector&lt;TreePath&gt; descendants = new Vector&lt;TreePath&gt;();</b>
<i>3727</i>&nbsp;        Enumeration&lt;TreePath&gt; nodes = expandedState.keys();
<i>3728</i>&nbsp;
<i>3729</i>&nbsp;        while(nodes.hasMoreElements()) {
<i>3730</i>&nbsp;            TreePath path = nodes.nextElement();
<i>3731</i>&nbsp;            if(parent.isDescendant(path))
<i>3732</i>&nbsp;                descendants.addElement(path);
<i>3733</i>&nbsp;        }
<i>3734</i>&nbsp;        return descendants.elements();
<b class="nc"><i>3735</i>&nbsp;    }</b>
<b class="nc"><i>3736</i>&nbsp;</b>
<i>3737</i>&nbsp;    /**
<i>3738</i>&nbsp;     * Removes any descendants of the &lt;code&gt;TreePaths&lt;/code&gt; in
<b class="nc"><i>3739</i>&nbsp;     * &lt;code&gt;toRemove&lt;/code&gt;</b>
<b class="nc"><i>3740</i>&nbsp;     * that have been expanded.</b>
<i>3741</i>&nbsp;     *
<b class="nc"><i>3742</i>&nbsp;     * @param toRemove an enumeration of the paths to remove; a value of</b>
<b class="nc"><i>3743</i>&nbsp;     *        {@code null} is ignored</b>
<b class="nc"><i>3744</i>&nbsp;     * @throws ClassCastException if {@code toRemove} contains an</b>
<b class="nc"><i>3745</i>&nbsp;     *         element that is not a {@code TreePath}; {@code null}</b>
<b class="nc"><i>3746</i>&nbsp;     *         values are ignored</b>
<i>3747</i>&nbsp;     */
<b class="nc"><i>3748</i>&nbsp;     protected void</b>
<i>3749</i>&nbsp;         removeDescendantToggledPaths(Enumeration&lt;TreePath&gt; toRemove)
<b class="nc"><i>3750</i>&nbsp;    {</b>
<b class="nc"><i>3751</i>&nbsp;         if(toRemove != null) {</b>
<i>3752</i>&nbsp;             while(toRemove.hasMoreElements()) {
<b class="nc"><i>3753</i>&nbsp;                 Enumeration&lt;?&gt; descendants = getDescendantToggledPaths</b>
<i>3754</i>&nbsp;                         (toRemove.nextElement());
<b class="nc"><i>3755</i>&nbsp;</b>
<i>3756</i>&nbsp;                 if(descendants != null) {
<i>3757</i>&nbsp;                     while(descendants.hasMoreElements()) {
<i>3758</i>&nbsp;                         expandedState.remove(descendants.nextElement());
<i>3759</i>&nbsp;                     }
<i>3760</i>&nbsp;                 }
<i>3761</i>&nbsp;             }
<i>3762</i>&nbsp;         }
<b class="nc"><i>3763</i>&nbsp;     }</b>
<b class="nc"><i>3764</i>&nbsp;</b>
<b class="nc"><i>3765</i>&nbsp;     /**</b>
<i>3766</i>&nbsp;      * Clears the cache of toggled tree paths. This does NOT send out
<b class="nc"><i>3767</i>&nbsp;      * any &lt;code&gt;TreeExpansionListener&lt;/code&gt; events.</b>
<i>3768</i>&nbsp;      */
<b class="nc"><i>3769</i>&nbsp;     protected void clearToggledPaths() {</b>
<b class="nc"><i>3770</i>&nbsp;         expandedState.clear();</b>
<i>3771</i>&nbsp;     }
<i>3772</i>&nbsp;
<b class="nc"><i>3773</i>&nbsp;     /**</b>
<b class="nc"><i>3774</i>&nbsp;      * Creates and returns an instance of &lt;code&gt;TreeModelHandler&lt;/code&gt;.</b>
<i>3775</i>&nbsp;      * The returned
<i>3776</i>&nbsp;      * object is responsible for updating the expanded state when the
<i>3777</i>&nbsp;      * &lt;code&gt;TreeModel&lt;/code&gt; changes.
<i>3778</i>&nbsp;      * &lt;p&gt;
<i>3779</i>&nbsp;      * For more information on what expanded state means, see the
<i>3780</i>&nbsp;      * {@link JTree JTree description} above.
<i>3781</i>&nbsp;      *
<i>3782</i>&nbsp;      * @return the instance of {@code TreeModelHandler}
<i>3783</i>&nbsp;      */
<b class="nc"><i>3784</i>&nbsp;     protected TreeModelListener createTreeModelListener() {</b>
<i>3785</i>&nbsp;         return new TreeModelHandler();
<i>3786</i>&nbsp;     }
<i>3787</i>&nbsp;
<i>3788</i>&nbsp;    /**
<i>3789</i>&nbsp;     * Removes any paths in the selection that are descendants of
<b class="nc"><i>3790</i>&nbsp;     * &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;includePath&lt;/code&gt; is true and</b>
<i>3791</i>&nbsp;     * &lt;code&gt;path&lt;/code&gt; is selected, it will be removed from the selection.
<i>3792</i>&nbsp;     *
<i>3793</i>&nbsp;     * @param path a path
<i>3794</i>&nbsp;     * @param includePath is {@code true} and {@code path} is selected,
<i>3795</i>&nbsp;     *                    it will be removed from the selection.
<i>3796</i>&nbsp;     * @return true if a descendant was selected
<b class="nc"><i>3797</i>&nbsp;     * @since 1.3</b>
<i>3798</i>&nbsp;     */
<b class="nc"><i>3799</i>&nbsp;    protected boolean removeDescendantSelectedPaths(TreePath path,</b>
<i>3800</i>&nbsp;                                                    boolean includePath) {
<i>3801</i>&nbsp;        TreePath[]    toRemove = getDescendantSelectedPaths(path, includePath);
<b class="nc"><i>3802</i>&nbsp;</b>
<i>3803</i>&nbsp;        if (toRemove != null) {
<b class="nc"><i>3804</i>&nbsp;            getSelectionModel().removeSelectionPaths(toRemove);</b>
<b class="nc"><i>3805</i>&nbsp;            return true;</b>
<b class="nc"><i>3806</i>&nbsp;        }</b>
<b class="nc"><i>3807</i>&nbsp;        return false;</b>
<i>3808</i>&nbsp;    }
<b class="nc"><i>3809</i>&nbsp;</b>
<i>3810</i>&nbsp;    /**
<b class="nc"><i>3811</i>&nbsp;     * Returns an array of paths in the selection that are descendants of</b>
<b class="nc"><i>3812</i>&nbsp;     * &lt;code&gt;path&lt;/code&gt;. The returned array may contain &lt;code&gt;null&lt;/code&gt;s.</b>
<b class="nc"><i>3813</i>&nbsp;     */</b>
<b class="nc"><i>3814</i>&nbsp;    private TreePath[] getDescendantSelectedPaths(TreePath path,</b>
<i>3815</i>&nbsp;                                                  boolean includePath) {
<b class="nc"><i>3816</i>&nbsp;        TreeSelectionModel   sm = getSelectionModel();</b>
<b class="nc"><i>3817</i>&nbsp;        TreePath[]           selPaths = (sm != null) ? sm.getSelectionPaths() :</b>
<b class="nc"><i>3818</i>&nbsp;                                        null;</b>
<b class="nc"><i>3819</i>&nbsp;</b>
<i>3820</i>&nbsp;        if(selPaths != null) {
<b class="nc"><i>3821</i>&nbsp;            boolean        shouldRemove = false;</b>
<b class="nc"><i>3822</i>&nbsp;</b>
<b class="nc"><i>3823</i>&nbsp;            for(int counter = selPaths.length - 1; counter &gt;= 0; counter--) {</b>
<i>3824</i>&nbsp;                if(selPaths[counter] != null &amp;&amp;
<b class="nc"><i>3825</i>&nbsp;                   path.isDescendant(selPaths[counter]) &amp;&amp;</b>
<i>3826</i>&nbsp;                   (!path.equals(selPaths[counter]) || includePath))
<i>3827</i>&nbsp;                    shouldRemove = true;
<b class="nc"><i>3828</i>&nbsp;                else</b>
<i>3829</i>&nbsp;                    selPaths[counter] = null;
<i>3830</i>&nbsp;            }
<i>3831</i>&nbsp;            if(!shouldRemove) {
<b class="nc"><i>3832</i>&nbsp;                selPaths = null;</b>
<i>3833</i>&nbsp;            }
<i>3834</i>&nbsp;            return selPaths;
<b class="nc"><i>3835</i>&nbsp;        }</b>
<b class="nc"><i>3836</i>&nbsp;        return null;</b>
<i>3837</i>&nbsp;    }
<b class="nc"><i>3838</i>&nbsp;</b>
<i>3839</i>&nbsp;    /**
<i>3840</i>&nbsp;     * Removes any paths from the selection model that are descendants of
<i>3841</i>&nbsp;     * the nodes identified by in &lt;code&gt;e&lt;/code&gt;.
<b class="nc"><i>3842</i>&nbsp;     */</b>
<b class="nc"><i>3843</i>&nbsp;    void removeDescendantSelectedPaths(TreeModelEvent e) {</b>
<i>3844</i>&nbsp;        TreePath            pPath = SwingUtilities2.getTreePath(e, getModel());
<b class="nc"><i>3845</i>&nbsp;        Object[]            oldChildren = e.getChildren();</b>
<b class="nc"><i>3846</i>&nbsp;        TreeSelectionModel  sm = getSelectionModel();</b>
<b class="nc"><i>3847</i>&nbsp;</b>
<b class="nc"><i>3848</i>&nbsp;        if (sm != null &amp;&amp; pPath != null &amp;&amp; oldChildren != null &amp;&amp;</b>
<i>3849</i>&nbsp;            oldChildren.length &gt; 0) {
<b class="nc"><i>3850</i>&nbsp;            for (int counter = oldChildren.length - 1; counter &gt;= 0;</b>
<b class="nc"><i>3851</i>&nbsp;                 counter--) {</b>
<i>3852</i>&nbsp;                // Might be better to call getDescendantSelectedPaths
<b class="nc"><i>3853</i>&nbsp;                // numerous times, then push to the model.</b>
<i>3854</i>&nbsp;                removeDescendantSelectedPaths(pPath.pathByAddingChild
<b class="nc"><i>3855</i>&nbsp;                                              (oldChildren[counter]), true);</b>
<b class="nc"><i>3856</i>&nbsp;            }</b>
<i>3857</i>&nbsp;        }
<b class="nc"><i>3858</i>&nbsp;    }</b>
<i>3859</i>&nbsp;
<i>3860</i>&nbsp;
<i>3861</i>&nbsp;     /**
<i>3862</i>&nbsp;      * Listens to the model and updates the &lt;code&gt;expandedState&lt;/code&gt;
<i>3863</i>&nbsp;      * accordingly when nodes are removed, or changed.
<i>3864</i>&nbsp;      */
<i>3865</i>&nbsp;    protected class TreeModelHandler implements TreeModelListener {
<i>3866</i>&nbsp;        public void treeNodesChanged(TreeModelEvent e) { }
<i>3867</i>&nbsp;
<i>3868</i>&nbsp;        public void treeNodesInserted(TreeModelEvent e) { }
<i>3869</i>&nbsp;
<i>3870</i>&nbsp;        public void treeStructureChanged(TreeModelEvent e) {
<i>3871</i>&nbsp;            if(e == null)
<i>3872</i>&nbsp;                return;
<i>3873</i>&nbsp;
<i>3874</i>&nbsp;            // NOTE: If I change this to NOT remove the descendants
<i>3875</i>&nbsp;            // and update BasicTreeUIs treeStructureChanged method
<i>3876</i>&nbsp;            // to update descendants in response to a treeStructureChanged
<i>3877</i>&nbsp;            // event, all the children of the event won&#39;t collapse!
<i>3878</i>&nbsp;            TreePath            parent = SwingUtilities2.getTreePath(e, getModel());
<i>3879</i>&nbsp;
<i>3880</i>&nbsp;            if(parent == null)
<i>3881</i>&nbsp;                return;
<i>3882</i>&nbsp;
<i>3883</i>&nbsp;            if (parent.getPathCount() == 1) {
<i>3884</i>&nbsp;                // New root, remove everything!
<i>3885</i>&nbsp;                clearToggledPaths();
<i>3886</i>&nbsp;
<i>3887</i>&nbsp;              Object treeRoot = treeModel.getRoot();
<i>3888</i>&nbsp;
<i>3889</i>&nbsp;              if(treeRoot != null &amp;&amp;
<i>3890</i>&nbsp;                !treeModel.isLeaf(treeRoot)) {
<i>3891</i>&nbsp;                    // Mark the root as expanded, if it isn&#39;t a leaf.
<i>3892</i>&nbsp;                    expandedState.put(parent, Boolean.TRUE);
<i>3893</i>&nbsp;                }
<i>3894</i>&nbsp;            }
<i>3895</i>&nbsp;            else if(expandedState.get(parent) != null) {
<i>3896</i>&nbsp;                Vector&lt;TreePath&gt;    toRemove = new Vector&lt;TreePath&gt;(1);
<i>3897</i>&nbsp;                boolean             isExpanded = isExpanded(parent);
<i>3898</i>&nbsp;
<b class="nc"><i>3899</i>&nbsp;                toRemove.addElement(parent);</b>
<b class="nc"><i>3900</i>&nbsp;                removeDescendantToggledPaths(toRemove.elements());</b>
<i>3901</i>&nbsp;                if(isExpanded) {
<b class="nc"><i>3902</i>&nbsp;                    TreeModel         model = getModel();</b>
<b class="nc"><i>3903</i>&nbsp;</b>
<b class="nc"><i>3904</i>&nbsp;                    if(model == null || model.isLeaf</b>
<b class="nc"><i>3905</i>&nbsp;                       (parent.getLastPathComponent()))</b>
<b class="nc"><i>3906</i>&nbsp;                        collapsePath(parent);</b>
<b class="nc"><i>3907</i>&nbsp;                    else</b>
<b class="nc"><i>3908</i>&nbsp;                        expandedState.put(parent, Boolean.TRUE);</b>
<b class="nc"><i>3909</i>&nbsp;                }</b>
<b class="nc"><i>3910</i>&nbsp;            }</b>
<i>3911</i>&nbsp;            removeDescendantSelectedPaths(parent, false);
<i>3912</i>&nbsp;        }
<b class="nc"><i>3913</i>&nbsp;</b>
<b class="nc"><i>3914</i>&nbsp;        public void treeNodesRemoved(TreeModelEvent e) {</b>
<b class="nc"><i>3915</i>&nbsp;            if(e == null)</b>
<b class="nc"><i>3916</i>&nbsp;                return;</b>
<i>3917</i>&nbsp;
<b class="nc"><i>3918</i>&nbsp;            TreePath            parent = SwingUtilities2.getTreePath(e, getModel());</b>
<b class="nc"><i>3919</i>&nbsp;            Object[]            children = e.getChildren();</b>
<b class="nc"><i>3920</i>&nbsp;</b>
<i>3921</i>&nbsp;            if(children == null)
<b class="nc"><i>3922</i>&nbsp;                return;</b>
<b class="nc"><i>3923</i>&nbsp;</b>
<b class="nc"><i>3924</i>&nbsp;            TreePath            rPath;</b>
<i>3925</i>&nbsp;            Vector&lt;TreePath&gt;    toRemove
<i>3926</i>&nbsp;                = new Vector&lt;TreePath&gt;(Math.max(1, children.length));
<i>3927</i>&nbsp;
<i>3928</i>&nbsp;            for(int counter = children.length - 1; counter &gt;= 0; counter--) {
<i>3929</i>&nbsp;                rPath = parent.pathByAddingChild(children[counter]);
<i>3930</i>&nbsp;                if(expandedState.get(rPath) != null)
<i>3931</i>&nbsp;                    toRemove.addElement(rPath);
<i>3932</i>&nbsp;            }
<i>3933</i>&nbsp;            if(toRemove.size() &gt; 0)
<i>3934</i>&nbsp;                removeDescendantToggledPaths(toRemove.elements());
<i>3935</i>&nbsp;
<i>3936</i>&nbsp;            TreeModel         model = getModel();
<i>3937</i>&nbsp;
<i>3938</i>&nbsp;            if(model == null || model.isLeaf(parent.getLastPathComponent()))
<i>3939</i>&nbsp;                expandedState.remove(parent);
<i>3940</i>&nbsp;
<i>3941</i>&nbsp;            removeDescendantSelectedPaths(e);
<i>3942</i>&nbsp;        }
<i>3943</i>&nbsp;    }
<i>3944</i>&nbsp;
<i>3945</i>&nbsp;
<i>3946</i>&nbsp;    /**
<b class="nc"><i>3947</i>&nbsp;     * &lt;code&gt;DynamicUtilTreeNode&lt;/code&gt; can wrap</b>
<b class="nc"><i>3948</i>&nbsp;     * vectors/hashtables/arrays/strings and</b>
<b class="nc"><i>3949</i>&nbsp;     * create the appropriate children tree nodes as necessary. It is</b>
<b class="nc"><i>3950</i>&nbsp;     * dynamic in that it will only create the children as necessary.</b>
<b class="nc"><i>3951</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3952</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;</b>
<b class="nc"><i>3953</i>&nbsp;     * Serialized objects of this class will not be compatible with</b>
<b class="nc"><i>3954</i>&nbsp;     * future Swing releases. The current serialization support is</b>
<b class="nc"><i>3955</i>&nbsp;     * appropriate for short term storage or RMI between applications running</b>
<b class="nc"><i>3956</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage</b>
<i>3957</i>&nbsp;     * of all JavaBeans&amp;trade;
<b class="nc"><i>3958</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.</b>
<i>3959</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<i>3960</i>&nbsp;     */
<b class="nc"><i>3961</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<i>3962</i>&nbsp;    public static class DynamicUtilTreeNode extends DefaultMutableTreeNode {
<i>3963</i>&nbsp;        /**
<i>3964</i>&nbsp;         * Does the this &lt;code&gt;JTree&lt;/code&gt; have children?
<i>3965</i>&nbsp;         * This property is currently not implemented.
<i>3966</i>&nbsp;         */
<i>3967</i>&nbsp;        protected boolean            hasChildren;
<i>3968</i>&nbsp;        /** Value to create children with. */
<i>3969</i>&nbsp;        protected Object             childValue;
<i>3970</i>&nbsp;        /** Have the children been loaded yet? */
<i>3971</i>&nbsp;        protected boolean            loadedChildren;
<b class="nc"><i>3972</i>&nbsp;</b>
<i>3973</i>&nbsp;        /**
<i>3974</i>&nbsp;         * Adds to parent all the children in &lt;code&gt;children&lt;/code&gt;.
<i>3975</i>&nbsp;         * If &lt;code&gt;children&lt;/code&gt; is an array or vector all of its
<i>3976</i>&nbsp;         * elements are added is children, otherwise if &lt;code&gt;children&lt;/code&gt;
<i>3977</i>&nbsp;         * is a hashtable all the key/value pairs are added in the order
<i>3978</i>&nbsp;         * &lt;code&gt;Enumeration&lt;/code&gt; returns them.
<i>3979</i>&nbsp;         *
<i>3980</i>&nbsp;         * @param parent the parent node
<b class="nc"><i>3981</i>&nbsp;         * @param children the children</b>
<b class="nc"><i>3982</i>&nbsp;         */</b>
<b class="nc"><i>3983</i>&nbsp;        public static void createChildren(DefaultMutableTreeNode parent,</b>
<i>3984</i>&nbsp;                                          Object children) {
<i>3985</i>&nbsp;            if(children instanceof Vector) {
<i>3986</i>&nbsp;                Vector&lt;?&gt;          childVector = (Vector)children;
<i>3987</i>&nbsp;
<i>3988</i>&nbsp;                for(int counter = 0, maxCounter = childVector.size();
<i>3989</i>&nbsp;                    counter &lt; maxCounter; counter++)
<i>3990</i>&nbsp;                    parent.add(new DynamicUtilTreeNode
<i>3991</i>&nbsp;                               (childVector.elementAt(counter),
<i>3992</i>&nbsp;                                childVector.elementAt(counter)));
<i>3993</i>&nbsp;            }
<i>3994</i>&nbsp;            else if(children instanceof Hashtable) {
<b class="nc"><i>3995</i>&nbsp;                Hashtable&lt;?,?&gt;           childHT = (Hashtable)children;</b>
<b class="nc"><i>3996</i>&nbsp;                Enumeration&lt;?&gt;         keys = childHT.keys();</b>
<i>3997</i>&nbsp;                Object              aKey;
<i>3998</i>&nbsp;
<i>3999</i>&nbsp;                while(keys.hasMoreElements()) {
<i>4000</i>&nbsp;                    aKey = keys.nextElement();
<i>4001</i>&nbsp;                    parent.add(new DynamicUtilTreeNode(aKey,
<i>4002</i>&nbsp;                                                       childHT.get(aKey)));
<b class="nc"><i>4003</i>&nbsp;                }</b>
<b class="nc"><i>4004</i>&nbsp;            }</b>
<b class="nc"><i>4005</i>&nbsp;            else if(children instanceof Object[]) {</b>
<i>4006</i>&nbsp;                Object[]             childArray = (Object[])children;
<i>4007</i>&nbsp;
<i>4008</i>&nbsp;                for(int counter = 0, maxCounter = childArray.length;
<i>4009</i>&nbsp;                    counter &lt; maxCounter; counter++)
<i>4010</i>&nbsp;                    parent.add(new DynamicUtilTreeNode(childArray[counter],
<i>4011</i>&nbsp;                                                       childArray[counter]));
<b class="nc"><i>4012</i>&nbsp;            }</b>
<b class="nc"><i>4013</i>&nbsp;        }</b>
<b class="nc"><i>4014</i>&nbsp;</b>
<i>4015</i>&nbsp;        /**
<i>4016</i>&nbsp;         * Creates a node with the specified object as its value and
<i>4017</i>&nbsp;         * with the specified children. For the node to allow children,
<i>4018</i>&nbsp;         * the children-object must be an array of objects, a
<b class="nc"><i>4019</i>&nbsp;         * &lt;code&gt;Vector&lt;/code&gt;, or a &lt;code&gt;Hashtable&lt;/code&gt; -- even</b>
<b class="nc"><i>4020</i>&nbsp;         * if empty. Otherwise, the node is not</b>
<b class="nc"><i>4021</i>&nbsp;         * allowed to have children.</b>
<b class="nc"><i>4022</i>&nbsp;         *</b>
<i>4023</i>&nbsp;         * @param value  the &lt;code&gt;Object&lt;/code&gt; that is the value for the
<b class="nc"><i>4024</i>&nbsp;         *              new node</b>
<b class="nc"><i>4025</i>&nbsp;         * @param children an array of &lt;code&gt;Object&lt;/code&gt;s, a</b>
<b class="nc"><i>4026</i>&nbsp;         *              &lt;code&gt;Vector&lt;/code&gt;, or a &lt;code&gt;Hashtable&lt;/code&gt;</b>
<b class="nc"><i>4027</i>&nbsp;         *              used to create the child nodes; if any other</b>
<i>4028</i>&nbsp;         *              object is specified, or if the value is
<b class="nc"><i>4029</i>&nbsp;         *              &lt;code&gt;null&lt;/code&gt;,</b>
<b class="nc"><i>4030</i>&nbsp;         *              then the node is not allowed to have children</b>
<b class="nc"><i>4031</i>&nbsp;         */</b>
<b class="nc"><i>4032</i>&nbsp;        public DynamicUtilTreeNode(Object value, Object children) {</b>
<i>4033</i>&nbsp;            super(value);
<i>4034</i>&nbsp;            loadedChildren = false;
<b class="nc"><i>4035</i>&nbsp;            childValue = children;</b>
<i>4036</i>&nbsp;            if(children != null) {
<i>4037</i>&nbsp;                if(children instanceof Vector)
<i>4038</i>&nbsp;                    setAllowsChildren(true);
<i>4039</i>&nbsp;                else if(children instanceof Hashtable)
<i>4040</i>&nbsp;                    setAllowsChildren(true);
<i>4041</i>&nbsp;                else if(children instanceof Object[])
<i>4042</i>&nbsp;                    setAllowsChildren(true);
<i>4043</i>&nbsp;                else
<i>4044</i>&nbsp;                    setAllowsChildren(false);
<i>4045</i>&nbsp;            }
<i>4046</i>&nbsp;            else
<i>4047</i>&nbsp;                setAllowsChildren(false);
<i>4048</i>&nbsp;        }
<i>4049</i>&nbsp;
<i>4050</i>&nbsp;        /**
<b class="nc"><i>4051</i>&nbsp;         * Returns true if this node allows children. Whether the node</b>
<i>4052</i>&nbsp;         * allows children depends on how it was created.
<b class="nc"><i>4053</i>&nbsp;         *</b>
<i>4054</i>&nbsp;         * @return true if this node allows children, false otherwise
<b class="nc"><i>4055</i>&nbsp;         * @see JTree.DynamicUtilTreeNode</b>
<i>4056</i>&nbsp;         */
<b class="nc"><i>4057</i>&nbsp;        public boolean isLeaf() {</b>
<i>4058</i>&nbsp;            return !getAllowsChildren();
<b class="nc"><i>4059</i>&nbsp;        }</b>
<i>4060</i>&nbsp;
<b class="nc"><i>4061</i>&nbsp;        /**</b>
<i>4062</i>&nbsp;         * Returns the number of child nodes.
<i>4063</i>&nbsp;         *
<b class="nc"><i>4064</i>&nbsp;         * @return the number of child nodes</b>
<i>4065</i>&nbsp;         */
<i>4066</i>&nbsp;        public int getChildCount() {
<i>4067</i>&nbsp;            if(!loadedChildren)
<i>4068</i>&nbsp;                loadChildren();
<i>4069</i>&nbsp;            return super.getChildCount();
<i>4070</i>&nbsp;        }
<i>4071</i>&nbsp;
<i>4072</i>&nbsp;        /**
<i>4073</i>&nbsp;         * Loads the children based on &lt;code&gt;childValue&lt;/code&gt;.
<i>4074</i>&nbsp;         * If &lt;code&gt;childValue&lt;/code&gt; is a &lt;code&gt;Vector&lt;/code&gt;
<i>4075</i>&nbsp;         * or array each element is added as a child,
<i>4076</i>&nbsp;         * if &lt;code&gt;childValue&lt;/code&gt; is a &lt;code&gt;Hashtable&lt;/code&gt;
<i>4077</i>&nbsp;         * each key/value pair is added in the order that
<i>4078</i>&nbsp;         * &lt;code&gt;Enumeration&lt;/code&gt; returns the keys.
<i>4079</i>&nbsp;         */
<i>4080</i>&nbsp;        protected void loadChildren() {
<i>4081</i>&nbsp;            loadedChildren = true;
<i>4082</i>&nbsp;            createChildren(this, childValue);
<i>4083</i>&nbsp;        }
<i>4084</i>&nbsp;
<i>4085</i>&nbsp;        /**
<i>4086</i>&nbsp;         * Subclassed to load the children, if necessary.
<i>4087</i>&nbsp;         */
<i>4088</i>&nbsp;        public TreeNode getChildAt(int index) {
<i>4089</i>&nbsp;            if(!loadedChildren)
<b class="nc"><i>4090</i>&nbsp;                loadChildren();</b>
<b class="nc"><i>4091</i>&nbsp;            return super.getChildAt(index);</b>
<i>4092</i>&nbsp;        }
<b class="nc"><i>4093</i>&nbsp;</b>
<i>4094</i>&nbsp;        /**
<i>4095</i>&nbsp;         * Subclassed to load the children, if necessary.
<i>4096</i>&nbsp;         */
<i>4097</i>&nbsp;        public Enumeration&lt;TreeNode&gt; children() {
<i>4098</i>&nbsp;            if(!loadedChildren)
<i>4099</i>&nbsp;                loadChildren();
<i>4100</i>&nbsp;            return super.children();
<i>4101</i>&nbsp;        }
<i>4102</i>&nbsp;    }
<i>4103</i>&nbsp;
<i>4104</i>&nbsp;    void setUIProperty(String propertyName, Object value) {
<i>4105</i>&nbsp;        if (propertyName == &quot;rowHeight&quot;) {
<i>4106</i>&nbsp;            if (!rowHeightSet) {
<i>4107</i>&nbsp;                setRowHeight(((Number)value).intValue());
<i>4108</i>&nbsp;                rowHeightSet = false;
<i>4109</i>&nbsp;            }
<i>4110</i>&nbsp;        } else if (propertyName == &quot;scrollsOnExpand&quot;) {
<i>4111</i>&nbsp;            if (!scrollsOnExpandSet) {
<i>4112</i>&nbsp;                setScrollsOnExpand(((Boolean)value).booleanValue());
<i>4113</i>&nbsp;                scrollsOnExpandSet = false;
<i>4114</i>&nbsp;            }
<i>4115</i>&nbsp;        } else if (propertyName == &quot;showsRootHandles&quot;) {
<i>4116</i>&nbsp;            if (!showsRootHandlesSet) {
<i>4117</i>&nbsp;                setShowsRootHandles(((Boolean)value).booleanValue());
<b class="nc"><i>4118</i>&nbsp;                showsRootHandlesSet = false;</b>
<i>4119</i>&nbsp;            }
<b class="nc"><i>4120</i>&nbsp;        } else {</b>
<b class="nc"><i>4121</i>&nbsp;            super.setUIProperty(propertyName, value);</b>
<b class="nc"><i>4122</i>&nbsp;        }</b>
<i>4123</i>&nbsp;    }
<b class="nc"><i>4124</i>&nbsp;</b>
<b class="nc"><i>4125</i>&nbsp;</b>
<b class="nc"><i>4126</i>&nbsp;    /**</b>
<b class="nc"><i>4127</i>&nbsp;     * Returns a string representation of this &lt;code&gt;JTree&lt;/code&gt;.</b>
<i>4128</i>&nbsp;     * This method
<i>4129</i>&nbsp;     * is intended to be used only for debugging purposes, and the
<i>4130</i>&nbsp;     * content and format of the returned string may vary between
<i>4131</i>&nbsp;     * implementations. The returned string may be empty but may not
<i>4132</i>&nbsp;     * be &lt;code&gt;null&lt;/code&gt;.
<i>4133</i>&nbsp;     *
<i>4134</i>&nbsp;     * @return  a string representation of this &lt;code&gt;JTree&lt;/code&gt;.
<i>4135</i>&nbsp;     */
<i>4136</i>&nbsp;    protected String paramString() {
<i>4137</i>&nbsp;        String rootVisibleString = (rootVisible ?
<i>4138</i>&nbsp;                                    &quot;true&quot; : &quot;false&quot;);
<i>4139</i>&nbsp;        String showsRootHandlesString = (showsRootHandles ?
<i>4140</i>&nbsp;                                         &quot;true&quot; : &quot;false&quot;);
<i>4141</i>&nbsp;        String editableString = (editable ?
<b class="nc"><i>4142</i>&nbsp;                                 &quot;true&quot; : &quot;false&quot;);</b>
<b class="nc"><i>4143</i>&nbsp;        String largeModelString = (largeModel ?</b>
<i>4144</i>&nbsp;                                   &quot;true&quot; : &quot;false&quot;);
<i>4145</i>&nbsp;        String invokesStopCellEditingString = (invokesStopCellEditing ?
<i>4146</i>&nbsp;                                               &quot;true&quot; : &quot;false&quot;);
<i>4147</i>&nbsp;        String scrollsOnExpandString = (scrollsOnExpand ?
<i>4148</i>&nbsp;                                        &quot;true&quot; : &quot;false&quot;);
<i>4149</i>&nbsp;
<i>4150</i>&nbsp;        return super.paramString() +
<i>4151</i>&nbsp;        &quot;,editable=&quot; + editableString +
<i>4152</i>&nbsp;        &quot;,invokesStopCellEditing=&quot; + invokesStopCellEditingString +
<i>4153</i>&nbsp;        &quot;,largeModel=&quot; + largeModelString +
<i>4154</i>&nbsp;        &quot;,rootVisible=&quot; + rootVisibleString +
<i>4155</i>&nbsp;        &quot;,rowHeight=&quot; + rowHeight +
<b class="nc"><i>4156</i>&nbsp;        &quot;,scrollsOnExpand=&quot; + scrollsOnExpandString +</b>
<b class="nc"><i>4157</i>&nbsp;        &quot;,showsRootHandles=&quot; + showsRootHandlesString +</b>
<i>4158</i>&nbsp;        &quot;,toggleClickCount=&quot; + toggleClickCount +
<i>4159</i>&nbsp;        &quot;,visibleRowCount=&quot; + visibleRowCount;
<i>4160</i>&nbsp;    }
<i>4161</i>&nbsp;
<i>4162</i>&nbsp;/////////////////
<i>4163</i>&nbsp;// Accessibility support
<i>4164</i>&nbsp;////////////////
<i>4165</i>&nbsp;
<i>4166</i>&nbsp;    /**
<i>4167</i>&nbsp;     * Gets the AccessibleContext associated with this JTree.
<b class="nc"><i>4168</i>&nbsp;     * For JTrees, the AccessibleContext takes the form of an</b>
<i>4169</i>&nbsp;     * AccessibleJTree.
<i>4170</i>&nbsp;     * A new AccessibleJTree instance is created if necessary.
<i>4171</i>&nbsp;     *
<i>4172</i>&nbsp;     * @return an AccessibleJTree that serves as the
<i>4173</i>&nbsp;     *         AccessibleContext of this JTree
<i>4174</i>&nbsp;     */
<i>4175</i>&nbsp;    @BeanProperty(bound = false)
<i>4176</i>&nbsp;    public AccessibleContext getAccessibleContext() {
<b class="nc"><i>4177</i>&nbsp;        if (accessibleContext == null) {</b>
<i>4178</i>&nbsp;            accessibleContext = new AccessibleJTree();
<i>4179</i>&nbsp;        }
<i>4180</i>&nbsp;        return accessibleContext;
<i>4181</i>&nbsp;    }
<i>4182</i>&nbsp;
<i>4183</i>&nbsp;    /**
<i>4184</i>&nbsp;     * This class implements accessibility support for the
<i>4185</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt; class.  It provides an implementation of the
<b class="nc"><i>4186</i>&nbsp;     * Java Accessibility API appropriate to tree user-interface elements.</b>
<i>4187</i>&nbsp;     * &lt;p&gt;
<i>4188</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>4189</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>4190</i>&nbsp;     * future Swing releases. The current serialization support is
<i>4191</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>4192</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>4193</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>4194</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<b class="nc"><i>4195</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.</b>
<i>4196</i>&nbsp;     */
<i>4197</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>4198</i>&nbsp;    protected class AccessibleJTree extends AccessibleJComponent
<i>4199</i>&nbsp;            implements AccessibleSelection, TreeSelectionListener,
<i>4200</i>&nbsp;                       TreeModelListener, TreeExpansionListener  {
<i>4201</i>&nbsp;
<i>4202</i>&nbsp;        TreePath   leadSelectionPath;
<i>4203</i>&nbsp;        Accessible leadSelectionAccessible;
<b class="nc"><i>4204</i>&nbsp;</b>
<b class="nc"><i>4205</i>&nbsp;        /**</b>
<b class="nc"><i>4206</i>&nbsp;         * Constructs {@code AccessibleJTree}</b>
<i>4207</i>&nbsp;         */
<i>4208</i>&nbsp;        public AccessibleJTree() {
<b class="nc"><i>4209</i>&nbsp;            // Add a tree model listener for JTree</b>
<i>4210</i>&nbsp;            TreeModel model = JTree.this.getModel();
<i>4211</i>&nbsp;            if (model != null) {
<b class="nc"><i>4212</i>&nbsp;                model.addTreeModelListener(this);</b>
<i>4213</i>&nbsp;            }
<i>4214</i>&nbsp;            JTree.this.addTreeExpansionListener(this);
<i>4215</i>&nbsp;            JTree.this.addTreeSelectionListener(this);
<b class="nc"><i>4216</i>&nbsp;            leadSelectionPath = JTree.this.getLeadSelectionPath();</b>
<i>4217</i>&nbsp;            leadSelectionAccessible = (leadSelectionPath != null)
<i>4218</i>&nbsp;                    ? new AccessibleJTreeNode(JTree.this,
<i>4219</i>&nbsp;                                              leadSelectionPath,
<i>4220</i>&nbsp;                                              JTree.this)
<i>4221</i>&nbsp;                    : null;
<i>4222</i>&nbsp;        }
<i>4223</i>&nbsp;
<i>4224</i>&nbsp;        /**
<i>4225</i>&nbsp;         * Tree Selection Listener value change method. Used to fire the
<i>4226</i>&nbsp;         * property change
<b class="nc"><i>4227</i>&nbsp;         *</b>
<b class="nc"><i>4228</i>&nbsp;         * @param e ListSelectionEvent</b>
<b class="nc"><i>4229</i>&nbsp;         *</b>
<i>4230</i>&nbsp;         */
<i>4231</i>&nbsp;        public void valueChanged(TreeSelectionEvent e) {
<i>4232</i>&nbsp;             firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
<b class="nc"><i>4233</i>&nbsp;                                Boolean.valueOf(false), Boolean.valueOf(true));</b>
<i>4234</i>&nbsp;         }
<i>4235</i>&nbsp;
<b class="nc"><i>4236</i>&nbsp;        /**</b>
<i>4237</i>&nbsp;         * Fire a visible data property change notification.
<i>4238</i>&nbsp;         * A &#39;visible&#39; data property is one that represents
<i>4239</i>&nbsp;         * something about the way the component appears on the
<b class="nc"><i>4240</i>&nbsp;         * display, where that appearance isn&#39;t bound to any other</b>
<i>4241</i>&nbsp;         * property. It notifies screen readers  that the visual
<i>4242</i>&nbsp;         * appearance of the component has changed, so they can
<i>4243</i>&nbsp;         * notify the user.
<i>4244</i>&nbsp;         */
<i>4245</i>&nbsp;        public void fireVisibleDataPropertyChange() {
<i>4246</i>&nbsp;           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
<i>4247</i>&nbsp;                              Boolean.valueOf(false), Boolean.valueOf(true));
<i>4248</i>&nbsp;        }
<i>4249</i>&nbsp;
<i>4250</i>&nbsp;        // Fire the visible data changes for the model changes.
<i>4251</i>&nbsp;
<i>4252</i>&nbsp;        /**
<i>4253</i>&nbsp;         * Tree Model Node change notification.
<i>4254</i>&nbsp;         *
<i>4255</i>&nbsp;         * @param e  a Tree Model event
<i>4256</i>&nbsp;         */
<b class="nc"><i>4257</i>&nbsp;        public void treeNodesChanged(TreeModelEvent e) {</b>
<b class="nc"><i>4258</i>&nbsp;           fireVisibleDataPropertyChange();</b>
<i>4259</i>&nbsp;        }
<i>4260</i>&nbsp;
<i>4261</i>&nbsp;        /**
<i>4262</i>&nbsp;         * Tree Model Node change notification.
<i>4263</i>&nbsp;         *
<b class="nc"><i>4264</i>&nbsp;         * @param e  a Tree node insertion event</b>
<i>4265</i>&nbsp;         */
<i>4266</i>&nbsp;        public void treeNodesInserted(TreeModelEvent e) {
<i>4267</i>&nbsp;           fireVisibleDataPropertyChange();
<i>4268</i>&nbsp;        }
<b class="nc"><i>4269</i>&nbsp;</b>
<i>4270</i>&nbsp;        /**
<i>4271</i>&nbsp;         * Tree Model Node change notification.
<i>4272</i>&nbsp;         *
<i>4273</i>&nbsp;         * @param e  a Tree node(s) removal event
<i>4274</i>&nbsp;         */
<b class="nc"><i>4275</i>&nbsp;        public  void treeNodesRemoved(TreeModelEvent e) {</b>
<b class="nc"><i>4276</i>&nbsp;           fireVisibleDataPropertyChange();</b>
<b class="nc"><i>4277</i>&nbsp;        }</b>
<i>4278</i>&nbsp;
<b class="nc"><i>4279</i>&nbsp;        /**</b>
<i>4280</i>&nbsp;         * Tree Model structure change change notification.
<i>4281</i>&nbsp;         *
<i>4282</i>&nbsp;         * @param e  a Tree Model event
<i>4283</i>&nbsp;         */
<i>4284</i>&nbsp;        public  void treeStructureChanged(TreeModelEvent e) {
<i>4285</i>&nbsp;           fireVisibleDataPropertyChange();
<i>4286</i>&nbsp;        }
<b class="nc"><i>4287</i>&nbsp;</b>
<b class="nc"><i>4288</i>&nbsp;        /**</b>
<b class="nc"><i>4289</i>&nbsp;         * Tree Collapsed notification.</b>
<i>4290</i>&nbsp;         *
<b class="nc"><i>4291</i>&nbsp;         * @param e  a TreeExpansionEvent</b>
<b class="nc"><i>4292</i>&nbsp;         */</b>
<b class="nc"><i>4293</i>&nbsp;        public  void treeCollapsed(TreeExpansionEvent e) {</b>
<i>4294</i>&nbsp;            fireVisibleDataPropertyChange();
<b class="nc"><i>4295</i>&nbsp;            TreePath path = e.getPath();</b>
<b class="nc"><i>4296</i>&nbsp;            if (path != null) {</b>
<b class="nc"><i>4297</i>&nbsp;                // Set parent to null so AccessibleJTreeNode computes</b>
<b class="nc"><i>4298</i>&nbsp;                // its parent.</b>
<b class="nc"><i>4299</i>&nbsp;                AccessibleJTreeNode node = new AccessibleJTreeNode(JTree.this,</b>
<b class="nc"><i>4300</i>&nbsp;                                                                   path,</b>
<b class="nc"><i>4301</i>&nbsp;                                                                   null);</b>
<b class="nc"><i>4302</i>&nbsp;                PropertyChangeEvent pce = new PropertyChangeEvent(node,</b>
<i>4303</i>&nbsp;                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<b class="nc"><i>4304</i>&nbsp;                    AccessibleState.EXPANDED,</b>
<b class="nc"><i>4305</i>&nbsp;                    AccessibleState.COLLAPSED);</b>
<i>4306</i>&nbsp;                firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<b class="nc"><i>4307</i>&nbsp;                                   null, pce);</b>
<i>4308</i>&nbsp;            }
<b class="nc"><i>4309</i>&nbsp;        }</b>
<i>4310</i>&nbsp;
<i>4311</i>&nbsp;        /**
<b class="nc"><i>4312</i>&nbsp;         * Tree Model Expansion notification.</b>
<i>4313</i>&nbsp;         *
<i>4314</i>&nbsp;         * @param e  a Tree node insertion event
<i>4315</i>&nbsp;         */
<i>4316</i>&nbsp;        public  void treeExpanded(TreeExpansionEvent e) {
<i>4317</i>&nbsp;            fireVisibleDataPropertyChange();
<i>4318</i>&nbsp;            TreePath path = e.getPath();
<i>4319</i>&nbsp;            if (path != null) {
<i>4320</i>&nbsp;                // TIGER - 4839971
<i>4321</i>&nbsp;                // Set parent to null so AccessibleJTreeNode computes
<i>4322</i>&nbsp;                // its parent.
<i>4323</i>&nbsp;                AccessibleJTreeNode node = new AccessibleJTreeNode(JTree.this,
<i>4324</i>&nbsp;                                                                   path,
<b class="nc"><i>4325</i>&nbsp;                                                                   null);</b>
<i>4326</i>&nbsp;                PropertyChangeEvent pce = new PropertyChangeEvent(node,
<i>4327</i>&nbsp;                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>4328</i>&nbsp;                    AccessibleState.COLLAPSED,
<i>4329</i>&nbsp;                    AccessibleState.EXPANDED);
<i>4330</i>&nbsp;                firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>4331</i>&nbsp;                                   null, pce);
<i>4332</i>&nbsp;            }
<i>4333</i>&nbsp;        }
<i>4334</i>&nbsp;
<i>4335</i>&nbsp;        /**
<i>4336</i>&nbsp;        *  Fire an active descendant property change notification.
<i>4337</i>&nbsp;        *  The active descendant is used for objects such as list,
<b class="nc"><i>4338</i>&nbsp;        *  tree, and table, which may have transient children.</b>
<b class="nc"><i>4339</i>&nbsp;        *  It notifies screen readers the active child of the component</b>
<i>4340</i>&nbsp;        *  has been changed so user can be notified from there.
<b class="nc"><i>4341</i>&nbsp;        *</b>
<i>4342</i>&nbsp;        * @param oldPath - lead path of previous active child
<b class="nc"><i>4343</i>&nbsp;        * @param newPath - lead path of current active child</b>
<i>4344</i>&nbsp;        *
<i>4345</i>&nbsp;        */
<i>4346</i>&nbsp;        void fireActiveDescendantPropertyChange(TreePath oldPath, TreePath newPath){
<i>4347</i>&nbsp;            if(oldPath != newPath){
<i>4348</i>&nbsp;                Accessible oldLSA = (oldPath != null)
<i>4349</i>&nbsp;                                    ? new AccessibleJTreeNode(JTree.this,
<i>4350</i>&nbsp;                                                              oldPath,
<i>4351</i>&nbsp;                                                              null)
<i>4352</i>&nbsp;                                    : null;
<i>4353</i>&nbsp;
<b class="nc"><i>4354</i>&nbsp;                Accessible newLSA = (newPath != null)</b>
<b class="nc"><i>4355</i>&nbsp;                                    ? new AccessibleJTreeNode(JTree.this,</b>
<b class="nc"><i>4356</i>&nbsp;                                                              newPath,</b>
<i>4357</i>&nbsp;                                                              null)
<b class="nc"><i>4358</i>&nbsp;                                    : null;</b>
<b class="nc"><i>4359</i>&nbsp;                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,</b>
<i>4360</i>&nbsp;                                                                oldLSA, newLSA);
<i>4361</i>&nbsp;            }
<b class="nc"><i>4362</i>&nbsp;        }</b>
<b class="nc"><i>4363</i>&nbsp;</b>
<b class="nc"><i>4364</i>&nbsp;        private AccessibleContext getCurrentAccessibleContext() {</b>
<i>4365</i>&nbsp;            Component c = getCurrentComponent();
<b class="nc"><i>4366</i>&nbsp;            if (c instanceof Accessible) {</b>
<i>4367</i>&nbsp;                return c.getAccessibleContext();
<i>4368</i>&nbsp;            } else {
<i>4369</i>&nbsp;                return null;
<i>4370</i>&nbsp;            }
<i>4371</i>&nbsp;        }
<i>4372</i>&nbsp;
<i>4373</i>&nbsp;        private Component getCurrentComponent() {
<i>4374</i>&nbsp;            // is the object visible?
<i>4375</i>&nbsp;            // if so, get row, selected, focus &amp; leaf state,
<b class="nc"><i>4376</i>&nbsp;            // and then get the renderer component and return it</b>
<b class="nc"><i>4377</i>&nbsp;            TreeModel model = JTree.this.getModel();</b>
<b class="nc"><i>4378</i>&nbsp;            if (model == null) {</b>
<i>4379</i>&nbsp;                return null;
<i>4380</i>&nbsp;            }
<b class="nc"><i>4381</i>&nbsp;</b>
<b class="nc"><i>4382</i>&nbsp;            Object treeRoot = model.getRoot();</b>
<b class="nc"><i>4383</i>&nbsp;            if (treeRoot == null) {</b>
<i>4384</i>&nbsp;                return null;
<i>4385</i>&nbsp;            }
<b class="nc"><i>4386</i>&nbsp;            TreePath path = new TreePath(treeRoot);</b>
<b class="nc"><i>4387</i>&nbsp;            if (JTree.this.isVisible(path)) {</b>
<b class="nc"><i>4388</i>&nbsp;                TreeCellRenderer r = JTree.this.getCellRenderer();</b>
<b class="nc"><i>4389</i>&nbsp;                TreeUI ui = JTree.this.getUI();</b>
<b class="nc"><i>4390</i>&nbsp;                if (ui != null) {</b>
<b class="nc"><i>4391</i>&nbsp;                    int row = ui.getRowForPath(JTree.this, path);</b>
<b class="nc"><i>4392</i>&nbsp;                    int lsr = JTree.this.getLeadSelectionRow();</b>
<i>4393</i>&nbsp;                    boolean hasFocus = JTree.this.isFocusOwner()
<b class="nc"><i>4394</i>&nbsp;                                       &amp;&amp; (lsr == row);</b>
<i>4395</i>&nbsp;                    boolean selected = JTree.this.isPathSelected(path);
<i>4396</i>&nbsp;                    boolean expanded = JTree.this.isExpanded(path);
<i>4397</i>&nbsp;
<i>4398</i>&nbsp;                    return r.getTreeCellRendererComponent(JTree.this,
<b class="nc"><i>4399</i>&nbsp;                        treeRoot, selected, expanded,</b>
<b class="nc"><i>4400</i>&nbsp;                        model.isLeaf(treeRoot), row, hasFocus);</b>
<b class="nc"><i>4401</i>&nbsp;                }</b>
<i>4402</i>&nbsp;            }
<b class="nc"><i>4403</i>&nbsp;            return null;</b>
<b class="nc"><i>4404</i>&nbsp;        }</b>
<b class="nc"><i>4405</i>&nbsp;</b>
<b class="nc"><i>4406</i>&nbsp;        // Overridden methods from AccessibleJComponent</b>
<b class="nc"><i>4407</i>&nbsp;</b>
<b class="nc"><i>4408</i>&nbsp;        /**</b>
<i>4409</i>&nbsp;         * Get the role of this object.
<i>4410</i>&nbsp;         *
<i>4411</i>&nbsp;         * @return an instance of AccessibleRole describing the role of the
<i>4412</i>&nbsp;         * object
<i>4413</i>&nbsp;         * @see AccessibleRole
<i>4414</i>&nbsp;         */
<i>4415</i>&nbsp;        public AccessibleRole getAccessibleRole() {
<i>4416</i>&nbsp;            return AccessibleRole.TREE;
<i>4417</i>&nbsp;        }
<i>4418</i>&nbsp;
<i>4419</i>&nbsp;        /**
<b class="nc"><i>4420</i>&nbsp;         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,</b>
<i>4421</i>&nbsp;         * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
<i>4422</i>&nbsp;         * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
<i>4423</i>&nbsp;         *
<i>4424</i>&nbsp;         * @param p point in local coordinates of this &lt;code&gt;Accessible&lt;/code&gt;
<i>4425</i>&nbsp;         * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
<i>4426</i>&nbsp;         *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
<i>4427</i>&nbsp;         */
<i>4428</i>&nbsp;        public Accessible getAccessibleAt(Point p) {
<i>4429</i>&nbsp;            TreePath path = getClosestPathForLocation(p.x, p.y);
<i>4430</i>&nbsp;            if (path != null) {
<i>4431</i>&nbsp;                // JTree.this is NOT the parent; parent will get computed later
<i>4432</i>&nbsp;                return new AccessibleJTreeNode(JTree.this, path, null);
<b class="nc"><i>4433</i>&nbsp;            } else {</b>
<i>4434</i>&nbsp;                return null;
<i>4435</i>&nbsp;            }
<i>4436</i>&nbsp;        }
<i>4437</i>&nbsp;
<i>4438</i>&nbsp;        /**
<i>4439</i>&nbsp;         * Returns the number of top-level children nodes of this
<i>4440</i>&nbsp;         * JTree.  Each of these nodes may in turn have children nodes.
<i>4441</i>&nbsp;         *
<i>4442</i>&nbsp;         * @return the number of accessible children nodes in the tree.
<b class="nc"><i>4443</i>&nbsp;         */</b>
<b class="nc"><i>4444</i>&nbsp;        public int getAccessibleChildrenCount() {</b>
<b class="nc"><i>4445</i>&nbsp;            TreeModel model = JTree.this.getModel();</b>
<b class="nc"><i>4446</i>&nbsp;            if (model == null) {</b>
<i>4447</i>&nbsp;                return 0;
<b class="nc"><i>4448</i>&nbsp;            }</b>
<b class="nc"><i>4449</i>&nbsp;            if (isRootVisible()) {</b>
<b class="nc"><i>4450</i>&nbsp;                return 1;    // the root node</b>
<i>4451</i>&nbsp;            }
<b class="nc"><i>4452</i>&nbsp;</b>
<i>4453</i>&nbsp;            Object treeRoot = model.getRoot();
<i>4454</i>&nbsp;            if (treeRoot == null)
<i>4455</i>&nbsp;                return 0;
<i>4456</i>&nbsp;
<i>4457</i>&nbsp;            // return the root&#39;s first set of children count
<i>4458</i>&nbsp;            return model.getChildCount(treeRoot);
<i>4459</i>&nbsp;        }
<i>4460</i>&nbsp;
<i>4461</i>&nbsp;        /**
<i>4462</i>&nbsp;         * Return the nth Accessible child of the object.
<i>4463</i>&nbsp;         *
<i>4464</i>&nbsp;         * @param i zero-based index of child
<i>4465</i>&nbsp;         * @return the nth Accessible child of the object
<i>4466</i>&nbsp;         */
<b class="nc"><i>4467</i>&nbsp;        public Accessible getAccessibleChild(int i) {</b>
<b class="nc"><i>4468</i>&nbsp;            TreeModel model = JTree.this.getModel();</b>
<b class="nc"><i>4469</i>&nbsp;            if (model == null) {</b>
<b class="nc"><i>4470</i>&nbsp;                return null;</b>
<b class="nc"><i>4471</i>&nbsp;            }</b>
<b class="nc"><i>4472</i>&nbsp;</b>
<b class="nc"><i>4473</i>&nbsp;            Object treeRoot = model.getRoot();</b>
<b class="nc"><i>4474</i>&nbsp;            if (treeRoot == null) {</b>
<i>4475</i>&nbsp;                return null;
<i>4476</i>&nbsp;            }
<b class="nc"><i>4477</i>&nbsp;</b>
<i>4478</i>&nbsp;            if (isRootVisible()) {
<i>4479</i>&nbsp;                if (i == 0) {    // return the root node Accessible
<i>4480</i>&nbsp;                    Object[] objPath = { treeRoot };
<i>4481</i>&nbsp;                    TreePath path = new TreePath(objPath);
<i>4482</i>&nbsp;                    return new AccessibleJTreeNode(JTree.this, path, JTree.this);
<i>4483</i>&nbsp;                } else {
<i>4484</i>&nbsp;                    return null;
<i>4485</i>&nbsp;                }
<i>4486</i>&nbsp;            }
<i>4487</i>&nbsp;
<b class="nc"><i>4488</i>&nbsp;            // return Accessible for one of root&#39;s child nodes</b>
<b class="nc"><i>4489</i>&nbsp;            int count = model.getChildCount(treeRoot);</b>
<b class="nc"><i>4490</i>&nbsp;            if (i &lt; 0 || i &gt;= count) {</b>
<b class="nc"><i>4491</i>&nbsp;                return null;</b>
<b class="nc"><i>4492</i>&nbsp;            }</b>
<b class="nc"><i>4493</i>&nbsp;            Object obj = model.getChild(treeRoot, i);</b>
<b class="nc"><i>4494</i>&nbsp;            if (obj == null)</b>
<i>4495</i>&nbsp;                return null;
<b class="nc"><i>4496</i>&nbsp;</b>
<i>4497</i>&nbsp;            Object[] objPath = {treeRoot, obj };
<i>4498</i>&nbsp;
<i>4499</i>&nbsp;            TreePath path = new TreePath(objPath);
<i>4500</i>&nbsp;            return new AccessibleJTreeNode(JTree.this, path, JTree.this);
<i>4501</i>&nbsp;        }
<i>4502</i>&nbsp;
<i>4503</i>&nbsp;        /**
<i>4504</i>&nbsp;         * Get the index of this object in its accessible parent.
<i>4505</i>&nbsp;         *
<i>4506</i>&nbsp;         * @return the index of this object in its parent.  Since a JTree
<i>4507</i>&nbsp;         * top-level object does not have an accessible parent.
<i>4508</i>&nbsp;         * @see #getAccessibleParent
<i>4509</i>&nbsp;         */
<b class="nc"><i>4510</i>&nbsp;        public int getAccessibleIndexInParent() {</b>
<b class="nc"><i>4511</i>&nbsp;            // didn&#39;t ever need to override this...</b>
<b class="nc"><i>4512</i>&nbsp;            return super.getAccessibleIndexInParent();</b>
<b class="nc"><i>4513</i>&nbsp;        }</b>
<b class="nc"><i>4514</i>&nbsp;</b>
<i>4515</i>&nbsp;        // AccessibleSelection methods
<b class="nc"><i>4516</i>&nbsp;        /**</b>
<b class="nc"><i>4517</i>&nbsp;         * Get the AccessibleSelection associated with this object.  In the</b>
<i>4518</i>&nbsp;         * implementation of the Java Accessibility API for this class,
<i>4519</i>&nbsp;         * return this object, which is responsible for implementing the
<i>4520</i>&nbsp;         * AccessibleSelection interface on behalf of itself.
<i>4521</i>&nbsp;         *
<i>4522</i>&nbsp;         * @return this object
<i>4523</i>&nbsp;         */
<i>4524</i>&nbsp;        public AccessibleSelection getAccessibleSelection() {
<i>4525</i>&nbsp;            return this;
<i>4526</i>&nbsp;        }
<i>4527</i>&nbsp;
<i>4528</i>&nbsp;        /**
<i>4529</i>&nbsp;         * Returns the number of items currently selected.
<b class="nc"><i>4530</i>&nbsp;         * If no items are selected, the return value will be 0.</b>
<b class="nc"><i>4531</i>&nbsp;         *</b>
<b class="nc"><i>4532</i>&nbsp;         * @return the number of items currently selected.</b>
<b class="nc"><i>4533</i>&nbsp;         */</b>
<b class="nc"><i>4534</i>&nbsp;        public int getAccessibleSelectionCount() {</b>
<i>4535</i>&nbsp;            Object[] rootPath = new Object[1];
<b class="nc"><i>4536</i>&nbsp;            rootPath[0] = treeModel.getRoot();</b>
<b class="nc"><i>4537</i>&nbsp;            if (rootPath[0] == null)</b>
<i>4538</i>&nbsp;                return 0;
<i>4539</i>&nbsp;
<i>4540</i>&nbsp;            TreePath childPath = new TreePath(rootPath);
<i>4541</i>&nbsp;            if (JTree.this.isPathSelected(childPath)) {
<i>4542</i>&nbsp;                return 1;
<i>4543</i>&nbsp;            } else {
<i>4544</i>&nbsp;                return 0;
<i>4545</i>&nbsp;            }
<i>4546</i>&nbsp;        }
<b class="nc"><i>4547</i>&nbsp;</b>
<b class="nc"><i>4548</i>&nbsp;        /**</b>
<b class="nc"><i>4549</i>&nbsp;         * Returns an Accessible representing the specified selected item</b>
<i>4550</i>&nbsp;         * in the object.  If there isn&#39;t a selection, or there are
<i>4551</i>&nbsp;         * fewer items selected than the integer passed in, the return
<i>4552</i>&nbsp;         * value will be null.
<i>4553</i>&nbsp;         *
<i>4554</i>&nbsp;         * @param i the zero-based index of selected items
<i>4555</i>&nbsp;         * @return an Accessible containing the selected item
<i>4556</i>&nbsp;         */
<i>4557</i>&nbsp;        public Accessible getAccessibleSelection(int i) {
<b class="nc"><i>4558</i>&nbsp;            // The JTree can have only one accessible child, the root.</b>
<b class="nc"><i>4559</i>&nbsp;            if (i == 0) {</b>
<b class="nc"><i>4560</i>&nbsp;                Object[] rootPath = new Object[1];</b>
<b class="nc"><i>4561</i>&nbsp;                rootPath[0] = treeModel.getRoot();</b>
<i>4562</i>&nbsp;                if (rootPath[0] == null)
<b class="nc"><i>4563</i>&nbsp;                    return null;</b>
<b class="nc"><i>4564</i>&nbsp;</b>
<i>4565</i>&nbsp;                TreePath childPath = new TreePath(rootPath);
<i>4566</i>&nbsp;                if (JTree.this.isPathSelected(childPath)) {
<i>4567</i>&nbsp;                    return new AccessibleJTreeNode(JTree.this, childPath, JTree.this);
<i>4568</i>&nbsp;                }
<i>4569</i>&nbsp;            }
<i>4570</i>&nbsp;            return null;
<i>4571</i>&nbsp;        }
<i>4572</i>&nbsp;
<i>4573</i>&nbsp;        /**
<i>4574</i>&nbsp;         * Returns true if the current child of this object is selected.
<i>4575</i>&nbsp;         *
<i>4576</i>&nbsp;         * @param i the zero-based index of the child in this Accessible object.
<b class="nc"><i>4577</i>&nbsp;         * @see AccessibleContext#getAccessibleChild</b>
<b class="nc"><i>4578</i>&nbsp;         */</b>
<b class="nc"><i>4579</i>&nbsp;        public boolean isAccessibleChildSelected(int i) {</b>
<b class="nc"><i>4580</i>&nbsp;            // The JTree can have only one accessible child, the root.</b>
<b class="nc"><i>4581</i>&nbsp;            if (i == 0) {</b>
<b class="nc"><i>4582</i>&nbsp;                Object[] rootPath = new Object[1];</b>
<b class="nc"><i>4583</i>&nbsp;                rootPath[0] = treeModel.getRoot();</b>
<i>4584</i>&nbsp;                if (rootPath[0] == null)
<i>4585</i>&nbsp;                    return false;
<i>4586</i>&nbsp;
<i>4587</i>&nbsp;                TreePath childPath = new TreePath(rootPath);
<i>4588</i>&nbsp;                return JTree.this.isPathSelected(childPath);
<b class="nc"><i>4589</i>&nbsp;            } else {</b>
<b class="nc"><i>4590</i>&nbsp;                return false;</b>
<b class="nc"><i>4591</i>&nbsp;            }</b>
<b class="nc"><i>4592</i>&nbsp;        }</b>
<b class="nc"><i>4593</i>&nbsp;</b>
<b class="nc"><i>4594</i>&nbsp;        /**</b>
<b class="nc"><i>4595</i>&nbsp;         * Adds the specified selected item in the object to the object&#39;s</b>
<b class="nc"><i>4596</i>&nbsp;         * selection.  If the object supports multiple selections,</b>
<i>4597</i>&nbsp;         * the specified item is added to any existing selection, otherwise
<i>4598</i>&nbsp;         * it replaces any existing selection in the object.  If the
<i>4599</i>&nbsp;         * specified item is already selected, this method has no effect.
<i>4600</i>&nbsp;         *
<i>4601</i>&nbsp;         * @param i the zero-based index of selectable items
<i>4602</i>&nbsp;         */
<b class="nc"><i>4603</i>&nbsp;        public void addAccessibleSelection(int i) {</b>
<b class="nc"><i>4604</i>&nbsp;           TreeModel model = JTree.this.getModel();</b>
<i>4605</i>&nbsp;           if (model != null) {
<b class="nc"><i>4606</i>&nbsp;               if (i == 0) {</b>
<b class="nc"><i>4607</i>&nbsp;                    Object[] objPath = {model.getRoot()};</b>
<b class="nc"><i>4608</i>&nbsp;                    if (objPath[0] == null)</b>
<b class="nc"><i>4609</i>&nbsp;                        return;</b>
<b class="nc"><i>4610</i>&nbsp;</b>
<b class="nc"><i>4611</i>&nbsp;                   TreePath path = new TreePath(objPath);</b>
<i>4612</i>&nbsp;                   JTree.this.addSelectionPath(path);
<i>4613</i>&nbsp;                }
<i>4614</i>&nbsp;            }
<i>4615</i>&nbsp;        }
<i>4616</i>&nbsp;
<i>4617</i>&nbsp;        /**
<i>4618</i>&nbsp;         * Removes the specified selected item in the object from the object&#39;s
<i>4619</i>&nbsp;         * selection.  If the specified item isn&#39;t currently selected, this
<i>4620</i>&nbsp;         * method has no effect.
<i>4621</i>&nbsp;         *
<i>4622</i>&nbsp;         * @param i the zero-based index of selectable items
<i>4623</i>&nbsp;         */
<b class="nc"><i>4624</i>&nbsp;        public void removeAccessibleSelection(int i) {</b>
<i>4625</i>&nbsp;            TreeModel model = JTree.this.getModel();
<i>4626</i>&nbsp;            if (model != null) {
<i>4627</i>&nbsp;                if (i == 0) {
<b class="nc"><i>4628</i>&nbsp;                    Object[] objPath = {model.getRoot()};</b>
<b class="nc"><i>4629</i>&nbsp;                    if (objPath[0] == null)</b>
<b class="nc"><i>4630</i>&nbsp;                        return;</b>
<i>4631</i>&nbsp;
<b class="nc"><i>4632</i>&nbsp;                    TreePath path = new TreePath(objPath);</b>
<i>4633</i>&nbsp;                    JTree.this.removeSelectionPath(path);
<i>4634</i>&nbsp;                }
<i>4635</i>&nbsp;            }
<i>4636</i>&nbsp;        }
<i>4637</i>&nbsp;
<i>4638</i>&nbsp;        /**
<i>4639</i>&nbsp;         * Clears the selection in the object, so that nothing in the
<b class="nc"><i>4640</i>&nbsp;         * object is selected.</b>
<b class="nc"><i>4641</i>&nbsp;         */</b>
<b class="nc"><i>4642</i>&nbsp;        public void clearAccessibleSelection() {</b>
<b class="nc"><i>4643</i>&nbsp;            int childCount = getAccessibleChildrenCount();</b>
<i>4644</i>&nbsp;            for (int i = 0; i &lt; childCount; i++) {
<b class="nc"><i>4645</i>&nbsp;                removeAccessibleSelection(i);</b>
<b class="nc"><i>4646</i>&nbsp;            }</b>
<b class="nc"><i>4647</i>&nbsp;        }</b>
<b class="nc"><i>4648</i>&nbsp;</b>
<b class="nc"><i>4649</i>&nbsp;        /**</b>
<b class="nc"><i>4650</i>&nbsp;         * Causes every selected item in the object to be selected</b>
<b class="nc"><i>4651</i>&nbsp;         * if the object supports multiple selections.</b>
<i>4652</i>&nbsp;         */
<i>4653</i>&nbsp;        public void selectAllAccessibleSelection() {
<i>4654</i>&nbsp;            TreeModel model = JTree.this.getModel();
<b class="nc"><i>4655</i>&nbsp;            if (model != null) {</b>
<i>4656</i>&nbsp;                Object[] objPath = {model.getRoot()};
<i>4657</i>&nbsp;                if (objPath[0] == null)
<i>4658</i>&nbsp;                    return;
<i>4659</i>&nbsp;
<i>4660</i>&nbsp;                TreePath path = new TreePath(objPath);
<i>4661</i>&nbsp;                JTree.this.addSelectionPath(path);
<i>4662</i>&nbsp;            }
<i>4663</i>&nbsp;        }
<i>4664</i>&nbsp;
<i>4665</i>&nbsp;        /**
<i>4666</i>&nbsp;         * This class implements accessibility support for the
<b class="nc"><i>4667</i>&nbsp;         * &lt;code&gt;JTree&lt;/code&gt; child.  It provides an implementation of the</b>
<b class="nc"><i>4668</i>&nbsp;         * Java Accessibility API appropriate to tree nodes.</b>
<b class="nc"><i>4669</i>&nbsp;         */</b>
<b class="nc"><i>4670</i>&nbsp;        protected class AccessibleJTreeNode extends AccessibleContext</b>
<b class="nc"><i>4671</i>&nbsp;            implements Accessible, AccessibleComponent, AccessibleSelection,</b>
<i>4672</i>&nbsp;            AccessibleAction {
<b class="nc"><i>4673</i>&nbsp;</b>
<i>4674</i>&nbsp;            private JTree tree = null;
<i>4675</i>&nbsp;            private TreeModel treeModel = null;
<b class="nc"><i>4676</i>&nbsp;            private Object obj = null;</b>
<b class="nc"><i>4677</i>&nbsp;            private TreePath path = null;</b>
<i>4678</i>&nbsp;            private Accessible accessibleParent = null;
<i>4679</i>&nbsp;            private int index = 0;
<b class="nc"><i>4680</i>&nbsp;            private boolean isLeaf = false;</b>
<i>4681</i>&nbsp;
<i>4682</i>&nbsp;            /**
<i>4683</i>&nbsp;             * Constructs an AccessibleJTreeNode
<i>4684</i>&nbsp;             *
<i>4685</i>&nbsp;             * @param t an instance of {@code JTree}
<i>4686</i>&nbsp;             * @param p an instance of {@code TreePath}
<i>4687</i>&nbsp;             * @param ap an instance of {@code Accessible}
<i>4688</i>&nbsp;             * @since 1.4
<i>4689</i>&nbsp;             */
<b class="nc"><i>4690</i>&nbsp;            public AccessibleJTreeNode(JTree t, TreePath p, Accessible ap) {</b>
<b class="nc"><i>4691</i>&nbsp;                tree = t;</b>
<b class="nc"><i>4692</i>&nbsp;                path = p;</b>
<i>4693</i>&nbsp;                accessibleParent = ap;
<b class="nc"><i>4694</i>&nbsp;                treeModel = t.getModel();</b>
<i>4695</i>&nbsp;                obj = p.getLastPathComponent();
<i>4696</i>&nbsp;                if (treeModel != null) {
<i>4697</i>&nbsp;                    isLeaf = treeModel.isLeaf(obj);
<i>4698</i>&nbsp;                }
<i>4699</i>&nbsp;            }
<i>4700</i>&nbsp;
<i>4701</i>&nbsp;            private TreePath getChildTreePath(int i) {
<i>4702</i>&nbsp;                // Tree nodes can&#39;t be so complex that they have
<i>4703</i>&nbsp;                // two sets of children -&gt; we&#39;re ignoring that case
<i>4704</i>&nbsp;                if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {
<i>4705</i>&nbsp;                    return null;
<i>4706</i>&nbsp;                } else {
<i>4707</i>&nbsp;                    Object childObj = treeModel.getChild(obj, i);
<b class="nc"><i>4708</i>&nbsp;                    Object[] objPath = path.getPath();</b>
<b class="nc"><i>4709</i>&nbsp;                    Object[] objChildPath = new Object[objPath.length+1];</b>
<b class="nc"><i>4710</i>&nbsp;                    java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);</b>
<i>4711</i>&nbsp;                    objChildPath[objChildPath.length-1] = childObj;
<b class="nc"><i>4712</i>&nbsp;                    return new TreePath(objChildPath);</b>
<i>4713</i>&nbsp;                }
<i>4714</i>&nbsp;            }
<i>4715</i>&nbsp;
<i>4716</i>&nbsp;            /**
<i>4717</i>&nbsp;             * Get the AccessibleContext associated with this tree node.
<i>4718</i>&nbsp;             * In the implementation of the Java Accessibility API for
<i>4719</i>&nbsp;             * this class, return this object, which is its own
<i>4720</i>&nbsp;             * AccessibleContext.
<i>4721</i>&nbsp;             *
<b class="nc"><i>4722</i>&nbsp;             * @return this object</b>
<b class="nc"><i>4723</i>&nbsp;             */</b>
<b class="nc"><i>4724</i>&nbsp;            public AccessibleContext getAccessibleContext() {</b>
<i>4725</i>&nbsp;                return this;
<b class="nc"><i>4726</i>&nbsp;            }</b>
<i>4727</i>&nbsp;
<i>4728</i>&nbsp;            private AccessibleContext getCurrentAccessibleContext() {
<i>4729</i>&nbsp;                Component c = getCurrentComponent();
<i>4730</i>&nbsp;                if (c instanceof Accessible) {
<i>4731</i>&nbsp;                    return c.getAccessibleContext();
<i>4732</i>&nbsp;                } else {
<i>4733</i>&nbsp;                    return null;
<i>4734</i>&nbsp;                }
<i>4735</i>&nbsp;            }
<i>4736</i>&nbsp;
<b class="nc"><i>4737</i>&nbsp;            private Component getCurrentComponent() {</b>
<b class="nc"><i>4738</i>&nbsp;                // is the object visible?</b>
<b class="nc"><i>4739</i>&nbsp;                // if so, get row, selected, focus &amp; leaf state,</b>
<i>4740</i>&nbsp;                // and then get the renderer component and return it
<b class="nc"><i>4741</i>&nbsp;                if (tree.isVisible(path)) {</b>
<i>4742</i>&nbsp;                    TreeCellRenderer r = tree.getCellRenderer();
<i>4743</i>&nbsp;                    if (r == null) {
<i>4744</i>&nbsp;                        return null;
<i>4745</i>&nbsp;                    }
<i>4746</i>&nbsp;                    TreeUI ui = tree.getUI();
<i>4747</i>&nbsp;                    if (ui != null) {
<i>4748</i>&nbsp;                        int row = ui.getRowForPath(JTree.this, path);
<i>4749</i>&nbsp;                        boolean selected = tree.isPathSelected(path);
<i>4750</i>&nbsp;                        boolean expanded = tree.isExpanded(path);
<i>4751</i>&nbsp;                        boolean hasFocus = false; // how to tell?? -PK
<i>4752</i>&nbsp;                        return r.getTreeCellRendererComponent(tree, obj,
<b class="nc"><i>4753</i>&nbsp;                            selected, expanded, isLeaf, row, hasFocus);</b>
<i>4754</i>&nbsp;                    }
<b class="nc"><i>4755</i>&nbsp;                }</b>
<b class="nc"><i>4756</i>&nbsp;                return null;</b>
<i>4757</i>&nbsp;            }
<b class="nc"><i>4758</i>&nbsp;</b>
<i>4759</i>&nbsp;        // AccessibleContext methods
<i>4760</i>&nbsp;
<i>4761</i>&nbsp;             /**
<b class="nc"><i>4762</i>&nbsp;              * Get the accessible name of this object.</b>
<b class="nc"><i>4763</i>&nbsp;              *</b>
<b class="nc"><i>4764</i>&nbsp;              * @return the localized name of the object; null if this</b>
<b class="nc"><i>4765</i>&nbsp;              * object does not have a name</b>
<i>4766</i>&nbsp;              */
<b class="nc"><i>4767</i>&nbsp;             public String getAccessibleName() {</b>
<b class="nc"><i>4768</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>4769</i>&nbsp;                if (ac != null) {</b>
<b class="nc"><i>4770</i>&nbsp;                    String name = ac.getAccessibleName();</b>
<i>4771</i>&nbsp;                    if ((name != null) &amp;&amp; (name != &quot;&quot;)) {
<b class="nc"><i>4772</i>&nbsp;                        return ac.getAccessibleName();</b>
<b class="nc"><i>4773</i>&nbsp;                    } else {</b>
<i>4774</i>&nbsp;                        return null;
<b class="nc"><i>4775</i>&nbsp;                    }</b>
<b class="nc"><i>4776</i>&nbsp;                }</b>
<i>4777</i>&nbsp;                if ((accessibleName != null) &amp;&amp; (accessibleName != &quot;&quot;)) {
<b class="nc"><i>4778</i>&nbsp;                    return accessibleName;</b>
<b class="nc"><i>4779</i>&nbsp;                } else {</b>
<i>4780</i>&nbsp;                    // fall back to the client property
<b class="nc"><i>4781</i>&nbsp;                    return (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);</b>
<b class="nc"><i>4782</i>&nbsp;                }</b>
<i>4783</i>&nbsp;            }
<b class="nc"><i>4784</i>&nbsp;</b>
<i>4785</i>&nbsp;            /**
<b class="nc"><i>4786</i>&nbsp;             * Set the localized accessible name of this object.</b>
<b class="nc"><i>4787</i>&nbsp;             *</b>
<i>4788</i>&nbsp;             * @param s the new localized name of the object.
<b class="nc"><i>4789</i>&nbsp;             */</b>
<i>4790</i>&nbsp;            public void setAccessibleName(String s) {
<i>4791</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>4792</i>&nbsp;                if (ac != null) {
<i>4793</i>&nbsp;                    ac.setAccessibleName(s);
<i>4794</i>&nbsp;                } else {
<i>4795</i>&nbsp;                    super.setAccessibleName(s);
<i>4796</i>&nbsp;                }
<i>4797</i>&nbsp;            }
<i>4798</i>&nbsp;
<i>4799</i>&nbsp;            //
<i>4800</i>&nbsp;            // *** should check tooltip text for desc. (needs MouseEvent)
<b class="nc"><i>4801</i>&nbsp;            //</b>
<b class="nc"><i>4802</i>&nbsp;            /**</b>
<b class="nc"><i>4803</i>&nbsp;             * Get the accessible description of this object.</b>
<b class="nc"><i>4804</i>&nbsp;             *</b>
<b class="nc"><i>4805</i>&nbsp;             * @return the localized description of the object; null if</b>
<b class="nc"><i>4806</i>&nbsp;             * this object does not have a description</b>
<i>4807</i>&nbsp;             */
<b class="nc"><i>4808</i>&nbsp;            public String getAccessibleDescription() {</b>
<b class="nc"><i>4809</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<i>4810</i>&nbsp;                if (ac != null) {
<b class="nc"><i>4811</i>&nbsp;                    return ac.getAccessibleDescription();</b>
<b class="nc"><i>4812</i>&nbsp;                } else {</b>
<i>4813</i>&nbsp;                    return super.getAccessibleDescription();
<i>4814</i>&nbsp;                }
<b class="nc"><i>4815</i>&nbsp;            }</b>
<b class="nc"><i>4816</i>&nbsp;</b>
<b class="nc"><i>4817</i>&nbsp;            /**</b>
<b class="nc"><i>4818</i>&nbsp;             * Set the accessible description of this object.</b>
<b class="nc"><i>4819</i>&nbsp;             *</b>
<i>4820</i>&nbsp;             * @param s the new localized description of the object
<i>4821</i>&nbsp;             */
<b class="nc"><i>4822</i>&nbsp;            public void setAccessibleDescription(String s) {</b>
<i>4823</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>4824</i>&nbsp;                if (ac != null) {
<i>4825</i>&nbsp;                    ac.setAccessibleDescription(s);
<i>4826</i>&nbsp;                } else {
<i>4827</i>&nbsp;                    super.setAccessibleDescription(s);
<i>4828</i>&nbsp;                }
<i>4829</i>&nbsp;            }
<i>4830</i>&nbsp;
<i>4831</i>&nbsp;            /**
<i>4832</i>&nbsp;             * Get the role of this object.
<i>4833</i>&nbsp;             *
<b class="nc"><i>4834</i>&nbsp;             * @return an instance of AccessibleRole describing the role of the object</b>
<b class="nc"><i>4835</i>&nbsp;             * @see AccessibleRole</b>
<i>4836</i>&nbsp;             */
<b class="nc"><i>4837</i>&nbsp;            public AccessibleRole getAccessibleRole() {</b>
<b class="nc"><i>4838</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>4839</i>&nbsp;                if (ac != null) {</b>
<b class="nc"><i>4840</i>&nbsp;                    return ac.getAccessibleRole();</b>
<b class="nc"><i>4841</i>&nbsp;                } else {</b>
<i>4842</i>&nbsp;                    return AccessibleRole.UNKNOWN;
<i>4843</i>&nbsp;                }
<b class="nc"><i>4844</i>&nbsp;            }</b>
<i>4845</i>&nbsp;
<i>4846</i>&nbsp;            /**
<i>4847</i>&nbsp;             * Get the state set of this object.
<i>4848</i>&nbsp;             *
<i>4849</i>&nbsp;             * @return an instance of AccessibleStateSet containing the
<i>4850</i>&nbsp;             * current state set of the object
<i>4851</i>&nbsp;             * @see AccessibleState
<i>4852</i>&nbsp;             */
<i>4853</i>&nbsp;            public AccessibleStateSet getAccessibleStateSet() {
<i>4854</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<b class="nc"><i>4855</i>&nbsp;                AccessibleStateSet states;</b>
<i>4856</i>&nbsp;                if (ac != null) {
<i>4857</i>&nbsp;                    states = ac.getAccessibleStateSet();
<i>4858</i>&nbsp;                } else {
<i>4859</i>&nbsp;                    states = new AccessibleStateSet();
<i>4860</i>&nbsp;                }
<i>4861</i>&nbsp;                // need to test here, &#39;cause the underlying component
<i>4862</i>&nbsp;                // is a cellRenderer, which is never showing...
<i>4863</i>&nbsp;                if (isShowing()) {
<i>4864</i>&nbsp;                    states.add(AccessibleState.SHOWING);
<i>4865</i>&nbsp;                } else if (states.contains(AccessibleState.SHOWING)) {
<i>4866</i>&nbsp;                    states.remove(AccessibleState.SHOWING);
<b class="nc"><i>4867</i>&nbsp;                }</b>
<b class="nc"><i>4868</i>&nbsp;                if (isVisible()) {</b>
<i>4869</i>&nbsp;                    states.add(AccessibleState.VISIBLE);
<b class="nc"><i>4870</i>&nbsp;                } else if (states.contains(AccessibleState.VISIBLE)) {</b>
<b class="nc"><i>4871</i>&nbsp;                    states.remove(AccessibleState.VISIBLE);</b>
<b class="nc"><i>4872</i>&nbsp;                }</b>
<b class="nc"><i>4873</i>&nbsp;                if (tree.isPathSelected(path)){</b>
<b class="nc"><i>4874</i>&nbsp;                    states.add(AccessibleState.SELECTED);</b>
<b class="nc"><i>4875</i>&nbsp;                }</b>
<b class="nc"><i>4876</i>&nbsp;                if (path == getLeadSelectionPath()) {</b>
<i>4877</i>&nbsp;                    states.add(AccessibleState.ACTIVE);
<i>4878</i>&nbsp;                }
<i>4879</i>&nbsp;                if (!isLeaf) {
<i>4880</i>&nbsp;                    states.add(AccessibleState.EXPANDABLE);
<i>4881</i>&nbsp;                }
<i>4882</i>&nbsp;                if (tree.isExpanded(path)) {
<i>4883</i>&nbsp;                    states.add(AccessibleState.EXPANDED);
<i>4884</i>&nbsp;                } else {
<i>4885</i>&nbsp;                    states.add(AccessibleState.COLLAPSED);
<i>4886</i>&nbsp;                }
<i>4887</i>&nbsp;                if (tree.isEditable()) {
<i>4888</i>&nbsp;                    states.add(AccessibleState.EDITABLE);
<i>4889</i>&nbsp;                }
<i>4890</i>&nbsp;                return states;
<i>4891</i>&nbsp;            }
<i>4892</i>&nbsp;
<b class="nc"><i>4893</i>&nbsp;            /**</b>
<b class="nc"><i>4894</i>&nbsp;             * Get the Accessible parent of this object.</b>
<b class="nc"><i>4895</i>&nbsp;             *</b>
<i>4896</i>&nbsp;             * @return the Accessible parent of this object; null if this
<b class="nc"><i>4897</i>&nbsp;             * object does not have an Accessible parent</b>
<i>4898</i>&nbsp;             */
<i>4899</i>&nbsp;            public Accessible getAccessibleParent() {
<i>4900</i>&nbsp;                // someone wants to know, so we need to create our parent
<i>4901</i>&nbsp;                // if we don&#39;t have one (hey, we&#39;re a talented kid!)
<i>4902</i>&nbsp;                if (accessibleParent == null) {
<i>4903</i>&nbsp;                    Object[] objPath = path.getPath();
<i>4904</i>&nbsp;                    if (objPath.length &gt; 1) {
<i>4905</i>&nbsp;                        Object objParent = objPath[objPath.length-2];
<i>4906</i>&nbsp;                        if (treeModel != null) {
<i>4907</i>&nbsp;                            index = treeModel.getIndexOfChild(objParent, obj);
<b class="nc"><i>4908</i>&nbsp;                        }</b>
<b class="nc"><i>4909</i>&nbsp;                        Object[] objParentPath = new Object[objPath.length-1];</b>
<b class="nc"><i>4910</i>&nbsp;                        java.lang.System.arraycopy(objPath, 0, objParentPath,</b>
<i>4911</i>&nbsp;                                                   0, objPath.length-1);
<b class="nc"><i>4912</i>&nbsp;                        TreePath parentPath = new TreePath(objParentPath);</b>
<i>4913</i>&nbsp;                        accessibleParent = new AccessibleJTreeNode(tree,
<i>4914</i>&nbsp;                                                                   parentPath,
<i>4915</i>&nbsp;                                                                   null);
<i>4916</i>&nbsp;                        this.setAccessibleParent(accessibleParent);
<i>4917</i>&nbsp;                    } else if (treeModel != null) {
<i>4918</i>&nbsp;                        accessibleParent = tree; // we&#39;re the top!
<i>4919</i>&nbsp;                        index = 0; // we&#39;re an only child!
<i>4920</i>&nbsp;                        this.setAccessibleParent(accessibleParent);
<i>4921</i>&nbsp;                    }
<i>4922</i>&nbsp;                }
<i>4923</i>&nbsp;                return accessibleParent;
<b class="nc"><i>4924</i>&nbsp;            }</b>
<b class="nc"><i>4925</i>&nbsp;</b>
<b class="nc"><i>4926</i>&nbsp;            /**</b>
<i>4927</i>&nbsp;             * Get the index of this object in its accessible parent.
<b class="nc"><i>4928</i>&nbsp;             *</b>
<i>4929</i>&nbsp;             * @return the index of this object in its parent; -1 if this
<i>4930</i>&nbsp;             * object does not have an accessible parent.
<i>4931</i>&nbsp;             * @see #getAccessibleParent
<i>4932</i>&nbsp;             */
<i>4933</i>&nbsp;            public int getAccessibleIndexInParent() {
<i>4934</i>&nbsp;                // index is invalid &#39;till we have an accessibleParent...
<i>4935</i>&nbsp;                if (accessibleParent == null) {
<i>4936</i>&nbsp;                    getAccessibleParent();
<i>4937</i>&nbsp;                }
<i>4938</i>&nbsp;                Object[] objPath = path.getPath();
<i>4939</i>&nbsp;                if (objPath.length &gt; 1) {
<i>4940</i>&nbsp;                    Object objParent = objPath[objPath.length-2];
<b class="nc"><i>4941</i>&nbsp;                    if (treeModel != null) {</b>
<i>4942</i>&nbsp;                        index = treeModel.getIndexOfChild(objParent, obj);
<i>4943</i>&nbsp;                    }
<i>4944</i>&nbsp;                }
<i>4945</i>&nbsp;                return index;
<i>4946</i>&nbsp;            }
<i>4947</i>&nbsp;
<i>4948</i>&nbsp;            /**
<i>4949</i>&nbsp;             * Returns the number of accessible children in the object.
<i>4950</i>&nbsp;             *
<i>4951</i>&nbsp;             * @return the number of accessible children in the object.
<i>4952</i>&nbsp;             */
<b class="nc"><i>4953</i>&nbsp;            public int getAccessibleChildrenCount() {</b>
<i>4954</i>&nbsp;                // Tree nodes can&#39;t be so complex that they have
<i>4955</i>&nbsp;                // two sets of children -&gt; we&#39;re ignoring that case
<i>4956</i>&nbsp;                return treeModel.getChildCount(obj);
<i>4957</i>&nbsp;            }
<i>4958</i>&nbsp;
<i>4959</i>&nbsp;            /**
<i>4960</i>&nbsp;             * Return the specified Accessible child of the object.
<i>4961</i>&nbsp;             *
<i>4962</i>&nbsp;             * @param i zero-based index of child
<b class="nc"><i>4963</i>&nbsp;             * @return the Accessible child of the object</b>
<b class="nc"><i>4964</i>&nbsp;             */</b>
<b class="nc"><i>4965</i>&nbsp;            public Accessible getAccessibleChild(int i) {</b>
<i>4966</i>&nbsp;                // Tree nodes can&#39;t be so complex that they have
<b class="nc"><i>4967</i>&nbsp;                // two sets of children -&gt; we&#39;re ignoring that case</b>
<i>4968</i>&nbsp;                if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {
<i>4969</i>&nbsp;                    return null;
<i>4970</i>&nbsp;                } else {
<i>4971</i>&nbsp;                    Object childObj = treeModel.getChild(obj, i);
<i>4972</i>&nbsp;                    Object[] objPath = path.getPath();
<i>4973</i>&nbsp;                    Object[] objChildPath = new Object[objPath.length+1];
<i>4974</i>&nbsp;                    java.lang.System.arraycopy(objPath, 0, objChildPath, 0, objPath.length);
<i>4975</i>&nbsp;                    objChildPath[objChildPath.length-1] = childObj;
<i>4976</i>&nbsp;                    TreePath childPath = new TreePath(objChildPath);
<i>4977</i>&nbsp;                    return new AccessibleJTreeNode(JTree.this, childPath, this);
<b class="nc"><i>4978</i>&nbsp;                }</b>
<b class="nc"><i>4979</i>&nbsp;            }</b>
<b class="nc"><i>4980</i>&nbsp;</b>
<i>4981</i>&nbsp;            /**
<b class="nc"><i>4982</i>&nbsp;             * Gets the locale of the component. If the component does not have</b>
<i>4983</i>&nbsp;             * a locale, then the locale of its parent is returned.
<i>4984</i>&nbsp;             *
<i>4985</i>&nbsp;             * @return This component&#39;s locale. If this component does not have
<i>4986</i>&nbsp;             * a locale, the locale of its parent is returned.
<i>4987</i>&nbsp;             * @exception IllegalComponentStateException
<i>4988</i>&nbsp;             * If the Component does not have its own locale and has not yet
<i>4989</i>&nbsp;             * been added to a containment hierarchy such that the locale can be
<i>4990</i>&nbsp;             * determined from the containing parent.
<i>4991</i>&nbsp;             * @see #setLocale
<i>4992</i>&nbsp;             */
<b class="nc"><i>4993</i>&nbsp;            public Locale getLocale() {</b>
<b class="nc"><i>4994</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>4995</i>&nbsp;                if (ac != null) {</b>
<i>4996</i>&nbsp;                    return ac.getLocale();
<b class="nc"><i>4997</i>&nbsp;                } else {</b>
<i>4998</i>&nbsp;                    return tree.getLocale();
<i>4999</i>&nbsp;                }
<i>5000</i>&nbsp;            }
<i>5001</i>&nbsp;
<i>5002</i>&nbsp;            /**
<i>5003</i>&nbsp;             * Add a PropertyChangeListener to the listener list.
<i>5004</i>&nbsp;             * The listener is registered for all properties.
<i>5005</i>&nbsp;             *
<i>5006</i>&nbsp;             * @param l  The PropertyChangeListener to be added
<i>5007</i>&nbsp;             */
<i>5008</i>&nbsp;            public void addPropertyChangeListener(PropertyChangeListener l) {
<i>5009</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5010</i>&nbsp;                if (ac != null) {
<b class="nc"><i>5011</i>&nbsp;                    ac.addPropertyChangeListener(l);</b>
<b class="nc"><i>5012</i>&nbsp;                } else {</b>
<b class="nc"><i>5013</i>&nbsp;                    super.addPropertyChangeListener(l);</b>
<i>5014</i>&nbsp;                }
<b class="nc"><i>5015</i>&nbsp;            }</b>
<b class="nc"><i>5016</i>&nbsp;</b>
<b class="nc"><i>5017</i>&nbsp;            /**</b>
<i>5018</i>&nbsp;             * Remove a PropertyChangeListener from the listener list.
<b class="nc"><i>5019</i>&nbsp;             * This removes a PropertyChangeListener that was registered</b>
<i>5020</i>&nbsp;             * for all properties.
<i>5021</i>&nbsp;             *
<i>5022</i>&nbsp;             * @param l  The PropertyChangeListener to be removed
<i>5023</i>&nbsp;             */
<i>5024</i>&nbsp;            public void removePropertyChangeListener(PropertyChangeListener l) {
<i>5025</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5026</i>&nbsp;                if (ac != null) {
<i>5027</i>&nbsp;                    ac.removePropertyChangeListener(l);
<i>5028</i>&nbsp;                } else {
<i>5029</i>&nbsp;                    super.removePropertyChangeListener(l);
<b class="nc"><i>5030</i>&nbsp;                }</b>
<b class="nc"><i>5031</i>&nbsp;            }</b>
<b class="nc"><i>5032</i>&nbsp;</b>
<i>5033</i>&nbsp;            /**
<b class="nc"><i>5034</i>&nbsp;             * Get the AccessibleAction associated with this object.  In the</b>
<b class="nc"><i>5035</i>&nbsp;             * implementation of the Java Accessibility API for this class,</b>
<b class="nc"><i>5036</i>&nbsp;             * return this object, which is responsible for implementing the</b>
<i>5037</i>&nbsp;             * AccessibleAction interface on behalf of itself.
<i>5038</i>&nbsp;             *
<i>5039</i>&nbsp;             * @return this object
<i>5040</i>&nbsp;             */
<i>5041</i>&nbsp;            public AccessibleAction getAccessibleAction() {
<i>5042</i>&nbsp;                return this;
<i>5043</i>&nbsp;            }
<i>5044</i>&nbsp;
<i>5045</i>&nbsp;            /**
<i>5046</i>&nbsp;             * Get the AccessibleComponent associated with this object.  In the
<i>5047</i>&nbsp;             * implementation of the Java Accessibility API for this class,
<i>5048</i>&nbsp;             * return this object, which is responsible for implementing the
<b class="nc"><i>5049</i>&nbsp;             * AccessibleComponent interface on behalf of itself.</b>
<b class="nc"><i>5050</i>&nbsp;             *</b>
<b class="nc"><i>5051</i>&nbsp;             * @return this object</b>
<i>5052</i>&nbsp;             */
<b class="nc"><i>5053</i>&nbsp;            public AccessibleComponent getAccessibleComponent() {</b>
<b class="nc"><i>5054</i>&nbsp;                return this; // to override getBounds()</b>
<b class="nc"><i>5055</i>&nbsp;            }</b>
<i>5056</i>&nbsp;
<b class="nc"><i>5057</i>&nbsp;            /**</b>
<i>5058</i>&nbsp;             * Get the AccessibleSelection associated with this object if one
<i>5059</i>&nbsp;             * exists.  Otherwise return null.
<i>5060</i>&nbsp;             *
<i>5061</i>&nbsp;             * @return the AccessibleSelection, or null
<i>5062</i>&nbsp;             */
<b class="nc"><i>5063</i>&nbsp;            public AccessibleSelection getAccessibleSelection() {</b>
<b class="nc"><i>5064</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5065</i>&nbsp;                if (ac != null &amp;&amp; isLeaf) {</b>
<i>5066</i>&nbsp;                    return getCurrentAccessibleContext().getAccessibleSelection();
<b class="nc"><i>5067</i>&nbsp;                } else {</b>
<b class="nc"><i>5068</i>&nbsp;                    return this;</b>
<b class="nc"><i>5069</i>&nbsp;                }</b>
<i>5070</i>&nbsp;            }
<i>5071</i>&nbsp;
<i>5072</i>&nbsp;            /**
<i>5073</i>&nbsp;             * Get the AccessibleText associated with this object if one
<i>5074</i>&nbsp;             * exists.  Otherwise return null.
<b class="nc"><i>5075</i>&nbsp;             *</b>
<b class="nc"><i>5076</i>&nbsp;             * @return the AccessibleText, or null</b>
<b class="nc"><i>5077</i>&nbsp;             */</b>
<i>5078</i>&nbsp;            public AccessibleText getAccessibleText() {
<b class="nc"><i>5079</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5080</i>&nbsp;                if (ac != null) {</b>
<b class="nc"><i>5081</i>&nbsp;                    return getCurrentAccessibleContext().getAccessibleText();</b>
<i>5082</i>&nbsp;                } else {
<b class="nc"><i>5083</i>&nbsp;                    return null;</b>
<b class="nc"><i>5084</i>&nbsp;                }</b>
<b class="nc"><i>5085</i>&nbsp;            }</b>
<i>5086</i>&nbsp;
<b class="nc"><i>5087</i>&nbsp;            /**</b>
<i>5088</i>&nbsp;             * Get the AccessibleValue associated with this object if one
<i>5089</i>&nbsp;             * exists.  Otherwise return null.
<i>5090</i>&nbsp;             *
<i>5091</i>&nbsp;             * @return the AccessibleValue, or null
<i>5092</i>&nbsp;             */
<i>5093</i>&nbsp;            public AccessibleValue getAccessibleValue() {
<b class="nc"><i>5094</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5095</i>&nbsp;                if (ac != null) {</b>
<b class="nc"><i>5096</i>&nbsp;                    return getCurrentAccessibleContext().getAccessibleValue();</b>
<i>5097</i>&nbsp;                } else {
<b class="nc"><i>5098</i>&nbsp;                    return null;</b>
<b class="nc"><i>5099</i>&nbsp;                }</b>
<b class="nc"><i>5100</i>&nbsp;            }</b>
<i>5101</i>&nbsp;
<i>5102</i>&nbsp;
<i>5103</i>&nbsp;        // AccessibleComponent methods
<i>5104</i>&nbsp;
<i>5105</i>&nbsp;            /**
<b class="nc"><i>5106</i>&nbsp;             * Get the background color of this object.</b>
<b class="nc"><i>5107</i>&nbsp;             *</b>
<b class="nc"><i>5108</i>&nbsp;             * @return the background color, if supported, of the object;</b>
<i>5109</i>&nbsp;             * otherwise, null
<b class="nc"><i>5110</i>&nbsp;             */</b>
<b class="nc"><i>5111</i>&nbsp;            public Color getBackground() {</b>
<b class="nc"><i>5112</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<i>5113</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<b class="nc"><i>5114</i>&nbsp;                    return ((AccessibleComponent) ac).getBackground();</b>
<i>5115</i>&nbsp;                } else {
<i>5116</i>&nbsp;                    Component c = getCurrentComponent();
<i>5117</i>&nbsp;                    if (c != null) {
<i>5118</i>&nbsp;                        return c.getBackground();
<i>5119</i>&nbsp;                    } else {
<b class="nc"><i>5120</i>&nbsp;                        return null;</b>
<b class="nc"><i>5121</i>&nbsp;                    }</b>
<b class="nc"><i>5122</i>&nbsp;                }</b>
<i>5123</i>&nbsp;            }
<b class="nc"><i>5124</i>&nbsp;</b>
<b class="nc"><i>5125</i>&nbsp;            /**</b>
<b class="nc"><i>5126</i>&nbsp;             * Set the background color of this object.</b>
<i>5127</i>&nbsp;             *
<i>5128</i>&nbsp;             * @param c the new Color for the background
<i>5129</i>&nbsp;             */
<i>5130</i>&nbsp;            public void setBackground(Color c) {
<i>5131</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<b class="nc"><i>5132</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5133</i>&nbsp;                    ((AccessibleComponent) ac).setBackground(c);</b>
<b class="nc"><i>5134</i>&nbsp;                } else {</b>
<i>5135</i>&nbsp;                    Component cp = getCurrentComponent();
<b class="nc"><i>5136</i>&nbsp;                    if (cp != null) {</b>
<b class="nc"><i>5137</i>&nbsp;                        cp.setBackground(c);</b>
<b class="nc"><i>5138</i>&nbsp;                    }</b>
<i>5139</i>&nbsp;                }
<b class="nc"><i>5140</i>&nbsp;            }</b>
<i>5141</i>&nbsp;
<i>5142</i>&nbsp;
<i>5143</i>&nbsp;            /**
<i>5144</i>&nbsp;             * Get the foreground color of this object.
<i>5145</i>&nbsp;             *
<b class="nc"><i>5146</i>&nbsp;             * @return the foreground color, if supported, of the object;</b>
<b class="nc"><i>5147</i>&nbsp;             * otherwise, null</b>
<b class="nc"><i>5148</i>&nbsp;             */</b>
<i>5149</i>&nbsp;            public Color getForeground() {
<b class="nc"><i>5150</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5151</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5152</i>&nbsp;                    return ((AccessibleComponent) ac).getForeground();</b>
<i>5153</i>&nbsp;                } else {
<b class="nc"><i>5154</i>&nbsp;                    Component c = getCurrentComponent();</b>
<i>5155</i>&nbsp;                    if (c != null) {
<i>5156</i>&nbsp;                        return c.getForeground();
<i>5157</i>&nbsp;                    } else {
<i>5158</i>&nbsp;                        return null;
<i>5159</i>&nbsp;                    }
<b class="nc"><i>5160</i>&nbsp;                }</b>
<b class="nc"><i>5161</i>&nbsp;            }</b>
<b class="nc"><i>5162</i>&nbsp;</b>
<i>5163</i>&nbsp;            public void setForeground(Color c) {
<b class="nc"><i>5164</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5165</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5166</i>&nbsp;                    ((AccessibleComponent) ac).setForeground(c);</b>
<i>5167</i>&nbsp;                } else {
<i>5168</i>&nbsp;                    Component cp = getCurrentComponent();
<i>5169</i>&nbsp;                    if (cp != null) {
<i>5170</i>&nbsp;                        cp.setForeground(c);
<i>5171</i>&nbsp;                    }
<b class="nc"><i>5172</i>&nbsp;                }</b>
<b class="nc"><i>5173</i>&nbsp;            }</b>
<b class="nc"><i>5174</i>&nbsp;</b>
<b class="nc"><i>5175</i>&nbsp;            public Cursor getCursor() {</b>
<i>5176</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5177</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5178</i>&nbsp;                    return ((AccessibleComponent) ac).getCursor();
<i>5179</i>&nbsp;                } else {
<i>5180</i>&nbsp;                    Component c = getCurrentComponent();
<i>5181</i>&nbsp;                    if (c != null) {
<b class="nc"><i>5182</i>&nbsp;                        return c.getCursor();</b>
<i>5183</i>&nbsp;                    } else {
<i>5184</i>&nbsp;                        Accessible ap = getAccessibleParent();
<i>5185</i>&nbsp;                        if (ap instanceof AccessibleComponent) {
<b class="nc"><i>5186</i>&nbsp;                            return ((AccessibleComponent) ap).getCursor();</b>
<b class="nc"><i>5187</i>&nbsp;                        } else {</b>
<b class="nc"><i>5188</i>&nbsp;                            return null;</b>
<b class="nc"><i>5189</i>&nbsp;                        }</b>
<i>5190</i>&nbsp;                    }
<b class="nc"><i>5191</i>&nbsp;                }</b>
<b class="nc"><i>5192</i>&nbsp;            }</b>
<b class="nc"><i>5193</i>&nbsp;</b>
<b class="nc"><i>5194</i>&nbsp;            public void setCursor(Cursor c) {</b>
<i>5195</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<b class="nc"><i>5196</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<i>5197</i>&nbsp;                    ((AccessibleComponent) ac).setCursor(c);
<i>5198</i>&nbsp;                } else {
<i>5199</i>&nbsp;                    Component cp = getCurrentComponent();
<i>5200</i>&nbsp;                    if (cp != null) {
<i>5201</i>&nbsp;                        cp.setCursor(c);
<b class="nc"><i>5202</i>&nbsp;                    }</b>
<b class="nc"><i>5203</i>&nbsp;                }</b>
<b class="nc"><i>5204</i>&nbsp;            }</b>
<b class="nc"><i>5205</i>&nbsp;</b>
<b class="nc"><i>5206</i>&nbsp;            public Font getFont() {</b>
<i>5207</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<b class="nc"><i>5208</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5209</i>&nbsp;                    return ((AccessibleComponent) ac).getFont();</b>
<i>5210</i>&nbsp;                } else {
<b class="nc"><i>5211</i>&nbsp;                    Component c = getCurrentComponent();</b>
<i>5212</i>&nbsp;                    if (c != null) {
<i>5213</i>&nbsp;                        return c.getFont();
<b class="nc"><i>5214</i>&nbsp;                    } else {</b>
<i>5215</i>&nbsp;                        return null;
<i>5216</i>&nbsp;                    }
<i>5217</i>&nbsp;                }
<i>5218</i>&nbsp;            }
<b class="nc"><i>5219</i>&nbsp;</b>
<b class="nc"><i>5220</i>&nbsp;            public void setFont(Font f) {</b>
<b class="nc"><i>5221</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<i>5222</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<b class="nc"><i>5223</i>&nbsp;                    ((AccessibleComponent) ac).setFont(f);</b>
<i>5224</i>&nbsp;                } else {
<i>5225</i>&nbsp;                    Component c = getCurrentComponent();
<i>5226</i>&nbsp;                    if (c != null) {
<i>5227</i>&nbsp;                        c.setFont(f);
<b class="nc"><i>5228</i>&nbsp;                    }</b>
<b class="nc"><i>5229</i>&nbsp;                }</b>
<b class="nc"><i>5230</i>&nbsp;            }</b>
<i>5231</i>&nbsp;
<b class="nc"><i>5232</i>&nbsp;            public FontMetrics getFontMetrics(Font f) {</b>
<i>5233</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5234</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5235</i>&nbsp;                    return ((AccessibleComponent) ac).getFontMetrics(f);
<i>5236</i>&nbsp;                } else {
<i>5237</i>&nbsp;                    Component c = getCurrentComponent();
<i>5238</i>&nbsp;                    if (c != null) {
<i>5239</i>&nbsp;                        return c.getFontMetrics(f);
<b class="nc"><i>5240</i>&nbsp;                    } else {</b>
<b class="nc"><i>5241</i>&nbsp;                        return null;</b>
<b class="nc"><i>5242</i>&nbsp;                    }</b>
<b class="nc"><i>5243</i>&nbsp;                }</b>
<b class="nc"><i>5244</i>&nbsp;            }</b>
<b class="nc"><i>5245</i>&nbsp;</b>
<b class="nc"><i>5246</i>&nbsp;            public boolean isEnabled() {</b>
<i>5247</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<b class="nc"><i>5248</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<i>5249</i>&nbsp;                    return ((AccessibleComponent) ac).isEnabled();
<i>5250</i>&nbsp;                } else {
<i>5251</i>&nbsp;                    Component c = getCurrentComponent();
<b class="nc"><i>5252</i>&nbsp;                    if (c != null) {</b>
<i>5253</i>&nbsp;                        return c.isEnabled();
<i>5254</i>&nbsp;                    } else {
<i>5255</i>&nbsp;                        return false;
<b class="nc"><i>5256</i>&nbsp;                    }</b>
<b class="nc"><i>5257</i>&nbsp;                }</b>
<b class="nc"><i>5258</i>&nbsp;            }</b>
<i>5259</i>&nbsp;
<b class="nc"><i>5260</i>&nbsp;            public void setEnabled(boolean b) {</b>
<b class="nc"><i>5261</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5262</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<i>5263</i>&nbsp;                    ((AccessibleComponent) ac).setEnabled(b);
<i>5264</i>&nbsp;                } else {
<i>5265</i>&nbsp;                    Component c = getCurrentComponent();
<i>5266</i>&nbsp;                    if (c != null) {
<i>5267</i>&nbsp;                        c.setEnabled(b);
<b class="nc"><i>5268</i>&nbsp;                    }</b>
<i>5269</i>&nbsp;                }
<i>5270</i>&nbsp;            }
<i>5271</i>&nbsp;
<b class="nc"><i>5272</i>&nbsp;            public boolean isVisible() {</b>
<b class="nc"><i>5273</i>&nbsp;                Rectangle pathBounds = tree.getPathBounds(path);</b>
<b class="nc"><i>5274</i>&nbsp;                Rectangle parentBounds = tree.getVisibleRect();</b>
<i>5275</i>&nbsp;                return pathBounds != null &amp;&amp; parentBounds != null &amp;&amp;
<b class="nc"><i>5276</i>&nbsp;                        parentBounds.intersects(pathBounds);</b>
<b class="nc"><i>5277</i>&nbsp;            }</b>
<b class="nc"><i>5278</i>&nbsp;</b>
<i>5279</i>&nbsp;            public void setVisible(boolean b) {
<i>5280</i>&nbsp;            }
<i>5281</i>&nbsp;
<i>5282</i>&nbsp;            public boolean isShowing() {
<i>5283</i>&nbsp;                return (tree.isShowing() &amp;&amp; isVisible());
<i>5284</i>&nbsp;            }
<i>5285</i>&nbsp;
<i>5286</i>&nbsp;            public boolean contains(Point p) {
<i>5287</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5288</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5289</i>&nbsp;                    Rectangle r = ((AccessibleComponent) ac).getBounds();
<i>5290</i>&nbsp;                    return r.contains(p);
<i>5291</i>&nbsp;                } else {
<i>5292</i>&nbsp;                    Component c = getCurrentComponent();
<i>5293</i>&nbsp;                    if (c != null) {
<b class="nc"><i>5294</i>&nbsp;                        Rectangle r = c.getBounds();</b>
<b class="nc"><i>5295</i>&nbsp;                        return r.contains(p);</b>
<b class="nc"><i>5296</i>&nbsp;                    } else {</b>
<i>5297</i>&nbsp;                        return getBounds().contains(p);
<b class="nc"><i>5298</i>&nbsp;                    }</b>
<i>5299</i>&nbsp;                }
<i>5300</i>&nbsp;            }
<i>5301</i>&nbsp;
<i>5302</i>&nbsp;            public Point getLocationOnScreen() {
<i>5303</i>&nbsp;                if (tree != null) {
<b class="nc"><i>5304</i>&nbsp;                    Point treeLocation = tree.getLocationOnScreen();</b>
<b class="nc"><i>5305</i>&nbsp;                    Rectangle pathBounds = tree.getPathBounds(path);</b>
<b class="nc"><i>5306</i>&nbsp;                    if (treeLocation != null &amp;&amp; pathBounds != null) {</b>
<i>5307</i>&nbsp;                        Point nodeLocation = new Point(pathBounds.x,
<b class="nc"><i>5308</i>&nbsp;                                                       pathBounds.y);</b>
<b class="nc"><i>5309</i>&nbsp;                        nodeLocation.translate(treeLocation.x, treeLocation.y);</b>
<b class="nc"><i>5310</i>&nbsp;                        return nodeLocation;</b>
<i>5311</i>&nbsp;                    } else {
<b class="nc"><i>5312</i>&nbsp;                        return null;</b>
<i>5313</i>&nbsp;                    }
<i>5314</i>&nbsp;                } else {
<i>5315</i>&nbsp;                    return null;
<i>5316</i>&nbsp;                }
<i>5317</i>&nbsp;            }
<b class="nc"><i>5318</i>&nbsp;</b>
<b class="nc"><i>5319</i>&nbsp;            /**</b>
<b class="nc"><i>5320</i>&nbsp;             * Returns the relative location of the node</b>
<i>5321</i>&nbsp;             *
<b class="nc"><i>5322</i>&nbsp;             * @return the relative location of the node</b>
<b class="nc"><i>5323</i>&nbsp;             */</b>
<b class="nc"><i>5324</i>&nbsp;            protected Point getLocationInJTree() {</b>
<i>5325</i>&nbsp;                Rectangle r = tree.getPathBounds(path);
<i>5326</i>&nbsp;                if (r != null) {
<i>5327</i>&nbsp;                    return r.getLocation();
<i>5328</i>&nbsp;                } else {
<i>5329</i>&nbsp;                    return null;
<b class="nc"><i>5330</i>&nbsp;                }</b>
<b class="nc"><i>5331</i>&nbsp;            }</b>
<b class="nc"><i>5332</i>&nbsp;</b>
<i>5333</i>&nbsp;            public Point getLocation() {
<b class="nc"><i>5334</i>&nbsp;                Rectangle r = getBounds();</b>
<b class="nc"><i>5335</i>&nbsp;                if (r != null) {</b>
<b class="nc"><i>5336</i>&nbsp;                    return r.getLocation();</b>
<i>5337</i>&nbsp;                } else {
<i>5338</i>&nbsp;                    return null;
<i>5339</i>&nbsp;                }
<i>5340</i>&nbsp;            }
<i>5341</i>&nbsp;
<b class="nc"><i>5342</i>&nbsp;            public void setLocation(Point p) {</b>
<b class="nc"><i>5343</i>&nbsp;            }</b>
<b class="nc"><i>5344</i>&nbsp;</b>
<i>5345</i>&nbsp;            public Rectangle getBounds() {
<b class="nc"><i>5346</i>&nbsp;                Rectangle r = tree.getPathBounds(path);</b>
<b class="nc"><i>5347</i>&nbsp;                Accessible parent = getAccessibleParent();</b>
<b class="nc"><i>5348</i>&nbsp;                if (parent != null) {</b>
<i>5349</i>&nbsp;                    if (parent instanceof AccessibleJTreeNode) {
<i>5350</i>&nbsp;                        Point parentLoc = ((AccessibleJTreeNode) parent).getLocationInJTree();
<i>5351</i>&nbsp;                        if (parentLoc != null &amp;&amp; r != null) {
<i>5352</i>&nbsp;                            r.translate(-parentLoc.x, -parentLoc.y);
<i>5353</i>&nbsp;                        } else {
<i>5354</i>&nbsp;                            return null;        // not visible!
<i>5355</i>&nbsp;                        }
<i>5356</i>&nbsp;                    }
<i>5357</i>&nbsp;                }
<i>5358</i>&nbsp;                return r;
<i>5359</i>&nbsp;            }
<i>5360</i>&nbsp;
<i>5361</i>&nbsp;            public void setBounds(Rectangle r) {
<b class="nc"><i>5362</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5363</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5364</i>&nbsp;                    ((AccessibleComponent) ac).setBounds(r);</b>
<b class="nc"><i>5365</i>&nbsp;                } else {</b>
<b class="nc"><i>5366</i>&nbsp;                    Component c = getCurrentComponent();</b>
<b class="nc"><i>5367</i>&nbsp;                    if (c != null) {</b>
<i>5368</i>&nbsp;                        c.setBounds(r);
<i>5369</i>&nbsp;                    }
<b class="nc"><i>5370</i>&nbsp;                }</b>
<i>5371</i>&nbsp;            }
<i>5372</i>&nbsp;
<i>5373</i>&nbsp;            public Dimension getSize() {
<i>5374</i>&nbsp;                return getBounds().getSize();
<i>5375</i>&nbsp;            }
<i>5376</i>&nbsp;
<i>5377</i>&nbsp;            public void setSize (Dimension d) {
<i>5378</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5379</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5380</i>&nbsp;                    ((AccessibleComponent) ac).setSize(d);
<i>5381</i>&nbsp;                } else {
<i>5382</i>&nbsp;                    Component c = getCurrentComponent();
<b class="nc"><i>5383</i>&nbsp;                    if (c != null) {</b>
<b class="nc"><i>5384</i>&nbsp;                        c.setSize(d);</b>
<b class="nc"><i>5385</i>&nbsp;                    }</b>
<i>5386</i>&nbsp;                }
<b class="nc"><i>5387</i>&nbsp;            }</b>
<b class="nc"><i>5388</i>&nbsp;</b>
<b class="nc"><i>5389</i>&nbsp;            /**</b>
<b class="nc"><i>5390</i>&nbsp;             * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,</b>
<b class="nc"><i>5391</i>&nbsp;             * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.</b>
<b class="nc"><i>5392</i>&nbsp;             * Otherwise returns &lt;code&gt;null&lt;/code&gt;.</b>
<i>5393</i>&nbsp;             *
<b class="nc"><i>5394</i>&nbsp;             * @param p point in local coordinates of this</b>
<i>5395</i>&nbsp;             *    &lt;code&gt;Accessible&lt;/code&gt;
<i>5396</i>&nbsp;             * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
<i>5397</i>&nbsp;             *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>5398</i>&nbsp;             */</b>
<i>5399</i>&nbsp;            public Accessible getAccessibleAt(Point p) {
<i>5400</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5401</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5402</i>&nbsp;                    return ((AccessibleComponent) ac).getAccessibleAt(p);
<i>5403</i>&nbsp;                } else {
<i>5404</i>&nbsp;                    return null;
<i>5405</i>&nbsp;                }
<i>5406</i>&nbsp;            }
<i>5407</i>&nbsp;
<i>5408</i>&nbsp;            @SuppressWarnings(&quot;deprecation&quot;)
<b class="nc"><i>5409</i>&nbsp;            public boolean isFocusTraversable() {</b>
<b class="nc"><i>5410</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5411</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<i>5412</i>&nbsp;                    return ((AccessibleComponent) ac).isFocusTraversable();
<b class="nc"><i>5413</i>&nbsp;                } else {</b>
<b class="nc"><i>5414</i>&nbsp;                    Component c = getCurrentComponent();</b>
<i>5415</i>&nbsp;                    if (c != null) {
<i>5416</i>&nbsp;                        return c.isFocusTraversable();
<i>5417</i>&nbsp;                    } else {
<i>5418</i>&nbsp;                        return false;
<i>5419</i>&nbsp;                    }
<i>5420</i>&nbsp;                }
<i>5421</i>&nbsp;            }
<i>5422</i>&nbsp;
<i>5423</i>&nbsp;            public void requestFocus() {
<i>5424</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5425</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5426</i>&nbsp;                    ((AccessibleComponent) ac).requestFocus();
<i>5427</i>&nbsp;                } else {
<b class="nc"><i>5428</i>&nbsp;                    Component c = getCurrentComponent();</b>
<b class="nc"><i>5429</i>&nbsp;                    if (c != null) {</b>
<b class="nc"><i>5430</i>&nbsp;                        c.requestFocus();</b>
<b class="nc"><i>5431</i>&nbsp;                    }</b>
<b class="nc"><i>5432</i>&nbsp;                }</b>
<i>5433</i>&nbsp;            }
<i>5434</i>&nbsp;
<i>5435</i>&nbsp;            public void addFocusListener(FocusListener l) {
<i>5436</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5437</i>&nbsp;                if (ac instanceof AccessibleComponent) {
<i>5438</i>&nbsp;                    ((AccessibleComponent) ac).addFocusListener(l);
<i>5439</i>&nbsp;                } else {
<i>5440</i>&nbsp;                    Component c = getCurrentComponent();
<i>5441</i>&nbsp;                    if (c != null) {
<i>5442</i>&nbsp;                        c.addFocusListener(l);
<i>5443</i>&nbsp;                    }
<i>5444</i>&nbsp;                }
<i>5445</i>&nbsp;            }
<b class="nc"><i>5446</i>&nbsp;</b>
<b class="nc"><i>5447</i>&nbsp;            public void removeFocusListener(FocusListener l) {</b>
<b class="nc"><i>5448</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();</b>
<b class="nc"><i>5449</i>&nbsp;                if (ac instanceof AccessibleComponent) {</b>
<b class="nc"><i>5450</i>&nbsp;                    ((AccessibleComponent) ac).removeFocusListener(l);</b>
<i>5451</i>&nbsp;                } else {
<i>5452</i>&nbsp;                    Component c = getCurrentComponent();
<i>5453</i>&nbsp;                    if (c != null) {
<i>5454</i>&nbsp;                        c.removeFocusListener(l);
<i>5455</i>&nbsp;                    }
<i>5456</i>&nbsp;                }
<i>5457</i>&nbsp;            }
<i>5458</i>&nbsp;
<i>5459</i>&nbsp;        // AccessibleSelection methods
<b class="nc"><i>5460</i>&nbsp;</b>
<b class="nc"><i>5461</i>&nbsp;            /**</b>
<b class="nc"><i>5462</i>&nbsp;             * Returns the number of items currently selected.</b>
<i>5463</i>&nbsp;             * If no items are selected, the return value will be 0.
<i>5464</i>&nbsp;             *
<i>5465</i>&nbsp;             * @return the number of items currently selected.
<i>5466</i>&nbsp;             */
<i>5467</i>&nbsp;            public int getAccessibleSelectionCount() {
<i>5468</i>&nbsp;                int count = 0;
<i>5469</i>&nbsp;                int childCount = getAccessibleChildrenCount();
<i>5470</i>&nbsp;                for (int i = 0; i &lt; childCount; i++) {
<b class="nc"><i>5471</i>&nbsp;                    TreePath childPath = getChildTreePath(i);</b>
<b class="nc"><i>5472</i>&nbsp;                    if (tree.isPathSelected(childPath)) {</b>
<b class="nc"><i>5473</i>&nbsp;                       count++;</b>
<i>5474</i>&nbsp;                    }
<b class="nc"><i>5475</i>&nbsp;                }</b>
<b class="nc"><i>5476</i>&nbsp;                return count;</b>
<b class="nc"><i>5477</i>&nbsp;            }</b>
<i>5478</i>&nbsp;
<i>5479</i>&nbsp;            /**
<i>5480</i>&nbsp;             * Returns an Accessible representing the specified selected item
<i>5481</i>&nbsp;             * in the object.  If there isn&#39;t a selection, or there are
<i>5482</i>&nbsp;             * fewer items selected than the integer passed in, the return
<i>5483</i>&nbsp;             * value will be null.
<i>5484</i>&nbsp;             *
<i>5485</i>&nbsp;             * @param i the zero-based index of selected items
<i>5486</i>&nbsp;             * @return an Accessible containing the selected item
<i>5487</i>&nbsp;             */
<i>5488</i>&nbsp;            public Accessible getAccessibleSelection(int i) {
<i>5489</i>&nbsp;                int childCount = getAccessibleChildrenCount();
<i>5490</i>&nbsp;                if (i &lt; 0 || i &gt;= childCount) {
<i>5491</i>&nbsp;                    return null;        // out of range
<i>5492</i>&nbsp;                }
<b class="nc"><i>5493</i>&nbsp;                int count = 0;</b>
<b class="nc"><i>5494</i>&nbsp;                for (int j = 0; j &lt; childCount &amp;&amp; i &gt;= count; j++) {</b>
<b class="nc"><i>5495</i>&nbsp;                    TreePath childPath = getChildTreePath(j);</b>
<b class="nc"><i>5496</i>&nbsp;                    if (tree.isPathSelected(childPath)) {</b>
<b class="nc"><i>5497</i>&nbsp;                        if (count == i) {</b>
<i>5498</i>&nbsp;                            return new AccessibleJTreeNode(tree, childPath, this);
<i>5499</i>&nbsp;                        } else {
<b class="nc"><i>5500</i>&nbsp;                            count++;</b>
<i>5501</i>&nbsp;                        }
<i>5502</i>&nbsp;                    }
<i>5503</i>&nbsp;                }
<i>5504</i>&nbsp;                return null;
<i>5505</i>&nbsp;            }
<i>5506</i>&nbsp;
<i>5507</i>&nbsp;            /**
<i>5508</i>&nbsp;             * Returns true if the current child of this object is selected.
<i>5509</i>&nbsp;             *
<i>5510</i>&nbsp;             * @param i the zero-based index of the child in this Accessible
<i>5511</i>&nbsp;             * object.
<i>5512</i>&nbsp;             * @see AccessibleContext#getAccessibleChild
<b class="nc"><i>5513</i>&nbsp;             */</b>
<b class="nc"><i>5514</i>&nbsp;            public boolean isAccessibleChildSelected(int i) {</b>
<i>5515</i>&nbsp;                int childCount = getAccessibleChildrenCount();
<b class="nc"><i>5516</i>&nbsp;                if (i &lt; 0 || i &gt;= childCount) {</b>
<b class="nc"><i>5517</i>&nbsp;                    return false;       // out of range</b>
<i>5518</i>&nbsp;                } else {
<b class="nc"><i>5519</i>&nbsp;                    TreePath childPath = getChildTreePath(i);</b>
<b class="nc"><i>5520</i>&nbsp;                    return tree.isPathSelected(childPath);</b>
<b class="nc"><i>5521</i>&nbsp;                }</b>
<b class="nc"><i>5522</i>&nbsp;            }</b>
<b class="nc"><i>5523</i>&nbsp;</b>
<i>5524</i>&nbsp;            /**
<i>5525</i>&nbsp;             * Adds the specified selected item in the object to the object&#39;s
<b class="nc"><i>5526</i>&nbsp;             * selection.  If the object supports multiple selections,</b>
<i>5527</i>&nbsp;             * the specified item is added to any existing selection, otherwise
<i>5528</i>&nbsp;             * it replaces any existing selection in the object.  If the
<i>5529</i>&nbsp;             * specified item is already selected, this method has no effect.
<i>5530</i>&nbsp;             *
<i>5531</i>&nbsp;             * @param i the zero-based index of selectable items
<i>5532</i>&nbsp;             */
<i>5533</i>&nbsp;            public void addAccessibleSelection(int i) {
<i>5534</i>&nbsp;               TreeModel model = JTree.this.getModel();
<i>5535</i>&nbsp;               if (model != null) {
<i>5536</i>&nbsp;                   if (i &gt;= 0 &amp;&amp; i &lt; getAccessibleChildrenCount()) {
<i>5537</i>&nbsp;                       TreePath path = getChildTreePath(i);
<i>5538</i>&nbsp;                       JTree.this.addSelectionPath(path);
<b class="nc"><i>5539</i>&nbsp;                    }</b>
<b class="nc"><i>5540</i>&nbsp;                }</b>
<i>5541</i>&nbsp;            }
<b class="nc"><i>5542</i>&nbsp;</b>
<b class="nc"><i>5543</i>&nbsp;            /**</b>
<b class="nc"><i>5544</i>&nbsp;             * Removes the specified selected item in the object from the</b>
<b class="nc"><i>5545</i>&nbsp;             * object&#39;s</b>
<i>5546</i>&nbsp;             * selection.  If the specified item isn&#39;t currently selected, this
<b class="nc"><i>5547</i>&nbsp;             * method has no effect.</b>
<i>5548</i>&nbsp;             *
<b class="nc"><i>5549</i>&nbsp;             * @param i the zero-based index of selectable items</b>
<b class="nc"><i>5550</i>&nbsp;             */</b>
<b class="nc"><i>5551</i>&nbsp;            public void removeAccessibleSelection(int i) {</b>
<b class="nc"><i>5552</i>&nbsp;               TreeModel model = JTree.this.getModel();</b>
<b class="nc"><i>5553</i>&nbsp;               if (model != null) {</b>
<i>5554</i>&nbsp;                   if (i &gt;= 0 &amp;&amp; i &lt; getAccessibleChildrenCount()) {
<i>5555</i>&nbsp;                       TreePath path = getChildTreePath(i);
<b class="nc"><i>5556</i>&nbsp;                       JTree.this.removeSelectionPath(path);</b>
<i>5557</i>&nbsp;                    }
<i>5558</i>&nbsp;                }
<i>5559</i>&nbsp;            }
<i>5560</i>&nbsp;
<i>5561</i>&nbsp;            /**
<i>5562</i>&nbsp;             * Clears the selection in the object, so that nothing in the
<i>5563</i>&nbsp;             * object is selected.
<i>5564</i>&nbsp;             */
<i>5565</i>&nbsp;            public void clearAccessibleSelection() {
<i>5566</i>&nbsp;                int childCount = getAccessibleChildrenCount();
<i>5567</i>&nbsp;                for (int i = 0; i &lt; childCount; i++) {
<i>5568</i>&nbsp;                    removeAccessibleSelection(i);
<i>5569</i>&nbsp;                }
<i>5570</i>&nbsp;            }
<i>5571</i>&nbsp;
<i>5572</i>&nbsp;            /**
<i>5573</i>&nbsp;             * Causes every selected item in the object to be selected
<i>5574</i>&nbsp;             * if the object supports multiple selections.
<i>5575</i>&nbsp;             */
<i>5576</i>&nbsp;            public void selectAllAccessibleSelection() {
<i>5577</i>&nbsp;               TreeModel model = JTree.this.getModel();
<i>5578</i>&nbsp;               if (model != null) {
<i>5579</i>&nbsp;                   int childCount = getAccessibleChildrenCount();
<i>5580</i>&nbsp;                   TreePath path;
<i>5581</i>&nbsp;                   for (int i = 0; i &lt; childCount; i++) {
<i>5582</i>&nbsp;                       path = getChildTreePath(i);
<i>5583</i>&nbsp;                       JTree.this.addSelectionPath(path);
<i>5584</i>&nbsp;                   }
<i>5585</i>&nbsp;                }
<i>5586</i>&nbsp;            }
<i>5587</i>&nbsp;
<i>5588</i>&nbsp;        // AccessibleAction methods
<i>5589</i>&nbsp;
<i>5590</i>&nbsp;            /**
<i>5591</i>&nbsp;             * Returns the number of accessible actions available in this
<i>5592</i>&nbsp;             * tree node.  If this node is not a leaf, there is at least
<i>5593</i>&nbsp;             * one action (toggle expand), in addition to any available
<i>5594</i>&nbsp;             * on the object behind the TreeCellRenderer.
<i>5595</i>&nbsp;             *
<i>5596</i>&nbsp;             * @return the number of Actions in this object
<i>5597</i>&nbsp;             */
<i>5598</i>&nbsp;            public int getAccessibleActionCount() {
<i>5599</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5600</i>&nbsp;                if (ac != null) {
<i>5601</i>&nbsp;                    AccessibleAction aa = ac.getAccessibleAction();
<i>5602</i>&nbsp;                    if (aa != null) {
<i>5603</i>&nbsp;                        return (aa.getAccessibleActionCount() + (isLeaf ? 0 : 1));
<i>5604</i>&nbsp;                    }
<i>5605</i>&nbsp;                }
<i>5606</i>&nbsp;                return isLeaf ? 0 : 1;
<i>5607</i>&nbsp;            }
<i>5608</i>&nbsp;
<i>5609</i>&nbsp;            /**
<i>5610</i>&nbsp;             * Return a description of the specified action of the tree node.
<i>5611</i>&nbsp;             * If this node is not a leaf, there is at least one action
<i>5612</i>&nbsp;             * description (toggle expand), in addition to any available
<i>5613</i>&nbsp;             * on the object behind the TreeCellRenderer.
<i>5614</i>&nbsp;             *
<i>5615</i>&nbsp;             * @param i zero-based index of the actions
<i>5616</i>&nbsp;             * @return a description of the action
<i>5617</i>&nbsp;             */
<i>5618</i>&nbsp;            public String getAccessibleActionDescription(int i) {
<i>5619</i>&nbsp;                if (i &lt; 0 || i &gt;= getAccessibleActionCount()) {
<i>5620</i>&nbsp;                    return null;
<i>5621</i>&nbsp;                }
<i>5622</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5623</i>&nbsp;                if (i == 0) {
<i>5624</i>&nbsp;                    // TIGER - 4766636
<i>5625</i>&nbsp;                    return AccessibleAction.TOGGLE_EXPAND;
<i>5626</i>&nbsp;                } else if (ac != null) {
<i>5627</i>&nbsp;                    AccessibleAction aa = ac.getAccessibleAction();
<i>5628</i>&nbsp;                    if (aa != null) {
<i>5629</i>&nbsp;                        return aa.getAccessibleActionDescription(i - 1);
<i>5630</i>&nbsp;                    }
<i>5631</i>&nbsp;                }
<i>5632</i>&nbsp;                return null;
<i>5633</i>&nbsp;            }
<i>5634</i>&nbsp;
<i>5635</i>&nbsp;            /**
<i>5636</i>&nbsp;             * Perform the specified Action on the tree node.  If this node
<i>5637</i>&nbsp;             * is not a leaf, there is at least one action which can be
<i>5638</i>&nbsp;             * done (toggle expand), in addition to any available on the
<i>5639</i>&nbsp;             * object behind the TreeCellRenderer.
<i>5640</i>&nbsp;             *
<i>5641</i>&nbsp;             * @param i zero-based index of actions
<i>5642</i>&nbsp;             * @return true if the action was performed; else false.
<i>5643</i>&nbsp;             */
<i>5644</i>&nbsp;            public boolean doAccessibleAction(int i) {
<i>5645</i>&nbsp;                if (i &lt; 0 || i &gt;= getAccessibleActionCount()) {
<i>5646</i>&nbsp;                    return false;
<i>5647</i>&nbsp;                }
<i>5648</i>&nbsp;                AccessibleContext ac = getCurrentAccessibleContext();
<i>5649</i>&nbsp;                if (i == 0) {
<i>5650</i>&nbsp;                    if (JTree.this.isExpanded(path)) {
<i>5651</i>&nbsp;                        JTree.this.collapsePath(path);
<i>5652</i>&nbsp;                    } else {
<i>5653</i>&nbsp;                        JTree.this.expandPath(path);
<i>5654</i>&nbsp;                    }
<i>5655</i>&nbsp;                    return true;
<i>5656</i>&nbsp;                } else if (ac != null) {
<i>5657</i>&nbsp;                    AccessibleAction aa = ac.getAccessibleAction();
<i>5658</i>&nbsp;                    if (aa != null) {
<i>5659</i>&nbsp;                        return aa.doAccessibleAction(i - 1);
<i>5660</i>&nbsp;                    }
<i>5661</i>&nbsp;                }
<i>5662</i>&nbsp;                return false;
<i>5663</i>&nbsp;            }
<i>5664</i>&nbsp;
<i>5665</i>&nbsp;        } // inner class AccessibleJTreeNode
<i>5666</i>&nbsp;
<i>5667</i>&nbsp;    }  // inner class AccessibleJTree
<i>5668</i>&nbsp;
<i>5669</i>&nbsp;} // End of class JTree
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
