


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: JComponent</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing</a> ]
</div>

<h1>Coverage Summary for Class: JComponent (javax.swing)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 186)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1049)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JComponent$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$AccessibleJComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$AccessibleJComponent$AccessibleContainerHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$AccessibleJComponent$AccessibleFocusHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$ActionStandin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$IntVector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$KeyboardState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JComponent$ReadObjectCallback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 229)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1240)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing;
<i>26</i>&nbsp;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.beans.*;
<i>29</i>&nbsp;import java.util.HashSet;
<i>30</i>&nbsp;import java.util.Hashtable;
<i>31</i>&nbsp;import java.util.Enumeration;
<i>32</i>&nbsp;import java.util.Locale;
<i>33</i>&nbsp;import java.util.Vector;
<i>34</i>&nbsp;import java.util.EventListener;
<i>35</i>&nbsp;import java.util.Set;
<i>36</i>&nbsp;
<i>37</i>&nbsp;import java.awt.*;
<i>38</i>&nbsp;import java.awt.event.*;
<i>39</i>&nbsp;
<i>40</i>&nbsp;import java.applet.Applet;
<i>41</i>&nbsp;
<i>42</i>&nbsp;import java.io.Serializable;
<i>43</i>&nbsp;import java.io.ObjectOutputStream;
<i>44</i>&nbsp;import java.io.ObjectInputStream;
<i>45</i>&nbsp;import java.io.IOException;
<i>46</i>&nbsp;import java.io.ObjectInputValidation;
<i>47</i>&nbsp;import java.io.InvalidObjectException;
<i>48</i>&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
<i>49</i>&nbsp;
<i>50</i>&nbsp;import javax.swing.border.*;
<i>51</i>&nbsp;import javax.swing.event.*;
<i>52</i>&nbsp;import javax.swing.plaf.*;
<i>53</i>&nbsp;import static javax.swing.ClientPropertyKey.*;
<i>54</i>&nbsp;import javax.accessibility.*;
<i>55</i>&nbsp;
<i>56</i>&nbsp;import sun.awt.AWTAccessor;
<i>57</i>&nbsp;import sun.awt.SunToolkit;
<i>58</i>&nbsp;import sun.swing.SwingAccessor;
<i>59</i>&nbsp;import sun.swing.SwingUtilities2;
<i>60</i>&nbsp;
<i>61</i>&nbsp;/**
<i>62</i>&nbsp; * The base class for all Swing components except top-level containers.
<i>63</i>&nbsp; * To use a component that inherits from &lt;code&gt;JComponent&lt;/code&gt;,
<i>64</i>&nbsp; * you must place the component in a containment hierarchy
<i>65</i>&nbsp; * whose root is a top-level Swing container.
<i>66</i>&nbsp; * Top-level Swing containers --
<i>67</i>&nbsp; * such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
<i>68</i>&nbsp; * and &lt;code&gt;JApplet&lt;/code&gt; --
<i>69</i>&nbsp; * are specialized components
<i>70</i>&nbsp; * that provide a place for other Swing components to paint themselves.
<i>71</i>&nbsp; * For an explanation of containment hierarchies, see
<i>72</i>&nbsp; * &lt;a
<i>73</i>&nbsp; href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;Swing Components and the Containment Hierarchy&lt;/a&gt;,
<i>74</i>&nbsp; * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>75</i>&nbsp; *
<i>76</i>&nbsp; * &lt;p&gt;
<i>77</i>&nbsp; * The &lt;code&gt;JComponent&lt;/code&gt; class provides:
<i>78</i>&nbsp; * &lt;ul&gt;
<i>79</i>&nbsp; * &lt;li&gt;The base class for both standard and custom components
<i>80</i>&nbsp; *     that use the Swing architecture.
<i>81</i>&nbsp; * &lt;li&gt;A &quot;pluggable look and feel&quot; (L&amp;amp;F) that can be specified by the
<i>82</i>&nbsp; *     programmer or (optionally) selected by the user at runtime.
<i>83</i>&nbsp; *     The look and feel for each component is provided by a
<i>84</i>&nbsp; *     &lt;em&gt;UI delegate&lt;/em&gt; -- an object that descends from
<i>85</i>&nbsp; *     {@link javax.swing.plaf.ComponentUI}.
<i>86</i>&nbsp; *     See &lt;a
<i>87</i>&nbsp; * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html&quot;&gt;How
<i>88</i>&nbsp; *     to Set the Look and Feel&lt;/a&gt;
<i>89</i>&nbsp; *     in &lt;em&gt;The Java Tutorial&lt;/em&gt;
<i>90</i>&nbsp; *     for more information.
<i>91</i>&nbsp; * &lt;li&gt;Comprehensive keystroke handling.
<i>92</i>&nbsp; *     See the document &lt;a
<i>93</i>&nbsp; * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html&quot;&gt;How to Use Key Bindings&lt;/a&gt;,
<i>94</i>&nbsp; *     an article in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
<i>95</i>&nbsp; *     for more information.
<i>96</i>&nbsp; * &lt;li&gt;Support for tool tips --
<i>97</i>&nbsp; *     short descriptions that pop up when the cursor lingers
<i>98</i>&nbsp; *     over a component.
<i>99</i>&nbsp; *     See &lt;a
<i>100</i>&nbsp; * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tooltip.html&quot;&gt;How
<i>101</i>&nbsp; *     to Use Tool Tips&lt;/a&gt;
<i>102</i>&nbsp; *     in &lt;em&gt;The Java Tutorial&lt;/em&gt;
<i>103</i>&nbsp; *     for more information.
<i>104</i>&nbsp; * &lt;li&gt;Support for accessibility.
<i>105</i>&nbsp; *     &lt;code&gt;JComponent&lt;/code&gt; contains all of the methods in the
<i>106</i>&nbsp; *     &lt;code&gt;Accessible&lt;/code&gt; interface,
<i>107</i>&nbsp; *     but it doesn&#39;t actually implement the interface.  That is the
<i>108</i>&nbsp; *     responsibility of the individual classes
<i>109</i>&nbsp; *     that extend &lt;code&gt;JComponent&lt;/code&gt;.
<i>110</i>&nbsp; * &lt;li&gt;Support for component-specific properties.
<i>111</i>&nbsp; *     With the {@link #putClientProperty}
<i>112</i>&nbsp; *     and {@link #getClientProperty} methods,
<i>113</i>&nbsp; *     you can associate name-object pairs
<i>114</i>&nbsp; *     with any object that descends from &lt;code&gt;JComponent&lt;/code&gt;.
<i>115</i>&nbsp; * &lt;li&gt;An infrastructure for painting
<i>116</i>&nbsp; *     that includes double buffering and support for borders.
<i>117</i>&nbsp; *     For more information see &lt;a
<i>118</i>&nbsp; * href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html#swing&quot;&gt;Painting&lt;/a&gt; and
<i>119</i>&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/border.html&quot;&gt;How
<i>120</i>&nbsp; *     to Use Borders&lt;/a&gt;,
<i>121</i>&nbsp; *     both of which are sections in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>122</i>&nbsp; * &lt;/ul&gt;
<i>123</i>&nbsp; * For more information on these subjects, see the
<i>124</i>&nbsp; * {@link javax.swing Swing package description}
<i>125</i>&nbsp; * and &lt;em&gt;The Java Tutorial&lt;/em&gt; section
<i>126</i>&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/jcomponent.html&quot;&gt;The JComponent Class&lt;/a&gt;.
<i>127</i>&nbsp; * &lt;p&gt;
<i>128</i>&nbsp; * &lt;code&gt;JComponent&lt;/code&gt; and its subclasses document default values
<i>129</i>&nbsp; * for certain properties.  For example, &lt;code&gt;JTable&lt;/code&gt; documents the
<i>130</i>&nbsp; * default row height as 16.  Each &lt;code&gt;JComponent&lt;/code&gt; subclass
<i>131</i>&nbsp; * that has a &lt;code&gt;ComponentUI&lt;/code&gt; will create the
<i>132</i>&nbsp; * &lt;code&gt;ComponentUI&lt;/code&gt; as part of its constructor.  In order
<i>133</i>&nbsp; * to provide a particular look and feel each
<i>134</i>&nbsp; * &lt;code&gt;ComponentUI&lt;/code&gt; may set properties back on the
<i>135</i>&nbsp; * &lt;code&gt;JComponent&lt;/code&gt; that created it.  For example, a custom
<i>136</i>&nbsp; * look and feel may require &lt;code&gt;JTable&lt;/code&gt;s to have a row
<i>137</i>&nbsp; * height of 24. The documented defaults are the value of a property
<i>138</i>&nbsp; * BEFORE the &lt;code&gt;ComponentUI&lt;/code&gt; has been installed.  If you
<i>139</i>&nbsp; * need a specific value for a particular property you should
<i>140</i>&nbsp; * explicitly set it.
<i>141</i>&nbsp; * &lt;p&gt;
<i>142</i>&nbsp; * In release 1.4, the focus subsystem was rearchitected.
<i>143</i>&nbsp; * For more information, see
<i>144</i>&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>145</i>&nbsp; * How to Use the Focus Subsystem&lt;/a&gt;,
<i>146</i>&nbsp; * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>147</i>&nbsp; * &lt;p&gt;
<i>148</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
<i>149</i>&nbsp; * information see &lt;a
<i>150</i>&nbsp; * href=&quot;package-summary.html#threading&quot;&gt;Swing&#39;s Threading
<i>151</i>&nbsp; * Policy&lt;/a&gt;.
<i>152</i>&nbsp; * &lt;p&gt;
<i>153</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>154</i>&nbsp; * Serialized objects of this class will not be compatible with
<i>155</i>&nbsp; * future Swing releases. The current serialization support is
<i>156</i>&nbsp; * appropriate for short term storage or RMI between applications running
<i>157</i>&nbsp; * the same version of Swing.  As of 1.4, support for long term storage
<i>158</i>&nbsp; * of all JavaBeans&amp;trade;
<i>159</i>&nbsp; * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>160</i>&nbsp; * Please see {@link java.beans.XMLEncoder}.
<i>161</i>&nbsp; *
<i>162</i>&nbsp; * @see KeyStroke
<i>163</i>&nbsp; * @see Action
<i>164</i>&nbsp; * @see #setBorder
<i>165</i>&nbsp; * @see #registerKeyboardAction
<i>166</i>&nbsp; * @see JOptionPane
<i>167</i>&nbsp; * @see #setDebugGraphicsOptions
<i>168</i>&nbsp; * @see #setToolTipText
<i>169</i>&nbsp; * @see #setAutoscrolls
<i>170</i>&nbsp; *
<i>171</i>&nbsp; * @author Hans Muller
<i>172</i>&nbsp; * @author Arnaud Weber
<i>173</i>&nbsp; * @since 1.2
<i>174</i>&nbsp; */
<i>175</i>&nbsp;@JavaBean(defaultProperty = &quot;UIClassID&quot;)
<i>176</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>177</i>&nbsp;public abstract class JComponent extends Container implements Serializable,
<i>178</i>&nbsp;                                              TransferHandler.HasGetTransferHandler
<i>179</i>&nbsp;{
<i>180</i>&nbsp;    /**
<i>181</i>&nbsp;     * @see #getUIClassID
<i>182</i>&nbsp;     * @see #writeObject
<i>183</i>&nbsp;     */
<b class="nc"><i>184</i>&nbsp;    private static final String uiClassID = &quot;ComponentUI&quot;;</b>
<i>185</i>&nbsp;
<i>186</i>&nbsp;    /**
<i>187</i>&nbsp;     * @see #readObject
<i>188</i>&nbsp;     */
<i>189</i>&nbsp;    private static final Hashtable&lt;ObjectInputStream, ReadObjectCallback&gt; readObjectCallbacks =
<i>190</i>&nbsp;            new Hashtable&lt;ObjectInputStream, ReadObjectCallback&gt;(1);
<i>191</i>&nbsp;
<i>192</i>&nbsp;    /**
<i>193</i>&nbsp;     * Keys to use for forward focus traversal when the JComponent is
<i>194</i>&nbsp;     * managing focus.
<i>195</i>&nbsp;     */
<b class="nc"><i>196</i>&nbsp;    private static Set&lt;KeyStroke&gt; managingFocusForwardTraversalKeys;</b>
<i>197</i>&nbsp;
<i>198</i>&nbsp;    /**
<i>199</i>&nbsp;     * Keys to use for backward focus traversal when the JComponent is
<i>200</i>&nbsp;     * managing focus.
<i>201</i>&nbsp;     */
<i>202</i>&nbsp;    private static Set&lt;KeyStroke&gt; managingFocusBackwardTraversalKeys;
<i>203</i>&nbsp;
<i>204</i>&nbsp;    // Following are the possible return values from getObscuredState.
<i>205</i>&nbsp;    private static final int NOT_OBSCURED = 0;
<i>206</i>&nbsp;    private static final int PARTIALLY_OBSCURED = 1;
<i>207</i>&nbsp;    private static final int COMPLETELY_OBSCURED = 2;
<i>208</i>&nbsp;
<i>209</i>&nbsp;    /**
<i>210</i>&nbsp;     * Set to true when DebugGraphics has been loaded.
<i>211</i>&nbsp;     */
<i>212</i>&nbsp;    static boolean DEBUG_GRAPHICS_LOADED;
<i>213</i>&nbsp;
<i>214</i>&nbsp;    /**
<i>215</i>&nbsp;     * Key used to look up a value from the AppContext to determine the
<i>216</i>&nbsp;     * JComponent the InputVerifier is running for. That is, if
<i>217</i>&nbsp;     * AppContext.get(INPUT_VERIFIER_SOURCE_KEY) returns non-null, it
<i>218</i>&nbsp;     * indicates the EDT is calling into the InputVerifier from the
<i>219</i>&nbsp;     * returned component.
<i>220</i>&nbsp;     */
<i>221</i>&nbsp;    private static final Object INPUT_VERIFIER_SOURCE_KEY =
<i>222</i>&nbsp;            new StringBuilder(&quot;InputVerifierSourceKey&quot;);
<i>223</i>&nbsp;
<i>224</i>&nbsp;    /* The following fields support set methods for the corresponding
<i>225</i>&nbsp;     * java.awt.Component properties.
<i>226</i>&nbsp;     */
<i>227</i>&nbsp;    private boolean isAlignmentXSet;
<b class="nc"><i>228</i>&nbsp;    private float alignmentX;</b>
<i>229</i>&nbsp;    private boolean isAlignmentYSet;
<i>230</i>&nbsp;    private float alignmentY;
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /**
<i>233</i>&nbsp;     * Backing store for JComponent properties and listeners
<i>234</i>&nbsp;     */
<i>235</i>&nbsp;
<i>236</i>&nbsp;    /** The look and feel delegate for this component. */
<i>237</i>&nbsp;    protected transient ComponentUI ui;
<i>238</i>&nbsp;    /** A list of event listeners for this component. */
<i>239</i>&nbsp;    protected EventListenerList listenerList = new EventListenerList();
<i>240</i>&nbsp;
<i>241</i>&nbsp;    private transient ArrayTable clientProperties;
<i>242</i>&nbsp;    private VetoableChangeSupport vetoableChangeSupport;
<i>243</i>&nbsp;    /**
<i>244</i>&nbsp;     * Whether or not autoscroll has been enabled.
<i>245</i>&nbsp;     */
<b class="nc"><i>246</i>&nbsp;    private boolean autoscrolls;</b>
<i>247</i>&nbsp;    private Border border;
<i>248</i>&nbsp;    private int flags;
<i>249</i>&nbsp;
<i>250</i>&nbsp;    /* Input verifier for this component */
<i>251</i>&nbsp;    private InputVerifier inputVerifier = null;
<i>252</i>&nbsp;
<i>253</i>&nbsp;    private boolean verifyInputWhenFocusTarget = true;
<i>254</i>&nbsp;
<i>255</i>&nbsp;    /**
<i>256</i>&nbsp;     * Set in &lt;code&gt;_paintImmediately&lt;/code&gt;.
<i>257</i>&nbsp;     * Will indicate the child that initiated the painting operation.
<b class="nc"><i>258</i>&nbsp;     * If &lt;code&gt;paintingChild&lt;/code&gt; is opaque, no need to paint</b>
<i>259</i>&nbsp;     * any child components after &lt;code&gt;paintingChild&lt;/code&gt;.
<b class="nc"><i>260</i>&nbsp;     * Test used in &lt;code&gt;paintChildren&lt;/code&gt;.</b>
<i>261</i>&nbsp;     */
<i>262</i>&nbsp;    transient Component         paintingChild;
<i>263</i>&nbsp;
<i>264</i>&nbsp;    /**
<i>265</i>&nbsp;     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
<i>266</i>&nbsp;     * means that the command should be invoked when
<i>267</i>&nbsp;     * the component has the focus.
<i>268</i>&nbsp;     */
<i>269</i>&nbsp;    public static final int WHEN_FOCUSED = 0;
<i>270</i>&nbsp;
<i>271</i>&nbsp;    /**
<i>272</i>&nbsp;     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
<i>273</i>&nbsp;     * means that the command should be invoked when the receiving
<i>274</i>&nbsp;     * component is an ancestor of the focused component or is
<i>275</i>&nbsp;     * itself the focused component.
<i>276</i>&nbsp;     */
<i>277</i>&nbsp;    public static final int WHEN_ANCESTOR_OF_FOCUSED_COMPONENT = 1;
<i>278</i>&nbsp;
<i>279</i>&nbsp;    /**
<i>280</i>&nbsp;     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
<i>281</i>&nbsp;     * means that the command should be invoked when
<i>282</i>&nbsp;     * the receiving component is in the window that has the focus
<i>283</i>&nbsp;     * or is itself the focused component.
<i>284</i>&nbsp;     */
<i>285</i>&nbsp;    public static final int WHEN_IN_FOCUSED_WINDOW = 2;
<i>286</i>&nbsp;
<i>287</i>&nbsp;    /**
<i>288</i>&nbsp;     * Constant used by some of the APIs to mean that no condition is defined.
<i>289</i>&nbsp;     */
<i>290</i>&nbsp;    public static final int UNDEFINED_CONDITION = -1;
<i>291</i>&nbsp;
<i>292</i>&nbsp;    /**
<i>293</i>&nbsp;     * The key used by &lt;code&gt;JComponent&lt;/code&gt; to access keyboard bindings.
<i>294</i>&nbsp;     */
<i>295</i>&nbsp;    private static final String KEYBOARD_BINDINGS_KEY = &quot;_KeyboardBindings&quot;;
<i>296</i>&nbsp;
<i>297</i>&nbsp;    /**
<i>298</i>&nbsp;     * An array of &lt;code&gt;KeyStroke&lt;/code&gt;s used for
<i>299</i>&nbsp;     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; are stashed
<i>300</i>&nbsp;     * in the client properties under this string.
<i>301</i>&nbsp;     */
<i>302</i>&nbsp;    private static final String WHEN_IN_FOCUSED_WINDOW_BINDINGS = &quot;_WhenInFocusedWindow&quot;;
<i>303</i>&nbsp;
<i>304</i>&nbsp;    /**
<i>305</i>&nbsp;     * The comment to display when the cursor is over the component,
<i>306</i>&nbsp;     * also known as a &quot;value tip&quot;, &quot;flyover help&quot;, or &quot;flyover label&quot;.
<i>307</i>&nbsp;     */
<i>308</i>&nbsp;    public static final String TOOL_TIP_TEXT_KEY = &quot;ToolTipText&quot;;
<i>309</i>&nbsp;
<i>310</i>&nbsp;    private static final String NEXT_FOCUS = &quot;nextFocus&quot;;
<i>311</i>&nbsp;
<i>312</i>&nbsp;    /**
<i>313</i>&nbsp;     * &lt;code&gt;JPopupMenu&lt;/code&gt; assigned to this component
<i>314</i>&nbsp;     * and all of its children
<i>315</i>&nbsp;     */
<i>316</i>&nbsp;    private JPopupMenu popupMenu;
<i>317</i>&nbsp;
<i>318</i>&nbsp;    /** Private flags **/
<i>319</i>&nbsp;    private static final int IS_DOUBLE_BUFFERED                       =  0;
<i>320</i>&nbsp;    private static final int ANCESTOR_USING_BUFFER                    =  1;
<i>321</i>&nbsp;    private static final int IS_PAINTING_TILE                         =  2;
<i>322</i>&nbsp;    private static final int IS_OPAQUE                                =  3;
<i>323</i>&nbsp;    private static final int KEY_EVENTS_ENABLED                       =  4;
<i>324</i>&nbsp;    private static final int FOCUS_INPUTMAP_CREATED                   =  5;
<i>325</i>&nbsp;    private static final int ANCESTOR_INPUTMAP_CREATED                =  6;
<i>326</i>&nbsp;    private static final int WIF_INPUTMAP_CREATED                     =  7;
<i>327</i>&nbsp;    private static final int ACTIONMAP_CREATED                        =  8;
<i>328</i>&nbsp;    private static final int CREATED_DOUBLE_BUFFER                    =  9;
<i>329</i>&nbsp;    // bit 10 is free
<i>330</i>&nbsp;    private static final int IS_PRINTING                              = 11;
<i>331</i>&nbsp;    private static final int IS_PRINTING_ALL                          = 12;
<i>332</i>&nbsp;    private static final int IS_REPAINTING                            = 13;
<i>333</i>&nbsp;    /** Bits 14-21 are used to handle nested writeObject calls. **/
<i>334</i>&nbsp;    private static final int WRITE_OBJ_COUNTER_FIRST                  = 14;
<i>335</i>&nbsp;    private static final int RESERVED_1                               = 15;
<i>336</i>&nbsp;    private static final int RESERVED_2                               = 16;
<i>337</i>&nbsp;    private static final int RESERVED_3                               = 17;
<i>338</i>&nbsp;    private static final int RESERVED_4                               = 18;
<i>339</i>&nbsp;    private static final int RESERVED_5                               = 19;
<i>340</i>&nbsp;    private static final int RESERVED_6                               = 20;
<i>341</i>&nbsp;    private static final int WRITE_OBJ_COUNTER_LAST                   = 21;
<i>342</i>&nbsp;
<i>343</i>&nbsp;    private static final int REQUEST_FOCUS_DISABLED                   = 22;
<i>344</i>&nbsp;    private static final int INHERITS_POPUP_MENU                      = 23;
<i>345</i>&nbsp;    private static final int OPAQUE_SET                               = 24;
<i>346</i>&nbsp;    private static final int AUTOSCROLLS_SET                          = 25;
<i>347</i>&nbsp;    private static final int FOCUS_TRAVERSAL_KEYS_FORWARD_SET         = 26;
<i>348</i>&nbsp;    private static final int FOCUS_TRAVERSAL_KEYS_BACKWARD_SET        = 27;
<i>349</i>&nbsp;
<i>350</i>&nbsp;    private transient AtomicBoolean revalidateRunnableScheduled = new AtomicBoolean(false);
<i>351</i>&nbsp;
<i>352</i>&nbsp;    /**
<i>353</i>&nbsp;     * Temporary rectangles.
<i>354</i>&nbsp;     */
<i>355</i>&nbsp;    private static java.util.List&lt;Rectangle&gt; tempRectangles = new java.util.ArrayList&lt;Rectangle&gt;(11);
<i>356</i>&nbsp;
<b class="nc"><i>357</i>&nbsp;    /** Used for &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings. */</b>
<i>358</i>&nbsp;    private InputMap focusInputMap;
<i>359</i>&nbsp;    /** Used for &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings. */
<i>360</i>&nbsp;    private InputMap ancestorInputMap;
<i>361</i>&nbsp;    /** Used for &lt;code&gt;WHEN_IN_FOCUSED_KEY&lt;/code&gt; bindings. */
<b class="nc"><i>362</i>&nbsp;    private ComponentInputMap windowInputMap;</b>
<i>363</i>&nbsp;
<i>364</i>&nbsp;    /** ActionMap. */
<i>365</i>&nbsp;    private ActionMap actionMap;
<i>366</i>&nbsp;
<i>367</i>&nbsp;    /** Key used to store the default locale in an AppContext **/
<i>368</i>&nbsp;    private static final String defaultLocale = &quot;JComponent.defaultLocale&quot;;
<i>369</i>&nbsp;
<i>370</i>&nbsp;    private static Component componentObtainingGraphicsFrom;
<i>371</i>&nbsp;    private static Object componentObtainingGraphicsFromLock = new
<i>372</i>&nbsp;            StringBuilder(&quot;componentObtainingGraphicsFrom&quot;);
<i>373</i>&nbsp;
<i>374</i>&nbsp;    /**
<i>375</i>&nbsp;     * AA text hints.
<i>376</i>&nbsp;     */
<i>377</i>&nbsp;    private transient Object aaHint;
<b class="nc"><i>378</i>&nbsp;    private transient Object lcdRenderingHint;</b>
<i>379</i>&nbsp;
<i>380</i>&nbsp;    static {
<i>381</i>&nbsp;        SwingAccessor.setJComponentAccessor(new SwingAccessor.JComponentAccessor() {
<i>382</i>&nbsp;
<i>383</i>&nbsp;            @Override
<i>384</i>&nbsp;            public boolean getFlag(JComponent comp, int aFlag) {
<i>385</i>&nbsp;                return comp.getFlag(aFlag);
<i>386</i>&nbsp;            }
<b class="nc"><i>387</i>&nbsp;</b>
<i>388</i>&nbsp;            @Override
<i>389</i>&nbsp;            public void compWriteObjectNotify(JComponent comp) {
<i>390</i>&nbsp;                comp.compWriteObjectNotify();
<b class="nc"><i>391</i>&nbsp;            }</b>
<b class="nc"><i>392</i>&nbsp;        });</b>
<b class="nc"><i>393</i>&nbsp;    }</b>
<b class="nc"><i>394</i>&nbsp;</b>
<b class="nc"><i>395</i>&nbsp;    static Graphics safelyGetGraphics(Component c) {</b>
<b class="nc"><i>396</i>&nbsp;        return safelyGetGraphics(c, SwingUtilities.getRoot(c));</b>
<i>397</i>&nbsp;    }
<i>398</i>&nbsp;
<i>399</i>&nbsp;    static Graphics safelyGetGraphics(Component c, Component root) {
<b class="nc"><i>400</i>&nbsp;        synchronized(componentObtainingGraphicsFromLock) {</b>
<b class="nc"><i>401</i>&nbsp;            componentObtainingGraphicsFrom = root;</b>
<b class="nc"><i>402</i>&nbsp;            Graphics g = c.getGraphics();</b>
<b class="nc"><i>403</i>&nbsp;            componentObtainingGraphicsFrom = null;</b>
<i>404</i>&nbsp;            return g;
<i>405</i>&nbsp;        }
<i>406</i>&nbsp;    }
<i>407</i>&nbsp;
<i>408</i>&nbsp;    static void getGraphicsInvoked(Component root) {
<i>409</i>&nbsp;        if (!JComponent.isComponentObtainingGraphicsFrom(root)) {
<i>410</i>&nbsp;            JRootPane rootPane = ((RootPaneContainer)root).getRootPane();
<i>411</i>&nbsp;            if (rootPane != null) {
<i>412</i>&nbsp;                rootPane.disableTrueDoubleBuffering();
<i>413</i>&nbsp;            }
<b class="nc"><i>414</i>&nbsp;        }</b>
<b class="nc"><i>415</i>&nbsp;    }</b>
<b class="nc"><i>416</i>&nbsp;</b>
<i>417</i>&nbsp;
<i>418</i>&nbsp;    /**
<i>419</i>&nbsp;     * Returns true if {@code c} is the component the graphics is being
<i>420</i>&nbsp;     * requested of. This is intended for use when getGraphics is invoked.
<i>421</i>&nbsp;     */
<i>422</i>&nbsp;    private static boolean isComponentObtainingGraphicsFrom(Component c) {
<i>423</i>&nbsp;        synchronized(componentObtainingGraphicsFromLock) {
<b class="nc"><i>424</i>&nbsp;            return (componentObtainingGraphicsFrom == c);</b>
<b class="nc"><i>425</i>&nbsp;        }</b>
<b class="nc"><i>426</i>&nbsp;    }</b>
<b class="nc"><i>427</i>&nbsp;</b>
<b class="nc"><i>428</i>&nbsp;    /**</b>
<i>429</i>&nbsp;     * Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
<i>430</i>&nbsp;     * is managing focus for forward focus traversal.
<b class="nc"><i>431</i>&nbsp;     */</b>
<b class="nc"><i>432</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
<i>433</i>&nbsp;    static Set&lt;KeyStroke&gt; getManagingFocusForwardTraversalKeys() {
<i>434</i>&nbsp;        synchronized(JComponent.class) {
<i>435</i>&nbsp;            if (managingFocusForwardTraversalKeys == null) {
<i>436</i>&nbsp;                managingFocusForwardTraversalKeys = new HashSet&lt;KeyStroke&gt;(1);
<i>437</i>&nbsp;                managingFocusForwardTraversalKeys.add(
<i>438</i>&nbsp;                    KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
<i>439</i>&nbsp;                                           InputEvent.CTRL_MASK));
<b class="nc"><i>440</i>&nbsp;            }</b>
<b class="nc"><i>441</i>&nbsp;        }</b>
<b class="nc"><i>442</i>&nbsp;        return managingFocusForwardTraversalKeys;</b>
<b class="nc"><i>443</i>&nbsp;    }</b>
<b class="nc"><i>444</i>&nbsp;</b>
<i>445</i>&nbsp;    /**
<i>446</i>&nbsp;     * Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
<i>447</i>&nbsp;     * is managing focus for backward focus traversal.
<b class="nc"><i>448</i>&nbsp;     */</b>
<b class="nc"><i>449</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
<i>450</i>&nbsp;    static Set&lt;KeyStroke&gt; getManagingFocusBackwardTraversalKeys() {
<i>451</i>&nbsp;        synchronized(JComponent.class) {
<i>452</i>&nbsp;            if (managingFocusBackwardTraversalKeys == null) {
<b class="nc"><i>453</i>&nbsp;                managingFocusBackwardTraversalKeys = new HashSet&lt;KeyStroke&gt;(1);</b>
<i>454</i>&nbsp;                managingFocusBackwardTraversalKeys.add(
<b class="nc"><i>455</i>&nbsp;                    KeyStroke.getKeyStroke(KeyEvent.VK_TAB,</b>
<b class="nc"><i>456</i>&nbsp;                                           InputEvent.SHIFT_MASK |</b>
<b class="nc"><i>457</i>&nbsp;                                           InputEvent.CTRL_MASK));</b>
<i>458</i>&nbsp;            }
<i>459</i>&nbsp;        }
<b class="nc"><i>460</i>&nbsp;        return managingFocusBackwardTraversalKeys;</b>
<i>461</i>&nbsp;    }
<b class="nc"><i>462</i>&nbsp;</b>
<b class="nc"><i>463</i>&nbsp;    private static Rectangle fetchRectangle() {</b>
<i>464</i>&nbsp;        synchronized(tempRectangles) {
<i>465</i>&nbsp;            Rectangle rect;
<i>466</i>&nbsp;            int size = tempRectangles.size();
<b class="nc"><i>467</i>&nbsp;            if (size &gt; 0) {</b>
<b class="nc"><i>468</i>&nbsp;                rect = tempRectangles.remove(size - 1);</b>
<b class="nc"><i>469</i>&nbsp;            }</b>
<i>470</i>&nbsp;            else {
<i>471</i>&nbsp;                rect = new Rectangle(0, 0, 0, 0);
<i>472</i>&nbsp;            }
<i>473</i>&nbsp;            return rect;
<i>474</i>&nbsp;        }
<i>475</i>&nbsp;    }
<i>476</i>&nbsp;
<i>477</i>&nbsp;    private static void recycleRectangle(Rectangle rect) {
<i>478</i>&nbsp;        synchronized(tempRectangles) {
<i>479</i>&nbsp;            tempRectangles.add(rect);
<i>480</i>&nbsp;        }
<i>481</i>&nbsp;    }
<i>482</i>&nbsp;
<i>483</i>&nbsp;    /**
<i>484</i>&nbsp;     * Sets whether or not &lt;code&gt;getComponentPopupMenu&lt;/code&gt; should delegate
<i>485</i>&nbsp;     * to the parent if this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt;
<i>486</i>&nbsp;     * assigned to it.
<i>487</i>&nbsp;     * &lt;p&gt;
<i>488</i>&nbsp;     * The default value for this is false, but some &lt;code&gt;JComponent&lt;/code&gt;
<i>489</i>&nbsp;     * subclasses that are implemented as a number of &lt;code&gt;JComponent&lt;/code&gt;s
<i>490</i>&nbsp;     * may set this to true.
<b class="nc"><i>491</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>492</i>&nbsp;     * This is a bound property.</b>
<b class="nc"><i>493</i>&nbsp;     *</b>
<i>494</i>&nbsp;     * @param value whether or not the JPopupMenu is inherited
<i>495</i>&nbsp;     * @see #setComponentPopupMenu
<i>496</i>&nbsp;     * @since 1.5
<i>497</i>&nbsp;     */
<i>498</i>&nbsp;    @BeanProperty(description
<i>499</i>&nbsp;            = &quot;Whether or not the JPopupMenu is inherited&quot;)
<i>500</i>&nbsp;    public void setInheritsPopupMenu(boolean value) {
<i>501</i>&nbsp;        boolean oldValue = getFlag(INHERITS_POPUP_MENU);
<i>502</i>&nbsp;        setFlag(INHERITS_POPUP_MENU, value);
<b class="nc"><i>503</i>&nbsp;        firePropertyChange(&quot;inheritsPopupMenu&quot;, oldValue, value);</b>
<i>504</i>&nbsp;    }
<i>505</i>&nbsp;
<i>506</i>&nbsp;    /**
<i>507</i>&nbsp;     * Returns true if the JPopupMenu should be inherited from the parent.
<i>508</i>&nbsp;     *
<i>509</i>&nbsp;     * @return true if the JPopupMenu should be inherited from the parent
<i>510</i>&nbsp;     * @see #setComponentPopupMenu
<i>511</i>&nbsp;     * @since 1.5
<i>512</i>&nbsp;     */
<i>513</i>&nbsp;    public boolean getInheritsPopupMenu() {
<i>514</i>&nbsp;        return getFlag(INHERITS_POPUP_MENU);
<i>515</i>&nbsp;    }
<i>516</i>&nbsp;
<i>517</i>&nbsp;    /**
<i>518</i>&nbsp;     * Sets the &lt;code&gt;JPopupMenu&lt;/code&gt; for this &lt;code&gt;JComponent&lt;/code&gt;.
<i>519</i>&nbsp;     * The UI is responsible for registering bindings and adding the necessary
<i>520</i>&nbsp;     * listeners such that the &lt;code&gt;JPopupMenu&lt;/code&gt; will be shown at
<i>521</i>&nbsp;     * the appropriate time. When the &lt;code&gt;JPopupMenu&lt;/code&gt; is shown
<i>522</i>&nbsp;     * depends upon the look and feel: some may show it on a mouse event,
<i>523</i>&nbsp;     * some may enable a key binding.
<i>524</i>&nbsp;     * &lt;p&gt;
<i>525</i>&nbsp;     * If &lt;code&gt;popup&lt;/code&gt; is null, and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt;
<i>526</i>&nbsp;     * returns true, then &lt;code&gt;getComponentPopupMenu&lt;/code&gt; will be delegated
<i>527</i>&nbsp;     * to the parent. This provides for a way to make all child components
<i>528</i>&nbsp;     * inherit the popupmenu of the parent.
<i>529</i>&nbsp;     * &lt;p&gt;
<i>530</i>&nbsp;     * This is a bound property.
<b class="nc"><i>531</i>&nbsp;     *</b>
<b class="nc"><i>532</i>&nbsp;     * @param popup - the popup that will be assigned to this component</b>
<i>533</i>&nbsp;     *                may be null
<b class="nc"><i>534</i>&nbsp;     * @see #getComponentPopupMenu</b>
<b class="nc"><i>535</i>&nbsp;     * @since 1.5</b>
<b class="nc"><i>536</i>&nbsp;     */</b>
<i>537</i>&nbsp;    @BeanProperty(preferred = true, description
<i>538</i>&nbsp;            = &quot;Popup to show&quot;)
<i>539</i>&nbsp;    public void setComponentPopupMenu(JPopupMenu popup) {
<i>540</i>&nbsp;        if(popup != null) {
<i>541</i>&nbsp;            enableEvents(AWTEvent.MOUSE_EVENT_MASK);
<i>542</i>&nbsp;        }
<i>543</i>&nbsp;        JPopupMenu oldPopup = this.popupMenu;
<i>544</i>&nbsp;        this.popupMenu = popup;
<i>545</i>&nbsp;        firePropertyChange(&quot;componentPopupMenu&quot;, oldPopup, popup);
<i>546</i>&nbsp;    }
<i>547</i>&nbsp;
<i>548</i>&nbsp;    /**
<i>549</i>&nbsp;     * Returns &lt;code&gt;JPopupMenu&lt;/code&gt; that assigned for this component.
<i>550</i>&nbsp;     * If this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt; assigned
<i>551</i>&nbsp;     * to it and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt; is true, this
<i>552</i>&nbsp;     * will return &lt;code&gt;getParent().getComponentPopupMenu()&lt;/code&gt; (assuming
<b class="nc"><i>553</i>&nbsp;     * the parent is valid.)</b>
<b class="nc"><i>554</i>&nbsp;     *</b>
<i>555</i>&nbsp;     * @return &lt;code&gt;JPopupMenu&lt;/code&gt; assigned for this component
<i>556</i>&nbsp;     *         or &lt;code&gt;null&lt;/code&gt; if no popup assigned
<b class="nc"><i>557</i>&nbsp;     * @see #setComponentPopupMenu</b>
<i>558</i>&nbsp;     * @since 1.5
<b class="nc"><i>559</i>&nbsp;     */</b>
<b class="nc"><i>560</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
<b class="nc"><i>561</i>&nbsp;    public JPopupMenu getComponentPopupMenu() {</b>
<b class="nc"><i>562</i>&nbsp;</b>
<i>563</i>&nbsp;        if(!getInheritsPopupMenu()) {
<b class="nc"><i>564</i>&nbsp;            return popupMenu;</b>
<i>565</i>&nbsp;        }
<i>566</i>&nbsp;
<b class="nc"><i>567</i>&nbsp;        if(popupMenu == null) {</b>
<i>568</i>&nbsp;            // Search parents for its popup
<b class="nc"><i>569</i>&nbsp;            Container parent = getParent();</b>
<i>570</i>&nbsp;            while (parent != null) {
<b class="nc"><i>571</i>&nbsp;                if(parent instanceof JComponent) {</b>
<i>572</i>&nbsp;                    return ((JComponent)parent).getComponentPopupMenu();
<i>573</i>&nbsp;                }
<b class="nc"><i>574</i>&nbsp;                if(parent instanceof Window ||</b>
<i>575</i>&nbsp;                   parent instanceof Applet) {
<i>576</i>&nbsp;                    // Reached toplevel, break and return null
<i>577</i>&nbsp;                    break;
<i>578</i>&nbsp;                }
<i>579</i>&nbsp;                parent = parent.getParent();
<i>580</i>&nbsp;            }
<i>581</i>&nbsp;            return null;
<i>582</i>&nbsp;        }
<i>583</i>&nbsp;
<i>584</i>&nbsp;        return popupMenu;
<i>585</i>&nbsp;    }
<i>586</i>&nbsp;
<i>587</i>&nbsp;    /**
<b class="nc"><i>588</i>&nbsp;     * Default &lt;code&gt;JComponent&lt;/code&gt; constructor.  This constructor does</b>
<i>589</i>&nbsp;     * very little initialization beyond calling the &lt;code&gt;Container&lt;/code&gt;
<i>590</i>&nbsp;     * constructor.  For example, the initial layout manager is
<i>591</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt;. It does, however, set the component&#39;s locale
<b class="nc"><i>592</i>&nbsp;     * property to the value returned by</b>
<b class="nc"><i>593</i>&nbsp;     * &lt;code&gt;JComponent.getDefaultLocale&lt;/code&gt;.</b>
<b class="nc"><i>594</i>&nbsp;     *</b>
<i>595</i>&nbsp;     * @see #getDefaultLocale
<b class="nc"><i>596</i>&nbsp;     */</b>
<b class="nc"><i>597</i>&nbsp;    public JComponent() {</b>
<i>598</i>&nbsp;        super();
<b class="nc"><i>599</i>&nbsp;        // We enable key events on all JComponents so that accessibility</b>
<i>600</i>&nbsp;        // bindings will work everywhere. This is a partial fix to BugID
<i>601</i>&nbsp;        // 4282211.
<b class="nc"><i>602</i>&nbsp;        enableEvents(AWTEvent.KEY_EVENT_MASK);</b>
<i>603</i>&nbsp;        if (isManagingFocus()) {
<i>604</i>&nbsp;            LookAndFeel.installProperty(this,
<i>605</i>&nbsp;                                        &quot;focusTraversalKeysForward&quot;,
<i>606</i>&nbsp;                                  getManagingFocusForwardTraversalKeys());
<i>607</i>&nbsp;            LookAndFeel.installProperty(this,
<i>608</i>&nbsp;                                        &quot;focusTraversalKeysBackward&quot;,
<i>609</i>&nbsp;                                  getManagingFocusBackwardTraversalKeys());
<i>610</i>&nbsp;        }
<i>611</i>&nbsp;
<i>612</i>&nbsp;        super.setLocale( JComponent.getDefaultLocale() );
<i>613</i>&nbsp;    }
<i>614</i>&nbsp;
<i>615</i>&nbsp;
<i>616</i>&nbsp;    /**
<i>617</i>&nbsp;     * Resets the UI property to a value from the current look and feel.
<i>618</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; subclasses must override this method
<i>619</i>&nbsp;     * like this:
<i>620</i>&nbsp;     * &lt;pre&gt;
<i>621</i>&nbsp;     *   public void updateUI() {
<i>622</i>&nbsp;     *      setUI((SliderUI)UIManager.getUI(this);
<i>623</i>&nbsp;     *   }
<i>624</i>&nbsp;     *  &lt;/pre&gt;
<i>625</i>&nbsp;     *
<i>626</i>&nbsp;     * @see #setUI
<i>627</i>&nbsp;     * @see UIManager#getLookAndFeel
<i>628</i>&nbsp;     * @see UIManager#getUI
<i>629</i>&nbsp;     */
<i>630</i>&nbsp;    public void updateUI() {}
<i>631</i>&nbsp;
<i>632</i>&nbsp;    /**
<i>633</i>&nbsp;     * Returns the look and feel delegate that renders this component.
<i>634</i>&nbsp;     *
<i>635</i>&nbsp;     * @return the {@code ComponentUI} object that renders this component
<i>636</i>&nbsp;     * @since 9
<i>637</i>&nbsp;     */
<i>638</i>&nbsp;    @Transient
<i>639</i>&nbsp;    public ComponentUI getUI() {
<i>640</i>&nbsp;        return ui;
<i>641</i>&nbsp;    }
<i>642</i>&nbsp;
<i>643</i>&nbsp;    /**
<i>644</i>&nbsp;     * Sets the look and feel delegate for this component.
<i>645</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; subclasses generally override this method
<i>646</i>&nbsp;     * to narrow the argument type. For example, in &lt;code&gt;JSlider&lt;/code&gt;:
<i>647</i>&nbsp;     * &lt;pre&gt;
<i>648</i>&nbsp;     * public void setUI(SliderUI newUI) {
<i>649</i>&nbsp;     *     super.setUI(newUI);
<i>650</i>&nbsp;     * }
<i>651</i>&nbsp;     *  &lt;/pre&gt;
<i>652</i>&nbsp;     * &lt;p&gt;
<i>653</i>&nbsp;     * Additionally &lt;code&gt;JComponent&lt;/code&gt; subclasses must provide a
<i>654</i>&nbsp;     * &lt;code&gt;getUI&lt;/code&gt; method that returns the correct type.  For example:
<i>655</i>&nbsp;     * &lt;pre&gt;
<i>656</i>&nbsp;     * public SliderUI getUI() {
<i>657</i>&nbsp;     *     return (SliderUI)ui;
<b class="nc"><i>658</i>&nbsp;     * }</b>
<i>659</i>&nbsp;     * &lt;/pre&gt;
<i>660</i>&nbsp;     *
<b class="nc"><i>661</i>&nbsp;     * @param newUI the new UI delegate</b>
<b class="nc"><i>662</i>&nbsp;     * @see #updateUI</b>
<b class="nc"><i>663</i>&nbsp;     * @see UIManager#getLookAndFeel</b>
<b class="nc"><i>664</i>&nbsp;     * @see UIManager#getUI</b>
<b class="nc"><i>665</i>&nbsp;     */</b>
<b class="nc"><i>666</i>&nbsp;    @BeanProperty(hidden = true, visualUpdate = true, description</b>
<i>667</i>&nbsp;            = &quot;The component&#39;s look and feel delegate.&quot;)
<i>668</i>&nbsp;    protected void setUI(ComponentUI newUI) {
<b class="nc"><i>669</i>&nbsp;        /* We do not check that the UI instance is different</b>
<b class="nc"><i>670</i>&nbsp;         * before allowing the switch in order to enable the</b>
<b class="nc"><i>671</i>&nbsp;         * same UI instance *with different default settings*</b>
<i>672</i>&nbsp;         * to be installed.
<i>673</i>&nbsp;         */
<i>674</i>&nbsp;
<i>675</i>&nbsp;        uninstallUIAndProperties();
<i>676</i>&nbsp;
<i>677</i>&nbsp;        // aaText shouldn&#39;t persist between look and feels, reset it.
<i>678</i>&nbsp;        aaHint = UIManager.getDefaults().get(
<i>679</i>&nbsp;                RenderingHints.KEY_TEXT_ANTIALIASING);
<b class="nc"><i>680</i>&nbsp;        lcdRenderingHint = UIManager.getDefaults().get(</b>
<b class="nc"><i>681</i>&nbsp;                RenderingHints.KEY_TEXT_LCD_CONTRAST);</b>
<i>682</i>&nbsp;        ComponentUI oldUI = ui;
<b class="nc"><i>683</i>&nbsp;        ui = newUI;</b>
<b class="nc"><i>684</i>&nbsp;        if (ui != null) {</b>
<b class="nc"><i>685</i>&nbsp;            ui.installUI(this);</b>
<b class="nc"><i>686</i>&nbsp;        }</b>
<b class="nc"><i>687</i>&nbsp;</b>
<b class="nc"><i>688</i>&nbsp;        firePropertyChange(&quot;UI&quot;, oldUI, newUI);</b>
<b class="nc"><i>689</i>&nbsp;        revalidate();</b>
<b class="nc"><i>690</i>&nbsp;        repaint();</b>
<i>691</i>&nbsp;    }
<i>692</i>&nbsp;
<i>693</i>&nbsp;    /**
<b class="nc"><i>694</i>&nbsp;     * Uninstalls the UI, if any, and any client properties designated</b>
<i>695</i>&nbsp;     * as being specific to the installed UI - instances of
<i>696</i>&nbsp;     * {@code UIClientPropertyKey}.
<i>697</i>&nbsp;     */
<i>698</i>&nbsp;    private void uninstallUIAndProperties() {
<i>699</i>&nbsp;        if (ui != null) {
<i>700</i>&nbsp;            ui.uninstallUI(this);
<i>701</i>&nbsp;            //clean UIClientPropertyKeys from client properties
<i>702</i>&nbsp;            if (clientProperties != null) {
<i>703</i>&nbsp;                synchronized(clientProperties) {
<i>704</i>&nbsp;                    Object[] clientPropertyKeys =
<i>705</i>&nbsp;                        clientProperties.getKeys(null);
<i>706</i>&nbsp;                    if (clientPropertyKeys != null) {
<i>707</i>&nbsp;                        for (Object key : clientPropertyKeys) {
<i>708</i>&nbsp;                            if (key instanceof UIClientPropertyKey) {
<i>709</i>&nbsp;                                putClientProperty(key, null);
<i>710</i>&nbsp;                            }
<i>711</i>&nbsp;                        }
<i>712</i>&nbsp;                    }
<i>713</i>&nbsp;                }
<i>714</i>&nbsp;            }
<i>715</i>&nbsp;        }
<i>716</i>&nbsp;    }
<b class="nc"><i>717</i>&nbsp;</b>
<i>718</i>&nbsp;    /**
<i>719</i>&nbsp;     * Returns the &lt;code&gt;UIDefaults&lt;/code&gt; key used to
<i>720</i>&nbsp;     * look up the name of the &lt;code&gt;swing.plaf.ComponentUI&lt;/code&gt;
<i>721</i>&nbsp;     * class that defines the look and feel
<i>722</i>&nbsp;     * for this component.  Most applications will never need to
<i>723</i>&nbsp;     * call this method.  Subclasses of &lt;code&gt;JComponent&lt;/code&gt; that support
<i>724</i>&nbsp;     * pluggable look and feel should override this method to
<i>725</i>&nbsp;     * return a &lt;code&gt;UIDefaults&lt;/code&gt; key that maps to the
<i>726</i>&nbsp;     * &lt;code&gt;ComponentUI&lt;/code&gt; subclass that defines their look and feel.
<i>727</i>&nbsp;     *
<i>728</i>&nbsp;     * @return the &lt;code&gt;UIDefaults&lt;/code&gt; key for a
<i>729</i>&nbsp;     *          &lt;code&gt;ComponentUI&lt;/code&gt; subclass
<i>730</i>&nbsp;     * @see UIDefaults#getUI
<i>731</i>&nbsp;     */
<b class="nc"><i>732</i>&nbsp;    @BeanProperty(bound = false, expert = true, description</b>
<b class="nc"><i>733</i>&nbsp;            = &quot;UIClassID&quot;)</b>
<b class="nc"><i>734</i>&nbsp;    public String getUIClassID() {</b>
<b class="nc"><i>735</i>&nbsp;        return uiClassID;</b>
<i>736</i>&nbsp;    }
<b class="nc"><i>737</i>&nbsp;</b>
<i>738</i>&nbsp;
<i>739</i>&nbsp;    /**
<b class="nc"><i>740</i>&nbsp;     * Returns the graphics object used to paint this component.</b>
<b class="nc"><i>741</i>&nbsp;     * If &lt;code&gt;DebugGraphics&lt;/code&gt; is turned on we create a new</b>
<i>742</i>&nbsp;     * &lt;code&gt;DebugGraphics&lt;/code&gt; object if necessary.
<b class="nc"><i>743</i>&nbsp;     * Otherwise we just configure the</b>
<i>744</i>&nbsp;     * specified graphics object&#39;s foreground and font.
<i>745</i>&nbsp;     *
<i>746</i>&nbsp;     * @param g the original &lt;code&gt;Graphics&lt;/code&gt; object
<i>747</i>&nbsp;     * @return a &lt;code&gt;Graphics&lt;/code&gt; object configured for this component
<i>748</i>&nbsp;     */
<i>749</i>&nbsp;    protected Graphics getComponentGraphics(Graphics g) {
<i>750</i>&nbsp;        Graphics componentGraphics = g;
<i>751</i>&nbsp;        if (ui != null &amp;&amp; DEBUG_GRAPHICS_LOADED) {
<i>752</i>&nbsp;            if ((DebugGraphics.debugComponentCount() != 0) &amp;&amp;
<i>753</i>&nbsp;                    (shouldDebugGraphics() != 0) &amp;&amp;
<i>754</i>&nbsp;                    !(g instanceof DebugGraphics)) {
<i>755</i>&nbsp;                componentGraphics = new DebugGraphics(g,this);
<i>756</i>&nbsp;            }
<i>757</i>&nbsp;        }
<i>758</i>&nbsp;        componentGraphics.setColor(getForeground());
<i>759</i>&nbsp;        componentGraphics.setFont(getFont());
<i>760</i>&nbsp;
<i>761</i>&nbsp;        return componentGraphics;
<i>762</i>&nbsp;    }
<i>763</i>&nbsp;
<i>764</i>&nbsp;
<i>765</i>&nbsp;    /**
<i>766</i>&nbsp;     * Calls the UI delegate&#39;s paint method, if the UI delegate
<i>767</i>&nbsp;     * is non-&lt;code&gt;null&lt;/code&gt;.  We pass the delegate a copy of the
<i>768</i>&nbsp;     * &lt;code&gt;Graphics&lt;/code&gt; object to protect the rest of the
<i>769</i>&nbsp;     * paint code from irrevocable changes
<i>770</i>&nbsp;     * (for example, &lt;code&gt;Graphics.translate&lt;/code&gt;).
<i>771</i>&nbsp;     * &lt;p&gt;
<i>772</i>&nbsp;     * If you override this in a subclass you should not make permanent
<i>773</i>&nbsp;     * changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
<i>774</i>&nbsp;     * should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
<i>775</i>&nbsp;     * transform. If you need to do these operations you may find it
<i>776</i>&nbsp;     * easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
<b class="nc"><i>777</i>&nbsp;     * &lt;code&gt;Graphics&lt;/code&gt; and manipulate it. Further, if you do not</b>
<b class="nc"><i>778</i>&nbsp;     * invoke super&#39;s implementation you must honor the opaque property, that is</b>
<i>779</i>&nbsp;     * if this component is opaque, you must completely fill in the background
<b class="nc"><i>780</i>&nbsp;     * in an opaque color. If you do not honor the opaque property you</b>
<i>781</i>&nbsp;     * will likely see visual artifacts.
<i>782</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>783</i>&nbsp;     * The passed in &lt;code&gt;Graphics&lt;/code&gt; object might</b>
<b class="nc"><i>784</i>&nbsp;     * have a transform other than the identify transform</b>
<i>785</i>&nbsp;     * installed on it.  In this case, you might get
<i>786</i>&nbsp;     * unexpected results if you cumulatively apply
<i>787</i>&nbsp;     * another transform.
<i>788</i>&nbsp;     *
<i>789</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; object to protect
<i>790</i>&nbsp;     * @see #paint
<i>791</i>&nbsp;     * @see ComponentUI
<i>792</i>&nbsp;     */
<i>793</i>&nbsp;    protected void paintComponent(Graphics g) {
<i>794</i>&nbsp;        if (ui != null) {
<i>795</i>&nbsp;            Graphics scratchGraphics = (g == null) ? null : g.create();
<i>796</i>&nbsp;            try {
<i>797</i>&nbsp;                ui.update(scratchGraphics, this);
<i>798</i>&nbsp;            }
<i>799</i>&nbsp;            finally {
<b class="nc"><i>800</i>&nbsp;                scratchGraphics.dispose();</b>
<i>801</i>&nbsp;            }
<b class="nc"><i>802</i>&nbsp;        }</b>
<b class="nc"><i>803</i>&nbsp;    }</b>
<b class="nc"><i>804</i>&nbsp;</b>
<b class="nc"><i>805</i>&nbsp;    /**</b>
<i>806</i>&nbsp;     * Paints this component&#39;s children.
<i>807</i>&nbsp;     * If &lt;code&gt;shouldUseBuffer&lt;/code&gt; is true,
<i>808</i>&nbsp;     * no component ancestor has a buffer and
<b class="nc"><i>809</i>&nbsp;     * the component children can use a buffer if they have one.</b>
<i>810</i>&nbsp;     * Otherwise, one ancestor has a buffer currently in use and children
<b class="nc"><i>811</i>&nbsp;     * should not use a buffer to paint.</b>
<b class="nc"><i>812</i>&nbsp;     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint</b>
<b class="nc"><i>813</i>&nbsp;     * @see #paint</b>
<b class="nc"><i>814</i>&nbsp;     * @see java.awt.Container#paint</b>
<i>815</i>&nbsp;     */
<i>816</i>&nbsp;    protected void paintChildren(Graphics g) {
<i>817</i>&nbsp;        Graphics sg = g;
<b class="nc"><i>818</i>&nbsp;</b>
<b class="nc"><i>819</i>&nbsp;        synchronized(getTreeLock()) {</b>
<b class="nc"><i>820</i>&nbsp;            int i = getComponentCount() - 1;</b>
<b class="nc"><i>821</i>&nbsp;            if (i &lt; 0) {</b>
<b class="nc"><i>822</i>&nbsp;                return;</b>
<b class="nc"><i>823</i>&nbsp;            }</b>
<b class="nc"><i>824</i>&nbsp;            // If we are only to paint to a specific child, determine</b>
<b class="nc"><i>825</i>&nbsp;            // its index.</b>
<b class="nc"><i>826</i>&nbsp;            if (paintingChild != null &amp;&amp;</b>
<i>827</i>&nbsp;                (paintingChild instanceof JComponent) &amp;&amp;
<i>828</i>&nbsp;                paintingChild.isOpaque()) {
<b class="nc"><i>829</i>&nbsp;                for (; i &gt;= 0; i--) {</b>
<b class="nc"><i>830</i>&nbsp;                    if (getComponent(i) == paintingChild){</b>
<b class="nc"><i>831</i>&nbsp;                        break;</b>
<b class="nc"><i>832</i>&nbsp;                    }</b>
<b class="nc"><i>833</i>&nbsp;                }</b>
<b class="nc"><i>834</i>&nbsp;            }</b>
<b class="nc"><i>835</i>&nbsp;            Rectangle tmpRect = fetchRectangle();</b>
<i>836</i>&nbsp;            boolean checkSiblings = (!isOptimizedDrawingEnabled() &amp;&amp;
<i>837</i>&nbsp;                                     checkIfChildObscuredBySibling());
<b class="nc"><i>838</i>&nbsp;            Rectangle clipBounds = null;</b>
<i>839</i>&nbsp;            if (checkSiblings) {
<i>840</i>&nbsp;                clipBounds = sg.getClipBounds();
<i>841</i>&nbsp;                if (clipBounds == null) {
<b class="nc"><i>842</i>&nbsp;                    clipBounds = new Rectangle(0, 0, getWidth(),</b>
<b class="nc"><i>843</i>&nbsp;                                               getHeight());</b>
<i>844</i>&nbsp;                }
<i>845</i>&nbsp;            }
<i>846</i>&nbsp;            boolean printing = getFlag(IS_PRINTING);
<b class="nc"><i>847</i>&nbsp;            final Window window = SwingUtilities.getWindowAncestor(this);</b>
<b class="nc"><i>848</i>&nbsp;            final boolean isWindowOpaque = window == null || window.isOpaque();</b>
<b class="nc"><i>849</i>&nbsp;            for (; i &gt;= 0 ; i--) {</b>
<b class="nc"><i>850</i>&nbsp;                Component comp = getComponent(i);</b>
<i>851</i>&nbsp;                if (comp == null) {
<i>852</i>&nbsp;                    continue;
<b class="nc"><i>853</i>&nbsp;                }</b>
<b class="nc"><i>854</i>&nbsp;</b>
<b class="nc"><i>855</i>&nbsp;                final boolean isJComponent = comp instanceof JComponent;</b>
<b class="nc"><i>856</i>&nbsp;</b>
<b class="nc"><i>857</i>&nbsp;                // Enable painting of heavyweights in non-opaque windows.</b>
<b class="nc"><i>858</i>&nbsp;                // See 6884960</b>
<b class="nc"><i>859</i>&nbsp;                if ((!isWindowOpaque || isJComponent ||</b>
<b class="nc"><i>860</i>&nbsp;                            isLightweightComponent(comp)) &amp;&amp; comp.isVisible())</b>
<i>861</i>&nbsp;                {
<i>862</i>&nbsp;                    Rectangle cr;
<b class="nc"><i>863</i>&nbsp;</b>
<i>864</i>&nbsp;                    cr = comp.getBounds(tmpRect);
<b class="nc"><i>865</i>&nbsp;                    Shape clip = g.getClip();</b>
<i>866</i>&nbsp;                    boolean hitClip = (clip != null)
<b class="nc"><i>867</i>&nbsp;                            ? clip.intersects(cr.x, cr.y, cr.width, cr.height)</b>
<b class="nc"><i>868</i>&nbsp;                            : true;</b>
<b class="nc"><i>869</i>&nbsp;</b>
<b class="nc"><i>870</i>&nbsp;                    if (hitClip) {</b>
<i>871</i>&nbsp;                        if (checkSiblings &amp;&amp; i &gt; 0) {
<b class="nc"><i>872</i>&nbsp;                            int x = cr.x;</b>
<i>873</i>&nbsp;                            int y = cr.y;
<b class="nc"><i>874</i>&nbsp;                            int width = cr.width;</b>
<b class="nc"><i>875</i>&nbsp;                            int height = cr.height;</b>
<b class="nc"><i>876</i>&nbsp;                            SwingUtilities.computeIntersection</b>
<i>877</i>&nbsp;                                (clipBounds.x, clipBounds.y,
<b class="nc"><i>878</i>&nbsp;                                 clipBounds.width, clipBounds.height, cr);</b>
<b class="nc"><i>879</i>&nbsp;</b>
<b class="nc"><i>880</i>&nbsp;                            if(getObscuredState(i, cr.x, cr.y, cr.width,</b>
<i>881</i>&nbsp;                                          cr.height) == COMPLETELY_OBSCURED) {
<b class="nc"><i>882</i>&nbsp;                                continue;</b>
<i>883</i>&nbsp;                            }
<b class="nc"><i>884</i>&nbsp;                            cr.x = x;</b>
<b class="nc"><i>885</i>&nbsp;                            cr.y = y;</b>
<i>886</i>&nbsp;                            cr.width = width;
<b class="nc"><i>887</i>&nbsp;                            cr.height = height;</b>
<i>888</i>&nbsp;                        }
<b class="nc"><i>889</i>&nbsp;                        Graphics cg = sg.create(cr.x, cr.y, cr.width,</b>
<b class="nc"><i>890</i>&nbsp;                                                cr.height);</b>
<i>891</i>&nbsp;                        cg.setColor(comp.getForeground());
<i>892</i>&nbsp;                        cg.setFont(comp.getFont());
<b class="nc"><i>893</i>&nbsp;                        boolean shouldSetFlagBack = false;</b>
<b class="nc"><i>894</i>&nbsp;                        try {</b>
<i>895</i>&nbsp;                            if(isJComponent) {
<i>896</i>&nbsp;                                if(getFlag(ANCESTOR_USING_BUFFER)) {
<b class="nc"><i>897</i>&nbsp;                                    ((JComponent)comp).setFlag(</b>
<i>898</i>&nbsp;                                                 ANCESTOR_USING_BUFFER,true);
<i>899</i>&nbsp;                                    shouldSetFlagBack = true;
<i>900</i>&nbsp;                                }
<i>901</i>&nbsp;                                if(getFlag(IS_PAINTING_TILE)) {
<i>902</i>&nbsp;                                    ((JComponent)comp).setFlag(
<b class="nc"><i>903</i>&nbsp;                                                 IS_PAINTING_TILE,true);</b>
<b class="nc"><i>904</i>&nbsp;                                    shouldSetFlagBack = true;</b>
<i>905</i>&nbsp;                                }
<i>906</i>&nbsp;                                if(!printing) {
<b class="nc"><i>907</i>&nbsp;                                    comp.paint(cg);</b>
<b class="nc"><i>908</i>&nbsp;                                }</b>
<i>909</i>&nbsp;                                else {
<i>910</i>&nbsp;                                    if (!getFlag(IS_PRINTING_ALL)) {
<b class="nc"><i>911</i>&nbsp;                                        comp.print(cg);</b>
<i>912</i>&nbsp;                                    }
<i>913</i>&nbsp;                                    else {
<i>914</i>&nbsp;                                        comp.printAll(cg);
<i>915</i>&nbsp;                                    }
<b class="nc"><i>916</i>&nbsp;                                }</b>
<b class="nc"><i>917</i>&nbsp;                            } else {</b>
<b class="nc"><i>918</i>&nbsp;                                // The component is either lightweight, or</b>
<i>919</i>&nbsp;                                // heavyweight in a non-opaque window
<b class="nc"><i>920</i>&nbsp;                                if (!printing) {</b>
<i>921</i>&nbsp;                                    comp.paint(cg);
<i>922</i>&nbsp;                                }
<i>923</i>&nbsp;                                else {
<i>924</i>&nbsp;                                    if (!getFlag(IS_PRINTING_ALL)) {
<i>925</i>&nbsp;                                        comp.print(cg);
<i>926</i>&nbsp;                                    }
<i>927</i>&nbsp;                                    else {
<b class="nc"><i>928</i>&nbsp;                                        comp.printAll(cg);</b>
<b class="nc"><i>929</i>&nbsp;                                    }</b>
<i>930</i>&nbsp;                                }
<i>931</i>&nbsp;                            }
<i>932</i>&nbsp;                        } finally {
<i>933</i>&nbsp;                            cg.dispose();
<i>934</i>&nbsp;                            if(shouldSetFlagBack) {
<i>935</i>&nbsp;                                ((JComponent)comp).setFlag(
<i>936</i>&nbsp;                                             ANCESTOR_USING_BUFFER,false);
<i>937</i>&nbsp;                                ((JComponent)comp).setFlag(
<i>938</i>&nbsp;                                             IS_PAINTING_TILE,false);
<i>939</i>&nbsp;                            }
<i>940</i>&nbsp;                        }
<i>941</i>&nbsp;                    }
<i>942</i>&nbsp;                }
<i>943</i>&nbsp;
<i>944</i>&nbsp;            }
<i>945</i>&nbsp;            recycleRectangle(tmpRect);
<i>946</i>&nbsp;        }
<i>947</i>&nbsp;    }
<b class="nc"><i>948</i>&nbsp;</b>
<b class="nc"><i>949</i>&nbsp;    /**</b>
<b class="nc"><i>950</i>&nbsp;     * Paints the component&#39;s border.</b>
<i>951</i>&nbsp;     * &lt;p&gt;
<i>952</i>&nbsp;     * If you override this in a subclass you should not make permanent
<i>953</i>&nbsp;     * changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
<i>954</i>&nbsp;     * should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
<i>955</i>&nbsp;     * transform. If you need to do these operations you may find it
<i>956</i>&nbsp;     * easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
<i>957</i>&nbsp;     * &lt;code&gt;Graphics&lt;/code&gt; and manipulate it.
<i>958</i>&nbsp;     *
<i>959</i>&nbsp;     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<i>960</i>&nbsp;     *
<i>961</i>&nbsp;     * @see #paint
<i>962</i>&nbsp;     * @see #setBorder
<i>963</i>&nbsp;     */
<i>964</i>&nbsp;    protected void paintBorder(Graphics g) {
<i>965</i>&nbsp;        Border border = getBorder();
<b class="nc"><i>966</i>&nbsp;        if (border != null) {</b>
<i>967</i>&nbsp;            border.paintBorder(this, g, 0, 0, getWidth(), getHeight());
<i>968</i>&nbsp;        }
<i>969</i>&nbsp;    }
<i>970</i>&nbsp;
<i>971</i>&nbsp;
<i>972</i>&nbsp;    /**
<i>973</i>&nbsp;     * Calls &lt;code&gt;paint&lt;/code&gt;.  Doesn&#39;t clear the background but see
<i>974</i>&nbsp;     * &lt;code&gt;ComponentUI.update&lt;/code&gt;, which is called by
<i>975</i>&nbsp;     * &lt;code&gt;paintComponent&lt;/code&gt;.
<i>976</i>&nbsp;     *
<i>977</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<i>978</i>&nbsp;     * @see #paint
<i>979</i>&nbsp;     * @see #paintComponent
<i>980</i>&nbsp;     * @see javax.swing.plaf.ComponentUI
<i>981</i>&nbsp;     */
<i>982</i>&nbsp;    public void update(Graphics g) {
<i>983</i>&nbsp;        paint(g);
<i>984</i>&nbsp;    }
<i>985</i>&nbsp;
<i>986</i>&nbsp;
<i>987</i>&nbsp;    /**
<i>988</i>&nbsp;     * Invoked by Swing to draw components.
<i>989</i>&nbsp;     * Applications should not invoke &lt;code&gt;paint&lt;/code&gt; directly,
<i>990</i>&nbsp;     * but should instead use the &lt;code&gt;repaint&lt;/code&gt; method to
<i>991</i>&nbsp;     * schedule the component for redrawing.
<i>992</i>&nbsp;     * &lt;p&gt;
<i>993</i>&nbsp;     * This method actually delegates the work of painting to three
<i>994</i>&nbsp;     * protected methods: &lt;code&gt;paintComponent&lt;/code&gt;,
<i>995</i>&nbsp;     * &lt;code&gt;paintBorder&lt;/code&gt;,
<b class="nc"><i>996</i>&nbsp;     * and &lt;code&gt;paintChildren&lt;/code&gt;.  They&#39;re called in the order</b>
<i>997</i>&nbsp;     * listed to ensure that children appear on top of component itself.
<b class="nc"><i>998</i>&nbsp;     * Generally speaking, the component and its children should not</b>
<i>999</i>&nbsp;     * paint in the insets area allocated to the border. Subclasses can
<i>1000</i>&nbsp;     * just override this method, as always.  A subclass that just
<i>1001</i>&nbsp;     * wants to specialize the UI (look and feel) delegate&#39;s
<b class="nc"><i>1002</i>&nbsp;     * &lt;code&gt;paint&lt;/code&gt; method should just override</b>
<b class="nc"><i>1003</i>&nbsp;     * &lt;code&gt;paintComponent&lt;/code&gt;.</b>
<i>1004</i>&nbsp;     *
<b class="nc"><i>1005</i>&nbsp;     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint</b>
<b class="nc"><i>1006</i>&nbsp;     * @see #paintComponent</b>
<i>1007</i>&nbsp;     * @see #paintBorder
<i>1008</i>&nbsp;     * @see #paintChildren
<i>1009</i>&nbsp;     * @see #getComponentGraphics
<i>1010</i>&nbsp;     * @see #repaint
<b class="nc"><i>1011</i>&nbsp;     */</b>
<b class="nc"><i>1012</i>&nbsp;    public void paint(Graphics g) {</b>
<b class="nc"><i>1013</i>&nbsp;        boolean shouldClearPaintFlags = false;</b>
<b class="nc"><i>1014</i>&nbsp;</b>
<i>1015</i>&nbsp;        if ((getWidth() &lt;= 0) || (getHeight() &lt;= 0)) {
<i>1016</i>&nbsp;            return;
<b class="nc"><i>1017</i>&nbsp;        }</b>
<b class="nc"><i>1018</i>&nbsp;</b>
<b class="nc"><i>1019</i>&nbsp;        Graphics componentGraphics = getComponentGraphics(g);</b>
<b class="nc"><i>1020</i>&nbsp;        Graphics co = componentGraphics.create();</b>
<i>1021</i>&nbsp;        try {
<i>1022</i>&nbsp;            RepaintManager repaintManager = RepaintManager.currentManager(this);
<b class="nc"><i>1023</i>&nbsp;            Rectangle clipRect = co.getClipBounds();</b>
<b class="nc"><i>1024</i>&nbsp;            int clipX;</b>
<i>1025</i>&nbsp;            int clipY;
<b class="nc"><i>1026</i>&nbsp;            int clipW;</b>
<b class="nc"><i>1027</i>&nbsp;            int clipH;</b>
<i>1028</i>&nbsp;            if (clipRect == null) {
<i>1029</i>&nbsp;                clipX = clipY = 0;
<b class="nc"><i>1030</i>&nbsp;                clipW = getWidth();</b>
<b class="nc"><i>1031</i>&nbsp;                clipH = getHeight();</b>
<b class="nc"><i>1032</i>&nbsp;            }</b>
<i>1033</i>&nbsp;            else {
<i>1034</i>&nbsp;                clipX = clipRect.x;
<i>1035</i>&nbsp;                clipY = clipRect.y;
<b class="nc"><i>1036</i>&nbsp;                clipW = clipRect.width;</b>
<b class="nc"><i>1037</i>&nbsp;                clipH = clipRect.height;</b>
<b class="nc"><i>1038</i>&nbsp;            }</b>
<b class="nc"><i>1039</i>&nbsp;</b>
<i>1040</i>&nbsp;            if(clipW &gt; getWidth()) {
<b class="nc"><i>1041</i>&nbsp;                clipW = getWidth();</b>
<i>1042</i>&nbsp;            }
<b class="nc"><i>1043</i>&nbsp;            if(clipH &gt; getHeight()) {</b>
<i>1044</i>&nbsp;                clipH = getHeight();
<i>1045</i>&nbsp;            }
<b class="nc"><i>1046</i>&nbsp;</b>
<b class="nc"><i>1047</i>&nbsp;            if(getParent() != null &amp;&amp; !(getParent() instanceof JComponent)) {</b>
<i>1048</i>&nbsp;                adjustPaintFlags();
<i>1049</i>&nbsp;                shouldClearPaintFlags = true;
<i>1050</i>&nbsp;            }
<b class="nc"><i>1051</i>&nbsp;</b>
<b class="nc"><i>1052</i>&nbsp;            int bw,bh;</b>
<i>1053</i>&nbsp;            boolean printing = getFlag(IS_PRINTING);
<i>1054</i>&nbsp;            if (!printing &amp;&amp; repaintManager.isDoubleBufferingEnabled() &amp;&amp;
<b class="nc"><i>1055</i>&nbsp;                !getFlag(ANCESTOR_USING_BUFFER) &amp;&amp; isDoubleBuffered() &amp;&amp;</b>
<b class="nc"><i>1056</i>&nbsp;                (getFlag(IS_REPAINTING) || repaintManager.isPainting()))</b>
<b class="nc"><i>1057</i>&nbsp;            {</b>
<b class="nc"><i>1058</i>&nbsp;                repaintManager.beginPaint();</b>
<i>1059</i>&nbsp;                try {
<i>1060</i>&nbsp;                    repaintManager.paint(this, this, co, clipX, clipY, clipW,
<b class="nc"><i>1061</i>&nbsp;                                         clipH);</b>
<b class="nc"><i>1062</i>&nbsp;                } finally {</b>
<i>1063</i>&nbsp;                    repaintManager.endPaint();
<i>1064</i>&nbsp;                }
<b class="nc"><i>1065</i>&nbsp;            }</b>
<b class="nc"><i>1066</i>&nbsp;            else {</b>
<i>1067</i>&nbsp;                // Will ocassionaly happen in 1.2, especially when printing.
<i>1068</i>&nbsp;                if (clipRect == null) {
<b class="nc"><i>1069</i>&nbsp;                    co.setClip(clipX, clipY, clipW, clipH);</b>
<i>1070</i>&nbsp;                }
<i>1071</i>&nbsp;
<i>1072</i>&nbsp;                if (!rectangleIsObscured(clipX,clipY,clipW,clipH)) {
<b class="nc"><i>1073</i>&nbsp;                    if (!printing) {</b>
<b class="nc"><i>1074</i>&nbsp;                        paintComponent(co);</b>
<b class="nc"><i>1075</i>&nbsp;                        paintBorder(co);</b>
<b class="nc"><i>1076</i>&nbsp;                    }</b>
<b class="nc"><i>1077</i>&nbsp;                    else {</b>
<b class="nc"><i>1078</i>&nbsp;                        printComponent(co);</b>
<i>1079</i>&nbsp;                        printBorder(co);
<i>1080</i>&nbsp;                    }
<i>1081</i>&nbsp;                }
<i>1082</i>&nbsp;                if (!printing) {
<i>1083</i>&nbsp;                    paintChildren(co);
<i>1084</i>&nbsp;                }
<i>1085</i>&nbsp;                else {
<i>1086</i>&nbsp;                    printChildren(co);
<i>1087</i>&nbsp;                }
<b class="nc"><i>1088</i>&nbsp;            }</b>
<b class="nc"><i>1089</i>&nbsp;        } finally {</b>
<b class="nc"><i>1090</i>&nbsp;            co.dispose();</b>
<b class="nc"><i>1091</i>&nbsp;            if(shouldClearPaintFlags) {</b>
<i>1092</i>&nbsp;                setFlag(ANCESTOR_USING_BUFFER,false);
<b class="nc"><i>1093</i>&nbsp;                setFlag(IS_PAINTING_TILE,false);</b>
<i>1094</i>&nbsp;                setFlag(IS_PRINTING,false);
<b class="nc"><i>1095</i>&nbsp;                setFlag(IS_PRINTING_ALL,false);</b>
<b class="nc"><i>1096</i>&nbsp;            }</b>
<b class="nc"><i>1097</i>&nbsp;        }</b>
<i>1098</i>&nbsp;    }
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;    // paint forcing use of the double buffer.  This is used for historical
<i>1101</i>&nbsp;    // reasons: JViewport, when scrolling, previously directly invoked paint
<i>1102</i>&nbsp;    // while turning off double buffering at the RepaintManager level, this
<i>1103</i>&nbsp;    // codes simulates that.
<i>1104</i>&nbsp;    void paintForceDoubleBuffered(Graphics g) {
<b class="nc"><i>1105</i>&nbsp;        RepaintManager rm = RepaintManager.currentManager(this);</b>
<b class="nc"><i>1106</i>&nbsp;        Rectangle clip = g.getClipBounds();</b>
<b class="nc"><i>1107</i>&nbsp;        rm.beginPaint();</b>
<b class="nc"><i>1108</i>&nbsp;        setFlag(IS_REPAINTING, true);</b>
<b class="nc"><i>1109</i>&nbsp;        try {</b>
<i>1110</i>&nbsp;            rm.paint(this, this, g, clip.x, clip.y, clip.width, clip.height);
<b class="nc"><i>1111</i>&nbsp;        } finally {</b>
<i>1112</i>&nbsp;            rm.endPaint();
<b class="nc"><i>1113</i>&nbsp;            setFlag(IS_REPAINTING, false);</b>
<i>1114</i>&nbsp;        }
<i>1115</i>&nbsp;    }
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;    /**
<i>1118</i>&nbsp;     * Returns true if this component, or any of its ancestors, are in
<b class="nc"><i>1119</i>&nbsp;     * the processing of painting.</b>
<b class="nc"><i>1120</i>&nbsp;     */</b>
<b class="nc"><i>1121</i>&nbsp;    boolean isPainting() {</b>
<b class="nc"><i>1122</i>&nbsp;        Container component = this;</b>
<b class="nc"><i>1123</i>&nbsp;        while (component != null) {</b>
<b class="nc"><i>1124</i>&nbsp;            if (component instanceof JComponent &amp;&amp;</b>
<b class="nc"><i>1125</i>&nbsp;                   ((JComponent)component).getFlag(ANCESTOR_USING_BUFFER)) {</b>
<b class="nc"><i>1126</i>&nbsp;                return true;</b>
<b class="nc"><i>1127</i>&nbsp;            }</b>
<b class="nc"><i>1128</i>&nbsp;            component = component.getParent();</b>
<b class="nc"><i>1129</i>&nbsp;        }</b>
<b class="nc"><i>1130</i>&nbsp;        return false;</b>
<i>1131</i>&nbsp;    }
<i>1132</i>&nbsp;
<i>1133</i>&nbsp;    private void adjustPaintFlags() {
<i>1134</i>&nbsp;        JComponent jparent;
<i>1135</i>&nbsp;        Container parent;
<i>1136</i>&nbsp;        for(parent = getParent() ; parent != null ; parent =
<i>1137</i>&nbsp;            parent.getParent()) {
<i>1138</i>&nbsp;            if(parent instanceof JComponent) {
<i>1139</i>&nbsp;                jparent = (JComponent) parent;
<i>1140</i>&nbsp;                if(jparent.getFlag(ANCESTOR_USING_BUFFER))
<i>1141</i>&nbsp;                  setFlag(ANCESTOR_USING_BUFFER, true);
<i>1142</i>&nbsp;                if(jparent.getFlag(IS_PAINTING_TILE))
<i>1143</i>&nbsp;                  setFlag(IS_PAINTING_TILE, true);
<i>1144</i>&nbsp;                if(jparent.getFlag(IS_PRINTING))
<i>1145</i>&nbsp;                  setFlag(IS_PRINTING, true);
<i>1146</i>&nbsp;                if(jparent.getFlag(IS_PRINTING_ALL))
<b class="nc"><i>1147</i>&nbsp;                  setFlag(IS_PRINTING_ALL, true);</b>
<i>1148</i>&nbsp;                break;
<b class="nc"><i>1149</i>&nbsp;            }</b>
<i>1150</i>&nbsp;        }
<i>1151</i>&nbsp;    }
<b class="nc"><i>1152</i>&nbsp;</b>
<b class="nc"><i>1153</i>&nbsp;    /**</b>
<i>1154</i>&nbsp;     * Invoke this method to print the component. This method invokes
<i>1155</i>&nbsp;     * &lt;code&gt;print&lt;/code&gt; on the component.
<i>1156</i>&nbsp;     *
<i>1157</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<i>1158</i>&nbsp;     * @see #print
<i>1159</i>&nbsp;     * @see #printComponent
<i>1160</i>&nbsp;     * @see #printBorder
<i>1161</i>&nbsp;     * @see #printChildren
<i>1162</i>&nbsp;     */
<i>1163</i>&nbsp;    public void printAll(Graphics g) {
<i>1164</i>&nbsp;        setFlag(IS_PRINTING_ALL, true);
<i>1165</i>&nbsp;        try {
<i>1166</i>&nbsp;            print(g);
<i>1167</i>&nbsp;        }
<i>1168</i>&nbsp;        finally {
<i>1169</i>&nbsp;            setFlag(IS_PRINTING_ALL, false);
<i>1170</i>&nbsp;        }
<i>1171</i>&nbsp;    }
<i>1172</i>&nbsp;
<i>1173</i>&nbsp;    /**
<i>1174</i>&nbsp;     * Invoke this method to print the component to the specified
<i>1175</i>&nbsp;     * &lt;code&gt;Graphics&lt;/code&gt;. This method will result in invocations
<i>1176</i>&nbsp;     * of &lt;code&gt;printComponent&lt;/code&gt;, &lt;code&gt;printBorder&lt;/code&gt; and
<i>1177</i>&nbsp;     * &lt;code&gt;printChildren&lt;/code&gt;. It is recommended that you override
<i>1178</i>&nbsp;     * one of the previously mentioned methods rather than this one if
<i>1179</i>&nbsp;     * your intention is to customize the way printing looks. However,
<i>1180</i>&nbsp;     * it can be useful to override this method should you want to prepare
<i>1181</i>&nbsp;     * state before invoking the superclass behavior. As an example,
<i>1182</i>&nbsp;     * if you wanted to change the component&#39;s background color before
<i>1183</i>&nbsp;     * printing, you could do the following:
<i>1184</i>&nbsp;     * &lt;pre&gt;
<i>1185</i>&nbsp;     *     public void print(Graphics g) {
<i>1186</i>&nbsp;     *         Color orig = getBackground();
<i>1187</i>&nbsp;     *         setBackground(Color.WHITE);
<i>1188</i>&nbsp;     *
<i>1189</i>&nbsp;     *         // wrap in try/finally so that we always restore the state
<i>1190</i>&nbsp;     *         try {
<i>1191</i>&nbsp;     *             super.print(g);
<i>1192</i>&nbsp;     *         } finally {
<i>1193</i>&nbsp;     *             setBackground(orig);
<i>1194</i>&nbsp;     *         }
<i>1195</i>&nbsp;     *     }
<i>1196</i>&nbsp;     * &lt;/pre&gt;
<i>1197</i>&nbsp;     * &lt;p&gt;
<i>1198</i>&nbsp;     * Alternatively, or for components that delegate painting to other objects,
<i>1199</i>&nbsp;     * you can query during painting whether or not the component is in the
<b class="nc"><i>1200</i>&nbsp;     * midst of a print operation. The &lt;code&gt;isPaintingForPrint&lt;/code&gt; method provides</b>
<b class="nc"><i>1201</i>&nbsp;     * this ability and its return value will be changed by this method: to</b>
<i>1202</i>&nbsp;     * &lt;code&gt;true&lt;/code&gt; immediately before rendering and to &lt;code&gt;false&lt;/code&gt;
<b class="nc"><i>1203</i>&nbsp;     * immediately after. With each change a property change event is fired on</b>
<i>1204</i>&nbsp;     * this component with the name &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
<i>1205</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1206</i>&nbsp;     * This method sets the component&#39;s state such that the double buffer</b>
<b class="nc"><i>1207</i>&nbsp;     * will not be used: painting will be done directly on the passed in</b>
<b class="nc"><i>1208</i>&nbsp;     * &lt;code&gt;Graphics&lt;/code&gt;.</b>
<i>1209</i>&nbsp;     *
<i>1210</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<i>1211</i>&nbsp;     * @see #printComponent
<i>1212</i>&nbsp;     * @see #printBorder
<i>1213</i>&nbsp;     * @see #printChildren
<i>1214</i>&nbsp;     * @see #isPaintingForPrint
<i>1215</i>&nbsp;     */
<i>1216</i>&nbsp;    public void print(Graphics g) {
<i>1217</i>&nbsp;        setFlag(IS_PRINTING, true);
<i>1218</i>&nbsp;        firePropertyChange(&quot;paintingForPrint&quot;, false, true);
<i>1219</i>&nbsp;        try {
<i>1220</i>&nbsp;            paint(g);
<b class="nc"><i>1221</i>&nbsp;        }</b>
<i>1222</i>&nbsp;        finally {
<i>1223</i>&nbsp;            setFlag(IS_PRINTING, false);
<i>1224</i>&nbsp;            firePropertyChange(&quot;paintingForPrint&quot;, true, false);
<i>1225</i>&nbsp;        }
<i>1226</i>&nbsp;    }
<i>1227</i>&nbsp;
<i>1228</i>&nbsp;    /**
<i>1229</i>&nbsp;     * This is invoked during a printing operation. This is implemented to
<i>1230</i>&nbsp;     * invoke &lt;code&gt;paintComponent&lt;/code&gt; on the component. Override this
<i>1231</i>&nbsp;     * if you wish to add special painting behavior when printing.
<i>1232</i>&nbsp;     *
<i>1233</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<b class="nc"><i>1234</i>&nbsp;     * @see #print</b>
<i>1235</i>&nbsp;     * @since 1.3
<i>1236</i>&nbsp;     */
<i>1237</i>&nbsp;    protected void printComponent(Graphics g) {
<i>1238</i>&nbsp;        paintComponent(g);
<i>1239</i>&nbsp;    }
<i>1240</i>&nbsp;
<i>1241</i>&nbsp;    /**
<i>1242</i>&nbsp;     * Prints this component&#39;s children. This is implemented to invoke
<i>1243</i>&nbsp;     * &lt;code&gt;paintChildren&lt;/code&gt; on the component. Override this if you
<i>1244</i>&nbsp;     * wish to print the children differently than painting.
<i>1245</i>&nbsp;     *
<i>1246</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<b class="nc"><i>1247</i>&nbsp;     * @see #print</b>
<i>1248</i>&nbsp;     * @since 1.3
<i>1249</i>&nbsp;     */
<i>1250</i>&nbsp;    protected void printChildren(Graphics g) {
<i>1251</i>&nbsp;        paintChildren(g);
<i>1252</i>&nbsp;    }
<i>1253</i>&nbsp;
<i>1254</i>&nbsp;    /**
<i>1255</i>&nbsp;     * Prints the component&#39;s border. This is implemented to invoke
<i>1256</i>&nbsp;     * &lt;code&gt;paintBorder&lt;/code&gt; on the component. Override this if you
<i>1257</i>&nbsp;     * wish to print the border differently that it is painted.
<i>1258</i>&nbsp;     *
<i>1259</i>&nbsp;     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
<i>1260</i>&nbsp;     * @see #print
<b class="nc"><i>1261</i>&nbsp;     * @since 1.3</b>
<i>1262</i>&nbsp;     */
<i>1263</i>&nbsp;    protected void printBorder(Graphics g) {
<i>1264</i>&nbsp;        paintBorder(g);
<i>1265</i>&nbsp;    }
<i>1266</i>&nbsp;
<i>1267</i>&nbsp;    /**
<i>1268</i>&nbsp;     *  Returns true if the component is currently painting a tile.
<i>1269</i>&nbsp;     *  If this method returns true, paint will be called again for another
<i>1270</i>&nbsp;     *  tile. This method returns false if you are not painting a tile or
<i>1271</i>&nbsp;     *  if the last tile is painted.
<i>1272</i>&nbsp;     *  Use this method to keep some state you might need between tiles.
<i>1273</i>&nbsp;     *
<i>1274</i>&nbsp;     *  @return  true if the component is currently painting a tile,
<i>1275</i>&nbsp;     *          false otherwise
<i>1276</i>&nbsp;     */
<i>1277</i>&nbsp;    @BeanProperty(bound = false)
<i>1278</i>&nbsp;    public boolean isPaintingTile() {
<i>1279</i>&nbsp;        return getFlag(IS_PAINTING_TILE);
<i>1280</i>&nbsp;    }
<i>1281</i>&nbsp;
<i>1282</i>&nbsp;    /**
<i>1283</i>&nbsp;     * Returns &lt;code&gt;true&lt;/code&gt; if the current painting operation on this
<i>1284</i>&nbsp;     * component is part of a &lt;code&gt;print&lt;/code&gt; operation. This method is
<i>1285</i>&nbsp;     * useful when you want to customize what you print versus what you show
<i>1286</i>&nbsp;     * on the screen.
<i>1287</i>&nbsp;     * &lt;p&gt;
<i>1288</i>&nbsp;     * You can detect changes in the value of this property by listening for
<i>1289</i>&nbsp;     * property change events on this component with name
<i>1290</i>&nbsp;     * &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
<b class="nc"><i>1291</i>&nbsp;     * &lt;p&gt;</b>
<i>1292</i>&nbsp;     * Note: This method provides complimentary functionality to that provided
<i>1293</i>&nbsp;     * by other high level Swing printing APIs. However, it deals strictly with
<i>1294</i>&nbsp;     * painting and should not be confused as providing information on higher
<i>1295</i>&nbsp;     * level print processes. For example, a {@link javax.swing.JTable#print()}
<i>1296</i>&nbsp;     * operation doesn&#39;t necessarily result in a continuous rendering of the
<i>1297</i>&nbsp;     * full component, and the return value of this method can change multiple
<i>1298</i>&nbsp;     * times during that operation. It is even possible for the component to be
<i>1299</i>&nbsp;     * painted to the screen while the printing process is ongoing. In such a
<i>1300</i>&nbsp;     * case, the return value of this method is &lt;code&gt;true&lt;/code&gt; when, and only
<i>1301</i>&nbsp;     * when, the table is being painted as part of the printing process.
<i>1302</i>&nbsp;     *
<i>1303</i>&nbsp;     * @return true if the current painting operation on this component
<i>1304</i>&nbsp;     *         is part of a print operation
<i>1305</i>&nbsp;     * @see #print
<i>1306</i>&nbsp;     * @since 1.6
<i>1307</i>&nbsp;     */
<i>1308</i>&nbsp;    @BeanProperty(bound = false)
<i>1309</i>&nbsp;    public final boolean isPaintingForPrint() {
<i>1310</i>&nbsp;        return getFlag(IS_PRINTING);
<i>1311</i>&nbsp;    }
<i>1312</i>&nbsp;
<i>1313</i>&nbsp;    /**
<b class="nc"><i>1314</i>&nbsp;     * In release 1.4, the focus subsystem was rearchitected.</b>
<i>1315</i>&nbsp;     * For more information, see
<i>1316</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1317</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<b class="nc"><i>1318</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</b>
<i>1319</i>&nbsp;     * &lt;p&gt;
<i>1320</i>&nbsp;     * Changes this &lt;code&gt;JComponent&lt;/code&gt;&#39;s focus traversal keys to
<i>1321</i>&nbsp;     * CTRL+TAB and CTRL+SHIFT+TAB. Also prevents
<i>1322</i>&nbsp;     * &lt;code&gt;SortingFocusTraversalPolicy&lt;/code&gt; from considering descendants
<b class="nc"><i>1323</i>&nbsp;     * of this JComponent when computing a focus traversal cycle.</b>
<i>1324</i>&nbsp;     *
<i>1325</i>&nbsp;     * @return false
<i>1326</i>&nbsp;     * @see java.awt.Component#setFocusTraversalKeys
<b class="nc"><i>1327</i>&nbsp;     * @see SortingFocusTraversalPolicy</b>
<b class="nc"><i>1328</i>&nbsp;     * @deprecated As of 1.4, replaced by</b>
<b class="nc"><i>1329</i>&nbsp;     *   &lt;code&gt;Component.setFocusTraversalKeys(int, Set)&lt;/code&gt; and</b>
<b class="nc"><i>1330</i>&nbsp;     *   &lt;code&gt;Container.setFocusCycleRoot(boolean)&lt;/code&gt;.</b>
<b class="nc"><i>1331</i>&nbsp;     */</b>
<b class="nc"><i>1332</i>&nbsp;    @Deprecated</b>
<i>1333</i>&nbsp;    @BeanProperty(bound = false)
<b class="nc"><i>1334</i>&nbsp;    public boolean isManagingFocus() {</b>
<b class="nc"><i>1335</i>&nbsp;        return false;</b>
<i>1336</i>&nbsp;    }
<i>1337</i>&nbsp;
<i>1338</i>&nbsp;    private void registerNextFocusableComponent() {
<b class="nc"><i>1339</i>&nbsp;        registerNextFocusableComponent(getNextFocusableComponent());</b>
<b class="nc"><i>1340</i>&nbsp;    }</b>
<i>1341</i>&nbsp;
<i>1342</i>&nbsp;    private void registerNextFocusableComponent(Component
<i>1343</i>&nbsp;                                                nextFocusableComponent) {
<b class="nc"><i>1344</i>&nbsp;        if (nextFocusableComponent == null) {</b>
<b class="nc"><i>1345</i>&nbsp;            return;</b>
<b class="nc"><i>1346</i>&nbsp;        }</b>
<i>1347</i>&nbsp;
<i>1348</i>&nbsp;        Container nearestRoot =
<b class="nc"><i>1349</i>&nbsp;            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();</b>
<b class="nc"><i>1350</i>&nbsp;        FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();</b>
<b class="nc"><i>1351</i>&nbsp;        if (!(policy instanceof LegacyGlueFocusTraversalPolicy)) {</b>
<b class="nc"><i>1352</i>&nbsp;            policy = new LegacyGlueFocusTraversalPolicy(policy);</b>
<i>1353</i>&nbsp;            nearestRoot.setFocusTraversalPolicy(policy);
<i>1354</i>&nbsp;        }
<i>1355</i>&nbsp;        ((LegacyGlueFocusTraversalPolicy)policy).
<i>1356</i>&nbsp;            setNextFocusableComponent(this, nextFocusableComponent);
<i>1357</i>&nbsp;    }
<i>1358</i>&nbsp;
<i>1359</i>&nbsp;    private void deregisterNextFocusableComponent() {
<i>1360</i>&nbsp;        Component nextFocusableComponent = getNextFocusableComponent();
<i>1361</i>&nbsp;        if (nextFocusableComponent == null) {
<i>1362</i>&nbsp;            return;
<i>1363</i>&nbsp;        }
<i>1364</i>&nbsp;
<i>1365</i>&nbsp;        Container nearestRoot =
<i>1366</i>&nbsp;            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();
<i>1367</i>&nbsp;        if (nearestRoot == null) {
<i>1368</i>&nbsp;            return;
<i>1369</i>&nbsp;        }
<i>1370</i>&nbsp;        FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();
<i>1371</i>&nbsp;        if (policy instanceof LegacyGlueFocusTraversalPolicy) {
<i>1372</i>&nbsp;            ((LegacyGlueFocusTraversalPolicy)policy).
<i>1373</i>&nbsp;                unsetNextFocusableComponent(this, nextFocusableComponent);
<i>1374</i>&nbsp;        }
<i>1375</i>&nbsp;    }
<i>1376</i>&nbsp;
<i>1377</i>&nbsp;    /**
<i>1378</i>&nbsp;     * In release 1.4, the focus subsystem was rearchitected.
<b class="nc"><i>1379</i>&nbsp;     * For more information, see</b>
<b class="nc"><i>1380</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;</b>
<b class="nc"><i>1381</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,</b>
<i>1382</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<b class="nc"><i>1383</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1384</i>&nbsp;     * Overrides the default &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; for this</b>
<b class="nc"><i>1385</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt;&#39;s focus traversal cycle by unconditionally</b>
<i>1386</i>&nbsp;     * setting the specified &lt;code&gt;Component&lt;/code&gt; as the next
<i>1387</i>&nbsp;     * &lt;code&gt;Component&lt;/code&gt; in the cycle, and this &lt;code&gt;JComponent&lt;/code&gt;
<i>1388</i>&nbsp;     * as the specified &lt;code&gt;Component&lt;/code&gt;&#39;s previous
<i>1389</i>&nbsp;     * &lt;code&gt;Component&lt;/code&gt; in the cycle.
<i>1390</i>&nbsp;     *
<i>1391</i>&nbsp;     * @param aComponent the &lt;code&gt;Component&lt;/code&gt; that should follow this
<i>1392</i>&nbsp;     *        &lt;code&gt;JComponent&lt;/code&gt; in the focus traversal cycle
<i>1393</i>&nbsp;     *
<i>1394</i>&nbsp;     * @see #getNextFocusableComponent
<i>1395</i>&nbsp;     * @see java.awt.FocusTraversalPolicy
<i>1396</i>&nbsp;     * @deprecated As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;
<i>1397</i>&nbsp;     */
<i>1398</i>&nbsp;    @Deprecated
<i>1399</i>&nbsp;    public void setNextFocusableComponent(Component aComponent) {
<i>1400</i>&nbsp;        boolean displayable = isDisplayable();
<i>1401</i>&nbsp;        if (displayable) {
<i>1402</i>&nbsp;            deregisterNextFocusableComponent();
<i>1403</i>&nbsp;        }
<i>1404</i>&nbsp;        putClientProperty(NEXT_FOCUS, aComponent);
<i>1405</i>&nbsp;        if (displayable) {
<i>1406</i>&nbsp;            registerNextFocusableComponent(aComponent);
<i>1407</i>&nbsp;        }
<i>1408</i>&nbsp;    }
<b class="nc"><i>1409</i>&nbsp;</b>
<i>1410</i>&nbsp;    /**
<i>1411</i>&nbsp;     * In release 1.4, the focus subsystem was rearchitected.
<i>1412</i>&nbsp;     * For more information, see
<i>1413</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1414</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1415</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>1416</i>&nbsp;     * &lt;p&gt;
<i>1417</i>&nbsp;     * Returns the &lt;code&gt;Component&lt;/code&gt; set by a prior call to
<i>1418</i>&nbsp;     * &lt;code&gt;setNextFocusableComponent(Component)&lt;/code&gt; on this
<i>1419</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt;.
<i>1420</i>&nbsp;     *
<i>1421</i>&nbsp;     * @return the &lt;code&gt;Component&lt;/code&gt; that will follow this
<i>1422</i>&nbsp;     *        &lt;code&gt;JComponent&lt;/code&gt; in the focus traversal cycle, or
<i>1423</i>&nbsp;     *        &lt;code&gt;null&lt;/code&gt; if none has been explicitly specified
<i>1424</i>&nbsp;     *
<i>1425</i>&nbsp;     * @see #setNextFocusableComponent
<i>1426</i>&nbsp;     * @deprecated As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;.
<i>1427</i>&nbsp;     */
<i>1428</i>&nbsp;    @Deprecated
<i>1429</i>&nbsp;    public Component getNextFocusableComponent() {
<i>1430</i>&nbsp;        return (Component)getClientProperty(NEXT_FOCUS);
<i>1431</i>&nbsp;    }
<i>1432</i>&nbsp;
<i>1433</i>&nbsp;    /**
<i>1434</i>&nbsp;     * Provides a hint as to whether or not this &lt;code&gt;JComponent&lt;/code&gt;
<i>1435</i>&nbsp;     * should get focus. This is only a hint, and it is up to consumers that
<b class="nc"><i>1436</i>&nbsp;     * are requesting focus to honor this property. This is typically honored</b>
<i>1437</i>&nbsp;     * for mouse operations, but not keyboard operations. For example, look
<i>1438</i>&nbsp;     * and feels could verify this property is true before requesting focus
<i>1439</i>&nbsp;     * during a mouse operation. This would often times be used if you did
<i>1440</i>&nbsp;     * not want a mouse press on a &lt;code&gt;JComponent&lt;/code&gt; to steal focus,
<i>1441</i>&nbsp;     * but did want the &lt;code&gt;JComponent&lt;/code&gt; to be traversable via the
<i>1442</i>&nbsp;     * keyboard. If you do not want this &lt;code&gt;JComponent&lt;/code&gt; focusable at
<i>1443</i>&nbsp;     * all, use the &lt;code&gt;setFocusable&lt;/code&gt; method instead.
<i>1444</i>&nbsp;     * &lt;p&gt;
<i>1445</i>&nbsp;     * Please see
<i>1446</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1447</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1448</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
<i>1449</i>&nbsp;     * for more information.
<i>1450</i>&nbsp;     *
<i>1451</i>&nbsp;     * @param requestFocusEnabled indicates whether you want this
<i>1452</i>&nbsp;     *        &lt;code&gt;JComponent&lt;/code&gt; to be focusable or not
<i>1453</i>&nbsp;     * @see &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
<i>1454</i>&nbsp;     * @see java.awt.Component#setFocusable
<i>1455</i>&nbsp;     */
<i>1456</i>&nbsp;    public void setRequestFocusEnabled(boolean requestFocusEnabled) {
<b class="nc"><i>1457</i>&nbsp;        setFlag(REQUEST_FOCUS_DISABLED, !requestFocusEnabled);</b>
<i>1458</i>&nbsp;    }
<i>1459</i>&nbsp;
<i>1460</i>&nbsp;    /**
<i>1461</i>&nbsp;     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JComponent&lt;/code&gt; should
<i>1462</i>&nbsp;     * get focus; otherwise returns &lt;code&gt;false&lt;/code&gt;.
<i>1463</i>&nbsp;     * &lt;p&gt;
<i>1464</i>&nbsp;     * Please see
<i>1465</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1466</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1467</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
<i>1468</i>&nbsp;     * for more information.
<i>1469</i>&nbsp;     *
<i>1470</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this component should get focus,
<i>1471</i>&nbsp;     *     otherwise returns &lt;code&gt;false&lt;/code&gt;
<i>1472</i>&nbsp;     * @see #setRequestFocusEnabled
<i>1473</i>&nbsp;     * @see &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus
<i>1474</i>&nbsp;     *      Specification&lt;/a&gt;
<i>1475</i>&nbsp;     * @see java.awt.Component#isFocusable
<i>1476</i>&nbsp;     */
<i>1477</i>&nbsp;    public boolean isRequestFocusEnabled() {
<i>1478</i>&nbsp;        return !getFlag(REQUEST_FOCUS_DISABLED);
<b class="nc"><i>1479</i>&nbsp;    }</b>
<i>1480</i>&nbsp;
<i>1481</i>&nbsp;    /**
<i>1482</i>&nbsp;     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
<i>1483</i>&nbsp;     * Refer to {@link java.awt.Component#requestFocus()
<i>1484</i>&nbsp;     * Component.requestFocus()} for a complete description of
<i>1485</i>&nbsp;     * this method.
<i>1486</i>&nbsp;     * &lt;p&gt;
<i>1487</i>&nbsp;     * Note that the use of this method is discouraged because
<i>1488</i>&nbsp;     * its behavior is platform dependent. Instead we recommend the
<i>1489</i>&nbsp;     * use of {@link #requestFocusInWindow() requestFocusInWindow()}.
<i>1490</i>&nbsp;     * If you would like more information on focus, see
<i>1491</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1492</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1493</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>1494</i>&nbsp;     *
<i>1495</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow()
<i>1496</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow(boolean)
<i>1497</i>&nbsp;     * @since 1.4
<i>1498</i>&nbsp;     */
<i>1499</i>&nbsp;    public void requestFocus() {
<i>1500</i>&nbsp;        super.requestFocus();
<i>1501</i>&nbsp;    }
<i>1502</i>&nbsp;
<i>1503</i>&nbsp;    /**
<i>1504</i>&nbsp;     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
<b class="nc"><i>1505</i>&nbsp;     * Refer to {@link java.awt.Component#requestFocus(boolean)</b>
<i>1506</i>&nbsp;     * Component.requestFocus(boolean)} for a complete description of
<i>1507</i>&nbsp;     * this method.
<i>1508</i>&nbsp;     * &lt;p&gt;
<i>1509</i>&nbsp;     * Note that the use of this method is discouraged because
<i>1510</i>&nbsp;     * its behavior is platform dependent. Instead we recommend the
<i>1511</i>&nbsp;     * use of {@link #requestFocusInWindow(boolean)
<i>1512</i>&nbsp;     * requestFocusInWindow(boolean)}.
<i>1513</i>&nbsp;     * If you would like more information on focus, see
<i>1514</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1515</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1516</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>1517</i>&nbsp;     *
<i>1518</i>&nbsp;     * @param temporary boolean indicating if the focus change is temporary
<i>1519</i>&nbsp;     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
<i>1520</i>&nbsp;     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
<i>1521</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow()
<i>1522</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow(boolean)
<i>1523</i>&nbsp;     * @since 1.4
<i>1524</i>&nbsp;     */
<i>1525</i>&nbsp;    public boolean requestFocus(boolean temporary) {
<b class="nc"><i>1526</i>&nbsp;        return super.requestFocus(temporary);</b>
<i>1527</i>&nbsp;    }
<i>1528</i>&nbsp;
<i>1529</i>&nbsp;    /**
<i>1530</i>&nbsp;     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
<i>1531</i>&nbsp;     * Refer to {@link java.awt.Component#requestFocusInWindow()
<i>1532</i>&nbsp;     * Component.requestFocusInWindow()} for a complete description of
<i>1533</i>&nbsp;     * this method.
<i>1534</i>&nbsp;     * &lt;p&gt;
<i>1535</i>&nbsp;     * If you would like more information on focus, see
<i>1536</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1537</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1538</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>1539</i>&nbsp;     *
<i>1540</i>&nbsp;     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
<i>1541</i>&nbsp;     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
<i>1542</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow()
<i>1543</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow(boolean)
<i>1544</i>&nbsp;     * @since 1.4
<i>1545</i>&nbsp;     */
<i>1546</i>&nbsp;    public boolean requestFocusInWindow() {
<i>1547</i>&nbsp;        return super.requestFocusInWindow();
<b class="nc"><i>1548</i>&nbsp;    }</b>
<i>1549</i>&nbsp;
<i>1550</i>&nbsp;    /**
<i>1551</i>&nbsp;     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
<i>1552</i>&nbsp;     * Refer to {@link java.awt.Component#requestFocusInWindow(boolean)
<i>1553</i>&nbsp;     * Component.requestFocusInWindow(boolean)} for a complete description of
<i>1554</i>&nbsp;     * this method.
<i>1555</i>&nbsp;     * &lt;p&gt;
<i>1556</i>&nbsp;     * If you would like more information on focus, see
<i>1557</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>1558</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>1559</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>1560</i>&nbsp;     *
<i>1561</i>&nbsp;     * @param temporary boolean indicating if the focus change is temporary
<i>1562</i>&nbsp;     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
<i>1563</i>&nbsp;     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
<b class="nc"><i>1564</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow()</b>
<i>1565</i>&nbsp;     * @see java.awt.Component#requestFocusInWindow(boolean)
<i>1566</i>&nbsp;     * @since 1.4
<i>1567</i>&nbsp;     */
<i>1568</i>&nbsp;    protected boolean requestFocusInWindow(boolean temporary) {
<i>1569</i>&nbsp;        return super.requestFocusInWindow(temporary);
<i>1570</i>&nbsp;    }
<i>1571</i>&nbsp;
<i>1572</i>&nbsp;    /**
<i>1573</i>&nbsp;     * Requests that this Component get the input focus, and that this
<i>1574</i>&nbsp;     * Component&#39;s top-level ancestor become the focused Window. This component
<i>1575</i>&nbsp;     * must be displayable, visible, and focusable for the request to be
<i>1576</i>&nbsp;     * granted.
<i>1577</i>&nbsp;     * &lt;p&gt;
<i>1578</i>&nbsp;     * This method is intended for use by focus implementations. Client code
<i>1579</i>&nbsp;     * should not use this method; instead, it should use
<i>1580</i>&nbsp;     * &lt;code&gt;requestFocusInWindow()&lt;/code&gt;.
<i>1581</i>&nbsp;     *
<i>1582</i>&nbsp;     * @see #requestFocusInWindow()
<i>1583</i>&nbsp;     */
<i>1584</i>&nbsp;    public void grabFocus() {
<i>1585</i>&nbsp;        requestFocus();
<i>1586</i>&nbsp;    }
<i>1587</i>&nbsp;
<i>1588</i>&nbsp;    /**
<i>1589</i>&nbsp;     * Sets the value to indicate whether input verifier for the
<b class="nc"><i>1590</i>&nbsp;     * current focus owner will be called before this component requests</b>
<i>1591</i>&nbsp;     * focus. The default is true. Set to false on components such as a
<b class="nc"><i>1592</i>&nbsp;     * Cancel button or a scrollbar, which should activate even if the</b>
<b class="nc"><i>1593</i>&nbsp;     * input in the current focus owner is not &quot;passed&quot; by the input</b>
<i>1594</i>&nbsp;     * verifier for that component.
<i>1595</i>&nbsp;     *
<i>1596</i>&nbsp;     * @param verifyInputWhenFocusTarget value for the
<i>1597</i>&nbsp;     *        &lt;code&gt;verifyInputWhenFocusTarget&lt;/code&gt; property
<i>1598</i>&nbsp;     * @see InputVerifier
<i>1599</i>&nbsp;     * @see #setInputVerifier
<i>1600</i>&nbsp;     * @see #getInputVerifier
<i>1601</i>&nbsp;     * @see #getVerifyInputWhenFocusTarget
<i>1602</i>&nbsp;     *
<i>1603</i>&nbsp;     * @since 1.3
<i>1604</i>&nbsp;     */
<i>1605</i>&nbsp;    @BeanProperty(description
<i>1606</i>&nbsp;            = &quot;Whether the Component verifies input before accepting focus.&quot;)
<i>1607</i>&nbsp;    public void setVerifyInputWhenFocusTarget(boolean
<i>1608</i>&nbsp;                                              verifyInputWhenFocusTarget) {
<i>1609</i>&nbsp;        boolean oldVerifyInputWhenFocusTarget =
<i>1610</i>&nbsp;            this.verifyInputWhenFocusTarget;
<i>1611</i>&nbsp;        this.verifyInputWhenFocusTarget = verifyInputWhenFocusTarget;
<i>1612</i>&nbsp;        firePropertyChange(&quot;verifyInputWhenFocusTarget&quot;,
<b class="nc"><i>1613</i>&nbsp;                           oldVerifyInputWhenFocusTarget,</b>
<i>1614</i>&nbsp;                           verifyInputWhenFocusTarget);
<i>1615</i>&nbsp;    }
<i>1616</i>&nbsp;
<i>1617</i>&nbsp;    /**
<i>1618</i>&nbsp;     * Returns the value that indicates whether the input verifier for the
<i>1619</i>&nbsp;     * current focus owner will be called before this component requests
<i>1620</i>&nbsp;     * focus.
<i>1621</i>&nbsp;     *
<i>1622</i>&nbsp;     * @return value of the &lt;code&gt;verifyInputWhenFocusTarget&lt;/code&gt; property
<i>1623</i>&nbsp;     *
<i>1624</i>&nbsp;     * @see InputVerifier
<i>1625</i>&nbsp;     * @see #setInputVerifier
<i>1626</i>&nbsp;     * @see #getInputVerifier
<b class="nc"><i>1627</i>&nbsp;     * @see #setVerifyInputWhenFocusTarget</b>
<i>1628</i>&nbsp;     *
<i>1629</i>&nbsp;     * @since 1.3
<i>1630</i>&nbsp;     */
<i>1631</i>&nbsp;    public boolean getVerifyInputWhenFocusTarget() {
<i>1632</i>&nbsp;        return verifyInputWhenFocusTarget;
<i>1633</i>&nbsp;    }
<i>1634</i>&nbsp;
<i>1635</i>&nbsp;
<i>1636</i>&nbsp;    /**
<i>1637</i>&nbsp;     * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; for the specified &lt;code&gt;Font&lt;/code&gt;.
<i>1638</i>&nbsp;     *
<i>1639</i>&nbsp;     * @param font the font for which font metrics is to be
<i>1640</i>&nbsp;     *          obtained
<b class="nc"><i>1641</i>&nbsp;     * @return the font metrics for &lt;code&gt;font&lt;/code&gt;</b>
<i>1642</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;font&lt;/code&gt; is null
<i>1643</i>&nbsp;     * @since 1.5
<i>1644</i>&nbsp;     */
<i>1645</i>&nbsp;    public FontMetrics getFontMetrics(Font font) {
<i>1646</i>&nbsp;        return SwingUtilities2.getFontMetrics(this, font);
<i>1647</i>&nbsp;    }
<i>1648</i>&nbsp;
<i>1649</i>&nbsp;
<i>1650</i>&nbsp;    /**
<i>1651</i>&nbsp;     * Sets the preferred size of this component.
<i>1652</i>&nbsp;     * If &lt;code&gt;preferredSize&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the UI will
<i>1653</i>&nbsp;     * be asked for the preferred size.
<i>1654</i>&nbsp;     */
<i>1655</i>&nbsp;    @BeanProperty(preferred = true, description
<i>1656</i>&nbsp;            = &quot;The preferred size of the component.&quot;)
<i>1657</i>&nbsp;    public void setPreferredSize(Dimension preferredSize) {
<b class="nc"><i>1658</i>&nbsp;        super.setPreferredSize(preferredSize);</b>
<b class="nc"><i>1659</i>&nbsp;    }</b>
<i>1660</i>&nbsp;
<b class="nc"><i>1661</i>&nbsp;</b>
<b class="nc"><i>1662</i>&nbsp;    /**</b>
<b class="nc"><i>1663</i>&nbsp;     * If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a</b>
<i>1664</i>&nbsp;     * non-&lt;code&gt;null&lt;/code&gt; value just returns it.
<b class="nc"><i>1665</i>&nbsp;     * If the UI delegate&#39;s &lt;code&gt;getPreferredSize&lt;/code&gt;</b>
<i>1666</i>&nbsp;     * method returns a non &lt;code&gt;null&lt;/code&gt; value then return that;
<i>1667</i>&nbsp;     * otherwise defer to the component&#39;s layout manager.
<i>1668</i>&nbsp;     *
<i>1669</i>&nbsp;     * @return the value of the &lt;code&gt;preferredSize&lt;/code&gt; property
<i>1670</i>&nbsp;     * @see #setPreferredSize
<i>1671</i>&nbsp;     * @see ComponentUI
<i>1672</i>&nbsp;     */
<i>1673</i>&nbsp;    @Transient
<i>1674</i>&nbsp;    public Dimension getPreferredSize() {
<i>1675</i>&nbsp;        if (isPreferredSizeSet()) {
<i>1676</i>&nbsp;            return super.getPreferredSize();
<i>1677</i>&nbsp;        }
<i>1678</i>&nbsp;        Dimension size = null;
<i>1679</i>&nbsp;        if (ui != null) {
<i>1680</i>&nbsp;            size = ui.getPreferredSize(this);
<i>1681</i>&nbsp;        }
<i>1682</i>&nbsp;        return (size != null) ? size : super.getPreferredSize();
<i>1683</i>&nbsp;    }
<b class="nc"><i>1684</i>&nbsp;</b>
<i>1685</i>&nbsp;
<i>1686</i>&nbsp;    /**
<i>1687</i>&nbsp;     * Sets the maximum size of this component to a constant
<i>1688</i>&nbsp;     * value.  Subsequent calls to &lt;code&gt;getMaximumSize&lt;/code&gt; will always
<i>1689</i>&nbsp;     * return this value; the component&#39;s UI will not be asked
<i>1690</i>&nbsp;     * to compute it.  Setting the maximum size to &lt;code&gt;null&lt;/code&gt;
<i>1691</i>&nbsp;     * restores the default behavior.
<i>1692</i>&nbsp;     *
<i>1693</i>&nbsp;     * @param maximumSize a &lt;code&gt;Dimension&lt;/code&gt; containing the
<i>1694</i>&nbsp;     *          desired maximum allowable size
<i>1695</i>&nbsp;     * @see #getMaximumSize
<i>1696</i>&nbsp;     */
<i>1697</i>&nbsp;    @BeanProperty(description
<i>1698</i>&nbsp;            = &quot;The maximum size of the component.&quot;)
<i>1699</i>&nbsp;    public void setMaximumSize(Dimension maximumSize) {
<b class="nc"><i>1700</i>&nbsp;        super.setMaximumSize(maximumSize);</b>
<b class="nc"><i>1701</i>&nbsp;    }</b>
<i>1702</i>&nbsp;
<b class="nc"><i>1703</i>&nbsp;</b>
<b class="nc"><i>1704</i>&nbsp;    /**</b>
<b class="nc"><i>1705</i>&nbsp;     * If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value</b>
<i>1706</i>&nbsp;     * just returns it.  If the UI delegate&#39;s &lt;code&gt;getMaximumSize&lt;/code&gt;
<b class="nc"><i>1707</i>&nbsp;     * method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that;</b>
<i>1708</i>&nbsp;     * otherwise defer to the component&#39;s layout manager.
<i>1709</i>&nbsp;     *
<i>1710</i>&nbsp;     * @return the value of the &lt;code&gt;maximumSize&lt;/code&gt; property
<i>1711</i>&nbsp;     * @see #setMaximumSize
<i>1712</i>&nbsp;     * @see ComponentUI
<i>1713</i>&nbsp;     */
<i>1714</i>&nbsp;    @Transient
<i>1715</i>&nbsp;    public Dimension getMaximumSize() {
<i>1716</i>&nbsp;        if (isMaximumSizeSet()) {
<i>1717</i>&nbsp;            return super.getMaximumSize();
<i>1718</i>&nbsp;        }
<i>1719</i>&nbsp;        Dimension size = null;
<i>1720</i>&nbsp;        if (ui != null) {
<i>1721</i>&nbsp;            size = ui.getMaximumSize(this);
<i>1722</i>&nbsp;        }
<i>1723</i>&nbsp;        return (size != null) ? size : super.getMaximumSize();
<i>1724</i>&nbsp;    }
<b class="nc"><i>1725</i>&nbsp;</b>
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;    /**
<i>1728</i>&nbsp;     * Sets the minimum size of this component to a constant
<i>1729</i>&nbsp;     * value.  Subsequent calls to &lt;code&gt;getMinimumSize&lt;/code&gt; will always
<i>1730</i>&nbsp;     * return this value; the component&#39;s UI will not be asked
<i>1731</i>&nbsp;     * to compute it.  Setting the minimum size to &lt;code&gt;null&lt;/code&gt;
<i>1732</i>&nbsp;     * restores the default behavior.
<i>1733</i>&nbsp;     *
<i>1734</i>&nbsp;     * @param minimumSize the new minimum size of this component
<i>1735</i>&nbsp;     * @see #getMinimumSize
<i>1736</i>&nbsp;     */
<i>1737</i>&nbsp;    @BeanProperty(description
<i>1738</i>&nbsp;            = &quot;The minimum size of the component.&quot;)
<i>1739</i>&nbsp;    public void setMinimumSize(Dimension minimumSize) {
<b class="nc"><i>1740</i>&nbsp;        super.setMinimumSize(minimumSize);</b>
<b class="nc"><i>1741</i>&nbsp;    }</b>
<i>1742</i>&nbsp;
<b class="nc"><i>1743</i>&nbsp;    /**</b>
<b class="nc"><i>1744</i>&nbsp;     * If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value</b>
<b class="nc"><i>1745</i>&nbsp;     * just returns it.  If the UI delegate&#39;s &lt;code&gt;getMinimumSize&lt;/code&gt;</b>
<i>1746</i>&nbsp;     * method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise
<b class="nc"><i>1747</i>&nbsp;     * defer to the component&#39;s layout manager.</b>
<i>1748</i>&nbsp;     *
<i>1749</i>&nbsp;     * @return the value of the &lt;code&gt;minimumSize&lt;/code&gt; property
<i>1750</i>&nbsp;     * @see #setMinimumSize
<i>1751</i>&nbsp;     * @see ComponentUI
<i>1752</i>&nbsp;     */
<i>1753</i>&nbsp;    @Transient
<i>1754</i>&nbsp;    public Dimension getMinimumSize() {
<i>1755</i>&nbsp;        if (isMinimumSizeSet()) {
<i>1756</i>&nbsp;            return super.getMinimumSize();
<i>1757</i>&nbsp;        }
<i>1758</i>&nbsp;        Dimension size = null;
<b class="nc"><i>1759</i>&nbsp;        if (ui != null) {</b>
<i>1760</i>&nbsp;            size = ui.getMinimumSize(this);
<i>1761</i>&nbsp;        }
<i>1762</i>&nbsp;        return (size != null) ? size : super.getMinimumSize();
<i>1763</i>&nbsp;    }
<i>1764</i>&nbsp;
<i>1765</i>&nbsp;    /**
<i>1766</i>&nbsp;     * Gives the UI delegate an opportunity to define the precise
<i>1767</i>&nbsp;     * shape of this component for the sake of mouse processing.
<i>1768</i>&nbsp;     *
<i>1769</i>&nbsp;     * @return true if this component logically contains x,y
<i>1770</i>&nbsp;     * @see java.awt.Component#contains(int, int)
<i>1771</i>&nbsp;     * @see ComponentUI
<i>1772</i>&nbsp;     */
<i>1773</i>&nbsp;    public boolean contains(int x, int y) {
<i>1774</i>&nbsp;        return (ui != null) ? ui.contains(this, x, y) : super.contains(x, y);
<i>1775</i>&nbsp;    }
<i>1776</i>&nbsp;
<i>1777</i>&nbsp;    /**
<i>1778</i>&nbsp;     * Sets the border of this component.  The &lt;code&gt;Border&lt;/code&gt; object is
<i>1779</i>&nbsp;     * responsible for defining the insets for the component
<i>1780</i>&nbsp;     * (overriding any insets set directly on the component) and
<i>1781</i>&nbsp;     * for optionally rendering any border decorations within the
<i>1782</i>&nbsp;     * bounds of those insets.  Borders should be used (rather
<i>1783</i>&nbsp;     * than insets) for creating both decorative and non-decorative
<i>1784</i>&nbsp;     * (such as margins and padding) regions for a swing component.
<i>1785</i>&nbsp;     * Compound borders can be used to nest multiple borders within a
<i>1786</i>&nbsp;     * single component.
<i>1787</i>&nbsp;     * &lt;p&gt;
<i>1788</i>&nbsp;     * Although technically you can set the border on any object
<i>1789</i>&nbsp;     * that inherits from &lt;code&gt;JComponent&lt;/code&gt;, the look and
<i>1790</i>&nbsp;     * feel implementation of many standard Swing components
<i>1791</i>&nbsp;     * doesn&#39;t work well with user-set borders.  In general,
<i>1792</i>&nbsp;     * when you want to set a border on a standard Swing
<i>1793</i>&nbsp;     * component other than &lt;code&gt;JPanel&lt;/code&gt; or &lt;code&gt;JLabel&lt;/code&gt;,
<b class="nc"><i>1794</i>&nbsp;     * we recommend that you put the component in a &lt;code&gt;JPanel&lt;/code&gt;</b>
<i>1795</i>&nbsp;     * and set the border on the &lt;code&gt;JPanel&lt;/code&gt;.
<b class="nc"><i>1796</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1797</i>&nbsp;     * This is a bound property.</b>
<b class="nc"><i>1798</i>&nbsp;     *</b>
<b class="nc"><i>1799</i>&nbsp;     * @param border the border to be rendered for this component</b>
<b class="nc"><i>1800</i>&nbsp;     * @see Border</b>
<b class="nc"><i>1801</i>&nbsp;     * @see CompoundBorder</b>
<i>1802</i>&nbsp;     */
<b class="nc"><i>1803</i>&nbsp;    @BeanProperty(preferred = true, visualUpdate = true, description</b>
<i>1804</i>&nbsp;            = &quot;The component&#39;s border.&quot;)
<i>1805</i>&nbsp;    public void setBorder(Border border) {
<i>1806</i>&nbsp;        Border         oldBorder = this.border;
<i>1807</i>&nbsp;
<i>1808</i>&nbsp;        this.border = border;
<i>1809</i>&nbsp;        firePropertyChange(&quot;border&quot;, oldBorder, border);
<i>1810</i>&nbsp;        if (border != oldBorder) {
<i>1811</i>&nbsp;            if (border == null || oldBorder == null ||
<i>1812</i>&nbsp;                !(border.getBorderInsets(this).equals(oldBorder.getBorderInsets(this)))) {
<i>1813</i>&nbsp;                revalidate();
<i>1814</i>&nbsp;            }
<b class="nc"><i>1815</i>&nbsp;            repaint();</b>
<i>1816</i>&nbsp;        }
<i>1817</i>&nbsp;    }
<i>1818</i>&nbsp;
<i>1819</i>&nbsp;    /**
<i>1820</i>&nbsp;     * Returns the border of this component or &lt;code&gt;null&lt;/code&gt; if no
<i>1821</i>&nbsp;     * border is currently set.
<i>1822</i>&nbsp;     *
<i>1823</i>&nbsp;     * @return the border object for this component
<i>1824</i>&nbsp;     * @see #setBorder
<i>1825</i>&nbsp;     */
<b class="nc"><i>1826</i>&nbsp;    public Border getBorder() {</b>
<b class="nc"><i>1827</i>&nbsp;        return border;</b>
<i>1828</i>&nbsp;    }
<b class="nc"><i>1829</i>&nbsp;</b>
<i>1830</i>&nbsp;    /**
<i>1831</i>&nbsp;     * If a border has been set on this component, returns the
<i>1832</i>&nbsp;     * border&#39;s insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.
<i>1833</i>&nbsp;     *
<i>1834</i>&nbsp;     * @return the value of the insets property
<i>1835</i>&nbsp;     * @see #setBorder
<i>1836</i>&nbsp;     */
<i>1837</i>&nbsp;    @BeanProperty(expert = true)
<i>1838</i>&nbsp;    public Insets getInsets() {
<i>1839</i>&nbsp;        if (border != null) {
<i>1840</i>&nbsp;            return border.getBorderInsets(this);
<i>1841</i>&nbsp;        }
<i>1842</i>&nbsp;        return super.getInsets();
<i>1843</i>&nbsp;    }
<i>1844</i>&nbsp;
<i>1845</i>&nbsp;    /**
<i>1846</i>&nbsp;     * Returns an &lt;code&gt;Insets&lt;/code&gt; object containing this component&#39;s inset
<b class="nc"><i>1847</i>&nbsp;     * values.  The passed-in &lt;code&gt;Insets&lt;/code&gt; object will be reused</b>
<b class="nc"><i>1848</i>&nbsp;     * if possible.</b>
<i>1849</i>&nbsp;     * Calling methods cannot assume that the same object will be returned,
<b class="nc"><i>1850</i>&nbsp;     * however.  All existing values within this object are overwritten.</b>
<b class="nc"><i>1851</i>&nbsp;     * If &lt;code&gt;insets&lt;/code&gt; is null, this will allocate a new one.</b>
<b class="nc"><i>1852</i>&nbsp;     *</b>
<i>1853</i>&nbsp;     * @param insets the &lt;code&gt;Insets&lt;/code&gt; object, which can be reused
<i>1854</i>&nbsp;     * @return the &lt;code&gt;Insets&lt;/code&gt; object
<i>1855</i>&nbsp;     * @see #getInsets
<b class="nc"><i>1856</i>&nbsp;     */</b>
<i>1857</i>&nbsp;    public Insets getInsets(Insets insets) {
<i>1858</i>&nbsp;        if (insets == null) {
<i>1859</i>&nbsp;            insets = new Insets(0, 0, 0, 0);
<i>1860</i>&nbsp;        }
<b class="nc"><i>1861</i>&nbsp;        if (border != null) {</b>
<b class="nc"><i>1862</i>&nbsp;            if (border instanceof AbstractBorder) {</b>
<i>1863</i>&nbsp;                return ((AbstractBorder)border).getBorderInsets(this, insets);
<i>1864</i>&nbsp;            } else {
<i>1865</i>&nbsp;                // Can&#39;t reuse border insets because the Border interface
<i>1866</i>&nbsp;                // can&#39;t be enhanced.
<i>1867</i>&nbsp;                return border.getBorderInsets(this);
<i>1868</i>&nbsp;            }
<i>1869</i>&nbsp;        } else {
<i>1870</i>&nbsp;            // super.getInsets() always returns an Insets object with
<i>1871</i>&nbsp;            // all of its value zeroed.  No need for a new object here.
<i>1872</i>&nbsp;            insets.left = insets.top = insets.right = insets.bottom = 0;
<i>1873</i>&nbsp;            return insets;
<i>1874</i>&nbsp;        }
<b class="nc"><i>1875</i>&nbsp;    }</b>
<b class="nc"><i>1876</i>&nbsp;</b>
<i>1877</i>&nbsp;    /**
<b class="nc"><i>1878</i>&nbsp;     * Overrides &lt;code&gt;Container.getAlignmentY&lt;/code&gt; to return</b>
<i>1879</i>&nbsp;     * the vertical alignment.
<i>1880</i>&nbsp;     *
<i>1881</i>&nbsp;     * @return the value of the &lt;code&gt;alignmentY&lt;/code&gt; property
<i>1882</i>&nbsp;     * @see #setAlignmentY
<i>1883</i>&nbsp;     * @see java.awt.Component#getAlignmentY
<i>1884</i>&nbsp;     */
<i>1885</i>&nbsp;    public float getAlignmentY() {
<i>1886</i>&nbsp;        if (isAlignmentYSet) {
<i>1887</i>&nbsp;            return alignmentY;
<i>1888</i>&nbsp;        }
<i>1889</i>&nbsp;        return super.getAlignmentY();
<b class="nc"><i>1890</i>&nbsp;    }</b>
<b class="nc"><i>1891</i>&nbsp;</b>
<i>1892</i>&nbsp;    /**
<i>1893</i>&nbsp;     * Sets the vertical alignment.
<i>1894</i>&nbsp;     *
<i>1895</i>&nbsp;     * @param alignmentY  the new vertical alignment
<i>1896</i>&nbsp;     * @see #getAlignmentY
<i>1897</i>&nbsp;     */
<i>1898</i>&nbsp;    @BeanProperty(description
<i>1899</i>&nbsp;            = &quot;The preferred vertical alignment of the component.&quot;)
<i>1900</i>&nbsp;    public void setAlignmentY(float alignmentY) {
<i>1901</i>&nbsp;        this.alignmentY = validateAlignment(alignmentY);
<i>1902</i>&nbsp;        isAlignmentYSet = true;
<i>1903</i>&nbsp;    }
<b class="nc"><i>1904</i>&nbsp;</b>
<b class="nc"><i>1905</i>&nbsp;</b>
<i>1906</i>&nbsp;    /**
<b class="nc"><i>1907</i>&nbsp;     * Overrides &lt;code&gt;Container.getAlignmentX&lt;/code&gt; to return</b>
<i>1908</i>&nbsp;     * the horizontal alignment.
<i>1909</i>&nbsp;     *
<i>1910</i>&nbsp;     * @return the value of the &lt;code&gt;alignmentX&lt;/code&gt; property
<i>1911</i>&nbsp;     * @see #setAlignmentX
<i>1912</i>&nbsp;     * @see java.awt.Component#getAlignmentX
<i>1913</i>&nbsp;     */
<i>1914</i>&nbsp;    public float getAlignmentX() {
<i>1915</i>&nbsp;        if (isAlignmentXSet) {
<i>1916</i>&nbsp;            return alignmentX;
<i>1917</i>&nbsp;        }
<i>1918</i>&nbsp;        return super.getAlignmentX();
<b class="nc"><i>1919</i>&nbsp;    }</b>
<b class="nc"><i>1920</i>&nbsp;</b>
<i>1921</i>&nbsp;    /**
<i>1922</i>&nbsp;     * Sets the horizontal alignment.
<i>1923</i>&nbsp;     *
<i>1924</i>&nbsp;     * @param alignmentX  the new horizontal alignment
<i>1925</i>&nbsp;     * @see #getAlignmentX
<i>1926</i>&nbsp;     */
<i>1927</i>&nbsp;    @BeanProperty(description
<i>1928</i>&nbsp;            = &quot;The preferred horizontal alignment of the component.&quot;)
<i>1929</i>&nbsp;    public void setAlignmentX(float alignmentX) {
<i>1930</i>&nbsp;        this.alignmentX = validateAlignment(alignmentX);
<i>1931</i>&nbsp;        isAlignmentXSet = true;
<i>1932</i>&nbsp;    }
<i>1933</i>&nbsp;
<b class="nc"><i>1934</i>&nbsp;    private float validateAlignment(float alignment) {</b>
<i>1935</i>&nbsp;        return alignment &gt; 1.0f ? 1.0f : alignment &lt; 0.0f ? 0.0f : alignment;
<b class="nc"><i>1936</i>&nbsp;    }</b>
<b class="nc"><i>1937</i>&nbsp;</b>
<i>1938</i>&nbsp;    /**
<i>1939</i>&nbsp;     * Sets the input verifier for this component.
<i>1940</i>&nbsp;     *
<i>1941</i>&nbsp;     * @param inputVerifier the new input verifier
<i>1942</i>&nbsp;     * @since 1.3
<i>1943</i>&nbsp;     * @see InputVerifier
<i>1944</i>&nbsp;     */
<i>1945</i>&nbsp;    @BeanProperty(description
<i>1946</i>&nbsp;            = &quot;The component&#39;s input verifier.&quot;)
<i>1947</i>&nbsp;    public void setInputVerifier(InputVerifier inputVerifier) {
<b class="nc"><i>1948</i>&nbsp;        InputVerifier oldInputVerifier = (InputVerifier)getClientProperty(</b>
<i>1949</i>&nbsp;                                         JComponent_INPUT_VERIFIER);
<i>1950</i>&nbsp;        putClientProperty(JComponent_INPUT_VERIFIER, inputVerifier);
<i>1951</i>&nbsp;        firePropertyChange(&quot;inputVerifier&quot;, oldInputVerifier, inputVerifier);
<i>1952</i>&nbsp;    }
<i>1953</i>&nbsp;
<i>1954</i>&nbsp;    /**
<i>1955</i>&nbsp;     * Returns the input verifier for this component.
<i>1956</i>&nbsp;     *
<i>1957</i>&nbsp;     * @return the &lt;code&gt;inputVerifier&lt;/code&gt; property
<b class="nc"><i>1958</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>1959</i>&nbsp;     * @see InputVerifier</b>
<i>1960</i>&nbsp;     */
<b class="nc"><i>1961</i>&nbsp;    public InputVerifier getInputVerifier() {</b>
<i>1962</i>&nbsp;        return (InputVerifier)getClientProperty(JComponent_INPUT_VERIFIER);
<b class="nc"><i>1963</i>&nbsp;    }</b>
<i>1964</i>&nbsp;
<i>1965</i>&nbsp;    /**
<i>1966</i>&nbsp;     * Returns this component&#39;s graphics context, which lets you draw
<i>1967</i>&nbsp;     * on a component. Use this method to get a &lt;code&gt;Graphics&lt;/code&gt; object and
<i>1968</i>&nbsp;     * then invoke operations on that object to draw on the component.
<i>1969</i>&nbsp;     * @return this components graphics context
<i>1970</i>&nbsp;     */
<i>1971</i>&nbsp;    @BeanProperty(bound = false)
<i>1972</i>&nbsp;    public Graphics getGraphics() {
<i>1973</i>&nbsp;        if (DEBUG_GRAPHICS_LOADED &amp;&amp; shouldDebugGraphics() != 0) {
<i>1974</i>&nbsp;            DebugGraphics graphics = new DebugGraphics(super.getGraphics(),
<i>1975</i>&nbsp;                                                       this);
<i>1976</i>&nbsp;            return graphics;
<i>1977</i>&nbsp;        }
<i>1978</i>&nbsp;        return super.getGraphics();
<i>1979</i>&nbsp;    }
<i>1980</i>&nbsp;
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;    /** Enables or disables diagnostic information about every graphics
<i>1983</i>&nbsp;      * operation performed within the component or one of its children.
<i>1984</i>&nbsp;      *
<i>1985</i>&nbsp;      * @param debugOptions  determines how the component should display
<i>1986</i>&nbsp;      *         the information;  one of the following options:
<i>1987</i>&nbsp;      * &lt;ul&gt;
<i>1988</i>&nbsp;      * &lt;li&gt;DebugGraphics.LOG_OPTION - causes a text message to be printed.
<i>1989</i>&nbsp;      * &lt;li&gt;DebugGraphics.FLASH_OPTION - causes the drawing to flash several
<i>1990</i>&nbsp;      * times.
<i>1991</i>&nbsp;      * &lt;li&gt;DebugGraphics.BUFFERED_OPTION - creates an
<i>1992</i>&nbsp;      *         &lt;code&gt;ExternalWindow&lt;/code&gt; that displays the operations
<b class="nc"><i>1993</i>&nbsp;      *         performed on the View&#39;s offscreen buffer.</b>
<i>1994</i>&nbsp;      * &lt;li&gt;DebugGraphics.NONE_OPTION disables debugging.
<i>1995</i>&nbsp;      * &lt;li&gt;A value of 0 causes no changes to the debugging options.
<i>1996</i>&nbsp;      * &lt;/ul&gt;
<i>1997</i>&nbsp;      * &lt;code&gt;debugOptions&lt;/code&gt; is bitwise OR&#39;d into the current value
<i>1998</i>&nbsp;      */
<i>1999</i>&nbsp;    @BeanProperty(bound = false, preferred = true, enumerationValues = {
<i>2000</i>&nbsp;            &quot;DebugGraphics.NONE_OPTION&quot;,
<i>2001</i>&nbsp;            &quot;DebugGraphics.LOG_OPTION&quot;,
<i>2002</i>&nbsp;            &quot;DebugGraphics.FLASH_OPTION&quot;,
<i>2003</i>&nbsp;            &quot;DebugGraphics.BUFFERED_OPTION&quot;}, description
<i>2004</i>&nbsp;            = &quot;Diagnostic options for graphics operations.&quot;)
<i>2005</i>&nbsp;    public void setDebugGraphicsOptions(int debugOptions) {
<i>2006</i>&nbsp;        DebugGraphics.setDebugOptions(this, debugOptions);
<i>2007</i>&nbsp;    }
<i>2008</i>&nbsp;
<i>2009</i>&nbsp;    /** Returns the state of graphics debugging.
<i>2010</i>&nbsp;      *
<i>2011</i>&nbsp;      * @return a bitwise OR&#39;d flag of zero or more of the following options:
<b class="nc"><i>2012</i>&nbsp;      * &lt;ul&gt;</b>
<i>2013</i>&nbsp;      * &lt;li&gt;DebugGraphics.LOG_OPTION - causes a text message to be printed.
<i>2014</i>&nbsp;      * &lt;li&gt;DebugGraphics.FLASH_OPTION - causes the drawing to flash several
<i>2015</i>&nbsp;      * times.
<i>2016</i>&nbsp;      * &lt;li&gt;DebugGraphics.BUFFERED_OPTION - creates an
<i>2017</i>&nbsp;      *         &lt;code&gt;ExternalWindow&lt;/code&gt; that displays the operations
<i>2018</i>&nbsp;      *         performed on the View&#39;s offscreen buffer.
<i>2019</i>&nbsp;      * &lt;li&gt;DebugGraphics.NONE_OPTION disables debugging.
<i>2020</i>&nbsp;      * &lt;li&gt;A value of 0 causes no changes to the debugging options.
<b class="nc"><i>2021</i>&nbsp;      * &lt;/ul&gt;</b>
<i>2022</i>&nbsp;      * @see #setDebugGraphicsOptions
<i>2023</i>&nbsp;      */
<i>2024</i>&nbsp;    public int getDebugGraphicsOptions() {
<i>2025</i>&nbsp;        return DebugGraphics.getDebugOptions(this);
<i>2026</i>&nbsp;    }
<i>2027</i>&nbsp;
<i>2028</i>&nbsp;
<i>2029</i>&nbsp;    /**
<i>2030</i>&nbsp;     * Returns true if debug information is enabled for this
<i>2031</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; or one of its parents.
<i>2032</i>&nbsp;     */
<i>2033</i>&nbsp;    int shouldDebugGraphics() {
<i>2034</i>&nbsp;        return DebugGraphics.shouldComponentDebug(this);
<i>2035</i>&nbsp;    }
<i>2036</i>&nbsp;
<i>2037</i>&nbsp;    /**
<i>2038</i>&nbsp;     * This method is now obsolete, please use a combination of
<i>2039</i>&nbsp;     * &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
<i>2040</i>&nbsp;     * similar behavior. For example, to bind the &lt;code&gt;KeyStroke&lt;/code&gt;
<i>2041</i>&nbsp;     * &lt;code&gt;aKeyStroke&lt;/code&gt; to the &lt;code&gt;Action&lt;/code&gt; &lt;code&gt;anAction&lt;/code&gt;
<i>2042</i>&nbsp;     * now use:
<i>2043</i>&nbsp;     * &lt;pre&gt;
<i>2044</i>&nbsp;     *   component.getInputMap().put(aKeyStroke, aCommand);
<i>2045</i>&nbsp;     *   component.getActionMap().put(aCommmand, anAction);
<i>2046</i>&nbsp;     * &lt;/pre&gt;
<i>2047</i>&nbsp;     * The above assumes you want the binding to be applicable for
<i>2048</i>&nbsp;     * &lt;code&gt;WHEN_FOCUSED&lt;/code&gt;. To register bindings for other focus
<i>2049</i>&nbsp;     * states use the &lt;code&gt;getInputMap&lt;/code&gt; method that takes an integer.
<i>2050</i>&nbsp;     * &lt;p&gt;
<i>2051</i>&nbsp;     * Register a new keyboard action.
<i>2052</i>&nbsp;     * &lt;code&gt;anAction&lt;/code&gt; will be invoked if a key event matching
<i>2053</i>&nbsp;     * &lt;code&gt;aKeyStroke&lt;/code&gt; occurs and &lt;code&gt;aCondition&lt;/code&gt; is verified.
<i>2054</i>&nbsp;     * The &lt;code&gt;KeyStroke&lt;/code&gt; object defines a
<i>2055</i>&nbsp;     * particular combination of a keyboard key and one or more modifiers
<i>2056</i>&nbsp;     * (alt, shift, ctrl, meta).
<i>2057</i>&nbsp;     * &lt;p&gt;
<i>2058</i>&nbsp;     * The &lt;code&gt;aCommand&lt;/code&gt; will be set in the delivered event if
<i>2059</i>&nbsp;     * specified.
<i>2060</i>&nbsp;     * &lt;p&gt;
<i>2061</i>&nbsp;     * The &lt;code&gt;aCondition&lt;/code&gt; can be one of:
<i>2062</i>&nbsp;     * &lt;blockquote&gt;
<i>2063</i>&nbsp;     * &lt;DL&gt;
<i>2064</i>&nbsp;     * &lt;DT&gt;WHEN_FOCUSED
<i>2065</i>&nbsp;     * &lt;DD&gt;The action will be invoked only when the keystroke occurs
<i>2066</i>&nbsp;     *     while the component has the focus.
<i>2067</i>&nbsp;     * &lt;DT&gt;WHEN_IN_FOCUSED_WINDOW
<i>2068</i>&nbsp;     * &lt;DD&gt;The action will be invoked when the keystroke occurs while
<i>2069</i>&nbsp;     *     the component has the focus or if the component is in the
<i>2070</i>&nbsp;     *     window that has the focus. Note that the component need not
<i>2071</i>&nbsp;     *     be an immediate descendent of the window -- it can be
<i>2072</i>&nbsp;     *     anywhere in the window&#39;s containment hierarchy. In other
<i>2073</i>&nbsp;     *     words, whenever &lt;em&gt;any&lt;/em&gt; component in the window has the focus,
<i>2074</i>&nbsp;     *     the action registered with this component is invoked.
<i>2075</i>&nbsp;     * &lt;DT&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
<i>2076</i>&nbsp;     * &lt;DD&gt;The action will be invoked when the keystroke occurs while the
<i>2077</i>&nbsp;     *     component has the focus or if the component is an ancestor of
<i>2078</i>&nbsp;     *     the component that has the focus.
<i>2079</i>&nbsp;     * &lt;/DL&gt;
<i>2080</i>&nbsp;     * &lt;/blockquote&gt;
<i>2081</i>&nbsp;     * &lt;p&gt;
<i>2082</i>&nbsp;     * The combination of keystrokes and conditions lets you define high
<i>2083</i>&nbsp;     * level (semantic) action events for a specified keystroke+modifier
<i>2084</i>&nbsp;     * combination (using the KeyStroke class) and direct to a parent or
<i>2085</i>&nbsp;     * child of a component that has the focus, or to the component itself.
<i>2086</i>&nbsp;     * In other words, in any hierarchical structure of components, an
<i>2087</i>&nbsp;     * arbitrary key-combination can be immediately directed to the
<i>2088</i>&nbsp;     * appropriate component in the hierarchy, and cause a specific method
<i>2089</i>&nbsp;     * to be invoked (usually by way of adapter objects).
<b class="nc"><i>2090</i>&nbsp;     * &lt;p&gt;</b>
<i>2091</i>&nbsp;     * If an action has already been registered for the receiving
<b class="nc"><i>2092</i>&nbsp;     * container, with the same charCode and the same modifiers,</b>
<b class="nc"><i>2093</i>&nbsp;     * &lt;code&gt;anAction&lt;/code&gt; will replace the action.</b>
<b class="nc"><i>2094</i>&nbsp;     *</b>
<b class="nc"><i>2095</i>&nbsp;     * @param anAction  the &lt;code&gt;Action&lt;/code&gt; to be registered</b>
<b class="nc"><i>2096</i>&nbsp;     * @param aCommand  the command to be set in the delivered event</b>
<b class="nc"><i>2097</i>&nbsp;     * @param aKeyStroke the &lt;code&gt;KeyStroke&lt;/code&gt; to bind to the action</b>
<i>2098</i>&nbsp;     * @param aCondition the condition that needs to be met, see above
<i>2099</i>&nbsp;     * @see KeyStroke
<i>2100</i>&nbsp;     */
<i>2101</i>&nbsp;    public void registerKeyboardAction(ActionListener anAction,String aCommand,KeyStroke aKeyStroke,int aCondition) {
<i>2102</i>&nbsp;
<i>2103</i>&nbsp;        InputMap inputMap = getInputMap(aCondition, true);
<i>2104</i>&nbsp;
<i>2105</i>&nbsp;        if (inputMap != null) {
<i>2106</i>&nbsp;            ActionMap actionMap = getActionMap(true);
<i>2107</i>&nbsp;            ActionStandin action = new ActionStandin(anAction, aCommand);
<i>2108</i>&nbsp;            inputMap.put(aKeyStroke, action);
<i>2109</i>&nbsp;            if (actionMap != null) {
<i>2110</i>&nbsp;                actionMap.put(action, action);
<i>2111</i>&nbsp;            }
<i>2112</i>&nbsp;        }
<b class="nc"><i>2113</i>&nbsp;    }</b>
<i>2114</i>&nbsp;
<b class="nc"><i>2115</i>&nbsp;    /**</b>
<i>2116</i>&nbsp;     * Registers any bound &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; actions with
<b class="nc"><i>2117</i>&nbsp;     * the &lt;code&gt;KeyboardManager&lt;/code&gt;. If &lt;code&gt;onlyIfNew&lt;/code&gt;</b>
<i>2118</i>&nbsp;     * is true only actions that haven&#39;t been registered are pushed
<b class="nc"><i>2119</i>&nbsp;     * to the &lt;code&gt;KeyboardManager&lt;/code&gt;;</b>
<i>2120</i>&nbsp;     * otherwise all actions are pushed to the &lt;code&gt;KeyboardManager&lt;/code&gt;.
<b class="nc"><i>2121</i>&nbsp;     *</b>
<b class="nc"><i>2122</i>&nbsp;     * @param onlyIfNew  if true, only actions that haven&#39;t been registered</b>
<b class="nc"><i>2123</i>&nbsp;     *          are pushed to the &lt;code&gt;KeyboardManager&lt;/code&gt;</b>
<b class="nc"><i>2124</i>&nbsp;     */</b>
<b class="nc"><i>2125</i>&nbsp;    private void registerWithKeyboardManager(boolean onlyIfNew) {</b>
<b class="nc"><i>2126</i>&nbsp;        InputMap inputMap = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);</b>
<b class="nc"><i>2127</i>&nbsp;        KeyStroke[] strokes;</b>
<i>2128</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>2129</i>&nbsp;        Hashtable&lt;KeyStroke, KeyStroke&gt; registered =</b>
<b class="nc"><i>2130</i>&nbsp;                (Hashtable&lt;KeyStroke, KeyStroke&gt;)getClientProperty</b>
<i>2131</i>&nbsp;                                (WHEN_IN_FOCUSED_WINDOW_BINDINGS);
<i>2132</i>&nbsp;
<i>2133</i>&nbsp;        if (inputMap != null) {
<i>2134</i>&nbsp;            // Push any new KeyStrokes to the KeyboardManager.
<i>2135</i>&nbsp;            strokes = inputMap.allKeys();
<b class="nc"><i>2136</i>&nbsp;            if (strokes != null) {</b>
<i>2137</i>&nbsp;                for (int counter = strokes.length - 1; counter &gt;= 0;
<i>2138</i>&nbsp;                     counter--) {
<b class="nc"><i>2139</i>&nbsp;                    if (!onlyIfNew || registered == null ||</b>
<b class="nc"><i>2140</i>&nbsp;                        registered.get(strokes[counter]) == null) {</b>
<i>2141</i>&nbsp;                        registerWithKeyboardManager(strokes[counter]);
<b class="nc"><i>2142</i>&nbsp;                    }</b>
<b class="nc"><i>2143</i>&nbsp;                    if (registered != null) {</b>
<b class="nc"><i>2144</i>&nbsp;                        registered.remove(strokes[counter]);</b>
<b class="nc"><i>2145</i>&nbsp;                    }</b>
<b class="nc"><i>2146</i>&nbsp;                }</b>
<i>2147</i>&nbsp;            }
<i>2148</i>&nbsp;        }
<b class="nc"><i>2149</i>&nbsp;        else {</b>
<b class="nc"><i>2150</i>&nbsp;            strokes = null;</b>
<b class="nc"><i>2151</i>&nbsp;        }</b>
<b class="nc"><i>2152</i>&nbsp;        // Remove any old ones.</b>
<i>2153</i>&nbsp;        if (registered != null &amp;&amp; registered.size() &gt; 0) {
<b class="nc"><i>2154</i>&nbsp;            Enumeration&lt;KeyStroke&gt; keys = registered.keys();</b>
<b class="nc"><i>2155</i>&nbsp;</b>
<i>2156</i>&nbsp;            while (keys.hasMoreElements()) {
<i>2157</i>&nbsp;                KeyStroke ks = keys.nextElement();
<i>2158</i>&nbsp;                unregisterWithKeyboardManager(ks);
<b class="nc"><i>2159</i>&nbsp;            }</b>
<i>2160</i>&nbsp;            registered.clear();
<i>2161</i>&nbsp;        }
<i>2162</i>&nbsp;        // Updated the registered Hashtable.
<i>2163</i>&nbsp;        if (strokes != null &amp;&amp; strokes.length &gt; 0) {
<i>2164</i>&nbsp;            if (registered == null) {
<i>2165</i>&nbsp;                registered = new Hashtable&lt;KeyStroke, KeyStroke&gt;(strokes.length);
<i>2166</i>&nbsp;                putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, registered);
<i>2167</i>&nbsp;            }
<b class="nc"><i>2168</i>&nbsp;            for (int counter = strokes.length - 1; counter &gt;= 0; counter--) {</b>
<i>2169</i>&nbsp;                registered.put(strokes[counter], strokes[counter]);
<b class="nc"><i>2170</i>&nbsp;            }</b>
<i>2171</i>&nbsp;        }
<b class="nc"><i>2172</i>&nbsp;        else {</b>
<b class="nc"><i>2173</i>&nbsp;            putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);</b>
<i>2174</i>&nbsp;        }
<b class="nc"><i>2175</i>&nbsp;    }</b>
<b class="nc"><i>2176</i>&nbsp;</b>
<b class="nc"><i>2177</i>&nbsp;    /**</b>
<b class="nc"><i>2178</i>&nbsp;     * Unregisters all the previously registered</b>
<i>2179</i>&nbsp;     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; &lt;code&gt;KeyStroke&lt;/code&gt; bindings.
<b class="nc"><i>2180</i>&nbsp;     */</b>
<i>2181</i>&nbsp;    private void unregisterWithKeyboardManager() {
<i>2182</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>2183</i>&nbsp;        Hashtable&lt;KeyStroke, KeyStroke&gt; registered =
<i>2184</i>&nbsp;                (Hashtable&lt;KeyStroke, KeyStroke&gt;)getClientProperty
<i>2185</i>&nbsp;                                (WHEN_IN_FOCUSED_WINDOW_BINDINGS);
<i>2186</i>&nbsp;
<i>2187</i>&nbsp;        if (registered != null &amp;&amp; registered.size() &gt; 0) {
<i>2188</i>&nbsp;            Enumeration&lt;KeyStroke&gt; keys = registered.keys();
<i>2189</i>&nbsp;
<i>2190</i>&nbsp;            while (keys.hasMoreElements()) {
<i>2191</i>&nbsp;                KeyStroke ks = keys.nextElement();
<b class="nc"><i>2192</i>&nbsp;                unregisterWithKeyboardManager(ks);</b>
<i>2193</i>&nbsp;            }
<b class="nc"><i>2194</i>&nbsp;        }</b>
<b class="nc"><i>2195</i>&nbsp;        putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);</b>
<i>2196</i>&nbsp;    }
<b class="nc"><i>2197</i>&nbsp;</b>
<b class="nc"><i>2198</i>&nbsp;    /**</b>
<i>2199</i>&nbsp;     * Invoked from &lt;code&gt;ComponentInputMap&lt;/code&gt; when its bindings change.
<i>2200</i>&nbsp;     * If &lt;code&gt;inputMap&lt;/code&gt; is the current &lt;code&gt;windowInputMap&lt;/code&gt;
<i>2201</i>&nbsp;     * (or a parent of the window &lt;code&gt;InputMap&lt;/code&gt;)
<i>2202</i>&nbsp;     * the &lt;code&gt;KeyboardManager&lt;/code&gt; is notified of the new bindings.
<b class="nc"><i>2203</i>&nbsp;     *</b>
<i>2204</i>&nbsp;     * @param inputMap the map containing the new bindings
<i>2205</i>&nbsp;     */
<i>2206</i>&nbsp;    void componentInputMapChanged(ComponentInputMap inputMap) {
<b class="nc"><i>2207</i>&nbsp;        InputMap km = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);</b>
<i>2208</i>&nbsp;
<i>2209</i>&nbsp;        while (km != inputMap &amp;&amp; km != null) {
<i>2210</i>&nbsp;            km = km.getParent();
<i>2211</i>&nbsp;        }
<i>2212</i>&nbsp;        if (km != null) {
<i>2213</i>&nbsp;            registerWithKeyboardManager(false);
<i>2214</i>&nbsp;        }
<i>2215</i>&nbsp;    }
<i>2216</i>&nbsp;
<b class="nc"><i>2217</i>&nbsp;    private void registerWithKeyboardManager(KeyStroke aKeyStroke) {</b>
<i>2218</i>&nbsp;        KeyboardManager.getCurrentManager().registerKeyStroke(aKeyStroke,this);
<i>2219</i>&nbsp;    }
<i>2220</i>&nbsp;
<i>2221</i>&nbsp;    private void unregisterWithKeyboardManager(KeyStroke aKeyStroke) {
<i>2222</i>&nbsp;        KeyboardManager.getCurrentManager().unregisterKeyStroke(aKeyStroke,
<i>2223</i>&nbsp;                                                                this);
<i>2224</i>&nbsp;    }
<i>2225</i>&nbsp;
<i>2226</i>&nbsp;    /**
<i>2227</i>&nbsp;     * This method is now obsolete, please use a combination of
<i>2228</i>&nbsp;     * &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
<i>2229</i>&nbsp;     * similar behavior.
<i>2230</i>&nbsp;     *
<i>2231</i>&nbsp;     * @param anAction  action to be registered to given keystroke and condition
<i>2232</i>&nbsp;     * @param aKeyStroke  a {@code KeyStroke}
<i>2233</i>&nbsp;     * @param aCondition  the condition to be associated with given keystroke
<i>2234</i>&nbsp;     *                    and action
<b class="nc"><i>2235</i>&nbsp;     * @see #getActionMap</b>
<b class="nc"><i>2236</i>&nbsp;     * @see #getInputMap(int)</b>
<b class="nc"><i>2237</i>&nbsp;     */</b>
<b class="nc"><i>2238</i>&nbsp;    public void registerKeyboardAction(ActionListener anAction,KeyStroke aKeyStroke,int aCondition) {</b>
<b class="nc"><i>2239</i>&nbsp;        registerKeyboardAction(anAction,null,aKeyStroke,aCondition);</b>
<i>2240</i>&nbsp;    }
<b class="nc"><i>2241</i>&nbsp;</b>
<b class="nc"><i>2242</i>&nbsp;    /**</b>
<i>2243</i>&nbsp;     * This method is now obsolete. To unregister an existing binding
<b class="nc"><i>2244</i>&nbsp;     * you can either remove the binding from the</b>
<i>2245</i>&nbsp;     * &lt;code&gt;ActionMap/InputMap&lt;/code&gt;, or place a dummy binding the
<i>2246</i>&nbsp;     * &lt;code&gt;InputMap&lt;/code&gt;. Removing the binding from the
<i>2247</i>&nbsp;     * &lt;code&gt;InputMap&lt;/code&gt; allows bindings in parent &lt;code&gt;InputMap&lt;/code&gt;s
<i>2248</i>&nbsp;     * to be active, whereas putting a dummy binding in the
<i>2249</i>&nbsp;     * &lt;code&gt;InputMap&lt;/code&gt; effectively disables
<i>2250</i>&nbsp;     * the binding from ever happening.
<i>2251</i>&nbsp;     * &lt;p&gt;
<i>2252</i>&nbsp;     * Unregisters a keyboard action.
<i>2253</i>&nbsp;     * This will remove the binding from the &lt;code&gt;ActionMap&lt;/code&gt;
<i>2254</i>&nbsp;     * (if it exists) as well as the &lt;code&gt;InputMap&lt;/code&gt;s.
<i>2255</i>&nbsp;     *
<i>2256</i>&nbsp;     * @param aKeyStroke  the keystroke for which to unregister its
<b class="nc"><i>2257</i>&nbsp;     *                    keyboard action</b>
<b class="nc"><i>2258</i>&nbsp;     */</b>
<i>2259</i>&nbsp;    public void unregisterKeyboardAction(KeyStroke aKeyStroke) {
<b class="nc"><i>2260</i>&nbsp;        ActionMap am = getActionMap(false);</b>
<b class="nc"><i>2261</i>&nbsp;        for (int counter = 0; counter &lt; 3; counter++) {</b>
<b class="nc"><i>2262</i>&nbsp;            InputMap km = getInputMap(counter, false);</b>
<b class="nc"><i>2263</i>&nbsp;            if (km != null) {</b>
<i>2264</i>&nbsp;                Object actionID = km.get(aKeyStroke);
<i>2265</i>&nbsp;
<b class="nc"><i>2266</i>&nbsp;                if (am != null &amp;&amp; actionID != null) {</b>
<i>2267</i>&nbsp;                    am.remove(actionID);
<b class="nc"><i>2268</i>&nbsp;                }</b>
<b class="nc"><i>2269</i>&nbsp;                km.remove(aKeyStroke);</b>
<b class="nc"><i>2270</i>&nbsp;            }</b>
<i>2271</i>&nbsp;        }
<b class="nc"><i>2272</i>&nbsp;    }</b>
<i>2273</i>&nbsp;
<i>2274</i>&nbsp;    /**
<b class="nc"><i>2275</i>&nbsp;     * Returns the &lt;code&gt;KeyStrokes&lt;/code&gt; that will initiate</b>
<i>2276</i>&nbsp;     * registered actions.
<i>2277</i>&nbsp;     *
<i>2278</i>&nbsp;     * @return an array of &lt;code&gt;KeyStroke&lt;/code&gt; objects
<i>2279</i>&nbsp;     * @see #registerKeyboardAction
<i>2280</i>&nbsp;     */
<i>2281</i>&nbsp;    @BeanProperty(bound = false)
<i>2282</i>&nbsp;    public KeyStroke[] getRegisteredKeyStrokes() {
<i>2283</i>&nbsp;        int[] counts = new int[3];
<i>2284</i>&nbsp;        KeyStroke[][] strokes = new KeyStroke[3][];
<i>2285</i>&nbsp;
<i>2286</i>&nbsp;        for (int counter = 0; counter &lt; 3; counter++) {
<i>2287</i>&nbsp;            InputMap km = getInputMap(counter, false);
<i>2288</i>&nbsp;            strokes[counter] = (km != null) ? km.allKeys() : null;
<i>2289</i>&nbsp;            counts[counter] = (strokes[counter] != null) ?
<i>2290</i>&nbsp;                               strokes[counter].length : 0;
<b class="nc"><i>2291</i>&nbsp;        }</b>
<b class="nc"><i>2292</i>&nbsp;        KeyStroke[] retValue = new KeyStroke[counts[0] + counts[1] +</b>
<b class="nc"><i>2293</i>&nbsp;                                            counts[2]];</b>
<b class="nc"><i>2294</i>&nbsp;        for (int counter = 0, last = 0; counter &lt; 3; counter++) {</b>
<i>2295</i>&nbsp;            if (counts[counter] &gt; 0) {
<i>2296</i>&nbsp;                System.arraycopy(strokes[counter], 0, retValue, last,
<b class="nc"><i>2297</i>&nbsp;                                 counts[counter]);</b>
<i>2298</i>&nbsp;                last += counts[counter];
<i>2299</i>&nbsp;            }
<i>2300</i>&nbsp;        }
<i>2301</i>&nbsp;        return retValue;
<i>2302</i>&nbsp;    }
<i>2303</i>&nbsp;
<i>2304</i>&nbsp;    /**
<i>2305</i>&nbsp;     * Returns the condition that determines whether a registered action
<i>2306</i>&nbsp;     * occurs in response to the specified keystroke.
<i>2307</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2308</i>&nbsp;     * For Java 2 platform v1.3, a &lt;code&gt;KeyStroke&lt;/code&gt; can be associated</b>
<i>2309</i>&nbsp;     * with more than one condition.
<b class="nc"><i>2310</i>&nbsp;     * For example, &#39;a&#39; could be bound for the two</b>
<b class="nc"><i>2311</i>&nbsp;     * conditions &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; and</b>
<i>2312</i>&nbsp;     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; condition.
<b class="nc"><i>2313</i>&nbsp;     *</b>
<b class="nc"><i>2314</i>&nbsp;     * @param aKeyStroke  the keystroke for which to request an</b>
<b class="nc"><i>2315</i>&nbsp;     *                    action-keystroke condition</b>
<b class="nc"><i>2316</i>&nbsp;     * @return the action-keystroke condition</b>
<i>2317</i>&nbsp;     */
<b class="nc"><i>2318</i>&nbsp;    public int getConditionForKeyStroke(KeyStroke aKeyStroke) {</b>
<b class="nc"><i>2319</i>&nbsp;        for (int counter = 0; counter &lt; 3; counter++) {</b>
<b class="nc"><i>2320</i>&nbsp;            InputMap inputMap = getInputMap(counter, false);</b>
<b class="nc"><i>2321</i>&nbsp;            if (inputMap != null &amp;&amp; inputMap.get(aKeyStroke) != null) {</b>
<i>2322</i>&nbsp;                return counter;
<b class="nc"><i>2323</i>&nbsp;            }</b>
<i>2324</i>&nbsp;        }
<i>2325</i>&nbsp;        return UNDEFINED_CONDITION;
<i>2326</i>&nbsp;    }
<b class="nc"><i>2327</i>&nbsp;</b>
<i>2328</i>&nbsp;    /**
<i>2329</i>&nbsp;     * Returns the object that will perform the action registered for a
<i>2330</i>&nbsp;     * given keystroke.
<i>2331</i>&nbsp;     *
<i>2332</i>&nbsp;     * @param aKeyStroke  the keystroke for which to return a listener
<i>2333</i>&nbsp;     * @return the &lt;code&gt;ActionListener&lt;/code&gt;
<i>2334</i>&nbsp;     *          object invoked when the keystroke occurs
<i>2335</i>&nbsp;     */
<i>2336</i>&nbsp;    public ActionListener getActionForKeyStroke(KeyStroke aKeyStroke) {
<i>2337</i>&nbsp;        ActionMap am = getActionMap(false);
<i>2338</i>&nbsp;
<b class="nc"><i>2339</i>&nbsp;        if (am == null) {</b>
<b class="nc"><i>2340</i>&nbsp;            return null;</b>
<i>2341</i>&nbsp;        }
<b class="nc"><i>2342</i>&nbsp;        for (int counter = 0; counter &lt; 3; counter++) {</b>
<b class="nc"><i>2343</i>&nbsp;            InputMap inputMap = getInputMap(counter, false);</b>
<i>2344</i>&nbsp;            if (inputMap != null) {
<i>2345</i>&nbsp;                Object actionBinding = inputMap.get(aKeyStroke);
<i>2346</i>&nbsp;
<i>2347</i>&nbsp;                if (actionBinding != null) {
<b class="nc"><i>2348</i>&nbsp;                    Action action = am.get(actionBinding);</b>
<i>2349</i>&nbsp;                    if (action instanceof ActionStandin) {
<b class="nc"><i>2350</i>&nbsp;                        return ((ActionStandin)action).actionListener;</b>
<b class="nc"><i>2351</i>&nbsp;                    }</b>
<i>2352</i>&nbsp;                    return action;
<i>2353</i>&nbsp;                }
<i>2354</i>&nbsp;            }
<i>2355</i>&nbsp;        }
<i>2356</i>&nbsp;        return null;
<i>2357</i>&nbsp;    }
<i>2358</i>&nbsp;
<i>2359</i>&nbsp;    /**
<i>2360</i>&nbsp;     * Unregisters all the bindings in the first tier &lt;code&gt;InputMaps&lt;/code&gt;
<i>2361</i>&nbsp;     * and &lt;code&gt;ActionMap&lt;/code&gt;. This has the effect of removing any
<i>2362</i>&nbsp;     * local bindings, and allowing the bindings defined in parent
<i>2363</i>&nbsp;     * &lt;code&gt;InputMap/ActionMaps&lt;/code&gt;
<i>2364</i>&nbsp;     * (the UI is usually defined in the second tier) to persist.
<i>2365</i>&nbsp;     */
<i>2366</i>&nbsp;    public void resetKeyboardActions() {
<i>2367</i>&nbsp;        // Keys
<i>2368</i>&nbsp;        for (int counter = 0; counter &lt; 3; counter++) {
<i>2369</i>&nbsp;            InputMap inputMap = getInputMap(counter, false);
<i>2370</i>&nbsp;
<i>2371</i>&nbsp;            if (inputMap != null) {
<i>2372</i>&nbsp;                inputMap.clear();
<i>2373</i>&nbsp;            }
<i>2374</i>&nbsp;        }
<i>2375</i>&nbsp;
<i>2376</i>&nbsp;        // Actions
<i>2377</i>&nbsp;        ActionMap am = getActionMap(false);
<i>2378</i>&nbsp;
<i>2379</i>&nbsp;        if (am != null) {
<i>2380</i>&nbsp;            am.clear();
<i>2381</i>&nbsp;        }
<i>2382</i>&nbsp;    }
<b class="nc"><i>2383</i>&nbsp;</b>
<i>2384</i>&nbsp;    /**
<b class="nc"><i>2385</i>&nbsp;     * Sets the &lt;code&gt;InputMap&lt;/code&gt; to use under the condition</b>
<b class="nc"><i>2386</i>&nbsp;     * &lt;code&gt;condition&lt;/code&gt; to</b>
<i>2387</i>&nbsp;     * &lt;code&gt;map&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; value implies you
<b class="nc"><i>2388</i>&nbsp;     * do not want any bindings to be used, even from the UI. This will</b>
<b class="nc"><i>2389</i>&nbsp;     * not reinstall the UI &lt;code&gt;InputMap&lt;/code&gt; (if there was one).</b>
<b class="nc"><i>2390</i>&nbsp;     * &lt;code&gt;condition&lt;/code&gt; has one of the following values:</b>
<b class="nc"><i>2391</i>&nbsp;     * &lt;ul&gt;</b>
<i>2392</i>&nbsp;     * &lt;li&gt;&lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
<b class="nc"><i>2393</i>&nbsp;     * &lt;li&gt;&lt;code&gt;WHEN_FOCUSED&lt;/code&gt;</b>
<b class="nc"><i>2394</i>&nbsp;     * &lt;li&gt;&lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt;</b>
<b class="nc"><i>2395</i>&nbsp;     * &lt;/ul&gt;</b>
<i>2396</i>&nbsp;     * If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
<b class="nc"><i>2397</i>&nbsp;     * and &lt;code&gt;map&lt;/code&gt; is not a &lt;code&gt;ComponentInputMap&lt;/code&gt;, an</b>
<b class="nc"><i>2398</i>&nbsp;     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</b>
<b class="nc"><i>2399</i>&nbsp;     * Similarly, if &lt;code&gt;condition&lt;/code&gt; is not one of the values</b>
<i>2400</i>&nbsp;     * listed, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
<b class="nc"><i>2401</i>&nbsp;     *</b>
<i>2402</i>&nbsp;     * @param condition one of the values listed above
<i>2403</i>&nbsp;     * @param map  the &lt;code&gt;InputMap&lt;/code&gt; to use for the given condition
<i>2404</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;condition&lt;/code&gt; is
<i>2405</i>&nbsp;     *          &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;
<i>2406</i>&nbsp;     *          is not an instance of &lt;code&gt;ComponentInputMap&lt;/code&gt;; or
<i>2407</i>&nbsp;     *          if &lt;code&gt;condition&lt;/code&gt; is not one of the legal values
<i>2408</i>&nbsp;     *          specified above
<i>2409</i>&nbsp;     * @since 1.3
<i>2410</i>&nbsp;     */
<i>2411</i>&nbsp;    public final void setInputMap(int condition, InputMap map) {
<i>2412</i>&nbsp;        switch (condition) {
<i>2413</i>&nbsp;        case WHEN_IN_FOCUSED_WINDOW:
<i>2414</i>&nbsp;            if (map != null &amp;&amp; !(map instanceof ComponentInputMap)) {
<i>2415</i>&nbsp;                throw new IllegalArgumentException(&quot;WHEN_IN_FOCUSED_WINDOW InputMaps must be of type ComponentInputMap&quot;);
<b class="nc"><i>2416</i>&nbsp;            }</b>
<i>2417</i>&nbsp;            windowInputMap = (ComponentInputMap)map;
<i>2418</i>&nbsp;            setFlag(WIF_INPUTMAP_CREATED, true);
<i>2419</i>&nbsp;            registerWithKeyboardManager(false);
<i>2420</i>&nbsp;            break;
<i>2421</i>&nbsp;        case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
<i>2422</i>&nbsp;            ancestorInputMap = map;
<i>2423</i>&nbsp;            setFlag(ANCESTOR_INPUTMAP_CREATED, true);
<i>2424</i>&nbsp;            break;
<i>2425</i>&nbsp;        case WHEN_FOCUSED:
<i>2426</i>&nbsp;            focusInputMap = map;
<i>2427</i>&nbsp;            setFlag(FOCUS_INPUTMAP_CREATED, true);
<b class="nc"><i>2428</i>&nbsp;            break;</b>
<i>2429</i>&nbsp;        default:
<i>2430</i>&nbsp;            throw new IllegalArgumentException(&quot;condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&quot;);
<i>2431</i>&nbsp;        }
<i>2432</i>&nbsp;    }
<i>2433</i>&nbsp;
<i>2434</i>&nbsp;    /**
<i>2435</i>&nbsp;     * Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used during
<i>2436</i>&nbsp;     * &lt;code&gt;condition&lt;/code&gt;.
<i>2437</i>&nbsp;     *
<i>2438</i>&nbsp;     * @param condition one of WHEN_IN_FOCUSED_WINDOW, WHEN_FOCUSED,
<i>2439</i>&nbsp;     *        WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
<b class="nc"><i>2440</i>&nbsp;     * @return the &lt;code&gt;InputMap&lt;/code&gt; for the specified</b>
<b class="nc"><i>2441</i>&nbsp;     *          &lt;code&gt;condition&lt;/code&gt;</b>
<i>2442</i>&nbsp;     * @since 1.3
<i>2443</i>&nbsp;     */
<i>2444</i>&nbsp;    public final InputMap getInputMap(int condition) {
<i>2445</i>&nbsp;        return getInputMap(condition, true);
<i>2446</i>&nbsp;    }
<i>2447</i>&nbsp;
<i>2448</i>&nbsp;    /**
<i>2449</i>&nbsp;     * Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used when the
<i>2450</i>&nbsp;     * component has focus.
<i>2451</i>&nbsp;     * This is convenience method for &lt;code&gt;getInputMap(WHEN_FOCUSED)&lt;/code&gt;.
<i>2452</i>&nbsp;     *
<i>2453</i>&nbsp;     * @return the &lt;code&gt;InputMap&lt;/code&gt; used when the component has focus
<b class="nc"><i>2454</i>&nbsp;     * @since 1.3</b>
<i>2455</i>&nbsp;     */
<i>2456</i>&nbsp;    public final InputMap getInputMap() {
<i>2457</i>&nbsp;        return getInputMap(WHEN_FOCUSED, true);
<i>2458</i>&nbsp;    }
<i>2459</i>&nbsp;
<i>2460</i>&nbsp;    /**
<i>2461</i>&nbsp;     * Sets the &lt;code&gt;ActionMap&lt;/code&gt; to &lt;code&gt;am&lt;/code&gt;. This does not set
<i>2462</i>&nbsp;     * the parent of the &lt;code&gt;am&lt;/code&gt; to be the &lt;code&gt;ActionMap&lt;/code&gt;
<i>2463</i>&nbsp;     * from the UI (if there was one), it is up to the caller to have done this.
<i>2464</i>&nbsp;     *
<i>2465</i>&nbsp;     * @param am  the new &lt;code&gt;ActionMap&lt;/code&gt;
<i>2466</i>&nbsp;     * @since 1.3
<i>2467</i>&nbsp;     */
<i>2468</i>&nbsp;    public final void setActionMap(ActionMap am) {
<i>2469</i>&nbsp;        actionMap = am;
<i>2470</i>&nbsp;        setFlag(ACTIONMAP_CREATED, true);
<i>2471</i>&nbsp;    }
<i>2472</i>&nbsp;
<i>2473</i>&nbsp;    /**
<i>2474</i>&nbsp;     * Returns the &lt;code&gt;ActionMap&lt;/code&gt; used to determine what
<i>2475</i>&nbsp;     * &lt;code&gt;Action&lt;/code&gt; to fire for particular &lt;code&gt;KeyStroke&lt;/code&gt;
<i>2476</i>&nbsp;     * binding. The returned &lt;code&gt;ActionMap&lt;/code&gt;, unless otherwise
<i>2477</i>&nbsp;     * set, will have the &lt;code&gt;ActionMap&lt;/code&gt; from the UI set as the parent.
<b class="nc"><i>2478</i>&nbsp;     *</b>
<i>2479</i>&nbsp;     * @return the &lt;code&gt;ActionMap&lt;/code&gt; containing the key/action bindings
<b class="nc"><i>2480</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>2481</i>&nbsp;     */</b>
<i>2482</i>&nbsp;    public final ActionMap getActionMap() {
<i>2483</i>&nbsp;        return getActionMap(true);
<b class="nc"><i>2484</i>&nbsp;    }</b>
<b class="nc"><i>2485</i>&nbsp;</b>
<b class="nc"><i>2486</i>&nbsp;    /**</b>
<b class="nc"><i>2487</i>&nbsp;     * Returns the &lt;code&gt;InputMap&lt;/code&gt; to use for condition</b>
<i>2488</i>&nbsp;     * &lt;code&gt;condition&lt;/code&gt;.  If the &lt;code&gt;InputMap&lt;/code&gt; hasn&#39;t
<i>2489</i>&nbsp;     * been created, and &lt;code&gt;create&lt;/code&gt; is
<i>2490</i>&nbsp;     * true, it will be created.
<b class="nc"><i>2491</i>&nbsp;     *</b>
<b class="nc"><i>2492</i>&nbsp;     * @param condition one of the following values:</b>
<i>2493</i>&nbsp;     * &lt;ul&gt;
<i>2494</i>&nbsp;     * &lt;li&gt;JComponent.FOCUS_INPUTMAP_CREATED
<b class="nc"><i>2495</i>&nbsp;     * &lt;li&gt;JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</b>
<b class="nc"><i>2496</i>&nbsp;     * &lt;li&gt;JComponent.WHEN_IN_FOCUSED_WINDOW</b>
<b class="nc"><i>2497</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>2498</i>&nbsp;     * @param create if true, create the &lt;code&gt;InputMap&lt;/code&gt; if it</b>
<i>2499</i>&nbsp;     *          is not already created
<i>2500</i>&nbsp;     * @return the &lt;code&gt;InputMap&lt;/code&gt; for the given &lt;code&gt;condition&lt;/code&gt;;
<i>2501</i>&nbsp;     *          if &lt;code&gt;create&lt;/code&gt; is false and the &lt;code&gt;InputMap&lt;/code&gt;
<b class="nc"><i>2502</i>&nbsp;     *          hasn&#39;t been created, returns &lt;code&gt;null&lt;/code&gt;</b>
<b class="nc"><i>2503</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;condition&lt;/code&gt;</b>
<i>2504</i>&nbsp;     *          is not one of the legal values listed above
<i>2505</i>&nbsp;     */
<b class="nc"><i>2506</i>&nbsp;    final InputMap getInputMap(int condition, boolean create) {</b>
<b class="nc"><i>2507</i>&nbsp;        switch (condition) {</b>
<b class="nc"><i>2508</i>&nbsp;        case WHEN_FOCUSED:</b>
<b class="nc"><i>2509</i>&nbsp;            if (getFlag(FOCUS_INPUTMAP_CREATED)) {</b>
<i>2510</i>&nbsp;                return focusInputMap;
<i>2511</i>&nbsp;            }
<i>2512</i>&nbsp;            // Hasn&#39;t been created yet.
<b class="nc"><i>2513</i>&nbsp;            if (create) {</b>
<i>2514</i>&nbsp;                InputMap km = new InputMap();
<b class="nc"><i>2515</i>&nbsp;                setInputMap(condition, km);</b>
<i>2516</i>&nbsp;                return km;
<i>2517</i>&nbsp;            }
<i>2518</i>&nbsp;            break;
<i>2519</i>&nbsp;        case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
<i>2520</i>&nbsp;            if (getFlag(ANCESTOR_INPUTMAP_CREATED)) {
<i>2521</i>&nbsp;                return ancestorInputMap;
<i>2522</i>&nbsp;            }
<i>2523</i>&nbsp;            // Hasn&#39;t been created yet.
<i>2524</i>&nbsp;            if (create) {
<i>2525</i>&nbsp;                InputMap km = new InputMap();
<i>2526</i>&nbsp;                setInputMap(condition, km);
<i>2527</i>&nbsp;                return km;
<b class="nc"><i>2528</i>&nbsp;            }</b>
<b class="nc"><i>2529</i>&nbsp;            break;</b>
<i>2530</i>&nbsp;        case WHEN_IN_FOCUSED_WINDOW:
<i>2531</i>&nbsp;            if (getFlag(WIF_INPUTMAP_CREATED)) {
<b class="nc"><i>2532</i>&nbsp;                return windowInputMap;</b>
<b class="nc"><i>2533</i>&nbsp;            }</b>
<b class="nc"><i>2534</i>&nbsp;            // Hasn&#39;t been created yet.</b>
<b class="nc"><i>2535</i>&nbsp;            if (create) {</b>
<i>2536</i>&nbsp;                ComponentInputMap km = new ComponentInputMap(this);
<b class="nc"><i>2537</i>&nbsp;                setInputMap(condition, km);</b>
<i>2538</i>&nbsp;                return km;
<i>2539</i>&nbsp;            }
<i>2540</i>&nbsp;            break;
<i>2541</i>&nbsp;        default:
<i>2542</i>&nbsp;            throw new IllegalArgumentException(&quot;condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&quot;);
<i>2543</i>&nbsp;        }
<i>2544</i>&nbsp;        return null;
<i>2545</i>&nbsp;    }
<i>2546</i>&nbsp;
<i>2547</i>&nbsp;    /**
<i>2548</i>&nbsp;     * Finds and returns the appropriate &lt;code&gt;ActionMap&lt;/code&gt;.
<i>2549</i>&nbsp;     *
<i>2550</i>&nbsp;     * @param create if true, create the &lt;code&gt;ActionMap&lt;/code&gt; if it
<i>2551</i>&nbsp;     *          is not already created
<i>2552</i>&nbsp;     * @return the &lt;code&gt;ActionMap&lt;/code&gt; for this component; if the
<i>2553</i>&nbsp;     *          &lt;code&gt;create&lt;/code&gt; flag is false and there is no
<i>2554</i>&nbsp;     *          current &lt;code&gt;ActionMap&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;
<i>2555</i>&nbsp;     */
<i>2556</i>&nbsp;    final ActionMap getActionMap(boolean create) {
<i>2557</i>&nbsp;        if (getFlag(ACTIONMAP_CREATED)) {
<i>2558</i>&nbsp;            return actionMap;
<i>2559</i>&nbsp;        }
<i>2560</i>&nbsp;        // Hasn&#39;t been created.
<i>2561</i>&nbsp;        if (create) {
<i>2562</i>&nbsp;            ActionMap am = new ActionMap();
<b class="nc"><i>2563</i>&nbsp;            setActionMap(am);</b>
<b class="nc"><i>2564</i>&nbsp;            return am;</b>
<b class="nc"><i>2565</i>&nbsp;        }</b>
<i>2566</i>&nbsp;        return null;
<b class="nc"><i>2567</i>&nbsp;    }</b>
<i>2568</i>&nbsp;
<i>2569</i>&nbsp;    /**
<i>2570</i>&nbsp;     * Returns the baseline.  The baseline is measured from the top of
<i>2571</i>&nbsp;     * the component.  This method is primarily meant for
<i>2572</i>&nbsp;     * &lt;code&gt;LayoutManager&lt;/code&gt;s to align components along their
<i>2573</i>&nbsp;     * baseline.  A return value less than 0 indicates this component
<i>2574</i>&nbsp;     * does not have a reasonable baseline and that
<i>2575</i>&nbsp;     * &lt;code&gt;LayoutManager&lt;/code&gt;s should not align this component on
<i>2576</i>&nbsp;     * its baseline.
<i>2577</i>&nbsp;     * &lt;p&gt;
<i>2578</i>&nbsp;     * This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of the
<i>2579</i>&nbsp;     * same name.  If this component does not have a &lt;code&gt;ComponentUI&lt;/code&gt;
<i>2580</i>&nbsp;     * -1 will be returned.  If a value &amp;gt;= 0 is
<i>2581</i>&nbsp;     * returned, then the component has a valid baseline for any
<i>2582</i>&nbsp;     * size &amp;gt;= the minimum size and &lt;code&gt;getBaselineResizeBehavior&lt;/code&gt;
<i>2583</i>&nbsp;     * can be used to determine how the baseline changes with size.
<i>2584</i>&nbsp;     *
<i>2585</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}
<i>2586</i>&nbsp;     * @see #getBaselineResizeBehavior
<i>2587</i>&nbsp;     * @see java.awt.FontMetrics
<i>2588</i>&nbsp;     * @since 1.6
<i>2589</i>&nbsp;     */
<i>2590</i>&nbsp;    public int getBaseline(int width, int height) {
<i>2591</i>&nbsp;        // check size.
<b class="nc"><i>2592</i>&nbsp;        super.getBaseline(width, height);</b>
<b class="nc"><i>2593</i>&nbsp;        if (ui != null) {</b>
<i>2594</i>&nbsp;            return ui.getBaseline(this, width, height);
<b class="nc"><i>2595</i>&nbsp;        }</b>
<i>2596</i>&nbsp;        return -1;
<i>2597</i>&nbsp;    }
<i>2598</i>&nbsp;
<i>2599</i>&nbsp;    /**
<i>2600</i>&nbsp;     * Returns an enum indicating how the baseline of the component
<i>2601</i>&nbsp;     * changes as the size changes.  This method is primarily meant for
<i>2602</i>&nbsp;     * layout managers and GUI builders.
<i>2603</i>&nbsp;     * &lt;p&gt;
<i>2604</i>&nbsp;     * This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of
<i>2605</i>&nbsp;     * the same name.  If this component does not have a
<i>2606</i>&nbsp;     * &lt;code&gt;ComponentUI&lt;/code&gt;
<i>2607</i>&nbsp;     * &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; will be
<i>2608</i>&nbsp;     * returned.  Subclasses should
<i>2609</i>&nbsp;     * never return &lt;code&gt;null&lt;/code&gt;; if the baseline can not be
<i>2610</i>&nbsp;     * calculated return &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Callers
<i>2611</i>&nbsp;     * should first ask for the baseline using
<i>2612</i>&nbsp;     * &lt;code&gt;getBaseline&lt;/code&gt; and if a value &amp;gt;= 0 is returned use
<i>2613</i>&nbsp;     * this method.  It is acceptable for this method to return a
<i>2614</i>&nbsp;     * value other than &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; even if
<i>2615</i>&nbsp;     * &lt;code&gt;getBaseline&lt;/code&gt; returns a value less than 0.
<i>2616</i>&nbsp;     *
<i>2617</i>&nbsp;     * @see #getBaseline(int, int)
<b class="nc"><i>2618</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>2619</i>&nbsp;     */</b>
<b class="nc"><i>2620</i>&nbsp;    @BeanProperty(bound = false)</b>
<b class="nc"><i>2621</i>&nbsp;    public BaselineResizeBehavior getBaselineResizeBehavior() {</b>
<i>2622</i>&nbsp;        if (ui != null) {
<b class="nc"><i>2623</i>&nbsp;            return ui.getBaselineResizeBehavior(this);</b>
<b class="nc"><i>2624</i>&nbsp;        }</b>
<b class="nc"><i>2625</i>&nbsp;        return BaselineResizeBehavior.OTHER;</b>
<b class="nc"><i>2626</i>&nbsp;    }</b>
<b class="nc"><i>2627</i>&nbsp;</b>
<i>2628</i>&nbsp;    /**
<b class="nc"><i>2629</i>&nbsp;     * In release 1.4, the focus subsystem was rearchitected.</b>
<i>2630</i>&nbsp;     * For more information, see
<i>2631</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
<i>2632</i>&nbsp;     * How to Use the Focus Subsystem&lt;/a&gt;,
<i>2633</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
<i>2634</i>&nbsp;     * &lt;p&gt;
<i>2635</i>&nbsp;     * Requests focus on this &lt;code&gt;JComponent&lt;/code&gt;&#39;s
<i>2636</i>&nbsp;     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;&#39;s default &lt;code&gt;Component&lt;/code&gt;.
<i>2637</i>&nbsp;     * If this &lt;code&gt;JComponent&lt;/code&gt; is a focus cycle root, then its
<i>2638</i>&nbsp;     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; is used. Otherwise, the
<i>2639</i>&nbsp;     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; of this &lt;code&gt;JComponent&lt;/code&gt;&#39;s
<i>2640</i>&nbsp;     * focus-cycle-root ancestor is used.
<i>2641</i>&nbsp;     *
<i>2642</i>&nbsp;     * @return true if this component can request to get the input focus,
<i>2643</i>&nbsp;     *              false if it can not
<b class="nc"><i>2644</i>&nbsp;     * @see java.awt.FocusTraversalPolicy#getDefaultComponent</b>
<b class="nc"><i>2645</i>&nbsp;     * @deprecated As of 1.4, replaced by</b>
<b class="nc"><i>2646</i>&nbsp;     * &lt;code&gt;FocusTraversalPolicy.getDefaultComponent(Container).requestFocus()&lt;/code&gt;</b>
<b class="nc"><i>2647</i>&nbsp;     */</b>
<b class="nc"><i>2648</i>&nbsp;    @Deprecated</b>
<b class="nc"><i>2649</i>&nbsp;    public boolean requestDefaultFocus() {</b>
<b class="nc"><i>2650</i>&nbsp;        Container nearestRoot =</b>
<i>2651</i>&nbsp;            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();
<b class="nc"><i>2652</i>&nbsp;        if (nearestRoot == null) {</b>
<i>2653</i>&nbsp;            return false;
<i>2654</i>&nbsp;        }
<i>2655</i>&nbsp;        Component comp = nearestRoot.getFocusTraversalPolicy().
<i>2656</i>&nbsp;            getDefaultComponent(nearestRoot);
<i>2657</i>&nbsp;        if (comp != null) {
<i>2658</i>&nbsp;            comp.requestFocus();
<i>2659</i>&nbsp;            return true;
<i>2660</i>&nbsp;        } else {
<i>2661</i>&nbsp;            return false;
<i>2662</i>&nbsp;        }
<i>2663</i>&nbsp;    }
<i>2664</i>&nbsp;
<i>2665</i>&nbsp;    /**
<i>2666</i>&nbsp;     * Makes the component visible or invisible.
<i>2667</i>&nbsp;     * Overrides &lt;code&gt;Component.setVisible&lt;/code&gt;.
<i>2668</i>&nbsp;     *
<i>2669</i>&nbsp;     * @param aFlag  true to make the component visible; false to
<i>2670</i>&nbsp;     *          make it invisible
<i>2671</i>&nbsp;     */
<i>2672</i>&nbsp;    @BeanProperty(hidden = true, visualUpdate = true)
<i>2673</i>&nbsp;    public void setVisible(boolean aFlag) {
<i>2674</i>&nbsp;        if (aFlag != isVisible()) {
<i>2675</i>&nbsp;            super.setVisible(aFlag);
<i>2676</i>&nbsp;            if (aFlag) {
<i>2677</i>&nbsp;                Container parent = getParent();
<i>2678</i>&nbsp;                if (parent != null) {
<i>2679</i>&nbsp;                    Rectangle r = getBounds();
<b class="nc"><i>2680</i>&nbsp;                    parent.repaint(r.x, r.y, r.width, r.height);</b>
<b class="nc"><i>2681</i>&nbsp;                }</b>
<b class="nc"><i>2682</i>&nbsp;                revalidate();</b>
<b class="nc"><i>2683</i>&nbsp;            }</b>
<b class="nc"><i>2684</i>&nbsp;        }</b>
<i>2685</i>&nbsp;    }
<i>2686</i>&nbsp;
<i>2687</i>&nbsp;    /**
<i>2688</i>&nbsp;     * Sets whether or not this component is enabled.
<i>2689</i>&nbsp;     * A component that is enabled may respond to user input,
<i>2690</i>&nbsp;     * while a component that is not enabled cannot respond to
<i>2691</i>&nbsp;     * user input.  Some components may alter their visual
<i>2692</i>&nbsp;     * representation when they are disabled in order to
<i>2693</i>&nbsp;     * provide feedback to the user that they cannot take input.
<i>2694</i>&nbsp;     * &lt;p&gt;Note: Disabling a component does not disable its children.
<i>2695</i>&nbsp;     *
<i>2696</i>&nbsp;     * &lt;p&gt;Note: Disabling a lightweight component does not prevent it from
<i>2697</i>&nbsp;     * receiving MouseEvents.
<i>2698</i>&nbsp;     *
<i>2699</i>&nbsp;     * @param enabled true if this component should be enabled, false otherwise
<i>2700</i>&nbsp;     * @see java.awt.Component#isEnabled
<i>2701</i>&nbsp;     * @see java.awt.Component#isLightweight
<i>2702</i>&nbsp;     */
<b class="nc"><i>2703</i>&nbsp;    @BeanProperty(expert = true, preferred = true, visualUpdate = true, description</b>
<b class="nc"><i>2704</i>&nbsp;            = &quot;The enabled state of the component.&quot;)</b>
<b class="nc"><i>2705</i>&nbsp;    public void setEnabled(boolean enabled) {</b>
<i>2706</i>&nbsp;        boolean oldEnabled = isEnabled();
<b class="nc"><i>2707</i>&nbsp;        super.setEnabled(enabled);</b>
<i>2708</i>&nbsp;        firePropertyChange(&quot;enabled&quot;, oldEnabled, enabled);
<i>2709</i>&nbsp;        if (enabled != oldEnabled) {
<i>2710</i>&nbsp;            repaint();
<i>2711</i>&nbsp;        }
<i>2712</i>&nbsp;    }
<i>2713</i>&nbsp;
<i>2714</i>&nbsp;    /**
<i>2715</i>&nbsp;     * Sets the foreground color of this component.  It is up to the
<i>2716</i>&nbsp;     * look and feel to honor this property, some may choose to ignore
<i>2717</i>&nbsp;     * it.
<i>2718</i>&nbsp;     *
<i>2719</i>&nbsp;     * @param fg  the desired foreground &lt;code&gt;Color&lt;/code&gt;
<i>2720</i>&nbsp;     * @see java.awt.Component#getForeground
<i>2721</i>&nbsp;     */
<i>2722</i>&nbsp;    @BeanProperty(preferred = true, visualUpdate = true, description
<i>2723</i>&nbsp;            = &quot;The foreground color of the component.&quot;)
<i>2724</i>&nbsp;    public void setForeground(Color fg) {
<i>2725</i>&nbsp;        Color oldFg = getForeground();
<i>2726</i>&nbsp;        super.setForeground(fg);
<i>2727</i>&nbsp;        if ((oldFg != null) ? !oldFg.equals(fg) : ((fg != null) &amp;&amp; !fg.equals(oldFg))) {
<i>2728</i>&nbsp;            // foreground already bound in AWT1.2
<i>2729</i>&nbsp;            repaint();
<i>2730</i>&nbsp;        }
<i>2731</i>&nbsp;    }
<i>2732</i>&nbsp;
<b class="nc"><i>2733</i>&nbsp;    /**</b>
<b class="nc"><i>2734</i>&nbsp;     * Sets the background color of this component.  The background</b>
<b class="nc"><i>2735</i>&nbsp;     * color is used only if the component is opaque, and only</b>
<i>2736</i>&nbsp;     * by subclasses of &lt;code&gt;JComponent&lt;/code&gt; or
<b class="nc"><i>2737</i>&nbsp;     * &lt;code&gt;ComponentUI&lt;/code&gt; implementations.  Direct subclasses of</b>
<i>2738</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; must override
<i>2739</i>&nbsp;     * &lt;code&gt;paintComponent&lt;/code&gt; to honor this property.
<i>2740</i>&nbsp;     * &lt;p&gt;
<i>2741</i>&nbsp;     * It is up to the look and feel to honor this property, some may
<i>2742</i>&nbsp;     * choose to ignore it.
<i>2743</i>&nbsp;     *
<i>2744</i>&nbsp;     * @param bg the desired background &lt;code&gt;Color&lt;/code&gt;
<i>2745</i>&nbsp;     * @see java.awt.Component#getBackground
<i>2746</i>&nbsp;     * @see #setOpaque
<i>2747</i>&nbsp;     */
<i>2748</i>&nbsp;    @BeanProperty(preferred = true, visualUpdate = true, description
<i>2749</i>&nbsp;            = &quot;The background color of the component.&quot;)
<i>2750</i>&nbsp;    public void setBackground(Color bg) {
<i>2751</i>&nbsp;        Color oldBg = getBackground();
<i>2752</i>&nbsp;        super.setBackground(bg);
<i>2753</i>&nbsp;        if ((oldBg != null) ? !oldBg.equals(bg) : ((bg != null) &amp;&amp; !bg.equals(oldBg))) {
<b class="nc"><i>2754</i>&nbsp;            // background already bound in AWT1.2</b>
<b class="nc"><i>2755</i>&nbsp;            repaint();</b>
<i>2756</i>&nbsp;        }
<b class="nc"><i>2757</i>&nbsp;    }</b>
<b class="nc"><i>2758</i>&nbsp;</b>
<b class="nc"><i>2759</i>&nbsp;    /**</b>
<i>2760</i>&nbsp;     * Sets the font for this component.
<i>2761</i>&nbsp;     *
<i>2762</i>&nbsp;     * @param font the desired &lt;code&gt;Font&lt;/code&gt; for this component
<i>2763</i>&nbsp;     * @see java.awt.Component#getFont
<i>2764</i>&nbsp;     */
<i>2765</i>&nbsp;    @BeanProperty(preferred = true, visualUpdate = true, description
<i>2766</i>&nbsp;            = &quot;The font for the component.&quot;)
<i>2767</i>&nbsp;    public void setFont(Font font) {
<i>2768</i>&nbsp;        Font oldFont = getFont();
<i>2769</i>&nbsp;        super.setFont(font);
<i>2770</i>&nbsp;        // font already bound in AWT1.2
<i>2771</i>&nbsp;        if (font != oldFont) {
<i>2772</i>&nbsp;            revalidate();
<i>2773</i>&nbsp;            repaint();
<i>2774</i>&nbsp;        }
<i>2775</i>&nbsp;    }
<i>2776</i>&nbsp;
<i>2777</i>&nbsp;    /**
<i>2778</i>&nbsp;     * Returns the default locale used to initialize each JComponent&#39;s
<b class="nc"><i>2779</i>&nbsp;     * locale property upon creation.</b>
<b class="nc"><i>2780</i>&nbsp;     *</b>
<i>2781</i>&nbsp;     * The default locale has &quot;AppContext&quot; scope so that applets (and
<i>2782</i>&nbsp;     * potentially multiple lightweight applications running in a single VM)
<b class="nc"><i>2783</i>&nbsp;     * can have their own setting. An applet can safely alter its default</b>
<b class="nc"><i>2784</i>&nbsp;     * locale because it will have no affect on other applets (or the browser).</b>
<i>2785</i>&nbsp;     *
<b class="nc"><i>2786</i>&nbsp;     * @return the default &lt;code&gt;Locale&lt;/code&gt;.</b>
<i>2787</i>&nbsp;     * @see #setDefaultLocale
<i>2788</i>&nbsp;     * @see java.awt.Component#getLocale
<i>2789</i>&nbsp;     * @see #setLocale
<i>2790</i>&nbsp;     * @since 1.4
<i>2791</i>&nbsp;     */
<i>2792</i>&nbsp;    public static Locale getDefaultLocale() {
<i>2793</i>&nbsp;        Locale l = (Locale) SwingUtilities.appContextGet(defaultLocale);
<i>2794</i>&nbsp;        if( l == null ) {
<i>2795</i>&nbsp;            //REMIND(bcb) choosing the default value is more complicated
<i>2796</i>&nbsp;            //than this.
<i>2797</i>&nbsp;            l = Locale.getDefault();
<i>2798</i>&nbsp;            JComponent.setDefaultLocale( l );
<i>2799</i>&nbsp;        }
<i>2800</i>&nbsp;        return l;
<i>2801</i>&nbsp;    }
<i>2802</i>&nbsp;
<i>2803</i>&nbsp;
<i>2804</i>&nbsp;    /**
<i>2805</i>&nbsp;     * Sets the default locale used to initialize each JComponent&#39;s locale
<b class="nc"><i>2806</i>&nbsp;     * property upon creation.  The initial value is the VM&#39;s default locale.</b>
<i>2807</i>&nbsp;     *
<i>2808</i>&nbsp;     * The default locale has &quot;AppContext&quot; scope so that applets (and
<i>2809</i>&nbsp;     * potentially multiple lightweight applications running in a single VM)
<i>2810</i>&nbsp;     * can have their own setting. An applet can safely alter its default
<i>2811</i>&nbsp;     * locale because it will have no affect on other applets (or the browser).
<i>2812</i>&nbsp;     *
<i>2813</i>&nbsp;     * @param l the desired default &lt;code&gt;Locale&lt;/code&gt; for new components.
<i>2814</i>&nbsp;     * @see #getDefaultLocale
<i>2815</i>&nbsp;     * @see java.awt.Component#getLocale
<i>2816</i>&nbsp;     * @see #setLocale
<i>2817</i>&nbsp;     * @since 1.4
<i>2818</i>&nbsp;     */
<i>2819</i>&nbsp;    public static void setDefaultLocale( Locale l ) {
<i>2820</i>&nbsp;        SwingUtilities.appContextPut(defaultLocale, l);
<i>2821</i>&nbsp;    }
<i>2822</i>&nbsp;
<i>2823</i>&nbsp;
<i>2824</i>&nbsp;    /**
<i>2825</i>&nbsp;     * Processes any key events that the component itself
<i>2826</i>&nbsp;     * recognizes.  This is called after the focus
<i>2827</i>&nbsp;     * manager and any interested listeners have been
<i>2828</i>&nbsp;     * given a chance to steal away the event.  This
<i>2829</i>&nbsp;     * method is called only if the event has not
<i>2830</i>&nbsp;     * yet been consumed.  This method is called prior
<i>2831</i>&nbsp;     * to the keyboard UI logic.
<i>2832</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2833</i>&nbsp;     * This method is implemented to do nothing.  Subclasses would</b>
<i>2834</i>&nbsp;     * normally override this method if they process some
<i>2835</i>&nbsp;     * key events themselves.  If the event is processed,
<b class="nc"><i>2836</i>&nbsp;     * it should be consumed.</b>
<b class="nc"><i>2837</i>&nbsp;     *</b>
<i>2838</i>&nbsp;     * @param e the event to be processed
<i>2839</i>&nbsp;     */
<b class="nc"><i>2840</i>&nbsp;    protected void processComponentKeyEvent(KeyEvent e) {</b>
<i>2841</i>&nbsp;    }
<b class="nc"><i>2842</i>&nbsp;</b>
<i>2843</i>&nbsp;    /** Overrides &lt;code&gt;processKeyEvent&lt;/code&gt; to process events. **/
<i>2844</i>&nbsp;    protected void processKeyEvent(KeyEvent e) {
<i>2845</i>&nbsp;      boolean result;
<b class="nc"><i>2846</i>&nbsp;      boolean shouldProcessKey;</b>
<i>2847</i>&nbsp;
<b class="nc"><i>2848</i>&nbsp;      // This gives the key event listeners a crack at the event</b>
<i>2849</i>&nbsp;      super.processKeyEvent(e);
<i>2850</i>&nbsp;
<i>2851</i>&nbsp;      // give the component itself a crack at the event
<i>2852</i>&nbsp;      if (! e.isConsumed()) {
<i>2853</i>&nbsp;          processComponentKeyEvent(e);
<i>2854</i>&nbsp;      }
<i>2855</i>&nbsp;
<i>2856</i>&nbsp;      shouldProcessKey = KeyboardState.shouldProcess(e);
<i>2857</i>&nbsp;
<i>2858</i>&nbsp;      if(e.isConsumed()) {
<i>2859</i>&nbsp;        return;
<i>2860</i>&nbsp;      }
<i>2861</i>&nbsp;
<i>2862</i>&nbsp;      if (shouldProcessKey &amp;&amp; processKeyBindings(e, e.getID() ==
<i>2863</i>&nbsp;                                                 KeyEvent.KEY_PRESSED)) {
<i>2864</i>&nbsp;          e.consume();
<i>2865</i>&nbsp;      }
<i>2866</i>&nbsp;    }
<i>2867</i>&nbsp;
<i>2868</i>&nbsp;    /**
<i>2869</i>&nbsp;     * Invoked to process the key bindings for &lt;code&gt;ks&lt;/code&gt; as the result
<i>2870</i>&nbsp;     * of the &lt;code&gt;KeyEvent&lt;/code&gt; &lt;code&gt;e&lt;/code&gt;. This obtains
<i>2871</i>&nbsp;     * the appropriate &lt;code&gt;InputMap&lt;/code&gt;,
<i>2872</i>&nbsp;     * gets the binding, gets the action from the &lt;code&gt;ActionMap&lt;/code&gt;,
<i>2873</i>&nbsp;     * and then (if the action is found and the component
<i>2874</i>&nbsp;     * is enabled) invokes &lt;code&gt;notifyAction&lt;/code&gt; to notify the action.
<i>2875</i>&nbsp;     *
<b class="nc"><i>2876</i>&nbsp;     * @param ks  the &lt;code&gt;KeyStroke&lt;/code&gt; queried</b>
<b class="nc"><i>2877</i>&nbsp;     * @param e the &lt;code&gt;KeyEvent&lt;/code&gt;</b>
<i>2878</i>&nbsp;     * @param condition one of the following values:
<b class="nc"><i>2879</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>2880</i>&nbsp;     * &lt;li&gt;JComponent.WHEN_FOCUSED</b>
<b class="nc"><i>2881</i>&nbsp;     * &lt;li&gt;JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</b>
<b class="nc"><i>2882</i>&nbsp;     * &lt;li&gt;JComponent.WHEN_IN_FOCUSED_WINDOW</b>
<b class="nc"><i>2883</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>2884</i>&nbsp;     * @param pressed true if the key is pressed</b>
<i>2885</i>&nbsp;     * @return true if there was a binding to an action, and the action
<i>2886</i>&nbsp;     *         was enabled
<b class="nc"><i>2887</i>&nbsp;     *</b>
<i>2888</i>&nbsp;     * @since 1.3
<i>2889</i>&nbsp;     */
<i>2890</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>2891</i>&nbsp;    protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
<i>2892</i>&nbsp;                                        int condition, boolean pressed) {
<i>2893</i>&nbsp;        InputMap map = getInputMap(condition, false);
<i>2894</i>&nbsp;        ActionMap am = getActionMap(false);
<i>2895</i>&nbsp;
<i>2896</i>&nbsp;        if(map != null &amp;&amp; am != null &amp;&amp; isEnabled()) {
<i>2897</i>&nbsp;            Object binding = map.get(ks);
<i>2898</i>&nbsp;            Action action = (binding == null) ? null : am.get(binding);
<i>2899</i>&nbsp;            if (action != null) {
<i>2900</i>&nbsp;                return SwingUtilities.notifyAction(action, ks, e, this,
<i>2901</i>&nbsp;                                                   e.getModifiers());
<i>2902</i>&nbsp;            }
<b class="nc"><i>2903</i>&nbsp;        }</b>
<b class="nc"><i>2904</i>&nbsp;        return false;</b>
<i>2905</i>&nbsp;    }
<i>2906</i>&nbsp;
<i>2907</i>&nbsp;    /**
<i>2908</i>&nbsp;     * This is invoked as the result of a &lt;code&gt;KeyEvent&lt;/code&gt;
<i>2909</i>&nbsp;     * that was not consumed by the &lt;code&gt;FocusManager&lt;/code&gt;,
<b class="nc"><i>2910</i>&nbsp;     * &lt;code&gt;KeyListeners&lt;/code&gt;, or the component. It will first try</b>
<i>2911</i>&nbsp;     * &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings,
<b class="nc"><i>2912</i>&nbsp;     * then &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings,</b>
<b class="nc"><i>2913</i>&nbsp;     * and finally &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; bindings.</b>
<i>2914</i>&nbsp;     *
<i>2915</i>&nbsp;     * @param e the unconsumed &lt;code&gt;KeyEvent&lt;/code&gt;
<b class="nc"><i>2916</i>&nbsp;     * @param pressed true if the key is pressed</b>
<i>2917</i>&nbsp;     * @return true if there is a key binding for &lt;code&gt;e&lt;/code&gt;
<b class="nc"><i>2918</i>&nbsp;     */</b>
<b class="nc"><i>2919</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
<i>2920</i>&nbsp;    boolean processKeyBindings(KeyEvent e, boolean pressed) {
<i>2921</i>&nbsp;      if (!SwingUtilities.isValidKeyEventForKeyBindings(e)) {
<i>2922</i>&nbsp;          return false;
<i>2923</i>&nbsp;      }
<i>2924</i>&nbsp;      // Get the KeyStroke
<i>2925</i>&nbsp;      // There may be two keystrokes associated with a low-level key event;
<i>2926</i>&nbsp;      // in this case a keystroke made of an extended key code has a priority.
<b class="nc"><i>2927</i>&nbsp;      KeyStroke ks;</b>
<b class="nc"><i>2928</i>&nbsp;      KeyStroke ksE = null;</b>
<i>2929</i>&nbsp;
<b class="nc"><i>2930</i>&nbsp;      if (e.getID() == KeyEvent.KEY_TYPED) {</b>
<b class="nc"><i>2931</i>&nbsp;          ks = KeyStroke.getKeyStroke(e.getKeyChar());</b>
<i>2932</i>&nbsp;      }
<i>2933</i>&nbsp;      else {
<i>2934</i>&nbsp;          ks = KeyStroke.getKeyStroke(e.getKeyCode(),e.getModifiers(),
<i>2935</i>&nbsp;                                    (pressed ? false:true));
<i>2936</i>&nbsp;          if (e.getKeyCode() != e.getExtendedKeyCode()) {
<b class="nc"><i>2937</i>&nbsp;              ksE = KeyStroke.getKeyStroke(e.getExtendedKeyCode(),e.getModifiers(),</b>
<b class="nc"><i>2938</i>&nbsp;                                    (pressed ? false:true));</b>
<i>2939</i>&nbsp;          }
<b class="nc"><i>2940</i>&nbsp;      }</b>
<b class="nc"><i>2941</i>&nbsp;</b>
<i>2942</i>&nbsp;      // Do we have a key binding for e?
<b class="nc"><i>2943</i>&nbsp;      // If we have a binding by an extended code, use it.</b>
<b class="nc"><i>2944</i>&nbsp;      // If not, check for regular code binding.</b>
<i>2945</i>&nbsp;      if(ksE != null &amp;&amp; processKeyBinding(ksE, e, WHEN_FOCUSED, pressed)) {
<b class="nc"><i>2946</i>&nbsp;          return true;</b>
<i>2947</i>&nbsp;      }
<i>2948</i>&nbsp;      if(processKeyBinding(ks, e, WHEN_FOCUSED, pressed))
<i>2949</i>&nbsp;          return true;
<i>2950</i>&nbsp;
<i>2951</i>&nbsp;      /* We have no key binding. Let&#39;s try the path from our parent to the
<i>2952</i>&nbsp;       * window excluded. We store the path components so we can avoid
<i>2953</i>&nbsp;       * asking the same component twice.
<i>2954</i>&nbsp;       */
<b class="nc"><i>2955</i>&nbsp;      Container parent = this;</b>
<b class="nc"><i>2956</i>&nbsp;      while (parent != null &amp;&amp; !(parent instanceof Window) &amp;&amp;</b>
<b class="nc"><i>2957</i>&nbsp;             !(parent instanceof Applet)) {</b>
<i>2958</i>&nbsp;          if(parent instanceof JComponent) {
<b class="nc"><i>2959</i>&nbsp;              if(ksE != null &amp;&amp; ((JComponent)parent).processKeyBinding(ksE, e,</b>
<i>2960</i>&nbsp;                               WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, pressed))
<i>2961</i>&nbsp;                  return true;
<i>2962</i>&nbsp;              if(((JComponent)parent).processKeyBinding(ks, e,
<i>2963</i>&nbsp;                               WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, pressed))
<i>2964</i>&nbsp;                  return true;
<i>2965</i>&nbsp;          }
<b class="nc"><i>2966</i>&nbsp;          // This is done so that the children of a JInternalFrame are</b>
<b class="nc"><i>2967</i>&nbsp;          // given precedence for WHEN_IN_FOCUSED_WINDOW bindings before</b>
<i>2968</i>&nbsp;          // other components WHEN_IN_FOCUSED_WINDOW bindings. This also gives
<b class="nc"><i>2969</i>&nbsp;          // more precedence to the WHEN_IN_FOCUSED_WINDOW bindings of the</b>
<i>2970</i>&nbsp;          // JInternalFrame&#39;s children vs the
<i>2971</i>&nbsp;          // WHEN_ANCESTOR_OF_FOCUSED_COMPONENT bindings of the parents.
<i>2972</i>&nbsp;          // maybe generalize from JInternalFrame (like isFocusCycleRoot).
<i>2973</i>&nbsp;          if ((parent instanceof JInternalFrame) &amp;&amp;
<i>2974</i>&nbsp;              JComponent.processKeyBindingsForAllComponents(e,parent,pressed)){
<b class="nc"><i>2975</i>&nbsp;              return true;</b>
<i>2976</i>&nbsp;          }
<b class="nc"><i>2977</i>&nbsp;          parent = parent.getParent();</b>
<i>2978</i>&nbsp;      }
<b class="nc"><i>2979</i>&nbsp;</b>
<b class="nc"><i>2980</i>&nbsp;      /* No components between the focused component and the window is</b>
<i>2981</i>&nbsp;       * actually interested by the key event. Let&#39;s try the other
<i>2982</i>&nbsp;       * JComponent in this window.
<b class="nc"><i>2983</i>&nbsp;       */</b>
<i>2984</i>&nbsp;      if(parent != null) {
<i>2985</i>&nbsp;        return JComponent.processKeyBindingsForAllComponents(e,parent,pressed);
<i>2986</i>&nbsp;      }
<i>2987</i>&nbsp;      return false;
<i>2988</i>&nbsp;    }
<i>2989</i>&nbsp;
<i>2990</i>&nbsp;    static boolean processKeyBindingsForAllComponents(KeyEvent e,
<i>2991</i>&nbsp;                                      Container container, boolean pressed) {
<i>2992</i>&nbsp;        while (true) {
<i>2993</i>&nbsp;            if (KeyboardManager.getCurrentManager().fireKeyboardAction(
<i>2994</i>&nbsp;                                e, pressed, container)) {
<i>2995</i>&nbsp;                return true;
<i>2996</i>&nbsp;            }
<i>2997</i>&nbsp;            if (container instanceof Popup.HeavyWeightWindow) {
<i>2998</i>&nbsp;                container = ((Window)container).getOwner();
<i>2999</i>&nbsp;            }
<i>3000</i>&nbsp;            else {
<i>3001</i>&nbsp;                return false;
<i>3002</i>&nbsp;            }
<i>3003</i>&nbsp;        }
<b class="nc"><i>3004</i>&nbsp;    }</b>
<b class="nc"><i>3005</i>&nbsp;</b>
<b class="nc"><i>3006</i>&nbsp;    /**</b>
<b class="nc"><i>3007</i>&nbsp;     * Registers the text to display in a tool tip.</b>
<b class="nc"><i>3008</i>&nbsp;     * The text displays when the cursor lingers over the component.</b>
<b class="nc"><i>3009</i>&nbsp;     * &lt;p&gt;</b>
<i>3010</i>&nbsp;     * See &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tooltip.html&quot;&gt;How to Use Tool Tips&lt;/a&gt;
<i>3011</i>&nbsp;     * in &lt;em&gt;The Java Tutorial&lt;/em&gt;
<b class="nc"><i>3012</i>&nbsp;     * for further documentation.</b>
<i>3013</i>&nbsp;     *
<i>3014</i>&nbsp;     * @param text  the string to display; if the text is &lt;code&gt;null&lt;/code&gt;,
<i>3015</i>&nbsp;     *              the tool tip is turned off for this component
<i>3016</i>&nbsp;     * @see #TOOL_TIP_TEXT_KEY
<i>3017</i>&nbsp;     */
<i>3018</i>&nbsp;    @BeanProperty(bound = false, preferred = true, description
<i>3019</i>&nbsp;            = &quot;The text to display in a tool tip.&quot;)
<i>3020</i>&nbsp;    public void setToolTipText(String text) {
<i>3021</i>&nbsp;        String oldText = getToolTipText();
<i>3022</i>&nbsp;        putClientProperty(TOOL_TIP_TEXT_KEY, text);
<i>3023</i>&nbsp;        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
<b class="nc"><i>3024</i>&nbsp;        if (text != null) {</b>
<i>3025</i>&nbsp;            if (oldText == null) {
<i>3026</i>&nbsp;                toolTipManager.registerComponent(this);
<i>3027</i>&nbsp;            }
<i>3028</i>&nbsp;        } else {
<i>3029</i>&nbsp;            toolTipManager.unregisterComponent(this);
<i>3030</i>&nbsp;        }
<i>3031</i>&nbsp;    }
<i>3032</i>&nbsp;
<i>3033</i>&nbsp;    /**
<i>3034</i>&nbsp;     * Returns the tooltip string that has been set with
<i>3035</i>&nbsp;     * &lt;code&gt;setToolTipText&lt;/code&gt;.
<b class="nc"><i>3036</i>&nbsp;     *</b>
<i>3037</i>&nbsp;     * @return the text of the tool tip
<i>3038</i>&nbsp;     * @see #TOOL_TIP_TEXT_KEY
<i>3039</i>&nbsp;     */
<i>3040</i>&nbsp;    public String getToolTipText() {
<i>3041</i>&nbsp;        return (String)getClientProperty(TOOL_TIP_TEXT_KEY);
<i>3042</i>&nbsp;    }
<i>3043</i>&nbsp;
<i>3044</i>&nbsp;
<i>3045</i>&nbsp;    /**
<i>3046</i>&nbsp;     * Returns the string to be used as the tooltip for &lt;i&gt;event&lt;/i&gt;.
<i>3047</i>&nbsp;     * By default this returns any string set using
<i>3048</i>&nbsp;     * &lt;code&gt;setToolTipText&lt;/code&gt;.  If a component provides
<b class="nc"><i>3049</i>&nbsp;     * more extensive API to support differing tooltips at different locations,</b>
<i>3050</i>&nbsp;     * this method should be overridden.
<i>3051</i>&nbsp;     *
<i>3052</i>&nbsp;     * @param event the {@code MouseEvent} that initiated the
<i>3053</i>&nbsp;     *              {@code ToolTip} display
<i>3054</i>&nbsp;     * @return a string containing the  tooltip
<i>3055</i>&nbsp;     */
<i>3056</i>&nbsp;    public String getToolTipText(MouseEvent event) {
<i>3057</i>&nbsp;        return getToolTipText();
<i>3058</i>&nbsp;    }
<i>3059</i>&nbsp;
<i>3060</i>&nbsp;    /**
<i>3061</i>&nbsp;     * Returns the tooltip location in this component&#39;s coordinate system.
<i>3062</i>&nbsp;     * If &lt;code&gt;null&lt;/code&gt; is returned, Swing will choose a location.
<i>3063</i>&nbsp;     * The default implementation returns &lt;code&gt;null&lt;/code&gt;.
<i>3064</i>&nbsp;     *
<b class="nc"><i>3065</i>&nbsp;     * @param event  the &lt;code&gt;MouseEvent&lt;/code&gt; that caused the</b>
<i>3066</i>&nbsp;     *          &lt;code&gt;ToolTipManager&lt;/code&gt; to show the tooltip
<i>3067</i>&nbsp;     * @return always returns &lt;code&gt;null&lt;/code&gt;
<i>3068</i>&nbsp;     */
<i>3069</i>&nbsp;    public Point getToolTipLocation(MouseEvent event) {
<i>3070</i>&nbsp;        return null;
<i>3071</i>&nbsp;    }
<i>3072</i>&nbsp;
<i>3073</i>&nbsp;    /**
<i>3074</i>&nbsp;     * Returns the preferred location to display the popup menu in this
<i>3075</i>&nbsp;     * component&#39;s coordinate system. It is up to the look and feel to
<i>3076</i>&nbsp;     * honor this property, some may choose to ignore it.
<i>3077</i>&nbsp;     * If {@code null}, the look and feel will choose a suitable location.
<i>3078</i>&nbsp;     *
<b class="nc"><i>3079</i>&nbsp;     * @param event the {@code MouseEvent} that triggered the popup to be</b>
<b class="nc"><i>3080</i>&nbsp;     *        shown, or {@code null} if the popup is not being shown as the</b>
<b class="nc"><i>3081</i>&nbsp;     *        result of a mouse event</b>
<i>3082</i>&nbsp;     * @return location to display the {@code JPopupMenu}, or {@code null}
<i>3083</i>&nbsp;     * @since 1.5
<i>3084</i>&nbsp;     */
<i>3085</i>&nbsp;    public Point getPopupLocation(MouseEvent event) {
<i>3086</i>&nbsp;        return null;
<i>3087</i>&nbsp;    }
<i>3088</i>&nbsp;
<i>3089</i>&nbsp;
<i>3090</i>&nbsp;    /**
<i>3091</i>&nbsp;     * Returns the instance of &lt;code&gt;JToolTip&lt;/code&gt; that should be used
<i>3092</i>&nbsp;     * to display the tooltip.
<i>3093</i>&nbsp;     * Components typically would not override this method,
<i>3094</i>&nbsp;     * but it can be used to
<b class="nc"><i>3095</i>&nbsp;     * cause different tooltips to be displayed differently.</b>
<i>3096</i>&nbsp;     *
<b class="nc"><i>3097</i>&nbsp;     * @return the &lt;code&gt;JToolTip&lt;/code&gt; used to display this toolTip</b>
<i>3098</i>&nbsp;     */
<b class="nc"><i>3099</i>&nbsp;    public JToolTip createToolTip() {</b>
<i>3100</i>&nbsp;        JToolTip tip = new JToolTip();
<b class="nc"><i>3101</i>&nbsp;        tip.setComponent(this);</b>
<b class="nc"><i>3102</i>&nbsp;        return tip;</b>
<i>3103</i>&nbsp;    }
<b class="nc"><i>3104</i>&nbsp;</b>
<b class="nc"><i>3105</i>&nbsp;    /**</b>
<i>3106</i>&nbsp;     * Forwards the &lt;code&gt;scrollRectToVisible()&lt;/code&gt; message to the
<i>3107</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt;&#39;s parent. Components that can service
<b class="nc"><i>3108</i>&nbsp;     * the request, such as &lt;code&gt;JViewport&lt;/code&gt;,</b>
<b class="nc"><i>3109</i>&nbsp;     * override this method and perform the scrolling.</b>
<b class="nc"><i>3110</i>&nbsp;     *</b>
<i>3111</i>&nbsp;     * @param aRect the visible &lt;code&gt;Rectangle&lt;/code&gt;
<b class="nc"><i>3112</i>&nbsp;     * @see JViewport</b>
<b class="nc"><i>3113</i>&nbsp;     */</b>
<b class="nc"><i>3114</i>&nbsp;    public void scrollRectToVisible(Rectangle aRect) {</b>
<i>3115</i>&nbsp;        Container parent;
<i>3116</i>&nbsp;        int dx = getX(), dy = getY();
<i>3117</i>&nbsp;
<i>3118</i>&nbsp;        for (parent = getParent();
<i>3119</i>&nbsp;                 !(parent == null) &amp;&amp;
<i>3120</i>&nbsp;                 !(parent instanceof JComponent) &amp;&amp;
<i>3121</i>&nbsp;                 !(parent instanceof CellRendererPane);
<i>3122</i>&nbsp;             parent = parent.getParent()) {
<i>3123</i>&nbsp;             Rectangle bounds = parent.getBounds();
<i>3124</i>&nbsp;
<i>3125</i>&nbsp;             dx += bounds.x;
<i>3126</i>&nbsp;             dy += bounds.y;
<i>3127</i>&nbsp;        }
<i>3128</i>&nbsp;
<i>3129</i>&nbsp;        if (!(parent == null) &amp;&amp; !(parent instanceof CellRendererPane)) {
<i>3130</i>&nbsp;            aRect.x += dx;
<i>3131</i>&nbsp;            aRect.y += dy;
<i>3132</i>&nbsp;
<i>3133</i>&nbsp;            ((JComponent)parent).scrollRectToVisible(aRect);
<i>3134</i>&nbsp;            aRect.x -= dx;
<i>3135</i>&nbsp;            aRect.y -= dy;
<i>3136</i>&nbsp;        }
<i>3137</i>&nbsp;    }
<i>3138</i>&nbsp;
<i>3139</i>&nbsp;    /**
<i>3140</i>&nbsp;     * Sets the &lt;code&gt;autoscrolls&lt;/code&gt; property.
<i>3141</i>&nbsp;     * If &lt;code&gt;true&lt;/code&gt; mouse dragged events will be
<i>3142</i>&nbsp;     * synthetically generated when the mouse is dragged
<i>3143</i>&nbsp;     * outside of the component&#39;s bounds and mouse motion
<i>3144</i>&nbsp;     * has paused (while the button continues to be held
<i>3145</i>&nbsp;     * down). The synthetic events make it appear that the
<i>3146</i>&nbsp;     * drag gesture has resumed in the direction established when
<i>3147</i>&nbsp;     * the component&#39;s boundary was crossed.  Components that
<i>3148</i>&nbsp;     * support autoscrolling must handle &lt;code&gt;mouseDragged&lt;/code&gt;
<i>3149</i>&nbsp;     * events by calling &lt;code&gt;scrollRectToVisible&lt;/code&gt; with a
<i>3150</i>&nbsp;     * rectangle that contains the mouse event&#39;s location.  All of
<i>3151</i>&nbsp;     * the Swing components that support item selection and are
<i>3152</i>&nbsp;     * typically displayed in a &lt;code&gt;JScrollPane&lt;/code&gt;
<i>3153</i>&nbsp;     * (&lt;code&gt;JTable&lt;/code&gt;, &lt;code&gt;JList&lt;/code&gt;, &lt;code&gt;JTree&lt;/code&gt;,
<i>3154</i>&nbsp;     * &lt;code&gt;JTextArea&lt;/code&gt;, and &lt;code&gt;JEditorPane&lt;/code&gt;)
<i>3155</i>&nbsp;     * already handle mouse dragged events in this way.  To enable
<i>3156</i>&nbsp;     * autoscrolling in any other component, add a mouse motion
<i>3157</i>&nbsp;     * listener that calls &lt;code&gt;scrollRectToVisible&lt;/code&gt;.
<i>3158</i>&nbsp;     * For example, given a &lt;code&gt;JPanel&lt;/code&gt;, &lt;code&gt;myPanel&lt;/code&gt;:
<i>3159</i>&nbsp;     * &lt;pre&gt;
<i>3160</i>&nbsp;     * MouseMotionListener doScrollRectToVisible = new MouseMotionAdapter() {
<i>3161</i>&nbsp;     *     public void mouseDragged(MouseEvent e) {
<i>3162</i>&nbsp;     *        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
<b class="nc"><i>3163</i>&nbsp;     *        ((JPanel)e.getSource()).scrollRectToVisible(r);</b>
<b class="nc"><i>3164</i>&nbsp;     *    }</b>
<b class="nc"><i>3165</i>&nbsp;     * };</b>
<b class="nc"><i>3166</i>&nbsp;     * myPanel.addMouseMotionListener(doScrollRectToVisible);</b>
<b class="nc"><i>3167</i>&nbsp;     * &lt;/pre&gt;</b>
<b class="nc"><i>3168</i>&nbsp;     * The default value of the &lt;code&gt;autoScrolls&lt;/code&gt;</b>
<i>3169</i>&nbsp;     * property is &lt;code&gt;false&lt;/code&gt;.
<i>3170</i>&nbsp;     *
<b class="nc"><i>3171</i>&nbsp;     * @param autoscrolls if true, synthetic mouse dragged events</b>
<i>3172</i>&nbsp;     *   are generated when the mouse is dragged outside of a component&#39;s
<i>3173</i>&nbsp;     *   bounds and the mouse button continues to be held down; otherwise
<i>3174</i>&nbsp;     *   false
<i>3175</i>&nbsp;     * @see #getAutoscrolls
<i>3176</i>&nbsp;     * @see JViewport
<i>3177</i>&nbsp;     * @see JScrollPane
<i>3178</i>&nbsp;     */
<i>3179</i>&nbsp;    @BeanProperty(bound = false, expert = true, description
<i>3180</i>&nbsp;            = &quot;Determines if this component automatically scrolls its contents when dragged.&quot;)
<i>3181</i>&nbsp;    public void setAutoscrolls(boolean autoscrolls) {
<i>3182</i>&nbsp;        setFlag(AUTOSCROLLS_SET, true);
<i>3183</i>&nbsp;        if (this.autoscrolls != autoscrolls) {
<b class="nc"><i>3184</i>&nbsp;            this.autoscrolls = autoscrolls;</b>
<i>3185</i>&nbsp;            if (autoscrolls) {
<i>3186</i>&nbsp;                enableEvents(AWTEvent.MOUSE_EVENT_MASK);
<i>3187</i>&nbsp;                enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);
<i>3188</i>&nbsp;            }
<i>3189</i>&nbsp;            else {
<i>3190</i>&nbsp;                Autoscroller.stop(this);
<i>3191</i>&nbsp;            }
<i>3192</i>&nbsp;        }
<i>3193</i>&nbsp;    }
<i>3194</i>&nbsp;
<i>3195</i>&nbsp;    /**
<i>3196</i>&nbsp;     * Gets the &lt;code&gt;autoscrolls&lt;/code&gt; property.
<i>3197</i>&nbsp;     *
<i>3198</i>&nbsp;     * @return the value of the &lt;code&gt;autoscrolls&lt;/code&gt; property
<i>3199</i>&nbsp;     * @see JViewport
<i>3200</i>&nbsp;     * @see #setAutoscrolls
<i>3201</i>&nbsp;     */
<i>3202</i>&nbsp;    public boolean getAutoscrolls() {
<i>3203</i>&nbsp;        return autoscrolls;
<i>3204</i>&nbsp;    }
<i>3205</i>&nbsp;
<i>3206</i>&nbsp;    /**
<i>3207</i>&nbsp;     * Sets the {@code TransferHandler}, which provides support for transfer
<i>3208</i>&nbsp;     * of data into and out of this component via cut/copy/paste and drag
<i>3209</i>&nbsp;     * and drop. This may be {@code null} if the component does not support
<i>3210</i>&nbsp;     * data transfer operations.
<i>3211</i>&nbsp;     * &lt;p&gt;
<i>3212</i>&nbsp;     * If the new {@code TransferHandler} is not {@code null}, this method
<i>3213</i>&nbsp;     * also installs a &lt;b&gt;new&lt;/b&gt; {@code DropTarget} on the component to
<i>3214</i>&nbsp;     * activate drop handling through the {@code TransferHandler} and activate
<i>3215</i>&nbsp;     * any built-in support (such as calculating and displaying potential drop
<i>3216</i>&nbsp;     * locations). If you do not wish for this component to respond in any way
<i>3217</i>&nbsp;     * to drops, you can disable drop support entirely either by removing the
<i>3218</i>&nbsp;     * drop target ({@code setDropTarget(null)}) or by de-activating it
<i>3219</i>&nbsp;     * ({@code getDropTaget().setActive(false)}).
<i>3220</i>&nbsp;     * &lt;p&gt;
<i>3221</i>&nbsp;     * If the new {@code TransferHandler} is {@code null}, this method removes
<i>3222</i>&nbsp;     * the drop target.
<i>3223</i>&nbsp;     * &lt;p&gt;
<i>3224</i>&nbsp;     * Under two circumstances, this method does not modify the drop target:
<i>3225</i>&nbsp;     * First, if the existing drop target on this component was explicitly
<i>3226</i>&nbsp;     * set by the developer to a {@code non-null} value. Second, if the
<b class="nc"><i>3227</i>&nbsp;     * system property {@code suppressSwingDropSupport} is {@code true}. The</b>
<i>3228</i>&nbsp;     * default value for the system property is {@code false}.
<b class="nc"><i>3229</i>&nbsp;     * &lt;p&gt;</b>
<i>3230</i>&nbsp;     * Please see
<b class="nc"><i>3231</i>&nbsp;     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html&quot;&gt;</b>
<b class="nc"><i>3232</i>&nbsp;     * How to Use Drag and Drop and Data Transfer&lt;/a&gt;,</b>
<i>3233</i>&nbsp;     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, for more information.
<i>3234</i>&nbsp;     *
<i>3235</i>&nbsp;     * @param newHandler the new {@code TransferHandler}
<i>3236</i>&nbsp;     *
<i>3237</i>&nbsp;     * @see TransferHandler
<i>3238</i>&nbsp;     * @see #getTransferHandler
<i>3239</i>&nbsp;     * @since 1.4
<i>3240</i>&nbsp;     */
<i>3241</i>&nbsp;    @BeanProperty(hidden = true, description
<i>3242</i>&nbsp;            = &quot;Mechanism for transfer of data to and from the component&quot;)
<i>3243</i>&nbsp;    public void setTransferHandler(TransferHandler newHandler) {
<i>3244</i>&nbsp;        TransferHandler oldHandler = (TransferHandler)getClientProperty(
<b class="nc"><i>3245</i>&nbsp;                                      JComponent_TRANSFER_HANDLER);</b>
<i>3246</i>&nbsp;        putClientProperty(JComponent_TRANSFER_HANDLER, newHandler);
<i>3247</i>&nbsp;
<i>3248</i>&nbsp;        SwingUtilities.installSwingDropTargetAsNecessary(this, newHandler);
<i>3249</i>&nbsp;        firePropertyChange(&quot;transferHandler&quot;, oldHandler, newHandler);
<i>3250</i>&nbsp;    }
<i>3251</i>&nbsp;
<i>3252</i>&nbsp;    /**
<i>3253</i>&nbsp;     * Gets the &lt;code&gt;transferHandler&lt;/code&gt; property.
<i>3254</i>&nbsp;     *
<i>3255</i>&nbsp;     * @return  the value of the &lt;code&gt;transferHandler&lt;/code&gt; property
<i>3256</i>&nbsp;     *
<i>3257</i>&nbsp;     * @see TransferHandler
<i>3258</i>&nbsp;     * @see #setTransferHandler
<i>3259</i>&nbsp;     * @since 1.4
<b class="nc"><i>3260</i>&nbsp;     */</b>
<i>3261</i>&nbsp;    public TransferHandler getTransferHandler() {
<i>3262</i>&nbsp;        return (TransferHandler)getClientProperty(JComponent_TRANSFER_HANDLER);
<i>3263</i>&nbsp;    }
<i>3264</i>&nbsp;
<i>3265</i>&nbsp;    /**
<i>3266</i>&nbsp;     * Calculates a custom drop location for this type of component,
<i>3267</i>&nbsp;     * representing where a drop at the given point should insert data.
<i>3268</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; is returned if this component doesn&#39;t calculate
<i>3269</i>&nbsp;     * custom drop locations. In this case, &lt;code&gt;TransferHandler&lt;/code&gt;
<i>3270</i>&nbsp;     * will provide a default &lt;code&gt;DropLocation&lt;/code&gt; containing just
<i>3271</i>&nbsp;     * the point.
<i>3272</i>&nbsp;     *
<i>3273</i>&nbsp;     * @param p the point to calculate a drop location for
<i>3274</i>&nbsp;     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
<i>3275</i>&nbsp;     */
<i>3276</i>&nbsp;    TransferHandler.DropLocation dropLocationForPoint(Point p) {
<i>3277</i>&nbsp;        return null;
<i>3278</i>&nbsp;    }
<i>3279</i>&nbsp;
<i>3280</i>&nbsp;    /**
<i>3281</i>&nbsp;     * Called to set or clear the drop location during a DnD operation.
<i>3282</i>&nbsp;     * In some cases, the component may need to use its internal selection
<i>3283</i>&nbsp;     * temporarily to indicate the drop location. To help facilitate this,
<i>3284</i>&nbsp;     * this method returns and accepts as a parameter a state object.
<i>3285</i>&nbsp;     * This state object can be used to store, and later restore, the selection
<i>3286</i>&nbsp;     * state. Whatever this method returns will be passed back to it in
<i>3287</i>&nbsp;     * future calls, as the state parameter. If it wants the DnD system to
<i>3288</i>&nbsp;     * continue storing the same state, it must pass it back every time.
<i>3289</i>&nbsp;     * Here&#39;s how this is used:
<i>3290</i>&nbsp;     * &lt;p&gt;
<i>3291</i>&nbsp;     * Let&#39;s say that on the first call to this method the component decides
<i>3292</i>&nbsp;     * to save some state (because it is about to use the selection to show
<i>3293</i>&nbsp;     * a drop index). It can return a state object to the caller encapsulating
<i>3294</i>&nbsp;     * any saved selection state. On a second call, let&#39;s say the drop location
<i>3295</i>&nbsp;     * is being changed to something else. The component doesn&#39;t need to
<i>3296</i>&nbsp;     * restore anything yet, so it simply passes back the same state object
<i>3297</i>&nbsp;     * to have the DnD system continue storing it. Finally, let&#39;s say this
<i>3298</i>&nbsp;     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
<i>3299</i>&nbsp;     * is finished with this component for now, meaning it should restore
<b class="nc"><i>3300</i>&nbsp;     * state. At this point, it can use the state parameter to restore</b>
<i>3301</i>&nbsp;     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there&#39;s
<i>3302</i>&nbsp;     * no longer anything to store.
<i>3303</i>&nbsp;     *
<i>3304</i>&nbsp;     * @param location the drop location (as calculated by
<i>3305</i>&nbsp;     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
<i>3306</i>&nbsp;     *        if there&#39;s no longer a valid drop location
<i>3307</i>&nbsp;     * @param state the state object saved earlier for this component,
<i>3308</i>&nbsp;     *        or &lt;code&gt;null&lt;/code&gt;
<i>3309</i>&nbsp;     * @param forDrop whether or not the method is being called because an
<i>3310</i>&nbsp;     *        actual drop occurred
<i>3311</i>&nbsp;     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
<i>3312</i>&nbsp;     */
<i>3313</i>&nbsp;    Object setDropLocation(TransferHandler.DropLocation location,
<i>3314</i>&nbsp;                           Object state,
<i>3315</i>&nbsp;                           boolean forDrop) {
<i>3316</i>&nbsp;
<i>3317</i>&nbsp;        return null;
<i>3318</i>&nbsp;    }
<i>3319</i>&nbsp;
<i>3320</i>&nbsp;    /**
<i>3321</i>&nbsp;     * Called to indicate to this component that DnD is done.
<b class="nc"><i>3322</i>&nbsp;     * Needed by &lt;code&gt;JTree&lt;/code&gt;.</b>
<b class="nc"><i>3323</i>&nbsp;     */</b>
<i>3324</i>&nbsp;    void dndDone() {
<b class="nc"><i>3325</i>&nbsp;    }</b>
<i>3326</i>&nbsp;
<i>3327</i>&nbsp;    /**
<i>3328</i>&nbsp;     * Processes mouse events occurring on this component by
<i>3329</i>&nbsp;     * dispatching them to any registered
<i>3330</i>&nbsp;     * &lt;code&gt;MouseListener&lt;/code&gt; objects, refer to
<i>3331</i>&nbsp;     * {@link java.awt.Component#processMouseEvent(MouseEvent)}
<i>3332</i>&nbsp;     * for a complete description of this method.
<i>3333</i>&nbsp;     *
<i>3334</i>&nbsp;     * @param       e the mouse event
<b class="nc"><i>3335</i>&nbsp;     * @see         java.awt.Component#processMouseEvent</b>
<b class="nc"><i>3336</i>&nbsp;     * @since       1.5</b>
<i>3337</i>&nbsp;     */
<i>3338</i>&nbsp;    protected void processMouseEvent(MouseEvent e) {
<b class="nc"><i>3339</i>&nbsp;        if (autoscrolls &amp;&amp; e.getID() == MouseEvent.MOUSE_RELEASED) {</b>
<b class="nc"><i>3340</i>&nbsp;            Autoscroller.stop(this);</b>
<i>3341</i>&nbsp;        }
<b class="nc"><i>3342</i>&nbsp;        super.processMouseEvent(e);</b>
<b class="nc"><i>3343</i>&nbsp;    }</b>
<i>3344</i>&nbsp;
<i>3345</i>&nbsp;    /**
<i>3346</i>&nbsp;     * Processes mouse motion events, such as MouseEvent.MOUSE_DRAGGED.
<i>3347</i>&nbsp;     *
<i>3348</i>&nbsp;     * @param e the &lt;code&gt;MouseEvent&lt;/code&gt;
<b class="nc"><i>3349</i>&nbsp;     * @see MouseEvent</b>
<i>3350</i>&nbsp;     */
<i>3351</i>&nbsp;    protected void processMouseMotionEvent(MouseEvent e) {
<i>3352</i>&nbsp;        boolean dispatch = true;
<i>3353</i>&nbsp;        if (autoscrolls &amp;&amp; e.getID() == MouseEvent.MOUSE_DRAGGED) {
<i>3354</i>&nbsp;            // We don&#39;t want to do the drags when the mouse moves if we&#39;re
<i>3355</i>&nbsp;            // autoscrolling.  It makes it feel spastic.
<i>3356</i>&nbsp;            dispatch = !Autoscroller.isRunning(this);
<i>3357</i>&nbsp;            Autoscroller.processMouseDragged(e);
<i>3358</i>&nbsp;        }
<b class="nc"><i>3359</i>&nbsp;        if (dispatch) {</b>
<i>3360</i>&nbsp;            super.processMouseMotionEvent(e);
<i>3361</i>&nbsp;        }
<i>3362</i>&nbsp;    }
<i>3363</i>&nbsp;
<i>3364</i>&nbsp;    // Inner classes can&#39;t get at this method from a super class
<i>3365</i>&nbsp;    void superProcessMouseMotionEvent(MouseEvent e) {
<i>3366</i>&nbsp;        super.processMouseMotionEvent(e);
<i>3367</i>&nbsp;    }
<i>3368</i>&nbsp;
<b class="nc"><i>3369</i>&nbsp;    /**</b>
<i>3370</i>&nbsp;     * This is invoked by the &lt;code&gt;RepaintManager&lt;/code&gt; if
<i>3371</i>&nbsp;     * &lt;code&gt;createImage&lt;/code&gt; is called on the component.
<i>3372</i>&nbsp;     *
<i>3373</i>&nbsp;     * @param newValue true if the double buffer image was created from this component
<i>3374</i>&nbsp;     */
<i>3375</i>&nbsp;    void setCreatedDoubleBuffer(boolean newValue) {
<i>3376</i>&nbsp;        setFlag(CREATED_DOUBLE_BUFFER, newValue);
<b class="nc"><i>3377</i>&nbsp;    }</b>
<i>3378</i>&nbsp;
<i>3379</i>&nbsp;    /**
<i>3380</i>&nbsp;     * Returns true if the &lt;code&gt;RepaintManager&lt;/code&gt;
<i>3381</i>&nbsp;     * created the double buffer image from the component.
<i>3382</i>&nbsp;     *
<b class="nc"><i>3383</i>&nbsp;     * @return true if this component had a double buffer image, false otherwise</b>
<b class="nc"><i>3384</i>&nbsp;     */</b>
<b class="nc"><i>3385</i>&nbsp;    boolean getCreatedDoubleBuffer() {</b>
<b class="nc"><i>3386</i>&nbsp;        return getFlag(CREATED_DOUBLE_BUFFER);</b>
<i>3387</i>&nbsp;    }
<i>3388</i>&nbsp;
<b class="nc"><i>3389</i>&nbsp;    /**</b>
<i>3390</i>&nbsp;     * &lt;code&gt;ActionStandin&lt;/code&gt; is used as a standin for
<b class="nc"><i>3391</i>&nbsp;     * &lt;code&gt;ActionListeners&lt;/code&gt; that are</b>
<i>3392</i>&nbsp;     * added via &lt;code&gt;registerKeyboardAction&lt;/code&gt;.
<i>3393</i>&nbsp;     */
<i>3394</i>&nbsp;    final class ActionStandin implements Action {
<b class="nc"><i>3395</i>&nbsp;        private final ActionListener actionListener;</b>
<b class="nc"><i>3396</i>&nbsp;        private final String command;</b>
<b class="nc"><i>3397</i>&nbsp;        // This will be non-null if actionListener is an Action.</b>
<i>3398</i>&nbsp;        private final Action action;
<b class="nc"><i>3399</i>&nbsp;</b>
<b class="nc"><i>3400</i>&nbsp;        ActionStandin(ActionListener actionListener, String command) {</b>
<i>3401</i>&nbsp;            this.actionListener = actionListener;
<b class="nc"><i>3402</i>&nbsp;            if (actionListener instanceof Action) {</b>
<b class="nc"><i>3403</i>&nbsp;                this.action = (Action)actionListener;</b>
<i>3404</i>&nbsp;            }
<i>3405</i>&nbsp;            else {
<b class="nc"><i>3406</i>&nbsp;                this.action = null;</b>
<i>3407</i>&nbsp;            }
<i>3408</i>&nbsp;            this.command = command;
<i>3409</i>&nbsp;        }
<b class="nc"><i>3410</i>&nbsp;</b>
<i>3411</i>&nbsp;        public Object getValue(String key) {
<i>3412</i>&nbsp;            if (key != null) {
<i>3413</i>&nbsp;                if (key.equals(Action.ACTION_COMMAND_KEY)) {
<i>3414</i>&nbsp;                    return command;
<i>3415</i>&nbsp;                }
<b class="nc"><i>3416</i>&nbsp;                if (action != null) {</b>
<i>3417</i>&nbsp;                    return action.getValue(key);
<b class="nc"><i>3418</i>&nbsp;                }</b>
<b class="nc"><i>3419</i>&nbsp;                if (key.equals(NAME)) {</b>
<i>3420</i>&nbsp;                    return &quot;ActionStandin&quot;;
<b class="nc"><i>3421</i>&nbsp;                }</b>
<i>3422</i>&nbsp;            }
<i>3423</i>&nbsp;            return null;
<i>3424</i>&nbsp;        }
<b class="nc"><i>3425</i>&nbsp;</b>
<b class="nc"><i>3426</i>&nbsp;        public boolean isEnabled() {</b>
<i>3427</i>&nbsp;            if (actionListener == null) {
<i>3428</i>&nbsp;                // This keeps the old semantics where
<i>3429</i>&nbsp;                // registerKeyboardAction(null) would essentialy remove
<i>3430</i>&nbsp;                // the binding. We don&#39;t remove the binding from the
<i>3431</i>&nbsp;                // InputMap as that would still allow parent InputMaps
<i>3432</i>&nbsp;                // bindings to be accessed.
<i>3433</i>&nbsp;                return false;
<i>3434</i>&nbsp;            }
<i>3435</i>&nbsp;            if (action == null) {
<i>3436</i>&nbsp;                return true;
<i>3437</i>&nbsp;            }
<i>3438</i>&nbsp;            return action.isEnabled();
<i>3439</i>&nbsp;        }
<i>3440</i>&nbsp;
<i>3441</i>&nbsp;        public void actionPerformed(ActionEvent ae) {
<i>3442</i>&nbsp;            if (actionListener != null) {
<i>3443</i>&nbsp;                actionListener.actionPerformed(ae);
<i>3444</i>&nbsp;            }
<i>3445</i>&nbsp;        }
<b class="nc"><i>3446</i>&nbsp;</b>
<b class="nc"><i>3447</i>&nbsp;        // We don&#39;t allow any values to be added.</b>
<b class="nc"><i>3448</i>&nbsp;        public void putValue(String key, Object value) {}</b>
<b class="nc"><i>3449</i>&nbsp;</b>
<i>3450</i>&nbsp;        // Does nothing, our enabledness is determiend from our asociated
<i>3451</i>&nbsp;        // action.
<b class="nc"><i>3452</i>&nbsp;        public void setEnabled(boolean b) { }</b>
<i>3453</i>&nbsp;
<i>3454</i>&nbsp;        public void addPropertyChangeListener
<i>3455</i>&nbsp;                    (PropertyChangeListener listener) {}
<b class="nc"><i>3456</i>&nbsp;        public void removePropertyChangeListener</b>
<i>3457</i>&nbsp;                          (PropertyChangeListener listener) {}
<i>3458</i>&nbsp;    }
<i>3459</i>&nbsp;
<b class="nc"><i>3460</i>&nbsp;</b>
<b class="nc"><i>3461</i>&nbsp;    // This class is used by the KeyboardState class to provide a single</b>
<b class="nc"><i>3462</i>&nbsp;    // instance that can be stored in the AppContext.</b>
<b class="nc"><i>3463</i>&nbsp;    static final class IntVector {</b>
<b class="nc"><i>3464</i>&nbsp;        int array[] = null;</b>
<i>3465</i>&nbsp;        int count = 0;
<b class="nc"><i>3466</i>&nbsp;        int capacity = 0;</b>
<i>3467</i>&nbsp;
<b class="nc"><i>3468</i>&nbsp;        int size() {</b>
<i>3469</i>&nbsp;            return count;
<i>3470</i>&nbsp;        }
<i>3471</i>&nbsp;
<b class="nc"><i>3472</i>&nbsp;        int elementAt(int index) {</b>
<i>3473</i>&nbsp;            return array[index];
<i>3474</i>&nbsp;        }
<i>3475</i>&nbsp;
<i>3476</i>&nbsp;        void addElement(int value) {
<b class="nc"><i>3477</i>&nbsp;            if (count == capacity) {</b>
<b class="nc"><i>3478</i>&nbsp;                capacity = (capacity + 2) * 2;</b>
<i>3479</i>&nbsp;                int[] newarray = new int[capacity];
<i>3480</i>&nbsp;                if (count &gt; 0) {
<i>3481</i>&nbsp;                    System.arraycopy(array, 0, newarray, 0, count);
<i>3482</i>&nbsp;                }
<b class="nc"><i>3483</i>&nbsp;                array = newarray;</b>
<b class="nc"><i>3484</i>&nbsp;            }</b>
<b class="nc"><i>3485</i>&nbsp;            array[count++] = value;</b>
<b class="nc"><i>3486</i>&nbsp;        }</b>
<b class="nc"><i>3487</i>&nbsp;</b>
<i>3488</i>&nbsp;        void setElementAt(int value, int index) {
<b class="nc"><i>3489</i>&nbsp;            array[index] = value;</b>
<i>3490</i>&nbsp;        }
<i>3491</i>&nbsp;    }
<i>3492</i>&nbsp;
<b class="nc"><i>3493</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>3494</i>&nbsp;    static class KeyboardState implements Serializable {</b>
<i>3495</i>&nbsp;        private static final Object keyCodesKey =
<b class="nc"><i>3496</i>&nbsp;            JComponent.KeyboardState.class;</b>
<b class="nc"><i>3497</i>&nbsp;</b>
<b class="nc"><i>3498</i>&nbsp;        // Get the array of key codes from the AppContext.</b>
<i>3499</i>&nbsp;        static IntVector getKeyCodeArray() {
<i>3500</i>&nbsp;            IntVector iv =
<i>3501</i>&nbsp;                (IntVector)SwingUtilities.appContextGet(keyCodesKey);
<b class="nc"><i>3502</i>&nbsp;            if (iv == null) {</b>
<i>3503</i>&nbsp;                iv = new IntVector();
<i>3504</i>&nbsp;                SwingUtilities.appContextPut(keyCodesKey, iv);
<i>3505</i>&nbsp;            }
<b class="nc"><i>3506</i>&nbsp;            return iv;</b>
<b class="nc"><i>3507</i>&nbsp;        }</b>
<i>3508</i>&nbsp;
<b class="nc"><i>3509</i>&nbsp;        static void registerKeyPressed(int keyCode) {</b>
<b class="nc"><i>3510</i>&nbsp;            IntVector kca = getKeyCodeArray();</b>
<b class="nc"><i>3511</i>&nbsp;            int count = kca.size();</b>
<i>3512</i>&nbsp;            int i;
<i>3513</i>&nbsp;            for(i=0;i&lt;count;i++) {
<i>3514</i>&nbsp;                if(kca.elementAt(i) == -1){
<i>3515</i>&nbsp;                    kca.setElementAt(keyCode, i);
<i>3516</i>&nbsp;                    return;
<i>3517</i>&nbsp;                }
<b class="nc"><i>3518</i>&nbsp;            }</b>
<b class="nc"><i>3519</i>&nbsp;            kca.addElement(keyCode);</b>
<i>3520</i>&nbsp;        }
<b class="nc"><i>3521</i>&nbsp;</b>
<b class="nc"><i>3522</i>&nbsp;        static void registerKeyReleased(int keyCode) {</b>
<b class="nc"><i>3523</i>&nbsp;            IntVector kca = getKeyCodeArray();</b>
<i>3524</i>&nbsp;            int count = kca.size();
<i>3525</i>&nbsp;            int i;
<b class="nc"><i>3526</i>&nbsp;            for(i=0;i&lt;count;i++) {</b>
<i>3527</i>&nbsp;                if(kca.elementAt(i) == keyCode) {
<i>3528</i>&nbsp;                    kca.setElementAt(-1, i);
<i>3529</i>&nbsp;                    return;
<i>3530</i>&nbsp;                }
<i>3531</i>&nbsp;            }
<i>3532</i>&nbsp;        }
<i>3533</i>&nbsp;
<b class="nc"><i>3534</i>&nbsp;        static boolean keyIsPressed(int keyCode) {</b>
<i>3535</i>&nbsp;            IntVector kca = getKeyCodeArray();
<b class="nc"><i>3536</i>&nbsp;            int count = kca.size();</b>
<b class="nc"><i>3537</i>&nbsp;            int i;</b>
<i>3538</i>&nbsp;            for(i=0;i&lt;count;i++) {
<b class="nc"><i>3539</i>&nbsp;                if(kca.elementAt(i) == keyCode) {</b>
<i>3540</i>&nbsp;                    return true;
<i>3541</i>&nbsp;                }
<i>3542</i>&nbsp;            }
<i>3543</i>&nbsp;            return false;
<i>3544</i>&nbsp;        }
<b class="nc"><i>3545</i>&nbsp;</b>
<b class="nc"><i>3546</i>&nbsp;        /**</b>
<b class="nc"><i>3547</i>&nbsp;         * Updates internal state of the KeyboardState and returns true</b>
<i>3548</i>&nbsp;         * if the event should be processed further.
<b class="nc"><i>3549</i>&nbsp;         */</b>
<i>3550</i>&nbsp;        static boolean shouldProcess(KeyEvent e) {
<b class="nc"><i>3551</i>&nbsp;            switch (e.getID()) {</b>
<i>3552</i>&nbsp;            case KeyEvent.KEY_PRESSED:
<i>3553</i>&nbsp;                if (!keyIsPressed(e.getKeyCode())) {
<b class="nc"><i>3554</i>&nbsp;                    registerKeyPressed(e.getKeyCode());</b>
<i>3555</i>&nbsp;                }
<i>3556</i>&nbsp;                return true;
<i>3557</i>&nbsp;            case KeyEvent.KEY_RELEASED:
<i>3558</i>&nbsp;                // We are forced to process VK_PRINTSCREEN separately because
<b class="nc"><i>3559</i>&nbsp;                // the Windows doesn&#39;t generate the key pressed event for</b>
<b class="nc"><i>3560</i>&nbsp;                // printscreen and it block the processing of key release</b>
<i>3561</i>&nbsp;                // event for printscreen.
<i>3562</i>&nbsp;                if (keyIsPressed(e.getKeyCode()) || e.getKeyCode()==KeyEvent.VK_PRINTSCREEN) {
<i>3563</i>&nbsp;                    registerKeyReleased(e.getKeyCode());
<i>3564</i>&nbsp;                    return true;
<b class="nc"><i>3565</i>&nbsp;                }</b>
<b class="nc"><i>3566</i>&nbsp;                return false;</b>
<i>3567</i>&nbsp;            case KeyEvent.KEY_TYPED:
<i>3568</i>&nbsp;                return true;
<b class="nc"><i>3569</i>&nbsp;            default:</b>
<b class="nc"><i>3570</i>&nbsp;                // Not a known KeyEvent type, bail.</b>
<i>3571</i>&nbsp;                return false;
<i>3572</i>&nbsp;            }
<b class="nc"><i>3573</i>&nbsp;      }</b>
<b class="nc"><i>3574</i>&nbsp;    }</b>
<b class="nc"><i>3575</i>&nbsp;</b>
<i>3576</i>&nbsp;    static final sun.awt.RequestFocusController focusController =
<i>3577</i>&nbsp;        new sun.awt.RequestFocusController() {
<b class="nc"><i>3578</i>&nbsp;            public boolean acceptRequestFocus(Component from, Component to,</b>
<b class="nc"><i>3579</i>&nbsp;                                              boolean temporary, boolean focusedWindowChangeAllowed,</b>
<i>3580</i>&nbsp;                                              FocusEvent.Cause cause)
<b class="nc"><i>3581</i>&nbsp;            {</b>
<b class="nc"><i>3582</i>&nbsp;                if ((to == null) || !(to instanceof JComponent)) {</b>
<i>3583</i>&nbsp;                    return true;
<b class="nc"><i>3584</i>&nbsp;                }</b>
<b class="nc"><i>3585</i>&nbsp;</b>
<b class="nc"><i>3586</i>&nbsp;                if ((from == null) || !(from instanceof JComponent)) {</b>
<i>3587</i>&nbsp;                    return true;
<i>3588</i>&nbsp;                }
<b class="nc"><i>3589</i>&nbsp;</b>
<i>3590</i>&nbsp;                JComponent target = (JComponent) to;
<b class="nc"><i>3591</i>&nbsp;                if (!target.getVerifyInputWhenFocusTarget()) {</b>
<i>3592</i>&nbsp;                    return true;
<i>3593</i>&nbsp;                }
<b class="nc"><i>3594</i>&nbsp;</b>
<i>3595</i>&nbsp;                JComponent jFocusOwner = (JComponent)from;
<b class="nc"><i>3596</i>&nbsp;                InputVerifier iv = jFocusOwner.getInputVerifier();</b>
<i>3597</i>&nbsp;
<i>3598</i>&nbsp;                if (iv == null) {
<i>3599</i>&nbsp;                    return true;
<i>3600</i>&nbsp;                } else {
<i>3601</i>&nbsp;                    Object currentSource = SwingUtilities.appContextGet(
<b class="nc"><i>3602</i>&nbsp;                            INPUT_VERIFIER_SOURCE_KEY);</b>
<b class="nc"><i>3603</i>&nbsp;                    if (currentSource == jFocusOwner) {</b>
<i>3604</i>&nbsp;                        // We&#39;re currently calling into the InputVerifier
<b class="nc"><i>3605</i>&nbsp;                        // for this component, so allow the focus change.</b>
<b class="nc"><i>3606</i>&nbsp;                        return true;</b>
<i>3607</i>&nbsp;                    }
<i>3608</i>&nbsp;                    SwingUtilities.appContextPut(INPUT_VERIFIER_SOURCE_KEY,
<i>3609</i>&nbsp;                                                 jFocusOwner);
<i>3610</i>&nbsp;                    try {
<i>3611</i>&nbsp;                        return iv.shouldYieldFocus(jFocusOwner, target);
<i>3612</i>&nbsp;                    } finally {
<i>3613</i>&nbsp;                        if (currentSource != null) {
<i>3614</i>&nbsp;                            // We&#39;re already in the InputVerifier for
<i>3615</i>&nbsp;                            // currentSource. By resetting the currentSource
<i>3616</i>&nbsp;                            // we ensure that if the InputVerifier for
<i>3617</i>&nbsp;                            // currentSource does a requestFocus, we don&#39;t
<i>3618</i>&nbsp;                            // try and run the InputVerifier again.
<i>3619</i>&nbsp;                            SwingUtilities.appContextPut(
<i>3620</i>&nbsp;                                INPUT_VERIFIER_SOURCE_KEY, currentSource);
<i>3621</i>&nbsp;                        } else {
<i>3622</i>&nbsp;                            SwingUtilities.appContextRemove(
<b class="nc"><i>3623</i>&nbsp;                                INPUT_VERIFIER_SOURCE_KEY);</b>
<b class="nc"><i>3624</i>&nbsp;                        }</b>
<b class="nc"><i>3625</i>&nbsp;                    }</b>
<b class="nc"><i>3626</i>&nbsp;                }</b>
<i>3627</i>&nbsp;            }
<i>3628</i>&nbsp;        };
<i>3629</i>&nbsp;
<i>3630</i>&nbsp;    /*
<i>3631</i>&nbsp;     * --- Accessibility Support ---
<i>3632</i>&nbsp;     */
<i>3633</i>&nbsp;
<i>3634</i>&nbsp;    /**
<i>3635</i>&nbsp;     * @deprecated As of JDK version 1.1,
<i>3636</i>&nbsp;     * replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.
<i>3637</i>&nbsp;     */
<i>3638</i>&nbsp;    @Deprecated
<b class="nc"><i>3639</i>&nbsp;    public void enable() {</b>
<b class="nc"><i>3640</i>&nbsp;        if (isEnabled() != true) {</b>
<b class="nc"><i>3641</i>&nbsp;            super.enable();</b>
<b class="nc"><i>3642</i>&nbsp;            if (accessibleContext != null) {</b>
<i>3643</i>&nbsp;                accessibleContext.firePropertyChange(
<i>3644</i>&nbsp;                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>3645</i>&nbsp;                    null, AccessibleState.ENABLED);
<i>3646</i>&nbsp;            }
<i>3647</i>&nbsp;        }
<i>3648</i>&nbsp;    }
<i>3649</i>&nbsp;
<i>3650</i>&nbsp;    /**
<i>3651</i>&nbsp;     * @deprecated As of JDK version 1.1,
<i>3652</i>&nbsp;     * replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.
<i>3653</i>&nbsp;     */
<i>3654</i>&nbsp;    @Deprecated
<i>3655</i>&nbsp;    public void disable() {
<i>3656</i>&nbsp;        if (isEnabled() != false) {
<i>3657</i>&nbsp;            super.disable();
<i>3658</i>&nbsp;            if (accessibleContext != null) {
<i>3659</i>&nbsp;                accessibleContext.firePropertyChange(
<i>3660</i>&nbsp;                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>3661</i>&nbsp;                    AccessibleState.ENABLED, null);
<i>3662</i>&nbsp;            }
<i>3663</i>&nbsp;        }
<i>3664</i>&nbsp;    }
<i>3665</i>&nbsp;
<i>3666</i>&nbsp;    /**
<i>3667</i>&nbsp;     * Inner class of JComponent used to provide default support for
<i>3668</i>&nbsp;     * accessibility.  This class is not meant to be used directly by
<i>3669</i>&nbsp;     * application developers, but is instead meant only to be
<i>3670</i>&nbsp;     * subclassed by component developers.
<b class="nc"><i>3671</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3672</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;</b>
<i>3673</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>3674</i>&nbsp;     * future Swing releases. The current serialization support is
<i>3675</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>3676</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>3677</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>3678</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>3679</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<b class="nc"><i>3680</i>&nbsp;     */</b>
<i>3681</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>3682</i>&nbsp;    public abstract class AccessibleJComponent extends AccessibleAWTContainer
<i>3683</i>&nbsp;       implements AccessibleExtendedComponent
<i>3684</i>&nbsp;    {
<i>3685</i>&nbsp;        /**
<b class="nc"><i>3686</i>&nbsp;         * Though the class is abstract, this should be called by</b>
<i>3687</i>&nbsp;         * all sub-classes.
<i>3688</i>&nbsp;         */
<i>3689</i>&nbsp;        protected AccessibleJComponent() {
<i>3690</i>&nbsp;            super();
<i>3691</i>&nbsp;        }
<i>3692</i>&nbsp;
<b class="nc"><i>3693</i>&nbsp;        /**</b>
<i>3694</i>&nbsp;         * Number of PropertyChangeListener objects registered. It&#39;s used
<i>3695</i>&nbsp;         * to add/remove ContainerListener and FocusListener to track
<b class="nc"><i>3696</i>&nbsp;         * target JComponent&#39;s state</b>
<b class="nc"><i>3697</i>&nbsp;         */</b>
<b class="nc"><i>3698</i>&nbsp;        private transient volatile int propertyListenersCount = 0;</b>
<i>3699</i>&nbsp;
<b class="nc"><i>3700</i>&nbsp;        /**</b>
<i>3701</i>&nbsp;         * This field duplicates the function of the accessibleAWTFocusHandler field
<i>3702</i>&nbsp;         * in java.awt.Component.AccessibleAWTComponent, so it has been deprecated.
<i>3703</i>&nbsp;         */
<b class="nc"><i>3704</i>&nbsp;        @Deprecated</b>
<b class="nc"><i>3705</i>&nbsp;        protected FocusListener accessibleFocusHandler = null;</b>
<b class="nc"><i>3706</i>&nbsp;</b>
<i>3707</i>&nbsp;        /**
<b class="nc"><i>3708</i>&nbsp;         * Fire PropertyChange listener, if one is registered,</b>
<i>3709</i>&nbsp;         * when children added/removed.
<i>3710</i>&nbsp;         */
<i>3711</i>&nbsp;        protected class AccessibleContainerHandler
<i>3712</i>&nbsp;            implements ContainerListener {
<i>3713</i>&nbsp;            public void componentAdded(ContainerEvent e) {
<i>3714</i>&nbsp;                Component c = e.getChild();
<i>3715</i>&nbsp;                if (c != null &amp;&amp; c instanceof Accessible) {
<i>3716</i>&nbsp;                    AccessibleJComponent.this.firePropertyChange(
<i>3717</i>&nbsp;                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<b class="nc"><i>3718</i>&nbsp;                        null, c.getAccessibleContext());</b>
<i>3719</i>&nbsp;                }
<b class="nc"><i>3720</i>&nbsp;            }</b>
<b class="nc"><i>3721</i>&nbsp;            public void componentRemoved(ContainerEvent e) {</b>
<i>3722</i>&nbsp;                Component c = e.getChild();
<i>3723</i>&nbsp;                if (c != null &amp;&amp; c instanceof Accessible) {
<i>3724</i>&nbsp;                    AccessibleJComponent.this.firePropertyChange(
<i>3725</i>&nbsp;                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<i>3726</i>&nbsp;                        c.getAccessibleContext(), null);
<b class="nc"><i>3727</i>&nbsp;                }</b>
<b class="nc"><i>3728</i>&nbsp;            }</b>
<i>3729</i>&nbsp;        }
<i>3730</i>&nbsp;
<i>3731</i>&nbsp;        /**
<i>3732</i>&nbsp;         * Fire PropertyChange listener, if one is registered,
<i>3733</i>&nbsp;         * when focus events happen
<i>3734</i>&nbsp;         * @since 1.3
<i>3735</i>&nbsp;         * @deprecated This class is no longer used or needed.
<i>3736</i>&nbsp;         * {@code java.awt.Component.AccessibleAWTComponent} provides
<i>3737</i>&nbsp;         * the same functionality and it is handled in {@code Component}.
<i>3738</i>&nbsp;         */
<i>3739</i>&nbsp;        @Deprecated
<i>3740</i>&nbsp;        protected class AccessibleFocusHandler implements FocusListener {
<i>3741</i>&nbsp;           public void focusGained(FocusEvent event) {
<b class="nc"><i>3742</i>&nbsp;               if (accessibleContext != null) {</b>
<i>3743</i>&nbsp;                    accessibleContext.firePropertyChange(
<i>3744</i>&nbsp;                        AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>3745</i>&nbsp;                        null, AccessibleState.FOCUSED);
<i>3746</i>&nbsp;                }
<i>3747</i>&nbsp;            }
<i>3748</i>&nbsp;            public void focusLost(FocusEvent event) {
<i>3749</i>&nbsp;                if (accessibleContext != null) {
<i>3750</i>&nbsp;                    accessibleContext.firePropertyChange(
<i>3751</i>&nbsp;                        AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
<i>3752</i>&nbsp;                        AccessibleState.FOCUSED, null);
<b class="nc"><i>3753</i>&nbsp;                }</b>
<i>3754</i>&nbsp;            }
<i>3755</i>&nbsp;        } // inner class AccessibleFocusHandler
<i>3756</i>&nbsp;
<i>3757</i>&nbsp;
<i>3758</i>&nbsp;        /**
<i>3759</i>&nbsp;         * Adds a PropertyChangeListener to the listener list.
<i>3760</i>&nbsp;         *
<i>3761</i>&nbsp;         * @param listener  the PropertyChangeListener to be added
<i>3762</i>&nbsp;         */
<i>3763</i>&nbsp;        public void addPropertyChangeListener(PropertyChangeListener listener) {
<i>3764</i>&nbsp;            super.addPropertyChangeListener(listener);
<i>3765</i>&nbsp;        }
<i>3766</i>&nbsp;
<i>3767</i>&nbsp;        /**
<i>3768</i>&nbsp;         * Removes a PropertyChangeListener from the listener list.
<b class="nc"><i>3769</i>&nbsp;         * This removes a PropertyChangeListener that was registered</b>
<b class="nc"><i>3770</i>&nbsp;         * for all properties.</b>
<b class="nc"><i>3771</i>&nbsp;         *</b>
<b class="nc"><i>3772</i>&nbsp;         * @param listener  the PropertyChangeListener to be removed</b>
<b class="nc"><i>3773</i>&nbsp;         */</b>
<b class="nc"><i>3774</i>&nbsp;        public void removePropertyChangeListener(PropertyChangeListener listener) {</b>
<i>3775</i>&nbsp;            super.removePropertyChangeListener(listener);
<b class="nc"><i>3776</i>&nbsp;        }</b>
<i>3777</i>&nbsp;
<b class="nc"><i>3778</i>&nbsp;</b>
<i>3779</i>&nbsp;
<i>3780</i>&nbsp;        /**
<i>3781</i>&nbsp;         * Recursively search through the border hierarchy (if it exists)
<i>3782</i>&nbsp;         * for a TitledBorder with a non-null title.  This does a depth
<i>3783</i>&nbsp;         * first search on first the inside borders then the outside borders.
<i>3784</i>&nbsp;         * The assumption is that titles make really pretty inside borders
<i>3785</i>&nbsp;         * but not very pretty outside borders in compound border situations.
<i>3786</i>&nbsp;         * It&#39;s rather arbitrary, but hopefully decent UI programmers will
<i>3787</i>&nbsp;         * not create multiple titled borders for the same component.
<i>3788</i>&nbsp;         *
<i>3789</i>&nbsp;         * @param b  the {@code Border} for which to retrieve its title
<i>3790</i>&nbsp;         * @return the border&#39;s title as a {@code String}, null if it has
<i>3791</i>&nbsp;         *         no title
<i>3792</i>&nbsp;         */
<i>3793</i>&nbsp;        protected String getBorderTitle(Border b) {
<i>3794</i>&nbsp;            String s;
<i>3795</i>&nbsp;            if (b instanceof TitledBorder) {
<i>3796</i>&nbsp;                return ((TitledBorder) b).getTitle();
<i>3797</i>&nbsp;            } else if (b instanceof CompoundBorder) {
<i>3798</i>&nbsp;                s = getBorderTitle(((CompoundBorder) b).getInsideBorder());
<b class="nc"><i>3799</i>&nbsp;                if (s == null) {</b>
<i>3800</i>&nbsp;                    s = getBorderTitle(((CompoundBorder) b).getOutsideBorder());
<i>3801</i>&nbsp;                }
<i>3802</i>&nbsp;                return s;
<b class="nc"><i>3803</i>&nbsp;            } else {</b>
<b class="nc"><i>3804</i>&nbsp;                return null;</b>
<i>3805</i>&nbsp;            }
<i>3806</i>&nbsp;        }
<i>3807</i>&nbsp;
<i>3808</i>&nbsp;        // AccessibleContext methods
<b class="nc"><i>3809</i>&nbsp;        //</b>
<b class="nc"><i>3810</i>&nbsp;        /**</b>
<i>3811</i>&nbsp;         * Gets the accessible name of this object.  This should almost never
<i>3812</i>&nbsp;         * return java.awt.Component.getName(), as that generally isn&#39;t
<i>3813</i>&nbsp;         * a localized name, and doesn&#39;t have meaning for the user.  If the
<i>3814</i>&nbsp;         * object is fundamentally a text object (such as a menu item), the
<b class="nc"><i>3815</i>&nbsp;         * accessible name should be the text of the object (for example,</b>
<b class="nc"><i>3816</i>&nbsp;         * &quot;save&quot;).</b>
<b class="nc"><i>3817</i>&nbsp;         * If the object has a tooltip, the tooltip text may also be an</b>
<b class="nc"><i>3818</i>&nbsp;         * appropriate String to return.</b>
<b class="nc"><i>3819</i>&nbsp;         *</b>
<b class="nc"><i>3820</i>&nbsp;         * @return the localized name of the object -- can be null if this</b>
<i>3821</i>&nbsp;         *         object does not have a name
<i>3822</i>&nbsp;         * @see AccessibleContext#setAccessibleName
<i>3823</i>&nbsp;         */
<b class="nc"><i>3824</i>&nbsp;        public String getAccessibleName() {</b>
<i>3825</i>&nbsp;            String name = accessibleName;
<i>3826</i>&nbsp;
<i>3827</i>&nbsp;            // fallback to the client name property
<i>3828</i>&nbsp;            //
<i>3829</i>&nbsp;            if (name == null) {
<i>3830</i>&nbsp;                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
<i>3831</i>&nbsp;            }
<i>3832</i>&nbsp;
<i>3833</i>&nbsp;            // fallback to the titled border if it exists
<i>3834</i>&nbsp;            //
<i>3835</i>&nbsp;            if (name == null) {
<i>3836</i>&nbsp;                name = getBorderTitle(getBorder());
<i>3837</i>&nbsp;            }
<i>3838</i>&nbsp;
<i>3839</i>&nbsp;            // fallback to the label labeling us if it exists
<i>3840</i>&nbsp;            //
<i>3841</i>&nbsp;            if (name == null) {
<i>3842</i>&nbsp;                Object o = getClientProperty(JLabel.LABELED_BY_PROPERTY);
<b class="nc"><i>3843</i>&nbsp;                if (o instanceof Accessible) {</b>
<i>3844</i>&nbsp;                    AccessibleContext ac = ((Accessible) o).getAccessibleContext();
<i>3845</i>&nbsp;                    if (ac != null) {
<i>3846</i>&nbsp;                        name = ac.getAccessibleName();
<b class="nc"><i>3847</i>&nbsp;                    }</b>
<b class="nc"><i>3848</i>&nbsp;                }</b>
<i>3849</i>&nbsp;            }
<i>3850</i>&nbsp;            return name;
<i>3851</i>&nbsp;        }
<i>3852</i>&nbsp;
<b class="nc"><i>3853</i>&nbsp;        /**</b>
<i>3854</i>&nbsp;         * Gets the accessible description of this object.  This should be
<b class="nc"><i>3855</i>&nbsp;         * a concise, localized description of what this object is - what</b>
<b class="nc"><i>3856</i>&nbsp;         * is its meaning to the user.  If the object has a tooltip, the</b>
<i>3857</i>&nbsp;         * tooltip text may be an appropriate string to return, assuming
<i>3858</i>&nbsp;         * it contains a concise description of the object (instead of just
<i>3859</i>&nbsp;         * the name of the object - for example a &quot;Save&quot; icon on a toolbar that
<i>3860</i>&nbsp;         * had &quot;save&quot; as the tooltip text shouldn&#39;t return the tooltip
<i>3861</i>&nbsp;         * text as the description, but something like &quot;Saves the current
<i>3862</i>&nbsp;         * text document&quot; instead).
<i>3863</i>&nbsp;         *
<i>3864</i>&nbsp;         * @return the localized description of the object -- can be null if
<i>3865</i>&nbsp;         * this object does not have a description
<b class="nc"><i>3866</i>&nbsp;         * @see AccessibleContext#setAccessibleDescription</b>
<i>3867</i>&nbsp;         */
<i>3868</i>&nbsp;        public String getAccessibleDescription() {
<i>3869</i>&nbsp;            String description = accessibleDescription;
<i>3870</i>&nbsp;
<b class="nc"><i>3871</i>&nbsp;            // fallback to the client description property</b>
<b class="nc"><i>3872</i>&nbsp;            //</b>
<b class="nc"><i>3873</i>&nbsp;            if (description == null) {</b>
<b class="nc"><i>3874</i>&nbsp;                description = (String)getClientProperty(AccessibleContext.ACCESSIBLE_DESCRIPTION_PROPERTY);</b>
<b class="nc"><i>3875</i>&nbsp;            }</b>
<b class="nc"><i>3876</i>&nbsp;</b>
<i>3877</i>&nbsp;            // fallback to the tool tip text if it exists
<i>3878</i>&nbsp;            //
<i>3879</i>&nbsp;            if (description == null) {
<i>3880</i>&nbsp;                try {
<b class="nc"><i>3881</i>&nbsp;                    description = getToolTipText();</b>
<i>3882</i>&nbsp;                } catch (Exception e) {
<i>3883</i>&nbsp;                    // Just in case the subclass overrode the
<i>3884</i>&nbsp;                    // getToolTipText method and actually
<i>3885</i>&nbsp;                    // requires a MouseEvent.
<i>3886</i>&nbsp;                    // [[[FIXME:  WDW - we probably should require this
<i>3887</i>&nbsp;                    // method to take a MouseEvent and just pass it on
<i>3888</i>&nbsp;                    // to getToolTipText.  The swing-feedback traffic
<i>3889</i>&nbsp;                    // leads me to believe getToolTipText might change,
<i>3890</i>&nbsp;                    // though, so I was hesitant to make this change at
<i>3891</i>&nbsp;                    // this time.]]]
<b class="nc"><i>3892</i>&nbsp;                }</b>
<i>3893</i>&nbsp;            }
<i>3894</i>&nbsp;
<i>3895</i>&nbsp;            // fallback to the label labeling us if it exists
<i>3896</i>&nbsp;            //
<i>3897</i>&nbsp;            if (description == null) {
<i>3898</i>&nbsp;                Object o = getClientProperty(JLabel.LABELED_BY_PROPERTY);
<i>3899</i>&nbsp;                if (o instanceof Accessible) {
<i>3900</i>&nbsp;                    AccessibleContext ac = ((Accessible) o).getAccessibleContext();
<i>3901</i>&nbsp;                    if (ac != null) {
<i>3902</i>&nbsp;                        description = ac.getAccessibleDescription();
<b class="nc"><i>3903</i>&nbsp;                    }</b>
<b class="nc"><i>3904</i>&nbsp;                }</b>
<b class="nc"><i>3905</i>&nbsp;            }</b>
<i>3906</i>&nbsp;
<b class="nc"><i>3907</i>&nbsp;            return description;</b>
<i>3908</i>&nbsp;        }
<i>3909</i>&nbsp;
<i>3910</i>&nbsp;        /**
<i>3911</i>&nbsp;         * Gets the role of this object.
<i>3912</i>&nbsp;         *
<i>3913</i>&nbsp;         * @return an instance of AccessibleRole describing the role of the
<i>3914</i>&nbsp;         * object
<i>3915</i>&nbsp;         * @see AccessibleRole
<i>3916</i>&nbsp;         */
<i>3917</i>&nbsp;        public AccessibleRole getAccessibleRole() {
<b class="nc"><i>3918</i>&nbsp;            return AccessibleRole.SWING_COMPONENT;</b>
<i>3919</i>&nbsp;        }
<i>3920</i>&nbsp;
<i>3921</i>&nbsp;        /**
<i>3922</i>&nbsp;         * Gets the state of this object.
<i>3923</i>&nbsp;         *
<i>3924</i>&nbsp;         * @return an instance of AccessibleStateSet containing the current
<i>3925</i>&nbsp;         * state set of the object
<i>3926</i>&nbsp;         * @see AccessibleState
<i>3927</i>&nbsp;         */
<b class="nc"><i>3928</i>&nbsp;        public AccessibleStateSet getAccessibleStateSet() {</b>
<i>3929</i>&nbsp;            AccessibleStateSet states = super.getAccessibleStateSet();
<i>3930</i>&nbsp;            if (JComponent.this.isOpaque()) {
<i>3931</i>&nbsp;                states.add(AccessibleState.OPAQUE);
<i>3932</i>&nbsp;            }
<i>3933</i>&nbsp;            return states;
<i>3934</i>&nbsp;        }
<i>3935</i>&nbsp;
<i>3936</i>&nbsp;        /**
<i>3937</i>&nbsp;         * Returns the number of accessible children in the object.  If all
<i>3938</i>&nbsp;         * of the children of this object implement Accessible, than this
<b class="nc"><i>3939</i>&nbsp;         * method should return the number of children of this object.</b>
<i>3940</i>&nbsp;         *
<i>3941</i>&nbsp;         * @return the number of accessible children in the object.
<i>3942</i>&nbsp;         */
<i>3943</i>&nbsp;        public int getAccessibleChildrenCount() {
<i>3944</i>&nbsp;            return super.getAccessibleChildrenCount();
<i>3945</i>&nbsp;        }
<i>3946</i>&nbsp;
<i>3947</i>&nbsp;        /**
<i>3948</i>&nbsp;         * Returns the nth Accessible child of the object.
<i>3949</i>&nbsp;         *
<b class="nc"><i>3950</i>&nbsp;         * @param i zero-based index of child</b>
<i>3951</i>&nbsp;         * @return the nth Accessible child of the object
<i>3952</i>&nbsp;         */
<i>3953</i>&nbsp;        public Accessible getAccessibleChild(int i) {
<i>3954</i>&nbsp;            return super.getAccessibleChild(i);
<i>3955</i>&nbsp;        }
<i>3956</i>&nbsp;
<i>3957</i>&nbsp;        // ----- AccessibleExtendedComponent
<i>3958</i>&nbsp;
<i>3959</i>&nbsp;        /**
<i>3960</i>&nbsp;         * Returns the AccessibleExtendedComponent
<b class="nc"><i>3961</i>&nbsp;         *</b>
<b class="nc"><i>3962</i>&nbsp;         * @return the AccessibleExtendedComponent</b>
<b class="nc"><i>3963</i>&nbsp;         */</b>
<i>3964</i>&nbsp;        AccessibleExtendedComponent getAccessibleExtendedComponent() {
<b class="nc"><i>3965</i>&nbsp;            return this;</b>
<i>3966</i>&nbsp;        }
<i>3967</i>&nbsp;
<i>3968</i>&nbsp;        /**
<i>3969</i>&nbsp;         * Returns the tool tip text
<i>3970</i>&nbsp;         *
<i>3971</i>&nbsp;         * @return the tool tip text, if supported, of the object;
<i>3972</i>&nbsp;         * otherwise, null
<i>3973</i>&nbsp;         * @since 1.4
<i>3974</i>&nbsp;         */
<i>3975</i>&nbsp;        public String getToolTipText() {
<i>3976</i>&nbsp;            return JComponent.this.getToolTipText();
<i>3977</i>&nbsp;        }
<i>3978</i>&nbsp;
<b class="nc"><i>3979</i>&nbsp;        /**</b>
<b class="nc"><i>3980</i>&nbsp;         * Returns the titled border text</b>
<b class="nc"><i>3981</i>&nbsp;         *</b>
<b class="nc"><i>3982</i>&nbsp;         * @return the titled border text, if supported, of the object;</b>
<b class="nc"><i>3983</i>&nbsp;         * otherwise, null</b>
<b class="nc"><i>3984</i>&nbsp;         * @since 1.4</b>
<b class="nc"><i>3985</i>&nbsp;         */</b>
<b class="nc"><i>3986</i>&nbsp;        public String getTitledBorderText() {</b>
<i>3987</i>&nbsp;            Border border = JComponent.this.getBorder();
<i>3988</i>&nbsp;            if (border instanceof TitledBorder) {
<b class="nc"><i>3989</i>&nbsp;                return ((TitledBorder)border).getTitle();</b>
<i>3990</i>&nbsp;            } else {
<i>3991</i>&nbsp;                return null;
<i>3992</i>&nbsp;            }
<i>3993</i>&nbsp;        }
<i>3994</i>&nbsp;
<i>3995</i>&nbsp;        /**
<i>3996</i>&nbsp;         * Returns key bindings associated with this object
<i>3997</i>&nbsp;         *
<i>3998</i>&nbsp;         * @return the key bindings, if supported, of the object;
<i>3999</i>&nbsp;         * otherwise, null
<i>4000</i>&nbsp;         * @see AccessibleKeyBinding
<i>4001</i>&nbsp;         * @since 1.4
<i>4002</i>&nbsp;         */
<i>4003</i>&nbsp;        public AccessibleKeyBinding getAccessibleKeyBinding(){
<i>4004</i>&nbsp;            // Try to get the linked label&#39;s mnemonic if it exists
<b class="nc"><i>4005</i>&nbsp;            Object o = getClientProperty(JLabel.LABELED_BY_PROPERTY);</b>
<b class="nc"><i>4006</i>&nbsp;            if (o instanceof Accessible){</b>
<i>4007</i>&nbsp;                AccessibleContext ac = ((Accessible) o).getAccessibleContext();
<b class="nc"><i>4008</i>&nbsp;                if (ac != null){</b>
<i>4009</i>&nbsp;                    AccessibleComponent comp = ac.getAccessibleComponent();
<i>4010</i>&nbsp;                    if (! (comp instanceof AccessibleExtendedComponent))
<i>4011</i>&nbsp;                        return null;
<i>4012</i>&nbsp;                    return ((AccessibleExtendedComponent)comp).getAccessibleKeyBinding();
<i>4013</i>&nbsp;                }
<i>4014</i>&nbsp;            }
<i>4015</i>&nbsp;            return null;
<i>4016</i>&nbsp;        }
<i>4017</i>&nbsp;    } // inner class AccessibleJComponent
<i>4018</i>&nbsp;
<i>4019</i>&nbsp;
<i>4020</i>&nbsp;    /**
<i>4021</i>&nbsp;     * Returns an &lt;code&gt;ArrayTable&lt;/code&gt; used for
<b class="nc"><i>4022</i>&nbsp;     * key/value &quot;client properties&quot; for this component. If the</b>
<b class="nc"><i>4023</i>&nbsp;     * &lt;code&gt;clientProperties&lt;/code&gt; table doesn&#39;t exist, an empty one</b>
<b class="nc"><i>4024</i>&nbsp;     * will be created.</b>
<b class="nc"><i>4025</i>&nbsp;     *</b>
<i>4026</i>&nbsp;     * @return an ArrayTable
<b class="nc"><i>4027</i>&nbsp;     * @see #putClientProperty</b>
<b class="nc"><i>4028</i>&nbsp;     * @see #getClientProperty</b>
<i>4029</i>&nbsp;     */
<b class="nc"><i>4030</i>&nbsp;    private ArrayTable getClientProperties() {</b>
<b class="nc"><i>4031</i>&nbsp;        if (clientProperties == null) {</b>
<b class="nc"><i>4032</i>&nbsp;            clientProperties = new ArrayTable();</b>
<i>4033</i>&nbsp;        }
<i>4034</i>&nbsp;        return clientProperties;
<i>4035</i>&nbsp;    }
<i>4036</i>&nbsp;
<i>4037</i>&nbsp;
<i>4038</i>&nbsp;    /**
<i>4039</i>&nbsp;     * Returns the value of the property with the specified key.  Only
<i>4040</i>&nbsp;     * properties added with &lt;code&gt;putClientProperty&lt;/code&gt; will return
<i>4041</i>&nbsp;     * a non-&lt;code&gt;null&lt;/code&gt; value.
<i>4042</i>&nbsp;     *
<i>4043</i>&nbsp;     * @param key the being queried
<i>4044</i>&nbsp;     * @return the value of this property or &lt;code&gt;null&lt;/code&gt;
<i>4045</i>&nbsp;     * @see #putClientProperty
<i>4046</i>&nbsp;     */
<i>4047</i>&nbsp;    public final Object getClientProperty(Object key) {
<i>4048</i>&nbsp;        if (key == RenderingHints.KEY_TEXT_ANTIALIASING) {
<i>4049</i>&nbsp;            return aaHint;
<i>4050</i>&nbsp;        } else if (key == RenderingHints.KEY_TEXT_LCD_CONTRAST) {
<i>4051</i>&nbsp;            return lcdRenderingHint;
<i>4052</i>&nbsp;        }
<i>4053</i>&nbsp;         if(clientProperties == null) {
<i>4054</i>&nbsp;            return null;
<i>4055</i>&nbsp;        } else {
<i>4056</i>&nbsp;            synchronized(clientProperties) {
<i>4057</i>&nbsp;                return clientProperties.get(key);
<i>4058</i>&nbsp;            }
<i>4059</i>&nbsp;        }
<i>4060</i>&nbsp;    }
<i>4061</i>&nbsp;
<i>4062</i>&nbsp;    /**
<i>4063</i>&nbsp;     * Adds an arbitrary key/value &quot;client property&quot; to this component.
<i>4064</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>4065</i>&nbsp;     * The &lt;code&gt;get/putClientProperty&lt;/code&gt; methods provide access to</b>
<b class="nc"><i>4066</i>&nbsp;     * a small per-instance hashtable. Callers can use get/putClientProperty</b>
<i>4067</i>&nbsp;     * to annotate components that were created by another module.
<i>4068</i>&nbsp;     * For example, a
<b class="nc"><i>4069</i>&nbsp;     * layout manager might store per child constraints this way. For example:</b>
<i>4070</i>&nbsp;     * &lt;pre&gt;
<i>4071</i>&nbsp;     * componentA.putClientProperty(&quot;to the left of&quot;, componentB);
<i>4072</i>&nbsp;     * &lt;/pre&gt;
<i>4073</i>&nbsp;     * If value is &lt;code&gt;null&lt;/code&gt; this method will remove the property.
<b class="nc"><i>4074</i>&nbsp;     * Changes to client properties are reported with</b>
<i>4075</i>&nbsp;     * &lt;code&gt;PropertyChange&lt;/code&gt; events.
<b class="nc"><i>4076</i>&nbsp;     * The name of the property (for the sake of PropertyChange</b>
<b class="nc"><i>4077</i>&nbsp;     * events) is &lt;code&gt;key.toString()&lt;/code&gt;.</b>
<b class="nc"><i>4078</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>4079</i>&nbsp;     * The &lt;code&gt;clientProperty&lt;/code&gt; dictionary is not intended to</b>
<b class="nc"><i>4080</i>&nbsp;     * support large</b>
<b class="nc"><i>4081</i>&nbsp;     * scale extensions to JComponent nor should be it considered an</b>
<i>4082</i>&nbsp;     * alternative to subclassing when designing a new component.
<i>4083</i>&nbsp;     *
<b class="nc"><i>4084</i>&nbsp;     * @param key the new client property key</b>
<i>4085</i>&nbsp;     * @param value the new client property value; if &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>4086</i>&nbsp;     *          this method will remove the property</b>
<b class="nc"><i>4087</i>&nbsp;     * @see #getClientProperty</b>
<b class="nc"><i>4088</i>&nbsp;     * @see #addPropertyChangeListener</b>
<i>4089</i>&nbsp;     */
<i>4090</i>&nbsp;    public final void putClientProperty(Object key, Object value) {
<i>4091</i>&nbsp;        if (key == RenderingHints.KEY_TEXT_ANTIALIASING) {
<i>4092</i>&nbsp;            aaHint = value;
<i>4093</i>&nbsp;            return;
<i>4094</i>&nbsp;        } else if (key == RenderingHints.KEY_TEXT_LCD_CONTRAST) {
<i>4095</i>&nbsp;            lcdRenderingHint = value;
<i>4096</i>&nbsp;            return;
<i>4097</i>&nbsp;        }
<i>4098</i>&nbsp;        if (value == null &amp;&amp; clientProperties == null) {
<i>4099</i>&nbsp;            // Both the value and ArrayTable are null, implying we don&#39;t
<i>4100</i>&nbsp;            // have to do anything.
<i>4101</i>&nbsp;            return;
<i>4102</i>&nbsp;        }
<i>4103</i>&nbsp;        ArrayTable clientProperties = getClientProperties();
<i>4104</i>&nbsp;        Object oldValue;
<i>4105</i>&nbsp;        synchronized(clientProperties) {
<i>4106</i>&nbsp;            oldValue = clientProperties.get(key);
<i>4107</i>&nbsp;            if (value != null) {
<i>4108</i>&nbsp;                clientProperties.put(key, value);
<b class="nc"><i>4109</i>&nbsp;            } else if (oldValue != null) {</b>
<b class="nc"><i>4110</i>&nbsp;                clientProperties.remove(key);</b>
<b class="nc"><i>4111</i>&nbsp;            } else {</b>
<b class="nc"><i>4112</i>&nbsp;                // old == new == null</b>
<i>4113</i>&nbsp;                return;
<b class="nc"><i>4114</i>&nbsp;            }</b>
<b class="nc"><i>4115</i>&nbsp;        }</b>
<b class="nc"><i>4116</i>&nbsp;        clientPropertyChanged(key, oldValue, value);</b>
<b class="nc"><i>4117</i>&nbsp;        firePropertyChange(key.toString(), oldValue, value);</b>
<i>4118</i>&nbsp;    }
<b class="nc"><i>4119</i>&nbsp;</b>
<b class="nc"><i>4120</i>&nbsp;    // Invoked from putClientProperty.  This is provided for subclasses</b>
<b class="nc"><i>4121</i>&nbsp;    // in Swing.</b>
<i>4122</i>&nbsp;    void clientPropertyChanged(Object key, Object oldValue,
<i>4123</i>&nbsp;                               Object newValue) {
<i>4124</i>&nbsp;    }
<b class="nc"><i>4125</i>&nbsp;</b>
<b class="nc"><i>4126</i>&nbsp;</b>
<b class="nc"><i>4127</i>&nbsp;    /*</b>
<i>4128</i>&nbsp;     * Sets the property with the specified name to the specified value if
<i>4129</i>&nbsp;     * the property has not already been set by the client program.
<i>4130</i>&nbsp;     * This method is used primarily to set UI defaults for properties
<i>4131</i>&nbsp;     * with primitive types, where the values cannot be marked with
<b class="nc"><i>4132</i>&nbsp;     * UIResource.</b>
<i>4133</i>&nbsp;     * @see LookAndFeel#installProperty
<i>4134</i>&nbsp;     * @param propertyName String containing the name of the property
<i>4135</i>&nbsp;     * @param value Object containing the property value
<i>4136</i>&nbsp;     */
<i>4137</i>&nbsp;    void setUIProperty(String propertyName, Object value) {
<i>4138</i>&nbsp;        if (propertyName == &quot;opaque&quot;) {
<i>4139</i>&nbsp;            if (!getFlag(OPAQUE_SET)) {
<i>4140</i>&nbsp;                setOpaque(((Boolean)value).booleanValue());
<i>4141</i>&nbsp;                setFlag(OPAQUE_SET, false);
<i>4142</i>&nbsp;            }
<i>4143</i>&nbsp;        } else if (propertyName == &quot;autoscrolls&quot;) {
<i>4144</i>&nbsp;            if (!getFlag(AUTOSCROLLS_SET)) {
<i>4145</i>&nbsp;                setAutoscrolls(((Boolean)value).booleanValue());
<i>4146</i>&nbsp;                setFlag(AUTOSCROLLS_SET, false);
<i>4147</i>&nbsp;            }
<i>4148</i>&nbsp;        } else if (propertyName == &quot;focusTraversalKeysForward&quot;) {
<i>4149</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>4150</i>&nbsp;            Set&lt;AWTKeyStroke&gt; strokeSet = (Set&lt;AWTKeyStroke&gt;) value;
<i>4151</i>&nbsp;            if (!getFlag(FOCUS_TRAVERSAL_KEYS_FORWARD_SET)) {
<i>4152</i>&nbsp;                super.setFocusTraversalKeys(KeyboardFocusManager.
<i>4153</i>&nbsp;                                            FORWARD_TRAVERSAL_KEYS,
<i>4154</i>&nbsp;                                            strokeSet);
<i>4155</i>&nbsp;            }
<i>4156</i>&nbsp;        } else if (propertyName == &quot;focusTraversalKeysBackward&quot;) {
<i>4157</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>4158</i>&nbsp;            Set&lt;AWTKeyStroke&gt; strokeSet = (Set&lt;AWTKeyStroke&gt;) value;
<i>4159</i>&nbsp;            if (!getFlag(FOCUS_TRAVERSAL_KEYS_BACKWARD_SET)) {
<i>4160</i>&nbsp;                super.setFocusTraversalKeys(KeyboardFocusManager.
<i>4161</i>&nbsp;                                            BACKWARD_TRAVERSAL_KEYS,
<i>4162</i>&nbsp;                                            strokeSet);
<i>4163</i>&nbsp;            }
<i>4164</i>&nbsp;        } else {
<i>4165</i>&nbsp;            throw new IllegalArgumentException(&quot;property \&quot;&quot;+
<i>4166</i>&nbsp;                                               propertyName+ &quot;\&quot; cannot be set using this method&quot;);
<i>4167</i>&nbsp;        }
<i>4168</i>&nbsp;    }
<b class="nc"><i>4169</i>&nbsp;</b>
<b class="nc"><i>4170</i>&nbsp;</b>
<b class="nc"><i>4171</i>&nbsp;    /**</b>
<b class="nc"><i>4172</i>&nbsp;     * Sets the focus traversal keys for a given traversal operation for this</b>
<i>4173</i>&nbsp;     * Component.
<b class="nc"><i>4174</i>&nbsp;     * Refer to</b>
<i>4175</i>&nbsp;     * {@link java.awt.Component#setFocusTraversalKeys}
<i>4176</i>&nbsp;     * for a complete description of this method.
<i>4177</i>&nbsp;     * &lt;p&gt;
<i>4178</i>&nbsp;     * This method may throw a {@code ClassCastException} if any {@code Object}
<i>4179</i>&nbsp;     * in {@code keystrokes} is not an {@code AWTKeyStroke}.
<i>4180</i>&nbsp;     *
<i>4181</i>&nbsp;     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
<i>4182</i>&nbsp;     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
<i>4183</i>&nbsp;     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
<i>4184</i>&nbsp;     * @param keystrokes the Set of AWTKeyStroke for the specified operation
<i>4185</i>&nbsp;     * @see java.awt.KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
<i>4186</i>&nbsp;     * @see java.awt.KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
<i>4187</i>&nbsp;     * @see java.awt.KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
<i>4188</i>&nbsp;     * @throws IllegalArgumentException if id is not one of
<i>4189</i>&nbsp;     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
<b class="nc"><i>4190</i>&nbsp;     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or</b>
<i>4191</i>&nbsp;     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes
<i>4192</i>&nbsp;     *         contains null, or if any keystroke represents a KEY_TYPED event,
<i>4193</i>&nbsp;     *         or if any keystroke already maps to another focus traversal
<i>4194</i>&nbsp;     *         operation for this Component
<i>4195</i>&nbsp;     * @since 1.5
<i>4196</i>&nbsp;     */
<i>4197</i>&nbsp;    public void
<i>4198</i>&nbsp;        setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke&gt; keystrokes)
<i>4199</i>&nbsp;    {
<i>4200</i>&nbsp;        if (id == KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS) {
<i>4201</i>&nbsp;            setFlag(FOCUS_TRAVERSAL_KEYS_FORWARD_SET,true);
<i>4202</i>&nbsp;        } else if (id == KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS) {
<i>4203</i>&nbsp;            setFlag(FOCUS_TRAVERSAL_KEYS_BACKWARD_SET,true);
<i>4204</i>&nbsp;        }
<i>4205</i>&nbsp;        super.setFocusTraversalKeys(id,keystrokes);
<i>4206</i>&nbsp;    }
<i>4207</i>&nbsp;
<b class="nc"><i>4208</i>&nbsp;    /* --- Transitional java.awt.Component Support ---</b>
<i>4209</i>&nbsp;     * The methods and fields in this section will migrate to
<i>4210</i>&nbsp;     * java.awt.Component in the next JDK release.
<i>4211</i>&nbsp;     */
<i>4212</i>&nbsp;
<i>4213</i>&nbsp;    /**
<i>4214</i>&nbsp;     * Returns true if this component is lightweight, that is, if it doesn&#39;t
<i>4215</i>&nbsp;     * have a native window system peer.
<i>4216</i>&nbsp;     *
<i>4217</i>&nbsp;     * @param c  the {@code Component} to be checked
<i>4218</i>&nbsp;     * @return true if this component is lightweight
<i>4219</i>&nbsp;     */
<i>4220</i>&nbsp;    public static boolean isLightweightComponent(Component c) {
<i>4221</i>&nbsp;        // TODO we cannot call c.isLightweight() because it is incorrectly
<i>4222</i>&nbsp;        // overriden in DelegateContainer on osx.
<i>4223</i>&nbsp;        return AWTAccessor.getComponentAccessor().isLightweight(c);
<i>4224</i>&nbsp;    }
<i>4225</i>&nbsp;
<b class="nc"><i>4226</i>&nbsp;</b>
<b class="nc"><i>4227</i>&nbsp;    /**</b>
<i>4228</i>&nbsp;     * @deprecated As of JDK 5,
<i>4229</i>&nbsp;     * replaced by &lt;code&gt;Component.setBounds(int, int, int, int)&lt;/code&gt;.
<b class="nc"><i>4230</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>4231</i>&nbsp;     * Moves and resizes this component.</b>
<i>4232</i>&nbsp;     *
<i>4233</i>&nbsp;     * @param x  the new horizontal location
<i>4234</i>&nbsp;     * @param y  the new vertical location
<i>4235</i>&nbsp;     * @param w  the new width
<i>4236</i>&nbsp;     * @param h  the new height
<i>4237</i>&nbsp;     * @see java.awt.Component#setBounds
<i>4238</i>&nbsp;     */
<i>4239</i>&nbsp;    @Deprecated
<i>4240</i>&nbsp;    public void reshape(int x, int y, int w, int h) {
<i>4241</i>&nbsp;        super.reshape(x, y, w, h);
<i>4242</i>&nbsp;    }
<i>4243</i>&nbsp;
<i>4244</i>&nbsp;
<i>4245</i>&nbsp;    /**
<i>4246</i>&nbsp;     * Stores the bounds of this component into &quot;return value&quot;
<i>4247</i>&nbsp;     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
<b class="nc"><i>4248</i>&nbsp;     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Rectangle&lt;/code&gt;</b>
<b class="nc"><i>4249</i>&nbsp;     * is allocated.  This version of &lt;code&gt;getBounds&lt;/code&gt; is useful</b>
<i>4250</i>&nbsp;     * if the caller wants to avoid allocating a new &lt;code&gt;Rectangle&lt;/code&gt;
<i>4251</i>&nbsp;     * object on the heap.
<b class="nc"><i>4252</i>&nbsp;     *</b>
<b class="nc"><i>4253</i>&nbsp;     * @param rv the return value, modified to the component&#39;s bounds</b>
<i>4254</i>&nbsp;     * @return &lt;code&gt;rv&lt;/code&gt;; if &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>4255</i>&nbsp;     *          return a newly created &lt;code&gt;Rectangle&lt;/code&gt; with this
<i>4256</i>&nbsp;     *          component&#39;s bounds
<i>4257</i>&nbsp;     */
<i>4258</i>&nbsp;    public Rectangle getBounds(Rectangle rv) {
<i>4259</i>&nbsp;        if (rv == null) {
<i>4260</i>&nbsp;            return new Rectangle(getX(), getY(), getWidth(), getHeight());
<i>4261</i>&nbsp;        }
<i>4262</i>&nbsp;        else {
<i>4263</i>&nbsp;            rv.setBounds(getX(), getY(), getWidth(), getHeight());
<i>4264</i>&nbsp;            return rv;
<i>4265</i>&nbsp;        }
<i>4266</i>&nbsp;    }
<i>4267</i>&nbsp;
<i>4268</i>&nbsp;
<i>4269</i>&nbsp;    /**
<b class="nc"><i>4270</i>&nbsp;     * Stores the width/height of this component into &quot;return value&quot;</b>
<b class="nc"><i>4271</i>&nbsp;     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.</b>
<i>4272</i>&nbsp;     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Dimension&lt;/code&gt;
<i>4273</i>&nbsp;     * object is allocated.  This version of &lt;code&gt;getSize&lt;/code&gt;
<b class="nc"><i>4274</i>&nbsp;     * is useful if the caller wants to avoid allocating a new</b>
<b class="nc"><i>4275</i>&nbsp;     * &lt;code&gt;Dimension&lt;/code&gt; object on the heap.</b>
<i>4276</i>&nbsp;     *
<i>4277</i>&nbsp;     * @param rv the return value, modified to the component&#39;s size
<i>4278</i>&nbsp;     * @return &lt;code&gt;rv&lt;/code&gt;
<i>4279</i>&nbsp;     */
<i>4280</i>&nbsp;    public Dimension getSize(Dimension rv) {
<i>4281</i>&nbsp;        if (rv == null) {
<i>4282</i>&nbsp;            return new Dimension(getWidth(), getHeight());
<i>4283</i>&nbsp;        }
<i>4284</i>&nbsp;        else {
<i>4285</i>&nbsp;            rv.setSize(getWidth(), getHeight());
<i>4286</i>&nbsp;            return rv;
<i>4287</i>&nbsp;        }
<i>4288</i>&nbsp;    }
<b class="nc"><i>4289</i>&nbsp;</b>
<i>4290</i>&nbsp;
<i>4291</i>&nbsp;    /**
<i>4292</i>&nbsp;     * Stores the x,y origin of this component into &quot;return value&quot;
<i>4293</i>&nbsp;     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
<i>4294</i>&nbsp;     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Point&lt;/code&gt;
<i>4295</i>&nbsp;     * is allocated.  This version of &lt;code&gt;getLocation&lt;/code&gt; is useful
<i>4296</i>&nbsp;     * if the caller wants to avoid allocating a new &lt;code&gt;Point&lt;/code&gt;
<i>4297</i>&nbsp;     * object on the heap.
<i>4298</i>&nbsp;     *
<i>4299</i>&nbsp;     * @param rv the return value, modified to the component&#39;s location
<i>4300</i>&nbsp;     * @return &lt;code&gt;rv&lt;/code&gt;
<b class="nc"><i>4301</i>&nbsp;     */</b>
<i>4302</i>&nbsp;    public Point getLocation(Point rv) {
<i>4303</i>&nbsp;        if (rv == null) {
<i>4304</i>&nbsp;            return new Point(getX(), getY());
<i>4305</i>&nbsp;        }
<i>4306</i>&nbsp;        else {
<i>4307</i>&nbsp;            rv.setLocation(getX(), getY());
<i>4308</i>&nbsp;            return rv;
<i>4309</i>&nbsp;        }
<i>4310</i>&nbsp;    }
<i>4311</i>&nbsp;
<i>4312</i>&nbsp;
<b class="nc"><i>4313</i>&nbsp;    /**</b>
<i>4314</i>&nbsp;     * Returns the current x coordinate of the component&#39;s origin.
<i>4315</i>&nbsp;     * This method is preferable to writing
<i>4316</i>&nbsp;     * &lt;code&gt;component.getBounds().x&lt;/code&gt;, or
<i>4317</i>&nbsp;     * &lt;code&gt;component.getLocation().x&lt;/code&gt; because it doesn&#39;t cause any
<i>4318</i>&nbsp;     * heap allocations.
<i>4319</i>&nbsp;     *
<i>4320</i>&nbsp;     * @return the current x coordinate of the component&#39;s origin
<i>4321</i>&nbsp;     */
<i>4322</i>&nbsp;    @BeanProperty(bound = false)
<i>4323</i>&nbsp;    public int getX() { return super.getX(); }
<i>4324</i>&nbsp;
<b class="nc"><i>4325</i>&nbsp;</b>
<i>4326</i>&nbsp;    /**
<i>4327</i>&nbsp;     * Returns the current y coordinate of the component&#39;s origin.
<i>4328</i>&nbsp;     * This method is preferable to writing
<i>4329</i>&nbsp;     * &lt;code&gt;component.getBounds().y&lt;/code&gt;, or
<i>4330</i>&nbsp;     * &lt;code&gt;component.getLocation().y&lt;/code&gt; because it doesn&#39;t cause any
<i>4331</i>&nbsp;     * heap allocations.
<i>4332</i>&nbsp;     *
<i>4333</i>&nbsp;     * @return the current y coordinate of the component&#39;s origin
<i>4334</i>&nbsp;     */
<i>4335</i>&nbsp;    @BeanProperty(bound = false)
<i>4336</i>&nbsp;    public int getY() { return super.getY(); }
<i>4337</i>&nbsp;
<i>4338</i>&nbsp;
<i>4339</i>&nbsp;    /**
<i>4340</i>&nbsp;     * Returns the current width of this component.
<i>4341</i>&nbsp;     * This method is preferable to writing
<i>4342</i>&nbsp;     * &lt;code&gt;component.getBounds().width&lt;/code&gt;, or
<b class="nc"><i>4343</i>&nbsp;     * &lt;code&gt;component.getSize().width&lt;/code&gt; because it doesn&#39;t cause any</b>
<i>4344</i>&nbsp;     * heap allocations.
<i>4345</i>&nbsp;     *
<i>4346</i>&nbsp;     * @return the current width of this component
<i>4347</i>&nbsp;     */
<i>4348</i>&nbsp;    @BeanProperty(bound = false)
<i>4349</i>&nbsp;    public int getWidth() { return super.getWidth(); }
<i>4350</i>&nbsp;
<i>4351</i>&nbsp;
<i>4352</i>&nbsp;    /**
<i>4353</i>&nbsp;     * Returns the current height of this component.
<i>4354</i>&nbsp;     * This method is preferable to writing
<i>4355</i>&nbsp;     * &lt;code&gt;component.getBounds().height&lt;/code&gt;, or
<i>4356</i>&nbsp;     * &lt;code&gt;component.getSize().height&lt;/code&gt; because it doesn&#39;t cause any
<i>4357</i>&nbsp;     * heap allocations.
<i>4358</i>&nbsp;     *
<i>4359</i>&nbsp;     * @return the current height of this component
<i>4360</i>&nbsp;     */
<i>4361</i>&nbsp;    @BeanProperty(bound = false)
<i>4362</i>&nbsp;    public int getHeight() { return super.getHeight(); }
<i>4363</i>&nbsp;
<b class="nc"><i>4364</i>&nbsp;    /**</b>
<b class="nc"><i>4365</i>&nbsp;     * Returns true if this component is completely opaque.</b>
<b class="nc"><i>4366</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>4367</i>&nbsp;     * An opaque component paints every pixel within its</b>
<i>4368</i>&nbsp;     * rectangular bounds. A non-opaque component paints only a subset of
<i>4369</i>&nbsp;     * its pixels or none at all, allowing the pixels underneath it to
<i>4370</i>&nbsp;     * &quot;show through&quot;.  Therefore, a component that does not fully paint
<i>4371</i>&nbsp;     * its pixels provides a degree of transparency.
<i>4372</i>&nbsp;     * &lt;p&gt;
<i>4373</i>&nbsp;     * Subclasses that guarantee to always completely paint their contents
<i>4374</i>&nbsp;     * should override this method and return true.
<i>4375</i>&nbsp;     *
<i>4376</i>&nbsp;     * @return true if this component is completely opaque
<i>4377</i>&nbsp;     * @see #setOpaque
<i>4378</i>&nbsp;     */
<i>4379</i>&nbsp;    public boolean isOpaque() {
<i>4380</i>&nbsp;        return getFlag(IS_OPAQUE);
<i>4381</i>&nbsp;    }
<i>4382</i>&nbsp;
<i>4383</i>&nbsp;    /**
<i>4384</i>&nbsp;     * If true the component paints every pixel within its bounds.
<i>4385</i>&nbsp;     * Otherwise, the component may not paint some or all of its
<i>4386</i>&nbsp;     * pixels, allowing the underlying pixels to show through.
<i>4387</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>4388</i>&nbsp;     * The default value of this property is false for &lt;code&gt;JComponent&lt;/code&gt;.</b>
<i>4389</i>&nbsp;     * However, the default value for this property on most standard
<b class="nc"><i>4390</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; subclasses (such as &lt;code&gt;JButton&lt;/code&gt; and</b>
<b class="nc"><i>4391</i>&nbsp;     * &lt;code&gt;JTree&lt;/code&gt;) is look-and-feel dependent.</b>
<i>4392</i>&nbsp;     *
<i>4393</i>&nbsp;     * @param isOpaque  true if this component should be opaque
<b class="nc"><i>4394</i>&nbsp;     * @see #isOpaque</b>
<b class="nc"><i>4395</i>&nbsp;     */</b>
<b class="nc"><i>4396</i>&nbsp;    @BeanProperty(expert = true, description</b>
<b class="nc"><i>4397</i>&nbsp;            = &quot;The component&#39;s opacity&quot;)</b>
<i>4398</i>&nbsp;    public void setOpaque(boolean isOpaque) {
<b class="nc"><i>4399</i>&nbsp;        boolean oldValue = getFlag(IS_OPAQUE);</b>
<b class="nc"><i>4400</i>&nbsp;        setFlag(IS_OPAQUE, isOpaque);</b>
<i>4401</i>&nbsp;        setFlag(OPAQUE_SET, true);
<b class="nc"><i>4402</i>&nbsp;        firePropertyChange(&quot;opaque&quot;, oldValue, isOpaque);</b>
<i>4403</i>&nbsp;    }
<i>4404</i>&nbsp;
<i>4405</i>&nbsp;
<b class="nc"><i>4406</i>&nbsp;    /**</b>
<i>4407</i>&nbsp;     * If the specified rectangle is completely obscured by any of this
<i>4408</i>&nbsp;     * component&#39;s opaque children then returns true.  Only direct children
<i>4409</i>&nbsp;     * are considered, more distant descendants are ignored.  A
<i>4410</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; is opaque if
<b class="nc"><i>4411</i>&nbsp;     * &lt;code&gt;JComponent.isOpaque()&lt;/code&gt; returns true, other lightweight</b>
<i>4412</i>&nbsp;     * components are always considered transparent, and heavyweight components
<i>4413</i>&nbsp;     * are always considered opaque.
<i>4414</i>&nbsp;     *
<i>4415</i>&nbsp;     * @param x  x value of specified rectangle
<b class="nc"><i>4416</i>&nbsp;     * @param y  y value of specified rectangle</b>
<i>4417</i>&nbsp;     * @param width  width of specified rectangle
<i>4418</i>&nbsp;     * @param height height of specified rectangle
<i>4419</i>&nbsp;     * @return true if the specified rectangle is obscured by an opaque child
<i>4420</i>&nbsp;     */
<i>4421</i>&nbsp;    boolean rectangleIsObscured(int x,int y,int width,int height)
<i>4422</i>&nbsp;    {
<i>4423</i>&nbsp;        int numChildren = getComponentCount();
<i>4424</i>&nbsp;
<i>4425</i>&nbsp;        for(int i = 0; i &lt; numChildren; i++) {
<i>4426</i>&nbsp;            Component child = getComponent(i);
<i>4427</i>&nbsp;            int cx, cy, cw, ch;
<i>4428</i>&nbsp;
<i>4429</i>&nbsp;            cx = child.getX();
<i>4430</i>&nbsp;            cy = child.getY();
<i>4431</i>&nbsp;            cw = child.getWidth();
<i>4432</i>&nbsp;            ch = child.getHeight();
<i>4433</i>&nbsp;
<b class="nc"><i>4434</i>&nbsp;            if (x &gt;= cx &amp;&amp; (x + width) &lt;= (cx + cw) &amp;&amp;</b>
<b class="nc"><i>4435</i>&nbsp;                y &gt;= cy &amp;&amp; (y + height) &lt;= (cy + ch) &amp;&amp; child.isVisible()) {</b>
<i>4436</i>&nbsp;
<b class="nc"><i>4437</i>&nbsp;                if(child instanceof JComponent) {</b>
<b class="nc"><i>4438</i>&nbsp;//                  System.out.println(&quot;A) checking opaque: &quot; + ((JComponent)child).isOpaque() + &quot;  &quot; + child);</b>
<i>4439</i>&nbsp;//                  System.out.print(&quot;B) &quot;);
<b class="nc"><i>4440</i>&nbsp;//                  Thread.dumpStack();</b>
<b class="nc"><i>4441</i>&nbsp;                    return child.isOpaque();</b>
<b class="nc"><i>4442</i>&nbsp;                } else {</b>
<b class="nc"><i>4443</i>&nbsp;                    /** Sometimes a heavy weight can have a bound larger than its peer size</b>
<i>4444</i>&nbsp;                     *  so we should always draw under heavy weights
<i>4445</i>&nbsp;                     */
<i>4446</i>&nbsp;                    return false;
<i>4447</i>&nbsp;                }
<i>4448</i>&nbsp;            }
<i>4449</i>&nbsp;        }
<i>4450</i>&nbsp;
<i>4451</i>&nbsp;        return false;
<i>4452</i>&nbsp;    }
<i>4453</i>&nbsp;
<i>4454</i>&nbsp;
<i>4455</i>&nbsp;    /**
<i>4456</i>&nbsp;     * Returns the &lt;code&gt;Component&lt;/code&gt;&#39;s &quot;visible rect rectangle&quot; -  the
<i>4457</i>&nbsp;     * intersection of the visible rectangles for the component &lt;code&gt;c&lt;/code&gt;
<i>4458</i>&nbsp;     * and all of its ancestors.  The return value is stored in
<i>4459</i>&nbsp;     * &lt;code&gt;visibleRect&lt;/code&gt;.
<i>4460</i>&nbsp;     *
<b class="nc"><i>4461</i>&nbsp;     * @param c  the component</b>
<i>4462</i>&nbsp;     * @param visibleRect  a &lt;code&gt;Rectangle&lt;/code&gt; computed as the
<i>4463</i>&nbsp;     *          intersection of all visible rectangles for the component
<i>4464</i>&nbsp;     *          &lt;code&gt;c&lt;/code&gt; and all of its ancestors -- this is the
<i>4465</i>&nbsp;     *          return value for this method
<i>4466</i>&nbsp;     * @see #getVisibleRect
<i>4467</i>&nbsp;     */
<i>4468</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>4469</i>&nbsp;    static final void computeVisibleRect(Component c, Rectangle visibleRect) {
<i>4470</i>&nbsp;        Container p = c.getParent();
<i>4471</i>&nbsp;        Rectangle bounds = c.getBounds();
<i>4472</i>&nbsp;
<i>4473</i>&nbsp;        if (p == null || p instanceof Window || p instanceof Applet) {
<b class="nc"><i>4474</i>&nbsp;            visibleRect.setBounds(0, 0, bounds.width, bounds.height);</b>
<i>4475</i>&nbsp;        } else {
<b class="nc"><i>4476</i>&nbsp;            computeVisibleRect(p, visibleRect);</b>
<b class="nc"><i>4477</i>&nbsp;            visibleRect.x -= bounds.x;</b>
<i>4478</i>&nbsp;            visibleRect.y -= bounds.y;
<i>4479</i>&nbsp;            SwingUtilities.computeIntersection(0,0,bounds.width,bounds.height,visibleRect);
<i>4480</i>&nbsp;        }
<i>4481</i>&nbsp;    }
<i>4482</i>&nbsp;
<i>4483</i>&nbsp;
<i>4484</i>&nbsp;    /**
<i>4485</i>&nbsp;     * Returns the &lt;code&gt;Component&lt;/code&gt;&#39;s &quot;visible rect rectangle&quot; -  the
<i>4486</i>&nbsp;     * intersection of the visible rectangles for this component
<i>4487</i>&nbsp;     * and all of its ancestors.  The return value is stored in
<i>4488</i>&nbsp;     * &lt;code&gt;visibleRect&lt;/code&gt;.
<i>4489</i>&nbsp;     *
<i>4490</i>&nbsp;     * @param visibleRect a &lt;code&gt;Rectangle&lt;/code&gt; computed as the
<i>4491</i>&nbsp;     *          intersection of all visible rectangles for this
<b class="nc"><i>4492</i>&nbsp;     *          component and all of its ancestors -- this is the return</b>
<i>4493</i>&nbsp;     *          value for this method
<i>4494</i>&nbsp;     * @see #getVisibleRect
<i>4495</i>&nbsp;     */
<i>4496</i>&nbsp;    public void computeVisibleRect(Rectangle visibleRect) {
<i>4497</i>&nbsp;        computeVisibleRect(this, visibleRect);
<i>4498</i>&nbsp;    }
<i>4499</i>&nbsp;
<i>4500</i>&nbsp;
<i>4501</i>&nbsp;    /**
<i>4502</i>&nbsp;     * Returns the &lt;code&gt;Component&lt;/code&gt;&#39;s &quot;visible rectangle&quot; -  the
<i>4503</i>&nbsp;     * intersection of this component&#39;s visible rectangle,
<i>4504</i>&nbsp;     * &lt;code&gt;new Rectangle(0, 0, getWidth(), getHeight())&lt;/code&gt;,
<i>4505</i>&nbsp;     * and all of its ancestors&#39; visible rectangles.
<i>4506</i>&nbsp;     *
<i>4507</i>&nbsp;     * @return the visible rectangle
<b class="nc"><i>4508</i>&nbsp;     */</b>
<i>4509</i>&nbsp;    @BeanProperty(bound = false)
<i>4510</i>&nbsp;    public Rectangle getVisibleRect() {
<i>4511</i>&nbsp;        Rectangle visibleRect = new Rectangle();
<i>4512</i>&nbsp;
<i>4513</i>&nbsp;        computeVisibleRect(visibleRect);
<b class="nc"><i>4514</i>&nbsp;        return visibleRect;</b>
<i>4515</i>&nbsp;    }
<i>4516</i>&nbsp;
<i>4517</i>&nbsp;    /**
<i>4518</i>&nbsp;     * Support for reporting bound property changes for boolean properties.
<i>4519</i>&nbsp;     * This method can be called when a bound property has changed and it will
<i>4520</i>&nbsp;     * send the appropriate PropertyChangeEvent to any registered
<i>4521</i>&nbsp;     * PropertyChangeListeners.
<i>4522</i>&nbsp;     *
<i>4523</i>&nbsp;     * @param propertyName the property whose value has changed
<i>4524</i>&nbsp;     * @param oldValue the property&#39;s previous value
<i>4525</i>&nbsp;     * @param newValue the property&#39;s new value
<i>4526</i>&nbsp;     */
<i>4527</i>&nbsp;    public void firePropertyChange(String propertyName,
<i>4528</i>&nbsp;                                   boolean oldValue, boolean newValue) {
<i>4529</i>&nbsp;        super.firePropertyChange(propertyName, oldValue, newValue);
<i>4530</i>&nbsp;    }
<i>4531</i>&nbsp;
<b class="nc"><i>4532</i>&nbsp;</b>
<i>4533</i>&nbsp;    /**
<i>4534</i>&nbsp;     * Support for reporting bound property changes for integer properties.
<b class="nc"><i>4535</i>&nbsp;     * This method can be called when a bound property has changed and it will</b>
<i>4536</i>&nbsp;     * send the appropriate PropertyChangeEvent to any registered
<i>4537</i>&nbsp;     * PropertyChangeListeners.
<i>4538</i>&nbsp;     *
<i>4539</i>&nbsp;     * @param propertyName the property whose value has changed
<i>4540</i>&nbsp;     * @param oldValue the property&#39;s previous value
<i>4541</i>&nbsp;     * @param newValue the property&#39;s new value
<i>4542</i>&nbsp;     */
<i>4543</i>&nbsp;    public void firePropertyChange(String propertyName,
<i>4544</i>&nbsp;                                      int oldValue, int newValue) {
<i>4545</i>&nbsp;        super.firePropertyChange(propertyName, oldValue, newValue);
<b class="nc"><i>4546</i>&nbsp;    }</b>
<b class="nc"><i>4547</i>&nbsp;</b>
<i>4548</i>&nbsp;    // XXX This method is implemented as a workaround to a JLS issue with ambiguous
<b class="nc"><i>4549</i>&nbsp;    // methods. This should be removed once 4758654 is resolved.</b>
<i>4550</i>&nbsp;    public void firePropertyChange(String propertyName, char oldValue, char newValue) {
<i>4551</i>&nbsp;        super.firePropertyChange(propertyName, oldValue, newValue);
<i>4552</i>&nbsp;    }
<i>4553</i>&nbsp;
<i>4554</i>&nbsp;    /**
<i>4555</i>&nbsp;     * Supports reporting constrained property changes.
<i>4556</i>&nbsp;     * This method can be called when a constrained property has changed
<i>4557</i>&nbsp;     * and it will send the appropriate &lt;code&gt;PropertyChangeEvent&lt;/code&gt;
<i>4558</i>&nbsp;     * to any registered &lt;code&gt;VetoableChangeListeners&lt;/code&gt;.
<i>4559</i>&nbsp;     *
<i>4560</i>&nbsp;     * @param propertyName  the name of the property that was listened on
<b class="nc"><i>4561</i>&nbsp;     * @param oldValue  the old value of the property</b>
<i>4562</i>&nbsp;     * @param newValue  the new value of the property
<i>4563</i>&nbsp;     * @exception java.beans.PropertyVetoException when the attempt to set the
<b class="nc"><i>4564</i>&nbsp;     *          property is vetoed by the component</b>
<i>4565</i>&nbsp;     */
<i>4566</i>&nbsp;    protected void fireVetoableChange(String propertyName, Object oldValue, Object newValue)
<i>4567</i>&nbsp;        throws java.beans.PropertyVetoException
<i>4568</i>&nbsp;    {
<i>4569</i>&nbsp;        if (vetoableChangeSupport == null) {
<i>4570</i>&nbsp;            return;
<i>4571</i>&nbsp;        }
<i>4572</i>&nbsp;        vetoableChangeSupport.fireVetoableChange(propertyName, oldValue, newValue);
<i>4573</i>&nbsp;    }
<i>4574</i>&nbsp;
<i>4575</i>&nbsp;
<i>4576</i>&nbsp;    /**
<i>4577</i>&nbsp;     * Adds a &lt;code&gt;VetoableChangeListener&lt;/code&gt; to the listener list.
<i>4578</i>&nbsp;     * The listener is registered for all properties.
<i>4579</i>&nbsp;     *
<i>4580</i>&nbsp;     * @param listener  the &lt;code&gt;VetoableChangeListener&lt;/code&gt; to be added
<i>4581</i>&nbsp;     */
<b class="nc"><i>4582</i>&nbsp;    public synchronized void addVetoableChangeListener(VetoableChangeListener listener) {</b>
<b class="nc"><i>4583</i>&nbsp;        if (vetoableChangeSupport == null) {</b>
<i>4584</i>&nbsp;            vetoableChangeSupport = new java.beans.VetoableChangeSupport(this);
<b class="nc"><i>4585</i>&nbsp;        }</b>
<i>4586</i>&nbsp;        vetoableChangeSupport.addVetoableChangeListener(listener);
<i>4587</i>&nbsp;    }
<i>4588</i>&nbsp;
<i>4589</i>&nbsp;
<i>4590</i>&nbsp;    /**
<i>4591</i>&nbsp;     * Removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; from the listener list.
<i>4592</i>&nbsp;     * This removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; that was registered
<i>4593</i>&nbsp;     * for all properties.
<i>4594</i>&nbsp;     *
<i>4595</i>&nbsp;     * @param listener  the &lt;code&gt;VetoableChangeListener&lt;/code&gt; to be removed
<i>4596</i>&nbsp;     */
<i>4597</i>&nbsp;    public synchronized void removeVetoableChangeListener(VetoableChangeListener listener) {
<i>4598</i>&nbsp;        if (vetoableChangeSupport == null) {
<b class="nc"><i>4599</i>&nbsp;            return;</b>
<b class="nc"><i>4600</i>&nbsp;        }</b>
<b class="nc"><i>4601</i>&nbsp;        vetoableChangeSupport.removeVetoableChangeListener(listener);</b>
<i>4602</i>&nbsp;    }
<i>4603</i>&nbsp;
<b class="nc"><i>4604</i>&nbsp;</b>
<i>4605</i>&nbsp;    /**
<i>4606</i>&nbsp;     * Returns an array of all the vetoable change listeners
<i>4607</i>&nbsp;     * registered on this component.
<b class="nc"><i>4608</i>&nbsp;     *</b>
<b class="nc"><i>4609</i>&nbsp;     * @return all of the component&#39;s &lt;code&gt;VetoableChangeListener&lt;/code&gt;s</b>
<i>4610</i>&nbsp;     *         or an empty
<i>4611</i>&nbsp;     *         array if no vetoable change listeners are currently registered
<i>4612</i>&nbsp;     *
<i>4613</i>&nbsp;     * @see #addVetoableChangeListener
<i>4614</i>&nbsp;     * @see #removeVetoableChangeListener
<i>4615</i>&nbsp;     *
<i>4616</i>&nbsp;     * @since 1.4
<i>4617</i>&nbsp;     */
<i>4618</i>&nbsp;    @BeanProperty(bound = false)
<i>4619</i>&nbsp;    public synchronized VetoableChangeListener[] getVetoableChangeListeners() {
<i>4620</i>&nbsp;        if (vetoableChangeSupport == null) {
<i>4621</i>&nbsp;            return new VetoableChangeListener[0];
<i>4622</i>&nbsp;        }
<b class="nc"><i>4623</i>&nbsp;        return vetoableChangeSupport.getVetoableChangeListeners();</b>
<b class="nc"><i>4624</i>&nbsp;    }</b>
<b class="nc"><i>4625</i>&nbsp;</b>
<b class="nc"><i>4626</i>&nbsp;</b>
<i>4627</i>&nbsp;    /**
<i>4628</i>&nbsp;     * Returns the top-level ancestor of this component (either the
<b class="nc"><i>4629</i>&nbsp;     * containing &lt;code&gt;Window&lt;/code&gt; or &lt;code&gt;Applet&lt;/code&gt;),</b>
<i>4630</i>&nbsp;     * or &lt;code&gt;null&lt;/code&gt; if this component has not
<i>4631</i>&nbsp;     * been added to any container.
<i>4632</i>&nbsp;     *
<i>4633</i>&nbsp;     * @return the top-level &lt;code&gt;Container&lt;/code&gt; that this component is in,
<i>4634</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if not in any container
<i>4635</i>&nbsp;     */
<i>4636</i>&nbsp;    @BeanProperty(bound = false)
<i>4637</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>4638</i>&nbsp;    public Container getTopLevelAncestor() {
<i>4639</i>&nbsp;        for(Container p = this; p != null; p = p.getParent()) {
<b class="nc"><i>4640</i>&nbsp;            if(p instanceof Window || p instanceof Applet) {</b>
<b class="nc"><i>4641</i>&nbsp;                return p;</b>
<i>4642</i>&nbsp;            }
<i>4643</i>&nbsp;        }
<b class="nc"><i>4644</i>&nbsp;        return null;</b>
<b class="nc"><i>4645</i>&nbsp;    }</b>
<b class="nc"><i>4646</i>&nbsp;</b>
<b class="nc"><i>4647</i>&nbsp;    private AncestorNotifier getAncestorNotifier() {</b>
<i>4648</i>&nbsp;        return (AncestorNotifier)
<i>4649</i>&nbsp;            getClientProperty(JComponent_ANCESTOR_NOTIFIER);
<i>4650</i>&nbsp;    }
<i>4651</i>&nbsp;
<i>4652</i>&nbsp;    /**
<i>4653</i>&nbsp;     * Registers &lt;code&gt;listener&lt;/code&gt; so that it will receive
<i>4654</i>&nbsp;     * &lt;code&gt;AncestorEvents&lt;/code&gt; when it or any of its ancestors
<i>4655</i>&nbsp;     * move or are made visible or invisible.
<i>4656</i>&nbsp;     * Events are also sent when the component or its ancestors are added
<i>4657</i>&nbsp;     * or removed from the containment hierarchy.
<i>4658</i>&nbsp;     *
<i>4659</i>&nbsp;     * @param listener  the &lt;code&gt;AncestorListener&lt;/code&gt; to register
<i>4660</i>&nbsp;     * @see AncestorEvent
<i>4661</i>&nbsp;     */
<i>4662</i>&nbsp;    public void addAncestorListener(AncestorListener listener) {
<i>4663</i>&nbsp;        AncestorNotifier ancestorNotifier = getAncestorNotifier();
<i>4664</i>&nbsp;        if (ancestorNotifier == null) {
<b class="nc"><i>4665</i>&nbsp;            ancestorNotifier = new AncestorNotifier(this);</b>
<b class="nc"><i>4666</i>&nbsp;            putClientProperty(JComponent_ANCESTOR_NOTIFIER,</b>
<b class="nc"><i>4667</i>&nbsp;                              ancestorNotifier);</b>
<i>4668</i>&nbsp;        }
<b class="nc"><i>4669</i>&nbsp;        ancestorNotifier.addAncestorListener(listener);</b>
<i>4670</i>&nbsp;    }
<i>4671</i>&nbsp;
<i>4672</i>&nbsp;    /**
<i>4673</i>&nbsp;     * Unregisters &lt;code&gt;listener&lt;/code&gt; so that it will no longer receive
<i>4674</i>&nbsp;     * &lt;code&gt;AncestorEvents&lt;/code&gt;.
<i>4675</i>&nbsp;     *
<i>4676</i>&nbsp;     * @param listener  the &lt;code&gt;AncestorListener&lt;/code&gt; to be removed
<i>4677</i>&nbsp;     * @see #addAncestorListener
<i>4678</i>&nbsp;     */
<i>4679</i>&nbsp;    public void removeAncestorListener(AncestorListener listener) {
<i>4680</i>&nbsp;        AncestorNotifier ancestorNotifier = getAncestorNotifier();
<i>4681</i>&nbsp;        if (ancestorNotifier == null) {
<i>4682</i>&nbsp;            return;
<i>4683</i>&nbsp;        }
<i>4684</i>&nbsp;        ancestorNotifier.removeAncestorListener(listener);
<i>4685</i>&nbsp;        if (ancestorNotifier.listenerList.getListenerList().length == 0) {
<i>4686</i>&nbsp;            ancestorNotifier.removeAllListeners();
<i>4687</i>&nbsp;            putClientProperty(JComponent_ANCESTOR_NOTIFIER, null);
<i>4688</i>&nbsp;        }
<i>4689</i>&nbsp;    }
<i>4690</i>&nbsp;
<i>4691</i>&nbsp;    /**
<i>4692</i>&nbsp;     * Returns an array of all the ancestor listeners
<i>4693</i>&nbsp;     * registered on this component.
<i>4694</i>&nbsp;     *
<i>4695</i>&nbsp;     * @return all of the component&#39;s &lt;code&gt;AncestorListener&lt;/code&gt;s
<i>4696</i>&nbsp;     *         or an empty
<i>4697</i>&nbsp;     *         array if no ancestor listeners are currently registered
<i>4698</i>&nbsp;     *
<i>4699</i>&nbsp;     * @see #addAncestorListener
<i>4700</i>&nbsp;     * @see #removeAncestorListener
<i>4701</i>&nbsp;     *
<i>4702</i>&nbsp;     * @since 1.4
<i>4703</i>&nbsp;     */
<i>4704</i>&nbsp;    @BeanProperty(bound = false)
<i>4705</i>&nbsp;    public AncestorListener[] getAncestorListeners() {
<i>4706</i>&nbsp;        AncestorNotifier ancestorNotifier = getAncestorNotifier();
<i>4707</i>&nbsp;        if (ancestorNotifier == null) {
<i>4708</i>&nbsp;            return new AncestorListener[0];
<b class="nc"><i>4709</i>&nbsp;        }</b>
<i>4710</i>&nbsp;        return ancestorNotifier.getAncestorListeners();
<b class="nc"><i>4711</i>&nbsp;    }</b>
<i>4712</i>&nbsp;
<b class="nc"><i>4713</i>&nbsp;    /**</b>
<i>4714</i>&nbsp;     * Returns an array of all the objects currently registered
<b class="nc"><i>4715</i>&nbsp;     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s</b>
<i>4716</i>&nbsp;     * upon this &lt;code&gt;JComponent&lt;/code&gt;.
<b class="nc"><i>4717</i>&nbsp;     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the</b>
<i>4718</i>&nbsp;     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
<b class="nc"><i>4719</i>&nbsp;     *</b>
<i>4720</i>&nbsp;     * &lt;p&gt;
<i>4721</i>&nbsp;     *
<b class="nc"><i>4722</i>&nbsp;     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument</b>
<i>4723</i>&nbsp;     * with a class literal,
<i>4724</i>&nbsp;     * such as
<b class="nc"><i>4725</i>&nbsp;     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.</b>
<b class="nc"><i>4726</i>&nbsp;     * For example, you can query a</b>
<i>4727</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
<b class="nc"><i>4728</i>&nbsp;     * for its mouse listeners with the following code:</b>
<i>4729</i>&nbsp;     * &lt;pre&gt;MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));&lt;/pre&gt;
<i>4730</i>&nbsp;     * If no such listeners exist, this method returns an empty array.
<i>4731</i>&nbsp;     *
<i>4732</i>&nbsp;     * @param listenerType the type of listeners requested; this parameter
<i>4733</i>&nbsp;     *          should specify an interface that descends from
<i>4734</i>&nbsp;     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
<i>4735</i>&nbsp;     * @return an array of all objects registered as
<i>4736</i>&nbsp;     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
<i>4737</i>&nbsp;     *          or an empty array if no such
<i>4738</i>&nbsp;     *          listeners have been added
<i>4739</i>&nbsp;     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
<i>4740</i>&nbsp;     *          doesn&#39;t specify a class or interface that implements
<b class="nc"><i>4741</i>&nbsp;     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;</b>
<b class="nc"><i>4742</i>&nbsp;     *</b>
<i>4743</i>&nbsp;     * @since 1.3
<b class="nc"><i>4744</i>&nbsp;     *</b>
<b class="nc"><i>4745</i>&nbsp;     * @see #getVetoableChangeListeners</b>
<i>4746</i>&nbsp;     * @see #getAncestorListeners
<i>4747</i>&nbsp;     */
<i>4748</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // Casts to (T[])
<i>4749</i>&nbsp;    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<i>4750</i>&nbsp;        T[] result;
<i>4751</i>&nbsp;        if (listenerType == AncestorListener.class) {
<i>4752</i>&nbsp;            // AncestorListeners are handled by the AncestorNotifier
<i>4753</i>&nbsp;            result = (T[])getAncestorListeners();
<i>4754</i>&nbsp;        }
<i>4755</i>&nbsp;        else if (listenerType == VetoableChangeListener.class) {
<i>4756</i>&nbsp;            // VetoableChangeListeners are handled by VetoableChangeSupport
<i>4757</i>&nbsp;            result = (T[])getVetoableChangeListeners();
<i>4758</i>&nbsp;        }
<b class="nc"><i>4759</i>&nbsp;        else if (listenerType == PropertyChangeListener.class) {</b>
<i>4760</i>&nbsp;            // PropertyChangeListeners are handled by PropertyChangeSupport
<i>4761</i>&nbsp;            result = (T[])getPropertyChangeListeners();
<i>4762</i>&nbsp;        }
<b class="nc"><i>4763</i>&nbsp;        else {</b>
<i>4764</i>&nbsp;            result = listenerList.getListeners(listenerType);
<b class="nc"><i>4765</i>&nbsp;        }</b>
<b class="nc"><i>4766</i>&nbsp;</b>
<i>4767</i>&nbsp;        if (result.length == 0) {
<b class="nc"><i>4768</i>&nbsp;            return super.getListeners(listenerType);</b>
<b class="nc"><i>4769</i>&nbsp;        }</b>
<b class="nc"><i>4770</i>&nbsp;        return result;</b>
<i>4771</i>&nbsp;    }
<b class="nc"><i>4772</i>&nbsp;</b>
<b class="nc"><i>4773</i>&nbsp;    /**</b>
<i>4774</i>&nbsp;     * Notifies this component that it now has a parent component.
<i>4775</i>&nbsp;     * When this method is invoked, the chain of parent components is
<i>4776</i>&nbsp;     * set up with &lt;code&gt;KeyboardAction&lt;/code&gt; event listeners.
<i>4777</i>&nbsp;     * This method is called by the toolkit internally and should
<i>4778</i>&nbsp;     * not be called directly by programs.
<i>4779</i>&nbsp;     *
<i>4780</i>&nbsp;     * @see #registerKeyboardAction
<i>4781</i>&nbsp;     */
<i>4782</i>&nbsp;    public void addNotify() {
<i>4783</i>&nbsp;        super.addNotify();
<i>4784</i>&nbsp;        firePropertyChange(&quot;ancestor&quot;, null, getParent());
<i>4785</i>&nbsp;
<i>4786</i>&nbsp;        registerWithKeyboardManager(false);
<i>4787</i>&nbsp;        registerNextFocusableComponent();
<i>4788</i>&nbsp;    }
<i>4789</i>&nbsp;
<i>4790</i>&nbsp;
<i>4791</i>&nbsp;    /**
<i>4792</i>&nbsp;     * Notifies this component that it no longer has a parent component.
<b class="nc"><i>4793</i>&nbsp;     * When this method is invoked, any &lt;code&gt;KeyboardAction&lt;/code&gt;s</b>
<b class="nc"><i>4794</i>&nbsp;     * set up in the chain of parent components are removed.</b>
<i>4795</i>&nbsp;     * This method is called by the toolkit internally and should
<i>4796</i>&nbsp;     * not be called directly by programs.
<i>4797</i>&nbsp;     *
<i>4798</i>&nbsp;     * @see #registerKeyboardAction
<i>4799</i>&nbsp;     */
<i>4800</i>&nbsp;    public void removeNotify() {
<i>4801</i>&nbsp;        super.removeNotify();
<i>4802</i>&nbsp;        // This isn&#39;t strictly correct.  The event shouldn&#39;t be
<i>4803</i>&nbsp;        // fired until *after* the parent is set to null.  But
<i>4804</i>&nbsp;        // we only get notified before that happens
<i>4805</i>&nbsp;        firePropertyChange(&quot;ancestor&quot;, getParent(), null);
<i>4806</i>&nbsp;
<i>4807</i>&nbsp;        unregisterWithKeyboardManager();
<i>4808</i>&nbsp;        deregisterNextFocusableComponent();
<b class="nc"><i>4809</i>&nbsp;</b>
<i>4810</i>&nbsp;        if (getCreatedDoubleBuffer()) {
<i>4811</i>&nbsp;            RepaintManager.currentManager(this).resetDoubleBuffer();
<i>4812</i>&nbsp;            setCreatedDoubleBuffer(false);
<i>4813</i>&nbsp;        }
<i>4814</i>&nbsp;        if (autoscrolls) {
<i>4815</i>&nbsp;            Autoscroller.stop(this);
<i>4816</i>&nbsp;        }
<i>4817</i>&nbsp;    }
<i>4818</i>&nbsp;
<i>4819</i>&nbsp;
<i>4820</i>&nbsp;    /**
<i>4821</i>&nbsp;     * Adds the specified region to the dirty region list if the component
<i>4822</i>&nbsp;     * is showing.  The component will be repainted after all of the
<i>4823</i>&nbsp;     * currently pending events have been dispatched.
<i>4824</i>&nbsp;     *
<i>4825</i>&nbsp;     * @param tm  this parameter is not used
<i>4826</i>&nbsp;     * @param x  the x value of the dirty region
<i>4827</i>&nbsp;     * @param y  the y value of the dirty region
<i>4828</i>&nbsp;     * @param width  the width of the dirty region
<i>4829</i>&nbsp;     * @param height  the height of the dirty region
<i>4830</i>&nbsp;     * @see #isPaintingOrigin()
<i>4831</i>&nbsp;     * @see java.awt.Component#isShowing
<i>4832</i>&nbsp;     * @see RepaintManager#addDirtyRegion
<i>4833</i>&nbsp;     */
<i>4834</i>&nbsp;    public void repaint(long tm, int x, int y, int width, int height) {
<i>4835</i>&nbsp;        RepaintManager.currentManager(SunToolkit.targetToAppContext(this))
<i>4836</i>&nbsp;                      .addDirtyRegion(this, x, y, width, height);
<i>4837</i>&nbsp;    }
<i>4838</i>&nbsp;
<b class="nc"><i>4839</i>&nbsp;</b>
<i>4840</i>&nbsp;    /**
<i>4841</i>&nbsp;     * Adds the specified region to the dirty region list if the component
<i>4842</i>&nbsp;     * is showing.  The component will be repainted after all of the
<i>4843</i>&nbsp;     * currently pending events have been dispatched.
<i>4844</i>&nbsp;     *
<i>4845</i>&nbsp;     * @param  r a &lt;code&gt;Rectangle&lt;/code&gt; containing the dirty region
<i>4846</i>&nbsp;     * @see #isPaintingOrigin()
<i>4847</i>&nbsp;     * @see java.awt.Component#isShowing
<b class="nc"><i>4848</i>&nbsp;     * @see RepaintManager#addDirtyRegion</b>
<b class="nc"><i>4849</i>&nbsp;     */</b>
<b class="nc"><i>4850</i>&nbsp;    public void repaint(Rectangle r) {</b>
<i>4851</i>&nbsp;        repaint(0,r.x,r.y,r.width,r.height);
<i>4852</i>&nbsp;    }
<i>4853</i>&nbsp;
<i>4854</i>&nbsp;
<i>4855</i>&nbsp;    /**
<b class="nc"><i>4856</i>&nbsp;     * Supports deferred automatic layout.</b>
<i>4857</i>&nbsp;     * &lt;p&gt;
<i>4858</i>&nbsp;     * Calls &lt;code&gt;invalidate&lt;/code&gt; and then adds this component&#39;s
<b class="nc"><i>4859</i>&nbsp;     * &lt;code&gt;validateRoot&lt;/code&gt; to a list of components that need to be</b>
<b class="nc"><i>4860</i>&nbsp;     * validated.  Validation will occur after all currently pending</b>
<b class="nc"><i>4861</i>&nbsp;     * events have been dispatched.  In other words after this method</b>
<i>4862</i>&nbsp;     * is called,  the first validateRoot (if any) found when walking
<i>4863</i>&nbsp;     * up the containment hierarchy of this component will be validated.
<i>4864</i>&nbsp;     * By default, &lt;code&gt;JRootPane&lt;/code&gt;, &lt;code&gt;JScrollPane&lt;/code&gt;,
<i>4865</i>&nbsp;     * and &lt;code&gt;JTextField&lt;/code&gt; return true
<i>4866</i>&nbsp;     * from &lt;code&gt;isValidateRoot&lt;/code&gt;.
<i>4867</i>&nbsp;     * &lt;p&gt;
<i>4868</i>&nbsp;     * This method will automatically be called on this component
<i>4869</i>&nbsp;     * when a property value changes such that size, location, or
<i>4870</i>&nbsp;     * internal layout of this component has been affected.  This automatic
<i>4871</i>&nbsp;     * updating differs from the AWT because programs generally no
<i>4872</i>&nbsp;     * longer need to invoke &lt;code&gt;validate&lt;/code&gt; to get the contents of the
<i>4873</i>&nbsp;     * GUI to update.
<i>4874</i>&nbsp;     *
<i>4875</i>&nbsp;     * @see java.awt.Component#invalidate
<i>4876</i>&nbsp;     * @see java.awt.Container#validate
<i>4877</i>&nbsp;     * @see #isValidateRoot
<i>4878</i>&nbsp;     * @see RepaintManager#addInvalidComponent
<i>4879</i>&nbsp;     */
<i>4880</i>&nbsp;    public void revalidate() {
<b class="nc"><i>4881</i>&nbsp;        if (getParent() == null) {</b>
<i>4882</i>&nbsp;            // Note: We don&#39;t bother invalidating here as once added
<i>4883</i>&nbsp;            // to a valid parent invalidate will be invoked (addImpl
<i>4884</i>&nbsp;            // invokes addNotify which will invoke invalidate on the
<i>4885</i>&nbsp;            // new Component). Also, if we do add a check to isValid
<i>4886</i>&nbsp;            // here it can potentially be called before the constructor
<i>4887</i>&nbsp;            // which was causing some people grief.
<i>4888</i>&nbsp;            return;
<i>4889</i>&nbsp;        }
<i>4890</i>&nbsp;        if (SunToolkit.isDispatchThreadForAppContext(this)) {
<i>4891</i>&nbsp;            invalidate();
<i>4892</i>&nbsp;            RepaintManager.currentManager(this).addInvalidComponent(this);
<i>4893</i>&nbsp;        }
<i>4894</i>&nbsp;        else {
<i>4895</i>&nbsp;            // To avoid a flood of Runnables when constructing GUIs off
<b class="nc"><i>4896</i>&nbsp;            // the EDT, a flag is maintained as to whether or not</b>
<i>4897</i>&nbsp;            // a Runnable has been scheduled.
<i>4898</i>&nbsp;            if (revalidateRunnableScheduled.getAndSet(true)) {
<i>4899</i>&nbsp;                return;
<i>4900</i>&nbsp;            }
<i>4901</i>&nbsp;            SunToolkit.executeOnEventHandlerThread(this, () -&gt; {
<i>4902</i>&nbsp;                revalidateRunnableScheduled.set(false);
<i>4903</i>&nbsp;                revalidate();
<i>4904</i>&nbsp;            });
<i>4905</i>&nbsp;        }
<i>4906</i>&nbsp;    }
<i>4907</i>&nbsp;
<i>4908</i>&nbsp;    /**
<i>4909</i>&nbsp;     * If this method returns true, &lt;code&gt;revalidate&lt;/code&gt; calls by
<i>4910</i>&nbsp;     * descendants of this component will cause the entire tree
<i>4911</i>&nbsp;     * beginning with this root to be validated.
<i>4912</i>&nbsp;     * Returns false by default.  &lt;code&gt;JScrollPane&lt;/code&gt; overrides
<i>4913</i>&nbsp;     * this method and returns true.
<i>4914</i>&nbsp;     *
<i>4915</i>&nbsp;     * @return always returns false
<b class="nc"><i>4916</i>&nbsp;     * @see #revalidate</b>
<i>4917</i>&nbsp;     * @see java.awt.Component#invalidate
<i>4918</i>&nbsp;     * @see java.awt.Container#validate
<i>4919</i>&nbsp;     * @see java.awt.Container#isValidateRoot
<i>4920</i>&nbsp;     */
<i>4921</i>&nbsp;    @Override
<i>4922</i>&nbsp;    public boolean isValidateRoot() {
<i>4923</i>&nbsp;        return false;
<i>4924</i>&nbsp;    }
<i>4925</i>&nbsp;
<i>4926</i>&nbsp;
<i>4927</i>&nbsp;    /**
<i>4928</i>&nbsp;     * Returns true if this component tiles its children -- that is, if
<i>4929</i>&nbsp;     * it can guarantee that the children will not overlap.  The
<i>4930</i>&nbsp;     * repainting system is substantially more efficient in this
<i>4931</i>&nbsp;     * common case.  &lt;code&gt;JComponent&lt;/code&gt; subclasses that can&#39;t make this
<i>4932</i>&nbsp;     * guarantee, such as &lt;code&gt;JLayeredPane&lt;/code&gt;,
<i>4933</i>&nbsp;     * should override this method to return false.
<i>4934</i>&nbsp;     *
<i>4935</i>&nbsp;     * @return always returns true
<i>4936</i>&nbsp;     */
<i>4937</i>&nbsp;    @BeanProperty(bound = false)
<i>4938</i>&nbsp;    public boolean isOptimizedDrawingEnabled() {
<i>4939</i>&nbsp;        return true;
<b class="nc"><i>4940</i>&nbsp;    }</b>
<i>4941</i>&nbsp;
<i>4942</i>&nbsp;    /**
<b class="nc"><i>4943</i>&nbsp;     * Returns {@code true} if a paint triggered on a child component should cause</b>
<i>4944</i>&nbsp;     * painting to originate from this Component, or one of its ancestors.
<i>4945</i>&nbsp;     * &lt;p&gt;
<i>4946</i>&nbsp;     * Calling {@link #repaint} or {@link #paintImmediately(int, int, int, int)}
<b class="nc"><i>4947</i>&nbsp;     * on a Swing component will result in calling</b>
<b class="nc"><i>4948</i>&nbsp;     * the {@link JComponent#paintImmediately(int, int, int, int)} method of</b>
<b class="nc"><i>4949</i>&nbsp;     * the first ancestor which {@code isPaintingOrigin()} returns {@code true}, if there are any.</b>
<i>4950</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>4951</i>&nbsp;     * {@code JComponent} subclasses that need to be painted when any of their</b>
<i>4952</i>&nbsp;     * children are repainted should override this method to return {@code true}.
<i>4953</i>&nbsp;     *
<i>4954</i>&nbsp;     * @return always returns {@code false}
<b class="nc"><i>4955</i>&nbsp;     *</b>
<b class="nc"><i>4956</i>&nbsp;     * @see #paintImmediately(int, int, int, int)</b>
<b class="nc"><i>4957</i>&nbsp;     */</b>
<b class="nc"><i>4958</i>&nbsp;    protected boolean isPaintingOrigin() {</b>
<b class="nc"><i>4959</i>&nbsp;        return false;</b>
<b class="nc"><i>4960</i>&nbsp;    }</b>
<i>4961</i>&nbsp;
<i>4962</i>&nbsp;    /**
<i>4963</i>&nbsp;     * Paints the specified region in this component and all of its
<i>4964</i>&nbsp;     * descendants that overlap the region, immediately.
<b class="nc"><i>4965</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>4966</i>&nbsp;     * It&#39;s rarely necessary to call this method.  In most cases it&#39;s</b>
<i>4967</i>&nbsp;     * more efficient to call repaint, which defers the actual painting
<i>4968</i>&nbsp;     * and can collapse redundant requests into a single paint call.
<b class="nc"><i>4969</i>&nbsp;     * This method is useful if one needs to update the display while</b>
<b class="nc"><i>4970</i>&nbsp;     * the current event is being dispatched.</b>
<i>4971</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>4972</i>&nbsp;     * This method is to be overridden when the dirty region needs to be changed</b>
<i>4973</i>&nbsp;     * for components that are painting origins.
<i>4974</i>&nbsp;     *
<i>4975</i>&nbsp;     * @param x  the x value of the region to be painted
<i>4976</i>&nbsp;     * @param y  the y value of the region to be painted
<i>4977</i>&nbsp;     * @param w  the width of the region to be painted
<i>4978</i>&nbsp;     * @param h  the height of the region to be painted
<i>4979</i>&nbsp;     * @see #repaint
<i>4980</i>&nbsp;     * @see #isPaintingOrigin()
<i>4981</i>&nbsp;     */
<b class="nc"><i>4982</i>&nbsp;    public void paintImmediately(int x,int y,int w, int h) {</b>
<i>4983</i>&nbsp;        Component c = this;
<i>4984</i>&nbsp;        Component parent;
<i>4985</i>&nbsp;
<i>4986</i>&nbsp;        if(!isShowing()) {
<i>4987</i>&nbsp;            return;
<i>4988</i>&nbsp;        }
<i>4989</i>&nbsp;
<i>4990</i>&nbsp;        JComponent paintingOigin = SwingUtilities.getPaintingOrigin(this);
<i>4991</i>&nbsp;        if (paintingOigin != null) {
<i>4992</i>&nbsp;            Rectangle rectangle = SwingUtilities.convertRectangle(
<i>4993</i>&nbsp;                    c, new Rectangle(x, y, w, h), paintingOigin);
<i>4994</i>&nbsp;            paintingOigin.paintImmediately(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
<b class="nc"><i>4995</i>&nbsp;            return;</b>
<i>4996</i>&nbsp;        }
<i>4997</i>&nbsp;
<i>4998</i>&nbsp;        while(!c.isOpaque()) {
<b class="nc"><i>4999</i>&nbsp;            parent = c.getParent();</b>
<i>5000</i>&nbsp;            if(parent != null) {
<i>5001</i>&nbsp;                x += c.getX();
<i>5002</i>&nbsp;                y += c.getY();
<i>5003</i>&nbsp;                c = parent;
<i>5004</i>&nbsp;            } else {
<i>5005</i>&nbsp;                break;
<i>5006</i>&nbsp;            }
<i>5007</i>&nbsp;
<b class="nc"><i>5008</i>&nbsp;            if(!(c instanceof JComponent)) {</b>
<i>5009</i>&nbsp;                break;
<b class="nc"><i>5010</i>&nbsp;            }</b>
<i>5011</i>&nbsp;        }
<b class="nc"><i>5012</i>&nbsp;        if(c instanceof JComponent) {</b>
<b class="nc"><i>5013</i>&nbsp;            ((JComponent)c)._paintImmediately(x,y,w,h);</b>
<i>5014</i>&nbsp;        } else {
<b class="nc"><i>5015</i>&nbsp;            c.repaint(x,y,w,h);</b>
<i>5016</i>&nbsp;        }
<i>5017</i>&nbsp;    }
<i>5018</i>&nbsp;
<i>5019</i>&nbsp;    /**
<b class="nc"><i>5020</i>&nbsp;     * Paints the specified region now.</b>
<b class="nc"><i>5021</i>&nbsp;     *</b>
<b class="nc"><i>5022</i>&nbsp;     * @param r a &lt;code&gt;Rectangle&lt;/code&gt; containing the region to be painted</b>
<i>5023</i>&nbsp;     */
<b class="nc"><i>5024</i>&nbsp;    public void paintImmediately(Rectangle r) {</b>
<i>5025</i>&nbsp;        paintImmediately(r.x,r.y,r.width,r.height);
<b class="nc"><i>5026</i>&nbsp;    }</b>
<b class="nc"><i>5027</i>&nbsp;</b>
<b class="nc"><i>5028</i>&nbsp;    /**</b>
<b class="nc"><i>5029</i>&nbsp;     * Returns whether this component should be guaranteed to be on top.</b>
<b class="nc"><i>5030</i>&nbsp;     * For example, it would make no sense for &lt;code&gt;Menu&lt;/code&gt;s to pop up</b>
<i>5031</i>&nbsp;     * under another component, so they would always return true.
<i>5032</i>&nbsp;     * Most components will want to return false, hence that is the default.
<i>5033</i>&nbsp;     *
<i>5034</i>&nbsp;     * @return always returns false
<b class="nc"><i>5035</i>&nbsp;     */</b>
<b class="nc"><i>5036</i>&nbsp;    // package private</b>
<b class="nc"><i>5037</i>&nbsp;    boolean alwaysOnTop() {</b>
<i>5038</i>&nbsp;        return false;
<b class="nc"><i>5039</i>&nbsp;    }</b>
<b class="nc"><i>5040</i>&nbsp;</b>
<i>5041</i>&nbsp;    void setPaintingChild(Component paintingChild) {
<i>5042</i>&nbsp;        this.paintingChild = paintingChild;
<i>5043</i>&nbsp;    }
<i>5044</i>&nbsp;
<b class="nc"><i>5045</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)</b>
<b class="nc"><i>5046</i>&nbsp;    void _paintImmediately(int x, int y, int w, int h) {</b>
<b class="nc"><i>5047</i>&nbsp;        Graphics g;</b>
<b class="nc"><i>5048</i>&nbsp;        Container c;</b>
<i>5049</i>&nbsp;        Rectangle b;
<b class="nc"><i>5050</i>&nbsp;</b>
<b class="nc"><i>5051</i>&nbsp;        int tmpX, tmpY, tmpWidth, tmpHeight;</b>
<i>5052</i>&nbsp;        int offsetX=0,offsetY=0;
<i>5053</i>&nbsp;
<i>5054</i>&nbsp;        boolean hasBuffer = false;
<i>5055</i>&nbsp;
<i>5056</i>&nbsp;        JComponent bufferedComponent = null;
<i>5057</i>&nbsp;        JComponent paintingComponent = this;
<i>5058</i>&nbsp;
<i>5059</i>&nbsp;        RepaintManager repaintManager = RepaintManager.currentManager(this);
<i>5060</i>&nbsp;        // parent Container&#39;s up to Window or Applet. First container is
<i>5061</i>&nbsp;        // the direct parent. Note that in testing it was faster to
<b class="nc"><i>5062</i>&nbsp;        // alloc a new Vector vs keeping a stack of them around, and gc</b>
<b class="nc"><i>5063</i>&nbsp;        // seemed to have a minimal effect on this.</b>
<b class="nc"><i>5064</i>&nbsp;        java.util.List&lt;Component&gt; path = new java.util.ArrayList&lt;Component&gt;(7);</b>
<i>5065</i>&nbsp;        int pIndex = -1;
<i>5066</i>&nbsp;        int pCount = 0;
<b class="nc"><i>5067</i>&nbsp;</b>
<b class="nc"><i>5068</i>&nbsp;        tmpX = tmpY = tmpWidth = tmpHeight = 0;</b>
<b class="nc"><i>5069</i>&nbsp;</b>
<b class="nc"><i>5070</i>&nbsp;        Rectangle paintImmediatelyClip = fetchRectangle();</b>
<i>5071</i>&nbsp;        paintImmediatelyClip.x = x;
<b class="nc"><i>5072</i>&nbsp;        paintImmediatelyClip.y = y;</b>
<i>5073</i>&nbsp;        paintImmediatelyClip.width = w;
<i>5074</i>&nbsp;        paintImmediatelyClip.height = h;
<i>5075</i>&nbsp;
<i>5076</i>&nbsp;
<i>5077</i>&nbsp;        // System.out.println(&quot;1) ************* in _paintImmediately for &quot; + this);
<b class="nc"><i>5078</i>&nbsp;</b>
<b class="nc"><i>5079</i>&nbsp;        boolean ontop = alwaysOnTop() &amp;&amp; isOpaque();</b>
<i>5080</i>&nbsp;        if (ontop) {
<b class="nc"><i>5081</i>&nbsp;            SwingUtilities.computeIntersection(0, 0, getWidth(), getHeight(),</b>
<i>5082</i>&nbsp;                                               paintImmediatelyClip);
<i>5083</i>&nbsp;            if (paintImmediatelyClip.width == 0) {
<b class="nc"><i>5084</i>&nbsp;                recycleRectangle(paintImmediatelyClip);</b>
<i>5085</i>&nbsp;                return;
<i>5086</i>&nbsp;            }
<b class="nc"><i>5087</i>&nbsp;        }</b>
<i>5088</i>&nbsp;        Component child;
<i>5089</i>&nbsp;        for (c = this, child = null;
<b class="nc"><i>5090</i>&nbsp;             c != null &amp;&amp; !(c instanceof Window) &amp;&amp; !(c instanceof Applet);</b>
<i>5091</i>&nbsp;             child = c, c = c.getParent()) {
<i>5092</i>&nbsp;                JComponent jc = (c instanceof JComponent) ? (JComponent)c :
<b class="nc"><i>5093</i>&nbsp;                                null;</b>
<i>5094</i>&nbsp;                path.add(c);
<i>5095</i>&nbsp;                if(!ontop &amp;&amp; jc != null &amp;&amp; !jc.isOptimizedDrawingEnabled()) {
<b class="nc"><i>5096</i>&nbsp;                    boolean resetPC;</b>
<b class="nc"><i>5097</i>&nbsp;</b>
<b class="nc"><i>5098</i>&nbsp;                    // Children of c may overlap, three possible cases for the</b>
<b class="nc"><i>5099</i>&nbsp;                    // painting region:</b>
<i>5100</i>&nbsp;                    // . Completely obscured by an opaque sibling, in which
<i>5101</i>&nbsp;                    //   case there is no need to paint.
<b class="nc"><i>5102</i>&nbsp;                    // . Partially obscured by a sibling: need to start</b>
<i>5103</i>&nbsp;                    //   painting from c.
<i>5104</i>&nbsp;                    // . Otherwise we aren&#39;t obscured and thus don&#39;t need to
<i>5105</i>&nbsp;                    //   start painting from parent.
<b class="nc"><i>5106</i>&nbsp;                    if (c != this) {</b>
<b class="nc"><i>5107</i>&nbsp;                        if (jc.isPaintingOrigin()) {</b>
<b class="nc"><i>5108</i>&nbsp;                            resetPC = true;</b>
<b class="nc"><i>5109</i>&nbsp;                        }</b>
<i>5110</i>&nbsp;                        else {
<i>5111</i>&nbsp;                            Component[] children = c.getComponents();
<i>5112</i>&nbsp;                            int i = 0;
<b class="nc"><i>5113</i>&nbsp;                            for (; i&lt;children.length; i++) {</b>
<b class="nc"><i>5114</i>&nbsp;                                if (children[i] == child) break;</b>
<b class="nc"><i>5115</i>&nbsp;                            }</b>
<b class="nc"><i>5116</i>&nbsp;                            switch (jc.getObscuredState(i,</b>
<b class="nc"><i>5117</i>&nbsp;                                            paintImmediatelyClip.x,</b>
<b class="nc"><i>5118</i>&nbsp;                                            paintImmediatelyClip.y,</b>
<b class="nc"><i>5119</i>&nbsp;                                            paintImmediatelyClip.width,</b>
<b class="nc"><i>5120</i>&nbsp;                                            paintImmediatelyClip.height)) {</b>
<b class="nc"><i>5121</i>&nbsp;                            case NOT_OBSCURED:</b>
<b class="nc"><i>5122</i>&nbsp;                                resetPC = false;</b>
<i>5123</i>&nbsp;                                break;
<i>5124</i>&nbsp;                            case COMPLETELY_OBSCURED:
<i>5125</i>&nbsp;                                recycleRectangle(paintImmediatelyClip);
<i>5126</i>&nbsp;                                return;
<b class="nc"><i>5127</i>&nbsp;                            default:</b>
<i>5128</i>&nbsp;                                resetPC = true;
<i>5129</i>&nbsp;                                break;
<b class="nc"><i>5130</i>&nbsp;                            }</b>
<i>5131</i>&nbsp;                        }
<i>5132</i>&nbsp;                    }
<i>5133</i>&nbsp;                    else {
<b class="nc"><i>5134</i>&nbsp;                        resetPC = false;</b>
<i>5135</i>&nbsp;                    }
<b class="nc"><i>5136</i>&nbsp;</b>
<b class="nc"><i>5137</i>&nbsp;                    if (resetPC) {</b>
<i>5138</i>&nbsp;                        // Get rid of any buffer since we draw from here and
<i>5139</i>&nbsp;                        // we might draw something larger
<i>5140</i>&nbsp;                        paintingComponent = jc;
<b class="nc"><i>5141</i>&nbsp;                        pIndex = pCount;</b>
<i>5142</i>&nbsp;                        offsetX = offsetY = 0;
<b class="nc"><i>5143</i>&nbsp;                        hasBuffer = false;</b>
<b class="nc"><i>5144</i>&nbsp;                    }</b>
<b class="nc"><i>5145</i>&nbsp;                }</b>
<b class="nc"><i>5146</i>&nbsp;                pCount++;</b>
<b class="nc"><i>5147</i>&nbsp;</b>
<i>5148</i>&nbsp;                // look to see if the parent (and therefor this component)
<i>5149</i>&nbsp;                // is double buffered
<i>5150</i>&nbsp;                if(repaintManager.isDoubleBufferingEnabled() &amp;&amp; jc != null &amp;&amp;
<i>5151</i>&nbsp;                                  jc.isDoubleBuffered()) {
<b class="nc"><i>5152</i>&nbsp;                    hasBuffer = true;</b>
<i>5153</i>&nbsp;                    bufferedComponent = jc;
<b class="nc"><i>5154</i>&nbsp;                }</b>
<b class="nc"><i>5155</i>&nbsp;</b>
<i>5156</i>&nbsp;                // if we aren&#39;t on top, include the parent&#39;s clip
<b class="nc"><i>5157</i>&nbsp;                if (!ontop) {</b>
<i>5158</i>&nbsp;                    int bx = c.getX();
<b class="nc"><i>5159</i>&nbsp;                    int by = c.getY();</b>
<i>5160</i>&nbsp;                    tmpWidth = c.getWidth();
<i>5161</i>&nbsp;                    tmpHeight = c.getHeight();
<i>5162</i>&nbsp;                    SwingUtilities.computeIntersection(tmpX,tmpY,tmpWidth,tmpHeight,paintImmediatelyClip);
<i>5163</i>&nbsp;                    paintImmediatelyClip.x += bx;
<i>5164</i>&nbsp;                    paintImmediatelyClip.y += by;
<b class="nc"><i>5165</i>&nbsp;                    offsetX += bx;</b>
<b class="nc"><i>5166</i>&nbsp;                    offsetY += by;</b>
<b class="nc"><i>5167</i>&nbsp;                }</b>
<b class="nc"><i>5168</i>&nbsp;        }</b>
<i>5169</i>&nbsp;
<b class="nc"><i>5170</i>&nbsp;        // If the clip width or height is negative, don&#39;t bother painting</b>
<i>5171</i>&nbsp;        if(c == null || !c.isDisplayable() ||
<i>5172</i>&nbsp;                        paintImmediatelyClip.width &lt;= 0 ||
<b class="nc"><i>5173</i>&nbsp;                        paintImmediatelyClip.height &lt;= 0) {</b>
<b class="nc"><i>5174</i>&nbsp;            recycleRectangle(paintImmediatelyClip);</b>
<i>5175</i>&nbsp;            return;
<i>5176</i>&nbsp;        }
<i>5177</i>&nbsp;
<i>5178</i>&nbsp;        paintingComponent.setFlag(IS_REPAINTING, true);
<b class="nc"><i>5179</i>&nbsp;</b>
<i>5180</i>&nbsp;        paintImmediatelyClip.x -= offsetX;
<b class="nc"><i>5181</i>&nbsp;        paintImmediatelyClip.y -= offsetY;</b>
<b class="nc"><i>5182</i>&nbsp;</b>
<b class="nc"><i>5183</i>&nbsp;        // Notify the Components that are going to be painted of the</b>
<b class="nc"><i>5184</i>&nbsp;        // child component to paint to.</b>
<b class="nc"><i>5185</i>&nbsp;        if(paintingComponent != this) {</b>
<i>5186</i>&nbsp;            Component comp;
<i>5187</i>&nbsp;            int i = pIndex;
<i>5188</i>&nbsp;            for(; i &gt; 0 ; i--) {
<b class="nc"><i>5189</i>&nbsp;                comp = path.get(i);</b>
<b class="nc"><i>5190</i>&nbsp;                if(comp instanceof JComponent) {</b>
<b class="nc"><i>5191</i>&nbsp;                    ((JComponent)comp).setPaintingChild(path.get(i-1));</b>
<i>5192</i>&nbsp;                }
<i>5193</i>&nbsp;            }
<i>5194</i>&nbsp;        }
<i>5195</i>&nbsp;        try {
<i>5196</i>&nbsp;            if ((g = safelyGetGraphics(paintingComponent, c)) != null) {
<i>5197</i>&nbsp;                try {
<i>5198</i>&nbsp;                    if (hasBuffer) {
<i>5199</i>&nbsp;                        RepaintManager rm = RepaintManager.currentManager(
<i>5200</i>&nbsp;                                bufferedComponent);
<i>5201</i>&nbsp;                        rm.beginPaint();
<i>5202</i>&nbsp;                        try {
<i>5203</i>&nbsp;                            rm.paint(paintingComponent, bufferedComponent, g,
<b class="nc"><i>5204</i>&nbsp;                                    paintImmediatelyClip.x,</b>
<b class="nc"><i>5205</i>&nbsp;                                    paintImmediatelyClip.y,</b>
<b class="nc"><i>5206</i>&nbsp;                                    paintImmediatelyClip.width,</b>
<i>5207</i>&nbsp;                                    paintImmediatelyClip.height);
<b class="nc"><i>5208</i>&nbsp;                        } finally {</b>
<i>5209</i>&nbsp;                            rm.endPaint();
<i>5210</i>&nbsp;                        }
<b class="nc"><i>5211</i>&nbsp;                    } else {</b>
<i>5212</i>&nbsp;                        g.setClip(paintImmediatelyClip.x, paintImmediatelyClip.y,
<i>5213</i>&nbsp;                                paintImmediatelyClip.width, paintImmediatelyClip.height);
<b class="nc"><i>5214</i>&nbsp;                        paintingComponent.paint(g);</b>
<b class="nc"><i>5215</i>&nbsp;                    }</b>
<b class="nc"><i>5216</i>&nbsp;                } finally {</b>
<i>5217</i>&nbsp;                    g.dispose();
<b class="nc"><i>5218</i>&nbsp;                }</b>
<i>5219</i>&nbsp;            }
<i>5220</i>&nbsp;        }
<b class="nc"><i>5221</i>&nbsp;        finally {</b>
<b class="nc"><i>5222</i>&nbsp;            // Reset the painting child for the parent components.</b>
<b class="nc"><i>5223</i>&nbsp;            if(paintingComponent != this) {</b>
<i>5224</i>&nbsp;                Component comp;
<i>5225</i>&nbsp;                int i = pIndex;
<i>5226</i>&nbsp;                for(; i &gt; 0 ; i--) {
<i>5227</i>&nbsp;                    comp = path.get(i);
<i>5228</i>&nbsp;                    if(comp instanceof JComponent) {
<i>5229</i>&nbsp;                        ((JComponent)comp).setPaintingChild(null);
<i>5230</i>&nbsp;                    }
<i>5231</i>&nbsp;                }
<i>5232</i>&nbsp;            }
<i>5233</i>&nbsp;            paintingComponent.setFlag(IS_REPAINTING, false);
<i>5234</i>&nbsp;        }
<i>5235</i>&nbsp;        recycleRectangle(paintImmediatelyClip);
<i>5236</i>&nbsp;    }
<b class="nc"><i>5237</i>&nbsp;</b>
<b class="nc"><i>5238</i>&nbsp;    /**</b>
<i>5239</i>&nbsp;     * Paints to the specified graphics.  This does not set the clip and it
<b class="nc"><i>5240</i>&nbsp;     * does not adjust the Graphics in anyway, callers must do that first.</b>
<b class="nc"><i>5241</i>&nbsp;     * This method is package-private for RepaintManager.PaintManager and</b>
<b class="nc"><i>5242</i>&nbsp;     * its subclasses to call, it is NOT intended for general use outside</b>
<b class="nc"><i>5243</i>&nbsp;     * of that.</b>
<i>5244</i>&nbsp;     */
<i>5245</i>&nbsp;    void paintToOffscreen(Graphics g, int x, int y, int w, int h, int maxX,
<i>5246</i>&nbsp;                          int maxY) {
<b class="nc"><i>5247</i>&nbsp;        try {</b>
<b class="nc"><i>5248</i>&nbsp;            setFlag(ANCESTOR_USING_BUFFER, true);</b>
<b class="nc"><i>5249</i>&nbsp;            if ((y + h) &lt; maxY || (x + w) &lt; maxX) {</b>
<b class="nc"><i>5250</i>&nbsp;                setFlag(IS_PAINTING_TILE, true);</b>
<b class="nc"><i>5251</i>&nbsp;            }</b>
<i>5252</i>&nbsp;            if (getFlag(IS_REPAINTING)) {
<i>5253</i>&nbsp;                // Called from paintImmediately (RepaintManager) to fill
<i>5254</i>&nbsp;                // repaint request
<i>5255</i>&nbsp;                paint(g);
<b class="nc"><i>5256</i>&nbsp;            } else {</b>
<i>5257</i>&nbsp;                // Called from paint() (AWT) to repair damage
<b class="nc"><i>5258</i>&nbsp;                if(!rectangleIsObscured(x, y, w, h)) {</b>
<b class="nc"><i>5259</i>&nbsp;                    paintComponent(g);</b>
<i>5260</i>&nbsp;                    paintBorder(g);
<i>5261</i>&nbsp;                }
<i>5262</i>&nbsp;                paintChildren(g);
<b class="nc"><i>5263</i>&nbsp;            }</b>
<b class="nc"><i>5264</i>&nbsp;        } finally {</b>
<i>5265</i>&nbsp;            setFlag(ANCESTOR_USING_BUFFER, false);
<b class="nc"><i>5266</i>&nbsp;            setFlag(IS_PAINTING_TILE, false);</b>
<i>5267</i>&nbsp;        }
<i>5268</i>&nbsp;    }
<i>5269</i>&nbsp;
<i>5270</i>&nbsp;    /**
<b class="nc"><i>5271</i>&nbsp;     * Returns whether or not the region of the specified component is</b>
<i>5272</i>&nbsp;     * obscured by a sibling.
<i>5273</i>&nbsp;     *
<b class="nc"><i>5274</i>&nbsp;     * @return NOT_OBSCURED if non of the siblings above the Component obscure</b>
<b class="nc"><i>5275</i>&nbsp;     *         it, COMPLETELY_OBSCURED if one of the siblings completely</b>
<i>5276</i>&nbsp;     *         obscures the Component or PARTIALLY_OBSCURED if the Component is
<i>5277</i>&nbsp;     *         only partially obscured.
<i>5278</i>&nbsp;     */
<i>5279</i>&nbsp;    private int getObscuredState(int compIndex, int x, int y, int width,
<i>5280</i>&nbsp;                                 int height) {
<i>5281</i>&nbsp;        int retValue = NOT_OBSCURED;
<i>5282</i>&nbsp;        Rectangle tmpRect = fetchRectangle();
<i>5283</i>&nbsp;
<i>5284</i>&nbsp;        for (int i = compIndex - 1 ; i &gt;= 0 ; i--) {
<i>5285</i>&nbsp;            Component sibling = getComponent(i);
<i>5286</i>&nbsp;            if (!sibling.isVisible()) {
<b class="nc"><i>5287</i>&nbsp;                continue;</b>
<i>5288</i>&nbsp;            }
<i>5289</i>&nbsp;            Rectangle siblingRect;
<i>5290</i>&nbsp;            boolean opaque;
<i>5291</i>&nbsp;            if (sibling instanceof JComponent) {
<b class="nc"><i>5292</i>&nbsp;                opaque = sibling.isOpaque();</b>
<b class="nc"><i>5293</i>&nbsp;                if (!opaque) {</b>
<i>5294</i>&nbsp;                    if (retValue == PARTIALLY_OBSCURED) {
<b class="nc"><i>5295</i>&nbsp;                        continue;</b>
<i>5296</i>&nbsp;                    }
<i>5297</i>&nbsp;                }
<i>5298</i>&nbsp;            }
<b class="nc"><i>5299</i>&nbsp;            else {</b>
<b class="nc"><i>5300</i>&nbsp;                opaque = true;</b>
<i>5301</i>&nbsp;            }
<i>5302</i>&nbsp;            siblingRect = sibling.getBounds(tmpRect);
<i>5303</i>&nbsp;            if (opaque &amp;&amp; x &gt;= siblingRect.x &amp;&amp; (x + width) &lt;=
<i>5304</i>&nbsp;                     (siblingRect.x + siblingRect.width) &amp;&amp;
<i>5305</i>&nbsp;                     y &gt;= siblingRect.y &amp;&amp; (y + height) &lt;=
<b class="nc"><i>5306</i>&nbsp;                     (siblingRect.y + siblingRect.height)) {</b>
<i>5307</i>&nbsp;                recycleRectangle(tmpRect);
<i>5308</i>&nbsp;                return COMPLETELY_OBSCURED;
<i>5309</i>&nbsp;            }
<b class="nc"><i>5310</i>&nbsp;            else if (retValue == NOT_OBSCURED &amp;&amp;</b>
<i>5311</i>&nbsp;                     !((x + width &lt;= siblingRect.x) ||
<i>5312</i>&nbsp;                       (y + height &lt;= siblingRect.y) ||
<i>5313</i>&nbsp;                       (x &gt;= siblingRect.x + siblingRect.width) ||
<i>5314</i>&nbsp;                       (y &gt;= siblingRect.y + siblingRect.height))) {
<i>5315</i>&nbsp;                retValue = PARTIALLY_OBSCURED;
<i>5316</i>&nbsp;            }
<i>5317</i>&nbsp;        }
<i>5318</i>&nbsp;        recycleRectangle(tmpRect);
<i>5319</i>&nbsp;        return retValue;
<i>5320</i>&nbsp;    }
<i>5321</i>&nbsp;
<i>5322</i>&nbsp;    /**
<i>5323</i>&nbsp;     * Returns true, which implies that before checking if a child should
<i>5324</i>&nbsp;     * be painted it is first check that the child is not obscured by another
<i>5325</i>&nbsp;     * sibling. This is only checked if &lt;code&gt;isOptimizedDrawingEnabled&lt;/code&gt;
<b class="nc"><i>5326</i>&nbsp;     * returns false.</b>
<i>5327</i>&nbsp;     *
<i>5328</i>&nbsp;     * @return always returns true
<i>5329</i>&nbsp;     */
<i>5330</i>&nbsp;    boolean checkIfChildObscuredBySibling() {
<i>5331</i>&nbsp;        return true;
<i>5332</i>&nbsp;    }
<i>5333</i>&nbsp;
<i>5334</i>&nbsp;
<b class="nc"><i>5335</i>&nbsp;    private void setFlag(int aFlag, boolean aValue) {</b>
<i>5336</i>&nbsp;        if(aValue) {
<i>5337</i>&nbsp;            flags |= (1 &lt;&lt; aFlag);
<i>5338</i>&nbsp;        } else {
<i>5339</i>&nbsp;            flags &amp;= ~(1 &lt;&lt; aFlag);
<i>5340</i>&nbsp;        }
<i>5341</i>&nbsp;    }
<i>5342</i>&nbsp;    private boolean getFlag(int aFlag) {
<i>5343</i>&nbsp;        int mask = (1 &lt;&lt; aFlag);
<i>5344</i>&nbsp;        return ((flags &amp; mask) == mask);
<b class="nc"><i>5345</i>&nbsp;    }</b>
<i>5346</i>&nbsp;    // These functions must be static so that they can be called from
<i>5347</i>&nbsp;    // subclasses inside the package, but whose inheritance hierarhcy includes
<i>5348</i>&nbsp;    // classes outside of the package below JComponent (e.g., JTextArea).
<i>5349</i>&nbsp;    static void setWriteObjCounter(JComponent comp, byte count) {
<i>5350</i>&nbsp;        comp.flags = (comp.flags &amp; ~(0xFF &lt;&lt; WRITE_OBJ_COUNTER_FIRST)) |
<i>5351</i>&nbsp;                     (count &lt;&lt; WRITE_OBJ_COUNTER_FIRST);
<i>5352</i>&nbsp;    }
<i>5353</i>&nbsp;    static byte getWriteObjCounter(JComponent comp) {
<i>5354</i>&nbsp;        return (byte)((comp.flags &gt;&gt; WRITE_OBJ_COUNTER_FIRST) &amp; 0xFF);
<i>5355</i>&nbsp;    }
<b class="nc"><i>5356</i>&nbsp;</b>
<b class="nc"><i>5357</i>&nbsp;    /** Buffering **/</b>
<b class="nc"><i>5358</i>&nbsp;</b>
<i>5359</i>&nbsp;    /**
<i>5360</i>&nbsp;     *  Sets whether this component should use a buffer to paint.
<i>5361</i>&nbsp;     *  If set to true, all the drawing from this component will be done
<b class="nc"><i>5362</i>&nbsp;     *  in an offscreen painting buffer. The offscreen painting buffer will</b>
<i>5363</i>&nbsp;     *  the be copied onto the screen.
<i>5364</i>&nbsp;     *  If a &lt;code&gt;Component&lt;/code&gt; is buffered and one of its ancestor
<i>5365</i>&nbsp;     *  is also buffered, the ancestor buffer will be used.
<i>5366</i>&nbsp;     *
<i>5367</i>&nbsp;     *  @param aFlag if true, set this component to be double buffered
<i>5368</i>&nbsp;     */
<i>5369</i>&nbsp;    public void setDoubleBuffered(boolean aFlag) {
<i>5370</i>&nbsp;        setFlag(IS_DOUBLE_BUFFERED,aFlag);
<b class="nc"><i>5371</i>&nbsp;    }</b>
<i>5372</i>&nbsp;
<b class="nc"><i>5373</i>&nbsp;    /**</b>
<i>5374</i>&nbsp;     * Returns whether this component should use a buffer to paint.
<i>5375</i>&nbsp;     *
<i>5376</i>&nbsp;     * @return true if this component is double buffered, otherwise false
<i>5377</i>&nbsp;     */
<i>5378</i>&nbsp;    public boolean isDoubleBuffered() {
<i>5379</i>&nbsp;        return getFlag(IS_DOUBLE_BUFFERED);
<i>5380</i>&nbsp;    }
<i>5381</i>&nbsp;
<i>5382</i>&nbsp;    /**
<i>5383</i>&nbsp;     * Returns the &lt;code&gt;JRootPane&lt;/code&gt; ancestor for this component.
<i>5384</i>&nbsp;     *
<i>5385</i>&nbsp;     * @return the &lt;code&gt;JRootPane&lt;/code&gt; that contains this component,
<i>5386</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;JRootPane&lt;/code&gt; is found
<i>5387</i>&nbsp;     */
<i>5388</i>&nbsp;    @BeanProperty(bound = false)
<i>5389</i>&nbsp;    public JRootPane getRootPane() {
<i>5390</i>&nbsp;        return SwingUtilities.getRootPane(this);
<i>5391</i>&nbsp;    }
<i>5392</i>&nbsp;
<b class="nc"><i>5393</i>&nbsp;</b>
<i>5394</i>&nbsp;    /** Serialization **/
<b class="nc"><i>5395</i>&nbsp;</b>
<i>5396</i>&nbsp;    /**
<i>5397</i>&nbsp;     * This is called from Component by way of reflection. Do NOT change
<b class="nc"><i>5398</i>&nbsp;     * the name unless you change the code in Component as well.</b>
<b class="nc"><i>5399</i>&nbsp;     */</b>
<b class="nc"><i>5400</i>&nbsp;    void compWriteObjectNotify() {</b>
<i>5401</i>&nbsp;        byte count = JComponent.getWriteObjCounter(this);
<i>5402</i>&nbsp;        JComponent.setWriteObjCounter(this, (byte)(count + 1));
<i>5403</i>&nbsp;        if (count != 0) {
<i>5404</i>&nbsp;            return;
<i>5405</i>&nbsp;        }
<i>5406</i>&nbsp;
<i>5407</i>&nbsp;        uninstallUIAndProperties();
<i>5408</i>&nbsp;
<i>5409</i>&nbsp;        /* JTableHeader is in a separate package, which prevents it from
<i>5410</i>&nbsp;         * being able to override this package-private method the way the
<b class="nc"><i>5411</i>&nbsp;         * other components can.  We don&#39;t want to make this method protected</b>
<b class="nc"><i>5412</i>&nbsp;         * because it would introduce public-api for a less-than-desirable</b>
<b class="nc"><i>5413</i>&nbsp;         * serialization scheme, so we compromise with this &#39;instanceof&#39; hack</b>
<i>5414</i>&nbsp;         * for now.
<i>5415</i>&nbsp;         */
<b class="nc"><i>5416</i>&nbsp;        if (getToolTipText() != null ||</b>
<b class="nc"><i>5417</i>&nbsp;            this instanceof javax.swing.table.JTableHeader) {</b>
<i>5418</i>&nbsp;            ToolTipManager.sharedInstance().unregisterComponent(JComponent.this);
<i>5419</i>&nbsp;        }
<i>5420</i>&nbsp;    }
<i>5421</i>&nbsp;
<i>5422</i>&nbsp;    /**
<i>5423</i>&nbsp;     * This object is the &lt;code&gt;ObjectInputStream&lt;/code&gt; callback
<i>5424</i>&nbsp;     * that&#39;s called after a complete graph of objects (including at least
<i>5425</i>&nbsp;     * one &lt;code&gt;JComponent&lt;/code&gt;) has been read.
<i>5426</i>&nbsp;     *  It sets the UI property of each Swing component
<i>5427</i>&nbsp;     * that was read to the current default with &lt;code&gt;updateUI&lt;/code&gt;.
<i>5428</i>&nbsp;     * &lt;p&gt;
<i>5429</i>&nbsp;     * As each  component is read in we keep track of the current set of
<i>5430</i>&nbsp;     * root components here, in the roots vector.  Note that there&#39;s only one
<b class="nc"><i>5431</i>&nbsp;     * &lt;code&gt;ReadObjectCallback&lt;/code&gt; per &lt;code&gt;ObjectInputStream&lt;/code&gt;,</b>
<b class="nc"><i>5432</i>&nbsp;     * they&#39;re stored in the static &lt;code&gt;readObjectCallbacks&lt;/code&gt;</b>
<b class="nc"><i>5433</i>&nbsp;     * hashtable.</b>
<i>5434</i>&nbsp;     *
<i>5435</i>&nbsp;     * @see java.io.ObjectInputStream#registerValidation
<i>5436</i>&nbsp;     * @see SwingUtilities#updateComponentTreeUI
<b class="nc"><i>5437</i>&nbsp;     */</b>
<i>5438</i>&nbsp;    private class ReadObjectCallback implements ObjectInputValidation
<i>5439</i>&nbsp;    {
<i>5440</i>&nbsp;        private final Vector&lt;JComponent&gt; roots = new Vector&lt;JComponent&gt;(1);
<i>5441</i>&nbsp;        private final ObjectInputStream inputStream;
<i>5442</i>&nbsp;
<b class="nc"><i>5443</i>&nbsp;        ReadObjectCallback(ObjectInputStream s) throws Exception {</b>
<b class="nc"><i>5444</i>&nbsp;            inputStream = s;</b>
<b class="nc"><i>5445</i>&nbsp;            s.registerValidation(this, 0);</b>
<b class="nc"><i>5446</i>&nbsp;        }</b>
<b class="nc"><i>5447</i>&nbsp;</b>
<b class="nc"><i>5448</i>&nbsp;        /**</b>
<i>5449</i>&nbsp;         * This is the method that&#39;s called after the entire graph
<i>5450</i>&nbsp;         * of objects has been read in.  It initializes
<i>5451</i>&nbsp;         * the UI property of all of the copmonents with
<i>5452</i>&nbsp;         * &lt;code&gt;SwingUtilities.updateComponentTreeUI&lt;/code&gt;.
<b class="nc"><i>5453</i>&nbsp;         */</b>
<i>5454</i>&nbsp;        public void validateObject() throws InvalidObjectException {
<i>5455</i>&nbsp;            try {
<i>5456</i>&nbsp;                for (JComponent root : roots) {
<i>5457</i>&nbsp;                    SwingUtilities.updateComponentTreeUI(root);
<i>5458</i>&nbsp;                }
<i>5459</i>&nbsp;            }
<i>5460</i>&nbsp;            finally {
<i>5461</i>&nbsp;                readObjectCallbacks.remove(inputStream);
<i>5462</i>&nbsp;            }
<i>5463</i>&nbsp;        }
<i>5464</i>&nbsp;
<i>5465</i>&nbsp;        /**
<i>5466</i>&nbsp;         * If &lt;code&gt;c&lt;/code&gt; isn&#39;t a descendant of a component we&#39;ve already
<i>5467</i>&nbsp;         * seen, then add it to the roots &lt;code&gt;Vector&lt;/code&gt;.
<b class="nc"><i>5468</i>&nbsp;         *</b>
<i>5469</i>&nbsp;         * @param c the &lt;code&gt;JComponent&lt;/code&gt; to add
<i>5470</i>&nbsp;         */
<i>5471</i>&nbsp;        private void registerComponent(JComponent c)
<i>5472</i>&nbsp;        {
<i>5473</i>&nbsp;            /* If the Component c is a descendant of one of the
<i>5474</i>&nbsp;             * existing roots (or it IS an existing root), we&#39;re done.
<i>5475</i>&nbsp;             */
<b class="nc"><i>5476</i>&nbsp;            for (JComponent root : roots) {</b>
<b class="nc"><i>5477</i>&nbsp;                for(Component p = c; p != null; p = p.getParent()) {</b>
<i>5478</i>&nbsp;                    if (p == root) {
<b class="nc"><i>5479</i>&nbsp;                        return;</b>
<i>5480</i>&nbsp;                    }
<b class="nc"><i>5481</i>&nbsp;                }</b>
<b class="nc"><i>5482</i>&nbsp;            }</b>
<b class="nc"><i>5483</i>&nbsp;</b>
<i>5484</i>&nbsp;            /* Otherwise: if Component c is an ancestor of any of the
<b class="nc"><i>5485</i>&nbsp;             * existing roots then remove them and add c (the &quot;new root&quot;)</b>
<i>5486</i>&nbsp;             * to the roots vector.
<i>5487</i>&nbsp;             */
<b class="nc"><i>5488</i>&nbsp;            for(int i = 0; i &lt; roots.size(); i++) {</b>
<b class="nc"><i>5489</i>&nbsp;                JComponent root = roots.elementAt(i);</b>
<b class="nc"><i>5490</i>&nbsp;                for(Component p = root.getParent(); p != null; p = p.getParent()) {</b>
<b class="nc"><i>5491</i>&nbsp;                    if (p == c) {</b>
<b class="nc"><i>5492</i>&nbsp;                        roots.removeElementAt(i--); // !!</b>
<b class="nc"><i>5493</i>&nbsp;                        break;</b>
<i>5494</i>&nbsp;                    }
<i>5495</i>&nbsp;                }
<b class="nc"><i>5496</i>&nbsp;            }</b>
<b class="nc"><i>5497</i>&nbsp;</b>
<i>5498</i>&nbsp;            roots.addElement(c);
<b class="nc"><i>5499</i>&nbsp;        }</b>
<b class="nc"><i>5500</i>&nbsp;    }</b>
<i>5501</i>&nbsp;
<i>5502</i>&nbsp;
<i>5503</i>&nbsp;    /**
<i>5504</i>&nbsp;     * We use the &lt;code&gt;ObjectInputStream&lt;/code&gt; &quot;registerValidation&quot;
<i>5505</i>&nbsp;     * callback to update the UI for the entire tree of components
<i>5506</i>&nbsp;     * after they&#39;ve all been read in.
<i>5507</i>&nbsp;     *
<i>5508</i>&nbsp;     * @param s  the &lt;code&gt;ObjectInputStream&lt;/code&gt; from which to read
<i>5509</i>&nbsp;     */
<i>5510</i>&nbsp;    private void readObject(ObjectInputStream s)
<i>5511</i>&nbsp;        throws IOException, ClassNotFoundException
<i>5512</i>&nbsp;    {
<i>5513</i>&nbsp;        ObjectInputStream.GetField f = s.readFields();
<i>5514</i>&nbsp;
<i>5515</i>&nbsp;        isAlignmentXSet = f.get(&quot;isAlignmentXSet&quot;, false);
<b class="nc"><i>5516</i>&nbsp;        alignmentX = validateAlignment(f.get(&quot;alignmentX&quot;, 0f));</b>
<b class="nc"><i>5517</i>&nbsp;        isAlignmentYSet = f.get(&quot;isAlignmentYSet&quot;, false);</b>
<b class="nc"><i>5518</i>&nbsp;        alignmentY = validateAlignment(f.get(&quot;alignmentY&quot;, 0f));</b>
<b class="nc"><i>5519</i>&nbsp;        listenerList = (EventListenerList) f.get(&quot;listenerList&quot;, null);</b>
<b class="nc"><i>5520</i>&nbsp;        vetoableChangeSupport = (VetoableChangeSupport) f.get(&quot;vetoableChangeSupport&quot;, null);</b>
<b class="nc"><i>5521</i>&nbsp;        autoscrolls = f.get(&quot;autoscrolls&quot;, false);</b>
<i>5522</i>&nbsp;        border = (Border) f.get(&quot;border&quot;, null);
<i>5523</i>&nbsp;        flags = f.get(&quot;flags&quot;, 0);
<b class="nc"><i>5524</i>&nbsp;        inputVerifier = (InputVerifier) f.get(&quot;inputVerifier&quot;, null);</b>
<i>5525</i>&nbsp;        verifyInputWhenFocusTarget = f.get(&quot;verifyInputWhenFocusTarget&quot;, false);
<i>5526</i>&nbsp;        popupMenu = (JPopupMenu) f.get(&quot;popupMenu&quot;, null);
<i>5527</i>&nbsp;        focusInputMap = (InputMap) f.get(&quot;focusInputMap&quot;, null);
<i>5528</i>&nbsp;        ancestorInputMap = (InputMap) f.get(&quot;ancestorInputMap&quot;, null);
<i>5529</i>&nbsp;        windowInputMap = (ComponentInputMap) f.get(&quot;windowInputMap&quot;, null);
<i>5530</i>&nbsp;        actionMap = (ActionMap) f.get(&quot;actionMap&quot;, null);
<i>5531</i>&nbsp;
<i>5532</i>&nbsp;        /* If there&#39;s no ReadObjectCallback for this stream yet, that is, if
<i>5533</i>&nbsp;         * this is the first call to JComponent.readObject() for this
<i>5534</i>&nbsp;         * graph of objects, then create a callback and stash it
<i>5535</i>&nbsp;         * in the readObjectCallbacks table.  Note that the ReadObjectCallback
<i>5536</i>&nbsp;         * constructor takes care of calling s.registerValidation().
<i>5537</i>&nbsp;         */
<i>5538</i>&nbsp;        ReadObjectCallback cb = readObjectCallbacks.get(s);
<b class="nc"><i>5539</i>&nbsp;        if (cb == null) {</b>
<b class="nc"><i>5540</i>&nbsp;            try {</b>
<b class="nc"><i>5541</i>&nbsp;                readObjectCallbacks.put(s, cb = new ReadObjectCallback(s));</b>
<b class="nc"><i>5542</i>&nbsp;            }</b>
<b class="nc"><i>5543</i>&nbsp;            catch (Exception e) {</b>
<b class="nc"><i>5544</i>&nbsp;                throw new IOException(e.toString());</b>
<b class="nc"><i>5545</i>&nbsp;            }</b>
<b class="nc"><i>5546</i>&nbsp;        }</b>
<i>5547</i>&nbsp;        cb.registerComponent(this);
<b class="nc"><i>5548</i>&nbsp;</b>
<i>5549</i>&nbsp;        // Read back the client properties.
<i>5550</i>&nbsp;        int cpCount = s.readInt();
<i>5551</i>&nbsp;        if (cpCount &gt; 0) {
<i>5552</i>&nbsp;            clientProperties = new ArrayTable();
<i>5553</i>&nbsp;            for (int counter = 0; counter &lt; cpCount; counter++) {
<i>5554</i>&nbsp;                clientProperties.put(s.readObject(),
<i>5555</i>&nbsp;                                     s.readObject());
<i>5556</i>&nbsp;            }
<i>5557</i>&nbsp;        }
<i>5558</i>&nbsp;        if (getToolTipText() != null) {
<i>5559</i>&nbsp;            ToolTipManager.sharedInstance().registerComponent(this);
<i>5560</i>&nbsp;        }
<i>5561</i>&nbsp;        setWriteObjCounter(this, (byte)0);
<i>5562</i>&nbsp;        revalidateRunnableScheduled = new AtomicBoolean(false);
<i>5563</i>&nbsp;    }
<b class="nc"><i>5564</i>&nbsp;</b>
<b class="nc"><i>5565</i>&nbsp;</b>
<b class="nc"><i>5566</i>&nbsp;    /**</b>
<b class="nc"><i>5567</i>&nbsp;     * Before writing a &lt;code&gt;JComponent&lt;/code&gt; to an</b>
<b class="nc"><i>5568</i>&nbsp;     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; we temporarily uninstall its UI.</b>
<b class="nc"><i>5569</i>&nbsp;     * This is tricky to do because we want to uninstall</b>
<b class="nc"><i>5570</i>&nbsp;     * the UI before any of the &lt;code&gt;JComponent&lt;/code&gt;&#39;s children</b>
<i>5571</i>&nbsp;     * (or its &lt;code&gt;LayoutManager&lt;/code&gt; etc.) are written,
<b class="nc"><i>5572</i>&nbsp;     * and we don&#39;t want to restore the UI until the most derived</b>
<i>5573</i>&nbsp;     * &lt;code&gt;JComponent&lt;/code&gt; subclass has been stored.
<i>5574</i>&nbsp;     *
<i>5575</i>&nbsp;     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; in which to write
<i>5576</i>&nbsp;     */
<i>5577</i>&nbsp;    private void writeObject(ObjectOutputStream s) throws IOException {
<i>5578</i>&nbsp;        s.defaultWriteObject();
<i>5579</i>&nbsp;        if (getUIClassID().equals(uiClassID)) {
<i>5580</i>&nbsp;            byte count = JComponent.getWriteObjCounter(this);
<i>5581</i>&nbsp;            JComponent.setWriteObjCounter(this, --count);
<i>5582</i>&nbsp;            if (count == 0 &amp;&amp; ui != null) {
<i>5583</i>&nbsp;                ui.installUI(this);
<i>5584</i>&nbsp;            }
<i>5585</i>&nbsp;        }
<i>5586</i>&nbsp;        ArrayTable.writeArrayTable(s, clientProperties);
<i>5587</i>&nbsp;    }
<i>5588</i>&nbsp;
<i>5589</i>&nbsp;
<i>5590</i>&nbsp;    /**
<i>5591</i>&nbsp;     * Returns a string representation of this &lt;code&gt;JComponent&lt;/code&gt;.
<i>5592</i>&nbsp;     * This method
<i>5593</i>&nbsp;     * is intended to be used only for debugging purposes, and the
<i>5594</i>&nbsp;     * content and format of the returned string may vary between
<i>5595</i>&nbsp;     * implementations. The returned string may be empty but may not
<i>5596</i>&nbsp;     * be &lt;code&gt;null&lt;/code&gt;.
<i>5597</i>&nbsp;     *
<i>5598</i>&nbsp;     * @return  a string representation of this &lt;code&gt;JComponent&lt;/code&gt;
<i>5599</i>&nbsp;     */
<i>5600</i>&nbsp;    protected String paramString() {
<i>5601</i>&nbsp;        String preferredSizeString = (isPreferredSizeSet() ?
<i>5602</i>&nbsp;                                      getPreferredSize().toString() : &quot;&quot;);
<i>5603</i>&nbsp;        String minimumSizeString = (isMinimumSizeSet() ?
<i>5604</i>&nbsp;                                    getMinimumSize().toString() : &quot;&quot;);
<i>5605</i>&nbsp;        String maximumSizeString = (isMaximumSizeSet() ?
<i>5606</i>&nbsp;                                    getMaximumSize().toString() : &quot;&quot;);
<i>5607</i>&nbsp;        String borderString = (border == null ? &quot;&quot;
<i>5608</i>&nbsp;                               : (border == this ? &quot;this&quot; : border.toString()));
<i>5609</i>&nbsp;
<i>5610</i>&nbsp;        return super.paramString() +
<i>5611</i>&nbsp;        &quot;,alignmentX=&quot; + alignmentX +
<i>5612</i>&nbsp;        &quot;,alignmentY=&quot; + alignmentY +
<i>5613</i>&nbsp;        &quot;,border=&quot; + borderString +
<i>5614</i>&nbsp;        &quot;,flags=&quot; + flags +             // should beef this up a bit
<i>5615</i>&nbsp;        &quot;,maximumSize=&quot; + maximumSizeString +
<i>5616</i>&nbsp;        &quot;,minimumSize=&quot; + minimumSizeString +
<i>5617</i>&nbsp;        &quot;,preferredSize=&quot; + preferredSizeString;
<i>5618</i>&nbsp;    }
<i>5619</i>&nbsp;
<i>5620</i>&nbsp;    /**
<i>5621</i>&nbsp;     * {@inheritDoc}
<i>5622</i>&nbsp;     */
<i>5623</i>&nbsp;    @Override
<i>5624</i>&nbsp;    @Deprecated
<i>5625</i>&nbsp;    public void hide() {
<i>5626</i>&nbsp;        boolean showing = isShowing();
<i>5627</i>&nbsp;        super.hide();
<i>5628</i>&nbsp;        if (showing) {
<i>5629</i>&nbsp;            Container parent = getParent();
<i>5630</i>&nbsp;            if (parent != null) {
<i>5631</i>&nbsp;                Rectangle r = getBounds();
<i>5632</i>&nbsp;                parent.repaint(r.x, r.y, r.width, r.height);
<i>5633</i>&nbsp;            }
<i>5634</i>&nbsp;            revalidate();
<i>5635</i>&nbsp;        }
<i>5636</i>&nbsp;    }
<i>5637</i>&nbsp;
<i>5638</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
