


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ClassDefinition</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.tools.java</a> ]
</div>

<h1>Coverage Summary for Class: ClassDefinition (sun.tools.java)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassDefinition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 105)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 550)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1994, 2015, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.tools.java;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.*;
<i>29</i>&nbsp;import java.io.OutputStream;
<i>30</i>&nbsp;import java.io.PrintStream;
<i>31</i>&nbsp;import sun.tools.tree.Context;
<i>32</i>&nbsp;import sun.tools.tree.Vset;
<i>33</i>&nbsp;import sun.tools.tree.Expression;
<i>34</i>&nbsp;import sun.tools.tree.LocalMember;
<i>35</i>&nbsp;import sun.tools.tree.UplevelReference;
<i>36</i>&nbsp;
<i>37</i>&nbsp;/**
<i>38</i>&nbsp; * This class is a Java class definition
<i>39</i>&nbsp; *
<i>40</i>&nbsp; * WARNING: The contents of this source file are not part of any
<i>41</i>&nbsp; * supported API.  Code that depends on them does so at its own risk:
<i>42</i>&nbsp; * they are subject to change or removal without notice.
<i>43</i>&nbsp; */
<i>44</i>&nbsp;@SuppressWarnings(&quot;deprecation&quot;)
<i>45</i>&nbsp;public
<i>46</i>&nbsp;class ClassDefinition implements Constants {
<i>47</i>&nbsp;
<i>48</i>&nbsp;    protected Object source;
<i>49</i>&nbsp;    protected long where;
<i>50</i>&nbsp;    protected int modifiers;
<i>51</i>&nbsp;    protected Identifier localName; // for local classes
<i>52</i>&nbsp;    protected ClassDeclaration declaration;
<i>53</i>&nbsp;    protected IdentifierToken superClassId;
<i>54</i>&nbsp;    protected IdentifierToken interfaceIds[];
<i>55</i>&nbsp;    protected ClassDeclaration superClass;
<i>56</i>&nbsp;    protected ClassDeclaration interfaces[];
<i>57</i>&nbsp;    protected ClassDefinition outerClass;
<i>58</i>&nbsp;    protected MemberDefinition outerMember;
<i>59</i>&nbsp;    protected MemberDefinition innerClassMember;        // field for me in outerClass
<i>60</i>&nbsp;    protected MemberDefinition firstMember;
<i>61</i>&nbsp;    protected MemberDefinition lastMember;
<i>62</i>&nbsp;    protected boolean resolved;
<i>63</i>&nbsp;    protected String documentation;
<i>64</i>&nbsp;    protected boolean error;
<i>65</i>&nbsp;    protected boolean nestError;
<i>66</i>&nbsp;    protected UplevelReference references;
<b class="nc"><i>67</i>&nbsp;    protected boolean referencesFrozen;</b>
<i>68</i>&nbsp;    private Hashtable&lt;Identifier, MemberDefinition&gt; fieldHash = new Hashtable&lt;&gt;(31);
<i>69</i>&nbsp;    private int abstr;
<i>70</i>&nbsp;
<i>71</i>&nbsp;    // Table of local and anonymous classes whose internal names are constructed
<i>72</i>&nbsp;    // using the current class as a prefix.  This is part of a fix for
<i>73</i>&nbsp;    // bugid 4054523 and 4030421.  See also &#39;Environment.getClassDefinition&#39;
<b class="nc"><i>74</i>&nbsp;    // and &#39;BatchEnvironment.makeClassDefinition&#39;.  Allocated on demand.</b>
<b class="nc"><i>75</i>&nbsp;    private Hashtable&lt;String, ClassDefinition&gt; localClasses = null;</b>
<i>76</i>&nbsp;    private final int LOCAL_CLASSES_SIZE = 31;
<i>77</i>&nbsp;
<i>78</i>&nbsp;    // The immediately surrounding context in which the class appears.
<i>79</i>&nbsp;    // Set at the beginning of checking, upon entry to &#39;SourceClass.checkInternal&#39;.
<i>80</i>&nbsp;    // Null for classes that are not local or inside a local class.
<i>81</i>&nbsp;    // At present, this field exists only for the benefit of &#39;resolveName&#39; as part
<i>82</i>&nbsp;    // of the fix for 4095716.
<i>83</i>&nbsp;    protected Context classContext;
<i>84</i>&nbsp;
<i>85</i>&nbsp;    // The saved class context is now also used in &#39;SourceClass.getAccessMember&#39;.
<i>86</i>&nbsp;    // Provide read-only access via this method.  Part of fix for 4098093.
<b class="nc"><i>87</i>&nbsp;    public Context getClassContext() {</b>
<i>88</i>&nbsp;        return classContext;
<i>89</i>&nbsp;    }
<i>90</i>&nbsp;
<i>91</i>&nbsp;
<i>92</i>&nbsp;    /**
<i>93</i>&nbsp;     * Constructor
<i>94</i>&nbsp;     */
<b class="nc"><i>95</i>&nbsp;    protected ClassDefinition(Object source, long where, ClassDeclaration declaration,</b>
<b class="nc"><i>96</i>&nbsp;                              int modifiers, IdentifierToken superClass, IdentifierToken interfaces[]) {</b>
<b class="nc"><i>97</i>&nbsp;        this.source = source;</b>
<b class="nc"><i>98</i>&nbsp;        this.where = where;</b>
<b class="nc"><i>99</i>&nbsp;        this.declaration = declaration;</b>
<b class="nc"><i>100</i>&nbsp;        this.modifiers = modifiers;</b>
<b class="nc"><i>101</i>&nbsp;        this.superClassId = superClass;</b>
<i>102</i>&nbsp;        this.interfaceIds = interfaces;
<i>103</i>&nbsp;    }
<i>104</i>&nbsp;
<i>105</i>&nbsp;    /**
<i>106</i>&nbsp;     * Get the source of the class
<i>107</i>&nbsp;     */
<b class="nc"><i>108</i>&nbsp;    public final Object getSource() {</b>
<i>109</i>&nbsp;        return source;
<i>110</i>&nbsp;    }
<i>111</i>&nbsp;
<i>112</i>&nbsp;    /**
<i>113</i>&nbsp;     * Check if there were any errors in this class.
<i>114</i>&nbsp;     */
<b class="nc"><i>115</i>&nbsp;    public final boolean getError() {</b>
<i>116</i>&nbsp;        return error;
<i>117</i>&nbsp;    }
<i>118</i>&nbsp;
<i>119</i>&nbsp;    /**
<i>120</i>&nbsp;     * Mark this class to be erroneous.
<i>121</i>&nbsp;     */
<b class="nc"><i>122</i>&nbsp;    public final void setError() {</b>
<b class="nc"><i>123</i>&nbsp;        this.error = true;</b>
<i>124</i>&nbsp;        setNestError();
<i>125</i>&nbsp;    }
<i>126</i>&nbsp;
<i>127</i>&nbsp;    /**
<i>128</i>&nbsp;     * Check if there were any errors in our class nest.
<i>129</i>&nbsp;     */
<i>130</i>&nbsp;    public final boolean getNestError() {
<i>131</i>&nbsp;        // Check to see if our error value is set, or if any of our
<i>132</i>&nbsp;        // outer classes&#39; error values are set.  This will work in
<i>133</i>&nbsp;        // conjunction with setError(), which sets the error value
<i>134</i>&nbsp;        // of its outer class, to yield true is any of our nest
<i>135</i>&nbsp;        // siblings has an error.  This addresses bug 4111488: either
<i>136</i>&nbsp;        // code should be generated for all classes in a nest, or
<b class="nc"><i>137</i>&nbsp;        // none of them.</b>
<i>138</i>&nbsp;        return nestError || ((outerClass != null) ? outerClass.getNestError() : false);
<i>139</i>&nbsp;    }
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /**
<i>142</i>&nbsp;     * Mark this class, and all siblings in its class nest, to be
<i>143</i>&nbsp;     * erroneous.
<i>144</i>&nbsp;     */
<b class="nc"><i>145</i>&nbsp;    public final void setNestError() {</b>
<b class="nc"><i>146</i>&nbsp;        this.nestError = true;</b>
<i>147</i>&nbsp;        if (outerClass != null) {
<i>148</i>&nbsp;            // If we have an outer class, set it to be erroneous as well.
<i>149</i>&nbsp;            // This will work in conjunction with getError(), which checks
<i>150</i>&nbsp;            // the error value of its outer class, to set the whole class
<i>151</i>&nbsp;            // nest to be erroneous.  This address bug 4111488: either
<i>152</i>&nbsp;            // code should be generated for all classes in a nest, or
<b class="nc"><i>153</i>&nbsp;            // none of them.</b>
<i>154</i>&nbsp;            outerClass.setNestError();
<i>155</i>&nbsp;        }
<i>156</i>&nbsp;    }
<i>157</i>&nbsp;
<i>158</i>&nbsp;    /**
<i>159</i>&nbsp;     * Get the position in the input
<i>160</i>&nbsp;     */
<b class="nc"><i>161</i>&nbsp;    public final long getWhere() {</b>
<i>162</i>&nbsp;        return where;
<i>163</i>&nbsp;    }
<i>164</i>&nbsp;
<i>165</i>&nbsp;    /**
<i>166</i>&nbsp;     * Get the class declaration
<i>167</i>&nbsp;     */
<b class="nc"><i>168</i>&nbsp;    public final ClassDeclaration getClassDeclaration() {</b>
<i>169</i>&nbsp;        return declaration;
<i>170</i>&nbsp;    }
<i>171</i>&nbsp;
<i>172</i>&nbsp;    /**
<i>173</i>&nbsp;     * Get the class&#39; modifiers
<i>174</i>&nbsp;     */
<b class="nc"><i>175</i>&nbsp;    public final int getModifiers() {</b>
<i>176</i>&nbsp;        return modifiers;
<i>177</i>&nbsp;    }
<b class="nc"><i>178</i>&nbsp;    public final void subModifiers(int mod) {</b>
<i>179</i>&nbsp;        modifiers &amp;= ~mod;
<i>180</i>&nbsp;    }
<b class="nc"><i>181</i>&nbsp;    public final void addModifiers(int mod) {</b>
<i>182</i>&nbsp;        modifiers |= mod;
<i>183</i>&nbsp;    }
<i>184</i>&nbsp;
<b class="nc"><i>185</i>&nbsp;    // *** DEBUG ***</b>
<i>186</i>&nbsp;    protected boolean supersCheckStarted = !(this instanceof sun.tools.javac.SourceClass);
<i>187</i>&nbsp;
<i>188</i>&nbsp;    /**
<i>189</i>&nbsp;     * Get the class&#39; super class
<i>190</i>&nbsp;     */
<i>191</i>&nbsp;    public final ClassDeclaration getSuperClass() {
<i>192</i>&nbsp;        /*---
<i>193</i>&nbsp;        if (superClass == null &amp;&amp; superClassId != null)
<i>194</i>&nbsp;            throw new CompilerError(&quot;getSuperClass &quot;+superClassId);
<i>195</i>&nbsp;        // There are obscure cases where null is the right answer,
<i>196</i>&nbsp;        // in order to enable some error reporting later on.
<i>197</i>&nbsp;        // For example:  class T extends T.N { class N { } }
<i>198</i>&nbsp;        ---*/
<i>199</i>&nbsp;
<i>200</i>&nbsp;        // *** DEBUG ***
<b class="nc"><i>201</i>&nbsp;        // This method should not be called if the superclass has not been resolved.</b>
<i>202</i>&nbsp;        if (!supersCheckStarted) throw new CompilerError(&quot;unresolved super&quot;);
<b class="nc"><i>203</i>&nbsp;</b>
<i>204</i>&nbsp;        return superClass;
<i>205</i>&nbsp;    }
<i>206</i>&nbsp;
<i>207</i>&nbsp;    /**
<i>208</i>&nbsp;     * Get the super class, and resolve names now if necessary.
<i>209</i>&nbsp;     *
<i>210</i>&nbsp;     * It is only possible to resolve names at this point if we are
<i>211</i>&nbsp;     * a source class.  The provision of this method at this level
<i>212</i>&nbsp;     * in the class hierarchy is dubious, but see &#39;getInnerClass&#39; below.
<i>213</i>&nbsp;     * All other calls to &#39;getSuperClass(env)&#39; appear in &#39;SourceClass&#39;.
<i>214</i>&nbsp;     * NOTE: An older definition of this method has been moved to
<i>215</i>&nbsp;     * &#39;SourceClass&#39;, where it overrides this one.
<i>216</i>&nbsp;     *
<i>217</i>&nbsp;     * @see #resolveTypeStructure
<i>218</i>&nbsp;     */
<i>219</i>&nbsp;
<b class="nc"><i>220</i>&nbsp;    public ClassDeclaration getSuperClass(Environment env) {</b>
<i>221</i>&nbsp;        return getSuperClass();
<i>222</i>&nbsp;    }
<i>223</i>&nbsp;
<i>224</i>&nbsp;    /**
<i>225</i>&nbsp;     * Get the class&#39; interfaces
<i>226</i>&nbsp;     */
<b class="nc"><i>227</i>&nbsp;    public final ClassDeclaration getInterfaces()[] {</b>
<b class="nc"><i>228</i>&nbsp;        if (interfaces == null)  throw new CompilerError(&quot;getInterfaces&quot;);</b>
<i>229</i>&nbsp;        return interfaces;
<i>230</i>&nbsp;    }
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /**
<i>233</i>&nbsp;     * Get the class&#39; enclosing class (or null if not inner)
<i>234</i>&nbsp;     */
<b class="nc"><i>235</i>&nbsp;    public final ClassDefinition getOuterClass() {</b>
<i>236</i>&nbsp;        return outerClass;
<i>237</i>&nbsp;    }
<i>238</i>&nbsp;
<i>239</i>&nbsp;    /**
<i>240</i>&nbsp;     * Set the class&#39; enclosing class.  Must be done at most once.
<i>241</i>&nbsp;     */
<b class="nc"><i>242</i>&nbsp;    protected final void setOuterClass(ClassDefinition outerClass) {</b>
<b class="nc"><i>243</i>&nbsp;        if (this.outerClass != null)  throw new CompilerError(&quot;setOuterClass&quot;);</b>
<i>244</i>&nbsp;        this.outerClass = outerClass;
<i>245</i>&nbsp;    }
<i>246</i>&nbsp;
<i>247</i>&nbsp;    /**
<i>248</i>&nbsp;     * Set the class&#39; enclosing current instance pointer.
<i>249</i>&nbsp;     * Must be done at most once.
<i>250</i>&nbsp;     */
<i>251</i>&nbsp;    protected final void setOuterMember(MemberDefinition outerMember) {
<b class="nc"><i>252</i>&nbsp;</b>
<b class="nc"><i>253</i>&nbsp;        if (isStatic() || !isInnerClass())  throw new CompilerError(&quot;setOuterField&quot;);</b>
<b class="nc"><i>254</i>&nbsp;        if (this.outerMember != null)  throw new CompilerError(&quot;setOuterField&quot;);</b>
<i>255</i>&nbsp;        this.outerMember = outerMember;
<i>256</i>&nbsp;    }
<i>257</i>&nbsp;
<i>258</i>&nbsp;    /**
<i>259</i>&nbsp;     * Tell if the class is inner.
<i>260</i>&nbsp;     * This predicate also returns true for top-level nested types.
<i>261</i>&nbsp;     * To test for a true inner class as seen by the programmer,
<i>262</i>&nbsp;     * use {@code !isTopLevel()}.
<i>263</i>&nbsp;     */
<b class="nc"><i>264</i>&nbsp;    public final boolean isInnerClass() {</b>
<i>265</i>&nbsp;        return outerClass != null;
<i>266</i>&nbsp;    }
<i>267</i>&nbsp;
<i>268</i>&nbsp;    /**
<i>269</i>&nbsp;     * Tell if the class is a member of another class.
<i>270</i>&nbsp;     * This is false for package members and for block-local classes.
<i>271</i>&nbsp;     */
<b class="nc"><i>272</i>&nbsp;    public final boolean isMember() {</b>
<i>273</i>&nbsp;        return outerClass != null &amp;&amp; !isLocal();
<i>274</i>&nbsp;    }
<i>275</i>&nbsp;
<i>276</i>&nbsp;    /**
<i>277</i>&nbsp;     * Tell if the class is &quot;top-level&quot;, which is either a package member,
<i>278</i>&nbsp;     * or a static member of another top-level class.
<i>279</i>&nbsp;     */
<b class="nc"><i>280</i>&nbsp;    public final boolean isTopLevel() {</b>
<i>281</i>&nbsp;        return outerClass == null || isStatic() || isInterface();
<i>282</i>&nbsp;    }
<i>283</i>&nbsp;
<i>284</i>&nbsp;    /**
<i>285</i>&nbsp;     * Tell if the class is local or inside a local class,
<i>286</i>&nbsp;     * which means it cannot be mentioned outside of its file.
<i>287</i>&nbsp;     */
<i>288</i>&nbsp;
<i>289</i>&nbsp;    // The comment above is true only because M_LOCAL is set
<i>290</i>&nbsp;    // whenever M_ANONYMOUS is.  I think it is risky to assume that
<i>291</i>&nbsp;    // isAnonymous(x) =&gt; isLocal(x).
<i>292</i>&nbsp;
<b class="nc"><i>293</i>&nbsp;    public final boolean isInsideLocal() {</b>
<b class="nc"><i>294</i>&nbsp;        return isLocal() ||</b>
<i>295</i>&nbsp;            (outerClass != null &amp;&amp; outerClass.isInsideLocal());
<i>296</i>&nbsp;    }
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /**
<i>299</i>&nbsp;     * Tell if the class is local or anonymous class, or inside
<i>300</i>&nbsp;     * such a class, which means it cannot be mentioned outside of
<i>301</i>&nbsp;     * its file.
<i>302</i>&nbsp;     */
<b class="nc"><i>303</i>&nbsp;    public final boolean isInsideLocalOrAnonymous() {</b>
<b class="nc"><i>304</i>&nbsp;        return isLocal() || isAnonymous () ||</b>
<i>305</i>&nbsp;            (outerClass != null &amp;&amp; outerClass.isInsideLocalOrAnonymous());
<i>306</i>&nbsp;    }
<i>307</i>&nbsp;
<i>308</i>&nbsp;    /**
<i>309</i>&nbsp;     * Return a simple identifier for this class (idNull if anonymous).
<i>310</i>&nbsp;     */
<b class="nc"><i>311</i>&nbsp;    public Identifier getLocalName() {</b>
<b class="nc"><i>312</i>&nbsp;        if (localName != null) {</b>
<i>313</i>&nbsp;            return localName;
<i>314</i>&nbsp;        }
<b class="nc"><i>315</i>&nbsp;        // This is also the name of the innerClassMember, if any:</b>
<i>316</i>&nbsp;        return getName().getFlatName().getName();
<i>317</i>&nbsp;    }
<i>318</i>&nbsp;
<i>319</i>&nbsp;    /**
<i>320</i>&nbsp;     * Set the local name of a class.  Must be a local class.
<i>321</i>&nbsp;     */
<b class="nc"><i>322</i>&nbsp;    public void setLocalName(Identifier name) {</b>
<b class="nc"><i>323</i>&nbsp;        if (isLocal()) {</b>
<i>324</i>&nbsp;            localName = name;
<i>325</i>&nbsp;        }
<i>326</i>&nbsp;    }
<i>327</i>&nbsp;
<i>328</i>&nbsp;    /**
<i>329</i>&nbsp;     * If inner, get the field for this class in the enclosing class
<i>330</i>&nbsp;     */
<b class="nc"><i>331</i>&nbsp;    public final MemberDefinition getInnerClassMember() {</b>
<b class="nc"><i>332</i>&nbsp;        if (outerClass == null)</b>
<b class="nc"><i>333</i>&nbsp;            return null;</b>
<i>334</i>&nbsp;        if (innerClassMember == null) {
<b class="nc"><i>335</i>&nbsp;            // We must find the field in the outer class.</b>
<b class="nc"><i>336</i>&nbsp;            Identifier nm = getName().getFlatName().getName();</b>
<b class="nc"><i>337</i>&nbsp;            for (MemberDefinition field = outerClass.getFirstMatch(nm);</b>
<b class="nc"><i>338</i>&nbsp;                 field != null; field = field.getNextMatch()) {</b>
<b class="nc"><i>339</i>&nbsp;                if (field.isInnerClass()) {</b>
<b class="nc"><i>340</i>&nbsp;                    innerClassMember = field;</b>
<i>341</i>&nbsp;                    break;
<i>342</i>&nbsp;                }
<b class="nc"><i>343</i>&nbsp;            }</b>
<b class="nc"><i>344</i>&nbsp;            if (innerClassMember == null)</b>
<i>345</i>&nbsp;                throw new CompilerError(&quot;getInnerClassField&quot;);
<b class="nc"><i>346</i>&nbsp;        }</b>
<i>347</i>&nbsp;        return innerClassMember;
<i>348</i>&nbsp;    }
<i>349</i>&nbsp;
<i>350</i>&nbsp;    /**
<i>351</i>&nbsp;     * If inner, return an innermost uplevel self pointer, if any exists.
<i>352</i>&nbsp;     * Otherwise, return null.
<i>353</i>&nbsp;     */
<b class="nc"><i>354</i>&nbsp;    public final MemberDefinition findOuterMember() {</b>
<i>355</i>&nbsp;        return outerMember;
<i>356</i>&nbsp;    }
<i>357</i>&nbsp;
<i>358</i>&nbsp;    /**
<i>359</i>&nbsp;     * See if this is a (nested) static class.
<i>360</i>&nbsp;     */
<b class="nc"><i>361</i>&nbsp;    public final boolean isStatic() {</b>
<i>362</i>&nbsp;        return (modifiers &amp; ACC_STATIC) != 0;
<i>363</i>&nbsp;    }
<i>364</i>&nbsp;
<i>365</i>&nbsp;    /**
<i>366</i>&nbsp;     * Get the class&#39; top-level enclosing class
<i>367</i>&nbsp;     */
<i>368</i>&nbsp;    public final ClassDefinition getTopClass() {
<b class="nc"><i>369</i>&nbsp;        ClassDefinition p, q;</b>
<i>370</i>&nbsp;        for (p = this; (q = p.outerClass) != null; p = q)
<b class="nc"><i>371</i>&nbsp;            ;</b>
<i>372</i>&nbsp;        return p;
<i>373</i>&nbsp;    }
<i>374</i>&nbsp;
<i>375</i>&nbsp;    /**
<i>376</i>&nbsp;     * Get the class&#39; first field or first match
<i>377</i>&nbsp;     */
<b class="nc"><i>378</i>&nbsp;    public final MemberDefinition getFirstMember() {</b>
<i>379</i>&nbsp;        return firstMember;
<i>380</i>&nbsp;    }
<b class="nc"><i>381</i>&nbsp;    public final MemberDefinition getFirstMatch(Identifier name) {</b>
<i>382</i>&nbsp;        return fieldHash.get(name);
<i>383</i>&nbsp;    }
<i>384</i>&nbsp;
<i>385</i>&nbsp;    /**
<i>386</i>&nbsp;     * Get the class&#39; name
<i>387</i>&nbsp;     */
<b class="nc"><i>388</i>&nbsp;    public final Identifier getName() {</b>
<i>389</i>&nbsp;        return declaration.getName();
<i>390</i>&nbsp;    }
<i>391</i>&nbsp;
<i>392</i>&nbsp;    /**
<i>393</i>&nbsp;     * Get the class&#39; type
<i>394</i>&nbsp;     */
<b class="nc"><i>395</i>&nbsp;    public final Type getType() {</b>
<i>396</i>&nbsp;        return declaration.getType();
<i>397</i>&nbsp;    }
<i>398</i>&nbsp;
<i>399</i>&nbsp;    /**
<i>400</i>&nbsp;     * Get the class&#39; documentation
<i>401</i>&nbsp;     */
<b class="nc"><i>402</i>&nbsp;    public String getDocumentation() {</b>
<i>403</i>&nbsp;        return documentation;
<i>404</i>&nbsp;    }
<i>405</i>&nbsp;
<i>406</i>&nbsp;    /**
<i>407</i>&nbsp;     * Return true if the given documentation string contains a deprecation
<i>408</i>&nbsp;     * paragraph.  This is true if the string contains the tag @deprecated
<i>409</i>&nbsp;     * is the first word in a line.
<i>410</i>&nbsp;     */
<b class="nc"><i>411</i>&nbsp;    public static boolean containsDeprecated(String documentation) {</b>
<b class="nc"><i>412</i>&nbsp;        if (documentation == null) {</b>
<i>413</i>&nbsp;            return false;
<i>414</i>&nbsp;        }
<b class="nc"><i>415</i>&nbsp;    doScan:</b>
<b class="nc"><i>416</i>&nbsp;        for (int scan = 0;</b>
<b class="nc"><i>417</i>&nbsp;             (scan = documentation.indexOf(paraDeprecated, scan)) &gt;= 0;</b>
<i>418</i>&nbsp;             scan += paraDeprecated.length()) {
<i>419</i>&nbsp;            // make sure there is only whitespace between this word
<b class="nc"><i>420</i>&nbsp;            // and the beginning of the line</b>
<b class="nc"><i>421</i>&nbsp;            for (int beg = scan-1; beg &gt;= 0; beg--) {</b>
<b class="nc"><i>422</i>&nbsp;                char ch = documentation.charAt(beg);</b>
<b class="nc"><i>423</i>&nbsp;                if (ch == &#39;\n&#39; || ch == &#39;\r&#39;) {</b>
<i>424</i>&nbsp;                    break;      // OK
<b class="nc"><i>425</i>&nbsp;                }</b>
<b class="nc"><i>426</i>&nbsp;                if (!Character.isSpace(ch)) {</b>
<i>427</i>&nbsp;                    continue doScan;
<i>428</i>&nbsp;                }
<i>429</i>&nbsp;            }
<b class="nc"><i>430</i>&nbsp;            // make sure the char after the word is space or end of line</b>
<b class="nc"><i>431</i>&nbsp;            int end = scan+paraDeprecated.length();</b>
<b class="nc"><i>432</i>&nbsp;            if (end &lt; documentation.length()) {</b>
<b class="nc"><i>433</i>&nbsp;                char ch = documentation.charAt(end);</b>
<b class="nc"><i>434</i>&nbsp;                if (!(ch == &#39;\n&#39; || ch == &#39;\r&#39;) &amp;&amp; !Character.isSpace(ch)) {</b>
<i>435</i>&nbsp;                    continue doScan;
<i>436</i>&nbsp;                }
<b class="nc"><i>437</i>&nbsp;            }</b>
<i>438</i>&nbsp;            return true;
<b class="nc"><i>439</i>&nbsp;        }</b>
<i>440</i>&nbsp;        return false;
<i>441</i>&nbsp;    }
<i>442</i>&nbsp;
<i>443</i>&nbsp;    public final boolean inSamePackage(ClassDeclaration c) {
<i>444</i>&nbsp;        // find out if the class stored in c is defined in the same
<b class="nc"><i>445</i>&nbsp;        // package as the current class.</b>
<i>446</i>&nbsp;        return inSamePackage(c.getName().getQualifier());
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;    public final boolean inSamePackage(ClassDefinition c) {
<i>450</i>&nbsp;        // find out if the class stored in c is defined in the same
<b class="nc"><i>451</i>&nbsp;        // package as the current class.</b>
<i>452</i>&nbsp;        return inSamePackage(c.getName().getQualifier());
<i>453</i>&nbsp;    }
<i>454</i>&nbsp;
<b class="nc"><i>455</i>&nbsp;    public final boolean inSamePackage(Identifier packageName) {</b>
<i>456</i>&nbsp;        return (getName().getQualifier().equals(packageName));
<i>457</i>&nbsp;    }
<i>458</i>&nbsp;
<i>459</i>&nbsp;    /**
<i>460</i>&nbsp;     * Checks
<i>461</i>&nbsp;     */
<b class="nc"><i>462</i>&nbsp;    public final boolean isInterface() {</b>
<i>463</i>&nbsp;        return (getModifiers() &amp; M_INTERFACE) != 0;
<i>464</i>&nbsp;    }
<b class="nc"><i>465</i>&nbsp;    public final boolean isClass() {</b>
<i>466</i>&nbsp;        return (getModifiers() &amp; M_INTERFACE) == 0;
<i>467</i>&nbsp;    }
<b class="nc"><i>468</i>&nbsp;    public final boolean isPublic() {</b>
<i>469</i>&nbsp;        return (getModifiers() &amp; M_PUBLIC) != 0;
<i>470</i>&nbsp;    }
<b class="nc"><i>471</i>&nbsp;    public final boolean isPrivate() {</b>
<i>472</i>&nbsp;        return (getModifiers() &amp; M_PRIVATE) != 0;
<i>473</i>&nbsp;    }
<b class="nc"><i>474</i>&nbsp;    public final boolean isProtected() {</b>
<i>475</i>&nbsp;        return (getModifiers() &amp; M_PROTECTED) != 0;
<i>476</i>&nbsp;    }
<b class="nc"><i>477</i>&nbsp;    public final boolean isPackagePrivate() {</b>
<i>478</i>&nbsp;        return (modifiers &amp; (M_PUBLIC | M_PRIVATE | M_PROTECTED)) == 0;
<i>479</i>&nbsp;    }
<b class="nc"><i>480</i>&nbsp;    public final boolean isFinal() {</b>
<i>481</i>&nbsp;        return (getModifiers() &amp; M_FINAL) != 0;
<i>482</i>&nbsp;    }
<b class="nc"><i>483</i>&nbsp;    public final boolean isAbstract() {</b>
<i>484</i>&nbsp;        return (getModifiers() &amp; M_ABSTRACT) != 0;
<i>485</i>&nbsp;    }
<b class="nc"><i>486</i>&nbsp;    public final boolean isSynthetic() {</b>
<i>487</i>&nbsp;        return (getModifiers() &amp; M_SYNTHETIC) != 0;
<i>488</i>&nbsp;    }
<b class="nc"><i>489</i>&nbsp;    public final boolean isDeprecated() {</b>
<i>490</i>&nbsp;        return (getModifiers() &amp; M_DEPRECATED) != 0;
<i>491</i>&nbsp;    }
<b class="nc"><i>492</i>&nbsp;    public final boolean isAnonymous() {</b>
<i>493</i>&nbsp;        return (getModifiers() &amp; M_ANONYMOUS) != 0;
<i>494</i>&nbsp;    }
<b class="nc"><i>495</i>&nbsp;    public final boolean isLocal() {</b>
<i>496</i>&nbsp;        return (getModifiers() &amp; M_LOCAL) != 0;
<i>497</i>&nbsp;    }
<b class="nc"><i>498</i>&nbsp;    public final boolean hasConstructor() {</b>
<i>499</i>&nbsp;        return getFirstMatch(idInit) != null;
<i>500</i>&nbsp;    }
<i>501</i>&nbsp;
<i>502</i>&nbsp;
<i>503</i>&nbsp;    /**
<i>504</i>&nbsp;     * Check to see if a class must be abstract.  This method replaces
<i>505</i>&nbsp;     * isAbstract(env)
<i>506</i>&nbsp;     */
<i>507</i>&nbsp;    public final boolean mustBeAbstract(Environment env) {
<i>508</i>&nbsp;        // If it is declared abstract, return true.
<b class="nc"><i>509</i>&nbsp;        // (Fix for 4110534.)</b>
<b class="nc"><i>510</i>&nbsp;        if (isAbstract()) {</b>
<i>511</i>&nbsp;            return true;
<i>512</i>&nbsp;        }
<i>513</i>&nbsp;
<i>514</i>&nbsp;        // Check to see if the class should have been declared to be
<i>515</i>&nbsp;        // abstract.
<i>516</i>&nbsp;
<i>517</i>&nbsp;        // We make sure that the inherited method collection has been
<b class="nc"><i>518</i>&nbsp;        // performed.</b>
<i>519</i>&nbsp;        collectInheritedMethods(env);
<i>520</i>&nbsp;
<i>521</i>&nbsp;        // We check for any abstract methods inherited or declared
<b class="nc"><i>522</i>&nbsp;        // by this class.</b>
<b class="nc"><i>523</i>&nbsp;        Iterator&lt;MemberDefinition&gt; methods = getMethods();</b>
<b class="nc"><i>524</i>&nbsp;        while (methods.hasNext()) {</b>
<i>525</i>&nbsp;            MemberDefinition method = methods.next();
<b class="nc"><i>526</i>&nbsp;</b>
<b class="nc"><i>527</i>&nbsp;            if (method.isAbstract()) {</b>
<i>528</i>&nbsp;                return true;
<b class="nc"><i>529</i>&nbsp;            }</b>
<i>530</i>&nbsp;        }
<i>531</i>&nbsp;
<i>532</i>&nbsp;        // We check for hidden &quot;permanently abstract&quot; methods in
<b class="nc"><i>533</i>&nbsp;        // our superclasses.</b>
<i>534</i>&nbsp;        return getPermanentlyAbstractMethods().hasNext();
<i>535</i>&nbsp;    }
<i>536</i>&nbsp;
<i>537</i>&nbsp;    /**
<i>538</i>&nbsp;     * Check if this is a super class of another class
<i>539</i>&nbsp;     */
<i>540</i>&nbsp;    public boolean superClassOf(Environment env, ClassDeclaration otherClass)
<b class="nc"><i>541</i>&nbsp;                                                                throws ClassNotFound {</b>
<b class="nc"><i>542</i>&nbsp;        while (otherClass != null) {</b>
<b class="nc"><i>543</i>&nbsp;            if (getClassDeclaration().equals(otherClass)) {</b>
<i>544</i>&nbsp;                return true;
<b class="nc"><i>545</i>&nbsp;            }</b>
<i>546</i>&nbsp;            otherClass = otherClass.getClassDefinition(env).getSuperClass();
<b class="nc"><i>547</i>&nbsp;        }</b>
<i>548</i>&nbsp;        return false;
<i>549</i>&nbsp;    }
<i>550</i>&nbsp;
<i>551</i>&nbsp;    /**
<i>552</i>&nbsp;     * Check if this is an enclosing class of another class
<i>553</i>&nbsp;     */
<b class="nc"><i>554</i>&nbsp;    public boolean enclosingClassOf(ClassDefinition otherClass) {</b>
<b class="nc"><i>555</i>&nbsp;        while ((otherClass = otherClass.getOuterClass()) != null) {</b>
<b class="nc"><i>556</i>&nbsp;            if (this == otherClass) {</b>
<i>557</i>&nbsp;                return true;
<i>558</i>&nbsp;            }
<b class="nc"><i>559</i>&nbsp;        }</b>
<i>560</i>&nbsp;        return false;
<i>561</i>&nbsp;    }
<i>562</i>&nbsp;
<i>563</i>&nbsp;    /**
<i>564</i>&nbsp;     * Check if this is a sub class of another class
<i>565</i>&nbsp;     */
<b class="nc"><i>566</i>&nbsp;    public boolean subClassOf(Environment env, ClassDeclaration otherClass) throws ClassNotFound {</b>
<b class="nc"><i>567</i>&nbsp;        ClassDeclaration c = getClassDeclaration();</b>
<b class="nc"><i>568</i>&nbsp;        while (c != null) {</b>
<b class="nc"><i>569</i>&nbsp;            if (c.equals(otherClass)) {</b>
<i>570</i>&nbsp;                return true;
<b class="nc"><i>571</i>&nbsp;            }</b>
<i>572</i>&nbsp;            c = c.getClassDefinition(env).getSuperClass();
<b class="nc"><i>573</i>&nbsp;        }</b>
<i>574</i>&nbsp;        return false;
<i>575</i>&nbsp;    }
<i>576</i>&nbsp;
<i>577</i>&nbsp;    /**
<i>578</i>&nbsp;     * Check if this class is implemented by another class
<i>579</i>&nbsp;     */
<b class="nc"><i>580</i>&nbsp;    public boolean implementedBy(Environment env, ClassDeclaration c) throws ClassNotFound {</b>
<b class="nc"><i>581</i>&nbsp;        for (; c != null ; c = c.getClassDefinition(env).getSuperClass()) {</b>
<b class="nc"><i>582</i>&nbsp;            if (getClassDeclaration().equals(c)) {</b>
<i>583</i>&nbsp;                return true;
<b class="nc"><i>584</i>&nbsp;            }</b>
<b class="nc"><i>585</i>&nbsp;            ClassDeclaration intf[] = c.getClassDefinition(env).getInterfaces();</b>
<b class="nc"><i>586</i>&nbsp;            for (int i = 0 ; i &lt; intf.length ; i++) {</b>
<b class="nc"><i>587</i>&nbsp;                if (implementedBy(env, intf[i])) {</b>
<i>588</i>&nbsp;                    return true;
<i>589</i>&nbsp;                }
<i>590</i>&nbsp;            }
<b class="nc"><i>591</i>&nbsp;        }</b>
<i>592</i>&nbsp;        return false;
<i>593</i>&nbsp;    }
<i>594</i>&nbsp;
<i>595</i>&nbsp;    /**
<i>596</i>&nbsp;     * Check to see if a class which implements interface `this&#39; could
<i>597</i>&nbsp;     * possibly implement the interface `intDef&#39;.  Note that the only
<i>598</i>&nbsp;     * way that this can fail is if `this&#39; and `intDef&#39; have methods
<i>599</i>&nbsp;     * which are of the same signature and different return types.  This
<i>600</i>&nbsp;     * method is used by Environment.explicitCast() to determine if a
<i>601</i>&nbsp;     * cast between two interfaces is legal.
<i>602</i>&nbsp;     *
<i>603</i>&nbsp;     * This method should only be called on a class after it has been
<i>604</i>&nbsp;     * basicCheck()&#39;ed.
<i>605</i>&nbsp;     */
<i>606</i>&nbsp;    public boolean couldImplement(ClassDefinition intDef) {
<b class="nc"><i>607</i>&nbsp;        // Check to see if we could have done the necessary checks.</b>
<b class="nc"><i>608</i>&nbsp;        if (!doInheritanceChecks) {</b>
<i>609</i>&nbsp;            throw new CompilerError(&quot;couldImplement: no checks&quot;);
<i>610</i>&nbsp;        }
<i>611</i>&nbsp;
<b class="nc"><i>612</i>&nbsp;        // This method should only be called for interfaces.</b>
<b class="nc"><i>613</i>&nbsp;        if (!isInterface() || !intDef.isInterface()) {</b>
<i>614</i>&nbsp;            throw new CompilerError(&quot;couldImplement: not interface&quot;);
<i>615</i>&nbsp;        }
<i>616</i>&nbsp;
<i>617</i>&nbsp;        // Make sure we are not called before we have collected our
<b class="nc"><i>618</i>&nbsp;        // inheritance information.</b>
<b class="nc"><i>619</i>&nbsp;        if (allMethods == null) {</b>
<i>620</i>&nbsp;            throw new CompilerError(&quot;couldImplement: called early&quot;);
<i>621</i>&nbsp;        }
<i>622</i>&nbsp;
<i>623</i>&nbsp;        // Get the other classes&#39; methods.  getMethods() in
<i>624</i>&nbsp;        // general can return methods which are not visible to the
<i>625</i>&nbsp;        // current package.  We need to make sure that these do not
<b class="nc"><i>626</i>&nbsp;        // prevent this class from being implemented.</b>
<i>627</i>&nbsp;        Iterator&lt;MemberDefinition&gt; otherMethods = intDef.getMethods();
<b class="nc"><i>628</i>&nbsp;</b>
<i>629</i>&nbsp;        while (otherMethods.hasNext()) {
<b class="nc"><i>630</i>&nbsp;            // Get one of the methods from intDef...</b>
<b class="nc"><i>631</i>&nbsp;            MemberDefinition method = otherMethods.next();</b>
<i>632</i>&nbsp;
<b class="nc"><i>633</i>&nbsp;            Identifier name = method.getName();</b>
<b class="nc"><i>634</i>&nbsp;            Type type = method.getType();</b>
<i>635</i>&nbsp;
<i>636</i>&nbsp;            // See if we implement a method of the same signature...
<b class="nc"><i>637</i>&nbsp;            MemberDefinition myMethod = allMethods.lookupSig(name, type);</b>
<i>638</i>&nbsp;
<i>639</i>&nbsp;            //System.out.println(&quot;Comparing\n\t&quot; + myMethod +
<i>640</i>&nbsp;            //                   &quot;\nand\n\t&quot; + method);
<i>641</i>&nbsp;
<b class="nc"><i>642</i>&nbsp;            if (myMethod != null) {</b>
<i>643</i>&nbsp;                // We do.  Make sure the methods have the same return type.
<b class="nc"><i>644</i>&nbsp;                if (!myMethod.sameReturnType(method)) {</b>
<b class="nc"><i>645</i>&nbsp;                    return false;</b>
<i>646</i>&nbsp;                }
<i>647</i>&nbsp;            }
<b class="nc"><i>648</i>&nbsp;        }</b>
<i>649</i>&nbsp;
<b class="nc"><i>650</i>&nbsp;        return true;</b>
<i>651</i>&nbsp;    }
<i>652</i>&nbsp;
<i>653</i>&nbsp;    /**
<i>654</i>&nbsp;     * Check if another class can be accessed from the &#39;extends&#39; or &#39;implements&#39;
<i>655</i>&nbsp;     * clause of this class.
<i>656</i>&nbsp;     */
<i>657</i>&nbsp;    public boolean extendsCanAccess(Environment env, ClassDeclaration c) throws ClassNotFound {
<i>658</i>&nbsp;
<i>659</i>&nbsp;        // Names in the &#39;extends&#39; or &#39;implements&#39; clause of an inner class
<i>660</i>&nbsp;        // are checked as if they appeared in the body of the surrounding class.
<b class="nc"><i>661</i>&nbsp;        if (outerClass != null) {</b>
<b class="nc"><i>662</i>&nbsp;            return outerClass.canAccess(env, c);</b>
<i>663</i>&nbsp;        }
<i>664</i>&nbsp;
<i>665</i>&nbsp;        // We are a package member.
<i>666</i>&nbsp;
<b class="nc"><i>667</i>&nbsp;        ClassDefinition cdef = c.getClassDefinition(env);</b>
<i>668</i>&nbsp;
<b class="nc"><i>669</i>&nbsp;        if (cdef.isLocal()) {</b>
<i>670</i>&nbsp;            // No locals should be in scope in the &#39;extends&#39; or
<i>671</i>&nbsp;            // &#39;implements&#39; clause of a package member.
<b class="nc"><i>672</i>&nbsp;            throw new CompilerError(&quot;top local&quot;);</b>
<i>673</i>&nbsp;        }
<i>674</i>&nbsp;
<b class="nc"><i>675</i>&nbsp;        if (cdef.isInnerClass()) {</b>
<b class="nc"><i>676</i>&nbsp;            MemberDefinition f = cdef.getInnerClassMember();</b>
<i>677</i>&nbsp;
<i>678</i>&nbsp;            // Access to public member is always allowed.
<b class="nc"><i>679</i>&nbsp;            if (f.isPublic()) {</b>
<b class="nc"><i>680</i>&nbsp;                return true;</b>
<i>681</i>&nbsp;            }
<i>682</i>&nbsp;
<i>683</i>&nbsp;            // Private access is ok only from the same class nest.  This can
<i>684</i>&nbsp;            // happen only if the class represented by &#39;this&#39; encloses the inner
<i>685</i>&nbsp;            // class represented by &#39;f&#39;.
<b class="nc"><i>686</i>&nbsp;            if (f.isPrivate()) {</b>
<b class="nc"><i>687</i>&nbsp;                return getClassDeclaration().equals(f.getTopClass().getClassDeclaration());</b>
<i>688</i>&nbsp;            }
<i>689</i>&nbsp;
<i>690</i>&nbsp;            // Protected or default access -- allow access if in same package.
<b class="nc"><i>691</i>&nbsp;            return getName().getQualifier().equals(f.getClassDeclaration().getName().getQualifier());</b>
<i>692</i>&nbsp;        }
<i>693</i>&nbsp;
<i>694</i>&nbsp;        // Access to public member is always allowed.
<b class="nc"><i>695</i>&nbsp;        if (cdef.isPublic()) {</b>
<b class="nc"><i>696</i>&nbsp;            return true;</b>
<i>697</i>&nbsp;        }
<i>698</i>&nbsp;
<i>699</i>&nbsp;        // Default access -- allow access if in same package.
<b class="nc"><i>700</i>&nbsp;        return getName().getQualifier().equals(c.getName().getQualifier());</b>
<i>701</i>&nbsp;    }
<i>702</i>&nbsp;
<i>703</i>&nbsp;    /**
<i>704</i>&nbsp;     * Check if another class can be accessed from within the body of this class.
<i>705</i>&nbsp;     */
<i>706</i>&nbsp;    public boolean canAccess(Environment env, ClassDeclaration c) throws ClassNotFound {
<b class="nc"><i>707</i>&nbsp;        ClassDefinition cdef = c.getClassDefinition(env);</b>
<i>708</i>&nbsp;
<b class="nc"><i>709</i>&nbsp;        if (cdef.isLocal()) {</b>
<i>710</i>&nbsp;            // if it&#39;s in scope, it&#39;s accessible
<b class="nc"><i>711</i>&nbsp;            return true;</b>
<i>712</i>&nbsp;        }
<i>713</i>&nbsp;
<b class="nc"><i>714</i>&nbsp;        if (cdef.isInnerClass()) {</b>
<b class="nc"><i>715</i>&nbsp;            return canAccess(env, cdef.getInnerClassMember());</b>
<i>716</i>&nbsp;        }
<i>717</i>&nbsp;
<i>718</i>&nbsp;        // Public access is always ok
<b class="nc"><i>719</i>&nbsp;        if (cdef.isPublic()) {</b>
<b class="nc"><i>720</i>&nbsp;            return true;</b>
<i>721</i>&nbsp;        }
<i>722</i>&nbsp;
<i>723</i>&nbsp;        // It must be in the same package
<b class="nc"><i>724</i>&nbsp;        return getName().getQualifier().equals(c.getName().getQualifier());</b>
<i>725</i>&nbsp;    }
<i>726</i>&nbsp;
<i>727</i>&nbsp;    /**
<i>728</i>&nbsp;     * Check if a field can be accessed from a class
<i>729</i>&nbsp;     */
<i>730</i>&nbsp;
<i>731</i>&nbsp;    public boolean canAccess(Environment env, MemberDefinition f)
<i>732</i>&nbsp;                throws ClassNotFound {
<i>733</i>&nbsp;
<i>734</i>&nbsp;        // Public access is always ok
<b class="nc"><i>735</i>&nbsp;        if (f.isPublic()) {</b>
<b class="nc"><i>736</i>&nbsp;            return true;</b>
<i>737</i>&nbsp;        }
<i>738</i>&nbsp;        // Protected access is ok from a subclass
<b class="nc"><i>739</i>&nbsp;        if (f.isProtected() &amp;&amp; subClassOf(env, f.getClassDeclaration())) {</b>
<b class="nc"><i>740</i>&nbsp;            return true;</b>
<i>741</i>&nbsp;        }
<i>742</i>&nbsp;        // Private access is ok only from the same class nest
<b class="nc"><i>743</i>&nbsp;        if (f.isPrivate()) {</b>
<b class="nc"><i>744</i>&nbsp;            return getTopClass().getClassDeclaration()</b>
<b class="nc"><i>745</i>&nbsp;                .equals(f.getTopClass().getClassDeclaration());</b>
<i>746</i>&nbsp;        }
<i>747</i>&nbsp;        // It must be in the same package
<b class="nc"><i>748</i>&nbsp;        return getName().getQualifier().equals(f.getClassDeclaration().getName().getQualifier());</b>
<i>749</i>&nbsp;    }
<i>750</i>&nbsp;
<i>751</i>&nbsp;    /**
<i>752</i>&nbsp;     * Check if a class is entitled to inline access to a class from
<i>753</i>&nbsp;     * another class.
<i>754</i>&nbsp;     */
<i>755</i>&nbsp;    public boolean permitInlinedAccess(Environment env, ClassDeclaration c)
<i>756</i>&nbsp;                       throws ClassNotFound {
<i>757</i>&nbsp;
<b class="nc"><i>758</i>&nbsp;        return (env.opt() &amp;&amp; c.equals(declaration)) ||</b>
<b class="nc"><i>759</i>&nbsp;               (env.opt_interclass() &amp;&amp; canAccess(env, c));</b>
<i>760</i>&nbsp;    }
<i>761</i>&nbsp;
<i>762</i>&nbsp;    /**
<i>763</i>&nbsp;     * Check if a class is entitled to inline access to a method from
<i>764</i>&nbsp;     * another class.
<i>765</i>&nbsp;     */
<i>766</i>&nbsp;    public boolean permitInlinedAccess(Environment env, MemberDefinition f)
<i>767</i>&nbsp;                       throws ClassNotFound {
<b class="nc"><i>768</i>&nbsp;        return (env.opt()</b>
<b class="nc"><i>769</i>&nbsp;                    &amp;&amp; (f.clazz.getClassDeclaration().equals(declaration))) ||</b>
<b class="nc"><i>770</i>&nbsp;               (env.opt_interclass() &amp;&amp; canAccess(env, f));</b>
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /**
<i>774</i>&nbsp;     * We know the field is marked protected (and not public) and that
<i>775</i>&nbsp;     * the field is visible (as per canAccess).  Can we access the field as
<i>776</i>&nbsp;     * &lt;accessor&gt;.&lt;field&gt;, where &lt;accessor&gt; has the type &lt;accessorType&gt;?
<i>777</i>&nbsp;     *
<i>778</i>&nbsp;     * Protected fields can only be accessed when the accessorType is a
<i>779</i>&nbsp;     * subclass of the current class
<i>780</i>&nbsp;     */
<i>781</i>&nbsp;    public boolean protectedAccess(Environment env, MemberDefinition f,
<i>782</i>&nbsp;                                   Type accessorType)
<i>783</i>&nbsp;        throws ClassNotFound
<i>784</i>&nbsp;    {
<i>785</i>&nbsp;
<b class="nc"><i>786</i>&nbsp;        return</b>
<i>787</i>&nbsp;               // static protected fields are accessible
<b class="nc"><i>788</i>&nbsp;               f.isStatic()</b>
<i>789</i>&nbsp;            || // allow array.clone()
<b class="nc"><i>790</i>&nbsp;               (accessorType.isType(TC_ARRAY) &amp;&amp; (f.getName() == idClone)</b>
<b class="nc"><i>791</i>&nbsp;                 &amp;&amp; (f.getType().getArgumentTypes().length == 0))</b>
<i>792</i>&nbsp;            || // &lt;accessorType&gt; is a subtype of the current class
<b class="nc"><i>793</i>&nbsp;               (accessorType.isType(TC_CLASS)</b>
<b class="nc"><i>794</i>&nbsp;                 &amp;&amp; env.getClassDefinition(accessorType.getClassName())</b>
<b class="nc"><i>795</i>&nbsp;                         .subClassOf(env, getClassDeclaration()))</b>
<i>796</i>&nbsp;            || // we are accessing the field from a friendly class (same package)
<b class="nc"><i>797</i>&nbsp;               (getName().getQualifier()</b>
<b class="nc"><i>798</i>&nbsp;                   .equals(f.getClassDeclaration().getName().getQualifier()));</b>
<i>799</i>&nbsp;    }
<i>800</i>&nbsp;
<i>801</i>&nbsp;
<i>802</i>&nbsp;    /**
<i>803</i>&nbsp;     * Find or create an access method for a private member,
<i>804</i>&nbsp;     * or return null if this is not possible.
<i>805</i>&nbsp;     */
<i>806</i>&nbsp;    public MemberDefinition getAccessMember(Environment env, Context ctx,
<i>807</i>&nbsp;                                          MemberDefinition field, boolean isSuper) {
<b class="nc"><i>808</i>&nbsp;        throw new CompilerError(&quot;binary getAccessMember&quot;);</b>
<i>809</i>&nbsp;    }
<i>810</i>&nbsp;
<i>811</i>&nbsp;    /**
<i>812</i>&nbsp;     * Find or create an update method for a private member,
<i>813</i>&nbsp;     * or return null if this is not possible.
<i>814</i>&nbsp;     */
<i>815</i>&nbsp;    public MemberDefinition getUpdateMember(Environment env, Context ctx,
<i>816</i>&nbsp;                                            MemberDefinition field, boolean isSuper) {
<b class="nc"><i>817</i>&nbsp;        throw new CompilerError(&quot;binary getUpdateMember&quot;);</b>
<i>818</i>&nbsp;    }
<i>819</i>&nbsp;
<i>820</i>&nbsp;    /**
<i>821</i>&nbsp;     * Get a field from this class.  Report ambiguous fields.
<i>822</i>&nbsp;     * If no accessible field is found, this method may return an
<i>823</i>&nbsp;     * inaccessible field to allow a useful error message.
<i>824</i>&nbsp;     *
<i>825</i>&nbsp;     * getVariable now takes the source class `source&#39; as an argument.
<i>826</i>&nbsp;     * This allows getVariable to check whether a field is inaccessible
<i>827</i>&nbsp;     * before it signals that a field is ambiguous.  The compiler used to
<i>828</i>&nbsp;     * signal an ambiguity even when one of the fields involved was not
<i>829</i>&nbsp;     * accessible.  (bug 4053724)
<i>830</i>&nbsp;     */
<i>831</i>&nbsp;    public MemberDefinition getVariable(Environment env,
<i>832</i>&nbsp;                                        Identifier nm,
<i>833</i>&nbsp;                                        ClassDefinition source)
<i>834</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>835</i>&nbsp;
<b class="nc"><i>836</i>&nbsp;        return getVariable0(env, nm, source, true, true);</b>
<i>837</i>&nbsp;    }
<i>838</i>&nbsp;
<i>839</i>&nbsp;    /*
<i>840</i>&nbsp;     * private fields are never inherited.  package-private fields are
<i>841</i>&nbsp;     * not inherited across package boundaries.  To capture this, we
<i>842</i>&nbsp;     * take two booleans as parameters: showPrivate indicates whether
<i>843</i>&nbsp;     * we have passed a class boundary, and showPackage indicates whether
<i>844</i>&nbsp;     * we have crossed a package boundary.
<i>845</i>&nbsp;     */
<i>846</i>&nbsp;    private MemberDefinition getVariable0(Environment env,
<i>847</i>&nbsp;                                          Identifier nm,
<i>848</i>&nbsp;                                          ClassDefinition source,
<i>849</i>&nbsp;                                          boolean showPrivate,
<i>850</i>&nbsp;                                          boolean showPackage)
<i>851</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>852</i>&nbsp;
<i>853</i>&nbsp;        // Check to see if this field is defined in the current class
<b class="nc"><i>854</i>&nbsp;        for (MemberDefinition member = getFirstMatch(nm);</b>
<b class="nc"><i>855</i>&nbsp;             member != null;</b>
<b class="nc"><i>856</i>&nbsp;             member = member.getNextMatch()) {</b>
<b class="nc"><i>857</i>&nbsp;            if (member.isVariable()) {</b>
<b class="nc"><i>858</i>&nbsp;                if ((showPrivate || !member.isPrivate()) &amp;&amp;</b>
<b class="nc"><i>859</i>&nbsp;                    (showPackage || !member.isPackagePrivate())) {</b>
<i>860</i>&nbsp;                    // It is defined in this class.
<b class="nc"><i>861</i>&nbsp;                    return member;</b>
<i>862</i>&nbsp;                } else {
<i>863</i>&nbsp;                    // Even though this definition is not inherited,
<i>864</i>&nbsp;                    // it hides all definitions in supertypes.
<b class="nc"><i>865</i>&nbsp;                    return null;</b>
<i>866</i>&nbsp;                }
<i>867</i>&nbsp;            }
<i>868</i>&nbsp;        }
<i>869</i>&nbsp;
<i>870</i>&nbsp;        // Find the field in our superclass.
<b class="nc"><i>871</i>&nbsp;        ClassDeclaration sup = getSuperClass();</b>
<b class="nc"><i>872</i>&nbsp;        MemberDefinition field = null;</b>
<b class="nc"><i>873</i>&nbsp;        if (sup != null) {</b>
<b class="nc"><i>874</i>&nbsp;            field =</b>
<b class="nc"><i>875</i>&nbsp;                sup.getClassDefinition(env)</b>
<b class="nc"><i>876</i>&nbsp;                  .getVariable0(env, nm, source,</b>
<i>877</i>&nbsp;                                false,
<b class="nc"><i>878</i>&nbsp;                                showPackage &amp;&amp; inSamePackage(sup));</b>
<i>879</i>&nbsp;        }
<i>880</i>&nbsp;
<i>881</i>&nbsp;        // Find the field in our superinterfaces.
<b class="nc"><i>882</i>&nbsp;        for (int i = 0 ; i &lt; interfaces.length ; i++) {</b>
<i>883</i>&nbsp;            // Try to look up the field in an interface.  Since interfaces
<i>884</i>&nbsp;            // only have public fields, the values of the two boolean
<i>885</i>&nbsp;            // arguments are not important.
<b class="nc"><i>886</i>&nbsp;            MemberDefinition field2 =</b>
<b class="nc"><i>887</i>&nbsp;                interfaces[i].getClassDefinition(env)</b>
<b class="nc"><i>888</i>&nbsp;                  .getVariable0(env, nm, source, true, true);</b>
<i>889</i>&nbsp;
<b class="nc"><i>890</i>&nbsp;            if (field2 != null) {</b>
<i>891</i>&nbsp;                // If we have two different, accessible fields, then
<i>892</i>&nbsp;                // we&#39;ve found an ambiguity.
<b class="nc"><i>893</i>&nbsp;                if (field != null &amp;&amp;</b>
<b class="nc"><i>894</i>&nbsp;                    source.canAccess(env, field) &amp;&amp;</b>
<i>895</i>&nbsp;                    field2 != field) {
<i>896</i>&nbsp;
<b class="nc"><i>897</i>&nbsp;                    throw new AmbiguousMember(field2, field);</b>
<i>898</i>&nbsp;                }
<b class="nc"><i>899</i>&nbsp;                field = field2;</b>
<i>900</i>&nbsp;            }
<i>901</i>&nbsp;        }
<b class="nc"><i>902</i>&nbsp;        return field;</b>
<i>903</i>&nbsp;    }
<i>904</i>&nbsp;
<i>905</i>&nbsp;    /**
<i>906</i>&nbsp;     * Tells whether to report a deprecation error for this class.
<i>907</i>&nbsp;     */
<i>908</i>&nbsp;    public boolean reportDeprecated(Environment env) {
<b class="nc"><i>909</i>&nbsp;        return (isDeprecated()</b>
<b class="nc"><i>910</i>&nbsp;                || (outerClass != null &amp;&amp; outerClass.reportDeprecated(env)));</b>
<i>911</i>&nbsp;    }
<i>912</i>&nbsp;
<i>913</i>&nbsp;    /**
<i>914</i>&nbsp;     * Note that this class is being used somehow by {@code ref}.
<i>915</i>&nbsp;     * Report deprecation errors, etc.
<i>916</i>&nbsp;     */
<i>917</i>&nbsp;    public void noteUsedBy(ClassDefinition ref, long where, Environment env) {
<i>918</i>&nbsp;        // (Have this deal with canAccess() checks, too?)
<b class="nc"><i>919</i>&nbsp;        if (reportDeprecated(env)) {</b>
<b class="nc"><i>920</i>&nbsp;            env.error(where, &quot;warn.class.is.deprecated&quot;, this);</b>
<i>921</i>&nbsp;        }
<i>922</i>&nbsp;    }
<i>923</i>&nbsp;
<i>924</i>&nbsp;   /**
<i>925</i>&nbsp;     * Get an inner class.
<i>926</i>&nbsp;     * Look in supers but not outers.
<i>927</i>&nbsp;     * (This is used directly to resolve expressions like &quot;site.K&quot;, and
<i>928</i>&nbsp;     * inside a loop to resolve lone names like &quot;K&quot; or the &quot;K&quot; in &quot;K.L&quot;.)
<i>929</i>&nbsp;     *
<i>930</i>&nbsp;     * Called from &#39;Context&#39; and &#39;FieldExpression&#39; as well as this class.
<i>931</i>&nbsp;     *
<i>932</i>&nbsp;     * @see FieldExpression.checkCommon
<i>933</i>&nbsp;     * @see resolveName
<i>934</i>&nbsp;     */
<i>935</i>&nbsp;    public MemberDefinition getInnerClass(Environment env, Identifier nm)
<i>936</i>&nbsp;                                                        throws ClassNotFound {
<i>937</i>&nbsp;        // Note:  AmbiguousClass will not be thrown unless and until
<i>938</i>&nbsp;        // inner classes can be defined inside interfaces.
<i>939</i>&nbsp;
<i>940</i>&nbsp;        // Check if it is defined in the current class
<b class="nc"><i>941</i>&nbsp;        for (MemberDefinition field = getFirstMatch(nm);</b>
<b class="nc"><i>942</i>&nbsp;                field != null ; field = field.getNextMatch()) {</b>
<b class="nc"><i>943</i>&nbsp;            if (field.isInnerClass()) {</b>
<b class="nc"><i>944</i>&nbsp;                if (field.getInnerClass().isLocal()) {</b>
<b class="nc"><i>945</i>&nbsp;                    continue;   // ignore this name; it is internally generated</b>
<i>946</i>&nbsp;                }
<b class="nc"><i>947</i>&nbsp;                return field;</b>
<i>948</i>&nbsp;            }
<i>949</i>&nbsp;        }
<i>950</i>&nbsp;
<i>951</i>&nbsp;        // Get it from the super class
<i>952</i>&nbsp;        // It is likely that &#39;getSuperClass()&#39; could be made to work here
<i>953</i>&nbsp;        // but we would have to assure somehow that &#39;resolveTypeStructure&#39;
<i>954</i>&nbsp;        // has been called on the current class nest.  Since we can get
<i>955</i>&nbsp;        // here from &#39;resolveName&#39;, which is called from &#39;resolveSupers&#39;,
<i>956</i>&nbsp;        // it is possible that the first attempt to resolve the superclass
<i>957</i>&nbsp;        // will originate here, instead of in the call to &#39;getSuperClass&#39;
<i>958</i>&nbsp;        // in &#39;checkSupers&#39;.  See &#39;resolveTypeStructure&#39;, in which a call
<i>959</i>&nbsp;        // to &#39;resolveSupers&#39; precedes the call to &#39;checkSupers&#39;.  Why is
<i>960</i>&nbsp;        // name resolution done twice, first in &#39;resolveName&#39;?
<i>961</i>&nbsp;        // NOTE: &#39;SourceMember.resolveTypeStructure&#39; may initiate type
<i>962</i>&nbsp;        // structure resolution for an inner class.  Normally, this
<i>963</i>&nbsp;        // occurs during the resolution of the outer class, but fields
<i>964</i>&nbsp;        // added after the resolution of their containing class will
<i>965</i>&nbsp;        // be resolved late -- see &#39;addMember(env,field)&#39; below.
<i>966</i>&nbsp;        // This should only happen for synthetic members, which should
<i>967</i>&nbsp;        // never be an inner class.
<b class="nc"><i>968</i>&nbsp;        ClassDeclaration sup = getSuperClass(env);</b>
<b class="nc"><i>969</i>&nbsp;        if (sup != null)</b>
<b class="nc"><i>970</i>&nbsp;            return sup.getClassDefinition(env).getInnerClass(env, nm);</b>
<i>971</i>&nbsp;
<b class="nc"><i>972</i>&nbsp;        return null;</b>
<i>973</i>&nbsp;    }
<i>974</i>&nbsp;
<i>975</i>&nbsp;    /**
<i>976</i>&nbsp;     * Lookup a method.  This code implements the method lookup
<i>977</i>&nbsp;     * mechanism specified in JLS 15.11.2.
<i>978</i>&nbsp;     *
<i>979</i>&nbsp;     * This mechanism cannot be used to lookup synthetic methods.
<i>980</i>&nbsp;     */
<i>981</i>&nbsp;    private MemberDefinition matchMethod(Environment env,
<i>982</i>&nbsp;                                         ClassDefinition accessor,
<i>983</i>&nbsp;                                         Identifier methodName,
<i>984</i>&nbsp;                                         Type[] argumentTypes,
<i>985</i>&nbsp;                                         boolean isAnonConstCall,
<i>986</i>&nbsp;                                         Identifier accessPackage)
<i>987</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>988</i>&nbsp;
<b class="nc"><i>989</i>&nbsp;        if (allMethods == null || !allMethods.isFrozen()) {</b>
<i>990</i>&nbsp;            // This may be too restrictive.
<b class="nc"><i>991</i>&nbsp;            throw new CompilerError(&quot;matchMethod called early&quot;);</b>
<i>992</i>&nbsp;            // collectInheritedMethods(env);
<i>993</i>&nbsp;        }
<i>994</i>&nbsp;
<i>995</i>&nbsp;        // A tentative maximally specific method.
<b class="nc"><i>996</i>&nbsp;        MemberDefinition tentative = null;</b>
<i>997</i>&nbsp;
<i>998</i>&nbsp;        // A list of other methods which may be maximally specific too.
<b class="nc"><i>999</i>&nbsp;        List&lt;MemberDefinition&gt; candidateList = null;</b>
<i>1000</i>&nbsp;
<i>1001</i>&nbsp;        // Get all the methods inherited by this class which
<i>1002</i>&nbsp;        // have the name `methodName&#39;.
<b class="nc"><i>1003</i>&nbsp;        Iterator&lt;MemberDefinition&gt; methods = allMethods.lookupName(methodName);</b>
<i>1004</i>&nbsp;
<b class="nc"><i>1005</i>&nbsp;        while (methods.hasNext()) {</b>
<b class="nc"><i>1006</i>&nbsp;            MemberDefinition method = methods.next();</b>
<i>1007</i>&nbsp;
<i>1008</i>&nbsp;            // See if this method is applicable.
<b class="nc"><i>1009</i>&nbsp;            if (!env.isApplicable(method, argumentTypes)) {</b>
<b class="nc"><i>1010</i>&nbsp;                continue;</b>
<i>1011</i>&nbsp;            }
<i>1012</i>&nbsp;
<i>1013</i>&nbsp;            // See if this method is accessible.
<b class="nc"><i>1014</i>&nbsp;            if (accessor != null) {</b>
<b class="nc"><i>1015</i>&nbsp;                if (!accessor.canAccess(env, method)) {</b>
<b class="nc"><i>1016</i>&nbsp;                    continue;</b>
<i>1017</i>&nbsp;                }
<b class="nc"><i>1018</i>&nbsp;            } else if (isAnonConstCall) {</b>
<b class="nc"><i>1019</i>&nbsp;                if (method.isPrivate() ||</b>
<b class="nc"><i>1020</i>&nbsp;                    (method.isPackagePrivate() &amp;&amp;</b>
<i>1021</i>&nbsp;                     accessPackage != null &amp;&amp;
<b class="nc"><i>1022</i>&nbsp;                     !inSamePackage(accessPackage))) {</b>
<i>1023</i>&nbsp;                    // For anonymous constructor accesses, we
<i>1024</i>&nbsp;                    // haven&#39;t yet built an accessing class.
<i>1025</i>&nbsp;                    // We disallow anonymous classes from seeing
<i>1026</i>&nbsp;                    // private/package-private inaccessible
<i>1027</i>&nbsp;                    // constructors in their superclass.
<b class="nc"><i>1028</i>&nbsp;                    continue;</b>
<i>1029</i>&nbsp;                }
<i>1030</i>&nbsp;            } else {
<i>1031</i>&nbsp;                // If accessor is null, we assume that the access
<i>1032</i>&nbsp;                // is allowed.  Query: is this option used?
<i>1033</i>&nbsp;            }
<i>1034</i>&nbsp;
<b class="nc"><i>1035</i>&nbsp;            if (tentative == null) {</b>
<i>1036</i>&nbsp;                // `method&#39; becomes our tentative maximally specific match.
<b class="nc"><i>1037</i>&nbsp;                tentative = method;</b>
<i>1038</i>&nbsp;            } else {
<b class="nc"><i>1039</i>&nbsp;                if (env.isMoreSpecific(method, tentative)) {</b>
<i>1040</i>&nbsp;                    // We have found a method which is a strictly better
<i>1041</i>&nbsp;                    // match than `tentative&#39;.  Replace it.
<b class="nc"><i>1042</i>&nbsp;                    tentative = method;</b>
<i>1043</i>&nbsp;                } else {
<i>1044</i>&nbsp;                    // If this method could possibly be another
<i>1045</i>&nbsp;                    // maximally specific method, add it to our
<i>1046</i>&nbsp;                    // list of other candidates.
<b class="nc"><i>1047</i>&nbsp;                    if (!env.isMoreSpecific(tentative,method)) {</b>
<b class="nc"><i>1048</i>&nbsp;                        if (candidateList == null) {</b>
<b class="nc"><i>1049</i>&nbsp;                            candidateList = new ArrayList&lt;&gt;();</b>
<i>1050</i>&nbsp;                        }
<b class="nc"><i>1051</i>&nbsp;                        candidateList.add(method);</b>
<i>1052</i>&nbsp;                    }
<i>1053</i>&nbsp;                }
<i>1054</i>&nbsp;            }
<b class="nc"><i>1055</i>&nbsp;        }</b>
<i>1056</i>&nbsp;
<b class="nc"><i>1057</i>&nbsp;        if (tentative != null &amp;&amp; candidateList != null) {</b>
<i>1058</i>&nbsp;            // Find out if our `tentative&#39; match is a uniquely
<i>1059</i>&nbsp;            // maximally specific.
<b class="nc"><i>1060</i>&nbsp;            Iterator&lt;MemberDefinition&gt; candidates = candidateList.iterator();</b>
<b class="nc"><i>1061</i>&nbsp;            while (candidates.hasNext()) {</b>
<b class="nc"><i>1062</i>&nbsp;                MemberDefinition method = candidates.next();</b>
<b class="nc"><i>1063</i>&nbsp;                if (!env.isMoreSpecific(tentative, method)) {</b>
<b class="nc"><i>1064</i>&nbsp;                    throw new AmbiguousMember(tentative, method);</b>
<i>1065</i>&nbsp;                }
<b class="nc"><i>1066</i>&nbsp;            }</b>
<i>1067</i>&nbsp;        }
<i>1068</i>&nbsp;
<b class="nc"><i>1069</i>&nbsp;        return tentative;</b>
<i>1070</i>&nbsp;    }
<i>1071</i>&nbsp;
<i>1072</i>&nbsp;    /**
<i>1073</i>&nbsp;     * Lookup a method.  This code implements the method lookup
<i>1074</i>&nbsp;     * mechanism specified in JLS 15.11.2.
<i>1075</i>&nbsp;     *
<i>1076</i>&nbsp;     * This mechanism cannot be used to lookup synthetic methods.
<i>1077</i>&nbsp;     */
<i>1078</i>&nbsp;    public MemberDefinition matchMethod(Environment env,
<i>1079</i>&nbsp;                                        ClassDefinition accessor,
<i>1080</i>&nbsp;                                        Identifier methodName,
<i>1081</i>&nbsp;                                        Type[] argumentTypes)
<i>1082</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>1083</i>&nbsp;
<b class="nc"><i>1084</i>&nbsp;        return matchMethod(env, accessor, methodName,</b>
<i>1085</i>&nbsp;                           argumentTypes, false, null);
<i>1086</i>&nbsp;    }
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;    /**
<i>1089</i>&nbsp;     * Lookup a method.  This code implements the method lookup
<i>1090</i>&nbsp;     * mechanism specified in JLS 15.11.2.
<i>1091</i>&nbsp;     *
<i>1092</i>&nbsp;     * This mechanism cannot be used to lookup synthetic methods.
<i>1093</i>&nbsp;     */
<i>1094</i>&nbsp;    public MemberDefinition matchMethod(Environment env,
<i>1095</i>&nbsp;                                        ClassDefinition accessor,
<i>1096</i>&nbsp;                                        Identifier methodName)
<i>1097</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>1098</i>&nbsp;
<b class="nc"><i>1099</i>&nbsp;        return matchMethod(env, accessor, methodName,</b>
<i>1100</i>&nbsp;                           Type.noArgs, false, null);
<i>1101</i>&nbsp;    }
<i>1102</i>&nbsp;
<i>1103</i>&nbsp;    /**
<i>1104</i>&nbsp;     * A version of matchMethod to be used only for constructors
<i>1105</i>&nbsp;     * when we cannot pass in a sourceClass argument.  We just assert
<i>1106</i>&nbsp;     * our package name.
<i>1107</i>&nbsp;     *
<i>1108</i>&nbsp;     * This is used only for anonymous classes, where we have to look up
<i>1109</i>&nbsp;     * a (potentially) protected constructor with no valid sourceClass
<i>1110</i>&nbsp;     * parameter available.
<i>1111</i>&nbsp;     */
<i>1112</i>&nbsp;    public MemberDefinition matchAnonConstructor(Environment env,
<i>1113</i>&nbsp;                                                 Identifier accessPackage,
<i>1114</i>&nbsp;                                                 Type argumentTypes[])
<i>1115</i>&nbsp;        throws AmbiguousMember, ClassNotFound {
<i>1116</i>&nbsp;
<b class="nc"><i>1117</i>&nbsp;        return matchMethod(env, null, idInit, argumentTypes,</b>
<i>1118</i>&nbsp;                           true, accessPackage);
<i>1119</i>&nbsp;    }
<i>1120</i>&nbsp;
<i>1121</i>&nbsp;    /**
<i>1122</i>&nbsp;     * Find a method, ie: exact match in this class or any of the super
<i>1123</i>&nbsp;     * classes.
<i>1124</i>&nbsp;     *
<i>1125</i>&nbsp;     * Only called by javadoc.  For now I am holding off rewriting this
<i>1126</i>&nbsp;     * code to rely on collectInheritedMethods(), as that code has
<i>1127</i>&nbsp;     * not gotten along with javadoc in the past.
<i>1128</i>&nbsp;     */
<i>1129</i>&nbsp;    public MemberDefinition findMethod(Environment env, Identifier nm, Type t)
<i>1130</i>&nbsp;    throws ClassNotFound {
<i>1131</i>&nbsp;        // look in the current class
<i>1132</i>&nbsp;        MemberDefinition f;
<b class="nc"><i>1133</i>&nbsp;        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</b>
<i>1134</i>&nbsp;            // Note that non-method types return false for equalArguments().
<b class="nc"><i>1135</i>&nbsp;            if (f.getType().equalArguments(t)) {</b>
<b class="nc"><i>1136</i>&nbsp;                return f;</b>
<i>1137</i>&nbsp;            }
<i>1138</i>&nbsp;        }
<i>1139</i>&nbsp;
<i>1140</i>&nbsp;        // constructors are not inherited
<b class="nc"><i>1141</i>&nbsp;        if (nm.equals(idInit)) {</b>
<b class="nc"><i>1142</i>&nbsp;            return null;</b>
<i>1143</i>&nbsp;        }
<i>1144</i>&nbsp;
<i>1145</i>&nbsp;        // look in the super class
<b class="nc"><i>1146</i>&nbsp;        ClassDeclaration sup = getSuperClass();</b>
<b class="nc"><i>1147</i>&nbsp;        if (sup == null)</b>
<b class="nc"><i>1148</i>&nbsp;            return null;</b>
<i>1149</i>&nbsp;
<b class="nc"><i>1150</i>&nbsp;        return sup.getClassDefinition(env).findMethod(env, nm, t);</b>
<i>1151</i>&nbsp;    }
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;    // We create a stub for this.  Source classes do more work.
<i>1154</i>&nbsp;    protected void basicCheck(Environment env) throws ClassNotFound {
<i>1155</i>&nbsp;        // Do the outer class first.
<b class="nc"><i>1156</i>&nbsp;        if (outerClass != null)</b>
<b class="nc"><i>1157</i>&nbsp;            outerClass.basicCheck(env);</b>
<i>1158</i>&nbsp;    }
<i>1159</i>&nbsp;
<i>1160</i>&nbsp;    /**
<i>1161</i>&nbsp;     * Check this class.
<i>1162</i>&nbsp;     */
<i>1163</i>&nbsp;    public void check(Environment env) throws ClassNotFound {
<i>1164</i>&nbsp;    }
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;    public Vset checkLocalClass(Environment env, Context ctx,
<i>1167</i>&nbsp;                                Vset vset, ClassDefinition sup,
<i>1168</i>&nbsp;                                Expression args[], Type argTypes[]
<i>1169</i>&nbsp;                                ) throws ClassNotFound {
<b class="nc"><i>1170</i>&nbsp;        throw new CompilerError(&quot;checkLocalClass&quot;);</b>
<i>1171</i>&nbsp;    }
<i>1172</i>&nbsp;
<i>1173</i>&nbsp;    //---------------------------------------------------------------
<i>1174</i>&nbsp;    // The non-synthetic methods defined in this class or in any
<i>1175</i>&nbsp;    // of its parents (class or interface).  This member is used
<i>1176</i>&nbsp;    // to cache work done in collectInheritedMethods for use by
<i>1177</i>&nbsp;    // getMethods() and matchMethod().  It should be accessed by
<i>1178</i>&nbsp;    // no other method without forethought.
<b class="nc"><i>1179</i>&nbsp;    MethodSet allMethods = null;</b>
<i>1180</i>&nbsp;
<i>1181</i>&nbsp;    // One of our superclasses may contain an abstract method which
<i>1182</i>&nbsp;    // we are unable to ever implement.  This happens when there is
<i>1183</i>&nbsp;    // a package-private abstract method in our parent and we are in
<i>1184</i>&nbsp;    // a different package than our parent.  In these cases, we
<i>1185</i>&nbsp;    // keep a list of the &quot;permanently abstract&quot; or &quot;unimplementable&quot;
<i>1186</i>&nbsp;    // methods so that we can correctly detect that this class is
<i>1187</i>&nbsp;    // indeed abstract and so that we can give somewhat comprehensible
<i>1188</i>&nbsp;    // error messages.
<b class="nc"><i>1189</i>&nbsp;    private List&lt;MemberDefinition&gt; permanentlyAbstractMethods = new ArrayList&lt;&gt;();</b>
<i>1190</i>&nbsp;
<i>1191</i>&nbsp;    /**
<i>1192</i>&nbsp;     * This method returns an Iterator of all abstract methods
<i>1193</i>&nbsp;     * in our superclasses which we are unable to implement.
<i>1194</i>&nbsp;     */
<i>1195</i>&nbsp;    protected Iterator&lt;MemberDefinition&gt; getPermanentlyAbstractMethods() {
<i>1196</i>&nbsp;        // This method can only be called after collectInheritedMethods.
<b class="nc"><i>1197</i>&nbsp;        if (allMethods == null) {</b>
<b class="nc"><i>1198</i>&nbsp;            throw new CompilerError(&quot;isPermanentlyAbstract() called early&quot;);</b>
<i>1199</i>&nbsp;        }
<i>1200</i>&nbsp;
<b class="nc"><i>1201</i>&nbsp;        return permanentlyAbstractMethods.iterator();</b>
<i>1202</i>&nbsp;    }
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;    /**
<i>1205</i>&nbsp;     * A flag used by turnOffInheritanceChecks() to indicate if
<i>1206</i>&nbsp;     * inheritance checks are on or off.
<i>1207</i>&nbsp;     */
<b class="nc"><i>1208</i>&nbsp;    protected static boolean doInheritanceChecks = true;</b>
<i>1209</i>&nbsp;
<i>1210</i>&nbsp;    /**
<i>1211</i>&nbsp;     * This is a workaround to allow javadoc to turn off certain
<i>1212</i>&nbsp;     * inheritance/override checks which interfere with javadoc
<i>1213</i>&nbsp;     * badly.  In the future it might be good to eliminate the
<i>1214</i>&nbsp;     * shared sources of javadoc and javac to avoid the need for this
<i>1215</i>&nbsp;     * sort of workaround.
<i>1216</i>&nbsp;     */
<i>1217</i>&nbsp;    public static void turnOffInheritanceChecks() {
<b class="nc"><i>1218</i>&nbsp;        doInheritanceChecks = false;</b>
<i>1219</i>&nbsp;    }
<i>1220</i>&nbsp;
<i>1221</i>&nbsp;    /**
<i>1222</i>&nbsp;     * Add all of the methods declared in or above `parent&#39; to
<i>1223</i>&nbsp;     * `allMethods&#39;, the set of methods in the current class.
<i>1224</i>&nbsp;     * `myMethods&#39; is the set of all methods declared in this
<i>1225</i>&nbsp;     * class, and `mirandaMethods&#39; is a repository for Miranda methods.
<i>1226</i>&nbsp;     * If mirandaMethods is null, no mirandaMethods will be
<i>1227</i>&nbsp;     * generated.
<i>1228</i>&nbsp;     *
<i>1229</i>&nbsp;     * For a definition of Miranda methods, see the comment above the
<i>1230</i>&nbsp;     * method addMirandaMethods() which occurs later in this file.
<i>1231</i>&nbsp;     */
<i>1232</i>&nbsp;    private void collectOneClass(Environment env,
<i>1233</i>&nbsp;                                 ClassDeclaration parent,
<i>1234</i>&nbsp;                                 MethodSet myMethods,
<i>1235</i>&nbsp;                                 MethodSet allMethods,
<i>1236</i>&nbsp;                                 MethodSet mirandaMethods) {
<i>1237</i>&nbsp;
<i>1238</i>&nbsp;        // System.out.println(&quot;Inheriting methods from &quot; + parent);
<i>1239</i>&nbsp;
<i>1240</i>&nbsp;        try {
<b class="nc"><i>1241</i>&nbsp;            ClassDefinition pClass = parent.getClassDefinition(env);</b>
<b class="nc"><i>1242</i>&nbsp;            Iterator&lt;MemberDefinition&gt; methods = pClass.getMethods(env);</b>
<b class="nc"><i>1243</i>&nbsp;            while (methods.hasNext()) {</b>
<b class="nc"><i>1244</i>&nbsp;                MemberDefinition method =</b>
<b class="nc"><i>1245</i>&nbsp;                    methods.next();</b>
<i>1246</i>&nbsp;
<i>1247</i>&nbsp;                // Private methods are not inherited.
<i>1248</i>&nbsp;                //
<i>1249</i>&nbsp;                // Constructors are not inherited.
<i>1250</i>&nbsp;                //
<i>1251</i>&nbsp;                // Any non-abstract methods in an interface come
<i>1252</i>&nbsp;                // from java.lang.Object.  This means that they
<i>1253</i>&nbsp;                // should have already been added to allMethods
<i>1254</i>&nbsp;                // when we walked our superclass lineage.
<b class="nc"><i>1255</i>&nbsp;                if (method.isPrivate() ||</b>
<b class="nc"><i>1256</i>&nbsp;                    method.isConstructor() ||</b>
<b class="nc"><i>1257</i>&nbsp;                    (pClass.isInterface() &amp;&amp; !method.isAbstract())) {</b>
<i>1258</i>&nbsp;
<b class="nc"><i>1259</i>&nbsp;                    continue;</b>
<i>1260</i>&nbsp;                }
<i>1261</i>&nbsp;
<i>1262</i>&nbsp;                // Get the components of the methods&#39; signature.
<b class="nc"><i>1263</i>&nbsp;                Identifier name = method.getName();</b>
<b class="nc"><i>1264</i>&nbsp;                Type type = method.getType();</b>
<i>1265</i>&nbsp;
<i>1266</i>&nbsp;                // Check for a method of the same signature which
<i>1267</i>&nbsp;                // was locally declared.
<b class="nc"><i>1268</i>&nbsp;                MemberDefinition override =</b>
<b class="nc"><i>1269</i>&nbsp;                    myMethods.lookupSig(name, type);</b>
<i>1270</i>&nbsp;
<i>1271</i>&nbsp;                // Is this method inaccessible due to package-private
<i>1272</i>&nbsp;                // visibility?
<b class="nc"><i>1273</i>&nbsp;                if (method.isPackagePrivate() &amp;&amp;</b>
<b class="nc"><i>1274</i>&nbsp;                    !inSamePackage(method.getClassDeclaration())) {</b>
<i>1275</i>&nbsp;
<b class="nc"><i>1276</i>&nbsp;                    if (override != null &amp;&amp; this instanceof</b>
<i>1277</i>&nbsp;                        sun.tools.javac.SourceClass) {
<i>1278</i>&nbsp;                        // We give a warning when a class shadows an
<i>1279</i>&nbsp;                        // inaccessible package-private method from
<i>1280</i>&nbsp;                        // its superclass.  This warning is meant
<i>1281</i>&nbsp;                        // to prevent people from relying on overriding
<i>1282</i>&nbsp;                        // when it does not happen.  This warning should
<i>1283</i>&nbsp;                        // probably be removed to be consistent with the
<i>1284</i>&nbsp;                        // general &quot;no warnings&quot; policy of this
<i>1285</i>&nbsp;                        // compiler.
<i>1286</i>&nbsp;                        //
<i>1287</i>&nbsp;                        // The `instanceof&#39; above is a hack so that only
<i>1288</i>&nbsp;                        // SourceClass generates this warning, not a
<i>1289</i>&nbsp;                        // BinaryClass, for example.
<b class="nc"><i>1290</i>&nbsp;                        env.error(method.getWhere(),</b>
<i>1291</i>&nbsp;                                  &quot;warn.no.override.access&quot;,
<i>1292</i>&nbsp;                                  override,
<b class="nc"><i>1293</i>&nbsp;                                  override.getClassDeclaration(),</b>
<b class="nc"><i>1294</i>&nbsp;                                  method.getClassDeclaration());</b>
<i>1295</i>&nbsp;                    }
<i>1296</i>&nbsp;
<i>1297</i>&nbsp;                    // If our superclass has a package-private abstract
<i>1298</i>&nbsp;                    // method that we have no access to, then we add
<i>1299</i>&nbsp;                    // this method to our list of permanently abstract
<i>1300</i>&nbsp;                    // methods.  The idea is, since we cannot override
<i>1301</i>&nbsp;                    // the method, we can never make this class
<i>1302</i>&nbsp;                    // non-abstract.
<b class="nc"><i>1303</i>&nbsp;                    if (method.isAbstract()) {</b>
<b class="nc"><i>1304</i>&nbsp;                        permanentlyAbstractMethods.add(method);</b>
<i>1305</i>&nbsp;                    }
<i>1306</i>&nbsp;
<i>1307</i>&nbsp;                    // `method&#39; is inaccessible.  We do not inherit it.
<i>1308</i>&nbsp;                    continue;
<i>1309</i>&nbsp;                }
<i>1310</i>&nbsp;
<b class="nc"><i>1311</i>&nbsp;                if (override != null) {</b>
<i>1312</i>&nbsp;                    // `method&#39; and `override&#39; have the same signature.
<i>1313</i>&nbsp;                    // We are required to check that `override&#39; is a
<i>1314</i>&nbsp;                    // legal override of `method&#39;
<i>1315</i>&nbsp;
<i>1316</i>&nbsp;                    //System.out.println (&quot;About to check override of &quot; +
<i>1317</i>&nbsp;                    //              method);
<i>1318</i>&nbsp;
<b class="nc"><i>1319</i>&nbsp;                    override.checkOverride(env, method);</b>
<i>1320</i>&nbsp;                } else {
<i>1321</i>&nbsp;                    // In the absence of a definition in the class
<i>1322</i>&nbsp;                    // itself, we check to see if this definition
<i>1323</i>&nbsp;                    // can be successfully merged with any other
<i>1324</i>&nbsp;                    // inherited definitions.
<i>1325</i>&nbsp;
<i>1326</i>&nbsp;                    // Have we added a member of the same signature
<i>1327</i>&nbsp;                    // to `allMethods&#39; already?
<b class="nc"><i>1328</i>&nbsp;                    MemberDefinition formerMethod =</b>
<b class="nc"><i>1329</i>&nbsp;                        allMethods.lookupSig(name, type);</b>
<i>1330</i>&nbsp;
<i>1331</i>&nbsp;                    // If the previous definition is nonexistent or
<i>1332</i>&nbsp;                    // ignorable, replace it.
<b class="nc"><i>1333</i>&nbsp;                    if (formerMethod == null) {</b>
<i>1334</i>&nbsp;                        //System.out.println(&quot;Added &quot; + method + &quot; to &quot; +
<i>1335</i>&nbsp;                        //             this);
<i>1336</i>&nbsp;
<b class="nc"><i>1337</i>&nbsp;                        if (mirandaMethods != null &amp;&amp;</b>
<b class="nc"><i>1338</i>&nbsp;                            pClass.isInterface() &amp;&amp; !isInterface()) {</b>
<i>1339</i>&nbsp;                            // Whenever a class inherits a method
<i>1340</i>&nbsp;                            // from an interface, that method is
<i>1341</i>&nbsp;                            // one of our &quot;miranda&quot; methods.  Early
<i>1342</i>&nbsp;                            // VMs require that these methods be
<i>1343</i>&nbsp;                            // added as true members to the class
<i>1344</i>&nbsp;                            // to enable method lookup to work in the
<i>1345</i>&nbsp;                            // VM.
<b class="nc"><i>1346</i>&nbsp;                            method =</b>
<i>1347</i>&nbsp;                                new sun.tools.javac.SourceMember(method,this,
<i>1348</i>&nbsp;                                                                 env);
<b class="nc"><i>1349</i>&nbsp;                            mirandaMethods.add(method);</b>
<i>1350</i>&nbsp;
<i>1351</i>&nbsp;                            //System.out.println(&quot;Added &quot; + method +
<i>1352</i>&nbsp;                            // &quot; to &quot; + this + &quot; as a Miranda&quot;);
<i>1353</i>&nbsp;                        }
<i>1354</i>&nbsp;
<i>1355</i>&nbsp;                        // There is no previous inherited definition.
<i>1356</i>&nbsp;                        // Add `method&#39; to `allMethods&#39;.
<b class="nc"><i>1357</i>&nbsp;                        allMethods.add(method);</b>
<b class="nc"><i>1358</i>&nbsp;                    } else if (isInterface() &amp;&amp;</b>
<b class="nc"><i>1359</i>&nbsp;                               !formerMethod.isAbstract() &amp;&amp;</b>
<b class="nc"><i>1360</i>&nbsp;                               method.isAbstract()) {</b>
<i>1361</i>&nbsp;                        // If we are in an interface and we have inherited
<i>1362</i>&nbsp;                        // both an abstract method and a non-abstract method
<i>1363</i>&nbsp;                        // then we know that the non-abstract method is
<i>1364</i>&nbsp;                        // a placeholder from Object put in for type checking
<i>1365</i>&nbsp;                        // and the abstract method was already checked to
<i>1366</i>&nbsp;                        // be proper by our superinterface.
<b class="nc"><i>1367</i>&nbsp;                        allMethods.replace(method);</b>
<i>1368</i>&nbsp;
<i>1369</i>&nbsp;                    } else {
<i>1370</i>&nbsp;                        // Okay, `formerMethod&#39; and `method&#39; both have the
<i>1371</i>&nbsp;                        // same signature.  See if they are compatible.
<i>1372</i>&nbsp;
<i>1373</i>&nbsp;                        //System.out.println (&quot;About to check meet of &quot; +
<i>1374</i>&nbsp;                        //              method);
<i>1375</i>&nbsp;
<b class="nc"><i>1376</i>&nbsp;                        if (!formerMethod.checkMeet(env,</b>
<i>1377</i>&nbsp;                                           method,
<b class="nc"><i>1378</i>&nbsp;                                           this.getClassDeclaration())) {</b>
<i>1379</i>&nbsp;                                // The methods are incompatible.  Skip to
<i>1380</i>&nbsp;                                // next method.
<b class="nc"><i>1381</i>&nbsp;                            continue;</b>
<i>1382</i>&nbsp;                        }
<i>1383</i>&nbsp;
<b class="nc"><i>1384</i>&nbsp;                        if (formerMethod.couldOverride(env, method)) {</b>
<i>1385</i>&nbsp;                                // Do nothing.  The current definition
<i>1386</i>&nbsp;                                // is specific enough.
<i>1387</i>&nbsp;
<i>1388</i>&nbsp;                                //System.out.println(&quot;trivial meet of &quot; +
<i>1389</i>&nbsp;                                //                 method);
<b class="nc"><i>1390</i>&nbsp;                            continue;</b>
<i>1391</i>&nbsp;                        }
<i>1392</i>&nbsp;
<b class="nc"><i>1393</i>&nbsp;                        if (method.couldOverride(env, formerMethod)) {</b>
<i>1394</i>&nbsp;                                // `method&#39; is more specific than
<i>1395</i>&nbsp;                                // `formerMethod&#39;.  replace `formerMethod&#39;.
<i>1396</i>&nbsp;
<i>1397</i>&nbsp;                                //System.out.println(&quot;new def of &quot; + method);
<b class="nc"><i>1398</i>&nbsp;                            if (mirandaMethods != null &amp;&amp;</b>
<b class="nc"><i>1399</i>&nbsp;                                pClass.isInterface() &amp;&amp; !isInterface()) {</b>
<i>1400</i>&nbsp;                                // Whenever a class inherits a method
<i>1401</i>&nbsp;                                // from an interface, that method is
<i>1402</i>&nbsp;                                // one of our &quot;miranda&quot; methods.  Early
<i>1403</i>&nbsp;                                // VMs require that these methods be
<i>1404</i>&nbsp;                                // added as true members to the class
<i>1405</i>&nbsp;                                // to enable method lookup to work in the
<i>1406</i>&nbsp;                                // VM.
<b class="nc"><i>1407</i>&nbsp;                                method =</b>
<i>1408</i>&nbsp;                                    new sun.tools.javac.SourceMember(method,
<i>1409</i>&nbsp;                                                                     this,env);
<i>1410</i>&nbsp;
<b class="nc"><i>1411</i>&nbsp;                                mirandaMethods.replace(method);</b>
<i>1412</i>&nbsp;
<i>1413</i>&nbsp;                                //System.out.println(&quot;Added &quot; + method +
<i>1414</i>&nbsp;                                // &quot; to &quot; + this + &quot; as a Miranda&quot;);
<i>1415</i>&nbsp;                            }
<i>1416</i>&nbsp;
<b class="nc"><i>1417</i>&nbsp;                            allMethods.replace(method);</b>
<i>1418</i>&nbsp;
<b class="nc"><i>1419</i>&nbsp;                            continue;</b>
<i>1420</i>&nbsp;                        }
<i>1421</i>&nbsp;
<i>1422</i>&nbsp;                        // Neither method is more specific than the other.
<i>1423</i>&nbsp;                        // Oh well.  We need to construct a nontrivial
<i>1424</i>&nbsp;                        // meet of the two methods.
<i>1425</i>&nbsp;                        //
<i>1426</i>&nbsp;                        // This is not yet implemented, so we give
<i>1427</i>&nbsp;                        // a message with a helpful workaround.
<b class="nc"><i>1428</i>&nbsp;                        env.error(this.where,</b>
<i>1429</i>&nbsp;                                  &quot;nontrivial.meet&quot;, method,
<b class="nc"><i>1430</i>&nbsp;                                  formerMethod.getClassDefinition(),</b>
<b class="nc"><i>1431</i>&nbsp;                                  method.getClassDeclaration()</b>
<i>1432</i>&nbsp;                                  );
<i>1433</i>&nbsp;                    }
<i>1434</i>&nbsp;                }
<b class="nc"><i>1435</i>&nbsp;            }</b>
<b class="nc"><i>1436</i>&nbsp;        } catch (ClassNotFound ee) {</b>
<b class="nc"><i>1437</i>&nbsp;            env.error(getWhere(), &quot;class.not.found&quot;, ee.name, this);</b>
<b class="nc"><i>1438</i>&nbsp;        }</b>
<i>1439</i>&nbsp;    }
<i>1440</i>&nbsp;
<i>1441</i>&nbsp;    /**
<i>1442</i>&nbsp;     * &lt;p&gt;Collect all methods defined in this class or inherited from
<i>1443</i>&nbsp;     * any of our superclasses or interfaces.  Look for any
<i>1444</i>&nbsp;     * incompatible definitions.
<i>1445</i>&nbsp;     *
<i>1446</i>&nbsp;     * &lt;p&gt;This function is also responsible for collecting the
<i>1447</i>&nbsp;     * &lt;em&gt;Miranda&lt;/em&gt; methods for a class.  For a definition of
<i>1448</i>&nbsp;     * Miranda methods, see the comment in addMirandaMethods()
<i>1449</i>&nbsp;     * below.
<i>1450</i>&nbsp;     */
<i>1451</i>&nbsp;    protected void collectInheritedMethods(Environment env) {
<i>1452</i>&nbsp;        // The methods defined in this class.
<i>1453</i>&nbsp;        MethodSet myMethods;
<i>1454</i>&nbsp;        MethodSet mirandaMethods;
<i>1455</i>&nbsp;
<i>1456</i>&nbsp;        //System.out.println(&quot;Called collectInheritedMethods() for &quot; +
<i>1457</i>&nbsp;        //                 this);
<i>1458</i>&nbsp;
<b class="nc"><i>1459</i>&nbsp;        if (allMethods != null) {</b>
<b class="nc"><i>1460</i>&nbsp;            if (allMethods.isFrozen()) {</b>
<i>1461</i>&nbsp;                // We have already done the collection.  No need to
<i>1462</i>&nbsp;                // do it again.
<i>1463</i>&nbsp;                return;
<i>1464</i>&nbsp;            } else {
<i>1465</i>&nbsp;                // We have run into a circular need to collect our methods.
<i>1466</i>&nbsp;                // This should not happen at this stage.
<b class="nc"><i>1467</i>&nbsp;                throw new CompilerError(&quot;collectInheritedMethods()&quot;);</b>
<i>1468</i>&nbsp;            }
<i>1469</i>&nbsp;        }
<i>1470</i>&nbsp;
<b class="nc"><i>1471</i>&nbsp;        myMethods = new MethodSet();</b>
<b class="nc"><i>1472</i>&nbsp;        allMethods = new MethodSet();</b>
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;        // For testing, do not generate miranda methods.
<b class="nc"><i>1475</i>&nbsp;        if (env.version12()) {</b>
<b class="nc"><i>1476</i>&nbsp;            mirandaMethods = null;</b>
<i>1477</i>&nbsp;        } else {
<b class="nc"><i>1478</i>&nbsp;            mirandaMethods = new MethodSet();</b>
<i>1479</i>&nbsp;        }
<i>1480</i>&nbsp;
<i>1481</i>&nbsp;        // Any methods defined in the current class get added
<i>1482</i>&nbsp;        // to both the myMethods and the allMethods MethodSets.
<i>1483</i>&nbsp;
<b class="nc"><i>1484</i>&nbsp;        for (MemberDefinition member = getFirstMember();</b>
<b class="nc"><i>1485</i>&nbsp;             member != null;</b>
<b class="nc"><i>1486</i>&nbsp;             member = member.nextMember) {</b>
<i>1487</i>&nbsp;
<i>1488</i>&nbsp;            // We only collect methods.  Initializers are not relevant.
<b class="nc"><i>1489</i>&nbsp;            if (member.isMethod() &amp;&amp;</b>
<b class="nc"><i>1490</i>&nbsp;                !member.isInitializer()) {</b>
<i>1491</i>&nbsp;
<i>1492</i>&nbsp;                //System.out.println(&quot;Declared in &quot; + this + &quot;, &quot; + member);
<i>1493</i>&nbsp;
<i>1494</i>&nbsp;                ////////////////////////////////////////////////////////////
<i>1495</i>&nbsp;                // PCJ 2003-07-30 modified the following code because with
<i>1496</i>&nbsp;                // the covariant return type feature of the 1.5 compiler,
<i>1497</i>&nbsp;                // there might be multiple methods with the same signature
<i>1498</i>&nbsp;                // but different return types, and MethodSet doesn&#39;t
<i>1499</i>&nbsp;                // support that.  We use a new utility method that attempts
<i>1500</i>&nbsp;                // to ensure that the appropriate method winds up in the
<i>1501</i>&nbsp;                // MethodSet.  See 4892308.
<i>1502</i>&nbsp;                ////////////////////////////////////////////////////////////
<i>1503</i>&nbsp;                // myMethods.add(member);
<i>1504</i>&nbsp;                // allMethods.add(member);
<i>1505</i>&nbsp;                ////////////////////////////////////////////////////////////
<b class="nc"><i>1506</i>&nbsp;                methodSetAdd(env, myMethods, member);</b>
<b class="nc"><i>1507</i>&nbsp;                methodSetAdd(env, allMethods, member);</b>
<i>1508</i>&nbsp;                ////////////////////////////////////////////////////////////
<i>1509</i>&nbsp;            }
<i>1510</i>&nbsp;        }
<i>1511</i>&nbsp;
<i>1512</i>&nbsp;        // We&#39;re ready to start adding inherited methods.  First add
<i>1513</i>&nbsp;        // the methods from our superclass.
<i>1514</i>&nbsp;
<i>1515</i>&nbsp;        //System.out.println(&quot;About to start superclasses for &quot; + this);
<i>1516</i>&nbsp;
<b class="nc"><i>1517</i>&nbsp;        ClassDeclaration scDecl = getSuperClass(env);</b>
<b class="nc"><i>1518</i>&nbsp;        if (scDecl != null) {</b>
<b class="nc"><i>1519</i>&nbsp;            collectOneClass(env, scDecl,</b>
<i>1520</i>&nbsp;                            myMethods, allMethods, mirandaMethods);
<i>1521</i>&nbsp;
<i>1522</i>&nbsp;            // Make sure that we add all unimplementable methods from our
<i>1523</i>&nbsp;            // superclass to our list of unimplementable methods.
<b class="nc"><i>1524</i>&nbsp;            ClassDefinition sc = scDecl.getClassDefinition();</b>
<b class="nc"><i>1525</i>&nbsp;            Iterator&lt;MemberDefinition&gt; supIter = sc.getPermanentlyAbstractMethods();</b>
<b class="nc"><i>1526</i>&nbsp;            while (supIter.hasNext()) {</b>
<b class="nc"><i>1527</i>&nbsp;                permanentlyAbstractMethods.add(supIter.next());</b>
<i>1528</i>&nbsp;            }
<i>1529</i>&nbsp;        }
<i>1530</i>&nbsp;
<i>1531</i>&nbsp;        // Now we inherit all of the methods from our interfaces.
<i>1532</i>&nbsp;
<i>1533</i>&nbsp;        //System.out.println(&quot;About to start interfaces for &quot; + this);
<i>1534</i>&nbsp;
<b class="nc"><i>1535</i>&nbsp;        for (int i = 0; i &lt; interfaces.length; i++) {</b>
<b class="nc"><i>1536</i>&nbsp;            collectOneClass(env, interfaces[i],</b>
<i>1537</i>&nbsp;                            myMethods, allMethods, mirandaMethods);
<i>1538</i>&nbsp;        }
<b class="nc"><i>1539</i>&nbsp;        allMethods.freeze();</b>
<i>1540</i>&nbsp;
<i>1541</i>&nbsp;        // Now we have collected all of our methods from our superclasses
<i>1542</i>&nbsp;        // and interfaces into our `allMethods&#39; member.  Good.  As a last
<i>1543</i>&nbsp;        // task, we add our collected miranda methods to this class.
<i>1544</i>&nbsp;        //
<i>1545</i>&nbsp;        // If we do not add the mirandas to the class explicitly, there
<i>1546</i>&nbsp;        // will be no code generated for them.
<b class="nc"><i>1547</i>&nbsp;        if (mirandaMethods != null &amp;&amp; mirandaMethods.size() &gt; 0) {</b>
<b class="nc"><i>1548</i>&nbsp;            addMirandaMethods(env, mirandaMethods.iterator());</b>
<i>1549</i>&nbsp;        }
<i>1550</i>&nbsp;    }
<i>1551</i>&nbsp;
<i>1552</i>&nbsp;    ////////////////////////////////////////////////////////////
<i>1553</i>&nbsp;    // PCJ 2003-07-30 added this utility method to insulate
<i>1554</i>&nbsp;    // MethodSet additions from the covariant return type
<i>1555</i>&nbsp;    // feature of the 1.5 compiler.  When there are multiple
<i>1556</i>&nbsp;    // methods with the same signature and different return
<i>1557</i>&nbsp;    // types to be added, we try to ensure that the one with
<i>1558</i>&nbsp;    // the most specific return type winds up in the MethodSet.
<i>1559</i>&nbsp;    // This logic was not put into MethodSet itself because it
<i>1560</i>&nbsp;    // requires access to an Environment for type relationship
<i>1561</i>&nbsp;    // checking.  No error checking is performed here, but that
<i>1562</i>&nbsp;    // should be OK because this code is only still used by
<i>1563</i>&nbsp;    // rmic.  See 4892308.
<i>1564</i>&nbsp;    ////////////////////////////////////////////////////////////
<i>1565</i>&nbsp;    private static void methodSetAdd(Environment env,
<i>1566</i>&nbsp;                                     MethodSet methodSet,
<i>1567</i>&nbsp;                                     MemberDefinition newMethod)
<i>1568</i>&nbsp;    {
<b class="nc"><i>1569</i>&nbsp;        MemberDefinition oldMethod = methodSet.lookupSig(newMethod.getName(),</b>
<b class="nc"><i>1570</i>&nbsp;                                                         newMethod.getType());</b>
<b class="nc"><i>1571</i>&nbsp;        if (oldMethod != null) {</b>
<b class="nc"><i>1572</i>&nbsp;            Type oldReturnType = oldMethod.getType().getReturnType();</b>
<b class="nc"><i>1573</i>&nbsp;            Type newReturnType = newMethod.getType().getReturnType();</b>
<i>1574</i>&nbsp;            try {
<b class="nc"><i>1575</i>&nbsp;                if (env.isMoreSpecific(newReturnType, oldReturnType)) {</b>
<b class="nc"><i>1576</i>&nbsp;                    methodSet.replace(newMethod);</b>
<i>1577</i>&nbsp;                }
<b class="nc"><i>1578</i>&nbsp;            } catch (ClassNotFound ignore) {</b>
<b class="nc"><i>1579</i>&nbsp;            }</b>
<b class="nc"><i>1580</i>&nbsp;        } else {</b>
<b class="nc"><i>1581</i>&nbsp;            methodSet.add(newMethod);</b>
<i>1582</i>&nbsp;        }
<i>1583</i>&nbsp;    }
<i>1584</i>&nbsp;    ////////////////////////////////////////////////////////////
<i>1585</i>&nbsp;
<i>1586</i>&nbsp;    /**
<i>1587</i>&nbsp;     * Get an Iterator of all methods which could be accessed in an
<i>1588</i>&nbsp;     * instance of this class.
<i>1589</i>&nbsp;     */
<i>1590</i>&nbsp;    public Iterator&lt;MemberDefinition&gt; getMethods(Environment env) {
<b class="nc"><i>1591</i>&nbsp;        if (allMethods == null) {</b>
<b class="nc"><i>1592</i>&nbsp;            collectInheritedMethods(env);</b>
<i>1593</i>&nbsp;        }
<b class="nc"><i>1594</i>&nbsp;        return getMethods();</b>
<i>1595</i>&nbsp;    }
<i>1596</i>&nbsp;
<i>1597</i>&nbsp;    /**
<i>1598</i>&nbsp;     * Get an Iterator of all methods which could be accessed in an
<i>1599</i>&nbsp;     * instance of this class.  Throw a compiler error if we haven&#39;t
<i>1600</i>&nbsp;     * generated this information yet.
<i>1601</i>&nbsp;     */
<i>1602</i>&nbsp;    public Iterator&lt;MemberDefinition&gt; getMethods() {
<b class="nc"><i>1603</i>&nbsp;        if (allMethods == null) {</b>
<b class="nc"><i>1604</i>&nbsp;            throw new CompilerError(&quot;getMethods: too early&quot;);</b>
<i>1605</i>&nbsp;        }
<b class="nc"><i>1606</i>&nbsp;        return allMethods.iterator();</b>
<i>1607</i>&nbsp;    }
<i>1608</i>&nbsp;
<i>1609</i>&nbsp;    // In early VM&#39;s there was a bug -- the VM didn&#39;t walk the interfaces
<i>1610</i>&nbsp;    // of a class looking for a method, they only walked the superclass
<i>1611</i>&nbsp;    // chain.  This meant that abstract methods defined only in interfaces
<i>1612</i>&nbsp;    // were not being found.  To fix this bug, a counter-bug was introduced
<i>1613</i>&nbsp;    // in the compiler -- the so-called Miranda methods.  If a class
<i>1614</i>&nbsp;    // does not provide a definition for an abstract method in one of
<i>1615</i>&nbsp;    // its interfaces then the compiler inserts one in the class artificially.
<i>1616</i>&nbsp;    // That way the VM didn&#39;t have to bother looking at the interfaces.
<i>1617</i>&nbsp;    //
<i>1618</i>&nbsp;    // This is a problem.  Miranda methods are not part of the specification.
<i>1619</i>&nbsp;    // But they continue to be inserted so that old VM&#39;s can run new code.
<i>1620</i>&nbsp;    // Someday, when the old VM&#39;s are gone, perhaps classes can be compiled
<i>1621</i>&nbsp;    // without Miranda methods.  Towards this end, the compiler has a
<i>1622</i>&nbsp;    // flag, -nomiranda, which can turn off the creation of these methods.
<i>1623</i>&nbsp;    // Eventually that behavior should become the default.
<i>1624</i>&nbsp;    //
<i>1625</i>&nbsp;    // Why are they called Miranda methods?  Well the sentence &quot;If the
<i>1626</i>&nbsp;    // class is not able to provide a method, then one will be provided
<i>1627</i>&nbsp;    // by the compiler&quot; is very similar to the sentence &quot;If you cannot
<i>1628</i>&nbsp;    // afford an attorney, one will be provided by the court,&quot; -- one
<i>1629</i>&nbsp;    // of the so-called &quot;Miranda&quot; rights in the United States.
<i>1630</i>&nbsp;
<i>1631</i>&nbsp;    /**
<i>1632</i>&nbsp;     * Add a list of methods to this class as miranda methods.  This
<i>1633</i>&nbsp;     * gets overridden with a meaningful implementation in SourceClass.
<i>1634</i>&nbsp;     * BinaryClass should not need to do anything -- it should already
<i>1635</i>&nbsp;     * have its miranda methods and, if it doesn&#39;t, then that doesn&#39;t
<i>1636</i>&nbsp;     * affect our compilation.
<i>1637</i>&nbsp;     */
<i>1638</i>&nbsp;    protected void addMirandaMethods(Environment env,
<i>1639</i>&nbsp;                                     Iterator&lt;MemberDefinition&gt; mirandas) {
<i>1640</i>&nbsp;        // do nothing.
<i>1641</i>&nbsp;    }
<i>1642</i>&nbsp;
<i>1643</i>&nbsp;    //---------------------------------------------------------------
<i>1644</i>&nbsp;
<i>1645</i>&nbsp;    public void inlineLocalClass(Environment env) {
<i>1646</i>&nbsp;    }
<i>1647</i>&nbsp;
<i>1648</i>&nbsp;    /**
<i>1649</i>&nbsp;     * We create a stub for this.  Source classes do more work.
<i>1650</i>&nbsp;     * Some calls from &#39;SourceClass.checkSupers&#39; execute this method.
<i>1651</i>&nbsp;     * @see sun.tools.javac.SourceClass#resolveTypeStructure
<i>1652</i>&nbsp;     */
<i>1653</i>&nbsp;
<i>1654</i>&nbsp;    public void resolveTypeStructure(Environment env) {
<i>1655</i>&nbsp;    }
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;    /**
<i>1658</i>&nbsp;     * Look up an inner class name, from somewhere inside this class.
<i>1659</i>&nbsp;     * Since supers and outers are in scope, search them too.
<i>1660</i>&nbsp;     * &lt;p&gt;
<i>1661</i>&nbsp;     * If no inner class is found, env.resolveName() is then called,
<i>1662</i>&nbsp;     * to interpret the ambient package and import directives.
<i>1663</i>&nbsp;     * &lt;p&gt;
<i>1664</i>&nbsp;     * This routine operates on a &quot;best-efforts&quot; basis.  If
<i>1665</i>&nbsp;     * at some point a class is not found, the partially-resolved
<i>1666</i>&nbsp;     * identifier is returned.  Eventually, someone else has to
<i>1667</i>&nbsp;     * try to get the ClassDefinition and diagnose the ClassNotFound.
<i>1668</i>&nbsp;     * &lt;p&gt;
<i>1669</i>&nbsp;     * resolveName() looks at surrounding scopes, and hence
<i>1670</i>&nbsp;     * pulling in both inherited and uplevel types.  By contrast,
<i>1671</i>&nbsp;     * resolveInnerClass() is intended only for interpreting
<i>1672</i>&nbsp;     * explicitly qualified names, and so look only at inherited
<i>1673</i>&nbsp;     * types.  Also, resolveName() looks for package prefixes,
<i>1674</i>&nbsp;     * which appear similar to &quot;very uplevel&quot; outer classes.
<i>1675</i>&nbsp;     * &lt;p&gt;
<i>1676</i>&nbsp;     * A similar (but more complex) name-lookup process happens
<i>1677</i>&nbsp;     * when field and identifier expressions denoting qualified names
<i>1678</i>&nbsp;     * are type-checked.  The added complexity comes from the fact
<i>1679</i>&nbsp;     * that variables may occur in such names, and take precedence
<i>1680</i>&nbsp;     * over class and package names.
<i>1681</i>&nbsp;     * &lt;p&gt;
<i>1682</i>&nbsp;     * In the expression type-checker, resolveInnerClass() is paralleled
<i>1683</i>&nbsp;     * by code in FieldExpression.checkAmbigName(), which also calls
<i>1684</i>&nbsp;     * ClassDefinition.getInnerClass() to interpret names of the form
<i>1685</i>&nbsp;     * &quot;OuterClass.Inner&quot; (and also outerObject.Inner).  The checking
<i>1686</i>&nbsp;     * of an identifier expression that fails to be a variable is referred
<i>1687</i>&nbsp;     * directly to resolveName().
<i>1688</i>&nbsp;     */
<i>1689</i>&nbsp;    public Identifier resolveName(Environment env, Identifier name) {
<b class="nc"><i>1690</i>&nbsp;        if (tracing) env.dtEvent(&quot;ClassDefinition.resolveName: &quot; + name);</b>
<i>1691</i>&nbsp;        // This logic is pretty much exactly parallel to that of
<i>1692</i>&nbsp;        // Environment.resolveName().
<b class="nc"><i>1693</i>&nbsp;        if (name.isQualified()) {</b>
<i>1694</i>&nbsp;            // Try to resolve the first identifier component,
<i>1695</i>&nbsp;            // because inner class names take precedence over
<i>1696</i>&nbsp;            // package prefixes.  (Cf. Environment.resolveName.)
<b class="nc"><i>1697</i>&nbsp;            Identifier rhead = resolveName(env, name.getHead());</b>
<i>1698</i>&nbsp;
<b class="nc"><i>1699</i>&nbsp;            if (rhead.hasAmbigPrefix()) {</b>
<i>1700</i>&nbsp;                // The first identifier component refers to an
<i>1701</i>&nbsp;                // ambiguous class.  Limp on.  We throw away the
<i>1702</i>&nbsp;                // rest of the classname as it is irrelevant.
<i>1703</i>&nbsp;                // (part of solution for 4059855).
<b class="nc"><i>1704</i>&nbsp;                return rhead;</b>
<i>1705</i>&nbsp;            }
<i>1706</i>&nbsp;
<b class="nc"><i>1707</i>&nbsp;            if (!env.classExists(rhead)) {</b>
<b class="nc"><i>1708</i>&nbsp;                return env.resolvePackageQualifiedName(name);</b>
<i>1709</i>&nbsp;            }
<i>1710</i>&nbsp;            try {
<b class="nc"><i>1711</i>&nbsp;                return env.getClassDefinition(rhead).</b>
<b class="nc"><i>1712</i>&nbsp;                    resolveInnerClass(env, name.getTail());</b>
<b class="nc"><i>1713</i>&nbsp;            } catch (ClassNotFound ee) {</b>
<i>1714</i>&nbsp;                // return partially-resolved name someone else can fail on
<b class="nc"><i>1715</i>&nbsp;                return Identifier.lookupInner(rhead, name.getTail());</b>
<i>1716</i>&nbsp;            }
<i>1717</i>&nbsp;        }
<i>1718</i>&nbsp;
<i>1719</i>&nbsp;        // This method used to fail to look for local classes, thus a
<i>1720</i>&nbsp;        // reference to a local class within, e.g., the type of a member
<i>1721</i>&nbsp;        // declaration, would fail to resolve if the immediately enclosing
<i>1722</i>&nbsp;        // context was an inner class.  The code added below is ugly, but
<i>1723</i>&nbsp;        // it works, and is lifted from existing code in &#39;Context.resolveName&#39;
<i>1724</i>&nbsp;        // and &#39;Context.getClassCommon&#39;. See the comments there about the design.
<i>1725</i>&nbsp;        // Fixes 4095716.
<i>1726</i>&nbsp;
<b class="nc"><i>1727</i>&nbsp;        int ls = -2;</b>
<b class="nc"><i>1728</i>&nbsp;        LocalMember lf = null;</b>
<b class="nc"><i>1729</i>&nbsp;        if (classContext != null) {</b>
<b class="nc"><i>1730</i>&nbsp;            lf = classContext.getLocalClass(name);</b>
<b class="nc"><i>1731</i>&nbsp;            if (lf != null) {</b>
<b class="nc"><i>1732</i>&nbsp;                ls = lf.getScopeNumber();</b>
<i>1733</i>&nbsp;            }
<i>1734</i>&nbsp;        }
<i>1735</i>&nbsp;
<i>1736</i>&nbsp;        // Look for an unqualified name in enclosing scopes.
<b class="nc"><i>1737</i>&nbsp;        for (ClassDefinition c = this; c != null; c = c.outerClass) {</b>
<i>1738</i>&nbsp;            try {
<b class="nc"><i>1739</i>&nbsp;                MemberDefinition f = c.getInnerClass(env, name);</b>
<b class="nc"><i>1740</i>&nbsp;                if (f != null &amp;&amp;</b>
<b class="nc"><i>1741</i>&nbsp;                    (lf == null || classContext.getScopeNumber(c) &gt; ls)) {</b>
<i>1742</i>&nbsp;                    // An uplevel member was found, and was nested more deeply than
<i>1743</i>&nbsp;                    // any enclosing local of the same name.
<b class="nc"><i>1744</i>&nbsp;                    return f.getInnerClass().getName();</b>
<i>1745</i>&nbsp;                }
<b class="nc"><i>1746</i>&nbsp;            } catch (ClassNotFound ee) {</b>
<i>1747</i>&nbsp;                // a missing superclass, or something catastrophic
<b class="nc"><i>1748</i>&nbsp;            }</b>
<i>1749</i>&nbsp;        }
<i>1750</i>&nbsp;
<i>1751</i>&nbsp;        // No uplevel member found, so use the enclosing local if one was found.
<b class="nc"><i>1752</i>&nbsp;        if (lf != null) {</b>
<b class="nc"><i>1753</i>&nbsp;           return lf.getInnerClass().getName();</b>
<i>1754</i>&nbsp;        }
<i>1755</i>&nbsp;
<i>1756</i>&nbsp;        // look in imports, etc.
<b class="nc"><i>1757</i>&nbsp;        return env.resolveName(name);</b>
<i>1758</i>&nbsp;    }
<i>1759</i>&nbsp;
<i>1760</i>&nbsp;    /**
<i>1761</i>&nbsp;     * Interpret a qualified class name, which may have further subcomponents..
<i>1762</i>&nbsp;     * Follow inheritance links, as in:
<i>1763</i>&nbsp;     *  class C { class N { } }  class D extends C { }  ... new D.N() ...
<i>1764</i>&nbsp;     * Ignore outer scopes and packages.
<i>1765</i>&nbsp;     * @see resolveName
<i>1766</i>&nbsp;     */
<i>1767</i>&nbsp;    public Identifier resolveInnerClass(Environment env, Identifier nm) {
<b class="nc"><i>1768</i>&nbsp;        if (nm.isInner())  throw new CompilerError(&quot;inner&quot;);</b>
<b class="nc"><i>1769</i>&nbsp;        if (nm.isQualified()) {</b>
<b class="nc"><i>1770</i>&nbsp;            Identifier rhead = resolveInnerClass(env, nm.getHead());</b>
<i>1771</i>&nbsp;            try {
<b class="nc"><i>1772</i>&nbsp;                return env.getClassDefinition(rhead).</b>
<b class="nc"><i>1773</i>&nbsp;                    resolveInnerClass(env, nm.getTail());</b>
<b class="nc"><i>1774</i>&nbsp;            } catch (ClassNotFound ee) {</b>
<i>1775</i>&nbsp;                // return partially-resolved name someone else can fail on
<b class="nc"><i>1776</i>&nbsp;                return Identifier.lookupInner(rhead, nm.getTail());</b>
<i>1777</i>&nbsp;            }
<i>1778</i>&nbsp;        } else {
<i>1779</i>&nbsp;            try {
<b class="nc"><i>1780</i>&nbsp;                MemberDefinition f = getInnerClass(env, nm);</b>
<b class="nc"><i>1781</i>&nbsp;                if (f != null) {</b>
<b class="nc"><i>1782</i>&nbsp;                    return f.getInnerClass().getName();</b>
<i>1783</i>&nbsp;                }
<b class="nc"><i>1784</i>&nbsp;            } catch (ClassNotFound ee) {</b>
<i>1785</i>&nbsp;                // a missing superclass, or something catastrophic
<b class="nc"><i>1786</i>&nbsp;            }</b>
<i>1787</i>&nbsp;            // Fake a good name for a diagnostic.
<b class="nc"><i>1788</i>&nbsp;            return Identifier.lookupInner(this.getName(), nm);</b>
<i>1789</i>&nbsp;        }
<i>1790</i>&nbsp;    }
<i>1791</i>&nbsp;
<i>1792</i>&nbsp;    /**
<i>1793</i>&nbsp;     * While resolving import directives, the question has arisen:
<i>1794</i>&nbsp;     * does a given inner class exist?  If the top-level class exists,
<i>1795</i>&nbsp;     * we ask it about an inner class via this method.
<i>1796</i>&nbsp;     * This method looks only at the literal name of the class,
<i>1797</i>&nbsp;     * and does not attempt to follow inheritance links.
<i>1798</i>&nbsp;     * This is necessary, since at the time imports are being
<i>1799</i>&nbsp;     * processed, inheritance links have not been resolved yet.
<i>1800</i>&nbsp;     * (Thus, an import directive must always spell a class
<i>1801</i>&nbsp;     * name exactly.)
<i>1802</i>&nbsp;     */
<i>1803</i>&nbsp;    public boolean innerClassExists(Identifier nm) {
<b class="nc"><i>1804</i>&nbsp;        for (MemberDefinition field = getFirstMatch(nm.getHead()) ; field != null ; field = field.getNextMatch()) {</b>
<b class="nc"><i>1805</i>&nbsp;            if (field.isInnerClass()) {</b>
<b class="nc"><i>1806</i>&nbsp;                if (field.getInnerClass().isLocal()) {</b>
<b class="nc"><i>1807</i>&nbsp;                    continue;   // ignore this name; it is internally generated</b>
<i>1808</i>&nbsp;                }
<b class="nc"><i>1809</i>&nbsp;                return !nm.isQualified() ||</b>
<b class="nc"><i>1810</i>&nbsp;                    field.getInnerClass().innerClassExists(nm.getTail());</b>
<i>1811</i>&nbsp;            }
<i>1812</i>&nbsp;        }
<b class="nc"><i>1813</i>&nbsp;        return false;</b>
<i>1814</i>&nbsp;    }
<i>1815</i>&nbsp;
<i>1816</i>&nbsp;   /**
<i>1817</i>&nbsp;     * Find any method with a given name.
<i>1818</i>&nbsp;     */
<i>1819</i>&nbsp;    public MemberDefinition findAnyMethod(Environment env, Identifier nm) throws ClassNotFound {
<i>1820</i>&nbsp;        MemberDefinition f;
<b class="nc"><i>1821</i>&nbsp;        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</b>
<b class="nc"><i>1822</i>&nbsp;            if (f.isMethod()) {</b>
<b class="nc"><i>1823</i>&nbsp;                return f;</b>
<i>1824</i>&nbsp;            }
<i>1825</i>&nbsp;        }
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;        // look in the super class
<b class="nc"><i>1828</i>&nbsp;        ClassDeclaration sup = getSuperClass();</b>
<b class="nc"><i>1829</i>&nbsp;        if (sup == null)</b>
<b class="nc"><i>1830</i>&nbsp;            return null;</b>
<b class="nc"><i>1831</i>&nbsp;        return sup.getClassDefinition(env).findAnyMethod(env, nm);</b>
<i>1832</i>&nbsp;    }
<i>1833</i>&nbsp;
<i>1834</i>&nbsp;    /**
<i>1835</i>&nbsp;      * Given the fact that this class has no method &quot;nm&quot; matching &quot;argTypes&quot;,
<i>1836</i>&nbsp;      * find out if the mismatch can be blamed on a particular actual argument
<i>1837</i>&nbsp;      * which disagrees with all of the overloadings.
<i>1838</i>&nbsp;      * If so, return the code (i&lt;&lt;2)+(castOK&lt;&lt;1)+ambig, where
<i>1839</i>&nbsp;      * &quot;i&quot; is the number of the offending argument, and
<i>1840</i>&nbsp;      * &quot;castOK&quot; is 1 if a cast could fix the problem.
<i>1841</i>&nbsp;      * The target type for the argument is returned in margTypeResult[0].
<i>1842</i>&nbsp;      * If not all methods agree on this type, &quot;ambig&quot; is 1.
<i>1843</i>&nbsp;      * If there is more than one method, the choice of target type is
<i>1844</i>&nbsp;      * arbitrary.&lt;p&gt;
<i>1845</i>&nbsp;      * Return -1 if every argument is acceptable to at least one method.
<i>1846</i>&nbsp;      * Return -2 if there are no methods of the required arity.
<i>1847</i>&nbsp;      * The value &quot;start&quot; gives the index of the first argument to begin
<i>1848</i>&nbsp;      * checking.
<i>1849</i>&nbsp;      */
<i>1850</i>&nbsp;    public int diagnoseMismatch(Environment env, Identifier nm, Type argTypes[],
<i>1851</i>&nbsp;                                int start, Type margTypeResult[]) throws ClassNotFound {
<b class="nc"><i>1852</i>&nbsp;        int haveMatch[] = new int[argTypes.length];</b>
<b class="nc"><i>1853</i>&nbsp;        Type margType[] = new Type[argTypes.length];</b>
<b class="nc"><i>1854</i>&nbsp;        if (!diagnoseMismatch(env, nm, argTypes, start, haveMatch, margType))</b>
<b class="nc"><i>1855</i>&nbsp;            return -2;</b>
<b class="nc"><i>1856</i>&nbsp;        for (int i = start; i &lt; argTypes.length; i++) {</b>
<b class="nc"><i>1857</i>&nbsp;            if (haveMatch[i] &lt; 4) {</b>
<b class="nc"><i>1858</i>&nbsp;                margTypeResult[0] = margType[i];</b>
<b class="nc"><i>1859</i>&nbsp;                return (i&lt;&lt;2) | haveMatch[i];</b>
<i>1860</i>&nbsp;            }
<i>1861</i>&nbsp;        }
<b class="nc"><i>1862</i>&nbsp;        return -1;</b>
<i>1863</i>&nbsp;    }
<i>1864</i>&nbsp;
<i>1865</i>&nbsp;    private boolean diagnoseMismatch(Environment env, Identifier nm, Type argTypes[], int start,
<i>1866</i>&nbsp;                                     int haveMatch[], Type margType[]) throws ClassNotFound {
<i>1867</i>&nbsp;        // look in the current class
<b class="nc"><i>1868</i>&nbsp;        boolean haveOne = false;</b>
<i>1869</i>&nbsp;        MemberDefinition f;
<b class="nc"><i>1870</i>&nbsp;        for (f = getFirstMatch(nm) ; f != null ; f = f.getNextMatch()) {</b>
<b class="nc"><i>1871</i>&nbsp;            if (!f.isMethod()) {</b>
<b class="nc"><i>1872</i>&nbsp;                continue;</b>
<i>1873</i>&nbsp;            }
<b class="nc"><i>1874</i>&nbsp;            Type fArgTypes[] = f.getType().getArgumentTypes();</b>
<b class="nc"><i>1875</i>&nbsp;            if (fArgTypes.length == argTypes.length) {</b>
<b class="nc"><i>1876</i>&nbsp;                haveOne = true;</b>
<b class="nc"><i>1877</i>&nbsp;                for (int i = start; i &lt; argTypes.length; i++) {</b>
<b class="nc"><i>1878</i>&nbsp;                    Type at = argTypes[i];</b>
<b class="nc"><i>1879</i>&nbsp;                    Type ft = fArgTypes[i];</b>
<b class="nc"><i>1880</i>&nbsp;                    if (env.implicitCast(at, ft)) {</b>
<b class="nc"><i>1881</i>&nbsp;                        haveMatch[i] = 4;</b>
<b class="nc"><i>1882</i>&nbsp;                        continue;</b>
<b class="nc"><i>1883</i>&nbsp;                    } else if (haveMatch[i] &lt;= 2 &amp;&amp; env.explicitCast(at, ft)) {</b>
<b class="nc"><i>1884</i>&nbsp;                        if (haveMatch[i] &lt; 2)  margType[i] = null;</b>
<b class="nc"><i>1885</i>&nbsp;                        haveMatch[i] = 2;</b>
<b class="nc"><i>1886</i>&nbsp;                    } else if (haveMatch[i] &gt; 0) {</b>
<b class="nc"><i>1887</i>&nbsp;                        continue;</b>
<i>1888</i>&nbsp;                    }
<b class="nc"><i>1889</i>&nbsp;                    if (margType[i] == null)</b>
<b class="nc"><i>1890</i>&nbsp;                        margType[i] = ft;</b>
<b class="nc"><i>1891</i>&nbsp;                    else if (margType[i] != ft)</b>
<b class="nc"><i>1892</i>&nbsp;                        haveMatch[i] |= 1;</b>
<i>1893</i>&nbsp;                }
<i>1894</i>&nbsp;            }
<i>1895</i>&nbsp;        }
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;        // constructors are not inherited
<b class="nc"><i>1898</i>&nbsp;        if (nm.equals(idInit)) {</b>
<b class="nc"><i>1899</i>&nbsp;            return haveOne;</b>
<i>1900</i>&nbsp;        }
<i>1901</i>&nbsp;
<i>1902</i>&nbsp;        // look in the super class
<b class="nc"><i>1903</i>&nbsp;        ClassDeclaration sup = getSuperClass();</b>
<b class="nc"><i>1904</i>&nbsp;        if (sup != null) {</b>
<b class="nc"><i>1905</i>&nbsp;            if (sup.getClassDefinition(env).diagnoseMismatch(env, nm, argTypes, start,</b>
<i>1906</i>&nbsp;                                                             haveMatch, margType))
<b class="nc"><i>1907</i>&nbsp;                haveOne = true;</b>
<i>1908</i>&nbsp;        }
<b class="nc"><i>1909</i>&nbsp;        return haveOne;</b>
<i>1910</i>&nbsp;    }
<i>1911</i>&nbsp;
<i>1912</i>&nbsp;    /**
<i>1913</i>&nbsp;     * Add a field (no checks)
<i>1914</i>&nbsp;     */
<i>1915</i>&nbsp;    public void addMember(MemberDefinition field) {
<i>1916</i>&nbsp;        //System.out.println(&quot;ADD = &quot; + field);
<b class="nc"><i>1917</i>&nbsp;        if (firstMember == null) {</b>
<b class="nc"><i>1918</i>&nbsp;            firstMember = lastMember = field;</b>
<b class="nc"><i>1919</i>&nbsp;        } else if (field.isSynthetic() &amp;&amp; field.isFinal()</b>
<b class="nc"><i>1920</i>&nbsp;                                       &amp;&amp; field.isVariable()) {</b>
<i>1921</i>&nbsp;            // insert this at the front, because of initialization order
<b class="nc"><i>1922</i>&nbsp;            field.nextMember = firstMember;</b>
<b class="nc"><i>1923</i>&nbsp;            firstMember = field;</b>
<b class="nc"><i>1924</i>&nbsp;            field.nextMatch = fieldHash.get(field.name);</b>
<i>1925</i>&nbsp;        } else {
<b class="nc"><i>1926</i>&nbsp;            lastMember.nextMember = field;</b>
<b class="nc"><i>1927</i>&nbsp;            lastMember = field;</b>
<b class="nc"><i>1928</i>&nbsp;            field.nextMatch = fieldHash.get(field.name);</b>
<i>1929</i>&nbsp;        }
<b class="nc"><i>1930</i>&nbsp;        fieldHash.put(field.name, field);</b>
<i>1931</i>&nbsp;    }
<i>1932</i>&nbsp;
<i>1933</i>&nbsp;    /**
<i>1934</i>&nbsp;     * Add a field (subclasses make checks)
<i>1935</i>&nbsp;     */
<i>1936</i>&nbsp;    public void addMember(Environment env, MemberDefinition field) {
<b class="nc"><i>1937</i>&nbsp;        addMember(field);</b>
<b class="nc"><i>1938</i>&nbsp;        if (resolved) {</b>
<i>1939</i>&nbsp;            // a late addition
<b class="nc"><i>1940</i>&nbsp;            field.resolveTypeStructure(env);</b>
<i>1941</i>&nbsp;        }
<i>1942</i>&nbsp;    }
<i>1943</i>&nbsp;
<i>1944</i>&nbsp;    /**
<i>1945</i>&nbsp;     * Find or create an uplevel reference for the given target.
<i>1946</i>&nbsp;     */
<i>1947</i>&nbsp;    public UplevelReference getReference(LocalMember target) {
<b class="nc"><i>1948</i>&nbsp;        for (UplevelReference r = references; r != null; r = r.getNext()) {</b>
<b class="nc"><i>1949</i>&nbsp;            if (r.getTarget() == target) {</b>
<b class="nc"><i>1950</i>&nbsp;                return r;</b>
<i>1951</i>&nbsp;            }
<i>1952</i>&nbsp;        }
<b class="nc"><i>1953</i>&nbsp;        return addReference(target);</b>
<i>1954</i>&nbsp;    }
<i>1955</i>&nbsp;
<i>1956</i>&nbsp;    protected UplevelReference addReference(LocalMember target) {
<b class="nc"><i>1957</i>&nbsp;        if (target.getClassDefinition() == this) {</b>
<b class="nc"><i>1958</i>&nbsp;            throw new CompilerError(&quot;addReference &quot;+target);</b>
<i>1959</i>&nbsp;        }
<b class="nc"><i>1960</i>&nbsp;        referencesMustNotBeFrozen();</b>
<b class="nc"><i>1961</i>&nbsp;        UplevelReference r = new UplevelReference(this, target);</b>
<b class="nc"><i>1962</i>&nbsp;        references = r.insertInto(references);</b>
<b class="nc"><i>1963</i>&nbsp;        return r;</b>
<i>1964</i>&nbsp;    }
<i>1965</i>&nbsp;
<i>1966</i>&nbsp;    /**
<i>1967</i>&nbsp;     * Return the list of all uplevel references.
<i>1968</i>&nbsp;     */
<i>1969</i>&nbsp;    public UplevelReference getReferences() {
<b class="nc"><i>1970</i>&nbsp;        return references;</b>
<i>1971</i>&nbsp;    }
<i>1972</i>&nbsp;
<i>1973</i>&nbsp;    /**
<i>1974</i>&nbsp;     * Return the same value as getReferences.
<i>1975</i>&nbsp;     * Also, mark the set of references frozen.
<i>1976</i>&nbsp;     * After that, it is an error to add new references.
<i>1977</i>&nbsp;     */
<i>1978</i>&nbsp;    public UplevelReference getReferencesFrozen() {
<b class="nc"><i>1979</i>&nbsp;        referencesFrozen = true;</b>
<b class="nc"><i>1980</i>&nbsp;        return references;</b>
<i>1981</i>&nbsp;    }
<i>1982</i>&nbsp;
<i>1983</i>&nbsp;    /**
<i>1984</i>&nbsp;     * assertion check
<i>1985</i>&nbsp;     */
<i>1986</i>&nbsp;    public final void referencesMustNotBeFrozen() {
<b class="nc"><i>1987</i>&nbsp;        if (referencesFrozen) {</b>
<b class="nc"><i>1988</i>&nbsp;            throw new CompilerError(&quot;referencesMustNotBeFrozen &quot;+this);</b>
<i>1989</i>&nbsp;        }
<i>1990</i>&nbsp;    }
<i>1991</i>&nbsp;
<i>1992</i>&nbsp;    /**
<i>1993</i>&nbsp;     * Get helper method for class literal lookup.
<i>1994</i>&nbsp;     */
<i>1995</i>&nbsp;    public MemberDefinition getClassLiteralLookup(long fwhere) {
<b class="nc"><i>1996</i>&nbsp;        throw new CompilerError(&quot;binary class&quot;);</b>
<i>1997</i>&nbsp;    }
<i>1998</i>&nbsp;
<i>1999</i>&nbsp;    /**
<i>2000</i>&nbsp;     * Add a dependency
<i>2001</i>&nbsp;     */
<i>2002</i>&nbsp;    public void addDependency(ClassDeclaration c) {
<b class="nc"><i>2003</i>&nbsp;        throw new CompilerError(&quot;addDependency&quot;);</b>
<i>2004</i>&nbsp;    }
<i>2005</i>&nbsp;
<i>2006</i>&nbsp;    /**
<i>2007</i>&nbsp;     * Maintain a hash table of local and anonymous classes
<i>2008</i>&nbsp;     * whose internal names are prefixed by the current class.
<i>2009</i>&nbsp;     * The key is the simple internal name, less the prefix.
<i>2010</i>&nbsp;     */
<i>2011</i>&nbsp;
<i>2012</i>&nbsp;    public ClassDefinition getLocalClass(String name) {
<b class="nc"><i>2013</i>&nbsp;        if (localClasses == null) {</b>
<b class="nc"><i>2014</i>&nbsp;            return null;</b>
<i>2015</i>&nbsp;        } else {
<b class="nc"><i>2016</i>&nbsp;            return localClasses.get(name);</b>
<i>2017</i>&nbsp;        }
<i>2018</i>&nbsp;    }
<i>2019</i>&nbsp;
<i>2020</i>&nbsp;    public void addLocalClass(ClassDefinition c, String name) {
<b class="nc"><i>2021</i>&nbsp;        if (localClasses == null) {</b>
<b class="nc"><i>2022</i>&nbsp;            localClasses = new Hashtable&lt;&gt;(LOCAL_CLASSES_SIZE);</b>
<i>2023</i>&nbsp;        }
<b class="nc"><i>2024</i>&nbsp;        localClasses.put(name, c);</b>
<i>2025</i>&nbsp;    }
<i>2026</i>&nbsp;
<i>2027</i>&nbsp;
<i>2028</i>&nbsp;    /**
<i>2029</i>&nbsp;     * Print for debugging
<i>2030</i>&nbsp;     */
<i>2031</i>&nbsp;    public void print(PrintStream out) {
<b class="nc"><i>2032</i>&nbsp;        if (isPublic()) {</b>
<b class="nc"><i>2033</i>&nbsp;            out.print(&quot;public &quot;);</b>
<i>2034</i>&nbsp;        }
<b class="nc"><i>2035</i>&nbsp;        if (isInterface()) {</b>
<b class="nc"><i>2036</i>&nbsp;            out.print(&quot;interface &quot;);</b>
<i>2037</i>&nbsp;        } else {
<b class="nc"><i>2038</i>&nbsp;            out.print(&quot;class &quot;);</b>
<i>2039</i>&nbsp;        }
<b class="nc"><i>2040</i>&nbsp;        out.print(getName() + &quot; &quot;);</b>
<b class="nc"><i>2041</i>&nbsp;        if (getSuperClass() != null) {</b>
<b class="nc"><i>2042</i>&nbsp;            out.print(&quot;extends &quot; + getSuperClass().getName() + &quot; &quot;);</b>
<i>2043</i>&nbsp;        }
<b class="nc"><i>2044</i>&nbsp;        if (interfaces.length &gt; 0) {</b>
<b class="nc"><i>2045</i>&nbsp;            out.print(&quot;implements &quot;);</b>
<b class="nc"><i>2046</i>&nbsp;            for (int i = 0 ; i &lt; interfaces.length ; i++) {</b>
<b class="nc"><i>2047</i>&nbsp;                if (i &gt; 0) {</b>
<b class="nc"><i>2048</i>&nbsp;                    out.print(&quot;, &quot;);</b>
<i>2049</i>&nbsp;                }
<b class="nc"><i>2050</i>&nbsp;                out.print(interfaces[i].getName());</b>
<b class="nc"><i>2051</i>&nbsp;                out.print(&quot; &quot;);</b>
<i>2052</i>&nbsp;            }
<i>2053</i>&nbsp;        }
<b class="nc"><i>2054</i>&nbsp;        out.println(&quot;{&quot;);</b>
<i>2055</i>&nbsp;
<b class="nc"><i>2056</i>&nbsp;        for (MemberDefinition f = getFirstMember() ; f != null ; f = f.getNextMember()) {</b>
<b class="nc"><i>2057</i>&nbsp;            out.print(&quot;    &quot;);</b>
<b class="nc"><i>2058</i>&nbsp;            f.print(out);</b>
<i>2059</i>&nbsp;        }
<i>2060</i>&nbsp;
<b class="nc"><i>2061</i>&nbsp;        out.println(&quot;}&quot;);</b>
<i>2062</i>&nbsp;    }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;    /**
<i>2065</i>&nbsp;     * Convert to String
<i>2066</i>&nbsp;     */
<i>2067</i>&nbsp;    public String toString() {
<b class="nc"><i>2068</i>&nbsp;        return getClassDeclaration().toString();</b>
<i>2069</i>&nbsp;    }
<i>2070</i>&nbsp;
<i>2071</i>&nbsp;    /**
<i>2072</i>&nbsp;     * After the class has been written to disk, try to free up
<i>2073</i>&nbsp;     * some storage.
<i>2074</i>&nbsp;     */
<i>2075</i>&nbsp;    public void cleanup(Environment env) {
<b class="nc"><i>2076</i>&nbsp;        if (env.dump()) {</b>
<b class="nc"><i>2077</i>&nbsp;            env.output(&quot;[cleanup &quot; + getName() + &quot;]&quot;);</b>
<i>2078</i>&nbsp;        }
<b class="nc"><i>2079</i>&nbsp;        for (MemberDefinition f = getFirstMember() ; f != null ; f = f.getNextMember()) {</b>
<b class="nc"><i>2080</i>&nbsp;            f.cleanup(env);</b>
<i>2081</i>&nbsp;        }
<i>2082</i>&nbsp;        // keep &quot;references&quot; around, for the sake of local subclasses
<b class="nc"><i>2083</i>&nbsp;        documentation = null;</b>
<i>2084</i>&nbsp;    }
<i>2085</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
