


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: compiler</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.resources</a> ]
</div>

<h1>Coverage Summary for Class: compiler (com.sun.tools.javac.resources)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">compiler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package com.sun.tools.javac.resources;
<i>2</i>&nbsp;
<b class="nc"><i>3</i>&nbsp;public final class compiler extends java.util.ListResourceBundle {</b>
<i>4</i>&nbsp;    protected final Object[][] getContents() {
<b class="nc"><i>5</i>&nbsp;        return new Object[][] {</b>
<i>6</i>&nbsp;            { &quot;compiler.err.abstract.cant.be.accessed.directly&quot;, &quot;abstract {0} {1} in {2} cannot be accessed directly&quot; },
<i>7</i>&nbsp;            { &quot;compiler.err.abstract.cant.be.instantiated&quot;, &quot;{0} is abstract; cannot be instantiated&quot; },
<i>8</i>&nbsp;            { &quot;compiler.err.abstract.meth.cant.have.body&quot;, &quot;abstract methods cannot have a body&quot; },
<i>9</i>&nbsp;            { &quot;compiler.err.add.exports.with.release&quot;, &quot;exporting a package from system module {0} is not allowed with --release&quot; },
<i>10</i>&nbsp;            { &quot;compiler.err.add.reads.with.release&quot;, &quot;adding read edges for system module {0} is not allowed with --release&quot; },
<i>11</i>&nbsp;            { &quot;compiler.err.addmods.all.module.path.invalid&quot;, &quot;--add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module&quot; },
<i>12</i>&nbsp;            { &quot;compiler.err.already.annotated&quot;, &quot;{0} {1} has already been annotated&quot; },
<i>13</i>&nbsp;            { &quot;compiler.err.already.defined&quot;, &quot;{0} {1} is already defined in {2} {3}&quot; },
<i>14</i>&nbsp;            { &quot;compiler.err.already.defined.in.clinit&quot;, &quot;{0} {1} is already defined in {2} of {3} {4}&quot; },
<i>15</i>&nbsp;            { &quot;compiler.err.already.defined.single.import&quot;, &quot;a type with the same simple name is already defined by the single-type-import of {0}&quot; },
<i>16</i>&nbsp;            { &quot;compiler.err.already.defined.static.single.import&quot;, &quot;a type with the same simple name is already defined by the static single-type-import of {0}&quot; },
<i>17</i>&nbsp;            { &quot;compiler.err.already.defined.this.unit&quot;, &quot;{0} is already defined in this compilation unit&quot; },
<i>18</i>&nbsp;            { &quot;compiler.err.annotation.decl.not.allowed.here&quot;, &quot;annotation type declaration not allowed here&quot; },
<i>19</i>&nbsp;            { &quot;compiler.err.annotation.missing.default.value&quot;, &quot;annotation @{0} is missing a default value for the element &#39;&#39;{1}&#39;&#39;&quot; },
<i>20</i>&nbsp;            { &quot;compiler.err.annotation.missing.default.value.1&quot;, &quot;annotation @{0} is missing default values for elements {1}&quot; },
<i>21</i>&nbsp;            { &quot;compiler.err.annotation.not.valid.for.type&quot;, &quot;annotation not valid for an element of type {0}&quot; },
<i>22</i>&nbsp;            { &quot;compiler.err.annotation.type.not.applicable&quot;, &quot;annotation type not applicable to this kind of declaration&quot; },
<i>23</i>&nbsp;            { &quot;compiler.err.annotation.type.not.applicable.to.type&quot;, &quot;annotation @{0} not applicable in this type context&quot; },
<i>24</i>&nbsp;            { &quot;compiler.err.annotation.value.must.be.annotation&quot;, &quot;annotation value must be an annotation&quot; },
<i>25</i>&nbsp;            { &quot;compiler.err.annotation.value.must.be.class.literal&quot;, &quot;annotation value must be a class literal&quot; },
<i>26</i>&nbsp;            { &quot;compiler.err.annotation.value.must.be.name.value&quot;, &quot;annotation values must be of the form &#39;&#39;name=value&#39;&#39;&quot; },
<i>27</i>&nbsp;            { &quot;compiler.err.annotation.value.not.allowable.type&quot;, &quot;annotation value not of an allowable type&quot; },
<i>28</i>&nbsp;            { &quot;compiler.err.anon.class.impl.intf.no.args&quot;, &quot;anonymous class implements interface; cannot have arguments&quot; },
<i>29</i>&nbsp;            { &quot;compiler.err.anon.class.impl.intf.no.qual.for.new&quot;, &quot;anonymous class implements interface; cannot have qualifier for new&quot; },
<i>30</i>&nbsp;            { &quot;compiler.err.anon.class.impl.intf.no.typeargs&quot;, &quot;anonymous class implements interface; cannot have type arguments&quot; },
<i>31</i>&nbsp;            { &quot;compiler.err.anonymous.diamond.method.does.not.override.superclass&quot;, &quot;method does not override or implement a method from a supertype\n{0}&quot; },
<i>32</i>&nbsp;            { &quot;compiler.err.array.and.receiver&quot;, &quot;legacy array notation not allowed on receiver parameter&quot; },
<i>33</i>&nbsp;            { &quot;compiler.err.array.and.varargs&quot;, &quot;cannot declare both {0} and {1} in {2}&quot; },
<i>34</i>&nbsp;            { &quot;compiler.err.array.dimension.missing&quot;, &quot;array dimension missing&quot; },
<i>35</i>&nbsp;            { &quot;compiler.err.array.req.but.found&quot;, &quot;array required, but {0} found&quot; },
<i>36</i>&nbsp;            { &quot;compiler.err.assert.as.identifier&quot;, &quot;as of release 1.4, &#39;&#39;assert&#39;&#39; is a keyword, and may not be used as an identifier&quot; },
<i>37</i>&nbsp;            { &quot;compiler.err.attribute.value.must.be.constant&quot;, &quot;element value must be a constant expression&quot; },
<i>38</i>&nbsp;            { &quot;compiler.err.bad.functional.intf.anno&quot;, &quot;Unexpected @FunctionalInterface annotation&quot; },
<i>39</i>&nbsp;            { &quot;compiler.err.bad.functional.intf.anno.1&quot;, &quot;Unexpected @FunctionalInterface annotation\n{0}&quot; },
<i>40</i>&nbsp;            { &quot;compiler.err.bad.initializer&quot;, &quot;bad initializer for {0}&quot; },
<i>41</i>&nbsp;            { &quot;compiler.err.bad.name.for.option&quot;, &quot;bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;&quot; },
<i>42</i>&nbsp;            { &quot;compiler.err.bad.target.sigpoly.call&quot;, &quot;polymorphic signature calls are not supported in -target {0}\n(use -target {1} or higher to enable polymorphic signature calls)&quot; },
<i>43</i>&nbsp;            { &quot;compiler.err.bad.value.for.option&quot;, &quot;bad value for {0} option: &#39;&#39;{1}&#39;&#39;&quot; },
<i>44</i>&nbsp;            { &quot;compiler.err.break.outside.switch.loop&quot;, &quot;break outside switch or loop&quot; },
<i>45</i>&nbsp;            { &quot;compiler.err.call.must.be.first.stmt.in.ctor&quot;, &quot;call to {0} must be first statement in constructor&quot; },
<i>46</i>&nbsp;            { &quot;compiler.err.call.to.super.not.allowed.in.enum.ctor&quot;, &quot;call to super not allowed in enum constructor&quot; },
<i>47</i>&nbsp;            { &quot;compiler.err.cannot.create.array.with.diamond&quot;, &quot;cannot create array with &#39;&#39;&lt;&gt;&#39;&#39;&quot; },
<i>48</i>&nbsp;            { &quot;compiler.err.cannot.create.array.with.type.arguments&quot;, &quot;cannot create array with type arguments&quot; },
<i>49</i>&nbsp;            { &quot;compiler.err.cannot.generate.class&quot;, &quot;error while generating class {0}\n({1})&quot; },
<i>50</i>&nbsp;            { &quot;compiler.err.cant.access&quot;, &quot;cannot access {0}\n{1}&quot; },
<i>51</i>&nbsp;            { &quot;compiler.err.cant.apply.diamond&quot;, &quot;cannot infer type arguments for {0}&quot; },
<i>52</i>&nbsp;            { &quot;compiler.err.cant.apply.diamond.1&quot;, &quot;cannot infer type arguments for {0}\nreason: {1}&quot; },
<i>53</i>&nbsp;            { &quot;compiler.err.cant.apply.symbol&quot;, &quot;{0} {1} in {4} {5} cannot be applied to given types;\nrequired: {2}\nfound: {3}\nreason: {6}&quot; },
<i>54</i>&nbsp;            { &quot;compiler.err.cant.apply.symbols&quot;, &quot;no suitable {0} found for {1}({2})&quot; },
<i>55</i>&nbsp;            { &quot;compiler.err.cant.assign.val.to.final.var&quot;, &quot;cannot assign a value to final variable {0}&quot; },
<i>56</i>&nbsp;            { &quot;compiler.err.cant.assign.val.to.this&quot;, &quot;cannot assign to &#39;&#39;this&#39;&#39;&quot; },
<i>57</i>&nbsp;            { &quot;compiler.err.cant.deref&quot;, &quot;{0} cannot be dereferenced&quot; },
<i>58</i>&nbsp;            { &quot;compiler.err.cant.extend.intf.annotation&quot;, &quot;&#39;&#39;extends&#39;&#39; not allowed for @interfaces&quot; },
<i>59</i>&nbsp;            { &quot;compiler.err.cant.infer.local.var.type&quot;, &quot;cannot infer type for local variable {0}\n({1})&quot; },
<i>60</i>&nbsp;            { &quot;compiler.err.cant.inherit.diff.arg&quot;, &quot;{0} cannot be inherited with different arguments: &lt;{1}&gt; and &lt;{2}&gt;&quot; },
<i>61</i>&nbsp;            { &quot;compiler.err.cant.inherit.from.anon&quot;, &quot;cannot inherit from anonymous class&quot; },
<i>62</i>&nbsp;            { &quot;compiler.err.cant.inherit.from.final&quot;, &quot;cannot inherit from final {0}&quot; },
<i>63</i>&nbsp;            { &quot;compiler.err.cant.read.file&quot;, &quot;cannot read: {0}&quot; },
<i>64</i>&nbsp;            { &quot;compiler.err.cant.ref.before.ctor.called&quot;, &quot;cannot reference {0} before supertype constructor has been called&quot; },
<i>65</i>&nbsp;            { &quot;compiler.err.cant.ref.non.effectively.final.var&quot;, &quot;local variables referenced from {1} must be final or effectively final&quot; },
<i>66</i>&nbsp;            { &quot;compiler.err.cant.resolve&quot;, &quot;cannot find symbol\nsymbol: {0} {1}&quot; },
<i>67</i>&nbsp;            { &quot;compiler.err.cant.resolve.args&quot;, &quot;cannot find symbol\nsymbol: {0} {1}({3})&quot; },
<i>68</i>&nbsp;            { &quot;compiler.err.cant.resolve.args.params&quot;, &quot;cannot find symbol\nsymbol: {0} &lt;{2}&gt;{1}({3})&quot; },
<i>69</i>&nbsp;            { &quot;compiler.err.cant.resolve.location&quot;, &quot;cannot find symbol\nsymbol:   {0} {1}\nlocation: {4}&quot; },
<i>70</i>&nbsp;            { &quot;compiler.err.cant.resolve.location.args&quot;, &quot;cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}&quot; },
<i>71</i>&nbsp;            { &quot;compiler.err.cant.resolve.location.args.params&quot;, &quot;cannot find symbol\nsymbol:   {0} &lt;{2}&gt;{1}({3})\nlocation: {4}&quot; },
<i>72</i>&nbsp;            { &quot;compiler.err.cant.select.static.class.from.param.type&quot;, &quot;cannot select a static class from a parameterized type&quot; },
<i>73</i>&nbsp;            { &quot;compiler.err.cant.type.annotate.scoping&quot;, &quot;scoping construct cannot be annotated with type-use annotations: {0}&quot; },
<i>74</i>&nbsp;            { &quot;compiler.err.cant.type.annotate.scoping.1&quot;, &quot;scoping construct cannot be annotated with type-use annotation: {0}&quot; },
<i>75</i>&nbsp;            { &quot;compiler.err.catch.without.try&quot;, &quot;&#39;&#39;catch&#39;&#39; without &#39;&#39;try&#39;&#39;&quot; },
<i>76</i>&nbsp;            { &quot;compiler.err.clash.with.pkg.of.same.name&quot;, &quot;{0} {1} clashes with package of same name&quot; },
<i>77</i>&nbsp;            { &quot;compiler.err.class.cant.write&quot;, &quot;error while writing {0}: {1}&quot; },
<i>78</i>&nbsp;            { &quot;compiler.err.class.not.allowed&quot;, &quot;class, interface or enum declaration not allowed here&quot; },
<i>79</i>&nbsp;            { &quot;compiler.err.class.public.should.be.in.file&quot;, &quot;{0} {1} is public, should be declared in a file named {1}.java&quot; },
<i>80</i>&nbsp;            { &quot;compiler.err.concrete.inheritance.conflict&quot;, &quot;methods {0} from {1} and {2} from {3} are inherited with the same signature&quot; },
<i>81</i>&nbsp;            { &quot;compiler.err.conflicting.exports&quot;, &quot;duplicate or conflicting exports: {0}&quot; },
<i>82</i>&nbsp;            { &quot;compiler.err.conflicting.exports.to.module&quot;, &quot;duplicate or conflicting exports to module: {0}&quot; },
<i>83</i>&nbsp;            { &quot;compiler.err.conflicting.opens&quot;, &quot;duplicate or conflicting opens: {0}&quot; },
<i>84</i>&nbsp;            { &quot;compiler.err.conflicting.opens.to.module&quot;, &quot;duplicate or conflicting opens to module: {0}&quot; },
<i>85</i>&nbsp;            { &quot;compiler.err.const.expr.req&quot;, &quot;constant expression required&quot; },
<i>86</i>&nbsp;            { &quot;compiler.err.cont.outside.loop&quot;, &quot;continue outside of loop&quot; },
<i>87</i>&nbsp;            { &quot;compiler.err.cyclic.annotation.element&quot;, &quot;type of element {0} is cyclic&quot; },
<i>88</i>&nbsp;            { &quot;compiler.err.cyclic.inheritance&quot;, &quot;cyclic inheritance involving {0}&quot; },
<i>89</i>&nbsp;            { &quot;compiler.err.cyclic.requires&quot;, &quot;cyclic dependence involving {0}&quot; },
<i>90</i>&nbsp;            { &quot;compiler.err.dc.bad.entity&quot;, &quot;bad HTML entity&quot; },
<i>91</i>&nbsp;            { &quot;compiler.err.dc.bad.gt&quot;, &quot;bad use of &#39;&#39;&gt;&#39;&#39;&quot; },
<i>92</i>&nbsp;            { &quot;compiler.err.dc.bad.inline.tag&quot;, &quot;incorrect use of inline tag&quot; },
<i>93</i>&nbsp;            { &quot;compiler.err.dc.gt.expected&quot;, &quot;&#39;&#39;&gt;&#39;&#39; expected&quot; },
<i>94</i>&nbsp;            { &quot;compiler.err.dc.identifier.expected&quot;, &quot;identifier expected&quot; },
<i>95</i>&nbsp;            { &quot;compiler.err.dc.malformed.html&quot;, &quot;malformed HTML&quot; },
<i>96</i>&nbsp;            { &quot;compiler.err.dc.missing.semicolon&quot;, &quot;semicolon missing&quot; },
<i>97</i>&nbsp;            { &quot;compiler.err.dc.no.content&quot;, &quot;no content&quot; },
<i>98</i>&nbsp;            { &quot;compiler.err.dc.no.tag.name&quot;, &quot;no tag name after &#39;@&#39;&quot; },
<i>99</i>&nbsp;            { &quot;compiler.err.dc.ref.bad.parens&quot;, &quot;&#39;&#39;)&#39;&#39; missing in reference&quot; },
<i>100</i>&nbsp;            { &quot;compiler.err.dc.ref.syntax.error&quot;, &quot;syntax error in reference&quot; },
<i>101</i>&nbsp;            { &quot;compiler.err.dc.ref.unexpected.input&quot;, &quot;unexpected text&quot; },
<i>102</i>&nbsp;            { &quot;compiler.err.dc.unexpected.content&quot;, &quot;unexpected content&quot; },
<i>103</i>&nbsp;            { &quot;compiler.err.dc.unterminated.inline.tag&quot;, &quot;unterminated inline tag&quot; },
<i>104</i>&nbsp;            { &quot;compiler.err.dc.unterminated.signature&quot;, &quot;unterminated signature&quot; },
<i>105</i>&nbsp;            { &quot;compiler.err.dc.unterminated.string&quot;, &quot;unterminated string&quot; },
<i>106</i>&nbsp;            { &quot;compiler.err.default.allowed.in.intf.annotation.member&quot;, &quot;default value only allowed in an annotation type declaration&quot; },
<i>107</i>&nbsp;            { &quot;compiler.err.default.overrides.object.member&quot;, &quot;default method {0} in {1} {2} overrides a member of java.lang.Object&quot; },
<i>108</i>&nbsp;            { &quot;compiler.err.does.not.override.abstract&quot;, &quot;{0} is not abstract and does not override abstract method {1} in {2}&quot; },
<i>109</i>&nbsp;            { &quot;compiler.err.doesnt.exist&quot;, &quot;package {0} does not exist&quot; },
<i>110</i>&nbsp;            { &quot;compiler.err.dot.class.expected&quot;, &quot;&#39;&#39;.class&#39;&#39; expected&quot; },
<i>111</i>&nbsp;            { &quot;compiler.err.duplicate.annotation.invalid.repeated&quot;, &quot;annotation {0} is not a valid repeatable annotation&quot; },
<i>112</i>&nbsp;            { &quot;compiler.err.duplicate.annotation.member.value&quot;, &quot;duplicate element &#39;&#39;{0}&#39;&#39; in annotation @{1}.&quot; },
<i>113</i>&nbsp;            { &quot;compiler.err.duplicate.annotation.missing.container&quot;, &quot;{0} is not a repeatable annotation type&quot; },
<i>114</i>&nbsp;            { &quot;compiler.err.duplicate.case.label&quot;, &quot;duplicate case label&quot; },
<i>115</i>&nbsp;            { &quot;compiler.err.duplicate.class&quot;, &quot;duplicate class: {0}&quot; },
<i>116</i>&nbsp;            { &quot;compiler.err.duplicate.default.label&quot;, &quot;duplicate default label&quot; },
<i>117</i>&nbsp;            { &quot;compiler.err.duplicate.module&quot;, &quot;duplicate module: {0}&quot; },
<i>118</i>&nbsp;            { &quot;compiler.err.duplicate.module.on.path&quot;, &quot;duplicate module on {0}\nmodule in {1}&quot; },
<i>119</i>&nbsp;            { &quot;compiler.err.duplicate.provides&quot;, &quot;duplicate provides: service {0}, implementation {1}&quot; },
<i>120</i>&nbsp;            { &quot;compiler.err.duplicate.requires&quot;, &quot;duplicate requires: {0}&quot; },
<i>121</i>&nbsp;            { &quot;compiler.err.duplicate.uses&quot;, &quot;duplicate uses: {0}&quot; },
<i>122</i>&nbsp;            { &quot;compiler.err.else.without.if&quot;, &quot;&#39;&#39;else&#39;&#39; without &#39;&#39;if&#39;&#39;&quot; },
<i>123</i>&nbsp;            { &quot;compiler.err.empty.A.argument&quot;, &quot;-A requires an argument; use &#39;&#39;-Akey&#39;&#39; or &#39;&#39;-Akey=value&#39;&#39;&quot; },
<i>124</i>&nbsp;            { &quot;compiler.err.empty.char.lit&quot;, &quot;empty character literal&quot; },
<i>125</i>&nbsp;            { &quot;compiler.err.encl.class.required&quot;, &quot;an enclosing instance that contains {0} is required&quot; },
<i>126</i>&nbsp;            { &quot;compiler.err.enum.annotation.must.be.enum.constant&quot;, &quot;an enum annotation value must be an enum constant&quot; },
<i>127</i>&nbsp;            { &quot;compiler.err.enum.as.identifier&quot;, &quot;as of release 5, &#39;&#39;enum&#39;&#39; is a keyword, and may not be used as an identifier&quot; },
<i>128</i>&nbsp;            { &quot;compiler.err.enum.cant.be.instantiated&quot;, &quot;enum types may not be instantiated&quot; },
<i>129</i>&nbsp;            { &quot;compiler.err.enum.label.must.be.unqualified.enum&quot;, &quot;an enum switch case label must be the unqualified name of an enumeration constant&quot; },
<i>130</i>&nbsp;            { &quot;compiler.err.enum.no.finalize&quot;, &quot;enums cannot have finalize methods&quot; },
<i>131</i>&nbsp;            { &quot;compiler.err.enum.no.subclassing&quot;, &quot;classes cannot directly extend java.lang.Enum&quot; },
<i>132</i>&nbsp;            { &quot;compiler.err.enum.types.not.extensible&quot;, &quot;enum types are not extensible&quot; },
<i>133</i>&nbsp;            { &quot;compiler.err.enums.must.be.static&quot;, &quot;enum declarations allowed only in static contexts&quot; },
<i>134</i>&nbsp;            { &quot;compiler.err.error&quot;, &quot;error: &quot; },
<i>135</i>&nbsp;            { &quot;compiler.err.error.reading.file&quot;, &quot;error reading {0}; {1}&quot; },
<i>136</i>&nbsp;            { &quot;compiler.err.error.writing.file&quot;, &quot;error writing {0}; {1}&quot; },
<i>137</i>&nbsp;            { &quot;compiler.err.except.already.caught&quot;, &quot;exception {0} has already been caught&quot; },
<i>138</i>&nbsp;            { &quot;compiler.err.except.never.thrown.in.try&quot;, &quot;exception {0} is never thrown in body of corresponding try statement&quot; },
<i>139</i>&nbsp;            { &quot;compiler.err.expected&quot;, &quot;{0} expected&quot; },
<i>140</i>&nbsp;            { &quot;compiler.err.expected.module&quot;, &quot;expected &#39;&#39;module&#39;&#39;&quot; },
<i>141</i>&nbsp;            { &quot;compiler.err.expected.module.or.open&quot;, &quot;&#39;&#39;module&#39;&#39; or &#39;&#39;open&#39;&#39; expected&quot; },
<i>142</i>&nbsp;            { &quot;compiler.err.expected.str&quot;, &quot;{0} expected&quot; },
<i>143</i>&nbsp;            { &quot;compiler.err.expected2&quot;, &quot;{0} or {1} expected&quot; },
<i>144</i>&nbsp;            { &quot;compiler.err.expected3&quot;, &quot;{0}, {1}, or {2} expected&quot; },
<i>145</i>&nbsp;            { &quot;compiler.err.expression.not.allowable.as.annotation.value&quot;, &quot;expression not allowed as annotation value&quot; },
<i>146</i>&nbsp;            { &quot;compiler.err.feature.not.supported.in.source&quot;, &quot;{0} is not supported in -source {1}\n(use -source {2} or higher to enable {0})&quot; },
<i>147</i>&nbsp;            { &quot;compiler.err.feature.not.supported.in.source.plural&quot;, &quot;{0} are not supported in -source {1}\n(use -source {2} or higher to enable {0})&quot; },
<i>148</i>&nbsp;            { &quot;compiler.err.file.not.directory&quot;, &quot;not a directory: {0}&quot; },
<i>149</i>&nbsp;            { &quot;compiler.err.file.not.file&quot;, &quot;not a file: {0}&quot; },
<i>150</i>&nbsp;            { &quot;compiler.err.file.not.found&quot;, &quot;file not found: {0}&quot; },
<i>151</i>&nbsp;            { &quot;compiler.err.file.patched.and.msp&quot;, &quot;file accessible from both --patch-module and --module-source-path, but belongs to a different module on each path: {0}, {1}&quot; },
<i>152</i>&nbsp;            { &quot;compiler.err.file.sb.on.source.or.patch.path.for.module&quot;, &quot;file should be on source path, or on patch path for module&quot; },
<i>153</i>&nbsp;            { &quot;compiler.err.final.parameter.may.not.be.assigned&quot;, &quot;final parameter {0} may not be assigned&quot; },
<i>154</i>&nbsp;            { &quot;compiler.err.finally.without.try&quot;, &quot;&#39;&#39;finally&#39;&#39; without &#39;&#39;try&#39;&#39;&quot; },
<i>155</i>&nbsp;            { &quot;compiler.err.foreach.not.applicable.to.type&quot;, &quot;for-each not applicable to expression type\nrequired: {1}\nfound:    {0}&quot; },
<i>156</i>&nbsp;            { &quot;compiler.err.fp.number.too.large&quot;, &quot;floating point number too large&quot; },
<i>157</i>&nbsp;            { &quot;compiler.err.fp.number.too.small&quot;, &quot;floating point number too small&quot; },
<i>158</i>&nbsp;            { &quot;compiler.err.generic.array.creation&quot;, &quot;generic array creation&quot; },
<i>159</i>&nbsp;            { &quot;compiler.err.generic.throwable&quot;, &quot;a generic class may not extend java.lang.Throwable&quot; },
<i>160</i>&nbsp;            { &quot;compiler.err.icls.cant.have.static.decl&quot;, &quot;Illegal static declaration in inner class {0}\nmodifier &#39;&#39;static&#39;&#39; is only allowed in constant variable declarations&quot; },
<i>161</i>&nbsp;            { &quot;compiler.err.illegal.argument.for.option&quot;, &quot;illegal argument for {0}: {1}&quot; },
<i>162</i>&nbsp;            { &quot;compiler.err.illegal.array.creation.both.dimension.and.initialization&quot;, &quot;array creation with both dimension expression and initialization is illegal&quot; },
<i>163</i>&nbsp;            { &quot;compiler.err.illegal.char&quot;, &quot;illegal character: &#39;&#39;{0}&#39;&#39;&quot; },
<i>164</i>&nbsp;            { &quot;compiler.err.illegal.char.for.encoding&quot;, &quot;unmappable character (0x{0}) for encoding {1}&quot; },
<i>165</i>&nbsp;            { &quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;illegal combination of modifiers: {0} and {1}&quot; },
<i>166</i>&nbsp;            { &quot;compiler.err.illegal.default.super.call&quot;, &quot;bad type qualifier {0} in default super call\n{1}&quot; },
<i>167</i>&nbsp;            { &quot;compiler.err.illegal.dot&quot;, &quot;illegal &#39;&#39;.&#39;&#39;&quot; },
<i>168</i>&nbsp;            { &quot;compiler.err.illegal.enum.static.ref&quot;, &quot;illegal reference to static field from initializer&quot; },
<i>169</i>&nbsp;            { &quot;compiler.err.illegal.esc.char&quot;, &quot;illegal escape character&quot; },
<i>170</i>&nbsp;            { &quot;compiler.err.illegal.forward.ref&quot;, &quot;illegal forward reference&quot; },
<i>171</i>&nbsp;            { &quot;compiler.err.illegal.generic.type.for.instof&quot;, &quot;illegal generic type for instanceof&quot; },
<i>172</i>&nbsp;            { &quot;compiler.err.illegal.initializer.for.type&quot;, &quot;illegal initializer for {0}&quot; },
<i>173</i>&nbsp;            { &quot;compiler.err.illegal.line.end.in.char.lit&quot;, &quot;illegal line end in character literal&quot; },
<i>174</i>&nbsp;            { &quot;compiler.err.illegal.nonascii.digit&quot;, &quot;illegal non-ASCII digit&quot; },
<i>175</i>&nbsp;            { &quot;compiler.err.illegal.parenthesized.expression&quot;, &quot;illegal parenthesized expression&quot; },
<i>176</i>&nbsp;            { &quot;compiler.err.illegal.qual.not.icls&quot;, &quot;illegal qualifier; {0} is not an inner class&quot; },
<i>177</i>&nbsp;            { &quot;compiler.err.illegal.ref.to.var.type&quot;, &quot;illegal reference to restricted type &#39;&#39;var&#39;&#39;&quot; },
<i>178</i>&nbsp;            { &quot;compiler.err.illegal.self.ref&quot;, &quot;self-reference in initializer&quot; },
<i>179</i>&nbsp;            { &quot;compiler.err.illegal.start.of.expr&quot;, &quot;illegal start of expression&quot; },
<i>180</i>&nbsp;            { &quot;compiler.err.illegal.start.of.stmt&quot;, &quot;illegal start of statement&quot; },
<i>181</i>&nbsp;            { &quot;compiler.err.illegal.start.of.type&quot;, &quot;illegal start of type&quot; },
<i>182</i>&nbsp;            { &quot;compiler.err.illegal.static.intf.meth.call&quot;, &quot;illegal static interface method call\nthe receiver expression should be replaced with the type qualifier &#39;&#39;{0}&#39;&#39;&quot; },
<i>183</i>&nbsp;            { &quot;compiler.err.illegal.underscore&quot;, &quot;illegal underscore&quot; },
<i>184</i>&nbsp;            { &quot;compiler.err.illegal.unicode.esc&quot;, &quot;illegal unicode escape&quot; },
<i>185</i>&nbsp;            { &quot;compiler.err.import.requires.canonical&quot;, &quot;import requires canonical name for {0}&quot; },
<i>186</i>&nbsp;            { &quot;compiler.err.improperly.formed.type.inner.raw.param&quot;, &quot;improperly formed type, type arguments given on a raw type&quot; },
<i>187</i>&nbsp;            { &quot;compiler.err.improperly.formed.type.param.missing&quot;, &quot;improperly formed type, some parameters are missing&quot; },
<i>188</i>&nbsp;            { &quot;compiler.err.incomparable.types&quot;, &quot;incomparable types: {0} and {1}&quot; },
<i>189</i>&nbsp;            { &quot;compiler.err.incompatible.thrown.types.in.mref&quot;, &quot;incompatible thrown types {0} in functional expression&quot; },
<i>190</i>&nbsp;            { &quot;compiler.err.incorrect.constructor.receiver.name&quot;, &quot;the receiver name does not match the enclosing outer class type\nrequired: {0}\nfound: {1}&quot; },
<i>191</i>&nbsp;            { &quot;compiler.err.incorrect.constructor.receiver.type&quot;, &quot;the receiver type does not match the enclosing outer class type\nrequired: {0}\nfound: {1}&quot; },
<i>192</i>&nbsp;            { &quot;compiler.err.incorrect.receiver.name&quot;, &quot;the receiver name does not match the enclosing class type\nrequired: {0}\nfound: {1}&quot; },
<i>193</i>&nbsp;            { &quot;compiler.err.incorrect.receiver.type&quot;, &quot;the receiver type does not match the enclosing class type\nrequired: {0}\nfound: {1}&quot; },
<i>194</i>&nbsp;            { &quot;compiler.err.initializer.must.be.able.to.complete.normally&quot;, &quot;initializer must be able to complete normally&quot; },
<i>195</i>&nbsp;            { &quot;compiler.err.initializer.not.allowed&quot;, &quot;initializers not allowed in interfaces&quot; },
<i>196</i>&nbsp;            { &quot;compiler.err.int.number.too.large&quot;, &quot;integer number too large&quot; },
<i>197</i>&nbsp;            { &quot;compiler.err.intf.annotation.cant.have.type.params&quot;, &quot;annotation type {0} cannot be generic&quot; },
<i>198</i>&nbsp;            { &quot;compiler.err.intf.annotation.member.clash&quot;, &quot;annotation type {1} declares an element with the same name as method {0}&quot; },
<i>199</i>&nbsp;            { &quot;compiler.err.intf.annotation.members.cant.have.params&quot;, &quot;elements in annotation type declarations cannot declare formal parameters&quot; },
<i>200</i>&nbsp;            { &quot;compiler.err.intf.annotation.members.cant.have.type.params&quot;, &quot;elements in annotation type declarations cannot be generic methods&quot; },
<i>201</i>&nbsp;            { &quot;compiler.err.intf.expected.here&quot;, &quot;interface expected here&quot; },
<i>202</i>&nbsp;            { &quot;compiler.err.intf.meth.cant.have.body&quot;, &quot;interface abstract methods cannot have body&quot; },
<i>203</i>&nbsp;            { &quot;compiler.err.intf.not.allowed.here&quot;, &quot;interface not allowed here&quot; },
<i>204</i>&nbsp;            { &quot;compiler.err.invalid.A.key&quot;, &quot;key in annotation processor option &#39;&#39;{0}&#39;&#39; is not a dot-separated sequence of identifiers&quot; },
<i>205</i>&nbsp;            { &quot;compiler.err.invalid.annotation.member.type&quot;, &quot;invalid type for annotation type element&quot; },
<i>206</i>&nbsp;            { &quot;compiler.err.invalid.binary.number&quot;, &quot;binary numbers must contain at least one binary digit&quot; },
<i>207</i>&nbsp;            { &quot;compiler.err.invalid.flag&quot;, &quot;invalid flag: {0}&quot; },
<i>208</i>&nbsp;            { &quot;compiler.err.invalid.hex.number&quot;, &quot;hexadecimal numbers must contain at least one hexadecimal digit&quot; },
<i>209</i>&nbsp;            { &quot;compiler.err.invalid.lambda.parameter.declaration&quot;, &quot;invalid lambda parameter declaration\n({0})&quot; },
<i>210</i>&nbsp;            { &quot;compiler.err.invalid.meth.decl.ret.type.req&quot;, &quot;invalid method declaration; return type required&quot; },
<i>211</i>&nbsp;            { &quot;compiler.err.invalid.module.directive&quot;, &quot;module directive keyword or &#39;&#39;}&#39;&#39; expected&quot; },
<i>212</i>&nbsp;            { &quot;compiler.err.invalid.module.specifier&quot;, &quot;module specifier not allowed: {0}&quot; },
<i>213</i>&nbsp;            { &quot;compiler.err.invalid.mref&quot;, &quot;invalid {0} reference\n{1}&quot; },
<i>214</i>&nbsp;            { &quot;compiler.err.invalid.profile&quot;, &quot;invalid profile: {0}&quot; },
<i>215</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation&quot;, &quot;duplicate annotation: {0} is annotated with an invalid @Repeatable annotation&quot; },
<i>216</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.elem.nondefault&quot;, &quot;containing annotation type ({0}) does not have a default value for element {1}&quot; },
<i>217</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.incompatible.target&quot;, &quot;containing annotation type ({0}) is applicable to more targets than repeatable annotation type ({1})&quot; },
<i>218</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.invalid.value&quot;, &quot;{0} is not a valid @Repeatable: invalid value element&quot; },
<i>219</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.multiple.values&quot;, &quot;{0} is not a valid @Repeatable, {1} element methods named &#39;&#39;value&#39;&#39; declared&quot; },
<i>220</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.no.value&quot;, &quot;{0} is not a valid @Repeatable, no value element method declared&quot; },
<i>221</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.not.applicable&quot;, &quot;container {0} is not applicable to element {1}&quot; },
<i>222</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.not.applicable.in.context&quot;, &quot;container {0} is not applicable in this type context&quot; },
<i>223</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.not.documented&quot;, &quot;repeatable annotation type ({1}) is @Documented while containing annotation type ({0}) is not&quot; },
<i>224</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.not.inherited&quot;, &quot;repeatable annotation type ({1}) is @Inherited while containing annotation type ({0}) is not&quot; },
<i>225</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.repeated.and.container.present&quot;, &quot;container {0} must not be present at the same time as the element it contains&quot; },
<i>226</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.retention&quot;, &quot;retention of containing annotation type ({0}) is shorter than the retention of repeatable annotation type ({2})&quot; },
<i>227</i>&nbsp;            { &quot;compiler.err.invalid.repeatable.annotation.value.return&quot;, &quot;containing annotation type ({0}) must declare an element named &#39;&#39;value&#39;&#39; of type {2}&quot; },
<i>228</i>&nbsp;            { &quot;compiler.err.invalid.source&quot;, &quot;invalid source release: {0}&quot; },
<i>229</i>&nbsp;            { &quot;compiler.err.invalid.target&quot;, &quot;invalid target release: {0}&quot; },
<i>230</i>&nbsp;            { &quot;compiler.err.io.exception&quot;, &quot;error reading source file: {0}&quot; },
<i>231</i>&nbsp;            { &quot;compiler.err.label.already.in.use&quot;, &quot;label {0} already in use&quot; },
<i>232</i>&nbsp;            { &quot;compiler.err.lambda.body.neither.value.nor.void.compatible&quot;, &quot;lambda body is neither value nor void compatible&quot; },
<i>233</i>&nbsp;            { &quot;compiler.err.limit.code&quot;, &quot;code too large&quot; },
<i>234</i>&nbsp;            { &quot;compiler.err.limit.code.too.large.for.try.stmt&quot;, &quot;code too large for try statement&quot; },
<i>235</i>&nbsp;            { &quot;compiler.err.limit.dimensions&quot;, &quot;array type has too many dimensions&quot; },
<i>236</i>&nbsp;            { &quot;compiler.err.limit.locals&quot;, &quot;too many local variables&quot; },
<i>237</i>&nbsp;            { &quot;compiler.err.limit.parameters&quot;, &quot;too many parameters&quot; },
<i>238</i>&nbsp;            { &quot;compiler.err.limit.pool&quot;, &quot;too many constants&quot; },
<i>239</i>&nbsp;            { &quot;compiler.err.limit.pool.in.class&quot;, &quot;too many constants in class {0}&quot; },
<i>240</i>&nbsp;            { &quot;compiler.err.limit.stack&quot;, &quot;code requires too much stack&quot; },
<i>241</i>&nbsp;            { &quot;compiler.err.limit.string&quot;, &quot;constant string too long&quot; },
<i>242</i>&nbsp;            { &quot;compiler.err.limit.string.overflow&quot;, &quot;UTF8 representation for string \&quot;{0}...\&quot; is too long for the constant pool&quot; },
<i>243</i>&nbsp;            { &quot;compiler.err.local.enum&quot;, &quot;enum types must not be local&quot; },
<i>244</i>&nbsp;            { &quot;compiler.err.local.var.accessed.from.icls.needs.final&quot;, &quot;local variable {0} is accessed from within inner class; needs to be declared final&quot; },
<i>245</i>&nbsp;            { &quot;compiler.err.locn.bad.module-info&quot;, &quot;problem reading module-info.class in {0}&quot; },
<i>246</i>&nbsp;            { &quot;compiler.err.locn.cant.get.module.name.for.jar&quot;, &quot;cannot determine module name for {0}&quot; },
<i>247</i>&nbsp;            { &quot;compiler.err.locn.cant.read.directory&quot;, &quot;cannot read directory {0}&quot; },
<i>248</i>&nbsp;            { &quot;compiler.err.locn.cant.read.file&quot;, &quot;cannot read file {0}&quot; },
<i>249</i>&nbsp;            { &quot;compiler.err.locn.invalid.arg.for.xpatch&quot;, &quot;invalid argument for --patch-module option: {0}&quot; },
<i>250</i>&nbsp;            { &quot;compiler.err.locn.module-info.not.allowed.on.patch.path&quot;, &quot;module-info.class not allowed on patch path: {0}&quot; },
<i>251</i>&nbsp;            { &quot;compiler.err.malformed.fp.lit&quot;, &quot;malformed floating point literal&quot; },
<i>252</i>&nbsp;            { &quot;compiler.err.method.does.not.override.superclass&quot;, &quot;method does not override or implement a method from a supertype&quot; },
<i>253</i>&nbsp;            { &quot;compiler.err.missing.meth.body.or.decl.abstract&quot;, &quot;missing method body, or declare abstract&quot; },
<i>254</i>&nbsp;            { &quot;compiler.err.missing.ret.stmt&quot;, &quot;missing return statement&quot; },
<i>255</i>&nbsp;            { &quot;compiler.err.mod.not.allowed.here&quot;, &quot;modifier {0} not allowed here&quot; },
<i>256</i>&nbsp;            { &quot;compiler.err.modifier.not.allowed.here&quot;, &quot;modifier {0} not allowed here&quot; },
<i>257</i>&nbsp;            { &quot;compiler.err.module.decl.sb.in.module-info.java&quot;, &quot;module declarations should be in a file named module-info.java&quot; },
<i>258</i>&nbsp;            { &quot;compiler.err.module.name.mismatch&quot;, &quot;module name {0} does not match expected name {1}&quot; },
<i>259</i>&nbsp;            { &quot;compiler.err.module.non.zero.opens&quot;, &quot;open module {0} has non-zero opens_count&quot; },
<i>260</i>&nbsp;            { &quot;compiler.err.module.not.found&quot;, &quot;module not found: {0}&quot; },
<i>261</i>&nbsp;            { &quot;compiler.err.module.not.found.in.module.source.path&quot;, &quot;module {0} not found in module source path&quot; },
<i>262</i>&nbsp;            { &quot;compiler.err.module.not.found.on.module.source.path&quot;, &quot;module not found on module source path&quot; },
<i>263</i>&nbsp;            { &quot;compiler.err.modulesourcepath.must.be.specified.with.dash.m.option&quot;, &quot;module source path must be specified if -m option is used&quot; },
<i>264</i>&nbsp;            { &quot;compiler.err.multi-module.outdir.cannot.be.exploded.module&quot;, &quot;in multi-module mode, the output directory cannot be an exploded module: {0}&quot; },
<i>265</i>&nbsp;            { &quot;compiler.err.multicatch.parameter.may.not.be.assigned&quot;, &quot;multi-catch parameter {0} may not be assigned&quot; },
<i>266</i>&nbsp;            { &quot;compiler.err.multicatch.types.must.be.disjoint&quot;, &quot;Alternatives in a multi-catch statement cannot be related by subclassing\nAlternative {0} is a subclass of alternative {1}&quot; },
<i>267</i>&nbsp;            { &quot;compiler.err.name.clash.same.erasure&quot;, &quot;name clash: {0} and {1} have the same erasure&quot; },
<i>268</i>&nbsp;            { &quot;compiler.err.name.clash.same.erasure.no.hide&quot;, &quot;name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither hides the other&quot; },
<i>269</i>&nbsp;            { &quot;compiler.err.name.clash.same.erasure.no.override&quot;, &quot;name clash: {0}({1}) in {2} and {3}({4}) in {5} have the same erasure, yet neither overrides the other&quot; },
<i>270</i>&nbsp;            { &quot;compiler.err.name.clash.same.erasure.no.override.1&quot;, &quot;name clash: {0} {1} has two methods with the same erasure, yet neither overrides the other\nfirst method:  {2}({3}) in {4}\nsecond method: {5}({6}) in {7}&quot; },
<i>271</i>&nbsp;            { &quot;compiler.err.name.reserved.for.internal.use&quot;, &quot;{0} is reserved for internal use&quot; },
<i>272</i>&nbsp;            { &quot;compiler.err.native.meth.cant.have.body&quot;, &quot;native methods cannot have a body&quot; },
<i>273</i>&nbsp;            { &quot;compiler.err.neither.conditional.subtype&quot;, &quot;incompatible types for ?: neither is a subtype of the other\nsecond operand: {0}\nthird operand : {1}&quot; },
<i>274</i>&nbsp;            { &quot;compiler.err.new.not.allowed.in.annotation&quot;, &quot;&#39;&#39;new&#39;&#39; not allowed in an annotation&quot; },
<i>275</i>&nbsp;            { &quot;compiler.err.no.annotation.member&quot;, &quot;no annotation member {0} in {1}&quot; },
<i>276</i>&nbsp;            { &quot;compiler.err.no.annotations.on.dot.class&quot;, &quot;no annotations are allowed in the type of a class literal&quot; },
<i>277</i>&nbsp;            { &quot;compiler.err.no.encl.instance.of.type.in.scope&quot;, &quot;no enclosing instance of type {0} is in scope&quot; },
<i>278</i>&nbsp;            { &quot;compiler.err.no.intf.expected.here&quot;, &quot;no interface expected here&quot; },
<i>279</i>&nbsp;            { &quot;compiler.err.no.match.entry&quot;, &quot;{0} has no match in entry in {1}; required {2}&quot; },
<i>280</i>&nbsp;            { &quot;compiler.err.no.opens.unless.strong&quot;, &quot;&#39;&#39;opens&#39;&#39; only allowed in strong modules&quot; },
<i>281</i>&nbsp;            { &quot;compiler.err.no.output.dir&quot;, &quot;no class output directory specified&quot; },
<i>282</i>&nbsp;            { &quot;compiler.err.no.pkg.in.module-info.java&quot;, &quot;package declarations not allowed in file module-info.java&quot; },
<i>283</i>&nbsp;            { &quot;compiler.err.no.source.files&quot;, &quot;no source files&quot; },
<i>284</i>&nbsp;            { &quot;compiler.err.no.source.files.classes&quot;, &quot;no source files or class names&quot; },
<i>285</i>&nbsp;            { &quot;compiler.err.no.superclass&quot;, &quot;{0} has no superclass.&quot; },
<i>286</i>&nbsp;            { &quot;compiler.err.no.value.for.option&quot;, &quot;no value for {0} option&quot; },
<i>287</i>&nbsp;            { &quot;compiler.err.no.zipfs.for.archive&quot;, &quot;No file system provider is available to handle this file: {0}&quot; },
<i>288</i>&nbsp;            { &quot;compiler.err.non-static.cant.be.ref&quot;, &quot;non-static {0} {1} cannot be referenced from a static context&quot; },
<i>289</i>&nbsp;            { &quot;compiler.err.not.annotation.type&quot;, &quot;{0} is not an annotation type&quot; },
<i>290</i>&nbsp;            { &quot;compiler.err.not.def.access.class.intf.cant.access&quot;, &quot;{1}.{0} is defined in an inaccessible class or interface&quot; },
<i>291</i>&nbsp;            { &quot;compiler.err.not.def.access.class.intf.cant.access.reason&quot;, &quot;{1}.{0} in package {2} is not accessible\n({3})&quot; },
<i>292</i>&nbsp;            { &quot;compiler.err.not.def.access.package.cant.access&quot;, &quot;{0} is not visible\n({2})&quot; },
<i>293</i>&nbsp;            { &quot;compiler.err.not.def.public&quot;, &quot;{0} is not public in {1}&quot; },
<i>294</i>&nbsp;            { &quot;compiler.err.not.def.public.cant.access&quot;, &quot;{0} is not public in {1}; cannot be accessed from outside package&quot; },
<i>295</i>&nbsp;            { &quot;compiler.err.not.encl.class&quot;, &quot;not an enclosing class: {0}&quot; },
<i>296</i>&nbsp;            { &quot;compiler.err.not.in.module.on.module.source.path&quot;, &quot;not in a module on the module source path&quot; },
<i>297</i>&nbsp;            { &quot;compiler.err.not.in.profile&quot;, &quot;{0} is not available in profile &#39;&#39;{1}&#39;&#39;&quot; },
<i>298</i>&nbsp;            { &quot;compiler.err.not.loop.label&quot;, &quot;not a loop label: {0}&quot; },
<i>299</i>&nbsp;            { &quot;compiler.err.not.stmt&quot;, &quot;not a statement&quot; },
<i>300</i>&nbsp;            { &quot;compiler.err.not.within.bounds&quot;, &quot;type argument {0} is not within bounds of type-variable {1}&quot; },
<i>301</i>&nbsp;            { &quot;compiler.err.operator.cant.be.applied&quot;, &quot;bad operand type {1} for unary operator &#39;&#39;{0}&#39;&#39;&quot; },
<i>302</i>&nbsp;            { &quot;compiler.err.operator.cant.be.applied.1&quot;, &quot;bad operand types for binary operator &#39;&#39;{0}&#39;&#39;\nfirst type:  {1}\nsecond type: {2}&quot; },
<i>303</i>&nbsp;            { &quot;compiler.err.option.not.allowed.with.target&quot;, &quot;option {0} not allowed with target {1}&quot; },
<i>304</i>&nbsp;            { &quot;compiler.err.option.removed.source&quot;, &quot;Source option {0} is no longer supported. Use {1} or later.&quot; },
<i>305</i>&nbsp;            { &quot;compiler.err.option.removed.target&quot;, &quot;Target option {0} is no longer supported. Use {1} or later.&quot; },
<i>306</i>&nbsp;            { &quot;compiler.err.option.too.many&quot;, &quot;option {0} can only be specified once&quot; },
<i>307</i>&nbsp;            { &quot;compiler.err.orphaned&quot;, &quot;orphaned {0}&quot; },
<i>308</i>&nbsp;            { &quot;compiler.err.output.dir.must.be.specified.with.dash.m.option&quot;, &quot;class output directory must be specified if -m option is used&quot; },
<i>309</i>&nbsp;            { &quot;compiler.err.override.incompatible.ret&quot;, &quot;{0}\nreturn type {1} is not compatible with {2}&quot; },
<i>310</i>&nbsp;            { &quot;compiler.err.override.meth&quot;, &quot;{0}\noverridden method is {1}&quot; },
<i>311</i>&nbsp;            { &quot;compiler.err.override.meth.doesnt.throw&quot;, &quot;{0}\noverridden method does not throw {1}&quot; },
<i>312</i>&nbsp;            { &quot;compiler.err.override.static&quot;, &quot;{0}\noverriding method is static&quot; },
<i>313</i>&nbsp;            { &quot;compiler.err.override.weaker.access&quot;, &quot;{0}\nattempting to assign weaker access privileges; was {1}&quot; },
<i>314</i>&nbsp;            { &quot;compiler.err.package.clash.from.requires&quot;, &quot;module {0} reads package {1} from both {2} and {3}&quot; },
<i>315</i>&nbsp;            { &quot;compiler.err.package.clash.from.requires.in.unnamed&quot;, &quot;the unnamed module reads package {0} from both {1} and {2}&quot; },
<i>316</i>&nbsp;            { &quot;compiler.err.package.empty.or.not.found&quot;, &quot;package is empty or does not exist: {0}&quot; },
<i>317</i>&nbsp;            { &quot;compiler.err.package.in.other.module&quot;, &quot;package exists in another module: {0}&quot; },
<i>318</i>&nbsp;            { &quot;compiler.err.package.not.visible&quot;, &quot;package {0} is not visible\n({1})&quot; },
<i>319</i>&nbsp;            { &quot;compiler.err.pkg.annotations.sb.in.package-info.java&quot;, &quot;package annotations should be in file package-info.java&quot; },
<i>320</i>&nbsp;            { &quot;compiler.err.pkg.clashes.with.class.of.same.name&quot;, &quot;package {0} clashes with class of same name&quot; },
<i>321</i>&nbsp;            { &quot;compiler.err.plugin.not.found&quot;, &quot;plug-in not found: {0}&quot; },
<i>322</i>&nbsp;            { &quot;compiler.err.premature.eof&quot;, &quot;reached end of file while parsing&quot; },
<i>323</i>&nbsp;            { &quot;compiler.err.preview.feature.disabled&quot;, &quot;{0} is a preview feature and is disabled by default.\n(use --enable-preview to enable {0})&quot; },
<i>324</i>&nbsp;            { &quot;compiler.err.preview.feature.disabled.classfile&quot;, &quot;classfile for {0} uses preview features of Java SE {1}.\n(use --enable-preview to allow loading of classfiles which contain preview features)&quot; },
<i>325</i>&nbsp;            { &quot;compiler.err.preview.feature.disabled.plural&quot;, &quot;{0} are a preview feature and are disabled by default.\n(use --enable-preview to enable {0})&quot; },
<i>326</i>&nbsp;            { &quot;compiler.err.preview.not.latest&quot;, &quot;invalid source release {0} with --enable-preview\n(preview language features are only supported for release {1})&quot; },
<i>327</i>&nbsp;            { &quot;compiler.err.preview.without.source.or.release&quot;, &quot;--enable-preview must be used with either -source or --release&quot; },
<i>328</i>&nbsp;            { &quot;compiler.err.prob.found.req&quot;, &quot;incompatible types: {0}&quot; },
<i>329</i>&nbsp;            { &quot;compiler.err.proc.bad.config.file&quot;, &quot;Bad service configuration file, or exception thrown while constructing Processor object: {0}&quot; },
<i>330</i>&nbsp;            { &quot;compiler.err.proc.cant.access&quot;, &quot;cannot access {0}\n{1}\nConsult the following stack trace for details.\n{2}&quot; },
<i>331</i>&nbsp;            { &quot;compiler.err.proc.cant.access.1&quot;, &quot;cannot access {0}\n{1}&quot; },
<i>332</i>&nbsp;            { &quot;compiler.err.proc.cant.create.loader&quot;, &quot;Could not create class loader for annotation processors: {0}&quot; },
<i>333</i>&nbsp;            { &quot;compiler.err.proc.cant.find.class&quot;, &quot;Could not find class file for &#39;&#39;{0}&#39;&#39;.&quot; },
<i>334</i>&nbsp;            { &quot;compiler.err.proc.messager&quot;, &quot;{0}&quot; },
<i>335</i>&nbsp;            { &quot;compiler.err.proc.no.explicit.annotation.processing.requested&quot;, &quot;Class names, &#39;&#39;{0}&#39;&#39;, are only accepted if annotation processing is explicitly requested&quot; },
<i>336</i>&nbsp;            { &quot;compiler.err.proc.no.service&quot;, &quot;A ServiceLoader was not usable and is required for annotation processing.&quot; },
<i>337</i>&nbsp;            { &quot;compiler.err.proc.processor.bad.option.name&quot;, &quot;Bad option name &#39;&#39;{0}&#39;&#39; provided by processor &#39;&#39;{1}&#39;&#39;&quot; },
<i>338</i>&nbsp;            { &quot;compiler.err.proc.processor.cant.instantiate&quot;, &quot;Could not instantiate an instance of processor &#39;&#39;{0}&#39;&#39;&quot; },
<i>339</i>&nbsp;            { &quot;compiler.err.proc.processor.not.found&quot;, &quot;Annotation processor &#39;&#39;{0}&#39;&#39; not found&quot; },
<i>340</i>&nbsp;            { &quot;compiler.err.proc.processor.wrong.type&quot;, &quot;Annotation processor &#39;&#39;{0}&#39;&#39; does not implement javax.annotation.processing.Processor&quot; },
<i>341</i>&nbsp;            { &quot;compiler.err.proc.service.problem&quot;, &quot;Error creating a service loader to load Processors.&quot; },
<i>342</i>&nbsp;            { &quot;compiler.err.processorpath.no.processormodulepath&quot;, &quot;illegal combination of -processorpath and --processor-module-path&quot; },
<i>343</i>&nbsp;            { &quot;compiler.err.profile.bootclasspath.conflict&quot;, &quot;profile and bootclasspath options cannot be used together&quot; },
<i>344</i>&nbsp;            { &quot;compiler.err.qualified.new.of.static.class&quot;, &quot;qualified new of static class&quot; },
<i>345</i>&nbsp;            { &quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;, &quot;receiver parameter not applicable for constructor of top-level class&quot; },
<i>346</i>&nbsp;            { &quot;compiler.err.recursive.ctor.invocation&quot;, &quot;recursive constructor invocation&quot; },
<i>347</i>&nbsp;            { &quot;compiler.err.ref.ambiguous&quot;, &quot;reference to {0} is ambiguous\nboth {1} {2} in {3} and {4} {5} in {6} match&quot; },
<i>348</i>&nbsp;            { &quot;compiler.err.release.bootclasspath.conflict&quot;, &quot;option {0} cannot be used together with --release&quot; },
<i>349</i>&nbsp;            { &quot;compiler.err.repeated.annotation.target&quot;, &quot;repeated annotation target&quot; },
<i>350</i>&nbsp;            { &quot;compiler.err.repeated.interface&quot;, &quot;repeated interface&quot; },
<i>351</i>&nbsp;            { &quot;compiler.err.repeated.modifier&quot;, &quot;repeated modifier&quot; },
<i>352</i>&nbsp;            { &quot;compiler.err.repeated.provides.for.service&quot;, &quot;multiple &#39;&#39;provides&#39;&#39; for service {0}&quot; },
<i>353</i>&nbsp;            { &quot;compiler.err.repeated.value.for.patch.module&quot;, &quot;--patch-module specified more than once for {0}&quot; },
<i>354</i>&nbsp;            { &quot;compiler.err.report.access&quot;, &quot;{0} has {1} access in {2}&quot; },
<i>355</i>&nbsp;            { &quot;compiler.err.req.arg&quot;, &quot;{0} requires an argument&quot; },
<i>356</i>&nbsp;            { &quot;compiler.err.ret.outside.meth&quot;, &quot;return outside method&quot; },
<i>357</i>&nbsp;            { &quot;compiler.err.same.binary.name&quot;, &quot;classes: {0} and {1} have the same binary name&quot; },
<i>358</i>&nbsp;            { &quot;compiler.err.service.definition.is.enum&quot;, &quot;the service definition is an enum: {0}&quot; },
<i>359</i>&nbsp;            { &quot;compiler.err.service.implementation.doesnt.have.a.no.args.constructor&quot;, &quot;the service implementation does not have a default constructor: {0}&quot; },
<i>360</i>&nbsp;            { &quot;compiler.err.service.implementation.is.abstract&quot;, &quot;the service implementation is an abstract class: {0}&quot; },
<i>361</i>&nbsp;            { &quot;compiler.err.service.implementation.is.inner&quot;, &quot;the service implementation is an inner class: {0}&quot; },
<i>362</i>&nbsp;            { &quot;compiler.err.service.implementation.must.be.subtype.of.service.interface&quot;, &quot;the service implementation type must be a subtype of the service interface type, or have a public static no-args method named \&quot;provider\&quot; returning the service implementation&quot; },
<i>363</i>&nbsp;            { &quot;compiler.err.service.implementation.no.args.constructor.not.public&quot;, &quot;the no arguments constructor of the service implementation is not public: {0}&quot; },
<i>364</i>&nbsp;            { &quot;compiler.err.service.implementation.not.in.right.module&quot;, &quot;service implementation must be defined in the same module as the provides directive&quot; },
<i>365</i>&nbsp;            { &quot;compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface&quot;, &quot;the \&quot;provider\&quot; method return type must be a subtype of the service interface type&quot; },
<i>366</i>&nbsp;            { &quot;compiler.err.signature.doesnt.match.intf&quot;, &quot;signature does not match {0}; incompatible interfaces&quot; },
<i>367</i>&nbsp;            { &quot;compiler.err.signature.doesnt.match.supertype&quot;, &quot;signature does not match {0}; incompatible supertype&quot; },
<i>368</i>&nbsp;            { &quot;compiler.err.source.cant.overwrite.input.file&quot;, &quot;error writing source; cannot overwrite input file {0}&quot; },
<i>369</i>&nbsp;            { &quot;compiler.err.sourcepath.modulesourcepath.conflict&quot;, &quot;cannot specify both --source-path and --module-source-path&quot; },
<i>370</i>&nbsp;            { &quot;compiler.err.stack.sim.error&quot;, &quot;Internal error: stack sim error on {0}&quot; },
<i>371</i>&nbsp;            { &quot;compiler.err.static.imp.only.classes.and.interfaces&quot;, &quot;static import only from classes and interfaces&quot; },
<i>372</i>&nbsp;            { &quot;compiler.err.static.methods.cannot.be.annotated.with.override&quot;, &quot;static methods cannot be annotated with @Override&quot; },
<i>373</i>&nbsp;            { &quot;compiler.err.string.const.req&quot;, &quot;constant string expression required&quot; },
<i>374</i>&nbsp;            { &quot;compiler.err.this.as.identifier&quot;, &quot;as of release 8, &#39;&#39;this&#39;&#39; is allowed as the parameter name for the receiver type only\nwhich has to be the first parameter, and cannot be a lambda parameter&quot; },
<i>375</i>&nbsp;            { &quot;compiler.err.throws.not.allowed.in.intf.annotation&quot;, &quot;throws clause not allowed in @interface members&quot; },
<i>376</i>&nbsp;            { &quot;compiler.err.too.many.modules&quot;, &quot;too many module declarations found&quot; },
<i>377</i>&nbsp;            { &quot;compiler.err.too.many.patched.modules&quot;, &quot;too many patched modules ({0}), use --module-source-path&quot; },
<i>378</i>&nbsp;            { &quot;compiler.err.try.resource.may.not.be.assigned&quot;, &quot;auto-closeable resource {0} may not be assigned&quot; },
<i>379</i>&nbsp;            { &quot;compiler.err.try.with.resources.expr.effectively.final.var&quot;, &quot;variable {0} used as a try-with-resources resource neither final nor effectively final&quot; },
<i>380</i>&nbsp;            { &quot;compiler.err.try.with.resources.expr.needs.var&quot;, &quot;the try-with-resources resource must either be a variable declaration or an expression denoting a reference to a final or effectively final variable&quot; },
<i>381</i>&nbsp;            { &quot;compiler.err.try.without.catch.finally.or.resource.decls&quot;, &quot;&#39;&#39;try&#39;&#39; without &#39;&#39;catch&#39;&#39;, &#39;&#39;finally&#39;&#39; or resource declarations&quot; },
<i>382</i>&nbsp;            { &quot;compiler.err.try.without.catch.or.finally&quot;, &quot;&#39;&#39;try&#39;&#39; without &#39;&#39;catch&#39;&#39; or &#39;&#39;finally&#39;&#39;&quot; },
<i>383</i>&nbsp;            { &quot;compiler.err.two.class.loaders.1&quot;, &quot;javac is split between multiple class loaders: check your configuration&quot; },
<i>384</i>&nbsp;            { &quot;compiler.err.two.class.loaders.2&quot;, &quot;javac is split between multiple class loaders:\none class comes from file: {0}\nwhile javac comes from {1}&quot; },
<i>385</i>&nbsp;            { &quot;compiler.err.type.doesnt.take.params&quot;, &quot;type {0} does not take parameters&quot; },
<i>386</i>&nbsp;            { &quot;compiler.err.type.found.req&quot;, &quot;unexpected type\nrequired: {1}\nfound:    {0}&quot; },
<i>387</i>&nbsp;            { &quot;compiler.err.type.var.cant.be.deref&quot;, &quot;cannot select from a type variable&quot; },
<i>388</i>&nbsp;            { &quot;compiler.err.type.var.may.not.be.followed.by.other.bounds&quot;, &quot;a type variable may not be followed by other bounds&quot; },
<i>389</i>&nbsp;            { &quot;compiler.err.type.var.more.than.once&quot;, &quot;type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated&quot; },
<i>390</i>&nbsp;            { &quot;compiler.err.type.var.more.than.once.in.result&quot;, &quot;type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated&quot; },
<i>391</i>&nbsp;            { &quot;compiler.err.types.incompatible&quot;, &quot;types {0} and {1} are incompatible;\n{2}&quot; },
<i>392</i>&nbsp;            { &quot;compiler.err.unclosed.char.lit&quot;, &quot;unclosed character literal&quot; },
<i>393</i>&nbsp;            { &quot;compiler.err.unclosed.comment&quot;, &quot;unclosed comment&quot; },
<i>394</i>&nbsp;            { &quot;compiler.err.unclosed.str.lit&quot;, &quot;unclosed string literal&quot; },
<i>395</i>&nbsp;            { &quot;compiler.err.undef.label&quot;, &quot;undefined label: {0}&quot; },
<i>396</i>&nbsp;            { &quot;compiler.err.underscore.as.identifier&quot;, &quot;as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier&quot; },
<i>397</i>&nbsp;            { &quot;compiler.err.underscore.as.identifier.in.lambda&quot;, &quot;&#39;&#39;_&#39;&#39; used as an identifier\n(use of &#39;&#39;_&#39;&#39; as an identifier is forbidden for lambda parameters)&quot; },
<i>398</i>&nbsp;            { &quot;compiler.err.unexpected.lambda&quot;, &quot;lambda expression not expected here&quot; },
<i>399</i>&nbsp;            { &quot;compiler.err.unexpected.mref&quot;, &quot;method reference not expected here&quot; },
<i>400</i>&nbsp;            { &quot;compiler.err.unexpected.type&quot;, &quot;unexpected type\nrequired: {0}\nfound:    {1}&quot; },
<i>401</i>&nbsp;            { &quot;compiler.err.unmatched.quote&quot;, &quot;unmatched quote in environment variable {0}&quot; },
<i>402</i>&nbsp;            { &quot;compiler.err.unnamed.pkg.not.allowed.named.modules&quot;, &quot;unnamed package is not allowed in named modules&quot; },
<i>403</i>&nbsp;            { &quot;compiler.err.unreachable.stmt&quot;, &quot;unreachable statement&quot; },
<i>404</i>&nbsp;            { &quot;compiler.err.unreported.exception.default.constructor&quot;, &quot;unreported exception {0} in default constructor&quot; },
<i>405</i>&nbsp;            { &quot;compiler.err.unreported.exception.implicit.close&quot;, &quot;unreported exception {0}; must be caught or declared to be thrown\nexception thrown from implicit call to close() on resource variable &#39;&#39;{1}&#39;&#39;&quot; },
<i>406</i>&nbsp;            { &quot;compiler.err.unreported.exception.need.to.catch.or.throw&quot;, &quot;unreported exception {0}; must be caught or declared to be thrown&quot; },
<i>407</i>&nbsp;            { &quot;compiler.err.unsupported.cross.fp.lit&quot;, &quot;hexadecimal floating-point literals are not supported on this VM&quot; },
<i>408</i>&nbsp;            { &quot;compiler.err.unsupported.encoding&quot;, &quot;unsupported encoding: {0}&quot; },
<i>409</i>&nbsp;            { &quot;compiler.err.unsupported.release.version&quot;, &quot;release version {0} not supported&quot; },
<i>410</i>&nbsp;            { &quot;compiler.err.var.might.already.be.assigned&quot;, &quot;variable {0} might already have been assigned&quot; },
<i>411</i>&nbsp;            { &quot;compiler.err.var.might.be.assigned.in.loop&quot;, &quot;variable {0} might be assigned in loop&quot; },
<i>412</i>&nbsp;            { &quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;variable {0} might not have been initialized&quot; },
<i>413</i>&nbsp;            { &quot;compiler.err.var.not.allowed&quot;, &quot;&#39;&#39;var&#39;&#39; not allowed here\nas of release 10, &#39;&#39;var&#39;&#39; is a restricted local variable type and cannot be used for type declarations&quot; },
<i>414</i>&nbsp;            { &quot;compiler.err.var.not.allowed.array&quot;, &quot;&#39;&#39;var&#39;&#39; is not allowed as an element type of an array&quot; },
<i>415</i>&nbsp;            { &quot;compiler.err.var.not.allowed.compound&quot;, &quot;&#39;&#39;var&#39;&#39; is not allowed in a compound declaration&quot; },
<i>416</i>&nbsp;            { &quot;compiler.err.var.not.allowed.here&quot;, &quot;&#39;&#39;var&#39;&#39; is not allowed here&quot; },
<i>417</i>&nbsp;            { &quot;compiler.err.var.not.initialized.in.default.constructor&quot;, &quot;variable {0} not initialized in the default constructor&quot; },
<i>418</i>&nbsp;            { &quot;compiler.err.varargs.and.old.array.syntax&quot;, &quot;legacy array notation not allowed on variable-arity parameter&quot; },
<i>419</i>&nbsp;            { &quot;compiler.err.varargs.and.receiver&quot;, &quot;varargs notation not allowed on receiver parameter&quot; },
<i>420</i>&nbsp;            { &quot;compiler.err.varargs.invalid.trustme.anno&quot;, &quot;Invalid {0} annotation. {1}&quot; },
<i>421</i>&nbsp;            { &quot;compiler.err.varargs.must.be.last&quot;, &quot;varargs parameter must be the last parameter&quot; },
<i>422</i>&nbsp;            { &quot;compiler.err.variable.not.allowed&quot;, &quot;variable declaration not allowed here&quot; },
<i>423</i>&nbsp;            { &quot;compiler.err.void.not.allowed.here&quot;, &quot;&#39;&#39;void&#39;&#39; type not allowed here&quot; },
<i>424</i>&nbsp;            { &quot;compiler.err.warnings.and.werror&quot;, &quot;warnings found and -Werror specified&quot; },
<i>425</i>&nbsp;            { &quot;compiler.err.wrong.number.type.args&quot;, &quot;wrong number of type arguments; required {0}&quot; },
<i>426</i>&nbsp;            { &quot;compiler.err.wrong.receiver&quot;, &quot;wrong receiver parameter name&quot; },
<i>427</i>&nbsp;            { &quot;compiler.misc.anachronistic.module.info&quot;, &quot;module declaration found in version {0}.{1} classfile&quot; },
<i>428</i>&nbsp;            { &quot;compiler.misc.anonymous.class&quot;, &quot;&lt;anonymous {0}&gt;&quot; },
<i>429</i>&nbsp;            { &quot;compiler.misc.applicable.method.found&quot;, &quot;#{0} applicable method found: {1}&quot; },
<i>430</i>&nbsp;            { &quot;compiler.misc.applicable.method.found.1&quot;, &quot;#{0} applicable method found: {1}\n({2})&quot; },
<i>431</i>&nbsp;            { &quot;compiler.misc.arg.length.mismatch&quot;, &quot;actual and formal argument lists differ in length&quot; },
<i>432</i>&nbsp;            { &quot;compiler.misc.bad.class.file&quot;, &quot;class file is invalid for class {0}&quot; },
<i>433</i>&nbsp;            { &quot;compiler.misc.bad.class.file.header&quot;, &quot;bad class file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the classpath.&quot; },
<i>434</i>&nbsp;            { &quot;compiler.misc.bad.class.signature&quot;, &quot;bad class signature: {0}&quot; },
<i>435</i>&nbsp;            { &quot;compiler.misc.bad.const.pool.entry&quot;, &quot;bad constant pool entry in {0}\nexpected {1} at index {2}&quot; },
<i>436</i>&nbsp;            { &quot;compiler.misc.bad.const.pool.tag&quot;, &quot;bad constant pool tag: {0}&quot; },
<i>437</i>&nbsp;            { &quot;compiler.misc.bad.const.pool.tag.at&quot;, &quot;bad constant pool tag: {0} at {1}&quot; },
<i>438</i>&nbsp;            { &quot;compiler.misc.bad.constant.range&quot;, &quot;constant value &#39;&#39;{0}&#39;&#39; for {1} is outside the expected range for {2}&quot; },
<i>439</i>&nbsp;            { &quot;compiler.misc.bad.constant.value&quot;, &quot;bad constant value &#39;&#39;{0}&#39;&#39; for {1}, expected {2}&quot; },
<i>440</i>&nbsp;            { &quot;compiler.misc.bad.enclosing.class&quot;, &quot;bad enclosing class for {0}: {1}&quot; },
<i>441</i>&nbsp;            { &quot;compiler.misc.bad.enclosing.method&quot;, &quot;bad enclosing method attribute for class {0}&quot; },
<i>442</i>&nbsp;            { &quot;compiler.misc.bad.instance.method.in.unbound.lookup&quot;, &quot;unexpected instance {0} {1} found in unbound lookup&quot; },
<i>443</i>&nbsp;            { &quot;compiler.misc.bad.intersection.target.for.functional.expr&quot;, &quot;bad intersection type target for lambda or method reference\n{0}&quot; },
<i>444</i>&nbsp;            { &quot;compiler.misc.bad.module-info.name&quot;, &quot;bad class name&quot; },
<i>445</i>&nbsp;            { &quot;compiler.misc.bad.requires.flag&quot;, &quot;bad requires flag: {0}&quot; },
<i>446</i>&nbsp;            { &quot;compiler.misc.bad.runtime.invisible.param.annotations&quot;, &quot;bad RuntimeInvisibleParameterAnnotations attribute: {0}&quot; },
<i>447</i>&nbsp;            { &quot;compiler.misc.bad.signature&quot;, &quot;bad signature: {0}&quot; },
<i>448</i>&nbsp;            { &quot;compiler.misc.bad.source.file.header&quot;, &quot;bad source file: {0}\n{1}\nPlease remove or make sure it appears in the correct subdirectory of the sourcepath.&quot; },
<i>449</i>&nbsp;            { &quot;compiler.misc.bad.static.method.in.bound.lookup&quot;, &quot;unexpected static {0} {1} found in bound lookup&quot; },
<i>450</i>&nbsp;            { &quot;compiler.misc.bad.static.method.in.unbound.lookup&quot;, &quot;unexpected static {0} {1} found in unbound lookup&quot; },
<i>451</i>&nbsp;            { &quot;compiler.misc.bad.type.annotation.value&quot;, &quot;bad type annotation target type value: {0}&quot; },
<i>452</i>&nbsp;            { &quot;compiler.misc.base.membership&quot;, &quot;all your base class are belong to us&quot; },
<i>453</i>&nbsp;            { &quot;compiler.misc.cant.access.inner.cls.constr&quot;, &quot;cannot access constructor {0}({1})\nan enclosing instance of type {2} is not in scope&quot; },
<i>454</i>&nbsp;            { &quot;compiler.misc.cant.apply.diamond.1&quot;, &quot;cannot infer type arguments for {0}\nreason: {1}&quot; },
<i>455</i>&nbsp;            { &quot;compiler.misc.cant.apply.symbol&quot;, &quot;{0} {1} in {4} {5} cannot be applied to given types\nrequired: {2}\nfound: {3}\nreason: {6}&quot; },
<i>456</i>&nbsp;            { &quot;compiler.misc.cant.apply.symbols&quot;, &quot;no suitable {0} found for {1}({2})&quot; },
<i>457</i>&nbsp;            { &quot;compiler.misc.cant.hide&quot;, &quot;{0} in {1} cannot hide {2} in {3}&quot; },
<i>458</i>&nbsp;            { &quot;compiler.misc.cant.implement&quot;, &quot;{0} in {1} cannot implement {2} in {3}&quot; },
<i>459</i>&nbsp;            { &quot;compiler.misc.cant.override&quot;, &quot;{0} in {1} cannot override {2} in {3}&quot; },
<i>460</i>&nbsp;            { &quot;compiler.misc.cant.resolve.args&quot;, &quot;cannot find symbol\nsymbol: {0} {1}({3})&quot; },
<i>461</i>&nbsp;            { &quot;compiler.misc.cant.resolve.location.args&quot;, &quot;cannot find symbol\nsymbol:   {0} {1}({3})\nlocation: {4}&quot; },
<i>462</i>&nbsp;            { &quot;compiler.misc.cant.resolve.location.args.params&quot;, &quot;cannot find symbol\nsymbol:   {0} &lt;{2}&gt;{1}({3})\nlocation: {4}&quot; },
<i>463</i>&nbsp;            { &quot;compiler.misc.cant.resolve.modules&quot;, &quot;cannot resolve modules&quot; },
<i>464</i>&nbsp;            { &quot;compiler.misc.captured.type&quot;, &quot;CAP#{0}&quot; },
<i>465</i>&nbsp;            { &quot;compiler.misc.clashes.with&quot;, &quot;{0} in {1} clashes with {2} in {3}&quot; },
<i>466</i>&nbsp;            { &quot;compiler.misc.class.file.not.found&quot;, &quot;class file for {0} not found&quot; },
<i>467</i>&nbsp;            { &quot;compiler.misc.class.file.wrong.class&quot;, &quot;class file contains wrong class: {0}&quot; },
<i>468</i>&nbsp;            { &quot;compiler.misc.conditional.target.cant.be.void&quot;, &quot;target-type for conditional expression cannot be void&quot; },
<i>469</i>&nbsp;            { &quot;compiler.misc.count.error&quot;, &quot;{0} error&quot; },
<i>470</i>&nbsp;            { &quot;compiler.misc.count.error.plural&quot;, &quot;{0} errors&quot; },
<i>471</i>&nbsp;            { &quot;compiler.misc.count.warn&quot;, &quot;{0} warning&quot; },
<i>472</i>&nbsp;            { &quot;compiler.misc.count.warn.plural&quot;, &quot;{0} warnings&quot; },
<i>473</i>&nbsp;            { &quot;compiler.misc.descriptor&quot;, &quot;descriptor: {2} {0}({1})&quot; },
<i>474</i>&nbsp;            { &quot;compiler.misc.descriptor.throws&quot;, &quot;descriptor: {2} {0}({1}) throws {3}&quot; },
<i>475</i>&nbsp;            { &quot;compiler.misc.diamond&quot;, &quot;{0}&lt;&gt;&quot; },
<i>476</i>&nbsp;            { &quot;compiler.misc.diamond.and.explicit.params&quot;, &quot;cannot use &#39;&#39;&lt;&gt;&#39;&#39; with explicit type parameters for constructor&quot; },
<i>477</i>&nbsp;            { &quot;compiler.misc.diamond.anonymous.methods.implicitly.override&quot;, &quot;(due to &lt;&gt;, every non-private method declared in this anonymous class must override or implement a method from a supertype)&quot; },
<i>478</i>&nbsp;            { &quot;compiler.misc.diamond.invalid.arg&quot;, &quot;type argument {0} inferred for {1} is not allowed in this context\ninferred argument is not expressible in the Signature attribute&quot; },
<i>479</i>&nbsp;            { &quot;compiler.misc.diamond.invalid.args&quot;, &quot;type arguments {0} inferred for {1} are not allowed in this context\ninferred arguments are not expressible in the Signature attribute&quot; },
<i>480</i>&nbsp;            { &quot;compiler.misc.diamond.non.generic&quot;, &quot;cannot use &#39;&#39;&lt;&gt;&#39;&#39; with non-generic class {0}&quot; },
<i>481</i>&nbsp;            { &quot;compiler.misc.eq.bounds&quot;, &quot;equality constraints: {0}&quot; },
<i>482</i>&nbsp;            { &quot;compiler.misc.exception.message&quot;, &quot;{0}&quot; },
<i>483</i>&nbsp;            { &quot;compiler.misc.explicit.param.do.not.conform.to.bounds&quot;, &quot;explicit type argument {0} does not conform to declared bound(s) {1}&quot; },
<i>484</i>&nbsp;            { &quot;compiler.misc.fatal.err.cant.close&quot;, &quot;Fatal Error: Cannot close compiler resources&quot; },
<i>485</i>&nbsp;            { &quot;compiler.misc.fatal.err.cant.locate.ctor&quot;, &quot;Fatal Error: Unable to find constructor for {0}&quot; },
<i>486</i>&nbsp;            { &quot;compiler.misc.fatal.err.cant.locate.field&quot;, &quot;Fatal Error: Unable to find field {0}&quot; },
<i>487</i>&nbsp;            { &quot;compiler.misc.fatal.err.cant.locate.meth&quot;, &quot;Fatal Error: Unable to find method {0}&quot; },
<i>488</i>&nbsp;            { &quot;compiler.misc.fatal.err.no.java.lang&quot;, &quot;Fatal Error: Unable to find package java.lang in classpath or bootclasspath&quot; },
<i>489</i>&nbsp;            { &quot;compiler.misc.feature.annotations.after.type.params&quot;, &quot;annotations after method type parameters&quot; },
<i>490</i>&nbsp;            { &quot;compiler.misc.feature.binary.lit&quot;, &quot;binary literals&quot; },
<i>491</i>&nbsp;            { &quot;compiler.misc.feature.default.methods&quot;, &quot;default methods&quot; },
<i>492</i>&nbsp;            { &quot;compiler.misc.feature.diamond&quot;, &quot;diamond operator&quot; },
<i>493</i>&nbsp;            { &quot;compiler.misc.feature.diamond.and.anon.class&quot;, &quot;&#39;&#39;&lt;&gt;&#39;&#39; with anonymous inner classes&quot; },
<i>494</i>&nbsp;            { &quot;compiler.misc.feature.intersection.types.in.cast&quot;, &quot;intersection types&quot; },
<i>495</i>&nbsp;            { &quot;compiler.misc.feature.lambda&quot;, &quot;lambda expressions&quot; },
<i>496</i>&nbsp;            { &quot;compiler.misc.feature.method.references&quot;, &quot;method references&quot; },
<i>497</i>&nbsp;            { &quot;compiler.misc.feature.modules&quot;, &quot;modules&quot; },
<i>498</i>&nbsp;            { &quot;compiler.misc.feature.multicatch&quot;, &quot;multi-catch statements&quot; },
<i>499</i>&nbsp;            { &quot;compiler.misc.feature.not.supported.in.source&quot;, &quot;{0} is not supported in -source {1}\n(use -source {2} or higher to enable {0})&quot; },
<i>500</i>&nbsp;            { &quot;compiler.misc.feature.not.supported.in.source.plural&quot;, &quot;{0} are not supported in -source {1}\n(use -source {2} or higher to enable {0})&quot; },
<i>501</i>&nbsp;            { &quot;compiler.misc.feature.private.intf.methods&quot;, &quot;private interface methods&quot; },
<i>502</i>&nbsp;            { &quot;compiler.misc.feature.repeatable.annotations&quot;, &quot;repeated annotations&quot; },
<i>503</i>&nbsp;            { &quot;compiler.misc.feature.static.intf.method.invoke&quot;, &quot;static interface method invocations&quot; },
<i>504</i>&nbsp;            { &quot;compiler.misc.feature.static.intf.methods&quot;, &quot;static interface methods&quot; },
<i>505</i>&nbsp;            { &quot;compiler.misc.feature.string.switch&quot;, &quot;strings in switch&quot; },
<i>506</i>&nbsp;            { &quot;compiler.misc.feature.try.with.resources&quot;, &quot;try-with-resources&quot; },
<i>507</i>&nbsp;            { &quot;compiler.misc.feature.type.annotations&quot;, &quot;type annotations&quot; },
<i>508</i>&nbsp;            { &quot;compiler.misc.feature.underscore.lit&quot;, &quot;underscores in literals&quot; },
<i>509</i>&nbsp;            { &quot;compiler.misc.feature.var.in.try.with.resources&quot;, &quot;variables in try-with-resources&quot; },
<i>510</i>&nbsp;            { &quot;compiler.misc.file.does.not.contain.module&quot;, &quot;file does not contain module declaration&quot; },
<i>511</i>&nbsp;            { &quot;compiler.misc.file.does.not.contain.package&quot;, &quot;file does not contain package {0}&quot; },
<i>512</i>&nbsp;            { &quot;compiler.misc.file.doesnt.contain.class&quot;, &quot;file does not contain class {0}&quot; },
<i>513</i>&nbsp;            { &quot;compiler.misc.illegal.signature&quot;, &quot;illegal signature attribute for type {1}&quot; },
<i>514</i>&nbsp;            { &quot;compiler.misc.illegal.start.of.class.file&quot;, &quot;illegal start of class file&quot; },
<i>515</i>&nbsp;            { &quot;compiler.misc.implicit.and.explicit.not.allowed&quot;, &quot;cannot mix implicitly-typed and explicitly-typed parameters&quot; },
<i>516</i>&nbsp;            { &quot;compiler.misc.inaccessible.varargs.type&quot;, &quot;formal varargs element type {0} is not accessible from {1} {2}&quot; },
<i>517</i>&nbsp;            { &quot;compiler.misc.inapplicable.method&quot;, &quot;{0} {1}.{2} is not applicable\n({3})&quot; },
<i>518</i>&nbsp;            { &quot;compiler.misc.incompatible.abstract.default&quot;, &quot;{0} {1} inherits abstract and default for {2}({3}) from types {4} and {5}&quot; },
<i>519</i>&nbsp;            { &quot;compiler.misc.incompatible.abstracts&quot;, &quot;multiple non-overriding abstract methods found in {0} {1}&quot; },
<i>520</i>&nbsp;            { &quot;compiler.misc.incompatible.arg.types.in.lambda&quot;, &quot;incompatible parameter types in lambda expression&quot; },
<i>521</i>&nbsp;            { &quot;compiler.misc.incompatible.arg.types.in.mref&quot;, &quot;incompatible parameter types in method reference&quot; },
<i>522</i>&nbsp;            { &quot;compiler.misc.incompatible.bounds&quot;, &quot;inference variable {0} has incompatible bounds\n{1}\n{2}&quot; },
<i>523</i>&nbsp;            { &quot;compiler.misc.incompatible.descs.in.functional.intf&quot;, &quot;incompatible function descriptors found in {0} {1}&quot; },
<i>524</i>&nbsp;            { &quot;compiler.misc.incompatible.diff.ret&quot;, &quot;both define {0}({1}), but with unrelated return types&quot; },
<i>525</i>&nbsp;            { &quot;compiler.misc.incompatible.eq.bounds&quot;, &quot;inference variable {0} has incompatible equality constraints {1}&quot; },
<i>526</i>&nbsp;            { &quot;compiler.misc.incompatible.ret.type.in.lambda&quot;, &quot;bad return type in lambda expression\n{0}&quot; },
<i>527</i>&nbsp;            { &quot;compiler.misc.incompatible.ret.type.in.mref&quot;, &quot;bad return type in method reference\n{0}&quot; },
<i>528</i>&nbsp;            { &quot;compiler.misc.incompatible.type.in.conditional&quot;, &quot;bad type in conditional expression\n{0}&quot; },
<i>529</i>&nbsp;            { &quot;compiler.misc.incompatible.unrelated.defaults&quot;, &quot;{0} {1} inherits unrelated defaults for {2}({3}) from types {4} and {5}&quot; },
<i>530</i>&nbsp;            { &quot;compiler.misc.incompatible.upper.bounds&quot;, &quot;inference variable {0} has incompatible upper bounds {1}&quot; },
<i>531</i>&nbsp;            { &quot;compiler.misc.inconvertible.types&quot;, &quot;{0} cannot be converted to {1}&quot; },
<i>532</i>&nbsp;            { &quot;compiler.misc.infer.arg.length.mismatch&quot;, &quot;cannot infer type-variable(s) {0}\n(actual and formal argument lists differ in length)&quot; },
<i>533</i>&nbsp;            { &quot;compiler.misc.infer.no.conforming.assignment.exists&quot;, &quot;cannot infer type-variable(s) {0}\n(argument mismatch; {1})&quot; },
<i>534</i>&nbsp;            { &quot;compiler.misc.infer.no.conforming.instance.exists&quot;, &quot;no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}&quot; },
<i>535</i>&nbsp;            { &quot;compiler.misc.infer.varargs.argument.mismatch&quot;, &quot;cannot infer type-variable(s) {0}\n(varargs mismatch; {1})&quot; },
<i>536</i>&nbsp;            { &quot;compiler.misc.inferred.do.not.conform.to.eq.bounds&quot;, &quot;inferred type does not conform to equality constraint(s)\ninferred: {0}\nequality constraints(s): {1}&quot; },
<i>537</i>&nbsp;            { &quot;compiler.misc.inferred.do.not.conform.to.lower.bounds&quot;, &quot;inferred type does not conform to lower bound(s)\ninferred: {0}\nlower bound(s): {1}&quot; },
<i>538</i>&nbsp;            { &quot;compiler.misc.inferred.do.not.conform.to.upper.bounds&quot;, &quot;inferred type does not conform to upper bound(s)\ninferred: {0}\nupper bound(s): {1}&quot; },
<i>539</i>&nbsp;            { &quot;compiler.misc.inner.cls&quot;, &quot;an inner class&quot; },
<i>540</i>&nbsp;            { &quot;compiler.misc.intersection.type&quot;, &quot;INT#{0}&quot; },
<i>541</i>&nbsp;            { &quot;compiler.misc.invalid.default.interface&quot;, &quot;default method found in version {0}.{1} classfile&quot; },
<i>542</i>&nbsp;            { &quot;compiler.misc.invalid.generic.lambda.target&quot;, &quot;invalid functional descriptor for lambda expression\nmethod {0} in {1} {2} is generic&quot; },
<i>543</i>&nbsp;            { &quot;compiler.misc.invalid.mref&quot;, &quot;invalid {0} reference\n{1}&quot; },
<i>544</i>&nbsp;            { &quot;compiler.misc.invalid.static.interface&quot;, &quot;static method found in version {0}.{1} classfile&quot; },
<i>545</i>&nbsp;            { &quot;compiler.misc.kindname.annotation&quot;, &quot;@interface&quot; },
<i>546</i>&nbsp;            { &quot;compiler.misc.kindname.class&quot;, &quot;class&quot; },
<i>547</i>&nbsp;            { &quot;compiler.misc.kindname.constructor&quot;, &quot;constructor&quot; },
<i>548</i>&nbsp;            { &quot;compiler.misc.kindname.enum&quot;, &quot;enum&quot; },
<i>549</i>&nbsp;            { &quot;compiler.misc.kindname.instance.init&quot;, &quot;instance initializer&quot; },
<i>550</i>&nbsp;            { &quot;compiler.misc.kindname.interface&quot;, &quot;interface&quot; },
<i>551</i>&nbsp;            { &quot;compiler.misc.kindname.method&quot;, &quot;method&quot; },
<i>552</i>&nbsp;            { &quot;compiler.misc.kindname.module&quot;, &quot;module&quot; },
<i>553</i>&nbsp;            { &quot;compiler.misc.kindname.package&quot;, &quot;package&quot; },
<i>554</i>&nbsp;            { &quot;compiler.misc.kindname.static&quot;, &quot;static&quot; },
<i>555</i>&nbsp;            { &quot;compiler.misc.kindname.static.init&quot;, &quot;static initializer&quot; },
<i>556</i>&nbsp;            { &quot;compiler.misc.kindname.type.variable&quot;, &quot;type variable&quot; },
<i>557</i>&nbsp;            { &quot;compiler.misc.kindname.type.variable.bound&quot;, &quot;bound of type variable&quot; },
<i>558</i>&nbsp;            { &quot;compiler.misc.kindname.value&quot;, &quot;value&quot; },
<i>559</i>&nbsp;            { &quot;compiler.misc.kindname.variable&quot;, &quot;variable&quot; },
<i>560</i>&nbsp;            { &quot;compiler.misc.lambda&quot;, &quot;a lambda expression&quot; },
<i>561</i>&nbsp;            { &quot;compiler.misc.local.array.missing.target&quot;, &quot;array initializer needs an explicit target-type&quot; },
<i>562</i>&nbsp;            { &quot;compiler.misc.local.cant.infer.null&quot;, &quot;variable initializer is &#39;&#39;null&#39;&#39;&quot; },
<i>563</i>&nbsp;            { &quot;compiler.misc.local.cant.infer.void&quot;, &quot;variable initializer is &#39;&#39;void&#39;&#39;&quot; },
<i>564</i>&nbsp;            { &quot;compiler.misc.local.lambda.missing.target&quot;, &quot;lambda expression needs an explicit target-type&quot; },
<i>565</i>&nbsp;            { &quot;compiler.misc.local.missing.init&quot;, &quot;cannot use &#39;&#39;var&#39;&#39; on variable without initializer&quot; },
<i>566</i>&nbsp;            { &quot;compiler.misc.local.mref.missing.target&quot;, &quot;method reference needs an explicit target-type&quot; },
<i>567</i>&nbsp;            { &quot;compiler.misc.local.self.ref&quot;, &quot;cannot use &#39;&#39;var&#39;&#39; on self-referencing variable&quot; },
<i>568</i>&nbsp;            { &quot;compiler.misc.location&quot;, &quot;{0} {1}&quot; },
<i>569</i>&nbsp;            { &quot;compiler.misc.location.1&quot;, &quot;{0} {1} of type {2}&quot; },
<i>570</i>&nbsp;            { &quot;compiler.misc.locn.module_path&quot;, &quot;application module path&quot; },
<i>571</i>&nbsp;            { &quot;compiler.misc.locn.module_source_path&quot;, &quot;module source path&quot; },
<i>572</i>&nbsp;            { &quot;compiler.misc.locn.system_modules&quot;, &quot;system modules&quot; },
<i>573</i>&nbsp;            { &quot;compiler.misc.locn.upgrade_module_path&quot;, &quot;upgrade module path&quot; },
<i>574</i>&nbsp;            { &quot;compiler.misc.lower.bounds&quot;, &quot;lower bounds: {0}&quot; },
<i>575</i>&nbsp;            { &quot;compiler.misc.malformed.vararg.method&quot;, &quot;class file contains malformed variable arity method: {0}&quot; },
<i>576</i>&nbsp;            { &quot;compiler.misc.missing.ret.val&quot;, &quot;missing return value&quot; },
<i>577</i>&nbsp;            { &quot;compiler.misc.module.info.invalid.super.class&quot;, &quot;module-info with invalid super class&quot; },
<i>578</i>&nbsp;            { &quot;compiler.misc.module.name.mismatch&quot;, &quot;module name {0} does not match expected name {1}&quot; },
<i>579</i>&nbsp;            { &quot;compiler.misc.module.non.zero.opens&quot;, &quot;open module {0} has non-zero opens_count&quot; },
<i>580</i>&nbsp;            { &quot;compiler.misc.mref.infer.and.explicit.params&quot;, &quot;cannot use raw constructor reference with explicit type parameters for constructor&quot; },
<i>581</i>&nbsp;            { &quot;compiler.misc.no.abstracts&quot;, &quot;no abstract method found in {0} {1}&quot; },
<i>582</i>&nbsp;            { &quot;compiler.misc.no.args&quot;, &quot;no arguments&quot; },
<i>583</i>&nbsp;            { &quot;compiler.misc.no.conforming.assignment.exists&quot;, &quot;argument mismatch; {0}&quot; },
<i>584</i>&nbsp;            { &quot;compiler.misc.no.suitable.functional.intf.inst&quot;, &quot;cannot infer functional interface descriptor for {0}&quot; },
<i>585</i>&nbsp;            { &quot;compiler.misc.no.unique.maximal.instance.exists&quot;, &quot;no unique maximal instance exists for type variable {0} with upper bounds {1}&quot; },
<i>586</i>&nbsp;            { &quot;compiler.misc.no.unique.minimal.instance.exists&quot;, &quot;no unique minimal instance exists for type variable {0} with lower bounds {1}&quot; },
<i>587</i>&nbsp;            { &quot;compiler.misc.not.a.functional.intf&quot;, &quot;{0} is not a functional interface&quot; },
<i>588</i>&nbsp;            { &quot;compiler.misc.not.a.functional.intf.1&quot;, &quot;{0} is not a functional interface\n{1}&quot; },
<i>589</i>&nbsp;            { &quot;compiler.misc.not.an.intf.component&quot;, &quot;component type {0} is not an interface&quot; },
<i>590</i>&nbsp;            { &quot;compiler.misc.not.applicable.method.found&quot;, &quot;#{0} not applicable method found: {1}\n({2})&quot; },
<i>591</i>&nbsp;            { &quot;compiler.misc.not.def.access.class.intf.cant.access&quot;, &quot;{1}.{0} is defined in an inaccessible class or interface&quot; },
<i>592</i>&nbsp;            { &quot;compiler.misc.not.def.access.class.intf.cant.access.reason&quot;, &quot;{1}.{0} in package {2} is not accessible\n({3})&quot; },
<i>593</i>&nbsp;            { &quot;compiler.misc.not.def.access.does.not.read&quot;, &quot;package {1} is declared in module {2}, but module {0} does not read it&quot; },
<i>594</i>&nbsp;            { &quot;compiler.misc.not.def.access.does.not.read.from.unnamed&quot;, &quot;package {0} is declared in module {1}, which is not in the module graph&quot; },
<i>595</i>&nbsp;            { &quot;compiler.misc.not.def.access.does.not.read.unnamed&quot;, &quot;package {0} is declared in the unnamed module, but module {0} does not read it&quot; },
<i>596</i>&nbsp;            { &quot;compiler.misc.not.def.access.not.exported&quot;, &quot;package {0} is declared in module {1}, which does not export it&quot; },
<i>597</i>&nbsp;            { &quot;compiler.misc.not.def.access.not.exported.from.unnamed&quot;, &quot;package {0} is declared in module {1}, which does not export it&quot; },
<i>598</i>&nbsp;            { &quot;compiler.misc.not.def.access.not.exported.to.module&quot;, &quot;package {0} is declared in module {1}, which does not export it to module {2}&quot; },
<i>599</i>&nbsp;            { &quot;compiler.misc.not.def.access.not.exported.to.module.from.unnamed&quot;, &quot;package {0} is declared in module {1}, which does not export it to the unnamed module&quot; },
<i>600</i>&nbsp;            { &quot;compiler.misc.not.def.access.package.cant.access&quot;, &quot;{0} is not visible\n({2})&quot; },
<i>601</i>&nbsp;            { &quot;compiler.misc.not.def.public.cant.access&quot;, &quot;{0} is not public in {1}; cannot be accessed from outside package&quot; },
<i>602</i>&nbsp;            { &quot;compiler.misc.overridden.default&quot;, &quot;method {0} is overridden in {1}&quot; },
<i>603</i>&nbsp;            { &quot;compiler.misc.package.not.visible&quot;, &quot;package {0} is not visible\n({1})&quot; },
<i>604</i>&nbsp;            { &quot;compiler.misc.partial.inst.sig&quot;, &quot;partially instantiated to: {0}&quot; },
<i>605</i>&nbsp;            { &quot;compiler.misc.possible.loss.of.precision&quot;, &quot;possible lossy conversion from {0} to {1}&quot; },
<i>606</i>&nbsp;            { &quot;compiler.misc.prob.found.req&quot;, &quot;incompatible types: {0}&quot; },
<i>607</i>&nbsp;            { &quot;compiler.misc.redundant.supertype&quot;, &quot;redundant interface {0} is extended by {1}&quot; },
<i>608</i>&nbsp;            { &quot;compiler.misc.ref.ambiguous&quot;, &quot;reference to {0} is ambiguous\nboth {1} {2} in {3} and {4} {5} in {6} match&quot; },
<i>609</i>&nbsp;            { &quot;compiler.misc.report.access&quot;, &quot;{0} has {1} access in {2}&quot; },
<i>610</i>&nbsp;            { &quot;compiler.misc.resume.abort&quot;, &quot;R)esume, A)bort&gt;&quot; },
<i>611</i>&nbsp;            { &quot;compiler.misc.source.unavailable&quot;, &quot;(source unavailable)&quot; },
<i>612</i>&nbsp;            { &quot;compiler.misc.stat.expr.expected&quot;, &quot;lambda body is not compatible with a void functional interface\n(consider using a block lambda body, or use a statement expression instead)&quot; },
<i>613</i>&nbsp;            { &quot;compiler.misc.static.mref.with.targs&quot;, &quot;parameterized qualifier on static method reference&quot; },
<i>614</i>&nbsp;            { &quot;compiler.misc.synthetic.name.conflict&quot;, &quot;the symbol {0} conflicts with a compiler-synthesized symbol in {1}&quot; },
<i>615</i>&nbsp;            { &quot;compiler.misc.token.bad-symbol&quot;, &quot;&lt;bad symbol&gt;&quot; },
<i>616</i>&nbsp;            { &quot;compiler.misc.token.character&quot;, &quot;&lt;character&gt;&quot; },
<i>617</i>&nbsp;            { &quot;compiler.misc.token.double&quot;, &quot;&lt;double&gt;&quot; },
<i>618</i>&nbsp;            { &quot;compiler.misc.token.end-of-input&quot;, &quot;&lt;end of input&gt;&quot; },
<i>619</i>&nbsp;            { &quot;compiler.misc.token.float&quot;, &quot;&lt;float&gt;&quot; },
<i>620</i>&nbsp;            { &quot;compiler.misc.token.identifier&quot;, &quot;&lt;identifier&gt;&quot; },
<i>621</i>&nbsp;            { &quot;compiler.misc.token.integer&quot;, &quot;&lt;integer&gt;&quot; },
<i>622</i>&nbsp;            { &quot;compiler.misc.token.long-integer&quot;, &quot;&lt;long integer&gt;&quot; },
<i>623</i>&nbsp;            { &quot;compiler.misc.token.string&quot;, &quot;&lt;string&gt;&quot; },
<i>624</i>&nbsp;            { &quot;compiler.misc.try.not.applicable.to.type&quot;, &quot;try-with-resources not applicable to variable type\n({0})&quot; },
<i>625</i>&nbsp;            { &quot;compiler.misc.type.captureof&quot;, &quot;capture#{0} of {1}&quot; },
<i>626</i>&nbsp;            { &quot;compiler.misc.type.captureof.1&quot;, &quot;capture#{0}&quot; },
<i>627</i>&nbsp;            { &quot;compiler.misc.type.none&quot;, &quot;&lt;none&gt;&quot; },
<i>628</i>&nbsp;            { &quot;compiler.misc.type.null&quot;, &quot;&lt;null&gt;&quot; },
<i>629</i>&nbsp;            { &quot;compiler.misc.type.parameter&quot;, &quot;type parameter {0}&quot; },
<i>630</i>&nbsp;            { &quot;compiler.misc.type.req.array.or.iterable&quot;, &quot;array or java.lang.Iterable&quot; },
<i>631</i>&nbsp;            { &quot;compiler.misc.type.req.class&quot;, &quot;class&quot; },
<i>632</i>&nbsp;            { &quot;compiler.misc.type.req.class.array&quot;, &quot;class or array&quot; },
<i>633</i>&nbsp;            { &quot;compiler.misc.type.req.exact&quot;, &quot;class or interface without bounds&quot; },
<i>634</i>&nbsp;            { &quot;compiler.misc.type.req.ref&quot;, &quot;reference&quot; },
<i>635</i>&nbsp;            { &quot;compiler.misc.type.var&quot;, &quot;{0}#{1}&quot; },
<i>636</i>&nbsp;            { &quot;compiler.misc.unable.to.access.file&quot;, &quot;unable to access file: {0}&quot; },
<i>637</i>&nbsp;            { &quot;compiler.misc.unchecked.assign&quot;, &quot;unchecked conversion&quot; },
<i>638</i>&nbsp;            { &quot;compiler.misc.unchecked.cast.to.type&quot;, &quot;unchecked cast&quot; },
<i>639</i>&nbsp;            { &quot;compiler.misc.unchecked.clash.with&quot;, &quot;{0} in {1} overrides {2} in {3}&quot; },
<i>640</i>&nbsp;            { &quot;compiler.misc.unchecked.implement&quot;, &quot;{0} in {1} implements {2} in {3}&quot; },
<i>641</i>&nbsp;            { &quot;compiler.misc.unchecked.override&quot;, &quot;{0} in {1} overrides {2} in {3}&quot; },
<i>642</i>&nbsp;            { &quot;compiler.misc.undecl.type.var&quot;, &quot;undeclared type variable: {0}&quot; },
<i>643</i>&nbsp;            { &quot;compiler.misc.unexpected.ret.val&quot;, &quot;unexpected return value&quot; },
<i>644</i>&nbsp;            { &quot;compiler.misc.unicode.str.not.supported&quot;, &quot;unicode string in class file not supported&quot; },
<i>645</i>&nbsp;            { &quot;compiler.misc.unnamed.module&quot;, &quot;unnamed module&quot; },
<i>646</i>&nbsp;            { &quot;compiler.misc.unnamed.package&quot;, &quot;unnamed package&quot; },
<i>647</i>&nbsp;            { &quot;compiler.misc.upper.bounds&quot;, &quot;lower bounds: {0}&quot; },
<i>648</i>&nbsp;            { &quot;compiler.misc.user.selected.completion.failure&quot;, &quot;user-selected completion failure by class name&quot; },
<i>649</i>&nbsp;            { &quot;compiler.misc.var.and.explicit.not.allowed&quot;, &quot;cannot mix &#39;&#39;var&#39;&#39; and explicitly-typed parameters&quot; },
<i>650</i>&nbsp;            { &quot;compiler.misc.var.and.implicit.not.allowed&quot;, &quot;cannot mix &#39;&#39;var&#39;&#39; and implicitly-typed parameters&quot; },
<i>651</i>&nbsp;            { &quot;compiler.misc.varargs.argument.mismatch&quot;, &quot;varargs mismatch; {0}&quot; },
<i>652</i>&nbsp;            { &quot;compiler.misc.varargs.clash.with&quot;, &quot;{0} in {1} overrides {2} in {3}&quot; },
<i>653</i>&nbsp;            { &quot;compiler.misc.varargs.implement&quot;, &quot;{0} in {1} implements {2} in {3}&quot; },
<i>654</i>&nbsp;            { &quot;compiler.misc.varargs.override&quot;, &quot;{0} in {1} overrides {2} in {3}&quot; },
<i>655</i>&nbsp;            { &quot;compiler.misc.varargs.trustme.on.non.varargs.meth&quot;, &quot;Method {0} is not a varargs method.&quot; },
<i>656</i>&nbsp;            { &quot;compiler.misc.varargs.trustme.on.reifiable.varargs&quot;, &quot;Varargs element type {0} is reifiable.&quot; },
<i>657</i>&nbsp;            { &quot;compiler.misc.varargs.trustme.on.virtual.varargs&quot;, &quot;Instance method {0} is neither final nor private.&quot; },
<i>658</i>&nbsp;            { &quot;compiler.misc.varargs.trustme.on.virtual.varargs.final.only&quot;, &quot;Instance method {0} is not final.&quot; },
<i>659</i>&nbsp;            { &quot;compiler.misc.verbose.checking.attribution&quot;, &quot;[checking {0}]&quot; },
<i>660</i>&nbsp;            { &quot;compiler.misc.verbose.classpath&quot;, &quot;[search path for class files: {0}]&quot; },
<i>661</i>&nbsp;            { &quot;compiler.misc.verbose.loading&quot;, &quot;[loading {0}]&quot; },
<i>662</i>&nbsp;            { &quot;compiler.misc.verbose.parsing.done&quot;, &quot;[parsing completed {0}ms]&quot; },
<i>663</i>&nbsp;            { &quot;compiler.misc.verbose.parsing.started&quot;, &quot;[parsing started {0}]&quot; },
<i>664</i>&nbsp;            { &quot;compiler.misc.verbose.sourcepath&quot;, &quot;[search path for source files: {0}]&quot; },
<i>665</i>&nbsp;            { &quot;compiler.misc.verbose.total&quot;, &quot;[total {0}ms]&quot; },
<i>666</i>&nbsp;            { &quot;compiler.misc.verbose.wrote.file&quot;, &quot;[wrote {0}]&quot; },
<i>667</i>&nbsp;            { &quot;compiler.misc.version.not.available&quot;, &quot;(version info not available)&quot; },
<i>668</i>&nbsp;            { &quot;compiler.misc.where.captured&quot;, &quot;{0} extends {1} super: {2} from capture of {3}&quot; },
<i>669</i>&nbsp;            { &quot;compiler.misc.where.captured.1&quot;, &quot;{0} extends {1} from capture of {3}&quot; },
<i>670</i>&nbsp;            { &quot;compiler.misc.where.description.captured&quot;, &quot;where {0} is a fresh type-variable:&quot; },
<i>671</i>&nbsp;            { &quot;compiler.misc.where.description.captured.1&quot;, &quot;where {0} are fresh type-variables:&quot; },
<i>672</i>&nbsp;            { &quot;compiler.misc.where.description.intersection&quot;, &quot;where {0} is an intersection type:&quot; },
<i>673</i>&nbsp;            { &quot;compiler.misc.where.description.intersection.1&quot;, &quot;where {0} are intersection types:&quot; },
<i>674</i>&nbsp;            { &quot;compiler.misc.where.description.typevar&quot;, &quot;where {0} is a type-variable:&quot; },
<i>675</i>&nbsp;            { &quot;compiler.misc.where.description.typevar.1&quot;, &quot;where {0} are type-variables:&quot; },
<i>676</i>&nbsp;            { &quot;compiler.misc.where.fresh.typevar&quot;, &quot;{0} extends {1}&quot; },
<i>677</i>&nbsp;            { &quot;compiler.misc.where.intersection&quot;, &quot;{0} extends {1}&quot; },
<i>678</i>&nbsp;            { &quot;compiler.misc.where.typevar&quot;, &quot;{0} extends {1} declared in {2} {3}&quot; },
<i>679</i>&nbsp;            { &quot;compiler.misc.where.typevar.1&quot;, &quot;{0} declared in {2} {3}&quot; },
<i>680</i>&nbsp;            { &quot;compiler.misc.wrong.number.type.args&quot;, &quot;wrong number of type arguments; required {0}&quot; },
<i>681</i>&nbsp;            { &quot;compiler.misc.wrong.version&quot;, &quot;class file has wrong version {0}.{1}, should be {2}.{3}&quot; },
<i>682</i>&nbsp;            { &quot;compiler.misc.x.print.processor.info&quot;, &quot;Processor {0} matches {1} and returns {2}.&quot; },
<i>683</i>&nbsp;            { &quot;compiler.misc.x.print.rounds&quot;, &quot;Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}&quot; },
<i>684</i>&nbsp;            { &quot;compiler.note.compressed.diags&quot;, &quot;Some messages have been simplified; recompile with -Xdiags:verbose to get full output&quot; },
<i>685</i>&nbsp;            { &quot;compiler.note.deferred.method.inst&quot;, &quot;Deferred instantiation of method {0}\ninstantiated signature: {1}\ntarget-type: {2}&quot; },
<i>686</i>&nbsp;            { &quot;compiler.note.deprecated.filename&quot;, &quot;{0} uses or overrides a deprecated API.&quot; },
<i>687</i>&nbsp;            { &quot;compiler.note.deprecated.filename.additional&quot;, &quot;{0} has additional uses or overrides of a deprecated API.&quot; },
<i>688</i>&nbsp;            { &quot;compiler.note.deprecated.plural&quot;, &quot;Some input files use or override a deprecated API.&quot; },
<i>689</i>&nbsp;            { &quot;compiler.note.deprecated.plural.additional&quot;, &quot;Some input files additionally use or override a deprecated API.&quot; },
<i>690</i>&nbsp;            { &quot;compiler.note.deprecated.recompile&quot;, &quot;Recompile with -Xlint:deprecation for details.&quot; },
<i>691</i>&nbsp;            { &quot;compiler.note.lambda.stat&quot;, &quot;Translating lambda expression\nalternate metafactory = {0}\nsynthetic method = {1}&quot; },
<i>692</i>&nbsp;            { &quot;compiler.note.mref.stat&quot;, &quot;Translating method reference\nalternate metafactory = {0}\n&quot; },
<i>693</i>&nbsp;            { &quot;compiler.note.mref.stat.1&quot;, &quot;Translating method reference\nalternate metafactory = {0}\nbridge method = {1}&quot; },
<i>694</i>&nbsp;            { &quot;compiler.note.multiple.elements&quot;, &quot;Multiple elements named &#39;&#39;{1}&#39;&#39; in modules &#39;&#39;{2}&#39;&#39; were found by javax.lang.model.util.Elements.{0}.&quot; },
<i>695</i>&nbsp;            { &quot;compiler.note.note&quot;, &quot;Note: &quot; },
<i>696</i>&nbsp;            { &quot;compiler.note.preview.filename&quot;, &quot;{0} uses preview language features.&quot; },
<i>697</i>&nbsp;            { &quot;compiler.note.preview.filename.additional&quot;, &quot;{0} has additional uses of preview language features.&quot; },
<i>698</i>&nbsp;            { &quot;compiler.note.preview.plural&quot;, &quot;Some input files use preview language features.&quot; },
<i>699</i>&nbsp;            { &quot;compiler.note.preview.plural.additional&quot;, &quot;Some input files additionally use preview language features.&quot; },
<i>700</i>&nbsp;            { &quot;compiler.note.preview.recompile&quot;, &quot;Recompile with -Xlint:preview for details.&quot; },
<i>701</i>&nbsp;            { &quot;compiler.note.proc.messager&quot;, &quot;{0}&quot; },
<i>702</i>&nbsp;            { &quot;compiler.note.removal.filename&quot;, &quot;{0} uses or overrides a deprecated API that is marked for removal.&quot; },
<i>703</i>&nbsp;            { &quot;compiler.note.removal.filename.additional&quot;, &quot;{0} has additional uses or overrides of a deprecated API that is marked for removal.&quot; },
<i>704</i>&nbsp;            { &quot;compiler.note.removal.plural&quot;, &quot;Some input files use or override a deprecated API that is marked for removal.&quot; },
<i>705</i>&nbsp;            { &quot;compiler.note.removal.plural.additional&quot;, &quot;Some input files additionally use or override a deprecated API that is marked for removal.&quot; },
<i>706</i>&nbsp;            { &quot;compiler.note.removal.recompile&quot;, &quot;Recompile with -Xlint:removal for details.&quot; },
<i>707</i>&nbsp;            { &quot;compiler.note.unchecked.filename&quot;, &quot;{0} uses unchecked or unsafe operations.&quot; },
<i>708</i>&nbsp;            { &quot;compiler.note.unchecked.filename.additional&quot;, &quot;{0} has additional unchecked or unsafe operations.&quot; },
<i>709</i>&nbsp;            { &quot;compiler.note.unchecked.plural&quot;, &quot;Some input files use unchecked or unsafe operations.&quot; },
<i>710</i>&nbsp;            { &quot;compiler.note.unchecked.plural.additional&quot;, &quot;Some input files additionally use unchecked or unsafe operations.&quot; },
<i>711</i>&nbsp;            { &quot;compiler.note.unchecked.recompile&quot;, &quot;Recompile with -Xlint:unchecked for details.&quot; },
<i>712</i>&nbsp;            { &quot;compiler.note.verbose.l2m.deduplicate&quot;, &quot;deduplicating lambda implementation method {0}&quot; },
<i>713</i>&nbsp;            { &quot;compiler.note.verbose.resolve.multi&quot;, &quot;resolving method {0} in type {1} to candidate {2}\nphase: {3}\nwith actuals: {4}\nwith type-args: {5}\ncandidates:&quot; },
<i>714</i>&nbsp;            { &quot;compiler.note.verbose.resolve.multi.1&quot;, &quot;erroneous resolution for method {0} in type {1}\nphase: {3}\nwith actuals: {4}\nwith type-args: {5}\ncandidates:&quot; },
<i>715</i>&nbsp;            { &quot;compiler.warn.access.to.member.from.serializable.element&quot;, &quot;access to member {0} from serializable element can be publicly accessible to untrusted code&quot; },
<i>716</i>&nbsp;            { &quot;compiler.warn.access.to.member.from.serializable.lambda&quot;, &quot;access to member {0} from serializable lambda can be publicly accessible to untrusted code&quot; },
<i>717</i>&nbsp;            { &quot;compiler.warn.addopens.ignored&quot;, &quot;--add-opens has no effect at compile time&quot; },
<i>718</i>&nbsp;            { &quot;compiler.warn.annotation.method.not.found&quot;, &quot;Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;&quot; },
<i>719</i>&nbsp;            { &quot;compiler.warn.annotation.method.not.found.reason&quot;, &quot;Cannot find annotation method &#39;&#39;{1}()&#39;&#39; in type &#39;&#39;{0}&#39;&#39;: {2}&quot; },
<i>720</i>&nbsp;            { &quot;compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file&quot;, &quot;auxiliary class {0} in {1} should not be accessed from outside its own source file&quot; },
<i>721</i>&nbsp;            { &quot;compiler.warn.bad.name.for.option&quot;, &quot;bad name in value for {0} option: &#39;&#39;{1}&#39;&#39;&quot; },
<i>722</i>&nbsp;            { &quot;compiler.warn.big.major.version&quot;, &quot;{0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\nIt is recommended that the compiler be upgraded.&quot; },
<i>723</i>&nbsp;            { &quot;compiler.warn.constant.SVUID&quot;, &quot;serialVersionUID must be constant in class {0}&quot; },
<i>724</i>&nbsp;            { &quot;compiler.warn.deprecated.annotation.has.no.effect&quot;, &quot;@Deprecated annotation has no effect on this {0} declaration&quot; },
<i>725</i>&nbsp;            { &quot;compiler.warn.diamond.redundant.args&quot;, &quot;Redundant type arguments in new expression (use diamond operator instead).&quot; },
<i>726</i>&nbsp;            { &quot;compiler.warn.dir.path.element.not.directory&quot;, &quot;bad path element \&quot;{0}\&quot;: not a directory&quot; },
<i>727</i>&nbsp;            { &quot;compiler.warn.dir.path.element.not.found&quot;, &quot;bad path element \&quot;{0}\&quot;: no such directory&quot; },
<i>728</i>&nbsp;            { &quot;compiler.warn.div.zero&quot;, &quot;division by zero&quot; },
<i>729</i>&nbsp;            { &quot;compiler.warn.empty.if&quot;, &quot;empty statement after if&quot; },
<i>730</i>&nbsp;            { &quot;compiler.warn.file.from.future&quot;, &quot;Modification date is in the future for file {0}&quot; },
<i>731</i>&nbsp;            { &quot;compiler.warn.finally.cannot.complete&quot;, &quot;finally clause cannot complete normally&quot; },
<i>732</i>&nbsp;            { &quot;compiler.warn.forward.ref&quot;, &quot;reference to variable &#39;&#39;{0}&#39;&#39; before it has been initialized&quot; },
<i>733</i>&nbsp;            { &quot;compiler.warn.future.attr&quot;, &quot;{0} attribute introduced in version {1}.{2} class files is ignored in version {3}.{4} class files&quot; },
<i>734</i>&nbsp;            { &quot;compiler.warn.has.been.deprecated&quot;, &quot;{0} in {1} has been deprecated&quot; },
<i>735</i>&nbsp;            { &quot;compiler.warn.has.been.deprecated.for.removal&quot;, &quot;{0} in {1} has been deprecated and marked for removal&quot; },
<i>736</i>&nbsp;            { &quot;compiler.warn.has.been.deprecated.for.removal.module&quot;, &quot;module {0} has been deprecated and marked for removal&quot; },
<i>737</i>&nbsp;            { &quot;compiler.warn.has.been.deprecated.module&quot;, &quot;module {0} has been deprecated&quot; },
<i>738</i>&nbsp;            { &quot;compiler.warn.illegal.char.for.encoding&quot;, &quot;unmappable character for encoding {0}&quot; },
<i>739</i>&nbsp;            { &quot;compiler.warn.improper.SVUID&quot;, &quot;serialVersionUID must be declared static final in class {0}&quot; },
<i>740</i>&nbsp;            { &quot;compiler.warn.incubating.modules&quot;, &quot;using incubating module(s): {0}&quot; },
<i>741</i>&nbsp;            { &quot;compiler.warn.inexact.non-varargs.call&quot;, &quot;non-varargs call of varargs method with inexact argument type for last parameter;\ncast to {0} for a varargs call\ncast to {1} for a non-varargs call and to suppress this warning&quot; },
<i>742</i>&nbsp;            { &quot;compiler.warn.invalid.archive.file&quot;, &quot;Unexpected file on path: {0}&quot; },
<i>743</i>&nbsp;            { &quot;compiler.warn.invalid.path&quot;, &quot;Invalid filename: {0}&quot; },
<i>744</i>&nbsp;            { &quot;compiler.warn.leaks.not.accessible&quot;, &quot;{0} {1} in module {2} is not accessible to clients that require this module&quot; },
<i>745</i>&nbsp;            { &quot;compiler.warn.leaks.not.accessible.not.required.transitive&quot;, &quot;{0} {1} in module {2} is not indirectly exported using &#39;requires transitive&#39;&quot; },
<i>746</i>&nbsp;            { &quot;compiler.warn.leaks.not.accessible.unexported&quot;, &quot;{0} {1} in module {2} is not exported&quot; },
<i>747</i>&nbsp;            { &quot;compiler.warn.leaks.not.accessible.unexported.qualified&quot;, &quot;{0} {1} in module {2} may not be visible to all clients that require this module&quot; },
<i>748</i>&nbsp;            { &quot;compiler.warn.lintOption&quot;, &quot;[{0}] &quot; },
<i>749</i>&nbsp;            { &quot;compiler.warn.local.redundant.type&quot;, &quot;Redundant type for local variable (replace explicit type with &#39;&#39;var&#39;&#39;).&quot; },
<i>750</i>&nbsp;            { &quot;compiler.warn.locn.unknown.file.on.module.path&quot;, &quot;unknown file on module path: {0}&quot; },
<i>751</i>&nbsp;            { &quot;compiler.warn.long.SVUID&quot;, &quot;serialVersionUID must be of type long in class {0}&quot; },
<i>752</i>&nbsp;            { &quot;compiler.warn.method.redundant.typeargs&quot;, &quot;Redundant type arguments in method call.&quot; },
<i>753</i>&nbsp;            { &quot;compiler.warn.missing.SVUID&quot;, &quot;serializable class {0} has no definition of serialVersionUID&quot; },
<i>754</i>&nbsp;            { &quot;compiler.warn.missing.deprecated.annotation&quot;, &quot;deprecated item is not annotated with @Deprecated&quot; },
<i>755</i>&nbsp;            { &quot;compiler.warn.module.for.option.not.found&quot;, &quot;module name in {0} option not found: {1}&quot; },
<i>756</i>&nbsp;            { &quot;compiler.warn.module.not.found&quot;, &quot;module not found: {0}&quot; },
<i>757</i>&nbsp;            { &quot;compiler.warn.option.obsolete.source&quot;, &quot;source value {0} is obsolete and will be removed in a future release&quot; },
<i>758</i>&nbsp;            { &quot;compiler.warn.option.obsolete.suppression&quot;, &quot;To suppress warnings about obsolete options, use -Xlint:-options.&quot; },
<i>759</i>&nbsp;            { &quot;compiler.warn.option.obsolete.target&quot;, &quot;target value {0} is obsolete and will be removed in a future release&quot; },
<i>760</i>&nbsp;            { &quot;compiler.warn.option.parameters.unsupported&quot;, &quot;-parameters is not supported for target value {0}. Use {1} or later.&quot; },
<i>761</i>&nbsp;            { &quot;compiler.warn.outdir.is.in.exploded.module&quot;, &quot;the output directory is within an exploded module: {0}&quot; },
<i>762</i>&nbsp;            { &quot;compiler.warn.override.bridge&quot;, &quot;{0}; overridden method is a bridge method&quot; },
<i>763</i>&nbsp;            { &quot;compiler.warn.override.equals.but.not.hashcode&quot;, &quot;Class {0} overrides equals, but neither it nor any superclass overrides hashCode method&quot; },
<i>764</i>&nbsp;            { &quot;compiler.warn.override.unchecked.ret&quot;, &quot;{0}\nreturn type requires unchecked conversion from {1} to {2}&quot; },
<i>765</i>&nbsp;            { &quot;compiler.warn.override.unchecked.thrown&quot;, &quot;{0}\noverridden method does not throw {1}&quot; },
<i>766</i>&nbsp;            { &quot;compiler.warn.override.varargs.extra&quot;, &quot;{0}; overriding method is missing &#39;&#39;...&#39;&#39;&quot; },
<i>767</i>&nbsp;            { &quot;compiler.warn.override.varargs.missing&quot;, &quot;{0}; overridden method has no &#39;&#39;...&#39;&#39;&quot; },
<i>768</i>&nbsp;            { &quot;compiler.warn.package.empty.or.not.found&quot;, &quot;package is empty or does not exist: {0}&quot; },
<i>769</i>&nbsp;            { &quot;compiler.warn.path.element.not.found&quot;, &quot;bad path element \&quot;{0}\&quot;: no such file or directory&quot; },
<i>770</i>&nbsp;            { &quot;compiler.warn.pkg-info.already.seen&quot;, &quot;a package-info.java file has already been seen for package {0}&quot; },
<i>771</i>&nbsp;            { &quot;compiler.warn.poor.choice.for.module.name&quot;, &quot;module name component {0} should avoid terminal digits&quot; },
<i>772</i>&nbsp;            { &quot;compiler.warn.position.overflow&quot;, &quot;Position encoding overflows at line {0}&quot; },
<i>773</i>&nbsp;            { &quot;compiler.warn.possible.fall-through.into.case&quot;, &quot;possible fall-through into case&quot; },
<i>774</i>&nbsp;            { &quot;compiler.warn.potential.lambda.found&quot;, &quot;This anonymous inner class creation can be turned into a lambda expression.&quot; },
<i>775</i>&nbsp;            { &quot;compiler.warn.potentially.ambiguous.overload&quot;, &quot;{0} in {1} is potentially ambiguous with {2} in {3}&quot; },
<i>776</i>&nbsp;            { &quot;compiler.warn.preview.feature.use&quot;, &quot;{0} is a preview feature and may be removed in a future release.&quot; },
<i>777</i>&nbsp;            { &quot;compiler.warn.preview.feature.use.classfile&quot;, &quot;classfile for {0} uses preview features of Java SE {1}.&quot; },
<i>778</i>&nbsp;            { &quot;compiler.warn.preview.feature.use.plural&quot;, &quot;{0} are a preview feature and may be removed in a future release.&quot; },
<i>779</i>&nbsp;            { &quot;compiler.warn.prob.found.req&quot;, &quot;{0}\nrequired: {2}\nfound:    {1}&quot; },
<i>780</i>&nbsp;            { &quot;compiler.warn.proc.annotations.without.processors&quot;, &quot;No processor claimed any of these annotations: {0}&quot; },
<i>781</i>&nbsp;            { &quot;compiler.warn.proc.file.create.last.round&quot;, &quot;File for type &#39;&#39;{0}&#39;&#39; created in the last round will not be subject to annotation processing.&quot; },
<i>782</i>&nbsp;            { &quot;compiler.warn.proc.file.reopening&quot;, &quot;Attempt to create a file for &#39;&#39;{0}&#39;&#39; multiple times&quot; },
<i>783</i>&nbsp;            { &quot;compiler.warn.proc.illegal.file.name&quot;, &quot;Cannot create file for illegal name &#39;&#39;{0}&#39;&#39;.&quot; },
<i>784</i>&nbsp;            { &quot;compiler.warn.proc.malformed.supported.string&quot;, &quot;Malformed string &#39;&#39;{0}&#39;&#39; for a supported annotation type returned by processor &#39;&#39;{1}&#39;&#39;&quot; },
<i>785</i>&nbsp;            { &quot;compiler.warn.proc.messager&quot;, &quot;{0}&quot; },
<i>786</i>&nbsp;            { &quot;compiler.warn.proc.package.does.not.exist&quot;, &quot;package {0} does not exist&quot; },
<i>787</i>&nbsp;            { &quot;compiler.warn.proc.proc-only.requested.no.procs&quot;, &quot;Annotation processing without compilation requested but no processors were found.&quot; },
<i>788</i>&nbsp;            { &quot;compiler.warn.proc.processor.incompatible.source.version&quot;, &quot;Supported source version &#39;&#39;{0}&#39;&#39; from annotation processor &#39;&#39;{1}&#39;&#39; less than -source &#39;&#39;{2}&#39;&#39;&quot; },
<i>789</i>&nbsp;            { &quot;compiler.warn.proc.suspicious.class.name&quot;, &quot;Creating file for a type whose name ends in {1}: &#39;&#39;{0}&#39;&#39;&quot; },
<i>790</i>&nbsp;            { &quot;compiler.warn.proc.type.already.exists&quot;, &quot;A file for type &#39;&#39;{0}&#39;&#39; already exists on the sourcepath or classpath&quot; },
<i>791</i>&nbsp;            { &quot;compiler.warn.proc.type.recreate&quot;, &quot;Attempt to create a file for type &#39;&#39;{0}&#39;&#39; multiple times&quot; },
<i>792</i>&nbsp;            { &quot;compiler.warn.proc.unclosed.type.files&quot;, &quot;Unclosed files for the types &#39;&#39;{0}&#39;&#39;; these types will not undergo annotation processing&quot; },
<i>793</i>&nbsp;            { &quot;compiler.warn.proc.unmatched.processor.options&quot;, &quot;The following options were not recognized by any processor: &#39;&#39;{0}&#39;&#39;&quot; },
<i>794</i>&nbsp;            { &quot;compiler.warn.proc.use.implicit&quot;, &quot;Implicitly compiled files were not subject to annotation processing.\nUse -implicit to specify a policy for implicit compilation.&quot; },
<i>795</i>&nbsp;            { &quot;compiler.warn.proc.use.proc.or.implicit&quot;, &quot;Implicitly compiled files were not subject to annotation processing.\nUse -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.&quot; },
<i>796</i>&nbsp;            { &quot;compiler.warn.profile.target.conflict&quot;, &quot;profile {0} is not valid for target release {1}&quot; },
<i>797</i>&nbsp;            { &quot;compiler.warn.raw.class.use&quot;, &quot;found raw type: {0}\nmissing type arguments for generic class {1}&quot; },
<i>798</i>&nbsp;            { &quot;compiler.warn.redundant.cast&quot;, &quot;redundant cast to {0}&quot; },
<i>799</i>&nbsp;            { &quot;compiler.warn.requires.automatic&quot;, &quot;requires directive for an automatic module&quot; },
<i>800</i>&nbsp;            { &quot;compiler.warn.requires.transitive.automatic&quot;, &quot;requires transitive directive for an automatic module&quot; },
<i>801</i>&nbsp;            { &quot;compiler.warn.self.ref&quot;, &quot;self-reference in initializer of variable &#39;&#39;{0}&#39;&#39;&quot; },
<i>802</i>&nbsp;            { &quot;compiler.warn.service.provided.but.not.exported.or.used&quot;, &quot;service interface provided but not exported or used&quot; },
<i>803</i>&nbsp;            { &quot;compiler.warn.source.no.bootclasspath&quot;, &quot;bootstrap class path not set in conjunction with -source {0}&quot; },
<i>804</i>&nbsp;            { &quot;compiler.warn.source.target.conflict&quot;, &quot;source release {0} requires target release {1}&quot; },
<i>805</i>&nbsp;            { &quot;compiler.warn.static.not.qualified.by.type&quot;, &quot;static {0} should be qualified by type name, {1}, instead of by an expression&quot; },
<i>806</i>&nbsp;            { &quot;compiler.warn.sun.proprietary&quot;, &quot;{0} is internal proprietary API and may be removed in a future release&quot; },
<i>807</i>&nbsp;            { &quot;compiler.warn.target.default.source.conflict&quot;, &quot;target release {0} conflicts with default source release {1}&quot; },
<i>808</i>&nbsp;            { &quot;compiler.warn.try.explicit.close.call&quot;, &quot;explicit call to close() on an auto-closeable resource&quot; },
<i>809</i>&nbsp;            { &quot;compiler.warn.try.resource.not.referenced&quot;, &quot;auto-closeable resource {0} is never referenced in body of corresponding try statement&quot; },
<i>810</i>&nbsp;            { &quot;compiler.warn.try.resource.throws.interrupted.exc&quot;, &quot;auto-closeable resource {0} has a member method close() that could throw InterruptedException&quot; },
<i>811</i>&nbsp;            { &quot;compiler.warn.unchecked.assign&quot;, &quot;unchecked assignment: {0} to {1}&quot; },
<i>812</i>&nbsp;            { &quot;compiler.warn.unchecked.assign.to.var&quot;, &quot;unchecked assignment to variable {0} as member of raw type {1}&quot; },
<i>813</i>&nbsp;            { &quot;compiler.warn.unchecked.call.mbr.of.raw.type&quot;, &quot;unchecked call to {0} as a member of the raw type {1}&quot; },
<i>814</i>&nbsp;            { &quot;compiler.warn.unchecked.cast.to.type&quot;, &quot;unchecked cast to type {0}&quot; },
<i>815</i>&nbsp;            { &quot;compiler.warn.unchecked.generic.array.creation&quot;, &quot;unchecked generic array creation for varargs parameter of type {0}&quot; },
<i>816</i>&nbsp;            { &quot;compiler.warn.unchecked.meth.invocation.applied&quot;, &quot;unchecked method invocation: {0} {1} in {4} {5} is applied to given types\nrequired: {2}\nfound: {3}&quot; },
<i>817</i>&nbsp;            { &quot;compiler.warn.unchecked.varargs.non.reifiable.type&quot;, &quot;Possible heap pollution from parameterized vararg type {0}&quot; },
<i>818</i>&nbsp;            { &quot;compiler.warn.underscore.as.identifier&quot;, &quot;as of release 9, &#39;&#39;_&#39;&#39; is a keyword, and may not be used as an identifier&quot; },
<i>819</i>&nbsp;            { &quot;compiler.warn.unexpected.archive.file&quot;, &quot;Unexpected extension for archive file: {0}&quot; },
<i>820</i>&nbsp;            { &quot;compiler.warn.unknown.enum.constant&quot;, &quot;unknown enum constant {1}.{2}&quot; },
<i>821</i>&nbsp;            { &quot;compiler.warn.unknown.enum.constant.reason&quot;, &quot;unknown enum constant {1}.{2}\nreason: {3}&quot; },
<i>822</i>&nbsp;            { &quot;compiler.warn.unreachable.catch&quot;, &quot;unreachable catch clause\nthrown type {0} has already been caught&quot; },
<i>823</i>&nbsp;            { &quot;compiler.warn.unreachable.catch.1&quot;, &quot;unreachable catch clause\nthrown types {0} have already been caught&quot; },
<i>824</i>&nbsp;            { &quot;compiler.warn.var.not.allowed&quot;, &quot;as of release 10, &#39;&#39;var&#39;&#39; is a restricted local variable type and cannot be used for type declarations or as the element type of an array&quot; },
<i>825</i>&nbsp;            { &quot;compiler.warn.varargs.redundant.trustme.anno&quot;, &quot;Redundant {0} annotation. {1}&quot; },
<i>826</i>&nbsp;            { &quot;compiler.warn.varargs.unsafe.use.varargs.param&quot;, &quot;Varargs method could cause heap pollution from non-reifiable varargs parameter {0}&quot; },
<i>827</i>&nbsp;            { &quot;compiler.warn.warning&quot;, &quot;warning: &quot; },
<i>828</i>&nbsp;        };
<i>829</i>&nbsp;    }
<i>830</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
