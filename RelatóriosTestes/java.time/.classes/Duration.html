


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Duration</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.time</a> ]
</div>

<h1>Coverage Summary for Class: Duration (java.time)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Duration</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 221)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Duration$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Duration$DurationUnits</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 66)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 224)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; *
<i>28</i>&nbsp; *
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *
<i>31</i>&nbsp; *
<i>32</i>&nbsp; * Copyright (c) 2007-2012, Stephen Colebourne &amp; Michael Nascimento Santos
<i>33</i>&nbsp; *
<i>34</i>&nbsp; * All rights reserved.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * Redistribution and use in source and binary forms, with or without
<i>37</i>&nbsp; * modification, are permitted provided that the following conditions are met:
<i>38</i>&nbsp; *
<i>39</i>&nbsp; *  * Redistributions of source code must retain the above copyright notice,
<i>40</i>&nbsp; *    this list of conditions and the following disclaimer.
<i>41</i>&nbsp; *
<i>42</i>&nbsp; *  * Redistributions in binary form must reproduce the above copyright notice,
<i>43</i>&nbsp; *    this list of conditions and the following disclaimer in the documentation
<i>44</i>&nbsp; *    and/or other materials provided with the distribution.
<i>45</i>&nbsp; *
<i>46</i>&nbsp; *  * Neither the name of JSR-310 nor the names of its contributors
<i>47</i>&nbsp; *    may be used to endorse or promote products derived from this software
<i>48</i>&nbsp; *    without specific prior written permission.
<i>49</i>&nbsp; *
<i>50</i>&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<i>51</i>&nbsp; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<i>52</i>&nbsp; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<i>53</i>&nbsp; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
<i>54</i>&nbsp; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<i>55</i>&nbsp; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<i>56</i>&nbsp; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<i>57</i>&nbsp; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<i>58</i>&nbsp; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<i>59</i>&nbsp; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<i>60</i>&nbsp; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<i>61</i>&nbsp; */
<i>62</i>&nbsp;package java.time;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import static java.time.LocalTime.MINUTES_PER_HOUR;
<i>65</i>&nbsp;import static java.time.LocalTime.NANOS_PER_MILLI;
<i>66</i>&nbsp;import static java.time.LocalTime.NANOS_PER_SECOND;
<i>67</i>&nbsp;import static java.time.LocalTime.SECONDS_PER_DAY;
<i>68</i>&nbsp;import static java.time.LocalTime.SECONDS_PER_HOUR;
<i>69</i>&nbsp;import static java.time.LocalTime.SECONDS_PER_MINUTE;
<i>70</i>&nbsp;import static java.time.temporal.ChronoField.NANO_OF_SECOND;
<i>71</i>&nbsp;import static java.time.temporal.ChronoUnit.DAYS;
<i>72</i>&nbsp;import static java.time.temporal.ChronoUnit.NANOS;
<i>73</i>&nbsp;import static java.time.temporal.ChronoUnit.SECONDS;
<i>74</i>&nbsp;
<i>75</i>&nbsp;import java.io.DataInput;
<i>76</i>&nbsp;import java.io.DataOutput;
<i>77</i>&nbsp;import java.io.IOException;
<i>78</i>&nbsp;import java.io.InvalidObjectException;
<i>79</i>&nbsp;import java.io.ObjectInputStream;
<i>80</i>&nbsp;import java.io.Serializable;
<i>81</i>&nbsp;import java.math.BigDecimal;
<i>82</i>&nbsp;import java.math.BigInteger;
<i>83</i>&nbsp;import java.math.RoundingMode;
<i>84</i>&nbsp;import java.time.format.DateTimeParseException;
<i>85</i>&nbsp;import java.time.temporal.ChronoField;
<i>86</i>&nbsp;import java.time.temporal.ChronoUnit;
<i>87</i>&nbsp;import java.time.temporal.Temporal;
<i>88</i>&nbsp;import java.time.temporal.TemporalAmount;
<i>89</i>&nbsp;import java.time.temporal.TemporalUnit;
<i>90</i>&nbsp;import java.time.temporal.UnsupportedTemporalTypeException;
<i>91</i>&nbsp;import java.util.List;
<i>92</i>&nbsp;import java.util.Objects;
<i>93</i>&nbsp;import java.util.regex.Matcher;
<i>94</i>&nbsp;import java.util.regex.Pattern;
<i>95</i>&nbsp;
<i>96</i>&nbsp;/**
<i>97</i>&nbsp; * A time-based amount of time, such as &#39;34.5 seconds&#39;.
<i>98</i>&nbsp; * &lt;p&gt;
<i>99</i>&nbsp; * This class models a quantity or amount of time in terms of seconds and nanoseconds.
<i>100</i>&nbsp; * It can be accessed using other duration-based units, such as minutes and hours.
<i>101</i>&nbsp; * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
<i>102</i>&nbsp; * exactly equal to 24 hours, thus ignoring daylight savings effects.
<i>103</i>&nbsp; * See {@link Period} for the date-based equivalent to this class.
<i>104</i>&nbsp; * &lt;p&gt;
<i>105</i>&nbsp; * A physical duration could be of infinite length.
<i>106</i>&nbsp; * For practicality, the duration is stored with constraints similar to {@link Instant}.
<i>107</i>&nbsp; * The duration uses nanosecond resolution with a maximum value of the seconds that can
<i>108</i>&nbsp; * be held in a {@code long}. This is greater than the current estimated age of the universe.
<i>109</i>&nbsp; * &lt;p&gt;
<i>110</i>&nbsp; * The range of a duration requires the storage of a number larger than a {@code long}.
<i>111</i>&nbsp; * To achieve this, the class stores a {@code long} representing seconds and an {@code int}
<i>112</i>&nbsp; * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
<i>113</i>&nbsp; * The model is of a directed duration, meaning that the duration may be negative.
<i>114</i>&nbsp; * &lt;p&gt;
<i>115</i>&nbsp; * The duration is measured in &quot;seconds&quot;, but these are not necessarily identical to
<i>116</i>&nbsp; * the scientific &quot;SI second&quot; definition based on atomic clocks.
<i>117</i>&nbsp; * This difference only impacts durations measured near a leap-second and should not affect
<i>118</i>&nbsp; * most applications.
<i>119</i>&nbsp; * See {@link Instant} for a discussion as to the meaning of the second and time-scales.
<i>120</i>&nbsp; *
<i>121</i>&nbsp; * &lt;p&gt;
<i>122</i>&nbsp; * This is a &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
<i>123</i>&nbsp; * class; use of identity-sensitive operations (including reference equality
<i>124</i>&nbsp; * ({@code ==}), identity hash code, or synchronization) on instances of
<i>125</i>&nbsp; * {@code Duration} may have unpredictable results and should be avoided.
<i>126</i>&nbsp; * The {@code equals} method should be used for comparisons.
<i>127</i>&nbsp; *
<i>128</i>&nbsp; * @implSpec
<i>129</i>&nbsp; * This class is immutable and thread-safe.
<i>130</i>&nbsp; *
<i>131</i>&nbsp; * @since 1.8
<i>132</i>&nbsp; */
<i>133</i>&nbsp;public final class Duration
<i>134</i>&nbsp;        implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable {
<i>135</i>&nbsp;
<i>136</i>&nbsp;    /**
<i>137</i>&nbsp;     * Constant for a duration of zero.
<i>138</i>&nbsp;     */
<b class="nc"><i>139</i>&nbsp;    public static final Duration ZERO = new Duration(0, 0);</b>
<i>140</i>&nbsp;    /**
<i>141</i>&nbsp;     * Serialization version.
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    private static final long serialVersionUID = 3078945930695997490L;
<i>144</i>&nbsp;    /**
<i>145</i>&nbsp;     * Constant for nanos per second.
<i>146</i>&nbsp;     */
<b class="nc"><i>147</i>&nbsp;    private static final BigInteger BI_NANOS_PER_SECOND = BigInteger.valueOf(NANOS_PER_SECOND);</b>
<i>148</i>&nbsp;    /**
<i>149</i>&nbsp;     * The pattern for parsing.
<i>150</i>&nbsp;     */
<i>151</i>&nbsp;    private static class Lazy {
<b class="nc"><i>152</i>&nbsp;        static final Pattern PATTERN =</b>
<i>153</i>&nbsp;            Pattern.compile(&quot;([-+]?)P(?:([-+]?[0-9]+)D)?&quot; +
<i>154</i>&nbsp;                    &quot;(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?&quot;,
<i>155</i>&nbsp;                    Pattern.CASE_INSENSITIVE);
<i>156</i>&nbsp;    }
<i>157</i>&nbsp;
<i>158</i>&nbsp;    /**
<i>159</i>&nbsp;     * The number of seconds in the duration.
<i>160</i>&nbsp;     */
<i>161</i>&nbsp;    private final long seconds;
<i>162</i>&nbsp;    /**
<i>163</i>&nbsp;     * The number of nanoseconds in the duration, expressed as a fraction of the
<i>164</i>&nbsp;     * number of seconds. This is always positive, and never exceeds 999,999,999.
<i>165</i>&nbsp;     */
<i>166</i>&nbsp;    private final int nanos;
<i>167</i>&nbsp;
<i>168</i>&nbsp;    //-----------------------------------------------------------------------
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * Obtains a {@code Duration} representing a number of standard 24 hour days.
<i>171</i>&nbsp;     * &lt;p&gt;
<i>172</i>&nbsp;     * The seconds are calculated based on the standard definition of a day,
<i>173</i>&nbsp;     * where each day is 86400 seconds which implies a 24 hour day.
<i>174</i>&nbsp;     * The nanosecond in second field is set to zero.
<i>175</i>&nbsp;     *
<i>176</i>&nbsp;     * @param days  the number of days, positive or negative
<i>177</i>&nbsp;     * @return a {@code Duration}, not null
<i>178</i>&nbsp;     * @throws ArithmeticException if the input days exceeds the capacity of {@code Duration}
<b class="nc"><i>179</i>&nbsp;     */</b>
<i>180</i>&nbsp;    public static Duration ofDays(long days) {
<i>181</i>&nbsp;        return create(Math.multiplyExact(days, SECONDS_PER_DAY), 0);
<i>182</i>&nbsp;    }
<i>183</i>&nbsp;
<i>184</i>&nbsp;    /**
<i>185</i>&nbsp;     * Obtains a {@code Duration} representing a number of standard hours.
<i>186</i>&nbsp;     * &lt;p&gt;
<i>187</i>&nbsp;     * The seconds are calculated based on the standard definition of an hour,
<i>188</i>&nbsp;     * where each hour is 3600 seconds.
<i>189</i>&nbsp;     * The nanosecond in second field is set to zero.
<i>190</i>&nbsp;     *
<i>191</i>&nbsp;     * @param hours  the number of hours, positive or negative
<i>192</i>&nbsp;     * @return a {@code Duration}, not null
<i>193</i>&nbsp;     * @throws ArithmeticException if the input hours exceeds the capacity of {@code Duration}
<b class="nc"><i>194</i>&nbsp;     */</b>
<i>195</i>&nbsp;    public static Duration ofHours(long hours) {
<i>196</i>&nbsp;        return create(Math.multiplyExact(hours, SECONDS_PER_HOUR), 0);
<i>197</i>&nbsp;    }
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /**
<i>200</i>&nbsp;     * Obtains a {@code Duration} representing a number of standard minutes.
<i>201</i>&nbsp;     * &lt;p&gt;
<i>202</i>&nbsp;     * The seconds are calculated based on the standard definition of a minute,
<i>203</i>&nbsp;     * where each minute is 60 seconds.
<i>204</i>&nbsp;     * The nanosecond in second field is set to zero.
<i>205</i>&nbsp;     *
<i>206</i>&nbsp;     * @param minutes  the number of minutes, positive or negative
<i>207</i>&nbsp;     * @return a {@code Duration}, not null
<i>208</i>&nbsp;     * @throws ArithmeticException if the input minutes exceeds the capacity of {@code Duration}
<b class="nc"><i>209</i>&nbsp;     */</b>
<i>210</i>&nbsp;    public static Duration ofMinutes(long minutes) {
<i>211</i>&nbsp;        return create(Math.multiplyExact(minutes, SECONDS_PER_MINUTE), 0);
<i>212</i>&nbsp;    }
<i>213</i>&nbsp;
<i>214</i>&nbsp;    //-----------------------------------------------------------------------
<i>215</i>&nbsp;    /**
<i>216</i>&nbsp;     * Obtains a {@code Duration} representing a number of seconds.
<i>217</i>&nbsp;     * &lt;p&gt;
<i>218</i>&nbsp;     * The nanosecond in second field is set to zero.
<i>219</i>&nbsp;     *
<i>220</i>&nbsp;     * @param seconds  the number of seconds, positive or negative
<i>221</i>&nbsp;     * @return a {@code Duration}, not null
<b class="nc"><i>222</i>&nbsp;     */</b>
<i>223</i>&nbsp;    public static Duration ofSeconds(long seconds) {
<i>224</i>&nbsp;        return create(seconds, 0);
<i>225</i>&nbsp;    }
<i>226</i>&nbsp;
<i>227</i>&nbsp;    /**
<i>228</i>&nbsp;     * Obtains a {@code Duration} representing a number of seconds and an
<i>229</i>&nbsp;     * adjustment in nanoseconds.
<i>230</i>&nbsp;     * &lt;p&gt;
<i>231</i>&nbsp;     * This method allows an arbitrary number of nanoseconds to be passed in.
<i>232</i>&nbsp;     * The factory will alter the values of the second and nanosecond in order
<i>233</i>&nbsp;     * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
<i>234</i>&nbsp;     * For example, the following will result in exactly the same duration:
<i>235</i>&nbsp;     * &lt;pre&gt;
<i>236</i>&nbsp;     *  Duration.ofSeconds(3, 1);
<i>237</i>&nbsp;     *  Duration.ofSeconds(4, -999_999_999);
<i>238</i>&nbsp;     *  Duration.ofSeconds(2, 1000_000_001);
<i>239</i>&nbsp;     * &lt;/pre&gt;
<i>240</i>&nbsp;     *
<i>241</i>&nbsp;     * @param seconds  the number of seconds, positive or negative
<i>242</i>&nbsp;     * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
<i>243</i>&nbsp;     * @return a {@code Duration}, not null
<i>244</i>&nbsp;     * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of {@code Duration}
<b class="nc"><i>245</i>&nbsp;     */</b>
<b class="nc"><i>246</i>&nbsp;    public static Duration ofSeconds(long seconds, long nanoAdjustment) {</b>
<b class="nc"><i>247</i>&nbsp;        long secs = Math.addExact(seconds, Math.floorDiv(nanoAdjustment, NANOS_PER_SECOND));</b>
<i>248</i>&nbsp;        int nos = (int) Math.floorMod(nanoAdjustment, NANOS_PER_SECOND);
<i>249</i>&nbsp;        return create(secs, nos);
<i>250</i>&nbsp;    }
<i>251</i>&nbsp;
<i>252</i>&nbsp;    //-----------------------------------------------------------------------
<i>253</i>&nbsp;    /**
<i>254</i>&nbsp;     * Obtains a {@code Duration} representing a number of milliseconds.
<i>255</i>&nbsp;     * &lt;p&gt;
<i>256</i>&nbsp;     * The seconds and nanoseconds are extracted from the specified milliseconds.
<i>257</i>&nbsp;     *
<i>258</i>&nbsp;     * @param millis  the number of milliseconds, positive or negative
<i>259</i>&nbsp;     * @return a {@code Duration}, not null
<b class="nc"><i>260</i>&nbsp;     */</b>
<b class="nc"><i>261</i>&nbsp;    public static Duration ofMillis(long millis) {</b>
<b class="nc"><i>262</i>&nbsp;        long secs = millis / 1000;</b>
<b class="nc"><i>263</i>&nbsp;        int mos = (int) (millis % 1000);</b>
<b class="nc"><i>264</i>&nbsp;        if (mos &lt; 0) {</b>
<i>265</i>&nbsp;            mos += 1000;
<b class="nc"><i>266</i>&nbsp;            secs--;</b>
<i>267</i>&nbsp;        }
<i>268</i>&nbsp;        return create(secs, mos * 1000_000);
<i>269</i>&nbsp;    }
<i>270</i>&nbsp;
<i>271</i>&nbsp;    //-----------------------------------------------------------------------
<i>272</i>&nbsp;    /**
<i>273</i>&nbsp;     * Obtains a {@code Duration} representing a number of nanoseconds.
<i>274</i>&nbsp;     * &lt;p&gt;
<i>275</i>&nbsp;     * The seconds and nanoseconds are extracted from the specified nanoseconds.
<i>276</i>&nbsp;     *
<i>277</i>&nbsp;     * @param nanos  the number of nanoseconds, positive or negative
<i>278</i>&nbsp;     * @return a {@code Duration}, not null
<b class="nc"><i>279</i>&nbsp;     */</b>
<b class="nc"><i>280</i>&nbsp;    public static Duration ofNanos(long nanos) {</b>
<b class="nc"><i>281</i>&nbsp;        long secs = nanos / NANOS_PER_SECOND;</b>
<b class="nc"><i>282</i>&nbsp;        int nos = (int) (nanos % NANOS_PER_SECOND);</b>
<b class="nc"><i>283</i>&nbsp;        if (nos &lt; 0) {</b>
<i>284</i>&nbsp;            nos += NANOS_PER_SECOND;
<b class="nc"><i>285</i>&nbsp;            secs--;</b>
<i>286</i>&nbsp;        }
<i>287</i>&nbsp;        return create(secs, nos);
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;    //-----------------------------------------------------------------------
<i>291</i>&nbsp;    /**
<i>292</i>&nbsp;     * Obtains a {@code Duration} representing an amount in the specified unit.
<i>293</i>&nbsp;     * &lt;p&gt;
<i>294</i>&nbsp;     * The parameters represent the two parts of a phrase like &#39;6 Hours&#39;. For example:
<i>295</i>&nbsp;     * &lt;pre&gt;
<i>296</i>&nbsp;     *  Duration.of(3, SECONDS);
<i>297</i>&nbsp;     *  Duration.of(465, HOURS);
<i>298</i>&nbsp;     * &lt;/pre&gt;
<i>299</i>&nbsp;     * Only a subset of units are accepted by this method.
<i>300</i>&nbsp;     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
<i>301</i>&nbsp;     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
<i>302</i>&nbsp;     *
<i>303</i>&nbsp;     * @param amount  the amount of the duration, measured in terms of the unit, positive or negative
<i>304</i>&nbsp;     * @param unit  the unit that the duration is measured in, must have an exact duration, not null
<i>305</i>&nbsp;     * @return a {@code Duration}, not null
<i>306</i>&nbsp;     * @throws DateTimeException if the period unit has an estimated duration
<i>307</i>&nbsp;     * @throws ArithmeticException if a numeric overflow occurs
<b class="nc"><i>308</i>&nbsp;     */</b>
<i>309</i>&nbsp;    public static Duration of(long amount, TemporalUnit unit) {
<i>310</i>&nbsp;        return ZERO.plus(amount, unit);
<i>311</i>&nbsp;    }
<i>312</i>&nbsp;
<i>313</i>&nbsp;    //-----------------------------------------------------------------------
<i>314</i>&nbsp;    /**
<i>315</i>&nbsp;     * Obtains an instance of {@code Duration} from a temporal amount.
<i>316</i>&nbsp;     * &lt;p&gt;
<i>317</i>&nbsp;     * This obtains a duration based on the specified amount.
<i>318</i>&nbsp;     * A {@code TemporalAmount} represents an  amount of time, which may be
<i>319</i>&nbsp;     * date-based or time-based, which this factory extracts to a duration.
<i>320</i>&nbsp;     * &lt;p&gt;
<i>321</i>&nbsp;     * The conversion loops around the set of units from the amount and uses
<i>322</i>&nbsp;     * the {@linkplain TemporalUnit#getDuration() duration} of the unit to
<i>323</i>&nbsp;     * calculate the total {@code Duration}.
<i>324</i>&nbsp;     * Only a subset of units are accepted by this method. The unit must either
<i>325</i>&nbsp;     * have an {@linkplain TemporalUnit#isDurationEstimated() exact duration}
<i>326</i>&nbsp;     * or be {@link ChronoUnit#DAYS} which is treated as 24 hours.
<i>327</i>&nbsp;     * If any other units are found then an exception is thrown.
<i>328</i>&nbsp;     *
<i>329</i>&nbsp;     * @param amount  the temporal amount to convert, not null
<i>330</i>&nbsp;     * @return the equivalent duration, not null
<i>331</i>&nbsp;     * @throws DateTimeException if unable to convert to a {@code Duration}
<i>332</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<b class="nc"><i>333</i>&nbsp;     */</b>
<b class="nc"><i>334</i>&nbsp;    public static Duration from(TemporalAmount amount) {</b>
<b class="nc"><i>335</i>&nbsp;        Objects.requireNonNull(amount, &quot;amount&quot;);</b>
<b class="nc"><i>336</i>&nbsp;        Duration duration = ZERO;</b>
<b class="nc"><i>337</i>&nbsp;        for (TemporalUnit unit : amount.getUnits()) {</b>
<b class="nc"><i>338</i>&nbsp;            duration = duration.plus(amount.get(unit), unit);</b>
<i>339</i>&nbsp;        }
<i>340</i>&nbsp;        return duration;
<i>341</i>&nbsp;    }
<i>342</i>&nbsp;
<i>343</i>&nbsp;    //-----------------------------------------------------------------------
<i>344</i>&nbsp;    /**
<i>345</i>&nbsp;     * Obtains a {@code Duration} from a text string such as {@code PnDTnHnMn.nS}.
<i>346</i>&nbsp;     * &lt;p&gt;
<i>347</i>&nbsp;     * This will parse a textual representation of a duration, including the
<i>348</i>&nbsp;     * string produced by {@code toString()}. The formats accepted are based
<i>349</i>&nbsp;     * on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days
<i>350</i>&nbsp;     * considered to be exactly 24 hours.
<i>351</i>&nbsp;     * &lt;p&gt;
<i>352</i>&nbsp;     * The string starts with an optional sign, denoted by the ASCII negative
<i>353</i>&nbsp;     * or positive symbol. If negative, the whole period is negated.
<i>354</i>&nbsp;     * The ASCII letter &quot;P&quot; is next in upper or lower case.
<i>355</i>&nbsp;     * There are then four sections, each consisting of a number and a suffix.
<i>356</i>&nbsp;     * The sections have suffixes in ASCII of &quot;D&quot;, &quot;H&quot;, &quot;M&quot; and &quot;S&quot; for
<i>357</i>&nbsp;     * days, hours, minutes and seconds, accepted in upper or lower case.
<i>358</i>&nbsp;     * The suffixes must occur in order. The ASCII letter &quot;T&quot; must occur before
<i>359</i>&nbsp;     * the first occurrence, if any, of an hour, minute or second section.
<i>360</i>&nbsp;     * At least one of the four sections must be present, and if &quot;T&quot; is present
<i>361</i>&nbsp;     * there must be at least one section after the &quot;T&quot;.
<i>362</i>&nbsp;     * The number part of each section must consist of one or more ASCII digits.
<i>363</i>&nbsp;     * The number may be prefixed by the ASCII negative or positive symbol.
<i>364</i>&nbsp;     * The number of days, hours and minutes must parse to a {@code long}.
<i>365</i>&nbsp;     * The number of seconds must parse to a {@code long} with optional fraction.
<i>366</i>&nbsp;     * The decimal point may be either a dot or a comma.
<i>367</i>&nbsp;     * The fractional part may have from zero to 9 digits.
<i>368</i>&nbsp;     * &lt;p&gt;
<i>369</i>&nbsp;     * The leading plus/minus sign, and negative values for other units are
<i>370</i>&nbsp;     * not part of the ISO-8601 standard.
<i>371</i>&nbsp;     * &lt;p&gt;
<i>372</i>&nbsp;     * Examples:
<i>373</i>&nbsp;     * &lt;pre&gt;
<i>374</i>&nbsp;     *    &quot;PT20.345S&quot; -- parses as &quot;20.345 seconds&quot;
<i>375</i>&nbsp;     *    &quot;PT15M&quot;     -- parses as &quot;15 minutes&quot; (where a minute is 60 seconds)
<i>376</i>&nbsp;     *    &quot;PT10H&quot;     -- parses as &quot;10 hours&quot; (where an hour is 3600 seconds)
<i>377</i>&nbsp;     *    &quot;P2D&quot;       -- parses as &quot;2 days&quot; (where a day is 24 hours or 86400 seconds)
<i>378</i>&nbsp;     *    &quot;P2DT3H4M&quot;  -- parses as &quot;2 days, 3 hours and 4 minutes&quot;
<i>379</i>&nbsp;     *    &quot;PT-6H3M&quot;    -- parses as &quot;-6 hours and +3 minutes&quot;
<i>380</i>&nbsp;     *    &quot;-PT6H3M&quot;    -- parses as &quot;-6 hours and -3 minutes&quot;
<i>381</i>&nbsp;     *    &quot;-PT-6H+3M&quot;  -- parses as &quot;+6 hours and -3 minutes&quot;
<i>382</i>&nbsp;     * &lt;/pre&gt;
<i>383</i>&nbsp;     *
<i>384</i>&nbsp;     * @param text  the text to parse, not null
<i>385</i>&nbsp;     * @return the parsed duration, not null
<i>386</i>&nbsp;     * @throws DateTimeParseException if the text cannot be parsed to a duration
<b class="nc"><i>387</i>&nbsp;     */</b>
<b class="nc"><i>388</i>&nbsp;    public static Duration parse(CharSequence text) {</b>
<b class="nc"><i>389</i>&nbsp;        Objects.requireNonNull(text, &quot;text&quot;);</b>
<i>390</i>&nbsp;        Matcher matcher = Lazy.PATTERN.matcher(text);
<b class="nc"><i>391</i>&nbsp;        if (matcher.matches()) {</b>
<b class="nc"><i>392</i>&nbsp;            // check for letter T but no time sections</b>
<b class="nc"><i>393</i>&nbsp;            if (!charMatch(text, matcher.start(3), matcher.end(3), &#39;T&#39;)) {</b>
<b class="nc"><i>394</i>&nbsp;                boolean negate = charMatch(text, matcher.start(1), matcher.end(1), &#39;-&#39;);</b>
<b class="nc"><i>395</i>&nbsp;</b>
<b class="nc"><i>396</i>&nbsp;                int dayStart = matcher.start(2), dayEnd = matcher.end(2);</b>
<b class="nc"><i>397</i>&nbsp;                int hourStart = matcher.start(4), hourEnd = matcher.end(4);</b>
<b class="nc"><i>398</i>&nbsp;                int minuteStart = matcher.start(5), minuteEnd = matcher.end(5);</b>
<b class="nc"><i>399</i>&nbsp;                int secondStart = matcher.start(6), secondEnd = matcher.end(6);</b>
<b class="nc"><i>400</i>&nbsp;                int fractionStart = matcher.start(7), fractionEnd = matcher.end(7);</b>
<b class="nc"><i>401</i>&nbsp;</b>
<b class="nc"><i>402</i>&nbsp;                if (dayStart &gt;= 0 || hourStart &gt;= 0 || minuteStart &gt;= 0 || secondStart &gt;= 0) {</b>
<b class="nc"><i>403</i>&nbsp;                    long daysAsSecs = parseNumber(text, dayStart, dayEnd, SECONDS_PER_DAY, &quot;days&quot;);</b>
<i>404</i>&nbsp;                    long hoursAsSecs = parseNumber(text, hourStart, hourEnd, SECONDS_PER_HOUR, &quot;hours&quot;);
<b class="nc"><i>405</i>&nbsp;                    long minsAsSecs = parseNumber(text, minuteStart, minuteEnd, SECONDS_PER_MINUTE, &quot;minutes&quot;);</b>
<b class="nc"><i>406</i>&nbsp;                    long seconds = parseNumber(text, secondStart, secondEnd, 1, &quot;seconds&quot;);</b>
<b class="nc"><i>407</i>&nbsp;                    boolean negativeSecs = secondStart &gt;= 0 &amp;&amp; text.charAt(secondStart) == &#39;-&#39;;</b>
<i>408</i>&nbsp;                    int nanos = parseFraction(text, fractionStart, fractionEnd, negativeSecs ? -1 : 1);
<i>409</i>&nbsp;                    try {
<i>410</i>&nbsp;                        return create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
<i>411</i>&nbsp;                    } catch (ArithmeticException ex) {
<b class="nc"><i>412</i>&nbsp;                        throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: overflow&quot;, text, 0).initCause(ex);</b>
<i>413</i>&nbsp;                    }
<i>414</i>&nbsp;                }
<i>415</i>&nbsp;            }
<i>416</i>&nbsp;        }
<b class="nc"><i>417</i>&nbsp;        throw new DateTimeParseException(&quot;Text cannot be parsed to a Duration&quot;, text, 0);</b>
<b class="nc"><i>418</i>&nbsp;    }</b>
<i>419</i>&nbsp;
<i>420</i>&nbsp;    private static boolean charMatch(CharSequence text, int start, int end, char c) {
<b class="nc"><i>421</i>&nbsp;        return (start &gt;= 0 &amp;&amp; end == start + 1 &amp;&amp; text.charAt(start) == c);</b>
<b class="nc"><i>422</i>&nbsp;    }</b>
<b class="nc"><i>423</i>&nbsp;</b>
<b class="nc"><i>424</i>&nbsp;    private static long parseNumber(CharSequence text, int start, int end, int multiplier, String errorText) {</b>
<i>425</i>&nbsp;        // regex limits to [-+]?[0-9]+
<i>426</i>&nbsp;        if (start &lt; 0 || end &lt; 0) {
<i>427</i>&nbsp;            return 0;
<i>428</i>&nbsp;        }
<i>429</i>&nbsp;        try {
<b class="nc"><i>430</i>&nbsp;            long val = Long.parseLong(text, start, end, 10);</b>
<b class="nc"><i>431</i>&nbsp;            return Math.multiplyExact(val, multiplier);</b>
<i>432</i>&nbsp;        } catch (NumberFormatException | ArithmeticException ex) {
<i>433</i>&nbsp;            throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: &quot; + errorText, text, 0).initCause(ex);
<b class="nc"><i>434</i>&nbsp;        }</b>
<b class="nc"><i>435</i>&nbsp;    }</b>
<b class="nc"><i>436</i>&nbsp;</b>
<b class="nc"><i>437</i>&nbsp;    private static int parseFraction(CharSequence text, int start, int end, int negate) {</b>
<i>438</i>&nbsp;        // regex limits to [0-9]{0,9}
<i>439</i>&nbsp;        if (start &lt; 0 || end &lt; 0 || end - start == 0) {
<i>440</i>&nbsp;            return 0;
<i>441</i>&nbsp;        }
<b class="nc"><i>442</i>&nbsp;        try {</b>
<b class="nc"><i>443</i>&nbsp;            int fraction = Integer.parseInt(text, start, end, 10);</b>
<b class="nc"><i>444</i>&nbsp;</b>
<i>445</i>&nbsp;            // for number strings smaller than 9 digits, interpret as if there
<b class="nc"><i>446</i>&nbsp;            // were trailing zeros</b>
<i>447</i>&nbsp;            for (int i = end - start; i &lt; 9; i++) {
<i>448</i>&nbsp;                fraction *= 10;
<i>449</i>&nbsp;            }
<i>450</i>&nbsp;            return fraction * negate;
<i>451</i>&nbsp;        } catch (NumberFormatException | ArithmeticException ex) {
<i>452</i>&nbsp;            throw (DateTimeParseException) new DateTimeParseException(&quot;Text cannot be parsed to a Duration: fraction&quot;, text, 0).initCause(ex);
<i>453</i>&nbsp;        }
<i>454</i>&nbsp;    }
<i>455</i>&nbsp;
<i>456</i>&nbsp;    private static Duration create(boolean negate, long daysAsSecs, long hoursAsSecs, long minsAsSecs, long secs, int nanos) {
<i>457</i>&nbsp;        long seconds = Math.addExact(daysAsSecs, Math.addExact(hoursAsSecs, Math.addExact(minsAsSecs, secs)));
<i>458</i>&nbsp;        if (negate) {
<i>459</i>&nbsp;            return ofSeconds(seconds, nanos).negated();
<i>460</i>&nbsp;        }
<i>461</i>&nbsp;        return ofSeconds(seconds, nanos);
<i>462</i>&nbsp;    }
<i>463</i>&nbsp;
<i>464</i>&nbsp;    //-----------------------------------------------------------------------
<i>465</i>&nbsp;    /**
<i>466</i>&nbsp;     * Obtains a {@code Duration} representing the duration between two temporal objects.
<i>467</i>&nbsp;     * &lt;p&gt;
<i>468</i>&nbsp;     * This calculates the duration between two temporal objects. If the objects
<i>469</i>&nbsp;     * are of different types, then the duration is calculated based on the type
<i>470</i>&nbsp;     * of the first object. For example, if the first argument is a {@code LocalTime}
<i>471</i>&nbsp;     * then the second argument is converted to a {@code LocalTime}.
<i>472</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>473</i>&nbsp;     * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.</b>
<b class="nc"><i>474</i>&nbsp;     * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the</b>
<b class="nc"><i>475</i>&nbsp;     * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.</b>
<i>476</i>&nbsp;     * &lt;p&gt;
<i>477</i>&nbsp;     * The result of this method can be a negative period if the end is before the start.
<b class="nc"><i>478</i>&nbsp;     * To guarantee to obtain a positive duration call {@link #abs()} on the result.</b>
<b class="nc"><i>479</i>&nbsp;     *</b>
<b class="nc"><i>480</i>&nbsp;     * @param startInclusive  the start instant, inclusive, not null</b>
<b class="nc"><i>481</i>&nbsp;     * @param endExclusive  the end instant, exclusive, not null</b>
<b class="nc"><i>482</i>&nbsp;     * @return a {@code Duration}, not null</b>
<i>483</i>&nbsp;     * @throws DateTimeException if the seconds between the temporals cannot be obtained
<b class="nc"><i>484</i>&nbsp;     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}</b>
<b class="nc"><i>485</i>&nbsp;     */</b>
<b class="nc"><i>486</i>&nbsp;    public static Duration between(Temporal startInclusive, Temporal endExclusive) {</b>
<b class="nc"><i>487</i>&nbsp;        try {</b>
<i>488</i>&nbsp;            return ofNanos(startInclusive.until(endExclusive, NANOS));
<i>489</i>&nbsp;        } catch (DateTimeException | ArithmeticException ex) {
<i>490</i>&nbsp;            long secs = startInclusive.until(endExclusive, SECONDS);
<i>491</i>&nbsp;            long nanos;
<i>492</i>&nbsp;            try {
<i>493</i>&nbsp;                nanos = endExclusive.getLong(NANO_OF_SECOND) - startInclusive.getLong(NANO_OF_SECOND);
<i>494</i>&nbsp;                if (secs &gt; 0 &amp;&amp; nanos &lt; 0) {
<i>495</i>&nbsp;                    secs++;
<i>496</i>&nbsp;                } else if (secs &lt; 0 &amp;&amp; nanos &gt; 0) {
<i>497</i>&nbsp;                    secs--;
<i>498</i>&nbsp;                }
<b class="nc"><i>499</i>&nbsp;            } catch (DateTimeException ex2) {</b>
<b class="nc"><i>500</i>&nbsp;                nanos = 0;</b>
<i>501</i>&nbsp;            }
<b class="nc"><i>502</i>&nbsp;            return ofSeconds(secs, nanos);</b>
<i>503</i>&nbsp;        }
<i>504</i>&nbsp;    }
<i>505</i>&nbsp;
<i>506</i>&nbsp;    //-----------------------------------------------------------------------
<i>507</i>&nbsp;    /**
<i>508</i>&nbsp;     * Obtains an instance of {@code Duration} using seconds and nanoseconds.
<i>509</i>&nbsp;     *
<i>510</i>&nbsp;     * @param seconds  the length of the duration in seconds, positive or negative
<i>511</i>&nbsp;     * @param nanoAdjustment  the nanosecond adjustment within the second, from 0 to 999,999,999
<b class="nc"><i>512</i>&nbsp;     */</b>
<b class="nc"><i>513</i>&nbsp;    private static Duration create(long seconds, int nanoAdjustment) {</b>
<b class="nc"><i>514</i>&nbsp;        if ((seconds | nanoAdjustment) == 0) {</b>
<i>515</i>&nbsp;            return ZERO;
<i>516</i>&nbsp;        }
<i>517</i>&nbsp;        return new Duration(seconds, nanoAdjustment);
<i>518</i>&nbsp;    }
<i>519</i>&nbsp;
<i>520</i>&nbsp;    /**
<i>521</i>&nbsp;     * Constructs an instance of {@code Duration} using seconds and nanoseconds.
<i>522</i>&nbsp;     *
<i>523</i>&nbsp;     * @param seconds  the length of the duration in seconds, positive or negative
<i>524</i>&nbsp;     * @param nanos  the nanoseconds within the second, from 0 to 999,999,999
<i>525</i>&nbsp;     */
<i>526</i>&nbsp;    private Duration(long seconds, int nanos) {
<i>527</i>&nbsp;        super();
<i>528</i>&nbsp;        this.seconds = seconds;
<i>529</i>&nbsp;        this.nanos = nanos;
<i>530</i>&nbsp;    }
<i>531</i>&nbsp;
<b class="nc"><i>532</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>533</i>&nbsp;    /**</b>
<b class="nc"><i>534</i>&nbsp;     * Gets the value of the requested unit.</b>
<b class="nc"><i>535</i>&nbsp;     * &lt;p&gt;</b>
<i>536</i>&nbsp;     * This returns a value for each of the two supported units,
<b class="nc"><i>537</i>&nbsp;     * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.</b>
<i>538</i>&nbsp;     * All other units throw an exception.
<i>539</i>&nbsp;     *
<i>540</i>&nbsp;     * @param unit the {@code TemporalUnit} for which to return the value
<i>541</i>&nbsp;     * @return the long value of the unit
<i>542</i>&nbsp;     * @throws DateTimeException if the unit is not supported
<i>543</i>&nbsp;     * @throws UnsupportedTemporalTypeException if the unit is not supported
<i>544</i>&nbsp;     */
<i>545</i>&nbsp;    @Override
<i>546</i>&nbsp;    public long get(TemporalUnit unit) {
<i>547</i>&nbsp;        if (unit == SECONDS) {
<i>548</i>&nbsp;            return seconds;
<i>549</i>&nbsp;        } else if (unit == NANOS) {
<i>550</i>&nbsp;            return nanos;
<i>551</i>&nbsp;        } else {
<i>552</i>&nbsp;            throw new UnsupportedTemporalTypeException(&quot;Unsupported unit: &quot; + unit);
<i>553</i>&nbsp;        }
<i>554</i>&nbsp;    }
<b class="nc"><i>555</i>&nbsp;</b>
<i>556</i>&nbsp;    /**
<i>557</i>&nbsp;     * Gets the set of units supported by this duration.
<i>558</i>&nbsp;     * &lt;p&gt;
<i>559</i>&nbsp;     * The supported units are {@link ChronoUnit#SECONDS SECONDS},
<i>560</i>&nbsp;     * and {@link ChronoUnit#NANOS NANOS}.
<i>561</i>&nbsp;     * They are returned in the order seconds, nanos.
<i>562</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>563</i>&nbsp;     * This set can be used in conjunction with {@link #get(TemporalUnit)}</b>
<i>564</i>&nbsp;     * to access the entire state of the duration.
<b class="nc"><i>565</i>&nbsp;     *</b>
<i>566</i>&nbsp;     * @return a list containing the seconds and nanos units, not null
<i>567</i>&nbsp;     */
<i>568</i>&nbsp;    @Override
<i>569</i>&nbsp;    public List&lt;TemporalUnit&gt; getUnits() {
<i>570</i>&nbsp;        return DurationUnits.UNITS;
<i>571</i>&nbsp;    }
<i>572</i>&nbsp;
<i>573</i>&nbsp;    /**
<i>574</i>&nbsp;     * Private class to delay initialization of this list until needed.
<i>575</i>&nbsp;     * The circular dependency between Duration and ChronoUnit prevents
<i>576</i>&nbsp;     * the simple initialization in Duration.
<i>577</i>&nbsp;     */
<i>578</i>&nbsp;    private static class DurationUnits {
<b class="nc"><i>579</i>&nbsp;        static final List&lt;TemporalUnit&gt; UNITS = List.of(SECONDS, NANOS);</b>
<i>580</i>&nbsp;    }
<i>581</i>&nbsp;
<i>582</i>&nbsp;    //-----------------------------------------------------------------------
<i>583</i>&nbsp;    /**
<i>584</i>&nbsp;     * Checks if this duration is zero length.
<i>585</i>&nbsp;     * &lt;p&gt;
<i>586</i>&nbsp;     * A {@code Duration} represents a directed distance between two points on
<i>587</i>&nbsp;     * the time-line and can therefore be positive, zero or negative.
<i>588</i>&nbsp;     * This method checks whether the length is zero.
<i>589</i>&nbsp;     *
<i>590</i>&nbsp;     * @return true if this duration has a total length equal to zero
<i>591</i>&nbsp;     */
<b class="nc"><i>592</i>&nbsp;    public boolean isZero() {</b>
<i>593</i>&nbsp;        return (seconds | nanos) == 0;
<i>594</i>&nbsp;    }
<i>595</i>&nbsp;
<i>596</i>&nbsp;    /**
<i>597</i>&nbsp;     * Checks if this duration is negative, excluding zero.
<i>598</i>&nbsp;     * &lt;p&gt;
<i>599</i>&nbsp;     * A {@code Duration} represents a directed distance between two points on
<i>600</i>&nbsp;     * the time-line and can therefore be positive, zero or negative.
<i>601</i>&nbsp;     * This method checks whether the length is less than zero.
<i>602</i>&nbsp;     *
<i>603</i>&nbsp;     * @return true if this duration has a total length less than zero
<i>604</i>&nbsp;     */
<i>605</i>&nbsp;    public boolean isNegative() {
<i>606</i>&nbsp;        return seconds &lt; 0;
<i>607</i>&nbsp;    }
<i>608</i>&nbsp;
<i>609</i>&nbsp;    //-----------------------------------------------------------------------
<i>610</i>&nbsp;    /**
<b class="nc"><i>611</i>&nbsp;     * Gets the number of seconds in this duration.</b>
<i>612</i>&nbsp;     * &lt;p&gt;
<i>613</i>&nbsp;     * The length of the duration is stored using two fields - seconds and nanoseconds.
<i>614</i>&nbsp;     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
<i>615</i>&nbsp;     * the length in seconds.
<i>616</i>&nbsp;     * The total duration is defined by calling this method and {@link #getNano()}.
<i>617</i>&nbsp;     * &lt;p&gt;
<i>618</i>&nbsp;     * A {@code Duration} represents a directed distance between two points on the time-line.
<i>619</i>&nbsp;     * A negative duration is expressed by the negative sign of the seconds part.
<i>620</i>&nbsp;     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
<i>621</i>&nbsp;     *
<i>622</i>&nbsp;     * @return the whole seconds part of the length of the duration, positive or negative
<i>623</i>&nbsp;     */
<i>624</i>&nbsp;    public long getSeconds() {
<i>625</i>&nbsp;        return seconds;
<i>626</i>&nbsp;    }
<i>627</i>&nbsp;
<i>628</i>&nbsp;    /**
<b class="nc"><i>629</i>&nbsp;     * Gets the number of nanoseconds within the second in this duration.</b>
<i>630</i>&nbsp;     * &lt;p&gt;
<i>631</i>&nbsp;     * The length of the duration is stored using two fields - seconds and nanoseconds.
<i>632</i>&nbsp;     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
<i>633</i>&nbsp;     * the length in seconds.
<i>634</i>&nbsp;     * The total duration is defined by calling this method and {@link #getSeconds()}.
<i>635</i>&nbsp;     * &lt;p&gt;
<i>636</i>&nbsp;     * A {@code Duration} represents a directed distance between two points on the time-line.
<i>637</i>&nbsp;     * A negative duration is expressed by the negative sign of the seconds part.
<i>638</i>&nbsp;     * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
<i>639</i>&nbsp;     *
<i>640</i>&nbsp;     * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
<i>641</i>&nbsp;     */
<i>642</i>&nbsp;    public int getNano() {
<i>643</i>&nbsp;        return nanos;
<i>644</i>&nbsp;    }
<b class="nc"><i>645</i>&nbsp;</b>
<i>646</i>&nbsp;    //-----------------------------------------------------------------------
<i>647</i>&nbsp;    /**
<i>648</i>&nbsp;     * Returns a copy of this duration with the specified amount of seconds.
<i>649</i>&nbsp;     * &lt;p&gt;
<i>650</i>&nbsp;     * This returns a duration with the specified seconds, retaining the
<i>651</i>&nbsp;     * nano-of-second part of this duration.
<i>652</i>&nbsp;     * &lt;p&gt;
<i>653</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>654</i>&nbsp;     *
<i>655</i>&nbsp;     * @param seconds  the seconds to represent, may be negative
<i>656</i>&nbsp;     * @return a {@code Duration} based on this period with the requested seconds, not null
<i>657</i>&nbsp;     */
<i>658</i>&nbsp;    public Duration withSeconds(long seconds) {
<i>659</i>&nbsp;        return create(seconds, nanos);
<i>660</i>&nbsp;    }
<b class="nc"><i>661</i>&nbsp;</b>
<b class="nc"><i>662</i>&nbsp;    /**</b>
<i>663</i>&nbsp;     * Returns a copy of this duration with the specified nano-of-second.
<i>664</i>&nbsp;     * &lt;p&gt;
<i>665</i>&nbsp;     * This returns a duration with the specified nano-of-second, retaining the
<i>666</i>&nbsp;     * seconds part of this duration.
<i>667</i>&nbsp;     * &lt;p&gt;
<i>668</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>669</i>&nbsp;     *
<i>670</i>&nbsp;     * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
<i>671</i>&nbsp;     * @return a {@code Duration} based on this period with the requested nano-of-second, not null
<i>672</i>&nbsp;     * @throws DateTimeException if the nano-of-second is invalid
<i>673</i>&nbsp;     */
<i>674</i>&nbsp;    public Duration withNanos(int nanoOfSecond) {
<i>675</i>&nbsp;        NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
<b class="nc"><i>676</i>&nbsp;        return create(seconds, nanoOfSecond);</b>
<i>677</i>&nbsp;    }
<i>678</i>&nbsp;
<i>679</i>&nbsp;    //-----------------------------------------------------------------------
<i>680</i>&nbsp;    /**
<i>681</i>&nbsp;     * Returns a copy of this duration with the specified duration added.
<i>682</i>&nbsp;     * &lt;p&gt;
<i>683</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>684</i>&nbsp;     *
<i>685</i>&nbsp;     * @param duration  the duration to add, positive or negative, not null
<i>686</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified duration added, not null
<i>687</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>688</i>&nbsp;     */
<i>689</i>&nbsp;    public Duration plus(Duration duration) {
<i>690</i>&nbsp;        return plus(duration.getSeconds(), duration.getNano());
<i>691</i>&nbsp;     }
<i>692</i>&nbsp;
<i>693</i>&nbsp;    /**
<i>694</i>&nbsp;     * Returns a copy of this duration with the specified duration added.
<i>695</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>696</i>&nbsp;     * The duration amount is measured in terms of the specified unit.</b>
<b class="nc"><i>697</i>&nbsp;     * Only a subset of units are accepted by this method.</b>
<b class="nc"><i>698</i>&nbsp;     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or</b>
<i>699</i>&nbsp;     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
<b class="nc"><i>700</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>701</i>&nbsp;     * This instance is immutable and unaffected by this method call.</b>
<i>702</i>&nbsp;     *
<b class="nc"><i>703</i>&nbsp;     * @param amountToAdd  the amount to add, measured in terms of the unit, positive or negative</b>
<b class="nc"><i>704</i>&nbsp;     * @param unit  the unit that the amount is measured in, must have an exact duration, not null</b>
<i>705</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified duration added, not null
<b class="nc"><i>706</i>&nbsp;     * @throws UnsupportedTemporalTypeException if the unit is not supported</b>
<b class="nc"><i>707</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs</b>
<b class="nc"><i>708</i>&nbsp;     */</b>
<b class="nc"><i>709</i>&nbsp;    public Duration plus(long amountToAdd, TemporalUnit unit) {</b>
<b class="nc"><i>710</i>&nbsp;        Objects.requireNonNull(unit, &quot;unit&quot;);</b>
<b class="nc"><i>711</i>&nbsp;        if (unit == DAYS) {</b>
<i>712</i>&nbsp;            return plus(Math.multiplyExact(amountToAdd, SECONDS_PER_DAY), 0);
<b class="nc"><i>713</i>&nbsp;        }</b>
<i>714</i>&nbsp;        if (unit.isDurationEstimated()) {
<b class="nc"><i>715</i>&nbsp;            throw new UnsupportedTemporalTypeException(&quot;Unit must not have an estimated duration&quot;);</b>
<b class="nc"><i>716</i>&nbsp;        }</b>
<i>717</i>&nbsp;        if (amountToAdd == 0) {
<i>718</i>&nbsp;            return this;
<i>719</i>&nbsp;        }
<i>720</i>&nbsp;        if (unit instanceof ChronoUnit) {
<i>721</i>&nbsp;            switch ((ChronoUnit) unit) {
<i>722</i>&nbsp;                case NANOS: return plusNanos(amountToAdd);
<i>723</i>&nbsp;                case MICROS: return plusSeconds((amountToAdd / (1000_000L * 1000)) * 1000).plusNanos((amountToAdd % (1000_000L * 1000)) * 1000);
<i>724</i>&nbsp;                case MILLIS: return plusMillis(amountToAdd);
<i>725</i>&nbsp;                case SECONDS: return plusSeconds(amountToAdd);
<i>726</i>&nbsp;            }
<i>727</i>&nbsp;            return plusSeconds(Math.multiplyExact(unit.getDuration().seconds, amountToAdd));
<i>728</i>&nbsp;        }
<i>729</i>&nbsp;        Duration duration = unit.getDuration().multipliedBy(amountToAdd);
<i>730</i>&nbsp;        return plusSeconds(duration.getSeconds()).plusNanos(duration.getNano());
<i>731</i>&nbsp;    }
<i>732</i>&nbsp;
<b class="nc"><i>733</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>734</i>&nbsp;    /**
<i>735</i>&nbsp;     * Returns a copy of this duration with the specified duration in standard 24 hour days added.
<i>736</i>&nbsp;     * &lt;p&gt;
<i>737</i>&nbsp;     * The number of days is multiplied by 86400 to obtain the number of seconds to add.
<i>738</i>&nbsp;     * This is based on the standard definition of a day as 24 hours.
<i>739</i>&nbsp;     * &lt;p&gt;
<i>740</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>741</i>&nbsp;     *
<i>742</i>&nbsp;     * @param daysToAdd  the days to add, positive or negative
<i>743</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified days added, not null
<i>744</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>745</i>&nbsp;     */
<b class="nc"><i>746</i>&nbsp;    public Duration plusDays(long daysToAdd) {</b>
<i>747</i>&nbsp;        return plus(Math.multiplyExact(daysToAdd, SECONDS_PER_DAY), 0);
<i>748</i>&nbsp;    }
<i>749</i>&nbsp;
<i>750</i>&nbsp;    /**
<i>751</i>&nbsp;     * Returns a copy of this duration with the specified duration in hours added.
<i>752</i>&nbsp;     * &lt;p&gt;
<i>753</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>754</i>&nbsp;     *
<i>755</i>&nbsp;     * @param hoursToAdd  the hours to add, positive or negative
<i>756</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified hours added, not null
<i>757</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>758</i>&nbsp;     */
<b class="nc"><i>759</i>&nbsp;    public Duration plusHours(long hoursToAdd) {</b>
<i>760</i>&nbsp;        return plus(Math.multiplyExact(hoursToAdd, SECONDS_PER_HOUR), 0);
<i>761</i>&nbsp;    }
<i>762</i>&nbsp;
<i>763</i>&nbsp;    /**
<i>764</i>&nbsp;     * Returns a copy of this duration with the specified duration in minutes added.
<i>765</i>&nbsp;     * &lt;p&gt;
<i>766</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>767</i>&nbsp;     *
<i>768</i>&nbsp;     * @param minutesToAdd  the minutes to add, positive or negative
<i>769</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified minutes added, not null
<i>770</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>771</i>&nbsp;     */
<b class="nc"><i>772</i>&nbsp;    public Duration plusMinutes(long minutesToAdd) {</b>
<i>773</i>&nbsp;        return plus(Math.multiplyExact(minutesToAdd, SECONDS_PER_MINUTE), 0);
<i>774</i>&nbsp;    }
<i>775</i>&nbsp;
<i>776</i>&nbsp;    /**
<i>777</i>&nbsp;     * Returns a copy of this duration with the specified duration in seconds added.
<i>778</i>&nbsp;     * &lt;p&gt;
<i>779</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>780</i>&nbsp;     *
<i>781</i>&nbsp;     * @param secondsToAdd  the seconds to add, positive or negative
<i>782</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified seconds added, not null
<i>783</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>784</i>&nbsp;     */
<b class="nc"><i>785</i>&nbsp;    public Duration plusSeconds(long secondsToAdd) {</b>
<i>786</i>&nbsp;        return plus(secondsToAdd, 0);
<i>787</i>&nbsp;    }
<i>788</i>&nbsp;
<i>789</i>&nbsp;    /**
<i>790</i>&nbsp;     * Returns a copy of this duration with the specified duration in milliseconds added.
<i>791</i>&nbsp;     * &lt;p&gt;
<i>792</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>793</i>&nbsp;     *
<i>794</i>&nbsp;     * @param millisToAdd  the milliseconds to add, positive or negative
<i>795</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified milliseconds added, not null
<i>796</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>797</i>&nbsp;     */
<b class="nc"><i>798</i>&nbsp;    public Duration plusMillis(long millisToAdd) {</b>
<i>799</i>&nbsp;        return plus(millisToAdd / 1000, (millisToAdd % 1000) * 1000_000);
<i>800</i>&nbsp;    }
<i>801</i>&nbsp;
<i>802</i>&nbsp;    /**
<i>803</i>&nbsp;     * Returns a copy of this duration with the specified duration in nanoseconds added.
<i>804</i>&nbsp;     * &lt;p&gt;
<i>805</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>806</i>&nbsp;     *
<i>807</i>&nbsp;     * @param nanosToAdd  the nanoseconds to add, positive or negative
<i>808</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified nanoseconds added, not null
<i>809</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>810</i>&nbsp;     */
<i>811</i>&nbsp;    public Duration plusNanos(long nanosToAdd) {
<b class="nc"><i>812</i>&nbsp;        return plus(0, nanosToAdd);</b>
<b class="nc"><i>813</i>&nbsp;    }</b>
<i>814</i>&nbsp;
<b class="nc"><i>815</i>&nbsp;    /**</b>
<b class="nc"><i>816</i>&nbsp;     * Returns a copy of this duration with the specified duration added.</b>
<b class="nc"><i>817</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>818</i>&nbsp;     * This instance is immutable and unaffected by this method call.</b>
<b class="nc"><i>819</i>&nbsp;     *</b>
<i>820</i>&nbsp;     * @param secondsToAdd  the seconds to add, positive or negative
<i>821</i>&nbsp;     * @param nanosToAdd  the nanos to add, positive or negative
<i>822</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified seconds added, not null
<i>823</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>824</i>&nbsp;     */
<i>825</i>&nbsp;    private Duration plus(long secondsToAdd, long nanosToAdd) {
<i>826</i>&nbsp;        if ((secondsToAdd | nanosToAdd) == 0) {
<i>827</i>&nbsp;            return this;
<i>828</i>&nbsp;        }
<i>829</i>&nbsp;        long epochSec = Math.addExact(seconds, secondsToAdd);
<i>830</i>&nbsp;        epochSec = Math.addExact(epochSec, nanosToAdd / NANOS_PER_SECOND);
<i>831</i>&nbsp;        nanosToAdd = nanosToAdd % NANOS_PER_SECOND;
<i>832</i>&nbsp;        long nanoAdjustment = nanos + nanosToAdd;  // safe int+NANOS_PER_SECOND
<b class="nc"><i>833</i>&nbsp;        return ofSeconds(epochSec, nanoAdjustment);</b>
<b class="nc"><i>834</i>&nbsp;    }</b>
<b class="nc"><i>835</i>&nbsp;</b>
<b class="nc"><i>836</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>837</i>&nbsp;    /**
<b class="nc"><i>838</i>&nbsp;     * Returns a copy of this duration with the specified duration subtracted.</b>
<i>839</i>&nbsp;     * &lt;p&gt;
<i>840</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>841</i>&nbsp;     *
<i>842</i>&nbsp;     * @param duration  the duration to subtract, positive or negative, not null
<i>843</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
<i>844</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>845</i>&nbsp;     */
<i>846</i>&nbsp;    public Duration minus(Duration duration) {
<i>847</i>&nbsp;        long secsToSubtract = duration.getSeconds();
<i>848</i>&nbsp;        int nanosToSubtract = duration.getNano();
<i>849</i>&nbsp;        if (secsToSubtract == Long.MIN_VALUE) {
<i>850</i>&nbsp;            return plus(Long.MAX_VALUE, -nanosToSubtract).plus(1, 0);
<i>851</i>&nbsp;        }
<i>852</i>&nbsp;        return plus(-secsToSubtract, -nanosToSubtract);
<i>853</i>&nbsp;     }
<i>854</i>&nbsp;
<i>855</i>&nbsp;    /**
<i>856</i>&nbsp;     * Returns a copy of this duration with the specified duration subtracted.
<b class="nc"><i>857</i>&nbsp;     * &lt;p&gt;</b>
<i>858</i>&nbsp;     * The duration amount is measured in terms of the specified unit.
<i>859</i>&nbsp;     * Only a subset of units are accepted by this method.
<i>860</i>&nbsp;     * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
<i>861</i>&nbsp;     * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
<i>862</i>&nbsp;     * &lt;p&gt;
<i>863</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>864</i>&nbsp;     *
<i>865</i>&nbsp;     * @param amountToSubtract  the amount to subtract, measured in terms of the unit, positive or negative
<i>866</i>&nbsp;     * @param unit  the unit that the amount is measured in, must have an exact duration, not null
<i>867</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified duration subtracted, not null
<i>868</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>869</i>&nbsp;     */
<i>870</i>&nbsp;    public Duration minus(long amountToSubtract, TemporalUnit unit) {
<i>871</i>&nbsp;        return (amountToSubtract == Long.MIN_VALUE ? plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
<i>872</i>&nbsp;    }
<i>873</i>&nbsp;
<b class="nc"><i>874</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>875</i>&nbsp;    /**
<i>876</i>&nbsp;     * Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.
<i>877</i>&nbsp;     * &lt;p&gt;
<i>878</i>&nbsp;     * The number of days is multiplied by 86400 to obtain the number of seconds to subtract.
<i>879</i>&nbsp;     * This is based on the standard definition of a day as 24 hours.
<i>880</i>&nbsp;     * &lt;p&gt;
<i>881</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>882</i>&nbsp;     *
<i>883</i>&nbsp;     * @param daysToSubtract  the days to subtract, positive or negative
<i>884</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified days subtracted, not null
<i>885</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>886</i>&nbsp;     */
<i>887</i>&nbsp;    public Duration minusDays(long daysToSubtract) {
<i>888</i>&nbsp;        return (daysToSubtract == Long.MIN_VALUE ? plusDays(Long.MAX_VALUE).plusDays(1) : plusDays(-daysToSubtract));
<b class="nc"><i>889</i>&nbsp;    }</b>
<i>890</i>&nbsp;
<i>891</i>&nbsp;    /**
<i>892</i>&nbsp;     * Returns a copy of this duration with the specified duration in hours subtracted.
<i>893</i>&nbsp;     * &lt;p&gt;
<i>894</i>&nbsp;     * The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.
<i>895</i>&nbsp;     * &lt;p&gt;
<i>896</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>897</i>&nbsp;     *
<i>898</i>&nbsp;     * @param hoursToSubtract  the hours to subtract, positive or negative
<i>899</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified hours subtracted, not null
<i>900</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>901</i>&nbsp;     */
<i>902</i>&nbsp;    public Duration minusHours(long hoursToSubtract) {
<i>903</i>&nbsp;        return (hoursToSubtract == Long.MIN_VALUE ? plusHours(Long.MAX_VALUE).plusHours(1) : plusHours(-hoursToSubtract));
<b class="nc"><i>904</i>&nbsp;    }</b>
<i>905</i>&nbsp;
<i>906</i>&nbsp;    /**
<i>907</i>&nbsp;     * Returns a copy of this duration with the specified duration in minutes subtracted.
<i>908</i>&nbsp;     * &lt;p&gt;
<i>909</i>&nbsp;     * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.
<i>910</i>&nbsp;     * &lt;p&gt;
<i>911</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>912</i>&nbsp;     *
<i>913</i>&nbsp;     * @param minutesToSubtract  the minutes to subtract, positive or negative
<i>914</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified minutes subtracted, not null
<i>915</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>916</i>&nbsp;     */
<b class="nc"><i>917</i>&nbsp;    public Duration minusMinutes(long minutesToSubtract) {</b>
<i>918</i>&nbsp;        return (minutesToSubtract == Long.MIN_VALUE ? plusMinutes(Long.MAX_VALUE).plusMinutes(1) : plusMinutes(-minutesToSubtract));
<i>919</i>&nbsp;    }
<i>920</i>&nbsp;
<i>921</i>&nbsp;    /**
<i>922</i>&nbsp;     * Returns a copy of this duration with the specified duration in seconds subtracted.
<i>923</i>&nbsp;     * &lt;p&gt;
<i>924</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>925</i>&nbsp;     *
<i>926</i>&nbsp;     * @param secondsToSubtract  the seconds to subtract, positive or negative
<i>927</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified seconds subtracted, not null
<i>928</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>929</i>&nbsp;     */
<b class="nc"><i>930</i>&nbsp;    public Duration minusSeconds(long secondsToSubtract) {</b>
<i>931</i>&nbsp;        return (secondsToSubtract == Long.MIN_VALUE ? plusSeconds(Long.MAX_VALUE).plusSeconds(1) : plusSeconds(-secondsToSubtract));
<i>932</i>&nbsp;    }
<i>933</i>&nbsp;
<i>934</i>&nbsp;    /**
<i>935</i>&nbsp;     * Returns a copy of this duration with the specified duration in milliseconds subtracted.
<i>936</i>&nbsp;     * &lt;p&gt;
<i>937</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>938</i>&nbsp;     *
<i>939</i>&nbsp;     * @param millisToSubtract  the milliseconds to subtract, positive or negative
<i>940</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified milliseconds subtracted, not null
<i>941</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>942</i>&nbsp;     */
<b class="nc"><i>943</i>&nbsp;    public Duration minusMillis(long millisToSubtract) {</b>
<i>944</i>&nbsp;        return (millisToSubtract == Long.MIN_VALUE ? plusMillis(Long.MAX_VALUE).plusMillis(1) : plusMillis(-millisToSubtract));
<i>945</i>&nbsp;    }
<i>946</i>&nbsp;
<i>947</i>&nbsp;    /**
<i>948</i>&nbsp;     * Returns a copy of this duration with the specified duration in nanoseconds subtracted.
<i>949</i>&nbsp;     * &lt;p&gt;
<i>950</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>951</i>&nbsp;     *
<i>952</i>&nbsp;     * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
<i>953</i>&nbsp;     * @return a {@code Duration} based on this duration with the specified nanoseconds subtracted, not null
<i>954</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>955</i>&nbsp;     */
<i>956</i>&nbsp;    public Duration minusNanos(long nanosToSubtract) {
<b class="nc"><i>957</i>&nbsp;        return (nanosToSubtract == Long.MIN_VALUE ? plusNanos(Long.MAX_VALUE).plusNanos(1) : plusNanos(-nanosToSubtract));</b>
<b class="nc"><i>958</i>&nbsp;    }</b>
<i>959</i>&nbsp;
<b class="nc"><i>960</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>961</i>&nbsp;    /**</b>
<i>962</i>&nbsp;     * Returns a copy of this duration multiplied by the scalar.
<b class="nc"><i>963</i>&nbsp;     * &lt;p&gt;</b>
<i>964</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>965</i>&nbsp;     *
<i>966</i>&nbsp;     * @param multiplicand  the value to multiply the duration by, positive or negative
<i>967</i>&nbsp;     * @return a {@code Duration} based on this duration multiplied by the specified scalar, not null
<i>968</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>969</i>&nbsp;     */
<i>970</i>&nbsp;    public Duration multipliedBy(long multiplicand) {
<i>971</i>&nbsp;        if (multiplicand == 0) {
<i>972</i>&nbsp;            return ZERO;
<i>973</i>&nbsp;        }
<i>974</i>&nbsp;        if (multiplicand == 1) {
<i>975</i>&nbsp;            return this;
<b class="nc"><i>976</i>&nbsp;        }</b>
<b class="nc"><i>977</i>&nbsp;        return create(toBigDecimalSeconds().multiply(BigDecimal.valueOf(multiplicand)));</b>
<i>978</i>&nbsp;     }
<b class="nc"><i>979</i>&nbsp;</b>
<b class="nc"><i>980</i>&nbsp;    /**</b>
<i>981</i>&nbsp;     * Returns a copy of this duration divided by the specified value.
<b class="nc"><i>982</i>&nbsp;     * &lt;p&gt;</b>
<i>983</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>984</i>&nbsp;     *
<i>985</i>&nbsp;     * @param divisor  the value to divide the duration by, positive or negative, not zero
<i>986</i>&nbsp;     * @return a {@code Duration} based on this duration divided by the specified divisor, not null
<i>987</i>&nbsp;     * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs
<i>988</i>&nbsp;     */
<i>989</i>&nbsp;    public Duration dividedBy(long divisor) {
<i>990</i>&nbsp;        if (divisor == 0) {
<i>991</i>&nbsp;            throw new ArithmeticException(&quot;Cannot divide by zero&quot;);
<b class="nc"><i>992</i>&nbsp;        }</b>
<i>993</i>&nbsp;        if (divisor == 1) {
<i>994</i>&nbsp;            return this;
<i>995</i>&nbsp;        }
<i>996</i>&nbsp;        return create(toBigDecimalSeconds().divide(BigDecimal.valueOf(divisor), RoundingMode.DOWN));
<i>997</i>&nbsp;     }
<i>998</i>&nbsp;
<i>999</i>&nbsp;    /**
<i>1000</i>&nbsp;     * Returns number of whole times a specified Duration occurs within this Duration.
<i>1001</i>&nbsp;     * &lt;p&gt;
<i>1002</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<b class="nc"><i>1003</i>&nbsp;     *</b>
<b class="nc"><i>1004</i>&nbsp;     * @param divisor the value to divide the duration by, positive or negative, not null</b>
<b class="nc"><i>1005</i>&nbsp;     * @return number of whole times, rounded toward zero, a specified</b>
<b class="nc"><i>1006</i>&nbsp;     *         {@code Duration} occurs within this Duration, may be negative</b>
<i>1007</i>&nbsp;     * @throws ArithmeticException if the divisor is zero, or if numeric overflow occurs
<b class="nc"><i>1008</i>&nbsp;     * @since 9</b>
<i>1009</i>&nbsp;     */
<i>1010</i>&nbsp;    public long dividedBy(Duration divisor) {
<i>1011</i>&nbsp;        Objects.requireNonNull(divisor, &quot;divisor&quot;);
<i>1012</i>&nbsp;        BigDecimal dividendBigD = toBigDecimalSeconds();
<i>1013</i>&nbsp;        BigDecimal divisorBigD = divisor.toBigDecimalSeconds();
<i>1014</i>&nbsp;        return dividendBigD.divideToIntegralValue(divisorBigD).longValueExact();
<i>1015</i>&nbsp;    }
<i>1016</i>&nbsp;
<i>1017</i>&nbsp;    /**
<i>1018</i>&nbsp;     * Converts this duration to the total length in seconds and
<i>1019</i>&nbsp;     * fractional nanoseconds expressed as a {@code BigDecimal}.
<i>1020</i>&nbsp;     *
<i>1021</i>&nbsp;     * @return the total length of the duration in seconds, with a scale of 9, not null
<i>1022</i>&nbsp;     */
<i>1023</i>&nbsp;    private BigDecimal toBigDecimalSeconds() {
<b class="nc"><i>1024</i>&nbsp;        return BigDecimal.valueOf(seconds).add(BigDecimal.valueOf(nanos, 9));</b>
<i>1025</i>&nbsp;    }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;    /**
<i>1028</i>&nbsp;     * Creates an instance of {@code Duration} from a number of seconds.
<i>1029</i>&nbsp;     *
<i>1030</i>&nbsp;     * @param seconds  the number of seconds, up to scale 9, positive or negative
<i>1031</i>&nbsp;     * @return a {@code Duration}, not null
<i>1032</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1033</i>&nbsp;     */
<i>1034</i>&nbsp;    private static Duration create(BigDecimal seconds) {
<i>1035</i>&nbsp;        BigInteger nanos = seconds.movePointRight(9).toBigIntegerExact();
<i>1036</i>&nbsp;        BigInteger[] divRem = nanos.divideAndRemainder(BI_NANOS_PER_SECOND);
<i>1037</i>&nbsp;        if (divRem[0].bitLength() &gt; 63) {
<i>1038</i>&nbsp;            throw new ArithmeticException(&quot;Exceeds capacity of Duration: &quot; + nanos);
<b class="nc"><i>1039</i>&nbsp;        }</b>
<i>1040</i>&nbsp;        return ofSeconds(divRem[0].longValue(), divRem[1].intValue());
<i>1041</i>&nbsp;    }
<i>1042</i>&nbsp;
<i>1043</i>&nbsp;    //-----------------------------------------------------------------------
<i>1044</i>&nbsp;    /**
<i>1045</i>&nbsp;     * Returns a copy of this duration with the length negated.
<i>1046</i>&nbsp;     * &lt;p&gt;
<i>1047</i>&nbsp;     * This method swaps the sign of the total length of this duration.
<i>1048</i>&nbsp;     * For example, {@code PT1.3S} will be returned as {@code PT-1.3S}.
<i>1049</i>&nbsp;     * &lt;p&gt;
<i>1050</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1051</i>&nbsp;     *
<i>1052</i>&nbsp;     * @return a {@code Duration} based on this duration with the amount negated, not null
<i>1053</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1054</i>&nbsp;     */
<i>1055</i>&nbsp;    public Duration negated() {
<i>1056</i>&nbsp;        return multipliedBy(-1);
<i>1057</i>&nbsp;    }
<i>1058</i>&nbsp;
<i>1059</i>&nbsp;    /**
<i>1060</i>&nbsp;     * Returns a copy of this duration with a positive length.
<i>1061</i>&nbsp;     * &lt;p&gt;
<i>1062</i>&nbsp;     * This method returns a positive duration by effectively removing the sign from any negative total length.
<i>1063</i>&nbsp;     * For example, {@code PT-1.3S} will be returned as {@code PT1.3S}.
<i>1064</i>&nbsp;     * &lt;p&gt;
<i>1065</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1066</i>&nbsp;     *
<i>1067</i>&nbsp;     * @return a {@code Duration} based on this duration with an absolute length, not null
<i>1068</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<b class="nc"><i>1069</i>&nbsp;     */</b>
<b class="nc"><i>1070</i>&nbsp;    public Duration abs() {</b>
<i>1071</i>&nbsp;        return isNegative() ? negated() : this;
<b class="nc"><i>1072</i>&nbsp;    }</b>
<b class="nc"><i>1073</i>&nbsp;</b>
<i>1074</i>&nbsp;    //-------------------------------------------------------------------------
<b class="nc"><i>1075</i>&nbsp;    /**</b>
<i>1076</i>&nbsp;     * Adds this duration to the specified temporal object.
<i>1077</i>&nbsp;     * &lt;p&gt;
<i>1078</i>&nbsp;     * This returns a temporal object of the same observable type as the input
<i>1079</i>&nbsp;     * with this duration added.
<i>1080</i>&nbsp;     * &lt;p&gt;
<i>1081</i>&nbsp;     * In most cases, it is clearer to reverse the calling pattern by using
<i>1082</i>&nbsp;     * {@link Temporal#plus(TemporalAmount)}.
<i>1083</i>&nbsp;     * &lt;pre&gt;
<i>1084</i>&nbsp;     *   // these two lines are equivalent, but the second approach is recommended
<i>1085</i>&nbsp;     *   dateTime = thisDuration.addTo(dateTime);
<i>1086</i>&nbsp;     *   dateTime = dateTime.plus(thisDuration);
<i>1087</i>&nbsp;     * &lt;/pre&gt;
<i>1088</i>&nbsp;     * &lt;p&gt;
<i>1089</i>&nbsp;     * The calculation will add the seconds, then nanos.
<i>1090</i>&nbsp;     * Only non-zero amounts will be added.
<i>1091</i>&nbsp;     * &lt;p&gt;
<i>1092</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1093</i>&nbsp;     *
<i>1094</i>&nbsp;     * @param temporal  the temporal object to adjust, not null
<i>1095</i>&nbsp;     * @return an object of the same type with the adjustment made, not null
<i>1096</i>&nbsp;     * @throws DateTimeException if unable to add
<i>1097</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1098</i>&nbsp;     */
<i>1099</i>&nbsp;    @Override
<i>1100</i>&nbsp;    public Temporal addTo(Temporal temporal) {
<i>1101</i>&nbsp;        if (seconds != 0) {
<i>1102</i>&nbsp;            temporal = temporal.plus(seconds, SECONDS);
<i>1103</i>&nbsp;        }
<b class="nc"><i>1104</i>&nbsp;        if (nanos != 0) {</b>
<b class="nc"><i>1105</i>&nbsp;            temporal = temporal.plus(nanos, NANOS);</b>
<i>1106</i>&nbsp;        }
<b class="nc"><i>1107</i>&nbsp;        return temporal;</b>
<b class="nc"><i>1108</i>&nbsp;    }</b>
<i>1109</i>&nbsp;
<b class="nc"><i>1110</i>&nbsp;    /**</b>
<i>1111</i>&nbsp;     * Subtracts this duration from the specified temporal object.
<i>1112</i>&nbsp;     * &lt;p&gt;
<i>1113</i>&nbsp;     * This returns a temporal object of the same observable type as the input
<i>1114</i>&nbsp;     * with this duration subtracted.
<i>1115</i>&nbsp;     * &lt;p&gt;
<i>1116</i>&nbsp;     * In most cases, it is clearer to reverse the calling pattern by using
<i>1117</i>&nbsp;     * {@link Temporal#minus(TemporalAmount)}.
<i>1118</i>&nbsp;     * &lt;pre&gt;
<i>1119</i>&nbsp;     *   // these two lines are equivalent, but the second approach is recommended
<i>1120</i>&nbsp;     *   dateTime = thisDuration.subtractFrom(dateTime);
<i>1121</i>&nbsp;     *   dateTime = dateTime.minus(thisDuration);
<i>1122</i>&nbsp;     * &lt;/pre&gt;
<i>1123</i>&nbsp;     * &lt;p&gt;
<i>1124</i>&nbsp;     * The calculation will subtract the seconds, then nanos.
<i>1125</i>&nbsp;     * Only non-zero amounts will be added.
<b class="nc"><i>1126</i>&nbsp;     * &lt;p&gt;</b>
<i>1127</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1128</i>&nbsp;     *
<i>1129</i>&nbsp;     * @param temporal  the temporal object to adjust, not null
<i>1130</i>&nbsp;     * @return an object of the same type with the adjustment made, not null
<i>1131</i>&nbsp;     * @throws DateTimeException if unable to subtract
<i>1132</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1133</i>&nbsp;     */
<i>1134</i>&nbsp;    @Override
<i>1135</i>&nbsp;    public Temporal subtractFrom(Temporal temporal) {
<i>1136</i>&nbsp;        if (seconds != 0) {
<i>1137</i>&nbsp;            temporal = temporal.minus(seconds, SECONDS);
<i>1138</i>&nbsp;        }
<i>1139</i>&nbsp;        if (nanos != 0) {
<b class="nc"><i>1140</i>&nbsp;            temporal = temporal.minus(nanos, NANOS);</b>
<i>1141</i>&nbsp;        }
<i>1142</i>&nbsp;        return temporal;
<i>1143</i>&nbsp;    }
<i>1144</i>&nbsp;
<i>1145</i>&nbsp;    //-----------------------------------------------------------------------
<i>1146</i>&nbsp;    /**
<i>1147</i>&nbsp;     * Gets the number of days in this duration.
<i>1148</i>&nbsp;     * &lt;p&gt;
<i>1149</i>&nbsp;     * This returns the total number of days in the duration by dividing the
<i>1150</i>&nbsp;     * number of seconds by 86400.
<i>1151</i>&nbsp;     * This is based on the standard definition of a day as 24 hours.
<i>1152</i>&nbsp;     * &lt;p&gt;
<i>1153</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<b class="nc"><i>1154</i>&nbsp;     *</b>
<i>1155</i>&nbsp;     * @return the number of days in the duration, may be negative
<i>1156</i>&nbsp;     */
<i>1157</i>&nbsp;    public long toDays() {
<i>1158</i>&nbsp;        return seconds / SECONDS_PER_DAY;
<i>1159</i>&nbsp;    }
<i>1160</i>&nbsp;
<i>1161</i>&nbsp;    /**
<i>1162</i>&nbsp;     * Gets the number of hours in this duration.
<i>1163</i>&nbsp;     * &lt;p&gt;
<i>1164</i>&nbsp;     * This returns the total number of hours in the duration by dividing the
<i>1165</i>&nbsp;     * number of seconds by 3600.
<i>1166</i>&nbsp;     * &lt;p&gt;
<i>1167</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1168</i>&nbsp;     *
<i>1169</i>&nbsp;     * @return the number of hours in the duration, may be negative
<i>1170</i>&nbsp;     */
<b class="nc"><i>1171</i>&nbsp;    public long toHours() {</b>
<b class="nc"><i>1172</i>&nbsp;        return seconds / SECONDS_PER_HOUR;</b>
<b class="nc"><i>1173</i>&nbsp;    }</b>
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;    /**
<i>1176</i>&nbsp;     * Gets the number of minutes in this duration.
<i>1177</i>&nbsp;     * &lt;p&gt;
<i>1178</i>&nbsp;     * This returns the total number of minutes in the duration by dividing the
<i>1179</i>&nbsp;     * number of seconds by 60.
<i>1180</i>&nbsp;     * &lt;p&gt;
<i>1181</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1182</i>&nbsp;     *
<i>1183</i>&nbsp;     * @return the number of minutes in the duration, may be negative
<i>1184</i>&nbsp;     */
<i>1185</i>&nbsp;    public long toMinutes() {
<b class="nc"><i>1186</i>&nbsp;        return seconds / SECONDS_PER_MINUTE;</b>
<b class="nc"><i>1187</i>&nbsp;    }</b>
<b class="nc"><i>1188</i>&nbsp;</b>
<i>1189</i>&nbsp;    /**
<i>1190</i>&nbsp;     * Gets the number of seconds in this duration.
<i>1191</i>&nbsp;     * &lt;p&gt;
<i>1192</i>&nbsp;     * This returns the total number of whole seconds in the duration.
<i>1193</i>&nbsp;     * &lt;p&gt;
<i>1194</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1195</i>&nbsp;     *
<i>1196</i>&nbsp;     * @return the whole seconds part of the length of the duration, positive or negative
<i>1197</i>&nbsp;     * @since 9
<i>1198</i>&nbsp;     */
<i>1199</i>&nbsp;    public long toSeconds() {
<i>1200</i>&nbsp;        return seconds;
<i>1201</i>&nbsp;    }
<i>1202</i>&nbsp;
<b class="nc"><i>1203</i>&nbsp;    /**</b>
<b class="nc"><i>1204</i>&nbsp;     * Converts this duration to the total length in milliseconds.</b>
<b class="nc"><i>1205</i>&nbsp;     * &lt;p&gt;</b>
<i>1206</i>&nbsp;     * If this duration is too large to fit in a {@code long} milliseconds, then an
<b class="nc"><i>1207</i>&nbsp;     * exception is thrown.</b>
<i>1208</i>&nbsp;     * &lt;p&gt;
<i>1209</i>&nbsp;     * If this duration has greater than millisecond precision, then the conversion
<i>1210</i>&nbsp;     * will drop any excess precision information as though the amount in nanoseconds
<i>1211</i>&nbsp;     * was subject to integer division by one million.
<i>1212</i>&nbsp;     *
<i>1213</i>&nbsp;     * @return the total length of the duration in milliseconds
<i>1214</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1215</i>&nbsp;     */
<i>1216</i>&nbsp;    public long toMillis() {
<i>1217</i>&nbsp;        long tempSeconds = seconds;
<i>1218</i>&nbsp;        long tempNanos = nanos;
<i>1219</i>&nbsp;        if (tempSeconds &lt; 0) {
<i>1220</i>&nbsp;            // change the seconds and nano value to
<b class="nc"><i>1221</i>&nbsp;            // handle Long.MIN_VALUE case</b>
<b class="nc"><i>1222</i>&nbsp;            tempSeconds = tempSeconds + 1;</b>
<i>1223</i>&nbsp;            tempNanos = tempNanos - NANOS_PER_SECOND;
<b class="nc"><i>1224</i>&nbsp;        }</b>
<b class="nc"><i>1225</i>&nbsp;        long millis = Math.multiplyExact(tempSeconds, 1000);</b>
<b class="nc"><i>1226</i>&nbsp;        millis = Math.addExact(millis, tempNanos / NANOS_PER_MILLI);</b>
<i>1227</i>&nbsp;        return millis;
<i>1228</i>&nbsp;    }
<b class="nc"><i>1229</i>&nbsp;</b>
<i>1230</i>&nbsp;    /**
<i>1231</i>&nbsp;     * Converts this duration to the total length in nanoseconds expressed as a {@code long}.
<i>1232</i>&nbsp;     * &lt;p&gt;
<i>1233</i>&nbsp;     * If this duration is too large to fit in a {@code long} nanoseconds, then an
<i>1234</i>&nbsp;     * exception is thrown.
<i>1235</i>&nbsp;     *
<i>1236</i>&nbsp;     * @return the total length of the duration in nanoseconds
<i>1237</i>&nbsp;     * @throws ArithmeticException if numeric overflow occurs
<i>1238</i>&nbsp;     */
<b class="nc"><i>1239</i>&nbsp;    public long toNanos() {</b>
<i>1240</i>&nbsp;        long tempSeconds = seconds;
<i>1241</i>&nbsp;        long tempNanos = nanos;
<i>1242</i>&nbsp;        if (tempSeconds &lt; 0) {
<i>1243</i>&nbsp;            // change the seconds and nano value to
<i>1244</i>&nbsp;            // handle Long.MIN_VALUE case
<i>1245</i>&nbsp;            tempSeconds = tempSeconds + 1;
<i>1246</i>&nbsp;            tempNanos = tempNanos - NANOS_PER_SECOND;
<i>1247</i>&nbsp;        }
<i>1248</i>&nbsp;        long totalNanos = Math.multiplyExact(tempSeconds, NANOS_PER_SECOND);
<i>1249</i>&nbsp;        totalNanos = Math.addExact(totalNanos, tempNanos);
<i>1250</i>&nbsp;        return totalNanos;
<i>1251</i>&nbsp;    }
<i>1252</i>&nbsp;
<i>1253</i>&nbsp;    /**
<i>1254</i>&nbsp;     * Extracts the number of days in the duration.
<i>1255</i>&nbsp;     * &lt;p&gt;
<i>1256</i>&nbsp;     * This returns the total number of days in the duration by dividing the
<i>1257</i>&nbsp;     * number of seconds by 86400.
<i>1258</i>&nbsp;     * This is based on the standard definition of a day as 24 hours.
<i>1259</i>&nbsp;     * &lt;p&gt;
<i>1260</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1261</i>&nbsp;     *
<i>1262</i>&nbsp;     * @return the number of days in the duration, may be negative
<i>1263</i>&nbsp;     * @since 9
<i>1264</i>&nbsp;     */
<i>1265</i>&nbsp;    public long toDaysPart(){
<i>1266</i>&nbsp;        return seconds / SECONDS_PER_DAY;
<b class="nc"><i>1267</i>&nbsp;    }</b>
<b class="nc"><i>1268</i>&nbsp;</b>
<i>1269</i>&nbsp;    /**
<b class="nc"><i>1270</i>&nbsp;     * Extracts the number of hours part in the duration.</b>
<b class="nc"><i>1271</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1272</i>&nbsp;     * This returns the number of remaining hours when dividing {@link #toHours}</b>
<b class="nc"><i>1273</i>&nbsp;     * by hours in a day.</b>
<b class="nc"><i>1274</i>&nbsp;     * This is based on the standard definition of a day as 24 hours.</b>
<b class="nc"><i>1275</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1276</i>&nbsp;     * This instance is immutable and unaffected by this method call.</b>
<i>1277</i>&nbsp;     *
<b class="nc"><i>1278</i>&nbsp;     * @return the number of hours part in the duration, may be negative</b>
<b class="nc"><i>1279</i>&nbsp;     * @since 9</b>
<i>1280</i>&nbsp;     */
<b class="nc"><i>1281</i>&nbsp;    public int toHoursPart(){</b>
<b class="nc"><i>1282</i>&nbsp;        return (int) (toHours() % 24);</b>
<i>1283</i>&nbsp;    }
<b class="nc"><i>1284</i>&nbsp;</b>
<b class="nc"><i>1285</i>&nbsp;    /**</b>
<b class="nc"><i>1286</i>&nbsp;     * Extracts the number of minutes part in the duration.</b>
<i>1287</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1288</i>&nbsp;     * This returns the number of remaining minutes when dividing {@link #toMinutes}</b>
<i>1289</i>&nbsp;     * by minutes in an hour.
<i>1290</i>&nbsp;     * This is based on the standard definition of an hour as 60 minutes.
<b class="nc"><i>1291</i>&nbsp;     * &lt;p&gt;</b>
<i>1292</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<b class="nc"><i>1293</i>&nbsp;     *</b>
<b class="nc"><i>1294</i>&nbsp;     * @return the number of minutes parts in the duration, may be negative</b>
<b class="nc"><i>1295</i>&nbsp;     * @since 9</b>
<b class="nc"><i>1296</i>&nbsp;     */</b>
<i>1297</i>&nbsp;    public int toMinutesPart(){
<b class="nc"><i>1298</i>&nbsp;        return (int) (toMinutes() % MINUTES_PER_HOUR);</b>
<i>1299</i>&nbsp;    }
<b class="nc"><i>1300</i>&nbsp;</b>
<b class="nc"><i>1301</i>&nbsp;    /**</b>
<i>1302</i>&nbsp;     * Extracts the number of seconds part in the duration.
<b class="nc"><i>1303</i>&nbsp;     * &lt;p&gt;</b>
<i>1304</i>&nbsp;     * This returns the remaining seconds when dividing {@link #toSeconds}
<b class="nc"><i>1305</i>&nbsp;     * by seconds in a minute.</b>
<b class="nc"><i>1306</i>&nbsp;     * This is based on the standard definition of a minute as 60 seconds.</b>
<i>1307</i>&nbsp;     * &lt;p&gt;
<i>1308</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1309</i>&nbsp;     *
<i>1310</i>&nbsp;     * @return the number of seconds parts in the duration, may be negative
<i>1311</i>&nbsp;     * @since 9
<i>1312</i>&nbsp;     */
<i>1313</i>&nbsp;    public int toSecondsPart(){
<i>1314</i>&nbsp;        return (int) (seconds % SECONDS_PER_MINUTE);
<i>1315</i>&nbsp;    }
<i>1316</i>&nbsp;
<i>1317</i>&nbsp;    /**
<i>1318</i>&nbsp;     * Extracts the number of milliseconds part of the duration.
<i>1319</i>&nbsp;     * &lt;p&gt;
<i>1320</i>&nbsp;     * This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.
<i>1321</i>&nbsp;     * The length of the duration is stored using two fields - seconds and nanoseconds.
<i>1322</i>&nbsp;     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
<b class="nc"><i>1323</i>&nbsp;     * the length in seconds.</b>
<i>1324</i>&nbsp;     * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
<i>1325</i>&nbsp;     * &lt;p&gt;
<i>1326</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1327</i>&nbsp;     *
<i>1328</i>&nbsp;     * @return the number of milliseconds part of the duration.
<i>1329</i>&nbsp;     * @since 9
<i>1330</i>&nbsp;     */
<i>1331</i>&nbsp;    public int toMillisPart(){
<i>1332</i>&nbsp;        return nanos / 1000_000;
<b class="nc"><i>1333</i>&nbsp;    }</b>
<i>1334</i>&nbsp;
<i>1335</i>&nbsp;    /**
<i>1336</i>&nbsp;     * Get the nanoseconds part within seconds of the duration.
<b class="nc"><i>1337</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1338</i>&nbsp;     * The length of the duration is stored using two fields - seconds and nanoseconds.</b>
<i>1339</i>&nbsp;     * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
<i>1340</i>&nbsp;     * the length in seconds.
<i>1341</i>&nbsp;     * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
<b class="nc"><i>1342</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1343</i>&nbsp;     * This instance is immutable and unaffected by this method call.</b>
<b class="nc"><i>1344</i>&nbsp;     *</b>
<i>1345</i>&nbsp;     * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
<i>1346</i>&nbsp;     * @since 9
<i>1347</i>&nbsp;     */
<i>1348</i>&nbsp;    public int toNanosPart(){
<i>1349</i>&nbsp;        return nanos;
<i>1350</i>&nbsp;    }
<i>1351</i>&nbsp;
<i>1352</i>&nbsp;
<i>1353</i>&nbsp;    //-----------------------------------------------------------------------
<i>1354</i>&nbsp;    /**
<i>1355</i>&nbsp;     * Returns a copy of this {@code Duration} truncated to the specified unit.
<i>1356</i>&nbsp;     * &lt;p&gt;
<i>1357</i>&nbsp;     * Truncating the duration returns a copy of the original with conceptual fields
<i>1358</i>&nbsp;     * smaller than the specified unit set to zero.
<i>1359</i>&nbsp;     * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
<i>1360</i>&nbsp;     * round down towards zero to the nearest minute, setting the seconds and
<i>1361</i>&nbsp;     * nanoseconds to zero.
<i>1362</i>&nbsp;     * &lt;p&gt;
<i>1363</i>&nbsp;     * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
<i>1364</i>&nbsp;     * that divides into the length of a standard day without remainder.
<i>1365</i>&nbsp;     * This includes all
<i>1366</i>&nbsp;     * {@linkplain ChronoUnit#isTimeBased() time-based units on {@code ChronoUnit}}
<i>1367</i>&nbsp;     * and {@link ChronoUnit#DAYS DAYS}. Other ChronoUnits throw an exception.
<i>1368</i>&nbsp;     * &lt;p&gt;
<i>1369</i>&nbsp;     * This instance is immutable and unaffected by this method call.
<i>1370</i>&nbsp;     *
<i>1371</i>&nbsp;     * @param unit the unit to truncate to, not null
<i>1372</i>&nbsp;     * @return a {@code Duration} based on this duration with the time truncated, not null
<i>1373</i>&nbsp;     * @throws DateTimeException if the unit is invalid for truncation
<i>1374</i>&nbsp;     * @throws UnsupportedTemporalTypeException if the unit is not supported
<i>1375</i>&nbsp;     * @since 9
<i>1376</i>&nbsp;     */
<i>1377</i>&nbsp;    public Duration truncatedTo(TemporalUnit unit) {
<i>1378</i>&nbsp;        Objects.requireNonNull(unit, &quot;unit&quot;);
<i>1379</i>&nbsp;        if (unit == ChronoUnit.SECONDS &amp;&amp; (seconds &gt;= 0 || nanos == 0)) {
<i>1380</i>&nbsp;            return new Duration(seconds, 0);
<i>1381</i>&nbsp;        } else if (unit == ChronoUnit.NANOS) {
<i>1382</i>&nbsp;            return this;
<i>1383</i>&nbsp;        }
<i>1384</i>&nbsp;        Duration unitDur = unit.getDuration();
<i>1385</i>&nbsp;        if (unitDur.getSeconds() &gt; LocalTime.SECONDS_PER_DAY) {
<i>1386</i>&nbsp;            throw new UnsupportedTemporalTypeException(&quot;Unit is too large to be used for truncation&quot;);
<i>1387</i>&nbsp;        }
<i>1388</i>&nbsp;        long dur = unitDur.toNanos();
<i>1389</i>&nbsp;        if ((LocalTime.NANOS_PER_DAY % dur) != 0) {
<i>1390</i>&nbsp;            throw new UnsupportedTemporalTypeException(&quot;Unit must divide into a standard day without remainder&quot;);
<i>1391</i>&nbsp;        }
<i>1392</i>&nbsp;        long nod = (seconds % LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + nanos;
<i>1393</i>&nbsp;        long result = (nod / dur) * dur;
<i>1394</i>&nbsp;        return plusNanos(result - nod);
<i>1395</i>&nbsp;    }
<i>1396</i>&nbsp;
<i>1397</i>&nbsp;    //-----------------------------------------------------------------------
<i>1398</i>&nbsp;    /**
<i>1399</i>&nbsp;     * Compares this duration to the specified {@code Duration}.
<i>1400</i>&nbsp;     * &lt;p&gt;
<i>1401</i>&nbsp;     * The comparison is based on the total length of the durations.
<i>1402</i>&nbsp;     * It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
<i>1403</i>&nbsp;     *
<i>1404</i>&nbsp;     * @param otherDuration the other duration to compare to, not null
<i>1405</i>&nbsp;     * @return the comparator value, negative if less, positive if greater
<i>1406</i>&nbsp;     */
<i>1407</i>&nbsp;    @Override
<i>1408</i>&nbsp;    public int compareTo(Duration otherDuration) {
<i>1409</i>&nbsp;        int cmp = Long.compare(seconds, otherDuration.seconds);
<i>1410</i>&nbsp;        if (cmp != 0) {
<i>1411</i>&nbsp;            return cmp;
<i>1412</i>&nbsp;        }
<i>1413</i>&nbsp;        return nanos - otherDuration.nanos;
<i>1414</i>&nbsp;    }
<i>1415</i>&nbsp;
<i>1416</i>&nbsp;    //-----------------------------------------------------------------------
<i>1417</i>&nbsp;    /**
<i>1418</i>&nbsp;     * Checks if this duration is equal to the specified {@code Duration}.
<i>1419</i>&nbsp;     * &lt;p&gt;
<i>1420</i>&nbsp;     * The comparison is based on the total length of the durations.
<i>1421</i>&nbsp;     *
<i>1422</i>&nbsp;     * @param otherDuration the other duration, null returns false
<i>1423</i>&nbsp;     * @return true if the other duration is equal to this one
<i>1424</i>&nbsp;     */
<i>1425</i>&nbsp;    @Override
<i>1426</i>&nbsp;    public boolean equals(Object otherDuration) {
<i>1427</i>&nbsp;        if (this == otherDuration) {
<i>1428</i>&nbsp;            return true;
<i>1429</i>&nbsp;        }
<i>1430</i>&nbsp;        if (otherDuration instanceof Duration) {
<i>1431</i>&nbsp;            Duration other = (Duration) otherDuration;
<i>1432</i>&nbsp;            return this.seconds == other.seconds &amp;&amp;
<i>1433</i>&nbsp;                   this.nanos == other.nanos;
<i>1434</i>&nbsp;        }
<i>1435</i>&nbsp;        return false;
<i>1436</i>&nbsp;    }
<i>1437</i>&nbsp;
<i>1438</i>&nbsp;    /**
<i>1439</i>&nbsp;     * A hash code for this duration.
<i>1440</i>&nbsp;     *
<i>1441</i>&nbsp;     * @return a suitable hash code
<i>1442</i>&nbsp;     */
<i>1443</i>&nbsp;    @Override
<i>1444</i>&nbsp;    public int hashCode() {
<i>1445</i>&nbsp;        return ((int) (seconds ^ (seconds &gt;&gt;&gt; 32))) + (51 * nanos);
<i>1446</i>&nbsp;    }
<i>1447</i>&nbsp;
<i>1448</i>&nbsp;    //-----------------------------------------------------------------------
<i>1449</i>&nbsp;    /**
<i>1450</i>&nbsp;     * A string representation of this duration using ISO-8601 seconds
<i>1451</i>&nbsp;     * based representation, such as {@code PT8H6M12.345S}.
<i>1452</i>&nbsp;     * &lt;p&gt;
<i>1453</i>&nbsp;     * The format of the returned string will be {@code PTnHnMnS}, where n is
<i>1454</i>&nbsp;     * the relevant hours, minutes or seconds part of the duration.
<i>1455</i>&nbsp;     * Any fractional seconds are placed after a decimal point in the seconds section.
<i>1456</i>&nbsp;     * If a section has a zero value, it is omitted.
<i>1457</i>&nbsp;     * The hours, minutes and seconds will all have the same sign.
<i>1458</i>&nbsp;     * &lt;p&gt;
<i>1459</i>&nbsp;     * Examples:
<i>1460</i>&nbsp;     * &lt;pre&gt;
<i>1461</i>&nbsp;     *    &quot;20.345 seconds&quot;                 -- &quot;PT20.345S
<i>1462</i>&nbsp;     *    &quot;15 minutes&quot; (15 * 60 seconds)   -- &quot;PT15M&quot;
<i>1463</i>&nbsp;     *    &quot;10 hours&quot; (10 * 3600 seconds)   -- &quot;PT10H&quot;
<i>1464</i>&nbsp;     *    &quot;2 days&quot; (2 * 86400 seconds)     -- &quot;PT48H&quot;
<i>1465</i>&nbsp;     * &lt;/pre&gt;
<i>1466</i>&nbsp;     * Note that multiples of 24 hours are not output as days to avoid confusion
<i>1467</i>&nbsp;     * with {@code Period}.
<i>1468</i>&nbsp;     *
<i>1469</i>&nbsp;     * @return an ISO-8601 representation of this duration, not null
<i>1470</i>&nbsp;     */
<i>1471</i>&nbsp;    @Override
<i>1472</i>&nbsp;    public String toString() {
<i>1473</i>&nbsp;        if (this == ZERO) {
<i>1474</i>&nbsp;            return &quot;PT0S&quot;;
<i>1475</i>&nbsp;        }
<i>1476</i>&nbsp;        long effectiveTotalSecs = seconds;
<i>1477</i>&nbsp;        if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
<i>1478</i>&nbsp;            effectiveTotalSecs++;
<i>1479</i>&nbsp;        }
<i>1480</i>&nbsp;        long hours = effectiveTotalSecs / SECONDS_PER_HOUR;
<i>1481</i>&nbsp;        int minutes = (int) ((effectiveTotalSecs % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE);
<i>1482</i>&nbsp;        int secs = (int) (effectiveTotalSecs % SECONDS_PER_MINUTE);
<i>1483</i>&nbsp;        StringBuilder buf = new StringBuilder(24);
<i>1484</i>&nbsp;        buf.append(&quot;PT&quot;);
<i>1485</i>&nbsp;        if (hours != 0) {
<i>1486</i>&nbsp;            buf.append(hours).append(&#39;H&#39;);
<i>1487</i>&nbsp;        }
<i>1488</i>&nbsp;        if (minutes != 0) {
<i>1489</i>&nbsp;            buf.append(minutes).append(&#39;M&#39;);
<i>1490</i>&nbsp;        }
<i>1491</i>&nbsp;        if (secs == 0 &amp;&amp; nanos == 0 &amp;&amp; buf.length() &gt; 2) {
<i>1492</i>&nbsp;            return buf.toString();
<i>1493</i>&nbsp;        }
<i>1494</i>&nbsp;        if (seconds &lt; 0 &amp;&amp; nanos &gt; 0) {
<i>1495</i>&nbsp;            if (secs == 0) {
<i>1496</i>&nbsp;                buf.append(&quot;-0&quot;);
<i>1497</i>&nbsp;            } else {
<i>1498</i>&nbsp;                buf.append(secs);
<i>1499</i>&nbsp;            }
<i>1500</i>&nbsp;        } else {
<i>1501</i>&nbsp;            buf.append(secs);
<i>1502</i>&nbsp;        }
<i>1503</i>&nbsp;        if (nanos &gt; 0) {
<i>1504</i>&nbsp;            int pos = buf.length();
<i>1505</i>&nbsp;            if (seconds &lt; 0) {
<i>1506</i>&nbsp;                buf.append(2 * NANOS_PER_SECOND - nanos);
<i>1507</i>&nbsp;            } else {
<i>1508</i>&nbsp;                buf.append(nanos + NANOS_PER_SECOND);
<i>1509</i>&nbsp;            }
<i>1510</i>&nbsp;            while (buf.charAt(buf.length() - 1) == &#39;0&#39;) {
<i>1511</i>&nbsp;                buf.setLength(buf.length() - 1);
<i>1512</i>&nbsp;            }
<i>1513</i>&nbsp;            buf.setCharAt(pos, &#39;.&#39;);
<i>1514</i>&nbsp;        }
<i>1515</i>&nbsp;        buf.append(&#39;S&#39;);
<i>1516</i>&nbsp;        return buf.toString();
<i>1517</i>&nbsp;    }
<i>1518</i>&nbsp;
<i>1519</i>&nbsp;    //-----------------------------------------------------------------------
<i>1520</i>&nbsp;    /**
<i>1521</i>&nbsp;     * Writes the object using a
<i>1522</i>&nbsp;     * &lt;a href=&quot;../../serialized-form.html#java.time.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
<i>1523</i>&nbsp;     * @serialData
<i>1524</i>&nbsp;     * &lt;pre&gt;
<i>1525</i>&nbsp;     *  out.writeByte(1);  // identifies a Duration
<i>1526</i>&nbsp;     *  out.writeLong(seconds);
<i>1527</i>&nbsp;     *  out.writeInt(nanos);
<i>1528</i>&nbsp;     * &lt;/pre&gt;
<i>1529</i>&nbsp;     *
<i>1530</i>&nbsp;     * @return the instance of {@code Ser}, not null
<i>1531</i>&nbsp;     */
<i>1532</i>&nbsp;    private Object writeReplace() {
<i>1533</i>&nbsp;        return new Ser(Ser.DURATION_TYPE, this);
<i>1534</i>&nbsp;    }
<i>1535</i>&nbsp;
<i>1536</i>&nbsp;    /**
<i>1537</i>&nbsp;     * Defend against malicious streams.
<i>1538</i>&nbsp;     *
<i>1539</i>&nbsp;     * @param s the stream to read
<i>1540</i>&nbsp;     * @throws InvalidObjectException always
<i>1541</i>&nbsp;     */
<i>1542</i>&nbsp;    private void readObject(ObjectInputStream s) throws InvalidObjectException {
<i>1543</i>&nbsp;        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);
<i>1544</i>&nbsp;    }
<i>1545</i>&nbsp;
<i>1546</i>&nbsp;    void writeExternal(DataOutput out) throws IOException {
<i>1547</i>&nbsp;        out.writeLong(seconds);
<i>1548</i>&nbsp;        out.writeInt(nanos);
<i>1549</i>&nbsp;    }
<i>1550</i>&nbsp;
<i>1551</i>&nbsp;    static Duration readExternal(DataInput in) throws IOException {
<i>1552</i>&nbsp;        long seconds = in.readLong();
<i>1553</i>&nbsp;        int nanos = in.readInt();
<i>1554</i>&nbsp;        return Duration.ofSeconds(seconds, nanos);
<i>1555</i>&nbsp;    }
<i>1556</i>&nbsp;
<i>1557</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
