


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: RevocationChecker</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.security.provider.certpath</a> ]
</div>

<h1>Coverage Summary for Class: RevocationChecker (sun.security.provider.certpath)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RevocationChecker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 474)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RevocationChecker$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RevocationChecker$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RevocationChecker$Mode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RevocationChecker$RejectKeySelector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RevocationChecker$RevocationProperties</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 513)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.security.provider.certpath;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.IOException;
<i>29</i>&nbsp;import java.math.BigInteger;
<i>30</i>&nbsp;import java.net.URI;
<i>31</i>&nbsp;import java.net.URISyntaxException;
<i>32</i>&nbsp;import java.security.AccessController;
<i>33</i>&nbsp;import java.security.InvalidAlgorithmParameterException;
<i>34</i>&nbsp;import java.security.NoSuchAlgorithmException;
<i>35</i>&nbsp;import java.security.PrivilegedAction;
<i>36</i>&nbsp;import java.security.PublicKey;
<i>37</i>&nbsp;import java.security.Security;
<i>38</i>&nbsp;import java.security.cert.CertPathValidatorException.BasicReason;
<i>39</i>&nbsp;import java.security.cert.Extension;
<i>40</i>&nbsp;import java.security.cert.*;
<i>41</i>&nbsp;import java.util.*;
<i>42</i>&nbsp;import javax.security.auth.x500.X500Principal;
<i>43</i>&nbsp;
<i>44</i>&nbsp;import static sun.security.provider.certpath.OCSP.*;
<i>45</i>&nbsp;import static sun.security.provider.certpath.PKIX.*;
<i>46</i>&nbsp;import sun.security.x509.*;
<i>47</i>&nbsp;import static sun.security.x509.PKIXExtensions.*;
<i>48</i>&nbsp;import sun.security.util.Debug;
<i>49</i>&nbsp;
<b class="nc"><i>50</i>&nbsp;class RevocationChecker extends PKIXRevocationChecker {</b>
<i>51</i>&nbsp;
<b class="nc"><i>52</i>&nbsp;    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</b>
<i>53</i>&nbsp;
<i>54</i>&nbsp;    private TrustAnchor anchor;
<i>55</i>&nbsp;    private ValidatorParams params;
<i>56</i>&nbsp;    private boolean onlyEE;
<i>57</i>&nbsp;    private boolean softFail;
<i>58</i>&nbsp;    private boolean crlDP;
<i>59</i>&nbsp;    private URI responderURI;
<i>60</i>&nbsp;    private X509Certificate responderCert;
<i>61</i>&nbsp;    private List&lt;CertStore&gt; certStores;
<i>62</i>&nbsp;    private Map&lt;X509Certificate, byte[]&gt; ocspResponses;
<i>63</i>&nbsp;    private List&lt;Extension&gt; ocspExtensions;
<i>64</i>&nbsp;    private final boolean legacy;
<b class="nc"><i>65</i>&nbsp;    private LinkedList&lt;CertPathValidatorException&gt; softFailExceptions =</b>
<i>66</i>&nbsp;        new LinkedList&lt;&gt;();
<i>67</i>&nbsp;
<i>68</i>&nbsp;    // state variables
<i>69</i>&nbsp;    private OCSPResponse.IssuerInfo issuerInfo;
<i>70</i>&nbsp;    private PublicKey prevPubKey;
<i>71</i>&nbsp;    private boolean crlSignFlag;
<i>72</i>&nbsp;    private int certIndex;
<i>73</i>&nbsp;
<b class="nc"><i>74</i>&nbsp;    private enum Mode { PREFER_OCSP, PREFER_CRLS, ONLY_CRLS, ONLY_OCSP };</b>
<b class="nc"><i>75</i>&nbsp;    private Mode mode = Mode.PREFER_OCSP;</b>
<i>76</i>&nbsp;
<b class="nc"><i>77</i>&nbsp;    private static class RevocationProperties {</b>
<i>78</i>&nbsp;        boolean onlyEE;
<i>79</i>&nbsp;        boolean ocspEnabled;
<i>80</i>&nbsp;        boolean crlDPEnabled;
<i>81</i>&nbsp;        String ocspUrl;
<i>82</i>&nbsp;        String ocspSubject;
<i>83</i>&nbsp;        String ocspIssuer;
<i>84</i>&nbsp;        String ocspSerial;
<i>85</i>&nbsp;    }
<i>86</i>&nbsp;
<b class="nc"><i>87</i>&nbsp;    RevocationChecker() {</b>
<b class="nc"><i>88</i>&nbsp;        legacy = false;</b>
<i>89</i>&nbsp;    }
<i>90</i>&nbsp;
<i>91</i>&nbsp;    RevocationChecker(TrustAnchor anchor, ValidatorParams params)
<i>92</i>&nbsp;        throws CertPathValidatorException
<b class="nc"><i>93</i>&nbsp;    {</b>
<b class="nc"><i>94</i>&nbsp;        legacy = true;</b>
<b class="nc"><i>95</i>&nbsp;        init(anchor, params);</b>
<i>96</i>&nbsp;    }
<i>97</i>&nbsp;
<i>98</i>&nbsp;    void init(TrustAnchor anchor, ValidatorParams params)
<i>99</i>&nbsp;        throws CertPathValidatorException
<i>100</i>&nbsp;    {
<b class="nc"><i>101</i>&nbsp;        RevocationProperties rp = getRevocationProperties();</b>
<b class="nc"><i>102</i>&nbsp;        URI uri = getOcspResponder();</b>
<b class="nc"><i>103</i>&nbsp;        responderURI = (uri == null) ? toURI(rp.ocspUrl) : uri;</b>
<b class="nc"><i>104</i>&nbsp;        X509Certificate cert = getOcspResponderCert();</b>
<b class="nc"><i>105</i>&nbsp;        responderCert = (cert == null)</b>
<b class="nc"><i>106</i>&nbsp;                        ? getResponderCert(rp, params.trustAnchors(),</b>
<b class="nc"><i>107</i>&nbsp;                                           params.certStores())</b>
<i>108</i>&nbsp;                        : cert;
<b class="nc"><i>109</i>&nbsp;        Set&lt;Option&gt; options = getOptions();</b>
<b class="nc"><i>110</i>&nbsp;        for (Option option : options) {</b>
<b class="nc"><i>111</i>&nbsp;            switch (option) {</b>
<i>112</i>&nbsp;            case ONLY_END_ENTITY:
<i>113</i>&nbsp;            case PREFER_CRLS:
<i>114</i>&nbsp;            case SOFT_FAIL:
<i>115</i>&nbsp;            case NO_FALLBACK:
<b class="nc"><i>116</i>&nbsp;                break;</b>
<i>117</i>&nbsp;            default:
<b class="nc"><i>118</i>&nbsp;                throw new CertPathValidatorException(</b>
<i>119</i>&nbsp;                    &quot;Unrecognized revocation parameter option: &quot; + option);
<i>120</i>&nbsp;            }
<b class="nc"><i>121</i>&nbsp;        }</b>
<b class="nc"><i>122</i>&nbsp;        softFail = options.contains(Option.SOFT_FAIL);</b>
<i>123</i>&nbsp;
<i>124</i>&nbsp;        // set mode, only end entity flag
<b class="nc"><i>125</i>&nbsp;        if (legacy) {</b>
<b class="nc"><i>126</i>&nbsp;            mode = (rp.ocspEnabled) ? Mode.PREFER_OCSP : Mode.ONLY_CRLS;</b>
<b class="nc"><i>127</i>&nbsp;            onlyEE = rp.onlyEE;</b>
<i>128</i>&nbsp;        } else {
<b class="nc"><i>129</i>&nbsp;            if (options.contains(Option.NO_FALLBACK)) {</b>
<b class="nc"><i>130</i>&nbsp;                if (options.contains(Option.PREFER_CRLS)) {</b>
<b class="nc"><i>131</i>&nbsp;                    mode = Mode.ONLY_CRLS;</b>
<i>132</i>&nbsp;                } else {
<b class="nc"><i>133</i>&nbsp;                    mode = Mode.ONLY_OCSP;</b>
<i>134</i>&nbsp;                }
<b class="nc"><i>135</i>&nbsp;            } else if (options.contains(Option.PREFER_CRLS)) {</b>
<b class="nc"><i>136</i>&nbsp;                mode = Mode.PREFER_CRLS;</b>
<i>137</i>&nbsp;            }
<b class="nc"><i>138</i>&nbsp;            onlyEE = options.contains(Option.ONLY_END_ENTITY);</b>
<i>139</i>&nbsp;        }
<b class="nc"><i>140</i>&nbsp;        if (legacy) {</b>
<b class="nc"><i>141</i>&nbsp;            crlDP = rp.crlDPEnabled;</b>
<i>142</i>&nbsp;        } else {
<b class="nc"><i>143</i>&nbsp;            crlDP = true;</b>
<i>144</i>&nbsp;        }
<b class="nc"><i>145</i>&nbsp;        ocspResponses = getOcspResponses();</b>
<b class="nc"><i>146</i>&nbsp;        ocspExtensions = getOcspExtensions();</b>
<i>147</i>&nbsp;
<b class="nc"><i>148</i>&nbsp;        this.anchor = anchor;</b>
<b class="nc"><i>149</i>&nbsp;        this.params = params;</b>
<b class="nc"><i>150</i>&nbsp;        this.certStores = new ArrayList&lt;&gt;(params.certStores());</b>
<i>151</i>&nbsp;        try {
<b class="nc"><i>152</i>&nbsp;            this.certStores.add(CertStore.getInstance(&quot;Collection&quot;,</b>
<b class="nc"><i>153</i>&nbsp;                new CollectionCertStoreParameters(params.certificates())));</b>
<b class="nc"><i>154</i>&nbsp;        } catch (InvalidAlgorithmParameterException |</b>
<i>155</i>&nbsp;                 NoSuchAlgorithmException e) {
<i>156</i>&nbsp;            // should never occur but not necessarily fatal, so log it,
<i>157</i>&nbsp;            // ignore and continue
<b class="nc"><i>158</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>159</i>&nbsp;                debug.println(&quot;RevocationChecker: &quot; +</b>
<i>160</i>&nbsp;                              &quot;error creating Collection CertStore: &quot; + e);
<i>161</i>&nbsp;            }
<b class="nc"><i>162</i>&nbsp;        }</b>
<i>163</i>&nbsp;    }
<i>164</i>&nbsp;
<i>165</i>&nbsp;    private static URI toURI(String uriString)
<i>166</i>&nbsp;        throws CertPathValidatorException
<i>167</i>&nbsp;    {
<i>168</i>&nbsp;        try {
<b class="nc"><i>169</i>&nbsp;            if (uriString != null) {</b>
<b class="nc"><i>170</i>&nbsp;                return new URI(uriString);</b>
<i>171</i>&nbsp;            }
<b class="nc"><i>172</i>&nbsp;            return null;</b>
<b class="nc"><i>173</i>&nbsp;        } catch (URISyntaxException e) {</b>
<b class="nc"><i>174</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>175</i>&nbsp;                &quot;cannot parse ocsp.responderURL property&quot;, e);
<i>176</i>&nbsp;        }
<i>177</i>&nbsp;    }
<i>178</i>&nbsp;
<i>179</i>&nbsp;    private static RevocationProperties getRevocationProperties() {
<b class="nc"><i>180</i>&nbsp;        return AccessController.doPrivileged(</b>
<b class="nc"><i>181</i>&nbsp;            new PrivilegedAction&lt;RevocationProperties&gt;() {</b>
<i>182</i>&nbsp;                public RevocationProperties run() {
<b class="nc"><i>183</i>&nbsp;                    RevocationProperties rp = new RevocationProperties();</b>
<b class="nc"><i>184</i>&nbsp;                    String onlyEE = Security.getProperty(</b>
<i>185</i>&nbsp;                        &quot;com.sun.security.onlyCheckRevocationOfEECert&quot;);
<b class="nc"><i>186</i>&nbsp;                    rp.onlyEE = onlyEE != null</b>
<b class="nc"><i>187</i>&nbsp;                                &amp;&amp; onlyEE.equalsIgnoreCase(&quot;true&quot;);</b>
<b class="nc"><i>188</i>&nbsp;                    String ocspEnabled = Security.getProperty(&quot;ocsp.enable&quot;);</b>
<b class="nc"><i>189</i>&nbsp;                    rp.ocspEnabled = ocspEnabled != null</b>
<b class="nc"><i>190</i>&nbsp;                                     &amp;&amp; ocspEnabled.equalsIgnoreCase(&quot;true&quot;);</b>
<b class="nc"><i>191</i>&nbsp;                    rp.ocspUrl = Security.getProperty(&quot;ocsp.responderURL&quot;);</b>
<b class="nc"><i>192</i>&nbsp;                    rp.ocspSubject</b>
<b class="nc"><i>193</i>&nbsp;                        = Security.getProperty(&quot;ocsp.responderCertSubjectName&quot;);</b>
<b class="nc"><i>194</i>&nbsp;                    rp.ocspIssuer</b>
<b class="nc"><i>195</i>&nbsp;                        = Security.getProperty(&quot;ocsp.responderCertIssuerName&quot;);</b>
<b class="nc"><i>196</i>&nbsp;                    rp.ocspSerial</b>
<b class="nc"><i>197</i>&nbsp;                        = Security.getProperty(&quot;ocsp.responderCertSerialNumber&quot;);</b>
<b class="nc"><i>198</i>&nbsp;                    rp.crlDPEnabled</b>
<b class="nc"><i>199</i>&nbsp;                        = Boolean.getBoolean(&quot;com.sun.security.enableCRLDP&quot;);</b>
<b class="nc"><i>200</i>&nbsp;                    return rp;</b>
<i>201</i>&nbsp;                }
<i>202</i>&nbsp;            }
<i>203</i>&nbsp;        );
<i>204</i>&nbsp;    }
<i>205</i>&nbsp;
<i>206</i>&nbsp;    private static X509Certificate getResponderCert(RevocationProperties rp,
<i>207</i>&nbsp;                                                    Set&lt;TrustAnchor&gt; anchors,
<i>208</i>&nbsp;                                                    List&lt;CertStore&gt; stores)
<i>209</i>&nbsp;        throws CertPathValidatorException
<i>210</i>&nbsp;    {
<b class="nc"><i>211</i>&nbsp;        if (rp.ocspSubject != null) {</b>
<b class="nc"><i>212</i>&nbsp;            return getResponderCert(rp.ocspSubject, anchors, stores);</b>
<b class="nc"><i>213</i>&nbsp;        } else if (rp.ocspIssuer != null &amp;&amp; rp.ocspSerial != null) {</b>
<b class="nc"><i>214</i>&nbsp;            return getResponderCert(rp.ocspIssuer, rp.ocspSerial,</b>
<i>215</i>&nbsp;                                    anchors, stores);
<b class="nc"><i>216</i>&nbsp;        } else if (rp.ocspIssuer != null || rp.ocspSerial != null) {</b>
<b class="nc"><i>217</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>218</i>&nbsp;                &quot;Must specify both ocsp.responderCertIssuerName and &quot; +
<i>219</i>&nbsp;                &quot;ocsp.responderCertSerialNumber properties&quot;);
<i>220</i>&nbsp;        }
<b class="nc"><i>221</i>&nbsp;        return null;</b>
<i>222</i>&nbsp;    }
<i>223</i>&nbsp;
<i>224</i>&nbsp;    private static X509Certificate getResponderCert(String subject,
<i>225</i>&nbsp;                                                    Set&lt;TrustAnchor&gt; anchors,
<i>226</i>&nbsp;                                                    List&lt;CertStore&gt; stores)
<i>227</i>&nbsp;        throws CertPathValidatorException
<i>228</i>&nbsp;    {
<b class="nc"><i>229</i>&nbsp;        X509CertSelector sel = new X509CertSelector();</b>
<i>230</i>&nbsp;        try {
<b class="nc"><i>231</i>&nbsp;            sel.setSubject(new X500Principal(subject));</b>
<b class="nc"><i>232</i>&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc"><i>233</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>234</i>&nbsp;                &quot;cannot parse ocsp.responderCertSubjectName property&quot;, e);
<b class="nc"><i>235</i>&nbsp;        }</b>
<b class="nc"><i>236</i>&nbsp;        return getResponderCert(sel, anchors, stores);</b>
<i>237</i>&nbsp;    }
<i>238</i>&nbsp;
<i>239</i>&nbsp;    private static X509Certificate getResponderCert(String issuer,
<i>240</i>&nbsp;                                                    String serial,
<i>241</i>&nbsp;                                                    Set&lt;TrustAnchor&gt; anchors,
<i>242</i>&nbsp;                                                    List&lt;CertStore&gt; stores)
<i>243</i>&nbsp;        throws CertPathValidatorException
<i>244</i>&nbsp;    {
<b class="nc"><i>245</i>&nbsp;        X509CertSelector sel = new X509CertSelector();</b>
<i>246</i>&nbsp;        try {
<b class="nc"><i>247</i>&nbsp;            sel.setIssuer(new X500Principal(issuer));</b>
<b class="nc"><i>248</i>&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc"><i>249</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>250</i>&nbsp;                &quot;cannot parse ocsp.responderCertIssuerName property&quot;, e);
<b class="nc"><i>251</i>&nbsp;        }</b>
<i>252</i>&nbsp;        try {
<b class="nc"><i>253</i>&nbsp;            sel.setSerialNumber(new BigInteger(stripOutSeparators(serial), 16));</b>
<b class="nc"><i>254</i>&nbsp;        } catch (NumberFormatException e) {</b>
<b class="nc"><i>255</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>256</i>&nbsp;                &quot;cannot parse ocsp.responderCertSerialNumber property&quot;, e);
<b class="nc"><i>257</i>&nbsp;        }</b>
<b class="nc"><i>258</i>&nbsp;        return getResponderCert(sel, anchors, stores);</b>
<i>259</i>&nbsp;    }
<i>260</i>&nbsp;
<i>261</i>&nbsp;    private static X509Certificate getResponderCert(X509CertSelector sel,
<i>262</i>&nbsp;                                                    Set&lt;TrustAnchor&gt; anchors,
<i>263</i>&nbsp;                                                    List&lt;CertStore&gt; stores)
<i>264</i>&nbsp;        throws CertPathValidatorException
<i>265</i>&nbsp;    {
<i>266</i>&nbsp;        // first check TrustAnchors
<b class="nc"><i>267</i>&nbsp;        for (TrustAnchor anchor : anchors) {</b>
<b class="nc"><i>268</i>&nbsp;            X509Certificate cert = anchor.getTrustedCert();</b>
<b class="nc"><i>269</i>&nbsp;            if (cert == null) {</b>
<b class="nc"><i>270</i>&nbsp;                continue;</b>
<i>271</i>&nbsp;            }
<b class="nc"><i>272</i>&nbsp;            if (sel.match(cert)) {</b>
<b class="nc"><i>273</i>&nbsp;                return cert;</b>
<i>274</i>&nbsp;            }
<b class="nc"><i>275</i>&nbsp;        }</b>
<i>276</i>&nbsp;        // now check CertStores
<b class="nc"><i>277</i>&nbsp;        for (CertStore store : stores) {</b>
<i>278</i>&nbsp;            try {
<b class="nc"><i>279</i>&nbsp;                Collection&lt;? extends Certificate&gt; certs =</b>
<b class="nc"><i>280</i>&nbsp;                    store.getCertificates(sel);</b>
<b class="nc"><i>281</i>&nbsp;                if (!certs.isEmpty()) {</b>
<b class="nc"><i>282</i>&nbsp;                    return (X509Certificate)certs.iterator().next();</b>
<i>283</i>&nbsp;                }
<b class="nc"><i>284</i>&nbsp;            } catch (CertStoreException e) {</b>
<i>285</i>&nbsp;                // ignore and try next CertStore
<b class="nc"><i>286</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>287</i>&nbsp;                    debug.println(&quot;CertStore exception:&quot; + e);</b>
<i>288</i>&nbsp;                }
<b class="nc"><i>289</i>&nbsp;                continue;</b>
<b class="nc"><i>290</i>&nbsp;            }</b>
<b class="nc"><i>291</i>&nbsp;        }</b>
<b class="nc"><i>292</i>&nbsp;        throw new CertPathValidatorException(</b>
<i>293</i>&nbsp;            &quot;Cannot find the responder&#39;s certificate &quot; +
<i>294</i>&nbsp;            &quot;(set using the OCSP security properties).&quot;);
<i>295</i>&nbsp;    }
<i>296</i>&nbsp;
<i>297</i>&nbsp;    @Override
<i>298</i>&nbsp;    public void init(boolean forward) throws CertPathValidatorException {
<b class="nc"><i>299</i>&nbsp;        if (forward) {</b>
<b class="nc"><i>300</i>&nbsp;            throw new</b>
<i>301</i>&nbsp;                CertPathValidatorException(&quot;forward checking not supported&quot;);
<i>302</i>&nbsp;        }
<b class="nc"><i>303</i>&nbsp;        if (anchor != null) {</b>
<b class="nc"><i>304</i>&nbsp;            issuerInfo = new OCSPResponse.IssuerInfo(anchor);</b>
<b class="nc"><i>305</i>&nbsp;            prevPubKey = issuerInfo.getPublicKey();</b>
<i>306</i>&nbsp;
<i>307</i>&nbsp;        }
<b class="nc"><i>308</i>&nbsp;        crlSignFlag = true;</b>
<b class="nc"><i>309</i>&nbsp;        if (params != null &amp;&amp; params.certPath() != null) {</b>
<b class="nc"><i>310</i>&nbsp;            certIndex = params.certPath().getCertificates().size() - 1;</b>
<i>311</i>&nbsp;        } else {
<b class="nc"><i>312</i>&nbsp;            certIndex = -1;</b>
<i>313</i>&nbsp;        }
<b class="nc"><i>314</i>&nbsp;        softFailExceptions.clear();</b>
<i>315</i>&nbsp;    }
<i>316</i>&nbsp;
<i>317</i>&nbsp;    @Override
<i>318</i>&nbsp;    public boolean isForwardCheckingSupported() {
<b class="nc"><i>319</i>&nbsp;        return false;</b>
<i>320</i>&nbsp;    }
<i>321</i>&nbsp;
<i>322</i>&nbsp;    @Override
<i>323</i>&nbsp;    public Set&lt;String&gt; getSupportedExtensions() {
<b class="nc"><i>324</i>&nbsp;        return null;</b>
<i>325</i>&nbsp;    }
<i>326</i>&nbsp;
<i>327</i>&nbsp;    @Override
<i>328</i>&nbsp;    public List&lt;CertPathValidatorException&gt; getSoftFailExceptions() {
<b class="nc"><i>329</i>&nbsp;        return Collections.unmodifiableList(softFailExceptions);</b>
<i>330</i>&nbsp;    }
<i>331</i>&nbsp;
<i>332</i>&nbsp;    @Override
<i>333</i>&nbsp;    public void check(Certificate cert, Collection&lt;String&gt; unresolvedCritExts)
<i>334</i>&nbsp;        throws CertPathValidatorException
<i>335</i>&nbsp;    {
<b class="nc"><i>336</i>&nbsp;        check((X509Certificate)cert, unresolvedCritExts,</b>
<i>337</i>&nbsp;              prevPubKey, crlSignFlag);
<i>338</i>&nbsp;    }
<i>339</i>&nbsp;
<i>340</i>&nbsp;    private void check(X509Certificate xcert,
<i>341</i>&nbsp;                       Collection&lt;String&gt; unresolvedCritExts,
<i>342</i>&nbsp;                       PublicKey pubKey, boolean crlSignFlag)
<i>343</i>&nbsp;        throws CertPathValidatorException
<i>344</i>&nbsp;    {
<b class="nc"><i>345</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>346</i>&nbsp;            debug.println(&quot;RevocationChecker.check: checking cert&quot; +</b>
<b class="nc"><i>347</i>&nbsp;                &quot;\n  SN: &quot; + Debug.toHexString(xcert.getSerialNumber()) +</b>
<b class="nc"><i>348</i>&nbsp;                &quot;\n  Subject: &quot; + xcert.getSubjectX500Principal() +</b>
<b class="nc"><i>349</i>&nbsp;                &quot;\n  Issuer: &quot; + xcert.getIssuerX500Principal());</b>
<i>350</i>&nbsp;        }
<i>351</i>&nbsp;        try {
<b class="nc"><i>352</i>&nbsp;            if (onlyEE &amp;&amp; xcert.getBasicConstraints() != -1) {</b>
<b class="nc"><i>353</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>354</i>&nbsp;                    debug.println(&quot;Skipping revocation check; cert is not &quot; +</b>
<i>355</i>&nbsp;                                  &quot;an end entity cert&quot;);
<i>356</i>&nbsp;                }
<i>357</i>&nbsp;                return;
<i>358</i>&nbsp;            }
<b class="nc"><i>359</i>&nbsp;            switch (mode) {</b>
<i>360</i>&nbsp;                case PREFER_OCSP:
<i>361</i>&nbsp;                case ONLY_OCSP:
<b class="nc"><i>362</i>&nbsp;                    checkOCSP(xcert, unresolvedCritExts);</b>
<b class="nc"><i>363</i>&nbsp;                    break;</b>
<i>364</i>&nbsp;                case PREFER_CRLS:
<i>365</i>&nbsp;                case ONLY_CRLS:
<b class="nc"><i>366</i>&nbsp;                    checkCRLs(xcert, unresolvedCritExts, null,</b>
<i>367</i>&nbsp;                              pubKey, crlSignFlag);
<i>368</i>&nbsp;                    break;
<i>369</i>&nbsp;            }
<b class="nc"><i>370</i>&nbsp;        } catch (CertPathValidatorException e) {</b>
<b class="nc"><i>371</i>&nbsp;            if (e.getReason() == BasicReason.REVOKED) {</b>
<b class="nc"><i>372</i>&nbsp;                throw e;</b>
<i>373</i>&nbsp;            }
<b class="nc"><i>374</i>&nbsp;            boolean eSoftFail = isSoftFailException(e);</b>
<b class="nc"><i>375</i>&nbsp;            if (eSoftFail) {</b>
<b class="nc"><i>376</i>&nbsp;                if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {</b>
<i>377</i>&nbsp;                    return;
<i>378</i>&nbsp;                }
<i>379</i>&nbsp;            } else {
<b class="nc"><i>380</i>&nbsp;                if (mode == Mode.ONLY_OCSP || mode == Mode.ONLY_CRLS) {</b>
<b class="nc"><i>381</i>&nbsp;                    throw e;</b>
<i>382</i>&nbsp;                }
<i>383</i>&nbsp;            }
<b class="nc"><i>384</i>&nbsp;            CertPathValidatorException cause = e;</b>
<i>385</i>&nbsp;            // Otherwise, failover
<b class="nc"><i>386</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>387</i>&nbsp;                debug.println(&quot;RevocationChecker.check() &quot; + e.getMessage());</b>
<b class="nc"><i>388</i>&nbsp;                debug.println(&quot;RevocationChecker.check() preparing to failover&quot;);</b>
<i>389</i>&nbsp;            }
<i>390</i>&nbsp;            try {
<b class="nc"><i>391</i>&nbsp;                switch (mode) {</b>
<i>392</i>&nbsp;                    case PREFER_OCSP:
<b class="nc"><i>393</i>&nbsp;                        checkCRLs(xcert, unresolvedCritExts, null,</b>
<i>394</i>&nbsp;                                  pubKey, crlSignFlag);
<b class="nc"><i>395</i>&nbsp;                        break;</b>
<i>396</i>&nbsp;                    case PREFER_CRLS:
<b class="nc"><i>397</i>&nbsp;                        checkOCSP(xcert, unresolvedCritExts);</b>
<i>398</i>&nbsp;                        break;
<i>399</i>&nbsp;                }
<b class="nc"><i>400</i>&nbsp;            } catch (CertPathValidatorException x) {</b>
<b class="nc"><i>401</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>402</i>&nbsp;                    debug.println(&quot;RevocationChecker.check() failover failed&quot;);</b>
<b class="nc"><i>403</i>&nbsp;                    debug.println(&quot;RevocationChecker.check() &quot; + x.getMessage());</b>
<i>404</i>&nbsp;                }
<b class="nc"><i>405</i>&nbsp;                if (x.getReason() == BasicReason.REVOKED) {</b>
<b class="nc"><i>406</i>&nbsp;                    throw x;</b>
<i>407</i>&nbsp;                }
<b class="nc"><i>408</i>&nbsp;                if (!isSoftFailException(x)) {</b>
<b class="nc"><i>409</i>&nbsp;                    cause.addSuppressed(x);</b>
<b class="nc"><i>410</i>&nbsp;                    throw cause;</b>
<i>411</i>&nbsp;                } else {
<i>412</i>&nbsp;                    // only pass if both exceptions were soft failures
<b class="nc"><i>413</i>&nbsp;                    if (!eSoftFail) {</b>
<b class="nc"><i>414</i>&nbsp;                        throw cause;</b>
<i>415</i>&nbsp;                    }
<i>416</i>&nbsp;                }
<b class="nc"><i>417</i>&nbsp;            }</b>
<i>418</i>&nbsp;        } finally {
<b class="nc"><i>419</i>&nbsp;            updateState(xcert);</b>
<b class="nc"><i>420</i>&nbsp;        }</b>
<i>421</i>&nbsp;    }
<i>422</i>&nbsp;
<i>423</i>&nbsp;    private boolean isSoftFailException(CertPathValidatorException e) {
<b class="nc"><i>424</i>&nbsp;        if (softFail &amp;&amp;</b>
<b class="nc"><i>425</i>&nbsp;            e.getReason() == BasicReason.UNDETERMINED_REVOCATION_STATUS)</b>
<i>426</i>&nbsp;        {
<i>427</i>&nbsp;            // recreate exception with correct index
<b class="nc"><i>428</i>&nbsp;            CertPathValidatorException e2 = new CertPathValidatorException(</b>
<b class="nc"><i>429</i>&nbsp;                e.getMessage(), e.getCause(), params.certPath(), certIndex,</b>
<b class="nc"><i>430</i>&nbsp;                e.getReason());</b>
<b class="nc"><i>431</i>&nbsp;            softFailExceptions.addFirst(e2);</b>
<b class="nc"><i>432</i>&nbsp;            return true;</b>
<i>433</i>&nbsp;        }
<b class="nc"><i>434</i>&nbsp;        return false;</b>
<i>435</i>&nbsp;    }
<i>436</i>&nbsp;
<i>437</i>&nbsp;    private void updateState(X509Certificate cert)
<i>438</i>&nbsp;        throws CertPathValidatorException
<i>439</i>&nbsp;    {
<b class="nc"><i>440</i>&nbsp;        issuerInfo = new OCSPResponse.IssuerInfo(anchor, cert);</b>
<i>441</i>&nbsp;
<i>442</i>&nbsp;        // Make new public key if parameters are missing
<b class="nc"><i>443</i>&nbsp;        PublicKey pubKey = cert.getPublicKey();</b>
<b class="nc"><i>444</i>&nbsp;        if (PKIX.isDSAPublicKeyWithoutParams(pubKey)) {</b>
<i>445</i>&nbsp;            // pubKey needs to inherit DSA parameters from prev key
<b class="nc"><i>446</i>&nbsp;            pubKey = BasicChecker.makeInheritedParamsKey(pubKey, prevPubKey);</b>
<i>447</i>&nbsp;        }
<b class="nc"><i>448</i>&nbsp;        prevPubKey = pubKey;</b>
<b class="nc"><i>449</i>&nbsp;        crlSignFlag = certCanSignCrl(cert);</b>
<b class="nc"><i>450</i>&nbsp;        if (certIndex &gt; 0) {</b>
<b class="nc"><i>451</i>&nbsp;            certIndex--;</b>
<i>452</i>&nbsp;        }
<i>453</i>&nbsp;    }
<i>454</i>&nbsp;
<i>455</i>&nbsp;    // Maximum clock skew in milliseconds (15 minutes) allowed when checking
<i>456</i>&nbsp;    // validity of CRLs
<i>457</i>&nbsp;    private static final long MAX_CLOCK_SKEW = 900000;
<i>458</i>&nbsp;    private void checkCRLs(X509Certificate cert,
<i>459</i>&nbsp;                           Collection&lt;String&gt; unresolvedCritExts,
<i>460</i>&nbsp;                           Set&lt;X509Certificate&gt; stackedCerts,
<i>461</i>&nbsp;                           PublicKey pubKey, boolean signFlag)
<i>462</i>&nbsp;        throws CertPathValidatorException
<i>463</i>&nbsp;    {
<b class="nc"><i>464</i>&nbsp;        checkCRLs(cert, pubKey, null, signFlag, true,</b>
<b class="nc"><i>465</i>&nbsp;                  stackedCerts, params.trustAnchors());</b>
<i>466</i>&nbsp;    }
<i>467</i>&nbsp;
<i>468</i>&nbsp;    static boolean isCausedByNetworkIssue(String type, CertStoreException cse) {
<i>469</i>&nbsp;        boolean result;
<b class="nc"><i>470</i>&nbsp;        Throwable t = cse.getCause();</b>
<i>471</i>&nbsp;
<b class="nc"><i>472</i>&nbsp;        switch (type) {</b>
<i>473</i>&nbsp;            case &quot;LDAP&quot;:
<b class="nc"><i>474</i>&nbsp;                if (t != null) {</b>
<i>475</i>&nbsp;                    // These two exception classes are inside java.naming module
<b class="nc"><i>476</i>&nbsp;                    String cn = t.getClass().getName();</b>
<b class="nc"><i>477</i>&nbsp;                    result = (cn.equals(&quot;javax.naming.ServiceUnavailableException&quot;) ||</b>
<b class="nc"><i>478</i>&nbsp;                        cn.equals(&quot;javax.naming.CommunicationException&quot;));</b>
<b class="nc"><i>479</i>&nbsp;                } else {</b>
<b class="nc"><i>480</i>&nbsp;                    result = false;</b>
<i>481</i>&nbsp;                }
<b class="nc"><i>482</i>&nbsp;                break;</b>
<i>483</i>&nbsp;            case &quot;SSLServer&quot;:
<b class="nc"><i>484</i>&nbsp;                result = (t != null &amp;&amp; t instanceof IOException);</b>
<b class="nc"><i>485</i>&nbsp;                break;</b>
<i>486</i>&nbsp;            case &quot;URI&quot;:
<b class="nc"><i>487</i>&nbsp;                result = (t != null &amp;&amp; t instanceof IOException);</b>
<b class="nc"><i>488</i>&nbsp;                break;</b>
<i>489</i>&nbsp;            default:
<i>490</i>&nbsp;                // we don&#39;t know about any other remote CertStore types
<b class="nc"><i>491</i>&nbsp;                return false;</b>
<i>492</i>&nbsp;        }
<b class="nc"><i>493</i>&nbsp;        return result;</b>
<i>494</i>&nbsp;    }
<i>495</i>&nbsp;
<i>496</i>&nbsp;    private void checkCRLs(X509Certificate cert, PublicKey prevKey,
<i>497</i>&nbsp;                           X509Certificate prevCert, boolean signFlag,
<i>498</i>&nbsp;                           boolean allowSeparateKey,
<i>499</i>&nbsp;                           Set&lt;X509Certificate&gt; stackedCerts,
<i>500</i>&nbsp;                           Set&lt;TrustAnchor&gt; anchors)
<i>501</i>&nbsp;        throws CertPathValidatorException
<i>502</i>&nbsp;    {
<b class="nc"><i>503</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>504</i>&nbsp;            debug.println(&quot;RevocationChecker.checkCRLs()&quot; +</b>
<i>505</i>&nbsp;                          &quot; ---checking revocation status ...&quot;);
<i>506</i>&nbsp;        }
<i>507</i>&nbsp;
<i>508</i>&nbsp;        // Reject circular dependencies - RFC 5280 is not explicit on how
<i>509</i>&nbsp;        // to handle this, but does suggest that they can be a security
<i>510</i>&nbsp;        // risk and can create unresolvable dependencies
<b class="nc"><i>511</i>&nbsp;        if (stackedCerts != null &amp;&amp; stackedCerts.contains(cert)) {</b>
<b class="nc"><i>512</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>513</i>&nbsp;                debug.println(&quot;RevocationChecker.checkCRLs()&quot; +</b>
<i>514</i>&nbsp;                              &quot; circular dependency&quot;);
<i>515</i>&nbsp;            }
<b class="nc"><i>516</i>&nbsp;            throw new CertPathValidatorException</b>
<i>517</i>&nbsp;                 (&quot;Could not determine revocation status&quot;, null, null, -1,
<i>518</i>&nbsp;                  BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>519</i>&nbsp;        }
<i>520</i>&nbsp;
<b class="nc"><i>521</i>&nbsp;        Set&lt;X509CRL&gt; possibleCRLs = new HashSet&lt;&gt;();</b>
<b class="nc"><i>522</i>&nbsp;        Set&lt;X509CRL&gt; approvedCRLs = new HashSet&lt;&gt;();</b>
<b class="nc"><i>523</i>&nbsp;        X509CRLSelector sel = new X509CRLSelector();</b>
<b class="nc"><i>524</i>&nbsp;        sel.setCertificateChecking(cert);</b>
<b class="nc"><i>525</i>&nbsp;        CertPathHelper.setDateAndTime(sel, params.date(), MAX_CLOCK_SKEW);</b>
<i>526</i>&nbsp;
<i>527</i>&nbsp;        // First, check user-specified CertStores
<b class="nc"><i>528</i>&nbsp;        CertPathValidatorException networkFailureException = null;</b>
<b class="nc"><i>529</i>&nbsp;        for (CertStore store : certStores) {</b>
<i>530</i>&nbsp;            try {
<b class="nc"><i>531</i>&nbsp;                for (CRL crl : store.getCRLs(sel)) {</b>
<b class="nc"><i>532</i>&nbsp;                    possibleCRLs.add((X509CRL)crl);</b>
<b class="nc"><i>533</i>&nbsp;                }</b>
<b class="nc"><i>534</i>&nbsp;            } catch (CertStoreException e) {</b>
<b class="nc"><i>535</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>536</i>&nbsp;                    debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</b>
<b class="nc"><i>537</i>&nbsp;                                  &quot;CertStoreException: &quot; + e.getMessage());</b>
<i>538</i>&nbsp;                }
<b class="nc"><i>539</i>&nbsp;                if (networkFailureException == null &amp;&amp;</b>
<b class="nc"><i>540</i>&nbsp;                    isCausedByNetworkIssue(store.getType(),e)) {</b>
<i>541</i>&nbsp;                    // save this exception, we may need to throw it later
<b class="nc"><i>542</i>&nbsp;                    networkFailureException = new CertPathValidatorException(</b>
<i>543</i>&nbsp;                        &quot;Unable to determine revocation status due to &quot; +
<i>544</i>&nbsp;                        &quot;network error&quot;, e, null, -1,
<i>545</i>&nbsp;                        BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>546</i>&nbsp;                }
<b class="nc"><i>547</i>&nbsp;            }</b>
<b class="nc"><i>548</i>&nbsp;        }</b>
<i>549</i>&nbsp;
<b class="nc"><i>550</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>551</i>&nbsp;            debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</b>
<b class="nc"><i>552</i>&nbsp;                          &quot;possible crls.size() = &quot; + possibleCRLs.size());</b>
<i>553</i>&nbsp;        }
<b class="nc"><i>554</i>&nbsp;        boolean[] reasonsMask = new boolean[9];</b>
<b class="nc"><i>555</i>&nbsp;        if (!possibleCRLs.isEmpty()) {</b>
<i>556</i>&nbsp;            // Now that we have a list of possible CRLs, see which ones can
<i>557</i>&nbsp;            // be approved
<b class="nc"><i>558</i>&nbsp;            approvedCRLs.addAll(verifyPossibleCRLs(possibleCRLs, cert, prevKey,</b>
<i>559</i>&nbsp;                                                   signFlag, reasonsMask,
<i>560</i>&nbsp;                                                   anchors));
<i>561</i>&nbsp;        }
<i>562</i>&nbsp;
<b class="nc"><i>563</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>564</i>&nbsp;            debug.println(&quot;RevocationChecker.checkCRLs() &quot; +</b>
<b class="nc"><i>565</i>&nbsp;                          &quot;approved crls.size() = &quot; + approvedCRLs.size());</b>
<i>566</i>&nbsp;        }
<i>567</i>&nbsp;
<i>568</i>&nbsp;        // make sure that we have at least one CRL that _could_ cover
<i>569</i>&nbsp;        // the certificate in question and all reasons are covered
<b class="nc"><i>570</i>&nbsp;        if (!approvedCRLs.isEmpty() &amp;&amp;</b>
<b class="nc"><i>571</i>&nbsp;            Arrays.equals(reasonsMask, ALL_REASONS))</b>
<i>572</i>&nbsp;        {
<b class="nc"><i>573</i>&nbsp;            checkApprovedCRLs(cert, approvedCRLs);</b>
<i>574</i>&nbsp;        } else {
<i>575</i>&nbsp;            // Check Distribution Points
<i>576</i>&nbsp;            // all CRLs returned by the DP Fetcher have also been verified
<i>577</i>&nbsp;            try {
<b class="nc"><i>578</i>&nbsp;                if (crlDP) {</b>
<b class="nc"><i>579</i>&nbsp;                    approvedCRLs.addAll(DistributionPointFetcher.getCRLs(</b>
<i>580</i>&nbsp;                                        sel, signFlag, prevKey, prevCert,
<b class="nc"><i>581</i>&nbsp;                                        params.sigProvider(), certStores,</b>
<b class="nc"><i>582</i>&nbsp;                                        reasonsMask, anchors, null, params.variant()));</b>
<i>583</i>&nbsp;                }
<b class="nc"><i>584</i>&nbsp;            } catch (CertStoreException e) {</b>
<b class="nc"><i>585</i>&nbsp;                if (e instanceof CertStoreTypeException) {</b>
<b class="nc"><i>586</i>&nbsp;                    CertStoreTypeException cste = (CertStoreTypeException)e;</b>
<b class="nc"><i>587</i>&nbsp;                    if (isCausedByNetworkIssue(cste.getType(), e)) {</b>
<b class="nc"><i>588</i>&nbsp;                        throw new CertPathValidatorException(</b>
<i>589</i>&nbsp;                            &quot;Unable to determine revocation status due to &quot; +
<i>590</i>&nbsp;                            &quot;network error&quot;, e, null, -1,
<i>591</i>&nbsp;                            BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>592</i>&nbsp;                    }
<i>593</i>&nbsp;                }
<b class="nc"><i>594</i>&nbsp;                throw new CertPathValidatorException(e);</b>
<b class="nc"><i>595</i>&nbsp;            }</b>
<b class="nc"><i>596</i>&nbsp;            if (!approvedCRLs.isEmpty() &amp;&amp;</b>
<b class="nc"><i>597</i>&nbsp;                Arrays.equals(reasonsMask, ALL_REASONS))</b>
<i>598</i>&nbsp;            {
<b class="nc"><i>599</i>&nbsp;                checkApprovedCRLs(cert, approvedCRLs);</b>
<i>600</i>&nbsp;            } else {
<b class="nc"><i>601</i>&nbsp;                if (allowSeparateKey) {</b>
<i>602</i>&nbsp;                    try {
<b class="nc"><i>603</i>&nbsp;                        verifyWithSeparateSigningKey(cert, prevKey, signFlag,</b>
<i>604</i>&nbsp;                                                     stackedCerts);
<i>605</i>&nbsp;                        return;
<b class="nc"><i>606</i>&nbsp;                    } catch (CertPathValidatorException cpve) {</b>
<b class="nc"><i>607</i>&nbsp;                        if (networkFailureException != null) {</b>
<i>608</i>&nbsp;                            // if a network issue previously prevented us from
<i>609</i>&nbsp;                            // retrieving a CRL from one of the user-specified
<i>610</i>&nbsp;                            // CertStores, throw it now so it can be handled
<i>611</i>&nbsp;                            // appropriately
<b class="nc"><i>612</i>&nbsp;                            throw networkFailureException;</b>
<i>613</i>&nbsp;                        }
<b class="nc"><i>614</i>&nbsp;                        throw cpve;</b>
<i>615</i>&nbsp;                    }
<i>616</i>&nbsp;                } else {
<b class="nc"><i>617</i>&nbsp;                    if (networkFailureException != null) {</b>
<i>618</i>&nbsp;                        // if a network issue previously prevented us from
<i>619</i>&nbsp;                        // retrieving a CRL from one of the user-specified
<i>620</i>&nbsp;                        // CertStores, throw it now so it can be handled
<i>621</i>&nbsp;                        // appropriately
<b class="nc"><i>622</i>&nbsp;                        throw networkFailureException;</b>
<i>623</i>&nbsp;                    }
<b class="nc"><i>624</i>&nbsp;                    throw new CertPathValidatorException(</b>
<i>625</i>&nbsp;                        &quot;Could not determine revocation status&quot;, null, null, -1,
<i>626</i>&nbsp;                        BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>627</i>&nbsp;                }
<i>628</i>&nbsp;            }
<i>629</i>&nbsp;        }
<i>630</i>&nbsp;    }
<i>631</i>&nbsp;
<i>632</i>&nbsp;    private void checkApprovedCRLs(X509Certificate cert,
<i>633</i>&nbsp;                                   Set&lt;X509CRL&gt; approvedCRLs)
<i>634</i>&nbsp;        throws CertPathValidatorException
<i>635</i>&nbsp;    {
<i>636</i>&nbsp;        // See if the cert is in the set of approved crls.
<b class="nc"><i>637</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>638</i>&nbsp;            BigInteger sn = cert.getSerialNumber();</b>
<b class="nc"><i>639</i>&nbsp;            debug.println(&quot;RevocationChecker.checkApprovedCRLs() &quot; +</b>
<i>640</i>&nbsp;                          &quot;starting the final sweep...&quot;);
<b class="nc"><i>641</i>&nbsp;            debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot; +</b>
<b class="nc"><i>642</i>&nbsp;                          &quot; cert SN: &quot; + sn.toString());</b>
<i>643</i>&nbsp;        }
<i>644</i>&nbsp;
<b class="nc"><i>645</i>&nbsp;        CRLReason reasonCode = CRLReason.UNSPECIFIED;</b>
<b class="nc"><i>646</i>&nbsp;        X509CRLEntryImpl entry = null;</b>
<b class="nc"><i>647</i>&nbsp;        for (X509CRL crl : approvedCRLs) {</b>
<b class="nc"><i>648</i>&nbsp;            X509CRLEntry e = crl.getRevokedCertificate(cert);</b>
<b class="nc"><i>649</i>&nbsp;            if (e != null) {</b>
<i>650</i>&nbsp;                try {
<b class="nc"><i>651</i>&nbsp;                    entry = X509CRLEntryImpl.toImpl(e);</b>
<b class="nc"><i>652</i>&nbsp;                } catch (CRLException ce) {</b>
<b class="nc"><i>653</i>&nbsp;                    throw new CertPathValidatorException(ce);</b>
<b class="nc"><i>654</i>&nbsp;                }</b>
<b class="nc"><i>655</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>656</i>&nbsp;                    debug.println(&quot;RevocationChecker.checkApprovedCRLs()&quot;</b>
<b class="nc"><i>657</i>&nbsp;                        + &quot; CRL entry: &quot; + entry.toString());</b>
<i>658</i>&nbsp;                }
<i>659</i>&nbsp;
<i>660</i>&nbsp;                /*
<i>661</i>&nbsp;                 * Abort CRL validation and throw exception if there are any
<i>662</i>&nbsp;                 * unrecognized critical CRL entry extensions (see section
<i>663</i>&nbsp;                 * 5.3 of RFC 5280).
<i>664</i>&nbsp;                 */
<b class="nc"><i>665</i>&nbsp;                Set&lt;String&gt; unresCritExts = entry.getCriticalExtensionOIDs();</b>
<b class="nc"><i>666</i>&nbsp;                if (unresCritExts != null &amp;&amp; !unresCritExts.isEmpty()) {</b>
<i>667</i>&nbsp;                    /* remove any that we will process */
<b class="nc"><i>668</i>&nbsp;                    unresCritExts.remove(ReasonCode_Id.toString());</b>
<b class="nc"><i>669</i>&nbsp;                    unresCritExts.remove(CertificateIssuer_Id.toString());</b>
<b class="nc"><i>670</i>&nbsp;                    if (!unresCritExts.isEmpty()) {</b>
<b class="nc"><i>671</i>&nbsp;                        throw new CertPathValidatorException(</b>
<i>672</i>&nbsp;                            &quot;Unrecognized critical extension(s) in revoked &quot; +
<i>673</i>&nbsp;                            &quot;CRL entry&quot;);
<i>674</i>&nbsp;                    }
<i>675</i>&nbsp;                }
<i>676</i>&nbsp;
<b class="nc"><i>677</i>&nbsp;                reasonCode = entry.getRevocationReason();</b>
<b class="nc"><i>678</i>&nbsp;                if (reasonCode == null) {</b>
<b class="nc"><i>679</i>&nbsp;                    reasonCode = CRLReason.UNSPECIFIED;</b>
<i>680</i>&nbsp;                }
<b class="nc"><i>681</i>&nbsp;                Date revocationDate = entry.getRevocationDate();</b>
<b class="nc"><i>682</i>&nbsp;                if (revocationDate.before(params.date())) {</b>
<b class="nc"><i>683</i>&nbsp;                    Throwable t = new CertificateRevokedException(</b>
<i>684</i>&nbsp;                        revocationDate, reasonCode,
<b class="nc"><i>685</i>&nbsp;                        crl.getIssuerX500Principal(), entry.getExtensions());</b>
<b class="nc"><i>686</i>&nbsp;                    throw new CertPathValidatorException(</b>
<b class="nc"><i>687</i>&nbsp;                        t.getMessage(), t, null, -1, BasicReason.REVOKED);</b>
<i>688</i>&nbsp;                }
<i>689</i>&nbsp;            }
<b class="nc"><i>690</i>&nbsp;        }</b>
<i>691</i>&nbsp;    }
<i>692</i>&nbsp;
<i>693</i>&nbsp;    private void checkOCSP(X509Certificate cert,
<i>694</i>&nbsp;                           Collection&lt;String&gt; unresolvedCritExts)
<i>695</i>&nbsp;        throws CertPathValidatorException
<i>696</i>&nbsp;    {
<b class="nc"><i>697</i>&nbsp;        X509CertImpl currCert = null;</b>
<i>698</i>&nbsp;        try {
<b class="nc"><i>699</i>&nbsp;            currCert = X509CertImpl.toImpl(cert);</b>
<b class="nc"><i>700</i>&nbsp;        } catch (CertificateException ce) {</b>
<b class="nc"><i>701</i>&nbsp;            throw new CertPathValidatorException(ce);</b>
<b class="nc"><i>702</i>&nbsp;        }</b>
<i>703</i>&nbsp;
<i>704</i>&nbsp;        // The algorithm constraints of the OCSP trusted responder certificate
<i>705</i>&nbsp;        // does not need to be checked in this code. The constraints will be
<i>706</i>&nbsp;        // checked when the responder&#39;s certificate is validated.
<i>707</i>&nbsp;
<b class="nc"><i>708</i>&nbsp;        OCSPResponse response = null;</b>
<b class="nc"><i>709</i>&nbsp;        CertId certId = null;</b>
<i>710</i>&nbsp;        try {
<b class="nc"><i>711</i>&nbsp;            certId = new CertId(issuerInfo.getName(), issuerInfo.getPublicKey(),</b>
<b class="nc"><i>712</i>&nbsp;                    currCert.getSerialNumberObject());</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;            // check if there is a cached OCSP response available
<b class="nc"><i>715</i>&nbsp;            byte[] responseBytes = ocspResponses.get(cert);</b>
<b class="nc"><i>716</i>&nbsp;            if (responseBytes != null) {</b>
<b class="nc"><i>717</i>&nbsp;                if (debug != null) {</b>
<b class="nc"><i>718</i>&nbsp;                    debug.println(&quot;Found cached OCSP response&quot;);</b>
<i>719</i>&nbsp;                }
<b class="nc"><i>720</i>&nbsp;                response = new OCSPResponse(responseBytes);</b>
<i>721</i>&nbsp;
<i>722</i>&nbsp;                // verify the response
<b class="nc"><i>723</i>&nbsp;                byte[] nonce = null;</b>
<b class="nc"><i>724</i>&nbsp;                for (Extension ext : ocspExtensions) {</b>
<b class="nc"><i>725</i>&nbsp;                    if (ext.getId().equals(&quot;1.3.6.1.5.5.7.48.1.2&quot;)) {</b>
<b class="nc"><i>726</i>&nbsp;                        nonce = ext.getValue();</b>
<i>727</i>&nbsp;                    }
<b class="nc"><i>728</i>&nbsp;                }</b>
<b class="nc"><i>729</i>&nbsp;                response.verify(Collections.singletonList(certId), issuerInfo,</b>
<b class="nc"><i>730</i>&nbsp;                        responderCert, params.date(), nonce, params.variant());</b>
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;            } else {</b>
<b class="nc"><i>733</i>&nbsp;                URI responderURI = (this.responderURI != null)</b>
<i>734</i>&nbsp;                                   ? this.responderURI
<b class="nc"><i>735</i>&nbsp;                                   : OCSP.getResponderURI(currCert);</b>
<b class="nc"><i>736</i>&nbsp;                if (responderURI == null) {</b>
<b class="nc"><i>737</i>&nbsp;                    throw new CertPathValidatorException(</b>
<i>738</i>&nbsp;                        &quot;Certificate does not specify OCSP responder&quot;, null,
<i>739</i>&nbsp;                        null, -1);
<i>740</i>&nbsp;                }
<i>741</i>&nbsp;
<b class="nc"><i>742</i>&nbsp;                response = OCSP.check(Collections.singletonList(certId),</b>
<i>743</i>&nbsp;                        responderURI, issuerInfo, responderCert, null,
<b class="nc"><i>744</i>&nbsp;                        ocspExtensions, params.variant());</b>
<i>745</i>&nbsp;            }
<b class="nc"><i>746</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>747</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>748</i>&nbsp;                &quot;Unable to determine revocation status due to network error&quot;,
<i>749</i>&nbsp;                e, null, -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);
<b class="nc"><i>750</i>&nbsp;        }</b>
<i>751</i>&nbsp;
<b class="nc"><i>752</i>&nbsp;        RevocationStatus rs =</b>
<b class="nc"><i>753</i>&nbsp;            (RevocationStatus)response.getSingleResponse(certId);</b>
<b class="nc"><i>754</i>&nbsp;        RevocationStatus.CertStatus certStatus = rs.getCertStatus();</b>
<b class="nc"><i>755</i>&nbsp;        if (certStatus == RevocationStatus.CertStatus.REVOKED) {</b>
<b class="nc"><i>756</i>&nbsp;            Date revocationTime = rs.getRevocationTime();</b>
<b class="nc"><i>757</i>&nbsp;            if (revocationTime.before(params.date())) {</b>
<b class="nc"><i>758</i>&nbsp;                Throwable t = new CertificateRevokedException(</b>
<b class="nc"><i>759</i>&nbsp;                    revocationTime, rs.getRevocationReason(),</b>
<b class="nc"><i>760</i>&nbsp;                    response.getSignerCertificate().getSubjectX500Principal(),</b>
<b class="nc"><i>761</i>&nbsp;                    rs.getSingleExtensions());</b>
<b class="nc"><i>762</i>&nbsp;                throw new CertPathValidatorException(t.getMessage(), t, null,</b>
<i>763</i>&nbsp;                                                     -1, BasicReason.REVOKED);
<i>764</i>&nbsp;            }
<b class="nc"><i>765</i>&nbsp;        } else if (certStatus == RevocationStatus.CertStatus.UNKNOWN) {</b>
<b class="nc"><i>766</i>&nbsp;            throw new CertPathValidatorException(</b>
<i>767</i>&nbsp;                &quot;Certificate&#39;s revocation status is unknown&quot;, null,
<b class="nc"><i>768</i>&nbsp;                params.certPath(), -1,</b>
<i>769</i>&nbsp;                BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>770</i>&nbsp;        }
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /*
<i>774</i>&nbsp;     * Removes any non-hexadecimal characters from a string.
<i>775</i>&nbsp;     */
<i>776</i>&nbsp;    private static final String HEX_DIGITS = &quot;0123456789ABCDEFabcdef&quot;;
<i>777</i>&nbsp;    private static String stripOutSeparators(String value) {
<b class="nc"><i>778</i>&nbsp;        char[] chars = value.toCharArray();</b>
<b class="nc"><i>779</i>&nbsp;        StringBuilder hexNumber = new StringBuilder();</b>
<b class="nc"><i>780</i>&nbsp;        for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="nc"><i>781</i>&nbsp;            if (HEX_DIGITS.indexOf(chars[i]) != -1) {</b>
<b class="nc"><i>782</i>&nbsp;                hexNumber.append(chars[i]);</b>
<i>783</i>&nbsp;            }
<i>784</i>&nbsp;        }
<b class="nc"><i>785</i>&nbsp;        return hexNumber.toString();</b>
<i>786</i>&nbsp;    }
<i>787</i>&nbsp;
<i>788</i>&nbsp;    /**
<i>789</i>&nbsp;     * Checks that a cert can be used to verify a CRL.
<i>790</i>&nbsp;     *
<i>791</i>&nbsp;     * @param cert an X509Certificate to check
<i>792</i>&nbsp;     * @return a boolean specifying if the cert is allowed to vouch for the
<i>793</i>&nbsp;     *         validity of a CRL
<i>794</i>&nbsp;     */
<i>795</i>&nbsp;    static boolean certCanSignCrl(X509Certificate cert) {
<i>796</i>&nbsp;        // if the cert doesn&#39;t include the key usage ext, or
<i>797</i>&nbsp;        // the key usage ext asserts cRLSigning, return true,
<i>798</i>&nbsp;        // otherwise return false.
<b class="nc"><i>799</i>&nbsp;        boolean[] keyUsage = cert.getKeyUsage();</b>
<b class="nc"><i>800</i>&nbsp;        if (keyUsage != null) {</b>
<b class="nc"><i>801</i>&nbsp;            return keyUsage[6];</b>
<i>802</i>&nbsp;        }
<b class="nc"><i>803</i>&nbsp;        return false;</b>
<i>804</i>&nbsp;    }
<i>805</i>&nbsp;
<i>806</i>&nbsp;    /**
<i>807</i>&nbsp;     * Internal method that verifies a set of possible_crls,
<i>808</i>&nbsp;     * and sees if each is approved, based on the cert.
<i>809</i>&nbsp;     *
<i>810</i>&nbsp;     * @param crls a set of possible CRLs to test for acceptability
<i>811</i>&nbsp;     * @param cert the certificate whose revocation status is being checked
<i>812</i>&nbsp;     * @param signFlag &lt;code&gt;true&lt;/code&gt; if prevKey was trusted to sign CRLs
<i>813</i>&nbsp;     * @param prevKey the public key of the issuer of cert
<i>814</i>&nbsp;     * @param reasonsMask the reason code mask
<i>815</i>&nbsp;     * @param trustAnchors a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;TrustAnchor&lt;/code&gt;s&gt;
<i>816</i>&nbsp;     * @return a collection of approved crls (or an empty collection)
<i>817</i>&nbsp;     */
<b class="nc"><i>818</i>&nbsp;    private static final boolean[] ALL_REASONS =</b>
<i>819</i>&nbsp;        {true, true, true, true, true, true, true, true, true};
<i>820</i>&nbsp;    private Collection&lt;X509CRL&gt; verifyPossibleCRLs(Set&lt;X509CRL&gt; crls,
<i>821</i>&nbsp;                                                   X509Certificate cert,
<i>822</i>&nbsp;                                                   PublicKey prevKey,
<i>823</i>&nbsp;                                                   boolean signFlag,
<i>824</i>&nbsp;                                                   boolean[] reasonsMask,
<i>825</i>&nbsp;                                                   Set&lt;TrustAnchor&gt; anchors)
<i>826</i>&nbsp;        throws CertPathValidatorException
<i>827</i>&nbsp;    {
<i>828</i>&nbsp;        try {
<b class="nc"><i>829</i>&nbsp;            X509CertImpl certImpl = X509CertImpl.toImpl(cert);</b>
<b class="nc"><i>830</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>831</i>&nbsp;                debug.println(&quot;RevocationChecker.verifyPossibleCRLs: &quot; +</b>
<i>832</i>&nbsp;                              &quot;Checking CRLDPs for &quot;
<b class="nc"><i>833</i>&nbsp;                              + certImpl.getSubjectX500Principal());</b>
<i>834</i>&nbsp;            }
<b class="nc"><i>835</i>&nbsp;            CRLDistributionPointsExtension ext =</b>
<b class="nc"><i>836</i>&nbsp;                certImpl.getCRLDistributionPointsExtension();</b>
<b class="nc"><i>837</i>&nbsp;            List&lt;DistributionPoint&gt; points = null;</b>
<b class="nc"><i>838</i>&nbsp;            if (ext == null) {</b>
<i>839</i>&nbsp;                // assume a DP with reasons and CRLIssuer fields omitted
<i>840</i>&nbsp;                // and a DP name of the cert issuer.
<i>841</i>&nbsp;                // TODO add issuerAltName too
<b class="nc"><i>842</i>&nbsp;                X500Name certIssuer = (X500Name)certImpl.getIssuerDN();</b>
<b class="nc"><i>843</i>&nbsp;                DistributionPoint point = new DistributionPoint(</b>
<b class="nc"><i>844</i>&nbsp;                     new GeneralNames().add(new GeneralName(certIssuer)),</b>
<i>845</i>&nbsp;                     null, null);
<b class="nc"><i>846</i>&nbsp;                points = Collections.singletonList(point);</b>
<b class="nc"><i>847</i>&nbsp;            } else {</b>
<b class="nc"><i>848</i>&nbsp;                points = ext.get(CRLDistributionPointsExtension.POINTS);</b>
<i>849</i>&nbsp;            }
<b class="nc"><i>850</i>&nbsp;            Set&lt;X509CRL&gt; results = new HashSet&lt;&gt;();</b>
<b class="nc"><i>851</i>&nbsp;            for (DistributionPoint point : points) {</b>
<b class="nc"><i>852</i>&nbsp;                for (X509CRL crl : crls) {</b>
<b class="nc"><i>853</i>&nbsp;                    if (DistributionPointFetcher.verifyCRL(</b>
<i>854</i>&nbsp;                            certImpl, point, crl, reasonsMask, signFlag,
<b class="nc"><i>855</i>&nbsp;                            prevKey, null, params.sigProvider(), anchors,</b>
<b class="nc"><i>856</i>&nbsp;                            certStores, params.date(), params.variant()))</b>
<i>857</i>&nbsp;                    {
<b class="nc"><i>858</i>&nbsp;                        results.add(crl);</b>
<i>859</i>&nbsp;                    }
<b class="nc"><i>860</i>&nbsp;                }</b>
<b class="nc"><i>861</i>&nbsp;                if (Arrays.equals(reasonsMask, ALL_REASONS))</b>
<b class="nc"><i>862</i>&nbsp;                    break;</b>
<b class="nc"><i>863</i>&nbsp;            }</b>
<b class="nc"><i>864</i>&nbsp;            return results;</b>
<b class="nc"><i>865</i>&nbsp;        } catch (CertificateException | CRLException | IOException e) {</b>
<b class="nc"><i>866</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>867</i>&nbsp;                debug.println(&quot;Exception while verifying CRL: &quot;+e.getMessage());</b>
<b class="nc"><i>868</i>&nbsp;                e.printStackTrace();</b>
<i>869</i>&nbsp;            }
<b class="nc"><i>870</i>&nbsp;            return Collections.emptySet();</b>
<i>871</i>&nbsp;        }
<i>872</i>&nbsp;    }
<i>873</i>&nbsp;
<i>874</i>&nbsp;    /**
<i>875</i>&nbsp;     * We have a cert whose revocation status couldn&#39;t be verified by
<i>876</i>&nbsp;     * a CRL issued by the cert that issued the CRL. See if we can
<i>877</i>&nbsp;     * find a valid CRL issued by a separate key that can verify the
<i>878</i>&nbsp;     * revocation status of this certificate.
<i>879</i>&nbsp;     * &lt;p&gt;
<i>880</i>&nbsp;     * Note that this does not provide support for indirect CRLs,
<i>881</i>&nbsp;     * only CRLs signed with a different key (but the same issuer
<i>882</i>&nbsp;     * name) as the certificate being checked.
<i>883</i>&nbsp;     *
<i>884</i>&nbsp;     * @param currCert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
<i>885</i>&nbsp;     * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; that failed
<i>886</i>&nbsp;     * @param signFlag &lt;code&gt;true&lt;/code&gt; if that key was trusted to sign CRLs
<i>887</i>&nbsp;     * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s&gt;
<i>888</i>&nbsp;     *                     whose revocation status depends on the
<i>889</i>&nbsp;     *                     non-revoked status of this cert. To avoid
<i>890</i>&nbsp;     *                     circular dependencies, we assume they&#39;re
<i>891</i>&nbsp;     *                     revoked while checking the revocation
<i>892</i>&nbsp;     *                     status of this cert.
<i>893</i>&nbsp;     * @throws CertPathValidatorException if the cert&#39;s revocation status
<i>894</i>&nbsp;     *         cannot be verified successfully with another key
<i>895</i>&nbsp;     */
<i>896</i>&nbsp;    private void verifyWithSeparateSigningKey(X509Certificate cert,
<i>897</i>&nbsp;                                              PublicKey prevKey,
<i>898</i>&nbsp;                                              boolean signFlag,
<i>899</i>&nbsp;                                              Set&lt;X509Certificate&gt; stackedCerts)
<i>900</i>&nbsp;        throws CertPathValidatorException
<i>901</i>&nbsp;    {
<b class="nc"><i>902</i>&nbsp;        String msg = &quot;revocation status&quot;;</b>
<b class="nc"><i>903</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>904</i>&nbsp;            debug.println(</b>
<i>905</i>&nbsp;                &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
<i>906</i>&nbsp;                &quot; ---checking &quot; + msg + &quot;...&quot;);
<i>907</i>&nbsp;        }
<i>908</i>&nbsp;
<i>909</i>&nbsp;        // Reject circular dependencies - RFC 5280 is not explicit on how
<i>910</i>&nbsp;        // to handle this, but does suggest that they can be a security
<i>911</i>&nbsp;        // risk and can create unresolvable dependencies
<b class="nc"><i>912</i>&nbsp;        if ((stackedCerts != null) &amp;&amp; stackedCerts.contains(cert)) {</b>
<b class="nc"><i>913</i>&nbsp;            if (debug != null) {</b>
<b class="nc"><i>914</i>&nbsp;                debug.println(</b>
<i>915</i>&nbsp;                    &quot;RevocationChecker.verifyWithSeparateSigningKey()&quot; +
<i>916</i>&nbsp;                    &quot; circular dependency&quot;);
<i>917</i>&nbsp;            }
<b class="nc"><i>918</i>&nbsp;            throw new CertPathValidatorException</b>
<i>919</i>&nbsp;                (&quot;Could not determine revocation status&quot;, null, null, -1,
<i>920</i>&nbsp;                 BasicReason.UNDETERMINED_REVOCATION_STATUS);
<i>921</i>&nbsp;        }
<i>922</i>&nbsp;
<i>923</i>&nbsp;        // Try to find another key that might be able to sign
<i>924</i>&nbsp;        // CRLs vouching for this cert.
<i>925</i>&nbsp;        // If prevKey wasn&#39;t trusted, maybe we just didn&#39;t have the right
<i>926</i>&nbsp;        // path to it. Don&#39;t rule that key out.
<b class="nc"><i>927</i>&nbsp;        if (!signFlag) {</b>
<b class="nc"><i>928</i>&nbsp;            buildToNewKey(cert, null, stackedCerts);</b>
<i>929</i>&nbsp;        } else {
<b class="nc"><i>930</i>&nbsp;            buildToNewKey(cert, prevKey, stackedCerts);</b>
<i>931</i>&nbsp;        }
<i>932</i>&nbsp;    }
<i>933</i>&nbsp;
<i>934</i>&nbsp;    /**
<i>935</i>&nbsp;     * Tries to find a CertPath that establishes a key that can be
<i>936</i>&nbsp;     * used to verify the revocation status of a given certificate.
<i>937</i>&nbsp;     * Ignores keys that have previously been tried. Throws a
<i>938</i>&nbsp;     * CertPathValidatorException if no such key could be found.
<i>939</i>&nbsp;     *
<i>940</i>&nbsp;     * @param currCert the &lt;code&gt;X509Certificate&lt;/code&gt; to be checked
<i>941</i>&nbsp;     * @param prevKey the &lt;code&gt;PublicKey&lt;/code&gt; of the certificate whose key
<i>942</i>&nbsp;     *    cannot be used to vouch for the CRL and should be ignored
<i>943</i>&nbsp;     * @param stackedCerts a &lt;code&gt;Set&lt;/code&gt; of &lt;code&gt;X509Certificate&lt;/code&gt;s&gt;
<i>944</i>&nbsp;     *                     whose revocation status depends on the
<i>945</i>&nbsp;     *                     establishment of this path.
<i>946</i>&nbsp;     * @throws CertPathValidatorException on failure
<i>947</i>&nbsp;     */
<b class="nc"><i>948</i>&nbsp;    private static final boolean [] CRL_SIGN_USAGE =</b>
<i>949</i>&nbsp;        { false, false, false, false, false, false, true };
<i>950</i>&nbsp;    private void buildToNewKey(X509Certificate currCert,
<i>951</i>&nbsp;                               PublicKey prevKey,
<i>952</i>&nbsp;                               Set&lt;X509Certificate&gt; stackedCerts)
<i>953</i>&nbsp;        throws CertPathValidatorException
<i>954</i>&nbsp;    {
<i>955</i>&nbsp;
<b class="nc"><i>956</i>&nbsp;        if (debug != null) {</b>
<b class="nc"><i>957</i>&nbsp;            debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +</b>
<i>958</i>&nbsp;                          &quot; starting work&quot;);
<i>959</i>&nbsp;        }
<b class="nc"><i>960</i>&nbsp;        Set&lt;PublicKey&gt; badKeys = new HashSet&lt;&gt;();</b>
<b class="nc"><i>961</i>&nbsp;        if (prevKey != null) {</b>
<b class="nc"><i>962</i>&nbsp;            badKeys.add(prevKey);</b>
<i>963</i>&nbsp;        }
<b class="nc"><i>964</i>&nbsp;        X509CertSelector certSel = new RejectKeySelector(badKeys);</b>
<b class="nc"><i>965</i>&nbsp;        certSel.setSubject(currCert.getIssuerX500Principal());</b>
<b class="nc"><i>966</i>&nbsp;        certSel.setKeyUsage(CRL_SIGN_USAGE);</b>
<i>967</i>&nbsp;
<b class="nc"><i>968</i>&nbsp;        Set&lt;TrustAnchor&gt; newAnchors = anchor == null ?</b>
<b class="nc"><i>969</i>&nbsp;                                      params.trustAnchors() :</b>
<b class="nc"><i>970</i>&nbsp;                                      Collections.singleton(anchor);</b>
<i>971</i>&nbsp;
<i>972</i>&nbsp;        PKIXBuilderParameters builderParams;
<i>973</i>&nbsp;        try {
<b class="nc"><i>974</i>&nbsp;            builderParams = new PKIXBuilderParameters(newAnchors, certSel);</b>
<b class="nc"><i>975</i>&nbsp;        } catch (InvalidAlgorithmParameterException iape) {</b>
<b class="nc"><i>976</i>&nbsp;            throw new RuntimeException(iape); // should never occur</b>
<b class="nc"><i>977</i>&nbsp;        }</b>
<b class="nc"><i>978</i>&nbsp;        builderParams.setInitialPolicies(params.initialPolicies());</b>
<b class="nc"><i>979</i>&nbsp;        builderParams.setCertStores(certStores);</b>
<b class="nc"><i>980</i>&nbsp;        builderParams.setExplicitPolicyRequired</b>
<b class="nc"><i>981</i>&nbsp;            (params.explicitPolicyRequired());</b>
<b class="nc"><i>982</i>&nbsp;        builderParams.setPolicyMappingInhibited</b>
<b class="nc"><i>983</i>&nbsp;            (params.policyMappingInhibited());</b>
<b class="nc"><i>984</i>&nbsp;        builderParams.setAnyPolicyInhibited(params.anyPolicyInhibited());</b>
<i>985</i>&nbsp;        // Policy qualifiers must be rejected, since we don&#39;t have
<i>986</i>&nbsp;        // any way to convey them back to the application.
<i>987</i>&nbsp;        // That&#39;s the default, so no need to write code.
<b class="nc"><i>988</i>&nbsp;        builderParams.setDate(params.date());</b>
<i>989</i>&nbsp;        builderParams.setCertPathCheckers(params.certPathCheckers());
<b class="nc"><i>990</i>&nbsp;        builderParams.setSigProvider(params.sigProvider());</b>
<b class="nc"><i>991</i>&nbsp;</b>
<b class="nc"><i>992</i>&nbsp;        // Skip revocation during this build to detect circular</b>
<i>993</i>&nbsp;        // references. But check revocation afterwards, using the
<i>994</i>&nbsp;        // key (or any other that works).
<i>995</i>&nbsp;        builderParams.setRevocationEnabled(false);
<i>996</i>&nbsp;
<b class="nc"><i>997</i>&nbsp;        // check for AuthorityInformationAccess extension</b>
<i>998</i>&nbsp;        if (Builder.USE_AIA == true) {
<i>999</i>&nbsp;            X509CertImpl currCertImpl = null;
<b class="nc"><i>1000</i>&nbsp;            try {</b>
<b class="nc"><i>1001</i>&nbsp;                currCertImpl = X509CertImpl.toImpl(currCert);</b>
<i>1002</i>&nbsp;            } catch (CertificateException ce) {
<b class="nc"><i>1003</i>&nbsp;                // ignore but log it</b>
<b class="nc"><i>1004</i>&nbsp;                if (debug != null) {</b>
<i>1005</i>&nbsp;                    debug.println(&quot;RevocationChecker.buildToNewKey: &quot; +
<b class="nc"><i>1006</i>&nbsp;                                  &quot;error decoding cert: &quot; + ce);</b>
<b class="nc"><i>1007</i>&nbsp;                }</b>
<i>1008</i>&nbsp;            }
<i>1009</i>&nbsp;            AuthorityInfoAccessExtension aiaExt = null;
<b class="nc"><i>1010</i>&nbsp;            if (currCertImpl != null) {</b>
<b class="nc"><i>1011</i>&nbsp;                aiaExt = currCertImpl.getAuthorityInfoAccessExtension();</b>
<b class="nc"><i>1012</i>&nbsp;            }</b>
<b class="nc"><i>1013</i>&nbsp;            if (aiaExt != null) {</b>
<i>1014</i>&nbsp;                List&lt;AccessDescription&gt; adList = aiaExt.getAccessDescriptions();
<b class="nc"><i>1015</i>&nbsp;                if (adList != null) {</b>
<b class="nc"><i>1016</i>&nbsp;                    for (AccessDescription ad : adList) {</b>
<b class="nc"><i>1017</i>&nbsp;                        CertStore cs = URICertStore.getInstance(ad);</b>
<b class="nc"><i>1018</i>&nbsp;                        if (cs != null) {</b>
<b class="nc"><i>1019</i>&nbsp;                            if (debug != null) {</b>
<b class="nc"><i>1020</i>&nbsp;                                debug.println(&quot;adding AIAext CertStore&quot;);</b>
<b class="nc"><i>1021</i>&nbsp;                            }</b>
<b class="nc"><i>1022</i>&nbsp;                            builderParams.addCertStore(cs);</b>
<i>1023</i>&nbsp;                        }
<b class="nc"><i>1024</i>&nbsp;                    }</b>
<i>1025</i>&nbsp;                }
<b class="nc"><i>1026</i>&nbsp;            }</b>
<i>1027</i>&nbsp;        }
<i>1028</i>&nbsp;
<i>1029</i>&nbsp;        CertPathBuilder builder = null;
<i>1030</i>&nbsp;        try {
<b class="nc"><i>1031</i>&nbsp;            builder = CertPathBuilder.getInstance(&quot;PKIX&quot;);</b>
<i>1032</i>&nbsp;        } catch (NoSuchAlgorithmException nsae) {
<b class="nc"><i>1033</i>&nbsp;            throw new CertPathValidatorException(nsae);</b>
<b class="nc"><i>1034</i>&nbsp;        }</b>
<b class="nc"><i>1035</i>&nbsp;        while (true) {</b>
<b class="nc"><i>1036</i>&nbsp;            try {</b>
<i>1037</i>&nbsp;                if (debug != null) {
<i>1038</i>&nbsp;                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
<b class="nc"><i>1039</i>&nbsp;                                  &quot; about to try build ...&quot;);</b>
<b class="nc"><i>1040</i>&nbsp;                }</b>
<i>1041</i>&nbsp;                PKIXCertPathBuilderResult cpbr =
<i>1042</i>&nbsp;                    (PKIXCertPathBuilderResult)builder.build(builderParams);
<b class="nc"><i>1043</i>&nbsp;</b>
<b class="nc"><i>1044</i>&nbsp;                if (debug != null) {</b>
<i>1045</i>&nbsp;                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
<b class="nc"><i>1046</i>&nbsp;                                  &quot; about to check revocation ...&quot;);</b>
<b class="nc"><i>1047</i>&nbsp;                }</b>
<i>1048</i>&nbsp;                // Now check revocation of all certs in path, assuming that
<i>1049</i>&nbsp;                // the stackedCerts are revoked.
<i>1050</i>&nbsp;                if (stackedCerts == null) {
<i>1051</i>&nbsp;                    stackedCerts = new HashSet&lt;X509Certificate&gt;();
<b class="nc"><i>1052</i>&nbsp;                }</b>
<b class="nc"><i>1053</i>&nbsp;                stackedCerts.add(currCert);</b>
<i>1054</i>&nbsp;                TrustAnchor ta = cpbr.getTrustAnchor();
<b class="nc"><i>1055</i>&nbsp;                PublicKey prevKey2 = ta.getCAPublicKey();</b>
<b class="nc"><i>1056</i>&nbsp;                if (prevKey2 == null) {</b>
<b class="nc"><i>1057</i>&nbsp;                    prevKey2 = ta.getTrustedCert().getPublicKey();</b>
<b class="nc"><i>1058</i>&nbsp;                }</b>
<b class="nc"><i>1059</i>&nbsp;                boolean signFlag = true;</b>
<i>1060</i>&nbsp;                List&lt;? extends Certificate&gt; cpList =
<b class="nc"><i>1061</i>&nbsp;                    cpbr.getCertPath().getCertificates();</b>
<b class="nc"><i>1062</i>&nbsp;                try {</b>
<b class="nc"><i>1063</i>&nbsp;                    for (int i = cpList.size() - 1; i &gt;= 0; i--) {</b>
<i>1064</i>&nbsp;                        X509Certificate cert = (X509Certificate) cpList.get(i);
<b class="nc"><i>1065</i>&nbsp;</b>
<b class="nc"><i>1066</i>&nbsp;                        if (debug != null) {</b>
<i>1067</i>&nbsp;                            debug.println(&quot;RevocationChecker.buildToNewKey()&quot;
<b class="nc"><i>1068</i>&nbsp;                                    + &quot; index &quot; + i + &quot; checking &quot;</b>
<b class="nc"><i>1069</i>&nbsp;                                    + cert);</b>
<i>1070</i>&nbsp;                        }
<i>1071</i>&nbsp;                        checkCRLs(cert, prevKey2, null, signFlag, true,
<i>1072</i>&nbsp;                                stackedCerts, newAnchors);
<b class="nc"><i>1073</i>&nbsp;                        signFlag = certCanSignCrl(cert);</b>
<i>1074</i>&nbsp;                        prevKey2 = cert.getPublicKey();
<b class="nc"><i>1075</i>&nbsp;                    }</b>
<b class="nc"><i>1076</i>&nbsp;                } catch (CertPathValidatorException cpve) {</b>
<i>1077</i>&nbsp;                    // ignore it and try to get another key
<b class="nc"><i>1078</i>&nbsp;                    badKeys.add(cpbr.getPublicKey());</b>
<i>1079</i>&nbsp;                    continue;
<b class="nc"><i>1080</i>&nbsp;                }</b>
<b class="nc"><i>1081</i>&nbsp;</b>
<b class="nc"><i>1082</i>&nbsp;                if (debug != null) {</b>
<i>1083</i>&nbsp;                    debug.println(&quot;RevocationChecker.buildToNewKey()&quot; +
<b class="nc"><i>1084</i>&nbsp;                                  &quot; got key &quot; + cpbr.getPublicKey());</b>
<b class="nc"><i>1085</i>&nbsp;                }</b>
<b class="nc"><i>1086</i>&nbsp;                // Now check revocation on the current cert using that key and</b>
<i>1087</i>&nbsp;                // the corresponding certificate.
<i>1088</i>&nbsp;                // If it doesn&#39;t check out, try to find a different key.
<i>1089</i>&nbsp;                // And if we can&#39;t find a key, then return false.
<i>1090</i>&nbsp;                PublicKey newKey = cpbr.getPublicKey();
<i>1091</i>&nbsp;                X509Certificate newCert = cpList.isEmpty() ?
<b class="nc"><i>1092</i>&nbsp;                    null : (X509Certificate) cpList.get(0);</b>
<b class="nc"><i>1093</i>&nbsp;                try {</b>
<b class="nc"><i>1094</i>&nbsp;                    checkCRLs(currCert, newKey, newCert,</b>
<i>1095</i>&nbsp;                              true, false, null, params.trustAnchors());
<b class="nc"><i>1096</i>&nbsp;                    // If that passed, the cert is OK!</b>
<b class="nc"><i>1097</i>&nbsp;                    return;</b>
<i>1098</i>&nbsp;                } catch (CertPathValidatorException cpve) {
<i>1099</i>&nbsp;                    // If it is revoked, rethrow exception
<b class="nc"><i>1100</i>&nbsp;                    if (cpve.getReason() == BasicReason.REVOKED) {</b>
<i>1101</i>&nbsp;                        throw cpve;
<b class="nc"><i>1102</i>&nbsp;                    }</b>
<b class="nc"><i>1103</i>&nbsp;                    // Otherwise, ignore the exception and</b>
<i>1104</i>&nbsp;                    // try to get another key.
<i>1105</i>&nbsp;                }
<i>1106</i>&nbsp;                badKeys.add(newKey);
<i>1107</i>&nbsp;            } catch (InvalidAlgorithmParameterException iape) {
<b class="nc"><i>1108</i>&nbsp;                throw new CertPathValidatorException(iape);</b>
<b class="nc"><i>1109</i>&nbsp;            } catch (CertPathBuilderException cpbe) {</b>
<b class="nc"><i>1110</i>&nbsp;                throw new CertPathValidatorException</b>
<b class="nc"><i>1111</i>&nbsp;                    (&quot;Could not determine revocation status&quot;, null, null,</b>
<b class="nc"><i>1112</i>&nbsp;                     -1, BasicReason.UNDETERMINED_REVOCATION_STATUS);</b>
<i>1113</i>&nbsp;            }
<i>1114</i>&nbsp;        }
<b class="nc"><i>1115</i>&nbsp;    }</b>
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;    /*
<i>1118</i>&nbsp;     * This inner class extends the X509CertSelector to add an additional
<i>1119</i>&nbsp;     * check to make sure the subject public key isn&#39;t on a particular list.
<i>1120</i>&nbsp;     * This class is used by buildToNewKey() to make sure the builder doesn&#39;t
<b class="nc"><i>1121</i>&nbsp;     * end up with a CertPath to a public key that has already been rejected.</b>
<i>1122</i>&nbsp;     */
<i>1123</i>&nbsp;    private static class RejectKeySelector extends X509CertSelector {
<b class="nc"><i>1124</i>&nbsp;        private final Set&lt;PublicKey&gt; badKeySet;</b>
<b class="nc"><i>1125</i>&nbsp;</b>
<i>1126</i>&nbsp;        /**
<i>1127</i>&nbsp;         * Creates a new &lt;code&gt;RejectKeySelector&lt;/code&gt;.
<i>1128</i>&nbsp;         *
<i>1129</i>&nbsp;         * @param badPublicKeys a &lt;code&gt;Set&lt;/code&gt; of
<i>1130</i>&nbsp;         *                      &lt;code&gt;PublicKey&lt;/code&gt;s that
<i>1131</i>&nbsp;         *                      should be rejected (or &lt;code&gt;null&lt;/code&gt;
<i>1132</i>&nbsp;         *                      if no such check should be done)
<i>1133</i>&nbsp;         */
<i>1134</i>&nbsp;        RejectKeySelector(Set&lt;PublicKey&gt; badPublicKeys) {
<i>1135</i>&nbsp;            this.badKeySet = badPublicKeys;
<i>1136</i>&nbsp;        }
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;        /**
<i>1139</i>&nbsp;         * Decides whether a &lt;code&gt;Certificate&lt;/code&gt; should be selected.
<i>1140</i>&nbsp;         *
<i>1141</i>&nbsp;         * @param cert the &lt;code&gt;Certificate&lt;/code&gt; to be checked
<i>1142</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Certificate&lt;/code&gt; should be
<i>1143</i>&nbsp;         *         selected, &lt;code&gt;false&lt;/code&gt; otherwise
<i>1144</i>&nbsp;         */
<b class="nc"><i>1145</i>&nbsp;        @Override</b>
<b class="nc"><i>1146</i>&nbsp;        public boolean match(Certificate cert) {</b>
<i>1147</i>&nbsp;            if (!super.match(cert))
<i>1148</i>&nbsp;                return(false);
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;            if (badKeySet.contains(cert.getPublicKey())) {
<i>1151</i>&nbsp;                if (debug != null)
<i>1152</i>&nbsp;                    debug.println(&quot;RejectKeySelector.match: bad key&quot;);
<i>1153</i>&nbsp;                return false;
<i>1154</i>&nbsp;            }
<i>1155</i>&nbsp;
<i>1156</i>&nbsp;            if (debug != null)
<i>1157</i>&nbsp;                debug.println(&quot;RejectKeySelector.match: returning true&quot;);
<b class="nc"><i>1158</i>&nbsp;            return true;</b>
<b class="nc"><i>1159</i>&nbsp;        }</b>
<i>1160</i>&nbsp;
<b class="nc"><i>1161</i>&nbsp;        /**</b>
<b class="nc"><i>1162</i>&nbsp;         * Return a printable representation of the &lt;code&gt;CertSelector&lt;/code&gt;.</b>
<b class="nc"><i>1163</i>&nbsp;         *</b>
<b class="nc"><i>1164</i>&nbsp;         * @return a &lt;code&gt;String&lt;/code&gt; describing the contents of the</b>
<i>1165</i>&nbsp;         *         &lt;code&gt;CertSelector&lt;/code&gt;
<i>1166</i>&nbsp;         */
<b class="nc"><i>1167</i>&nbsp;        @Override</b>
<b class="nc"><i>1168</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>1169</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<i>1170</i>&nbsp;            sb.append(&quot;RejectKeySelector: [\n&quot;);
<i>1171</i>&nbsp;            sb.append(super.toString());
<i>1172</i>&nbsp;            sb.append(badKeySet);
<i>1173</i>&nbsp;            sb.append(&quot;]&quot;);
<i>1174</i>&nbsp;            return sb.toString();
<i>1175</i>&nbsp;        }
<i>1176</i>&nbsp;    }
<i>1177</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
