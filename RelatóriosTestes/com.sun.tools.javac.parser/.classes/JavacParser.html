


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: JavacParser</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.parser</a> ]
</div>

<h1>Coverage Summary for Class: JavacParser (com.sun.tools.javac.parser)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JavacParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 168)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1968)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JavacParser$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$AbstractEndPosTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$BasicErrorRecoveryAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$BasicErrorRecoveryAction$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$BasicErrorRecoveryAction$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$EmptyEndPosTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$ParensResult</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavacParser$SimpleEndPosTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 189)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2008)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.parser;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.*;
<i>29</i>&nbsp;import java.util.stream.Collectors;
<i>30</i>&nbsp;
<i>31</i>&nbsp;import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
<i>32</i>&nbsp;import com.sun.source.tree.ModuleTree.ModuleKind;
<i>33</i>&nbsp;
<i>34</i>&nbsp;import com.sun.tools.javac.code.*;
<i>35</i>&nbsp;import com.sun.tools.javac.code.Source.Feature;
<i>36</i>&nbsp;import com.sun.tools.javac.parser.Tokens.*;
<i>37</i>&nbsp;import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
<i>38</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Errors;
<i>39</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<i>40</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Warnings;
<i>41</i>&nbsp;import com.sun.tools.javac.tree.*;
<i>42</i>&nbsp;import com.sun.tools.javac.tree.JCTree.*;
<i>43</i>&nbsp;import com.sun.tools.javac.util.*;
<i>44</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
<i>45</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.Error;
<i>46</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.Fragment;
<i>47</i>&nbsp;import com.sun.tools.javac.util.List;
<i>48</i>&nbsp;
<i>49</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
<i>50</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
<i>51</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
<i>52</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
<i>53</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
<i>54</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
<i>55</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
<i>56</i>&nbsp;import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
<i>57</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.Tag.*;
<i>58</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
<i>59</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
<i>60</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
<i>61</i>&nbsp;
<i>62</i>&nbsp;/** The parser maps a token sequence into an abstract syntax
<b class="nc"><i>63</i>&nbsp; *  tree. It operates by recursive descent, with code derived</b>
<i>64</i>&nbsp; *  systematically from an LL(1) grammar. For efficiency reasons, an
<i>65</i>&nbsp; *  operator precedence scheme is used for parsing binary operation
<i>66</i>&nbsp; *  expressions.
<i>67</i>&nbsp; *
<i>68</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>69</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>70</i>&nbsp; *  This code and its internal interfaces are subject to change or
<i>71</i>&nbsp; *  deletion without notice.&lt;/b&gt;
<i>72</i>&nbsp; */
<i>73</i>&nbsp;public class JavacParser implements Parser {
<i>74</i>&nbsp;
<i>75</i>&nbsp;    /** The number of precedence levels of infix operators.
<i>76</i>&nbsp;     */
<i>77</i>&nbsp;    private static final int infixPrecedenceLevels = 10;
<i>78</i>&nbsp;
<i>79</i>&nbsp;    /** Is the parser instantiated to parse a module-info file ?
<i>80</i>&nbsp;     */
<i>81</i>&nbsp;    private final boolean parseModuleInfo;
<i>82</i>&nbsp;
<i>83</i>&nbsp;    /** The scanner used for lexical analysis.
<i>84</i>&nbsp;     */
<i>85</i>&nbsp;    protected Lexer S;
<i>86</i>&nbsp;
<i>87</i>&nbsp;    /** The factory to be used for abstract syntax tree construction.
<i>88</i>&nbsp;     */
<i>89</i>&nbsp;    protected TreeMaker F;
<i>90</i>&nbsp;
<i>91</i>&nbsp;    /** The log to be used for error diagnostics.
<i>92</i>&nbsp;     */
<i>93</i>&nbsp;    private Log log;
<i>94</i>&nbsp;
<i>95</i>&nbsp;    /** The Source language setting. */
<i>96</i>&nbsp;    private Source source;
<i>97</i>&nbsp;
<i>98</i>&nbsp;    /** The Preview language setting. */
<i>99</i>&nbsp;    private Preview preview;
<i>100</i>&nbsp;
<i>101</i>&nbsp;    /** The name table. */
<i>102</i>&nbsp;    private Names names;
<i>103</i>&nbsp;
<i>104</i>&nbsp;    /** End position mappings container */
<i>105</i>&nbsp;    protected final AbstractEndPosTable endPosTable;
<i>106</i>&nbsp;
<i>107</i>&nbsp;    // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
<i>108</i>&nbsp;    // the presence of type annotations even though they are not ambiguous
<i>109</i>&nbsp;    // in the absence of type annotations.  Consider this code:
<i>110</i>&nbsp;    //   void m(String [] m) { }
<i>111</i>&nbsp;    //   void m(String ... m) { }
<i>112</i>&nbsp;    // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
<i>113</i>&nbsp;    // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
<i>114</i>&nbsp;    // if the next token is ... and in that case parse an ellipsis.  But in
<b class="nc"><i>115</i>&nbsp;    // the presence of type annotations:</b>
<i>116</i>&nbsp;    //   void m(String @A [] m) { }
<i>117</i>&nbsp;    //   void m(String @A ... m) { }
<i>118</i>&nbsp;    // no finite lookahead is enough to determine whether to read array
<i>119</i>&nbsp;    // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
<i>120</i>&nbsp;    // bracketsOpt first reads all the leading annotations and only then
<i>121</i>&nbsp;    // discovers that it needs to fail.  bracketsOpt needs a way to push
<i>122</i>&nbsp;    // back the extra annotations that it read.  (But, bracketsOpt should
<b class="nc"><i>123</i>&nbsp;    // not *always* be allowed to push back extra annotations that it finds</b>
<i>124</i>&nbsp;    // -- in most contexts, any such extra annotation is an error.
<i>125</i>&nbsp;    //
<i>126</i>&nbsp;    // The following two variables permit type annotations that have
<i>127</i>&nbsp;    // already been read to be stored for later use.  Alternate
<i>128</i>&nbsp;    // implementations are possible but would cause much larger changes to
<b class="nc"><i>129</i>&nbsp;    // the parser.</b>
<b class="nc"><i>130</i>&nbsp;</b>
<b class="nc"><i>131</i>&nbsp;    /** Type annotations that have already been read but have not yet been used. **/</b>
<i>132</i>&nbsp;    private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
<i>133</i>&nbsp;
<i>134</i>&nbsp;    /**
<i>135</i>&nbsp;     * If the parser notices extra annotations, then it either immediately
<i>136</i>&nbsp;     * issues an error (if this variable is false) or places the extra
<i>137</i>&nbsp;     * annotations in variable typeAnnotationsPushedBack (if this variable
<i>138</i>&nbsp;     * is true).
<i>139</i>&nbsp;     */
<b class="nc"><i>140</i>&nbsp;    private boolean permitTypeAnnotationsPushBack = false;</b>
<b class="nc"><i>141</i>&nbsp;</b>
<b class="nc"><i>142</i>&nbsp;    interface ErrorRecoveryAction {</b>
<b class="nc"><i>143</i>&nbsp;        JCTree doRecover(JavacParser parser);</b>
<b class="nc"><i>144</i>&nbsp;    }</b>
<b class="nc"><i>145</i>&nbsp;</b>
<b class="nc"><i>146</i>&nbsp;    enum BasicErrorRecoveryAction implements ErrorRecoveryAction {</b>
<b class="nc"><i>147</i>&nbsp;        BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},</b>
<b class="nc"><i>148</i>&nbsp;        CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}</b>
<b class="nc"><i>149</i>&nbsp;    }</b>
<b class="nc"><i>150</i>&nbsp;</b>
<b class="nc"><i>151</i>&nbsp;    /** Construct a parser from a given scanner, tree factory and log.</b>
<b class="nc"><i>152</i>&nbsp;     */</b>
<b class="nc"><i>153</i>&nbsp;    protected JavacParser(ParserFactory fac,</b>
<b class="nc"><i>154</i>&nbsp;                          Lexer S,</b>
<b class="nc"><i>155</i>&nbsp;                          boolean keepDocComments,</b>
<b class="nc"><i>156</i>&nbsp;                          boolean keepLineMap,</b>
<b class="nc"><i>157</i>&nbsp;                          boolean keepEndPositions) {</b>
<b class="nc"><i>158</i>&nbsp;        this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);</b>
<b class="nc"><i>159</i>&nbsp;</b>
<b class="nc"><i>160</i>&nbsp;    }</b>
<b class="nc"><i>161</i>&nbsp;    /** Construct a parser from a given scanner, tree factory and log.</b>
<b class="nc"><i>162</i>&nbsp;     */</b>
<b class="nc"><i>163</i>&nbsp;    protected JavacParser(ParserFactory fac,</b>
<b class="nc"><i>164</i>&nbsp;                     Lexer S,</b>
<b class="nc"><i>165</i>&nbsp;                     boolean keepDocComments,</b>
<b class="nc"><i>166</i>&nbsp;                     boolean keepLineMap,</b>
<b class="nc"><i>167</i>&nbsp;                     boolean keepEndPositions,</b>
<b class="nc"><i>168</i>&nbsp;                     boolean parseModuleInfo) {</b>
<b class="nc"><i>169</i>&nbsp;        this.S = S;</b>
<i>170</i>&nbsp;        nextToken(); // prime the pump
<i>171</i>&nbsp;        this.F = fac.F;
<i>172</i>&nbsp;        this.log = fac.log;
<b class="nc"><i>173</i>&nbsp;        this.names = fac.names;</b>
<i>174</i>&nbsp;        this.source = fac.source;
<i>175</i>&nbsp;        this.preview = fac.preview;
<i>176</i>&nbsp;        this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
<i>177</i>&nbsp;        this.keepDocComments = keepDocComments;
<i>178</i>&nbsp;        this.parseModuleInfo = parseModuleInfo;
<b class="nc"><i>179</i>&nbsp;        docComments = newDocCommentTable(keepDocComments, fac);</b>
<i>180</i>&nbsp;        this.keepLineMap = keepLineMap;
<i>181</i>&nbsp;        this.errorTree = F.Erroneous();
<i>182</i>&nbsp;        endPosTable = newEndPosTable(keepEndPositions);
<i>183</i>&nbsp;    }
<i>184</i>&nbsp;
<i>185</i>&nbsp;    protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
<i>186</i>&nbsp;        return  keepEndPositions
<i>187</i>&nbsp;                ? new SimpleEndPosTable(this)
<i>188</i>&nbsp;                : new EmptyEndPosTable(this);
<i>189</i>&nbsp;    }
<i>190</i>&nbsp;
<i>191</i>&nbsp;    protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
<i>192</i>&nbsp;        return keepDocComments ? new LazyDocCommentTable(fac) : null;
<i>193</i>&nbsp;    }
<i>194</i>&nbsp;
<i>195</i>&nbsp;    /** Switch: should we fold strings?
<i>196</i>&nbsp;     */
<i>197</i>&nbsp;    boolean allowStringFolding;
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /** Switch: should we keep docComments?
<i>200</i>&nbsp;     */
<i>201</i>&nbsp;    boolean keepDocComments;
<i>202</i>&nbsp;
<i>203</i>&nbsp;    /** Switch: should we keep line table?
<i>204</i>&nbsp;     */
<i>205</i>&nbsp;    boolean keepLineMap;
<i>206</i>&nbsp;
<i>207</i>&nbsp;    /** Switch: is &quot;this&quot; allowed as an identifier?
<i>208</i>&nbsp;     * This is needed to parse receiver types.
<i>209</i>&nbsp;     */
<i>210</i>&nbsp;    boolean allowThisIdent;
<i>211</i>&nbsp;
<i>212</i>&nbsp;    /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
<i>213</i>&nbsp;     */
<i>214</i>&nbsp;    JCVariableDecl receiverParam;
<i>215</i>&nbsp;
<i>216</i>&nbsp;    /** When terms are parsed, the mode determines which is expected:
<i>217</i>&nbsp;     *     mode = EXPR        : an expression
<i>218</i>&nbsp;     *     mode = TYPE        : a type
<i>219</i>&nbsp;     *     mode = NOPARAMS    : no parameters allowed for type
<i>220</i>&nbsp;     *     mode = TYPEARG     : type argument
<i>221</i>&nbsp;     */
<i>222</i>&nbsp;    protected static final int EXPR = 0x1;
<i>223</i>&nbsp;    protected static final int TYPE = 0x2;
<i>224</i>&nbsp;    protected static final int NOPARAMS = 0x4;
<i>225</i>&nbsp;    protected static final int TYPEARG = 0x8;
<i>226</i>&nbsp;    protected static final int DIAMOND = 0x10;
<i>227</i>&nbsp;
<i>228</i>&nbsp;    /** The current mode.
<i>229</i>&nbsp;     */
<i>230</i>&nbsp;    protected int mode = 0;
<i>231</i>&nbsp;
<i>232</i>&nbsp;    /** The mode of the term that was parsed last.
<i>233</i>&nbsp;     */
<i>234</i>&nbsp;    protected int lastmode = 0;
<i>235</i>&nbsp;
<i>236</i>&nbsp;    /* ---------- token management -------------- */
<i>237</i>&nbsp;
<i>238</i>&nbsp;    protected Token token;
<i>239</i>&nbsp;
<i>240</i>&nbsp;    public Token token() {
<i>241</i>&nbsp;        return token;
<i>242</i>&nbsp;    }
<i>243</i>&nbsp;
<i>244</i>&nbsp;    public void nextToken() {
<i>245</i>&nbsp;        S.nextToken();
<i>246</i>&nbsp;        token = S.token();
<i>247</i>&nbsp;    }
<i>248</i>&nbsp;
<i>249</i>&nbsp;    protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
<i>250</i>&nbsp;        return peekToken(0, tk);
<i>251</i>&nbsp;    }
<i>252</i>&nbsp;
<i>253</i>&nbsp;    protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
<i>254</i>&nbsp;        return tk.accepts(S.token(lookahead + 1).kind);
<i>255</i>&nbsp;    }
<i>256</i>&nbsp;
<i>257</i>&nbsp;    protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
<i>258</i>&nbsp;        return peekToken(0, tk1, tk2);
<i>259</i>&nbsp;    }
<i>260</i>&nbsp;
<i>261</i>&nbsp;    protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
<i>262</i>&nbsp;        return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
<i>263</i>&nbsp;                tk2.accepts(S.token(lookahead + 2).kind);
<i>264</i>&nbsp;    }
<i>265</i>&nbsp;
<i>266</i>&nbsp;    protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
<i>267</i>&nbsp;        return peekToken(0, tk1, tk2, tk3);
<i>268</i>&nbsp;    }
<i>269</i>&nbsp;
<i>270</i>&nbsp;    protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
<i>271</i>&nbsp;        return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
<i>272</i>&nbsp;                tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
<i>273</i>&nbsp;                tk3.accepts(S.token(lookahead + 3).kind);
<i>274</i>&nbsp;    }
<i>275</i>&nbsp;
<i>276</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>277</i>&nbsp;    protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
<i>278</i>&nbsp;        return peekToken(0, kinds);
<i>279</i>&nbsp;    }
<i>280</i>&nbsp;
<i>281</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>282</i>&nbsp;    protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
<i>283</i>&nbsp;        for (; lookahead &lt; kinds.length ; lookahead++) {
<i>284</i>&nbsp;            if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
<i>285</i>&nbsp;                return false;
<b class="nc"><i>286</i>&nbsp;            }</b>
<i>287</i>&nbsp;        }
<i>288</i>&nbsp;        return true;
<i>289</i>&nbsp;    }
<b class="nc"><i>290</i>&nbsp;</b>
<i>291</i>&nbsp;    /* ---------- error recovery -------------- */
<i>292</i>&nbsp;
<i>293</i>&nbsp;    private JCErroneous errorTree;
<i>294</i>&nbsp;
<i>295</i>&nbsp;    /** Skip forward until a suitable stop token is found.
<i>296</i>&nbsp;     */
<b class="nc"><i>297</i>&nbsp;    protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {</b>
<i>298</i>&nbsp;         while (true) {
<i>299</i>&nbsp;             switch (token.kind) {
<i>300</i>&nbsp;                case SEMI:
<b class="nc"><i>301</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>302</i>&nbsp;                    return;</b>
<i>303</i>&nbsp;                case PUBLIC:
<i>304</i>&nbsp;                case FINAL:
<i>305</i>&nbsp;                case ABSTRACT:
<b class="nc"><i>306</i>&nbsp;                case MONKEYS_AT:</b>
<i>307</i>&nbsp;                case EOF:
<i>308</i>&nbsp;                case CLASS:
<i>309</i>&nbsp;                case INTERFACE:
<b class="nc"><i>310</i>&nbsp;                case ENUM:</b>
<i>311</i>&nbsp;                    return;
<i>312</i>&nbsp;                case IMPORT:
<i>313</i>&nbsp;                    if (stopAtImport)
<b class="nc"><i>314</i>&nbsp;                        return;</b>
<i>315</i>&nbsp;                    break;
<i>316</i>&nbsp;                case LBRACE:
<i>317</i>&nbsp;                case RBRACE:
<b class="nc"><i>318</i>&nbsp;                case PRIVATE:</b>
<b class="nc"><i>319</i>&nbsp;                case PROTECTED:</b>
<i>320</i>&nbsp;                case STATIC:
<i>321</i>&nbsp;                case TRANSIENT:
<i>322</i>&nbsp;                case NATIVE:
<b class="nc"><i>323</i>&nbsp;                case VOLATILE:</b>
<i>324</i>&nbsp;                case SYNCHRONIZED:
<i>325</i>&nbsp;                case STRICTFP:
<i>326</i>&nbsp;                case LT:
<b class="nc"><i>327</i>&nbsp;                case BYTE:</b>
<b class="nc"><i>328</i>&nbsp;                case SHORT:</b>
<b class="nc"><i>329</i>&nbsp;                case CHAR:</b>
<i>330</i>&nbsp;                case INT:
<i>331</i>&nbsp;                case LONG:
<i>332</i>&nbsp;                case FLOAT:
<i>333</i>&nbsp;                case DOUBLE:
<b class="nc"><i>334</i>&nbsp;                case BOOLEAN:</b>
<i>335</i>&nbsp;                case VOID:
<i>336</i>&nbsp;                    if (stopAtMemberDecl)
<i>337</i>&nbsp;                        return;
<i>338</i>&nbsp;                    break;
<b class="nc"><i>339</i>&nbsp;                case UNDERSCORE:</b>
<b class="nc"><i>340</i>&nbsp;                case IDENTIFIER:</b>
<b class="nc"><i>341</i>&nbsp;                   if (stopAtIdentifier)</b>
<i>342</i>&nbsp;                        return;
<i>343</i>&nbsp;                    break;
<b class="nc"><i>344</i>&nbsp;                case CASE:</b>
<i>345</i>&nbsp;                case DEFAULT:
<i>346</i>&nbsp;                case IF:
<i>347</i>&nbsp;                case FOR:
<i>348</i>&nbsp;                case WHILE:
<i>349</i>&nbsp;                case DO:
<i>350</i>&nbsp;                case TRY:
<i>351</i>&nbsp;                case SWITCH:
<i>352</i>&nbsp;                case RETURN:
<i>353</i>&nbsp;                case THROW:
<i>354</i>&nbsp;                case BREAK:
<b class="nc"><i>355</i>&nbsp;                case CONTINUE:</b>
<i>356</i>&nbsp;                case ELSE:
<b class="nc"><i>357</i>&nbsp;                case FINALLY:</b>
<i>358</i>&nbsp;                case CATCH:
<i>359</i>&nbsp;                case THIS:
<i>360</i>&nbsp;                case SUPER:
<i>361</i>&nbsp;                case NEW:
<i>362</i>&nbsp;                    if (stopAtStatement)
<i>363</i>&nbsp;                        return;
<i>364</i>&nbsp;                    break;
<i>365</i>&nbsp;                case ASSERT:
<i>366</i>&nbsp;                    if (stopAtStatement)
<i>367</i>&nbsp;                        return;
<i>368</i>&nbsp;                    break;
<b class="nc"><i>369</i>&nbsp;            }</b>
<i>370</i>&nbsp;            nextToken();
<i>371</i>&nbsp;        }
<i>372</i>&nbsp;    }
<i>373</i>&nbsp;
<i>374</i>&nbsp;    protected JCErroneous syntaxError(int pos, Error errorKey) {
<i>375</i>&nbsp;        return syntaxError(pos, List.nil(), errorKey);
<i>376</i>&nbsp;    }
<i>377</i>&nbsp;
<i>378</i>&nbsp;    protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
<i>379</i>&nbsp;        setErrorEndPos(pos);
<i>380</i>&nbsp;        JCErroneous err = F.at(pos).Erroneous(errs);
<i>381</i>&nbsp;        reportSyntaxError(err, errorKey);
<i>382</i>&nbsp;        if (errs != null) {
<i>383</i>&nbsp;            JCTree last = errs.last();
<i>384</i>&nbsp;            if (last != null)
<i>385</i>&nbsp;                storeEnd(last, pos);
<i>386</i>&nbsp;        }
<i>387</i>&nbsp;        return toP(err);
<i>388</i>&nbsp;    }
<i>389</i>&nbsp;
<i>390</i>&nbsp;    private static final int RECOVERY_THRESHOLD = 50;
<i>391</i>&nbsp;    private int errorPos = Position.NOPOS;
<b class="nc"><i>392</i>&nbsp;    private int count = 0;</b>
<i>393</i>&nbsp;
<i>394</i>&nbsp;    /**
<i>395</i>&nbsp;     * Report a syntax using the given the position parameter and arguments,
<i>396</i>&nbsp;     * unless one was already reported at the same position.
<b class="nc"><i>397</i>&nbsp;     */</b>
<i>398</i>&nbsp;    protected void reportSyntaxError(int pos, Error errorKey) {
<i>399</i>&nbsp;        JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
<i>400</i>&nbsp;        reportSyntaxError(diag, errorKey);
<i>401</i>&nbsp;    }
<i>402</i>&nbsp;
<i>403</i>&nbsp;    /**
<i>404</i>&nbsp;     * Report a syntax error using the given DiagnosticPosition object and
<i>405</i>&nbsp;     * arguments, unless one was already reported at the same position.
<i>406</i>&nbsp;     */
<i>407</i>&nbsp;    protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
<i>408</i>&nbsp;        int pos = diagPos.getPreferredPosition();
<i>409</i>&nbsp;        if (pos &gt; S.errPos() || pos == Position.NOPOS) {
<i>410</i>&nbsp;            if (token.kind == EOF) {
<i>411</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
<i>412</i>&nbsp;            } else {
<i>413</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
<i>414</i>&nbsp;            }
<b class="nc"><i>415</i>&nbsp;        }</b>
<i>416</i>&nbsp;        S.errPos(pos);
<i>417</i>&nbsp;        if (token.pos == errorPos) {
<i>418</i>&nbsp;            //check for a possible infinite loop in parsing:
<b class="nc"><i>419</i>&nbsp;            Assert.check(count++ &lt; RECOVERY_THRESHOLD);</b>
<i>420</i>&nbsp;        } else {
<i>421</i>&nbsp;            count = 0;
<i>422</i>&nbsp;            errorPos = token.pos;
<i>423</i>&nbsp;        }
<b class="nc"><i>424</i>&nbsp;    }</b>
<i>425</i>&nbsp;
<i>426</i>&nbsp;    /** If next input token matches given token, skip it, otherwise report
<i>427</i>&nbsp;     *  an error.
<b class="nc"><i>428</i>&nbsp;     */</b>
<b class="nc"><i>429</i>&nbsp;    public void accept(TokenKind tk) {</b>
<b class="nc"><i>430</i>&nbsp;        if (token.kind == tk) {</b>
<b class="nc"><i>431</i>&nbsp;            nextToken();</b>
<b class="nc"><i>432</i>&nbsp;        } else {</b>
<b class="nc"><i>433</i>&nbsp;            setErrorEndPos(token.pos);</b>
<b class="nc"><i>434</i>&nbsp;            reportSyntaxError(S.prevToken().endPos, Errors.Expected(tk));</b>
<i>435</i>&nbsp;        }
<b class="nc"><i>436</i>&nbsp;    }</b>
<i>437</i>&nbsp;
<i>438</i>&nbsp;    /** Report an illegal start of expression/type error at given position.
<b class="nc"><i>439</i>&nbsp;     */</b>
<i>440</i>&nbsp;    JCExpression illegal(int pos) {
<i>441</i>&nbsp;        setErrorEndPos(pos);
<i>442</i>&nbsp;        if ((mode &amp; EXPR) != 0)
<i>443</i>&nbsp;            return syntaxError(pos, Errors.IllegalStartOfExpr);
<i>444</i>&nbsp;        else
<i>445</i>&nbsp;            return syntaxError(pos, Errors.IllegalStartOfType);
<b class="nc"><i>446</i>&nbsp;</b>
<b class="nc"><i>447</i>&nbsp;    }</b>
<i>448</i>&nbsp;
<i>449</i>&nbsp;    /** Report an illegal start of expression/type error at current position.
<i>450</i>&nbsp;     */
<i>451</i>&nbsp;    JCExpression illegal() {
<i>452</i>&nbsp;        return illegal(token.pos);
<i>453</i>&nbsp;    }
<i>454</i>&nbsp;
<b class="nc"><i>455</i>&nbsp;    /** Diagnose a modifier flag from the set, if any. */</b>
<b class="nc"><i>456</i>&nbsp;    protected void checkNoMods(long mods) {</b>
<b class="nc"><i>457</i>&nbsp;        if (mods != 0) {</b>
<b class="nc"><i>458</i>&nbsp;            long lowestMod = mods &amp; -mods;</b>
<i>459</i>&nbsp;            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
<b class="nc"><i>460</i>&nbsp;        }</b>
<i>461</i>&nbsp;    }
<i>462</i>&nbsp;
<b class="nc"><i>463</i>&nbsp;/* ---------- doc comments --------- */</b>
<b class="nc"><i>464</i>&nbsp;</b>
<b class="nc"><i>465</i>&nbsp;    /** A table to store all documentation comments</b>
<b class="nc"><i>466</i>&nbsp;     *  indexed by the tree nodes they refer to.</b>
<i>467</i>&nbsp;     *  defined only if option flag keepDocComment is set.
<i>468</i>&nbsp;     */
<i>469</i>&nbsp;    private final DocCommentTable docComments;
<i>470</i>&nbsp;
<i>471</i>&nbsp;    /** Make an entry into docComments hashtable,
<i>472</i>&nbsp;     *  provided flag keepDocComments is set and given doc comment is non-null.
<i>473</i>&nbsp;     *  @param tree   The tree to be used as index in the hashtable
<b class="nc"><i>474</i>&nbsp;     *  @param dc     The doc comment to associate with the tree, or null.</b>
<i>475</i>&nbsp;     */
<i>476</i>&nbsp;    protected void attach(JCTree tree, Comment dc) {
<i>477</i>&nbsp;        if (keepDocComments &amp;&amp; dc != null) {
<i>478</i>&nbsp;//          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
<i>479</i>&nbsp;            docComments.putComment(tree, dc);
<i>480</i>&nbsp;        }
<b class="nc"><i>481</i>&nbsp;    }</b>
<i>482</i>&nbsp;
<i>483</i>&nbsp;/* -------- source positions ------- */
<i>484</i>&nbsp;
<i>485</i>&nbsp;    protected void setErrorEndPos(int errPos) {
<i>486</i>&nbsp;        endPosTable.setErrorEndPos(errPos);
<i>487</i>&nbsp;    }
<b class="nc"><i>488</i>&nbsp;</b>
<b class="nc"><i>489</i>&nbsp;    protected void storeEnd(JCTree tree, int endpos) {</b>
<i>490</i>&nbsp;        endPosTable.storeEnd(tree, endpos);
<b class="nc"><i>491</i>&nbsp;    }</b>
<b class="nc"><i>492</i>&nbsp;</b>
<i>493</i>&nbsp;    protected &lt;T extends JCTree&gt; T to(T t) {
<i>494</i>&nbsp;        return endPosTable.to(t);
<i>495</i>&nbsp;    }
<i>496</i>&nbsp;
<i>497</i>&nbsp;    protected &lt;T extends JCTree&gt; T toP(T t) {
<i>498</i>&nbsp;        return endPosTable.toP(t);
<b class="nc"><i>499</i>&nbsp;    }</b>
<b class="nc"><i>500</i>&nbsp;</b>
<b class="nc"><i>501</i>&nbsp;    /** Get the start position for a tree node.  The start position is</b>
<i>502</i>&nbsp;     * defined to be the position of the first character of the first
<b class="nc"><i>503</i>&nbsp;     * token of the node&#39;s source text.</b>
<i>504</i>&nbsp;     * @param tree  The tree node
<i>505</i>&nbsp;     */
<i>506</i>&nbsp;    public int getStartPos(JCTree tree) {
<i>507</i>&nbsp;        return TreeInfo.getStartPos(tree);
<i>508</i>&nbsp;    }
<i>509</i>&nbsp;
<b class="nc"><i>510</i>&nbsp;    /**</b>
<i>511</i>&nbsp;     * Get the end position for a tree node.  The end position is
<i>512</i>&nbsp;     * defined to be the position of the last character of the last
<i>513</i>&nbsp;     * token of the node&#39;s source text.  Returns Position.NOPOS if end
<i>514</i>&nbsp;     * positions are not generated or the position is otherwise not
<b class="nc"><i>515</i>&nbsp;     * found.</b>
<b class="nc"><i>516</i>&nbsp;     * @param tree  The tree node</b>
<b class="nc"><i>517</i>&nbsp;     */</b>
<b class="nc"><i>518</i>&nbsp;    public int getEndPos(JCTree tree) {</b>
<i>519</i>&nbsp;        return endPosTable.getEndPos(tree);
<i>520</i>&nbsp;    }
<i>521</i>&nbsp;
<i>522</i>&nbsp;
<i>523</i>&nbsp;
<i>524</i>&nbsp;/* ---------- parsing -------------- */
<i>525</i>&nbsp;
<i>526</i>&nbsp;    /**
<i>527</i>&nbsp;     * Ident = IDENTIFIER
<i>528</i>&nbsp;     */
<i>529</i>&nbsp;    public Name ident() {
<i>530</i>&nbsp;        return ident(false);
<i>531</i>&nbsp;    }
<i>532</i>&nbsp;
<i>533</i>&nbsp;    protected Name ident(boolean advanceOnErrors) {
<i>534</i>&nbsp;        if (token.kind == IDENTIFIER) {
<i>535</i>&nbsp;            Name name = token.name();
<b class="nc"><i>536</i>&nbsp;            nextToken();</b>
<i>537</i>&nbsp;            return name;
<b class="nc"><i>538</i>&nbsp;        } else if (token.kind == ASSERT) {</b>
<i>539</i>&nbsp;            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
<i>540</i>&nbsp;            nextToken();
<i>541</i>&nbsp;            return names.error;
<i>542</i>&nbsp;        } else if (token.kind == ENUM) {
<i>543</i>&nbsp;            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
<i>544</i>&nbsp;            nextToken();
<b class="nc"><i>545</i>&nbsp;            return names.error;</b>
<i>546</i>&nbsp;        } else if (token.kind == THIS) {
<i>547</i>&nbsp;            if (allowThisIdent) {
<i>548</i>&nbsp;                // Make sure we&#39;re using a supported source version.
<b class="nc"><i>549</i>&nbsp;                checkSourceLevel(Feature.TYPE_ANNOTATIONS);</b>
<i>550</i>&nbsp;                Name name = token.name();
<i>551</i>&nbsp;                nextToken();
<i>552</i>&nbsp;                return name;
<b class="nc"><i>553</i>&nbsp;            } else {</b>
<i>554</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
<i>555</i>&nbsp;                nextToken();
<i>556</i>&nbsp;                return names.error;
<b class="nc"><i>557</i>&nbsp;            }</b>
<i>558</i>&nbsp;        } else if (token.kind == UNDERSCORE) {
<i>559</i>&nbsp;            if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
<i>560</i>&nbsp;                log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
<i>561</i>&nbsp;            } else {
<i>562</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
<i>563</i>&nbsp;            }
<i>564</i>&nbsp;            Name name = token.name();
<i>565</i>&nbsp;            nextToken();
<b class="nc"><i>566</i>&nbsp;            return name;</b>
<i>567</i>&nbsp;        } else {
<i>568</i>&nbsp;            accept(IDENTIFIER);
<i>569</i>&nbsp;            if (advanceOnErrors) {
<i>570</i>&nbsp;                nextToken();
<i>571</i>&nbsp;            }
<i>572</i>&nbsp;            return names.error;
<i>573</i>&nbsp;        }
<i>574</i>&nbsp;    }
<i>575</i>&nbsp;
<i>576</i>&nbsp;    /**
<i>577</i>&nbsp;     * Qualident = Ident { DOT [Annotations] Ident }
<b class="nc"><i>578</i>&nbsp;     */</b>
<i>579</i>&nbsp;    public JCExpression qualident(boolean allowAnnos) {
<i>580</i>&nbsp;        JCExpression t = toP(F.at(token.pos).Ident(ident()));
<i>581</i>&nbsp;        while (token.kind == DOT) {
<i>582</i>&nbsp;            int pos = token.pos;
<i>583</i>&nbsp;            nextToken();
<i>584</i>&nbsp;            List&lt;JCAnnotation&gt; tyannos = null;
<i>585</i>&nbsp;            if (allowAnnos) {
<i>586</i>&nbsp;                tyannos = typeAnnotationsOpt();
<i>587</i>&nbsp;            }
<i>588</i>&nbsp;            t = toP(F.at(pos).Select(t, ident()));
<b class="nc"><i>589</i>&nbsp;            if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {</b>
<b class="nc"><i>590</i>&nbsp;                t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));</b>
<b class="nc"><i>591</i>&nbsp;            }</b>
<b class="nc"><i>592</i>&nbsp;        }</b>
<b class="nc"><i>593</i>&nbsp;        return t;</b>
<b class="nc"><i>594</i>&nbsp;    }</b>
<b class="nc"><i>595</i>&nbsp;</b>
<b class="nc"><i>596</i>&nbsp;    JCExpression literal(Name prefix) {</b>
<b class="nc"><i>597</i>&nbsp;        return literal(prefix, token.pos);</b>
<i>598</i>&nbsp;    }
<b class="nc"><i>599</i>&nbsp;</b>
<b class="nc"><i>600</i>&nbsp;    /**</b>
<b class="nc"><i>601</i>&nbsp;     * Literal =</b>
<b class="nc"><i>602</i>&nbsp;     *     INTLITERAL</b>
<i>603</i>&nbsp;     *   | LONGLITERAL
<b class="nc"><i>604</i>&nbsp;     *   | FLOATLITERAL</b>
<b class="nc"><i>605</i>&nbsp;     *   | DOUBLELITERAL</b>
<b class="nc"><i>606</i>&nbsp;     *   | CHARLITERAL</b>
<b class="nc"><i>607</i>&nbsp;     *   | STRINGLITERAL</b>
<b class="nc"><i>608</i>&nbsp;     *   | TRUE</b>
<i>609</i>&nbsp;     *   | FALSE
<b class="nc"><i>610</i>&nbsp;     *   | NULL</b>
<b class="nc"><i>611</i>&nbsp;     */</b>
<b class="nc"><i>612</i>&nbsp;    JCExpression literal(Name prefix, int pos) {</b>
<b class="nc"><i>613</i>&nbsp;        JCExpression t = errorTree;</b>
<i>614</i>&nbsp;        switch (token.kind) {
<b class="nc"><i>615</i>&nbsp;        case INTLITERAL:</b>
<b class="nc"><i>616</i>&nbsp;            try {</b>
<i>617</i>&nbsp;                t = F.at(pos).Literal(
<b class="nc"><i>618</i>&nbsp;                    TypeTag.INT,</b>
<b class="nc"><i>619</i>&nbsp;                    Convert.string2int(strval(prefix), token.radix()));</b>
<b class="nc"><i>620</i>&nbsp;            } catch (NumberFormatException ex) {</b>
<b class="nc"><i>621</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));</b>
<i>622</i>&nbsp;            }
<b class="nc"><i>623</i>&nbsp;            break;</b>
<b class="nc"><i>624</i>&nbsp;        case LONGLITERAL:</b>
<b class="nc"><i>625</i>&nbsp;            try {</b>
<i>626</i>&nbsp;                t = F.at(pos).Literal(
<b class="nc"><i>627</i>&nbsp;                    TypeTag.LONG,</b>
<b class="nc"><i>628</i>&nbsp;                    Long.valueOf(Convert.string2long(strval(prefix), token.radix())));</b>
<b class="nc"><i>629</i>&nbsp;            } catch (NumberFormatException ex) {</b>
<b class="nc"><i>630</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));</b>
<b class="nc"><i>631</i>&nbsp;            }</b>
<i>632</i>&nbsp;            break;
<b class="nc"><i>633</i>&nbsp;        case FLOATLITERAL: {</b>
<b class="nc"><i>634</i>&nbsp;            String proper = token.radix() == 16 ?</b>
<i>635</i>&nbsp;                    (&quot;0x&quot;+ token.stringVal()) :
<i>636</i>&nbsp;                    token.stringVal();
<i>637</i>&nbsp;            Float n;
<i>638</i>&nbsp;            try {
<i>639</i>&nbsp;                n = Float.valueOf(proper);
<i>640</i>&nbsp;            } catch (NumberFormatException ex) {
<i>641</i>&nbsp;                // error already reported in scanner
<b class="nc"><i>642</i>&nbsp;                n = Float.NaN;</b>
<b class="nc"><i>643</i>&nbsp;            }</b>
<b class="nc"><i>644</i>&nbsp;            if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))</b>
<b class="nc"><i>645</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);</b>
<b class="nc"><i>646</i>&nbsp;            else if (n.floatValue() == Float.POSITIVE_INFINITY)</b>
<b class="nc"><i>647</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);</b>
<b class="nc"><i>648</i>&nbsp;            else</b>
<i>649</i>&nbsp;                t = F.at(pos).Literal(TypeTag.FLOAT, n);
<b class="nc"><i>650</i>&nbsp;            break;</b>
<b class="nc"><i>651</i>&nbsp;        }</b>
<b class="nc"><i>652</i>&nbsp;        case DOUBLELITERAL: {</b>
<i>653</i>&nbsp;            String proper = token.radix() == 16 ?
<b class="nc"><i>654</i>&nbsp;                    (&quot;0x&quot;+ token.stringVal()) :</b>
<b class="nc"><i>655</i>&nbsp;                    token.stringVal();</b>
<i>656</i>&nbsp;            Double n;
<i>657</i>&nbsp;            try {
<i>658</i>&nbsp;                n = Double.valueOf(proper);
<b class="nc"><i>659</i>&nbsp;            } catch (NumberFormatException ex) {</b>
<i>660</i>&nbsp;                // error already reported in scanner
<i>661</i>&nbsp;                n = Double.NaN;
<i>662</i>&nbsp;            }
<i>663</i>&nbsp;            if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
<i>664</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
<i>665</i>&nbsp;            else if (n.doubleValue() == Double.POSITIVE_INFINITY)
<i>666</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
<i>667</i>&nbsp;            else
<i>668</i>&nbsp;                t = F.at(pos).Literal(TypeTag.DOUBLE, n);
<i>669</i>&nbsp;            break;
<i>670</i>&nbsp;        }
<i>671</i>&nbsp;        case CHARLITERAL:
<i>672</i>&nbsp;            t = F.at(pos).Literal(
<i>673</i>&nbsp;                TypeTag.CHAR,
<i>674</i>&nbsp;                token.stringVal().charAt(0) + 0);
<b class="nc"><i>675</i>&nbsp;            break;</b>
<b class="nc"><i>676</i>&nbsp;        case STRINGLITERAL:</b>
<i>677</i>&nbsp;            t = F.at(pos).Literal(
<i>678</i>&nbsp;                TypeTag.CLASS,
<b class="nc"><i>679</i>&nbsp;                token.stringVal());</b>
<i>680</i>&nbsp;            break;
<b class="nc"><i>681</i>&nbsp;        case TRUE: case FALSE:</b>
<b class="nc"><i>682</i>&nbsp;            t = F.at(pos).Literal(</b>
<b class="nc"><i>683</i>&nbsp;                TypeTag.BOOLEAN,</b>
<b class="nc"><i>684</i>&nbsp;                (token.kind == TRUE ? 1 : 0));</b>
<b class="nc"><i>685</i>&nbsp;            break;</b>
<i>686</i>&nbsp;        case NULL:
<i>687</i>&nbsp;            t = F.at(pos).Literal(
<b class="nc"><i>688</i>&nbsp;                TypeTag.BOT,</b>
<i>689</i>&nbsp;                null);
<b class="nc"><i>690</i>&nbsp;            break;</b>
<b class="nc"><i>691</i>&nbsp;        default:</b>
<b class="nc"><i>692</i>&nbsp;            Assert.error();</b>
<b class="nc"><i>693</i>&nbsp;        }</b>
<b class="nc"><i>694</i>&nbsp;        if (t == errorTree)</b>
<i>695</i>&nbsp;            t = F.at(pos).Erroneous();
<b class="nc"><i>696</i>&nbsp;        storeEnd(t, token.endPos);</b>
<b class="nc"><i>697</i>&nbsp;        nextToken();</b>
<b class="nc"><i>698</i>&nbsp;        return t;</b>
<i>699</i>&nbsp;    }
<i>700</i>&nbsp;    //where
<b class="nc"><i>701</i>&nbsp;        boolean isZero(String s) {</b>
<b class="nc"><i>702</i>&nbsp;            char[] cs = s.toCharArray();</b>
<i>703</i>&nbsp;            int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
<b class="nc"><i>704</i>&nbsp;            int i = ((base==16) ? 2 : 0);</b>
<b class="nc"><i>705</i>&nbsp;            while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;</b>
<b class="nc"><i>706</i>&nbsp;            return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));</b>
<b class="nc"><i>707</i>&nbsp;        }</b>
<b class="nc"><i>708</i>&nbsp;</b>
<b class="nc"><i>709</i>&nbsp;        String strval(Name prefix) {</b>
<i>710</i>&nbsp;            String s = token.stringVal();
<b class="nc"><i>711</i>&nbsp;            return prefix.isEmpty() ? s : prefix + s;</b>
<b class="nc"><i>712</i>&nbsp;        }</b>
<i>713</i>&nbsp;
<i>714</i>&nbsp;    /** terms can be either expressions or types.
<b class="nc"><i>715</i>&nbsp;     */</b>
<b class="nc"><i>716</i>&nbsp;    public JCExpression parseExpression() {</b>
<b class="nc"><i>717</i>&nbsp;        return term(EXPR);</b>
<i>718</i>&nbsp;    }
<i>719</i>&nbsp;
<b class="nc"><i>720</i>&nbsp;    /**</b>
<b class="nc"><i>721</i>&nbsp;     * parses (optional) type annotations followed by a type. If the</b>
<i>722</i>&nbsp;     * annotations are present before the type and are not consumed during array
<b class="nc"><i>723</i>&nbsp;     * parsing, this method returns a {@link JCAnnotatedType} consisting of</b>
<b class="nc"><i>724</i>&nbsp;     * these annotations and the underlying type. Otherwise, it returns the</b>
<b class="nc"><i>725</i>&nbsp;     * underlying type.</b>
<b class="nc"><i>726</i>&nbsp;     *</b>
<b class="nc"><i>727</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>728</i>&nbsp;     *</b>
<i>729</i>&nbsp;     * Note that this method sets {@code mode} to {@code TYPE} first, before
<b class="nc"><i>730</i>&nbsp;     * parsing annotations.</b>
<b class="nc"><i>731</i>&nbsp;     */</b>
<i>732</i>&nbsp;    public JCExpression parseType() {
<i>733</i>&nbsp;        return parseType(false);
<b class="nc"><i>734</i>&nbsp;    }</b>
<i>735</i>&nbsp;
<b class="nc"><i>736</i>&nbsp;    public JCExpression parseType(boolean allowVar) {</b>
<b class="nc"><i>737</i>&nbsp;        List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();</b>
<i>738</i>&nbsp;        return parseType(allowVar, annotations);
<b class="nc"><i>739</i>&nbsp;    }</b>
<i>740</i>&nbsp;
<b class="nc"><i>741</i>&nbsp;    public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {</b>
<b class="nc"><i>742</i>&nbsp;        JCExpression result = unannotatedType(allowVar);</b>
<i>743</i>&nbsp;
<b class="nc"><i>744</i>&nbsp;        if (annotations.nonEmpty()) {</b>
<i>745</i>&nbsp;            result = insertAnnotationsToMostInner(result, annotations, false);
<b class="nc"><i>746</i>&nbsp;        }</b>
<b class="nc"><i>747</i>&nbsp;</b>
<i>748</i>&nbsp;        return result;
<b class="nc"><i>749</i>&nbsp;    }</b>
<i>750</i>&nbsp;
<i>751</i>&nbsp;    public JCExpression unannotatedType(boolean allowVar) {
<b class="nc"><i>752</i>&nbsp;        JCExpression result = term(TYPE);</b>
<i>753</i>&nbsp;
<b class="nc"><i>754</i>&nbsp;        if (!allowVar &amp;&amp; isRestrictedLocalVarTypeName(result, true)) {</b>
<i>755</i>&nbsp;            syntaxError(result.pos, Errors.VarNotAllowedHere);
<b class="nc"><i>756</i>&nbsp;        }</b>
<b class="nc"><i>757</i>&nbsp;</b>
<b class="nc"><i>758</i>&nbsp;        return result;</b>
<b class="nc"><i>759</i>&nbsp;    }</b>
<b class="nc"><i>760</i>&nbsp;</b>
<i>761</i>&nbsp;
<i>762</i>&nbsp;
<i>763</i>&nbsp;    protected JCExpression term(int newmode) {
<b class="nc"><i>764</i>&nbsp;        int prevmode = mode;</b>
<b class="nc"><i>765</i>&nbsp;        mode = newmode;</b>
<b class="nc"><i>766</i>&nbsp;        JCExpression t = term();</b>
<b class="nc"><i>767</i>&nbsp;        lastmode = mode;</b>
<b class="nc"><i>768</i>&nbsp;        mode = prevmode;</b>
<i>769</i>&nbsp;        return t;
<i>770</i>&nbsp;    }
<i>771</i>&nbsp;
<b class="nc"><i>772</i>&nbsp;    /**</b>
<b class="nc"><i>773</i>&nbsp;     *  {@literal</b>
<i>774</i>&nbsp;     *  Expression = Expression1 [ExpressionRest]
<i>775</i>&nbsp;     *  ExpressionRest = [AssignmentOperator Expression1]
<i>776</i>&nbsp;     *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
<i>777</i>&nbsp;     *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
<i>778</i>&nbsp;     *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
<b class="nc"><i>779</i>&nbsp;     *  Type = Type1</b>
<i>780</i>&nbsp;     *  TypeNoParams = TypeNoParams1
<i>781</i>&nbsp;     *  StatementExpression = Expression
<i>782</i>&nbsp;     *  ConstantExpression = Expression
<i>783</i>&nbsp;     *  }
<i>784</i>&nbsp;     */
<i>785</i>&nbsp;    JCExpression term() {
<i>786</i>&nbsp;        JCExpression t = term1();
<i>787</i>&nbsp;        if ((mode &amp; EXPR) != 0 &amp;&amp;
<i>788</i>&nbsp;            token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0)
<i>789</i>&nbsp;            return termRest(t);
<i>790</i>&nbsp;        else
<i>791</i>&nbsp;            return t;
<i>792</i>&nbsp;    }
<i>793</i>&nbsp;
<i>794</i>&nbsp;    JCExpression termRest(JCExpression t) {
<b class="nc"><i>795</i>&nbsp;        switch (token.kind) {</b>
<b class="nc"><i>796</i>&nbsp;        case EQ: {</b>
<i>797</i>&nbsp;            int pos = token.pos;
<i>798</i>&nbsp;            nextToken();
<i>799</i>&nbsp;            mode = EXPR;
<b class="nc"><i>800</i>&nbsp;            JCExpression t1 = term();</b>
<i>801</i>&nbsp;            return toP(F.at(pos).Assign(t, t1));
<b class="nc"><i>802</i>&nbsp;        }</b>
<b class="nc"><i>803</i>&nbsp;        case PLUSEQ:</b>
<i>804</i>&nbsp;        case SUBEQ:
<i>805</i>&nbsp;        case STAREQ:
<b class="nc"><i>806</i>&nbsp;        case SLASHEQ:</b>
<i>807</i>&nbsp;        case PERCENTEQ:
<i>808</i>&nbsp;        case AMPEQ:
<i>809</i>&nbsp;        case BAREQ:
<b class="nc"><i>810</i>&nbsp;        case CARETEQ:</b>
<i>811</i>&nbsp;        case LTLTEQ:
<i>812</i>&nbsp;        case GTGTEQ:
<i>813</i>&nbsp;        case GTGTGTEQ:
<b class="nc"><i>814</i>&nbsp;            int pos = token.pos;</b>
<b class="nc"><i>815</i>&nbsp;            TokenKind tk = token.kind;</b>
<b class="nc"><i>816</i>&nbsp;            nextToken();</b>
<b class="nc"><i>817</i>&nbsp;            mode = EXPR;</b>
<b class="nc"><i>818</i>&nbsp;            JCExpression t1 = term();</b>
<b class="nc"><i>819</i>&nbsp;            return F.at(pos).Assignop(optag(tk), t, t1);</b>
<i>820</i>&nbsp;        default:
<i>821</i>&nbsp;            return t;
<i>822</i>&nbsp;        }
<i>823</i>&nbsp;    }
<i>824</i>&nbsp;
<i>825</i>&nbsp;    /** Expression1   = Expression2 [Expression1Rest]
<i>826</i>&nbsp;     *  Type1         = Type2
<i>827</i>&nbsp;     *  TypeNoParams1 = TypeNoParams2
<i>828</i>&nbsp;     */
<i>829</i>&nbsp;    JCExpression term1() {
<i>830</i>&nbsp;        JCExpression t = term2();
<i>831</i>&nbsp;        if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
<i>832</i>&nbsp;            mode = EXPR;
<i>833</i>&nbsp;            return term1Rest(t);
<i>834</i>&nbsp;        } else {
<i>835</i>&nbsp;            return t;
<b class="nc"><i>836</i>&nbsp;        }</b>
<b class="nc"><i>837</i>&nbsp;    }</b>
<b class="nc"><i>838</i>&nbsp;</b>
<b class="nc"><i>839</i>&nbsp;    /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]</b>
<i>840</i>&nbsp;     */
<b class="nc"><i>841</i>&nbsp;    JCExpression term1Rest(JCExpression t) {</b>
<i>842</i>&nbsp;        if (token.kind == QUES) {
<i>843</i>&nbsp;            int pos = token.pos;
<i>844</i>&nbsp;            nextToken();
<b class="nc"><i>845</i>&nbsp;            JCExpression t1 = term();</b>
<i>846</i>&nbsp;            accept(COLON);
<b class="nc"><i>847</i>&nbsp;            JCExpression t2 = term1();</b>
<b class="nc"><i>848</i>&nbsp;            return F.at(pos).Conditional(t, t1, t2);</b>
<b class="nc"><i>849</i>&nbsp;        } else {</b>
<b class="nc"><i>850</i>&nbsp;            return t;</b>
<b class="nc"><i>851</i>&nbsp;        }</b>
<i>852</i>&nbsp;    }
<i>853</i>&nbsp;
<i>854</i>&nbsp;    /** Expression2   = Expression3 [Expression2Rest]
<i>855</i>&nbsp;     *  Type2         = Type3
<i>856</i>&nbsp;     *  TypeNoParams2 = TypeNoParams3
<i>857</i>&nbsp;     */
<i>858</i>&nbsp;    JCExpression term2() {
<i>859</i>&nbsp;        JCExpression t = term3();
<i>860</i>&nbsp;        if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
<i>861</i>&nbsp;            mode = EXPR;
<i>862</i>&nbsp;            return term2Rest(t, TreeInfo.orPrec);
<i>863</i>&nbsp;        } else {
<b class="nc"><i>864</i>&nbsp;            return t;</b>
<b class="nc"><i>865</i>&nbsp;        }</b>
<b class="nc"><i>866</i>&nbsp;    }</b>
<b class="nc"><i>867</i>&nbsp;</b>
<b class="nc"><i>868</i>&nbsp;    /*  Expression2Rest = {infixop Expression3}</b>
<b class="nc"><i>869</i>&nbsp;     *                  | Expression3 instanceof Type</b>
<i>870</i>&nbsp;     *  infixop         = &quot;||&quot;
<b class="nc"><i>871</i>&nbsp;     *                  | &quot;&amp;&amp;&quot;</b>
<i>872</i>&nbsp;     *                  | &quot;|&quot;
<i>873</i>&nbsp;     *                  | &quot;^&quot;
<i>874</i>&nbsp;     *                  | &quot;&amp;&quot;
<i>875</i>&nbsp;     *                  | &quot;==&quot; | &quot;!=&quot;
<i>876</i>&nbsp;     *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
<i>877</i>&nbsp;     *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
<i>878</i>&nbsp;     *                  | &quot;+&quot; | &quot;-&quot;
<i>879</i>&nbsp;     *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
<b class="nc"><i>880</i>&nbsp;     */</b>
<b class="nc"><i>881</i>&nbsp;    JCExpression term2Rest(JCExpression t, int minprec) {</b>
<b class="nc"><i>882</i>&nbsp;        JCExpression[] odStack = newOdStack();</b>
<b class="nc"><i>883</i>&nbsp;        Token[] opStack = newOpStack();</b>
<i>884</i>&nbsp;
<b class="nc"><i>885</i>&nbsp;        // optimization, was odStack = new Tree[...]; opStack = new Tree[...];</b>
<i>886</i>&nbsp;        int top = 0;
<i>887</i>&nbsp;        odStack[0] = t;
<i>888</i>&nbsp;        int startPos = token.pos;
<i>889</i>&nbsp;        Token topOp = Tokens.DUMMY;
<i>890</i>&nbsp;        while (prec(token.kind) &gt;= minprec) {
<i>891</i>&nbsp;            opStack[top] = topOp;
<b class="nc"><i>892</i>&nbsp;            top++;</b>
<b class="nc"><i>893</i>&nbsp;            topOp = token;</b>
<b class="nc"><i>894</i>&nbsp;            nextToken();</b>
<b class="nc"><i>895</i>&nbsp;            odStack[top] = (topOp.kind == INSTANCEOF) ? parseType() : term3();</b>
<b class="nc"><i>896</i>&nbsp;            while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {</b>
<b class="nc"><i>897</i>&nbsp;                odStack[top-1] = makeOp(topOp.pos, topOp.kind, odStack[top-1],</b>
<b class="nc"><i>898</i>&nbsp;                                        odStack[top]);</b>
<i>899</i>&nbsp;                top--;
<b class="nc"><i>900</i>&nbsp;                topOp = opStack[top];</b>
<i>901</i>&nbsp;            }
<i>902</i>&nbsp;        }
<i>903</i>&nbsp;        Assert.check(top == 0);
<i>904</i>&nbsp;        t = odStack[0];
<i>905</i>&nbsp;
<i>906</i>&nbsp;        if (t.hasTag(JCTree.Tag.PLUS)) {
<i>907</i>&nbsp;            t = foldStrings(t);
<i>908</i>&nbsp;        }
<b class="nc"><i>909</i>&nbsp;</b>
<b class="nc"><i>910</i>&nbsp;        odStackSupply.add(odStack);</b>
<b class="nc"><i>911</i>&nbsp;        opStackSupply.add(opStack);</b>
<b class="nc"><i>912</i>&nbsp;        return t;</b>
<i>913</i>&nbsp;    }
<b class="nc"><i>914</i>&nbsp;    //where</b>
<i>915</i>&nbsp;        /** Construct a binary or type test node.
<i>916</i>&nbsp;         */
<i>917</i>&nbsp;        private JCExpression makeOp(int pos,
<i>918</i>&nbsp;                                    TokenKind topOp,
<i>919</i>&nbsp;                                    JCExpression od1,
<i>920</i>&nbsp;                                    JCExpression od2)
<i>921</i>&nbsp;        {
<i>922</i>&nbsp;            if (topOp == INSTANCEOF) {
<i>923</i>&nbsp;                return F.at(pos).TypeTest(od1, od2);
<i>924</i>&nbsp;            } else {
<i>925</i>&nbsp;                return F.at(pos).Binary(optag(topOp), od1, od2);
<i>926</i>&nbsp;            }
<i>927</i>&nbsp;        }
<i>928</i>&nbsp;        /** If tree is a concatenation of string literals, replace it
<i>929</i>&nbsp;         *  by a single literal representing the concatenated string.
<i>930</i>&nbsp;         */
<i>931</i>&nbsp;        protected JCExpression foldStrings(JCExpression tree) {
<b class="nc"><i>932</i>&nbsp;            if (!allowStringFolding)</b>
<b class="nc"><i>933</i>&nbsp;                return tree;</b>
<i>934</i>&nbsp;            ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
<i>935</i>&nbsp;            ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
<b class="nc"><i>936</i>&nbsp;            boolean needsFolding = false;</b>
<b class="nc"><i>937</i>&nbsp;            JCExpression curr = tree;</b>
<b class="nc"><i>938</i>&nbsp;            while (true) {</b>
<b class="nc"><i>939</i>&nbsp;                if (curr.hasTag(JCTree.Tag.PLUS)) {</b>
<b class="nc"><i>940</i>&nbsp;                    JCBinary op = (JCBinary)curr;</b>
<b class="nc"><i>941</i>&nbsp;                    needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);</b>
<b class="nc"><i>942</i>&nbsp;                    curr = op.lhs;</b>
<b class="nc"><i>943</i>&nbsp;                } else {</b>
<b class="nc"><i>944</i>&nbsp;                    needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);</b>
<b class="nc"><i>945</i>&nbsp;                    break; //last one!</b>
<b class="nc"><i>946</i>&nbsp;                }</b>
<b class="nc"><i>947</i>&nbsp;            }</b>
<i>948</i>&nbsp;            if (needsFolding) {
<b class="nc"><i>949</i>&nbsp;                List&lt;JCExpression&gt; ops = opStack.toList();</b>
<b class="nc"><i>950</i>&nbsp;                JCExpression res = ops.head;</b>
<i>951</i>&nbsp;                for (JCExpression op : ops.tail) {
<i>952</i>&nbsp;                    res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
<b class="nc"><i>953</i>&nbsp;                    storeEnd(res, getEndPos(op));</b>
<b class="nc"><i>954</i>&nbsp;                }</b>
<i>955</i>&nbsp;                return res;
<b class="nc"><i>956</i>&nbsp;            } else {</b>
<b class="nc"><i>957</i>&nbsp;                return tree;</b>
<i>958</i>&nbsp;            }
<i>959</i>&nbsp;        }
<b class="nc"><i>960</i>&nbsp;</b>
<b class="nc"><i>961</i>&nbsp;        private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,</b>
<b class="nc"><i>962</i>&nbsp;                                                ListBuffer&lt;JCExpression&gt; opStack, boolean last) {</b>
<i>963</i>&nbsp;            JCLiteral str = stringLiteral(tree);
<i>964</i>&nbsp;            if (str != null) {
<i>965</i>&nbsp;                litBuf.prepend(str);
<i>966</i>&nbsp;                return last &amp;&amp; merge(litBuf, opStack);
<i>967</i>&nbsp;            } else {
<i>968</i>&nbsp;                boolean res = merge(litBuf, opStack);
<i>969</i>&nbsp;                litBuf.clear();
<i>970</i>&nbsp;                opStack.prepend(tree);
<i>971</i>&nbsp;                return res;
<b class="nc"><i>972</i>&nbsp;            }</b>
<b class="nc"><i>973</i>&nbsp;        }</b>
<i>974</i>&nbsp;
<b class="nc"><i>975</i>&nbsp;        boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {</b>
<i>976</i>&nbsp;            if (litBuf.isEmpty()) {
<i>977</i>&nbsp;                return false;
<i>978</i>&nbsp;            } else if (litBuf.size() == 1) {
<i>979</i>&nbsp;                opStack.prepend(litBuf.first());
<i>980</i>&nbsp;                return false;
<i>981</i>&nbsp;            } else {
<b class="nc"><i>982</i>&nbsp;                JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,</b>
<b class="nc"><i>983</i>&nbsp;                        litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));</b>
<b class="nc"><i>984</i>&nbsp;                storeEnd(t, litBuf.last().getEndPosition(endPosTable));</b>
<b class="nc"><i>985</i>&nbsp;                opStack.prepend(t);</b>
<b class="nc"><i>986</i>&nbsp;                return true;</b>
<b class="nc"><i>987</i>&nbsp;            }</b>
<i>988</i>&nbsp;        }
<b class="nc"><i>989</i>&nbsp;</b>
<b class="nc"><i>990</i>&nbsp;        private JCLiteral stringLiteral(JCTree tree) {</b>
<b class="nc"><i>991</i>&nbsp;            if (tree.hasTag(LITERAL)) {</b>
<b class="nc"><i>992</i>&nbsp;                JCLiteral lit = (JCLiteral)tree;</b>
<b class="nc"><i>993</i>&nbsp;                if (lit.typetag == TypeTag.CLASS) {</b>
<b class="nc"><i>994</i>&nbsp;                    return lit;</b>
<b class="nc"><i>995</i>&nbsp;                }</b>
<i>996</i>&nbsp;            }
<i>997</i>&nbsp;            return null;
<b class="nc"><i>998</i>&nbsp;        }</b>
<b class="nc"><i>999</i>&nbsp;</b>
<b class="nc"><i>1000</i>&nbsp;</b>
<b class="nc"><i>1001</i>&nbsp;        /** optimization: To save allocating a new operand/operator stack</b>
<b class="nc"><i>1002</i>&nbsp;         *  for every binary operation, we use supplys.</b>
<b class="nc"><i>1003</i>&nbsp;         */</b>
<b class="nc"><i>1004</i>&nbsp;        ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1005</i>&nbsp;        ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();</b>
<i>1006</i>&nbsp;
<b class="nc"><i>1007</i>&nbsp;        private JCExpression[] newOdStack() {</b>
<i>1008</i>&nbsp;            if (odStackSupply.isEmpty())
<i>1009</i>&nbsp;                return new JCExpression[infixPrecedenceLevels + 1];
<i>1010</i>&nbsp;            return odStackSupply.remove(odStackSupply.size() - 1);
<i>1011</i>&nbsp;        }
<i>1012</i>&nbsp;
<b class="nc"><i>1013</i>&nbsp;        private Token[] newOpStack() {</b>
<b class="nc"><i>1014</i>&nbsp;            if (opStackSupply.isEmpty())</b>
<b class="nc"><i>1015</i>&nbsp;                return new Token[infixPrecedenceLevels + 1];</b>
<b class="nc"><i>1016</i>&nbsp;            return opStackSupply.remove(opStackSupply.size() - 1);</b>
<i>1017</i>&nbsp;        }
<b class="nc"><i>1018</i>&nbsp;</b>
<b class="nc"><i>1019</i>&nbsp;    /**</b>
<b class="nc"><i>1020</i>&nbsp;     *  Expression3    = PrefixOp Expression3</b>
<b class="nc"><i>1021</i>&nbsp;     *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3</b>
<i>1022</i>&nbsp;     *                 | Primary {Selector} {PostfixOp}
<i>1023</i>&nbsp;     *
<i>1024</i>&nbsp;     *  {@literal
<i>1025</i>&nbsp;     *  Primary        = &quot;(&quot; Expression &quot;)&quot;
<b class="nc"><i>1026</i>&nbsp;     *                 | Literal</b>
<b class="nc"><i>1027</i>&nbsp;     *                 | [TypeArguments] THIS [Arguments]</b>
<b class="nc"><i>1028</i>&nbsp;     *                 | [TypeArguments] SUPER SuperSuffix</b>
<b class="nc"><i>1029</i>&nbsp;     *                 | NEW [TypeArguments] Creator</b>
<b class="nc"><i>1030</i>&nbsp;     *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )</b>
<i>1031</i>&nbsp;     *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
<b class="nc"><i>1032</i>&nbsp;     *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }</b>
<b class="nc"><i>1033</i>&nbsp;     *                 | Expression3 MemberReferenceSuffix</b>
<b class="nc"><i>1034</i>&nbsp;     *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )</b>
<b class="nc"><i>1035</i>&nbsp;     *                   | Arguments</b>
<b class="nc"><i>1036</i>&nbsp;     *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )</b>
<b class="nc"><i>1037</i>&nbsp;     *                   ]</b>
<b class="nc"><i>1038</i>&nbsp;     *                 | BasicType BracketsOpt &quot;.&quot; CLASS</b>
<b class="nc"><i>1039</i>&nbsp;     *  }</b>
<i>1040</i>&nbsp;     *
<i>1041</i>&nbsp;     *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
<i>1042</i>&nbsp;     *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
<i>1043</i>&nbsp;     *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
<b class="nc"><i>1044</i>&nbsp;     *                 | BasicType</b>
<b class="nc"><i>1045</i>&nbsp;     *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt</b>
<b class="nc"><i>1046</i>&nbsp;     *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]</b>
<b class="nc"><i>1047</i>&nbsp;     *                 | &quot;.&quot; THIS</b>
<i>1048</i>&nbsp;     *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
<i>1049</i>&nbsp;     *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
<b class="nc"><i>1050</i>&nbsp;     *                 | &quot;[&quot; Expression &quot;]&quot;</b>
<i>1051</i>&nbsp;     *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
<i>1052</i>&nbsp;     *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
<i>1053</i>&nbsp;     */
<i>1054</i>&nbsp;    protected JCExpression term3() {
<i>1055</i>&nbsp;        int pos = token.pos;
<i>1056</i>&nbsp;        JCExpression t;
<b class="nc"><i>1057</i>&nbsp;        List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);</b>
<b class="nc"><i>1058</i>&nbsp;        switch (token.kind) {</b>
<i>1059</i>&nbsp;        case QUES:
<i>1060</i>&nbsp;            if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
<b class="nc"><i>1061</i>&nbsp;                mode = TYPE;</b>
<b class="nc"><i>1062</i>&nbsp;                return typeArgument();</b>
<b class="nc"><i>1063</i>&nbsp;            } else</b>
<i>1064</i>&nbsp;                return illegal();
<i>1065</i>&nbsp;        case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
<i>1066</i>&nbsp;            if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
<b class="nc"><i>1067</i>&nbsp;                TokenKind tk = token.kind;</b>
<b class="nc"><i>1068</i>&nbsp;                nextToken();</b>
<b class="nc"><i>1069</i>&nbsp;                mode = EXPR;</b>
<i>1070</i>&nbsp;                if (tk == SUB &amp;&amp;
<i>1071</i>&nbsp;                    (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
<i>1072</i>&nbsp;                    token.radix() == 10) {
<i>1073</i>&nbsp;                    mode = EXPR;
<i>1074</i>&nbsp;                    t = literal(names.hyphen, pos);
<i>1075</i>&nbsp;                } else {
<i>1076</i>&nbsp;                    t = term3();
<i>1077</i>&nbsp;                    return F.at(pos).Unary(unoptag(tk), t);
<i>1078</i>&nbsp;                }
<i>1079</i>&nbsp;            } else return illegal();
<i>1080</i>&nbsp;            break;
<i>1081</i>&nbsp;        case LPAREN:
<i>1082</i>&nbsp;            if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
<i>1083</i>&nbsp;                ParensResult pres = analyzeParens();
<i>1084</i>&nbsp;                switch (pres) {
<i>1085</i>&nbsp;                    case CAST:
<i>1086</i>&nbsp;                       accept(LPAREN);
<i>1087</i>&nbsp;                       mode = TYPE;
<i>1088</i>&nbsp;                       int pos1 = pos;
<i>1089</i>&nbsp;                       List&lt;JCExpression&gt; targets = List.of(t = parseType());
<i>1090</i>&nbsp;                       while (token.kind == AMP) {
<i>1091</i>&nbsp;                           checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
<i>1092</i>&nbsp;                           accept(AMP);
<i>1093</i>&nbsp;                           targets = targets.prepend(parseType());
<i>1094</i>&nbsp;                       }
<i>1095</i>&nbsp;                       if (targets.length() &gt; 1) {
<i>1096</i>&nbsp;                           t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
<i>1097</i>&nbsp;                       }
<i>1098</i>&nbsp;                       accept(RPAREN);
<i>1099</i>&nbsp;                       mode = EXPR;
<i>1100</i>&nbsp;                       JCExpression t1 = term3();
<i>1101</i>&nbsp;                       return F.at(pos).TypeCast(t, t1);
<i>1102</i>&nbsp;                    case IMPLICIT_LAMBDA:
<i>1103</i>&nbsp;                    case EXPLICIT_LAMBDA:
<i>1104</i>&nbsp;                        t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
<i>1105</i>&nbsp;                        break;
<i>1106</i>&nbsp;                    default: //PARENS
<i>1107</i>&nbsp;                        accept(LPAREN);
<b class="nc"><i>1108</i>&nbsp;                        mode = EXPR;</b>
<i>1109</i>&nbsp;                        t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
<b class="nc"><i>1110</i>&nbsp;                        accept(RPAREN);</b>
<b class="nc"><i>1111</i>&nbsp;                        t = toP(F.at(pos).Parens(t));</b>
<i>1112</i>&nbsp;                        break;
<b class="nc"><i>1113</i>&nbsp;                }</b>
<b class="nc"><i>1114</i>&nbsp;            } else {</b>
<b class="nc"><i>1115</i>&nbsp;                return illegal();</b>
<i>1116</i>&nbsp;            }
<b class="nc"><i>1117</i>&nbsp;            break;</b>
<i>1118</i>&nbsp;        case THIS:
<b class="nc"><i>1119</i>&nbsp;            if ((mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1120</i>&nbsp;                mode = EXPR;</b>
<b class="nc"><i>1121</i>&nbsp;                t = to(F.at(pos).Ident(names._this));</b>
<b class="nc"><i>1122</i>&nbsp;                nextToken();</b>
<b class="nc"><i>1123</i>&nbsp;                if (typeArgs == null)</b>
<i>1124</i>&nbsp;                    t = argumentsOpt(null, t);
<b class="nc"><i>1125</i>&nbsp;                else</b>
<b class="nc"><i>1126</i>&nbsp;                    t = arguments(typeArgs, t);</b>
<b class="nc"><i>1127</i>&nbsp;                typeArgs = null;</b>
<i>1128</i>&nbsp;            } else return illegal();
<b class="nc"><i>1129</i>&nbsp;            break;</b>
<b class="nc"><i>1130</i>&nbsp;        case SUPER:</b>
<i>1131</i>&nbsp;            if ((mode &amp; EXPR) != 0) {
<b class="nc"><i>1132</i>&nbsp;                mode = EXPR;</b>
<i>1133</i>&nbsp;                t = to(F.at(pos).Ident(names._super));
<i>1134</i>&nbsp;                t = superSuffix(typeArgs, t);
<b class="nc"><i>1135</i>&nbsp;                typeArgs = null;</b>
<b class="nc"><i>1136</i>&nbsp;            } else return illegal();</b>
<b class="nc"><i>1137</i>&nbsp;            break;</b>
<i>1138</i>&nbsp;        case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
<b class="nc"><i>1139</i>&nbsp;        case CHARLITERAL: case STRINGLITERAL:</b>
<b class="nc"><i>1140</i>&nbsp;        case TRUE: case FALSE: case NULL:</b>
<b class="nc"><i>1141</i>&nbsp;            if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1142</i>&nbsp;                mode = EXPR;</b>
<b class="nc"><i>1143</i>&nbsp;                t = literal(names.empty);</b>
<b class="nc"><i>1144</i>&nbsp;            } else return illegal();</b>
<b class="nc"><i>1145</i>&nbsp;            break;</b>
<b class="nc"><i>1146</i>&nbsp;        case NEW:</b>
<i>1147</i>&nbsp;            if (typeArgs != null) return illegal();
<b class="nc"><i>1148</i>&nbsp;            if ((mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1149</i>&nbsp;                mode = EXPR;</b>
<i>1150</i>&nbsp;                nextToken();
<b class="nc"><i>1151</i>&nbsp;                if (token.kind == LT) typeArgs = typeArguments(false);</b>
<b class="nc"><i>1152</i>&nbsp;                t = creator(pos, typeArgs);</b>
<b class="nc"><i>1153</i>&nbsp;                typeArgs = null;</b>
<b class="nc"><i>1154</i>&nbsp;            } else return illegal();</b>
<i>1155</i>&nbsp;            break;
<i>1156</i>&nbsp;        case MONKEYS_AT:
<b class="nc"><i>1157</i>&nbsp;            // Only annotated cast types and method references are valid</b>
<b class="nc"><i>1158</i>&nbsp;            List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();</b>
<i>1159</i>&nbsp;            if (typeAnnos.isEmpty()) {
<b class="nc"><i>1160</i>&nbsp;                // else there would be no &#39;@&#39;</b>
<b class="nc"><i>1161</i>&nbsp;                throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);</b>
<b class="nc"><i>1162</i>&nbsp;            }</b>
<b class="nc"><i>1163</i>&nbsp;</b>
<b class="nc"><i>1164</i>&nbsp;            JCExpression expr = term3();</b>
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;            if ((mode &amp; TYPE) == 0) {
<b class="nc"><i>1167</i>&nbsp;                // Type annotations on class literals no longer legal</b>
<b class="nc"><i>1168</i>&nbsp;                switch (expr.getTag()) {</b>
<i>1169</i>&nbsp;                case REFERENCE: {
<i>1170</i>&nbsp;                    JCMemberReference mref = (JCMemberReference) expr;
<i>1171</i>&nbsp;                    mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
<b class="nc"><i>1172</i>&nbsp;                    t = mref;</b>
<b class="nc"><i>1173</i>&nbsp;                    break;</b>
<b class="nc"><i>1174</i>&nbsp;                }</b>
<b class="nc"><i>1175</i>&nbsp;                case SELECT: {</b>
<b class="nc"><i>1176</i>&nbsp;                    JCFieldAccess sel = (JCFieldAccess) expr;</b>
<b class="nc"><i>1177</i>&nbsp;</b>
<i>1178</i>&nbsp;                    if (sel.name != names._class) {
<b class="nc"><i>1179</i>&nbsp;                        return illegal();</b>
<b class="nc"><i>1180</i>&nbsp;                    } else {</b>
<b class="nc"><i>1181</i>&nbsp;                        log.error(token.pos, Errors.NoAnnotationsOnDotClass);</b>
<i>1182</i>&nbsp;                        return expr;
<i>1183</i>&nbsp;                    }
<b class="nc"><i>1184</i>&nbsp;                }</b>
<b class="nc"><i>1185</i>&nbsp;                default:</b>
<b class="nc"><i>1186</i>&nbsp;                    return illegal(typeAnnos.head.pos);</b>
<b class="nc"><i>1187</i>&nbsp;                }</b>
<b class="nc"><i>1188</i>&nbsp;</b>
<b class="nc"><i>1189</i>&nbsp;            } else {</b>
<i>1190</i>&nbsp;                // Type annotations targeting a cast
<i>1191</i>&nbsp;                t = insertAnnotationsToMostInner(expr, typeAnnos, false);
<i>1192</i>&nbsp;            }
<i>1193</i>&nbsp;            break;
<b class="nc"><i>1194</i>&nbsp;        case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:</b>
<b class="nc"><i>1195</i>&nbsp;            if (typeArgs != null) return illegal();</b>
<b class="nc"><i>1196</i>&nbsp;            if ((mode &amp; EXPR) != 0 &amp;&amp; peekToken(ARROW)) {</b>
<b class="nc"><i>1197</i>&nbsp;                t = lambdaExpressionOrStatement(false, false, pos);</b>
<i>1198</i>&nbsp;            } else {
<i>1199</i>&nbsp;                t = toP(F.at(token.pos).Ident(ident()));
<b class="nc"><i>1200</i>&nbsp;                loop: while (true) {</b>
<b class="nc"><i>1201</i>&nbsp;                    pos = token.pos;</b>
<b class="nc"><i>1202</i>&nbsp;                    final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();</b>
<b class="nc"><i>1203</i>&nbsp;</b>
<b class="nc"><i>1204</i>&nbsp;                    // need to report an error later if LBRACKET is for array</b>
<b class="nc"><i>1205</i>&nbsp;                    // index access rather than array creation level</b>
<b class="nc"><i>1206</i>&nbsp;                    if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)</b>
<b class="nc"><i>1207</i>&nbsp;                        return illegal(annos.head.pos);</b>
<i>1208</i>&nbsp;
<i>1209</i>&nbsp;                    switch (token.kind) {
<i>1210</i>&nbsp;                    case LBRACKET:
<b class="nc"><i>1211</i>&nbsp;                        nextToken();</b>
<b class="nc"><i>1212</i>&nbsp;                        if (token.kind == RBRACKET) {</b>
<i>1213</i>&nbsp;                            nextToken();
<b class="nc"><i>1214</i>&nbsp;                            t = bracketsOpt(t);</b>
<i>1215</i>&nbsp;                            t = toP(F.at(pos).TypeArray(t));
<i>1216</i>&nbsp;                            if (annos.nonEmpty()) {
<b class="nc"><i>1217</i>&nbsp;                                t = toP(F.at(pos).AnnotatedType(annos, t));</b>
<i>1218</i>&nbsp;                            }
<b class="nc"><i>1219</i>&nbsp;                            t = bracketsSuffix(t);</b>
<i>1220</i>&nbsp;                        } else {
<b class="nc"><i>1221</i>&nbsp;                            if ((mode &amp; EXPR) != 0) {</b>
<i>1222</i>&nbsp;                                mode = EXPR;
<b class="nc"><i>1223</i>&nbsp;                                JCExpression t1 = term();</b>
<b class="nc"><i>1224</i>&nbsp;                                if (!annos.isEmpty()) t = illegal(annos.head.pos);</b>
<b class="nc"><i>1225</i>&nbsp;                                t = to(F.at(pos).Indexed(t, t1));</b>
<b class="nc"><i>1226</i>&nbsp;                            }</b>
<i>1227</i>&nbsp;                            accept(RBRACKET);
<i>1228</i>&nbsp;                        }
<b class="nc"><i>1229</i>&nbsp;                        break loop;</b>
<i>1230</i>&nbsp;                    case LPAREN:
<b class="nc"><i>1231</i>&nbsp;                        if ((mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1232</i>&nbsp;                            mode = EXPR;</b>
<i>1233</i>&nbsp;                            t = arguments(typeArgs, t);
<b class="nc"><i>1234</i>&nbsp;                            if (!annos.isEmpty()) t = illegal(annos.head.pos);</b>
<b class="nc"><i>1235</i>&nbsp;                            typeArgs = null;</b>
<i>1236</i>&nbsp;                        }
<i>1237</i>&nbsp;                        break loop;
<i>1238</i>&nbsp;                    case DOT:
<b class="nc"><i>1239</i>&nbsp;                        nextToken();</b>
<i>1240</i>&nbsp;                        if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
<i>1241</i>&nbsp;                            return illegal();
<i>1242</i>&nbsp;                        }
<i>1243</i>&nbsp;                        int oldmode = mode;
<b class="nc"><i>1244</i>&nbsp;                        mode &amp;= ~NOPARAMS;</b>
<i>1245</i>&nbsp;                        typeArgs = typeArgumentsOpt(EXPR);
<b class="nc"><i>1246</i>&nbsp;                        mode = oldmode;</b>
<i>1247</i>&nbsp;                        if ((mode &amp; EXPR) != 0) {
<b class="nc"><i>1248</i>&nbsp;                            switch (token.kind) {</b>
<b class="nc"><i>1249</i>&nbsp;                            case CLASS:</b>
<b class="nc"><i>1250</i>&nbsp;                                if (typeArgs != null) return illegal();</b>
<i>1251</i>&nbsp;                                mode = EXPR;
<b class="nc"><i>1252</i>&nbsp;                                t = to(F.at(pos).Select(t, names._class));</b>
<i>1253</i>&nbsp;                                nextToken();
<b class="nc"><i>1254</i>&nbsp;                                break loop;</b>
<b class="nc"><i>1255</i>&nbsp;                            case THIS:</b>
<i>1256</i>&nbsp;                                if (typeArgs != null) return illegal();
<i>1257</i>&nbsp;                                mode = EXPR;
<i>1258</i>&nbsp;                                t = to(F.at(pos).Select(t, names._this));
<b class="nc"><i>1259</i>&nbsp;                                nextToken();</b>
<b class="nc"><i>1260</i>&nbsp;                                break loop;</b>
<i>1261</i>&nbsp;                            case SUPER:
<b class="nc"><i>1262</i>&nbsp;                                mode = EXPR;</b>
<i>1263</i>&nbsp;                                t = to(F.at(pos).Select(t, names._super));
<b class="nc"><i>1264</i>&nbsp;                                t = superSuffix(typeArgs, t);</b>
<b class="nc"><i>1265</i>&nbsp;                                typeArgs = null;</b>
<b class="nc"><i>1266</i>&nbsp;                                break loop;</b>
<b class="nc"><i>1267</i>&nbsp;                            case NEW:</b>
<b class="nc"><i>1268</i>&nbsp;                                if (typeArgs != null) return illegal();</b>
<b class="nc"><i>1269</i>&nbsp;                                mode = EXPR;</b>
<b class="nc"><i>1270</i>&nbsp;                                int pos1 = token.pos;</b>
<i>1271</i>&nbsp;                                nextToken();
<i>1272</i>&nbsp;                                if (token.kind == LT) typeArgs = typeArguments(false);
<b class="nc"><i>1273</i>&nbsp;                                t = innerCreator(pos1, typeArgs, t);</b>
<b class="nc"><i>1274</i>&nbsp;                                typeArgs = null;</b>
<i>1275</i>&nbsp;                                break loop;
<i>1276</i>&nbsp;                            }
<i>1277</i>&nbsp;                        }
<b class="nc"><i>1278</i>&nbsp;</b>
<i>1279</i>&nbsp;                        List&lt;JCAnnotation&gt; tyannos = null;
<b class="nc"><i>1280</i>&nbsp;                        if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {</b>
<b class="nc"><i>1281</i>&nbsp;                            tyannos = typeAnnotationsOpt();</b>
<b class="nc"><i>1282</i>&nbsp;                        }</b>
<b class="nc"><i>1283</i>&nbsp;                        // typeArgs saved for next loop iteration.</b>
<b class="nc"><i>1284</i>&nbsp;                        t = toP(F.at(pos).Select(t, ident()));</b>
<b class="nc"><i>1285</i>&nbsp;                        if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {</b>
<b class="nc"><i>1286</i>&nbsp;                            t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));</b>
<i>1287</i>&nbsp;                        }
<b class="nc"><i>1288</i>&nbsp;                        break;</b>
<i>1289</i>&nbsp;                    case ELLIPSIS:
<b class="nc"><i>1290</i>&nbsp;                        if (this.permitTypeAnnotationsPushBack) {</b>
<i>1291</i>&nbsp;                            this.typeAnnotationsPushedBack = annos;
<b class="nc"><i>1292</i>&nbsp;                        } else if (annos.nonEmpty()) {</b>
<b class="nc"><i>1293</i>&nbsp;                            // Don&#39;t return here -- error recovery attempt</b>
<b class="nc"><i>1294</i>&nbsp;                            illegal(annos.head.pos);</b>
<b class="nc"><i>1295</i>&nbsp;                        }</b>
<b class="nc"><i>1296</i>&nbsp;                        break loop;</b>
<i>1297</i>&nbsp;                    case LT:
<i>1298</i>&nbsp;                        if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
<i>1299</i>&nbsp;                            //this is an unbound method reference whose qualifier
<b class="nc"><i>1300</i>&nbsp;                            //is a generic type i.e. A&lt;S&gt;::m</b>
<b class="nc"><i>1301</i>&nbsp;                            int pos1 = token.pos;</b>
<b class="nc"><i>1302</i>&nbsp;                            accept(LT);</b>
<b class="nc"><i>1303</i>&nbsp;                            ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1304</i>&nbsp;                            args.append(typeArgument());</b>
<b class="nc"><i>1305</i>&nbsp;                            while (token.kind == COMMA) {</b>
<b class="nc"><i>1306</i>&nbsp;                                nextToken();</b>
<i>1307</i>&nbsp;                                args.append(typeArgument());
<b class="nc"><i>1308</i>&nbsp;                            }</b>
<b class="nc"><i>1309</i>&nbsp;                            accept(GT);</b>
<b class="nc"><i>1310</i>&nbsp;                            t = toP(F.at(pos1).TypeApply(t, args.toList()));</b>
<b class="nc"><i>1311</i>&nbsp;                            while (token.kind == DOT) {</b>
<b class="nc"><i>1312</i>&nbsp;                                nextToken();</b>
<i>1313</i>&nbsp;                                mode = TYPE;
<b class="nc"><i>1314</i>&nbsp;                                t = toP(F.at(token.pos).Select(t, ident()));</b>
<b class="nc"><i>1315</i>&nbsp;                                t = typeArgumentsOpt(t);</b>
<b class="nc"><i>1316</i>&nbsp;                            }</b>
<b class="nc"><i>1317</i>&nbsp;                            t = bracketsOpt(t);</b>
<b class="nc"><i>1318</i>&nbsp;                            if (token.kind != COLCOL) {</b>
<i>1319</i>&nbsp;                                //method reference expected here
<b class="nc"><i>1320</i>&nbsp;                                t = illegal();</b>
<b class="nc"><i>1321</i>&nbsp;                            }</b>
<b class="nc"><i>1322</i>&nbsp;                            mode = EXPR;</b>
<b class="nc"><i>1323</i>&nbsp;                            return term3Rest(t, typeArgs);</b>
<b class="nc"><i>1324</i>&nbsp;                        }</b>
<i>1325</i>&nbsp;                        break loop;
<b class="nc"><i>1326</i>&nbsp;                    default:</b>
<b class="nc"><i>1327</i>&nbsp;                        break loop;</b>
<b class="nc"><i>1328</i>&nbsp;                    }</b>
<b class="nc"><i>1329</i>&nbsp;                }</b>
<b class="nc"><i>1330</i>&nbsp;            }</b>
<b class="nc"><i>1331</i>&nbsp;            if (typeArgs != null) illegal();</b>
<b class="nc"><i>1332</i>&nbsp;            t = typeArgumentsOpt(t);</b>
<b class="nc"><i>1333</i>&nbsp;            break;</b>
<i>1334</i>&nbsp;        case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
<i>1335</i>&nbsp;        case DOUBLE: case BOOLEAN:
<i>1336</i>&nbsp;            if (typeArgs != null) illegal();
<b class="nc"><i>1337</i>&nbsp;            t = bracketsSuffix(bracketsOpt(basicType()));</b>
<b class="nc"><i>1338</i>&nbsp;            break;</b>
<b class="nc"><i>1339</i>&nbsp;        case VOID:</b>
<i>1340</i>&nbsp;            if (typeArgs != null) illegal();
<i>1341</i>&nbsp;            if ((mode &amp; EXPR) != 0) {
<b class="nc"><i>1342</i>&nbsp;                nextToken();</b>
<b class="nc"><i>1343</i>&nbsp;                if (token.kind == DOT) {</b>
<b class="nc"><i>1344</i>&nbsp;                    JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));</b>
<i>1345</i>&nbsp;                    t = bracketsSuffix(ti);
<i>1346</i>&nbsp;                } else {
<i>1347</i>&nbsp;                    return illegal(pos);
<b class="nc"><i>1348</i>&nbsp;                }</b>
<b class="nc"><i>1349</i>&nbsp;            } else {</b>
<b class="nc"><i>1350</i>&nbsp;                // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing</b>
<i>1351</i>&nbsp;                // a void type (like other primitive types) to the next phase.
<b class="nc"><i>1352</i>&nbsp;                // The error will be reported in Attr.attribTypes or Attr.visitApply.</b>
<i>1353</i>&nbsp;                JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
<i>1354</i>&nbsp;                nextToken();
<i>1355</i>&nbsp;                return ti;
<b class="nc"><i>1356</i>&nbsp;                //return illegal();</b>
<i>1357</i>&nbsp;            }
<i>1358</i>&nbsp;            break;
<b class="nc"><i>1359</i>&nbsp;        default:</b>
<b class="nc"><i>1360</i>&nbsp;            return illegal();</b>
<b class="nc"><i>1361</i>&nbsp;        }</b>
<b class="nc"><i>1362</i>&nbsp;        return term3Rest(t, typeArgs);</b>
<b class="nc"><i>1363</i>&nbsp;    }</b>
<b class="nc"><i>1364</i>&nbsp;</b>
<b class="nc"><i>1365</i>&nbsp;    JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {</b>
<i>1366</i>&nbsp;        if (typeArgs != null) illegal();
<b class="nc"><i>1367</i>&nbsp;        while (true) {</b>
<b class="nc"><i>1368</i>&nbsp;            int pos1 = token.pos;</b>
<b class="nc"><i>1369</i>&nbsp;            final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();</b>
<b class="nc"><i>1370</i>&nbsp;</b>
<b class="nc"><i>1371</i>&nbsp;            if (token.kind == LBRACKET) {</b>
<b class="nc"><i>1372</i>&nbsp;                nextToken();</b>
<b class="nc"><i>1373</i>&nbsp;                if ((mode &amp; TYPE) != 0) {</b>
<b class="nc"><i>1374</i>&nbsp;                    int oldmode = mode;</b>
<i>1375</i>&nbsp;                    mode = TYPE;
<b class="nc"><i>1376</i>&nbsp;                    if (token.kind == RBRACKET) {</b>
<b class="nc"><i>1377</i>&nbsp;                        nextToken();</b>
<i>1378</i>&nbsp;                        t = bracketsOpt(t);
<b class="nc"><i>1379</i>&nbsp;                        t = toP(F.at(pos1).TypeArray(t));</b>
<i>1380</i>&nbsp;                        if (token.kind == COLCOL) {
<b class="nc"><i>1381</i>&nbsp;                            mode = EXPR;</b>
<b class="nc"><i>1382</i>&nbsp;                            continue;</b>
<i>1383</i>&nbsp;                        }
<i>1384</i>&nbsp;                        if (annos.nonEmpty()) {
<i>1385</i>&nbsp;                            t = toP(F.at(pos1).AnnotatedType(annos, t));
<b class="nc"><i>1386</i>&nbsp;                        }</b>
<i>1387</i>&nbsp;                        return t;
<b class="nc"><i>1388</i>&nbsp;                    }</b>
<i>1389</i>&nbsp;                    mode = oldmode;
<b class="nc"><i>1390</i>&nbsp;                }</b>
<b class="nc"><i>1391</i>&nbsp;                if ((mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1392</i>&nbsp;                    mode = EXPR;</b>
<i>1393</i>&nbsp;                    JCExpression t1 = term();
<i>1394</i>&nbsp;                    t = to(F.at(pos1).Indexed(t, t1));
<b class="nc"><i>1395</i>&nbsp;                }</b>
<b class="nc"><i>1396</i>&nbsp;                accept(RBRACKET);</b>
<b class="nc"><i>1397</i>&nbsp;            } else if (token.kind == DOT) {</b>
<i>1398</i>&nbsp;                nextToken();
<b class="nc"><i>1399</i>&nbsp;                typeArgs = typeArgumentsOpt(EXPR);</b>
<b class="nc"><i>1400</i>&nbsp;                if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {</b>
<b class="nc"><i>1401</i>&nbsp;                    mode = EXPR;</b>
<b class="nc"><i>1402</i>&nbsp;                    t = to(F.at(pos1).Select(t, names._super));</b>
<b class="nc"><i>1403</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>1404</i>&nbsp;                    t = arguments(typeArgs, t);</b>
<b class="nc"><i>1405</i>&nbsp;                    typeArgs = null;</b>
<b class="nc"><i>1406</i>&nbsp;                } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {</b>
<i>1407</i>&nbsp;                    if (typeArgs != null) return illegal();
<i>1408</i>&nbsp;                    mode = EXPR;
<i>1409</i>&nbsp;                    int pos2 = token.pos;
<i>1410</i>&nbsp;                    nextToken();
<i>1411</i>&nbsp;                    if (token.kind == LT) typeArgs = typeArguments(false);
<b class="nc"><i>1412</i>&nbsp;                    t = innerCreator(pos2, typeArgs, t);</b>
<b class="nc"><i>1413</i>&nbsp;                    typeArgs = null;</b>
<b class="nc"><i>1414</i>&nbsp;                } else {</b>
<i>1415</i>&nbsp;                    List&lt;JCAnnotation&gt; tyannos = null;
<i>1416</i>&nbsp;                    if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
<i>1417</i>&nbsp;                        // is the mode check needed?
<i>1418</i>&nbsp;                        tyannos = typeAnnotationsOpt();
<b class="nc"><i>1419</i>&nbsp;                    }</b>
<i>1420</i>&nbsp;                    t = toP(F.at(pos1).Select(t, ident(true)));
<b class="nc"><i>1421</i>&nbsp;                    if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {</b>
<i>1422</i>&nbsp;                        t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
<i>1423</i>&nbsp;                    }
<i>1424</i>&nbsp;                    t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
<b class="nc"><i>1425</i>&nbsp;                    typeArgs = null;</b>
<i>1426</i>&nbsp;                }
<b class="nc"><i>1427</i>&nbsp;            } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {</b>
<b class="nc"><i>1428</i>&nbsp;                mode = EXPR;</b>
<i>1429</i>&nbsp;                if (typeArgs != null) return illegal();
<b class="nc"><i>1430</i>&nbsp;                accept(COLCOL);</b>
<b class="nc"><i>1431</i>&nbsp;                t = memberReferenceSuffix(pos1, t);</b>
<b class="nc"><i>1432</i>&nbsp;            } else {</b>
<b class="nc"><i>1433</i>&nbsp;                if (!annos.isEmpty()) {</b>
<b class="nc"><i>1434</i>&nbsp;                    if (permitTypeAnnotationsPushBack)</b>
<b class="nc"><i>1435</i>&nbsp;                        typeAnnotationsPushedBack = annos;</b>
<b class="nc"><i>1436</i>&nbsp;                    else</b>
<b class="nc"><i>1437</i>&nbsp;                        return illegal(annos.head.pos);</b>
<b class="nc"><i>1438</i>&nbsp;                }</b>
<b class="nc"><i>1439</i>&nbsp;                break;</b>
<b class="nc"><i>1440</i>&nbsp;            }</b>
<b class="nc"><i>1441</i>&nbsp;        }</b>
<i>1442</i>&nbsp;        while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
<b class="nc"><i>1443</i>&nbsp;            mode = EXPR;</b>
<b class="nc"><i>1444</i>&nbsp;            t = to(F.at(token.pos).Unary(</b>
<i>1445</i>&nbsp;                  token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
<b class="nc"><i>1446</i>&nbsp;            nextToken();</b>
<i>1447</i>&nbsp;        }
<b class="nc"><i>1448</i>&nbsp;        return toP(t);</b>
<i>1449</i>&nbsp;    }
<b class="nc"><i>1450</i>&nbsp;</b>
<b class="nc"><i>1451</i>&nbsp;    /**</b>
<b class="nc"><i>1452</i>&nbsp;     * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound</b>
<b class="nc"><i>1453</i>&nbsp;     * method reference or a binary expression. To disambiguate, look for a</b>
<i>1454</i>&nbsp;     * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
<b class="nc"><i>1455</i>&nbsp;     */</b>
<b class="nc"><i>1456</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)</b>
<b class="nc"><i>1457</i>&nbsp;    boolean isUnboundMemberRef() {</b>
<b class="nc"><i>1458</i>&nbsp;        int pos = 0, depth = 0;</b>
<b class="nc"><i>1459</i>&nbsp;        outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {</b>
<b class="nc"><i>1460</i>&nbsp;            switch (t.kind) {</b>
<b class="nc"><i>1461</i>&nbsp;                case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:</b>
<b class="nc"><i>1462</i>&nbsp;                case DOT: case RBRACKET: case LBRACKET: case COMMA:</b>
<b class="nc"><i>1463</i>&nbsp;                case BYTE: case SHORT: case INT: case LONG: case FLOAT:</b>
<b class="nc"><i>1464</i>&nbsp;                case DOUBLE: case BOOLEAN: case CHAR:</b>
<b class="nc"><i>1465</i>&nbsp;                case MONKEYS_AT:</b>
<b class="nc"><i>1466</i>&nbsp;                    break;</b>
<b class="nc"><i>1467</i>&nbsp;</b>
<b class="nc"><i>1468</i>&nbsp;                case LPAREN:</b>
<b class="nc"><i>1469</i>&nbsp;                    // skip annotation values</b>
<b class="nc"><i>1470</i>&nbsp;                    int nesting = 0;</b>
<b class="nc"><i>1471</i>&nbsp;                    for (; ; pos++) {</b>
<b class="nc"><i>1472</i>&nbsp;                        TokenKind tk2 = S.token(pos).kind;</b>
<b class="nc"><i>1473</i>&nbsp;                        switch (tk2) {</b>
<b class="nc"><i>1474</i>&nbsp;                            case EOF:</b>
<b class="nc"><i>1475</i>&nbsp;                                return false;</b>
<i>1476</i>&nbsp;                            case LPAREN:
<b class="nc"><i>1477</i>&nbsp;                                nesting++;</b>
<i>1478</i>&nbsp;                                break;
<b class="nc"><i>1479</i>&nbsp;                            case RPAREN:</b>
<b class="nc"><i>1480</i>&nbsp;                                nesting--;</b>
<b class="nc"><i>1481</i>&nbsp;                                if (nesting == 0) {</b>
<i>1482</i>&nbsp;                                    continue outer;
<b class="nc"><i>1483</i>&nbsp;                                }</b>
<b class="nc"><i>1484</i>&nbsp;                                break;</b>
<b class="nc"><i>1485</i>&nbsp;                        }</b>
<b class="nc"><i>1486</i>&nbsp;                    }</b>
<b class="nc"><i>1487</i>&nbsp;</b>
<b class="nc"><i>1488</i>&nbsp;                case LT:</b>
<b class="nc"><i>1489</i>&nbsp;                    depth++; break;</b>
<b class="nc"><i>1490</i>&nbsp;                case GTGTGT:</b>
<i>1491</i>&nbsp;                    depth--;
<b class="nc"><i>1492</i>&nbsp;                case GTGT:</b>
<b class="nc"><i>1493</i>&nbsp;                    depth--;</b>
<b class="nc"><i>1494</i>&nbsp;                case GT:</b>
<i>1495</i>&nbsp;                    depth--;
<b class="nc"><i>1496</i>&nbsp;                    if (depth == 0) {</b>
<i>1497</i>&nbsp;                        TokenKind nextKind = S.token(pos + 1).kind;
<i>1498</i>&nbsp;                        return
<i>1499</i>&nbsp;                            nextKind == TokenKind.DOT ||
<b class="nc"><i>1500</i>&nbsp;                            nextKind == TokenKind.LBRACKET ||</b>
<b class="nc"><i>1501</i>&nbsp;                            nextKind == TokenKind.COLCOL;</b>
<b class="nc"><i>1502</i>&nbsp;                    }</b>
<b class="nc"><i>1503</i>&nbsp;                    break;</b>
<i>1504</i>&nbsp;                default:
<b class="nc"><i>1505</i>&nbsp;                    return false;</b>
<i>1506</i>&nbsp;            }
<b class="nc"><i>1507</i>&nbsp;        }</b>
<i>1508</i>&nbsp;    }
<i>1509</i>&nbsp;
<i>1510</i>&nbsp;    /**
<i>1511</i>&nbsp;     * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
<i>1512</i>&nbsp;     * method reference or a binary expression. To disambiguate, look for a
<i>1513</i>&nbsp;     * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
<i>1514</i>&nbsp;     */
<i>1515</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)
<i>1516</i>&nbsp;    ParensResult analyzeParens() {
<b class="nc"><i>1517</i>&nbsp;        int depth = 0;</b>
<b class="nc"><i>1518</i>&nbsp;        boolean type = false;</b>
<b class="nc"><i>1519</i>&nbsp;        outer: for (int lookahead = 0 ; ; lookahead++) {</b>
<i>1520</i>&nbsp;            TokenKind tk = S.token(lookahead).kind;
<i>1521</i>&nbsp;            switch (tk) {
<i>1522</i>&nbsp;                case COMMA:
<i>1523</i>&nbsp;                    type = true;
<i>1524</i>&nbsp;                case EXTENDS: case SUPER: case DOT: case AMP:
<b class="nc"><i>1525</i>&nbsp;                    //skip</b>
<i>1526</i>&nbsp;                    break;
<i>1527</i>&nbsp;                case QUES:
<i>1528</i>&nbsp;                    if (peekToken(lookahead, EXTENDS) ||
<b class="nc"><i>1529</i>&nbsp;                            peekToken(lookahead, SUPER)) {</b>
<b class="nc"><i>1530</i>&nbsp;                        //wildcards</b>
<b class="nc"><i>1531</i>&nbsp;                        type = true;</b>
<b class="nc"><i>1532</i>&nbsp;                    }</b>
<i>1533</i>&nbsp;                    break;
<b class="nc"><i>1534</i>&nbsp;                case BYTE: case SHORT: case INT: case LONG: case FLOAT:</b>
<i>1535</i>&nbsp;                case DOUBLE: case BOOLEAN: case CHAR: case VOID:
<b class="nc"><i>1536</i>&nbsp;                    if (peekToken(lookahead, RPAREN)) {</b>
<b class="nc"><i>1537</i>&nbsp;                        //Type, &#39;)&#39; -&gt; cast</b>
<i>1538</i>&nbsp;                        return ParensResult.CAST;
<b class="nc"><i>1539</i>&nbsp;                    } else if (peekToken(lookahead, LAX_IDENTIFIER)) {</b>
<b class="nc"><i>1540</i>&nbsp;                        //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</b>
<b class="nc"><i>1541</i>&nbsp;                        return ParensResult.EXPLICIT_LAMBDA;</b>
<i>1542</i>&nbsp;                    }
<i>1543</i>&nbsp;                    break;
<i>1544</i>&nbsp;                case LPAREN:
<i>1545</i>&nbsp;                    if (lookahead != 0) {
<i>1546</i>&nbsp;                        // &#39;(&#39; in a non-starting position -&gt; parens
<i>1547</i>&nbsp;                        return ParensResult.PARENS;
<b class="nc"><i>1548</i>&nbsp;                    } else if (peekToken(lookahead, RPAREN)) {</b>
<i>1549</i>&nbsp;                        // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
<b class="nc"><i>1550</i>&nbsp;                        return ParensResult.EXPLICIT_LAMBDA;</b>
<i>1551</i>&nbsp;                    }
<b class="nc"><i>1552</i>&nbsp;                    break;</b>
<i>1553</i>&nbsp;                case RPAREN:
<b class="nc"><i>1554</i>&nbsp;                    // if we have seen something that looks like a type,</b>
<b class="nc"><i>1555</i>&nbsp;                    // then it&#39;s a cast expression</b>
<b class="nc"><i>1556</i>&nbsp;                    if (type) return ParensResult.CAST;</b>
<b class="nc"><i>1557</i>&nbsp;                    // otherwise, disambiguate cast vs. parenthesized expression</b>
<i>1558</i>&nbsp;                    // based on subsequent token.
<i>1559</i>&nbsp;                    switch (S.token(lookahead + 1).kind) {
<i>1560</i>&nbsp;                        /*case PLUSPLUS: case SUBSUB: */
<i>1561</i>&nbsp;                        case BANG: case TILDE:
<i>1562</i>&nbsp;                        case LPAREN: case THIS: case SUPER:
<i>1563</i>&nbsp;                        case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
<b class="nc"><i>1564</i>&nbsp;                        case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:</b>
<i>1565</i>&nbsp;                        case TRUE: case FALSE: case NULL:
<i>1566</i>&nbsp;                        case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
<i>1567</i>&nbsp;                        case BYTE: case SHORT: case CHAR: case INT:
<i>1568</i>&nbsp;                        case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
<i>1569</i>&nbsp;                            return ParensResult.CAST;
<i>1570</i>&nbsp;                        default:
<i>1571</i>&nbsp;                            return ParensResult.PARENS;
<i>1572</i>&nbsp;                    }
<i>1573</i>&nbsp;                case UNDERSCORE:
<i>1574</i>&nbsp;                case ASSERT:
<i>1575</i>&nbsp;                case ENUM:
<b class="nc"><i>1576</i>&nbsp;                case IDENTIFIER:</b>
<b class="nc"><i>1577</i>&nbsp;                    if (peekToken(lookahead, LAX_IDENTIFIER)) {</b>
<b class="nc"><i>1578</i>&nbsp;                        // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda</b>
<b class="nc"><i>1579</i>&nbsp;                        return ParensResult.EXPLICIT_LAMBDA;</b>
<b class="nc"><i>1580</i>&nbsp;                    } else if (peekToken(lookahead, RPAREN, ARROW)) {</b>
<i>1581</i>&nbsp;                        // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
<b class="nc"><i>1582</i>&nbsp;                        return ParensResult.IMPLICIT_LAMBDA;</b>
<i>1583</i>&nbsp;                    }
<i>1584</i>&nbsp;                    type = false;
<b class="nc"><i>1585</i>&nbsp;                    break;</b>
<i>1586</i>&nbsp;                case FINAL:
<b class="nc"><i>1587</i>&nbsp;                case ELLIPSIS:</b>
<b class="nc"><i>1588</i>&nbsp;                    //those can only appear in explicit lambdas</b>
<i>1589</i>&nbsp;                    return ParensResult.EXPLICIT_LAMBDA;
<b class="nc"><i>1590</i>&nbsp;                case MONKEYS_AT:</b>
<i>1591</i>&nbsp;                    type = true;
<i>1592</i>&nbsp;                    lookahead += 1; //skip &#39;@&#39;
<i>1593</i>&nbsp;                    while (peekToken(lookahead, DOT)) {
<i>1594</i>&nbsp;                        lookahead += 2;
<b class="nc"><i>1595</i>&nbsp;                    }</b>
<i>1596</i>&nbsp;                    if (peekToken(lookahead, LPAREN)) {
<b class="nc"><i>1597</i>&nbsp;                        lookahead++;</b>
<b class="nc"><i>1598</i>&nbsp;                        //skip annotation values</b>
<i>1599</i>&nbsp;                        int nesting = 0;
<b class="nc"><i>1600</i>&nbsp;                        for (; ; lookahead++) {</b>
<i>1601</i>&nbsp;                            TokenKind tk2 = S.token(lookahead).kind;
<i>1602</i>&nbsp;                            switch (tk2) {
<i>1603</i>&nbsp;                                case EOF:
<b class="nc"><i>1604</i>&nbsp;                                    return ParensResult.PARENS;</b>
<i>1605</i>&nbsp;                                case LPAREN:
<b class="nc"><i>1606</i>&nbsp;                                    nesting++;</b>
<b class="nc"><i>1607</i>&nbsp;                                    break;</b>
<i>1608</i>&nbsp;                                case RPAREN:
<b class="nc"><i>1609</i>&nbsp;                                    nesting--;</b>
<i>1610</i>&nbsp;                                    if (nesting == 0) {
<i>1611</i>&nbsp;                                        continue outer;
<i>1612</i>&nbsp;                                    }
<i>1613</i>&nbsp;                                break;
<i>1614</i>&nbsp;                            }
<b class="nc"><i>1615</i>&nbsp;                        }</b>
<i>1616</i>&nbsp;                    }
<i>1617</i>&nbsp;                    break;
<b class="nc"><i>1618</i>&nbsp;                case LBRACKET:</b>
<i>1619</i>&nbsp;                    if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
<i>1620</i>&nbsp;                        // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
<i>1621</i>&nbsp;                        return ParensResult.EXPLICIT_LAMBDA;
<i>1622</i>&nbsp;                    } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
<i>1623</i>&nbsp;                            peekToken(lookahead, RBRACKET, AMP)) {
<i>1624</i>&nbsp;                        // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
<i>1625</i>&nbsp;                        // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
<i>1626</i>&nbsp;                        return ParensResult.CAST;
<i>1627</i>&nbsp;                    } else if (peekToken(lookahead, RBRACKET)) {
<b class="nc"><i>1628</i>&nbsp;                        //consume the &#39;]&#39; and skip</b>
<i>1629</i>&nbsp;                        type = true;
<b class="nc"><i>1630</i>&nbsp;                        lookahead++;</b>
<i>1631</i>&nbsp;                        break;
<i>1632</i>&nbsp;                    } else {
<i>1633</i>&nbsp;                        return ParensResult.PARENS;
<i>1634</i>&nbsp;                    }
<i>1635</i>&nbsp;                case LT:
<b class="nc"><i>1636</i>&nbsp;                    depth++; break;</b>
<i>1637</i>&nbsp;                case GTGTGT:
<b class="nc"><i>1638</i>&nbsp;                    depth--;</b>
<b class="nc"><i>1639</i>&nbsp;                case GTGT:</b>
<i>1640</i>&nbsp;                    depth--;
<b class="nc"><i>1641</i>&nbsp;                case GT:</b>
<i>1642</i>&nbsp;                    depth--;
<b class="nc"><i>1643</i>&nbsp;                    if (depth == 0) {</b>
<b class="nc"><i>1644</i>&nbsp;                        if (peekToken(lookahead, RPAREN) ||</b>
<i>1645</i>&nbsp;                                peekToken(lookahead, AMP)) {
<i>1646</i>&nbsp;                            // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
<i>1647</i>&nbsp;                            // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
<b class="nc"><i>1648</i>&nbsp;                            return ParensResult.CAST;</b>
<i>1649</i>&nbsp;                        } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
<b class="nc"><i>1650</i>&nbsp;                                peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||</b>
<b class="nc"><i>1651</i>&nbsp;                                peekToken(lookahead, ELLIPSIS)) {</b>
<b class="nc"><i>1652</i>&nbsp;                            // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda</b>
<b class="nc"><i>1653</i>&nbsp;                            // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda</b>
<i>1654</i>&nbsp;                            // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
<b class="nc"><i>1655</i>&nbsp;                            return ParensResult.EXPLICIT_LAMBDA;</b>
<b class="nc"><i>1656</i>&nbsp;                        }</b>
<i>1657</i>&nbsp;                        //it looks a type, but could still be (i) a cast to generic type,
<b class="nc"><i>1658</i>&nbsp;                        //(ii) an unbound method reference or (iii) an explicit lambda</b>
<b class="nc"><i>1659</i>&nbsp;                        type = true;</b>
<b class="nc"><i>1660</i>&nbsp;                        break;</b>
<b class="nc"><i>1661</i>&nbsp;                    } else if (depth &lt; 0) {</b>
<i>1662</i>&nbsp;                        //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
<b class="nc"><i>1663</i>&nbsp;                        return ParensResult.PARENS;</b>
<i>1664</i>&nbsp;                    }
<b class="nc"><i>1665</i>&nbsp;                    break;</b>
<b class="nc"><i>1666</i>&nbsp;                default:</b>
<i>1667</i>&nbsp;                    //this includes EOF
<b class="nc"><i>1668</i>&nbsp;                    return ParensResult.PARENS;</b>
<b class="nc"><i>1669</i>&nbsp;            }</b>
<b class="nc"><i>1670</i>&nbsp;        }</b>
<i>1671</i>&nbsp;    }
<i>1672</i>&nbsp;
<i>1673</i>&nbsp;    /** Accepts all identifier-like tokens */
<i>1674</i>&nbsp;    protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
<i>1675</i>&nbsp;
<i>1676</i>&nbsp;    enum ParensResult {
<i>1677</i>&nbsp;        CAST,
<b class="nc"><i>1678</i>&nbsp;        EXPLICIT_LAMBDA,</b>
<i>1679</i>&nbsp;        IMPLICIT_LAMBDA,
<b class="nc"><i>1680</i>&nbsp;        PARENS</b>
<b class="nc"><i>1681</i>&nbsp;    }</b>
<b class="nc"><i>1682</i>&nbsp;</b>
<i>1683</i>&nbsp;    JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
<i>1684</i>&nbsp;        List&lt;JCVariableDecl&gt; params = explicitParams ?
<b class="nc"><i>1685</i>&nbsp;                formalParameters(true) :</b>
<b class="nc"><i>1686</i>&nbsp;                implicitParameters(hasParens);</b>
<i>1687</i>&nbsp;        if (explicitParams) {
<b class="nc"><i>1688</i>&nbsp;            LambdaClassifier lambdaClassifier = new LambdaClassifier();</b>
<b class="nc"><i>1689</i>&nbsp;            for (JCVariableDecl param: params) {</b>
<b class="nc"><i>1690</i>&nbsp;                if (param.vartype != null &amp;&amp;</b>
<i>1691</i>&nbsp;                        isRestrictedLocalVarTypeName(param.vartype, false) &amp;&amp;
<b class="nc"><i>1692</i>&nbsp;                        param.vartype.hasTag(TYPEARRAY)) {</b>
<i>1693</i>&nbsp;                    log.error(DiagnosticFlag.SYNTAX, param.pos, Errors.VarNotAllowedArray);
<i>1694</i>&nbsp;                }
<b class="nc"><i>1695</i>&nbsp;                lambdaClassifier.addParameter(param);</b>
<i>1696</i>&nbsp;                if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
<b class="nc"><i>1697</i>&nbsp;                    break;</b>
<i>1698</i>&nbsp;                }
<b class="nc"><i>1699</i>&nbsp;            }</b>
<i>1700</i>&nbsp;            if (lambdaClassifier.diagFragment != null) {
<b class="nc"><i>1701</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));</b>
<b class="nc"><i>1702</i>&nbsp;            }</b>
<b class="nc"><i>1703</i>&nbsp;            for (JCVariableDecl param: params) {</b>
<b class="nc"><i>1704</i>&nbsp;                if (param.vartype != null &amp;&amp; isRestrictedLocalVarTypeName(param.vartype, true)) {</b>
<i>1705</i>&nbsp;                    param.startPos = TreeInfo.getStartPos(param.vartype);
<i>1706</i>&nbsp;                    param.vartype = null;
<b class="nc"><i>1707</i>&nbsp;                }</b>
<b class="nc"><i>1708</i>&nbsp;            }</b>
<b class="nc"><i>1709</i>&nbsp;        }</b>
<b class="nc"><i>1710</i>&nbsp;        return lambdaExpressionOrStatementRest(params, pos);</b>
<i>1711</i>&nbsp;    }
<i>1712</i>&nbsp;
<i>1713</i>&nbsp;    enum LambdaParameterKind {
<b class="nc"><i>1714</i>&nbsp;        EXPLICIT(0),</b>
<i>1715</i>&nbsp;        IMPLICIT(1),
<i>1716</i>&nbsp;        VAR(2),
<i>1717</i>&nbsp;        ERROR(-1);
<b class="nc"><i>1718</i>&nbsp;</b>
<b class="nc"><i>1719</i>&nbsp;        private final int index;</b>
<b class="nc"><i>1720</i>&nbsp;</b>
<i>1721</i>&nbsp;        LambdaParameterKind(int index) {
<b class="nc"><i>1722</i>&nbsp;            this.index = index;</b>
<i>1723</i>&nbsp;        }
<i>1724</i>&nbsp;    }
<i>1725</i>&nbsp;
<i>1726</i>&nbsp;    private final static Fragment[][] decisionTable = new Fragment[][]{
<b class="nc"><i>1727</i>&nbsp;        /*              EXPLICIT                         IMPLICIT                         VAR  */</b>
<i>1728</i>&nbsp;        /* EXPLICIT */ {null,                            ImplicitAndExplicitNotAllowed,   VarAndExplicitNotAllowed},
<i>1729</i>&nbsp;        /* IMPLICIT */ {ImplicitAndExplicitNotAllowed,   null,                            VarAndImplicitNotAllowed},
<i>1730</i>&nbsp;        /* VAR      */ {VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed,        null}
<i>1731</i>&nbsp;    };
<i>1732</i>&nbsp;
<b class="nc"><i>1733</i>&nbsp;    class LambdaClassifier {</b>
<i>1734</i>&nbsp;
<b class="nc"><i>1735</i>&nbsp;        LambdaParameterKind kind;</b>
<i>1736</i>&nbsp;        Fragment diagFragment;
<i>1737</i>&nbsp;        List&lt;JCVariableDecl&gt; params;
<i>1738</i>&nbsp;
<b class="nc"><i>1739</i>&nbsp;        void addParameter(JCVariableDecl param) {</b>
<b class="nc"><i>1740</i>&nbsp;            if (param.vartype != null &amp;&amp; param.name != names.empty) {</b>
<b class="nc"><i>1741</i>&nbsp;                if (isRestrictedLocalVarTypeName(param.vartype, false)) {</b>
<b class="nc"><i>1742</i>&nbsp;                    reduce(LambdaParameterKind.VAR);</b>
<b class="nc"><i>1743</i>&nbsp;                } else {</b>
<i>1744</i>&nbsp;                    reduce(LambdaParameterKind.EXPLICIT);
<i>1745</i>&nbsp;                }
<i>1746</i>&nbsp;            }
<b class="nc"><i>1747</i>&nbsp;            if (param.vartype == null &amp;&amp; param.name != names.empty ||</b>
<b class="nc"><i>1748</i>&nbsp;                param.vartype != null &amp;&amp; param.name == names.empty) {</b>
<b class="nc"><i>1749</i>&nbsp;                reduce(LambdaParameterKind.IMPLICIT);</b>
<i>1750</i>&nbsp;            }
<b class="nc"><i>1751</i>&nbsp;        }</b>
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;        private void reduce(LambdaParameterKind newKind) {
<i>1754</i>&nbsp;            if (kind == null) {
<b class="nc"><i>1755</i>&nbsp;                kind = newKind;</b>
<b class="nc"><i>1756</i>&nbsp;            } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {</b>
<i>1757</i>&nbsp;                LambdaParameterKind currentKind = kind;
<b class="nc"><i>1758</i>&nbsp;                kind = LambdaParameterKind.ERROR;</b>
<b class="nc"><i>1759</i>&nbsp;                diagFragment = decisionTable[currentKind.index][newKind.index];</b>
<b class="nc"><i>1760</i>&nbsp;            }</b>
<i>1761</i>&nbsp;        }
<i>1762</i>&nbsp;
<i>1763</i>&nbsp;        LambdaParameterKind result() {
<b class="nc"><i>1764</i>&nbsp;            return kind;</b>
<b class="nc"><i>1765</i>&nbsp;        }</b>
<i>1766</i>&nbsp;    }
<i>1767</i>&nbsp;
<i>1768</i>&nbsp;    JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
<b class="nc"><i>1769</i>&nbsp;        checkSourceLevel(Feature.LAMBDA);</b>
<b class="nc"><i>1770</i>&nbsp;        accept(ARROW);</b>
<i>1771</i>&nbsp;
<i>1772</i>&nbsp;        return token.kind == LBRACE ?
<i>1773</i>&nbsp;            lambdaStatement(args, pos, token.pos) :
<i>1774</i>&nbsp;            lambdaExpression(args, pos);
<i>1775</i>&nbsp;    }
<b class="nc"><i>1776</i>&nbsp;</b>
<b class="nc"><i>1777</i>&nbsp;    JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {</b>
<b class="nc"><i>1778</i>&nbsp;        JCBlock block = block(pos2, 0);</b>
<b class="nc"><i>1779</i>&nbsp;        return toP(F.at(pos).Lambda(args, block));</b>
<b class="nc"><i>1780</i>&nbsp;    }</b>
<b class="nc"><i>1781</i>&nbsp;</b>
<i>1782</i>&nbsp;    JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
<b class="nc"><i>1783</i>&nbsp;        JCTree expr = parseExpression();</b>
<b class="nc"><i>1784</i>&nbsp;        return toP(F.at(pos).Lambda(args, expr));</b>
<b class="nc"><i>1785</i>&nbsp;    }</b>
<b class="nc"><i>1786</i>&nbsp;</b>
<b class="nc"><i>1787</i>&nbsp;    /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]</b>
<i>1788</i>&nbsp;     */
<b class="nc"><i>1789</i>&nbsp;    JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</b>
<i>1790</i>&nbsp;        nextToken();
<i>1791</i>&nbsp;        if (token.kind == LPAREN || typeArgs != null) {
<i>1792</i>&nbsp;            t = arguments(typeArgs, t);
<i>1793</i>&nbsp;        } else if (token.kind == COLCOL) {
<i>1794</i>&nbsp;            if (typeArgs != null) return illegal();
<b class="nc"><i>1795</i>&nbsp;            t = memberReferenceSuffix(t);</b>
<b class="nc"><i>1796</i>&nbsp;        } else {</b>
<b class="nc"><i>1797</i>&nbsp;            int pos = token.pos;</b>
<i>1798</i>&nbsp;            accept(DOT);
<i>1799</i>&nbsp;            typeArgs = (token.kind == LT) ? typeArguments(false) : null;
<i>1800</i>&nbsp;            t = toP(F.at(pos).Select(t, ident()));
<i>1801</i>&nbsp;            t = argumentsOpt(typeArgs, t);
<i>1802</i>&nbsp;        }
<b class="nc"><i>1803</i>&nbsp;        return t;</b>
<b class="nc"><i>1804</i>&nbsp;    }</b>
<b class="nc"><i>1805</i>&nbsp;</b>
<i>1806</i>&nbsp;    /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
<b class="nc"><i>1807</i>&nbsp;     */</b>
<i>1808</i>&nbsp;    JCPrimitiveTypeTree basicType() {
<i>1809</i>&nbsp;        JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
<i>1810</i>&nbsp;        nextToken();
<i>1811</i>&nbsp;        return t;
<i>1812</i>&nbsp;    }
<i>1813</i>&nbsp;
<b class="nc"><i>1814</i>&nbsp;    /** ArgumentsOpt = [ Arguments ]</b>
<b class="nc"><i>1815</i>&nbsp;     */</b>
<b class="nc"><i>1816</i>&nbsp;    JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</b>
<b class="nc"><i>1817</i>&nbsp;        if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {</b>
<b class="nc"><i>1818</i>&nbsp;            mode = EXPR;</b>
<b class="nc"><i>1819</i>&nbsp;            return arguments(typeArgs, t);</b>
<b class="nc"><i>1820</i>&nbsp;        } else {</b>
<b class="nc"><i>1821</i>&nbsp;            return t;</b>
<i>1822</i>&nbsp;        }
<i>1823</i>&nbsp;    }
<b class="nc"><i>1824</i>&nbsp;</b>
<i>1825</i>&nbsp;    /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
<b class="nc"><i>1826</i>&nbsp;     */</b>
<i>1827</i>&nbsp;    List&lt;JCExpression&gt; arguments() {
<b class="nc"><i>1828</i>&nbsp;        ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();</b>
<i>1829</i>&nbsp;        if (token.kind == LPAREN) {
<i>1830</i>&nbsp;            nextToken();
<i>1831</i>&nbsp;            if (token.kind != RPAREN) {
<b class="nc"><i>1832</i>&nbsp;                args.append(parseExpression());</b>
<b class="nc"><i>1833</i>&nbsp;                while (token.kind == COMMA) {</b>
<b class="nc"><i>1834</i>&nbsp;                    nextToken();</b>
<i>1835</i>&nbsp;                    args.append(parseExpression());
<i>1836</i>&nbsp;                }
<i>1837</i>&nbsp;            }
<i>1838</i>&nbsp;            accept(RPAREN);
<i>1839</i>&nbsp;        } else {
<b class="nc"><i>1840</i>&nbsp;            syntaxError(token.pos, Errors.Expected(LPAREN));</b>
<i>1841</i>&nbsp;        }
<i>1842</i>&nbsp;        return args.toList();
<b class="nc"><i>1843</i>&nbsp;    }</b>
<b class="nc"><i>1844</i>&nbsp;</b>
<b class="nc"><i>1845</i>&nbsp;    JCMethodInvocation arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</b>
<i>1846</i>&nbsp;        int pos = token.pos;
<b class="nc"><i>1847</i>&nbsp;        List&lt;JCExpression&gt; args = arguments();</b>
<i>1848</i>&nbsp;        return toP(F.at(pos).Apply(typeArgs, t, args));
<i>1849</i>&nbsp;    }
<i>1850</i>&nbsp;
<b class="nc"><i>1851</i>&nbsp;    /**  TypeArgumentsOpt = [ TypeArguments ]</b>
<i>1852</i>&nbsp;     */
<i>1853</i>&nbsp;    JCExpression typeArgumentsOpt(JCExpression t) {
<i>1854</i>&nbsp;        if (token.kind == LT &amp;&amp;
<b class="nc"><i>1855</i>&nbsp;            (mode &amp; TYPE) != 0 &amp;&amp;</b>
<b class="nc"><i>1856</i>&nbsp;            (mode &amp; NOPARAMS) == 0) {</b>
<b class="nc"><i>1857</i>&nbsp;            mode = TYPE;</b>
<i>1858</i>&nbsp;            return typeArguments(t, false);
<b class="nc"><i>1859</i>&nbsp;        } else {</b>
<i>1860</i>&nbsp;            return t;
<b class="nc"><i>1861</i>&nbsp;        }</b>
<b class="nc"><i>1862</i>&nbsp;    }</b>
<i>1863</i>&nbsp;    List&lt;JCExpression&gt; typeArgumentsOpt() {
<b class="nc"><i>1864</i>&nbsp;        return typeArgumentsOpt(TYPE);</b>
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
<i>1868</i>&nbsp;        if (token.kind == LT) {
<i>1869</i>&nbsp;            if ((mode &amp; useMode) == 0 ||
<i>1870</i>&nbsp;                (mode &amp; NOPARAMS) != 0) {
<i>1871</i>&nbsp;                illegal();
<i>1872</i>&nbsp;            }
<b class="nc"><i>1873</i>&nbsp;            mode = useMode;</b>
<b class="nc"><i>1874</i>&nbsp;            return typeArguments(false);</b>
<b class="nc"><i>1875</i>&nbsp;        }</b>
<b class="nc"><i>1876</i>&nbsp;        return null;</b>
<b class="nc"><i>1877</i>&nbsp;    }</b>
<b class="nc"><i>1878</i>&nbsp;</b>
<b class="nc"><i>1879</i>&nbsp;    /**</b>
<i>1880</i>&nbsp;     *  {@literal
<b class="nc"><i>1881</i>&nbsp;     *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;</b>
<b class="nc"><i>1882</i>&nbsp;     *  }</b>
<b class="nc"><i>1883</i>&nbsp;     */</b>
<b class="nc"><i>1884</i>&nbsp;    List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {</b>
<b class="nc"><i>1885</i>&nbsp;        if (token.kind == LT) {</b>
<i>1886</i>&nbsp;            nextToken();
<b class="nc"><i>1887</i>&nbsp;            if (token.kind == GT &amp;&amp; diamondAllowed) {</b>
<i>1888</i>&nbsp;                checkSourceLevel(Feature.DIAMOND);
<i>1889</i>&nbsp;                mode |= DIAMOND;
<i>1890</i>&nbsp;                nextToken();
<b class="nc"><i>1891</i>&nbsp;                return List.nil();</b>
<b class="nc"><i>1892</i>&nbsp;            } else {</b>
<i>1893</i>&nbsp;                ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
<b class="nc"><i>1894</i>&nbsp;                args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());</b>
<b class="nc"><i>1895</i>&nbsp;                while (token.kind == COMMA) {</b>
<i>1896</i>&nbsp;                    nextToken();
<b class="nc"><i>1897</i>&nbsp;                    args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());</b>
<i>1898</i>&nbsp;                }
<i>1899</i>&nbsp;                switch (token.kind) {
<b class="nc"><i>1900</i>&nbsp;</b>
<i>1901</i>&nbsp;                case GTGTGTEQ: case GTGTEQ: case GTEQ:
<i>1902</i>&nbsp;                case GTGTGT: case GTGT:
<b class="nc"><i>1903</i>&nbsp;                    token = S.split();</b>
<i>1904</i>&nbsp;                    break;
<i>1905</i>&nbsp;                case GT:
<i>1906</i>&nbsp;                    nextToken();
<i>1907</i>&nbsp;                    break;
<i>1908</i>&nbsp;                default:
<i>1909</i>&nbsp;                    args.append(syntaxError(token.pos, Errors.Expected(GT)));
<i>1910</i>&nbsp;                    break;
<i>1911</i>&nbsp;                }
<i>1912</i>&nbsp;                return args.toList();
<i>1913</i>&nbsp;            }
<i>1914</i>&nbsp;        } else {
<i>1915</i>&nbsp;            return List.of(syntaxError(token.pos, Errors.Expected(LT)));
<b class="nc"><i>1916</i>&nbsp;        }</b>
<b class="nc"><i>1917</i>&nbsp;    }</b>
<b class="nc"><i>1918</i>&nbsp;</b>
<b class="nc"><i>1919</i>&nbsp;    /**</b>
<i>1920</i>&nbsp;     *  {@literal
<b class="nc"><i>1921</i>&nbsp;     *  TypeArgument = Type</b>
<b class="nc"><i>1922</i>&nbsp;     *               | [Annotations] &quot;?&quot;</b>
<b class="nc"><i>1923</i>&nbsp;     *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}</b>
<b class="nc"><i>1924</i>&nbsp;     *               | [Annotations] &quot;?&quot; SUPER Type</b>
<b class="nc"><i>1925</i>&nbsp;     *  }</b>
<b class="nc"><i>1926</i>&nbsp;     */</b>
<b class="nc"><i>1927</i>&nbsp;    JCExpression typeArgument() {</b>
<b class="nc"><i>1928</i>&nbsp;        List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();</b>
<b class="nc"><i>1929</i>&nbsp;        if (token.kind != QUES) return parseType(false, annotations);</b>
<b class="nc"><i>1930</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>1931</i>&nbsp;        nextToken();</b>
<i>1932</i>&nbsp;        JCExpression result;
<b class="nc"><i>1933</i>&nbsp;        if (token.kind == EXTENDS) {</b>
<b class="nc"><i>1934</i>&nbsp;            TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));</b>
<b class="nc"><i>1935</i>&nbsp;            nextToken();</b>
<b class="nc"><i>1936</i>&nbsp;            JCExpression bound = parseType();</b>
<b class="nc"><i>1937</i>&nbsp;            result = F.at(pos).Wildcard(t, bound);</b>
<b class="nc"><i>1938</i>&nbsp;        } else if (token.kind == SUPER) {</b>
<b class="nc"><i>1939</i>&nbsp;            TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));</b>
<b class="nc"><i>1940</i>&nbsp;            nextToken();</b>
<b class="nc"><i>1941</i>&nbsp;            JCExpression bound = parseType();</b>
<i>1942</i>&nbsp;            result = F.at(pos).Wildcard(t, bound);
<b class="nc"><i>1943</i>&nbsp;        } else if (LAX_IDENTIFIER.accepts(token.kind)) {</b>
<b class="nc"><i>1944</i>&nbsp;            //error recovery</b>
<i>1945</i>&nbsp;            TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
<b class="nc"><i>1946</i>&nbsp;            JCExpression wc = toP(F.at(pos).Wildcard(t, null));</b>
<i>1947</i>&nbsp;            JCIdent id = toP(F.at(token.pos).Ident(ident()));
<i>1948</i>&nbsp;            JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
<i>1949</i>&nbsp;            reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
<b class="nc"><i>1950</i>&nbsp;            result = err;</b>
<b class="nc"><i>1951</i>&nbsp;        } else {</b>
<b class="nc"><i>1952</i>&nbsp;            TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));</b>
<i>1953</i>&nbsp;            result = toP(F.at(pos).Wildcard(t, null));
<i>1954</i>&nbsp;        }
<i>1955</i>&nbsp;        if (!annotations.isEmpty()) {
<i>1956</i>&nbsp;            result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
<i>1957</i>&nbsp;        }
<i>1958</i>&nbsp;        return result;
<i>1959</i>&nbsp;    }
<i>1960</i>&nbsp;
<i>1961</i>&nbsp;    JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
<i>1962</i>&nbsp;        int pos = token.pos;
<i>1963</i>&nbsp;        List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
<i>1964</i>&nbsp;        return toP(F.at(pos).TypeApply(t, args));
<b class="nc"><i>1965</i>&nbsp;    }</b>
<i>1966</i>&nbsp;
<b class="nc"><i>1967</i>&nbsp;    /**</b>
<b class="nc"><i>1968</i>&nbsp;     * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*</b>
<b class="nc"><i>1969</i>&nbsp;     *</b>
<b class="nc"><i>1970</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1971</i>&nbsp;     *</b>
<b class="nc"><i>1972</i>&nbsp;     * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting</b>
<b class="nc"><i>1973</i>&nbsp;     * the expression &lt;code&gt;t&lt;/code&gt;.</b>
<i>1974</i>&nbsp;     */
<b class="nc"><i>1975</i>&nbsp;    private JCExpression bracketsOpt(JCExpression t,</b>
<i>1976</i>&nbsp;            List&lt;JCAnnotation&gt; annotations) {
<i>1977</i>&nbsp;        List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
<i>1978</i>&nbsp;
<b class="nc"><i>1979</i>&nbsp;        if (token.kind == LBRACKET) {</b>
<b class="nc"><i>1980</i>&nbsp;            int pos = token.pos;</b>
<i>1981</i>&nbsp;            nextToken();
<b class="nc"><i>1982</i>&nbsp;            t = bracketsOptCont(t, pos, nextLevelAnnotations);</b>
<i>1983</i>&nbsp;        } else if (!nextLevelAnnotations.isEmpty()) {
<i>1984</i>&nbsp;            if (permitTypeAnnotationsPushBack) {
<i>1985</i>&nbsp;                this.typeAnnotationsPushedBack = nextLevelAnnotations;
<i>1986</i>&nbsp;            } else {
<i>1987</i>&nbsp;                return illegal(nextLevelAnnotations.head.pos);
<b class="nc"><i>1988</i>&nbsp;            }</b>
<i>1989</i>&nbsp;        }
<i>1990</i>&nbsp;
<i>1991</i>&nbsp;        if (!annotations.isEmpty()) {
<i>1992</i>&nbsp;            t = toP(F.at(token.pos).AnnotatedType(annotations, t));
<b class="nc"><i>1993</i>&nbsp;        }</b>
<b class="nc"><i>1994</i>&nbsp;        return t;</b>
<b class="nc"><i>1995</i>&nbsp;    }</b>
<b class="nc"><i>1996</i>&nbsp;</b>
<b class="nc"><i>1997</i>&nbsp;    /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]</b>
<i>1998</i>&nbsp;     */
<b class="nc"><i>1999</i>&nbsp;    private JCExpression bracketsOpt(JCExpression t) {</b>
<i>2000</i>&nbsp;        return bracketsOpt(t, List.nil());
<i>2001</i>&nbsp;    }
<i>2002</i>&nbsp;
<i>2003</i>&nbsp;    private JCExpression bracketsOptCont(JCExpression t, int pos,
<i>2004</i>&nbsp;            List&lt;JCAnnotation&gt; annotations) {
<i>2005</i>&nbsp;        accept(RBRACKET);
<b class="nc"><i>2006</i>&nbsp;        t = bracketsOpt(t);</b>
<b class="nc"><i>2007</i>&nbsp;        t = toP(F.at(pos).TypeArray(t));</b>
<b class="nc"><i>2008</i>&nbsp;        if (annotations.nonEmpty()) {</b>
<b class="nc"><i>2009</i>&nbsp;            t = toP(F.at(pos).AnnotatedType(annotations, t));</b>
<b class="nc"><i>2010</i>&nbsp;        }</b>
<b class="nc"><i>2011</i>&nbsp;        return t;</b>
<i>2012</i>&nbsp;    }
<i>2013</i>&nbsp;
<b class="nc"><i>2014</i>&nbsp;    /** BracketsSuffixExpr = &quot;.&quot; CLASS</b>
<b class="nc"><i>2015</i>&nbsp;     *  BracketsSuffixType =</b>
<b class="nc"><i>2016</i>&nbsp;     */</b>
<i>2017</i>&nbsp;    JCExpression bracketsSuffix(JCExpression t) {
<b class="nc"><i>2018</i>&nbsp;        if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {</b>
<i>2019</i>&nbsp;            mode = EXPR;
<b class="nc"><i>2020</i>&nbsp;            int pos = token.pos;</b>
<b class="nc"><i>2021</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2022</i>&nbsp;            accept(CLASS);</b>
<i>2023</i>&nbsp;            if (token.pos == endPosTable.errorEndPos) {
<b class="nc"><i>2024</i>&nbsp;                // error recovery</b>
<b class="nc"><i>2025</i>&nbsp;                Name name;</b>
<b class="nc"><i>2026</i>&nbsp;                if (LAX_IDENTIFIER.accepts(token.kind)) {</b>
<i>2027</i>&nbsp;                    name = token.name();
<b class="nc"><i>2028</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>2029</i>&nbsp;                } else {</b>
<i>2030</i>&nbsp;                    name = names.error;
<b class="nc"><i>2031</i>&nbsp;                }</b>
<i>2032</i>&nbsp;                t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
<i>2033</i>&nbsp;            } else {
<i>2034</i>&nbsp;                Tag tag = t.getTag();
<i>2035</i>&nbsp;                // Type annotations are illegal on class literals. Annotated non array class literals
<i>2036</i>&nbsp;                // are complained about directly in term3(), Here check for type annotations on dimensions
<i>2037</i>&nbsp;                // taking care to handle some interior dimension(s) being annotated.
<i>2038</i>&nbsp;                if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
<b class="nc"><i>2039</i>&nbsp;                    syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);</b>
<b class="nc"><i>2040</i>&nbsp;                t = toP(F.at(pos).Select(t, names._class));</b>
<b class="nc"><i>2041</i>&nbsp;            }</b>
<i>2042</i>&nbsp;        } else if ((mode &amp; TYPE) != 0) {
<i>2043</i>&nbsp;            if (token.kind != COLCOL) {
<i>2044</i>&nbsp;                mode = TYPE;
<b class="nc"><i>2045</i>&nbsp;            }</b>
<b class="nc"><i>2046</i>&nbsp;        } else if (token.kind != COLCOL) {</b>
<b class="nc"><i>2047</i>&nbsp;            syntaxError(token.pos, Errors.DotClassExpected);</b>
<b class="nc"><i>2048</i>&nbsp;        }</b>
<b class="nc"><i>2049</i>&nbsp;        return t;</b>
<i>2050</i>&nbsp;    }
<i>2051</i>&nbsp;
<i>2052</i>&nbsp;    /**
<b class="nc"><i>2053</i>&nbsp;     * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident</b>
<b class="nc"><i>2054</i>&nbsp;     *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;</b>
<b class="nc"><i>2055</i>&nbsp;     */</b>
<b class="nc"><i>2056</i>&nbsp;    JCExpression memberReferenceSuffix(JCExpression t) {</b>
<i>2057</i>&nbsp;        int pos1 = token.pos;
<b class="nc"><i>2058</i>&nbsp;        accept(COLCOL);</b>
<b class="nc"><i>2059</i>&nbsp;        return memberReferenceSuffix(pos1, t);</b>
<i>2060</i>&nbsp;    }
<b class="nc"><i>2061</i>&nbsp;</b>
<i>2062</i>&nbsp;    JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
<i>2063</i>&nbsp;        checkSourceLevel(Feature.METHOD_REFERENCES);
<i>2064</i>&nbsp;        mode = EXPR;
<i>2065</i>&nbsp;        List&lt;JCExpression&gt; typeArgs = null;
<i>2066</i>&nbsp;        if (token.kind == LT) {
<b class="nc"><i>2067</i>&nbsp;            typeArgs = typeArguments(false);</b>
<i>2068</i>&nbsp;        }
<b class="nc"><i>2069</i>&nbsp;        Name refName;</b>
<i>2070</i>&nbsp;        ReferenceMode refMode;
<i>2071</i>&nbsp;        if (token.kind == NEW) {
<b class="nc"><i>2072</i>&nbsp;            refMode = ReferenceMode.NEW;</b>
<b class="nc"><i>2073</i>&nbsp;            refName = names.init;</b>
<b class="nc"><i>2074</i>&nbsp;            nextToken();</b>
<i>2075</i>&nbsp;        } else {
<b class="nc"><i>2076</i>&nbsp;            refMode = ReferenceMode.INVOKE;</b>
<i>2077</i>&nbsp;            refName = ident();
<i>2078</i>&nbsp;        }
<i>2079</i>&nbsp;        return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
<i>2080</i>&nbsp;    }
<i>2081</i>&nbsp;
<b class="nc"><i>2082</i>&nbsp;    /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )</b>
<i>2083</i>&nbsp;     */
<b class="nc"><i>2084</i>&nbsp;    JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {</b>
<b class="nc"><i>2085</i>&nbsp;        List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();</b>
<b class="nc"><i>2086</i>&nbsp;</b>
<b class="nc"><i>2087</i>&nbsp;        switch (token.kind) {</b>
<b class="nc"><i>2088</i>&nbsp;        case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:</b>
<b class="nc"><i>2089</i>&nbsp;        case DOUBLE: case BOOLEAN:</b>
<b class="nc"><i>2090</i>&nbsp;            if (typeArgs == null) {</b>
<b class="nc"><i>2091</i>&nbsp;                if (newAnnotations.isEmpty()) {</b>
<b class="nc"><i>2092</i>&nbsp;                    return arrayCreatorRest(newpos, basicType());</b>
<i>2093</i>&nbsp;                } else {
<b class="nc"><i>2094</i>&nbsp;                    return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));</b>
<b class="nc"><i>2095</i>&nbsp;                }</b>
<i>2096</i>&nbsp;            }
<b class="nc"><i>2097</i>&nbsp;            break;</b>
<i>2098</i>&nbsp;        default:
<b class="nc"><i>2099</i>&nbsp;        }</b>
<b class="nc"><i>2100</i>&nbsp;        JCExpression t = qualident(true);</b>
<b class="nc"><i>2101</i>&nbsp;</b>
<b class="nc"><i>2102</i>&nbsp;        int oldmode = mode;</b>
<i>2103</i>&nbsp;        mode = TYPE;
<b class="nc"><i>2104</i>&nbsp;        boolean diamondFound = false;</b>
<b class="nc"><i>2105</i>&nbsp;        int lastTypeargsPos = -1;</b>
<i>2106</i>&nbsp;        if (token.kind == LT) {
<i>2107</i>&nbsp;            lastTypeargsPos = token.pos;
<b class="nc"><i>2108</i>&nbsp;            t = typeArguments(t, true);</b>
<b class="nc"><i>2109</i>&nbsp;            diamondFound = (mode &amp; DIAMOND) != 0;</b>
<b class="nc"><i>2110</i>&nbsp;        }</b>
<b class="nc"><i>2111</i>&nbsp;        while (token.kind == DOT) {</b>
<b class="nc"><i>2112</i>&nbsp;            if (diamondFound) {</b>
<i>2113</i>&nbsp;                //cannot select after a diamond
<b class="nc"><i>2114</i>&nbsp;                illegal();</b>
<b class="nc"><i>2115</i>&nbsp;            }</b>
<b class="nc"><i>2116</i>&nbsp;            int pos = token.pos;</b>
<i>2117</i>&nbsp;            nextToken();
<b class="nc"><i>2118</i>&nbsp;            List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();</b>
<b class="nc"><i>2119</i>&nbsp;            t = toP(F.at(pos).Select(t, ident()));</b>
<i>2120</i>&nbsp;
<i>2121</i>&nbsp;            if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
<b class="nc"><i>2122</i>&nbsp;                t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));</b>
<b class="nc"><i>2123</i>&nbsp;            }</b>
<b class="nc"><i>2124</i>&nbsp;</b>
<b class="nc"><i>2125</i>&nbsp;            if (token.kind == LT) {</b>
<i>2126</i>&nbsp;                lastTypeargsPos = token.pos;
<b class="nc"><i>2127</i>&nbsp;                t = typeArguments(t, true);</b>
<b class="nc"><i>2128</i>&nbsp;                diamondFound = (mode &amp; DIAMOND) != 0;</b>
<b class="nc"><i>2129</i>&nbsp;            }</b>
<i>2130</i>&nbsp;        }
<i>2131</i>&nbsp;        mode = oldmode;
<i>2132</i>&nbsp;        if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
<b class="nc"><i>2133</i>&nbsp;            // handle type annotations for non primitive arrays</b>
<i>2134</i>&nbsp;            if (newAnnotations.nonEmpty()) {
<b class="nc"><i>2135</i>&nbsp;                t = insertAnnotationsToMostInner(t, newAnnotations, false);</b>
<b class="nc"><i>2136</i>&nbsp;            }</b>
<b class="nc"><i>2137</i>&nbsp;</b>
<b class="nc"><i>2138</i>&nbsp;            JCExpression e = arrayCreatorRest(newpos, t);</b>
<i>2139</i>&nbsp;            if (diamondFound) {
<b class="nc"><i>2140</i>&nbsp;                reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);</b>
<b class="nc"><i>2141</i>&nbsp;                return toP(F.at(newpos).Erroneous(List.of(e)));</b>
<b class="nc"><i>2142</i>&nbsp;            }</b>
<b class="nc"><i>2143</i>&nbsp;            else if (typeArgs != null) {</b>
<b class="nc"><i>2144</i>&nbsp;                int pos = newpos;</b>
<b class="nc"><i>2145</i>&nbsp;                if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {</b>
<i>2146</i>&nbsp;                    // note: this should always happen but we should
<i>2147</i>&nbsp;                    // not rely on this as the parser is continuously
<i>2148</i>&nbsp;                    // modified to improve error recovery.
<i>2149</i>&nbsp;                    pos = typeArgs.head.pos;
<b class="nc"><i>2150</i>&nbsp;                }</b>
<b class="nc"><i>2151</i>&nbsp;                setErrorEndPos(S.prevToken().endPos);</b>
<i>2152</i>&nbsp;                JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
<i>2153</i>&nbsp;                reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
<i>2154</i>&nbsp;                return toP(err);
<b class="nc"><i>2155</i>&nbsp;            }</b>
<b class="nc"><i>2156</i>&nbsp;            return e;</b>
<b class="nc"><i>2157</i>&nbsp;        } else if (token.kind == LPAREN) {</b>
<i>2158</i>&nbsp;            JCNewClass newClass = classCreatorRest(newpos, null, typeArgs, t);
<i>2159</i>&nbsp;            if (newClass.def != null) {
<b class="nc"><i>2160</i>&nbsp;                assert newClass.def.mods.annotations.isEmpty();</b>
<i>2161</i>&nbsp;                if (newAnnotations.nonEmpty()) {
<b class="nc"><i>2162</i>&nbsp;                    // Add type and declaration annotations to the new class;</b>
<b class="nc"><i>2163</i>&nbsp;                    // com.sun.tools.javac.code.TypeAnnotations.TypeAnnotationPositions.visitNewClass(JCNewClass)</b>
<b class="nc"><i>2164</i>&nbsp;                    // will later remove all type annotations and only leave the</b>
<b class="nc"><i>2165</i>&nbsp;                    // declaration annotations.</b>
<i>2166</i>&nbsp;                    newClass.def.mods.pos = earlier(newClass.def.mods.pos, newAnnotations.head.pos);
<i>2167</i>&nbsp;                    newClass.def.mods.annotations = newAnnotations;
<i>2168</i>&nbsp;                }
<i>2169</i>&nbsp;            } else {
<i>2170</i>&nbsp;                // handle type annotations for instantiations
<i>2171</i>&nbsp;                if (newAnnotations.nonEmpty()) {
<b class="nc"><i>2172</i>&nbsp;                    t = insertAnnotationsToMostInner(t, newAnnotations, false);</b>
<i>2173</i>&nbsp;                    newClass.clazz = t;
<b class="nc"><i>2174</i>&nbsp;                }</b>
<i>2175</i>&nbsp;            }
<b class="nc"><i>2176</i>&nbsp;            return newClass;</b>
<b class="nc"><i>2177</i>&nbsp;        } else {</b>
<i>2178</i>&nbsp;            setErrorEndPos(token.pos);
<i>2179</i>&nbsp;            reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
<b class="nc"><i>2180</i>&nbsp;            t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));</b>
<b class="nc"><i>2181</i>&nbsp;            return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));</b>
<b class="nc"><i>2182</i>&nbsp;        }</b>
<b class="nc"><i>2183</i>&nbsp;    }</b>
<b class="nc"><i>2184</i>&nbsp;</b>
<i>2185</i>&nbsp;    /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
<b class="nc"><i>2186</i>&nbsp;     */</b>
<i>2187</i>&nbsp;    JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
<i>2188</i>&nbsp;        List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
<i>2189</i>&nbsp;
<i>2190</i>&nbsp;        JCExpression t = toP(F.at(token.pos).Ident(ident()));
<i>2191</i>&nbsp;
<i>2192</i>&nbsp;        if (newAnnotations.nonEmpty()) {
<b class="nc"><i>2193</i>&nbsp;            t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));</b>
<i>2194</i>&nbsp;        }
<b class="nc"><i>2195</i>&nbsp;</b>
<b class="nc"><i>2196</i>&nbsp;        if (token.kind == LT) {</b>
<b class="nc"><i>2197</i>&nbsp;            int oldmode = mode;</b>
<b class="nc"><i>2198</i>&nbsp;            t = typeArguments(t, true);</b>
<b class="nc"><i>2199</i>&nbsp;            mode = oldmode;</b>
<b class="nc"><i>2200</i>&nbsp;        }</b>
<b class="nc"><i>2201</i>&nbsp;        return classCreatorRest(newpos, encl, typeArgs, t);</b>
<i>2202</i>&nbsp;    }
<i>2203</i>&nbsp;
<i>2204</i>&nbsp;    /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
<i>2205</i>&nbsp;     *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
<i>2206</i>&nbsp;     */
<i>2207</i>&nbsp;    JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
<b class="nc"><i>2208</i>&nbsp;        List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();</b>
<b class="nc"><i>2209</i>&nbsp;</b>
<b class="nc"><i>2210</i>&nbsp;        accept(LBRACKET);</b>
<b class="nc"><i>2211</i>&nbsp;        if (token.kind == RBRACKET) {</b>
<i>2212</i>&nbsp;            accept(RBRACKET);
<b class="nc"><i>2213</i>&nbsp;            elemtype = bracketsOpt(elemtype, annos);</b>
<i>2214</i>&nbsp;            if (token.kind == LBRACE) {
<b class="nc"><i>2215</i>&nbsp;                JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);</b>
<b class="nc"><i>2216</i>&nbsp;                if (annos.nonEmpty()) {</b>
<i>2217</i>&nbsp;                    // when an array initializer is present then
<i>2218</i>&nbsp;                    // the parsed annotations should target the
<b class="nc"><i>2219</i>&nbsp;                    // new array tree</b>
<i>2220</i>&nbsp;                    // bracketsOpt inserts the annotation in
<i>2221</i>&nbsp;                    // elemtype, and it needs to be corrected
<b class="nc"><i>2222</i>&nbsp;                    //</b>
<b class="nc"><i>2223</i>&nbsp;                    JCAnnotatedType annotated = (JCAnnotatedType)elemtype;</b>
<i>2224</i>&nbsp;                    assert annotated.annotations == annos;
<b class="nc"><i>2225</i>&nbsp;                    na.annotations = annotated.annotations;</b>
<b class="nc"><i>2226</i>&nbsp;                    na.elemtype = annotated.underlyingType;</b>
<b class="nc"><i>2227</i>&nbsp;                }</b>
<i>2228</i>&nbsp;                return na;
<b class="nc"><i>2229</i>&nbsp;            } else {</b>
<b class="nc"><i>2230</i>&nbsp;                JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));</b>
<b class="nc"><i>2231</i>&nbsp;                return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);</b>
<b class="nc"><i>2232</i>&nbsp;            }</b>
<b class="nc"><i>2233</i>&nbsp;        } else {</b>
<i>2234</i>&nbsp;            ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
<b class="nc"><i>2235</i>&nbsp;</b>
<b class="nc"><i>2236</i>&nbsp;            // maintain array dimension type annotations</b>
<i>2237</i>&nbsp;            ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
<b class="nc"><i>2238</i>&nbsp;            dimAnnotations.append(annos);</b>
<b class="nc"><i>2239</i>&nbsp;</b>
<b class="nc"><i>2240</i>&nbsp;            dims.append(parseExpression());</b>
<i>2241</i>&nbsp;            accept(RBRACKET);
<i>2242</i>&nbsp;            while (token.kind == LBRACKET
<b class="nc"><i>2243</i>&nbsp;                    || token.kind == MONKEYS_AT) {</b>
<i>2244</i>&nbsp;                List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
<b class="nc"><i>2245</i>&nbsp;                int pos = token.pos;</b>
<b class="nc"><i>2246</i>&nbsp;                nextToken();</b>
<b class="nc"><i>2247</i>&nbsp;                if (token.kind == RBRACKET) {</b>
<i>2248</i>&nbsp;                    elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
<i>2249</i>&nbsp;                } else {
<i>2250</i>&nbsp;                    if (token.kind == RBRACKET) { // no dimension
<i>2251</i>&nbsp;                        elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
<i>2252</i>&nbsp;                    } else {
<i>2253</i>&nbsp;                        dimAnnotations.append(maybeDimAnnos);
<i>2254</i>&nbsp;                        dims.append(parseExpression());
<i>2255</i>&nbsp;                        accept(RBRACKET);
<i>2256</i>&nbsp;                    }
<i>2257</i>&nbsp;                }
<b class="nc"><i>2258</i>&nbsp;            }</b>
<b class="nc"><i>2259</i>&nbsp;</b>
<b class="nc"><i>2260</i>&nbsp;            List&lt;JCExpression&gt; elems = null;</b>
<b class="nc"><i>2261</i>&nbsp;            int errpos = token.pos;</b>
<b class="nc"><i>2262</i>&nbsp;</b>
<b class="nc"><i>2263</i>&nbsp;            if (token.kind == LBRACE) {</b>
<b class="nc"><i>2264</i>&nbsp;                elems = arrayInitializerElements(newpos, elemtype);</b>
<i>2265</i>&nbsp;            }
<b class="nc"><i>2266</i>&nbsp;</b>
<i>2267</i>&nbsp;            JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
<i>2268</i>&nbsp;            na.dimAnnotations = dimAnnotations.toList();
<i>2269</i>&nbsp;
<i>2270</i>&nbsp;            if (elems != null) {
<i>2271</i>&nbsp;                return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
<b class="nc"><i>2272</i>&nbsp;            }</b>
<b class="nc"><i>2273</i>&nbsp;</b>
<b class="nc"><i>2274</i>&nbsp;            return na;</b>
<b class="nc"><i>2275</i>&nbsp;        }</b>
<b class="nc"><i>2276</i>&nbsp;    }</b>
<b class="nc"><i>2277</i>&nbsp;</b>
<b class="nc"><i>2278</i>&nbsp;    /** ClassCreatorRest = Arguments [ClassBody]</b>
<b class="nc"><i>2279</i>&nbsp;     */</b>
<b class="nc"><i>2280</i>&nbsp;    JCNewClass classCreatorRest(int newpos,</b>
<b class="nc"><i>2281</i>&nbsp;                                  JCExpression encl,</b>
<i>2282</i>&nbsp;                                  List&lt;JCExpression&gt; typeArgs,
<i>2283</i>&nbsp;                                  JCExpression t)
<b class="nc"><i>2284</i>&nbsp;    {</b>
<b class="nc"><i>2285</i>&nbsp;        List&lt;JCExpression&gt; args = arguments();</b>
<i>2286</i>&nbsp;        JCClassDecl body = null;
<i>2287</i>&nbsp;        if (token.kind == LBRACE) {
<i>2288</i>&nbsp;            int pos = token.pos;
<i>2289</i>&nbsp;            List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);
<i>2290</i>&nbsp;            JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
<b class="nc"><i>2291</i>&nbsp;            body = toP(F.at(pos).AnonymousClassDef(mods, defs));</b>
<i>2292</i>&nbsp;        }
<i>2293</i>&nbsp;        return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
<i>2294</i>&nbsp;    }
<i>2295</i>&nbsp;
<i>2296</i>&nbsp;    /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
<b class="nc"><i>2297</i>&nbsp;     */</b>
<b class="nc"><i>2298</i>&nbsp;    JCExpression arrayInitializer(int newpos, JCExpression t) {</b>
<b class="nc"><i>2299</i>&nbsp;        List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);</b>
<b class="nc"><i>2300</i>&nbsp;        return toP(F.at(newpos).NewArray(t, List.nil(), elems));</b>
<b class="nc"><i>2301</i>&nbsp;    }</b>
<i>2302</i>&nbsp;
<i>2303</i>&nbsp;    List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
<i>2304</i>&nbsp;        accept(LBRACE);
<i>2305</i>&nbsp;        ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
<i>2306</i>&nbsp;        if (token.kind == COMMA) {
<b class="nc"><i>2307</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2308</i>&nbsp;        } else if (token.kind != RBRACE) {</b>
<b class="nc"><i>2309</i>&nbsp;            elems.append(variableInitializer());</b>
<b class="nc"><i>2310</i>&nbsp;            while (token.kind == COMMA) {</b>
<b class="nc"><i>2311</i>&nbsp;                nextToken();</b>
<b class="nc"><i>2312</i>&nbsp;                if (token.kind == RBRACE) break;</b>
<i>2313</i>&nbsp;                elems.append(variableInitializer());
<i>2314</i>&nbsp;            }
<i>2315</i>&nbsp;        }
<b class="nc"><i>2316</i>&nbsp;        accept(RBRACE);</b>
<b class="nc"><i>2317</i>&nbsp;        return elems.toList();</b>
<b class="nc"><i>2318</i>&nbsp;    }</b>
<i>2319</i>&nbsp;
<i>2320</i>&nbsp;    /** VariableInitializer = ArrayInitializer | Expression
<i>2321</i>&nbsp;     */
<b class="nc"><i>2322</i>&nbsp;    public JCExpression variableInitializer() {</b>
<i>2323</i>&nbsp;        return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
<i>2324</i>&nbsp;    }
<i>2325</i>&nbsp;
<i>2326</i>&nbsp;    /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
<i>2327</i>&nbsp;     */
<i>2328</i>&nbsp;    JCExpression parExpression() {
<i>2329</i>&nbsp;        int pos = token.pos;
<i>2330</i>&nbsp;        accept(LPAREN);
<i>2331</i>&nbsp;        JCExpression t = parseExpression();
<i>2332</i>&nbsp;        accept(RPAREN);
<i>2333</i>&nbsp;        return toP(F.at(pos).Parens(t));
<i>2334</i>&nbsp;    }
<b class="nc"><i>2335</i>&nbsp;</b>
<i>2336</i>&nbsp;    /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
<b class="nc"><i>2337</i>&nbsp;     */</b>
<b class="nc"><i>2338</i>&nbsp;    JCBlock block(int pos, long flags) {</b>
<b class="nc"><i>2339</i>&nbsp;        accept(LBRACE);</b>
<i>2340</i>&nbsp;        List&lt;JCStatement&gt; stats = blockStatements();
<b class="nc"><i>2341</i>&nbsp;        JCBlock t = F.at(pos).Block(flags, stats);</b>
<b class="nc"><i>2342</i>&nbsp;        while (token.kind == CASE || token.kind == DEFAULT) {</b>
<i>2343</i>&nbsp;            syntaxError(token.pos, Errors.Orphaned(token.kind));
<b class="nc"><i>2344</i>&nbsp;            switchBlockStatementGroups();</b>
<i>2345</i>&nbsp;        }
<b class="nc"><i>2346</i>&nbsp;        // the Block node has a field &quot;endpos&quot; for first char of last token, which is</b>
<i>2347</i>&nbsp;        // usually but not necessarily the last char of the last token.
<i>2348</i>&nbsp;        t.endpos = token.pos;
<i>2349</i>&nbsp;        accept(RBRACE);
<i>2350</i>&nbsp;        return toP(t);
<i>2351</i>&nbsp;    }
<i>2352</i>&nbsp;
<i>2353</i>&nbsp;    public JCBlock block() {
<i>2354</i>&nbsp;        return block(token.pos, 0);
<b class="nc"><i>2355</i>&nbsp;    }</b>
<b class="nc"><i>2356</i>&nbsp;</b>
<b class="nc"><i>2357</i>&nbsp;    /** BlockStatements = { BlockStatement }</b>
<b class="nc"><i>2358</i>&nbsp;     *  BlockStatement  = LocalVariableDeclarationStatement</b>
<b class="nc"><i>2359</i>&nbsp;     *                  | ClassOrInterfaceOrEnumDeclaration</b>
<b class="nc"><i>2360</i>&nbsp;     *                  | [Ident &quot;:&quot;] Statement</b>
<i>2361</i>&nbsp;     *  LocalVariableDeclarationStatement
<b class="nc"><i>2362</i>&nbsp;     *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;</b>
<b class="nc"><i>2363</i>&nbsp;     */</b>
<b class="nc"><i>2364</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)</b>
<i>2365</i>&nbsp;    List&lt;JCStatement&gt; blockStatements() {
<b class="nc"><i>2366</i>&nbsp;        //todo: skip to anchor on error(?)</b>
<b class="nc"><i>2367</i>&nbsp;        int lastErrPos = -1;</b>
<i>2368</i>&nbsp;        ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
<b class="nc"><i>2369</i>&nbsp;        while (true) {</b>
<i>2370</i>&nbsp;            List&lt;JCStatement&gt; stat = blockStatement();
<i>2371</i>&nbsp;            if (stat.isEmpty()) {
<b class="nc"><i>2372</i>&nbsp;                return stats.toList();</b>
<b class="nc"><i>2373</i>&nbsp;            } else {</b>
<b class="nc"><i>2374</i>&nbsp;                // error recovery</b>
<b class="nc"><i>2375</i>&nbsp;                if (token.pos == lastErrPos)</b>
<i>2376</i>&nbsp;                    return stats.toList();
<b class="nc"><i>2377</i>&nbsp;                if (token.pos &lt;= endPosTable.errorEndPos) {</b>
<i>2378</i>&nbsp;                    skip(false, true, true, true);
<i>2379</i>&nbsp;                    lastErrPos = token.pos;
<i>2380</i>&nbsp;                }
<i>2381</i>&nbsp;                stats.addAll(stat);
<i>2382</i>&nbsp;            }
<i>2383</i>&nbsp;        }
<b class="nc"><i>2384</i>&nbsp;    }</b>
<b class="nc"><i>2385</i>&nbsp;</b>
<i>2386</i>&nbsp;    /*
<b class="nc"><i>2387</i>&nbsp;     * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,</b>
<i>2388</i>&nbsp;     * this method will also recognize variable and class declarations (which are
<i>2389</i>&nbsp;     * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
<i>2390</i>&nbsp;     * If any illegal declarations are found, they will be wrapped in an erroneous tree,
<b class="nc"><i>2391</i>&nbsp;     * and an error will be produced by this method.</b>
<i>2392</i>&nbsp;     */
<i>2393</i>&nbsp;    JCStatement parseStatementAsBlock() {
<b class="nc"><i>2394</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>2395</i>&nbsp;        List&lt;JCStatement&gt; stats = blockStatement();</b>
<b class="nc"><i>2396</i>&nbsp;        if (stats.isEmpty()) {</b>
<i>2397</i>&nbsp;            JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
<i>2398</i>&nbsp;            return toP(F.at(pos).Exec(e));
<b class="nc"><i>2399</i>&nbsp;        } else {</b>
<i>2400</i>&nbsp;            JCStatement first = stats.head;
<b class="nc"><i>2401</i>&nbsp;            Error error = null;</b>
<b class="nc"><i>2402</i>&nbsp;            switch (first.getTag()) {</b>
<b class="nc"><i>2403</i>&nbsp;            case CLASSDEF:</b>
<i>2404</i>&nbsp;                error = Errors.ClassNotAllowed;
<b class="nc"><i>2405</i>&nbsp;                break;</b>
<b class="nc"><i>2406</i>&nbsp;            case VARDEF:</b>
<b class="nc"><i>2407</i>&nbsp;                error = Errors.VariableNotAllowed;</b>
<i>2408</i>&nbsp;                break;
<i>2409</i>&nbsp;            }
<i>2410</i>&nbsp;            if (error != null) {
<b class="nc"><i>2411</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, first, error);</b>
<b class="nc"><i>2412</i>&nbsp;                List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));</b>
<b class="nc"><i>2413</i>&nbsp;                return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));</b>
<i>2414</i>&nbsp;            }
<i>2415</i>&nbsp;            return first;
<i>2416</i>&nbsp;        }
<b class="nc"><i>2417</i>&nbsp;    }</b>
<b class="nc"><i>2418</i>&nbsp;</b>
<i>2419</i>&nbsp;    /**This method parses a statement appearing inside a block.
<i>2420</i>&nbsp;     */
<b class="nc"><i>2421</i>&nbsp;    List&lt;JCStatement&gt; blockStatement() {</b>
<b class="nc"><i>2422</i>&nbsp;        //todo: skip to anchor on error(?)</b>
<b class="nc"><i>2423</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>2424</i>&nbsp;        switch (token.kind) {</b>
<b class="nc"><i>2425</i>&nbsp;        case RBRACE: case CASE: case DEFAULT: case EOF:</b>
<b class="nc"><i>2426</i>&nbsp;            return List.nil();</b>
<i>2427</i>&nbsp;        case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
<i>2428</i>&nbsp;        case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
<i>2429</i>&nbsp;        case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
<b class="nc"><i>2430</i>&nbsp;        case ASSERT:</b>
<b class="nc"><i>2431</i>&nbsp;            return List.of(parseSimpleStatement());</b>
<b class="nc"><i>2432</i>&nbsp;        case MONKEYS_AT:</b>
<b class="nc"><i>2433</i>&nbsp;        case FINAL: {</b>
<b class="nc"><i>2434</i>&nbsp;            Comment dc = token.comment(CommentStyle.JAVADOC);</b>
<b class="nc"><i>2435</i>&nbsp;            JCModifiers mods = modifiersOpt();</b>
<b class="nc"><i>2436</i>&nbsp;            if (token.kind == INTERFACE ||</b>
<b class="nc"><i>2437</i>&nbsp;                token.kind == CLASS ||</b>
<b class="nc"><i>2438</i>&nbsp;                token.kind == ENUM) {</b>
<b class="nc"><i>2439</i>&nbsp;                return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</b>
<b class="nc"><i>2440</i>&nbsp;            } else {</b>
<b class="nc"><i>2441</i>&nbsp;                JCExpression t = parseType(true);</b>
<i>2442</i>&nbsp;                return localVariableDeclarations(mods, t);
<b class="nc"><i>2443</i>&nbsp;            }</b>
<b class="nc"><i>2444</i>&nbsp;        }</b>
<b class="nc"><i>2445</i>&nbsp;        case ABSTRACT: case STRICTFP: {</b>
<i>2446</i>&nbsp;            Comment dc = token.comment(CommentStyle.JAVADOC);
<i>2447</i>&nbsp;            JCModifiers mods = modifiersOpt();
<b class="nc"><i>2448</i>&nbsp;            return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</b>
<b class="nc"><i>2449</i>&nbsp;        }</b>
<b class="nc"><i>2450</i>&nbsp;        case INTERFACE:</b>
<i>2451</i>&nbsp;        case CLASS:
<i>2452</i>&nbsp;            Comment dc = token.comment(CommentStyle.JAVADOC);
<i>2453</i>&nbsp;            return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
<i>2454</i>&nbsp;        case ENUM:
<i>2455</i>&nbsp;            log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
<i>2456</i>&nbsp;            dc = token.comment(CommentStyle.JAVADOC);
<i>2457</i>&nbsp;            return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
<i>2458</i>&nbsp;        default:
<i>2459</i>&nbsp;            Token prevToken = token;
<i>2460</i>&nbsp;            JCExpression t = term(EXPR | TYPE);
<i>2461</i>&nbsp;            if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
<i>2462</i>&nbsp;                nextToken();
<i>2463</i>&nbsp;                JCStatement stat = parseStatementAsBlock();
<i>2464</i>&nbsp;                return List.of(F.at(pos).Labelled(prevToken.name(), stat));
<i>2465</i>&nbsp;            } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<i>2466</i>&nbsp;                pos = token.pos;
<i>2467</i>&nbsp;                JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
<i>2468</i>&nbsp;                F.at(pos);
<i>2469</i>&nbsp;                return localVariableDeclarations(mods, t);
<i>2470</i>&nbsp;            } else {
<i>2471</i>&nbsp;                // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
<i>2472</i>&nbsp;                t = checkExprStat(t);
<i>2473</i>&nbsp;                accept(SEMI);
<i>2474</i>&nbsp;                JCExpressionStatement expr = toP(F.at(pos).Exec(t));
<i>2475</i>&nbsp;                return List.of(expr);
<i>2476</i>&nbsp;            }
<b class="nc"><i>2477</i>&nbsp;        }</b>
<b class="nc"><i>2478</i>&nbsp;    }</b>
<i>2479</i>&nbsp;    //where
<b class="nc"><i>2480</i>&nbsp;        private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {</b>
<i>2481</i>&nbsp;            ListBuffer&lt;JCStatement&gt; stats =
<b class="nc"><i>2482</i>&nbsp;                    variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);</b>
<b class="nc"><i>2483</i>&nbsp;            // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon</b>
<b class="nc"><i>2484</i>&nbsp;            accept(SEMI);</b>
<b class="nc"><i>2485</i>&nbsp;            storeEnd(stats.last(), S.prevToken().endPos);</b>
<b class="nc"><i>2486</i>&nbsp;            return stats.toList();</b>
<b class="nc"><i>2487</i>&nbsp;        }</b>
<b class="nc"><i>2488</i>&nbsp;</b>
<i>2489</i>&nbsp;    /** Statement =
<b class="nc"><i>2490</i>&nbsp;     *       Block</b>
<i>2491</i>&nbsp;     *     | IF ParExpression Statement [ELSE Statement]
<i>2492</i>&nbsp;     *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
<b class="nc"><i>2493</i>&nbsp;     *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement</b>
<b class="nc"><i>2494</i>&nbsp;     *     | WHILE ParExpression Statement</b>
<b class="nc"><i>2495</i>&nbsp;     *     | DO Statement WHILE ParExpression &quot;;&quot;</b>
<b class="nc"><i>2496</i>&nbsp;     *     | TRY Block ( Catches | [Catches] FinallyPart )</b>
<b class="nc"><i>2497</i>&nbsp;     *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]</b>
<i>2498</i>&nbsp;     *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
<i>2499</i>&nbsp;     *     | SYNCHRONIZED ParExpression Block
<b class="nc"><i>2500</i>&nbsp;     *     | RETURN [Expression] &quot;;&quot;</b>
<b class="nc"><i>2501</i>&nbsp;     *     | THROW Expression &quot;;&quot;</b>
<b class="nc"><i>2502</i>&nbsp;     *     | BREAK [Ident] &quot;;&quot;</b>
<b class="nc"><i>2503</i>&nbsp;     *     | CONTINUE [Ident] &quot;;&quot;</b>
<b class="nc"><i>2504</i>&nbsp;     *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;</b>
<b class="nc"><i>2505</i>&nbsp;     *     | &quot;;&quot;</b>
<b class="nc"><i>2506</i>&nbsp;     */</b>
<i>2507</i>&nbsp;    public JCStatement parseSimpleStatement() {
<b class="nc"><i>2508</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>2509</i>&nbsp;        switch (token.kind) {</b>
<b class="nc"><i>2510</i>&nbsp;        case LBRACE:</b>
<b class="nc"><i>2511</i>&nbsp;            return block();</b>
<b class="nc"><i>2512</i>&nbsp;        case IF: {</b>
<b class="nc"><i>2513</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2514</i>&nbsp;            JCExpression cond = parExpression();</b>
<i>2515</i>&nbsp;            JCStatement thenpart = parseStatementAsBlock();
<i>2516</i>&nbsp;            JCStatement elsepart = null;
<i>2517</i>&nbsp;            if (token.kind == ELSE) {
<b class="nc"><i>2518</i>&nbsp;                nextToken();</b>
<b class="nc"><i>2519</i>&nbsp;                elsepart = parseStatementAsBlock();</b>
<b class="nc"><i>2520</i>&nbsp;            }</b>
<b class="nc"><i>2521</i>&nbsp;            return F.at(pos).If(cond, thenpart, elsepart);</b>
<i>2522</i>&nbsp;        }
<i>2523</i>&nbsp;        case FOR: {
<b class="nc"><i>2524</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2525</i>&nbsp;            accept(LPAREN);</b>
<b class="nc"><i>2526</i>&nbsp;            List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();</b>
<b class="nc"><i>2527</i>&nbsp;            if (inits.length() == 1 &amp;&amp;</b>
<b class="nc"><i>2528</i>&nbsp;                inits.head.hasTag(VARDEF) &amp;&amp;</b>
<b class="nc"><i>2529</i>&nbsp;                ((JCVariableDecl) inits.head).init == null &amp;&amp;</b>
<b class="nc"><i>2530</i>&nbsp;                token.kind == COLON) {</b>
<i>2531</i>&nbsp;                JCVariableDecl var = (JCVariableDecl)inits.head;
<i>2532</i>&nbsp;                accept(COLON);
<b class="nc"><i>2533</i>&nbsp;                JCExpression expr = parseExpression();</b>
<b class="nc"><i>2534</i>&nbsp;                accept(RPAREN);</b>
<b class="nc"><i>2535</i>&nbsp;                JCStatement body = parseStatementAsBlock();</b>
<b class="nc"><i>2536</i>&nbsp;                return F.at(pos).ForeachLoop(var, expr, body);</b>
<b class="nc"><i>2537</i>&nbsp;            } else {</b>
<b class="nc"><i>2538</i>&nbsp;                accept(SEMI);</b>
<b class="nc"><i>2539</i>&nbsp;                JCExpression cond = token.kind == SEMI ? null : parseExpression();</b>
<i>2540</i>&nbsp;                accept(SEMI);
<b class="nc"><i>2541</i>&nbsp;                List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();</b>
<b class="nc"><i>2542</i>&nbsp;                accept(RPAREN);</b>
<b class="nc"><i>2543</i>&nbsp;                JCStatement body = parseStatementAsBlock();</b>
<b class="nc"><i>2544</i>&nbsp;                return F.at(pos).ForLoop(inits, cond, steps, body);</b>
<b class="nc"><i>2545</i>&nbsp;            }</b>
<b class="nc"><i>2546</i>&nbsp;        }</b>
<b class="nc"><i>2547</i>&nbsp;        case WHILE: {</b>
<b class="nc"><i>2548</i>&nbsp;            nextToken();</b>
<i>2549</i>&nbsp;            JCExpression cond = parExpression();
<i>2550</i>&nbsp;            JCStatement body = parseStatementAsBlock();
<b class="nc"><i>2551</i>&nbsp;            return F.at(pos).WhileLoop(cond, body);</b>
<b class="nc"><i>2552</i>&nbsp;        }</b>
<b class="nc"><i>2553</i>&nbsp;        case DO: {</b>
<i>2554</i>&nbsp;            nextToken();
<b class="nc"><i>2555</i>&nbsp;            JCStatement body = parseStatementAsBlock();</b>
<i>2556</i>&nbsp;            accept(WHILE);
<b class="nc"><i>2557</i>&nbsp;            JCExpression cond = parExpression();</b>
<i>2558</i>&nbsp;            accept(SEMI);
<i>2559</i>&nbsp;            JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
<b class="nc"><i>2560</i>&nbsp;            return t;</b>
<b class="nc"><i>2561</i>&nbsp;        }</b>
<b class="nc"><i>2562</i>&nbsp;        case TRY: {</b>
<b class="nc"><i>2563</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2564</i>&nbsp;            List&lt;JCTree&gt; resources = List.nil();</b>
<b class="nc"><i>2565</i>&nbsp;            if (token.kind == LPAREN) {</b>
<b class="nc"><i>2566</i>&nbsp;                checkSourceLevel(Feature.TRY_WITH_RESOURCES);</b>
<i>2567</i>&nbsp;                nextToken();
<i>2568</i>&nbsp;                resources = resources();
<b class="nc"><i>2569</i>&nbsp;                accept(RPAREN);</b>
<b class="nc"><i>2570</i>&nbsp;            }</b>
<b class="nc"><i>2571</i>&nbsp;            JCBlock body = block();</b>
<b class="nc"><i>2572</i>&nbsp;            ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();</b>
<i>2573</i>&nbsp;            JCBlock finalizer = null;
<i>2574</i>&nbsp;            if (token.kind == CATCH || token.kind == FINALLY) {
<b class="nc"><i>2575</i>&nbsp;                while (token.kind == CATCH) catchers.append(catchClause());</b>
<b class="nc"><i>2576</i>&nbsp;                if (token.kind == FINALLY) {</b>
<b class="nc"><i>2577</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>2578</i>&nbsp;                    finalizer = block();</b>
<b class="nc"><i>2579</i>&nbsp;                }</b>
<i>2580</i>&nbsp;            } else {
<i>2581</i>&nbsp;                if (resources.isEmpty()) {
<b class="nc"><i>2582</i>&nbsp;                    if (Feature.TRY_WITH_RESOURCES.allowedInSource(source)) {</b>
<b class="nc"><i>2583</i>&nbsp;                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);</b>
<b class="nc"><i>2584</i>&nbsp;                    } else {</b>
<b class="nc"><i>2585</i>&nbsp;                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchOrFinally);</b>
<b class="nc"><i>2586</i>&nbsp;                    }</b>
<i>2587</i>&nbsp;                }
<i>2588</i>&nbsp;            }
<b class="nc"><i>2589</i>&nbsp;            return F.at(pos).Try(resources, body, catchers.toList(), finalizer);</b>
<b class="nc"><i>2590</i>&nbsp;        }</b>
<b class="nc"><i>2591</i>&nbsp;        case SWITCH: {</b>
<b class="nc"><i>2592</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2593</i>&nbsp;            JCExpression selector = parExpression();</b>
<i>2594</i>&nbsp;            accept(LBRACE);
<i>2595</i>&nbsp;            List&lt;JCCase&gt; cases = switchBlockStatementGroups();
<b class="nc"><i>2596</i>&nbsp;            JCSwitch t = to(F.at(pos).Switch(selector, cases));</b>
<b class="nc"><i>2597</i>&nbsp;            accept(RBRACE);</b>
<b class="nc"><i>2598</i>&nbsp;            return t;</b>
<b class="nc"><i>2599</i>&nbsp;        }</b>
<b class="nc"><i>2600</i>&nbsp;        case SYNCHRONIZED: {</b>
<i>2601</i>&nbsp;            nextToken();
<i>2602</i>&nbsp;            JCExpression lock = parExpression();
<b class="nc"><i>2603</i>&nbsp;            JCBlock body = block();</b>
<b class="nc"><i>2604</i>&nbsp;            return F.at(pos).Synchronized(lock, body);</b>
<i>2605</i>&nbsp;        }
<b class="nc"><i>2606</i>&nbsp;        case RETURN: {</b>
<b class="nc"><i>2607</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2608</i>&nbsp;            JCExpression result = token.kind == SEMI ? null : parseExpression();</b>
<i>2609</i>&nbsp;            accept(SEMI);
<b class="nc"><i>2610</i>&nbsp;            JCReturn t = toP(F.at(pos).Return(result));</b>
<b class="nc"><i>2611</i>&nbsp;            return t;</b>
<b class="nc"><i>2612</i>&nbsp;        }</b>
<i>2613</i>&nbsp;        case THROW: {
<b class="nc"><i>2614</i>&nbsp;            nextToken();</b>
<i>2615</i>&nbsp;            JCExpression exc = parseExpression();
<b class="nc"><i>2616</i>&nbsp;            accept(SEMI);</b>
<b class="nc"><i>2617</i>&nbsp;            JCThrow t = toP(F.at(pos).Throw(exc));</b>
<b class="nc"><i>2618</i>&nbsp;            return t;</b>
<b class="nc"><i>2619</i>&nbsp;        }</b>
<b class="nc"><i>2620</i>&nbsp;        case BREAK: {</b>
<b class="nc"><i>2621</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2622</i>&nbsp;            Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;</b>
<i>2623</i>&nbsp;            accept(SEMI);
<b class="nc"><i>2624</i>&nbsp;            JCBreak t = toP(F.at(pos).Break(label));</b>
<b class="nc"><i>2625</i>&nbsp;            return t;</b>
<b class="nc"><i>2626</i>&nbsp;        }</b>
<i>2627</i>&nbsp;        case CONTINUE: {
<i>2628</i>&nbsp;            nextToken();
<i>2629</i>&nbsp;            Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
<i>2630</i>&nbsp;            accept(SEMI);
<i>2631</i>&nbsp;            JCContinue t =  toP(F.at(pos).Continue(label));
<b class="nc"><i>2632</i>&nbsp;            return t;</b>
<b class="nc"><i>2633</i>&nbsp;        }</b>
<b class="nc"><i>2634</i>&nbsp;        case SEMI:</b>
<b class="nc"><i>2635</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2636</i>&nbsp;            return toP(F.at(pos).Skip());</b>
<b class="nc"><i>2637</i>&nbsp;        case ELSE:</b>
<i>2638</i>&nbsp;            int elsePos = token.pos;
<i>2639</i>&nbsp;            nextToken();
<b class="nc"><i>2640</i>&nbsp;            return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);</b>
<b class="nc"><i>2641</i>&nbsp;        case FINALLY:</b>
<b class="nc"><i>2642</i>&nbsp;            int finallyPos = token.pos;</b>
<i>2643</i>&nbsp;            nextToken();
<i>2644</i>&nbsp;            return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
<i>2645</i>&nbsp;        case CATCH:
<i>2646</i>&nbsp;            return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
<i>2647</i>&nbsp;        case ASSERT: {
<b class="nc"><i>2648</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2649</i>&nbsp;            JCExpression assertion = parseExpression();</b>
<b class="nc"><i>2650</i>&nbsp;            JCExpression message = null;</b>
<b class="nc"><i>2651</i>&nbsp;            if (token.kind == COLON) {</b>
<i>2652</i>&nbsp;                nextToken();
<i>2653</i>&nbsp;                message = parseExpression();
<i>2654</i>&nbsp;            }
<i>2655</i>&nbsp;            accept(SEMI);
<i>2656</i>&nbsp;            JCAssert t = toP(F.at(pos).Assert(assertion, message));
<i>2657</i>&nbsp;            return t;
<b class="nc"><i>2658</i>&nbsp;        }</b>
<b class="nc"><i>2659</i>&nbsp;        default:</b>
<b class="nc"><i>2660</i>&nbsp;            Assert.error();</b>
<b class="nc"><i>2661</i>&nbsp;            return null;</b>
<b class="nc"><i>2662</i>&nbsp;        }</b>
<b class="nc"><i>2663</i>&nbsp;    }</b>
<b class="nc"><i>2664</i>&nbsp;</b>
<i>2665</i>&nbsp;    @Override
<b class="nc"><i>2666</i>&nbsp;    public JCStatement parseStatement() {</b>
<b class="nc"><i>2667</i>&nbsp;        return parseStatementAsBlock();</b>
<b class="nc"><i>2668</i>&nbsp;    }</b>
<b class="nc"><i>2669</i>&nbsp;</b>
<i>2670</i>&nbsp;    private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
<i>2671</i>&nbsp;        int errPos = S.errPos();
<i>2672</i>&nbsp;        JCTree stm = action.doRecover(this);
<b class="nc"><i>2673</i>&nbsp;        S.errPos(errPos);</b>
<b class="nc"><i>2674</i>&nbsp;        return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));</b>
<b class="nc"><i>2675</i>&nbsp;    }</b>
<b class="nc"><i>2676</i>&nbsp;</b>
<b class="nc"><i>2677</i>&nbsp;    /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block</b>
<i>2678</i>&nbsp;     * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
<i>2679</i>&nbsp;     */
<b class="nc"><i>2680</i>&nbsp;    protected JCCatch catchClause() {</b>
<i>2681</i>&nbsp;        int pos = token.pos;
<b class="nc"><i>2682</i>&nbsp;        accept(CATCH);</b>
<i>2683</i>&nbsp;        accept(LPAREN);
<i>2684</i>&nbsp;        JCModifiers mods = optFinal(Flags.PARAMETER);
<i>2685</i>&nbsp;        List&lt;JCExpression&gt; catchTypes = catchTypes();
<i>2686</i>&nbsp;        JCExpression paramType = catchTypes.size() &gt; 1 ?
<i>2687</i>&nbsp;                toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
<i>2688</i>&nbsp;                catchTypes.head;
<i>2689</i>&nbsp;        JCVariableDecl formal = variableDeclaratorId(mods, paramType);
<b class="nc"><i>2690</i>&nbsp;        accept(RPAREN);</b>
<i>2691</i>&nbsp;        JCBlock body = block();
<b class="nc"><i>2692</i>&nbsp;        return F.at(pos).Catch(formal, body);</b>
<b class="nc"><i>2693</i>&nbsp;    }</b>
<i>2694</i>&nbsp;
<i>2695</i>&nbsp;    List&lt;JCExpression&gt; catchTypes() {
<b class="nc"><i>2696</i>&nbsp;        ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2697</i>&nbsp;        catchTypes.add(parseType());</b>
<i>2698</i>&nbsp;        while (token.kind == BAR) {
<b class="nc"><i>2699</i>&nbsp;            checkSourceLevel(Feature.MULTICATCH);</b>
<i>2700</i>&nbsp;            nextToken();
<b class="nc"><i>2701</i>&nbsp;            // Instead of qualident this is now parseType.</b>
<b class="nc"><i>2702</i>&nbsp;            // But would that allow too much, e.g. arrays or generics?</b>
<i>2703</i>&nbsp;            catchTypes.add(parseType());
<i>2704</i>&nbsp;        }
<b class="nc"><i>2705</i>&nbsp;        return catchTypes.toList();</b>
<i>2706</i>&nbsp;    }
<i>2707</i>&nbsp;
<i>2708</i>&nbsp;    /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
<b class="nc"><i>2709</i>&nbsp;     *  SwitchBlockStatementGroup = SwitchLabel BlockStatements</b>
<i>2710</i>&nbsp;     *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
<i>2711</i>&nbsp;     */
<b class="nc"><i>2712</i>&nbsp;    List&lt;JCCase&gt; switchBlockStatementGroups() {</b>
<i>2713</i>&nbsp;        ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
<b class="nc"><i>2714</i>&nbsp;        while (true) {</b>
<b class="nc"><i>2715</i>&nbsp;            int pos = token.pos;</b>
<b class="nc"><i>2716</i>&nbsp;            switch (token.kind) {</b>
<b class="nc"><i>2717</i>&nbsp;            case CASE:</b>
<b class="nc"><i>2718</i>&nbsp;            case DEFAULT:</b>
<b class="nc"><i>2719</i>&nbsp;                cases.append(switchBlockStatementGroup());</b>
<b class="nc"><i>2720</i>&nbsp;                break;</b>
<b class="nc"><i>2721</i>&nbsp;            case RBRACE: case EOF:</b>
<i>2722</i>&nbsp;                return cases.toList();
<b class="nc"><i>2723</i>&nbsp;            default:</b>
<b class="nc"><i>2724</i>&nbsp;                nextToken(); // to ensure progress</b>
<b class="nc"><i>2725</i>&nbsp;                syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));</b>
<b class="nc"><i>2726</i>&nbsp;            }</b>
<b class="nc"><i>2727</i>&nbsp;        }</b>
<b class="nc"><i>2728</i>&nbsp;    }</b>
<b class="nc"><i>2729</i>&nbsp;</b>
<i>2730</i>&nbsp;    protected JCCase switchBlockStatementGroup() {
<b class="nc"><i>2731</i>&nbsp;        int pos = token.pos;</b>
<i>2732</i>&nbsp;        List&lt;JCStatement&gt; stats;
<i>2733</i>&nbsp;        JCCase c;
<i>2734</i>&nbsp;        switch (token.kind) {
<i>2735</i>&nbsp;        case CASE:
<i>2736</i>&nbsp;            nextToken();
<i>2737</i>&nbsp;            JCExpression pat = parseExpression();
<i>2738</i>&nbsp;            accept(COLON);
<i>2739</i>&nbsp;            stats = blockStatements();
<b class="nc"><i>2740</i>&nbsp;            c = F.at(pos).Case(pat, stats);</b>
<b class="nc"><i>2741</i>&nbsp;            if (stats.isEmpty())</b>
<b class="nc"><i>2742</i>&nbsp;                storeEnd(c, S.prevToken().endPos);</b>
<b class="nc"><i>2743</i>&nbsp;            return c;</b>
<b class="nc"><i>2744</i>&nbsp;        case DEFAULT:</b>
<i>2745</i>&nbsp;            nextToken();
<b class="nc"><i>2746</i>&nbsp;            accept(COLON);</b>
<b class="nc"><i>2747</i>&nbsp;            stats = blockStatements();</b>
<b class="nc"><i>2748</i>&nbsp;            c = F.at(pos).Case(null, stats);</b>
<i>2749</i>&nbsp;            if (stats.isEmpty())
<i>2750</i>&nbsp;                storeEnd(c, S.prevToken().endPos);
<i>2751</i>&nbsp;            return c;
<i>2752</i>&nbsp;        }
<i>2753</i>&nbsp;        throw new AssertionError(&quot;should not reach here&quot;);
<i>2754</i>&nbsp;    }
<b class="nc"><i>2755</i>&nbsp;</b>
<b class="nc"><i>2756</i>&nbsp;    /** MoreStatementExpressions = { COMMA StatementExpression }</b>
<b class="nc"><i>2757</i>&nbsp;     */</b>
<b class="nc"><i>2758</i>&nbsp;    &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,</b>
<i>2759</i>&nbsp;                                                                    JCExpression first,
<b class="nc"><i>2760</i>&nbsp;                                                                    T stats) {</b>
<b class="nc"><i>2761</i>&nbsp;        // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token</b>
<b class="nc"><i>2762</i>&nbsp;        stats.append(toP(F.at(pos).Exec(checkExprStat(first))));</b>
<b class="nc"><i>2763</i>&nbsp;        while (token.kind == COMMA) {</b>
<b class="nc"><i>2764</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2765</i>&nbsp;            pos = token.pos;</b>
<i>2766</i>&nbsp;            JCExpression t = parseExpression();
<b class="nc"><i>2767</i>&nbsp;            // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token</b>
<i>2768</i>&nbsp;            stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
<i>2769</i>&nbsp;        }
<i>2770</i>&nbsp;        return stats;
<i>2771</i>&nbsp;    }
<i>2772</i>&nbsp;
<i>2773</i>&nbsp;    /** ForInit = StatementExpression MoreStatementExpressions
<i>2774</i>&nbsp;     *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
<b class="nc"><i>2775</i>&nbsp;     */</b>
<b class="nc"><i>2776</i>&nbsp;    List&lt;JCStatement&gt; forInit() {</b>
<b class="nc"><i>2777</i>&nbsp;        ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();</b>
<i>2778</i>&nbsp;        int pos = token.pos;
<i>2779</i>&nbsp;        if (token.kind == FINAL || token.kind == MONKEYS_AT) {
<i>2780</i>&nbsp;            return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
<i>2781</i>&nbsp;        } else {
<i>2782</i>&nbsp;            JCExpression t = term(EXPR | TYPE);
<i>2783</i>&nbsp;            if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<i>2784</i>&nbsp;                return variableDeclarators(modifiersOpt(), t, stats, true).toList();
<b class="nc"><i>2785</i>&nbsp;            } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {</b>
<b class="nc"><i>2786</i>&nbsp;                log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));</b>
<b class="nc"><i>2787</i>&nbsp;                return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));</b>
<b class="nc"><i>2788</i>&nbsp;            } else {</b>
<b class="nc"><i>2789</i>&nbsp;                return moreStatementExpressions(pos, t, stats).toList();</b>
<b class="nc"><i>2790</i>&nbsp;            }</b>
<b class="nc"><i>2791</i>&nbsp;        }</b>
<b class="nc"><i>2792</i>&nbsp;    }</b>
<b class="nc"><i>2793</i>&nbsp;</b>
<b class="nc"><i>2794</i>&nbsp;    /** ForUpdate = StatementExpression MoreStatementExpressions</b>
<b class="nc"><i>2795</i>&nbsp;     */</b>
<i>2796</i>&nbsp;    List&lt;JCExpressionStatement&gt; forUpdate() {
<b class="nc"><i>2797</i>&nbsp;        return moreStatementExpressions(token.pos,</b>
<i>2798</i>&nbsp;                                        parseExpression(),
<i>2799</i>&nbsp;                                        new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
<i>2800</i>&nbsp;    }
<b class="nc"><i>2801</i>&nbsp;</b>
<b class="nc"><i>2802</i>&nbsp;    /** AnnotationsOpt = { &#39;@&#39; Annotation }</b>
<i>2803</i>&nbsp;     *
<i>2804</i>&nbsp;     * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
<i>2805</i>&nbsp;     */
<i>2806</i>&nbsp;    protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
<i>2807</i>&nbsp;        if (token.kind != MONKEYS_AT) return List.nil(); // optimization
<i>2808</i>&nbsp;        ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
<i>2809</i>&nbsp;        int prevmode = mode;
<i>2810</i>&nbsp;        while (token.kind == MONKEYS_AT) {
<b class="nc"><i>2811</i>&nbsp;            int pos = token.pos;</b>
<i>2812</i>&nbsp;            nextToken();
<i>2813</i>&nbsp;            buf.append(annotation(pos, kind));
<i>2814</i>&nbsp;        }
<b class="nc"><i>2815</i>&nbsp;        lastmode = mode;</b>
<i>2816</i>&nbsp;        mode = prevmode;
<b class="nc"><i>2817</i>&nbsp;        List&lt;JCAnnotation&gt; annotations = buf.toList();</b>
<b class="nc"><i>2818</i>&nbsp;</b>
<b class="nc"><i>2819</i>&nbsp;        return annotations;</b>
<i>2820</i>&nbsp;    }
<b class="nc"><i>2821</i>&nbsp;</b>
<b class="nc"><i>2822</i>&nbsp;    List&lt;JCAnnotation&gt; typeAnnotationsOpt() {</b>
<b class="nc"><i>2823</i>&nbsp;        List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);</b>
<i>2824</i>&nbsp;        return annotations;
<b class="nc"><i>2825</i>&nbsp;    }</b>
<b class="nc"><i>2826</i>&nbsp;</b>
<i>2827</i>&nbsp;    /** ModifiersOpt = { Modifier }
<i>2828</i>&nbsp;     *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
<i>2829</i>&nbsp;     *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
<i>2830</i>&nbsp;     *           | &quot;@&quot; Annotation
<i>2831</i>&nbsp;     */
<b class="nc"><i>2832</i>&nbsp;    protected JCModifiers modifiersOpt() {</b>
<b class="nc"><i>2833</i>&nbsp;        return modifiersOpt(null);</b>
<b class="nc"><i>2834</i>&nbsp;    }</b>
<b class="nc"><i>2835</i>&nbsp;    protected JCModifiers modifiersOpt(JCModifiers partial) {</b>
<b class="nc"><i>2836</i>&nbsp;        long flags;</b>
<b class="nc"><i>2837</i>&nbsp;        ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2838</i>&nbsp;        int pos;</b>
<b class="nc"><i>2839</i>&nbsp;        if (partial == null) {</b>
<b class="nc"><i>2840</i>&nbsp;            flags = 0;</b>
<b class="nc"><i>2841</i>&nbsp;            pos = token.pos;</b>
<b class="nc"><i>2842</i>&nbsp;        } else {</b>
<b class="nc"><i>2843</i>&nbsp;            flags = partial.flags;</b>
<b class="nc"><i>2844</i>&nbsp;            annotations.appendList(partial.annotations);</b>
<b class="nc"><i>2845</i>&nbsp;            pos = partial.pos;</b>
<b class="nc"><i>2846</i>&nbsp;        }</b>
<b class="nc"><i>2847</i>&nbsp;        if (token.deprecatedFlag()) {</b>
<i>2848</i>&nbsp;            flags |= Flags.DEPRECATED;
<b class="nc"><i>2849</i>&nbsp;        }</b>
<b class="nc"><i>2850</i>&nbsp;        int lastPos;</b>
<b class="nc"><i>2851</i>&nbsp;    loop:</b>
<b class="nc"><i>2852</i>&nbsp;        while (true) {</b>
<b class="nc"><i>2853</i>&nbsp;            long flag;</b>
<b class="nc"><i>2854</i>&nbsp;            switch (token.kind) {</b>
<b class="nc"><i>2855</i>&nbsp;            case PRIVATE     : flag = Flags.PRIVATE; break;</b>
<i>2856</i>&nbsp;            case PROTECTED   : flag = Flags.PROTECTED; break;
<b class="nc"><i>2857</i>&nbsp;            case PUBLIC      : flag = Flags.PUBLIC; break;</b>
<b class="nc"><i>2858</i>&nbsp;            case STATIC      : flag = Flags.STATIC; break;</b>
<b class="nc"><i>2859</i>&nbsp;            case TRANSIENT   : flag = Flags.TRANSIENT; break;</b>
<b class="nc"><i>2860</i>&nbsp;            case FINAL       : flag = Flags.FINAL; break;</b>
<i>2861</i>&nbsp;            case ABSTRACT    : flag = Flags.ABSTRACT; break;
<i>2862</i>&nbsp;            case NATIVE      : flag = Flags.NATIVE; break;
<b class="nc"><i>2863</i>&nbsp;            case VOLATILE    : flag = Flags.VOLATILE; break;</b>
<b class="nc"><i>2864</i>&nbsp;            case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;</b>
<b class="nc"><i>2865</i>&nbsp;            case STRICTFP    : flag = Flags.STRICTFP; break;</b>
<b class="nc"><i>2866</i>&nbsp;            case MONKEYS_AT  : flag = Flags.ANNOTATION; break;</b>
<b class="nc"><i>2867</i>&nbsp;            case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;</b>
<i>2868</i>&nbsp;            case ERROR       : flag = 0; nextToken(); break;
<i>2869</i>&nbsp;            default: break loop;
<i>2870</i>&nbsp;            }
<b class="nc"><i>2871</i>&nbsp;            if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);</b>
<i>2872</i>&nbsp;            lastPos = token.pos;
<i>2873</i>&nbsp;            nextToken();
<i>2874</i>&nbsp;            if (flag == Flags.ANNOTATION) {
<i>2875</i>&nbsp;                if (token.kind != INTERFACE) {
<i>2876</i>&nbsp;                    JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
<b class="nc"><i>2877</i>&nbsp;                    // if first modifier is an annotation, set pos to annotation&#39;s.</b>
<b class="nc"><i>2878</i>&nbsp;                    if (flags == 0 &amp;&amp; annotations.isEmpty())</b>
<i>2879</i>&nbsp;                        pos = ann.pos;
<b class="nc"><i>2880</i>&nbsp;                    annotations.append(ann);</b>
<b class="nc"><i>2881</i>&nbsp;                    flag = 0;</b>
<b class="nc"><i>2882</i>&nbsp;                }</b>
<b class="nc"><i>2883</i>&nbsp;            }</b>
<i>2884</i>&nbsp;            flags |= flag;
<i>2885</i>&nbsp;        }
<i>2886</i>&nbsp;        switch (token.kind) {
<i>2887</i>&nbsp;        case ENUM: flags |= Flags.ENUM; break;
<i>2888</i>&nbsp;        case INTERFACE: flags |= Flags.INTERFACE; break;
<i>2889</i>&nbsp;        default: break;
<i>2890</i>&nbsp;        }
<i>2891</i>&nbsp;
<i>2892</i>&nbsp;        /* A modifiers tree with no modifier tokens or annotations
<b class="nc"><i>2893</i>&nbsp;         * has no text position. */</b>
<b class="nc"><i>2894</i>&nbsp;        if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())</b>
<b class="nc"><i>2895</i>&nbsp;            pos = Position.NOPOS;</b>
<i>2896</i>&nbsp;
<b class="nc"><i>2897</i>&nbsp;        JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());</b>
<b class="nc"><i>2898</i>&nbsp;        if (pos != Position.NOPOS)</b>
<i>2899</i>&nbsp;            storeEnd(mods, S.prevToken().endPos);
<b class="nc"><i>2900</i>&nbsp;        return mods;</b>
<b class="nc"><i>2901</i>&nbsp;    }</b>
<b class="nc"><i>2902</i>&nbsp;</b>
<b class="nc"><i>2903</i>&nbsp;    /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]</b>
<i>2904</i>&nbsp;     *
<b class="nc"><i>2905</i>&nbsp;     * @param pos position of &quot;@&quot; token</b>
<i>2906</i>&nbsp;     * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
<i>2907</i>&nbsp;     */
<b class="nc"><i>2908</i>&nbsp;    JCAnnotation annotation(int pos, Tag kind) {</b>
<b class="nc"><i>2909</i>&nbsp;        // accept(AT); // AT consumed by caller</b>
<i>2910</i>&nbsp;        if (kind == Tag.TYPE_ANNOTATION) {
<i>2911</i>&nbsp;            checkSourceLevel(Feature.TYPE_ANNOTATIONS);
<i>2912</i>&nbsp;        }
<b class="nc"><i>2913</i>&nbsp;        JCTree ident = qualident(false);</b>
<i>2914</i>&nbsp;        List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
<i>2915</i>&nbsp;        JCAnnotation ann;
<i>2916</i>&nbsp;        if (kind == Tag.ANNOTATION) {
<i>2917</i>&nbsp;            ann = F.at(pos).Annotation(ident, fieldValues);
<b class="nc"><i>2918</i>&nbsp;        } else if (kind == Tag.TYPE_ANNOTATION) {</b>
<b class="nc"><i>2919</i>&nbsp;            ann = F.at(pos).TypeAnnotation(ident, fieldValues);</b>
<b class="nc"><i>2920</i>&nbsp;        } else {</b>
<b class="nc"><i>2921</i>&nbsp;            throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);</b>
<b class="nc"><i>2922</i>&nbsp;        }</b>
<b class="nc"><i>2923</i>&nbsp;</b>
<b class="nc"><i>2924</i>&nbsp;        storeEnd(ann, S.prevToken().endPos);</b>
<i>2925</i>&nbsp;        return ann;
<i>2926</i>&nbsp;    }
<b class="nc"><i>2927</i>&nbsp;</b>
<b class="nc"><i>2928</i>&nbsp;    List&lt;JCExpression&gt; annotationFieldValuesOpt() {</b>
<i>2929</i>&nbsp;        return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
<i>2930</i>&nbsp;    }
<i>2931</i>&nbsp;
<i>2932</i>&nbsp;    /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
<i>2933</i>&nbsp;    List&lt;JCExpression&gt; annotationFieldValues() {
<i>2934</i>&nbsp;        accept(LPAREN);
<b class="nc"><i>2935</i>&nbsp;        ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2936</i>&nbsp;        if (token.kind != RPAREN) {</b>
<b class="nc"><i>2937</i>&nbsp;            buf.append(annotationFieldValue());</b>
<b class="nc"><i>2938</i>&nbsp;            while (token.kind == COMMA) {</b>
<b class="nc"><i>2939</i>&nbsp;                nextToken();</b>
<b class="nc"><i>2940</i>&nbsp;                buf.append(annotationFieldValue());</b>
<b class="nc"><i>2941</i>&nbsp;            }</b>
<b class="nc"><i>2942</i>&nbsp;        }</b>
<i>2943</i>&nbsp;        accept(RPAREN);
<b class="nc"><i>2944</i>&nbsp;        return buf.toList();</b>
<i>2945</i>&nbsp;    }
<i>2946</i>&nbsp;
<b class="nc"><i>2947</i>&nbsp;    /** AnnotationFieldValue    = AnnotationValue</b>
<i>2948</i>&nbsp;     *                          | Identifier &quot;=&quot; AnnotationValue
<i>2949</i>&nbsp;     */
<i>2950</i>&nbsp;    JCExpression annotationFieldValue() {
<i>2951</i>&nbsp;        if (LAX_IDENTIFIER.accepts(token.kind)) {
<i>2952</i>&nbsp;            mode = EXPR;
<i>2953</i>&nbsp;            JCExpression t1 = term1();
<i>2954</i>&nbsp;            if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
<i>2955</i>&nbsp;                int pos = token.pos;
<b class="nc"><i>2956</i>&nbsp;                accept(EQ);</b>
<i>2957</i>&nbsp;                JCExpression v = annotationValue();
<b class="nc"><i>2958</i>&nbsp;                return toP(F.at(pos).Assign(t1, v));</b>
<b class="nc"><i>2959</i>&nbsp;            } else {</b>
<b class="nc"><i>2960</i>&nbsp;                return t1;</b>
<i>2961</i>&nbsp;            }
<b class="nc"><i>2962</i>&nbsp;        }</b>
<b class="nc"><i>2963</i>&nbsp;        return annotationValue();</b>
<b class="nc"><i>2964</i>&nbsp;    }</b>
<b class="nc"><i>2965</i>&nbsp;</b>
<b class="nc"><i>2966</i>&nbsp;    /* AnnotationValue          = ConditionalExpression</b>
<b class="nc"><i>2967</i>&nbsp;     *                          | Annotation</b>
<b class="nc"><i>2968</i>&nbsp;     *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;</b>
<b class="nc"><i>2969</i>&nbsp;     */</b>
<b class="nc"><i>2970</i>&nbsp;    JCExpression annotationValue() {</b>
<b class="nc"><i>2971</i>&nbsp;        int pos;</b>
<b class="nc"><i>2972</i>&nbsp;        switch (token.kind) {</b>
<i>2973</i>&nbsp;        case MONKEYS_AT:
<i>2974</i>&nbsp;            pos = token.pos;
<b class="nc"><i>2975</i>&nbsp;            nextToken();</b>
<b class="nc"><i>2976</i>&nbsp;            return annotation(pos, Tag.ANNOTATION);</b>
<i>2977</i>&nbsp;        case LBRACE:
<b class="nc"><i>2978</i>&nbsp;            pos = token.pos;</b>
<b class="nc"><i>2979</i>&nbsp;            accept(LBRACE);</b>
<i>2980</i>&nbsp;            ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
<i>2981</i>&nbsp;            if (token.kind == COMMA) {
<i>2982</i>&nbsp;                nextToken();
<i>2983</i>&nbsp;            } else if (token.kind != RBRACE) {
<i>2984</i>&nbsp;                buf.append(annotationValue());
<i>2985</i>&nbsp;                while (token.kind == COMMA) {
<i>2986</i>&nbsp;                    nextToken();
<i>2987</i>&nbsp;                    if (token.kind == RBRACE) break;
<i>2988</i>&nbsp;                    buf.append(annotationValue());
<b class="nc"><i>2989</i>&nbsp;                }</b>
<i>2990</i>&nbsp;            }
<i>2991</i>&nbsp;            accept(RBRACE);
<i>2992</i>&nbsp;            return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
<i>2993</i>&nbsp;        default:
<i>2994</i>&nbsp;            mode = EXPR;
<i>2995</i>&nbsp;            return term1();
<i>2996</i>&nbsp;        }
<i>2997</i>&nbsp;    }
<i>2998</i>&nbsp;
<i>2999</i>&nbsp;    /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
<i>3000</i>&nbsp;     */
<i>3001</i>&nbsp;    public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
<i>3002</i>&nbsp;                                                                         JCExpression type,
<i>3003</i>&nbsp;                                                                         T vdefs,
<i>3004</i>&nbsp;                                                                         boolean localDecl)
<i>3005</i>&nbsp;    {
<b class="nc"><i>3006</i>&nbsp;        return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);</b>
<b class="nc"><i>3007</i>&nbsp;    }</b>
<i>3008</i>&nbsp;
<b class="nc"><i>3009</i>&nbsp;    /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }</b>
<b class="nc"><i>3010</i>&nbsp;     *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }</b>
<b class="nc"><i>3011</i>&nbsp;     *</b>
<i>3012</i>&nbsp;     *  @param reqInit  Is an initializer always required?
<b class="nc"><i>3013</i>&nbsp;     *  @param dc       The documentation comment for the variable declarations, or null.</b>
<i>3014</i>&nbsp;     */
<i>3015</i>&nbsp;    protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
<i>3016</i>&nbsp;                                                                     JCModifiers mods,
<i>3017</i>&nbsp;                                                                     JCExpression type,
<i>3018</i>&nbsp;                                                                     Name name,
<i>3019</i>&nbsp;                                                                     boolean reqInit,
<b class="nc"><i>3020</i>&nbsp;                                                                     Comment dc,</b>
<i>3021</i>&nbsp;                                                                     T vdefs,
<i>3022</i>&nbsp;                                                                     boolean localDecl)
<i>3023</i>&nbsp;    {
<i>3024</i>&nbsp;        JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
<i>3025</i>&nbsp;        vdefs.append(head);
<i>3026</i>&nbsp;        while (token.kind == COMMA) {
<i>3027</i>&nbsp;            // All but last of multiple declarators subsume a comma
<i>3028</i>&nbsp;            storeEnd((JCTree)vdefs.last(), token.endPos);
<i>3029</i>&nbsp;            nextToken();
<i>3030</i>&nbsp;            vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
<b class="nc"><i>3031</i>&nbsp;        }</b>
<b class="nc"><i>3032</i>&nbsp;        return vdefs;</b>
<b class="nc"><i>3033</i>&nbsp;    }</b>
<b class="nc"><i>3034</i>&nbsp;</b>
<b class="nc"><i>3035</i>&nbsp;    /** VariableDeclarator = Ident VariableDeclaratorRest</b>
<i>3036</i>&nbsp;     *  ConstantDeclarator = Ident ConstantDeclaratorRest
<b class="nc"><i>3037</i>&nbsp;     */</b>
<b class="nc"><i>3038</i>&nbsp;    JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {</b>
<b class="nc"><i>3039</i>&nbsp;        return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);</b>
<b class="nc"><i>3040</i>&nbsp;    }</b>
<b class="nc"><i>3041</i>&nbsp;</b>
<i>3042</i>&nbsp;    /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
<i>3043</i>&nbsp;     *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
<i>3044</i>&nbsp;     *
<i>3045</i>&nbsp;     *  @param reqInit  Is an initializer always required?
<i>3046</i>&nbsp;     *  @param dc       The documentation comment for the variable declarations, or null.
<b class="nc"><i>3047</i>&nbsp;     */</b>
<i>3048</i>&nbsp;    JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
<i>3049</i>&nbsp;                                  boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
<i>3050</i>&nbsp;        type = bracketsOpt(type);
<b class="nc"><i>3051</i>&nbsp;        JCExpression init = null;</b>
<i>3052</i>&nbsp;        if (token.kind == EQ) {
<b class="nc"><i>3053</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3054</i>&nbsp;            init = variableInitializer();</b>
<b class="nc"><i>3055</i>&nbsp;        }</b>
<b class="nc"><i>3056</i>&nbsp;        else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));</b>
<i>3057</i>&nbsp;        JCTree elemType = TreeInfo.innermostType(type, true);
<b class="nc"><i>3058</i>&nbsp;        int startPos = Position.NOPOS;</b>
<b class="nc"><i>3059</i>&nbsp;        if (elemType.hasTag(IDENT)) {</b>
<b class="nc"><i>3060</i>&nbsp;            Name typeName = ((JCIdent)elemType).name;</b>
<b class="nc"><i>3061</i>&nbsp;            if (isRestrictedLocalVarTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</b>
<i>3062</i>&nbsp;                if (compound) {
<b class="nc"><i>3063</i>&nbsp;                    //error - &#39;var&#39; in compound local var decl</b>
<b class="nc"><i>3064</i>&nbsp;                   reportSyntaxError(pos, Errors.VarNotAllowedCompound);</b>
<i>3065</i>&nbsp;                } else if (type.hasTag(TYPEARRAY)) {
<b class="nc"><i>3066</i>&nbsp;                    //error - &#39;var&#39; and arrays</b>
<b class="nc"><i>3067</i>&nbsp;                    reportSyntaxError(pos, Errors.VarNotAllowedArray);</b>
<i>3068</i>&nbsp;                } else {
<b class="nc"><i>3069</i>&nbsp;                    startPos = TreeInfo.getStartPos(mods);</b>
<i>3070</i>&nbsp;                    if (startPos == Position.NOPOS)
<b class="nc"><i>3071</i>&nbsp;                        startPos = TreeInfo.getStartPos(type);</b>
<b class="nc"><i>3072</i>&nbsp;                    //implicit type</b>
<i>3073</i>&nbsp;                    type = null;
<i>3074</i>&nbsp;                }
<b class="nc"><i>3075</i>&nbsp;            }</b>
<i>3076</i>&nbsp;        }
<b class="nc"><i>3077</i>&nbsp;        JCVariableDecl result =</b>
<i>3078</i>&nbsp;            toP(F.at(pos).VarDef(mods, name, type, init));
<b class="nc"><i>3079</i>&nbsp;        attach(result, dc);</b>
<b class="nc"><i>3080</i>&nbsp;        result.startPos = startPos;</b>
<i>3081</i>&nbsp;        return result;
<i>3082</i>&nbsp;    }
<i>3083</i>&nbsp;
<i>3084</i>&nbsp;    boolean isRestrictedLocalVarTypeName(JCExpression e, boolean shouldWarn) {
<i>3085</i>&nbsp;        switch (e.getTag()) {
<b class="nc"><i>3086</i>&nbsp;            case IDENT:</b>
<b class="nc"><i>3087</i>&nbsp;                return isRestrictedLocalVarTypeName(((JCIdent)e).name, e.pos, shouldWarn);</b>
<b class="nc"><i>3088</i>&nbsp;            case TYPEARRAY:</b>
<i>3089</i>&nbsp;                return isRestrictedLocalVarTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
<b class="nc"><i>3090</i>&nbsp;            default:</b>
<b class="nc"><i>3091</i>&nbsp;                return false;</b>
<b class="nc"><i>3092</i>&nbsp;        }</b>
<b class="nc"><i>3093</i>&nbsp;    }</b>
<i>3094</i>&nbsp;
<b class="nc"><i>3095</i>&nbsp;    boolean isRestrictedLocalVarTypeName(Name name, int pos, boolean shouldWarn) {</b>
<i>3096</i>&nbsp;        if (name == names.var) {
<b class="nc"><i>3097</i>&nbsp;            if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {</b>
<b class="nc"><i>3098</i>&nbsp;                return true;</b>
<b class="nc"><i>3099</i>&nbsp;            } else if (shouldWarn) {</b>
<i>3100</i>&nbsp;                log.warning(pos, Warnings.VarNotAllowed);
<i>3101</i>&nbsp;            }
<i>3102</i>&nbsp;        }
<i>3103</i>&nbsp;        return false;
<i>3104</i>&nbsp;    }
<b class="nc"><i>3105</i>&nbsp;</b>
<b class="nc"><i>3106</i>&nbsp;    /** VariableDeclaratorId = Ident BracketsOpt</b>
<b class="nc"><i>3107</i>&nbsp;     */</b>
<b class="nc"><i>3108</i>&nbsp;    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {</b>
<b class="nc"><i>3109</i>&nbsp;        return variableDeclaratorId(mods, type, false);</b>
<i>3110</i>&nbsp;    }
<i>3111</i>&nbsp;    //where
<i>3112</i>&nbsp;    JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
<i>3113</i>&nbsp;        int pos = token.pos;
<i>3114</i>&nbsp;        Name name;
<b class="nc"><i>3115</i>&nbsp;        if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {</b>
<b class="nc"><i>3116</i>&nbsp;            log.error(pos, Errors.UnderscoreAsIdentifierInLambda);</b>
<b class="nc"><i>3117</i>&nbsp;            name = token.name();</b>
<b class="nc"><i>3118</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3119</i>&nbsp;        } else {</b>
<b class="nc"><i>3120</i>&nbsp;            if (allowThisIdent ||</b>
<b class="nc"><i>3121</i>&nbsp;                !lambdaParameter ||</b>
<b class="nc"><i>3122</i>&nbsp;                LAX_IDENTIFIER.accepts(token.kind) ||</b>
<b class="nc"><i>3123</i>&nbsp;                mods.flags != Flags.PARAMETER ||</b>
<i>3124</i>&nbsp;                mods.annotations.nonEmpty()) {
<b class="nc"><i>3125</i>&nbsp;                JCExpression pn = qualident(false);</b>
<b class="nc"><i>3126</i>&nbsp;                if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {</b>
<b class="nc"><i>3127</i>&nbsp;                    name = ((JCIdent)pn).name;</b>
<b class="nc"><i>3128</i>&nbsp;                } else {</b>
<b class="nc"><i>3129</i>&nbsp;                    if (allowThisIdent) {</b>
<b class="nc"><i>3130</i>&nbsp;                        if ((mods.flags &amp; Flags.VARARGS) != 0) {</b>
<i>3131</i>&nbsp;                            log.error(token.pos, Errors.VarargsAndReceiver);
<b class="nc"><i>3132</i>&nbsp;                        }</b>
<b class="nc"><i>3133</i>&nbsp;                        if (token.kind == LBRACKET) {</b>
<b class="nc"><i>3134</i>&nbsp;                            log.error(token.pos, Errors.ArrayAndReceiver);</b>
<i>3135</i>&nbsp;                        }
<b class="nc"><i>3136</i>&nbsp;                        if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {</b>
<b class="nc"><i>3137</i>&nbsp;                            log.error(token.pos, Errors.WrongReceiver);</b>
<b class="nc"><i>3138</i>&nbsp;                        }</b>
<b class="nc"><i>3139</i>&nbsp;                    }</b>
<b class="nc"><i>3140</i>&nbsp;                    return toP(F.at(pos).ReceiverVarDef(mods, pn, type));</b>
<i>3141</i>&nbsp;                }
<b class="nc"><i>3142</i>&nbsp;            } else {</b>
<b class="nc"><i>3143</i>&nbsp;                /** if it is a lambda parameter and the token kind is not an identifier,</b>
<b class="nc"><i>3144</i>&nbsp;                 *  and there are no modifiers or annotations, then this means that the compiler</b>
<i>3145</i>&nbsp;                 *  supposed the lambda to be explicit but it can contain a mix of implicit,
<b class="nc"><i>3146</i>&nbsp;                 *  var or explicit parameters. So we assign the error name to the parameter name</b>
<b class="nc"><i>3147</i>&nbsp;                 *  instead of issuing an error and analyze the lambda parameters as a whole at</b>
<b class="nc"><i>3148</i>&nbsp;                 *  a higher level.</b>
<i>3149</i>&nbsp;                 */
<b class="nc"><i>3150</i>&nbsp;                name = names.empty;</b>
<b class="nc"><i>3151</i>&nbsp;            }</b>
<b class="nc"><i>3152</i>&nbsp;        }</b>
<b class="nc"><i>3153</i>&nbsp;        if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;</b>
<i>3154</i>&nbsp;                token.kind == LBRACKET) {
<b class="nc"><i>3155</i>&nbsp;            log.error(token.pos, Errors.VarargsAndOldArraySyntax);</b>
<b class="nc"><i>3156</i>&nbsp;        }</b>
<b class="nc"><i>3157</i>&nbsp;        type = bracketsOpt(type);</b>
<b class="nc"><i>3158</i>&nbsp;        return toP(F.at(pos).VarDef(mods, name, type, null));</b>
<b class="nc"><i>3159</i>&nbsp;    }</b>
<b class="nc"><i>3160</i>&nbsp;</b>
<b class="nc"><i>3161</i>&nbsp;    /** Resources = Resource { &quot;;&quot; Resources }</b>
<b class="nc"><i>3162</i>&nbsp;     */</b>
<b class="nc"><i>3163</i>&nbsp;    List&lt;JCTree&gt; resources() {</b>
<i>3164</i>&nbsp;        ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
<b class="nc"><i>3165</i>&nbsp;        defs.append(resource());</b>
<b class="nc"><i>3166</i>&nbsp;        while (token.kind == SEMI) {</b>
<b class="nc"><i>3167</i>&nbsp;            // All but last of multiple declarators must subsume a semicolon</b>
<b class="nc"><i>3168</i>&nbsp;            storeEnd(defs.last(), token.endPos);</b>
<b class="nc"><i>3169</i>&nbsp;            int semiColonPos = token.pos;</b>
<b class="nc"><i>3170</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3171</i>&nbsp;            if (token.kind == RPAREN) { // Optional trailing semicolon</b>
<b class="nc"><i>3172</i>&nbsp;                                       // after last resource</b>
<b class="nc"><i>3173</i>&nbsp;                break;</b>
<b class="nc"><i>3174</i>&nbsp;            }</b>
<b class="nc"><i>3175</i>&nbsp;            defs.append(resource());</b>
<b class="nc"><i>3176</i>&nbsp;        }</b>
<i>3177</i>&nbsp;        return defs.toList();
<i>3178</i>&nbsp;    }
<i>3179</i>&nbsp;
<i>3180</i>&nbsp;    /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
<i>3181</i>&nbsp;     *           | Expression
<b class="nc"><i>3182</i>&nbsp;     */</b>
<b class="nc"><i>3183</i>&nbsp;    protected JCTree resource() {</b>
<b class="nc"><i>3184</i>&nbsp;        int startPos = token.pos;</b>
<b class="nc"><i>3185</i>&nbsp;        if (token.kind == FINAL || token.kind == MONKEYS_AT) {</b>
<b class="nc"><i>3186</i>&nbsp;            JCModifiers mods = optFinal(Flags.FINAL);</b>
<b class="nc"><i>3187</i>&nbsp;            JCExpression t = parseType(true);</b>
<b class="nc"><i>3188</i>&nbsp;            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);</b>
<i>3189</i>&nbsp;        }
<b class="nc"><i>3190</i>&nbsp;        JCExpression t = term(EXPR | TYPE);</b>
<i>3191</i>&nbsp;        if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
<b class="nc"><i>3192</i>&nbsp;            JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));</b>
<b class="nc"><i>3193</i>&nbsp;            return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);</b>
<b class="nc"><i>3194</i>&nbsp;        } else {</b>
<b class="nc"><i>3195</i>&nbsp;            checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);</b>
<b class="nc"><i>3196</i>&nbsp;            if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {</b>
<b class="nc"><i>3197</i>&nbsp;                log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);</b>
<i>3198</i>&nbsp;            }
<b class="nc"><i>3199</i>&nbsp;</b>
<i>3200</i>&nbsp;            return t;
<b class="nc"><i>3201</i>&nbsp;        }</b>
<b class="nc"><i>3202</i>&nbsp;    }</b>
<b class="nc"><i>3203</i>&nbsp;</b>
<i>3204</i>&nbsp;    /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
<i>3205</i>&nbsp;     */
<i>3206</i>&nbsp;    public JCTree.JCCompilationUnit parseCompilationUnit() {
<i>3207</i>&nbsp;        Token firstToken = token;
<i>3208</i>&nbsp;        JCModifiers mods = null;
<i>3209</i>&nbsp;        boolean consumedToplevelDoc = false;
<b class="nc"><i>3210</i>&nbsp;        boolean seenImport = false;</b>
<b class="nc"><i>3211</i>&nbsp;        boolean seenPackage = false;</b>
<b class="nc"><i>3212</i>&nbsp;        ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>3213</i>&nbsp;        if (token.kind == MONKEYS_AT)</b>
<i>3214</i>&nbsp;            mods = modifiersOpt();
<b class="nc"><i>3215</i>&nbsp;</b>
<i>3216</i>&nbsp;        if (token.kind == PACKAGE) {
<i>3217</i>&nbsp;            int packagePos = token.pos;
<i>3218</i>&nbsp;            List&lt;JCAnnotation&gt; annotations = List.nil();
<i>3219</i>&nbsp;            seenPackage = true;
<i>3220</i>&nbsp;            if (mods != null) {
<i>3221</i>&nbsp;                checkNoMods(mods.flags);
<i>3222</i>&nbsp;                annotations = mods.annotations;
<i>3223</i>&nbsp;                mods = null;
<i>3224</i>&nbsp;            }
<b class="nc"><i>3225</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3226</i>&nbsp;            JCExpression pid = qualident(false);</b>
<b class="nc"><i>3227</i>&nbsp;            accept(SEMI);</b>
<b class="nc"><i>3228</i>&nbsp;            JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));</b>
<b class="nc"><i>3229</i>&nbsp;            attach(pd, firstToken.comment(CommentStyle.JAVADOC));</b>
<b class="nc"><i>3230</i>&nbsp;            consumedToplevelDoc = true;</b>
<b class="nc"><i>3231</i>&nbsp;            defs.append(pd);</b>
<i>3232</i>&nbsp;        }
<b class="nc"><i>3233</i>&nbsp;</b>
<i>3234</i>&nbsp;        boolean checkForImports = true;
<b class="nc"><i>3235</i>&nbsp;        boolean firstTypeDecl = true;</b>
<b class="nc"><i>3236</i>&nbsp;        while (token.kind != EOF) {</b>
<b class="nc"><i>3237</i>&nbsp;            if (token.pos &lt;= endPosTable.errorEndPos) {</b>
<i>3238</i>&nbsp;                // error recovery
<b class="nc"><i>3239</i>&nbsp;                skip(checkForImports, false, false, false);</b>
<i>3240</i>&nbsp;                if (token.kind == EOF)
<b class="nc"><i>3241</i>&nbsp;                    break;</b>
<i>3242</i>&nbsp;            }
<i>3243</i>&nbsp;            if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
<i>3244</i>&nbsp;                seenImport = true;
<b class="nc"><i>3245</i>&nbsp;                defs.append(importDeclaration());</b>
<b class="nc"><i>3246</i>&nbsp;            } else {</b>
<b class="nc"><i>3247</i>&nbsp;                Comment docComment = token.comment(CommentStyle.JAVADOC);</b>
<b class="nc"><i>3248</i>&nbsp;                if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {</b>
<i>3249</i>&nbsp;                    docComment = firstToken.comment(CommentStyle.JAVADOC);
<b class="nc"><i>3250</i>&nbsp;                    consumedToplevelDoc = true;</b>
<i>3251</i>&nbsp;                }
<b class="nc"><i>3252</i>&nbsp;                if (mods != null || token.kind != SEMI)</b>
<b class="nc"><i>3253</i>&nbsp;                    mods = modifiersOpt(mods);</b>
<b class="nc"><i>3254</i>&nbsp;                if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {</b>
<i>3255</i>&nbsp;                    ModuleKind kind = ModuleKind.STRONG;
<b class="nc"><i>3256</i>&nbsp;                    if (token.name() == names.open) {</b>
<i>3257</i>&nbsp;                        kind = ModuleKind.OPEN;
<b class="nc"><i>3258</i>&nbsp;                        nextToken();</b>
<i>3259</i>&nbsp;                    }
<i>3260</i>&nbsp;                    if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
<i>3261</i>&nbsp;                        if (mods != null) {
<i>3262</i>&nbsp;                            checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
<i>3263</i>&nbsp;                        }
<i>3264</i>&nbsp;                        defs.append(moduleDecl(mods, kind, docComment));
<i>3265</i>&nbsp;                        consumedToplevelDoc = true;
<i>3266</i>&nbsp;                        break;
<i>3267</i>&nbsp;                    } else if (kind != ModuleKind.STRONG) {
<i>3268</i>&nbsp;                        reportSyntaxError(token.pos, Errors.ExpectedModule);
<b class="nc"><i>3269</i>&nbsp;                    }</b>
<b class="nc"><i>3270</i>&nbsp;                }</b>
<b class="nc"><i>3271</i>&nbsp;                JCTree def = typeDeclaration(mods, docComment);</b>
<i>3272</i>&nbsp;                if (def instanceof JCExpressionStatement)
<b class="nc"><i>3273</i>&nbsp;                    def = ((JCExpressionStatement)def).expr;</b>
<i>3274</i>&nbsp;                defs.append(def);
<b class="nc"><i>3275</i>&nbsp;                if (def instanceof JCClassDecl)</b>
<b class="nc"><i>3276</i>&nbsp;                    checkForImports = false;</b>
<b class="nc"><i>3277</i>&nbsp;                mods = null;</b>
<b class="nc"><i>3278</i>&nbsp;                firstTypeDecl = false;</b>
<i>3279</i>&nbsp;            }
<b class="nc"><i>3280</i>&nbsp;        }</b>
<b class="nc"><i>3281</i>&nbsp;        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());</b>
<b class="nc"><i>3282</i>&nbsp;        if (!consumedToplevelDoc)</b>
<b class="nc"><i>3283</i>&nbsp;            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));</b>
<i>3284</i>&nbsp;        if (defs.isEmpty())
<b class="nc"><i>3285</i>&nbsp;            storeEnd(toplevel, S.prevToken().endPos);</b>
<b class="nc"><i>3286</i>&nbsp;        if (keepDocComments)</b>
<i>3287</i>&nbsp;            toplevel.docComments = docComments;
<b class="nc"><i>3288</i>&nbsp;        if (keepLineMap)</b>
<b class="nc"><i>3289</i>&nbsp;            toplevel.lineMap = S.getLineMap();</b>
<i>3290</i>&nbsp;        this.endPosTable.setParser(null); // remove reference to parser
<i>3291</i>&nbsp;        toplevel.endPositions = this.endPosTable;
<i>3292</i>&nbsp;        return toplevel;
<i>3293</i>&nbsp;    }
<i>3294</i>&nbsp;
<i>3295</i>&nbsp;    JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
<i>3296</i>&nbsp;        int pos = token.pos;
<i>3297</i>&nbsp;        checkSourceLevel(Feature.MODULES);
<b class="nc"><i>3298</i>&nbsp;</b>
<b class="nc"><i>3299</i>&nbsp;        nextToken();</b>
<b class="nc"><i>3300</i>&nbsp;        JCExpression name = qualident(false);</b>
<i>3301</i>&nbsp;        List&lt;JCDirective&gt; directives = null;
<b class="nc"><i>3302</i>&nbsp;</b>
<i>3303</i>&nbsp;        accept(LBRACE);
<b class="nc"><i>3304</i>&nbsp;        directives = moduleDirectiveList();</b>
<b class="nc"><i>3305</i>&nbsp;        accept(RBRACE);</b>
<b class="nc"><i>3306</i>&nbsp;        accept(EOF);</b>
<b class="nc"><i>3307</i>&nbsp;</b>
<i>3308</i>&nbsp;        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
<b class="nc"><i>3309</i>&nbsp;        attach(result, dc);</b>
<b class="nc"><i>3310</i>&nbsp;        return result;</b>
<i>3311</i>&nbsp;    }
<b class="nc"><i>3312</i>&nbsp;</b>
<b class="nc"><i>3313</i>&nbsp;    List&lt;JCDirective&gt; moduleDirectiveList() {</b>
<i>3314</i>&nbsp;        ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
<i>3315</i>&nbsp;        while (token.kind == IDENTIFIER) {
<i>3316</i>&nbsp;            int pos = token.pos;
<i>3317</i>&nbsp;            if (token.name() == names.requires) {
<i>3318</i>&nbsp;                nextToken();
<i>3319</i>&nbsp;                boolean isTransitive = false;
<i>3320</i>&nbsp;                boolean isStaticPhase = false;
<b class="nc"><i>3321</i>&nbsp;            loop:</b>
<b class="nc"><i>3322</i>&nbsp;                while (true) {</b>
<b class="nc"><i>3323</i>&nbsp;                    switch (token.kind) {</b>
<i>3324</i>&nbsp;                        case IDENTIFIER:
<b class="nc"><i>3325</i>&nbsp;                            if (token.name() == names.transitive &amp;&amp; !isTransitive) {</b>
<b class="nc"><i>3326</i>&nbsp;                                Token t1 = S.token(1);</b>
<b class="nc"><i>3327</i>&nbsp;                                if (t1.kind == SEMI || t1.kind == DOT) {</b>
<b class="nc"><i>3328</i>&nbsp;                                    break loop;</b>
<i>3329</i>&nbsp;                                }
<i>3330</i>&nbsp;                                isTransitive = true;
<b class="nc"><i>3331</i>&nbsp;                                break;</b>
<b class="nc"><i>3332</i>&nbsp;                            } else {</b>
<b class="nc"><i>3333</i>&nbsp;                                break loop;</b>
<b class="nc"><i>3334</i>&nbsp;                            }</b>
<i>3335</i>&nbsp;                        case STATIC:
<b class="nc"><i>3336</i>&nbsp;                            if (isStaticPhase) {</b>
<b class="nc"><i>3337</i>&nbsp;                                log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);</b>
<i>3338</i>&nbsp;                            }
<i>3339</i>&nbsp;                            isStaticPhase = true;
<i>3340</i>&nbsp;                            break;
<i>3341</i>&nbsp;                        default:
<i>3342</i>&nbsp;                            break loop;
<i>3343</i>&nbsp;                    }
<b class="nc"><i>3344</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>3345</i>&nbsp;                }</b>
<b class="nc"><i>3346</i>&nbsp;                JCExpression moduleName = qualident(false);</b>
<b class="nc"><i>3347</i>&nbsp;                accept(SEMI);</b>
<b class="nc"><i>3348</i>&nbsp;                defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));</b>
<b class="nc"><i>3349</i>&nbsp;            } else if (token.name() == names.exports || token.name() == names.opens) {</b>
<b class="nc"><i>3350</i>&nbsp;                boolean exports = token.name() == names.exports;</b>
<b class="nc"><i>3351</i>&nbsp;                nextToken();</b>
<b class="nc"><i>3352</i>&nbsp;                JCExpression pkgName = qualident(false);</b>
<b class="nc"><i>3353</i>&nbsp;                List&lt;JCExpression&gt; moduleNames = null;</b>
<i>3354</i>&nbsp;                if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
<b class="nc"><i>3355</i>&nbsp;                    nextToken();</b>
<b class="nc"><i>3356</i>&nbsp;                    moduleNames = qualidentList(false);</b>
<i>3357</i>&nbsp;                }
<b class="nc"><i>3358</i>&nbsp;                accept(SEMI);</b>
<i>3359</i>&nbsp;                JCDirective d;
<i>3360</i>&nbsp;                if (exports) {
<b class="nc"><i>3361</i>&nbsp;                    d = F.at(pos).Exports(pkgName, moduleNames);</b>
<b class="nc"><i>3362</i>&nbsp;                } else {</b>
<b class="nc"><i>3363</i>&nbsp;                    d = F.at(pos).Opens(pkgName, moduleNames);</b>
<b class="nc"><i>3364</i>&nbsp;                }</b>
<i>3365</i>&nbsp;                defs.append(toP(d));
<b class="nc"><i>3366</i>&nbsp;            } else if (token.name() == names.provides) {</b>
<i>3367</i>&nbsp;                nextToken();
<b class="nc"><i>3368</i>&nbsp;                JCExpression serviceName = qualident(false);</b>
<i>3369</i>&nbsp;                if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
<i>3370</i>&nbsp;                    nextToken();
<i>3371</i>&nbsp;                    List&lt;JCExpression&gt; implNames = qualidentList(false);
<b class="nc"><i>3372</i>&nbsp;                    accept(SEMI);</b>
<b class="nc"><i>3373</i>&nbsp;                    defs.append(toP(F.at(pos).Provides(serviceName, implNames)));</b>
<i>3374</i>&nbsp;                } else {
<i>3375</i>&nbsp;                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
<i>3376</i>&nbsp;                    skip(false, false, false, false);
<i>3377</i>&nbsp;                }
<i>3378</i>&nbsp;            } else if (token.name() == names.uses) {
<b class="nc"><i>3379</i>&nbsp;                nextToken();</b>
<b class="nc"><i>3380</i>&nbsp;                JCExpression service = qualident(false);</b>
<b class="nc"><i>3381</i>&nbsp;                accept(SEMI);</b>
<b class="nc"><i>3382</i>&nbsp;                defs.append(toP(F.at(pos).Uses(service)));</b>
<i>3383</i>&nbsp;            } else {
<b class="nc"><i>3384</i>&nbsp;                setErrorEndPos(pos);</b>
<b class="nc"><i>3385</i>&nbsp;                reportSyntaxError(pos, Errors.InvalidModuleDirective);</b>
<b class="nc"><i>3386</i>&nbsp;                break;</b>
<b class="nc"><i>3387</i>&nbsp;            }</b>
<b class="nc"><i>3388</i>&nbsp;        }</b>
<b class="nc"><i>3389</i>&nbsp;        return defs.toList();</b>
<b class="nc"><i>3390</i>&nbsp;    }</b>
<b class="nc"><i>3391</i>&nbsp;</b>
<b class="nc"><i>3392</i>&nbsp;    /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;</b>
<b class="nc"><i>3393</i>&nbsp;     */</b>
<b class="nc"><i>3394</i>&nbsp;    protected JCTree importDeclaration() {</b>
<b class="nc"><i>3395</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>3396</i>&nbsp;        nextToken();</b>
<b class="nc"><i>3397</i>&nbsp;        boolean importStatic = false;</b>
<i>3398</i>&nbsp;        if (token.kind == STATIC) {
<b class="nc"><i>3399</i>&nbsp;            importStatic = true;</b>
<b class="nc"><i>3400</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3401</i>&nbsp;        }</b>
<b class="nc"><i>3402</i>&nbsp;        JCExpression pid = toP(F.at(token.pos).Ident(ident()));</b>
<b class="nc"><i>3403</i>&nbsp;        do {</b>
<b class="nc"><i>3404</i>&nbsp;            int pos1 = token.pos;</b>
<b class="nc"><i>3405</i>&nbsp;            accept(DOT);</b>
<b class="nc"><i>3406</i>&nbsp;            if (token.kind == STAR) {</b>
<b class="nc"><i>3407</i>&nbsp;                pid = to(F.at(pos1).Select(pid, names.asterisk));</b>
<b class="nc"><i>3408</i>&nbsp;                nextToken();</b>
<i>3409</i>&nbsp;                break;
<i>3410</i>&nbsp;            } else {
<i>3411</i>&nbsp;                pid = toP(F.at(pos1).Select(pid, ident()));
<i>3412</i>&nbsp;            }
<i>3413</i>&nbsp;        } while (token.kind == DOT);
<b class="nc"><i>3414</i>&nbsp;        accept(SEMI);</b>
<b class="nc"><i>3415</i>&nbsp;        return toP(F.at(pos).Import(pid, importStatic));</b>
<b class="nc"><i>3416</i>&nbsp;    }</b>
<b class="nc"><i>3417</i>&nbsp;</b>
<b class="nc"><i>3418</i>&nbsp;    /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration</b>
<i>3419</i>&nbsp;     *                  | &quot;;&quot;
<b class="nc"><i>3420</i>&nbsp;     */</b>
<i>3421</i>&nbsp;    JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
<i>3422</i>&nbsp;        int pos = token.pos;
<i>3423</i>&nbsp;        if (mods == null &amp;&amp; token.kind == SEMI) {
<i>3424</i>&nbsp;            nextToken();
<i>3425</i>&nbsp;            return toP(F.at(pos).Skip());
<i>3426</i>&nbsp;        } else {
<b class="nc"><i>3427</i>&nbsp;            return classOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);</b>
<b class="nc"><i>3428</i>&nbsp;        }</b>
<i>3429</i>&nbsp;    }
<b class="nc"><i>3430</i>&nbsp;</b>
<b class="nc"><i>3431</i>&nbsp;    /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt</b>
<b class="nc"><i>3432</i>&nbsp;     *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)</b>
<i>3433</i>&nbsp;     *  @param mods     Any modifiers starting the class or interface declaration
<b class="nc"><i>3434</i>&nbsp;     *  @param dc       The documentation comment for the class, or null.</b>
<b class="nc"><i>3435</i>&nbsp;     */</b>
<b class="nc"><i>3436</i>&nbsp;    protected JCStatement classOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {</b>
<b class="nc"><i>3437</i>&nbsp;        if (token.kind == CLASS) {</b>
<i>3438</i>&nbsp;            return classDeclaration(mods, dc);
<b class="nc"><i>3439</i>&nbsp;        } else if (token.kind == INTERFACE) {</b>
<i>3440</i>&nbsp;            return interfaceDeclaration(mods, dc);
<i>3441</i>&nbsp;        } else if (token.kind == ENUM) {
<b class="nc"><i>3442</i>&nbsp;            return enumDeclaration(mods, dc);</b>
<b class="nc"><i>3443</i>&nbsp;        } else {</b>
<i>3444</i>&nbsp;            int pos = token.pos;
<i>3445</i>&nbsp;            List&lt;JCTree&gt; errs;
<i>3446</i>&nbsp;            if (LAX_IDENTIFIER.accepts(token.kind)) {
<i>3447</i>&nbsp;                errs = List.of(mods, toP(F.at(pos).Ident(ident())));
<i>3448</i>&nbsp;                setErrorEndPos(token.pos);
<i>3449</i>&nbsp;            } else {
<i>3450</i>&nbsp;                errs = List.of(mods);
<i>3451</i>&nbsp;            }
<i>3452</i>&nbsp;            final JCErroneous erroneousTree;
<i>3453</i>&nbsp;            if (parseModuleInfo) {
<i>3454</i>&nbsp;                erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
<i>3455</i>&nbsp;            } else {
<i>3456</i>&nbsp;                erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
<i>3457</i>&nbsp;            }
<i>3458</i>&nbsp;            return toP(F.Exec(erroneousTree));
<i>3459</i>&nbsp;        }
<i>3460</i>&nbsp;    }
<i>3461</i>&nbsp;
<i>3462</i>&nbsp;    /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
<i>3463</i>&nbsp;     *                     [IMPLEMENTS TypeList] ClassBody
<i>3464</i>&nbsp;     *  @param mods    The modifiers starting the class declaration
<i>3465</i>&nbsp;     *  @param dc       The documentation comment for the class, or null.
<i>3466</i>&nbsp;     */
<i>3467</i>&nbsp;    protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
<i>3468</i>&nbsp;        int pos = token.pos;
<i>3469</i>&nbsp;        accept(CLASS);
<i>3470</i>&nbsp;        Name name = typeName();
<i>3471</i>&nbsp;
<i>3472</i>&nbsp;        List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
<i>3473</i>&nbsp;
<i>3474</i>&nbsp;        JCExpression extending = null;
<i>3475</i>&nbsp;        if (token.kind == EXTENDS) {
<b class="nc"><i>3476</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3477</i>&nbsp;            extending = parseType();</b>
<b class="nc"><i>3478</i>&nbsp;        }</b>
<i>3479</i>&nbsp;        List&lt;JCExpression&gt; implementing = List.nil();
<b class="nc"><i>3480</i>&nbsp;        if (token.kind == IMPLEMENTS) {</b>
<b class="nc"><i>3481</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3482</i>&nbsp;            implementing = typeList();</b>
<b class="nc"><i>3483</i>&nbsp;        }</b>
<i>3484</i>&nbsp;        List&lt;JCTree&gt; defs = classOrInterfaceBody(name, false);
<i>3485</i>&nbsp;        JCClassDecl result = toP(F.at(pos).ClassDef(
<b class="nc"><i>3486</i>&nbsp;            mods, name, typarams, extending, implementing, defs));</b>
<b class="nc"><i>3487</i>&nbsp;        attach(result, dc);</b>
<i>3488</i>&nbsp;        return result;
<b class="nc"><i>3489</i>&nbsp;    }</b>
<b class="nc"><i>3490</i>&nbsp;</b>
<i>3491</i>&nbsp;    Name typeName() {
<b class="nc"><i>3492</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>3493</i>&nbsp;        Name name = ident();</b>
<i>3494</i>&nbsp;        if (isRestrictedLocalVarTypeName(name, pos, true)) {
<i>3495</i>&nbsp;            reportSyntaxError(pos, Errors.VarNotAllowed);
<b class="nc"><i>3496</i>&nbsp;        }</b>
<b class="nc"><i>3497</i>&nbsp;        return name;</b>
<b class="nc"><i>3498</i>&nbsp;    }</b>
<i>3499</i>&nbsp;
<b class="nc"><i>3500</i>&nbsp;    /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt</b>
<i>3501</i>&nbsp;     *                         [EXTENDS TypeList] InterfaceBody
<b class="nc"><i>3502</i>&nbsp;     *  @param mods    The modifiers starting the interface declaration</b>
<b class="nc"><i>3503</i>&nbsp;     *  @param dc       The documentation comment for the interface, or null.</b>
<b class="nc"><i>3504</i>&nbsp;     */</b>
<b class="nc"><i>3505</i>&nbsp;    protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {</b>
<b class="nc"><i>3506</i>&nbsp;        int pos = token.pos;</b>
<i>3507</i>&nbsp;        accept(INTERFACE);
<i>3508</i>&nbsp;
<b class="nc"><i>3509</i>&nbsp;        Name name = typeName();</b>
<b class="nc"><i>3510</i>&nbsp;</b>
<i>3511</i>&nbsp;        List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
<b class="nc"><i>3512</i>&nbsp;</b>
<b class="nc"><i>3513</i>&nbsp;        List&lt;JCExpression&gt; extending = List.nil();</b>
<b class="nc"><i>3514</i>&nbsp;        if (token.kind == EXTENDS) {</b>
<b class="nc"><i>3515</i>&nbsp;            nextToken();</b>
<i>3516</i>&nbsp;            extending = typeList();
<i>3517</i>&nbsp;        }
<b class="nc"><i>3518</i>&nbsp;        List&lt;JCTree&gt; defs = classOrInterfaceBody(name, true);</b>
<i>3519</i>&nbsp;        JCClassDecl result = toP(F.at(pos).ClassDef(
<b class="nc"><i>3520</i>&nbsp;            mods, name, typarams, null, extending, defs));</b>
<b class="nc"><i>3521</i>&nbsp;        attach(result, dc);</b>
<b class="nc"><i>3522</i>&nbsp;        return result;</b>
<b class="nc"><i>3523</i>&nbsp;    }</b>
<b class="nc"><i>3524</i>&nbsp;</b>
<b class="nc"><i>3525</i>&nbsp;    /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody</b>
<i>3526</i>&nbsp;     *  @param mods    The modifiers starting the enum declaration
<i>3527</i>&nbsp;     *  @param dc       The documentation comment for the enum, or null.
<i>3528</i>&nbsp;     */
<b class="nc"><i>3529</i>&nbsp;    protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {</b>
<b class="nc"><i>3530</i>&nbsp;        int pos = token.pos;</b>
<b class="nc"><i>3531</i>&nbsp;        accept(ENUM);</b>
<b class="nc"><i>3532</i>&nbsp;</b>
<i>3533</i>&nbsp;        Name name = typeName();
<i>3534</i>&nbsp;
<b class="nc"><i>3535</i>&nbsp;        List&lt;JCExpression&gt; implementing = List.nil();</b>
<b class="nc"><i>3536</i>&nbsp;        if (token.kind == IMPLEMENTS) {</b>
<b class="nc"><i>3537</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3538</i>&nbsp;            implementing = typeList();</b>
<b class="nc"><i>3539</i>&nbsp;        }</b>
<b class="nc"><i>3540</i>&nbsp;</b>
<b class="nc"><i>3541</i>&nbsp;        List&lt;JCTree&gt; defs = enumBody(name);</b>
<i>3542</i>&nbsp;        mods.flags |= Flags.ENUM;
<b class="nc"><i>3543</i>&nbsp;        JCClassDecl result = toP(F.at(pos).</b>
<b class="nc"><i>3544</i>&nbsp;            ClassDef(mods, name, List.nil(),</b>
<b class="nc"><i>3545</i>&nbsp;                     null, implementing, defs));</b>
<b class="nc"><i>3546</i>&nbsp;        attach(result, dc);</b>
<i>3547</i>&nbsp;        return result;
<b class="nc"><i>3548</i>&nbsp;    }</b>
<i>3549</i>&nbsp;
<i>3550</i>&nbsp;    /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
<i>3551</i>&nbsp;     *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
<i>3552</i>&nbsp;     */
<i>3553</i>&nbsp;    List&lt;JCTree&gt; enumBody(Name enumName) {
<i>3554</i>&nbsp;        accept(LBRACE);
<i>3555</i>&nbsp;        ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
<i>3556</i>&nbsp;        if (token.kind == COMMA) {
<i>3557</i>&nbsp;            nextToken();
<i>3558</i>&nbsp;        } else if (token.kind != RBRACE &amp;&amp; token.kind != SEMI) {
<i>3559</i>&nbsp;            defs.append(enumeratorDeclaration(enumName));
<i>3560</i>&nbsp;            while (token.kind == COMMA) {
<i>3561</i>&nbsp;                nextToken();
<i>3562</i>&nbsp;                if (token.kind == RBRACE || token.kind == SEMI) break;
<i>3563</i>&nbsp;                defs.append(enumeratorDeclaration(enumName));
<i>3564</i>&nbsp;            }
<i>3565</i>&nbsp;            if (token.kind != SEMI &amp;&amp; token.kind != RBRACE) {
<i>3566</i>&nbsp;                defs.append(syntaxError(token.pos, Errors.Expected3(COMMA, RBRACE, SEMI)));
<i>3567</i>&nbsp;                nextToken();
<i>3568</i>&nbsp;            }
<b class="nc"><i>3569</i>&nbsp;        }</b>
<b class="nc"><i>3570</i>&nbsp;        if (token.kind == SEMI) {</b>
<i>3571</i>&nbsp;            nextToken();
<b class="nc"><i>3572</i>&nbsp;            while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {</b>
<i>3573</i>&nbsp;                defs.appendList(classOrInterfaceBodyDeclaration(enumName,
<b class="nc"><i>3574</i>&nbsp;                                                                false));</b>
<i>3575</i>&nbsp;                if (token.pos &lt;= endPosTable.errorEndPos) {
<b class="nc"><i>3576</i>&nbsp;                    // error recovery</b>
<b class="nc"><i>3577</i>&nbsp;                   skip(false, true, true, false);</b>
<b class="nc"><i>3578</i>&nbsp;                }</b>
<b class="nc"><i>3579</i>&nbsp;            }</b>
<b class="nc"><i>3580</i>&nbsp;        }</b>
<b class="nc"><i>3581</i>&nbsp;        accept(RBRACE);</b>
<i>3582</i>&nbsp;        return defs.toList();
<b class="nc"><i>3583</i>&nbsp;    }</b>
<i>3584</i>&nbsp;
<b class="nc"><i>3585</i>&nbsp;    /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]</b>
<b class="nc"><i>3586</i>&nbsp;     */</b>
<b class="nc"><i>3587</i>&nbsp;    JCTree enumeratorDeclaration(Name enumName) {</b>
<i>3588</i>&nbsp;        Comment dc = token.comment(CommentStyle.JAVADOC);
<b class="nc"><i>3589</i>&nbsp;        int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;</b>
<b class="nc"><i>3590</i>&nbsp;        if (token.deprecatedFlag()) {</b>
<b class="nc"><i>3591</i>&nbsp;            flags |= Flags.DEPRECATED;</b>
<i>3592</i>&nbsp;        }
<b class="nc"><i>3593</i>&nbsp;        int pos = token.pos;</b>
<i>3594</i>&nbsp;        List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
<b class="nc"><i>3595</i>&nbsp;        JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);</b>
<b class="nc"><i>3596</i>&nbsp;        List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();</b>
<i>3597</i>&nbsp;        int identPos = token.pos;
<b class="nc"><i>3598</i>&nbsp;        Name name = ident();</b>
<b class="nc"><i>3599</i>&nbsp;        int createPos = token.pos;</b>
<b class="nc"><i>3600</i>&nbsp;        List&lt;JCExpression&gt; args = (token.kind == LPAREN)</b>
<i>3601</i>&nbsp;            ? arguments() : List.nil();
<i>3602</i>&nbsp;        JCClassDecl body = null;
<i>3603</i>&nbsp;        if (token.kind == LBRACE) {
<i>3604</i>&nbsp;            JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
<b class="nc"><i>3605</i>&nbsp;            List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);</b>
<b class="nc"><i>3606</i>&nbsp;            body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));</b>
<i>3607</i>&nbsp;        }
<i>3608</i>&nbsp;        if (args.isEmpty() &amp;&amp; body == null)
<b class="nc"><i>3609</i>&nbsp;            createPos = identPos;</b>
<b class="nc"><i>3610</i>&nbsp;        JCIdent ident = F.at(identPos).Ident(enumName);</b>
<i>3611</i>&nbsp;        JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
<b class="nc"><i>3612</i>&nbsp;        if (createPos != identPos)</b>
<i>3613</i>&nbsp;            storeEnd(create, S.prevToken().endPos);
<i>3614</i>&nbsp;        ident = F.at(identPos).Ident(enumName);
<i>3615</i>&nbsp;        JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
<i>3616</i>&nbsp;        attach(result, dc);
<i>3617</i>&nbsp;        return result;
<i>3618</i>&nbsp;    }
<b class="nc"><i>3619</i>&nbsp;</b>
<i>3620</i>&nbsp;    /** TypeList = Type {&quot;,&quot; Type}
<b class="nc"><i>3621</i>&nbsp;     */</b>
<b class="nc"><i>3622</i>&nbsp;    List&lt;JCExpression&gt; typeList() {</b>
<b class="nc"><i>3623</i>&nbsp;        ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>3624</i>&nbsp;        ts.append(parseType());</b>
<b class="nc"><i>3625</i>&nbsp;        while (token.kind == COMMA) {</b>
<b class="nc"><i>3626</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3627</i>&nbsp;            ts.append(parseType());</b>
<i>3628</i>&nbsp;        }
<b class="nc"><i>3629</i>&nbsp;        return ts.toList();</b>
<b class="nc"><i>3630</i>&nbsp;    }</b>
<i>3631</i>&nbsp;
<b class="nc"><i>3632</i>&nbsp;    /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;</b>
<b class="nc"><i>3633</i>&nbsp;     *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;</b>
<b class="nc"><i>3634</i>&nbsp;     */</b>
<b class="nc"><i>3635</i>&nbsp;    List&lt;JCTree&gt; classOrInterfaceBody(Name className, boolean isInterface) {</b>
<b class="nc"><i>3636</i>&nbsp;        accept(LBRACE);</b>
<b class="nc"><i>3637</i>&nbsp;        if (token.pos &lt;= endPosTable.errorEndPos) {</b>
<b class="nc"><i>3638</i>&nbsp;            // error recovery</b>
<i>3639</i>&nbsp;            skip(false, true, false, false);
<i>3640</i>&nbsp;            if (token.kind == LBRACE)
<b class="nc"><i>3641</i>&nbsp;                nextToken();</b>
<i>3642</i>&nbsp;        }
<i>3643</i>&nbsp;        ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
<i>3644</i>&nbsp;        while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
<i>3645</i>&nbsp;            defs.appendList(classOrInterfaceBodyDeclaration(className, isInterface));
<i>3646</i>&nbsp;            if (token.pos &lt;= endPosTable.errorEndPos) {
<i>3647</i>&nbsp;               // error recovery
<i>3648</i>&nbsp;               skip(false, true, true, false);
<i>3649</i>&nbsp;           }
<b class="nc"><i>3650</i>&nbsp;        }</b>
<b class="nc"><i>3651</i>&nbsp;        accept(RBRACE);</b>
<b class="nc"><i>3652</i>&nbsp;        return defs.toList();</b>
<b class="nc"><i>3653</i>&nbsp;    }</b>
<b class="nc"><i>3654</i>&nbsp;</b>
<b class="nc"><i>3655</i>&nbsp;    /** ClassBodyDeclaration =</b>
<b class="nc"><i>3656</i>&nbsp;     *      &quot;;&quot;</b>
<b class="nc"><i>3657</i>&nbsp;     *    | [STATIC] Block</b>
<i>3658</i>&nbsp;     *    | ModifiersOpt
<b class="nc"><i>3659</i>&nbsp;     *      ( Type Ident</b>
<b class="nc"><i>3660</i>&nbsp;     *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )</b>
<i>3661</i>&nbsp;     *      | VOID Ident VoidMethodDeclaratorRest
<b class="nc"><i>3662</i>&nbsp;     *      | TypeParameters [Annotations]</b>
<i>3663</i>&nbsp;     *        ( Type Ident MethodDeclaratorRest
<i>3664</i>&nbsp;     *        | VOID Ident VoidMethodDeclaratorRest
<i>3665</i>&nbsp;     *        )
<i>3666</i>&nbsp;     *      | Ident ConstructorDeclaratorRest
<i>3667</i>&nbsp;     *      | TypeParameters Ident ConstructorDeclaratorRest
<i>3668</i>&nbsp;     *      | ClassOrInterfaceOrEnumDeclaration
<i>3669</i>&nbsp;     *      )
<i>3670</i>&nbsp;     *  InterfaceBodyDeclaration =
<i>3671</i>&nbsp;     *      &quot;;&quot;
<i>3672</i>&nbsp;     *    | ModifiersOpt
<i>3673</i>&nbsp;     *      ( Type Ident
<b class="nc"><i>3674</i>&nbsp;     *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )</b>
<b class="nc"><i>3675</i>&nbsp;     *      | VOID Ident MethodDeclaratorRest</b>
<b class="nc"><i>3676</i>&nbsp;     *      | TypeParameters [Annotations]</b>
<b class="nc"><i>3677</i>&nbsp;     *        ( Type Ident MethodDeclaratorRest</b>
<b class="nc"><i>3678</i>&nbsp;     *        | VOID Ident VoidMethodDeclaratorRest</b>
<b class="nc"><i>3679</i>&nbsp;     *        )</b>
<b class="nc"><i>3680</i>&nbsp;     *      | ClassOrInterfaceOrEnumDeclaration</b>
<b class="nc"><i>3681</i>&nbsp;     *      )</b>
<b class="nc"><i>3682</i>&nbsp;     *</b>
<b class="nc"><i>3683</i>&nbsp;     */</b>
<i>3684</i>&nbsp;    protected List&lt;JCTree&gt; classOrInterfaceBodyDeclaration(Name className, boolean isInterface) {
<i>3685</i>&nbsp;        if (token.kind == SEMI) {
<b class="nc"><i>3686</i>&nbsp;            nextToken();</b>
<i>3687</i>&nbsp;            return List.nil();
<i>3688</i>&nbsp;        } else {
<i>3689</i>&nbsp;            Comment dc = token.comment(CommentStyle.JAVADOC);
<i>3690</i>&nbsp;            int pos = token.pos;
<i>3691</i>&nbsp;            JCModifiers mods = modifiersOpt();
<i>3692</i>&nbsp;            if (token.kind == CLASS ||
<i>3693</i>&nbsp;                token.kind == INTERFACE ||
<b class="nc"><i>3694</i>&nbsp;                token.kind == ENUM) {</b>
<i>3695</i>&nbsp;                return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));
<i>3696</i>&nbsp;            } else if (token.kind == LBRACE &amp;&amp;
<b class="nc"><i>3697</i>&nbsp;                       (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;</b>
<i>3698</i>&nbsp;                       mods.annotations.isEmpty()) {
<b class="nc"><i>3699</i>&nbsp;                if (isInterface) {</b>
<b class="nc"><i>3700</i>&nbsp;                    log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);</b>
<b class="nc"><i>3701</i>&nbsp;                }</b>
<b class="nc"><i>3702</i>&nbsp;                return List.of(block(pos, mods.flags));</b>
<b class="nc"><i>3703</i>&nbsp;            } else {</b>
<b class="nc"><i>3704</i>&nbsp;                pos = token.pos;</b>
<i>3705</i>&nbsp;                List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
<b class="nc"><i>3706</i>&nbsp;                // if there are type parameters but no modifiers, save the start</b>
<i>3707</i>&nbsp;                // position of the method in the modifiers.
<b class="nc"><i>3708</i>&nbsp;                if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {</b>
<b class="nc"><i>3709</i>&nbsp;                    mods.pos = pos;</b>
<b class="nc"><i>3710</i>&nbsp;                    storeEnd(mods, pos);</b>
<b class="nc"><i>3711</i>&nbsp;                }</b>
<i>3712</i>&nbsp;                List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
<i>3713</i>&nbsp;
<b class="nc"><i>3714</i>&nbsp;                if (annosAfterParams.nonEmpty()) {</b>
<b class="nc"><i>3715</i>&nbsp;                    checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);</b>
<i>3716</i>&nbsp;                    mods.annotations = mods.annotations.appendList(annosAfterParams);
<i>3717</i>&nbsp;                    if (mods.pos == Position.NOPOS)
<i>3718</i>&nbsp;                        mods.pos = mods.annotations.head.pos;
<b class="nc"><i>3719</i>&nbsp;                }</b>
<b class="nc"><i>3720</i>&nbsp;</b>
<i>3721</i>&nbsp;                Token tk = token;
<b class="nc"><i>3722</i>&nbsp;                pos = token.pos;</b>
<b class="nc"><i>3723</i>&nbsp;                JCExpression type;</b>
<b class="nc"><i>3724</i>&nbsp;                boolean isVoid = token.kind == VOID;</b>
<b class="nc"><i>3725</i>&nbsp;                if (isVoid) {</b>
<b class="nc"><i>3726</i>&nbsp;                    type = to(F.at(pos).TypeIdent(TypeTag.VOID));</b>
<b class="nc"><i>3727</i>&nbsp;                    nextToken();</b>
<i>3728</i>&nbsp;                } else {
<i>3729</i>&nbsp;                    // method returns types are un-annotated types
<b class="nc"><i>3730</i>&nbsp;                    type = unannotatedType(false);</b>
<b class="nc"><i>3731</i>&nbsp;                }</b>
<i>3732</i>&nbsp;                if (token.kind == LPAREN &amp;&amp; !isInterface &amp;&amp; type.hasTag(IDENT)) {
<b class="nc"><i>3733</i>&nbsp;                    if (isInterface || tk.name() != className)</b>
<i>3734</i>&nbsp;                        log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
<i>3735</i>&nbsp;                    else if (annosAfterParams.nonEmpty())
<i>3736</i>&nbsp;                        illegal(annosAfterParams.head.pos);
<b class="nc"><i>3737</i>&nbsp;                    return List.of(methodDeclaratorRest(</b>
<b class="nc"><i>3738</i>&nbsp;                        pos, mods, null, names.init, typarams,</b>
<b class="nc"><i>3739</i>&nbsp;                        isInterface, true, dc));</b>
<b class="nc"><i>3740</i>&nbsp;                } else {</b>
<i>3741</i>&nbsp;                    pos = token.pos;
<i>3742</i>&nbsp;                    Name name = ident();
<i>3743</i>&nbsp;                    if (token.kind == LPAREN) {
<i>3744</i>&nbsp;                        return List.of(methodDeclaratorRest(
<i>3745</i>&nbsp;                            pos, mods, type, name, typarams,
<i>3746</i>&nbsp;                            isInterface, isVoid, dc));
<i>3747</i>&nbsp;                    } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
<i>3748</i>&nbsp;                        List&lt;JCTree&gt; defs =
<i>3749</i>&nbsp;                            variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
<i>3750</i>&nbsp;                                                    new ListBuffer&lt;JCTree&gt;(), false).toList();
<i>3751</i>&nbsp;                        accept(SEMI);
<i>3752</i>&nbsp;                        storeEnd(defs.last(), S.prevToken().endPos);
<i>3753</i>&nbsp;                        return defs;
<i>3754</i>&nbsp;                    } else {
<i>3755</i>&nbsp;                        pos = token.pos;
<i>3756</i>&nbsp;                        List&lt;JCTree&gt; err = isVoid
<i>3757</i>&nbsp;                            ? List.of(toP(F.at(pos).MethodDef(mods, name, type, typarams,
<i>3758</i>&nbsp;                                List.nil(), List.nil(), null, null)))
<i>3759</i>&nbsp;                            : null;
<i>3760</i>&nbsp;                        return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
<i>3761</i>&nbsp;                    }
<i>3762</i>&nbsp;                }
<i>3763</i>&nbsp;            }
<i>3764</i>&nbsp;        }
<b class="nc"><i>3765</i>&nbsp;    }</b>
<b class="nc"><i>3766</i>&nbsp;</b>
<b class="nc"><i>3767</i>&nbsp;    /** MethodDeclaratorRest =</b>
<b class="nc"><i>3768</i>&nbsp;     *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)</b>
<b class="nc"><i>3769</i>&nbsp;     *  VoidMethodDeclaratorRest =</b>
<b class="nc"><i>3770</i>&nbsp;     *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)</b>
<i>3771</i>&nbsp;     *  ConstructorDeclaratorRest =
<i>3772</i>&nbsp;     *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
<b class="nc"><i>3773</i>&nbsp;     */</b>
<b class="nc"><i>3774</i>&nbsp;    protected JCTree methodDeclaratorRest(int pos,</b>
<i>3775</i>&nbsp;                              JCModifiers mods,
<i>3776</i>&nbsp;                              JCExpression type,
<b class="nc"><i>3777</i>&nbsp;                              Name name,</b>
<b class="nc"><i>3778</i>&nbsp;                              List&lt;JCTypeParameter&gt; typarams,</b>
<b class="nc"><i>3779</i>&nbsp;                              boolean isInterface, boolean isVoid,</b>
<i>3780</i>&nbsp;                              Comment dc) {
<b class="nc"><i>3781</i>&nbsp;        if (isInterface) {</b>
<b class="nc"><i>3782</i>&nbsp;            if ((mods.flags &amp; Flags.STATIC) != 0) {</b>
<b class="nc"><i>3783</i>&nbsp;                checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);</b>
<b class="nc"><i>3784</i>&nbsp;            }</b>
<b class="nc"><i>3785</i>&nbsp;            if ((mods.flags &amp; Flags.PRIVATE) != 0) {</b>
<i>3786</i>&nbsp;                checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
<b class="nc"><i>3787</i>&nbsp;            }</b>
<b class="nc"><i>3788</i>&nbsp;        }</b>
<b class="nc"><i>3789</i>&nbsp;        JCVariableDecl prevReceiverParam = this.receiverParam;</b>
<i>3790</i>&nbsp;        try {
<i>3791</i>&nbsp;            this.receiverParam = null;
<i>3792</i>&nbsp;            // Parsing formalParameters sets the receiverParam, if present
<b class="nc"><i>3793</i>&nbsp;            List&lt;JCVariableDecl&gt; params = formalParameters();</b>
<i>3794</i>&nbsp;            if (!isVoid) type = bracketsOpt(type);
<b class="nc"><i>3795</i>&nbsp;            List&lt;JCExpression&gt; thrown = List.nil();</b>
<b class="nc"><i>3796</i>&nbsp;            if (token.kind == THROWS) {</b>
<b class="nc"><i>3797</i>&nbsp;                nextToken();</b>
<b class="nc"><i>3798</i>&nbsp;                thrown = qualidentList(true);</b>
<i>3799</i>&nbsp;            }
<i>3800</i>&nbsp;            JCBlock body = null;
<b class="nc"><i>3801</i>&nbsp;            JCExpression defaultValue;</b>
<i>3802</i>&nbsp;            if (token.kind == LBRACE) {
<i>3803</i>&nbsp;                body = block();
<i>3804</i>&nbsp;                defaultValue = null;
<b class="nc"><i>3805</i>&nbsp;            } else {</b>
<b class="nc"><i>3806</i>&nbsp;                if (token.kind == DEFAULT) {</b>
<i>3807</i>&nbsp;                    accept(DEFAULT);
<b class="nc"><i>3808</i>&nbsp;                    defaultValue = annotationValue();</b>
<b class="nc"><i>3809</i>&nbsp;                } else {</b>
<b class="nc"><i>3810</i>&nbsp;                    defaultValue = null;</b>
<i>3811</i>&nbsp;                }
<i>3812</i>&nbsp;                accept(SEMI);
<i>3813</i>&nbsp;                if (token.pos &lt;= endPosTable.errorEndPos) {
<i>3814</i>&nbsp;                    // error recovery
<i>3815</i>&nbsp;                    skip(false, true, false, false);
<i>3816</i>&nbsp;                    if (token.kind == LBRACE) {
<i>3817</i>&nbsp;                        body = block();
<b class="nc"><i>3818</i>&nbsp;                    }</b>
<i>3819</i>&nbsp;                }
<i>3820</i>&nbsp;            }
<b class="nc"><i>3821</i>&nbsp;</b>
<i>3822</i>&nbsp;            JCMethodDecl result =
<i>3823</i>&nbsp;                    toP(F.at(pos).MethodDef(mods, name, type, typarams,
<b class="nc"><i>3824</i>&nbsp;                                            receiverParam, params, thrown,</b>
<b class="nc"><i>3825</i>&nbsp;                                            body, defaultValue));</b>
<b class="nc"><i>3826</i>&nbsp;            attach(result, dc);</b>
<i>3827</i>&nbsp;            return result;
<b class="nc"><i>3828</i>&nbsp;        } finally {</b>
<b class="nc"><i>3829</i>&nbsp;            this.receiverParam = prevReceiverParam;</b>
<b class="nc"><i>3830</i>&nbsp;        }</b>
<b class="nc"><i>3831</i>&nbsp;    }</b>
<b class="nc"><i>3832</i>&nbsp;</b>
<i>3833</i>&nbsp;    /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
<b class="nc"><i>3834</i>&nbsp;     */</b>
<b class="nc"><i>3835</i>&nbsp;    List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {</b>
<b class="nc"><i>3836</i>&nbsp;        ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();</b>
<i>3837</i>&nbsp;
<b class="nc"><i>3838</i>&nbsp;        List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();</b>
<b class="nc"><i>3839</i>&nbsp;        JCExpression qi = qualident(allowAnnos);</b>
<i>3840</i>&nbsp;        if (!typeAnnos.isEmpty()) {
<i>3841</i>&nbsp;            JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
<b class="nc"><i>3842</i>&nbsp;            ts.append(at);</b>
<i>3843</i>&nbsp;        } else {
<b class="nc"><i>3844</i>&nbsp;            ts.append(qi);</b>
<i>3845</i>&nbsp;        }
<i>3846</i>&nbsp;        while (token.kind == COMMA) {
<i>3847</i>&nbsp;            nextToken();
<b class="nc"><i>3848</i>&nbsp;</b>
<b class="nc"><i>3849</i>&nbsp;            typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();</b>
<i>3850</i>&nbsp;            qi = qualident(allowAnnos);
<i>3851</i>&nbsp;            if (!typeAnnos.isEmpty()) {
<i>3852</i>&nbsp;                JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
<i>3853</i>&nbsp;                ts.append(at);
<i>3854</i>&nbsp;            } else {
<b class="nc"><i>3855</i>&nbsp;                ts.append(qi);</b>
<i>3856</i>&nbsp;            }
<i>3857</i>&nbsp;        }
<i>3858</i>&nbsp;        return ts.toList();
<b class="nc"><i>3859</i>&nbsp;    }</b>
<i>3860</i>&nbsp;
<i>3861</i>&nbsp;    /**
<i>3862</i>&nbsp;     *  {@literal
<b class="nc"><i>3863</i>&nbsp;     *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]</b>
<i>3864</i>&nbsp;     *  }
<i>3865</i>&nbsp;     */
<i>3866</i>&nbsp;    protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
<i>3867</i>&nbsp;        if (token.kind == LT) {
<i>3868</i>&nbsp;            ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
<b class="nc"><i>3869</i>&nbsp;            nextToken();</b>
<b class="nc"><i>3870</i>&nbsp;            typarams.append(typeParameter());</b>
<b class="nc"><i>3871</i>&nbsp;            while (token.kind == COMMA) {</b>
<b class="nc"><i>3872</i>&nbsp;                nextToken();</b>
<i>3873</i>&nbsp;                typarams.append(typeParameter());
<b class="nc"><i>3874</i>&nbsp;            }</b>
<i>3875</i>&nbsp;            accept(GT);
<i>3876</i>&nbsp;            return typarams.toList();
<i>3877</i>&nbsp;        } else {
<i>3878</i>&nbsp;            return List.nil();
<i>3879</i>&nbsp;        }
<i>3880</i>&nbsp;    }
<i>3881</i>&nbsp;
<b class="nc"><i>3882</i>&nbsp;    /**</b>
<b class="nc"><i>3883</i>&nbsp;     *  {@literal</b>
<i>3884</i>&nbsp;     *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
<i>3885</i>&nbsp;     *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
<i>3886</i>&nbsp;     *  TypeVariable = Ident
<i>3887</i>&nbsp;     *  }
<i>3888</i>&nbsp;     */
<i>3889</i>&nbsp;    JCTypeParameter typeParameter() {
<i>3890</i>&nbsp;        int pos = token.pos;
<b class="nc"><i>3891</i>&nbsp;        List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();</b>
<b class="nc"><i>3892</i>&nbsp;        Name name = typeName();</b>
<b class="nc"><i>3893</i>&nbsp;        ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>3894</i>&nbsp;        if (token.kind == EXTENDS) {</b>
<b class="nc"><i>3895</i>&nbsp;            nextToken();</b>
<i>3896</i>&nbsp;            bounds.append(parseType());
<i>3897</i>&nbsp;            while (token.kind == AMP) {
<i>3898</i>&nbsp;                nextToken();
<i>3899</i>&nbsp;                bounds.append(parseType());
<i>3900</i>&nbsp;            }
<i>3901</i>&nbsp;        }
<b class="nc"><i>3902</i>&nbsp;        return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));</b>
<i>3903</i>&nbsp;    }
<b class="nc"><i>3904</i>&nbsp;</b>
<i>3905</i>&nbsp;    /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
<b class="nc"><i>3906</i>&nbsp;     *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter</b>
<i>3907</i>&nbsp;     *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
<b class="nc"><i>3908</i>&nbsp;     */</b>
<i>3909</i>&nbsp;    List&lt;JCVariableDecl&gt; formalParameters() {
<b class="nc"><i>3910</i>&nbsp;        return formalParameters(false);</b>
<i>3911</i>&nbsp;    }
<b class="nc"><i>3912</i>&nbsp;    List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters) {</b>
<i>3913</i>&nbsp;        ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
<b class="nc"><i>3914</i>&nbsp;        JCVariableDecl lastParam;</b>
<i>3915</i>&nbsp;        accept(LPAREN);
<b class="nc"><i>3916</i>&nbsp;        if (token.kind != RPAREN) {</b>
<i>3917</i>&nbsp;            this.allowThisIdent = !lambdaParameters;
<b class="nc"><i>3918</i>&nbsp;            lastParam = formalParameter(lambdaParameters);</b>
<i>3919</i>&nbsp;            if (lastParam.nameexpr != null) {
<b class="nc"><i>3920</i>&nbsp;                this.receiverParam = lastParam;</b>
<i>3921</i>&nbsp;            } else {
<b class="nc"><i>3922</i>&nbsp;                params.append(lastParam);</b>
<i>3923</i>&nbsp;            }
<b class="nc"><i>3924</i>&nbsp;            this.allowThisIdent = false;</b>
<i>3925</i>&nbsp;            while (token.kind == COMMA) {
<b class="nc"><i>3926</i>&nbsp;                if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {</b>
<i>3927</i>&nbsp;                    log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
<b class="nc"><i>3928</i>&nbsp;                }</b>
<i>3929</i>&nbsp;                nextToken();
<b class="nc"><i>3930</i>&nbsp;                params.append(lastParam = formalParameter(lambdaParameters));</b>
<i>3931</i>&nbsp;            }
<b class="nc"><i>3932</i>&nbsp;        }</b>
<i>3933</i>&nbsp;        if (token.kind == RPAREN) {
<b class="nc"><i>3934</i>&nbsp;            nextToken();</b>
<i>3935</i>&nbsp;        } else {
<b class="nc"><i>3936</i>&nbsp;            setErrorEndPos(token.pos);</b>
<i>3937</i>&nbsp;            reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
<b class="nc"><i>3938</i>&nbsp;        }</b>
<i>3939</i>&nbsp;        return params.toList();
<b class="nc"><i>3940</i>&nbsp;    }</b>
<i>3941</i>&nbsp;
<b class="nc"><i>3942</i>&nbsp;    List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {</b>
<i>3943</i>&nbsp;        if (hasParens) {
<b class="nc"><i>3944</i>&nbsp;            accept(LPAREN);</b>
<i>3945</i>&nbsp;        }
<b class="nc"><i>3946</i>&nbsp;        ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();</b>
<i>3947</i>&nbsp;        if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
<b class="nc"><i>3948</i>&nbsp;            params.append(implicitParameter());</b>
<i>3949</i>&nbsp;            while (token.kind == COMMA) {
<b class="nc"><i>3950</i>&nbsp;                nextToken();</b>
<i>3951</i>&nbsp;                params.append(implicitParameter());
<b class="nc"><i>3952</i>&nbsp;            }</b>
<i>3953</i>&nbsp;        }
<b class="nc"><i>3954</i>&nbsp;        if (hasParens) {</b>
<i>3955</i>&nbsp;            accept(RPAREN);
<b class="nc"><i>3956</i>&nbsp;        }</b>
<i>3957</i>&nbsp;        return params.toList();
<b class="nc"><i>3958</i>&nbsp;    }</b>
<i>3959</i>&nbsp;
<b class="nc"><i>3960</i>&nbsp;    JCModifiers optFinal(long flags) {</b>
<i>3961</i>&nbsp;        JCModifiers mods = modifiersOpt();
<b class="nc"><i>3962</i>&nbsp;        checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));</b>
<i>3963</i>&nbsp;        mods.flags |= flags;
<b class="nc"><i>3964</i>&nbsp;        return mods;</b>
<i>3965</i>&nbsp;    }
<b class="nc"><i>3966</i>&nbsp;</b>
<i>3967</i>&nbsp;    /**
<i>3968</i>&nbsp;     * Inserts the annotations (and possibly a new array level)
<i>3969</i>&nbsp;     * to the left-most type in an array or nested type.
<i>3970</i>&nbsp;     *
<i>3971</i>&nbsp;     * When parsing a type like {@code @B Outer.Inner @A []}, the
<i>3972</i>&nbsp;     * {@code @A} annotation should target the array itself, while
<i>3973</i>&nbsp;     * {@code @B} targets the nested type {@code Outer}.
<b class="nc"><i>3974</i>&nbsp;     *</b>
<i>3975</i>&nbsp;     * Currently the parser parses the annotation first, then
<b class="nc"><i>3976</i>&nbsp;     * the array, and then inserts the annotation to the left-most</b>
<i>3977</i>&nbsp;     * nested type.
<b class="nc"><i>3978</i>&nbsp;     *</b>
<i>3979</i>&nbsp;     * When {@code createNewLevel} is true, then a new array
<b class="nc"><i>3980</i>&nbsp;     * level is inserted as the most inner type, and have the</b>
<i>3981</i>&nbsp;     * annotations target it.  This is useful in the case of
<b class="nc"><i>3982</i>&nbsp;     * varargs, e.g. {@code String @A [] @B ...}, as the parser</b>
<i>3983</i>&nbsp;     * first parses the type {@code String @A []} then inserts
<b class="nc"><i>3984</i>&nbsp;     * a new array level with {@code @B} annotation.</b>
<i>3985</i>&nbsp;     */
<b class="nc"><i>3986</i>&nbsp;    private JCExpression insertAnnotationsToMostInner(</b>
<i>3987</i>&nbsp;            JCExpression type, List&lt;JCAnnotation&gt; annos,
<b class="nc"><i>3988</i>&nbsp;            boolean createNewLevel) {</b>
<i>3989</i>&nbsp;        int origEndPos = getEndPos(type);
<i>3990</i>&nbsp;        JCExpression mostInnerType = type;
<i>3991</i>&nbsp;        JCArrayTypeTree mostInnerArrayType = null;
<i>3992</i>&nbsp;        while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
<i>3993</i>&nbsp;            mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
<i>3994</i>&nbsp;            mostInnerType = mostInnerArrayType.elemtype;
<i>3995</i>&nbsp;        }
<b class="nc"><i>3996</i>&nbsp;</b>
<i>3997</i>&nbsp;        if (createNewLevel) {
<b class="nc"><i>3998</i>&nbsp;            mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));</b>
<i>3999</i>&nbsp;        }
<b class="nc"><i>4000</i>&nbsp;</b>
<i>4001</i>&nbsp;        JCExpression mostInnerTypeToReturn = mostInnerType;
<b class="nc"><i>4002</i>&nbsp;        if (annos.nonEmpty()) {</b>
<i>4003</i>&nbsp;            JCExpression lastToModify = mostInnerType;
<b class="nc"><i>4004</i>&nbsp;</b>
<i>4005</i>&nbsp;            while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
<b class="nc"><i>4006</i>&nbsp;                    TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {</b>
<i>4007</i>&nbsp;                while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
<b class="nc"><i>4008</i>&nbsp;                    lastToModify = mostInnerType;</b>
<i>4009</i>&nbsp;                    mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
<b class="nc"><i>4010</i>&nbsp;                }</b>
<i>4011</i>&nbsp;                while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
<b class="nc"><i>4012</i>&nbsp;                    lastToModify = mostInnerType;</b>
<i>4013</i>&nbsp;                    mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
<b class="nc"><i>4014</i>&nbsp;                }</b>
<i>4015</i>&nbsp;            }
<i>4016</i>&nbsp;
<i>4017</i>&nbsp;            mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
<i>4018</i>&nbsp;
<b class="nc"><i>4019</i>&nbsp;            if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {</b>
<b class="nc"><i>4020</i>&nbsp;                ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;</b>
<b class="nc"><i>4021</i>&nbsp;            } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {</b>
<i>4022</i>&nbsp;                ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
<i>4023</i>&nbsp;            } else {
<i>4024</i>&nbsp;                // We never saw a SELECT or TYPEAPPLY, return the annotated type.
<b class="nc"><i>4025</i>&nbsp;                mostInnerTypeToReturn = mostInnerType;</b>
<b class="nc"><i>4026</i>&nbsp;            }</b>
<b class="nc"><i>4027</i>&nbsp;        }</b>
<i>4028</i>&nbsp;
<i>4029</i>&nbsp;        if (mostInnerArrayType == null) {
<i>4030</i>&nbsp;            return mostInnerTypeToReturn;
<b class="nc"><i>4031</i>&nbsp;        } else {</b>
<b class="nc"><i>4032</i>&nbsp;            mostInnerArrayType.elemtype = mostInnerTypeToReturn;</b>
<b class="nc"><i>4033</i>&nbsp;            storeEnd(type, origEndPos);</b>
<i>4034</i>&nbsp;            return type;
<i>4035</i>&nbsp;        }
<i>4036</i>&nbsp;    }
<b class="nc"><i>4037</i>&nbsp;</b>
<b class="nc"><i>4038</i>&nbsp;    /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId</b>
<b class="nc"><i>4039</i>&nbsp;     *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter</b>
<i>4040</i>&nbsp;     */
<i>4041</i>&nbsp;    protected JCVariableDecl formalParameter() {
<i>4042</i>&nbsp;        return formalParameter(false);
<b class="nc"><i>4043</i>&nbsp;    }</b>
<b class="nc"><i>4044</i>&nbsp;    protected JCVariableDecl formalParameter(boolean lambdaParameter) {</b>
<b class="nc"><i>4045</i>&nbsp;        JCModifiers mods = optFinal(Flags.PARAMETER);</b>
<i>4046</i>&nbsp;        // need to distinguish between vararg annos and array annos
<i>4047</i>&nbsp;        // look at typeAnnotationsPushedBack comment
<i>4048</i>&nbsp;        this.permitTypeAnnotationsPushBack = true;
<b class="nc"><i>4049</i>&nbsp;        JCExpression type = parseType(lambdaParameter);</b>
<b class="nc"><i>4050</i>&nbsp;        this.permitTypeAnnotationsPushBack = false;</b>
<b class="nc"><i>4051</i>&nbsp;</b>
<i>4052</i>&nbsp;        if (token.kind == ELLIPSIS) {
<i>4053</i>&nbsp;            List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
<i>4054</i>&nbsp;            typeAnnotationsPushedBack = List.nil();
<b class="nc"><i>4055</i>&nbsp;            mods.flags |= Flags.VARARGS;</b>
<b class="nc"><i>4056</i>&nbsp;            // insert var arg type annotations</b>
<b class="nc"><i>4057</i>&nbsp;            type = insertAnnotationsToMostInner(type, varargsAnnos, true);</b>
<i>4058</i>&nbsp;            nextToken();
<i>4059</i>&nbsp;        } else {
<i>4060</i>&nbsp;            // if not a var arg, then typeAnnotationsPushedBack should be null
<b class="nc"><i>4061</i>&nbsp;            if (typeAnnotationsPushedBack.nonEmpty()) {</b>
<b class="nc"><i>4062</i>&nbsp;                reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);</b>
<b class="nc"><i>4063</i>&nbsp;            }</b>
<i>4064</i>&nbsp;            typeAnnotationsPushedBack = List.nil();
<i>4065</i>&nbsp;        }
<i>4066</i>&nbsp;        return variableDeclaratorId(mods, type, lambdaParameter);
<b class="nc"><i>4067</i>&nbsp;    }</b>
<b class="nc"><i>4068</i>&nbsp;</b>
<b class="nc"><i>4069</i>&nbsp;    protected JCVariableDecl implicitParameter() {</b>
<i>4070</i>&nbsp;        JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
<i>4071</i>&nbsp;        return variableDeclaratorId(mods, null, true);
<i>4072</i>&nbsp;    }
<b class="nc"><i>4073</i>&nbsp;</b>
<b class="nc"><i>4074</i>&nbsp;/* ---------- auxiliary methods -------------- */</b>
<b class="nc"><i>4075</i>&nbsp;    /** Check that given tree is a legal expression statement.</b>
<i>4076</i>&nbsp;     */
<i>4077</i>&nbsp;    protected JCExpression checkExprStat(JCExpression t) {
<i>4078</i>&nbsp;        if (!TreeInfo.isExpressionStatement(t)) {
<b class="nc"><i>4079</i>&nbsp;            JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));</b>
<b class="nc"><i>4080</i>&nbsp;            log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);</b>
<b class="nc"><i>4081</i>&nbsp;            return ret;</b>
<i>4082</i>&nbsp;        } else {
<i>4083</i>&nbsp;            return t;
<i>4084</i>&nbsp;        }
<b class="nc"><i>4085</i>&nbsp;    }</b>
<b class="nc"><i>4086</i>&nbsp;</b>
<b class="nc"><i>4087</i>&nbsp;    /** Return precedence of operator represented by token,</b>
<i>4088</i>&nbsp;     *  -1 if token is not a binary operator. @see TreeInfo.opPrec
<i>4089</i>&nbsp;     */
<i>4090</i>&nbsp;    static int prec(TokenKind token) {
<b class="nc"><i>4091</i>&nbsp;        JCTree.Tag oc = optag(token);</b>
<b class="nc"><i>4092</i>&nbsp;        return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;</b>
<b class="nc"><i>4093</i>&nbsp;    }</b>
<i>4094</i>&nbsp;
<i>4095</i>&nbsp;    /**
<i>4096</i>&nbsp;     * Return the lesser of two positions, making allowance for either one
<b class="nc"><i>4097</i>&nbsp;     * being unset.</b>
<b class="nc"><i>4098</i>&nbsp;     */</b>
<b class="nc"><i>4099</i>&nbsp;    static int earlier(int pos1, int pos2) {</b>
<i>4100</i>&nbsp;        if (pos1 == Position.NOPOS)
<i>4101</i>&nbsp;            return pos2;
<i>4102</i>&nbsp;        if (pos2 == Position.NOPOS)
<b class="nc"><i>4103</i>&nbsp;            return pos1;</b>
<b class="nc"><i>4104</i>&nbsp;        return (pos1 &lt; pos2 ? pos1 : pos2);</b>
<b class="nc"><i>4105</i>&nbsp;    }</b>
<i>4106</i>&nbsp;
<i>4107</i>&nbsp;    /** Return operation tag of binary operator represented by token,
<i>4108</i>&nbsp;     *  No_TAG if token is not a binary operator.
<i>4109</i>&nbsp;     */
<i>4110</i>&nbsp;    static JCTree.Tag optag(TokenKind token) {
<i>4111</i>&nbsp;        switch (token) {
<i>4112</i>&nbsp;        case BARBAR:
<i>4113</i>&nbsp;            return OR;
<i>4114</i>&nbsp;        case AMPAMP:
<i>4115</i>&nbsp;            return AND;
<i>4116</i>&nbsp;        case BAR:
<b class="nc"><i>4117</i>&nbsp;            return BITOR;</b>
<b class="nc"><i>4118</i>&nbsp;        case BAREQ:</b>
<i>4119</i>&nbsp;            return BITOR_ASG;
<i>4120</i>&nbsp;        case CARET:
<i>4121</i>&nbsp;            return BITXOR;
<b class="nc"><i>4122</i>&nbsp;        case CARETEQ:</b>
<b class="nc"><i>4123</i>&nbsp;            return BITXOR_ASG;</b>
<i>4124</i>&nbsp;        case AMP:
<i>4125</i>&nbsp;            return BITAND;
<i>4126</i>&nbsp;        case AMPEQ:
<b class="nc"><i>4127</i>&nbsp;            return BITAND_ASG;</b>
<b class="nc"><i>4128</i>&nbsp;        case EQEQ:</b>
<i>4129</i>&nbsp;            return JCTree.Tag.EQ;
<i>4130</i>&nbsp;        case BANGEQ:
<i>4131</i>&nbsp;            return NE;
<b class="nc"><i>4132</i>&nbsp;        case LT:</b>
<b class="nc"><i>4133</i>&nbsp;            return JCTree.Tag.LT;</b>
<i>4134</i>&nbsp;        case GT:
<i>4135</i>&nbsp;            return JCTree.Tag.GT;
<i>4136</i>&nbsp;        case LTEQ:
<b class="nc"><i>4137</i>&nbsp;            return LE;</b>
<i>4138</i>&nbsp;        case GTEQ:
<b class="nc"><i>4139</i>&nbsp;            return GE;</b>
<i>4140</i>&nbsp;        case LTLT:
<i>4141</i>&nbsp;            return SL;
<i>4142</i>&nbsp;        case LTLTEQ:
<b class="nc"><i>4143</i>&nbsp;            return SL_ASG;</b>
<b class="nc"><i>4144</i>&nbsp;        case GTGT:</b>
<b class="nc"><i>4145</i>&nbsp;            return SR;</b>
<b class="nc"><i>4146</i>&nbsp;        case GTGTEQ:</b>
<i>4147</i>&nbsp;            return SR_ASG;
<b class="nc"><i>4148</i>&nbsp;        case GTGTGT:</b>
<i>4149</i>&nbsp;            return USR;
<i>4150</i>&nbsp;        case GTGTGTEQ:
<i>4151</i>&nbsp;            return USR_ASG;
<i>4152</i>&nbsp;        case PLUS:
<i>4153</i>&nbsp;            return JCTree.Tag.PLUS;
<i>4154</i>&nbsp;        case PLUSEQ:
<i>4155</i>&nbsp;            return PLUS_ASG;
<i>4156</i>&nbsp;        case SUB:
<i>4157</i>&nbsp;            return MINUS;
<b class="nc"><i>4158</i>&nbsp;        case SUBEQ:</b>
<i>4159</i>&nbsp;            return MINUS_ASG;
<i>4160</i>&nbsp;        case STAR:
<i>4161</i>&nbsp;            return MUL;
<i>4162</i>&nbsp;        case STAREQ:
<i>4163</i>&nbsp;            return MUL_ASG;
<b class="nc"><i>4164</i>&nbsp;        case SLASH:</b>
<i>4165</i>&nbsp;            return DIV;
<i>4166</i>&nbsp;        case SLASHEQ:
<i>4167</i>&nbsp;            return DIV_ASG;
<b class="nc"><i>4168</i>&nbsp;        case PERCENT:</b>
<i>4169</i>&nbsp;            return MOD;
<i>4170</i>&nbsp;        case PERCENTEQ:
<i>4171</i>&nbsp;            return MOD_ASG;
<b class="nc"><i>4172</i>&nbsp;        case INSTANCEOF:</b>
<i>4173</i>&nbsp;            return TYPETEST;
<i>4174</i>&nbsp;        default:
<i>4175</i>&nbsp;            return NO_TAG;
<b class="nc"><i>4176</i>&nbsp;        }</b>
<i>4177</i>&nbsp;    }
<i>4178</i>&nbsp;
<i>4179</i>&nbsp;    /** Return operation tag of unary operator represented by token,
<i>4180</i>&nbsp;     *  No_TAG if token is not a binary operator.
<i>4181</i>&nbsp;     */
<i>4182</i>&nbsp;    static JCTree.Tag unoptag(TokenKind token) {
<i>4183</i>&nbsp;        switch (token) {
<i>4184</i>&nbsp;        case PLUS:
<i>4185</i>&nbsp;            return POS;
<i>4186</i>&nbsp;        case SUB:
<i>4187</i>&nbsp;            return NEG;
<i>4188</i>&nbsp;        case BANG:
<i>4189</i>&nbsp;            return NOT;
<i>4190</i>&nbsp;        case TILDE:
<i>4191</i>&nbsp;            return COMPL;
<b class="nc"><i>4192</i>&nbsp;        case PLUSPLUS:</b>
<b class="nc"><i>4193</i>&nbsp;            return PREINC;</b>
<i>4194</i>&nbsp;        case SUBSUB:
<i>4195</i>&nbsp;            return PREDEC;
<i>4196</i>&nbsp;        default:
<i>4197</i>&nbsp;            return NO_TAG;
<i>4198</i>&nbsp;        }
<i>4199</i>&nbsp;    }
<i>4200</i>&nbsp;
<i>4201</i>&nbsp;    /** Return type tag of basic type represented by token,
<i>4202</i>&nbsp;     *  NONE if token is not a basic type identifier.
<i>4203</i>&nbsp;     */
<i>4204</i>&nbsp;    static TypeTag typetag(TokenKind token) {
<i>4205</i>&nbsp;        switch (token) {
<i>4206</i>&nbsp;        case BYTE:
<i>4207</i>&nbsp;            return TypeTag.BYTE;
<i>4208</i>&nbsp;        case CHAR:
<i>4209</i>&nbsp;            return TypeTag.CHAR;
<i>4210</i>&nbsp;        case SHORT:
<i>4211</i>&nbsp;            return TypeTag.SHORT;
<i>4212</i>&nbsp;        case INT:
<i>4213</i>&nbsp;            return TypeTag.INT;
<i>4214</i>&nbsp;        case LONG:
<i>4215</i>&nbsp;            return TypeTag.LONG;
<i>4216</i>&nbsp;        case FLOAT:
<i>4217</i>&nbsp;            return TypeTag.FLOAT;
<b class="nc"><i>4218</i>&nbsp;        case DOUBLE:</b>
<b class="nc"><i>4219</i>&nbsp;            return TypeTag.DOUBLE;</b>
<i>4220</i>&nbsp;        case BOOLEAN:
<i>4221</i>&nbsp;            return TypeTag.BOOLEAN;
<i>4222</i>&nbsp;        default:
<i>4223</i>&nbsp;            return TypeTag.NONE;
<b class="nc"><i>4224</i>&nbsp;        }</b>
<i>4225</i>&nbsp;    }
<i>4226</i>&nbsp;
<i>4227</i>&nbsp;    void checkSourceLevel(Feature feature) {
<i>4228</i>&nbsp;        checkSourceLevel(token.pos, feature);
<i>4229</i>&nbsp;    }
<i>4230</i>&nbsp;
<i>4231</i>&nbsp;    protected void checkSourceLevel(int pos, Feature feature) {
<i>4232</i>&nbsp;        if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
<i>4233</i>&nbsp;            //preview feature without --preview flag, error
<i>4234</i>&nbsp;            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
<i>4235</i>&nbsp;        } else if (!feature.allowedInSource(source)) {
<i>4236</i>&nbsp;            //incompatible source level, error
<i>4237</i>&nbsp;            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
<i>4238</i>&nbsp;        } else if (preview.isPreview(feature)) {
<i>4239</i>&nbsp;            //use of preview feature, warn
<i>4240</i>&nbsp;            preview.warnPreview(pos, feature);
<i>4241</i>&nbsp;        }
<i>4242</i>&nbsp;    }
<i>4243</i>&nbsp;
<i>4244</i>&nbsp;    /*
<i>4245</i>&nbsp;     * a functional source tree and end position mappings
<i>4246</i>&nbsp;     */
<i>4247</i>&nbsp;    protected static class SimpleEndPosTable extends AbstractEndPosTable {
<i>4248</i>&nbsp;
<i>4249</i>&nbsp;        private final IntHashTable endPosMap;
<i>4250</i>&nbsp;
<i>4251</i>&nbsp;        SimpleEndPosTable(JavacParser parser) {
<i>4252</i>&nbsp;            super(parser);
<i>4253</i>&nbsp;            endPosMap = new IntHashTable();
<i>4254</i>&nbsp;        }
<i>4255</i>&nbsp;
<i>4256</i>&nbsp;        public void storeEnd(JCTree tree, int endpos) {
<i>4257</i>&nbsp;            endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
<i>4258</i>&nbsp;                                 endPosMap.lookup(tree));
<i>4259</i>&nbsp;        }
<i>4260</i>&nbsp;
<i>4261</i>&nbsp;        protected &lt;T extends JCTree&gt; T to(T t) {
<i>4262</i>&nbsp;            storeEnd(t, parser.token.endPos);
<i>4263</i>&nbsp;            return t;
<i>4264</i>&nbsp;        }
<i>4265</i>&nbsp;
<i>4266</i>&nbsp;        protected &lt;T extends JCTree&gt; T toP(T t) {
<i>4267</i>&nbsp;            storeEnd(t, parser.S.prevToken().endPos);
<i>4268</i>&nbsp;            return t;
<i>4269</i>&nbsp;        }
<i>4270</i>&nbsp;
<i>4271</i>&nbsp;        public int getEndPos(JCTree tree) {
<i>4272</i>&nbsp;            int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
<i>4273</i>&nbsp;            // As long as Position.NOPOS==-1, this just returns value.
<i>4274</i>&nbsp;            return (value == -1) ? Position.NOPOS : value;
<i>4275</i>&nbsp;        }
<i>4276</i>&nbsp;
<i>4277</i>&nbsp;        public int replaceTree(JCTree oldTree, JCTree newTree) {
<i>4278</i>&nbsp;            int pos = endPosMap.remove(oldTree);
<i>4279</i>&nbsp;            if (pos != -1) {
<i>4280</i>&nbsp;                storeEnd(newTree, pos);
<i>4281</i>&nbsp;                return pos;
<i>4282</i>&nbsp;            }
<i>4283</i>&nbsp;            return Position.NOPOS;
<i>4284</i>&nbsp;        }
<i>4285</i>&nbsp;    }
<i>4286</i>&nbsp;
<i>4287</i>&nbsp;    /*
<i>4288</i>&nbsp;     * a default skeletal implementation without any mapping overhead.
<i>4289</i>&nbsp;     */
<i>4290</i>&nbsp;    protected static class EmptyEndPosTable extends AbstractEndPosTable {
<i>4291</i>&nbsp;
<i>4292</i>&nbsp;        EmptyEndPosTable(JavacParser parser) {
<i>4293</i>&nbsp;            super(parser);
<i>4294</i>&nbsp;        }
<i>4295</i>&nbsp;
<i>4296</i>&nbsp;        public void storeEnd(JCTree tree, int endpos) { /* empty */ }
<i>4297</i>&nbsp;
<i>4298</i>&nbsp;        protected &lt;T extends JCTree&gt; T to(T t) {
<i>4299</i>&nbsp;            return t;
<i>4300</i>&nbsp;        }
<i>4301</i>&nbsp;
<i>4302</i>&nbsp;        protected &lt;T extends JCTree&gt; T toP(T t) {
<i>4303</i>&nbsp;            return t;
<i>4304</i>&nbsp;        }
<i>4305</i>&nbsp;
<i>4306</i>&nbsp;        public int getEndPos(JCTree tree) {
<i>4307</i>&nbsp;            return Position.NOPOS;
<i>4308</i>&nbsp;        }
<i>4309</i>&nbsp;
<i>4310</i>&nbsp;        public int replaceTree(JCTree oldTree, JCTree newTree) {
<i>4311</i>&nbsp;            return Position.NOPOS;
<i>4312</i>&nbsp;        }
<i>4313</i>&nbsp;
<i>4314</i>&nbsp;    }
<i>4315</i>&nbsp;
<i>4316</i>&nbsp;    protected static abstract class AbstractEndPosTable implements EndPosTable {
<i>4317</i>&nbsp;        /**
<i>4318</i>&nbsp;         * The current parser.
<i>4319</i>&nbsp;         */
<i>4320</i>&nbsp;        protected JavacParser parser;
<i>4321</i>&nbsp;
<i>4322</i>&nbsp;        /**
<i>4323</i>&nbsp;         * Store the last error position.
<i>4324</i>&nbsp;         */
<i>4325</i>&nbsp;        public int errorEndPos = Position.NOPOS;
<i>4326</i>&nbsp;
<i>4327</i>&nbsp;        public AbstractEndPosTable(JavacParser parser) {
<i>4328</i>&nbsp;            this.parser = parser;
<i>4329</i>&nbsp;        }
<i>4330</i>&nbsp;
<i>4331</i>&nbsp;        /**
<i>4332</i>&nbsp;         * Store current token&#39;s ending position for a tree, the value of which
<i>4333</i>&nbsp;         * will be the greater of last error position and the ending position of
<i>4334</i>&nbsp;         * the current token.
<i>4335</i>&nbsp;         * @param t The tree.
<i>4336</i>&nbsp;         */
<i>4337</i>&nbsp;        protected abstract &lt;T extends JCTree&gt; T to(T t);
<i>4338</i>&nbsp;
<i>4339</i>&nbsp;        /**
<i>4340</i>&nbsp;         * Store current token&#39;s ending position for a tree, the value of which
<i>4341</i>&nbsp;         * will be the greater of last error position and the ending position of
<i>4342</i>&nbsp;         * the previous token.
<i>4343</i>&nbsp;         * @param t The tree.
<i>4344</i>&nbsp;         */
<i>4345</i>&nbsp;        protected abstract &lt;T extends JCTree&gt; T toP(T t);
<i>4346</i>&nbsp;
<i>4347</i>&nbsp;        /**
<i>4348</i>&nbsp;         * Set the error position during the parsing phases, the value of which
<i>4349</i>&nbsp;         * will be set only if it is greater than the last stored error position.
<i>4350</i>&nbsp;         * @param errPos The error position
<i>4351</i>&nbsp;         */
<i>4352</i>&nbsp;        public void setErrorEndPos(int errPos) {
<i>4353</i>&nbsp;            if (errPos &gt; errorEndPos) {
<i>4354</i>&nbsp;                errorEndPos = errPos;
<i>4355</i>&nbsp;            }
<i>4356</i>&nbsp;        }
<i>4357</i>&nbsp;
<i>4358</i>&nbsp;        public void setParser(JavacParser parser) {
<i>4359</i>&nbsp;            this.parser = parser;
<i>4360</i>&nbsp;        }
<i>4361</i>&nbsp;    }
<i>4362</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
