


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: BidiBase</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.text.bidi</a> ]
</div>

<h1>Coverage Summary for Class: BidiBase (sun.text.bidi)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BidiBase</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 709)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BidiBase$ImpTabPair</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$InsertPoints</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$LevState</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$NumericShapings</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$Point</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$TextAttributeConstants</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BidiBase$TextAttributeConstants$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 83)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 759)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp;*******************************************************************************
<i>28</i>&nbsp;*   Copyright (C) 2001-2014, International Business Machines
<i>29</i>&nbsp;*   Corporation and others.  All Rights Reserved.
<i>30</i>&nbsp;*******************************************************************************
<i>31</i>&nbsp;*/
<i>32</i>&nbsp;
<i>33</i>&nbsp;/* FOOD FOR THOUGHT: currently the reordering modes are a mixture of
<i>34</i>&nbsp; * algorithm for direct BiDi, algorithm for inverse Bidi and the bizarre
<i>35</i>&nbsp; * concept of RUNS_ONLY which is a double operation.
<i>36</i>&nbsp; * It could be advantageous to divide this into 3 concepts:
<i>37</i>&nbsp; * a) Operation: direct / inverse / RUNS_ONLY
<i>38</i>&nbsp; * b) Direct algorithm: default / NUMBERS_SPECIAL / GROUP_NUMBERS_WITH_L
<i>39</i>&nbsp; * c) Inverse algorithm: default / INVERSE_LIKE_DIRECT / NUMBERS_SPECIAL
<i>40</i>&nbsp; * This would allow combinations not possible today like RUNS_ONLY with
<i>41</i>&nbsp; * NUMBERS_SPECIAL.
<i>42</i>&nbsp; * Also allow to set INSERT_MARKS for the direct step of RUNS_ONLY and
<i>43</i>&nbsp; * REMOVE_CONTROLS for the inverse step.
<i>44</i>&nbsp; * Not all combinations would be supported, and probably not all do make sense.
<i>45</i>&nbsp; * This would need to document which ones are supported and what are the
<i>46</i>&nbsp; * fallbacks for unsupported combinations.
<i>47</i>&nbsp; */
<i>48</i>&nbsp;
<i>49</i>&nbsp;package sun.text.bidi;
<i>50</i>&nbsp;
<i>51</i>&nbsp;import java.lang.reflect.Array;
<i>52</i>&nbsp;import java.text.AttributedCharacterIterator;
<i>53</i>&nbsp;import java.text.Bidi;
<i>54</i>&nbsp;import java.util.Arrays;
<i>55</i>&nbsp;import jdk.internal.misc.JavaAWTFontAccess;
<i>56</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>57</i>&nbsp;import sun.text.normalizer.UBiDiProps;
<i>58</i>&nbsp;import sun.text.normalizer.UCharacter;
<i>59</i>&nbsp;import sun.text.normalizer.UTF16;
<i>60</i>&nbsp;
<i>61</i>&nbsp;/**
<i>62</i>&nbsp; *
<i>63</i>&nbsp; * &lt;h2&gt;Bidi algorithm for ICU&lt;/h2&gt;
<i>64</i>&nbsp; *
<i>65</i>&nbsp; * This is an implementation of the Unicode Bidirectional Algorithm. The
<i>66</i>&nbsp; * algorithm is defined in the &lt;a
<i>67</i>&nbsp; * href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;.
<i>68</i>&nbsp; * &lt;p&gt;
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * Note: Libraries that perform a bidirectional algorithm and reorder strings
<i>71</i>&nbsp; * accordingly are sometimes called &quot;Storage Layout Engines&quot;. ICU&#39;s Bidi and
<i>72</i>&nbsp; * shaping (ArabicShaping) classes can be used at the core of such &quot;Storage
<i>73</i>&nbsp; * Layout Engines&quot;.
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * &lt;h3&gt;General remarks about the API:&lt;/h3&gt;
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * The &quot;limit&quot; of a sequence of characters is the position just after
<i>78</i>&nbsp; * their last character, i.e., one more than that position.
<i>79</i>&nbsp; * &lt;p&gt;
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * Some of the API methods provide access to &quot;runs&quot;. Such a
<i>82</i>&nbsp; * &quot;run&quot; is defined as a sequence of characters that are at the same
<i>83</i>&nbsp; * embedding level after performing the Bidi algorithm.
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * &lt;h3&gt;Basic concept: paragraph&lt;/h3&gt;
<i>86</i>&nbsp; * A piece of text can be divided into several paragraphs by characters
<i>87</i>&nbsp; * with the Bidi class &lt;code&gt;Block Separator&lt;/code&gt;. For handling of
<i>88</i>&nbsp; * paragraphs, see:
<i>89</i>&nbsp; * &lt;ul&gt;
<i>90</i>&nbsp; * &lt;li&gt;{@link #countParagraphs}
<i>91</i>&nbsp; * &lt;li&gt;{@link #getParaLevel}
<i>92</i>&nbsp; * &lt;li&gt;{@link #getParagraph}
<i>93</i>&nbsp; * &lt;li&gt;{@link #getParagraphByIndex}
<i>94</i>&nbsp; * &lt;/ul&gt;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;h3&gt;Basic concept: text direction&lt;/h3&gt;
<i>97</i>&nbsp; * The direction of a piece of text may be:
<i>98</i>&nbsp; * &lt;ul&gt;
<i>99</i>&nbsp; * &lt;li&gt;{@link #LTR}
<i>100</i>&nbsp; * &lt;li&gt;{@link #RTL}
<i>101</i>&nbsp; * &lt;li&gt;{@link #MIXED}
<i>102</i>&nbsp; * &lt;li&gt;{@link #NEUTRAL}
<i>103</i>&nbsp; * &lt;/ul&gt;
<i>104</i>&nbsp; *
<i>105</i>&nbsp; * &lt;h3&gt;Basic concept: levels&lt;/h3&gt;
<i>106</i>&nbsp; *
<i>107</i>&nbsp; * Levels in this API represent embedding levels according to the Unicode
<i>108</i>&nbsp; * Bidirectional Algorithm.
<i>109</i>&nbsp; * Their low-order bit (even/odd value) indicates the visual direction.&lt;p&gt;
<i>110</i>&nbsp; *
<i>111</i>&nbsp; * Levels can be abstract values when used for the
<i>112</i>&nbsp; * &lt;code&gt;paraLevel&lt;/code&gt; and &lt;code&gt;embeddingLevels&lt;/code&gt;
<i>113</i>&nbsp; * arguments of &lt;code&gt;setPara()&lt;/code&gt;; there:
<i>114</i>&nbsp; * &lt;ul&gt;
<i>115</i>&nbsp; * &lt;li&gt;the high-order bit of an &lt;code&gt;embeddingLevels[]&lt;/code&gt;
<i>116</i>&nbsp; * value indicates whether the using application is
<i>117</i>&nbsp; * specifying the level of a character to &lt;i&gt;override&lt;/i&gt; whatever the
<i>118</i>&nbsp; * Bidi implementation would resolve it to.&lt;/li&gt;
<i>119</i>&nbsp; * &lt;li&gt;&lt;code&gt;paraLevel&lt;/code&gt; can be set to the
<i>120</i>&nbsp; * pseudo-level values &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
<i>121</i>&nbsp; * and &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;.&lt;/li&gt;
<i>122</i>&nbsp; * &lt;/ul&gt;
<i>123</i>&nbsp; *
<i>124</i>&nbsp; * &lt;p&gt;The related constants are not real, valid level values.
<i>125</i>&nbsp; * &lt;code&gt;DEFAULT_XXX&lt;/code&gt; can be used to specify
<i>126</i>&nbsp; * a default for the paragraph level for
<i>127</i>&nbsp; * when the &lt;code&gt;setPara()&lt;/code&gt; method
<i>128</i>&nbsp; * shall determine it but there is no
<i>129</i>&nbsp; * strongly typed character in the input.&lt;p&gt;
<i>130</i>&nbsp; *
<i>131</i>&nbsp; * Note that the value for &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt; is even
<i>132</i>&nbsp; * and the one for &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt; is odd,
<i>133</i>&nbsp; * just like with normal LTR and RTL level values -
<i>134</i>&nbsp; * these special values are designed that way. Also, the implementation
<i>135</i>&nbsp; * assumes that MAX_EXPLICIT_LEVEL is odd.
<i>136</i>&nbsp; *
<i>137</i>&nbsp; * &lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;
<i>138</i>&nbsp; * &lt;ul&gt;
<i>139</i>&nbsp; * &lt;li&gt;{@link #LEVEL_DEFAULT_LTR}
<i>140</i>&nbsp; * &lt;li&gt;{@link #LEVEL_DEFAULT_RTL}
<i>141</i>&nbsp; * &lt;li&gt;{@link #LEVEL_OVERRIDE}
<i>142</i>&nbsp; * &lt;li&gt;{@link #MAX_EXPLICIT_LEVEL}
<i>143</i>&nbsp; * &lt;li&gt;{@link #setPara}
<i>144</i>&nbsp; * &lt;/ul&gt;
<i>145</i>&nbsp; *
<i>146</i>&nbsp; * &lt;h3&gt;Basic concept: Reordering Mode&lt;/h3&gt;
<i>147</i>&nbsp; * Reordering mode values indicate which variant of the Bidi algorithm to
<i>148</i>&nbsp; * use.
<i>149</i>&nbsp; *
<i>150</i>&nbsp; * &lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;
<i>151</i>&nbsp; * &lt;ul&gt;
<i>152</i>&nbsp; * &lt;li&gt;{@link #setReorderingMode}
<i>153</i>&nbsp; * &lt;li&gt;{@link #REORDER_DEFAULT}
<i>154</i>&nbsp; * &lt;li&gt;{@link #REORDER_NUMBERS_SPECIAL}
<i>155</i>&nbsp; * &lt;li&gt;{@link #REORDER_GROUP_NUMBERS_WITH_R}
<i>156</i>&nbsp; * &lt;li&gt;{@link #REORDER_RUNS_ONLY}
<i>157</i>&nbsp; * &lt;li&gt;{@link #REORDER_INVERSE_NUMBERS_AS_L}
<i>158</i>&nbsp; * &lt;li&gt;{@link #REORDER_INVERSE_LIKE_DIRECT}
<i>159</i>&nbsp; * &lt;li&gt;{@link #REORDER_INVERSE_FOR_NUMBERS_SPECIAL}
<i>160</i>&nbsp; * &lt;/ul&gt;
<i>161</i>&nbsp; *
<i>162</i>&nbsp; * &lt;h3&gt;Basic concept: Reordering Options&lt;/h3&gt;
<i>163</i>&nbsp; * Reordering options can be applied during Bidi text transformations.
<i>164</i>&nbsp; *
<i>165</i>&nbsp; * &lt;p&gt;&lt;b&gt;See Also:&lt;/b&gt;
<i>166</i>&nbsp; * &lt;ul&gt;
<i>167</i>&nbsp; * &lt;li&gt;{@link #setReorderingOptions}
<i>168</i>&nbsp; * &lt;li&gt;{@link #OPTION_DEFAULT}
<i>169</i>&nbsp; * &lt;li&gt;{@link #OPTION_INSERT_MARKS}
<i>170</i>&nbsp; * &lt;li&gt;{@link #OPTION_REMOVE_CONTROLS}
<i>171</i>&nbsp; * &lt;li&gt;{@link #OPTION_STREAMING}
<i>172</i>&nbsp; * &lt;/ul&gt;
<i>173</i>&nbsp; *
<i>174</i>&nbsp; *
<i>175</i>&nbsp; * @author Simon Montagu, Matitiahu Allouche (ported from C code written by Markus W. Scherer)
<i>176</i>&nbsp; * @stable ICU 3.8
<i>177</i>&nbsp; *
<i>178</i>&nbsp; *
<i>179</i>&nbsp; * &lt;h4&gt; Sample code for the ICU Bidi API &lt;/h4&gt;
<i>180</i>&nbsp; *
<i>181</i>&nbsp; * &lt;h5&gt;Rendering a paragraph with the ICU Bidi API&lt;/h5&gt;
<i>182</i>&nbsp; *
<i>183</i>&nbsp; * This is (hypothetical) sample code that illustrates how the ICU Bidi API
<i>184</i>&nbsp; * could be used to render a paragraph of text. Rendering code depends highly on
<i>185</i>&nbsp; * the graphics system, therefore this sample code must make a lot of
<i>186</i>&nbsp; * assumptions, which may or may not match any existing graphics system&#39;s
<i>187</i>&nbsp; * properties.
<i>188</i>&nbsp; *
<i>189</i>&nbsp; * &lt;p&gt;
<i>190</i>&nbsp; * The basic assumptions are:
<i>191</i>&nbsp; * &lt;/p&gt;
<i>192</i>&nbsp; * &lt;ul&gt;
<i>193</i>&nbsp; * &lt;li&gt;Rendering is done from left to right on a horizontal line.&lt;/li&gt;
<i>194</i>&nbsp; * &lt;li&gt;A run of single-style, unidirectional text can be rendered at once.
<i>195</i>&nbsp; * &lt;/li&gt;
<i>196</i>&nbsp; * &lt;li&gt;Such a run of text is passed to the graphics system with characters
<i>197</i>&nbsp; * (code units) in logical order.&lt;/li&gt;
<i>198</i>&nbsp; * &lt;li&gt;The line-breaking algorithm is very complicated and Locale-dependent -
<i>199</i>&nbsp; * and therefore its implementation omitted from this sample code.&lt;/li&gt;
<i>200</i>&nbsp; * &lt;/ul&gt;
<i>201</i>&nbsp; *
<i>202</i>&nbsp; * &lt;pre&gt;{@code
<i>203</i>&nbsp; *
<i>204</i>&nbsp; *  package com.ibm.icu.dev.test.bidi;
<i>205</i>&nbsp; *
<i>206</i>&nbsp; *  import com.ibm.icu.text.Bidi;
<i>207</i>&nbsp; *  import com.ibm.icu.text.BidiRun;
<i>208</i>&nbsp; *
<i>209</i>&nbsp; *  public class Sample {
<i>210</i>&nbsp; *
<i>211</i>&nbsp; *      static final int styleNormal = 0;
<i>212</i>&nbsp; *      static final int styleSelected = 1;
<i>213</i>&nbsp; *      static final int styleBold = 2;
<i>214</i>&nbsp; *      static final int styleItalics = 4;
<i>215</i>&nbsp; *      static final int styleSuper=8;
<i>216</i>&nbsp; *      static final int styleSub = 16;
<i>217</i>&nbsp; *
<i>218</i>&nbsp; *      static class StyleRun {
<i>219</i>&nbsp; *          int limit;
<i>220</i>&nbsp; *          int style;
<i>221</i>&nbsp; *
<i>222</i>&nbsp; *          public StyleRun(int limit, int style) {
<i>223</i>&nbsp; *              this.limit = limit;
<i>224</i>&nbsp; *              this.style = style;
<i>225</i>&nbsp; *          }
<i>226</i>&nbsp; *      }
<i>227</i>&nbsp; *
<i>228</i>&nbsp; *      static class Bounds {
<i>229</i>&nbsp; *          int start;
<i>230</i>&nbsp; *          int limit;
<i>231</i>&nbsp; *
<i>232</i>&nbsp; *          public Bounds(int start, int limit) {
<i>233</i>&nbsp; *              this.start = start;
<i>234</i>&nbsp; *              this.limit = limit;
<i>235</i>&nbsp; *          }
<i>236</i>&nbsp; *      }
<i>237</i>&nbsp; *
<i>238</i>&nbsp; *      static int getTextWidth(String text, int start, int limit,
<i>239</i>&nbsp; *                              StyleRun[] styleRuns, int styleRunCount) {
<i>240</i>&nbsp; *          // simplistic way to compute the width
<i>241</i>&nbsp; *          return limit - start;
<i>242</i>&nbsp; *      }
<i>243</i>&nbsp; *
<i>244</i>&nbsp; *      // set limit and StyleRun limit for a line
<i>245</i>&nbsp; *      // from text[start] and from styleRuns[styleRunStart]
<i>246</i>&nbsp; *      // using Bidi.getLogicalRun(...)
<i>247</i>&nbsp; *      // returns line width
<i>248</i>&nbsp; *      static int getLineBreak(String text, Bounds line, Bidi para,
<i>249</i>&nbsp; *                              StyleRun styleRuns[], Bounds styleRun) {
<i>250</i>&nbsp; *          // dummy return
<i>251</i>&nbsp; *          return 0;
<i>252</i>&nbsp; *      }
<i>253</i>&nbsp; *
<i>254</i>&nbsp; *      // render runs on a line sequentially, always from left to right
<i>255</i>&nbsp; *
<i>256</i>&nbsp; *      // prepare rendering a new line
<i>257</i>&nbsp; *      static void startLine(byte textDirection, int lineWidth) {
<i>258</i>&nbsp; *          System.out.println();
<i>259</i>&nbsp; *      }
<i>260</i>&nbsp; *
<i>261</i>&nbsp; *      // render a run of text and advance to the right by the run width
<i>262</i>&nbsp; *      // the text[start..limit-1] is always in logical order
<i>263</i>&nbsp; *      static void renderRun(String text, int start, int limit,
<i>264</i>&nbsp; *                            byte textDirection, int style) {
<i>265</i>&nbsp; *      }
<i>266</i>&nbsp; *
<i>267</i>&nbsp; *      // We could compute a cross-product
<i>268</i>&nbsp; *      // from the style runs with the directional runs
<i>269</i>&nbsp; *      // and then reorder it.
<i>270</i>&nbsp; *      // Instead, here we iterate over each run type
<i>271</i>&nbsp; *      // and render the intersections -
<i>272</i>&nbsp; *      // with shortcuts in simple (and common) cases.
<i>273</i>&nbsp; *      // renderParagraph() is the main function.
<i>274</i>&nbsp; *
<i>275</i>&nbsp; *      // render a directional run with
<i>276</i>&nbsp; *      // (possibly) multiple style runs intersecting with it
<i>277</i>&nbsp; *      static void renderDirectionalRun(String text, int start, int limit,
<i>278</i>&nbsp; *                                       byte direction, StyleRun styleRuns[],
<i>279</i>&nbsp; *                                       int styleRunCount) {
<i>280</i>&nbsp; *          int i;
<i>281</i>&nbsp; *
<i>282</i>&nbsp; *          // iterate over style runs
<i>283</i>&nbsp; *          if (direction == Bidi.LTR) {
<i>284</i>&nbsp; *              int styleLimit;
<i>285</i>&nbsp; *              for (i = 0; i &lt; styleRunCount; ++i) {
<i>286</i>&nbsp; *                  styleLimit = styleRuns[i].limit;
<i>287</i>&nbsp; *                  if (start &lt; styleLimit) {
<i>288</i>&nbsp; *                      if (styleLimit &gt; limit) {
<i>289</i>&nbsp; *                          styleLimit = limit;
<i>290</i>&nbsp; *                      }
<i>291</i>&nbsp; *                      renderRun(text, start, styleLimit,
<i>292</i>&nbsp; *                                direction, styleRuns[i].style);
<i>293</i>&nbsp; *                      if (styleLimit == limit) {
<i>294</i>&nbsp; *                          break;
<i>295</i>&nbsp; *                      }
<i>296</i>&nbsp; *                      start = styleLimit;
<i>297</i>&nbsp; *                  }
<i>298</i>&nbsp; *              }
<i>299</i>&nbsp; *          } else {
<i>300</i>&nbsp; *              int styleStart;
<i>301</i>&nbsp; *
<i>302</i>&nbsp; *              for (i = styleRunCount-1; i &gt;= 0; --i) {
<i>303</i>&nbsp; *                  if (i &gt; 0) {
<i>304</i>&nbsp; *                      styleStart = styleRuns[i-1].limit;
<i>305</i>&nbsp; *                  } else {
<i>306</i>&nbsp; *                      styleStart = 0;
<i>307</i>&nbsp; *                  }
<i>308</i>&nbsp; *                  if (limit &gt;= styleStart) {
<i>309</i>&nbsp; *                      if (styleStart &lt; start) {
<i>310</i>&nbsp; *                          styleStart = start;
<i>311</i>&nbsp; *                      }
<i>312</i>&nbsp; *                      renderRun(text, styleStart, limit, direction,
<i>313</i>&nbsp; *                                styleRuns[i].style);
<i>314</i>&nbsp; *                      if (styleStart == start) {
<i>315</i>&nbsp; *                          break;
<i>316</i>&nbsp; *                      }
<i>317</i>&nbsp; *                      limit = styleStart;
<i>318</i>&nbsp; *                  }
<i>319</i>&nbsp; *              }
<i>320</i>&nbsp; *          }
<i>321</i>&nbsp; *      }
<i>322</i>&nbsp; *
<i>323</i>&nbsp; *      // the line object represents text[start..limit-1]
<i>324</i>&nbsp; *      static void renderLine(Bidi line, String text, int start, int limit,
<i>325</i>&nbsp; *                             StyleRun styleRuns[], int styleRunCount) {
<i>326</i>&nbsp; *          byte direction = line.getDirection();
<i>327</i>&nbsp; *          if (direction != Bidi.MIXED) {
<i>328</i>&nbsp; *              // unidirectional
<i>329</i>&nbsp; *              if (styleRunCount &lt;= 1) {
<i>330</i>&nbsp; *                  renderRun(text, start, limit, direction, styleRuns[0].style);
<i>331</i>&nbsp; *              } else {
<i>332</i>&nbsp; *                  renderDirectionalRun(text, start, limit, direction,
<i>333</i>&nbsp; *                                       styleRuns, styleRunCount);
<i>334</i>&nbsp; *              }
<i>335</i>&nbsp; *          } else {
<i>336</i>&nbsp; *              // mixed-directional
<i>337</i>&nbsp; *              int count, i;
<i>338</i>&nbsp; *              BidiRun run;
<i>339</i>&nbsp; *
<i>340</i>&nbsp; *              try {
<i>341</i>&nbsp; *                  count = line.countRuns();
<i>342</i>&nbsp; *              } catch (IllegalStateException e) {
<i>343</i>&nbsp; *                  e.printStackTrace();
<i>344</i>&nbsp; *                  return;
<i>345</i>&nbsp; *              }
<i>346</i>&nbsp; *              if (styleRunCount &lt;= 1) {
<i>347</i>&nbsp; *                  int style = styleRuns[0].style;
<i>348</i>&nbsp; *
<i>349</i>&nbsp; *                  // iterate over directional runs
<i>350</i>&nbsp; *                  for (i = 0; i &lt; count; ++i) {
<i>351</i>&nbsp; *                      run = line.getVisualRun(i);
<i>352</i>&nbsp; *                      renderRun(text, run.getStart(), run.getLimit(),
<i>353</i>&nbsp; *                                run.getDirection(), style);
<i>354</i>&nbsp; *                  }
<i>355</i>&nbsp; *              } else {
<i>356</i>&nbsp; *                  // iterate over both directional and style runs
<i>357</i>&nbsp; *                  for (i = 0; i &lt; count; ++i) {
<i>358</i>&nbsp; *                      run = line.getVisualRun(i);
<i>359</i>&nbsp; *                      renderDirectionalRun(text, run.getStart(),
<i>360</i>&nbsp; *                                           run.getLimit(), run.getDirection(),
<i>361</i>&nbsp; *                                           styleRuns, styleRunCount);
<i>362</i>&nbsp; *                  }
<i>363</i>&nbsp; *              }
<i>364</i>&nbsp; *          }
<i>365</i>&nbsp; *      }
<i>366</i>&nbsp; *
<i>367</i>&nbsp; *      static void renderParagraph(String text, byte textDirection,
<i>368</i>&nbsp; *                                  StyleRun styleRuns[], int styleRunCount,
<i>369</i>&nbsp; *                                  int lineWidth) {
<i>370</i>&nbsp; *          int length = text.length();
<i>371</i>&nbsp; *          Bidi para = new Bidi();
<i>372</i>&nbsp; *          try {
<i>373</i>&nbsp; *              para.setPara(text,
<i>374</i>&nbsp; *                           textDirection != 0 ? Bidi.LEVEL_DEFAULT_RTL
<i>375</i>&nbsp; *                                              : Bidi.LEVEL_DEFAULT_LTR,
<i>376</i>&nbsp; *                           null);
<i>377</i>&nbsp; *          } catch (Exception e) {
<i>378</i>&nbsp; *              e.printStackTrace();
<i>379</i>&nbsp; *              return;
<i>380</i>&nbsp; *          }
<i>381</i>&nbsp; *          byte paraLevel = (byte)(1 &amp; para.getParaLevel());
<i>382</i>&nbsp; *          StyleRun styleRun = new StyleRun(length, styleNormal);
<i>383</i>&nbsp; *
<i>384</i>&nbsp; *          if (styleRuns == null || styleRunCount &lt;= 0) {
<i>385</i>&nbsp; *              styleRuns = new StyleRun[1];
<i>386</i>&nbsp; *              styleRunCount = 1;
<i>387</i>&nbsp; *              styleRuns[0] = styleRun;
<i>388</i>&nbsp; *          }
<i>389</i>&nbsp; *          // assume styleRuns[styleRunCount-1].limit&gt;=length
<i>390</i>&nbsp; *
<i>391</i>&nbsp; *          int width = getTextWidth(text, 0, length, styleRuns, styleRunCount);
<i>392</i>&nbsp; *          if (width &lt;= lineWidth) {
<i>393</i>&nbsp; *              // everything fits onto one line
<i>394</i>&nbsp; *
<i>395</i>&nbsp; *              // prepare rendering a new line from either left or right
<i>396</i>&nbsp; *              startLine(paraLevel, width);
<i>397</i>&nbsp; *
<i>398</i>&nbsp; *              renderLine(para, text, 0, length, styleRuns, styleRunCount);
<i>399</i>&nbsp; *          } else {
<i>400</i>&nbsp; *              // we need to render several lines
<i>401</i>&nbsp; *              Bidi line = new Bidi(length, 0);
<i>402</i>&nbsp; *              int start = 0, limit;
<i>403</i>&nbsp; *              int styleRunStart = 0, styleRunLimit;
<i>404</i>&nbsp; *
<i>405</i>&nbsp; *              for (;;) {
<i>406</i>&nbsp; *                  limit = length;
<i>407</i>&nbsp; *                  styleRunLimit = styleRunCount;
<i>408</i>&nbsp; *                  width = getLineBreak(text, new Bounds(start, limit),
<i>409</i>&nbsp; *                                       para, styleRuns,
<i>410</i>&nbsp; *                                       new Bounds(styleRunStart, styleRunLimit));
<i>411</i>&nbsp; *                  try {
<i>412</i>&nbsp; *                      line = para.setLine(start, limit);
<i>413</i>&nbsp; *                  } catch (Exception e) {
<i>414</i>&nbsp; *                      e.printStackTrace();
<i>415</i>&nbsp; *                      return;
<i>416</i>&nbsp; *                  }
<i>417</i>&nbsp; *                  // prepare rendering a new line
<i>418</i>&nbsp; *                  // from either left or right
<i>419</i>&nbsp; *                  startLine(paraLevel, width);
<i>420</i>&nbsp; *
<i>421</i>&nbsp; *                  if (styleRunStart &gt; 0) {
<i>422</i>&nbsp; *                      int newRunCount = styleRuns.length - styleRunStart;
<i>423</i>&nbsp; *                      StyleRun[] newRuns = new StyleRun[newRunCount];
<i>424</i>&nbsp; *                      System.arraycopy(styleRuns, styleRunStart, newRuns, 0,
<i>425</i>&nbsp; *                                       newRunCount);
<i>426</i>&nbsp; *                      renderLine(line, text, start, limit, newRuns,
<i>427</i>&nbsp; *                                 styleRunLimit - styleRunStart);
<i>428</i>&nbsp; *                  } else {
<i>429</i>&nbsp; *                      renderLine(line, text, start, limit, styleRuns,
<i>430</i>&nbsp; *                                 styleRunLimit - styleRunStart);
<i>431</i>&nbsp; *                  }
<i>432</i>&nbsp; *                  if (limit == length) {
<i>433</i>&nbsp; *                      break;
<i>434</i>&nbsp; *                  }
<i>435</i>&nbsp; *                  start = limit;
<i>436</i>&nbsp; *                  styleRunStart = styleRunLimit - 1;
<i>437</i>&nbsp; *                  if (start &gt;= styleRuns[styleRunStart].limit) {
<i>438</i>&nbsp; *                      ++styleRunStart;
<i>439</i>&nbsp; *                  }
<i>440</i>&nbsp; *              }
<i>441</i>&nbsp; *          }
<i>442</i>&nbsp; *      }
<i>443</i>&nbsp; *
<i>444</i>&nbsp; *      public static void main(String[] args)
<i>445</i>&nbsp; *      {
<i>446</i>&nbsp; *          renderParagraph(&quot;Some Latin text...&quot;, Bidi.LTR, null, 0, 80);
<i>447</i>&nbsp; *          renderParagraph(&quot;Some Hebrew text...&quot;, Bidi.RTL, null, 0, 60);
<i>448</i>&nbsp; *      }
<i>449</i>&nbsp; *  }
<i>450</i>&nbsp; *
<i>451</i>&nbsp; * }&lt;/pre&gt;
<i>452</i>&nbsp; */
<i>453</i>&nbsp;
<i>454</i>&nbsp;/*
<i>455</i>&nbsp; * General implementation notes:
<i>456</i>&nbsp; *
<i>457</i>&nbsp; * Throughout the implementation, there are comments like (W2) that refer to
<i>458</i>&nbsp; * rules of the BiDi algorithm, in this example to the second rule of the
<i>459</i>&nbsp; * resolution of weak types.
<b class="nc"><i>460</i>&nbsp; *</b>
<i>461</i>&nbsp; * For handling surrogate pairs, where two UChar&#39;s form one &quot;abstract&quot; (or UTF-32)
<i>462</i>&nbsp; * character according to UTF-16, the second UChar gets the directional property of
<i>463</i>&nbsp; * the entire character assigned, while the first one gets a BN, a boundary
<i>464</i>&nbsp; * neutral, type, which is ignored by most of the algorithm according to
<b class="nc"><i>465</i>&nbsp; * rule (X9) and the implementation suggestions of the BiDi algorithm.</b>
<i>466</i>&nbsp; *
<i>467</i>&nbsp; * Later, adjustWSLevels() will set the level for each BN to that of the
<b class="nc"><i>468</i>&nbsp; * following character (UChar), which results in surrogate pairs getting the</b>
<i>469</i>&nbsp; * same level on each of their surrogates.
<i>470</i>&nbsp; *
<i>471</i>&nbsp; * In a UTF-8 implementation, the same thing could be done: the last byte of
<i>472</i>&nbsp; * a multi-byte sequence would get the &quot;real&quot; property, while all previous
<i>473</i>&nbsp; * bytes of that sequence would get BN.
<i>474</i>&nbsp; *
<i>475</i>&nbsp; * It is not possible to assign all those parts of a character the same real
<i>476</i>&nbsp; * property because this would fail in the resolution of weak types with rules
<i>477</i>&nbsp; * that look at immediately surrounding types.
<i>478</i>&nbsp; *
<i>479</i>&nbsp; * As a related topic, this implementation does not remove Boundary Neutral
<i>480</i>&nbsp; * types from the input, but ignores them wherever this is relevant.
<i>481</i>&nbsp; * For example, the loop for the resolution of the weak types reads
<i>482</i>&nbsp; * types until it finds a non-BN.
<i>483</i>&nbsp; * Also, explicit embedding codes are neither changed into BN nor removed.
<i>484</i>&nbsp; * They are only treated the same way real BNs are.
<i>485</i>&nbsp; * As stated before, adjustWSLevels() takes care of them at the end.
<i>486</i>&nbsp; * For the purpose of conformance, the levels of all these codes
<i>487</i>&nbsp; * do not matter.
<i>488</i>&nbsp; *
<i>489</i>&nbsp; * Note that this implementation modifies the dirProps
<i>490</i>&nbsp; * after the initial setup, when applying X5c (replace FSI by LRI or RLI),
<i>491</i>&nbsp; * X6, N0 (replace paired brackets by L or R).
<i>492</i>&nbsp; *
<i>493</i>&nbsp; * In this implementation, the resolution of weak types (W1 to W6),
<i>494</i>&nbsp; * neutrals (N1 and N2), and the assignment of the resolved level (In)
<i>495</i>&nbsp; * are all done in one single loop, in resolveImplicitLevels().
<i>496</i>&nbsp; * Changes of dirProp values are done on the fly, without writing
<i>497</i>&nbsp; * them back to the dirProps array.
<i>498</i>&nbsp; *
<i>499</i>&nbsp; *
<i>500</i>&nbsp; * This implementation contains code that allows to bypass steps of the
<i>501</i>&nbsp; * algorithm that are not needed on the specific paragraph
<i>502</i>&nbsp; * in order to speed up the most common cases considerably,
<i>503</i>&nbsp; * like text that is entirely LTR, or RTL text without numbers.
<i>504</i>&nbsp; *
<i>505</i>&nbsp; * Most of this is done by setting a bit for each directional property
<i>506</i>&nbsp; * in a flags variable and later checking for whether there are
<i>507</i>&nbsp; * any LTR characters or any RTL characters, or both, whether
<i>508</i>&nbsp; * there are any explicit embedding codes, etc.
<i>509</i>&nbsp; *
<i>510</i>&nbsp; * If the (Xn) steps are performed, then the flags are re-evaluated,
<i>511</i>&nbsp; * because they will then not contain the embedding codes any more
<i>512</i>&nbsp; * and will be adjusted for override codes, so that subsequently
<i>513</i>&nbsp; * more bypassing may be possible than what the initial flags suggested.
<i>514</i>&nbsp; *
<i>515</i>&nbsp; * If the text is not mixed-directional, then the
<i>516</i>&nbsp; * algorithm steps for the weak type resolution are not performed,
<i>517</i>&nbsp; * and all levels are set to the paragraph level.
<i>518</i>&nbsp; *
<i>519</i>&nbsp; * If there are no explicit embedding codes, then the (Xn) steps
<i>520</i>&nbsp; * are not performed.
<i>521</i>&nbsp; *
<i>522</i>&nbsp; * If embedding levels are supplied as a parameter, then all
<i>523</i>&nbsp; * explicit embedding codes are ignored, and the (Xn) steps
<i>524</i>&nbsp; * are not performed.
<i>525</i>&nbsp; *
<i>526</i>&nbsp; * White Space types could get the level of the run they belong to,
<i>527</i>&nbsp; * and are checked with a test of (flags&amp;MASK_EMBEDDING) to
<i>528</i>&nbsp; * consider if the paragraph direction should be considered in
<i>529</i>&nbsp; * the flags variable.
<i>530</i>&nbsp; *
<i>531</i>&nbsp; * If there are no White Space types in the paragraph, then
<i>532</i>&nbsp; * (L1) is not necessary in adjustWSLevels().
<i>533</i>&nbsp; */
<i>534</i>&nbsp;
<i>535</i>&nbsp;public class BidiBase {
<i>536</i>&nbsp;
<i>537</i>&nbsp;    static class Point {
<i>538</i>&nbsp;        int pos;    /* position in text */
<i>539</i>&nbsp;        int flag;   /* flag for LRM/RLM, before/after */
<i>540</i>&nbsp;    }
<i>541</i>&nbsp;
<i>542</i>&nbsp;    static class InsertPoints {
<i>543</i>&nbsp;        int size;
<i>544</i>&nbsp;        int confirmed;
<i>545</i>&nbsp;        Point[] points = new Point[0];
<i>546</i>&nbsp;    }
<i>547</i>&nbsp;
<i>548</i>&nbsp;    static class Opening {
<i>549</i>&nbsp;        int   position;                 /* position of opening bracket */
<i>550</i>&nbsp;        int   match;                    /* matching char or -position of closing bracket */
<i>551</i>&nbsp;        int   contextPos;               /* position of last strong char found before opening */
<i>552</i>&nbsp;        short flags;                    /* bits for L or R/AL found within the pair */
<i>553</i>&nbsp;        byte  contextDir;               /* L or R according to last strong char before opening */
<i>554</i>&nbsp;    }
<i>555</i>&nbsp;
<i>556</i>&nbsp;    static class IsoRun {
<i>557</i>&nbsp;        int   contextPos;               /* position of char determining context */
<i>558</i>&nbsp;        short start;                    /* index of first opening entry for this run */
<i>559</i>&nbsp;        short limit;                    /* index after last opening entry for this run */
<i>560</i>&nbsp;        byte  level;                    /* level of this run */
<i>561</i>&nbsp;        byte  lastStrong;               /* bidi class of last strong char found in this run */
<i>562</i>&nbsp;        byte  lastBase;                 /* bidi class of last base char found in this run */
<i>563</i>&nbsp;        byte  contextDir;               /* L or R to use as context for following openings */
<i>564</i>&nbsp;    }
<i>565</i>&nbsp;
<i>566</i>&nbsp;    static class BracketData {
<i>567</i>&nbsp;        Opening[] openings = new Opening[SIMPLE_PARAS_COUNT];
<i>568</i>&nbsp;        int   isoRunLast;               /* index of last used entry */
<i>569</i>&nbsp;        /* array of nested isolated sequence entries; can never excess UBIDI_MAX_EXPLICIT_LEVEL
<i>570</i>&nbsp;           + 1 for index 0, + 1 for before the first isolated sequence */
<i>571</i>&nbsp;        IsoRun[]  isoRuns = new IsoRun[MAX_EXPLICIT_LEVEL+2];
<i>572</i>&nbsp;        boolean   isNumbersSpecial;     /*reordering mode for NUMBERS_SPECIAL */
<i>573</i>&nbsp;    }
<i>574</i>&nbsp;
<i>575</i>&nbsp;    static class Isolate {
<i>576</i>&nbsp;        int   startON;
<i>577</i>&nbsp;        int   start1;
<i>578</i>&nbsp;        short stateImp;
<i>579</i>&nbsp;        short state;
<i>580</i>&nbsp;    }
<i>581</i>&nbsp;
<i>582</i>&nbsp;    /** Paragraph level setting&lt;p&gt;
<i>583</i>&nbsp;     *
<i>584</i>&nbsp;     * Constant indicating that the base direction depends on the first strong
<i>585</i>&nbsp;     * directional character in the text according to the Unicode Bidirectional
<i>586</i>&nbsp;     * Algorithm. If no strong directional character is present,
<i>587</i>&nbsp;     * then set the paragraph level to 0 (left-to-right).&lt;p&gt;
<i>588</i>&nbsp;     *
<i>589</i>&nbsp;     * If this value is used in conjunction with reordering modes
<i>590</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
<i>591</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
<i>592</i>&nbsp;     * is assumed to be visual LTR, and the text after reordering is required
<i>593</i>&nbsp;     * to be the corresponding logical string with appropriate contextual
<i>594</i>&nbsp;     * direction. The direction of the result string will be RTL if either
<i>595</i>&nbsp;     * the rightmost or leftmost strong character of the source text is RTL
<i>596</i>&nbsp;     * or Arabic Letter, the direction will be LTR otherwise.&lt;p&gt;
<i>597</i>&nbsp;     *
<i>598</i>&nbsp;     * If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
<i>599</i>&nbsp;     * be added at the beginning of the result string to ensure round trip
<i>600</i>&nbsp;     * (that the result string, when reordered back to visual, will produce
<i>601</i>&nbsp;     * the original source text).
<i>602</i>&nbsp;     * @see #REORDER_INVERSE_LIKE_DIRECT
<i>603</i>&nbsp;     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
<i>604</i>&nbsp;     * @stable ICU 3.8
<i>605</i>&nbsp;     */
<i>606</i>&nbsp;    public static final byte LEVEL_DEFAULT_LTR = (byte)0x7e;
<i>607</i>&nbsp;
<i>608</i>&nbsp;    /** Paragraph level setting&lt;p&gt;
<i>609</i>&nbsp;     *
<i>610</i>&nbsp;     * Constant indicating that the base direction depends on the first strong
<i>611</i>&nbsp;     * directional character in the text according to the Unicode Bidirectional
<i>612</i>&nbsp;     * Algorithm. If no strong directional character is present,
<i>613</i>&nbsp;     * then set the paragraph level to 1 (right-to-left).&lt;p&gt;
<i>614</i>&nbsp;     *
<i>615</i>&nbsp;     * If this value is used in conjunction with reordering modes
<i>616</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt; or
<i>617</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;, the text to reorder
<i>618</i>&nbsp;     * is assumed to be visual LTR, and the text after reordering is required
<i>619</i>&nbsp;     * to be the corresponding logical string with appropriate contextual
<i>620</i>&nbsp;     * direction. The direction of the result string will be RTL if either
<i>621</i>&nbsp;     * the rightmost or leftmost strong character of the source text is RTL
<i>622</i>&nbsp;     * or Arabic Letter, or if the text contains no strong character;
<i>623</i>&nbsp;     * the direction will be LTR otherwise.&lt;p&gt;
<i>624</i>&nbsp;     *
<i>625</i>&nbsp;     * If reordering option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt; is set, an RLM may
<i>626</i>&nbsp;     * be added at the beginning of the result string to ensure round trip
<i>627</i>&nbsp;     * (that the result string, when reordered back to visual, will produce
<i>628</i>&nbsp;     * the original source text).
<i>629</i>&nbsp;     * @see #REORDER_INVERSE_LIKE_DIRECT
<i>630</i>&nbsp;     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
<i>631</i>&nbsp;     * @stable ICU 3.8
<i>632</i>&nbsp;     */
<i>633</i>&nbsp;    public static final byte LEVEL_DEFAULT_RTL = (byte)0x7f;
<i>634</i>&nbsp;
<i>635</i>&nbsp;    /**
<i>636</i>&nbsp;     * Maximum explicit embedding level.
<i>637</i>&nbsp;     * (The maximum resolved level can be up to &lt;code&gt;MAX_EXPLICIT_LEVEL+1&lt;/code&gt;).
<i>638</i>&nbsp;     * @stable ICU 3.8
<i>639</i>&nbsp;     */
<i>640</i>&nbsp;    public static final byte MAX_EXPLICIT_LEVEL = 125;
<i>641</i>&nbsp;
<i>642</i>&nbsp;    /**
<i>643</i>&nbsp;     * Bit flag for level input.
<i>644</i>&nbsp;     * Overrides directional properties.
<i>645</i>&nbsp;     * @stable ICU 3.8
<i>646</i>&nbsp;     */
<i>647</i>&nbsp;    public static final byte LEVEL_OVERRIDE = (byte)0x80;
<i>648</i>&nbsp;
<i>649</i>&nbsp;    /**
<i>650</i>&nbsp;     * Special value which can be returned by the mapping methods when a
<i>651</i>&nbsp;     * logical index has no corresponding visual index or vice-versa. This may
<i>652</i>&nbsp;     * happen for the logical-to-visual mapping of a Bidi control when option
<i>653</i>&nbsp;     * &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; is
<i>654</i>&nbsp;     * specified. This can also happen for the visual-to-logical mapping of a
<i>655</i>&nbsp;     * Bidi mark (LRM or RLM) inserted by option
<i>656</i>&nbsp;     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.
<i>657</i>&nbsp;     * @see #getVisualIndex
<i>658</i>&nbsp;     * @see #getVisualMap
<i>659</i>&nbsp;     * @see #getLogicalIndex
<i>660</i>&nbsp;     * @see #getLogicalMap
<i>661</i>&nbsp;     * @see #OPTION_INSERT_MARKS
<i>662</i>&nbsp;     * @see #OPTION_REMOVE_CONTROLS
<i>663</i>&nbsp;     * @stable ICU 3.8
<i>664</i>&nbsp;     */
<i>665</i>&nbsp;    public static final int MAP_NOWHERE = -1;
<i>666</i>&nbsp;
<i>667</i>&nbsp;    /**
<i>668</i>&nbsp;     * Left-to-right text.
<i>669</i>&nbsp;     * &lt;ul&gt;
<i>670</i>&nbsp;     * &lt;li&gt;As return value for &lt;code&gt;getDirection()&lt;/code&gt;, it means
<i>671</i>&nbsp;     *     that the source string contains no right-to-left characters, or
<i>672</i>&nbsp;     *     that the source string is empty and the paragraph level is even.
<i>673</i>&nbsp;     * &lt;li&gt;As return value for &lt;code&gt;getBaseDirection()&lt;/code&gt;, it
<i>674</i>&nbsp;     *     means that the first strong character of the source string has
<i>675</i>&nbsp;     *     a left-to-right direction.
<i>676</i>&nbsp;     * &lt;/ul&gt;
<i>677</i>&nbsp;     * @stable ICU 3.8
<i>678</i>&nbsp;     */
<i>679</i>&nbsp;    public static final byte LTR = 0;
<i>680</i>&nbsp;
<i>681</i>&nbsp;    /**
<i>682</i>&nbsp;     * Right-to-left text.
<i>683</i>&nbsp;     * &lt;ul&gt;
<i>684</i>&nbsp;     * &lt;li&gt;As return value for &lt;code&gt;getDirection()&lt;/code&gt;, it means
<i>685</i>&nbsp;     *     that the source string contains no left-to-right characters, or
<i>686</i>&nbsp;     *     that the source string is empty and the paragraph level is odd.
<i>687</i>&nbsp;     * &lt;li&gt;As return value for &lt;code&gt;getBaseDirection()&lt;/code&gt;, it
<i>688</i>&nbsp;     *     means that the first strong character of the source string has
<i>689</i>&nbsp;     *     a right-to-left direction.
<i>690</i>&nbsp;     * &lt;/ul&gt;
<i>691</i>&nbsp;     * @stable ICU 3.8
<i>692</i>&nbsp;     */
<i>693</i>&nbsp;    public static final byte RTL = 1;
<i>694</i>&nbsp;
<i>695</i>&nbsp;    /**
<i>696</i>&nbsp;     * Mixed-directional text.
<i>697</i>&nbsp;     * &lt;p&gt;As return value for &lt;code&gt;getDirection()&lt;/code&gt;, it means
<i>698</i>&nbsp;     *    that the source string contains both left-to-right and
<i>699</i>&nbsp;     *    right-to-left characters.
<i>700</i>&nbsp;     * @stable ICU 3.8
<i>701</i>&nbsp;     */
<i>702</i>&nbsp;    public static final byte MIXED = 2;
<i>703</i>&nbsp;
<i>704</i>&nbsp;    /**
<i>705</i>&nbsp;     * option bit for writeReordered():
<i>706</i>&nbsp;     * keep combining characters after their base characters in RTL runs
<i>707</i>&nbsp;     *
<i>708</i>&nbsp;     * @see #writeReordered
<i>709</i>&nbsp;     * @stable ICU 3.8
<i>710</i>&nbsp;     */
<i>711</i>&nbsp;    public static final short KEEP_BASE_COMBINING = 1;
<i>712</i>&nbsp;
<i>713</i>&nbsp;    /**
<i>714</i>&nbsp;     * option bit for writeReordered():
<i>715</i>&nbsp;     * replace characters with the &quot;mirrored&quot; property in RTL runs
<i>716</i>&nbsp;     * by their mirror-image mappings
<i>717</i>&nbsp;     *
<i>718</i>&nbsp;     * @see #writeReordered
<i>719</i>&nbsp;     * @stable ICU 3.8
<i>720</i>&nbsp;     */
<i>721</i>&nbsp;    public static final short DO_MIRRORING = 2;
<i>722</i>&nbsp;
<i>723</i>&nbsp;    /**
<i>724</i>&nbsp;     * option bit for writeReordered():
<i>725</i>&nbsp;     * surround the run with LRMs if necessary;
<i>726</i>&nbsp;     * this is part of the approximate &quot;inverse Bidi&quot; algorithm
<i>727</i>&nbsp;     *
<i>728</i>&nbsp;     * &lt;p&gt;This option does not imply corresponding adjustment of the index
<i>729</i>&nbsp;     * mappings.&lt;/p&gt;
<i>730</i>&nbsp;     *
<i>731</i>&nbsp;     * @see #setInverse
<i>732</i>&nbsp;     * @see #writeReordered
<i>733</i>&nbsp;     * @stable ICU 3.8
<i>734</i>&nbsp;     */
<i>735</i>&nbsp;    public static final short INSERT_LRM_FOR_NUMERIC = 4;
<i>736</i>&nbsp;
<i>737</i>&nbsp;    /**
<i>738</i>&nbsp;     * option bit for writeReordered():
<i>739</i>&nbsp;     * remove Bidi control characters
<i>740</i>&nbsp;     * (this does not affect INSERT_LRM_FOR_NUMERIC)
<i>741</i>&nbsp;     *
<i>742</i>&nbsp;     * &lt;p&gt;This option does not imply corresponding adjustment of the index
<i>743</i>&nbsp;     * mappings.&lt;/p&gt;
<i>744</i>&nbsp;     *
<i>745</i>&nbsp;     * @see #writeReordered
<i>746</i>&nbsp;     * @see #INSERT_LRM_FOR_NUMERIC
<i>747</i>&nbsp;     * @stable ICU 3.8
<i>748</i>&nbsp;     */
<i>749</i>&nbsp;    public static final short REMOVE_BIDI_CONTROLS = 8;
<i>750</i>&nbsp;
<i>751</i>&nbsp;    /**
<i>752</i>&nbsp;     * option bit for writeReordered():
<i>753</i>&nbsp;     * write the output in reverse order
<i>754</i>&nbsp;     *
<i>755</i>&nbsp;     * &lt;p&gt;This has the same effect as calling &lt;code&gt;writeReordered()&lt;/code&gt;
<i>756</i>&nbsp;     * first without this option, and then calling
<i>757</i>&nbsp;     * &lt;code&gt;writeReverse()&lt;/code&gt; without mirroring.
<i>758</i>&nbsp;     * Doing this in the same step is faster and avoids a temporary buffer.
<i>759</i>&nbsp;     * An example for using this option is output to a character terminal that
<i>760</i>&nbsp;     * is designed for RTL scripts and stores text in reverse order.&lt;/p&gt;
<i>761</i>&nbsp;     *
<i>762</i>&nbsp;     * @see #writeReordered
<i>763</i>&nbsp;     * @stable ICU 3.8
<i>764</i>&nbsp;     */
<i>765</i>&nbsp;    public static final short OUTPUT_REVERSE = 16;
<i>766</i>&nbsp;
<i>767</i>&nbsp;    /** Reordering mode: Regular Logical to Visual Bidi algorithm according to Unicode.
<i>768</i>&nbsp;     * @see #setReorderingMode
<i>769</i>&nbsp;     * @stable ICU 3.8
<i>770</i>&nbsp;     */
<i>771</i>&nbsp;    private static final short REORDER_DEFAULT = 0;
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /** Reordering mode: Logical to Visual algorithm which handles numbers in
<i>774</i>&nbsp;     * a way which mimicks the behavior of Windows XP.
<i>775</i>&nbsp;     * @see #setReorderingMode
<i>776</i>&nbsp;     * @stable ICU 3.8
<i>777</i>&nbsp;     */
<i>778</i>&nbsp;    private static final short REORDER_NUMBERS_SPECIAL = 1;
<i>779</i>&nbsp;
<i>780</i>&nbsp;    /** Reordering mode: Logical to Visual algorithm grouping numbers with
<i>781</i>&nbsp;     * adjacent R characters (reversible algorithm).
<i>782</i>&nbsp;     * @see #setReorderingMode
<i>783</i>&nbsp;     * @stable ICU 3.8
<i>784</i>&nbsp;     */
<i>785</i>&nbsp;    private static final short REORDER_GROUP_NUMBERS_WITH_R = 2;
<i>786</i>&nbsp;
<i>787</i>&nbsp;    /** Reordering mode: Reorder runs only to transform a Logical LTR string
<i>788</i>&nbsp;     * to the logical RTL string with the same display, or vice-versa.&lt;br&gt;
<i>789</i>&nbsp;     * If this mode is set together with option
<i>790</i>&nbsp;     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;, some Bidi controls in the source
<i>791</i>&nbsp;     * text may be removed and other controls may be added to produce the
<i>792</i>&nbsp;     * minimum combination which has the required display.
<i>793</i>&nbsp;     * @see #OPTION_INSERT_MARKS
<i>794</i>&nbsp;     * @see #setReorderingMode
<i>795</i>&nbsp;     * @stable ICU 3.8
<i>796</i>&nbsp;     */
<i>797</i>&nbsp;    static final short REORDER_RUNS_ONLY = 3;
<i>798</i>&nbsp;
<i>799</i>&nbsp;    /** Reordering mode: Visual to Logical algorithm which handles numbers
<i>800</i>&nbsp;     * like L (same algorithm as selected by &lt;code&gt;setInverse(true)&lt;/code&gt;.
<i>801</i>&nbsp;     * @see #setInverse
<i>802</i>&nbsp;     * @see #setReorderingMode
<i>803</i>&nbsp;     * @stable ICU 3.8
<i>804</i>&nbsp;     */
<i>805</i>&nbsp;    static final short REORDER_INVERSE_NUMBERS_AS_L = 4;
<i>806</i>&nbsp;
<i>807</i>&nbsp;    /** Reordering mode: Visual to Logical algorithm equivalent to the regular
<i>808</i>&nbsp;     * Logical to Visual algorithm.
<i>809</i>&nbsp;     * @see #setReorderingMode
<i>810</i>&nbsp;     * @stable ICU 3.8
<i>811</i>&nbsp;     */
<i>812</i>&nbsp;    static final short REORDER_INVERSE_LIKE_DIRECT = 5;
<i>813</i>&nbsp;
<i>814</i>&nbsp;    /** Reordering mode: Inverse Bidi (Visual to Logical) algorithm for the
<i>815</i>&nbsp;     * &lt;code&gt;REORDER_NUMBERS_SPECIAL&lt;/code&gt; Bidi algorithm.
<i>816</i>&nbsp;     * @see #setReorderingMode
<i>817</i>&nbsp;     * @stable ICU 3.8
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    static final short REORDER_INVERSE_FOR_NUMBERS_SPECIAL = 6;
<i>820</i>&nbsp;
<i>821</i>&nbsp;    /* Reordering mode values must be ordered so that all the regular logical to
<i>822</i>&nbsp;     * visual modes come first, and all inverse Bidi modes come last.
<i>823</i>&nbsp;     */
<i>824</i>&nbsp;    private static final short REORDER_LAST_LOGICAL_TO_VISUAL =
<b class="nc"><i>825</i>&nbsp;            REORDER_NUMBERS_SPECIAL;</b>
<b class="nc"><i>826</i>&nbsp;</b>
<i>827</i>&nbsp;    /**
<i>828</i>&nbsp;     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
<i>829</i>&nbsp;     * insert Bidi marks (LRM or RLM) when needed to ensure correct result of
<i>830</i>&nbsp;     * a reordering to a Logical order
<i>831</i>&nbsp;     *
<i>832</i>&nbsp;     * &lt;p&gt;This option must be set or reset before calling
<i>833</i>&nbsp;     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
<i>834</i>&nbsp;     *
<i>835</i>&nbsp;     * &lt;p&gt;This option is significant only with reordering modes which generate
<i>836</i>&nbsp;     * a result with Logical order, specifically.&lt;/p&gt;
<i>837</i>&nbsp;     * &lt;ul&gt;
<i>838</i>&nbsp;     *   &lt;li&gt;&lt;code&gt;REORDER_RUNS_ONLY&lt;/code&gt;&lt;/li&gt;
<i>839</i>&nbsp;     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;&lt;/li&gt;
<i>840</i>&nbsp;     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_LIKE_DIRECT&lt;/code&gt;&lt;/li&gt;
<i>841</i>&nbsp;     *   &lt;li&gt;&lt;code&gt;REORDER_INVERSE_FOR_NUMBERS_SPECIAL&lt;/code&gt;&lt;/li&gt;
<i>842</i>&nbsp;     * &lt;/ul&gt;
<i>843</i>&nbsp;     *
<i>844</i>&nbsp;     * &lt;p&gt;If this option is set in conjunction with reordering mode
<i>845</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt; or with calling
<i>846</i>&nbsp;     * &lt;code&gt;setInverse(true)&lt;/code&gt;, it implies option
<i>847</i>&nbsp;     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
<i>848</i>&nbsp;     * &lt;code&gt;writeReordered()&lt;/code&gt;.&lt;/p&gt;
<i>849</i>&nbsp;     *
<i>850</i>&nbsp;     * &lt;p&gt;For other reordering modes, a minimum number of LRM or RLM characters
<i>851</i>&nbsp;     * will be added to the source text after reordering it so as to ensure
<i>852</i>&nbsp;     * round trip, i.e. when applying the inverse reordering mode on the
<i>853</i>&nbsp;     * resulting logical text with removal of Bidi marks
<i>854</i>&nbsp;     * (option &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt; set before calling
<i>855</i>&nbsp;     * &lt;code&gt;setPara()&lt;/code&gt; or option
<i>856</i>&nbsp;     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in
<i>857</i>&nbsp;     * &lt;code&gt;writeReordered&lt;/code&gt;), the result will be identical to the
<i>858</i>&nbsp;     * source text in the first transformation.
<b class="nc"><i>859</i>&nbsp;     *</b>
<i>860</i>&nbsp;     * &lt;p&gt;This option will be ignored if specified together with option
<i>861</i>&nbsp;     * &lt;code&gt;OPTION_REMOVE_CONTROLS&lt;/code&gt;. It inhibits option
<i>862</i>&nbsp;     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to method
<i>863</i>&nbsp;     * &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
<b class="nc"><i>864</i>&nbsp;     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method</b>
<i>865</i>&nbsp;     * &lt;code&gt;writeReordered()&lt;/code&gt; if the reordering mode is
<i>866</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;.&lt;/p&gt;
<i>867</i>&nbsp;     *
<b class="nc"><i>868</i>&nbsp;     * @see #setReorderingMode</b>
<i>869</i>&nbsp;     * @see #setReorderingOptions
<i>870</i>&nbsp;     * @see #INSERT_LRM_FOR_NUMERIC
<i>871</i>&nbsp;     * @see #REMOVE_BIDI_CONTROLS
<b class="nc"><i>872</i>&nbsp;     * @see #OPTION_REMOVE_CONTROLS</b>
<i>873</i>&nbsp;     * @see #REORDER_RUNS_ONLY
<i>874</i>&nbsp;     * @see #REORDER_INVERSE_NUMBERS_AS_L
<i>875</i>&nbsp;     * @see #REORDER_INVERSE_LIKE_DIRECT
<i>876</i>&nbsp;     * @see #REORDER_INVERSE_FOR_NUMBERS_SPECIAL
<i>877</i>&nbsp;     * @stable ICU 3.8
<i>878</i>&nbsp;     */
<i>879</i>&nbsp;    static final int OPTION_INSERT_MARKS = 1;
<i>880</i>&nbsp;
<b class="nc"><i>881</i>&nbsp;    /**</b>
<i>882</i>&nbsp;     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:
<i>883</i>&nbsp;     * remove Bidi control characters
<i>884</i>&nbsp;     *
<i>885</i>&nbsp;     * &lt;p&gt;This option must be set or reset before calling
<i>886</i>&nbsp;     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
<i>887</i>&nbsp;     *
<i>888</i>&nbsp;     * &lt;p&gt;This option nullifies option
<i>889</i>&nbsp;     * &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;. It inhibits option
<i>890</i>&nbsp;     * &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; in calls to method
<i>891</i>&nbsp;     * &lt;code&gt;writeReordered()&lt;/code&gt; and it implies option
<i>892</i>&nbsp;     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; in calls to that method.&lt;/p&gt;
<b class="nc"><i>893</i>&nbsp;     *</b>
<i>894</i>&nbsp;     * @see #setReorderingMode
<i>895</i>&nbsp;     * @see #setReorderingOptions
<i>896</i>&nbsp;     * @see #OPTION_INSERT_MARKS
<i>897</i>&nbsp;     * @see #INSERT_LRM_FOR_NUMERIC
<i>898</i>&nbsp;     * @see #REMOVE_BIDI_CONTROLS
<i>899</i>&nbsp;     * @stable ICU 3.8
<i>900</i>&nbsp;     */
<i>901</i>&nbsp;    static final int OPTION_REMOVE_CONTROLS = 2;
<i>902</i>&nbsp;
<i>903</i>&nbsp;    /**
<b class="nc"><i>904</i>&nbsp;     * Option bit for &lt;code&gt;setReorderingOptions&lt;/code&gt;:</b>
<i>905</i>&nbsp;     * process the output as part of a stream to be continued
<i>906</i>&nbsp;     *
<i>907</i>&nbsp;     * &lt;p&gt;This option must be set or reset before calling
<i>908</i>&nbsp;     * &lt;code&gt;setPara&lt;/code&gt;.&lt;/p&gt;
<i>909</i>&nbsp;     *
<i>910</i>&nbsp;     * &lt;p&gt;This option specifies that the caller is interested in processing
<i>911</i>&nbsp;     * large text object in parts. The results of the successive calls are
<b class="nc"><i>912</i>&nbsp;     * expected to be concatenated by the caller. Only the call for the last</b>
<i>913</i>&nbsp;     * part will have this option bit off.&lt;/p&gt;
<i>914</i>&nbsp;     *
<b class="nc"><i>915</i>&nbsp;     * &lt;p&gt;When this option bit is on, &lt;code&gt;setPara()&lt;/code&gt; may process</b>
<i>916</i>&nbsp;     * less than the full source text in order to truncate the text at a
<i>917</i>&nbsp;     * meaningful boundary. The caller should call
<b class="nc"><i>918</i>&nbsp;     * &lt;code&gt;getProcessedLength()&lt;/code&gt; immediately after calling</b>
<b class="nc"><i>919</i>&nbsp;     * &lt;code&gt;setPara()&lt;/code&gt; in order to determine how much of the source</b>
<b class="nc"><i>920</i>&nbsp;     * text has been processed. Source text beyond that length should be</b>
<i>921</i>&nbsp;     * resubmitted in following calls to &lt;code&gt;setPara&lt;/code&gt;. The
<b class="nc"><i>922</i>&nbsp;     * processed length may be less than the length of the source text if a</b>
<b class="nc"><i>923</i>&nbsp;     * character preceding the last character of the source text constitutes a</b>
<b class="nc"><i>924</i>&nbsp;     * reasonable boundary (like a block separator) for text to be continued.&lt;br&gt;</b>
<i>925</i>&nbsp;     * If the last character of the source text constitutes a reasonable
<i>926</i>&nbsp;     * boundary, the whole text will be processed at once.&lt;br&gt;
<i>927</i>&nbsp;     * If nowhere in the source text there exists
<i>928</i>&nbsp;     * such a reasonable boundary, the processed length will be zero.&lt;br&gt;
<b class="nc"><i>929</i>&nbsp;     * The caller should check for such an occurrence and do one of the following:</b>
<b class="nc"><i>930</i>&nbsp;     * &lt;ul&gt;&lt;li&gt;submit a larger amount of text with a better chance to include</b>
<i>931</i>&nbsp;     *         a reasonable boundary.&lt;/li&gt;
<i>932</i>&nbsp;     *     &lt;li&gt;resubmit the same text after turning off option
<i>933</i>&nbsp;     *         &lt;code&gt;OPTION_STREAMING&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;
<i>934</i>&nbsp;     * In all cases, this option should be turned off before processing the last
<b class="nc"><i>935</i>&nbsp;     * part of the text.&lt;/p&gt;</b>
<i>936</i>&nbsp;     *
<i>937</i>&nbsp;     * &lt;p&gt;When the &lt;code&gt;OPTION_STREAMING&lt;/code&gt; option is used, it is
<b class="nc"><i>938</i>&nbsp;     * recommended to call &lt;code&gt;orderParagraphsLTR(true)&lt;/code&gt; before calling</b>
<b class="nc"><i>939</i>&nbsp;     * &lt;code&gt;setPara()&lt;/code&gt; so that later paragraphs may be concatenated to</b>
<b class="nc"><i>940</i>&nbsp;     * previous paragraphs on the right.</b>
<b class="nc"><i>941</i>&nbsp;     * &lt;/p&gt;</b>
<i>942</i>&nbsp;     *
<i>943</i>&nbsp;     * @see #setReorderingMode
<b class="nc"><i>944</i>&nbsp;     * @see #setReorderingOptions</b>
<i>945</i>&nbsp;     * @see #getProcessedLength
<i>946</i>&nbsp;     * @stable ICU 3.8
<b class="nc"><i>947</i>&nbsp;     */</b>
<b class="nc"><i>948</i>&nbsp;    private static final int OPTION_STREAMING = 4;</b>
<i>949</i>&nbsp;
<i>950</i>&nbsp;    /*
<b class="nc"><i>951</i>&nbsp;     *   Comparing the description of the Bidi algorithm with this implementation</b>
<i>952</i>&nbsp;     *   is easier with the same names for the Bidi types in the code as there.
<i>953</i>&nbsp;     *   See UCharacterDirection
<i>954</i>&nbsp;     */
<i>955</i>&nbsp;    /* private */ static final byte L   = 0;
<i>956</i>&nbsp;    private static final byte R   = 1;
<i>957</i>&nbsp;    private static final byte EN  = 2;
<b class="nc"><i>958</i>&nbsp;    private static final byte ES  = 3;</b>
<i>959</i>&nbsp;    private static final byte ET  = 4;
<i>960</i>&nbsp;    private static final byte AN  = 5;
<i>961</i>&nbsp;    private static final byte CS  = 6;
<i>962</i>&nbsp;    static final byte B   = 7;
<i>963</i>&nbsp;    private static final byte S   = 8;
<i>964</i>&nbsp;    private static final byte WS  = 9;
<b class="nc"><i>965</i>&nbsp;    private static final byte ON  = 10;</b>
<i>966</i>&nbsp;    private static final byte LRE = 11;
<i>967</i>&nbsp;    private static final byte LRO = 12;
<i>968</i>&nbsp;    private static final byte AL  = 13;
<i>969</i>&nbsp;    private static final byte RLE = 14;
<b class="nc"><i>970</i>&nbsp;    private static final byte RLO = 15;</b>
<i>971</i>&nbsp;    private static final byte PDF = 16;
<i>972</i>&nbsp;    private static final byte NSM = 17;
<i>973</i>&nbsp;    private static final byte BN  = 18;
<i>974</i>&nbsp;    private static final byte FSI = 19;
<b class="nc"><i>975</i>&nbsp;    private static final byte LRI = 20;</b>
<i>976</i>&nbsp;    private static final byte RLI = 21;
<i>977</i>&nbsp;    private static final byte PDI = 22;
<i>978</i>&nbsp;    private static final byte ENL = PDI + 1;    /* EN after W7 */
<i>979</i>&nbsp;    private static final byte ENR = ENL + 1;    /* EN not subject to W7 */
<i>980</i>&nbsp;
<i>981</i>&nbsp;    // Number of directional types
<i>982</i>&nbsp;    private static final int CHAR_DIRECTION_COUNT       = 23;
<b class="nc"><i>983</i>&nbsp;</b>
<i>984</i>&nbsp;    /**
<i>985</i>&nbsp;     * Enumerated property Bidi_Paired_Bracket_Type (new in Unicode 6.3).
<i>986</i>&nbsp;     * Used in UAX #9: Unicode Bidirectional Algorithm
<i>987</i>&nbsp;     * (http://www.unicode.org/reports/tr9/)
<b class="nc"><i>988</i>&nbsp;     * Returns UCharacter.BidiPairedBracketType values.</b>
<b class="nc"><i>989</i>&nbsp;     * @stable ICU 52</b>
<i>990</i>&nbsp;     */
<i>991</i>&nbsp;    public static final int BIDI_PAIRED_BRACKET_TYPE = 0x1015;
<i>992</i>&nbsp;
<i>993</i>&nbsp;    /**
<i>994</i>&nbsp;     * Bidi Paired Bracket Type constants.
<b class="nc"><i>995</i>&nbsp;     *</b>
<i>996</i>&nbsp;     * @see UProperty#BIDI_PAIRED_BRACKET_TYPE
<b class="nc"><i>997</i>&nbsp;     * @stable ICU 52</b>
<i>998</i>&nbsp;     */
<i>999</i>&nbsp;    public static interface BidiPairedBracketType {
<i>1000</i>&nbsp;        /**
<b class="nc"><i>1001</i>&nbsp;         * Not a paired bracket.</b>
<b class="nc"><i>1002</i>&nbsp;         * @stable ICU 52</b>
<i>1003</i>&nbsp;         */
<i>1004</i>&nbsp;        public static final int NONE = 0;
<i>1005</i>&nbsp;        /**
<i>1006</i>&nbsp;         * Open paired bracket.
<i>1007</i>&nbsp;         * @stable ICU 52
<b class="nc"><i>1008</i>&nbsp;         */</b>
<b class="nc"><i>1009</i>&nbsp;        public static final int OPEN = 1;</b>
<i>1010</i>&nbsp;        /**
<i>1011</i>&nbsp;         * Close paired bracket.
<i>1012</i>&nbsp;         * @stable ICU 52
<i>1013</i>&nbsp;         */
<i>1014</i>&nbsp;        public static final int CLOSE = 2;
<i>1015</i>&nbsp;        /**
<b class="nc"><i>1016</i>&nbsp;         * @stable ICU 52</b>
<b class="nc"><i>1017</i>&nbsp;         */</b>
<i>1018</i>&nbsp;        public static final int COUNT = 3;
<i>1019</i>&nbsp;    }
<i>1020</i>&nbsp;
<i>1021</i>&nbsp;    /* number of paras entries allocated initially */
<i>1022</i>&nbsp;    static final int SIMPLE_PARAS_COUNT = 10;
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;    private static final char CR = &#39;\r&#39;;
<i>1025</i>&nbsp;    private static final char LF = &#39;\n&#39;;
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;    static final int LRM_BEFORE = 1;
<i>1028</i>&nbsp;    static final int LRM_AFTER = 2;
<i>1029</i>&nbsp;    static final int RLM_BEFORE = 4;
<i>1030</i>&nbsp;    static final int RLM_AFTER = 8;
<i>1031</i>&nbsp;
<i>1032</i>&nbsp;    /* flags for Opening.flags */
<i>1033</i>&nbsp;    static final byte FOUND_L = (byte)DirPropFlag(L);
<i>1034</i>&nbsp;    static final byte FOUND_R = (byte)DirPropFlag(R);
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;    /*
<i>1037</i>&nbsp;     * The following bit is used for the directional isolate status.
<i>1038</i>&nbsp;     * Stack entries corresponding to isolate sequences are greater than ISOLATE.
<i>1039</i>&nbsp;     */
<i>1040</i>&nbsp;    static final int ISOLATE = 0x0100;
<i>1041</i>&nbsp;
<i>1042</i>&nbsp;    /*
<i>1043</i>&nbsp;     * reference to parent paragraph object (reference to self if this object is
<i>1044</i>&nbsp;     * a paragraph object); set to null in a newly opened object; set to a
<i>1045</i>&nbsp;     * real value after a successful execution of setPara or setLine
<i>1046</i>&nbsp;     */
<i>1047</i>&nbsp;    BidiBase            paraBidi;
<i>1048</i>&nbsp;
<i>1049</i>&nbsp;    final UBiDiProps    bdp;
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;    /* character array representing the current text */
<i>1052</i>&nbsp;    char[]              text;
<b class="nc"><i>1053</i>&nbsp;</b>
<i>1054</i>&nbsp;    /* length of the current text */
<b class="nc"><i>1055</i>&nbsp;    int                 originalLength;</b>
<b class="nc"><i>1056</i>&nbsp;</b>
<i>1057</i>&nbsp;    /* if the option OPTION_STREAMING is set, this is the length of
<i>1058</i>&nbsp;     * text actually processed by &lt;code&gt;setPara&lt;/code&gt;, which may be shorter
<i>1059</i>&nbsp;     * than the original length. Otherwise, it is identical to the original
<i>1060</i>&nbsp;     * length.
<i>1061</i>&nbsp;     */
<i>1062</i>&nbsp;    public int                 length;
<i>1063</i>&nbsp;
<i>1064</i>&nbsp;    /* if option OPTION_REMOVE_CONTROLS is set, and/or Bidi
<i>1065</i>&nbsp;     * marks are allowed to be inserted in one of the reordering modes, the
<i>1066</i>&nbsp;     * length of the result string may be different from the processed length.
<i>1067</i>&nbsp;     */
<i>1068</i>&nbsp;    int                 resultLength;
<i>1069</i>&nbsp;
<i>1070</i>&nbsp;    /* indicators for whether memory may be allocated after construction */
<i>1071</i>&nbsp;    boolean             mayAllocateText;
<i>1072</i>&nbsp;    boolean             mayAllocateRuns;
<i>1073</i>&nbsp;
<i>1074</i>&nbsp;    /* arrays with one value per text-character */
<i>1075</i>&nbsp;    byte[]              dirPropsMemory = new byte[1];
<i>1076</i>&nbsp;    byte[]              levelsMemory = new byte[1];
<i>1077</i>&nbsp;    byte[]              dirProps;
<b class="nc"><i>1078</i>&nbsp;    byte[]              levels;</b>
<i>1079</i>&nbsp;
<b class="nc"><i>1080</i>&nbsp;    /* are we performing an approximation of the &quot;inverse Bidi&quot; algorithm? */</b>
<b class="nc"><i>1081</i>&nbsp;    boolean             isInverse;</b>
<b class="nc"><i>1082</i>&nbsp;</b>
<i>1083</i>&nbsp;    /* are we using the basic algorithm or its variation? */
<i>1084</i>&nbsp;    int                 reorderingMode;
<b class="nc"><i>1085</i>&nbsp;</b>
<b class="nc"><i>1086</i>&nbsp;    /* bitmask for reordering options */</b>
<b class="nc"><i>1087</i>&nbsp;    int                 reorderingOptions;</b>
<i>1088</i>&nbsp;
<b class="nc"><i>1089</i>&nbsp;    /* must block separators receive level 0? */</b>
<i>1090</i>&nbsp;    boolean             orderParagraphsLTR;
<i>1091</i>&nbsp;
<b class="nc"><i>1092</i>&nbsp;    /* the paragraph level */</b>
<i>1093</i>&nbsp;    byte                paraLevel;
<b class="nc"><i>1094</i>&nbsp;</b>
<b class="nc"><i>1095</i>&nbsp;    /* original paraLevel when contextual */</b>
<i>1096</i>&nbsp;    /* must be one of DEFAULT_xxx or 0 if not contextual */
<i>1097</i>&nbsp;    byte                defaultParaLevel;
<b class="nc"><i>1098</i>&nbsp;</b>
<i>1099</i>&nbsp;    /* the following is set in setPara, used in processPropertySeq */
<i>1100</i>&nbsp;
<i>1101</i>&nbsp;    ImpTabPair          impTabPair;  /* reference to levels state table pair */
<i>1102</i>&nbsp;
<i>1103</i>&nbsp;    /* the overall paragraph or line directionality*/
<i>1104</i>&nbsp;    byte                direction;
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;    /* flags is a bit set for which directional properties are in the text */
<i>1107</i>&nbsp;    int                 flags;
<i>1108</i>&nbsp;
<i>1109</i>&nbsp;    /* lastArabicPos is index to the last AL in the text, -1 if none */
<i>1110</i>&nbsp;    int                 lastArabicPos;
<i>1111</i>&nbsp;
<b class="nc"><i>1112</i>&nbsp;    /* characters after trailingWSStart are WS and are */</b>
<i>1113</i>&nbsp;    /* implicitly at the paraLevel (rule (L1)) - levels may not reflect that */
<i>1114</i>&nbsp;    int                 trailingWSStart;
<b class="nc"><i>1115</i>&nbsp;</b>
<b class="nc"><i>1116</i>&nbsp;    /* fields for paragraph handling, set in getDirProps() */</b>
<i>1117</i>&nbsp;    int                 paraCount;
<b class="nc"><i>1118</i>&nbsp;    int[]               paras_limit = new int[SIMPLE_PARAS_COUNT];</b>
<i>1119</i>&nbsp;    byte[]              paras_level = new byte[SIMPLE_PARAS_COUNT];
<b class="nc"><i>1120</i>&nbsp;</b>
<b class="nc"><i>1121</i>&nbsp;    /* fields for line reordering */</b>
<i>1122</i>&nbsp;    int                 runCount;     /* ==-1: runs not set up yet */
<b class="nc"><i>1123</i>&nbsp;    BidiRun[]           runsMemory = new BidiRun[0];</b>
<i>1124</i>&nbsp;    BidiRun[]           runs;
<i>1125</i>&nbsp;
<i>1126</i>&nbsp;    /* for non-mixed text, we only need a tiny array of runs (no allocation) */
<i>1127</i>&nbsp;    BidiRun[]           simpleRuns = {new BidiRun()};
<i>1128</i>&nbsp;
<i>1129</i>&nbsp;    /* fields for managing isolate sequences */
<b class="nc"><i>1130</i>&nbsp;    Isolate[]           isolates;</b>
<b class="nc"><i>1131</i>&nbsp;</b>
<b class="nc"><i>1132</i>&nbsp;    /* maximum or current nesting depth of isolate sequences */</b>
<i>1133</i>&nbsp;    /* Within resolveExplicitLevels() and checkExplicitLevels(), this is the maximal
<i>1134</i>&nbsp;       nesting encountered.
<i>1135</i>&nbsp;       Within resolveImplicitLevels(), this is the index of the current isolates
<i>1136</i>&nbsp;       stack entry. */
<i>1137</i>&nbsp;    int                 isolateCount;
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;    /* mapping of runs in logical order to visual order */
<b class="nc"><i>1140</i>&nbsp;    int[]               logicalToVisualRunsMap;</b>
<b class="nc"><i>1141</i>&nbsp;    /* flag to indicate that the map has been updated */</b>
<i>1142</i>&nbsp;    boolean             isGoodLogicalToVisualRunsMap;
<i>1143</i>&nbsp;
<i>1144</i>&nbsp;    /* for inverse Bidi with insertion of directional marks */
<i>1145</i>&nbsp;    InsertPoints        insertPoints = new InsertPoints();
<b class="nc"><i>1146</i>&nbsp;</b>
<i>1147</i>&nbsp;    /* for option OPTION_REMOVE_CONTROLS */
<i>1148</i>&nbsp;    int                 controlCount;
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;    /*
<b class="nc"><i>1151</i>&nbsp;     * Sometimes, bit values are more appropriate</b>
<b class="nc"><i>1152</i>&nbsp;     * to deal with directionality properties.</b>
<i>1153</i>&nbsp;     * Abbreviations in these method names refer to names
<i>1154</i>&nbsp;     * used in the Bidi algorithm.
<i>1155</i>&nbsp;     */
<i>1156</i>&nbsp;    static int DirPropFlag(byte dir) {
<b class="nc"><i>1157</i>&nbsp;        return (1 &lt;&lt; dir);</b>
<i>1158</i>&nbsp;    }
<i>1159</i>&nbsp;
<i>1160</i>&nbsp;    boolean testDirPropFlagAt(int flag, int index) {
<i>1161</i>&nbsp;        return ((DirPropFlag(dirProps[index]) &amp; flag) != 0);
<b class="nc"><i>1162</i>&nbsp;    }</b>
<b class="nc"><i>1163</i>&nbsp;</b>
<i>1164</i>&nbsp;    static final int DirPropFlagMultiRuns = DirPropFlag((byte)31);
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;    /* to avoid some conditional statements, use tiny constant arrays */
<i>1167</i>&nbsp;    static final int DirPropFlagLR[] = { DirPropFlag(L), DirPropFlag(R) };
<b class="nc"><i>1168</i>&nbsp;    static final int DirPropFlagE[] = { DirPropFlag(LRE), DirPropFlag(RLE) };</b>
<i>1169</i>&nbsp;    static final int DirPropFlagO[] = { DirPropFlag(LRO), DirPropFlag(RLO) };
<i>1170</i>&nbsp;
<i>1171</i>&nbsp;    static final int DirPropFlagLR(byte level) { return DirPropFlagLR[level &amp; 1]; }
<i>1172</i>&nbsp;    static final int DirPropFlagE(byte level)  { return DirPropFlagE[level &amp; 1]; }
<i>1173</i>&nbsp;    static final int DirPropFlagO(byte level)  { return DirPropFlagO[level &amp; 1]; }
<b class="nc"><i>1174</i>&nbsp;    static final byte DirFromStrong(byte strong) { return strong == L ? L : R; }</b>
<i>1175</i>&nbsp;    static final byte NoOverride(byte level) { return (byte)(level &amp; ~LEVEL_OVERRIDE); }
<i>1176</i>&nbsp;
<i>1177</i>&nbsp;    /*  are there any characters that are LTR or RTL? */
<i>1178</i>&nbsp;    static final int MASK_LTR =
<b class="nc"><i>1179</i>&nbsp;        DirPropFlag(L)|DirPropFlag(EN)|DirPropFlag(ENL)|DirPropFlag(ENR)|DirPropFlag(AN)|DirPropFlag(LRE)|DirPropFlag(LRO)|DirPropFlag(LRI);</b>
<i>1180</i>&nbsp;    static final int MASK_RTL = DirPropFlag(R)|DirPropFlag(AL)|DirPropFlag(RLE)|DirPropFlag(RLO)|DirPropFlag(RLI);
<i>1181</i>&nbsp;
<i>1182</i>&nbsp;    static final int MASK_R_AL = DirPropFlag(R)|DirPropFlag(AL);
<i>1183</i>&nbsp;
<b class="nc"><i>1184</i>&nbsp;    /* explicit embedding codes */</b>
<b class="nc"><i>1185</i>&nbsp;    private static final int MASK_EXPLICIT = DirPropFlag(LRE)|DirPropFlag(LRO)|DirPropFlag(RLE)|DirPropFlag(RLO)|DirPropFlag(PDF);</b>
<i>1186</i>&nbsp;    private static final int MASK_BN_EXPLICIT = DirPropFlag(BN)|MASK_EXPLICIT;
<i>1187</i>&nbsp;
<i>1188</i>&nbsp;    /* explicit isolate codes */
<i>1189</i>&nbsp;    private static final int MASK_ISO = DirPropFlag(LRI)|DirPropFlag(RLI)|DirPropFlag(FSI)|DirPropFlag(PDI);
<b class="nc"><i>1190</i>&nbsp;</b>
<i>1191</i>&nbsp;    /* paragraph and segment separators */
<i>1192</i>&nbsp;    private static final int MASK_B_S = DirPropFlag(B)|DirPropFlag(S);
<i>1193</i>&nbsp;
<i>1194</i>&nbsp;    /* all types that are counted as White Space or Neutral in some steps */
<i>1195</i>&nbsp;    static final int MASK_WS = MASK_B_S|DirPropFlag(WS)|MASK_BN_EXPLICIT|MASK_ISO;
<i>1196</i>&nbsp;
<b class="nc"><i>1197</i>&nbsp;    /* types that are neutrals or could becomes neutrals in (Wn) */</b>
<b class="nc"><i>1198</i>&nbsp;    private static final int MASK_POSSIBLE_N = DirPropFlag(ON)|DirPropFlag(CS)|DirPropFlag(ES)|DirPropFlag(ET)|MASK_WS;</b>
<i>1199</i>&nbsp;
<i>1200</i>&nbsp;    /*
<b class="nc"><i>1201</i>&nbsp;     * These types may be changed to &quot;e&quot;,</b>
<b class="nc"><i>1202</i>&nbsp;     * the embedding type (L or R) of the run,</b>
<i>1203</i>&nbsp;     * in the Bidi algorithm (N2)
<i>1204</i>&nbsp;     */
<b class="nc"><i>1205</i>&nbsp;    private static final int MASK_EMBEDDING = DirPropFlag(NSM)|MASK_POSSIBLE_N;</b>
<b class="nc"><i>1206</i>&nbsp;</b>
<i>1207</i>&nbsp;    /*
<i>1208</i>&nbsp;     *  the dirProp&#39;s L and R are defined to 0 and 1 values in UCharacterDirection.java
<i>1209</i>&nbsp;     */
<i>1210</i>&nbsp;    private static byte GetLRFromLevel(byte level)
<i>1211</i>&nbsp;    {
<i>1212</i>&nbsp;        return (byte)(level &amp; 1);
<b class="nc"><i>1213</i>&nbsp;    }</b>
<i>1214</i>&nbsp;
<i>1215</i>&nbsp;    private static boolean IsDefaultLevel(byte level)
<b class="nc"><i>1216</i>&nbsp;    {</b>
<b class="nc"><i>1217</i>&nbsp;        return ((level &amp; LEVEL_DEFAULT_LTR) == LEVEL_DEFAULT_LTR);</b>
<i>1218</i>&nbsp;    }
<b class="nc"><i>1219</i>&nbsp;</b>
<b class="nc"><i>1220</i>&nbsp;    static boolean IsBidiControlChar(int c)</b>
<b class="nc"><i>1221</i>&nbsp;    {</b>
<b class="nc"><i>1222</i>&nbsp;        /* check for range 0x200c to 0x200f (ZWNJ, ZWJ, LRM, RLM) or</b>
<b class="nc"><i>1223</i>&nbsp;                           0x202a to 0x202e (LRE, RLE, PDF, LRO, RLO) */</b>
<i>1224</i>&nbsp;        return (((c &amp; 0xfffffffc) == 0x200c) || ((c &gt;= 0x202a) &amp;&amp; (c &lt;= 0x202e))
<b class="nc"><i>1225</i>&nbsp;                                             || ((c &gt;= 0x2066) &amp;&amp; (c &lt;= 0x2069)));</b>
<b class="nc"><i>1226</i>&nbsp;    }</b>
<i>1227</i>&nbsp;
<i>1228</i>&nbsp;    void verifyValidPara()
<i>1229</i>&nbsp;    {
<i>1230</i>&nbsp;        if (!(this == this.paraBidi)) {
<i>1231</i>&nbsp;            throw new IllegalStateException();
<i>1232</i>&nbsp;        }
<i>1233</i>&nbsp;    }
<i>1234</i>&nbsp;
<b class="nc"><i>1235</i>&nbsp;    void verifyValidParaOrLine()</b>
<b class="nc"><i>1236</i>&nbsp;    {</b>
<b class="nc"><i>1237</i>&nbsp;        BidiBase para = this.paraBidi;</b>
<b class="nc"><i>1238</i>&nbsp;        /* verify Para */</b>
<b class="nc"><i>1239</i>&nbsp;        if (this == para) {</b>
<i>1240</i>&nbsp;            return;
<b class="nc"><i>1241</i>&nbsp;        }</b>
<i>1242</i>&nbsp;        /* verify Line */
<b class="nc"><i>1243</i>&nbsp;        if ((para == null) || (para != para.paraBidi)) {</b>
<b class="nc"><i>1244</i>&nbsp;            throw new IllegalStateException();</b>
<b class="nc"><i>1245</i>&nbsp;        }</b>
<b class="nc"><i>1246</i>&nbsp;    }</b>
<i>1247</i>&nbsp;
<b class="nc"><i>1248</i>&nbsp;    void verifyRange(int index, int start, int limit)</b>
<b class="nc"><i>1249</i>&nbsp;    {</b>
<i>1250</i>&nbsp;        if (index &lt; start || index &gt;= limit) {
<b class="nc"><i>1251</i>&nbsp;            throw new IllegalArgumentException(&quot;Value &quot; + index +</b>
<b class="nc"><i>1252</i>&nbsp;                      &quot; is out of range &quot; + start + &quot; to &quot; + limit);</b>
<b class="nc"><i>1253</i>&nbsp;        }</b>
<b class="nc"><i>1254</i>&nbsp;    }</b>
<b class="nc"><i>1255</i>&nbsp;</b>
<b class="nc"><i>1256</i>&nbsp;    /**</b>
<b class="nc"><i>1257</i>&nbsp;     * Allocate a &lt;code&gt;Bidi&lt;/code&gt; object with preallocated memory</b>
<i>1258</i>&nbsp;     * for internal structures.
<i>1259</i>&nbsp;     * This method provides a &lt;code&gt;Bidi&lt;/code&gt; object like the default constructor
<i>1260</i>&nbsp;     * but it also preallocates memory for internal structures
<i>1261</i>&nbsp;     * according to the sizings supplied by the caller.&lt;p&gt;
<b class="nc"><i>1262</i>&nbsp;     * The preallocation can be limited to some of the internal memory</b>
<b class="nc"><i>1263</i>&nbsp;     * by setting some values to 0 here. That means that if, e.g.,</b>
<b class="nc"><i>1264</i>&nbsp;     * &lt;code&gt;maxRunCount&lt;/code&gt; cannot be reasonably predetermined and should not</b>
<b class="nc"><i>1265</i>&nbsp;     * be set to &lt;code&gt;maxLength&lt;/code&gt; (the only failproof value) to avoid</b>
<b class="nc"><i>1266</i>&nbsp;     * wasting  memory, then &lt;code&gt;maxRunCount&lt;/code&gt; could be set to 0 here</b>
<b class="nc"><i>1267</i>&nbsp;     * and the internal structures that are associated with it will be allocated</b>
<i>1268</i>&nbsp;     * on demand, just like with the default constructor.
<i>1269</i>&nbsp;     *
<i>1270</i>&nbsp;     * @param maxLength is the maximum text or line length that internal memory
<i>1271</i>&nbsp;     *        will be preallocated for. An attempt to associate this object with a
<i>1272</i>&nbsp;     *        longer text will fail, unless this value is 0, which leaves the allocation
<b class="nc"><i>1273</i>&nbsp;     *        up to the implementation.</b>
<b class="nc"><i>1274</i>&nbsp;     *</b>
<b class="nc"><i>1275</i>&nbsp;     * @param maxRunCount is the maximum anticipated number of same-level runs</b>
<i>1276</i>&nbsp;     *        that internal memory will be preallocated for. An attempt to access
<b class="nc"><i>1277</i>&nbsp;     *        visual runs on an object that was not preallocated for as many runs</b>
<b class="nc"><i>1278</i>&nbsp;     *        as the text was actually resolved to will fail,</b>
<i>1279</i>&nbsp;     *        unless this value is 0, which leaves the allocation up to the implementation.&lt;br&gt;&lt;br&gt;
<b class="nc"><i>1280</i>&nbsp;     *        The number of runs depends on the actual text and maybe anywhere between</b>
<b class="nc"><i>1281</i>&nbsp;     *        1 and &lt;code&gt;maxLength&lt;/code&gt;. It is typically small.</b>
<b class="nc"><i>1282</i>&nbsp;     *</b>
<i>1283</i>&nbsp;     * @throws IllegalArgumentException if maxLength or maxRunCount is less than 0
<b class="nc"><i>1284</i>&nbsp;     * @stable ICU 3.8</b>
<b class="nc"><i>1285</i>&nbsp;     */</b>
<b class="nc"><i>1286</i>&nbsp;    public BidiBase(int maxLength, int maxRunCount)</b>
<b class="nc"><i>1287</i>&nbsp;    {</b>
<i>1288</i>&nbsp;        /* check the argument values */
<b class="nc"><i>1289</i>&nbsp;        if (maxLength &lt; 0 || maxRunCount &lt; 0) {</b>
<b class="nc"><i>1290</i>&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc"><i>1291</i>&nbsp;        }</b>
<b class="nc"><i>1292</i>&nbsp;</b>
<b class="nc"><i>1293</i>&nbsp;        /* reset the object, all reference variables null, all flags false,</b>
<i>1294</i>&nbsp;           all sizes 0.
<i>1295</i>&nbsp;           In fact, we don&#39;t need to do anything, since class members are
<i>1296</i>&nbsp;           initialized as zero when an instance is created.
<i>1297</i>&nbsp;         */
<b class="nc"><i>1298</i>&nbsp;        /*</b>
<b class="nc"><i>1299</i>&nbsp;        mayAllocateText = false;</b>
<i>1300</i>&nbsp;        mayAllocateRuns = false;
<i>1301</i>&nbsp;        orderParagraphsLTR = false;
<i>1302</i>&nbsp;        paraCount = 0;
<i>1303</i>&nbsp;        runCount = 0;
<b class="nc"><i>1304</i>&nbsp;        trailingWSStart = 0;</b>
<i>1305</i>&nbsp;        flags = 0;
<b class="nc"><i>1306</i>&nbsp;        paraLevel = 0;</b>
<b class="nc"><i>1307</i>&nbsp;        defaultParaLevel = 0;</b>
<i>1308</i>&nbsp;        direction = 0;
<i>1309</i>&nbsp;        */
<i>1310</i>&nbsp;        /* get Bidi properties */
<i>1311</i>&nbsp;        bdp = UBiDiProps.INSTANCE;
<i>1312</i>&nbsp;
<i>1313</i>&nbsp;        /* allocate memory for arrays as requested */
<i>1314</i>&nbsp;        if (maxLength &gt; 0) {
<i>1315</i>&nbsp;            getInitialDirPropsMemory(maxLength);
<b class="nc"><i>1316</i>&nbsp;            getInitialLevelsMemory(maxLength);</b>
<b class="nc"><i>1317</i>&nbsp;        } else {</b>
<i>1318</i>&nbsp;            mayAllocateText = true;
<b class="nc"><i>1319</i>&nbsp;        }</b>
<b class="nc"><i>1320</i>&nbsp;</b>
<b class="nc"><i>1321</i>&nbsp;        if (maxRunCount &gt; 0) {</b>
<i>1322</i>&nbsp;            // if maxRunCount == 1, use simpleRuns[]
<b class="nc"><i>1323</i>&nbsp;            if (maxRunCount &gt; 1) {</b>
<i>1324</i>&nbsp;                getInitialRunsMemory(maxRunCount);
<i>1325</i>&nbsp;            }
<i>1326</i>&nbsp;        } else {
<i>1327</i>&nbsp;            mayAllocateRuns = true;
<i>1328</i>&nbsp;        }
<i>1329</i>&nbsp;    }
<i>1330</i>&nbsp;
<i>1331</i>&nbsp;    /*
<i>1332</i>&nbsp;     * We are allowed to allocate memory if object==null or
<i>1333</i>&nbsp;     * mayAllocate==true for each array that we need.
<i>1334</i>&nbsp;     *
<i>1335</i>&nbsp;     * Assume sizeNeeded&gt;0.
<i>1336</i>&nbsp;     * If object != null, then assume size &gt; 0.
<i>1337</i>&nbsp;     */
<i>1338</i>&nbsp;    private Object getMemory(String label, Object array, Class&lt;?&gt; arrayClass,
<i>1339</i>&nbsp;            boolean mayAllocate, int sizeNeeded)
<i>1340</i>&nbsp;    {
<i>1341</i>&nbsp;        int len = Array.getLength(array);
<i>1342</i>&nbsp;
<i>1343</i>&nbsp;        /* we have at least enough memory and must not allocate */
<i>1344</i>&nbsp;        if (sizeNeeded == len) {
<i>1345</i>&nbsp;            return array;
<i>1346</i>&nbsp;        }
<i>1347</i>&nbsp;        if (!mayAllocate) {
<i>1348</i>&nbsp;            /* we must not allocate */
<i>1349</i>&nbsp;            if (sizeNeeded &lt;= len) {
<i>1350</i>&nbsp;                return array;
<i>1351</i>&nbsp;            }
<i>1352</i>&nbsp;            throw new OutOfMemoryError(&quot;Failed to allocate memory for &quot;
<i>1353</i>&nbsp;                                       + label);
<i>1354</i>&nbsp;        }
<i>1355</i>&nbsp;        /* we may try to grow or shrink */
<i>1356</i>&nbsp;        /* FOOD FOR THOUGHT: when shrinking it should be possible to avoid
<i>1357</i>&nbsp;           the allocation altogether and rely on this.length */
<i>1358</i>&nbsp;        try {
<i>1359</i>&nbsp;            return Array.newInstance(arrayClass, sizeNeeded);
<i>1360</i>&nbsp;        } catch (Exception e) {
<i>1361</i>&nbsp;            throw new OutOfMemoryError(&quot;Failed to allocate memory for &quot;
<i>1362</i>&nbsp;                                       + label);
<i>1363</i>&nbsp;        }
<i>1364</i>&nbsp;    }
<i>1365</i>&nbsp;
<i>1366</i>&nbsp;    /* helper methods for each allocated array */
<i>1367</i>&nbsp;    private void getDirPropsMemory(boolean mayAllocate, int len)
<i>1368</i>&nbsp;    {
<i>1369</i>&nbsp;        Object array = getMemory(&quot;DirProps&quot;, dirPropsMemory, Byte.TYPE, mayAllocate, len);
<i>1370</i>&nbsp;        dirPropsMemory = (byte[]) array;
<i>1371</i>&nbsp;    }
<i>1372</i>&nbsp;
<i>1373</i>&nbsp;    void getDirPropsMemory(int len)
<i>1374</i>&nbsp;    {
<i>1375</i>&nbsp;        getDirPropsMemory(mayAllocateText, len);
<i>1376</i>&nbsp;    }
<i>1377</i>&nbsp;
<i>1378</i>&nbsp;    private void getLevelsMemory(boolean mayAllocate, int len)
<i>1379</i>&nbsp;    {
<b class="nc"><i>1380</i>&nbsp;        Object array = getMemory(&quot;Levels&quot;, levelsMemory, Byte.TYPE, mayAllocate, len);</b>
<i>1381</i>&nbsp;        levelsMemory = (byte[]) array;
<b class="nc"><i>1382</i>&nbsp;    }</b>
<i>1383</i>&nbsp;
<i>1384</i>&nbsp;    void getLevelsMemory(int len)
<b class="nc"><i>1385</i>&nbsp;    {</b>
<i>1386</i>&nbsp;        getLevelsMemory(mayAllocateText, len);
<i>1387</i>&nbsp;    }
<b class="nc"><i>1388</i>&nbsp;</b>
<i>1389</i>&nbsp;    private void getRunsMemory(boolean mayAllocate, int len)
<i>1390</i>&nbsp;    {
<i>1391</i>&nbsp;        Object array = getMemory(&quot;Runs&quot;, runsMemory, BidiRun.class, mayAllocate, len);
<b class="nc"><i>1392</i>&nbsp;        runsMemory = (BidiRun[]) array;</b>
<i>1393</i>&nbsp;    }
<b class="nc"><i>1394</i>&nbsp;</b>
<i>1395</i>&nbsp;    void getRunsMemory(int len)
<i>1396</i>&nbsp;    {
<i>1397</i>&nbsp;        getRunsMemory(mayAllocateRuns, len);
<i>1398</i>&nbsp;    }
<i>1399</i>&nbsp;
<b class="nc"><i>1400</i>&nbsp;    /* additional methods used by constructor - always allow allocation */</b>
<b class="nc"><i>1401</i>&nbsp;    private void getInitialDirPropsMemory(int len)</b>
<i>1402</i>&nbsp;    {
<i>1403</i>&nbsp;        getDirPropsMemory(true, len);
<i>1404</i>&nbsp;    }
<i>1405</i>&nbsp;
<i>1406</i>&nbsp;    private void getInitialLevelsMemory(int len)
<i>1407</i>&nbsp;    {
<b class="nc"><i>1408</i>&nbsp;        getLevelsMemory(true, len);</b>
<i>1409</i>&nbsp;    }
<b class="nc"><i>1410</i>&nbsp;</b>
<i>1411</i>&nbsp;    private void getInitialRunsMemory(int len)
<b class="nc"><i>1412</i>&nbsp;    {</b>
<b class="nc"><i>1413</i>&nbsp;        getRunsMemory(true, len);</b>
<b class="nc"><i>1414</i>&nbsp;    }</b>
<i>1415</i>&nbsp;
<i>1416</i>&nbsp;    /**
<b class="nc"><i>1417</i>&nbsp;     * Is this &lt;code&gt;Bidi&lt;/code&gt; object set to perform the inverse Bidi</b>
<i>1418</i>&nbsp;     * algorithm?
<b class="nc"><i>1419</i>&nbsp;     * &lt;p&gt;Note: calling this method after setting the reordering mode with</b>
<b class="nc"><i>1420</i>&nbsp;     * &lt;code&gt;setReorderingMode&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; if the</b>
<b class="nc"><i>1421</i>&nbsp;     * reordering mode was set to</b>
<i>1422</i>&nbsp;     * &lt;code&gt;REORDER_INVERSE_NUMBERS_AS_L&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;
<i>1423</i>&nbsp;     * for all other values.&lt;/p&gt;
<i>1424</i>&nbsp;     *
<b class="nc"><i>1425</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;Bidi&lt;/code&gt; object is set to</b>
<b class="nc"><i>1426</i>&nbsp;     * perform the inverse Bidi algorithm by handling numbers as L.</b>
<b class="nc"><i>1427</i>&nbsp;     *</b>
<b class="nc"><i>1428</i>&nbsp;     * @see #setInverse</b>
<b class="nc"><i>1429</i>&nbsp;     * @see #setReorderingMode</b>
<b class="nc"><i>1430</i>&nbsp;     * @see #REORDER_INVERSE_NUMBERS_AS_L</b>
<b class="nc"><i>1431</i>&nbsp;     * @stable ICU 3.8</b>
<i>1432</i>&nbsp;     */
<i>1433</i>&nbsp;    public boolean isInverse() {
<i>1434</i>&nbsp;        return isInverse;
<i>1435</i>&nbsp;    }
<i>1436</i>&nbsp;
<b class="nc"><i>1437</i>&nbsp;    /* perform (P2)..(P3) ------------------------------------------------------- */</b>
<b class="nc"><i>1438</i>&nbsp;</b>
<i>1439</i>&nbsp;    /*
<b class="nc"><i>1440</i>&nbsp;     * Check that there are enough entries in the arrays paras_limit and paras_level</b>
<i>1441</i>&nbsp;     */
<b class="nc"><i>1442</i>&nbsp;    private void checkParaCount() {</b>
<b class="nc"><i>1443</i>&nbsp;        int[] saveLimits;</b>
<i>1444</i>&nbsp;        byte[] saveLevels;
<i>1445</i>&nbsp;        int count = paraCount;
<i>1446</i>&nbsp;        if (count &lt;= paras_level.length)
<b class="nc"><i>1447</i>&nbsp;            return;</b>
<b class="nc"><i>1448</i>&nbsp;        int oldLength = paras_level.length;</b>
<b class="nc"><i>1449</i>&nbsp;        saveLimits = paras_limit;</b>
<b class="nc"><i>1450</i>&nbsp;        saveLevels = paras_level;</b>
<b class="nc"><i>1451</i>&nbsp;        try {</b>
<b class="nc"><i>1452</i>&nbsp;            paras_limit = new int[count * 2];</b>
<b class="nc"><i>1453</i>&nbsp;            paras_level = new byte[count * 2];</b>
<i>1454</i>&nbsp;        } catch (Exception e) {
<i>1455</i>&nbsp;            throw new OutOfMemoryError(&quot;Failed to allocate memory for paras&quot;);
<i>1456</i>&nbsp;        }
<i>1457</i>&nbsp;        System.arraycopy(saveLimits, 0, paras_limit, 0, oldLength);
<i>1458</i>&nbsp;        System.arraycopy(saveLevels, 0, paras_level, 0, oldLength);
<i>1459</i>&nbsp;    }
<b class="nc"><i>1460</i>&nbsp;</b>
<i>1461</i>&nbsp;    /*
<b class="nc"><i>1462</i>&nbsp;     * Get the directional properties for the text, calculate the flags bit-set, and</b>
<b class="nc"><i>1463</i>&nbsp;     * determine the paragraph level if necessary (in paras_level[i]).</b>
<i>1464</i>&nbsp;     * FSI initiators are also resolved and their dirProp replaced with LRI or RLI.
<i>1465</i>&nbsp;     * When encountering an FSI, it is initially replaced with an LRI, which is the
<i>1466</i>&nbsp;     * default. Only if a strong R or AL is found within its scope will the LRI be
<b class="nc"><i>1467</i>&nbsp;     * replaced by an RLI.</b>
<b class="nc"><i>1468</i>&nbsp;     */</b>
<b class="nc"><i>1469</i>&nbsp;    static final int NOT_SEEKING_STRONG = 0;        /* 0: not contextual paraLevel, not after FSI */</b>
<i>1470</i>&nbsp;    static final int SEEKING_STRONG_FOR_PARA = 1;   /* 1: looking for first strong char in para */
<b class="nc"><i>1471</i>&nbsp;    static final int SEEKING_STRONG_FOR_FSI = 2;    /* 2: looking for first strong after FSI */</b>
<b class="nc"><i>1472</i>&nbsp;    static final int LOOKING_FOR_PDI = 3;           /* 3: found strong after FSI, looking for PDI */</b>
<i>1473</i>&nbsp;
<b class="nc"><i>1474</i>&nbsp;    private void getDirProps()</b>
<b class="nc"><i>1475</i>&nbsp;    {</b>
<i>1476</i>&nbsp;        int i = 0, i0, i1;
<i>1477</i>&nbsp;        flags = 0;          /* collect all directionalities in the text */
<b class="nc"><i>1478</i>&nbsp;        int uchar;</b>
<b class="nc"><i>1479</i>&nbsp;        byte dirProp;</b>
<i>1480</i>&nbsp;        byte defaultParaLevel = 0;   /* initialize to avoid compiler warnings */
<b class="nc"><i>1481</i>&nbsp;        boolean isDefaultLevel = IsDefaultLevel(paraLevel);</b>
<b class="nc"><i>1482</i>&nbsp;        /* for inverse Bidi, the default para level is set to RTL if there is a</b>
<b class="nc"><i>1483</i>&nbsp;           strong R or AL character at either end of the text                */</b>
<b class="nc"><i>1484</i>&nbsp;        boolean isDefaultLevelInverse=isDefaultLevel &amp;&amp;</b>
<b class="nc"><i>1485</i>&nbsp;                (reorderingMode == REORDER_INVERSE_LIKE_DIRECT ||</b>
<b class="nc"><i>1486</i>&nbsp;                 reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL);</b>
<b class="nc"><i>1487</i>&nbsp;        lastArabicPos = -1;</b>
<b class="nc"><i>1488</i>&nbsp;        int controlCount = 0;</b>
<i>1489</i>&nbsp;        boolean removeBidiControls = (reorderingOptions &amp; OPTION_REMOVE_CONTROLS) != 0;
<i>1490</i>&nbsp;
<b class="nc"><i>1491</i>&nbsp;        byte state;</b>
<b class="nc"><i>1492</i>&nbsp;        byte lastStrong = ON;           /* for default level &amp; inverse Bidi */</b>
<i>1493</i>&nbsp;    /* The following stacks are used to manage isolate sequences. Those
<i>1494</i>&nbsp;       sequences may be nested, but obviously never more deeply than the
<i>1495</i>&nbsp;       maximum explicit embedding level.
<b class="nc"><i>1496</i>&nbsp;       lastStack is the index of the last used entry in the stack. A value of -1</b>
<b class="nc"><i>1497</i>&nbsp;       means that there is no open isolate sequence.</b>
<i>1498</i>&nbsp;       lastStack is reset to -1 on paragraph boundaries. */
<i>1499</i>&nbsp;    /* The following stack contains the position of the initiator of
<b class="nc"><i>1500</i>&nbsp;       each open isolate sequence */</b>
<b class="nc"><i>1501</i>&nbsp;        int[] isolateStartStack= new int[MAX_EXPLICIT_LEVEL+1];</b>
<b class="nc"><i>1502</i>&nbsp;    /* The following stack contains the last known state before</b>
<b class="nc"><i>1503</i>&nbsp;       encountering the initiator of an isolate sequence */</b>
<i>1504</i>&nbsp;        byte[] previousStateStack = new byte[MAX_EXPLICIT_LEVEL+1];
<b class="nc"><i>1505</i>&nbsp;        int  stackLast=-1;</b>
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;        if ((reorderingOptions &amp; OPTION_STREAMING) != 0)
<b class="nc"><i>1508</i>&nbsp;            length = 0;</b>
<b class="nc"><i>1509</i>&nbsp;        defaultParaLevel = (byte)(paraLevel &amp; 1);</b>
<i>1510</i>&nbsp;
<i>1511</i>&nbsp;        if (isDefaultLevel) {
<i>1512</i>&nbsp;            paras_level[0] = defaultParaLevel;
<i>1513</i>&nbsp;            lastStrong = defaultParaLevel;
<i>1514</i>&nbsp;            state = SEEKING_STRONG_FOR_PARA;
<i>1515</i>&nbsp;        } else {
<i>1516</i>&nbsp;            paras_level[0] = paraLevel;
<i>1517</i>&nbsp;            state = NOT_SEEKING_STRONG;
<b class="nc"><i>1518</i>&nbsp;        }</b>
<i>1519</i>&nbsp;        /* count paragraphs and determine the paragraph level (P2..P3) */
<b class="nc"><i>1520</i>&nbsp;        /*</b>
<b class="nc"><i>1521</i>&nbsp;         * see comment on constant fields:</b>
<i>1522</i>&nbsp;         * the LEVEL_DEFAULT_XXX values are designed so that
<b class="nc"><i>1523</i>&nbsp;         * their low-order bit alone yields the intended default</b>
<b class="nc"><i>1524</i>&nbsp;         */</b>
<i>1525</i>&nbsp;
<i>1526</i>&nbsp;        for (i = 0; i &lt; originalLength; /* i is incremented in the loop */) {
<i>1527</i>&nbsp;            i0 = i;                     /* index of first code unit */
<i>1528</i>&nbsp;            uchar = UTF16.charAt(text, 0, originalLength, i);
<i>1529</i>&nbsp;            i += UTF16.getCharCount(uchar);
<b class="nc"><i>1530</i>&nbsp;            i1 = i - 1; /* index of last code unit, gets the directional property */</b>
<i>1531</i>&nbsp;
<i>1532</i>&nbsp;            dirProp = (byte)getCustomizedClass(uchar);
<b class="nc"><i>1533</i>&nbsp;            flags |= DirPropFlag(dirProp);</b>
<i>1534</i>&nbsp;            dirProps[i1] = dirProp;
<i>1535</i>&nbsp;            if (i1 &gt; i0) {     /* set previous code units&#39; properties to BN */
<i>1536</i>&nbsp;                flags |= DirPropFlag(BN);
<i>1537</i>&nbsp;                do {
<i>1538</i>&nbsp;                    dirProps[--i1] = BN;
<i>1539</i>&nbsp;                } while (i1 &gt; i0);
<i>1540</i>&nbsp;            }
<i>1541</i>&nbsp;            if (removeBidiControls &amp;&amp; IsBidiControlChar(uchar)) {
<i>1542</i>&nbsp;                controlCount++;
<i>1543</i>&nbsp;            }
<i>1544</i>&nbsp;            if (dirProp == L) {
<i>1545</i>&nbsp;                if (state == SEEKING_STRONG_FOR_PARA) {
<i>1546</i>&nbsp;                    paras_level[paraCount - 1] = 0;
<i>1547</i>&nbsp;                    state = NOT_SEEKING_STRONG;
<i>1548</i>&nbsp;                }
<b class="nc"><i>1549</i>&nbsp;                else if (state == SEEKING_STRONG_FOR_FSI) {</b>
<i>1550</i>&nbsp;                    if (stackLast &lt;= MAX_EXPLICIT_LEVEL) {
<b class="nc"><i>1551</i>&nbsp;                        /* no need for next statement, already set by default */</b>
<i>1552</i>&nbsp;                        /* dirProps[isolateStartStack[stackLast]] = LRI; */
<b class="nc"><i>1553</i>&nbsp;                        flags |= DirPropFlag(LRI);</b>
<b class="nc"><i>1554</i>&nbsp;                    }</b>
<b class="nc"><i>1555</i>&nbsp;                    state = LOOKING_FOR_PDI;</b>
<i>1556</i>&nbsp;                }
<b class="nc"><i>1557</i>&nbsp;                lastStrong = L;</b>
<b class="nc"><i>1558</i>&nbsp;                continue;</b>
<b class="nc"><i>1559</i>&nbsp;            }</b>
<i>1560</i>&nbsp;            if (dirProp == R || dirProp == AL) {
<b class="nc"><i>1561</i>&nbsp;                if (state == SEEKING_STRONG_FOR_PARA) {</b>
<i>1562</i>&nbsp;                    paras_level[paraCount - 1] = 1;
<i>1563</i>&nbsp;                    state = NOT_SEEKING_STRONG;
<b class="nc"><i>1564</i>&nbsp;                }</b>
<b class="nc"><i>1565</i>&nbsp;                else if (state == SEEKING_STRONG_FOR_FSI) {</b>
<b class="nc"><i>1566</i>&nbsp;                    if (stackLast &lt;= MAX_EXPLICIT_LEVEL) {</b>
<i>1567</i>&nbsp;                        dirProps[isolateStartStack[stackLast]] = RLI;
<b class="nc"><i>1568</i>&nbsp;                        flags |= DirPropFlag(RLI);</b>
<b class="nc"><i>1569</i>&nbsp;                    }</b>
<i>1570</i>&nbsp;                    state = LOOKING_FOR_PDI;
<i>1571</i>&nbsp;                }
<b class="nc"><i>1572</i>&nbsp;                lastStrong = R;</b>
<i>1573</i>&nbsp;                if (dirProp == AL)
<i>1574</i>&nbsp;                    lastArabicPos = i - 1;
<b class="nc"><i>1575</i>&nbsp;                continue;</b>
<i>1576</i>&nbsp;            }
<i>1577</i>&nbsp;            if (dirProp &gt;= FSI &amp;&amp; dirProp &lt;= RLI) { /* FSI, LRI or RLI */
<i>1578</i>&nbsp;                stackLast++;
<b class="nc"><i>1579</i>&nbsp;                if (stackLast &lt;= MAX_EXPLICIT_LEVEL) {</b>
<i>1580</i>&nbsp;                    isolateStartStack[stackLast] = i - 1;
<i>1581</i>&nbsp;                    previousStateStack[stackLast] = state;
<b class="nc"><i>1582</i>&nbsp;                }</b>
<b class="nc"><i>1583</i>&nbsp;                if (dirProp == FSI) {</b>
<b class="nc"><i>1584</i>&nbsp;                    dirProps[i-1] = LRI;    /* default if no strong char */</b>
<i>1585</i>&nbsp;                    state = SEEKING_STRONG_FOR_FSI;
<i>1586</i>&nbsp;                }
<i>1587</i>&nbsp;                else
<b class="nc"><i>1588</i>&nbsp;                    state = LOOKING_FOR_PDI;</b>
<b class="nc"><i>1589</i>&nbsp;                continue;</b>
<i>1590</i>&nbsp;            }
<i>1591</i>&nbsp;            if (dirProp == PDI) {
<i>1592</i>&nbsp;                if (state == SEEKING_STRONG_FOR_FSI) {
<b class="nc"><i>1593</i>&nbsp;                    if (stackLast &lt;= MAX_EXPLICIT_LEVEL) {</b>
<i>1594</i>&nbsp;                        /* no need for next statement, already set by default */
<i>1595</i>&nbsp;                        /* dirProps[isolateStartStack[stackLast]] = LRI; */
<i>1596</i>&nbsp;                        flags |= DirPropFlag(LRI);
<i>1597</i>&nbsp;                    }
<i>1598</i>&nbsp;                }
<i>1599</i>&nbsp;                if (stackLast &gt;= 0) {
<i>1600</i>&nbsp;                    if (stackLast &lt;= MAX_EXPLICIT_LEVEL)
<i>1601</i>&nbsp;                        state = previousStateStack[stackLast];
<i>1602</i>&nbsp;                    stackLast--;
<i>1603</i>&nbsp;                }
<i>1604</i>&nbsp;                continue;
<i>1605</i>&nbsp;            }
<i>1606</i>&nbsp;            if (dirProp == B) {
<i>1607</i>&nbsp;                if (i &lt; originalLength &amp;&amp; uchar == CR &amp;&amp; text[i] == LF) /* do nothing on the CR */
<i>1608</i>&nbsp;                    continue;
<i>1609</i>&nbsp;                paras_limit[paraCount - 1] = i;
<i>1610</i>&nbsp;                if (isDefaultLevelInverse &amp;&amp; lastStrong == R)
<i>1611</i>&nbsp;                    paras_level[paraCount - 1] = 1;
<i>1612</i>&nbsp;                if ((reorderingOptions &amp; OPTION_STREAMING) != 0) {
<i>1613</i>&nbsp;                /* When streaming, we only process whole paragraphs
<i>1614</i>&nbsp;                   thus some updates are only done on paragraph boundaries */
<b class="nc"><i>1615</i>&nbsp;                   length = i;          /* i is index to next character */</b>
<i>1616</i>&nbsp;                   this.controlCount = controlCount;
<i>1617</i>&nbsp;                }
<b class="nc"><i>1618</i>&nbsp;                if (i &lt; originalLength) {       /* B not last char in text */</b>
<i>1619</i>&nbsp;                    paraCount++;
<i>1620</i>&nbsp;                    checkParaCount();   /* check that there is enough memory for a new para entry */
<b class="nc"><i>1621</i>&nbsp;                    if (isDefaultLevel) {</b>
<i>1622</i>&nbsp;                        paras_level[paraCount - 1] = defaultParaLevel;
<i>1623</i>&nbsp;                        state = SEEKING_STRONG_FOR_PARA;
<i>1624</i>&nbsp;                        lastStrong = defaultParaLevel;
<i>1625</i>&nbsp;                    } else {
<i>1626</i>&nbsp;                        paras_level[paraCount - 1] = paraLevel;
<i>1627</i>&nbsp;                        state = NOT_SEEKING_STRONG;
<i>1628</i>&nbsp;                    }
<i>1629</i>&nbsp;                    stackLast = -1;
<i>1630</i>&nbsp;                }
<i>1631</i>&nbsp;                continue;
<i>1632</i>&nbsp;            }
<i>1633</i>&nbsp;        }
<i>1634</i>&nbsp;        /* +Ignore still open isolate sequences with overflow */
<i>1635</i>&nbsp;      if (stackLast &gt; MAX_EXPLICIT_LEVEL) {
<i>1636</i>&nbsp;            stackLast = MAX_EXPLICIT_LEVEL;
<i>1637</i>&nbsp;            state=SEEKING_STRONG_FOR_FSI;   /* to be on the safe side */
<i>1638</i>&nbsp;        }
<i>1639</i>&nbsp;        /* Resolve direction of still unresolved open FSI sequences */
<i>1640</i>&nbsp;        while (stackLast &gt;= 0) {
<i>1641</i>&nbsp;            if (state == SEEKING_STRONG_FOR_FSI) {
<i>1642</i>&nbsp;                /* no need for next statement, already set by default */
<i>1643</i>&nbsp;                /* dirProps[isolateStartStack[stackLast]] = LRI; */
<i>1644</i>&nbsp;                flags |= DirPropFlag(LRI);
<i>1645</i>&nbsp;                break;
<i>1646</i>&nbsp;            }
<i>1647</i>&nbsp;            state = previousStateStack[stackLast];
<i>1648</i>&nbsp;            stackLast--;
<i>1649</i>&nbsp;        }
<i>1650</i>&nbsp;        /* When streaming, ignore text after the last paragraph separator */
<i>1651</i>&nbsp;        if ((reorderingOptions &amp; OPTION_STREAMING) != 0) {
<i>1652</i>&nbsp;            if (length &lt; originalLength)
<i>1653</i>&nbsp;                paraCount--;
<i>1654</i>&nbsp;        } else {
<i>1655</i>&nbsp;            paras_limit[paraCount - 1] = originalLength;
<i>1656</i>&nbsp;            this.controlCount = controlCount;
<i>1657</i>&nbsp;        }
<i>1658</i>&nbsp;        /* For inverse bidi, default para direction is RTL if there is
<i>1659</i>&nbsp;           a strong R or AL at either end of the paragraph */
<i>1660</i>&nbsp;        if (isDefaultLevelInverse &amp;&amp; lastStrong == R) {
<i>1661</i>&nbsp;            paras_level[paraCount - 1] = 1;
<i>1662</i>&nbsp;        }
<i>1663</i>&nbsp;        if (isDefaultLevel) {
<i>1664</i>&nbsp;            paraLevel = paras_level[0];
<i>1665</i>&nbsp;        }
<i>1666</i>&nbsp;        /* The following is needed to resolve the text direction for default level
<i>1667</i>&nbsp;           paragraphs containing no strong character */
<b class="nc"><i>1668</i>&nbsp;        for (i = 0; i &lt; paraCount; i++)</b>
<i>1669</i>&nbsp;            flags |= DirPropFlagLR(paras_level[i]);
<i>1670</i>&nbsp;
<i>1671</i>&nbsp;        if (orderParagraphsLTR &amp;&amp; (flags &amp; DirPropFlag(B)) != 0) {
<i>1672</i>&nbsp;            flags |= DirPropFlag(L);
<i>1673</i>&nbsp;        }
<i>1674</i>&nbsp;    }
<i>1675</i>&nbsp;
<i>1676</i>&nbsp;    /* determine the paragraph level at position index */
<i>1677</i>&nbsp;    byte GetParaLevelAt(int pindex)
<i>1678</i>&nbsp;    {
<i>1679</i>&nbsp;        if (defaultParaLevel == 0 || pindex &lt; paras_limit[0])
<i>1680</i>&nbsp;            return paraLevel;
<i>1681</i>&nbsp;        int i;
<i>1682</i>&nbsp;        for (i = 1; i &lt; paraCount; i++)
<i>1683</i>&nbsp;            if (pindex &lt; paras_limit[i])
<i>1684</i>&nbsp;                break;
<i>1685</i>&nbsp;        if (i &gt;= paraCount)
<i>1686</i>&nbsp;            i = paraCount - 1;
<i>1687</i>&nbsp;        return paras_level[i];
<i>1688</i>&nbsp;    }
<i>1689</i>&nbsp;
<i>1690</i>&nbsp;    /* Functions for handling paired brackets ----------------------------------- */
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;    /* In the isoRuns array, the first entry is used for text outside of any
<i>1693</i>&nbsp;       isolate sequence.  Higher entries are used for each more deeply nested
<i>1694</i>&nbsp;       isolate sequence. isoRunLast is the index of the last used entry.  The
<i>1695</i>&nbsp;       openings array is used to note the data of opening brackets not yet
<i>1696</i>&nbsp;       matched by a closing bracket, or matched but still susceptible to change
<i>1697</i>&nbsp;       level.
<i>1698</i>&nbsp;       Each isoRun entry contains the index of the first and
<i>1699</i>&nbsp;       one-after-last openings entries for pending opening brackets it
<i>1700</i>&nbsp;       contains.  The next openings entry to use is the one-after-last of the
<i>1701</i>&nbsp;       most deeply nested isoRun entry.
<i>1702</i>&nbsp;       isoRun entries also contain their current embedding level and the last
<i>1703</i>&nbsp;       encountered strong character, since these will be needed to resolve
<i>1704</i>&nbsp;       the level of paired brackets.  */
<i>1705</i>&nbsp;
<i>1706</i>&nbsp;    private void bracketInit(BracketData bd) {
<i>1707</i>&nbsp;        bd.isoRunLast = 0;
<i>1708</i>&nbsp;        bd.isoRuns[0] = new IsoRun();
<i>1709</i>&nbsp;        bd.isoRuns[0].start = 0;
<i>1710</i>&nbsp;        bd.isoRuns[0].limit = 0;
<b class="nc"><i>1711</i>&nbsp;        bd.isoRuns[0].level = GetParaLevelAt(0);</b>
<b class="nc"><i>1712</i>&nbsp;        bd.isoRuns[0].lastStrong = bd.isoRuns[0].lastBase = bd.isoRuns[0].contextDir = (byte)(GetParaLevelAt(0) &amp; 1);</b>
<i>1713</i>&nbsp;        bd.isoRuns[0].contextPos = 0;
<i>1714</i>&nbsp;        bd.openings = new Opening[SIMPLE_PARAS_COUNT];
<i>1715</i>&nbsp;        bd.isNumbersSpecial = reorderingMode == REORDER_NUMBERS_SPECIAL ||
<i>1716</i>&nbsp;                              reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL;
<i>1717</i>&nbsp;    }
<i>1718</i>&nbsp;
<b class="nc"><i>1719</i>&nbsp;    /* paragraph boundary */</b>
<b class="nc"><i>1720</i>&nbsp;    private void bracketProcessB(BracketData bd, byte level) {</b>
<b class="nc"><i>1721</i>&nbsp;        bd.isoRunLast = 0;</b>
<i>1722</i>&nbsp;        bd.isoRuns[0].limit = 0;
<i>1723</i>&nbsp;        bd.isoRuns[0].level = level;
<i>1724</i>&nbsp;        bd.isoRuns[0].lastStrong = bd.isoRuns[0].lastBase = bd.isoRuns[0].contextDir = (byte)(level &amp; 1);
<i>1725</i>&nbsp;        bd.isoRuns[0].contextPos = 0;
<i>1726</i>&nbsp;    }
<i>1727</i>&nbsp;
<i>1728</i>&nbsp;    /* LRE, LRO, RLE, RLO, PDF */
<i>1729</i>&nbsp;    private void bracketProcessBoundary(BracketData bd, int lastCcPos,
<i>1730</i>&nbsp;                                        byte contextLevel, byte embeddingLevel) {
<i>1731</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1732</i>&nbsp;        if ((DirPropFlag(dirProps[lastCcPos]) &amp; MASK_ISO) != 0) /* after an isolate */
<i>1733</i>&nbsp;            return;
<i>1734</i>&nbsp;        if (NoOverride(embeddingLevel) &gt; NoOverride(contextLevel))  /* not a PDF */
<i>1735</i>&nbsp;            contextLevel = embeddingLevel;
<i>1736</i>&nbsp;        pLastIsoRun.limit = pLastIsoRun.start;
<i>1737</i>&nbsp;        pLastIsoRun.level = embeddingLevel;
<i>1738</i>&nbsp;        pLastIsoRun.lastStrong = pLastIsoRun.lastBase = pLastIsoRun.contextDir = (byte)(contextLevel &amp; 1);
<i>1739</i>&nbsp;        pLastIsoRun.contextPos = lastCcPos;
<i>1740</i>&nbsp;    }
<i>1741</i>&nbsp;
<i>1742</i>&nbsp;    /* LRI or RLI */
<i>1743</i>&nbsp;    private void bracketProcessLRI_RLI(BracketData bd, byte level) {
<i>1744</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1745</i>&nbsp;        short lastLimit;
<i>1746</i>&nbsp;        pLastIsoRun.lastBase = ON;
<i>1747</i>&nbsp;        lastLimit = pLastIsoRun.limit;
<i>1748</i>&nbsp;        bd.isoRunLast++;
<i>1749</i>&nbsp;        pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1750</i>&nbsp;        if (pLastIsoRun == null)
<i>1751</i>&nbsp;            pLastIsoRun = bd.isoRuns[bd.isoRunLast] = new IsoRun();
<i>1752</i>&nbsp;        pLastIsoRun.start = pLastIsoRun.limit = lastLimit;
<i>1753</i>&nbsp;        pLastIsoRun.level = level;
<i>1754</i>&nbsp;        pLastIsoRun.lastStrong = pLastIsoRun.lastBase = pLastIsoRun.contextDir = (byte)(level &amp; 1);
<i>1755</i>&nbsp;        pLastIsoRun.contextPos = 0;
<i>1756</i>&nbsp;    }
<i>1757</i>&nbsp;
<i>1758</i>&nbsp;    /* PDI */
<i>1759</i>&nbsp;    private void bracketProcessPDI(BracketData bd) {
<i>1760</i>&nbsp;        IsoRun pLastIsoRun;
<b class="nc"><i>1761</i>&nbsp;        bd.isoRunLast--;</b>
<i>1762</i>&nbsp;        pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1763</i>&nbsp;        pLastIsoRun.lastBase = ON;
<i>1764</i>&nbsp;    }
<i>1765</i>&nbsp;
<i>1766</i>&nbsp;    /* newly found opening bracket: create an openings entry */
<i>1767</i>&nbsp;    private void bracketAddOpening(BracketData bd, char match, int position) {
<i>1768</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1769</i>&nbsp;        Opening pOpening;
<i>1770</i>&nbsp;        if (pLastIsoRun.limit &gt;= bd.openings.length) {  /* no available new entry */
<i>1771</i>&nbsp;            Opening[] saveOpenings = bd.openings;
<i>1772</i>&nbsp;            int count;
<i>1773</i>&nbsp;            try {
<i>1774</i>&nbsp;                count = bd.openings.length;
<b class="nc"><i>1775</i>&nbsp;                bd.openings = new Opening[count * 2];</b>
<i>1776</i>&nbsp;            } catch (Exception e) {
<i>1777</i>&nbsp;                throw new OutOfMemoryError(&quot;Failed to allocate memory for openings&quot;);
<i>1778</i>&nbsp;            }
<i>1779</i>&nbsp;            System.arraycopy(saveOpenings, 0, bd.openings, 0, count);
<i>1780</i>&nbsp;        }
<i>1781</i>&nbsp;        pOpening = bd.openings[pLastIsoRun.limit];
<i>1782</i>&nbsp;        if (pOpening == null)
<i>1783</i>&nbsp;            pOpening = bd.openings[pLastIsoRun.limit]= new Opening();
<i>1784</i>&nbsp;        pOpening.position = position;
<i>1785</i>&nbsp;        pOpening.match = match;
<i>1786</i>&nbsp;        pOpening.contextDir = pLastIsoRun.contextDir;
<i>1787</i>&nbsp;        pOpening.contextPos = pLastIsoRun.contextPos;
<i>1788</i>&nbsp;        pOpening.flags = 0;
<b class="nc"><i>1789</i>&nbsp;        pLastIsoRun.limit++;</b>
<i>1790</i>&nbsp;    }
<b class="nc"><i>1791</i>&nbsp;</b>
<i>1792</i>&nbsp;    /* change N0c1 to N0c2 when a preceding bracket is assigned the embedding level */
<i>1793</i>&nbsp;    private void fixN0c(BracketData bd, int openingIndex, int newPropPosition, byte newProp) {
<b class="nc"><i>1794</i>&nbsp;        /* This function calls itself recursively */</b>
<i>1795</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1796</i>&nbsp;        Opening qOpening;
<i>1797</i>&nbsp;        int k, openingPosition, closingPosition;
<i>1798</i>&nbsp;        for (k = openingIndex+1; k &lt; pLastIsoRun.limit; k++) {
<i>1799</i>&nbsp;            qOpening = bd.openings[k];
<i>1800</i>&nbsp;            if (qOpening.match &gt;= 0)    /* not an N0c match */
<i>1801</i>&nbsp;                continue;
<i>1802</i>&nbsp;            if (newPropPosition &lt; qOpening.contextPos)
<i>1803</i>&nbsp;                break;
<i>1804</i>&nbsp;            if (newPropPosition &gt;= qOpening.position)
<b class="nc"><i>1805</i>&nbsp;                continue;</b>
<i>1806</i>&nbsp;            if (newProp == qOpening.contextDir)
<i>1807</i>&nbsp;                break;
<b class="nc"><i>1808</i>&nbsp;            openingPosition = qOpening.position;</b>
<i>1809</i>&nbsp;            dirProps[openingPosition] = newProp;
<i>1810</i>&nbsp;            closingPosition = -(qOpening.match);
<i>1811</i>&nbsp;            dirProps[closingPosition] = newProp;
<i>1812</i>&nbsp;            qOpening.match = 0;                                 /* prevent further changes */
<i>1813</i>&nbsp;            fixN0c(bd, k, openingPosition, newProp);
<i>1814</i>&nbsp;            fixN0c(bd, k, closingPosition, newProp);
<i>1815</i>&nbsp;        }
<i>1816</i>&nbsp;    }
<i>1817</i>&nbsp;
<i>1818</i>&nbsp;    /* process closing bracket; return L or R if N0b or N0c, ON if N0d */
<i>1819</i>&nbsp;    private byte bracketProcessClosing(BracketData bd, int openIdx, int position) {
<b class="nc"><i>1820</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];</b>
<i>1821</i>&nbsp;        Opening pOpening, qOpening;
<i>1822</i>&nbsp;        byte direction;
<i>1823</i>&nbsp;        boolean stable;
<i>1824</i>&nbsp;        byte newProp;
<i>1825</i>&nbsp;        pOpening = bd.openings[openIdx];
<i>1826</i>&nbsp;        direction = (byte)(pLastIsoRun.level &amp; 1);
<i>1827</i>&nbsp;        stable = true;          /* assume stable until proved otherwise */
<i>1828</i>&nbsp;
<i>1829</i>&nbsp;        /* The stable flag is set when brackets are paired and their
<i>1830</i>&nbsp;           level is resolved and cannot be changed by what will be
<b class="nc"><i>1831</i>&nbsp;           found later in the source string.</b>
<i>1832</i>&nbsp;           An unstable match can occur only when applying N0c, where
<i>1833</i>&nbsp;           the resolved level depends on the preceding context, and
<i>1834</i>&nbsp;           this context may be affected by text occurring later.
<b class="nc"><i>1835</i>&nbsp;           Example: RTL paragraph containing:  abc[(latin) HEBREW]</b>
<i>1836</i>&nbsp;           When the closing parenthesis is encountered, it appears
<i>1837</i>&nbsp;           that N0c1 must be applied since &#39;abc&#39; sets an opposite
<i>1838</i>&nbsp;           direction context and both parentheses receive level 2.
<i>1839</i>&nbsp;           However, when the closing square bracket is processed,
<i>1840</i>&nbsp;           N0b applies because of &#39;HEBREW&#39; being included within the
<i>1841</i>&nbsp;           brackets, thus the square brackets are treated like R and
<i>1842</i>&nbsp;           receive level 1. However, this changes the preceding
<i>1843</i>&nbsp;           context of the opening parenthesis, and it now appears
<i>1844</i>&nbsp;           that N0c2 must be applied to the parentheses rather than
<i>1845</i>&nbsp;           N0c1. */
<i>1846</i>&nbsp;
<b class="nc"><i>1847</i>&nbsp;            if ((direction == 0 &amp;&amp; (pOpening.flags &amp; FOUND_L) &gt; 0) ||</b>
<i>1848</i>&nbsp;                (direction == 1 &amp;&amp; (pOpening.flags &amp; FOUND_R) &gt; 0)) {   /* N0b */
<i>1849</i>&nbsp;                newProp = direction;
<i>1850</i>&nbsp;            }
<i>1851</i>&nbsp;            else if ((pOpening.flags &amp; (FOUND_L | FOUND_R)) != 0) {     /* N0c */
<i>1852</i>&nbsp;                    /* it is stable if there is no preceding text or in
<i>1853</i>&nbsp;                       conditions too complicated and not worth checking */
<i>1854</i>&nbsp;                    stable = (openIdx == pLastIsoRun.start);
<i>1855</i>&nbsp;                if (direction != pOpening.contextDir)
<i>1856</i>&nbsp;                    newProp = pOpening.contextDir;                      /* N0c1 */
<i>1857</i>&nbsp;                else
<i>1858</i>&nbsp;                    newProp = direction;                                /* N0c2 */
<b class="nc"><i>1859</i>&nbsp;            } else {</b>
<i>1860</i>&nbsp;            /* forget this and any brackets nested within this pair */
<i>1861</i>&nbsp;            pLastIsoRun.limit = (short)openIdx;
<i>1862</i>&nbsp;            return ON;                                                  /* N0d */
<b class="nc"><i>1863</i>&nbsp;        }</b>
<i>1864</i>&nbsp;        dirProps[pOpening.position] = newProp;
<i>1865</i>&nbsp;        dirProps[position] = newProp;
<i>1866</i>&nbsp;        /* Update nested N0c pairs that may be affected */
<i>1867</i>&nbsp;        fixN0c(bd, openIdx, pOpening.position, newProp);
<i>1868</i>&nbsp;        if (stable) {
<i>1869</i>&nbsp;            pLastIsoRun.limit = (short)openIdx; /* forget any brackets nested within this pair */
<i>1870</i>&nbsp;            /* remove lower located synonyms if any */
<i>1871</i>&nbsp;            while (pLastIsoRun.limit &gt; pLastIsoRun.start &amp;&amp;
<i>1872</i>&nbsp;                   bd.openings[pLastIsoRun.limit - 1].position == pOpening.position)
<i>1873</i>&nbsp;                pLastIsoRun.limit--;
<i>1874</i>&nbsp;        } else {
<i>1875</i>&nbsp;            int k;
<b class="nc"><i>1876</i>&nbsp;            pOpening.match = -position;</b>
<b class="nc"><i>1877</i>&nbsp;            /* neutralize lower located synonyms if any */</b>
<i>1878</i>&nbsp;            k = openIdx - 1;
<i>1879</i>&nbsp;            while (k &gt;= pLastIsoRun.start &amp;&amp;
<b class="nc"><i>1880</i>&nbsp;                   bd.openings[k].position == pOpening.position)</b>
<i>1881</i>&nbsp;                bd.openings[k--].match = 0;
<i>1882</i>&nbsp;            /* neutralize any unmatched opening between the current pair;
<i>1883</i>&nbsp;               this will also neutralize higher located synonyms if any */
<i>1884</i>&nbsp;            for (k = openIdx + 1; k &lt; pLastIsoRun.limit; k++) {
<i>1885</i>&nbsp;                qOpening =bd.openings[k];
<i>1886</i>&nbsp;                if (qOpening.position &gt;= position)
<i>1887</i>&nbsp;                    break;
<i>1888</i>&nbsp;                if (qOpening.match &gt; 0)
<i>1889</i>&nbsp;                    qOpening.match = 0;
<i>1890</i>&nbsp;            }
<i>1891</i>&nbsp;        }
<b class="nc"><i>1892</i>&nbsp;        return newProp;</b>
<i>1893</i>&nbsp;    }
<i>1894</i>&nbsp;
<i>1895</i>&nbsp;    /* handle strong characters, digits and candidates for closing brackets */
<i>1896</i>&nbsp;    private void bracketProcessChar(BracketData bd, int position) {
<i>1897</i>&nbsp;        IsoRun pLastIsoRun = bd.isoRuns[bd.isoRunLast];
<i>1898</i>&nbsp;        byte dirProp, newProp;
<i>1899</i>&nbsp;        byte level;
<i>1900</i>&nbsp;        dirProp = dirProps[position];
<i>1901</i>&nbsp;        if (dirProp == ON) {
<i>1902</i>&nbsp;            char c, match;
<i>1903</i>&nbsp;            int idx;
<i>1904</i>&nbsp;            /* First see if it is a matching closing bracket. Hopefully, this is
<b class="nc"><i>1905</i>&nbsp;               more efficient than checking if it is a closing bracket at all */</b>
<b class="nc"><i>1906</i>&nbsp;            c = text[position];</b>
<i>1907</i>&nbsp;            for (idx = pLastIsoRun.limit - 1; idx &gt;= pLastIsoRun.start; idx--) {
<i>1908</i>&nbsp;                if (bd.openings[idx].match != c)
<i>1909</i>&nbsp;                    continue;
<b class="nc"><i>1910</i>&nbsp;                /* We have a match */</b>
<i>1911</i>&nbsp;                newProp = bracketProcessClosing(bd, idx, position);
<i>1912</i>&nbsp;                if(newProp == ON) {         /* N0d */
<b class="nc"><i>1913</i>&nbsp;                    c = 0;          /* prevent handling as an opening */</b>
<i>1914</i>&nbsp;                    break;
<i>1915</i>&nbsp;                }
<i>1916</i>&nbsp;                pLastIsoRun.lastBase = ON;
<i>1917</i>&nbsp;                pLastIsoRun.contextDir = newProp;
<i>1918</i>&nbsp;                pLastIsoRun.contextPos = position;
<i>1919</i>&nbsp;                level = levels[position];
<i>1920</i>&nbsp;                if ((level &amp; LEVEL_OVERRIDE) != 0) {    /* X4, X5 */
<i>1921</i>&nbsp;                    short flag;
<i>1922</i>&nbsp;                    int i;
<b class="nc"><i>1923</i>&nbsp;                    newProp = (byte)(level &amp; 1);</b>
<i>1924</i>&nbsp;                    pLastIsoRun.lastStrong = newProp;
<i>1925</i>&nbsp;                    flag = (short)DirPropFlag(newProp);
<i>1926</i>&nbsp;                    for (i = pLastIsoRun.start; i &lt; idx; i++)
<b class="nc"><i>1927</i>&nbsp;                        bd.openings[i].flags |= flag;</b>
<i>1928</i>&nbsp;                    /* matching brackets are not overridden by LRO/RLO */
<i>1929</i>&nbsp;                    levels[position] &amp;= ~LEVEL_OVERRIDE;
<i>1930</i>&nbsp;                }
<i>1931</i>&nbsp;                /* matching brackets are not overridden by LRO/RLO */
<i>1932</i>&nbsp;                levels[bd.openings[idx].position] &amp;= ~LEVEL_OVERRIDE;
<i>1933</i>&nbsp;                return;
<i>1934</i>&nbsp;            }
<i>1935</i>&nbsp;            /* We get here only if the ON character is not a matching closing
<i>1936</i>&nbsp;               bracket or it is a case of N0d */
<i>1937</i>&nbsp;            /* Now see if it is an opening bracket */
<i>1938</i>&nbsp;            if (c != 0) {
<i>1939</i>&nbsp;                match = (char)UCharacter.getBidiPairedBracket(c); /* get the matching char */
<i>1940</i>&nbsp;            } else {
<i>1941</i>&nbsp;                match = 0;
<i>1942</i>&nbsp;            }
<i>1943</i>&nbsp;            if (match != c &amp;&amp;               /* has a matching char */
<i>1944</i>&nbsp;                UCharacter.getIntPropertyValue(c, BIDI_PAIRED_BRACKET_TYPE) ==
<i>1945</i>&nbsp;                    /* opening bracket */         BidiPairedBracketType.OPEN) {
<b class="nc"><i>1946</i>&nbsp;                /* special case: process synonyms</b>
<i>1947</i>&nbsp;                   create an opening entry for each synonym */
<b class="nc"><i>1948</i>&nbsp;                if (match == 0x232A) {      /* RIGHT-POINTING ANGLE BRACKET */</b>
<b class="nc"><i>1949</i>&nbsp;                    bracketAddOpening(bd, (char)0x3009, position);</b>
<b class="nc"><i>1950</i>&nbsp;                }</b>
<b class="nc"><i>1951</i>&nbsp;                else if (match == 0x3009) { /* RIGHT ANGLE BRACKET */</b>
<i>1952</i>&nbsp;                    bracketAddOpening(bd, (char)0x232A, position);
<b class="nc"><i>1953</i>&nbsp;                }</b>
<b class="nc"><i>1954</i>&nbsp;                bracketAddOpening(bd, match, position);</b>
<b class="nc"><i>1955</i>&nbsp;            }</b>
<b class="nc"><i>1956</i>&nbsp;        }</b>
<i>1957</i>&nbsp;        level = levels[position];
<b class="nc"><i>1958</i>&nbsp;        if ((level &amp; LEVEL_OVERRIDE) != 0) {    /* X4, X5 */</b>
<b class="nc"><i>1959</i>&nbsp;            newProp = (byte)(level &amp; 1);</b>
<b class="nc"><i>1960</i>&nbsp;            if (dirProp != S &amp;&amp; dirProp != WS &amp;&amp; dirProp != ON)</b>
<b class="nc"><i>1961</i>&nbsp;                dirProps[position] = newProp;</b>
<i>1962</i>&nbsp;            pLastIsoRun.lastBase = newProp;
<i>1963</i>&nbsp;            pLastIsoRun.lastStrong = newProp;
<i>1964</i>&nbsp;            pLastIsoRun.contextDir = newProp;
<i>1965</i>&nbsp;            pLastIsoRun.contextPos = position;
<i>1966</i>&nbsp;        }
<i>1967</i>&nbsp;        else if (dirProp &lt;= R || dirProp == AL) {
<i>1968</i>&nbsp;            newProp = DirFromStrong(dirProp);
<i>1969</i>&nbsp;            pLastIsoRun.lastBase = dirProp;
<i>1970</i>&nbsp;            pLastIsoRun.lastStrong = dirProp;
<i>1971</i>&nbsp;            pLastIsoRun.contextDir = newProp;
<i>1972</i>&nbsp;            pLastIsoRun.contextPos = position;
<i>1973</i>&nbsp;        }
<i>1974</i>&nbsp;        else if(dirProp == EN) {
<i>1975</i>&nbsp;            pLastIsoRun.lastBase = EN;
<i>1976</i>&nbsp;            if (pLastIsoRun.lastStrong == L) {
<i>1977</i>&nbsp;                newProp = L;                    /* W7 */
<i>1978</i>&nbsp;                if (!bd.isNumbersSpecial)
<i>1979</i>&nbsp;                    dirProps[position] = ENL;
<i>1980</i>&nbsp;                pLastIsoRun.contextDir = L;
<i>1981</i>&nbsp;                pLastIsoRun.contextPos = position;
<b class="nc"><i>1982</i>&nbsp;            }</b>
<b class="nc"><i>1983</i>&nbsp;            else {</b>
<i>1984</i>&nbsp;                newProp = R;                    /* N0 */
<i>1985</i>&nbsp;                if (pLastIsoRun.lastStrong == AL)
<i>1986</i>&nbsp;                    dirProps[position] = AN;    /* W2 */
<i>1987</i>&nbsp;                else
<b class="nc"><i>1988</i>&nbsp;                    dirProps[position] = ENR;</b>
<b class="nc"><i>1989</i>&nbsp;                pLastIsoRun.contextDir = R;</b>
<b class="nc"><i>1990</i>&nbsp;                pLastIsoRun.contextPos = position;</b>
<b class="nc"><i>1991</i>&nbsp;            }</b>
<b class="nc"><i>1992</i>&nbsp;        }</b>
<b class="nc"><i>1993</i>&nbsp;        else if (dirProp == AN) {</b>
<i>1994</i>&nbsp;            newProp = R;                        /* N0 */
<b class="nc"><i>1995</i>&nbsp;            pLastIsoRun.lastBase = AN;</b>
<b class="nc"><i>1996</i>&nbsp;            pLastIsoRun.contextDir = R;</b>
<i>1997</i>&nbsp;            pLastIsoRun.contextPos = position;
<b class="nc"><i>1998</i>&nbsp;        }</b>
<b class="nc"><i>1999</i>&nbsp;        else if (dirProp == NSM) {</b>
<i>2000</i>&nbsp;            /* if the last real char was ON, change NSM to ON so that it
<i>2001</i>&nbsp;               will stay ON even if the last real char is a bracket which
<b class="nc"><i>2002</i>&nbsp;               may be changed to L or R */</b>
<b class="nc"><i>2003</i>&nbsp;            newProp = pLastIsoRun.lastBase;</b>
<i>2004</i>&nbsp;            if (newProp == ON)
<i>2005</i>&nbsp;                dirProps[position] = newProp;
<i>2006</i>&nbsp;        }
<b class="nc"><i>2007</i>&nbsp;        else {</b>
<b class="nc"><i>2008</i>&nbsp;            newProp = dirProp;</b>
<i>2009</i>&nbsp;            pLastIsoRun.lastBase = dirProp;
<b class="nc"><i>2010</i>&nbsp;        }</b>
<i>2011</i>&nbsp;        if (newProp &lt;= R || newProp == AL) {
<b class="nc"><i>2012</i>&nbsp;            int i;</b>
<i>2013</i>&nbsp;            short flag = (short)DirPropFlag(DirFromStrong(newProp));
<i>2014</i>&nbsp;            for (i = pLastIsoRun.start; i &lt; pLastIsoRun.limit; i++)
<b class="nc"><i>2015</i>&nbsp;                if (position &gt; bd.openings[i].position)</b>
<i>2016</i>&nbsp;                    bd.openings[i].flags |= flag;
<b class="nc"><i>2017</i>&nbsp;        }</b>
<b class="nc"><i>2018</i>&nbsp;    }</b>
<b class="nc"><i>2019</i>&nbsp;</b>
<i>2020</i>&nbsp;    /* perform (X1)..(X9) ------------------------------------------------------- */
<b class="nc"><i>2021</i>&nbsp;</b>
<b class="nc"><i>2022</i>&nbsp;    /* determine if the text is mixed-directional or single-directional */</b>
<b class="nc"><i>2023</i>&nbsp;    private byte directionFromFlags() {</b>
<i>2024</i>&nbsp;
<i>2025</i>&nbsp;        /* if the text contains AN and neutrals, then some neutrals may become RTL */
<i>2026</i>&nbsp;        if (!((flags &amp; MASK_RTL) != 0 ||
<i>2027</i>&nbsp;              ((flags &amp; DirPropFlag(AN)) != 0 &amp;&amp;
<b class="nc"><i>2028</i>&nbsp;               (flags &amp; MASK_POSSIBLE_N) != 0))) {</b>
<i>2029</i>&nbsp;            return LTR;
<b class="nc"><i>2030</i>&nbsp;        } else if ((flags &amp; MASK_LTR) == 0) {</b>
<i>2031</i>&nbsp;            return RTL;
<i>2032</i>&nbsp;        } else {
<b class="nc"><i>2033</i>&nbsp;            return MIXED;</b>
<b class="nc"><i>2034</i>&nbsp;        }</b>
<b class="nc"><i>2035</i>&nbsp;    }</b>
<b class="nc"><i>2036</i>&nbsp;</b>
<b class="nc"><i>2037</i>&nbsp;    /*</b>
<i>2038</i>&nbsp;     * Resolve the explicit levels as specified by explicit embedding codes.
<i>2039</i>&nbsp;     * Recalculate the flags to have them reflect the real properties
<i>2040</i>&nbsp;     * after taking the explicit embeddings into account.
<i>2041</i>&nbsp;     *
<i>2042</i>&nbsp;     * The BiDi algorithm is designed to result in the same behavior whether embedding
<b class="nc"><i>2043</i>&nbsp;     * levels are externally specified (from &quot;styled text&quot;, supposedly the preferred</b>
<i>2044</i>&nbsp;     * method) or set by explicit embedding codes (LRx, RLx, PDF, FSI, PDI) in the plain text.
<b class="nc"><i>2045</i>&nbsp;     * That is why (X9) instructs to remove all not-isolate explicit codes (and BN).</b>
<b class="nc"><i>2046</i>&nbsp;     * However, in a real implementation, the removal of these codes and their index</b>
<b class="nc"><i>2047</i>&nbsp;     * positions in the plain text is undesirable since it would result in</b>
<b class="nc"><i>2048</i>&nbsp;     * reallocated, reindexed text.</b>
<b class="nc"><i>2049</i>&nbsp;     * Instead, this implementation leaves the codes in there and just ignores them</b>
<i>2050</i>&nbsp;     * in the subsequent processing.
<i>2051</i>&nbsp;     * In order to get the same reordering behavior, positions with a BN or a not-isolate
<i>2052</i>&nbsp;     * explicit embedding code just get the same level assigned as the last &quot;real&quot;
<b class="nc"><i>2053</i>&nbsp;     * character.</b>
<i>2054</i>&nbsp;     *
<b class="nc"><i>2055</i>&nbsp;     * Some implementations, not this one, then overwrite some of these</b>
<i>2056</i>&nbsp;     * directionality properties at &quot;real&quot; same-level-run boundaries by
<b class="nc"><i>2057</i>&nbsp;     * L or R codes so that the resolution of weak types can be performed on the</b>
<b class="nc"><i>2058</i>&nbsp;     * entire paragraph at once instead of having to parse it once more and</b>
<i>2059</i>&nbsp;     * perform that resolution on same-level-runs.
<b class="nc"><i>2060</i>&nbsp;     * This limits the scope of the implicit rules in effectively</b>
<b class="nc"><i>2061</i>&nbsp;     * the same way as the run limits.</b>
<b class="nc"><i>2062</i>&nbsp;     *</b>
<i>2063</i>&nbsp;     * Instead, this implementation does not modify these codes, except for
<i>2064</i>&nbsp;     * paired brackets whose properties (ON) may be replaced by L or R.
<b class="nc"><i>2065</i>&nbsp;     * On one hand, the paragraph has to be scanned for same-level-runs, but</b>
<b class="nc"><i>2066</i>&nbsp;     * on the other hand, this saves another loop to reset these codes,</b>
<i>2067</i>&nbsp;     * or saves making and modifying a copy of dirProps[].
<i>2068</i>&nbsp;     *
<b class="nc"><i>2069</i>&nbsp;     *</b>
<b class="nc"><i>2070</i>&nbsp;     * Note that (Pn) and (Xn) changed significantly from version 4 of the BiDi algorithm.</b>
<i>2071</i>&nbsp;     *
<i>2072</i>&nbsp;     *
<i>2073</i>&nbsp;     * Handling the stack of explicit levels (Xn):
<i>2074</i>&nbsp;     *
<b class="nc"><i>2075</i>&nbsp;     * With the BiDi stack of explicit levels, as pushed with each</b>
<b class="nc"><i>2076</i>&nbsp;     * LRE, RLE, LRO, RLO, LRI, RLI and FSI and popped with each PDF and PDI,</b>
<b class="nc"><i>2077</i>&nbsp;     * the explicit level must never exceed MAX_EXPLICIT_LEVEL.</b>
<i>2078</i>&nbsp;     *
<i>2079</i>&nbsp;     * In order to have a correct push-pop semantics even in the case of overflows,
<i>2080</i>&nbsp;     * overflow counters and a valid isolate counter are used as described in UAX#9
<b class="nc"><i>2081</i>&nbsp;     * section 3.3.2 &quot;Explicit Levels and Directions&quot;.</b>
<i>2082</i>&nbsp;     *
<b class="nc"><i>2083</i>&nbsp;     * This implementation assumes that MAX_EXPLICIT_LEVEL is odd.</b>
<b class="nc"><i>2084</i>&nbsp;     *</b>
<b class="nc"><i>2085</i>&nbsp;     * Returns the direction</b>
<i>2086</i>&nbsp;     *
<b class="nc"><i>2087</i>&nbsp;     */</b>
<b class="nc"><i>2088</i>&nbsp;    private byte resolveExplicitLevels() {</b>
<i>2089</i>&nbsp;        int i = 0;
<i>2090</i>&nbsp;        byte dirProp;
<i>2091</i>&nbsp;        byte level = GetParaLevelAt(0);
<i>2092</i>&nbsp;        byte dirct;
<b class="nc"><i>2093</i>&nbsp;        isolateCount = 0;</b>
<b class="nc"><i>2094</i>&nbsp;</b>
<b class="nc"><i>2095</i>&nbsp;        /* determine if the text is mixed-directional or single-directional */</b>
<i>2096</i>&nbsp;        dirct = directionFromFlags();
<i>2097</i>&nbsp;
<i>2098</i>&nbsp;        /* we may not need to resolve any explicit levels */
<b class="nc"><i>2099</i>&nbsp;        if (dirct != MIXED) {</b>
<b class="nc"><i>2100</i>&nbsp;            /* not mixed directionality: levels don&#39;t matter - trailingWSStart will be 0 */</b>
<b class="nc"><i>2101</i>&nbsp;            return dirct;</b>
<b class="nc"><i>2102</i>&nbsp;        }</b>
<i>2103</i>&nbsp;
<i>2104</i>&nbsp;        if (reorderingMode &gt; REORDER_LAST_LOGICAL_TO_VISUAL) {
<i>2105</i>&nbsp;            /* inverse BiDi: mixed, but all characters are at the same embedding level */
<i>2106</i>&nbsp;            /* set all levels to the paragraph level */
<b class="nc"><i>2107</i>&nbsp;            int paraIndex, start, limit;</b>
<b class="nc"><i>2108</i>&nbsp;            for (paraIndex = 0; paraIndex &lt; paraCount; paraIndex++) {</b>
<b class="nc"><i>2109</i>&nbsp;                if (paraIndex == 0)</b>
<b class="nc"><i>2110</i>&nbsp;                    start = 0;</b>
<i>2111</i>&nbsp;                else
<i>2112</i>&nbsp;                    start = paras_limit[paraIndex - 1];
<b class="nc"><i>2113</i>&nbsp;                limit = paras_limit[paraIndex];</b>
<b class="nc"><i>2114</i>&nbsp;                level = paras_level[paraIndex];</b>
<b class="nc"><i>2115</i>&nbsp;                for (i = start; i &lt; limit; i++)</b>
<i>2116</i>&nbsp;                    levels[i] =level;
<i>2117</i>&nbsp;            }
<b class="nc"><i>2118</i>&nbsp;            return dirct;               /* no bracket matching for inverse BiDi */</b>
<b class="nc"><i>2119</i>&nbsp;        }</b>
<b class="nc"><i>2120</i>&nbsp;        if ((flags &amp; (MASK_EXPLICIT | MASK_ISO)) == 0) {</b>
<b class="nc"><i>2121</i>&nbsp;            /* no embeddings, set all levels to the paragraph level */</b>
<b class="nc"><i>2122</i>&nbsp;            /* we still have to perform bracket matching */</b>
<i>2123</i>&nbsp;            int paraIndex, start, limit;
<b class="nc"><i>2124</i>&nbsp;            BracketData bracketData = new BracketData();</b>
<b class="nc"><i>2125</i>&nbsp;            bracketInit(bracketData);</b>
<i>2126</i>&nbsp;            for (paraIndex = 0; paraIndex &lt; paraCount; paraIndex++) {
<i>2127</i>&nbsp;                if (paraIndex == 0)
<b class="nc"><i>2128</i>&nbsp;                    start = 0;</b>
<b class="nc"><i>2129</i>&nbsp;                else</b>
<b class="nc"><i>2130</i>&nbsp;                    start = paras_limit[paraIndex-1];</b>
<i>2131</i>&nbsp;                limit = paras_limit[paraIndex];
<b class="nc"><i>2132</i>&nbsp;                level = paras_level[paraIndex];</b>
<i>2133</i>&nbsp;                for (i = start; i &lt; limit; i++) {
<i>2134</i>&nbsp;                    levels[i] = level;
<i>2135</i>&nbsp;                    dirProp = dirProps[i];
<i>2136</i>&nbsp;                    if (dirProp == BN)
<b class="nc"><i>2137</i>&nbsp;                        continue;</b>
<b class="nc"><i>2138</i>&nbsp;                    if (dirProp == B) {</b>
<b class="nc"><i>2139</i>&nbsp;                        if ((i + 1) &lt; length) {</b>
<b class="nc"><i>2140</i>&nbsp;                            if (text[i] == CR &amp;&amp; text[i + 1] == LF)</b>
<i>2141</i>&nbsp;                                continue;   /* skip CR when followed by LF */
<i>2142</i>&nbsp;                            bracketProcessB(bracketData, level);
<i>2143</i>&nbsp;                        }
<i>2144</i>&nbsp;                        continue;
<i>2145</i>&nbsp;                    }
<b class="nc"><i>2146</i>&nbsp;                    bracketProcessChar(bracketData, i);</b>
<i>2147</i>&nbsp;                }
<i>2148</i>&nbsp;            }
<b class="nc"><i>2149</i>&nbsp;            return dirct;</b>
<b class="nc"><i>2150</i>&nbsp;        }</b>
<b class="nc"><i>2151</i>&nbsp;        /* continue to perform (Xn) */</b>
<b class="nc"><i>2152</i>&nbsp;</b>
<i>2153</i>&nbsp;        /* (X1) level is set for all codes, embeddingLevel keeps track of the push/pop operations */
<i>2154</i>&nbsp;        /* both variables may carry the LEVEL_OVERRIDE flag to indicate the override status */
<i>2155</i>&nbsp;        byte embeddingLevel = level, newLevel;
<i>2156</i>&nbsp;        byte previousLevel = level; /* previous level for regular (not CC) characters */
<i>2157</i>&nbsp;        int lastCcPos = 0;          /* index of last effective LRx,RLx, PDx */
<i>2158</i>&nbsp;
<b class="nc"><i>2159</i>&nbsp;        /* The following stack remembers the embedding level and the ISOLATE flag of level runs.</b>
<i>2160</i>&nbsp;           stackLast points to its current entry. */
<i>2161</i>&nbsp;        short[] stack = new short[MAX_EXPLICIT_LEVEL + 2];  /* we never push anything &gt;= MAX_EXPLICIT_LEVEL
<i>2162</i>&nbsp;                                                               but we need one more entry as base */
<b class="nc"><i>2163</i>&nbsp;        int stackLast = 0;</b>
<b class="nc"><i>2164</i>&nbsp;        int overflowIsolateCount = 0;</b>
<i>2165</i>&nbsp;        int overflowEmbeddingCount = 0;
<i>2166</i>&nbsp;        int validIsolateCount = 0;
<i>2167</i>&nbsp;        BracketData bracketData = new BracketData();
<i>2168</i>&nbsp;        bracketInit(bracketData);
<i>2169</i>&nbsp;        stack[0] = level;       /* initialize base entry to para level, no override, no isolate */
<i>2170</i>&nbsp;
<i>2171</i>&nbsp;        /* recalculate the flags */
<i>2172</i>&nbsp;        flags = 0;
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;        for (i = 0; i &lt; length; i++) {
<b class="nc"><i>2175</i>&nbsp;            dirProp = dirProps[i];</b>
<b class="nc"><i>2176</i>&nbsp;            switch (dirProp) {</b>
<b class="nc"><i>2177</i>&nbsp;            case LRE:</b>
<b class="nc"><i>2178</i>&nbsp;            case RLE:</b>
<b class="nc"><i>2179</i>&nbsp;            case LRO:</b>
<b class="nc"><i>2180</i>&nbsp;            case RLO:</b>
<b class="nc"><i>2181</i>&nbsp;                /* (X2, X3, X4, X5) */</b>
<i>2182</i>&nbsp;                flags |= DirPropFlag(BN);
<b class="nc"><i>2183</i>&nbsp;                levels[i] = previousLevel;</b>
<b class="nc"><i>2184</i>&nbsp;                if (dirProp == LRE || dirProp == LRO) {</b>
<i>2185</i>&nbsp;                    /* least greater even level */
<b class="nc"><i>2186</i>&nbsp;                    newLevel = (byte)((embeddingLevel+2) &amp; ~(LEVEL_OVERRIDE | 1));</b>
<i>2187</i>&nbsp;                } else {
<b class="nc"><i>2188</i>&nbsp;                    /* least greater odd level */</b>
<b class="nc"><i>2189</i>&nbsp;                    newLevel = (byte)((NoOverride(embeddingLevel) + 1) | 1);</b>
<i>2190</i>&nbsp;                }
<b class="nc"><i>2191</i>&nbsp;                if (newLevel &lt;= MAX_EXPLICIT_LEVEL &amp;&amp; overflowIsolateCount == 0 &amp;&amp;</b>
<b class="nc"><i>2192</i>&nbsp;                                                      overflowEmbeddingCount == 0) {</b>
<b class="nc"><i>2193</i>&nbsp;                    lastCcPos = i;</b>
<i>2194</i>&nbsp;                    embeddingLevel = newLevel;
<i>2195</i>&nbsp;                    if (dirProp == LRO || dirProp == RLO)
<b class="nc"><i>2196</i>&nbsp;                        embeddingLevel |= LEVEL_OVERRIDE;</b>
<b class="nc"><i>2197</i>&nbsp;                    stackLast++;</b>
<i>2198</i>&nbsp;                    stack[stackLast] = embeddingLevel;
<b class="nc"><i>2199</i>&nbsp;                    /* we don&#39;t need to set LEVEL_OVERRIDE off for LRE and RLE</b>
<b class="nc"><i>2200</i>&nbsp;                       since this has already been done for newLevel which is</b>
<b class="nc"><i>2201</i>&nbsp;                       the source for embeddingLevel.</b>
<b class="nc"><i>2202</i>&nbsp;                     */</b>
<b class="nc"><i>2203</i>&nbsp;                } else {</b>
<i>2204</i>&nbsp;                    if (overflowIsolateCount == 0)
<b class="nc"><i>2205</i>&nbsp;                        overflowEmbeddingCount++;</b>
<i>2206</i>&nbsp;                }
<b class="nc"><i>2207</i>&nbsp;                break;</b>
<b class="nc"><i>2208</i>&nbsp;            case PDF:</b>
<b class="nc"><i>2209</i>&nbsp;                /* (X7) */</b>
<i>2210</i>&nbsp;                flags |= DirPropFlag(BN);
<b class="nc"><i>2211</i>&nbsp;                levels[i] = previousLevel;</b>
<b class="nc"><i>2212</i>&nbsp;                /* handle all the overflow cases first */</b>
<b class="nc"><i>2213</i>&nbsp;                if (overflowIsolateCount &gt; 0) {</b>
<i>2214</i>&nbsp;                    break;
<b class="nc"><i>2215</i>&nbsp;                }</b>
<b class="nc"><i>2216</i>&nbsp;                if (overflowEmbeddingCount &gt; 0) {</b>
<i>2217</i>&nbsp;                    overflowEmbeddingCount--;
<b class="nc"><i>2218</i>&nbsp;                    break;</b>
<b class="nc"><i>2219</i>&nbsp;                }</b>
<b class="nc"><i>2220</i>&nbsp;                if (stackLast &gt; 0 &amp;&amp; stack[stackLast] &lt; ISOLATE) {   /* not an isolate entry */</b>
<b class="nc"><i>2221</i>&nbsp;                    lastCcPos = i;</b>
<i>2222</i>&nbsp;                    stackLast--;
<b class="nc"><i>2223</i>&nbsp;                    embeddingLevel = (byte)stack[stackLast];</b>
<b class="nc"><i>2224</i>&nbsp;                }</b>
<b class="nc"><i>2225</i>&nbsp;                break;</b>
<b class="nc"><i>2226</i>&nbsp;            case LRI:</b>
<i>2227</i>&nbsp;            case RLI:
<b class="nc"><i>2228</i>&nbsp;                flags |= DirPropFlag(ON) | DirPropFlagLR(embeddingLevel);</b>
<i>2229</i>&nbsp;                levels[i] = NoOverride(embeddingLevel);
<i>2230</i>&nbsp;                if (NoOverride(embeddingLevel) != NoOverride(previousLevel)) {
<i>2231</i>&nbsp;                    bracketProcessBoundary(bracketData, lastCcPos,
<i>2232</i>&nbsp;                                           previousLevel, embeddingLevel);
<b class="nc"><i>2233</i>&nbsp;                    flags |= DirPropFlagMultiRuns;</b>
<i>2234</i>&nbsp;                }
<i>2235</i>&nbsp;                previousLevel = embeddingLevel;
<i>2236</i>&nbsp;                /* (X5a, X5b) */
<i>2237</i>&nbsp;                if (dirProp == LRI)
<i>2238</i>&nbsp;                    /* least greater even level */
<i>2239</i>&nbsp;                    newLevel=(byte)((embeddingLevel+2)&amp;~(LEVEL_OVERRIDE|1));
<i>2240</i>&nbsp;                else
<i>2241</i>&nbsp;                    /* least greater odd level */
<i>2242</i>&nbsp;                    newLevel=(byte)((NoOverride(embeddingLevel)+1)|1);
<i>2243</i>&nbsp;                if (newLevel &lt;= MAX_EXPLICIT_LEVEL &amp;&amp; overflowIsolateCount == 0
<i>2244</i>&nbsp;                                                   &amp;&amp; overflowEmbeddingCount == 0) {
<i>2245</i>&nbsp;                    flags |= DirPropFlag(dirProp);
<i>2246</i>&nbsp;                    lastCcPos = i;
<b class="nc"><i>2247</i>&nbsp;                    validIsolateCount++;</b>
<i>2248</i>&nbsp;                    if (validIsolateCount &gt; isolateCount)
<b class="nc"><i>2249</i>&nbsp;                        isolateCount = validIsolateCount;</b>
<b class="nc"><i>2250</i>&nbsp;                    embeddingLevel = newLevel;</b>
<i>2251</i>&nbsp;                    /* we can increment stackLast without checking because newLevel
<b class="nc"><i>2252</i>&nbsp;                       will exceed UBIDI_MAX_EXPLICIT_LEVEL before stackLast overflows */</b>
<b class="nc"><i>2253</i>&nbsp;                    stackLast++;</b>
<b class="nc"><i>2254</i>&nbsp;                    stack[stackLast] = (short)(embeddingLevel + ISOLATE);</b>
<i>2255</i>&nbsp;                    bracketProcessLRI_RLI(bracketData, embeddingLevel);
<b class="nc"><i>2256</i>&nbsp;                } else {</b>
<i>2257</i>&nbsp;                    /* make it WS so that it is handled by adjustWSLevels() */
<i>2258</i>&nbsp;                    dirProps[i] = WS;
<i>2259</i>&nbsp;                    overflowIsolateCount++;
<i>2260</i>&nbsp;                }
<i>2261</i>&nbsp;                break;
<b class="nc"><i>2262</i>&nbsp;            case PDI:</b>
<b class="nc"><i>2263</i>&nbsp;                if (NoOverride(embeddingLevel) != NoOverride(previousLevel)) {</b>
<b class="nc"><i>2264</i>&nbsp;                    bracketProcessBoundary(bracketData, lastCcPos,</b>
<b class="nc"><i>2265</i>&nbsp;                                           previousLevel, embeddingLevel);</b>
<b class="nc"><i>2266</i>&nbsp;                    flags |= DirPropFlagMultiRuns;</b>
<b class="nc"><i>2267</i>&nbsp;                }</b>
<b class="nc"><i>2268</i>&nbsp;                /* (X6a) */</b>
<b class="nc"><i>2269</i>&nbsp;                if (overflowIsolateCount &gt; 0) {</b>
<b class="nc"><i>2270</i>&nbsp;                    overflowIsolateCount--;</b>
<b class="nc"><i>2271</i>&nbsp;                    /* make it WS so that it is handled by adjustWSLevels() */</b>
<i>2272</i>&nbsp;                    dirProps[i] = WS;
<i>2273</i>&nbsp;                }
<i>2274</i>&nbsp;                else if (validIsolateCount &gt; 0) {
<i>2275</i>&nbsp;                    flags |= DirPropFlag(PDI);
<i>2276</i>&nbsp;                    lastCcPos = i;
<i>2277</i>&nbsp;                    overflowEmbeddingCount = 0;
<i>2278</i>&nbsp;                    while (stack[stackLast] &lt; ISOLATE)  /* pop embedding entries */
<b class="nc"><i>2279</i>&nbsp;                        stackLast--;                    /* until the last isolate entry */</b>
<i>2280</i>&nbsp;                    stackLast--;                        /* pop also the last isolate entry */
<i>2281</i>&nbsp;                    validIsolateCount--;
<i>2282</i>&nbsp;                    bracketProcessPDI(bracketData);
<b class="nc"><i>2283</i>&nbsp;                } else</b>
<i>2284</i>&nbsp;                    /* make it WS so that it is handled by adjustWSLevels() */
<i>2285</i>&nbsp;                    dirProps[i] = WS;
<i>2286</i>&nbsp;                embeddingLevel = (byte)(stack[stackLast] &amp; ~ISOLATE);
<i>2287</i>&nbsp;                flags |= DirPropFlag(ON) | DirPropFlagLR(embeddingLevel);
<i>2288</i>&nbsp;                previousLevel = embeddingLevel;
<i>2289</i>&nbsp;                levels[i] = NoOverride(embeddingLevel);
<i>2290</i>&nbsp;                break;
<i>2291</i>&nbsp;            case B:
<i>2292</i>&nbsp;                flags |= DirPropFlag(B);
<i>2293</i>&nbsp;                levels[i] = GetParaLevelAt(i);
<i>2294</i>&nbsp;                if ((i + 1) &lt; length) {
<i>2295</i>&nbsp;                    if (text[i] == CR &amp;&amp; text[i + 1] == LF)
<i>2296</i>&nbsp;                        break;          /* skip CR when followed by LF */
<i>2297</i>&nbsp;                    overflowEmbeddingCount = overflowIsolateCount = 0;
<i>2298</i>&nbsp;                    validIsolateCount = 0;
<i>2299</i>&nbsp;                    stackLast = 0;
<i>2300</i>&nbsp;                    previousLevel = embeddingLevel = GetParaLevelAt(i + 1);
<i>2301</i>&nbsp;                    stack[0] = embeddingLevel;   /* initialize base entry to para level, no override, no isolate */
<i>2302</i>&nbsp;                    bracketProcessB(bracketData, embeddingLevel);
<i>2303</i>&nbsp;                }
<i>2304</i>&nbsp;                break;
<i>2305</i>&nbsp;            case BN:
<i>2306</i>&nbsp;                /* BN, LRE, RLE, and PDF are supposed to be removed (X9) */
<i>2307</i>&nbsp;                /* they will get their levels set correctly in adjustWSLevels() */
<i>2308</i>&nbsp;                levels[i] = previousLevel;
<i>2309</i>&nbsp;                flags |= DirPropFlag(BN);
<i>2310</i>&nbsp;                break;
<i>2311</i>&nbsp;            default:
<i>2312</i>&nbsp;                /* all other types are normal characters and get the &quot;real&quot; level */
<i>2313</i>&nbsp;                if (NoOverride(embeddingLevel) != NoOverride(previousLevel)) {
<i>2314</i>&nbsp;                    bracketProcessBoundary(bracketData, lastCcPos,
<i>2315</i>&nbsp;                                           previousLevel, embeddingLevel);
<i>2316</i>&nbsp;                    flags |= DirPropFlagMultiRuns;
<i>2317</i>&nbsp;                    if ((embeddingLevel &amp; LEVEL_OVERRIDE) != 0)
<i>2318</i>&nbsp;                        flags |= DirPropFlagO(embeddingLevel);
<i>2319</i>&nbsp;                    else
<i>2320</i>&nbsp;                        flags |= DirPropFlagE(embeddingLevel);
<i>2321</i>&nbsp;                }
<i>2322</i>&nbsp;                previousLevel = embeddingLevel;
<i>2323</i>&nbsp;                levels[i] = embeddingLevel;
<i>2324</i>&nbsp;                bracketProcessChar(bracketData, i);
<i>2325</i>&nbsp;                /* the dirProp may have been changed in bracketProcessChar() */
<i>2326</i>&nbsp;                flags |= DirPropFlag(dirProps[i]);
<i>2327</i>&nbsp;                break;
<i>2328</i>&nbsp;            }
<i>2329</i>&nbsp;        }
<i>2330</i>&nbsp;        if ((flags &amp; MASK_EMBEDDING) != 0) {
<i>2331</i>&nbsp;            flags |= DirPropFlagLR(paraLevel);
<i>2332</i>&nbsp;        }
<i>2333</i>&nbsp;        if (orderParagraphsLTR &amp;&amp; (flags &amp; DirPropFlag(B)) != 0) {
<i>2334</i>&nbsp;            flags |= DirPropFlag(L);
<i>2335</i>&nbsp;        }
<i>2336</i>&nbsp;        /* again, determine if the text is mixed-directional or single-directional */
<i>2337</i>&nbsp;        dirct = directionFromFlags();
<i>2338</i>&nbsp;
<i>2339</i>&nbsp;        return dirct;
<i>2340</i>&nbsp;    }
<i>2341</i>&nbsp;
<i>2342</i>&nbsp;    /*
<i>2343</i>&nbsp;     * Use a pre-specified embedding levels array:
<i>2344</i>&nbsp;     *
<i>2345</i>&nbsp;     * Adjust the directional properties for overrides (-&gt;LEVEL_OVERRIDE),
<i>2346</i>&nbsp;     * ignore all explicit codes (X9),
<i>2347</i>&nbsp;     * and check all the preset levels.
<i>2348</i>&nbsp;     *
<i>2349</i>&nbsp;     * Recalculate the flags to have them reflect the real properties
<i>2350</i>&nbsp;     * after taking the explicit embeddings into account.
<i>2351</i>&nbsp;     */
<i>2352</i>&nbsp;    private byte checkExplicitLevels() {
<i>2353</i>&nbsp;        byte dirProp;
<i>2354</i>&nbsp;        int i;
<i>2355</i>&nbsp;        int isolateCount = 0;
<i>2356</i>&nbsp;
<i>2357</i>&nbsp;        this.flags = 0;     /* collect all directionalities in the text */
<i>2358</i>&nbsp;        byte level;
<i>2359</i>&nbsp;        this.isolateCount = 0;
<i>2360</i>&nbsp;
<i>2361</i>&nbsp;        for (i = 0; i &lt; length; ++i) {
<i>2362</i>&nbsp;            if (levels[i] == 0) {
<i>2363</i>&nbsp;               levels[i] = paraLevel;
<b class="nc"><i>2364</i>&nbsp;            }</b>
<b class="nc"><i>2365</i>&nbsp;</b>
<i>2366</i>&nbsp;            // for backward compatibility
<b class="nc"><i>2367</i>&nbsp;            if (MAX_EXPLICIT_LEVEL &lt; (levels[i]&amp;0x7f)) {</b>
<i>2368</i>&nbsp;                if ((levels[i] &amp; LEVEL_OVERRIDE) != 0) {
<i>2369</i>&nbsp;                    levels[i] =  (byte)(paraLevel|LEVEL_OVERRIDE);
<i>2370</i>&nbsp;                } else {
<i>2371</i>&nbsp;                    levels[i] = paraLevel;
<i>2372</i>&nbsp;                }
<i>2373</i>&nbsp;            }
<i>2374</i>&nbsp;
<i>2375</i>&nbsp;            level = levels[i];
<i>2376</i>&nbsp;            dirProp = dirProps[i];
<i>2377</i>&nbsp;            if (dirProp == LRI || dirProp == RLI) {
<i>2378</i>&nbsp;                isolateCount++;
<i>2379</i>&nbsp;                if (isolateCount &gt; this.isolateCount)
<i>2380</i>&nbsp;                    this.isolateCount = isolateCount;
<i>2381</i>&nbsp;            }
<i>2382</i>&nbsp;            else if (dirProp == PDI) {
<i>2383</i>&nbsp;                isolateCount--;
<i>2384</i>&nbsp;            } else if (dirProp == B) {
<i>2385</i>&nbsp;                isolateCount = 0;
<i>2386</i>&nbsp;            }
<i>2387</i>&nbsp;            if ((level &amp; LEVEL_OVERRIDE) != 0) {
<i>2388</i>&nbsp;                /* keep the override flag in levels[i] but adjust the flags */
<i>2389</i>&nbsp;                level &amp;= ~LEVEL_OVERRIDE;     /* make the range check below simpler */
<i>2390</i>&nbsp;                flags |= DirPropFlagO(level);
<i>2391</i>&nbsp;            } else {
<i>2392</i>&nbsp;                /* set the flags */
<i>2393</i>&nbsp;                flags |= DirPropFlagE(level) | DirPropFlag(dirProp);
<i>2394</i>&nbsp;            }
<i>2395</i>&nbsp;            if ((level &lt; GetParaLevelAt(i) &amp;&amp;
<i>2396</i>&nbsp;                    !((0 == level) &amp;&amp; (dirProp == B))) ||
<i>2397</i>&nbsp;                    (MAX_EXPLICIT_LEVEL &lt; level)) {
<i>2398</i>&nbsp;                /* level out of bounds */
<i>2399</i>&nbsp;                throw new IllegalArgumentException(&quot;level &quot; + level +
<i>2400</i>&nbsp;                                                   &quot; out of bounds at &quot; + i);
<i>2401</i>&nbsp;            }
<i>2402</i>&nbsp;        }
<i>2403</i>&nbsp;        if ((flags &amp; MASK_EMBEDDING) != 0) {
<i>2404</i>&nbsp;            flags |= DirPropFlagLR(paraLevel);
<i>2405</i>&nbsp;        }
<i>2406</i>&nbsp;        /* determine if the text is mixed-directional or single-directional */
<i>2407</i>&nbsp;        return directionFromFlags();
<i>2408</i>&nbsp;    }
<i>2409</i>&nbsp;
<i>2410</i>&nbsp;    /*********************************************************************/
<i>2411</i>&nbsp;    /* The Properties state machine table                                */
<i>2412</i>&nbsp;    /*********************************************************************/
<i>2413</i>&nbsp;    /*                                                                   */
<i>2414</i>&nbsp;    /* All table cells are 8 bits:                                       */
<i>2415</i>&nbsp;    /*      bits 0..4:  next state                                       */
<i>2416</i>&nbsp;    /*      bits 5..7:  action to perform (if &gt; 0)                       */
<i>2417</i>&nbsp;    /*                                                                   */
<i>2418</i>&nbsp;    /* Cells may be of format &quot;n&quot; where n represents the next state      */
<i>2419</i>&nbsp;    /* (except for the rightmost column).                                */
<i>2420</i>&nbsp;    /* Cells may also be of format &quot;_(x,y)&quot; where x represents an action */
<i>2421</i>&nbsp;    /* to perform and y represents the next state.                       */
<i>2422</i>&nbsp;    /*                                                                   */
<i>2423</i>&nbsp;    /*********************************************************************/
<i>2424</i>&nbsp;    /* Definitions and type for properties state tables                  */
<i>2425</i>&nbsp;    /*********************************************************************/
<i>2426</i>&nbsp;    private static final int IMPTABPROPS_COLUMNS = 16;
<i>2427</i>&nbsp;    private static final int IMPTABPROPS_RES = IMPTABPROPS_COLUMNS - 1;
<i>2428</i>&nbsp;    private static short GetStateProps(short cell) {
<i>2429</i>&nbsp;        return (short)(cell &amp; 0x1f);
<i>2430</i>&nbsp;    }
<i>2431</i>&nbsp;    private static short GetActionProps(short cell) {
<i>2432</i>&nbsp;        return (short)(cell &gt;&gt; 5);
<i>2433</i>&nbsp;    }
<i>2434</i>&nbsp;
<i>2435</i>&nbsp;    private static final short groupProp[] =          /* dirProp regrouped */
<i>2436</i>&nbsp;    {
<i>2437</i>&nbsp;        /*  L   R   EN  ES  ET  AN  CS  B   S   WS  ON  LRE LRO AL  RLE RLO PDF NSM BN  FSI LRI RLI PDI ENL ENR */
<i>2438</i>&nbsp;            0,  1,  2,  7,  8,  3,  9,  6,  5,  4,  4,  10, 10, 12, 10, 10, 10, 11, 10, 4,  4,  4,  4,  13, 14
<i>2439</i>&nbsp;    };
<i>2440</i>&nbsp;    private static final short _L  = 0;
<i>2441</i>&nbsp;    private static final short _R  = 1;
<i>2442</i>&nbsp;    private static final short _EN = 2;
<i>2443</i>&nbsp;    private static final short _AN = 3;
<i>2444</i>&nbsp;    private static final short _ON = 4;
<i>2445</i>&nbsp;    private static final short _S  = 5;
<i>2446</i>&nbsp;    private static final short _B  = 6; /* reduced dirProp */
<i>2447</i>&nbsp;
<i>2448</i>&nbsp;    /*********************************************************************/
<b class="nc"><i>2449</i>&nbsp;    /*                                                                   */</b>
<b class="nc"><i>2450</i>&nbsp;    /*      PROPERTIES  STATE  TABLE                                     */</b>
<i>2451</i>&nbsp;    /*                                                                   */
<b class="nc"><i>2452</i>&nbsp;    /* In table impTabProps,                                             */</b>
<b class="nc"><i>2453</i>&nbsp;    /*      - the ON column regroups ON and WS, FSI, RLI, LRI and PDI    */</b>
<i>2454</i>&nbsp;    /*      - the BN column regroups BN, LRE, RLE, LRO, RLO, PDF         */
<i>2455</i>&nbsp;    /*      - the Res column is the reduced property assigned to a run   */
<i>2456</i>&nbsp;    /*                                                                   */
<b class="nc"><i>2457</i>&nbsp;    /* Action 1: process current run1, init new run1                     */</b>
<b class="nc"><i>2458</i>&nbsp;    /*        2: init new run2                                           */</b>
<b class="nc"><i>2459</i>&nbsp;    /*        3: process run1, process run2, init new run1               */</b>
<b class="nc"><i>2460</i>&nbsp;    /*        4: process run1, set run1=run2, init new run2              */</b>
<b class="nc"><i>2461</i>&nbsp;    /*                                                                   */</b>
<b class="nc"><i>2462</i>&nbsp;    /* Notes:                                                            */</b>
<i>2463</i>&nbsp;    /*  1) This table is used in resolveImplicitLevels().                */
<i>2464</i>&nbsp;    /*  2) This table triggers actions when there is a change in the Bidi*/
<i>2465</i>&nbsp;    /*     property of incoming characters (action 1).                   */
<i>2466</i>&nbsp;    /*  3) Most such property sequences are processed immediately (in    */
<b class="nc"><i>2467</i>&nbsp;    /*     fact, passed to processPropertySeq().                         */</b>
<b class="nc"><i>2468</i>&nbsp;    /*  4) However, numbers are assembled as one sequence. This means    */</b>
<b class="nc"><i>2469</i>&nbsp;    /*     that undefined situations (like CS following digits, until    */</b>
<b class="nc"><i>2470</i>&nbsp;    /*     it is known if the next char will be a digit) are held until  */</b>
<b class="nc"><i>2471</i>&nbsp;    /*     following chars define them.                                  */</b>
<b class="nc"><i>2472</i>&nbsp;    /*     Example: digits followed by CS, then comes another CS or ON;  */</b>
<i>2473</i>&nbsp;    /*              the digits will be processed, then the CS assigned   */
<i>2474</i>&nbsp;    /*              as the start of an ON sequence (action 3).           */
<i>2475</i>&nbsp;    /*  5) There are cases where more than one sequence must be          */
<i>2476</i>&nbsp;    /*     processed, for instance digits followed by CS followed by L:  */
<b class="nc"><i>2477</i>&nbsp;    /*     the digits must be processed as one sequence, and the CS      */</b>
<b class="nc"><i>2478</i>&nbsp;    /*     must be processed as an ON sequence, all this before starting */</b>
<i>2479</i>&nbsp;    /*     assembling chars for the opening L sequence.                  */
<b class="nc"><i>2480</i>&nbsp;    /*                                                                   */</b>
<i>2481</i>&nbsp;    /*                                                                   */
<i>2482</i>&nbsp;    private static final short impTabProps[][] =
<b class="nc"><i>2483</i>&nbsp;    {</b>
<i>2484</i>&nbsp;/*                        L,     R,    EN,    AN,    ON,     S,     B,    ES,    ET,    CS,    BN,   NSM,    AL,   ENL,   ENR,   Res */
<i>2485</i>&nbsp;/* 0 Init        */ {     1,     2,     4,     5,     7,    15,    17,     7,     9,     7,     0,     7,     3,    18,    21,   _ON },
<i>2486</i>&nbsp;/* 1 L           */ {     1,  32+2,  32+4,  32+5,  32+7, 32+15, 32+17,  32+7,  32+9,  32+7,     1,     1,  32+3, 32+18, 32+21,    _L },
<i>2487</i>&nbsp;/* 2 R           */ {  32+1,     2,  32+4,  32+5,  32+7, 32+15, 32+17,  32+7,  32+9,  32+7,     2,     2,  32+3, 32+18, 32+21,    _R },
<i>2488</i>&nbsp;/* 3 AL          */ {  32+1,  32+2,  32+6,  32+6,  32+8, 32+16, 32+17,  32+8,  32+8,  32+8,     3,     3,     3, 32+18, 32+21,    _R },
<b class="nc"><i>2489</i>&nbsp;/* 4 EN          */ {  32+1,  32+2,     4,  32+5,  32+7, 32+15, 32+17, 64+10,    11, 64+10,     4,     4,  32+3,    18,    21,   _EN },</b>
<b class="nc"><i>2490</i>&nbsp;/* 5 AN          */ {  32+1,  32+2,  32+4,     5,  32+7, 32+15, 32+17,  32+7,  32+9, 64+12,     5,     5,  32+3, 32+18, 32+21,   _AN },</b>
<b class="nc"><i>2491</i>&nbsp;/* 6 AL:EN/AN    */ {  32+1,  32+2,     6,     6,  32+8, 32+16, 32+17,  32+8,  32+8, 64+13,     6,     6,  32+3,    18,    21,   _AN },</b>
<i>2492</i>&nbsp;/* 7 ON          */ {  32+1,  32+2,  32+4,  32+5,     7, 32+15, 32+17,     7, 64+14,     7,     7,     7,  32+3, 32+18, 32+21,   _ON },
<b class="nc"><i>2493</i>&nbsp;/* 8 AL:ON       */ {  32+1,  32+2,  32+6,  32+6,     8, 32+16, 32+17,     8,     8,     8,     8,     8,  32+3, 32+18, 32+21,   _ON },</b>
<b class="nc"><i>2494</i>&nbsp;/* 9 ET          */ {  32+1,  32+2,     4,  32+5,     7, 32+15, 32+17,     7,     9,     7,     9,     9,  32+3,    18,    21,   _ON },</b>
<b class="nc"><i>2495</i>&nbsp;/*10 EN+ES/CS    */ {  96+1,  96+2,     4,  96+5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    10, 128+7,  96+3,    18,    21,   _EN },</b>
<i>2496</i>&nbsp;/*11 EN+ET       */ {  32+1,  32+2,     4,  32+5,  32+7, 32+15, 32+17,  32+7,    11,  32+7,    11,    11,  32+3,    18,    21,   _EN },
<b class="nc"><i>2497</i>&nbsp;/*12 AN+CS       */ {  96+1,  96+2,  96+4,     5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    12, 128+7,  96+3, 96+18, 96+21,   _AN },</b>
<b class="nc"><i>2498</i>&nbsp;/*13 AL:EN/AN+CS */ {  96+1,  96+2,     6,     6, 128+8, 96+16, 96+17, 128+8, 128+8, 128+8,    13, 128+8,  96+3,    18,    21,   _AN },</b>
<i>2499</i>&nbsp;/*14 ON+ET       */ {  32+1,  32+2, 128+4,  32+5,     7, 32+15, 32+17,     7,    14,     7,    14,    14,  32+3,128+18,128+21,   _ON },
<i>2500</i>&nbsp;/*15 S           */ {  32+1,  32+2,  32+4,  32+5,  32+7,    15, 32+17,  32+7,  32+9,  32+7,    15,  32+7,  32+3, 32+18, 32+21,    _S },
<b class="nc"><i>2501</i>&nbsp;/*16 AL:S        */ {  32+1,  32+2,  32+6,  32+6,  32+8,    16, 32+17,  32+8,  32+8,  32+8,    16,  32+8,  32+3, 32+18, 32+21,    _S },</b>
<b class="nc"><i>2502</i>&nbsp;/*17 B           */ {  32+1,  32+2,  32+4,  32+5,  32+7, 32+15,    17,  32+7,  32+9,  32+7,    17,  32+7,  32+3, 32+18, 32+21,    _B },</b>
<b class="nc"><i>2503</i>&nbsp;/*18 ENL         */ {  32+1,  32+2,    18,  32+5,  32+7, 32+15, 32+17, 64+19,    20, 64+19,    18,    18,  32+3,    18,    21,    _L },</b>
<i>2504</i>&nbsp;/*19 ENL+ES/CS   */ {  96+1,  96+2,    18,  96+5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    19, 128+7,  96+3,    18,    21,    _L },
<i>2505</i>&nbsp;/*20 ENL+ET      */ {  32+1,  32+2,    18,  32+5,  32+7, 32+15, 32+17,  32+7,    20,  32+7,    20,    20,  32+3,    18,    21,    _L },
<i>2506</i>&nbsp;/*21 ENR         */ {  32+1,  32+2,    21,  32+5,  32+7, 32+15, 32+17, 64+22,    23, 64+22,    21,    21,  32+3,    18,    21,   _AN },
<b class="nc"><i>2507</i>&nbsp;/*22 ENR+ES/CS   */ {  96+1,  96+2,    21,  96+5, 128+7, 96+15, 96+17, 128+7,128+14, 128+7,    22, 128+7,  96+3,    18,    21,   _AN },</b>
<i>2508</i>&nbsp;/*23 ENR+ET      */ {  32+1,  32+2,    21,  32+5,  32+7, 32+15, 32+17,  32+7,    23,  32+7,    23,    23,  32+3,    18,    21,   _AN }
<i>2509</i>&nbsp;    };
<i>2510</i>&nbsp;
<i>2511</i>&nbsp;    /*********************************************************************/
<i>2512</i>&nbsp;    /* The levels state machine tables                                   */
<i>2513</i>&nbsp;    /*********************************************************************/
<b class="nc"><i>2514</i>&nbsp;    /*                                                                   */</b>
<b class="nc"><i>2515</i>&nbsp;    /* All table cells are 8 bits:                                       */</b>
<b class="nc"><i>2516</i>&nbsp;    /*      bits 0..3:  next state                                       */</b>
<i>2517</i>&nbsp;    /*      bits 4..7:  action to perform (if &gt; 0)                       */
<i>2518</i>&nbsp;    /*                                                                   */
<b class="nc"><i>2519</i>&nbsp;    /* Cells may be of format &quot;n&quot; where n represents the next state      */</b>
<i>2520</i>&nbsp;    /* (except for the rightmost column).                                */
<i>2521</i>&nbsp;    /* Cells may also be of format &quot;_(x,y)&quot; where x represents an action */
<b class="nc"><i>2522</i>&nbsp;    /* to perform and y represents the next state.                       */</b>
<b class="nc"><i>2523</i>&nbsp;    /*                                                                   */</b>
<b class="nc"><i>2524</i>&nbsp;    /* This format limits each table to 16 states each and to 15 actions.*/</b>
<b class="nc"><i>2525</i>&nbsp;    /*                                                                   */</b>
<i>2526</i>&nbsp;    /*********************************************************************/
<i>2527</i>&nbsp;    /* Definitions and type for levels state tables                      */
<b class="nc"><i>2528</i>&nbsp;    /*********************************************************************/</b>
<b class="nc"><i>2529</i>&nbsp;    private static final int IMPTABLEVELS_COLUMNS = _B + 2;</b>
<i>2530</i>&nbsp;    private static final int IMPTABLEVELS_RES = IMPTABLEVELS_COLUMNS - 1;
<i>2531</i>&nbsp;    private static short GetState(byte cell) { return (short)(cell &amp; 0x0f); }
<i>2532</i>&nbsp;    private static short GetAction(byte cell) { return (short)(cell &gt;&gt; 4); }
<b class="nc"><i>2533</i>&nbsp;</b>
<i>2534</i>&nbsp;    private static class ImpTabPair {
<b class="nc"><i>2535</i>&nbsp;        byte[][][] imptab;</b>
<b class="nc"><i>2536</i>&nbsp;        short[][] impact;</b>
<b class="nc"><i>2537</i>&nbsp;</b>
<i>2538</i>&nbsp;        ImpTabPair(byte[][] table1, byte[][] table2,
<i>2539</i>&nbsp;                   short[] act1, short[] act2) {
<b class="nc"><i>2540</i>&nbsp;            imptab = new byte[][][] {table1, table2};</b>
<b class="nc"><i>2541</i>&nbsp;            impact = new short[][] {act1, act2};</b>
<i>2542</i>&nbsp;        }
<i>2543</i>&nbsp;    }
<i>2544</i>&nbsp;
<i>2545</i>&nbsp;    /*********************************************************************/
<i>2546</i>&nbsp;    /*                                                                   */
<i>2547</i>&nbsp;    /*      LEVELS  STATE  TABLES                                        */
<b class="nc"><i>2548</i>&nbsp;    /*                                                                   */</b>
<i>2549</i>&nbsp;    /* In all levels state tables,                                       */
<i>2550</i>&nbsp;    /*      - state 0 is the initial state                               */
<b class="nc"><i>2551</i>&nbsp;    /*      - the Res column is the increment to add to the text level   */</b>
<i>2552</i>&nbsp;    /*        for this property sequence.                                */
<i>2553</i>&nbsp;    /*                                                                   */
<b class="nc"><i>2554</i>&nbsp;    /* The impact arrays for each table of a pair map the local action   */</b>
<b class="nc"><i>2555</i>&nbsp;    /* numbers of the table to the total list of actions. For instance,  */</b>
<i>2556</i>&nbsp;    /* action 2 in a given table corresponds to the action number which  */
<i>2557</i>&nbsp;    /* appears in entry [2] of the impact array for that table.          */
<b class="nc"><i>2558</i>&nbsp;    /* The first entry of all impact arrays must be 0.                   */</b>
<i>2559</i>&nbsp;    /*                                                                   */
<i>2560</i>&nbsp;    /* Action 1: init conditional sequence                               */
<b class="nc"><i>2561</i>&nbsp;    /*        2: prepend conditional sequence to current sequence        */</b>
<b class="nc"><i>2562</i>&nbsp;    /*        3: set ON sequence to new level - 1                        */</b>
<i>2563</i>&nbsp;    /*        4: init EN/AN/ON sequence                                  */
<b class="nc"><i>2564</i>&nbsp;    /*        5: fix EN/AN/ON sequence followed by R                     */</b>
<i>2565</i>&nbsp;    /*        6: set previous level sequence to level 2                  */
<i>2566</i>&nbsp;    /*                                                                   */
<i>2567</i>&nbsp;    /* Notes:                                                            */
<i>2568</i>&nbsp;    /*  1) These tables are used in processPropertySeq(). The input      */
<i>2569</i>&nbsp;    /*     is property sequences as determined by resolveImplicitLevels. */
<i>2570</i>&nbsp;    /*  2) Most such property sequences are processed immediately        */
<i>2571</i>&nbsp;    /*     (levels are assigned).                                        */
<i>2572</i>&nbsp;    /*  3) However, some sequences cannot be assigned a final level till */
<i>2573</i>&nbsp;    /*     one or more following sequences are received. For instance,   */
<i>2574</i>&nbsp;    /*     ON following an R sequence within an even-level paragraph.    */
<i>2575</i>&nbsp;    /*     If the following sequence is R, the ON sequence will be       */
<i>2576</i>&nbsp;    /*     assigned basic run level+1, and so will the R sequence.       */
<b class="nc"><i>2577</i>&nbsp;    /*  4) S is generally handled like ON, since its level will be fixed */</b>
<i>2578</i>&nbsp;    /*     to paragraph level in adjustWSLevels().                       */
<b class="nc"><i>2579</i>&nbsp;    /*                                                                   */</b>
<b class="nc"><i>2580</i>&nbsp;</b>
<b class="nc"><i>2581</i>&nbsp;    private static final byte impTabL_DEFAULT[][] = /* Even paragraph level */</b>
<i>2582</i>&nbsp;        /*  In this table, conditional sequences receive the lower possible level
<i>2583</i>&nbsp;            until proven otherwise.
<b class="nc"><i>2584</i>&nbsp;        */</b>
<i>2585</i>&nbsp;    {
<i>2586</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2587</i>&nbsp;        /* 0 : init       */ {     0,     1,     0,     2,     0,     0,     0,  0 },
<i>2588</i>&nbsp;        /* 1 : R          */ {     0,     1,     3,     3,  0x14,  0x14,     0,  1 },
<b class="nc"><i>2589</i>&nbsp;        /* 2 : AN         */ {     0,     1,     0,     2,  0x15,  0x15,     0,  2 },</b>
<b class="nc"><i>2590</i>&nbsp;        /* 3 : R+EN/AN    */ {     0,     1,     3,     3,  0x14,  0x14,     0,  2 },</b>
<b class="nc"><i>2591</i>&nbsp;        /* 4 : R+ON       */ {     0,  0x21,  0x33,  0x33,     4,     4,     0,  0 },</b>
<b class="nc"><i>2592</i>&nbsp;        /* 5 : AN+ON      */ {     0,  0x21,     0,  0x32,     5,     5,     0,  0 }</b>
<i>2593</i>&nbsp;    };
<b class="nc"><i>2594</i>&nbsp;</b>
<i>2595</i>&nbsp;    private static final byte impTabR_DEFAULT[][] = /* Odd  paragraph level */
<i>2596</i>&nbsp;        /*  In this table, conditional sequences receive the lower possible level
<i>2597</i>&nbsp;            until proven otherwise.
<i>2598</i>&nbsp;        */
<i>2599</i>&nbsp;    {
<i>2600</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<b class="nc"><i>2601</i>&nbsp;        /* 0 : init       */ {     1,     0,     2,     2,     0,     0,     0,  0 },</b>
<b class="nc"><i>2602</i>&nbsp;        /* 1 : L          */ {     1,     0,     1,     3,  0x14,  0x14,     0,  1 },</b>
<b class="nc"><i>2603</i>&nbsp;        /* 2 : EN/AN      */ {     1,     0,     2,     2,     0,     0,     0,  1 },</b>
<i>2604</i>&nbsp;        /* 3 : L+AN       */ {     1,     0,     1,     3,     5,     5,     0,  1 },
<b class="nc"><i>2605</i>&nbsp;        /* 4 : L+ON       */ {  0x21,     0,  0x21,     3,     4,     4,     0,  0 },</b>
<i>2606</i>&nbsp;        /* 5 : L+AN+ON    */ {     1,     0,     1,     3,     5,     5,     0,  0 }
<b class="nc"><i>2607</i>&nbsp;    };</b>
<i>2608</i>&nbsp;
<i>2609</i>&nbsp;    private static final short[] impAct0 = {0,1,2,3,4};
<i>2610</i>&nbsp;
<b class="nc"><i>2611</i>&nbsp;    private static final ImpTabPair impTab_DEFAULT = new ImpTabPair(</b>
<i>2612</i>&nbsp;            impTabL_DEFAULT, impTabR_DEFAULT, impAct0, impAct0);
<i>2613</i>&nbsp;
<b class="nc"><i>2614</i>&nbsp;    private static final byte impTabL_NUMBERS_SPECIAL[][] = { /* Even paragraph level */</b>
<b class="nc"><i>2615</i>&nbsp;        /* In this table, conditional sequences receive the lower possible</b>
<i>2616</i>&nbsp;           level until proven otherwise.
<b class="nc"><i>2617</i>&nbsp;        */</b>
<i>2618</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2619</i>&nbsp;        /* 0 : init       */ {     0,     2,  0x11,  0x11,     0,     0,     0,  0 },
<i>2620</i>&nbsp;        /* 1 : L+EN/AN    */ {     0,  0x42,     1,     1,     0,     0,     0,  0 },
<b class="nc"><i>2621</i>&nbsp;        /* 2 : R          */ {     0,     2,     4,     4,  0x13,  0x13,     0,  1 },</b>
<b class="nc"><i>2622</i>&nbsp;        /* 3 : R+ON       */ {     0,  0x22,  0x34,  0x34,     3,     3,     0,  0 },</b>
<i>2623</i>&nbsp;        /* 4 : R+EN/AN    */ {     0,     2,     4,     4,  0x13,  0x13,     0,  2 }
<b class="nc"><i>2624</i>&nbsp;    };</b>
<i>2625</i>&nbsp;    private static final ImpTabPair impTab_NUMBERS_SPECIAL = new ImpTabPair(
<i>2626</i>&nbsp;            impTabL_NUMBERS_SPECIAL, impTabR_DEFAULT, impAct0, impAct0);
<i>2627</i>&nbsp;
<i>2628</i>&nbsp;    private static final byte impTabL_GROUP_NUMBERS_WITH_R[][] = {
<b class="nc"><i>2629</i>&nbsp;        /* In this table, EN/AN+ON sequences receive levels as if associated with R</b>
<b class="nc"><i>2630</i>&nbsp;           until proven that there is L or sor/eor on both sides. AN is handled like EN.</b>
<i>2631</i>&nbsp;        */
<i>2632</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2633</i>&nbsp;        /* 0 init         */ {     0,     3,  0x11,  0x11,     0,     0,     0,  0 },
<b class="nc"><i>2634</i>&nbsp;        /* 1 EN/AN        */ {  0x20,     3,     1,     1,     2,  0x20,  0x20,  2 },</b>
<b class="nc"><i>2635</i>&nbsp;        /* 2 EN/AN+ON     */ {  0x20,     3,     1,     1,     2,  0x20,  0x20,  1 },</b>
<i>2636</i>&nbsp;        /* 3 R            */ {     0,     3,     5,     5,  0x14,     0,     0,  1 },
<b class="nc"><i>2637</i>&nbsp;        /* 4 R+ON         */ {  0x20,     3,     5,     5,     4,  0x20,  0x20,  1 },</b>
<i>2638</i>&nbsp;        /* 5 R+EN/AN      */ {     0,     3,     5,     5,  0x14,     0,     0,  2 }
<i>2639</i>&nbsp;    };
<i>2640</i>&nbsp;    private static final byte impTabR_GROUP_NUMBERS_WITH_R[][] = {
<b class="nc"><i>2641</i>&nbsp;        /*  In this table, EN/AN+ON sequences receive levels as if associated with R</b>
<i>2642</i>&nbsp;            until proven that there is L on both sides. AN is handled like EN.
<i>2643</i>&nbsp;        */
<i>2644</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2645</i>&nbsp;        /* 0 init         */ {     2,     0,     1,     1,     0,     0,     0,  0 },
<b class="nc"><i>2646</i>&nbsp;        /* 1 EN/AN        */ {     2,     0,     1,     1,     0,     0,     0,  1 },</b>
<b class="nc"><i>2647</i>&nbsp;        /* 2 L            */ {     2,     0,  0x14,  0x14,  0x13,     0,     0,  1 },</b>
<i>2648</i>&nbsp;        /* 3 L+ON         */ {  0x22,     0,     4,     4,     3,     0,     0,  0 },
<i>2649</i>&nbsp;        /* 4 L+EN/AN      */ {  0x22,     0,     4,     4,     3,     0,     0,  1 }
<i>2650</i>&nbsp;    };
<i>2651</i>&nbsp;    private static final ImpTabPair impTab_GROUP_NUMBERS_WITH_R = new
<i>2652</i>&nbsp;            ImpTabPair(impTabL_GROUP_NUMBERS_WITH_R,
<i>2653</i>&nbsp;                       impTabR_GROUP_NUMBERS_WITH_R, impAct0, impAct0);
<i>2654</i>&nbsp;
<i>2655</i>&nbsp;    private static final byte impTabL_INVERSE_NUMBERS_AS_L[][] = {
<i>2656</i>&nbsp;        /* This table is identical to the Default LTR table except that EN and AN
<i>2657</i>&nbsp;           are handled like L.
<i>2658</i>&nbsp;        */
<i>2659</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2660</i>&nbsp;        /* 0 : init       */ {     0,     1,     0,     0,     0,     0,     0,  0 },
<i>2661</i>&nbsp;        /* 1 : R          */ {     0,     1,     0,     0,  0x14,  0x14,     0,  1 },
<i>2662</i>&nbsp;        /* 2 : AN         */ {     0,     1,     0,     0,  0x15,  0x15,     0,  2 },
<i>2663</i>&nbsp;        /* 3 : R+EN/AN    */ {     0,     1,     0,     0,  0x14,  0x14,     0,  2 },
<i>2664</i>&nbsp;        /* 4 : R+ON       */ {  0x20,     1,  0x20,  0x20,     4,     4,  0x20,  1 },
<i>2665</i>&nbsp;        /* 5 : AN+ON      */ {  0x20,     1,  0x20,  0x20,     5,     5,  0x20,  1 }
<i>2666</i>&nbsp;    };
<i>2667</i>&nbsp;    private static final byte impTabR_INVERSE_NUMBERS_AS_L[][] = {
<i>2668</i>&nbsp;        /* This table is identical to the Default RTL table except that EN and AN
<i>2669</i>&nbsp;           are handled like L.
<i>2670</i>&nbsp;        */
<i>2671</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2672</i>&nbsp;        /* 0 : init       */ {     1,     0,     1,     1,     0,     0,     0,  0 },
<i>2673</i>&nbsp;        /* 1 : L          */ {     1,     0,     1,     1,  0x14,  0x14,     0,  1 },
<i>2674</i>&nbsp;        /* 2 : EN/AN      */ {     1,     0,     1,     1,     0,     0,     0,  1 },
<i>2675</i>&nbsp;        /* 3 : L+AN       */ {     1,     0,     1,     1,     5,     5,     0,  1 },
<i>2676</i>&nbsp;        /* 4 : L+ON       */ {  0x21,     0,  0x21,  0x21,     4,     4,     0,  0 },
<i>2677</i>&nbsp;        /* 5 : L+AN+ON    */ {     1,     0,     1,     1,     5,     5,     0,  0 }
<i>2678</i>&nbsp;    };
<i>2679</i>&nbsp;    private static final ImpTabPair impTab_INVERSE_NUMBERS_AS_L = new ImpTabPair
<i>2680</i>&nbsp;            (impTabL_INVERSE_NUMBERS_AS_L, impTabR_INVERSE_NUMBERS_AS_L,
<i>2681</i>&nbsp;             impAct0, impAct0);
<i>2682</i>&nbsp;
<i>2683</i>&nbsp;    private static final byte impTabR_INVERSE_LIKE_DIRECT[][] = {  /* Odd  paragraph level */
<i>2684</i>&nbsp;        /*  In this table, conditional sequences receive the lower possible level
<i>2685</i>&nbsp;            until proven otherwise.
<i>2686</i>&nbsp;        */
<i>2687</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2688</i>&nbsp;        /* 0 : init       */ {     1,     0,     2,     2,     0,     0,     0,  0 },
<i>2689</i>&nbsp;        /* 1 : L          */ {     1,     0,     1,     2,  0x13,  0x13,     0,  1 },
<i>2690</i>&nbsp;        /* 2 : EN/AN      */ {     1,     0,     2,     2,     0,     0,     0,  1 },
<i>2691</i>&nbsp;        /* 3 : L+ON       */ {  0x21,  0x30,     6,     4,     3,     3,  0x30,  0 },
<i>2692</i>&nbsp;        /* 4 : L+ON+AN    */ {  0x21,  0x30,     6,     4,     5,     5,  0x30,  3 },
<b class="nc"><i>2693</i>&nbsp;        /* 5 : L+AN+ON    */ {  0x21,  0x30,     6,     4,     5,     5,  0x30,  2 },</b>
<b class="nc"><i>2694</i>&nbsp;        /* 6 : L+ON+EN    */ {  0x21,  0x30,     6,     4,     3,     3,  0x30,  1 }</b>
<b class="nc"><i>2695</i>&nbsp;    };</b>
<b class="nc"><i>2696</i>&nbsp;    private static final short[] impAct1 = {0,1,13,14};</b>
<b class="nc"><i>2697</i>&nbsp;    private static final ImpTabPair impTab_INVERSE_LIKE_DIRECT = new ImpTabPair(</b>
<b class="nc"><i>2698</i>&nbsp;            impTabL_DEFAULT, impTabR_INVERSE_LIKE_DIRECT, impAct0, impAct1);</b>
<i>2699</i>&nbsp;
<b class="nc"><i>2700</i>&nbsp;    private static final byte impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS[][] = {</b>
<i>2701</i>&nbsp;        /* The case handled in this table is (visually):  R EN L
<i>2702</i>&nbsp;         */
<i>2703</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<b class="nc"><i>2704</i>&nbsp;        /* 0 : init       */ {     0,  0x63,     0,     1,     0,     0,     0,  0 },</b>
<b class="nc"><i>2705</i>&nbsp;        /* 1 : L+AN       */ {     0,  0x63,     0,     1,  0x12,  0x30,     0,  4 },</b>
<b class="nc"><i>2706</i>&nbsp;        /* 2 : L+AN+ON    */ {  0x20,  0x63,  0x20,     1,     2,  0x30,  0x20,  3 },</b>
<b class="nc"><i>2707</i>&nbsp;        /* 3 : R          */ {     0,  0x63,  0x55,  0x56,  0x14,  0x30,     0,  3 },</b>
<b class="nc"><i>2708</i>&nbsp;        /* 4 : R+ON       */ {  0x30,  0x43,  0x55,  0x56,     4,  0x30,  0x30,  3 },</b>
<b class="nc"><i>2709</i>&nbsp;        /* 5 : R+EN       */ {  0x30,  0x43,     5,  0x56,  0x14,  0x30,  0x30,  4 },</b>
<b class="nc"><i>2710</i>&nbsp;        /* 6 : R+AN       */ {  0x30,  0x43,  0x55,     6,  0x14,  0x30,  0x30,  4 }</b>
<b class="nc"><i>2711</i>&nbsp;    };</b>
<b class="nc"><i>2712</i>&nbsp;    private static final byte impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS[][] = {</b>
<b class="nc"><i>2713</i>&nbsp;        /* The cases handled in this table are (visually):  R EN L</b>
<b class="nc"><i>2714</i>&nbsp;                                                            R L AN L</b>
<b class="nc"><i>2715</i>&nbsp;        */</b>
<i>2716</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<b class="nc"><i>2717</i>&nbsp;        /* 0 : init       */ {  0x13,     0,     1,     1,     0,     0,     0,  0 },</b>
<b class="nc"><i>2718</i>&nbsp;        /* 1 : R+EN/AN    */ {  0x23,     0,     1,     1,     2,  0x40,     0,  1 },</b>
<b class="nc"><i>2719</i>&nbsp;        /* 2 : R+EN/AN+ON */ {  0x23,     0,     1,     1,     2,  0x40,     0,  0 },</b>
<i>2720</i>&nbsp;        /* 3 : L          */ {     3,     0,     3,  0x36,  0x14,  0x40,     0,  1 },
<b class="nc"><i>2721</i>&nbsp;        /* 4 : L+ON       */ {  0x53,  0x40,     5,  0x36,     4,  0x40,  0x40,  0 },</b>
<b class="nc"><i>2722</i>&nbsp;        /* 5 : L+ON+EN    */ {  0x53,  0x40,     5,  0x36,     4,  0x40,  0x40,  1 },</b>
<i>2723</i>&nbsp;        /* 6 : L+AN       */ {  0x53,  0x40,     6,     6,     4,  0x40,  0x40,  3 }
<i>2724</i>&nbsp;    };
<b class="nc"><i>2725</i>&nbsp;    private static final short[] impAct2 = {0,1,2,5,6,7,8};</b>
<b class="nc"><i>2726</i>&nbsp;    private static final short[] impAct3 = {0,1,9,10,11,12};</b>
<b class="nc"><i>2727</i>&nbsp;    private static final ImpTabPair impTab_INVERSE_LIKE_DIRECT_WITH_MARKS =</b>
<i>2728</i>&nbsp;            new ImpTabPair(impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS,
<b class="nc"><i>2729</i>&nbsp;                           impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct2, impAct3);</b>
<b class="nc"><i>2730</i>&nbsp;</b>
<i>2731</i>&nbsp;    private static final ImpTabPair impTab_INVERSE_FOR_NUMBERS_SPECIAL = new ImpTabPair(
<b class="nc"><i>2732</i>&nbsp;            impTabL_NUMBERS_SPECIAL, impTabR_INVERSE_LIKE_DIRECT, impAct0, impAct1);</b>
<i>2733</i>&nbsp;
<i>2734</i>&nbsp;    private static final byte impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS[][] = {
<i>2735</i>&nbsp;        /*  The case handled in this table is (visually):  R EN L
<i>2736</i>&nbsp;        */
<i>2737</i>&nbsp;        /*                         L,     R,    EN,    AN,    ON,     S,     B, Res */
<i>2738</i>&nbsp;        /* 0 : init       */ {     0,  0x62,     1,     1,     0,     0,     0,  0 },
<i>2739</i>&nbsp;        /* 1 : L+EN/AN    */ {     0,  0x62,     1,     1,     0,  0x30,     0,  4 },
<i>2740</i>&nbsp;        /* 2 : R          */ {     0,  0x62,  0x54,  0x54,  0x13,  0x30,     0,  3 },
<i>2741</i>&nbsp;        /* 3 : R+ON       */ {  0x30,  0x42,  0x54,  0x54,     3,  0x30,  0x30,  3 },
<i>2742</i>&nbsp;        /* 4 : R+EN/AN    */ {  0x30,  0x42,     4,     4,  0x13,  0x30,  0x30,  4 }
<i>2743</i>&nbsp;    };
<i>2744</i>&nbsp;    private static final ImpTabPair impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS = new
<i>2745</i>&nbsp;            ImpTabPair(impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS,
<i>2746</i>&nbsp;                       impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct2, impAct3);
<i>2747</i>&nbsp;
<i>2748</i>&nbsp;    private static class LevState {
<i>2749</i>&nbsp;        byte[][] impTab;                /* level table pointer          */
<i>2750</i>&nbsp;        short[] impAct;                 /* action map array             */
<i>2751</i>&nbsp;        int startON;                    /* start of ON sequence         */
<i>2752</i>&nbsp;        int startL2EN;                  /* start of level 2 sequence    */
<i>2753</i>&nbsp;        int lastStrongRTL;              /* index of last found R or AL  */
<b class="nc"><i>2754</i>&nbsp;        int runStart;                   /* start position of the run    */</b>
<i>2755</i>&nbsp;        short state;                    /* current state                */
<i>2756</i>&nbsp;        byte runLevel;                  /* run level before implicit solving */
<i>2757</i>&nbsp;    }
<i>2758</i>&nbsp;
<i>2759</i>&nbsp;    /*------------------------------------------------------------------------*/
<i>2760</i>&nbsp;
<i>2761</i>&nbsp;    static final int FIRSTALLOC = 10;
<i>2762</i>&nbsp;    /*
<i>2763</i>&nbsp;     *  param pos:     position where to insert
<i>2764</i>&nbsp;     *  param flag:    one of LRM_BEFORE, LRM_AFTER, RLM_BEFORE, RLM_AFTER
<i>2765</i>&nbsp;     */
<i>2766</i>&nbsp;    private void addPoint(int pos, int flag)
<i>2767</i>&nbsp;    {
<i>2768</i>&nbsp;        Point point = new Point();
<i>2769</i>&nbsp;
<i>2770</i>&nbsp;        int len = insertPoints.points.length;
<i>2771</i>&nbsp;        if (len == 0) {
<i>2772</i>&nbsp;            insertPoints.points = new Point[FIRSTALLOC];
<i>2773</i>&nbsp;            len = FIRSTALLOC;
<i>2774</i>&nbsp;        }
<b class="nc"><i>2775</i>&nbsp;        if (insertPoints.size &gt;= len) { /* no room for new point */</b>
<b class="nc"><i>2776</i>&nbsp;            Point[] savePoints = insertPoints.points;</b>
<i>2777</i>&nbsp;            insertPoints.points = new Point[len * 2];
<i>2778</i>&nbsp;            System.arraycopy(savePoints, 0, insertPoints.points, 0, len);
<i>2779</i>&nbsp;        }
<i>2780</i>&nbsp;        point.pos = pos;
<i>2781</i>&nbsp;        point.flag = flag;
<i>2782</i>&nbsp;        insertPoints.points[insertPoints.size] = point;
<i>2783</i>&nbsp;        insertPoints.size++;
<i>2784</i>&nbsp;    }
<i>2785</i>&nbsp;
<i>2786</i>&nbsp;    private void setLevelsOutsideIsolates(int start, int limit, byte level)
<i>2787</i>&nbsp;    {
<i>2788</i>&nbsp;        byte dirProp;
<i>2789</i>&nbsp;        int  isolateCount = 0, k;
<i>2790</i>&nbsp;        for (k = start; k &lt; limit; k++) {
<b class="nc"><i>2791</i>&nbsp;            dirProp = dirProps[k];</b>
<b class="nc"><i>2792</i>&nbsp;            if (dirProp == PDI)</b>
<i>2793</i>&nbsp;                isolateCount--;
<i>2794</i>&nbsp;            if (isolateCount == 0) {
<i>2795</i>&nbsp;                levels[k] = level;
<i>2796</i>&nbsp;            }
<i>2797</i>&nbsp;            if (dirProp == LRI || dirProp == RLI)
<i>2798</i>&nbsp;                isolateCount++;
<i>2799</i>&nbsp;        }
<i>2800</i>&nbsp;    }
<i>2801</i>&nbsp;
<i>2802</i>&nbsp;    /* perform rules (Wn), (Nn), and (In) on a run of the text ------------------ */
<i>2803</i>&nbsp;
<i>2804</i>&nbsp;    /*
<i>2805</i>&nbsp;     * This implementation of the (Wn) rules applies all rules in one pass.
<i>2806</i>&nbsp;     * In order to do so, it needs a look-ahead of typically 1 character
<i>2807</i>&nbsp;     * (except for W5: sequences of ET) and keeps track of changes
<i>2808</i>&nbsp;     * in a rule Wp that affect a later Wq (p&lt;q).
<i>2809</i>&nbsp;     *
<i>2810</i>&nbsp;     * The (Nn) and (In) rules are also performed in that same single loop,
<i>2811</i>&nbsp;     * but effectively one iteration behind for white space.
<i>2812</i>&nbsp;     *
<i>2813</i>&nbsp;     * Since all implicit rules are performed in one step, it is not necessary
<i>2814</i>&nbsp;     * to actually store the intermediate directional properties in dirProps[].
<i>2815</i>&nbsp;     */
<b class="nc"><i>2816</i>&nbsp;</b>
<b class="nc"><i>2817</i>&nbsp;    private void processPropertySeq(LevState levState, short _prop,</b>
<i>2818</i>&nbsp;            int start, int limit) {
<i>2819</i>&nbsp;        byte cell;
<i>2820</i>&nbsp;        byte[][] impTab = levState.impTab;
<i>2821</i>&nbsp;        short[] impAct = levState.impAct;
<i>2822</i>&nbsp;        short oldStateSeq,actionSeq;
<i>2823</i>&nbsp;        byte level, addLevel;
<i>2824</i>&nbsp;        int start0, k;
<i>2825</i>&nbsp;
<i>2826</i>&nbsp;        start0 = start;                 /* save original start position */
<i>2827</i>&nbsp;        oldStateSeq = levState.state;
<i>2828</i>&nbsp;        cell = impTab[oldStateSeq][_prop];
<i>2829</i>&nbsp;        levState.state = GetState(cell);        /* isolate the new state */
<i>2830</i>&nbsp;        actionSeq = impAct[GetAction(cell)];    /* isolate the action */
<i>2831</i>&nbsp;        addLevel = impTab[levState.state][IMPTABLEVELS_RES];
<i>2832</i>&nbsp;
<i>2833</i>&nbsp;        if (actionSeq != 0) {
<i>2834</i>&nbsp;            switch (actionSeq) {
<i>2835</i>&nbsp;            case 1:                     /* init ON seq */
<i>2836</i>&nbsp;                levState.startON = start0;
<i>2837</i>&nbsp;                break;
<i>2838</i>&nbsp;
<b class="nc"><i>2839</i>&nbsp;            case 2:                     /* prepend ON seq to current seq */</b>
<b class="nc"><i>2840</i>&nbsp;                start = levState.startON;</b>
<b class="nc"><i>2841</i>&nbsp;                break;</b>
<i>2842</i>&nbsp;
<b class="nc"><i>2843</i>&nbsp;            case 3:                     /* EN/AN after R+ON */</b>
<i>2844</i>&nbsp;                level = (byte)(levState.runLevel + 1);
<b class="nc"><i>2845</i>&nbsp;                setLevelsOutsideIsolates(levState.startON, start0, level);</b>
<i>2846</i>&nbsp;                break;
<i>2847</i>&nbsp;
<i>2848</i>&nbsp;            case 4:                     /* EN/AN before R for NUMBERS_SPECIAL */
<i>2849</i>&nbsp;                level = (byte)(levState.runLevel + 2);
<i>2850</i>&nbsp;                setLevelsOutsideIsolates(levState.startON, start0, level);
<i>2851</i>&nbsp;                break;
<i>2852</i>&nbsp;
<i>2853</i>&nbsp;            case 5:                     /* L or S after possible relevant EN/AN */
<i>2854</i>&nbsp;                /* check if we had EN after R/AL */
<i>2855</i>&nbsp;                if (levState.startL2EN &gt;= 0) {
<i>2856</i>&nbsp;                    addPoint(levState.startL2EN, LRM_BEFORE);
<i>2857</i>&nbsp;                }
<i>2858</i>&nbsp;                levState.startL2EN = -1;  /* not within previous if since could also be -2 */
<i>2859</i>&nbsp;                /* check if we had any relevant EN/AN after R/AL */
<i>2860</i>&nbsp;                if ((insertPoints.points.length == 0) ||
<i>2861</i>&nbsp;                        (insertPoints.size &lt;= insertPoints.confirmed)) {
<i>2862</i>&nbsp;                    /* nothing, just clean up */
<i>2863</i>&nbsp;                    levState.lastStrongRTL = -1;
<i>2864</i>&nbsp;                    /* check if we have a pending conditional segment */
<i>2865</i>&nbsp;                    level = impTab[oldStateSeq][IMPTABLEVELS_RES];
<i>2866</i>&nbsp;                    if ((level &amp; 1) != 0 &amp;&amp; levState.startON &gt; 0) { /* after ON */
<i>2867</i>&nbsp;                        start = levState.startON;   /* reset to basic run level */
<i>2868</i>&nbsp;                    }
<i>2869</i>&nbsp;                    if (_prop == _S) {              /* add LRM before S */
<i>2870</i>&nbsp;                        addPoint(start0, LRM_BEFORE);
<i>2871</i>&nbsp;                        insertPoints.confirmed = insertPoints.size;
<i>2872</i>&nbsp;                    }
<i>2873</i>&nbsp;                    break;
<i>2874</i>&nbsp;                }
<i>2875</i>&nbsp;                /* reset previous RTL cont to level for LTR text */
<i>2876</i>&nbsp;                for (k = levState.lastStrongRTL + 1; k &lt; start0; k++) {
<i>2877</i>&nbsp;                    /* reset odd level, leave runLevel+2 as is */
<i>2878</i>&nbsp;                    levels[k] = (byte)((levels[k] - 2) &amp; ~1);
<i>2879</i>&nbsp;                }
<i>2880</i>&nbsp;                /* mark insert points as confirmed */
<i>2881</i>&nbsp;                insertPoints.confirmed = insertPoints.size;
<i>2882</i>&nbsp;                levState.lastStrongRTL = -1;
<i>2883</i>&nbsp;                if (_prop == _S) {           /* add LRM before S */
<i>2884</i>&nbsp;                    addPoint(start0, LRM_BEFORE);
<i>2885</i>&nbsp;                    insertPoints.confirmed = insertPoints.size;
<i>2886</i>&nbsp;                }
<i>2887</i>&nbsp;                break;
<i>2888</i>&nbsp;
<b class="nc"><i>2889</i>&nbsp;            case 6:                     /* R/AL after possible relevant EN/AN */</b>
<b class="nc"><i>2890</i>&nbsp;                /* just clean up */</b>
<b class="nc"><i>2891</i>&nbsp;                if (insertPoints.points.length &gt; 0)</b>
<i>2892</i>&nbsp;                    /* remove all non confirmed insert points */
<b class="nc"><i>2893</i>&nbsp;                    insertPoints.size = insertPoints.confirmed;</b>
<i>2894</i>&nbsp;                levState.startON = -1;
<i>2895</i>&nbsp;                levState.startL2EN = -1;
<i>2896</i>&nbsp;                levState.lastStrongRTL = limit - 1;
<i>2897</i>&nbsp;                break;
<i>2898</i>&nbsp;
<i>2899</i>&nbsp;            case 7:                     /* EN/AN after R/AL + possible cont */
<i>2900</i>&nbsp;                /* check for real AN */
<i>2901</i>&nbsp;
<i>2902</i>&nbsp;                if ((_prop == _AN) &amp;&amp; (dirProps[start0] == AN) &amp;&amp;
<i>2903</i>&nbsp;                (reorderingMode != REORDER_INVERSE_FOR_NUMBERS_SPECIAL))
<i>2904</i>&nbsp;                {
<i>2905</i>&nbsp;                    /* real AN */
<i>2906</i>&nbsp;                    if (levState.startL2EN == -1) { /* if no relevant EN already found */
<i>2907</i>&nbsp;                        /* just note the rightmost digit as a strong RTL */
<i>2908</i>&nbsp;                        levState.lastStrongRTL = limit - 1;
<i>2909</i>&nbsp;                        break;
<i>2910</i>&nbsp;                    }
<i>2911</i>&nbsp;                    if (levState.startL2EN &gt;= 0)  { /* after EN, no AN */
<i>2912</i>&nbsp;                        addPoint(levState.startL2EN, LRM_BEFORE);
<b class="nc"><i>2913</i>&nbsp;                        levState.startL2EN = -2;</b>
<b class="nc"><i>2914</i>&nbsp;                    }</b>
<i>2915</i>&nbsp;                    /* note AN */
<b class="nc"><i>2916</i>&nbsp;                    addPoint(start0, LRM_BEFORE);</b>
<b class="nc"><i>2917</i>&nbsp;                    break;</b>
<b class="nc"><i>2918</i>&nbsp;                }</b>
<i>2919</i>&nbsp;                /* if first EN/AN after R/AL */
<i>2920</i>&nbsp;                if (levState.startL2EN == -1) {
<i>2921</i>&nbsp;                    levState.startL2EN = start0;
<i>2922</i>&nbsp;                }
<i>2923</i>&nbsp;                break;
<i>2924</i>&nbsp;
<i>2925</i>&nbsp;            case 8:                     /* note location of latest R/AL */
<i>2926</i>&nbsp;                levState.lastStrongRTL = limit - 1;
<i>2927</i>&nbsp;                levState.startON = -1;
<i>2928</i>&nbsp;                break;
<i>2929</i>&nbsp;
<i>2930</i>&nbsp;            case 9:                     /* L after R+ON/EN/AN */
<i>2931</i>&nbsp;                /* include possible adjacent number on the left */
<i>2932</i>&nbsp;                for (k = start0-1; k &gt;= 0 &amp;&amp; ((levels[k] &amp; 1) == 0); k--) {
<i>2933</i>&nbsp;                }
<i>2934</i>&nbsp;                if (k &gt;= 0) {
<i>2935</i>&nbsp;                    addPoint(k, RLM_BEFORE);    /* add RLM before */
<b class="nc"><i>2936</i>&nbsp;                    insertPoints.confirmed = insertPoints.size; /* confirm it */</b>
<b class="nc"><i>2937</i>&nbsp;                }</b>
<b class="nc"><i>2938</i>&nbsp;                levState.startON = start0;</b>
<i>2939</i>&nbsp;                break;
<b class="nc"><i>2940</i>&nbsp;</b>
<i>2941</i>&nbsp;            case 10:                    /* AN after L */
<i>2942</i>&nbsp;                /* AN numbers between L text on both sides may be trouble. */
<i>2943</i>&nbsp;                /* tentatively bracket with LRMs; will be confirmed if followed by L */
<i>2944</i>&nbsp;                addPoint(start0, LRM_BEFORE);   /* add LRM before */
<i>2945</i>&nbsp;                addPoint(start0, LRM_AFTER);    /* add LRM after  */
<i>2946</i>&nbsp;                break;
<i>2947</i>&nbsp;
<i>2948</i>&nbsp;            case 11:                    /* R after L+ON/EN/AN */
<i>2949</i>&nbsp;                /* false alert, infirm LRMs around previous AN */
<i>2950</i>&nbsp;                insertPoints.size=insertPoints.confirmed;
<i>2951</i>&nbsp;                if (_prop == _S) {          /* add RLM before S */
<i>2952</i>&nbsp;                    addPoint(start0, RLM_BEFORE);
<i>2953</i>&nbsp;                    insertPoints.confirmed = insertPoints.size;
<i>2954</i>&nbsp;                }
<i>2955</i>&nbsp;                break;
<i>2956</i>&nbsp;
<i>2957</i>&nbsp;            case 12:                    /* L after L+ON/AN */
<i>2958</i>&nbsp;                level = (byte)(levState.runLevel + addLevel);
<b class="nc"><i>2959</i>&nbsp;                for (k=levState.startON; k &lt; start0; k++) {</b>
<b class="nc"><i>2960</i>&nbsp;                    if (levels[k] &lt; level) {</b>
<b class="nc"><i>2961</i>&nbsp;                        levels[k] = level;</b>
<i>2962</i>&nbsp;                    }
<i>2963</i>&nbsp;                }
<i>2964</i>&nbsp;                insertPoints.confirmed = insertPoints.size;   /* confirm inserts */
<i>2965</i>&nbsp;                levState.startON = start0;
<i>2966</i>&nbsp;                break;
<i>2967</i>&nbsp;
<i>2968</i>&nbsp;            case 13:                    /* L after L+ON+EN/AN/ON */
<i>2969</i>&nbsp;                level = levState.runLevel;
<i>2970</i>&nbsp;                for (k = start0-1; k &gt;= levState.startON; k--) {
<i>2971</i>&nbsp;                    if (levels[k] == level+3) {
<i>2972</i>&nbsp;                        while (levels[k] == level+3) {
<i>2973</i>&nbsp;                            levels[k--] -= 2;
<i>2974</i>&nbsp;                        }
<i>2975</i>&nbsp;                        while (levels[k] == level) {
<i>2976</i>&nbsp;                            k--;
<i>2977</i>&nbsp;                        }
<i>2978</i>&nbsp;                    }
<i>2979</i>&nbsp;                    if (levels[k] == level+2) {
<i>2980</i>&nbsp;                        levels[k] = level;
<i>2981</i>&nbsp;                        continue;
<i>2982</i>&nbsp;                    }
<i>2983</i>&nbsp;                    levels[k] = (byte)(level+1);
<i>2984</i>&nbsp;                }
<i>2985</i>&nbsp;                break;
<i>2986</i>&nbsp;
<i>2987</i>&nbsp;            case 14:                    /* R after L+ON+EN/AN/ON */
<i>2988</i>&nbsp;                level = (byte)(levState.runLevel+1);
<i>2989</i>&nbsp;                for (k = start0-1; k &gt;= levState.startON; k--) {
<i>2990</i>&nbsp;                    if (levels[k] &gt; level) {
<i>2991</i>&nbsp;                        levels[k] -= 2;
<i>2992</i>&nbsp;                    }
<i>2993</i>&nbsp;                }
<i>2994</i>&nbsp;                break;
<i>2995</i>&nbsp;
<i>2996</i>&nbsp;            default:                        /* we should never get here */
<i>2997</i>&nbsp;                throw new IllegalStateException(&quot;Internal ICU error in processPropertySeq&quot;);
<i>2998</i>&nbsp;            }
<b class="nc"><i>2999</i>&nbsp;        }</b>
<b class="nc"><i>3000</i>&nbsp;        if ((addLevel) != 0 || (start &lt; start0)) {</b>
<b class="nc"><i>3001</i>&nbsp;            level = (byte)(levState.runLevel + addLevel);</b>
<i>3002</i>&nbsp;            if (start &gt;= levState.runStart) {
<b class="nc"><i>3003</i>&nbsp;                for (k = start; k &lt; limit; k++) {</b>
<i>3004</i>&nbsp;                    levels[k] = level;
<i>3005</i>&nbsp;                }
<i>3006</i>&nbsp;            } else {
<i>3007</i>&nbsp;                setLevelsOutsideIsolates(start, limit, level);
<i>3008</i>&nbsp;            }
<i>3009</i>&nbsp;        }
<i>3010</i>&nbsp;    }
<i>3011</i>&nbsp;
<i>3012</i>&nbsp;    private void resolveImplicitLevels(int start, int limit, short sor, short eor)
<i>3013</i>&nbsp;    {
<i>3014</i>&nbsp;        byte dirProp;
<i>3015</i>&nbsp;        LevState levState = new LevState();
<i>3016</i>&nbsp;        int i, start1, start2;
<i>3017</i>&nbsp;        short oldStateImp, stateImp, actionImp;
<i>3018</i>&nbsp;        short gprop, resProp, cell;
<i>3019</i>&nbsp;        boolean inverseRTL;
<i>3020</i>&nbsp;        short nextStrongProp = R;
<i>3021</i>&nbsp;        int nextStrongPos = -1;
<i>3022</i>&nbsp;
<i>3023</i>&nbsp;        /* check for RTL inverse Bidi mode */
<i>3024</i>&nbsp;        /* FOOD FOR THOUGHT: in case of RTL inverse Bidi, it would make sense to
<i>3025</i>&nbsp;         * loop on the text characters from end to start.
<b class="nc"><i>3026</i>&nbsp;         * This would need a different properties state table (at least different</b>
<i>3027</i>&nbsp;         * actions) and different levels state tables (maybe very similar to the
<i>3028</i>&nbsp;         * LTR corresponding ones.
<i>3029</i>&nbsp;         */
<i>3030</i>&nbsp;        inverseRTL=((start&lt;lastArabicPos) &amp;&amp; ((GetParaLevelAt(start) &amp; 1)&gt;0) &amp;&amp;
<i>3031</i>&nbsp;                    (reorderingMode == REORDER_INVERSE_LIKE_DIRECT  ||
<i>3032</i>&nbsp;                     reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL));
<i>3033</i>&nbsp;        /* initialize for property and levels state table */
<i>3034</i>&nbsp;        levState.startL2EN = -1;        /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */
<i>3035</i>&nbsp;        levState.lastStrongRTL = -1;    /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */
<i>3036</i>&nbsp;        levState.runStart = start;
<i>3037</i>&nbsp;        levState.runLevel = levels[start];
<i>3038</i>&nbsp;        levState.impTab = impTabPair.imptab[levState.runLevel &amp; 1];
<i>3039</i>&nbsp;        levState.impAct = impTabPair.impact[levState.runLevel &amp; 1];
<i>3040</i>&nbsp;
<i>3041</i>&nbsp;        /* The isolates[] entries contain enough information to
<i>3042</i>&nbsp;           resume the bidi algorithm in the same state as it was
<i>3043</i>&nbsp;           when it was interrupted by an isolate sequence. */
<i>3044</i>&nbsp;        if (dirProps[start] == PDI) {
<i>3045</i>&nbsp;            levState.startON = isolates[isolateCount].startON;
<i>3046</i>&nbsp;            start1 = isolates[isolateCount].start1;
<i>3047</i>&nbsp;            stateImp = isolates[isolateCount].stateImp;
<i>3048</i>&nbsp;            levState.state = isolates[isolateCount].state;
<i>3049</i>&nbsp;            isolateCount--;
<i>3050</i>&nbsp;        } else {
<i>3051</i>&nbsp;            levState.startON = -1;
<i>3052</i>&nbsp;            start1 = start;
<i>3053</i>&nbsp;            if (dirProps[start] == NSM)
<i>3054</i>&nbsp;              stateImp = (short)(1 + sor);
<i>3055</i>&nbsp;            else
<i>3056</i>&nbsp;                stateImp = 0;
<i>3057</i>&nbsp;            levState.state = 0;
<i>3058</i>&nbsp;            processPropertySeq(levState, sor, start, start);
<i>3059</i>&nbsp;        }
<i>3060</i>&nbsp;        start2 = start;                 /* to make the Java compiler happy */
<i>3061</i>&nbsp;
<i>3062</i>&nbsp;        for (i = start; i &lt;= limit; i++) {
<i>3063</i>&nbsp;            if (i &gt;= limit) {
<i>3064</i>&nbsp;                int k;
<i>3065</i>&nbsp;                for (k = limit - 1;
<i>3066</i>&nbsp;                     k &gt; start &amp;&amp;
<i>3067</i>&nbsp;                         (DirPropFlag(dirProps[k]) &amp; MASK_BN_EXPLICIT) != 0;
<i>3068</i>&nbsp;                     k--);
<i>3069</i>&nbsp;                dirProp = dirProps[k];
<i>3070</i>&nbsp;                if (dirProp == LRI || dirProp == RLI)
<i>3071</i>&nbsp;                    break;  /* no forced closing for sequence ending with LRI/RLI */
<i>3072</i>&nbsp;                gprop = eor;
<i>3073</i>&nbsp;            } else {
<i>3074</i>&nbsp;                byte prop, prop1;
<i>3075</i>&nbsp;                prop = dirProps[i];
<i>3076</i>&nbsp;                if (prop == B)
<i>3077</i>&nbsp;                    isolateCount = -1;  /* current isolates stack entry == none */
<i>3078</i>&nbsp;                if (inverseRTL) {
<i>3079</i>&nbsp;                    if (prop == AL) {
<i>3080</i>&nbsp;                        /* AL before EN does not make it AN */
<i>3081</i>&nbsp;                        prop = R;
<i>3082</i>&nbsp;                    } else if (prop == EN) {
<i>3083</i>&nbsp;                        if (nextStrongPos &lt;= i) {
<i>3084</i>&nbsp;                            /* look for next strong char (L/R/AL) */
<i>3085</i>&nbsp;                            int j;
<i>3086</i>&nbsp;                            nextStrongProp = R;     /* set default */
<i>3087</i>&nbsp;                            nextStrongPos = limit;
<b class="nc"><i>3088</i>&nbsp;                            for (j = i+1; j &lt; limit; j++) {</b>
<i>3089</i>&nbsp;                                prop1 = dirProps[j];
<b class="nc"><i>3090</i>&nbsp;                                if (prop1 == L || prop1 == R || prop1 == AL) {</b>
<i>3091</i>&nbsp;                                    nextStrongProp = prop1;
<i>3092</i>&nbsp;                                    nextStrongPos = j;
<b class="nc"><i>3093</i>&nbsp;                                    break;</b>
<b class="nc"><i>3094</i>&nbsp;                                }</b>
<i>3095</i>&nbsp;                            }
<b class="nc"><i>3096</i>&nbsp;                        }</b>
<b class="nc"><i>3097</i>&nbsp;                        if (nextStrongProp == AL) {</b>
<i>3098</i>&nbsp;                            prop = AN;
<b class="nc"><i>3099</i>&nbsp;                        }</b>
<b class="nc"><i>3100</i>&nbsp;                    }</b>
<i>3101</i>&nbsp;                }
<b class="nc"><i>3102</i>&nbsp;                gprop = groupProp[prop];</b>
<i>3103</i>&nbsp;            }
<i>3104</i>&nbsp;            oldStateImp = stateImp;
<i>3105</i>&nbsp;            cell = impTabProps[oldStateImp][gprop];
<b class="nc"><i>3106</i>&nbsp;            stateImp = GetStateProps(cell);     /* isolate the new state */</b>
<b class="nc"><i>3107</i>&nbsp;            actionImp = GetActionProps(cell);   /* isolate the action */</b>
<i>3108</i>&nbsp;            if ((i == limit) &amp;&amp; (actionImp == 0)) {
<b class="nc"><i>3109</i>&nbsp;                /* there is an unprocessed sequence if its property == eor   */</b>
<i>3110</i>&nbsp;                actionImp = 1;                  /* process the last sequence */
<b class="nc"><i>3111</i>&nbsp;            }</b>
<b class="nc"><i>3112</i>&nbsp;            if (actionImp != 0) {</b>
<b class="nc"><i>3113</i>&nbsp;                resProp = impTabProps[oldStateImp][IMPTABPROPS_RES];</b>
<b class="nc"><i>3114</i>&nbsp;                switch (actionImp) {</b>
<b class="nc"><i>3115</i>&nbsp;                case 1:             /* process current seq1, init new seq1 */</b>
<b class="nc"><i>3116</i>&nbsp;                    processPropertySeq(levState, resProp, start1, i);</b>
<b class="nc"><i>3117</i>&nbsp;                    start1 = i;</b>
<b class="nc"><i>3118</i>&nbsp;                    break;</b>
<i>3119</i>&nbsp;                case 2:             /* init new seq2 */
<i>3120</i>&nbsp;                    start2 = i;
<b class="nc"><i>3121</i>&nbsp;                    break;</b>
<i>3122</i>&nbsp;                case 3:             /* process seq1, process seq2, init new seq1 */
<i>3123</i>&nbsp;                    processPropertySeq(levState, resProp, start1, start2);
<b class="nc"><i>3124</i>&nbsp;                    processPropertySeq(levState, _ON, start2, i);</b>
<b class="nc"><i>3125</i>&nbsp;                    start1 = i;</b>
<i>3126</i>&nbsp;                    break;
<b class="nc"><i>3127</i>&nbsp;                case 4:             /* process seq1, set seq1=seq2, init new seq2 */</b>
<b class="nc"><i>3128</i>&nbsp;                    processPropertySeq(levState, resProp, start1, start2);</b>
<b class="nc"><i>3129</i>&nbsp;                    start1 = start2;</b>
<i>3130</i>&nbsp;                    start2 = i;
<i>3131</i>&nbsp;                    break;
<i>3132</i>&nbsp;                default:            /* we should never get here */
<i>3133</i>&nbsp;                    throw new IllegalStateException(&quot;Internal ICU error in resolveImplicitLevels&quot;);
<i>3134</i>&nbsp;                }
<i>3135</i>&nbsp;            }
<i>3136</i>&nbsp;        }
<i>3137</i>&nbsp;
<i>3138</i>&nbsp;        /* look for the last char not a BN or LRE/RLE/LRO/RLO/PDF */
<i>3139</i>&nbsp;        for (i = limit - 1;
<i>3140</i>&nbsp;             i &gt; start &amp;&amp;
<i>3141</i>&nbsp;                 (DirPropFlag(dirProps[i]) &amp; MASK_BN_EXPLICIT) != 0;
<i>3142</i>&nbsp;             i--);
<i>3143</i>&nbsp;        dirProp = dirProps[i];
<i>3144</i>&nbsp;        if ((dirProp == LRI || dirProp == RLI) &amp;&amp; limit &lt; length) {
<i>3145</i>&nbsp;            isolateCount++;
<b class="nc"><i>3146</i>&nbsp;            if (isolates[isolateCount] == null)</b>
<i>3147</i>&nbsp;                isolates[isolateCount] = new Isolate();
<i>3148</i>&nbsp;            isolates[isolateCount].stateImp = stateImp;
<i>3149</i>&nbsp;            isolates[isolateCount].state = levState.state;
<i>3150</i>&nbsp;            isolates[isolateCount].start1 = start1;
<i>3151</i>&nbsp;            isolates[isolateCount].startON = levState.startON;
<i>3152</i>&nbsp;        }
<i>3153</i>&nbsp;        else
<i>3154</i>&nbsp;            processPropertySeq(levState, eor, limit, limit);
<i>3155</i>&nbsp;    }
<i>3156</i>&nbsp;
<i>3157</i>&nbsp;    /* perform (L1) and (X9) ---------------------------------------------------- */
<i>3158</i>&nbsp;
<i>3159</i>&nbsp;    /*
<i>3160</i>&nbsp;     * Reset the embedding levels for some non-graphic characters (L1).
<i>3161</i>&nbsp;     * This method also sets appropriate levels for BN, and
<b class="nc"><i>3162</i>&nbsp;     * explicit embedding types that are supposed to have been removed</b>
<i>3163</i>&nbsp;     * from the paragraph in (X9).
<i>3164</i>&nbsp;     */
<i>3165</i>&nbsp;    private void adjustWSLevels() {
<i>3166</i>&nbsp;        int i;
<i>3167</i>&nbsp;
<i>3168</i>&nbsp;        if ((flags &amp; MASK_WS) != 0) {
<i>3169</i>&nbsp;            int flag;
<i>3170</i>&nbsp;            i = trailingWSStart;
<i>3171</i>&nbsp;            while (i &gt; 0) {
<i>3172</i>&nbsp;                /* reset a sequence of WS/BN before eop and B/S to the paragraph paraLevel */
<i>3173</i>&nbsp;                while (i &gt; 0 &amp;&amp; ((flag = DirPropFlag(dirProps[--i])) &amp; MASK_WS) != 0) {
<i>3174</i>&nbsp;                    if (orderParagraphsLTR &amp;&amp; (flag &amp; DirPropFlag(B)) != 0) {
<i>3175</i>&nbsp;                        levels[i] = 0;
<i>3176</i>&nbsp;                    } else {
<i>3177</i>&nbsp;                        levels[i] = GetParaLevelAt(i);
<b class="nc"><i>3178</i>&nbsp;                    }</b>
<i>3179</i>&nbsp;                }
<i>3180</i>&nbsp;
<i>3181</i>&nbsp;                /* reset BN to the next character&#39;s paraLevel until B/S, which restarts above loop */
<i>3182</i>&nbsp;                /* here, i+1 is guaranteed to be &lt;length */
<i>3183</i>&nbsp;                while (i &gt; 0) {
<i>3184</i>&nbsp;                    flag = DirPropFlag(dirProps[--i]);
<i>3185</i>&nbsp;                    if ((flag &amp; MASK_BN_EXPLICIT) != 0) {
<i>3186</i>&nbsp;                        levels[i] = levels[i + 1];
<i>3187</i>&nbsp;                    } else if (orderParagraphsLTR &amp;&amp; (flag &amp; DirPropFlag(B)) != 0) {
<i>3188</i>&nbsp;                        levels[i] = 0;
<i>3189</i>&nbsp;                        break;
<i>3190</i>&nbsp;                    } else if ((flag &amp; MASK_B_S) != 0){
<i>3191</i>&nbsp;                        levels[i] = GetParaLevelAt(i);
<i>3192</i>&nbsp;                        break;
<b class="nc"><i>3193</i>&nbsp;                    }</b>
<i>3194</i>&nbsp;                }
<i>3195</i>&nbsp;            }
<i>3196</i>&nbsp;        }
<i>3197</i>&nbsp;    }
<i>3198</i>&nbsp;
<i>3199</i>&nbsp;    private void setParaSuccess() {
<i>3200</i>&nbsp;        paraBidi = this;                /* mark successful setPara */
<i>3201</i>&nbsp;    }
<i>3202</i>&nbsp;
<i>3203</i>&nbsp;    private int Bidi_Min(int x, int y) {
<i>3204</i>&nbsp;        return x &lt; y ? x : y;
<i>3205</i>&nbsp;    }
<i>3206</i>&nbsp;
<i>3207</i>&nbsp;    private int Bidi_Abs(int x) {
<b class="nc"><i>3208</i>&nbsp;        return x &gt;= 0 ? x : -x;</b>
<i>3209</i>&nbsp;    }
<i>3210</i>&nbsp;
<i>3211</i>&nbsp;    void setParaRunsOnly(char[] parmText, byte parmParaLevel) {
<i>3212</i>&nbsp;        int[] visualMap;
<i>3213</i>&nbsp;        String visualText;
<i>3214</i>&nbsp;        int saveLength, saveTrailingWSStart;
<i>3215</i>&nbsp;        byte[] saveLevels;
<b class="nc"><i>3216</i>&nbsp;        byte saveDirection;</b>
<i>3217</i>&nbsp;        int i, j, visualStart, logicalStart,
<i>3218</i>&nbsp;            oldRunCount, runLength, addedRuns, insertRemove,
<b class="nc"><i>3219</i>&nbsp;            start, limit, step, indexOddBit, logicalPos,</b>
<b class="nc"><i>3220</i>&nbsp;            index, index1;</b>
<i>3221</i>&nbsp;        int saveOptions;
<b class="nc"><i>3222</i>&nbsp;</b>
<i>3223</i>&nbsp;        reorderingMode = REORDER_DEFAULT;
<i>3224</i>&nbsp;        int parmLength = parmText.length;
<b class="nc"><i>3225</i>&nbsp;        if (parmLength == 0) {</b>
<b class="nc"><i>3226</i>&nbsp;            setPara(parmText, parmParaLevel, null);</b>
<b class="nc"><i>3227</i>&nbsp;            reorderingMode = REORDER_RUNS_ONLY;</b>
<i>3228</i>&nbsp;            return;
<b class="nc"><i>3229</i>&nbsp;        }</b>
<b class="nc"><i>3230</i>&nbsp;        /* obtain memory for mapping table and visual text */</b>
<b class="nc"><i>3231</i>&nbsp;        saveOptions = reorderingOptions;</b>
<i>3232</i>&nbsp;        if ((saveOptions &amp; OPTION_INSERT_MARKS) &gt; 0) {
<b class="nc"><i>3233</i>&nbsp;            reorderingOptions &amp;= ~OPTION_INSERT_MARKS;</b>
<b class="nc"><i>3234</i>&nbsp;            reorderingOptions |= OPTION_REMOVE_CONTROLS;</b>
<i>3235</i>&nbsp;        }
<i>3236</i>&nbsp;        parmParaLevel &amp;= 1;             /* accept only 0 or 1 */
<i>3237</i>&nbsp;        setPara(parmText, parmParaLevel, null);
<i>3238</i>&nbsp;        /* we cannot access directly levels since it is not yet set if
<i>3239</i>&nbsp;         * direction is not MIXED
<i>3240</i>&nbsp;         */
<i>3241</i>&nbsp;        saveLevels = new byte[this.length];
<i>3242</i>&nbsp;        System.arraycopy(getLevels(), 0, saveLevels, 0, this.length);
<i>3243</i>&nbsp;        saveTrailingWSStart = trailingWSStart;
<i>3244</i>&nbsp;
<i>3245</i>&nbsp;        /* FOOD FOR THOUGHT: instead of writing the visual text, we could use
<i>3246</i>&nbsp;         * the visual map and the dirProps array to drive the second call
<i>3247</i>&nbsp;         * to setPara (but must make provision for possible removal of
<i>3248</i>&nbsp;         * Bidi controls.  Alternatively, only use the dirProps array via
<i>3249</i>&nbsp;         * customized classifier callback.
<i>3250</i>&nbsp;         */
<i>3251</i>&nbsp;        visualText = writeReordered(DO_MIRRORING);
<b class="nc"><i>3252</i>&nbsp;        visualMap = getVisualMap();</b>
<b class="nc"><i>3253</i>&nbsp;        this.reorderingOptions = saveOptions;</b>
<b class="nc"><i>3254</i>&nbsp;        saveLength = this.length;</b>
<b class="nc"><i>3255</i>&nbsp;        saveDirection=this.direction;</b>
<i>3256</i>&nbsp;
<b class="nc"><i>3257</i>&nbsp;        this.reorderingMode = REORDER_INVERSE_LIKE_DIRECT;</b>
<b class="nc"><i>3258</i>&nbsp;        parmParaLevel ^= 1;</b>
<i>3259</i>&nbsp;        setPara(visualText, parmParaLevel, null);
<i>3260</i>&nbsp;        BidiLine.getRuns(this);
<i>3261</i>&nbsp;        /* check if some runs must be split, count how many splits */
<i>3262</i>&nbsp;        addedRuns = 0;
<i>3263</i>&nbsp;        oldRunCount = this.runCount;
<i>3264</i>&nbsp;        visualStart = 0;
<i>3265</i>&nbsp;        for (i = 0; i &lt; oldRunCount; i++, visualStart += runLength) {
<i>3266</i>&nbsp;            runLength = runs[i].limit - visualStart;
<i>3267</i>&nbsp;            if (runLength &lt; 2) {
<i>3268</i>&nbsp;                continue;
<i>3269</i>&nbsp;            }
<i>3270</i>&nbsp;            logicalStart = runs[i].start;
<i>3271</i>&nbsp;            for (j = logicalStart+1; j &lt; logicalStart+runLength; j++) {
<i>3272</i>&nbsp;                index = visualMap[j];
<i>3273</i>&nbsp;                index1 = visualMap[j-1];
<i>3274</i>&nbsp;                if ((Bidi_Abs(index-index1)!=1) || (saveLevels[index]!=saveLevels[index1])) {
<i>3275</i>&nbsp;                    addedRuns++;
<i>3276</i>&nbsp;                }
<b class="nc"><i>3277</i>&nbsp;            }</b>
<b class="nc"><i>3278</i>&nbsp;        }</b>
<b class="nc"><i>3279</i>&nbsp;        if (addedRuns &gt; 0) {</b>
<b class="nc"><i>3280</i>&nbsp;            getRunsMemory(oldRunCount + addedRuns);</b>
<b class="nc"><i>3281</i>&nbsp;            if (runCount == 1) {</b>
<b class="nc"><i>3282</i>&nbsp;                /* because we switch from UBiDi.simpleRuns to UBiDi.runs */</b>
<i>3283</i>&nbsp;                runsMemory[0] = runs[0];
<b class="nc"><i>3284</i>&nbsp;            } else {</b>
<b class="nc"><i>3285</i>&nbsp;                System.arraycopy(runs, 0, runsMemory, 0, runCount);</b>
<b class="nc"><i>3286</i>&nbsp;            }</b>
<i>3287</i>&nbsp;            runs = runsMemory;
<i>3288</i>&nbsp;            runCount += addedRuns;
<i>3289</i>&nbsp;            for (i = oldRunCount; i &lt; runCount; i++) {
<i>3290</i>&nbsp;                if (runs[i] == null) {
<i>3291</i>&nbsp;                    runs[i] = new BidiRun(0, 0, (byte)0);
<i>3292</i>&nbsp;                }
<i>3293</i>&nbsp;            }
<i>3294</i>&nbsp;        }
<i>3295</i>&nbsp;        /* split runs which are not consecutive in source text */
<i>3296</i>&nbsp;        int newI;
<i>3297</i>&nbsp;        for (i = oldRunCount-1; i &gt;= 0; i--) {
<i>3298</i>&nbsp;            newI = i + addedRuns;
<i>3299</i>&nbsp;            runLength = i==0 ? runs[0].limit :
<i>3300</i>&nbsp;                               runs[i].limit - runs[i-1].limit;
<i>3301</i>&nbsp;            logicalStart = runs[i].start;
<i>3302</i>&nbsp;            indexOddBit = runs[i].level &amp; 1;
<i>3303</i>&nbsp;            if (runLength &lt; 2) {
<i>3304</i>&nbsp;                if (addedRuns &gt; 0) {
<i>3305</i>&nbsp;                    runs[newI].copyFrom(runs[i]);
<b class="nc"><i>3306</i>&nbsp;                }</b>
<b class="nc"><i>3307</i>&nbsp;                logicalPos = visualMap[logicalStart];</b>
<b class="nc"><i>3308</i>&nbsp;                runs[newI].start = logicalPos;</b>
<b class="nc"><i>3309</i>&nbsp;                runs[newI].level = (byte)(saveLevels[logicalPos] ^ indexOddBit);</b>
<i>3310</i>&nbsp;                continue;
<b class="nc"><i>3311</i>&nbsp;            }</b>
<b class="nc"><i>3312</i>&nbsp;            if (indexOddBit &gt; 0) {</b>
<b class="nc"><i>3313</i>&nbsp;                start = logicalStart;</b>
<b class="nc"><i>3314</i>&nbsp;                limit = logicalStart + runLength - 1;</b>
<i>3315</i>&nbsp;                step = 1;
<b class="nc"><i>3316</i>&nbsp;            } else {</b>
<i>3317</i>&nbsp;                start = logicalStart + runLength - 1;
<i>3318</i>&nbsp;                limit = logicalStart;
<i>3319</i>&nbsp;                step = -1;
<i>3320</i>&nbsp;            }
<i>3321</i>&nbsp;            for (j = start; j != limit; j += step) {
<i>3322</i>&nbsp;                index = visualMap[j];
<i>3323</i>&nbsp;                index1 = visualMap[j+step];
<i>3324</i>&nbsp;                if ((Bidi_Abs(index-index1)!=1) || (saveLevels[index]!=saveLevels[index1])) {
<i>3325</i>&nbsp;                    logicalPos = Bidi_Min(visualMap[start], index);
<i>3326</i>&nbsp;                    runs[newI].start = logicalPos;
<i>3327</i>&nbsp;                    runs[newI].level = (byte)(saveLevels[logicalPos] ^ indexOddBit);
<i>3328</i>&nbsp;                    runs[newI].limit = runs[i].limit;
<i>3329</i>&nbsp;                    runs[i].limit -= Bidi_Abs(j - start) + 1;
<i>3330</i>&nbsp;                    insertRemove = runs[i].insertRemove &amp; (LRM_AFTER|RLM_AFTER);
<i>3331</i>&nbsp;                    runs[newI].insertRemove = insertRemove;
<i>3332</i>&nbsp;                    runs[i].insertRemove &amp;= ~insertRemove;
<i>3333</i>&nbsp;                    start = j + step;
<i>3334</i>&nbsp;                    addedRuns--;
<i>3335</i>&nbsp;                    newI--;
<i>3336</i>&nbsp;                }
<i>3337</i>&nbsp;            }
<i>3338</i>&nbsp;            if (addedRuns &gt; 0) {
<i>3339</i>&nbsp;                runs[newI].copyFrom(runs[i]);
<i>3340</i>&nbsp;            }
<i>3341</i>&nbsp;            logicalPos = Bidi_Min(visualMap[start], visualMap[limit]);
<i>3342</i>&nbsp;            runs[newI].start = logicalPos;
<i>3343</i>&nbsp;            runs[newI].level = (byte)(saveLevels[logicalPos] ^ indexOddBit);
<b class="nc"><i>3344</i>&nbsp;        }</b>
<b class="nc"><i>3345</i>&nbsp;</b>
<i>3346</i>&nbsp;    cleanup1:
<i>3347</i>&nbsp;        /* restore initial paraLevel */
<b class="nc"><i>3348</i>&nbsp;        this.paraLevel ^= 1;</b>
<b class="nc"><i>3349</i>&nbsp;    cleanup2:</b>
<b class="nc"><i>3350</i>&nbsp;        /* restore real text */</b>
<b class="nc"><i>3351</i>&nbsp;        this.text = parmText;</b>
<b class="nc"><i>3352</i>&nbsp;        this.length = saveLength;</b>
<i>3353</i>&nbsp;        this.originalLength = parmLength;
<b class="nc"><i>3354</i>&nbsp;        this.direction=saveDirection;</b>
<b class="nc"><i>3355</i>&nbsp;        this.levels = saveLevels;</b>
<i>3356</i>&nbsp;        this.trailingWSStart = saveTrailingWSStart;
<i>3357</i>&nbsp;        if (runCount &gt; 1) {
<b class="nc"><i>3358</i>&nbsp;            this.direction = MIXED;</b>
<i>3359</i>&nbsp;        }
<i>3360</i>&nbsp;    cleanup3:
<i>3361</i>&nbsp;        this.reorderingMode = REORDER_RUNS_ONLY;
<i>3362</i>&nbsp;    }
<i>3363</i>&nbsp;
<i>3364</i>&nbsp;    /**
<i>3365</i>&nbsp;     * Perform the Unicode Bidi algorithm. It is defined in the
<i>3366</i>&nbsp;     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
<i>3367</i>&nbsp;     * version 13,
<i>3368</i>&nbsp;     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
<i>3369</i>&nbsp;     *
<i>3370</i>&nbsp;     * This method takes a piece of plain text containing one or more paragraphs,
<i>3371</i>&nbsp;     * with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;
<i>3372</i>&nbsp;     * text and computes the left-right-directionality of each character.&lt;p&gt;
<i>3373</i>&nbsp;     *
<i>3374</i>&nbsp;     * If the entire text is all of the same directionality, then
<i>3375</i>&nbsp;     * the method may not perform all the steps described by the algorithm,
<i>3376</i>&nbsp;     * i.e., some levels may not be the same as if all steps were performed.
<i>3377</i>&nbsp;     * This is not relevant for unidirectional text.&lt;br&gt;
<i>3378</i>&nbsp;     * For example, in pure LTR text with numbers the numbers would get
<i>3379</i>&nbsp;     * a resolved level of 2 higher than the surrounding text according to
<i>3380</i>&nbsp;     * the algorithm. This implementation may set all resolved levels to
<i>3381</i>&nbsp;     * the same value in such a case.&lt;p&gt;
<i>3382</i>&nbsp;     *
<i>3383</i>&nbsp;     * The text can be composed of multiple paragraphs. Occurrence of a block
<b class="nc"><i>3384</i>&nbsp;     * separator in the text terminates a paragraph, and whatever comes next starts</b>
<b class="nc"><i>3385</i>&nbsp;     * a new paragraph. The exception to this rule is when a Carriage Return (CR)</b>
<i>3386</i>&nbsp;     * is followed by a Line Feed (LF). Both CR and LF are block separators, but
<i>3387</i>&nbsp;     * in that case, the pair of characters is considered as terminating the
<i>3388</i>&nbsp;     * preceding paragraph, and a new paragraph will be started by a character
<b class="nc"><i>3389</i>&nbsp;     * coming after the LF.</b>
<b class="nc"><i>3390</i>&nbsp;     *</b>
<i>3391</i>&nbsp;     * Although the text is passed here as a &lt;code&gt;String&lt;/code&gt;, it is
<i>3392</i>&nbsp;     * stored internally as an array of characters. Therefore the
<i>3393</i>&nbsp;     * documentation will refer to indexes of the characters in the text.
<b class="nc"><i>3394</i>&nbsp;     *</b>
<b class="nc"><i>3395</i>&nbsp;     * @param text contains the text that the Bidi algorithm will be performed</b>
<i>3396</i>&nbsp;     *        on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or
<i>3397</i>&nbsp;     *        &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;
<i>3398</i>&nbsp;     *
<b class="nc"><i>3399</i>&nbsp;     * @param paraLevel specifies the default level for the text;</b>
<b class="nc"><i>3400</i>&nbsp;     *        it is typically 0 (LTR) or 1 (RTL).</b>
<b class="nc"><i>3401</i>&nbsp;     *        If the method shall determine the paragraph level from the text,</b>
<b class="nc"><i>3402</i>&nbsp;     *        then &lt;code&gt;paraLevel&lt;/code&gt; can be set to</b>
<b class="nc"><i>3403</i>&nbsp;     *        either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;</b>
<b class="nc"><i>3404</i>&nbsp;     *        or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple</b>
<b class="nc"><i>3405</i>&nbsp;     *        paragraphs, the paragraph level shall be determined separately for</b>
<i>3406</i>&nbsp;     *        each paragraph; if a paragraph does not include any strongly typed
<i>3407</i>&nbsp;     *        character, then the desired default is used (0 for LTR or 1 for RTL).
<i>3408</i>&nbsp;     *        Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;
<i>3409</i>&nbsp;     *        is also valid, with odd levels indicating RTL.
<i>3410</i>&nbsp;     *
<i>3411</i>&nbsp;     * @param embeddingLevels (in) may be used to preset the embedding and override levels,
<i>3412</i>&nbsp;     *        ignoring characters like LRE and PDF in the text.
<b class="nc"><i>3413</i>&nbsp;     *        A level overrides the directional property of its corresponding</b>
<i>3414</i>&nbsp;     *        (same index) character if the level has the
<b class="nc"><i>3415</i>&nbsp;     *        &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;</b>
<b class="nc"><i>3416</i>&nbsp;     *        Except for that bit, it must be</b>
<b class="nc"><i>3417</i>&nbsp;     *        &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,</b>
<b class="nc"><i>3418</i>&nbsp;     *        with one exception: a level of zero may be specified for a</b>
<b class="nc"><i>3419</i>&nbsp;     *        paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple</b>
<b class="nc"><i>3420</i>&nbsp;     *        paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;</b>
<b class="nc"><i>3421</i>&nbsp;     *        &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy</b>
<b class="nc"><i>3422</i>&nbsp;     *        of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;</b>
<b class="nc"><i>3423</i>&nbsp;     *        the &lt;code&gt;embeddingLevels&lt;/code&gt;</b>
<i>3424</i>&nbsp;     *        should not be modified to avoid unexpected results on subsequent
<b class="nc"><i>3425</i>&nbsp;     *        Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and</b>
<b class="nc"><i>3426</i>&nbsp;     *        &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the</b>
<b class="nc"><i>3427</i>&nbsp;     *        levels.&lt;br&gt;&lt;br&gt;</b>
<b class="nc"><i>3428</i>&nbsp;     *        &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must</b>
<b class="nc"><i>3429</i>&nbsp;     *        have one entry for each character in &lt;code&gt;text&lt;/code&gt;.</b>
<i>3430</i>&nbsp;     *
<b class="nc"><i>3431</i>&nbsp;     * @throws IllegalArgumentException if the values in embeddingLevels are</b>
<i>3432</i>&nbsp;     *         not within the allowed range
<b class="nc"><i>3433</i>&nbsp;     *</b>
<b class="nc"><i>3434</i>&nbsp;     * @see #LEVEL_DEFAULT_LTR</b>
<b class="nc"><i>3435</i>&nbsp;     * @see #LEVEL_DEFAULT_RTL</b>
<b class="nc"><i>3436</i>&nbsp;     * @see #LEVEL_OVERRIDE</b>
<b class="nc"><i>3437</i>&nbsp;     * @see #MAX_EXPLICIT_LEVEL</b>
<i>3438</i>&nbsp;     * @stable ICU 3.8
<b class="nc"><i>3439</i>&nbsp;     */</b>
<i>3440</i>&nbsp;    void setPara(String text, byte paraLevel, byte[] embeddingLevels)
<b class="nc"><i>3441</i>&nbsp;    {</b>
<i>3442</i>&nbsp;        if (text == null) {
<i>3443</i>&nbsp;            setPara(new char[0], paraLevel, embeddingLevels);
<i>3444</i>&nbsp;        } else {
<i>3445</i>&nbsp;            setPara(text.toCharArray(), paraLevel, embeddingLevels);
<i>3446</i>&nbsp;        }
<i>3447</i>&nbsp;    }
<b class="nc"><i>3448</i>&nbsp;</b>
<b class="nc"><i>3449</i>&nbsp;    /**</b>
<i>3450</i>&nbsp;     * Perform the Unicode Bidi algorithm. It is defined in the
<i>3451</i>&nbsp;     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
<i>3452</i>&nbsp;     * version 13,
<i>3453</i>&nbsp;     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
<i>3454</i>&nbsp;     *
<b class="nc"><i>3455</i>&nbsp;     * This method takes a piece of plain text containing one or more paragraphs,</b>
<b class="nc"><i>3456</i>&nbsp;     * with or without externally specified embedding levels from &lt;i&gt;styled&lt;/i&gt;</b>
<b class="nc"><i>3457</i>&nbsp;     * text and computes the left-right-directionality of each character.&lt;p&gt;</b>
<b class="nc"><i>3458</i>&nbsp;     *</b>
<b class="nc"><i>3459</i>&nbsp;     * If the entire text is all of the same directionality, then</b>
<b class="nc"><i>3460</i>&nbsp;     * the method may not perform all the steps described by the algorithm,</b>
<i>3461</i>&nbsp;     * i.e., some levels may not be the same as if all steps were performed.
<i>3462</i>&nbsp;     * This is not relevant for unidirectional text.&lt;br&gt;
<i>3463</i>&nbsp;     * For example, in pure LTR text with numbers the numbers would get
<i>3464</i>&nbsp;     * a resolved level of 2 higher than the surrounding text according to
<i>3465</i>&nbsp;     * the algorithm. This implementation may set all resolved levels to
<b class="nc"><i>3466</i>&nbsp;     * the same value in such a case.</b>
<i>3467</i>&nbsp;     *
<i>3468</i>&nbsp;     * The text can be composed of multiple paragraphs. Occurrence of a block
<i>3469</i>&nbsp;     * separator in the text terminates a paragraph, and whatever comes next starts
<i>3470</i>&nbsp;     * a new paragraph. The exception to this rule is when a Carriage Return (CR)
<b class="nc"><i>3471</i>&nbsp;     * is followed by a Line Feed (LF). Both CR and LF are block separators, but</b>
<b class="nc"><i>3472</i>&nbsp;     * in that case, the pair of characters is considered as terminating the</b>
<b class="nc"><i>3473</i>&nbsp;     * preceding paragraph, and a new paragraph will be started by a character</b>
<i>3474</i>&nbsp;     * coming after the LF.
<i>3475</i>&nbsp;     *
<i>3476</i>&nbsp;     * The text is stored internally as an array of characters. Therefore the
<i>3477</i>&nbsp;     * documentation will refer to indexes of the characters in the text.
<i>3478</i>&nbsp;     *
<b class="nc"><i>3479</i>&nbsp;     * @param chars contains the text that the Bidi algorithm will be performed</b>
<b class="nc"><i>3480</i>&nbsp;     *        on. This text can be retrieved with &lt;code&gt;getText()&lt;/code&gt; or</b>
<b class="nc"><i>3481</i>&nbsp;     *        &lt;code&gt;getTextAsString&lt;/code&gt;.&lt;br&gt;</b>
<b class="nc"><i>3482</i>&nbsp;     *</b>
<i>3483</i>&nbsp;     * @param paraLevel specifies the default level for the text;
<i>3484</i>&nbsp;     *        it is typically 0 (LTR) or 1 (RTL).
<i>3485</i>&nbsp;     *        If the method shall determine the paragraph level from the text,
<i>3486</i>&nbsp;     *        then &lt;code&gt;paraLevel&lt;/code&gt; can be set to
<i>3487</i>&nbsp;     *        either &lt;code&gt;LEVEL_DEFAULT_LTR&lt;/code&gt;
<i>3488</i>&nbsp;     *        or &lt;code&gt;LEVEL_DEFAULT_RTL&lt;/code&gt;; if the text contains multiple
<i>3489</i>&nbsp;     *        paragraphs, the paragraph level shall be determined separately for
<b class="nc"><i>3490</i>&nbsp;     *        each paragraph; if a paragraph does not include any strongly typed</b>
<i>3491</i>&nbsp;     *        character, then the desired default is used (0 for LTR or 1 for RTL).
<b class="nc"><i>3492</i>&nbsp;     *        Any other value between 0 and &lt;code&gt;MAX_EXPLICIT_LEVEL&lt;/code&gt;</b>
<i>3493</i>&nbsp;     *        is also valid, with odd levels indicating RTL.
<b class="nc"><i>3494</i>&nbsp;     *</b>
<i>3495</i>&nbsp;     * @param embeddingLevels (in) may be used to preset the embedding and
<i>3496</i>&nbsp;     *        override levels, ignoring characters like LRE and PDF in the text.
<i>3497</i>&nbsp;     *        A level overrides the directional property of its corresponding
<i>3498</i>&nbsp;     *        (same index) character if the level has the
<i>3499</i>&nbsp;     *        &lt;code&gt;LEVEL_OVERRIDE&lt;/code&gt; bit set.&lt;br&gt;&lt;br&gt;
<i>3500</i>&nbsp;     *        Except for that bit, it must be
<i>3501</i>&nbsp;     *        &lt;code&gt;paraLevel&lt;=embeddingLevels[]&lt;=MAX_EXPLICIT_LEVEL&lt;/code&gt;,
<i>3502</i>&nbsp;     *        with one exception: a level of zero may be specified for a
<b class="nc"><i>3503</i>&nbsp;     *        paragraph separator even if &lt;code&gt;paraLevel&amp;gt;0&lt;/code&gt; when multiple</b>
<b class="nc"><i>3504</i>&nbsp;     *        paragraphs are submitted in the same call to &lt;code&gt;setPara()&lt;/code&gt;.&lt;br&gt;&lt;br&gt;</b>
<b class="nc"><i>3505</i>&nbsp;     *        &lt;strong&gt;Caution: &lt;/strong&gt;A reference to this array, not a copy</b>
<i>3506</i>&nbsp;     *        of the levels, will be stored in the &lt;code&gt;Bidi&lt;/code&gt; object;
<b class="nc"><i>3507</i>&nbsp;     *        the &lt;code&gt;embeddingLevels&lt;/code&gt;</b>
<i>3508</i>&nbsp;     *        should not be modified to avoid unexpected results on subsequent
<i>3509</i>&nbsp;     *        Bidi operations. However, the &lt;code&gt;setPara()&lt;/code&gt; and
<i>3510</i>&nbsp;     *        &lt;code&gt;setLine()&lt;/code&gt; methods may modify some or all of the
<b class="nc"><i>3511</i>&nbsp;     *        levels.&lt;br&gt;&lt;br&gt;</b>
<b class="nc"><i>3512</i>&nbsp;     *        &lt;strong&gt;Note:&lt;/strong&gt; the &lt;code&gt;embeddingLevels&lt;/code&gt; array must</b>
<b class="nc"><i>3513</i>&nbsp;     *        have one entry for each character in &lt;code&gt;text&lt;/code&gt;.</b>
<i>3514</i>&nbsp;     *
<i>3515</i>&nbsp;     * @throws IllegalArgumentException if the values in embeddingLevels are
<i>3516</i>&nbsp;     *         not within the allowed range
<i>3517</i>&nbsp;     *
<i>3518</i>&nbsp;     * @see #LEVEL_DEFAULT_LTR
<i>3519</i>&nbsp;     * @see #LEVEL_DEFAULT_RTL
<i>3520</i>&nbsp;     * @see #LEVEL_OVERRIDE
<b class="nc"><i>3521</i>&nbsp;     * @see #MAX_EXPLICIT_LEVEL</b>
<i>3522</i>&nbsp;     * @stable ICU 3.8
<b class="nc"><i>3523</i>&nbsp;     */</b>
<b class="nc"><i>3524</i>&nbsp;    void setPara(char[] chars, byte paraLevel, byte[] embeddingLevels)</b>
<b class="nc"><i>3525</i>&nbsp;    {</b>
<i>3526</i>&nbsp;        /* check the argument values */
<i>3527</i>&nbsp;        if (paraLevel &lt; LEVEL_DEFAULT_LTR) {
<b class="nc"><i>3528</i>&nbsp;            verifyRange(paraLevel, 0, MAX_EXPLICIT_LEVEL + 1);</b>
<i>3529</i>&nbsp;        }
<i>3530</i>&nbsp;        if (chars == null) {
<i>3531</i>&nbsp;            chars = new char[0];
<i>3532</i>&nbsp;        }
<i>3533</i>&nbsp;
<i>3534</i>&nbsp;        /* special treatment for RUNS_ONLY mode */
<i>3535</i>&nbsp;        if (reorderingMode == REORDER_RUNS_ONLY) {
<b class="nc"><i>3536</i>&nbsp;            setParaRunsOnly(chars, paraLevel);</b>
<b class="nc"><i>3537</i>&nbsp;            return;</b>
<i>3538</i>&nbsp;        }
<b class="nc"><i>3539</i>&nbsp;</b>
<b class="nc"><i>3540</i>&nbsp;        /* initialize the Bidi object */</b>
<b class="nc"><i>3541</i>&nbsp;        this.paraBidi = null;          /* mark unfinished setPara */</b>
<b class="nc"><i>3542</i>&nbsp;        this.text = chars;</b>
<b class="nc"><i>3543</i>&nbsp;        this.length = this.originalLength = this.resultLength = text.length;</b>
<b class="nc"><i>3544</i>&nbsp;        this.paraLevel = paraLevel;</b>
<b class="nc"><i>3545</i>&nbsp;        this.direction = (byte)(paraLevel &amp; 1);</b>
<b class="nc"><i>3546</i>&nbsp;        this.paraCount = 1;</b>
<b class="nc"><i>3547</i>&nbsp;</b>
<i>3548</i>&nbsp;        /* Allocate zero-length arrays instead of setting to null here; then
<i>3549</i>&nbsp;         * checks for null in various places can be eliminated.
<i>3550</i>&nbsp;         */
<i>3551</i>&nbsp;        dirProps = new byte[0];
<i>3552</i>&nbsp;        levels = new byte[0];
<i>3553</i>&nbsp;        runs = new BidiRun[0];
<i>3554</i>&nbsp;        isGoodLogicalToVisualRunsMap = false;
<i>3555</i>&nbsp;        insertPoints.size = 0;          /* clean up from last call */
<i>3556</i>&nbsp;        insertPoints.confirmed = 0;     /* clean up from last call */
<i>3557</i>&nbsp;
<i>3558</i>&nbsp;        /*
<i>3559</i>&nbsp;         * Save the original paraLevel if contextual; otherwise, set to 0.
<i>3560</i>&nbsp;         */
<i>3561</i>&nbsp;        defaultParaLevel = IsDefaultLevel(paraLevel) ? paraLevel : 0;
<i>3562</i>&nbsp;
<i>3563</i>&nbsp;        if (length == 0) {
<i>3564</i>&nbsp;            /*
<i>3565</i>&nbsp;             * For an empty paragraph, create a Bidi object with the paraLevel and
<i>3566</i>&nbsp;             * the flags and the direction set but without allocating zero-length arrays.
<i>3567</i>&nbsp;             * There is nothing more to do.
<i>3568</i>&nbsp;             */
<i>3569</i>&nbsp;            if (IsDefaultLevel(paraLevel)) {
<i>3570</i>&nbsp;                this.paraLevel &amp;= 1;
<i>3571</i>&nbsp;                defaultParaLevel = 0;
<i>3572</i>&nbsp;            }
<i>3573</i>&nbsp;            flags = DirPropFlagLR(paraLevel);
<i>3574</i>&nbsp;            runCount = 0;
<i>3575</i>&nbsp;            paraCount = 0;
<i>3576</i>&nbsp;            setParaSuccess();
<i>3577</i>&nbsp;            return;
<i>3578</i>&nbsp;        }
<i>3579</i>&nbsp;
<i>3580</i>&nbsp;        runCount = -1;
<i>3581</i>&nbsp;
<i>3582</i>&nbsp;        /*
<i>3583</i>&nbsp;         * Get the directional properties,
<i>3584</i>&nbsp;         * the flags bit-set, and
<i>3585</i>&nbsp;         * determine the paragraph level if necessary.
<i>3586</i>&nbsp;         */
<i>3587</i>&nbsp;        getDirPropsMemory(length);
<i>3588</i>&nbsp;        dirProps = dirPropsMemory;
<i>3589</i>&nbsp;        getDirProps();
<i>3590</i>&nbsp;        /* the processed length may have changed if OPTION_STREAMING is set */
<i>3591</i>&nbsp;        trailingWSStart = length;  /* the levels[] will reflect the WS run */
<i>3592</i>&nbsp;
<i>3593</i>&nbsp;        /* are explicit levels specified? */
<i>3594</i>&nbsp;        if (embeddingLevels == null) {
<i>3595</i>&nbsp;            /* no: determine explicit levels according to the (Xn) rules */
<i>3596</i>&nbsp;            getLevelsMemory(length);
<i>3597</i>&nbsp;            levels = levelsMemory;
<i>3598</i>&nbsp;            direction = resolveExplicitLevels();
<i>3599</i>&nbsp;        } else {
<i>3600</i>&nbsp;            /* set BN for all explicit codes, check that all levels are 0 or paraLevel..MAX_EXPLICIT_LEVEL */
<i>3601</i>&nbsp;            levels = embeddingLevels;
<i>3602</i>&nbsp;            direction = checkExplicitLevels();
<i>3603</i>&nbsp;        }
<i>3604</i>&nbsp;
<i>3605</i>&nbsp;        /* allocate isolate memory */
<i>3606</i>&nbsp;        if (isolateCount &gt; 0) {
<i>3607</i>&nbsp;            if (isolates == null || isolates.length &lt; isolateCount)
<i>3608</i>&nbsp;                isolates = new Isolate[isolateCount + 3];   /* keep some reserve */
<i>3609</i>&nbsp;        }
<i>3610</i>&nbsp;        isolateCount = -1;              /* current isolates stack entry == none */
<i>3611</i>&nbsp;
<i>3612</i>&nbsp;        /*
<i>3613</i>&nbsp;         * The steps after (X9) in the Bidi algorithm are performed only if
<i>3614</i>&nbsp;         * the paragraph text has mixed directionality!
<i>3615</i>&nbsp;         */
<i>3616</i>&nbsp;        switch (direction) {
<i>3617</i>&nbsp;        case LTR:
<i>3618</i>&nbsp;            /* all levels are implicitly at paraLevel (important for getLevels()) */
<i>3619</i>&nbsp;            trailingWSStart = 0;
<i>3620</i>&nbsp;            break;
<i>3621</i>&nbsp;        case RTL:
<i>3622</i>&nbsp;            /* all levels are implicitly at paraLevel (important for getLevels()) */
<i>3623</i>&nbsp;            trailingWSStart = 0;
<i>3624</i>&nbsp;            break;
<i>3625</i>&nbsp;        default:
<i>3626</i>&nbsp;            /*
<i>3627</i>&nbsp;             *  Choose the right implicit state table
<i>3628</i>&nbsp;             */
<i>3629</i>&nbsp;            switch(reorderingMode) {
<i>3630</i>&nbsp;            case REORDER_DEFAULT:
<i>3631</i>&nbsp;                this.impTabPair = impTab_DEFAULT;
<i>3632</i>&nbsp;                break;
<i>3633</i>&nbsp;            case REORDER_NUMBERS_SPECIAL:
<i>3634</i>&nbsp;                this.impTabPair = impTab_NUMBERS_SPECIAL;
<i>3635</i>&nbsp;                break;
<i>3636</i>&nbsp;            case REORDER_GROUP_NUMBERS_WITH_R:
<i>3637</i>&nbsp;                this.impTabPair = impTab_GROUP_NUMBERS_WITH_R;
<i>3638</i>&nbsp;                break;
<i>3639</i>&nbsp;            case REORDER_RUNS_ONLY:
<i>3640</i>&nbsp;                /* we should never get here */
<i>3641</i>&nbsp;                throw new InternalError(&quot;Internal ICU error in setPara&quot;);
<i>3642</i>&nbsp;                /* break; */
<i>3643</i>&nbsp;            case REORDER_INVERSE_NUMBERS_AS_L:
<i>3644</i>&nbsp;                this.impTabPair = impTab_INVERSE_NUMBERS_AS_L;
<i>3645</i>&nbsp;                break;
<i>3646</i>&nbsp;            case REORDER_INVERSE_LIKE_DIRECT:
<i>3647</i>&nbsp;                if ((reorderingOptions &amp; OPTION_INSERT_MARKS) != 0) {
<i>3648</i>&nbsp;                    this.impTabPair = impTab_INVERSE_LIKE_DIRECT_WITH_MARKS;
<i>3649</i>&nbsp;                } else {
<i>3650</i>&nbsp;                    this.impTabPair = impTab_INVERSE_LIKE_DIRECT;
<i>3651</i>&nbsp;                }
<i>3652</i>&nbsp;                break;
<i>3653</i>&nbsp;            case REORDER_INVERSE_FOR_NUMBERS_SPECIAL:
<i>3654</i>&nbsp;                if ((reorderingOptions &amp; OPTION_INSERT_MARKS) != 0) {
<i>3655</i>&nbsp;                    this.impTabPair = impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS;
<i>3656</i>&nbsp;                } else {
<i>3657</i>&nbsp;                    this.impTabPair = impTab_INVERSE_FOR_NUMBERS_SPECIAL;
<i>3658</i>&nbsp;                }
<i>3659</i>&nbsp;                break;
<i>3660</i>&nbsp;            }
<i>3661</i>&nbsp;            /*
<i>3662</i>&nbsp;             * If there are no external levels specified and there
<i>3663</i>&nbsp;             * are no significant explicit level codes in the text,
<i>3664</i>&nbsp;             * then we can treat the entire paragraph as one run.
<i>3665</i>&nbsp;             * Otherwise, we need to perform the following rules on runs of
<i>3666</i>&nbsp;             * the text with the same embedding levels. (X10)
<i>3667</i>&nbsp;             * &quot;Significant&quot; explicit level codes are ones that actually
<i>3668</i>&nbsp;             * affect non-BN characters.
<i>3669</i>&nbsp;             * Examples for &quot;insignificant&quot; ones are empty embeddings
<i>3670</i>&nbsp;             * LRE-PDF, LRE-RLE-PDF-PDF, etc.
<i>3671</i>&nbsp;             */
<i>3672</i>&nbsp;            if (embeddingLevels == null &amp;&amp; paraCount &lt;= 1 &amp;&amp;
<i>3673</i>&nbsp;                (flags &amp; DirPropFlagMultiRuns) == 0) {
<i>3674</i>&nbsp;                resolveImplicitLevels(0, length,
<i>3675</i>&nbsp;                        GetLRFromLevel(GetParaLevelAt(0)),
<i>3676</i>&nbsp;                        GetLRFromLevel(GetParaLevelAt(length - 1)));
<i>3677</i>&nbsp;            } else {
<i>3678</i>&nbsp;                /* sor, eor: start and end types of same-level-run */
<i>3679</i>&nbsp;                int start, limit = 0;
<i>3680</i>&nbsp;                byte level, nextLevel;
<i>3681</i>&nbsp;                short sor, eor;
<i>3682</i>&nbsp;
<i>3683</i>&nbsp;                /* determine the first sor and set eor to it because of the loop body (sor=eor there) */
<i>3684</i>&nbsp;                level = GetParaLevelAt(0);
<i>3685</i>&nbsp;                nextLevel = levels[0];
<i>3686</i>&nbsp;                if (level &lt; nextLevel) {
<i>3687</i>&nbsp;                    eor = GetLRFromLevel(nextLevel);
<i>3688</i>&nbsp;                } else {
<i>3689</i>&nbsp;                    eor = GetLRFromLevel(level);
<i>3690</i>&nbsp;                }
<i>3691</i>&nbsp;
<i>3692</i>&nbsp;                do {
<i>3693</i>&nbsp;                    /* determine start and limit of the run (end points just behind the run) */
<i>3694</i>&nbsp;
<i>3695</i>&nbsp;                    /* the values for this run&#39;s start are the same as for the previous run&#39;s end */
<i>3696</i>&nbsp;                    start = limit;
<i>3697</i>&nbsp;                    level = nextLevel;
<i>3698</i>&nbsp;                    if ((start &gt; 0) &amp;&amp; (dirProps[start - 1] == B)) {
<i>3699</i>&nbsp;                        /* except if this is a new paragraph, then set sor = para level */
<i>3700</i>&nbsp;                        sor = GetLRFromLevel(GetParaLevelAt(start));
<i>3701</i>&nbsp;                    } else {
<i>3702</i>&nbsp;                        sor = eor;
<i>3703</i>&nbsp;                    }
<i>3704</i>&nbsp;
<i>3705</i>&nbsp;                    /* search for the limit of this run */
<i>3706</i>&nbsp;                    while ((++limit &lt; length) &amp;&amp;
<i>3707</i>&nbsp;                           ((levels[limit] == level) ||
<i>3708</i>&nbsp;                            ((DirPropFlag(dirProps[limit]) &amp; MASK_BN_EXPLICIT) != 0))) {}
<i>3709</i>&nbsp;
<i>3710</i>&nbsp;                    /* get the correct level of the next run */
<i>3711</i>&nbsp;                    if (limit &lt; length) {
<i>3712</i>&nbsp;                        nextLevel = levels[limit];
<i>3713</i>&nbsp;                    } else {
<i>3714</i>&nbsp;                        nextLevel = GetParaLevelAt(length - 1);
<i>3715</i>&nbsp;                    }
<i>3716</i>&nbsp;
<i>3717</i>&nbsp;                    /* determine eor from max(level, nextLevel); sor is last run&#39;s eor */
<i>3718</i>&nbsp;                    if (NoOverride(level) &lt; NoOverride(nextLevel)) {
<i>3719</i>&nbsp;                        eor = GetLRFromLevel(nextLevel);
<i>3720</i>&nbsp;                    } else {
<i>3721</i>&nbsp;                        eor = GetLRFromLevel(level);
<i>3722</i>&nbsp;                    }
<i>3723</i>&nbsp;
<i>3724</i>&nbsp;                    /* if the run consists of overridden directional types, then there
<i>3725</i>&nbsp;                       are no implicit types to be resolved */
<i>3726</i>&nbsp;                    if ((level &amp; LEVEL_OVERRIDE) == 0) {
<i>3727</i>&nbsp;                        resolveImplicitLevels(start, limit, sor, eor);
<i>3728</i>&nbsp;                    } else {
<i>3729</i>&nbsp;                        /* remove the LEVEL_OVERRIDE flags */
<i>3730</i>&nbsp;                        do {
<i>3731</i>&nbsp;                            levels[start++] &amp;= ~LEVEL_OVERRIDE;
<i>3732</i>&nbsp;                        } while (start &lt; limit);
<i>3733</i>&nbsp;                    }
<i>3734</i>&nbsp;                } while (limit  &lt; length);
<i>3735</i>&nbsp;            }
<i>3736</i>&nbsp;
<i>3737</i>&nbsp;            /* reset the embedding levels for some non-graphic characters (L1), (X9) */
<i>3738</i>&nbsp;            adjustWSLevels();
<i>3739</i>&nbsp;
<i>3740</i>&nbsp;            break;
<i>3741</i>&nbsp;        }
<i>3742</i>&nbsp;
<i>3743</i>&nbsp;        /* add RLM for inverse Bidi with contextual orientation resolving
<i>3744</i>&nbsp;         * to RTL which would not round-trip otherwise
<i>3745</i>&nbsp;         */
<i>3746</i>&nbsp;        if ((defaultParaLevel &gt; 0) &amp;&amp;
<i>3747</i>&nbsp;            ((reorderingOptions &amp; OPTION_INSERT_MARKS) != 0) &amp;&amp;
<i>3748</i>&nbsp;            ((reorderingMode == REORDER_INVERSE_LIKE_DIRECT) ||
<i>3749</i>&nbsp;             (reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL))) {
<i>3750</i>&nbsp;            int start, last;
<i>3751</i>&nbsp;            byte level;
<i>3752</i>&nbsp;            byte dirProp;
<i>3753</i>&nbsp;            for (int i = 0; i &lt; paraCount; i++) {
<i>3754</i>&nbsp;                last = paras_limit[i] - 1;
<i>3755</i>&nbsp;                level = paras_level[i];
<i>3756</i>&nbsp;                if (level == 0)
<i>3757</i>&nbsp;                    continue;           /* LTR paragraph */
<i>3758</i>&nbsp;                start = i == 0 ? 0 : paras_limit[i - 1];
<i>3759</i>&nbsp;                for (int j = last; j &gt;= start; j--) {
<i>3760</i>&nbsp;                    dirProp = dirProps[j];
<i>3761</i>&nbsp;                    if (dirProp == L) {
<i>3762</i>&nbsp;                        if (j &lt; last) {
<i>3763</i>&nbsp;                            while (dirProps[last] == B) {
<i>3764</i>&nbsp;                                last--;
<i>3765</i>&nbsp;                            }
<i>3766</i>&nbsp;                        }
<i>3767</i>&nbsp;                        addPoint(last, RLM_BEFORE);
<i>3768</i>&nbsp;                        break;
<i>3769</i>&nbsp;                    }
<i>3770</i>&nbsp;                    if ((DirPropFlag(dirProp) &amp; MASK_R_AL) != 0) {
<i>3771</i>&nbsp;                        break;
<i>3772</i>&nbsp;                    }
<i>3773</i>&nbsp;                }
<i>3774</i>&nbsp;            }
<i>3775</i>&nbsp;        }
<i>3776</i>&nbsp;
<i>3777</i>&nbsp;        if ((reorderingOptions &amp; OPTION_REMOVE_CONTROLS) != 0) {
<i>3778</i>&nbsp;            resultLength -= controlCount;
<i>3779</i>&nbsp;        } else {
<i>3780</i>&nbsp;            resultLength += insertPoints.size;
<i>3781</i>&nbsp;        }
<i>3782</i>&nbsp;        setParaSuccess();
<i>3783</i>&nbsp;    }
<i>3784</i>&nbsp;
<i>3785</i>&nbsp;    /**
<i>3786</i>&nbsp;     * Perform the Unicode Bidi algorithm on a given paragraph, as defined in the
<i>3787</i>&nbsp;     * &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr9/&quot;&gt;Unicode Standard Annex #9&lt;/a&gt;,
<i>3788</i>&nbsp;     * version 13,
<i>3789</i>&nbsp;     * also described in The Unicode Standard, Version 4.0 .&lt;p&gt;
<i>3790</i>&nbsp;     *
<i>3791</i>&nbsp;     * This method takes a paragraph of text and computes the
<i>3792</i>&nbsp;     * left-right-directionality of each character. The text should not
<i>3793</i>&nbsp;     * contain any Unicode block separators.&lt;p&gt;
<i>3794</i>&nbsp;     *
<i>3795</i>&nbsp;     * The RUN_DIRECTION attribute in the text, if present, determines the base
<i>3796</i>&nbsp;     * direction (left-to-right or right-to-left). If not present, the base
<i>3797</i>&nbsp;     * direction is computed using the Unicode Bidirectional Algorithm,
<i>3798</i>&nbsp;     * defaulting to left-to-right if there are no strong directional characters
<i>3799</i>&nbsp;     * in the text. This attribute, if present, must be applied to all the text
<i>3800</i>&nbsp;     * in the paragraph.&lt;p&gt;
<i>3801</i>&nbsp;     *
<i>3802</i>&nbsp;     * The BIDI_EMBEDDING attribute in the text, if present, represents
<i>3803</i>&nbsp;     * embedding level information. Negative values from -1 to -62 indicate
<i>3804</i>&nbsp;     * overrides at the absolute value of the level. Positive values from 1 to
<i>3805</i>&nbsp;     * 62 indicate embeddings. Where values are zero or not defined, the base
<i>3806</i>&nbsp;     * embedding level as determined by the base direction is assumed.&lt;p&gt;
<i>3807</i>&nbsp;     *
<i>3808</i>&nbsp;     * The NUMERIC_SHAPING attribute in the text, if present, converts European
<i>3809</i>&nbsp;     * digits to other decimal digits before running the bidi algorithm. This
<i>3810</i>&nbsp;     * attribute, if present, must be applied to all the text in the paragraph.
<i>3811</i>&nbsp;     *
<i>3812</i>&nbsp;     * If the entire text is all of the same directionality, then
<i>3813</i>&nbsp;     * the method may not perform all the steps described by the algorithm,
<i>3814</i>&nbsp;     * i.e., some levels may not be the same as if all steps were performed.
<i>3815</i>&nbsp;     * This is not relevant for unidirectional text.&lt;br&gt;
<i>3816</i>&nbsp;     * For example, in pure LTR text with numbers the numbers would get
<i>3817</i>&nbsp;     * a resolved level of 2 higher than the surrounding text according to
<i>3818</i>&nbsp;     * the algorithm. This implementation may set all resolved levels to
<i>3819</i>&nbsp;     * the same value in such a case.&lt;p&gt;
<i>3820</i>&nbsp;     *
<i>3821</i>&nbsp;     * @param paragraph a paragraph of text with optional character and
<i>3822</i>&nbsp;     *        paragraph attribute information
<i>3823</i>&nbsp;     * @stable ICU 3.8
<i>3824</i>&nbsp;     */
<i>3825</i>&nbsp;    public void setPara(AttributedCharacterIterator paragraph)
<i>3826</i>&nbsp;    {
<i>3827</i>&nbsp;        byte paraLvl;
<i>3828</i>&nbsp;        char ch = paragraph.first();
<i>3829</i>&nbsp;        Boolean runDirection =
<i>3830</i>&nbsp;          (Boolean) paragraph.getAttribute(TextAttributeConstants.RUN_DIRECTION);
<i>3831</i>&nbsp;        Object shaper = paragraph.getAttribute(TextAttributeConstants.NUMERIC_SHAPING);
<i>3832</i>&nbsp;
<i>3833</i>&nbsp;        if (runDirection == null) {
<i>3834</i>&nbsp;            paraLvl = LEVEL_DEFAULT_LTR;
<i>3835</i>&nbsp;        } else {
<i>3836</i>&nbsp;            paraLvl = (runDirection.equals(TextAttributeConstants.RUN_DIRECTION_LTR)) ?
<i>3837</i>&nbsp;                        LTR : RTL;
<i>3838</i>&nbsp;        }
<i>3839</i>&nbsp;
<i>3840</i>&nbsp;        byte[] lvls = null;
<i>3841</i>&nbsp;        int len = paragraph.getEndIndex() - paragraph.getBeginIndex();
<i>3842</i>&nbsp;        byte[] embeddingLevels = new byte[len];
<i>3843</i>&nbsp;        char[] txt = new char[len];
<i>3844</i>&nbsp;        int i = 0;
<i>3845</i>&nbsp;        while (ch != AttributedCharacterIterator.DONE) {
<i>3846</i>&nbsp;            txt[i] = ch;
<i>3847</i>&nbsp;            Integer embedding =
<i>3848</i>&nbsp;                (Integer) paragraph.getAttribute(TextAttributeConstants.BIDI_EMBEDDING);
<i>3849</i>&nbsp;            if (embedding != null) {
<i>3850</i>&nbsp;                byte level = embedding.byteValue();
<i>3851</i>&nbsp;                if (level == 0) {
<i>3852</i>&nbsp;                    /* no-op */
<i>3853</i>&nbsp;                } else if (level &lt; 0) {
<i>3854</i>&nbsp;                    lvls = embeddingLevels;
<i>3855</i>&nbsp;                    embeddingLevels[i] = (byte)((0 - level) | LEVEL_OVERRIDE);
<i>3856</i>&nbsp;                } else {
<i>3857</i>&nbsp;                    lvls = embeddingLevels;
<i>3858</i>&nbsp;                    embeddingLevels[i] = level;
<i>3859</i>&nbsp;                }
<i>3860</i>&nbsp;            }
<i>3861</i>&nbsp;            ch = paragraph.next();
<i>3862</i>&nbsp;            ++i;
<i>3863</i>&nbsp;        }
<i>3864</i>&nbsp;
<i>3865</i>&nbsp;        if (shaper != null) {
<i>3866</i>&nbsp;            NumericShapings.shape(shaper, txt, 0, len);
<i>3867</i>&nbsp;        }
<i>3868</i>&nbsp;        setPara(txt, paraLvl, lvls);
<i>3869</i>&nbsp;    }
<i>3870</i>&nbsp;
<i>3871</i>&nbsp;    /**
<i>3872</i>&nbsp;     * Specify whether block separators must be allocated level zero,
<i>3873</i>&nbsp;     * so that successive paragraphs will progress from left to right.
<i>3874</i>&nbsp;     * This method must be called before &lt;code&gt;setPara()&lt;/code&gt;.
<i>3875</i>&nbsp;     * Paragraph separators (B) may appear in the text.  Setting them to level zero
<i>3876</i>&nbsp;     * means that all paragraph separators (including one possibly appearing
<i>3877</i>&nbsp;     * in the last text position) are kept in the reordered text after the text
<i>3878</i>&nbsp;     * that they follow in the source text.
<i>3879</i>&nbsp;     * When this feature is not enabled, a paragraph separator at the last
<i>3880</i>&nbsp;     * position of the text before reordering will go to the first position
<i>3881</i>&nbsp;     * of the reordered text when the paragraph level is odd.
<i>3882</i>&nbsp;     *
<i>3883</i>&nbsp;     * @param ordarParaLTR specifies whether paragraph separators (B) must
<i>3884</i>&nbsp;     * receive level 0, so that successive paragraphs progress from left to right.
<i>3885</i>&nbsp;     *
<i>3886</i>&nbsp;     * @see #setPara
<i>3887</i>&nbsp;     * @stable ICU 3.8
<i>3888</i>&nbsp;     */
<i>3889</i>&nbsp;    public void orderParagraphsLTR(boolean ordarParaLTR) {
<i>3890</i>&nbsp;        orderParagraphsLTR = ordarParaLTR;
<i>3891</i>&nbsp;    }
<i>3892</i>&nbsp;
<i>3893</i>&nbsp;    /**
<i>3894</i>&nbsp;     * Get the directionality of the text.
<i>3895</i>&nbsp;     *
<i>3896</i>&nbsp;     * @return a value of &lt;code&gt;LTR&lt;/code&gt;, &lt;code&gt;RTL&lt;/code&gt; or &lt;code&gt;MIXED&lt;/code&gt;
<i>3897</i>&nbsp;     *         that indicates if the entire text
<i>3898</i>&nbsp;     *         represented by this object is unidirectional,
<i>3899</i>&nbsp;     *         and which direction, or if it is mixed-directional.
<i>3900</i>&nbsp;     *
<i>3901</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>3902</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>3903</i>&nbsp;     *
<i>3904</i>&nbsp;     * @see #LTR
<i>3905</i>&nbsp;     * @see #RTL
<i>3906</i>&nbsp;     * @see #MIXED
<i>3907</i>&nbsp;     * @stable ICU 3.8
<i>3908</i>&nbsp;     */
<i>3909</i>&nbsp;    public byte getDirection()
<i>3910</i>&nbsp;    {
<i>3911</i>&nbsp;        verifyValidParaOrLine();
<i>3912</i>&nbsp;        return direction;
<i>3913</i>&nbsp;    }
<i>3914</i>&nbsp;
<i>3915</i>&nbsp;    /**
<i>3916</i>&nbsp;     * Get the length of the text.
<i>3917</i>&nbsp;     *
<i>3918</i>&nbsp;     * @return The length of the text that the &lt;code&gt;Bidi&lt;/code&gt; object was
<i>3919</i>&nbsp;     *         created for.
<i>3920</i>&nbsp;     *
<i>3921</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>3922</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>3923</i>&nbsp;     * @stable ICU 3.8
<i>3924</i>&nbsp;     */
<i>3925</i>&nbsp;    public int getLength()
<i>3926</i>&nbsp;    {
<i>3927</i>&nbsp;        verifyValidParaOrLine();
<i>3928</i>&nbsp;        return originalLength;
<i>3929</i>&nbsp;    }
<i>3930</i>&nbsp;
<i>3931</i>&nbsp;    /* paragraphs API methods ------------------------------------------------- */
<i>3932</i>&nbsp;
<i>3933</i>&nbsp;    /**
<i>3934</i>&nbsp;     * Get the paragraph level of the text.
<i>3935</i>&nbsp;     *
<i>3936</i>&nbsp;     * @return The paragraph level. If there are multiple paragraphs, their
<i>3937</i>&nbsp;     *         level may vary if the required paraLevel is LEVEL_DEFAULT_LTR or
<i>3938</i>&nbsp;     *         LEVEL_DEFAULT_RTL.  In that case, the level of the first paragraph
<i>3939</i>&nbsp;     *         is returned.
<i>3940</i>&nbsp;     *
<i>3941</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>3942</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>3943</i>&nbsp;     *
<i>3944</i>&nbsp;     * @see #LEVEL_DEFAULT_LTR
<i>3945</i>&nbsp;     * @see #LEVEL_DEFAULT_RTL
<i>3946</i>&nbsp;     * @see #getParagraph
<i>3947</i>&nbsp;     * @see #getParagraphByIndex
<i>3948</i>&nbsp;     * @stable ICU 3.8
<i>3949</i>&nbsp;     */
<i>3950</i>&nbsp;    public byte getParaLevel()
<i>3951</i>&nbsp;    {
<i>3952</i>&nbsp;        verifyValidParaOrLine();
<i>3953</i>&nbsp;        return paraLevel;
<i>3954</i>&nbsp;    }
<i>3955</i>&nbsp;
<i>3956</i>&nbsp;    /**
<i>3957</i>&nbsp;     * Retrieves the Bidi class for a given code point.
<i>3958</i>&nbsp;     * &lt;p&gt;If a &lt;code&gt;BidiClassifier&lt;/code&gt; is defined and returns a value
<i>3959</i>&nbsp;     * other than &lt;code&gt;CLASS_DEFAULT&lt;/code&gt;, that value is used; otherwise
<i>3960</i>&nbsp;     * the default class determination mechanism is invoked.&lt;/p&gt;
<i>3961</i>&nbsp;     *
<i>3962</i>&nbsp;     * @param c The code point to get a Bidi class for.
<i>3963</i>&nbsp;     *
<i>3964</i>&nbsp;     * @return The Bidi class for the character &lt;code&gt;c&lt;/code&gt; that is in effect
<i>3965</i>&nbsp;     *         for this &lt;code&gt;Bidi&lt;/code&gt; instance.
<i>3966</i>&nbsp;     *
<i>3967</i>&nbsp;     * @stable ICU 3.8
<i>3968</i>&nbsp;     */
<i>3969</i>&nbsp;    public int getCustomizedClass(int c) {
<i>3970</i>&nbsp;        int dir;
<i>3971</i>&nbsp;
<i>3972</i>&nbsp;        dir = bdp.getClass(c);
<i>3973</i>&nbsp;        if (dir &gt;= CHAR_DIRECTION_COUNT)
<i>3974</i>&nbsp;            dir = ON;
<i>3975</i>&nbsp;        return dir;
<i>3976</i>&nbsp;    }
<i>3977</i>&nbsp;
<i>3978</i>&nbsp;    /**
<i>3979</i>&nbsp;     * &lt;code&gt;setLine()&lt;/code&gt; returns a &lt;code&gt;Bidi&lt;/code&gt; object to
<i>3980</i>&nbsp;     * contain the reordering information, especially the resolved levels,
<i>3981</i>&nbsp;     * for all the characters in a line of text. This line of text is
<i>3982</i>&nbsp;     * specified by referring to a &lt;code&gt;Bidi&lt;/code&gt; object representing
<i>3983</i>&nbsp;     * this information for a piece of text containing one or more paragraphs,
<i>3984</i>&nbsp;     * and by specifying a range of indexes in this text.&lt;p&gt;
<i>3985</i>&nbsp;     * In the new line object, the indexes will range from 0 to &lt;code&gt;limit-start-1&lt;/code&gt;.&lt;p&gt;
<i>3986</i>&nbsp;     *
<i>3987</i>&nbsp;     * This is used after calling &lt;code&gt;setPara()&lt;/code&gt;
<i>3988</i>&nbsp;     * for a piece of text, and after line-breaking on that text.
<i>3989</i>&nbsp;     * It is not necessary if each paragraph is treated as a single line.&lt;p&gt;
<i>3990</i>&nbsp;     *
<i>3991</i>&nbsp;     * After line-breaking, rules (L1) and (L2) for the treatment of
<i>3992</i>&nbsp;     * trailing WS and for reordering are performed on
<i>3993</i>&nbsp;     * a &lt;code&gt;Bidi&lt;/code&gt; object that represents a line.&lt;p&gt;
<i>3994</i>&nbsp;     *
<i>3995</i>&nbsp;     * &lt;strong&gt;Important: &lt;/strong&gt;the line &lt;code&gt;Bidi&lt;/code&gt; object may
<i>3996</i>&nbsp;     * reference data within the global text &lt;code&gt;Bidi&lt;/code&gt; object.
<i>3997</i>&nbsp;     * You should not alter the content of the global text object until
<i>3998</i>&nbsp;     * you are finished using the line object.
<i>3999</i>&nbsp;     *
<i>4000</i>&nbsp;     * @param start is the line&#39;s first index into the text.
<i>4001</i>&nbsp;     *
<i>4002</i>&nbsp;     * @param limit is just behind the line&#39;s last index into the text
<i>4003</i>&nbsp;     *        (its last index +1).
<i>4004</i>&nbsp;     *
<i>4005</i>&nbsp;     * @return a &lt;code&gt;Bidi&lt;/code&gt; object that will now represent a line of the text.
<i>4006</i>&nbsp;     *
<i>4007</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4008</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt;
<i>4009</i>&nbsp;     * @throws IllegalArgumentException if start and limit are not in the range
<i>4010</i>&nbsp;     *         &lt;code&gt;0&amp;lt;=start&amp;lt;limit&amp;lt;=getProcessedLength()&lt;/code&gt;,
<i>4011</i>&nbsp;     *         or if the specified line crosses a paragraph boundary
<i>4012</i>&nbsp;     *
<i>4013</i>&nbsp;     * @see #setPara
<i>4014</i>&nbsp;     * @see #getProcessedLength
<i>4015</i>&nbsp;     * @stable ICU 3.8
<i>4016</i>&nbsp;     */
<i>4017</i>&nbsp;    public Bidi setLine(Bidi bidi, BidiBase bidiBase, Bidi newBidi, BidiBase newBidiBase, int start, int limit)
<i>4018</i>&nbsp;    {
<i>4019</i>&nbsp;        verifyValidPara();
<i>4020</i>&nbsp;        verifyRange(start, 0, limit);
<i>4021</i>&nbsp;        verifyRange(limit, 0, length+1);
<i>4022</i>&nbsp;
<i>4023</i>&nbsp;        return BidiLine.setLine(this, newBidi, newBidiBase, start, limit);
<i>4024</i>&nbsp;    }
<i>4025</i>&nbsp;
<i>4026</i>&nbsp;    /**
<i>4027</i>&nbsp;     * Get the level for one character.
<i>4028</i>&nbsp;     *
<i>4029</i>&nbsp;     * @param charIndex the index of a character.
<i>4030</i>&nbsp;     *
<i>4031</i>&nbsp;     * @return The level for the character at &lt;code&gt;charIndex&lt;/code&gt;.
<i>4032</i>&nbsp;     *
<i>4033</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4034</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4035</i>&nbsp;     * @throws IllegalArgumentException if charIndex is not in the range
<i>4036</i>&nbsp;     *         &lt;code&gt;0&amp;lt;=charIndex&amp;lt;getProcessedLength()&lt;/code&gt;
<i>4037</i>&nbsp;     *
<i>4038</i>&nbsp;     * @see #getProcessedLength
<i>4039</i>&nbsp;     * @stable ICU 3.8
<i>4040</i>&nbsp;     */
<i>4041</i>&nbsp;    public byte getLevelAt(int charIndex)
<i>4042</i>&nbsp;    {
<i>4043</i>&nbsp;        // for backward compatibility
<i>4044</i>&nbsp;        if (charIndex &lt; 0 || charIndex &gt;= length) {
<i>4045</i>&nbsp;            return (byte)getBaseLevel();
<i>4046</i>&nbsp;        }
<i>4047</i>&nbsp;
<i>4048</i>&nbsp;        verifyValidParaOrLine();
<i>4049</i>&nbsp;        verifyRange(charIndex, 0, length);
<i>4050</i>&nbsp;        return BidiLine.getLevelAt(this, charIndex);
<i>4051</i>&nbsp;    }
<i>4052</i>&nbsp;
<i>4053</i>&nbsp;    /**
<i>4054</i>&nbsp;     * Get an array of levels for each character.&lt;p&gt;
<i>4055</i>&nbsp;     *
<i>4056</i>&nbsp;     * Note that this method may allocate memory under some
<i>4057</i>&nbsp;     * circumstances, unlike &lt;code&gt;getLevelAt()&lt;/code&gt;.
<i>4058</i>&nbsp;     *
<i>4059</i>&nbsp;     * @return The levels array for the text,
<i>4060</i>&nbsp;     *         or &lt;code&gt;null&lt;/code&gt; if an error occurs.
<i>4061</i>&nbsp;     *
<i>4062</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4063</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4064</i>&nbsp;     * @stable ICU 3.8
<i>4065</i>&nbsp;     */
<i>4066</i>&nbsp;    byte[] getLevels()
<i>4067</i>&nbsp;    {
<i>4068</i>&nbsp;        verifyValidParaOrLine();
<i>4069</i>&nbsp;        if (length &lt;= 0) {
<i>4070</i>&nbsp;            return new byte[0];
<i>4071</i>&nbsp;        }
<i>4072</i>&nbsp;        return BidiLine.getLevels(this);
<i>4073</i>&nbsp;    }
<i>4074</i>&nbsp;
<i>4075</i>&nbsp;    /**
<i>4076</i>&nbsp;     * Get the number of runs.
<i>4077</i>&nbsp;     * This method may invoke the actual reordering on the
<i>4078</i>&nbsp;     * &lt;code&gt;Bidi&lt;/code&gt; object, after &lt;code&gt;setPara()&lt;/code&gt;
<i>4079</i>&nbsp;     * may have resolved only the levels of the text. Therefore,
<i>4080</i>&nbsp;     * &lt;code&gt;countRuns()&lt;/code&gt; may have to allocate memory,
<i>4081</i>&nbsp;     * and may throw an exception if it fails to do so.
<i>4082</i>&nbsp;     *
<i>4083</i>&nbsp;     * @return The number of runs.
<i>4084</i>&nbsp;     *
<i>4085</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4086</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4087</i>&nbsp;     * @stable ICU 3.8
<i>4088</i>&nbsp;     */
<i>4089</i>&nbsp;    public int countRuns()
<i>4090</i>&nbsp;    {
<i>4091</i>&nbsp;        verifyValidParaOrLine();
<i>4092</i>&nbsp;        BidiLine.getRuns(this);
<i>4093</i>&nbsp;        return runCount;
<i>4094</i>&nbsp;    }
<i>4095</i>&nbsp;
<i>4096</i>&nbsp;    /**
<i>4097</i>&nbsp;     *
<i>4098</i>&nbsp;     * Get a &lt;code&gt;BidiRun&lt;/code&gt; object according to its index. BidiRun methods
<i>4099</i>&nbsp;     * may be used to retrieve the run&#39;s logical start, length and level,
<i>4100</i>&nbsp;     * which can be even for an LTR run or odd for an RTL run.
<i>4101</i>&nbsp;     * In an RTL run, the character at the logical start is
<i>4102</i>&nbsp;     * visually on the right of the displayed run.
<i>4103</i>&nbsp;     * The length is the number of characters in the run.&lt;p&gt;
<i>4104</i>&nbsp;     * &lt;code&gt;countRuns()&lt;/code&gt; is normally called
<i>4105</i>&nbsp;     * before the runs are retrieved.
<i>4106</i>&nbsp;     *
<i>4107</i>&nbsp;     * &lt;p&gt;
<i>4108</i>&nbsp;     *  Example:
<i>4109</i>&nbsp;     * &lt;pre&gt;
<i>4110</i>&nbsp;     *  Bidi bidi = new Bidi();
<i>4111</i>&nbsp;     *  String text = &quot;abc 123 DEFG xyz&quot;;
<i>4112</i>&nbsp;     *  bidi.setPara(text, Bidi.RTL, null);
<i>4113</i>&nbsp;     *  int i, count=bidi.countRuns(), logicalStart, visualIndex=0, length;
<i>4114</i>&nbsp;     *  BidiRun run;
<i>4115</i>&nbsp;     *  for (i = 0; i &amp;lt; count; ++i) {
<i>4116</i>&nbsp;     *      run = bidi.getVisualRun(i);
<i>4117</i>&nbsp;     *      logicalStart = run.getStart();
<i>4118</i>&nbsp;     *      length = run.getLength();
<i>4119</i>&nbsp;     *      if (Bidi.LTR == run.getEmbeddingLevel()) {
<i>4120</i>&nbsp;     *          do { // LTR
<i>4121</i>&nbsp;     *              show_char(text.charAt(logicalStart++), visualIndex++);
<i>4122</i>&nbsp;     *          } while (--length &amp;gt; 0);
<i>4123</i>&nbsp;     *      } else {
<i>4124</i>&nbsp;     *          logicalStart += length;  // logicalLimit
<i>4125</i>&nbsp;     *          do { // RTL
<i>4126</i>&nbsp;     *              show_char(text.charAt(--logicalStart), visualIndex++);
<i>4127</i>&nbsp;     *          } while (--length &amp;gt; 0);
<i>4128</i>&nbsp;     *      }
<i>4129</i>&nbsp;     *  }
<i>4130</i>&nbsp;     * &lt;/pre&gt;
<i>4131</i>&nbsp;     * &lt;p&gt;
<i>4132</i>&nbsp;     * Note that in right-to-left runs, code like this places
<i>4133</i>&nbsp;     * second surrogates before first ones (which is generally a bad idea)
<i>4134</i>&nbsp;     * and combining characters before base characters.
<i>4135</i>&nbsp;     * &lt;p&gt;
<i>4136</i>&nbsp;     * Use of &lt;code&gt;{@link #writeReordered}&lt;/code&gt;, optionally with the
<i>4137</i>&nbsp;     * &lt;code&gt;{@link #KEEP_BASE_COMBINING}&lt;/code&gt; option, can be considered in
<i>4138</i>&nbsp;     * order to avoid these issues.
<i>4139</i>&nbsp;     *
<i>4140</i>&nbsp;     * @param runIndex is the number of the run in visual order, in the
<i>4141</i>&nbsp;     *        range &lt;code&gt;[0..countRuns()-1]&lt;/code&gt;.
<i>4142</i>&nbsp;     *
<i>4143</i>&nbsp;     * @return a BidiRun object containing the details of the run. The
<i>4144</i>&nbsp;     *         directionality of the run is
<i>4145</i>&nbsp;     *         &lt;code&gt;LTR==0&lt;/code&gt; or &lt;code&gt;RTL==1&lt;/code&gt;,
<i>4146</i>&nbsp;     *         never &lt;code&gt;MIXED&lt;/code&gt;.
<i>4147</i>&nbsp;     *
<i>4148</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4149</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4150</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;runIndex&lt;/code&gt; is not in
<i>4151</i>&nbsp;     *         the range &lt;code&gt;0&amp;lt;=runIndex&amp;lt;countRuns()&lt;/code&gt;
<i>4152</i>&nbsp;     *
<i>4153</i>&nbsp;     * @see #countRuns()
<i>4154</i>&nbsp;     * @see com.ibm.icu.text.BidiRun
<i>4155</i>&nbsp;     * @see com.ibm.icu.text.BidiRun#getStart()
<i>4156</i>&nbsp;     * @see com.ibm.icu.text.BidiRun#getLength()
<i>4157</i>&nbsp;     * @see com.ibm.icu.text.BidiRun#getEmbeddingLevel()
<i>4158</i>&nbsp;     * @stable ICU 3.8
<i>4159</i>&nbsp;     */
<i>4160</i>&nbsp;    BidiRun getVisualRun(int runIndex)
<i>4161</i>&nbsp;    {
<i>4162</i>&nbsp;        verifyValidParaOrLine();
<i>4163</i>&nbsp;        BidiLine.getRuns(this);
<i>4164</i>&nbsp;        verifyRange(runIndex, 0, runCount);
<i>4165</i>&nbsp;        return BidiLine.getVisualRun(this, runIndex);
<i>4166</i>&nbsp;    }
<i>4167</i>&nbsp;
<i>4168</i>&nbsp;    /**
<i>4169</i>&nbsp;     * Get a visual-to-logical index map (array) for the characters in the
<i>4170</i>&nbsp;     * &lt;code&gt;Bidi&lt;/code&gt; (paragraph or line) object.
<i>4171</i>&nbsp;     * &lt;p&gt;
<i>4172</i>&nbsp;     * Some values in the map may be &lt;code&gt;MAP_NOWHERE&lt;/code&gt; if the
<i>4173</i>&nbsp;     * corresponding text characters are Bidi marks inserted in the visual
<i>4174</i>&nbsp;     * output by the option &lt;code&gt;OPTION_INSERT_MARKS&lt;/code&gt;.
<i>4175</i>&nbsp;     * &lt;p&gt;
<i>4176</i>&nbsp;     * When the visual output is altered by using options of
<i>4177</i>&nbsp;     * &lt;code&gt;writeReordered()&lt;/code&gt; such as &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt;,
<i>4178</i>&nbsp;     * &lt;code&gt;KEEP_BASE_COMBINING&lt;/code&gt;, &lt;code&gt;OUTPUT_REVERSE&lt;/code&gt;,
<i>4179</i>&nbsp;     * &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt;, the logical positions returned may not
<i>4180</i>&nbsp;     * be correct. It is advised to use, when possible, reordering options
<i>4181</i>&nbsp;     * such as {@link #OPTION_INSERT_MARKS} and {@link #OPTION_REMOVE_CONTROLS}.
<i>4182</i>&nbsp;     *
<i>4183</i>&nbsp;     * @return an array of &lt;code&gt;getResultLength()&lt;/code&gt;
<i>4184</i>&nbsp;     *        indexes which will reflect the reordering of the characters.&lt;br&gt;&lt;br&gt;
<i>4185</i>&nbsp;     *        The index map will result in
<i>4186</i>&nbsp;     *        &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
<i>4187</i>&nbsp;     *        &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.
<i>4188</i>&nbsp;     *
<i>4189</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4190</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4191</i>&nbsp;     *
<i>4192</i>&nbsp;     * @see #getLogicalMap
<i>4193</i>&nbsp;     * @see #getLogicalIndex
<i>4194</i>&nbsp;     * @see #getResultLength
<i>4195</i>&nbsp;     * @see #MAP_NOWHERE
<i>4196</i>&nbsp;     * @see #OPTION_INSERT_MARKS
<i>4197</i>&nbsp;     * @see #writeReordered
<i>4198</i>&nbsp;     * @stable ICU 3.8
<i>4199</i>&nbsp;     */
<i>4200</i>&nbsp;    private int[] getVisualMap()
<i>4201</i>&nbsp;    {
<i>4202</i>&nbsp;        /* countRuns() checks successful call to setPara/setLine */
<i>4203</i>&nbsp;        countRuns();
<i>4204</i>&nbsp;        if (resultLength &lt;= 0) {
<i>4205</i>&nbsp;            return new int[0];
<i>4206</i>&nbsp;        }
<i>4207</i>&nbsp;        return BidiLine.getVisualMap(this);
<i>4208</i>&nbsp;    }
<i>4209</i>&nbsp;
<i>4210</i>&nbsp;    /**
<i>4211</i>&nbsp;     * This is a convenience method that does not use a &lt;code&gt;Bidi&lt;/code&gt; object.
<i>4212</i>&nbsp;     * It is intended to be used for when an application has determined the levels
<i>4213</i>&nbsp;     * of objects (character sequences) and just needs to have them reordered (L2).
<i>4214</i>&nbsp;     * This is equivalent to using &lt;code&gt;getVisualMap()&lt;/code&gt; on a
<i>4215</i>&nbsp;     * &lt;code&gt;Bidi&lt;/code&gt; object.
<i>4216</i>&nbsp;     *
<i>4217</i>&nbsp;     * @param levels is an array of levels that have been determined by
<i>4218</i>&nbsp;     *        the application.
<i>4219</i>&nbsp;     *
<i>4220</i>&nbsp;     * @return an array of &lt;code&gt;levels.length&lt;/code&gt;
<i>4221</i>&nbsp;     *        indexes which will reflect the reordering of the characters.&lt;p&gt;
<i>4222</i>&nbsp;     *        The index map will result in
<i>4223</i>&nbsp;     *        &lt;code&gt;indexMap[visualIndex]==logicalIndex&lt;/code&gt;, where
<i>4224</i>&nbsp;     *        &lt;code&gt;indexMap&lt;/code&gt; represents the returned array.
<i>4225</i>&nbsp;     *
<i>4226</i>&nbsp;     * @stable ICU 3.8
<i>4227</i>&nbsp;     */
<i>4228</i>&nbsp;    private static int[] reorderVisual(byte[] levels)
<i>4229</i>&nbsp;    {
<i>4230</i>&nbsp;        return BidiLine.reorderVisual(levels);
<i>4231</i>&nbsp;    }
<i>4232</i>&nbsp;
<i>4233</i>&nbsp;    /**
<i>4234</i>&nbsp;     * Constant indicating that the base direction depends on the first strong
<i>4235</i>&nbsp;     * directional character in the text according to the Unicode Bidirectional
<i>4236</i>&nbsp;     * Algorithm. If no strong directional character is present, the base
<i>4237</i>&nbsp;     * direction is right-to-left.
<i>4238</i>&nbsp;     * @stable ICU 3.8
<i>4239</i>&nbsp;     */
<i>4240</i>&nbsp;    public static final int DIRECTION_DEFAULT_RIGHT_TO_LEFT = LEVEL_DEFAULT_RTL;
<i>4241</i>&nbsp;
<i>4242</i>&nbsp;    /**
<i>4243</i>&nbsp;     * Create Bidi from the given text, embedding, and direction information.
<i>4244</i>&nbsp;     * The embeddings array may be null. If present, the values represent
<i>4245</i>&nbsp;     * embedding level information. Negative values from -1 to -61 indicate
<i>4246</i>&nbsp;     * overrides at the absolute value of the level. Positive values from 1 to
<i>4247</i>&nbsp;     * 61 indicate embeddings. Where values are zero, the base embedding level
<i>4248</i>&nbsp;     * as determined by the base direction is assumed.&lt;p&gt;
<i>4249</i>&nbsp;     *
<i>4250</i>&nbsp;     * Note: this constructor calls setPara() internally.
<i>4251</i>&nbsp;     *
<i>4252</i>&nbsp;     * @param text an array containing the paragraph of text to process.
<i>4253</i>&nbsp;     * @param textStart the index into the text array of the start of the
<i>4254</i>&nbsp;     *        paragraph.
<i>4255</i>&nbsp;     * @param embeddings an array containing embedding values for each character
<i>4256</i>&nbsp;     *        in the paragraph. This can be null, in which case it is assumed
<i>4257</i>&nbsp;     *        that there is no external embedding information.
<i>4258</i>&nbsp;     * @param embStart the index into the embedding array of the start of the
<i>4259</i>&nbsp;     *        paragraph.
<i>4260</i>&nbsp;     * @param paragraphLength the length of the paragraph in the text and
<i>4261</i>&nbsp;     *        embeddings arrays.
<i>4262</i>&nbsp;     * @param flags a collection of flags that control the algorithm. The
<i>4263</i>&nbsp;     *        algorithm understands the flags DIRECTION_LEFT_TO_RIGHT,
<i>4264</i>&nbsp;     *        DIRECTION_RIGHT_TO_LEFT, DIRECTION_DEFAULT_LEFT_TO_RIGHT, and
<i>4265</i>&nbsp;     *        DIRECTION_DEFAULT_RIGHT_TO_LEFT. Other values are reserved.
<i>4266</i>&nbsp;     *
<i>4267</i>&nbsp;     * @throws IllegalArgumentException if the values in embeddings are
<i>4268</i>&nbsp;     *         not within the allowed range
<i>4269</i>&nbsp;     *
<i>4270</i>&nbsp;     * @see #DIRECTION_LEFT_TO_RIGHT
<i>4271</i>&nbsp;     * @see #DIRECTION_RIGHT_TO_LEFT
<i>4272</i>&nbsp;     * @see #DIRECTION_DEFAULT_LEFT_TO_RIGHT
<i>4273</i>&nbsp;     * @see #DIRECTION_DEFAULT_RIGHT_TO_LEFT
<i>4274</i>&nbsp;     * @stable ICU 3.8
<i>4275</i>&nbsp;     */
<i>4276</i>&nbsp;    public BidiBase(char[] text,
<i>4277</i>&nbsp;            int textStart,
<i>4278</i>&nbsp;            byte[] embeddings,
<i>4279</i>&nbsp;            int embStart,
<i>4280</i>&nbsp;            int paragraphLength,
<i>4281</i>&nbsp;            int flags)
<i>4282</i>&nbsp;    {
<i>4283</i>&nbsp;        this(0, 0);
<i>4284</i>&nbsp;        byte paraLvl;
<i>4285</i>&nbsp;        switch (flags) {
<i>4286</i>&nbsp;        case Bidi.DIRECTION_LEFT_TO_RIGHT:
<i>4287</i>&nbsp;        default:
<i>4288</i>&nbsp;            paraLvl = LTR;
<i>4289</i>&nbsp;            break;
<i>4290</i>&nbsp;        case Bidi.DIRECTION_RIGHT_TO_LEFT:
<i>4291</i>&nbsp;            paraLvl = RTL;
<i>4292</i>&nbsp;            break;
<i>4293</i>&nbsp;        case Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT:
<i>4294</i>&nbsp;            paraLvl = LEVEL_DEFAULT_LTR;
<i>4295</i>&nbsp;            break;
<i>4296</i>&nbsp;        case Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT:
<i>4297</i>&nbsp;            paraLvl = LEVEL_DEFAULT_RTL;
<i>4298</i>&nbsp;            break;
<i>4299</i>&nbsp;        }
<i>4300</i>&nbsp;        byte[] paraEmbeddings;
<i>4301</i>&nbsp;        if (embeddings == null) {
<i>4302</i>&nbsp;            paraEmbeddings = null;
<i>4303</i>&nbsp;        } else {
<i>4304</i>&nbsp;            paraEmbeddings = new byte[paragraphLength];
<i>4305</i>&nbsp;            byte lev;
<i>4306</i>&nbsp;            for (int i = 0; i &lt; paragraphLength; i++) {
<i>4307</i>&nbsp;                lev = embeddings[i + embStart];
<i>4308</i>&nbsp;                if (lev &lt; 0) {
<i>4309</i>&nbsp;                    lev = (byte)((- lev) | LEVEL_OVERRIDE);
<i>4310</i>&nbsp;                } else if (lev == 0) {
<i>4311</i>&nbsp;                    lev = paraLvl;
<i>4312</i>&nbsp;                    if (paraLvl &gt; MAX_EXPLICIT_LEVEL) {
<i>4313</i>&nbsp;                        lev &amp;= 1;
<i>4314</i>&nbsp;                    }
<i>4315</i>&nbsp;                }
<i>4316</i>&nbsp;                paraEmbeddings[i] = lev;
<i>4317</i>&nbsp;            }
<i>4318</i>&nbsp;        }
<i>4319</i>&nbsp;
<i>4320</i>&nbsp;        char[] paraText = new char[paragraphLength];
<i>4321</i>&nbsp;        System.arraycopy(text, textStart, paraText, 0, paragraphLength);
<i>4322</i>&nbsp;        setPara(paraText, paraLvl, paraEmbeddings);
<i>4323</i>&nbsp;    }
<i>4324</i>&nbsp;
<i>4325</i>&nbsp;    /**
<i>4326</i>&nbsp;     * Return true if the line is not left-to-right or right-to-left. This means
<i>4327</i>&nbsp;     * it either has mixed runs of left-to-right and right-to-left text, or the
<i>4328</i>&nbsp;     * base direction differs from the direction of the only run of text.
<i>4329</i>&nbsp;     *
<i>4330</i>&nbsp;     * @return true if the line is not left-to-right or right-to-left.
<i>4331</i>&nbsp;     *
<i>4332</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4333</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt;
<i>4334</i>&nbsp;     * @stable ICU 3.8
<i>4335</i>&nbsp;     */
<i>4336</i>&nbsp;    public boolean isMixed()
<i>4337</i>&nbsp;    {
<i>4338</i>&nbsp;        return (!isLeftToRight() &amp;&amp; !isRightToLeft());
<i>4339</i>&nbsp;    }
<i>4340</i>&nbsp;
<i>4341</i>&nbsp;    /**
<i>4342</i>&nbsp;     * Return true if the line is all left-to-right text and the base direction
<i>4343</i>&nbsp;     * is left-to-right.
<i>4344</i>&nbsp;     *
<i>4345</i>&nbsp;     * @return true if the line is all left-to-right text and the base direction
<i>4346</i>&nbsp;     *         is left-to-right.
<i>4347</i>&nbsp;     *
<i>4348</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4349</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt;
<i>4350</i>&nbsp;     * @stable ICU 3.8
<i>4351</i>&nbsp;     */
<i>4352</i>&nbsp;    public boolean isLeftToRight()
<i>4353</i>&nbsp;    {
<i>4354</i>&nbsp;        return (getDirection() == LTR &amp;&amp; (paraLevel &amp; 1) == 0);
<i>4355</i>&nbsp;    }
<i>4356</i>&nbsp;
<i>4357</i>&nbsp;    /**
<i>4358</i>&nbsp;     * Return true if the line is all right-to-left text, and the base direction
<i>4359</i>&nbsp;     * is right-to-left
<i>4360</i>&nbsp;     *
<i>4361</i>&nbsp;     * @return true if the line is all right-to-left text, and the base
<i>4362</i>&nbsp;     *         direction is right-to-left
<i>4363</i>&nbsp;     *
<i>4364</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4365</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt;
<i>4366</i>&nbsp;     * @stable ICU 3.8
<i>4367</i>&nbsp;     */
<i>4368</i>&nbsp;    public boolean isRightToLeft()
<i>4369</i>&nbsp;    {
<i>4370</i>&nbsp;        return (getDirection() == RTL &amp;&amp; (paraLevel &amp; 1) == 1);
<i>4371</i>&nbsp;    }
<i>4372</i>&nbsp;
<i>4373</i>&nbsp;    /**
<i>4374</i>&nbsp;     * Return true if the base direction is left-to-right
<i>4375</i>&nbsp;     *
<i>4376</i>&nbsp;     * @return true if the base direction is left-to-right
<i>4377</i>&nbsp;     *
<i>4378</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4379</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4380</i>&nbsp;     *
<i>4381</i>&nbsp;     * @stable ICU 3.8
<i>4382</i>&nbsp;     */
<i>4383</i>&nbsp;    public boolean baseIsLeftToRight()
<i>4384</i>&nbsp;    {
<i>4385</i>&nbsp;        return (getParaLevel() == LTR);
<i>4386</i>&nbsp;    }
<i>4387</i>&nbsp;
<i>4388</i>&nbsp;    /**
<i>4389</i>&nbsp;     * Return the base level (0 if left-to-right, 1 if right-to-left).
<i>4390</i>&nbsp;     *
<i>4391</i>&nbsp;     * @return the base level
<i>4392</i>&nbsp;     *
<i>4393</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4394</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4395</i>&nbsp;     *
<i>4396</i>&nbsp;     * @stable ICU 3.8
<i>4397</i>&nbsp;     */
<i>4398</i>&nbsp;    public int getBaseLevel()
<i>4399</i>&nbsp;    {
<i>4400</i>&nbsp;        return getParaLevel();
<i>4401</i>&nbsp;    }
<i>4402</i>&nbsp;
<i>4403</i>&nbsp;    /**
<i>4404</i>&nbsp;     * Compute the logical to visual run mapping
<i>4405</i>&nbsp;     */
<i>4406</i>&nbsp;     void getLogicalToVisualRunsMap()
<i>4407</i>&nbsp;     {
<i>4408</i>&nbsp;        if (isGoodLogicalToVisualRunsMap) {
<i>4409</i>&nbsp;            return;
<i>4410</i>&nbsp;        }
<i>4411</i>&nbsp;        int count = countRuns();
<i>4412</i>&nbsp;        if ((logicalToVisualRunsMap == null) ||
<i>4413</i>&nbsp;            (logicalToVisualRunsMap.length &lt; count)) {
<i>4414</i>&nbsp;            logicalToVisualRunsMap = new int[count];
<i>4415</i>&nbsp;        }
<i>4416</i>&nbsp;        int i;
<i>4417</i>&nbsp;        long[] keys = new long[count];
<i>4418</i>&nbsp;        for (i = 0; i &lt; count; i++) {
<i>4419</i>&nbsp;            keys[i] = ((long)(runs[i].start)&lt;&lt;32) + i;
<i>4420</i>&nbsp;        }
<i>4421</i>&nbsp;        Arrays.sort(keys);
<i>4422</i>&nbsp;        for (i = 0; i &lt; count; i++) {
<i>4423</i>&nbsp;            logicalToVisualRunsMap[i] = (int)(keys[i] &amp; 0x00000000FFFFFFFF);
<i>4424</i>&nbsp;        }
<i>4425</i>&nbsp;        isGoodLogicalToVisualRunsMap = true;
<i>4426</i>&nbsp;     }
<i>4427</i>&nbsp;
<i>4428</i>&nbsp;    /**
<i>4429</i>&nbsp;     * Return the level of the nth logical run in this line.
<i>4430</i>&nbsp;     *
<i>4431</i>&nbsp;     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()-1&lt;/code&gt;
<i>4432</i>&nbsp;     *
<i>4433</i>&nbsp;     * @return the level of the run
<i>4434</i>&nbsp;     *
<i>4435</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4436</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4437</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
<i>4438</i>&nbsp;     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
<i>4439</i>&nbsp;     * @stable ICU 3.8
<i>4440</i>&nbsp;     */
<i>4441</i>&nbsp;    public int getRunLevel(int run)
<i>4442</i>&nbsp;    {
<i>4443</i>&nbsp;        verifyValidParaOrLine();
<i>4444</i>&nbsp;        BidiLine.getRuns(this);
<i>4445</i>&nbsp;
<i>4446</i>&nbsp;        // for backward compatibility
<i>4447</i>&nbsp;        if (run &lt; 0 || run &gt;= runCount) {
<i>4448</i>&nbsp;            return getParaLevel();
<i>4449</i>&nbsp;        }
<i>4450</i>&nbsp;
<i>4451</i>&nbsp;        getLogicalToVisualRunsMap();
<i>4452</i>&nbsp;        return runs[logicalToVisualRunsMap[run]].level;
<i>4453</i>&nbsp;    }
<i>4454</i>&nbsp;
<i>4455</i>&nbsp;    /**
<i>4456</i>&nbsp;     * Return the index of the character at the start of the nth logical run in
<i>4457</i>&nbsp;     * this line, as an offset from the start of the line.
<i>4458</i>&nbsp;     *
<i>4459</i>&nbsp;     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;
<i>4460</i>&nbsp;     *
<i>4461</i>&nbsp;     * @return the start of the run
<i>4462</i>&nbsp;     *
<i>4463</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4464</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4465</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
<i>4466</i>&nbsp;     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
<i>4467</i>&nbsp;     * @stable ICU 3.8
<i>4468</i>&nbsp;     */
<i>4469</i>&nbsp;    public int getRunStart(int run)
<i>4470</i>&nbsp;    {
<i>4471</i>&nbsp;        verifyValidParaOrLine();
<i>4472</i>&nbsp;        BidiLine.getRuns(this);
<i>4473</i>&nbsp;
<i>4474</i>&nbsp;        // for backward compatibility
<i>4475</i>&nbsp;        if (runCount == 1) {
<i>4476</i>&nbsp;            return 0;
<i>4477</i>&nbsp;        } else if (run == runCount) {
<i>4478</i>&nbsp;            return length;
<i>4479</i>&nbsp;        }
<i>4480</i>&nbsp;
<i>4481</i>&nbsp;        getLogicalToVisualRunsMap();
<i>4482</i>&nbsp;        return runs[logicalToVisualRunsMap[run]].start;
<i>4483</i>&nbsp;    }
<i>4484</i>&nbsp;
<i>4485</i>&nbsp;    /**
<i>4486</i>&nbsp;     * Return the index of the character past the end of the nth logical run in
<i>4487</i>&nbsp;     * this line, as an offset from the start of the line. For example, this
<i>4488</i>&nbsp;     * will return the length of the line for the last run on the line.
<i>4489</i>&nbsp;     *
<i>4490</i>&nbsp;     * @param run the index of the run, between 0 and &lt;code&gt;countRuns()&lt;/code&gt;
<i>4491</i>&nbsp;     *
<i>4492</i>&nbsp;     * @return the limit of the run
<i>4493</i>&nbsp;     *
<i>4494</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4495</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4496</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;run&lt;/code&gt; is not in
<i>4497</i>&nbsp;     *         the range &lt;code&gt;0&amp;lt;=run&amp;lt;countRuns()&lt;/code&gt;
<i>4498</i>&nbsp;     * @stable ICU 3.8
<i>4499</i>&nbsp;     */
<i>4500</i>&nbsp;    public int getRunLimit(int run)
<i>4501</i>&nbsp;    {
<i>4502</i>&nbsp;        verifyValidParaOrLine();
<i>4503</i>&nbsp;        BidiLine.getRuns(this);
<i>4504</i>&nbsp;
<i>4505</i>&nbsp;        // for backward compatibility
<i>4506</i>&nbsp;        if (runCount == 1) {
<i>4507</i>&nbsp;            return length;
<i>4508</i>&nbsp;        }
<i>4509</i>&nbsp;
<i>4510</i>&nbsp;        getLogicalToVisualRunsMap();
<i>4511</i>&nbsp;        int idx = logicalToVisualRunsMap[run];
<i>4512</i>&nbsp;        int len = idx == 0 ? runs[idx].limit :
<i>4513</i>&nbsp;                                runs[idx].limit - runs[idx-1].limit;
<i>4514</i>&nbsp;        return runs[idx].start + len;
<i>4515</i>&nbsp;    }
<i>4516</i>&nbsp;
<i>4517</i>&nbsp;    /**
<i>4518</i>&nbsp;     * Return true if the specified text requires bidi analysis. If this returns
<i>4519</i>&nbsp;     * false, the text will display left-to-right. Clients can then avoid
<i>4520</i>&nbsp;     * constructing a Bidi object. Text in the Arabic Presentation Forms area of
<i>4521</i>&nbsp;     * Unicode is presumed to already be shaped and ordered for display, and so
<i>4522</i>&nbsp;     * will not cause this method to return true.
<i>4523</i>&nbsp;     *
<i>4524</i>&nbsp;     * @param text the text containing the characters to test
<i>4525</i>&nbsp;     * @param start the start of the range of characters to test
<i>4526</i>&nbsp;     * @param limit the limit of the range of characters to test
<i>4527</i>&nbsp;     *
<i>4528</i>&nbsp;     * @return true if the range of characters requires bidi analysis
<i>4529</i>&nbsp;     *
<i>4530</i>&nbsp;     * @stable ICU 3.8
<i>4531</i>&nbsp;     */
<i>4532</i>&nbsp;    public static boolean requiresBidi(char[] text,
<i>4533</i>&nbsp;            int start,
<i>4534</i>&nbsp;            int limit)
<i>4535</i>&nbsp;    {
<i>4536</i>&nbsp;        final int RTLMask = (1 &lt;&lt; R |
<i>4537</i>&nbsp;                1 &lt;&lt; AL |
<i>4538</i>&nbsp;                1 &lt;&lt; RLE |
<i>4539</i>&nbsp;                1 &lt;&lt; RLO |
<i>4540</i>&nbsp;                1 &lt;&lt; AN);
<i>4541</i>&nbsp;
<i>4542</i>&nbsp;        if (0 &gt; start || start &gt; limit || limit &gt; text.length) {
<i>4543</i>&nbsp;            throw new IllegalArgumentException(&quot;Value start &quot; + start +
<i>4544</i>&nbsp;                      &quot; is out of range 0 to &quot; + limit);
<i>4545</i>&nbsp;        }
<i>4546</i>&nbsp;
<i>4547</i>&nbsp;        for (int i = start; i &lt; limit; ++i) {
<i>4548</i>&nbsp;            if (Character.isHighSurrogate(text[i]) &amp;&amp; i &lt; (limit-1) &amp;&amp;
<i>4549</i>&nbsp;                Character.isLowSurrogate(text[i+1])) {
<i>4550</i>&nbsp;                if (((1 &lt;&lt; UCharacter.getDirection(Character.codePointAt(text, i))) &amp; RTLMask) != 0) {
<i>4551</i>&nbsp;                    return true;
<i>4552</i>&nbsp;                }
<i>4553</i>&nbsp;            } else if (((1 &lt;&lt; UCharacter.getDirection(text[i])) &amp; RTLMask) != 0) {
<i>4554</i>&nbsp;                return true;
<i>4555</i>&nbsp;            }
<i>4556</i>&nbsp;        }
<i>4557</i>&nbsp;
<i>4558</i>&nbsp;        return false;
<i>4559</i>&nbsp;    }
<i>4560</i>&nbsp;
<i>4561</i>&nbsp;    /**
<i>4562</i>&nbsp;     * Reorder the objects in the array into visual order based on their levels.
<i>4563</i>&nbsp;     * This is a utility method to use when you have a collection of objects
<i>4564</i>&nbsp;     * representing runs of text in logical order, each run containing text at a
<i>4565</i>&nbsp;     * single level. The elements at &lt;code&gt;index&lt;/code&gt; from
<i>4566</i>&nbsp;     * &lt;code&gt;objectStart&lt;/code&gt; up to &lt;code&gt;objectStart + count&lt;/code&gt; in the
<i>4567</i>&nbsp;     * objects array will be reordered into visual order assuming
<i>4568</i>&nbsp;     * each run of text has the level indicated by the corresponding element in
<i>4569</i>&nbsp;     * the levels array (at &lt;code&gt;index - objectStart + levelStart&lt;/code&gt;).
<i>4570</i>&nbsp;     *
<i>4571</i>&nbsp;     * @param levels an array representing the bidi level of each object
<i>4572</i>&nbsp;     * @param levelStart the start position in the levels array
<i>4573</i>&nbsp;     * @param objects the array of objects to be reordered into visual order
<i>4574</i>&nbsp;     * @param objectStart the start position in the objects array
<i>4575</i>&nbsp;     * @param count the number of objects to reorder
<i>4576</i>&nbsp;     * @stable ICU 3.8
<i>4577</i>&nbsp;     */
<i>4578</i>&nbsp;    public static void reorderVisually(byte[] levels,
<i>4579</i>&nbsp;            int levelStart,
<i>4580</i>&nbsp;            Object[] objects,
<i>4581</i>&nbsp;            int objectStart,
<i>4582</i>&nbsp;            int count)
<i>4583</i>&nbsp;    {
<i>4584</i>&nbsp;        // for backward compatibility
<i>4585</i>&nbsp;        if (0 &gt; levelStart || levels.length &lt;= levelStart) {
<i>4586</i>&nbsp;          throw new IllegalArgumentException(&quot;Value levelStart &quot; +
<i>4587</i>&nbsp;                      levelStart + &quot; is out of range 0 to &quot; +
<i>4588</i>&nbsp;                      (levels.length-1));
<i>4589</i>&nbsp;        }
<i>4590</i>&nbsp;        if (0 &gt; objectStart || objects.length &lt;= objectStart) {
<i>4591</i>&nbsp;            throw new IllegalArgumentException(&quot;Value objectStart &quot; +
<i>4592</i>&nbsp;                      levelStart + &quot; is out of range 0 to &quot; +
<i>4593</i>&nbsp;                      (objects.length-1));
<i>4594</i>&nbsp;        }
<i>4595</i>&nbsp;        if (0 &gt; count || objects.length &lt; (objectStart+count)) {
<i>4596</i>&nbsp;            throw new IllegalArgumentException(&quot;Value count &quot; +
<i>4597</i>&nbsp;                      levelStart + &quot; is out of range 0 to &quot; +
<i>4598</i>&nbsp;                      (objects.length - objectStart));
<i>4599</i>&nbsp;        }
<i>4600</i>&nbsp;
<i>4601</i>&nbsp;        byte[] reorderLevels = new byte[count];
<i>4602</i>&nbsp;        System.arraycopy(levels, levelStart, reorderLevels, 0, count);
<i>4603</i>&nbsp;        int[] indexMap = reorderVisual(reorderLevels);
<i>4604</i>&nbsp;        Object[] temp = new Object[count];
<i>4605</i>&nbsp;        System.arraycopy(objects, objectStart, temp, 0, count);
<i>4606</i>&nbsp;        for (int i = 0; i &lt; count; ++i) {
<i>4607</i>&nbsp;            objects[objectStart + i] = temp[indexMap[i]];
<i>4608</i>&nbsp;        }
<i>4609</i>&nbsp;    }
<i>4610</i>&nbsp;
<i>4611</i>&nbsp;    /**
<i>4612</i>&nbsp;     * Take a &lt;code&gt;Bidi&lt;/code&gt; object containing the reordering
<i>4613</i>&nbsp;     * information for a piece of text (one or more paragraphs) set by
<i>4614</i>&nbsp;     * &lt;code&gt;setPara()&lt;/code&gt; or for a line of text set by &lt;code&gt;setLine()&lt;/code&gt;
<i>4615</i>&nbsp;     * and return a string containing the reordered text.
<i>4616</i>&nbsp;     *
<i>4617</i>&nbsp;     * &lt;p&gt;The text may have been aliased (only a reference was stored
<i>4618</i>&nbsp;     * without copying the contents), thus it must not have been modified
<i>4619</i>&nbsp;     * since the &lt;code&gt;setPara()&lt;/code&gt; call.&lt;/p&gt;
<i>4620</i>&nbsp;     *
<i>4621</i>&nbsp;     * This method preserves the integrity of characters with multiple
<i>4622</i>&nbsp;     * code units and (optionally) combining characters.
<i>4623</i>&nbsp;     * Characters in RTL runs can be replaced by mirror-image characters
<i>4624</i>&nbsp;     * in the returned string. Note that &quot;real&quot; mirroring has to be done in a
<i>4625</i>&nbsp;     * rendering engine by glyph selection and that for many &quot;mirrored&quot;
<i>4626</i>&nbsp;     * characters there are no Unicode characters as mirror-image equivalents.
<i>4627</i>&nbsp;     * There are also options to insert or remove Bidi control
<i>4628</i>&nbsp;     * characters; see the descriptions of the return value and the
<i>4629</i>&nbsp;     * &lt;code&gt;options&lt;/code&gt; parameter, and of the option bit flags.
<i>4630</i>&nbsp;     *
<i>4631</i>&nbsp;     * @param options A bit set of options for the reordering that control
<i>4632</i>&nbsp;     *                how the reordered text is written.
<i>4633</i>&nbsp;     *                The options include mirroring the characters on a code
<i>4634</i>&nbsp;     *                point basis and inserting LRM characters, which is used
<i>4635</i>&nbsp;     *                especially for transforming visually stored text
<i>4636</i>&nbsp;     *                to logically stored text (although this is still an
<i>4637</i>&nbsp;     *                imperfect implementation of an &quot;inverse Bidi&quot; algorithm
<i>4638</i>&nbsp;     *                because it uses the &quot;forward Bidi&quot; algorithm at its core).
<i>4639</i>&nbsp;     *                The available options are:
<i>4640</i>&nbsp;     *                &lt;code&gt;DO_MIRRORING&lt;/code&gt;,
<i>4641</i>&nbsp;     *                &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt;,
<i>4642</i>&nbsp;     *                &lt;code&gt;KEEP_BASE_COMBINING&lt;/code&gt;,
<i>4643</i>&nbsp;     *                &lt;code&gt;OUTPUT_REVERSE&lt;/code&gt;,
<i>4644</i>&nbsp;     *                &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt;,
<i>4645</i>&nbsp;     *                &lt;code&gt;STREAMING&lt;/code&gt;
<i>4646</i>&nbsp;     *
<i>4647</i>&nbsp;     * @return The reordered text.
<i>4648</i>&nbsp;     *         If the &lt;code&gt;INSERT_LRM_FOR_NUMERIC&lt;/code&gt; option is set, then
<i>4649</i>&nbsp;     *         the length of the returned string could be as large as
<i>4650</i>&nbsp;     *         &lt;code&gt;getLength()+2*countRuns()&lt;/code&gt;.&lt;br&gt;
<i>4651</i>&nbsp;     *         If the &lt;code&gt;REMOVE_BIDI_CONTROLS&lt;/code&gt; option is set, then the
<i>4652</i>&nbsp;     *         length of the returned string may be less than
<i>4653</i>&nbsp;     *         &lt;code&gt;getLength()&lt;/code&gt;.&lt;br&gt;
<i>4654</i>&nbsp;     *         If none of these options is set, then the length of the returned
<i>4655</i>&nbsp;     *         string will be exactly &lt;code&gt;getProcessedLength()&lt;/code&gt;.
<i>4656</i>&nbsp;     *
<i>4657</i>&nbsp;     * @throws IllegalStateException if this call is not preceded by a successful
<i>4658</i>&nbsp;     *         call to &lt;code&gt;setPara&lt;/code&gt; or &lt;code&gt;setLine&lt;/code&gt;
<i>4659</i>&nbsp;     *
<i>4660</i>&nbsp;     * @see #DO_MIRRORING
<i>4661</i>&nbsp;     * @see #INSERT_LRM_FOR_NUMERIC
<i>4662</i>&nbsp;     * @see #KEEP_BASE_COMBINING
<i>4663</i>&nbsp;     * @see #OUTPUT_REVERSE
<i>4664</i>&nbsp;     * @see #REMOVE_BIDI_CONTROLS
<i>4665</i>&nbsp;     * @see #OPTION_STREAMING
<i>4666</i>&nbsp;     * @see #getProcessedLength
<i>4667</i>&nbsp;     * @stable ICU 3.8
<i>4668</i>&nbsp;     */
<i>4669</i>&nbsp;    public String writeReordered(int options)
<i>4670</i>&nbsp;    {
<i>4671</i>&nbsp;        verifyValidParaOrLine();
<i>4672</i>&nbsp;        if (length == 0) {
<i>4673</i>&nbsp;            /* nothing to do */
<i>4674</i>&nbsp;            return &quot;&quot;;
<i>4675</i>&nbsp;        }
<i>4676</i>&nbsp;        return BidiWriter.writeReordered(this, options);
<i>4677</i>&nbsp;    }
<i>4678</i>&nbsp;
<i>4679</i>&nbsp;    /**
<i>4680</i>&nbsp;     * Display the bidi internal state, used in debugging.
<i>4681</i>&nbsp;     */
<i>4682</i>&nbsp;    public String toString() {
<i>4683</i>&nbsp;        StringBuilder buf = new StringBuilder(getClass().getName());
<i>4684</i>&nbsp;
<i>4685</i>&nbsp;        buf.append(&quot;[dir: &quot;);
<i>4686</i>&nbsp;        buf.append(direction);
<i>4687</i>&nbsp;        buf.append(&quot; baselevel: &quot;);
<i>4688</i>&nbsp;        buf.append(paraLevel);
<i>4689</i>&nbsp;        buf.append(&quot; length: &quot;);
<i>4690</i>&nbsp;        buf.append(length);
<i>4691</i>&nbsp;        buf.append(&quot; runs: &quot;);
<i>4692</i>&nbsp;        if (levels == null) {
<i>4693</i>&nbsp;            buf.append(&quot;none&quot;);
<i>4694</i>&nbsp;        } else {
<i>4695</i>&nbsp;            buf.append(&#39;[&#39;);
<i>4696</i>&nbsp;            buf.append(levels[0]);
<i>4697</i>&nbsp;            for (int i = 1; i &lt; levels.length; i++) {
<i>4698</i>&nbsp;                buf.append(&#39; &#39;);
<i>4699</i>&nbsp;                buf.append(levels[i]);
<i>4700</i>&nbsp;            }
<i>4701</i>&nbsp;            buf.append(&#39;]&#39;);
<i>4702</i>&nbsp;        }
<i>4703</i>&nbsp;        buf.append(&quot; text: [0x&quot;);
<i>4704</i>&nbsp;        buf.append(Integer.toHexString(text[0]));
<i>4705</i>&nbsp;        for (int i = 1; i &lt; text.length; i++) {
<i>4706</i>&nbsp;            buf.append(&quot; 0x&quot;);
<i>4707</i>&nbsp;            buf.append(Integer.toHexString(text[i]));
<i>4708</i>&nbsp;        }
<i>4709</i>&nbsp;        buf.append(&quot;]]&quot;);
<i>4710</i>&nbsp;
<i>4711</i>&nbsp;        return buf.toString();
<i>4712</i>&nbsp;    }
<i>4713</i>&nbsp;
<i>4714</i>&nbsp;    /**
<i>4715</i>&nbsp;     * A class that provides access to constants defined by
<i>4716</i>&nbsp;     * java.awt.font.TextAttribute without creating a static dependency.
<i>4717</i>&nbsp;     */
<i>4718</i>&nbsp;    private static class TextAttributeConstants {
<i>4719</i>&nbsp;        // Make sure to load the AWT&#39;s TextAttribute class before using the constants, if any.
<i>4720</i>&nbsp;        static {
<i>4721</i>&nbsp;            try {
<i>4722</i>&nbsp;                Class.forName(&quot;java.awt.font.TextAttribute&quot;, true, null);
<i>4723</i>&nbsp;            } catch (ClassNotFoundException e) {}
<i>4724</i>&nbsp;        }
<i>4725</i>&nbsp;        static final JavaAWTFontAccess jafa = SharedSecrets.getJavaAWTFontAccess();
<i>4726</i>&nbsp;
<i>4727</i>&nbsp;        /**
<i>4728</i>&nbsp;         * TextAttribute instances (or a fake Attribute type if
<i>4729</i>&nbsp;         * java.awt.font.TextAttribute is not present)
<i>4730</i>&nbsp;         */
<i>4731</i>&nbsp;        static final AttributedCharacterIterator.Attribute RUN_DIRECTION =
<i>4732</i>&nbsp;            getTextAttribute(&quot;RUN_DIRECTION&quot;);
<i>4733</i>&nbsp;        static final AttributedCharacterIterator.Attribute NUMERIC_SHAPING =
<i>4734</i>&nbsp;            getTextAttribute(&quot;NUMERIC_SHAPING&quot;);
<i>4735</i>&nbsp;        static final AttributedCharacterIterator.Attribute BIDI_EMBEDDING =
<i>4736</i>&nbsp;            getTextAttribute(&quot;BIDI_EMBEDDING&quot;);
<i>4737</i>&nbsp;
<i>4738</i>&nbsp;        /**
<i>4739</i>&nbsp;         * TextAttribute.RUN_DIRECTION_LTR
<i>4740</i>&nbsp;         */
<i>4741</i>&nbsp;        static final Boolean RUN_DIRECTION_LTR = (jafa == null) ?
<i>4742</i>&nbsp;            Boolean.FALSE : (Boolean)jafa.getTextAttributeConstant(&quot;RUN_DIRECTION_LTR&quot;);
<i>4743</i>&nbsp;
<i>4744</i>&nbsp;        @SuppressWarnings(&quot;serial&quot;)
<i>4745</i>&nbsp;        private static AttributedCharacterIterator.Attribute
<i>4746</i>&nbsp;            getTextAttribute(String name)
<i>4747</i>&nbsp;        {
<i>4748</i>&nbsp;            if (jafa == null) {
<i>4749</i>&nbsp;                // fake attribute
<i>4750</i>&nbsp;                return new AttributedCharacterIterator.Attribute(name) { };
<i>4751</i>&nbsp;            } else {
<i>4752</i>&nbsp;                return (AttributedCharacterIterator.Attribute)jafa.getTextAttributeConstant(name);
<i>4753</i>&nbsp;            }
<i>4754</i>&nbsp;        }
<i>4755</i>&nbsp;    }
<i>4756</i>&nbsp;
<i>4757</i>&nbsp;    /**
<i>4758</i>&nbsp;     * A class that provides access to java.awt.font.NumericShaper without
<i>4759</i>&nbsp;     * creating a static dependency.
<i>4760</i>&nbsp;     */
<i>4761</i>&nbsp;    private static class NumericShapings {
<i>4762</i>&nbsp;        // Make sure to load the AWT&#39;s NumericShaper class before calling shape, if any.
<i>4763</i>&nbsp;        static {
<i>4764</i>&nbsp;            try {
<i>4765</i>&nbsp;                Class.forName(&quot;java.awt.font.NumericShaper&quot;, true, null);
<i>4766</i>&nbsp;            } catch (ClassNotFoundException e) {}
<i>4767</i>&nbsp;        }
<i>4768</i>&nbsp;        static final JavaAWTFontAccess jafa = SharedSecrets.getJavaAWTFontAccess();
<i>4769</i>&nbsp;
<i>4770</i>&nbsp;        /**
<i>4771</i>&nbsp;         * Invokes NumericShaping shape(text,start,count) method.
<i>4772</i>&nbsp;         */
<i>4773</i>&nbsp;        static void shape(Object shaper, char[] text, int start, int count) {
<i>4774</i>&nbsp;            if (jafa != null) {
<i>4775</i>&nbsp;                jafa.shape(shaper, text, start, count);
<i>4776</i>&nbsp;            }
<i>4777</i>&nbsp;        }
<i>4778</i>&nbsp;    }
<i>4779</i>&nbsp;
<i>4780</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
