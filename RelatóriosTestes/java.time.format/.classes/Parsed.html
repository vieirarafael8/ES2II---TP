


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Parsed</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.time.format</a> ]
</div>

<h1>Coverage Summary for Class: Parsed (java.time.format)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Parsed</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 299)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2015, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; *
<i>28</i>&nbsp; *
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *
<i>31</i>&nbsp; *
<i>32</i>&nbsp; * Copyright (c) 2008-2013, Stephen Colebourne &amp; Michael Nascimento Santos
<i>33</i>&nbsp; *
<i>34</i>&nbsp; * All rights reserved.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * Redistribution and use in source and binary forms, with or without
<i>37</i>&nbsp; * modification, are permitted provided that the following conditions are met:
<i>38</i>&nbsp; *
<i>39</i>&nbsp; *  * Redistributions of source code must retain the above copyright notice,
<i>40</i>&nbsp; *    this list of conditions and the following disclaimer.
<i>41</i>&nbsp; *
<i>42</i>&nbsp; *  * Redistributions in binary form must reproduce the above copyright notice,
<i>43</i>&nbsp; *    this list of conditions and the following disclaimer in the documentation
<i>44</i>&nbsp; *    and/or other materials provided with the distribution.
<i>45</i>&nbsp; *
<i>46</i>&nbsp; *  * Neither the name of JSR-310 nor the names of its contributors
<i>47</i>&nbsp; *    may be used to endorse or promote products derived from this software
<i>48</i>&nbsp; *    without specific prior written permission.
<i>49</i>&nbsp; *
<i>50</i>&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<i>51</i>&nbsp; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<i>52</i>&nbsp; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<i>53</i>&nbsp; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
<i>54</i>&nbsp; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<i>55</i>&nbsp; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<i>56</i>&nbsp; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<i>57</i>&nbsp; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<i>58</i>&nbsp; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<i>59</i>&nbsp; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<i>60</i>&nbsp; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<i>61</i>&nbsp; */
<i>62</i>&nbsp;package java.time.format;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import static java.time.temporal.ChronoField.AMPM_OF_DAY;
<i>65</i>&nbsp;import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_AMPM;
<i>66</i>&nbsp;import static java.time.temporal.ChronoField.CLOCK_HOUR_OF_DAY;
<i>67</i>&nbsp;import static java.time.temporal.ChronoField.HOUR_OF_AMPM;
<i>68</i>&nbsp;import static java.time.temporal.ChronoField.HOUR_OF_DAY;
<i>69</i>&nbsp;import static java.time.temporal.ChronoField.INSTANT_SECONDS;
<i>70</i>&nbsp;import static java.time.temporal.ChronoField.MICRO_OF_DAY;
<i>71</i>&nbsp;import static java.time.temporal.ChronoField.MICRO_OF_SECOND;
<i>72</i>&nbsp;import static java.time.temporal.ChronoField.MILLI_OF_DAY;
<i>73</i>&nbsp;import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
<i>74</i>&nbsp;import static java.time.temporal.ChronoField.MINUTE_OF_DAY;
<i>75</i>&nbsp;import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
<i>76</i>&nbsp;import static java.time.temporal.ChronoField.NANO_OF_DAY;
<i>77</i>&nbsp;import static java.time.temporal.ChronoField.NANO_OF_SECOND;
<i>78</i>&nbsp;import static java.time.temporal.ChronoField.OFFSET_SECONDS;
<i>79</i>&nbsp;import static java.time.temporal.ChronoField.SECOND_OF_DAY;
<i>80</i>&nbsp;import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
<i>81</i>&nbsp;
<i>82</i>&nbsp;import java.time.DateTimeException;
<i>83</i>&nbsp;import java.time.Instant;
<i>84</i>&nbsp;import java.time.LocalDate;
<i>85</i>&nbsp;import java.time.LocalTime;
<i>86</i>&nbsp;import java.time.Period;
<i>87</i>&nbsp;import java.time.ZoneId;
<i>88</i>&nbsp;import java.time.ZoneOffset;
<i>89</i>&nbsp;import java.time.chrono.ChronoLocalDate;
<i>90</i>&nbsp;import java.time.chrono.ChronoLocalDateTime;
<i>91</i>&nbsp;import java.time.chrono.ChronoZonedDateTime;
<i>92</i>&nbsp;import java.time.chrono.Chronology;
<i>93</i>&nbsp;import java.time.temporal.ChronoField;
<i>94</i>&nbsp;import java.time.temporal.TemporalAccessor;
<i>95</i>&nbsp;import java.time.temporal.TemporalField;
<i>96</i>&nbsp;import java.time.temporal.TemporalQueries;
<i>97</i>&nbsp;import java.time.temporal.TemporalQuery;
<i>98</i>&nbsp;import java.time.temporal.UnsupportedTemporalTypeException;
<i>99</i>&nbsp;import java.util.HashMap;
<i>100</i>&nbsp;import java.util.Iterator;
<i>101</i>&nbsp;import java.util.Map;
<i>102</i>&nbsp;import java.util.Map.Entry;
<i>103</i>&nbsp;import java.util.Objects;
<i>104</i>&nbsp;import java.util.Set;
<i>105</i>&nbsp;
<i>106</i>&nbsp;/**
<i>107</i>&nbsp; * A store of parsed data.
<i>108</i>&nbsp; * &lt;p&gt;
<i>109</i>&nbsp; * This class is used during parsing to collect the data. Part of the parsing process
<i>110</i>&nbsp; * involves handling optional blocks and multiple copies of the data get created to
<i>111</i>&nbsp; * support the necessary backtracking.
<i>112</i>&nbsp; * &lt;p&gt;
<i>113</i>&nbsp; * Once parsing is completed, this class can be used as the resultant {@code TemporalAccessor}.
<i>114</i>&nbsp; * In most cases, it is only exposed once the fields have been resolved.
<i>115</i>&nbsp; *
<i>116</i>&nbsp; * @implSpec
<i>117</i>&nbsp; * This class is a mutable context intended for use from a single thread.
<i>118</i>&nbsp; * Usage of the class is thread-safe within standard parsing as a new instance of this class
<i>119</i>&nbsp; * is automatically created for each parse and parsing is single-threaded
<i>120</i>&nbsp; *
<i>121</i>&nbsp; * @since 1.8
<i>122</i>&nbsp; */
<i>123</i>&nbsp;final class Parsed implements TemporalAccessor {
<i>124</i>&nbsp;    // some fields are accessed using package scope from DateTimeParseContext
<i>125</i>&nbsp;
<i>126</i>&nbsp;    /**
<i>127</i>&nbsp;     * The parsed fields.
<i>128</i>&nbsp;     */
<b class="nc"><i>129</i>&nbsp;    final Map&lt;TemporalField, Long&gt; fieldValues = new HashMap&lt;&gt;();</b>
<i>130</i>&nbsp;    /**
<i>131</i>&nbsp;     * The parsed zone.
<i>132</i>&nbsp;     */
<i>133</i>&nbsp;    ZoneId zone;
<i>134</i>&nbsp;    /**
<i>135</i>&nbsp;     * The parsed chronology.
<i>136</i>&nbsp;     */
<i>137</i>&nbsp;    Chronology chrono;
<i>138</i>&nbsp;    /**
<i>139</i>&nbsp;     * Whether a leap-second is parsed.
<i>140</i>&nbsp;     */
<i>141</i>&nbsp;    boolean leapSecond;
<i>142</i>&nbsp;    /**
<i>143</i>&nbsp;     * The resolver style to use.
<i>144</i>&nbsp;     */
<i>145</i>&nbsp;    private ResolverStyle resolverStyle;
<i>146</i>&nbsp;    /**
<i>147</i>&nbsp;     * The resolved date.
<i>148</i>&nbsp;     */
<i>149</i>&nbsp;    private ChronoLocalDate date;
<i>150</i>&nbsp;    /**
<i>151</i>&nbsp;     * The resolved time.
<i>152</i>&nbsp;     */
<i>153</i>&nbsp;    private LocalTime time;
<i>154</i>&nbsp;    /**
<i>155</i>&nbsp;     * The excess period from time-only parsing.
<i>156</i>&nbsp;     */
<b class="nc"><i>157</i>&nbsp;    Period excessDays = Period.ZERO;</b>
<i>158</i>&nbsp;
<i>159</i>&nbsp;    /**
<i>160</i>&nbsp;     * Creates an instance.
<i>161</i>&nbsp;     */
<b class="nc"><i>162</i>&nbsp;    Parsed() {</b>
<i>163</i>&nbsp;    }
<i>164</i>&nbsp;
<i>165</i>&nbsp;    /**
<i>166</i>&nbsp;     * Creates a copy.
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    Parsed copy() {
<i>169</i>&nbsp;        // only copy fields used in parsing stage
<b class="nc"><i>170</i>&nbsp;        Parsed cloned = new Parsed();</b>
<b class="nc"><i>171</i>&nbsp;        cloned.fieldValues.putAll(this.fieldValues);</b>
<b class="nc"><i>172</i>&nbsp;        cloned.zone = this.zone;</b>
<b class="nc"><i>173</i>&nbsp;        cloned.chrono = this.chrono;</b>
<b class="nc"><i>174</i>&nbsp;        cloned.leapSecond = this.leapSecond;</b>
<b class="nc"><i>175</i>&nbsp;        return cloned;</b>
<i>176</i>&nbsp;    }
<i>177</i>&nbsp;
<i>178</i>&nbsp;    //-----------------------------------------------------------------------
<i>179</i>&nbsp;    @Override
<i>180</i>&nbsp;    public boolean isSupported(TemporalField field) {
<b class="nc"><i>181</i>&nbsp;        if (fieldValues.containsKey(field) ||</b>
<b class="nc"><i>182</i>&nbsp;                (date != null &amp;&amp; date.isSupported(field)) ||</b>
<b class="nc"><i>183</i>&nbsp;                (time != null &amp;&amp; time.isSupported(field))) {</b>
<b class="nc"><i>184</i>&nbsp;            return true;</b>
<i>185</i>&nbsp;        }
<b class="nc"><i>186</i>&nbsp;        return field != null &amp;&amp; (field instanceof ChronoField == false) &amp;&amp; field.isSupportedBy(this);</b>
<i>187</i>&nbsp;    }
<i>188</i>&nbsp;
<i>189</i>&nbsp;    @Override
<i>190</i>&nbsp;    public long getLong(TemporalField field) {
<b class="nc"><i>191</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);</b>
<b class="nc"><i>192</i>&nbsp;        Long value = fieldValues.get(field);</b>
<b class="nc"><i>193</i>&nbsp;        if (value != null) {</b>
<b class="nc"><i>194</i>&nbsp;            return value;</b>
<i>195</i>&nbsp;        }
<b class="nc"><i>196</i>&nbsp;        if (date != null &amp;&amp; date.isSupported(field)) {</b>
<b class="nc"><i>197</i>&nbsp;            return date.getLong(field);</b>
<i>198</i>&nbsp;        }
<b class="nc"><i>199</i>&nbsp;        if (time != null &amp;&amp; time.isSupported(field)) {</b>
<b class="nc"><i>200</i>&nbsp;            return time.getLong(field);</b>
<i>201</i>&nbsp;        }
<b class="nc"><i>202</i>&nbsp;        if (field instanceof ChronoField) {</b>
<b class="nc"><i>203</i>&nbsp;            throw new UnsupportedTemporalTypeException(&quot;Unsupported field: &quot; + field);</b>
<i>204</i>&nbsp;        }
<b class="nc"><i>205</i>&nbsp;        return field.getFrom(this);</b>
<i>206</i>&nbsp;    }
<i>207</i>&nbsp;
<i>208</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>209</i>&nbsp;    @Override
<i>210</i>&nbsp;    public &lt;R&gt; R query(TemporalQuery&lt;R&gt; query) {
<b class="nc"><i>211</i>&nbsp;        if (query == TemporalQueries.zoneId()) {</b>
<b class="nc"><i>212</i>&nbsp;            return (R) zone;</b>
<b class="nc"><i>213</i>&nbsp;        } else if (query == TemporalQueries.chronology()) {</b>
<b class="nc"><i>214</i>&nbsp;            return (R) chrono;</b>
<b class="nc"><i>215</i>&nbsp;        } else if (query == TemporalQueries.localDate()) {</b>
<b class="nc"><i>216</i>&nbsp;            return (R) (date != null ? LocalDate.from(date) : null);</b>
<b class="nc"><i>217</i>&nbsp;        } else if (query == TemporalQueries.localTime()) {</b>
<b class="nc"><i>218</i>&nbsp;            return (R) time;</b>
<b class="nc"><i>219</i>&nbsp;        } else if (query == TemporalQueries.offset()) {</b>
<b class="nc"><i>220</i>&nbsp;            Long offsetSecs = fieldValues.get(OFFSET_SECONDS);</b>
<b class="nc"><i>221</i>&nbsp;            if (offsetSecs != null) {</b>
<b class="nc"><i>222</i>&nbsp;                return (R) ZoneOffset.ofTotalSeconds(offsetSecs.intValue());</b>
<i>223</i>&nbsp;            }
<i>224</i>&nbsp;            if (zone instanceof ZoneOffset) {
<i>225</i>&nbsp;                return (R)zone;
<b class="nc"><i>226</i>&nbsp;            }</b>
<i>227</i>&nbsp;            return query.queryFrom(this);
<i>228</i>&nbsp;        } else if (query == TemporalQueries.zone()) {
<i>229</i>&nbsp;            return query.queryFrom(this);
<i>230</i>&nbsp;        } else if (query == TemporalQueries.precision()) {
<i>231</i>&nbsp;            return null;  // not a complete date/time
<i>232</i>&nbsp;        }
<i>233</i>&nbsp;        // inline TemporalAccessor.super.query(query) as an optimization
<i>234</i>&nbsp;        // non-JDK classes are not permitted to make this optimization
<i>235</i>&nbsp;        return query.queryFrom(this);
<i>236</i>&nbsp;    }
<i>237</i>&nbsp;
<i>238</i>&nbsp;    //-----------------------------------------------------------------------
<i>239</i>&nbsp;    /**
<b class="nc"><i>240</i>&nbsp;     * Resolves the fields in this context.</b>
<b class="nc"><i>241</i>&nbsp;     *</b>
<i>242</i>&nbsp;     * @param resolverStyle  the resolver style, not null
<b class="nc"><i>243</i>&nbsp;     * @param resolverFields  the fields to use for resolving, null for all fields</b>
<b class="nc"><i>244</i>&nbsp;     * @return this, for method chaining</b>
<b class="nc"><i>245</i>&nbsp;     * @throws DateTimeException if resolving one field results in a value for</b>
<b class="nc"><i>246</i>&nbsp;     *  another field that is in conflict</b>
<b class="nc"><i>247</i>&nbsp;     */</b>
<b class="nc"><i>248</i>&nbsp;    TemporalAccessor resolve(ResolverStyle resolverStyle, Set&lt;TemporalField&gt; resolverFields) {</b>
<b class="nc"><i>249</i>&nbsp;        if (resolverFields != null) {</b>
<b class="nc"><i>250</i>&nbsp;            fieldValues.keySet().retainAll(resolverFields);</b>
<i>251</i>&nbsp;        }
<i>252</i>&nbsp;        this.resolverStyle = resolverStyle;
<i>253</i>&nbsp;        resolveFields();
<i>254</i>&nbsp;        resolveTimeLenient();
<i>255</i>&nbsp;        crossCheck();
<b class="nc"><i>256</i>&nbsp;        resolvePeriod();</b>
<b class="nc"><i>257</i>&nbsp;        resolveFractional();</b>
<b class="nc"><i>258</i>&nbsp;        resolveInstant();</b>
<i>259</i>&nbsp;        return this;
<i>260</i>&nbsp;    }
<i>261</i>&nbsp;
<b class="nc"><i>262</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>263</i>&nbsp;    private void resolveFields() {</b>
<i>264</i>&nbsp;        // resolve ChronoField
<b class="nc"><i>265</i>&nbsp;        resolveInstantFields();</b>
<b class="nc"><i>266</i>&nbsp;        resolveDateFields();</b>
<b class="nc"><i>267</i>&nbsp;        resolveTimeFields();</b>
<b class="nc"><i>268</i>&nbsp;</b>
<b class="nc"><i>269</i>&nbsp;        // if any other fields, handle them</b>
<b class="nc"><i>270</i>&nbsp;        // any lenient date resolution should return epoch-day</b>
<b class="nc"><i>271</i>&nbsp;        if (fieldValues.size() &gt; 0) {</b>
<b class="nc"><i>272</i>&nbsp;            int changedCount = 0;</b>
<b class="nc"><i>273</i>&nbsp;            outer:</b>
<b class="nc"><i>274</i>&nbsp;            while (changedCount &lt; 50) {</b>
<b class="nc"><i>275</i>&nbsp;                for (Map.Entry&lt;TemporalField, Long&gt; entry : fieldValues.entrySet()) {</b>
<i>276</i>&nbsp;                    TemporalField targetField = entry.getKey();
<b class="nc"><i>277</i>&nbsp;                    TemporalAccessor resolvedObject = targetField.resolve(fieldValues, this, resolverStyle);</b>
<i>278</i>&nbsp;                    if (resolvedObject != null) {
<b class="nc"><i>279</i>&nbsp;                        if (resolvedObject instanceof ChronoZonedDateTime) {</b>
<b class="nc"><i>280</i>&nbsp;                            ChronoZonedDateTime&lt;?&gt; czdt = (ChronoZonedDateTime&lt;?&gt;) resolvedObject;</b>
<b class="nc"><i>281</i>&nbsp;                            if (zone == null) {</b>
<b class="nc"><i>282</i>&nbsp;                                zone = czdt.getZone();</b>
<b class="nc"><i>283</i>&nbsp;                            } else if (zone.equals(czdt.getZone()) == false) {</b>
<b class="nc"><i>284</i>&nbsp;                                throw new DateTimeException(&quot;ChronoZonedDateTime must use the effective parsed zone: &quot; + zone);</b>
<i>285</i>&nbsp;                            }
<b class="nc"><i>286</i>&nbsp;                            resolvedObject = czdt.toLocalDateTime();</b>
<b class="nc"><i>287</i>&nbsp;                        }</b>
<b class="nc"><i>288</i>&nbsp;                        if (resolvedObject instanceof ChronoLocalDateTime) {</b>
<b class="nc"><i>289</i>&nbsp;                            ChronoLocalDateTime&lt;?&gt; cldt = (ChronoLocalDateTime&lt;?&gt;) resolvedObject;</b>
<i>290</i>&nbsp;                            updateCheckConflict(cldt.toLocalTime(), Period.ZERO);
<b class="nc"><i>291</i>&nbsp;                            updateCheckConflict(cldt.toLocalDate());</b>
<b class="nc"><i>292</i>&nbsp;                            changedCount++;</b>
<b class="nc"><i>293</i>&nbsp;                            continue outer;  // have to restart to avoid concurrent modification</b>
<b class="nc"><i>294</i>&nbsp;                        }</b>
<i>295</i>&nbsp;                        if (resolvedObject instanceof ChronoLocalDate) {
<b class="nc"><i>296</i>&nbsp;                            updateCheckConflict((ChronoLocalDate) resolvedObject);</b>
<i>297</i>&nbsp;                            changedCount++;
<b class="nc"><i>298</i>&nbsp;                            continue outer;  // have to restart to avoid concurrent modification</b>
<b class="nc"><i>299</i>&nbsp;                        }</b>
<b class="nc"><i>300</i>&nbsp;                        if (resolvedObject instanceof LocalTime) {</b>
<i>301</i>&nbsp;                            updateCheckConflict((LocalTime) resolvedObject, Period.ZERO);
<b class="nc"><i>302</i>&nbsp;                            changedCount++;</b>
<b class="nc"><i>303</i>&nbsp;                            continue outer;  // have to restart to avoid concurrent modification</b>
<i>304</i>&nbsp;                        }
<b class="nc"><i>305</i>&nbsp;                        throw new DateTimeException(&quot;Method resolve() can only return ChronoZonedDateTime, &quot; +</b>
<b class="nc"><i>306</i>&nbsp;                                &quot;ChronoLocalDateTime, ChronoLocalDate or LocalTime&quot;);</b>
<i>307</i>&nbsp;                    } else if (fieldValues.containsKey(targetField) == false) {
<i>308</i>&nbsp;                        changedCount++;
<b class="nc"><i>309</i>&nbsp;                        continue outer;  // have to restart to avoid concurrent modification</b>
<b class="nc"><i>310</i>&nbsp;                    }</b>
<b class="nc"><i>311</i>&nbsp;                }</b>
<b class="nc"><i>312</i>&nbsp;                break;</b>
<i>313</i>&nbsp;            }
<i>314</i>&nbsp;            if (changedCount == 50) {  // catch infinite loops
<i>315</i>&nbsp;                throw new DateTimeException(&quot;One of the parsed fields has an incorrectly implemented resolve method&quot;);
<i>316</i>&nbsp;            }
<i>317</i>&nbsp;            // if something changed then have to redo ChronoField resolve
<b class="nc"><i>318</i>&nbsp;            if (changedCount &gt; 0) {</b>
<b class="nc"><i>319</i>&nbsp;                resolveInstantFields();</b>
<b class="nc"><i>320</i>&nbsp;                resolveDateFields();</b>
<i>321</i>&nbsp;                resolveTimeFields();
<i>322</i>&nbsp;            }
<i>323</i>&nbsp;        }
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;
<i>326</i>&nbsp;    private void updateCheckConflict(TemporalField targetField, TemporalField changeField, Long changeValue) {
<i>327</i>&nbsp;        Long old = fieldValues.put(changeField, changeValue);
<i>328</i>&nbsp;        if (old != null &amp;&amp; old.longValue() != changeValue.longValue()) {
<b class="nc"><i>329</i>&nbsp;            throw new DateTimeException(&quot;Conflict found: &quot; + changeField + &quot; &quot; + old +</b>
<b class="nc"><i>330</i>&nbsp;                    &quot; differs from &quot; + changeField + &quot; &quot; + changeValue +</b>
<b class="nc"><i>331</i>&nbsp;                    &quot; while resolving  &quot; + targetField);</b>
<i>332</i>&nbsp;        }
<b class="nc"><i>333</i>&nbsp;    }</b>
<b class="nc"><i>334</i>&nbsp;</b>
<b class="nc"><i>335</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>336</i>&nbsp;    private void resolveInstantFields() {</b>
<i>337</i>&nbsp;        // resolve parsed instant seconds to date and time if zone available
<i>338</i>&nbsp;        if (fieldValues.containsKey(INSTANT_SECONDS)) {
<i>339</i>&nbsp;            if (zone != null) {
<i>340</i>&nbsp;                resolveInstantFields0(zone);
<i>341</i>&nbsp;            } else {
<i>342</i>&nbsp;                Long offsetSecs = fieldValues.get(OFFSET_SECONDS);
<b class="nc"><i>343</i>&nbsp;                if (offsetSecs != null) {</b>
<b class="nc"><i>344</i>&nbsp;                    ZoneOffset offset = ZoneOffset.ofTotalSeconds(offsetSecs.intValue());</b>
<b class="nc"><i>345</i>&nbsp;                    resolveInstantFields0(offset);</b>
<b class="nc"><i>346</i>&nbsp;                }</b>
<i>347</i>&nbsp;            }
<i>348</i>&nbsp;        }
<i>349</i>&nbsp;    }
<i>350</i>&nbsp;
<b class="nc"><i>351</i>&nbsp;    private void resolveInstantFields0(ZoneId selectedZone) {</b>
<i>352</i>&nbsp;        Instant instant = Instant.ofEpochSecond(fieldValues.remove(INSTANT_SECONDS));
<i>353</i>&nbsp;        ChronoZonedDateTime&lt;?&gt; zdt = chrono.zonedDateTime(instant, selectedZone);
<i>354</i>&nbsp;        updateCheckConflict(zdt.toLocalDate());
<b class="nc"><i>355</i>&nbsp;        updateCheckConflict(INSTANT_SECONDS, SECOND_OF_DAY, (long) zdt.toLocalTime().toSecondOfDay());</b>
<b class="nc"><i>356</i>&nbsp;    }</b>
<b class="nc"><i>357</i>&nbsp;</b>
<i>358</i>&nbsp;    //-----------------------------------------------------------------------
<b class="nc"><i>359</i>&nbsp;    private void resolveDateFields() {</b>
<b class="nc"><i>360</i>&nbsp;        updateCheckConflict(chrono.resolveDate(fieldValues, resolverStyle));</b>
<b class="nc"><i>361</i>&nbsp;    }</b>
<i>362</i>&nbsp;
<b class="nc"><i>363</i>&nbsp;    private void updateCheckConflict(ChronoLocalDate cld) {</b>
<i>364</i>&nbsp;        if (date != null) {
<i>365</i>&nbsp;            if (cld != null &amp;&amp; date.equals(cld) == false) {
<i>366</i>&nbsp;                throw new DateTimeException(&quot;Conflict found: Fields resolved to two different dates: &quot; + date + &quot; &quot; + cld);
<i>367</i>&nbsp;            }
<i>368</i>&nbsp;        } else if (cld != null) {
<i>369</i>&nbsp;            if (chrono.equals(cld.getChronology()) == false) {
<b class="nc"><i>370</i>&nbsp;                throw new DateTimeException(&quot;ChronoLocalDate must use the effective parsed chronology: &quot; + chrono);</b>
<i>371</i>&nbsp;            }
<b class="nc"><i>372</i>&nbsp;            date = cld;</b>
<b class="nc"><i>373</i>&nbsp;        }</b>
<b class="nc"><i>374</i>&nbsp;    }</b>
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>377</i>&nbsp;    private void resolveTimeFields() {
<b class="nc"><i>378</i>&nbsp;        // simplify fields</b>
<i>379</i>&nbsp;        if (fieldValues.containsKey(CLOCK_HOUR_OF_DAY)) {
<b class="nc"><i>380</i>&nbsp;            // lenient allows anything, smart allows 0-24, strict allows 1-24</b>
<b class="nc"><i>381</i>&nbsp;            long ch = fieldValues.remove(CLOCK_HOUR_OF_DAY);</b>
<b class="nc"><i>382</i>&nbsp;            if (resolverStyle == ResolverStyle.STRICT || (resolverStyle == ResolverStyle.SMART &amp;&amp; ch != 0)) {</b>
<i>383</i>&nbsp;                CLOCK_HOUR_OF_DAY.checkValidValue(ch);
<b class="nc"><i>384</i>&nbsp;            }</b>
<i>385</i>&nbsp;            updateCheckConflict(CLOCK_HOUR_OF_DAY, HOUR_OF_DAY, ch == 24 ? 0 : ch);
<b class="nc"><i>386</i>&nbsp;        }</b>
<b class="nc"><i>387</i>&nbsp;        if (fieldValues.containsKey(CLOCK_HOUR_OF_AMPM)) {</b>
<b class="nc"><i>388</i>&nbsp;            // lenient allows anything, smart allows 0-12, strict allows 1-12</b>
<b class="nc"><i>389</i>&nbsp;            long ch = fieldValues.remove(CLOCK_HOUR_OF_AMPM);</b>
<b class="nc"><i>390</i>&nbsp;            if (resolverStyle == ResolverStyle.STRICT || (resolverStyle == ResolverStyle.SMART &amp;&amp; ch != 0)) {</b>
<i>391</i>&nbsp;                CLOCK_HOUR_OF_AMPM.checkValidValue(ch);
<b class="nc"><i>392</i>&nbsp;            }</b>
<b class="nc"><i>393</i>&nbsp;            updateCheckConflict(CLOCK_HOUR_OF_AMPM, HOUR_OF_AMPM, ch == 12 ? 0 : ch);</b>
<b class="nc"><i>394</i>&nbsp;        }</b>
<i>395</i>&nbsp;        if (fieldValues.containsKey(AMPM_OF_DAY) &amp;&amp; fieldValues.containsKey(HOUR_OF_AMPM)) {
<i>396</i>&nbsp;            long ap = fieldValues.remove(AMPM_OF_DAY);
<b class="nc"><i>397</i>&nbsp;            long hap = fieldValues.remove(HOUR_OF_AMPM);</b>
<b class="nc"><i>398</i>&nbsp;            if (resolverStyle == ResolverStyle.LENIENT) {</b>
<b class="nc"><i>399</i>&nbsp;                updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, Math.addExact(Math.multiplyExact(ap, 12), hap));</b>
<b class="nc"><i>400</i>&nbsp;            } else {  // STRICT or SMART</b>
<i>401</i>&nbsp;                AMPM_OF_DAY.checkValidValue(ap);
<b class="nc"><i>402</i>&nbsp;                HOUR_OF_AMPM.checkValidValue(ap);</b>
<b class="nc"><i>403</i>&nbsp;                updateCheckConflict(AMPM_OF_DAY, HOUR_OF_DAY, ap * 12 + hap);</b>
<b class="nc"><i>404</i>&nbsp;            }</b>
<b class="nc"><i>405</i>&nbsp;        }</b>
<i>406</i>&nbsp;        if (fieldValues.containsKey(NANO_OF_DAY)) {
<b class="nc"><i>407</i>&nbsp;            long nod = fieldValues.remove(NANO_OF_DAY);</b>
<b class="nc"><i>408</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<b class="nc"><i>409</i>&nbsp;                NANO_OF_DAY.checkValidValue(nod);</b>
<b class="nc"><i>410</i>&nbsp;            }</b>
<i>411</i>&nbsp;            updateCheckConflict(NANO_OF_DAY, HOUR_OF_DAY, nod / 3600_000_000_000L);
<b class="nc"><i>412</i>&nbsp;            updateCheckConflict(NANO_OF_DAY, MINUTE_OF_HOUR, (nod / 60_000_000_000L) % 60);</b>
<b class="nc"><i>413</i>&nbsp;            updateCheckConflict(NANO_OF_DAY, SECOND_OF_MINUTE, (nod / 1_000_000_000L) % 60);</b>
<i>414</i>&nbsp;            updateCheckConflict(NANO_OF_DAY, NANO_OF_SECOND, nod % 1_000_000_000L);
<b class="nc"><i>415</i>&nbsp;        }</b>
<b class="nc"><i>416</i>&nbsp;        if (fieldValues.containsKey(MICRO_OF_DAY)) {</b>
<b class="nc"><i>417</i>&nbsp;            long cod = fieldValues.remove(MICRO_OF_DAY);</b>
<b class="nc"><i>418</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<i>419</i>&nbsp;                MICRO_OF_DAY.checkValidValue(cod);
<b class="nc"><i>420</i>&nbsp;            }</b>
<b class="nc"><i>421</i>&nbsp;            updateCheckConflict(MICRO_OF_DAY, SECOND_OF_DAY, cod / 1_000_000L);</b>
<i>422</i>&nbsp;            updateCheckConflict(MICRO_OF_DAY, MICRO_OF_SECOND, cod % 1_000_000L);
<b class="nc"><i>423</i>&nbsp;        }</b>
<b class="nc"><i>424</i>&nbsp;        if (fieldValues.containsKey(MILLI_OF_DAY)) {</b>
<b class="nc"><i>425</i>&nbsp;            long lod = fieldValues.remove(MILLI_OF_DAY);</b>
<b class="nc"><i>426</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<i>427</i>&nbsp;                MILLI_OF_DAY.checkValidValue(lod);
<b class="nc"><i>428</i>&nbsp;            }</b>
<b class="nc"><i>429</i>&nbsp;            updateCheckConflict(MILLI_OF_DAY, SECOND_OF_DAY, lod / 1_000);</b>
<b class="nc"><i>430</i>&nbsp;            updateCheckConflict(MILLI_OF_DAY, MILLI_OF_SECOND, lod % 1_000);</b>
<i>431</i>&nbsp;        }
<b class="nc"><i>432</i>&nbsp;        if (fieldValues.containsKey(SECOND_OF_DAY)) {</b>
<b class="nc"><i>433</i>&nbsp;            long sod = fieldValues.remove(SECOND_OF_DAY);</b>
<b class="nc"><i>434</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<b class="nc"><i>435</i>&nbsp;                SECOND_OF_DAY.checkValidValue(sod);</b>
<i>436</i>&nbsp;            }
<b class="nc"><i>437</i>&nbsp;            updateCheckConflict(SECOND_OF_DAY, HOUR_OF_DAY, sod / 3600);</b>
<b class="nc"><i>438</i>&nbsp;            updateCheckConflict(SECOND_OF_DAY, MINUTE_OF_HOUR, (sod / 60) % 60);</b>
<i>439</i>&nbsp;            updateCheckConflict(SECOND_OF_DAY, SECOND_OF_MINUTE, sod % 60);
<i>440</i>&nbsp;        }
<i>441</i>&nbsp;        if (fieldValues.containsKey(MINUTE_OF_DAY)) {
<b class="nc"><i>442</i>&nbsp;            long mod = fieldValues.remove(MINUTE_OF_DAY);</b>
<b class="nc"><i>443</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<b class="nc"><i>444</i>&nbsp;                MINUTE_OF_DAY.checkValidValue(mod);</b>
<b class="nc"><i>445</i>&nbsp;            }</b>
<i>446</i>&nbsp;            updateCheckConflict(MINUTE_OF_DAY, HOUR_OF_DAY, mod / 60);
<b class="nc"><i>447</i>&nbsp;            updateCheckConflict(MINUTE_OF_DAY, MINUTE_OF_HOUR, mod % 60);</b>
<b class="nc"><i>448</i>&nbsp;        }</b>
<b class="nc"><i>449</i>&nbsp;</b>
<b class="nc"><i>450</i>&nbsp;        // combine partial second fields strictly, leaving lenient expansion to later</b>
<i>451</i>&nbsp;        if (fieldValues.containsKey(NANO_OF_SECOND)) {
<b class="nc"><i>452</i>&nbsp;            long nos = fieldValues.get(NANO_OF_SECOND);</b>
<b class="nc"><i>453</i>&nbsp;            if (resolverStyle != ResolverStyle.LENIENT) {</b>
<i>454</i>&nbsp;                NANO_OF_SECOND.checkValidValue(nos);
<b class="nc"><i>455</i>&nbsp;            }</b>
<b class="nc"><i>456</i>&nbsp;            if (fieldValues.containsKey(MICRO_OF_SECOND)) {</b>
<b class="nc"><i>457</i>&nbsp;                long cos = fieldValues.remove(MICRO_OF_SECOND);</b>
<b class="nc"><i>458</i>&nbsp;                if (resolverStyle != ResolverStyle.LENIENT) {</b>
<i>459</i>&nbsp;                    MICRO_OF_SECOND.checkValidValue(cos);
<b class="nc"><i>460</i>&nbsp;                }</b>
<i>461</i>&nbsp;                nos = cos * 1000 + (nos % 1000);
<i>462</i>&nbsp;                updateCheckConflict(MICRO_OF_SECOND, NANO_OF_SECOND, nos);
<i>463</i>&nbsp;            }
<i>464</i>&nbsp;            if (fieldValues.containsKey(MILLI_OF_SECOND)) {
<b class="nc"><i>465</i>&nbsp;                long los = fieldValues.remove(MILLI_OF_SECOND);</b>
<b class="nc"><i>466</i>&nbsp;                if (resolverStyle != ResolverStyle.LENIENT) {</b>
<b class="nc"><i>467</i>&nbsp;                    MILLI_OF_SECOND.checkValidValue(los);</b>
<b class="nc"><i>468</i>&nbsp;                }</b>
<b class="nc"><i>469</i>&nbsp;                updateCheckConflict(MILLI_OF_SECOND, NANO_OF_SECOND, los * 1_000_000L + (nos % 1_000_000L));</b>
<b class="nc"><i>470</i>&nbsp;            }</b>
<b class="nc"><i>471</i>&nbsp;        }</b>
<i>472</i>&nbsp;
<i>473</i>&nbsp;        // convert to time if all four fields available (optimization)
<i>474</i>&nbsp;        if (fieldValues.containsKey(HOUR_OF_DAY) &amp;&amp; fieldValues.containsKey(MINUTE_OF_HOUR) &amp;&amp;
<i>475</i>&nbsp;                fieldValues.containsKey(SECOND_OF_MINUTE) &amp;&amp; fieldValues.containsKey(NANO_OF_SECOND)) {
<i>476</i>&nbsp;            long hod = fieldValues.remove(HOUR_OF_DAY);
<i>477</i>&nbsp;            long moh = fieldValues.remove(MINUTE_OF_HOUR);
<i>478</i>&nbsp;            long som = fieldValues.remove(SECOND_OF_MINUTE);
<i>479</i>&nbsp;            long nos = fieldValues.remove(NANO_OF_SECOND);
<b class="nc"><i>480</i>&nbsp;            resolveTime(hod, moh, som, nos);</b>
<i>481</i>&nbsp;        }
<b class="nc"><i>482</i>&nbsp;    }</b>
<b class="nc"><i>483</i>&nbsp;</b>
<b class="nc"><i>484</i>&nbsp;    private void resolveTimeLenient() {</b>
<i>485</i>&nbsp;        // leniently create a time from incomplete information
<b class="nc"><i>486</i>&nbsp;        // done after everything else as it creates information from nothing</b>
<b class="nc"><i>487</i>&nbsp;        // which would break updateCheckConflict(field)</b>
<b class="nc"><i>488</i>&nbsp;</b>
<b class="nc"><i>489</i>&nbsp;        if (time == null) {</b>
<b class="nc"><i>490</i>&nbsp;            // NANO_OF_SECOND merged with MILLI/MICRO above</b>
<i>491</i>&nbsp;            if (fieldValues.containsKey(MILLI_OF_SECOND)) {
<b class="nc"><i>492</i>&nbsp;                long los = fieldValues.remove(MILLI_OF_SECOND);</b>
<i>493</i>&nbsp;                if (fieldValues.containsKey(MICRO_OF_SECOND)) {
<b class="nc"><i>494</i>&nbsp;                    // merge milli-of-second and micro-of-second for better error message</b>
<i>495</i>&nbsp;                    long cos = los * 1_000 + (fieldValues.get(MICRO_OF_SECOND) % 1_000);
<b class="nc"><i>496</i>&nbsp;                    updateCheckConflict(MILLI_OF_SECOND, MICRO_OF_SECOND, cos);</b>
<b class="nc"><i>497</i>&nbsp;                    fieldValues.remove(MICRO_OF_SECOND);</b>
<i>498</i>&nbsp;                    fieldValues.put(NANO_OF_SECOND, cos * 1_000L);
<i>499</i>&nbsp;                } else {
<i>500</i>&nbsp;                    // convert milli-of-second to nano-of-second
<b class="nc"><i>501</i>&nbsp;                    fieldValues.put(NANO_OF_SECOND, los * 1_000_000L);</b>
<b class="nc"><i>502</i>&nbsp;                }</b>
<b class="nc"><i>503</i>&nbsp;            } else if (fieldValues.containsKey(MICRO_OF_SECOND)) {</b>
<b class="nc"><i>504</i>&nbsp;                // convert micro-of-second to nano-of-second</b>
<b class="nc"><i>505</i>&nbsp;                long cos = fieldValues.remove(MICRO_OF_SECOND);</b>
<i>506</i>&nbsp;                fieldValues.put(NANO_OF_SECOND, cos * 1_000L);
<i>507</i>&nbsp;            }
<b class="nc"><i>508</i>&nbsp;</b>
<i>509</i>&nbsp;            // merge hour/minute/second/nano leniently
<i>510</i>&nbsp;            Long hod = fieldValues.get(HOUR_OF_DAY);
<i>511</i>&nbsp;            if (hod != null) {
<i>512</i>&nbsp;                Long moh = fieldValues.get(MINUTE_OF_HOUR);
<i>513</i>&nbsp;                Long som = fieldValues.get(SECOND_OF_MINUTE);
<b class="nc"><i>514</i>&nbsp;                Long nos = fieldValues.get(NANO_OF_SECOND);</b>
<b class="nc"><i>515</i>&nbsp;</b>
<b class="nc"><i>516</i>&nbsp;                // check for invalid combinations that cannot be defaulted</b>
<b class="nc"><i>517</i>&nbsp;                if ((moh == null &amp;&amp; (som != null || nos != null)) ||</b>
<b class="nc"><i>518</i>&nbsp;                        (moh != null &amp;&amp; som == null &amp;&amp; nos != null)) {</b>
<b class="nc"><i>519</i>&nbsp;                    return;</b>
<b class="nc"><i>520</i>&nbsp;                }</b>
<b class="nc"><i>521</i>&nbsp;</b>
<i>522</i>&nbsp;                // default as necessary and build time
<i>523</i>&nbsp;                long mohVal = (moh != null ? moh : 0);
<i>524</i>&nbsp;                long somVal = (som != null ? som : 0);
<i>525</i>&nbsp;                long nosVal = (nos != null ? nos : 0);
<b class="nc"><i>526</i>&nbsp;                resolveTime(hod, mohVal, somVal, nosVal);</b>
<b class="nc"><i>527</i>&nbsp;                fieldValues.remove(HOUR_OF_DAY);</b>
<b class="nc"><i>528</i>&nbsp;                fieldValues.remove(MINUTE_OF_HOUR);</b>
<b class="nc"><i>529</i>&nbsp;                fieldValues.remove(SECOND_OF_MINUTE);</b>
<b class="nc"><i>530</i>&nbsp;                fieldValues.remove(NANO_OF_SECOND);</b>
<i>531</i>&nbsp;            }
<b class="nc"><i>532</i>&nbsp;        }</b>
<i>533</i>&nbsp;
<i>534</i>&nbsp;        // validate remaining
<i>535</i>&nbsp;        if (resolverStyle != ResolverStyle.LENIENT &amp;&amp; fieldValues.size() &gt; 0) {
<i>536</i>&nbsp;            for (Entry&lt;TemporalField, Long&gt; entry : fieldValues.entrySet()) {
<b class="nc"><i>537</i>&nbsp;                TemporalField field = entry.getKey();</b>
<b class="nc"><i>538</i>&nbsp;                if (field instanceof ChronoField &amp;&amp; field.isTimeBased()) {</b>
<b class="nc"><i>539</i>&nbsp;                    ((ChronoField) field).checkValidValue(entry.getValue());</b>
<b class="nc"><i>540</i>&nbsp;                }</b>
<b class="nc"><i>541</i>&nbsp;            }</b>
<b class="nc"><i>542</i>&nbsp;        }</b>
<b class="nc"><i>543</i>&nbsp;    }</b>
<b class="nc"><i>544</i>&nbsp;</b>
<b class="nc"><i>545</i>&nbsp;    private void resolveTime(long hod, long moh, long som, long nos) {</b>
<b class="nc"><i>546</i>&nbsp;        if (resolverStyle == ResolverStyle.LENIENT) {</b>
<b class="nc"><i>547</i>&nbsp;            long totalNanos = Math.multiplyExact(hod, 3600_000_000_000L);</b>
<i>548</i>&nbsp;            totalNanos = Math.addExact(totalNanos, Math.multiplyExact(moh, 60_000_000_000L));
<b class="nc"><i>549</i>&nbsp;            totalNanos = Math.addExact(totalNanos, Math.multiplyExact(som, 1_000_000_000L));</b>
<b class="nc"><i>550</i>&nbsp;            totalNanos = Math.addExact(totalNanos, nos);</b>
<i>551</i>&nbsp;            int excessDays = (int) Math.floorDiv(totalNanos, 86400_000_000_000L);  // safe int cast
<b class="nc"><i>552</i>&nbsp;            long nod = Math.floorMod(totalNanos, 86400_000_000_000L);</b>
<b class="nc"><i>553</i>&nbsp;            updateCheckConflict(LocalTime.ofNanoOfDay(nod), Period.ofDays(excessDays));</b>
<b class="nc"><i>554</i>&nbsp;        } else {  // STRICT or SMART</b>
<i>555</i>&nbsp;            int mohVal = MINUTE_OF_HOUR.checkValidIntValue(moh);
<i>556</i>&nbsp;            int nosVal = NANO_OF_SECOND.checkValidIntValue(nos);
<i>557</i>&nbsp;            // handle 24:00 end of day
<i>558</i>&nbsp;            if (resolverStyle == ResolverStyle.SMART &amp;&amp; hod == 24 &amp;&amp; mohVal == 0 &amp;&amp; som == 0 &amp;&amp; nosVal == 0) {
<i>559</i>&nbsp;                updateCheckConflict(LocalTime.MIDNIGHT, Period.ofDays(1));
<i>560</i>&nbsp;            } else {
<b class="nc"><i>561</i>&nbsp;                int hodVal = HOUR_OF_DAY.checkValidIntValue(hod);</b>
<b class="nc"><i>562</i>&nbsp;                int somVal = SECOND_OF_MINUTE.checkValidIntValue(som);</b>
<b class="nc"><i>563</i>&nbsp;                updateCheckConflict(LocalTime.of(hodVal, mohVal, somVal, nosVal), Period.ZERO);</b>
<i>564</i>&nbsp;            }
<i>565</i>&nbsp;        }
<i>566</i>&nbsp;    }
<i>567</i>&nbsp;
<i>568</i>&nbsp;    private void resolvePeriod() {
<i>569</i>&nbsp;        // add whole days if we have both date and time
<b class="nc"><i>570</i>&nbsp;        if (date != null &amp;&amp; time != null &amp;&amp; excessDays.isZero() == false) {</b>
<b class="nc"><i>571</i>&nbsp;            date = date.plus(excessDays);</b>
<b class="nc"><i>572</i>&nbsp;            excessDays = Period.ZERO;</b>
<b class="nc"><i>573</i>&nbsp;        }</b>
<b class="nc"><i>574</i>&nbsp;    }</b>
<b class="nc"><i>575</i>&nbsp;</b>
<b class="nc"><i>576</i>&nbsp;    private void resolveFractional() {</b>
<b class="nc"><i>577</i>&nbsp;        // ensure fractional seconds available as ChronoField requires</b>
<b class="nc"><i>578</i>&nbsp;        // resolveTimeLenient() will have merged MICRO_OF_SECOND/MILLI_OF_SECOND to NANO_OF_SECOND</b>
<b class="nc"><i>579</i>&nbsp;        if (time == null &amp;&amp;</b>
<b class="nc"><i>580</i>&nbsp;                (fieldValues.containsKey(INSTANT_SECONDS) ||</b>
<b class="nc"><i>581</i>&nbsp;                    fieldValues.containsKey(SECOND_OF_DAY) ||</b>
<i>582</i>&nbsp;                    fieldValues.containsKey(SECOND_OF_MINUTE))) {
<i>583</i>&nbsp;            if (fieldValues.containsKey(NANO_OF_SECOND)) {
<i>584</i>&nbsp;                long nos = fieldValues.get(NANO_OF_SECOND);
<i>585</i>&nbsp;                fieldValues.put(MICRO_OF_SECOND, nos / 1000);
<i>586</i>&nbsp;                fieldValues.put(MILLI_OF_SECOND, nos / 1000000);
<i>587</i>&nbsp;            } else {
<b class="nc"><i>588</i>&nbsp;                fieldValues.put(NANO_OF_SECOND, 0L);</b>
<b class="nc"><i>589</i>&nbsp;                fieldValues.put(MICRO_OF_SECOND, 0L);</b>
<b class="nc"><i>590</i>&nbsp;                fieldValues.put(MILLI_OF_SECOND, 0L);</b>
<b class="nc"><i>591</i>&nbsp;            }</b>
<b class="nc"><i>592</i>&nbsp;        }</b>
<b class="nc"><i>593</i>&nbsp;    }</b>
<b class="nc"><i>594</i>&nbsp;</b>
<b class="nc"><i>595</i>&nbsp;    private void resolveInstant() {</b>
<b class="nc"><i>596</i>&nbsp;        // add instant seconds if we have date, time and zone</b>
<b class="nc"><i>597</i>&nbsp;        // Offset (if present) will be given priority over the zone.</b>
<i>598</i>&nbsp;        if (date != null &amp;&amp; time != null) {
<i>599</i>&nbsp;            Long offsetSecs = fieldValues.get(OFFSET_SECONDS);
<i>600</i>&nbsp;            if (offsetSecs != null) {
<i>601</i>&nbsp;                ZoneOffset offset = ZoneOffset.ofTotalSeconds(offsetSecs.intValue());
<i>602</i>&nbsp;                long instant = date.atTime(time).atZone(offset).toEpochSecond();
<i>603</i>&nbsp;                fieldValues.put(INSTANT_SECONDS, instant);
<b class="nc"><i>604</i>&nbsp;            } else {</b>
<b class="nc"><i>605</i>&nbsp;                if (zone != null) {</b>
<b class="nc"><i>606</i>&nbsp;                    long instant = date.atTime(time).atZone(zone).toEpochSecond();</b>
<i>607</i>&nbsp;                    fieldValues.put(INSTANT_SECONDS, instant);
<b class="nc"><i>608</i>&nbsp;                }</b>
<b class="nc"><i>609</i>&nbsp;            }</b>
<i>610</i>&nbsp;        }
<b class="nc"><i>611</i>&nbsp;    }</b>
<i>612</i>&nbsp;
<i>613</i>&nbsp;    private void updateCheckConflict(LocalTime timeToSet, Period periodToSet) {
<b class="nc"><i>614</i>&nbsp;        if (time != null) {</b>
<b class="nc"><i>615</i>&nbsp;            if (time.equals(timeToSet) == false) {</b>
<i>616</i>&nbsp;                throw new DateTimeException(&quot;Conflict found: Fields resolved to different times: &quot; + time + &quot; &quot; + timeToSet);
<i>617</i>&nbsp;            }
<i>618</i>&nbsp;            if (excessDays.isZero() == false &amp;&amp; periodToSet.isZero() == false &amp;&amp; excessDays.equals(periodToSet) == false) {
<i>619</i>&nbsp;                throw new DateTimeException(&quot;Conflict found: Fields resolved to different excess periods: &quot; + excessDays + &quot; &quot; + periodToSet);
<i>620</i>&nbsp;            } else {
<i>621</i>&nbsp;                excessDays = periodToSet;
<i>622</i>&nbsp;            }
<b class="nc"><i>623</i>&nbsp;        } else {</b>
<b class="nc"><i>624</i>&nbsp;            time = timeToSet;</b>
<i>625</i>&nbsp;            excessDays = periodToSet;
<b class="nc"><i>626</i>&nbsp;        }</b>
<b class="nc"><i>627</i>&nbsp;    }</b>
<b class="nc"><i>628</i>&nbsp;</b>
<b class="nc"><i>629</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>630</i>&nbsp;    private void crossCheck() {
<i>631</i>&nbsp;        // only cross-check date, time and date-time
<i>632</i>&nbsp;        // avoid object creation if possible
<i>633</i>&nbsp;        if (date != null) {
<i>634</i>&nbsp;            crossCheck(date);
<b class="nc"><i>635</i>&nbsp;        }</b>
<b class="nc"><i>636</i>&nbsp;        if (time != null) {</b>
<b class="nc"><i>637</i>&nbsp;            crossCheck(time);</b>
<b class="nc"><i>638</i>&nbsp;            if (date != null &amp;&amp; fieldValues.size() &gt; 0) {</b>
<i>639</i>&nbsp;                crossCheck(date.atTime(time));
<i>640</i>&nbsp;            }
<b class="nc"><i>641</i>&nbsp;        }</b>
<b class="nc"><i>642</i>&nbsp;    }</b>
<b class="nc"><i>643</i>&nbsp;</b>
<b class="nc"><i>644</i>&nbsp;    private void crossCheck(TemporalAccessor target) {</b>
<b class="nc"><i>645</i>&nbsp;        for (Iterator&lt;Entry&lt;TemporalField, Long&gt;&gt; it = fieldValues.entrySet().iterator(); it.hasNext(); ) {</b>
<b class="nc"><i>646</i>&nbsp;            Entry&lt;TemporalField, Long&gt; entry = it.next();</b>
<b class="nc"><i>647</i>&nbsp;            TemporalField field = entry.getKey();</b>
<i>648</i>&nbsp;            if (target.isSupported(field)) {
<i>649</i>&nbsp;                long val1;
<b class="nc"><i>650</i>&nbsp;                try {</b>
<i>651</i>&nbsp;                    val1 = target.getLong(field);
<b class="nc"><i>652</i>&nbsp;                } catch (RuntimeException ex) {</b>
<i>653</i>&nbsp;                    continue;
<i>654</i>&nbsp;                }
<i>655</i>&nbsp;                long val2 = entry.getValue();
<i>656</i>&nbsp;                if (val1 != val2) {
<i>657</i>&nbsp;                    throw new DateTimeException(&quot;Conflict found: Field &quot; + field + &quot; &quot; + val1 +
<b class="nc"><i>658</i>&nbsp;                            &quot; differs from &quot; + field + &quot; &quot; + val2 + &quot; derived from &quot; + target);</b>
<b class="nc"><i>659</i>&nbsp;                }</b>
<b class="nc"><i>660</i>&nbsp;                it.remove();</b>
<b class="nc"><i>661</i>&nbsp;            }</b>
<i>662</i>&nbsp;        }
<b class="nc"><i>663</i>&nbsp;    }</b>
<b class="nc"><i>664</i>&nbsp;</b>
<b class="nc"><i>665</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>666</i>&nbsp;    @Override</b>
<b class="nc"><i>667</i>&nbsp;    public String toString() {</b>
<b class="nc"><i>668</i>&nbsp;        StringBuilder buf = new StringBuilder(64);</b>
<i>669</i>&nbsp;        buf.append(fieldValues).append(&#39;,&#39;).append(chrono);
<i>670</i>&nbsp;        if (zone != null) {
<b class="nc"><i>671</i>&nbsp;            buf.append(&#39;,&#39;).append(zone);</b>
<i>672</i>&nbsp;        }
<i>673</i>&nbsp;        if (date != null || time != null) {
<b class="nc"><i>674</i>&nbsp;            buf.append(&quot; resolved to &quot;);</b>
<i>675</i>&nbsp;            if (date != null) {
<i>676</i>&nbsp;                buf.append(date);
<i>677</i>&nbsp;                if (time != null) {
<i>678</i>&nbsp;                    buf.append(&#39;T&#39;).append(time);
<i>679</i>&nbsp;                }
<i>680</i>&nbsp;            } else {
<i>681</i>&nbsp;                buf.append(time);
<i>682</i>&nbsp;            }
<i>683</i>&nbsp;        }
<i>684</i>&nbsp;        return buf.toString();
<i>685</i>&nbsp;    }
<i>686</i>&nbsp;
<i>687</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
