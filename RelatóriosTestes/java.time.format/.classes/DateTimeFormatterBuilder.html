


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DateTimeFormatterBuilder</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.time.format</a> ]
</div>

<h1>Coverage Summary for Class: DateTimeFormatterBuilder (java.time.format)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DateTimeFormatterBuilder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 350)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$CharLiteralPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$ChronoPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$CompositePrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$DefaultValueParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$FractionPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 75)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$InstantPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 87)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$LocalizedOffsetIdPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 99)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$LocalizedPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$NumberPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 117)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$OffsetIdPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 80)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$PadPrinterParserDecorator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$PrefixTree</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 96)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$PrefixTree$CI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$PrefixTree$LENIENT</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$ReducedPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$SettingsParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$StringLiteralPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$TextPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$WeekBasedFieldPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$ZoneIdPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 70)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeFormatterBuilder$ZoneTextPrinterParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 84)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 182)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1421)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; *
<i>28</i>&nbsp; *
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *
<i>31</i>&nbsp; *
<i>32</i>&nbsp; * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
<i>33</i>&nbsp; *
<i>34</i>&nbsp; * All rights reserved.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * Redistribution and use in source and binary forms, with or without
<i>37</i>&nbsp; * modification, are permitted provided that the following conditions are met:
<i>38</i>&nbsp; *
<i>39</i>&nbsp; *  * Redistributions of source code must retain the above copyright notice,
<i>40</i>&nbsp; *    this list of conditions and the following disclaimer.
<i>41</i>&nbsp; *
<i>42</i>&nbsp; *  * Redistributions in binary form must reproduce the above copyright notice,
<i>43</i>&nbsp; *    this list of conditions and the following disclaimer in the documentation
<i>44</i>&nbsp; *    and/or other materials provided with the distribution.
<i>45</i>&nbsp; *
<i>46</i>&nbsp; *  * Neither the name of JSR-310 nor the names of its contributors
<i>47</i>&nbsp; *    may be used to endorse or promote products derived from this software
<i>48</i>&nbsp; *    without specific prior written permission.
<i>49</i>&nbsp; *
<i>50</i>&nbsp; * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<i>51</i>&nbsp; * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<i>52</i>&nbsp; * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<i>53</i>&nbsp; * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
<i>54</i>&nbsp; * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<i>55</i>&nbsp; * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<i>56</i>&nbsp; * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<i>57</i>&nbsp; * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<i>58</i>&nbsp; * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<i>59</i>&nbsp; * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<i>60</i>&nbsp; * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<i>61</i>&nbsp; */
<i>62</i>&nbsp;package java.time.format;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import static java.time.temporal.ChronoField.DAY_OF_MONTH;
<i>65</i>&nbsp;import static java.time.temporal.ChronoField.HOUR_OF_DAY;
<i>66</i>&nbsp;import static java.time.temporal.ChronoField.INSTANT_SECONDS;
<i>67</i>&nbsp;import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
<i>68</i>&nbsp;import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
<i>69</i>&nbsp;import static java.time.temporal.ChronoField.NANO_OF_SECOND;
<i>70</i>&nbsp;import static java.time.temporal.ChronoField.OFFSET_SECONDS;
<i>71</i>&nbsp;import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;
<i>72</i>&nbsp;import static java.time.temporal.ChronoField.YEAR;
<i>73</i>&nbsp;import static java.time.temporal.ChronoField.ERA;
<i>74</i>&nbsp;
<i>75</i>&nbsp;import java.lang.ref.SoftReference;
<i>76</i>&nbsp;import java.math.BigDecimal;
<i>77</i>&nbsp;import java.math.BigInteger;
<i>78</i>&nbsp;import java.math.RoundingMode;
<i>79</i>&nbsp;import java.text.ParsePosition;
<i>80</i>&nbsp;import java.time.DateTimeException;
<i>81</i>&nbsp;import java.time.Instant;
<i>82</i>&nbsp;import java.time.LocalDate;
<i>83</i>&nbsp;import java.time.LocalDateTime;
<i>84</i>&nbsp;import java.time.LocalTime;
<i>85</i>&nbsp;import java.time.ZoneId;
<i>86</i>&nbsp;import java.time.ZoneOffset;
<i>87</i>&nbsp;import java.time.chrono.ChronoLocalDate;
<i>88</i>&nbsp;import java.time.chrono.ChronoLocalDateTime;
<i>89</i>&nbsp;import java.time.chrono.Chronology;
<i>90</i>&nbsp;import java.time.chrono.Era;
<i>91</i>&nbsp;import java.time.chrono.IsoChronology;
<i>92</i>&nbsp;import java.time.format.DateTimeTextProvider.LocaleStore;
<i>93</i>&nbsp;import java.time.temporal.ChronoField;
<i>94</i>&nbsp;import java.time.temporal.IsoFields;
<i>95</i>&nbsp;import java.time.temporal.JulianFields;
<i>96</i>&nbsp;import java.time.temporal.TemporalAccessor;
<i>97</i>&nbsp;import java.time.temporal.TemporalField;
<i>98</i>&nbsp;import java.time.temporal.TemporalQueries;
<i>99</i>&nbsp;import java.time.temporal.TemporalQuery;
<i>100</i>&nbsp;import java.time.temporal.ValueRange;
<i>101</i>&nbsp;import java.time.temporal.WeekFields;
<i>102</i>&nbsp;import java.time.zone.ZoneRulesProvider;
<i>103</i>&nbsp;import java.util.AbstractMap.SimpleImmutableEntry;
<i>104</i>&nbsp;import java.util.ArrayList;
<i>105</i>&nbsp;import java.util.Arrays;
<i>106</i>&nbsp;import java.util.Collections;
<i>107</i>&nbsp;import java.util.Comparator;
<i>108</i>&nbsp;import java.util.HashMap;
<i>109</i>&nbsp;import java.util.HashSet;
<i>110</i>&nbsp;import java.util.Iterator;
<i>111</i>&nbsp;import java.util.LinkedHashMap;
<i>112</i>&nbsp;import java.util.List;
<i>113</i>&nbsp;import java.util.Locale;
<i>114</i>&nbsp;import java.util.Map;
<i>115</i>&nbsp;import java.util.Map.Entry;
<i>116</i>&nbsp;import java.util.Objects;
<i>117</i>&nbsp;import java.util.Set;
<i>118</i>&nbsp;import java.util.TimeZone;
<i>119</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>120</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>121</i>&nbsp;
<i>122</i>&nbsp;import sun.text.spi.JavaTimeDateTimePatternProvider;
<i>123</i>&nbsp;import sun.util.locale.provider.CalendarDataUtility;
<i>124</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>125</i>&nbsp;import sun.util.locale.provider.LocaleResources;
<i>126</i>&nbsp;import sun.util.locale.provider.TimeZoneNameUtility;
<i>127</i>&nbsp;
<i>128</i>&nbsp;/**
<i>129</i>&nbsp; * Builder to create date-time formatters.
<i>130</i>&nbsp; * &lt;p&gt;
<i>131</i>&nbsp; * This allows a {@code DateTimeFormatter} to be created.
<i>132</i>&nbsp; * All date-time formatters are created ultimately using this builder.
<i>133</i>&nbsp; * &lt;p&gt;
<i>134</i>&nbsp; * The basic elements of date-time can all be added:
<i>135</i>&nbsp; * &lt;ul&gt;
<i>136</i>&nbsp; * &lt;li&gt;Value - a numeric value&lt;/li&gt;
<i>137</i>&nbsp; * &lt;li&gt;Fraction - a fractional value including the decimal place. Always use this when
<i>138</i>&nbsp; * outputting fractions to ensure that the fraction is parsed correctly&lt;/li&gt;
<i>139</i>&nbsp; * &lt;li&gt;Text - the textual equivalent for the value&lt;/li&gt;
<i>140</i>&nbsp; * &lt;li&gt;OffsetId/Offset - the {@linkplain ZoneOffset zone offset}&lt;/li&gt;
<i>141</i>&nbsp; * &lt;li&gt;ZoneId - the {@linkplain ZoneId time-zone} id&lt;/li&gt;
<i>142</i>&nbsp; * &lt;li&gt;ZoneText - the name of the time-zone&lt;/li&gt;
<i>143</i>&nbsp; * &lt;li&gt;ChronologyId - the {@linkplain Chronology chronology} id&lt;/li&gt;
<i>144</i>&nbsp; * &lt;li&gt;ChronologyText - the name of the chronology&lt;/li&gt;
<i>145</i>&nbsp; * &lt;li&gt;Literal - a text literal&lt;/li&gt;
<i>146</i>&nbsp; * &lt;li&gt;Nested and Optional - formats can be nested or made optional&lt;/li&gt;
<i>147</i>&nbsp; * &lt;/ul&gt;
<i>148</i>&nbsp; * In addition, any of the elements may be decorated by padding, either with spaces or any other character.
<i>149</i>&nbsp; * &lt;p&gt;
<i>150</i>&nbsp; * Finally, a shorthand pattern, mostly compatible with {@code java.text.SimpleDateFormat SimpleDateFormat}
<i>151</i>&nbsp; * can be used, see {@link #appendPattern(String)}.
<i>152</i>&nbsp; * In practice, this simply parses the pattern and calls other methods on the builder.
<i>153</i>&nbsp; *
<i>154</i>&nbsp; * @implSpec
<i>155</i>&nbsp; * This class is a mutable builder intended for use from a single thread.
<i>156</i>&nbsp; *
<b class="nc"><i>157</i>&nbsp; * @since 1.8</b>
<b class="nc"><i>158</i>&nbsp; */</b>
<b class="nc"><i>159</i>&nbsp;public final class DateTimeFormatterBuilder {</b>
<i>160</i>&nbsp;
<i>161</i>&nbsp;    /**
<i>162</i>&nbsp;     * Query for a time-zone that is region-only.
<i>163</i>&nbsp;     */
<i>164</i>&nbsp;    private static final TemporalQuery&lt;ZoneId&gt; QUERY_REGION_ONLY = (temporal) -&gt; {
<b class="nc"><i>165</i>&nbsp;        ZoneId zone = temporal.query(TemporalQueries.zoneId());</b>
<i>166</i>&nbsp;        return (zone != null &amp;&amp; zone instanceof ZoneOffset == false ? zone : null);
<i>167</i>&nbsp;    };
<i>168</i>&nbsp;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * The currently active builder, used by the outermost builder.
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    private DateTimeFormatterBuilder active = this;
<b class="nc"><i>173</i>&nbsp;    /**</b>
<i>174</i>&nbsp;     * The parent builder, null for the outermost builder.
<i>175</i>&nbsp;     */
<i>176</i>&nbsp;    private final DateTimeFormatterBuilder parent;
<i>177</i>&nbsp;    /**
<i>178</i>&nbsp;     * The list of printers that will be used.
<i>179</i>&nbsp;     */
<i>180</i>&nbsp;    private final List&lt;DateTimePrinterParser&gt; printerParsers = new ArrayList&lt;&gt;();
<i>181</i>&nbsp;    /**
<i>182</i>&nbsp;     * Whether this builder produces an optional formatter.
<i>183</i>&nbsp;     */
<i>184</i>&nbsp;    private final boolean optional;
<i>185</i>&nbsp;    /**
<i>186</i>&nbsp;     * The width to pad the next field to.
<i>187</i>&nbsp;     */
<i>188</i>&nbsp;    private int padNextWidth;
<b class="nc"><i>189</i>&nbsp;    /**</b>
<i>190</i>&nbsp;     * The character to pad the next field with.
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    private char padNextChar;
<i>193</i>&nbsp;    /**
<i>194</i>&nbsp;     * The index of the last variable width value parser.
<i>195</i>&nbsp;     */
<i>196</i>&nbsp;    private int valueParserIndex = -1;
<i>197</i>&nbsp;
<i>198</i>&nbsp;    /**
<i>199</i>&nbsp;     * Gets the formatting pattern for date and time styles for a locale and chronology.
<i>200</i>&nbsp;     * The locale and chronology are used to lookup the locale specific format
<i>201</i>&nbsp;     * for the requested dateStyle and/or timeStyle.
<i>202</i>&nbsp;     * &lt;p&gt;
<i>203</i>&nbsp;     * If the locale contains the &quot;rg&quot; (region override)
<i>204</i>&nbsp;     * &lt;a href=&quot;../../util/Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;,
<b class="nc"><i>205</i>&nbsp;     * the formatting pattern is overridden with the one appropriate for the region.</b>
<b class="nc"><i>206</i>&nbsp;     *</b>
<b class="nc"><i>207</i>&nbsp;     * @param dateStyle  the FormatStyle for the date, null for time-only pattern</b>
<b class="nc"><i>208</i>&nbsp;     * @param timeStyle  the FormatStyle for the time, null for date-only pattern</b>
<i>209</i>&nbsp;     * @param chrono  the Chronology, non-null
<b class="nc"><i>210</i>&nbsp;     * @param locale  the locale, non-null</b>
<b class="nc"><i>211</i>&nbsp;     * @return the locale and Chronology specific formatting pattern</b>
<b class="nc"><i>212</i>&nbsp;     * @throws IllegalArgumentException if both dateStyle and timeStyle are null</b>
<b class="nc"><i>213</i>&nbsp;     */</b>
<i>214</i>&nbsp;    public static String getLocalizedDateTimePattern(FormatStyle dateStyle, FormatStyle timeStyle,
<i>215</i>&nbsp;            Chronology chrono, Locale locale) {
<i>216</i>&nbsp;        Objects.requireNonNull(locale, &quot;locale&quot;);
<i>217</i>&nbsp;        Objects.requireNonNull(chrono, &quot;chrono&quot;);
<i>218</i>&nbsp;        if (dateStyle == null &amp;&amp; timeStyle == null) {
<i>219</i>&nbsp;            throw new IllegalArgumentException(&quot;Either dateStyle or timeStyle must be non-null&quot;);
<i>220</i>&nbsp;        }
<i>221</i>&nbsp;        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(JavaTimeDateTimePatternProvider.class, locale);
<i>222</i>&nbsp;        JavaTimeDateTimePatternProvider provider = adapter.getJavaTimeDateTimePatternProvider();
<b class="nc"><i>223</i>&nbsp;        String pattern = provider.getJavaTimeDateTimePattern(convertStyle(timeStyle),</b>
<b class="nc"><i>224</i>&nbsp;                         convertStyle(dateStyle), chrono.getCalendarType(),</b>
<i>225</i>&nbsp;                         CalendarDataUtility.findRegionOverride(locale));
<b class="nc"><i>226</i>&nbsp;        return pattern;</b>
<i>227</i>&nbsp;    }
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Converts the given FormatStyle to the java.text.DateFormat style.
<i>231</i>&nbsp;     *
<i>232</i>&nbsp;     * @param style  the FormatStyle style
<b class="nc"><i>233</i>&nbsp;     * @return the int style, or -1 if style is null, indicating un-required</b>
<b class="nc"><i>234</i>&nbsp;     */</b>
<b class="nc"><i>235</i>&nbsp;    private static int convertStyle(FormatStyle style) {</b>
<i>236</i>&nbsp;        if (style == null) {
<i>237</i>&nbsp;            return -1;
<i>238</i>&nbsp;        }
<i>239</i>&nbsp;        return style.ordinal();  // indices happen to align
<i>240</i>&nbsp;    }
<i>241</i>&nbsp;
<i>242</i>&nbsp;    /**
<i>243</i>&nbsp;     * Constructs a new instance of the builder.
<i>244</i>&nbsp;     */
<b class="nc"><i>245</i>&nbsp;    public DateTimeFormatterBuilder() {</b>
<b class="nc"><i>246</i>&nbsp;        super();</b>
<b class="nc"><i>247</i>&nbsp;        parent = null;</b>
<i>248</i>&nbsp;        optional = false;
<i>249</i>&nbsp;    }
<i>250</i>&nbsp;
<i>251</i>&nbsp;    /**
<i>252</i>&nbsp;     * Constructs a new instance of the builder.
<i>253</i>&nbsp;     *
<i>254</i>&nbsp;     * @param parent  the parent builder, not null
<i>255</i>&nbsp;     * @param optional  whether the formatter is optional, not null
<i>256</i>&nbsp;     */
<i>257</i>&nbsp;    private DateTimeFormatterBuilder(DateTimeFormatterBuilder parent, boolean optional) {
<i>258</i>&nbsp;        super();
<i>259</i>&nbsp;        this.parent = parent;
<i>260</i>&nbsp;        this.optional = optional;
<i>261</i>&nbsp;    }
<i>262</i>&nbsp;
<i>263</i>&nbsp;    //-----------------------------------------------------------------------
<i>264</i>&nbsp;    /**
<i>265</i>&nbsp;     * Changes the parse style to be case sensitive for the remainder of the formatter.
<i>266</i>&nbsp;     * &lt;p&gt;
<i>267</i>&nbsp;     * Parsing can be case sensitive or insensitive - by default it is case sensitive.
<i>268</i>&nbsp;     * This method allows the case sensitivity setting of parsing to be changed.
<i>269</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>270</i>&nbsp;     * Calling this method changes the state of the builder such that all</b>
<b class="nc"><i>271</i>&nbsp;     * subsequent builder method calls will parse text in case sensitive mode.</b>
<i>272</i>&nbsp;     * See {@link #parseCaseInsensitive} for the opposite setting.
<i>273</i>&nbsp;     * The parse case sensitive/insensitive methods may be called at any point
<i>274</i>&nbsp;     * in the builder, thus the parser can swap between case parsing modes
<i>275</i>&nbsp;     * multiple times during the parse.
<i>276</i>&nbsp;     * &lt;p&gt;
<i>277</i>&nbsp;     * Since the default is case sensitive, this method should only be used after
<i>278</i>&nbsp;     * a previous call to {@code #parseCaseInsensitive}.
<i>279</i>&nbsp;     *
<i>280</i>&nbsp;     * @return this, for chaining, not null
<i>281</i>&nbsp;     */
<i>282</i>&nbsp;    public DateTimeFormatterBuilder parseCaseSensitive() {
<i>283</i>&nbsp;        appendInternal(SettingsParser.SENSITIVE);
<i>284</i>&nbsp;        return this;
<i>285</i>&nbsp;    }
<i>286</i>&nbsp;
<i>287</i>&nbsp;    /**
<i>288</i>&nbsp;     * Changes the parse style to be case insensitive for the remainder of the formatter.
<i>289</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>290</i>&nbsp;     * Parsing can be case sensitive or insensitive - by default it is case sensitive.</b>
<b class="nc"><i>291</i>&nbsp;     * This method allows the case sensitivity setting of parsing to be changed.</b>
<i>292</i>&nbsp;     * &lt;p&gt;
<i>293</i>&nbsp;     * Calling this method changes the state of the builder such that all
<i>294</i>&nbsp;     * subsequent builder method calls will parse text in case insensitive mode.
<i>295</i>&nbsp;     * See {@link #parseCaseSensitive()} for the opposite setting.
<i>296</i>&nbsp;     * The parse case sensitive/insensitive methods may be called at any point
<i>297</i>&nbsp;     * in the builder, thus the parser can swap between case parsing modes
<i>298</i>&nbsp;     * multiple times during the parse.
<i>299</i>&nbsp;     *
<i>300</i>&nbsp;     * @return this, for chaining, not null
<i>301</i>&nbsp;     */
<i>302</i>&nbsp;    public DateTimeFormatterBuilder parseCaseInsensitive() {
<i>303</i>&nbsp;        appendInternal(SettingsParser.INSENSITIVE);
<i>304</i>&nbsp;        return this;
<i>305</i>&nbsp;    }
<i>306</i>&nbsp;
<i>307</i>&nbsp;    //-----------------------------------------------------------------------
<i>308</i>&nbsp;    /**
<b class="nc"><i>309</i>&nbsp;     * Changes the parse style to be strict for the remainder of the formatter.</b>
<b class="nc"><i>310</i>&nbsp;     * &lt;p&gt;</b>
<i>311</i>&nbsp;     * Parsing can be strict or lenient - by default its strict.
<i>312</i>&nbsp;     * This controls the degree of flexibility in matching the text and sign styles.
<i>313</i>&nbsp;     * &lt;p&gt;
<i>314</i>&nbsp;     * When used, this method changes the parsing to be strict from this point onwards.
<i>315</i>&nbsp;     * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
<i>316</i>&nbsp;     * The change will remain in force until the end of the formatter that is eventually
<i>317</i>&nbsp;     * constructed or until {@code parseLenient} is called.
<i>318</i>&nbsp;     *
<i>319</i>&nbsp;     * @return this, for chaining, not null
<i>320</i>&nbsp;     */
<i>321</i>&nbsp;    public DateTimeFormatterBuilder parseStrict() {
<i>322</i>&nbsp;        appendInternal(SettingsParser.STRICT);
<i>323</i>&nbsp;        return this;
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;
<i>326</i>&nbsp;    /**
<i>327</i>&nbsp;     * Changes the parse style to be lenient for the remainder of the formatter.
<b class="nc"><i>328</i>&nbsp;     * Note that case sensitivity is set separately to this method.</b>
<b class="nc"><i>329</i>&nbsp;     * &lt;p&gt;</b>
<i>330</i>&nbsp;     * Parsing can be strict or lenient - by default its strict.
<i>331</i>&nbsp;     * This controls the degree of flexibility in matching the text and sign styles.
<i>332</i>&nbsp;     * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
<i>333</i>&nbsp;     * &lt;p&gt;
<i>334</i>&nbsp;     * When used, this method changes the parsing to be lenient from this point onwards.
<i>335</i>&nbsp;     * The change will remain in force until the end of the formatter that is eventually
<i>336</i>&nbsp;     * constructed or until {@code parseStrict} is called.
<i>337</i>&nbsp;     *
<i>338</i>&nbsp;     * @return this, for chaining, not null
<i>339</i>&nbsp;     */
<i>340</i>&nbsp;    public DateTimeFormatterBuilder parseLenient() {
<i>341</i>&nbsp;        appendInternal(SettingsParser.LENIENT);
<i>342</i>&nbsp;        return this;
<i>343</i>&nbsp;    }
<i>344</i>&nbsp;
<i>345</i>&nbsp;    //-----------------------------------------------------------------------
<i>346</i>&nbsp;    /**
<i>347</i>&nbsp;     * Appends a default value for a field to the formatter for use in parsing.
<i>348</i>&nbsp;     * &lt;p&gt;
<i>349</i>&nbsp;     * This appends an instruction to the builder to inject a default value
<i>350</i>&nbsp;     * into the parsed result. This is especially useful in conjunction with
<i>351</i>&nbsp;     * optional parts of the formatter.
<i>352</i>&nbsp;     * &lt;p&gt;
<i>353</i>&nbsp;     * For example, consider a formatter that parses the year, followed by
<i>354</i>&nbsp;     * an optional month, with a further optional day-of-month. Using such a
<i>355</i>&nbsp;     * formatter would require the calling code to check whether a full date,
<i>356</i>&nbsp;     * year-month or just a year had been parsed. This method can be used to
<i>357</i>&nbsp;     * default the month and day-of-month to a sensible value, such as the
<i>358</i>&nbsp;     * first of the month, allowing the calling code to always get a date.
<i>359</i>&nbsp;     * &lt;p&gt;
<i>360</i>&nbsp;     * During formatting, this method has no effect.
<b class="nc"><i>361</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>362</i>&nbsp;     * During parsing, the current state of the parse is inspected.</b>
<b class="nc"><i>363</i>&nbsp;     * If the specified field has no associated value, because it has not been</b>
<i>364</i>&nbsp;     * parsed successfully at that point, then the specified value is injected
<i>365</i>&nbsp;     * into the parse result. Injection is immediate, thus the field-value pair
<i>366</i>&nbsp;     * will be visible to any subsequent elements in the formatter.
<i>367</i>&nbsp;     * As such, this method is normally called at the end of the builder.
<i>368</i>&nbsp;     *
<i>369</i>&nbsp;     * @param field  the field to default the value of, not null
<i>370</i>&nbsp;     * @param value  the value to default the field to
<i>371</i>&nbsp;     * @return this, for chaining, not null
<i>372</i>&nbsp;     */
<i>373</i>&nbsp;    public DateTimeFormatterBuilder parseDefaulting(TemporalField field, long value) {
<i>374</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>375</i>&nbsp;        appendInternal(new DefaultValueParser(field, value));
<i>376</i>&nbsp;        return this;
<i>377</i>&nbsp;    }
<i>378</i>&nbsp;
<i>379</i>&nbsp;    //-----------------------------------------------------------------------
<i>380</i>&nbsp;    /**
<i>381</i>&nbsp;     * Appends the value of a date-time field to the formatter using a normal
<i>382</i>&nbsp;     * output style.
<i>383</i>&nbsp;     * &lt;p&gt;
<i>384</i>&nbsp;     * The value of the field will be output during a format.
<i>385</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<b class="nc"><i>386</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>387</i>&nbsp;     * The value will be printed as per the normal format of an integer value.</b>
<b class="nc"><i>388</i>&nbsp;     * Only negative numbers will be signed. No padding will be added.</b>
<i>389</i>&nbsp;     * &lt;p&gt;
<i>390</i>&nbsp;     * The parser for a variable width value such as this normally behaves greedily,
<i>391</i>&nbsp;     * requiring one digit, but accepting as many digits as possible.
<i>392</i>&nbsp;     * This behavior can be affected by &#39;adjacent value parsing&#39;.
<i>393</i>&nbsp;     * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
<i>394</i>&nbsp;     *
<i>395</i>&nbsp;     * @param field  the field to append, not null
<i>396</i>&nbsp;     * @return this, for chaining, not null
<i>397</i>&nbsp;     */
<i>398</i>&nbsp;    public DateTimeFormatterBuilder appendValue(TemporalField field) {
<i>399</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>400</i>&nbsp;        appendValue(new NumberPrinterParser(field, 1, 19, SignStyle.NORMAL));
<i>401</i>&nbsp;        return this;
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;
<i>404</i>&nbsp;    /**
<i>405</i>&nbsp;     * Appends the value of a date-time field to the formatter using a fixed
<i>406</i>&nbsp;     * width, zero-padded approach.
<i>407</i>&nbsp;     * &lt;p&gt;
<i>408</i>&nbsp;     * The value of the field will be output during a format.
<i>409</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<i>410</i>&nbsp;     * &lt;p&gt;
<i>411</i>&nbsp;     * The value will be zero-padded on the left. If the size of the value
<i>412</i>&nbsp;     * means that it cannot be printed within the width then an exception is thrown.
<i>413</i>&nbsp;     * If the value of the field is negative then an exception is thrown during formatting.
<i>414</i>&nbsp;     * &lt;p&gt;
<i>415</i>&nbsp;     * This method supports a special technique of parsing known as &#39;adjacent value parsing&#39;.
<i>416</i>&nbsp;     * This technique solves the problem where a value, variable or fixed width, is followed by one or more
<i>417</i>&nbsp;     * fixed length values. The standard parser is greedy, and thus it would normally
<i>418</i>&nbsp;     * steal the digits that are needed by the fixed width value parsers that follow the
<i>419</i>&nbsp;     * variable width one.
<i>420</i>&nbsp;     * &lt;p&gt;
<i>421</i>&nbsp;     * No action is required to initiate &#39;adjacent value parsing&#39;.
<i>422</i>&nbsp;     * When a call to {@code appendValue} is made, the builder
<i>423</i>&nbsp;     * enters adjacent value parsing setup mode. If the immediately subsequent method
<i>424</i>&nbsp;     * call or calls on the same builder are for a fixed width value, then the parser will reserve
<i>425</i>&nbsp;     * space so that the fixed width values can be parsed.
<i>426</i>&nbsp;     * &lt;p&gt;
<i>427</i>&nbsp;     * For example, consider {@code builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);}
<i>428</i>&nbsp;     * The year is a variable width parse of between 1 and 19 digits.
<i>429</i>&nbsp;     * The month is a fixed width parse of 2 digits.
<i>430</i>&nbsp;     * Because these were appended to the same builder immediately after one another,
<i>431</i>&nbsp;     * the year parser will reserve two digits for the month to parse.
<i>432</i>&nbsp;     * Thus, the text &#39;201106&#39; will correctly parse to a year of 2011 and a month of 6.
<i>433</i>&nbsp;     * Without adjacent value parsing, the year would greedily parse all six digits and leave
<i>434</i>&nbsp;     * nothing for the month.
<i>435</i>&nbsp;     * &lt;p&gt;
<i>436</i>&nbsp;     * Adjacent value parsing applies to each set of fixed width not-negative values in the parser
<i>437</i>&nbsp;     * that immediately follow any kind of value, variable or fixed width.
<i>438</i>&nbsp;     * Calling any other append method will end the setup of adjacent value parsing.
<i>439</i>&nbsp;     * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
<b class="nc"><i>440</i>&nbsp;     * simply add the {@code appendValue} to another {@code DateTimeFormatterBuilder}</b>
<b class="nc"><i>441</i>&nbsp;     * and add that to this builder.</b>
<b class="nc"><i>442</i>&nbsp;     * &lt;p&gt;</b>
<i>443</i>&nbsp;     * If adjacent parsing is active, then parsing must match exactly the specified
<b class="nc"><i>444</i>&nbsp;     * number of digits in both strict and lenient modes.</b>
<b class="nc"><i>445</i>&nbsp;     * In addition, no positive or negative sign is permitted.</b>
<b class="nc"><i>446</i>&nbsp;     *</b>
<i>447</i>&nbsp;     * @param field  the field to append, not null
<i>448</i>&nbsp;     * @param width  the width of the printed field, from 1 to 19
<i>449</i>&nbsp;     * @return this, for chaining, not null
<i>450</i>&nbsp;     * @throws IllegalArgumentException if the width is invalid
<i>451</i>&nbsp;     */
<i>452</i>&nbsp;    public DateTimeFormatterBuilder appendValue(TemporalField field, int width) {
<i>453</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>454</i>&nbsp;        if (width &lt; 1 || width &gt; 19) {
<i>455</i>&nbsp;            throw new IllegalArgumentException(&quot;The width must be from 1 to 19 inclusive but was &quot; + width);
<i>456</i>&nbsp;        }
<i>457</i>&nbsp;        NumberPrinterParser pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
<i>458</i>&nbsp;        appendValue(pp);
<i>459</i>&nbsp;        return this;
<i>460</i>&nbsp;    }
<i>461</i>&nbsp;
<i>462</i>&nbsp;    /**
<i>463</i>&nbsp;     * Appends the value of a date-time field to the formatter providing full
<i>464</i>&nbsp;     * control over formatting.
<i>465</i>&nbsp;     * &lt;p&gt;
<i>466</i>&nbsp;     * The value of the field will be output during a format.
<i>467</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<i>468</i>&nbsp;     * &lt;p&gt;
<i>469</i>&nbsp;     * This method provides full control of the numeric formatting, including
<i>470</i>&nbsp;     * zero-padding and the positive/negative sign.
<i>471</i>&nbsp;     * &lt;p&gt;
<i>472</i>&nbsp;     * The parser for a variable width value such as this normally behaves greedily,
<i>473</i>&nbsp;     * accepting as many digits as possible.
<i>474</i>&nbsp;     * This behavior can be affected by &#39;adjacent value parsing&#39;.
<i>475</i>&nbsp;     * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
<i>476</i>&nbsp;     * &lt;p&gt;
<i>477</i>&nbsp;     * In strict parsing mode, the minimum number of parsed digits is {@code minWidth}
<i>478</i>&nbsp;     * and the maximum is {@code maxWidth}.
<i>479</i>&nbsp;     * In lenient parsing mode, the minimum number of parsed digits is one
<i>480</i>&nbsp;     * and the maximum is 19 (except as limited by adjacent value parsing).
<i>481</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>482</i>&nbsp;     * If this method is invoked with equal minimum and maximum widths and a sign style of</b>
<b class="nc"><i>483</i>&nbsp;     * {@code NOT_NEGATIVE} then it delegates to {@code appendValue(TemporalField,int)}.</b>
<i>484</i>&nbsp;     * In this scenario, the formatting and parsing behavior described there occur.
<b class="nc"><i>485</i>&nbsp;     *</b>
<b class="nc"><i>486</i>&nbsp;     * @param field  the field to append, not null</b>
<b class="nc"><i>487</i>&nbsp;     * @param minWidth  the minimum field width of the printed field, from 1 to 19</b>
<b class="nc"><i>488</i>&nbsp;     * @param maxWidth  the maximum field width of the printed field, from 1 to 19</b>
<i>489</i>&nbsp;     * @param signStyle  the positive/negative output style, not null
<b class="nc"><i>490</i>&nbsp;     * @return this, for chaining, not null</b>
<b class="nc"><i>491</i>&nbsp;     * @throws IllegalArgumentException if the widths are invalid</b>
<i>492</i>&nbsp;     */
<b class="nc"><i>493</i>&nbsp;    public DateTimeFormatterBuilder appendValue(</b>
<b class="nc"><i>494</i>&nbsp;            TemporalField field, int minWidth, int maxWidth, SignStyle signStyle) {</b>
<i>495</i>&nbsp;        if (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) {
<i>496</i>&nbsp;            return appendValue(field, maxWidth);
<b class="nc"><i>497</i>&nbsp;        }</b>
<b class="nc"><i>498</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);</b>
<b class="nc"><i>499</i>&nbsp;        Objects.requireNonNull(signStyle, &quot;signStyle&quot;);</b>
<i>500</i>&nbsp;        if (minWidth &lt; 1 || minWidth &gt; 19) {
<i>501</i>&nbsp;            throw new IllegalArgumentException(&quot;The minimum width must be from 1 to 19 inclusive but was &quot; + minWidth);
<i>502</i>&nbsp;        }
<i>503</i>&nbsp;        if (maxWidth &lt; 1 || maxWidth &gt; 19) {
<i>504</i>&nbsp;            throw new IllegalArgumentException(&quot;The maximum width must be from 1 to 19 inclusive but was &quot; + maxWidth);
<i>505</i>&nbsp;        }
<i>506</i>&nbsp;        if (maxWidth &lt; minWidth) {
<i>507</i>&nbsp;            throw new IllegalArgumentException(&quot;The maximum width must exceed or equal the minimum width but &quot; +
<i>508</i>&nbsp;                    maxWidth + &quot; &lt; &quot; + minWidth);
<i>509</i>&nbsp;        }
<i>510</i>&nbsp;        NumberPrinterParser pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
<i>511</i>&nbsp;        appendValue(pp);
<i>512</i>&nbsp;        return this;
<i>513</i>&nbsp;    }
<i>514</i>&nbsp;
<i>515</i>&nbsp;    //-----------------------------------------------------------------------
<i>516</i>&nbsp;    /**
<i>517</i>&nbsp;     * Appends the reduced value of a date-time field to the formatter.
<i>518</i>&nbsp;     * &lt;p&gt;
<i>519</i>&nbsp;     * Since fields such as year vary by chronology, it is recommended to use the
<i>520</i>&nbsp;     * {@link #appendValueReduced(TemporalField, int, int, ChronoLocalDate)} date}
<i>521</i>&nbsp;     * variant of this method in most cases. This variant is suitable for
<i>522</i>&nbsp;     * simple fields or working with only the ISO chronology.
<i>523</i>&nbsp;     * &lt;p&gt;
<i>524</i>&nbsp;     * For formatting, the {@code width} and {@code maxWidth} are used to
<i>525</i>&nbsp;     * determine the number of characters to format.
<i>526</i>&nbsp;     * If they are equal then the format is fixed width.
<i>527</i>&nbsp;     * If the value of the field is within the range of the {@code baseValue} using
<i>528</i>&nbsp;     * {@code width} characters then the reduced value is formatted otherwise the value is
<i>529</i>&nbsp;     * truncated to fit {@code maxWidth}.
<i>530</i>&nbsp;     * The rightmost characters are output to match the width, left padding with zero.
<i>531</i>&nbsp;     * &lt;p&gt;
<i>532</i>&nbsp;     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
<i>533</i>&nbsp;     * For lenient parsing, the number of characters must be at least 1 and less than 10.
<i>534</i>&nbsp;     * If the number of digits parsed is equal to {@code width} and the value is positive,
<i>535</i>&nbsp;     * the value of the field is computed to be the first number greater than
<i>536</i>&nbsp;     * or equal to the {@code baseValue} with the same least significant characters,
<i>537</i>&nbsp;     * otherwise the value parsed is the field value.
<i>538</i>&nbsp;     * This allows a reduced value to be entered for values in range of the baseValue
<i>539</i>&nbsp;     * and width and absolute values can be entered for values outside the range.
<i>540</i>&nbsp;     * &lt;p&gt;
<i>541</i>&nbsp;     * For example, a base value of {@code 1980} and a width of {@code 2} will have
<i>542</i>&nbsp;     * valid values from {@code 1980} to {@code 2079}.
<b class="nc"><i>543</i>&nbsp;     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that</b>
<b class="nc"><i>544</i>&nbsp;     * is the value within the range where the last two characters are &quot;12&quot;.</b>
<b class="nc"><i>545</i>&nbsp;     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.</b>
<b class="nc"><i>546</i>&nbsp;     *</b>
<i>547</i>&nbsp;     * @param field  the field to append, not null
<i>548</i>&nbsp;     * @param width  the field width of the printed and parsed field, from 1 to 10
<i>549</i>&nbsp;     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
<i>550</i>&nbsp;     * @param baseValue  the base value of the range of valid values
<i>551</i>&nbsp;     * @return this, for chaining, not null
<i>552</i>&nbsp;     * @throws IllegalArgumentException if the width or base value is invalid
<i>553</i>&nbsp;     */
<i>554</i>&nbsp;    public DateTimeFormatterBuilder appendValueReduced(TemporalField field,
<i>555</i>&nbsp;            int width, int maxWidth, int baseValue) {
<i>556</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>557</i>&nbsp;        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
<i>558</i>&nbsp;        appendValue(pp);
<i>559</i>&nbsp;        return this;
<i>560</i>&nbsp;    }
<i>561</i>&nbsp;
<i>562</i>&nbsp;    /**
<i>563</i>&nbsp;     * Appends the reduced value of a date-time field to the formatter.
<i>564</i>&nbsp;     * &lt;p&gt;
<i>565</i>&nbsp;     * This is typically used for formatting and parsing a two digit year.
<i>566</i>&nbsp;     * &lt;p&gt;
<i>567</i>&nbsp;     * The base date is used to calculate the full value during parsing.
<i>568</i>&nbsp;     * For example, if the base date is 1950-01-01 then parsed values for
<i>569</i>&nbsp;     * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
<i>570</i>&nbsp;     * Only the year would be extracted from the date, thus a base date of
<i>571</i>&nbsp;     * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
<i>572</i>&nbsp;     * This behavior is necessary to support fields such as week-based-year
<i>573</i>&nbsp;     * or other calendar systems where the parsed value does not align with
<i>574</i>&nbsp;     * standard ISO years.
<i>575</i>&nbsp;     * &lt;p&gt;
<i>576</i>&nbsp;     * The exact behavior is as follows. Parse the full set of fields and
<i>577</i>&nbsp;     * determine the effective chronology using the last chronology if
<i>578</i>&nbsp;     * it appears more than once. Then convert the base date to the
<i>579</i>&nbsp;     * effective chronology. Then extract the specified field from the
<i>580</i>&nbsp;     * chronology-specific base date and use it to determine the
<i>581</i>&nbsp;     * {@code baseValue} used below.
<i>582</i>&nbsp;     * &lt;p&gt;
<i>583</i>&nbsp;     * For formatting, the {@code width} and {@code maxWidth} are used to
<i>584</i>&nbsp;     * determine the number of characters to format.
<i>585</i>&nbsp;     * If they are equal then the format is fixed width.
<i>586</i>&nbsp;     * If the value of the field is within the range of the {@code baseValue} using
<i>587</i>&nbsp;     * {@code width} characters then the reduced value is formatted otherwise the value is
<i>588</i>&nbsp;     * truncated to fit {@code maxWidth}.
<i>589</i>&nbsp;     * The rightmost characters are output to match the width, left padding with zero.
<i>590</i>&nbsp;     * &lt;p&gt;
<i>591</i>&nbsp;     * For strict parsing, the number of characters allowed by {@code width} to {@code maxWidth} are parsed.
<i>592</i>&nbsp;     * For lenient parsing, the number of characters must be at least 1 and less than 10.
<i>593</i>&nbsp;     * If the number of digits parsed is equal to {@code width} and the value is positive,
<i>594</i>&nbsp;     * the value of the field is computed to be the first number greater than
<i>595</i>&nbsp;     * or equal to the {@code baseValue} with the same least significant characters,
<i>596</i>&nbsp;     * otherwise the value parsed is the field value.
<i>597</i>&nbsp;     * This allows a reduced value to be entered for values in range of the baseValue
<i>598</i>&nbsp;     * and width and absolute values can be entered for values outside the range.
<i>599</i>&nbsp;     * &lt;p&gt;
<i>600</i>&nbsp;     * For example, a base value of {@code 1980} and a width of {@code 2} will have
<i>601</i>&nbsp;     * valid values from {@code 1980} to {@code 2079}.
<i>602</i>&nbsp;     * During parsing, the text {@code &quot;12&quot;} will result in the value {@code 2012} as that
<b class="nc"><i>603</i>&nbsp;     * is the value within the range where the last two characters are &quot;12&quot;.</b>
<b class="nc"><i>604</i>&nbsp;     * By contrast, parsing the text {@code &quot;1915&quot;} will result in the value {@code 1915}.</b>
<b class="nc"><i>605</i>&nbsp;     *</b>
<b class="nc"><i>606</i>&nbsp;     * @param field  the field to append, not null</b>
<b class="nc"><i>607</i>&nbsp;     * @param width  the field width of the printed and parsed field, from 1 to 10</b>
<i>608</i>&nbsp;     * @param maxWidth  the maximum field width of the printed field, from 1 to 10
<i>609</i>&nbsp;     * @param baseDate  the base date used to calculate the base value for the range
<i>610</i>&nbsp;     *  of valid values in the parsed chronology, not null
<i>611</i>&nbsp;     * @return this, for chaining, not null
<i>612</i>&nbsp;     * @throws IllegalArgumentException if the width or base value is invalid
<i>613</i>&nbsp;     */
<i>614</i>&nbsp;    public DateTimeFormatterBuilder appendValueReduced(
<i>615</i>&nbsp;            TemporalField field, int width, int maxWidth, ChronoLocalDate baseDate) {
<i>616</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>617</i>&nbsp;        Objects.requireNonNull(baseDate, &quot;baseDate&quot;);
<i>618</i>&nbsp;        ReducedPrinterParser pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
<i>619</i>&nbsp;        appendValue(pp);
<i>620</i>&nbsp;        return this;
<i>621</i>&nbsp;    }
<i>622</i>&nbsp;
<i>623</i>&nbsp;    /**
<i>624</i>&nbsp;     * Appends a fixed or variable width printer-parser handling adjacent value mode.
<b class="nc"><i>625</i>&nbsp;     * If a PrinterParser is not active then the new PrinterParser becomes</b>
<b class="nc"><i>626</i>&nbsp;     * the active PrinterParser.</b>
<i>627</i>&nbsp;     * Otherwise, the active PrinterParser is modified depending on the new PrinterParser.
<i>628</i>&nbsp;     * If the new PrinterParser is fixed width and has sign style {@code NOT_NEGATIVE}
<b class="nc"><i>629</i>&nbsp;     * then its width is added to the active PP and</b>
<b class="nc"><i>630</i>&nbsp;     * the new PrinterParser is forced to be fixed width.</b>
<i>631</i>&nbsp;     * If the new PrinterParser is variable width, the active PrinterParser is changed
<b class="nc"><i>632</i>&nbsp;     * to be fixed width and the new PrinterParser becomes the active PP.</b>
<i>633</i>&nbsp;     *
<b class="nc"><i>634</i>&nbsp;     * @param pp  the printer-parser, not null</b>
<i>635</i>&nbsp;     * @return this, for chaining, not null
<b class="nc"><i>636</i>&nbsp;     */</b>
<i>637</i>&nbsp;    private DateTimeFormatterBuilder appendValue(NumberPrinterParser pp) {
<i>638</i>&nbsp;        if (active.valueParserIndex &gt;= 0) {
<b class="nc"><i>639</i>&nbsp;            final int activeValueParser = active.valueParserIndex;</b>
<i>640</i>&nbsp;
<b class="nc"><i>641</i>&nbsp;            // adjacent parsing mode, update setting in previous parsers</b>
<i>642</i>&nbsp;            NumberPrinterParser basePP = (NumberPrinterParser) active.printerParsers.get(activeValueParser);
<i>643</i>&nbsp;            if (pp.minWidth == pp.maxWidth &amp;&amp; pp.signStyle == SignStyle.NOT_NEGATIVE) {
<b class="nc"><i>644</i>&nbsp;                // Append the width to the subsequentWidth of the active parser</b>
<b class="nc"><i>645</i>&nbsp;                basePP = basePP.withSubsequentWidth(pp.maxWidth);</b>
<i>646</i>&nbsp;                // Append the new parser as a fixed width
<b class="nc"><i>647</i>&nbsp;                appendInternal(pp.withFixedWidth());</b>
<i>648</i>&nbsp;                // Retain the previous active parser
<b class="nc"><i>649</i>&nbsp;                active.valueParserIndex = activeValueParser;</b>
<i>650</i>&nbsp;            } else {
<i>651</i>&nbsp;                // Modify the active parser to be fixed width
<i>652</i>&nbsp;                basePP = basePP.withFixedWidth();
<i>653</i>&nbsp;                // The new parser becomes the mew active parser
<i>654</i>&nbsp;                active.valueParserIndex = appendInternal(pp);
<i>655</i>&nbsp;            }
<i>656</i>&nbsp;            // Replace the modified parser with the updated one
<i>657</i>&nbsp;            active.printerParsers.set(activeValueParser, basePP);
<i>658</i>&nbsp;        } else {
<i>659</i>&nbsp;            // The new Parser becomes the active parser
<i>660</i>&nbsp;            active.valueParserIndex = appendInternal(pp);
<i>661</i>&nbsp;        }
<i>662</i>&nbsp;        return this;
<i>663</i>&nbsp;    }
<i>664</i>&nbsp;
<i>665</i>&nbsp;    //-----------------------------------------------------------------------
<i>666</i>&nbsp;    /**
<i>667</i>&nbsp;     * Appends the fractional value of a date-time field to the formatter.
<i>668</i>&nbsp;     * &lt;p&gt;
<i>669</i>&nbsp;     * The fractional value of the field will be output including the
<i>670</i>&nbsp;     * preceding decimal point. The preceding value is not output.
<i>671</i>&nbsp;     * For example, the second-of-minute value of 15 would be output as {@code .25}.
<i>672</i>&nbsp;     * &lt;p&gt;
<i>673</i>&nbsp;     * The width of the printed fraction can be controlled. Setting the
<i>674</i>&nbsp;     * minimum width to zero will cause no output to be generated.
<i>675</i>&nbsp;     * The printed fraction will have the minimum width necessary between
<i>676</i>&nbsp;     * the minimum and maximum widths - trailing zeroes are omitted.
<i>677</i>&nbsp;     * No rounding occurs due to the maximum width - digits are simply dropped.
<i>678</i>&nbsp;     * &lt;p&gt;
<i>679</i>&nbsp;     * When parsing in strict mode, the number of parsed digits must be between
<i>680</i>&nbsp;     * the minimum and maximum width. In strict mode, if the minimum and maximum widths
<i>681</i>&nbsp;     * are equal and there is no decimal point then the parser will
<i>682</i>&nbsp;     * participate in adjacent value parsing, see
<i>683</i>&nbsp;     * {@link appendValue(java.time.temporal.TemporalField, int)}. When parsing in lenient mode,
<i>684</i>&nbsp;     * the minimum width is considered to be zero and the maximum is nine.
<i>685</i>&nbsp;     * &lt;p&gt;
<i>686</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<b class="nc"><i>687</i>&nbsp;     * If the value is negative an exception will be thrown.</b>
<b class="nc"><i>688</i>&nbsp;     * If the field does not have a fixed set of valid values then an</b>
<i>689</i>&nbsp;     * exception will be thrown.
<i>690</i>&nbsp;     * If the field value in the date-time to be printed is invalid it
<i>691</i>&nbsp;     * cannot be printed and an exception will be thrown.
<i>692</i>&nbsp;     *
<i>693</i>&nbsp;     * @param field  the field to append, not null
<i>694</i>&nbsp;     * @param minWidth  the minimum width of the field excluding the decimal point, from 0 to 9
<i>695</i>&nbsp;     * @param maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9
<i>696</i>&nbsp;     * @param decimalPoint  whether to output the localized decimal point symbol
<i>697</i>&nbsp;     * @return this, for chaining, not null
<i>698</i>&nbsp;     * @throws IllegalArgumentException if the field has a variable set of valid values or
<i>699</i>&nbsp;     *  either width is invalid
<i>700</i>&nbsp;     */
<i>701</i>&nbsp;    public DateTimeFormatterBuilder appendFraction(
<i>702</i>&nbsp;            TemporalField field, int minWidth, int maxWidth, boolean decimalPoint) {
<i>703</i>&nbsp;        if (minWidth == maxWidth &amp;&amp; decimalPoint == false) {
<i>704</i>&nbsp;            // adjacent parsing
<i>705</i>&nbsp;            appendValue(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
<i>706</i>&nbsp;        } else {
<i>707</i>&nbsp;            appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
<b class="nc"><i>708</i>&nbsp;        }</b>
<i>709</i>&nbsp;        return this;
<i>710</i>&nbsp;    }
<i>711</i>&nbsp;
<i>712</i>&nbsp;    //-----------------------------------------------------------------------
<i>713</i>&nbsp;    /**
<i>714</i>&nbsp;     * Appends the text of a date-time field to the formatter using the full
<i>715</i>&nbsp;     * text style.
<i>716</i>&nbsp;     * &lt;p&gt;
<i>717</i>&nbsp;     * The text of the field will be output during a format.
<i>718</i>&nbsp;     * The value must be within the valid range of the field.
<i>719</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<i>720</i>&nbsp;     * If the field has no textual representation, then the numeric value will be used.
<i>721</i>&nbsp;     * &lt;p&gt;
<i>722</i>&nbsp;     * The value will be printed as per the normal format of an integer value.
<i>723</i>&nbsp;     * Only negative numbers will be signed. No padding will be added.
<i>724</i>&nbsp;     *
<i>725</i>&nbsp;     * @param field  the field to append, not null
<i>726</i>&nbsp;     * @return this, for chaining, not null
<b class="nc"><i>727</i>&nbsp;     */</b>
<b class="nc"><i>728</i>&nbsp;    public DateTimeFormatterBuilder appendText(TemporalField field) {</b>
<b class="nc"><i>729</i>&nbsp;        return appendText(field, TextStyle.FULL);</b>
<b class="nc"><i>730</i>&nbsp;    }</b>
<i>731</i>&nbsp;
<i>732</i>&nbsp;    /**
<i>733</i>&nbsp;     * Appends the text of a date-time field to the formatter.
<i>734</i>&nbsp;     * &lt;p&gt;
<i>735</i>&nbsp;     * The text of the field will be output during a format.
<i>736</i>&nbsp;     * The value must be within the valid range of the field.
<i>737</i>&nbsp;     * If the value cannot be obtained then an exception will be thrown.
<i>738</i>&nbsp;     * If the field has no textual representation, then the numeric value will be used.
<i>739</i>&nbsp;     * &lt;p&gt;
<i>740</i>&nbsp;     * The value will be printed as per the normal format of an integer value.
<i>741</i>&nbsp;     * Only negative numbers will be signed. No padding will be added.
<i>742</i>&nbsp;     *
<i>743</i>&nbsp;     * @param field  the field to append, not null
<i>744</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>745</i>&nbsp;     * @return this, for chaining, not null
<i>746</i>&nbsp;     */
<i>747</i>&nbsp;    public DateTimeFormatterBuilder appendText(TemporalField field, TextStyle textStyle) {
<i>748</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>749</i>&nbsp;        Objects.requireNonNull(textStyle, &quot;textStyle&quot;);
<i>750</i>&nbsp;        appendInternal(new TextPrinterParser(field, textStyle, DateTimeTextProvider.getInstance()));
<i>751</i>&nbsp;        return this;
<i>752</i>&nbsp;    }
<i>753</i>&nbsp;
<i>754</i>&nbsp;    /**
<i>755</i>&nbsp;     * Appends the text of a date-time field to the formatter using the specified
<i>756</i>&nbsp;     * map to supply the text.
<i>757</i>&nbsp;     * &lt;p&gt;
<i>758</i>&nbsp;     * The standard text outputting methods use the localized text in the JDK.
<i>759</i>&nbsp;     * This method allows that text to be specified directly.
<i>760</i>&nbsp;     * The supplied map is not validated by the builder to ensure that formatting or
<i>761</i>&nbsp;     * parsing is possible, thus an invalid map may throw an error during later use.
<i>762</i>&nbsp;     * &lt;p&gt;
<i>763</i>&nbsp;     * Supplying the map of text provides considerable flexibility in formatting and parsing.
<i>764</i>&nbsp;     * For example, a legacy application might require or supply the months of the
<i>765</i>&nbsp;     * year as &quot;JNY&quot;, &quot;FBY&quot;, &quot;MCH&quot; etc. These do not match the standard set of text
<i>766</i>&nbsp;     * for localized month names. Using this method, a map can be created which
<i>767</i>&nbsp;     * defines the connection between each value and the text:
<b class="nc"><i>768</i>&nbsp;     * &lt;pre&gt;</b>
<b class="nc"><i>769</i>&nbsp;     * Map&amp;lt;Long, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();</b>
<b class="nc"><i>770</i>&nbsp;     * map.put(1L, &quot;JNY&quot;);</b>
<b class="nc"><i>771</i>&nbsp;     * map.put(2L, &quot;FBY&quot;);</b>
<b class="nc"><i>772</i>&nbsp;     * map.put(3L, &quot;MCH&quot;);</b>
<b class="nc"><i>773</i>&nbsp;     * ...</b>
<i>774</i>&nbsp;     * builder.appendText(MONTH_OF_YEAR, map);
<i>775</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>776</i>&nbsp;     * &lt;p&gt;</b>
<i>777</i>&nbsp;     * Other uses might be to output the value with a suffix, such as &quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;,
<i>778</i>&nbsp;     * or as Roman numerals &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;.
<i>779</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>780</i>&nbsp;     * During formatting, the value is obtained and checked that it is in the valid range.</b>
<i>781</i>&nbsp;     * If text is not available for the value then it is output as a number.
<i>782</i>&nbsp;     * During parsing, the parser will match against the map of text and numeric values.
<b class="nc"><i>783</i>&nbsp;     *</b>
<b class="nc"><i>784</i>&nbsp;     * @param field  the field to append, not null</b>
<i>785</i>&nbsp;     * @param textLookup  the map from the value to the text
<i>786</i>&nbsp;     * @return this, for chaining, not null
<i>787</i>&nbsp;     */
<i>788</i>&nbsp;    public DateTimeFormatterBuilder appendText(TemporalField field, Map&lt;Long, String&gt; textLookup) {
<i>789</i>&nbsp;        Objects.requireNonNull(field, &quot;field&quot;);
<i>790</i>&nbsp;        Objects.requireNonNull(textLookup, &quot;textLookup&quot;);
<i>791</i>&nbsp;        Map&lt;Long, String&gt; copy = new LinkedHashMap&lt;&gt;(textLookup);
<i>792</i>&nbsp;        Map&lt;TextStyle, Map&lt;Long, String&gt;&gt; map = Collections.singletonMap(TextStyle.FULL, copy);
<i>793</i>&nbsp;        final LocaleStore store = new LocaleStore(map);
<i>794</i>&nbsp;        DateTimeTextProvider provider = new DateTimeTextProvider() {
<i>795</i>&nbsp;            @Override
<i>796</i>&nbsp;            public String getText(Chronology chrono, TemporalField field,
<i>797</i>&nbsp;                                  long value, TextStyle style, Locale locale) {
<i>798</i>&nbsp;                return store.getText(value, style);
<i>799</i>&nbsp;            }
<i>800</i>&nbsp;            @Override
<i>801</i>&nbsp;            public String getText(TemporalField field, long value, TextStyle style, Locale locale) {
<i>802</i>&nbsp;                return store.getText(value, style);
<i>803</i>&nbsp;            }
<i>804</i>&nbsp;            @Override
<i>805</i>&nbsp;            public Iterator&lt;Entry&lt;String, Long&gt;&gt; getTextIterator(TemporalField field, TextStyle style, Locale locale) {
<i>806</i>&nbsp;                return store.getTextIterator(style);
<i>807</i>&nbsp;            }
<i>808</i>&nbsp;        };
<i>809</i>&nbsp;        appendInternal(new TextPrinterParser(field, TextStyle.FULL, provider));
<i>810</i>&nbsp;        return this;
<i>811</i>&nbsp;    }
<i>812</i>&nbsp;
<i>813</i>&nbsp;    //-----------------------------------------------------------------------
<b class="nc"><i>814</i>&nbsp;    /**</b>
<b class="nc"><i>815</i>&nbsp;     * Appends an instant using ISO-8601 to the formatter, formatting fractional</b>
<i>816</i>&nbsp;     * digits in groups of three.
<i>817</i>&nbsp;     * &lt;p&gt;
<i>818</i>&nbsp;     * Instants have a fixed output format.
<i>819</i>&nbsp;     * They are converted to a date-time with a zone-offset of UTC and formatted
<i>820</i>&nbsp;     * using the standard ISO-8601 format.
<i>821</i>&nbsp;     * With this method, formatting nano-of-second outputs zero, three, six
<i>822</i>&nbsp;     * or nine digits as necessary.
<i>823</i>&nbsp;     * The localized decimal style is not used.
<i>824</i>&nbsp;     * &lt;p&gt;
<i>825</i>&nbsp;     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
<i>826</i>&nbsp;     * and optionally {@code NANO_OF_SECOND}. The value of {@code INSTANT_SECONDS}
<i>827</i>&nbsp;     * may be outside the maximum range of {@code LocalDateTime}.
<i>828</i>&nbsp;     * &lt;p&gt;
<i>829</i>&nbsp;     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
<i>830</i>&nbsp;     * The end-of-day time of &#39;24:00&#39; is handled as midnight at the start of the following day.
<i>831</i>&nbsp;     * The leap-second time of &#39;23:59:59&#39; is handled to some degree, see
<i>832</i>&nbsp;     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
<i>833</i>&nbsp;     * &lt;p&gt;
<i>834</i>&nbsp;     * An alternative to this method is to format/parse the instant as a single
<i>835</i>&nbsp;     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.
<i>836</i>&nbsp;     *
<i>837</i>&nbsp;     * @return this, for chaining, not null
<i>838</i>&nbsp;     */
<i>839</i>&nbsp;    public DateTimeFormatterBuilder appendInstant() {
<i>840</i>&nbsp;        appendInternal(new InstantPrinterParser(-2));
<i>841</i>&nbsp;        return this;
<i>842</i>&nbsp;    }
<i>843</i>&nbsp;
<i>844</i>&nbsp;    /**
<i>845</i>&nbsp;     * Appends an instant using ISO-8601 to the formatter with control over
<i>846</i>&nbsp;     * the number of fractional digits.
<i>847</i>&nbsp;     * &lt;p&gt;
<i>848</i>&nbsp;     * Instants have a fixed output format, although this method provides some
<i>849</i>&nbsp;     * control over the fractional digits. They are converted to a date-time
<i>850</i>&nbsp;     * with a zone-offset of UTC and printed using the standard ISO-8601 format.
<i>851</i>&nbsp;     * The localized decimal style is not used.
<i>852</i>&nbsp;     * &lt;p&gt;
<i>853</i>&nbsp;     * The {@code fractionalDigits} parameter allows the output of the fractional
<b class="nc"><i>854</i>&nbsp;     * second to be controlled. Specifying zero will cause no fractional digits</b>
<b class="nc"><i>855</i>&nbsp;     * to be output. From 1 to 9 will output an increasing number of digits, using</b>
<i>856</i>&nbsp;     * zero right-padding if necessary. The special value -1 is used to output as
<b class="nc"><i>857</i>&nbsp;     * many digits as necessary to avoid any trailing zeroes.</b>
<b class="nc"><i>858</i>&nbsp;     * &lt;p&gt;</b>
<i>859</i>&nbsp;     * When parsing in strict mode, the number of parsed digits must match the
<i>860</i>&nbsp;     * fractional digits. When parsing in lenient mode, any number of fractional
<i>861</i>&nbsp;     * digits from zero to nine are accepted.
<i>862</i>&nbsp;     * &lt;p&gt;
<i>863</i>&nbsp;     * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
<i>864</i>&nbsp;     * and optionally {@code NANO_OF_SECOND}. The value of {@code INSTANT_SECONDS}
<i>865</i>&nbsp;     * may be outside the maximum range of {@code LocalDateTime}.
<i>866</i>&nbsp;     * &lt;p&gt;
<i>867</i>&nbsp;     * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
<i>868</i>&nbsp;     * The end-of-day time of &#39;24:00&#39; is handled as midnight at the start of the following day.
<i>869</i>&nbsp;     * The leap-second time of &#39;23:59:60&#39; is handled to some degree, see
<i>870</i>&nbsp;     * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
<b class="nc"><i>871</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>872</i>&nbsp;     * An alternative to this method is to format/parse the instant as a single</b>
<i>873</i>&nbsp;     * epoch-seconds value. That is achieved using {@code appendValue(INSTANT_SECONDS)}.
<i>874</i>&nbsp;     *
<i>875</i>&nbsp;     * @param fractionalDigits  the number of fractional second digits to format with,
<i>876</i>&nbsp;     *  from 0 to 9, or -1 to use as many digits as necessary
<i>877</i>&nbsp;     * @return this, for chaining, not null
<i>878</i>&nbsp;     * @throws IllegalArgumentException if the number of fractional digits is invalid
<i>879</i>&nbsp;     */
<i>880</i>&nbsp;    public DateTimeFormatterBuilder appendInstant(int fractionalDigits) {
<i>881</i>&nbsp;        if (fractionalDigits &lt; -1 || fractionalDigits &gt; 9) {
<i>882</i>&nbsp;            throw new IllegalArgumentException(&quot;The fractional digits must be from -1 to 9 inclusive but was &quot; + fractionalDigits);
<i>883</i>&nbsp;        }
<i>884</i>&nbsp;        appendInternal(new InstantPrinterParser(fractionalDigits));
<i>885</i>&nbsp;        return this;
<i>886</i>&nbsp;    }
<i>887</i>&nbsp;
<i>888</i>&nbsp;    //-----------------------------------------------------------------------
<i>889</i>&nbsp;    /**
<i>890</i>&nbsp;     * Appends the zone offset, such as &#39;+01:00&#39;, to the formatter.
<i>891</i>&nbsp;     * &lt;p&gt;
<i>892</i>&nbsp;     * This appends an instruction to format/parse the offset ID to the builder.
<i>893</i>&nbsp;     * This is equivalent to calling {@code appendOffset(&quot;+HH:mm:ss&quot;, &quot;Z&quot;)}.
<i>894</i>&nbsp;     * See {@link #appendOffset(String, String)} for details on formatting
<i>895</i>&nbsp;     * and parsing.
<i>896</i>&nbsp;     *
<i>897</i>&nbsp;     * @return this, for chaining, not null
<i>898</i>&nbsp;     */
<i>899</i>&nbsp;    public DateTimeFormatterBuilder appendOffsetId() {
<i>900</i>&nbsp;        appendInternal(OffsetIdPrinterParser.INSTANCE_ID_Z);
<i>901</i>&nbsp;        return this;
<i>902</i>&nbsp;    }
<i>903</i>&nbsp;
<i>904</i>&nbsp;    /**
<i>905</i>&nbsp;     * Appends the zone offset, such as &#39;+01:00&#39;, to the formatter.
<i>906</i>&nbsp;     * &lt;p&gt;
<i>907</i>&nbsp;     * This appends an instruction to format/parse the offset ID to the builder.
<i>908</i>&nbsp;     * &lt;p&gt;
<i>909</i>&nbsp;     * During formatting, the offset is obtained using a mechanism equivalent
<i>910</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#offset()}.
<i>911</i>&nbsp;     * It will be printed using the format defined below.
<i>912</i>&nbsp;     * If the offset cannot be obtained then an exception is thrown unless the
<i>913</i>&nbsp;     * section of the formatter is optional.
<b class="nc"><i>914</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>915</i>&nbsp;     * When parsing in strict mode, the input must contain the mandatory</b>
<i>916</i>&nbsp;     * and optional elements are defined by the specified pattern.
<i>917</i>&nbsp;     * If the offset cannot be parsed then an exception is thrown unless
<i>918</i>&nbsp;     * the section of the formatter is optional.
<i>919</i>&nbsp;     * &lt;p&gt;
<i>920</i>&nbsp;     * When parsing in lenient mode, only the hours are mandatory - minutes
<i>921</i>&nbsp;     * and seconds are optional. The colons are required if the specified
<i>922</i>&nbsp;     * pattern contains a colon. If the specified pattern is &quot;+HH&quot;, the
<i>923</i>&nbsp;     * presence of colons is determined by whether the character after the
<i>924</i>&nbsp;     * hour digits is a colon or not.
<i>925</i>&nbsp;     * If the offset cannot be parsed then an exception is thrown unless
<i>926</i>&nbsp;     * the section of the formatter is optional.
<i>927</i>&nbsp;     * &lt;p&gt;
<i>928</i>&nbsp;     * The format of the offset is controlled by a pattern which must be one
<i>929</i>&nbsp;     * of the following:
<i>930</i>&nbsp;     * &lt;ul&gt;
<i>931</i>&nbsp;     * &lt;li&gt;{@code +HH} - hour only, ignoring minute and second
<i>932</i>&nbsp;     * &lt;li&gt;{@code +HHmm} - hour, with minute if non-zero, ignoring second, no colon
<i>933</i>&nbsp;     * &lt;li&gt;{@code +HH:mm} - hour, with minute if non-zero, ignoring second, with colon
<i>934</i>&nbsp;     * &lt;li&gt;{@code +HHMM} - hour and minute, ignoring second, no colon
<i>935</i>&nbsp;     * &lt;li&gt;{@code +HH:MM} - hour and minute, ignoring second, with colon
<i>936</i>&nbsp;     * &lt;li&gt;{@code +HHMMss} - hour and minute, with second if non-zero, no colon
<i>937</i>&nbsp;     * &lt;li&gt;{@code +HH:MM:ss} - hour and minute, with second if non-zero, with colon
<i>938</i>&nbsp;     * &lt;li&gt;{@code +HHMMSS} - hour, minute and second, no colon
<i>939</i>&nbsp;     * &lt;li&gt;{@code +HH:MM:SS} - hour, minute and second, with colon
<i>940</i>&nbsp;     * &lt;li&gt;{@code +HHmmss} - hour, with minute if non-zero or with minute and
<i>941</i>&nbsp;     * second if non-zero, no colon
<i>942</i>&nbsp;     * &lt;li&gt;{@code +HH:mm:ss} - hour, with minute if non-zero or with minute and
<i>943</i>&nbsp;     * second if non-zero, with colon
<i>944</i>&nbsp;     * &lt;li&gt;{@code +H} - hour only, ignoring minute and second
<i>945</i>&nbsp;     * &lt;li&gt;{@code +Hmm} - hour, with minute if non-zero, ignoring second, no colon
<i>946</i>&nbsp;     * &lt;li&gt;{@code +H:mm} - hour, with minute if non-zero, ignoring second, with colon
<i>947</i>&nbsp;     * &lt;li&gt;{@code +HMM} - hour and minute, ignoring second, no colon
<b class="nc"><i>948</i>&nbsp;     * &lt;li&gt;{@code +H:MM} - hour and minute, ignoring second, with colon</b>
<b class="nc"><i>949</i>&nbsp;     * &lt;li&gt;{@code +HMMss} - hour and minute, with second if non-zero, no colon</b>
<b class="nc"><i>950</i>&nbsp;     * &lt;li&gt;{@code +H:MM:ss} - hour and minute, with second if non-zero, with colon</b>
<i>951</i>&nbsp;     * &lt;li&gt;{@code +HMMSS} - hour, minute and second, no colon
<b class="nc"><i>952</i>&nbsp;     * &lt;li&gt;{@code +H:MM:SS} - hour, minute and second, with colon</b>
<b class="nc"><i>953</i>&nbsp;     * &lt;li&gt;{@code +Hmmss} - hour, with minute if non-zero or with minute and</b>
<i>954</i>&nbsp;     * second if non-zero, no colon
<i>955</i>&nbsp;     * &lt;li&gt;{@code +H:mm:ss} - hour, with minute if non-zero or with minute and
<i>956</i>&nbsp;     * second if non-zero, with colon
<i>957</i>&nbsp;     * &lt;/ul&gt;
<i>958</i>&nbsp;     * Patterns containing &quot;HH&quot; will format and parse a two digit hour,
<i>959</i>&nbsp;     * zero-padded if necessary. Patterns containing &quot;H&quot; will format with no
<i>960</i>&nbsp;     * zero-padding, and parse either one or two digits.
<i>961</i>&nbsp;     * In lenient mode, the parser will be greedy and parse the maximum digits possible.
<i>962</i>&nbsp;     * The &quot;no offset&quot; text controls what text is printed when the total amount of
<i>963</i>&nbsp;     * the offset fields to be output is zero.
<i>964</i>&nbsp;     * Example values would be &#39;Z&#39;, &#39;+00:00&#39;, &#39;UTC&#39; or &#39;GMT&#39;.
<i>965</i>&nbsp;     * Three formats are accepted for parsing UTC - the &quot;no offset&quot; text, and the
<i>966</i>&nbsp;     * plus and minus versions of zero defined by the pattern.
<i>967</i>&nbsp;     *
<i>968</i>&nbsp;     * @param pattern  the pattern to use, not null
<i>969</i>&nbsp;     * @param noOffsetText  the text to use when the offset is zero, not null
<i>970</i>&nbsp;     * @return this, for chaining, not null
<i>971</i>&nbsp;     * @throws IllegalArgumentException if the pattern is invalid
<i>972</i>&nbsp;     */
<i>973</i>&nbsp;    public DateTimeFormatterBuilder appendOffset(String pattern, String noOffsetText) {
<i>974</i>&nbsp;        appendInternal(new OffsetIdPrinterParser(pattern, noOffsetText));
<i>975</i>&nbsp;        return this;
<i>976</i>&nbsp;    }
<i>977</i>&nbsp;
<i>978</i>&nbsp;    /**
<i>979</i>&nbsp;     * Appends the localized zone offset, such as &#39;GMT+01:00&#39;, to the formatter.
<i>980</i>&nbsp;     * &lt;p&gt;
<i>981</i>&nbsp;     * This appends a localized zone offset to the builder, the format of the
<i>982</i>&nbsp;     * localized offset is controlled by the specified {@link FormatStyle style}
<i>983</i>&nbsp;     * to this method:
<i>984</i>&nbsp;     * &lt;ul&gt;
<i>985</i>&nbsp;     * &lt;li&gt;{@link TextStyle#FULL full} - formats with localized offset text, such
<i>986</i>&nbsp;     * as &#39;GMT, 2-digit hour and minute field, optional second field if non-zero,
<i>987</i>&nbsp;     * and colon.
<i>988</i>&nbsp;     * &lt;li&gt;{@link TextStyle#SHORT short} - formats with localized offset text,
<i>989</i>&nbsp;     * such as &#39;GMT, hour without leading zero, optional 2-digit minute and
<i>990</i>&nbsp;     * second if non-zero, and colon.
<i>991</i>&nbsp;     * &lt;/ul&gt;
<i>992</i>&nbsp;     * &lt;p&gt;
<i>993</i>&nbsp;     * During formatting, the offset is obtained using a mechanism equivalent
<i>994</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#offset()}.
<i>995</i>&nbsp;     * If the offset cannot be obtained then an exception is thrown unless the
<i>996</i>&nbsp;     * section of the formatter is optional.
<i>997</i>&nbsp;     * &lt;p&gt;
<i>998</i>&nbsp;     * During parsing, the offset is parsed using the format defined above.
<i>999</i>&nbsp;     * If the offset cannot be parsed then an exception is thrown unless the
<i>1000</i>&nbsp;     * section of the formatter is optional.
<i>1001</i>&nbsp;     *
<i>1002</i>&nbsp;     * @param style  the format style to use, not null
<i>1003</i>&nbsp;     * @return this, for chaining, not null
<b class="nc"><i>1004</i>&nbsp;     * @throws IllegalArgumentException if style is neither {@link TextStyle#FULL</b>
<b class="nc"><i>1005</i>&nbsp;     * full} nor {@link TextStyle#SHORT short}</b>
<i>1006</i>&nbsp;     */
<i>1007</i>&nbsp;    public DateTimeFormatterBuilder appendLocalizedOffset(TextStyle style) {
<i>1008</i>&nbsp;        Objects.requireNonNull(style, &quot;style&quot;);
<i>1009</i>&nbsp;        if (style != TextStyle.FULL &amp;&amp; style != TextStyle.SHORT) {
<i>1010</i>&nbsp;            throw new IllegalArgumentException(&quot;Style must be either full or short&quot;);
<i>1011</i>&nbsp;        }
<i>1012</i>&nbsp;        appendInternal(new LocalizedOffsetIdPrinterParser(style));
<i>1013</i>&nbsp;        return this;
<i>1014</i>&nbsp;    }
<i>1015</i>&nbsp;
<i>1016</i>&nbsp;    //-----------------------------------------------------------------------
<i>1017</i>&nbsp;    /**
<i>1018</i>&nbsp;     * Appends the time-zone ID, such as &#39;Europe/Paris&#39; or &#39;+02:00&#39;, to the formatter.
<i>1019</i>&nbsp;     * &lt;p&gt;
<i>1020</i>&nbsp;     * This appends an instruction to format/parse the zone ID to the builder.
<i>1021</i>&nbsp;     * The zone ID is obtained in a strict manner suitable for {@code ZonedDateTime}.
<i>1022</i>&nbsp;     * By contrast, {@code OffsetDateTime} does not have a zone ID suitable
<i>1023</i>&nbsp;     * for use with this method, see {@link #appendZoneOrOffsetId()}.
<i>1024</i>&nbsp;     * &lt;p&gt;
<i>1025</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent
<i>1026</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zoneId()}.
<i>1027</i>&nbsp;     * It will be printed using the result of {@link ZoneId#getId()}.
<i>1028</i>&nbsp;     * If the zone cannot be obtained then an exception is thrown unless the
<i>1029</i>&nbsp;     * section of the formatter is optional.
<i>1030</i>&nbsp;     * &lt;p&gt;
<i>1031</i>&nbsp;     * During parsing, the text must match a known zone or offset.
<i>1032</i>&nbsp;     * There are two types of zone ID, offset-based, such as &#39;+01:30&#39; and
<i>1033</i>&nbsp;     * region-based, such as &#39;Europe/London&#39;. These are parsed differently.
<i>1034</i>&nbsp;     * If the parse starts with &#39;+&#39;, &#39;-&#39;, &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, then the parser
<i>1035</i>&nbsp;     * expects an offset-based zone and will not match region-based zones.
<i>1036</i>&nbsp;     * The offset ID, such as &#39;+02:30&#39;, may be at the start of the parse,
<i>1037</i>&nbsp;     * or prefixed by  &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;. The offset ID parsing is
<i>1038</i>&nbsp;     * equivalent to using {@link #appendOffset(String, String)} using the
<i>1039</i>&nbsp;     * arguments &#39;HH:MM:ss&#39; and the no offset string &#39;0&#39;.
<i>1040</i>&nbsp;     * If the parse starts with &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, and the parser cannot
<i>1041</i>&nbsp;     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
<i>1042</i>&nbsp;     * In all other cases, the list of known region-based zones is used to
<i>1043</i>&nbsp;     * find the longest available match. If no match is found, and the parse
<i>1044</i>&nbsp;     * starts with &#39;Z&#39;, then {@code ZoneOffset.UTC} is selected.
<i>1045</i>&nbsp;     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
<i>1046</i>&nbsp;     * &lt;p&gt;
<i>1047</i>&nbsp;     * For example, the following will parse:
<i>1048</i>&nbsp;     * &lt;pre&gt;
<i>1049</i>&nbsp;     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
<i>1050</i>&nbsp;     *   &quot;Z&quot;                       -- ZoneOffset.UTC
<i>1051</i>&nbsp;     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
<i>1052</i>&nbsp;     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
<i>1053</i>&nbsp;     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
<i>1054</i>&nbsp;     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1055</i>&nbsp;     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1056</i>&nbsp;     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1057</i>&nbsp;     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1058</i>&nbsp;     * &lt;/pre&gt;
<i>1059</i>&nbsp;     *
<b class="nc"><i>1060</i>&nbsp;     * @return this, for chaining, not null</b>
<b class="nc"><i>1061</i>&nbsp;     * @see #appendZoneRegionId()</b>
<i>1062</i>&nbsp;     */
<i>1063</i>&nbsp;    public DateTimeFormatterBuilder appendZoneId() {
<i>1064</i>&nbsp;        appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), &quot;ZoneId()&quot;));
<i>1065</i>&nbsp;        return this;
<i>1066</i>&nbsp;    }
<i>1067</i>&nbsp;
<i>1068</i>&nbsp;    /**
<i>1069</i>&nbsp;     * Appends the time-zone region ID, such as &#39;Europe/Paris&#39;, to the formatter,
<i>1070</i>&nbsp;     * rejecting the zone ID if it is a {@code ZoneOffset}.
<i>1071</i>&nbsp;     * &lt;p&gt;
<i>1072</i>&nbsp;     * This appends an instruction to format/parse the zone ID to the builder
<i>1073</i>&nbsp;     * only if it is a region-based ID.
<i>1074</i>&nbsp;     * &lt;p&gt;
<i>1075</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent
<i>1076</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zoneId()}.
<i>1077</i>&nbsp;     * If the zone is a {@code ZoneOffset} or it cannot be obtained then
<i>1078</i>&nbsp;     * an exception is thrown unless the section of the formatter is optional.
<i>1079</i>&nbsp;     * If the zone is not an offset, then the zone will be printed using
<i>1080</i>&nbsp;     * the zone ID from {@link ZoneId#getId()}.
<i>1081</i>&nbsp;     * &lt;p&gt;
<i>1082</i>&nbsp;     * During parsing, the text must match a known zone or offset.
<i>1083</i>&nbsp;     * There are two types of zone ID, offset-based, such as &#39;+01:30&#39; and
<i>1084</i>&nbsp;     * region-based, such as &#39;Europe/London&#39;. These are parsed differently.
<i>1085</i>&nbsp;     * If the parse starts with &#39;+&#39;, &#39;-&#39;, &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, then the parser
<i>1086</i>&nbsp;     * expects an offset-based zone and will not match region-based zones.
<i>1087</i>&nbsp;     * The offset ID, such as &#39;+02:30&#39;, may be at the start of the parse,
<i>1088</i>&nbsp;     * or prefixed by  &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;. The offset ID parsing is
<i>1089</i>&nbsp;     * equivalent to using {@link #appendOffset(String, String)} using the
<i>1090</i>&nbsp;     * arguments &#39;HH:MM:ss&#39; and the no offset string &#39;0&#39;.
<i>1091</i>&nbsp;     * If the parse starts with &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, and the parser cannot
<i>1092</i>&nbsp;     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
<i>1093</i>&nbsp;     * In all other cases, the list of known region-based zones is used to
<i>1094</i>&nbsp;     * find the longest available match. If no match is found, and the parse
<i>1095</i>&nbsp;     * starts with &#39;Z&#39;, then {@code ZoneOffset.UTC} is selected.
<i>1096</i>&nbsp;     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
<i>1097</i>&nbsp;     * &lt;p&gt;
<i>1098</i>&nbsp;     * For example, the following will parse:
<i>1099</i>&nbsp;     * &lt;pre&gt;
<i>1100</i>&nbsp;     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
<i>1101</i>&nbsp;     *   &quot;Z&quot;                       -- ZoneOffset.UTC
<i>1102</i>&nbsp;     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
<i>1103</i>&nbsp;     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
<i>1104</i>&nbsp;     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
<i>1105</i>&nbsp;     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1106</i>&nbsp;     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1107</i>&nbsp;     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1108</i>&nbsp;     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1109</i>&nbsp;     * &lt;/pre&gt;
<i>1110</i>&nbsp;     * &lt;p&gt;
<i>1111</i>&nbsp;     * Note that this method is identical to {@code appendZoneId()} except
<i>1112</i>&nbsp;     * in the mechanism used to obtain the zone.
<i>1113</i>&nbsp;     * Note also that parsing accepts offsets, whereas formatting will never
<i>1114</i>&nbsp;     * produce one.
<i>1115</i>&nbsp;     *
<b class="nc"><i>1116</i>&nbsp;     * @return this, for chaining, not null</b>
<b class="nc"><i>1117</i>&nbsp;     * @see #appendZoneId()</b>
<i>1118</i>&nbsp;     */
<i>1119</i>&nbsp;    public DateTimeFormatterBuilder appendZoneRegionId() {
<i>1120</i>&nbsp;        appendInternal(new ZoneIdPrinterParser(QUERY_REGION_ONLY, &quot;ZoneRegionId()&quot;));
<i>1121</i>&nbsp;        return this;
<i>1122</i>&nbsp;    }
<i>1123</i>&nbsp;
<i>1124</i>&nbsp;    /**
<i>1125</i>&nbsp;     * Appends the time-zone ID, such as &#39;Europe/Paris&#39; or &#39;+02:00&#39;, to
<i>1126</i>&nbsp;     * the formatter, using the best available zone ID.
<i>1127</i>&nbsp;     * &lt;p&gt;
<i>1128</i>&nbsp;     * This appends an instruction to format/parse the best available
<i>1129</i>&nbsp;     * zone or offset ID to the builder.
<i>1130</i>&nbsp;     * The zone ID is obtained in a lenient manner that first attempts to
<i>1131</i>&nbsp;     * find a true zone ID, such as that on {@code ZonedDateTime}, and
<i>1132</i>&nbsp;     * then attempts to find an offset, such as that on {@code OffsetDateTime}.
<i>1133</i>&nbsp;     * &lt;p&gt;
<i>1134</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent
<i>1135</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zone()}.
<i>1136</i>&nbsp;     * It will be printed using the result of {@link ZoneId#getId()}.
<i>1137</i>&nbsp;     * If the zone cannot be obtained then an exception is thrown unless the
<i>1138</i>&nbsp;     * section of the formatter is optional.
<i>1139</i>&nbsp;     * &lt;p&gt;
<i>1140</i>&nbsp;     * During parsing, the text must match a known zone or offset.
<i>1141</i>&nbsp;     * There are two types of zone ID, offset-based, such as &#39;+01:30&#39; and
<i>1142</i>&nbsp;     * region-based, such as &#39;Europe/London&#39;. These are parsed differently.
<i>1143</i>&nbsp;     * If the parse starts with &#39;+&#39;, &#39;-&#39;, &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, then the parser
<i>1144</i>&nbsp;     * expects an offset-based zone and will not match region-based zones.
<i>1145</i>&nbsp;     * The offset ID, such as &#39;+02:30&#39;, may be at the start of the parse,
<i>1146</i>&nbsp;     * or prefixed by  &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;. The offset ID parsing is
<i>1147</i>&nbsp;     * equivalent to using {@link #appendOffset(String, String)} using the
<i>1148</i>&nbsp;     * arguments &#39;HH:MM:ss&#39; and the no offset string &#39;0&#39;.
<i>1149</i>&nbsp;     * If the parse starts with &#39;UT&#39;, &#39;UTC&#39; or &#39;GMT&#39;, and the parser cannot
<i>1150</i>&nbsp;     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
<i>1151</i>&nbsp;     * In all other cases, the list of known region-based zones is used to
<b class="nc"><i>1152</i>&nbsp;     * find the longest available match. If no match is found, and the parse</b>
<b class="nc"><i>1153</i>&nbsp;     * starts with &#39;Z&#39;, then {@code ZoneOffset.UTC} is selected.</b>
<i>1154</i>&nbsp;     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
<i>1155</i>&nbsp;     * &lt;p&gt;
<i>1156</i>&nbsp;     * For example, the following will parse:
<i>1157</i>&nbsp;     * &lt;pre&gt;
<i>1158</i>&nbsp;     *   &quot;Europe/London&quot;           -- ZoneId.of(&quot;Europe/London&quot;)
<i>1159</i>&nbsp;     *   &quot;Z&quot;                       -- ZoneOffset.UTC
<i>1160</i>&nbsp;     *   &quot;UT&quot;                      -- ZoneId.of(&quot;UT&quot;)
<i>1161</i>&nbsp;     *   &quot;UTC&quot;                     -- ZoneId.of(&quot;UTC&quot;)
<i>1162</i>&nbsp;     *   &quot;GMT&quot;                     -- ZoneId.of(&quot;GMT&quot;)
<i>1163</i>&nbsp;     *   &quot;+01:30&quot;                  -- ZoneOffset.of(&quot;+01:30&quot;)
<i>1164</i>&nbsp;     *   &quot;UT+01:30&quot;                -- ZoneOffset.of(&quot;UT+01:30&quot;)
<i>1165</i>&nbsp;     *   &quot;UTC+01:30&quot;               -- ZoneOffset.of(&quot;UTC+01:30&quot;)
<i>1166</i>&nbsp;     *   &quot;GMT+01:30&quot;               -- ZoneOffset.of(&quot;GMT+01:30&quot;)
<i>1167</i>&nbsp;     * &lt;/pre&gt;
<i>1168</i>&nbsp;     * &lt;p&gt;
<i>1169</i>&nbsp;     * Note that this method is identical to {@code appendZoneId()} except
<i>1170</i>&nbsp;     * in the mechanism used to obtain the zone.
<i>1171</i>&nbsp;     *
<i>1172</i>&nbsp;     * @return this, for chaining, not null
<i>1173</i>&nbsp;     * @see #appendZoneId()
<i>1174</i>&nbsp;     */
<i>1175</i>&nbsp;    public DateTimeFormatterBuilder appendZoneOrOffsetId() {
<i>1176</i>&nbsp;        appendInternal(new ZoneIdPrinterParser(TemporalQueries.zone(), &quot;ZoneOrOffsetId()&quot;));
<i>1177</i>&nbsp;        return this;
<i>1178</i>&nbsp;    }
<i>1179</i>&nbsp;
<i>1180</i>&nbsp;    /**
<i>1181</i>&nbsp;     * Appends the time-zone name, such as &#39;British Summer Time&#39;, to the formatter.
<i>1182</i>&nbsp;     * &lt;p&gt;
<i>1183</i>&nbsp;     * This appends an instruction to format/parse the textual name of the zone to
<i>1184</i>&nbsp;     * the builder.
<i>1185</i>&nbsp;     * &lt;p&gt;
<i>1186</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent
<i>1187</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zoneId()}.
<i>1188</i>&nbsp;     * If the zone is a {@code ZoneOffset} it will be printed using the
<i>1189</i>&nbsp;     * result of {@link ZoneOffset#getId()}.
<i>1190</i>&nbsp;     * If the zone is not an offset, the textual name will be looked up
<i>1191</i>&nbsp;     * for the locale set in the {@link DateTimeFormatter}.
<i>1192</i>&nbsp;     * If the temporal object being printed represents an instant, or if it is a
<i>1193</i>&nbsp;     * local date-time that is not in a daylight saving gap or overlap then
<b class="nc"><i>1194</i>&nbsp;     * the text will be the summer or winter time text as appropriate.</b>
<b class="nc"><i>1195</i>&nbsp;     * If the lookup for text does not find any suitable result, then the</b>
<b class="nc"><i>1196</i>&nbsp;     * {@link ZoneId#getId() ID} will be printed.</b>
<i>1197</i>&nbsp;     * If the zone cannot be obtained then an exception is thrown unless the
<i>1198</i>&nbsp;     * section of the formatter is optional.
<i>1199</i>&nbsp;     * &lt;p&gt;
<i>1200</i>&nbsp;     * During parsing, either the textual zone name, the zone ID or the offset
<i>1201</i>&nbsp;     * is accepted. Many textual zone names are not unique, such as CST can be
<i>1202</i>&nbsp;     * for both &quot;Central Standard Time&quot; and &quot;China Standard Time&quot;. In this
<i>1203</i>&nbsp;     * situation, the zone id will be determined by the region information from
<i>1204</i>&nbsp;     * formatter&#39;s  {@link DateTimeFormatter#getLocale() locale} and the standard
<i>1205</i>&nbsp;     * zone id for that area, for example, America/New_York for the America Eastern
<i>1206</i>&nbsp;     * zone. The {@link #appendZoneText(TextStyle, Set)} may be used
<i>1207</i>&nbsp;     * to specify a set of preferred {@link ZoneId} in this situation.
<i>1208</i>&nbsp;     *
<i>1209</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>1210</i>&nbsp;     * @return this, for chaining, not null
<i>1211</i>&nbsp;     */
<i>1212</i>&nbsp;    public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle) {
<i>1213</i>&nbsp;        appendInternal(new ZoneTextPrinterParser(textStyle, null, false));
<i>1214</i>&nbsp;        return this;
<i>1215</i>&nbsp;    }
<i>1216</i>&nbsp;
<i>1217</i>&nbsp;    /**
<i>1218</i>&nbsp;     * Appends the time-zone name, such as &#39;British Summer Time&#39;, to the formatter.
<i>1219</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1220</i>&nbsp;     * This appends an instruction to format/parse the textual name of the zone to</b>
<b class="nc"><i>1221</i>&nbsp;     * the builder.</b>
<i>1222</i>&nbsp;     * &lt;p&gt;
<i>1223</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent
<i>1224</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zoneId()}.
<i>1225</i>&nbsp;     * If the zone is a {@code ZoneOffset} it will be printed using the
<i>1226</i>&nbsp;     * result of {@link ZoneOffset#getId()}.
<i>1227</i>&nbsp;     * If the zone is not an offset, the textual name will be looked up
<i>1228</i>&nbsp;     * for the locale set in the {@link DateTimeFormatter}.
<i>1229</i>&nbsp;     * If the temporal object being printed represents an instant, or if it is a
<i>1230</i>&nbsp;     * local date-time that is not in a daylight saving gap or overlap, then the text
<i>1231</i>&nbsp;     * will be the summer or winter time text as appropriate.
<i>1232</i>&nbsp;     * If the lookup for text does not find any suitable result, then the
<i>1233</i>&nbsp;     * {@link ZoneId#getId() ID} will be printed.
<b class="nc"><i>1234</i>&nbsp;     * If the zone cannot be obtained then an exception is thrown unless the</b>
<b class="nc"><i>1235</i>&nbsp;     * section of the formatter is optional.</b>
<b class="nc"><i>1236</i>&nbsp;     * &lt;p&gt;</b>
<i>1237</i>&nbsp;     * During parsing, either the textual zone name, the zone ID or the offset
<i>1238</i>&nbsp;     * is accepted. Many textual zone names are not unique, such as CST can be
<i>1239</i>&nbsp;     * for both &quot;Central Standard Time&quot; and &quot;China Standard Time&quot;. In this
<i>1240</i>&nbsp;     * situation, the zone id will be determined by the region information from
<i>1241</i>&nbsp;     * formatter&#39;s  {@link DateTimeFormatter#getLocale() locale} and the standard
<i>1242</i>&nbsp;     * zone id for that area, for example, America/New_York for the America Eastern
<i>1243</i>&nbsp;     * zone. This method also allows a set of preferred {@link ZoneId} to be
<i>1244</i>&nbsp;     * specified for parsing. The matched preferred zone id will be used if the
<i>1245</i>&nbsp;     * textural zone name being parsed is not unique.
<i>1246</i>&nbsp;     * &lt;p&gt;
<i>1247</i>&nbsp;     * If the zone cannot be parsed then an exception is thrown unless the
<i>1248</i>&nbsp;     * section of the formatter is optional.
<i>1249</i>&nbsp;     *
<i>1250</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>1251</i>&nbsp;     * @param preferredZones  the set of preferred zone ids, not null
<i>1252</i>&nbsp;     * @return this, for chaining, not null
<i>1253</i>&nbsp;     */
<i>1254</i>&nbsp;    public DateTimeFormatterBuilder appendZoneText(TextStyle textStyle,
<i>1255</i>&nbsp;                                                   Set&lt;ZoneId&gt; preferredZones) {
<i>1256</i>&nbsp;        Objects.requireNonNull(preferredZones, &quot;preferredZones&quot;);
<i>1257</i>&nbsp;        appendInternal(new ZoneTextPrinterParser(textStyle, preferredZones, false));
<i>1258</i>&nbsp;        return this;
<i>1259</i>&nbsp;    }
<i>1260</i>&nbsp;    //----------------------------------------------------------------------
<i>1261</i>&nbsp;    /**
<i>1262</i>&nbsp;     * Appends the generic time-zone name, such as &#39;Pacific Time&#39;, to the formatter.
<i>1263</i>&nbsp;     * &lt;p&gt;
<i>1264</i>&nbsp;     * This appends an instruction to format/parse the generic textual
<i>1265</i>&nbsp;     * name of the zone to the builder. The generic name is the same throughout the whole
<i>1266</i>&nbsp;     * year, ignoring any daylight saving changes. For example, &#39;Pacific Time&#39; is the
<i>1267</i>&nbsp;     * generic name, whereas &#39;Pacific Standard Time&#39; and &#39;Pacific Daylight Time&#39; are the
<i>1268</i>&nbsp;     * specific names, see {@link #appendZoneText(TextStyle)}.
<b class="nc"><i>1269</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1270</i>&nbsp;     * During formatting, the zone is obtained using a mechanism equivalent</b>
<i>1271</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#zoneId()}.
<b class="nc"><i>1272</i>&nbsp;     * If the zone is a {@code ZoneOffset} it will be printed using the</b>
<b class="nc"><i>1273</i>&nbsp;     * result of {@link ZoneOffset#getId()}.</b>
<i>1274</i>&nbsp;     * If the zone is not an offset, the textual name will be looked up
<i>1275</i>&nbsp;     * for the locale set in the {@link DateTimeFormatter}.
<i>1276</i>&nbsp;     * If the lookup for text does not find any suitable result, then the
<i>1277</i>&nbsp;     * {@link ZoneId#getId() ID} will be printed.
<i>1278</i>&nbsp;     * If the zone cannot be obtained then an exception is thrown unless the
<i>1279</i>&nbsp;     * section of the formatter is optional.
<i>1280</i>&nbsp;     * &lt;p&gt;
<i>1281</i>&nbsp;     * During parsing, either the textual zone name, the zone ID or the offset
<i>1282</i>&nbsp;     * is accepted. Many textual zone names are not unique, such as CST can be
<i>1283</i>&nbsp;     * for both &quot;Central Standard Time&quot; and &quot;China Standard Time&quot;. In this
<i>1284</i>&nbsp;     * situation, the zone id will be determined by the region information from
<i>1285</i>&nbsp;     * formatter&#39;s  {@link DateTimeFormatter#getLocale() locale} and the standard
<b class="nc"><i>1286</i>&nbsp;     * zone id for that area, for example, America/New_York for the America Eastern zone.</b>
<b class="nc"><i>1287</i>&nbsp;     * The {@link #appendGenericZoneText(TextStyle, Set)} may be used</b>
<i>1288</i>&nbsp;     * to specify a set of preferred {@link ZoneId} in this situation.
<i>1289</i>&nbsp;     *
<i>1290</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>1291</i>&nbsp;     * @return this, for chaining, not null
<i>1292</i>&nbsp;     * @since 9
<i>1293</i>&nbsp;     */
<i>1294</i>&nbsp;    public DateTimeFormatterBuilder appendGenericZoneText(TextStyle textStyle) {
<i>1295</i>&nbsp;        appendInternal(new ZoneTextPrinterParser(textStyle, null, true));
<i>1296</i>&nbsp;        return this;
<i>1297</i>&nbsp;    }
<i>1298</i>&nbsp;
<i>1299</i>&nbsp;    /**
<i>1300</i>&nbsp;     * Appends the generic time-zone name, such as &#39;Pacific Time&#39;, to the formatter.
<b class="nc"><i>1301</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1302</i>&nbsp;     * This appends an instruction to format/parse the generic textual</b>
<b class="nc"><i>1303</i>&nbsp;     * name of the zone to the builder. The generic name is the same throughout the whole</b>
<b class="nc"><i>1304</i>&nbsp;     * year, ignoring any daylight saving changes. For example, &#39;Pacific Time&#39; is the</b>
<i>1305</i>&nbsp;     * generic name, whereas &#39;Pacific Standard Time&#39; and &#39;Pacific Daylight Time&#39; are the
<b class="nc"><i>1306</i>&nbsp;     * specific names, see {@link #appendZoneText(TextStyle)}.</b>
<i>1307</i>&nbsp;     * &lt;p&gt;
<i>1308</i>&nbsp;     * This method also allows a set of preferred {@link ZoneId} to be
<b class="nc"><i>1309</i>&nbsp;     * specified for parsing. The matched preferred zone id will be used if the</b>
<i>1310</i>&nbsp;     * textural zone name being parsed is not unique.
<i>1311</i>&nbsp;     * &lt;p&gt;
<i>1312</i>&nbsp;     * See {@link #appendGenericZoneText(TextStyle)} for details about
<i>1313</i>&nbsp;     * formatting and parsing.
<i>1314</i>&nbsp;     *
<i>1315</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>1316</i>&nbsp;     * @param preferredZones  the set of preferred zone ids, not null
<i>1317</i>&nbsp;     * @return this, for chaining, not null
<i>1318</i>&nbsp;     * @since 9
<i>1319</i>&nbsp;     */
<i>1320</i>&nbsp;    public DateTimeFormatterBuilder appendGenericZoneText(TextStyle textStyle,
<i>1321</i>&nbsp;                                                          Set&lt;ZoneId&gt; preferredZones) {
<i>1322</i>&nbsp;        appendInternal(new ZoneTextPrinterParser(textStyle, preferredZones, true));
<b class="nc"><i>1323</i>&nbsp;        return this;</b>
<b class="nc"><i>1324</i>&nbsp;    }</b>
<b class="nc"><i>1325</i>&nbsp;</b>
<i>1326</i>&nbsp;    //-----------------------------------------------------------------------
<i>1327</i>&nbsp;    /**
<i>1328</i>&nbsp;     * Appends the chronology ID, such as &#39;ISO&#39; or &#39;ThaiBuddhist&#39;, to the formatter.
<i>1329</i>&nbsp;     * &lt;p&gt;
<i>1330</i>&nbsp;     * This appends an instruction to format/parse the chronology ID to the builder.
<i>1331</i>&nbsp;     * &lt;p&gt;
<i>1332</i>&nbsp;     * During formatting, the chronology is obtained using a mechanism equivalent
<i>1333</i>&nbsp;     * to querying the temporal with {@link TemporalQueries#chronology()}.
<i>1334</i>&nbsp;     * It will be printed using the result of {@link Chronology#getId()}.
<i>1335</i>&nbsp;     * If the chronology cannot be obtained then an exception is thrown unless the
<i>1336</i>&nbsp;     * section of the formatter is optional.
<i>1337</i>&nbsp;     * &lt;p&gt;
<i>1338</i>&nbsp;     * During parsing, the chronology is parsed and must match one of the chronologies
<i>1339</i>&nbsp;     * in {@link Chronology#getAvailableChronologies()}.
<i>1340</i>&nbsp;     * If the chronology cannot be parsed then an exception is thrown unless the
<i>1341</i>&nbsp;     * section of the formatter is optional.
<b class="nc"><i>1342</i>&nbsp;     * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.</b>
<b class="nc"><i>1343</i>&nbsp;     *</b>
<b class="nc"><i>1344</i>&nbsp;     * @return this, for chaining, not null</b>
<i>1345</i>&nbsp;     */
<i>1346</i>&nbsp;    public DateTimeFormatterBuilder appendChronologyId() {
<i>1347</i>&nbsp;        appendInternal(new ChronoPrinterParser(null));
<i>1348</i>&nbsp;        return this;
<i>1349</i>&nbsp;    }
<i>1350</i>&nbsp;
<i>1351</i>&nbsp;    /**
<i>1352</i>&nbsp;     * Appends the chronology name to the formatter.
<i>1353</i>&nbsp;     * &lt;p&gt;
<i>1354</i>&nbsp;     * The calendar system name will be output during a format.
<i>1355</i>&nbsp;     * If the chronology cannot be obtained then an exception will be thrown.
<i>1356</i>&nbsp;     *
<i>1357</i>&nbsp;     * @param textStyle  the text style to use, not null
<i>1358</i>&nbsp;     * @return this, for chaining, not null
<i>1359</i>&nbsp;     */
<i>1360</i>&nbsp;    public DateTimeFormatterBuilder appendChronologyText(TextStyle textStyle) {
<i>1361</i>&nbsp;        Objects.requireNonNull(textStyle, &quot;textStyle&quot;);
<i>1362</i>&nbsp;        appendInternal(new ChronoPrinterParser(textStyle));
<i>1363</i>&nbsp;        return this;
<i>1364</i>&nbsp;    }
<i>1365</i>&nbsp;
<i>1366</i>&nbsp;    //-----------------------------------------------------------------------
<i>1367</i>&nbsp;    /**
<i>1368</i>&nbsp;     * Appends a localized date-time pattern to the formatter.
<i>1369</i>&nbsp;     * &lt;p&gt;
<i>1370</i>&nbsp;     * This appends a localized section to the builder, suitable for outputting
<i>1371</i>&nbsp;     * a date, time or date-time combination. The format of the localized
<i>1372</i>&nbsp;     * section is lazily looked up based on four items:
<i>1373</i>&nbsp;     * &lt;ul&gt;
<i>1374</i>&nbsp;     * &lt;li&gt;the {@code dateStyle} specified to this method
<i>1375</i>&nbsp;     * &lt;li&gt;the {@code timeStyle} specified to this method
<i>1376</i>&nbsp;     * &lt;li&gt;the {@code Locale} of the {@code DateTimeFormatter}
<i>1377</i>&nbsp;     * &lt;li&gt;the {@code Chronology}, selecting the best available
<i>1378</i>&nbsp;     * &lt;/ul&gt;
<i>1379</i>&nbsp;     * During formatting, the chronology is obtained from the temporal object
<i>1380</i>&nbsp;     * being formatted, which may have been overridden by
<i>1381</i>&nbsp;     * {@link DateTimeFormatter#withChronology(Chronology)}.
<i>1382</i>&nbsp;     * The {@code FULL} and {@code LONG} styles typically require a time-zone.
<i>1383</i>&nbsp;     * When formatting using these styles, a {@code ZoneId} must be available,
<i>1384</i>&nbsp;     * either by using {@code ZonedDateTime} or {@link DateTimeFormatter#withZone}.
<i>1385</i>&nbsp;     * &lt;p&gt;
<i>1386</i>&nbsp;     * During parsing, if a chronology has already been parsed, then it is used.
<i>1387</i>&nbsp;     * Otherwise the default from {@code DateTimeFormatter.withChronology(Chronology)}
<i>1388</i>&nbsp;     * is used, with {@code IsoChronology} as the fallback.
<i>1389</i>&nbsp;     * &lt;p&gt;
<i>1390</i>&nbsp;     * Note that this method provides similar functionality to methods on
<i>1391</i>&nbsp;     * {@code DateFormat} such as {@link java.text.DateFormat#getDateTimeInstance(int, int)}.
<i>1392</i>&nbsp;     *
<i>1393</i>&nbsp;     * @param dateStyle  the date style to use, null means no date required
<i>1394</i>&nbsp;     * @param timeStyle  the time style to use, null means no time required
<i>1395</i>&nbsp;     * @return this, for chaining, not null
<i>1396</i>&nbsp;     * @throws IllegalArgumentException if both the date and time styles are null
<i>1397</i>&nbsp;     */
<i>1398</i>&nbsp;    public DateTimeFormatterBuilder appendLocalized(FormatStyle dateStyle, FormatStyle timeStyle) {
<i>1399</i>&nbsp;        if (dateStyle == null &amp;&amp; timeStyle == null) {
<i>1400</i>&nbsp;            throw new IllegalArgumentException(&quot;Either the date or time style must be non-null&quot;);
<i>1401</i>&nbsp;        }
<i>1402</i>&nbsp;        appendInternal(new LocalizedPrinterParser(dateStyle, timeStyle));
<i>1403</i>&nbsp;        return this;
<i>1404</i>&nbsp;    }
<i>1405</i>&nbsp;
<i>1406</i>&nbsp;    //-----------------------------------------------------------------------
<i>1407</i>&nbsp;    /**
<i>1408</i>&nbsp;     * Appends a character literal to the formatter.
<i>1409</i>&nbsp;     * &lt;p&gt;
<i>1410</i>&nbsp;     * This character will be output during a format.
<i>1411</i>&nbsp;     *
<i>1412</i>&nbsp;     * @param literal  the literal to append, not null
<i>1413</i>&nbsp;     * @return this, for chaining, not null
<i>1414</i>&nbsp;     */
<i>1415</i>&nbsp;    public DateTimeFormatterBuilder appendLiteral(char literal) {
<i>1416</i>&nbsp;        appendInternal(new CharLiteralPrinterParser(literal));
<i>1417</i>&nbsp;        return this;
<i>1418</i>&nbsp;    }
<i>1419</i>&nbsp;
<i>1420</i>&nbsp;    /**
<i>1421</i>&nbsp;     * Appends a string literal to the formatter.
<i>1422</i>&nbsp;     * &lt;p&gt;
<i>1423</i>&nbsp;     * This string will be output during a format.
<i>1424</i>&nbsp;     * &lt;p&gt;
<i>1425</i>&nbsp;     * If the literal is empty, nothing is added to the formatter.
<i>1426</i>&nbsp;     *
<i>1427</i>&nbsp;     * @param literal  the literal to append, not null
<i>1428</i>&nbsp;     * @return this, for chaining, not null
<i>1429</i>&nbsp;     */
<i>1430</i>&nbsp;    public DateTimeFormatterBuilder appendLiteral(String literal) {
<i>1431</i>&nbsp;        Objects.requireNonNull(literal, &quot;literal&quot;);
<i>1432</i>&nbsp;        if (literal.length() &gt; 0) {
<i>1433</i>&nbsp;            if (literal.length() == 1) {
<i>1434</i>&nbsp;                appendInternal(new CharLiteralPrinterParser(literal.charAt(0)));
<i>1435</i>&nbsp;            } else {
<i>1436</i>&nbsp;                appendInternal(new StringLiteralPrinterParser(literal));
<i>1437</i>&nbsp;            }
<i>1438</i>&nbsp;        }
<i>1439</i>&nbsp;        return this;
<i>1440</i>&nbsp;    }
<i>1441</i>&nbsp;
<i>1442</i>&nbsp;    //-----------------------------------------------------------------------
<i>1443</i>&nbsp;    /**
<i>1444</i>&nbsp;     * Appends all the elements of a formatter to the builder.
<i>1445</i>&nbsp;     * &lt;p&gt;
<i>1446</i>&nbsp;     * This method has the same effect as appending each of the constituent
<i>1447</i>&nbsp;     * parts of the formatter directly to this builder.
<i>1448</i>&nbsp;     *
<i>1449</i>&nbsp;     * @param formatter  the formatter to add, not null
<i>1450</i>&nbsp;     * @return this, for chaining, not null
<i>1451</i>&nbsp;     */
<i>1452</i>&nbsp;    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
<i>1453</i>&nbsp;        Objects.requireNonNull(formatter, &quot;formatter&quot;);
<i>1454</i>&nbsp;        appendInternal(formatter.toPrinterParser(false));
<i>1455</i>&nbsp;        return this;
<i>1456</i>&nbsp;    }
<i>1457</i>&nbsp;
<i>1458</i>&nbsp;    /**
<i>1459</i>&nbsp;     * Appends a formatter to the builder which will optionally format/parse.
<i>1460</i>&nbsp;     * &lt;p&gt;
<i>1461</i>&nbsp;     * This method has the same effect as appending each of the constituent
<i>1462</i>&nbsp;     * parts directly to this builder surrounded by an {@link #optionalStart()} and
<i>1463</i>&nbsp;     * {@link #optionalEnd()}.
<i>1464</i>&nbsp;     * &lt;p&gt;
<i>1465</i>&nbsp;     * The formatter will format if data is available for all the fields contained within it.
<i>1466</i>&nbsp;     * The formatter will parse if the string matches, otherwise no error is returned.
<i>1467</i>&nbsp;     *
<i>1468</i>&nbsp;     * @param formatter  the formatter to add, not null
<i>1469</i>&nbsp;     * @return this, for chaining, not null
<i>1470</i>&nbsp;     */
<i>1471</i>&nbsp;    public DateTimeFormatterBuilder appendOptional(DateTimeFormatter formatter) {
<i>1472</i>&nbsp;        Objects.requireNonNull(formatter, &quot;formatter&quot;);
<i>1473</i>&nbsp;        appendInternal(formatter.toPrinterParser(true));
<i>1474</i>&nbsp;        return this;
<i>1475</i>&nbsp;    }
<i>1476</i>&nbsp;
<i>1477</i>&nbsp;    //-----------------------------------------------------------------------
<i>1478</i>&nbsp;    /**
<i>1479</i>&nbsp;     * Appends the elements defined by the specified pattern to the builder.
<i>1480</i>&nbsp;     * &lt;p&gt;
<i>1481</i>&nbsp;     * All letters &#39;A&#39; to &#39;Z&#39; and &#39;a&#39; to &#39;z&#39; are reserved as pattern letters.
<i>1482</i>&nbsp;     * The characters &#39;#&#39;, &#39;{&#39; and &#39;}&#39; are reserved for future use.
<i>1483</i>&nbsp;     * The characters &#39;[&#39; and &#39;]&#39; indicate optional patterns.
<i>1484</i>&nbsp;     * The following pattern letters are defined:
<i>1485</i>&nbsp;     * &lt;pre&gt;
<i>1486</i>&nbsp;     *  Symbol  Meaning                     Presentation      Examples
<i>1487</i>&nbsp;     *  ------  -------                     ------------      -------
<i>1488</i>&nbsp;     *   G       era                         text              AD; Anno Domini; A
<i>1489</i>&nbsp;     *   u       year                        year              2004; 04
<i>1490</i>&nbsp;     *   y       year-of-era                 year              2004; 04
<i>1491</i>&nbsp;     *   D       day-of-year                 number            189
<i>1492</i>&nbsp;     *   M/L     month-of-year               number/text       7; 07; Jul; July; J
<i>1493</i>&nbsp;     *   d       day-of-month                number            10
<i>1494</i>&nbsp;     *   g       modified-julian-day         number            2451334
<i>1495</i>&nbsp;     *
<i>1496</i>&nbsp;     *   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
<i>1497</i>&nbsp;     *   Y       week-based-year             year              1996; 96
<i>1498</i>&nbsp;     *   w       week-of-week-based-year     number            27
<i>1499</i>&nbsp;     *   W       week-of-month               number            4
<i>1500</i>&nbsp;     *   E       day-of-week                 text              Tue; Tuesday; T
<i>1501</i>&nbsp;     *   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
<i>1502</i>&nbsp;     *   F       day-of-week-in-month        number            3
<i>1503</i>&nbsp;     *
<i>1504</i>&nbsp;     *   a       am-pm-of-day                text              PM
<i>1505</i>&nbsp;     *   h       clock-hour-of-am-pm (1-12)  number            12
<i>1506</i>&nbsp;     *   K       hour-of-am-pm (0-11)        number            0
<i>1507</i>&nbsp;     *   k       clock-hour-of-day (1-24)    number            24
<i>1508</i>&nbsp;     *
<i>1509</i>&nbsp;     *   H       hour-of-day (0-23)          number            0
<i>1510</i>&nbsp;     *   m       minute-of-hour              number            30
<i>1511</i>&nbsp;     *   s       second-of-minute            number            55
<i>1512</i>&nbsp;     *   S       fraction-of-second          fraction          978
<i>1513</i>&nbsp;     *   A       milli-of-day                number            1234
<i>1514</i>&nbsp;     *   n       nano-of-second              number            987654321
<i>1515</i>&nbsp;     *   N       nano-of-day                 number            1234000000
<i>1516</i>&nbsp;     *
<i>1517</i>&nbsp;     *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
<i>1518</i>&nbsp;     *   v       generic time-zone name      zone-name         PT, Pacific Time
<i>1519</i>&nbsp;     *   z       time-zone name              zone-name         Pacific Standard Time; PST
<i>1520</i>&nbsp;     *   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
<i>1521</i>&nbsp;     *   X       zone-offset &#39;Z&#39; for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15
<i>1522</i>&nbsp;     *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15
<i>1523</i>&nbsp;     *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00
<i>1524</i>&nbsp;     *
<i>1525</i>&nbsp;     *   p       pad next                    pad modifier      1
<i>1526</i>&nbsp;     *
<i>1527</i>&nbsp;     *   &#39;       escape for text             delimiter
<i>1528</i>&nbsp;     *   &#39;&#39;      single quote                literal           &#39;
<i>1529</i>&nbsp;     *   [       optional section start
<i>1530</i>&nbsp;     *   ]       optional section end
<i>1531</i>&nbsp;     *   #       reserved for future use
<i>1532</i>&nbsp;     *   {       reserved for future use
<i>1533</i>&nbsp;     *   }       reserved for future use
<i>1534</i>&nbsp;     * &lt;/pre&gt;
<i>1535</i>&nbsp;     * &lt;p&gt;
<i>1536</i>&nbsp;     * The count of pattern letters determine the format.
<i>1537</i>&nbsp;     * See &lt;a href=&quot;DateTimeFormatter.html#patterns&quot;&gt;DateTimeFormatter&lt;/a&gt; for a user-focused description of the patterns.
<i>1538</i>&nbsp;     * The following tables define how the pattern letters map to the builder.
<i>1539</i>&nbsp;     * &lt;p&gt;
<i>1540</i>&nbsp;     * &lt;b&gt;Date fields&lt;/b&gt;: Pattern letters to output a date.
<i>1541</i>&nbsp;     * &lt;pre&gt;
<i>1542</i>&nbsp;     *  Pattern  Count  Equivalent builder methods
<i>1543</i>&nbsp;     *  -------  -----  --------------------------
<i>1544</i>&nbsp;     *    G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
<i>1545</i>&nbsp;     *    GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
<i>1546</i>&nbsp;     *    GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
<i>1547</i>&nbsp;     *    GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
<i>1548</i>&nbsp;     *    GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)
<i>1549</i>&nbsp;     *
<i>1550</i>&nbsp;     *    u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL)
<i>1551</i>&nbsp;     *    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2000)
<i>1552</i>&nbsp;     *    uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL)
<i>1553</i>&nbsp;     *    u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD)
<i>1554</i>&nbsp;     *    y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL)
<i>1555</i>&nbsp;     *    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2000)
<i>1556</i>&nbsp;     *    yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL)
<i>1557</i>&nbsp;     *    y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD)
<i>1558</i>&nbsp;     *    Y       1      append special localized WeekFields element for numeric week-based-year
<i>1559</i>&nbsp;     *    YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits
<i>1560</i>&nbsp;     *    YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL)
<i>1561</i>&nbsp;     *    Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD)
<i>1562</i>&nbsp;     *
<i>1563</i>&nbsp;     *    Q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
<i>1564</i>&nbsp;     *    QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)
<i>1565</i>&nbsp;     *    QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
<i>1566</i>&nbsp;     *    QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
<i>1567</i>&nbsp;     *    QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
<i>1568</i>&nbsp;     *    q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
<b class="nc"><i>1569</i>&nbsp;     *    qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)</b>
<b class="nc"><i>1570</i>&nbsp;     *    qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)</b>
<b class="nc"><i>1571</i>&nbsp;     *    qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)</b>
<i>1572</i>&nbsp;     *    qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)
<i>1573</i>&nbsp;     *
<i>1574</i>&nbsp;     *    M       1      appendValue(ChronoField.MONTH_OF_YEAR)
<b class="nc"><i>1575</i>&nbsp;     *    MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)</b>
<b class="nc"><i>1576</i>&nbsp;     *    MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)</b>
<b class="nc"><i>1577</i>&nbsp;     *    MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)</b>
<b class="nc"><i>1578</i>&nbsp;     *    MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)</b>
<b class="nc"><i>1579</i>&nbsp;     *    L       1      appendValue(ChronoField.MONTH_OF_YEAR)</b>
<b class="nc"><i>1580</i>&nbsp;     *    LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)</b>
<i>1581</i>&nbsp;     *    LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
<b class="nc"><i>1582</i>&nbsp;     *    LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)</b>
<b class="nc"><i>1583</i>&nbsp;     *    LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)</b>
<b class="nc"><i>1584</i>&nbsp;     *</b>
<b class="nc"><i>1585</i>&nbsp;     *    w       1      append special localized WeekFields element for numeric week-of-year</b>
<b class="nc"><i>1586</i>&nbsp;     *    ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded</b>
<b class="nc"><i>1587</i>&nbsp;     *    W       1      append special localized WeekFields element for numeric week-of-month</b>
<b class="nc"><i>1588</i>&nbsp;     *    d       1      appendValue(ChronoField.DAY_OF_MONTH)</b>
<b class="nc"><i>1589</i>&nbsp;     *    dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)</b>
<b class="nc"><i>1590</i>&nbsp;     *    D       1      appendValue(ChronoField.DAY_OF_YEAR)</b>
<i>1591</i>&nbsp;     *    DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2, 3, SignStyle.NOT_NEGATIVE)
<i>1592</i>&nbsp;     *    DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
<b class="nc"><i>1593</i>&nbsp;     *    F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)</b>
<b class="nc"><i>1594</i>&nbsp;     *    g..g    1..n   appendValue(JulianFields.MODIFIED_JULIAN_DAY, n, 19, SignStyle.NORMAL)</b>
<i>1595</i>&nbsp;     *    E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
<i>1596</i>&nbsp;     *    EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
<b class="nc"><i>1597</i>&nbsp;     *    EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)</b>
<i>1598</i>&nbsp;     *    EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
<i>1599</i>&nbsp;     *    EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
<b class="nc"><i>1600</i>&nbsp;     *    e       1      append special localized WeekFields element for numeric day-of-week</b>
<b class="nc"><i>1601</i>&nbsp;     *    ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded</b>
<b class="nc"><i>1602</i>&nbsp;     *    eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)</b>
<b class="nc"><i>1603</i>&nbsp;     *    eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)</b>
<b class="nc"><i>1604</i>&nbsp;     *    eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)</b>
<b class="nc"><i>1605</i>&nbsp;     *    c       1      append special localized WeekFields element for numeric day-of-week</b>
<b class="nc"><i>1606</i>&nbsp;     *    ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)</b>
<b class="nc"><i>1607</i>&nbsp;     *    cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)</b>
<i>1608</i>&nbsp;     *    ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)
<b class="nc"><i>1609</i>&nbsp;     * &lt;/pre&gt;</b>
<i>1610</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1611</i>&nbsp;     * &lt;b&gt;Time fields&lt;/b&gt;: Pattern letters to output a time.</b>
<b class="nc"><i>1612</i>&nbsp;     * &lt;pre&gt;</b>
<b class="nc"><i>1613</i>&nbsp;     *  Pattern  Count  Equivalent builder methods</b>
<i>1614</i>&nbsp;     *  -------  -----  --------------------------
<b class="nc"><i>1615</i>&nbsp;     *    a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)</b>
<b class="nc"><i>1616</i>&nbsp;     *    h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)</b>
<b class="nc"><i>1617</i>&nbsp;     *    hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)</b>
<b class="nc"><i>1618</i>&nbsp;     *    H       1      appendValue(ChronoField.HOUR_OF_DAY)</b>
<b class="nc"><i>1619</i>&nbsp;     *    HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)</b>
<b class="nc"><i>1620</i>&nbsp;     *    k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)</b>
<b class="nc"><i>1621</i>&nbsp;     *    kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)</b>
<b class="nc"><i>1622</i>&nbsp;     *    K       1      appendValue(ChronoField.HOUR_OF_AMPM)</b>
<i>1623</i>&nbsp;     *    KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
<b class="nc"><i>1624</i>&nbsp;     *    m       1      appendValue(ChronoField.MINUTE_OF_HOUR)</b>
<i>1625</i>&nbsp;     *    mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
<b class="nc"><i>1626</i>&nbsp;     *    s       1      appendValue(ChronoField.SECOND_OF_MINUTE)</b>
<b class="nc"><i>1627</i>&nbsp;     *    ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)</b>
<b class="nc"><i>1628</i>&nbsp;     *</b>
<b class="nc"><i>1629</i>&nbsp;     *    S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)</b>
<b class="nc"><i>1630</i>&nbsp;     *    A..A    1..n   appendValue(ChronoField.MILLI_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)</b>
<i>1631</i>&nbsp;     *    n..n    1..n   appendValue(ChronoField.NANO_OF_SECOND, n, 19, SignStyle.NOT_NEGATIVE)
<b class="nc"><i>1632</i>&nbsp;     *    N..N    1..n   appendValue(ChronoField.NANO_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)</b>
<i>1633</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1634</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1635</i>&nbsp;     * &lt;b&gt;Zone ID&lt;/b&gt;: Pattern letters to output {@code ZoneId}.</b>
<b class="nc"><i>1636</i>&nbsp;     * &lt;pre&gt;</b>
<i>1637</i>&nbsp;     *  Pattern  Count  Equivalent builder methods
<b class="nc"><i>1638</i>&nbsp;     *  -------  -----  --------------------------</b>
<b class="nc"><i>1639</i>&nbsp;     *    VV      2      appendZoneId()</b>
<b class="nc"><i>1640</i>&nbsp;     *    v       1      appendGenericZoneText(TextStyle.SHORT)</b>
<b class="nc"><i>1641</i>&nbsp;     *    vvvv    4      appendGenericZoneText(TextStyle.FULL)</b>
<i>1642</i>&nbsp;     *    z       1      appendZoneText(TextStyle.SHORT)
<b class="nc"><i>1643</i>&nbsp;     *    zz      2      appendZoneText(TextStyle.SHORT)</b>
<b class="nc"><i>1644</i>&nbsp;     *    zzz     3      appendZoneText(TextStyle.SHORT)</b>
<b class="nc"><i>1645</i>&nbsp;     *    zzzz    4      appendZoneText(TextStyle.FULL)</b>
<i>1646</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1647</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1648</i>&nbsp;     * &lt;b&gt;Zone offset&lt;/b&gt;: Pattern letters to output {@code ZoneOffset}.</b>
<i>1649</i>&nbsp;     * &lt;pre&gt;
<b class="nc"><i>1650</i>&nbsp;     *  Pattern  Count  Equivalent builder methods</b>
<b class="nc"><i>1651</i>&nbsp;     *  -------  -----  --------------------------</b>
<i>1652</i>&nbsp;     *    O       1      appendLocalizedOffset(TextStyle.SHORT)
<b class="nc"><i>1653</i>&nbsp;     *    OOOO    4      appendLocalizedOffset(TextStyle.FULL)</b>
<b class="nc"><i>1654</i>&nbsp;     *    X       1      appendOffset(&quot;+HHmm&quot;,&quot;Z&quot;)</b>
<i>1655</i>&nbsp;     *    XX      2      appendOffset(&quot;+HHMM&quot;,&quot;Z&quot;)
<b class="nc"><i>1656</i>&nbsp;     *    XXX     3      appendOffset(&quot;+HH:MM&quot;,&quot;Z&quot;)</b>
<b class="nc"><i>1657</i>&nbsp;     *    XXXX    4      appendOffset(&quot;+HHMMss&quot;,&quot;Z&quot;)</b>
<i>1658</i>&nbsp;     *    XXXXX   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;)
<b class="nc"><i>1659</i>&nbsp;     *    x       1      appendOffset(&quot;+HHmm&quot;,&quot;+00&quot;)</b>
<i>1660</i>&nbsp;     *    xx      2      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
<b class="nc"><i>1661</i>&nbsp;     *    xxx     3      appendOffset(&quot;+HH:MM&quot;,&quot;+00:00&quot;)</b>
<i>1662</i>&nbsp;     *    xxxx    4      appendOffset(&quot;+HHMMss&quot;,&quot;+0000&quot;)
<b class="nc"><i>1663</i>&nbsp;     *    xxxxx   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;+00:00&quot;)</b>
<i>1664</i>&nbsp;     *    Z       1      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
<b class="nc"><i>1665</i>&nbsp;     *    ZZ      2      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)</b>
<i>1666</i>&nbsp;     *    ZZZ     3      appendOffset(&quot;+HHMM&quot;,&quot;+0000&quot;)
<b class="nc"><i>1667</i>&nbsp;     *    ZZZZ    4      appendLocalizedOffset(TextStyle.FULL)</b>
<b class="nc"><i>1668</i>&nbsp;     *    ZZZZZ   5      appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;)</b>
<b class="nc"><i>1669</i>&nbsp;     * &lt;/pre&gt;</b>
<b class="nc"><i>1670</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>1671</i>&nbsp;     * &lt;b&gt;Modifiers&lt;/b&gt;: Pattern letters that modify the rest of the pattern:</b>
<i>1672</i>&nbsp;     * &lt;pre&gt;
<i>1673</i>&nbsp;     *  Pattern  Count  Equivalent builder methods
<i>1674</i>&nbsp;     *  -------  -----  --------------------------
<i>1675</i>&nbsp;     *    [       1      optionalStart()
<i>1676</i>&nbsp;     *    ]       1      optionalEnd()
<b class="nc"><i>1677</i>&nbsp;     *    p..p    1..n   padNext(n)</b>
<b class="nc"><i>1678</i>&nbsp;     * &lt;/pre&gt;</b>
<i>1679</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1680</i>&nbsp;     * Any sequence of letters not specified above, unrecognized letter or</b>
<b class="nc"><i>1681</i>&nbsp;     * reserved character will throw an exception.</b>
<b class="nc"><i>1682</i>&nbsp;     * Future versions may add to the set of patterns.</b>
<i>1683</i>&nbsp;     * It is recommended to use single quotes around all characters that you want
<b class="nc"><i>1684</i>&nbsp;     * to output directly to ensure that future changes do not break your application.</b>
<i>1685</i>&nbsp;     * &lt;p&gt;
<i>1686</i>&nbsp;     * Note that the pattern string is similar, but not identical, to
<b class="nc"><i>1687</i>&nbsp;     * {@link java.text.SimpleDateFormat SimpleDateFormat}.</b>
<b class="nc"><i>1688</i>&nbsp;     * The pattern string is also similar, but not identical, to that defined by the</b>
<i>1689</i>&nbsp;     * Unicode Common Locale Data Repository (CLDR/LDML).
<b class="nc"><i>1690</i>&nbsp;     * Pattern letters &#39;X&#39; and &#39;u&#39; are aligned with Unicode CLDR/LDML.</b>
<b class="nc"><i>1691</i>&nbsp;     * By contrast, {@code SimpleDateFormat} uses &#39;u&#39; for the numeric day of week.</b>
<b class="nc"><i>1692</i>&nbsp;     * Pattern letters &#39;y&#39; and &#39;Y&#39; parse years of two digits and more than 4 digits differently.</b>
<i>1693</i>&nbsp;     * Pattern letters &#39;n&#39;, &#39;A&#39;, &#39;N&#39;, and &#39;p&#39; are added.
<b class="nc"><i>1694</i>&nbsp;     * Number types will reject large numbers.</b>
<i>1695</i>&nbsp;     *
<b class="nc"><i>1696</i>&nbsp;     * @param pattern  the pattern to add, not null</b>
<b class="nc"><i>1697</i>&nbsp;     * @return this, for chaining, not null</b>
<i>1698</i>&nbsp;     * @throws IllegalArgumentException if the pattern is invalid
<b class="nc"><i>1699</i>&nbsp;     */</b>
<i>1700</i>&nbsp;    public DateTimeFormatterBuilder appendPattern(String pattern) {
<i>1701</i>&nbsp;        Objects.requireNonNull(pattern, &quot;pattern&quot;);
<i>1702</i>&nbsp;        parsePattern(pattern);
<i>1703</i>&nbsp;        return this;
<i>1704</i>&nbsp;    }
<i>1705</i>&nbsp;
<b class="nc"><i>1706</i>&nbsp;    private void parsePattern(String pattern) {</b>
<b class="nc"><i>1707</i>&nbsp;        for (int pos = 0; pos &lt; pattern.length(); pos++) {</b>
<i>1708</i>&nbsp;            char cur = pattern.charAt(pos);
<i>1709</i>&nbsp;            if ((cur &gt;= &#39;A&#39; &amp;&amp; cur &lt;= &#39;Z&#39;) || (cur &gt;= &#39;a&#39; &amp;&amp; cur &lt;= &#39;z&#39;)) {
<b class="nc"><i>1710</i>&nbsp;                int start = pos++;</b>
<b class="nc"><i>1711</i>&nbsp;                for ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  // short loop</b>
<b class="nc"><i>1712</i>&nbsp;                int count = pos - start;</b>
<b class="nc"><i>1713</i>&nbsp;                // padding</b>
<i>1714</i>&nbsp;                if (cur == &#39;p&#39;) {
<b class="nc"><i>1715</i>&nbsp;                    int pad = 0;</b>
<i>1716</i>&nbsp;                    if (pos &lt; pattern.length()) {
<b class="nc"><i>1717</i>&nbsp;                        cur = pattern.charAt(pos);</b>
<i>1718</i>&nbsp;                        if ((cur &gt;= &#39;A&#39; &amp;&amp; cur &lt;= &#39;Z&#39;) || (cur &gt;= &#39;a&#39; &amp;&amp; cur &lt;= &#39;z&#39;)) {
<b class="nc"><i>1719</i>&nbsp;                            pad = count;</b>
<b class="nc"><i>1720</i>&nbsp;                            start = pos++;</b>
<i>1721</i>&nbsp;                            for ( ; pos &lt; pattern.length() &amp;&amp; pattern.charAt(pos) == cur; pos++);  // short loop
<i>1722</i>&nbsp;                            count = pos - start;
<i>1723</i>&nbsp;                        }
<i>1724</i>&nbsp;                    }
<b class="nc"><i>1725</i>&nbsp;                    if (pad == 0) {</b>
<i>1726</i>&nbsp;                        throw new IllegalArgumentException(
<i>1727</i>&nbsp;                                &quot;Pad letter &#39;p&#39; must be followed by valid pad pattern: &quot; + pattern);
<i>1728</i>&nbsp;                    }
<i>1729</i>&nbsp;                    padNext(pad); // pad and continue parsing
<i>1730</i>&nbsp;                }
<b class="nc"><i>1731</i>&nbsp;                // main rules</b>
<i>1732</i>&nbsp;                TemporalField field = FIELD_MAP.get(cur);
<i>1733</i>&nbsp;                if (field != null) {
<b class="nc"><i>1734</i>&nbsp;                    parseField(cur, count, field);</b>
<b class="nc"><i>1735</i>&nbsp;                } else if (cur == &#39;z&#39;) {</b>
<b class="nc"><i>1736</i>&nbsp;                    if (count &gt; 4) {</b>
<b class="nc"><i>1737</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</b>
<i>1738</i>&nbsp;                    } else if (count == 4) {
<b class="nc"><i>1739</i>&nbsp;                        appendZoneText(TextStyle.FULL);</b>
<b class="nc"><i>1740</i>&nbsp;                    } else {</b>
<i>1741</i>&nbsp;                        appendZoneText(TextStyle.SHORT);
<b class="nc"><i>1742</i>&nbsp;                    }</b>
<i>1743</i>&nbsp;                } else if (cur == &#39;V&#39;) {
<i>1744</i>&nbsp;                    if (count != 2) {
<b class="nc"><i>1745</i>&nbsp;                        throw new IllegalArgumentException(&quot;Pattern letter count must be 2: &quot; + cur);</b>
<i>1746</i>&nbsp;                    }
<b class="nc"><i>1747</i>&nbsp;                    appendZoneId();</b>
<b class="nc"><i>1748</i>&nbsp;                } else if (cur == &#39;v&#39;) {</b>
<i>1749</i>&nbsp;                    if (count == 1) {
<b class="nc"><i>1750</i>&nbsp;                        appendGenericZoneText(TextStyle.SHORT);</b>
<b class="nc"><i>1751</i>&nbsp;                    } else if (count == 4) {</b>
<i>1752</i>&nbsp;                        appendGenericZoneText(TextStyle.FULL);
<b class="nc"><i>1753</i>&nbsp;                    } else {</b>
<b class="nc"><i>1754</i>&nbsp;                        throw new IllegalArgumentException(&quot;Wrong number of  pattern letters: &quot; + cur);</b>
<i>1755</i>&nbsp;                    }
<b class="nc"><i>1756</i>&nbsp;                } else if (cur == &#39;Z&#39;) {</b>
<i>1757</i>&nbsp;                    if (count &lt; 4) {
<i>1758</i>&nbsp;                        appendOffset(&quot;+HHMM&quot;, &quot;+0000&quot;);
<i>1759</i>&nbsp;                    } else if (count == 4) {
<b class="nc"><i>1760</i>&nbsp;                        appendLocalizedOffset(TextStyle.FULL);</b>
<b class="nc"><i>1761</i>&nbsp;                    } else if (count == 5) {</b>
<i>1762</i>&nbsp;                        appendOffset(&quot;+HH:MM:ss&quot;,&quot;Z&quot;);
<b class="nc"><i>1763</i>&nbsp;                    } else {</b>
<i>1764</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1765</i>&nbsp;                    }
<i>1766</i>&nbsp;                } else if (cur == &#39;O&#39;) {
<b class="nc"><i>1767</i>&nbsp;                    if (count == 1) {</b>
<i>1768</i>&nbsp;                        appendLocalizedOffset(TextStyle.SHORT);
<i>1769</i>&nbsp;                    } else if (count == 4) {
<i>1770</i>&nbsp;                        appendLocalizedOffset(TextStyle.FULL);
<b class="nc"><i>1771</i>&nbsp;                    } else {</b>
<b class="nc"><i>1772</i>&nbsp;                        throw new IllegalArgumentException(&quot;Pattern letter count must be 1 or 4: &quot; + cur);</b>
<i>1773</i>&nbsp;                    }
<b class="nc"><i>1774</i>&nbsp;                } else if (cur == &#39;X&#39;) {</b>
<b class="nc"><i>1775</i>&nbsp;                    if (count &gt; 5) {</b>
<i>1776</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<b class="nc"><i>1777</i>&nbsp;                    }</b>
<b class="nc"><i>1778</i>&nbsp;                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == 1 ? 0 : 1)], &quot;Z&quot;);</b>
<i>1779</i>&nbsp;                } else if (cur == &#39;x&#39;) {
<b class="nc"><i>1780</i>&nbsp;                    if (count &gt; 5) {</b>
<i>1781</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1782</i>&nbsp;                    }
<i>1783</i>&nbsp;                    String zero = (count == 1 ? &quot;+00&quot; : (count % 2 == 0 ? &quot;+0000&quot; : &quot;+00:00&quot;));
<b class="nc"><i>1784</i>&nbsp;                    appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count == 1 ? 0 : 1)], zero);</b>
<b class="nc"><i>1785</i>&nbsp;                } else if (cur == &#39;W&#39;) {</b>
<i>1786</i>&nbsp;                    // Fields defined by Locale
<b class="nc"><i>1787</i>&nbsp;                    if (count &gt; 1) {</b>
<b class="nc"><i>1788</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);</b>
<i>1789</i>&nbsp;                    }
<b class="nc"><i>1790</i>&nbsp;                    appendValue(new WeekBasedFieldPrinterParser(cur, count, count, count));</b>
<i>1791</i>&nbsp;                } else if (cur == &#39;w&#39;) {
<i>1792</i>&nbsp;                    // Fields defined by Locale
<i>1793</i>&nbsp;                    if (count &gt; 2) {
<i>1794</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1795</i>&nbsp;                    }
<i>1796</i>&nbsp;                    appendValue(new WeekBasedFieldPrinterParser(cur, count, count, 2));
<i>1797</i>&nbsp;                } else if (cur == &#39;Y&#39;) {
<i>1798</i>&nbsp;                    // Fields defined by Locale
<i>1799</i>&nbsp;                    if (count == 2) {
<b class="nc"><i>1800</i>&nbsp;                        appendValue(new WeekBasedFieldPrinterParser(cur, count, count, 2));</b>
<b class="nc"><i>1801</i>&nbsp;                    } else {</b>
<b class="nc"><i>1802</i>&nbsp;                        appendValue(new WeekBasedFieldPrinterParser(cur, count, count, 19));</b>
<b class="nc"><i>1803</i>&nbsp;                    }</b>
<i>1804</i>&nbsp;                } else {
<b class="nc"><i>1805</i>&nbsp;                    throw new IllegalArgumentException(&quot;Unknown pattern letter: &quot; + cur);</b>
<i>1806</i>&nbsp;                }
<i>1807</i>&nbsp;                pos--;
<i>1808</i>&nbsp;
<b class="nc"><i>1809</i>&nbsp;            } else if (cur == &#39;\&#39;&#39;) {</b>
<b class="nc"><i>1810</i>&nbsp;                // parse literals</b>
<b class="nc"><i>1811</i>&nbsp;                int start = pos++;</b>
<b class="nc"><i>1812</i>&nbsp;                for ( ; pos &lt; pattern.length(); pos++) {</b>
<i>1813</i>&nbsp;                    if (pattern.charAt(pos) == &#39;\&#39;&#39;) {
<b class="nc"><i>1814</i>&nbsp;                        if (pos + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(pos + 1) == &#39;\&#39;&#39;) {</b>
<i>1815</i>&nbsp;                            pos++;
<i>1816</i>&nbsp;                        } else {
<i>1817</i>&nbsp;                            break;  // end of literal
<b class="nc"><i>1818</i>&nbsp;                        }</b>
<b class="nc"><i>1819</i>&nbsp;                    }</b>
<i>1820</i>&nbsp;                }
<b class="nc"><i>1821</i>&nbsp;                if (pos &gt;= pattern.length()) {</b>
<i>1822</i>&nbsp;                    throw new IllegalArgumentException(&quot;Pattern ends with an incomplete string literal: &quot; + pattern);
<i>1823</i>&nbsp;                }
<i>1824</i>&nbsp;                String str = pattern.substring(start + 1, pos);
<i>1825</i>&nbsp;                if (str.length() == 0) {
<i>1826</i>&nbsp;                    appendLiteral(&#39;\&#39;&#39;);
<i>1827</i>&nbsp;                } else {
<b class="nc"><i>1828</i>&nbsp;                    appendLiteral(str.replace(&quot;&#39;&#39;&quot;, &quot;&#39;&quot;));</b>
<i>1829</i>&nbsp;                }
<i>1830</i>&nbsp;
<b class="nc"><i>1831</i>&nbsp;            } else if (cur == &#39;[&#39;) {</b>
<b class="nc"><i>1832</i>&nbsp;                optionalStart();</b>
<b class="nc"><i>1833</i>&nbsp;</b>
<b class="nc"><i>1834</i>&nbsp;            } else if (cur == &#39;]&#39;) {</b>
<b class="nc"><i>1835</i>&nbsp;                if (active.parent == null) {</b>
<b class="nc"><i>1836</i>&nbsp;                    throw new IllegalArgumentException(&quot;Pattern invalid as it contains ] without previous [&quot;);</b>
<b class="nc"><i>1837</i>&nbsp;                }</b>
<b class="nc"><i>1838</i>&nbsp;                optionalEnd();</b>
<b class="nc"><i>1839</i>&nbsp;</b>
<b class="nc"><i>1840</i>&nbsp;            } else if (cur == &#39;{&#39; || cur == &#39;}&#39; || cur == &#39;#&#39;) {</b>
<b class="nc"><i>1841</i>&nbsp;                throw new IllegalArgumentException(&quot;Pattern includes reserved character: &#39;&quot; + cur + &quot;&#39;&quot;);</b>
<b class="nc"><i>1842</i>&nbsp;            } else {</b>
<b class="nc"><i>1843</i>&nbsp;                appendLiteral(cur);</b>
<b class="nc"><i>1844</i>&nbsp;            }</b>
<b class="nc"><i>1845</i>&nbsp;        }</b>
<b class="nc"><i>1846</i>&nbsp;    }</b>
<b class="nc"><i>1847</i>&nbsp;</b>
<b class="nc"><i>1848</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)</b>
<b class="nc"><i>1849</i>&nbsp;    private void parseField(char cur, int count, TemporalField field) {</b>
<b class="nc"><i>1850</i>&nbsp;        boolean standalone = false;</b>
<b class="nc"><i>1851</i>&nbsp;        switch (cur) {</b>
<b class="nc"><i>1852</i>&nbsp;            case &#39;u&#39;:</b>
<b class="nc"><i>1853</i>&nbsp;            case &#39;y&#39;:</b>
<b class="nc"><i>1854</i>&nbsp;                if (count == 2) {</b>
<i>1855</i>&nbsp;                    appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
<i>1856</i>&nbsp;                } else if (count &lt; 4) {
<i>1857</i>&nbsp;                    appendValue(field, count, 19, SignStyle.NORMAL);
<i>1858</i>&nbsp;                } else {
<i>1859</i>&nbsp;                    appendValue(field, count, 19, SignStyle.EXCEEDS_PAD);
<i>1860</i>&nbsp;                }
<i>1861</i>&nbsp;                break;
<i>1862</i>&nbsp;            case &#39;c&#39;:
<i>1863</i>&nbsp;                if (count == 1) {
<i>1864</i>&nbsp;                    appendValue(new WeekBasedFieldPrinterParser(cur, count, count, count));
<i>1865</i>&nbsp;                    break;
<i>1866</i>&nbsp;                } else if (count == 2) {
<i>1867</i>&nbsp;                    throw new IllegalArgumentException(&quot;Invalid pattern \&quot;cc\&quot;&quot;);
<i>1868</i>&nbsp;                }
<i>1869</i>&nbsp;                /*fallthrough*/
<i>1870</i>&nbsp;            case &#39;L&#39;:
<i>1871</i>&nbsp;            case &#39;q&#39;:
<i>1872</i>&nbsp;                standalone = true;
<i>1873</i>&nbsp;                /*fallthrough*/
<i>1874</i>&nbsp;            case &#39;M&#39;:
<i>1875</i>&nbsp;            case &#39;Q&#39;:
<i>1876</i>&nbsp;            case &#39;E&#39;:
<i>1877</i>&nbsp;            case &#39;e&#39;:
<i>1878</i>&nbsp;                switch (count) {
<i>1879</i>&nbsp;                    case 1:
<i>1880</i>&nbsp;                    case 2:
<i>1881</i>&nbsp;                        if (cur == &#39;e&#39;) {
<i>1882</i>&nbsp;                            appendValue(new WeekBasedFieldPrinterParser(cur, count, count, count));
<i>1883</i>&nbsp;                        } else if (cur == &#39;E&#39;) {
<i>1884</i>&nbsp;                            appendText(field, TextStyle.SHORT);
<i>1885</i>&nbsp;                        } else {
<i>1886</i>&nbsp;                            if (count == 1) {
<i>1887</i>&nbsp;                                appendValue(field);
<i>1888</i>&nbsp;                            } else {
<b class="nc"><i>1889</i>&nbsp;                                appendValue(field, 2);</b>
<i>1890</i>&nbsp;                            }
<i>1891</i>&nbsp;                        }
<i>1892</i>&nbsp;                        break;
<i>1893</i>&nbsp;                    case 3:
<i>1894</i>&nbsp;                        appendText(field, standalone ? TextStyle.SHORT_STANDALONE : TextStyle.SHORT);
<i>1895</i>&nbsp;                        break;
<i>1896</i>&nbsp;                    case 4:
<i>1897</i>&nbsp;                        appendText(field, standalone ? TextStyle.FULL_STANDALONE : TextStyle.FULL);
<i>1898</i>&nbsp;                        break;
<i>1899</i>&nbsp;                    case 5:
<i>1900</i>&nbsp;                        appendText(field, standalone ? TextStyle.NARROW_STANDALONE : TextStyle.NARROW);
<i>1901</i>&nbsp;                        break;
<i>1902</i>&nbsp;                    default:
<i>1903</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1904</i>&nbsp;                }
<i>1905</i>&nbsp;                break;
<i>1906</i>&nbsp;            case &#39;a&#39;:
<i>1907</i>&nbsp;                if (count == 1) {
<i>1908</i>&nbsp;                    appendText(field, TextStyle.SHORT);
<i>1909</i>&nbsp;                } else {
<i>1910</i>&nbsp;                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1911</i>&nbsp;                }
<i>1912</i>&nbsp;                break;
<i>1913</i>&nbsp;            case &#39;G&#39;:
<b class="nc"><i>1914</i>&nbsp;                switch (count) {</b>
<b class="nc"><i>1915</i>&nbsp;                    case 1:</b>
<i>1916</i>&nbsp;                    case 2:
<b class="nc"><i>1917</i>&nbsp;                    case 3:</b>
<b class="nc"><i>1918</i>&nbsp;                        appendText(field, TextStyle.SHORT);</b>
<b class="nc"><i>1919</i>&nbsp;                        break;</b>
<b class="nc"><i>1920</i>&nbsp;                    case 4:</b>
<i>1921</i>&nbsp;                        appendText(field, TextStyle.FULL);
<i>1922</i>&nbsp;                        break;
<i>1923</i>&nbsp;                    case 5:
<i>1924</i>&nbsp;                        appendText(field, TextStyle.NARROW);
<i>1925</i>&nbsp;                        break;
<i>1926</i>&nbsp;                    default:
<i>1927</i>&nbsp;                        throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1928</i>&nbsp;                }
<i>1929</i>&nbsp;                break;
<i>1930</i>&nbsp;            case &#39;S&#39;:
<i>1931</i>&nbsp;                appendFraction(NANO_OF_SECOND, count, count, false);
<i>1932</i>&nbsp;                break;
<i>1933</i>&nbsp;            case &#39;F&#39;:
<i>1934</i>&nbsp;                if (count == 1) {
<i>1935</i>&nbsp;                    appendValue(field);
<i>1936</i>&nbsp;                } else {
<i>1937</i>&nbsp;                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1938</i>&nbsp;                }
<i>1939</i>&nbsp;                break;
<i>1940</i>&nbsp;            case &#39;d&#39;:
<i>1941</i>&nbsp;            case &#39;h&#39;:
<i>1942</i>&nbsp;            case &#39;H&#39;:
<i>1943</i>&nbsp;            case &#39;k&#39;:
<i>1944</i>&nbsp;            case &#39;K&#39;:
<b class="nc"><i>1945</i>&nbsp;            case &#39;m&#39;:</b>
<b class="nc"><i>1946</i>&nbsp;            case &#39;s&#39;:</b>
<b class="nc"><i>1947</i>&nbsp;                if (count == 1) {</b>
<i>1948</i>&nbsp;                    appendValue(field);
<i>1949</i>&nbsp;                } else if (count == 2) {
<i>1950</i>&nbsp;                    appendValue(field, count);
<i>1951</i>&nbsp;                } else {
<i>1952</i>&nbsp;                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1953</i>&nbsp;                }
<i>1954</i>&nbsp;                break;
<i>1955</i>&nbsp;            case &#39;D&#39;:
<i>1956</i>&nbsp;                if (count == 1) {
<i>1957</i>&nbsp;                    appendValue(field);
<i>1958</i>&nbsp;                } else if (count == 2 || count == 3) {
<i>1959</i>&nbsp;                    appendValue(field, count, 3, SignStyle.NOT_NEGATIVE);
<i>1960</i>&nbsp;                } else {
<i>1961</i>&nbsp;                    throw new IllegalArgumentException(&quot;Too many pattern letters: &quot; + cur);
<i>1962</i>&nbsp;                }
<i>1963</i>&nbsp;                break;
<i>1964</i>&nbsp;            case &#39;g&#39;:
<i>1965</i>&nbsp;                appendValue(field, count, 19, SignStyle.NORMAL);
<i>1966</i>&nbsp;                break;
<i>1967</i>&nbsp;            case &#39;A&#39;:
<i>1968</i>&nbsp;            case &#39;n&#39;:
<i>1969</i>&nbsp;            case &#39;N&#39;:
<i>1970</i>&nbsp;                appendValue(field, count, 19, SignStyle.NOT_NEGATIVE);
<i>1971</i>&nbsp;                break;
<i>1972</i>&nbsp;            default:
<i>1973</i>&nbsp;                if (count == 1) {
<i>1974</i>&nbsp;                    appendValue(field);
<i>1975</i>&nbsp;                } else {
<b class="nc"><i>1976</i>&nbsp;                    appendValue(field, count);</b>
<b class="nc"><i>1977</i>&nbsp;                }</b>
<i>1978</i>&nbsp;                break;
<b class="nc"><i>1979</i>&nbsp;        }</b>
<b class="nc"><i>1980</i>&nbsp;    }</b>
<b class="nc"><i>1981</i>&nbsp;</b>
<b class="nc"><i>1982</i>&nbsp;    /** Map of letters to fields. */</b>
<b class="nc"><i>1983</i>&nbsp;    private static final Map&lt;Character, TemporalField&gt; FIELD_MAP = new HashMap&lt;&gt;();</b>
<b class="nc"><i>1984</i>&nbsp;    static {</b>
<i>1985</i>&nbsp;        // SDF = SimpleDateFormat
<b class="nc"><i>1986</i>&nbsp;        FIELD_MAP.put(&#39;G&#39;, ChronoField.ERA);                       // SDF, LDML (different to both for 1/2 chars)</b>
<i>1987</i>&nbsp;        FIELD_MAP.put(&#39;y&#39;, ChronoField.YEAR_OF_ERA);               // SDF, LDML
<i>1988</i>&nbsp;        FIELD_MAP.put(&#39;u&#39;, ChronoField.YEAR);                      // LDML (different in SDF)
<i>1989</i>&nbsp;        FIELD_MAP.put(&#39;Q&#39;, IsoFields.QUARTER_OF_YEAR);             // LDML (removed quarter from 310)
<i>1990</i>&nbsp;        FIELD_MAP.put(&#39;q&#39;, IsoFields.QUARTER_OF_YEAR);             // LDML (stand-alone)
<i>1991</i>&nbsp;        FIELD_MAP.put(&#39;M&#39;, ChronoField.MONTH_OF_YEAR);             // SDF, LDML
<i>1992</i>&nbsp;        FIELD_MAP.put(&#39;L&#39;, ChronoField.MONTH_OF_YEAR);             // SDF, LDML (stand-alone)
<i>1993</i>&nbsp;        FIELD_MAP.put(&#39;D&#39;, ChronoField.DAY_OF_YEAR);               // SDF, LDML
<i>1994</i>&nbsp;        FIELD_MAP.put(&#39;d&#39;, ChronoField.DAY_OF_MONTH);              // SDF, LDML
<i>1995</i>&nbsp;        FIELD_MAP.put(&#39;F&#39;, ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);  // SDF, LDML
<i>1996</i>&nbsp;        FIELD_MAP.put(&#39;E&#39;, ChronoField.DAY_OF_WEEK);               // SDF, LDML (different to both for 1/2 chars)
<b class="nc"><i>1997</i>&nbsp;        FIELD_MAP.put(&#39;c&#39;, ChronoField.DAY_OF_WEEK);               // LDML (stand-alone)</b>
<b class="nc"><i>1998</i>&nbsp;        FIELD_MAP.put(&#39;e&#39;, ChronoField.DAY_OF_WEEK);               // LDML (needs localized week number)</b>
<b class="nc"><i>1999</i>&nbsp;        FIELD_MAP.put(&#39;a&#39;, ChronoField.AMPM_OF_DAY);               // SDF, LDML</b>
<b class="nc"><i>2000</i>&nbsp;        FIELD_MAP.put(&#39;H&#39;, ChronoField.HOUR_OF_DAY);               // SDF, LDML</b>
<i>2001</i>&nbsp;        FIELD_MAP.put(&#39;k&#39;, ChronoField.CLOCK_HOUR_OF_DAY);         // SDF, LDML
<b class="nc"><i>2002</i>&nbsp;        FIELD_MAP.put(&#39;K&#39;, ChronoField.HOUR_OF_AMPM);              // SDF, LDML</b>
<b class="nc"><i>2003</i>&nbsp;        FIELD_MAP.put(&#39;h&#39;, ChronoField.CLOCK_HOUR_OF_AMPM);        // SDF, LDML</b>
<i>2004</i>&nbsp;        FIELD_MAP.put(&#39;m&#39;, ChronoField.MINUTE_OF_HOUR);            // SDF, LDML
<b class="nc"><i>2005</i>&nbsp;        FIELD_MAP.put(&#39;s&#39;, ChronoField.SECOND_OF_MINUTE);          // SDF, LDML</b>
<b class="nc"><i>2006</i>&nbsp;        FIELD_MAP.put(&#39;S&#39;, ChronoField.NANO_OF_SECOND);            // LDML (SDF uses milli-of-second number)</b>
<b class="nc"><i>2007</i>&nbsp;        FIELD_MAP.put(&#39;A&#39;, ChronoField.MILLI_OF_DAY);              // LDML</b>
<i>2008</i>&nbsp;        FIELD_MAP.put(&#39;n&#39;, ChronoField.NANO_OF_SECOND);            // 310 (proposed for LDML)
<i>2009</i>&nbsp;        FIELD_MAP.put(&#39;N&#39;, ChronoField.NANO_OF_DAY);               // 310 (proposed for LDML)
<i>2010</i>&nbsp;        FIELD_MAP.put(&#39;g&#39;, JulianFields.MODIFIED_JULIAN_DAY);
<i>2011</i>&nbsp;        // 310 - z - time-zone names, matches LDML and SimpleDateFormat 1 to 4
<i>2012</i>&nbsp;        // 310 - Z - matches SimpleDateFormat and LDML
<i>2013</i>&nbsp;        // 310 - V - time-zone id, matches LDML
<i>2014</i>&nbsp;        // 310 - v - general timezone names, not matching exactly with LDML because LDML specify to fall back
<i>2015</i>&nbsp;        //           to &#39;VVVV&#39; if general-nonlocation unavailable but here it&#39;s not falling back because of lack of data
<i>2016</i>&nbsp;        // 310 - p - prefix for padding
<i>2017</i>&nbsp;        // 310 - X - matches LDML, almost matches SDF for 1, exact match 2&amp;3, extended 4&amp;5
<i>2018</i>&nbsp;        // 310 - x - matches LDML
<i>2019</i>&nbsp;        // 310 - w, W, and Y are localized forms matching LDML
<i>2020</i>&nbsp;        // LDML - U - cycle year name, not supported by 310 yet
<i>2021</i>&nbsp;        // LDML - l - deprecated
<i>2022</i>&nbsp;        // LDML - j - not relevant
<i>2023</i>&nbsp;    }
<i>2024</i>&nbsp;
<i>2025</i>&nbsp;    //-----------------------------------------------------------------------
<i>2026</i>&nbsp;    /**
<i>2027</i>&nbsp;     * Causes the next added printer/parser to pad to a fixed width using a space.
<b class="nc"><i>2028</i>&nbsp;     * &lt;p&gt;</b>
<i>2029</i>&nbsp;     * This padding will pad to a fixed width using spaces.
<i>2030</i>&nbsp;     * &lt;p&gt;
<i>2031</i>&nbsp;     * During formatting, the decorated element will be output and then padded
<i>2032</i>&nbsp;     * to the specified width. An exception will be thrown during formatting if
<i>2033</i>&nbsp;     * the pad width is exceeded.
<i>2034</i>&nbsp;     * &lt;p&gt;
<i>2035</i>&nbsp;     * During parsing, the padding and decorated element are parsed.
<i>2036</i>&nbsp;     * If parsing is lenient, then the pad width is treated as a maximum.
<i>2037</i>&nbsp;     * The padding is parsed greedily. Thus, if the decorated element starts with
<i>2038</i>&nbsp;     * the pad character, it will not be parsed.
<i>2039</i>&nbsp;     *
<i>2040</i>&nbsp;     * @param padWidth  the pad width, 1 or greater
<i>2041</i>&nbsp;     * @return this, for chaining, not null
<i>2042</i>&nbsp;     * @throws IllegalArgumentException if pad width is too small
<i>2043</i>&nbsp;     */
<i>2044</i>&nbsp;    public DateTimeFormatterBuilder padNext(int padWidth) {
<i>2045</i>&nbsp;        return padNext(padWidth, &#39; &#39;);
<i>2046</i>&nbsp;    }
<i>2047</i>&nbsp;
<i>2048</i>&nbsp;    /**
<b class="nc"><i>2049</i>&nbsp;     * Causes the next added printer/parser to pad to a fixed width.</b>
<i>2050</i>&nbsp;     * &lt;p&gt;
<i>2051</i>&nbsp;     * This padding is intended for padding other than zero-padding.
<i>2052</i>&nbsp;     * Zero-padding should be achieved using the appendValue methods.
<i>2053</i>&nbsp;     * &lt;p&gt;
<i>2054</i>&nbsp;     * During formatting, the decorated element will be output and then padded
<i>2055</i>&nbsp;     * to the specified width. An exception will be thrown during formatting if
<i>2056</i>&nbsp;     * the pad width is exceeded.
<i>2057</i>&nbsp;     * &lt;p&gt;
<i>2058</i>&nbsp;     * During parsing, the padding and decorated element are parsed.
<i>2059</i>&nbsp;     * If parsing is lenient, then the pad width is treated as a maximum.
<b class="nc"><i>2060</i>&nbsp;     * If parsing is case insensitive, then the pad character is matched ignoring case.</b>
<i>2061</i>&nbsp;     * The padding is parsed greedily. Thus, if the decorated element starts with
<i>2062</i>&nbsp;     * the pad character, it will not be parsed.
<i>2063</i>&nbsp;     *
<i>2064</i>&nbsp;     * @param padWidth  the pad width, 1 or greater
<i>2065</i>&nbsp;     * @param padChar  the pad character
<i>2066</i>&nbsp;     * @return this, for chaining, not null
<i>2067</i>&nbsp;     * @throws IllegalArgumentException if pad width is too small
<i>2068</i>&nbsp;     */
<i>2069</i>&nbsp;    public DateTimeFormatterBuilder padNext(int padWidth, char padChar) {
<i>2070</i>&nbsp;        if (padWidth &lt; 1) {
<b class="nc"><i>2071</i>&nbsp;            throw new IllegalArgumentException(&quot;The pad width must be at least one but was &quot; + padWidth);</b>
<b class="nc"><i>2072</i>&nbsp;        }</b>
<b class="nc"><i>2073</i>&nbsp;        active.padNextWidth = padWidth;</b>
<i>2074</i>&nbsp;        active.padNextChar = padChar;
<b class="nc"><i>2075</i>&nbsp;        active.valueParserIndex = -1;</b>
<b class="nc"><i>2076</i>&nbsp;        return this;</b>
<i>2077</i>&nbsp;    }
<i>2078</i>&nbsp;
<i>2079</i>&nbsp;    //-----------------------------------------------------------------------
<i>2080</i>&nbsp;    /**
<i>2081</i>&nbsp;     * Mark the start of an optional section.
<i>2082</i>&nbsp;     * &lt;p&gt;
<i>2083</i>&nbsp;     * The output of formatting can include optional sections, which may be nested.
<i>2084</i>&nbsp;     * An optional section is started by calling this method and ended by calling
<i>2085</i>&nbsp;     * {@link #optionalEnd()} or by ending the build process.
<i>2086</i>&nbsp;     * &lt;p&gt;
<i>2087</i>&nbsp;     * All elements in the optional section are treated as optional.
<i>2088</i>&nbsp;     * During formatting, the section is only output if data is available in the
<i>2089</i>&nbsp;     * {@code TemporalAccessor} for all the elements in the section.
<i>2090</i>&nbsp;     * During parsing, the whole section may be missing from the parsed string.
<i>2091</i>&nbsp;     * &lt;p&gt;
<i>2092</i>&nbsp;     * For example, consider a builder setup as
<i>2093</i>&nbsp;     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)}.
<i>2094</i>&nbsp;     * The optional section ends automatically at the end of the builder.
<i>2095</i>&nbsp;     * During formatting, the minute will only be output if its value can be obtained from the date-time.
<i>2096</i>&nbsp;     * During parsing, the input will be successfully parsed whether the minute is present or not.
<i>2097</i>&nbsp;     *
<i>2098</i>&nbsp;     * @return this, for chaining, not null
<i>2099</i>&nbsp;     */
<i>2100</i>&nbsp;    public DateTimeFormatterBuilder optionalStart() {
<i>2101</i>&nbsp;        active.valueParserIndex = -1;
<i>2102</i>&nbsp;        active = new DateTimeFormatterBuilder(active, true);
<i>2103</i>&nbsp;        return this;
<i>2104</i>&nbsp;    }
<i>2105</i>&nbsp;
<i>2106</i>&nbsp;    /**
<i>2107</i>&nbsp;     * Ends an optional section.
<i>2108</i>&nbsp;     * &lt;p&gt;
<i>2109</i>&nbsp;     * The output of formatting can include optional sections, which may be nested.
<i>2110</i>&nbsp;     * An optional section is started by calling {@link #optionalStart()} and ended
<i>2111</i>&nbsp;     * using this method (or at the end of the builder).
<i>2112</i>&nbsp;     * &lt;p&gt;
<i>2113</i>&nbsp;     * Calling this method without having previously called {@code optionalStart}
<i>2114</i>&nbsp;     * will throw an exception.
<i>2115</i>&nbsp;     * Calling this method immediately after calling {@code optionalStart} has no effect
<i>2116</i>&nbsp;     * on the formatter other than ending the (empty) optional section.
<i>2117</i>&nbsp;     * &lt;p&gt;
<i>2118</i>&nbsp;     * All elements in the optional section are treated as optional.
<i>2119</i>&nbsp;     * During formatting, the section is only output if data is available in the
<i>2120</i>&nbsp;     * {@code TemporalAccessor} for all the elements in the section.
<i>2121</i>&nbsp;     * During parsing, the whole section may be missing from the parsed string.
<i>2122</i>&nbsp;     * &lt;p&gt;
<i>2123</i>&nbsp;     * For example, consider a builder setup as
<i>2124</i>&nbsp;     * {@code builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()}.
<i>2125</i>&nbsp;     * During formatting, the minute will only be output if its value can be obtained from the date-time.
<i>2126</i>&nbsp;     * During parsing, the input will be successfully parsed whether the minute is present or not.
<i>2127</i>&nbsp;     *
<i>2128</i>&nbsp;     * @return this, for chaining, not null
<i>2129</i>&nbsp;     * @throws IllegalStateException if there was no previous call to {@code optionalStart}
<i>2130</i>&nbsp;     */
<i>2131</i>&nbsp;    public DateTimeFormatterBuilder optionalEnd() {
<i>2132</i>&nbsp;        if (active.parent == null) {
<i>2133</i>&nbsp;            throw new IllegalStateException(&quot;Cannot call optionalEnd() as there was no previous call to optionalStart()&quot;);
<i>2134</i>&nbsp;        }
<i>2135</i>&nbsp;        if (active.printerParsers.size() &gt; 0) {
<i>2136</i>&nbsp;            CompositePrinterParser cpp = new CompositePrinterParser(active.printerParsers, active.optional);
<i>2137</i>&nbsp;            active = active.parent;
<i>2138</i>&nbsp;            appendInternal(cpp);
<i>2139</i>&nbsp;        } else {
<i>2140</i>&nbsp;            active = active.parent;
<i>2141</i>&nbsp;        }
<i>2142</i>&nbsp;        return this;
<i>2143</i>&nbsp;    }
<i>2144</i>&nbsp;
<i>2145</i>&nbsp;    //-----------------------------------------------------------------------
<i>2146</i>&nbsp;    /**
<i>2147</i>&nbsp;     * Appends a printer and/or parser to the internal list handling padding.
<i>2148</i>&nbsp;     *
<i>2149</i>&nbsp;     * @param pp  the printer-parser to add, not null
<b class="nc"><i>2150</i>&nbsp;     * @return the index into the active parsers list</b>
<i>2151</i>&nbsp;     */
<i>2152</i>&nbsp;    private int appendInternal(DateTimePrinterParser pp) {
<b class="nc"><i>2153</i>&nbsp;        Objects.requireNonNull(pp, &quot;pp&quot;);</b>
<b class="nc"><i>2154</i>&nbsp;        if (active.padNextWidth &gt; 0) {</b>
<b class="nc"><i>2155</i>&nbsp;            if (pp != null) {</b>
<i>2156</i>&nbsp;                pp = new PadPrinterParserDecorator(pp, active.padNextWidth, active.padNextChar);
<i>2157</i>&nbsp;            }
<i>2158</i>&nbsp;            active.padNextWidth = 0;
<i>2159</i>&nbsp;            active.padNextChar = 0;
<i>2160</i>&nbsp;        }
<i>2161</i>&nbsp;        active.printerParsers.add(pp);
<i>2162</i>&nbsp;        active.valueParserIndex = -1;
<i>2163</i>&nbsp;        return active.printerParsers.size() - 1;
<i>2164</i>&nbsp;    }
<b class="nc"><i>2165</i>&nbsp;</b>
<b class="nc"><i>2166</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>2167</i>&nbsp;    /**
<b class="nc"><i>2168</i>&nbsp;     * Completes this builder by creating the {@code DateTimeFormatter}</b>
<i>2169</i>&nbsp;     * using the default locale.
<i>2170</i>&nbsp;     * &lt;p&gt;
<i>2171</i>&nbsp;     * This will create a formatter with the {@linkplain Locale#getDefault(Locale.Category) default FORMAT locale}.
<i>2172</i>&nbsp;     * Numbers will be printed and parsed using the standard DecimalStyle.
<b class="nc"><i>2173</i>&nbsp;     * The resolver style will be {@link ResolverStyle#SMART SMART}.</b>
<b class="nc"><i>2174</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2175</i>&nbsp;     * Calling this method will end any open optional sections by repeatedly</b>
<i>2176</i>&nbsp;     * calling {@link #optionalEnd()} before creating the formatter.
<i>2177</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2178</i>&nbsp;     * This builder can still be used after creating the formatter if desired,</b>
<b class="nc"><i>2179</i>&nbsp;     * although the state may have been changed by calls to {@code optionalEnd}.</b>
<b class="nc"><i>2180</i>&nbsp;     *</b>
<b class="nc"><i>2181</i>&nbsp;     * @return the created formatter, not null</b>
<i>2182</i>&nbsp;     */
<i>2183</i>&nbsp;    public DateTimeFormatter toFormatter() {
<i>2184</i>&nbsp;        return toFormatter(Locale.getDefault(Locale.Category.FORMAT));
<b class="nc"><i>2185</i>&nbsp;    }</b>
<b class="nc"><i>2186</i>&nbsp;</b>
<i>2187</i>&nbsp;    /**
<i>2188</i>&nbsp;     * Completes this builder by creating the {@code DateTimeFormatter}
<b class="nc"><i>2189</i>&nbsp;     * using the specified locale.</b>
<i>2190</i>&nbsp;     * &lt;p&gt;
<i>2191</i>&nbsp;     * This will create a formatter with the specified locale.
<i>2192</i>&nbsp;     * Numbers will be printed and parsed using the standard DecimalStyle.
<i>2193</i>&nbsp;     * The resolver style will be {@link ResolverStyle#SMART SMART}.
<b class="nc"><i>2194</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2195</i>&nbsp;     * Calling this method will end any open optional sections by repeatedly</b>
<b class="nc"><i>2196</i>&nbsp;     * calling {@link #optionalEnd()} before creating the formatter.</b>
<b class="nc"><i>2197</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2198</i>&nbsp;     * This builder can still be used after creating the formatter if desired,</b>
<b class="nc"><i>2199</i>&nbsp;     * although the state may have been changed by calls to {@code optionalEnd}.</b>
<b class="nc"><i>2200</i>&nbsp;     *</b>
<b class="nc"><i>2201</i>&nbsp;     * @param locale  the locale to use for formatting, not null</b>
<i>2202</i>&nbsp;     * @return the created formatter, not null
<i>2203</i>&nbsp;     */
<b class="nc"><i>2204</i>&nbsp;    public DateTimeFormatter toFormatter(Locale locale) {</b>
<b class="nc"><i>2205</i>&nbsp;        return toFormatter(locale, ResolverStyle.SMART, null);</b>
<i>2206</i>&nbsp;    }
<b class="nc"><i>2207</i>&nbsp;</b>
<b class="nc"><i>2208</i>&nbsp;    /**</b>
<b class="nc"><i>2209</i>&nbsp;     * Completes this builder by creating the formatter.</b>
<b class="nc"><i>2210</i>&nbsp;     * This uses the default locale.</b>
<i>2211</i>&nbsp;     *
<i>2212</i>&nbsp;     * @param resolverStyle  the resolver style to use, not null
<b class="nc"><i>2213</i>&nbsp;     * @return the created formatter, not null</b>
<i>2214</i>&nbsp;     */
<i>2215</i>&nbsp;    DateTimeFormatter toFormatter(ResolverStyle resolverStyle, Chronology chrono) {
<i>2216</i>&nbsp;        return toFormatter(Locale.getDefault(Locale.Category.FORMAT), resolverStyle, chrono);
<i>2217</i>&nbsp;    }
<i>2218</i>&nbsp;
<b class="nc"><i>2219</i>&nbsp;    /**</b>
<b class="nc"><i>2220</i>&nbsp;     * Completes this builder by creating the formatter.</b>
<b class="nc"><i>2221</i>&nbsp;     *</b>
<b class="nc"><i>2222</i>&nbsp;     * @param locale  the locale to use for formatting, not null</b>
<b class="nc"><i>2223</i>&nbsp;     * @param chrono  the chronology to use, may be null</b>
<i>2224</i>&nbsp;     * @return the created formatter, not null
<b class="nc"><i>2225</i>&nbsp;     */</b>
<i>2226</i>&nbsp;    private DateTimeFormatter toFormatter(Locale locale, ResolverStyle resolverStyle, Chronology chrono) {
<b class="nc"><i>2227</i>&nbsp;        Objects.requireNonNull(locale, &quot;locale&quot;);</b>
<i>2228</i>&nbsp;        while (active.parent != null) {
<i>2229</i>&nbsp;            optionalEnd();
<i>2230</i>&nbsp;        }
<i>2231</i>&nbsp;        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);
<i>2232</i>&nbsp;        return new DateTimeFormatter(pp, locale, DecimalStyle.STANDARD,
<i>2233</i>&nbsp;                resolverStyle, null, chrono, null);
<i>2234</i>&nbsp;    }
<i>2235</i>&nbsp;
<i>2236</i>&nbsp;    //-----------------------------------------------------------------------
<i>2237</i>&nbsp;    /**
<i>2238</i>&nbsp;     * Strategy for formatting/parsing date-time information.
<i>2239</i>&nbsp;     * &lt;p&gt;
<i>2240</i>&nbsp;     * The printer may format any part, or the whole, of the input date-time object.
<i>2241</i>&nbsp;     * Typically, a complete format is constructed from a number of smaller
<i>2242</i>&nbsp;     * units, each outputting a single field.
<i>2243</i>&nbsp;     * &lt;p&gt;
<i>2244</i>&nbsp;     * The parser may parse any piece of text from the input, storing the result
<i>2245</i>&nbsp;     * in the context. Typically, each individual parser will just parse one
<i>2246</i>&nbsp;     * field, such as the day-of-month, storing the value in the context.
<b class="nc"><i>2247</i>&nbsp;     * Once the parse is complete, the caller will then resolve the parsed values</b>
<i>2248</i>&nbsp;     * to create the desired object, such as a {@code LocalDate}.
<b class="nc"><i>2249</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2250</i>&nbsp;     * The parse position will be updated during the parse. Parsing will start at</b>
<b class="nc"><i>2251</i>&nbsp;     * the specified index and the return value specifies the new parse position</b>
<i>2252</i>&nbsp;     * for the next parser. If an error occurs, the returned index will be negative
<i>2253</i>&nbsp;     * and will have the error position encoded using the complement operator.
<i>2254</i>&nbsp;     *
<i>2255</i>&nbsp;     * @implSpec
<b class="nc"><i>2256</i>&nbsp;     * This interface must be implemented with care to ensure other classes operate correctly.</b>
<b class="nc"><i>2257</i>&nbsp;     * All implementations that can be instantiated must be final, immutable and thread-safe.</b>
<b class="nc"><i>2258</i>&nbsp;     * &lt;p&gt;</b>
<i>2259</i>&nbsp;     * The context is not a thread-safe object and a new instance will be created
<b class="nc"><i>2260</i>&nbsp;     * for each format that occurs. The context must not be stored in an instance</b>
<b class="nc"><i>2261</i>&nbsp;     * variable or shared with any other threads.</b>
<b class="nc"><i>2262</i>&nbsp;     */</b>
<i>2263</i>&nbsp;    interface DateTimePrinterParser {
<i>2264</i>&nbsp;
<b class="nc"><i>2265</i>&nbsp;        /**</b>
<b class="nc"><i>2266</i>&nbsp;         * Prints the date-time object to the buffer.</b>
<i>2267</i>&nbsp;         * &lt;p&gt;
<b class="nc"><i>2268</i>&nbsp;         * The context holds information to use during the format.</b>
<i>2269</i>&nbsp;         * It also contains the date-time information to be printed.
<i>2270</i>&nbsp;         * &lt;p&gt;
<i>2271</i>&nbsp;         * The buffer must not be mutated beyond the content controlled by the implementation.
<i>2272</i>&nbsp;         *
<i>2273</i>&nbsp;         * @param context  the context to format using, not null
<b class="nc"><i>2274</i>&nbsp;         * @param buf  the buffer to append to, not null</b>
<i>2275</i>&nbsp;         * @return false if unable to query the value from the date-time, true otherwise
<b class="nc"><i>2276</i>&nbsp;         * @throws DateTimeException if the date-time cannot be printed successfully</b>
<b class="nc"><i>2277</i>&nbsp;         */</b>
<i>2278</i>&nbsp;        boolean format(DateTimePrintContext context, StringBuilder buf);
<b class="nc"><i>2279</i>&nbsp;</b>
<b class="nc"><i>2280</i>&nbsp;        /**</b>
<i>2281</i>&nbsp;         * Parses text into date-time information.
<b class="nc"><i>2282</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>2283</i>&nbsp;         * The context holds information to use during the parse.</b>
<b class="nc"><i>2284</i>&nbsp;         * It is also used to store the parsed date-time information.</b>
<b class="nc"><i>2285</i>&nbsp;         *</b>
<i>2286</i>&nbsp;         * @param context  the context to use and parse into, not null
<b class="nc"><i>2287</i>&nbsp;         * @param text  the input text to parse, not null</b>
<i>2288</i>&nbsp;         * @param position  the position to start parsing at, from 0 to the text length
<b class="nc"><i>2289</i>&nbsp;         * @return the new parse position, where negative means an error with the</b>
<b class="nc"><i>2290</i>&nbsp;         *  error position encoded using the complement ~ operator</b>
<b class="nc"><i>2291</i>&nbsp;         * @throws NullPointerException if the context or text is null</b>
<i>2292</i>&nbsp;         * @throws IndexOutOfBoundsException if the position is invalid
<b class="nc"><i>2293</i>&nbsp;         */</b>
<b class="nc"><i>2294</i>&nbsp;        int parse(DateTimeParseContext context, CharSequence text, int position);</b>
<b class="nc"><i>2295</i>&nbsp;    }</b>
<b class="nc"><i>2296</i>&nbsp;</b>
<i>2297</i>&nbsp;    //-----------------------------------------------------------------------
<b class="nc"><i>2298</i>&nbsp;    /**</b>
<i>2299</i>&nbsp;     * Composite printer and parser.
<i>2300</i>&nbsp;     */
<i>2301</i>&nbsp;    static final class CompositePrinterParser implements DateTimePrinterParser {
<i>2302</i>&nbsp;        private final DateTimePrinterParser[] printerParsers;
<b class="nc"><i>2303</i>&nbsp;        private final boolean optional;</b>
<i>2304</i>&nbsp;
<i>2305</i>&nbsp;        CompositePrinterParser(List&lt;DateTimePrinterParser&gt; printerParsers, boolean optional) {
<i>2306</i>&nbsp;            this(printerParsers.toArray(new DateTimePrinterParser[printerParsers.size()]), optional);
<i>2307</i>&nbsp;        }
<i>2308</i>&nbsp;
<i>2309</i>&nbsp;        CompositePrinterParser(DateTimePrinterParser[] printerParsers, boolean optional) {
<i>2310</i>&nbsp;            this.printerParsers = printerParsers;
<b class="nc"><i>2311</i>&nbsp;            this.optional = optional;</b>
<b class="nc"><i>2312</i>&nbsp;        }</b>
<b class="nc"><i>2313</i>&nbsp;</b>
<b class="nc"><i>2314</i>&nbsp;        /**</b>
<b class="nc"><i>2315</i>&nbsp;         * Returns a copy of this printer-parser with the optional flag changed.</b>
<i>2316</i>&nbsp;         *
<i>2317</i>&nbsp;         * @param optional  the optional flag to set in the copy
<i>2318</i>&nbsp;         * @return the new printer-parser, not null
<b class="nc"><i>2319</i>&nbsp;         */</b>
<i>2320</i>&nbsp;        public CompositePrinterParser withOptional(boolean optional) {
<i>2321</i>&nbsp;            if (optional == this.optional) {
<i>2322</i>&nbsp;                return this;
<i>2323</i>&nbsp;            }
<i>2324</i>&nbsp;            return new CompositePrinterParser(printerParsers, optional);
<b class="nc"><i>2325</i>&nbsp;        }</b>
<b class="nc"><i>2326</i>&nbsp;</b>
<b class="nc"><i>2327</i>&nbsp;        @Override</b>
<b class="nc"><i>2328</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<b class="nc"><i>2329</i>&nbsp;            int length = buf.length();</b>
<i>2330</i>&nbsp;            if (optional) {
<b class="nc"><i>2331</i>&nbsp;                context.startOptional();</b>
<i>2332</i>&nbsp;            }
<i>2333</i>&nbsp;            try {
<i>2334</i>&nbsp;                for (DateTimePrinterParser pp : printerParsers) {
<i>2335</i>&nbsp;                    if (pp.format(context, buf) == false) {
<i>2336</i>&nbsp;                        buf.setLength(length);  // reset buffer
<b class="nc"><i>2337</i>&nbsp;                        return true;</b>
<b class="nc"><i>2338</i>&nbsp;                    }</b>
<b class="nc"><i>2339</i>&nbsp;                }</b>
<b class="nc"><i>2340</i>&nbsp;            } finally {</b>
<b class="nc"><i>2341</i>&nbsp;                if (optional) {</b>
<i>2342</i>&nbsp;                    context.endOptional();
<b class="nc"><i>2343</i>&nbsp;                }</b>
<i>2344</i>&nbsp;            }
<i>2345</i>&nbsp;            return true;
<i>2346</i>&nbsp;        }
<i>2347</i>&nbsp;
<i>2348</i>&nbsp;        @Override
<i>2349</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>2350</i>&nbsp;            if (optional) {
<i>2351</i>&nbsp;                context.startOptional();
<i>2352</i>&nbsp;                int pos = position;
<i>2353</i>&nbsp;                for (DateTimePrinterParser pp : printerParsers) {
<i>2354</i>&nbsp;                    pos = pp.parse(context, text, pos);
<b class="nc"><i>2355</i>&nbsp;                    if (pos &lt; 0) {</b>
<b class="nc"><i>2356</i>&nbsp;                        context.endOptional(false);</b>
<b class="nc"><i>2357</i>&nbsp;                        return position;  // return original position</b>
<i>2358</i>&nbsp;                    }
<i>2359</i>&nbsp;                }
<i>2360</i>&nbsp;                context.endOptional(true);
<b class="nc"><i>2361</i>&nbsp;                return pos;</b>
<i>2362</i>&nbsp;            } else {
<i>2363</i>&nbsp;                for (DateTimePrinterParser pp : printerParsers) {
<i>2364</i>&nbsp;                    position = pp.parse(context, text, position);
<b class="nc"><i>2365</i>&nbsp;                    if (position &lt; 0) {</b>
<b class="nc"><i>2366</i>&nbsp;                        break;</b>
<i>2367</i>&nbsp;                    }
<b class="nc"><i>2368</i>&nbsp;                }</b>
<i>2369</i>&nbsp;                return position;
<i>2370</i>&nbsp;            }
<i>2371</i>&nbsp;        }
<i>2372</i>&nbsp;
<i>2373</i>&nbsp;        @Override
<i>2374</i>&nbsp;        public String toString() {
<i>2375</i>&nbsp;            StringBuilder buf = new StringBuilder();
<i>2376</i>&nbsp;            if (printerParsers != null) {
<i>2377</i>&nbsp;                buf.append(optional ? &quot;[&quot; : &quot;(&quot;);
<i>2378</i>&nbsp;                for (DateTimePrinterParser pp : printerParsers) {
<b class="nc"><i>2379</i>&nbsp;                    buf.append(pp);</b>
<b class="nc"><i>2380</i>&nbsp;                }</b>
<i>2381</i>&nbsp;                buf.append(optional ? &quot;]&quot; : &quot;)&quot;);
<i>2382</i>&nbsp;            }
<i>2383</i>&nbsp;            return buf.toString();
<i>2384</i>&nbsp;        }
<b class="nc"><i>2385</i>&nbsp;    }</b>
<b class="nc"><i>2386</i>&nbsp;</b>
<i>2387</i>&nbsp;    //-----------------------------------------------------------------------
<i>2388</i>&nbsp;    /**
<i>2389</i>&nbsp;     * Pads the output to a fixed width.
<i>2390</i>&nbsp;     */
<b class="nc"><i>2391</i>&nbsp;    static final class PadPrinterParserDecorator implements DateTimePrinterParser {</b>
<b class="nc"><i>2392</i>&nbsp;        private final DateTimePrinterParser printerParser;</b>
<b class="nc"><i>2393</i>&nbsp;        private final int padWidth;</b>
<i>2394</i>&nbsp;        private final char padChar;
<b class="nc"><i>2395</i>&nbsp;</b>
<b class="nc"><i>2396</i>&nbsp;        /**</b>
<b class="nc"><i>2397</i>&nbsp;         * Constructor.</b>
<b class="nc"><i>2398</i>&nbsp;         *</b>
<b class="nc"><i>2399</i>&nbsp;         * @param printerParser  the printer, not null</b>
<b class="nc"><i>2400</i>&nbsp;         * @param padWidth  the width to pad to, 1 or greater</b>
<i>2401</i>&nbsp;         * @param padChar  the pad character
<i>2402</i>&nbsp;         */
<b class="nc"><i>2403</i>&nbsp;        PadPrinterParserDecorator(DateTimePrinterParser printerParser, int padWidth, char padChar) {</b>
<i>2404</i>&nbsp;            // input checked by DateTimeFormatterBuilder
<i>2405</i>&nbsp;            this.printerParser = printerParser;
<i>2406</i>&nbsp;            this.padWidth = padWidth;
<i>2407</i>&nbsp;            this.padChar = padChar;
<b class="nc"><i>2408</i>&nbsp;        }</b>
<b class="nc"><i>2409</i>&nbsp;</b>
<i>2410</i>&nbsp;        @Override
<b class="nc"><i>2411</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<i>2412</i>&nbsp;            int preLen = buf.length();
<i>2413</i>&nbsp;            if (printerParser.format(context, buf) == false) {
<i>2414</i>&nbsp;                return false;
<i>2415</i>&nbsp;            }
<i>2416</i>&nbsp;            int len = buf.length() - preLen;
<i>2417</i>&nbsp;            if (len &gt; padWidth) {
<i>2418</i>&nbsp;                throw new DateTimeException(
<i>2419</i>&nbsp;                    &quot;Cannot print as output of &quot; + len + &quot; characters exceeds pad width of &quot; + padWidth);
<i>2420</i>&nbsp;            }
<i>2421</i>&nbsp;            for (int i = 0; i &lt; padWidth - len; i++) {
<b class="nc"><i>2422</i>&nbsp;                buf.insert(preLen, padChar);</b>
<b class="nc"><i>2423</i>&nbsp;            }</b>
<i>2424</i>&nbsp;            return true;
<i>2425</i>&nbsp;        }
<i>2426</i>&nbsp;
<i>2427</i>&nbsp;        @Override
<b class="nc"><i>2428</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {</b>
<b class="nc"><i>2429</i>&nbsp;            // cache context before changed by decorated parser</b>
<i>2430</i>&nbsp;            final boolean strict = context.isStrict();
<i>2431</i>&nbsp;            // parse
<i>2432</i>&nbsp;            if (position &gt; text.length()) {
<i>2433</i>&nbsp;                throw new IndexOutOfBoundsException();
<b class="nc"><i>2434</i>&nbsp;            }</b>
<b class="nc"><i>2435</i>&nbsp;            if (position == text.length()) {</b>
<b class="nc"><i>2436</i>&nbsp;                return ~position;  // no more characters in the string</b>
<i>2437</i>&nbsp;            }
<b class="nc"><i>2438</i>&nbsp;            int endPos = position + padWidth;</b>
<b class="nc"><i>2439</i>&nbsp;            if (endPos &gt; text.length()) {</b>
<i>2440</i>&nbsp;                if (strict) {
<b class="nc"><i>2441</i>&nbsp;                    return ~position;  // not enough characters in the string to meet the parse width</b>
<i>2442</i>&nbsp;                }
<i>2443</i>&nbsp;                endPos = text.length();
<i>2444</i>&nbsp;            }
<i>2445</i>&nbsp;            int pos = position;
<b class="nc"><i>2446</i>&nbsp;            while (pos &lt; endPos &amp;&amp; context.charEquals(text.charAt(pos), padChar)) {</b>
<b class="nc"><i>2447</i>&nbsp;                pos++;</b>
<i>2448</i>&nbsp;            }
<i>2449</i>&nbsp;            text = text.subSequence(0, endPos);
<i>2450</i>&nbsp;            int resultPos = printerParser.parse(context, text, pos);
<i>2451</i>&nbsp;            if (resultPos != endPos &amp;&amp; strict) {
<i>2452</i>&nbsp;                return ~(position + pos);  // parse of decorated field didn&#39;t parse to the end
<i>2453</i>&nbsp;            }
<i>2454</i>&nbsp;            return resultPos;
<b class="nc"><i>2455</i>&nbsp;        }</b>
<i>2456</i>&nbsp;
<i>2457</i>&nbsp;        @Override
<i>2458</i>&nbsp;        public String toString() {
<i>2459</i>&nbsp;            return &quot;Pad(&quot; + printerParser + &quot;,&quot; + padWidth + (padChar == &#39; &#39; ? &quot;)&quot; : &quot;,&#39;&quot; + padChar + &quot;&#39;)&quot;);
<b class="nc"><i>2460</i>&nbsp;        }</b>
<i>2461</i>&nbsp;    }
<i>2462</i>&nbsp;
<i>2463</i>&nbsp;    //-----------------------------------------------------------------------
<i>2464</i>&nbsp;    /**
<i>2465</i>&nbsp;     * Enumeration to apply simple parse settings.
<i>2466</i>&nbsp;     */
<i>2467</i>&nbsp;    static enum SettingsParser implements DateTimePrinterParser {
<i>2468</i>&nbsp;        SENSITIVE,
<i>2469</i>&nbsp;        INSENSITIVE,
<i>2470</i>&nbsp;        STRICT,
<i>2471</i>&nbsp;        LENIENT;
<i>2472</i>&nbsp;
<i>2473</i>&nbsp;        @Override
<i>2474</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>2475</i>&nbsp;            return true;  // nothing to do here
<i>2476</i>&nbsp;        }
<i>2477</i>&nbsp;
<i>2478</i>&nbsp;        @Override
<i>2479</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>2480</i>&nbsp;            // using ordinals to avoid javac synthetic inner class
<i>2481</i>&nbsp;            switch (ordinal()) {
<i>2482</i>&nbsp;                case 0: context.setCaseSensitive(true); break;
<i>2483</i>&nbsp;                case 1: context.setCaseSensitive(false); break;
<i>2484</i>&nbsp;                case 2: context.setStrict(true); break;
<i>2485</i>&nbsp;                case 3: context.setStrict(false); break;
<i>2486</i>&nbsp;            }
<i>2487</i>&nbsp;            return position;
<b class="nc"><i>2488</i>&nbsp;        }</b>
<i>2489</i>&nbsp;
<b class="nc"><i>2490</i>&nbsp;        @Override</b>
<b class="nc"><i>2491</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>2492</i>&nbsp;            // using ordinals to avoid javac synthetic inner class</b>
<b class="nc"><i>2493</i>&nbsp;            switch (ordinal()) {</b>
<b class="nc"><i>2494</i>&nbsp;                case 0: return &quot;ParseCaseSensitive(true)&quot;;</b>
<i>2495</i>&nbsp;                case 1: return &quot;ParseCaseSensitive(false)&quot;;
<i>2496</i>&nbsp;                case 2: return &quot;ParseStrict(true)&quot;;
<i>2497</i>&nbsp;                case 3: return &quot;ParseStrict(false)&quot;;
<i>2498</i>&nbsp;            }
<i>2499</i>&nbsp;            throw new IllegalStateException(&quot;Unreachable&quot;);
<i>2500</i>&nbsp;        }
<i>2501</i>&nbsp;    }
<i>2502</i>&nbsp;
<i>2503</i>&nbsp;    //-----------------------------------------------------------------------
<i>2504</i>&nbsp;    /**
<i>2505</i>&nbsp;     * Defaults a value into the parse if not currently present.
<i>2506</i>&nbsp;     */
<b class="nc"><i>2507</i>&nbsp;    static class DefaultValueParser implements DateTimePrinterParser {</b>
<i>2508</i>&nbsp;        private final TemporalField field;
<b class="nc"><i>2509</i>&nbsp;        private final long value;</b>
<b class="nc"><i>2510</i>&nbsp;</b>
<b class="nc"><i>2511</i>&nbsp;        DefaultValueParser(TemporalField field, long value) {</b>
<b class="nc"><i>2512</i>&nbsp;            this.field = field;</b>
<b class="nc"><i>2513</i>&nbsp;            this.value = value;</b>
<i>2514</i>&nbsp;        }
<i>2515</i>&nbsp;
<i>2516</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>2517</i>&nbsp;            return true;
<i>2518</i>&nbsp;        }
<i>2519</i>&nbsp;
<i>2520</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>2521</i>&nbsp;            if (context.getParsed(field) == null) {
<b class="nc"><i>2522</i>&nbsp;                context.setParsedField(field, value, position, position);</b>
<b class="nc"><i>2523</i>&nbsp;            }</b>
<i>2524</i>&nbsp;            return position;
<b class="nc"><i>2525</i>&nbsp;        }</b>
<i>2526</i>&nbsp;    }
<i>2527</i>&nbsp;
<i>2528</i>&nbsp;    //-----------------------------------------------------------------------
<i>2529</i>&nbsp;    /**
<i>2530</i>&nbsp;     * Prints or parses a character literal.
<i>2531</i>&nbsp;     */
<i>2532</i>&nbsp;    static final class CharLiteralPrinterParser implements DateTimePrinterParser {
<i>2533</i>&nbsp;        private final char literal;
<i>2534</i>&nbsp;
<b class="nc"><i>2535</i>&nbsp;        CharLiteralPrinterParser(char literal) {</b>
<i>2536</i>&nbsp;            this.literal = literal;
<i>2537</i>&nbsp;        }
<i>2538</i>&nbsp;
<i>2539</i>&nbsp;        @Override
<b class="nc"><i>2540</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<b class="nc"><i>2541</i>&nbsp;            buf.append(literal);</b>
<b class="nc"><i>2542</i>&nbsp;            return true;</b>
<i>2543</i>&nbsp;        }
<b class="nc"><i>2544</i>&nbsp;</b>
<b class="nc"><i>2545</i>&nbsp;        @Override</b>
<b class="nc"><i>2546</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {</b>
<b class="nc"><i>2547</i>&nbsp;            int length = text.length();</b>
<b class="nc"><i>2548</i>&nbsp;            if (position == length) {</b>
<i>2549</i>&nbsp;                return ~position;
<i>2550</i>&nbsp;            }
<i>2551</i>&nbsp;            char ch = text.charAt(position);
<b class="nc"><i>2552</i>&nbsp;            if (ch != literal) {</b>
<i>2553</i>&nbsp;                if (context.isCaseSensitive() ||
<b class="nc"><i>2554</i>&nbsp;                        (Character.toUpperCase(ch) != Character.toUpperCase(literal) &amp;&amp;</b>
<b class="nc"><i>2555</i>&nbsp;                         Character.toLowerCase(ch) != Character.toLowerCase(literal))) {</b>
<i>2556</i>&nbsp;                    return ~position;
<b class="nc"><i>2557</i>&nbsp;                }</b>
<b class="nc"><i>2558</i>&nbsp;            }</b>
<i>2559</i>&nbsp;            return position + 1;
<i>2560</i>&nbsp;        }
<i>2561</i>&nbsp;
<b class="nc"><i>2562</i>&nbsp;        @Override</b>
<b class="nc"><i>2563</i>&nbsp;        public String toString() {</b>
<i>2564</i>&nbsp;            if (literal == &#39;\&#39;&#39;) {
<i>2565</i>&nbsp;                return &quot;&#39;&#39;&quot;;
<b class="nc"><i>2566</i>&nbsp;            }</b>
<i>2567</i>&nbsp;            return &quot;&#39;&quot; + literal + &quot;&#39;&quot;;
<i>2568</i>&nbsp;        }
<i>2569</i>&nbsp;    }
<b class="nc"><i>2570</i>&nbsp;</b>
<b class="nc"><i>2571</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>2572</i>&nbsp;    /**
<b class="nc"><i>2573</i>&nbsp;     * Prints or parses a string literal.</b>
<i>2574</i>&nbsp;     */
<i>2575</i>&nbsp;    static final class StringLiteralPrinterParser implements DateTimePrinterParser {
<i>2576</i>&nbsp;        private final String literal;
<i>2577</i>&nbsp;
<b class="nc"><i>2578</i>&nbsp;        StringLiteralPrinterParser(String literal) {</b>
<b class="nc"><i>2579</i>&nbsp;            this.literal = literal;  // validated by caller</b>
<i>2580</i>&nbsp;        }
<b class="nc"><i>2581</i>&nbsp;</b>
<b class="nc"><i>2582</i>&nbsp;        @Override</b>
<i>2583</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>2584</i>&nbsp;            buf.append(literal);
<i>2585</i>&nbsp;            return true;
<i>2586</i>&nbsp;        }
<i>2587</i>&nbsp;
<i>2588</i>&nbsp;        @Override
<i>2589</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>2590</i>&nbsp;            int length = text.length();
<i>2591</i>&nbsp;            if (position &gt; length || position &lt; 0) {
<i>2592</i>&nbsp;                throw new IndexOutOfBoundsException();
<b class="nc"><i>2593</i>&nbsp;            }</b>
<i>2594</i>&nbsp;            if (context.subSequenceEquals(text, position, literal, 0, literal.length()) == false) {
<i>2595</i>&nbsp;                return ~position;
<i>2596</i>&nbsp;            }
<i>2597</i>&nbsp;            return position + literal.length();
<i>2598</i>&nbsp;        }
<i>2599</i>&nbsp;
<i>2600</i>&nbsp;        @Override
<i>2601</i>&nbsp;        public String toString() {
<i>2602</i>&nbsp;            String converted = literal.replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;);
<i>2603</i>&nbsp;            return &quot;&#39;&quot; + converted + &quot;&#39;&quot;;
<b class="nc"><i>2604</i>&nbsp;        }</b>
<i>2605</i>&nbsp;    }
<i>2606</i>&nbsp;
<i>2607</i>&nbsp;    //-----------------------------------------------------------------------
<i>2608</i>&nbsp;    /**
<i>2609</i>&nbsp;     * Prints and parses a numeric date-time field with optional padding.
<b class="nc"><i>2610</i>&nbsp;     */</b>
<b class="nc"><i>2611</i>&nbsp;    static class NumberPrinterParser implements DateTimePrinterParser {</b>
<b class="nc"><i>2612</i>&nbsp;</b>
<i>2613</i>&nbsp;        /**
<b class="nc"><i>2614</i>&nbsp;         * Array of 10 to the power of n.</b>
<b class="nc"><i>2615</i>&nbsp;         */</b>
<b class="nc"><i>2616</i>&nbsp;        static final long[] EXCEED_POINTS = new long[] {</b>
<b class="nc"><i>2617</i>&nbsp;            0L,</b>
<b class="nc"><i>2618</i>&nbsp;            10L,</b>
<b class="nc"><i>2619</i>&nbsp;            100L,</b>
<i>2620</i>&nbsp;            1000L,
<b class="nc"><i>2621</i>&nbsp;            10000L,</b>
<b class="nc"><i>2622</i>&nbsp;            100000L,</b>
<b class="nc"><i>2623</i>&nbsp;            1000000L,</b>
<b class="nc"><i>2624</i>&nbsp;            10000000L,</b>
<b class="nc"><i>2625</i>&nbsp;            100000000L,</b>
<i>2626</i>&nbsp;            1000000000L,
<b class="nc"><i>2627</i>&nbsp;            10000000000L,</b>
<b class="nc"><i>2628</i>&nbsp;        };</b>
<i>2629</i>&nbsp;
<b class="nc"><i>2630</i>&nbsp;        final TemporalField field;</b>
<b class="nc"><i>2631</i>&nbsp;        final int minWidth;</b>
<i>2632</i>&nbsp;        final int maxWidth;
<i>2633</i>&nbsp;        private final SignStyle signStyle;
<b class="nc"><i>2634</i>&nbsp;        final int subsequentWidth;</b>
<b class="nc"><i>2635</i>&nbsp;</b>
<b class="nc"><i>2636</i>&nbsp;        /**</b>
<b class="nc"><i>2637</i>&nbsp;         * Constructor.</b>
<i>2638</i>&nbsp;         *
<b class="nc"><i>2639</i>&nbsp;         * @param field  the field to format, not null</b>
<b class="nc"><i>2640</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 19</b>
<b class="nc"><i>2641</i>&nbsp;         * @param maxWidth  the maximum field width, from minWidth to 19</b>
<b class="nc"><i>2642</i>&nbsp;         * @param signStyle  the positive/negative sign style, not null</b>
<b class="nc"><i>2643</i>&nbsp;         */</b>
<b class="nc"><i>2644</i>&nbsp;        NumberPrinterParser(TemporalField field, int minWidth, int maxWidth, SignStyle signStyle) {</b>
<b class="nc"><i>2645</i>&nbsp;            // validated by caller</b>
<b class="nc"><i>2646</i>&nbsp;            this.field = field;</b>
<b class="nc"><i>2647</i>&nbsp;            this.minWidth = minWidth;</b>
<b class="nc"><i>2648</i>&nbsp;            this.maxWidth = maxWidth;</b>
<b class="nc"><i>2649</i>&nbsp;            this.signStyle = signStyle;</b>
<b class="nc"><i>2650</i>&nbsp;            this.subsequentWidth = 0;</b>
<b class="nc"><i>2651</i>&nbsp;        }</b>
<i>2652</i>&nbsp;
<i>2653</i>&nbsp;        /**
<i>2654</i>&nbsp;         * Constructor.
<b class="nc"><i>2655</i>&nbsp;         *</b>
<b class="nc"><i>2656</i>&nbsp;         * @param field  the field to format, not null</b>
<b class="nc"><i>2657</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 19</b>
<i>2658</i>&nbsp;         * @param maxWidth  the maximum field width, from minWidth to 19
<b class="nc"><i>2659</i>&nbsp;         * @param signStyle  the positive/negative sign style, not null</b>
<i>2660</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,
<b class="nc"><i>2661</i>&nbsp;         *  -1 if fixed width due to active adjacent parsing</b>
<i>2662</i>&nbsp;         */
<b class="nc"><i>2663</i>&nbsp;        protected NumberPrinterParser(TemporalField field, int minWidth, int maxWidth, SignStyle signStyle, int subsequentWidth) {</b>
<b class="nc"><i>2664</i>&nbsp;            // validated by caller</b>
<i>2665</i>&nbsp;            this.field = field;
<b class="nc"><i>2666</i>&nbsp;            this.minWidth = minWidth;</b>
<b class="nc"><i>2667</i>&nbsp;            this.maxWidth = maxWidth;</b>
<b class="nc"><i>2668</i>&nbsp;            this.signStyle = signStyle;</b>
<b class="nc"><i>2669</i>&nbsp;            this.subsequentWidth = subsequentWidth;</b>
<b class="nc"><i>2670</i>&nbsp;        }</b>
<i>2671</i>&nbsp;
<i>2672</i>&nbsp;        /**
<i>2673</i>&nbsp;         * Returns a new instance with fixed width flag set.
<i>2674</i>&nbsp;         *
<b class="nc"><i>2675</i>&nbsp;         * @return a new updated printer-parser, not null</b>
<b class="nc"><i>2676</i>&nbsp;         */</b>
<b class="nc"><i>2677</i>&nbsp;        NumberPrinterParser withFixedWidth() {</b>
<b class="nc"><i>2678</i>&nbsp;            if (subsequentWidth == -1) {</b>
<i>2679</i>&nbsp;                return this;
<b class="nc"><i>2680</i>&nbsp;            }</b>
<i>2681</i>&nbsp;            return new NumberPrinterParser(field, minWidth, maxWidth, signStyle, -1);
<b class="nc"><i>2682</i>&nbsp;        }</b>
<b class="nc"><i>2683</i>&nbsp;</b>
<i>2684</i>&nbsp;        /**
<b class="nc"><i>2685</i>&nbsp;         * Returns a new instance with an updated subsequent width.</b>
<i>2686</i>&nbsp;         *
<b class="nc"><i>2687</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater</b>
<b class="nc"><i>2688</i>&nbsp;         * @return a new updated printer-parser, not null</b>
<b class="nc"><i>2689</i>&nbsp;         */</b>
<b class="nc"><i>2690</i>&nbsp;        NumberPrinterParser withSubsequentWidth(int subsequentWidth) {</b>
<b class="nc"><i>2691</i>&nbsp;            return new NumberPrinterParser(field, minWidth, maxWidth, signStyle, this.subsequentWidth + subsequentWidth);</b>
<i>2692</i>&nbsp;        }
<i>2693</i>&nbsp;
<b class="nc"><i>2694</i>&nbsp;        @Override</b>
<b class="nc"><i>2695</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<i>2696</i>&nbsp;            Long valueLong = context.getValue(field);
<i>2697</i>&nbsp;            if (valueLong == null) {
<i>2698</i>&nbsp;                return false;
<b class="nc"><i>2699</i>&nbsp;            }</b>
<b class="nc"><i>2700</i>&nbsp;            long value = getValue(context, valueLong);</b>
<i>2701</i>&nbsp;            DecimalStyle decimalStyle = context.getDecimalStyle();
<b class="nc"><i>2702</i>&nbsp;            String str = (value == Long.MIN_VALUE ? &quot;9223372036854775808&quot; : Long.toString(Math.abs(value)));</b>
<b class="nc"><i>2703</i>&nbsp;            if (str.length() &gt; maxWidth) {</b>
<i>2704</i>&nbsp;                throw new DateTimeException(&quot;Field &quot; + field +
<b class="nc"><i>2705</i>&nbsp;                    &quot; cannot be printed as the value &quot; + value +</b>
<i>2706</i>&nbsp;                    &quot; exceeds the maximum print width of &quot; + maxWidth);
<b class="nc"><i>2707</i>&nbsp;            }</b>
<i>2708</i>&nbsp;            str = decimalStyle.convertNumberToI18N(str);
<i>2709</i>&nbsp;
<i>2710</i>&nbsp;            if (value &gt;= 0) {
<i>2711</i>&nbsp;                switch (signStyle) {
<i>2712</i>&nbsp;                    case EXCEEDS_PAD:
<i>2713</i>&nbsp;                        if (minWidth &lt; 19 &amp;&amp; value &gt;= EXCEED_POINTS[minWidth]) {
<i>2714</i>&nbsp;                            buf.append(decimalStyle.getPositiveSign());
<i>2715</i>&nbsp;                        }
<i>2716</i>&nbsp;                        break;
<i>2717</i>&nbsp;                    case ALWAYS:
<i>2718</i>&nbsp;                        buf.append(decimalStyle.getPositiveSign());
<i>2719</i>&nbsp;                        break;
<b class="nc"><i>2720</i>&nbsp;                }</b>
<i>2721</i>&nbsp;            } else {
<i>2722</i>&nbsp;                switch (signStyle) {
<i>2723</i>&nbsp;                    case NORMAL:
<i>2724</i>&nbsp;                    case EXCEEDS_PAD:
<b class="nc"><i>2725</i>&nbsp;                    case ALWAYS:</b>
<b class="nc"><i>2726</i>&nbsp;                        buf.append(decimalStyle.getNegativeSign());</b>
<i>2727</i>&nbsp;                        break;
<b class="nc"><i>2728</i>&nbsp;                    case NOT_NEGATIVE:</b>
<b class="nc"><i>2729</i>&nbsp;                        throw new DateTimeException(&quot;Field &quot; + field +</b>
<i>2730</i>&nbsp;                            &quot; cannot be printed as the value &quot; + value +
<b class="nc"><i>2731</i>&nbsp;                            &quot; cannot be negative according to the SignStyle&quot;);</b>
<i>2732</i>&nbsp;                }
<i>2733</i>&nbsp;            }
<i>2734</i>&nbsp;            for (int i = 0; i &lt; minWidth - str.length(); i++) {
<i>2735</i>&nbsp;                buf.append(decimalStyle.getZeroDigit());
<i>2736</i>&nbsp;            }
<i>2737</i>&nbsp;            buf.append(str);
<i>2738</i>&nbsp;            return true;
<b class="nc"><i>2739</i>&nbsp;        }</b>
<i>2740</i>&nbsp;
<i>2741</i>&nbsp;        /**
<i>2742</i>&nbsp;         * Gets the value to output.
<b class="nc"><i>2743</i>&nbsp;         *</b>
<i>2744</i>&nbsp;         * @param context  the context
<i>2745</i>&nbsp;         * @param value  the value of the field, not null
<i>2746</i>&nbsp;         * @return the value
<i>2747</i>&nbsp;         */
<i>2748</i>&nbsp;        long getValue(DateTimePrintContext context, long value) {
<i>2749</i>&nbsp;            return value;
<i>2750</i>&nbsp;        }
<i>2751</i>&nbsp;
<i>2752</i>&nbsp;        /**
<i>2753</i>&nbsp;         * For NumberPrinterParser, the width is fixed depending on the
<i>2754</i>&nbsp;         * minWidth, maxWidth, signStyle and whether subsequent fields are fixed.
<i>2755</i>&nbsp;         * @param context the context
<i>2756</i>&nbsp;         * @return true if the field is fixed width
<i>2757</i>&nbsp;         * @see DateTimeFormatterBuilder#appendValue(java.time.temporal.TemporalField, int)
<i>2758</i>&nbsp;         */
<b class="nc"><i>2759</i>&nbsp;        boolean isFixedWidth(DateTimeParseContext context) {</b>
<b class="nc"><i>2760</i>&nbsp;            return subsequentWidth == -1 ||</b>
<b class="nc"><i>2761</i>&nbsp;                (subsequentWidth &gt; 0 &amp;&amp; minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE);</b>
<i>2762</i>&nbsp;        }
<b class="nc"><i>2763</i>&nbsp;</b>
<b class="nc"><i>2764</i>&nbsp;        @Override</b>
<i>2765</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<b class="nc"><i>2766</i>&nbsp;            int length = text.length();</b>
<b class="nc"><i>2767</i>&nbsp;            if (position == length) {</b>
<i>2768</i>&nbsp;                return ~position;
<i>2769</i>&nbsp;            }
<b class="nc"><i>2770</i>&nbsp;            char sign = text.charAt(position);  // IOOBE if invalid position</b>
<b class="nc"><i>2771</i>&nbsp;            boolean negative = false;</b>
<b class="nc"><i>2772</i>&nbsp;            boolean positive = false;</b>
<i>2773</i>&nbsp;            if (sign == context.getDecimalStyle().getPositiveSign()) {
<b class="nc"><i>2774</i>&nbsp;                if (signStyle.parse(true, context.isStrict(), minWidth == maxWidth) == false) {</b>
<b class="nc"><i>2775</i>&nbsp;                    return ~position;</b>
<i>2776</i>&nbsp;                }
<i>2777</i>&nbsp;                positive = true;
<i>2778</i>&nbsp;                position++;
<i>2779</i>&nbsp;            } else if (sign == context.getDecimalStyle().getNegativeSign()) {
<i>2780</i>&nbsp;                if (signStyle.parse(false, context.isStrict(), minWidth == maxWidth) == false) {
<i>2781</i>&nbsp;                    return ~position;
<i>2782</i>&nbsp;                }
<i>2783</i>&nbsp;                negative = true;
<i>2784</i>&nbsp;                position++;
<i>2785</i>&nbsp;            } else {
<i>2786</i>&nbsp;                if (signStyle == SignStyle.ALWAYS &amp;&amp; context.isStrict()) {
<i>2787</i>&nbsp;                    return ~position;
<i>2788</i>&nbsp;                }
<i>2789</i>&nbsp;            }
<i>2790</i>&nbsp;            int effMinWidth = (context.isStrict() || isFixedWidth(context) ? minWidth : 1);
<i>2791</i>&nbsp;            int minEndPos = position + effMinWidth;
<i>2792</i>&nbsp;            if (minEndPos &gt; length) {
<b class="nc"><i>2793</i>&nbsp;                return ~position;</b>
<b class="nc"><i>2794</i>&nbsp;            }</b>
<b class="nc"><i>2795</i>&nbsp;            int effMaxWidth = (context.isStrict() || isFixedWidth(context) ? maxWidth : 9) + Math.max(subsequentWidth, 0);</b>
<i>2796</i>&nbsp;            long total = 0;
<i>2797</i>&nbsp;            BigInteger totalBig = null;
<i>2798</i>&nbsp;            int pos = position;
<i>2799</i>&nbsp;            for (int pass = 0; pass &lt; 2; pass++) {
<b class="nc"><i>2800</i>&nbsp;                int maxEndPos = Math.min(pos + effMaxWidth, length);</b>
<b class="nc"><i>2801</i>&nbsp;                while (pos &lt; maxEndPos) {</b>
<b class="nc"><i>2802</i>&nbsp;                    char ch = text.charAt(pos++);</b>
<b class="nc"><i>2803</i>&nbsp;                    int digit = context.getDecimalStyle().convertToDigit(ch);</b>
<b class="nc"><i>2804</i>&nbsp;                    if (digit &lt; 0) {</b>
<i>2805</i>&nbsp;                        pos--;
<b class="nc"><i>2806</i>&nbsp;                        if (pos &lt; minEndPos) {</b>
<i>2807</i>&nbsp;                            return ~position;  // need at least min width digits
<b class="nc"><i>2808</i>&nbsp;                        }</b>
<i>2809</i>&nbsp;                        break;
<i>2810</i>&nbsp;                    }
<b class="nc"><i>2811</i>&nbsp;                    if ((pos - position) &gt; 18) {</b>
<i>2812</i>&nbsp;                        if (totalBig == null) {
<i>2813</i>&nbsp;                            totalBig = BigInteger.valueOf(total);
<i>2814</i>&nbsp;                        }
<i>2815</i>&nbsp;                        totalBig = totalBig.multiply(BigInteger.TEN).add(BigInteger.valueOf(digit));
<b class="nc"><i>2816</i>&nbsp;                    } else {</b>
<b class="nc"><i>2817</i>&nbsp;                        total = total * 10 + digit;</b>
<b class="nc"><i>2818</i>&nbsp;                    }</b>
<b class="nc"><i>2819</i>&nbsp;                }</b>
<i>2820</i>&nbsp;                if (subsequentWidth &gt; 0 &amp;&amp; pass == 0) {
<i>2821</i>&nbsp;                    // re-parse now we know the correct width
<b class="nc"><i>2822</i>&nbsp;                    int parseLen = pos - position;</b>
<b class="nc"><i>2823</i>&nbsp;                    effMaxWidth = Math.max(effMinWidth, parseLen - subsequentWidth);</b>
<i>2824</i>&nbsp;                    pos = position;
<i>2825</i>&nbsp;                    total = 0;
<i>2826</i>&nbsp;                    totalBig = null;
<i>2827</i>&nbsp;                } else {
<i>2828</i>&nbsp;                    break;
<b class="nc"><i>2829</i>&nbsp;                }</b>
<i>2830</i>&nbsp;            }
<i>2831</i>&nbsp;            if (negative) {
<b class="nc"><i>2832</i>&nbsp;                if (totalBig != null) {</b>
<b class="nc"><i>2833</i>&nbsp;                    if (totalBig.equals(BigInteger.ZERO) &amp;&amp; context.isStrict()) {</b>
<b class="nc"><i>2834</i>&nbsp;                        return ~(position - 1);  // minus zero not allowed</b>
<b class="nc"><i>2835</i>&nbsp;                    }</b>
<b class="nc"><i>2836</i>&nbsp;                    totalBig = totalBig.negate();</b>
<b class="nc"><i>2837</i>&nbsp;                } else {</b>
<b class="nc"><i>2838</i>&nbsp;                    if (total == 0 &amp;&amp; context.isStrict()) {</b>
<i>2839</i>&nbsp;                        return ~(position - 1);  // minus zero not allowed
<b class="nc"><i>2840</i>&nbsp;                    }</b>
<i>2841</i>&nbsp;                    total = -total;
<b class="nc"><i>2842</i>&nbsp;                }</b>
<b class="nc"><i>2843</i>&nbsp;            } else if (signStyle == SignStyle.EXCEEDS_PAD &amp;&amp; context.isStrict()) {</b>
<i>2844</i>&nbsp;                int parseLen = pos - position;
<i>2845</i>&nbsp;                if (positive) {
<b class="nc"><i>2846</i>&nbsp;                    if (parseLen &lt;= minWidth) {</b>
<i>2847</i>&nbsp;                        return ~(position - 1);  // &#39;+&#39; only parsed if minWidth exceeded
<i>2848</i>&nbsp;                    }
<i>2849</i>&nbsp;                } else {
<i>2850</i>&nbsp;                    if (parseLen &gt; minWidth) {
<i>2851</i>&nbsp;                        return ~position;  // &#39;+&#39; must be parsed if minWidth exceeded
<i>2852</i>&nbsp;                    }
<i>2853</i>&nbsp;                }
<i>2854</i>&nbsp;            }
<i>2855</i>&nbsp;            if (totalBig != null) {
<b class="nc"><i>2856</i>&nbsp;                if (totalBig.bitLength() &gt; 63) {</b>
<b class="nc"><i>2857</i>&nbsp;                    // overflow, parse 1 less digit</b>
<i>2858</i>&nbsp;                    totalBig = totalBig.divide(BigInteger.TEN);
<b class="nc"><i>2859</i>&nbsp;                    pos--;</b>
<i>2860</i>&nbsp;                }
<i>2861</i>&nbsp;                return setValue(context, totalBig.longValue(), position, pos);
<i>2862</i>&nbsp;            }
<i>2863</i>&nbsp;            return setValue(context, total, position, pos);
<i>2864</i>&nbsp;        }
<i>2865</i>&nbsp;
<i>2866</i>&nbsp;        /**
<i>2867</i>&nbsp;         * Stores the value.
<i>2868</i>&nbsp;         *
<i>2869</i>&nbsp;         * @param context  the context to store into, not null
<b class="nc"><i>2870</i>&nbsp;         * @param value  the value</b>
<i>2871</i>&nbsp;         * @param errorPos  the position of the field being parsed
<i>2872</i>&nbsp;         * @param successPos  the position after the field being parsed
<i>2873</i>&nbsp;         * @return the new position
<i>2874</i>&nbsp;         */
<i>2875</i>&nbsp;        int setValue(DateTimeParseContext context, long value, int errorPos, int successPos) {
<i>2876</i>&nbsp;            return context.setParsedField(field, value, errorPos, successPos);
<i>2877</i>&nbsp;        }
<i>2878</i>&nbsp;
<i>2879</i>&nbsp;        @Override
<i>2880</i>&nbsp;        public String toString() {
<i>2881</i>&nbsp;            if (minWidth == 1 &amp;&amp; maxWidth == 19 &amp;&amp; signStyle == SignStyle.NORMAL) {
<i>2882</i>&nbsp;                return &quot;Value(&quot; + field + &quot;)&quot;;
<b class="nc"><i>2883</i>&nbsp;            }</b>
<b class="nc"><i>2884</i>&nbsp;            if (minWidth == maxWidth &amp;&amp; signStyle == SignStyle.NOT_NEGATIVE) {</b>
<i>2885</i>&nbsp;                return &quot;Value(&quot; + field + &quot;,&quot; + minWidth + &quot;)&quot;;
<b class="nc"><i>2886</i>&nbsp;            }</b>
<i>2887</i>&nbsp;            return &quot;Value(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth + &quot;,&quot; + signStyle + &quot;)&quot;;
<i>2888</i>&nbsp;        }
<i>2889</i>&nbsp;    }
<i>2890</i>&nbsp;
<b class="nc"><i>2891</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>2892</i>&nbsp;    /**
<i>2893</i>&nbsp;     * Prints and parses a reduced numeric date-time field.
<i>2894</i>&nbsp;     */
<i>2895</i>&nbsp;    static final class ReducedPrinterParser extends NumberPrinterParser {
<i>2896</i>&nbsp;        /**
<i>2897</i>&nbsp;         * The base date for reduced value parsing.
<i>2898</i>&nbsp;         */
<i>2899</i>&nbsp;        static final LocalDate BASE_DATE = LocalDate.of(2000, 1, 1);
<i>2900</i>&nbsp;
<i>2901</i>&nbsp;        private final int baseValue;
<i>2902</i>&nbsp;        private final ChronoLocalDate baseDate;
<i>2903</i>&nbsp;
<i>2904</i>&nbsp;        /**
<i>2905</i>&nbsp;         * Constructor.
<i>2906</i>&nbsp;         *
<i>2907</i>&nbsp;         * @param field  the field to format, validated not null
<i>2908</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 10
<i>2909</i>&nbsp;         * @param maxWidth  the maximum field width, from 1 to 10
<i>2910</i>&nbsp;         * @param baseValue  the base value
<i>2911</i>&nbsp;         * @param baseDate  the base date
<i>2912</i>&nbsp;         */
<b class="nc"><i>2913</i>&nbsp;        ReducedPrinterParser(TemporalField field, int minWidth, int maxWidth,</b>
<b class="nc"><i>2914</i>&nbsp;                int baseValue, ChronoLocalDate baseDate) {</b>
<b class="nc"><i>2915</i>&nbsp;            this(field, minWidth, maxWidth, baseValue, baseDate, 0);</b>
<b class="nc"><i>2916</i>&nbsp;            if (minWidth &lt; 1 || minWidth &gt; 10) {</b>
<i>2917</i>&nbsp;                throw new IllegalArgumentException(&quot;The minWidth must be from 1 to 10 inclusive but was &quot; + minWidth);
<b class="nc"><i>2918</i>&nbsp;            }</b>
<b class="nc"><i>2919</i>&nbsp;            if (maxWidth &lt; 1 || maxWidth &gt; 10) {</b>
<i>2920</i>&nbsp;                throw new IllegalArgumentException(&quot;The maxWidth must be from 1 to 10 inclusive but was &quot; + minWidth);
<b class="nc"><i>2921</i>&nbsp;            }</b>
<b class="nc"><i>2922</i>&nbsp;            if (maxWidth &lt; minWidth) {</b>
<i>2923</i>&nbsp;                throw new IllegalArgumentException(&quot;Maximum width must exceed or equal the minimum width but &quot; +
<b class="nc"><i>2924</i>&nbsp;                        maxWidth + &quot; &lt; &quot; + minWidth);</b>
<b class="nc"><i>2925</i>&nbsp;            }</b>
<i>2926</i>&nbsp;            if (baseDate == null) {
<i>2927</i>&nbsp;                if (field.range().isValidValue(baseValue) == false) {
<b class="nc"><i>2928</i>&nbsp;                    throw new IllegalArgumentException(&quot;The base value must be within the range of the field&quot;);</b>
<b class="nc"><i>2929</i>&nbsp;                }</b>
<b class="nc"><i>2930</i>&nbsp;                if ((((long) baseValue) + EXCEED_POINTS[maxWidth]) &gt; Integer.MAX_VALUE) {</b>
<b class="nc"><i>2931</i>&nbsp;                    throw new DateTimeException(&quot;Unable to add printer-parser as the range exceeds the capacity of an int&quot;);</b>
<i>2932</i>&nbsp;                }
<i>2933</i>&nbsp;            }
<i>2934</i>&nbsp;        }
<i>2935</i>&nbsp;
<b class="nc"><i>2936</i>&nbsp;        /**</b>
<b class="nc"><i>2937</i>&nbsp;         * Constructor.</b>
<b class="nc"><i>2938</i>&nbsp;         * The arguments have already been checked.</b>
<i>2939</i>&nbsp;         *
<b class="nc"><i>2940</i>&nbsp;         * @param field  the field to format, validated not null</b>
<b class="nc"><i>2941</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 10</b>
<b class="nc"><i>2942</i>&nbsp;         * @param maxWidth  the maximum field width, from 1 to 10</b>
<b class="nc"><i>2943</i>&nbsp;         * @param baseValue  the base value</b>
<b class="nc"><i>2944</i>&nbsp;         * @param baseDate  the base date</b>
<b class="nc"><i>2945</i>&nbsp;         * @param subsequentWidth the subsequentWidth for this instance</b>
<i>2946</i>&nbsp;         */
<b class="nc"><i>2947</i>&nbsp;        private ReducedPrinterParser(TemporalField field, int minWidth, int maxWidth,</b>
<b class="nc"><i>2948</i>&nbsp;                int baseValue, ChronoLocalDate baseDate, int subsequentWidth) {</b>
<i>2949</i>&nbsp;            super(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth);
<i>2950</i>&nbsp;            this.baseValue = baseValue;
<i>2951</i>&nbsp;            this.baseDate = baseDate;
<b class="nc"><i>2952</i>&nbsp;        }</b>
<b class="nc"><i>2953</i>&nbsp;</b>
<b class="nc"><i>2954</i>&nbsp;        @Override</b>
<b class="nc"><i>2955</i>&nbsp;        long getValue(DateTimePrintContext context, long value) {</b>
<b class="nc"><i>2956</i>&nbsp;            long absValue = Math.abs(value);</b>
<b class="nc"><i>2957</i>&nbsp;            int baseValue = this.baseValue;</b>
<i>2958</i>&nbsp;            if (baseDate != null) {
<b class="nc"><i>2959</i>&nbsp;                Chronology chrono = Chronology.from(context.getTemporal());</b>
<i>2960</i>&nbsp;                baseValue = chrono.date(baseDate).get(field);
<b class="nc"><i>2961</i>&nbsp;            }</b>
<i>2962</i>&nbsp;            if (value &gt;= baseValue &amp;&amp; value &lt; baseValue + EXCEED_POINTS[minWidth]) {
<i>2963</i>&nbsp;                // Use the reduced value if it fits in minWidth
<i>2964</i>&nbsp;                return absValue % EXCEED_POINTS[minWidth];
<i>2965</i>&nbsp;            }
<b class="nc"><i>2966</i>&nbsp;            // Otherwise truncate to fit in maxWidth</b>
<b class="nc"><i>2967</i>&nbsp;            return absValue % EXCEED_POINTS[maxWidth];</b>
<b class="nc"><i>2968</i>&nbsp;        }</b>
<b class="nc"><i>2969</i>&nbsp;</b>
<i>2970</i>&nbsp;        @Override
<b class="nc"><i>2971</i>&nbsp;        int setValue(DateTimeParseContext context, long value, int errorPos, int successPos) {</b>
<i>2972</i>&nbsp;            int baseValue = this.baseValue;
<b class="nc"><i>2973</i>&nbsp;            if (baseDate != null) {</b>
<b class="nc"><i>2974</i>&nbsp;                Chronology chrono = context.getEffectiveChronology();</b>
<i>2975</i>&nbsp;                baseValue = chrono.date(baseDate).get(field);
<b class="nc"><i>2976</i>&nbsp;</b>
<i>2977</i>&nbsp;                // In case the Chronology is changed later, add a callback when/if it changes
<b class="nc"><i>2978</i>&nbsp;                final long initialValue = value;</b>
<i>2979</i>&nbsp;                context.addChronoChangedListener(
<b class="nc"><i>2980</i>&nbsp;                        (_unused) -&gt;  {</b>
<b class="nc"><i>2981</i>&nbsp;                            /* Repeat the set of the field using the current Chronology</b>
<b class="nc"><i>2982</i>&nbsp;                             * The success/error position is ignored because the value is</b>
<i>2983</i>&nbsp;                             * intentionally being overwritten.
<b class="nc"><i>2984</i>&nbsp;                             */</b>
<b class="nc"><i>2985</i>&nbsp;                            setValue(context, initialValue, errorPos, successPos);</b>
<b class="nc"><i>2986</i>&nbsp;                        });</b>
<b class="nc"><i>2987</i>&nbsp;            }</b>
<b class="nc"><i>2988</i>&nbsp;            int parseLen = successPos - errorPos;</b>
<b class="nc"><i>2989</i>&nbsp;            if (parseLen == minWidth &amp;&amp; value &gt;= 0) {</b>
<b class="nc"><i>2990</i>&nbsp;                long range = EXCEED_POINTS[minWidth];</b>
<b class="nc"><i>2991</i>&nbsp;                long lastPart = baseValue % range;</b>
<b class="nc"><i>2992</i>&nbsp;                long basePart = baseValue - lastPart;</b>
<i>2993</i>&nbsp;                if (baseValue &gt; 0) {
<b class="nc"><i>2994</i>&nbsp;                    value = basePart + value;</b>
<b class="nc"><i>2995</i>&nbsp;                } else {</b>
<i>2996</i>&nbsp;                    value = basePart - value;
<b class="nc"><i>2997</i>&nbsp;                }</b>
<b class="nc"><i>2998</i>&nbsp;                if (value &lt; baseValue) {</b>
<b class="nc"><i>2999</i>&nbsp;                    value += range;</b>
<b class="nc"><i>3000</i>&nbsp;                }</b>
<b class="nc"><i>3001</i>&nbsp;            }</b>
<i>3002</i>&nbsp;            return context.setParsedField(field, value, errorPos, successPos);
<i>3003</i>&nbsp;        }
<i>3004</i>&nbsp;
<i>3005</i>&nbsp;        /**
<i>3006</i>&nbsp;         * Returns a new instance with fixed width flag set.
<i>3007</i>&nbsp;         *
<i>3008</i>&nbsp;         * @return a new updated printer-parser, not null
<i>3009</i>&nbsp;         */
<i>3010</i>&nbsp;        @Override
<i>3011</i>&nbsp;        ReducedPrinterParser withFixedWidth() {
<i>3012</i>&nbsp;            if (subsequentWidth == -1) {
<i>3013</i>&nbsp;                return this;
<i>3014</i>&nbsp;            }
<i>3015</i>&nbsp;            return new ReducedPrinterParser(field, minWidth, maxWidth, baseValue, baseDate, -1);
<i>3016</i>&nbsp;        }
<i>3017</i>&nbsp;
<i>3018</i>&nbsp;        /**
<i>3019</i>&nbsp;         * Returns a new instance with an updated subsequent width.
<i>3020</i>&nbsp;         *
<b class="nc"><i>3021</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater</b>
<b class="nc"><i>3022</i>&nbsp;         * @return a new updated printer-parser, not null</b>
<b class="nc"><i>3023</i>&nbsp;         */</b>
<b class="nc"><i>3024</i>&nbsp;        @Override</b>
<b class="nc"><i>3025</i>&nbsp;        ReducedPrinterParser withSubsequentWidth(int subsequentWidth) {</b>
<b class="nc"><i>3026</i>&nbsp;            return new ReducedPrinterParser(field, minWidth, maxWidth, baseValue, baseDate,</b>
<i>3027</i>&nbsp;                    this.subsequentWidth + subsequentWidth);
<b class="nc"><i>3028</i>&nbsp;        }</b>
<i>3029</i>&nbsp;
<i>3030</i>&nbsp;        /**
<i>3031</i>&nbsp;         * For a ReducedPrinterParser, fixed width is false if the mode is strict,
<i>3032</i>&nbsp;         * otherwise it is set as for NumberPrinterParser.
<i>3033</i>&nbsp;         * @param context the context
<i>3034</i>&nbsp;         * @return if the field is fixed width
<i>3035</i>&nbsp;         * @see DateTimeFormatterBuilder#appendValueReduced(java.time.temporal.TemporalField, int, int, int)
<i>3036</i>&nbsp;         */
<i>3037</i>&nbsp;        @Override
<i>3038</i>&nbsp;        boolean isFixedWidth(DateTimeParseContext context) {
<i>3039</i>&nbsp;           if (context.isStrict() == false) {
<i>3040</i>&nbsp;               return false;
<i>3041</i>&nbsp;           }
<i>3042</i>&nbsp;           return super.isFixedWidth(context);
<i>3043</i>&nbsp;        }
<i>3044</i>&nbsp;
<i>3045</i>&nbsp;        @Override
<i>3046</i>&nbsp;        public String toString() {
<i>3047</i>&nbsp;            return &quot;ReducedValue(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth +
<b class="nc"><i>3048</i>&nbsp;                    &quot;,&quot; + Objects.requireNonNullElse(baseDate, baseValue) + &quot;)&quot;;</b>
<b class="nc"><i>3049</i>&nbsp;        }</b>
<b class="nc"><i>3050</i>&nbsp;    }</b>
<b class="nc"><i>3051</i>&nbsp;</b>
<b class="nc"><i>3052</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>3053</i>&nbsp;    /**
<i>3054</i>&nbsp;     * Prints and parses a numeric date-time field with optional padding.
<i>3055</i>&nbsp;     */
<i>3056</i>&nbsp;    static final class FractionPrinterParser extends NumberPrinterParser {
<b class="nc"><i>3057</i>&nbsp;        private final boolean decimalPoint;</b>
<b class="nc"><i>3058</i>&nbsp;</b>
<i>3059</i>&nbsp;        /**
<i>3060</i>&nbsp;         * Constructor.
<i>3061</i>&nbsp;         *
<i>3062</i>&nbsp;         * @param field  the field to output, not null
<i>3063</i>&nbsp;         * @param minWidth  the minimum width to output, from 0 to 9
<i>3064</i>&nbsp;         * @param maxWidth  the maximum width to output, from 0 to 9
<i>3065</i>&nbsp;         * @param decimalPoint  whether to output the localized decimal point symbol
<i>3066</i>&nbsp;         */
<i>3067</i>&nbsp;        FractionPrinterParser(TemporalField field, int minWidth, int maxWidth, boolean decimalPoint) {
<i>3068</i>&nbsp;            this(field, minWidth, maxWidth, decimalPoint, 0);
<i>3069</i>&nbsp;            Objects.requireNonNull(field, &quot;field&quot;);
<i>3070</i>&nbsp;            if (field.range().isFixed() == false) {
<i>3071</i>&nbsp;                throw new IllegalArgumentException(&quot;Field must have a fixed set of values: &quot; + field);
<i>3072</i>&nbsp;            }
<i>3073</i>&nbsp;            if (minWidth &lt; 0 || minWidth &gt; 9) {
<i>3074</i>&nbsp;                throw new IllegalArgumentException(&quot;Minimum width must be from 0 to 9 inclusive but was &quot; + minWidth);
<i>3075</i>&nbsp;            }
<i>3076</i>&nbsp;            if (maxWidth &lt; 1 || maxWidth &gt; 9) {
<i>3077</i>&nbsp;                throw new IllegalArgumentException(&quot;Maximum width must be from 1 to 9 inclusive but was &quot; + maxWidth);
<i>3078</i>&nbsp;            }
<i>3079</i>&nbsp;            if (maxWidth &lt; minWidth) {
<i>3080</i>&nbsp;                throw new IllegalArgumentException(&quot;Maximum width must exceed or equal the minimum width but &quot; +
<i>3081</i>&nbsp;                        maxWidth + &quot; &lt; &quot; + minWidth);
<i>3082</i>&nbsp;            }
<b class="nc"><i>3083</i>&nbsp;        }</b>
<i>3084</i>&nbsp;
<b class="nc"><i>3085</i>&nbsp;        /**</b>
<b class="nc"><i>3086</i>&nbsp;         * Constructor.</b>
<b class="nc"><i>3087</i>&nbsp;         *</b>
<i>3088</i>&nbsp;         * @param field  the field to output, not null
<i>3089</i>&nbsp;         * @param minWidth  the minimum width to output, from 0 to 9
<i>3090</i>&nbsp;         * @param maxWidth  the maximum width to output, from 0 to 9
<i>3091</i>&nbsp;         * @param decimalPoint  whether to output the localized decimal point symbol
<b class="nc"><i>3092</i>&nbsp;         * @param subsequentWidth the subsequentWidth for this instance</b>
<b class="nc"><i>3093</i>&nbsp;         */</b>
<b class="nc"><i>3094</i>&nbsp;        FractionPrinterParser(TemporalField field, int minWidth, int maxWidth, boolean decimalPoint, int subsequentWidth) {</b>
<i>3095</i>&nbsp;            super(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth);
<i>3096</i>&nbsp;            this.decimalPoint = decimalPoint;
<b class="nc"><i>3097</i>&nbsp;        }</b>
<b class="nc"><i>3098</i>&nbsp;</b>
<b class="nc"><i>3099</i>&nbsp;        /**</b>
<i>3100</i>&nbsp;         * Returns a new instance with fixed width flag set.
<b class="nc"><i>3101</i>&nbsp;         *</b>
<i>3102</i>&nbsp;         * @return a new updated printer-parser, not null
<b class="nc"><i>3103</i>&nbsp;         */</b>
<b class="nc"><i>3104</i>&nbsp;        @Override</b>
<i>3105</i>&nbsp;        FractionPrinterParser withFixedWidth() {
<b class="nc"><i>3106</i>&nbsp;            if (subsequentWidth == -1) {</b>
<b class="nc"><i>3107</i>&nbsp;                return this;</b>
<i>3108</i>&nbsp;            }
<i>3109</i>&nbsp;            return new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint, -1);
<i>3110</i>&nbsp;        }
<i>3111</i>&nbsp;
<b class="nc"><i>3112</i>&nbsp;        /**</b>
<b class="nc"><i>3113</i>&nbsp;         * Returns a new instance with an updated subsequent width.</b>
<b class="nc"><i>3114</i>&nbsp;         *</b>
<i>3115</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
<b class="nc"><i>3116</i>&nbsp;         * @return a new updated printer-parser, not null</b>
<b class="nc"><i>3117</i>&nbsp;         */</b>
<i>3118</i>&nbsp;        @Override
<b class="nc"><i>3119</i>&nbsp;        FractionPrinterParser withSubsequentWidth(int subsequentWidth) {</b>
<b class="nc"><i>3120</i>&nbsp;            return new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint, this.subsequentWidth + subsequentWidth);</b>
<i>3121</i>&nbsp;        }
<b class="nc"><i>3122</i>&nbsp;</b>
<i>3123</i>&nbsp;        /**
<b class="nc"><i>3124</i>&nbsp;         * For FractionPrinterPrinterParser, the width is fixed if context is sttrict,</b>
<b class="nc"><i>3125</i>&nbsp;         * minWidth equal to maxWidth and decimalpoint is absent.</b>
<b class="nc"><i>3126</i>&nbsp;         * @param context the context</b>
<b class="nc"><i>3127</i>&nbsp;         * @return if the field is fixed width</b>
<b class="nc"><i>3128</i>&nbsp;         * @see DateTimeFormatterBuilder#appendValueFraction(java.time.temporal.TemporalField, int, int, boolean)</b>
<b class="nc"><i>3129</i>&nbsp;         */</b>
<i>3130</i>&nbsp;        @Override
<b class="nc"><i>3131</i>&nbsp;        boolean isFixedWidth(DateTimeParseContext context) {</b>
<b class="nc"><i>3132</i>&nbsp;            if (context.isStrict() &amp;&amp; minWidth == maxWidth &amp;&amp; decimalPoint == false) {</b>
<b class="nc"><i>3133</i>&nbsp;                return true;</b>
<i>3134</i>&nbsp;            }
<i>3135</i>&nbsp;            return false;
<b class="nc"><i>3136</i>&nbsp;        }</b>
<i>3137</i>&nbsp;
<i>3138</i>&nbsp;        @Override
<i>3139</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>3140</i>&nbsp;            Long value = context.getValue(field);
<i>3141</i>&nbsp;            if (value == null) {
<i>3142</i>&nbsp;                return false;
<i>3143</i>&nbsp;            }
<b class="nc"><i>3144</i>&nbsp;            DecimalStyle decimalStyle = context.getDecimalStyle();</b>
<b class="nc"><i>3145</i>&nbsp;            BigDecimal fraction = convertToFraction(value);</b>
<i>3146</i>&nbsp;            if (fraction.scale() == 0) {  // scale is zero if value is zero
<b class="nc"><i>3147</i>&nbsp;                if (minWidth &gt; 0) {</b>
<i>3148</i>&nbsp;                    if (decimalPoint) {
<i>3149</i>&nbsp;                        buf.append(decimalStyle.getDecimalSeparator());
<i>3150</i>&nbsp;                    }
<i>3151</i>&nbsp;                    for (int i = 0; i &lt; minWidth; i++) {
<b class="nc"><i>3152</i>&nbsp;                        buf.append(decimalStyle.getZeroDigit());</b>
<b class="nc"><i>3153</i>&nbsp;                    }</b>
<i>3154</i>&nbsp;                }
<b class="nc"><i>3155</i>&nbsp;            } else {</b>
<i>3156</i>&nbsp;                int outputScale = Math.min(Math.max(fraction.scale(), minWidth), maxWidth);
<i>3157</i>&nbsp;                fraction = fraction.setScale(outputScale, RoundingMode.FLOOR);
<i>3158</i>&nbsp;                String str = fraction.toPlainString().substring(2);
<i>3159</i>&nbsp;                str = decimalStyle.convertNumberToI18N(str);
<i>3160</i>&nbsp;                if (decimalPoint) {
<i>3161</i>&nbsp;                    buf.append(decimalStyle.getDecimalSeparator());
<i>3162</i>&nbsp;                }
<i>3163</i>&nbsp;                buf.append(str);
<i>3164</i>&nbsp;            }
<i>3165</i>&nbsp;            return true;
<i>3166</i>&nbsp;        }
<i>3167</i>&nbsp;
<i>3168</i>&nbsp;        @Override
<i>3169</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>3170</i>&nbsp;            int effectiveMin = (context.isStrict() || isFixedWidth(context) ? minWidth : 0);
<b class="nc"><i>3171</i>&nbsp;            int effectiveMax = (context.isStrict() || isFixedWidth(context) ? maxWidth : 9);</b>
<b class="nc"><i>3172</i>&nbsp;            int length = text.length();</b>
<i>3173</i>&nbsp;            if (position == length) {
<i>3174</i>&nbsp;                // valid if whole field is optional, invalid if minimum width
<i>3175</i>&nbsp;                return (effectiveMin &gt; 0 ? ~position : position);
<i>3176</i>&nbsp;            }
<i>3177</i>&nbsp;            if (decimalPoint) {
<b class="nc"><i>3178</i>&nbsp;                if (text.charAt(position) != context.getDecimalStyle().getDecimalSeparator()) {</b>
<b class="nc"><i>3179</i>&nbsp;                    // valid if whole field is optional, invalid if minimum width</b>
<b class="nc"><i>3180</i>&nbsp;                    return (effectiveMin &gt; 0 ? ~position : position);</b>
<b class="nc"><i>3181</i>&nbsp;                }</b>
<i>3182</i>&nbsp;                position++;
<b class="nc"><i>3183</i>&nbsp;            }</b>
<b class="nc"><i>3184</i>&nbsp;            int minEndPos = position + effectiveMin;</b>
<i>3185</i>&nbsp;            if (minEndPos &gt; length) {
<b class="nc"><i>3186</i>&nbsp;                return ~position;  // need at least min width digits</b>
<b class="nc"><i>3187</i>&nbsp;            }</b>
<i>3188</i>&nbsp;            int maxEndPos = Math.min(position + effectiveMax, length);
<b class="nc"><i>3189</i>&nbsp;            int total = 0;  // can use int because we are only parsing up to 9 digits</b>
<i>3190</i>&nbsp;            int pos = position;
<b class="nc"><i>3191</i>&nbsp;            while (pos &lt; maxEndPos) {</b>
<b class="nc"><i>3192</i>&nbsp;                char ch = text.charAt(pos++);</b>
<b class="nc"><i>3193</i>&nbsp;                int digit = context.getDecimalStyle().convertToDigit(ch);</b>
<b class="nc"><i>3194</i>&nbsp;                if (digit &lt; 0) {</b>
<b class="nc"><i>3195</i>&nbsp;                    if (pos &lt; minEndPos) {</b>
<b class="nc"><i>3196</i>&nbsp;                        return ~position;  // need at least min width digits</b>
<i>3197</i>&nbsp;                    }
<b class="nc"><i>3198</i>&nbsp;                    pos--;</b>
<b class="nc"><i>3199</i>&nbsp;                    break;</b>
<b class="nc"><i>3200</i>&nbsp;                }</b>
<i>3201</i>&nbsp;                total = total * 10 + digit;
<b class="nc"><i>3202</i>&nbsp;            }</b>
<i>3203</i>&nbsp;            BigDecimal fraction = new BigDecimal(total).movePointLeft(pos - position);
<b class="nc"><i>3204</i>&nbsp;            long value = convertFromFraction(fraction);</b>
<b class="nc"><i>3205</i>&nbsp;            return context.setParsedField(field, value, position, pos);</b>
<b class="nc"><i>3206</i>&nbsp;        }</b>
<b class="nc"><i>3207</i>&nbsp;</b>
<b class="nc"><i>3208</i>&nbsp;        /**</b>
<b class="nc"><i>3209</i>&nbsp;         * Converts a value for this field to a fraction between 0 and 1.</b>
<b class="nc"><i>3210</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>3211</i>&nbsp;         * The fractional value is between 0 (inclusive) and 1 (exclusive).</b>
<i>3212</i>&nbsp;         * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
<b class="nc"><i>3213</i>&nbsp;         * The fraction is obtained by calculation from the field range using 9 decimal</b>
<b class="nc"><i>3214</i>&nbsp;         * places and a rounding mode of {@link RoundingMode#FLOOR FLOOR}.</b>
<b class="nc"><i>3215</i>&nbsp;         * The calculation is inaccurate if the values do not run continuously from smallest to largest.</b>
<b class="nc"><i>3216</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>3217</i>&nbsp;         * For example, the second-of-minute value of 15 would be returned as 0.25,</b>
<i>3218</i>&nbsp;         * assuming the standard definition of 60 seconds in a minute.
<b class="nc"><i>3219</i>&nbsp;         *</b>
<i>3220</i>&nbsp;         * @param value  the value to convert, must be valid for this rule
<i>3221</i>&nbsp;         * @return the value as a fraction within the range, from 0 to 1, not null
<i>3222</i>&nbsp;         * @throws DateTimeException if the value cannot be converted to a fraction
<i>3223</i>&nbsp;         */
<b class="nc"><i>3224</i>&nbsp;        private BigDecimal convertToFraction(long value) {</b>
<b class="nc"><i>3225</i>&nbsp;            ValueRange range = field.range();</b>
<b class="nc"><i>3226</i>&nbsp;            range.checkValidValue(value, field);</b>
<b class="nc"><i>3227</i>&nbsp;            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());</b>
<i>3228</i>&nbsp;            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);
<b class="nc"><i>3229</i>&nbsp;            BigDecimal valueBD = BigDecimal.valueOf(value).subtract(minBD);</b>
<b class="nc"><i>3230</i>&nbsp;            BigDecimal fraction = valueBD.divide(rangeBD, 9, RoundingMode.FLOOR);</b>
<b class="nc"><i>3231</i>&nbsp;            // stripTrailingZeros bug</b>
<b class="nc"><i>3232</i>&nbsp;            return fraction.compareTo(BigDecimal.ZERO) == 0 ? BigDecimal.ZERO : fraction.stripTrailingZeros();</b>
<b class="nc"><i>3233</i>&nbsp;        }</b>
<i>3234</i>&nbsp;
<i>3235</i>&nbsp;        /**
<b class="nc"><i>3236</i>&nbsp;         * Converts a fraction from 0 to 1 for this field to a value.</b>
<b class="nc"><i>3237</i>&nbsp;         * &lt;p&gt;</b>
<i>3238</i>&nbsp;         * The fractional value must be between 0 (inclusive) and 1 (exclusive).
<i>3239</i>&nbsp;         * It can only be returned if the {@link java.time.temporal.TemporalField#range() value range} is fixed.
<i>3240</i>&nbsp;         * The value is obtained by calculation from the field range and a rounding
<i>3241</i>&nbsp;         * mode of {@link RoundingMode#FLOOR FLOOR}.
<i>3242</i>&nbsp;         * The calculation is inaccurate if the values do not run continuously from smallest to largest.
<b class="nc"><i>3243</i>&nbsp;         * &lt;p&gt;</b>
<b class="nc"><i>3244</i>&nbsp;         * For example, the fractional second-of-minute of 0.25 would be converted to 15,</b>
<b class="nc"><i>3245</i>&nbsp;         * assuming the standard definition of 60 seconds in a minute.</b>
<b class="nc"><i>3246</i>&nbsp;         *</b>
<b class="nc"><i>3247</i>&nbsp;         * @param fraction  the fraction to convert, not null</b>
<b class="nc"><i>3248</i>&nbsp;         * @return the value of the field, valid for this rule</b>
<b class="nc"><i>3249</i>&nbsp;         * @throws DateTimeException if the value cannot be converted</b>
<b class="nc"><i>3250</i>&nbsp;         */</b>
<b class="nc"><i>3251</i>&nbsp;        private long convertFromFraction(BigDecimal fraction) {</b>
<b class="nc"><i>3252</i>&nbsp;            ValueRange range = field.range();</b>
<b class="nc"><i>3253</i>&nbsp;            BigDecimal minBD = BigDecimal.valueOf(range.getMinimum());</b>
<b class="nc"><i>3254</i>&nbsp;            BigDecimal rangeBD = BigDecimal.valueOf(range.getMaximum()).subtract(minBD).add(BigDecimal.ONE);</b>
<b class="nc"><i>3255</i>&nbsp;            BigDecimal valueBD = fraction.multiply(rangeBD).setScale(0, RoundingMode.FLOOR).add(minBD);</b>
<b class="nc"><i>3256</i>&nbsp;            return valueBD.longValueExact();</b>
<i>3257</i>&nbsp;        }
<i>3258</i>&nbsp;
<i>3259</i>&nbsp;        @Override
<b class="nc"><i>3260</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>3261</i>&nbsp;            String decimal = (decimalPoint ? &quot;,DecimalPoint&quot; : &quot;&quot;);</b>
<b class="nc"><i>3262</i>&nbsp;            return &quot;Fraction(&quot; + field + &quot;,&quot; + minWidth + &quot;,&quot; + maxWidth + decimal + &quot;)&quot;;</b>
<b class="nc"><i>3263</i>&nbsp;        }</b>
<b class="nc"><i>3264</i>&nbsp;    }</b>
<b class="nc"><i>3265</i>&nbsp;</b>
<b class="nc"><i>3266</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>3267</i>&nbsp;    /**</b>
<b class="nc"><i>3268</i>&nbsp;     * Prints or parses field text.</b>
<b class="nc"><i>3269</i>&nbsp;     */</b>
<b class="nc"><i>3270</i>&nbsp;    static final class TextPrinterParser implements DateTimePrinterParser {</b>
<b class="nc"><i>3271</i>&nbsp;        private final TemporalField field;</b>
<b class="nc"><i>3272</i>&nbsp;        private final TextStyle textStyle;</b>
<b class="nc"><i>3273</i>&nbsp;        private final DateTimeTextProvider provider;</b>
<b class="nc"><i>3274</i>&nbsp;        /**</b>
<b class="nc"><i>3275</i>&nbsp;         * The cached number printer parser.</b>
<i>3276</i>&nbsp;         * Immutable and volatile, so no synchronization needed.
<b class="nc"><i>3277</i>&nbsp;         */</b>
<i>3278</i>&nbsp;        private volatile NumberPrinterParser numberPrinterParser;
<i>3279</i>&nbsp;
<b class="nc"><i>3280</i>&nbsp;        /**</b>
<b class="nc"><i>3281</i>&nbsp;         * Constructor.</b>
<b class="nc"><i>3282</i>&nbsp;         *</b>
<b class="nc"><i>3283</i>&nbsp;         * @param field  the field to output, not null</b>
<b class="nc"><i>3284</i>&nbsp;         * @param textStyle  the text style, not null</b>
<b class="nc"><i>3285</i>&nbsp;         * @param provider  the text provider, not null</b>
<b class="nc"><i>3286</i>&nbsp;         */</b>
<b class="nc"><i>3287</i>&nbsp;        TextPrinterParser(TemporalField field, TextStyle textStyle, DateTimeTextProvider provider) {</b>
<b class="nc"><i>3288</i>&nbsp;            // validated by caller</b>
<i>3289</i>&nbsp;            this.field = field;
<i>3290</i>&nbsp;            this.textStyle = textStyle;
<i>3291</i>&nbsp;            this.provider = provider;
<i>3292</i>&nbsp;        }
<b class="nc"><i>3293</i>&nbsp;</b>
<i>3294</i>&nbsp;        @Override
<i>3295</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>3296</i>&nbsp;            Long value = context.getValue(field);
<i>3297</i>&nbsp;            if (value == null) {
<i>3298</i>&nbsp;                return false;
<i>3299</i>&nbsp;            }
<i>3300</i>&nbsp;            String text;
<i>3301</i>&nbsp;            Chronology chrono = context.getTemporal().query(TemporalQueries.chronology());
<b class="nc"><i>3302</i>&nbsp;            if (chrono == null || chrono == IsoChronology.INSTANCE) {</b>
<i>3303</i>&nbsp;                text = provider.getText(field, value, textStyle, context.getLocale());
<i>3304</i>&nbsp;            } else {
<b class="nc"><i>3305</i>&nbsp;                text = provider.getText(chrono, field, value, textStyle, context.getLocale());</b>
<b class="nc"><i>3306</i>&nbsp;            }</b>
<i>3307</i>&nbsp;            if (text == null) {
<i>3308</i>&nbsp;                return numberPrinterParser().format(context, buf);
<i>3309</i>&nbsp;            }
<i>3310</i>&nbsp;            buf.append(text);
<i>3311</i>&nbsp;            return true;
<i>3312</i>&nbsp;        }
<i>3313</i>&nbsp;
<i>3314</i>&nbsp;        @Override
<i>3315</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence parseText, int position) {
<i>3316</i>&nbsp;            int length = parseText.length();
<b class="nc"><i>3317</i>&nbsp;            if (position &lt; 0 || position &gt; length) {</b>
<b class="nc"><i>3318</i>&nbsp;                throw new IndexOutOfBoundsException();</b>
<b class="nc"><i>3319</i>&nbsp;            }</b>
<b class="nc"><i>3320</i>&nbsp;            TextStyle style = (context.isStrict() ? textStyle : null);</b>
<b class="nc"><i>3321</i>&nbsp;            Chronology chrono = context.getEffectiveChronology();</b>
<i>3322</i>&nbsp;            Iterator&lt;Entry&lt;String, Long&gt;&gt; it;
<i>3323</i>&nbsp;            if (chrono == null || chrono == IsoChronology.INSTANCE) {
<i>3324</i>&nbsp;                it = provider.getTextIterator(field, style, context.getLocale());
<b class="nc"><i>3325</i>&nbsp;            } else {</b>
<b class="nc"><i>3326</i>&nbsp;                it = provider.getTextIterator(chrono, field, style, context.getLocale());</b>
<b class="nc"><i>3327</i>&nbsp;            }</b>
<i>3328</i>&nbsp;            if (it != null) {
<i>3329</i>&nbsp;                while (it.hasNext()) {
<b class="nc"><i>3330</i>&nbsp;                    Entry&lt;String, Long&gt; entry = it.next();</b>
<i>3331</i>&nbsp;                    String itText = entry.getKey();
<i>3332</i>&nbsp;                    if (context.subSequenceEquals(itText, 0, parseText, position, itText.length())) {
<i>3333</i>&nbsp;                        return context.setParsedField(field, entry.getValue(), position, position + itText.length());
<i>3334</i>&nbsp;                    }
<b class="nc"><i>3335</i>&nbsp;                }</b>
<b class="nc"><i>3336</i>&nbsp;                if (field == ERA &amp;&amp; !context.isStrict()) {</b>
<b class="nc"><i>3337</i>&nbsp;                    // parse the possible era name from era.toString()</b>
<i>3338</i>&nbsp;                    List&lt;Era&gt; eras = chrono.eras();
<b class="nc"><i>3339</i>&nbsp;                    for (Era era : eras) {</b>
<b class="nc"><i>3340</i>&nbsp;                        String name = era.toString();</b>
<b class="nc"><i>3341</i>&nbsp;                        if (context.subSequenceEquals(name, 0, parseText, position, name.length())) {</b>
<i>3342</i>&nbsp;                            return context.setParsedField(field, era.getValue(), position, position + name.length());
<b class="nc"><i>3343</i>&nbsp;                        }</b>
<b class="nc"><i>3344</i>&nbsp;                    }</b>
<b class="nc"><i>3345</i>&nbsp;                }</b>
<b class="nc"><i>3346</i>&nbsp;                if (context.isStrict()) {</b>
<b class="nc"><i>3347</i>&nbsp;                    return ~position;</b>
<b class="nc"><i>3348</i>&nbsp;                }</b>
<b class="nc"><i>3349</i>&nbsp;            }</b>
<b class="nc"><i>3350</i>&nbsp;            return numberPrinterParser().parse(context, parseText, position);</b>
<b class="nc"><i>3351</i>&nbsp;        }</b>
<b class="nc"><i>3352</i>&nbsp;</b>
<b class="nc"><i>3353</i>&nbsp;        /**</b>
<b class="nc"><i>3354</i>&nbsp;         * Create and cache a number printer parser.</b>
<b class="nc"><i>3355</i>&nbsp;         * @return the number printer parser for this field, not null</b>
<b class="nc"><i>3356</i>&nbsp;         */</b>
<b class="nc"><i>3357</i>&nbsp;        private NumberPrinterParser numberPrinterParser() {</b>
<i>3358</i>&nbsp;            if (numberPrinterParser == null) {
<i>3359</i>&nbsp;                numberPrinterParser = new NumberPrinterParser(field, 1, 19, SignStyle.NORMAL);
<b class="nc"><i>3360</i>&nbsp;            }</b>
<b class="nc"><i>3361</i>&nbsp;            return numberPrinterParser;</b>
<b class="nc"><i>3362</i>&nbsp;        }</b>
<i>3363</i>&nbsp;
<i>3364</i>&nbsp;        @Override
<b class="nc"><i>3365</i>&nbsp;        public String toString() {</b>
<i>3366</i>&nbsp;            if (textStyle == TextStyle.FULL) {
<i>3367</i>&nbsp;                return &quot;Text(&quot; + field + &quot;)&quot;;
<i>3368</i>&nbsp;            }
<i>3369</i>&nbsp;            return &quot;Text(&quot; + field + &quot;,&quot; + textStyle + &quot;)&quot;;
<b class="nc"><i>3370</i>&nbsp;        }</b>
<b class="nc"><i>3371</i>&nbsp;    }</b>
<b class="nc"><i>3372</i>&nbsp;</b>
<b class="nc"><i>3373</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>3374</i>&nbsp;    /**</b>
<i>3375</i>&nbsp;     * Prints or parses an ISO-8601 instant.
<i>3376</i>&nbsp;     */
<b class="nc"><i>3377</i>&nbsp;    static final class InstantPrinterParser implements DateTimePrinterParser {</b>
<b class="nc"><i>3378</i>&nbsp;        // days in a 400 year cycle = 146097</b>
<i>3379</i>&nbsp;        // days in a 10,000 year cycle = 146097 * 25
<b class="nc"><i>3380</i>&nbsp;        // seconds per day = 86400</b>
<b class="nc"><i>3381</i>&nbsp;        private static final long SECONDS_PER_10000_YEARS = 146097L * 25L * 86400L;</b>
<i>3382</i>&nbsp;        private static final long SECONDS_0000_TO_1970 = ((146097L * 5L) - (30L * 365L + 7L)) * 86400L;
<i>3383</i>&nbsp;        private final int fractionalDigits;
<i>3384</i>&nbsp;
<i>3385</i>&nbsp;        InstantPrinterParser(int fractionalDigits) {
<b class="nc"><i>3386</i>&nbsp;            this.fractionalDigits = fractionalDigits;</b>
<b class="nc"><i>3387</i>&nbsp;        }</b>
<i>3388</i>&nbsp;
<b class="nc"><i>3389</i>&nbsp;        @Override</b>
<b class="nc"><i>3390</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<b class="nc"><i>3391</i>&nbsp;            // use INSTANT_SECONDS, thus this code is not bound by Instant.MAX</b>
<b class="nc"><i>3392</i>&nbsp;            Long inSecs = context.getValue(INSTANT_SECONDS);</b>
<b class="nc"><i>3393</i>&nbsp;            Long inNanos = null;</b>
<b class="nc"><i>3394</i>&nbsp;            if (context.getTemporal().isSupported(NANO_OF_SECOND)) {</b>
<i>3395</i>&nbsp;                inNanos = context.getTemporal().getLong(NANO_OF_SECOND);
<b class="nc"><i>3396</i>&nbsp;            }</b>
<b class="nc"><i>3397</i>&nbsp;            if (inSecs == null) {</b>
<i>3398</i>&nbsp;                return false;
<i>3399</i>&nbsp;            }
<i>3400</i>&nbsp;            long inSec = inSecs;
<b class="nc"><i>3401</i>&nbsp;            int inNano = NANO_OF_SECOND.checkValidIntValue(inNanos != null ? inNanos : 0);</b>
<b class="nc"><i>3402</i>&nbsp;            // format mostly using LocalDateTime.toString</b>
<i>3403</i>&nbsp;            if (inSec &gt;= -SECONDS_0000_TO_1970) {
<b class="nc"><i>3404</i>&nbsp;                // current era</b>
<i>3405</i>&nbsp;                long zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
<i>3406</i>&nbsp;                long hi = Math.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
<i>3407</i>&nbsp;                long lo = Math.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
<i>3408</i>&nbsp;                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
<i>3409</i>&nbsp;                if (hi &gt; 0) {
<i>3410</i>&nbsp;                    buf.append(&#39;+&#39;).append(hi);
<i>3411</i>&nbsp;                }
<i>3412</i>&nbsp;                buf.append(ldt);
<i>3413</i>&nbsp;                if (ldt.getSecond() == 0) {
<i>3414</i>&nbsp;                    buf.append(&quot;:00&quot;);
<i>3415</i>&nbsp;                }
<i>3416</i>&nbsp;            } else {
<b class="nc"><i>3417</i>&nbsp;                // before current era</b>
<b class="nc"><i>3418</i>&nbsp;                long zeroSecs = inSec + SECONDS_0000_TO_1970;</b>
<i>3419</i>&nbsp;                long hi = zeroSecs / SECONDS_PER_10000_YEARS;
<b class="nc"><i>3420</i>&nbsp;                long lo = zeroSecs % SECONDS_PER_10000_YEARS;</b>
<b class="nc"><i>3421</i>&nbsp;                LocalDateTime ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);</b>
<b class="nc"><i>3422</i>&nbsp;                int pos = buf.length();</b>
<b class="nc"><i>3423</i>&nbsp;                buf.append(ldt);</b>
<i>3424</i>&nbsp;                if (ldt.getSecond() == 0) {
<b class="nc"><i>3425</i>&nbsp;                    buf.append(&quot;:00&quot;);</b>
<i>3426</i>&nbsp;                }
<b class="nc"><i>3427</i>&nbsp;                if (hi &lt; 0) {</b>
<b class="nc"><i>3428</i>&nbsp;                    if (ldt.getYear() == -10_000) {</b>
<i>3429</i>&nbsp;                        buf.replace(pos, pos + 2, Long.toString(hi - 1));
<b class="nc"><i>3430</i>&nbsp;                    } else if (lo == 0) {</b>
<b class="nc"><i>3431</i>&nbsp;                        buf.insert(pos, hi);</b>
<b class="nc"><i>3432</i>&nbsp;                    } else {</b>
<b class="nc"><i>3433</i>&nbsp;                        buf.insert(pos + 1, Math.abs(hi));</b>
<i>3434</i>&nbsp;                    }
<b class="nc"><i>3435</i>&nbsp;                }</b>
<b class="nc"><i>3436</i>&nbsp;            }</b>
<b class="nc"><i>3437</i>&nbsp;            // add fraction</b>
<i>3438</i>&nbsp;            if ((fractionalDigits &lt; 0 &amp;&amp; inNano &gt; 0) || fractionalDigits &gt; 0) {
<b class="nc"><i>3439</i>&nbsp;                buf.append(&#39;.&#39;);</b>
<b class="nc"><i>3440</i>&nbsp;                int div = 100_000_000;</b>
<b class="nc"><i>3441</i>&nbsp;                for (int i = 0; ((fractionalDigits == -1 &amp;&amp; inNano &gt; 0) ||</b>
<i>3442</i>&nbsp;                                    (fractionalDigits == -2 &amp;&amp; (inNano &gt; 0 || (i % 3) != 0)) ||
<i>3443</i>&nbsp;                                    i &lt; fractionalDigits); i++) {
<i>3444</i>&nbsp;                    int digit = inNano / div;
<i>3445</i>&nbsp;                    buf.append((char) (digit + &#39;0&#39;));
<b class="nc"><i>3446</i>&nbsp;                    inNano = inNano - (digit * div);</b>
<b class="nc"><i>3447</i>&nbsp;                    div = div / 10;</b>
<i>3448</i>&nbsp;                }
<i>3449</i>&nbsp;            }
<i>3450</i>&nbsp;            buf.append(&#39;Z&#39;);
<i>3451</i>&nbsp;            return true;
<i>3452</i>&nbsp;        }
<i>3453</i>&nbsp;
<i>3454</i>&nbsp;        @Override
<i>3455</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>3456</i>&nbsp;            // new context to avoid overwriting fields like year/month/day
<i>3457</i>&nbsp;            int minDigits = (fractionalDigits &lt; 0 ? 0 : fractionalDigits);
<i>3458</i>&nbsp;            int maxDigits = (fractionalDigits &lt; 0 ? 9 : fractionalDigits);
<i>3459</i>&nbsp;            CompositePrinterParser parser = new DateTimeFormatterBuilder()
<i>3460</i>&nbsp;                    .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral(&#39;T&#39;)
<i>3461</i>&nbsp;                    .appendValue(HOUR_OF_DAY, 2).appendLiteral(&#39;:&#39;)
<i>3462</i>&nbsp;                    .appendValue(MINUTE_OF_HOUR, 2).appendLiteral(&#39;:&#39;)
<b class="nc"><i>3463</i>&nbsp;                    .appendValue(SECOND_OF_MINUTE, 2)</b>
<b class="nc"><i>3464</i>&nbsp;                    .appendFraction(NANO_OF_SECOND, minDigits, maxDigits, true)</b>
<i>3465</i>&nbsp;                    .appendLiteral(&#39;Z&#39;)
<i>3466</i>&nbsp;                    .toFormatter().toPrinterParser(false);
<i>3467</i>&nbsp;            DateTimeParseContext newContext = context.copy();
<b class="nc"><i>3468</i>&nbsp;            int pos = parser.parse(newContext, text, position);</b>
<b class="nc"><i>3469</i>&nbsp;            if (pos &lt; 0) {</b>
<i>3470</i>&nbsp;                return pos;
<i>3471</i>&nbsp;            }
<i>3472</i>&nbsp;            // parser restricts most fields to 2 digits, so definitely int
<i>3473</i>&nbsp;            // correctly parsed nano is also guaranteed to be valid
<b class="nc"><i>3474</i>&nbsp;            long yearParsed = newContext.getParsed(YEAR);</b>
<b class="nc"><i>3475</i>&nbsp;            int month = newContext.getParsed(MONTH_OF_YEAR).intValue();</b>
<b class="nc"><i>3476</i>&nbsp;            int day = newContext.getParsed(DAY_OF_MONTH).intValue();</b>
<i>3477</i>&nbsp;            int hour = newContext.getParsed(HOUR_OF_DAY).intValue();
<b class="nc"><i>3478</i>&nbsp;            int min = newContext.getParsed(MINUTE_OF_HOUR).intValue();</b>
<b class="nc"><i>3479</i>&nbsp;            Long secVal = newContext.getParsed(SECOND_OF_MINUTE);</b>
<b class="nc"><i>3480</i>&nbsp;            Long nanoVal = newContext.getParsed(NANO_OF_SECOND);</b>
<i>3481</i>&nbsp;            int sec = (secVal != null ? secVal.intValue() : 0);
<b class="nc"><i>3482</i>&nbsp;            int nano = (nanoVal != null ? nanoVal.intValue() : 0);</b>
<b class="nc"><i>3483</i>&nbsp;            int days = 0;</b>
<b class="nc"><i>3484</i>&nbsp;            if (hour == 24 &amp;&amp; min == 0 &amp;&amp; sec == 0 &amp;&amp; nano == 0) {</b>
<b class="nc"><i>3485</i>&nbsp;                hour = 0;</b>
<b class="nc"><i>3486</i>&nbsp;                days = 1;</b>
<b class="nc"><i>3487</i>&nbsp;            } else if (hour == 23 &amp;&amp; min == 59 &amp;&amp; sec == 60) {</b>
<b class="nc"><i>3488</i>&nbsp;                context.setParsedLeapSecond();</b>
<b class="nc"><i>3489</i>&nbsp;                sec = 59;</b>
<b class="nc"><i>3490</i>&nbsp;            }</b>
<b class="nc"><i>3491</i>&nbsp;            int year = (int) yearParsed % 10_000;</b>
<b class="nc"><i>3492</i>&nbsp;            long instantSecs;</b>
<b class="nc"><i>3493</i>&nbsp;            try {</b>
<b class="nc"><i>3494</i>&nbsp;                LocalDateTime ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);</b>
<i>3495</i>&nbsp;                instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
<i>3496</i>&nbsp;                instantSecs += Math.multiplyExact(yearParsed / 10_000L, SECONDS_PER_10000_YEARS);
<b class="nc"><i>3497</i>&nbsp;            } catch (RuntimeException ex) {</b>
<b class="nc"><i>3498</i>&nbsp;                return ~position;</b>
<i>3499</i>&nbsp;            }
<b class="nc"><i>3500</i>&nbsp;            int successPos = pos;</b>
<b class="nc"><i>3501</i>&nbsp;            successPos = context.setParsedField(INSTANT_SECONDS, instantSecs, position, successPos);</b>
<b class="nc"><i>3502</i>&nbsp;            return context.setParsedField(NANO_OF_SECOND, nano, position, successPos);</b>
<b class="nc"><i>3503</i>&nbsp;        }</b>
<b class="nc"><i>3504</i>&nbsp;</b>
<b class="nc"><i>3505</i>&nbsp;        @Override</b>
<b class="nc"><i>3506</i>&nbsp;        public String toString() {</b>
<i>3507</i>&nbsp;            return &quot;Instant()&quot;;
<i>3508</i>&nbsp;        }
<i>3509</i>&nbsp;    }
<i>3510</i>&nbsp;
<b class="nc"><i>3511</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>3512</i>&nbsp;    /**
<i>3513</i>&nbsp;     * Prints or parses an offset ID.
<i>3514</i>&nbsp;     */
<b class="nc"><i>3515</i>&nbsp;    static final class OffsetIdPrinterParser implements DateTimePrinterParser {</b>
<b class="nc"><i>3516</i>&nbsp;        static final String[] PATTERNS = new String[] {</b>
<b class="nc"><i>3517</i>&nbsp;                &quot;+HH&quot;, &quot;+HHmm&quot;, &quot;+HH:mm&quot;, &quot;+HHMM&quot;, &quot;+HH:MM&quot;, &quot;+HHMMss&quot;, &quot;+HH:MM:ss&quot;, &quot;+HHMMSS&quot;, &quot;+HH:MM:SS&quot;, &quot;+HHmmss&quot;, &quot;+HH:mm:ss&quot;,</b>
<i>3518</i>&nbsp;                &quot;+H&quot;,  &quot;+Hmm&quot;,  &quot;+H:mm&quot;,  &quot;+HMM&quot;,  &quot;+H:MM&quot;,  &quot;+HMMss&quot;,  &quot;+H:MM:ss&quot;,  &quot;+HMMSS&quot;,  &quot;+H:MM:SS&quot;,  &quot;+Hmmss&quot;,  &quot;+H:mm:ss&quot;,
<b class="nc"><i>3519</i>&nbsp;        };  // order used in pattern builder</b>
<i>3520</i>&nbsp;        static final OffsetIdPrinterParser INSTANCE_ID_Z = new OffsetIdPrinterParser(&quot;+HH:MM:ss&quot;, &quot;Z&quot;);
<i>3521</i>&nbsp;        static final OffsetIdPrinterParser INSTANCE_ID_ZERO = new OffsetIdPrinterParser(&quot;+HH:MM:ss&quot;, &quot;0&quot;);
<i>3522</i>&nbsp;
<i>3523</i>&nbsp;        private final String noOffsetText;
<b class="nc"><i>3524</i>&nbsp;        private final int type;</b>
<b class="nc"><i>3525</i>&nbsp;        private final int style;</b>
<b class="nc"><i>3526</i>&nbsp;</b>
<b class="nc"><i>3527</i>&nbsp;        /**</b>
<b class="nc"><i>3528</i>&nbsp;         * Constructor.</b>
<b class="nc"><i>3529</i>&nbsp;         *</b>
<i>3530</i>&nbsp;         * @param pattern  the pattern
<b class="nc"><i>3531</i>&nbsp;         * @param noOffsetText  the text to use for UTC, not null</b>
<i>3532</i>&nbsp;         */
<i>3533</i>&nbsp;        OffsetIdPrinterParser(String pattern, String noOffsetText) {
<b class="nc"><i>3534</i>&nbsp;            Objects.requireNonNull(pattern, &quot;pattern&quot;);</b>
<b class="nc"><i>3535</i>&nbsp;            Objects.requireNonNull(noOffsetText, &quot;noOffsetText&quot;);</b>
<b class="nc"><i>3536</i>&nbsp;            this.type = checkPattern(pattern);</b>
<i>3537</i>&nbsp;            this.style = type % 11;
<b class="nc"><i>3538</i>&nbsp;            this.noOffsetText = noOffsetText;</b>
<b class="nc"><i>3539</i>&nbsp;        }</b>
<b class="nc"><i>3540</i>&nbsp;</b>
<b class="nc"><i>3541</i>&nbsp;        private int checkPattern(String pattern) {</b>
<b class="nc"><i>3542</i>&nbsp;            for (int i = 0; i &lt; PATTERNS.length; i++) {</b>
<i>3543</i>&nbsp;                if (PATTERNS[i].equals(pattern)) {
<b class="nc"><i>3544</i>&nbsp;                    return i;</b>
<i>3545</i>&nbsp;                }
<b class="nc"><i>3546</i>&nbsp;            }</b>
<b class="nc"><i>3547</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid zone offset pattern: &quot; + pattern);</b>
<b class="nc"><i>3548</i>&nbsp;        }</b>
<b class="nc"><i>3549</i>&nbsp;</b>
<b class="nc"><i>3550</i>&nbsp;        private boolean isPaddedHour() {</b>
<b class="nc"><i>3551</i>&nbsp;            return type &lt; 11;</b>
<b class="nc"><i>3552</i>&nbsp;        }</b>
<b class="nc"><i>3553</i>&nbsp;</b>
<b class="nc"><i>3554</i>&nbsp;        private boolean isColon() {</b>
<i>3555</i>&nbsp;            return style &gt; 0 &amp;&amp; (style % 2) == 0;
<b class="nc"><i>3556</i>&nbsp;        }</b>
<b class="nc"><i>3557</i>&nbsp;</b>
<b class="nc"><i>3558</i>&nbsp;        @Override</b>
<b class="nc"><i>3559</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {</b>
<b class="nc"><i>3560</i>&nbsp;            Long offsetSecs = context.getValue(OFFSET_SECONDS);</b>
<i>3561</i>&nbsp;            if (offsetSecs == null) {
<b class="nc"><i>3562</i>&nbsp;                return false;</b>
<b class="nc"><i>3563</i>&nbsp;            }</b>
<b class="nc"><i>3564</i>&nbsp;            int totalSecs = Math.toIntExact(offsetSecs);</b>
<b class="nc"><i>3565</i>&nbsp;            if (totalSecs == 0) {</b>
<b class="nc"><i>3566</i>&nbsp;                buf.append(noOffsetText);</b>
<b class="nc"><i>3567</i>&nbsp;            } else {</b>
<b class="nc"><i>3568</i>&nbsp;                int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped</b>
<i>3569</i>&nbsp;                int absMinutes = Math.abs((totalSecs / 60) % 60);
<i>3570</i>&nbsp;                int absSeconds = Math.abs(totalSecs % 60);
<b class="nc"><i>3571</i>&nbsp;                int bufPos = buf.length();</b>
<b class="nc"><i>3572</i>&nbsp;                int output = absHours;</b>
<b class="nc"><i>3573</i>&nbsp;                buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;);</b>
<b class="nc"><i>3574</i>&nbsp;                if (isPaddedHour() || absHours &gt;= 10) {</b>
<i>3575</i>&nbsp;                    formatZeroPad(false, absHours, buf);
<b class="nc"><i>3576</i>&nbsp;                } else {</b>
<b class="nc"><i>3577</i>&nbsp;                    buf.append((char) (absHours + &#39;0&#39;));</b>
<b class="nc"><i>3578</i>&nbsp;                }</b>
<b class="nc"><i>3579</i>&nbsp;                if ((style &gt;= 3 &amp;&amp; style &lt;= 8) || (style &gt;= 9 &amp;&amp; absSeconds &gt; 0) || (style &gt;= 1 &amp;&amp; absMinutes &gt; 0)) {</b>
<b class="nc"><i>3580</i>&nbsp;                    formatZeroPad(isColon(), absMinutes, buf);</b>
<i>3581</i>&nbsp;                    output += absMinutes;
<b class="nc"><i>3582</i>&nbsp;                    if (style == 7 || style == 8 || (style &gt;= 5 &amp;&amp; absSeconds &gt; 0)) {</b>
<b class="nc"><i>3583</i>&nbsp;                        formatZeroPad(isColon(), absSeconds, buf);</b>
<b class="nc"><i>3584</i>&nbsp;                        output += absSeconds;</b>
<b class="nc"><i>3585</i>&nbsp;                    }</b>
<b class="nc"><i>3586</i>&nbsp;                }</b>
<b class="nc"><i>3587</i>&nbsp;                if (output == 0) {</b>
<b class="nc"><i>3588</i>&nbsp;                    buf.setLength(bufPos);</b>
<b class="nc"><i>3589</i>&nbsp;                    buf.append(noOffsetText);</b>
<b class="nc"><i>3590</i>&nbsp;                }</b>
<b class="nc"><i>3591</i>&nbsp;            }</b>
<b class="nc"><i>3592</i>&nbsp;            return true;</b>
<b class="nc"><i>3593</i>&nbsp;        }</b>
<b class="nc"><i>3594</i>&nbsp;</b>
<i>3595</i>&nbsp;        private void formatZeroPad(boolean colon, int value, StringBuilder buf) {
<i>3596</i>&nbsp;            buf.append(colon ? &quot;:&quot; : &quot;&quot;)
<i>3597</i>&nbsp;                    .append((char) (value / 10 + &#39;0&#39;))
<i>3598</i>&nbsp;                    .append((char) (value % 10 + &#39;0&#39;));
<i>3599</i>&nbsp;        }
<i>3600</i>&nbsp;
<i>3601</i>&nbsp;        @Override
<b class="nc"><i>3602</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {</b>
<b class="nc"><i>3603</i>&nbsp;            int length = text.length();</b>
<i>3604</i>&nbsp;            int noOffsetLen = noOffsetText.length();
<i>3605</i>&nbsp;            if (noOffsetLen == 0) {
<i>3606</i>&nbsp;                if (position == length) {
<i>3607</i>&nbsp;                    return context.setParsedField(OFFSET_SECONDS, 0, position, position);
<b class="nc"><i>3608</i>&nbsp;                }</b>
<i>3609</i>&nbsp;            } else {
<i>3610</i>&nbsp;                if (position == length) {
<i>3611</i>&nbsp;                    return ~position;
<i>3612</i>&nbsp;                }
<i>3613</i>&nbsp;                if (context.subSequenceEquals(text, position, noOffsetText, 0, noOffsetLen)) {
<i>3614</i>&nbsp;                    return context.setParsedField(OFFSET_SECONDS, 0, position, position + noOffsetLen);
<i>3615</i>&nbsp;                }
<i>3616</i>&nbsp;            }
<i>3617</i>&nbsp;
<i>3618</i>&nbsp;            // parse normal plus/minus offset
<i>3619</i>&nbsp;            char sign = text.charAt(position);  // IOOBE if invalid position
<i>3620</i>&nbsp;            if (sign == &#39;+&#39; || sign == &#39;-&#39;) {
<i>3621</i>&nbsp;                // starts
<i>3622</i>&nbsp;                int negative = (sign == &#39;-&#39; ? -1 : 1);
<i>3623</i>&nbsp;                boolean isColon = isColon();
<i>3624</i>&nbsp;                boolean paddedHour = isPaddedHour();
<b class="nc"><i>3625</i>&nbsp;                int[] array = new int[4];</b>
<b class="nc"><i>3626</i>&nbsp;                array[0] = position + 1;</b>
<b class="nc"><i>3627</i>&nbsp;                int parseType = type;</b>
<b class="nc"><i>3628</i>&nbsp;                // select parse type when lenient</b>
<b class="nc"><i>3629</i>&nbsp;                if (!context.isStrict()) {</b>
<b class="nc"><i>3630</i>&nbsp;                    if (paddedHour) {</b>
<b class="nc"><i>3631</i>&nbsp;                        if (isColon || (parseType == 0 &amp;&amp; length &gt; position + 3 &amp;&amp; text.charAt(position + 3) == &#39;:&#39;)) {</b>
<i>3632</i>&nbsp;                            isColon = true; // needed in cases like (&quot;+HH&quot;, &quot;+01:01&quot;)
<i>3633</i>&nbsp;                            parseType = 10;
<i>3634</i>&nbsp;                        } else {
<i>3635</i>&nbsp;                            parseType = 9;
<i>3636</i>&nbsp;                        }
<i>3637</i>&nbsp;                    } else {
<b class="nc"><i>3638</i>&nbsp;                        if (isColon || (parseType == 11 &amp;&amp; length &gt; position + 3 &amp;&amp; (text.charAt(position + 2) == &#39;:&#39; || text.charAt(position + 3) == &#39;:&#39;))) {</b>
<i>3639</i>&nbsp;                            isColon = true;
<i>3640</i>&nbsp;                            parseType = 21;  // needed in cases like (&quot;+H&quot;, &quot;+1:01&quot;)
<i>3641</i>&nbsp;                        } else {
<b class="nc"><i>3642</i>&nbsp;                            parseType = 20;</b>
<b class="nc"><i>3643</i>&nbsp;                        }</b>
<i>3644</i>&nbsp;                    }
<i>3645</i>&nbsp;                }
<b class="nc"><i>3646</i>&nbsp;                // parse according to the selected pattern</b>
<b class="nc"><i>3647</i>&nbsp;                switch (parseType) {</b>
<b class="nc"><i>3648</i>&nbsp;                    case 0: // +HH</b>
<b class="nc"><i>3649</i>&nbsp;                    case 11: // +H</b>
<b class="nc"><i>3650</i>&nbsp;                        parseHour(text, paddedHour, array);</b>
<b class="nc"><i>3651</i>&nbsp;                        break;</b>
<b class="nc"><i>3652</i>&nbsp;                    case 1: // +HHmm</b>
<i>3653</i>&nbsp;                    case 2: // +HH:mm
<b class="nc"><i>3654</i>&nbsp;                    case 13: // +H:mm</b>
<b class="nc"><i>3655</i>&nbsp;                        parseHour(text, paddedHour, array);</b>
<b class="nc"><i>3656</i>&nbsp;                        parseMinute(text, isColon, false, array);</b>
<b class="nc"><i>3657</i>&nbsp;                        break;</b>
<b class="nc"><i>3658</i>&nbsp;                    case 3: // +HHMM</b>
<i>3659</i>&nbsp;                    case 4: // +HH:MM
<b class="nc"><i>3660</i>&nbsp;                    case 15: // +H:MM</b>
<b class="nc"><i>3661</i>&nbsp;                        parseHour(text, paddedHour, array);</b>
<b class="nc"><i>3662</i>&nbsp;                        parseMinute(text, isColon, true, array);</b>
<b class="nc"><i>3663</i>&nbsp;                        break;</b>
<i>3664</i>&nbsp;                    case 5: // +HHMMss
<b class="nc"><i>3665</i>&nbsp;                    case 6: // +HH:MM:ss</b>
<b class="nc"><i>3666</i>&nbsp;                    case 17: // +H:MM:ss</b>
<i>3667</i>&nbsp;                        parseHour(text, paddedHour, array);
<b class="nc"><i>3668</i>&nbsp;                        parseMinute(text, isColon, true, array);</b>
<b class="nc"><i>3669</i>&nbsp;                        parseSecond(text, isColon, false, array);</b>
<i>3670</i>&nbsp;                        break;
<b class="nc"><i>3671</i>&nbsp;                    case 7: // +HHMMSS</b>
<i>3672</i>&nbsp;                    case 8: // +HH:MM:SS
<b class="nc"><i>3673</i>&nbsp;                    case 19: // +H:MM:SS</b>
<i>3674</i>&nbsp;                        parseHour(text, paddedHour, array);
<b class="nc"><i>3675</i>&nbsp;                        parseMinute(text, isColon, true, array);</b>
<i>3676</i>&nbsp;                        parseSecond(text, isColon, true, array);
<b class="nc"><i>3677</i>&nbsp;                        break;</b>
<i>3678</i>&nbsp;                    case 9: // +HHmmss
<i>3679</i>&nbsp;                    case 10: // +HH:mm:ss
<i>3680</i>&nbsp;                    case 21: // +H:mm:ss
<i>3681</i>&nbsp;                        parseHour(text, paddedHour, array);
<b class="nc"><i>3682</i>&nbsp;                        parseOptionalMinuteSecond(text, isColon, array);</b>
<b class="nc"><i>3683</i>&nbsp;                        break;</b>
<b class="nc"><i>3684</i>&nbsp;                    case 12: // +Hmm</b>
<i>3685</i>&nbsp;                        parseVariableWidthDigits(text, 1, 4, array);
<b class="nc"><i>3686</i>&nbsp;                        break;</b>
<b class="nc"><i>3687</i>&nbsp;                    case 14: // +HMM</b>
<b class="nc"><i>3688</i>&nbsp;                        parseVariableWidthDigits(text, 3, 4, array);</b>
<b class="nc"><i>3689</i>&nbsp;                        break;</b>
<b class="nc"><i>3690</i>&nbsp;                    case 16: // +HMMss</b>
<b class="nc"><i>3691</i>&nbsp;                        parseVariableWidthDigits(text, 3, 6, array);</b>
<i>3692</i>&nbsp;                        break;
<b class="nc"><i>3693</i>&nbsp;                    case 18: // +HMMSS</b>
<b class="nc"><i>3694</i>&nbsp;                        parseVariableWidthDigits(text, 5, 6, array);</b>
<b class="nc"><i>3695</i>&nbsp;                        break;</b>
<i>3696</i>&nbsp;                    case 20: // +Hmmss
<i>3697</i>&nbsp;                        parseVariableWidthDigits(text, 1, 6, array);
<b class="nc"><i>3698</i>&nbsp;                        break;</b>
<b class="nc"><i>3699</i>&nbsp;                }</b>
<i>3700</i>&nbsp;                if (array[0] &gt; 0) {
<i>3701</i>&nbsp;                    if (array[1] &gt; 23 || array[2] &gt; 59 || array[3] &gt; 59) {
<i>3702</i>&nbsp;                        throw new DateTimeException(&quot;Value out of range: Hour[0-23], Minute[0-59], Second[0-59]&quot;);
<b class="nc"><i>3703</i>&nbsp;                    }</b>
<i>3704</i>&nbsp;                    long offsetSecs = negative * (array[1] * 3600L + array[2] * 60L + array[3]);
<b class="nc"><i>3705</i>&nbsp;                    return context.setParsedField(OFFSET_SECONDS, offsetSecs, position, array[0]);</b>
<i>3706</i>&nbsp;                }
<i>3707</i>&nbsp;            }
<i>3708</i>&nbsp;            // handle special case of empty no offset text
<i>3709</i>&nbsp;            if (noOffsetLen == 0) {
<b class="nc"><i>3710</i>&nbsp;                return context.setParsedField(OFFSET_SECONDS, 0, position, position);</b>
<b class="nc"><i>3711</i>&nbsp;            }</b>
<i>3712</i>&nbsp;            return ~position;
<b class="nc"><i>3713</i>&nbsp;        }</b>
<b class="nc"><i>3714</i>&nbsp;</b>
<b class="nc"><i>3715</i>&nbsp;        private void parseHour(CharSequence parseText, boolean paddedHour, int[] array) {</b>
<b class="nc"><i>3716</i>&nbsp;            if (paddedHour) {</b>
<i>3717</i>&nbsp;                // parse two digits
<b class="nc"><i>3718</i>&nbsp;                if (!parseDigits(parseText, false, 1, array)) {</b>
<i>3719</i>&nbsp;                    array[0] = ~array[0];
<i>3720</i>&nbsp;                }
<b class="nc"><i>3721</i>&nbsp;            } else {</b>
<b class="nc"><i>3722</i>&nbsp;                // parse one or two digits</b>
<b class="nc"><i>3723</i>&nbsp;                parseVariableWidthDigits(parseText, 1, 2, array);</b>
<b class="nc"><i>3724</i>&nbsp;            }</b>
<b class="nc"><i>3725</i>&nbsp;        }</b>
<b class="nc"><i>3726</i>&nbsp;</b>
<b class="nc"><i>3727</i>&nbsp;        private void parseMinute(CharSequence parseText, boolean isColon, boolean mandatory, int[] array) {</b>
<b class="nc"><i>3728</i>&nbsp;            if (!parseDigits(parseText, isColon, 2, array)) {</b>
<b class="nc"><i>3729</i>&nbsp;                if (mandatory) {</b>
<b class="nc"><i>3730</i>&nbsp;                    array[0] = ~array[0];</b>
<b class="nc"><i>3731</i>&nbsp;                }</b>
<b class="nc"><i>3732</i>&nbsp;            }</b>
<i>3733</i>&nbsp;        }
<b class="nc"><i>3734</i>&nbsp;</b>
<b class="nc"><i>3735</i>&nbsp;        private void parseSecond(CharSequence parseText, boolean isColon, boolean mandatory, int[] array) {</b>
<b class="nc"><i>3736</i>&nbsp;            if (!parseDigits(parseText, isColon, 3, array)) {</b>
<b class="nc"><i>3737</i>&nbsp;                if (mandatory) {</b>
<b class="nc"><i>3738</i>&nbsp;                    array[0] = ~array[0];</b>
<i>3739</i>&nbsp;                }
<i>3740</i>&nbsp;            }
<i>3741</i>&nbsp;        }
<i>3742</i>&nbsp;
<b class="nc"><i>3743</i>&nbsp;        private void parseOptionalMinuteSecond(CharSequence parseText, boolean isColon, int[] array) {</b>
<b class="nc"><i>3744</i>&nbsp;            if (parseDigits(parseText, isColon, 2, array)) {</b>
<b class="nc"><i>3745</i>&nbsp;                parseDigits(parseText, isColon, 3, array);</b>
<b class="nc"><i>3746</i>&nbsp;            }</b>
<b class="nc"><i>3747</i>&nbsp;        }</b>
<i>3748</i>&nbsp;
<b class="nc"><i>3749</i>&nbsp;        private boolean parseDigits(CharSequence parseText, boolean isColon, int arrayIndex, int[] array) {</b>
<b class="nc"><i>3750</i>&nbsp;            int pos = array[0];</b>
<b class="nc"><i>3751</i>&nbsp;            if (pos &lt; 0) {</b>
<i>3752</i>&nbsp;                return true;
<i>3753</i>&nbsp;            }
<i>3754</i>&nbsp;            if (isColon &amp;&amp; arrayIndex != 1) { //  &#39;:&#39; will precede only in case of minute/second
<b class="nc"><i>3755</i>&nbsp;                if (pos + 1 &gt; parseText.length() || parseText.charAt(pos) != &#39;:&#39;) {</b>
<i>3756</i>&nbsp;                    return false;
<b class="nc"><i>3757</i>&nbsp;                }</b>
<i>3758</i>&nbsp;                pos++;
<i>3759</i>&nbsp;            }
<i>3760</i>&nbsp;            if (pos + 2 &gt; parseText.length()) {
<i>3761</i>&nbsp;                return false;
<i>3762</i>&nbsp;            }
<i>3763</i>&nbsp;            char ch1 = parseText.charAt(pos++);
<i>3764</i>&nbsp;            char ch2 = parseText.charAt(pos++);
<i>3765</i>&nbsp;            if (ch1 &lt; &#39;0&#39; || ch1 &gt; &#39;9&#39; || ch2 &lt; &#39;0&#39; || ch2 &gt; &#39;9&#39;) {
<i>3766</i>&nbsp;                return false;
<i>3767</i>&nbsp;            }
<i>3768</i>&nbsp;            int value = (ch1 - 48) * 10 + (ch2 - 48);
<b class="nc"><i>3769</i>&nbsp;            if (value &lt; 0 || value &gt; 59) {</b>
<b class="nc"><i>3770</i>&nbsp;                return false;</b>
<b class="nc"><i>3771</i>&nbsp;            }</b>
<i>3772</i>&nbsp;            array[arrayIndex] = value;
<i>3773</i>&nbsp;            array[0] = pos;
<i>3774</i>&nbsp;            return true;
<i>3775</i>&nbsp;        }
<b class="nc"><i>3776</i>&nbsp;</b>
<b class="nc"><i>3777</i>&nbsp;        private void parseVariableWidthDigits(CharSequence parseText, int minDigits, int maxDigits, int[] array) {</b>
<b class="nc"><i>3778</i>&nbsp;            // scan the text to find the available number of digits up to maxDigits</b>
<i>3779</i>&nbsp;            // so long as the number available is minDigits or more, the input is valid
<b class="nc"><i>3780</i>&nbsp;            // then parse the number of available digits</b>
<b class="nc"><i>3781</i>&nbsp;            int pos = array[0];</b>
<i>3782</i>&nbsp;            int available = 0;
<i>3783</i>&nbsp;            char[] chars = new char[maxDigits];
<i>3784</i>&nbsp;            for (int i = 0; i &lt; maxDigits; i++) {
<i>3785</i>&nbsp;                if (pos + 1  &gt; parseText.length()) {
<i>3786</i>&nbsp;                    break;
<i>3787</i>&nbsp;                }
<i>3788</i>&nbsp;                char ch = parseText.charAt(pos++);
<i>3789</i>&nbsp;                if (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) {
<i>3790</i>&nbsp;                    pos--;
<i>3791</i>&nbsp;                    break;
<b class="nc"><i>3792</i>&nbsp;                }</b>
<b class="nc"><i>3793</i>&nbsp;                chars[i] = ch;</b>
<b class="nc"><i>3794</i>&nbsp;                available++;</b>
<i>3795</i>&nbsp;            }
<b class="nc"><i>3796</i>&nbsp;            if (available &lt; minDigits) {</b>
<b class="nc"><i>3797</i>&nbsp;                array[0] = ~array[0];</b>
<b class="nc"><i>3798</i>&nbsp;                return;</b>
<b class="nc"><i>3799</i>&nbsp;            }</b>
<b class="nc"><i>3800</i>&nbsp;            switch (available) {</b>
<b class="nc"><i>3801</i>&nbsp;                case 1:</b>
<b class="nc"><i>3802</i>&nbsp;                    array[1] = (chars[0] - 48);</b>
<i>3803</i>&nbsp;                    break;
<b class="nc"><i>3804</i>&nbsp;                case 2:</b>
<i>3805</i>&nbsp;                    array[1] = ((chars[0] - 48) * 10 + (chars[1] - 48));
<i>3806</i>&nbsp;                    break;
<b class="nc"><i>3807</i>&nbsp;                case 3:</b>
<i>3808</i>&nbsp;                    array[1] = (chars[0] - 48);
<b class="nc"><i>3809</i>&nbsp;                    array[2] = ((chars[1] - 48) * 10 + (chars[2] - 48));</b>
<i>3810</i>&nbsp;                    break;
<i>3811</i>&nbsp;                case 4:
<i>3812</i>&nbsp;                    array[1] = ((chars[0] - 48) * 10 + (chars[1] - 48));
<i>3813</i>&nbsp;                    array[2] = ((chars[2] - 48) * 10 + (chars[3] - 48));
<i>3814</i>&nbsp;                    break;
<i>3815</i>&nbsp;                case 5:
<i>3816</i>&nbsp;                    array[1] = (chars[0] - 48);
<i>3817</i>&nbsp;                    array[2] = ((chars[1] - 48) * 10 + (chars[2] - 48));
<i>3818</i>&nbsp;                    array[3] = ((chars[3] - 48) * 10 + (chars[4] - 48));
<b class="nc"><i>3819</i>&nbsp;                    break;</b>
<b class="nc"><i>3820</i>&nbsp;                case 6:</b>
<b class="nc"><i>3821</i>&nbsp;                    array[1] = ((chars[0] - 48) * 10 + (chars[1] - 48));</b>
<i>3822</i>&nbsp;                    array[2] = ((chars[2] - 48) * 10 + (chars[3] - 48));
<b class="nc"><i>3823</i>&nbsp;                    array[3] = ((chars[4] - 48) * 10 + (chars[5] - 48));</b>
<b class="nc"><i>3824</i>&nbsp;                    break;</b>
<i>3825</i>&nbsp;            }
<i>3826</i>&nbsp;            array[0] = pos;
<i>3827</i>&nbsp;        }
<b class="nc"><i>3828</i>&nbsp;</b>
<b class="nc"><i>3829</i>&nbsp;        @Override</b>
<b class="nc"><i>3830</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>3831</i>&nbsp;            String converted = noOffsetText.replace(&quot;&#39;&quot;, &quot;&#39;&#39;&quot;);</b>
<b class="nc"><i>3832</i>&nbsp;            return &quot;Offset(&quot; + PATTERNS[type] + &quot;,&#39;&quot; + converted + &quot;&#39;)&quot;;</b>
<b class="nc"><i>3833</i>&nbsp;        }</b>
<b class="nc"><i>3834</i>&nbsp;    }</b>
<b class="nc"><i>3835</i>&nbsp;</b>
<i>3836</i>&nbsp;    //-----------------------------------------------------------------------
<b class="nc"><i>3837</i>&nbsp;    /**</b>
<b class="nc"><i>3838</i>&nbsp;     * Prints or parses an offset ID.</b>
<b class="nc"><i>3839</i>&nbsp;     */</b>
<b class="nc"><i>3840</i>&nbsp;    static final class LocalizedOffsetIdPrinterParser implements DateTimePrinterParser {</b>
<i>3841</i>&nbsp;        private final TextStyle style;
<i>3842</i>&nbsp;
<i>3843</i>&nbsp;        /**
<i>3844</i>&nbsp;         * Constructor.
<b class="nc"><i>3845</i>&nbsp;         *</b>
<b class="nc"><i>3846</i>&nbsp;         * @param style  the style, not null</b>
<b class="nc"><i>3847</i>&nbsp;         */</b>
<b class="nc"><i>3848</i>&nbsp;        LocalizedOffsetIdPrinterParser(TextStyle style) {</b>
<b class="nc"><i>3849</i>&nbsp;            this.style = style;</b>
<b class="nc"><i>3850</i>&nbsp;        }</b>
<b class="nc"><i>3851</i>&nbsp;</b>
<i>3852</i>&nbsp;        private static StringBuilder appendHMS(StringBuilder buf, int t) {
<b class="nc"><i>3853</i>&nbsp;            return buf.append((char)(t / 10 + &#39;0&#39;))</b>
<i>3854</i>&nbsp;                      .append((char)(t % 10 + &#39;0&#39;));
<b class="nc"><i>3855</i>&nbsp;        }</b>
<b class="nc"><i>3856</i>&nbsp;</b>
<i>3857</i>&nbsp;        @Override
<i>3858</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>3859</i>&nbsp;            Long offsetSecs = context.getValue(OFFSET_SECONDS);
<i>3860</i>&nbsp;            if (offsetSecs == null) {
<i>3861</i>&nbsp;                return false;
<i>3862</i>&nbsp;            }
<i>3863</i>&nbsp;            String gmtText = &quot;GMT&quot;;  // TODO: get localized version of &#39;GMT&#39;
<i>3864</i>&nbsp;            buf.append(gmtText);
<i>3865</i>&nbsp;            int totalSecs = Math.toIntExact(offsetSecs);
<i>3866</i>&nbsp;            if (totalSecs != 0) {
<i>3867</i>&nbsp;                int absHours = Math.abs((totalSecs / 3600) % 100);  // anything larger than 99 silently dropped
<i>3868</i>&nbsp;                int absMinutes = Math.abs((totalSecs / 60) % 60);
<i>3869</i>&nbsp;                int absSeconds = Math.abs(totalSecs % 60);
<i>3870</i>&nbsp;                buf.append(totalSecs &lt; 0 ? &quot;-&quot; : &quot;+&quot;);
<i>3871</i>&nbsp;                if (style == TextStyle.FULL) {
<b class="nc"><i>3872</i>&nbsp;                    appendHMS(buf, absHours);</b>
<b class="nc"><i>3873</i>&nbsp;                    buf.append(&#39;:&#39;);</b>
<b class="nc"><i>3874</i>&nbsp;                    appendHMS(buf, absMinutes);</b>
<b class="nc"><i>3875</i>&nbsp;                    if (absSeconds != 0) {</b>
<i>3876</i>&nbsp;                       buf.append(&#39;:&#39;);
<i>3877</i>&nbsp;                       appendHMS(buf, absSeconds);
<i>3878</i>&nbsp;                    }
<b class="nc"><i>3879</i>&nbsp;                } else {</b>
<b class="nc"><i>3880</i>&nbsp;                    if (absHours &gt;= 10) {</b>
<b class="nc"><i>3881</i>&nbsp;                        buf.append((char)(absHours / 10 + &#39;0&#39;));</b>
<b class="nc"><i>3882</i>&nbsp;                    }</b>
<i>3883</i>&nbsp;                    buf.append((char)(absHours % 10 + &#39;0&#39;));
<i>3884</i>&nbsp;                    if (absMinutes != 0 || absSeconds != 0) {
<b class="nc"><i>3885</i>&nbsp;                        buf.append(&#39;:&#39;);</b>
<b class="nc"><i>3886</i>&nbsp;                        appendHMS(buf, absMinutes);</b>
<i>3887</i>&nbsp;                        if (absSeconds != 0) {
<b class="nc"><i>3888</i>&nbsp;                            buf.append(&#39;:&#39;);</b>
<b class="nc"><i>3889</i>&nbsp;                            appendHMS(buf, absSeconds);</b>
<b class="nc"><i>3890</i>&nbsp;                        }</b>
<i>3891</i>&nbsp;                    }
<b class="nc"><i>3892</i>&nbsp;                }</b>
<b class="nc"><i>3893</i>&nbsp;            }</b>
<i>3894</i>&nbsp;            return true;
<b class="nc"><i>3895</i>&nbsp;        }</b>
<b class="nc"><i>3896</i>&nbsp;</b>
<b class="nc"><i>3897</i>&nbsp;        int getDigit(CharSequence text, int position) {</b>
<b class="nc"><i>3898</i>&nbsp;            char c = text.charAt(position);</b>
<b class="nc"><i>3899</i>&nbsp;            if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<b class="nc"><i>3900</i>&nbsp;                return -1;</b>
<i>3901</i>&nbsp;            }
<i>3902</i>&nbsp;            return c - &#39;0&#39;;
<i>3903</i>&nbsp;        }
<i>3904</i>&nbsp;
<i>3905</i>&nbsp;        @Override
<b class="nc"><i>3906</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {</b>
<i>3907</i>&nbsp;            int pos = position;
<i>3908</i>&nbsp;            int end = text.length();
<i>3909</i>&nbsp;            String gmtText = &quot;GMT&quot;;  // TODO: get localized version of &#39;GMT&#39;
<i>3910</i>&nbsp;            if (!context.subSequenceEquals(text, pos, gmtText, 0, gmtText.length())) {
<i>3911</i>&nbsp;                    return ~position;
<i>3912</i>&nbsp;                }
<i>3913</i>&nbsp;            pos += gmtText.length();
<b class="nc"><i>3914</i>&nbsp;            // parse normal plus/minus offset</b>
<i>3915</i>&nbsp;            int negative = 0;
<i>3916</i>&nbsp;            if (pos == end) {
<i>3917</i>&nbsp;                return context.setParsedField(OFFSET_SECONDS, 0, position, pos);
<i>3918</i>&nbsp;            }
<i>3919</i>&nbsp;            char sign = text.charAt(pos);  // IOOBE if invalid position
<i>3920</i>&nbsp;            if (sign == &#39;+&#39;) {
<i>3921</i>&nbsp;                negative = 1;
<b class="nc"><i>3922</i>&nbsp;            } else if (sign == &#39;-&#39;) {</b>
<b class="nc"><i>3923</i>&nbsp;                negative = -1;</b>
<b class="nc"><i>3924</i>&nbsp;            } else {</b>
<b class="nc"><i>3925</i>&nbsp;                return context.setParsedField(OFFSET_SECONDS, 0, position, pos);</b>
<b class="nc"><i>3926</i>&nbsp;            }</b>
<b class="nc"><i>3927</i>&nbsp;            pos++;</b>
<i>3928</i>&nbsp;            int h = 0;
<b class="nc"><i>3929</i>&nbsp;            int m = 0;</b>
<i>3930</i>&nbsp;            int s = 0;
<i>3931</i>&nbsp;            if (style == TextStyle.FULL) {
<i>3932</i>&nbsp;                int h1 = getDigit(text, pos++);
<i>3933</i>&nbsp;                int h2 = getDigit(text, pos++);
<i>3934</i>&nbsp;                if (h1 &lt; 0 || h2 &lt; 0 || text.charAt(pos++) != &#39;:&#39;) {
<i>3935</i>&nbsp;                    return ~position;
<i>3936</i>&nbsp;                }
<i>3937</i>&nbsp;                h = h1 * 10 + h2;
<i>3938</i>&nbsp;                int m1 = getDigit(text, pos++);
<i>3939</i>&nbsp;                int m2 = getDigit(text, pos++);
<i>3940</i>&nbsp;                if (m1 &lt; 0 || m2 &lt; 0) {
<i>3941</i>&nbsp;                    return ~position;
<i>3942</i>&nbsp;                }
<b class="nc"><i>3943</i>&nbsp;                m = m1 * 10 + m2;</b>
<b class="nc"><i>3944</i>&nbsp;                if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == &#39;:&#39;) {</b>
<i>3945</i>&nbsp;                    int s1 = getDigit(text, pos + 1);
<b class="nc"><i>3946</i>&nbsp;                    int s2 = getDigit(text, pos + 2);</b>
<i>3947</i>&nbsp;                    if (s1 &gt;= 0 &amp;&amp; s2 &gt;= 0) {
<i>3948</i>&nbsp;                        s = s1 * 10 + s2;
<i>3949</i>&nbsp;                        pos += 3;
<i>3950</i>&nbsp;                    }
<i>3951</i>&nbsp;                }
<i>3952</i>&nbsp;            } else {
<i>3953</i>&nbsp;                h = getDigit(text, pos++);
<i>3954</i>&nbsp;                if (h &lt; 0) {
<i>3955</i>&nbsp;                    return ~position;
<i>3956</i>&nbsp;                }
<b class="nc"><i>3957</i>&nbsp;                if (pos &lt; end) {</b>
<b class="nc"><i>3958</i>&nbsp;                    int h2 = getDigit(text, pos);</b>
<b class="nc"><i>3959</i>&nbsp;                    if (h2 &gt;=0) {</b>
<b class="nc"><i>3960</i>&nbsp;                        h = h * 10 + h2;</b>
<b class="nc"><i>3961</i>&nbsp;                        pos++;</b>
<i>3962</i>&nbsp;                    }
<i>3963</i>&nbsp;                    if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == &#39;:&#39;) {
<i>3964</i>&nbsp;                        if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == &#39;:&#39;) {
<i>3965</i>&nbsp;                            int m1 = getDigit(text, pos + 1);
<i>3966</i>&nbsp;                            int m2 = getDigit(text, pos + 2);
<i>3967</i>&nbsp;                            if (m1 &gt;= 0 &amp;&amp; m2 &gt;= 0) {
<b class="nc"><i>3968</i>&nbsp;                                m = m1 * 10 + m2;</b>
<b class="nc"><i>3969</i>&nbsp;                                pos += 3;</b>
<b class="nc"><i>3970</i>&nbsp;                                if (pos + 2 &lt; end &amp;&amp; text.charAt(pos) == &#39;:&#39;) {</b>
<i>3971</i>&nbsp;                                    int s1 = getDigit(text, pos + 1);
<b class="nc"><i>3972</i>&nbsp;                                    int s2 = getDigit(text, pos + 2);</b>
<b class="nc"><i>3973</i>&nbsp;                                    if (s1 &gt;= 0 &amp;&amp; s2 &gt;= 0) {</b>
<i>3974</i>&nbsp;                                        s = s1 * 10 + s2;
<b class="nc"><i>3975</i>&nbsp;                                        pos += 3;</b>
<i>3976</i>&nbsp;                                   }
<i>3977</i>&nbsp;                                }
<i>3978</i>&nbsp;                            }
<i>3979</i>&nbsp;                        }
<i>3980</i>&nbsp;                    }
<i>3981</i>&nbsp;                }
<i>3982</i>&nbsp;            }
<i>3983</i>&nbsp;            long offsetSecs = negative * (h * 3600L + m * 60L + s);
<i>3984</i>&nbsp;            return context.setParsedField(OFFSET_SECONDS, offsetSecs, position, pos);
<i>3985</i>&nbsp;        }
<i>3986</i>&nbsp;
<b class="nc"><i>3987</i>&nbsp;        @Override</b>
<i>3988</i>&nbsp;        public String toString() {
<i>3989</i>&nbsp;            return &quot;LocalizedOffset(&quot; + style + &quot;)&quot;;
<i>3990</i>&nbsp;        }
<b class="nc"><i>3991</i>&nbsp;    }</b>
<b class="nc"><i>3992</i>&nbsp;</b>
<b class="nc"><i>3993</i>&nbsp;    //-----------------------------------------------------------------------</b>
<b class="nc"><i>3994</i>&nbsp;    /**</b>
<b class="nc"><i>3995</i>&nbsp;     * Prints or parses a zone ID.</b>
<b class="nc"><i>3996</i>&nbsp;     */</b>
<b class="nc"><i>3997</i>&nbsp;    static final class ZoneTextPrinterParser extends ZoneIdPrinterParser {</b>
<b class="nc"><i>3998</i>&nbsp;</b>
<b class="nc"><i>3999</i>&nbsp;        /** The text style to output. */</b>
<i>4000</i>&nbsp;        private final TextStyle textStyle;
<b class="nc"><i>4001</i>&nbsp;</b>
<i>4002</i>&nbsp;        /** The preferred zoneid map */
<i>4003</i>&nbsp;        private Set&lt;String&gt; preferredZones;
<b class="nc"><i>4004</i>&nbsp;</b>
<b class="nc"><i>4005</i>&nbsp;        /**  Display in generic time-zone format. True in case of pattern letter &#39;v&#39; */</b>
<b class="nc"><i>4006</i>&nbsp;        private final boolean isGeneric;</b>
<b class="nc"><i>4007</i>&nbsp;        ZoneTextPrinterParser(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones, boolean isGeneric) {</b>
<i>4008</i>&nbsp;            super(TemporalQueries.zone(), &quot;ZoneText(&quot; + textStyle + &quot;)&quot;);
<i>4009</i>&nbsp;            this.textStyle = Objects.requireNonNull(textStyle, &quot;textStyle&quot;);
<i>4010</i>&nbsp;            this.isGeneric = isGeneric;
<i>4011</i>&nbsp;            if (preferredZones != null &amp;&amp; preferredZones.size() != 0) {
<i>4012</i>&nbsp;                this.preferredZones = new HashSet&lt;&gt;();
<b class="nc"><i>4013</i>&nbsp;                for (ZoneId id : preferredZones) {</b>
<b class="nc"><i>4014</i>&nbsp;                    this.preferredZones.add(id.getId());</b>
<i>4015</i>&nbsp;                }
<i>4016</i>&nbsp;            }
<b class="nc"><i>4017</i>&nbsp;        }</b>
<b class="nc"><i>4018</i>&nbsp;</b>
<b class="nc"><i>4019</i>&nbsp;        private static final int STD = 0;</b>
<b class="nc"><i>4020</i>&nbsp;        private static final int DST = 1;</b>
<b class="nc"><i>4021</i>&nbsp;        private static final int GENERIC = 2;</b>
<b class="nc"><i>4022</i>&nbsp;        private static final Map&lt;String, SoftReference&lt;Map&lt;Locale, String[]&gt;&gt;&gt; cache =</b>
<b class="nc"><i>4023</i>&nbsp;            new ConcurrentHashMap&lt;&gt;();</b>
<b class="nc"><i>4024</i>&nbsp;</b>
<b class="nc"><i>4025</i>&nbsp;        private String getDisplayName(String id, int type, Locale locale) {</b>
<i>4026</i>&nbsp;            if (textStyle == TextStyle.NARROW) {
<b class="nc"><i>4027</i>&nbsp;                return null;</b>
<i>4028</i>&nbsp;            }
<i>4029</i>&nbsp;            String[] names;
<i>4030</i>&nbsp;            SoftReference&lt;Map&lt;Locale, String[]&gt;&gt; ref = cache.get(id);
<i>4031</i>&nbsp;            Map&lt;Locale, String[]&gt; perLocale = null;
<i>4032</i>&nbsp;            if (ref == null || (perLocale = ref.get()) == null ||
<i>4033</i>&nbsp;                (names = perLocale.get(locale)) == null) {
<i>4034</i>&nbsp;                names = TimeZoneNameUtility.retrieveDisplayNames(id, locale);
<i>4035</i>&nbsp;                if (names == null) {
<i>4036</i>&nbsp;                    return null;
<i>4037</i>&nbsp;                }
<i>4038</i>&nbsp;                names = Arrays.copyOfRange(names, 0, 7);
<b class="nc"><i>4039</i>&nbsp;                names[5] =</b>
<b class="nc"><i>4040</i>&nbsp;                    TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.LONG, locale);</b>
<i>4041</i>&nbsp;                if (names[5] == null) {
<b class="nc"><i>4042</i>&nbsp;                    names[5] = names[0]; // use the id</b>
<b class="nc"><i>4043</i>&nbsp;                }</b>
<i>4044</i>&nbsp;                names[6] =
<b class="nc"><i>4045</i>&nbsp;                    TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.SHORT, locale);</b>
<b class="nc"><i>4046</i>&nbsp;                if (names[6] == null) {</b>
<b class="nc"><i>4047</i>&nbsp;                    names[6] = names[0];</b>
<b class="nc"><i>4048</i>&nbsp;                }</b>
<i>4049</i>&nbsp;                if (perLocale == null) {
<b class="nc"><i>4050</i>&nbsp;                    perLocale = new ConcurrentHashMap&lt;&gt;();</b>
<i>4051</i>&nbsp;                }
<b class="nc"><i>4052</i>&nbsp;                perLocale.put(locale, names);</b>
<b class="nc"><i>4053</i>&nbsp;                cache.put(id, new SoftReference&lt;&gt;(perLocale));</b>
<i>4054</i>&nbsp;            }
<b class="nc"><i>4055</i>&nbsp;            switch (type) {</b>
<i>4056</i>&nbsp;            case STD:
<i>4057</i>&nbsp;                return names[textStyle.zoneNameStyleIndex() + 1];
<i>4058</i>&nbsp;            case DST:
<i>4059</i>&nbsp;                return names[textStyle.zoneNameStyleIndex() + 3];
<i>4060</i>&nbsp;            }
<i>4061</i>&nbsp;            return names[textStyle.zoneNameStyleIndex() + 5];
<i>4062</i>&nbsp;        }
<i>4063</i>&nbsp;
<i>4064</i>&nbsp;        @Override
<i>4065</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>4066</i>&nbsp;            ZoneId zone = context.getValue(TemporalQueries.zoneId());
<i>4067</i>&nbsp;            if (zone == null) {
<b class="nc"><i>4068</i>&nbsp;                return false;</b>
<b class="nc"><i>4069</i>&nbsp;            }</b>
<b class="nc"><i>4070</i>&nbsp;            String zname = zone.getId();</b>
<b class="nc"><i>4071</i>&nbsp;            if (!(zone instanceof ZoneOffset)) {</b>
<i>4072</i>&nbsp;                TemporalAccessor dt = context.getTemporal();
<b class="nc"><i>4073</i>&nbsp;                int type = GENERIC;</b>
<b class="nc"><i>4074</i>&nbsp;                if (!isGeneric) {</b>
<b class="nc"><i>4075</i>&nbsp;                    if (dt.isSupported(ChronoField.INSTANT_SECONDS)) {</b>
<i>4076</i>&nbsp;                        type = zone.getRules().isDaylightSavings(Instant.from(dt)) ? DST : STD;
<b class="nc"><i>4077</i>&nbsp;                    } else if (dt.isSupported(ChronoField.EPOCH_DAY) &amp;&amp;</b>
<b class="nc"><i>4078</i>&nbsp;                               dt.isSupported(ChronoField.NANO_OF_DAY)) {</b>
<b class="nc"><i>4079</i>&nbsp;                        LocalDate date = LocalDate.ofEpochDay(dt.getLong(ChronoField.EPOCH_DAY));</b>
<b class="nc"><i>4080</i>&nbsp;                        LocalTime time = LocalTime.ofNanoOfDay(dt.getLong(ChronoField.NANO_OF_DAY));</b>
<b class="nc"><i>4081</i>&nbsp;                        LocalDateTime ldt = date.atTime(time);</b>
<i>4082</i>&nbsp;                        if (zone.getRules().getTransition(ldt) == null) {
<i>4083</i>&nbsp;                            type = zone.getRules().isDaylightSavings(ldt.atZone(zone).toInstant()) ? DST : STD;
<i>4084</i>&nbsp;                        }
<b class="nc"><i>4085</i>&nbsp;                    }</b>
<b class="nc"><i>4086</i>&nbsp;                }</b>
<i>4087</i>&nbsp;                String name = getDisplayName(zname, type, context.getLocale());
<b class="nc"><i>4088</i>&nbsp;                if (name != null) {</b>
<b class="nc"><i>4089</i>&nbsp;                    zname = name;</b>
<i>4090</i>&nbsp;                }
<i>4091</i>&nbsp;            }
<i>4092</i>&nbsp;            buf.append(zname);
<b class="nc"><i>4093</i>&nbsp;            return true;</b>
<i>4094</i>&nbsp;        }
<i>4095</i>&nbsp;
<i>4096</i>&nbsp;        // cache per instance for now
<b class="nc"><i>4097</i>&nbsp;        private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;</b>
<i>4098</i>&nbsp;            cachedTree = new HashMap&lt;&gt;();
<i>4099</i>&nbsp;        private final Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt;
<i>4100</i>&nbsp;            cachedTreeCI = new HashMap&lt;&gt;();
<b class="nc"><i>4101</i>&nbsp;</b>
<i>4102</i>&nbsp;        @Override
<i>4103</i>&nbsp;        protected PrefixTree getTree(DateTimeParseContext context) {
<i>4104</i>&nbsp;            if (textStyle == TextStyle.NARROW) {
<b class="nc"><i>4105</i>&nbsp;                return super.getTree(context);</b>
<b class="nc"><i>4106</i>&nbsp;            }</b>
<i>4107</i>&nbsp;            Locale locale = context.getLocale();
<b class="nc"><i>4108</i>&nbsp;            boolean isCaseSensitive = context.isCaseSensitive();</b>
<b class="nc"><i>4109</i>&nbsp;            Set&lt;String&gt; regionIds = ZoneRulesProvider.getAvailableZoneIds();</b>
<b class="nc"><i>4110</i>&nbsp;            int regionIdsSize = regionIds.size();</b>
<i>4111</i>&nbsp;
<b class="nc"><i>4112</i>&nbsp;            Map&lt;Locale, Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt;&gt; cached =</b>
<b class="nc"><i>4113</i>&nbsp;                isCaseSensitive ? cachedTree : cachedTreeCI;</b>
<b class="nc"><i>4114</i>&nbsp;</b>
<b class="nc"><i>4115</i>&nbsp;            Entry&lt;Integer, SoftReference&lt;PrefixTree&gt;&gt; entry = null;</b>
<i>4116</i>&nbsp;            PrefixTree tree = null;
<i>4117</i>&nbsp;            String[][] zoneStrings = null;
<b class="nc"><i>4118</i>&nbsp;            if ((entry = cached.get(locale)) == null ||</b>
<i>4119</i>&nbsp;                (entry.getKey() != regionIdsSize ||
<i>4120</i>&nbsp;                (tree = entry.getValue().get()) == null)) {
<i>4121</i>&nbsp;                tree = PrefixTree.newTree(context);
<b class="nc"><i>4122</i>&nbsp;                zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);</b>
<b class="nc"><i>4123</i>&nbsp;                for (String[] names : zoneStrings) {</b>
<b class="nc"><i>4124</i>&nbsp;                    String zid = names[0];</b>
<b class="nc"><i>4125</i>&nbsp;                    if (!regionIds.contains(zid)) {</b>
<i>4126</i>&nbsp;                        continue;
<b class="nc"><i>4127</i>&nbsp;                    }</b>
<i>4128</i>&nbsp;                    tree.add(zid, zid);    // don&#39;t convert zid -&gt; metazone
<b class="nc"><i>4129</i>&nbsp;                    zid = ZoneName.toZid(zid, locale);</b>
<i>4130</i>&nbsp;                    int i = textStyle == TextStyle.FULL ? 1 : 2;
<i>4131</i>&nbsp;                    for (; i &lt; names.length; i += 2) {
<i>4132</i>&nbsp;                        tree.add(names[i], zid);
<i>4133</i>&nbsp;                    }
<i>4134</i>&nbsp;                }
<b class="nc"><i>4135</i>&nbsp;                // if we have a set of preferred zones, need a copy and</b>
<i>4136</i>&nbsp;                // add the preferred zones again to overwrite
<i>4137</i>&nbsp;                if (preferredZones != null) {
<b class="nc"><i>4138</i>&nbsp;                    for (String[] names : zoneStrings) {</b>
<i>4139</i>&nbsp;                        String zid = names[0];
<i>4140</i>&nbsp;                        if (!preferredZones.contains(zid) || !regionIds.contains(zid)) {
<i>4141</i>&nbsp;                            continue;
<i>4142</i>&nbsp;                        }
<b class="nc"><i>4143</i>&nbsp;                        int i = textStyle == TextStyle.FULL ? 1 : 2;</b>
<i>4144</i>&nbsp;                        for (; i &lt; names.length; i += 2) {
<i>4145</i>&nbsp;                            tree.add(names[i], zid);
<i>4146</i>&nbsp;                       }
<i>4147</i>&nbsp;                    }
<b class="nc"><i>4148</i>&nbsp;                }</b>
<i>4149</i>&nbsp;                cached.put(locale, new SimpleImmutableEntry&lt;&gt;(regionIdsSize, new SoftReference&lt;&gt;(tree)));
<i>4150</i>&nbsp;            }
<i>4151</i>&nbsp;            return tree;
<i>4152</i>&nbsp;        }
<b class="nc"><i>4153</i>&nbsp;    }</b>
<b class="nc"><i>4154</i>&nbsp;</b>
<b class="nc"><i>4155</i>&nbsp;    //-----------------------------------------------------------------------</b>
<i>4156</i>&nbsp;    /**
<b class="nc"><i>4157</i>&nbsp;     * Prints or parses a zone ID.</b>
<b class="nc"><i>4158</i>&nbsp;     */</b>
<b class="nc"><i>4159</i>&nbsp;    static class ZoneIdPrinterParser implements DateTimePrinterParser {</b>
<b class="nc"><i>4160</i>&nbsp;        private final TemporalQuery&lt;ZoneId&gt; query;</b>
<i>4161</i>&nbsp;        private final String description;
<i>4162</i>&nbsp;
<b class="nc"><i>4163</i>&nbsp;        ZoneIdPrinterParser(TemporalQuery&lt;ZoneId&gt; query, String description) {</b>
<i>4164</i>&nbsp;            this.query = query;
<i>4165</i>&nbsp;            this.description = description;
<i>4166</i>&nbsp;        }
<i>4167</i>&nbsp;
<i>4168</i>&nbsp;        @Override
<i>4169</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>4170</i>&nbsp;            ZoneId zone = context.getValue(query);
<i>4171</i>&nbsp;            if (zone == null) {
<i>4172</i>&nbsp;                return false;
<i>4173</i>&nbsp;            }
<b class="nc"><i>4174</i>&nbsp;            buf.append(zone.getId());</b>
<i>4175</i>&nbsp;            return true;
<i>4176</i>&nbsp;        }
<i>4177</i>&nbsp;
<i>4178</i>&nbsp;        /**
<b class="nc"><i>4179</i>&nbsp;         * The cached tree to speed up parsing.</b>
<i>4180</i>&nbsp;         */
<i>4181</i>&nbsp;        private static volatile Entry&lt;Integer, PrefixTree&gt; cachedPrefixTree;
<i>4182</i>&nbsp;        private static volatile Entry&lt;Integer, PrefixTree&gt; cachedPrefixTreeCI;
<b class="nc"><i>4183</i>&nbsp;</b>
<i>4184</i>&nbsp;        protected PrefixTree getTree(DateTimeParseContext context) {
<i>4185</i>&nbsp;            // prepare parse tree
<i>4186</i>&nbsp;            Set&lt;String&gt; regionIds = ZoneRulesProvider.getAvailableZoneIds();
<b class="nc"><i>4187</i>&nbsp;            final int regionIdsSize = regionIds.size();</b>
<b class="nc"><i>4188</i>&nbsp;            Entry&lt;Integer, PrefixTree&gt; cached = context.isCaseSensitive()</b>
<b class="nc"><i>4189</i>&nbsp;                                                ? cachedPrefixTree : cachedPrefixTreeCI;</b>
<b class="nc"><i>4190</i>&nbsp;            if (cached == null || cached.getKey() != regionIdsSize) {</b>
<b class="nc"><i>4191</i>&nbsp;                synchronized (this) {</b>
<b class="nc"><i>4192</i>&nbsp;                    cached = context.isCaseSensitive() ? cachedPrefixTree : cachedPrefixTreeCI;</b>
<b class="nc"><i>4193</i>&nbsp;                    if (cached == null || cached.getKey() != regionIdsSize) {</b>
<b class="nc"><i>4194</i>&nbsp;                        cached = new SimpleImmutableEntry&lt;&gt;(regionIdsSize, PrefixTree.newTree(regionIds, context));</b>
<i>4195</i>&nbsp;                        if (context.isCaseSensitive()) {
<b class="nc"><i>4196</i>&nbsp;                            cachedPrefixTree = cached;</b>
<i>4197</i>&nbsp;                        } else {
<b class="nc"><i>4198</i>&nbsp;                            cachedPrefixTreeCI = cached;</b>
<i>4199</i>&nbsp;                        }
<i>4200</i>&nbsp;                    }
<b class="nc"><i>4201</i>&nbsp;                }</b>
<i>4202</i>&nbsp;            }
<i>4203</i>&nbsp;            return cached.getValue();
<i>4204</i>&nbsp;        }
<i>4205</i>&nbsp;
<b class="nc"><i>4206</i>&nbsp;        /**</b>
<b class="nc"><i>4207</i>&nbsp;         * This implementation looks for the longest matching string.</b>
<b class="nc"><i>4208</i>&nbsp;         * For example, parsing Etc/GMT-2 will return Etc/GMC-2 rather than just</b>
<b class="nc"><i>4209</i>&nbsp;         * Etc/GMC although both are valid.</b>
<b class="nc"><i>4210</i>&nbsp;         */</b>
<b class="nc"><i>4211</i>&nbsp;        @Override</b>
<b class="nc"><i>4212</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {</b>
<b class="nc"><i>4213</i>&nbsp;            int length = text.length();</b>
<i>4214</i>&nbsp;            if (position &gt; length) {
<b class="nc"><i>4215</i>&nbsp;                throw new IndexOutOfBoundsException();</b>
<b class="nc"><i>4216</i>&nbsp;            }</b>
<i>4217</i>&nbsp;            if (position == length) {
<i>4218</i>&nbsp;                return ~position;
<b class="nc"><i>4219</i>&nbsp;            }</b>
<b class="nc"><i>4220</i>&nbsp;</b>
<i>4221</i>&nbsp;            // handle fixed time-zone IDs
<b class="nc"><i>4222</i>&nbsp;            char nextChar = text.charAt(position);</b>
<b class="nc"><i>4223</i>&nbsp;            if (nextChar == &#39;+&#39; || nextChar == &#39;-&#39;) {</b>
<b class="nc"><i>4224</i>&nbsp;                return parseOffsetBased(context, text, position, position, OffsetIdPrinterParser.INSTANCE_ID_Z);</b>
<b class="nc"><i>4225</i>&nbsp;            } else if (length &gt;= position + 2) {</b>
<i>4226</i>&nbsp;                char nextNextChar = text.charAt(position + 1);
<b class="nc"><i>4227</i>&nbsp;                if (context.charEquals(nextChar, &#39;U&#39;) &amp;&amp; context.charEquals(nextNextChar, &#39;T&#39;)) {</b>
<b class="nc"><i>4228</i>&nbsp;                    if (length &gt;= position + 3 &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;C&#39;)) {</b>
<i>4229</i>&nbsp;                        return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);
<b class="nc"><i>4230</i>&nbsp;                    }</b>
<b class="nc"><i>4231</i>&nbsp;                    return parseOffsetBased(context, text, position, position + 2, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</b>
<b class="nc"><i>4232</i>&nbsp;                } else if (context.charEquals(nextChar, &#39;G&#39;) &amp;&amp; length &gt;= position + 3 &amp;&amp;</b>
<b class="nc"><i>4233</i>&nbsp;                        context.charEquals(nextNextChar, &#39;M&#39;) &amp;&amp; context.charEquals(text.charAt(position + 2), &#39;T&#39;)) {</b>
<b class="nc"><i>4234</i>&nbsp;                    if (length &gt;= position + 4 &amp;&amp; context.charEquals(text.charAt(position + 3), &#39;0&#39;)) {</b>
<i>4235</i>&nbsp;                        context.setParsed(ZoneId.of(&quot;GMT0&quot;));
<i>4236</i>&nbsp;                        return position + 4;
<i>4237</i>&nbsp;                    }
<b class="nc"><i>4238</i>&nbsp;                    return parseOffsetBased(context, text, position, position + 3, OffsetIdPrinterParser.INSTANCE_ID_ZERO);</b>
<b class="nc"><i>4239</i>&nbsp;                }</b>
<i>4240</i>&nbsp;            }
<i>4241</i>&nbsp;
<b class="nc"><i>4242</i>&nbsp;            // parse</b>
<b class="nc"><i>4243</i>&nbsp;            PrefixTree tree = getTree(context);</b>
<i>4244</i>&nbsp;            ParsePosition ppos = new ParsePosition(position);
<i>4245</i>&nbsp;            String parsedZoneId = tree.match(text, ppos);
<i>4246</i>&nbsp;            if (parsedZoneId == null) {
<i>4247</i>&nbsp;                if (context.charEquals(nextChar, &#39;Z&#39;)) {
<i>4248</i>&nbsp;                    context.setParsed(ZoneOffset.UTC);
<i>4249</i>&nbsp;                    return position + 1;
<i>4250</i>&nbsp;                }
<i>4251</i>&nbsp;                return ~position;
<i>4252</i>&nbsp;            }
<i>4253</i>&nbsp;            context.setParsed(ZoneId.of(parsedZoneId));
<i>4254</i>&nbsp;            return ppos.getIndex();
<i>4255</i>&nbsp;        }
<b class="nc"><i>4256</i>&nbsp;</b>
<i>4257</i>&nbsp;        /**
<b class="nc"><i>4258</i>&nbsp;         * Parse an offset following a prefix and set the ZoneId if it is valid.</b>
<i>4259</i>&nbsp;         * To matching the parsing of ZoneId.of the values are not normalized
<i>4260</i>&nbsp;         * to ZoneOffsets.
<i>4261</i>&nbsp;         *
<i>4262</i>&nbsp;         * @param context the parse context
<b class="nc"><i>4263</i>&nbsp;         * @param text the input text</b>
<b class="nc"><i>4264</i>&nbsp;         * @param prefixPos start of the prefix</b>
<b class="nc"><i>4265</i>&nbsp;         * @param position start of text after the prefix</b>
<i>4266</i>&nbsp;         * @param parser parser for the value after the prefix
<b class="nc"><i>4267</i>&nbsp;         * @return the position after the parse</b>
<b class="nc"><i>4268</i>&nbsp;         */</b>
<i>4269</i>&nbsp;        private int parseOffsetBased(DateTimeParseContext context, CharSequence text, int prefixPos, int position, OffsetIdPrinterParser parser) {
<b class="nc"><i>4270</i>&nbsp;            String prefix = text.subSequence(prefixPos, position).toString().toUpperCase();</b>
<i>4271</i>&nbsp;            if (position &gt;= text.length()) {
<b class="nc"><i>4272</i>&nbsp;                context.setParsed(ZoneId.of(prefix));</b>
<i>4273</i>&nbsp;                return position;
<i>4274</i>&nbsp;            }
<i>4275</i>&nbsp;
<i>4276</i>&nbsp;            // &#39;0&#39; or &#39;Z&#39; after prefix is not part of a valid ZoneId; use bare prefix
<i>4277</i>&nbsp;            if (text.charAt(position) == &#39;0&#39; ||
<b class="nc"><i>4278</i>&nbsp;                context.charEquals(text.charAt(position), &#39;Z&#39;)) {</b>
<b class="nc"><i>4279</i>&nbsp;                context.setParsed(ZoneId.of(prefix));</b>
<i>4280</i>&nbsp;                return position;
<b class="nc"><i>4281</i>&nbsp;            }</b>
<b class="nc"><i>4282</i>&nbsp;</b>
<b class="nc"><i>4283</i>&nbsp;            DateTimeParseContext newContext = context.copy();</b>
<b class="nc"><i>4284</i>&nbsp;            int endPos = parser.parse(newContext, text, position);</b>
<i>4285</i>&nbsp;            try {
<b class="nc"><i>4286</i>&nbsp;                if (endPos &lt; 0) {</b>
<b class="nc"><i>4287</i>&nbsp;                    if (parser == OffsetIdPrinterParser.INSTANCE_ID_Z) {</b>
<i>4288</i>&nbsp;                        return ~prefixPos;
<b class="nc"><i>4289</i>&nbsp;                    }</b>
<i>4290</i>&nbsp;                    context.setParsed(ZoneId.of(prefix));
<b class="nc"><i>4291</i>&nbsp;                    return position;</b>
<b class="nc"><i>4292</i>&nbsp;                }</b>
<b class="nc"><i>4293</i>&nbsp;                int offset = (int) newContext.getParsed(OFFSET_SECONDS).longValue();</b>
<b class="nc"><i>4294</i>&nbsp;                ZoneOffset zoneOffset = ZoneOffset.ofTotalSeconds(offset);</b>
<i>4295</i>&nbsp;                context.setParsed(ZoneId.ofOffset(prefix, zoneOffset));
<b class="nc"><i>4296</i>&nbsp;                return endPos;</b>
<b class="nc"><i>4297</i>&nbsp;            } catch (DateTimeException dte) {</b>
<b class="nc"><i>4298</i>&nbsp;                return ~prefixPos;</b>
<i>4299</i>&nbsp;            }
<b class="nc"><i>4300</i>&nbsp;        }</b>
<b class="nc"><i>4301</i>&nbsp;</b>
<i>4302</i>&nbsp;        @Override
<i>4303</i>&nbsp;        public String toString() {
<i>4304</i>&nbsp;            return description;
<i>4305</i>&nbsp;        }
<i>4306</i>&nbsp;    }
<i>4307</i>&nbsp;
<i>4308</i>&nbsp;    //-----------------------------------------------------------------------
<i>4309</i>&nbsp;    /**
<i>4310</i>&nbsp;     * A String based prefix tree for parsing time-zone names.
<i>4311</i>&nbsp;     */
<i>4312</i>&nbsp;    static class PrefixTree {
<i>4313</i>&nbsp;        protected String key;
<i>4314</i>&nbsp;        protected String value;
<b class="nc"><i>4315</i>&nbsp;        protected char c0;    // performance optimization to avoid the</b>
<b class="nc"><i>4316</i>&nbsp;                              // boundary check cost of key.charat(0)</b>
<b class="nc"><i>4317</i>&nbsp;        protected PrefixTree child;</b>
<i>4318</i>&nbsp;        protected PrefixTree sibling;
<i>4319</i>&nbsp;
<i>4320</i>&nbsp;        private PrefixTree(String k, String v, PrefixTree child) {
<i>4321</i>&nbsp;            this.key = k;
<i>4322</i>&nbsp;            this.value = v;
<i>4323</i>&nbsp;            this.child = child;
<i>4324</i>&nbsp;            if (k.length() == 0){
<i>4325</i>&nbsp;                c0 = 0xffff;
<i>4326</i>&nbsp;            } else {
<b class="nc"><i>4327</i>&nbsp;                c0 = key.charAt(0);</b>
<i>4328</i>&nbsp;            }
<i>4329</i>&nbsp;        }
<i>4330</i>&nbsp;
<i>4331</i>&nbsp;        /**
<i>4332</i>&nbsp;         * Creates a new prefix parsing tree based on parse context.
<i>4333</i>&nbsp;         *
<i>4334</i>&nbsp;         * @param context  the parse context
<i>4335</i>&nbsp;         * @return the tree, not null
<i>4336</i>&nbsp;         */
<i>4337</i>&nbsp;        public static PrefixTree newTree(DateTimeParseContext context) {
<b class="nc"><i>4338</i>&nbsp;            //if (!context.isStrict()) {</b>
<i>4339</i>&nbsp;            //    return new LENIENT(&quot;&quot;, null, null);
<b class="nc"><i>4340</i>&nbsp;            //}</b>
<b class="nc"><i>4341</i>&nbsp;            if (context.isCaseSensitive()) {</b>
<i>4342</i>&nbsp;                return new PrefixTree(&quot;&quot;, null, null);
<i>4343</i>&nbsp;            }
<i>4344</i>&nbsp;            return new CI(&quot;&quot;, null, null);
<i>4345</i>&nbsp;        }
<b class="nc"><i>4346</i>&nbsp;</b>
<b class="nc"><i>4347</i>&nbsp;        /**</b>
<i>4348</i>&nbsp;         * Creates a new prefix parsing tree.
<i>4349</i>&nbsp;         *
<i>4350</i>&nbsp;         * @param keys  a set of strings to build the prefix parsing tree, not null
<i>4351</i>&nbsp;         * @param context  the parse context
<b class="nc"><i>4352</i>&nbsp;         * @return the tree, not null</b>
<b class="nc"><i>4353</i>&nbsp;         */</b>
<i>4354</i>&nbsp;        public static  PrefixTree newTree(Set&lt;String&gt; keys, DateTimeParseContext context) {
<i>4355</i>&nbsp;            PrefixTree tree = newTree(context);
<i>4356</i>&nbsp;            for (String k : keys) {
<i>4357</i>&nbsp;                tree.add0(k, k);
<i>4358</i>&nbsp;            }
<i>4359</i>&nbsp;            return tree;
<i>4360</i>&nbsp;        }
<i>4361</i>&nbsp;
<i>4362</i>&nbsp;        /**
<i>4363</i>&nbsp;         * Clone a copy of this tree
<i>4364</i>&nbsp;         */
<i>4365</i>&nbsp;        public PrefixTree copyTree() {
<i>4366</i>&nbsp;            PrefixTree copy = new PrefixTree(key, value, null);
<i>4367</i>&nbsp;            if (child != null) {
<b class="nc"><i>4368</i>&nbsp;                copy.child = child.copyTree();</b>
<b class="nc"><i>4369</i>&nbsp;            }</b>
<b class="nc"><i>4370</i>&nbsp;            if (sibling != null) {</b>
<b class="nc"><i>4371</i>&nbsp;                copy.sibling = sibling.copyTree();</b>
<b class="nc"><i>4372</i>&nbsp;            }</b>
<b class="nc"><i>4373</i>&nbsp;            return copy;</b>
<b class="nc"><i>4374</i>&nbsp;        }</b>
<b class="nc"><i>4375</i>&nbsp;</b>
<i>4376</i>&nbsp;
<i>4377</i>&nbsp;        /**
<b class="nc"><i>4378</i>&nbsp;         * Adds a pair of {key, value} into the prefix tree.</b>
<i>4379</i>&nbsp;         *
<i>4380</i>&nbsp;         * @param k  the key, not null
<i>4381</i>&nbsp;         * @param v  the value, not null
<i>4382</i>&nbsp;         * @return  true if the pair is added successfully
<b class="nc"><i>4383</i>&nbsp;         */</b>
<i>4384</i>&nbsp;        public boolean add(String k, String v) {
<i>4385</i>&nbsp;            return add0(k, v);
<i>4386</i>&nbsp;        }
<i>4387</i>&nbsp;
<i>4388</i>&nbsp;        private boolean add0(String k, String v) {
<i>4389</i>&nbsp;            k = toKey(k);
<i>4390</i>&nbsp;            int prefixLen = prefixLength(k);
<i>4391</i>&nbsp;            if (prefixLen == key.length()) {
<i>4392</i>&nbsp;                if (prefixLen &lt; k.length()) {  // down the tree
<i>4393</i>&nbsp;                    String subKey = k.substring(prefixLen);
<i>4394</i>&nbsp;                    PrefixTree c = child;
<i>4395</i>&nbsp;                    while (c != null) {
<i>4396</i>&nbsp;                        if (isEqual(c.c0, subKey.charAt(0))) {
<i>4397</i>&nbsp;                            return c.add0(subKey, v);
<i>4398</i>&nbsp;                        }
<i>4399</i>&nbsp;                        c = c.sibling;
<i>4400</i>&nbsp;                    }
<i>4401</i>&nbsp;                    // add the node as the child of the current node
<i>4402</i>&nbsp;                    c = newNode(subKey, v, null);
<i>4403</i>&nbsp;                    c.sibling = child;
<i>4404</i>&nbsp;                    child = c;
<i>4405</i>&nbsp;                    return true;
<b class="nc"><i>4406</i>&nbsp;                }</b>
<b class="nc"><i>4407</i>&nbsp;                // have an existing &lt;key, value&gt; already, overwrite it</b>
<b class="nc"><i>4408</i>&nbsp;                // if (value != null) {</b>
<i>4409</i>&nbsp;                //    return false;
<i>4410</i>&nbsp;                //}
<i>4411</i>&nbsp;                value = v;
<i>4412</i>&nbsp;                return true;
<b class="nc"><i>4413</i>&nbsp;            }</b>
<i>4414</i>&nbsp;            // split the existing node
<i>4415</i>&nbsp;            PrefixTree n1 = newNode(key.substring(prefixLen), value, child);
<i>4416</i>&nbsp;            key = k.substring(0, prefixLen);
<i>4417</i>&nbsp;            child = n1;
<b class="nc"><i>4418</i>&nbsp;            if (prefixLen &lt; k.length()) {</b>
<i>4419</i>&nbsp;                PrefixTree n2 = newNode(k.substring(prefixLen), v, null);
<i>4420</i>&nbsp;                child.sibling = n2;
<i>4421</i>&nbsp;                value = null;
<i>4422</i>&nbsp;            } else {
<i>4423</i>&nbsp;                value = v;
<i>4424</i>&nbsp;            }
<i>4425</i>&nbsp;            return true;
<i>4426</i>&nbsp;        }
<i>4427</i>&nbsp;
<i>4428</i>&nbsp;        /**
<b class="nc"><i>4429</i>&nbsp;         * Match text with the prefix tree.</b>
<b class="nc"><i>4430</i>&nbsp;         *</b>
<b class="nc"><i>4431</i>&nbsp;         * @param text  the input text to parse, not null</b>
<i>4432</i>&nbsp;         * @param off  the offset position to start parsing at
<b class="nc"><i>4433</i>&nbsp;         * @param end  the end position to stop parsing</b>
<b class="nc"><i>4434</i>&nbsp;         * @return the resulting string, or null if no match found.</b>
<b class="nc"><i>4435</i>&nbsp;         */</b>
<i>4436</i>&nbsp;        public String match(CharSequence text, int off, int end) {
<b class="nc"><i>4437</i>&nbsp;            if (!prefixOf(text, off, end)){</b>
<i>4438</i>&nbsp;                return null;
<i>4439</i>&nbsp;            }
<i>4440</i>&nbsp;            if (child != null &amp;&amp; (off += key.length()) != end) {
<i>4441</i>&nbsp;                PrefixTree c = child;
<b class="nc"><i>4442</i>&nbsp;                do {</b>
<b class="nc"><i>4443</i>&nbsp;                    if (isEqual(c.c0, text.charAt(off))) {</b>
<i>4444</i>&nbsp;                        String found = c.match(text, off, end);
<b class="nc"><i>4445</i>&nbsp;                        if (found != null) {</b>
<b class="nc"><i>4446</i>&nbsp;                            return found;</b>
<i>4447</i>&nbsp;                        }
<b class="nc"><i>4448</i>&nbsp;                        return value;</b>
<b class="nc"><i>4449</i>&nbsp;                    }</b>
<i>4450</i>&nbsp;                    c = c.sibling;
<b class="nc"><i>4451</i>&nbsp;                } while (c != null);</b>
<i>4452</i>&nbsp;            }
<b class="nc"><i>4453</i>&nbsp;            return value;</b>
<i>4454</i>&nbsp;        }
<i>4455</i>&nbsp;
<i>4456</i>&nbsp;        /**
<i>4457</i>&nbsp;         * Match text with the prefix tree.
<b class="nc"><i>4458</i>&nbsp;         *</b>
<b class="nc"><i>4459</i>&nbsp;         * @param text  the input text to parse, not null</b>
<b class="nc"><i>4460</i>&nbsp;         * @param pos  the position to start parsing at, from 0 to the text</b>
<b class="nc"><i>4461</i>&nbsp;         *  length. Upon return, position will be updated to the new parse</b>
<b class="nc"><i>4462</i>&nbsp;         *  position, or unchanged, if no match found.</b>
<b class="nc"><i>4463</i>&nbsp;         * @return the resulting string, or null if no match found.</b>
<b class="nc"><i>4464</i>&nbsp;         */</b>
<i>4465</i>&nbsp;        public String match(CharSequence text, ParsePosition pos) {
<b class="nc"><i>4466</i>&nbsp;            int off = pos.getIndex();</b>
<b class="nc"><i>4467</i>&nbsp;            int end = text.length();</b>
<b class="nc"><i>4468</i>&nbsp;            if (!prefixOf(text, off, end)){</b>
<i>4469</i>&nbsp;                return null;
<i>4470</i>&nbsp;            }
<b class="nc"><i>4471</i>&nbsp;            off += key.length();</b>
<i>4472</i>&nbsp;            if (child != null &amp;&amp; off != end) {
<i>4473</i>&nbsp;                PrefixTree c = child;
<b class="nc"><i>4474</i>&nbsp;                do {</b>
<b class="nc"><i>4475</i>&nbsp;                    if (isEqual(c.c0, text.charAt(off))) {</b>
<i>4476</i>&nbsp;                        pos.setIndex(off);
<b class="nc"><i>4477</i>&nbsp;                        String found = c.match(text, pos);</b>
<b class="nc"><i>4478</i>&nbsp;                        if (found != null) {</b>
<i>4479</i>&nbsp;                            return found;
<b class="nc"><i>4480</i>&nbsp;                        }</b>
<b class="nc"><i>4481</i>&nbsp;                        break;</b>
<i>4482</i>&nbsp;                    }
<i>4483</i>&nbsp;                    c = c.sibling;
<i>4484</i>&nbsp;                } while (c != null);
<b class="nc"><i>4485</i>&nbsp;            }</b>
<b class="nc"><i>4486</i>&nbsp;            pos.setIndex(off);</b>
<i>4487</i>&nbsp;            return value;
<b class="nc"><i>4488</i>&nbsp;        }</b>
<b class="nc"><i>4489</i>&nbsp;</b>
<i>4490</i>&nbsp;        protected String toKey(String k) {
<i>4491</i>&nbsp;            return k;
<i>4492</i>&nbsp;        }
<i>4493</i>&nbsp;
<i>4494</i>&nbsp;        protected PrefixTree newNode(String k, String v, PrefixTree child) {
<i>4495</i>&nbsp;            return new PrefixTree(k, v, child);
<i>4496</i>&nbsp;        }
<b class="nc"><i>4497</i>&nbsp;</b>
<i>4498</i>&nbsp;        protected boolean isEqual(char c1, char c2) {
<i>4499</i>&nbsp;            return c1 == c2;
<b class="nc"><i>4500</i>&nbsp;        }</b>
<i>4501</i>&nbsp;
<i>4502</i>&nbsp;        protected boolean prefixOf(CharSequence text, int off, int end) {
<i>4503</i>&nbsp;            if (text instanceof String) {
<i>4504</i>&nbsp;                return ((String)text).startsWith(key, off);
<i>4505</i>&nbsp;            }
<i>4506</i>&nbsp;            int len = key.length();
<i>4507</i>&nbsp;            if (len &gt; end - off) {
<i>4508</i>&nbsp;                return false;
<i>4509</i>&nbsp;            }
<i>4510</i>&nbsp;            int off0 = 0;
<i>4511</i>&nbsp;            while (len-- &gt; 0) {
<i>4512</i>&nbsp;                if (!isEqual(key.charAt(off0++), text.charAt(off++))) {
<i>4513</i>&nbsp;                    return false;
<i>4514</i>&nbsp;                }
<i>4515</i>&nbsp;            }
<i>4516</i>&nbsp;            return true;
<i>4517</i>&nbsp;        }
<i>4518</i>&nbsp;
<i>4519</i>&nbsp;        private int prefixLength(String k) {
<i>4520</i>&nbsp;            int off = 0;
<i>4521</i>&nbsp;            while (off &lt; k.length() &amp;&amp; off &lt; key.length()) {
<i>4522</i>&nbsp;                if (!isEqual(k.charAt(off), key.charAt(off))) {
<i>4523</i>&nbsp;                    return off;
<i>4524</i>&nbsp;                }
<i>4525</i>&nbsp;                off++;
<i>4526</i>&nbsp;            }
<i>4527</i>&nbsp;            return off;
<i>4528</i>&nbsp;        }
<i>4529</i>&nbsp;
<i>4530</i>&nbsp;        /**
<i>4531</i>&nbsp;         * Case Insensitive prefix tree.
<i>4532</i>&nbsp;         */
<i>4533</i>&nbsp;        private static class CI extends PrefixTree {
<i>4534</i>&nbsp;
<i>4535</i>&nbsp;            private CI(String k, String v, PrefixTree child) {
<i>4536</i>&nbsp;                super(k, v, child);
<i>4537</i>&nbsp;            }
<i>4538</i>&nbsp;
<i>4539</i>&nbsp;            @Override
<i>4540</i>&nbsp;            protected CI newNode(String k, String v, PrefixTree child) {
<i>4541</i>&nbsp;                return new CI(k, v, child);
<i>4542</i>&nbsp;            }
<i>4543</i>&nbsp;
<i>4544</i>&nbsp;            @Override
<i>4545</i>&nbsp;            protected boolean isEqual(char c1, char c2) {
<i>4546</i>&nbsp;                return DateTimeParseContext.charEqualsIgnoreCase(c1, c2);
<i>4547</i>&nbsp;            }
<i>4548</i>&nbsp;
<i>4549</i>&nbsp;            @Override
<i>4550</i>&nbsp;            protected boolean prefixOf(CharSequence text, int off, int end) {
<i>4551</i>&nbsp;                int len = key.length();
<i>4552</i>&nbsp;                if (len &gt; end - off) {
<i>4553</i>&nbsp;                    return false;
<i>4554</i>&nbsp;                }
<i>4555</i>&nbsp;                int off0 = 0;
<i>4556</i>&nbsp;                while (len-- &gt; 0) {
<i>4557</i>&nbsp;                    if (!isEqual(key.charAt(off0++), text.charAt(off++))) {
<i>4558</i>&nbsp;                        return false;
<i>4559</i>&nbsp;                    }
<i>4560</i>&nbsp;                }
<i>4561</i>&nbsp;                return true;
<i>4562</i>&nbsp;            }
<i>4563</i>&nbsp;        }
<i>4564</i>&nbsp;
<i>4565</i>&nbsp;        /**
<i>4566</i>&nbsp;         * Lenient prefix tree. Case insensitive and ignores characters
<i>4567</i>&nbsp;         * like space, underscore and slash.
<i>4568</i>&nbsp;         */
<i>4569</i>&nbsp;        private static class LENIENT extends CI {
<i>4570</i>&nbsp;
<i>4571</i>&nbsp;            private LENIENT(String k, String v, PrefixTree child) {
<i>4572</i>&nbsp;                super(k, v, child);
<i>4573</i>&nbsp;            }
<i>4574</i>&nbsp;
<i>4575</i>&nbsp;            @Override
<i>4576</i>&nbsp;            protected CI newNode(String k, String v, PrefixTree child) {
<i>4577</i>&nbsp;                return new LENIENT(k, v, child);
<i>4578</i>&nbsp;            }
<i>4579</i>&nbsp;
<i>4580</i>&nbsp;            private boolean isLenientChar(char c) {
<i>4581</i>&nbsp;                return c == &#39; &#39; || c == &#39;_&#39; || c == &#39;/&#39;;
<i>4582</i>&nbsp;            }
<i>4583</i>&nbsp;
<i>4584</i>&nbsp;            protected String toKey(String k) {
<i>4585</i>&nbsp;                for (int i = 0; i &lt; k.length(); i++) {
<i>4586</i>&nbsp;                    if (isLenientChar(k.charAt(i))) {
<i>4587</i>&nbsp;                        StringBuilder sb = new StringBuilder(k.length());
<i>4588</i>&nbsp;                        sb.append(k, 0, i);
<i>4589</i>&nbsp;                        i++;
<i>4590</i>&nbsp;                        while (i &lt; k.length()) {
<i>4591</i>&nbsp;                            if (!isLenientChar(k.charAt(i))) {
<i>4592</i>&nbsp;                                sb.append(k.charAt(i));
<i>4593</i>&nbsp;                            }
<i>4594</i>&nbsp;                            i++;
<i>4595</i>&nbsp;                        }
<i>4596</i>&nbsp;                        return sb.toString();
<i>4597</i>&nbsp;                    }
<i>4598</i>&nbsp;                }
<i>4599</i>&nbsp;                return k;
<i>4600</i>&nbsp;            }
<i>4601</i>&nbsp;
<i>4602</i>&nbsp;            @Override
<i>4603</i>&nbsp;            public String match(CharSequence text, ParsePosition pos) {
<i>4604</i>&nbsp;                int off = pos.getIndex();
<i>4605</i>&nbsp;                int end = text.length();
<i>4606</i>&nbsp;                int len = key.length();
<i>4607</i>&nbsp;                int koff = 0;
<i>4608</i>&nbsp;                while (koff &lt; len &amp;&amp; off &lt; end) {
<i>4609</i>&nbsp;                    if (isLenientChar(text.charAt(off))) {
<i>4610</i>&nbsp;                        off++;
<i>4611</i>&nbsp;                        continue;
<i>4612</i>&nbsp;                    }
<i>4613</i>&nbsp;                    if (!isEqual(key.charAt(koff++), text.charAt(off++))) {
<i>4614</i>&nbsp;                        return null;
<i>4615</i>&nbsp;                    }
<i>4616</i>&nbsp;                }
<i>4617</i>&nbsp;                if (koff != len) {
<i>4618</i>&nbsp;                    return null;
<i>4619</i>&nbsp;                }
<i>4620</i>&nbsp;                if (child != null &amp;&amp; off != end) {
<i>4621</i>&nbsp;                    int off0 = off;
<i>4622</i>&nbsp;                    while (off0 &lt; end &amp;&amp; isLenientChar(text.charAt(off0))) {
<i>4623</i>&nbsp;                        off0++;
<i>4624</i>&nbsp;                    }
<i>4625</i>&nbsp;                    if (off0 &lt; end) {
<i>4626</i>&nbsp;                        PrefixTree c = child;
<i>4627</i>&nbsp;                        do {
<i>4628</i>&nbsp;                            if (isEqual(c.c0, text.charAt(off0))) {
<i>4629</i>&nbsp;                                pos.setIndex(off0);
<i>4630</i>&nbsp;                                String found = c.match(text, pos);
<i>4631</i>&nbsp;                                if (found != null) {
<i>4632</i>&nbsp;                                    return found;
<i>4633</i>&nbsp;                                }
<i>4634</i>&nbsp;                                break;
<i>4635</i>&nbsp;                            }
<i>4636</i>&nbsp;                            c = c.sibling;
<i>4637</i>&nbsp;                        } while (c != null);
<i>4638</i>&nbsp;                    }
<i>4639</i>&nbsp;                }
<i>4640</i>&nbsp;                pos.setIndex(off);
<i>4641</i>&nbsp;                return value;
<i>4642</i>&nbsp;            }
<i>4643</i>&nbsp;        }
<i>4644</i>&nbsp;    }
<i>4645</i>&nbsp;
<i>4646</i>&nbsp;    //-----------------------------------------------------------------------
<i>4647</i>&nbsp;    /**
<i>4648</i>&nbsp;     * Prints or parses a chronology.
<i>4649</i>&nbsp;     */
<i>4650</i>&nbsp;    static final class ChronoPrinterParser implements DateTimePrinterParser {
<i>4651</i>&nbsp;        /** The text style to output, null means the ID. */
<i>4652</i>&nbsp;        private final TextStyle textStyle;
<i>4653</i>&nbsp;
<i>4654</i>&nbsp;        ChronoPrinterParser(TextStyle textStyle) {
<i>4655</i>&nbsp;            // validated by caller
<i>4656</i>&nbsp;            this.textStyle = textStyle;
<i>4657</i>&nbsp;        }
<i>4658</i>&nbsp;
<i>4659</i>&nbsp;        @Override
<i>4660</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>4661</i>&nbsp;            Chronology chrono = context.getValue(TemporalQueries.chronology());
<i>4662</i>&nbsp;            if (chrono == null) {
<i>4663</i>&nbsp;                return false;
<i>4664</i>&nbsp;            }
<i>4665</i>&nbsp;            if (textStyle == null) {
<i>4666</i>&nbsp;                buf.append(chrono.getId());
<i>4667</i>&nbsp;            } else {
<i>4668</i>&nbsp;                buf.append(getChronologyName(chrono, context.getLocale()));
<i>4669</i>&nbsp;            }
<i>4670</i>&nbsp;            return true;
<i>4671</i>&nbsp;        }
<i>4672</i>&nbsp;
<i>4673</i>&nbsp;        @Override
<i>4674</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>4675</i>&nbsp;            // simple looping parser to find the chronology
<i>4676</i>&nbsp;            if (position &lt; 0 || position &gt; text.length()) {
<i>4677</i>&nbsp;                throw new IndexOutOfBoundsException();
<i>4678</i>&nbsp;            }
<i>4679</i>&nbsp;            Set&lt;Chronology&gt; chronos = Chronology.getAvailableChronologies();
<i>4680</i>&nbsp;            Chronology bestMatch = null;
<i>4681</i>&nbsp;            int matchLen = -1;
<i>4682</i>&nbsp;            for (Chronology chrono : chronos) {
<i>4683</i>&nbsp;                String name;
<i>4684</i>&nbsp;                if (textStyle == null) {
<i>4685</i>&nbsp;                    name = chrono.getId();
<i>4686</i>&nbsp;                } else {
<i>4687</i>&nbsp;                    name = getChronologyName(chrono, context.getLocale());
<i>4688</i>&nbsp;                }
<i>4689</i>&nbsp;                int nameLen = name.length();
<i>4690</i>&nbsp;                if (nameLen &gt; matchLen &amp;&amp; context.subSequenceEquals(text, position, name, 0, nameLen)) {
<i>4691</i>&nbsp;                    bestMatch = chrono;
<i>4692</i>&nbsp;                    matchLen = nameLen;
<i>4693</i>&nbsp;                }
<i>4694</i>&nbsp;            }
<i>4695</i>&nbsp;            if (bestMatch == null) {
<i>4696</i>&nbsp;                return ~position;
<i>4697</i>&nbsp;            }
<i>4698</i>&nbsp;            context.setParsed(bestMatch);
<i>4699</i>&nbsp;            return position + matchLen;
<i>4700</i>&nbsp;        }
<i>4701</i>&nbsp;
<i>4702</i>&nbsp;        /**
<i>4703</i>&nbsp;         * Returns the chronology name of the given chrono in the given locale
<i>4704</i>&nbsp;         * if available, or the chronology Id otherwise. The regular ResourceBundle
<i>4705</i>&nbsp;         * search path is used for looking up the chronology name.
<i>4706</i>&nbsp;         *
<i>4707</i>&nbsp;         * @param chrono  the chronology, not null
<i>4708</i>&nbsp;         * @param locale  the locale, not null
<i>4709</i>&nbsp;         * @return the chronology name of chrono in locale, or the id if no name is available
<i>4710</i>&nbsp;         * @throws NullPointerException if chrono or locale is null
<i>4711</i>&nbsp;         */
<i>4712</i>&nbsp;        private String getChronologyName(Chronology chrono, Locale locale) {
<i>4713</i>&nbsp;            String key = &quot;calendarname.&quot; + chrono.getCalendarType();
<i>4714</i>&nbsp;            String name = DateTimeTextProvider.getLocalizedResource(key, locale);
<i>4715</i>&nbsp;            return Objects.requireNonNullElseGet(name, () -&gt; chrono.getId());
<i>4716</i>&nbsp;        }
<i>4717</i>&nbsp;    }
<i>4718</i>&nbsp;
<i>4719</i>&nbsp;    //-----------------------------------------------------------------------
<i>4720</i>&nbsp;    /**
<i>4721</i>&nbsp;     * Prints or parses a localized pattern.
<i>4722</i>&nbsp;     */
<i>4723</i>&nbsp;    static final class LocalizedPrinterParser implements DateTimePrinterParser {
<i>4724</i>&nbsp;        /** Cache of formatters. */
<i>4725</i>&nbsp;        private static final ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTER_CACHE = new ConcurrentHashMap&lt;&gt;(16, 0.75f, 2);
<i>4726</i>&nbsp;
<i>4727</i>&nbsp;        private final FormatStyle dateStyle;
<i>4728</i>&nbsp;        private final FormatStyle timeStyle;
<i>4729</i>&nbsp;
<i>4730</i>&nbsp;        /**
<i>4731</i>&nbsp;         * Constructor.
<i>4732</i>&nbsp;         *
<i>4733</i>&nbsp;         * @param dateStyle  the date style to use, may be null
<i>4734</i>&nbsp;         * @param timeStyle  the time style to use, may be null
<i>4735</i>&nbsp;         */
<i>4736</i>&nbsp;        LocalizedPrinterParser(FormatStyle dateStyle, FormatStyle timeStyle) {
<i>4737</i>&nbsp;            // validated by caller
<i>4738</i>&nbsp;            this.dateStyle = dateStyle;
<i>4739</i>&nbsp;            this.timeStyle = timeStyle;
<i>4740</i>&nbsp;        }
<i>4741</i>&nbsp;
<i>4742</i>&nbsp;        @Override
<i>4743</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>4744</i>&nbsp;            Chronology chrono = Chronology.from(context.getTemporal());
<i>4745</i>&nbsp;            return formatter(context.getLocale(), chrono).toPrinterParser(false).format(context, buf);
<i>4746</i>&nbsp;        }
<i>4747</i>&nbsp;
<i>4748</i>&nbsp;        @Override
<i>4749</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>4750</i>&nbsp;            Chronology chrono = context.getEffectiveChronology();
<i>4751</i>&nbsp;            return formatter(context.getLocale(), chrono).toPrinterParser(false).parse(context, text, position);
<i>4752</i>&nbsp;        }
<i>4753</i>&nbsp;
<i>4754</i>&nbsp;        /**
<i>4755</i>&nbsp;         * Gets the formatter to use.
<i>4756</i>&nbsp;         * &lt;p&gt;
<i>4757</i>&nbsp;         * The formatter will be the most appropriate to use for the date and time style in the locale.
<i>4758</i>&nbsp;         * For example, some locales will use the month name while others will use the number.
<i>4759</i>&nbsp;         *
<i>4760</i>&nbsp;         * @param locale  the locale to use, not null
<i>4761</i>&nbsp;         * @param chrono  the chronology to use, not null
<i>4762</i>&nbsp;         * @return the formatter, not null
<i>4763</i>&nbsp;         * @throws IllegalArgumentException if the formatter cannot be found
<i>4764</i>&nbsp;         */
<i>4765</i>&nbsp;        private DateTimeFormatter formatter(Locale locale, Chronology chrono) {
<i>4766</i>&nbsp;            String key = chrono.getId() + &#39;|&#39; + locale.toString() + &#39;|&#39; + dateStyle + timeStyle;
<i>4767</i>&nbsp;            DateTimeFormatter formatter = FORMATTER_CACHE.get(key);
<i>4768</i>&nbsp;            if (formatter == null) {
<i>4769</i>&nbsp;                String pattern = getLocalizedDateTimePattern(dateStyle, timeStyle, chrono, locale);
<i>4770</i>&nbsp;                formatter = new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale);
<i>4771</i>&nbsp;                DateTimeFormatter old = FORMATTER_CACHE.putIfAbsent(key, formatter);
<i>4772</i>&nbsp;                if (old != null) {
<i>4773</i>&nbsp;                    formatter = old;
<i>4774</i>&nbsp;                }
<i>4775</i>&nbsp;            }
<i>4776</i>&nbsp;            return formatter;
<i>4777</i>&nbsp;        }
<i>4778</i>&nbsp;
<i>4779</i>&nbsp;        @Override
<i>4780</i>&nbsp;        public String toString() {
<i>4781</i>&nbsp;            return &quot;Localized(&quot; + (dateStyle != null ? dateStyle : &quot;&quot;) + &quot;,&quot; +
<i>4782</i>&nbsp;                (timeStyle != null ? timeStyle : &quot;&quot;) + &quot;)&quot;;
<i>4783</i>&nbsp;        }
<i>4784</i>&nbsp;    }
<i>4785</i>&nbsp;
<i>4786</i>&nbsp;    //-----------------------------------------------------------------------
<i>4787</i>&nbsp;    /**
<i>4788</i>&nbsp;     * Prints or parses a localized pattern from a localized field.
<i>4789</i>&nbsp;     * The specific formatter and parameters is not selected until
<i>4790</i>&nbsp;     * the field is to be printed or parsed.
<i>4791</i>&nbsp;     * The locale is needed to select the proper WeekFields from which
<i>4792</i>&nbsp;     * the field for day-of-week, week-of-month, or week-of-year is selected.
<i>4793</i>&nbsp;     * Hence the inherited field NumberPrinterParser.field is unused.
<i>4794</i>&nbsp;     */
<i>4795</i>&nbsp;    static final class WeekBasedFieldPrinterParser extends NumberPrinterParser {
<i>4796</i>&nbsp;        private char chr;
<i>4797</i>&nbsp;        private int count;
<i>4798</i>&nbsp;
<i>4799</i>&nbsp;        /**
<i>4800</i>&nbsp;         * Constructor.
<i>4801</i>&nbsp;         *
<i>4802</i>&nbsp;         * @param chr the pattern format letter that added this PrinterParser.
<i>4803</i>&nbsp;         * @param count the repeat count of the format letter
<i>4804</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 19
<i>4805</i>&nbsp;         * @param maxWidth  the maximum field width, from minWidth to 19
<i>4806</i>&nbsp;         */
<i>4807</i>&nbsp;        WeekBasedFieldPrinterParser(char chr, int count, int minWidth, int maxWidth) {
<i>4808</i>&nbsp;            this(chr, count, minWidth, maxWidth, 0);
<i>4809</i>&nbsp;        }
<i>4810</i>&nbsp;
<i>4811</i>&nbsp;        /**
<i>4812</i>&nbsp;         * Constructor.
<i>4813</i>&nbsp;         *
<i>4814</i>&nbsp;         * @param chr the pattern format letter that added this PrinterParser.
<i>4815</i>&nbsp;         * @param count the repeat count of the format letter
<i>4816</i>&nbsp;         * @param minWidth  the minimum field width, from 1 to 19
<i>4817</i>&nbsp;         * @param maxWidth  the maximum field width, from minWidth to 19
<i>4818</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater,
<i>4819</i>&nbsp;         * -1 if fixed width due to active adjacent parsing
<i>4820</i>&nbsp;         */
<i>4821</i>&nbsp;        WeekBasedFieldPrinterParser(char chr, int count, int minWidth, int maxWidth,
<i>4822</i>&nbsp;                int subsequentWidth) {
<i>4823</i>&nbsp;            super(null, minWidth, maxWidth, SignStyle.NOT_NEGATIVE, subsequentWidth);
<i>4824</i>&nbsp;            this.chr = chr;
<i>4825</i>&nbsp;            this.count = count;
<i>4826</i>&nbsp;        }
<i>4827</i>&nbsp;
<i>4828</i>&nbsp;        /**
<i>4829</i>&nbsp;         * Returns a new instance with fixed width flag set.
<i>4830</i>&nbsp;         *
<i>4831</i>&nbsp;         * @return a new updated printer-parser, not null
<i>4832</i>&nbsp;         */
<i>4833</i>&nbsp;        @Override
<i>4834</i>&nbsp;        WeekBasedFieldPrinterParser withFixedWidth() {
<i>4835</i>&nbsp;            if (subsequentWidth == -1) {
<i>4836</i>&nbsp;                return this;
<i>4837</i>&nbsp;            }
<i>4838</i>&nbsp;            return new WeekBasedFieldPrinterParser(chr, count, minWidth, maxWidth, -1);
<i>4839</i>&nbsp;        }
<i>4840</i>&nbsp;
<i>4841</i>&nbsp;        /**
<i>4842</i>&nbsp;         * Returns a new instance with an updated subsequent width.
<i>4843</i>&nbsp;         *
<i>4844</i>&nbsp;         * @param subsequentWidth  the width of subsequent non-negative numbers, 0 or greater
<i>4845</i>&nbsp;         * @return a new updated printer-parser, not null
<i>4846</i>&nbsp;         */
<i>4847</i>&nbsp;        @Override
<i>4848</i>&nbsp;        WeekBasedFieldPrinterParser withSubsequentWidth(int subsequentWidth) {
<i>4849</i>&nbsp;            return new WeekBasedFieldPrinterParser(chr, count, minWidth, maxWidth,
<i>4850</i>&nbsp;                    this.subsequentWidth + subsequentWidth);
<i>4851</i>&nbsp;        }
<i>4852</i>&nbsp;
<i>4853</i>&nbsp;        @Override
<i>4854</i>&nbsp;        public boolean format(DateTimePrintContext context, StringBuilder buf) {
<i>4855</i>&nbsp;            return printerParser(context.getLocale()).format(context, buf);
<i>4856</i>&nbsp;        }
<i>4857</i>&nbsp;
<i>4858</i>&nbsp;        @Override
<i>4859</i>&nbsp;        public int parse(DateTimeParseContext context, CharSequence text, int position) {
<i>4860</i>&nbsp;            return printerParser(context.getLocale()).parse(context, text, position);
<i>4861</i>&nbsp;        }
<i>4862</i>&nbsp;
<i>4863</i>&nbsp;        /**
<i>4864</i>&nbsp;         * Gets the printerParser to use based on the field and the locale.
<i>4865</i>&nbsp;         *
<i>4866</i>&nbsp;         * @param locale  the locale to use, not null
<i>4867</i>&nbsp;         * @return the formatter, not null
<i>4868</i>&nbsp;         * @throws IllegalArgumentException if the formatter cannot be found
<i>4869</i>&nbsp;         */
<i>4870</i>&nbsp;        private DateTimePrinterParser printerParser(Locale locale) {
<i>4871</i>&nbsp;            WeekFields weekDef = WeekFields.of(locale);
<i>4872</i>&nbsp;            TemporalField field = null;
<i>4873</i>&nbsp;            switch (chr) {
<i>4874</i>&nbsp;                case &#39;Y&#39;:
<i>4875</i>&nbsp;                    field = weekDef.weekBasedYear();
<i>4876</i>&nbsp;                    if (count == 2) {
<i>4877</i>&nbsp;                        return new ReducedPrinterParser(field, 2, 2, 0, ReducedPrinterParser.BASE_DATE,
<i>4878</i>&nbsp;                                this.subsequentWidth);
<i>4879</i>&nbsp;                    } else {
<i>4880</i>&nbsp;                        return new NumberPrinterParser(field, count, 19,
<i>4881</i>&nbsp;                                (count &lt; 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD,
<i>4882</i>&nbsp;                                this.subsequentWidth);
<i>4883</i>&nbsp;                    }
<i>4884</i>&nbsp;                case &#39;e&#39;:
<i>4885</i>&nbsp;                case &#39;c&#39;:
<i>4886</i>&nbsp;                    field = weekDef.dayOfWeek();
<i>4887</i>&nbsp;                    break;
<i>4888</i>&nbsp;                case &#39;w&#39;:
<i>4889</i>&nbsp;                    field = weekDef.weekOfWeekBasedYear();
<i>4890</i>&nbsp;                    break;
<i>4891</i>&nbsp;                case &#39;W&#39;:
<i>4892</i>&nbsp;                    field = weekDef.weekOfMonth();
<i>4893</i>&nbsp;                    break;
<i>4894</i>&nbsp;                default:
<i>4895</i>&nbsp;                    throw new IllegalStateException(&quot;unreachable&quot;);
<i>4896</i>&nbsp;            }
<i>4897</i>&nbsp;            return new NumberPrinterParser(field, minWidth, maxWidth, SignStyle.NOT_NEGATIVE,
<i>4898</i>&nbsp;                    this.subsequentWidth);
<i>4899</i>&nbsp;        }
<i>4900</i>&nbsp;
<i>4901</i>&nbsp;        @Override
<i>4902</i>&nbsp;        public String toString() {
<i>4903</i>&nbsp;            StringBuilder sb = new StringBuilder(30);
<i>4904</i>&nbsp;            sb.append(&quot;Localized(&quot;);
<i>4905</i>&nbsp;            if (chr == &#39;Y&#39;) {
<i>4906</i>&nbsp;                if (count == 1) {
<i>4907</i>&nbsp;                    sb.append(&quot;WeekBasedYear&quot;);
<i>4908</i>&nbsp;                } else if (count == 2) {
<i>4909</i>&nbsp;                    sb.append(&quot;ReducedValue(WeekBasedYear,2,2,2000-01-01)&quot;);
<i>4910</i>&nbsp;                } else {
<i>4911</i>&nbsp;                    sb.append(&quot;WeekBasedYear,&quot;).append(count).append(&quot;,&quot;)
<i>4912</i>&nbsp;                            .append(19).append(&quot;,&quot;)
<i>4913</i>&nbsp;                            .append((count &lt; 4) ? SignStyle.NORMAL : SignStyle.EXCEEDS_PAD);
<i>4914</i>&nbsp;                }
<i>4915</i>&nbsp;            } else {
<i>4916</i>&nbsp;                switch (chr) {
<i>4917</i>&nbsp;                    case &#39;c&#39;:
<i>4918</i>&nbsp;                    case &#39;e&#39;:
<i>4919</i>&nbsp;                        sb.append(&quot;DayOfWeek&quot;);
<i>4920</i>&nbsp;                        break;
<i>4921</i>&nbsp;                    case &#39;w&#39;:
<i>4922</i>&nbsp;                        sb.append(&quot;WeekOfWeekBasedYear&quot;);
<i>4923</i>&nbsp;                        break;
<i>4924</i>&nbsp;                    case &#39;W&#39;:
<i>4925</i>&nbsp;                        sb.append(&quot;WeekOfMonth&quot;);
<i>4926</i>&nbsp;                        break;
<i>4927</i>&nbsp;                    default:
<i>4928</i>&nbsp;                        break;
<i>4929</i>&nbsp;                }
<i>4930</i>&nbsp;                sb.append(&quot;,&quot;);
<i>4931</i>&nbsp;                sb.append(count);
<i>4932</i>&nbsp;            }
<i>4933</i>&nbsp;            sb.append(&quot;)&quot;);
<i>4934</i>&nbsp;            return sb.toString();
<i>4935</i>&nbsp;        }
<i>4936</i>&nbsp;    }
<i>4937</i>&nbsp;
<i>4938</i>&nbsp;    //-------------------------------------------------------------------------
<i>4939</i>&nbsp;    /**
<i>4940</i>&nbsp;     * Length comparator.
<i>4941</i>&nbsp;     */
<i>4942</i>&nbsp;    static final Comparator&lt;String&gt; LENGTH_SORT = new Comparator&lt;String&gt;() {
<i>4943</i>&nbsp;        @Override
<i>4944</i>&nbsp;        public int compare(String str1, String str2) {
<i>4945</i>&nbsp;            return str1.length() == str2.length() ? str1.compareTo(str2) : str1.length() - str2.length();
<i>4946</i>&nbsp;        }
<i>4947</i>&nbsp;    };
<i>4948</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
