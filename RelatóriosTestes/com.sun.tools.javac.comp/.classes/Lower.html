


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Lower</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.comp</a> ]
</div>

<h1>Coverage Summary for Class: Lower (com.sun.tools.javac.comp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Lower</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 137)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1650)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Lower$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$1Patcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$3$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$6$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$BasicFreeVarCollector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$ClassMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$EnumMapping</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 55)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Lower$FreeVarCollector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 37)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 175)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1803)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.comp;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.*;
<i>29</i>&nbsp;
<i>30</i>&nbsp;import com.sun.tools.javac.code.*;
<i>31</i>&nbsp;import com.sun.tools.javac.code.Kinds.KindSelector;
<i>32</i>&nbsp;import com.sun.tools.javac.code.Scope.WriteableScope;
<i>33</i>&nbsp;import com.sun.tools.javac.jvm.*;
<i>34</i>&nbsp;import com.sun.tools.javac.main.Option.PkgInfo;
<i>35</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<i>36</i>&nbsp;import com.sun.tools.javac.tree.*;
<i>37</i>&nbsp;import com.sun.tools.javac.util.*;
<i>38</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<i>39</i>&nbsp;import com.sun.tools.javac.util.List;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import com.sun.tools.javac.code.Symbol.*;
<i>42</i>&nbsp;import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
<i>43</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Errors;
<i>44</i>&nbsp;import com.sun.tools.javac.tree.JCTree.*;
<i>45</i>&nbsp;import com.sun.tools.javac.code.Type.*;
<i>46</i>&nbsp;
<i>47</i>&nbsp;import com.sun.tools.javac.jvm.Target;
<i>48</i>&nbsp;import com.sun.tools.javac.tree.EndPosTable;
<i>49</i>&nbsp;
<i>50</i>&nbsp;import static com.sun.tools.javac.code.Flags.*;
<i>51</i>&nbsp;import static com.sun.tools.javac.code.Flags.BLOCK;
<i>52</i>&nbsp;import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
<i>53</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.*;
<i>54</i>&nbsp;import static com.sun.tools.javac.code.Kinds.Kind.*;
<i>55</i>&nbsp;import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.DEREF;
<i>56</i>&nbsp;import static com.sun.tools.javac.jvm.ByteCodes.*;
<i>57</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
<i>58</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.Tag.*;
<i>59</i>&nbsp;
<i>60</i>&nbsp;/** This pass translates away some syntactic sugar: inner classes,
<b class="nc"><i>61</i>&nbsp; *  class literals, assertions, foreach loops, etc.</b>
<b class="nc"><i>62</i>&nbsp; *</b>
<i>63</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>64</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>65</i>&nbsp; *  This code and its internal interfaces are subject to change or
<b class="nc"><i>66</i>&nbsp; *  deletion without notice.&lt;/b&gt;</b>
<b class="nc"><i>67</i>&nbsp; */</b>
<b class="nc"><i>68</i>&nbsp;public class Lower extends TreeTranslator {</b>
<b class="nc"><i>69</i>&nbsp;    protected static final Context.Key&lt;Lower&gt; lowerKey = new Context.Key&lt;&gt;();</b>
<i>70</i>&nbsp;
<i>71</i>&nbsp;    public static Lower instance(Context context) {
<i>72</i>&nbsp;        Lower instance = context.get(lowerKey);
<i>73</i>&nbsp;        if (instance == null)
<i>74</i>&nbsp;            instance = new Lower(context);
<i>75</i>&nbsp;        return instance;
<i>76</i>&nbsp;    }
<i>77</i>&nbsp;
<i>78</i>&nbsp;    private final Names names;
<i>79</i>&nbsp;    private final Log log;
<i>80</i>&nbsp;    private final Symtab syms;
<i>81</i>&nbsp;    private final Resolve rs;
<i>82</i>&nbsp;    private final Operators operators;
<i>83</i>&nbsp;    private final Check chk;
<i>84</i>&nbsp;    private final Attr attr;
<i>85</i>&nbsp;    private TreeMaker make;
<i>86</i>&nbsp;    private DiagnosticPosition make_pos;
<i>87</i>&nbsp;    private final ClassWriter writer;
<i>88</i>&nbsp;    private final ConstFold cfolder;
<i>89</i>&nbsp;    private final Target target;
<i>90</i>&nbsp;    private final Source source;
<i>91</i>&nbsp;    private final TypeEnvs typeEnvs;
<i>92</i>&nbsp;    private final Name dollarAssertionsDisabled;
<b class="nc"><i>93</i>&nbsp;    private final Name classDollar;</b>
<b class="nc"><i>94</i>&nbsp;    private final Name dollarCloseResource;</b>
<b class="nc"><i>95</i>&nbsp;    private final Types types;</b>
<b class="nc"><i>96</i>&nbsp;    private final boolean debugLower;</b>
<b class="nc"><i>97</i>&nbsp;    private final boolean disableProtectedAccessors; // experimental</b>
<b class="nc"><i>98</i>&nbsp;    private final PkgInfo pkginfoOpt;</b>
<b class="nc"><i>99</i>&nbsp;</b>
<b class="nc"><i>100</i>&nbsp;    protected Lower(Context context) {</b>
<b class="nc"><i>101</i>&nbsp;        context.put(lowerKey, this);</b>
<b class="nc"><i>102</i>&nbsp;        names = Names.instance(context);</b>
<b class="nc"><i>103</i>&nbsp;        log = Log.instance(context);</b>
<b class="nc"><i>104</i>&nbsp;        syms = Symtab.instance(context);</b>
<b class="nc"><i>105</i>&nbsp;        rs = Resolve.instance(context);</b>
<b class="nc"><i>106</i>&nbsp;        operators = Operators.instance(context);</b>
<b class="nc"><i>107</i>&nbsp;        chk = Check.instance(context);</b>
<b class="nc"><i>108</i>&nbsp;        attr = Attr.instance(context);</b>
<b class="nc"><i>109</i>&nbsp;        make = TreeMaker.instance(context);</b>
<b class="nc"><i>110</i>&nbsp;        writer = ClassWriter.instance(context);</b>
<b class="nc"><i>111</i>&nbsp;        cfolder = ConstFold.instance(context);</b>
<b class="nc"><i>112</i>&nbsp;        target = Target.instance(context);</b>
<i>113</i>&nbsp;        source = Source.instance(context);
<b class="nc"><i>114</i>&nbsp;        typeEnvs = TypeEnvs.instance(context);</b>
<b class="nc"><i>115</i>&nbsp;        dollarAssertionsDisabled = names.</b>
<b class="nc"><i>116</i>&nbsp;            fromString(target.syntheticNameChar() + &quot;assertionsDisabled&quot;);</b>
<b class="nc"><i>117</i>&nbsp;        classDollar = names.</b>
<i>118</i>&nbsp;            fromString(&quot;class&quot; + target.syntheticNameChar());
<i>119</i>&nbsp;        dollarCloseResource = names.
<i>120</i>&nbsp;            fromString(target.syntheticNameChar() + &quot;closeResource&quot;);
<i>121</i>&nbsp;
<i>122</i>&nbsp;        types = Types.instance(context);
<i>123</i>&nbsp;        Options options = Options.instance(context);
<i>124</i>&nbsp;        debugLower = options.isSet(&quot;debuglower&quot;);
<i>125</i>&nbsp;        pkginfoOpt = PkgInfo.get(options);
<i>126</i>&nbsp;        disableProtectedAccessors = options.isSet(&quot;disableProtectedAccessors&quot;);
<i>127</i>&nbsp;    }
<i>128</i>&nbsp;
<i>129</i>&nbsp;    /** The currently enclosing class.
<i>130</i>&nbsp;     */
<i>131</i>&nbsp;    ClassSymbol currentClass;
<i>132</i>&nbsp;
<i>133</i>&nbsp;    /** A queue of all translated classes.
<i>134</i>&nbsp;     */
<i>135</i>&nbsp;    ListBuffer&lt;JCTree&gt; translated;
<i>136</i>&nbsp;
<i>137</i>&nbsp;    /** Environment for symbol lookup, set by translateTopLevelClass.
<i>138</i>&nbsp;     */
<i>139</i>&nbsp;    Env&lt;AttrContext&gt; attrEnv;
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /** A hash table mapping syntax trees to their ending source positions.
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    EndPosTable endPosTable;
<i>144</i>&nbsp;
<i>145</i>&nbsp;/**************************************************************************
<b class="nc"><i>146</i>&nbsp; * Global mappings</b>
<i>147</i>&nbsp; *************************************************************************/
<i>148</i>&nbsp;
<i>149</i>&nbsp;    /** A hash table mapping local classes to their definitions.
<i>150</i>&nbsp;     */
<i>151</i>&nbsp;    Map&lt;ClassSymbol, JCClassDecl&gt; classdefs;
<i>152</i>&nbsp;
<i>153</i>&nbsp;    /** A hash table mapping local classes to a list of pruned trees.
<i>154</i>&nbsp;     */
<i>155</i>&nbsp;    public Map&lt;ClassSymbol, List&lt;JCTree&gt;&gt; prunedTree = new WeakHashMap&lt;&gt;();
<i>156</i>&nbsp;
<i>157</i>&nbsp;    /** A hash table mapping virtual accessed symbols in outer subclasses
<i>158</i>&nbsp;     *  to the actually referred symbol in superclasses.
<i>159</i>&nbsp;     */
<i>160</i>&nbsp;    Map&lt;Symbol,Symbol&gt; actualSymbols;
<i>161</i>&nbsp;
<i>162</i>&nbsp;    /** The current method definition.
<i>163</i>&nbsp;     */
<i>164</i>&nbsp;    JCMethodDecl currentMethodDef;
<i>165</i>&nbsp;
<i>166</i>&nbsp;    /** The current method symbol.
<i>167</i>&nbsp;     */
<i>168</i>&nbsp;    MethodSymbol currentMethodSym;
<i>169</i>&nbsp;
<i>170</i>&nbsp;    /** The currently enclosing outermost class definition.
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    JCClassDecl outermostClassDef;
<b class="nc"><i>173</i>&nbsp;</b>
<i>174</i>&nbsp;    /** The currently enclosing outermost member definition.
<i>175</i>&nbsp;     */
<i>176</i>&nbsp;    JCTree outermostMemberDef;
<i>177</i>&nbsp;
<i>178</i>&nbsp;    /** A map from local variable symbols to their translation (as per LambdaToMethod).
<b class="nc"><i>179</i>&nbsp;     * This is required when a capturing local class is created from a lambda (in which</b>
<i>180</i>&nbsp;     * case the captured symbols should be replaced with the translated lambda symbols).
<i>181</i>&nbsp;     */
<i>182</i>&nbsp;    Map&lt;Symbol, Symbol&gt; lambdaTranslationMap = null;
<i>183</i>&nbsp;
<b class="nc"><i>184</i>&nbsp;    /** A navigator class for assembling a mapping from local class symbols</b>
<b class="nc"><i>185</i>&nbsp;     *  to class definition trees.</b>
<i>186</i>&nbsp;     *  There is only one case; all other cases simply traverse down the tree.
<i>187</i>&nbsp;     */
<b class="nc"><i>188</i>&nbsp;    class ClassMap extends TreeScanner {</b>
<i>189</i>&nbsp;
<i>190</i>&nbsp;        /** All encountered class defs are entered into classdefs table.
<i>191</i>&nbsp;         */
<i>192</i>&nbsp;        public void visitClassDef(JCClassDecl tree) {
<i>193</i>&nbsp;            classdefs.put(tree.sym, tree);
<i>194</i>&nbsp;            super.visitClassDef(tree);
<b class="nc"><i>195</i>&nbsp;        }</b>
<b class="nc"><i>196</i>&nbsp;    }</b>
<i>197</i>&nbsp;    ClassMap classMap = new ClassMap();
<i>198</i>&nbsp;
<b class="nc"><i>199</i>&nbsp;    /** Map a class symbol to its definition.</b>
<b class="nc"><i>200</i>&nbsp;     *  @param c    The class symbol of which we want to determine the definition.</b>
<i>201</i>&nbsp;     */
<b class="nc"><i>202</i>&nbsp;    JCClassDecl classDef(ClassSymbol c) {</b>
<i>203</i>&nbsp;        // First lookup the class in the classdefs table.
<i>204</i>&nbsp;        JCClassDecl def = classdefs.get(c);
<b class="nc"><i>205</i>&nbsp;        if (def == null &amp;&amp; outermostMemberDef != null) {</b>
<b class="nc"><i>206</i>&nbsp;            // If this fails, traverse outermost member definition, entering all</b>
<i>207</i>&nbsp;            // local classes into classdefs, and try again.
<b class="nc"><i>208</i>&nbsp;            classMap.scan(outermostMemberDef);</b>
<i>209</i>&nbsp;            def = classdefs.get(c);
<i>210</i>&nbsp;        }
<i>211</i>&nbsp;        if (def == null) {
<i>212</i>&nbsp;            // If this fails, traverse outermost class definition, entering all
<i>213</i>&nbsp;            // local classes into classdefs, and try again.
<i>214</i>&nbsp;            classMap.scan(outermostClassDef);
<i>215</i>&nbsp;            def = classdefs.get(c);
<i>216</i>&nbsp;        }
<i>217</i>&nbsp;        return def;
<i>218</i>&nbsp;    }
<i>219</i>&nbsp;
<i>220</i>&nbsp;    /** A hash table mapping class symbols to lists of free variables.
<i>221</i>&nbsp;     *  accessed by them. Only free variables of the method immediately containing
<i>222</i>&nbsp;     *  a class are associated with that class.
<b class="nc"><i>223</i>&nbsp;     */</b>
<i>224</i>&nbsp;    Map&lt;ClassSymbol,List&lt;VarSymbol&gt;&gt; freevarCache;
<i>225</i>&nbsp;
<i>226</i>&nbsp;    /** A navigator class for collecting the free variables accessed
<i>227</i>&nbsp;     *  from a local class. There is only one case; all other cases simply
<i>228</i>&nbsp;     *  traverse down the tree. This class doesn&#39;t deal with the specific
<i>229</i>&nbsp;     *  of Lower - it&#39;s an abstract visitor that is meant to be reused in
<i>230</i>&nbsp;     *  order to share the local variable capture logic.
<i>231</i>&nbsp;     */
<i>232</i>&nbsp;    abstract class BasicFreeVarCollector extends TreeScanner {
<i>233</i>&nbsp;
<b class="nc"><i>234</i>&nbsp;        /** Add all free variables of class c to fvs list</b>
<i>235</i>&nbsp;         *  unless they are already there.
<i>236</i>&nbsp;         */
<i>237</i>&nbsp;        abstract void addFreeVars(ClassSymbol c);
<i>238</i>&nbsp;
<i>239</i>&nbsp;        /** If tree refers to a variable in owner of local class, add it to
<i>240</i>&nbsp;         *  free variables list.
<i>241</i>&nbsp;         */
<i>242</i>&nbsp;        public void visitIdent(JCIdent tree) {
<b class="nc"><i>243</i>&nbsp;            visitSymbol(tree.sym);</b>
<b class="nc"><i>244</i>&nbsp;        }</b>
<b class="nc"><i>245</i>&nbsp;        // where</b>
<i>246</i>&nbsp;        abstract void visitSymbol(Symbol _sym);
<i>247</i>&nbsp;
<i>248</i>&nbsp;        /** If tree refers to a class instance creation expression
<i>249</i>&nbsp;         *  add all free variables of the freshly created class.
<i>250</i>&nbsp;         */
<i>251</i>&nbsp;        public void visitNewClass(JCNewClass tree) {
<b class="nc"><i>252</i>&nbsp;            ClassSymbol c = (ClassSymbol)tree.constructor.owner;</b>
<b class="nc"><i>253</i>&nbsp;            addFreeVars(c);</b>
<i>254</i>&nbsp;            super.visitNewClass(tree);
<b class="nc"><i>255</i>&nbsp;        }</b>
<i>256</i>&nbsp;
<i>257</i>&nbsp;        /** If tree refers to a superclass constructor call,
<i>258</i>&nbsp;         *  add all free variables of the superclass.
<i>259</i>&nbsp;         */
<i>260</i>&nbsp;        public void visitApply(JCMethodInvocation tree) {
<i>261</i>&nbsp;            if (TreeInfo.name(tree.meth) == names._super) {
<i>262</i>&nbsp;                addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
<i>263</i>&nbsp;            }
<i>264</i>&nbsp;            super.visitApply(tree);
<i>265</i>&nbsp;        }
<i>266</i>&nbsp;    }
<i>267</i>&nbsp;
<i>268</i>&nbsp;    /**
<i>269</i>&nbsp;     * Lower-specific subclass of {@code BasicFreeVarCollector}.
<i>270</i>&nbsp;     */
<i>271</i>&nbsp;    class FreeVarCollector extends BasicFreeVarCollector {
<i>272</i>&nbsp;
<i>273</i>&nbsp;        /** The owner of the local class.
<i>274</i>&nbsp;         */
<i>275</i>&nbsp;        Symbol owner;
<i>276</i>&nbsp;
<b class="nc"><i>277</i>&nbsp;        /** The local class.</b>
<b class="nc"><i>278</i>&nbsp;         */</b>
<b class="nc"><i>279</i>&nbsp;        ClassSymbol clazz;</b>
<b class="nc"><i>280</i>&nbsp;</b>
<i>281</i>&nbsp;        /** The list of owner&#39;s variables accessed from within the local class,
<i>282</i>&nbsp;         *  without any duplicates.
<i>283</i>&nbsp;         */
<i>284</i>&nbsp;        List&lt;VarSymbol&gt; fvs;
<i>285</i>&nbsp;
<b class="nc"><i>286</i>&nbsp;        FreeVarCollector(ClassSymbol clazz) {</b>
<b class="nc"><i>287</i>&nbsp;            this.clazz = clazz;</b>
<b class="nc"><i>288</i>&nbsp;            this.owner = clazz.owner;</b>
<i>289</i>&nbsp;            this.fvs = List.nil();
<i>290</i>&nbsp;        }
<i>291</i>&nbsp;
<i>292</i>&nbsp;        /** Add free variable to fvs list unless it is already there.
<b class="nc"><i>293</i>&nbsp;         */</b>
<b class="nc"><i>294</i>&nbsp;        private void addFreeVar(VarSymbol v) {</b>
<b class="nc"><i>295</i>&nbsp;            for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail)</b>
<b class="nc"><i>296</i>&nbsp;                if (l.head == v) return;</b>
<i>297</i>&nbsp;            fvs = fvs.prepend(v);
<i>298</i>&nbsp;        }
<i>299</i>&nbsp;
<i>300</i>&nbsp;        @Override
<i>301</i>&nbsp;        void addFreeVars(ClassSymbol c) {
<i>302</i>&nbsp;            List&lt;VarSymbol&gt; fvs = freevarCache.get(c);
<b class="nc"><i>303</i>&nbsp;            if (fvs != null) {</b>
<b class="nc"><i>304</i>&nbsp;                for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>305</i>&nbsp;                    addFreeVar(l.head);</b>
<b class="nc"><i>306</i>&nbsp;                }</b>
<b class="nc"><i>307</i>&nbsp;            }</b>
<b class="nc"><i>308</i>&nbsp;        }</b>
<b class="nc"><i>309</i>&nbsp;</b>
<b class="nc"><i>310</i>&nbsp;        @Override</b>
<i>311</i>&nbsp;        void visitSymbol(Symbol _sym) {
<b class="nc"><i>312</i>&nbsp;            Symbol sym = _sym;</b>
<b class="nc"><i>313</i>&nbsp;            if (sym.kind == VAR || sym.kind == MTH) {</b>
<i>314</i>&nbsp;                if (sym != null &amp;&amp; sym.owner != owner)
<b class="nc"><i>315</i>&nbsp;                    sym = proxies.get(sym);</b>
<i>316</i>&nbsp;                if (sym != null &amp;&amp; sym.owner == owner) {
<i>317</i>&nbsp;                    VarSymbol v = (VarSymbol)sym;
<i>318</i>&nbsp;                    if (v.getConstValue() == null) {
<i>319</i>&nbsp;                        addFreeVar(v);
<i>320</i>&nbsp;                    }
<i>321</i>&nbsp;                } else {
<i>322</i>&nbsp;                    if (outerThisStack.head != null &amp;&amp;
<i>323</i>&nbsp;                        outerThisStack.head != _sym)
<b class="nc"><i>324</i>&nbsp;                        visitSymbol(outerThisStack.head);</b>
<b class="nc"><i>325</i>&nbsp;                }</b>
<b class="nc"><i>326</i>&nbsp;            }</b>
<i>327</i>&nbsp;        }
<b class="nc"><i>328</i>&nbsp;</b>
<b class="nc"><i>329</i>&nbsp;        /** If tree refers to a class instance creation expression</b>
<i>330</i>&nbsp;         *  add all free variables of the freshly created class.
<i>331</i>&nbsp;         */
<i>332</i>&nbsp;        public void visitNewClass(JCNewClass tree) {
<i>333</i>&nbsp;            ClassSymbol c = (ClassSymbol)tree.constructor.owner;
<i>334</i>&nbsp;            if (tree.encl == null &amp;&amp;
<i>335</i>&nbsp;                c.hasOuterInstance() &amp;&amp;
<i>336</i>&nbsp;                outerThisStack.head != null)
<b class="nc"><i>337</i>&nbsp;                visitSymbol(outerThisStack.head);</b>
<i>338</i>&nbsp;            super.visitNewClass(tree);
<i>339</i>&nbsp;        }
<b class="nc"><i>340</i>&nbsp;</b>
<b class="nc"><i>341</i>&nbsp;        /** If tree refers to a qualified this or super expression</b>
<i>342</i>&nbsp;         *  for anything but the current class, add the outer this
<i>343</i>&nbsp;         *  stack as a free variable.
<i>344</i>&nbsp;         */
<i>345</i>&nbsp;        public void visitSelect(JCFieldAccess tree) {
<i>346</i>&nbsp;            if ((tree.name == names._this || tree.name == names._super) &amp;&amp;
<i>347</i>&nbsp;                tree.selected.type.tsym != clazz &amp;&amp;
<b class="nc"><i>348</i>&nbsp;                outerThisStack.head != null)</b>
<b class="nc"><i>349</i>&nbsp;                visitSymbol(outerThisStack.head);</b>
<b class="nc"><i>350</i>&nbsp;            super.visitSelect(tree);</b>
<b class="nc"><i>351</i>&nbsp;        }</b>
<b class="nc"><i>352</i>&nbsp;</b>
<i>353</i>&nbsp;        /** If tree refers to a superclass constructor call,
<b class="nc"><i>354</i>&nbsp;         *  add all free variables of the superclass.</b>
<i>355</i>&nbsp;         */
<b class="nc"><i>356</i>&nbsp;        public void visitApply(JCMethodInvocation tree) {</b>
<i>357</i>&nbsp;            if (TreeInfo.name(tree.meth) == names._super) {
<i>358</i>&nbsp;                Symbol constructor = TreeInfo.symbol(tree.meth);
<i>359</i>&nbsp;                ClassSymbol c = (ClassSymbol)constructor.owner;
<i>360</i>&nbsp;                if (c.hasOuterInstance() &amp;&amp;
<b class="nc"><i>361</i>&nbsp;                    !tree.meth.hasTag(SELECT) &amp;&amp;</b>
<b class="nc"><i>362</i>&nbsp;                    outerThisStack.head != null)</b>
<i>363</i>&nbsp;                    visitSymbol(outerThisStack.head);
<b class="nc"><i>364</i>&nbsp;            }</b>
<b class="nc"><i>365</i>&nbsp;            super.visitApply(tree);</b>
<b class="nc"><i>366</i>&nbsp;        }</b>
<i>367</i>&nbsp;    }
<b class="nc"><i>368</i>&nbsp;</b>
<b class="nc"><i>369</i>&nbsp;    ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {</b>
<i>370</i>&nbsp;        if (!c.isLocal()) {
<b class="nc"><i>371</i>&nbsp;            return null;</b>
<i>372</i>&nbsp;        }
<i>373</i>&nbsp;        Symbol currentOwner = c.owner;
<i>374</i>&nbsp;        while (currentOwner.owner.kind.matches(KindSelector.TYP) &amp;&amp; currentOwner.isLocal()) {
<i>375</i>&nbsp;            currentOwner = currentOwner.owner;
<i>376</i>&nbsp;        }
<i>377</i>&nbsp;        if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp; c.isSubClass(currentOwner, types)) {
<i>378</i>&nbsp;            return (ClassSymbol)currentOwner;
<b class="nc"><i>379</i>&nbsp;        }</b>
<b class="nc"><i>380</i>&nbsp;        return null;</b>
<b class="nc"><i>381</i>&nbsp;    }</b>
<i>382</i>&nbsp;
<b class="nc"><i>383</i>&nbsp;    /** Return the variables accessed from within a local class, which</b>
<b class="nc"><i>384</i>&nbsp;     *  are declared in the local class&#39; owner.</b>
<b class="nc"><i>385</i>&nbsp;     *  (in reverse order of first access).</b>
<b class="nc"><i>386</i>&nbsp;     */</b>
<b class="nc"><i>387</i>&nbsp;    List&lt;VarSymbol&gt; freevars(ClassSymbol c)  {</b>
<b class="nc"><i>388</i>&nbsp;        List&lt;VarSymbol&gt; fvs = freevarCache.get(c);</b>
<i>389</i>&nbsp;        if (fvs != null) {
<b class="nc"><i>390</i>&nbsp;            return fvs;</b>
<b class="nc"><i>391</i>&nbsp;        }</b>
<b class="nc"><i>392</i>&nbsp;        if (c.owner.kind.matches(KindSelector.VAL_MTH)) {</b>
<b class="nc"><i>393</i>&nbsp;            FreeVarCollector collector = new FreeVarCollector(c);</b>
<b class="nc"><i>394</i>&nbsp;            collector.scan(classDef(c));</b>
<i>395</i>&nbsp;            fvs = collector.fvs;
<b class="nc"><i>396</i>&nbsp;            freevarCache.put(c, fvs);</b>
<i>397</i>&nbsp;            return fvs;
<i>398</i>&nbsp;        } else {
<i>399</i>&nbsp;            ClassSymbol owner = ownerToCopyFreeVarsFrom(c);
<i>400</i>&nbsp;            if (owner != null) {
<b class="nc"><i>401</i>&nbsp;                fvs = freevarCache.get(owner);</b>
<i>402</i>&nbsp;                freevarCache.put(c, fvs);
<i>403</i>&nbsp;                return fvs;
<b class="nc"><i>404</i>&nbsp;            } else {</b>
<b class="nc"><i>405</i>&nbsp;                return List.nil();</b>
<b class="nc"><i>406</i>&nbsp;            }</b>
<b class="nc"><i>407</i>&nbsp;        }</b>
<i>408</i>&nbsp;    }
<i>409</i>&nbsp;
<i>410</i>&nbsp;    Map&lt;TypeSymbol,EnumMapping&gt; enumSwitchMap = new LinkedHashMap&lt;&gt;();
<i>411</i>&nbsp;
<i>412</i>&nbsp;    EnumMapping mapForEnum(DiagnosticPosition pos, TypeSymbol enumClass) {
<i>413</i>&nbsp;        EnumMapping map = enumSwitchMap.get(enumClass);
<i>414</i>&nbsp;        if (map == null)
<i>415</i>&nbsp;            enumSwitchMap.put(enumClass, map = new EnumMapping(pos, enumClass));
<i>416</i>&nbsp;        return map;
<i>417</i>&nbsp;    }
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /** This map gives a translation table to be used for enum
<i>420</i>&nbsp;     *  switches.
<i>421</i>&nbsp;     *
<i>422</i>&nbsp;     *  &lt;p&gt;For each enum that appears as the type of a switch
<i>423</i>&nbsp;     *  expression, we maintain an EnumMapping to assist in the
<i>424</i>&nbsp;     *  translation, as exemplified by the following example:
<i>425</i>&nbsp;     *
<i>426</i>&nbsp;     *  &lt;p&gt;we translate
<i>427</i>&nbsp;     *  &lt;pre&gt;
<i>428</i>&nbsp;     *          switch(colorExpression) {
<i>429</i>&nbsp;     *          case red: stmt1;
<i>430</i>&nbsp;     *          case green: stmt2;
<i>431</i>&nbsp;     *          }
<i>432</i>&nbsp;     *  &lt;/pre&gt;
<i>433</i>&nbsp;     *  into
<i>434</i>&nbsp;     *  &lt;pre&gt;
<i>435</i>&nbsp;     *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
<i>436</i>&nbsp;     *          case 1: stmt1;
<i>437</i>&nbsp;     *          case 2: stmt2
<i>438</i>&nbsp;     *          }
<i>439</i>&nbsp;     *  &lt;/pre&gt;
<i>440</i>&nbsp;     *  with the auxiliary table initialized as follows:
<i>441</i>&nbsp;     *  &lt;pre&gt;
<i>442</i>&nbsp;     *          class Outer$0 {
<i>443</i>&nbsp;     *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
<b class="nc"><i>444</i>&nbsp;     *              static {</b>
<b class="nc"><i>445</i>&nbsp;     *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}</b>
<b class="nc"><i>446</i>&nbsp;     *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}</b>
<b class="nc"><i>447</i>&nbsp;     *              }</b>
<b class="nc"><i>448</i>&nbsp;     *          }</b>
<b class="nc"><i>449</i>&nbsp;     *  &lt;/pre&gt;</b>
<i>450</i>&nbsp;     *  class EnumMapping provides mapping data and support methods for this translation.
<b class="nc"><i>451</i>&nbsp;     */</b>
<b class="nc"><i>452</i>&nbsp;    class EnumMapping {</b>
<b class="nc"><i>453</i>&nbsp;        EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {</b>
<b class="nc"><i>454</i>&nbsp;            this.forEnum = forEnum;</b>
<b class="nc"><i>455</i>&nbsp;            this.values = new LinkedHashMap&lt;&gt;();</b>
<b class="nc"><i>456</i>&nbsp;            this.pos = pos;</b>
<i>457</i>&nbsp;            Name varName = names
<b class="nc"><i>458</i>&nbsp;                .fromString(target.syntheticNameChar() +</b>
<i>459</i>&nbsp;                            &quot;SwitchMap&quot; +
<b class="nc"><i>460</i>&nbsp;                            target.syntheticNameChar() +</b>
<i>461</i>&nbsp;                            writer.xClassName(forEnum.type).toString()
<i>462</i>&nbsp;                            .replace(&#39;/&#39;, &#39;.&#39;)
<b class="nc"><i>463</i>&nbsp;                            .replace(&#39;.&#39;, target.syntheticNameChar()));</b>
<i>464</i>&nbsp;            ClassSymbol outerCacheClass = outerCacheClass();
<i>465</i>&nbsp;            this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
<b class="nc"><i>466</i>&nbsp;                                        varName,</b>
<i>467</i>&nbsp;                                        new ArrayType(syms.intType, syms.arrayClass),
<i>468</i>&nbsp;                                        outerCacheClass);
<i>469</i>&nbsp;            enterSynthetic(pos, mapVar, outerCacheClass.members());
<i>470</i>&nbsp;        }
<i>471</i>&nbsp;
<i>472</i>&nbsp;        DiagnosticPosition pos = null;
<i>473</i>&nbsp;
<i>474</i>&nbsp;        // the next value to use
<i>475</i>&nbsp;        int next = 1; // 0 (unused map elements) go to the default label
<i>476</i>&nbsp;
<i>477</i>&nbsp;        // the enum for which this is a map
<b class="nc"><i>478</i>&nbsp;        final TypeSymbol forEnum;</b>
<b class="nc"><i>479</i>&nbsp;</b>
<b class="nc"><i>480</i>&nbsp;        // the field containing the map</b>
<b class="nc"><i>481</i>&nbsp;        final VarSymbol mapVar;</b>
<i>482</i>&nbsp;
<i>483</i>&nbsp;        // the mapped values
<i>484</i>&nbsp;        final Map&lt;VarSymbol,Integer&gt; values;
<i>485</i>&nbsp;
<b class="nc"><i>486</i>&nbsp;        JCLiteral forConstant(VarSymbol v) {</b>
<b class="nc"><i>487</i>&nbsp;            Integer result = values.get(v);</b>
<i>488</i>&nbsp;            if (result == null)
<i>489</i>&nbsp;                values.put(v, result = next++);
<b class="nc"><i>490</i>&nbsp;            return make.Literal(result);</b>
<b class="nc"><i>491</i>&nbsp;        }</b>
<i>492</i>&nbsp;
<b class="nc"><i>493</i>&nbsp;        // generate the field initializer for the map</b>
<b class="nc"><i>494</i>&nbsp;        void translate() {</b>
<b class="nc"><i>495</i>&nbsp;            make.at(pos.getStartPosition());</b>
<b class="nc"><i>496</i>&nbsp;            JCClassDecl owner = classDef((ClassSymbol)mapVar.owner);</b>
<b class="nc"><i>497</i>&nbsp;</b>
<b class="nc"><i>498</i>&nbsp;            // synthetic static final int[] $SwitchMap$Color = new int[Color.values().length];</b>
<b class="nc"><i>499</i>&nbsp;            MethodSymbol valuesMethod = lookupMethod(pos,</b>
<i>500</i>&nbsp;                                                     names.values,
<i>501</i>&nbsp;                                                     forEnum.type,
<b class="nc"><i>502</i>&nbsp;                                                     List.nil());</b>
<b class="nc"><i>503</i>&nbsp;            JCExpression size = make // Color.values().length</b>
<b class="nc"><i>504</i>&nbsp;                .Select(make.App(make.QualIdent(valuesMethod)),</b>
<i>505</i>&nbsp;                        syms.lengthVar);
<b class="nc"><i>506</i>&nbsp;            JCExpression mapVarInit = make</b>
<b class="nc"><i>507</i>&nbsp;                .NewArray(make.Type(syms.intType), List.of(size), null)</b>
<b class="nc"><i>508</i>&nbsp;                .setType(new ArrayType(syms.intType, syms.arrayClass));</b>
<b class="nc"><i>509</i>&nbsp;</b>
<b class="nc"><i>510</i>&nbsp;            // try { $SwitchMap$Color[red.ordinal()] = 1; } catch (java.lang.NoSuchFieldError ex) {}</b>
<i>511</i>&nbsp;            ListBuffer&lt;JCStatement&gt; stmts = new ListBuffer&lt;&gt;();
<b class="nc"><i>512</i>&nbsp;            Symbol ordinalMethod = lookupMethod(pos,</b>
<b class="nc"><i>513</i>&nbsp;                                                names.ordinal,</b>
<b class="nc"><i>514</i>&nbsp;                                                forEnum.type,</b>
<b class="nc"><i>515</i>&nbsp;                                                List.nil());</b>
<b class="nc"><i>516</i>&nbsp;            List&lt;JCCatch&gt; catcher = List.&lt;JCCatch&gt;nil()</b>
<b class="nc"><i>517</i>&nbsp;                .prepend(make.Catch(make.VarDef(new VarSymbol(PARAMETER, names.ex,</b>
<b class="nc"><i>518</i>&nbsp;                                                              syms.noSuchFieldErrorType,</b>
<i>519</i>&nbsp;                                                              syms.noSymbol),
<b class="nc"><i>520</i>&nbsp;                                                null),</b>
<b class="nc"><i>521</i>&nbsp;                                    make.Block(0, List.nil())));</b>
<b class="nc"><i>522</i>&nbsp;            for (Map.Entry&lt;VarSymbol,Integer&gt; e : values.entrySet()) {</b>
<b class="nc"><i>523</i>&nbsp;                VarSymbol enumerator = e.getKey();</b>
<b class="nc"><i>524</i>&nbsp;                Integer mappedValue = e.getValue();</b>
<b class="nc"><i>525</i>&nbsp;                JCExpression assign = make</b>
<i>526</i>&nbsp;                    .Assign(make.Indexed(mapVar,
<b class="nc"><i>527</i>&nbsp;                                         make.App(make.Select(make.QualIdent(enumerator),</b>
<b class="nc"><i>528</i>&nbsp;                                                              ordinalMethod))),</b>
<b class="nc"><i>529</i>&nbsp;                            make.Literal(mappedValue))</b>
<i>530</i>&nbsp;                    .setType(syms.intType);
<i>531</i>&nbsp;                JCStatement exec = make.Exec(assign);
<i>532</i>&nbsp;                JCStatement _try = make.Try(make.Block(0, List.of(exec)), catcher, null);
<i>533</i>&nbsp;                stmts.append(_try);
<i>534</i>&nbsp;            }
<i>535</i>&nbsp;
<i>536</i>&nbsp;            owner.defs = owner.defs
<i>537</i>&nbsp;                .prepend(make.Block(STATIC, stmts.toList()))
<i>538</i>&nbsp;                .prepend(make.VarDef(mapVar, mapVarInit));
<i>539</i>&nbsp;        }
<i>540</i>&nbsp;    }
<i>541</i>&nbsp;
<b class="nc"><i>542</i>&nbsp;</b>
<b class="nc"><i>543</i>&nbsp;/**************************************************************************</b>
<i>544</i>&nbsp; * Tree building blocks
<i>545</i>&nbsp; *************************************************************************/
<i>546</i>&nbsp;
<i>547</i>&nbsp;    /** Equivalent to make.at(pos.getStartPosition()) with side effect of caching
<i>548</i>&nbsp;     *  pos as make_pos, for use in diagnostics.
<i>549</i>&nbsp;     **/
<i>550</i>&nbsp;    TreeMaker make_at(DiagnosticPosition pos) {
<i>551</i>&nbsp;        make_pos = pos;
<i>552</i>&nbsp;        return make.at(pos);
<b class="nc"><i>553</i>&nbsp;    }</b>
<i>554</i>&nbsp;
<i>555</i>&nbsp;    /** Make an attributed tree representing a literal. This will be an
<i>556</i>&nbsp;     *  Ident node in the case of boolean literals, a Literal node in all
<i>557</i>&nbsp;     *  other cases.
<i>558</i>&nbsp;     *  @param type       The literal&#39;s type.
<b class="nc"><i>559</i>&nbsp;     *  @param value      The literal&#39;s value.</b>
<i>560</i>&nbsp;     */
<i>561</i>&nbsp;    JCExpression makeLit(Type type, Object value) {
<i>562</i>&nbsp;        return make.Literal(type.getTag(), value).setType(type.constType(value));
<i>563</i>&nbsp;    }
<i>564</i>&nbsp;
<i>565</i>&nbsp;    /** Make an attributed tree representing null.
<i>566</i>&nbsp;     */
<b class="nc"><i>567</i>&nbsp;    JCExpression makeNull() {</b>
<b class="nc"><i>568</i>&nbsp;        return makeLit(syms.botType, null);</b>
<b class="nc"><i>569</i>&nbsp;    }</b>
<b class="nc"><i>570</i>&nbsp;</b>
<b class="nc"><i>571</i>&nbsp;    /** Make an attributed class instance creation expression.</b>
<b class="nc"><i>572</i>&nbsp;     *  @param ctype    The class type.</b>
<i>573</i>&nbsp;     *  @param args     The constructor arguments.
<i>574</i>&nbsp;     */
<i>575</i>&nbsp;    JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
<i>576</i>&nbsp;        JCNewClass tree = make.NewClass(null,
<i>577</i>&nbsp;            null, make.QualIdent(ctype.tsym), args, null);
<i>578</i>&nbsp;        tree.constructor = rs.resolveConstructor(
<i>579</i>&nbsp;            make_pos, attrEnv, ctype, TreeInfo.types(args), List.nil());
<b class="nc"><i>580</i>&nbsp;        tree.type = ctype;</b>
<b class="nc"><i>581</i>&nbsp;        return tree;</b>
<i>582</i>&nbsp;    }
<b class="nc"><i>583</i>&nbsp;</b>
<b class="nc"><i>584</i>&nbsp;    /** Make an attributed unary expression.</b>
<i>585</i>&nbsp;     *  @param optag    The operators tree tag.
<i>586</i>&nbsp;     *  @param arg      The operator&#39;s argument.
<i>587</i>&nbsp;     */
<i>588</i>&nbsp;    JCUnary makeUnary(JCTree.Tag optag, JCExpression arg) {
<i>589</i>&nbsp;        JCUnary tree = make.Unary(optag, arg);
<i>590</i>&nbsp;        tree.operator = operators.resolveUnary(tree, optag, arg.type);
<i>591</i>&nbsp;        tree.type = tree.operator.type.getReturnType();
<i>592</i>&nbsp;        return tree;
<b class="nc"><i>593</i>&nbsp;    }</b>
<b class="nc"><i>594</i>&nbsp;</b>
<i>595</i>&nbsp;    /** Make an attributed binary expression.
<b class="nc"><i>596</i>&nbsp;     *  @param optag    The operators tree tag.</b>
<b class="nc"><i>597</i>&nbsp;     *  @param lhs      The operator&#39;s left argument.</b>
<i>598</i>&nbsp;     *  @param rhs      The operator&#39;s right argument.
<i>599</i>&nbsp;     */
<i>600</i>&nbsp;    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
<i>601</i>&nbsp;        JCBinary tree = make.Binary(optag, lhs, rhs);
<i>602</i>&nbsp;        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
<i>603</i>&nbsp;        tree.type = tree.operator.type.getReturnType();
<i>604</i>&nbsp;        return tree;
<i>605</i>&nbsp;    }
<b class="nc"><i>606</i>&nbsp;</b>
<b class="nc"><i>607</i>&nbsp;    /** Make an attributed assignop expression.</b>
<b class="nc"><i>608</i>&nbsp;     *  @param optag    The operators tree tag.</b>
<b class="nc"><i>609</i>&nbsp;     *  @param lhs      The operator&#39;s left argument.</b>
<b class="nc"><i>610</i>&nbsp;     *  @param rhs      The operator&#39;s right argument.</b>
<i>611</i>&nbsp;     */
<i>612</i>&nbsp;    JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
<i>613</i>&nbsp;        JCAssignOp tree = make.Assignop(optag, lhs, rhs);
<i>614</i>&nbsp;        tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
<i>615</i>&nbsp;        tree.type = lhs.type;
<i>616</i>&nbsp;        return tree;
<b class="nc"><i>617</i>&nbsp;    }</b>
<b class="nc"><i>618</i>&nbsp;</b>
<i>619</i>&nbsp;    /** Convert tree into string object, unless it has already a
<b class="nc"><i>620</i>&nbsp;     *  reference type..</b>
<i>621</i>&nbsp;     */
<i>622</i>&nbsp;    JCExpression makeString(JCExpression tree) {
<b class="nc"><i>623</i>&nbsp;        if (!tree.type.isPrimitiveOrVoid()) {</b>
<b class="nc"><i>624</i>&nbsp;            return tree;</b>
<i>625</i>&nbsp;        } else {
<i>626</i>&nbsp;            Symbol valueOfSym = lookupMethod(tree.pos(),
<i>627</i>&nbsp;                                             names.valueOf,
<i>628</i>&nbsp;                                             syms.stringType,
<i>629</i>&nbsp;                                             List.of(tree.type));
<i>630</i>&nbsp;            return make.App(make.QualIdent(valueOfSym), List.of(tree));
<i>631</i>&nbsp;        }
<i>632</i>&nbsp;    }
<i>633</i>&nbsp;
<i>634</i>&nbsp;    /** Create an empty anonymous class definition and enter and complete
<b class="nc"><i>635</i>&nbsp;     *  its symbol. Return the class definition&#39;s symbol.</b>
<i>636</i>&nbsp;     *  and create
<i>637</i>&nbsp;     *  @param flags    The class symbol&#39;s flags
<i>638</i>&nbsp;     *  @param owner    The class symbol&#39;s owner
<i>639</i>&nbsp;     */
<i>640</i>&nbsp;    JCClassDecl makeEmptyClass(long flags, ClassSymbol owner) {
<b class="nc"><i>641</i>&nbsp;        return makeEmptyClass(flags, owner, null, true);</b>
<b class="nc"><i>642</i>&nbsp;    }</b>
<b class="nc"><i>643</i>&nbsp;</b>
<i>644</i>&nbsp;    JCClassDecl makeEmptyClass(long flags, ClassSymbol owner, Name flatname,
<b class="nc"><i>645</i>&nbsp;            boolean addToDefs) {</b>
<i>646</i>&nbsp;        // Create class symbol.
<b class="nc"><i>647</i>&nbsp;        ClassSymbol c = syms.defineClass(names.empty, owner);</b>
<b class="nc"><i>648</i>&nbsp;        if (flatname != null) {</b>
<b class="nc"><i>649</i>&nbsp;            c.flatname = flatname;</b>
<b class="nc"><i>650</i>&nbsp;        } else {</b>
<b class="nc"><i>651</i>&nbsp;            c.flatname = chk.localClassName(c);</b>
<b class="nc"><i>652</i>&nbsp;        }</b>
<b class="nc"><i>653</i>&nbsp;        c.sourcefile = owner.sourcefile;</b>
<i>654</i>&nbsp;        c.completer = Completer.NULL_COMPLETER;
<b class="nc"><i>655</i>&nbsp;        c.members_field = WriteableScope.create(c);</b>
<i>656</i>&nbsp;        c.flags_field = flags;
<i>657</i>&nbsp;        ClassType ctype = (ClassType) c.type;
<b class="nc"><i>658</i>&nbsp;        ctype.supertype_field = syms.objectType;</b>
<b class="nc"><i>659</i>&nbsp;        ctype.interfaces_field = List.nil();</b>
<i>660</i>&nbsp;
<i>661</i>&nbsp;        JCClassDecl odef = classDef(owner);
<b class="nc"><i>662</i>&nbsp;</b>
<b class="nc"><i>663</i>&nbsp;        // Enter class symbol in owner scope and compiled table.</b>
<b class="nc"><i>664</i>&nbsp;        enterSynthetic(odef.pos(), c, owner.members());</b>
<b class="nc"><i>665</i>&nbsp;        chk.putCompiled(c);</b>
<b class="nc"><i>666</i>&nbsp;</b>
<b class="nc"><i>667</i>&nbsp;        // Create class definition tree.</b>
<i>668</i>&nbsp;        JCClassDecl cdef = make.ClassDef(
<i>669</i>&nbsp;            make.Modifiers(flags), names.empty,
<b class="nc"><i>670</i>&nbsp;            List.nil(),</b>
<b class="nc"><i>671</i>&nbsp;            null, List.nil(), List.nil());</b>
<i>672</i>&nbsp;        cdef.sym = c;
<i>673</i>&nbsp;        cdef.type = c.type;
<i>674</i>&nbsp;
<i>675</i>&nbsp;        // Append class definition tree to owner&#39;s definitions.
<i>676</i>&nbsp;        if (addToDefs) odef.defs = odef.defs.prepend(cdef);
<i>677</i>&nbsp;        return cdef;
<i>678</i>&nbsp;    }
<i>679</i>&nbsp;
<i>680</i>&nbsp;/**************************************************************************
<i>681</i>&nbsp; * Symbol manipulation utilities
<i>682</i>&nbsp; *************************************************************************/
<i>683</i>&nbsp;
<b class="nc"><i>684</i>&nbsp;    /** Enter a synthetic symbol in a given scope, but complain if there was already one there.</b>
<i>685</i>&nbsp;     *  @param pos           Position for error reporting.
<i>686</i>&nbsp;     *  @param sym           The symbol.
<i>687</i>&nbsp;     *  @param s             The scope.
<i>688</i>&nbsp;     */
<i>689</i>&nbsp;    private void enterSynthetic(DiagnosticPosition pos, Symbol sym, WriteableScope s) {
<i>690</i>&nbsp;        s.enter(sym);
<i>691</i>&nbsp;    }
<i>692</i>&nbsp;
<i>693</i>&nbsp;    /** Create a fresh synthetic name within a given scope - the unique name is
<i>694</i>&nbsp;     *  obtained by appending &#39;$&#39; chars at the end of the name until no match
<i>695</i>&nbsp;     *  is found.
<i>696</i>&nbsp;     *
<b class="nc"><i>697</i>&nbsp;     * @param name base name</b>
<b class="nc"><i>698</i>&nbsp;     * @param s scope in which the name has to be unique</b>
<i>699</i>&nbsp;     * @return fresh synthetic name
<b class="nc"><i>700</i>&nbsp;     */</b>
<b class="nc"><i>701</i>&nbsp;    private Name makeSyntheticName(Name name, Scope s) {</b>
<i>702</i>&nbsp;        do {
<i>703</i>&nbsp;            name = name.append(
<i>704</i>&nbsp;                    target.syntheticNameChar(),
<i>705</i>&nbsp;                    names.empty);
<i>706</i>&nbsp;        } while (lookupSynthetic(name, s) != null);
<i>707</i>&nbsp;        return name;
<i>708</i>&nbsp;    }
<i>709</i>&nbsp;
<b class="nc"><i>710</i>&nbsp;    /** Check whether synthetic symbols generated during lowering conflict</b>
<b class="nc"><i>711</i>&nbsp;     *  with user-defined symbols.</b>
<b class="nc"><i>712</i>&nbsp;     *</b>
<i>713</i>&nbsp;     *  @param translatedTrees lowered class trees
<i>714</i>&nbsp;     */
<b class="nc"><i>715</i>&nbsp;    void checkConflicts(List&lt;JCTree&gt; translatedTrees) {</b>
<i>716</i>&nbsp;        for (JCTree t : translatedTrees) {
<i>717</i>&nbsp;            t.accept(conflictsChecker);
<i>718</i>&nbsp;        }
<i>719</i>&nbsp;    }
<i>720</i>&nbsp;
<b class="nc"><i>721</i>&nbsp;    JCTree.Visitor conflictsChecker = new TreeScanner() {</b>
<b class="nc"><i>722</i>&nbsp;</b>
<i>723</i>&nbsp;        TypeSymbol currentClass;
<i>724</i>&nbsp;
<i>725</i>&nbsp;        @Override
<i>726</i>&nbsp;        public void visitMethodDef(JCMethodDecl that) {
<b class="nc"><i>727</i>&nbsp;            checkConflicts(that.pos(), that.sym, currentClass);</b>
<b class="nc"><i>728</i>&nbsp;            super.visitMethodDef(that);</b>
<i>729</i>&nbsp;        }
<b class="nc"><i>730</i>&nbsp;</b>
<i>731</i>&nbsp;        @Override
<i>732</i>&nbsp;        public void visitVarDef(JCVariableDecl that) {
<i>733</i>&nbsp;            if (that.sym.owner.kind == TYP) {
<i>734</i>&nbsp;                checkConflicts(that.pos(), that.sym, currentClass);
<b class="nc"><i>735</i>&nbsp;            }</b>
<b class="nc"><i>736</i>&nbsp;            super.visitVarDef(that);</b>
<i>737</i>&nbsp;        }
<b class="nc"><i>738</i>&nbsp;</b>
<i>739</i>&nbsp;        @Override
<i>740</i>&nbsp;        public void visitClassDef(JCClassDecl that) {
<b class="nc"><i>741</i>&nbsp;            TypeSymbol prevCurrentClass = currentClass;</b>
<b class="nc"><i>742</i>&nbsp;            currentClass = that.sym;</b>
<i>743</i>&nbsp;            try {
<i>744</i>&nbsp;                super.visitClassDef(that);
<i>745</i>&nbsp;            }
<i>746</i>&nbsp;            finally {
<i>747</i>&nbsp;                currentClass = prevCurrentClass;
<i>748</i>&nbsp;            }
<i>749</i>&nbsp;        }
<i>750</i>&nbsp;
<b class="nc"><i>751</i>&nbsp;        void checkConflicts(DiagnosticPosition pos, Symbol sym, TypeSymbol c) {</b>
<b class="nc"><i>752</i>&nbsp;            for (Type ct = c.type; ct != Type.noType ; ct = types.supertype(ct)) {</b>
<i>753</i>&nbsp;                for (Symbol sym2 : ct.tsym.members().getSymbolsByName(sym.name, NON_RECURSIVE)) {
<i>754</i>&nbsp;                    // VM allows methods and variables with differing types
<i>755</i>&nbsp;                    if (sym.kind == sym2.kind &amp;&amp;
<i>756</i>&nbsp;                        types.isSameType(types.erasure(sym.type), types.erasure(sym2.type)) &amp;&amp;
<i>757</i>&nbsp;                        sym != sym2 &amp;&amp;
<b class="nc"><i>758</i>&nbsp;                        (sym.flags() &amp; Flags.SYNTHETIC) != (sym2.flags() &amp; Flags.SYNTHETIC) &amp;&amp;</b>
<i>759</i>&nbsp;                        (sym.flags() &amp; BRIDGE) == 0 &amp;&amp; (sym2.flags() &amp; BRIDGE) == 0) {
<i>760</i>&nbsp;                        syntheticError(pos, (sym2.flags() &amp; SYNTHETIC) == 0 ? sym2 : sym);
<i>761</i>&nbsp;                        return;
<i>762</i>&nbsp;                    }
<i>763</i>&nbsp;                }
<b class="nc"><i>764</i>&nbsp;            }</b>
<i>765</i>&nbsp;        }
<i>766</i>&nbsp;
<i>767</i>&nbsp;        /** Report a conflict between a user symbol and a synthetic symbol.
<i>768</i>&nbsp;         */
<i>769</i>&nbsp;        private void syntheticError(DiagnosticPosition pos, Symbol sym) {
<b class="nc"><i>770</i>&nbsp;            if (!sym.type.isErroneous()) {</b>
<i>771</i>&nbsp;                log.error(pos, Errors.CannotGenerateClass(sym.location(), Fragments.SyntheticNameConflict(sym, sym.location())));
<i>772</i>&nbsp;            }
<i>773</i>&nbsp;        }
<i>774</i>&nbsp;    };
<i>775</i>&nbsp;
<i>776</i>&nbsp;    /** Look up a synthetic name in a given scope.
<i>777</i>&nbsp;     *  @param s            The scope.
<i>778</i>&nbsp;     *  @param name         The name.
<i>779</i>&nbsp;     */
<i>780</i>&nbsp;    private Symbol lookupSynthetic(Name name, Scope s) {
<b class="nc"><i>781</i>&nbsp;        Symbol sym = s.findFirst(name);</b>
<b class="nc"><i>782</i>&nbsp;        return (sym==null || (sym.flags()&amp;SYNTHETIC)==0) ? null : sym;</b>
<b class="nc"><i>783</i>&nbsp;    }</b>
<b class="nc"><i>784</i>&nbsp;</b>
<i>785</i>&nbsp;    /** Look up a method in a given scope.
<b class="nc"><i>786</i>&nbsp;     */</b>
<b class="nc"><i>787</i>&nbsp;    private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List&lt;Type&gt; args) {</b>
<b class="nc"><i>788</i>&nbsp;        return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());</b>
<b class="nc"><i>789</i>&nbsp;    }</b>
<i>790</i>&nbsp;
<i>791</i>&nbsp;    /** Anon inner classes are used as access constructor tags.
<i>792</i>&nbsp;     * accessConstructorTag will use an existing anon class if one is available,
<i>793</i>&nbsp;     * and synthethise a class (with makeEmptyClass) if one is not available.
<b class="nc"><i>794</i>&nbsp;     * However, there is a small possibility that an existing class will not</b>
<b class="nc"><i>795</i>&nbsp;     * be generated as expected if it is inside a conditional with a constant</b>
<i>796</i>&nbsp;     * expression. If that is found to be the case, create an empty class tree here.
<b class="nc"><i>797</i>&nbsp;     */</b>
<i>798</i>&nbsp;    private void checkAccessConstructorTags() {
<b class="nc"><i>799</i>&nbsp;        for (List&lt;ClassSymbol&gt; l = accessConstrTags; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>800</i>&nbsp;            ClassSymbol c = l.head;</b>
<i>801</i>&nbsp;            if (isTranslatedClassAvailable(c))
<i>802</i>&nbsp;                continue;
<i>803</i>&nbsp;            // Create class definition tree.
<b class="nc"><i>804</i>&nbsp;            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,</b>
<b class="nc"><i>805</i>&nbsp;                    c.outermostClass(), c.flatname, false);</b>
<b class="nc"><i>806</i>&nbsp;            swapAccessConstructorTag(c, cdec.sym);</b>
<i>807</i>&nbsp;            translated.append(cdec);
<b class="nc"><i>808</i>&nbsp;        }</b>
<b class="nc"><i>809</i>&nbsp;    }</b>
<b class="nc"><i>810</i>&nbsp;    // where</b>
<b class="nc"><i>811</i>&nbsp;    private boolean isTranslatedClassAvailable(ClassSymbol c) {</b>
<b class="nc"><i>812</i>&nbsp;        for (JCTree tree: translated) {</b>
<b class="nc"><i>813</i>&nbsp;            if (tree.hasTag(CLASSDEF)</b>
<i>814</i>&nbsp;                    &amp;&amp; ((JCClassDecl) tree).sym == c) {
<i>815</i>&nbsp;                return true;
<i>816</i>&nbsp;            }
<i>817</i>&nbsp;        }
<i>818</i>&nbsp;        return false;
<i>819</i>&nbsp;    }
<i>820</i>&nbsp;
<i>821</i>&nbsp;    void swapAccessConstructorTag(ClassSymbol oldCTag, ClassSymbol newCTag) {
<i>822</i>&nbsp;        for (MethodSymbol methodSymbol : accessConstrs.values()) {
<i>823</i>&nbsp;            Assert.check(methodSymbol.type.hasTag(METHOD));
<i>824</i>&nbsp;            MethodType oldMethodType =
<i>825</i>&nbsp;                    (MethodType)methodSymbol.type;
<i>826</i>&nbsp;            if (oldMethodType.argtypes.head.tsym == oldCTag)
<i>827</i>&nbsp;                methodSymbol.type =
<i>828</i>&nbsp;                    types.createMethodTypeWithParameters(oldMethodType,
<i>829</i>&nbsp;                        oldMethodType.getParameterTypes().tail
<i>830</i>&nbsp;                            .prepend(newCTag.erasure(types)));
<i>831</i>&nbsp;        }
<i>832</i>&nbsp;    }
<i>833</i>&nbsp;
<i>834</i>&nbsp;/**************************************************************************
<i>835</i>&nbsp; * Access methods
<i>836</i>&nbsp; *************************************************************************/
<i>837</i>&nbsp;
<i>838</i>&nbsp;    /** A mapping from symbols to their access numbers.
<i>839</i>&nbsp;     */
<i>840</i>&nbsp;    private Map&lt;Symbol,Integer&gt; accessNums;
<i>841</i>&nbsp;
<i>842</i>&nbsp;    /** A mapping from symbols to an array of access symbols, indexed by
<i>843</i>&nbsp;     *  access code.
<i>844</i>&nbsp;     */
<b class="nc"><i>845</i>&nbsp;    private Map&lt;Symbol,MethodSymbol[]&gt; accessSyms;</b>
<i>846</i>&nbsp;
<i>847</i>&nbsp;    /** A mapping from (constructor) symbols to access constructor symbols.
<i>848</i>&nbsp;     */
<i>849</i>&nbsp;    private Map&lt;Symbol,MethodSymbol&gt; accessConstrs;
<i>850</i>&nbsp;
<i>851</i>&nbsp;    /** A list of all class symbols used for access constructor tags.
<i>852</i>&nbsp;     */
<i>853</i>&nbsp;    private List&lt;ClassSymbol&gt; accessConstrTags;
<i>854</i>&nbsp;
<i>855</i>&nbsp;    /** A queue for all accessed symbols.
<i>856</i>&nbsp;     */
<i>857</i>&nbsp;    private ListBuffer&lt;Symbol&gt; accessed;
<i>858</i>&nbsp;
<i>859</i>&nbsp;    /** return access code for identifier,
<i>860</i>&nbsp;     *  @param tree     The tree representing the identifier use.
<i>861</i>&nbsp;     *  @param enclOp   The closest enclosing operation node of tree,
<i>862</i>&nbsp;     *                  null if tree is not a subtree of an operation.
<i>863</i>&nbsp;     */
<i>864</i>&nbsp;    private static int accessCode(JCTree tree, JCTree enclOp) {
<i>865</i>&nbsp;        if (enclOp == null)
<i>866</i>&nbsp;            return AccessCode.DEREF.code;
<i>867</i>&nbsp;        else if (enclOp.hasTag(ASSIGN) &amp;&amp;
<i>868</i>&nbsp;                 tree == TreeInfo.skipParens(((JCAssign) enclOp).lhs))
<i>869</i>&nbsp;            return AccessCode.ASSIGN.code;
<i>870</i>&nbsp;        else if ((enclOp.getTag().isIncOrDecUnaryOp() || enclOp.getTag().isAssignop()) &amp;&amp;
<i>871</i>&nbsp;                tree == TreeInfo.skipParens(((JCOperatorExpression) enclOp).getOperand(LEFT)))
<b class="nc"><i>872</i>&nbsp;            return (((JCOperatorExpression) enclOp).operator).getAccessCode(enclOp.getTag());</b>
<b class="nc"><i>873</i>&nbsp;        else</b>
<b class="nc"><i>874</i>&nbsp;            return AccessCode.DEREF.code;</b>
<b class="nc"><i>875</i>&nbsp;    }</b>
<b class="nc"><i>876</i>&nbsp;</b>
<b class="nc"><i>877</i>&nbsp;    /** Return binary operator that corresponds to given access code.</b>
<i>878</i>&nbsp;     */
<b class="nc"><i>879</i>&nbsp;    private OperatorSymbol binaryAccessOperator(int acode, Tag tag) {</b>
<i>880</i>&nbsp;        return operators.lookupBinaryOp(op -&gt; op.getAccessCode(tag) == acode);
<i>881</i>&nbsp;    }
<i>882</i>&nbsp;
<i>883</i>&nbsp;    /** Return tree tag for assignment operation corresponding
<i>884</i>&nbsp;     *  to given binary operator.
<i>885</i>&nbsp;     */
<i>886</i>&nbsp;    private static JCTree.Tag treeTag(OperatorSymbol operator) {
<i>887</i>&nbsp;        switch (operator.opcode) {
<b class="nc"><i>888</i>&nbsp;        case ByteCodes.ior: case ByteCodes.lor:</b>
<b class="nc"><i>889</i>&nbsp;            return BITOR_ASG;</b>
<b class="nc"><i>890</i>&nbsp;        case ByteCodes.ixor: case ByteCodes.lxor:</b>
<b class="nc"><i>891</i>&nbsp;            return BITXOR_ASG;</b>
<b class="nc"><i>892</i>&nbsp;        case ByteCodes.iand: case ByteCodes.land:</b>
<b class="nc"><i>893</i>&nbsp;            return BITAND_ASG;</b>
<b class="nc"><i>894</i>&nbsp;        case ByteCodes.ishl: case ByteCodes.lshl:</b>
<b class="nc"><i>895</i>&nbsp;        case ByteCodes.ishll: case ByteCodes.lshll:</b>
<b class="nc"><i>896</i>&nbsp;            return SL_ASG;</b>
<b class="nc"><i>897</i>&nbsp;        case ByteCodes.ishr: case ByteCodes.lshr:</b>
<b class="nc"><i>898</i>&nbsp;        case ByteCodes.ishrl: case ByteCodes.lshrl:</b>
<i>899</i>&nbsp;            return SR_ASG;
<b class="nc"><i>900</i>&nbsp;        case ByteCodes.iushr: case ByteCodes.lushr:</b>
<i>901</i>&nbsp;        case ByteCodes.iushrl: case ByteCodes.lushrl:
<i>902</i>&nbsp;            return USR_ASG;
<i>903</i>&nbsp;        case ByteCodes.iadd: case ByteCodes.ladd:
<i>904</i>&nbsp;        case ByteCodes.fadd: case ByteCodes.dadd:
<i>905</i>&nbsp;        case ByteCodes.string_add:
<b class="nc"><i>906</i>&nbsp;            return PLUS_ASG;</b>
<b class="nc"><i>907</i>&nbsp;        case ByteCodes.isub: case ByteCodes.lsub:</b>
<b class="nc"><i>908</i>&nbsp;        case ByteCodes.fsub: case ByteCodes.dsub:</b>
<b class="nc"><i>909</i>&nbsp;            return MINUS_ASG;</b>
<b class="nc"><i>910</i>&nbsp;        case ByteCodes.imul: case ByteCodes.lmul:</b>
<b class="nc"><i>911</i>&nbsp;        case ByteCodes.fmul: case ByteCodes.dmul:</b>
<i>912</i>&nbsp;            return MUL_ASG;
<i>913</i>&nbsp;        case ByteCodes.idiv: case ByteCodes.ldiv:
<b class="nc"><i>914</i>&nbsp;        case ByteCodes.fdiv: case ByteCodes.ddiv:</b>
<i>915</i>&nbsp;            return DIV_ASG;
<i>916</i>&nbsp;        case ByteCodes.imod: case ByteCodes.lmod:
<i>917</i>&nbsp;        case ByteCodes.fmod: case ByteCodes.dmod:
<i>918</i>&nbsp;            return MOD_ASG;
<i>919</i>&nbsp;        default:
<i>920</i>&nbsp;            throw new AssertionError();
<b class="nc"><i>921</i>&nbsp;        }</b>
<i>922</i>&nbsp;    }
<b class="nc"><i>923</i>&nbsp;</b>
<i>924</i>&nbsp;    /** The name of the access method with number `anum&#39; and access code `acode&#39;.
<b class="nc"><i>925</i>&nbsp;     */</b>
<i>926</i>&nbsp;    Name accessName(int anum, int acode) {
<b class="nc"><i>927</i>&nbsp;        return names.fromString(</b>
<i>928</i>&nbsp;            &quot;access&quot; + target.syntheticNameChar() + anum + acode / 10 + acode % 10);
<i>929</i>&nbsp;    }
<b class="nc"><i>930</i>&nbsp;</b>
<i>931</i>&nbsp;    /** Return access symbol for a private or protected symbol from an inner class.
<i>932</i>&nbsp;     *  @param sym        The accessed private symbol.
<b class="nc"><i>933</i>&nbsp;     *  @param tree       The accessing tree.</b>
<i>934</i>&nbsp;     *  @param enclOp     The closest enclosing operation node of tree,
<i>935</i>&nbsp;     *                    null if tree is not a subtree of an operation.
<b class="nc"><i>936</i>&nbsp;     *  @param protAccess Is access to a protected symbol in another</b>
<i>937</i>&nbsp;     *                    package?
<i>938</i>&nbsp;     *  @param refSuper   Is access via a (qualified) C.super?
<i>939</i>&nbsp;     */
<b class="nc"><i>940</i>&nbsp;    MethodSymbol accessSymbol(Symbol sym, JCTree tree, JCTree enclOp,</b>
<i>941</i>&nbsp;                              boolean protAccess, boolean refSuper) {
<i>942</i>&nbsp;        ClassSymbol accOwner = refSuper &amp;&amp; protAccess
<b class="nc"><i>943</i>&nbsp;            // For access via qualified super (T.super.x), place the</b>
<i>944</i>&nbsp;            // access symbol on T.
<i>945</i>&nbsp;            ? (ClassSymbol)((JCFieldAccess) tree).selected.type.tsym
<b class="nc"><i>946</i>&nbsp;            // Otherwise pretend that the owner of an accessed</b>
<i>947</i>&nbsp;            // protected symbol is the enclosing class of the current
<i>948</i>&nbsp;            // class which is a subclass of the symbol&#39;s owner.
<b class="nc"><i>949</i>&nbsp;            : accessClass(sym, protAccess, tree);</b>
<i>950</i>&nbsp;
<i>951</i>&nbsp;        Symbol vsym = sym;
<b class="nc"><i>952</i>&nbsp;        if (sym.owner != accOwner) {</b>
<i>953</i>&nbsp;            vsym = sym.clone(accOwner);
<b class="nc"><i>954</i>&nbsp;            actualSymbols.put(vsym, sym);</b>
<i>955</i>&nbsp;        }
<i>956</i>&nbsp;
<i>957</i>&nbsp;        Integer anum              // The access number of the access method.
<i>958</i>&nbsp;            = accessNums.get(vsym);
<i>959</i>&nbsp;        if (anum == null) {
<i>960</i>&nbsp;            anum = accessed.length();
<b class="nc"><i>961</i>&nbsp;            accessNums.put(vsym, anum);</b>
<b class="nc"><i>962</i>&nbsp;            accessSyms.put(vsym, new MethodSymbol[AccessCode.numberOfAccessCodes]);</b>
<i>963</i>&nbsp;            accessed.append(vsym);
<i>964</i>&nbsp;            // System.out.println(&quot;accessing &quot; + vsym + &quot; in &quot; + vsym.location());
<i>965</i>&nbsp;        }
<i>966</i>&nbsp;
<i>967</i>&nbsp;        int acode;                // The access code of the access method.
<i>968</i>&nbsp;        List&lt;Type&gt; argtypes;      // The argument types of the access method.
<i>969</i>&nbsp;        Type restype;             // The result type of the access method.
<i>970</i>&nbsp;        List&lt;Type&gt; thrown;        // The thrown exceptions of the access method.
<i>971</i>&nbsp;        switch (vsym.kind) {
<i>972</i>&nbsp;        case VAR:
<i>973</i>&nbsp;            acode = accessCode(tree, enclOp);
<i>974</i>&nbsp;            if (acode &gt;= AccessCode.FIRSTASGOP.code) {
<i>975</i>&nbsp;                OperatorSymbol operator = binaryAccessOperator(acode, enclOp.getTag());
<b class="nc"><i>976</i>&nbsp;                if (operator.opcode == string_add)</b>
<i>977</i>&nbsp;                    argtypes = List.of(syms.objectType);
<i>978</i>&nbsp;                else
<i>979</i>&nbsp;                    argtypes = operator.type.getParameterTypes().tail;
<i>980</i>&nbsp;            } else if (acode == AccessCode.ASSIGN.code)
<i>981</i>&nbsp;                argtypes = List.of(vsym.erasure(types));
<i>982</i>&nbsp;            else
<b class="nc"><i>983</i>&nbsp;                argtypes = List.nil();</b>
<i>984</i>&nbsp;            restype = vsym.erasure(types);
<b class="nc"><i>985</i>&nbsp;            thrown = List.nil();</b>
<b class="nc"><i>986</i>&nbsp;            break;</b>
<b class="nc"><i>987</i>&nbsp;        case MTH:</b>
<b class="nc"><i>988</i>&nbsp;            acode = AccessCode.DEREF.code;</b>
<i>989</i>&nbsp;            argtypes = vsym.erasure(types).getParameterTypes();
<i>990</i>&nbsp;            restype = vsym.erasure(types).getReturnType();
<b class="nc"><i>991</i>&nbsp;            thrown = vsym.type.getThrownTypes();</b>
<b class="nc"><i>992</i>&nbsp;            break;</b>
<b class="nc"><i>993</i>&nbsp;        default:</b>
<b class="nc"><i>994</i>&nbsp;            throw new AssertionError();</b>
<b class="nc"><i>995</i>&nbsp;        }</b>
<b class="nc"><i>996</i>&nbsp;</b>
<b class="nc"><i>997</i>&nbsp;        // For references via qualified super, increment acode by one,</b>
<i>998</i>&nbsp;        // making it odd.
<i>999</i>&nbsp;        if (protAccess &amp;&amp; refSuper) acode++;
<i>1000</i>&nbsp;
<i>1001</i>&nbsp;        // Instance access methods get instance as first parameter.
<i>1002</i>&nbsp;        // For protected symbols this needs to be the instance as a member
<i>1003</i>&nbsp;        // of the type containing the accessed symbol, not the class
<i>1004</i>&nbsp;        // containing the access method.
<b class="nc"><i>1005</i>&nbsp;        if ((vsym.flags() &amp; STATIC) == 0) {</b>
<i>1006</i>&nbsp;            argtypes = argtypes.prepend(vsym.owner.erasure(types));
<b class="nc"><i>1007</i>&nbsp;        }</b>
<b class="nc"><i>1008</i>&nbsp;        MethodSymbol[] accessors = accessSyms.get(vsym);</b>
<b class="nc"><i>1009</i>&nbsp;        MethodSymbol accessor = accessors[acode];</b>
<b class="nc"><i>1010</i>&nbsp;        if (accessor == null) {</b>
<b class="nc"><i>1011</i>&nbsp;            accessor = new MethodSymbol(</b>
<i>1012</i>&nbsp;                STATIC | SYNTHETIC | (accOwner.isInterface() ? PUBLIC : 0),
<b class="nc"><i>1013</i>&nbsp;                accessName(anum.intValue(), acode),</b>
<b class="nc"><i>1014</i>&nbsp;                new MethodType(argtypes, restype, thrown, syms.methodClass),</b>
<b class="nc"><i>1015</i>&nbsp;                accOwner);</b>
<i>1016</i>&nbsp;            enterSynthetic(tree.pos(), accessor, accOwner.members());
<b class="nc"><i>1017</i>&nbsp;            accessors[acode] = accessor;</b>
<b class="nc"><i>1018</i>&nbsp;        }</b>
<b class="nc"><i>1019</i>&nbsp;        return accessor;</b>
<b class="nc"><i>1020</i>&nbsp;    }</b>
<i>1021</i>&nbsp;
<b class="nc"><i>1022</i>&nbsp;    /** The qualifier to be used for accessing a symbol in an outer class.</b>
<b class="nc"><i>1023</i>&nbsp;     *  This is either C.sym or C.this.sym, depending on whether or not</b>
<b class="nc"><i>1024</i>&nbsp;     *  sym is static.</b>
<b class="nc"><i>1025</i>&nbsp;     *  @param sym   The accessed symbol.</b>
<b class="nc"><i>1026</i>&nbsp;     */</b>
<i>1027</i>&nbsp;    JCExpression accessBase(DiagnosticPosition pos, Symbol sym) {
<b class="nc"><i>1028</i>&nbsp;        return (sym.flags() &amp; STATIC) != 0</b>
<i>1029</i>&nbsp;            ? access(make.at(pos.getStartPosition()).QualIdent(sym.owner))
<i>1030</i>&nbsp;            : makeOwnerThis(pos, sym, true);
<i>1031</i>&nbsp;    }
<i>1032</i>&nbsp;
<b class="nc"><i>1033</i>&nbsp;    /** Do we need an access method to reference private symbol?</b>
<i>1034</i>&nbsp;     */
<i>1035</i>&nbsp;    boolean needsPrivateAccess(Symbol sym) {
<i>1036</i>&nbsp;        if (target.hasNestmateAccess()) {
<i>1037</i>&nbsp;            return false;
<i>1038</i>&nbsp;        }
<b class="nc"><i>1039</i>&nbsp;        if ((sym.flags() &amp; PRIVATE) == 0 || sym.owner == currentClass) {</b>
<b class="nc"><i>1040</i>&nbsp;            return false;</b>
<i>1041</i>&nbsp;        } else if (sym.name == names.init &amp;&amp; sym.owner.isLocal()) {
<b class="nc"><i>1042</i>&nbsp;            // private constructor in local class: relax protection</b>
<b class="nc"><i>1043</i>&nbsp;            sym.flags_field &amp;= ~PRIVATE;</b>
<b class="nc"><i>1044</i>&nbsp;            return false;</b>
<b class="nc"><i>1045</i>&nbsp;        } else {</b>
<i>1046</i>&nbsp;            return true;
<b class="nc"><i>1047</i>&nbsp;        }</b>
<i>1048</i>&nbsp;    }
<i>1049</i>&nbsp;
<b class="nc"><i>1050</i>&nbsp;    /** Do we need an access method to reference symbol in other package?</b>
<b class="nc"><i>1051</i>&nbsp;     */</b>
<i>1052</i>&nbsp;    boolean needsProtectedAccess(Symbol sym, JCTree tree) {
<b class="nc"><i>1053</i>&nbsp;        if (disableProtectedAccessors) return false;</b>
<i>1054</i>&nbsp;        if ((sym.flags() &amp; PROTECTED) == 0 ||
<i>1055</i>&nbsp;            sym.owner.owner == currentClass.owner || // fast special case
<i>1056</i>&nbsp;            sym.packge() == currentClass.packge())
<i>1057</i>&nbsp;            return false;
<i>1058</i>&nbsp;        if (!currentClass.isSubClass(sym.owner, types))
<i>1059</i>&nbsp;            return true;
<i>1060</i>&nbsp;        if ((sym.flags() &amp; STATIC) != 0 ||
<i>1061</i>&nbsp;            !tree.hasTag(SELECT) ||
<b class="nc"><i>1062</i>&nbsp;            TreeInfo.name(((JCFieldAccess) tree).selected) == names._super)</b>
<b class="nc"><i>1063</i>&nbsp;            return false;</b>
<b class="nc"><i>1064</i>&nbsp;        return !((JCFieldAccess) tree).selected.type.tsym.isSubClass(currentClass, types);</b>
<i>1065</i>&nbsp;    }
<i>1066</i>&nbsp;
<i>1067</i>&nbsp;    /** The class in which an access method for given symbol goes.
<i>1068</i>&nbsp;     *  @param sym        The access symbol
<i>1069</i>&nbsp;     *  @param protAccess Is access to a protected symbol in another
<b class="nc"><i>1070</i>&nbsp;     *                    package?</b>
<b class="nc"><i>1071</i>&nbsp;     */</b>
<b class="nc"><i>1072</i>&nbsp;    ClassSymbol accessClass(Symbol sym, boolean protAccess, JCTree tree) {</b>
<i>1073</i>&nbsp;        if (protAccess) {
<b class="nc"><i>1074</i>&nbsp;            Symbol qualifier = null;</b>
<b class="nc"><i>1075</i>&nbsp;            ClassSymbol c = currentClass;</b>
<i>1076</i>&nbsp;            if (tree.hasTag(SELECT) &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
<b class="nc"><i>1077</i>&nbsp;                qualifier = ((JCFieldAccess) tree).selected.type.tsym;</b>
<i>1078</i>&nbsp;                while (!qualifier.isSubClass(c, types)) {
<i>1079</i>&nbsp;                    c = c.owner.enclClass();
<i>1080</i>&nbsp;                }
<i>1081</i>&nbsp;                return c;
<i>1082</i>&nbsp;            } else {
<i>1083</i>&nbsp;                while (!c.isSubClass(sym.owner, types)) {
<b class="nc"><i>1084</i>&nbsp;                    c = c.owner.enclClass();</b>
<i>1085</i>&nbsp;                }
<b class="nc"><i>1086</i>&nbsp;            }</b>
<b class="nc"><i>1087</i>&nbsp;            return c;</b>
<b class="nc"><i>1088</i>&nbsp;        } else {</b>
<b class="nc"><i>1089</i>&nbsp;            // the symbol is private</b>
<b class="nc"><i>1090</i>&nbsp;            return sym.owner.enclClass();</b>
<b class="nc"><i>1091</i>&nbsp;        }</b>
<b class="nc"><i>1092</i>&nbsp;    }</b>
<b class="nc"><i>1093</i>&nbsp;</b>
<b class="nc"><i>1094</i>&nbsp;    private void addPrunedInfo(JCTree tree) {</b>
<i>1095</i>&nbsp;        List&lt;JCTree&gt; infoList = prunedTree.get(currentClass);
<i>1096</i>&nbsp;        infoList = (infoList == null) ? List.of(tree) : infoList.prepend(tree);
<i>1097</i>&nbsp;        prunedTree.put(currentClass, infoList);
<i>1098</i>&nbsp;    }
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;    /** Ensure that identifier is accessible, return tree accessing the identifier.
<i>1101</i>&nbsp;     *  @param sym      The accessed symbol.
<i>1102</i>&nbsp;     *  @param tree     The tree referring to the symbol.
<b class="nc"><i>1103</i>&nbsp;     *  @param enclOp   The closest enclosing operation node of tree,</b>
<b class="nc"><i>1104</i>&nbsp;     *                  null if tree is not a subtree of an operation.</b>
<b class="nc"><i>1105</i>&nbsp;     *  @param refSuper Is access via a (qualified) C.super?</b>
<b class="nc"><i>1106</i>&nbsp;     */</b>
<b class="nc"><i>1107</i>&nbsp;    JCExpression access(Symbol sym, JCExpression tree, JCExpression enclOp, boolean refSuper) {</b>
<b class="nc"><i>1108</i>&nbsp;        // Access a free variable via its proxy, or its proxy&#39;s proxy</b>
<b class="nc"><i>1109</i>&nbsp;        while (sym.kind == VAR &amp;&amp; sym.owner.kind == MTH &amp;&amp;</b>
<i>1110</i>&nbsp;            sym.owner.enclClass() != currentClass) {
<b class="nc"><i>1111</i>&nbsp;            // A constant is replaced by its constant value.</b>
<i>1112</i>&nbsp;            Object cv = ((VarSymbol)sym).getConstValue();
<b class="nc"><i>1113</i>&nbsp;            if (cv != null) {</b>
<b class="nc"><i>1114</i>&nbsp;                make.at(tree.pos);</b>
<i>1115</i>&nbsp;                return makeLit(sym.type, cv);
<i>1116</i>&nbsp;            }
<b class="nc"><i>1117</i>&nbsp;            // Otherwise replace the variable by its proxy.</b>
<i>1118</i>&nbsp;            sym = proxies.get(sym);
<i>1119</i>&nbsp;            Assert.check(sym != null &amp;&amp; (sym.flags_field &amp; FINAL) != 0);
<b class="nc"><i>1120</i>&nbsp;            tree = make.at(tree.pos).Ident(sym);</b>
<i>1121</i>&nbsp;        }
<i>1122</i>&nbsp;        JCExpression base = (tree.hasTag(SELECT)) ? ((JCFieldAccess) tree).selected : null;
<i>1123</i>&nbsp;        switch (sym.kind) {
<i>1124</i>&nbsp;        case TYP:
<b class="nc"><i>1125</i>&nbsp;            if (sym.owner.kind != PCK) {</b>
<b class="nc"><i>1126</i>&nbsp;                // Convert type idents to</b>
<b class="nc"><i>1127</i>&nbsp;                // &lt;flat name&gt; or &lt;package name&gt; . &lt;flat name&gt;</b>
<i>1128</i>&nbsp;                Name flatname = Convert.shortName(sym.flatName());
<i>1129</i>&nbsp;                while (base != null &amp;&amp;
<i>1130</i>&nbsp;                       TreeInfo.symbol(base) != null &amp;&amp;
<i>1131</i>&nbsp;                       TreeInfo.symbol(base).kind != PCK) {
<i>1132</i>&nbsp;                    base = (base.hasTag(SELECT))
<i>1133</i>&nbsp;                        ? ((JCFieldAccess) base).selected
<i>1134</i>&nbsp;                        : null;
<i>1135</i>&nbsp;                }
<i>1136</i>&nbsp;                if (tree.hasTag(IDENT)) {
<i>1137</i>&nbsp;                    ((JCIdent) tree).name = flatname;
<i>1138</i>&nbsp;                } else if (base == null) {
<b class="nc"><i>1139</i>&nbsp;                    tree = make.at(tree.pos).Ident(sym);</b>
<b class="nc"><i>1140</i>&nbsp;                    ((JCIdent) tree).name = flatname;</b>
<i>1141</i>&nbsp;                } else {
<b class="nc"><i>1142</i>&nbsp;                    ((JCFieldAccess) tree).selected = base;</b>
<b class="nc"><i>1143</i>&nbsp;                    ((JCFieldAccess) tree).name = flatname;</b>
<b class="nc"><i>1144</i>&nbsp;                }</b>
<b class="nc"><i>1145</i>&nbsp;            }</b>
<i>1146</i>&nbsp;            break;
<i>1147</i>&nbsp;        case MTH: case VAR:
<b class="nc"><i>1148</i>&nbsp;            if (sym.owner.kind == TYP) {</b>
<b class="nc"><i>1149</i>&nbsp;</b>
<b class="nc"><i>1150</i>&nbsp;                // Access methods are required for</b>
<b class="nc"><i>1151</i>&nbsp;                //  - private members,</b>
<b class="nc"><i>1152</i>&nbsp;                //  - protected members in a superclass of an</b>
<b class="nc"><i>1153</i>&nbsp;                //    enclosing class contained in another package.</b>
<i>1154</i>&nbsp;                //  - all non-private members accessed via a qualified super.
<b class="nc"><i>1155</i>&nbsp;                boolean protAccess = refSuper &amp;&amp; !needsPrivateAccess(sym)</b>
<i>1156</i>&nbsp;                    || needsProtectedAccess(sym, tree);
<i>1157</i>&nbsp;                boolean accReq = protAccess || needsPrivateAccess(sym);
<b class="nc"><i>1158</i>&nbsp;</b>
<b class="nc"><i>1159</i>&nbsp;                // A base has to be supplied for</b>
<b class="nc"><i>1160</i>&nbsp;                //  - simple identifiers accessing variables in outer classes.</b>
<b class="nc"><i>1161</i>&nbsp;                boolean baseReq =</b>
<b class="nc"><i>1162</i>&nbsp;                    base == null &amp;&amp;</b>
<i>1163</i>&nbsp;                    sym.owner != syms.predefClass &amp;&amp;
<i>1164</i>&nbsp;                    !sym.isMemberOf(currentClass, types);
<i>1165</i>&nbsp;
<b class="nc"><i>1166</i>&nbsp;                if (accReq || baseReq) {</b>
<b class="nc"><i>1167</i>&nbsp;                    make.at(tree.pos);</b>
<b class="nc"><i>1168</i>&nbsp;</b>
<b class="nc"><i>1169</i>&nbsp;                    // Constants are replaced by their constant value.</b>
<b class="nc"><i>1170</i>&nbsp;                    if (sym.kind == VAR) {</b>
<i>1171</i>&nbsp;                        Object cv = ((VarSymbol)sym).getConstValue();
<b class="nc"><i>1172</i>&nbsp;                        if (cv != null) {</b>
<b class="nc"><i>1173</i>&nbsp;                            addPrunedInfo(tree);</b>
<i>1174</i>&nbsp;                            return makeLit(sym.type, cv);
<b class="nc"><i>1175</i>&nbsp;                        }</b>
<i>1176</i>&nbsp;                    }
<i>1177</i>&nbsp;
<b class="nc"><i>1178</i>&nbsp;                    // Private variables and methods are replaced by calls</b>
<i>1179</i>&nbsp;                    // to their access methods.
<i>1180</i>&nbsp;                    if (accReq) {
<i>1181</i>&nbsp;                        List&lt;JCExpression&gt; args = List.nil();
<i>1182</i>&nbsp;                        if ((sym.flags() &amp; STATIC) == 0) {
<i>1183</i>&nbsp;                            // Instance access methods get instance
<i>1184</i>&nbsp;                            // as first parameter.
<b class="nc"><i>1185</i>&nbsp;                            if (base == null)</b>
<b class="nc"><i>1186</i>&nbsp;                                base = makeOwnerThis(tree.pos(), sym, true);</b>
<b class="nc"><i>1187</i>&nbsp;                            args = args.prepend(base);</b>
<i>1188</i>&nbsp;                            base = null;   // so we don&#39;t duplicate code
<i>1189</i>&nbsp;                        }
<i>1190</i>&nbsp;                        Symbol access = accessSymbol(sym, tree,
<b class="nc"><i>1191</i>&nbsp;                                                     enclOp, protAccess,</b>
<i>1192</i>&nbsp;                                                     refSuper);
<i>1193</i>&nbsp;                        JCExpression receiver = make.Select(
<b class="nc"><i>1194</i>&nbsp;                            base != null ? base : make.QualIdent(access.owner),</b>
<i>1195</i>&nbsp;                            access);
<b class="nc"><i>1196</i>&nbsp;                        return make.App(receiver, args);</b>
<b class="nc"><i>1197</i>&nbsp;</b>
<i>1198</i>&nbsp;                    // Other accesses to members of outer classes get a
<i>1199</i>&nbsp;                    // qualifier.
<b class="nc"><i>1200</i>&nbsp;                    } else if (baseReq) {</b>
<b class="nc"><i>1201</i>&nbsp;                        return make.at(tree.pos).Select(</b>
<b class="nc"><i>1202</i>&nbsp;                            accessBase(tree.pos(), sym), sym).setType(tree.type);</b>
<b class="nc"><i>1203</i>&nbsp;                    }</b>
<b class="nc"><i>1204</i>&nbsp;                }</b>
<i>1205</i>&nbsp;            } else if (sym.owner.kind == MTH &amp;&amp; lambdaTranslationMap != null) {
<i>1206</i>&nbsp;                //sym is a local variable - check the lambda translation map to
<i>1207</i>&nbsp;                //see if sym has been translated to something else in the current
<i>1208</i>&nbsp;                //scope (by LambdaToMethod)
<i>1209</i>&nbsp;                Symbol translatedSym = lambdaTranslationMap.get(sym);
<b class="nc"><i>1210</i>&nbsp;                if (translatedSym != null) {</b>
<b class="nc"><i>1211</i>&nbsp;                    tree = make.at(tree.pos).Ident(translatedSym);</b>
<b class="nc"><i>1212</i>&nbsp;                }</b>
<i>1213</i>&nbsp;            }
<i>1214</i>&nbsp;        }
<b class="nc"><i>1215</i>&nbsp;        return tree;</b>
<b class="nc"><i>1216</i>&nbsp;    }</b>
<b class="nc"><i>1217</i>&nbsp;</b>
<b class="nc"><i>1218</i>&nbsp;    /** Ensure that identifier is accessible, return tree accessing the identifier.</b>
<i>1219</i>&nbsp;     *  @param tree     The identifier tree.
<b class="nc"><i>1220</i>&nbsp;     */</b>
<i>1221</i>&nbsp;    JCExpression access(JCExpression tree) {
<i>1222</i>&nbsp;        Symbol sym = TreeInfo.symbol(tree);
<b class="nc"><i>1223</i>&nbsp;        return sym == null ? tree : access(sym, tree, null, false);</b>
<b class="nc"><i>1224</i>&nbsp;    }</b>
<i>1225</i>&nbsp;
<b class="nc"><i>1226</i>&nbsp;    /** Return access constructor for a private constructor,</b>
<i>1227</i>&nbsp;     *  or the constructor itself, if no access constructor is needed.
<i>1228</i>&nbsp;     *  @param pos       The position to report diagnostics, if any.
<i>1229</i>&nbsp;     *  @param constr    The private constructor.
<b class="nc"><i>1230</i>&nbsp;     */</b>
<b class="nc"><i>1231</i>&nbsp;    Symbol accessConstructor(DiagnosticPosition pos, Symbol constr) {</b>
<b class="nc"><i>1232</i>&nbsp;        if (needsPrivateAccess(constr)) {</b>
<i>1233</i>&nbsp;            ClassSymbol accOwner = constr.owner.enclClass();
<i>1234</i>&nbsp;            MethodSymbol aconstr = accessConstrs.get(constr);
<b class="nc"><i>1235</i>&nbsp;            if (aconstr == null) {</b>
<i>1236</i>&nbsp;                List&lt;Type&gt; argtypes = constr.type.getParameterTypes();
<i>1237</i>&nbsp;                if ((accOwner.flags_field &amp; ENUM) != 0)
<i>1238</i>&nbsp;                    argtypes = argtypes
<b class="nc"><i>1239</i>&nbsp;                        .prepend(syms.intType)</b>
<b class="nc"><i>1240</i>&nbsp;                        .prepend(syms.stringType);</b>
<b class="nc"><i>1241</i>&nbsp;                aconstr = new MethodSymbol(</b>
<i>1242</i>&nbsp;                    SYNTHETIC,
<i>1243</i>&nbsp;                    names.init,
<i>1244</i>&nbsp;                    new MethodType(
<b class="nc"><i>1245</i>&nbsp;                        argtypes.append(</b>
<i>1246</i>&nbsp;                            accessConstructorTag().erasure(types)),
<i>1247</i>&nbsp;                        constr.type.getReturnType(),
<i>1248</i>&nbsp;                        constr.type.getThrownTypes(),
<i>1249</i>&nbsp;                        syms.methodClass),
<i>1250</i>&nbsp;                    accOwner);
<i>1251</i>&nbsp;                enterSynthetic(pos, aconstr, accOwner.members());
<b class="nc"><i>1252</i>&nbsp;                accessConstrs.put(constr, aconstr);</b>
<b class="nc"><i>1253</i>&nbsp;                accessed.append(constr);</b>
<i>1254</i>&nbsp;            }
<i>1255</i>&nbsp;            return aconstr;
<i>1256</i>&nbsp;        } else {
<i>1257</i>&nbsp;            return constr;
<i>1258</i>&nbsp;        }
<i>1259</i>&nbsp;    }
<i>1260</i>&nbsp;
<i>1261</i>&nbsp;    /** Return an anonymous class nested in this toplevel class.
<b class="nc"><i>1262</i>&nbsp;     */</b>
<b class="nc"><i>1263</i>&nbsp;    ClassSymbol accessConstructorTag() {</b>
<b class="nc"><i>1264</i>&nbsp;        ClassSymbol topClass = currentClass.outermostClass();</b>
<b class="nc"><i>1265</i>&nbsp;        ModuleSymbol topModle = topClass.packge().modle;</b>
<b class="nc"><i>1266</i>&nbsp;        for (int i = 1; ; i++) {</b>
<b class="nc"><i>1267</i>&nbsp;            Name flatname = names.fromString(&quot;&quot; + topClass.getQualifiedName() +</b>
<b class="nc"><i>1268</i>&nbsp;                                            target.syntheticNameChar() +</b>
<b class="nc"><i>1269</i>&nbsp;                                            i);</b>
<b class="nc"><i>1270</i>&nbsp;            ClassSymbol ctag = chk.getCompiled(topModle, flatname);</b>
<b class="nc"><i>1271</i>&nbsp;            if (ctag == null)</b>
<i>1272</i>&nbsp;                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;
<i>1273</i>&nbsp;            else if (!ctag.isAnonymous())
<i>1274</i>&nbsp;                continue;
<b class="nc"><i>1275</i>&nbsp;            // keep a record of all tags, to verify that all are generated as required</b>
<b class="nc"><i>1276</i>&nbsp;            accessConstrTags = accessConstrTags.prepend(ctag);</b>
<b class="nc"><i>1277</i>&nbsp;            return ctag;</b>
<b class="nc"><i>1278</i>&nbsp;        }</b>
<i>1279</i>&nbsp;    }
<i>1280</i>&nbsp;
<b class="nc"><i>1281</i>&nbsp;    /** Add all required access methods for a private symbol to enclosing class.</b>
<b class="nc"><i>1282</i>&nbsp;     *  @param sym       The symbol.</b>
<b class="nc"><i>1283</i>&nbsp;     */</b>
<i>1284</i>&nbsp;    void makeAccessible(Symbol sym) {
<b class="nc"><i>1285</i>&nbsp;        JCClassDecl cdef = classDef(sym.owner.enclClass());</b>
<i>1286</i>&nbsp;        if (cdef == null) Assert.error(&quot;class def not found: &quot; + sym + &quot; in &quot; + sym.owner);
<b class="nc"><i>1287</i>&nbsp;        if (sym.name == names.init) {</b>
<i>1288</i>&nbsp;            cdef.defs = cdef.defs.prepend(
<i>1289</i>&nbsp;                accessConstructorDef(cdef.pos, sym, accessConstrs.get(sym)));
<i>1290</i>&nbsp;        } else {
<i>1291</i>&nbsp;            MethodSymbol[] accessors = accessSyms.get(sym);
<i>1292</i>&nbsp;            for (int i = 0; i &lt; AccessCode.numberOfAccessCodes; i++) {
<i>1293</i>&nbsp;                if (accessors[i] != null)
<b class="nc"><i>1294</i>&nbsp;                    cdef.defs = cdef.defs.prepend(</b>
<b class="nc"><i>1295</i>&nbsp;                        accessDef(cdef.pos, sym, accessors[i], i));</b>
<b class="nc"><i>1296</i>&nbsp;            }</b>
<i>1297</i>&nbsp;        }
<b class="nc"><i>1298</i>&nbsp;    }</b>
<b class="nc"><i>1299</i>&nbsp;</b>
<b class="nc"><i>1300</i>&nbsp;    /** Construct definition of an access method.</b>
<i>1301</i>&nbsp;     *  @param pos        The source code position of the definition.
<b class="nc"><i>1302</i>&nbsp;     *  @param vsym       The private or protected symbol.</b>
<b class="nc"><i>1303</i>&nbsp;     *  @param accessor   The access method for the symbol.</b>
<i>1304</i>&nbsp;     *  @param acode      The access code.
<i>1305</i>&nbsp;     */
<i>1306</i>&nbsp;    JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {
<i>1307</i>&nbsp;//      System.err.println(&quot;access &quot; + vsym + &quot; with &quot; + accessor);//DEBUG
<i>1308</i>&nbsp;        currentClass = vsym.owner.enclClass();
<i>1309</i>&nbsp;        make.at(pos);
<b class="nc"><i>1310</i>&nbsp;        JCMethodDecl md = make.MethodDef(accessor, null);</b>
<b class="nc"><i>1311</i>&nbsp;</b>
<b class="nc"><i>1312</i>&nbsp;        // Find actual symbol</b>
<b class="nc"><i>1313</i>&nbsp;        Symbol sym = actualSymbols.get(vsym);</b>
<b class="nc"><i>1314</i>&nbsp;        if (sym == null) sym = vsym;</b>
<i>1315</i>&nbsp;
<b class="nc"><i>1316</i>&nbsp;        JCExpression ref;           // The tree referencing the private symbol.</b>
<b class="nc"><i>1317</i>&nbsp;        List&lt;JCExpression&gt; args;    // Any additional arguments to be passed along.</b>
<b class="nc"><i>1318</i>&nbsp;        if ((sym.flags() &amp; STATIC) != 0) {</b>
<b class="nc"><i>1319</i>&nbsp;            ref = make.Ident(sym);</b>
<b class="nc"><i>1320</i>&nbsp;            args = make.Idents(md.params);</b>
<i>1321</i>&nbsp;        } else {
<i>1322</i>&nbsp;            JCExpression site = make.Ident(md.params.head);
<i>1323</i>&nbsp;            if (acode % 2 != 0) {
<i>1324</i>&nbsp;                //odd access codes represent qualified super accesses - need to
<i>1325</i>&nbsp;                //emit reference to the direct superclass, even if the refered
<i>1326</i>&nbsp;                //member is from an indirect superclass (JLS 13.1)
<i>1327</i>&nbsp;                site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
<i>1328</i>&nbsp;            }
<b class="nc"><i>1329</i>&nbsp;            ref = make.Select(site, sym);</b>
<i>1330</i>&nbsp;            args = make.Idents(md.params.tail);
<b class="nc"><i>1331</i>&nbsp;        }</b>
<i>1332</i>&nbsp;        JCStatement stat;          // The statement accessing the private symbol.
<b class="nc"><i>1333</i>&nbsp;        if (sym.kind == VAR) {</b>
<i>1334</i>&nbsp;            // Normalize out all odd access codes by taking floor modulo 2:
<b class="nc"><i>1335</i>&nbsp;            int acode1 = acode - (acode &amp; 1);</b>
<i>1336</i>&nbsp;
<b class="nc"><i>1337</i>&nbsp;            JCExpression expr;      // The access method&#39;s return value.</b>
<i>1338</i>&nbsp;            AccessCode aCode = AccessCode.getFromCode(acode1);
<b class="nc"><i>1339</i>&nbsp;            switch (aCode) {</b>
<i>1340</i>&nbsp;            case DEREF:
<i>1341</i>&nbsp;                expr = ref;
<i>1342</i>&nbsp;                break;
<i>1343</i>&nbsp;            case ASSIGN:
<i>1344</i>&nbsp;                expr = make.Assign(ref, args.head);
<i>1345</i>&nbsp;                break;
<i>1346</i>&nbsp;            case PREINC: case POSTINC: case PREDEC: case POSTDEC:
<b class="nc"><i>1347</i>&nbsp;                expr = makeUnary(aCode.tag, ref);</b>
<i>1348</i>&nbsp;                break;
<b class="nc"><i>1349</i>&nbsp;            default:</b>
<i>1350</i>&nbsp;                expr = make.Assignop(
<b class="nc"><i>1351</i>&nbsp;                    treeTag(binaryAccessOperator(acode1, JCTree.Tag.NO_TAG)), ref, args.head);</b>
<i>1352</i>&nbsp;                ((JCAssignOp) expr).operator = binaryAccessOperator(acode1, JCTree.Tag.NO_TAG);
<b class="nc"><i>1353</i>&nbsp;            }</b>
<i>1354</i>&nbsp;            stat = make.Return(expr.setType(sym.type));
<b class="nc"><i>1355</i>&nbsp;        } else {</b>
<i>1356</i>&nbsp;            stat = make.Call(make.App(ref, args));
<b class="nc"><i>1357</i>&nbsp;        }</b>
<i>1358</i>&nbsp;        md.body = make.Block(0, List.of(stat));
<i>1359</i>&nbsp;
<i>1360</i>&nbsp;        // Make sure all parameters, result types and thrown exceptions
<i>1361</i>&nbsp;        // are accessible.
<i>1362</i>&nbsp;        for (List&lt;JCVariableDecl&gt; l = md.params; l.nonEmpty(); l = l.tail)
<i>1363</i>&nbsp;            l.head.vartype = access(l.head.vartype);
<i>1364</i>&nbsp;        md.restype = access(md.restype);
<i>1365</i>&nbsp;        for (List&lt;JCExpression&gt; l = md.thrown; l.nonEmpty(); l = l.tail)
<i>1366</i>&nbsp;            l.head = access(l.head);
<i>1367</i>&nbsp;
<i>1368</i>&nbsp;        return md;
<b class="nc"><i>1369</i>&nbsp;    }</b>
<b class="nc"><i>1370</i>&nbsp;</b>
<b class="nc"><i>1371</i>&nbsp;    /** Construct definition of an access constructor.</b>
<i>1372</i>&nbsp;     *  @param pos        The source code position of the definition.
<i>1373</i>&nbsp;     *  @param constr     The private constructor.
<b class="nc"><i>1374</i>&nbsp;     *  @param accessor   The access method for the constructor.</b>
<b class="nc"><i>1375</i>&nbsp;     */</b>
<i>1376</i>&nbsp;    JCTree accessConstructorDef(int pos, Symbol constr, MethodSymbol accessor) {
<i>1377</i>&nbsp;        make.at(pos);
<i>1378</i>&nbsp;        JCMethodDecl md = make.MethodDef(accessor,
<b class="nc"><i>1379</i>&nbsp;                                      accessor.externalType(types),</b>
<b class="nc"><i>1380</i>&nbsp;                                      null);</b>
<b class="nc"><i>1381</i>&nbsp;        JCIdent callee = make.Ident(names._this);</b>
<i>1382</i>&nbsp;        callee.sym = constr;
<b class="nc"><i>1383</i>&nbsp;        callee.type = constr.type;</b>
<b class="nc"><i>1384</i>&nbsp;        md.body =</b>
<i>1385</i>&nbsp;            make.Block(0, List.of(
<i>1386</i>&nbsp;                make.Call(
<i>1387</i>&nbsp;                    make.App(
<b class="nc"><i>1388</i>&nbsp;                        callee,</b>
<i>1389</i>&nbsp;                        make.Idents(md.params.reverse().tail.reverse())))));
<b class="nc"><i>1390</i>&nbsp;        return md;</b>
<b class="nc"><i>1391</i>&nbsp;    }</b>
<i>1392</i>&nbsp;
<i>1393</i>&nbsp;/**************************************************************************
<b class="nc"><i>1394</i>&nbsp; * Free variables proxies and this$n</b>
<i>1395</i>&nbsp; *************************************************************************/
<b class="nc"><i>1396</i>&nbsp;</b>
<i>1397</i>&nbsp;    /** A map which allows to retrieve the translated proxy variable for any given symbol of an
<i>1398</i>&nbsp;     *  enclosing scope that is accessed (the accessed symbol could be the synthetic &#39;this$n&#39; symbol).
<b class="nc"><i>1399</i>&nbsp;     *  Inside a constructor, the map temporarily overrides entries corresponding to proxies and any</b>
<i>1400</i>&nbsp;     *  &#39;this$n&#39; symbols, where they represent the constructor parameters.
<b class="nc"><i>1401</i>&nbsp;     */</b>
<b class="nc"><i>1402</i>&nbsp;    Map&lt;Symbol, Symbol&gt; proxies;</b>
<i>1403</i>&nbsp;
<b class="nc"><i>1404</i>&nbsp;    /** A scope containing all unnamed resource variables/saved</b>
<b class="nc"><i>1405</i>&nbsp;     *  exception variables for translated TWR blocks</b>
<i>1406</i>&nbsp;     */
<b class="nc"><i>1407</i>&nbsp;    WriteableScope twrVars;</b>
<b class="nc"><i>1408</i>&nbsp;</b>
<i>1409</i>&nbsp;    /** A stack containing the this$n field of the currently translated
<b class="nc"><i>1410</i>&nbsp;     *  classes (if needed) in innermost first order.</b>
<b class="nc"><i>1411</i>&nbsp;     *  Inside a constructor, proxies and any this$n symbol are duplicated</b>
<b class="nc"><i>1412</i>&nbsp;     *  in an additional innermost scope, where they represent the constructor</b>
<i>1413</i>&nbsp;     *  parameters.
<b class="nc"><i>1414</i>&nbsp;     */</b>
<b class="nc"><i>1415</i>&nbsp;    List&lt;VarSymbol&gt; outerThisStack;</b>
<b class="nc"><i>1416</i>&nbsp;</b>
<i>1417</i>&nbsp;    /** The name of a free variable proxy.
<b class="nc"><i>1418</i>&nbsp;     */</b>
<i>1419</i>&nbsp;    Name proxyName(Name name, int index) {
<i>1420</i>&nbsp;        Name proxyName = names.fromString(&quot;val&quot; + target.syntheticNameChar() + name);
<i>1421</i>&nbsp;        if (index &gt; 0) {
<b class="nc"><i>1422</i>&nbsp;            proxyName = proxyName.append(names.fromString(&quot;&quot; + target.syntheticNameChar() + index));</b>
<b class="nc"><i>1423</i>&nbsp;        }</b>
<b class="nc"><i>1424</i>&nbsp;        return proxyName;</b>
<b class="nc"><i>1425</i>&nbsp;    }</b>
<b class="nc"><i>1426</i>&nbsp;</b>
<i>1427</i>&nbsp;    /** Proxy definitions for all free variables in given list, in reverse order.
<b class="nc"><i>1428</i>&nbsp;     *  @param pos        The source code position of the definition.</b>
<i>1429</i>&nbsp;     *  @param freevars   The free variables.
<i>1430</i>&nbsp;     *  @param owner      The class in which the definitions go.
<i>1431</i>&nbsp;     */
<i>1432</i>&nbsp;    List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner) {
<i>1433</i>&nbsp;        return freevarDefs(pos, freevars, owner, 0);
<i>1434</i>&nbsp;    }
<i>1435</i>&nbsp;
<i>1436</i>&nbsp;    List&lt;JCVariableDecl&gt; freevarDefs(int pos, List&lt;VarSymbol&gt; freevars, Symbol owner,
<b class="nc"><i>1437</i>&nbsp;            long additionalFlags) {</b>
<b class="nc"><i>1438</i>&nbsp;        long flags = FINAL | SYNTHETIC | additionalFlags;</b>
<b class="nc"><i>1439</i>&nbsp;        List&lt;JCVariableDecl&gt; defs = List.nil();</b>
<i>1440</i>&nbsp;        Set&lt;Name&gt; proxyNames = new HashSet&lt;&gt;();
<b class="nc"><i>1441</i>&nbsp;        for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>1442</i>&nbsp;            VarSymbol v = l.head;</b>
<b class="nc"><i>1443</i>&nbsp;            int index = 0;</b>
<b class="nc"><i>1444</i>&nbsp;            Name proxyName;</b>
<b class="nc"><i>1445</i>&nbsp;            do {</b>
<b class="nc"><i>1446</i>&nbsp;                proxyName = proxyName(v.name, index++);</b>
<b class="nc"><i>1447</i>&nbsp;            } while (!proxyNames.add(proxyName));</b>
<i>1448</i>&nbsp;            VarSymbol proxy = new VarSymbol(
<b class="nc"><i>1449</i>&nbsp;                flags, proxyName, v.erasure(types), owner);</b>
<b class="nc"><i>1450</i>&nbsp;            proxies.put(v, proxy);</b>
<i>1451</i>&nbsp;            JCVariableDecl vd = make.at(pos).VarDef(proxy, null);
<i>1452</i>&nbsp;            vd.vartype = access(vd.vartype);
<i>1453</i>&nbsp;            defs = defs.prepend(vd);
<i>1454</i>&nbsp;        }
<i>1455</i>&nbsp;        return defs;
<i>1456</i>&nbsp;    }
<i>1457</i>&nbsp;
<i>1458</i>&nbsp;    /** The name of a this$n field
<i>1459</i>&nbsp;     *  @param type   The class referenced by the this$n field
<i>1460</i>&nbsp;     */
<i>1461</i>&nbsp;    Name outerThisName(Type type, Symbol owner) {
<i>1462</i>&nbsp;        Type t = type.getEnclosingType();
<i>1463</i>&nbsp;        int nestingLevel = 0;
<i>1464</i>&nbsp;        while (t.hasTag(CLASS)) {
<i>1465</i>&nbsp;            t = t.getEnclosingType();
<i>1466</i>&nbsp;            nestingLevel++;
<i>1467</i>&nbsp;        }
<i>1468</i>&nbsp;        Name result = names.fromString(&quot;this&quot; + target.syntheticNameChar() + nestingLevel);
<i>1469</i>&nbsp;        while (owner.kind == TYP &amp;&amp; ((ClassSymbol)owner).members().findFirst(result) != null)
<i>1470</i>&nbsp;            result = names.fromString(result.toString() + target.syntheticNameChar());
<i>1471</i>&nbsp;        return result;
<i>1472</i>&nbsp;    }
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;    private VarSymbol makeOuterThisVarSymbol(Symbol owner, long flags) {
<i>1475</i>&nbsp;        Type target = types.erasure(owner.enclClass().type.getEnclosingType());
<i>1476</i>&nbsp;        VarSymbol outerThis =
<i>1477</i>&nbsp;            new VarSymbol(flags, outerThisName(target, owner), target, owner);
<i>1478</i>&nbsp;        outerThisStack = outerThisStack.prepend(outerThis);
<i>1479</i>&nbsp;        return outerThis;
<i>1480</i>&nbsp;    }
<i>1481</i>&nbsp;
<b class="nc"><i>1482</i>&nbsp;    private JCVariableDecl makeOuterThisVarDecl(int pos, VarSymbol sym) {</b>
<i>1483</i>&nbsp;        JCVariableDecl vd = make.at(pos).VarDef(sym, null);
<i>1484</i>&nbsp;        vd.vartype = access(vd.vartype);
<i>1485</i>&nbsp;        return vd;
<i>1486</i>&nbsp;    }
<i>1487</i>&nbsp;
<i>1488</i>&nbsp;    /** Definition for this$n field.
<i>1489</i>&nbsp;     *  @param pos        The source code position of the definition.
<i>1490</i>&nbsp;     *  @param owner      The method in which the definition goes.
<b class="nc"><i>1491</i>&nbsp;     */</b>
<i>1492</i>&nbsp;    JCVariableDecl outerThisDef(int pos, MethodSymbol owner) {
<i>1493</i>&nbsp;        ClassSymbol c = owner.enclClass();
<i>1494</i>&nbsp;        boolean isMandated =
<i>1495</i>&nbsp;            // Anonymous constructors
<b class="nc"><i>1496</i>&nbsp;            (owner.isConstructor() &amp;&amp; owner.isAnonymous()) ||</b>
<b class="nc"><i>1497</i>&nbsp;            // Constructors of non-private inner member classes</b>
<b class="nc"><i>1498</i>&nbsp;            (owner.isConstructor() &amp;&amp; c.isInner() &amp;&amp;</b>
<b class="nc"><i>1499</i>&nbsp;             !c.isPrivate() &amp;&amp; !c.isStatic());</b>
<b class="nc"><i>1500</i>&nbsp;        long flags =</b>
<b class="nc"><i>1501</i>&nbsp;            FINAL | (isMandated ? MANDATED : SYNTHETIC) | PARAMETER;</b>
<b class="nc"><i>1502</i>&nbsp;        VarSymbol outerThis = makeOuterThisVarSymbol(owner, flags);</b>
<b class="nc"><i>1503</i>&nbsp;        owner.extraParams = owner.extraParams.prepend(outerThis);</b>
<b class="nc"><i>1504</i>&nbsp;        return makeOuterThisVarDecl(pos, outerThis);</b>
<b class="nc"><i>1505</i>&nbsp;    }</b>
<b class="nc"><i>1506</i>&nbsp;</b>
<b class="nc"><i>1507</i>&nbsp;    /** Definition for this$n field.</b>
<b class="nc"><i>1508</i>&nbsp;     *  @param pos        The source code position of the definition.</b>
<i>1509</i>&nbsp;     *  @param owner      The class in which the definition goes.
<b class="nc"><i>1510</i>&nbsp;     */</b>
<i>1511</i>&nbsp;    JCVariableDecl outerThisDef(int pos, ClassSymbol owner) {
<i>1512</i>&nbsp;        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);
<i>1513</i>&nbsp;        return makeOuterThisVarDecl(pos, outerThis);
<i>1514</i>&nbsp;    }
<i>1515</i>&nbsp;
<i>1516</i>&nbsp;    /** Return a list of trees that load the free variables in given list,
<b class="nc"><i>1517</i>&nbsp;     *  in reverse order.</b>
<b class="nc"><i>1518</i>&nbsp;     *  @param pos          The source code position to be used for the trees.</b>
<b class="nc"><i>1519</i>&nbsp;     *  @param freevars     The list of free variables.</b>
<b class="nc"><i>1520</i>&nbsp;     */</b>
<b class="nc"><i>1521</i>&nbsp;    List&lt;JCExpression&gt; loadFreevars(DiagnosticPosition pos, List&lt;VarSymbol&gt; freevars) {</b>
<i>1522</i>&nbsp;        List&lt;JCExpression&gt; args = List.nil();
<b class="nc"><i>1523</i>&nbsp;        for (List&lt;VarSymbol&gt; l = freevars; l.nonEmpty(); l = l.tail)</b>
<b class="nc"><i>1524</i>&nbsp;            args = args.prepend(loadFreevar(pos, l.head));</b>
<b class="nc"><i>1525</i>&nbsp;        return args;</b>
<b class="nc"><i>1526</i>&nbsp;    }</b>
<i>1527</i>&nbsp;//where
<i>1528</i>&nbsp;        JCExpression loadFreevar(DiagnosticPosition pos, VarSymbol v) {
<i>1529</i>&nbsp;            return access(v, make.at(pos).Ident(v), null, false);
<b class="nc"><i>1530</i>&nbsp;        }</b>
<b class="nc"><i>1531</i>&nbsp;</b>
<b class="nc"><i>1532</i>&nbsp;    /** Construct a tree simulating the expression {@code C.this}.</b>
<b class="nc"><i>1533</i>&nbsp;     *  @param pos           The source code position to be used for the tree.</b>
<b class="nc"><i>1534</i>&nbsp;     *  @param c             The qualifier class.</b>
<b class="nc"><i>1535</i>&nbsp;     */</b>
<b class="nc"><i>1536</i>&nbsp;    JCExpression makeThis(DiagnosticPosition pos, TypeSymbol c) {</b>
<b class="nc"><i>1537</i>&nbsp;        if (currentClass == c) {</b>
<i>1538</i>&nbsp;            // in this case, `this&#39; works fine
<i>1539</i>&nbsp;            return make.at(pos).This(c.erasure(types));
<i>1540</i>&nbsp;        } else {
<b class="nc"><i>1541</i>&nbsp;            // need to go via this$n</b>
<b class="nc"><i>1542</i>&nbsp;            return makeOuterThis(pos, c);</b>
<b class="nc"><i>1543</i>&nbsp;        }</b>
<i>1544</i>&nbsp;    }
<i>1545</i>&nbsp;
<i>1546</i>&nbsp;    /**
<i>1547</i>&nbsp;     * Optionally replace a try statement with the desugaring of a
<i>1548</i>&nbsp;     * try-with-resources statement.  The canonical desugaring of
<i>1549</i>&nbsp;     *
<i>1550</i>&nbsp;     * try ResourceSpecification
<b class="nc"><i>1551</i>&nbsp;     *   Block</b>
<b class="nc"><i>1552</i>&nbsp;     *</b>
<i>1553</i>&nbsp;     * is
<b class="nc"><i>1554</i>&nbsp;     *</b>
<i>1555</i>&nbsp;     * {
<b class="nc"><i>1556</i>&nbsp;     *   final VariableModifiers_minus_final R #resource = Expression;</b>
<b class="nc"><i>1557</i>&nbsp;     *</b>
<b class="nc"><i>1558</i>&nbsp;     *   try ResourceSpecificationtail</b>
<i>1559</i>&nbsp;     *     Block
<b class="nc"><i>1560</i>&nbsp;     *   } body-only-finally {</b>
<b class="nc"><i>1561</i>&nbsp;     *     if (#resource != null) //nullcheck skipped if Expression is provably non-null</b>
<b class="nc"><i>1562</i>&nbsp;     *         #resource.close();</b>
<i>1563</i>&nbsp;     *   } catch (Throwable #primaryException) {
<i>1564</i>&nbsp;     *       if (#resource != null) //nullcheck skipped if Expression is provably non-null
<i>1565</i>&nbsp;     *           try {
<i>1566</i>&nbsp;     *               #resource.close();
<i>1567</i>&nbsp;     *           } catch (Throwable #suppressedException) {
<i>1568</i>&nbsp;     *              #primaryException.addSuppressed(#suppressedException);
<i>1569</i>&nbsp;     *           }
<b class="nc"><i>1570</i>&nbsp;     *       throw #primaryException;</b>
<b class="nc"><i>1571</i>&nbsp;     *   }</b>
<i>1572</i>&nbsp;     * }
<i>1573</i>&nbsp;     *
<i>1574</i>&nbsp;     * @param tree  The try statement to inspect.
<i>1575</i>&nbsp;     * @return A a desugared try-with-resources tree, or the original
<i>1576</i>&nbsp;     * try block if there are no resources to manage.
<i>1577</i>&nbsp;     */
<i>1578</i>&nbsp;    JCTree makeTwrTry(JCTry tree) {
<i>1579</i>&nbsp;        make_at(tree.pos());
<b class="nc"><i>1580</i>&nbsp;        twrVars = twrVars.dup();</b>
<b class="nc"><i>1581</i>&nbsp;        JCBlock twrBlock = makeTwrBlock(tree.resources, tree.body, 0);</b>
<b class="nc"><i>1582</i>&nbsp;        if (tree.catchers.isEmpty() &amp;&amp; tree.finalizer == null)</b>
<b class="nc"><i>1583</i>&nbsp;            result = translate(twrBlock);</b>
<i>1584</i>&nbsp;        else
<i>1585</i>&nbsp;            result = translate(make.Try(twrBlock, tree.catchers, tree.finalizer));
<i>1586</i>&nbsp;        twrVars = twrVars.leave();
<b class="nc"><i>1587</i>&nbsp;        return result;</b>
<i>1588</i>&nbsp;    }
<i>1589</i>&nbsp;
<i>1590</i>&nbsp;    private JCBlock makeTwrBlock(List&lt;JCTree&gt; resources, JCBlock block, int depth) {
<i>1591</i>&nbsp;        if (resources.isEmpty())
<i>1592</i>&nbsp;            return block;
<i>1593</i>&nbsp;
<i>1594</i>&nbsp;        // Add resource declaration or expression to block statements
<b class="nc"><i>1595</i>&nbsp;        ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();</b>
<i>1596</i>&nbsp;        JCTree resource = resources.head;
<b class="nc"><i>1597</i>&nbsp;        JCExpression resourceUse;</b>
<i>1598</i>&nbsp;        boolean resourceNonNull;
<i>1599</i>&nbsp;        if (resource instanceof JCVariableDecl) {
<b class="nc"><i>1600</i>&nbsp;            JCVariableDecl var = (JCVariableDecl) resource;</b>
<i>1601</i>&nbsp;            resourceUse = make.Ident(var.sym).setType(resource.type);
<i>1602</i>&nbsp;            resourceNonNull = var.init != null &amp;&amp; TreeInfo.skipParens(var.init).hasTag(NEWCLASS);
<i>1603</i>&nbsp;            stats.add(var);
<i>1604</i>&nbsp;        } else {
<i>1605</i>&nbsp;            Assert.check(resource instanceof JCExpression);
<i>1606</i>&nbsp;            VarSymbol syntheticTwrVar =
<i>1607</i>&nbsp;            new VarSymbol(SYNTHETIC | FINAL,
<i>1608</i>&nbsp;                          makeSyntheticName(names.fromString(&quot;twrVar&quot; +
<i>1609</i>&nbsp;                                           depth), twrVars),
<i>1610</i>&nbsp;                          (resource.type.hasTag(BOT)) ?
<i>1611</i>&nbsp;                          syms.autoCloseableType : resource.type,
<i>1612</i>&nbsp;                          currentMethodSym);
<i>1613</i>&nbsp;            twrVars.enter(syntheticTwrVar);
<i>1614</i>&nbsp;            JCVariableDecl syntheticTwrVarDecl =
<i>1615</i>&nbsp;                make.VarDef(syntheticTwrVar, (JCExpression)resource);
<i>1616</i>&nbsp;            resourceUse = (JCExpression)make.Ident(syntheticTwrVar);
<i>1617</i>&nbsp;            resourceNonNull = false;
<i>1618</i>&nbsp;            stats.add(syntheticTwrVarDecl);
<i>1619</i>&nbsp;        }
<i>1620</i>&nbsp;
<i>1621</i>&nbsp;        //create (semi-) finally block that will be copied into the main try body:
<i>1622</i>&nbsp;        int oldPos = make.pos;
<i>1623</i>&nbsp;        make.at(TreeInfo.endPos(block));
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;        // if (#resource != null) { #resource.close(); }
<i>1626</i>&nbsp;        JCStatement bodyCloseStatement = makeResourceCloseInvocation(resourceUse);
<i>1627</i>&nbsp;
<i>1628</i>&nbsp;        if (!resourceNonNull) {
<i>1629</i>&nbsp;            bodyCloseStatement = make.If(makeNonNullCheck(resourceUse),
<i>1630</i>&nbsp;                                         bodyCloseStatement,
<i>1631</i>&nbsp;                                         null);
<i>1632</i>&nbsp;        }
<i>1633</i>&nbsp;
<i>1634</i>&nbsp;        JCBlock finallyClause = make.Block(BODY_ONLY_FINALIZE, List.of(bodyCloseStatement));
<i>1635</i>&nbsp;        make.at(oldPos);
<i>1636</i>&nbsp;
<i>1637</i>&nbsp;        // Create catch clause that saves exception, closes the resource and then rethrows the exception:
<i>1638</i>&nbsp;        VarSymbol primaryException =
<i>1639</i>&nbsp;            new VarSymbol(FINAL|SYNTHETIC,
<i>1640</i>&nbsp;                          names.fromString(&quot;t&quot; +
<b class="nc"><i>1641</i>&nbsp;                                           target.syntheticNameChar()),</b>
<b class="nc"><i>1642</i>&nbsp;                          syms.throwableType,</b>
<b class="nc"><i>1643</i>&nbsp;                          currentMethodSym);</b>
<i>1644</i>&nbsp;        JCVariableDecl primaryExceptionDecl = make.VarDef(primaryException, null);
<b class="nc"><i>1645</i>&nbsp;</b>
<b class="nc"><i>1646</i>&nbsp;        // close resource:</b>
<i>1647</i>&nbsp;        // try {
<b class="nc"><i>1648</i>&nbsp;        //     #resource.close();</b>
<b class="nc"><i>1649</i>&nbsp;        // } catch (Throwable #suppressedException) {</b>
<b class="nc"><i>1650</i>&nbsp;        //     #primaryException.addSuppressed(#suppressedException);</b>
<i>1651</i>&nbsp;        // }
<i>1652</i>&nbsp;        VarSymbol suppressedException =
<i>1653</i>&nbsp;            new VarSymbol(SYNTHETIC, make.paramName(2),
<i>1654</i>&nbsp;                          syms.throwableType,
<b class="nc"><i>1655</i>&nbsp;                          currentMethodSym);</b>
<b class="nc"><i>1656</i>&nbsp;        JCStatement addSuppressedStatement =</b>
<i>1657</i>&nbsp;            make.Exec(makeCall(make.Ident(primaryException),
<i>1658</i>&nbsp;                               names.addSuppressed,
<b class="nc"><i>1659</i>&nbsp;                               List.of(make.Ident(suppressedException))));</b>
<b class="nc"><i>1660</i>&nbsp;        JCBlock closeResourceTryBlock =</b>
<b class="nc"><i>1661</i>&nbsp;            make.Block(0L, List.of(makeResourceCloseInvocation(resourceUse)));</b>
<b class="nc"><i>1662</i>&nbsp;        JCVariableDecl catchSuppressedDecl = make.VarDef(suppressedException, null);</b>
<b class="nc"><i>1663</i>&nbsp;        JCBlock catchSuppressedBlock = make.Block(0L, List.of(addSuppressedStatement));</b>
<b class="nc"><i>1664</i>&nbsp;        List&lt;JCCatch&gt; catchSuppressedClauses =</b>
<b class="nc"><i>1665</i>&nbsp;                List.of(make.Catch(catchSuppressedDecl, catchSuppressedBlock));</b>
<b class="nc"><i>1666</i>&nbsp;        JCTry closeResourceTry = make.Try(closeResourceTryBlock, catchSuppressedClauses, null);</b>
<b class="nc"><i>1667</i>&nbsp;        closeResourceTry.finallyCanCompleteNormally = true;</b>
<b class="nc"><i>1668</i>&nbsp;</b>
<i>1669</i>&nbsp;        JCStatement exceptionalCloseStatement = closeResourceTry;
<b class="nc"><i>1670</i>&nbsp;</b>
<i>1671</i>&nbsp;        if (!resourceNonNull) {
<b class="nc"><i>1672</i>&nbsp;            // if (#resource != null) {  }</b>
<i>1673</i>&nbsp;            exceptionalCloseStatement = make.If(makeNonNullCheck(resourceUse),
<i>1674</i>&nbsp;                                                exceptionalCloseStatement,
<b class="nc"><i>1675</i>&nbsp;                                                null);</b>
<b class="nc"><i>1676</i>&nbsp;        }</b>
<b class="nc"><i>1677</i>&nbsp;</b>
<b class="nc"><i>1678</i>&nbsp;        JCStatement exceptionalRethrow = make.Throw(make.Ident(primaryException));</b>
<b class="nc"><i>1679</i>&nbsp;        JCBlock exceptionalCloseBlock = make.Block(0L, List.of(exceptionalCloseStatement, exceptionalRethrow));</b>
<i>1680</i>&nbsp;        JCCatch exceptionalCatchClause = make.Catch(primaryExceptionDecl, exceptionalCloseBlock);
<i>1681</i>&nbsp;
<i>1682</i>&nbsp;        //create the main try statement with the close:
<b class="nc"><i>1683</i>&nbsp;        JCTry outerTry = make.Try(makeTwrBlock(resources.tail, block, depth + 1),</b>
<i>1684</i>&nbsp;                                  List.of(exceptionalCatchClause),
<b class="nc"><i>1685</i>&nbsp;                                  finallyClause);</b>
<i>1686</i>&nbsp;
<i>1687</i>&nbsp;        outerTry.finallyCanCompleteNormally = true;
<i>1688</i>&nbsp;        stats.add(outerTry);
<b class="nc"><i>1689</i>&nbsp;</b>
<b class="nc"><i>1690</i>&nbsp;        JCBlock newBlock = make.Block(0L, stats.toList());</b>
<b class="nc"><i>1691</i>&nbsp;        return newBlock;</b>
<i>1692</i>&nbsp;    }
<i>1693</i>&nbsp;
<b class="nc"><i>1694</i>&nbsp;    private JCStatement makeResourceCloseInvocation(JCExpression resource) {</b>
<i>1695</i>&nbsp;        // convert to AutoCloseable if needed
<b class="nc"><i>1696</i>&nbsp;        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {</b>
<b class="nc"><i>1697</i>&nbsp;            resource = convert(resource, syms.autoCloseableType);</b>
<i>1698</i>&nbsp;        }
<i>1699</i>&nbsp;
<b class="nc"><i>1700</i>&nbsp;        // create resource.close() method invocation</b>
<b class="nc"><i>1701</i>&nbsp;        JCExpression resourceClose = makeCall(resource,</b>
<b class="nc"><i>1702</i>&nbsp;                                              names.close,</b>
<b class="nc"><i>1703</i>&nbsp;                                              List.nil());</b>
<b class="nc"><i>1704</i>&nbsp;        return make.Exec(resourceClose);</b>
<i>1705</i>&nbsp;    }
<b class="nc"><i>1706</i>&nbsp;</b>
<b class="nc"><i>1707</i>&nbsp;    private JCExpression makeNonNullCheck(JCExpression expression) {</b>
<b class="nc"><i>1708</i>&nbsp;        return makeBinary(NE, expression, makeNull());</b>
<b class="nc"><i>1709</i>&nbsp;    }</b>
<b class="nc"><i>1710</i>&nbsp;</b>
<i>1711</i>&nbsp;    /** Construct a tree that represents the outer instance
<b class="nc"><i>1712</i>&nbsp;     *  {@code C.this}. Never pick the current `this&#39;.</b>
<i>1713</i>&nbsp;     *  @param pos           The source code position to be used for the tree.
<b class="nc"><i>1714</i>&nbsp;     *  @param c             The qualifier class.</b>
<b class="nc"><i>1715</i>&nbsp;     */</b>
<b class="nc"><i>1716</i>&nbsp;    JCExpression makeOuterThis(DiagnosticPosition pos, TypeSymbol c) {</b>
<b class="nc"><i>1717</i>&nbsp;        List&lt;VarSymbol&gt; ots = outerThisStack;</b>
<i>1718</i>&nbsp;        if (ots.isEmpty()) {
<i>1719</i>&nbsp;            log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
<i>1720</i>&nbsp;            Assert.error();
<i>1721</i>&nbsp;            return makeNull();
<b class="nc"><i>1722</i>&nbsp;        }</b>
<b class="nc"><i>1723</i>&nbsp;        VarSymbol ot = ots.head;</b>
<i>1724</i>&nbsp;        JCExpression tree = access(make.at(pos).Ident(ot));
<i>1725</i>&nbsp;        TypeSymbol otc = ot.type.tsym;
<b class="nc"><i>1726</i>&nbsp;        while (otc != c) {</b>
<b class="nc"><i>1727</i>&nbsp;            do {</b>
<i>1728</i>&nbsp;                ots = ots.tail;
<b class="nc"><i>1729</i>&nbsp;                if (ots.isEmpty()) {</b>
<i>1730</i>&nbsp;                    log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));
<i>1731</i>&nbsp;                    Assert.error(); // should have been caught in Attr
<b class="nc"><i>1732</i>&nbsp;                    return tree;</b>
<b class="nc"><i>1733</i>&nbsp;                }</b>
<b class="nc"><i>1734</i>&nbsp;                ot = ots.head;</b>
<b class="nc"><i>1735</i>&nbsp;            } while (ot.owner != otc);</b>
<b class="nc"><i>1736</i>&nbsp;            if (otc.owner.kind != PCK &amp;&amp; !otc.hasOuterInstance()) {</b>
<b class="nc"><i>1737</i>&nbsp;                chk.earlyRefError(pos, c);</b>
<b class="nc"><i>1738</i>&nbsp;                Assert.error(); // should have been caught in Attr</b>
<i>1739</i>&nbsp;                return makeNull();
<i>1740</i>&nbsp;            }
<b class="nc"><i>1741</i>&nbsp;            tree = access(make.at(pos).Select(tree, ot));</b>
<i>1742</i>&nbsp;            otc = ot.type.tsym;
<b class="nc"><i>1743</i>&nbsp;        }</b>
<i>1744</i>&nbsp;        return tree;
<i>1745</i>&nbsp;    }
<b class="nc"><i>1746</i>&nbsp;</b>
<b class="nc"><i>1747</i>&nbsp;    /** Construct a tree that represents the closest outer instance</b>
<i>1748</i>&nbsp;     *  {@code C.this} such that the given symbol is a member of C.
<i>1749</i>&nbsp;     *  @param pos           The source code position to be used for the tree.
<i>1750</i>&nbsp;     *  @param sym           The accessed symbol.
<i>1751</i>&nbsp;     *  @param preciseMatch  should we accept a type that is a subtype of
<i>1752</i>&nbsp;     *                       sym&#39;s owner, even if it doesn&#39;t contain sym
<i>1753</i>&nbsp;     *                       due to hiding, overriding, or non-inheritance
<b class="nc"><i>1754</i>&nbsp;     *                       due to protection?</b>
<b class="nc"><i>1755</i>&nbsp;     */</b>
<i>1756</i>&nbsp;    JCExpression makeOwnerThis(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
<i>1757</i>&nbsp;        Symbol c = sym.owner;
<i>1758</i>&nbsp;        if (preciseMatch ? sym.isMemberOf(currentClass, types)
<b class="nc"><i>1759</i>&nbsp;                         : currentClass.isSubClass(sym.owner, types)) {</b>
<i>1760</i>&nbsp;            // in this case, `this&#39; works fine
<b class="nc"><i>1761</i>&nbsp;            return make.at(pos).This(c.erasure(types));</b>
<b class="nc"><i>1762</i>&nbsp;        } else {</b>
<i>1763</i>&nbsp;            // need to go via this$n
<i>1764</i>&nbsp;            return makeOwnerThisN(pos, sym, preciseMatch);
<i>1765</i>&nbsp;        }
<b class="nc"><i>1766</i>&nbsp;    }</b>
<i>1767</i>&nbsp;
<i>1768</i>&nbsp;    /**
<i>1769</i>&nbsp;     * Similar to makeOwnerThis but will never pick &quot;this&quot;.
<i>1770</i>&nbsp;     */
<i>1771</i>&nbsp;    JCExpression makeOwnerThisN(DiagnosticPosition pos, Symbol sym, boolean preciseMatch) {
<i>1772</i>&nbsp;        Symbol c = sym.owner;
<i>1773</i>&nbsp;        List&lt;VarSymbol&gt; ots = outerThisStack;
<i>1774</i>&nbsp;        if (ots.isEmpty()) {
<b class="nc"><i>1775</i>&nbsp;            log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));</b>
<b class="nc"><i>1776</i>&nbsp;            Assert.error();</b>
<b class="nc"><i>1777</i>&nbsp;            return makeNull();</b>
<b class="nc"><i>1778</i>&nbsp;        }</b>
<b class="nc"><i>1779</i>&nbsp;        VarSymbol ot = ots.head;</b>
<i>1780</i>&nbsp;        JCExpression tree = access(make.at(pos).Ident(ot));
<b class="nc"><i>1781</i>&nbsp;        TypeSymbol otc = ot.type.tsym;</b>
<b class="nc"><i>1782</i>&nbsp;        while (!(preciseMatch ? sym.isMemberOf(otc, types) : otc.isSubClass(sym.owner, types))) {</b>
<b class="nc"><i>1783</i>&nbsp;            do {</b>
<b class="nc"><i>1784</i>&nbsp;                ots = ots.tail;</b>
<i>1785</i>&nbsp;                if (ots.isEmpty()) {
<b class="nc"><i>1786</i>&nbsp;                    log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));</b>
<b class="nc"><i>1787</i>&nbsp;                    Assert.error();</b>
<b class="nc"><i>1788</i>&nbsp;                    return tree;</b>
<i>1789</i>&nbsp;                }
<i>1790</i>&nbsp;                ot = ots.head;
<b class="nc"><i>1791</i>&nbsp;            } while (ot.owner != otc);</b>
<b class="nc"><i>1792</i>&nbsp;            tree = access(make.at(pos).Select(tree, ot));</b>
<i>1793</i>&nbsp;            otc = ot.type.tsym;
<b class="nc"><i>1794</i>&nbsp;        }</b>
<b class="nc"><i>1795</i>&nbsp;        return tree;</b>
<b class="nc"><i>1796</i>&nbsp;    }</b>
<b class="nc"><i>1797</i>&nbsp;</b>
<b class="nc"><i>1798</i>&nbsp;    /** Return tree simulating the assignment {@code this.name = name}, where</b>
<b class="nc"><i>1799</i>&nbsp;     *  name is the name of a free variable.</b>
<i>1800</i>&nbsp;     */
<b class="nc"><i>1801</i>&nbsp;    JCStatement initField(int pos, Symbol rhs, Symbol lhs) {</b>
<b class="nc"><i>1802</i>&nbsp;        Assert.check(rhs.owner.kind == MTH);</b>
<i>1803</i>&nbsp;        Assert.check(rhs.owner.owner == lhs.owner);
<b class="nc"><i>1804</i>&nbsp;        make.at(pos);</b>
<i>1805</i>&nbsp;        return
<i>1806</i>&nbsp;            make.Exec(
<i>1807</i>&nbsp;                make.Assign(
<i>1808</i>&nbsp;                    make.Select(make.This(lhs.owner.erasure(types)), lhs),
<i>1809</i>&nbsp;                    make.Ident(rhs)).setType(lhs.erasure(types)));
<i>1810</i>&nbsp;    }
<i>1811</i>&nbsp;
<i>1812</i>&nbsp;    /** Return tree simulating the assignment {@code this.this$n = this$n}.
<i>1813</i>&nbsp;     */
<i>1814</i>&nbsp;    JCStatement initOuterThis(int pos) {
<i>1815</i>&nbsp;        VarSymbol rhs = outerThisStack.head;
<i>1816</i>&nbsp;        Assert.check(rhs.owner.kind == MTH);
<b class="nc"><i>1817</i>&nbsp;        VarSymbol lhs = outerThisStack.tail.head;</b>
<b class="nc"><i>1818</i>&nbsp;        Assert.check(rhs.owner.owner == lhs.owner);</b>
<b class="nc"><i>1819</i>&nbsp;        make.at(pos);</b>
<i>1820</i>&nbsp;        return
<b class="nc"><i>1821</i>&nbsp;            make.Exec(</b>
<i>1822</i>&nbsp;                make.Assign(
<i>1823</i>&nbsp;                    make.Select(make.This(lhs.owner.erasure(types)), lhs),
<b class="nc"><i>1824</i>&nbsp;                    make.Ident(rhs)).setType(lhs.erasure(types)));</b>
<i>1825</i>&nbsp;    }
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;/**************************************************************************
<i>1828</i>&nbsp; * Code for .class
<i>1829</i>&nbsp; *************************************************************************/
<i>1830</i>&nbsp;
<i>1831</i>&nbsp;    /** Return the symbol of a class to contain a cache of
<b class="nc"><i>1832</i>&nbsp;     *  compiler-generated statics such as class$ and the</b>
<b class="nc"><i>1833</i>&nbsp;     *  $assertionsDisabled flag.  We create an anonymous nested class</b>
<b class="nc"><i>1834</i>&nbsp;     *  (unless one already exists) and return its symbol.  However,</b>
<b class="nc"><i>1835</i>&nbsp;     *  for backward compatibility in 1.4 and earlier we use the</b>
<b class="nc"><i>1836</i>&nbsp;     *  top-level class itself.</b>
<b class="nc"><i>1837</i>&nbsp;     */</b>
<i>1838</i>&nbsp;    private ClassSymbol outerCacheClass() {
<b class="nc"><i>1839</i>&nbsp;        ClassSymbol clazz = outermostClassDef.sym;</b>
<b class="nc"><i>1840</i>&nbsp;        Scope s = clazz.members();</b>
<b class="nc"><i>1841</i>&nbsp;        for (Symbol sym : s.getSymbols(NON_RECURSIVE))</b>
<b class="nc"><i>1842</i>&nbsp;            if (sym.kind == TYP &amp;&amp;</b>
<i>1843</i>&nbsp;                sym.name == names.empty &amp;&amp;
<b class="nc"><i>1844</i>&nbsp;                (sym.flags() &amp; INTERFACE) == 0) return (ClassSymbol) sym;</b>
<b class="nc"><i>1845</i>&nbsp;        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;</b>
<b class="nc"><i>1846</i>&nbsp;    }</b>
<i>1847</i>&nbsp;
<i>1848</i>&nbsp;    /** Create an attributed tree of the form left.name(). */
<b class="nc"><i>1849</i>&nbsp;    private JCMethodInvocation makeCall(JCExpression left, Name name, List&lt;JCExpression&gt; args) {</b>
<b class="nc"><i>1850</i>&nbsp;        Assert.checkNonNull(left.type);</b>
<i>1851</i>&nbsp;        Symbol funcsym = lookupMethod(make_pos, name, left.type,
<b class="nc"><i>1852</i>&nbsp;                                      TreeInfo.types(args));</b>
<b class="nc"><i>1853</i>&nbsp;        return make.App(make.Select(left, funcsym), args);</b>
<b class="nc"><i>1854</i>&nbsp;    }</b>
<b class="nc"><i>1855</i>&nbsp;</b>
<i>1856</i>&nbsp;    /** The tree simulating a T.class expression.
<b class="nc"><i>1857</i>&nbsp;     *  @param clazz      The tree identifying type T.</b>
<i>1858</i>&nbsp;     */
<i>1859</i>&nbsp;    private JCExpression classOf(JCTree clazz) {
<i>1860</i>&nbsp;        return classOfType(clazz.type, clazz.pos());
<i>1861</i>&nbsp;    }
<i>1862</i>&nbsp;
<i>1863</i>&nbsp;    private JCExpression classOfType(Type type, DiagnosticPosition pos) {
<b class="nc"><i>1864</i>&nbsp;        switch (type.getTag()) {</b>
<b class="nc"><i>1865</i>&nbsp;        case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:</b>
<b class="nc"><i>1866</i>&nbsp;        case DOUBLE: case BOOLEAN: case VOID:</b>
<b class="nc"><i>1867</i>&nbsp;            // replace with &lt;BoxedClass&gt;.TYPE</b>
<b class="nc"><i>1868</i>&nbsp;            ClassSymbol c = types.boxedClass(type);</b>
<b class="nc"><i>1869</i>&nbsp;            Symbol typeSym =</b>
<b class="nc"><i>1870</i>&nbsp;                rs.accessBase(</b>
<b class="nc"><i>1871</i>&nbsp;                    rs.findIdentInType(attrEnv, c.type, names.TYPE, KindSelector.VAR),</b>
<b class="nc"><i>1872</i>&nbsp;                    pos, c.type, names.TYPE, true);</b>
<b class="nc"><i>1873</i>&nbsp;            if (typeSym.kind == VAR)</b>
<b class="nc"><i>1874</i>&nbsp;                ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated</b>
<i>1875</i>&nbsp;            return make.QualIdent(typeSym);
<i>1876</i>&nbsp;        case CLASS: case ARRAY:
<i>1877</i>&nbsp;                VarSymbol sym = new VarSymbol(
<i>1878</i>&nbsp;                        STATIC | PUBLIC | FINAL, names._class,
<i>1879</i>&nbsp;                        syms.classType, type.tsym);
<b class="nc"><i>1880</i>&nbsp;                return make_at(pos).Select(make.Type(type), sym);</b>
<b class="nc"><i>1881</i>&nbsp;        default:</b>
<b class="nc"><i>1882</i>&nbsp;            throw new AssertionError();</b>
<b class="nc"><i>1883</i>&nbsp;        }</b>
<b class="nc"><i>1884</i>&nbsp;    }</b>
<b class="nc"><i>1885</i>&nbsp;</b>
<b class="nc"><i>1886</i>&nbsp;/**************************************************************************</b>
<b class="nc"><i>1887</i>&nbsp; * Code for enabling/disabling assertions.</b>
<b class="nc"><i>1888</i>&nbsp; *************************************************************************/</b>
<b class="nc"><i>1889</i>&nbsp;</b>
<i>1890</i>&nbsp;    private ClassSymbol assertionsDisabledClassCache;
<i>1891</i>&nbsp;
<i>1892</i>&nbsp;    /**Used to create an auxiliary class to hold $assertionsDisabled for interfaces.
<i>1893</i>&nbsp;     */
<i>1894</i>&nbsp;    private ClassSymbol assertionsDisabledClass() {
<i>1895</i>&nbsp;        if (assertionsDisabledClassCache != null) return assertionsDisabledClassCache;
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;
<i>1898</i>&nbsp;
<i>1899</i>&nbsp;        return assertionsDisabledClassCache;
<i>1900</i>&nbsp;    }
<i>1901</i>&nbsp;
<i>1902</i>&nbsp;    // This code is not particularly robust if the user has
<i>1903</i>&nbsp;    // previously declared a member named &#39;$assertionsDisabled&#39;.
<b class="nc"><i>1904</i>&nbsp;    // The same faulty idiom also appears in the translation of</b>
<b class="nc"><i>1905</i>&nbsp;    // class literals above.  We should report an error if a</b>
<b class="nc"><i>1906</i>&nbsp;    // previous declaration is not synthetic.</b>
<b class="nc"><i>1907</i>&nbsp;</b>
<b class="nc"><i>1908</i>&nbsp;    private JCExpression assertFlagTest(DiagnosticPosition pos) {</b>
<b class="nc"><i>1909</i>&nbsp;        // Outermost class may be either true class or an interface.</b>
<i>1910</i>&nbsp;        ClassSymbol outermostClass = outermostClassDef.sym;
<b class="nc"><i>1911</i>&nbsp;</b>
<b class="nc"><i>1912</i>&nbsp;        //only classes can hold a non-public field, look for a usable one:</b>
<i>1913</i>&nbsp;        ClassSymbol container = !currentClass.isInterface() ? currentClass :
<i>1914</i>&nbsp;                assertionsDisabledClass();
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;        VarSymbol assertDisabledSym =
<i>1917</i>&nbsp;            (VarSymbol)lookupSynthetic(dollarAssertionsDisabled,
<i>1918</i>&nbsp;                                       container.members());
<i>1919</i>&nbsp;        if (assertDisabledSym == null) {
<i>1920</i>&nbsp;            assertDisabledSym =
<i>1921</i>&nbsp;                new VarSymbol(STATIC | FINAL | SYNTHETIC,
<i>1922</i>&nbsp;                              dollarAssertionsDisabled,
<i>1923</i>&nbsp;                              syms.booleanType,
<i>1924</i>&nbsp;                              container);
<i>1925</i>&nbsp;            enterSynthetic(pos, assertDisabledSym, container.members());
<i>1926</i>&nbsp;            Symbol desiredAssertionStatusSym = lookupMethod(pos,
<b class="nc"><i>1927</i>&nbsp;                                                            names.desiredAssertionStatus,</b>
<b class="nc"><i>1928</i>&nbsp;                                                            types.erasure(syms.classType),</b>
<b class="nc"><i>1929</i>&nbsp;                                                            List.nil());</b>
<b class="nc"><i>1930</i>&nbsp;            JCClassDecl containerDef = classDef(container);</b>
<b class="nc"><i>1931</i>&nbsp;            make_at(containerDef.pos());</b>
<b class="nc"><i>1932</i>&nbsp;            JCExpression notStatus = makeUnary(NOT, make.App(make.Select(</b>
<i>1933</i>&nbsp;                    classOfType(types.erasure(outermostClass.type),
<i>1934</i>&nbsp;                                containerDef.pos()),
<i>1935</i>&nbsp;                    desiredAssertionStatusSym)));
<b class="nc"><i>1936</i>&nbsp;            JCVariableDecl assertDisabledDef = make.VarDef(assertDisabledSym,</b>
<b class="nc"><i>1937</i>&nbsp;                                                   notStatus);</b>
<b class="nc"><i>1938</i>&nbsp;            containerDef.defs = containerDef.defs.prepend(assertDisabledDef);</b>
<i>1939</i>&nbsp;
<i>1940</i>&nbsp;            if (currentClass.isInterface()) {
<b class="nc"><i>1941</i>&nbsp;                //need to load the assertions enabled/disabled state while</b>
<i>1942</i>&nbsp;                //initializing the interface:
<b class="nc"><i>1943</i>&nbsp;                JCClassDecl currentClassDef = classDef(currentClass);</b>
<i>1944</i>&nbsp;                make_at(currentClassDef.pos());
<b class="nc"><i>1945</i>&nbsp;                JCStatement dummy = make.If(make.QualIdent(assertDisabledSym), make.Skip(), null);</b>
<b class="nc"><i>1946</i>&nbsp;                JCBlock clinit = make.Block(STATIC, List.of(dummy));</b>
<b class="nc"><i>1947</i>&nbsp;                currentClassDef.defs = currentClassDef.defs.prepend(clinit);</b>
<b class="nc"><i>1948</i>&nbsp;            }</b>
<b class="nc"><i>1949</i>&nbsp;        }</b>
<b class="nc"><i>1950</i>&nbsp;        make_at(pos);</b>
<b class="nc"><i>1951</i>&nbsp;        return makeUnary(NOT, make.Ident(assertDisabledSym));</b>
<i>1952</i>&nbsp;    }
<b class="nc"><i>1953</i>&nbsp;</b>
<i>1954</i>&nbsp;
<i>1955</i>&nbsp;/**************************************************************************
<i>1956</i>&nbsp; * Building blocks for let expressions
<i>1957</i>&nbsp; *************************************************************************/
<b class="nc"><i>1958</i>&nbsp;</b>
<b class="nc"><i>1959</i>&nbsp;    interface TreeBuilder {</b>
<i>1960</i>&nbsp;        JCExpression build(JCExpression arg);
<i>1961</i>&nbsp;    }
<i>1962</i>&nbsp;
<i>1963</i>&nbsp;    /** Construct an expression using the builder, with the given rval
<i>1964</i>&nbsp;     *  expression as an argument to the builder.  However, the rval
<i>1965</i>&nbsp;     *  expression must be computed only once, even if used multiple
<b class="nc"><i>1966</i>&nbsp;     *  times in the result of the builder.  We do that by</b>
<i>1967</i>&nbsp;     *  constructing a &quot;let&quot; expression that saves the rvalue into a
<b class="nc"><i>1968</i>&nbsp;     *  temporary variable and then uses the temporary variable in</b>
<b class="nc"><i>1969</i>&nbsp;     *  place of the expression built by the builder.  The complete</b>
<i>1970</i>&nbsp;     *  resulting expression is of the form
<i>1971</i>&nbsp;     *  &lt;pre&gt;
<b class="nc"><i>1972</i>&nbsp;     *    (let &lt;b&gt;TYPE&lt;/b&gt; &lt;b&gt;TEMP&lt;/b&gt; = &lt;b&gt;RVAL&lt;/b&gt;;</b>
<i>1973</i>&nbsp;     *     in (&lt;b&gt;BUILDER&lt;/b&gt;(&lt;b&gt;TEMP&lt;/b&gt;)))
<i>1974</i>&nbsp;     *  &lt;/pre&gt;
<b class="nc"><i>1975</i>&nbsp;     *  where &lt;code&gt;&lt;b&gt;TEMP&lt;/b&gt;&lt;/code&gt; is a newly declared variable</b>
<b class="nc"><i>1976</i>&nbsp;     *  in the let expression.</b>
<b class="nc"><i>1977</i>&nbsp;     */</b>
<i>1978</i>&nbsp;    JCExpression abstractRval(JCExpression rval, Type type, TreeBuilder builder) {
<i>1979</i>&nbsp;        rval = TreeInfo.skipParens(rval);
<b class="nc"><i>1980</i>&nbsp;        switch (rval.getTag()) {</b>
<b class="nc"><i>1981</i>&nbsp;        case LITERAL:</b>
<b class="nc"><i>1982</i>&nbsp;            return builder.build(rval);</b>
<i>1983</i>&nbsp;        case IDENT:
<b class="nc"><i>1984</i>&nbsp;            JCIdent id = (JCIdent) rval;</b>
<i>1985</i>&nbsp;            if ((id.sym.flags() &amp; FINAL) != 0 &amp;&amp; id.sym.owner.kind == MTH)
<i>1986</i>&nbsp;                return builder.build(rval);
<i>1987</i>&nbsp;        }
<i>1988</i>&nbsp;        Name name = TreeInfo.name(rval);
<b class="nc"><i>1989</i>&nbsp;        if (name == names._super || name == names._this)</b>
<b class="nc"><i>1990</i>&nbsp;            return builder.build(rval);</b>
<b class="nc"><i>1991</i>&nbsp;        VarSymbol var =</b>
<i>1992</i>&nbsp;            new VarSymbol(FINAL|SYNTHETIC,
<i>1993</i>&nbsp;                          names.fromString(
<i>1994</i>&nbsp;                                          target.syntheticNameChar()
<i>1995</i>&nbsp;                                          + &quot;&quot; + rval.hashCode()),
<b class="nc"><i>1996</i>&nbsp;                                      type,</b>
<b class="nc"><i>1997</i>&nbsp;                                      currentMethodSym);</b>
<b class="nc"><i>1998</i>&nbsp;        rval = convert(rval,type);</b>
<b class="nc"><i>1999</i>&nbsp;        JCVariableDecl def = make.VarDef(var, rval); // XXX cast</b>
<b class="nc"><i>2000</i>&nbsp;        JCExpression built = builder.build(make.Ident(var));</b>
<b class="nc"><i>2001</i>&nbsp;        JCExpression res = make.LetExpr(def, built);</b>
<b class="nc"><i>2002</i>&nbsp;        res.type = built.type;</b>
<i>2003</i>&nbsp;        return res;
<b class="nc"><i>2004</i>&nbsp;    }</b>
<i>2005</i>&nbsp;
<b class="nc"><i>2006</i>&nbsp;    // same as above, with the type of the temporary variable computed</b>
<i>2007</i>&nbsp;    JCExpression abstractRval(JCExpression rval, TreeBuilder builder) {
<b class="nc"><i>2008</i>&nbsp;        return abstractRval(rval, rval.type, builder);</b>
<b class="nc"><i>2009</i>&nbsp;    }</b>
<i>2010</i>&nbsp;
<i>2011</i>&nbsp;    // same as above, but for an expression that may be used as either
<b class="nc"><i>2012</i>&nbsp;    // an rvalue or an lvalue.  This requires special handling for</b>
<b class="nc"><i>2013</i>&nbsp;    // Select expressions, where we place the left-hand-side of the</b>
<i>2014</i>&nbsp;    // select in a temporary, and for Indexed expressions, where we
<b class="nc"><i>2015</i>&nbsp;    // place both the indexed expression and the index value in temps.</b>
<b class="nc"><i>2016</i>&nbsp;    JCExpression abstractLval(JCExpression lval, final TreeBuilder builder) {</b>
<b class="nc"><i>2017</i>&nbsp;        lval = TreeInfo.skipParens(lval);</b>
<b class="nc"><i>2018</i>&nbsp;        switch (lval.getTag()) {</b>
<b class="nc"><i>2019</i>&nbsp;        case IDENT:</b>
<b class="nc"><i>2020</i>&nbsp;            return builder.build(lval);</b>
<i>2021</i>&nbsp;        case SELECT: {
<b class="nc"><i>2022</i>&nbsp;            final JCFieldAccess s = (JCFieldAccess)lval;</b>
<i>2023</i>&nbsp;            Symbol lid = TreeInfo.symbol(s.selected);
<b class="nc"><i>2024</i>&nbsp;            if (lid != null &amp;&amp; lid.kind == TYP) return builder.build(lval);</b>
<b class="nc"><i>2025</i>&nbsp;            return abstractRval(s.selected, selected -&gt; builder.build(make.Select(selected, s.sym)));</b>
<i>2026</i>&nbsp;        }
<b class="nc"><i>2027</i>&nbsp;        case INDEXED: {</b>
<b class="nc"><i>2028</i>&nbsp;            final JCArrayAccess i = (JCArrayAccess)lval;</b>
<b class="nc"><i>2029</i>&nbsp;            return abstractRval(i.indexed, indexed -&gt; abstractRval(i.index, syms.intType, index -&gt; {</b>
<b class="nc"><i>2030</i>&nbsp;                JCExpression newLval = make.Indexed(indexed, index);</b>
<b class="nc"><i>2031</i>&nbsp;                newLval.setType(i.type);</b>
<b class="nc"><i>2032</i>&nbsp;                return builder.build(newLval);</b>
<b class="nc"><i>2033</i>&nbsp;            }));</b>
<i>2034</i>&nbsp;        }
<i>2035</i>&nbsp;        case TYPECAST: {
<i>2036</i>&nbsp;            return abstractLval(((JCTypeCast)lval).expr, builder);
<i>2037</i>&nbsp;        }
<b class="nc"><i>2038</i>&nbsp;        }</b>
<b class="nc"><i>2039</i>&nbsp;        throw new AssertionError(lval);</b>
<i>2040</i>&nbsp;    }
<i>2041</i>&nbsp;
<i>2042</i>&nbsp;    // evaluate and discard the first expression, then evaluate the second.
<i>2043</i>&nbsp;    JCExpression makeComma(final JCExpression expr1, final JCExpression expr2) {
<b class="nc"><i>2044</i>&nbsp;        return abstractRval(expr1, discarded -&gt; expr2);</b>
<i>2045</i>&nbsp;    }
<b class="nc"><i>2046</i>&nbsp;</b>
<b class="nc"><i>2047</i>&nbsp;/**************************************************************************</b>
<b class="nc"><i>2048</i>&nbsp; * Translation methods</b>
<i>2049</i>&nbsp; *************************************************************************/
<b class="nc"><i>2050</i>&nbsp;</b>
<b class="nc"><i>2051</i>&nbsp;    /** Visitor argument: enclosing operator node.</b>
<b class="nc"><i>2052</i>&nbsp;     */</b>
<i>2053</i>&nbsp;    private JCExpression enclOp;
<b class="nc"><i>2054</i>&nbsp;</b>
<i>2055</i>&nbsp;    /** Visitor method: Translate a single node.
<i>2056</i>&nbsp;     *  Attach the source position from the old tree to its replacement tree.
<b class="nc"><i>2057</i>&nbsp;     */</b>
<i>2058</i>&nbsp;    @Override
<b class="nc"><i>2059</i>&nbsp;    public &lt;T extends JCTree&gt; T translate(T tree) {</b>
<b class="nc"><i>2060</i>&nbsp;        if (tree == null) {</b>
<b class="nc"><i>2061</i>&nbsp;            return null;</b>
<i>2062</i>&nbsp;        } else {
<b class="nc"><i>2063</i>&nbsp;            make_at(tree.pos());</b>
<i>2064</i>&nbsp;            T result = super.translate(tree);
<i>2065</i>&nbsp;            if (endPosTable != null &amp;&amp; result != tree) {
<i>2066</i>&nbsp;                endPosTable.replaceTree(tree, result);
<b class="nc"><i>2067</i>&nbsp;            }</b>
<i>2068</i>&nbsp;            return result;
<i>2069</i>&nbsp;        }
<b class="nc"><i>2070</i>&nbsp;    }</b>
<i>2071</i>&nbsp;
<i>2072</i>&nbsp;    /** Visitor method: Translate a single node, boxing or unboxing if needed.
<i>2073</i>&nbsp;     */
<b class="nc"><i>2074</i>&nbsp;    public &lt;T extends JCExpression&gt; T translate(T tree, Type type) {</b>
<b class="nc"><i>2075</i>&nbsp;        return (tree == null) ? null : boxIfNeeded(translate(tree), type);</b>
<i>2076</i>&nbsp;    }
<b class="nc"><i>2077</i>&nbsp;</b>
<i>2078</i>&nbsp;    /** Visitor method: Translate tree.
<i>2079</i>&nbsp;     */
<i>2080</i>&nbsp;    public &lt;T extends JCTree&gt; T translate(T tree, JCExpression enclOp) {
<i>2081</i>&nbsp;        JCExpression prevEnclOp = this.enclOp;
<b class="nc"><i>2082</i>&nbsp;        this.enclOp = enclOp;</b>
<b class="nc"><i>2083</i>&nbsp;        T res = translate(tree);</b>
<b class="nc"><i>2084</i>&nbsp;        this.enclOp = prevEnclOp;</b>
<b class="nc"><i>2085</i>&nbsp;        return res;</b>
<i>2086</i>&nbsp;    }
<i>2087</i>&nbsp;
<i>2088</i>&nbsp;    /** Visitor method: Translate list of trees.
<i>2089</i>&nbsp;     */
<i>2090</i>&nbsp;    public &lt;T extends JCExpression&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, Type type) {
<i>2091</i>&nbsp;        if (trees == null) return null;
<b class="nc"><i>2092</i>&nbsp;        for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)</b>
<b class="nc"><i>2093</i>&nbsp;            l.head = translate(l.head, type);</b>
<b class="nc"><i>2094</i>&nbsp;        return trees;</b>
<b class="nc"><i>2095</i>&nbsp;    }</b>
<b class="nc"><i>2096</i>&nbsp;</b>
<b class="nc"><i>2097</i>&nbsp;    public void visitPackageDef(JCPackageDecl tree) {</b>
<i>2098</i>&nbsp;        if (!needPackageInfoClass(tree))
<b class="nc"><i>2099</i>&nbsp;                        return;</b>
<b class="nc"><i>2100</i>&nbsp;</b>
<i>2101</i>&nbsp;        long flags = Flags.ABSTRACT | Flags.INTERFACE;
<i>2102</i>&nbsp;        // package-info is marked SYNTHETIC in JDK 1.6 and later releases
<b class="nc"><i>2103</i>&nbsp;        flags = flags | Flags.SYNTHETIC;</b>
<i>2104</i>&nbsp;        ClassSymbol c = tree.packge.package_info;
<b class="nc"><i>2105</i>&nbsp;        c.setAttributes(tree.packge);</b>
<b class="nc"><i>2106</i>&nbsp;        c.flags_field |= flags;</b>
<i>2107</i>&nbsp;        ClassType ctype = (ClassType) c.type;
<i>2108</i>&nbsp;        ctype.supertype_field = syms.objectType;
<i>2109</i>&nbsp;        ctype.interfaces_field = List.nil();
<i>2110</i>&nbsp;        createInfoClass(tree.annotations, c);
<i>2111</i>&nbsp;    }
<i>2112</i>&nbsp;    // where
<i>2113</i>&nbsp;    private boolean needPackageInfoClass(JCPackageDecl pd) {
<i>2114</i>&nbsp;        switch (pkginfoOpt) {
<b class="nc"><i>2115</i>&nbsp;            case ALWAYS:</b>
<b class="nc"><i>2116</i>&nbsp;                return true;</b>
<b class="nc"><i>2117</i>&nbsp;            case LEGACY:</b>
<b class="nc"><i>2118</i>&nbsp;                return pd.getAnnotations().nonEmpty();</b>
<b class="nc"><i>2119</i>&nbsp;            case NONEMPTY:</b>
<b class="nc"><i>2120</i>&nbsp;                for (Attribute.Compound a :</b>
<b class="nc"><i>2121</i>&nbsp;                         pd.packge.getDeclarationAttributes()) {</b>
<b class="nc"><i>2122</i>&nbsp;                    Attribute.RetentionPolicy p = types.getRetention(a);</b>
<i>2123</i>&nbsp;                    if (p != Attribute.RetentionPolicy.SOURCE)
<b class="nc"><i>2124</i>&nbsp;                        return true;</b>
<b class="nc"><i>2125</i>&nbsp;                }</b>
<b class="nc"><i>2126</i>&nbsp;                return false;</b>
<i>2127</i>&nbsp;        }
<b class="nc"><i>2128</i>&nbsp;        throw new AssertionError();</b>
<i>2129</i>&nbsp;    }
<i>2130</i>&nbsp;
<i>2131</i>&nbsp;    public void visitModuleDef(JCModuleDecl tree) {
<i>2132</i>&nbsp;        ModuleSymbol msym = tree.sym;
<i>2133</i>&nbsp;        ClassSymbol c = msym.module_info;
<i>2134</i>&nbsp;        c.setAttributes(msym);
<b class="nc"><i>2135</i>&nbsp;        c.flags_field |= Flags.MODULE;</b>
<i>2136</i>&nbsp;        createInfoClass(List.nil(), tree.sym.module_info);
<i>2137</i>&nbsp;    }
<i>2138</i>&nbsp;
<b class="nc"><i>2139</i>&nbsp;    private void createInfoClass(List&lt;JCAnnotation&gt; annots, ClassSymbol c) {</b>
<i>2140</i>&nbsp;        long flags = Flags.ABSTRACT | Flags.INTERFACE;
<i>2141</i>&nbsp;        JCClassDecl infoClass =
<i>2142</i>&nbsp;                make.ClassDef(make.Modifiers(flags, annots),
<b class="nc"><i>2143</i>&nbsp;                    c.name, List.nil(),</b>
<b class="nc"><i>2144</i>&nbsp;                    null, List.nil(), List.nil());</b>
<b class="nc"><i>2145</i>&nbsp;        infoClass.sym = c;</b>
<b class="nc"><i>2146</i>&nbsp;        translated.append(infoClass);</b>
<i>2147</i>&nbsp;    }
<b class="nc"><i>2148</i>&nbsp;</b>
<b class="nc"><i>2149</i>&nbsp;    public void visitClassDef(JCClassDecl tree) {</b>
<b class="nc"><i>2150</i>&nbsp;        Env&lt;AttrContext&gt; prevEnv = attrEnv;</b>
<i>2151</i>&nbsp;        ClassSymbol currentClassPrev = currentClass;
<b class="nc"><i>2152</i>&nbsp;        MethodSymbol currentMethodSymPrev = currentMethodSym;</b>
<b class="nc"><i>2153</i>&nbsp;</b>
<i>2154</i>&nbsp;        currentClass = tree.sym;
<i>2155</i>&nbsp;        currentMethodSym = null;
<b class="nc"><i>2156</i>&nbsp;        attrEnv = typeEnvs.remove(currentClass);</b>
<i>2157</i>&nbsp;        if (attrEnv == null)
<i>2158</i>&nbsp;            attrEnv = prevEnv;
<i>2159</i>&nbsp;
<i>2160</i>&nbsp;        classdefs.put(currentClass, tree);
<i>2161</i>&nbsp;
<b class="nc"><i>2162</i>&nbsp;        Map&lt;Symbol, Symbol&gt; prevProxies = proxies;</b>
<b class="nc"><i>2163</i>&nbsp;        proxies = new HashMap&lt;&gt;(proxies);</b>
<b class="nc"><i>2164</i>&nbsp;        List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;</b>
<b class="nc"><i>2165</i>&nbsp;</b>
<b class="nc"><i>2166</i>&nbsp;        // If this is an enum definition</b>
<b class="nc"><i>2167</i>&nbsp;        if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;</b>
<b class="nc"><i>2168</i>&nbsp;            (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)</b>
<b class="nc"><i>2169</i>&nbsp;            visitEnumDef(tree);</b>
<b class="nc"><i>2170</i>&nbsp;</b>
<b class="nc"><i>2171</i>&nbsp;        // If this is a nested class, define a this$n field for</b>
<b class="nc"><i>2172</i>&nbsp;        // it and add to proxies.</b>
<b class="nc"><i>2173</i>&nbsp;        JCVariableDecl otdef = null;</b>
<b class="nc"><i>2174</i>&nbsp;        if (currentClass.hasOuterInstance())</b>
<i>2175</i>&nbsp;            otdef = outerThisDef(tree.pos, currentClass);
<b class="nc"><i>2176</i>&nbsp;</b>
<i>2177</i>&nbsp;        // If this is a local class, define proxies for all its free variables.
<i>2178</i>&nbsp;        List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(
<i>2179</i>&nbsp;            tree.pos, freevars(currentClass), currentClass);
<i>2180</i>&nbsp;
<i>2181</i>&nbsp;        // Recursively translate superclass, interfaces.
<i>2182</i>&nbsp;        tree.extending = translate(tree.extending);
<i>2183</i>&nbsp;        tree.implementing = translate(tree.implementing);
<i>2184</i>&nbsp;
<i>2185</i>&nbsp;        if (currentClass.isLocal()) {
<i>2186</i>&nbsp;            ClassSymbol encl = currentClass.owner.enclClass();
<i>2187</i>&nbsp;            if (encl.trans_local == null) {
<i>2188</i>&nbsp;                encl.trans_local = List.nil();
<b class="nc"><i>2189</i>&nbsp;            }</b>
<i>2190</i>&nbsp;            encl.trans_local = encl.trans_local.prepend(currentClass);
<b class="nc"><i>2191</i>&nbsp;        }</b>
<i>2192</i>&nbsp;
<b class="nc"><i>2193</i>&nbsp;        // Recursively translate members, taking into account that new members</b>
<i>2194</i>&nbsp;        // might be created during the translation and prepended to the member
<i>2195</i>&nbsp;        // list `tree.defs&#39;.
<i>2196</i>&nbsp;        List&lt;JCTree&gt; seen = List.nil();
<i>2197</i>&nbsp;        while (tree.defs != seen) {
<i>2198</i>&nbsp;            List&lt;JCTree&gt; unseen = tree.defs;
<i>2199</i>&nbsp;            for (List&lt;JCTree&gt; l = unseen; l.nonEmpty() &amp;&amp; l != seen; l = l.tail) {
<i>2200</i>&nbsp;                JCTree outermostMemberDefPrev = outermostMemberDef;
<i>2201</i>&nbsp;                if (outermostMemberDefPrev == null) outermostMemberDef = l.head;
<i>2202</i>&nbsp;                l.head = translate(l.head);
<i>2203</i>&nbsp;                outermostMemberDef = outermostMemberDefPrev;
<b class="nc"><i>2204</i>&nbsp;            }</b>
<i>2205</i>&nbsp;            seen = unseen;
<i>2206</i>&nbsp;        }
<b class="nc"><i>2207</i>&nbsp;</b>
<b class="nc"><i>2208</i>&nbsp;        // Convert a protected modifier to public, mask static modifier.</b>
<i>2209</i>&nbsp;        if ((tree.mods.flags &amp; PROTECTED) != 0) tree.mods.flags |= PUBLIC;
<b class="nc"><i>2210</i>&nbsp;        tree.mods.flags &amp;= ClassFlags;</b>
<b class="nc"><i>2211</i>&nbsp;</b>
<b class="nc"><i>2212</i>&nbsp;        // Convert name to flat representation, replacing &#39;.&#39; by &#39;$&#39;.</b>
<b class="nc"><i>2213</i>&nbsp;        tree.name = Convert.shortName(currentClass.flatName());</b>
<b class="nc"><i>2214</i>&nbsp;</b>
<i>2215</i>&nbsp;        // Add this$n and free variables proxy definitions to class.
<i>2216</i>&nbsp;
<i>2217</i>&nbsp;        for (List&lt;JCVariableDecl&gt; l = fvdefs; l.nonEmpty(); l = l.tail) {
<i>2218</i>&nbsp;            tree.defs = tree.defs.prepend(l.head);
<b class="nc"><i>2219</i>&nbsp;            enterSynthetic(tree.pos(), l.head.sym, currentClass.members());</b>
<b class="nc"><i>2220</i>&nbsp;        }</b>
<i>2221</i>&nbsp;        if (currentClass.hasOuterInstance()) {
<b class="nc"><i>2222</i>&nbsp;            tree.defs = tree.defs.prepend(otdef);</b>
<b class="nc"><i>2223</i>&nbsp;            enterSynthetic(tree.pos(), otdef.sym, currentClass.members());</b>
<b class="nc"><i>2224</i>&nbsp;        }</b>
<b class="nc"><i>2225</i>&nbsp;</b>
<b class="nc"><i>2226</i>&nbsp;        proxies = prevProxies;</b>
<b class="nc"><i>2227</i>&nbsp;        outerThisStack = prevOuterThisStack;</b>
<b class="nc"><i>2228</i>&nbsp;</b>
<i>2229</i>&nbsp;        // Append translated tree to `translated&#39; queue.
<b class="nc"><i>2230</i>&nbsp;        translated.append(tree);</b>
<i>2231</i>&nbsp;
<b class="nc"><i>2232</i>&nbsp;        attrEnv = prevEnv;</b>
<i>2233</i>&nbsp;        currentClass = currentClassPrev;
<b class="nc"><i>2234</i>&nbsp;        currentMethodSym = currentMethodSymPrev;</b>
<i>2235</i>&nbsp;
<i>2236</i>&nbsp;        // Return empty block {} as a placeholder for an inner class.
<b class="nc"><i>2237</i>&nbsp;        result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());</b>
<b class="nc"><i>2238</i>&nbsp;    }</b>
<b class="nc"><i>2239</i>&nbsp;</b>
<b class="nc"><i>2240</i>&nbsp;    /** Translate an enum class. */</b>
<b class="nc"><i>2241</i>&nbsp;    private void visitEnumDef(JCClassDecl tree) {</b>
<i>2242</i>&nbsp;        make_at(tree.pos());
<i>2243</i>&nbsp;
<b class="nc"><i>2244</i>&nbsp;        // add the supertype, if needed</b>
<b class="nc"><i>2245</i>&nbsp;        if (tree.extending == null)</b>
<i>2246</i>&nbsp;            tree.extending = make.Type(types.supertype(tree.type));
<i>2247</i>&nbsp;
<i>2248</i>&nbsp;        // classOfType adds a cache field to tree.defs
<i>2249</i>&nbsp;        JCExpression e_class = classOfType(tree.sym.type, tree.pos()).
<i>2250</i>&nbsp;            setType(types.erasure(syms.classType));
<i>2251</i>&nbsp;
<i>2252</i>&nbsp;        // process each enumeration constant, adding implicit constructor parameters
<i>2253</i>&nbsp;        int nextOrdinal = 0;
<i>2254</i>&nbsp;        ListBuffer&lt;JCExpression&gt; values = new ListBuffer&lt;&gt;();
<i>2255</i>&nbsp;        ListBuffer&lt;JCTree&gt; enumDefs = new ListBuffer&lt;&gt;();
<i>2256</i>&nbsp;        ListBuffer&lt;JCTree&gt; otherDefs = new ListBuffer&lt;&gt;();
<i>2257</i>&nbsp;        for (List&lt;JCTree&gt; defs = tree.defs;
<i>2258</i>&nbsp;             defs.nonEmpty();
<i>2259</i>&nbsp;             defs=defs.tail) {
<i>2260</i>&nbsp;            if (defs.head.hasTag(VARDEF) &amp;&amp; (((JCVariableDecl) defs.head).mods.flags &amp; ENUM) != 0) {
<i>2261</i>&nbsp;                JCVariableDecl var = (JCVariableDecl)defs.head;
<i>2262</i>&nbsp;                visitEnumConstantDef(var, nextOrdinal++);
<i>2263</i>&nbsp;                values.append(make.QualIdent(var.sym));
<i>2264</i>&nbsp;                enumDefs.append(var);
<i>2265</i>&nbsp;            } else {
<i>2266</i>&nbsp;                otherDefs.append(defs.head);
<i>2267</i>&nbsp;            }
<i>2268</i>&nbsp;        }
<i>2269</i>&nbsp;
<i>2270</i>&nbsp;        // private static final T[] #VALUES = { a, b, c };
<i>2271</i>&nbsp;        Name valuesName = names.fromString(target.syntheticNameChar() + &quot;VALUES&quot;);
<i>2272</i>&nbsp;        while (tree.sym.members().findFirst(valuesName) != null) // avoid name clash
<b class="nc"><i>2273</i>&nbsp;            valuesName = names.fromString(valuesName + &quot;&quot; + target.syntheticNameChar());</b>
<b class="nc"><i>2274</i>&nbsp;        Type arrayType = new ArrayType(types.erasure(tree.type), syms.arrayClass);</b>
<i>2275</i>&nbsp;        VarSymbol valuesVar = new VarSymbol(PRIVATE|FINAL|STATIC|SYNTHETIC,
<b class="nc"><i>2276</i>&nbsp;                                            valuesName,</b>
<i>2277</i>&nbsp;                                            arrayType,
<b class="nc"><i>2278</i>&nbsp;                                            tree.type.tsym);</b>
<b class="nc"><i>2279</i>&nbsp;        JCNewArray newArray = make.NewArray(make.Type(types.erasure(tree.type)),</b>
<b class="nc"><i>2280</i>&nbsp;                                          List.nil(),</b>
<i>2281</i>&nbsp;                                          values.toList());
<b class="nc"><i>2282</i>&nbsp;        newArray.type = arrayType;</b>
<i>2283</i>&nbsp;        enumDefs.append(make.VarDef(valuesVar, newArray));
<b class="nc"><i>2284</i>&nbsp;        tree.sym.members().enter(valuesVar);</b>
<b class="nc"><i>2285</i>&nbsp;</b>
<b class="nc"><i>2286</i>&nbsp;        Symbol valuesSym = lookupMethod(tree.pos(), names.values,</b>
<i>2287</i>&nbsp;                                        tree.type, List.nil());
<i>2288</i>&nbsp;        List&lt;JCStatement&gt; valuesBody;
<b class="nc"><i>2289</i>&nbsp;        if (useClone()) {</b>
<b class="nc"><i>2290</i>&nbsp;            // return (T[]) $VALUES.clone();</b>
<b class="nc"><i>2291</i>&nbsp;            JCTypeCast valuesResult =</b>
<b class="nc"><i>2292</i>&nbsp;                make.TypeCast(valuesSym.type.getReturnType(),</b>
<b class="nc"><i>2293</i>&nbsp;                              make.App(make.Select(make.Ident(valuesVar),</b>
<b class="nc"><i>2294</i>&nbsp;                                                   syms.arrayCloneMethod)));</b>
<i>2295</i>&nbsp;            valuesBody = List.of(make.Return(valuesResult));
<i>2296</i>&nbsp;        } else {
<i>2297</i>&nbsp;            // template: T[] $result = new T[$values.length];
<i>2298</i>&nbsp;            Name resultName = names.fromString(target.syntheticNameChar() + &quot;result&quot;);
<b class="nc"><i>2299</i>&nbsp;            while (tree.sym.members().findFirst(resultName) != null) // avoid name clash</b>
<i>2300</i>&nbsp;                resultName = names.fromString(resultName + &quot;&quot; + target.syntheticNameChar());
<i>2301</i>&nbsp;            VarSymbol resultVar = new VarSymbol(FINAL|SYNTHETIC,
<i>2302</i>&nbsp;                                                resultName,
<i>2303</i>&nbsp;                                                arrayType,
<i>2304</i>&nbsp;                                                valuesSym);
<i>2305</i>&nbsp;            JCNewArray resultArray = make.NewArray(make.Type(types.erasure(tree.type)),
<i>2306</i>&nbsp;                                  List.of(make.Select(make.Ident(valuesVar), syms.lengthVar)),
<i>2307</i>&nbsp;                                  null);
<b class="nc"><i>2308</i>&nbsp;            resultArray.type = arrayType;</b>
<b class="nc"><i>2309</i>&nbsp;            JCVariableDecl decl = make.VarDef(resultVar, resultArray);</b>
<i>2310</i>&nbsp;
<b class="nc"><i>2311</i>&nbsp;            // template: System.arraycopy($VALUES, 0, $result, 0, $VALUES.length);</b>
<i>2312</i>&nbsp;            if (systemArraycopyMethod == null) {
<b class="nc"><i>2313</i>&nbsp;                systemArraycopyMethod =</b>
<b class="nc"><i>2314</i>&nbsp;                    new MethodSymbol(PUBLIC | STATIC,</b>
<b class="nc"><i>2315</i>&nbsp;                                     names.fromString(&quot;arraycopy&quot;),</b>
<b class="nc"><i>2316</i>&nbsp;                                     new MethodType(List.of(syms.objectType,</b>
<b class="nc"><i>2317</i>&nbsp;                                                            syms.intType,</b>
<i>2318</i>&nbsp;                                                            syms.objectType,
<b class="nc"><i>2319</i>&nbsp;                                                            syms.intType,</b>
<i>2320</i>&nbsp;                                                            syms.intType),
<i>2321</i>&nbsp;                                                    syms.voidType,
<i>2322</i>&nbsp;                                                    List.nil(),
<i>2323</i>&nbsp;                                                    syms.methodClass),
<b class="nc"><i>2324</i>&nbsp;                                     syms.systemType.tsym);</b>
<b class="nc"><i>2325</i>&nbsp;            }</b>
<i>2326</i>&nbsp;            JCStatement copy =
<b class="nc"><i>2327</i>&nbsp;                make.Exec(make.App(make.Select(make.Ident(syms.systemType.tsym),</b>
<i>2328</i>&nbsp;                                               systemArraycopyMethod),
<b class="nc"><i>2329</i>&nbsp;                          List.of(make.Ident(valuesVar), make.Literal(0),</b>
<i>2330</i>&nbsp;                                  make.Ident(resultVar), make.Literal(0),
<b class="nc"><i>2331</i>&nbsp;                                  make.Select(make.Ident(valuesVar), syms.lengthVar))));</b>
<b class="nc"><i>2332</i>&nbsp;</b>
<i>2333</i>&nbsp;            // template: return $result;
<i>2334</i>&nbsp;            JCStatement ret = make.Return(make.Ident(resultVar));
<i>2335</i>&nbsp;            valuesBody = List.of(decl, copy, ret);
<i>2336</i>&nbsp;        }
<i>2337</i>&nbsp;
<i>2338</i>&nbsp;        JCMethodDecl valuesDef =
<b class="nc"><i>2339</i>&nbsp;             make.MethodDef((MethodSymbol)valuesSym, make.Block(0, valuesBody));</b>
<i>2340</i>&nbsp;
<i>2341</i>&nbsp;        enumDefs.append(valuesDef);
<b class="nc"><i>2342</i>&nbsp;</b>
<i>2343</i>&nbsp;        if (debugLower)
<i>2344</i>&nbsp;            System.err.println(tree.sym + &quot;.valuesDef = &quot; + valuesDef);
<i>2345</i>&nbsp;
<i>2346</i>&nbsp;        /** The template for the following code is:
<b class="nc"><i>2347</i>&nbsp;         *</b>
<i>2348</i>&nbsp;         *     public static E valueOf(String name) {
<b class="nc"><i>2349</i>&nbsp;         *         return (E)Enum.valueOf(E.class, name);</b>
<i>2350</i>&nbsp;         *     }
<i>2351</i>&nbsp;         *
<i>2352</i>&nbsp;         *  where E is tree.sym
<i>2353</i>&nbsp;         */
<i>2354</i>&nbsp;        MethodSymbol valueOfSym = lookupMethod(tree.pos(),
<i>2355</i>&nbsp;                         names.valueOf,
<i>2356</i>&nbsp;                         tree.sym.type,
<i>2357</i>&nbsp;                         List.of(syms.stringType));
<i>2358</i>&nbsp;        Assert.check((valueOfSym.flags() &amp; STATIC) != 0);
<i>2359</i>&nbsp;        VarSymbol nameArgSym = valueOfSym.params.head;
<i>2360</i>&nbsp;        JCIdent nameVal = make.Ident(nameArgSym);
<i>2361</i>&nbsp;        JCStatement enum_ValueOf =
<i>2362</i>&nbsp;            make.Return(make.TypeCast(tree.sym.type,
<i>2363</i>&nbsp;                                      makeCall(make.Ident(syms.enumSym),
<i>2364</i>&nbsp;                                               names.valueOf,
<i>2365</i>&nbsp;                                               List.of(e_class, nameVal))));
<i>2366</i>&nbsp;        JCMethodDecl valueOf = make.MethodDef(valueOfSym,
<b class="nc"><i>2367</i>&nbsp;                                           make.Block(0, List.of(enum_ValueOf)));</b>
<b class="nc"><i>2368</i>&nbsp;        nameVal.sym = valueOf.params.head.sym;</b>
<i>2369</i>&nbsp;        if (debugLower)
<b class="nc"><i>2370</i>&nbsp;            System.err.println(tree.sym + &quot;.valueOf = &quot; + valueOf);</b>
<b class="nc"><i>2371</i>&nbsp;        enumDefs.append(valueOf);</b>
<b class="nc"><i>2372</i>&nbsp;</b>
<b class="nc"><i>2373</i>&nbsp;        enumDefs.appendList(otherDefs.toList());</b>
<i>2374</i>&nbsp;        tree.defs = enumDefs.toList();
<b class="nc"><i>2375</i>&nbsp;    }</b>
<i>2376</i>&nbsp;        // where
<i>2377</i>&nbsp;        private MethodSymbol systemArraycopyMethod;
<i>2378</i>&nbsp;        private boolean useClone() {
<i>2379</i>&nbsp;            try {
<i>2380</i>&nbsp;                return syms.objectType.tsym.members().findFirst(names.clone) != null;
<i>2381</i>&nbsp;            }
<b class="nc"><i>2382</i>&nbsp;            catch (CompletionFailure e) {</b>
<i>2383</i>&nbsp;                return false;
<i>2384</i>&nbsp;            }
<i>2385</i>&nbsp;        }
<i>2386</i>&nbsp;
<i>2387</i>&nbsp;    /** Translate an enumeration constant and its initializer. */
<b class="nc"><i>2388</i>&nbsp;    private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {</b>
<b class="nc"><i>2389</i>&nbsp;        JCNewClass varDef = (JCNewClass)var.init;</b>
<b class="nc"><i>2390</i>&nbsp;        varDef.args = varDef.args.</b>
<b class="nc"><i>2391</i>&nbsp;            prepend(makeLit(syms.intType, ordinal)).</b>
<b class="nc"><i>2392</i>&nbsp;            prepend(makeLit(syms.stringType, var.name.toString()));</b>
<i>2393</i>&nbsp;    }
<i>2394</i>&nbsp;
<i>2395</i>&nbsp;    public void visitMethodDef(JCMethodDecl tree) {
<i>2396</i>&nbsp;        if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
<i>2397</i>&nbsp;            // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
<b class="nc"><i>2398</i>&nbsp;            // argument list for each constructor of an enum.</b>
<b class="nc"><i>2399</i>&nbsp;            JCVariableDecl nameParam = make_at(tree.pos()).</b>
<b class="nc"><i>2400</i>&nbsp;                Param(names.fromString(target.syntheticNameChar() +</b>
<b class="nc"><i>2401</i>&nbsp;                                       &quot;enum&quot; + target.syntheticNameChar() + &quot;name&quot;),</b>
<b class="nc"><i>2402</i>&nbsp;                      syms.stringType, tree.sym);</b>
<i>2403</i>&nbsp;            nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;
<i>2404</i>&nbsp;            JCVariableDecl ordParam = make.
<i>2405</i>&nbsp;                Param(names.fromString(target.syntheticNameChar() +
<i>2406</i>&nbsp;                                       &quot;enum&quot; + target.syntheticNameChar() +
<i>2407</i>&nbsp;                                       &quot;ordinal&quot;),
<b class="nc"><i>2408</i>&nbsp;                      syms.intType, tree.sym);</b>
<b class="nc"><i>2409</i>&nbsp;            ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;</b>
<b class="nc"><i>2410</i>&nbsp;</b>
<b class="nc"><i>2411</i>&nbsp;            MethodSymbol m = tree.sym;</b>
<i>2412</i>&nbsp;            tree.params = tree.params.prepend(ordParam).prepend(nameParam);
<i>2413</i>&nbsp;
<i>2414</i>&nbsp;            m.extraParams = m.extraParams.prepend(ordParam.sym);
<b class="nc"><i>2415</i>&nbsp;            m.extraParams = m.extraParams.prepend(nameParam.sym);</b>
<b class="nc"><i>2416</i>&nbsp;            Type olderasure = m.erasure(types);</b>
<b class="nc"><i>2417</i>&nbsp;            m.erasure_field = new MethodType(</b>
<b class="nc"><i>2418</i>&nbsp;                olderasure.getParameterTypes().prepend(syms.intType).prepend(syms.stringType),</b>
<i>2419</i>&nbsp;                olderasure.getReturnType(),
<b class="nc"><i>2420</i>&nbsp;                olderasure.getThrownTypes(),</b>
<b class="nc"><i>2421</i>&nbsp;                syms.methodClass);</b>
<b class="nc"><i>2422</i>&nbsp;        }</b>
<i>2423</i>&nbsp;
<b class="nc"><i>2424</i>&nbsp;        JCMethodDecl prevMethodDef = currentMethodDef;</b>
<b class="nc"><i>2425</i>&nbsp;        MethodSymbol prevMethodSym = currentMethodSym;</b>
<b class="nc"><i>2426</i>&nbsp;        try {</b>
<b class="nc"><i>2427</i>&nbsp;            currentMethodDef = tree;</b>
<b class="nc"><i>2428</i>&nbsp;            currentMethodSym = tree.sym;</b>
<b class="nc"><i>2429</i>&nbsp;            visitMethodDefInternal(tree);</b>
<b class="nc"><i>2430</i>&nbsp;        } finally {</b>
<b class="nc"><i>2431</i>&nbsp;            currentMethodDef = prevMethodDef;</b>
<b class="nc"><i>2432</i>&nbsp;            currentMethodSym = prevMethodSym;</b>
<i>2433</i>&nbsp;        }
<b class="nc"><i>2434</i>&nbsp;    }</b>
<i>2435</i>&nbsp;
<i>2436</i>&nbsp;    private void visitMethodDefInternal(JCMethodDecl tree) {
<i>2437</i>&nbsp;        if (tree.name == names.init &amp;&amp;
<i>2438</i>&nbsp;            (currentClass.isInner() || currentClass.isLocal())) {
<b class="nc"><i>2439</i>&nbsp;            // We are seeing a constructor of an inner class.</b>
<i>2440</i>&nbsp;            MethodSymbol m = tree.sym;
<b class="nc"><i>2441</i>&nbsp;</b>
<i>2442</i>&nbsp;            // Push a new proxy scope for constructor parameters.
<b class="nc"><i>2443</i>&nbsp;            // and create definitions for any this$n and proxy parameters.</b>
<i>2444</i>&nbsp;            Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
<i>2445</i>&nbsp;            proxies = new HashMap&lt;&gt;(proxies);
<b class="nc"><i>2446</i>&nbsp;            List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;</b>
<b class="nc"><i>2447</i>&nbsp;            List&lt;VarSymbol&gt; fvs = freevars(currentClass);</b>
<b class="nc"><i>2448</i>&nbsp;            JCVariableDecl otdef = null;</b>
<b class="nc"><i>2449</i>&nbsp;            if (currentClass.hasOuterInstance())</b>
<b class="nc"><i>2450</i>&nbsp;                otdef = outerThisDef(tree.pos, m);</b>
<b class="nc"><i>2451</i>&nbsp;            List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(tree.pos, fvs, m, PARAMETER);</b>
<i>2452</i>&nbsp;
<b class="nc"><i>2453</i>&nbsp;            // Recursively translate result type, parameters and thrown list.</b>
<i>2454</i>&nbsp;            tree.restype = translate(tree.restype);
<i>2455</i>&nbsp;            tree.params = translateVarDefs(tree.params);
<i>2456</i>&nbsp;            tree.thrown = translate(tree.thrown);
<b class="nc"><i>2457</i>&nbsp;</b>
<b class="nc"><i>2458</i>&nbsp;            // when compiling stubs, don&#39;t process body</b>
<b class="nc"><i>2459</i>&nbsp;            if (tree.body == null) {</b>
<i>2460</i>&nbsp;                result = tree;
<b class="nc"><i>2461</i>&nbsp;                return;</b>
<b class="nc"><i>2462</i>&nbsp;            }</b>
<b class="nc"><i>2463</i>&nbsp;</b>
<b class="nc"><i>2464</i>&nbsp;            // Add this$n (if needed) in front of and free variables behind</b>
<b class="nc"><i>2465</i>&nbsp;            // constructor parameter list.</b>
<i>2466</i>&nbsp;            tree.params = tree.params.appendList(fvdefs);
<b class="nc"><i>2467</i>&nbsp;            if (currentClass.hasOuterInstance()) {</b>
<i>2468</i>&nbsp;                tree.params = tree.params.prepend(otdef);
<b class="nc"><i>2469</i>&nbsp;            }</b>
<b class="nc"><i>2470</i>&nbsp;</b>
<i>2471</i>&nbsp;            // If this is an initial constructor, i.e., it does not start with
<i>2472</i>&nbsp;            // this(...), insert initializers for this$n and proxies
<b class="nc"><i>2473</i>&nbsp;            // before (pre-1.4, after) the call to superclass constructor.</b>
<b class="nc"><i>2474</i>&nbsp;            JCStatement selfCall = translate(tree.body.stats.head);</b>
<b class="nc"><i>2475</i>&nbsp;</b>
<i>2476</i>&nbsp;            List&lt;JCStatement&gt; added = List.nil();
<i>2477</i>&nbsp;            if (fvs.nonEmpty()) {
<i>2478</i>&nbsp;                List&lt;Type&gt; addedargtypes = List.nil();
<b class="nc"><i>2479</i>&nbsp;                for (List&lt;VarSymbol&gt; l = fvs; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>2480</i>&nbsp;                    m.capturedLocals =</b>
<b class="nc"><i>2481</i>&nbsp;                        m.capturedLocals.prepend((VarSymbol)</b>
<i>2482</i>&nbsp;                                                (proxies.get(l.head)));
<i>2483</i>&nbsp;                    if (TreeInfo.isInitialConstructor(tree)) {
<b class="nc"><i>2484</i>&nbsp;                        added = added.prepend(</b>
<b class="nc"><i>2485</i>&nbsp;                          initField(tree.body.pos, proxies.get(l.head), prevProxies.get(l.head)));</b>
<i>2486</i>&nbsp;                    }
<i>2487</i>&nbsp;                    addedargtypes = addedargtypes.prepend(l.head.erasure(types));
<b class="nc"><i>2488</i>&nbsp;                }</b>
<b class="nc"><i>2489</i>&nbsp;                Type olderasure = m.erasure(types);</b>
<i>2490</i>&nbsp;                m.erasure_field = new MethodType(
<b class="nc"><i>2491</i>&nbsp;                    olderasure.getParameterTypes().appendList(addedargtypes),</b>
<b class="nc"><i>2492</i>&nbsp;                    olderasure.getReturnType(),</b>
<b class="nc"><i>2493</i>&nbsp;                    olderasure.getThrownTypes(),</b>
<b class="nc"><i>2494</i>&nbsp;                    syms.methodClass);</b>
<i>2495</i>&nbsp;            }
<b class="nc"><i>2496</i>&nbsp;            if (currentClass.hasOuterInstance() &amp;&amp;</b>
<i>2497</i>&nbsp;                TreeInfo.isInitialConstructor(tree))
<i>2498</i>&nbsp;            {
<i>2499</i>&nbsp;                added = added.prepend(initOuterThis(tree.body.pos));
<i>2500</i>&nbsp;            }
<i>2501</i>&nbsp;
<b class="nc"><i>2502</i>&nbsp;            // pop local variables from proxy stack</b>
<b class="nc"><i>2503</i>&nbsp;            proxies = prevProxies;</b>
<b class="nc"><i>2504</i>&nbsp;</b>
<b class="nc"><i>2505</i>&nbsp;            // recursively translate following local statements and</b>
<b class="nc"><i>2506</i>&nbsp;            // combine with this- or super-call</b>
<b class="nc"><i>2507</i>&nbsp;            List&lt;JCStatement&gt; stats = translate(tree.body.stats.tail);</b>
<b class="nc"><i>2508</i>&nbsp;            tree.body.stats = stats.prepend(selfCall).prependList(added);</b>
<b class="nc"><i>2509</i>&nbsp;            outerThisStack = prevOuterThisStack;</b>
<i>2510</i>&nbsp;        } else {
<b class="nc"><i>2511</i>&nbsp;            Map&lt;Symbol, Symbol&gt; prevLambdaTranslationMap =</b>
<b class="nc"><i>2512</i>&nbsp;                    lambdaTranslationMap;</b>
<i>2513</i>&nbsp;            try {
<i>2514</i>&nbsp;                lambdaTranslationMap = (tree.sym.flags() &amp; SYNTHETIC) != 0 &amp;&amp;
<b class="nc"><i>2515</i>&nbsp;                        tree.sym.name.startsWith(names.lambda) ?</b>
<b class="nc"><i>2516</i>&nbsp;                        makeTranslationMap(tree) : null;</b>
<i>2517</i>&nbsp;                super.visitMethodDef(tree);
<i>2518</i>&nbsp;            } finally {
<b class="nc"><i>2519</i>&nbsp;                lambdaTranslationMap = prevLambdaTranslationMap;</b>
<i>2520</i>&nbsp;            }
<i>2521</i>&nbsp;        }
<i>2522</i>&nbsp;        result = tree;
<b class="nc"><i>2523</i>&nbsp;    }</b>
<b class="nc"><i>2524</i>&nbsp;    //where</b>
<b class="nc"><i>2525</i>&nbsp;        private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {</b>
<i>2526</i>&nbsp;            Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
<b class="nc"><i>2527</i>&nbsp;            for (JCVariableDecl vd : tree.params) {</b>
<b class="nc"><i>2528</i>&nbsp;                Symbol p = vd.sym;</b>
<b class="nc"><i>2529</i>&nbsp;                if (p != p.baseSymbol()) {</b>
<i>2530</i>&nbsp;                    translationMap.put(p.baseSymbol(), p);
<i>2531</i>&nbsp;                }
<b class="nc"><i>2532</i>&nbsp;            }</b>
<b class="nc"><i>2533</i>&nbsp;            return translationMap;</b>
<i>2534</i>&nbsp;        }
<i>2535</i>&nbsp;
<b class="nc"><i>2536</i>&nbsp;    public void visitTypeCast(JCTypeCast tree) {</b>
<i>2537</i>&nbsp;        tree.clazz = translate(tree.clazz);
<b class="nc"><i>2538</i>&nbsp;        if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())</b>
<b class="nc"><i>2539</i>&nbsp;            tree.expr = translate(tree.expr, tree.type);</b>
<b class="nc"><i>2540</i>&nbsp;        else</b>
<i>2541</i>&nbsp;            tree.expr = translate(tree.expr);
<i>2542</i>&nbsp;        result = tree;
<b class="nc"><i>2543</i>&nbsp;    }</b>
<i>2544</i>&nbsp;
<i>2545</i>&nbsp;    public void visitNewClass(JCNewClass tree) {
<i>2546</i>&nbsp;        ClassSymbol c = (ClassSymbol)tree.constructor.owner;
<i>2547</i>&nbsp;
<b class="nc"><i>2548</i>&nbsp;        // Box arguments, if necessary</b>
<i>2549</i>&nbsp;        boolean isEnum = (tree.constructor.owner.flags() &amp; ENUM) != 0;
<i>2550</i>&nbsp;        List&lt;Type&gt; argTypes = tree.constructor.type.getParameterTypes();
<b class="nc"><i>2551</i>&nbsp;        if (isEnum) argTypes = argTypes.prepend(syms.intType).prepend(syms.stringType);</b>
<b class="nc"><i>2552</i>&nbsp;        tree.args = boxArgs(argTypes, tree.args, tree.varargsElement);</b>
<i>2553</i>&nbsp;        tree.varargsElement = null;
<i>2554</i>&nbsp;
<i>2555</i>&nbsp;        // If created class is local, add free variables after
<b class="nc"><i>2556</i>&nbsp;        // explicit constructor arguments.</b>
<b class="nc"><i>2557</i>&nbsp;        if (c.isLocal()) {</b>
<i>2558</i>&nbsp;            tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));
<i>2559</i>&nbsp;        }
<b class="nc"><i>2560</i>&nbsp;</b>
<b class="nc"><i>2561</i>&nbsp;        // If an access constructor is used, append null as a last argument.</b>
<b class="nc"><i>2562</i>&nbsp;        Symbol constructor = accessConstructor(tree.pos(), tree.constructor);</b>
<b class="nc"><i>2563</i>&nbsp;        if (constructor != tree.constructor) {</b>
<b class="nc"><i>2564</i>&nbsp;            tree.args = tree.args.append(makeNull());</b>
<b class="nc"><i>2565</i>&nbsp;            tree.constructor = constructor;</b>
<b class="nc"><i>2566</i>&nbsp;        }</b>
<b class="nc"><i>2567</i>&nbsp;</b>
<b class="nc"><i>2568</i>&nbsp;        // If created class has an outer instance, and new is qualified, pass</b>
<b class="nc"><i>2569</i>&nbsp;        // qualifier as first argument. If new is not qualified, pass the</b>
<b class="nc"><i>2570</i>&nbsp;        // correct outer instance as first argument.</b>
<b class="nc"><i>2571</i>&nbsp;        if (c.hasOuterInstance()) {</b>
<b class="nc"><i>2572</i>&nbsp;            JCExpression thisArg;</b>
<b class="nc"><i>2573</i>&nbsp;            if (tree.encl != null) {</b>
<i>2574</i>&nbsp;                thisArg = attr.makeNullCheck(translate(tree.encl));
<i>2575</i>&nbsp;                thisArg.type = tree.encl.type;
<i>2576</i>&nbsp;            } else if (c.isLocal()) {
<i>2577</i>&nbsp;                // local class
<b class="nc"><i>2578</i>&nbsp;                thisArg = makeThis(tree.pos(), c.type.getEnclosingType().tsym);</b>
<b class="nc"><i>2579</i>&nbsp;            } else {</b>
<b class="nc"><i>2580</i>&nbsp;                // nested class</b>
<b class="nc"><i>2581</i>&nbsp;                thisArg = makeOwnerThis(tree.pos(), c, false);</b>
<b class="nc"><i>2582</i>&nbsp;            }</b>
<i>2583</i>&nbsp;            tree.args = tree.args.prepend(thisArg);
<i>2584</i>&nbsp;        }
<i>2585</i>&nbsp;        tree.encl = null;
<b class="nc"><i>2586</i>&nbsp;</b>
<b class="nc"><i>2587</i>&nbsp;        // If we have an anonymous class, create its flat version, rather</b>
<b class="nc"><i>2588</i>&nbsp;        // than the class or interface following new.</b>
<b class="nc"><i>2589</i>&nbsp;        if (tree.def != null) {</b>
<b class="nc"><i>2590</i>&nbsp;            translate(tree.def);</b>
<b class="nc"><i>2591</i>&nbsp;            tree.clazz = access(make_at(tree.clazz.pos()).Ident(tree.def.sym));</b>
<i>2592</i>&nbsp;            tree.def = null;
<b class="nc"><i>2593</i>&nbsp;        } else {</b>
<b class="nc"><i>2594</i>&nbsp;            tree.clazz = access(c, tree.clazz, enclOp, false);</b>
<i>2595</i>&nbsp;        }
<b class="nc"><i>2596</i>&nbsp;        result = tree;</b>
<i>2597</i>&nbsp;    }
<b class="nc"><i>2598</i>&nbsp;</b>
<b class="nc"><i>2599</i>&nbsp;    // Simplify conditionals with known constant controlling expressions.</b>
<b class="nc"><i>2600</i>&nbsp;    // This allows us to avoid generating supporting declarations for</b>
<i>2601</i>&nbsp;    // the dead code, which will not be eliminated during code generation.
<b class="nc"><i>2602</i>&nbsp;    // Note that Flow.isFalse and Flow.isTrue only return true</b>
<b class="nc"><i>2603</i>&nbsp;    // for constant expressions in the sense of JLS 15.27, which</b>
<i>2604</i>&nbsp;    // are guaranteed to have no side-effects.  More aggressive
<b class="nc"><i>2605</i>&nbsp;    // constant propagation would require that we take care to</b>
<b class="nc"><i>2606</i>&nbsp;    // preserve possible side-effects in the condition expression.</b>
<b class="nc"><i>2607</i>&nbsp;</b>
<b class="nc"><i>2608</i>&nbsp;    // One common case is equality expressions involving a constant and null.</b>
<i>2609</i>&nbsp;    // Since null is not a constant expression (because null cannot be
<i>2610</i>&nbsp;    // represented in the constant pool), equality checks involving null are
<i>2611</i>&nbsp;    // not captured by Flow.isTrue/isFalse.
<b class="nc"><i>2612</i>&nbsp;    // Equality checks involving a constant and null, e.g.</b>
<b class="nc"><i>2613</i>&nbsp;    //     &quot;&quot; == null</b>
<i>2614</i>&nbsp;    // are safe to simplify as no side-effects can occur.
<b class="nc"><i>2615</i>&nbsp;</b>
<b class="nc"><i>2616</i>&nbsp;    private boolean isTrue(JCTree exp) {</b>
<i>2617</i>&nbsp;        if (exp.type.isTrue())
<i>2618</i>&nbsp;            return true;
<b class="nc"><i>2619</i>&nbsp;        Boolean b = expValue(exp);</b>
<b class="nc"><i>2620</i>&nbsp;        return b == null ? false : b;</b>
<i>2621</i>&nbsp;    }
<b class="nc"><i>2622</i>&nbsp;    private boolean isFalse(JCTree exp) {</b>
<b class="nc"><i>2623</i>&nbsp;        if (exp.type.isFalse())</b>
<i>2624</i>&nbsp;            return true;
<i>2625</i>&nbsp;        Boolean b = expValue(exp);
<i>2626</i>&nbsp;        return b == null ? false : !b;
<i>2627</i>&nbsp;    }
<i>2628</i>&nbsp;    /* look for (in)equality relations involving null.
<b class="nc"><i>2629</i>&nbsp;     * return true - if expression is always true</b>
<i>2630</i>&nbsp;     *       false - if expression is always false
<i>2631</i>&nbsp;     *        null - if expression cannot be eliminated
<i>2632</i>&nbsp;     */
<b class="nc"><i>2633</i>&nbsp;    private Boolean expValue(JCTree exp) {</b>
<b class="nc"><i>2634</i>&nbsp;        while (exp.hasTag(PARENS))</b>
<i>2635</i>&nbsp;            exp = ((JCParens)exp).expr;
<b class="nc"><i>2636</i>&nbsp;</b>
<b class="nc"><i>2637</i>&nbsp;        boolean eq;</b>
<b class="nc"><i>2638</i>&nbsp;        switch (exp.getTag()) {</b>
<i>2639</i>&nbsp;        case EQ: eq = true;  break;
<i>2640</i>&nbsp;        case NE: eq = false; break;
<b class="nc"><i>2641</i>&nbsp;        default:</b>
<b class="nc"><i>2642</i>&nbsp;            return null;</b>
<i>2643</i>&nbsp;        }
<i>2644</i>&nbsp;
<b class="nc"><i>2645</i>&nbsp;        // we have a JCBinary(EQ|NE)</b>
<b class="nc"><i>2646</i>&nbsp;        // check if we have two literals (constants or null)</b>
<i>2647</i>&nbsp;        JCBinary b = (JCBinary)exp;
<b class="nc"><i>2648</i>&nbsp;        if (b.lhs.type.hasTag(BOT)) return expValueIsNull(eq, b.rhs);</b>
<i>2649</i>&nbsp;        if (b.rhs.type.hasTag(BOT)) return expValueIsNull(eq, b.lhs);
<b class="nc"><i>2650</i>&nbsp;        return null;</b>
<b class="nc"><i>2651</i>&nbsp;    }</b>
<i>2652</i>&nbsp;    private Boolean expValueIsNull(boolean eq, JCTree t) {
<i>2653</i>&nbsp;        if (t.type.hasTag(BOT)) return Boolean.valueOf(eq);
<i>2654</i>&nbsp;        if (t.hasTag(LITERAL))  return Boolean.valueOf(!eq);
<i>2655</i>&nbsp;        return null;
<i>2656</i>&nbsp;    }
<i>2657</i>&nbsp;
<i>2658</i>&nbsp;    /** Visitor method for conditional expressions.
<i>2659</i>&nbsp;     */
<i>2660</i>&nbsp;    @Override
<b class="nc"><i>2661</i>&nbsp;    public void visitConditional(JCConditional tree) {</b>
<i>2662</i>&nbsp;        JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
<i>2663</i>&nbsp;        if (isTrue(cond)) {
<b class="nc"><i>2664</i>&nbsp;            result = convert(translate(tree.truepart, tree.type), tree.type);</b>
<b class="nc"><i>2665</i>&nbsp;            addPrunedInfo(cond);</b>
<b class="nc"><i>2666</i>&nbsp;        } else if (isFalse(cond)) {</b>
<b class="nc"><i>2667</i>&nbsp;            result = convert(translate(tree.falsepart, tree.type), tree.type);</b>
<b class="nc"><i>2668</i>&nbsp;            addPrunedInfo(cond);</b>
<b class="nc"><i>2669</i>&nbsp;        } else {</b>
<b class="nc"><i>2670</i>&nbsp;            // Condition is not a compile-time constant.</b>
<i>2671</i>&nbsp;            tree.truepart = translate(tree.truepart, tree.type);
<b class="nc"><i>2672</i>&nbsp;            tree.falsepart = translate(tree.falsepart, tree.type);</b>
<b class="nc"><i>2673</i>&nbsp;            result = tree;</b>
<b class="nc"><i>2674</i>&nbsp;        }</b>
<b class="nc"><i>2675</i>&nbsp;    }</b>
<b class="nc"><i>2676</i>&nbsp;//where</b>
<b class="nc"><i>2677</i>&nbsp;    private JCExpression convert(JCExpression tree, Type pt) {</b>
<b class="nc"><i>2678</i>&nbsp;        if (tree.type == pt || tree.type.hasTag(BOT))</b>
<i>2679</i>&nbsp;            return tree;
<b class="nc"><i>2680</i>&nbsp;        JCExpression result = make_at(tree.pos()).TypeCast(make.Type(pt), tree);</b>
<b class="nc"><i>2681</i>&nbsp;        result.type = (tree.type.constValue() != null) ? cfolder.coerce(tree.type, pt)</b>
<i>2682</i>&nbsp;                                                       : pt;
<i>2683</i>&nbsp;        return result;
<i>2684</i>&nbsp;    }
<i>2685</i>&nbsp;
<i>2686</i>&nbsp;    /** Visitor method for if statements.
<b class="nc"><i>2687</i>&nbsp;     */</b>
<b class="nc"><i>2688</i>&nbsp;    public void visitIf(JCIf tree) {</b>
<i>2689</i>&nbsp;        JCTree cond = tree.cond = translate(tree.cond, syms.booleanType);
<b class="nc"><i>2690</i>&nbsp;        if (isTrue(cond)) {</b>
<b class="nc"><i>2691</i>&nbsp;            result = translate(tree.thenpart);</b>
<i>2692</i>&nbsp;            addPrunedInfo(cond);
<i>2693</i>&nbsp;        } else if (isFalse(cond)) {
<i>2694</i>&nbsp;            if (tree.elsepart != null) {
<i>2695</i>&nbsp;                result = translate(tree.elsepart);
<i>2696</i>&nbsp;            } else {
<b class="nc"><i>2697</i>&nbsp;                result = make.Skip();</b>
<b class="nc"><i>2698</i>&nbsp;            }</b>
<b class="nc"><i>2699</i>&nbsp;            addPrunedInfo(cond);</b>
<b class="nc"><i>2700</i>&nbsp;        } else {</b>
<i>2701</i>&nbsp;            // Condition is not a compile-time constant.
<i>2702</i>&nbsp;            tree.thenpart = translate(tree.thenpart);
<i>2703</i>&nbsp;            tree.elsepart = translate(tree.elsepart);
<b class="nc"><i>2704</i>&nbsp;            result = tree;</b>
<i>2705</i>&nbsp;        }
<i>2706</i>&nbsp;    }
<b class="nc"><i>2707</i>&nbsp;</b>
<b class="nc"><i>2708</i>&nbsp;    /** Visitor method for assert statements. Translate them away.</b>
<b class="nc"><i>2709</i>&nbsp;     */</b>
<i>2710</i>&nbsp;    public void visitAssert(JCAssert tree) {
<b class="nc"><i>2711</i>&nbsp;        tree.cond = translate(tree.cond, syms.booleanType);</b>
<b class="nc"><i>2712</i>&nbsp;        if (!tree.cond.type.isTrue()) {</b>
<b class="nc"><i>2713</i>&nbsp;            JCExpression cond = assertFlagTest(tree.pos());</b>
<b class="nc"><i>2714</i>&nbsp;            List&lt;JCExpression&gt; exnArgs = (tree.detail == null) ?</b>
<i>2715</i>&nbsp;                List.nil() : List.of(translate(tree.detail));
<i>2716</i>&nbsp;            if (!tree.cond.type.isFalse()) {
<b class="nc"><i>2717</i>&nbsp;                cond = makeBinary</b>
<i>2718</i>&nbsp;                    (AND,
<b class="nc"><i>2719</i>&nbsp;                     cond,</b>
<i>2720</i>&nbsp;                     makeUnary(NOT, tree.cond));
<b class="nc"><i>2721</i>&nbsp;            }</b>
<b class="nc"><i>2722</i>&nbsp;            result =</b>
<b class="nc"><i>2723</i>&nbsp;                make.If(cond,</b>
<b class="nc"><i>2724</i>&nbsp;                        make_at(tree).</b>
<b class="nc"><i>2725</i>&nbsp;                           Throw(makeNewClass(syms.assertionErrorType, exnArgs)),</b>
<b class="nc"><i>2726</i>&nbsp;                        null);</b>
<b class="nc"><i>2727</i>&nbsp;        } else {</b>
<b class="nc"><i>2728</i>&nbsp;            result = make.Skip();</b>
<i>2729</i>&nbsp;        }
<i>2730</i>&nbsp;    }
<i>2731</i>&nbsp;
<b class="nc"><i>2732</i>&nbsp;    public void visitApply(JCMethodInvocation tree) {</b>
<b class="nc"><i>2733</i>&nbsp;        Symbol meth = TreeInfo.symbol(tree.meth);</b>
<i>2734</i>&nbsp;        List&lt;Type&gt; argtypes = meth.type.getParameterTypes();
<b class="nc"><i>2735</i>&nbsp;        if (meth.name == names.init &amp;&amp; meth.owner == syms.enumSym)</b>
<b class="nc"><i>2736</i>&nbsp;            argtypes = argtypes.tail.tail;</b>
<b class="nc"><i>2737</i>&nbsp;        tree.args = boxArgs(argtypes, tree.args, tree.varargsElement);</b>
<i>2738</i>&nbsp;        tree.varargsElement = null;
<b class="nc"><i>2739</i>&nbsp;        Name methName = TreeInfo.name(tree.meth);</b>
<b class="nc"><i>2740</i>&nbsp;        if (meth.name==names.init) {</b>
<b class="nc"><i>2741</i>&nbsp;            // We are seeing a this(...) or super(...) constructor call.</b>
<i>2742</i>&nbsp;            // If an access constructor is used, append null as a last argument.
<i>2743</i>&nbsp;            Symbol constructor = accessConstructor(tree.pos(), meth);
<i>2744</i>&nbsp;            if (constructor != meth) {
<b class="nc"><i>2745</i>&nbsp;                tree.args = tree.args.append(makeNull());</b>
<b class="nc"><i>2746</i>&nbsp;                TreeInfo.setSymbol(tree.meth, constructor);</b>
<i>2747</i>&nbsp;            }
<b class="nc"><i>2748</i>&nbsp;</b>
<i>2749</i>&nbsp;            // If we are calling a constructor of a local class, add
<i>2750</i>&nbsp;            // free variables after explicit constructor arguments.
<i>2751</i>&nbsp;            ClassSymbol c = (ClassSymbol)constructor.owner;
<b class="nc"><i>2752</i>&nbsp;            if (c.isLocal()) {</b>
<b class="nc"><i>2753</i>&nbsp;                tree.args = tree.args.appendList(loadFreevars(tree.pos(), freevars(c)));</b>
<b class="nc"><i>2754</i>&nbsp;            }</b>
<b class="nc"><i>2755</i>&nbsp;</b>
<b class="nc"><i>2756</i>&nbsp;            // If we are calling a constructor of an enum class, pass</b>
<b class="nc"><i>2757</i>&nbsp;            // along the name and ordinal arguments</b>
<b class="nc"><i>2758</i>&nbsp;            if ((c.flags_field&amp;ENUM) != 0 || c.getQualifiedName() == names.java_lang_Enum) {</b>
<i>2759</i>&nbsp;                List&lt;JCVariableDecl&gt; params = currentMethodDef.params;
<i>2760</i>&nbsp;                if (currentMethodSym.owner.hasOuterInstance())
<b class="nc"><i>2761</i>&nbsp;                    params = params.tail; // drop this$n</b>
<b class="nc"><i>2762</i>&nbsp;                tree.args = tree.args</b>
<b class="nc"><i>2763</i>&nbsp;                    .prepend(make_at(tree.pos()).Ident(params.tail.head.sym)) // ordinal</b>
<i>2764</i>&nbsp;                    .prepend(make.Ident(params.head.sym)); // name
<i>2765</i>&nbsp;            }
<b class="nc"><i>2766</i>&nbsp;</b>
<b class="nc"><i>2767</i>&nbsp;            // If we are calling a constructor of a class with an outer</b>
<i>2768</i>&nbsp;            // instance, and the call
<i>2769</i>&nbsp;            // is qualified, pass qualifier as first argument in front of
<i>2770</i>&nbsp;            // the explicit constructor arguments. If the call
<i>2771</i>&nbsp;            // is not qualified, pass the correct outer instance as
<i>2772</i>&nbsp;            // first argument.
<b class="nc"><i>2773</i>&nbsp;            if (c.hasOuterInstance()) {</b>
<b class="nc"><i>2774</i>&nbsp;                JCExpression thisArg;</b>
<b class="nc"><i>2775</i>&nbsp;                if (tree.meth.hasTag(SELECT)) {</b>
<i>2776</i>&nbsp;                    thisArg = attr.
<i>2777</i>&nbsp;                        makeNullCheck(translate(((JCFieldAccess) tree.meth).selected));
<i>2778</i>&nbsp;                    tree.meth = make.Ident(constructor);
<i>2779</i>&nbsp;                    ((JCIdent) tree.meth).name = methName;
<b class="nc"><i>2780</i>&nbsp;                } else if (c.isLocal() || methName == names._this){</b>
<i>2781</i>&nbsp;                    // local class or this() call
<b class="nc"><i>2782</i>&nbsp;                    thisArg = makeThis(tree.meth.pos(), c.type.getEnclosingType().tsym);</b>
<b class="nc"><i>2783</i>&nbsp;                } else {</b>
<b class="nc"><i>2784</i>&nbsp;                    // super() call of nested class - never pick &#39;this&#39;</b>
<b class="nc"><i>2785</i>&nbsp;                    thisArg = makeOwnerThisN(tree.meth.pos(), c, false);</b>
<b class="nc"><i>2786</i>&nbsp;                }</b>
<b class="nc"><i>2787</i>&nbsp;                tree.args = tree.args.prepend(thisArg);</b>
<b class="nc"><i>2788</i>&nbsp;            }</b>
<b class="nc"><i>2789</i>&nbsp;        } else {</b>
<b class="nc"><i>2790</i>&nbsp;            // We are seeing a normal method invocation; translate this as usual.</b>
<b class="nc"><i>2791</i>&nbsp;            tree.meth = translate(tree.meth);</b>
<b class="nc"><i>2792</i>&nbsp;</b>
<i>2793</i>&nbsp;            // If the translated method itself is an Apply tree, we are
<b class="nc"><i>2794</i>&nbsp;            // seeing an access method invocation. In this case, append</b>
<i>2795</i>&nbsp;            // the method arguments to the arguments of the access method.
<b class="nc"><i>2796</i>&nbsp;            if (tree.meth.hasTag(APPLY)) {</b>
<b class="nc"><i>2797</i>&nbsp;                JCMethodInvocation app = (JCMethodInvocation)tree.meth;</b>
<b class="nc"><i>2798</i>&nbsp;                app.args = tree.args.prependList(app.args);</b>
<b class="nc"><i>2799</i>&nbsp;                result = app;</b>
<b class="nc"><i>2800</i>&nbsp;                return;</b>
<i>2801</i>&nbsp;            }
<i>2802</i>&nbsp;        }
<b class="nc"><i>2803</i>&nbsp;        result = tree;</b>
<b class="nc"><i>2804</i>&nbsp;    }</b>
<i>2805</i>&nbsp;
<b class="nc"><i>2806</i>&nbsp;    List&lt;JCExpression&gt; boxArgs(List&lt;Type&gt; parameters, List&lt;JCExpression&gt; _args, Type varargsElement) {</b>
<i>2807</i>&nbsp;        List&lt;JCExpression&gt; args = _args;
<i>2808</i>&nbsp;        if (parameters.isEmpty()) return args;
<i>2809</i>&nbsp;        boolean anyChanges = false;
<b class="nc"><i>2810</i>&nbsp;        ListBuffer&lt;JCExpression&gt; result = new ListBuffer&lt;&gt;();</b>
<i>2811</i>&nbsp;        while (parameters.tail.nonEmpty()) {
<i>2812</i>&nbsp;            JCExpression arg = translate(args.head, parameters.head);
<i>2813</i>&nbsp;            anyChanges |= (arg != args.head);
<b class="nc"><i>2814</i>&nbsp;            result.append(arg);</b>
<b class="nc"><i>2815</i>&nbsp;            args = args.tail;</b>
<b class="nc"><i>2816</i>&nbsp;            parameters = parameters.tail;</b>
<i>2817</i>&nbsp;        }
<b class="nc"><i>2818</i>&nbsp;        Type parameter = parameters.head;</b>
<i>2819</i>&nbsp;        if (varargsElement != null) {
<b class="nc"><i>2820</i>&nbsp;            anyChanges = true;</b>
<b class="nc"><i>2821</i>&nbsp;            ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2822</i>&nbsp;            while (args.nonEmpty()) {</b>
<i>2823</i>&nbsp;                JCExpression arg = translate(args.head, varargsElement);
<i>2824</i>&nbsp;                elems.append(arg);
<b class="nc"><i>2825</i>&nbsp;                args = args.tail;</b>
<b class="nc"><i>2826</i>&nbsp;            }</b>
<b class="nc"><i>2827</i>&nbsp;            JCNewArray boxedArgs = make.NewArray(make.Type(varargsElement),</b>
<b class="nc"><i>2828</i>&nbsp;                                               List.nil(),</b>
<i>2829</i>&nbsp;                                               elems.toList());
<b class="nc"><i>2830</i>&nbsp;            boxedArgs.type = new ArrayType(varargsElement, syms.arrayClass);</b>
<b class="nc"><i>2831</i>&nbsp;            result.append(boxedArgs);</b>
<i>2832</i>&nbsp;        } else {
<b class="nc"><i>2833</i>&nbsp;            if (args.length() != 1) throw new AssertionError(args);</b>
<i>2834</i>&nbsp;            JCExpression arg = translate(args.head, parameter);
<i>2835</i>&nbsp;            anyChanges |= (arg != args.head);
<i>2836</i>&nbsp;            result.append(arg);
<b class="nc"><i>2837</i>&nbsp;            if (!anyChanges) return _args;</b>
<b class="nc"><i>2838</i>&nbsp;        }</b>
<b class="nc"><i>2839</i>&nbsp;        return result.toList();</b>
<b class="nc"><i>2840</i>&nbsp;    }</b>
<b class="nc"><i>2841</i>&nbsp;</b>
<i>2842</i>&nbsp;    /** Expand a boxing or unboxing conversion if needed. */
<b class="nc"><i>2843</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // XXX unchecked</b>
<b class="nc"><i>2844</i>&nbsp;    &lt;T extends JCExpression&gt; T boxIfNeeded(T tree, Type type) {</b>
<i>2845</i>&nbsp;        boolean havePrimitive = tree.type.isPrimitive();
<i>2846</i>&nbsp;        if (havePrimitive == type.isPrimitive())
<i>2847</i>&nbsp;            return tree;
<i>2848</i>&nbsp;        if (havePrimitive) {
<i>2849</i>&nbsp;            Type unboxedTarget = types.unboxedType(type);
<b class="nc"><i>2850</i>&nbsp;            if (!unboxedTarget.hasTag(NONE)) {</b>
<b class="nc"><i>2851</i>&nbsp;                if (!types.isSubtype(tree.type, unboxedTarget)) //e.g. Character c = 89;</b>
<i>2852</i>&nbsp;                    tree.type = unboxedTarget.constType(tree.type.constValue());
<b class="nc"><i>2853</i>&nbsp;                return (T)boxPrimitive(tree, types.erasure(type));</b>
<b class="nc"><i>2854</i>&nbsp;            } else {</b>
<b class="nc"><i>2855</i>&nbsp;                tree = (T)boxPrimitive(tree);</b>
<b class="nc"><i>2856</i>&nbsp;            }</b>
<i>2857</i>&nbsp;        } else {
<b class="nc"><i>2858</i>&nbsp;            tree = (T)unbox(tree, type);</b>
<i>2859</i>&nbsp;        }
<i>2860</i>&nbsp;        return tree;
<i>2861</i>&nbsp;    }
<b class="nc"><i>2862</i>&nbsp;</b>
<b class="nc"><i>2863</i>&nbsp;    /** Box up a single primitive expression. */</b>
<b class="nc"><i>2864</i>&nbsp;    JCExpression boxPrimitive(JCExpression tree) {</b>
<i>2865</i>&nbsp;        return boxPrimitive(tree, types.boxedClass(tree.type).type);
<b class="nc"><i>2866</i>&nbsp;    }</b>
<b class="nc"><i>2867</i>&nbsp;</b>
<i>2868</i>&nbsp;    /** Box up a single primitive expression. */
<i>2869</i>&nbsp;    JCExpression boxPrimitive(JCExpression tree, Type box) {
<i>2870</i>&nbsp;        make_at(tree.pos());
<b class="nc"><i>2871</i>&nbsp;        Symbol valueOfSym = lookupMethod(tree.pos(),</b>
<i>2872</i>&nbsp;                                         names.valueOf,
<i>2873</i>&nbsp;                                         box,
<b class="nc"><i>2874</i>&nbsp;                                         List.&lt;Type&gt;nil()</b>
<b class="nc"><i>2875</i>&nbsp;                                         .prepend(tree.type));</b>
<b class="nc"><i>2876</i>&nbsp;        return make.App(make.QualIdent(valueOfSym), List.of(tree));</b>
<b class="nc"><i>2877</i>&nbsp;    }</b>
<b class="nc"><i>2878</i>&nbsp;</b>
<i>2879</i>&nbsp;    /** Unbox an object to a primitive value. */
<i>2880</i>&nbsp;    JCExpression unbox(JCExpression tree, Type primitive) {
<i>2881</i>&nbsp;        Type unboxedType = types.unboxedType(tree.type);
<b class="nc"><i>2882</i>&nbsp;        if (unboxedType.hasTag(NONE)) {</b>
<b class="nc"><i>2883</i>&nbsp;            unboxedType = primitive;</b>
<i>2884</i>&nbsp;            if (!unboxedType.isPrimitive())
<i>2885</i>&nbsp;                throw new AssertionError(unboxedType);
<i>2886</i>&nbsp;            make_at(tree.pos());
<b class="nc"><i>2887</i>&nbsp;            tree = make.TypeCast(types.boxedClass(unboxedType).type, tree);</b>
<b class="nc"><i>2888</i>&nbsp;        } else {</b>
<b class="nc"><i>2889</i>&nbsp;            // There must be a conversion from unboxedType to primitive.</b>
<b class="nc"><i>2890</i>&nbsp;            if (!types.isSubtype(unboxedType, primitive))</b>
<i>2891</i>&nbsp;                throw new AssertionError(tree);
<i>2892</i>&nbsp;        }
<i>2893</i>&nbsp;        make_at(tree.pos());
<i>2894</i>&nbsp;        Symbol valueSym = lookupMethod(tree.pos(),
<i>2895</i>&nbsp;                                       unboxedType.tsym.name.append(names.Value), // x.intValue()
<b class="nc"><i>2896</i>&nbsp;                                       tree.type,</b>
<i>2897</i>&nbsp;                                       List.nil());
<b class="nc"><i>2898</i>&nbsp;        return make.App(make.Select(tree, valueSym));</b>
<b class="nc"><i>2899</i>&nbsp;    }</b>
<b class="nc"><i>2900</i>&nbsp;</b>
<b class="nc"><i>2901</i>&nbsp;    /** Visitor method for parenthesized expressions.</b>
<i>2902</i>&nbsp;     *  If the subexpression has changed, omit the parens.
<b class="nc"><i>2903</i>&nbsp;     */</b>
<i>2904</i>&nbsp;    public void visitParens(JCParens tree) {
<i>2905</i>&nbsp;        JCTree expr = translate(tree.expr);
<b class="nc"><i>2906</i>&nbsp;        result = ((expr == tree.expr) ? tree : expr);</b>
<i>2907</i>&nbsp;    }
<b class="nc"><i>2908</i>&nbsp;</b>
<i>2909</i>&nbsp;    public void visitIndexed(JCArrayAccess tree) {
<b class="nc"><i>2910</i>&nbsp;        tree.indexed = translate(tree.indexed);</b>
<i>2911</i>&nbsp;        tree.index = translate(tree.index, syms.intType);
<i>2912</i>&nbsp;        result = tree;
<i>2913</i>&nbsp;    }
<b class="nc"><i>2914</i>&nbsp;</b>
<b class="nc"><i>2915</i>&nbsp;    public void visitAssign(JCAssign tree) {</b>
<b class="nc"><i>2916</i>&nbsp;        tree.lhs = translate(tree.lhs, tree);</b>
<b class="nc"><i>2917</i>&nbsp;        tree.rhs = translate(tree.rhs, tree.lhs.type);</b>
<i>2918</i>&nbsp;
<b class="nc"><i>2919</i>&nbsp;        // If translated left hand side is an Apply, we are</b>
<i>2920</i>&nbsp;        // seeing an access method invocation. In this case, append
<b class="nc"><i>2921</i>&nbsp;        // right hand side as last argument of the access method.</b>
<i>2922</i>&nbsp;        if (tree.lhs.hasTag(APPLY)) {
<i>2923</i>&nbsp;            JCMethodInvocation app = (JCMethodInvocation)tree.lhs;
<i>2924</i>&nbsp;            app.args = List.of(tree.rhs).prependList(app.args);
<i>2925</i>&nbsp;            result = app;
<i>2926</i>&nbsp;        } else {
<i>2927</i>&nbsp;            result = tree;
<i>2928</i>&nbsp;        }
<i>2929</i>&nbsp;    }
<i>2930</i>&nbsp;
<i>2931</i>&nbsp;    public void visitAssignop(final JCAssignOp tree) {
<i>2932</i>&nbsp;        final boolean boxingReq = !tree.lhs.type.isPrimitive() &amp;&amp;
<i>2933</i>&nbsp;            tree.operator.type.getReturnType().isPrimitive();
<i>2934</i>&nbsp;
<i>2935</i>&nbsp;        AssignopDependencyScanner depScanner = new AssignopDependencyScanner(tree);
<i>2936</i>&nbsp;        depScanner.scan(tree.rhs);
<b class="nc"><i>2937</i>&nbsp;</b>
<b class="nc"><i>2938</i>&nbsp;        if (boxingReq || depScanner.dependencyFound) {</b>
<b class="nc"><i>2939</i>&nbsp;            // boxing required; need to rewrite as x = (unbox typeof x)(x op y);</b>
<b class="nc"><i>2940</i>&nbsp;            // or if x == (typeof x)z then z = (unbox typeof x)((typeof x)z op y)</b>
<b class="nc"><i>2941</i>&nbsp;            // (but without recomputing x)</b>
<b class="nc"><i>2942</i>&nbsp;            JCTree newTree = abstractLval(tree.lhs, lhs -&gt; {</b>
<b class="nc"><i>2943</i>&nbsp;                Tag newTag = tree.getTag().noAssignOp();</b>
<i>2944</i>&nbsp;                // Erasure (TransTypes) can change the type of
<i>2945</i>&nbsp;                // tree.lhs.  However, we can still get the
<b class="nc"><i>2946</i>&nbsp;                // unerased type of tree.lhs as it is stored</b>
<b class="nc"><i>2947</i>&nbsp;                // in tree.type in Attr.</b>
<b class="nc"><i>2948</i>&nbsp;                OperatorSymbol newOperator = operators.resolveBinary(tree,</b>
<i>2949</i>&nbsp;                                                              newTag,
<i>2950</i>&nbsp;                                                              tree.type,
<i>2951</i>&nbsp;                                                              tree.rhs.type);
<i>2952</i>&nbsp;                //Need to use the &quot;lhs&quot; at two places, once on the future left hand side
<b class="nc"><i>2953</i>&nbsp;                //and once in the future binary operator. But further processing may change</b>
<b class="nc"><i>2954</i>&nbsp;                //the components of the tree in place (see visitSelect for e.g. &lt;Class&gt;.super.&lt;ident&gt;),</b>
<b class="nc"><i>2955</i>&nbsp;                //so cloning the tree to avoid interference between the uses:</b>
<b class="nc"><i>2956</i>&nbsp;                JCExpression expr = (JCExpression) lhs.clone();</b>
<i>2957</i>&nbsp;                if (expr.type != tree.type)
<b class="nc"><i>2958</i>&nbsp;                    expr = make.TypeCast(tree.type, expr);</b>
<i>2959</i>&nbsp;                JCBinary opResult = make.Binary(newTag, expr, tree.rhs);
<i>2960</i>&nbsp;                opResult.operator = newOperator;
<i>2961</i>&nbsp;                opResult.type = newOperator.type.getReturnType();
<i>2962</i>&nbsp;                JCExpression newRhs = boxingReq ?
<i>2963</i>&nbsp;                    make.TypeCast(types.unboxedType(tree.type), opResult) :
<b class="nc"><i>2964</i>&nbsp;                    opResult;</b>
<b class="nc"><i>2965</i>&nbsp;                return make.Assign(lhs, newRhs).setType(tree.type);</b>
<b class="nc"><i>2966</i>&nbsp;            });</b>
<b class="nc"><i>2967</i>&nbsp;            result = translate(newTree);</b>
<b class="nc"><i>2968</i>&nbsp;            return;</b>
<b class="nc"><i>2969</i>&nbsp;        }</b>
<b class="nc"><i>2970</i>&nbsp;        tree.lhs = translate(tree.lhs, tree);</b>
<i>2971</i>&nbsp;        tree.rhs = translate(tree.rhs, tree.operator.type.getParameterTypes().tail.head);
<b class="nc"><i>2972</i>&nbsp;</b>
<i>2973</i>&nbsp;        // If translated left hand side is an Apply, we are
<b class="nc"><i>2974</i>&nbsp;        // seeing an access method invocation. In this case, append</b>
<i>2975</i>&nbsp;        // right hand side as last argument of the access method.
<i>2976</i>&nbsp;        if (tree.lhs.hasTag(APPLY)) {
<b class="nc"><i>2977</i>&nbsp;            JCMethodInvocation app = (JCMethodInvocation)tree.lhs;</b>
<b class="nc"><i>2978</i>&nbsp;            // if operation is a += on strings,</b>
<b class="nc"><i>2979</i>&nbsp;            // make sure to convert argument to string</b>
<i>2980</i>&nbsp;            JCExpression rhs = tree.operator.opcode == string_add
<i>2981</i>&nbsp;              ? makeString(tree.rhs)
<i>2982</i>&nbsp;              : tree.rhs;
<i>2983</i>&nbsp;            app.args = List.of(rhs).prependList(app.args);
<i>2984</i>&nbsp;            result = app;
<i>2985</i>&nbsp;        } else {
<b class="nc"><i>2986</i>&nbsp;            result = tree;</b>
<b class="nc"><i>2987</i>&nbsp;        }</b>
<b class="nc"><i>2988</i>&nbsp;    }</b>
<b class="nc"><i>2989</i>&nbsp;</b>
<b class="nc"><i>2990</i>&nbsp;    class AssignopDependencyScanner extends TreeScanner {</b>
<b class="nc"><i>2991</i>&nbsp;</b>
<b class="nc"><i>2992</i>&nbsp;        Symbol sym;</b>
<b class="nc"><i>2993</i>&nbsp;        boolean dependencyFound = false;</b>
<b class="nc"><i>2994</i>&nbsp;</b>
<i>2995</i>&nbsp;        AssignopDependencyScanner(JCAssignOp tree) {
<b class="nc"><i>2996</i>&nbsp;            this.sym = TreeInfo.symbol(tree.lhs);</b>
<i>2997</i>&nbsp;        }
<b class="nc"><i>2998</i>&nbsp;</b>
<b class="nc"><i>2999</i>&nbsp;        @Override</b>
<b class="nc"><i>3000</i>&nbsp;        public void scan(JCTree tree) {</b>
<b class="nc"><i>3001</i>&nbsp;            if (tree != null &amp;&amp; sym != null) {</b>
<i>3002</i>&nbsp;                tree.accept(this);
<b class="nc"><i>3003</i>&nbsp;            }</b>
<b class="nc"><i>3004</i>&nbsp;        }</b>
<i>3005</i>&nbsp;
<i>3006</i>&nbsp;        @Override
<i>3007</i>&nbsp;        public void visitAssignop(JCAssignOp tree) {
<i>3008</i>&nbsp;            if (TreeInfo.symbol(tree.lhs) == sym) {
<b class="nc"><i>3009</i>&nbsp;                dependencyFound = true;</b>
<b class="nc"><i>3010</i>&nbsp;                return;</b>
<b class="nc"><i>3011</i>&nbsp;            }</b>
<i>3012</i>&nbsp;            super.visitAssignop(tree);
<i>3013</i>&nbsp;        }
<b class="nc"><i>3014</i>&nbsp;</b>
<b class="nc"><i>3015</i>&nbsp;        @Override</b>
<b class="nc"><i>3016</i>&nbsp;        public void visitUnary(JCUnary tree) {</b>
<b class="nc"><i>3017</i>&nbsp;            if (TreeInfo.symbol(tree.arg) == sym) {</b>
<b class="nc"><i>3018</i>&nbsp;                dependencyFound = true;</b>
<i>3019</i>&nbsp;                return;
<i>3020</i>&nbsp;            }
<b class="nc"><i>3021</i>&nbsp;            super.visitUnary(tree);</b>
<b class="nc"><i>3022</i>&nbsp;        }</b>
<b class="nc"><i>3023</i>&nbsp;    }</b>
<b class="nc"><i>3024</i>&nbsp;</b>
<i>3025</i>&nbsp;    /** Lower a tree of the form e++ or e-- where e is an object type */
<i>3026</i>&nbsp;    JCExpression lowerBoxedPostop(final JCUnary tree) {
<i>3027</i>&nbsp;        // translate to tmp1=lval(e); tmp2=tmp1; tmp1 OP 1; tmp2
<i>3028</i>&nbsp;        // or
<b class="nc"><i>3029</i>&nbsp;        // translate to tmp1=lval(e); tmp2=tmp1; (typeof tree)tmp1 OP 1; tmp2</b>
<b class="nc"><i>3030</i>&nbsp;        // where OP is += or -=</b>
<b class="nc"><i>3031</i>&nbsp;        final boolean cast = TreeInfo.skipParens(tree.arg).hasTag(TYPECAST);</b>
<i>3032</i>&nbsp;        return abstractLval(tree.arg, tmp1 -&gt; abstractRval(tmp1, tree.arg.type, tmp2 -&gt; {
<i>3033</i>&nbsp;            Tag opcode = (tree.hasTag(POSTINC))
<i>3034</i>&nbsp;                ? PLUS_ASG : MINUS_ASG;
<i>3035</i>&nbsp;            //&quot;tmp1&quot; and &quot;tmp2&quot; may refer to the same instance
<b class="nc"><i>3036</i>&nbsp;            //(for e.g. &lt;Class&gt;.super.&lt;ident&gt;). But further processing may</b>
<b class="nc"><i>3037</i>&nbsp;            //change the components of the tree in place (see visitSelect),</b>
<b class="nc"><i>3038</i>&nbsp;            //so cloning the tree to avoid interference between the two uses:</b>
<b class="nc"><i>3039</i>&nbsp;            JCExpression lhs = (JCExpression)tmp1.clone();</b>
<b class="nc"><i>3040</i>&nbsp;            lhs = cast</b>
<b class="nc"><i>3041</i>&nbsp;                ? make.TypeCast(tree.arg.type, lhs)</b>
<b class="nc"><i>3042</i>&nbsp;                : lhs;</b>
<i>3043</i>&nbsp;            JCExpression update = makeAssignop(opcode,
<i>3044</i>&nbsp;                                         lhs,
<i>3045</i>&nbsp;                                         make.Literal(1));
<i>3046</i>&nbsp;            return makeComma(update, tmp2);
<i>3047</i>&nbsp;        }));
<i>3048</i>&nbsp;    }
<i>3049</i>&nbsp;
<i>3050</i>&nbsp;    public void visitUnary(JCUnary tree) {
<b class="nc"><i>3051</i>&nbsp;        boolean isUpdateOperator = tree.getTag().isIncOrDecUnaryOp();</b>
<i>3052</i>&nbsp;        if (isUpdateOperator &amp;&amp; !tree.arg.type.isPrimitive()) {
<b class="nc"><i>3053</i>&nbsp;            switch(tree.getTag()) {</b>
<b class="nc"><i>3054</i>&nbsp;            case PREINC:            // ++ e</b>
<b class="nc"><i>3055</i>&nbsp;                    // translate to e += 1</b>
<b class="nc"><i>3056</i>&nbsp;            case PREDEC:            // -- e</b>
<b class="nc"><i>3057</i>&nbsp;                    // translate to e -= 1</b>
<b class="nc"><i>3058</i>&nbsp;                {</b>
<i>3059</i>&nbsp;                    JCTree.Tag opcode = (tree.hasTag(PREINC))
<b class="nc"><i>3060</i>&nbsp;                        ? PLUS_ASG : MINUS_ASG;</b>
<i>3061</i>&nbsp;                    JCAssignOp newTree = makeAssignop(opcode,
<i>3062</i>&nbsp;                                                    tree.arg,
<b class="nc"><i>3063</i>&nbsp;                                                    make.Literal(1));</b>
<i>3064</i>&nbsp;                    result = translate(newTree, tree.type);
<b class="nc"><i>3065</i>&nbsp;                    return;</b>
<i>3066</i>&nbsp;                }
<b class="nc"><i>3067</i>&nbsp;            case POSTINC:           // e ++</b>
<i>3068</i>&nbsp;            case POSTDEC:           // e --
<b class="nc"><i>3069</i>&nbsp;                {</b>
<i>3070</i>&nbsp;                    result = translate(lowerBoxedPostop(tree), tree.type);
<i>3071</i>&nbsp;                    return;
<i>3072</i>&nbsp;                }
<i>3073</i>&nbsp;            }
<b class="nc"><i>3074</i>&nbsp;            throw new AssertionError(tree);</b>
<b class="nc"><i>3075</i>&nbsp;        }</b>
<b class="nc"><i>3076</i>&nbsp;</b>
<b class="nc"><i>3077</i>&nbsp;        tree.arg = boxIfNeeded(translate(tree.arg, tree), tree.type);</b>
<i>3078</i>&nbsp;
<i>3079</i>&nbsp;        if (tree.hasTag(NOT) &amp;&amp; tree.arg.type.constValue() != null) {
<i>3080</i>&nbsp;            tree.type = cfolder.fold1(bool_not, tree.arg.type);
<b class="nc"><i>3081</i>&nbsp;        }</b>
<i>3082</i>&nbsp;
<i>3083</i>&nbsp;        // If translated left hand side is an Apply, we are
<i>3084</i>&nbsp;        // seeing an access method invocation. In this case, return
<b class="nc"><i>3085</i>&nbsp;        // that access method invocation as result.</b>
<b class="nc"><i>3086</i>&nbsp;        if (isUpdateOperator &amp;&amp; tree.arg.hasTag(APPLY)) {</b>
<b class="nc"><i>3087</i>&nbsp;            result = tree.arg;</b>
<b class="nc"><i>3088</i>&nbsp;        } else {</b>
<b class="nc"><i>3089</i>&nbsp;            result = tree;</b>
<b class="nc"><i>3090</i>&nbsp;        }</b>
<b class="nc"><i>3091</i>&nbsp;    }</b>
<b class="nc"><i>3092</i>&nbsp;</b>
<b class="nc"><i>3093</i>&nbsp;    public void visitBinary(JCBinary tree) {</b>
<b class="nc"><i>3094</i>&nbsp;        List&lt;Type&gt; formals = tree.operator.type.getParameterTypes();</b>
<b class="nc"><i>3095</i>&nbsp;        JCTree lhs = tree.lhs = translate(tree.lhs, formals.head);</b>
<b class="nc"><i>3096</i>&nbsp;        switch (tree.getTag()) {</b>
<b class="nc"><i>3097</i>&nbsp;        case OR:</b>
<b class="nc"><i>3098</i>&nbsp;            if (isTrue(lhs)) {</b>
<b class="nc"><i>3099</i>&nbsp;                result = lhs;</b>
<b class="nc"><i>3100</i>&nbsp;                return;</b>
<b class="nc"><i>3101</i>&nbsp;            }</b>
<b class="nc"><i>3102</i>&nbsp;            if (isFalse(lhs)) {</b>
<b class="nc"><i>3103</i>&nbsp;                result = translate(tree.rhs, formals.tail.head);</b>
<b class="nc"><i>3104</i>&nbsp;                return;</b>
<b class="nc"><i>3105</i>&nbsp;            }</b>
<b class="nc"><i>3106</i>&nbsp;            break;</b>
<b class="nc"><i>3107</i>&nbsp;        case AND:</b>
<b class="nc"><i>3108</i>&nbsp;            if (isFalse(lhs)) {</b>
<b class="nc"><i>3109</i>&nbsp;                result = lhs;</b>
<b class="nc"><i>3110</i>&nbsp;                return;</b>
<b class="nc"><i>3111</i>&nbsp;            }</b>
<b class="nc"><i>3112</i>&nbsp;            if (isTrue(lhs)) {</b>
<b class="nc"><i>3113</i>&nbsp;                result = translate(tree.rhs, formals.tail.head);</b>
<b class="nc"><i>3114</i>&nbsp;                return;</b>
<b class="nc"><i>3115</i>&nbsp;            }</b>
<i>3116</i>&nbsp;            break;
<b class="nc"><i>3117</i>&nbsp;        }</b>
<i>3118</i>&nbsp;        tree.rhs = translate(tree.rhs, formals.tail.head);
<i>3119</i>&nbsp;        result = tree;
<i>3120</i>&nbsp;    }
<i>3121</i>&nbsp;
<i>3122</i>&nbsp;    public void visitIdent(JCIdent tree) {
<b class="nc"><i>3123</i>&nbsp;        result = access(tree.sym, tree, enclOp, false);</b>
<b class="nc"><i>3124</i>&nbsp;    }</b>
<b class="nc"><i>3125</i>&nbsp;</b>
<b class="nc"><i>3126</i>&nbsp;    /** Translate away the foreach loop.  */</b>
<b class="nc"><i>3127</i>&nbsp;    public void visitForeachLoop(JCEnhancedForLoop tree) {</b>
<b class="nc"><i>3128</i>&nbsp;        if (types.elemtype(tree.expr.type) == null)</b>
<b class="nc"><i>3129</i>&nbsp;            visitIterableForeachLoop(tree);</b>
<b class="nc"><i>3130</i>&nbsp;        else</b>
<b class="nc"><i>3131</i>&nbsp;            visitArrayForeachLoop(tree);</b>
<i>3132</i>&nbsp;    }
<b class="nc"><i>3133</i>&nbsp;        // where</b>
<i>3134</i>&nbsp;        /**
<b class="nc"><i>3135</i>&nbsp;         * A statement of the form</b>
<b class="nc"><i>3136</i>&nbsp;         *</b>
<i>3137</i>&nbsp;         * &lt;pre&gt;
<b class="nc"><i>3138</i>&nbsp;         *     for ( T v : arrayexpr ) stmt;</b>
<i>3139</i>&nbsp;         * &lt;/pre&gt;
<i>3140</i>&nbsp;         *
<i>3141</i>&nbsp;         * (where arrayexpr is of an array type) gets translated to
<i>3142</i>&nbsp;         *
<b class="nc"><i>3143</i>&nbsp;         * &lt;pre&gt;{@code</b>
<i>3144</i>&nbsp;         *     for ( { arraytype #arr = arrayexpr;
<i>3145</i>&nbsp;         *             int #len = array.length;
<i>3146</i>&nbsp;         *             int #i = 0; };
<i>3147</i>&nbsp;         *           #i &lt; #len; i$++ ) {
<b class="nc"><i>3148</i>&nbsp;         *         T v = arr$[#i];</b>
<b class="nc"><i>3149</i>&nbsp;         *         stmt;</b>
<b class="nc"><i>3150</i>&nbsp;         *     }</b>
<i>3151</i>&nbsp;         * }&lt;/pre&gt;
<b class="nc"><i>3152</i>&nbsp;         *</b>
<b class="nc"><i>3153</i>&nbsp;         * where #arr, #len, and #i are freshly named synthetic local variables.</b>
<b class="nc"><i>3154</i>&nbsp;         */</b>
<i>3155</i>&nbsp;        private void visitArrayForeachLoop(JCEnhancedForLoop tree) {
<b class="nc"><i>3156</i>&nbsp;            make_at(tree.expr.pos());</b>
<i>3157</i>&nbsp;            VarSymbol arraycache = new VarSymbol(SYNTHETIC,
<i>3158</i>&nbsp;                                                 names.fromString(&quot;arr&quot; + target.syntheticNameChar()),
<b class="nc"><i>3159</i>&nbsp;                                                 tree.expr.type,</b>
<b class="nc"><i>3160</i>&nbsp;                                                 currentMethodSym);</b>
<b class="nc"><i>3161</i>&nbsp;            JCStatement arraycachedef = make.VarDef(arraycache, tree.expr);</b>
<i>3162</i>&nbsp;            VarSymbol lencache = new VarSymbol(SYNTHETIC,
<i>3163</i>&nbsp;                                               names.fromString(&quot;len&quot; + target.syntheticNameChar()),
<i>3164</i>&nbsp;                                               syms.intType,
<i>3165</i>&nbsp;                                               currentMethodSym);
<i>3166</i>&nbsp;            JCStatement lencachedef = make.
<b class="nc"><i>3167</i>&nbsp;                VarDef(lencache, make.Select(make.Ident(arraycache), syms.lengthVar));</b>
<b class="nc"><i>3168</i>&nbsp;            VarSymbol index = new VarSymbol(SYNTHETIC,</b>
<b class="nc"><i>3169</i>&nbsp;                                            names.fromString(&quot;i&quot; + target.syntheticNameChar()),</b>
<b class="nc"><i>3170</i>&nbsp;                                            syms.intType,</b>
<b class="nc"><i>3171</i>&nbsp;                                            currentMethodSym);</b>
<b class="nc"><i>3172</i>&nbsp;</b>
<b class="nc"><i>3173</i>&nbsp;            JCVariableDecl indexdef = make.VarDef(index, make.Literal(INT, 0));</b>
<i>3174</i>&nbsp;            indexdef.init.type = indexdef.type = syms.intType.constType(0);
<i>3175</i>&nbsp;
<b class="nc"><i>3176</i>&nbsp;            List&lt;JCStatement&gt; loopinit = List.of(arraycachedef, lencachedef, indexdef);</b>
<b class="nc"><i>3177</i>&nbsp;            JCBinary cond = makeBinary(LT, make.Ident(index), make.Ident(lencache));</b>
<i>3178</i>&nbsp;
<b class="nc"><i>3179</i>&nbsp;            JCExpressionStatement step = make.Exec(makeUnary(PREINC, make.Ident(index)));</b>
<b class="nc"><i>3180</i>&nbsp;</b>
<b class="nc"><i>3181</i>&nbsp;            Type elemtype = types.elemtype(tree.expr.type);</b>
<i>3182</i>&nbsp;            JCExpression loopvarinit = make.Indexed(make.Ident(arraycache),
<b class="nc"><i>3183</i>&nbsp;                                                    make.Ident(index)).setType(elemtype);</b>
<b class="nc"><i>3184</i>&nbsp;            JCVariableDecl loopvardef = (JCVariableDecl)make.VarDef(tree.var.mods,</b>
<i>3185</i>&nbsp;                                                  tree.var.name,
<i>3186</i>&nbsp;                                                  tree.var.vartype,
<i>3187</i>&nbsp;                                                  loopvarinit).setType(tree.var.type);
<i>3188</i>&nbsp;            loopvardef.sym = tree.var.sym;
<i>3189</i>&nbsp;            JCBlock body = make.
<i>3190</i>&nbsp;                Block(0, List.of(loopvardef, tree.body));
<b class="nc"><i>3191</i>&nbsp;</b>
<b class="nc"><i>3192</i>&nbsp;            result = translate(make.</b>
<i>3193</i>&nbsp;                               ForLoop(loopinit,
<i>3194</i>&nbsp;                                       cond,
<i>3195</i>&nbsp;                                       List.of(step),
<b class="nc"><i>3196</i>&nbsp;                                       body));</b>
<b class="nc"><i>3197</i>&nbsp;            patchTargets(body, tree, result);</b>
<b class="nc"><i>3198</i>&nbsp;        }</b>
<i>3199</i>&nbsp;        /** Patch up break and continue targets. */
<i>3200</i>&nbsp;        private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {
<i>3201</i>&nbsp;            class Patcher extends TreeScanner {
<b class="nc"><i>3202</i>&nbsp;                public void visitBreak(JCBreak tree) {</b>
<b class="nc"><i>3203</i>&nbsp;                    if (tree.target == src)</b>
<i>3204</i>&nbsp;                        tree.target = dest;
<i>3205</i>&nbsp;                }
<i>3206</i>&nbsp;                public void visitContinue(JCContinue tree) {
<i>3207</i>&nbsp;                    if (tree.target == src)
<b class="nc"><i>3208</i>&nbsp;                        tree.target = dest;</b>
<b class="nc"><i>3209</i>&nbsp;                }</b>
<b class="nc"><i>3210</i>&nbsp;                public void visitClassDef(JCClassDecl tree) {}</b>
<b class="nc"><i>3211</i>&nbsp;            }</b>
<b class="nc"><i>3212</i>&nbsp;            new Patcher().scan(body);</b>
<b class="nc"><i>3213</i>&nbsp;        }</b>
<i>3214</i>&nbsp;        /**
<i>3215</i>&nbsp;         * A statement of the form
<i>3216</i>&nbsp;         *
<i>3217</i>&nbsp;         * &lt;pre&gt;
<b class="nc"><i>3218</i>&nbsp;         *     for ( T v : coll ) stmt ;</b>
<b class="nc"><i>3219</i>&nbsp;         * &lt;/pre&gt;</b>
<b class="nc"><i>3220</i>&nbsp;         *</b>
<i>3221</i>&nbsp;         * (where coll implements {@code Iterable&lt;? extends T&gt;}) gets translated to
<b class="nc"><i>3222</i>&nbsp;         *</b>
<i>3223</i>&nbsp;         * &lt;pre&gt;{@code
<i>3224</i>&nbsp;         *     for ( Iterator&lt;? extends T&gt; #i = coll.iterator(); #i.hasNext(); ) {
<i>3225</i>&nbsp;         *         T v = (T) #i.next();
<b class="nc"><i>3226</i>&nbsp;         *         stmt;</b>
<i>3227</i>&nbsp;         *     }
<b class="nc"><i>3228</i>&nbsp;         * }&lt;/pre&gt;</b>
<i>3229</i>&nbsp;         *
<i>3230</i>&nbsp;         * where #i is a freshly named synthetic local variable.
<i>3231</i>&nbsp;         */
<i>3232</i>&nbsp;        private void visitIterableForeachLoop(JCEnhancedForLoop tree) {
<b class="nc"><i>3233</i>&nbsp;            make_at(tree.expr.pos());</b>
<i>3234</i>&nbsp;            Type iteratorTarget = syms.objectType;
<i>3235</i>&nbsp;            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),
<i>3236</i>&nbsp;                                              syms.iterableType.tsym);
<i>3237</i>&nbsp;            if (iterableType.getTypeArguments().nonEmpty())
<b class="nc"><i>3238</i>&nbsp;                iteratorTarget = types.erasure(iterableType.getTypeArguments().head);</b>
<b class="nc"><i>3239</i>&nbsp;            Type eType = types.skipTypeVars(tree.expr.type, false);</b>
<b class="nc"><i>3240</i>&nbsp;            tree.expr.type = types.erasure(eType);</b>
<b class="nc"><i>3241</i>&nbsp;            if (eType.isCompound())</b>
<b class="nc"><i>3242</i>&nbsp;                tree.expr = make.TypeCast(types.erasure(iterableType), tree.expr);</b>
<b class="nc"><i>3243</i>&nbsp;            Symbol iterator = lookupMethod(tree.expr.pos(),</b>
<b class="nc"><i>3244</i>&nbsp;                                           names.iterator,</b>
<b class="nc"><i>3245</i>&nbsp;                                           eType,</b>
<i>3246</i>&nbsp;                                           List.nil());
<b class="nc"><i>3247</i>&nbsp;            VarSymbol itvar = new VarSymbol(SYNTHETIC, names.fromString(&quot;i&quot; + target.syntheticNameChar()),</b>
<i>3248</i>&nbsp;                                            types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)),
<i>3249</i>&nbsp;                                            currentMethodSym);
<b class="nc"><i>3250</i>&nbsp;</b>
<i>3251</i>&nbsp;             JCStatement init = make.
<i>3252</i>&nbsp;                VarDef(itvar, make.App(make.Select(tree.expr, iterator)
<b class="nc"><i>3253</i>&nbsp;                     .setType(types.erasure(iterator.type))));</b>
<b class="nc"><i>3254</i>&nbsp;</b>
<i>3255</i>&nbsp;            Symbol hasNext = lookupMethod(tree.expr.pos(),
<i>3256</i>&nbsp;                                          names.hasNext,
<i>3257</i>&nbsp;                                          itvar.type,
<i>3258</i>&nbsp;                                          List.nil());
<b class="nc"><i>3259</i>&nbsp;            JCMethodInvocation cond = make.App(make.Select(make.Ident(itvar), hasNext));</b>
<b class="nc"><i>3260</i>&nbsp;            Symbol next = lookupMethod(tree.expr.pos(),</b>
<i>3261</i>&nbsp;                                       names.next,
<i>3262</i>&nbsp;                                       itvar.type,
<b class="nc"><i>3263</i>&nbsp;                                       List.nil());</b>
<b class="nc"><i>3264</i>&nbsp;            JCExpression vardefinit = make.App(make.Select(make.Ident(itvar), next));</b>
<i>3265</i>&nbsp;            if (tree.var.type.isPrimitive())
<b class="nc"><i>3266</i>&nbsp;                vardefinit = make.TypeCast(types.cvarUpperBound(iteratorTarget), vardefinit);</b>
<b class="nc"><i>3267</i>&nbsp;            else</b>
<b class="nc"><i>3268</i>&nbsp;                vardefinit = make.TypeCast(tree.var.type, vardefinit);</b>
<b class="nc"><i>3269</i>&nbsp;            JCVariableDecl indexDef = (JCVariableDecl)make.VarDef(tree.var.mods,</b>
<i>3270</i>&nbsp;                                                  tree.var.name,
<i>3271</i>&nbsp;                                                  tree.var.vartype,
<i>3272</i>&nbsp;                                                  vardefinit).setType(tree.var.type);
<i>3273</i>&nbsp;            indexDef.sym = tree.var.sym;
<i>3274</i>&nbsp;            JCBlock body = make.Block(0, List.of(indexDef, tree.body));
<i>3275</i>&nbsp;            body.endpos = TreeInfo.endPos(tree.body);
<i>3276</i>&nbsp;            result = translate(make.
<i>3277</i>&nbsp;                ForLoop(List.of(init),
<i>3278</i>&nbsp;                        cond,
<b class="nc"><i>3279</i>&nbsp;                        List.nil(),</b>
<b class="nc"><i>3280</i>&nbsp;                        body));</b>
<i>3281</i>&nbsp;            patchTargets(body, tree, result);
<b class="nc"><i>3282</i>&nbsp;        }</b>
<i>3283</i>&nbsp;
<b class="nc"><i>3284</i>&nbsp;    public void visitVarDef(JCVariableDecl tree) {</b>
<i>3285</i>&nbsp;        MethodSymbol oldMethodSym = currentMethodSym;
<b class="nc"><i>3286</i>&nbsp;        tree.mods = translate(tree.mods);</b>
<b class="nc"><i>3287</i>&nbsp;        tree.vartype = translate(tree.vartype);</b>
<i>3288</i>&nbsp;        if (currentMethodSym == null) {
<b class="nc"><i>3289</i>&nbsp;            // A class or instance field initializer.</b>
<i>3290</i>&nbsp;            currentMethodSym =
<b class="nc"><i>3291</i>&nbsp;                new MethodSymbol((tree.mods.flags&amp;STATIC) | BLOCK,</b>
<b class="nc"><i>3292</i>&nbsp;                                 names.empty, null,</b>
<i>3293</i>&nbsp;                                 currentClass);
<i>3294</i>&nbsp;        }
<i>3295</i>&nbsp;        if (tree.init != null) tree.init = translate(tree.init, tree.type);
<i>3296</i>&nbsp;        result = tree;
<i>3297</i>&nbsp;        currentMethodSym = oldMethodSym;
<i>3298</i>&nbsp;    }
<i>3299</i>&nbsp;
<b class="nc"><i>3300</i>&nbsp;    public void visitBlock(JCBlock tree) {</b>
<b class="nc"><i>3301</i>&nbsp;        MethodSymbol oldMethodSym = currentMethodSym;</b>
<b class="nc"><i>3302</i>&nbsp;        if (currentMethodSym == null) {</b>
<i>3303</i>&nbsp;            // Block is a static or instance initializer.
<i>3304</i>&nbsp;            currentMethodSym =
<i>3305</i>&nbsp;                new MethodSymbol(tree.flags | BLOCK,
<i>3306</i>&nbsp;                                 names.empty, null,
<i>3307</i>&nbsp;                                 currentClass);
<b class="nc"><i>3308</i>&nbsp;        }</b>
<i>3309</i>&nbsp;        super.visitBlock(tree);
<b class="nc"><i>3310</i>&nbsp;        currentMethodSym = oldMethodSym;</b>
<i>3311</i>&nbsp;    }
<b class="nc"><i>3312</i>&nbsp;</b>
<b class="nc"><i>3313</i>&nbsp;    public void visitDoLoop(JCDoWhileLoop tree) {</b>
<i>3314</i>&nbsp;        tree.body = translate(tree.body);
<i>3315</i>&nbsp;        tree.cond = translate(tree.cond, syms.booleanType);
<i>3316</i>&nbsp;        result = tree;
<i>3317</i>&nbsp;    }
<i>3318</i>&nbsp;
<b class="nc"><i>3319</i>&nbsp;    public void visitWhileLoop(JCWhileLoop tree) {</b>
<i>3320</i>&nbsp;        tree.cond = translate(tree.cond, syms.booleanType);
<i>3321</i>&nbsp;        tree.body = translate(tree.body);
<i>3322</i>&nbsp;        result = tree;
<b class="nc"><i>3323</i>&nbsp;    }</b>
<i>3324</i>&nbsp;
<i>3325</i>&nbsp;    public void visitForLoop(JCForLoop tree) {
<b class="nc"><i>3326</i>&nbsp;        tree.init = translate(tree.init);</b>
<i>3327</i>&nbsp;        if (tree.cond != null)
<b class="nc"><i>3328</i>&nbsp;            tree.cond = translate(tree.cond, syms.booleanType);</b>
<b class="nc"><i>3329</i>&nbsp;        tree.step = translate(tree.step);</b>
<i>3330</i>&nbsp;        tree.body = translate(tree.body);
<i>3331</i>&nbsp;        result = tree;
<i>3332</i>&nbsp;    }
<i>3333</i>&nbsp;
<i>3334</i>&nbsp;    public void visitReturn(JCReturn tree) {
<b class="nc"><i>3335</i>&nbsp;        if (tree.expr != null)</b>
<b class="nc"><i>3336</i>&nbsp;            tree.expr = translate(tree.expr,</b>
<i>3337</i>&nbsp;                                  types.erasure(currentMethodDef
<b class="nc"><i>3338</i>&nbsp;                                                .restype.type));</b>
<i>3339</i>&nbsp;        result = tree;
<i>3340</i>&nbsp;    }
<i>3341</i>&nbsp;
<i>3342</i>&nbsp;    public void visitSwitch(JCSwitch tree) {
<b class="nc"><i>3343</i>&nbsp;        Type selsuper = types.supertype(tree.selector.type);</b>
<b class="nc"><i>3344</i>&nbsp;        boolean enumSwitch = selsuper != null &amp;&amp;</b>
<b class="nc"><i>3345</i>&nbsp;            (tree.selector.type.tsym.flags() &amp; ENUM) != 0;</b>
<i>3346</i>&nbsp;        boolean stringSwitch = selsuper != null &amp;&amp;
<b class="nc"><i>3347</i>&nbsp;            types.isSameType(tree.selector.type, syms.stringType);</b>
<b class="nc"><i>3348</i>&nbsp;        Type target = enumSwitch ? tree.selector.type :</b>
<i>3349</i>&nbsp;            (stringSwitch? syms.stringType : syms.intType);
<i>3350</i>&nbsp;        tree.selector = translate(tree.selector, target);
<b class="nc"><i>3351</i>&nbsp;        tree.cases = translateCases(tree.cases);</b>
<b class="nc"><i>3352</i>&nbsp;        if (enumSwitch) {</b>
<i>3353</i>&nbsp;            result = visitEnumSwitch(tree);
<i>3354</i>&nbsp;        } else if (stringSwitch) {
<i>3355</i>&nbsp;            result = visitStringSwitch(tree);
<i>3356</i>&nbsp;        } else {
<b class="nc"><i>3357</i>&nbsp;            result = tree;</b>
<b class="nc"><i>3358</i>&nbsp;        }</b>
<i>3359</i>&nbsp;    }
<i>3360</i>&nbsp;
<b class="nc"><i>3361</i>&nbsp;    public JCTree visitEnumSwitch(JCSwitch tree) {</b>
<b class="nc"><i>3362</i>&nbsp;        TypeSymbol enumSym = tree.selector.type.tsym;</b>
<i>3363</i>&nbsp;        EnumMapping map = mapForEnum(tree.pos(), enumSym);
<i>3364</i>&nbsp;        make_at(tree.pos());
<i>3365</i>&nbsp;        Symbol ordinalMethod = lookupMethod(tree.pos(),
<i>3366</i>&nbsp;                                            names.ordinal,
<b class="nc"><i>3367</i>&nbsp;                                            tree.selector.type,</b>
<b class="nc"><i>3368</i>&nbsp;                                            List.nil());</b>
<i>3369</i>&nbsp;        JCArrayAccess selector = make.Indexed(map.mapVar,
<i>3370</i>&nbsp;                                        make.App(make.Select(tree.selector,
<i>3371</i>&nbsp;                                                             ordinalMethod)));
<b class="nc"><i>3372</i>&nbsp;        ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();</b>
<i>3373</i>&nbsp;        for (JCCase c : tree.cases) {
<i>3374</i>&nbsp;            if (c.pat != null) {
<i>3375</i>&nbsp;                VarSymbol label = (VarSymbol)TreeInfo.symbol(c.pat);
<i>3376</i>&nbsp;                JCLiteral pat = map.forConstant(label);
<b class="nc"><i>3377</i>&nbsp;                cases.append(make.Case(pat, c.stats));</b>
<b class="nc"><i>3378</i>&nbsp;            } else {</b>
<i>3379</i>&nbsp;                cases.append(c);
<b class="nc"><i>3380</i>&nbsp;            }</b>
<i>3381</i>&nbsp;        }
<i>3382</i>&nbsp;        JCSwitch enumSwitch = make.Switch(selector, cases.toList());
<i>3383</i>&nbsp;        patchTargets(enumSwitch, tree, enumSwitch);
<i>3384</i>&nbsp;        return enumSwitch;
<i>3385</i>&nbsp;    }
<i>3386</i>&nbsp;
<i>3387</i>&nbsp;    public JCTree visitStringSwitch(JCSwitch tree) {
<i>3388</i>&nbsp;        List&lt;JCCase&gt; caseList = tree.getCases();
<i>3389</i>&nbsp;        int alternatives = caseList.size();
<i>3390</i>&nbsp;
<i>3391</i>&nbsp;        if (alternatives == 0) { // Strange but legal possibility
<i>3392</i>&nbsp;            return make.at(tree.pos()).Exec(attr.makeNullCheck(tree.getExpression()));
<i>3393</i>&nbsp;        } else {
<i>3394</i>&nbsp;            /*
<i>3395</i>&nbsp;             * The general approach used is to translate a single
<i>3396</i>&nbsp;             * string switch statement into a series of two chained
<i>3397</i>&nbsp;             * switch statements: the first a synthesized statement
<i>3398</i>&nbsp;             * switching on the argument string&#39;s hash value and
<i>3399</i>&nbsp;             * computing a string&#39;s position in the list of original
<i>3400</i>&nbsp;             * case labels, if any, followed by a second switch on the
<i>3401</i>&nbsp;             * computed integer value.  The second switch has the same
<i>3402</i>&nbsp;             * code structure as the original string switch statement
<i>3403</i>&nbsp;             * except that the string case labels are replaced with
<i>3404</i>&nbsp;             * positional integer constants starting at 0.
<b class="nc"><i>3405</i>&nbsp;             *</b>
<b class="nc"><i>3406</i>&nbsp;             * The first switch statement can be thought of as an</b>
<b class="nc"><i>3407</i>&nbsp;             * inlined map from strings to their position in the case</b>
<i>3408</i>&nbsp;             * label list.  An alternate implementation would use an
<i>3409</i>&nbsp;             * actual Map for this purpose, as done for enum switches.
<b class="nc"><i>3410</i>&nbsp;             *</b>
<b class="nc"><i>3411</i>&nbsp;             * With some additional effort, it would be possible to</b>
<b class="nc"><i>3412</i>&nbsp;             * use a single switch statement on the hash code of the</b>
<i>3413</i>&nbsp;             * argument, but care would need to be taken to preserve
<i>3414</i>&nbsp;             * the proper control flow in the presence of hash
<b class="nc"><i>3415</i>&nbsp;             * collisions and other complications, such as</b>
<b class="nc"><i>3416</i>&nbsp;             * fallthroughs.  Switch statements with one or two</b>
<b class="nc"><i>3417</i>&nbsp;             * alternatives could also be specially translated into</b>
<b class="nc"><i>3418</i>&nbsp;             * if-then statements to omit the computation of the hash</b>
<i>3419</i>&nbsp;             * code.
<i>3420</i>&nbsp;             *
<i>3421</i>&nbsp;             * The generated code assumes that the hashing algorithm
<b class="nc"><i>3422</i>&nbsp;             * of String is the same in the compilation environment as</b>
<b class="nc"><i>3423</i>&nbsp;             * in the environment the code will run in.  The string</b>
<i>3424</i>&nbsp;             * hashing algorithm in the SE JDK has been unchanged
<b class="nc"><i>3425</i>&nbsp;             * since at least JDK 1.2.  Since the algorithm has been</b>
<b class="nc"><i>3426</i>&nbsp;             * specified since that release as well, it is very</b>
<i>3427</i>&nbsp;             * unlikely to be changed in the future.
<b class="nc"><i>3428</i>&nbsp;             *</b>
<i>3429</i>&nbsp;             * Different hashing algorithms, such as the length of the
<b class="nc"><i>3430</i>&nbsp;             * strings or a perfect hashing algorithm over the</b>
<b class="nc"><i>3431</i>&nbsp;             * particular set of case labels, could potentially be</b>
<b class="nc"><i>3432</i>&nbsp;             * used instead of String.hashCode.</b>
<b class="nc"><i>3433</i>&nbsp;             */</b>
<i>3434</i>&nbsp;
<i>3435</i>&nbsp;            ListBuffer&lt;JCStatement&gt; stmtList = new ListBuffer&lt;&gt;();
<b class="nc"><i>3436</i>&nbsp;</b>
<b class="nc"><i>3437</i>&nbsp;            // Map from String case labels to their original position in</b>
<b class="nc"><i>3438</i>&nbsp;            // the list of case labels.</b>
<b class="nc"><i>3439</i>&nbsp;            Map&lt;String, Integer&gt; caseLabelToPosition = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);</b>
<i>3440</i>&nbsp;
<b class="nc"><i>3441</i>&nbsp;            // Map of hash codes to the string case labels having that hashCode.</b>
<b class="nc"><i>3442</i>&nbsp;            Map&lt;Integer, Set&lt;String&gt;&gt; hashToString = new LinkedHashMap&lt;&gt;(alternatives + 1, 1.0f);</b>
<i>3443</i>&nbsp;
<b class="nc"><i>3444</i>&nbsp;            int casePosition = 0;</b>
<i>3445</i>&nbsp;            for(JCCase oneCase : caseList) {
<b class="nc"><i>3446</i>&nbsp;                JCExpression expression = oneCase.getExpression();</b>
<i>3447</i>&nbsp;
<i>3448</i>&nbsp;                if (expression != null) { // expression for a &quot;default&quot; case is null
<i>3449</i>&nbsp;                    String labelExpr = (String) expression.type.constValue();
<b class="nc"><i>3450</i>&nbsp;                    Integer mapping = caseLabelToPosition.put(labelExpr, casePosition);</b>
<i>3451</i>&nbsp;                    Assert.checkNull(mapping);
<b class="nc"><i>3452</i>&nbsp;                    int hashCode = labelExpr.hashCode();</b>
<b class="nc"><i>3453</i>&nbsp;</b>
<i>3454</i>&nbsp;                    Set&lt;String&gt; stringSet = hashToString.get(hashCode);
<i>3455</i>&nbsp;                    if (stringSet == null) {
<b class="nc"><i>3456</i>&nbsp;                        stringSet = new LinkedHashSet&lt;&gt;(1, 1.0f);</b>
<b class="nc"><i>3457</i>&nbsp;                        stringSet.add(labelExpr);</b>
<i>3458</i>&nbsp;                        hashToString.put(hashCode, stringSet);
<i>3459</i>&nbsp;                    } else {
<i>3460</i>&nbsp;                        boolean added = stringSet.add(labelExpr);
<b class="nc"><i>3461</i>&nbsp;                        Assert.check(added);</b>
<i>3462</i>&nbsp;                    }
<i>3463</i>&nbsp;                }
<i>3464</i>&nbsp;                casePosition++;
<i>3465</i>&nbsp;            }
<i>3466</i>&nbsp;
<i>3467</i>&nbsp;            // Synthesize a switch statement that has the effect of
<i>3468</i>&nbsp;            // mapping from a string to the integer position of that
<i>3469</i>&nbsp;            // string in the list of case labels.  This is done by
<i>3470</i>&nbsp;            // switching on the hashCode of the string followed by an
<i>3471</i>&nbsp;            // if-then-else chain comparing the input for equality
<i>3472</i>&nbsp;            // with all the case labels having that hash value.
<i>3473</i>&nbsp;
<i>3474</i>&nbsp;            /*
<i>3475</i>&nbsp;             * s$ = top of stack;
<i>3476</i>&nbsp;             * tmp$ = -1;
<i>3477</i>&nbsp;             * switch($s.hashCode()) {
<i>3478</i>&nbsp;             *     case caseLabel.hashCode:
<i>3479</i>&nbsp;             *         if (s$.equals(&quot;caseLabel_1&quot;)
<i>3480</i>&nbsp;             *           tmp$ = caseLabelToPosition(&quot;caseLabel_1&quot;);
<i>3481</i>&nbsp;             *         else if (s$.equals(&quot;caseLabel_2&quot;))
<b class="nc"><i>3482</i>&nbsp;             *           tmp$ = caseLabelToPosition(&quot;caseLabel_2&quot;);</b>
<b class="nc"><i>3483</i>&nbsp;             *         ...</b>
<b class="nc"><i>3484</i>&nbsp;             *         break;</b>
<i>3485</i>&nbsp;             * ...
<b class="nc"><i>3486</i>&nbsp;             * }</b>
<b class="nc"><i>3487</i>&nbsp;             */</b>
<b class="nc"><i>3488</i>&nbsp;</b>
<b class="nc"><i>3489</i>&nbsp;            VarSymbol dollar_s = new VarSymbol(FINAL|SYNTHETIC,</b>
<b class="nc"><i>3490</i>&nbsp;                                               names.fromString(&quot;s&quot; + tree.pos + target.syntheticNameChar()),</b>
<i>3491</i>&nbsp;                                               syms.stringType,
<b class="nc"><i>3492</i>&nbsp;                                               currentMethodSym);</b>
<b class="nc"><i>3493</i>&nbsp;            stmtList.append(make.at(tree.pos()).VarDef(dollar_s, tree.getExpression()).setType(dollar_s.type));</b>
<b class="nc"><i>3494</i>&nbsp;</b>
<b class="nc"><i>3495</i>&nbsp;            VarSymbol dollar_tmp = new VarSymbol(SYNTHETIC,</b>
<i>3496</i>&nbsp;                                                 names.fromString(&quot;tmp&quot; + tree.pos + target.syntheticNameChar()),
<i>3497</i>&nbsp;                                                 syms.intType,
<b class="nc"><i>3498</i>&nbsp;                                                 currentMethodSym);</b>
<b class="nc"><i>3499</i>&nbsp;            JCVariableDecl dollar_tmp_def =</b>
<b class="nc"><i>3500</i>&nbsp;                (JCVariableDecl)make.VarDef(dollar_tmp, make.Literal(INT, -1)).setType(dollar_tmp.type);</b>
<i>3501</i>&nbsp;            dollar_tmp_def.init.type = dollar_tmp.type = syms.intType;
<i>3502</i>&nbsp;            stmtList.append(dollar_tmp_def);
<b class="nc"><i>3503</i>&nbsp;            ListBuffer&lt;JCCase&gt; caseBuffer = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>3504</i>&nbsp;            // hashCode will trigger nullcheck on original switch expression</b>
<b class="nc"><i>3505</i>&nbsp;            JCMethodInvocation hashCodeCall = makeCall(make.Ident(dollar_s),</b>
<i>3506</i>&nbsp;                                                       names.hashCode,
<b class="nc"><i>3507</i>&nbsp;                                                       List.nil()).setType(syms.intType);</b>
<i>3508</i>&nbsp;            JCSwitch switch1 = make.Switch(hashCodeCall,
<i>3509</i>&nbsp;                                        caseBuffer.toList());
<b class="nc"><i>3510</i>&nbsp;            for(Map.Entry&lt;Integer, Set&lt;String&gt;&gt; entry : hashToString.entrySet()) {</b>
<b class="nc"><i>3511</i>&nbsp;                int hashCode = entry.getKey();</b>
<b class="nc"><i>3512</i>&nbsp;                Set&lt;String&gt; stringsWithHashCode = entry.getValue();</b>
<i>3513</i>&nbsp;                Assert.check(stringsWithHashCode.size() &gt;= 1);
<i>3514</i>&nbsp;
<b class="nc"><i>3515</i>&nbsp;                JCStatement elsepart = null;</b>
<b class="nc"><i>3516</i>&nbsp;                for(String caseLabel : stringsWithHashCode ) {</b>
<b class="nc"><i>3517</i>&nbsp;                    JCMethodInvocation stringEqualsCall = makeCall(make.Ident(dollar_s),</b>
<b class="nc"><i>3518</i>&nbsp;                                                                   names.equals,</b>
<i>3519</i>&nbsp;                                                                   List.of(make.Literal(caseLabel)));
<b class="nc"><i>3520</i>&nbsp;                    elsepart = make.If(stringEqualsCall,</b>
<b class="nc"><i>3521</i>&nbsp;                                       make.Exec(make.Assign(make.Ident(dollar_tmp),</b>
<i>3522</i>&nbsp;                                                             make.Literal(caseLabelToPosition.get(caseLabel))).
<i>3523</i>&nbsp;                                                 setType(dollar_tmp.type)),
<b class="nc"><i>3524</i>&nbsp;                                       elsepart);</b>
<b class="nc"><i>3525</i>&nbsp;                }</b>
<b class="nc"><i>3526</i>&nbsp;</b>
<b class="nc"><i>3527</i>&nbsp;                ListBuffer&lt;JCStatement&gt; lb = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>3528</i>&nbsp;                JCBreak breakStmt = make.Break(null);</b>
<b class="nc"><i>3529</i>&nbsp;                breakStmt.target = switch1;</b>
<i>3530</i>&nbsp;                lb.append(elsepart).append(breakStmt);
<b class="nc"><i>3531</i>&nbsp;</b>
<i>3532</i>&nbsp;                caseBuffer.append(make.Case(make.Literal(hashCode), lb.toList()));
<b class="nc"><i>3533</i>&nbsp;            }</b>
<i>3534</i>&nbsp;
<i>3535</i>&nbsp;            switch1.cases = caseBuffer.toList();
<i>3536</i>&nbsp;            stmtList.append(switch1);
<b class="nc"><i>3537</i>&nbsp;</b>
<b class="nc"><i>3538</i>&nbsp;            // Make isomorphic switch tree replacing string labels</b>
<b class="nc"><i>3539</i>&nbsp;            // with corresponding integer ones from the label to</b>
<b class="nc"><i>3540</i>&nbsp;            // position map.</b>
<i>3541</i>&nbsp;
<b class="nc"><i>3542</i>&nbsp;            ListBuffer&lt;JCCase&gt; lb = new ListBuffer&lt;&gt;();</b>
<i>3543</i>&nbsp;            JCSwitch switch2 = make.Switch(make.Ident(dollar_tmp), lb.toList());
<i>3544</i>&nbsp;            for(JCCase oneCase : caseList ) {
<i>3545</i>&nbsp;                // Rewire up old unlabeled break statements to the
<i>3546</i>&nbsp;                // replacement switch being created.
<b class="nc"><i>3547</i>&nbsp;                patchTargets(oneCase, tree, switch2);</b>
<b class="nc"><i>3548</i>&nbsp;</b>
<b class="nc"><i>3549</i>&nbsp;                boolean isDefault = (oneCase.getExpression() == null);</b>
<i>3550</i>&nbsp;                JCExpression caseExpr;
<i>3551</i>&nbsp;                if (isDefault)
<i>3552</i>&nbsp;                    caseExpr = null;
<b class="nc"><i>3553</i>&nbsp;                else {</b>
<b class="nc"><i>3554</i>&nbsp;                    caseExpr = make.Literal(caseLabelToPosition.get((String)TreeInfo.skipParens(oneCase.</b>
<i>3555</i>&nbsp;                                                                                                getExpression()).
<b class="nc"><i>3556</i>&nbsp;                                                                    type.constValue()));</b>
<i>3557</i>&nbsp;                }
<i>3558</i>&nbsp;
<i>3559</i>&nbsp;                lb.append(make.Case(caseExpr,
<i>3560</i>&nbsp;                                    oneCase.getStatements()));
<b class="nc"><i>3561</i>&nbsp;            }</b>
<b class="nc"><i>3562</i>&nbsp;</b>
<i>3563</i>&nbsp;            switch2.cases = lb.toList();
<i>3564</i>&nbsp;            stmtList.append(switch2);
<i>3565</i>&nbsp;
<b class="nc"><i>3566</i>&nbsp;            return make.Block(0L, stmtList.toList());</b>
<b class="nc"><i>3567</i>&nbsp;        }</b>
<b class="nc"><i>3568</i>&nbsp;    }</b>
<i>3569</i>&nbsp;
<i>3570</i>&nbsp;    public void visitNewArray(JCNewArray tree) {
<i>3571</i>&nbsp;        tree.elemtype = translate(tree.elemtype);
<b class="nc"><i>3572</i>&nbsp;        for (List&lt;JCExpression&gt; t = tree.dims; t.tail != null; t = t.tail)</b>
<b class="nc"><i>3573</i>&nbsp;            if (t.head != null) t.head = translate(t.head, syms.intType);</b>
<b class="nc"><i>3574</i>&nbsp;        tree.elems = translate(tree.elems, types.elemtype(tree.type));</b>
<i>3575</i>&nbsp;        result = tree;
<i>3576</i>&nbsp;    }
<i>3577</i>&nbsp;
<b class="nc"><i>3578</i>&nbsp;    public void visitSelect(JCFieldAccess tree) {</b>
<b class="nc"><i>3579</i>&nbsp;        // need to special case-access of the form C.super.x</b>
<b class="nc"><i>3580</i>&nbsp;        // these will always need an access method, unless C</b>
<b class="nc"><i>3581</i>&nbsp;        // is a default interface subclassed by the current class.</b>
<b class="nc"><i>3582</i>&nbsp;        boolean qualifiedSuperAccess =</b>
<b class="nc"><i>3583</i>&nbsp;            tree.selected.hasTag(SELECT) &amp;&amp;</b>
<i>3584</i>&nbsp;            TreeInfo.name(tree.selected) == names._super &amp;&amp;
<i>3585</i>&nbsp;            !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);
<i>3586</i>&nbsp;        tree.selected = translate(tree.selected);
<b class="nc"><i>3587</i>&nbsp;        if (tree.name == names._class) {</b>
<b class="nc"><i>3588</i>&nbsp;            result = classOf(tree.selected);</b>
<b class="nc"><i>3589</i>&nbsp;        }</b>
<i>3590</i>&nbsp;        else if (tree.name == names._super &amp;&amp;
<b class="nc"><i>3591</i>&nbsp;                types.isDirectSuperInterface(tree.selected.type.tsym, currentClass)) {</b>
<i>3592</i>&nbsp;            //default super call!! Not a classic qualified super call
<i>3593</i>&nbsp;            TypeSymbol supSym = tree.selected.type.tsym;
<i>3594</i>&nbsp;            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));
<b class="nc"><i>3595</i>&nbsp;            result = tree;</b>
<b class="nc"><i>3596</i>&nbsp;        }</b>
<b class="nc"><i>3597</i>&nbsp;        else if (tree.name == names._this || tree.name == names._super) {</b>
<b class="nc"><i>3598</i>&nbsp;            result = makeThis(tree.pos(), tree.selected.type.tsym);</b>
<b class="nc"><i>3599</i>&nbsp;        }</b>
<b class="nc"><i>3600</i>&nbsp;        else</b>
<i>3601</i>&nbsp;            result = access(tree.sym, tree, enclOp, qualifiedSuperAccess);
<b class="nc"><i>3602</i>&nbsp;    }</b>
<b class="nc"><i>3603</i>&nbsp;</b>
<b class="nc"><i>3604</i>&nbsp;    public void visitLetExpr(LetExpr tree) {</b>
<b class="nc"><i>3605</i>&nbsp;        tree.defs = translateVarDefs(tree.defs);</b>
<b class="nc"><i>3606</i>&nbsp;        tree.expr = translate(tree.expr, tree.type);</b>
<b class="nc"><i>3607</i>&nbsp;        result = tree;</b>
<i>3608</i>&nbsp;    }
<b class="nc"><i>3609</i>&nbsp;</b>
<i>3610</i>&nbsp;    // There ought to be nothing to rewrite here;
<i>3611</i>&nbsp;    // we don&#39;t generate code.
<i>3612</i>&nbsp;    public void visitAnnotation(JCAnnotation tree) {
<i>3613</i>&nbsp;        result = tree;
<b class="nc"><i>3614</i>&nbsp;    }</b>
<b class="nc"><i>3615</i>&nbsp;</b>
<b class="nc"><i>3616</i>&nbsp;    @Override</b>
<b class="nc"><i>3617</i>&nbsp;    public void visitTry(JCTry tree) {</b>
<i>3618</i>&nbsp;        if (tree.resources.nonEmpty()) {
<i>3619</i>&nbsp;            result = makeTwrTry(tree);
<b class="nc"><i>3620</i>&nbsp;            return;</b>
<b class="nc"><i>3621</i>&nbsp;        }</b>
<b class="nc"><i>3622</i>&nbsp;</b>
<i>3623</i>&nbsp;        boolean hasBody = tree.body.getStatements().nonEmpty();
<b class="nc"><i>3624</i>&nbsp;        boolean hasCatchers = tree.catchers.nonEmpty();</b>
<b class="nc"><i>3625</i>&nbsp;        boolean hasFinally = tree.finalizer != null &amp;&amp;</b>
<b class="nc"><i>3626</i>&nbsp;                tree.finalizer.getStatements().nonEmpty();</b>
<b class="nc"><i>3627</i>&nbsp;</b>
<b class="nc"><i>3628</i>&nbsp;        if (!hasCatchers &amp;&amp; !hasFinally) {</b>
<b class="nc"><i>3629</i>&nbsp;            result = translate(tree.body);</b>
<b class="nc"><i>3630</i>&nbsp;            return;</b>
<b class="nc"><i>3631</i>&nbsp;        }</b>
<i>3632</i>&nbsp;
<b class="nc"><i>3633</i>&nbsp;        if (!hasBody) {</b>
<b class="nc"><i>3634</i>&nbsp;            if (hasFinally) {</b>
<b class="nc"><i>3635</i>&nbsp;                result = translate(tree.finalizer);</b>
<b class="nc"><i>3636</i>&nbsp;            } else {</b>
<i>3637</i>&nbsp;                result = translate(tree.body);
<i>3638</i>&nbsp;            }
<i>3639</i>&nbsp;            return;
<b class="nc"><i>3640</i>&nbsp;        }</b>
<b class="nc"><i>3641</i>&nbsp;</b>
<i>3642</i>&nbsp;        // no optimizations possible
<b class="nc"><i>3643</i>&nbsp;        super.visitTry(tree);</b>
<b class="nc"><i>3644</i>&nbsp;    }</b>
<i>3645</i>&nbsp;
<i>3646</i>&nbsp;/**************************************************************************
<i>3647</i>&nbsp; * main method
<i>3648</i>&nbsp; *************************************************************************/
<i>3649</i>&nbsp;
<i>3650</i>&nbsp;    /** Translate a toplevel class and return a list consisting of
<i>3651</i>&nbsp;     *  the translated class and translated versions of all inner classes.
<i>3652</i>&nbsp;     *  @param env   The attribution environment current at the class definition.
<i>3653</i>&nbsp;     *               We need this for resolving some additional symbols.
<i>3654</i>&nbsp;     *  @param cdef  The tree representing the class definition.
<i>3655</i>&nbsp;     */
<i>3656</i>&nbsp;    public List&lt;JCTree&gt; translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
<i>3657</i>&nbsp;        ListBuffer&lt;JCTree&gt; translated = null;
<i>3658</i>&nbsp;        try {
<i>3659</i>&nbsp;            attrEnv = env;
<i>3660</i>&nbsp;            this.make = make;
<i>3661</i>&nbsp;            endPosTable = env.toplevel.endPositions;
<i>3662</i>&nbsp;            currentClass = null;
<i>3663</i>&nbsp;            currentMethodDef = null;
<i>3664</i>&nbsp;            outermostClassDef = (cdef.hasTag(CLASSDEF)) ? (JCClassDecl)cdef : null;
<i>3665</i>&nbsp;            outermostMemberDef = null;
<i>3666</i>&nbsp;            this.translated = new ListBuffer&lt;&gt;();
<i>3667</i>&nbsp;            classdefs = new HashMap&lt;&gt;();
<i>3668</i>&nbsp;            actualSymbols = new HashMap&lt;&gt;();
<i>3669</i>&nbsp;            freevarCache = new HashMap&lt;&gt;();
<i>3670</i>&nbsp;            proxies = new HashMap&lt;&gt;();
<i>3671</i>&nbsp;            twrVars = WriteableScope.create(syms.noSymbol);
<i>3672</i>&nbsp;            outerThisStack = List.nil();
<i>3673</i>&nbsp;            accessNums = new HashMap&lt;&gt;();
<i>3674</i>&nbsp;            accessSyms = new HashMap&lt;&gt;();
<i>3675</i>&nbsp;            accessConstrs = new HashMap&lt;&gt;();
<i>3676</i>&nbsp;            accessConstrTags = List.nil();
<i>3677</i>&nbsp;            accessed = new ListBuffer&lt;&gt;();
<i>3678</i>&nbsp;            translate(cdef, (JCExpression)null);
<i>3679</i>&nbsp;            for (List&lt;Symbol&gt; l = accessed.toList(); l.nonEmpty(); l = l.tail)
<i>3680</i>&nbsp;                makeAccessible(l.head);
<i>3681</i>&nbsp;            for (EnumMapping map : enumSwitchMap.values())
<i>3682</i>&nbsp;                map.translate();
<i>3683</i>&nbsp;            checkConflicts(this.translated.toList());
<i>3684</i>&nbsp;            checkAccessConstructorTags();
<i>3685</i>&nbsp;            translated = this.translated;
<i>3686</i>&nbsp;        } finally {
<b class="nc"><i>3687</i>&nbsp;            // note that recursive invocations of this method fail hard</b>
<i>3688</i>&nbsp;            attrEnv = null;
<i>3689</i>&nbsp;            this.make = null;
<i>3690</i>&nbsp;            endPosTable = null;
<b class="nc"><i>3691</i>&nbsp;            currentClass = null;</b>
<i>3692</i>&nbsp;            currentMethodDef = null;
<i>3693</i>&nbsp;            outermostClassDef = null;
<i>3694</i>&nbsp;            outermostMemberDef = null;
<b class="nc"><i>3695</i>&nbsp;            this.translated = null;</b>
<i>3696</i>&nbsp;            classdefs = null;
<i>3697</i>&nbsp;            actualSymbols = null;
<b class="nc"><i>3698</i>&nbsp;            freevarCache = null;</b>
<b class="nc"><i>3699</i>&nbsp;            proxies = null;</b>
<b class="nc"><i>3700</i>&nbsp;            outerThisStack = null;</b>
<i>3701</i>&nbsp;            accessNums = null;
<b class="nc"><i>3702</i>&nbsp;            accessSyms = null;</b>
<b class="nc"><i>3703</i>&nbsp;            accessConstrs = null;</b>
<b class="nc"><i>3704</i>&nbsp;            accessConstrTags = null;</b>
<b class="nc"><i>3705</i>&nbsp;            accessed = null;</b>
<b class="nc"><i>3706</i>&nbsp;            enumSwitchMap.clear();</b>
<i>3707</i>&nbsp;            assertionsDisabledClassCache = null;
<b class="nc"><i>3708</i>&nbsp;        }</b>
<b class="nc"><i>3709</i>&nbsp;        return translated.toList();</b>
<b class="nc"><i>3710</i>&nbsp;    }</b>
<b class="nc"><i>3711</i>&nbsp;}</b>
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
