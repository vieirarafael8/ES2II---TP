


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Attr</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.comp</a> ]
</div>

<h1>Coverage Summary for Class: Attr (com.sun.tools.javac.comp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Attr</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 134)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1868)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Attr$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$BreakAttr</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$ExpressionLambdaReturnContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$FunctionalReturnContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$IdentAttributer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$PostAttrAnalyzer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$RecoveryInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$RecoveryInfo$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$ResultInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Attr$TypeAnnotationsValidator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 124)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 219)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2157)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.comp;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.*;
<i>29</i>&nbsp;
<i>30</i>&nbsp;import javax.lang.model.element.ElementKind;
<i>31</i>&nbsp;import javax.tools.JavaFileObject;
<i>32</i>&nbsp;
<i>33</i>&nbsp;import com.sun.source.tree.IdentifierTree;
<i>34</i>&nbsp;import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
<i>35</i>&nbsp;import com.sun.source.tree.MemberSelectTree;
<i>36</i>&nbsp;import com.sun.source.tree.TreeVisitor;
<i>37</i>&nbsp;import com.sun.source.util.SimpleTreeVisitor;
<i>38</i>&nbsp;import com.sun.tools.javac.code.*;
<i>39</i>&nbsp;import com.sun.tools.javac.code.Lint.LintCategory;
<i>40</i>&nbsp;import com.sun.tools.javac.code.Scope.WriteableScope;
<i>41</i>&nbsp;import com.sun.tools.javac.code.Source.Feature;
<i>42</i>&nbsp;import com.sun.tools.javac.code.Symbol.*;
<i>43</i>&nbsp;import com.sun.tools.javac.code.Type.*;
<i>44</i>&nbsp;import com.sun.tools.javac.code.TypeMetadata.Annotations;
<i>45</i>&nbsp;import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
<i>46</i>&nbsp;import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
<i>47</i>&nbsp;import com.sun.tools.javac.comp.Check.CheckContext;
<i>48</i>&nbsp;import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
<i>49</i>&nbsp;import com.sun.tools.javac.jvm.*;
<i>50</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
<i>51</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
<i>52</i>&nbsp;import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
<i>53</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Errors;
<i>54</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<i>55</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Warnings;
<i>56</i>&nbsp;import com.sun.tools.javac.tree.*;
<i>57</i>&nbsp;import com.sun.tools.javac.tree.JCTree.*;
<i>58</i>&nbsp;import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
<i>59</i>&nbsp;import com.sun.tools.javac.util.*;
<i>60</i>&nbsp;import com.sun.tools.javac.util.DefinedBy.Api;
<i>61</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<i>62</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.Error;
<i>63</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.Fragment;
<i>64</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.Warning;
<i>65</i>&nbsp;import com.sun.tools.javac.util.List;
<i>66</i>&nbsp;
<i>67</i>&nbsp;import static com.sun.tools.javac.code.Flags.*;
<i>68</i>&nbsp;import static com.sun.tools.javac.code.Flags.ANNOTATION;
<i>69</i>&nbsp;import static com.sun.tools.javac.code.Flags.BLOCK;
<i>70</i>&nbsp;import static com.sun.tools.javac.code.Kinds.*;
<i>71</i>&nbsp;import static com.sun.tools.javac.code.Kinds.Kind.*;
<i>72</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.*;
<i>73</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.WILDCARD;
<i>74</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.Tag.*;
<b class="nc"><i>75</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;</b>
<b class="nc"><i>76</i>&nbsp;</b>
<i>77</i>&nbsp;/** This is the main context-dependent analysis phase in GJC. It
<i>78</i>&nbsp; *  encompasses name resolution, type checking and constant folding as
<i>79</i>&nbsp; *  subtasks. Some subtasks involve auxiliary classes.
<i>80</i>&nbsp; *  @see Check
<i>81</i>&nbsp; *  @see Resolve
<i>82</i>&nbsp; *  @see ConstFold
<i>83</i>&nbsp; *  @see Infer
<i>84</i>&nbsp; *
<i>85</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>86</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>87</i>&nbsp; *  This code and its internal interfaces are subject to change or
<i>88</i>&nbsp; *  deletion without notice.&lt;/b&gt;
<i>89</i>&nbsp; */
<i>90</i>&nbsp;public class Attr extends JCTree.Visitor {
<i>91</i>&nbsp;    protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
<i>92</i>&nbsp;
<i>93</i>&nbsp;    final Names names;
<i>94</i>&nbsp;    final Log log;
<i>95</i>&nbsp;    final Symtab syms;
<i>96</i>&nbsp;    final Resolve rs;
<i>97</i>&nbsp;    final Operators operators;
<i>98</i>&nbsp;    final Infer infer;
<i>99</i>&nbsp;    final Analyzer analyzer;
<b class="nc"><i>100</i>&nbsp;    final DeferredAttr deferredAttr;</b>
<b class="nc"><i>101</i>&nbsp;    final Check chk;</b>
<b class="nc"><i>102</i>&nbsp;    final Flow flow;</b>
<b class="nc"><i>103</i>&nbsp;    final MemberEnter memberEnter;</b>
<i>104</i>&nbsp;    final TypeEnter typeEnter;
<i>105</i>&nbsp;    final TreeMaker make;
<b class="nc"><i>106</i>&nbsp;    final ConstFold cfolder;</b>
<b class="nc"><i>107</i>&nbsp;    final Enter enter;</b>
<i>108</i>&nbsp;    final Target target;
<b class="nc"><i>109</i>&nbsp;    final Types types;</b>
<b class="nc"><i>110</i>&nbsp;    final JCDiagnostic.Factory diags;</b>
<b class="nc"><i>111</i>&nbsp;    final TypeAnnotations typeAnnotations;</b>
<b class="nc"><i>112</i>&nbsp;    final DeferredLintHandler deferredLintHandler;</b>
<b class="nc"><i>113</i>&nbsp;    final TypeEnvs typeEnvs;</b>
<b class="nc"><i>114</i>&nbsp;    final Dependencies dependencies;</b>
<b class="nc"><i>115</i>&nbsp;    final Annotate annotate;</b>
<b class="nc"><i>116</i>&nbsp;    final ArgumentAttr argumentAttr;</b>
<b class="nc"><i>117</i>&nbsp;</b>
<b class="nc"><i>118</i>&nbsp;    public static Attr instance(Context context) {</b>
<b class="nc"><i>119</i>&nbsp;        Attr instance = context.get(attrKey);</b>
<b class="nc"><i>120</i>&nbsp;        if (instance == null)</b>
<b class="nc"><i>121</i>&nbsp;            instance = new Attr(context);</b>
<b class="nc"><i>122</i>&nbsp;        return instance;</b>
<b class="nc"><i>123</i>&nbsp;    }</b>
<b class="nc"><i>124</i>&nbsp;</b>
<b class="nc"><i>125</i>&nbsp;    protected Attr(Context context) {</b>
<b class="nc"><i>126</i>&nbsp;        context.put(attrKey, this);</b>
<b class="nc"><i>127</i>&nbsp;</b>
<i>128</i>&nbsp;        names = Names.instance(context);
<b class="nc"><i>129</i>&nbsp;        log = Log.instance(context);</b>
<i>130</i>&nbsp;        syms = Symtab.instance(context);
<b class="nc"><i>131</i>&nbsp;        rs = Resolve.instance(context);</b>
<b class="nc"><i>132</i>&nbsp;        operators = Operators.instance(context);</b>
<b class="nc"><i>133</i>&nbsp;        chk = Check.instance(context);</b>
<b class="nc"><i>134</i>&nbsp;        flow = Flow.instance(context);</b>
<b class="nc"><i>135</i>&nbsp;        memberEnter = MemberEnter.instance(context);</b>
<b class="nc"><i>136</i>&nbsp;        typeEnter = TypeEnter.instance(context);</b>
<b class="nc"><i>137</i>&nbsp;        make = TreeMaker.instance(context);</b>
<b class="nc"><i>138</i>&nbsp;        enter = Enter.instance(context);</b>
<b class="nc"><i>139</i>&nbsp;        infer = Infer.instance(context);</b>
<b class="nc"><i>140</i>&nbsp;        analyzer = Analyzer.instance(context);</b>
<b class="nc"><i>141</i>&nbsp;        deferredAttr = DeferredAttr.instance(context);</b>
<b class="nc"><i>142</i>&nbsp;        cfolder = ConstFold.instance(context);</b>
<b class="nc"><i>143</i>&nbsp;        target = Target.instance(context);</b>
<b class="nc"><i>144</i>&nbsp;        types = Types.instance(context);</b>
<b class="nc"><i>145</i>&nbsp;        diags = JCDiagnostic.Factory.instance(context);</b>
<b class="nc"><i>146</i>&nbsp;        annotate = Annotate.instance(context);</b>
<b class="nc"><i>147</i>&nbsp;        typeAnnotations = TypeAnnotations.instance(context);</b>
<b class="nc"><i>148</i>&nbsp;        deferredLintHandler = DeferredLintHandler.instance(context);</b>
<b class="nc"><i>149</i>&nbsp;        typeEnvs = TypeEnvs.instance(context);</b>
<b class="nc"><i>150</i>&nbsp;        dependencies = Dependencies.instance(context);</b>
<i>151</i>&nbsp;        argumentAttr = ArgumentAttr.instance(context);
<b class="nc"><i>152</i>&nbsp;</b>
<b class="nc"><i>153</i>&nbsp;        Options options = Options.instance(context);</b>
<b class="nc"><i>154</i>&nbsp;</b>
<b class="nc"><i>155</i>&nbsp;        Source source = Source.instance(context);</b>
<b class="nc"><i>156</i>&nbsp;        allowStringsInSwitch = Feature.STRINGS_IN_SWITCH.allowedInSource(source);</b>
<b class="nc"><i>157</i>&nbsp;        allowPoly = Feature.POLY.allowedInSource(source);</b>
<b class="nc"><i>158</i>&nbsp;        allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);</b>
<i>159</i>&nbsp;        allowLambda = Feature.LAMBDA.allowedInSource(source);
<b class="nc"><i>160</i>&nbsp;        allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);</b>
<i>161</i>&nbsp;        allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<i>162</i>&nbsp;        sourceName = source.name;
<i>163</i>&nbsp;        useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<i>164</i>&nbsp;
<i>165</i>&nbsp;        statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
<i>166</i>&nbsp;        varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
<i>167</i>&nbsp;        unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
<i>168</i>&nbsp;        methodAttrInfo = new MethodAttrInfo();
<i>169</i>&nbsp;        unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
<i>170</i>&nbsp;        unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
<i>171</i>&nbsp;        recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
<i>172</i>&nbsp;    }
<i>173</i>&nbsp;
<i>174</i>&nbsp;    /** Switch: support target-typing inference
<i>175</i>&nbsp;     */
<i>176</i>&nbsp;    boolean allowPoly;
<i>177</i>&nbsp;
<i>178</i>&nbsp;    /** Switch: support type annotations.
<i>179</i>&nbsp;     */
<i>180</i>&nbsp;    boolean allowTypeAnnos;
<i>181</i>&nbsp;
<i>182</i>&nbsp;    /** Switch: support lambda expressions ?
<i>183</i>&nbsp;     */
<i>184</i>&nbsp;    boolean allowLambda;
<i>185</i>&nbsp;
<i>186</i>&nbsp;    /** Switch: support default methods ?
<i>187</i>&nbsp;     */
<i>188</i>&nbsp;    boolean allowDefaultMethods;
<i>189</i>&nbsp;
<i>190</i>&nbsp;    /** Switch: static interface methods enabled?
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    boolean allowStaticInterfaceMethods;
<i>193</i>&nbsp;
<i>194</i>&nbsp;    /**
<i>195</i>&nbsp;     * Switch: warn about use of variable before declaration?
<i>196</i>&nbsp;     * RFE: 6425594
<i>197</i>&nbsp;     */
<i>198</i>&nbsp;    boolean useBeforeDeclarationWarning;
<i>199</i>&nbsp;
<i>200</i>&nbsp;    /**
<i>201</i>&nbsp;     * Switch: allow strings in switch?
<i>202</i>&nbsp;     */
<i>203</i>&nbsp;    boolean allowStringsInSwitch;
<i>204</i>&nbsp;
<i>205</i>&nbsp;    /**
<i>206</i>&nbsp;     * Switch: name of source level; used for error reporting.
<i>207</i>&nbsp;     */
<i>208</i>&nbsp;    String sourceName;
<i>209</i>&nbsp;
<i>210</i>&nbsp;    /** Check kind and type of given tree against protokind and prototype.
<i>211</i>&nbsp;     *  If check succeeds, store type in tree and return it.
<i>212</i>&nbsp;     *  If check fails, store errType in tree and return it.
<i>213</i>&nbsp;     *  No checks are performed if the prototype is a method type.
<i>214</i>&nbsp;     *  It is not necessary in this case since we know that kind and type
<i>215</i>&nbsp;     *  are correct.
<i>216</i>&nbsp;     *
<i>217</i>&nbsp;     *  @param tree     The tree whose kind and type is checked
<i>218</i>&nbsp;     *  @param found    The computed type of the tree
<i>219</i>&nbsp;     *  @param ownkind  The computed kind of the tree
<i>220</i>&nbsp;     *  @param resultInfo  The expected result of the tree
<i>221</i>&nbsp;     */
<i>222</i>&nbsp;    Type check(final JCTree tree,
<i>223</i>&nbsp;               final Type found,
<i>224</i>&nbsp;               final KindSelector ownkind,
<i>225</i>&nbsp;               final ResultInfo resultInfo) {
<i>226</i>&nbsp;        InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
<i>227</i>&nbsp;        Type owntype;
<i>228</i>&nbsp;        boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
<i>229</i>&nbsp;                !resultInfo.pt.hasTag(METHOD) &amp;&amp;
<i>230</i>&nbsp;                !resultInfo.pt.hasTag(FORALL);
<i>231</i>&nbsp;        if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
<i>232</i>&nbsp;            log.error(tree.pos(),
<i>233</i>&nbsp;                      Errors.UnexpectedType(resultInfo.pkind.kindNames(),
<i>234</i>&nbsp;                                            ownkind.kindNames()));
<i>235</i>&nbsp;            owntype = types.createErrorType(found);
<i>236</i>&nbsp;        } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
<i>237</i>&nbsp;            //delay the check if there are inference variables in the found type
<i>238</i>&nbsp;            //this means we are dealing with a partially inferred poly expression
<i>239</i>&nbsp;            owntype = shouldCheck ? resultInfo.pt : found;
<i>240</i>&nbsp;            if (resultInfo.checkMode.installPostInferenceHook()) {
<i>241</i>&nbsp;                inferenceContext.addFreeTypeListener(List.of(found),
<i>242</i>&nbsp;                        instantiatedContext -&gt; {
<i>243</i>&nbsp;                            ResultInfo pendingResult =
<i>244</i>&nbsp;                                    resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
<i>245</i>&nbsp;                            check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
<i>246</i>&nbsp;                        });
<i>247</i>&nbsp;            }
<i>248</i>&nbsp;        } else {
<i>249</i>&nbsp;            owntype = shouldCheck ?
<i>250</i>&nbsp;            resultInfo.check(tree, found) :
<i>251</i>&nbsp;            found;
<i>252</i>&nbsp;        }
<i>253</i>&nbsp;        if (resultInfo.checkMode.updateTreeType()) {
<i>254</i>&nbsp;            tree.type = owntype;
<i>255</i>&nbsp;        }
<i>256</i>&nbsp;        return owntype;
<b class="nc"><i>257</i>&nbsp;    }</b>
<i>258</i>&nbsp;
<b class="nc"><i>259</i>&nbsp;    /** Is given blank final variable assignable, i.e. in a scope where it</b>
<b class="nc"><i>260</i>&nbsp;     *  may be assigned to even though it is final?</b>
<b class="nc"><i>261</i>&nbsp;     *  @param v      The blank final variable.</b>
<b class="nc"><i>262</i>&nbsp;     *  @param env    The current environment.</b>
<b class="nc"><i>263</i>&nbsp;     */</b>
<b class="nc"><i>264</i>&nbsp;    boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>265</i>&nbsp;        Symbol owner = env.info.scope.owner;</b>
<b class="nc"><i>266</i>&nbsp;           // owner refers to the innermost variable, method or</b>
<b class="nc"><i>267</i>&nbsp;           // initializer block declaration at this point.</b>
<i>268</i>&nbsp;        return
<i>269</i>&nbsp;            v.owner == owner
<b class="nc"><i>270</i>&nbsp;            ||</b>
<b class="nc"><i>271</i>&nbsp;            ((owner.name == names.init ||    // i.e. we are in a constructor</b>
<i>272</i>&nbsp;              owner.kind == VAR ||           // i.e. we are in a variable initializer
<i>273</i>&nbsp;              (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
<b class="nc"><i>274</i>&nbsp;             &amp;&amp;</b>
<b class="nc"><i>275</i>&nbsp;             v.owner == owner.owner</b>
<b class="nc"><i>276</i>&nbsp;             &amp;&amp;</b>
<i>277</i>&nbsp;             ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
<i>278</i>&nbsp;    }
<i>279</i>&nbsp;
<b class="nc"><i>280</i>&nbsp;    /** Check that variable can be assigned to.</b>
<b class="nc"><i>281</i>&nbsp;     *  @param pos    The current source code position.</b>
<i>282</i>&nbsp;     *  @param v      The assigned variable
<i>283</i>&nbsp;     *  @param base   If the variable is referred to in a Select, the part
<b class="nc"><i>284</i>&nbsp;     *                to the left of the `.&#39;, null otherwise.</b>
<b class="nc"><i>285</i>&nbsp;     *  @param env    The current environment.</b>
<i>286</i>&nbsp;     */
<b class="nc"><i>287</i>&nbsp;    void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {</b>
<i>288</i>&nbsp;        if (v.name == names._this) {
<i>289</i>&nbsp;            log.error(pos, Errors.CantAssignValToThis);
<i>290</i>&nbsp;        } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
<i>291</i>&nbsp;            ((v.flags() &amp; HASINIT) != 0
<i>292</i>&nbsp;             ||
<i>293</i>&nbsp;             !((base == null ||
<i>294</i>&nbsp;               TreeInfo.isThisQualifier(base)) &amp;&amp;
<i>295</i>&nbsp;               isAssignableAsBlankFinal(v, env)))) {
<b class="nc"><i>296</i>&nbsp;            if (v.isResourceVariable()) { //TWR resource</b>
<i>297</i>&nbsp;                log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
<i>298</i>&nbsp;            } else {
<b class="nc"><i>299</i>&nbsp;                log.error(pos, Errors.CantAssignValToFinalVar(v));</b>
<i>300</i>&nbsp;            }
<i>301</i>&nbsp;        }
<i>302</i>&nbsp;    }
<i>303</i>&nbsp;
<b class="nc"><i>304</i>&nbsp;    /** Does tree represent a static reference to an identifier?</b>
<i>305</i>&nbsp;     *  It is assumed that tree is either a SELECT or an IDENT.
<i>306</i>&nbsp;     *  We have to weed out selects from non-type names here.
<i>307</i>&nbsp;     *  @param tree    The candidate tree.
<b class="nc"><i>308</i>&nbsp;     */</b>
<i>309</i>&nbsp;    boolean isStaticReference(JCTree tree) {
<i>310</i>&nbsp;        if (tree.hasTag(SELECT)) {
<i>311</i>&nbsp;            Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
<i>312</i>&nbsp;            if (lsym == null || lsym.kind != TYP) {
<i>313</i>&nbsp;                return false;
<i>314</i>&nbsp;            }
<i>315</i>&nbsp;        }
<i>316</i>&nbsp;        return true;
<i>317</i>&nbsp;    }
<i>318</i>&nbsp;
<b class="nc"><i>319</i>&nbsp;    /** Is this symbol a type?</b>
<b class="nc"><i>320</i>&nbsp;     */</b>
<i>321</i>&nbsp;    static boolean isType(Symbol sym) {
<i>322</i>&nbsp;        return sym != null &amp;&amp; sym.kind == TYP;
<b class="nc"><i>323</i>&nbsp;    }</b>
<b class="nc"><i>324</i>&nbsp;</b>
<b class="nc"><i>325</i>&nbsp;    /** The current `this&#39; symbol.</b>
<b class="nc"><i>326</i>&nbsp;     *  @param env    The current environment.</b>
<i>327</i>&nbsp;     */
<b class="nc"><i>328</i>&nbsp;    Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {</b>
<i>329</i>&nbsp;        return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
<i>330</i>&nbsp;    }
<i>331</i>&nbsp;
<i>332</i>&nbsp;    /** Attribute a parsed identifier.
<i>333</i>&nbsp;     * @param tree Parsed identifier name
<i>334</i>&nbsp;     * @param topLevel The toplevel to use
<i>335</i>&nbsp;     */
<i>336</i>&nbsp;    public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
<i>337</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
<i>338</i>&nbsp;        localEnv.enclClass = make.ClassDef(make.Modifiers(0),
<b class="nc"><i>339</i>&nbsp;                                           syms.errSymbol.name,</b>
<b class="nc"><i>340</i>&nbsp;                                           null, null, null, null);</b>
<b class="nc"><i>341</i>&nbsp;        localEnv.enclClass.sym = syms.errSymbol;</b>
<b class="nc"><i>342</i>&nbsp;        return attribIdent(tree, localEnv);</b>
<i>343</i>&nbsp;    }
<i>344</i>&nbsp;
<b class="nc"><i>345</i>&nbsp;    /** Attribute a parsed identifier.</b>
<i>346</i>&nbsp;     * @param tree Parsed identifier name
<i>347</i>&nbsp;     * @param env The env to use
<i>348</i>&nbsp;     */
<i>349</i>&nbsp;    public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
<i>350</i>&nbsp;        return tree.accept(identAttributer, env);
<b class="nc"><i>351</i>&nbsp;    }</b>
<i>352</i>&nbsp;    // where
<i>353</i>&nbsp;        private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
<i>354</i>&nbsp;        private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
<i>355</i>&nbsp;            @Override @DefinedBy(Api.COMPILER_TREE)
<i>356</i>&nbsp;            public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
<i>357</i>&nbsp;                Symbol site = visit(node.getExpression(), env);
<b class="nc"><i>358</i>&nbsp;                if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)</b>
<i>359</i>&nbsp;                    return site;
<i>360</i>&nbsp;                Name name = (Name)node.getIdentifier();
<i>361</i>&nbsp;                if (site.kind == PCK) {
<i>362</i>&nbsp;                    env.toplevel.packge = (PackageSymbol)site;
<i>363</i>&nbsp;                    return rs.findIdentInPackage(env, (TypeSymbol)site, name,
<i>364</i>&nbsp;                            KindSelector.TYP_PCK);
<i>365</i>&nbsp;                } else {
<b class="nc"><i>366</i>&nbsp;                    env.enclClass.sym = (ClassSymbol)site;</b>
<b class="nc"><i>367</i>&nbsp;                    return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);</b>
<i>368</i>&nbsp;                }
<i>369</i>&nbsp;            }
<b class="nc"><i>370</i>&nbsp;</b>
<b class="nc"><i>371</i>&nbsp;            @Override @DefinedBy(Api.COMPILER_TREE)</b>
<i>372</i>&nbsp;            public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
<i>373</i>&nbsp;                return rs.findIdent(env, (Name)node.getName(), KindSelector.TYP_PCK);
<b class="nc"><i>374</i>&nbsp;            }</b>
<b class="nc"><i>375</i>&nbsp;        }</b>
<i>376</i>&nbsp;
<i>377</i>&nbsp;    public Type coerce(Type etype, Type ttype) {
<b class="nc"><i>378</i>&nbsp;        return cfolder.coerce(etype, ttype);</b>
<b class="nc"><i>379</i>&nbsp;    }</b>
<b class="nc"><i>380</i>&nbsp;</b>
<b class="nc"><i>381</i>&nbsp;    public Type attribType(JCTree node, TypeSymbol sym) {</b>
<b class="nc"><i>382</i>&nbsp;        Env&lt;AttrContext&gt; env = typeEnvs.get(sym);</b>
<b class="nc"><i>383</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());</b>
<b class="nc"><i>384</i>&nbsp;        return attribTree(node, localEnv, unknownTypeInfo);</b>
<i>385</i>&nbsp;    }
<b class="nc"><i>386</i>&nbsp;</b>
<b class="nc"><i>387</i>&nbsp;    public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {</b>
<i>388</i>&nbsp;        // Attribute qualifying package or class.
<i>389</i>&nbsp;        JCFieldAccess s = (JCFieldAccess)tree.qualid;
<i>390</i>&nbsp;        return attribTree(s.selected, env,
<i>391</i>&nbsp;                          new ResultInfo(tree.staticImport ?
<i>392</i>&nbsp;                                         KindSelector.TYP : KindSelector.TYP_PCK,
<b class="nc"><i>393</i>&nbsp;                       Type.noType));</b>
<i>394</i>&nbsp;    }
<i>395</i>&nbsp;
<i>396</i>&nbsp;    public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
<i>397</i>&nbsp;        breakTree = tree;
<b class="nc"><i>398</i>&nbsp;        JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</b>
<i>399</i>&nbsp;        try {
<i>400</i>&nbsp;            attribExpr(expr, env);
<i>401</i>&nbsp;        } catch (BreakAttr b) {
<b class="nc"><i>402</i>&nbsp;            return b.env;</b>
<b class="nc"><i>403</i>&nbsp;        } catch (AssertionError ae) {</b>
<b class="nc"><i>404</i>&nbsp;            if (ae.getCause() instanceof BreakAttr) {</b>
<i>405</i>&nbsp;                return ((BreakAttr)(ae.getCause())).env;
<i>406</i>&nbsp;            } else {
<i>407</i>&nbsp;                throw ae;
<i>408</i>&nbsp;            }
<b class="nc"><i>409</i>&nbsp;        } finally {</b>
<b class="nc"><i>410</i>&nbsp;            breakTree = null;</b>
<i>411</i>&nbsp;            log.useSource(prev);
<i>412</i>&nbsp;        }
<i>413</i>&nbsp;        return env;
<i>414</i>&nbsp;    }
<i>415</i>&nbsp;
<i>416</i>&nbsp;    public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
<b class="nc"><i>417</i>&nbsp;        breakTree = tree;</b>
<b class="nc"><i>418</i>&nbsp;        JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</b>
<i>419</i>&nbsp;        try {
<b class="nc"><i>420</i>&nbsp;            attribStat(stmt, env);</b>
<b class="nc"><i>421</i>&nbsp;        } catch (BreakAttr b) {</b>
<b class="nc"><i>422</i>&nbsp;            return b.env;</b>
<b class="nc"><i>423</i>&nbsp;        } catch (AssertionError ae) {</b>
<b class="nc"><i>424</i>&nbsp;            if (ae.getCause() instanceof BreakAttr) {</b>
<b class="nc"><i>425</i>&nbsp;                return ((BreakAttr)(ae.getCause())).env;</b>
<i>426</i>&nbsp;            } else {
<b class="nc"><i>427</i>&nbsp;                throw ae;</b>
<i>428</i>&nbsp;            }
<i>429</i>&nbsp;        } finally {
<b class="nc"><i>430</i>&nbsp;            breakTree = null;</b>
<b class="nc"><i>431</i>&nbsp;            log.useSource(prev);</b>
<b class="nc"><i>432</i>&nbsp;        }</b>
<b class="nc"><i>433</i>&nbsp;        return env;</b>
<i>434</i>&nbsp;    }
<i>435</i>&nbsp;
<i>436</i>&nbsp;    private JCTree breakTree = null;
<b class="nc"><i>437</i>&nbsp;</b>
<b class="nc"><i>438</i>&nbsp;    private static class BreakAttr extends RuntimeException {</b>
<i>439</i>&nbsp;        static final long serialVersionUID = -6924771130405446405L;
<b class="nc"><i>440</i>&nbsp;        private Env&lt;AttrContext&gt; env;</b>
<b class="nc"><i>441</i>&nbsp;        private BreakAttr(Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>442</i>&nbsp;            this.env = env;</b>
<b class="nc"><i>443</i>&nbsp;        }</b>
<b class="nc"><i>444</i>&nbsp;    }</b>
<b class="nc"><i>445</i>&nbsp;</b>
<i>446</i>&nbsp;    /**
<b class="nc"><i>447</i>&nbsp;     * Mode controlling behavior of Attr.Check</b>
<i>448</i>&nbsp;     */
<i>449</i>&nbsp;    enum CheckMode {
<b class="nc"><i>450</i>&nbsp;</b>
<b class="nc"><i>451</i>&nbsp;        NORMAL,</b>
<b class="nc"><i>452</i>&nbsp;</b>
<b class="nc"><i>453</i>&nbsp;        /**</b>
<i>454</i>&nbsp;         * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
<i>455</i>&nbsp;         * that the captured var cache in {@code InferenceContext} will be used in read-only
<b class="nc"><i>456</i>&nbsp;         * mode when performing inference checks.</b>
<i>457</i>&nbsp;         */
<b class="nc"><i>458</i>&nbsp;        NO_TREE_UPDATE {</b>
<i>459</i>&nbsp;            @Override
<i>460</i>&nbsp;            public boolean updateTreeType() {
<b class="nc"><i>461</i>&nbsp;                return false;</b>
<b class="nc"><i>462</i>&nbsp;            }</b>
<i>463</i>&nbsp;        },
<i>464</i>&nbsp;        /**
<i>465</i>&nbsp;         * Mode signalling that caller will manage free types in tree decorations.
<i>466</i>&nbsp;         */
<i>467</i>&nbsp;        NO_INFERENCE_HOOK {
<i>468</i>&nbsp;            @Override
<i>469</i>&nbsp;            public boolean installPostInferenceHook() {
<i>470</i>&nbsp;                return false;
<i>471</i>&nbsp;            }
<b class="nc"><i>472</i>&nbsp;        };</b>
<i>473</i>&nbsp;
<i>474</i>&nbsp;        public boolean updateTreeType() {
<b class="nc"><i>475</i>&nbsp;            return true;</b>
<b class="nc"><i>476</i>&nbsp;        }</b>
<b class="nc"><i>477</i>&nbsp;        public boolean installPostInferenceHook() {</b>
<b class="nc"><i>478</i>&nbsp;            return true;</b>
<i>479</i>&nbsp;        }
<i>480</i>&nbsp;    }
<i>481</i>&nbsp;
<b class="nc"><i>482</i>&nbsp;</b>
<i>483</i>&nbsp;    class ResultInfo {
<i>484</i>&nbsp;        final KindSelector pkind;
<i>485</i>&nbsp;        final Type pt;
<b class="nc"><i>486</i>&nbsp;        final CheckContext checkContext;</b>
<i>487</i>&nbsp;        final CheckMode checkMode;
<i>488</i>&nbsp;
<i>489</i>&nbsp;        ResultInfo(KindSelector pkind, Type pt) {
<b class="nc"><i>490</i>&nbsp;            this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);</b>
<i>491</i>&nbsp;        }
<i>492</i>&nbsp;
<i>493</i>&nbsp;        ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
<b class="nc"><i>494</i>&nbsp;            this(pkind, pt, chk.basicHandler, checkMode);</b>
<i>495</i>&nbsp;        }
<i>496</i>&nbsp;
<i>497</i>&nbsp;        protected ResultInfo(KindSelector pkind,
<i>498</i>&nbsp;                             Type pt, CheckContext checkContext) {
<b class="nc"><i>499</i>&nbsp;            this(pkind, pt, checkContext, CheckMode.NORMAL);</b>
<b class="nc"><i>500</i>&nbsp;        }</b>
<i>501</i>&nbsp;
<b class="nc"><i>502</i>&nbsp;        protected ResultInfo(KindSelector pkind,</b>
<i>503</i>&nbsp;                             Type pt, CheckContext checkContext, CheckMode checkMode) {
<i>504</i>&nbsp;            this.pkind = pkind;
<i>505</i>&nbsp;            this.pt = pt;
<i>506</i>&nbsp;            this.checkContext = checkContext;
<i>507</i>&nbsp;            this.checkMode = checkMode;
<i>508</i>&nbsp;        }
<b class="nc"><i>509</i>&nbsp;</b>
<b class="nc"><i>510</i>&nbsp;        /**</b>
<i>511</i>&nbsp;         * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
<i>512</i>&nbsp;         * @param tree The tree to be type-checked.
<b class="nc"><i>513</i>&nbsp;         * @return true if {@ArgumentAttr} should be used.</b>
<i>514</i>&nbsp;         */
<i>515</i>&nbsp;        protected boolean needsArgumentAttr(JCTree tree) { return false; }
<i>516</i>&nbsp;
<b class="nc"><i>517</i>&nbsp;        protected Type check(final DiagnosticPosition pos, final Type found) {</b>
<i>518</i>&nbsp;            return chk.checkType(pos, found, pt, checkContext);
<i>519</i>&nbsp;        }
<i>520</i>&nbsp;
<b class="nc"><i>521</i>&nbsp;        protected ResultInfo dup(Type newPt) {</b>
<i>522</i>&nbsp;            return new ResultInfo(pkind, newPt, checkContext, checkMode);
<i>523</i>&nbsp;        }
<i>524</i>&nbsp;
<i>525</i>&nbsp;        protected ResultInfo dup(CheckContext newContext) {
<i>526</i>&nbsp;            return new ResultInfo(pkind, pt, newContext, checkMode);
<i>527</i>&nbsp;        }
<i>528</i>&nbsp;
<i>529</i>&nbsp;        protected ResultInfo dup(Type newPt, CheckContext newContext) {
<i>530</i>&nbsp;            return new ResultInfo(pkind, newPt, newContext, checkMode);
<i>531</i>&nbsp;        }
<i>532</i>&nbsp;
<i>533</i>&nbsp;        protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
<i>534</i>&nbsp;            return new ResultInfo(pkind, newPt, newContext, newMode);
<i>535</i>&nbsp;        }
<b class="nc"><i>536</i>&nbsp;</b>
<i>537</i>&nbsp;        protected ResultInfo dup(CheckMode newMode) {
<i>538</i>&nbsp;            return new ResultInfo(pkind, pt, checkContext, newMode);
<i>539</i>&nbsp;        }
<b class="nc"><i>540</i>&nbsp;</b>
<i>541</i>&nbsp;        @Override
<i>542</i>&nbsp;        public String toString() {
<i>543</i>&nbsp;            if (pt != null) {
<i>544</i>&nbsp;                return pt.toString();
<i>545</i>&nbsp;            } else {
<i>546</i>&nbsp;                return &quot;&quot;;
<i>547</i>&nbsp;            }
<i>548</i>&nbsp;        }
<i>549</i>&nbsp;    }
<i>550</i>&nbsp;
<i>551</i>&nbsp;    class MethodAttrInfo extends ResultInfo {
<i>552</i>&nbsp;        public MethodAttrInfo() {
<i>553</i>&nbsp;            this(chk.basicHandler);
<i>554</i>&nbsp;        }
<i>555</i>&nbsp;
<i>556</i>&nbsp;        public MethodAttrInfo(CheckContext checkContext) {
<i>557</i>&nbsp;            super(KindSelector.VAL, Infer.anyPoly, checkContext);
<i>558</i>&nbsp;        }
<i>559</i>&nbsp;
<i>560</i>&nbsp;        @Override
<i>561</i>&nbsp;        protected boolean needsArgumentAttr(JCTree tree) {
<i>562</i>&nbsp;            return true;
<i>563</i>&nbsp;        }
<i>564</i>&nbsp;
<i>565</i>&nbsp;        protected ResultInfo dup(Type newPt) {
<i>566</i>&nbsp;            throw new IllegalStateException();
<i>567</i>&nbsp;        }
<i>568</i>&nbsp;
<i>569</i>&nbsp;        protected ResultInfo dup(CheckContext newContext) {
<i>570</i>&nbsp;            return new MethodAttrInfo(newContext);
<b class="nc"><i>571</i>&nbsp;        }</b>
<b class="nc"><i>572</i>&nbsp;</b>
<i>573</i>&nbsp;        protected ResultInfo dup(Type newPt, CheckContext newContext) {
<b class="nc"><i>574</i>&nbsp;            throw new IllegalStateException();</b>
<b class="nc"><i>575</i>&nbsp;        }</b>
<b class="nc"><i>576</i>&nbsp;</b>
<b class="nc"><i>577</i>&nbsp;        protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {</b>
<b class="nc"><i>578</i>&nbsp;            throw new IllegalStateException();</b>
<b class="nc"><i>579</i>&nbsp;        }</b>
<i>580</i>&nbsp;
<b class="nc"><i>581</i>&nbsp;        protected ResultInfo dup(CheckMode newMode) {</b>
<b class="nc"><i>582</i>&nbsp;            throw new IllegalStateException();</b>
<b class="nc"><i>583</i>&nbsp;        }</b>
<b class="nc"><i>584</i>&nbsp;    }</b>
<i>585</i>&nbsp;
<b class="nc"><i>586</i>&nbsp;    class RecoveryInfo extends ResultInfo {</b>
<b class="nc"><i>587</i>&nbsp;</b>
<i>588</i>&nbsp;        public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
<i>589</i>&nbsp;            super(KindSelector.VAL, Type.recoveryType,
<i>590</i>&nbsp;                  new Check.NestedCheckContext(chk.basicHandler) {
<i>591</i>&nbsp;                @Override
<b class="nc"><i>592</i>&nbsp;                public DeferredAttr.DeferredAttrContext deferredAttrContext() {</b>
<b class="nc"><i>593</i>&nbsp;                    return deferredAttrContext;</b>
<b class="nc"><i>594</i>&nbsp;                }</b>
<b class="nc"><i>595</i>&nbsp;                @Override</b>
<i>596</i>&nbsp;                public boolean compatible(Type found, Type req, Warner warn) {
<b class="nc"><i>597</i>&nbsp;                    return true;</b>
<i>598</i>&nbsp;                }
<i>599</i>&nbsp;                @Override
<i>600</i>&nbsp;                public void report(DiagnosticPosition pos, JCDiagnostic details) {
<b class="nc"><i>601</i>&nbsp;                    chk.basicHandler.report(pos, details);</b>
<b class="nc"><i>602</i>&nbsp;                }</b>
<b class="nc"><i>603</i>&nbsp;            });</b>
<b class="nc"><i>604</i>&nbsp;        }</b>
<b class="nc"><i>605</i>&nbsp;    }</b>
<i>606</i>&nbsp;
<b class="nc"><i>607</i>&nbsp;    final ResultInfo statInfo;</b>
<i>608</i>&nbsp;    final ResultInfo varAssignmentInfo;
<b class="nc"><i>609</i>&nbsp;    final ResultInfo methodAttrInfo;</b>
<b class="nc"><i>610</i>&nbsp;    final ResultInfo unknownExprInfo;</b>
<b class="nc"><i>611</i>&nbsp;    final ResultInfo unknownTypeInfo;</b>
<b class="nc"><i>612</i>&nbsp;    final ResultInfo unknownTypeExprInfo;</b>
<i>613</i>&nbsp;    final ResultInfo recoveryInfo;
<i>614</i>&nbsp;
<i>615</i>&nbsp;    Type pt() {
<i>616</i>&nbsp;        return resultInfo.pt;
<i>617</i>&nbsp;    }
<b class="nc"><i>618</i>&nbsp;</b>
<i>619</i>&nbsp;    KindSelector pkind() {
<i>620</i>&nbsp;        return resultInfo.pkind;
<i>621</i>&nbsp;    }
<i>622</i>&nbsp;
<i>623</i>&nbsp;/* ************************************************************************
<i>624</i>&nbsp; * Visitor methods
<b class="nc"><i>625</i>&nbsp; *************************************************************************/</b>
<i>626</i>&nbsp;
<i>627</i>&nbsp;    /** Visitor argument: the current environment.
<i>628</i>&nbsp;     */
<i>629</i>&nbsp;    Env&lt;AttrContext&gt; env;
<i>630</i>&nbsp;
<b class="nc"><i>631</i>&nbsp;    /** Visitor argument: the currently expected attribution result.</b>
<b class="nc"><i>632</i>&nbsp;     */</b>
<i>633</i>&nbsp;    ResultInfo resultInfo;
<i>634</i>&nbsp;
<i>635</i>&nbsp;    /** Visitor result: the computed type.
<i>636</i>&nbsp;     */
<i>637</i>&nbsp;    Type result;
<b class="nc"><i>638</i>&nbsp;</b>
<b class="nc"><i>639</i>&nbsp;    /** Visitor method: attribute a tree, catching any completion failure</b>
<i>640</i>&nbsp;     *  exceptions. Return the tree&#39;s type.
<i>641</i>&nbsp;     *
<i>642</i>&nbsp;     *  @param tree    The tree to be visited.
<i>643</i>&nbsp;     *  @param env     The environment visitor argument.
<i>644</i>&nbsp;     *  @param resultInfo   The result info visitor argument.
<b class="nc"><i>645</i>&nbsp;     */</b>
<i>646</i>&nbsp;    Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
<i>647</i>&nbsp;        Env&lt;AttrContext&gt; prevEnv = this.env;
<i>648</i>&nbsp;        ResultInfo prevResult = this.resultInfo;
<i>649</i>&nbsp;        try {
<i>650</i>&nbsp;            this.env = env;
<b class="nc"><i>651</i>&nbsp;            this.resultInfo = resultInfo;</b>
<b class="nc"><i>652</i>&nbsp;            if (resultInfo.needsArgumentAttr(tree)) {</b>
<b class="nc"><i>653</i>&nbsp;                result = argumentAttr.attribArg(tree, env);</b>
<b class="nc"><i>654</i>&nbsp;            } else {</b>
<i>655</i>&nbsp;                tree.accept(this);
<i>656</i>&nbsp;            }
<i>657</i>&nbsp;            if (tree == breakTree &amp;&amp;
<i>658</i>&nbsp;                    resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
<i>659</i>&nbsp;                throw new BreakAttr(copyEnv(env));
<b class="nc"><i>660</i>&nbsp;            }</b>
<b class="nc"><i>661</i>&nbsp;            return result;</b>
<i>662</i>&nbsp;        } catch (CompletionFailure ex) {
<i>663</i>&nbsp;            tree.type = syms.errType;
<i>664</i>&nbsp;            return chk.completionError(tree.pos(), ex);
<i>665</i>&nbsp;        } finally {
<i>666</i>&nbsp;            this.env = prevEnv;
<b class="nc"><i>667</i>&nbsp;            this.resultInfo = prevResult;</b>
<b class="nc"><i>668</i>&nbsp;        }</b>
<i>669</i>&nbsp;    }
<b class="nc"><i>670</i>&nbsp;</b>
<b class="nc"><i>671</i>&nbsp;    Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>672</i>&nbsp;        Env&lt;AttrContext&gt; newEnv =</b>
<i>673</i>&nbsp;                env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
<b class="nc"><i>674</i>&nbsp;        if (newEnv.outer != null) {</b>
<i>675</i>&nbsp;            newEnv.outer = copyEnv(newEnv.outer);
<b class="nc"><i>676</i>&nbsp;        }</b>
<b class="nc"><i>677</i>&nbsp;        return newEnv;</b>
<b class="nc"><i>678</i>&nbsp;    }</b>
<i>679</i>&nbsp;
<i>680</i>&nbsp;    WriteableScope copyScope(WriteableScope sc) {
<i>681</i>&nbsp;        WriteableScope newScope = WriteableScope.create(sc.owner);
<i>682</i>&nbsp;        List&lt;Symbol&gt; elemsList = List.nil();
<i>683</i>&nbsp;        for (Symbol sym : sc.getSymbols()) {
<i>684</i>&nbsp;            elemsList = elemsList.prepend(sym);
<b class="nc"><i>685</i>&nbsp;        }</b>
<b class="nc"><i>686</i>&nbsp;        for (Symbol s : elemsList) {</b>
<b class="nc"><i>687</i>&nbsp;            newScope.enter(s);</b>
<b class="nc"><i>688</i>&nbsp;        }</b>
<i>689</i>&nbsp;        return newScope;
<i>690</i>&nbsp;    }
<i>691</i>&nbsp;
<i>692</i>&nbsp;    /** Derived visitor method: attribute an expression tree.
<i>693</i>&nbsp;     */
<i>694</i>&nbsp;    public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
<b class="nc"><i>695</i>&nbsp;        return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));</b>
<b class="nc"><i>696</i>&nbsp;    }</b>
<i>697</i>&nbsp;
<i>698</i>&nbsp;    /** Derived visitor method: attribute an expression tree with
<i>699</i>&nbsp;     *  no constraints on the computed type.
<i>700</i>&nbsp;     */
<i>701</i>&nbsp;    public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
<i>702</i>&nbsp;        return attribTree(tree, env, unknownExprInfo);
<i>703</i>&nbsp;    }
<i>704</i>&nbsp;
<i>705</i>&nbsp;    /** Derived visitor method: attribute a type tree.
<b class="nc"><i>706</i>&nbsp;     */</b>
<b class="nc"><i>707</i>&nbsp;    public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>708</i>&nbsp;        Type result = attribType(tree, env, Type.noType);</b>
<b class="nc"><i>709</i>&nbsp;        return result;</b>
<b class="nc"><i>710</i>&nbsp;    }</b>
<b class="nc"><i>711</i>&nbsp;</b>
<b class="nc"><i>712</i>&nbsp;    /** Derived visitor method: attribute a type tree.</b>
<b class="nc"><i>713</i>&nbsp;     */</b>
<b class="nc"><i>714</i>&nbsp;    Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {</b>
<b class="nc"><i>715</i>&nbsp;        Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));</b>
<i>716</i>&nbsp;        return result;
<i>717</i>&nbsp;    }
<b class="nc"><i>718</i>&nbsp;</b>
<i>719</i>&nbsp;    /** Derived visitor method: attribute a statement or definition tree.
<b class="nc"><i>720</i>&nbsp;     */</b>
<b class="nc"><i>721</i>&nbsp;    public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>722</i>&nbsp;        Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);</b>
<b class="nc"><i>723</i>&nbsp;        try {</b>
<b class="nc"><i>724</i>&nbsp;            return attribTree(tree, env, statInfo);</b>
<i>725</i>&nbsp;        } finally {
<i>726</i>&nbsp;            analyzer.analyzeIfNeeded(tree, analyzeEnv);
<i>727</i>&nbsp;        }
<i>728</i>&nbsp;    }
<i>729</i>&nbsp;
<i>730</i>&nbsp;    /** Attribute a list of expressions, returning a list of types.
<i>731</i>&nbsp;     */
<b class="nc"><i>732</i>&nbsp;    List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {</b>
<b class="nc"><i>733</i>&nbsp;        ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>734</i>&nbsp;        for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)</b>
<i>735</i>&nbsp;            ts.append(attribExpr(l.head, env, pt));
<i>736</i>&nbsp;        return ts.toList();
<i>737</i>&nbsp;    }
<i>738</i>&nbsp;
<i>739</i>&nbsp;    /** Attribute a list of statements, returning nothing.
<i>740</i>&nbsp;     */
<i>741</i>&nbsp;    &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
<i>742</i>&nbsp;        for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
<i>743</i>&nbsp;            attribStat(l.head, env);
<i>744</i>&nbsp;    }
<i>745</i>&nbsp;
<i>746</i>&nbsp;    /** Attribute the arguments in a method call, returning the method kind.
<i>747</i>&nbsp;     */
<i>748</i>&nbsp;    KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
<b class="nc"><i>749</i>&nbsp;        KindSelector kind = initialKind;</b>
<b class="nc"><i>750</i>&nbsp;        for (JCExpression arg : trees) {</b>
<i>751</i>&nbsp;            Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
<i>752</i>&nbsp;            if (argtype.hasTag(DEFERRED)) {
<i>753</i>&nbsp;                kind = KindSelector.of(KindSelector.POLY, kind);
<i>754</i>&nbsp;            }
<i>755</i>&nbsp;            argtypes.append(argtype);
<i>756</i>&nbsp;        }
<i>757</i>&nbsp;        return kind;
<b class="nc"><i>758</i>&nbsp;    }</b>
<b class="nc"><i>759</i>&nbsp;</b>
<b class="nc"><i>760</i>&nbsp;    /** Attribute a type argument list, returning a list of types.</b>
<b class="nc"><i>761</i>&nbsp;     *  Caller is responsible for calling checkRefTypes.</b>
<b class="nc"><i>762</i>&nbsp;     */</b>
<i>763</i>&nbsp;    List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
<b class="nc"><i>764</i>&nbsp;        ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();</b>
<i>765</i>&nbsp;        for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
<i>766</i>&nbsp;            argtypes.append(attribType(l.head, env));
<b class="nc"><i>767</i>&nbsp;        return argtypes.toList();</b>
<i>768</i>&nbsp;    }
<i>769</i>&nbsp;
<i>770</i>&nbsp;    /** Attribute a type argument list, returning a list of types.
<i>771</i>&nbsp;     *  Check that all the types are references.
<i>772</i>&nbsp;     */
<i>773</i>&nbsp;    List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
<i>774</i>&nbsp;        List&lt;Type&gt; types = attribAnyTypes(trees, env);
<i>775</i>&nbsp;        return chk.checkRefTypes(trees, types);
<i>776</i>&nbsp;    }
<i>777</i>&nbsp;
<i>778</i>&nbsp;    /**
<i>779</i>&nbsp;     * Attribute type variables (of generic classes or methods).
<i>780</i>&nbsp;     * Compound types are attributed later in attribBounds.
<i>781</i>&nbsp;     * @param typarams the type variables to enter
<i>782</i>&nbsp;     * @param env      the current environment
<i>783</i>&nbsp;     */
<b class="nc"><i>784</i>&nbsp;    void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env) {</b>
<i>785</i>&nbsp;        for (JCTypeParameter tvar : typarams) {
<b class="nc"><i>786</i>&nbsp;            TypeVar a = (TypeVar)tvar.type;</b>
<b class="nc"><i>787</i>&nbsp;            a.tsym.flags_field |= UNATTRIBUTED;</b>
<i>788</i>&nbsp;            a.bound = Type.noType;
<i>789</i>&nbsp;            if (!tvar.bounds.isEmpty()) {
<i>790</i>&nbsp;                List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));
<i>791</i>&nbsp;                for (JCExpression bound : tvar.bounds.tail)
<i>792</i>&nbsp;                    bounds = bounds.prepend(attribType(bound, env));
<i>793</i>&nbsp;                types.setBounds(a, bounds.reverse());
<i>794</i>&nbsp;            } else {
<b class="nc"><i>795</i>&nbsp;                // if no bounds are given, assume a single bound of</b>
<b class="nc"><i>796</i>&nbsp;                // java.lang.Object.</b>
<b class="nc"><i>797</i>&nbsp;                types.setBounds(a, List.of(syms.objectType));</b>
<i>798</i>&nbsp;            }
<b class="nc"><i>799</i>&nbsp;            a.tsym.flags_field &amp;= ~UNATTRIBUTED;</b>
<b class="nc"><i>800</i>&nbsp;        }</b>
<b class="nc"><i>801</i>&nbsp;        for (JCTypeParameter tvar : typarams) {</b>
<i>802</i>&nbsp;            chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
<b class="nc"><i>803</i>&nbsp;        }</b>
<b class="nc"><i>804</i>&nbsp;    }</b>
<b class="nc"><i>805</i>&nbsp;</b>
<i>806</i>&nbsp;    /**
<i>807</i>&nbsp;     * Attribute the type references in a list of annotations.
<b class="nc"><i>808</i>&nbsp;     */</b>
<i>809</i>&nbsp;    void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
<b class="nc"><i>810</i>&nbsp;                               Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>811</i>&nbsp;        for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {</b>
<i>812</i>&nbsp;            JCAnnotation a = al.head;
<i>813</i>&nbsp;            attribType(a.annotationType, env);
<b class="nc"><i>814</i>&nbsp;        }</b>
<b class="nc"><i>815</i>&nbsp;    }</b>
<i>816</i>&nbsp;
<b class="nc"><i>817</i>&nbsp;    /**</b>
<b class="nc"><i>818</i>&nbsp;     * Attribute a &quot;lazy constant value&quot;.</b>
<b class="nc"><i>819</i>&nbsp;     *  @param env         The env for the const value</b>
<i>820</i>&nbsp;     *  @param variable    The initializer for the const value
<b class="nc"><i>821</i>&nbsp;     *  @param type        The expected type, or null</b>
<b class="nc"><i>822</i>&nbsp;     *  @see VarSymbol#setLazyConstValue</b>
<b class="nc"><i>823</i>&nbsp;     */</b>
<i>824</i>&nbsp;    public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
<i>825</i>&nbsp;                                      JCVariableDecl variable,
<b class="nc"><i>826</i>&nbsp;                                      Type type) {</b>
<b class="nc"><i>827</i>&nbsp;</b>
<i>828</i>&nbsp;        DiagnosticPosition prevLintPos
<i>829</i>&nbsp;                = deferredLintHandler.setPos(variable.pos());
<i>830</i>&nbsp;
<b class="nc"><i>831</i>&nbsp;        final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);</b>
<b class="nc"><i>832</i>&nbsp;        try {</b>
<b class="nc"><i>833</i>&nbsp;            Type itype = attribExpr(variable.init, env, type);</b>
<b class="nc"><i>834</i>&nbsp;            if (variable.isImplicitlyTyped()) {</b>
<i>835</i>&nbsp;                //fixup local variable type
<i>836</i>&nbsp;                type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
<i>837</i>&nbsp;            }
<i>838</i>&nbsp;            if (itype.constValue() != null) {
<i>839</i>&nbsp;                return coerce(itype, type).constValue();
<b class="nc"><i>840</i>&nbsp;            } else {</b>
<b class="nc"><i>841</i>&nbsp;                return null;</b>
<i>842</i>&nbsp;            }
<i>843</i>&nbsp;        } finally {
<i>844</i>&nbsp;            log.useSource(prevSource);
<i>845</i>&nbsp;            deferredLintHandler.setPos(prevLintPos);
<i>846</i>&nbsp;        }
<b class="nc"><i>847</i>&nbsp;    }</b>
<b class="nc"><i>848</i>&nbsp;</b>
<i>849</i>&nbsp;    /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
<i>850</i>&nbsp;     *  Supertypes of anonymous inner classes are usually already attributed.
<b class="nc"><i>851</i>&nbsp;     *</b>
<b class="nc"><i>852</i>&nbsp;     *  @param tree              The tree making up the type reference.</b>
<i>853</i>&nbsp;     *  @param env               The environment current at the reference.
<b class="nc"><i>854</i>&nbsp;     *  @param classExpected     true if only a class is expected here.</b>
<i>855</i>&nbsp;     *  @param interfaceExpected true if only an interface is expected here.
<i>856</i>&nbsp;     */
<b class="nc"><i>857</i>&nbsp;    Type attribBase(JCTree tree,</b>
<i>858</i>&nbsp;                    Env&lt;AttrContext&gt; env,
<i>859</i>&nbsp;                    boolean classExpected,
<i>860</i>&nbsp;                    boolean interfaceExpected,
<i>861</i>&nbsp;                    boolean checkExtensible) {
<i>862</i>&nbsp;        Type t = tree.type != null ?
<i>863</i>&nbsp;            tree.type :
<b class="nc"><i>864</i>&nbsp;            attribType(tree, env);</b>
<b class="nc"><i>865</i>&nbsp;        return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);</b>
<i>866</i>&nbsp;    }
<i>867</i>&nbsp;    Type checkBase(Type t,
<b class="nc"><i>868</i>&nbsp;                   JCTree tree,</b>
<i>869</i>&nbsp;                   Env&lt;AttrContext&gt; env,
<b class="nc"><i>870</i>&nbsp;                   boolean classExpected,</b>
<b class="nc"><i>871</i>&nbsp;                   boolean interfaceExpected,</b>
<i>872</i>&nbsp;                   boolean checkExtensible) {
<i>873</i>&nbsp;        final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
<i>874</i>&nbsp;                (((JCTypeApply) tree).clazz).pos() : tree.pos();
<i>875</i>&nbsp;        if (t.tsym.isAnonymous()) {
<b class="nc"><i>876</i>&nbsp;            log.error(pos, Errors.CantInheritFromAnon);</b>
<b class="nc"><i>877</i>&nbsp;            return types.createErrorType(t);</b>
<i>878</i>&nbsp;        }
<b class="nc"><i>879</i>&nbsp;        if (t.isErroneous())</b>
<b class="nc"><i>880</i>&nbsp;            return t;</b>
<b class="nc"><i>881</i>&nbsp;        if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {</b>
<i>882</i>&nbsp;            // check that type variable is already visible
<b class="nc"><i>883</i>&nbsp;            if (t.getUpperBound() == null) {</b>
<b class="nc"><i>884</i>&nbsp;                log.error(pos, Errors.IllegalForwardRef);</b>
<i>885</i>&nbsp;                return types.createErrorType(t);
<i>886</i>&nbsp;            }
<i>887</i>&nbsp;        } else {
<i>888</i>&nbsp;            t = chk.checkClassType(pos, t, checkExtensible);
<b class="nc"><i>889</i>&nbsp;        }</b>
<b class="nc"><i>890</i>&nbsp;        if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {</b>
<i>891</i>&nbsp;            log.error(pos, Errors.IntfExpectedHere);
<b class="nc"><i>892</i>&nbsp;            // return errType is necessary since otherwise there might</b>
<i>893</i>&nbsp;            // be undetected cycles which cause attribution to loop
<i>894</i>&nbsp;            return types.createErrorType(t);
<i>895</i>&nbsp;        } else if (checkExtensible &amp;&amp;
<b class="nc"><i>896</i>&nbsp;                   classExpected &amp;&amp;</b>
<b class="nc"><i>897</i>&nbsp;                   (t.tsym.flags() &amp; INTERFACE) != 0) {</b>
<i>898</i>&nbsp;            log.error(pos, Errors.NoIntfExpectedHere);
<b class="nc"><i>899</i>&nbsp;            return types.createErrorType(t);</b>
<i>900</i>&nbsp;        }
<b class="nc"><i>901</i>&nbsp;        if (checkExtensible &amp;&amp;</b>
<i>902</i>&nbsp;            ((t.tsym.flags() &amp; FINAL) != 0)) {
<b class="nc"><i>903</i>&nbsp;            log.error(pos,</b>
<b class="nc"><i>904</i>&nbsp;                      Errors.CantInheritFromFinal(t.tsym));</b>
<i>905</i>&nbsp;        }
<i>906</i>&nbsp;        chk.checkNonCyclic(pos, t);
<i>907</i>&nbsp;        return t;
<b class="nc"><i>908</i>&nbsp;    }</b>
<b class="nc"><i>909</i>&nbsp;</b>
<i>910</i>&nbsp;    Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
<b class="nc"><i>911</i>&nbsp;        Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);</b>
<b class="nc"><i>912</i>&nbsp;        id.type = env.info.scope.owner.enclClass().type;</b>
<b class="nc"><i>913</i>&nbsp;        id.sym = env.info.scope.owner.enclClass();</b>
<b class="nc"><i>914</i>&nbsp;        return id.type;</b>
<i>915</i>&nbsp;    }
<i>916</i>&nbsp;
<i>917</i>&nbsp;    public void visitClassDef(JCClassDecl tree) {
<b class="nc"><i>918</i>&nbsp;        Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =</b>
<b class="nc"><i>919</i>&nbsp;                Optional.ofNullable(env.info.isSpeculative ?</b>
<i>920</i>&nbsp;                        argumentAttr.withLocalCacheContext() : null);
<i>921</i>&nbsp;        try {
<b class="nc"><i>922</i>&nbsp;            // Local and anonymous classes have not been entered yet, so we need to</b>
<i>923</i>&nbsp;            // do it now.
<i>924</i>&nbsp;            if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
<b class="nc"><i>925</i>&nbsp;                enter.classEnter(tree, env);</b>
<i>926</i>&nbsp;            } else {
<i>927</i>&nbsp;                // If this class declaration is part of a class level annotation,
<b class="nc"><i>928</i>&nbsp;                // as in @MyAnno(new Object() {}) class MyClass {}, enter it in</b>
<b class="nc"><i>929</i>&nbsp;                // order to simplify later steps and allow for sensible error</b>
<i>930</i>&nbsp;                // messages.
<i>931</i>&nbsp;                if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
<b class="nc"><i>932</i>&nbsp;                    enter.classEnter(tree, env);</b>
<i>933</i>&nbsp;            }
<i>934</i>&nbsp;
<i>935</i>&nbsp;            ClassSymbol c = tree.sym;
<b class="nc"><i>936</i>&nbsp;            if (c == null) {</b>
<b class="nc"><i>937</i>&nbsp;                // exit in case something drastic went wrong during enter.</b>
<b class="nc"><i>938</i>&nbsp;                result = null;</b>
<i>939</i>&nbsp;            } else {
<i>940</i>&nbsp;                // make sure class has been completed:
<i>941</i>&nbsp;                c.complete();
<b class="nc"><i>942</i>&nbsp;</b>
<i>943</i>&nbsp;                // If this class appears as an anonymous class
<b class="nc"><i>944</i>&nbsp;                // in a superclass constructor call</b>
<b class="nc"><i>945</i>&nbsp;                // disable implicit outer instance from being passed.</b>
<i>946</i>&nbsp;                // (This would be an illegal access to &quot;this before super&quot;).
<i>947</i>&nbsp;                if (env.info.isSelfCall &amp;&amp;
<i>948</i>&nbsp;                        env.tree.hasTag(NEWCLASS)) {
<b class="nc"><i>949</i>&nbsp;                    c.flags_field |= NOOUTERTHIS;</b>
<b class="nc"><i>950</i>&nbsp;                }</b>
<i>951</i>&nbsp;                attribClass(tree.pos(), c);
<i>952</i>&nbsp;                result = tree.type = c.type;
<i>953</i>&nbsp;            }
<b class="nc"><i>954</i>&nbsp;        } finally {</b>
<i>955</i>&nbsp;            localCacheContext.ifPresent(LocalCacheContext::leave);
<b class="nc"><i>956</i>&nbsp;        }</b>
<i>957</i>&nbsp;    }
<i>958</i>&nbsp;
<b class="nc"><i>959</i>&nbsp;    public void visitMethodDef(JCMethodDecl tree) {</b>
<b class="nc"><i>960</i>&nbsp;        MethodSymbol m = tree.sym;</b>
<i>961</i>&nbsp;        boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
<b class="nc"><i>962</i>&nbsp;</b>
<i>963</i>&nbsp;        Lint lint = env.info.lint.augment(m);
<i>964</i>&nbsp;        Lint prevLint = chk.setLint(lint);
<i>965</i>&nbsp;        MethodSymbol prevMethod = chk.setMethod(m);
<b class="nc"><i>966</i>&nbsp;        try {</b>
<i>967</i>&nbsp;            deferredLintHandler.flush(tree.pos());
<b class="nc"><i>968</i>&nbsp;            chk.checkDeprecatedAnnotation(tree.pos(), m);</b>
<b class="nc"><i>969</i>&nbsp;</b>
<b class="nc"><i>970</i>&nbsp;</b>
<b class="nc"><i>971</i>&nbsp;            // Create a new environment with local scope</b>
<i>972</i>&nbsp;            // for attributing the method.
<i>973</i>&nbsp;            Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
<b class="nc"><i>974</i>&nbsp;            localEnv.info.lint = lint;</b>
<b class="nc"><i>975</i>&nbsp;</b>
<b class="nc"><i>976</i>&nbsp;            attribStats(tree.typarams, localEnv);</b>
<i>977</i>&nbsp;
<b class="nc"><i>978</i>&nbsp;            // If we override any other methods, check that we do so properly.</b>
<i>979</i>&nbsp;            // JLS ???
<b class="nc"><i>980</i>&nbsp;            if (m.isStatic()) {</b>
<b class="nc"><i>981</i>&nbsp;                chk.checkHideClashes(tree.pos(), env.enclClass.type, m);</b>
<i>982</i>&nbsp;            } else {
<i>983</i>&nbsp;                chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
<i>984</i>&nbsp;            }
<i>985</i>&nbsp;            chk.checkOverride(env, tree, m);
<b class="nc"><i>986</i>&nbsp;</b>
<b class="nc"><i>987</i>&nbsp;            if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {</b>
<b class="nc"><i>988</i>&nbsp;                log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));</b>
<b class="nc"><i>989</i>&nbsp;            }</b>
<b class="nc"><i>990</i>&nbsp;</b>
<b class="nc"><i>991</i>&nbsp;            // Enter all type parameters into the local method scope.</b>
<b class="nc"><i>992</i>&nbsp;            for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)</b>
<b class="nc"><i>993</i>&nbsp;                localEnv.info.scope.enterIfAbsent(l.head.type.tsym);</b>
<i>994</i>&nbsp;
<b class="nc"><i>995</i>&nbsp;            ClassSymbol owner = env.enclClass.sym;</b>
<i>996</i>&nbsp;            if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
<b class="nc"><i>997</i>&nbsp;                    (tree.params.nonEmpty() ||</b>
<i>998</i>&nbsp;                    tree.recvparam != null))
<i>999</i>&nbsp;                log.error(tree.params.nonEmpty() ?
<i>1000</i>&nbsp;                        tree.params.head.pos() :
<i>1001</i>&nbsp;                        tree.recvparam.pos(),
<b class="nc"><i>1002</i>&nbsp;                        Errors.IntfAnnotationMembersCantHaveParams);</b>
<i>1003</i>&nbsp;
<i>1004</i>&nbsp;            // Attribute all value parameters.
<i>1005</i>&nbsp;            for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
<i>1006</i>&nbsp;                attribStat(l.head, localEnv);
<i>1007</i>&nbsp;            }
<i>1008</i>&nbsp;
<b class="nc"><i>1009</i>&nbsp;            chk.checkVarargsMethodDecl(localEnv, tree);</b>
<b class="nc"><i>1010</i>&nbsp;</b>
<i>1011</i>&nbsp;            // Check that type parameters are well-formed.
<i>1012</i>&nbsp;            chk.validate(tree.typarams, localEnv);
<b class="nc"><i>1013</i>&nbsp;</b>
<i>1014</i>&nbsp;            // Check that result type is well-formed.
<i>1015</i>&nbsp;            if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
<b class="nc"><i>1016</i>&nbsp;                chk.validate(tree.restype, localEnv);</b>
<b class="nc"><i>1017</i>&nbsp;</b>
<i>1018</i>&nbsp;            // Check that receiver type is well-formed.
<i>1019</i>&nbsp;            if (tree.recvparam != null) {
<b class="nc"><i>1020</i>&nbsp;                // Use a new environment to check the receiver parameter.</b>
<b class="nc"><i>1021</i>&nbsp;                // Otherwise I get &quot;might not have been initialized&quot; errors.</b>
<b class="nc"><i>1022</i>&nbsp;                // Is there a better way?</b>
<i>1023</i>&nbsp;                Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
<i>1024</i>&nbsp;                attribType(tree.recvparam, newEnv);
<i>1025</i>&nbsp;                chk.validate(tree.recvparam, newEnv);
<i>1026</i>&nbsp;            }
<b class="nc"><i>1027</i>&nbsp;</b>
<b class="nc"><i>1028</i>&nbsp;            // annotation method checks</b>
<i>1029</i>&nbsp;            if ((owner.flags() &amp; ANNOTATION) != 0) {
<b class="nc"><i>1030</i>&nbsp;                // annotation method cannot have throws clause</b>
<i>1031</i>&nbsp;                if (tree.thrown.nonEmpty()) {
<i>1032</i>&nbsp;                    log.error(tree.thrown.head.pos(),
<b class="nc"><i>1033</i>&nbsp;                              Errors.ThrowsNotAllowedInIntfAnnotation);</b>
<b class="nc"><i>1034</i>&nbsp;                }</b>
<i>1035</i>&nbsp;                // annotation method cannot declare type-parameters
<b class="nc"><i>1036</i>&nbsp;                if (tree.typarams.nonEmpty()) {</b>
<b class="nc"><i>1037</i>&nbsp;                    log.error(tree.typarams.head.pos(),</b>
<i>1038</i>&nbsp;                              Errors.IntfAnnotationMembersCantHaveTypeParams);
<i>1039</i>&nbsp;                }
<b class="nc"><i>1040</i>&nbsp;                // validate annotation method&#39;s return type (could be an annotation type)</b>
<i>1041</i>&nbsp;                chk.validateAnnotationType(tree.restype);
<b class="nc"><i>1042</i>&nbsp;                // ensure that annotation method does not clash with members of Object/Annotation</b>
<b class="nc"><i>1043</i>&nbsp;                chk.validateAnnotationMethod(tree.pos(), m);</b>
<i>1044</i>&nbsp;            }
<i>1045</i>&nbsp;
<i>1046</i>&nbsp;            for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
<b class="nc"><i>1047</i>&nbsp;                chk.checkType(l.head.pos(), l.head.type, syms.throwableType);</b>
<b class="nc"><i>1048</i>&nbsp;</b>
<b class="nc"><i>1049</i>&nbsp;            if (tree.body == null) {</b>
<i>1050</i>&nbsp;                // Empty bodies are only allowed for
<i>1051</i>&nbsp;                // abstract, native, or interface methods, or for methods
<b class="nc"><i>1052</i>&nbsp;                // in a retrofit signature class.</b>
<i>1053</i>&nbsp;                if (tree.defaultValue != null) {
<b class="nc"><i>1054</i>&nbsp;                    if ((owner.flags() &amp; ANNOTATION) == 0)</b>
<b class="nc"><i>1055</i>&nbsp;                        log.error(tree.pos(),</b>
<i>1056</i>&nbsp;                                  Errors.DefaultAllowedInIntfAnnotationMember);
<i>1057</i>&nbsp;                }
<b class="nc"><i>1058</i>&nbsp;                if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)</b>
<b class="nc"><i>1059</i>&nbsp;                    log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);</b>
<b class="nc"><i>1060</i>&nbsp;            } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {</b>
<i>1061</i>&nbsp;                if ((owner.flags() &amp; INTERFACE) != 0) {
<b class="nc"><i>1062</i>&nbsp;                    log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);</b>
<b class="nc"><i>1063</i>&nbsp;                } else {</b>
<b class="nc"><i>1064</i>&nbsp;                    log.error(tree.pos(), Errors.AbstractMethCantHaveBody);</b>
<i>1065</i>&nbsp;                }
<i>1066</i>&nbsp;            } else if ((tree.mods.flags &amp; NATIVE) != 0) {
<i>1067</i>&nbsp;                log.error(tree.pos(), Errors.NativeMethCantHaveBody);
<i>1068</i>&nbsp;            } else {
<b class="nc"><i>1069</i>&nbsp;                // Add an implicit super() call unless an explicit call to</b>
<b class="nc"><i>1070</i>&nbsp;                // super(...) or this(...) is given</b>
<i>1071</i>&nbsp;                // or we are compiling class java.lang.Object.
<i>1072</i>&nbsp;                if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
<i>1073</i>&nbsp;                    JCBlock body = tree.body;
<b class="nc"><i>1074</i>&nbsp;                    if (body.stats.isEmpty() ||</b>
<b class="nc"><i>1075</i>&nbsp;                            !TreeInfo.isSelfCall(body.stats.head)) {</b>
<i>1076</i>&nbsp;                        body.stats = body.stats.
<i>1077</i>&nbsp;                                prepend(typeEnter.SuperCall(make.at(body.pos),
<b class="nc"><i>1078</i>&nbsp;                                        List.nil(),</b>
<i>1079</i>&nbsp;                                        List.nil(),
<i>1080</i>&nbsp;                                        false));
<b class="nc"><i>1081</i>&nbsp;                    } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;</b>
<b class="nc"><i>1082</i>&nbsp;                            (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;</b>
<i>1083</i>&nbsp;                            TreeInfo.isSuperCall(body.stats.head)) {
<i>1084</i>&nbsp;                        // enum constructors are not allowed to call super
<i>1085</i>&nbsp;                        // directly, so make sure there aren&#39;t any super calls
<b class="nc"><i>1086</i>&nbsp;                        // in enum constructors, except in the compiler</b>
<i>1087</i>&nbsp;                        // generated one.
<i>1088</i>&nbsp;                        log.error(tree.body.stats.head.pos(),
<i>1089</i>&nbsp;                                  Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
<b class="nc"><i>1090</i>&nbsp;                    }</b>
<i>1091</i>&nbsp;                }
<i>1092</i>&nbsp;
<i>1093</i>&nbsp;                // Attribute all type annotations in the body
<b class="nc"><i>1094</i>&nbsp;                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);</b>
<b class="nc"><i>1095</i>&nbsp;                annotate.flush();</b>
<b class="nc"><i>1096</i>&nbsp;</b>
<i>1097</i>&nbsp;                // Attribute method body.
<b class="nc"><i>1098</i>&nbsp;                attribStat(tree.body, localEnv);</b>
<i>1099</i>&nbsp;            }
<b class="nc"><i>1100</i>&nbsp;</b>
<i>1101</i>&nbsp;            localEnv.info.scope.leave();
<i>1102</i>&nbsp;            result = tree.type = m.type;
<b class="nc"><i>1103</i>&nbsp;        } finally {</b>
<b class="nc"><i>1104</i>&nbsp;            chk.setLint(prevLint);</b>
<i>1105</i>&nbsp;            chk.setMethod(prevMethod);
<i>1106</i>&nbsp;        }
<i>1107</i>&nbsp;    }
<i>1108</i>&nbsp;
<b class="nc"><i>1109</i>&nbsp;    public void visitVarDef(JCVariableDecl tree) {</b>
<b class="nc"><i>1110</i>&nbsp;        // Local variables have not been entered yet, so we need to do it now:</b>
<b class="nc"><i>1111</i>&nbsp;        if (env.info.scope.owner.kind == MTH) {</b>
<b class="nc"><i>1112</i>&nbsp;            if (tree.sym != null) {</b>
<i>1113</i>&nbsp;                // parameters have already been entered
<b class="nc"><i>1114</i>&nbsp;                env.info.scope.enter(tree.sym);</b>
<i>1115</i>&nbsp;            } else {
<i>1116</i>&nbsp;                if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
<i>1117</i>&nbsp;                    if (tree.init == null) {
<b class="nc"><i>1118</i>&nbsp;                        //cannot use &#39;var&#39; without initializer</b>
<b class="nc"><i>1119</i>&nbsp;                        log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));</b>
<i>1120</i>&nbsp;                        tree.vartype = make.Erroneous();
<b class="nc"><i>1121</i>&nbsp;                    } else {</b>
<b class="nc"><i>1122</i>&nbsp;                        Fragment msg = canInferLocalVarType(tree);</b>
<i>1123</i>&nbsp;                        if (msg != null) {
<b class="nc"><i>1124</i>&nbsp;                            //cannot use &#39;var&#39; with initializer which require an explicit target</b>
<i>1125</i>&nbsp;                            //(e.g. lambda, method reference, array initializer).
<b class="nc"><i>1126</i>&nbsp;                            log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));</b>
<b class="nc"><i>1127</i>&nbsp;                            tree.vartype = make.Erroneous();</b>
<i>1128</i>&nbsp;                        }
<b class="nc"><i>1129</i>&nbsp;                    }</b>
<i>1130</i>&nbsp;                }
<i>1131</i>&nbsp;                try {
<i>1132</i>&nbsp;                    annotate.blockAnnotations();
<b class="nc"><i>1133</i>&nbsp;                    memberEnter.memberEnter(tree, env);</b>
<b class="nc"><i>1134</i>&nbsp;                } finally {</b>
<b class="nc"><i>1135</i>&nbsp;                    annotate.unblockAnnotations();</b>
<i>1136</i>&nbsp;                }
<i>1137</i>&nbsp;            }
<i>1138</i>&nbsp;        } else {
<b class="nc"><i>1139</i>&nbsp;            if (tree.init != null) {</b>
<b class="nc"><i>1140</i>&nbsp;                // Field initializer expression need to be entered.</b>
<b class="nc"><i>1141</i>&nbsp;                annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());</b>
<i>1142</i>&nbsp;                annotate.flush();
<i>1143</i>&nbsp;            }
<i>1144</i>&nbsp;        }
<b class="nc"><i>1145</i>&nbsp;</b>
<b class="nc"><i>1146</i>&nbsp;        VarSymbol v = tree.sym;</b>
<i>1147</i>&nbsp;        Lint lint = env.info.lint.augment(v);
<b class="nc"><i>1148</i>&nbsp;        Lint prevLint = chk.setLint(lint);</b>
<b class="nc"><i>1149</i>&nbsp;</b>
<b class="nc"><i>1150</i>&nbsp;        // Check that the variable&#39;s declared type is well-formed.</b>
<b class="nc"><i>1151</i>&nbsp;        boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;</b>
<b class="nc"><i>1152</i>&nbsp;                ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;</b>
<b class="nc"><i>1153</i>&nbsp;                (tree.sym.flags() &amp; PARAMETER) != 0;</b>
<i>1154</i>&nbsp;        chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
<i>1155</i>&nbsp;
<b class="nc"><i>1156</i>&nbsp;        try {</b>
<b class="nc"><i>1157</i>&nbsp;            v.getConstValue(); // ensure compile-time constant initializer is evaluated</b>
<i>1158</i>&nbsp;            deferredLintHandler.flush(tree.pos());
<i>1159</i>&nbsp;            chk.checkDeprecatedAnnotation(tree.pos(), v);
<i>1160</i>&nbsp;
<b class="nc"><i>1161</i>&nbsp;            if (tree.init != null) {</b>
<b class="nc"><i>1162</i>&nbsp;                if ((v.flags_field &amp; FINAL) == 0 ||</b>
<i>1163</i>&nbsp;                    !memberEnter.needsLazyConstValue(tree.init)) {
<i>1164</i>&nbsp;                    // Not a compile-time constant
<i>1165</i>&nbsp;                    // Attribute initializer in a new environment
<i>1166</i>&nbsp;                    // with the declared variable as owner.
<b class="nc"><i>1167</i>&nbsp;                    // Check that initializer conforms to variable&#39;s declared type.</b>
<b class="nc"><i>1168</i>&nbsp;                    Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);</b>
<b class="nc"><i>1169</i>&nbsp;                    initEnv.info.lint = lint;</b>
<b class="nc"><i>1170</i>&nbsp;                    // In order to catch self-references, we set the variable&#39;s</b>
<b class="nc"><i>1171</i>&nbsp;                    // declaration position to maximal possible value, effectively</b>
<i>1172</i>&nbsp;                    // marking the variable as undefined.
<b class="nc"><i>1173</i>&nbsp;                    initEnv.info.enclVar = v;</b>
<b class="nc"><i>1174</i>&nbsp;                    attribExpr(tree.init, initEnv, v.type);</b>
<b class="nc"><i>1175</i>&nbsp;                    if (tree.isImplicitlyTyped()) {</b>
<i>1176</i>&nbsp;                        //fixup local variable type
<i>1177</i>&nbsp;                        v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
<b class="nc"><i>1178</i>&nbsp;                    }</b>
<b class="nc"><i>1179</i>&nbsp;                }</b>
<i>1180</i>&nbsp;                if (tree.isImplicitlyTyped()) {
<b class="nc"><i>1181</i>&nbsp;                    setSyntheticVariableType(tree, v.type);</b>
<b class="nc"><i>1182</i>&nbsp;                }</b>
<i>1183</i>&nbsp;            }
<b class="nc"><i>1184</i>&nbsp;            result = tree.type = v.type;</b>
<i>1185</i>&nbsp;        }
<i>1186</i>&nbsp;        finally {
<b class="nc"><i>1187</i>&nbsp;            chk.setLint(prevLint);</b>
<b class="nc"><i>1188</i>&nbsp;        }</b>
<b class="nc"><i>1189</i>&nbsp;    }</b>
<b class="nc"><i>1190</i>&nbsp;</b>
<i>1191</i>&nbsp;    Fragment canInferLocalVarType(JCVariableDecl tree) {
<i>1192</i>&nbsp;        LocalInitScanner lis = new LocalInitScanner();
<b class="nc"><i>1193</i>&nbsp;        lis.scan(tree.init);</b>
<b class="nc"><i>1194</i>&nbsp;        return lis.badInferenceMsg;</b>
<i>1195</i>&nbsp;    }
<i>1196</i>&nbsp;
<i>1197</i>&nbsp;    static class LocalInitScanner extends TreeScanner {
<i>1198</i>&nbsp;        Fragment badInferenceMsg = null;
<b class="nc"><i>1199</i>&nbsp;        boolean needsTarget = true;</b>
<b class="nc"><i>1200</i>&nbsp;</b>
<b class="nc"><i>1201</i>&nbsp;        @Override</b>
<i>1202</i>&nbsp;        public void visitNewArray(JCNewArray tree) {
<b class="nc"><i>1203</i>&nbsp;            if (tree.elemtype == null &amp;&amp; needsTarget) {</b>
<i>1204</i>&nbsp;                badInferenceMsg = Fragments.LocalArrayMissingTarget;
<b class="nc"><i>1205</i>&nbsp;            }</b>
<i>1206</i>&nbsp;        }
<b class="nc"><i>1207</i>&nbsp;</b>
<i>1208</i>&nbsp;        @Override
<i>1209</i>&nbsp;        public void visitLambda(JCLambda tree) {
<b class="nc"><i>1210</i>&nbsp;            if (needsTarget) {</b>
<b class="nc"><i>1211</i>&nbsp;                badInferenceMsg = Fragments.LocalLambdaMissingTarget;</b>
<i>1212</i>&nbsp;            }
<i>1213</i>&nbsp;        }
<i>1214</i>&nbsp;
<b class="nc"><i>1215</i>&nbsp;        @Override</b>
<i>1216</i>&nbsp;        public void visitTypeCast(JCTypeCast tree) {
<b class="nc"><i>1217</i>&nbsp;            boolean prevNeedsTarget = needsTarget;</b>
<b class="nc"><i>1218</i>&nbsp;            try {</b>
<i>1219</i>&nbsp;                needsTarget = false;
<i>1220</i>&nbsp;                super.visitTypeCast(tree);
<i>1221</i>&nbsp;            } finally {
<b class="nc"><i>1222</i>&nbsp;                needsTarget = prevNeedsTarget;</b>
<i>1223</i>&nbsp;            }
<b class="nc"><i>1224</i>&nbsp;        }</b>
<b class="nc"><i>1225</i>&nbsp;</b>
<b class="nc"><i>1226</i>&nbsp;        @Override</b>
<b class="nc"><i>1227</i>&nbsp;        public void visitReference(JCMemberReference tree) {</b>
<b class="nc"><i>1228</i>&nbsp;            if (needsTarget) {</b>
<i>1229</i>&nbsp;                badInferenceMsg = Fragments.LocalMrefMissingTarget;
<b class="nc"><i>1230</i>&nbsp;            }</b>
<i>1231</i>&nbsp;        }
<i>1232</i>&nbsp;
<b class="nc"><i>1233</i>&nbsp;        @Override</b>
<b class="nc"><i>1234</i>&nbsp;        public void visitNewClass(JCNewClass tree) {</b>
<i>1235</i>&nbsp;            boolean prevNeedsTarget = needsTarget;
<i>1236</i>&nbsp;            try {
<i>1237</i>&nbsp;                needsTarget = false;
<b class="nc"><i>1238</i>&nbsp;                super.visitNewClass(tree);</b>
<b class="nc"><i>1239</i>&nbsp;            } finally {</b>
<b class="nc"><i>1240</i>&nbsp;                needsTarget = prevNeedsTarget;</b>
<b class="nc"><i>1241</i>&nbsp;            }</b>
<b class="nc"><i>1242</i>&nbsp;        }</b>
<b class="nc"><i>1243</i>&nbsp;</b>
<i>1244</i>&nbsp;        @Override
<b class="nc"><i>1245</i>&nbsp;        public void visitApply(JCMethodInvocation tree) {</b>
<b class="nc"><i>1246</i>&nbsp;            boolean prevNeedsTarget = needsTarget;</b>
<b class="nc"><i>1247</i>&nbsp;            try {</b>
<b class="nc"><i>1248</i>&nbsp;                needsTarget = false;</b>
<b class="nc"><i>1249</i>&nbsp;                super.visitApply(tree);</b>
<b class="nc"><i>1250</i>&nbsp;            } finally {</b>
<b class="nc"><i>1251</i>&nbsp;                needsTarget = prevNeedsTarget;</b>
<i>1252</i>&nbsp;            }
<b class="nc"><i>1253</i>&nbsp;        }</b>
<b class="nc"><i>1254</i>&nbsp;    }</b>
<b class="nc"><i>1255</i>&nbsp;</b>
<b class="nc"><i>1256</i>&nbsp;    public void visitSkip(JCSkip tree) {</b>
<b class="nc"><i>1257</i>&nbsp;        result = null;</b>
<i>1258</i>&nbsp;    }
<b class="nc"><i>1259</i>&nbsp;</b>
<b class="nc"><i>1260</i>&nbsp;    public void visitBlock(JCBlock tree) {</b>
<i>1261</i>&nbsp;        if (env.info.scope.owner.kind == TYP) {
<b class="nc"><i>1262</i>&nbsp;            // Block is a static or instance initializer;</b>
<i>1263</i>&nbsp;            // let the owner of the environment be a freshly
<i>1264</i>&nbsp;            // created BLOCK-method.
<b class="nc"><i>1265</i>&nbsp;            Symbol fakeOwner =</b>
<b class="nc"><i>1266</i>&nbsp;                new MethodSymbol(tree.flags | BLOCK |</b>
<b class="nc"><i>1267</i>&nbsp;                    env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,</b>
<i>1268</i>&nbsp;                    env.info.scope.owner);
<b class="nc"><i>1269</i>&nbsp;            final Env&lt;AttrContext&gt; localEnv =</b>
<i>1270</i>&nbsp;                env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
<b class="nc"><i>1271</i>&nbsp;</b>
<i>1272</i>&nbsp;            if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
<b class="nc"><i>1273</i>&nbsp;            // Attribute all type annotations in the block</b>
<b class="nc"><i>1274</i>&nbsp;            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);</b>
<b class="nc"><i>1275</i>&nbsp;            annotate.flush();</b>
<i>1276</i>&nbsp;            attribStats(tree.stats, localEnv);
<i>1277</i>&nbsp;
<b class="nc"><i>1278</i>&nbsp;            {</b>
<i>1279</i>&nbsp;                // Store init and clinit type annotations with the ClassSymbol
<i>1280</i>&nbsp;                // to allow output in Gen.normalizeDefs.
<b class="nc"><i>1281</i>&nbsp;                ClassSymbol cs = (ClassSymbol)env.info.scope.owner;</b>
<b class="nc"><i>1282</i>&nbsp;                List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();</b>
<i>1283</i>&nbsp;                if ((tree.flags &amp; STATIC) != 0) {
<i>1284</i>&nbsp;                    cs.appendClassInitTypeAttributes(tas);
<i>1285</i>&nbsp;                } else {
<i>1286</i>&nbsp;                    cs.appendInitTypeAttributes(tas);
<b class="nc"><i>1287</i>&nbsp;                }</b>
<b class="nc"><i>1288</i>&nbsp;            }</b>
<b class="nc"><i>1289</i>&nbsp;        } else {</b>
<b class="nc"><i>1290</i>&nbsp;            // Create a new local environment with a local scope.</b>
<i>1291</i>&nbsp;            Env&lt;AttrContext&gt; localEnv =
<i>1292</i>&nbsp;                env.dup(tree, env.info.dup(env.info.scope.dup()));
<i>1293</i>&nbsp;            try {
<i>1294</i>&nbsp;                attribStats(tree.stats, localEnv);
<i>1295</i>&nbsp;            } finally {
<b class="nc"><i>1296</i>&nbsp;                localEnv.info.scope.leave();</b>
<b class="nc"><i>1297</i>&nbsp;            }</b>
<b class="nc"><i>1298</i>&nbsp;        }</b>
<i>1299</i>&nbsp;        result = null;
<b class="nc"><i>1300</i>&nbsp;    }</b>
<b class="nc"><i>1301</i>&nbsp;</b>
<b class="nc"><i>1302</i>&nbsp;    public void visitDoLoop(JCDoWhileLoop tree) {</b>
<b class="nc"><i>1303</i>&nbsp;        attribStat(tree.body, env.dup(tree));</b>
<b class="nc"><i>1304</i>&nbsp;        attribExpr(tree.cond, env, syms.booleanType);</b>
<b class="nc"><i>1305</i>&nbsp;        result = null;</b>
<b class="nc"><i>1306</i>&nbsp;    }</b>
<b class="nc"><i>1307</i>&nbsp;</b>
<b class="nc"><i>1308</i>&nbsp;    public void visitWhileLoop(JCWhileLoop tree) {</b>
<i>1309</i>&nbsp;        attribExpr(tree.cond, env, syms.booleanType);
<i>1310</i>&nbsp;        attribStat(tree.body, env.dup(tree));
<i>1311</i>&nbsp;        result = null;
<b class="nc"><i>1312</i>&nbsp;    }</b>
<i>1313</i>&nbsp;
<i>1314</i>&nbsp;    public void visitForLoop(JCForLoop tree) {
<i>1315</i>&nbsp;        Env&lt;AttrContext&gt; loopEnv =
<b class="nc"><i>1316</i>&nbsp;            env.dup(env.tree, env.info.dup(env.info.scope.dup()));</b>
<b class="nc"><i>1317</i>&nbsp;        try {</b>
<b class="nc"><i>1318</i>&nbsp;            attribStats(tree.init, loopEnv);</b>
<i>1319</i>&nbsp;            if (tree.cond != null) attribExpr(tree.cond, loopEnv, syms.booleanType);
<i>1320</i>&nbsp;            loopEnv.tree = tree; // before, we were not in loop!
<i>1321</i>&nbsp;            attribStats(tree.step, loopEnv);
<i>1322</i>&nbsp;            attribStat(tree.body, loopEnv);
<b class="nc"><i>1323</i>&nbsp;            result = null;</b>
<i>1324</i>&nbsp;        }
<b class="nc"><i>1325</i>&nbsp;        finally {</b>
<i>1326</i>&nbsp;            loopEnv.info.scope.leave();
<b class="nc"><i>1327</i>&nbsp;        }</b>
<b class="nc"><i>1328</i>&nbsp;    }</b>
<i>1329</i>&nbsp;
<i>1330</i>&nbsp;    public void visitForeachLoop(JCEnhancedForLoop tree) {
<i>1331</i>&nbsp;        Env&lt;AttrContext&gt; loopEnv =
<b class="nc"><i>1332</i>&nbsp;            env.dup(env.tree, env.info.dup(env.info.scope.dup()));</b>
<b class="nc"><i>1333</i>&nbsp;        try {</b>
<i>1334</i>&nbsp;            //the Formal Parameter of a for-each loop is not in the scope when
<i>1335</i>&nbsp;            //attributing the for-each expression; we mimick this by attributing
<b class="nc"><i>1336</i>&nbsp;            //the for-each expression first (against original scope).</b>
<i>1337</i>&nbsp;            Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
<i>1338</i>&nbsp;            chk.checkNonVoid(tree.pos(), exprType);
<b class="nc"><i>1339</i>&nbsp;            Type elemtype = types.elemtype(exprType); // perhaps expr is an array?</b>
<b class="nc"><i>1340</i>&nbsp;            if (elemtype == null) {</b>
<b class="nc"><i>1341</i>&nbsp;                // or perhaps expr implements Iterable&lt;T&gt;?</b>
<b class="nc"><i>1342</i>&nbsp;                Type base = types.asSuper(exprType, syms.iterableType.tsym);</b>
<i>1343</i>&nbsp;                if (base == null) {
<i>1344</i>&nbsp;                    log.error(tree.expr.pos(),
<b class="nc"><i>1345</i>&nbsp;                              Errors.ForeachNotApplicableToType(exprType,</b>
<i>1346</i>&nbsp;                                                                Fragments.TypeReqArrayOrIterable));
<b class="nc"><i>1347</i>&nbsp;                    elemtype = types.createErrorType(exprType);</b>
<b class="nc"><i>1348</i>&nbsp;                } else {</b>
<b class="nc"><i>1349</i>&nbsp;                    List&lt;Type&gt; iterableParams = base.allparams();</b>
<b class="nc"><i>1350</i>&nbsp;                    elemtype = iterableParams.isEmpty()</b>
<i>1351</i>&nbsp;                        ? syms.objectType
<b class="nc"><i>1352</i>&nbsp;                        : types.wildUpperBound(iterableParams.head);</b>
<i>1353</i>&nbsp;                }
<b class="nc"><i>1354</i>&nbsp;            }</b>
<i>1355</i>&nbsp;            if (tree.var.isImplicitlyTyped()) {
<b class="nc"><i>1356</i>&nbsp;                Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);</b>
<b class="nc"><i>1357</i>&nbsp;                setSyntheticVariableType(tree.var, inferredType);</b>
<i>1358</i>&nbsp;            }
<i>1359</i>&nbsp;            attribStat(tree.var, loopEnv);
<i>1360</i>&nbsp;            chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
<b class="nc"><i>1361</i>&nbsp;            loopEnv.tree = tree; // before, we were not in loop!</b>
<b class="nc"><i>1362</i>&nbsp;            attribStat(tree.body, loopEnv);</b>
<b class="nc"><i>1363</i>&nbsp;            result = null;</b>
<b class="nc"><i>1364</i>&nbsp;        }</b>
<i>1365</i>&nbsp;        finally {
<b class="nc"><i>1366</i>&nbsp;            loopEnv.info.scope.leave();</b>
<b class="nc"><i>1367</i>&nbsp;        }</b>
<i>1368</i>&nbsp;    }
<b class="nc"><i>1369</i>&nbsp;</b>
<i>1370</i>&nbsp;    public void visitLabelled(JCLabeledStatement tree) {
<b class="nc"><i>1371</i>&nbsp;        // Check that label is not used in an enclosing statement</b>
<b class="nc"><i>1372</i>&nbsp;        Env&lt;AttrContext&gt; env1 = env;</b>
<i>1373</i>&nbsp;        while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
<b class="nc"><i>1374</i>&nbsp;            if (env1.tree.hasTag(LABELLED) &amp;&amp;</b>
<b class="nc"><i>1375</i>&nbsp;                ((JCLabeledStatement) env1.tree).label == tree.label) {</b>
<i>1376</i>&nbsp;                log.error(tree.pos(),
<b class="nc"><i>1377</i>&nbsp;                          Errors.LabelAlreadyInUse(tree.label));</b>
<i>1378</i>&nbsp;                break;
<b class="nc"><i>1379</i>&nbsp;            }</b>
<b class="nc"><i>1380</i>&nbsp;            env1 = env1.next;</b>
<i>1381</i>&nbsp;        }
<i>1382</i>&nbsp;
<i>1383</i>&nbsp;        attribStat(tree.body, env.dup(tree));
<b class="nc"><i>1384</i>&nbsp;        result = null;</b>
<b class="nc"><i>1385</i>&nbsp;    }</b>
<i>1386</i>&nbsp;
<i>1387</i>&nbsp;    public void visitSwitch(JCSwitch tree) {
<b class="nc"><i>1388</i>&nbsp;        Type seltype = attribExpr(tree.selector, env);</b>
<b class="nc"><i>1389</i>&nbsp;</b>
<i>1390</i>&nbsp;        Env&lt;AttrContext&gt; switchEnv =
<i>1391</i>&nbsp;            env.dup(tree, env.info.dup(env.info.scope.dup()));
<i>1392</i>&nbsp;
<b class="nc"><i>1393</i>&nbsp;        try {</b>
<b class="nc"><i>1394</i>&nbsp;</b>
<b class="nc"><i>1395</i>&nbsp;            boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;</b>
<b class="nc"><i>1396</i>&nbsp;            boolean stringSwitch = types.isSameType(seltype, syms.stringType);</b>
<b class="nc"><i>1397</i>&nbsp;            if (stringSwitch &amp;&amp; !allowStringsInSwitch) {</b>
<i>1398</i>&nbsp;                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.selector.pos(), Feature.STRINGS_IN_SWITCH.error(sourceName));
<b class="nc"><i>1399</i>&nbsp;            }</b>
<i>1400</i>&nbsp;            if (!enumSwitch &amp;&amp; !stringSwitch)
<i>1401</i>&nbsp;                seltype = chk.checkType(tree.selector.pos(), seltype, syms.intType);
<i>1402</i>&nbsp;
<b class="nc"><i>1403</i>&nbsp;            // Attribute all cases and</b>
<b class="nc"><i>1404</i>&nbsp;            // check that there are no duplicate case labels or default clauses.</b>
<i>1405</i>&nbsp;            Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
<i>1406</i>&nbsp;            boolean hasDefault = false;      // Is there a default label?
<b class="nc"><i>1407</i>&nbsp;            for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>1408</i>&nbsp;                JCCase c = l.head;</b>
<b class="nc"><i>1409</i>&nbsp;                if (c.pat != null) {</b>
<b class="nc"><i>1410</i>&nbsp;                    if (enumSwitch) {</b>
<b class="nc"><i>1411</i>&nbsp;                        Symbol sym = enumConstant(c.pat, seltype);</b>
<b class="nc"><i>1412</i>&nbsp;                        if (sym == null) {</b>
<b class="nc"><i>1413</i>&nbsp;                            log.error(c.pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);</b>
<i>1414</i>&nbsp;                        } else if (!labels.add(sym)) {
<i>1415</i>&nbsp;                            log.error(c.pos(), Errors.DuplicateCaseLabel);
<i>1416</i>&nbsp;                        }
<i>1417</i>&nbsp;                    } else {
<i>1418</i>&nbsp;                        Type pattype = attribExpr(c.pat, switchEnv, seltype);
<b class="nc"><i>1419</i>&nbsp;                        if (!pattype.hasTag(ERROR)) {</b>
<i>1420</i>&nbsp;                            if (pattype.constValue() == null) {
<b class="nc"><i>1421</i>&nbsp;                                log.error(c.pat.pos(),</b>
<b class="nc"><i>1422</i>&nbsp;                                          (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));</b>
<b class="nc"><i>1423</i>&nbsp;                            } else if (!labels.add(pattype.constValue())) {</b>
<i>1424</i>&nbsp;                                log.error(c.pos(), Errors.DuplicateCaseLabel);
<i>1425</i>&nbsp;                            }
<b class="nc"><i>1426</i>&nbsp;                        }</b>
<i>1427</i>&nbsp;                    }
<b class="nc"><i>1428</i>&nbsp;                } else if (hasDefault) {</b>
<b class="nc"><i>1429</i>&nbsp;                    log.error(c.pos(), Errors.DuplicateDefaultLabel);</b>
<i>1430</i>&nbsp;                } else {
<i>1431</i>&nbsp;                    hasDefault = true;
<i>1432</i>&nbsp;                }
<b class="nc"><i>1433</i>&nbsp;                Env&lt;AttrContext&gt; caseEnv =</b>
<i>1434</i>&nbsp;                    switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
<b class="nc"><i>1435</i>&nbsp;                try {</b>
<i>1436</i>&nbsp;                    attribStats(c.stats, caseEnv);
<i>1437</i>&nbsp;                } finally {
<i>1438</i>&nbsp;                    caseEnv.info.scope.leave();
<i>1439</i>&nbsp;                    addVars(c.stats, switchEnv.info.scope);
<i>1440</i>&nbsp;                }
<b class="nc"><i>1441</i>&nbsp;            }</b>
<i>1442</i>&nbsp;
<i>1443</i>&nbsp;            result = null;
<i>1444</i>&nbsp;        }
<b class="nc"><i>1445</i>&nbsp;        finally {</b>
<b class="nc"><i>1446</i>&nbsp;            switchEnv.info.scope.leave();</b>
<i>1447</i>&nbsp;        }
<b class="nc"><i>1448</i>&nbsp;    }</b>
<b class="nc"><i>1449</i>&nbsp;    // where</b>
<b class="nc"><i>1450</i>&nbsp;        /** Add any variables defined in stats to the switch scope. */</b>
<b class="nc"><i>1451</i>&nbsp;        private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {</b>
<b class="nc"><i>1452</i>&nbsp;            for (;stats.nonEmpty(); stats = stats.tail) {</b>
<i>1453</i>&nbsp;                JCTree stat = stats.head;
<b class="nc"><i>1454</i>&nbsp;                if (stat.hasTag(VARDEF))</b>
<i>1455</i>&nbsp;                    switchScope.enter(((JCVariableDecl) stat).sym);
<b class="nc"><i>1456</i>&nbsp;            }</b>
<i>1457</i>&nbsp;        }
<i>1458</i>&nbsp;    // where
<i>1459</i>&nbsp;    /** Return the selected enumeration constant symbol, or null. */
<b class="nc"><i>1460</i>&nbsp;    private Symbol enumConstant(JCTree tree, Type enumType) {</b>
<b class="nc"><i>1461</i>&nbsp;        if (tree.hasTag(IDENT)) {</b>
<i>1462</i>&nbsp;            JCIdent ident = (JCIdent)tree;
<i>1463</i>&nbsp;            Name name = ident.name;
<b class="nc"><i>1464</i>&nbsp;            for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {</b>
<b class="nc"><i>1465</i>&nbsp;                if (sym.kind == VAR) {</b>
<i>1466</i>&nbsp;                    Symbol s = ident.sym = sym;
<b class="nc"><i>1467</i>&nbsp;                    ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated</b>
<b class="nc"><i>1468</i>&nbsp;                    ident.type = s.type;</b>
<b class="nc"><i>1469</i>&nbsp;                    return ((s.flags_field &amp; Flags.ENUM) == 0)</b>
<i>1470</i>&nbsp;                        ? null : s;
<b class="nc"><i>1471</i>&nbsp;                }</b>
<b class="nc"><i>1472</i>&nbsp;            }</b>
<b class="nc"><i>1473</i>&nbsp;        }</b>
<b class="nc"><i>1474</i>&nbsp;        return null;</b>
<i>1475</i>&nbsp;    }
<b class="nc"><i>1476</i>&nbsp;</b>
<b class="nc"><i>1477</i>&nbsp;    public void visitSynchronized(JCSynchronized tree) {</b>
<b class="nc"><i>1478</i>&nbsp;        chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));</b>
<b class="nc"><i>1479</i>&nbsp;        attribStat(tree.body, env);</b>
<b class="nc"><i>1480</i>&nbsp;        result = null;</b>
<i>1481</i>&nbsp;    }
<b class="nc"><i>1482</i>&nbsp;</b>
<b class="nc"><i>1483</i>&nbsp;    public void visitTry(JCTry tree) {</b>
<b class="nc"><i>1484</i>&nbsp;        // Create a new local environment with a local</b>
<i>1485</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
<i>1486</i>&nbsp;        try {
<i>1487</i>&nbsp;            boolean isTryWithResource = tree.resources.nonEmpty();
<b class="nc"><i>1488</i>&nbsp;            // Create a nested environment for attributing the try block if needed</b>
<i>1489</i>&nbsp;            Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
<i>1490</i>&nbsp;                env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
<b class="nc"><i>1491</i>&nbsp;                localEnv;</b>
<i>1492</i>&nbsp;            try {
<i>1493</i>&nbsp;                // Attribute resource declarations
<i>1494</i>&nbsp;                for (JCTree resource : tree.resources) {
<i>1495</i>&nbsp;                    CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
<i>1496</i>&nbsp;                        @Override
<i>1497</i>&nbsp;                        public void report(DiagnosticPosition pos, JCDiagnostic details) {
<i>1498</i>&nbsp;                            chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
<i>1499</i>&nbsp;                        }
<i>1500</i>&nbsp;                    };
<i>1501</i>&nbsp;                    ResultInfo twrResult =
<i>1502</i>&nbsp;                        new ResultInfo(KindSelector.VAR,
<i>1503</i>&nbsp;                                       syms.autoCloseableType,
<i>1504</i>&nbsp;                                       twrContext);
<i>1505</i>&nbsp;                    if (resource.hasTag(VARDEF)) {
<i>1506</i>&nbsp;                        attribStat(resource, tryEnv);
<i>1507</i>&nbsp;                        twrResult.check(resource, resource.type);
<b class="nc"><i>1508</i>&nbsp;</b>
<b class="nc"><i>1509</i>&nbsp;                        //check that resource type cannot throw InterruptedException</b>
<i>1510</i>&nbsp;                        checkAutoCloseable(resource.pos(), localEnv, resource.type);
<b class="nc"><i>1511</i>&nbsp;</b>
<b class="nc"><i>1512</i>&nbsp;                        VarSymbol var = ((JCVariableDecl) resource).sym;</b>
<b class="nc"><i>1513</i>&nbsp;                        var.setData(ElementKind.RESOURCE_VARIABLE);</b>
<b class="nc"><i>1514</i>&nbsp;                    } else {</b>
<i>1515</i>&nbsp;                        attribTree(resource, tryEnv, twrResult);
<i>1516</i>&nbsp;                    }
<i>1517</i>&nbsp;                }
<i>1518</i>&nbsp;                // Attribute body
<i>1519</i>&nbsp;                attribStat(tree.body, tryEnv);
<b class="nc"><i>1520</i>&nbsp;            } finally {</b>
<i>1521</i>&nbsp;                if (isTryWithResource)
<i>1522</i>&nbsp;                    tryEnv.info.scope.leave();
<i>1523</i>&nbsp;            }
<b class="nc"><i>1524</i>&nbsp;</b>
<b class="nc"><i>1525</i>&nbsp;            // Attribute catch clauses</b>
<b class="nc"><i>1526</i>&nbsp;            for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>1527</i>&nbsp;                JCCatch c = l.head;</b>
<i>1528</i>&nbsp;                Env&lt;AttrContext&gt; catchEnv =
<b class="nc"><i>1529</i>&nbsp;                    localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));</b>
<b class="nc"><i>1530</i>&nbsp;                try {</b>
<b class="nc"><i>1531</i>&nbsp;                    Type ctype = attribStat(c.param, catchEnv);</b>
<b class="nc"><i>1532</i>&nbsp;                    if (TreeInfo.isMultiCatch(c)) {</b>
<i>1533</i>&nbsp;                        //multi-catch parameter is implicitly marked as final
<i>1534</i>&nbsp;                        c.param.sym.flags_field |= FINAL | UNION;
<b class="nc"><i>1535</i>&nbsp;                    }</b>
<b class="nc"><i>1536</i>&nbsp;                    if (c.param.sym.kind == VAR) {</b>
<b class="nc"><i>1537</i>&nbsp;                        c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);</b>
<b class="nc"><i>1538</i>&nbsp;                    }</b>
<b class="nc"><i>1539</i>&nbsp;                    chk.checkType(c.param.vartype.pos(),</b>
<i>1540</i>&nbsp;                                  chk.checkClassType(c.param.vartype.pos(), ctype),
<i>1541</i>&nbsp;                                  syms.throwableType);
<i>1542</i>&nbsp;                    attribStat(c.body, catchEnv);
<i>1543</i>&nbsp;                } finally {
<i>1544</i>&nbsp;                    catchEnv.info.scope.leave();
<b class="nc"><i>1545</i>&nbsp;                }</b>
<b class="nc"><i>1546</i>&nbsp;            }</b>
<b class="nc"><i>1547</i>&nbsp;</b>
<b class="nc"><i>1548</i>&nbsp;            // Attribute finalizer</b>
<b class="nc"><i>1549</i>&nbsp;            if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);</b>
<i>1550</i>&nbsp;            result = null;
<i>1551</i>&nbsp;        }
<b class="nc"><i>1552</i>&nbsp;        finally {</b>
<b class="nc"><i>1553</i>&nbsp;            localEnv.info.scope.leave();</b>
<b class="nc"><i>1554</i>&nbsp;        }</b>
<b class="nc"><i>1555</i>&nbsp;    }</b>
<i>1556</i>&nbsp;
<b class="nc"><i>1557</i>&nbsp;    void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {</b>
<b class="nc"><i>1558</i>&nbsp;        if (!resource.isErroneous() &amp;&amp;</b>
<i>1559</i>&nbsp;            types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;
<b class="nc"><i>1560</i>&nbsp;            !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself</b>
<i>1561</i>&nbsp;            Symbol close = syms.noSymbol;
<i>1562</i>&nbsp;            Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
<i>1563</i>&nbsp;            try {
<i>1564</i>&nbsp;                close = rs.resolveQualifiedMethod(pos,
<i>1565</i>&nbsp;                        env,
<b class="nc"><i>1566</i>&nbsp;                        types.skipTypeVars(resource, false),</b>
<i>1567</i>&nbsp;                        names.close,
<i>1568</i>&nbsp;                        List.nil(),
<b class="nc"><i>1569</i>&nbsp;                        List.nil());</b>
<i>1570</i>&nbsp;            }
<i>1571</i>&nbsp;            finally {
<i>1572</i>&nbsp;                log.popDiagnosticHandler(discardHandler);
<i>1573</i>&nbsp;            }
<i>1574</i>&nbsp;            if (close.kind == MTH &amp;&amp;
<i>1575</i>&nbsp;                    close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
<i>1576</i>&nbsp;                    chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
<i>1577</i>&nbsp;                    env.info.lint.isEnabled(LintCategory.TRY)) {
<i>1578</i>&nbsp;                log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
<i>1579</i>&nbsp;            }
<i>1580</i>&nbsp;        }
<b class="nc"><i>1581</i>&nbsp;    }</b>
<b class="nc"><i>1582</i>&nbsp;</b>
<b class="nc"><i>1583</i>&nbsp;    public void visitConditional(JCConditional tree) {</b>
<b class="nc"><i>1584</i>&nbsp;        Type condtype = attribExpr(tree.cond, env, syms.booleanType);</b>
<b class="nc"><i>1585</i>&nbsp;</b>
<b class="nc"><i>1586</i>&nbsp;        tree.polyKind = (!allowPoly ||</b>
<i>1587</i>&nbsp;                pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
<i>1588</i>&nbsp;                isBooleanOrNumeric(env, tree)) ?
<i>1589</i>&nbsp;                PolyKind.STANDALONE : PolyKind.POLY;
<i>1590</i>&nbsp;
<i>1591</i>&nbsp;        if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
<b class="nc"><i>1592</i>&nbsp;            //this means we are returning a poly conditional from void-compatible lambda expression</b>
<b class="nc"><i>1593</i>&nbsp;            resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));</b>
<b class="nc"><i>1594</i>&nbsp;            result = tree.type = types.createErrorType(resultInfo.pt);</b>
<i>1595</i>&nbsp;            return;
<i>1596</i>&nbsp;        }
<i>1597</i>&nbsp;
<b class="nc"><i>1598</i>&nbsp;        ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?</b>
<b class="nc"><i>1599</i>&nbsp;                unknownExprInfo :</b>
<i>1600</i>&nbsp;                resultInfo.dup(conditionalContext(resultInfo.checkContext));
<i>1601</i>&nbsp;
<i>1602</i>&nbsp;        Type truetype = attribTree(tree.truepart, env, condInfo);
<b class="nc"><i>1603</i>&nbsp;        Type falsetype = attribTree(tree.falsepart, env, condInfo);</b>
<b class="nc"><i>1604</i>&nbsp;</b>
<i>1605</i>&nbsp;        Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(tree, truetype, falsetype) : pt();
<i>1606</i>&nbsp;        if (condtype.constValue() != null &amp;&amp;
<i>1607</i>&nbsp;                truetype.constValue() != null &amp;&amp;
<i>1608</i>&nbsp;                falsetype.constValue() != null &amp;&amp;
<i>1609</i>&nbsp;                !owntype.hasTag(NONE)) {
<i>1610</i>&nbsp;            //constant folding
<i>1611</i>&nbsp;            owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
<i>1612</i>&nbsp;        }
<i>1613</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);
<i>1614</i>&nbsp;    }
<i>1615</i>&nbsp;    //where
<i>1616</i>&nbsp;        private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
<i>1617</i>&nbsp;            switch (tree.getTag()) {
<i>1618</i>&nbsp;                case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
<i>1619</i>&nbsp;                              ((JCLiteral)tree).typetag == BOOLEAN ||
<i>1620</i>&nbsp;                              ((JCLiteral)tree).typetag == BOT;
<i>1621</i>&nbsp;                case LAMBDA: case REFERENCE: return false;
<i>1622</i>&nbsp;                case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
<i>1623</i>&nbsp;                case CONDEXPR:
<i>1624</i>&nbsp;                    JCConditional condTree = (JCConditional)tree;
<b class="nc"><i>1625</i>&nbsp;                    return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;</b>
<i>1626</i>&nbsp;                            isBooleanOrNumeric(env, condTree.falsepart);
<b class="nc"><i>1627</i>&nbsp;                case APPLY:</b>
<b class="nc"><i>1628</i>&nbsp;                    JCMethodInvocation speculativeMethodTree =</b>
<i>1629</i>&nbsp;                            (JCMethodInvocation)deferredAttr.attribSpeculative(
<b class="nc"><i>1630</i>&nbsp;                                    tree, env, unknownExprInfo,</b>
<b class="nc"><i>1631</i>&nbsp;                                    argumentAttr.withLocalCacheContext());</b>
<i>1632</i>&nbsp;                    Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
<b class="nc"><i>1633</i>&nbsp;                    Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?</b>
<b class="nc"><i>1634</i>&nbsp;                            env.enclClass.type :</b>
<b class="nc"><i>1635</i>&nbsp;                            ((JCFieldAccess)speculativeMethodTree.meth).selected.type;</b>
<b class="nc"><i>1636</i>&nbsp;                    Type owntype = types.memberType(receiverType, msym).getReturnType();</b>
<b class="nc"><i>1637</i>&nbsp;                    return primitiveOrBoxed(owntype);</b>
<b class="nc"><i>1638</i>&nbsp;                case NEWCLASS:</b>
<i>1639</i>&nbsp;                    JCExpression className =
<i>1640</i>&nbsp;                            removeClassParams.translate(((JCNewClass)tree).clazz);
<b class="nc"><i>1641</i>&nbsp;                    JCExpression speculativeNewClassTree =</b>
<i>1642</i>&nbsp;                            (JCExpression)deferredAttr.attribSpeculative(
<b class="nc"><i>1643</i>&nbsp;                                    className, env, unknownTypeInfo,</b>
<i>1644</i>&nbsp;                                    argumentAttr.withLocalCacheContext());
<i>1645</i>&nbsp;                    return primitiveOrBoxed(speculativeNewClassTree.type);
<i>1646</i>&nbsp;                default:
<i>1647</i>&nbsp;                    Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
<i>1648</i>&nbsp;                            argumentAttr.withLocalCacheContext()).type;
<i>1649</i>&nbsp;                    return primitiveOrBoxed(speculativeType);
<i>1650</i>&nbsp;            }
<b class="nc"><i>1651</i>&nbsp;        }</b>
<i>1652</i>&nbsp;        //where
<i>1653</i>&nbsp;            boolean primitiveOrBoxed(Type t) {
<b class="nc"><i>1654</i>&nbsp;                return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());</b>
<i>1655</i>&nbsp;            }
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;            TreeTranslator removeClassParams = new TreeTranslator() {
<i>1658</i>&nbsp;                @Override
<b class="nc"><i>1659</i>&nbsp;                public void visitTypeApply(JCTypeApply tree) {</b>
<i>1660</i>&nbsp;                    result = translate(tree.clazz);
<i>1661</i>&nbsp;                }
<b class="nc"><i>1662</i>&nbsp;            };</b>
<i>1663</i>&nbsp;
<b class="nc"><i>1664</i>&nbsp;        CheckContext conditionalContext(CheckContext checkContext) {</b>
<b class="nc"><i>1665</i>&nbsp;            return new Check.NestedCheckContext(checkContext) {</b>
<b class="nc"><i>1666</i>&nbsp;                //this will use enclosing check context to check compatibility of</b>
<b class="nc"><i>1667</i>&nbsp;                //subexpression against target type; if we are in a method check context,</b>
<i>1668</i>&nbsp;                //depending on whether boxing is allowed, we could have incompatibilities
<b class="nc"><i>1669</i>&nbsp;                @Override</b>
<b class="nc"><i>1670</i>&nbsp;                public void report(DiagnosticPosition pos, JCDiagnostic details) {</b>
<i>1671</i>&nbsp;                    enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
<i>1672</i>&nbsp;                }
<i>1673</i>&nbsp;            };
<i>1674</i>&nbsp;        }
<i>1675</i>&nbsp;
<b class="nc"><i>1676</i>&nbsp;        /** Compute the type of a conditional expression, after</b>
<b class="nc"><i>1677</i>&nbsp;         *  checking that it exists.  See JLS 15.25. Does not take into</b>
<i>1678</i>&nbsp;         *  account the special case where condition and both arms
<i>1679</i>&nbsp;         *  are constants.
<i>1680</i>&nbsp;         *
<b class="nc"><i>1681</i>&nbsp;         *  @param pos      The source position to be used for error</b>
<b class="nc"><i>1682</i>&nbsp;         *                  diagnostics.</b>
<b class="nc"><i>1683</i>&nbsp;         *  @param thentype The type of the expression&#39;s then-part.</b>
<b class="nc"><i>1684</i>&nbsp;         *  @param elsetype The type of the expression&#39;s else-part.</b>
<i>1685</i>&nbsp;         */
<b class="nc"><i>1686</i>&nbsp;        Type condType(DiagnosticPosition pos,</b>
<b class="nc"><i>1687</i>&nbsp;                               Type thentype, Type elsetype) {</b>
<b class="nc"><i>1688</i>&nbsp;            // If same type, that is the result</b>
<b class="nc"><i>1689</i>&nbsp;            if (types.isSameType(thentype, elsetype))</b>
<b class="nc"><i>1690</i>&nbsp;                return thentype.baseType();</b>
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;            Type thenUnboxed = (thentype.isPrimitive())
<b class="nc"><i>1693</i>&nbsp;                ? thentype : types.unboxedType(thentype);</b>
<i>1694</i>&nbsp;            Type elseUnboxed = (elsetype.isPrimitive())
<i>1695</i>&nbsp;                ? elsetype : types.unboxedType(elsetype);
<i>1696</i>&nbsp;
<b class="nc"><i>1697</i>&nbsp;            // Otherwise, if both arms can be converted to a numeric</b>
<b class="nc"><i>1698</i>&nbsp;            // type, return the least numeric type that fits both arms</b>
<b class="nc"><i>1699</i>&nbsp;            // (i.e. return larger of the two, or return int if one</b>
<i>1700</i>&nbsp;            // arm is short, the other is char).
<b class="nc"><i>1701</i>&nbsp;            if (thenUnboxed.isPrimitive() &amp;&amp; elseUnboxed.isPrimitive()) {</b>
<i>1702</i>&nbsp;                // If one arm has an integer subrange type (i.e., byte,
<i>1703</i>&nbsp;                // short, or char), and the other is an integer constant
<i>1704</i>&nbsp;                // that fits into the subrange, return the subrange type.
<b class="nc"><i>1705</i>&nbsp;                if (thenUnboxed.getTag().isStrictSubRangeOf(INT) &amp;&amp;</b>
<b class="nc"><i>1706</i>&nbsp;                    elseUnboxed.hasTag(INT) &amp;&amp;</b>
<b class="nc"><i>1707</i>&nbsp;                    types.isAssignable(elseUnboxed, thenUnboxed)) {</b>
<i>1708</i>&nbsp;                    return thenUnboxed.baseType();
<b class="nc"><i>1709</i>&nbsp;                }</b>
<i>1710</i>&nbsp;                if (elseUnboxed.getTag().isStrictSubRangeOf(INT) &amp;&amp;
<i>1711</i>&nbsp;                    thenUnboxed.hasTag(INT) &amp;&amp;
<i>1712</i>&nbsp;                    types.isAssignable(thenUnboxed, elseUnboxed)) {
<i>1713</i>&nbsp;                    return elseUnboxed.baseType();
<i>1714</i>&nbsp;                }
<i>1715</i>&nbsp;
<i>1716</i>&nbsp;                for (TypeTag tag : primitiveTags) {
<i>1717</i>&nbsp;                    Type candidate = syms.typeOfTag[tag.ordinal()];
<i>1718</i>&nbsp;                    if (types.isSubtype(thenUnboxed, candidate) &amp;&amp;
<b class="nc"><i>1719</i>&nbsp;                        types.isSubtype(elseUnboxed, candidate)) {</b>
<i>1720</i>&nbsp;                        return candidate;
<i>1721</i>&nbsp;                    }
<i>1722</i>&nbsp;                }
<i>1723</i>&nbsp;            }
<i>1724</i>&nbsp;
<b class="nc"><i>1725</i>&nbsp;            // Those were all the cases that could result in a primitive</b>
<i>1726</i>&nbsp;            if (thentype.isPrimitive())
<b class="nc"><i>1727</i>&nbsp;                thentype = types.boxedClass(thentype).type;</b>
<i>1728</i>&nbsp;            if (elsetype.isPrimitive())
<b class="nc"><i>1729</i>&nbsp;                elsetype = types.boxedClass(elsetype).type;</b>
<i>1730</i>&nbsp;
<i>1731</i>&nbsp;            if (types.isSubtype(thentype, elsetype))
<b class="nc"><i>1732</i>&nbsp;                return elsetype.baseType();</b>
<b class="nc"><i>1733</i>&nbsp;            if (types.isSubtype(elsetype, thentype))</b>
<i>1734</i>&nbsp;                return thentype.baseType();
<i>1735</i>&nbsp;
<b class="nc"><i>1736</i>&nbsp;            if (thentype.hasTag(VOID) || elsetype.hasTag(VOID)) {</b>
<i>1737</i>&nbsp;                log.error(pos,
<i>1738</i>&nbsp;                          Errors.NeitherConditionalSubtype(thentype,
<i>1739</i>&nbsp;                                                           elsetype));
<b class="nc"><i>1740</i>&nbsp;                return thentype.baseType();</b>
<i>1741</i>&nbsp;            }
<i>1742</i>&nbsp;
<b class="nc"><i>1743</i>&nbsp;            // both are known to be reference types.  The result is</b>
<b class="nc"><i>1744</i>&nbsp;            // lub(thentype,elsetype). This cannot fail, as it will</b>
<b class="nc"><i>1745</i>&nbsp;            // always be possible to infer &quot;Object&quot; if nothing better.</b>
<i>1746</i>&nbsp;            return types.lub(thentype.baseType(), elsetype.baseType());
<i>1747</i>&nbsp;        }
<i>1748</i>&nbsp;
<b class="nc"><i>1749</i>&nbsp;    final static TypeTag[] primitiveTags = new TypeTag[]{</b>
<b class="nc"><i>1750</i>&nbsp;        BYTE,</b>
<b class="nc"><i>1751</i>&nbsp;        CHAR,</b>
<b class="nc"><i>1752</i>&nbsp;        SHORT,</b>
<b class="nc"><i>1753</i>&nbsp;        INT,</b>
<i>1754</i>&nbsp;        LONG,
<b class="nc"><i>1755</i>&nbsp;        FLOAT,</b>
<i>1756</i>&nbsp;        DOUBLE,
<i>1757</i>&nbsp;        BOOLEAN,
<i>1758</i>&nbsp;    };
<b class="nc"><i>1759</i>&nbsp;</b>
<b class="nc"><i>1760</i>&nbsp;    public void visitIf(JCIf tree) {</b>
<b class="nc"><i>1761</i>&nbsp;        attribExpr(tree.cond, env, syms.booleanType);</b>
<b class="nc"><i>1762</i>&nbsp;        attribStat(tree.thenpart, env);</b>
<b class="nc"><i>1763</i>&nbsp;        if (tree.elsepart != null)</b>
<i>1764</i>&nbsp;            attribStat(tree.elsepart, env);
<i>1765</i>&nbsp;        chk.checkEmptyIf(tree);
<b class="nc"><i>1766</i>&nbsp;        result = null;</b>
<b class="nc"><i>1767</i>&nbsp;    }</b>
<i>1768</i>&nbsp;
<i>1769</i>&nbsp;    public void visitExec(JCExpressionStatement tree) {
<i>1770</i>&nbsp;        //a fresh environment is required for 292 inference to work properly ---
<i>1771</i>&nbsp;        //see Infer.instantiatePolymorphicSignatureInstance()
<i>1772</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree);
<b class="nc"><i>1773</i>&nbsp;        attribExpr(tree.expr, localEnv);</b>
<b class="nc"><i>1774</i>&nbsp;        result = null;</b>
<i>1775</i>&nbsp;    }
<b class="nc"><i>1776</i>&nbsp;</b>
<i>1777</i>&nbsp;    public void visitBreak(JCBreak tree) {
<i>1778</i>&nbsp;        tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
<b class="nc"><i>1779</i>&nbsp;        result = null;</b>
<i>1780</i>&nbsp;    }
<i>1781</i>&nbsp;
<b class="nc"><i>1782</i>&nbsp;    public void visitContinue(JCContinue tree) {</b>
<b class="nc"><i>1783</i>&nbsp;        tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);</b>
<i>1784</i>&nbsp;        result = null;
<i>1785</i>&nbsp;    }
<i>1786</i>&nbsp;    //where
<i>1787</i>&nbsp;        /** Return the target of a break or continue statement, if it exists,
<i>1788</i>&nbsp;         *  report an error if not.
<b class="nc"><i>1789</i>&nbsp;         *  Note: The target of a labelled break or continue is the</b>
<b class="nc"><i>1790</i>&nbsp;         *  (non-labelled) statement tree referred to by the label,</b>
<i>1791</i>&nbsp;         *  not the tree representing the labelled statement itself.
<i>1792</i>&nbsp;         *
<i>1793</i>&nbsp;         *  @param pos     The position to be used for error diagnostics
<i>1794</i>&nbsp;         *  @param tag     The tag of the jump statement. This is either
<b class="nc"><i>1795</i>&nbsp;         *                 Tree.BREAK or Tree.CONTINUE.</b>
<b class="nc"><i>1796</i>&nbsp;         *  @param label   The label of the jump statement, or null if no</b>
<b class="nc"><i>1797</i>&nbsp;         *                 label is given.</b>
<b class="nc"><i>1798</i>&nbsp;         *  @param env     The environment current at the jump statement.</b>
<b class="nc"><i>1799</i>&nbsp;         */</b>
<b class="nc"><i>1800</i>&nbsp;        private JCTree findJumpTarget(DiagnosticPosition pos,</b>
<i>1801</i>&nbsp;                                    JCTree.Tag tag,
<i>1802</i>&nbsp;                                    Name label,
<b class="nc"><i>1803</i>&nbsp;                                    Env&lt;AttrContext&gt; env) {</b>
<i>1804</i>&nbsp;            // Search environments outwards from the point of jump.
<i>1805</i>&nbsp;            Env&lt;AttrContext&gt; env1 = env;
<i>1806</i>&nbsp;            LOOP:
<b class="nc"><i>1807</i>&nbsp;            while (env1 != null) {</b>
<b class="nc"><i>1808</i>&nbsp;                switch (env1.tree.getTag()) {</b>
<i>1809</i>&nbsp;                    case LABELLED:
<i>1810</i>&nbsp;                        JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
<i>1811</i>&nbsp;                        if (label == labelled.label) {
<b class="nc"><i>1812</i>&nbsp;                            // If jump is a continue, check that target is a loop.</b>
<i>1813</i>&nbsp;                            if (tag == CONTINUE) {
<i>1814</i>&nbsp;                                if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
<i>1815</i>&nbsp;                                        !labelled.body.hasTag(WHILELOOP) &amp;&amp;
<b class="nc"><i>1816</i>&nbsp;                                        !labelled.body.hasTag(FORLOOP) &amp;&amp;</b>
<b class="nc"><i>1817</i>&nbsp;                                        !labelled.body.hasTag(FOREACHLOOP))</b>
<b class="nc"><i>1818</i>&nbsp;                                    log.error(pos, Errors.NotLoopLabel(label));</b>
<i>1819</i>&nbsp;                                // Found labelled statement target, now go inwards
<i>1820</i>&nbsp;                                // to next non-labelled tree.
<i>1821</i>&nbsp;                                return TreeInfo.referencedStatement(labelled);
<i>1822</i>&nbsp;                            } else {
<b class="nc"><i>1823</i>&nbsp;                                return labelled;</b>
<b class="nc"><i>1824</i>&nbsp;                            }</b>
<b class="nc"><i>1825</i>&nbsp;                        }</b>
<i>1826</i>&nbsp;                        break;
<i>1827</i>&nbsp;                    case DOLOOP:
<b class="nc"><i>1828</i>&nbsp;                    case WHILELOOP:</b>
<b class="nc"><i>1829</i>&nbsp;                    case FORLOOP:</b>
<b class="nc"><i>1830</i>&nbsp;                    case FOREACHLOOP:</b>
<i>1831</i>&nbsp;                        if (label == null) return env1.tree;
<b class="nc"><i>1832</i>&nbsp;                        break;</b>
<i>1833</i>&nbsp;                    case SWITCH:
<i>1834</i>&nbsp;                        if (label == null &amp;&amp; tag == BREAK) return env1.tree;
<b class="nc"><i>1835</i>&nbsp;                        break;</b>
<i>1836</i>&nbsp;                    case LAMBDA:
<b class="nc"><i>1837</i>&nbsp;                    case METHODDEF:</b>
<i>1838</i>&nbsp;                    case CLASSDEF:
<i>1839</i>&nbsp;                        break LOOP;
<i>1840</i>&nbsp;                    default:
<b class="nc"><i>1841</i>&nbsp;                }</b>
<i>1842</i>&nbsp;                env1 = env1.next;
<b class="nc"><i>1843</i>&nbsp;            }</b>
<i>1844</i>&nbsp;            if (label != null)
<i>1845</i>&nbsp;                log.error(pos, Errors.UndefLabel(label));
<i>1846</i>&nbsp;            else if (tag == CONTINUE)
<b class="nc"><i>1847</i>&nbsp;                log.error(pos, Errors.ContOutsideLoop);</b>
<i>1848</i>&nbsp;            else
<b class="nc"><i>1849</i>&nbsp;                log.error(pos, Errors.BreakOutsideSwitchLoop);</b>
<i>1850</i>&nbsp;            return null;
<i>1851</i>&nbsp;        }
<b class="nc"><i>1852</i>&nbsp;</b>
<b class="nc"><i>1853</i>&nbsp;    public void visitReturn(JCReturn tree) {</b>
<i>1854</i>&nbsp;        // Check that there is an enclosing method which is
<b class="nc"><i>1855</i>&nbsp;        // nested within than the enclosing class.</b>
<i>1856</i>&nbsp;        if (env.info.returnResult == null) {
<b class="nc"><i>1857</i>&nbsp;            log.error(tree.pos(), Errors.RetOutsideMeth);</b>
<b class="nc"><i>1858</i>&nbsp;        } else {</b>
<i>1859</i>&nbsp;            // Attribute return expression, if it exists, and check that
<i>1860</i>&nbsp;            // it conforms to result type of enclosing method.
<i>1861</i>&nbsp;            if (tree.expr != null) {
<i>1862</i>&nbsp;                if (env.info.returnResult.pt.hasTag(VOID)) {
<b class="nc"><i>1863</i>&nbsp;                    env.info.returnResult.checkContext.report(tree.expr.pos(),</b>
<i>1864</i>&nbsp;                              diags.fragment(Fragments.UnexpectedRetVal));
<i>1865</i>&nbsp;                }
<i>1866</i>&nbsp;                attribTree(tree.expr, env, env.info.returnResult);
<i>1867</i>&nbsp;            } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
<i>1868</i>&nbsp;                    !env.info.returnResult.pt.hasTag(NONE)) {
<i>1869</i>&nbsp;                env.info.returnResult.checkContext.report(tree.pos(),
<i>1870</i>&nbsp;                              diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
<i>1871</i>&nbsp;            }
<i>1872</i>&nbsp;        }
<b class="nc"><i>1873</i>&nbsp;        result = null;</b>
<b class="nc"><i>1874</i>&nbsp;    }</b>
<b class="nc"><i>1875</i>&nbsp;</b>
<b class="nc"><i>1876</i>&nbsp;    public void visitThrow(JCThrow tree) {</b>
<i>1877</i>&nbsp;        Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
<b class="nc"><i>1878</i>&nbsp;        if (allowPoly) {</b>
<i>1879</i>&nbsp;            chk.checkType(tree, owntype, syms.throwableType);
<b class="nc"><i>1880</i>&nbsp;        }</b>
<b class="nc"><i>1881</i>&nbsp;        result = null;</b>
<b class="nc"><i>1882</i>&nbsp;    }</b>
<i>1883</i>&nbsp;
<i>1884</i>&nbsp;    public void visitAssert(JCAssert tree) {
<i>1885</i>&nbsp;        attribExpr(tree.cond, env, syms.booleanType);
<i>1886</i>&nbsp;        if (tree.detail != null) {
<i>1887</i>&nbsp;            chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
<b class="nc"><i>1888</i>&nbsp;        }</b>
<b class="nc"><i>1889</i>&nbsp;        result = null;</b>
<i>1890</i>&nbsp;    }
<i>1891</i>&nbsp;
<i>1892</i>&nbsp;     /** Visitor method for method invocations.
<b class="nc"><i>1893</i>&nbsp;     *  NOTE: The method part of an application will have in its type field</b>
<i>1894</i>&nbsp;     *        the return type of the method, not the method&#39;s type itself!
<i>1895</i>&nbsp;     */
<i>1896</i>&nbsp;    public void visitApply(JCMethodInvocation tree) {
<b class="nc"><i>1897</i>&nbsp;        // The local environment of a method application is</b>
<i>1898</i>&nbsp;        // a new environment nested in the current one.
<i>1899</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
<i>1900</i>&nbsp;
<b class="nc"><i>1901</i>&nbsp;        // The types of the actual method arguments.</b>
<i>1902</i>&nbsp;        List&lt;Type&gt; argtypes;
<i>1903</i>&nbsp;
<i>1904</i>&nbsp;        // The types of the actual method type arguments.
<b class="nc"><i>1905</i>&nbsp;        List&lt;Type&gt; typeargtypes = null;</b>
<i>1906</i>&nbsp;
<i>1907</i>&nbsp;        Name methName = TreeInfo.name(tree.meth);
<b class="nc"><i>1908</i>&nbsp;</b>
<i>1909</i>&nbsp;        boolean isConstructorCall =
<b class="nc"><i>1910</i>&nbsp;            methName == names._this || methName == names._super;</b>
<b class="nc"><i>1911</i>&nbsp;</b>
<b class="nc"><i>1912</i>&nbsp;        ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1913</i>&nbsp;        if (isConstructorCall) {</b>
<b class="nc"><i>1914</i>&nbsp;            // We are seeing a ...this(...) or ...super(...) call.</b>
<i>1915</i>&nbsp;            // Check that this is the first statement in a constructor.
<i>1916</i>&nbsp;            if (checkFirstConstructorStat(tree, env)) {
<b class="nc"><i>1917</i>&nbsp;</b>
<b class="nc"><i>1918</i>&nbsp;                // Record the fact</b>
<b class="nc"><i>1919</i>&nbsp;                // that this is a constructor call (using isSelfCall).</b>
<i>1920</i>&nbsp;                localEnv.info.isSelfCall = true;
<b class="nc"><i>1921</i>&nbsp;</b>
<i>1922</i>&nbsp;                // Attribute arguments, yielding list of argument types.
<i>1923</i>&nbsp;                KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
<i>1924</i>&nbsp;                argtypes = argtypesBuf.toList();
<b class="nc"><i>1925</i>&nbsp;                typeargtypes = attribTypes(tree.typeargs, localEnv);</b>
<i>1926</i>&nbsp;
<b class="nc"><i>1927</i>&nbsp;                // Variable `site&#39; points to the class in which the called</b>
<i>1928</i>&nbsp;                // constructor is defined.
<i>1929</i>&nbsp;                Type site = env.enclClass.sym.type;
<i>1930</i>&nbsp;                if (methName == names._super) {
<i>1931</i>&nbsp;                    if (site == syms.objectType) {
<i>1932</i>&nbsp;                        log.error(tree.meth.pos(), Errors.NoSuperclass(site));
<i>1933</i>&nbsp;                        site = types.createErrorType(syms.objectType);
<i>1934</i>&nbsp;                    } else {
<i>1935</i>&nbsp;                        site = types.supertype(site);
<b class="nc"><i>1936</i>&nbsp;                    }</b>
<b class="nc"><i>1937</i>&nbsp;                }</b>
<i>1938</i>&nbsp;
<i>1939</i>&nbsp;                if (site.hasTag(CLASS)) {
<b class="nc"><i>1940</i>&nbsp;                    Type encl = site.getEnclosingType();</b>
<i>1941</i>&nbsp;                    while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
<i>1942</i>&nbsp;                        encl = encl.getUpperBound();
<b class="nc"><i>1943</i>&nbsp;                    if (encl.hasTag(CLASS)) {</b>
<b class="nc"><i>1944</i>&nbsp;                        // we are calling a nested class</b>
<b class="nc"><i>1945</i>&nbsp;</b>
<b class="nc"><i>1946</i>&nbsp;                        if (tree.meth.hasTag(SELECT)) {</b>
<b class="nc"><i>1947</i>&nbsp;                            JCTree qualifier = ((JCFieldAccess) tree.meth).selected;</b>
<i>1948</i>&nbsp;
<b class="nc"><i>1949</i>&nbsp;                            // We are seeing a prefixed call, of the form</b>
<b class="nc"><i>1950</i>&nbsp;                            //     &lt;expr&gt;.super(...).</b>
<b class="nc"><i>1951</i>&nbsp;                            // Check that the prefix expression conforms</b>
<i>1952</i>&nbsp;                            // to the outer instance type of the class.
<i>1953</i>&nbsp;                            chk.checkRefType(qualifier.pos(),
<i>1954</i>&nbsp;                                             attribExpr(qualifier, localEnv,
<b class="nc"><i>1955</i>&nbsp;                                                        encl));</b>
<b class="nc"><i>1956</i>&nbsp;                        } else if (methName == names._super) {</b>
<b class="nc"><i>1957</i>&nbsp;                            // qualifier omitted; check for existence</b>
<b class="nc"><i>1958</i>&nbsp;                            // of an appropriate implicit qualifier.</b>
<b class="nc"><i>1959</i>&nbsp;                            rs.resolveImplicitThis(tree.meth.pos(),</b>
<i>1960</i>&nbsp;                                                   localEnv, site, true);
<i>1961</i>&nbsp;                        }
<i>1962</i>&nbsp;                    } else if (tree.meth.hasTag(SELECT)) {
<b class="nc"><i>1963</i>&nbsp;                        log.error(tree.meth.pos(),</b>
<i>1964</i>&nbsp;                                  Errors.IllegalQualNotIcls(site.tsym));
<i>1965</i>&nbsp;                    }
<i>1966</i>&nbsp;
<i>1967</i>&nbsp;                    // if we&#39;re calling a java.lang.Enum constructor,
<b class="nc"><i>1968</i>&nbsp;                    // prefix the implicit String and int parameters</b>
<b class="nc"><i>1969</i>&nbsp;                    if (site.tsym == syms.enumSym)</b>
<b class="nc"><i>1970</i>&nbsp;                        argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);</b>
<i>1971</i>&nbsp;
<b class="nc"><i>1972</i>&nbsp;                    // Resolve the called constructor under the assumption</b>
<b class="nc"><i>1973</i>&nbsp;                    // that we are referring to a superclass instance of the</b>
<b class="nc"><i>1974</i>&nbsp;                    // current instance (JLS ???).</b>
<i>1975</i>&nbsp;                    boolean selectSuperPrev = localEnv.info.selectSuper;
<i>1976</i>&nbsp;                    localEnv.info.selectSuper = true;
<b class="nc"><i>1977</i>&nbsp;                    localEnv.info.pendingResolutionPhase = null;</b>
<b class="nc"><i>1978</i>&nbsp;                    Symbol sym = rs.resolveConstructor(</b>
<b class="nc"><i>1979</i>&nbsp;                        tree.meth.pos(), localEnv, site, argtypes, typeargtypes);</b>
<b class="nc"><i>1980</i>&nbsp;                    localEnv.info.selectSuper = selectSuperPrev;</b>
<b class="nc"><i>1981</i>&nbsp;</b>
<i>1982</i>&nbsp;                    // Set method symbol to resolved constructor...
<b class="nc"><i>1983</i>&nbsp;                    TreeInfo.setSymbol(tree.meth, sym);</b>
<b class="nc"><i>1984</i>&nbsp;</b>
<b class="nc"><i>1985</i>&nbsp;                    // ...and check that it is legal in the current context.</b>
<b class="nc"><i>1986</i>&nbsp;                    // (this will also set the tree&#39;s type)</b>
<b class="nc"><i>1987</i>&nbsp;                    Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);</b>
<i>1988</i>&nbsp;                    checkId(tree.meth, site, sym, localEnv,
<i>1989</i>&nbsp;                            new ResultInfo(kind, mpt));
<b class="nc"><i>1990</i>&nbsp;                }</b>
<b class="nc"><i>1991</i>&nbsp;                // Otherwise, `site&#39; is an error type and we do nothing</b>
<i>1992</i>&nbsp;            }
<b class="nc"><i>1993</i>&nbsp;            result = tree.type = syms.voidType;</b>
<i>1994</i>&nbsp;        } else {
<i>1995</i>&nbsp;            // Otherwise, we are seeing a regular method call.
<i>1996</i>&nbsp;            // Attribute the arguments, yielding list of argument types, ...
<b class="nc"><i>1997</i>&nbsp;            KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);</b>
<b class="nc"><i>1998</i>&nbsp;            argtypes = argtypesBuf.toList();</b>
<b class="nc"><i>1999</i>&nbsp;            typeargtypes = attribAnyTypes(tree.typeargs, localEnv);</b>
<b class="nc"><i>2000</i>&nbsp;</b>
<i>2001</i>&nbsp;            // ... and attribute the method using as a prototype a methodtype
<i>2002</i>&nbsp;            // whose formal argument types is exactly the list of actual
<b class="nc"><i>2003</i>&nbsp;            // arguments (this will also set the method symbol).</b>
<i>2004</i>&nbsp;            Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
<b class="nc"><i>2005</i>&nbsp;            localEnv.info.pendingResolutionPhase = null;</b>
<i>2006</i>&nbsp;            Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
<b class="nc"><i>2007</i>&nbsp;</b>
<i>2008</i>&nbsp;            // Compute the result type.
<i>2009</i>&nbsp;            Type restype = mtype.getReturnType();
<b class="nc"><i>2010</i>&nbsp;            if (restype.hasTag(WILDCARD))</b>
<i>2011</i>&nbsp;                throw new AssertionError(mtype);
<b class="nc"><i>2012</i>&nbsp;</b>
<b class="nc"><i>2013</i>&nbsp;            Type qualifier = (tree.meth.hasTag(SELECT))</b>
<b class="nc"><i>2014</i>&nbsp;                    ? ((JCFieldAccess) tree.meth).selected.type</b>
<i>2015</i>&nbsp;                    : env.enclClass.sym.type;
<b class="nc"><i>2016</i>&nbsp;            Symbol msym = TreeInfo.symbol(tree.meth);</b>
<i>2017</i>&nbsp;            restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
<i>2018</i>&nbsp;
<b class="nc"><i>2019</i>&nbsp;            chk.checkRefTypes(tree.typeargs, typeargtypes);</b>
<b class="nc"><i>2020</i>&nbsp;</b>
<i>2021</i>&nbsp;            // Check that value of resulting type is admissible in the
<b class="nc"><i>2022</i>&nbsp;            // current context.  Also, capture the return type</b>
<b class="nc"><i>2023</i>&nbsp;            Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);</b>
<i>2024</i>&nbsp;            result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
<i>2025</i>&nbsp;        }
<b class="nc"><i>2026</i>&nbsp;        chk.validate(tree.typeargs, localEnv);</b>
<b class="nc"><i>2027</i>&nbsp;    }</b>
<b class="nc"><i>2028</i>&nbsp;    //where</b>
<b class="nc"><i>2029</i>&nbsp;        Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {</b>
<b class="nc"><i>2030</i>&nbsp;            if (msym != null &amp;&amp;</b>
<i>2031</i>&nbsp;                    msym.owner == syms.objectType.tsym &amp;&amp;
<i>2032</i>&nbsp;                    methodName == names.getClass &amp;&amp;
<b class="nc"><i>2033</i>&nbsp;                    argtypes.isEmpty()) {</b>
<b class="nc"><i>2034</i>&nbsp;                // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;</b>
<b class="nc"><i>2035</i>&nbsp;                return new ClassType(restype.getEnclosingType(),</b>
<i>2036</i>&nbsp;                        List.of(new WildcardType(types.erasure(qualifierType),
<i>2037</i>&nbsp;                                BoundKind.EXTENDS,
<i>2038</i>&nbsp;                                syms.boundClass)),
<i>2039</i>&nbsp;                        restype.tsym,
<b class="nc"><i>2040</i>&nbsp;                        restype.getMetadata());</b>
<i>2041</i>&nbsp;            } else if (msym != null &amp;&amp;
<i>2042</i>&nbsp;                    msym.owner == syms.arrayClass &amp;&amp;
<i>2043</i>&nbsp;                    methodName == names.clone &amp;&amp;
<i>2044</i>&nbsp;                    types.isArray(qualifierType)) {
<b class="nc"><i>2045</i>&nbsp;                // as a special case, array.clone() has a result that is</b>
<i>2046</i>&nbsp;                // the same as static type of the array being cloned
<b class="nc"><i>2047</i>&nbsp;                return qualifierType;</b>
<b class="nc"><i>2048</i>&nbsp;            } else {</b>
<i>2049</i>&nbsp;                return restype;
<i>2050</i>&nbsp;            }
<b class="nc"><i>2051</i>&nbsp;        }</b>
<b class="nc"><i>2052</i>&nbsp;</b>
<i>2053</i>&nbsp;        /** Check that given application node appears as first statement
<i>2054</i>&nbsp;         *  in a constructor call.
<b class="nc"><i>2055</i>&nbsp;         *  @param tree   The application node</b>
<b class="nc"><i>2056</i>&nbsp;         *  @param env    The environment current at the application.</b>
<i>2057</i>&nbsp;         */
<i>2058</i>&nbsp;        boolean checkFirstConstructorStat(JCMethodInvocation tree, Env&lt;AttrContext&gt; env) {
<i>2059</i>&nbsp;            JCMethodDecl enclMethod = env.enclMethod;
<i>2060</i>&nbsp;            if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
<b class="nc"><i>2061</i>&nbsp;                JCBlock body = enclMethod.body;</b>
<b class="nc"><i>2062</i>&nbsp;                if (body.stats.head.hasTag(EXEC) &amp;&amp;</b>
<b class="nc"><i>2063</i>&nbsp;                    ((JCExpressionStatement) body.stats.head).expr == tree)</b>
<b class="nc"><i>2064</i>&nbsp;                    return true;</b>
<i>2065</i>&nbsp;            }
<b class="nc"><i>2066</i>&nbsp;            log.error(tree.pos(),</b>
<b class="nc"><i>2067</i>&nbsp;                      Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));</b>
<i>2068</i>&nbsp;            return false;
<i>2069</i>&nbsp;        }
<i>2070</i>&nbsp;
<i>2071</i>&nbsp;        /** Obtain a method type with given argument types.
<i>2072</i>&nbsp;         */
<i>2073</i>&nbsp;        Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>2074</i>&nbsp;            MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
<i>2075</i>&nbsp;            return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
<b class="nc"><i>2076</i>&nbsp;        }</b>
<b class="nc"><i>2077</i>&nbsp;</b>
<b class="nc"><i>2078</i>&nbsp;    public void visitNewClass(final JCNewClass tree) {</b>
<b class="nc"><i>2079</i>&nbsp;        Type owntype = types.createErrorType(tree.type);</b>
<b class="nc"><i>2080</i>&nbsp;</b>
<b class="nc"><i>2081</i>&nbsp;        // The local environment of a class creation is</b>
<b class="nc"><i>2082</i>&nbsp;        // a new environment nested in the current one.</b>
<i>2083</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
<i>2084</i>&nbsp;
<i>2085</i>&nbsp;        // The anonymous inner class definition of the new expression,
<b class="nc"><i>2086</i>&nbsp;        // if one is defined by it.</b>
<b class="nc"><i>2087</i>&nbsp;        JCClassDecl cdef = tree.def;</b>
<b class="nc"><i>2088</i>&nbsp;</b>
<i>2089</i>&nbsp;        // If enclosing class is given, attribute it, and
<b class="nc"><i>2090</i>&nbsp;        // complete class name to be fully qualified</b>
<b class="nc"><i>2091</i>&nbsp;        JCExpression clazz = tree.clazz; // Class field following new</b>
<b class="nc"><i>2092</i>&nbsp;        JCExpression clazzid;            // Identifier in class field</b>
<i>2093</i>&nbsp;        JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
<b class="nc"><i>2094</i>&nbsp;        annoclazzid = null;</b>
<i>2095</i>&nbsp;
<i>2096</i>&nbsp;        if (clazz.hasTag(TYPEAPPLY)) {
<i>2097</i>&nbsp;            clazzid = ((JCTypeApply) clazz).clazz;
<b class="nc"><i>2098</i>&nbsp;            if (clazzid.hasTag(ANNOTATED_TYPE)) {</b>
<i>2099</i>&nbsp;                annoclazzid = (JCAnnotatedType) clazzid;
<i>2100</i>&nbsp;                clazzid = annoclazzid.underlyingType;
<i>2101</i>&nbsp;            }
<i>2102</i>&nbsp;        } else {
<i>2103</i>&nbsp;            if (clazz.hasTag(ANNOTATED_TYPE)) {
<i>2104</i>&nbsp;                annoclazzid = (JCAnnotatedType) clazz;
<i>2105</i>&nbsp;                clazzid = annoclazzid.underlyingType;
<i>2106</i>&nbsp;            } else {
<i>2107</i>&nbsp;                clazzid = clazz;
<i>2108</i>&nbsp;            }
<i>2109</i>&nbsp;        }
<i>2110</i>&nbsp;
<i>2111</i>&nbsp;        JCExpression clazzid1 = clazzid; // The same in fully qualified form
<i>2112</i>&nbsp;
<i>2113</i>&nbsp;        if (tree.encl != null) {
<i>2114</i>&nbsp;            // We are seeing a qualified new, of the form
<i>2115</i>&nbsp;            //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
<i>2116</i>&nbsp;            // In this case, we let clazz stand for the name of the
<i>2117</i>&nbsp;            // allocated class C prefixed with the type of the qualifier
<i>2118</i>&nbsp;            // expression, so that we can
<i>2119</i>&nbsp;            // resolve it with standard techniques later. I.e., if
<i>2120</i>&nbsp;            // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
<i>2121</i>&nbsp;            // yields a clazz T.C.
<i>2122</i>&nbsp;            Type encltype = chk.checkRefType(tree.encl.pos(),
<i>2123</i>&nbsp;                                             attribExpr(tree.encl, env));
<i>2124</i>&nbsp;            // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
<i>2125</i>&nbsp;            // from expr to the combined type, or not? Yes, do this.
<i>2126</i>&nbsp;            clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
<i>2127</i>&nbsp;                                                 ((JCIdent) clazzid).name);
<i>2128</i>&nbsp;
<i>2129</i>&nbsp;            EndPosTable endPosTable = this.env.toplevel.endPositions;
<i>2130</i>&nbsp;            endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
<b class="nc"><i>2131</i>&nbsp;            if (clazz.hasTag(ANNOTATED_TYPE)) {</b>
<i>2132</i>&nbsp;                JCAnnotatedType annoType = (JCAnnotatedType) clazz;
<b class="nc"><i>2133</i>&nbsp;                List&lt;JCAnnotation&gt; annos = annoType.annotations;</b>
<b class="nc"><i>2134</i>&nbsp;</b>
<i>2135</i>&nbsp;                if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
<b class="nc"><i>2136</i>&nbsp;                    clazzid1 = make.at(tree.pos).</b>
<i>2137</i>&nbsp;                        TypeApply(clazzid1,
<i>2138</i>&nbsp;                                  ((JCTypeApply) clazz).arguments);
<b class="nc"><i>2139</i>&nbsp;                }</b>
<b class="nc"><i>2140</i>&nbsp;</b>
<b class="nc"><i>2141</i>&nbsp;                clazzid1 = make.at(tree.pos).</b>
<i>2142</i>&nbsp;                    AnnotatedType(annos, clazzid1);
<i>2143</i>&nbsp;            } else if (clazz.hasTag(TYPEAPPLY)) {
<b class="nc"><i>2144</i>&nbsp;                clazzid1 = make.at(tree.pos).</b>
<i>2145</i>&nbsp;                    TypeApply(clazzid1,
<b class="nc"><i>2146</i>&nbsp;                              ((JCTypeApply) clazz).arguments);</b>
<i>2147</i>&nbsp;            }
<i>2148</i>&nbsp;
<i>2149</i>&nbsp;            clazz = clazzid1;
<i>2150</i>&nbsp;        }
<b class="nc"><i>2151</i>&nbsp;</b>
<b class="nc"><i>2152</i>&nbsp;        // Attribute clazz expression and store</b>
<b class="nc"><i>2153</i>&nbsp;        // symbol + type back into the attributed tree.</b>
<b class="nc"><i>2154</i>&nbsp;        Type clazztype;</b>
<i>2155</i>&nbsp;
<i>2156</i>&nbsp;        try {
<i>2157</i>&nbsp;            env.info.isNewClass = true;
<b class="nc"><i>2158</i>&nbsp;            clazztype = TreeInfo.isEnumInit(env.tree) ?</b>
<b class="nc"><i>2159</i>&nbsp;                attribIdentAsEnumType(env, (JCIdent)clazz) :</b>
<b class="nc"><i>2160</i>&nbsp;                attribType(clazz, env);</b>
<b class="nc"><i>2161</i>&nbsp;        } finally {</b>
<b class="nc"><i>2162</i>&nbsp;            env.info.isNewClass = false;</b>
<b class="nc"><i>2163</i>&nbsp;        }</b>
<i>2164</i>&nbsp;
<i>2165</i>&nbsp;        clazztype = chk.checkDiamond(tree, clazztype);
<i>2166</i>&nbsp;        chk.validate(clazz, localEnv);
<b class="nc"><i>2167</i>&nbsp;        if (tree.encl != null) {</b>
<i>2168</i>&nbsp;            // We have to work in this case to store
<i>2169</i>&nbsp;            // symbol + type back into the attributed tree.
<b class="nc"><i>2170</i>&nbsp;            tree.clazz.type = clazztype;</b>
<b class="nc"><i>2171</i>&nbsp;            TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));</b>
<i>2172</i>&nbsp;            clazzid.type = ((JCIdent) clazzid).sym.type;
<b class="nc"><i>2173</i>&nbsp;            if (annoclazzid != null) {</b>
<b class="nc"><i>2174</i>&nbsp;                annoclazzid.type = clazzid.type;</b>
<b class="nc"><i>2175</i>&nbsp;            }</b>
<i>2176</i>&nbsp;            if (!clazztype.isErroneous()) {
<b class="nc"><i>2177</i>&nbsp;                if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {</b>
<b class="nc"><i>2178</i>&nbsp;                    log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);</b>
<i>2179</i>&nbsp;                } else if (clazztype.tsym.isStatic()) {
<i>2180</i>&nbsp;                    log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
<b class="nc"><i>2181</i>&nbsp;                }</b>
<i>2182</i>&nbsp;            }
<i>2183</i>&nbsp;        } else if (!clazztype.tsym.isInterface() &amp;&amp;
<i>2184</i>&nbsp;                   clazztype.getEnclosingType().hasTag(CLASS)) {
<b class="nc"><i>2185</i>&nbsp;            // Check for the existence of an apropos outer instance</b>
<i>2186</i>&nbsp;            rs.resolveImplicitThis(tree.pos(), env, clazztype);
<i>2187</i>&nbsp;        }
<i>2188</i>&nbsp;
<b class="nc"><i>2189</i>&nbsp;        // Attribute constructor arguments.</b>
<b class="nc"><i>2190</i>&nbsp;        ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();</b>
<i>2191</i>&nbsp;        final KindSelector pkind =
<i>2192</i>&nbsp;            attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
<b class="nc"><i>2193</i>&nbsp;        List&lt;Type&gt; argtypes = argtypesBuf.toList();</b>
<b class="nc"><i>2194</i>&nbsp;        List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);</b>
<b class="nc"><i>2195</i>&nbsp;</b>
<b class="nc"><i>2196</i>&nbsp;        if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {</b>
<b class="nc"><i>2197</i>&nbsp;            // Enums may not be instantiated except implicitly</b>
<i>2198</i>&nbsp;            if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
<i>2199</i>&nbsp;                (!env.tree.hasTag(VARDEF) ||
<b class="nc"><i>2200</i>&nbsp;                 (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||</b>
<b class="nc"><i>2201</i>&nbsp;                 ((JCVariableDecl) env.tree).init != tree))</b>
<b class="nc"><i>2202</i>&nbsp;                log.error(tree.pos(), Errors.EnumCantBeInstantiated);</b>
<b class="nc"><i>2203</i>&nbsp;</b>
<b class="nc"><i>2204</i>&nbsp;            boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;</b>
<i>2205</i>&nbsp;                    resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
<i>2206</i>&nbsp;            boolean skipNonDiamondPath = false;
<b class="nc"><i>2207</i>&nbsp;            // Check that class is not abstract</b>
<i>2208</i>&nbsp;            if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
<i>2209</i>&nbsp;                (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
<b class="nc"><i>2210</i>&nbsp;                log.error(tree.pos(),</b>
<b class="nc"><i>2211</i>&nbsp;                          Errors.AbstractCantBeInstantiated(clazztype.tsym));</b>
<i>2212</i>&nbsp;                skipNonDiamondPath = true;
<i>2213</i>&nbsp;            } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
<i>2214</i>&nbsp;                // Check that no constructor arguments are given to
<b class="nc"><i>2215</i>&nbsp;                // anonymous classes implementing an interface</b>
<i>2216</i>&nbsp;                if (!argtypes.isEmpty())
<b class="nc"><i>2217</i>&nbsp;                    log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);</b>
<b class="nc"><i>2218</i>&nbsp;</b>
<b class="nc"><i>2219</i>&nbsp;                if (!typeargtypes.isEmpty())</b>
<b class="nc"><i>2220</i>&nbsp;                    log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);</b>
<b class="nc"><i>2221</i>&nbsp;</b>
<b class="nc"><i>2222</i>&nbsp;                // Error recovery: pretend no arguments were supplied.</b>
<b class="nc"><i>2223</i>&nbsp;                argtypes = List.nil();</b>
<b class="nc"><i>2224</i>&nbsp;                typeargtypes = List.nil();</b>
<b class="nc"><i>2225</i>&nbsp;                skipNonDiamondPath = true;</b>
<b class="nc"><i>2226</i>&nbsp;            }</b>
<b class="nc"><i>2227</i>&nbsp;            if (TreeInfo.isDiamond(tree)) {</b>
<b class="nc"><i>2228</i>&nbsp;                ClassType site = new ClassType(clazztype.getEnclosingType(),</b>
<b class="nc"><i>2229</i>&nbsp;                            clazztype.tsym.type.getTypeArguments(),</b>
<b class="nc"><i>2230</i>&nbsp;                                               clazztype.tsym,</b>
<b class="nc"><i>2231</i>&nbsp;                                               clazztype.getMetadata());</b>
<i>2232</i>&nbsp;
<b class="nc"><i>2233</i>&nbsp;                Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);</b>
<b class="nc"><i>2234</i>&nbsp;                diamondEnv.info.selectSuper = cdef != null;</b>
<b class="nc"><i>2235</i>&nbsp;                diamondEnv.info.pendingResolutionPhase = null;</b>
<i>2236</i>&nbsp;
<i>2237</i>&nbsp;                //if the type of the instance creation expression is a class type
<i>2238</i>&nbsp;                //apply method resolution inference (JLS 15.12.2.7). The return type
<i>2239</i>&nbsp;                //of the resolved constructor will be a partially instantiated type
<i>2240</i>&nbsp;                Symbol constructor = rs.resolveDiamond(tree.pos(),
<i>2241</i>&nbsp;                            diamondEnv,
<i>2242</i>&nbsp;                            site,
<i>2243</i>&nbsp;                            argtypes,
<b class="nc"><i>2244</i>&nbsp;                            typeargtypes);</b>
<b class="nc"><i>2245</i>&nbsp;                tree.constructor = constructor.baseSymbol();</b>
<i>2246</i>&nbsp;
<b class="nc"><i>2247</i>&nbsp;                final TypeSymbol csym = clazztype.tsym;</b>
<b class="nc"><i>2248</i>&nbsp;                ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),</b>
<b class="nc"><i>2249</i>&nbsp;                        diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);</b>
<b class="nc"><i>2250</i>&nbsp;                Type constructorType = tree.constructorType = types.createErrorType(clazztype);</b>
<b class="nc"><i>2251</i>&nbsp;                constructorType = checkId(tree, site,</b>
<i>2252</i>&nbsp;                        constructor,
<i>2253</i>&nbsp;                        diamondEnv,
<i>2254</i>&nbsp;                        diamondResult);
<b class="nc"><i>2255</i>&nbsp;</b>
<b class="nc"><i>2256</i>&nbsp;                tree.clazz.type = types.createErrorType(clazztype);</b>
<i>2257</i>&nbsp;                if (!constructorType.isErroneous()) {
<b class="nc"><i>2258</i>&nbsp;                    tree.clazz.type = clazz.type = constructorType.getReturnType();</b>
<b class="nc"><i>2259</i>&nbsp;                    tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);</b>
<b class="nc"><i>2260</i>&nbsp;                }</b>
<b class="nc"><i>2261</i>&nbsp;                clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);</b>
<b class="nc"><i>2262</i>&nbsp;            }</b>
<b class="nc"><i>2263</i>&nbsp;</b>
<b class="nc"><i>2264</i>&nbsp;            // Resolve the called constructor under the assumption</b>
<i>2265</i>&nbsp;            // that we are referring to a superclass instance of the
<i>2266</i>&nbsp;            // current instance (JLS ???).
<i>2267</i>&nbsp;            else if (!skipNonDiamondPath) {
<i>2268</i>&nbsp;                //the following code alters some of the fields in the current
<b class="nc"><i>2269</i>&nbsp;                //AttrContext - hence, the current context must be dup&#39;ed in</b>
<b class="nc"><i>2270</i>&nbsp;                //order to avoid downstream failures</b>
<i>2271</i>&nbsp;                Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
<b class="nc"><i>2272</i>&nbsp;                rsEnv.info.selectSuper = cdef != null;</b>
<b class="nc"><i>2273</i>&nbsp;                rsEnv.info.pendingResolutionPhase = null;</b>
<b class="nc"><i>2274</i>&nbsp;                tree.constructor = rs.resolveConstructor(</b>
<i>2275</i>&nbsp;                    tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
<b class="nc"><i>2276</i>&nbsp;                if (cdef == null) { //do not check twice!</b>
<i>2277</i>&nbsp;                    tree.constructorType = checkId(tree,
<i>2278</i>&nbsp;                            clazztype,
<b class="nc"><i>2279</i>&nbsp;                            tree.constructor,</b>
<b class="nc"><i>2280</i>&nbsp;                            rsEnv,</b>
<b class="nc"><i>2281</i>&nbsp;                            new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));</b>
<i>2282</i>&nbsp;                    if (rsEnv.info.lastResolveVarargs())
<b class="nc"><i>2283</i>&nbsp;                        Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);</b>
<b class="nc"><i>2284</i>&nbsp;                }</b>
<b class="nc"><i>2285</i>&nbsp;            }</b>
<i>2286</i>&nbsp;
<i>2287</i>&nbsp;            if (cdef != null) {
<i>2288</i>&nbsp;                visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
<i>2289</i>&nbsp;                return;
<i>2290</i>&nbsp;            }
<i>2291</i>&nbsp;
<i>2292</i>&nbsp;            if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
<i>2293</i>&nbsp;                owntype = clazztype;
<i>2294</i>&nbsp;        }
<i>2295</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);
<b class="nc"><i>2296</i>&nbsp;        InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();</b>
<b class="nc"><i>2297</i>&nbsp;        if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {</b>
<i>2298</i>&nbsp;            //we need to wait for inference to finish and then replace inference vars in the constructor type
<b class="nc"><i>2299</i>&nbsp;            inferenceContext.addFreeTypeListener(List.of(tree.constructorType),</b>
<i>2300</i>&nbsp;                    instantiatedContext -&gt; {
<b class="nc"><i>2301</i>&nbsp;                        tree.constructorType = instantiatedContext.asInstType(tree.constructorType);</b>
<i>2302</i>&nbsp;                    });
<i>2303</i>&nbsp;        }
<i>2304</i>&nbsp;        chk.validate(tree.typeargs, localEnv);
<b class="nc"><i>2305</i>&nbsp;    }</b>
<b class="nc"><i>2306</i>&nbsp;</b>
<b class="nc"><i>2307</i>&nbsp;        // where</b>
<i>2308</i>&nbsp;        private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
<b class="nc"><i>2309</i>&nbsp;                                                   JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,</b>
<b class="nc"><i>2310</i>&nbsp;                                                   List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,</b>
<b class="nc"><i>2311</i>&nbsp;                                                   KindSelector pkind) {</b>
<i>2312</i>&nbsp;            // We are seeing an anonymous class instance creation.
<b class="nc"><i>2313</i>&nbsp;            // In this case, the class instance creation</b>
<b class="nc"><i>2314</i>&nbsp;            // expression</b>
<i>2315</i>&nbsp;            //
<b class="nc"><i>2316</i>&nbsp;            //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }</b>
<b class="nc"><i>2317</i>&nbsp;            //</b>
<i>2318</i>&nbsp;            // is represented internally as
<i>2319</i>&nbsp;            //
<i>2320</i>&nbsp;            //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
<b class="nc"><i>2321</i>&nbsp;            //</b>
<i>2322</i>&nbsp;            // This expression is then *transformed* as follows:
<i>2323</i>&nbsp;            //
<i>2324</i>&nbsp;            // (1) add an extends or implements clause
<i>2325</i>&nbsp;            // (2) add a constructor.
<b class="nc"><i>2326</i>&nbsp;            //</b>
<b class="nc"><i>2327</i>&nbsp;            // For instance, if C is a class, and ET is the type of E,</b>
<b class="nc"><i>2328</i>&nbsp;            // the expression</b>
<i>2329</i>&nbsp;            //
<i>2330</i>&nbsp;            //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
<b class="nc"><i>2331</i>&nbsp;            //</b>
<b class="nc"><i>2332</i>&nbsp;            // is translated to (where X is a fresh name and typarams is the</b>
<i>2333</i>&nbsp;            // parameter list of the super constructor):
<b class="nc"><i>2334</i>&nbsp;            //</b>
<b class="nc"><i>2335</i>&nbsp;            //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where</b>
<i>2336</i>&nbsp;            //     X extends C&lt;typargs2&gt; {
<i>2337</i>&nbsp;            //       &lt;typarams&gt; X(ET e, args) {
<b class="nc"><i>2338</i>&nbsp;            //         e.&lt;typeargs1&gt;super(args)</b>
<i>2339</i>&nbsp;            //       }
<b class="nc"><i>2340</i>&nbsp;            //       ...</b>
<i>2341</i>&nbsp;            //     }
<b class="nc"><i>2342</i>&nbsp;            InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();</b>
<b class="nc"><i>2343</i>&nbsp;            final boolean isDiamond = TreeInfo.isDiamond(tree);</b>
<b class="nc"><i>2344</i>&nbsp;            if (isDiamond</b>
<i>2345</i>&nbsp;                    &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
<i>2346</i>&nbsp;                    || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
<i>2347</i>&nbsp;                final ResultInfo resultInfoForClassDefinition = this.resultInfo;
<b class="nc"><i>2348</i>&nbsp;                inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),</b>
<i>2349</i>&nbsp;                        instantiatedContext -&gt; {
<b class="nc"><i>2350</i>&nbsp;                            tree.constructorType = instantiatedContext.asInstType(tree.constructorType);</b>
<b class="nc"><i>2351</i>&nbsp;                            tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);</b>
<i>2352</i>&nbsp;                            ResultInfo prevResult = this.resultInfo;
<b class="nc"><i>2353</i>&nbsp;                            try {</b>
<i>2354</i>&nbsp;                                this.resultInfo = resultInfoForClassDefinition;
<b class="nc"><i>2355</i>&nbsp;                                visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,</b>
<b class="nc"><i>2356</i>&nbsp;                                                            localEnv, argtypes, typeargtypes, pkind);</b>
<i>2357</i>&nbsp;                            } finally {
<b class="nc"><i>2358</i>&nbsp;                                this.resultInfo = prevResult;</b>
<i>2359</i>&nbsp;                            }
<i>2360</i>&nbsp;                        });
<b class="nc"><i>2361</i>&nbsp;            } else {</b>
<i>2362</i>&nbsp;                if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
<i>2363</i>&nbsp;                    List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
<b class="nc"><i>2364</i>&nbsp;                    if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {</b>
<b class="nc"><i>2365</i>&nbsp;                        // One or more types inferred in the previous steps is non-denotable.</b>
<b class="nc"><i>2366</i>&nbsp;                        Fragment fragment = Diamond(clazztype.tsym);</b>
<i>2367</i>&nbsp;                        log.error(tree.clazz.pos(),
<i>2368</i>&nbsp;                                Errors.CantApplyDiamond1(
<b class="nc"><i>2369</i>&nbsp;                                        fragment,</b>
<b class="nc"><i>2370</i>&nbsp;                                        invalidDiamondArgs.size() &gt; 1 ?</b>
<i>2371</i>&nbsp;                                                DiamondInvalidArgs(invalidDiamondArgs, fragment) :
<i>2372</i>&nbsp;                                                DiamondInvalidArg(invalidDiamondArgs, fragment)));
<b class="nc"><i>2373</i>&nbsp;                    }</b>
<i>2374</i>&nbsp;                    // For &lt;&gt;(){}, inferred types must also be accessible.
<b class="nc"><i>2375</i>&nbsp;                    for (Type t : clazztype.getTypeArguments()) {</b>
<b class="nc"><i>2376</i>&nbsp;                        rs.checkAccessibleType(env, t);</b>
<b class="nc"><i>2377</i>&nbsp;                    }</b>
<i>2378</i>&nbsp;                }
<i>2379</i>&nbsp;
<i>2380</i>&nbsp;                // If we already errored, be careful to avoid a further avalanche. ErrorType answers
<i>2381</i>&nbsp;                // false for isInterface call even when the original type is an interface.
<i>2382</i>&nbsp;                boolean implementing = clazztype.tsym.isInterface() ||
<i>2383</i>&nbsp;                        clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
<i>2384</i>&nbsp;                        clazztype.getOriginalType().tsym.isInterface();
<i>2385</i>&nbsp;
<b class="nc"><i>2386</i>&nbsp;                if (implementing) {</b>
<i>2387</i>&nbsp;                    cdef.implementing = List.of(clazz);
<b class="nc"><i>2388</i>&nbsp;                } else {</b>
<b class="nc"><i>2389</i>&nbsp;                    cdef.extending = clazz;</b>
<i>2390</i>&nbsp;                }
<i>2391</i>&nbsp;
<b class="nc"><i>2392</i>&nbsp;                if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;</b>
<i>2393</i>&nbsp;                    isSerializable(clazztype)) {
<b class="nc"><i>2394</i>&nbsp;                    localEnv.info.isSerializable = true;</b>
<b class="nc"><i>2395</i>&nbsp;                }</b>
<i>2396</i>&nbsp;
<b class="nc"><i>2397</i>&nbsp;                attribStat(cdef, localEnv);</b>
<b class="nc"><i>2398</i>&nbsp;</b>
<i>2399</i>&nbsp;                List&lt;Type&gt; finalargtypes;
<b class="nc"><i>2400</i>&nbsp;                // If an outer instance is given,</b>
<b class="nc"><i>2401</i>&nbsp;                // prefix it to the constructor arguments</b>
<i>2402</i>&nbsp;                // and delete it from the new expression
<i>2403</i>&nbsp;                if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
<b class="nc"><i>2404</i>&nbsp;                    finalargtypes = argtypes.prepend(tree.encl.type);</b>
<i>2405</i>&nbsp;                } else {
<b class="nc"><i>2406</i>&nbsp;                    finalargtypes = argtypes;</b>
<b class="nc"><i>2407</i>&nbsp;                }</b>
<i>2408</i>&nbsp;
<b class="nc"><i>2409</i>&nbsp;                // Reassign clazztype and recompute constructor. As this necessarily involves</b>
<b class="nc"><i>2410</i>&nbsp;                // another attribution pass for deferred types in the case of &lt;&gt;, replicate</b>
<i>2411</i>&nbsp;                // them. Original arguments have right decorations already.
<b class="nc"><i>2412</i>&nbsp;                if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {</b>
<b class="nc"><i>2413</i>&nbsp;                    finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);</b>
<i>2414</i>&nbsp;                }
<b class="nc"><i>2415</i>&nbsp;</b>
<i>2416</i>&nbsp;                clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
<b class="nc"><i>2417</i>&nbsp;                                                    : cdef.sym.type;</b>
<b class="nc"><i>2418</i>&nbsp;                Symbol sym = tree.constructor = rs.resolveConstructor(</b>
<b class="nc"><i>2419</i>&nbsp;                        tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);</b>
<i>2420</i>&nbsp;                Assert.check(!sym.kind.isResolutionError());
<b class="nc"><i>2421</i>&nbsp;                tree.constructor = sym;</b>
<i>2422</i>&nbsp;                tree.constructorType = checkId(tree,
<i>2423</i>&nbsp;                        clazztype,
<b class="nc"><i>2424</i>&nbsp;                        tree.constructor,</b>
<i>2425</i>&nbsp;                        localEnv,
<b class="nc"><i>2426</i>&nbsp;                        new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));</b>
<b class="nc"><i>2427</i>&nbsp;            }</b>
<b class="nc"><i>2428</i>&nbsp;            Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?</b>
<b class="nc"><i>2429</i>&nbsp;                                clazztype : types.createErrorType(tree.type);</b>
<b class="nc"><i>2430</i>&nbsp;            result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));</b>
<i>2431</i>&nbsp;            chk.validate(tree.typeargs, localEnv);
<i>2432</i>&nbsp;        }
<b class="nc"><i>2433</i>&nbsp;</b>
<b class="nc"><i>2434</i>&nbsp;        CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {</b>
<b class="nc"><i>2435</i>&nbsp;            return new Check.NestedCheckContext(checkContext) {</b>
<i>2436</i>&nbsp;                @Override
<i>2437</i>&nbsp;                public void report(DiagnosticPosition _unused, JCDiagnostic details) {
<i>2438</i>&nbsp;                    enclosingContext.report(clazz.clazz,
<i>2439</i>&nbsp;                            diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
<i>2440</i>&nbsp;                }
<b class="nc"><i>2441</i>&nbsp;            };</b>
<i>2442</i>&nbsp;        }
<i>2443</i>&nbsp;
<b class="nc"><i>2444</i>&nbsp;    /** Make an attributed null check tree.</b>
<i>2445</i>&nbsp;     */
<i>2446</i>&nbsp;    public JCExpression makeNullCheck(JCExpression arg) {
<i>2447</i>&nbsp;        // optimization: new Outer() can never be null; skip null check
<i>2448</i>&nbsp;        if (arg.getTag() == NEWCLASS)
<i>2449</i>&nbsp;            return arg;
<b class="nc"><i>2450</i>&nbsp;        // optimization: X.this is never null; skip null check</b>
<i>2451</i>&nbsp;        Name name = TreeInfo.name(arg);
<b class="nc"><i>2452</i>&nbsp;        if (name == names._this || name == names._super) return arg;</b>
<i>2453</i>&nbsp;
<i>2454</i>&nbsp;        JCTree.Tag optag = NULLCHK;
<b class="nc"><i>2455</i>&nbsp;        JCUnary tree = make.at(arg.pos).Unary(optag, arg);</b>
<i>2456</i>&nbsp;        tree.operator = operators.resolveUnary(arg, optag, arg.type);
<i>2457</i>&nbsp;        tree.type = arg.type;
<i>2458</i>&nbsp;        return tree;
<b class="nc"><i>2459</i>&nbsp;    }</b>
<b class="nc"><i>2460</i>&nbsp;</b>
<i>2461</i>&nbsp;    public void visitNewArray(JCNewArray tree) {
<i>2462</i>&nbsp;        Type owntype = types.createErrorType(tree.type);
<i>2463</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree);
<b class="nc"><i>2464</i>&nbsp;        Type elemtype;</b>
<b class="nc"><i>2465</i>&nbsp;        if (tree.elemtype != null) {</b>
<b class="nc"><i>2466</i>&nbsp;            elemtype = attribType(tree.elemtype, localEnv);</b>
<b class="nc"><i>2467</i>&nbsp;            chk.validate(tree.elemtype, localEnv);</b>
<b class="nc"><i>2468</i>&nbsp;            owntype = elemtype;</b>
<b class="nc"><i>2469</i>&nbsp;            for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>2470</i>&nbsp;                attribExpr(l.head, localEnv, syms.intType);</b>
<b class="nc"><i>2471</i>&nbsp;                owntype = new ArrayType(owntype, syms.arrayClass);</b>
<i>2472</i>&nbsp;            }
<b class="nc"><i>2473</i>&nbsp;        } else {</b>
<i>2474</i>&nbsp;            // we are seeing an untyped aggregate { ... }
<b class="nc"><i>2475</i>&nbsp;            // this is allowed only if the prototype is an array</b>
<b class="nc"><i>2476</i>&nbsp;            if (pt().hasTag(ARRAY)) {</b>
<i>2477</i>&nbsp;                elemtype = types.elemtype(pt());
<b class="nc"><i>2478</i>&nbsp;            } else {</b>
<i>2479</i>&nbsp;                if (!pt().hasTag(ERROR) &amp;&amp;
<i>2480</i>&nbsp;                        (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
<i>2481</i>&nbsp;                    log.error(tree.pos(),
<b class="nc"><i>2482</i>&nbsp;                              Errors.IllegalInitializerForType(pt()));</b>
<b class="nc"><i>2483</i>&nbsp;                }</b>
<b class="nc"><i>2484</i>&nbsp;                elemtype = types.createErrorType(pt());</b>
<b class="nc"><i>2485</i>&nbsp;            }</b>
<b class="nc"><i>2486</i>&nbsp;        }</b>
<i>2487</i>&nbsp;        if (tree.elems != null) {
<b class="nc"><i>2488</i>&nbsp;            attribExprs(tree.elems, localEnv, elemtype);</b>
<b class="nc"><i>2489</i>&nbsp;            owntype = new ArrayType(elemtype, syms.arrayClass);</b>
<b class="nc"><i>2490</i>&nbsp;        }</b>
<b class="nc"><i>2491</i>&nbsp;        if (!types.isReifiable(elemtype))</b>
<b class="nc"><i>2492</i>&nbsp;            log.error(tree.pos(), Errors.GenericArrayCreation);</b>
<b class="nc"><i>2493</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);</b>
<i>2494</i>&nbsp;    }
<i>2495</i>&nbsp;
<i>2496</i>&nbsp;    /*
<b class="nc"><i>2497</i>&nbsp;     * A lambda expression can only be attributed when a target-type is available.</b>
<b class="nc"><i>2498</i>&nbsp;     * In addition, if the target-type is that of a functional interface whose</b>
<i>2499</i>&nbsp;     * descriptor contains inference variables in argument position the lambda expression
<i>2500</i>&nbsp;     * is &#39;stuck&#39; (see DeferredAttr).
<i>2501</i>&nbsp;     */
<i>2502</i>&nbsp;    @Override
<b class="nc"><i>2503</i>&nbsp;    public void visitLambda(final JCLambda that) {</b>
<i>2504</i>&nbsp;        if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
<b class="nc"><i>2505</i>&nbsp;            if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {</b>
<b class="nc"><i>2506</i>&nbsp;                //lambda only allowed in assignment or method invocation/cast context</b>
<b class="nc"><i>2507</i>&nbsp;                log.error(that.pos(), Errors.UnexpectedLambda);</b>
<b class="nc"><i>2508</i>&nbsp;            }</b>
<b class="nc"><i>2509</i>&nbsp;            result = that.type = types.createErrorType(pt());</b>
<b class="nc"><i>2510</i>&nbsp;            return;</b>
<b class="nc"><i>2511</i>&nbsp;        }</b>
<b class="nc"><i>2512</i>&nbsp;        //create an environment for attribution of the lambda expression</b>
<b class="nc"><i>2513</i>&nbsp;        final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);</b>
<i>2514</i>&nbsp;        boolean needsRecovery =
<b class="nc"><i>2515</i>&nbsp;                resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;</b>
<b class="nc"><i>2516</i>&nbsp;        try {</b>
<i>2517</i>&nbsp;            if (needsRecovery &amp;&amp; isSerializable(pt())) {
<b class="nc"><i>2518</i>&nbsp;                localEnv.info.isSerializable = true;</b>
<i>2519</i>&nbsp;                localEnv.info.isLambda = true;
<b class="nc"><i>2520</i>&nbsp;            }</b>
<i>2521</i>&nbsp;            List&lt;Type&gt; explicitParamTypes = null;
<i>2522</i>&nbsp;            if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
<i>2523</i>&nbsp;                //attribute lambda parameters
<i>2524</i>&nbsp;                attribStats(that.params, localEnv);
<b class="nc"><i>2525</i>&nbsp;                explicitParamTypes = TreeInfo.types(that.params);</b>
<i>2526</i>&nbsp;            }
<i>2527</i>&nbsp;
<i>2528</i>&nbsp;            TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
<i>2529</i>&nbsp;            Type currentTarget = targetInfo.target;
<b class="nc"><i>2530</i>&nbsp;            Type lambdaType = targetInfo.descriptor;</b>
<b class="nc"><i>2531</i>&nbsp;</b>
<i>2532</i>&nbsp;            if (currentTarget.isErroneous()) {
<i>2533</i>&nbsp;                result = that.type = currentTarget;
<b class="nc"><i>2534</i>&nbsp;                return;</b>
<i>2535</i>&nbsp;            }
<i>2536</i>&nbsp;
<i>2537</i>&nbsp;            setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
<b class="nc"><i>2538</i>&nbsp;</b>
<b class="nc"><i>2539</i>&nbsp;            if (lambdaType.hasTag(FORALL)) {</b>
<b class="nc"><i>2540</i>&nbsp;                //lambda expression target desc cannot be a generic method</b>
<i>2541</i>&nbsp;                Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
<i>2542</i>&nbsp;                                                                    kindName(currentTarget.tsym),
<i>2543</i>&nbsp;                                                                    currentTarget.tsym);
<i>2544</i>&nbsp;                resultInfo.checkContext.report(that, diags.fragment(msg));
<i>2545</i>&nbsp;                result = that.type = types.createErrorType(pt());
<i>2546</i>&nbsp;                return;
<i>2547</i>&nbsp;            }
<i>2548</i>&nbsp;
<i>2549</i>&nbsp;            if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
<i>2550</i>&nbsp;                //add param type info in the AST
<i>2551</i>&nbsp;                List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
<b class="nc"><i>2552</i>&nbsp;                List&lt;JCVariableDecl&gt; params = that.params;</b>
<b class="nc"><i>2553</i>&nbsp;</b>
<i>2554</i>&nbsp;                boolean arityMismatch = false;
<i>2555</i>&nbsp;
<i>2556</i>&nbsp;                while (params.nonEmpty()) {
<i>2557</i>&nbsp;                    if (actuals.isEmpty()) {
<i>2558</i>&nbsp;                        //not enough actuals to perform lambda parameter inference
<b class="nc"><i>2559</i>&nbsp;                        arityMismatch = true;</b>
<i>2560</i>&nbsp;                    }
<i>2561</i>&nbsp;                    //reset previously set info
<i>2562</i>&nbsp;                    Type argType = arityMismatch ?
<i>2563</i>&nbsp;                            syms.errType :
<b class="nc"><i>2564</i>&nbsp;                            actuals.head;</b>
<i>2565</i>&nbsp;                    if (params.head.isImplicitlyTyped()) {
<i>2566</i>&nbsp;                        setSyntheticVariableType(params.head, argType);
<i>2567</i>&nbsp;                    }
<i>2568</i>&nbsp;                    params.head.sym = null;
<i>2569</i>&nbsp;                    actuals = actuals.isEmpty() ?
<i>2570</i>&nbsp;                            actuals :
<i>2571</i>&nbsp;                            actuals.tail;
<b class="nc"><i>2572</i>&nbsp;                    params = params.tail;</b>
<b class="nc"><i>2573</i>&nbsp;                }</b>
<b class="nc"><i>2574</i>&nbsp;</b>
<i>2575</i>&nbsp;                //attribute lambda parameters
<i>2576</i>&nbsp;                attribStats(that.params, localEnv);
<i>2577</i>&nbsp;
<i>2578</i>&nbsp;                if (arityMismatch) {
<i>2579</i>&nbsp;                    resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
<b class="nc"><i>2580</i>&nbsp;                        result = that.type = types.createErrorType(currentTarget);</b>
<b class="nc"><i>2581</i>&nbsp;                        return;</b>
<i>2582</i>&nbsp;                }
<i>2583</i>&nbsp;            }
<i>2584</i>&nbsp;
<i>2585</i>&nbsp;            //from this point on, no recovery is needed; if we are in assignment context
<i>2586</i>&nbsp;            //we will be able to attribute the whole lambda body, regardless of errors;
<i>2587</i>&nbsp;            //if we are in a &#39;check&#39; method context, and the lambda is not compatible
<i>2588</i>&nbsp;            //with the target-type, it will be recovered anyway in Attr.checkId
<i>2589</i>&nbsp;            needsRecovery = false;
<i>2590</i>&nbsp;
<i>2591</i>&nbsp;            ResultInfo bodyResultInfo = localEnv.info.returnResult =
<b class="nc"><i>2592</i>&nbsp;                    lambdaBodyResult(that, lambdaType, resultInfo);</b>
<i>2593</i>&nbsp;
<i>2594</i>&nbsp;            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
<i>2595</i>&nbsp;                attribTree(that.getBody(), localEnv, bodyResultInfo);
<i>2596</i>&nbsp;            } else {
<i>2597</i>&nbsp;                JCBlock body = (JCBlock)that.body;
<b class="nc"><i>2598</i>&nbsp;                attribStats(body.stats, localEnv);</b>
<b class="nc"><i>2599</i>&nbsp;            }</b>
<b class="nc"><i>2600</i>&nbsp;</b>
<b class="nc"><i>2601</i>&nbsp;            result = check(that, currentTarget, KindSelector.VAL, resultInfo);</b>
<i>2602</i>&nbsp;
<i>2603</i>&nbsp;            boolean isSpeculativeRound =
<b class="nc"><i>2604</i>&nbsp;                    resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;</b>
<b class="nc"><i>2605</i>&nbsp;</b>
<b class="nc"><i>2606</i>&nbsp;            preFlow(that);</b>
<i>2607</i>&nbsp;            flow.analyzeLambda(env, that, make, isSpeculativeRound);
<i>2608</i>&nbsp;
<i>2609</i>&nbsp;            that.type = currentTarget; //avoids recovery at this stage
<i>2610</i>&nbsp;            checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
<i>2611</i>&nbsp;
<i>2612</i>&nbsp;            if (!isSpeculativeRound) {
<i>2613</i>&nbsp;                //add thrown types as bounds to the thrown types free variables if needed:
<i>2614</i>&nbsp;                if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
<i>2615</i>&nbsp;                    List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
<i>2616</i>&nbsp;                    if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
<i>2617</i>&nbsp;                        log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
<b class="nc"><i>2618</i>&nbsp;                    }</b>
<i>2619</i>&nbsp;                }
<i>2620</i>&nbsp;
<b class="nc"><i>2621</i>&nbsp;                checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);</b>
<i>2622</i>&nbsp;            }
<i>2623</i>&nbsp;            result = check(that, currentTarget, KindSelector.VAL, resultInfo);
<i>2624</i>&nbsp;        } catch (Types.FunctionDescriptorLookupError ex) {
<i>2625</i>&nbsp;            JCDiagnostic cause = ex.getDiagnostic();
<i>2626</i>&nbsp;            resultInfo.checkContext.report(that, cause);
<i>2627</i>&nbsp;            result = that.type = types.createErrorType(pt());
<i>2628</i>&nbsp;            return;
<i>2629</i>&nbsp;        } catch (Throwable t) {
<i>2630</i>&nbsp;            //when an unexpected exception happens, avoid attempts to attribute the same tree again
<i>2631</i>&nbsp;            //as that would likely cause the same exception again.
<i>2632</i>&nbsp;            needsRecovery = false;
<i>2633</i>&nbsp;            throw t;
<i>2634</i>&nbsp;        } finally {
<i>2635</i>&nbsp;            localEnv.info.scope.leave();
<b class="nc"><i>2636</i>&nbsp;            if (needsRecovery) {</b>
<b class="nc"><i>2637</i>&nbsp;                attribTree(that, env, recoveryInfo);</b>
<i>2638</i>&nbsp;            }
<b class="nc"><i>2639</i>&nbsp;        }</b>
<b class="nc"><i>2640</i>&nbsp;    }</b>
<i>2641</i>&nbsp;    //where
<i>2642</i>&nbsp;        class TargetInfo {
<i>2643</i>&nbsp;            Type target;
<i>2644</i>&nbsp;            Type descriptor;
<b class="nc"><i>2645</i>&nbsp;</b>
<b class="nc"><i>2646</i>&nbsp;            public TargetInfo(Type target, Type descriptor) {</b>
<b class="nc"><i>2647</i>&nbsp;                this.target = target;</b>
<b class="nc"><i>2648</i>&nbsp;                this.descriptor = descriptor;</b>
<i>2649</i>&nbsp;            }
<i>2650</i>&nbsp;        }
<i>2651</i>&nbsp;
<i>2652</i>&nbsp;        TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
<i>2653</i>&nbsp;            Type lambdaType;
<b class="nc"><i>2654</i>&nbsp;            Type currentTarget = resultInfo.pt;</b>
<b class="nc"><i>2655</i>&nbsp;            if (resultInfo.pt != Type.recoveryType) {</b>
<b class="nc"><i>2656</i>&nbsp;                /* We need to adjust the target. If the target is an</b>
<b class="nc"><i>2657</i>&nbsp;                 * intersection type, for example: SAM &amp; I1 &amp; I2 ...</b>
<b class="nc"><i>2658</i>&nbsp;                 * the target will be updated to SAM</b>
<i>2659</i>&nbsp;                 */
<b class="nc"><i>2660</i>&nbsp;                currentTarget = targetChecker.visit(currentTarget, that);</b>
<b class="nc"><i>2661</i>&nbsp;                if (!currentTarget.isIntersection()) {</b>
<i>2662</i>&nbsp;                    if (explicitParamTypes != null) {
<b class="nc"><i>2663</i>&nbsp;                        currentTarget = infer.instantiateFunctionalInterface(that,</b>
<i>2664</i>&nbsp;                                currentTarget, explicitParamTypes, resultInfo.checkContext);
<b class="nc"><i>2665</i>&nbsp;                    }</b>
<b class="nc"><i>2666</i>&nbsp;                    currentTarget = types.removeWildcards(currentTarget);</b>
<i>2667</i>&nbsp;                    lambdaType = types.findDescriptorType(currentTarget);
<b class="nc"><i>2668</i>&nbsp;                } else {</b>
<i>2669</i>&nbsp;                    IntersectionClassType ict = (IntersectionClassType)currentTarget;
<i>2670</i>&nbsp;                    ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
<i>2671</i>&nbsp;                    for (Type bound : ict.getExplicitComponents()) {
<i>2672</i>&nbsp;                        if (explicitParamTypes != null) {
<b class="nc"><i>2673</i>&nbsp;                            try {</b>
<b class="nc"><i>2674</i>&nbsp;                                bound = infer.instantiateFunctionalInterface(that,</b>
<i>2675</i>&nbsp;                                        bound, explicitParamTypes, resultInfo.checkContext);
<b class="nc"><i>2676</i>&nbsp;                            } catch (FunctionDescriptorLookupError t) {</b>
<i>2677</i>&nbsp;                                // do nothing
<b class="nc"><i>2678</i>&nbsp;                            }</b>
<i>2679</i>&nbsp;                        }
<i>2680</i>&nbsp;                        bound = types.removeWildcards(bound);
<b class="nc"><i>2681</i>&nbsp;                        components.add(bound);</b>
<i>2682</i>&nbsp;                    }
<i>2683</i>&nbsp;                    currentTarget = types.makeIntersectionType(components.toList());
<i>2684</i>&nbsp;                    currentTarget.tsym.flags_field |= INTERFACE;
<b class="nc"><i>2685</i>&nbsp;                    lambdaType = types.findDescriptorType(currentTarget);</b>
<i>2686</i>&nbsp;                }
<b class="nc"><i>2687</i>&nbsp;</b>
<b class="nc"><i>2688</i>&nbsp;            } else {</b>
<b class="nc"><i>2689</i>&nbsp;                currentTarget = Type.recoveryType;</b>
<b class="nc"><i>2690</i>&nbsp;                lambdaType = fallbackDescriptorType(that);</b>
<i>2691</i>&nbsp;            }
<b class="nc"><i>2692</i>&nbsp;            if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {</b>
<b class="nc"><i>2693</i>&nbsp;                //lambda expression target desc cannot be a generic method</b>
<b class="nc"><i>2694</i>&nbsp;                Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,</b>
<i>2695</i>&nbsp;                                                                    kindName(currentTarget.tsym),
<i>2696</i>&nbsp;                                                                    currentTarget.tsym);
<i>2697</i>&nbsp;                resultInfo.checkContext.report(that, diags.fragment(msg));
<b class="nc"><i>2698</i>&nbsp;                currentTarget = types.createErrorType(pt());</b>
<i>2699</i>&nbsp;            }
<i>2700</i>&nbsp;            return new TargetInfo(currentTarget, lambdaType);
<b class="nc"><i>2701</i>&nbsp;        }</b>
<i>2702</i>&nbsp;
<i>2703</i>&nbsp;        void preFlow(JCLambda tree) {
<i>2704</i>&nbsp;            new PostAttrAnalyzer() {
<b class="nc"><i>2705</i>&nbsp;                @Override</b>
<i>2706</i>&nbsp;                public void scan(JCTree tree) {
<i>2707</i>&nbsp;                    if (tree == null ||
<i>2708</i>&nbsp;                            (tree.type != null &amp;&amp;
<b class="nc"><i>2709</i>&nbsp;                            tree.type == Type.stuckType)) {</b>
<i>2710</i>&nbsp;                        //don&#39;t touch stuck expressions!
<i>2711</i>&nbsp;                        return;
<i>2712</i>&nbsp;                    }
<b class="nc"><i>2713</i>&nbsp;                    super.scan(tree);</b>
<b class="nc"><i>2714</i>&nbsp;                }</b>
<b class="nc"><i>2715</i>&nbsp;            }.scan(tree);</b>
<i>2716</i>&nbsp;        }
<i>2717</i>&nbsp;
<i>2718</i>&nbsp;        Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
<b class="nc"><i>2719</i>&nbsp;</b>
<b class="nc"><i>2720</i>&nbsp;            @Override</b>
<b class="nc"><i>2721</i>&nbsp;            public Type visitClassType(ClassType t, DiagnosticPosition pos) {</b>
<b class="nc"><i>2722</i>&nbsp;                return t.isIntersection() ?</b>
<b class="nc"><i>2723</i>&nbsp;                        visitIntersectionClassType((IntersectionClassType)t, pos) : t;</b>
<b class="nc"><i>2724</i>&nbsp;            }</b>
<b class="nc"><i>2725</i>&nbsp;</b>
<i>2726</i>&nbsp;            public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
<b class="nc"><i>2727</i>&nbsp;                types.findDescriptorSymbol(makeNotionalInterface(ict, pos));</b>
<b class="nc"><i>2728</i>&nbsp;                return ict;</b>
<i>2729</i>&nbsp;            }
<i>2730</i>&nbsp;
<b class="nc"><i>2731</i>&nbsp;            private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {</b>
<b class="nc"><i>2732</i>&nbsp;                ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2733</i>&nbsp;                ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();</b>
<i>2734</i>&nbsp;                for (Type i : ict.interfaces_field) {
<b class="nc"><i>2735</i>&nbsp;                    if (i.isParameterized()) {</b>
<b class="nc"><i>2736</i>&nbsp;                        targs.appendList(i.tsym.type.allparams());</b>
<i>2737</i>&nbsp;                    }
<i>2738</i>&nbsp;                    supertypes.append(i.tsym.type);
<b class="nc"><i>2739</i>&nbsp;                }</b>
<b class="nc"><i>2740</i>&nbsp;                IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());</b>
<i>2741</i>&nbsp;                notionalIntf.allparams_field = targs.toList();
<b class="nc"><i>2742</i>&nbsp;                notionalIntf.tsym.flags_field |= INTERFACE;</b>
<i>2743</i>&nbsp;                return notionalIntf.tsym;
<b class="nc"><i>2744</i>&nbsp;            }</b>
<b class="nc"><i>2745</i>&nbsp;        };</b>
<i>2746</i>&nbsp;
<b class="nc"><i>2747</i>&nbsp;        private Type fallbackDescriptorType(JCExpression tree) {</b>
<b class="nc"><i>2748</i>&nbsp;            switch (tree.getTag()) {</b>
<i>2749</i>&nbsp;                case LAMBDA:
<b class="nc"><i>2750</i>&nbsp;                    JCLambda lambda = (JCLambda)tree;</b>
<b class="nc"><i>2751</i>&nbsp;                    List&lt;Type&gt; argtypes = List.nil();</b>
<i>2752</i>&nbsp;                    for (JCVariableDecl param : lambda.params) {
<b class="nc"><i>2753</i>&nbsp;                        argtypes = param.vartype != null ?</b>
<i>2754</i>&nbsp;                                argtypes.append(param.vartype.type) :
<b class="nc"><i>2755</i>&nbsp;                                argtypes.append(syms.errType);</b>
<i>2756</i>&nbsp;                    }
<b class="nc"><i>2757</i>&nbsp;                    return new MethodType(argtypes, Type.recoveryType,</b>
<b class="nc"><i>2758</i>&nbsp;                            List.of(syms.throwableType), syms.methodClass);</b>
<i>2759</i>&nbsp;                case REFERENCE:
<i>2760</i>&nbsp;                    return new MethodType(List.nil(), Type.recoveryType,
<i>2761</i>&nbsp;                            List.of(syms.throwableType), syms.methodClass);
<i>2762</i>&nbsp;                default:
<i>2763</i>&nbsp;                    Assert.error(&quot;Cannot get here!&quot;);
<i>2764</i>&nbsp;            }
<i>2765</i>&nbsp;            return null;
<b class="nc"><i>2766</i>&nbsp;        }</b>
<b class="nc"><i>2767</i>&nbsp;</b>
<i>2768</i>&nbsp;        private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
<b class="nc"><i>2769</i>&nbsp;                final InferenceContext inferenceContext, final Type... ts) {</b>
<b class="nc"><i>2770</i>&nbsp;            checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));</b>
<i>2771</i>&nbsp;        }
<i>2772</i>&nbsp;
<b class="nc"><i>2773</i>&nbsp;        private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,</b>
<i>2774</i>&nbsp;                final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
<i>2775</i>&nbsp;            if (inferenceContext.free(ts)) {
<b class="nc"><i>2776</i>&nbsp;                inferenceContext.addFreeTypeListener(ts,</b>
<i>2777</i>&nbsp;                        solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
<i>2778</i>&nbsp;            } else {
<b class="nc"><i>2779</i>&nbsp;                for (Type t : ts) {</b>
<b class="nc"><i>2780</i>&nbsp;                    rs.checkAccessibleType(env, t);</b>
<i>2781</i>&nbsp;                }
<b class="nc"><i>2782</i>&nbsp;            }</b>
<i>2783</i>&nbsp;        }
<i>2784</i>&nbsp;
<b class="nc"><i>2785</i>&nbsp;        /**</b>
<i>2786</i>&nbsp;         * Lambda/method reference have a special check context that ensures
<i>2787</i>&nbsp;         * that i.e. a lambda return type is compatible with the expected
<b class="nc"><i>2788</i>&nbsp;         * type according to both the inherited context and the assignment</b>
<b class="nc"><i>2789</i>&nbsp;         * context.</b>
<i>2790</i>&nbsp;         */
<b class="nc"><i>2791</i>&nbsp;        class FunctionalReturnContext extends Check.NestedCheckContext {</b>
<i>2792</i>&nbsp;
<b class="nc"><i>2793</i>&nbsp;            FunctionalReturnContext(CheckContext enclosingContext) {</b>
<i>2794</i>&nbsp;                super(enclosingContext);
<i>2795</i>&nbsp;            }
<i>2796</i>&nbsp;
<i>2797</i>&nbsp;            @Override
<b class="nc"><i>2798</i>&nbsp;            public boolean compatible(Type found, Type req, Warner warn) {</b>
<b class="nc"><i>2799</i>&nbsp;                //return type must be compatible in both current context and assignment context</b>
<b class="nc"><i>2800</i>&nbsp;                return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);</b>
<i>2801</i>&nbsp;            }
<b class="nc"><i>2802</i>&nbsp;</b>
<i>2803</i>&nbsp;            @Override
<b class="nc"><i>2804</i>&nbsp;            public void report(DiagnosticPosition pos, JCDiagnostic details) {</b>
<i>2805</i>&nbsp;                enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
<i>2806</i>&nbsp;            }
<i>2807</i>&nbsp;        }
<b class="nc"><i>2808</i>&nbsp;</b>
<i>2809</i>&nbsp;        class ExpressionLambdaReturnContext extends FunctionalReturnContext {
<b class="nc"><i>2810</i>&nbsp;</b>
<b class="nc"><i>2811</i>&nbsp;            JCExpression expr;</b>
<b class="nc"><i>2812</i>&nbsp;            boolean expStmtExpected;</b>
<b class="nc"><i>2813</i>&nbsp;</b>
<b class="nc"><i>2814</i>&nbsp;            ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {</b>
<i>2815</i>&nbsp;                super(enclosingContext);
<i>2816</i>&nbsp;                this.expr = expr;
<b class="nc"><i>2817</i>&nbsp;            }</b>
<b class="nc"><i>2818</i>&nbsp;</b>
<i>2819</i>&nbsp;            @Override
<b class="nc"><i>2820</i>&nbsp;            public void report(DiagnosticPosition pos, JCDiagnostic details) {</b>
<b class="nc"><i>2821</i>&nbsp;                if (expStmtExpected) {</b>
<b class="nc"><i>2822</i>&nbsp;                    enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));</b>
<i>2823</i>&nbsp;                } else {
<i>2824</i>&nbsp;                    super.report(pos, details);
<i>2825</i>&nbsp;                }
<b class="nc"><i>2826</i>&nbsp;            }</b>
<b class="nc"><i>2827</i>&nbsp;</b>
<i>2828</i>&nbsp;            @Override
<b class="nc"><i>2829</i>&nbsp;            public boolean compatible(Type found, Type req, Warner warn) {</b>
<b class="nc"><i>2830</i>&nbsp;                //a void return is compatible with an expression statement lambda</b>
<b class="nc"><i>2831</i>&nbsp;                if (req.hasTag(VOID)) {</b>
<i>2832</i>&nbsp;                    expStmtExpected = true;
<i>2833</i>&nbsp;                    return TreeInfo.isExpressionStatement(expr);
<i>2834</i>&nbsp;                } else {
<b class="nc"><i>2835</i>&nbsp;                    return super.compatible(found, req, warn);</b>
<i>2836</i>&nbsp;                }
<b class="nc"><i>2837</i>&nbsp;            }</b>
<i>2838</i>&nbsp;        }
<i>2839</i>&nbsp;
<b class="nc"><i>2840</i>&nbsp;        ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {</b>
<b class="nc"><i>2841</i>&nbsp;            FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?</b>
<i>2842</i>&nbsp;                    new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
<i>2843</i>&nbsp;                    new FunctionalReturnContext(resultInfo.checkContext);
<i>2844</i>&nbsp;
<b class="nc"><i>2845</i>&nbsp;            return descriptor.getReturnType() == Type.recoveryType ?</b>
<b class="nc"><i>2846</i>&nbsp;                    recoveryInfo :</b>
<b class="nc"><i>2847</i>&nbsp;                    new ResultInfo(KindSelector.VAL,</b>
<b class="nc"><i>2848</i>&nbsp;                            descriptor.getReturnType(), funcContext);</b>
<i>2849</i>&nbsp;        }
<i>2850</i>&nbsp;
<b class="nc"><i>2851</i>&nbsp;        /**</b>
<i>2852</i>&nbsp;        * Lambda compatibility. Check that given return types, thrown types, parameter types
<b class="nc"><i>2853</i>&nbsp;        * are compatible with the expected functional interface descriptor. This means that:</b>
<b class="nc"><i>2854</i>&nbsp;        * (i) parameter types must be identical to those of the target descriptor; (ii) return</b>
<i>2855</i>&nbsp;        * types must be compatible with the return type of the expected descriptor.
<b class="nc"><i>2856</i>&nbsp;        */</b>
<i>2857</i>&nbsp;        void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
<i>2858</i>&nbsp;            Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
<i>2859</i>&nbsp;
<b class="nc"><i>2860</i>&nbsp;            //return values have already been checked - but if lambda has no return</b>
<i>2861</i>&nbsp;            //values, we must ensure that void/value compatibility is correct;
<i>2862</i>&nbsp;            //this amounts at checking that, if a lambda body can complete normally,
<i>2863</i>&nbsp;            //the descriptor&#39;s return type must be void
<b class="nc"><i>2864</i>&nbsp;            if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;</b>
<b class="nc"><i>2865</i>&nbsp;                    !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {</b>
<b class="nc"><i>2866</i>&nbsp;                Fragment msg =</b>
<i>2867</i>&nbsp;                        Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
<i>2868</i>&nbsp;                checkContext.report(tree,
<i>2869</i>&nbsp;                                    diags.fragment(msg));
<i>2870</i>&nbsp;            }
<b class="nc"><i>2871</i>&nbsp;</b>
<b class="nc"><i>2872</i>&nbsp;            List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());</b>
<i>2873</i>&nbsp;            if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
<b class="nc"><i>2874</i>&nbsp;                checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));</b>
<b class="nc"><i>2875</i>&nbsp;            }</b>
<b class="nc"><i>2876</i>&nbsp;        }</b>
<b class="nc"><i>2877</i>&nbsp;</b>
<i>2878</i>&nbsp;        /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
<b class="nc"><i>2879</i>&nbsp;         * static field and that lambda has type annotations, these annotations will</b>
<b class="nc"><i>2880</i>&nbsp;         * also be stored at these fake clinit methods.</b>
<b class="nc"><i>2881</i>&nbsp;         *</b>
<b class="nc"><i>2882</i>&nbsp;         * LambdaToMethod also use fake clinit methods so they can be reused.</b>
<b class="nc"><i>2883</i>&nbsp;         * Also as LTM is a phase subsequent to attribution, the methods from</b>
<i>2884</i>&nbsp;         * clinits can be safely removed by LTM to save memory.
<b class="nc"><i>2885</i>&nbsp;         */</b>
<i>2886</i>&nbsp;        private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
<i>2887</i>&nbsp;
<i>2888</i>&nbsp;        public MethodSymbol removeClinit(ClassSymbol sym) {
<i>2889</i>&nbsp;            return clinits.remove(sym);
<b class="nc"><i>2890</i>&nbsp;        }</b>
<i>2891</i>&nbsp;
<i>2892</i>&nbsp;        /* This method returns an environment to be used to attribute a lambda
<i>2893</i>&nbsp;         * expression.
<i>2894</i>&nbsp;         *
<i>2895</i>&nbsp;         * The owner of this environment is a method symbol. If the current owner
<b class="nc"><i>2896</i>&nbsp;         * is not a method, for example if the lambda is used to initialize</b>
<i>2897</i>&nbsp;         * a field, then if the field is:
<i>2898</i>&nbsp;         *
<b class="nc"><i>2899</i>&nbsp;         * - an instance field, we use the first constructor.</b>
<i>2900</i>&nbsp;         * - a static field, we create a fake clinit method.
<b class="nc"><i>2901</i>&nbsp;         */</b>
<b class="nc"><i>2902</i>&nbsp;        public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>2903</i>&nbsp;            Env&lt;AttrContext&gt; lambdaEnv;</b>
<i>2904</i>&nbsp;            Symbol owner = env.info.scope.owner;
<i>2905</i>&nbsp;            if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
<b class="nc"><i>2906</i>&nbsp;                //field initializer</b>
<i>2907</i>&nbsp;                ClassSymbol enclClass = owner.enclClass();
<i>2908</i>&nbsp;                Symbol newScopeOwner = env.info.scope.owner;
<b class="nc"><i>2909</i>&nbsp;                /* if the field isn&#39;t static, then we can get the first constructor</b>
<i>2910</i>&nbsp;                 * and use it as the owner of the environment. This is what
<b class="nc"><i>2911</i>&nbsp;                 * LTM code is doing to look for type annotations so we are fine.</b>
<b class="nc"><i>2912</i>&nbsp;                 */</b>
<i>2913</i>&nbsp;                if ((owner.flags() &amp; STATIC) == 0) {
<i>2914</i>&nbsp;                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
<b class="nc"><i>2915</i>&nbsp;                        newScopeOwner = s;</b>
<b class="nc"><i>2916</i>&nbsp;                        break;</b>
<b class="nc"><i>2917</i>&nbsp;                    }</b>
<b class="nc"><i>2918</i>&nbsp;                } else {</b>
<i>2919</i>&nbsp;                    /* if the field is static then we need to create a fake clinit
<i>2920</i>&nbsp;                     * method, this method can later be reused by LTM.
<i>2921</i>&nbsp;                     */
<b class="nc"><i>2922</i>&nbsp;                    MethodSymbol clinit = clinits.get(enclClass);</b>
<b class="nc"><i>2923</i>&nbsp;                    if (clinit == null) {</b>
<b class="nc"><i>2924</i>&nbsp;                        Type clinitType = new MethodType(List.nil(),</b>
<i>2925</i>&nbsp;                                syms.voidType, List.nil(), syms.methodClass);
<i>2926</i>&nbsp;                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
<b class="nc"><i>2927</i>&nbsp;                                names.clinit, clinitType, enclClass);</b>
<b class="nc"><i>2928</i>&nbsp;                        clinit.params = List.nil();</b>
<b class="nc"><i>2929</i>&nbsp;                        clinits.put(enclClass, clinit);</b>
<b class="nc"><i>2930</i>&nbsp;                    }</b>
<i>2931</i>&nbsp;                    newScopeOwner = clinit;
<i>2932</i>&nbsp;                }
<i>2933</i>&nbsp;                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
<i>2934</i>&nbsp;            } else {
<i>2935</i>&nbsp;                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
<i>2936</i>&nbsp;            }
<i>2937</i>&nbsp;            return lambdaEnv;
<i>2938</i>&nbsp;        }
<i>2939</i>&nbsp;
<i>2940</i>&nbsp;    @Override
<i>2941</i>&nbsp;    public void visitReference(final JCMemberReference that) {
<b class="nc"><i>2942</i>&nbsp;        if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {</b>
<b class="nc"><i>2943</i>&nbsp;            if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {</b>
<i>2944</i>&nbsp;                //method reference only allowed in assignment or method invocation/cast context
<b class="nc"><i>2945</i>&nbsp;                log.error(that.pos(), Errors.UnexpectedMref);</b>
<b class="nc"><i>2946</i>&nbsp;            }</b>
<i>2947</i>&nbsp;            result = that.type = types.createErrorType(pt());
<i>2948</i>&nbsp;            return;
<i>2949</i>&nbsp;        }
<b class="nc"><i>2950</i>&nbsp;        final Env&lt;AttrContext&gt; localEnv = env.dup(that);</b>
<b class="nc"><i>2951</i>&nbsp;        try {</b>
<b class="nc"><i>2952</i>&nbsp;            //attribute member reference qualifier - if this is a constructor</b>
<b class="nc"><i>2953</i>&nbsp;            //reference, the expected kind must be a type</b>
<b class="nc"><i>2954</i>&nbsp;            Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));</b>
<b class="nc"><i>2955</i>&nbsp;</b>
<b class="nc"><i>2956</i>&nbsp;            if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {</b>
<i>2957</i>&nbsp;                exprType = chk.checkConstructorRefType(that.expr, exprType);
<b class="nc"><i>2958</i>&nbsp;                if (!exprType.isErroneous() &amp;&amp;</b>
<i>2959</i>&nbsp;                    exprType.isRaw() &amp;&amp;
<b class="nc"><i>2960</i>&nbsp;                    that.typeargs != null) {</b>
<i>2961</i>&nbsp;                    log.error(that.expr.pos(),
<i>2962</i>&nbsp;                              Errors.InvalidMref(Kinds.kindName(that.getMode()),
<b class="nc"><i>2963</i>&nbsp;                                                 Fragments.MrefInferAndExplicitParams));</b>
<b class="nc"><i>2964</i>&nbsp;                    exprType = types.createErrorType(exprType);</b>
<i>2965</i>&nbsp;                }
<i>2966</i>&nbsp;            }
<i>2967</i>&nbsp;
<i>2968</i>&nbsp;            if (exprType.isErroneous()) {
<i>2969</i>&nbsp;                //if the qualifier expression contains problems,
<i>2970</i>&nbsp;                //give up attribution of method reference
<i>2971</i>&nbsp;                result = that.type = exprType;
<b class="nc"><i>2972</i>&nbsp;                return;</b>
<b class="nc"><i>2973</i>&nbsp;            }</b>
<b class="nc"><i>2974</i>&nbsp;</b>
<b class="nc"><i>2975</i>&nbsp;            if (TreeInfo.isStaticSelector(that.expr, names)) {</b>
<i>2976</i>&nbsp;                //if the qualifier is a type, validate it; raw warning check is
<b class="nc"><i>2977</i>&nbsp;                //omitted as we don&#39;t know at this stage as to whether this is a</b>
<b class="nc"><i>2978</i>&nbsp;                //raw selector (because of inference)</b>
<b class="nc"><i>2979</i>&nbsp;                chk.validate(that.expr, env, false);</b>
<b class="nc"><i>2980</i>&nbsp;            } else {</b>
<i>2981</i>&nbsp;                Symbol lhsSym = TreeInfo.symbol(that.expr);
<i>2982</i>&nbsp;                localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
<i>2983</i>&nbsp;            }
<i>2984</i>&nbsp;            //attrib type-arguments
<i>2985</i>&nbsp;            List&lt;Type&gt; typeargtypes = List.nil();
<b class="nc"><i>2986</i>&nbsp;            if (that.typeargs != null) {</b>
<b class="nc"><i>2987</i>&nbsp;                typeargtypes = attribTypes(that.typeargs, localEnv);</b>
<b class="nc"><i>2988</i>&nbsp;            }</b>
<b class="nc"><i>2989</i>&nbsp;</b>
<b class="nc"><i>2990</i>&nbsp;            boolean isTargetSerializable =</b>
<i>2991</i>&nbsp;                    resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
<i>2992</i>&nbsp;                    isSerializable(pt());
<i>2993</i>&nbsp;            TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
<b class="nc"><i>2994</i>&nbsp;            Type currentTarget = targetInfo.target;</b>
<b class="nc"><i>2995</i>&nbsp;            Type desc = targetInfo.descriptor;</b>
<b class="nc"><i>2996</i>&nbsp;</b>
<b class="nc"><i>2997</i>&nbsp;            setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);</b>
<i>2998</i>&nbsp;            List&lt;Type&gt; argtypes = desc.getParameterTypes();
<i>2999</i>&nbsp;            Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
<i>3000</i>&nbsp;
<i>3001</i>&nbsp;            if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
<b class="nc"><i>3002</i>&nbsp;                referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());</b>
<b class="nc"><i>3003</i>&nbsp;            }</b>
<i>3004</i>&nbsp;
<b class="nc"><i>3005</i>&nbsp;            Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;</b>
<b class="nc"><i>3006</i>&nbsp;            List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();</b>
<i>3007</i>&nbsp;            try {
<i>3008</i>&nbsp;                refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
<b class="nc"><i>3009</i>&nbsp;                        that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,</b>
<b class="nc"><i>3010</i>&nbsp;                        resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);</b>
<b class="nc"><i>3011</i>&nbsp;            } finally {</b>
<b class="nc"><i>3012</i>&nbsp;                resultInfo.checkContext.inferenceContext().rollback(saved_undet);</b>
<i>3013</i>&nbsp;            }
<b class="nc"><i>3014</i>&nbsp;</b>
<i>3015</i>&nbsp;            Symbol refSym = refResult.fst;
<i>3016</i>&nbsp;            Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
<b class="nc"><i>3017</i>&nbsp;</b>
<b class="nc"><i>3018</i>&nbsp;            /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing</b>
<b class="nc"><i>3019</i>&nbsp;             *  JDK-8075541</b>
<i>3020</i>&nbsp;             */
<i>3021</i>&nbsp;            if (refSym.kind != MTH) {
<b class="nc"><i>3022</i>&nbsp;                boolean targetError;</b>
<i>3023</i>&nbsp;                switch (refSym.kind) {
<i>3024</i>&nbsp;                    case ABSENT_MTH:
<i>3025</i>&nbsp;                    case MISSING_ENCL:
<i>3026</i>&nbsp;                        targetError = false;
<b class="nc"><i>3027</i>&nbsp;                        break;</b>
<b class="nc"><i>3028</i>&nbsp;                    case WRONG_MTH:</b>
<b class="nc"><i>3029</i>&nbsp;                    case WRONG_MTHS:</b>
<i>3030</i>&nbsp;                    case AMBIGUOUS:
<i>3031</i>&nbsp;                    case HIDDEN:
<b class="nc"><i>3032</i>&nbsp;                    case STATICERR:</b>
<b class="nc"><i>3033</i>&nbsp;                        targetError = true;</b>
<i>3034</i>&nbsp;                        break;
<b class="nc"><i>3035</i>&nbsp;                    default:</b>
<b class="nc"><i>3036</i>&nbsp;                        Assert.error(&quot;unexpected result kind &quot; + refSym.kind);</b>
<b class="nc"><i>3037</i>&nbsp;                        targetError = false;</b>
<b class="nc"><i>3038</i>&nbsp;                }</b>
<i>3039</i>&nbsp;
<b class="nc"><i>3040</i>&nbsp;                JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())</b>
<b class="nc"><i>3041</i>&nbsp;                        .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,</b>
<i>3042</i>&nbsp;                                that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
<i>3043</i>&nbsp;
<b class="nc"><i>3044</i>&nbsp;                JCDiagnostic diag = diags.create(log.currentSource(), that,</b>
<b class="nc"><i>3045</i>&nbsp;                        targetError ?</b>
<b class="nc"><i>3046</i>&nbsp;                            Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :</b>
<b class="nc"><i>3047</i>&nbsp;                            Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));</b>
<i>3048</i>&nbsp;
<i>3049</i>&nbsp;                if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
<i>3050</i>&nbsp;                    //a target error doesn&#39;t make sense during recovery stage
<b class="nc"><i>3051</i>&nbsp;                    //as we don&#39;t know what actual parameter types are</b>
<i>3052</i>&nbsp;                    result = that.type = currentTarget;
<i>3053</i>&nbsp;                    return;
<i>3054</i>&nbsp;                } else {
<i>3055</i>&nbsp;                    if (targetError) {
<b class="nc"><i>3056</i>&nbsp;                        resultInfo.checkContext.report(that, diag);</b>
<b class="nc"><i>3057</i>&nbsp;                    } else {</b>
<i>3058</i>&nbsp;                        log.report(diag);
<i>3059</i>&nbsp;                    }
<b class="nc"><i>3060</i>&nbsp;                    result = that.type = types.createErrorType(currentTarget);</b>
<b class="nc"><i>3061</i>&nbsp;                    return;</b>
<i>3062</i>&nbsp;                }
<b class="nc"><i>3063</i>&nbsp;            }</b>
<b class="nc"><i>3064</i>&nbsp;</b>
<b class="nc"><i>3065</i>&nbsp;            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;</b>
<b class="nc"><i>3066</i>&nbsp;            that.kind = lookupHelper.referenceKind(that.sym);</b>
<b class="nc"><i>3067</i>&nbsp;            that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());</b>
<i>3068</i>&nbsp;
<i>3069</i>&nbsp;            if (desc.getReturnType() == Type.recoveryType) {
<b class="nc"><i>3070</i>&nbsp;                // stop here</b>
<i>3071</i>&nbsp;                result = that.type = currentTarget;
<b class="nc"><i>3072</i>&nbsp;                return;</b>
<i>3073</i>&nbsp;            }
<i>3074</i>&nbsp;
<i>3075</i>&nbsp;            if (!env.info.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
<i>3076</i>&nbsp;                Type enclosingType = exprType.getEnclosingType();
<b class="nc"><i>3077</i>&nbsp;                if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {</b>
<b class="nc"><i>3078</i>&nbsp;                    // Check for the existence of an apropriate outer instance</b>
<b class="nc"><i>3079</i>&nbsp;                    rs.resolveImplicitThis(that.pos(), env, exprType);</b>
<b class="nc"><i>3080</i>&nbsp;                }</b>
<i>3081</i>&nbsp;            }
<i>3082</i>&nbsp;
<i>3083</i>&nbsp;            if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
<i>3084</i>&nbsp;
<i>3085</i>&nbsp;                if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
<i>3086</i>&nbsp;                        TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
<b class="nc"><i>3087</i>&nbsp;                        that.kind.isUnbound() &amp;&amp;</b>
<b class="nc"><i>3088</i>&nbsp;                        lookupHelper.site.isRaw()) {</b>
<b class="nc"><i>3089</i>&nbsp;                    chk.checkRaw(that.expr, localEnv);</b>
<b class="nc"><i>3090</i>&nbsp;                }</b>
<i>3091</i>&nbsp;
<i>3092</i>&nbsp;                if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
<i>3093</i>&nbsp;                        exprType.getTypeArguments().nonEmpty()) {
<b class="nc"><i>3094</i>&nbsp;                    //static ref with class type-args</b>
<i>3095</i>&nbsp;                    log.error(that.expr.pos(),
<b class="nc"><i>3096</i>&nbsp;                              Errors.InvalidMref(Kinds.kindName(that.getMode()),</b>
<i>3097</i>&nbsp;                                                 Fragments.StaticMrefWithTargs));
<i>3098</i>&nbsp;                    result = that.type = types.createErrorType(currentTarget);
<i>3099</i>&nbsp;                    return;
<b class="nc"><i>3100</i>&nbsp;                }</b>
<b class="nc"><i>3101</i>&nbsp;</b>
<i>3102</i>&nbsp;                if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
<i>3103</i>&nbsp;                    // Check that super-qualified symbols are not abstract (JLS)
<b class="nc"><i>3104</i>&nbsp;                    rs.checkNonAbstract(that.pos(), that.sym);</b>
<i>3105</i>&nbsp;                }
<i>3106</i>&nbsp;
<b class="nc"><i>3107</i>&nbsp;                if (isTargetSerializable) {</b>
<b class="nc"><i>3108</i>&nbsp;                    chk.checkAccessFromSerializableElement(that, true);</b>
<b class="nc"><i>3109</i>&nbsp;                }</b>
<i>3110</i>&nbsp;            }
<b class="nc"><i>3111</i>&nbsp;</b>
<i>3112</i>&nbsp;            ResultInfo checkInfo =
<i>3113</i>&nbsp;                    resultInfo.dup(newMethodTemplate(
<b class="nc"><i>3114</i>&nbsp;                        desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),</b>
<i>3115</i>&nbsp;                        that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
<i>3116</i>&nbsp;                        new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
<i>3117</i>&nbsp;
<i>3118</i>&nbsp;            Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
<b class="nc"><i>3119</i>&nbsp;</b>
<i>3120</i>&nbsp;            if (that.kind.isUnbound() &amp;&amp;
<b class="nc"><i>3121</i>&nbsp;                    resultInfo.checkContext.inferenceContext().free(argtypes.head)) {</b>
<b class="nc"><i>3122</i>&nbsp;                //re-generate inference constraints for unbound receiver</b>
<b class="nc"><i>3123</i>&nbsp;                if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {</b>
<b class="nc"><i>3124</i>&nbsp;                    //cannot happen as this has already been checked - we just need</b>
<b class="nc"><i>3125</i>&nbsp;                    //to regenerate the inference constraints, as that has been lost</b>
<b class="nc"><i>3126</i>&nbsp;                    //as a result of the call to inferenceContext.save()</b>
<b class="nc"><i>3127</i>&nbsp;                    Assert.error(&quot;Can&#39;t get here&quot;);</b>
<i>3128</i>&nbsp;                }
<i>3129</i>&nbsp;            }
<i>3130</i>&nbsp;
<b class="nc"><i>3131</i>&nbsp;            if (!refType.isErroneous()) {</b>
<b class="nc"><i>3132</i>&nbsp;                refType = types.createMethodTypeWithReturn(refType,</b>
<b class="nc"><i>3133</i>&nbsp;                        adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));</b>
<b class="nc"><i>3134</i>&nbsp;            }</b>
<b class="nc"><i>3135</i>&nbsp;</b>
<i>3136</i>&nbsp;            //go ahead with standard method reference compatibility check - note that param check
<b class="nc"><i>3137</i>&nbsp;            //is a no-op (as this has been taken care during method applicability)</b>
<b class="nc"><i>3138</i>&nbsp;            boolean isSpeculativeRound =</b>
<b class="nc"><i>3139</i>&nbsp;                    resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;</b>
<i>3140</i>&nbsp;
<b class="nc"><i>3141</i>&nbsp;            that.type = currentTarget; //avoids recovery at this stage</b>
<b class="nc"><i>3142</i>&nbsp;            checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);</b>
<b class="nc"><i>3143</i>&nbsp;            if (!isSpeculativeRound) {</b>
<i>3144</i>&nbsp;                checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
<i>3145</i>&nbsp;            }
<i>3146</i>&nbsp;            result = check(that, currentTarget, KindSelector.VAL, resultInfo);
<b class="nc"><i>3147</i>&nbsp;        } catch (Types.FunctionDescriptorLookupError ex) {</b>
<b class="nc"><i>3148</i>&nbsp;            JCDiagnostic cause = ex.getDiagnostic();</b>
<b class="nc"><i>3149</i>&nbsp;            resultInfo.checkContext.report(that, cause);</b>
<b class="nc"><i>3150</i>&nbsp;            result = that.type = types.createErrorType(pt());</b>
<b class="nc"><i>3151</i>&nbsp;            return;</b>
<b class="nc"><i>3152</i>&nbsp;        }</b>
<b class="nc"><i>3153</i>&nbsp;    }</b>
<b class="nc"><i>3154</i>&nbsp;    //where</b>
<b class="nc"><i>3155</i>&nbsp;        ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {</b>
<i>3156</i>&nbsp;            //if this is a constructor reference, the expected kind must be a type
<i>3157</i>&nbsp;            return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
<i>3158</i>&nbsp;                                  KindSelector.VAL_TYP : KindSelector.TYP,
<i>3159</i>&nbsp;                                  Type.noType);
<i>3160</i>&nbsp;        }
<i>3161</i>&nbsp;
<b class="nc"><i>3162</i>&nbsp;</b>
<i>3163</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)
<i>3164</i>&nbsp;    void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
<b class="nc"><i>3165</i>&nbsp;        InferenceContext inferenceContext = checkContext.inferenceContext();</b>
<b class="nc"><i>3166</i>&nbsp;        Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());</b>
<b class="nc"><i>3167</i>&nbsp;</b>
<b class="nc"><i>3168</i>&nbsp;        Type resType;</b>
<i>3169</i>&nbsp;        switch (tree.getMode()) {
<b class="nc"><i>3170</i>&nbsp;            case NEW:</b>
<i>3171</i>&nbsp;                if (!tree.expr.type.isRaw()) {
<b class="nc"><i>3172</i>&nbsp;                    resType = tree.expr.type;</b>
<i>3173</i>&nbsp;                    break;
<i>3174</i>&nbsp;                }
<i>3175</i>&nbsp;            default:
<i>3176</i>&nbsp;                resType = refType.getReturnType();
<i>3177</i>&nbsp;        }
<i>3178</i>&nbsp;
<i>3179</i>&nbsp;        Type incompatibleReturnType = resType;
<i>3180</i>&nbsp;
<b class="nc"><i>3181</i>&nbsp;        if (returnType.hasTag(VOID)) {</b>
<b class="nc"><i>3182</i>&nbsp;            incompatibleReturnType = null;</b>
<b class="nc"><i>3183</i>&nbsp;        }</b>
<i>3184</i>&nbsp;
<i>3185</i>&nbsp;        if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
<i>3186</i>&nbsp;            if (resType.isErroneous() ||
<i>3187</i>&nbsp;                    new FunctionalReturnContext(checkContext).compatible(resType, returnType,
<i>3188</i>&nbsp;                            checkContext.checkWarner(tree, resType, returnType))) {
<b class="nc"><i>3189</i>&nbsp;                incompatibleReturnType = null;</b>
<b class="nc"><i>3190</i>&nbsp;            }</b>
<b class="nc"><i>3191</i>&nbsp;        }</b>
<b class="nc"><i>3192</i>&nbsp;</b>
<b class="nc"><i>3193</i>&nbsp;        if (incompatibleReturnType != null) {</b>
<i>3194</i>&nbsp;            Fragment msg =
<i>3195</i>&nbsp;                    Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
<i>3196</i>&nbsp;            checkContext.report(tree, diags.fragment(msg));
<i>3197</i>&nbsp;        } else {
<b class="nc"><i>3198</i>&nbsp;            if (inferenceContext.free(refType)) {</b>
<b class="nc"><i>3199</i>&nbsp;                // we need to wait for inference to finish and then replace inference vars in the referent type</b>
<i>3200</i>&nbsp;                inferenceContext.addFreeTypeListener(List.of(refType),
<i>3201</i>&nbsp;                        instantiatedContext -&gt; {
<i>3202</i>&nbsp;                            tree.referentType = instantiatedContext.asInstType(refType);
<b class="nc"><i>3203</i>&nbsp;                        });</b>
<i>3204</i>&nbsp;            } else {
<i>3205</i>&nbsp;                tree.referentType = refType;
<i>3206</i>&nbsp;            }
<b class="nc"><i>3207</i>&nbsp;        }</b>
<b class="nc"><i>3208</i>&nbsp;</b>
<i>3209</i>&nbsp;        if (!speculativeAttr) {
<i>3210</i>&nbsp;            if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
<i>3211</i>&nbsp;                log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
<i>3212</i>&nbsp;            }
<i>3213</i>&nbsp;        }
<b class="nc"><i>3214</i>&nbsp;    }</b>
<i>3215</i>&nbsp;
<i>3216</i>&nbsp;    boolean checkExConstraints(
<b class="nc"><i>3217</i>&nbsp;            List&lt;Type&gt; thrownByFuncExpr,</b>
<b class="nc"><i>3218</i>&nbsp;            List&lt;Type&gt; thrownAtFuncType,</b>
<i>3219</i>&nbsp;            InferenceContext inferenceContext) {
<b class="nc"><i>3220</i>&nbsp;        /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that</b>
<b class="nc"><i>3221</i>&nbsp;         *  are not proper types</b>
<i>3222</i>&nbsp;         */
<i>3223</i>&nbsp;        List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
<i>3224</i>&nbsp;                .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
<b class="nc"><i>3225</i>&nbsp;        List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);</b>
<b class="nc"><i>3226</i>&nbsp;</b>
<i>3227</i>&nbsp;        /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
<i>3228</i>&nbsp;         *  in the throws clause of the invocation type of the method reference&#39;s compile-time
<b class="nc"><i>3229</i>&nbsp;         *  declaration</b>
<b class="nc"><i>3230</i>&nbsp;         */</b>
<i>3231</i>&nbsp;        List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
<i>3232</i>&nbsp;                .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
<b class="nc"><i>3233</i>&nbsp;</b>
<i>3234</i>&nbsp;        /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
<i>3235</i>&nbsp;         *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
<i>3236</i>&nbsp;         *  in the throws clause, the constraint reduces to false; otherwise, the constraint
<i>3237</i>&nbsp;         *  reduces to true
<b class="nc"><i>3238</i>&nbsp;         */</b>
<b class="nc"><i>3239</i>&nbsp;        ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();</b>
<i>3240</i>&nbsp;        for (Type checked : checkedList) {
<i>3241</i>&nbsp;            boolean isSubtype = false;
<b class="nc"><i>3242</i>&nbsp;            for (Type proper : properList) {</b>
<i>3243</i>&nbsp;                if (types.isSubtype(checked, proper)) {
<b class="nc"><i>3244</i>&nbsp;                    isSubtype = true;</b>
<b class="nc"><i>3245</i>&nbsp;                    break;</b>
<b class="nc"><i>3246</i>&nbsp;                }</b>
<i>3247</i>&nbsp;            }
<i>3248</i>&nbsp;            if (!isSubtype) {
<i>3249</i>&nbsp;                uncaughtByProperTypes.add(checked);
<b class="nc"><i>3250</i>&nbsp;            }</b>
<b class="nc"><i>3251</i>&nbsp;        }</b>
<b class="nc"><i>3252</i>&nbsp;</b>
<i>3253</i>&nbsp;        if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
<i>3254</i>&nbsp;            return false;
<b class="nc"><i>3255</i>&nbsp;        }</b>
<b class="nc"><i>3256</i>&nbsp;</b>
<b class="nc"><i>3257</i>&nbsp;        /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:</b>
<b class="nc"><i>3258</i>&nbsp;         *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the</b>
<b class="nc"><i>3259</i>&nbsp;         *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;</b>
<b class="nc"><i>3260</i>&nbsp;         */</b>
<b class="nc"><i>3261</i>&nbsp;        List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);</b>
<b class="nc"><i>3262</i>&nbsp;        uncaughtByProperTypes.forEach(checkedEx -&gt; {</b>
<i>3263</i>&nbsp;            nonProperAsUndet.forEach(nonProper -&gt; {
<i>3264</i>&nbsp;                types.isSubtype(checkedEx, nonProper);
<i>3265</i>&nbsp;            });
<i>3266</i>&nbsp;        });
<i>3267</i>&nbsp;
<i>3268</i>&nbsp;        /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
<i>3269</i>&nbsp;         */
<b class="nc"><i>3270</i>&nbsp;        nonProperAsUndet.stream()</b>
<b class="nc"><i>3271</i>&nbsp;                .filter(t -&gt; t.hasTag(UNDETVAR))</b>
<b class="nc"><i>3272</i>&nbsp;                .forEach(t -&gt; ((UndetVar)t).setThrow());</b>
<i>3273</i>&nbsp;        return true;
<i>3274</i>&nbsp;    }
<i>3275</i>&nbsp;
<i>3276</i>&nbsp;    /**
<b class="nc"><i>3277</i>&nbsp;     * Set functional type info on the underlying AST. Note: as the target descriptor</b>
<b class="nc"><i>3278</i>&nbsp;     * might contain inference variables, we might need to register an hook in the</b>
<b class="nc"><i>3279</i>&nbsp;     * current inference context.</b>
<b class="nc"><i>3280</i>&nbsp;     */</b>
<b class="nc"><i>3281</i>&nbsp;    private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,</b>
<i>3282</i>&nbsp;            final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
<b class="nc"><i>3283</i>&nbsp;        if (checkContext.inferenceContext().free(descriptorType)) {</b>
<b class="nc"><i>3284</i>&nbsp;            checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),</b>
<b class="nc"><i>3285</i>&nbsp;                    inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),</b>
<i>3286</i>&nbsp;                    inferenceContext.asInstType(primaryTarget), checkContext));
<b class="nc"><i>3287</i>&nbsp;        } else {</b>
<b class="nc"><i>3288</i>&nbsp;            if (pt.hasTag(CLASS)) {</b>
<i>3289</i>&nbsp;                fExpr.target = primaryTarget;
<b class="nc"><i>3290</i>&nbsp;            }</b>
<b class="nc"><i>3291</i>&nbsp;            if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;</b>
<b class="nc"><i>3292</i>&nbsp;                    pt != Type.recoveryType) {</b>
<i>3293</i>&nbsp;                //check that functional interface class is well-formed
<i>3294</i>&nbsp;                try {
<i>3295</i>&nbsp;                    /* Types.makeFunctionalInterfaceClass() may throw an exception
<b class="nc"><i>3296</i>&nbsp;                     * when it&#39;s executed post-inference. See the listener code</b>
<b class="nc"><i>3297</i>&nbsp;                     * above.</b>
<i>3298</i>&nbsp;                     */
<i>3299</i>&nbsp;                    ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
<i>3300</i>&nbsp;                            names.empty, fExpr.target, ABSTRACT);
<b class="nc"><i>3301</i>&nbsp;                    if (csym != null) {</b>
<i>3302</i>&nbsp;                        chk.checkImplementations(env.tree, csym, csym);
<i>3303</i>&nbsp;                        try {
<i>3304</i>&nbsp;                            //perform an additional functional interface check on the synthetic class,
<b class="nc"><i>3305</i>&nbsp;                            //as there may be spurious errors for raw targets - because of existing issues</b>
<b class="nc"><i>3306</i>&nbsp;                            //with membership and inheritance (see JDK-8074570).</b>
<i>3307</i>&nbsp;                            csym.flags_field |= INTERFACE;
<i>3308</i>&nbsp;                            types.findDescriptorType(csym.type);
<b class="nc"><i>3309</i>&nbsp;                        } catch (FunctionDescriptorLookupError err) {</b>
<i>3310</i>&nbsp;                            resultInfo.checkContext.report(fExpr,
<b class="nc"><i>3311</i>&nbsp;                                    diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));</b>
<i>3312</i>&nbsp;                        }
<b class="nc"><i>3313</i>&nbsp;                    }</b>
<b class="nc"><i>3314</i>&nbsp;                } catch (Types.FunctionDescriptorLookupError ex) {</b>
<b class="nc"><i>3315</i>&nbsp;                    JCDiagnostic cause = ex.getDiagnostic();</b>
<b class="nc"><i>3316</i>&nbsp;                    resultInfo.checkContext.report(env.tree, cause);</b>
<i>3317</i>&nbsp;                }
<i>3318</i>&nbsp;            }
<i>3319</i>&nbsp;        }
<b class="nc"><i>3320</i>&nbsp;    }</b>
<b class="nc"><i>3321</i>&nbsp;</b>
<b class="nc"><i>3322</i>&nbsp;    public void visitParens(JCParens tree) {</b>
<i>3323</i>&nbsp;        Type owntype = attribTree(tree.expr, env, resultInfo);
<i>3324</i>&nbsp;        result = check(tree, owntype, pkind(), resultInfo);
<b class="nc"><i>3325</i>&nbsp;        Symbol sym = TreeInfo.symbol(tree);</b>
<b class="nc"><i>3326</i>&nbsp;        if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))</b>
<i>3327</i>&nbsp;            log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
<i>3328</i>&nbsp;    }
<b class="nc"><i>3329</i>&nbsp;</b>
<i>3330</i>&nbsp;    public void visitAssign(JCAssign tree) {
<b class="nc"><i>3331</i>&nbsp;        Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);</b>
<i>3332</i>&nbsp;        Type capturedType = capture(owntype);
<i>3333</i>&nbsp;        attribExpr(tree.rhs, env, owntype);
<i>3334</i>&nbsp;        result = check(tree, capturedType, KindSelector.VAL, resultInfo);
<b class="nc"><i>3335</i>&nbsp;    }</b>
<b class="nc"><i>3336</i>&nbsp;</b>
<i>3337</i>&nbsp;    public void visitAssignop(JCAssignOp tree) {
<i>3338</i>&nbsp;        // Attribute arguments.
<b class="nc"><i>3339</i>&nbsp;        Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);</b>
<b class="nc"><i>3340</i>&nbsp;        Type operand = attribExpr(tree.rhs, env);</b>
<i>3341</i>&nbsp;        // Find operator.
<i>3342</i>&nbsp;        Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
<b class="nc"><i>3343</i>&nbsp;        if (operator != operators.noOpSymbol &amp;&amp;</b>
<b class="nc"><i>3344</i>&nbsp;                !owntype.isErroneous() &amp;&amp;</b>
<b class="nc"><i>3345</i>&nbsp;                !operand.isErroneous()) {</b>
<i>3346</i>&nbsp;            chk.checkDivZero(tree.rhs.pos(), operator, operand);
<b class="nc"><i>3347</i>&nbsp;            chk.checkCastable(tree.rhs.pos(),</b>
<i>3348</i>&nbsp;                              operator.type.getReturnType(),
<i>3349</i>&nbsp;                              owntype);
<b class="nc"><i>3350</i>&nbsp;        }</b>
<i>3351</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);
<i>3352</i>&nbsp;    }
<i>3353</i>&nbsp;
<b class="nc"><i>3354</i>&nbsp;    public void visitUnary(JCUnary tree) {</b>
<i>3355</i>&nbsp;        // Attribute arguments.
<i>3356</i>&nbsp;        Type argtype = (tree.getTag().isIncOrDecUnaryOp())
<b class="nc"><i>3357</i>&nbsp;            ? attribTree(tree.arg, env, varAssignmentInfo)</b>
<i>3358</i>&nbsp;            : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
<b class="nc"><i>3359</i>&nbsp;</b>
<i>3360</i>&nbsp;        // Find operator.
<b class="nc"><i>3361</i>&nbsp;        Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);</b>
<b class="nc"><i>3362</i>&nbsp;        Type owntype = types.createErrorType(tree.type);</b>
<i>3363</i>&nbsp;        if (operator != operators.noOpSymbol &amp;&amp;
<i>3364</i>&nbsp;                !argtype.isErroneous()) {
<i>3365</i>&nbsp;            owntype = (tree.getTag().isIncOrDecUnaryOp())
<b class="nc"><i>3366</i>&nbsp;                ? tree.arg.type</b>
<b class="nc"><i>3367</i>&nbsp;                : operator.type.getReturnType();</b>
<i>3368</i>&nbsp;            int opc = ((OperatorSymbol)operator).opcode;
<i>3369</i>&nbsp;
<b class="nc"><i>3370</i>&nbsp;            // If the argument is constant, fold it.</b>
<b class="nc"><i>3371</i>&nbsp;            if (argtype.constValue() != null) {</b>
<i>3372</i>&nbsp;                Type ctype = cfolder.fold1(opc, argtype);
<i>3373</i>&nbsp;                if (ctype != null) {
<i>3374</i>&nbsp;                    owntype = cfolder.coerce(ctype, owntype);
<i>3375</i>&nbsp;                }
<i>3376</i>&nbsp;            }
<i>3377</i>&nbsp;        }
<i>3378</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);
<i>3379</i>&nbsp;    }
<i>3380</i>&nbsp;
<i>3381</i>&nbsp;    public void visitBinary(JCBinary tree) {
<i>3382</i>&nbsp;        // Attribute arguments.
<i>3383</i>&nbsp;        Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
<i>3384</i>&nbsp;        Type right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, env));
<i>3385</i>&nbsp;        // Find operator.
<b class="nc"><i>3386</i>&nbsp;        Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);</b>
<b class="nc"><i>3387</i>&nbsp;        Type owntype = types.createErrorType(tree.type);</b>
<b class="nc"><i>3388</i>&nbsp;        if (operator != operators.noOpSymbol &amp;&amp;</b>
<i>3389</i>&nbsp;                !left.isErroneous() &amp;&amp;
<b class="nc"><i>3390</i>&nbsp;                !right.isErroneous()) {</b>
<b class="nc"><i>3391</i>&nbsp;            owntype = operator.type.getReturnType();</b>
<i>3392</i>&nbsp;            int opc = ((OperatorSymbol)operator).opcode;
<i>3393</i>&nbsp;            // If both arguments are constants, fold them.
<i>3394</i>&nbsp;            if (left.constValue() != null &amp;&amp; right.constValue() != null) {
<b class="nc"><i>3395</i>&nbsp;                Type ctype = cfolder.fold2(opc, left, right);</b>
<b class="nc"><i>3396</i>&nbsp;                if (ctype != null) {</b>
<b class="nc"><i>3397</i>&nbsp;                    owntype = cfolder.coerce(ctype, owntype);</b>
<b class="nc"><i>3398</i>&nbsp;                }</b>
<b class="nc"><i>3399</i>&nbsp;            }</b>
<b class="nc"><i>3400</i>&nbsp;</b>
<i>3401</i>&nbsp;            // Check that argument types of a reference ==, != are
<i>3402</i>&nbsp;            // castable to each other, (JLS 15.21).  Note: unboxing
<b class="nc"><i>3403</i>&nbsp;            // comparisons will not have an acmp* opc at this point.</b>
<b class="nc"><i>3404</i>&nbsp;            if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {</b>
<b class="nc"><i>3405</i>&nbsp;                if (!types.isCastable(left, right, new Warner(tree.pos()))) {</b>
<b class="nc"><i>3406</i>&nbsp;                    log.error(tree.pos(), Errors.IncomparableTypes(left, right));</b>
<b class="nc"><i>3407</i>&nbsp;                }</b>
<b class="nc"><i>3408</i>&nbsp;            }</b>
<i>3409</i>&nbsp;
<i>3410</i>&nbsp;            chk.checkDivZero(tree.rhs.pos(), operator, right);
<i>3411</i>&nbsp;        }
<b class="nc"><i>3412</i>&nbsp;        result = check(tree, owntype, KindSelector.VAL, resultInfo);</b>
<b class="nc"><i>3413</i>&nbsp;    }</b>
<b class="nc"><i>3414</i>&nbsp;</b>
<b class="nc"><i>3415</i>&nbsp;    public void visitTypeCast(final JCTypeCast tree) {</b>
<i>3416</i>&nbsp;        Type clazztype = attribType(tree.clazz, env);
<i>3417</i>&nbsp;        chk.validate(tree.clazz, env, false);
<b class="nc"><i>3418</i>&nbsp;        //a fresh environment is required for 292 inference to work properly ---</b>
<i>3419</i>&nbsp;        //see Infer.instantiatePolymorphicSignatureInstance()
<i>3420</i>&nbsp;        Env&lt;AttrContext&gt; localEnv = env.dup(tree);
<i>3421</i>&nbsp;        //should we propagate the target type?
<i>3422</i>&nbsp;        final ResultInfo castInfo;
<i>3423</i>&nbsp;        JCExpression expr = TreeInfo.skipParens(tree.expr);
<i>3424</i>&nbsp;        boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
<i>3425</i>&nbsp;        if (isPoly) {
<b class="nc"><i>3426</i>&nbsp;            //expression is a poly - we need to propagate target type info</b>
<b class="nc"><i>3427</i>&nbsp;            castInfo = new ResultInfo(KindSelector.VAL, clazztype,</b>
<i>3428</i>&nbsp;                                      new Check.NestedCheckContext(resultInfo.checkContext) {
<b class="nc"><i>3429</i>&nbsp;                @Override</b>
<b class="nc"><i>3430</i>&nbsp;                public boolean compatible(Type found, Type req, Warner warn) {</b>
<b class="nc"><i>3431</i>&nbsp;                    return types.isCastable(found, req, warn);</b>
<i>3432</i>&nbsp;                }
<b class="nc"><i>3433</i>&nbsp;            });</b>
<i>3434</i>&nbsp;        } else {
<i>3435</i>&nbsp;            //standalone cast - target-type info is not propagated
<b class="nc"><i>3436</i>&nbsp;            castInfo = unknownExprInfo;</b>
<b class="nc"><i>3437</i>&nbsp;        }</b>
<i>3438</i>&nbsp;        Type exprtype = attribTree(tree.expr, localEnv, castInfo);
<i>3439</i>&nbsp;        Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
<i>3440</i>&nbsp;        if (exprtype.constValue() != null)
<b class="nc"><i>3441</i>&nbsp;            owntype = cfolder.coerce(exprtype, owntype);</b>
<i>3442</i>&nbsp;        result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
<i>3443</i>&nbsp;        if (!isPoly)
<i>3444</i>&nbsp;            chk.checkRedundantCast(localEnv, tree);
<b class="nc"><i>3445</i>&nbsp;    }</b>
<i>3446</i>&nbsp;
<i>3447</i>&nbsp;    public void visitTypeTest(JCInstanceOf tree) {
<b class="nc"><i>3448</i>&nbsp;        Type exprtype = chk.checkNullOrRefType(</b>
<b class="nc"><i>3449</i>&nbsp;                tree.expr.pos(), attribExpr(tree.expr, env));</b>
<b class="nc"><i>3450</i>&nbsp;        Type clazztype = attribType(tree.clazz, env);</b>
<b class="nc"><i>3451</i>&nbsp;        if (!clazztype.hasTag(TYPEVAR)) {</b>
<i>3452</i>&nbsp;            clazztype = chk.checkClassOrArrayType(tree.clazz.pos(), clazztype);
<i>3453</i>&nbsp;        }
<b class="nc"><i>3454</i>&nbsp;        if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {</b>
<b class="nc"><i>3455</i>&nbsp;            log.error(tree.clazz.pos(), Errors.IllegalGenericTypeForInstof);</b>
<i>3456</i>&nbsp;            clazztype = types.createErrorType(clazztype);
<i>3457</i>&nbsp;        }
<i>3458</i>&nbsp;        chk.validate(tree.clazz, env, false);
<i>3459</i>&nbsp;        chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
<i>3460</i>&nbsp;        result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
<i>3461</i>&nbsp;    }
<i>3462</i>&nbsp;
<i>3463</i>&nbsp;    public void visitIndexed(JCArrayAccess tree) {
<i>3464</i>&nbsp;        Type owntype = types.createErrorType(tree.type);
<i>3465</i>&nbsp;        Type atype = attribExpr(tree.indexed, env);
<i>3466</i>&nbsp;        attribExpr(tree.index, env, syms.intType);
<i>3467</i>&nbsp;        if (types.isArray(atype))
<i>3468</i>&nbsp;            owntype = types.elemtype(atype);
<i>3469</i>&nbsp;        else if (!atype.hasTag(ERROR))
<i>3470</i>&nbsp;            log.error(tree.pos(), Errors.ArrayReqButFound(atype));
<i>3471</i>&nbsp;        if (!pkind().contains(KindSelector.VAL))
<i>3472</i>&nbsp;            owntype = capture(owntype);
<i>3473</i>&nbsp;        result = check(tree, owntype, KindSelector.VAR, resultInfo);
<i>3474</i>&nbsp;    }
<i>3475</i>&nbsp;
<i>3476</i>&nbsp;    public void visitIdent(JCIdent tree) {
<i>3477</i>&nbsp;        Symbol sym;
<i>3478</i>&nbsp;
<i>3479</i>&nbsp;        // Find symbol
<i>3480</i>&nbsp;        if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
<i>3481</i>&nbsp;            // If we are looking for a method, the prototype `pt&#39; will be a
<i>3482</i>&nbsp;            // method type with the type of the call&#39;s arguments as parameters.
<i>3483</i>&nbsp;            env.info.pendingResolutionPhase = null;
<i>3484</i>&nbsp;            sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
<i>3485</i>&nbsp;        } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
<i>3486</i>&nbsp;            sym = tree.sym;
<i>3487</i>&nbsp;        } else {
<b class="nc"><i>3488</i>&nbsp;            sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());</b>
<b class="nc"><i>3489</i>&nbsp;        }</b>
<b class="nc"><i>3490</i>&nbsp;        tree.sym = sym;</b>
<i>3491</i>&nbsp;
<i>3492</i>&nbsp;        // (1) Also find the environment current for the class where
<i>3493</i>&nbsp;        //     sym is defined (`symEnv&#39;).
<i>3494</i>&nbsp;        // Only for pre-tiger versions (1.4 and earlier):
<i>3495</i>&nbsp;        // (2) Also determine whether we access symbol out of an anonymous
<i>3496</i>&nbsp;        //     class in a this or super call.  This is illegal for instance
<i>3497</i>&nbsp;        //     members since such classes don&#39;t carry a this$n link.
<b class="nc"><i>3498</i>&nbsp;        //     (`noOuterThisPath&#39;).</b>
<b class="nc"><i>3499</i>&nbsp;        Env&lt;AttrContext&gt; symEnv = env;</b>
<b class="nc"><i>3500</i>&nbsp;        boolean noOuterThisPath = false;</b>
<b class="nc"><i>3501</i>&nbsp;        if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class</b>
<b class="nc"><i>3502</i>&nbsp;            sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;</b>
<i>3503</i>&nbsp;            sym.owner.kind == TYP &amp;&amp;
<i>3504</i>&nbsp;            tree.name != names._this &amp;&amp; tree.name != names._super) {
<i>3505</i>&nbsp;
<i>3506</i>&nbsp;            // Find environment in which identifier is defined.
<i>3507</i>&nbsp;            while (symEnv.outer != null &amp;&amp;
<i>3508</i>&nbsp;                   !sym.isMemberOf(symEnv.enclClass.sym, types)) {
<i>3509</i>&nbsp;                if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
<i>3510</i>&nbsp;                    noOuterThisPath = false;
<b class="nc"><i>3511</i>&nbsp;                symEnv = symEnv.outer;</b>
<b class="nc"><i>3512</i>&nbsp;            }</b>
<b class="nc"><i>3513</i>&nbsp;        }</b>
<i>3514</i>&nbsp;
<i>3515</i>&nbsp;        // If symbol is a variable, ...
<i>3516</i>&nbsp;        if (sym.kind == VAR) {
<i>3517</i>&nbsp;            VarSymbol v = (VarSymbol)sym;
<i>3518</i>&nbsp;
<i>3519</i>&nbsp;            // ..., evaluate its initializer, if it has one, and check for
<i>3520</i>&nbsp;            // illegal forward reference.
<b class="nc"><i>3521</i>&nbsp;            checkInit(tree, env, v, false);</b>
<b class="nc"><i>3522</i>&nbsp;</b>
<b class="nc"><i>3523</i>&nbsp;            // If we are expecting a variable (as opposed to a value), check</b>
<b class="nc"><i>3524</i>&nbsp;            // that the variable is assignable in the current environment.</b>
<b class="nc"><i>3525</i>&nbsp;            if (KindSelector.ASG.subset(pkind()))</b>
<i>3526</i>&nbsp;                checkAssignable(tree.pos(), v, null, env);
<b class="nc"><i>3527</i>&nbsp;        }</b>
<i>3528</i>&nbsp;
<i>3529</i>&nbsp;        // In a constructor body,
<i>3530</i>&nbsp;        // if symbol is a field or instance method, check that it is
<i>3531</i>&nbsp;        // not accessed before the supertype constructor is called.
<i>3532</i>&nbsp;        if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
<i>3533</i>&nbsp;            sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
<i>3534</i>&nbsp;            sym.owner.kind == TYP &amp;&amp;
<i>3535</i>&nbsp;            (sym.flags() &amp; STATIC) == 0) {
<i>3536</i>&nbsp;            chk.earlyRefError(tree.pos(), sym.kind == VAR ?
<b class="nc"><i>3537</i>&nbsp;                                          sym : thisSym(tree.pos(), env));</b>
<b class="nc"><i>3538</i>&nbsp;        }</b>
<i>3539</i>&nbsp;        Env&lt;AttrContext&gt; env1 = env;
<i>3540</i>&nbsp;        if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
<b class="nc"><i>3541</i>&nbsp;            sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {</b>
<i>3542</i>&nbsp;            // If the found symbol is inaccessible, then it is
<i>3543</i>&nbsp;            // accessed through an enclosing instance.  Locate this
<i>3544</i>&nbsp;            // enclosing instance:
<b class="nc"><i>3545</i>&nbsp;            while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))</b>
<b class="nc"><i>3546</i>&nbsp;                env1 = env1.outer;</b>
<b class="nc"><i>3547</i>&nbsp;        }</b>
<b class="nc"><i>3548</i>&nbsp;</b>
<i>3549</i>&nbsp;        if (env.info.isSerializable) {
<i>3550</i>&nbsp;            chk.checkAccessFromSerializableElement(tree, env.info.isLambda);
<i>3551</i>&nbsp;        }
<i>3552</i>&nbsp;
<b class="nc"><i>3553</i>&nbsp;        result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);</b>
<b class="nc"><i>3554</i>&nbsp;    }</b>
<i>3555</i>&nbsp;
<i>3556</i>&nbsp;    public void visitSelect(JCFieldAccess tree) {
<i>3557</i>&nbsp;        // Determine the expected kind of the qualifier expression.
<i>3558</i>&nbsp;        KindSelector skind = KindSelector.NIL;
<i>3559</i>&nbsp;        if (tree.name == names._this || tree.name == names._super ||
<i>3560</i>&nbsp;                tree.name == names._class)
<i>3561</i>&nbsp;        {
<i>3562</i>&nbsp;            skind = KindSelector.TYP;
<i>3563</i>&nbsp;        } else {
<i>3564</i>&nbsp;            if (pkind().contains(KindSelector.PCK))
<i>3565</i>&nbsp;                skind = KindSelector.of(skind, KindSelector.PCK);
<i>3566</i>&nbsp;            if (pkind().contains(KindSelector.TYP))
<b class="nc"><i>3567</i>&nbsp;                skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);</b>
<b class="nc"><i>3568</i>&nbsp;            if (pkind().contains(KindSelector.VAL_MTH))</b>
<b class="nc"><i>3569</i>&nbsp;                skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);</b>
<b class="nc"><i>3570</i>&nbsp;        }</b>
<i>3571</i>&nbsp;
<b class="nc"><i>3572</i>&nbsp;        // Attribute the qualifier expression, and determine its symbol (if any).</b>
<b class="nc"><i>3573</i>&nbsp;        Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));</b>
<b class="nc"><i>3574</i>&nbsp;        if (!pkind().contains(KindSelector.TYP_PCK))</b>
<b class="nc"><i>3575</i>&nbsp;            site = capture(site); // Capture field access</b>
<b class="nc"><i>3576</i>&nbsp;</b>
<i>3577</i>&nbsp;        // don&#39;t allow T.class T[].class, etc
<b class="nc"><i>3578</i>&nbsp;        if (skind == KindSelector.TYP) {</b>
<i>3579</i>&nbsp;            Type elt = site;
<i>3580</i>&nbsp;            while (elt.hasTag(ARRAY))
<b class="nc"><i>3581</i>&nbsp;                elt = ((ArrayType)elt).elemtype;</b>
<i>3582</i>&nbsp;            if (elt.hasTag(TYPEVAR)) {
<i>3583</i>&nbsp;                log.error(tree.pos(), Errors.TypeVarCantBeDeref);
<i>3584</i>&nbsp;                result = tree.type = types.createErrorType(tree.name, site.tsym, site);
<b class="nc"><i>3585</i>&nbsp;                tree.sym = tree.type.tsym;</b>
<i>3586</i>&nbsp;                return ;
<i>3587</i>&nbsp;            }
<b class="nc"><i>3588</i>&nbsp;        }</b>
<b class="nc"><i>3589</i>&nbsp;</b>
<b class="nc"><i>3590</i>&nbsp;        // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;</b>
<b class="nc"><i>3591</i>&nbsp;        // for the selection. This is relevant for determining whether</b>
<b class="nc"><i>3592</i>&nbsp;        // protected symbols are accessible.</b>
<b class="nc"><i>3593</i>&nbsp;        Symbol sitesym = TreeInfo.symbol(tree.selected);</b>
<b class="nc"><i>3594</i>&nbsp;        boolean selectSuperPrev = env.info.selectSuper;</b>
<i>3595</i>&nbsp;        env.info.selectSuper =
<i>3596</i>&nbsp;            sitesym != null &amp;&amp;
<i>3597</i>&nbsp;            sitesym.name == names._super;
<i>3598</i>&nbsp;
<i>3599</i>&nbsp;        // Determine the symbol represented by the selection.
<i>3600</i>&nbsp;        env.info.pendingResolutionPhase = null;
<b class="nc"><i>3601</i>&nbsp;        Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);</b>
<i>3602</i>&nbsp;        if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
<b class="nc"><i>3603</i>&nbsp;            log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));</b>
<i>3604</i>&nbsp;            sym = syms.errSymbol;
<i>3605</i>&nbsp;        }
<i>3606</i>&nbsp;        if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
<i>3607</i>&nbsp;            site = capture(site);
<b class="nc"><i>3608</i>&nbsp;            sym = selectSym(tree, sitesym, site, env, resultInfo);</b>
<b class="nc"><i>3609</i>&nbsp;        }</b>
<i>3610</i>&nbsp;        boolean varArgs = env.info.lastResolveVarargs();
<b class="nc"><i>3611</i>&nbsp;        tree.sym = sym;</b>
<b class="nc"><i>3612</i>&nbsp;</b>
<i>3613</i>&nbsp;        if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
<i>3614</i>&nbsp;            site = types.skipTypeVars(site, true);
<i>3615</i>&nbsp;        }
<b class="nc"><i>3616</i>&nbsp;</b>
<b class="nc"><i>3617</i>&nbsp;        // If that symbol is a variable, ...</b>
<b class="nc"><i>3618</i>&nbsp;        if (sym.kind == VAR) {</b>
<b class="nc"><i>3619</i>&nbsp;            VarSymbol v = (VarSymbol)sym;</b>
<b class="nc"><i>3620</i>&nbsp;</b>
<i>3621</i>&nbsp;            // ..., evaluate its initializer, if it has one, and check for
<i>3622</i>&nbsp;            // illegal forward reference.
<b class="nc"><i>3623</i>&nbsp;            checkInit(tree, env, v, true);</b>
<b class="nc"><i>3624</i>&nbsp;</b>
<i>3625</i>&nbsp;            // If we are expecting a variable (as opposed to a value), check
<b class="nc"><i>3626</i>&nbsp;            // that the variable is assignable in the current environment.</b>
<i>3627</i>&nbsp;            if (KindSelector.ASG.subset(pkind()))
<i>3628</i>&nbsp;                checkAssignable(tree.pos(), v, tree.selected, env);
<i>3629</i>&nbsp;        }
<i>3630</i>&nbsp;
<i>3631</i>&nbsp;        if (sitesym != null &amp;&amp;
<i>3632</i>&nbsp;                sitesym.kind == VAR &amp;&amp;
<i>3633</i>&nbsp;                ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
<b class="nc"><i>3634</i>&nbsp;                sym.kind == MTH &amp;&amp;</b>
<b class="nc"><i>3635</i>&nbsp;                sym.name.equals(names.close) &amp;&amp;</b>
<b class="nc"><i>3636</i>&nbsp;                sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;</b>
<b class="nc"><i>3637</i>&nbsp;                env.info.lint.isEnabled(LintCategory.TRY)) {</b>
<i>3638</i>&nbsp;            log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
<i>3639</i>&nbsp;        }
<i>3640</i>&nbsp;
<i>3641</i>&nbsp;        // Disallow selecting a type from an expression
<b class="nc"><i>3642</i>&nbsp;        if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {</b>
<i>3643</i>&nbsp;            tree.type = check(tree.selected, pt(),
<i>3644</i>&nbsp;                              sitesym == null ?
<i>3645</i>&nbsp;                                      KindSelector.VAL : sitesym.kind.toSelector(),
<i>3646</i>&nbsp;                              new ResultInfo(KindSelector.TYP_PCK, pt()));
<i>3647</i>&nbsp;        }
<i>3648</i>&nbsp;
<i>3649</i>&nbsp;        if (isType(sitesym)) {
<i>3650</i>&nbsp;            if (sym.name == names._this) {
<i>3651</i>&nbsp;                // If `C&#39; is the currently compiled class, check that
<i>3652</i>&nbsp;                // C.this&#39; does not appear in a call to a super(...)
<i>3653</i>&nbsp;                if (env.info.isSelfCall &amp;&amp;
<i>3654</i>&nbsp;                    site.tsym == env.enclClass.sym) {
<i>3655</i>&nbsp;                    chk.earlyRefError(tree.pos(), sym);
<i>3656</i>&nbsp;                }
<i>3657</i>&nbsp;            } else {
<i>3658</i>&nbsp;                // Check if type-qualified fields or methods are static (JLS)
<i>3659</i>&nbsp;                if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
<i>3660</i>&nbsp;                    sym.name != names._super &amp;&amp;
<i>3661</i>&nbsp;                    (sym.kind == VAR || sym.kind == MTH)) {
<i>3662</i>&nbsp;                    rs.accessBase(rs.new StaticError(sym),
<i>3663</i>&nbsp;                              tree.pos(), site, sym.name, true);
<i>3664</i>&nbsp;                }
<i>3665</i>&nbsp;            }
<i>3666</i>&nbsp;            if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
<b class="nc"><i>3667</i>&nbsp;                    sym.isStatic() &amp;&amp; sym.kind == MTH) {</b>
<i>3668</i>&nbsp;                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
<b class="nc"><i>3669</i>&nbsp;            }</b>
<b class="nc"><i>3670</i>&nbsp;        } else if (sym.kind != ERR &amp;&amp;</b>
<b class="nc"><i>3671</i>&nbsp;                   (sym.flags() &amp; STATIC) != 0 &amp;&amp;</b>
<b class="nc"><i>3672</i>&nbsp;                   sym.name != names._class) {</b>
<b class="nc"><i>3673</i>&nbsp;            // If the qualified item is not a type and the selected item is static, report</b>
<b class="nc"><i>3674</i>&nbsp;            // a warning. Make allowance for the class of an array type e.g. Object[].class)</b>
<i>3675</i>&nbsp;            chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
<b class="nc"><i>3676</i>&nbsp;        }</b>
<b class="nc"><i>3677</i>&nbsp;</b>
<b class="nc"><i>3678</i>&nbsp;        // If we are selecting an instance member via a `super&#39;, ...</b>
<b class="nc"><i>3679</i>&nbsp;        if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {</b>
<i>3680</i>&nbsp;
<i>3681</i>&nbsp;            // Check that super-qualified symbols are not abstract (JLS)
<i>3682</i>&nbsp;            rs.checkNonAbstract(tree.pos(), sym);
<b class="nc"><i>3683</i>&nbsp;</b>
<i>3684</i>&nbsp;            if (site.isRaw()) {
<b class="nc"><i>3685</i>&nbsp;                // Determine argument types for site.</b>
<i>3686</i>&nbsp;                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
<i>3687</i>&nbsp;                if (site1 != null) site = site1;
<i>3688</i>&nbsp;            }
<i>3689</i>&nbsp;        }
<i>3690</i>&nbsp;
<i>3691</i>&nbsp;        if (env.info.isSerializable) {
<i>3692</i>&nbsp;            chk.checkAccessFromSerializableElement(tree, env.info.isLambda);
<i>3693</i>&nbsp;        }
<b class="nc"><i>3694</i>&nbsp;</b>
<i>3695</i>&nbsp;        env.info.selectSuper = selectSuperPrev;
<b class="nc"><i>3696</i>&nbsp;        result = checkId(tree, site, sym, env, resultInfo);</b>
<b class="nc"><i>3697</i>&nbsp;    }</b>
<i>3698</i>&nbsp;    //where
<b class="nc"><i>3699</i>&nbsp;        /** Determine symbol referenced by a Select expression,</b>
<i>3700</i>&nbsp;         *
<i>3701</i>&nbsp;         *  @param tree   The select tree.
<i>3702</i>&nbsp;         *  @param site   The type of the selected expression,
<b class="nc"><i>3703</i>&nbsp;         *  @param env    The current environment.</b>
<i>3704</i>&nbsp;         *  @param resultInfo The current result.
<b class="nc"><i>3705</i>&nbsp;         */</b>
<i>3706</i>&nbsp;        private Symbol selectSym(JCFieldAccess tree,
<i>3707</i>&nbsp;                                 Symbol location,
<i>3708</i>&nbsp;                                 Type site,
<i>3709</i>&nbsp;                                 Env&lt;AttrContext&gt; env,
<i>3710</i>&nbsp;                                 ResultInfo resultInfo) {
<b class="nc"><i>3711</i>&nbsp;            DiagnosticPosition pos = tree.pos();</b>
<i>3712</i>&nbsp;            Name name = tree.name;
<b class="nc"><i>3713</i>&nbsp;            switch (site.getTag()) {</b>
<b class="nc"><i>3714</i>&nbsp;            case PACKAGE:</b>
<i>3715</i>&nbsp;                return rs.accessBase(
<i>3716</i>&nbsp;                    rs.findIdentInPackage(env, site.tsym, name, resultInfo.pkind),
<i>3717</i>&nbsp;                    pos, location, site, name, true);
<i>3718</i>&nbsp;            case ARRAY:
<i>3719</i>&nbsp;            case CLASS:
<i>3720</i>&nbsp;                if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
<i>3721</i>&nbsp;                    return rs.resolveQualifiedMethod(
<i>3722</i>&nbsp;                        pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
<i>3723</i>&nbsp;                } else if (name == names._this || name == names._super) {
<i>3724</i>&nbsp;                    return rs.resolveSelf(pos, env, site.tsym, name);
<i>3725</i>&nbsp;                } else if (name == names._class) {
<i>3726</i>&nbsp;                    // In this case, we have already made sure in
<i>3727</i>&nbsp;                    // visitSelect that qualifier expression is a type.
<i>3728</i>&nbsp;                    return syms.getClassField(site, types);
<i>3729</i>&nbsp;                } else {
<i>3730</i>&nbsp;                    // We are seeing a plain identifier as selector.
<i>3731</i>&nbsp;                    Symbol sym = rs.findIdentInType(env, site, name, resultInfo.pkind);
<i>3732</i>&nbsp;                        sym = rs.accessBase(sym, pos, location, site, name, true);
<i>3733</i>&nbsp;                    return sym;
<i>3734</i>&nbsp;                }
<i>3735</i>&nbsp;            case WILDCARD:
<i>3736</i>&nbsp;                throw new AssertionError(tree);
<i>3737</i>&nbsp;            case TYPEVAR:
<i>3738</i>&nbsp;                // Normally, site.getUpperBound() shouldn&#39;t be null.
<i>3739</i>&nbsp;                // It should only happen during memberEnter/attribBase
<b class="nc"><i>3740</i>&nbsp;                // when determining the super type which *must* beac</b>
<b class="nc"><i>3741</i>&nbsp;                // done before attributing the type variables.  In</b>
<i>3742</i>&nbsp;                // other words, we are seeing this illegal program:
<b class="nc"><i>3743</i>&nbsp;                // class B&lt;T&gt; extends A&lt;T.foo&gt; {}</b>
<i>3744</i>&nbsp;                Symbol sym = (site.getUpperBound() != null)
<i>3745</i>&nbsp;                    ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
<i>3746</i>&nbsp;                    : null;
<i>3747</i>&nbsp;                if (sym == null) {
<i>3748</i>&nbsp;                    log.error(pos, Errors.TypeVarCantBeDeref);
<b class="nc"><i>3749</i>&nbsp;                    return syms.errSymbol;</b>
<i>3750</i>&nbsp;                } else {
<i>3751</i>&nbsp;                    Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
<i>3752</i>&nbsp;                        rs.new AccessError(env, site, sym) :
<i>3753</i>&nbsp;                                sym;
<b class="nc"><i>3754</i>&nbsp;                    rs.accessBase(sym2, pos, location, site, name, true);</b>
<i>3755</i>&nbsp;                    return sym;
<i>3756</i>&nbsp;                }
<b class="nc"><i>3757</i>&nbsp;            case ERROR:</b>
<i>3758</i>&nbsp;                // preserve identifier names through errors
<i>3759</i>&nbsp;                return types.createErrorType(name, site.tsym, site).tsym;
<i>3760</i>&nbsp;            default:
<i>3761</i>&nbsp;                // The qualifier expression is of a primitive type -- only
<i>3762</i>&nbsp;                // .class is allowed for these.
<i>3763</i>&nbsp;                if (name == names._class) {
<i>3764</i>&nbsp;                    // In this case, we have already made sure in Select that
<b class="nc"><i>3765</i>&nbsp;                    // qualifier expression is a type.</b>
<b class="nc"><i>3766</i>&nbsp;                    return syms.getClassField(site, types);</b>
<b class="nc"><i>3767</i>&nbsp;                } else {</b>
<i>3768</i>&nbsp;                    log.error(pos, Errors.CantDeref(site));
<i>3769</i>&nbsp;                    return syms.errSymbol;
<i>3770</i>&nbsp;                }
<b class="nc"><i>3771</i>&nbsp;            }</b>
<i>3772</i>&nbsp;        }
<i>3773</i>&nbsp;
<i>3774</i>&nbsp;        /** Determine type of identifier or select expression and check that
<i>3775</i>&nbsp;         *  (1) the referenced symbol is not deprecated
<i>3776</i>&nbsp;         *  (2) the symbol&#39;s type is safe (@see checkSafe)
<i>3777</i>&nbsp;         *  (3) if symbol is a variable, check that its type and kind are
<i>3778</i>&nbsp;         *      compatible with the prototype and protokind.
<i>3779</i>&nbsp;         *  (4) if symbol is an instance field of a raw type,
<i>3780</i>&nbsp;         *      which is being assigned to, issue an unchecked warning if its
<i>3781</i>&nbsp;         *      type changes under erasure.
<i>3782</i>&nbsp;         *  (5) if symbol is an instance method of a raw type, issue an
<i>3783</i>&nbsp;         *      unchecked warning if its argument types change under erasure.
<i>3784</i>&nbsp;         *  If checks succeed:
<b class="nc"><i>3785</i>&nbsp;         *    If symbol is a constant, return its constant type</b>
<b class="nc"><i>3786</i>&nbsp;         *    else if symbol is a method, return its result type</b>
<b class="nc"><i>3787</i>&nbsp;         *    otherwise return its type.</b>
<b class="nc"><i>3788</i>&nbsp;         *  Otherwise return errType.</b>
<b class="nc"><i>3789</i>&nbsp;         *</b>
<b class="nc"><i>3790</i>&nbsp;         *  @param tree       The syntax tree representing the identifier</b>
<b class="nc"><i>3791</i>&nbsp;         *  @param site       If this is a select, the type of the selected</b>
<b class="nc"><i>3792</i>&nbsp;         *                    expression, otherwise the type of the current class.</b>
<i>3793</i>&nbsp;         *  @param sym        The symbol representing the identifier.
<i>3794</i>&nbsp;         *  @param env        The current environment.
<i>3795</i>&nbsp;         *  @param resultInfo    The expected result
<i>3796</i>&nbsp;         */
<i>3797</i>&nbsp;        Type checkId(JCTree tree,
<b class="nc"><i>3798</i>&nbsp;                     Type site,</b>
<b class="nc"><i>3799</i>&nbsp;                     Symbol sym,</b>
<b class="nc"><i>3800</i>&nbsp;                     Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>3801</i>&nbsp;                     ResultInfo resultInfo) {</b>
<b class="nc"><i>3802</i>&nbsp;            return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?</b>
<b class="nc"><i>3803</i>&nbsp;                    checkMethodIdInternal(tree, site, sym, env, resultInfo) :</b>
<b class="nc"><i>3804</i>&nbsp;                    checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);</b>
<i>3805</i>&nbsp;        }
<b class="nc"><i>3806</i>&nbsp;</b>
<b class="nc"><i>3807</i>&nbsp;        Type checkMethodIdInternal(JCTree tree,</b>
<b class="nc"><i>3808</i>&nbsp;                     Type site,</b>
<b class="nc"><i>3809</i>&nbsp;                     Symbol sym,</b>
<i>3810</i>&nbsp;                     Env&lt;AttrContext&gt; env,
<b class="nc"><i>3811</i>&nbsp;                     ResultInfo resultInfo) {</b>
<b class="nc"><i>3812</i>&nbsp;            if (resultInfo.pkind.contains(KindSelector.POLY)) {</b>
<i>3813</i>&nbsp;                Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
<i>3814</i>&nbsp;                Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
<b class="nc"><i>3815</i>&nbsp;                resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));</b>
<b class="nc"><i>3816</i>&nbsp;                return owntype;</b>
<b class="nc"><i>3817</i>&nbsp;            } else {</b>
<b class="nc"><i>3818</i>&nbsp;                return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);</b>
<b class="nc"><i>3819</i>&nbsp;            }</b>
<i>3820</i>&nbsp;        }
<i>3821</i>&nbsp;
<i>3822</i>&nbsp;        Type checkIdInternal(JCTree tree,
<i>3823</i>&nbsp;                     Type site,
<i>3824</i>&nbsp;                     Symbol sym,
<i>3825</i>&nbsp;                     Type pt,
<i>3826</i>&nbsp;                     Env&lt;AttrContext&gt; env,
<b class="nc"><i>3827</i>&nbsp;                     ResultInfo resultInfo) {</b>
<i>3828</i>&nbsp;            if (pt.isErroneous()) {
<b class="nc"><i>3829</i>&nbsp;                return types.createErrorType(site);</b>
<i>3830</i>&nbsp;            }
<i>3831</i>&nbsp;            Type owntype; // The computed type of this identifier occurrence.
<i>3832</i>&nbsp;            switch (sym.kind) {
<i>3833</i>&nbsp;            case TYP:
<i>3834</i>&nbsp;                // For types, the computed type equals the symbol&#39;s type,
<i>3835</i>&nbsp;                // except for two situations:
<i>3836</i>&nbsp;                owntype = sym.type;
<i>3837</i>&nbsp;                if (owntype.hasTag(CLASS)) {
<b class="nc"><i>3838</i>&nbsp;                    chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);</b>
<i>3839</i>&nbsp;                    Type ownOuter = owntype.getEnclosingType();
<i>3840</i>&nbsp;
<b class="nc"><i>3841</i>&nbsp;                    // (a) If the symbol&#39;s type is parameterized, erase it</b>
<i>3842</i>&nbsp;                    // because no type parameters were given.
<b class="nc"><i>3843</i>&nbsp;                    // We recover generic outer type later in visitTypeApply.</b>
<b class="nc"><i>3844</i>&nbsp;                    if (owntype.tsym.type.getTypeArguments().nonEmpty()) {</b>
<i>3845</i>&nbsp;                        owntype = types.erasure(owntype);
<b class="nc"><i>3846</i>&nbsp;                    }</b>
<i>3847</i>&nbsp;
<b class="nc"><i>3848</i>&nbsp;                    // (b) If the symbol&#39;s type is an inner class, then</b>
<b class="nc"><i>3849</i>&nbsp;                    // we have to interpret its outer type as a superclass</b>
<b class="nc"><i>3850</i>&nbsp;                    // of the site type. Example:</b>
<b class="nc"><i>3851</i>&nbsp;                    //</b>
<b class="nc"><i>3852</i>&nbsp;                    // class Tree&lt;A&gt; { class Visitor { ... } }</b>
<b class="nc"><i>3853</i>&nbsp;                    // class PointTree extends Tree&lt;Point&gt; { ... }</b>
<b class="nc"><i>3854</i>&nbsp;                    // ...PointTree.Visitor...</b>
<i>3855</i>&nbsp;                    //
<i>3856</i>&nbsp;                    // Then the type of the last expression above is
<i>3857</i>&nbsp;                    // Tree&lt;Point&gt;.Visitor.
<b class="nc"><i>3858</i>&nbsp;                    else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {</b>
<b class="nc"><i>3859</i>&nbsp;                        Type normOuter = site;</b>
<b class="nc"><i>3860</i>&nbsp;                        if (normOuter.hasTag(CLASS)) {</b>
<i>3861</i>&nbsp;                            normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
<i>3862</i>&nbsp;                        }
<b class="nc"><i>3863</i>&nbsp;                        if (normOuter == null) // perhaps from an import</b>
<b class="nc"><i>3864</i>&nbsp;                            normOuter = types.erasure(ownOuter);</b>
<b class="nc"><i>3865</i>&nbsp;                        if (normOuter != ownOuter)</b>
<b class="nc"><i>3866</i>&nbsp;                            owntype = new ClassType(</b>
<b class="nc"><i>3867</i>&nbsp;                                normOuter, List.nil(), owntype.tsym,</b>
<i>3868</i>&nbsp;                                owntype.getMetadata());
<i>3869</i>&nbsp;                    }
<b class="nc"><i>3870</i>&nbsp;                }</b>
<i>3871</i>&nbsp;                break;
<i>3872</i>&nbsp;            case VAR:
<b class="nc"><i>3873</i>&nbsp;                VarSymbol v = (VarSymbol)sym;</b>
<i>3874</i>&nbsp;
<b class="nc"><i>3875</i>&nbsp;                if (env.info.enclVar != null</b>
<i>3876</i>&nbsp;                        &amp;&amp; v.type.hasTag(NONE)) {
<b class="nc"><i>3877</i>&nbsp;                    //self reference to implicitly typed variable declaration</b>
<b class="nc"><i>3878</i>&nbsp;                    log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));</b>
<i>3879</i>&nbsp;                    return v.type = types.createErrorType(v.type);
<i>3880</i>&nbsp;                }
<i>3881</i>&nbsp;
<i>3882</i>&nbsp;                // Test (4): if symbol is an instance field of a raw type,
<b class="nc"><i>3883</i>&nbsp;                // which is being assigned to, issue an unchecked warning if</b>
<b class="nc"><i>3884</i>&nbsp;                // its type changes under erasure.</b>
<i>3885</i>&nbsp;                if (KindSelector.ASG.subset(pkind()) &amp;&amp;
<i>3886</i>&nbsp;                    v.owner.kind == TYP &amp;&amp;
<i>3887</i>&nbsp;                    (v.flags() &amp; STATIC) == 0 &amp;&amp;
<i>3888</i>&nbsp;                    (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
<i>3889</i>&nbsp;                    Type s = types.asOuterSuper(site, v.owner);
<b class="nc"><i>3890</i>&nbsp;                    if (s != null &amp;&amp;</b>
<i>3891</i>&nbsp;                        s.isRaw() &amp;&amp;
<i>3892</i>&nbsp;                        !types.isSameType(v.type, v.erasure(types))) {
<i>3893</i>&nbsp;                        chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
<b class="nc"><i>3894</i>&nbsp;                    }</b>
<i>3895</i>&nbsp;                }
<i>3896</i>&nbsp;                // The computed type of a variable is the type of the
<i>3897</i>&nbsp;                // variable symbol, taken as a member of the site type.
<b class="nc"><i>3898</i>&nbsp;                owntype = (sym.owner.kind == TYP &amp;&amp;</b>
<b class="nc"><i>3899</i>&nbsp;                           sym.name != names._this &amp;&amp; sym.name != names._super)</b>
<b class="nc"><i>3900</i>&nbsp;                    ? types.memberType(site, sym)</b>
<i>3901</i>&nbsp;                    : sym.type;
<i>3902</i>&nbsp;
<i>3903</i>&nbsp;                // If the variable is a constant, record constant value in
<i>3904</i>&nbsp;                // computed type.
<i>3905</i>&nbsp;                if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
<i>3906</i>&nbsp;                    owntype = owntype.constType(v.getConstValue());
<i>3907</i>&nbsp;
<b class="nc"><i>3908</i>&nbsp;                if (resultInfo.pkind == KindSelector.VAL) {</b>
<i>3909</i>&nbsp;                    owntype = capture(owntype); // capture &quot;names as expressions&quot;
<i>3910</i>&nbsp;                }
<b class="nc"><i>3911</i>&nbsp;                break;</b>
<i>3912</i>&nbsp;            case MTH: {
<i>3913</i>&nbsp;                owntype = checkMethod(site, sym,
<b class="nc"><i>3914</i>&nbsp;                        new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),</b>
<i>3915</i>&nbsp;                        env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
<b class="nc"><i>3916</i>&nbsp;                        resultInfo.pt.getTypeArguments());</b>
<b class="nc"><i>3917</i>&nbsp;                break;</b>
<b class="nc"><i>3918</i>&nbsp;            }</b>
<b class="nc"><i>3919</i>&nbsp;            case PCK: case ERR:</b>
<i>3920</i>&nbsp;                owntype = sym.type;
<b class="nc"><i>3921</i>&nbsp;                break;</b>
<b class="nc"><i>3922</i>&nbsp;            default:</b>
<b class="nc"><i>3923</i>&nbsp;                throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +</b>
<b class="nc"><i>3924</i>&nbsp;                                         &quot; in tree &quot; + tree);</b>
<b class="nc"><i>3925</i>&nbsp;            }</b>
<b class="nc"><i>3926</i>&nbsp;</b>
<b class="nc"><i>3927</i>&nbsp;            // Emit a `deprecation&#39; warning if symbol is deprecated.</b>
<i>3928</i>&nbsp;            // (for constructors (but not for constructor references), the error
<i>3929</i>&nbsp;            // was given when the constructor was resolved)
<b class="nc"><i>3930</i>&nbsp;</b>
<b class="nc"><i>3931</i>&nbsp;            if (sym.name != names.init || tree.hasTag(REFERENCE)) {</b>
<i>3932</i>&nbsp;                chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
<b class="nc"><i>3933</i>&nbsp;                chk.checkSunAPI(tree.pos(), sym);</b>
<b class="nc"><i>3934</i>&nbsp;                chk.checkProfile(tree.pos(), sym);</b>
<b class="nc"><i>3935</i>&nbsp;            }</b>
<b class="nc"><i>3936</i>&nbsp;</b>
<b class="nc"><i>3937</i>&nbsp;            // If symbol is a variable, check that its type and</b>
<b class="nc"><i>3938</i>&nbsp;            // kind are compatible with the prototype and protokind.</b>
<b class="nc"><i>3939</i>&nbsp;            return check(tree, owntype, sym.kind.toSelector(), resultInfo);</b>
<b class="nc"><i>3940</i>&nbsp;        }</b>
<b class="nc"><i>3941</i>&nbsp;</b>
<b class="nc"><i>3942</i>&nbsp;        /** Check that variable is initialized and evaluate the variable&#39;s</b>
<b class="nc"><i>3943</i>&nbsp;         *  initializer, if not yet done. Also check that variable is not</b>
<b class="nc"><i>3944</i>&nbsp;         *  referenced before it is defined.</b>
<i>3945</i>&nbsp;         *  @param tree    The tree making up the variable reference.
<i>3946</i>&nbsp;         *  @param env     The current environment.
<b class="nc"><i>3947</i>&nbsp;         *  @param v       The variable&#39;s symbol.</b>
<b class="nc"><i>3948</i>&nbsp;         */</b>
<b class="nc"><i>3949</i>&nbsp;        private void checkInit(JCTree tree,</b>
<b class="nc"><i>3950</i>&nbsp;                               Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>3951</i>&nbsp;                               VarSymbol v,</b>
<i>3952</i>&nbsp;                               boolean onlyWarning) {
<b class="nc"><i>3953</i>&nbsp;            // A forward reference is diagnosed if the declaration position</b>
<i>3954</i>&nbsp;            // of the variable is greater than the current tree position
<b class="nc"><i>3955</i>&nbsp;            // and the tree and variable definition occur in the same class</b>
<i>3956</i>&nbsp;            // definition.  Note that writes don&#39;t count as references.
<i>3957</i>&nbsp;            // This check applies only to class and instance
<b class="nc"><i>3958</i>&nbsp;            // variables.  Local variables follow different scope rules,</b>
<i>3959</i>&nbsp;            // and are subject to definite assignment checking.
<i>3960</i>&nbsp;            Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
<i>3961</i>&nbsp;            if (initEnv != null &amp;&amp;
<b class="nc"><i>3962</i>&nbsp;                (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;</b>
<b class="nc"><i>3963</i>&nbsp;                v.owner.kind == TYP &amp;&amp;</b>
<b class="nc"><i>3964</i>&nbsp;                v.owner == env.info.scope.owner.enclClass() &amp;&amp;</b>
<b class="nc"><i>3965</i>&nbsp;                ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;</b>
<b class="nc"><i>3966</i>&nbsp;                (!env.tree.hasTag(ASSIGN) ||</b>
<b class="nc"><i>3967</i>&nbsp;                 TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {</b>
<i>3968</i>&nbsp;                if (!onlyWarning || isStaticEnumField(v)) {
<b class="nc"><i>3969</i>&nbsp;                    Error errkey = (initEnv.info.enclVar == v) ?</b>
<i>3970</i>&nbsp;                                Errors.IllegalSelfRef : Errors.IllegalForwardRef;
<i>3971</i>&nbsp;                    log.error(tree.pos(), errkey);
<b class="nc"><i>3972</i>&nbsp;                } else if (useBeforeDeclarationWarning) {</b>
<b class="nc"><i>3973</i>&nbsp;                    Warning warnkey = (initEnv.info.enclVar == v) ?</b>
<b class="nc"><i>3974</i>&nbsp;                                Warnings.SelfRef(v) : Warnings.ForwardRef(v);</b>
<b class="nc"><i>3975</i>&nbsp;                    log.warning(tree.pos(), warnkey);</b>
<b class="nc"><i>3976</i>&nbsp;                }</b>
<i>3977</i>&nbsp;            }
<b class="nc"><i>3978</i>&nbsp;</b>
<b class="nc"><i>3979</i>&nbsp;            v.getConstValue(); // ensure initializer is evaluated</b>
<b class="nc"><i>3980</i>&nbsp;</b>
<i>3981</i>&nbsp;            checkEnumInitializer(tree, env, v);
<b class="nc"><i>3982</i>&nbsp;        }</b>
<i>3983</i>&nbsp;
<b class="nc"><i>3984</i>&nbsp;        /**</b>
<b class="nc"><i>3985</i>&nbsp;         * Returns the enclosing init environment associated with this env (if any). An init env</b>
<b class="nc"><i>3986</i>&nbsp;         * can be either a field declaration env or a static/instance initializer env.</b>
<i>3987</i>&nbsp;         */
<b class="nc"><i>3988</i>&nbsp;        Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>3989</i>&nbsp;            while (true) {</b>
<b class="nc"><i>3990</i>&nbsp;                switch (env.tree.getTag()) {</b>
<i>3991</i>&nbsp;                    case VARDEF:
<b class="nc"><i>3992</i>&nbsp;                        JCVariableDecl vdecl = (JCVariableDecl)env.tree;</b>
<i>3993</i>&nbsp;                        if (vdecl.sym.owner.kind == TYP) {
<b class="nc"><i>3994</i>&nbsp;                            //field</b>
<b class="nc"><i>3995</i>&nbsp;                            return env;</b>
<b class="nc"><i>3996</i>&nbsp;                        }</b>
<b class="nc"><i>3997</i>&nbsp;                        break;</b>
<b class="nc"><i>3998</i>&nbsp;                    case BLOCK:</b>
<b class="nc"><i>3999</i>&nbsp;                        if (env.next.tree.hasTag(CLASSDEF)) {</b>
<i>4000</i>&nbsp;                            //instance/static initializer
<b class="nc"><i>4001</i>&nbsp;                            return env;</b>
<i>4002</i>&nbsp;                        }
<i>4003</i>&nbsp;                        break;
<i>4004</i>&nbsp;                    case METHODDEF:
<b class="nc"><i>4005</i>&nbsp;                    case CLASSDEF:</b>
<b class="nc"><i>4006</i>&nbsp;                    case TOPLEVEL:</b>
<i>4007</i>&nbsp;                        return null;
<i>4008</i>&nbsp;                }
<i>4009</i>&nbsp;                Assert.checkNonNull(env.next);
<b class="nc"><i>4010</i>&nbsp;                env = env.next;</b>
<i>4011</i>&nbsp;            }
<b class="nc"><i>4012</i>&nbsp;        }</b>
<b class="nc"><i>4013</i>&nbsp;</b>
<i>4014</i>&nbsp;        /**
<i>4015</i>&nbsp;         * Check for illegal references to static members of enum.  In
<b class="nc"><i>4016</i>&nbsp;         * an enum type, constructors and initializers may not</b>
<i>4017</i>&nbsp;         * reference its static members unless they are constant.
<b class="nc"><i>4018</i>&nbsp;         *</b>
<i>4019</i>&nbsp;         * @param tree    The tree making up the variable reference.
<i>4020</i>&nbsp;         * @param env     The current environment.
<i>4021</i>&nbsp;         * @param v       The variable&#39;s symbol.
<i>4022</i>&nbsp;         * @jls  section 8.9 Enums
<b class="nc"><i>4023</i>&nbsp;         */</b>
<b class="nc"><i>4024</i>&nbsp;        private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {</b>
<i>4025</i>&nbsp;            // JLS:
<b class="nc"><i>4026</i>&nbsp;            //</b>
<b class="nc"><i>4027</i>&nbsp;            // &quot;It is a compile-time error to reference a static field</b>
<b class="nc"><i>4028</i>&nbsp;            // of an enum type that is not a compile-time constant</b>
<b class="nc"><i>4029</i>&nbsp;            // (15.28) from constructors, instance initializer blocks,</b>
<i>4030</i>&nbsp;            // or instance variable initializer expressions of that
<b class="nc"><i>4031</i>&nbsp;            // type. It is a compile-time error for the constructors,</b>
<i>4032</i>&nbsp;            // instance initializer blocks, or instance variable
<b class="nc"><i>4033</i>&nbsp;            // initializer expressions of an enum constant e to refer</b>
<b class="nc"><i>4034</i>&nbsp;            // to itself or to an enum constant of the same type that</b>
<i>4035</i>&nbsp;            // is declared to the right of e.&quot;
<b class="nc"><i>4036</i>&nbsp;            if (isStaticEnumField(v)) {</b>
<i>4037</i>&nbsp;                ClassSymbol enclClass = env.info.scope.owner.enclClass();
<i>4038</i>&nbsp;
<i>4039</i>&nbsp;                if (enclClass == null || enclClass.owner == null)
<i>4040</i>&nbsp;                    return;
<b class="nc"><i>4041</i>&nbsp;</b>
<b class="nc"><i>4042</i>&nbsp;                // See if the enclosing class is the enum (or a</b>
<b class="nc"><i>4043</i>&nbsp;                // subclass thereof) declaring v.  If not, this</b>
<b class="nc"><i>4044</i>&nbsp;                // reference is OK.</b>
<i>4045</i>&nbsp;                if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
<b class="nc"><i>4046</i>&nbsp;                    return;</b>
<b class="nc"><i>4047</i>&nbsp;</b>
<i>4048</i>&nbsp;                // If the reference isn&#39;t from an initializer, then
<b class="nc"><i>4049</i>&nbsp;                // the reference is OK.</b>
<i>4050</i>&nbsp;                if (!Resolve.isInitializer(env))
<i>4051</i>&nbsp;                    return;
<i>4052</i>&nbsp;
<b class="nc"><i>4053</i>&nbsp;                log.error(tree.pos(), Errors.IllegalEnumStaticRef);</b>
<b class="nc"><i>4054</i>&nbsp;            }</b>
<b class="nc"><i>4055</i>&nbsp;        }</b>
<b class="nc"><i>4056</i>&nbsp;</b>
<i>4057</i>&nbsp;        /** Is the given symbol a static, non-constant field of an Enum?
<b class="nc"><i>4058</i>&nbsp;         *  Note: enum literals should not be regarded as such</b>
<i>4059</i>&nbsp;         */
<i>4060</i>&nbsp;        private boolean isStaticEnumField(VarSymbol v) {
<i>4061</i>&nbsp;            return Flags.isEnum(v.owner) &amp;&amp;
<i>4062</i>&nbsp;                   Flags.isStatic(v) &amp;&amp;
<i>4063</i>&nbsp;                   !Flags.isConstant(v) &amp;&amp;
<i>4064</i>&nbsp;                   v.name != names._class;
<b class="nc"><i>4065</i>&nbsp;        }</b>
<b class="nc"><i>4066</i>&nbsp;</b>
<b class="nc"><i>4067</i>&nbsp;    /**</b>
<i>4068</i>&nbsp;     * Check that method arguments conform to its instantiation.
<b class="nc"><i>4069</i>&nbsp;     **/</b>
<b class="nc"><i>4070</i>&nbsp;    public Type checkMethod(Type site,</b>
<i>4071</i>&nbsp;                            final Symbol sym,
<b class="nc"><i>4072</i>&nbsp;                            ResultInfo resultInfo,</b>
<b class="nc"><i>4073</i>&nbsp;                            Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>4074</i>&nbsp;                            final List&lt;JCExpression&gt; argtrees,</b>
<b class="nc"><i>4075</i>&nbsp;                            List&lt;Type&gt; argtypes,</b>
<i>4076</i>&nbsp;                            List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>4077</i>&nbsp;        // Test (5): if symbol is an instance method of a raw type, issue</b>
<b class="nc"><i>4078</i>&nbsp;        // an unchecked warning if its argument types change under erasure.</b>
<b class="nc"><i>4079</i>&nbsp;        if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;</b>
<b class="nc"><i>4080</i>&nbsp;            (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {</b>
<i>4081</i>&nbsp;            Type s = types.asOuterSuper(site, sym.owner);
<i>4082</i>&nbsp;            if (s != null &amp;&amp; s.isRaw() &amp;&amp;
<b class="nc"><i>4083</i>&nbsp;                !types.isSameTypes(sym.type.getParameterTypes(),</b>
<b class="nc"><i>4084</i>&nbsp;                                   sym.erasure(types).getParameterTypes())) {</b>
<b class="nc"><i>4085</i>&nbsp;                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));</b>
<b class="nc"><i>4086</i>&nbsp;            }</b>
<b class="nc"><i>4087</i>&nbsp;        }</b>
<i>4088</i>&nbsp;
<i>4089</i>&nbsp;        if (env.info.defaultSuperCallSite != null) {
<i>4090</i>&nbsp;            for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
<i>4091</i>&nbsp;                if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
<i>4092</i>&nbsp;                        types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
<b class="nc"><i>4093</i>&nbsp;                List&lt;MethodSymbol&gt; icand_sup =</b>
<i>4094</i>&nbsp;                        types.interfaceCandidates(sup, (MethodSymbol)sym);
<b class="nc"><i>4095</i>&nbsp;                if (icand_sup.nonEmpty() &amp;&amp;</b>
<b class="nc"><i>4096</i>&nbsp;                        icand_sup.head != sym &amp;&amp;</b>
<i>4097</i>&nbsp;                        icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
<i>4098</i>&nbsp;                    log.error(env.tree.pos(),
<i>4099</i>&nbsp;                              Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
<i>4100</i>&nbsp;                    break;
<i>4101</i>&nbsp;                }
<i>4102</i>&nbsp;            }
<b class="nc"><i>4103</i>&nbsp;            env.info.defaultSuperCallSite = null;</b>
<i>4104</i>&nbsp;        }
<i>4105</i>&nbsp;
<i>4106</i>&nbsp;        if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
<b class="nc"><i>4107</i>&nbsp;            JCMethodInvocation app = (JCMethodInvocation)env.tree;</b>
<b class="nc"><i>4108</i>&nbsp;            if (app.meth.hasTag(SELECT) &amp;&amp;</b>
<b class="nc"><i>4109</i>&nbsp;                    !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {</b>
<b class="nc"><i>4110</i>&nbsp;                log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));</b>
<i>4111</i>&nbsp;            }
<i>4112</i>&nbsp;        }
<i>4113</i>&nbsp;
<i>4114</i>&nbsp;        // Compute the identifier&#39;s instantiated type.
<i>4115</i>&nbsp;        // For methods, we need to compute the instance type by
<i>4116</i>&nbsp;        // Resolve.instantiate from the symbol&#39;s type as well as
<b class="nc"><i>4117</i>&nbsp;        // any type arguments and value arguments.</b>
<i>4118</i>&nbsp;        Warner noteWarner = new Warner();
<i>4119</i>&nbsp;        try {
<b class="nc"><i>4120</i>&nbsp;            Type owntype = rs.checkMethod(</b>
<i>4121</i>&nbsp;                    env,
<i>4122</i>&nbsp;                    site,
<i>4123</i>&nbsp;                    sym,
<b class="nc"><i>4124</i>&nbsp;                    resultInfo,</b>
<b class="nc"><i>4125</i>&nbsp;                    argtypes,</b>
<i>4126</i>&nbsp;                    typeargtypes,
<b class="nc"><i>4127</i>&nbsp;                    noteWarner);</b>
<i>4128</i>&nbsp;
<i>4129</i>&nbsp;            DeferredAttr.DeferredTypeMap checkDeferredMap =
<i>4130</i>&nbsp;                deferredAttr.new DeferredTypeMap(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
<i>4131</i>&nbsp;
<i>4132</i>&nbsp;            argtypes = argtypes.map(checkDeferredMap);
<i>4133</i>&nbsp;
<b class="nc"><i>4134</i>&nbsp;            if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {</b>
<b class="nc"><i>4135</i>&nbsp;                chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),</b>
<i>4136</i>&nbsp;                        sym.name,
<i>4137</i>&nbsp;                        rs.methodArguments(sym.type.getParameterTypes()),
<b class="nc"><i>4138</i>&nbsp;                        rs.methodArguments(argtypes.map(checkDeferredMap)),</b>
<b class="nc"><i>4139</i>&nbsp;                        kindName(sym.location()),</b>
<b class="nc"><i>4140</i>&nbsp;                        sym.location()));</b>
<i>4141</i>&nbsp;                if (resultInfo.pt != Infer.anyPoly ||
<i>4142</i>&nbsp;                        !owntype.hasTag(METHOD) ||
<i>4143</i>&nbsp;                        !owntype.isPartial()) {
<i>4144</i>&nbsp;                    //if this is not a partially inferred method type, erase return type. Otherwise,
<i>4145</i>&nbsp;                    //erasure is carried out in PartiallyInferredMethodType.check().
<b class="nc"><i>4146</i>&nbsp;                    owntype = new MethodType(owntype.getParameterTypes(),</b>
<i>4147</i>&nbsp;                            types.erasure(owntype.getReturnType()),
<i>4148</i>&nbsp;                            types.erasure(owntype.getThrownTypes()),
<i>4149</i>&nbsp;                            syms.methodClass);
<i>4150</i>&nbsp;                }
<i>4151</i>&nbsp;            }
<b class="nc"><i>4152</i>&nbsp;</b>
<b class="nc"><i>4153</i>&nbsp;            PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;</b>
<i>4154</i>&nbsp;                 sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
<i>4155</i>&nbsp;                 PolyKind.POLY : PolyKind.STANDALONE;
<i>4156</i>&nbsp;            TreeInfo.setPolyKind(env.tree, pkind);
<b class="nc"><i>4157</i>&nbsp;</b>
<b class="nc"><i>4158</i>&nbsp;            return (resultInfo.pt == Infer.anyPoly) ?</b>
<b class="nc"><i>4159</i>&nbsp;                    owntype :</b>
<b class="nc"><i>4160</i>&nbsp;                    chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),</b>
<i>4161</i>&nbsp;                            resultInfo.checkContext.inferenceContext());
<i>4162</i>&nbsp;        } catch (Infer.InferenceException ex) {
<i>4163</i>&nbsp;            //invalid target type - propagate exception outwards or report error
<i>4164</i>&nbsp;            //depending on the current check context
<i>4165</i>&nbsp;            resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
<b class="nc"><i>4166</i>&nbsp;            return types.createErrorType(site);</b>
<i>4167</i>&nbsp;        } catch (Resolve.InapplicableMethodException ex) {
<i>4168</i>&nbsp;            final JCDiagnostic diag = ex.getDiagnostic();
<i>4169</i>&nbsp;            Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
<i>4170</i>&nbsp;                @Override
<i>4171</i>&nbsp;                protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
<i>4172</i>&nbsp;                    return new Pair&lt;&gt;(sym, diag);
<b class="nc"><i>4173</i>&nbsp;                }</b>
<b class="nc"><i>4174</i>&nbsp;            };</b>
<i>4175</i>&nbsp;            List&lt;Type&gt; argtypes2 = argtypes.map(
<b class="nc"><i>4176</i>&nbsp;                    rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));</b>
<i>4177</i>&nbsp;            JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
<i>4178</i>&nbsp;                    env.tree, sym, site, sym.name, argtypes2, typeargtypes);
<i>4179</i>&nbsp;            log.report(errDiag);
<i>4180</i>&nbsp;            return types.createErrorType(site);
<i>4181</i>&nbsp;        }
<i>4182</i>&nbsp;    }
<i>4183</i>&nbsp;
<b class="nc"><i>4184</i>&nbsp;    public void visitLiteral(JCLiteral tree) {</b>
<i>4185</i>&nbsp;        result = check(tree, litType(tree.typetag).constType(tree.value),
<b class="nc"><i>4186</i>&nbsp;                KindSelector.VAL, resultInfo);</b>
<b class="nc"><i>4187</i>&nbsp;    }</b>
<b class="nc"><i>4188</i>&nbsp;    //where</b>
<b class="nc"><i>4189</i>&nbsp;    /** Return the type of a literal with given type tag.</b>
<i>4190</i>&nbsp;     */
<i>4191</i>&nbsp;    Type litType(TypeTag tag) {
<i>4192</i>&nbsp;        return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
<i>4193</i>&nbsp;    }
<i>4194</i>&nbsp;
<i>4195</i>&nbsp;    public void visitTypeIdent(JCPrimitiveTypeTree tree) {
<i>4196</i>&nbsp;        result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
<i>4197</i>&nbsp;    }
<i>4198</i>&nbsp;
<i>4199</i>&nbsp;    public void visitTypeArray(JCArrayTypeTree tree) {
<b class="nc"><i>4200</i>&nbsp;        Type etype = attribType(tree.elemtype, env);</b>
<b class="nc"><i>4201</i>&nbsp;        Type type = new ArrayType(etype, syms.arrayClass);</b>
<b class="nc"><i>4202</i>&nbsp;        result = check(tree, type, KindSelector.TYP, resultInfo);</b>
<b class="nc"><i>4203</i>&nbsp;    }</b>
<b class="nc"><i>4204</i>&nbsp;</b>
<i>4205</i>&nbsp;    /** Visitor method for parameterized types.
<i>4206</i>&nbsp;     *  Bound checking is left until later, since types are attributed
<i>4207</i>&nbsp;     *  before supertype structure is completely known
<i>4208</i>&nbsp;     */
<i>4209</i>&nbsp;    public void visitTypeApply(JCTypeApply tree) {
<i>4210</i>&nbsp;        Type owntype = types.createErrorType(tree.type);
<b class="nc"><i>4211</i>&nbsp;</b>
<i>4212</i>&nbsp;        // Attribute functor part of application and make sure it&#39;s a class.
<i>4213</i>&nbsp;        Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
<i>4214</i>&nbsp;
<b class="nc"><i>4215</i>&nbsp;        // Attribute type parameters</b>
<i>4216</i>&nbsp;        List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
<b class="nc"><i>4217</i>&nbsp;</b>
<b class="nc"><i>4218</i>&nbsp;        if (clazztype.hasTag(CLASS)) {</b>
<i>4219</i>&nbsp;            List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
<b class="nc"><i>4220</i>&nbsp;            if (actuals.isEmpty()) //diamond</b>
<b class="nc"><i>4221</i>&nbsp;                actuals = formals;</b>
<i>4222</i>&nbsp;
<i>4223</i>&nbsp;            if (actuals.length() == formals.length()) {
<b class="nc"><i>4224</i>&nbsp;                List&lt;Type&gt; a = actuals;</b>
<b class="nc"><i>4225</i>&nbsp;                List&lt;Type&gt; f = formals;</b>
<i>4226</i>&nbsp;                while (a.nonEmpty()) {
<i>4227</i>&nbsp;                    a.head = a.head.withTypeVar(f.head);
<i>4228</i>&nbsp;                    a = a.tail;
<i>4229</i>&nbsp;                    f = f.tail;
<i>4230</i>&nbsp;                }
<b class="nc"><i>4231</i>&nbsp;                // Compute the proper generic outer</b>
<b class="nc"><i>4232</i>&nbsp;                Type clazzOuter = clazztype.getEnclosingType();</b>
<i>4233</i>&nbsp;                if (clazzOuter.hasTag(CLASS)) {
<i>4234</i>&nbsp;                    Type site;
<b class="nc"><i>4235</i>&nbsp;                    JCExpression clazz = TreeInfo.typeIn(tree.clazz);</b>
<i>4236</i>&nbsp;                    if (clazz.hasTag(IDENT)) {
<i>4237</i>&nbsp;                        site = env.enclClass.sym.type;
<i>4238</i>&nbsp;                    } else if (clazz.hasTag(SELECT)) {
<i>4239</i>&nbsp;                        site = ((JCFieldAccess) clazz).selected.type;
<i>4240</i>&nbsp;                    } else throw new AssertionError(&quot;&quot;+tree);
<i>4241</i>&nbsp;                    if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
<b class="nc"><i>4242</i>&nbsp;                        if (site.hasTag(CLASS))</b>
<b class="nc"><i>4243</i>&nbsp;                            site = types.asOuterSuper(site, clazzOuter.tsym);</b>
<b class="nc"><i>4244</i>&nbsp;                        if (site == null)</b>
<i>4245</i>&nbsp;                            site = types.erasure(clazzOuter);
<i>4246</i>&nbsp;                        clazzOuter = site;
<b class="nc"><i>4247</i>&nbsp;                    }</b>
<i>4248</i>&nbsp;                }
<b class="nc"><i>4249</i>&nbsp;                owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,</b>
<b class="nc"><i>4250</i>&nbsp;                                        clazztype.getMetadata());</b>
<b class="nc"><i>4251</i>&nbsp;            } else {</b>
<i>4252</i>&nbsp;                if (formals.length() != 0) {
<i>4253</i>&nbsp;                    log.error(tree.pos(),
<b class="nc"><i>4254</i>&nbsp;                              Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));</b>
<b class="nc"><i>4255</i>&nbsp;                } else {</b>
<i>4256</i>&nbsp;                    log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
<b class="nc"><i>4257</i>&nbsp;                }</b>
<i>4258</i>&nbsp;                owntype = types.createErrorType(tree.type);
<b class="nc"><i>4259</i>&nbsp;            }</b>
<i>4260</i>&nbsp;        }
<i>4261</i>&nbsp;        result = check(tree, owntype, KindSelector.TYP, resultInfo);
<b class="nc"><i>4262</i>&nbsp;    }</b>
<i>4263</i>&nbsp;
<i>4264</i>&nbsp;    public void visitTypeUnion(JCTypeUnion tree) {
<b class="nc"><i>4265</i>&nbsp;        ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();</b>
<i>4266</i>&nbsp;        ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
<i>4267</i>&nbsp;        for (JCExpression typeTree : tree.alternatives) {
<b class="nc"><i>4268</i>&nbsp;            Type ctype = attribType(typeTree, env);</b>
<b class="nc"><i>4269</i>&nbsp;            ctype = chk.checkType(typeTree.pos(),</b>
<i>4270</i>&nbsp;                          chk.checkClassType(typeTree.pos(), ctype),
<i>4271</i>&nbsp;                          syms.throwableType);
<b class="nc"><i>4272</i>&nbsp;            if (!ctype.isErroneous()) {</b>
<i>4273</i>&nbsp;                //check that alternatives of a union type are pairwise
<b class="nc"><i>4274</i>&nbsp;                //unrelated w.r.t. subtyping</b>
<b class="nc"><i>4275</i>&nbsp;                if (chk.intersects(ctype,  multicatchTypes.toList())) {</b>
<b class="nc"><i>4276</i>&nbsp;                    for (Type t : multicatchTypes) {</b>
<i>4277</i>&nbsp;                        boolean sub = types.isSubtype(ctype, t);
<b class="nc"><i>4278</i>&nbsp;                        boolean sup = types.isSubtype(t, ctype);</b>
<b class="nc"><i>4279</i>&nbsp;                        if (sub || sup) {</b>
<b class="nc"><i>4280</i>&nbsp;                            //assume &#39;a&#39; &lt;: &#39;b&#39;</b>
<b class="nc"><i>4281</i>&nbsp;                            Type a = sub ? ctype : t;</b>
<i>4282</i>&nbsp;                            Type b = sub ? t : ctype;
<i>4283</i>&nbsp;                            log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
<i>4284</i>&nbsp;                        }
<i>4285</i>&nbsp;                    }
<i>4286</i>&nbsp;                }
<i>4287</i>&nbsp;                multicatchTypes.append(ctype);
<i>4288</i>&nbsp;                if (all_multicatchTypes != null)
<i>4289</i>&nbsp;                    all_multicatchTypes.append(ctype);
<i>4290</i>&nbsp;            } else {
<i>4291</i>&nbsp;                if (all_multicatchTypes == null) {
<b class="nc"><i>4292</i>&nbsp;                    all_multicatchTypes = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>4293</i>&nbsp;                    all_multicatchTypes.appendList(multicatchTypes);</b>
<i>4294</i>&nbsp;                }
<i>4295</i>&nbsp;                all_multicatchTypes.append(ctype);
<b class="nc"><i>4296</i>&nbsp;            }</b>
<b class="nc"><i>4297</i>&nbsp;        }</b>
<i>4298</i>&nbsp;        Type t = check(tree, types.lub(multicatchTypes.toList()),
<b class="nc"><i>4299</i>&nbsp;                KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));</b>
<b class="nc"><i>4300</i>&nbsp;        if (t.hasTag(CLASS)) {</b>
<b class="nc"><i>4301</i>&nbsp;            List&lt;Type&gt; alternatives =</b>
<i>4302</i>&nbsp;                ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
<i>4303</i>&nbsp;            t = new UnionClassType((ClassType) t, alternatives);
<b class="nc"><i>4304</i>&nbsp;        }</b>
<i>4305</i>&nbsp;        tree.type = result = t;
<i>4306</i>&nbsp;    }
<i>4307</i>&nbsp;
<b class="nc"><i>4308</i>&nbsp;    public void visitTypeIntersection(JCTypeIntersection tree) {</b>
<b class="nc"><i>4309</i>&nbsp;        attribTypes(tree.bounds, env);</b>
<b class="nc"><i>4310</i>&nbsp;        tree.type = result = checkIntersection(tree, tree.bounds);</b>
<i>4311</i>&nbsp;    }
<i>4312</i>&nbsp;
<b class="nc"><i>4313</i>&nbsp;    public void visitTypeParameter(JCTypeParameter tree) {</b>
<b class="nc"><i>4314</i>&nbsp;        TypeVar typeVar = (TypeVar) tree.type;</b>
<b class="nc"><i>4315</i>&nbsp;</b>
<i>4316</i>&nbsp;        if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
<b class="nc"><i>4317</i>&nbsp;            annotate.annotateTypeParameterSecondStage(tree, tree.annotations);</b>
<b class="nc"><i>4318</i>&nbsp;        }</b>
<i>4319</i>&nbsp;
<i>4320</i>&nbsp;        if (!typeVar.bound.isErroneous()) {
<i>4321</i>&nbsp;            //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
<b class="nc"><i>4322</i>&nbsp;            typeVar.bound = checkIntersection(tree, tree.bounds);</b>
<b class="nc"><i>4323</i>&nbsp;        }</b>
<i>4324</i>&nbsp;    }
<b class="nc"><i>4325</i>&nbsp;</b>
<b class="nc"><i>4326</i>&nbsp;    Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {</b>
<i>4327</i>&nbsp;        Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
<b class="nc"><i>4328</i>&nbsp;        if (bounds.nonEmpty()) {</b>
<i>4329</i>&nbsp;            // accept class or interface or typevar as first bound.
<b class="nc"><i>4330</i>&nbsp;            bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);</b>
<i>4331</i>&nbsp;            boundSet.add(types.erasure(bounds.head.type));
<i>4332</i>&nbsp;            if (bounds.head.type.isErroneous()) {
<i>4333</i>&nbsp;                return bounds.head.type;
<b class="nc"><i>4334</i>&nbsp;            }</b>
<b class="nc"><i>4335</i>&nbsp;            else if (bounds.head.type.hasTag(TYPEVAR)) {</b>
<b class="nc"><i>4336</i>&nbsp;                // if first bound was a typevar, do not accept further bounds.</b>
<i>4337</i>&nbsp;                if (bounds.tail.nonEmpty()) {
<i>4338</i>&nbsp;                    log.error(bounds.tail.head.pos(),
<i>4339</i>&nbsp;                              Errors.TypeVarMayNotBeFollowedByOtherBounds);
<i>4340</i>&nbsp;                    return bounds.head.type;
<i>4341</i>&nbsp;                }
<b class="nc"><i>4342</i>&nbsp;            } else {</b>
<i>4343</i>&nbsp;                // if first bound was a class or interface, accept only interfaces
<b class="nc"><i>4344</i>&nbsp;                // as further bounds.</b>
<i>4345</i>&nbsp;                for (JCExpression bound : bounds.tail) {
<b class="nc"><i>4346</i>&nbsp;                    bound.type = checkBase(bound.type, bound, env, false, true, false);</b>
<b class="nc"><i>4347</i>&nbsp;                    if (bound.type.isErroneous()) {</b>
<b class="nc"><i>4348</i>&nbsp;                        bounds = List.of(bound);</b>
<i>4349</i>&nbsp;                    }
<i>4350</i>&nbsp;                    else if (bound.type.hasTag(CLASS)) {
<i>4351</i>&nbsp;                        chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
<b class="nc"><i>4352</i>&nbsp;                    }</b>
<b class="nc"><i>4353</i>&nbsp;                }</b>
<i>4354</i>&nbsp;            }
<i>4355</i>&nbsp;        }
<i>4356</i>&nbsp;
<b class="nc"><i>4357</i>&nbsp;        if (bounds.length() == 0) {</b>
<i>4358</i>&nbsp;            return syms.objectType;
<i>4359</i>&nbsp;        } else if (bounds.length() == 1) {
<b class="nc"><i>4360</i>&nbsp;            return bounds.head.type;</b>
<i>4361</i>&nbsp;        } else {
<b class="nc"><i>4362</i>&nbsp;            Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));</b>
<i>4363</i>&nbsp;            // ... the variable&#39;s bound is a class type flagged COMPOUND
<b class="nc"><i>4364</i>&nbsp;            // (see comment for TypeVar.bound).</b>
<i>4365</i>&nbsp;            // In this case, generate a class tree that represents the
<i>4366</i>&nbsp;            // bound class, ...
<b class="nc"><i>4367</i>&nbsp;            JCExpression extending;</b>
<b class="nc"><i>4368</i>&nbsp;            List&lt;JCExpression&gt; implementing;</b>
<b class="nc"><i>4369</i>&nbsp;            if (!bounds.head.type.isInterface()) {</b>
<b class="nc"><i>4370</i>&nbsp;                extending = bounds.head;</b>
<b class="nc"><i>4371</i>&nbsp;                implementing = bounds.tail;</b>
<b class="nc"><i>4372</i>&nbsp;            } else {</b>
<i>4373</i>&nbsp;                extending = null;
<b class="nc"><i>4374</i>&nbsp;                implementing = bounds;</b>
<b class="nc"><i>4375</i>&nbsp;            }</b>
<i>4376</i>&nbsp;            JCClassDecl cd = make.at(tree).ClassDef(
<i>4377</i>&nbsp;                make.Modifiers(PUBLIC | ABSTRACT),
<i>4378</i>&nbsp;                names.empty, List.nil(),
<i>4379</i>&nbsp;                extending, implementing, List.nil());
<b class="nc"><i>4380</i>&nbsp;</b>
<i>4381</i>&nbsp;            ClassSymbol c = (ClassSymbol)owntype.tsym;
<i>4382</i>&nbsp;            Assert.check((c.flags() &amp; COMPOUND) != 0);
<b class="nc"><i>4383</i>&nbsp;            cd.sym = c;</b>
<i>4384</i>&nbsp;            c.sourcefile = env.toplevel.sourcefile;
<i>4385</i>&nbsp;
<b class="nc"><i>4386</i>&nbsp;            // ... and attribute the bound class</b>
<b class="nc"><i>4387</i>&nbsp;            c.flags_field |= UNATTRIBUTED;</b>
<b class="nc"><i>4388</i>&nbsp;            Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);</b>
<b class="nc"><i>4389</i>&nbsp;            typeEnvs.put(c, cenv);</b>
<b class="nc"><i>4390</i>&nbsp;            attribClass(c);</b>
<i>4391</i>&nbsp;            return owntype;
<b class="nc"><i>4392</i>&nbsp;        }</b>
<i>4393</i>&nbsp;    }
<b class="nc"><i>4394</i>&nbsp;</b>
<i>4395</i>&nbsp;    public void visitWildcard(JCWildcard tree) {
<i>4396</i>&nbsp;        //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
<b class="nc"><i>4397</i>&nbsp;        Type type = (tree.kind.kind == BoundKind.UNBOUND)</b>
<i>4398</i>&nbsp;            ? syms.objectType
<i>4399</i>&nbsp;            : attribType(tree.inner, env);
<i>4400</i>&nbsp;        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),
<i>4401</i>&nbsp;                                              tree.kind.kind,
<b class="nc"><i>4402</i>&nbsp;                                              syms.boundClass),</b>
<b class="nc"><i>4403</i>&nbsp;                KindSelector.TYP, resultInfo);</b>
<i>4404</i>&nbsp;    }
<b class="nc"><i>4405</i>&nbsp;</b>
<i>4406</i>&nbsp;    public void visitAnnotation(JCAnnotation tree) {
<i>4407</i>&nbsp;        Assert.error(&quot;should be handled in annotate&quot;);
<i>4408</i>&nbsp;    }
<b class="nc"><i>4409</i>&nbsp;</b>
<i>4410</i>&nbsp;    public void visitAnnotatedType(JCAnnotatedType tree) {
<i>4411</i>&nbsp;        attribAnnotationTypes(tree.annotations, env);
<b class="nc"><i>4412</i>&nbsp;        Type underlyingType = attribType(tree.underlyingType, env);</b>
<b class="nc"><i>4413</i>&nbsp;        Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);</b>
<i>4414</i>&nbsp;
<i>4415</i>&nbsp;        if (!env.info.isNewClass)
<i>4416</i>&nbsp;            annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
<i>4417</i>&nbsp;        result = tree.type = annotatedType;
<i>4418</i>&nbsp;    }
<b class="nc"><i>4419</i>&nbsp;</b>
<b class="nc"><i>4420</i>&nbsp;    public void visitErroneous(JCErroneous tree) {</b>
<b class="nc"><i>4421</i>&nbsp;        if (tree.errs != null)</b>
<i>4422</i>&nbsp;            for (JCTree err : tree.errs)
<i>4423</i>&nbsp;                attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
<b class="nc"><i>4424</i>&nbsp;        result = tree.type = syms.errType;</b>
<i>4425</i>&nbsp;    }
<i>4426</i>&nbsp;
<i>4427</i>&nbsp;    /** Default visitor method for all other trees.
<i>4428</i>&nbsp;     */
<i>4429</i>&nbsp;    public void visitTree(JCTree tree) {
<b class="nc"><i>4430</i>&nbsp;        throw new AssertionError();</b>
<i>4431</i>&nbsp;    }
<b class="nc"><i>4432</i>&nbsp;</b>
<b class="nc"><i>4433</i>&nbsp;    /**</b>
<b class="nc"><i>4434</i>&nbsp;     * Attribute an env for either a top level tree or class or module declaration.</b>
<b class="nc"><i>4435</i>&nbsp;     */</b>
<i>4436</i>&nbsp;    public void attrib(Env&lt;AttrContext&gt; env) {
<i>4437</i>&nbsp;        switch (env.tree.getTag()) {
<i>4438</i>&nbsp;            case MODULEDEF:
<i>4439</i>&nbsp;                attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
<i>4440</i>&nbsp;                break;
<i>4441</i>&nbsp;            case TOPLEVEL:
<b class="nc"><i>4442</i>&nbsp;                attribTopLevel(env);</b>
<b class="nc"><i>4443</i>&nbsp;                break;</b>
<b class="nc"><i>4444</i>&nbsp;            case PACKAGEDEF:</b>
<b class="nc"><i>4445</i>&nbsp;                attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);</b>
<b class="nc"><i>4446</i>&nbsp;                break;</b>
<i>4447</i>&nbsp;            default:
<i>4448</i>&nbsp;                attribClass(env.tree.pos(), env.enclClass.sym);
<i>4449</i>&nbsp;        }
<i>4450</i>&nbsp;    }
<b class="nc"><i>4451</i>&nbsp;</b>
<b class="nc"><i>4452</i>&nbsp;    /**</b>
<i>4453</i>&nbsp;     * Attribute a top level tree. These trees are encountered when the
<b class="nc"><i>4454</i>&nbsp;     * package declaration has annotations.</b>
<b class="nc"><i>4455</i>&nbsp;     */</b>
<i>4456</i>&nbsp;    public void attribTopLevel(Env&lt;AttrContext&gt; env) {
<i>4457</i>&nbsp;        JCCompilationUnit toplevel = env.toplevel;
<b class="nc"><i>4458</i>&nbsp;        try {</b>
<b class="nc"><i>4459</i>&nbsp;            annotate.flush();</b>
<b class="nc"><i>4460</i>&nbsp;        } catch (CompletionFailure ex) {</b>
<i>4461</i>&nbsp;            chk.completionError(toplevel.pos(), ex);
<i>4462</i>&nbsp;        }
<b class="nc"><i>4463</i>&nbsp;    }</b>
<b class="nc"><i>4464</i>&nbsp;</b>
<b class="nc"><i>4465</i>&nbsp;    public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {</b>
<i>4466</i>&nbsp;        try {
<i>4467</i>&nbsp;            annotate.flush();
<i>4468</i>&nbsp;            attribPackage(p);
<b class="nc"><i>4469</i>&nbsp;        } catch (CompletionFailure ex) {</b>
<i>4470</i>&nbsp;            chk.completionError(pos, ex);
<i>4471</i>&nbsp;        }
<i>4472</i>&nbsp;    }
<b class="nc"><i>4473</i>&nbsp;</b>
<i>4474</i>&nbsp;    void attribPackage(PackageSymbol p) {
<i>4475</i>&nbsp;        Env&lt;AttrContext&gt; env = typeEnvs.get(p);
<i>4476</i>&nbsp;        chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
<i>4477</i>&nbsp;    }
<i>4478</i>&nbsp;
<b class="nc"><i>4479</i>&nbsp;    public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {</b>
<b class="nc"><i>4480</i>&nbsp;        try {</b>
<i>4481</i>&nbsp;            annotate.flush();
<i>4482</i>&nbsp;            attribModule(m);
<i>4483</i>&nbsp;        } catch (CompletionFailure ex) {
<b class="nc"><i>4484</i>&nbsp;            chk.completionError(pos, ex);</b>
<b class="nc"><i>4485</i>&nbsp;        }</b>
<i>4486</i>&nbsp;    }
<i>4487</i>&nbsp;
<b class="nc"><i>4488</i>&nbsp;    void attribModule(ModuleSymbol m) {</b>
<b class="nc"><i>4489</i>&nbsp;        // Get environment current at the point of module definition.</b>
<i>4490</i>&nbsp;        Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
<i>4491</i>&nbsp;        attribStat(env.tree, env);
<i>4492</i>&nbsp;    }
<b class="nc"><i>4493</i>&nbsp;</b>
<b class="nc"><i>4494</i>&nbsp;    /** Main method: attribute class definition associated with given class symbol.</b>
<i>4495</i>&nbsp;     *  reporting completion failures at the given position.
<i>4496</i>&nbsp;     *  @param pos The source position at which completion errors are to be
<i>4497</i>&nbsp;     *             reported.
<i>4498</i>&nbsp;     *  @param c   The class symbol whose definition will be attributed.
<i>4499</i>&nbsp;     */
<i>4500</i>&nbsp;    public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
<b class="nc"><i>4501</i>&nbsp;        try {</b>
<b class="nc"><i>4502</i>&nbsp;            annotate.flush();</b>
<b class="nc"><i>4503</i>&nbsp;            attribClass(c);</b>
<i>4504</i>&nbsp;        } catch (CompletionFailure ex) {
<i>4505</i>&nbsp;            chk.completionError(pos, ex);
<b class="nc"><i>4506</i>&nbsp;        }</b>
<b class="nc"><i>4507</i>&nbsp;    }</b>
<i>4508</i>&nbsp;
<b class="nc"><i>4509</i>&nbsp;    /** Attribute class definition associated with given class symbol.</b>
<b class="nc"><i>4510</i>&nbsp;     *  @param c   The class symbol whose definition will be attributed.</b>
<b class="nc"><i>4511</i>&nbsp;     */</b>
<b class="nc"><i>4512</i>&nbsp;    void attribClass(ClassSymbol c) throws CompletionFailure {</b>
<b class="nc"><i>4513</i>&nbsp;        if (c.type.hasTag(ERROR)) return;</b>
<b class="nc"><i>4514</i>&nbsp;</b>
<b class="nc"><i>4515</i>&nbsp;        // Check for cycles in the inheritance graph, which can arise from</b>
<i>4516</i>&nbsp;        // ill-formed class files.
<b class="nc"><i>4517</i>&nbsp;        chk.checkNonCyclic(null, c.type);</b>
<b class="nc"><i>4518</i>&nbsp;</b>
<i>4519</i>&nbsp;        Type st = types.supertype(c.type);
<i>4520</i>&nbsp;        if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
<i>4521</i>&nbsp;            // First, attribute superclass.
<b class="nc"><i>4522</i>&nbsp;            if (st.hasTag(CLASS))</b>
<b class="nc"><i>4523</i>&nbsp;                attribClass((ClassSymbol)st.tsym);</b>
<b class="nc"><i>4524</i>&nbsp;</b>
<b class="nc"><i>4525</i>&nbsp;            // Next attribute owner, if it is a class.</b>
<b class="nc"><i>4526</i>&nbsp;            if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))</b>
<b class="nc"><i>4527</i>&nbsp;                attribClass((ClassSymbol)c.owner);</b>
<i>4528</i>&nbsp;        }
<i>4529</i>&nbsp;
<i>4530</i>&nbsp;        // The previous operations might have attributed the current class
<b class="nc"><i>4531</i>&nbsp;        // if there was a cycle. So we test first whether the class is still</b>
<b class="nc"><i>4532</i>&nbsp;        // UNATTRIBUTED.</b>
<b class="nc"><i>4533</i>&nbsp;        if ((c.flags_field &amp; UNATTRIBUTED) != 0) {</b>
<i>4534</i>&nbsp;            c.flags_field &amp;= ~UNATTRIBUTED;
<i>4535</i>&nbsp;
<b class="nc"><i>4536</i>&nbsp;            // Get environment current at the point of class definition.</b>
<b class="nc"><i>4537</i>&nbsp;            Env&lt;AttrContext&gt; env = typeEnvs.get(c);</b>
<b class="nc"><i>4538</i>&nbsp;</b>
<i>4539</i>&nbsp;            // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
<i>4540</i>&nbsp;            // because the annotations were not available at the time the env was created. Therefore,
<b class="nc"><i>4541</i>&nbsp;            // we look up the environment chain for the first enclosing environment for which the</b>
<b class="nc"><i>4542</i>&nbsp;            // lint value is set. Typically, this is the parent env, but might be further if there</b>
<b class="nc"><i>4543</i>&nbsp;            // are any envs created as a result of TypeParameter nodes.</b>
<i>4544</i>&nbsp;            Env&lt;AttrContext&gt; lintEnv = env;
<i>4545</i>&nbsp;            while (lintEnv.info.lint == null)
<b class="nc"><i>4546</i>&nbsp;                lintEnv = lintEnv.next;</b>
<b class="nc"><i>4547</i>&nbsp;</b>
<i>4548</i>&nbsp;            // Having found the enclosing lint value, we can initialize the lint value for this class
<i>4549</i>&nbsp;            env.info.lint = lintEnv.info.lint.augment(c);
<b class="nc"><i>4550</i>&nbsp;</b>
<i>4551</i>&nbsp;            Lint prevLint = chk.setLint(env.info.lint);
<b class="nc"><i>4552</i>&nbsp;            JavaFileObject prev = log.useSource(c.sourcefile);</b>
<i>4553</i>&nbsp;            ResultInfo prevReturnRes = env.info.returnResult;
<i>4554</i>&nbsp;
<b class="nc"><i>4555</i>&nbsp;            try {</b>
<b class="nc"><i>4556</i>&nbsp;                deferredLintHandler.flush(env.tree);</b>
<b class="nc"><i>4557</i>&nbsp;                env.info.returnResult = null;</b>
<i>4558</i>&nbsp;                // java.lang.Enum may not be subclassed by a non-enum
<i>4559</i>&nbsp;                if (st.tsym == syms.enumSym &amp;&amp;
<b class="nc"><i>4560</i>&nbsp;                    ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))</b>
<i>4561</i>&nbsp;                    log.error(env.tree.pos(), Errors.EnumNoSubclassing);
<b class="nc"><i>4562</i>&nbsp;</b>
<i>4563</i>&nbsp;                // Enums may not be extended by source-level classes
<i>4564</i>&nbsp;                if (st.tsym != null &amp;&amp;
<b class="nc"><i>4565</i>&nbsp;                    ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;</b>
<b class="nc"><i>4566</i>&nbsp;                    ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {</b>
<b class="nc"><i>4567</i>&nbsp;                    log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);</b>
<b class="nc"><i>4568</i>&nbsp;                }</b>
<b class="nc"><i>4569</i>&nbsp;</b>
<i>4570</i>&nbsp;                if (isSerializable(c.type)) {
<b class="nc"><i>4571</i>&nbsp;                    env.info.isSerializable = true;</b>
<b class="nc"><i>4572</i>&nbsp;                }</b>
<b class="nc"><i>4573</i>&nbsp;</b>
<i>4574</i>&nbsp;                attribClassBody(env, c);
<b class="nc"><i>4575</i>&nbsp;</b>
<b class="nc"><i>4576</i>&nbsp;                chk.checkDeprecatedAnnotation(env.tree.pos(), c);</b>
<i>4577</i>&nbsp;                chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
<i>4578</i>&nbsp;                chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
<b class="nc"><i>4579</i>&nbsp;                chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);</b>
<b class="nc"><i>4580</i>&nbsp;            } finally {</b>
<i>4581</i>&nbsp;                env.info.returnResult = prevReturnRes;
<i>4582</i>&nbsp;                log.useSource(prev);
<i>4583</i>&nbsp;                chk.setLint(prevLint);
<i>4584</i>&nbsp;            }
<i>4585</i>&nbsp;
<i>4586</i>&nbsp;        }
<i>4587</i>&nbsp;    }
<i>4588</i>&nbsp;
<i>4589</i>&nbsp;    public void visitImport(JCImport tree) {
<i>4590</i>&nbsp;        // nothing to do
<i>4591</i>&nbsp;    }
<i>4592</i>&nbsp;
<i>4593</i>&nbsp;    public void visitModuleDef(JCModuleDecl tree) {
<i>4594</i>&nbsp;        tree.sym.completeUsesProvides();
<b class="nc"><i>4595</i>&nbsp;        ModuleSymbol msym = tree.sym;</b>
<i>4596</i>&nbsp;        Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
<i>4597</i>&nbsp;        Lint prevLint = chk.setLint(lint);
<i>4598</i>&nbsp;        chk.checkModuleName(tree);
<b class="nc"><i>4599</i>&nbsp;        chk.checkDeprecatedAnnotation(tree, msym);</b>
<b class="nc"><i>4600</i>&nbsp;</b>
<i>4601</i>&nbsp;        try {
<b class="nc"><i>4602</i>&nbsp;            deferredLintHandler.flush(tree.pos());</b>
<b class="nc"><i>4603</i>&nbsp;        } finally {</b>
<b class="nc"><i>4604</i>&nbsp;            chk.setLint(prevLint);</b>
<b class="nc"><i>4605</i>&nbsp;        }</b>
<b class="nc"><i>4606</i>&nbsp;    }</b>
<b class="nc"><i>4607</i>&nbsp;</b>
<i>4608</i>&nbsp;    /** Finish the attribution of a class. */
<b class="nc"><i>4609</i>&nbsp;    private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {</b>
<b class="nc"><i>4610</i>&nbsp;        JCClassDecl tree = (JCClassDecl)env.tree;</b>
<b class="nc"><i>4611</i>&nbsp;        Assert.check(c == tree.sym);</b>
<i>4612</i>&nbsp;
<i>4613</i>&nbsp;        // Validate type parameters, supertype and interfaces.
<i>4614</i>&nbsp;        attribStats(tree.typarams, env);
<i>4615</i>&nbsp;        if (!c.isAnonymous()) {
<i>4616</i>&nbsp;            //already checked if anonymous
<i>4617</i>&nbsp;            chk.validate(tree.typarams, env);
<i>4618</i>&nbsp;            chk.validate(tree.extending, env);
<i>4619</i>&nbsp;            chk.validate(tree.implementing, env);
<b class="nc"><i>4620</i>&nbsp;        }</b>
<i>4621</i>&nbsp;
<i>4622</i>&nbsp;        c.markAbstractIfNeeded(types);
<b class="nc"><i>4623</i>&nbsp;</b>
<b class="nc"><i>4624</i>&nbsp;        // If this is a non-abstract class, check that it has no abstract</b>
<b class="nc"><i>4625</i>&nbsp;        // methods or unimplemented methods of an implemented interface.</b>
<b class="nc"><i>4626</i>&nbsp;        if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {</b>
<b class="nc"><i>4627</i>&nbsp;            chk.checkAllDefined(tree.pos(), c);</b>
<i>4628</i>&nbsp;        }
<b class="nc"><i>4629</i>&nbsp;</b>
<b class="nc"><i>4630</i>&nbsp;        if ((c.flags() &amp; ANNOTATION) != 0) {</b>
<b class="nc"><i>4631</i>&nbsp;            if (tree.implementing.nonEmpty())</b>
<b class="nc"><i>4632</i>&nbsp;                log.error(tree.implementing.head.pos(),</b>
<b class="nc"><i>4633</i>&nbsp;                          Errors.CantExtendIntfAnnotation);</b>
<b class="nc"><i>4634</i>&nbsp;            if (tree.typarams.nonEmpty()) {</b>
<i>4635</i>&nbsp;                log.error(tree.typarams.head.pos(),
<b class="nc"><i>4636</i>&nbsp;                          Errors.IntfAnnotationCantHaveTypeParams(c));</b>
<b class="nc"><i>4637</i>&nbsp;            }</b>
<b class="nc"><i>4638</i>&nbsp;</b>
<b class="nc"><i>4639</i>&nbsp;            // If this annotation type has a @Repeatable, validate</b>
<b class="nc"><i>4640</i>&nbsp;            Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();</b>
<i>4641</i>&nbsp;            // If this annotation type has a @Repeatable, validate
<b class="nc"><i>4642</i>&nbsp;            if (repeatable != null) {</b>
<i>4643</i>&nbsp;                // get diagnostic position for error reporting
<b class="nc"><i>4644</i>&nbsp;                DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);</b>
<i>4645</i>&nbsp;                Assert.checkNonNull(cbPos);
<b class="nc"><i>4646</i>&nbsp;</b>
<b class="nc"><i>4647</i>&nbsp;                chk.validateRepeatable(c, repeatable, cbPos);</b>
<b class="nc"><i>4648</i>&nbsp;            }</b>
<b class="nc"><i>4649</i>&nbsp;        } else {</b>
<b class="nc"><i>4650</i>&nbsp;            // Check that all extended classes and interfaces</b>
<b class="nc"><i>4651</i>&nbsp;            // are compatible (i.e. no two define methods with same arguments</b>
<b class="nc"><i>4652</i>&nbsp;            // yet different return types).  (JLS 8.4.6.3)</b>
<b class="nc"><i>4653</i>&nbsp;            chk.checkCompatibleSupertypes(tree.pos(), c.type);</b>
<i>4654</i>&nbsp;            if (allowDefaultMethods) {
<i>4655</i>&nbsp;                chk.checkDefaultMethodClashes(tree.pos(), c.type);
<i>4656</i>&nbsp;            }
<b class="nc"><i>4657</i>&nbsp;        }</b>
<b class="nc"><i>4658</i>&nbsp;</b>
<b class="nc"><i>4659</i>&nbsp;        // Check that class does not import the same parameterized interface</b>
<b class="nc"><i>4660</i>&nbsp;        // with two different argument lists.</b>
<b class="nc"><i>4661</i>&nbsp;        chk.checkClassBounds(tree.pos(), c.type);</b>
<b class="nc"><i>4662</i>&nbsp;</b>
<b class="nc"><i>4663</i>&nbsp;        tree.type = c.type;</b>
<b class="nc"><i>4664</i>&nbsp;</b>
<b class="nc"><i>4665</i>&nbsp;        for (List&lt;JCTypeParameter&gt; l = tree.typarams;</b>
<b class="nc"><i>4666</i>&nbsp;             l.nonEmpty(); l = l.tail) {</b>
<b class="nc"><i>4667</i>&nbsp;             Assert.checkNonNull(env.info.scope.findFirst(l.head.name));</b>
<b class="nc"><i>4668</i>&nbsp;        }</b>
<b class="nc"><i>4669</i>&nbsp;</b>
<b class="nc"><i>4670</i>&nbsp;        // Check that a generic class doesn&#39;t extend Throwable</b>
<b class="nc"><i>4671</i>&nbsp;        if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))</b>
<b class="nc"><i>4672</i>&nbsp;            log.error(tree.extending.pos(), Errors.GenericThrowable);</b>
<b class="nc"><i>4673</i>&nbsp;</b>
<b class="nc"><i>4674</i>&nbsp;        // Check that all methods which implement some</b>
<b class="nc"><i>4675</i>&nbsp;        // method conform to the method they implement.</b>
<b class="nc"><i>4676</i>&nbsp;        chk.checkImplementations(tree);</b>
<i>4677</i>&nbsp;
<b class="nc"><i>4678</i>&nbsp;        //check that a resource implementing AutoCloseable cannot throw InterruptedException</b>
<b class="nc"><i>4679</i>&nbsp;        checkAutoCloseable(tree.pos(), env, c.type);</b>
<i>4680</i>&nbsp;
<i>4681</i>&nbsp;        for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
<i>4682</i>&nbsp;            // Attribute declaration
<i>4683</i>&nbsp;            attribStat(l.head, env);
<i>4684</i>&nbsp;            // Check that declarations in inner classes are not static (JLS 8.1.2)
<i>4685</i>&nbsp;            // Make an exception for static constants.
<i>4686</i>&nbsp;            if (c.owner.kind != PCK &amp;&amp;
<i>4687</i>&nbsp;                ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
<i>4688</i>&nbsp;                (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
<i>4689</i>&nbsp;                Symbol sym = null;
<b class="nc"><i>4690</i>&nbsp;                if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;</b>
<b class="nc"><i>4691</i>&nbsp;                if (sym == null ||</b>
<b class="nc"><i>4692</i>&nbsp;                    sym.kind != VAR ||</b>
<b class="nc"><i>4693</i>&nbsp;                    ((VarSymbol) sym).getConstValue() == null)</b>
<i>4694</i>&nbsp;                    log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
<b class="nc"><i>4695</i>&nbsp;            }</b>
<i>4696</i>&nbsp;        }
<i>4697</i>&nbsp;
<i>4698</i>&nbsp;        // Check for cycles among non-initial constructors.
<i>4699</i>&nbsp;        chk.checkCyclicConstructors(tree);
<i>4700</i>&nbsp;
<i>4701</i>&nbsp;        // Check for cycles among annotation elements.
<i>4702</i>&nbsp;        chk.checkNonCyclicElements(tree);
<i>4703</i>&nbsp;
<i>4704</i>&nbsp;        // Check for proper use of serialVersionUID
<i>4705</i>&nbsp;        if (env.info.lint.isEnabled(LintCategory.SERIAL)
<i>4706</i>&nbsp;                &amp;&amp; isSerializable(c.type)
<i>4707</i>&nbsp;                &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
<i>4708</i>&nbsp;                &amp;&amp; !c.isAnonymous()) {
<b class="nc"><i>4709</i>&nbsp;            checkSerialVersionUID(tree, c);</b>
<i>4710</i>&nbsp;        }
<i>4711</i>&nbsp;        if (allowTypeAnnos) {
<b class="nc"><i>4712</i>&nbsp;            // Correctly organize the postions of the type annotations</b>
<i>4713</i>&nbsp;            typeAnnotations.organizeTypeAnnotationsBodies(tree);
<i>4714</i>&nbsp;
<b class="nc"><i>4715</i>&nbsp;            // Check type annotations applicability rules</b>
<b class="nc"><i>4716</i>&nbsp;            validateTypeAnnotations(tree, false);</b>
<b class="nc"><i>4717</i>&nbsp;        }</b>
<i>4718</i>&nbsp;    }
<b class="nc"><i>4719</i>&nbsp;        // where</b>
<i>4720</i>&nbsp;        /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
<i>4721</i>&nbsp;        private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
<i>4722</i>&nbsp;            for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
<i>4723</i>&nbsp;                if (types.isSameType(al.head.annotationType.type, t))
<i>4724</i>&nbsp;                    return al.head.pos();
<i>4725</i>&nbsp;            }
<i>4726</i>&nbsp;
<i>4727</i>&nbsp;            return null;
<i>4728</i>&nbsp;        }
<i>4729</i>&nbsp;
<b class="nc"><i>4730</i>&nbsp;        /** check if a type is a subtype of Serializable, if that is available. */</b>
<b class="nc"><i>4731</i>&nbsp;        boolean isSerializable(Type t) {</b>
<b class="nc"><i>4732</i>&nbsp;            try {</b>
<b class="nc"><i>4733</i>&nbsp;                syms.serializableType.complete();</b>
<b class="nc"><i>4734</i>&nbsp;            }</b>
<i>4735</i>&nbsp;            catch (CompletionFailure e) {
<b class="nc"><i>4736</i>&nbsp;                return false;</b>
<b class="nc"><i>4737</i>&nbsp;            }</b>
<i>4738</i>&nbsp;            return types.isSubtype(t, syms.serializableType);
<i>4739</i>&nbsp;        }
<b class="nc"><i>4740</i>&nbsp;</b>
<i>4741</i>&nbsp;        /** Check that an appropriate serialVersionUID member is defined. */
<i>4742</i>&nbsp;        private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
<i>4743</i>&nbsp;
<i>4744</i>&nbsp;            // check for presence of serialVersionUID
<b class="nc"><i>4745</i>&nbsp;            VarSymbol svuid = null;</b>
<b class="nc"><i>4746</i>&nbsp;            for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {</b>
<b class="nc"><i>4747</i>&nbsp;                if (sym.kind == VAR) {</b>
<i>4748</i>&nbsp;                    svuid = (VarSymbol)sym;
<b class="nc"><i>4749</i>&nbsp;                    break;</b>
<i>4750</i>&nbsp;                }
<i>4751</i>&nbsp;            }
<i>4752</i>&nbsp;
<i>4753</i>&nbsp;            if (svuid == null) {
<b class="nc"><i>4754</i>&nbsp;                log.warning(LintCategory.SERIAL,</b>
<b class="nc"><i>4755</i>&nbsp;                        tree.pos(), Warnings.MissingSVUID(c));</b>
<i>4756</i>&nbsp;                return;
<i>4757</i>&nbsp;            }
<i>4758</i>&nbsp;
<i>4759</i>&nbsp;            // check that it is static final
<i>4760</i>&nbsp;            if ((svuid.flags() &amp; (STATIC | FINAL)) !=
<b class="nc"><i>4761</i>&nbsp;                (STATIC | FINAL))</b>
<b class="nc"><i>4762</i>&nbsp;                log.warning(LintCategory.SERIAL,</b>
<i>4763</i>&nbsp;                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
<b class="nc"><i>4764</i>&nbsp;</b>
<i>4765</i>&nbsp;            // check that it is long
<i>4766</i>&nbsp;            else if (!svuid.type.hasTag(LONG))
<i>4767</i>&nbsp;                log.warning(LintCategory.SERIAL,
<i>4768</i>&nbsp;                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
<b class="nc"><i>4769</i>&nbsp;</b>
<b class="nc"><i>4770</i>&nbsp;            // check constant</b>
<b class="nc"><i>4771</i>&nbsp;            else if (svuid.getConstValue() == null)</b>
<i>4772</i>&nbsp;                log.warning(LintCategory.SERIAL,
<b class="nc"><i>4773</i>&nbsp;                        TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));</b>
<i>4774</i>&nbsp;        }
<i>4775</i>&nbsp;
<i>4776</i>&nbsp;    private Type capture(Type type) {
<i>4777</i>&nbsp;        return types.capture(type);
<b class="nc"><i>4778</i>&nbsp;    }</b>
<b class="nc"><i>4779</i>&nbsp;</b>
<b class="nc"><i>4780</i>&nbsp;    private void setSyntheticVariableType(JCVariableDecl tree, Type type) {</b>
<i>4781</i>&nbsp;        if (type.isErroneous()) {
<b class="nc"><i>4782</i>&nbsp;            tree.vartype = make.at(Position.NOPOS).Erroneous();</b>
<i>4783</i>&nbsp;        } else {
<i>4784</i>&nbsp;            tree.vartype = make.at(Position.NOPOS).Type(type);
<i>4785</i>&nbsp;        }
<i>4786</i>&nbsp;    }
<b class="nc"><i>4787</i>&nbsp;</b>
<b class="nc"><i>4788</i>&nbsp;    public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {</b>
<b class="nc"><i>4789</i>&nbsp;        tree.accept(new TypeAnnotationsValidator(sigOnly));</b>
<b class="nc"><i>4790</i>&nbsp;    }</b>
<i>4791</i>&nbsp;    //where
<b class="nc"><i>4792</i>&nbsp;    private final class TypeAnnotationsValidator extends TreeScanner {</b>
<i>4793</i>&nbsp;
<i>4794</i>&nbsp;        private final boolean sigOnly;
<i>4795</i>&nbsp;        public TypeAnnotationsValidator(boolean sigOnly) {
<i>4796</i>&nbsp;            this.sigOnly = sigOnly;
<b class="nc"><i>4797</i>&nbsp;        }</b>
<b class="nc"><i>4798</i>&nbsp;</b>
<b class="nc"><i>4799</i>&nbsp;        public void visitAnnotation(JCAnnotation tree) {</b>
<i>4800</i>&nbsp;            chk.validateTypeAnnotation(tree, false);
<b class="nc"><i>4801</i>&nbsp;            super.visitAnnotation(tree);</b>
<b class="nc"><i>4802</i>&nbsp;        }</b>
<i>4803</i>&nbsp;        public void visitAnnotatedType(JCAnnotatedType tree) {
<b class="nc"><i>4804</i>&nbsp;            if (!tree.underlyingType.type.isErroneous()) {</b>
<i>4805</i>&nbsp;                super.visitAnnotatedType(tree);
<i>4806</i>&nbsp;            }
<i>4807</i>&nbsp;        }
<i>4808</i>&nbsp;        public void visitTypeParameter(JCTypeParameter tree) {
<b class="nc"><i>4809</i>&nbsp;            chk.validateTypeAnnotations(tree.annotations, true);</b>
<b class="nc"><i>4810</i>&nbsp;            scan(tree.bounds);</b>
<i>4811</i>&nbsp;            // Don&#39;t call super.
<i>4812</i>&nbsp;            // This is needed because above we call validateTypeAnnotation with
<b class="nc"><i>4813</i>&nbsp;            // false, which would forbid annotations on type parameters.</b>
<i>4814</i>&nbsp;            // super.visitTypeParameter(tree);
<i>4815</i>&nbsp;        }
<i>4816</i>&nbsp;        public void visitMethodDef(JCMethodDecl tree) {
<i>4817</i>&nbsp;            if (tree.recvparam != null &amp;&amp;
<b class="nc"><i>4818</i>&nbsp;                    !tree.recvparam.vartype.type.isErroneous()) {</b>
<b class="nc"><i>4819</i>&nbsp;                checkForDeclarationAnnotations(tree.recvparam.mods.annotations,</b>
<i>4820</i>&nbsp;                        tree.recvparam.vartype.type.tsym);
<i>4821</i>&nbsp;            }
<b class="nc"><i>4822</i>&nbsp;            if (tree.restype != null &amp;&amp; tree.restype.type != null) {</b>
<i>4823</i>&nbsp;                validateAnnotatedType(tree.restype, tree.restype.type);
<i>4824</i>&nbsp;            }
<i>4825</i>&nbsp;            if (sigOnly) {
<i>4826</i>&nbsp;                scan(tree.mods);
<b class="nc"><i>4827</i>&nbsp;                scan(tree.restype);</b>
<b class="nc"><i>4828</i>&nbsp;                scan(tree.typarams);</b>
<i>4829</i>&nbsp;                scan(tree.recvparam);
<i>4830</i>&nbsp;                scan(tree.params);
<b class="nc"><i>4831</i>&nbsp;                scan(tree.thrown);</b>
<i>4832</i>&nbsp;            } else {
<i>4833</i>&nbsp;                scan(tree.defaultValue);
<i>4834</i>&nbsp;                scan(tree.body);
<i>4835</i>&nbsp;            }
<b class="nc"><i>4836</i>&nbsp;        }</b>
<b class="nc"><i>4837</i>&nbsp;        public void visitVarDef(final JCVariableDecl tree) {</b>
<b class="nc"><i>4838</i>&nbsp;            //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);</b>
<i>4839</i>&nbsp;            if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
<i>4840</i>&nbsp;                validateAnnotatedType(tree.vartype, tree.sym.type);
<i>4841</i>&nbsp;            scan(tree.mods);
<i>4842</i>&nbsp;            scan(tree.vartype);
<i>4843</i>&nbsp;            if (!sigOnly) {
<b class="nc"><i>4844</i>&nbsp;                scan(tree.init);</b>
<b class="nc"><i>4845</i>&nbsp;            }</b>
<b class="nc"><i>4846</i>&nbsp;        }</b>
<i>4847</i>&nbsp;        public void visitTypeCast(JCTypeCast tree) {
<i>4848</i>&nbsp;            if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
<b class="nc"><i>4849</i>&nbsp;                validateAnnotatedType(tree.clazz, tree.clazz.type);</b>
<b class="nc"><i>4850</i>&nbsp;            super.visitTypeCast(tree);</b>
<i>4851</i>&nbsp;        }
<i>4852</i>&nbsp;        public void visitTypeTest(JCInstanceOf tree) {
<i>4853</i>&nbsp;            if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
<i>4854</i>&nbsp;                validateAnnotatedType(tree.clazz, tree.clazz.type);
<i>4855</i>&nbsp;            super.visitTypeTest(tree);
<i>4856</i>&nbsp;        }
<i>4857</i>&nbsp;        public void visitNewClass(JCNewClass tree) {
<i>4858</i>&nbsp;            if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
<i>4859</i>&nbsp;                if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
<i>4860</i>&nbsp;                    checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
<i>4861</i>&nbsp;                            tree.clazz.type.tsym);
<i>4862</i>&nbsp;                }
<i>4863</i>&nbsp;                if (tree.def != null) {
<i>4864</i>&nbsp;                    checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
<i>4865</i>&nbsp;                }
<i>4866</i>&nbsp;
<i>4867</i>&nbsp;                validateAnnotatedType(tree.clazz, tree.clazz.type);
<i>4868</i>&nbsp;            }
<i>4869</i>&nbsp;            super.visitNewClass(tree);
<i>4870</i>&nbsp;        }
<i>4871</i>&nbsp;        public void visitNewArray(JCNewArray tree) {
<i>4872</i>&nbsp;            if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
<i>4873</i>&nbsp;                if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
<i>4874</i>&nbsp;                    checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
<i>4875</i>&nbsp;                            tree.elemtype.type.tsym);
<i>4876</i>&nbsp;                }
<i>4877</i>&nbsp;                validateAnnotatedType(tree.elemtype, tree.elemtype.type);
<i>4878</i>&nbsp;            }
<i>4879</i>&nbsp;            super.visitNewArray(tree);
<i>4880</i>&nbsp;        }
<i>4881</i>&nbsp;        public void visitClassDef(JCClassDecl tree) {
<i>4882</i>&nbsp;            //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
<i>4883</i>&nbsp;            if (sigOnly) {
<i>4884</i>&nbsp;                scan(tree.mods);
<i>4885</i>&nbsp;                scan(tree.typarams);
<i>4886</i>&nbsp;                scan(tree.extending);
<i>4887</i>&nbsp;                scan(tree.implementing);
<i>4888</i>&nbsp;            }
<i>4889</i>&nbsp;            for (JCTree member : tree.defs) {
<i>4890</i>&nbsp;                if (member.hasTag(Tag.CLASSDEF)) {
<i>4891</i>&nbsp;                    continue;
<i>4892</i>&nbsp;                }
<i>4893</i>&nbsp;                scan(member);
<i>4894</i>&nbsp;            }
<i>4895</i>&nbsp;        }
<i>4896</i>&nbsp;        public void visitBlock(JCBlock tree) {
<i>4897</i>&nbsp;            if (!sigOnly) {
<i>4898</i>&nbsp;                scan(tree.stats);
<i>4899</i>&nbsp;            }
<i>4900</i>&nbsp;        }
<i>4901</i>&nbsp;
<i>4902</i>&nbsp;        /* I would want to model this after
<i>4903</i>&nbsp;         * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
<i>4904</i>&nbsp;         * and override visitSelect and visitTypeApply.
<i>4905</i>&nbsp;         * However, we only set the annotated type in the top-level type
<i>4906</i>&nbsp;         * of the symbol.
<i>4907</i>&nbsp;         * Therefore, we need to override each individual location where a type
<i>4908</i>&nbsp;         * can occur.
<i>4909</i>&nbsp;         */
<i>4910</i>&nbsp;        private void validateAnnotatedType(final JCTree errtree, final Type type) {
<i>4911</i>&nbsp;            //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
<i>4912</i>&nbsp;
<i>4913</i>&nbsp;            if (type.isPrimitiveOrVoid()) {
<i>4914</i>&nbsp;                return;
<i>4915</i>&nbsp;            }
<i>4916</i>&nbsp;
<i>4917</i>&nbsp;            JCTree enclTr = errtree;
<i>4918</i>&nbsp;            Type enclTy = type;
<i>4919</i>&nbsp;
<i>4920</i>&nbsp;            boolean repeat = true;
<i>4921</i>&nbsp;            while (repeat) {
<i>4922</i>&nbsp;                if (enclTr.hasTag(TYPEAPPLY)) {
<i>4923</i>&nbsp;                    List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
<i>4924</i>&nbsp;                    List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
<i>4925</i>&nbsp;                    if (trargs.length() &gt; 0) {
<i>4926</i>&nbsp;                        // Nothing to do for diamonds
<i>4927</i>&nbsp;                        if (tyargs.length() == trargs.length()) {
<i>4928</i>&nbsp;                            for (int i = 0; i &lt; tyargs.length(); ++i) {
<i>4929</i>&nbsp;                                validateAnnotatedType(trargs.get(i), tyargs.get(i));
<i>4930</i>&nbsp;                            }
<i>4931</i>&nbsp;                        }
<i>4932</i>&nbsp;                        // If the lengths don&#39;t match, it&#39;s either a diamond
<i>4933</i>&nbsp;                        // or some nested type that redundantly provides
<i>4934</i>&nbsp;                        // type arguments in the tree.
<i>4935</i>&nbsp;                    }
<i>4936</i>&nbsp;
<i>4937</i>&nbsp;                    // Look at the clazz part of a generic type
<i>4938</i>&nbsp;                    enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
<i>4939</i>&nbsp;                }
<i>4940</i>&nbsp;
<i>4941</i>&nbsp;                if (enclTr.hasTag(SELECT)) {
<i>4942</i>&nbsp;                    enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
<i>4943</i>&nbsp;                    if (enclTy != null &amp;&amp;
<i>4944</i>&nbsp;                            !enclTy.hasTag(NONE)) {
<i>4945</i>&nbsp;                        enclTy = enclTy.getEnclosingType();
<i>4946</i>&nbsp;                    }
<i>4947</i>&nbsp;                } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
<i>4948</i>&nbsp;                    JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
<i>4949</i>&nbsp;                    if (enclTy == null || enclTy.hasTag(NONE)) {
<i>4950</i>&nbsp;                        if (at.getAnnotations().size() == 1) {
<i>4951</i>&nbsp;                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
<i>4952</i>&nbsp;                        } else {
<i>4953</i>&nbsp;                            ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
<i>4954</i>&nbsp;                            for (JCAnnotation an : at.getAnnotations()) {
<i>4955</i>&nbsp;                                comps.add(an.attribute);
<i>4956</i>&nbsp;                            }
<i>4957</i>&nbsp;                            log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
<i>4958</i>&nbsp;                        }
<i>4959</i>&nbsp;                        repeat = false;
<i>4960</i>&nbsp;                    }
<i>4961</i>&nbsp;                    enclTr = at.underlyingType;
<i>4962</i>&nbsp;                    // enclTy doesn&#39;t need to be changed
<i>4963</i>&nbsp;                } else if (enclTr.hasTag(IDENT)) {
<i>4964</i>&nbsp;                    repeat = false;
<i>4965</i>&nbsp;                } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
<i>4966</i>&nbsp;                    JCWildcard wc = (JCWildcard) enclTr;
<i>4967</i>&nbsp;                    if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
<i>4968</i>&nbsp;                            wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
<i>4969</i>&nbsp;                        validateAnnotatedType(wc.getBound(), wc.getBound().type);
<i>4970</i>&nbsp;                    } else {
<i>4971</i>&nbsp;                        // Nothing to do for UNBOUND
<i>4972</i>&nbsp;                    }
<i>4973</i>&nbsp;                    repeat = false;
<i>4974</i>&nbsp;                } else if (enclTr.hasTag(TYPEARRAY)) {
<i>4975</i>&nbsp;                    JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
<i>4976</i>&nbsp;                    validateAnnotatedType(art.getType(), art.elemtype.type);
<i>4977</i>&nbsp;                    repeat = false;
<i>4978</i>&nbsp;                } else if (enclTr.hasTag(TYPEUNION)) {
<i>4979</i>&nbsp;                    JCTypeUnion ut = (JCTypeUnion) enclTr;
<i>4980</i>&nbsp;                    for (JCTree t : ut.getTypeAlternatives()) {
<i>4981</i>&nbsp;                        validateAnnotatedType(t, t.type);
<i>4982</i>&nbsp;                    }
<i>4983</i>&nbsp;                    repeat = false;
<i>4984</i>&nbsp;                } else if (enclTr.hasTag(TYPEINTERSECTION)) {
<i>4985</i>&nbsp;                    JCTypeIntersection it = (JCTypeIntersection) enclTr;
<i>4986</i>&nbsp;                    for (JCTree t : it.getBounds()) {
<i>4987</i>&nbsp;                        validateAnnotatedType(t, t.type);
<i>4988</i>&nbsp;                    }
<i>4989</i>&nbsp;                    repeat = false;
<i>4990</i>&nbsp;                } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
<i>4991</i>&nbsp;                           enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
<i>4992</i>&nbsp;                    repeat = false;
<i>4993</i>&nbsp;                } else {
<i>4994</i>&nbsp;                    Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
<i>4995</i>&nbsp;                            &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
<i>4996</i>&nbsp;                }
<i>4997</i>&nbsp;            }
<i>4998</i>&nbsp;        }
<i>4999</i>&nbsp;
<i>5000</i>&nbsp;        private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
<i>5001</i>&nbsp;                Symbol sym) {
<i>5002</i>&nbsp;            // Ensure that no declaration annotations are present.
<i>5003</i>&nbsp;            // Note that a tree type might be an AnnotatedType with
<i>5004</i>&nbsp;            // empty annotations, if only declaration annotations were given.
<i>5005</i>&nbsp;            // This method will raise an error for such a type.
<i>5006</i>&nbsp;            for (JCAnnotation ai : annotations) {
<i>5007</i>&nbsp;                if (!ai.type.isErroneous() &amp;&amp;
<i>5008</i>&nbsp;                        typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
<i>5009</i>&nbsp;                    log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
<i>5010</i>&nbsp;                }
<i>5011</i>&nbsp;            }
<i>5012</i>&nbsp;        }
<i>5013</i>&nbsp;    }
<i>5014</i>&nbsp;
<i>5015</i>&nbsp;    // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
<i>5016</i>&nbsp;
<i>5017</i>&nbsp;    /**
<i>5018</i>&nbsp;     * Handle missing types/symbols in an AST. This routine is useful when
<i>5019</i>&nbsp;     * the compiler has encountered some errors (which might have ended up
<i>5020</i>&nbsp;     * terminating attribution abruptly); if the compiler is used in fail-over
<i>5021</i>&nbsp;     * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
<i>5022</i>&nbsp;     * prevents NPE to be progagated during subsequent compilation steps.
<i>5023</i>&nbsp;     */
<i>5024</i>&nbsp;    public void postAttr(JCTree tree) {
<i>5025</i>&nbsp;        new PostAttrAnalyzer().scan(tree);
<i>5026</i>&nbsp;    }
<i>5027</i>&nbsp;
<i>5028</i>&nbsp;    class PostAttrAnalyzer extends TreeScanner {
<i>5029</i>&nbsp;
<i>5030</i>&nbsp;        private void initTypeIfNeeded(JCTree that) {
<i>5031</i>&nbsp;            if (that.type == null) {
<i>5032</i>&nbsp;                if (that.hasTag(METHODDEF)) {
<i>5033</i>&nbsp;                    that.type = dummyMethodType((JCMethodDecl)that);
<i>5034</i>&nbsp;                } else {
<i>5035</i>&nbsp;                    that.type = syms.unknownType;
<i>5036</i>&nbsp;                }
<i>5037</i>&nbsp;            }
<i>5038</i>&nbsp;        }
<i>5039</i>&nbsp;
<i>5040</i>&nbsp;        /* Construct a dummy method type. If we have a method declaration,
<i>5041</i>&nbsp;         * and the declared return type is void, then use that return type
<i>5042</i>&nbsp;         * instead of UNKNOWN to avoid spurious error messages in lambda
<i>5043</i>&nbsp;         * bodies (see:JDK-8041704).
<i>5044</i>&nbsp;         */
<i>5045</i>&nbsp;        private Type dummyMethodType(JCMethodDecl md) {
<i>5046</i>&nbsp;            Type restype = syms.unknownType;
<i>5047</i>&nbsp;            if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
<i>5048</i>&nbsp;                JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
<i>5049</i>&nbsp;                if (prim.typetag == VOID)
<i>5050</i>&nbsp;                    restype = syms.voidType;
<i>5051</i>&nbsp;            }
<i>5052</i>&nbsp;            return new MethodType(List.nil(), restype,
<i>5053</i>&nbsp;                                  List.nil(), syms.methodClass);
<i>5054</i>&nbsp;        }
<i>5055</i>&nbsp;        private Type dummyMethodType() {
<i>5056</i>&nbsp;            return dummyMethodType(null);
<i>5057</i>&nbsp;        }
<i>5058</i>&nbsp;
<i>5059</i>&nbsp;        @Override
<i>5060</i>&nbsp;        public void scan(JCTree tree) {
<i>5061</i>&nbsp;            if (tree == null) return;
<i>5062</i>&nbsp;            if (tree instanceof JCExpression) {
<i>5063</i>&nbsp;                initTypeIfNeeded(tree);
<i>5064</i>&nbsp;            }
<i>5065</i>&nbsp;            super.scan(tree);
<i>5066</i>&nbsp;        }
<i>5067</i>&nbsp;
<i>5068</i>&nbsp;        @Override
<i>5069</i>&nbsp;        public void visitIdent(JCIdent that) {
<i>5070</i>&nbsp;            if (that.sym == null) {
<i>5071</i>&nbsp;                that.sym = syms.unknownSymbol;
<i>5072</i>&nbsp;            }
<i>5073</i>&nbsp;        }
<i>5074</i>&nbsp;
<i>5075</i>&nbsp;        @Override
<i>5076</i>&nbsp;        public void visitSelect(JCFieldAccess that) {
<i>5077</i>&nbsp;            if (that.sym == null) {
<i>5078</i>&nbsp;                that.sym = syms.unknownSymbol;
<i>5079</i>&nbsp;            }
<i>5080</i>&nbsp;            super.visitSelect(that);
<i>5081</i>&nbsp;        }
<i>5082</i>&nbsp;
<i>5083</i>&nbsp;        @Override
<i>5084</i>&nbsp;        public void visitClassDef(JCClassDecl that) {
<i>5085</i>&nbsp;            initTypeIfNeeded(that);
<i>5086</i>&nbsp;            if (that.sym == null) {
<i>5087</i>&nbsp;                that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
<i>5088</i>&nbsp;            }
<i>5089</i>&nbsp;            super.visitClassDef(that);
<i>5090</i>&nbsp;        }
<i>5091</i>&nbsp;
<i>5092</i>&nbsp;        @Override
<i>5093</i>&nbsp;        public void visitMethodDef(JCMethodDecl that) {
<i>5094</i>&nbsp;            initTypeIfNeeded(that);
<i>5095</i>&nbsp;            if (that.sym == null) {
<i>5096</i>&nbsp;                that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
<i>5097</i>&nbsp;            }
<i>5098</i>&nbsp;            super.visitMethodDef(that);
<i>5099</i>&nbsp;        }
<i>5100</i>&nbsp;
<i>5101</i>&nbsp;        @Override
<i>5102</i>&nbsp;        public void visitVarDef(JCVariableDecl that) {
<i>5103</i>&nbsp;            initTypeIfNeeded(that);
<i>5104</i>&nbsp;            if (that.sym == null) {
<i>5105</i>&nbsp;                that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
<i>5106</i>&nbsp;                that.sym.adr = 0;
<i>5107</i>&nbsp;            }
<i>5108</i>&nbsp;            if (that.vartype == null) {
<i>5109</i>&nbsp;                that.vartype = make.at(Position.NOPOS).Erroneous();
<i>5110</i>&nbsp;            }
<i>5111</i>&nbsp;            super.visitVarDef(that);
<i>5112</i>&nbsp;        }
<i>5113</i>&nbsp;
<i>5114</i>&nbsp;        @Override
<i>5115</i>&nbsp;        public void visitNewClass(JCNewClass that) {
<i>5116</i>&nbsp;            if (that.constructor == null) {
<i>5117</i>&nbsp;                that.constructor = new MethodSymbol(0, names.init,
<i>5118</i>&nbsp;                        dummyMethodType(), syms.noSymbol);
<i>5119</i>&nbsp;            }
<i>5120</i>&nbsp;            if (that.constructorType == null) {
<i>5121</i>&nbsp;                that.constructorType = syms.unknownType;
<i>5122</i>&nbsp;            }
<i>5123</i>&nbsp;            super.visitNewClass(that);
<i>5124</i>&nbsp;        }
<i>5125</i>&nbsp;
<i>5126</i>&nbsp;        @Override
<i>5127</i>&nbsp;        public void visitAssignop(JCAssignOp that) {
<i>5128</i>&nbsp;            if (that.operator == null) {
<i>5129</i>&nbsp;                that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
<i>5130</i>&nbsp;                        -1, syms.noSymbol);
<i>5131</i>&nbsp;            }
<i>5132</i>&nbsp;            super.visitAssignop(that);
<i>5133</i>&nbsp;        }
<i>5134</i>&nbsp;
<i>5135</i>&nbsp;        @Override
<i>5136</i>&nbsp;        public void visitBinary(JCBinary that) {
<i>5137</i>&nbsp;            if (that.operator == null) {
<i>5138</i>&nbsp;                that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
<i>5139</i>&nbsp;                        -1, syms.noSymbol);
<i>5140</i>&nbsp;            }
<i>5141</i>&nbsp;            super.visitBinary(that);
<i>5142</i>&nbsp;        }
<i>5143</i>&nbsp;
<i>5144</i>&nbsp;        @Override
<i>5145</i>&nbsp;        public void visitUnary(JCUnary that) {
<i>5146</i>&nbsp;            if (that.operator == null) {
<i>5147</i>&nbsp;                that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
<i>5148</i>&nbsp;                        -1, syms.noSymbol);
<i>5149</i>&nbsp;            }
<i>5150</i>&nbsp;            super.visitUnary(that);
<i>5151</i>&nbsp;        }
<i>5152</i>&nbsp;
<i>5153</i>&nbsp;        @Override
<i>5154</i>&nbsp;        public void visitLambda(JCLambda that) {
<i>5155</i>&nbsp;            super.visitLambda(that);
<i>5156</i>&nbsp;            if (that.target == null) {
<i>5157</i>&nbsp;                that.target = syms.unknownType;
<i>5158</i>&nbsp;            }
<i>5159</i>&nbsp;        }
<i>5160</i>&nbsp;
<i>5161</i>&nbsp;        @Override
<i>5162</i>&nbsp;        public void visitReference(JCMemberReference that) {
<i>5163</i>&nbsp;            super.visitReference(that);
<i>5164</i>&nbsp;            if (that.sym == null) {
<i>5165</i>&nbsp;                that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
<i>5166</i>&nbsp;                        syms.noSymbol);
<i>5167</i>&nbsp;            }
<i>5168</i>&nbsp;            if (that.target == null) {
<i>5169</i>&nbsp;                that.target = syms.unknownType;
<i>5170</i>&nbsp;            }
<i>5171</i>&nbsp;        }
<i>5172</i>&nbsp;    }
<i>5173</i>&nbsp;    // &lt;/editor-fold&gt;
<i>5174</i>&nbsp;
<i>5175</i>&nbsp;    public void setPackageSymbols(JCExpression pid, Symbol pkg) {
<i>5176</i>&nbsp;        new TreeScanner() {
<i>5177</i>&nbsp;            Symbol packge = pkg;
<i>5178</i>&nbsp;            @Override
<i>5179</i>&nbsp;            public void visitIdent(JCIdent that) {
<i>5180</i>&nbsp;                that.sym = packge;
<i>5181</i>&nbsp;            }
<i>5182</i>&nbsp;
<i>5183</i>&nbsp;            @Override
<i>5184</i>&nbsp;            public void visitSelect(JCFieldAccess that) {
<i>5185</i>&nbsp;                that.sym = packge;
<i>5186</i>&nbsp;                packge = packge.owner;
<i>5187</i>&nbsp;                super.visitSelect(that);
<i>5188</i>&nbsp;            }
<i>5189</i>&nbsp;        }.scan(pid);
<i>5190</i>&nbsp;    }
<i>5191</i>&nbsp;
<i>5192</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
