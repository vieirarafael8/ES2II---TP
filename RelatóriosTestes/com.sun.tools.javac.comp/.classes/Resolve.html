


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Resolve</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.comp</a> ]
</div>

<h1>Coverage Summary for Class: Resolve (com.sun.tools.javac.comp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Resolve</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 92)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 882)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Resolve$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$12$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$4$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$4$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$5$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$AbstractMethodCheck</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$AccessError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$AmbiguityError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ArrayConstructorReferenceLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$BadVarargsMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$BasicLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ConstructorReferenceLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ConstructorReferenceLookupHelper$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InapplicableMethodException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InapplicableSymbolError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InapplicableSymbolsError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InapplicableSymbolsError$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InterfaceLookupPhase</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InterfaceLookupPhase$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InterfaceLookupPhase$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$InvalidSymbolError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$LookupFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$LookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodCheckContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodCheckDiag</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodReferenceCheck</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodReferenceCheck$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodReferenceLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionContext$Candidate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionDiagHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionDiagHelper$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionDiagHelper$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionDiagHelper$Template</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionPhase</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResolutionPhase$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MethodResultInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MostSpecificCheck</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MostSpecificCheck$MostSpecificCheckContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MostSpecificCheck$MostSpecificCheckContext$FunctionalInterfaceMostSpecificChecker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$MostSpecificCheck$MostSpecificCheckContext$FunctionalInterfaceMostSpecificChecker$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ReferenceLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ReferenceLookupHelper$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ResolveDeferredRecoveryMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$ResolveError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$SearchResultKind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$StaticError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$SymbolNotFoundError</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$UnboundMethodReferenceLookupHelper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Resolve$VerboseResolutionMode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 315)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1628)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.comp;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.tools.javac.api.Formattable.LocalizedString;
<i>29</i>&nbsp;import com.sun.tools.javac.code.*;
<i>30</i>&nbsp;import com.sun.tools.javac.code.Scope.WriteableScope;
<i>31</i>&nbsp;import com.sun.tools.javac.code.Source.Feature;
<i>32</i>&nbsp;import com.sun.tools.javac.code.Symbol.*;
<i>33</i>&nbsp;import com.sun.tools.javac.code.Type.*;
<i>34</i>&nbsp;import com.sun.tools.javac.comp.Attr.ResultInfo;
<i>35</i>&nbsp;import com.sun.tools.javac.comp.Check.CheckContext;
<i>36</i>&nbsp;import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
<i>37</i>&nbsp;import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
<i>38</i>&nbsp;import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
<i>39</i>&nbsp;import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
<i>40</i>&nbsp;import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
<i>41</i>&nbsp;import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
<i>42</i>&nbsp;import com.sun.tools.javac.jvm.*;
<i>43</i>&nbsp;import com.sun.tools.javac.main.Option;
<i>44</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Errors;
<i>45</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<i>46</i>&nbsp;import com.sun.tools.javac.tree.*;
<i>47</i>&nbsp;import com.sun.tools.javac.tree.JCTree.*;
<i>48</i>&nbsp;import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
<i>49</i>&nbsp;import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
<i>50</i>&nbsp;import com.sun.tools.javac.util.*;
<i>51</i>&nbsp;import com.sun.tools.javac.util.DefinedBy.Api;
<i>52</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
<i>53</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<i>54</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
<i>55</i>&nbsp;
<i>56</i>&nbsp;import java.util.Arrays;
<i>57</i>&nbsp;import java.util.Collection;
<i>58</i>&nbsp;import java.util.EnumSet;
<i>59</i>&nbsp;import java.util.HashSet;
<i>60</i>&nbsp;import java.util.Iterator;
<i>61</i>&nbsp;import java.util.LinkedHashMap;
<i>62</i>&nbsp;import java.util.Map;
<i>63</i>&nbsp;import java.util.Set;
<i>64</i>&nbsp;import java.util.function.BiFunction;
<i>65</i>&nbsp;import java.util.function.BiPredicate;
<i>66</i>&nbsp;import java.util.function.Function;
<i>67</i>&nbsp;import java.util.function.Predicate;
<i>68</i>&nbsp;import java.util.stream.Stream;
<i>69</i>&nbsp;
<i>70</i>&nbsp;import javax.lang.model.element.ElementVisitor;
<i>71</i>&nbsp;
<i>72</i>&nbsp;import static com.sun.tools.javac.code.Flags.*;
<i>73</i>&nbsp;import static com.sun.tools.javac.code.Flags.BLOCK;
<i>74</i>&nbsp;import static com.sun.tools.javac.code.Flags.STATIC;
<i>75</i>&nbsp;import static com.sun.tools.javac.code.Kinds.*;
<i>76</i>&nbsp;import static com.sun.tools.javac.code.Kinds.Kind.*;
<i>77</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.*;
<i>78</i>&nbsp;import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
<i>79</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.Tag.*;
<b class="nc"><i>80</i>&nbsp;import static com.sun.tools.javac.util.Iterators.createCompoundIterator;</b>
<b class="nc"><i>81</i>&nbsp;</b>
<i>82</i>&nbsp;/** Helper class for name resolution, used mostly by the attribution phase.
<i>83</i>&nbsp; *
<i>84</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>85</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>86</i>&nbsp; *  This code and its internal interfaces are subject to change or
<i>87</i>&nbsp; *  deletion without notice.&lt;/b&gt;
<i>88</i>&nbsp; */
<i>89</i>&nbsp;public class Resolve {
<i>90</i>&nbsp;    protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
<i>91</i>&nbsp;
<i>92</i>&nbsp;    Names names;
<i>93</i>&nbsp;    Log log;
<i>94</i>&nbsp;    Symtab syms;
<i>95</i>&nbsp;    Attr attr;
<i>96</i>&nbsp;    DeferredAttr deferredAttr;
<i>97</i>&nbsp;    Check chk;
<i>98</i>&nbsp;    Infer infer;
<i>99</i>&nbsp;    ClassFinder finder;
<i>100</i>&nbsp;    ModuleFinder moduleFinder;
<i>101</i>&nbsp;    Types types;
<i>102</i>&nbsp;    JCDiagnostic.Factory diags;
<i>103</i>&nbsp;    public final boolean allowMethodHandles;
<i>104</i>&nbsp;    public final boolean allowFunctionalInterfaceMostSpecific;
<i>105</i>&nbsp;    public final boolean allowModules;
<b class="nc"><i>106</i>&nbsp;    public final boolean checkVarargsAccessAfterResolution;</b>
<b class="nc"><i>107</i>&nbsp;    private final boolean compactMethodDiags;</b>
<b class="nc"><i>108</i>&nbsp;    private final boolean allowLocalVariableTypeInference;</b>
<i>109</i>&nbsp;    final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
<b class="nc"><i>110</i>&nbsp;</b>
<i>111</i>&nbsp;    WriteableScope polymorphicSignatureScope;
<b class="nc"><i>112</i>&nbsp;</b>
<i>113</i>&nbsp;    protected Resolve(Context context) {
<b class="nc"><i>114</i>&nbsp;        context.put(resolveKey, this);</b>
<i>115</i>&nbsp;        syms = Symtab.instance(context);
<i>116</i>&nbsp;
<b class="nc"><i>117</i>&nbsp;        varNotFound = new SymbolNotFoundError(ABSENT_VAR);</b>
<i>118</i>&nbsp;        methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
<i>119</i>&nbsp;        typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
<b class="nc"><i>120</i>&nbsp;        referenceNotFound = ReferenceLookupResult.error(methodNotFound);</b>
<b class="nc"><i>121</i>&nbsp;</b>
<b class="nc"><i>122</i>&nbsp;        names = Names.instance(context);</b>
<b class="nc"><i>123</i>&nbsp;        log = Log.instance(context);</b>
<b class="nc"><i>124</i>&nbsp;        attr = Attr.instance(context);</b>
<b class="nc"><i>125</i>&nbsp;        deferredAttr = DeferredAttr.instance(context);</b>
<b class="nc"><i>126</i>&nbsp;        chk = Check.instance(context);</b>
<b class="nc"><i>127</i>&nbsp;        infer = Infer.instance(context);</b>
<b class="nc"><i>128</i>&nbsp;        finder = ClassFinder.instance(context);</b>
<b class="nc"><i>129</i>&nbsp;        moduleFinder = ModuleFinder.instance(context);</b>
<b class="nc"><i>130</i>&nbsp;        types = Types.instance(context);</b>
<b class="nc"><i>131</i>&nbsp;        diags = JCDiagnostic.Factory.instance(context);</b>
<b class="nc"><i>132</i>&nbsp;        Source source = Source.instance(context);</b>
<b class="nc"><i>133</i>&nbsp;        Options options = Options.instance(context);</b>
<b class="nc"><i>134</i>&nbsp;        compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||</b>
<b class="nc"><i>135</i>&nbsp;                options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);</b>
<b class="nc"><i>136</i>&nbsp;        verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);</b>
<b class="nc"><i>137</i>&nbsp;        Target target = Target.instance(context);</b>
<b class="nc"><i>138</i>&nbsp;        allowMethodHandles = target.hasMethodHandles();</b>
<b class="nc"><i>139</i>&nbsp;        allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);</b>
<b class="nc"><i>140</i>&nbsp;        allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);</b>
<b class="nc"><i>141</i>&nbsp;        checkVarargsAccessAfterResolution =</b>
<b class="nc"><i>142</i>&nbsp;                Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);</b>
<b class="nc"><i>143</i>&nbsp;        polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);</b>
<i>144</i>&nbsp;        allowModules = Feature.MODULES.allowedInSource(source);
<b class="nc"><i>145</i>&nbsp;    }</b>
<i>146</i>&nbsp;
<i>147</i>&nbsp;    /** error symbols, which are returned when resolution fails
<i>148</i>&nbsp;     */
<i>149</i>&nbsp;    private final SymbolNotFoundError varNotFound;
<i>150</i>&nbsp;    private final SymbolNotFoundError methodNotFound;
<i>151</i>&nbsp;    private final SymbolNotFoundError typeNotFound;
<i>152</i>&nbsp;
<i>153</i>&nbsp;    /** empty reference lookup result */
<i>154</i>&nbsp;    private final ReferenceLookupResult referenceNotFound;
<i>155</i>&nbsp;
<b class="nc"><i>156</i>&nbsp;    public static Resolve instance(Context context) {</b>
<b class="nc"><i>157</i>&nbsp;        Resolve instance = context.get(resolveKey);</b>
<b class="nc"><i>158</i>&nbsp;        if (instance == null)</b>
<b class="nc"><i>159</i>&nbsp;            instance = new Resolve(context);</b>
<i>160</i>&nbsp;        return instance;
<i>161</i>&nbsp;    }
<i>162</i>&nbsp;
<b class="nc"><i>163</i>&nbsp;    private static Symbol bestOf(Symbol s1,</b>
<b class="nc"><i>164</i>&nbsp;                                 Symbol s2) {</b>
<b class="nc"><i>165</i>&nbsp;        return s1.kind.betterThan(s2.kind) ? s1 : s2;</b>
<b class="nc"><i>166</i>&nbsp;    }</b>
<b class="nc"><i>167</i>&nbsp;</b>
<b class="nc"><i>168</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;</b>
<b class="nc"><i>169</i>&nbsp;    enum VerboseResolutionMode {</b>
<b class="nc"><i>170</i>&nbsp;        SUCCESS(&quot;success&quot;),</b>
<b class="nc"><i>171</i>&nbsp;        FAILURE(&quot;failure&quot;),</b>
<i>172</i>&nbsp;        APPLICABLE(&quot;applicable&quot;),
<i>173</i>&nbsp;        INAPPLICABLE(&quot;inapplicable&quot;),
<i>174</i>&nbsp;        DEFERRED_INST(&quot;deferred-inference&quot;),
<b class="nc"><i>175</i>&nbsp;        PREDEF(&quot;predef&quot;),</b>
<b class="nc"><i>176</i>&nbsp;        OBJECT_INIT(&quot;object-init&quot;),</b>
<i>177</i>&nbsp;        INTERNAL(&quot;internal&quot;);
<i>178</i>&nbsp;
<i>179</i>&nbsp;        final String opt;
<b class="nc"><i>180</i>&nbsp;</b>
<b class="nc"><i>181</i>&nbsp;        private VerboseResolutionMode(String opt) {</b>
<b class="nc"><i>182</i>&nbsp;            this.opt = opt;</b>
<b class="nc"><i>183</i>&nbsp;        }</b>
<b class="nc"><i>184</i>&nbsp;</b>
<i>185</i>&nbsp;        static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
<b class="nc"><i>186</i>&nbsp;            String s = opts.get(&quot;debug.verboseResolution&quot;);</b>
<b class="nc"><i>187</i>&nbsp;            EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);</b>
<b class="nc"><i>188</i>&nbsp;            if (s == null) return res;</b>
<b class="nc"><i>189</i>&nbsp;            if (s.contains(&quot;all&quot;)) {</b>
<b class="nc"><i>190</i>&nbsp;                res = EnumSet.allOf(VerboseResolutionMode.class);</b>
<b class="nc"><i>191</i>&nbsp;            }</b>
<i>192</i>&nbsp;            Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
<i>193</i>&nbsp;            for (VerboseResolutionMode mode : values()) {
<b class="nc"><i>194</i>&nbsp;                if (args.contains(mode.opt)) {</b>
<i>195</i>&nbsp;                    res.add(mode);
<i>196</i>&nbsp;                } else if (args.contains(&quot;-&quot; + mode.opt)) {
<i>197</i>&nbsp;                    res.remove(mode);
<i>198</i>&nbsp;                }
<i>199</i>&nbsp;            }
<b class="nc"><i>200</i>&nbsp;            return res;</b>
<i>201</i>&nbsp;        }
<b class="nc"><i>202</i>&nbsp;    }</b>
<i>203</i>&nbsp;
<b class="nc"><i>204</i>&nbsp;    void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,</b>
<i>205</i>&nbsp;            List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
<i>206</i>&nbsp;        boolean success = !bestSoFar.kind.isResolutionError();
<i>207</i>&nbsp;
<b class="nc"><i>208</i>&nbsp;        if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {</b>
<i>209</i>&nbsp;            return;
<b class="nc"><i>210</i>&nbsp;        } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {</b>
<i>211</i>&nbsp;            return;
<b class="nc"><i>212</i>&nbsp;        }</b>
<b class="nc"><i>213</i>&nbsp;</b>
<i>214</i>&nbsp;        if (bestSoFar.name == names.init &amp;&amp;
<b class="nc"><i>215</i>&nbsp;                bestSoFar.owner == syms.objectType.tsym &amp;&amp;</b>
<b class="nc"><i>216</i>&nbsp;                !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {</b>
<i>217</i>&nbsp;            return; //skip diags for Object constructor resolution
<i>218</i>&nbsp;        } else if (site == syms.predefClass.type &amp;&amp;
<i>219</i>&nbsp;                !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
<b class="nc"><i>220</i>&nbsp;            return; //skip spurious diags for predef symbols (i.e. operators)</b>
<b class="nc"><i>221</i>&nbsp;        } else if (currentResolutionContext.internalResolution &amp;&amp;</b>
<b class="nc"><i>222</i>&nbsp;                !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {</b>
<b class="nc"><i>223</i>&nbsp;            return;</b>
<b class="nc"><i>224</i>&nbsp;        }</b>
<b class="nc"><i>225</i>&nbsp;</b>
<b class="nc"><i>226</i>&nbsp;        int pos = 0;</b>
<b class="nc"><i>227</i>&nbsp;        int mostSpecificPos = -1;</b>
<i>228</i>&nbsp;        ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
<b class="nc"><i>229</i>&nbsp;        for (Candidate c : currentResolutionContext.candidates) {</b>
<b class="nc"><i>230</i>&nbsp;            if (currentResolutionContext.step != c.step ||</b>
<b class="nc"><i>231</i>&nbsp;                    (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||</b>
<b class="nc"><i>232</i>&nbsp;                    (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {</b>
<b class="nc"><i>233</i>&nbsp;                continue;</b>
<b class="nc"><i>234</i>&nbsp;            } else {</b>
<i>235</i>&nbsp;                subDiags.append(c.isApplicable() ?
<b class="nc"><i>236</i>&nbsp;                        getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :</b>
<b class="nc"><i>237</i>&nbsp;                        getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));</b>
<b class="nc"><i>238</i>&nbsp;                if (c.sym == bestSoFar)</b>
<i>239</i>&nbsp;                    mostSpecificPos = pos;
<b class="nc"><i>240</i>&nbsp;                pos++;</b>
<b class="nc"><i>241</i>&nbsp;            }</b>
<b class="nc"><i>242</i>&nbsp;        }</b>
<b class="nc"><i>243</i>&nbsp;        String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;</b>
<b class="nc"><i>244</i>&nbsp;        List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));</b>
<b class="nc"><i>245</i>&nbsp;        JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,</b>
<i>246</i>&nbsp;                site.tsym, mostSpecificPos, currentResolutionContext.step,
<i>247</i>&nbsp;                methodArguments(argtypes2),
<i>248</i>&nbsp;                methodArguments(typeargtypes));
<b class="nc"><i>249</i>&nbsp;        JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());</b>
<b class="nc"><i>250</i>&nbsp;        log.report(d);</b>
<b class="nc"><i>251</i>&nbsp;    }</b>
<i>252</i>&nbsp;
<i>253</i>&nbsp;    JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
<b class="nc"><i>254</i>&nbsp;        JCDiagnostic subDiag = null;</b>
<i>255</i>&nbsp;        if (sym.type.hasTag(FORALL)) {
<i>256</i>&nbsp;            subDiag = diags.fragment(Fragments.PartialInstSig(inst));
<i>257</i>&nbsp;        }
<b class="nc"><i>258</i>&nbsp;</b>
<i>259</i>&nbsp;        String key = subDiag == null ?
<i>260</i>&nbsp;                &quot;applicable.method.found&quot; :
<i>261</i>&nbsp;                &quot;applicable.method.found.1&quot;;
<b class="nc"><i>262</i>&nbsp;</b>
<i>263</i>&nbsp;        return diags.fragment(key, pos, sym, subDiag);
<i>264</i>&nbsp;    }
<i>265</i>&nbsp;
<i>266</i>&nbsp;    JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
<i>267</i>&nbsp;        return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
<i>268</i>&nbsp;    }
<i>269</i>&nbsp;    // &lt;/editor-fold&gt;
<i>270</i>&nbsp;
<i>271</i>&nbsp;/* ************************************************************************
<i>272</i>&nbsp; * Identifier resolution
<i>273</i>&nbsp; *************************************************************************/
<b class="nc"><i>274</i>&nbsp;</b>
<i>275</i>&nbsp;    /** An environment is &quot;static&quot; if its static level is greater than
<i>276</i>&nbsp;     *  the one of its outer environment
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
<i>279</i>&nbsp;        return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
<i>280</i>&nbsp;    }
<b class="nc"><i>281</i>&nbsp;</b>
<b class="nc"><i>282</i>&nbsp;    /** An environment is an &quot;initializer&quot; if it is a constructor or</b>
<i>283</i>&nbsp;     *  an instance initializer.
<i>284</i>&nbsp;     */
<b class="nc"><i>285</i>&nbsp;    static boolean isInitializer(Env&lt;AttrContext&gt; env) {</b>
<b class="nc"><i>286</i>&nbsp;        Symbol owner = env.info.scope.owner;</b>
<i>287</i>&nbsp;        return owner.isConstructor() ||
<i>288</i>&nbsp;            owner.owner.kind == TYP &amp;&amp;
<i>289</i>&nbsp;            (owner.kind == VAR ||
<i>290</i>&nbsp;             owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
<i>291</i>&nbsp;            (owner.flags() &amp; STATIC) == 0;
<i>292</i>&nbsp;    }
<i>293</i>&nbsp;
<b class="nc"><i>294</i>&nbsp;    /** Is class accessible in given evironment?</b>
<i>295</i>&nbsp;     *  @param env    The current environment.
<i>296</i>&nbsp;     *  @param c      The class whose accessibility is checked.
<i>297</i>&nbsp;     */
<b class="nc"><i>298</i>&nbsp;    public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {</b>
<b class="nc"><i>299</i>&nbsp;        return isAccessible(env, c, false);</b>
<i>300</i>&nbsp;    }
<b class="nc"><i>301</i>&nbsp;</b>
<b class="nc"><i>302</i>&nbsp;    public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {</b>
<b class="nc"><i>303</i>&nbsp;</b>
<b class="nc"><i>304</i>&nbsp;        /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor</b>
<i>305</i>&nbsp;           to refer to an inaccessible type
<b class="nc"><i>306</i>&nbsp;        */</b>
<i>307</i>&nbsp;        if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
<i>308</i>&nbsp;            return true;
<b class="nc"><i>309</i>&nbsp;</b>
<i>310</i>&nbsp;        if (env.info.visitingServiceImplementation &amp;&amp;
<i>311</i>&nbsp;            env.toplevel.modle == c.packge().modle) {
<i>312</i>&nbsp;            return true;
<i>313</i>&nbsp;        }
<i>314</i>&nbsp;
<i>315</i>&nbsp;        boolean isAccessible = false;
<b class="nc"><i>316</i>&nbsp;        switch ((short)(c.flags() &amp; AccessFlags)) {</b>
<i>317</i>&nbsp;            case PRIVATE:
<i>318</i>&nbsp;                isAccessible =
<b class="nc"><i>319</i>&nbsp;                    env.enclClass.sym.outermostClass() ==</b>
<b class="nc"><i>320</i>&nbsp;                    c.owner.outermostClass();</b>
<i>321</i>&nbsp;                break;
<b class="nc"><i>322</i>&nbsp;            case 0:</b>
<i>323</i>&nbsp;                isAccessible =
<i>324</i>&nbsp;                    env.toplevel.packge == c.owner // fast special case
<b class="nc"><i>325</i>&nbsp;                    ||</b>
<i>326</i>&nbsp;                    env.toplevel.packge == c.packge();
<b class="nc"><i>327</i>&nbsp;                break;</b>
<i>328</i>&nbsp;            default: // error recovery
<i>329</i>&nbsp;                isAccessible = true;
<b class="nc"><i>330</i>&nbsp;                break;</b>
<i>331</i>&nbsp;            case PUBLIC:
<b class="nc"><i>332</i>&nbsp;                if (allowModules) {</b>
<i>333</i>&nbsp;                    ModuleSymbol currModule = env.toplevel.modle;
<i>334</i>&nbsp;                    currModule.complete();
<i>335</i>&nbsp;                    PackageSymbol p = c.packge();
<i>336</i>&nbsp;                    isAccessible =
<i>337</i>&nbsp;                        currModule == p.modle ||
<i>338</i>&nbsp;                        currModule.visiblePackages.get(p.fullname) == p ||
<i>339</i>&nbsp;                        p == syms.rootPackage ||
<i>340</i>&nbsp;                        (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
<i>341</i>&nbsp;                } else {
<b class="nc"><i>342</i>&nbsp;                    isAccessible = true;</b>
<b class="nc"><i>343</i>&nbsp;                }</b>
<i>344</i>&nbsp;                break;
<b class="nc"><i>345</i>&nbsp;            case PROTECTED:</b>
<i>346</i>&nbsp;                isAccessible =
<i>347</i>&nbsp;                    env.toplevel.packge == c.owner // fast special case
<i>348</i>&nbsp;                    ||
<b class="nc"><i>349</i>&nbsp;                    env.toplevel.packge == c.packge()</b>
<i>350</i>&nbsp;                    ||
<i>351</i>&nbsp;                    isInnerSubClass(env.enclClass.sym, c.owner);
<i>352</i>&nbsp;                break;
<b class="nc"><i>353</i>&nbsp;        }</b>
<b class="nc"><i>354</i>&nbsp;        return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?</b>
<b class="nc"><i>355</i>&nbsp;            isAccessible :</b>
<i>356</i>&nbsp;            isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
<i>357</i>&nbsp;    }
<i>358</i>&nbsp;    //where
<i>359</i>&nbsp;        /** Is given class a subclass of given base class, or an inner class
<i>360</i>&nbsp;         *  of a subclass?
<i>361</i>&nbsp;         *  Return null if no such class exists.
<i>362</i>&nbsp;         *  @param c     The class which is the subclass or is contained in it.
<i>363</i>&nbsp;         *  @param base  The base class
<i>364</i>&nbsp;         */
<b class="nc"><i>365</i>&nbsp;        private boolean isInnerSubClass(ClassSymbol c, Symbol base) {</b>
<i>366</i>&nbsp;            while (c != null &amp;&amp; !c.isSubClass(base, types)) {
<i>367</i>&nbsp;                c = c.owner.enclClass();
<b class="nc"><i>368</i>&nbsp;            }</b>
<b class="nc"><i>369</i>&nbsp;            return c != null;</b>
<i>370</i>&nbsp;        }
<b class="nc"><i>371</i>&nbsp;</b>
<i>372</i>&nbsp;    boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
<i>373</i>&nbsp;        return isAccessible(env, t, false);
<b class="nc"><i>374</i>&nbsp;    }</b>
<b class="nc"><i>375</i>&nbsp;</b>
<i>376</i>&nbsp;    boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
<b class="nc"><i>377</i>&nbsp;        return (t.hasTag(ARRAY))</b>
<i>378</i>&nbsp;            ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
<b class="nc"><i>379</i>&nbsp;            : isAccessible(env, t.tsym, checkInner);</b>
<i>380</i>&nbsp;    }
<i>381</i>&nbsp;
<b class="nc"><i>382</i>&nbsp;    /** Is symbol accessible as a member of given type in given environment?</b>
<i>383</i>&nbsp;     *  @param env    The current environment.
<b class="nc"><i>384</i>&nbsp;     *  @param site   The type of which the tested symbol is regarded</b>
<i>385</i>&nbsp;     *                as a member.
<b class="nc"><i>386</i>&nbsp;     *  @param sym    The symbol.</b>
<i>387</i>&nbsp;     */
<b class="nc"><i>388</i>&nbsp;    public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {</b>
<i>389</i>&nbsp;        return isAccessible(env, site, sym, false);
<b class="nc"><i>390</i>&nbsp;    }</b>
<i>391</i>&nbsp;    public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
<i>392</i>&nbsp;        if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
<b class="nc"><i>393</i>&nbsp;</b>
<i>394</i>&nbsp;        /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
<b class="nc"><i>395</i>&nbsp;           to refer to an inaccessible type</b>
<i>396</i>&nbsp;        */
<i>397</i>&nbsp;        if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
<i>398</i>&nbsp;            return true;
<b class="nc"><i>399</i>&nbsp;</b>
<i>400</i>&nbsp;        if (env.info.visitingServiceImplementation &amp;&amp;
<b class="nc"><i>401</i>&nbsp;            env.toplevel.modle == sym.packge().modle) {</b>
<i>402</i>&nbsp;            return true;
<b class="nc"><i>403</i>&nbsp;        }</b>
<i>404</i>&nbsp;
<b class="nc"><i>405</i>&nbsp;        switch ((short)(sym.flags() &amp; AccessFlags)) {</b>
<i>406</i>&nbsp;        case PRIVATE:
<i>407</i>&nbsp;            return
<i>408</i>&nbsp;                (env.enclClass.sym == sym.owner // fast special case
<i>409</i>&nbsp;                 ||
<i>410</i>&nbsp;                 env.enclClass.sym.outermostClass() ==
<i>411</i>&nbsp;                 sym.owner.outermostClass())
<i>412</i>&nbsp;                &amp;&amp;
<i>413</i>&nbsp;                sym.isInheritedIn(site.tsym, types);
<i>414</i>&nbsp;        case 0:
<i>415</i>&nbsp;            return
<b class="nc"><i>416</i>&nbsp;                (env.toplevel.packge == sym.owner.owner // fast special case</b>
<b class="nc"><i>417</i>&nbsp;                 ||</b>
<i>418</i>&nbsp;                 env.toplevel.packge == sym.packge())
<b class="nc"><i>419</i>&nbsp;                &amp;&amp;</b>
<b class="nc"><i>420</i>&nbsp;                isAccessible(env, site, checkInner)</b>
<b class="nc"><i>421</i>&nbsp;                &amp;&amp;</b>
<i>422</i>&nbsp;                sym.isInheritedIn(site.tsym, types)
<i>423</i>&nbsp;                &amp;&amp;
<i>424</i>&nbsp;                notOverriddenIn(site, sym);
<i>425</i>&nbsp;        case PROTECTED:
<i>426</i>&nbsp;            return
<i>427</i>&nbsp;                (env.toplevel.packge == sym.owner.owner // fast special case
<i>428</i>&nbsp;                 ||
<i>429</i>&nbsp;                 env.toplevel.packge == sym.packge()
<i>430</i>&nbsp;                 ||
<i>431</i>&nbsp;                 isProtectedAccessible(sym, env.enclClass.sym, site)
<i>432</i>&nbsp;                 ||
<b class="nc"><i>433</i>&nbsp;                 // OK to select instance method or field from &#39;super&#39; or type name</b>
<b class="nc"><i>434</i>&nbsp;                 // (but type names should be disallowed elsewhere!)</b>
<b class="nc"><i>435</i>&nbsp;                 env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)</b>
<b class="nc"><i>436</i>&nbsp;                &amp;&amp;</b>
<i>437</i>&nbsp;                isAccessible(env, site, checkInner)
<i>438</i>&nbsp;                &amp;&amp;
<i>439</i>&nbsp;                notOverriddenIn(site, sym);
<b class="nc"><i>440</i>&nbsp;        default: // this case includes erroneous combinations as well</b>
<b class="nc"><i>441</i>&nbsp;            return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);</b>
<b class="nc"><i>442</i>&nbsp;        }</b>
<i>443</i>&nbsp;    }
<i>444</i>&nbsp;    //where
<i>445</i>&nbsp;    /* `sym&#39; is accessible only if not overridden by
<i>446</i>&nbsp;     * another symbol which is a member of `site&#39;
<i>447</i>&nbsp;     * (because, if it is overridden, `sym&#39; is not strictly
<i>448</i>&nbsp;     * speaking a member of `site&#39;). A polymorphic signature method
<i>449</i>&nbsp;     * cannot be overridden (e.g. MH.invokeExact(Object[])).
<b class="nc"><i>450</i>&nbsp;     */</b>
<i>451</i>&nbsp;    private boolean notOverriddenIn(Type site, Symbol sym) {
<i>452</i>&nbsp;        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
<i>453</i>&nbsp;            return true;
<i>454</i>&nbsp;        else {
<i>455</i>&nbsp;            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
<b class="nc"><i>456</i>&nbsp;            return (s2 == null || s2 == sym || sym.owner == s2.owner ||</b>
<b class="nc"><i>457</i>&nbsp;                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));</b>
<i>458</i>&nbsp;        }
<i>459</i>&nbsp;    }
<b class="nc"><i>460</i>&nbsp;    //where</b>
<b class="nc"><i>461</i>&nbsp;        /** Is given protected symbol accessible if it is selected from given site</b>
<b class="nc"><i>462</i>&nbsp;         *  and the selection takes place in given class?</b>
<i>463</i>&nbsp;         *  @param sym     The symbol with protected access
<i>464</i>&nbsp;         *  @param c       The class where the access takes place
<i>465</i>&nbsp;         *  @site          The type of the qualifier
<b class="nc"><i>466</i>&nbsp;         */</b>
<i>467</i>&nbsp;        private
<i>468</i>&nbsp;        boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
<i>469</i>&nbsp;            Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
<i>470</i>&nbsp;            while (c != null &amp;&amp;
<b class="nc"><i>471</i>&nbsp;                   !(c.isSubClass(sym.owner, types) &amp;&amp;</b>
<b class="nc"><i>472</i>&nbsp;                     (c.flags() &amp; INTERFACE) == 0 &amp;&amp;</b>
<i>473</i>&nbsp;                     // In JLS 2e 6.6.2.1, the subclass restriction applies
<i>474</i>&nbsp;                     // only to instance fields and methods -- types are excluded
<i>475</i>&nbsp;                     // regardless of whether they are declared &#39;static&#39; or not.
<i>476</i>&nbsp;                     ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
<b class="nc"><i>477</i>&nbsp;                c = c.owner.enclClass();</b>
<b class="nc"><i>478</i>&nbsp;            return c != null;</b>
<b class="nc"><i>479</i>&nbsp;        }</b>
<i>480</i>&nbsp;
<b class="nc"><i>481</i>&nbsp;    /**</b>
<i>482</i>&nbsp;     * Performs a recursive scan of a type looking for accessibility problems
<i>483</i>&nbsp;     * from current attribution environment
<i>484</i>&nbsp;     */
<i>485</i>&nbsp;    void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
<b class="nc"><i>486</i>&nbsp;        accessibilityChecker.visit(t, env);</b>
<b class="nc"><i>487</i>&nbsp;    }</b>
<i>488</i>&nbsp;
<i>489</i>&nbsp;    /**
<i>490</i>&nbsp;     * Accessibility type-visitor
<i>491</i>&nbsp;     */
<b class="nc"><i>492</i>&nbsp;    Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =</b>
<b class="nc"><i>493</i>&nbsp;            new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {</b>
<b class="nc"><i>494</i>&nbsp;</b>
<b class="nc"><i>495</i>&nbsp;        void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {</b>
<i>496</i>&nbsp;            for (Type t : ts) {
<i>497</i>&nbsp;                visit(t, env);
<i>498</i>&nbsp;            }
<i>499</i>&nbsp;        }
<i>500</i>&nbsp;
<i>501</i>&nbsp;        public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
<i>502</i>&nbsp;            return null;
<i>503</i>&nbsp;        }
<i>504</i>&nbsp;
<i>505</i>&nbsp;        @Override
<i>506</i>&nbsp;        public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
<i>507</i>&nbsp;            visit(t.elemtype, env);
<i>508</i>&nbsp;            return null;
<i>509</i>&nbsp;        }
<i>510</i>&nbsp;
<i>511</i>&nbsp;        @Override
<i>512</i>&nbsp;        public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
<i>513</i>&nbsp;            visit(t.getTypeArguments(), env);
<i>514</i>&nbsp;            if (!isAccessible(env, t, true)) {
<i>515</i>&nbsp;                accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
<i>516</i>&nbsp;            }
<i>517</i>&nbsp;            return null;
<i>518</i>&nbsp;        }
<i>519</i>&nbsp;
<i>520</i>&nbsp;        @Override
<i>521</i>&nbsp;        public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
<i>522</i>&nbsp;            visit(t.type, env);
<i>523</i>&nbsp;            return null;
<i>524</i>&nbsp;        }
<i>525</i>&nbsp;
<b class="nc"><i>526</i>&nbsp;        @Override</b>
<i>527</i>&nbsp;        public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
<i>528</i>&nbsp;            visit(t.getParameterTypes(), env);
<b class="nc"><i>529</i>&nbsp;            visit(t.getReturnType(), env);</b>
<b class="nc"><i>530</i>&nbsp;            visit(t.getThrownTypes(), env);</b>
<b class="nc"><i>531</i>&nbsp;            return null;</b>
<i>532</i>&nbsp;        }
<i>533</i>&nbsp;    };
<b class="nc"><i>534</i>&nbsp;</b>
<b class="nc"><i>535</i>&nbsp;    /** Try to instantiate the type of a method so that it fits</b>
<b class="nc"><i>536</i>&nbsp;     *  given type arguments and argument types. If successful, return</b>
<b class="nc"><i>537</i>&nbsp;     *  the method&#39;s instantiated type, else return null.</b>
<i>538</i>&nbsp;     *  The instantiation will take into account an additional leading
<b class="nc"><i>539</i>&nbsp;     *  formal parameter if the method is an instance method seen as a member</b>
<b class="nc"><i>540</i>&nbsp;     *  of an under determined site. In this case, we treat site as an additional</b>
<b class="nc"><i>541</i>&nbsp;     *  parameter and the parameters of the class containing the method as</b>
<b class="nc"><i>542</i>&nbsp;     *  additional type variables that get instantiated.</b>
<i>543</i>&nbsp;     *
<b class="nc"><i>544</i>&nbsp;     *  @param env         The current environment</b>
<b class="nc"><i>545</i>&nbsp;     *  @param site        The type of which the method is a member.</b>
<b class="nc"><i>546</i>&nbsp;     *  @param m           The method symbol.</b>
<b class="nc"><i>547</i>&nbsp;     *  @param argtypes    The invocation&#39;s given value arguments.</b>
<b class="nc"><i>548</i>&nbsp;     *  @param typeargtypes    The invocation&#39;s given type arguments.</b>
<b class="nc"><i>549</i>&nbsp;     *  @param allowBoxing Allow boxing conversions of arguments.</b>
<b class="nc"><i>550</i>&nbsp;     *  @param useVarargs Box trailing arguments into an array for varargs.</b>
<b class="nc"><i>551</i>&nbsp;     */</b>
<b class="nc"><i>552</i>&nbsp;    Type rawInstantiate(Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>553</i>&nbsp;                        Type site,</b>
<b class="nc"><i>554</i>&nbsp;                        Symbol m,</b>
<b class="nc"><i>555</i>&nbsp;                        ResultInfo resultInfo,</b>
<i>556</i>&nbsp;                        List&lt;Type&gt; argtypes,
<i>557</i>&nbsp;                        List&lt;Type&gt; typeargtypes,
<i>558</i>&nbsp;                        boolean allowBoxing,
<b class="nc"><i>559</i>&nbsp;                        boolean useVarargs,</b>
<b class="nc"><i>560</i>&nbsp;                        Warner warn) throws Infer.InferenceException {</b>
<b class="nc"><i>561</i>&nbsp;        Type mt = types.memberType(site, m);</b>
<b class="nc"><i>562</i>&nbsp;        // tvars is the list of formal type variables for which type arguments</b>
<b class="nc"><i>563</i>&nbsp;        // need to inferred.</b>
<i>564</i>&nbsp;        List&lt;Type&gt; tvars = List.nil();
<i>565</i>&nbsp;        if (typeargtypes == null) typeargtypes = List.nil();
<b class="nc"><i>566</i>&nbsp;        if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {</b>
<b class="nc"><i>567</i>&nbsp;            // This is not a polymorphic method, but typeargs are supplied</b>
<i>568</i>&nbsp;            // which is fine, see JLS 15.12.2.1
<i>569</i>&nbsp;        } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
<i>570</i>&nbsp;            ForAll pmt = (ForAll) mt;
<i>571</i>&nbsp;            if (typeargtypes.length() != pmt.tvars.length())
<i>572</i>&nbsp;                 // not enough args
<i>573</i>&nbsp;                throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
<i>574</i>&nbsp;            // Check type arguments are within bounds
<i>575</i>&nbsp;            List&lt;Type&gt; formals = pmt.tvars;
<i>576</i>&nbsp;            List&lt;Type&gt; actuals = typeargtypes;
<i>577</i>&nbsp;            while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
<b class="nc"><i>578</i>&nbsp;                List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),</b>
<b class="nc"><i>579</i>&nbsp;                                                pmt.tvars, typeargtypes);</b>
<b class="nc"><i>580</i>&nbsp;                for (; bounds.nonEmpty(); bounds = bounds.tail) {</b>
<b class="nc"><i>581</i>&nbsp;                    if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {</b>
<b class="nc"><i>582</i>&nbsp;                        throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));</b>
<i>583</i>&nbsp;                    }
<i>584</i>&nbsp;                }
<i>585</i>&nbsp;                formals = formals.tail;
<i>586</i>&nbsp;                actuals = actuals.tail;
<i>587</i>&nbsp;            }
<i>588</i>&nbsp;            mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
<i>589</i>&nbsp;        } else if (mt.hasTag(FORALL)) {
<i>590</i>&nbsp;            ForAll pmt = (ForAll) mt;
<i>591</i>&nbsp;            List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
<b class="nc"><i>592</i>&nbsp;            tvars = tvars.appendList(tvars1);</b>
<i>593</i>&nbsp;            mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
<b class="nc"><i>594</i>&nbsp;        }</b>
<b class="nc"><i>595</i>&nbsp;</b>
<b class="nc"><i>596</i>&nbsp;        // find out whether we need to go the slow route via infer</b>
<i>597</i>&nbsp;        boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
<i>598</i>&nbsp;        for (List&lt;Type&gt; l = argtypes;
<i>599</i>&nbsp;             l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
<b class="nc"><i>600</i>&nbsp;             l = l.tail) {</b>
<b class="nc"><i>601</i>&nbsp;            if (l.head.hasTag(FORALL)) instNeeded = true;</b>
<i>602</i>&nbsp;        }
<b class="nc"><i>603</i>&nbsp;</b>
<b class="nc"><i>604</i>&nbsp;        if (instNeeded) {</b>
<b class="nc"><i>605</i>&nbsp;            return infer.instantiateMethod(env,</b>
<i>606</i>&nbsp;                                    tvars,
<i>607</i>&nbsp;                                    (MethodType)mt,
<b class="nc"><i>608</i>&nbsp;                                    resultInfo,</b>
<i>609</i>&nbsp;                                    (MethodSymbol)m,
<i>610</i>&nbsp;                                    argtypes,
<i>611</i>&nbsp;                                    allowBoxing,
<i>612</i>&nbsp;                                    useVarargs,
<i>613</i>&nbsp;                                    currentResolutionContext,
<i>614</i>&nbsp;                                    warn);
<i>615</i>&nbsp;        }
<i>616</i>&nbsp;
<i>617</i>&nbsp;        DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
<i>618</i>&nbsp;        currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
<i>619</i>&nbsp;                                argtypes, mt.getParameterTypes(), warn);
<i>620</i>&nbsp;        dc.complete();
<i>621</i>&nbsp;        return mt;
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;    Type checkMethod(Env&lt;AttrContext&gt; env,</b>
<i>625</i>&nbsp;                     Type site,
<b class="nc"><i>626</i>&nbsp;                     Symbol m,</b>
<b class="nc"><i>627</i>&nbsp;                     ResultInfo resultInfo,</b>
<i>628</i>&nbsp;                     List&lt;Type&gt; argtypes,
<i>629</i>&nbsp;                     List&lt;Type&gt; typeargtypes,
<i>630</i>&nbsp;                     Warner warn) {
<i>631</i>&nbsp;        MethodResolutionContext prevContext = currentResolutionContext;
<i>632</i>&nbsp;        try {
<i>633</i>&nbsp;            currentResolutionContext = new MethodResolutionContext();
<i>634</i>&nbsp;            currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
<i>635</i>&nbsp;                    AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
<i>636</i>&nbsp;            if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
<i>637</i>&nbsp;                //method/constructor references need special check class
<i>638</i>&nbsp;                //to handle inference variables in &#39;argtypes&#39; (might happen
<i>639</i>&nbsp;                //during an unsticking round)
<i>640</i>&nbsp;                currentResolutionContext.methodCheck =
<i>641</i>&nbsp;                        new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
<i>642</i>&nbsp;            }
<i>643</i>&nbsp;            MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
<i>644</i>&nbsp;            return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
<i>645</i>&nbsp;                    step.isBoxingRequired(), step.isVarargsRequired(), warn);
<i>646</i>&nbsp;        }
<i>647</i>&nbsp;        finally {
<i>648</i>&nbsp;            currentResolutionContext = prevContext;
<i>649</i>&nbsp;        }
<i>650</i>&nbsp;    }
<i>651</i>&nbsp;
<i>652</i>&nbsp;    /** Same but returns null instead throwing a NoInstanceException
<i>653</i>&nbsp;     */
<i>654</i>&nbsp;    Type instantiate(Env&lt;AttrContext&gt; env,
<i>655</i>&nbsp;                     Type site,
<i>656</i>&nbsp;                     Symbol m,
<i>657</i>&nbsp;                     ResultInfo resultInfo,
<i>658</i>&nbsp;                     List&lt;Type&gt; argtypes,
<i>659</i>&nbsp;                     List&lt;Type&gt; typeargtypes,
<i>660</i>&nbsp;                     boolean allowBoxing,
<b class="nc"><i>661</i>&nbsp;                     boolean useVarargs,</b>
<i>662</i>&nbsp;                     Warner warn) {
<i>663</i>&nbsp;        try {
<i>664</i>&nbsp;            return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
<b class="nc"><i>665</i>&nbsp;                                  allowBoxing, useVarargs, warn);</b>
<i>666</i>&nbsp;        } catch (InapplicableMethodException ex) {
<i>667</i>&nbsp;            return null;
<i>668</i>&nbsp;        }
<b class="nc"><i>669</i>&nbsp;    }</b>
<i>670</i>&nbsp;
<i>671</i>&nbsp;    /**
<i>672</i>&nbsp;     * This interface defines an entry point that should be used to perform a
<b class="nc"><i>673</i>&nbsp;     * method check. A method check usually consist in determining as to whether</b>
<i>674</i>&nbsp;     * a set of types (actuals) is compatible with another set of types (formals).
<i>675</i>&nbsp;     * Since the notion of compatibility can vary depending on the circumstances,
<i>676</i>&nbsp;     * this interfaces allows to easily add new pluggable method check routines.
<b class="nc"><i>677</i>&nbsp;     */</b>
<i>678</i>&nbsp;    interface MethodCheck {
<i>679</i>&nbsp;        /**
<i>680</i>&nbsp;         * Main method check routine. A method check usually consist in determining
<i>681</i>&nbsp;         * as to whether a set of types (actuals) is compatible with another set of
<b class="nc"><i>682</i>&nbsp;         * types (formals). If an incompatibility is found, an unchecked exception</b>
<b class="nc"><i>683</i>&nbsp;         * is assumed to be thrown.</b>
<b class="nc"><i>684</i>&nbsp;         */</b>
<i>685</i>&nbsp;        void argumentsAcceptable(Env&lt;AttrContext&gt; env,
<i>686</i>&nbsp;                                DeferredAttrContext deferredAttrContext,
<i>687</i>&nbsp;                                List&lt;Type&gt; argtypes,
<b class="nc"><i>688</i>&nbsp;                                List&lt;Type&gt; formals,</b>
<i>689</i>&nbsp;                                Warner warn);
<i>690</i>&nbsp;
<i>691</i>&nbsp;        /**
<i>692</i>&nbsp;         * Retrieve the method check object that will be used during a
<i>693</i>&nbsp;         * most specific check.
<i>694</i>&nbsp;         */
<i>695</i>&nbsp;        MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
<b class="nc"><i>696</i>&nbsp;    }</b>
<i>697</i>&nbsp;
<i>698</i>&nbsp;    /**
<i>699</i>&nbsp;     * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
<i>700</i>&nbsp;     */
<i>701</i>&nbsp;    enum MethodCheckDiag {
<b class="nc"><i>702</i>&nbsp;        /**</b>
<i>703</i>&nbsp;         * Actuals and formals differs in length.
<i>704</i>&nbsp;         */
<i>705</i>&nbsp;        ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
<i>706</i>&nbsp;        /**
<i>707</i>&nbsp;         * An actual is incompatible with a formal.
<i>708</i>&nbsp;         */
<i>709</i>&nbsp;        ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
<i>710</i>&nbsp;        /**
<b class="nc"><i>711</i>&nbsp;         * An actual is incompatible with the varargs element type.</b>
<i>712</i>&nbsp;         */
<i>713</i>&nbsp;        VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
<i>714</i>&nbsp;        /**
<i>715</i>&nbsp;         * The varargs element type is inaccessible.
<i>716</i>&nbsp;         */
<i>717</i>&nbsp;        INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
<i>718</i>&nbsp;
<b class="nc"><i>719</i>&nbsp;        final String basicKey;</b>
<b class="nc"><i>720</i>&nbsp;        final String inferKey;</b>
<b class="nc"><i>721</i>&nbsp;</b>
<i>722</i>&nbsp;        MethodCheckDiag(String basicKey, String inferKey) {
<i>723</i>&nbsp;            this.basicKey = basicKey;
<b class="nc"><i>724</i>&nbsp;            this.inferKey = inferKey;</b>
<i>725</i>&nbsp;        }
<b class="nc"><i>726</i>&nbsp;</b>
<i>727</i>&nbsp;        String regex() {
<b class="nc"><i>728</i>&nbsp;            return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);</b>
<b class="nc"><i>729</i>&nbsp;        }</b>
<b class="nc"><i>730</i>&nbsp;    }</b>
<i>731</i>&nbsp;
<i>732</i>&nbsp;    /**
<b class="nc"><i>733</i>&nbsp;     * Dummy method check object. All methods are deemed applicable, regardless</b>
<b class="nc"><i>734</i>&nbsp;     * of their formal parameter types.</b>
<b class="nc"><i>735</i>&nbsp;     */</b>
<b class="nc"><i>736</i>&nbsp;    MethodCheck nilMethodCheck = new MethodCheck() {</b>
<b class="nc"><i>737</i>&nbsp;        public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {</b>
<b class="nc"><i>738</i>&nbsp;            //do nothing - method always applicable regardless of actuals</b>
<b class="nc"><i>739</i>&nbsp;        }</b>
<i>740</i>&nbsp;
<b class="nc"><i>741</i>&nbsp;        public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {</b>
<b class="nc"><i>742</i>&nbsp;            return this;</b>
<i>743</i>&nbsp;        }
<i>744</i>&nbsp;    };
<b class="nc"><i>745</i>&nbsp;</b>
<i>746</i>&nbsp;    /**
<i>747</i>&nbsp;     * Base class for &#39;real&#39; method checks. The class defines the logic for
<b class="nc"><i>748</i>&nbsp;     * iterating through formals and actuals and provides and entry point</b>
<b class="nc"><i>749</i>&nbsp;     * that can be used by subclasses in order to define the actual check logic.</b>
<b class="nc"><i>750</i>&nbsp;     */</b>
<b class="nc"><i>751</i>&nbsp;    abstract class AbstractMethodCheck implements MethodCheck {</b>
<b class="nc"><i>752</i>&nbsp;        @Override</b>
<b class="nc"><i>753</i>&nbsp;        public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>754</i>&nbsp;                                    DeferredAttrContext deferredAttrContext,</b>
<i>755</i>&nbsp;                                    List&lt;Type&gt; argtypes,
<i>756</i>&nbsp;                                    List&lt;Type&gt; formals,
<i>757</i>&nbsp;                                    Warner warn) {
<i>758</i>&nbsp;            //should we expand formals?
<i>759</i>&nbsp;            boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
<b class="nc"><i>760</i>&nbsp;            JCTree callTree = treeForDiagnostics(env);</b>
<i>761</i>&nbsp;            List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
<i>762</i>&nbsp;
<i>763</i>&nbsp;            //inference context used during this method check
<i>764</i>&nbsp;            InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
<i>765</i>&nbsp;
<i>766</i>&nbsp;            Type varargsFormal = useVarargs ? formals.last() : null;
<i>767</i>&nbsp;
<i>768</i>&nbsp;            if (varargsFormal == null &amp;&amp;
<b class="nc"><i>769</i>&nbsp;                    argtypes.size() != formals.size()) {</b>
<b class="nc"><i>770</i>&nbsp;                reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args</b>
<b class="nc"><i>771</i>&nbsp;            }</b>
<b class="nc"><i>772</i>&nbsp;</b>
<b class="nc"><i>773</i>&nbsp;            while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {</b>
<b class="nc"><i>774</i>&nbsp;                DiagnosticPosition pos = trees != null ? trees.head : null;</b>
<b class="nc"><i>775</i>&nbsp;                checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);</b>
<b class="nc"><i>776</i>&nbsp;                argtypes = argtypes.tail;</b>
<i>777</i>&nbsp;                formals = formals.tail;
<b class="nc"><i>778</i>&nbsp;                trees = trees != null ? trees.tail : trees;</b>
<b class="nc"><i>779</i>&nbsp;            }</b>
<i>780</i>&nbsp;
<i>781</i>&nbsp;            if (formals.head != varargsFormal) {
<i>782</i>&nbsp;                reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
<b class="nc"><i>783</i>&nbsp;            }</b>
<i>784</i>&nbsp;
<i>785</i>&nbsp;            if (useVarargs) {
<i>786</i>&nbsp;                //note: if applicability check is triggered by most specific test,
<i>787</i>&nbsp;                //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
<i>788</i>&nbsp;                final Type elt = types.elemtype(varargsFormal);
<i>789</i>&nbsp;                while (argtypes.nonEmpty()) {
<i>790</i>&nbsp;                    DiagnosticPosition pos = trees != null ? trees.head : null;
<i>791</i>&nbsp;                    checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
<b class="nc"><i>792</i>&nbsp;                    argtypes = argtypes.tail;</b>
<i>793</i>&nbsp;                    trees = trees != null ? trees.tail : trees;
<i>794</i>&nbsp;                }
<i>795</i>&nbsp;            }
<i>796</i>&nbsp;        }
<i>797</i>&nbsp;
<i>798</i>&nbsp;            // where
<i>799</i>&nbsp;            private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
<b class="nc"><i>800</i>&nbsp;                return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;</b>
<i>801</i>&nbsp;            }
<i>802</i>&nbsp;
<i>803</i>&nbsp;        /**
<i>804</i>&nbsp;         * Does the actual argument conforms to the corresponding formal?
<b class="nc"><i>805</i>&nbsp;         */</b>
<b class="nc"><i>806</i>&nbsp;        abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);</b>
<b class="nc"><i>807</i>&nbsp;</b>
<i>808</i>&nbsp;        protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
<b class="nc"><i>809</i>&nbsp;            boolean inferDiag = inferenceContext != infer.emptyContext;</b>
<i>810</i>&nbsp;            if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
<i>811</i>&nbsp;                Object[] args2 = new Object[args.length + 1];
<i>812</i>&nbsp;                System.arraycopy(args, 0, args2, 1, args.length);
<i>813</i>&nbsp;                args2[0] = inferenceContext.inferenceVars();
<i>814</i>&nbsp;                args = args2;
<i>815</i>&nbsp;            }
<i>816</i>&nbsp;            String key = inferDiag ? diag.inferKey : diag.basicKey;
<i>817</i>&nbsp;            throw inferDiag ?
<i>818</i>&nbsp;                infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
<i>819</i>&nbsp;                methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
<i>820</i>&nbsp;        }
<i>821</i>&nbsp;
<i>822</i>&nbsp;        /**
<i>823</i>&nbsp;         * To eliminate the overhead associated with allocating an exception object in such an
<i>824</i>&nbsp;         * hot execution path, we use flyweight pattern - and share the same exception instance
<i>825</i>&nbsp;         * across multiple method check failures.
<i>826</i>&nbsp;         */
<i>827</i>&nbsp;        class SharedInapplicableMethodException extends InapplicableMethodException {
<i>828</i>&nbsp;            private static final long serialVersionUID = 0;
<i>829</i>&nbsp;
<b class="nc"><i>830</i>&nbsp;            SharedInapplicableMethodException() {</b>
<i>831</i>&nbsp;                super(null);
<i>832</i>&nbsp;            }
<i>833</i>&nbsp;
<b class="nc"><i>834</i>&nbsp;            SharedInapplicableMethodException setMessage(JCDiagnostic details) {</b>
<b class="nc"><i>835</i>&nbsp;                this.diagnostic = details;</b>
<i>836</i>&nbsp;                return this;
<i>837</i>&nbsp;            }
<i>838</i>&nbsp;        }
<i>839</i>&nbsp;
<i>840</i>&nbsp;        SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
<i>841</i>&nbsp;
<i>842</i>&nbsp;        public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
<i>843</i>&nbsp;            return nilMethodCheck;
<b class="nc"><i>844</i>&nbsp;        }</b>
<i>845</i>&nbsp;
<b class="nc"><i>846</i>&nbsp;    }</b>
<b class="nc"><i>847</i>&nbsp;</b>
<b class="nc"><i>848</i>&nbsp;    /**</b>
<i>849</i>&nbsp;     * Arity-based method check. A method is applicable if the number of actuals
<i>850</i>&nbsp;     * supplied conforms to the method signature.
<i>851</i>&nbsp;     */
<i>852</i>&nbsp;    MethodCheck arityMethodCheck = new AbstractMethodCheck() {
<i>853</i>&nbsp;        @Override
<i>854</i>&nbsp;        void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
<i>855</i>&nbsp;            //do nothing - actual always compatible to formals
<i>856</i>&nbsp;        }
<i>857</i>&nbsp;
<i>858</i>&nbsp;        @Override
<b class="nc"><i>859</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>860</i>&nbsp;            return &quot;arityMethodCheck&quot;;</b>
<i>861</i>&nbsp;        }
<i>862</i>&nbsp;    };
<b class="nc"><i>863</i>&nbsp;</b>
<i>864</i>&nbsp;    /**
<i>865</i>&nbsp;     * Main method applicability routine. Given a list of actual types A,
<i>866</i>&nbsp;     * a list of formal types F, determines whether the types in A are
<b class="nc"><i>867</i>&nbsp;     * compatible (by method invocation conversion) with the types in F.</b>
<b class="nc"><i>868</i>&nbsp;     *</b>
<b class="nc"><i>869</i>&nbsp;     * Since this routine is shared between overload resolution and method</b>
<i>870</i>&nbsp;     * type-inference, a (possibly empty) inference context is used to convert
<i>871</i>&nbsp;     * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
<i>872</i>&nbsp;     * check so that constraints can be propagated and collected.
<i>873</i>&nbsp;     *
<i>874</i>&nbsp;     * Moreover, if one or more types in A is a deferred type, this routine uses
<i>875</i>&nbsp;     * DeferredAttr in order to perform deferred attribution. If one or more actual
<b class="nc"><i>876</i>&nbsp;     * deferred types are stuck, they are placed in a queue and revisited later</b>
<b class="nc"><i>877</i>&nbsp;     * after the remainder of the arguments have been seen. If this is not sufficient</b>
<i>878</i>&nbsp;     * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
<i>879</i>&nbsp;     *
<i>880</i>&nbsp;     * A method check handler (see above) is used in order to report errors.
<i>881</i>&nbsp;     */
<b class="nc"><i>882</i>&nbsp;    MethodCheck resolveMethodCheck = new AbstractMethodCheck() {</b>
<i>883</i>&nbsp;
<i>884</i>&nbsp;        @Override
<b class="nc"><i>885</i>&nbsp;        void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {</b>
<i>886</i>&nbsp;            ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
<i>887</i>&nbsp;            mresult.check(pos, actual);
<i>888</i>&nbsp;        }
<i>889</i>&nbsp;
<b class="nc"><i>890</i>&nbsp;        @Override</b>
<i>891</i>&nbsp;        public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
<i>892</i>&nbsp;                                    DeferredAttrContext deferredAttrContext,
<i>893</i>&nbsp;                                    List&lt;Type&gt; argtypes,
<i>894</i>&nbsp;                                    List&lt;Type&gt; formals,
<b class="nc"><i>895</i>&nbsp;                                    Warner warn) {</b>
<i>896</i>&nbsp;            super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
<i>897</i>&nbsp;            // should we check varargs element type accessibility?
<i>898</i>&nbsp;            if (deferredAttrContext.phase.isVarargsRequired()) {
<i>899</i>&nbsp;                if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
<i>900</i>&nbsp;                    varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
<i>901</i>&nbsp;                }
<i>902</i>&nbsp;            }
<i>903</i>&nbsp;        }
<i>904</i>&nbsp;
<i>905</i>&nbsp;        /**
<i>906</i>&nbsp;         * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
<i>907</i>&nbsp;         * varargs element type of either the method invocation type signature (after inference completes)
<i>908</i>&nbsp;         * or the method declaration signature (before inference completes).
<b class="nc"><i>909</i>&nbsp;         */</b>
<b class="nc"><i>910</i>&nbsp;        private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {</b>
<i>911</i>&nbsp;            if (inferenceContext.free(t)) {
<i>912</i>&nbsp;                inferenceContext.addFreeTypeListener(List.of(t),
<i>913</i>&nbsp;                        solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
<i>914</i>&nbsp;            } else {
<b class="nc"><i>915</i>&nbsp;                if (!isAccessible(env, types.erasure(t))) {</b>
<b class="nc"><i>916</i>&nbsp;                    Symbol location = env.enclClass.sym;</b>
<i>917</i>&nbsp;                    reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
<i>918</i>&nbsp;                }
<i>919</i>&nbsp;            }
<i>920</i>&nbsp;        }
<b class="nc"><i>921</i>&nbsp;</b>
<b class="nc"><i>922</i>&nbsp;        private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,</b>
<i>923</i>&nbsp;                final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
<i>924</i>&nbsp;            CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
<i>925</i>&nbsp;                MethodCheckDiag methodDiag = varargsCheck ?
<i>926</i>&nbsp;                                 MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
<b class="nc"><i>927</i>&nbsp;</b>
<b class="nc"><i>928</i>&nbsp;                @Override</b>
<b class="nc"><i>929</i>&nbsp;                public void report(DiagnosticPosition pos, JCDiagnostic details) {</b>
<i>930</i>&nbsp;                    reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
<b class="nc"><i>931</i>&nbsp;                }</b>
<i>932</i>&nbsp;            };
<i>933</i>&nbsp;            return new MethodResultInfo(to, checkContext);
<i>934</i>&nbsp;        }
<i>935</i>&nbsp;
<b class="nc"><i>936</i>&nbsp;        @Override</b>
<i>937</i>&nbsp;        public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
<i>938</i>&nbsp;            return new MostSpecificCheck(actuals);
<b class="nc"><i>939</i>&nbsp;        }</b>
<i>940</i>&nbsp;
<i>941</i>&nbsp;        @Override
<i>942</i>&nbsp;        public String toString() {
<i>943</i>&nbsp;            return &quot;resolveMethodCheck&quot;;
<b class="nc"><i>944</i>&nbsp;        }</b>
<i>945</i>&nbsp;    };
<i>946</i>&nbsp;
<i>947</i>&nbsp;    /**
<i>948</i>&nbsp;     * This class handles method reference applicability checks; since during
<i>949</i>&nbsp;     * these checks it&#39;s sometime possible to have inference variables on
<i>950</i>&nbsp;     * the actual argument types list, the method applicability check must be
<i>951</i>&nbsp;     * extended so that inference variables are &#39;opened&#39; as needed.
<i>952</i>&nbsp;     */
<i>953</i>&nbsp;    class MethodReferenceCheck extends AbstractMethodCheck {
<i>954</i>&nbsp;
<i>955</i>&nbsp;        InferenceContext pendingInferenceContext;
<i>956</i>&nbsp;
<i>957</i>&nbsp;        MethodReferenceCheck(InferenceContext pendingInferenceContext) {
<b class="nc"><i>958</i>&nbsp;            this.pendingInferenceContext = pendingInferenceContext;</b>
<b class="nc"><i>959</i>&nbsp;        }</b>
<b class="nc"><i>960</i>&nbsp;</b>
<b class="nc"><i>961</i>&nbsp;        @Override</b>
<i>962</i>&nbsp;        void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
<i>963</i>&nbsp;            ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
<i>964</i>&nbsp;            mresult.check(pos, actual);
<b class="nc"><i>965</i>&nbsp;        }</b>
<b class="nc"><i>966</i>&nbsp;</b>
<b class="nc"><i>967</i>&nbsp;        private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,</b>
<b class="nc"><i>968</i>&nbsp;                final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {</b>
<i>969</i>&nbsp;            CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
<i>970</i>&nbsp;                MethodCheckDiag methodDiag = varargsCheck ?
<i>971</i>&nbsp;                                 MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
<b class="nc"><i>972</i>&nbsp;</b>
<i>973</i>&nbsp;                @Override
<i>974</i>&nbsp;                public boolean compatible(Type found, Type req, Warner warn) {
<i>975</i>&nbsp;                    found = pendingInferenceContext.asUndetVar(found);
<b class="nc"><i>976</i>&nbsp;                    if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {</b>
<i>977</i>&nbsp;                        req = types.boxedClass(req).type;
<i>978</i>&nbsp;                    }
<i>979</i>&nbsp;                    return super.compatible(found, req, warn);
<b class="nc"><i>980</i>&nbsp;                }</b>
<i>981</i>&nbsp;
<i>982</i>&nbsp;                @Override
<i>983</i>&nbsp;                public void report(DiagnosticPosition pos, JCDiagnostic details) {
<b class="nc"><i>984</i>&nbsp;                    reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);</b>
<i>985</i>&nbsp;                }
<i>986</i>&nbsp;            };
<i>987</i>&nbsp;            return new MethodResultInfo(to, checkContext);
<i>988</i>&nbsp;        }
<b class="nc"><i>989</i>&nbsp;</b>
<i>990</i>&nbsp;        @Override
<i>991</i>&nbsp;        public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
<i>992</i>&nbsp;            return new MostSpecificCheck(actuals);
<i>993</i>&nbsp;        }
<i>994</i>&nbsp;
<i>995</i>&nbsp;        @Override
<i>996</i>&nbsp;        public String toString() {
<i>997</i>&nbsp;            return &quot;MethodReferenceCheck&quot;;
<i>998</i>&nbsp;        }
<i>999</i>&nbsp;    }
<b class="nc"><i>1000</i>&nbsp;</b>
<b class="nc"><i>1001</i>&nbsp;    /**</b>
<i>1002</i>&nbsp;     * Check context to be used during method applicability checks. A method check
<i>1003</i>&nbsp;     * context might contain inference variables.
<i>1004</i>&nbsp;     */
<i>1005</i>&nbsp;    abstract class MethodCheckContext implements CheckContext {
<b class="nc"><i>1006</i>&nbsp;</b>
<b class="nc"><i>1007</i>&nbsp;        boolean strict;</b>
<b class="nc"><i>1008</i>&nbsp;        DeferredAttrContext deferredAttrContext;</b>
<i>1009</i>&nbsp;        Warner rsWarner;
<b class="nc"><i>1010</i>&nbsp;</b>
<b class="nc"><i>1011</i>&nbsp;        public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {</b>
<b class="nc"><i>1012</i>&nbsp;           this.strict = strict;</b>
<b class="nc"><i>1013</i>&nbsp;           this.deferredAttrContext = deferredAttrContext;</b>
<b class="nc"><i>1014</i>&nbsp;           this.rsWarner = rsWarner;</b>
<b class="nc"><i>1015</i>&nbsp;        }</b>
<i>1016</i>&nbsp;
<i>1017</i>&nbsp;        public boolean compatible(Type found, Type req, Warner warn) {
<i>1018</i>&nbsp;            InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
<i>1019</i>&nbsp;            return strict ?
<i>1020</i>&nbsp;                    types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
<i>1021</i>&nbsp;                    types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
<i>1022</i>&nbsp;        }
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;        public void report(DiagnosticPosition pos, JCDiagnostic details) {
<i>1025</i>&nbsp;            throw new InapplicableMethodException(details);
<i>1026</i>&nbsp;        }
<i>1027</i>&nbsp;
<b class="nc"><i>1028</i>&nbsp;        public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {</b>
<b class="nc"><i>1029</i>&nbsp;            return rsWarner;</b>
<i>1030</i>&nbsp;        }
<i>1031</i>&nbsp;
<i>1032</i>&nbsp;        public InferenceContext inferenceContext() {
<i>1033</i>&nbsp;            return deferredAttrContext.inferenceContext;
<b class="nc"><i>1034</i>&nbsp;        }</b>
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;        public DeferredAttrContext deferredAttrContext() {
<i>1037</i>&nbsp;            return deferredAttrContext;
<i>1038</i>&nbsp;        }
<b class="nc"><i>1039</i>&nbsp;</b>
<i>1040</i>&nbsp;        @Override
<i>1041</i>&nbsp;        public String toString() {
<i>1042</i>&nbsp;            return &quot;MethodCheckContext&quot;;
<i>1043</i>&nbsp;        }
<i>1044</i>&nbsp;    }
<i>1045</i>&nbsp;
<i>1046</i>&nbsp;    /**
<i>1047</i>&nbsp;     * ResultInfo class to be used during method applicability checks. Check
<i>1048</i>&nbsp;     * for deferred types goes through special path.
<i>1049</i>&nbsp;     */
<i>1050</i>&nbsp;    class MethodResultInfo extends ResultInfo {
<i>1051</i>&nbsp;
<i>1052</i>&nbsp;        public MethodResultInfo(Type pt, CheckContext checkContext) {
<i>1053</i>&nbsp;            attr.super(KindSelector.VAL, pt, checkContext);
<b class="nc"><i>1054</i>&nbsp;        }</b>
<b class="nc"><i>1055</i>&nbsp;</b>
<b class="nc"><i>1056</i>&nbsp;        @Override</b>
<i>1057</i>&nbsp;        protected Type check(DiagnosticPosition pos, Type found) {
<i>1058</i>&nbsp;            if (found.hasTag(DEFERRED)) {
<i>1059</i>&nbsp;                DeferredType dt = (DeferredType)found;
<i>1060</i>&nbsp;                return dt.check(this);
<i>1061</i>&nbsp;            } else {
<i>1062</i>&nbsp;                Type uResult = U(found);
<i>1063</i>&nbsp;                Type capturedType = pos == null || pos.getTree() == null ?
<i>1064</i>&nbsp;                        types.capture(uResult) :
<b class="nc"><i>1065</i>&nbsp;                        checkContext.inferenceContext()</b>
<b class="nc"><i>1066</i>&nbsp;                            .cachedCapture(pos.getTree(), uResult, true);</b>
<b class="nc"><i>1067</i>&nbsp;                return super.check(pos, chk.checkNonVoid(pos, capturedType));</b>
<b class="nc"><i>1068</i>&nbsp;            }</b>
<b class="nc"><i>1069</i>&nbsp;        }</b>
<b class="nc"><i>1070</i>&nbsp;</b>
<b class="nc"><i>1071</i>&nbsp;        /**</b>
<b class="nc"><i>1072</i>&nbsp;         * javac has a long-standing &#39;simplification&#39; (see 6391995):</b>
<i>1073</i>&nbsp;         * given an actual argument type, the method check is performed
<i>1074</i>&nbsp;         * on its upper bound. This leads to inconsistencies when an
<i>1075</i>&nbsp;         * argument type is checked against itself. For example, given
<i>1076</i>&nbsp;         * a type-variable T, it is not true that {@code U(T) &lt;: T},
<i>1077</i>&nbsp;         * so we need to guard against that.
<i>1078</i>&nbsp;         */
<i>1079</i>&nbsp;        private Type U(Type found) {
<b class="nc"><i>1080</i>&nbsp;            return found == pt ?</b>
<i>1081</i>&nbsp;                    found : types.cvarUpperBound(found);
<i>1082</i>&nbsp;        }
<i>1083</i>&nbsp;
<i>1084</i>&nbsp;        @Override
<i>1085</i>&nbsp;        protected MethodResultInfo dup(Type newPt) {
<i>1086</i>&nbsp;            return new MethodResultInfo(newPt, checkContext);
<i>1087</i>&nbsp;        }
<i>1088</i>&nbsp;
<b class="nc"><i>1089</i>&nbsp;        @Override</b>
<i>1090</i>&nbsp;        protected ResultInfo dup(CheckContext newContext) {
<i>1091</i>&nbsp;            return new MethodResultInfo(pt, newContext);
<i>1092</i>&nbsp;        }
<b class="nc"><i>1093</i>&nbsp;</b>
<b class="nc"><i>1094</i>&nbsp;        @Override</b>
<b class="nc"><i>1095</i>&nbsp;        protected ResultInfo dup(Type newPt, CheckContext newContext) {</b>
<i>1096</i>&nbsp;            return new MethodResultInfo(newPt, newContext);
<i>1097</i>&nbsp;        }
<i>1098</i>&nbsp;    }
<b class="nc"><i>1099</i>&nbsp;</b>
<b class="nc"><i>1100</i>&nbsp;    /**</b>
<b class="nc"><i>1101</i>&nbsp;     * Most specific method applicability routine. Given a list of actual types A,</b>
<b class="nc"><i>1102</i>&nbsp;     * a list of formal types F1, and a list of formal types F2, the routine determines</b>
<b class="nc"><i>1103</i>&nbsp;     * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.</b>
<b class="nc"><i>1104</i>&nbsp;     * argument types A.</b>
<b class="nc"><i>1105</i>&nbsp;     */</b>
<b class="nc"><i>1106</i>&nbsp;    class MostSpecificCheck implements MethodCheck {</b>
<i>1107</i>&nbsp;
<i>1108</i>&nbsp;        List&lt;Type&gt; actuals;
<b class="nc"><i>1109</i>&nbsp;</b>
<i>1110</i>&nbsp;        MostSpecificCheck(List&lt;Type&gt; actuals) {
<i>1111</i>&nbsp;            this.actuals = actuals;
<i>1112</i>&nbsp;        }
<i>1113</i>&nbsp;
<b class="nc"><i>1114</i>&nbsp;        @Override</b>
<b class="nc"><i>1115</i>&nbsp;        public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>1116</i>&nbsp;                                    DeferredAttrContext deferredAttrContext,</b>
<b class="nc"><i>1117</i>&nbsp;                                    List&lt;Type&gt; formals1,</b>
<i>1118</i>&nbsp;                                    List&lt;Type&gt; formals2,
<i>1119</i>&nbsp;                                    Warner warn) {
<i>1120</i>&nbsp;            formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
<i>1121</i>&nbsp;            while (formals2.nonEmpty()) {
<b class="nc"><i>1122</i>&nbsp;                ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);</b>
<b class="nc"><i>1123</i>&nbsp;                mresult.check(null, formals1.head);</b>
<b class="nc"><i>1124</i>&nbsp;                formals1 = formals1.tail;</b>
<i>1125</i>&nbsp;                formals2 = formals2.tail;
<i>1126</i>&nbsp;                actuals = actuals.isEmpty() ? actuals : actuals.tail;
<i>1127</i>&nbsp;            }
<i>1128</i>&nbsp;        }
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;       /**
<i>1131</i>&nbsp;        * Create a method check context to be used during the most specific applicability check
<i>1132</i>&nbsp;        */
<i>1133</i>&nbsp;        ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
<i>1134</i>&nbsp;               Warner rsWarner, Type actual) {
<i>1135</i>&nbsp;            return attr.new ResultInfo(KindSelector.VAL, to,
<i>1136</i>&nbsp;                   new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
<i>1137</i>&nbsp;        }
<i>1138</i>&nbsp;
<b class="nc"><i>1139</i>&nbsp;        /**</b>
<b class="nc"><i>1140</i>&nbsp;         * Subclass of method check context class that implements most specific</b>
<b class="nc"><i>1141</i>&nbsp;         * method conversion. If the actual type under analysis is a deferred type</b>
<b class="nc"><i>1142</i>&nbsp;         * a full blown structural analysis is carried out.</b>
<b class="nc"><i>1143</i>&nbsp;         */</b>
<i>1144</i>&nbsp;        class MostSpecificCheckContext extends MethodCheckContext {
<i>1145</i>&nbsp;
<i>1146</i>&nbsp;            Type actual;
<i>1147</i>&nbsp;
<b class="nc"><i>1148</i>&nbsp;            public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {</b>
<i>1149</i>&nbsp;                super(true, deferredAttrContext, rsWarner);
<i>1150</i>&nbsp;                this.actual = actual;
<i>1151</i>&nbsp;            }
<i>1152</i>&nbsp;
<b class="nc"><i>1153</i>&nbsp;            public boolean compatible(Type found, Type req, Warner warn) {</b>
<b class="nc"><i>1154</i>&nbsp;                if (allowFunctionalInterfaceMostSpecific &amp;&amp;</b>
<i>1155</i>&nbsp;                        unrelatedFunctionalInterfaces(found, req) &amp;&amp;
<i>1156</i>&nbsp;                        (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
<i>1157</i>&nbsp;                    DeferredType dt = (DeferredType) actual;
<i>1158</i>&nbsp;                    JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
<b class="nc"><i>1159</i>&nbsp;                    if (speculativeTree != deferredAttr.stuckTree) {</b>
<b class="nc"><i>1160</i>&nbsp;                        return functionalInterfaceMostSpecific(found, req, speculativeTree);</b>
<i>1161</i>&nbsp;                    }
<b class="nc"><i>1162</i>&nbsp;                }</b>
<b class="nc"><i>1163</i>&nbsp;                return compatibleBySubtyping(found, req);</b>
<b class="nc"><i>1164</i>&nbsp;            }</b>
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;            private boolean compatibleBySubtyping(Type found, Type req) {
<b class="nc"><i>1167</i>&nbsp;                if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {</b>
<b class="nc"><i>1168</i>&nbsp;                    found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);</b>
<b class="nc"><i>1169</i>&nbsp;                }</b>
<b class="nc"><i>1170</i>&nbsp;                return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));</b>
<b class="nc"><i>1171</i>&nbsp;            }</b>
<b class="nc"><i>1172</i>&nbsp;</b>
<b class="nc"><i>1173</i>&nbsp;            /** Whether {@code t} and {@code s} are unrelated functional interface types. */</b>
<b class="nc"><i>1174</i>&nbsp;            private boolean unrelatedFunctionalInterfaces(Type t, Type s) {</b>
<i>1175</i>&nbsp;                return types.isFunctionalInterface(t.tsym) &amp;&amp;
<b class="nc"><i>1176</i>&nbsp;                       types.isFunctionalInterface(s.tsym) &amp;&amp;</b>
<b class="nc"><i>1177</i>&nbsp;                       unrelatedInterfaces(t, s);</b>
<b class="nc"><i>1178</i>&nbsp;            }</b>
<b class="nc"><i>1179</i>&nbsp;</b>
<b class="nc"><i>1180</i>&nbsp;            /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/</b>
<i>1181</i>&nbsp;            private boolean unrelatedInterfaces(Type t, Type s) {
<i>1182</i>&nbsp;                if (t.isCompound()) {
<i>1183</i>&nbsp;                    for (Type ti : types.interfaces(t)) {
<i>1184</i>&nbsp;                        if (!unrelatedInterfaces(ti, s)) {
<i>1185</i>&nbsp;                            return false;
<i>1186</i>&nbsp;                        }
<b class="nc"><i>1187</i>&nbsp;                    }</b>
<b class="nc"><i>1188</i>&nbsp;                    return true;</b>
<i>1189</i>&nbsp;                } else if (s.isCompound()) {
<b class="nc"><i>1190</i>&nbsp;                    for (Type si : types.interfaces(s)) {</b>
<b class="nc"><i>1191</i>&nbsp;                        if (!unrelatedInterfaces(t, si)) {</b>
<b class="nc"><i>1192</i>&nbsp;                            return false;</b>
<i>1193</i>&nbsp;                        }
<i>1194</i>&nbsp;                    }
<b class="nc"><i>1195</i>&nbsp;                    return true;</b>
<b class="nc"><i>1196</i>&nbsp;                } else {</b>
<b class="nc"><i>1197</i>&nbsp;                    return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;</b>
<b class="nc"><i>1198</i>&nbsp;                }</b>
<b class="nc"><i>1199</i>&nbsp;            }</b>
<b class="nc"><i>1200</i>&nbsp;</b>
<b class="nc"><i>1201</i>&nbsp;            /** Parameters {@code t} and {@code s} are unrelated functional interface types. */</b>
<b class="nc"><i>1202</i>&nbsp;            private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {</b>
<b class="nc"><i>1203</i>&nbsp;                Type tDesc = types.findDescriptorType(types.capture(t));</b>
<b class="nc"><i>1204</i>&nbsp;                Type tDescNoCapture = types.findDescriptorType(t);</b>
<b class="nc"><i>1205</i>&nbsp;                Type sDesc = types.findDescriptorType(s);</b>
<b class="nc"><i>1206</i>&nbsp;                final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();</b>
<b class="nc"><i>1207</i>&nbsp;                final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();</b>
<b class="nc"><i>1208</i>&nbsp;                final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();</b>
<b class="nc"><i>1209</i>&nbsp;</b>
<b class="nc"><i>1210</i>&nbsp;                // compare type parameters</b>
<i>1211</i>&nbsp;                if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
<b class="nc"><i>1212</i>&nbsp;                    return false;</b>
<i>1213</i>&nbsp;                }
<i>1214</i>&nbsp;                // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
<i>1215</i>&nbsp;                List&lt;Type&gt; tIter = tTypeParams;
<i>1216</i>&nbsp;                List&lt;Type&gt; sIter = sTypeParams;
<i>1217</i>&nbsp;                while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
<i>1218</i>&nbsp;                    Type tBound = tIter.head.getUpperBound();
<b class="nc"><i>1219</i>&nbsp;                    Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);</b>
<b class="nc"><i>1220</i>&nbsp;                    if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {</b>
<i>1221</i>&nbsp;                        return false;
<b class="nc"><i>1222</i>&nbsp;                    }</b>
<b class="nc"><i>1223</i>&nbsp;                    if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {</b>
<b class="nc"><i>1224</i>&nbsp;                        return false;</b>
<i>1225</i>&nbsp;                    }
<i>1226</i>&nbsp;                    tIter = tIter.tail;
<b class="nc"><i>1227</i>&nbsp;                    sIter = sIter.tail;</b>
<b class="nc"><i>1228</i>&nbsp;                }</b>
<i>1229</i>&nbsp;                if (!tIter.isEmpty() || !sIter.isEmpty()) {
<i>1230</i>&nbsp;                    return false;
<i>1231</i>&nbsp;                }
<b class="nc"><i>1232</i>&nbsp;</b>
<b class="nc"><i>1233</i>&nbsp;                // compare parameters</b>
<i>1234</i>&nbsp;                List&lt;Type&gt; tParams = tDesc.getParameterTypes();
<i>1235</i>&nbsp;                List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
<i>1236</i>&nbsp;                List&lt;Type&gt; sParams = sDesc.getParameterTypes();
<i>1237</i>&nbsp;                while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
<i>1238</i>&nbsp;                    Type tParam = tParams.head;
<i>1239</i>&nbsp;                    Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
<i>1240</i>&nbsp;                    Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
<b class="nc"><i>1241</i>&nbsp;                    if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {</b>
<b class="nc"><i>1242</i>&nbsp;                        return false;</b>
<i>1243</i>&nbsp;                    }
<i>1244</i>&nbsp;                    if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
<i>1245</i>&nbsp;                        return false;
<i>1246</i>&nbsp;                    }
<i>1247</i>&nbsp;                    if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
<i>1248</i>&nbsp;                        return false;
<i>1249</i>&nbsp;                    }
<i>1250</i>&nbsp;                    tParams = tParams.tail;
<i>1251</i>&nbsp;                    tParamsNoCapture = tParamsNoCapture.tail;
<b class="nc"><i>1252</i>&nbsp;                    sParams = sParams.tail;</b>
<b class="nc"><i>1253</i>&nbsp;                }</b>
<b class="nc"><i>1254</i>&nbsp;                if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {</b>
<i>1255</i>&nbsp;                    return false;
<i>1256</i>&nbsp;                }
<b class="nc"><i>1257</i>&nbsp;</b>
<i>1258</i>&nbsp;                // compare returns
<i>1259</i>&nbsp;                Type tRet = tDesc.getReturnType();
<b class="nc"><i>1260</i>&nbsp;                Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);</b>
<i>1261</i>&nbsp;                if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
<i>1262</i>&nbsp;                    return false;
<b class="nc"><i>1263</i>&nbsp;                }</b>
<i>1264</i>&nbsp;                MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
<i>1265</i>&nbsp;                msc.scan(tree);
<b class="nc"><i>1266</i>&nbsp;                return msc.result;</b>
<b class="nc"><i>1267</i>&nbsp;            }</b>
<i>1268</i>&nbsp;
<i>1269</i>&nbsp;            /**
<i>1270</i>&nbsp;             * Tests whether one functional interface type can be considered more specific
<b class="nc"><i>1271</i>&nbsp;             * than another unrelated functional interface type for the scanned expression.</b>
<i>1272</i>&nbsp;             */
<i>1273</i>&nbsp;            class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
<i>1274</i>&nbsp;
<i>1275</i>&nbsp;                final Type tRet;
<i>1276</i>&nbsp;                final Type sRet;
<i>1277</i>&nbsp;                boolean result;
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;                /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
<i>1280</i>&nbsp;                MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
<i>1281</i>&nbsp;                    this.tRet = tRet;
<i>1282</i>&nbsp;                    this.sRet = sRet;
<i>1283</i>&nbsp;                    result = true;
<i>1284</i>&nbsp;                }
<i>1285</i>&nbsp;
<i>1286</i>&nbsp;                @Override
<i>1287</i>&nbsp;                void skip(JCTree tree) {
<i>1288</i>&nbsp;                    result &amp;= false;
<i>1289</i>&nbsp;                }
<i>1290</i>&nbsp;
<i>1291</i>&nbsp;                @Override
<i>1292</i>&nbsp;                public void visitConditional(JCConditional tree) {
<i>1293</i>&nbsp;                    scan(asExpr(tree.truepart));
<i>1294</i>&nbsp;                    scan(asExpr(tree.falsepart));
<i>1295</i>&nbsp;                }
<i>1296</i>&nbsp;
<i>1297</i>&nbsp;                @Override
<i>1298</i>&nbsp;                public void visitReference(JCMemberReference tree) {
<i>1299</i>&nbsp;                    if (sRet.hasTag(VOID)) {
<b class="nc"><i>1300</i>&nbsp;                        result &amp;= true;</b>
<b class="nc"><i>1301</i>&nbsp;                    } else if (tRet.hasTag(VOID)) {</b>
<b class="nc"><i>1302</i>&nbsp;                        result &amp;= false;</b>
<i>1303</i>&nbsp;                    } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
<b class="nc"><i>1304</i>&nbsp;                        boolean retValIsPrimitive =</b>
<b class="nc"><i>1305</i>&nbsp;                                tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;</b>
<b class="nc"><i>1306</i>&nbsp;                                tree.sym.type.getReturnType().isPrimitive();</b>
<b class="nc"><i>1307</i>&nbsp;                        result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;</b>
<i>1308</i>&nbsp;                                  (retValIsPrimitive != sRet.isPrimitive());
<i>1309</i>&nbsp;                    } else {
<b class="nc"><i>1310</i>&nbsp;                        result &amp;= compatibleBySubtyping(tRet, sRet);</b>
<i>1311</i>&nbsp;                    }
<b class="nc"><i>1312</i>&nbsp;                }</b>
<b class="nc"><i>1313</i>&nbsp;</b>
<b class="nc"><i>1314</i>&nbsp;                @Override</b>
<b class="nc"><i>1315</i>&nbsp;                public void visitParens(JCParens tree) {</b>
<i>1316</i>&nbsp;                    scan(asExpr(tree.expr));
<b class="nc"><i>1317</i>&nbsp;                }</b>
<b class="nc"><i>1318</i>&nbsp;</b>
<b class="nc"><i>1319</i>&nbsp;                @Override</b>
<b class="nc"><i>1320</i>&nbsp;                public void visitLambda(JCLambda tree) {</b>
<b class="nc"><i>1321</i>&nbsp;                    if (sRet.hasTag(VOID)) {</b>
<i>1322</i>&nbsp;                        result &amp;= true;
<b class="nc"><i>1323</i>&nbsp;                    } else if (tRet.hasTag(VOID)) {</b>
<b class="nc"><i>1324</i>&nbsp;                        result &amp;= false;</b>
<b class="nc"><i>1325</i>&nbsp;                    } else {</b>
<i>1326</i>&nbsp;                        List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
<b class="nc"><i>1327</i>&nbsp;                        if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {</b>
<i>1328</i>&nbsp;                            for (JCExpression expr : lambdaResults) {
<i>1329</i>&nbsp;                                result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
<i>1330</i>&nbsp;                            }
<i>1331</i>&nbsp;                        } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
<i>1332</i>&nbsp;                            for (JCExpression expr : lambdaResults) {
<i>1333</i>&nbsp;                                boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
<i>1334</i>&nbsp;                                result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
<i>1335</i>&nbsp;                                        (retValIsPrimitive != sRet.isPrimitive());
<i>1336</i>&nbsp;                            }
<i>1337</i>&nbsp;                        } else {
<i>1338</i>&nbsp;                            result &amp;= compatibleBySubtyping(tRet, sRet);
<b class="nc"><i>1339</i>&nbsp;                        }</b>
<b class="nc"><i>1340</i>&nbsp;                    }</b>
<b class="nc"><i>1341</i>&nbsp;                }</b>
<b class="nc"><i>1342</i>&nbsp;                //where</b>
<i>1343</i>&nbsp;
<i>1344</i>&nbsp;                private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
<i>1345</i>&nbsp;                    if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
<i>1346</i>&nbsp;                        return List.of(asExpr((JCExpression) lambda.body));
<i>1347</i>&nbsp;                    } else {
<i>1348</i>&nbsp;                        final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
<i>1349</i>&nbsp;                        DeferredAttr.LambdaReturnScanner lambdaScanner =
<i>1350</i>&nbsp;                                new DeferredAttr.LambdaReturnScanner() {
<i>1351</i>&nbsp;                                    @Override
<b class="nc"><i>1352</i>&nbsp;                                    public void visitReturn(JCReturn tree) {</b>
<i>1353</i>&nbsp;                                        if (tree.expr != null) {
<b class="nc"><i>1354</i>&nbsp;                                            buffer.append(asExpr(tree.expr));</b>
<b class="nc"><i>1355</i>&nbsp;                                        }</b>
<b class="nc"><i>1356</i>&nbsp;                                    }</b>
<b class="nc"><i>1357</i>&nbsp;                                };</b>
<b class="nc"><i>1358</i>&nbsp;                        lambdaScanner.scan(lambda.body);</b>
<b class="nc"><i>1359</i>&nbsp;                        return buffer.toList();</b>
<i>1360</i>&nbsp;                    }
<i>1361</i>&nbsp;                }
<b class="nc"><i>1362</i>&nbsp;</b>
<b class="nc"><i>1363</i>&nbsp;                private JCExpression asExpr(JCExpression expr) {</b>
<i>1364</i>&nbsp;                    if (expr.type.hasTag(DEFERRED)) {
<b class="nc"><i>1365</i>&nbsp;                        JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);</b>
<i>1366</i>&nbsp;                        if (speculativeTree != deferredAttr.stuckTree) {
<b class="nc"><i>1367</i>&nbsp;                            expr = (JCExpression)speculativeTree;</b>
<b class="nc"><i>1368</i>&nbsp;                        }</b>
<i>1369</i>&nbsp;                    }
<i>1370</i>&nbsp;                    return expr;
<b class="nc"><i>1371</i>&nbsp;                }</b>
<b class="nc"><i>1372</i>&nbsp;            }</b>
<i>1373</i>&nbsp;
<b class="nc"><i>1374</i>&nbsp;        }</b>
<b class="nc"><i>1375</i>&nbsp;</b>
<b class="nc"><i>1376</i>&nbsp;        public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {</b>
<i>1377</i>&nbsp;            Assert.error(&quot;Cannot get here!&quot;);
<i>1378</i>&nbsp;            return null;
<b class="nc"><i>1379</i>&nbsp;        }</b>
<b class="nc"><i>1380</i>&nbsp;    }</b>
<b class="nc"><i>1381</i>&nbsp;</b>
<i>1382</i>&nbsp;    public static class InapplicableMethodException extends RuntimeException {
<b class="nc"><i>1383</i>&nbsp;        private static final long serialVersionUID = 0;</b>
<b class="nc"><i>1384</i>&nbsp;</b>
<b class="nc"><i>1385</i>&nbsp;        JCDiagnostic diagnostic;</b>
<b class="nc"><i>1386</i>&nbsp;</b>
<b class="nc"><i>1387</i>&nbsp;        InapplicableMethodException(JCDiagnostic diag) {</b>
<i>1388</i>&nbsp;            this.diagnostic = diag;
<b class="nc"><i>1389</i>&nbsp;        }</b>
<b class="nc"><i>1390</i>&nbsp;</b>
<b class="nc"><i>1391</i>&nbsp;        public JCDiagnostic getDiagnostic() {</b>
<b class="nc"><i>1392</i>&nbsp;            return diagnostic;</b>
<b class="nc"><i>1393</i>&nbsp;        }</b>
<b class="nc"><i>1394</i>&nbsp;    }</b>
<b class="nc"><i>1395</i>&nbsp;</b>
<i>1396</i>&nbsp;/* ***************************************************************************
<b class="nc"><i>1397</i>&nbsp; *  Symbol lookup</b>
<b class="nc"><i>1398</i>&nbsp; *  the following naming conventions for arguments are used</b>
<b class="nc"><i>1399</i>&nbsp; *</b>
<b class="nc"><i>1400</i>&nbsp; *       env      is the environment where the symbol was mentioned</b>
<b class="nc"><i>1401</i>&nbsp; *       site     is the type of which the symbol is a member</b>
<i>1402</i>&nbsp; *       name     is the symbol&#39;s name
<i>1403</i>&nbsp; *                if no arguments are given
<i>1404</i>&nbsp; *       argtypes are the value arguments, if we search for a method
<b class="nc"><i>1405</i>&nbsp; *</b>
<i>1406</i>&nbsp; *  If no symbol was found, a ResolveError detailing the problem is returned.
<b class="nc"><i>1407</i>&nbsp; ****************************************************************************/</b>
<b class="nc"><i>1408</i>&nbsp;</b>
<i>1409</i>&nbsp;    /** Find field. Synthetic fields are always skipped.
<b class="nc"><i>1410</i>&nbsp;     *  @param env     The current environment.</b>
<i>1411</i>&nbsp;     *  @param site    The original type from where the selection takes place.
<i>1412</i>&nbsp;     *  @param name    The name of the field.
<b class="nc"><i>1413</i>&nbsp;     *  @param c       The class to search for the field. This is always</b>
<i>1414</i>&nbsp;     *                 a superclass or implemented interface of site&#39;s class.
<i>1415</i>&nbsp;     */
<i>1416</i>&nbsp;    Symbol findField(Env&lt;AttrContext&gt; env,
<i>1417</i>&nbsp;                     Type site,
<i>1418</i>&nbsp;                     Name name,
<i>1419</i>&nbsp;                     TypeSymbol c) {
<i>1420</i>&nbsp;        while (c.type.hasTag(TYPEVAR))
<i>1421</i>&nbsp;            c = c.type.getUpperBound().tsym;
<i>1422</i>&nbsp;        Symbol bestSoFar = varNotFound;
<i>1423</i>&nbsp;        Symbol sym;
<i>1424</i>&nbsp;        for (Symbol s : c.members().getSymbolsByName(name)) {
<i>1425</i>&nbsp;            if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
<i>1426</i>&nbsp;                return isAccessible(env, site, s)
<i>1427</i>&nbsp;                    ? s : new AccessError(env, site, s);
<i>1428</i>&nbsp;            }
<i>1429</i>&nbsp;        }
<i>1430</i>&nbsp;        Type st = types.supertype(c.type);
<i>1431</i>&nbsp;        if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
<i>1432</i>&nbsp;            sym = findField(env, site, name, st.tsym);
<i>1433</i>&nbsp;            bestSoFar = bestOf(bestSoFar, sym);
<i>1434</i>&nbsp;        }
<i>1435</i>&nbsp;        for (List&lt;Type&gt; l = types.interfaces(c.type);
<b class="nc"><i>1436</i>&nbsp;             bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();</b>
<b class="nc"><i>1437</i>&nbsp;             l = l.tail) {</b>
<b class="nc"><i>1438</i>&nbsp;            sym = findField(env, site, name, l.head.tsym);</b>
<b class="nc"><i>1439</i>&nbsp;            if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;</b>
<b class="nc"><i>1440</i>&nbsp;                sym.owner != bestSoFar.owner)</b>
<b class="nc"><i>1441</i>&nbsp;                bestSoFar = new AmbiguityError(bestSoFar, sym);</b>
<i>1442</i>&nbsp;            else
<i>1443</i>&nbsp;                bestSoFar = bestOf(bestSoFar, sym);
<b class="nc"><i>1444</i>&nbsp;        }</b>
<i>1445</i>&nbsp;        return bestSoFar;
<b class="nc"><i>1446</i>&nbsp;    }</b>
<i>1447</i>&nbsp;
<b class="nc"><i>1448</i>&nbsp;    /** Resolve a field identifier, throw a fatal error if not found.</b>
<b class="nc"><i>1449</i>&nbsp;     *  @param pos       The position to use for error reporting.</b>
<b class="nc"><i>1450</i>&nbsp;     *  @param env       The environment current at the method invocation.</b>
<b class="nc"><i>1451</i>&nbsp;     *  @param site      The type of the qualifying expression, in which</b>
<b class="nc"><i>1452</i>&nbsp;     *                   identifier is searched.</b>
<b class="nc"><i>1453</i>&nbsp;     *  @param name      The identifier&#39;s name.</b>
<i>1454</i>&nbsp;     */
<b class="nc"><i>1455</i>&nbsp;    public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,</b>
<i>1456</i>&nbsp;                                          Type site, Name name) {
<b class="nc"><i>1457</i>&nbsp;        Symbol sym = findField(env, site, name, site.tsym);</b>
<b class="nc"><i>1458</i>&nbsp;        if (sym.kind == VAR) return (VarSymbol)sym;</b>
<i>1459</i>&nbsp;        else throw new FatalError(
<b class="nc"><i>1460</i>&nbsp;                 diags.fragment(Fragments.FatalErrCantLocateField(name)));</b>
<i>1461</i>&nbsp;    }
<b class="nc"><i>1462</i>&nbsp;</b>
<b class="nc"><i>1463</i>&nbsp;    /** Find unqualified variable or field with given name.</b>
<b class="nc"><i>1464</i>&nbsp;     *  Synthetic fields always skipped.</b>
<i>1465</i>&nbsp;     *  @param env     The current environment.
<i>1466</i>&nbsp;     *  @param name    The name of the variable or field.
<i>1467</i>&nbsp;     */
<b class="nc"><i>1468</i>&nbsp;    Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {</b>
<i>1469</i>&nbsp;        Symbol bestSoFar = varNotFound;
<b class="nc"><i>1470</i>&nbsp;        Env&lt;AttrContext&gt; env1 = env;</b>
<i>1471</i>&nbsp;        boolean staticOnly = false;
<i>1472</i>&nbsp;        while (env1.outer != null) {
<i>1473</i>&nbsp;            Symbol sym = null;
<i>1474</i>&nbsp;            if (isStatic(env1)) staticOnly = true;
<i>1475</i>&nbsp;            for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
<i>1476</i>&nbsp;                if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
<i>1477</i>&nbsp;                    sym = s;
<i>1478</i>&nbsp;                    break;
<i>1479</i>&nbsp;                }
<i>1480</i>&nbsp;            }
<i>1481</i>&nbsp;            if (sym == null) {
<i>1482</i>&nbsp;                sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
<i>1483</i>&nbsp;            }
<i>1484</i>&nbsp;            if (sym.exists()) {
<i>1485</i>&nbsp;                if (staticOnly &amp;&amp;
<i>1486</i>&nbsp;                    sym.kind == VAR &amp;&amp;
<i>1487</i>&nbsp;                    sym.owner.kind == TYP &amp;&amp;
<i>1488</i>&nbsp;                    (sym.flags() &amp; STATIC) == 0)
<i>1489</i>&nbsp;                    return new StaticError(sym);
<b class="nc"><i>1490</i>&nbsp;                else</b>
<i>1491</i>&nbsp;                    return sym;
<b class="nc"><i>1492</i>&nbsp;            } else {</b>
<b class="nc"><i>1493</i>&nbsp;                bestSoFar = bestOf(bestSoFar, sym);</b>
<b class="nc"><i>1494</i>&nbsp;            }</b>
<b class="nc"><i>1495</i>&nbsp;</b>
<b class="nc"><i>1496</i>&nbsp;            if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;</b>
<b class="nc"><i>1497</i>&nbsp;            env1 = env1.outer;</b>
<b class="nc"><i>1498</i>&nbsp;        }</b>
<b class="nc"><i>1499</i>&nbsp;</b>
<b class="nc"><i>1500</i>&nbsp;        Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);</b>
<b class="nc"><i>1501</i>&nbsp;        if (sym.exists())</b>
<i>1502</i>&nbsp;            return sym;
<i>1503</i>&nbsp;        if (bestSoFar.exists())
<i>1504</i>&nbsp;            return bestSoFar;
<i>1505</i>&nbsp;
<b class="nc"><i>1506</i>&nbsp;        Symbol origin = null;</b>
<b class="nc"><i>1507</i>&nbsp;        for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {</b>
<i>1508</i>&nbsp;            for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
<i>1509</i>&nbsp;                if (currentSymbol.kind != VAR)
<b class="nc"><i>1510</i>&nbsp;                    continue;</b>
<b class="nc"><i>1511</i>&nbsp;                // invariant: sym.kind == Symbol.Kind.VAR</b>
<b class="nc"><i>1512</i>&nbsp;                if (!bestSoFar.kind.isResolutionError() &amp;&amp;</b>
<i>1513</i>&nbsp;                    currentSymbol.owner != bestSoFar.owner)
<i>1514</i>&nbsp;                    return new AmbiguityError(bestSoFar, currentSymbol);
<b class="nc"><i>1515</i>&nbsp;                else if (!bestSoFar.kind.betterThan(VAR)) {</b>
<b class="nc"><i>1516</i>&nbsp;                    origin = sc.getOrigin(currentSymbol).owner;</b>
<b class="nc"><i>1517</i>&nbsp;                    bestSoFar = isAccessible(env, origin.type, currentSymbol)</b>
<i>1518</i>&nbsp;                        ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
<i>1519</i>&nbsp;                }
<b class="nc"><i>1520</i>&nbsp;            }</b>
<b class="nc"><i>1521</i>&nbsp;            if (bestSoFar.exists()) break;</b>
<b class="nc"><i>1522</i>&nbsp;        }</b>
<b class="nc"><i>1523</i>&nbsp;        if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)</b>
<b class="nc"><i>1524</i>&nbsp;            return bestSoFar.clone(origin);</b>
<b class="nc"><i>1525</i>&nbsp;        else</b>
<i>1526</i>&nbsp;            return bestSoFar;
<b class="nc"><i>1527</i>&nbsp;    }</b>
<i>1528</i>&nbsp;
<b class="nc"><i>1529</i>&nbsp;    Warner noteWarner = new Warner();</b>
<b class="nc"><i>1530</i>&nbsp;</b>
<b class="nc"><i>1531</i>&nbsp;    /** Select the best method for a call site among two choices.</b>
<i>1532</i>&nbsp;     *  @param env              The current environment.
<i>1533</i>&nbsp;     *  @param site             The original type from where the
<b class="nc"><i>1534</i>&nbsp;     *                          selection takes place.</b>
<b class="nc"><i>1535</i>&nbsp;     *  @param argtypes         The invocation&#39;s value arguments,</b>
<b class="nc"><i>1536</i>&nbsp;     *  @param typeargtypes     The invocation&#39;s type arguments,</b>
<b class="nc"><i>1537</i>&nbsp;     *  @param sym              Proposed new best match.</b>
<b class="nc"><i>1538</i>&nbsp;     *  @param bestSoFar        Previously found best match.</b>
<b class="nc"><i>1539</i>&nbsp;     *  @param allowBoxing Allow boxing conversions of arguments.</b>
<b class="nc"><i>1540</i>&nbsp;     *  @param useVarargs Box trailing arguments into an array for varargs.</b>
<b class="nc"><i>1541</i>&nbsp;     */</b>
<b class="nc"><i>1542</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)</b>
<b class="nc"><i>1543</i>&nbsp;    Symbol selectBest(Env&lt;AttrContext&gt; env,</b>
<i>1544</i>&nbsp;                      Type site,
<i>1545</i>&nbsp;                      List&lt;Type&gt; argtypes,
<b class="nc"><i>1546</i>&nbsp;                      List&lt;Type&gt; typeargtypes,</b>
<b class="nc"><i>1547</i>&nbsp;                      Symbol sym,</b>
<b class="nc"><i>1548</i>&nbsp;                      Symbol bestSoFar,</b>
<i>1549</i>&nbsp;                      boolean allowBoxing,
<b class="nc"><i>1550</i>&nbsp;                      boolean useVarargs) {</b>
<i>1551</i>&nbsp;        if (sym.kind == ERR ||
<i>1552</i>&nbsp;                (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
<i>1553</i>&nbsp;                !notOverriddenIn(site, sym)) {
<i>1554</i>&nbsp;            return bestSoFar;
<b class="nc"><i>1555</i>&nbsp;        } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {</b>
<b class="nc"><i>1556</i>&nbsp;            return bestSoFar.kind.isResolutionError() ?</b>
<b class="nc"><i>1557</i>&nbsp;                    new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :</b>
<b class="nc"><i>1558</i>&nbsp;                    bestSoFar;</b>
<b class="nc"><i>1559</i>&nbsp;        }</b>
<i>1560</i>&nbsp;        Assert.check(!sym.kind.isResolutionError());
<b class="nc"><i>1561</i>&nbsp;        try {</b>
<b class="nc"><i>1562</i>&nbsp;            types.noWarnings.clear();</b>
<b class="nc"><i>1563</i>&nbsp;            Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,</b>
<b class="nc"><i>1564</i>&nbsp;                               allowBoxing, useVarargs, types.noWarnings);</b>
<b class="nc"><i>1565</i>&nbsp;            currentResolutionContext.addApplicableCandidate(sym, mt);</b>
<b class="nc"><i>1566</i>&nbsp;        } catch (InapplicableMethodException ex) {</b>
<i>1567</i>&nbsp;            currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
<b class="nc"><i>1568</i>&nbsp;            switch (bestSoFar.kind) {</b>
<b class="nc"><i>1569</i>&nbsp;                case ABSENT_MTH:</b>
<i>1570</i>&nbsp;                    return new InapplicableSymbolError(currentResolutionContext);
<b class="nc"><i>1571</i>&nbsp;                case WRONG_MTH:</b>
<i>1572</i>&nbsp;                    bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
<i>1573</i>&nbsp;                default:
<i>1574</i>&nbsp;                    return bestSoFar;
<i>1575</i>&nbsp;            }
<b class="nc"><i>1576</i>&nbsp;        }</b>
<b class="nc"><i>1577</i>&nbsp;        if (!isAccessible(env, site, sym)) {</b>
<b class="nc"><i>1578</i>&nbsp;            return (bestSoFar.kind == ABSENT_MTH)</b>
<b class="nc"><i>1579</i>&nbsp;                ? new AccessError(env, site, sym)</b>
<i>1580</i>&nbsp;                : bestSoFar;
<b class="nc"><i>1581</i>&nbsp;        }</b>
<b class="nc"><i>1582</i>&nbsp;        return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)</b>
<b class="nc"><i>1583</i>&nbsp;            ? sym</b>
<i>1584</i>&nbsp;            : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
<b class="nc"><i>1585</i>&nbsp;    }</b>
<i>1586</i>&nbsp;
<b class="nc"><i>1587</i>&nbsp;    /* Return the most specific of the two methods for a call,</b>
<i>1588</i>&nbsp;     *  given that both are accessible and applicable.
<i>1589</i>&nbsp;     *  @param m1               A new candidate for most specific.
<i>1590</i>&nbsp;     *  @param m2               The previous most specific candidate.
<i>1591</i>&nbsp;     *  @param env              The current environment.
<b class="nc"><i>1592</i>&nbsp;     *  @param site             The original type from where the selection</b>
<b class="nc"><i>1593</i>&nbsp;     *                          takes place.</b>
<i>1594</i>&nbsp;     *  @param allowBoxing Allow boxing conversions of arguments.
<b class="nc"><i>1595</i>&nbsp;     *  @param useVarargs Box trailing arguments into an array for varargs.</b>
<i>1596</i>&nbsp;     */
<b class="nc"><i>1597</i>&nbsp;    Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,</b>
<i>1598</i>&nbsp;                        Symbol m2,
<i>1599</i>&nbsp;                        Env&lt;AttrContext&gt; env,
<b class="nc"><i>1600</i>&nbsp;                        final Type site,</b>
<b class="nc"><i>1601</i>&nbsp;                        boolean useVarargs) {</b>
<b class="nc"><i>1602</i>&nbsp;        switch (m2.kind) {</b>
<b class="nc"><i>1603</i>&nbsp;        case MTH:</b>
<b class="nc"><i>1604</i>&nbsp;            if (m1 == m2) return m1;</b>
<b class="nc"><i>1605</i>&nbsp;            boolean m1SignatureMoreSpecific =</b>
<b class="nc"><i>1606</i>&nbsp;                    signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);</b>
<b class="nc"><i>1607</i>&nbsp;            boolean m2SignatureMoreSpecific =</b>
<i>1608</i>&nbsp;                    signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
<b class="nc"><i>1609</i>&nbsp;            if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {</b>
<i>1610</i>&nbsp;                Type mt1 = types.memberType(site, m1);
<i>1611</i>&nbsp;                Type mt2 = types.memberType(site, m2);
<i>1612</i>&nbsp;                if (!types.overrideEquivalent(mt1, mt2))
<i>1613</i>&nbsp;                    return ambiguityError(m1, m2);
<b class="nc"><i>1614</i>&nbsp;</b>
<b class="nc"><i>1615</i>&nbsp;                // same signature; select (a) the non-bridge method, or</b>
<i>1616</i>&nbsp;                // (b) the one that overrides the other, or (c) the concrete
<b class="nc"><i>1617</i>&nbsp;                // one, or (d) merge both abstract signatures</b>
<i>1618</i>&nbsp;                if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
<i>1619</i>&nbsp;                    return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
<i>1620</i>&nbsp;
<i>1621</i>&nbsp;                if (m1.baseSymbol() == m2.baseSymbol()) {
<i>1622</i>&nbsp;                    // this is the same imported symbol which has been cloned twice.
<i>1623</i>&nbsp;                    // Return the first one (either will do).
<i>1624</i>&nbsp;                    return m1;
<i>1625</i>&nbsp;                }
<i>1626</i>&nbsp;
<i>1627</i>&nbsp;                // if one overrides or hides the other, use it
<i>1628</i>&nbsp;                TypeSymbol m1Owner = (TypeSymbol)m1.owner;
<i>1629</i>&nbsp;                TypeSymbol m2Owner = (TypeSymbol)m2.owner;
<i>1630</i>&nbsp;                // the two owners can never be the same if the target methods are compiled from source,
<i>1631</i>&nbsp;                // but we need to protect against cases where the methods are defined in some classfile
<b class="nc"><i>1632</i>&nbsp;                // and make sure we issue an ambiguity error accordingly (by skipping the logic below).</b>
<b class="nc"><i>1633</i>&nbsp;                if (m1Owner != m2Owner) {</b>
<i>1634</i>&nbsp;                    if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
<b class="nc"><i>1635</i>&nbsp;                        ((m1.owner.flags_field &amp; INTERFACE) == 0 ||</b>
<b class="nc"><i>1636</i>&nbsp;                         (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;</b>
<i>1637</i>&nbsp;                        m1.overrides(m2, m1Owner, types, false))
<i>1638</i>&nbsp;                        return m1;
<i>1639</i>&nbsp;                    if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
<i>1640</i>&nbsp;                        ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
<i>1641</i>&nbsp;                         (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
<i>1642</i>&nbsp;                        m2.overrides(m1, m2Owner, types, false))
<b class="nc"><i>1643</i>&nbsp;                        return m2;</b>
<b class="nc"><i>1644</i>&nbsp;                }</b>
<i>1645</i>&nbsp;                boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
<i>1646</i>&nbsp;                boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
<i>1647</i>&nbsp;                if (m1Abstract &amp;&amp; !m2Abstract) return m2;
<b class="nc"><i>1648</i>&nbsp;                if (m2Abstract &amp;&amp; !m1Abstract) return m1;</b>
<b class="nc"><i>1649</i>&nbsp;                // both abstract or both concrete</b>
<i>1650</i>&nbsp;                return ambiguityError(m1, m2);
<i>1651</i>&nbsp;            }
<i>1652</i>&nbsp;            if (m1SignatureMoreSpecific) return m1;
<i>1653</i>&nbsp;            if (m2SignatureMoreSpecific) return m2;
<i>1654</i>&nbsp;            return ambiguityError(m1, m2);
<i>1655</i>&nbsp;        case AMBIGUOUS:
<i>1656</i>&nbsp;            //compare m1 to ambiguous methods in m2
<i>1657</i>&nbsp;            AmbiguityError e = (AmbiguityError)m2.baseSymbol();
<i>1658</i>&nbsp;            boolean m1MoreSpecificThanAnyAmbiguous = true;
<i>1659</i>&nbsp;            boolean allAmbiguousMoreSpecificThanM1 = true;
<i>1660</i>&nbsp;            for (Symbol s : e.ambiguousSyms) {
<i>1661</i>&nbsp;                Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
<i>1662</i>&nbsp;                m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
<i>1663</i>&nbsp;                allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
<i>1664</i>&nbsp;            }
<i>1665</i>&nbsp;            if (m1MoreSpecificThanAnyAmbiguous)
<i>1666</i>&nbsp;                return m1;
<i>1667</i>&nbsp;            //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
<i>1668</i>&nbsp;            //more specific than m1, add it as a new ambiguous method:
<i>1669</i>&nbsp;            if (!allAmbiguousMoreSpecificThanM1)
<i>1670</i>&nbsp;                e.addAmbiguousSymbol(m1);
<i>1671</i>&nbsp;            return e;
<i>1672</i>&nbsp;        default:
<i>1673</i>&nbsp;            throw new AssertionError();
<i>1674</i>&nbsp;        }
<i>1675</i>&nbsp;    }
<b class="nc"><i>1676</i>&nbsp;    //where</b>
<b class="nc"><i>1677</i>&nbsp;    private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {</b>
<i>1678</i>&nbsp;        noteWarner.clear();
<i>1679</i>&nbsp;        int maxLength = Math.max(
<i>1680</i>&nbsp;                            Math.max(m1.type.getParameterTypes().length(), actuals.length()),
<i>1681</i>&nbsp;                            m2.type.getParameterTypes().length());
<i>1682</i>&nbsp;        MethodResolutionContext prevResolutionContext = currentResolutionContext;
<i>1683</i>&nbsp;        try {
<i>1684</i>&nbsp;            currentResolutionContext = new MethodResolutionContext();
<i>1685</i>&nbsp;            currentResolutionContext.step = prevResolutionContext.step;
<i>1686</i>&nbsp;            currentResolutionContext.methodCheck =
<b class="nc"><i>1687</i>&nbsp;                    prevResolutionContext.methodCheck.mostSpecificCheck(actuals);</b>
<i>1688</i>&nbsp;            Type mst = instantiate(env, site, m2, null,
<i>1689</i>&nbsp;                    adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
<i>1690</i>&nbsp;                    false, useVarargs, noteWarner);
<i>1691</i>&nbsp;            return mst != null &amp;&amp;
<i>1692</i>&nbsp;                    !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
<i>1693</i>&nbsp;        } finally {
<i>1694</i>&nbsp;            currentResolutionContext = prevResolutionContext;
<i>1695</i>&nbsp;        }
<i>1696</i>&nbsp;    }
<i>1697</i>&nbsp;
<i>1698</i>&nbsp;    List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
<i>1699</i>&nbsp;        if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
<i>1700</i>&nbsp;            Type varargsElem = types.elemtype(args.last());
<b class="nc"><i>1701</i>&nbsp;            if (varargsElem == null) {</b>
<b class="nc"><i>1702</i>&nbsp;                Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);</b>
<b class="nc"><i>1703</i>&nbsp;            }</b>
<b class="nc"><i>1704</i>&nbsp;            List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();</b>
<b class="nc"><i>1705</i>&nbsp;            while (newArgs.length() &lt; length) {</b>
<b class="nc"><i>1706</i>&nbsp;                newArgs = newArgs.append(newArgs.last());</b>
<b class="nc"><i>1707</i>&nbsp;            }</b>
<b class="nc"><i>1708</i>&nbsp;            return newArgs;</b>
<b class="nc"><i>1709</i>&nbsp;        } else {</b>
<b class="nc"><i>1710</i>&nbsp;            return args;</b>
<b class="nc"><i>1711</i>&nbsp;        }</b>
<i>1712</i>&nbsp;    }
<b class="nc"><i>1713</i>&nbsp;    //where</b>
<i>1714</i>&nbsp;    Symbol ambiguityError(Symbol m1, Symbol m2) {
<b class="nc"><i>1715</i>&nbsp;        if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {</b>
<b class="nc"><i>1716</i>&nbsp;            return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;</b>
<i>1717</i>&nbsp;        } else {
<i>1718</i>&nbsp;            return new AmbiguityError(m1, m2);
<b class="nc"><i>1719</i>&nbsp;        }</b>
<i>1720</i>&nbsp;    }
<b class="nc"><i>1721</i>&nbsp;</b>
<b class="nc"><i>1722</i>&nbsp;    Symbol findMethodInScope(Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>1723</i>&nbsp;            Type site,</b>
<b class="nc"><i>1724</i>&nbsp;            Name name,</b>
<b class="nc"><i>1725</i>&nbsp;            List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>1726</i>&nbsp;            List&lt;Type&gt; typeargtypes,</b>
<b class="nc"><i>1727</i>&nbsp;            Scope sc,</b>
<i>1728</i>&nbsp;            Symbol bestSoFar,
<b class="nc"><i>1729</i>&nbsp;            boolean allowBoxing,</b>
<i>1730</i>&nbsp;            boolean useVarargs,
<i>1731</i>&nbsp;            boolean abstractok) {
<i>1732</i>&nbsp;        for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
<i>1733</i>&nbsp;            bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
<i>1734</i>&nbsp;                    bestSoFar, allowBoxing, useVarargs);
<i>1735</i>&nbsp;        }
<b class="nc"><i>1736</i>&nbsp;        return bestSoFar;</b>
<i>1737</i>&nbsp;    }
<b class="nc"><i>1738</i>&nbsp;    //where</b>
<i>1739</i>&nbsp;        class LookupFilter implements Filter&lt;Symbol&gt; {
<b class="nc"><i>1740</i>&nbsp;</b>
<i>1741</i>&nbsp;            boolean abstractOk;
<i>1742</i>&nbsp;
<b class="nc"><i>1743</i>&nbsp;            LookupFilter(boolean abstractOk) {</b>
<b class="nc"><i>1744</i>&nbsp;                this.abstractOk = abstractOk;</b>
<i>1745</i>&nbsp;            }
<i>1746</i>&nbsp;
<i>1747</i>&nbsp;            public boolean accepts(Symbol s) {
<i>1748</i>&nbsp;                long flags = s.flags();
<i>1749</i>&nbsp;                return s.kind == MTH &amp;&amp;
<b class="nc"><i>1750</i>&nbsp;                        (flags &amp; SYNTHETIC) == 0 &amp;&amp;</b>
<b class="nc"><i>1751</i>&nbsp;                        (abstractOk ||</b>
<i>1752</i>&nbsp;                        (flags &amp; DEFAULT) != 0 ||
<b class="nc"><i>1753</i>&nbsp;                        (flags &amp; ABSTRACT) == 0);</b>
<i>1754</i>&nbsp;            }
<i>1755</i>&nbsp;        }
<i>1756</i>&nbsp;
<b class="nc"><i>1757</i>&nbsp;    /** Find best qualified method matching given name, type and value</b>
<i>1758</i>&nbsp;     *  arguments.
<i>1759</i>&nbsp;     *  @param env       The current environment.
<b class="nc"><i>1760</i>&nbsp;     *  @param site      The original type from where the selection</b>
<i>1761</i>&nbsp;     *                   takes place.
<i>1762</i>&nbsp;     *  @param name      The method&#39;s name.
<i>1763</i>&nbsp;     *  @param argtypes  The method&#39;s value arguments.
<i>1764</i>&nbsp;     *  @param typeargtypes The method&#39;s type arguments
<i>1765</i>&nbsp;     *  @param allowBoxing Allow boxing conversions of arguments.
<i>1766</i>&nbsp;     *  @param useVarargs Box trailing arguments into an array for varargs.
<i>1767</i>&nbsp;     */
<i>1768</i>&nbsp;    Symbol findMethod(Env&lt;AttrContext&gt; env,
<i>1769</i>&nbsp;                      Type site,
<i>1770</i>&nbsp;                      Name name,
<i>1771</i>&nbsp;                      List&lt;Type&gt; argtypes,
<i>1772</i>&nbsp;                      List&lt;Type&gt; typeargtypes,
<i>1773</i>&nbsp;                      boolean allowBoxing,
<b class="nc"><i>1774</i>&nbsp;                      boolean useVarargs) {</b>
<i>1775</i>&nbsp;        Symbol bestSoFar = methodNotFound;
<b class="nc"><i>1776</i>&nbsp;        bestSoFar = findMethod(env,</b>
<i>1777</i>&nbsp;                          site,
<b class="nc"><i>1778</i>&nbsp;                          name,</b>
<b class="nc"><i>1779</i>&nbsp;                          argtypes,</b>
<b class="nc"><i>1780</i>&nbsp;                          typeargtypes,</b>
<i>1781</i>&nbsp;                          site.tsym.type,
<i>1782</i>&nbsp;                          bestSoFar,
<b class="nc"><i>1783</i>&nbsp;                          allowBoxing,</b>
<b class="nc"><i>1784</i>&nbsp;                          useVarargs);</b>
<i>1785</i>&nbsp;        return bestSoFar;
<b class="nc"><i>1786</i>&nbsp;    }</b>
<i>1787</i>&nbsp;    // where
<i>1788</i>&nbsp;    private Symbol findMethod(Env&lt;AttrContext&gt; env,
<i>1789</i>&nbsp;                              Type site,
<b class="nc"><i>1790</i>&nbsp;                              Name name,</b>
<b class="nc"><i>1791</i>&nbsp;                              List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>1792</i>&nbsp;                              List&lt;Type&gt; typeargtypes,</b>
<b class="nc"><i>1793</i>&nbsp;                              Type intype,</b>
<i>1794</i>&nbsp;                              Symbol bestSoFar,
<i>1795</i>&nbsp;                              boolean allowBoxing,
<i>1796</i>&nbsp;                              boolean useVarargs) {
<b class="nc"><i>1797</i>&nbsp;        @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})</b>
<i>1798</i>&nbsp;        List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
<i>1799</i>&nbsp;
<i>1800</i>&nbsp;        InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
<b class="nc"><i>1801</i>&nbsp;        for (TypeSymbol s : superclasses(intype)) {</b>
<b class="nc"><i>1802</i>&nbsp;            bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,</b>
<b class="nc"><i>1803</i>&nbsp;                    s.members(), bestSoFar, allowBoxing, useVarargs, true);</b>
<i>1804</i>&nbsp;            if (name == names.init) return bestSoFar;
<b class="nc"><i>1805</i>&nbsp;            iphase = (iphase == null) ? null : iphase.update(s, this);</b>
<b class="nc"><i>1806</i>&nbsp;            if (iphase != null) {</b>
<b class="nc"><i>1807</i>&nbsp;                for (Type itype : types.interfaces(s.type)) {</b>
<i>1808</i>&nbsp;                    itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
<i>1809</i>&nbsp;                }
<b class="nc"><i>1810</i>&nbsp;            }</b>
<i>1811</i>&nbsp;        }
<b class="nc"><i>1812</i>&nbsp;</b>
<b class="nc"><i>1813</i>&nbsp;        Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;</b>
<i>1814</i>&nbsp;                (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
<i>1815</i>&nbsp;                bestSoFar : methodNotFound;
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;        for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
<i>1818</i>&nbsp;            //keep searching for abstract methods
<i>1819</i>&nbsp;            for (Type itype : itypes[iphase2.ordinal()]) {
<i>1820</i>&nbsp;                if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
<i>1821</i>&nbsp;                if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
<i>1822</i>&nbsp;                        (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
<i>1823</i>&nbsp;                bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
<i>1824</i>&nbsp;                        itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
<i>1825</i>&nbsp;                if (concrete != bestSoFar &amp;&amp;
<i>1826</i>&nbsp;                    concrete.kind.isValid() &amp;&amp;
<i>1827</i>&nbsp;                    bestSoFar.kind.isValid() &amp;&amp;
<i>1828</i>&nbsp;                        types.isSubSignature(concrete.type, bestSoFar.type)) {
<i>1829</i>&nbsp;                    //this is an hack - as javac does not do full membership checks
<i>1830</i>&nbsp;                    //most specific ends up comparing abstract methods that might have
<b class="nc"><i>1831</i>&nbsp;                    //been implemented by some concrete method in a subclass and,</b>
<i>1832</i>&nbsp;                    //because of raw override, it is possible for an abstract method
<b class="nc"><i>1833</i>&nbsp;                    //to be more specific than the concrete method - so we need</b>
<b class="nc"><i>1834</i>&nbsp;                    //to explicitly call that out (see CR 6178365)</b>
<b class="nc"><i>1835</i>&nbsp;                    bestSoFar = concrete;</b>
<b class="nc"><i>1836</i>&nbsp;                }</b>
<b class="nc"><i>1837</i>&nbsp;            }</b>
<b class="nc"><i>1838</i>&nbsp;        }</b>
<i>1839</i>&nbsp;        return bestSoFar;
<b class="nc"><i>1840</i>&nbsp;    }</b>
<i>1841</i>&nbsp;
<i>1842</i>&nbsp;    enum InterfaceLookupPhase {
<b class="nc"><i>1843</i>&nbsp;        ABSTRACT_OK() {</b>
<b class="nc"><i>1844</i>&nbsp;            @Override</b>
<i>1845</i>&nbsp;            InterfaceLookupPhase update(Symbol s, Resolve rs) {
<i>1846</i>&nbsp;                //We should not look for abstract methods if receiver is a concrete class
<b class="nc"><i>1847</i>&nbsp;                //(as concrete classes are expected to implement all abstracts coming</b>
<b class="nc"><i>1848</i>&nbsp;                //from superinterfaces)</b>
<b class="nc"><i>1849</i>&nbsp;                if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {</b>
<b class="nc"><i>1850</i>&nbsp;                    return this;</b>
<i>1851</i>&nbsp;                } else {
<i>1852</i>&nbsp;                    return DEFAULT_OK;
<b class="nc"><i>1853</i>&nbsp;                }</b>
<b class="nc"><i>1854</i>&nbsp;            }</b>
<b class="nc"><i>1855</i>&nbsp;        },</b>
<b class="nc"><i>1856</i>&nbsp;        DEFAULT_OK() {</b>
<i>1857</i>&nbsp;            @Override
<i>1858</i>&nbsp;            InterfaceLookupPhase update(Symbol s, Resolve rs) {
<b class="nc"><i>1859</i>&nbsp;                return this;</b>
<i>1860</i>&nbsp;            }
<b class="nc"><i>1861</i>&nbsp;        };</b>
<b class="nc"><i>1862</i>&nbsp;</b>
<i>1863</i>&nbsp;        abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
<b class="nc"><i>1864</i>&nbsp;    }</b>
<b class="nc"><i>1865</i>&nbsp;</b>
<b class="nc"><i>1866</i>&nbsp;    /**</b>
<b class="nc"><i>1867</i>&nbsp;     * Return an Iterable object to scan the superclasses of a given type.</b>
<b class="nc"><i>1868</i>&nbsp;     * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally</b>
<b class="nc"><i>1869</i>&nbsp;     * access more supertypes than strictly needed (as this could trigger completion</b>
<b class="nc"><i>1870</i>&nbsp;     * errors if some of the not-needed supertypes are missing/ill-formed).</b>
<b class="nc"><i>1871</i>&nbsp;     */</b>
<b class="nc"><i>1872</i>&nbsp;    Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {</b>
<b class="nc"><i>1873</i>&nbsp;        return () -&gt; new Iterator&lt;TypeSymbol&gt;() {</b>
<i>1874</i>&nbsp;
<i>1875</i>&nbsp;            List&lt;TypeSymbol&gt; seen = List.nil();
<i>1876</i>&nbsp;            TypeSymbol currentSym = symbolFor(intype);
<i>1877</i>&nbsp;            TypeSymbol prevSym = null;
<i>1878</i>&nbsp;
<b class="nc"><i>1879</i>&nbsp;            public boolean hasNext() {</b>
<b class="nc"><i>1880</i>&nbsp;                if (currentSym == syms.noSymbol) {</b>
<i>1881</i>&nbsp;                    currentSym = symbolFor(types.supertype(prevSym.type));
<b class="nc"><i>1882</i>&nbsp;                }</b>
<b class="nc"><i>1883</i>&nbsp;                return currentSym != null;</b>
<b class="nc"><i>1884</i>&nbsp;            }</b>
<b class="nc"><i>1885</i>&nbsp;</b>
<b class="nc"><i>1886</i>&nbsp;            public TypeSymbol next() {</b>
<b class="nc"><i>1887</i>&nbsp;                prevSym = currentSym;</b>
<b class="nc"><i>1888</i>&nbsp;                currentSym = syms.noSymbol;</b>
<b class="nc"><i>1889</i>&nbsp;                Assert.check(prevSym != null || prevSym != syms.noSymbol);</b>
<b class="nc"><i>1890</i>&nbsp;                return prevSym;</b>
<b class="nc"><i>1891</i>&nbsp;            }</b>
<i>1892</i>&nbsp;
<i>1893</i>&nbsp;            public void remove() {
<i>1894</i>&nbsp;                throw new UnsupportedOperationException();
<i>1895</i>&nbsp;            }
<i>1896</i>&nbsp;
<b class="nc"><i>1897</i>&nbsp;            TypeSymbol symbolFor(Type t) {</b>
<i>1898</i>&nbsp;                if (!t.hasTag(CLASS) &amp;&amp;
<i>1899</i>&nbsp;                        !t.hasTag(TYPEVAR)) {
<i>1900</i>&nbsp;                    return null;
<i>1901</i>&nbsp;                }
<i>1902</i>&nbsp;                t = types.skipTypeVars(t, false);
<i>1903</i>&nbsp;                if (seen.contains(t.tsym)) {
<i>1904</i>&nbsp;                    //degenerate case in which we have a circular
<i>1905</i>&nbsp;                    //class hierarchy - because of ill-formed classfiles
<i>1906</i>&nbsp;                    return null;
<b class="nc"><i>1907</i>&nbsp;                }</b>
<b class="nc"><i>1908</i>&nbsp;                seen = seen.prepend(t.tsym);</b>
<b class="nc"><i>1909</i>&nbsp;                return t.tsym;</b>
<b class="nc"><i>1910</i>&nbsp;            }</b>
<b class="nc"><i>1911</i>&nbsp;        };</b>
<b class="nc"><i>1912</i>&nbsp;    }</b>
<i>1913</i>&nbsp;
<i>1914</i>&nbsp;    /** Find unqualified method matching given name, type and value arguments.
<i>1915</i>&nbsp;     *  @param env       The current environment.
<i>1916</i>&nbsp;     *  @param name      The method&#39;s name.
<i>1917</i>&nbsp;     *  @param argtypes  The method&#39;s value arguments.
<i>1918</i>&nbsp;     *  @param typeargtypes  The method&#39;s type arguments.
<i>1919</i>&nbsp;     *  @param allowBoxing Allow boxing conversions of arguments.
<i>1920</i>&nbsp;     *  @param useVarargs Box trailing arguments into an array for varargs.
<i>1921</i>&nbsp;     */
<i>1922</i>&nbsp;    Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
<i>1923</i>&nbsp;                   List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
<i>1924</i>&nbsp;                   boolean allowBoxing, boolean useVarargs) {
<i>1925</i>&nbsp;        Symbol bestSoFar = methodNotFound;
<i>1926</i>&nbsp;        Env&lt;AttrContext&gt; env1 = env;
<i>1927</i>&nbsp;        boolean staticOnly = false;
<i>1928</i>&nbsp;        while (env1.outer != null) {
<i>1929</i>&nbsp;            if (isStatic(env1)) staticOnly = true;
<i>1930</i>&nbsp;            Assert.check(env1.info.preferredTreeForDiagnostics == null);
<i>1931</i>&nbsp;            env1.info.preferredTreeForDiagnostics = env.tree;
<b class="nc"><i>1932</i>&nbsp;            try {</b>
<b class="nc"><i>1933</i>&nbsp;                Symbol sym = findMethod(</b>
<b class="nc"><i>1934</i>&nbsp;                    env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,</b>
<b class="nc"><i>1935</i>&nbsp;                    allowBoxing, useVarargs);</b>
<i>1936</i>&nbsp;                if (sym.exists()) {
<i>1937</i>&nbsp;                    if (staticOnly &amp;&amp;
<i>1938</i>&nbsp;                        sym.kind == MTH &amp;&amp;
<b class="nc"><i>1939</i>&nbsp;                        sym.owner.kind == TYP &amp;&amp;</b>
<i>1940</i>&nbsp;                        (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
<b class="nc"><i>1941</i>&nbsp;                    else return sym;</b>
<i>1942</i>&nbsp;                } else {
<i>1943</i>&nbsp;                    bestSoFar = bestOf(bestSoFar, sym);
<i>1944</i>&nbsp;                }
<i>1945</i>&nbsp;            } finally {
<i>1946</i>&nbsp;                env1.info.preferredTreeForDiagnostics = null;
<i>1947</i>&nbsp;            }
<i>1948</i>&nbsp;            if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
<i>1949</i>&nbsp;            env1 = env1.outer;
<i>1950</i>&nbsp;        }
<i>1951</i>&nbsp;
<i>1952</i>&nbsp;        Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
<i>1953</i>&nbsp;                                typeargtypes, allowBoxing, useVarargs);
<i>1954</i>&nbsp;        if (sym.exists())
<i>1955</i>&nbsp;            return sym;
<i>1956</i>&nbsp;
<b class="nc"><i>1957</i>&nbsp;        for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {</b>
<i>1958</i>&nbsp;            Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
<b class="nc"><i>1959</i>&nbsp;            if (currentSym.kind == MTH) {</b>
<b class="nc"><i>1960</i>&nbsp;                if (currentSym.owner.type != origin.type)</b>
<b class="nc"><i>1961</i>&nbsp;                    currentSym = currentSym.clone(origin);</b>
<b class="nc"><i>1962</i>&nbsp;                if (!isAccessible(env, origin.type, currentSym))</b>
<i>1963</i>&nbsp;                    currentSym = new AccessError(env, origin.type, currentSym);
<b class="nc"><i>1964</i>&nbsp;                bestSoFar = selectBest(env, origin.type,</b>
<b class="nc"><i>1965</i>&nbsp;                                       argtypes, typeargtypes,</b>
<b class="nc"><i>1966</i>&nbsp;                                       currentSym, bestSoFar,</b>
<b class="nc"><i>1967</i>&nbsp;                                       allowBoxing, useVarargs);</b>
<b class="nc"><i>1968</i>&nbsp;            }</b>
<i>1969</i>&nbsp;        }
<b class="nc"><i>1970</i>&nbsp;        if (bestSoFar.exists())</b>
<b class="nc"><i>1971</i>&nbsp;            return bestSoFar;</b>
<b class="nc"><i>1972</i>&nbsp;</b>
<i>1973</i>&nbsp;        for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
<b class="nc"><i>1974</i>&nbsp;            Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;</b>
<i>1975</i>&nbsp;            if (currentSym.kind == MTH) {
<i>1976</i>&nbsp;                if (currentSym.owner.type != origin.type)
<i>1977</i>&nbsp;                    currentSym = currentSym.clone(origin);
<i>1978</i>&nbsp;                if (!isAccessible(env, origin.type, currentSym))
<i>1979</i>&nbsp;                    currentSym = new AccessError(env, origin.type, currentSym);
<i>1980</i>&nbsp;                bestSoFar = selectBest(env, origin.type,
<i>1981</i>&nbsp;                                       argtypes, typeargtypes,
<i>1982</i>&nbsp;                                       currentSym, bestSoFar,
<i>1983</i>&nbsp;                                       allowBoxing, useVarargs);
<i>1984</i>&nbsp;            }
<i>1985</i>&nbsp;        }
<i>1986</i>&nbsp;        return bestSoFar;
<i>1987</i>&nbsp;    }
<i>1988</i>&nbsp;
<i>1989</i>&nbsp;    /** Load toplevel or member class with given fully qualified name and
<b class="nc"><i>1990</i>&nbsp;     *  verify that it is accessible.</b>
<i>1991</i>&nbsp;     *  @param env       The current environment.
<b class="nc"><i>1992</i>&nbsp;     *  @param name      The fully qualified name of the class to be loaded.</b>
<b class="nc"><i>1993</i>&nbsp;     */</b>
<i>1994</i>&nbsp;    Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
<b class="nc"><i>1995</i>&nbsp;        try {</b>
<i>1996</i>&nbsp;            ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
<i>1997</i>&nbsp;            return isAccessible(env, c) ? c : new AccessError(env, null, c);
<i>1998</i>&nbsp;        } catch (ClassFinder.BadClassFile err) {
<i>1999</i>&nbsp;            return new BadClassFileError(err);
<i>2000</i>&nbsp;        } catch (CompletionFailure ex) {
<i>2001</i>&nbsp;            Symbol candidate = recoveryLoadClass.loadClass(env, name);
<i>2002</i>&nbsp;
<i>2003</i>&nbsp;            if (candidate != null) {
<i>2004</i>&nbsp;                return candidate;
<b class="nc"><i>2005</i>&nbsp;            }</b>
<b class="nc"><i>2006</i>&nbsp;</b>
<b class="nc"><i>2007</i>&nbsp;            return typeNotFound;</b>
<b class="nc"><i>2008</i>&nbsp;        }</b>
<i>2009</i>&nbsp;    }
<b class="nc"><i>2010</i>&nbsp;</b>
<b class="nc"><i>2011</i>&nbsp;    public interface RecoveryLoadClass {</b>
<b class="nc"><i>2012</i>&nbsp;        Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);</b>
<i>2013</i>&nbsp;    }
<b class="nc"><i>2014</i>&nbsp;</b>
<i>2015</i>&nbsp;    private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
<i>2016</i>&nbsp;
<i>2017</i>&nbsp;    private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
<b class="nc"><i>2018</i>&nbsp;        @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {</b>
<b class="nc"><i>2019</i>&nbsp;            List&lt;Name&gt; candidates = Convert.classCandidates(name);</b>
<b class="nc"><i>2020</i>&nbsp;            return lookupInvisibleSymbol(env, name,</b>
<b class="nc"><i>2021</i>&nbsp;                                         n -&gt; () -&gt; createCompoundIterator(candidates,</b>
<b class="nc"><i>2022</i>&nbsp;                                                                           c -&gt; syms.getClassesForName(c)</b>
<b class="nc"><i>2023</i>&nbsp;                                                                                    .iterator()),</b>
<i>2024</i>&nbsp;                                         (ms, n) -&gt; {
<b class="nc"><i>2025</i>&nbsp;                for (Name candidate : candidates) {</b>
<b class="nc"><i>2026</i>&nbsp;                    try {</b>
<i>2027</i>&nbsp;                        return finder.loadClass(ms, candidate);
<i>2028</i>&nbsp;                    } catch (CompletionFailure cf) {
<b class="nc"><i>2029</i>&nbsp;                        //ignore</b>
<i>2030</i>&nbsp;                    }
<i>2031</i>&nbsp;                }
<i>2032</i>&nbsp;                return null;
<i>2033</i>&nbsp;            }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
<i>2034</i>&nbsp;        }
<i>2035</i>&nbsp;    };
<i>2036</i>&nbsp;
<b class="nc"><i>2037</i>&nbsp;    private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {</b>
<i>2038</i>&nbsp;        Scope importScope = env.toplevel.namedImportScope;
<b class="nc"><i>2039</i>&nbsp;        Symbol existing = importScope.findFirst(Convert.shortName(name),</b>
<b class="nc"><i>2040</i>&nbsp;                                                sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);</b>
<b class="nc"><i>2041</i>&nbsp;</b>
<i>2042</i>&nbsp;        if (existing != null) {
<b class="nc"><i>2043</i>&nbsp;            return new InvisibleSymbolError(env, true, existing);</b>
<b class="nc"><i>2044</i>&nbsp;        }</b>
<i>2045</i>&nbsp;        return null;
<i>2046</i>&nbsp;    };
<i>2047</i>&nbsp;
<i>2048</i>&nbsp;    private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
<b class="nc"><i>2049</i>&nbsp;        Scope importScope = env.toplevel.starImportScope;</b>
<b class="nc"><i>2050</i>&nbsp;        Symbol existing = importScope.findFirst(Convert.shortName(name),</b>
<b class="nc"><i>2051</i>&nbsp;                                                sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);</b>
<i>2052</i>&nbsp;
<b class="nc"><i>2053</i>&nbsp;        if (existing != null) {</b>
<i>2054</i>&nbsp;            try {
<i>2055</i>&nbsp;                existing = finder.loadClass(existing.packge().modle, name);
<i>2056</i>&nbsp;
<i>2057</i>&nbsp;                return new InvisibleSymbolError(env, true, existing);
<b class="nc"><i>2058</i>&nbsp;            } catch (CompletionFailure cf) {</b>
<b class="nc"><i>2059</i>&nbsp;                //ignore</b>
<i>2060</i>&nbsp;            }
<i>2061</i>&nbsp;        }
<b class="nc"><i>2062</i>&nbsp;</b>
<b class="nc"><i>2063</i>&nbsp;        return null;</b>
<b class="nc"><i>2064</i>&nbsp;    };</b>
<b class="nc"><i>2065</i>&nbsp;</b>
<b class="nc"><i>2066</i>&nbsp;    Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {</b>
<b class="nc"><i>2067</i>&nbsp;        PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);</b>
<b class="nc"><i>2068</i>&nbsp;</b>
<b class="nc"><i>2069</i>&nbsp;        if (allowModules &amp;&amp; isImportOnDemand(env, name)) {</b>
<i>2070</i>&nbsp;            if (pack.members().isEmpty()) {
<b class="nc"><i>2071</i>&nbsp;                return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {</b>
<b class="nc"><i>2072</i>&nbsp;                    sym.complete();</b>
<b class="nc"><i>2073</i>&nbsp;                    return !sym.members().isEmpty();</b>
<i>2074</i>&nbsp;                }, pack);
<i>2075</i>&nbsp;            }
<b class="nc"><i>2076</i>&nbsp;        }</b>
<b class="nc"><i>2077</i>&nbsp;</b>
<b class="nc"><i>2078</i>&nbsp;        return pack;</b>
<b class="nc"><i>2079</i>&nbsp;    }</b>
<i>2080</i>&nbsp;
<b class="nc"><i>2081</i>&nbsp;    private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {</b>
<b class="nc"><i>2082</i>&nbsp;        if (!env.tree.hasTag(IMPORT))</b>
<b class="nc"><i>2083</i>&nbsp;            return false;</b>
<i>2084</i>&nbsp;
<b class="nc"><i>2085</i>&nbsp;        JCTree qualid = ((JCImport) env.tree).qualid;</b>
<b class="nc"><i>2086</i>&nbsp;</b>
<b class="nc"><i>2087</i>&nbsp;        if (!qualid.hasTag(SELECT))</b>
<i>2088</i>&nbsp;            return false;
<i>2089</i>&nbsp;
<b class="nc"><i>2090</i>&nbsp;        if (TreeInfo.name(qualid) != names.asterisk)</b>
<i>2091</i>&nbsp;            return false;
<i>2092</i>&nbsp;
<i>2093</i>&nbsp;        return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
<i>2094</i>&nbsp;    }
<i>2095</i>&nbsp;
<i>2096</i>&nbsp;    private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
<i>2097</i>&nbsp;                                                            Name name,
<i>2098</i>&nbsp;                                                            Function&lt;Name, Iterable&lt;S&gt;&gt; get,
<i>2099</i>&nbsp;                                                            BiFunction&lt;ModuleSymbol, Name, S&gt; load,
<b class="nc"><i>2100</i>&nbsp;                                                            Predicate&lt;S&gt; validate,</b>
<i>2101</i>&nbsp;                                                            Symbol defaultResult) {
<i>2102</i>&nbsp;        //even if a class/package cannot be found in the current module and among packages in modules
<b class="nc"><i>2103</i>&nbsp;        //it depends on that are exported for any or this module, the class/package may exist internally</b>
<b class="nc"><i>2104</i>&nbsp;        //in some of these modules, or may exist in a module on which this module does not depend.</b>
<b class="nc"><i>2105</i>&nbsp;        //Provide better diagnostic in such cases by looking for the class in any module:</b>
<b class="nc"><i>2106</i>&nbsp;        Iterable&lt;? extends S&gt; candidates = get.apply(name);</b>
<i>2107</i>&nbsp;
<i>2108</i>&nbsp;        for (S sym : candidates) {
<b class="nc"><i>2109</i>&nbsp;            if (validate.test(sym))</b>
<b class="nc"><i>2110</i>&nbsp;                return createInvisibleSymbolError(env, sym);</b>
<b class="nc"><i>2111</i>&nbsp;        }</b>
<b class="nc"><i>2112</i>&nbsp;</b>
<i>2113</i>&nbsp;        Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
<b class="nc"><i>2114</i>&nbsp;</b>
<b class="nc"><i>2115</i>&nbsp;        recoverableModules.add(syms.unnamedModule);</b>
<i>2116</i>&nbsp;        recoverableModules.remove(env.toplevel.modle);
<i>2117</i>&nbsp;
<b class="nc"><i>2118</i>&nbsp;        for (ModuleSymbol ms : recoverableModules) {</b>
<b class="nc"><i>2119</i>&nbsp;            //avoid overly eager completing classes from source-based modules, as those</b>
<i>2120</i>&nbsp;            //may not be completable with the current compiler settings:
<i>2121</i>&nbsp;            if (ms.sourceLocation == null) {
<i>2122</i>&nbsp;                if (ms.classLocation == null) {
<i>2123</i>&nbsp;                    ms = moduleFinder.findModule(ms);
<i>2124</i>&nbsp;                }
<i>2125</i>&nbsp;
<i>2126</i>&nbsp;                if (ms.kind != ERR) {
<i>2127</i>&nbsp;                    S sym = load.apply(ms, name);
<i>2128</i>&nbsp;
<i>2129</i>&nbsp;                    if (sym != null &amp;&amp; validate.test(sym)) {
<i>2130</i>&nbsp;                        return createInvisibleSymbolError(env, sym);
<i>2131</i>&nbsp;                    }
<i>2132</i>&nbsp;                }
<i>2133</i>&nbsp;            }
<i>2134</i>&nbsp;        }
<i>2135</i>&nbsp;
<i>2136</i>&nbsp;        return defaultResult;
<i>2137</i>&nbsp;    }
<b class="nc"><i>2138</i>&nbsp;</b>
<b class="nc"><i>2139</i>&nbsp;    private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {</b>
<b class="nc"><i>2140</i>&nbsp;        if (symbolPackageVisible(env, sym)) {</b>
<b class="nc"><i>2141</i>&nbsp;            return new AccessError(env, null, sym);</b>
<b class="nc"><i>2142</i>&nbsp;        } else {</b>
<b class="nc"><i>2143</i>&nbsp;            return new InvisibleSymbolError(env, false, sym);</b>
<i>2144</i>&nbsp;        }
<b class="nc"><i>2145</i>&nbsp;    }</b>
<b class="nc"><i>2146</i>&nbsp;</b>
<b class="nc"><i>2147</i>&nbsp;    private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {</b>
<i>2148</i>&nbsp;        ModuleSymbol envMod = env.toplevel.modle;
<b class="nc"><i>2149</i>&nbsp;        PackageSymbol symPack = sym.packge();</b>
<i>2150</i>&nbsp;        return envMod == symPack.modle ||
<b class="nc"><i>2151</i>&nbsp;               envMod.visiblePackages.containsKey(symPack.fullname);</b>
<i>2152</i>&nbsp;    }
<b class="nc"><i>2153</i>&nbsp;</b>
<i>2154</i>&nbsp;    /**
<i>2155</i>&nbsp;     * Find a type declared in a scope (not inherited).  Return null
<i>2156</i>&nbsp;     * if none is found.
<i>2157</i>&nbsp;     *  @param env       The current environment.
<i>2158</i>&nbsp;     *  @param site      The original type from where the selection takes
<i>2159</i>&nbsp;     *                   place.
<i>2160</i>&nbsp;     *  @param name      The type&#39;s name.
<i>2161</i>&nbsp;     *  @param c         The class to search for the member type. This is
<i>2162</i>&nbsp;     *                   always a superclass or implemented interface of
<i>2163</i>&nbsp;     *                   site&#39;s class.
<i>2164</i>&nbsp;     */
<b class="nc"><i>2165</i>&nbsp;    Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,</b>
<i>2166</i>&nbsp;                                   Type site,
<b class="nc"><i>2167</i>&nbsp;                                   Name name,</b>
<b class="nc"><i>2168</i>&nbsp;                                   TypeSymbol c) {</b>
<b class="nc"><i>2169</i>&nbsp;        for (Symbol sym : c.members().getSymbolsByName(name)) {</b>
<b class="nc"><i>2170</i>&nbsp;            if (sym.kind == TYP) {</b>
<i>2171</i>&nbsp;                return isAccessible(env, site, sym)
<i>2172</i>&nbsp;                    ? sym
<b class="nc"><i>2173</i>&nbsp;                    : new AccessError(env, site, sym);</b>
<b class="nc"><i>2174</i>&nbsp;            }</b>
<b class="nc"><i>2175</i>&nbsp;        }</b>
<b class="nc"><i>2176</i>&nbsp;        return typeNotFound;</b>
<i>2177</i>&nbsp;    }
<b class="nc"><i>2178</i>&nbsp;</b>
<i>2179</i>&nbsp;    /** Find a member type inherited from a superclass or interface.
<i>2180</i>&nbsp;     *  @param env       The current environment.
<i>2181</i>&nbsp;     *  @param site      The original type from where the selection takes
<i>2182</i>&nbsp;     *                   place.
<i>2183</i>&nbsp;     *  @param name      The type&#39;s name.
<i>2184</i>&nbsp;     *  @param c         The class to search for the member type. This is
<i>2185</i>&nbsp;     *                   always a superclass or implemented interface of
<i>2186</i>&nbsp;     *                   site&#39;s class.
<i>2187</i>&nbsp;     */
<i>2188</i>&nbsp;    Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
<i>2189</i>&nbsp;                                   Type site,
<i>2190</i>&nbsp;                                   Name name,
<i>2191</i>&nbsp;                                   TypeSymbol c) {
<i>2192</i>&nbsp;        Symbol bestSoFar = typeNotFound;
<i>2193</i>&nbsp;        Symbol sym;
<i>2194</i>&nbsp;        Type st = types.supertype(c.type);
<i>2195</i>&nbsp;        if (st != null &amp;&amp; st.hasTag(CLASS)) {
<i>2196</i>&nbsp;            sym = findMemberType(env, site, name, st.tsym);
<i>2197</i>&nbsp;            bestSoFar = bestOf(bestSoFar, sym);
<i>2198</i>&nbsp;        }
<i>2199</i>&nbsp;        for (List&lt;Type&gt; l = types.interfaces(c.type);
<i>2200</i>&nbsp;             bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
<i>2201</i>&nbsp;             l = l.tail) {
<i>2202</i>&nbsp;            sym = findMemberType(env, site, name, l.head.tsym);
<i>2203</i>&nbsp;            if (!bestSoFar.kind.isResolutionError() &amp;&amp;
<i>2204</i>&nbsp;                !sym.kind.isResolutionError() &amp;&amp;
<i>2205</i>&nbsp;                sym.owner != bestSoFar.owner)
<i>2206</i>&nbsp;                bestSoFar = new AmbiguityError(bestSoFar, sym);
<i>2207</i>&nbsp;            else
<i>2208</i>&nbsp;                bestSoFar = bestOf(bestSoFar, sym);
<i>2209</i>&nbsp;        }
<i>2210</i>&nbsp;        return bestSoFar;
<i>2211</i>&nbsp;    }
<i>2212</i>&nbsp;
<i>2213</i>&nbsp;    /** Find qualified member type.
<b class="nc"><i>2214</i>&nbsp;     *  @param env       The current environment.</b>
<b class="nc"><i>2215</i>&nbsp;     *  @param site      The original type from where the selection takes</b>
<b class="nc"><i>2216</i>&nbsp;     *                   place.</b>
<b class="nc"><i>2217</i>&nbsp;     *  @param name      The type&#39;s name.</b>
<b class="nc"><i>2218</i>&nbsp;     *  @param c         The class to search for the member type. This is</b>
<b class="nc"><i>2219</i>&nbsp;     *                   always a superclass or implemented interface of</b>
<i>2220</i>&nbsp;     *                   site&#39;s class.
<i>2221</i>&nbsp;     */
<b class="nc"><i>2222</i>&nbsp;    Symbol findMemberType(Env&lt;AttrContext&gt; env,</b>
<i>2223</i>&nbsp;                          Type site,
<i>2224</i>&nbsp;                          Name name,
<i>2225</i>&nbsp;                          TypeSymbol c) {
<i>2226</i>&nbsp;        Symbol sym = findImmediateMemberType(env, site, name, c);
<i>2227</i>&nbsp;
<i>2228</i>&nbsp;        if (sym != typeNotFound)
<i>2229</i>&nbsp;            return sym;
<i>2230</i>&nbsp;
<i>2231</i>&nbsp;        return findInheritedMemberType(env, site, name, c);
<i>2232</i>&nbsp;
<i>2233</i>&nbsp;    }
<i>2234</i>&nbsp;
<i>2235</i>&nbsp;    /** Find a global type in given scope and load corresponding class.
<i>2236</i>&nbsp;     *  @param env       The current environment.
<b class="nc"><i>2237</i>&nbsp;     *  @param scope     The scope in which to look for the type.</b>
<i>2238</i>&nbsp;     *  @param name      The type&#39;s name.
<i>2239</i>&nbsp;     */
<i>2240</i>&nbsp;    Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
<i>2241</i>&nbsp;        Symbol bestSoFar = typeNotFound;
<i>2242</i>&nbsp;        for (Symbol s : scope.getSymbolsByName(name)) {
<i>2243</i>&nbsp;            Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
<i>2244</i>&nbsp;            if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
<i>2245</i>&nbsp;                bestSoFar != sym)
<i>2246</i>&nbsp;                return new AmbiguityError(bestSoFar, sym);
<i>2247</i>&nbsp;            else
<i>2248</i>&nbsp;                bestSoFar = bestOf(bestSoFar, sym);
<b class="nc"><i>2249</i>&nbsp;        }</b>
<i>2250</i>&nbsp;        return bestSoFar;
<i>2251</i>&nbsp;    }
<i>2252</i>&nbsp;
<i>2253</i>&nbsp;    Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
<i>2254</i>&nbsp;        for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
<i>2255</i>&nbsp;            if (sym.kind == TYP) {
<i>2256</i>&nbsp;                if (staticOnly &amp;&amp;
<i>2257</i>&nbsp;                    sym.type.hasTag(TYPEVAR) &amp;&amp;
<i>2258</i>&nbsp;                    sym.owner.kind == TYP)
<i>2259</i>&nbsp;                    return new StaticError(sym);
<i>2260</i>&nbsp;                return sym;
<i>2261</i>&nbsp;            }
<b class="nc"><i>2262</i>&nbsp;        }</b>
<i>2263</i>&nbsp;        return typeNotFound;
<i>2264</i>&nbsp;    }
<i>2265</i>&nbsp;
<i>2266</i>&nbsp;    /** Find an unqualified type symbol.
<i>2267</i>&nbsp;     *  @param env       The current environment.
<i>2268</i>&nbsp;     *  @param name      The type&#39;s name.
<i>2269</i>&nbsp;     */
<i>2270</i>&nbsp;    Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
<i>2271</i>&nbsp;        if (name == names.empty)
<b class="nc"><i>2272</i>&nbsp;            return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types</b>
<i>2273</i>&nbsp;        Symbol bestSoFar = typeNotFound;
<i>2274</i>&nbsp;        Symbol sym;
<i>2275</i>&nbsp;        boolean staticOnly = false;
<i>2276</i>&nbsp;        for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
<i>2277</i>&nbsp;            if (isStatic(env1)) staticOnly = true;
<i>2278</i>&nbsp;            // First, look for a type variable and the first member type
<i>2279</i>&nbsp;            final Symbol tyvar = findTypeVar(env1, name, staticOnly);
<b class="nc"><i>2280</i>&nbsp;            sym = findImmediateMemberType(env1, env1.enclClass.sym.type,</b>
<i>2281</i>&nbsp;                                          name, env1.enclClass.sym);
<b class="nc"><i>2282</i>&nbsp;</b>
<i>2283</i>&nbsp;            // Return the type variable if we have it, and have no
<i>2284</i>&nbsp;            // immediate member, OR the type variable is for a method.
<b class="nc"><i>2285</i>&nbsp;            if (tyvar != typeNotFound) {</b>
<i>2286</i>&nbsp;                if (env.baseClause || sym == typeNotFound ||
<i>2287</i>&nbsp;                    (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
<i>2288</i>&nbsp;                     tyvar.owner.kind == MTH)) {
<b class="nc"><i>2289</i>&nbsp;                    return tyvar;</b>
<i>2290</i>&nbsp;                }
<b class="nc"><i>2291</i>&nbsp;            }</b>
<b class="nc"><i>2292</i>&nbsp;</b>
<b class="nc"><i>2293</i>&nbsp;            // If the environment is a class def, finish up,</b>
<i>2294</i>&nbsp;            // otherwise, do the entire findMemberType
<i>2295</i>&nbsp;            if (sym == typeNotFound)
<b class="nc"><i>2296</i>&nbsp;                sym = findInheritedMemberType(env1, env1.enclClass.sym.type,</b>
<i>2297</i>&nbsp;                                              name, env1.enclClass.sym);
<b class="nc"><i>2298</i>&nbsp;</b>
<i>2299</i>&nbsp;            if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
<i>2300</i>&nbsp;                sym.type.hasTag(CLASS) &amp;&amp;
<i>2301</i>&nbsp;                sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
<i>2302</i>&nbsp;                env1.enclClass.sym.type.isParameterized() &amp;&amp;
<i>2303</i>&nbsp;                sym.type.getEnclosingType().isParameterized())
<b class="nc"><i>2304</i>&nbsp;                return new StaticError(sym);</b>
<b class="nc"><i>2305</i>&nbsp;            else if (sym.exists()) return sym;</b>
<i>2306</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2307</i>&nbsp;
<i>2308</i>&nbsp;            JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
<i>2309</i>&nbsp;            if ((encl.sym.flags() &amp; STATIC) != 0)
<b class="nc"><i>2310</i>&nbsp;                staticOnly = true;</b>
<b class="nc"><i>2311</i>&nbsp;        }</b>
<b class="nc"><i>2312</i>&nbsp;</b>
<i>2313</i>&nbsp;        if (!env.tree.hasTag(IMPORT)) {
<i>2314</i>&nbsp;            sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
<b class="nc"><i>2315</i>&nbsp;            if (sym.exists()) return sym;</b>
<i>2316</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<b class="nc"><i>2317</i>&nbsp;</b>
<i>2318</i>&nbsp;            sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
<i>2319</i>&nbsp;            if (sym.exists()) return sym;
<i>2320</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<b class="nc"><i>2321</i>&nbsp;</b>
<i>2322</i>&nbsp;            sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
<i>2323</i>&nbsp;            if (sym.exists()) return sym;
<i>2324</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2325</i>&nbsp;
<i>2326</i>&nbsp;            sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
<i>2327</i>&nbsp;            if (sym.exists()) return sym;
<b class="nc"><i>2328</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);</b>
<b class="nc"><i>2329</i>&nbsp;        }</b>
<b class="nc"><i>2330</i>&nbsp;</b>
<i>2331</i>&nbsp;        return bestSoFar;
<i>2332</i>&nbsp;    }
<i>2333</i>&nbsp;
<i>2334</i>&nbsp;    /** Find an unqualified identifier which matches a specified kind set.
<i>2335</i>&nbsp;     *  @param env       The current environment.
<i>2336</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2337</i>&nbsp;     *  @param kind      Indicates the possible symbol kinds
<i>2338</i>&nbsp;     *                   (a subset of VAL, TYP, PCK).
<i>2339</i>&nbsp;     */
<i>2340</i>&nbsp;    Symbol findIdent(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
<b class="nc"><i>2341</i>&nbsp;        return checkVarType(findIdentInternal(env, name, kind), name);</b>
<b class="nc"><i>2342</i>&nbsp;    }</b>
<b class="nc"><i>2343</i>&nbsp;</b>
<b class="nc"><i>2344</i>&nbsp;    Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</b>
<b class="nc"><i>2345</i>&nbsp;        Symbol bestSoFar = typeNotFound;</b>
<b class="nc"><i>2346</i>&nbsp;        Symbol sym;</b>
<b class="nc"><i>2347</i>&nbsp;</b>
<i>2348</i>&nbsp;        if (kind.contains(KindSelector.VAL)) {
<b class="nc"><i>2349</i>&nbsp;            sym = findVar(env, name);</b>
<b class="nc"><i>2350</i>&nbsp;            if (sym.exists()) return sym;</b>
<i>2351</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2352</i>&nbsp;        }
<i>2353</i>&nbsp;
<i>2354</i>&nbsp;        if (kind.contains(KindSelector.TYP)) {
<b class="nc"><i>2355</i>&nbsp;            sym = findType(env, name);</b>
<b class="nc"><i>2356</i>&nbsp;</b>
<b class="nc"><i>2357</i>&nbsp;            if (sym.exists()) return sym;</b>
<b class="nc"><i>2358</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);</b>
<i>2359</i>&nbsp;        }
<i>2360</i>&nbsp;
<i>2361</i>&nbsp;        if (kind.contains(KindSelector.PCK))
<i>2362</i>&nbsp;            return lookupPackage(env, name);
<b class="nc"><i>2363</i>&nbsp;        else return bestSoFar;</b>
<b class="nc"><i>2364</i>&nbsp;    }</b>
<b class="nc"><i>2365</i>&nbsp;</b>
<i>2366</i>&nbsp;    /** Find an identifier in a package which matches a specified kind set.
<i>2367</i>&nbsp;     *  @param env       The current environment.
<i>2368</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2369</i>&nbsp;     *  @param kind      Indicates the possible symbol kinds
<i>2370</i>&nbsp;     *                   (a nonempty subset of TYP, PCK).
<i>2371</i>&nbsp;     */
<i>2372</i>&nbsp;    Symbol findIdentInPackage(Env&lt;AttrContext&gt; env, TypeSymbol pck,
<i>2373</i>&nbsp;                              Name name, KindSelector kind) {
<i>2374</i>&nbsp;        return checkVarType(findIdentInPackageInternal(env, pck, name, kind), name);
<i>2375</i>&nbsp;    }
<i>2376</i>&nbsp;
<i>2377</i>&nbsp;    Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
<i>2378</i>&nbsp;                              Name name, KindSelector kind) {
<i>2379</i>&nbsp;        Name fullname = TypeSymbol.formFullName(name, pck);
<i>2380</i>&nbsp;        Symbol bestSoFar = typeNotFound;
<i>2381</i>&nbsp;        if (kind.contains(KindSelector.TYP)) {
<i>2382</i>&nbsp;            RecoveryLoadClass recoveryLoadClass =
<b class="nc"><i>2383</i>&nbsp;                    allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;</b>
<b class="nc"><i>2384</i>&nbsp;                    !pck.exists() &amp;&amp; !env.info.isSpeculative ?</b>
<i>2385</i>&nbsp;                        doRecoveryLoadClass : noRecovery;
<i>2386</i>&nbsp;            Symbol sym = loadClass(env, fullname, recoveryLoadClass);
<i>2387</i>&nbsp;            if (sym.exists()) {
<i>2388</i>&nbsp;                // don&#39;t allow programs to use flatnames
<i>2389</i>&nbsp;                if (name == sym.name) return sym;
<i>2390</i>&nbsp;            }
<i>2391</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2392</i>&nbsp;        }
<i>2393</i>&nbsp;        if (kind.contains(KindSelector.PCK)) {
<i>2394</i>&nbsp;            return lookupPackage(env, fullname);
<i>2395</i>&nbsp;        }
<i>2396</i>&nbsp;        return bestSoFar;
<i>2397</i>&nbsp;    }
<i>2398</i>&nbsp;
<i>2399</i>&nbsp;    /** Find an identifier among the members of a given type `site&#39;.
<b class="nc"><i>2400</i>&nbsp;     *  @param env       The current environment.</b>
<b class="nc"><i>2401</i>&nbsp;     *  @param site      The type containing the symbol to be found.</b>
<i>2402</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2403</i>&nbsp;     *  @param kind      Indicates the possible symbol kinds
<b class="nc"><i>2404</i>&nbsp;     *                   (a subset of VAL, TYP).</b>
<b class="nc"><i>2405</i>&nbsp;     */</b>
<b class="nc"><i>2406</i>&nbsp;    Symbol findIdentInType(Env&lt;AttrContext&gt; env, Type site,</b>
<i>2407</i>&nbsp;                           Name name, KindSelector kind) {
<i>2408</i>&nbsp;        return checkVarType(findIdentInTypeInternal(env, site, name, kind), name);
<i>2409</i>&nbsp;    }
<i>2410</i>&nbsp;
<i>2411</i>&nbsp;    Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
<i>2412</i>&nbsp;                           Name name, KindSelector kind) {
<i>2413</i>&nbsp;        Symbol bestSoFar = typeNotFound;
<i>2414</i>&nbsp;        Symbol sym;
<i>2415</i>&nbsp;        if (kind.contains(KindSelector.VAL)) {
<i>2416</i>&nbsp;            sym = findField(env, site, name, site.tsym);
<i>2417</i>&nbsp;            if (sym.exists()) return sym;
<i>2418</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2419</i>&nbsp;        }
<i>2420</i>&nbsp;
<i>2421</i>&nbsp;        if (kind.contains(KindSelector.TYP)) {
<b class="nc"><i>2422</i>&nbsp;            sym = findMemberType(env, site, name, site.tsym);</b>
<i>2423</i>&nbsp;            if (sym.exists()) return sym;
<i>2424</i>&nbsp;            else bestSoFar = bestOf(bestSoFar, sym);
<i>2425</i>&nbsp;        }
<i>2426</i>&nbsp;        return bestSoFar;
<b class="nc"><i>2427</i>&nbsp;    }</b>
<i>2428</i>&nbsp;
<i>2429</i>&nbsp;    private Symbol checkVarType(Symbol bestSoFar, Name name) {
<i>2430</i>&nbsp;        if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var) &amp;&amp;
<i>2431</i>&nbsp;                (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP)) {
<i>2432</i>&nbsp;            bestSoFar = new BadVarTypeError();
<b class="nc"><i>2433</i>&nbsp;        }</b>
<i>2434</i>&nbsp;        return bestSoFar;
<i>2435</i>&nbsp;    }
<b class="nc"><i>2436</i>&nbsp;</b>
<b class="nc"><i>2437</i>&nbsp;/* ***************************************************************************</b>
<b class="nc"><i>2438</i>&nbsp; *  Access checking</b>
<i>2439</i>&nbsp; *  The following methods convert ResolveErrors to ErrorSymbols, issuing
<i>2440</i>&nbsp; *  an error message in the process
<i>2441</i>&nbsp; ****************************************************************************/
<b class="nc"><i>2442</i>&nbsp;</b>
<b class="nc"><i>2443</i>&nbsp;    /** If `sym&#39; is a bad symbol: report error and return errSymbol</b>
<b class="nc"><i>2444</i>&nbsp;     *  else pass through unchanged,</b>
<b class="nc"><i>2445</i>&nbsp;     *  additional arguments duplicate what has been used in trying to find the</b>
<b class="nc"><i>2446</i>&nbsp;     *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we</b>
<b class="nc"><i>2447</i>&nbsp;     *  expect misses to happen frequently.</b>
<i>2448</i>&nbsp;     *
<i>2449</i>&nbsp;     *  @param sym       The symbol that was found, or a ResolveError.
<b class="nc"><i>2450</i>&nbsp;     *  @param pos       The position to use for error reporting.</b>
<i>2451</i>&nbsp;     *  @param location  The symbol the served as a context for this lookup
<i>2452</i>&nbsp;     *  @param site      The original type from where the selection took place.
<i>2453</i>&nbsp;     *  @param name      The symbol&#39;s name.
<i>2454</i>&nbsp;     *  @param qualified Did we get here through a qualified expression resolution?
<i>2455</i>&nbsp;     *  @param argtypes  The invocation&#39;s value arguments,
<i>2456</i>&nbsp;     *                   if we looked for a method.
<i>2457</i>&nbsp;     *  @param typeargtypes  The invocation&#39;s type arguments,
<i>2458</i>&nbsp;     *                   if we looked for a method.
<i>2459</i>&nbsp;     *  @param logResolveHelper helper class used to log resolve errors
<i>2460</i>&nbsp;     */
<i>2461</i>&nbsp;    Symbol accessInternal(Symbol sym,
<i>2462</i>&nbsp;                  DiagnosticPosition pos,
<i>2463</i>&nbsp;                  Symbol location,
<i>2464</i>&nbsp;                  Type site,
<b class="nc"><i>2465</i>&nbsp;                  Name name,</b>
<i>2466</i>&nbsp;                  boolean qualified,
<b class="nc"><i>2467</i>&nbsp;                  List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>2468</i>&nbsp;                  List&lt;Type&gt; typeargtypes,</b>
<b class="nc"><i>2469</i>&nbsp;                  LogResolveHelper logResolveHelper) {</b>
<i>2470</i>&nbsp;        if (sym.kind.isResolutionError()) {
<b class="nc"><i>2471</i>&nbsp;            ResolveError errSym = (ResolveError)sym.baseSymbol();</b>
<i>2472</i>&nbsp;            sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
<i>2473</i>&nbsp;            argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
<b class="nc"><i>2474</i>&nbsp;            if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {</b>
<b class="nc"><i>2475</i>&nbsp;                logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);</b>
<i>2476</i>&nbsp;            }
<i>2477</i>&nbsp;        }
<b class="nc"><i>2478</i>&nbsp;        return sym;</b>
<i>2479</i>&nbsp;    }
<i>2480</i>&nbsp;
<b class="nc"><i>2481</i>&nbsp;    /**</b>
<b class="nc"><i>2482</i>&nbsp;     * Variant of the generalized access routine, to be used for generating method</b>
<i>2483</i>&nbsp;     * resolution diagnostics
<b class="nc"><i>2484</i>&nbsp;     */</b>
<i>2485</i>&nbsp;    Symbol accessMethod(Symbol sym,
<i>2486</i>&nbsp;                  DiagnosticPosition pos,
<i>2487</i>&nbsp;                  Symbol location,
<i>2488</i>&nbsp;                  Type site,
<i>2489</i>&nbsp;                  Name name,
<i>2490</i>&nbsp;                  boolean qualified,
<i>2491</i>&nbsp;                  List&lt;Type&gt; argtypes,
<i>2492</i>&nbsp;                  List&lt;Type&gt; typeargtypes) {
<i>2493</i>&nbsp;        return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
<i>2494</i>&nbsp;    }
<i>2495</i>&nbsp;
<i>2496</i>&nbsp;    /** Same as original accessMethod(), but without location.
<i>2497</i>&nbsp;     */
<i>2498</i>&nbsp;    Symbol accessMethod(Symbol sym,
<i>2499</i>&nbsp;                  DiagnosticPosition pos,
<i>2500</i>&nbsp;                  Type site,
<b class="nc"><i>2501</i>&nbsp;                  Name name,</b>
<b class="nc"><i>2502</i>&nbsp;                  boolean qualified,</b>
<b class="nc"><i>2503</i>&nbsp;                  List&lt;Type&gt; argtypes,</b>
<i>2504</i>&nbsp;                  List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>2505</i>&nbsp;        return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);</b>
<b class="nc"><i>2506</i>&nbsp;    }</b>
<b class="nc"><i>2507</i>&nbsp;</b>
<i>2508</i>&nbsp;    /**
<i>2509</i>&nbsp;     * Variant of the generalized access routine, to be used for generating variable,
<i>2510</i>&nbsp;     * type resolution diagnostics
<i>2511</i>&nbsp;     */
<i>2512</i>&nbsp;    Symbol accessBase(Symbol sym,
<i>2513</i>&nbsp;                  DiagnosticPosition pos,
<i>2514</i>&nbsp;                  Symbol location,
<i>2515</i>&nbsp;                  Type site,
<i>2516</i>&nbsp;                  Name name,
<i>2517</i>&nbsp;                  boolean qualified) {
<i>2518</i>&nbsp;        return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
<i>2519</i>&nbsp;    }
<i>2520</i>&nbsp;
<i>2521</i>&nbsp;    /** Same as original accessBase(), but without location.
<i>2522</i>&nbsp;     */
<i>2523</i>&nbsp;    Symbol accessBase(Symbol sym,
<i>2524</i>&nbsp;                  DiagnosticPosition pos,
<b class="nc"><i>2525</i>&nbsp;                  Type site,</b>
<i>2526</i>&nbsp;                  Name name,
<i>2527</i>&nbsp;                  boolean qualified) {
<i>2528</i>&nbsp;        return accessBase(sym, pos, site.tsym, site, name, qualified);
<i>2529</i>&nbsp;    }
<i>2530</i>&nbsp;
<i>2531</i>&nbsp;    interface LogResolveHelper {
<i>2532</i>&nbsp;        boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
<i>2533</i>&nbsp;        List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
<b class="nc"><i>2534</i>&nbsp;    }</b>
<i>2535</i>&nbsp;
<i>2536</i>&nbsp;    LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
<b class="nc"><i>2537</i>&nbsp;        public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {</b>
<b class="nc"><i>2538</i>&nbsp;            return !site.isErroneous();</b>
<b class="nc"><i>2539</i>&nbsp;        }</b>
<i>2540</i>&nbsp;        public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
<i>2541</i>&nbsp;            return argtypes;
<i>2542</i>&nbsp;        }
<i>2543</i>&nbsp;    };
<i>2544</i>&nbsp;
<i>2545</i>&nbsp;    LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
<i>2546</i>&nbsp;        public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>2547</i>&nbsp;            return !site.isErroneous() &amp;&amp;
<i>2548</i>&nbsp;                        !Type.isErroneous(argtypes) &amp;&amp;
<i>2549</i>&nbsp;                        (typeargtypes == null || !Type.isErroneous(typeargtypes));
<i>2550</i>&nbsp;        }
<i>2551</i>&nbsp;        public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
<i>2552</i>&nbsp;            return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
<i>2553</i>&nbsp;        }
<i>2554</i>&nbsp;    };
<b class="nc"><i>2555</i>&nbsp;</b>
<b class="nc"><i>2556</i>&nbsp;    class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {</b>
<b class="nc"><i>2557</i>&nbsp;</b>
<b class="nc"><i>2558</i>&nbsp;        public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {</b>
<b class="nc"><i>2559</i>&nbsp;            deferredAttr.super(mode, msym, step);</b>
<b class="nc"><i>2560</i>&nbsp;        }</b>
<i>2561</i>&nbsp;
<i>2562</i>&nbsp;        @Override
<i>2563</i>&nbsp;        protected Type typeOf(DeferredType dt) {
<i>2564</i>&nbsp;            Type res = super.typeOf(dt);
<i>2565</i>&nbsp;            if (!res.isErroneous()) {
<i>2566</i>&nbsp;                switch (TreeInfo.skipParens(dt.tree).getTag()) {
<i>2567</i>&nbsp;                    case LAMBDA:
<b class="nc"><i>2568</i>&nbsp;                    case REFERENCE:</b>
<i>2569</i>&nbsp;                        return dt;
<i>2570</i>&nbsp;                    case CONDEXPR:
<i>2571</i>&nbsp;                        return res == Type.recoveryType ?
<b class="nc"><i>2572</i>&nbsp;                                dt : res;</b>
<b class="nc"><i>2573</i>&nbsp;                }</b>
<i>2574</i>&nbsp;            }
<i>2575</i>&nbsp;            return res;
<i>2576</i>&nbsp;        }
<i>2577</i>&nbsp;    }
<i>2578</i>&nbsp;
<i>2579</i>&nbsp;    /** Check that sym is not an abstract method.
<i>2580</i>&nbsp;     */
<i>2581</i>&nbsp;    void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
<i>2582</i>&nbsp;        if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
<i>2583</i>&nbsp;            log.error(pos,
<i>2584</i>&nbsp;                      Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
<i>2585</i>&nbsp;    }
<i>2586</i>&nbsp;
<i>2587</i>&nbsp;/* ***************************************************************************
<i>2588</i>&nbsp; *  Name resolution
<i>2589</i>&nbsp; *  Naming conventions are as for symbol lookup
<i>2590</i>&nbsp; *  Unlike the find... methods these methods will report access errors
<b class="nc"><i>2591</i>&nbsp; ****************************************************************************/</b>
<b class="nc"><i>2592</i>&nbsp;</b>
<i>2593</i>&nbsp;    /** Resolve an unqualified (non-method) identifier.
<i>2594</i>&nbsp;     *  @param pos       The position to use for error reporting.
<b class="nc"><i>2595</i>&nbsp;     *  @param env       The environment current at the identifier use.</b>
<b class="nc"><i>2596</i>&nbsp;     *  @param name      The identifier&#39;s name.</b>
<b class="nc"><i>2597</i>&nbsp;     *  @param kind      The set of admissible symbol kinds for the identifier.</b>
<i>2598</i>&nbsp;     */
<i>2599</i>&nbsp;    Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
<i>2600</i>&nbsp;                        Name name, KindSelector kind) {
<b class="nc"><i>2601</i>&nbsp;        return accessBase(</b>
<b class="nc"><i>2602</i>&nbsp;            findIdent(env, name, kind),</b>
<b class="nc"><i>2603</i>&nbsp;            pos, env.enclClass.sym.type, name, false);</b>
<i>2604</i>&nbsp;    }
<b class="nc"><i>2605</i>&nbsp;</b>
<b class="nc"><i>2606</i>&nbsp;    /** Resolve an unqualified method identifier.</b>
<i>2607</i>&nbsp;     *  @param pos       The position to use for error reporting.
<b class="nc"><i>2608</i>&nbsp;     *  @param env       The environment current at the method invocation.</b>
<i>2609</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2610</i>&nbsp;     *  @param argtypes  The types of the invocation&#39;s value arguments.
<i>2611</i>&nbsp;     *  @param typeargtypes  The types of the invocation&#39;s type arguments.
<b class="nc"><i>2612</i>&nbsp;     */</b>
<i>2613</i>&nbsp;    Symbol resolveMethod(DiagnosticPosition pos,
<i>2614</i>&nbsp;                         Env&lt;AttrContext&gt; env,
<b class="nc"><i>2615</i>&nbsp;                         Name name,</b>
<b class="nc"><i>2616</i>&nbsp;                         List&lt;Type&gt; argtypes,</b>
<i>2617</i>&nbsp;                         List&lt;Type&gt; typeargtypes) {
<i>2618</i>&nbsp;        return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
<b class="nc"><i>2619</i>&nbsp;                new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {</b>
<b class="nc"><i>2620</i>&nbsp;                    @Override</b>
<i>2621</i>&nbsp;                    Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
<i>2622</i>&nbsp;                        return findFun(env, name, argtypes, typeargtypes,
<b class="nc"><i>2623</i>&nbsp;                                phase.isBoxingRequired(),</b>
<i>2624</i>&nbsp;                                phase.isVarargsRequired());
<i>2625</i>&nbsp;                    }});
<i>2626</i>&nbsp;    }
<i>2627</i>&nbsp;
<i>2628</i>&nbsp;    /** Resolve a qualified method identifier
<i>2629</i>&nbsp;     *  @param pos       The position to use for error reporting.
<i>2630</i>&nbsp;     *  @param env       The environment current at the method invocation.
<i>2631</i>&nbsp;     *  @param site      The type of the qualifying expression, in which
<i>2632</i>&nbsp;     *                   identifier is searched.
<i>2633</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2634</i>&nbsp;     *  @param argtypes  The types of the invocation&#39;s value arguments.
<i>2635</i>&nbsp;     *  @param typeargtypes  The types of the invocation&#39;s type arguments.
<i>2636</i>&nbsp;     */
<i>2637</i>&nbsp;    Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
<i>2638</i>&nbsp;                                  Type site, Name name, List&lt;Type&gt; argtypes,
<i>2639</i>&nbsp;                                  List&lt;Type&gt; typeargtypes) {
<i>2640</i>&nbsp;        return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
<b class="nc"><i>2641</i>&nbsp;    }</b>
<b class="nc"><i>2642</i>&nbsp;    Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>2643</i>&nbsp;                                  Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>2644</i>&nbsp;                                  List&lt;Type&gt; typeargtypes) {</b>
<b class="nc"><i>2645</i>&nbsp;        return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);</b>
<i>2646</i>&nbsp;    }
<b class="nc"><i>2647</i>&nbsp;    private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,</b>
<i>2648</i>&nbsp;                                  DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
<b class="nc"><i>2649</i>&nbsp;                                  Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,</b>
<i>2650</i>&nbsp;                                  List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>2651</i>&nbsp;        return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {</b>
<b class="nc"><i>2652</i>&nbsp;            @Override</b>
<b class="nc"><i>2653</i>&nbsp;            Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {</b>
<b class="nc"><i>2654</i>&nbsp;                return findMethod(env, site, name, argtypes, typeargtypes,</b>
<i>2655</i>&nbsp;                        phase.isBoxingRequired(),
<i>2656</i>&nbsp;                        phase.isVarargsRequired());
<b class="nc"><i>2657</i>&nbsp;            }</b>
<i>2658</i>&nbsp;            @Override
<i>2659</i>&nbsp;            Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
<b class="nc"><i>2660</i>&nbsp;                if (sym.kind.isResolutionError()) {</b>
<i>2661</i>&nbsp;                    sym = super.access(env, pos, location, sym);
<i>2662</i>&nbsp;                } else if (allowMethodHandles) {
<i>2663</i>&nbsp;                    MethodSymbol msym = (MethodSymbol)sym;
<i>2664</i>&nbsp;                    if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
<i>2665</i>&nbsp;                        env.info.pendingResolutionPhase = BASIC;
<i>2666</i>&nbsp;                        return findPolymorphicSignatureInstance(env, sym, argtypes);
<i>2667</i>&nbsp;                    }
<b class="nc"><i>2668</i>&nbsp;                }</b>
<i>2669</i>&nbsp;                return sym;
<i>2670</i>&nbsp;            }
<i>2671</i>&nbsp;        });
<i>2672</i>&nbsp;    }
<i>2673</i>&nbsp;
<i>2674</i>&nbsp;    /** Find or create an implicit method of exactly the given type (after erasure).
<i>2675</i>&nbsp;     *  Searches in a side table, not the main scope of the site.
<i>2676</i>&nbsp;     *  This emulates the lookup process required by JSR 292 in JVM.
<i>2677</i>&nbsp;     *  @param env       Attribution environment
<i>2678</i>&nbsp;     *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
<i>2679</i>&nbsp;     *  @param argtypes  The required argument types
<i>2680</i>&nbsp;     */
<b class="nc"><i>2681</i>&nbsp;    Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,</b>
<i>2682</i>&nbsp;                                            final Symbol spMethod,
<b class="nc"><i>2683</i>&nbsp;                                            List&lt;Type&gt; argtypes) {</b>
<b class="nc"><i>2684</i>&nbsp;        Type mtype = infer.instantiatePolymorphicSignatureInstance(env,</b>
<b class="nc"><i>2685</i>&nbsp;                (MethodSymbol)spMethod, currentResolutionContext, argtypes);</b>
<b class="nc"><i>2686</i>&nbsp;        return findPolymorphicSignatureInstance(spMethod, mtype);</b>
<i>2687</i>&nbsp;    }
<i>2688</i>&nbsp;
<b class="nc"><i>2689</i>&nbsp;    Symbol findPolymorphicSignatureInstance(final Symbol spMethod,</b>
<b class="nc"><i>2690</i>&nbsp;                                            Type mtype) {</b>
<b class="nc"><i>2691</i>&nbsp;        for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {</b>
<i>2692</i>&nbsp;            // Check that there is already a method symbol for the method
<i>2693</i>&nbsp;            // type and owner
<i>2694</i>&nbsp;            if (types.isSameType(mtype, sym.type) &amp;&amp;
<b class="nc"><i>2695</i>&nbsp;                spMethod.owner == sym.owner) {</b>
<i>2696</i>&nbsp;                return sym;
<i>2697</i>&nbsp;            }
<i>2698</i>&nbsp;        }
<i>2699</i>&nbsp;
<b class="nc"><i>2700</i>&nbsp;        // Create the desired method</b>
<i>2701</i>&nbsp;        // Retain static modifier is to support invocations to
<i>2702</i>&nbsp;        // MethodHandle.linkTo* methods
<i>2703</i>&nbsp;        long flags = ABSTRACT | HYPOTHETICAL |
<i>2704</i>&nbsp;                     spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
<i>2705</i>&nbsp;        Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
<i>2706</i>&nbsp;            @Override
<i>2707</i>&nbsp;            public Symbol baseSymbol() {
<i>2708</i>&nbsp;                return spMethod;
<i>2709</i>&nbsp;            }
<i>2710</i>&nbsp;        };
<b class="nc"><i>2711</i>&nbsp;        if (!mtype.isErroneous()) { // Cache only if kosher.</b>
<i>2712</i>&nbsp;            polymorphicSignatureScope.enter(msym);
<i>2713</i>&nbsp;        }
<i>2714</i>&nbsp;        return msym;
<i>2715</i>&nbsp;    }
<i>2716</i>&nbsp;
<i>2717</i>&nbsp;    /** Resolve a qualified method identifier, throw a fatal error if not
<i>2718</i>&nbsp;     *  found.
<i>2719</i>&nbsp;     *  @param pos       The position to use for error reporting.
<i>2720</i>&nbsp;     *  @param env       The environment current at the method invocation.
<i>2721</i>&nbsp;     *  @param site      The type of the qualifying expression, in which
<i>2722</i>&nbsp;     *                   identifier is searched.
<i>2723</i>&nbsp;     *  @param name      The identifier&#39;s name.
<i>2724</i>&nbsp;     *  @param argtypes  The types of the invocation&#39;s value arguments.
<i>2725</i>&nbsp;     *  @param typeargtypes  The types of the invocation&#39;s type arguments.
<b class="nc"><i>2726</i>&nbsp;     */</b>
<i>2727</i>&nbsp;    public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
<i>2728</i>&nbsp;                                        Type site, Name name,
<i>2729</i>&nbsp;                                        List&lt;Type&gt; argtypes,
<i>2730</i>&nbsp;                                        List&lt;Type&gt; typeargtypes) {
<i>2731</i>&nbsp;        MethodResolutionContext resolveContext = new MethodResolutionContext();
<i>2732</i>&nbsp;        resolveContext.internalResolution = true;
<i>2733</i>&nbsp;        Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
<i>2734</i>&nbsp;                site, name, argtypes, typeargtypes);
<b class="nc"><i>2735</i>&nbsp;        if (sym.kind == MTH) return (MethodSymbol)sym;</b>
<i>2736</i>&nbsp;        else throw new FatalError(
<b class="nc"><i>2737</i>&nbsp;                 diags.fragment(Fragments.FatalErrCantLocateMeth(name)));</b>
<b class="nc"><i>2738</i>&nbsp;    }</b>
<i>2739</i>&nbsp;
<b class="nc"><i>2740</i>&nbsp;    /** Resolve constructor.</b>
<b class="nc"><i>2741</i>&nbsp;     *  @param pos       The position to use for error reporting.</b>
<i>2742</i>&nbsp;     *  @param env       The environment current at the constructor invocation.
<i>2743</i>&nbsp;     *  @param site      The type of class for which a constructor is searched.
<b class="nc"><i>2744</i>&nbsp;     *  @param argtypes  The types of the constructor invocation&#39;s value</b>
<i>2745</i>&nbsp;     *                   arguments.
<b class="nc"><i>2746</i>&nbsp;     *  @param typeargtypes  The types of the constructor invocation&#39;s type</b>
<i>2747</i>&nbsp;     *                   arguments.
<i>2748</i>&nbsp;     */
<i>2749</i>&nbsp;    Symbol resolveConstructor(DiagnosticPosition pos,
<i>2750</i>&nbsp;                              Env&lt;AttrContext&gt; env,
<i>2751</i>&nbsp;                              Type site,
<i>2752</i>&nbsp;                              List&lt;Type&gt; argtypes,
<i>2753</i>&nbsp;                              List&lt;Type&gt; typeargtypes) {
<i>2754</i>&nbsp;        return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
<i>2755</i>&nbsp;    }
<b class="nc"><i>2756</i>&nbsp;</b>
<i>2757</i>&nbsp;    private Symbol resolveConstructor(MethodResolutionContext resolveContext,
<b class="nc"><i>2758</i>&nbsp;                              final DiagnosticPosition pos,</b>
<i>2759</i>&nbsp;                              Env&lt;AttrContext&gt; env,
<i>2760</i>&nbsp;                              Type site,
<b class="nc"><i>2761</i>&nbsp;                              List&lt;Type&gt; argtypes,</b>
<i>2762</i>&nbsp;                              List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>2763</i>&nbsp;        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {</b>
<i>2764</i>&nbsp;            @Override
<i>2765</i>&nbsp;            Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
<i>2766</i>&nbsp;                return findConstructor(pos, env, site, argtypes, typeargtypes,
<b class="nc"><i>2767</i>&nbsp;                        phase.isBoxingRequired(),</b>
<i>2768</i>&nbsp;                        phase.isVarargsRequired());
<i>2769</i>&nbsp;            }
<i>2770</i>&nbsp;        });
<b class="nc"><i>2771</i>&nbsp;    }</b>
<i>2772</i>&nbsp;
<i>2773</i>&nbsp;    /** Resolve a constructor, throw a fatal error if not found.
<i>2774</i>&nbsp;     *  @param pos       The position to use for error reporting.
<i>2775</i>&nbsp;     *  @param env       The environment current at the method invocation.
<i>2776</i>&nbsp;     *  @param site      The type to be constructed.
<i>2777</i>&nbsp;     *  @param argtypes  The types of the invocation&#39;s value arguments.
<i>2778</i>&nbsp;     *  @param typeargtypes  The types of the invocation&#39;s type arguments.
<i>2779</i>&nbsp;     */
<i>2780</i>&nbsp;    public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
<b class="nc"><i>2781</i>&nbsp;                                        Type site,</b>
<b class="nc"><i>2782</i>&nbsp;                                        List&lt;Type&gt; argtypes,</b>
<i>2783</i>&nbsp;                                        List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>2784</i>&nbsp;        MethodResolutionContext resolveContext = new MethodResolutionContext();</b>
<i>2785</i>&nbsp;        resolveContext.internalResolution = true;
<i>2786</i>&nbsp;        Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
<b class="nc"><i>2787</i>&nbsp;        if (sym.kind == MTH) return (MethodSymbol)sym;</b>
<b class="nc"><i>2788</i>&nbsp;        else throw new FatalError(</b>
<i>2789</i>&nbsp;                 diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
<b class="nc"><i>2790</i>&nbsp;    }</b>
<b class="nc"><i>2791</i>&nbsp;</b>
<b class="nc"><i>2792</i>&nbsp;    Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,</b>
<i>2793</i>&nbsp;                              Type site, List&lt;Type&gt; argtypes,
<b class="nc"><i>2794</i>&nbsp;                              List&lt;Type&gt; typeargtypes,</b>
<i>2795</i>&nbsp;                              boolean allowBoxing,
<i>2796</i>&nbsp;                              boolean useVarargs) {
<i>2797</i>&nbsp;        Symbol sym = findMethod(env, site,
<b class="nc"><i>2798</i>&nbsp;                                    names.init, argtypes,</b>
<b class="nc"><i>2799</i>&nbsp;                                    typeargtypes, allowBoxing,</b>
<b class="nc"><i>2800</i>&nbsp;                                    useVarargs);</b>
<b class="nc"><i>2801</i>&nbsp;        chk.checkDeprecated(pos, env.info.scope.owner, sym);</b>
<b class="nc"><i>2802</i>&nbsp;        return sym;</b>
<b class="nc"><i>2803</i>&nbsp;    }</b>
<i>2804</i>&nbsp;
<b class="nc"><i>2805</i>&nbsp;    /** Resolve constructor using diamond inference.</b>
<i>2806</i>&nbsp;     *  @param pos       The position to use for error reporting.
<b class="nc"><i>2807</i>&nbsp;     *  @param env       The environment current at the constructor invocation.</b>
<i>2808</i>&nbsp;     *  @param site      The type of class for which a constructor is searched.
<i>2809</i>&nbsp;     *                   The scope of this class has been touched in attribution.
<i>2810</i>&nbsp;     *  @param argtypes  The types of the constructor invocation&#39;s value
<i>2811</i>&nbsp;     *                   arguments.
<b class="nc"><i>2812</i>&nbsp;     *  @param typeargtypes  The types of the constructor invocation&#39;s type</b>
<b class="nc"><i>2813</i>&nbsp;     *                   arguments.</b>
<i>2814</i>&nbsp;     */
<i>2815</i>&nbsp;    Symbol resolveDiamond(DiagnosticPosition pos,
<i>2816</i>&nbsp;                              Env&lt;AttrContext&gt; env,
<b class="nc"><i>2817</i>&nbsp;                              Type site,</b>
<i>2818</i>&nbsp;                              List&lt;Type&gt; argtypes,
<i>2819</i>&nbsp;                              List&lt;Type&gt; typeargtypes) {
<i>2820</i>&nbsp;        return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
<i>2821</i>&nbsp;                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
<i>2822</i>&nbsp;                    @Override
<i>2823</i>&nbsp;                    Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
<i>2824</i>&nbsp;                        return findDiamond(env, site, argtypes, typeargtypes,
<i>2825</i>&nbsp;                                phase.isBoxingRequired(),
<i>2826</i>&nbsp;                                phase.isVarargsRequired());
<i>2827</i>&nbsp;                    }
<i>2828</i>&nbsp;                    @Override
<i>2829</i>&nbsp;                    Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
<i>2830</i>&nbsp;                        if (sym.kind.isResolutionError()) {
<i>2831</i>&nbsp;                            if (sym.kind != WRONG_MTH &amp;&amp;
<i>2832</i>&nbsp;                                sym.kind != WRONG_MTHS) {
<i>2833</i>&nbsp;                                sym = super.access(env, pos, location, sym);
<i>2834</i>&nbsp;                            } else {
<i>2835</i>&nbsp;                                final JCDiagnostic details = sym.kind == WRONG_MTH ?
<i>2836</i>&nbsp;                                                ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
<i>2837</i>&nbsp;                                                null;
<i>2838</i>&nbsp;                                sym = new DiamondError(sym, currentResolutionContext);
<i>2839</i>&nbsp;                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
<i>2840</i>&nbsp;                                env.info.pendingResolutionPhase = currentResolutionContext.step;
<i>2841</i>&nbsp;                            }
<i>2842</i>&nbsp;                        }
<i>2843</i>&nbsp;                        return sym;
<i>2844</i>&nbsp;                    }});
<i>2845</i>&nbsp;    }
<i>2846</i>&nbsp;
<i>2847</i>&nbsp;    /** This method scans all the constructor symbol in a given class scope -
<i>2848</i>&nbsp;     *  assuming that the original scope contains a constructor of the kind:
<i>2849</i>&nbsp;     *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
<i>2850</i>&nbsp;     *  a method check is executed against the modified constructor type:
<i>2851</i>&nbsp;     *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
<i>2852</i>&nbsp;     *  inference. The inferred return type of the synthetic constructor IS
<i>2853</i>&nbsp;     *  the inferred type for the diamond operator.
<i>2854</i>&nbsp;     */
<i>2855</i>&nbsp;    private Symbol findDiamond(Env&lt;AttrContext&gt; env,
<b class="nc"><i>2856</i>&nbsp;                              Type site,</b>
<b class="nc"><i>2857</i>&nbsp;                              List&lt;Type&gt; argtypes,</b>
<i>2858</i>&nbsp;                              List&lt;Type&gt; typeargtypes,
<i>2859</i>&nbsp;                              boolean allowBoxing,
<i>2860</i>&nbsp;                              boolean useVarargs) {
<b class="nc"><i>2861</i>&nbsp;        Symbol bestSoFar = methodNotFound;</b>
<i>2862</i>&nbsp;        TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
<b class="nc"><i>2863</i>&nbsp;        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {</b>
<b class="nc"><i>2864</i>&nbsp;            //- System.out.println(&quot; e &quot; + e.sym);</b>
<b class="nc"><i>2865</i>&nbsp;            if (sym.kind == MTH &amp;&amp;</b>
<b class="nc"><i>2866</i>&nbsp;                (sym.flags_field &amp; SYNTHETIC) == 0) {</b>
<i>2867</i>&nbsp;                    List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
<b class="nc"><i>2868</i>&nbsp;                            ((ForAll)sym.type).tvars :</b>
<b class="nc"><i>2869</i>&nbsp;                            List.nil();</b>
<b class="nc"><i>2870</i>&nbsp;                    Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),</b>
<b class="nc"><i>2871</i>&nbsp;                                                 types.createMethodTypeWithReturn(sym.type.asMethodType(), site));</b>
<b class="nc"><i>2872</i>&nbsp;                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {</b>
<b class="nc"><i>2873</i>&nbsp;                        @Override</b>
<b class="nc"><i>2874</i>&nbsp;                        public Symbol baseSymbol() {</b>
<b class="nc"><i>2875</i>&nbsp;                            return sym;</b>
<b class="nc"><i>2876</i>&nbsp;                        }</b>
<i>2877</i>&nbsp;                    };
<b class="nc"><i>2878</i>&nbsp;                    bestSoFar = selectBest(env, site, argtypes, typeargtypes,</b>
<i>2879</i>&nbsp;                            newConstr,
<b class="nc"><i>2880</i>&nbsp;                            bestSoFar,</b>
<b class="nc"><i>2881</i>&nbsp;                            allowBoxing,</b>
<b class="nc"><i>2882</i>&nbsp;                            useVarargs);</b>
<i>2883</i>&nbsp;            }
<i>2884</i>&nbsp;        }
<b class="nc"><i>2885</i>&nbsp;        return bestSoFar;</b>
<b class="nc"><i>2886</i>&nbsp;    }</b>
<i>2887</i>&nbsp;
<i>2888</i>&nbsp;    Symbol getMemberReference(DiagnosticPosition pos,
<i>2889</i>&nbsp;            Env&lt;AttrContext&gt; env,
<i>2890</i>&nbsp;            JCMemberReference referenceTree,
<i>2891</i>&nbsp;            Type site,
<b class="nc"><i>2892</i>&nbsp;            Name name) {</b>
<b class="nc"><i>2893</i>&nbsp;</b>
<b class="nc"><i>2894</i>&nbsp;        site = types.capture(site);</b>
<b class="nc"><i>2895</i>&nbsp;</b>
<b class="nc"><i>2896</i>&nbsp;        ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(</b>
<b class="nc"><i>2897</i>&nbsp;                referenceTree, site, name, List.nil(), null, VARARITY);</b>
<b class="nc"><i>2898</i>&nbsp;</b>
<b class="nc"><i>2899</i>&nbsp;        Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());</b>
<b class="nc"><i>2900</i>&nbsp;        Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,</b>
<i>2901</i>&nbsp;                nilMethodCheck, lookupHelper);
<b class="nc"><i>2902</i>&nbsp;</b>
<b class="nc"><i>2903</i>&nbsp;        env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;</b>
<i>2904</i>&nbsp;
<i>2905</i>&nbsp;        return sym;
<b class="nc"><i>2906</i>&nbsp;    }</b>
<b class="nc"><i>2907</i>&nbsp;</b>
<b class="nc"><i>2908</i>&nbsp;    ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,</b>
<b class="nc"><i>2909</i>&nbsp;                                  Type site,</b>
<b class="nc"><i>2910</i>&nbsp;                                  Name name,</b>
<i>2911</i>&nbsp;                                  List&lt;Type&gt; argtypes,
<b class="nc"><i>2912</i>&nbsp;                                  List&lt;Type&gt; typeargtypes,</b>
<i>2913</i>&nbsp;                                  MethodResolutionPhase maxPhase) {
<b class="nc"><i>2914</i>&nbsp;        if (!name.equals(names.init)) {</b>
<b class="nc"><i>2915</i>&nbsp;            //method reference</b>
<b class="nc"><i>2916</i>&nbsp;            return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);</b>
<i>2917</i>&nbsp;        } else if (site.hasTag(ARRAY)) {
<i>2918</i>&nbsp;            //array constructor reference
<b class="nc"><i>2919</i>&nbsp;            return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);</b>
<b class="nc"><i>2920</i>&nbsp;        } else {</b>
<i>2921</i>&nbsp;            //class constructor reference
<i>2922</i>&nbsp;            return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
<i>2923</i>&nbsp;        }
<i>2924</i>&nbsp;    }
<i>2925</i>&nbsp;
<i>2926</i>&nbsp;    /**
<i>2927</i>&nbsp;     * Resolution of member references is typically done as a single
<b class="nc"><i>2928</i>&nbsp;     * overload resolution step, where the argument types A are inferred from</b>
<b class="nc"><i>2929</i>&nbsp;     * the target functional descriptor.</b>
<b class="nc"><i>2930</i>&nbsp;     *</b>
<b class="nc"><i>2931</i>&nbsp;     * If the member reference is a method reference with a type qualifier,</b>
<i>2932</i>&nbsp;     * a two-step lookup process is performed. The first step uses the
<b class="nc"><i>2933</i>&nbsp;     * expected argument list A, while the second step discards the first</b>
<b class="nc"><i>2934</i>&nbsp;     * type from A (which is treated as a receiver type).</b>
<i>2935</i>&nbsp;     *
<b class="nc"><i>2936</i>&nbsp;     * There are two cases in which inference is performed: (i) if the member</b>
<i>2937</i>&nbsp;     * reference is a constructor reference and the qualifier type is raw - in
<b class="nc"><i>2938</i>&nbsp;     * which case diamond inference is used to infer a parameterization for the</b>
<b class="nc"><i>2939</i>&nbsp;     * type qualifier; (ii) if the member reference is an unbound reference</b>
<b class="nc"><i>2940</i>&nbsp;     * where the type qualifier is raw - in that case, during the unbound lookup</b>
<b class="nc"><i>2941</i>&nbsp;     * the receiver argument type is used to infer an instantiation for the raw</b>
<b class="nc"><i>2942</i>&nbsp;     * qualifier type.</b>
<b class="nc"><i>2943</i>&nbsp;     *</b>
<b class="nc"><i>2944</i>&nbsp;     * When a multi-step resolution process is exploited, the process of picking</b>
<i>2945</i>&nbsp;     * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
<i>2946</i>&nbsp;     *
<b class="nc"><i>2947</i>&nbsp;     * This routine returns a pair (T,S), where S is the member reference symbol,</b>
<b class="nc"><i>2948</i>&nbsp;     * and T is the type of the class in which S is defined. This is necessary as</b>
<b class="nc"><i>2949</i>&nbsp;     * the type T might be dynamically inferred (i.e. if constructor reference</b>
<i>2950</i>&nbsp;     * has a raw qualifier).
<i>2951</i>&nbsp;     */
<b class="nc"><i>2952</i>&nbsp;    Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>2953</i>&nbsp;                                  JCMemberReference referenceTree,</b>
<b class="nc"><i>2954</i>&nbsp;                                  Type site,</b>
<b class="nc"><i>2955</i>&nbsp;                                  Name name,</b>
<i>2956</i>&nbsp;                                  List&lt;Type&gt; argtypes,
<b class="nc"><i>2957</i>&nbsp;                                  List&lt;Type&gt; typeargtypes,</b>
<i>2958</i>&nbsp;                                  Type descriptor,
<b class="nc"><i>2959</i>&nbsp;                                  MethodCheck methodCheck,</b>
<i>2960</i>&nbsp;                                  InferenceContext inferenceContext,
<i>2961</i>&nbsp;                                  ReferenceChooser referenceChooser) {
<i>2962</i>&nbsp;
<b class="nc"><i>2963</i>&nbsp;        //step 1 - bound lookup</b>
<i>2964</i>&nbsp;        ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
<i>2965</i>&nbsp;                referenceTree, site, name, argtypes, typeargtypes, VARARITY);
<b class="nc"><i>2966</i>&nbsp;        Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());</b>
<b class="nc"><i>2967</i>&nbsp;        MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();</b>
<b class="nc"><i>2968</i>&nbsp;        boundSearchResolveContext.methodCheck = methodCheck;</b>
<b class="nc"><i>2969</i>&nbsp;        Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),</b>
<b class="nc"><i>2970</i>&nbsp;                site.tsym, boundSearchResolveContext, boundLookupHelper);</b>
<i>2971</i>&nbsp;        ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
<i>2972</i>&nbsp;
<i>2973</i>&nbsp;        //step 2 - unbound lookup
<i>2974</i>&nbsp;        Symbol unboundSym = methodNotFound;
<b class="nc"><i>2975</i>&nbsp;        Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());</b>
<b class="nc"><i>2976</i>&nbsp;        ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);</b>
<b class="nc"><i>2977</i>&nbsp;        ReferenceLookupResult unboundRes = referenceNotFound;</b>
<i>2978</i>&nbsp;        if (unboundLookupHelper != null) {
<b class="nc"><i>2979</i>&nbsp;            MethodResolutionContext unboundSearchResolveContext =</b>
<i>2980</i>&nbsp;                    new MethodResolutionContext();
<b class="nc"><i>2981</i>&nbsp;            unboundSearchResolveContext.methodCheck = methodCheck;</b>
<b class="nc"><i>2982</i>&nbsp;            unboundSym = lookupMethod(unboundEnv, env.tree.pos(),</b>
<i>2983</i>&nbsp;                    site.tsym, unboundSearchResolveContext, unboundLookupHelper);
<i>2984</i>&nbsp;            unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
<b class="nc"><i>2985</i>&nbsp;        }</b>
<b class="nc"><i>2986</i>&nbsp;</b>
<i>2987</i>&nbsp;        //merge results
<i>2988</i>&nbsp;        Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
<i>2989</i>&nbsp;        ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
<i>2990</i>&nbsp;        res = new Pair&lt;&gt;(bestRes.sym,
<b class="nc"><i>2991</i>&nbsp;                bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);</b>
<b class="nc"><i>2992</i>&nbsp;        env.info.pendingResolutionPhase = bestRes == unboundRes ?</b>
<b class="nc"><i>2993</i>&nbsp;                unboundEnv.info.pendingResolutionPhase :</b>
<b class="nc"><i>2994</i>&nbsp;                boundEnv.info.pendingResolutionPhase;</b>
<b class="nc"><i>2995</i>&nbsp;</b>
<b class="nc"><i>2996</i>&nbsp;        if (!res.fst.kind.isResolutionError()) {</b>
<b class="nc"><i>2997</i>&nbsp;            //handle sigpoly method references</b>
<b class="nc"><i>2998</i>&nbsp;            MethodSymbol msym = (MethodSymbol)res.fst;</b>
<i>2999</i>&nbsp;            if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
<b class="nc"><i>3000</i>&nbsp;                env.info.pendingResolutionPhase = BASIC;</b>
<i>3001</i>&nbsp;                res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
<i>3002</i>&nbsp;            }
<i>3003</i>&nbsp;        }
<i>3004</i>&nbsp;
<b class="nc"><i>3005</i>&nbsp;        return res;</b>
<i>3006</i>&nbsp;    }
<i>3007</i>&nbsp;
<i>3008</i>&nbsp;    /**
<b class="nc"><i>3009</i>&nbsp;     * This class is used to represent a method reference lookup result. It keeps track of two</b>
<i>3010</i>&nbsp;     * things: (i) the symbol found during a method reference lookup and (ii) the static kind
<b class="nc"><i>3011</i>&nbsp;     * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).</b>
<i>3012</i>&nbsp;     */
<b class="nc"><i>3013</i>&nbsp;    static class ReferenceLookupResult {</b>
<b class="nc"><i>3014</i>&nbsp;</b>
<b class="nc"><i>3015</i>&nbsp;        /**</b>
<b class="nc"><i>3016</i>&nbsp;         * Static kind associated with a method reference lookup. Erroneous lookups end up with</b>
<i>3017</i>&nbsp;         * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
<b class="nc"><i>3018</i>&nbsp;         * depending on whether all applicable candidates are static or non-static methods,</b>
<b class="nc"><i>3019</i>&nbsp;         * respectively. If a successful lookup has both static and non-static applicable methods,</b>
<b class="nc"><i>3020</i>&nbsp;         * its kind is set to BOTH.</b>
<i>3021</i>&nbsp;         */
<b class="nc"><i>3022</i>&nbsp;        enum StaticKind {</b>
<i>3023</i>&nbsp;            STATIC,
<b class="nc"><i>3024</i>&nbsp;            NON_STATIC,</b>
<i>3025</i>&nbsp;            BOTH,
<i>3026</i>&nbsp;            UNDEFINED;
<i>3027</i>&nbsp;
<i>3028</i>&nbsp;            /**
<i>3029</i>&nbsp;             * Retrieve the static kind associated with a given (method) symbol.
<i>3030</i>&nbsp;             */
<i>3031</i>&nbsp;            static StaticKind from(Symbol s) {
<i>3032</i>&nbsp;                return s.isStatic() ?
<i>3033</i>&nbsp;                        STATIC : NON_STATIC;
<i>3034</i>&nbsp;            }
<i>3035</i>&nbsp;
<i>3036</i>&nbsp;            /**
<i>3037</i>&nbsp;             * Merge two static kinds together.
<i>3038</i>&nbsp;             */
<i>3039</i>&nbsp;            static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
<i>3040</i>&nbsp;                if (sk1 == UNDEFINED) {
<i>3041</i>&nbsp;                    return sk2;
<i>3042</i>&nbsp;                } else if (sk2 == UNDEFINED) {
<i>3043</i>&nbsp;                    return sk1;
<i>3044</i>&nbsp;                } else {
<i>3045</i>&nbsp;                    return sk1 == sk2 ? sk1 : BOTH;
<i>3046</i>&nbsp;                }
<i>3047</i>&nbsp;            }
<i>3048</i>&nbsp;        }
<i>3049</i>&nbsp;
<b class="nc"><i>3050</i>&nbsp;        /** The static kind. */</b>
<b class="nc"><i>3051</i>&nbsp;        StaticKind staticKind;</b>
<b class="nc"><i>3052</i>&nbsp;</b>
<b class="nc"><i>3053</i>&nbsp;        /** The lookup result. */</b>
<b class="nc"><i>3054</i>&nbsp;        Symbol sym;</b>
<b class="nc"><i>3055</i>&nbsp;</b>
<i>3056</i>&nbsp;        ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
<i>3057</i>&nbsp;            this(sym, staticKind(sym, resolutionContext));
<i>3058</i>&nbsp;        }
<i>3059</i>&nbsp;
<i>3060</i>&nbsp;        private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
<i>3061</i>&nbsp;            this.staticKind = staticKind;
<b class="nc"><i>3062</i>&nbsp;            this.sym = sym;</b>
<i>3063</i>&nbsp;        }
<i>3064</i>&nbsp;
<i>3065</i>&nbsp;        private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
<i>3066</i>&nbsp;            switch (sym.kind) {
<i>3067</i>&nbsp;                case MTH:
<i>3068</i>&nbsp;                case AMBIGUOUS:
<i>3069</i>&nbsp;                    return resolutionContext.candidates.stream()
<i>3070</i>&nbsp;                            .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
<i>3071</i>&nbsp;                            .map(c -&gt; StaticKind.from(c.sym))
<i>3072</i>&nbsp;                            .reduce(StaticKind::reduce)
<i>3073</i>&nbsp;                            .orElse(StaticKind.UNDEFINED);
<i>3074</i>&nbsp;                default:
<i>3075</i>&nbsp;                    return StaticKind.UNDEFINED;
<i>3076</i>&nbsp;            }
<i>3077</i>&nbsp;        }
<i>3078</i>&nbsp;
<i>3079</i>&nbsp;        /**
<i>3080</i>&nbsp;         * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
<i>3081</i>&nbsp;         */
<i>3082</i>&nbsp;        boolean isSuccess() {
<i>3083</i>&nbsp;            return staticKind != StaticKind.UNDEFINED;
<i>3084</i>&nbsp;        }
<i>3085</i>&nbsp;
<i>3086</i>&nbsp;        /**
<i>3087</i>&nbsp;         * Does this result have given static kind?
<b class="nc"><i>3088</i>&nbsp;         */</b>
<i>3089</i>&nbsp;        boolean hasKind(StaticKind sk) {
<i>3090</i>&nbsp;            return this.staticKind == sk;
<b class="nc"><i>3091</i>&nbsp;        }</b>
<b class="nc"><i>3092</i>&nbsp;</b>
<i>3093</i>&nbsp;        /**
<i>3094</i>&nbsp;         * Error recovery helper: can this lookup result be ignored (for the purpose of returning
<i>3095</i>&nbsp;         * some &#39;better&#39; result) ?
<i>3096</i>&nbsp;         */
<b class="nc"><i>3097</i>&nbsp;        boolean canIgnore() {</b>
<b class="nc"><i>3098</i>&nbsp;            switch (sym.kind) {</b>
<b class="nc"><i>3099</i>&nbsp;                case ABSENT_MTH:</b>
<b class="nc"><i>3100</i>&nbsp;                    return true;</b>
<i>3101</i>&nbsp;                case WRONG_MTH:
<b class="nc"><i>3102</i>&nbsp;                    InapplicableSymbolError errSym =</b>
<i>3103</i>&nbsp;                            (InapplicableSymbolError)sym.baseSymbol();
<i>3104</i>&nbsp;                    return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
<i>3105</i>&nbsp;                            .matches(errSym.errCandidate().snd);
<i>3106</i>&nbsp;                case WRONG_MTHS:
<i>3107</i>&nbsp;                    InapplicableSymbolsError errSyms =
<i>3108</i>&nbsp;                            (InapplicableSymbolsError)sym.baseSymbol();
<b class="nc"><i>3109</i>&nbsp;                    return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();</b>
<i>3110</i>&nbsp;                default:
<b class="nc"><i>3111</i>&nbsp;                    return false;</b>
<i>3112</i>&nbsp;            }
<b class="nc"><i>3113</i>&nbsp;        }</b>
<i>3114</i>&nbsp;
<i>3115</i>&nbsp;        static ReferenceLookupResult error(Symbol sym) {
<i>3116</i>&nbsp;            return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
<i>3117</i>&nbsp;        }
<b class="nc"><i>3118</i>&nbsp;    }</b>
<i>3119</i>&nbsp;
<i>3120</i>&nbsp;    /**
<i>3121</i>&nbsp;     * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
<i>3122</i>&nbsp;     * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
<i>3123</i>&nbsp;     * result of method reference resolution.
<i>3124</i>&nbsp;     */
<i>3125</i>&nbsp;    abstract class ReferenceChooser {
<i>3126</i>&nbsp;        /**
<i>3127</i>&nbsp;         * Generate a result from a pair of lookup result objects. This method delegates to the
<i>3128</i>&nbsp;         * appropriate result generation routine.
<i>3129</i>&nbsp;         */
<i>3130</i>&nbsp;        ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
<i>3131</i>&nbsp;            return unboundRes != referenceNotFound ?
<i>3132</i>&nbsp;                    unboundResult(boundRes, unboundRes) :
<i>3133</i>&nbsp;                    boundResult(boundRes);
<b class="nc"><i>3134</i>&nbsp;        }</b>
<b class="nc"><i>3135</i>&nbsp;</b>
<b class="nc"><i>3136</i>&nbsp;        /**</b>
<i>3137</i>&nbsp;         * Generate a symbol from a given bound lookup result.
<i>3138</i>&nbsp;         */
<i>3139</i>&nbsp;        abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
<i>3140</i>&nbsp;
<i>3141</i>&nbsp;        /**
<i>3142</i>&nbsp;         * Generate a symbol from a pair of bound/unbound lookup results.
<i>3143</i>&nbsp;         */
<i>3144</i>&nbsp;        abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
<b class="nc"><i>3145</i>&nbsp;    }</b>
<i>3146</i>&nbsp;
<i>3147</i>&nbsp;    /**
<b class="nc"><i>3148</i>&nbsp;     * This chooser implements the selection strategy used during a full lookup; this logic</b>
<i>3149</i>&nbsp;     * is described in JLS SE 8 (15.3.2).
<i>3150</i>&nbsp;     */
<i>3151</i>&nbsp;    ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
<b class="nc"><i>3152</i>&nbsp;</b>
<i>3153</i>&nbsp;        @Override
<i>3154</i>&nbsp;        ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
<i>3155</i>&nbsp;            return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
<b class="nc"><i>3156</i>&nbsp;                    boundRes : //the search produces a non-static method</b>
<b class="nc"><i>3157</i>&nbsp;                    ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));</b>
<i>3158</i>&nbsp;        }
<i>3159</i>&nbsp;
<i>3160</i>&nbsp;        @Override
<i>3161</i>&nbsp;        ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
<i>3162</i>&nbsp;            if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
<i>3163</i>&nbsp;                    (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
<i>3164</i>&nbsp;                //the first search produces a static method and no non-static method is applicable
<i>3165</i>&nbsp;                //during the second search
<i>3166</i>&nbsp;                return boundRes;
<i>3167</i>&nbsp;            } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
<b class="nc"><i>3168</i>&nbsp;                    (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {</b>
<b class="nc"><i>3169</i>&nbsp;                //the second search produces a non-static method and no static method is applicable</b>
<b class="nc"><i>3170</i>&nbsp;                //during the first search</b>
<i>3171</i>&nbsp;                return unboundRes;
<i>3172</i>&nbsp;            } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
<b class="nc"><i>3173</i>&nbsp;                //both searches produce some result; ambiguity (error recovery)</b>
<i>3174</i>&nbsp;                return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
<i>3175</i>&nbsp;            } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
<i>3176</i>&nbsp;                //Both searches failed to produce a result with correct staticness (i.e. first search
<i>3177</i>&nbsp;                //produces an non-static method). Alternatively, a given search produced a result
<i>3178</i>&nbsp;                //with the right staticness, but the other search has applicable methods with wrong
<i>3179</i>&nbsp;                //staticness (error recovery)
<i>3180</i>&nbsp;                return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
<i>3181</i>&nbsp;                        boundRes.sym : unboundRes.sym, true));
<i>3182</i>&nbsp;            } else {
<i>3183</i>&nbsp;                //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
<i>3184</i>&nbsp;                return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
<i>3185</i>&nbsp;                        unboundRes : boundRes;
<b class="nc"><i>3186</i>&nbsp;            }</b>
<b class="nc"><i>3187</i>&nbsp;        }</b>
<i>3188</i>&nbsp;    };
<i>3189</i>&nbsp;
<i>3190</i>&nbsp;    /**
<i>3191</i>&nbsp;     * This chooser implements the selection strategy used during an arity-based lookup; this logic
<b class="nc"><i>3192</i>&nbsp;     * is described in JLS SE 8 (15.12.2.1).</b>
<b class="nc"><i>3193</i>&nbsp;     */</b>
<i>3194</i>&nbsp;    ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
<i>3195</i>&nbsp;
<i>3196</i>&nbsp;        @Override
<i>3197</i>&nbsp;        ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
<b class="nc"><i>3198</i>&nbsp;            return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?</b>
<b class="nc"><i>3199</i>&nbsp;                    boundRes : //the search has at least one applicable non-static method</b>
<b class="nc"><i>3200</i>&nbsp;                    ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));</b>
<b class="nc"><i>3201</i>&nbsp;        }</b>
<b class="nc"><i>3202</i>&nbsp;</b>
<i>3203</i>&nbsp;        @Override
<i>3204</i>&nbsp;        ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
<b class="nc"><i>3205</i>&nbsp;            if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {</b>
<i>3206</i>&nbsp;                //the first serach has at least one applicable static method
<i>3207</i>&nbsp;                return boundRes;
<i>3208</i>&nbsp;            } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
<i>3209</i>&nbsp;                //the second search has at least one applicable non-static method
<i>3210</i>&nbsp;                return unboundRes;
<b class="nc"><i>3211</i>&nbsp;            } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {</b>
<b class="nc"><i>3212</i>&nbsp;                //either the first search produces a non-static method, or second search produces</b>
<i>3213</i>&nbsp;                //a non-static method (error recovery)
<b class="nc"><i>3214</i>&nbsp;                return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?</b>
<b class="nc"><i>3215</i>&nbsp;                        boundRes.sym : unboundRes.sym, true));</b>
<i>3216</i>&nbsp;            } else {
<i>3217</i>&nbsp;                //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
<i>3218</i>&nbsp;                return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
<i>3219</i>&nbsp;                        unboundRes : boundRes;
<i>3220</i>&nbsp;            }
<i>3221</i>&nbsp;        }
<i>3222</i>&nbsp;    };
<i>3223</i>&nbsp;
<i>3224</i>&nbsp;    /**
<i>3225</i>&nbsp;     * Helper for defining custom method-like lookup logic; a lookup helper
<i>3226</i>&nbsp;     * provides hooks for (i) the actual lookup logic and (ii) accessing the
<i>3227</i>&nbsp;     * lookup result (this step might result in compiler diagnostics to be generated)
<i>3228</i>&nbsp;     */
<i>3229</i>&nbsp;    abstract class LookupHelper {
<i>3230</i>&nbsp;
<i>3231</i>&nbsp;        /** name of the symbol to lookup */
<b class="nc"><i>3232</i>&nbsp;        Name name;</b>
<b class="nc"><i>3233</i>&nbsp;</b>
<b class="nc"><i>3234</i>&nbsp;        /** location in which the lookup takes place */</b>
<b class="nc"><i>3235</i>&nbsp;        Type site;</b>
<b class="nc"><i>3236</i>&nbsp;</b>
<i>3237</i>&nbsp;        /** actual types used during the lookup */
<i>3238</i>&nbsp;        List&lt;Type&gt; argtypes;
<i>3239</i>&nbsp;
<i>3240</i>&nbsp;        /** type arguments used during the lookup */
<i>3241</i>&nbsp;        List&lt;Type&gt; typeargtypes;
<b class="nc"><i>3242</i>&nbsp;</b>
<i>3243</i>&nbsp;        /** Max overload resolution phase handled by this helper */
<i>3244</i>&nbsp;        MethodResolutionPhase maxPhase;
<i>3245</i>&nbsp;
<i>3246</i>&nbsp;        LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
<b class="nc"><i>3247</i>&nbsp;            this.name = name;</b>
<i>3248</i>&nbsp;            this.site = site;
<i>3249</i>&nbsp;            this.argtypes = argtypes;
<i>3250</i>&nbsp;            this.typeargtypes = typeargtypes;
<i>3251</i>&nbsp;            this.maxPhase = maxPhase;
<i>3252</i>&nbsp;        }
<i>3253</i>&nbsp;
<i>3254</i>&nbsp;        /**
<i>3255</i>&nbsp;         * Should lookup stop at given phase with given result
<i>3256</i>&nbsp;         */
<i>3257</i>&nbsp;        final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
<i>3258</i>&nbsp;            return phase.ordinal() &gt; maxPhase.ordinal() ||
<b class="nc"><i>3259</i>&nbsp;                !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;</b>
<b class="nc"><i>3260</i>&nbsp;        }</b>
<i>3261</i>&nbsp;
<i>3262</i>&nbsp;        /**
<i>3263</i>&nbsp;         * Search for a symbol under a given overload resolution phase - this method
<i>3264</i>&nbsp;         * is usually called several times, once per each overload resolution phase
<b class="nc"><i>3265</i>&nbsp;         */</b>
<b class="nc"><i>3266</i>&nbsp;        abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);</b>
<b class="nc"><i>3267</i>&nbsp;</b>
<b class="nc"><i>3268</i>&nbsp;        /**</b>
<b class="nc"><i>3269</i>&nbsp;         * Dump overload resolution info</b>
<i>3270</i>&nbsp;         */
<i>3271</i>&nbsp;        void debug(DiagnosticPosition pos, Symbol sym) {
<i>3272</i>&nbsp;            //do nothing
<i>3273</i>&nbsp;        }
<b class="nc"><i>3274</i>&nbsp;</b>
<i>3275</i>&nbsp;        /**
<i>3276</i>&nbsp;         * Validate the result of the lookup
<i>3277</i>&nbsp;         */
<i>3278</i>&nbsp;        abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
<i>3279</i>&nbsp;    }
<i>3280</i>&nbsp;
<i>3281</i>&nbsp;    abstract class BasicLookupHelper extends LookupHelper {
<i>3282</i>&nbsp;
<i>3283</i>&nbsp;        BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>3284</i>&nbsp;            this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
<i>3285</i>&nbsp;        }
<i>3286</i>&nbsp;
<i>3287</i>&nbsp;        BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
<i>3288</i>&nbsp;            super(name, site, argtypes, typeargtypes, maxPhase);
<i>3289</i>&nbsp;        }
<i>3290</i>&nbsp;
<b class="nc"><i>3291</i>&nbsp;        @Override</b>
<b class="nc"><i>3292</i>&nbsp;        final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {</b>
<b class="nc"><i>3293</i>&nbsp;            Symbol sym = doLookup(env, phase);</b>
<b class="nc"><i>3294</i>&nbsp;            if (sym.kind == AMBIGUOUS) {</b>
<b class="nc"><i>3295</i>&nbsp;                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();</b>
<i>3296</i>&nbsp;                sym = a_err.mergeAbstracts(site);
<i>3297</i>&nbsp;            }
<i>3298</i>&nbsp;            return sym;
<i>3299</i>&nbsp;        }
<i>3300</i>&nbsp;
<b class="nc"><i>3301</i>&nbsp;        abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);</b>
<b class="nc"><i>3302</i>&nbsp;</b>
<b class="nc"><i>3303</i>&nbsp;        @Override</b>
<b class="nc"><i>3304</i>&nbsp;        Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {</b>
<b class="nc"><i>3305</i>&nbsp;            if (sym.kind.isResolutionError()) {</b>
<b class="nc"><i>3306</i>&nbsp;                //if nothing is found return the &#39;first&#39; error</b>
<b class="nc"><i>3307</i>&nbsp;                sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);</b>
<b class="nc"><i>3308</i>&nbsp;            }</b>
<i>3309</i>&nbsp;            return sym;
<i>3310</i>&nbsp;        }
<b class="nc"><i>3311</i>&nbsp;</b>
<b class="nc"><i>3312</i>&nbsp;        @Override</b>
<i>3313</i>&nbsp;        void debug(DiagnosticPosition pos, Symbol sym) {
<i>3314</i>&nbsp;            reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
<i>3315</i>&nbsp;        }
<i>3316</i>&nbsp;    }
<i>3317</i>&nbsp;
<i>3318</i>&nbsp;    /**
<b class="nc"><i>3319</i>&nbsp;     * Helper class for member reference lookup. A reference lookup helper</b>
<i>3320</i>&nbsp;     * defines the basic logic for member reference lookup; a method gives
<i>3321</i>&nbsp;     * access to an &#39;unbound&#39; helper used to perform an unbound member
<i>3322</i>&nbsp;     * reference lookup.
<i>3323</i>&nbsp;     */
<i>3324</i>&nbsp;    abstract class ReferenceLookupHelper extends LookupHelper {
<i>3325</i>&nbsp;
<i>3326</i>&nbsp;        /** The member reference tree */
<i>3327</i>&nbsp;        JCMemberReference referenceTree;
<i>3328</i>&nbsp;
<i>3329</i>&nbsp;        ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
<i>3330</i>&nbsp;                List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
<b class="nc"><i>3331</i>&nbsp;            super(name, site, argtypes, typeargtypes, maxPhase);</b>
<b class="nc"><i>3332</i>&nbsp;            this.referenceTree = referenceTree;</b>
<b class="nc"><i>3333</i>&nbsp;        }</b>
<i>3334</i>&nbsp;
<i>3335</i>&nbsp;        /**
<i>3336</i>&nbsp;         * Returns an unbound version of this lookup helper. By default, this
<i>3337</i>&nbsp;         * method returns an dummy lookup helper.
<b class="nc"><i>3338</i>&nbsp;         */</b>
<i>3339</i>&nbsp;        ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
<b class="nc"><i>3340</i>&nbsp;            return null;</b>
<b class="nc"><i>3341</i>&nbsp;        }</b>
<b class="nc"><i>3342</i>&nbsp;</b>
<b class="nc"><i>3343</i>&nbsp;        /**</b>
<b class="nc"><i>3344</i>&nbsp;         * Get the kind of the member reference</b>
<b class="nc"><i>3345</i>&nbsp;         */</b>
<b class="nc"><i>3346</i>&nbsp;        abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);</b>
<b class="nc"><i>3347</i>&nbsp;</b>
<b class="nc"><i>3348</i>&nbsp;        Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {</b>
<b class="nc"><i>3349</i>&nbsp;            if (sym.kind == AMBIGUOUS) {</b>
<b class="nc"><i>3350</i>&nbsp;                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();</b>
<b class="nc"><i>3351</i>&nbsp;                sym = a_err.mergeAbstracts(site);</b>
<b class="nc"><i>3352</i>&nbsp;            }</b>
<b class="nc"><i>3353</i>&nbsp;            //skip error reporting</b>
<i>3354</i>&nbsp;            return sym;
<b class="nc"><i>3355</i>&nbsp;        }</b>
<i>3356</i>&nbsp;    }
<i>3357</i>&nbsp;
<i>3358</i>&nbsp;    /**
<i>3359</i>&nbsp;     * Helper class for method reference lookup. The lookup logic is based
<i>3360</i>&nbsp;     * upon Resolve.findMethod; in certain cases, this helper class has a
<i>3361</i>&nbsp;     * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
<i>3362</i>&nbsp;     * In such cases, non-static lookup results are thrown away.
<i>3363</i>&nbsp;     */
<i>3364</i>&nbsp;    class MethodReferenceLookupHelper extends ReferenceLookupHelper {
<i>3365</i>&nbsp;
<i>3366</i>&nbsp;        /** The original method reference lookup site. */
<i>3367</i>&nbsp;        Type originalSite;
<i>3368</i>&nbsp;
<i>3369</i>&nbsp;        MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
<b class="nc"><i>3370</i>&nbsp;                List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {</b>
<b class="nc"><i>3371</i>&nbsp;            super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);</b>
<b class="nc"><i>3372</i>&nbsp;            this.originalSite = site;</b>
<b class="nc"><i>3373</i>&nbsp;        }</b>
<b class="nc"><i>3374</i>&nbsp;</b>
<b class="nc"><i>3375</i>&nbsp;        @Override</b>
<b class="nc"><i>3376</i>&nbsp;        final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {</b>
<b class="nc"><i>3377</i>&nbsp;            return findMethod(env, site, name, argtypes, typeargtypes,</b>
<b class="nc"><i>3378</i>&nbsp;                    phase.isBoxingRequired(), phase.isVarargsRequired());</b>
<i>3379</i>&nbsp;        }
<i>3380</i>&nbsp;
<i>3381</i>&nbsp;        @Override
<b class="nc"><i>3382</i>&nbsp;        ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {</b>
<b class="nc"><i>3383</i>&nbsp;            if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {</b>
<i>3384</i>&nbsp;                if (argtypes.nonEmpty() &amp;&amp;
<b class="nc"><i>3385</i>&nbsp;                        (argtypes.head.hasTag(NONE) ||</b>
<b class="nc"><i>3386</i>&nbsp;                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {</b>
<b class="nc"><i>3387</i>&nbsp;                    return new UnboundMethodReferenceLookupHelper(referenceTree, name,</b>
<i>3388</i>&nbsp;                            originalSite, argtypes, typeargtypes, maxPhase);
<b class="nc"><i>3389</i>&nbsp;                } else {</b>
<b class="nc"><i>3390</i>&nbsp;                    return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {</b>
<b class="nc"><i>3391</i>&nbsp;                        @Override</b>
<b class="nc"><i>3392</i>&nbsp;                        ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {</b>
<b class="nc"><i>3393</i>&nbsp;                            return this;</b>
<i>3394</i>&nbsp;                        }
<b class="nc"><i>3395</i>&nbsp;</b>
<i>3396</i>&nbsp;                        @Override
<b class="nc"><i>3397</i>&nbsp;                        Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {</b>
<b class="nc"><i>3398</i>&nbsp;                            return methodNotFound;</b>
<b class="nc"><i>3399</i>&nbsp;                        }</b>
<b class="nc"><i>3400</i>&nbsp;</b>
<b class="nc"><i>3401</i>&nbsp;                        @Override</b>
<i>3402</i>&nbsp;                        ReferenceKind referenceKind(Symbol sym) {
<b class="nc"><i>3403</i>&nbsp;                            Assert.error();</b>
<b class="nc"><i>3404</i>&nbsp;                            return null;</b>
<i>3405</i>&nbsp;                        }
<b class="nc"><i>3406</i>&nbsp;                    };</b>
<b class="nc"><i>3407</i>&nbsp;                }</b>
<i>3408</i>&nbsp;            } else {
<i>3409</i>&nbsp;                return super.unboundLookup(inferenceContext);
<i>3410</i>&nbsp;            }
<b class="nc"><i>3411</i>&nbsp;        }</b>
<b class="nc"><i>3412</i>&nbsp;</b>
<b class="nc"><i>3413</i>&nbsp;        @Override</b>
<b class="nc"><i>3414</i>&nbsp;        ReferenceKind referenceKind(Symbol sym) {</b>
<b class="nc"><i>3415</i>&nbsp;            if (sym.isStatic()) {</b>
<b class="nc"><i>3416</i>&nbsp;                return ReferenceKind.STATIC;</b>
<i>3417</i>&nbsp;            } else {
<b class="nc"><i>3418</i>&nbsp;                Name selName = TreeInfo.name(referenceTree.getQualifierExpression());</b>
<b class="nc"><i>3419</i>&nbsp;                return selName != null &amp;&amp; selName == names._super ?</b>
<b class="nc"><i>3420</i>&nbsp;                        ReferenceKind.SUPER :</b>
<i>3421</i>&nbsp;                        ReferenceKind.BOUND;
<b class="nc"><i>3422</i>&nbsp;            }</b>
<b class="nc"><i>3423</i>&nbsp;        }</b>
<i>3424</i>&nbsp;    }
<i>3425</i>&nbsp;
<i>3426</i>&nbsp;    /**
<i>3427</i>&nbsp;     * Helper class for unbound method reference lookup. Essentially the same
<i>3428</i>&nbsp;     * as the basic method reference lookup helper; main difference is that static
<i>3429</i>&nbsp;     * lookup results are thrown away. If qualifier type is raw, an attempt to
<i>3430</i>&nbsp;     * infer a parameterized type is made using the first actual argument (that
<i>3431</i>&nbsp;     * would otherwise be ignored during the lookup).
<i>3432</i>&nbsp;     */
<i>3433</i>&nbsp;    class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
<i>3434</i>&nbsp;
<i>3435</i>&nbsp;        UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
<i>3436</i>&nbsp;                List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
<i>3437</i>&nbsp;            super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
<b class="nc"><i>3438</i>&nbsp;            if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {</b>
<b class="nc"><i>3439</i>&nbsp;                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);</b>
<b class="nc"><i>3440</i>&nbsp;                this.site = types.skipTypeVars(asSuperSite, true);</b>
<b class="nc"><i>3441</i>&nbsp;            }</b>
<i>3442</i>&nbsp;        }
<b class="nc"><i>3443</i>&nbsp;</b>
<i>3444</i>&nbsp;        @Override
<i>3445</i>&nbsp;        ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
<i>3446</i>&nbsp;            return this;
<i>3447</i>&nbsp;        }
<b class="nc"><i>3448</i>&nbsp;</b>
<b class="nc"><i>3449</i>&nbsp;        @Override</b>
<i>3450</i>&nbsp;        ReferenceKind referenceKind(Symbol sym) {
<i>3451</i>&nbsp;            return ReferenceKind.UNBOUND;
<i>3452</i>&nbsp;        }
<i>3453</i>&nbsp;    }
<i>3454</i>&nbsp;
<b class="nc"><i>3455</i>&nbsp;    /**</b>
<b class="nc"><i>3456</i>&nbsp;     * Helper class for array constructor lookup; an array constructor lookup</b>
<b class="nc"><i>3457</i>&nbsp;     * is simulated by looking up a method that returns the array type specified</b>
<b class="nc"><i>3458</i>&nbsp;     * as qualifier, and that accepts a single int parameter (size of the array).</b>
<b class="nc"><i>3459</i>&nbsp;     */</b>
<b class="nc"><i>3460</i>&nbsp;    class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {</b>
<b class="nc"><i>3461</i>&nbsp;</b>
<b class="nc"><i>3462</i>&nbsp;        ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>3463</i>&nbsp;                List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {</b>
<b class="nc"><i>3464</i>&nbsp;            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);</b>
<b class="nc"><i>3465</i>&nbsp;        }</b>
<i>3466</i>&nbsp;
<i>3467</i>&nbsp;        @Override
<b class="nc"><i>3468</i>&nbsp;        protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {</b>
<b class="nc"><i>3469</i>&nbsp;            WriteableScope sc = WriteableScope.create(syms.arrayClass);</b>
<b class="nc"><i>3470</i>&nbsp;            MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);</b>
<i>3471</i>&nbsp;            arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
<i>3472</i>&nbsp;            sc.enter(arrayConstr);
<b class="nc"><i>3473</i>&nbsp;            return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);</b>
<i>3474</i>&nbsp;        }
<i>3475</i>&nbsp;
<i>3476</i>&nbsp;        @Override
<i>3477</i>&nbsp;        ReferenceKind referenceKind(Symbol sym) {
<i>3478</i>&nbsp;            return ReferenceKind.ARRAY_CTOR;
<i>3479</i>&nbsp;        }
<i>3480</i>&nbsp;    }
<b class="nc"><i>3481</i>&nbsp;</b>
<i>3482</i>&nbsp;    /**
<i>3483</i>&nbsp;     * Helper class for constructor reference lookup. The lookup logic is based
<i>3484</i>&nbsp;     * upon either Resolve.findMethod or Resolve.findDiamond - depending on
<b class="nc"><i>3485</i>&nbsp;     * whether the constructor reference needs diamond inference (this is the case</b>
<b class="nc"><i>3486</i>&nbsp;     * if the qualifier type is raw). A special erroneous symbol is returned</b>
<b class="nc"><i>3487</i>&nbsp;     * if the lookup returns the constructor of an inner class and there&#39;s no</b>
<b class="nc"><i>3488</i>&nbsp;     * enclosing instance in scope.</b>
<b class="nc"><i>3489</i>&nbsp;     */</b>
<b class="nc"><i>3490</i>&nbsp;    class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {</b>
<i>3491</i>&nbsp;
<i>3492</i>&nbsp;        boolean needsInference;
<i>3493</i>&nbsp;
<i>3494</i>&nbsp;        ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
<i>3495</i>&nbsp;                List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
<i>3496</i>&nbsp;            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
<i>3497</i>&nbsp;            if (site.isRaw()) {
<i>3498</i>&nbsp;                this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
<b class="nc"><i>3499</i>&nbsp;                needsInference = true;</b>
<b class="nc"><i>3500</i>&nbsp;            }</b>
<i>3501</i>&nbsp;        }
<i>3502</i>&nbsp;
<i>3503</i>&nbsp;        @Override
<i>3504</i>&nbsp;        protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
<i>3505</i>&nbsp;            Symbol sym = needsInference ?
<i>3506</i>&nbsp;                findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
<i>3507</i>&nbsp;                findMethod(env, site, name, argtypes, typeargtypes,
<i>3508</i>&nbsp;                        phase.isBoxingRequired(), phase.isVarargsRequired());
<i>3509</i>&nbsp;            return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
<b class="nc"><i>3510</i>&nbsp;        }</b>
<i>3511</i>&nbsp;
<b class="nc"><i>3512</i>&nbsp;        @Override</b>
<b class="nc"><i>3513</i>&nbsp;        ReferenceKind referenceKind(Symbol sym) {</b>
<b class="nc"><i>3514</i>&nbsp;            return site.getEnclosingType().hasTag(NONE) ?</b>
<i>3515</i>&nbsp;                    ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
<i>3516</i>&nbsp;        }
<i>3517</i>&nbsp;    }
<b class="nc"><i>3518</i>&nbsp;</b>
<i>3519</i>&nbsp;    /**
<i>3520</i>&nbsp;     * Main overload resolution routine. On each overload resolution step, a
<b class="nc"><i>3521</i>&nbsp;     * lookup helper class is used to perform the method/constructor lookup;</b>
<b class="nc"><i>3522</i>&nbsp;     * at the end of the lookup, the helper is used to validate the results</b>
<i>3523</i>&nbsp;     * (this last step might trigger overload resolution diagnostics).
<b class="nc"><i>3524</i>&nbsp;     */</b>
<b class="nc"><i>3525</i>&nbsp;    Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {</b>
<b class="nc"><i>3526</i>&nbsp;        MethodResolutionContext resolveContext = new MethodResolutionContext();</b>
<b class="nc"><i>3527</i>&nbsp;        resolveContext.methodCheck = methodCheck;</b>
<i>3528</i>&nbsp;        return lookupMethod(env, pos, location, resolveContext, lookupHelper);
<b class="nc"><i>3529</i>&nbsp;    }</b>
<i>3530</i>&nbsp;
<b class="nc"><i>3531</i>&nbsp;    Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,</b>
<b class="nc"><i>3532</i>&nbsp;            MethodResolutionContext resolveContext, LookupHelper lookupHelper) {</b>
<i>3533</i>&nbsp;        MethodResolutionContext prevResolutionContext = currentResolutionContext;
<i>3534</i>&nbsp;        try {
<i>3535</i>&nbsp;            Symbol bestSoFar = methodNotFound;
<i>3536</i>&nbsp;            currentResolutionContext = resolveContext;
<i>3537</i>&nbsp;            for (MethodResolutionPhase phase : methodResolutionSteps) {
<i>3538</i>&nbsp;                if (lookupHelper.shouldStop(bestSoFar, phase))
<i>3539</i>&nbsp;                    break;
<i>3540</i>&nbsp;                MethodResolutionPhase prevPhase = currentResolutionContext.step;
<i>3541</i>&nbsp;                Symbol prevBest = bestSoFar;
<i>3542</i>&nbsp;                currentResolutionContext.step = phase;
<i>3543</i>&nbsp;                Symbol sym = lookupHelper.lookup(env, phase);
<i>3544</i>&nbsp;                lookupHelper.debug(pos, sym);
<i>3545</i>&nbsp;                bestSoFar = phase.mergeResults(bestSoFar, sym);
<b class="nc"><i>3546</i>&nbsp;                env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;</b>
<b class="nc"><i>3547</i>&nbsp;            }</b>
<b class="nc"><i>3548</i>&nbsp;            return lookupHelper.access(env, pos, location, bestSoFar);</b>
<i>3549</i>&nbsp;        } finally {
<i>3550</i>&nbsp;            currentResolutionContext = prevResolutionContext;
<i>3551</i>&nbsp;        }
<i>3552</i>&nbsp;    }
<b class="nc"><i>3553</i>&nbsp;</b>
<i>3554</i>&nbsp;    /**
<i>3555</i>&nbsp;     * Resolve `c.name&#39; where name == this or name == super.
<i>3556</i>&nbsp;     * @param pos           The position to use for error reporting.
<i>3557</i>&nbsp;     * @param env           The environment current at the expression.
<b class="nc"><i>3558</i>&nbsp;     * @param c             The qualifier.</b>
<i>3559</i>&nbsp;     * @param name          The identifier&#39;s name.
<i>3560</i>&nbsp;     */
<i>3561</i>&nbsp;    Symbol resolveSelf(DiagnosticPosition pos,
<i>3562</i>&nbsp;                       Env&lt;AttrContext&gt; env,
<b class="nc"><i>3563</i>&nbsp;                       TypeSymbol c,</b>
<i>3564</i>&nbsp;                       Name name) {
<i>3565</i>&nbsp;        Env&lt;AttrContext&gt; env1 = env;
<i>3566</i>&nbsp;        boolean staticOnly = false;
<i>3567</i>&nbsp;        while (env1.outer != null) {
<b class="nc"><i>3568</i>&nbsp;            if (isStatic(env1)) staticOnly = true;</b>
<i>3569</i>&nbsp;            if (env1.enclClass.sym == c) {
<i>3570</i>&nbsp;                Symbol sym = env1.info.scope.findFirst(name);
<i>3571</i>&nbsp;                if (sym != null) {
<i>3572</i>&nbsp;                    if (staticOnly) sym = new StaticError(sym);
<i>3573</i>&nbsp;                    return accessBase(sym, pos, env.enclClass.sym.type,
<i>3574</i>&nbsp;                                  name, true);
<i>3575</i>&nbsp;                }
<i>3576</i>&nbsp;            }
<i>3577</i>&nbsp;            if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
<i>3578</i>&nbsp;            env1 = env1.outer;
<i>3579</i>&nbsp;        }
<i>3580</i>&nbsp;        if (c.isInterface() &amp;&amp;
<b class="nc"><i>3581</i>&nbsp;            name == names._super &amp;&amp; !isStatic(env) &amp;&amp;</b>
<i>3582</i>&nbsp;            types.isDirectSuperInterface(c, env.enclClass.sym)) {
<i>3583</i>&nbsp;            //this might be a default super call if one of the superinterfaces is &#39;c&#39;
<i>3584</i>&nbsp;            for (Type t : pruneInterfaces(env.enclClass.type)) {
<i>3585</i>&nbsp;                if (t.tsym == c) {
<i>3586</i>&nbsp;                    env.info.defaultSuperCallSite = t;
<i>3587</i>&nbsp;                    return new VarSymbol(0, names._super,
<i>3588</i>&nbsp;                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);
<i>3589</i>&nbsp;                }
<i>3590</i>&nbsp;            }
<i>3591</i>&nbsp;            //find a direct super type that is a subtype of &#39;c&#39;
<i>3592</i>&nbsp;            for (Type i : types.directSupertypes(env.enclClass.type)) {
<i>3593</i>&nbsp;                if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
<i>3594</i>&nbsp;                    log.error(pos,
<i>3595</i>&nbsp;                              Errors.IllegalDefaultSuperCall(c,
<i>3596</i>&nbsp;                                                             Fragments.RedundantSupertype(c, i)));
<i>3597</i>&nbsp;                    return syms.errSymbol;
<i>3598</i>&nbsp;                }
<i>3599</i>&nbsp;            }
<i>3600</i>&nbsp;            Assert.error();
<i>3601</i>&nbsp;        }
<i>3602</i>&nbsp;        log.error(pos, Errors.NotEnclClass(c));
<i>3603</i>&nbsp;        return syms.errSymbol;
<i>3604</i>&nbsp;    }
<i>3605</i>&nbsp;    //where
<i>3606</i>&nbsp;    private List&lt;Type&gt; pruneInterfaces(Type t) {
<i>3607</i>&nbsp;        ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
<i>3608</i>&nbsp;        for (Type t1 : types.interfaces(t)) {
<i>3609</i>&nbsp;            boolean shouldAdd = true;
<i>3610</i>&nbsp;            for (Type t2 : types.directSupertypes(t)) {
<i>3611</i>&nbsp;                if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
<i>3612</i>&nbsp;                    shouldAdd = false;
<i>3613</i>&nbsp;                }
<b class="nc"><i>3614</i>&nbsp;            }</b>
<b class="nc"><i>3615</i>&nbsp;            if (shouldAdd) {</b>
<b class="nc"><i>3616</i>&nbsp;                result.append(t1);</b>
<i>3617</i>&nbsp;            }
<i>3618</i>&nbsp;        }
<i>3619</i>&nbsp;        return result.toList();
<i>3620</i>&nbsp;    }
<b class="nc"><i>3621</i>&nbsp;</b>
<i>3622</i>&nbsp;
<i>3623</i>&nbsp;    /**
<i>3624</i>&nbsp;     * Resolve `c.this&#39; for an enclosing class c that contains the
<i>3625</i>&nbsp;     * named member.
<b class="nc"><i>3626</i>&nbsp;     * @param pos           The position to use for error reporting.</b>
<i>3627</i>&nbsp;     * @param env           The environment current at the expression.
<i>3628</i>&nbsp;     * @param member        The member that must be contained in the result.
<i>3629</i>&nbsp;     */
<i>3630</i>&nbsp;    Symbol resolveSelfContaining(DiagnosticPosition pos,
<b class="nc"><i>3631</i>&nbsp;                                 Env&lt;AttrContext&gt; env,</b>
<b class="nc"><i>3632</i>&nbsp;                                 Symbol member,</b>
<i>3633</i>&nbsp;                                 boolean isSuperCall) {
<b class="nc"><i>3634</i>&nbsp;        Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);</b>
<i>3635</i>&nbsp;        if (sym == null) {
<i>3636</i>&nbsp;            log.error(pos, Errors.EnclClassRequired(member));
<i>3637</i>&nbsp;            return syms.errSymbol;
<i>3638</i>&nbsp;        } else {
<i>3639</i>&nbsp;            return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
<i>3640</i>&nbsp;        }
<i>3641</i>&nbsp;    }
<i>3642</i>&nbsp;
<i>3643</i>&nbsp;    boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
<i>3644</i>&nbsp;        if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
<b class="nc"><i>3645</i>&nbsp;            Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);</b>
<i>3646</i>&nbsp;            return encl == null || encl.kind.isResolutionError();
<i>3647</i>&nbsp;        }
<b class="nc"><i>3648</i>&nbsp;        return false;</b>
<b class="nc"><i>3649</i>&nbsp;    }</b>
<i>3650</i>&nbsp;
<i>3651</i>&nbsp;    private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
<i>3652</i>&nbsp;                                 Symbol member,
<i>3653</i>&nbsp;                                 boolean isSuperCall) {
<i>3654</i>&nbsp;        Name name = names._this;
<i>3655</i>&nbsp;        Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
<i>3656</i>&nbsp;        boolean staticOnly = false;
<i>3657</i>&nbsp;        if (env1 != null) {
<i>3658</i>&nbsp;            while (env1 != null &amp;&amp; env1.outer != null) {
<i>3659</i>&nbsp;                if (isStatic(env1)) staticOnly = true;
<b class="nc"><i>3660</i>&nbsp;                if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {</b>
<b class="nc"><i>3661</i>&nbsp;                    Symbol sym = env1.info.scope.findFirst(name);</b>
<b class="nc"><i>3662</i>&nbsp;                    if (sym != null) {</b>
<b class="nc"><i>3663</i>&nbsp;                        if (staticOnly) sym = new StaticError(sym);</b>
<i>3664</i>&nbsp;                        return sym;
<b class="nc"><i>3665</i>&nbsp;                    }</b>
<b class="nc"><i>3666</i>&nbsp;                }</b>
<b class="nc"><i>3667</i>&nbsp;                if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)</b>
<i>3668</i>&nbsp;                    staticOnly = true;
<i>3669</i>&nbsp;                env1 = env1.outer;
<b class="nc"><i>3670</i>&nbsp;            }</b>
<b class="nc"><i>3671</i>&nbsp;        }</b>
<b class="nc"><i>3672</i>&nbsp;        return null;</b>
<i>3673</i>&nbsp;    }
<i>3674</i>&nbsp;
<b class="nc"><i>3675</i>&nbsp;    /**</b>
<b class="nc"><i>3676</i>&nbsp;     * Resolve an appropriate implicit this instance for t&#39;s container.</b>
<b class="nc"><i>3677</i>&nbsp;     * JLS 8.8.5.1 and 15.9.2</b>
<i>3678</i>&nbsp;     */
<b class="nc"><i>3679</i>&nbsp;    Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {</b>
<b class="nc"><i>3680</i>&nbsp;        return resolveImplicitThis(pos, env, t, false);</b>
<b class="nc"><i>3681</i>&nbsp;    }</b>
<i>3682</i>&nbsp;
<i>3683</i>&nbsp;    Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
<b class="nc"><i>3684</i>&nbsp;        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)</b>
<b class="nc"><i>3685</i>&nbsp;                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)</b>
<i>3686</i>&nbsp;                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
<b class="nc"><i>3687</i>&nbsp;        if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {</b>
<i>3688</i>&nbsp;            log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
<b class="nc"><i>3689</i>&nbsp;        }</b>
<b class="nc"><i>3690</i>&nbsp;        return thisType;</b>
<b class="nc"><i>3691</i>&nbsp;    }</b>
<b class="nc"><i>3692</i>&nbsp;</b>
<b class="nc"><i>3693</i>&nbsp;/* ***************************************************************************</b>
<i>3694</i>&nbsp; *  ResolveError classes, indicating error situations when accessing symbols
<b class="nc"><i>3695</i>&nbsp; ****************************************************************************/</b>
<b class="nc"><i>3696</i>&nbsp;</b>
<i>3697</i>&nbsp;    //used by TransTypes when checking target type of synthetic cast
<i>3698</i>&nbsp;    public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
<b class="nc"><i>3699</i>&nbsp;        AccessError error = new AccessError(env, env.enclClass.type, type.tsym);</b>
<i>3700</i>&nbsp;        logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
<b class="nc"><i>3701</i>&nbsp;    }</b>
<i>3702</i>&nbsp;    //where
<i>3703</i>&nbsp;    private void logResolveError(ResolveError error,
<i>3704</i>&nbsp;            DiagnosticPosition pos,
<i>3705</i>&nbsp;            Symbol location,
<b class="nc"><i>3706</i>&nbsp;            Type site,</b>
<i>3707</i>&nbsp;            Name name,
<i>3708</i>&nbsp;            List&lt;Type&gt; argtypes,
<i>3709</i>&nbsp;            List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>3710</i>&nbsp;        JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,</b>
<b class="nc"><i>3711</i>&nbsp;                pos, location, site, name, argtypes, typeargtypes);</b>
<b class="nc"><i>3712</i>&nbsp;        if (d != null) {</b>
<i>3713</i>&nbsp;            d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
<i>3714</i>&nbsp;            log.report(d);
<b class="nc"><i>3715</i>&nbsp;        }</b>
<b class="nc"><i>3716</i>&nbsp;    }</b>
<i>3717</i>&nbsp;
<i>3718</i>&nbsp;    private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
<b class="nc"><i>3719</i>&nbsp;</b>
<i>3720</i>&nbsp;    public Object methodArguments(List&lt;Type&gt; argtypes) {
<i>3721</i>&nbsp;        if (argtypes == null || argtypes.isEmpty()) {
<b class="nc"><i>3722</i>&nbsp;            return noArgs;</b>
<b class="nc"><i>3723</i>&nbsp;        } else {</b>
<b class="nc"><i>3724</i>&nbsp;            ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();</b>
<i>3725</i>&nbsp;            for (Type t : argtypes) {
<i>3726</i>&nbsp;                if (t.hasTag(DEFERRED)) {
<i>3727</i>&nbsp;                    diagArgs.append(((DeferredAttr.DeferredType)t).tree);
<b class="nc"><i>3728</i>&nbsp;                } else {</b>
<b class="nc"><i>3729</i>&nbsp;                    diagArgs.append(t);</b>
<i>3730</i>&nbsp;                }
<i>3731</i>&nbsp;            }
<i>3732</i>&nbsp;            return diagArgs;
<i>3733</i>&nbsp;        }
<i>3734</i>&nbsp;    }
<i>3735</i>&nbsp;
<i>3736</i>&nbsp;    /**
<i>3737</i>&nbsp;     * Root class for resolution errors. Subclass of ResolveError
<i>3738</i>&nbsp;     * represent a different kinds of resolution error - as such they must
<i>3739</i>&nbsp;     * specify how they map into concrete compiler diagnostics.
<i>3740</i>&nbsp;     */
<i>3741</i>&nbsp;    abstract class ResolveError extends Symbol {
<i>3742</i>&nbsp;
<i>3743</i>&nbsp;        /** The name of the kind of error, for debugging only. */
<i>3744</i>&nbsp;        final String debugName;
<i>3745</i>&nbsp;
<b class="nc"><i>3746</i>&nbsp;        ResolveError(Kind kind, String debugName) {</b>
<i>3747</i>&nbsp;            super(kind, 0, null, null, null);
<i>3748</i>&nbsp;            this.debugName = debugName;
<b class="nc"><i>3749</i>&nbsp;        }</b>
<b class="nc"><i>3750</i>&nbsp;</b>
<b class="nc"><i>3751</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)</b>
<i>3752</i>&nbsp;        public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
<i>3753</i>&nbsp;            throw new AssertionError();
<i>3754</i>&nbsp;        }
<i>3755</i>&nbsp;
<b class="nc"><i>3756</i>&nbsp;        @Override</b>
<i>3757</i>&nbsp;        public String toString() {
<i>3758</i>&nbsp;            return debugName;
<i>3759</i>&nbsp;        }
<i>3760</i>&nbsp;
<b class="nc"><i>3761</i>&nbsp;        @Override</b>
<i>3762</i>&nbsp;        public boolean exists() {
<i>3763</i>&nbsp;            return false;
<i>3764</i>&nbsp;        }
<i>3765</i>&nbsp;
<i>3766</i>&nbsp;        @Override
<i>3767</i>&nbsp;        public boolean isStatic() {
<i>3768</i>&nbsp;            return false;
<i>3769</i>&nbsp;        }
<i>3770</i>&nbsp;
<i>3771</i>&nbsp;        /**
<b class="nc"><i>3772</i>&nbsp;         * Create an external representation for this erroneous symbol to be</b>
<b class="nc"><i>3773</i>&nbsp;         * used during attribution - by default this returns the symbol of a</b>
<i>3774</i>&nbsp;         * brand new error type which stores the original type found
<b class="nc"><i>3775</i>&nbsp;         * during resolution.</b>
<b class="nc"><i>3776</i>&nbsp;         *</b>
<b class="nc"><i>3777</i>&nbsp;         * @param name     the name used during resolution</b>
<i>3778</i>&nbsp;         * @param location the location from which the symbol is accessed
<i>3779</i>&nbsp;         */
<b class="nc"><i>3780</i>&nbsp;        protected Symbol access(Name name, TypeSymbol location) {</b>
<b class="nc"><i>3781</i>&nbsp;            return types.createErrorType(name, location, syms.errSymbol.type).tsym;</b>
<b class="nc"><i>3782</i>&nbsp;        }</b>
<i>3783</i>&nbsp;
<i>3784</i>&nbsp;        /**
<i>3785</i>&nbsp;         * Create a diagnostic representing this resolution error.
<b class="nc"><i>3786</i>&nbsp;         *</b>
<b class="nc"><i>3787</i>&nbsp;         * @param dkind     The kind of the diagnostic to be created (e.g error).</b>
<i>3788</i>&nbsp;         * @param pos       The position to be used for error reporting.
<b class="nc"><i>3789</i>&nbsp;         * @param site      The original type from where the selection took place.</b>
<b class="nc"><i>3790</i>&nbsp;         * @param name      The name of the symbol to be resolved.</b>
<b class="nc"><i>3791</i>&nbsp;         * @param argtypes  The invocation&#39;s value arguments,</b>
<b class="nc"><i>3792</i>&nbsp;         *                  if we looked for a method.</b>
<b class="nc"><i>3793</i>&nbsp;         * @param typeargtypes  The invocation&#39;s type arguments,</b>
<b class="nc"><i>3794</i>&nbsp;         *                      if we looked for a method.</b>
<b class="nc"><i>3795</i>&nbsp;         */</b>
<i>3796</i>&nbsp;        abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
<b class="nc"><i>3797</i>&nbsp;                DiagnosticPosition pos,</b>
<i>3798</i>&nbsp;                Symbol location,
<b class="nc"><i>3799</i>&nbsp;                Type site,</b>
<b class="nc"><i>3800</i>&nbsp;                Name name,</b>
<i>3801</i>&nbsp;                List&lt;Type&gt; argtypes,
<b class="nc"><i>3802</i>&nbsp;                List&lt;Type&gt; typeargtypes);</b>
<i>3803</i>&nbsp;    }
<b class="nc"><i>3804</i>&nbsp;</b>
<b class="nc"><i>3805</i>&nbsp;    /**</b>
<b class="nc"><i>3806</i>&nbsp;     * This class is the root class of all resolution errors caused by</b>
<i>3807</i>&nbsp;     * an invalid symbol being found during resolution.
<i>3808</i>&nbsp;     */
<i>3809</i>&nbsp;    abstract class InvalidSymbolError extends ResolveError {
<i>3810</i>&nbsp;
<i>3811</i>&nbsp;        /** The invalid symbol found during resolution */
<i>3812</i>&nbsp;        Symbol sym;
<i>3813</i>&nbsp;
<b class="nc"><i>3814</i>&nbsp;        InvalidSymbolError(Kind kind, Symbol sym, String debugName) {</b>
<i>3815</i>&nbsp;            super(kind, debugName);
<i>3816</i>&nbsp;            this.sym = sym;
<i>3817</i>&nbsp;        }
<b class="nc"><i>3818</i>&nbsp;</b>
<b class="nc"><i>3819</i>&nbsp;        @Override</b>
<b class="nc"><i>3820</i>&nbsp;        public boolean exists() {</b>
<b class="nc"><i>3821</i>&nbsp;            return true;</b>
<b class="nc"><i>3822</i>&nbsp;        }</b>
<b class="nc"><i>3823</i>&nbsp;</b>
<b class="nc"><i>3824</i>&nbsp;        @Override</b>
<i>3825</i>&nbsp;        public String toString() {
<i>3826</i>&nbsp;             return super.toString() + &quot; wrongSym=&quot; + sym;
<i>3827</i>&nbsp;        }
<i>3828</i>&nbsp;
<i>3829</i>&nbsp;        @Override
<i>3830</i>&nbsp;        public Symbol access(Name name, TypeSymbol location) {
<i>3831</i>&nbsp;            if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
<i>3832</i>&nbsp;                return types.createErrorType(name, location, sym.type).tsym;
<b class="nc"><i>3833</i>&nbsp;            else</b>
<i>3834</i>&nbsp;                return sym;
<b class="nc"><i>3835</i>&nbsp;        }</b>
<b class="nc"><i>3836</i>&nbsp;    }</b>
<i>3837</i>&nbsp;
<i>3838</i>&nbsp;    class BadVarTypeError extends ResolveError {
<i>3839</i>&nbsp;        BadVarTypeError() {
<i>3840</i>&nbsp;            super(Kind.BAD_VAR, &quot;bad var use&quot;);
<i>3841</i>&nbsp;        }
<i>3842</i>&nbsp;
<i>3843</i>&nbsp;        @Override
<i>3844</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>3845</i>&nbsp;            return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.var.type&quot;);
<i>3846</i>&nbsp;        }
<b class="nc"><i>3847</i>&nbsp;    }</b>
<b class="nc"><i>3848</i>&nbsp;</b>
<b class="nc"><i>3849</i>&nbsp;    /**</b>
<b class="nc"><i>3850</i>&nbsp;     * InvalidSymbolError error class indicating that a symbol matching a</b>
<b class="nc"><i>3851</i>&nbsp;     * given name does not exists in a given site.</b>
<b class="nc"><i>3852</i>&nbsp;     */</b>
<i>3853</i>&nbsp;    class SymbolNotFoundError extends ResolveError {
<b class="nc"><i>3854</i>&nbsp;</b>
<b class="nc"><i>3855</i>&nbsp;        SymbolNotFoundError(Kind kind) {</b>
<b class="nc"><i>3856</i>&nbsp;            this(kind, &quot;symbol not found error&quot;);</b>
<i>3857</i>&nbsp;        }
<i>3858</i>&nbsp;
<b class="nc"><i>3859</i>&nbsp;        SymbolNotFoundError(Kind kind, String debugName) {</b>
<b class="nc"><i>3860</i>&nbsp;            super(kind, debugName);</b>
<b class="nc"><i>3861</i>&nbsp;        }</b>
<i>3862</i>&nbsp;
<i>3863</i>&nbsp;        @Override
<b class="nc"><i>3864</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,</b>
<i>3865</i>&nbsp;                DiagnosticPosition pos,
<b class="nc"><i>3866</i>&nbsp;                Symbol location,</b>
<b class="nc"><i>3867</i>&nbsp;                Type site,</b>
<b class="nc"><i>3868</i>&nbsp;                Name name,</b>
<b class="nc"><i>3869</i>&nbsp;                List&lt;Type&gt; argtypes,</b>
<b class="nc"><i>3870</i>&nbsp;                List&lt;Type&gt; typeargtypes) {</b>
<b class="nc"><i>3871</i>&nbsp;            argtypes = argtypes == null ? List.nil() : argtypes;</b>
<b class="nc"><i>3872</i>&nbsp;            typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;</b>
<i>3873</i>&nbsp;            if (name == names.error)
<i>3874</i>&nbsp;                return null;
<b class="nc"><i>3875</i>&nbsp;</b>
<i>3876</i>&nbsp;            boolean hasLocation = false;
<b class="nc"><i>3877</i>&nbsp;            if (location == null) {</b>
<i>3878</i>&nbsp;                location = site.tsym;
<b class="nc"><i>3879</i>&nbsp;            }</b>
<b class="nc"><i>3880</i>&nbsp;            if (!location.name.isEmpty()) {</b>
<i>3881</i>&nbsp;                if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
<b class="nc"><i>3882</i>&nbsp;                    return diags.create(dkind, log.currentSource(), pos,</b>
<i>3883</i>&nbsp;                        &quot;doesnt.exist&quot;, location);
<b class="nc"><i>3884</i>&nbsp;                }</b>
<i>3885</i>&nbsp;                hasLocation = !location.name.equals(names._this) &amp;&amp;
<i>3886</i>&nbsp;                        !location.name.equals(names._super);
<i>3887</i>&nbsp;            }
<i>3888</i>&nbsp;            boolean isConstructor = name == names.init;
<i>3889</i>&nbsp;            KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
<b class="nc"><i>3890</i>&nbsp;            Name idname = isConstructor ? site.tsym.name : name;</b>
<b class="nc"><i>3891</i>&nbsp;            String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);</b>
<b class="nc"><i>3892</i>&nbsp;            if (hasLocation) {</b>
<b class="nc"><i>3893</i>&nbsp;                return diags.create(dkind, log.currentSource(), pos,</b>
<b class="nc"><i>3894</i>&nbsp;                        errKey, kindname, idname, //symbol kindname, name</b>
<b class="nc"><i>3895</i>&nbsp;                        typeargtypes, args(argtypes), //type parameters and arguments (if any)</b>
<i>3896</i>&nbsp;                        getLocationDiag(location, site)); //location kindname, type
<i>3897</i>&nbsp;            }
<i>3898</i>&nbsp;            else {
<b class="nc"><i>3899</i>&nbsp;                return diags.create(dkind, log.currentSource(), pos,</b>
<b class="nc"><i>3900</i>&nbsp;                        errKey, kindname, idname, //symbol kindname, name</b>
<b class="nc"><i>3901</i>&nbsp;                        typeargtypes, args(argtypes)); //type parameters and arguments (if any)</b>
<b class="nc"><i>3902</i>&nbsp;            }</b>
<b class="nc"><i>3903</i>&nbsp;        }</b>
<i>3904</i>&nbsp;        //where
<b class="nc"><i>3905</i>&nbsp;        private Object args(List&lt;Type&gt; args) {</b>
<b class="nc"><i>3906</i>&nbsp;            return args.isEmpty() ? args : methodArguments(args);</b>
<i>3907</i>&nbsp;        }
<i>3908</i>&nbsp;
<i>3909</i>&nbsp;        private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
<b class="nc"><i>3910</i>&nbsp;            String key = &quot;cant.resolve&quot;;</b>
<b class="nc"><i>3911</i>&nbsp;            String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;</b>
<b class="nc"><i>3912</i>&nbsp;            switch (kindname) {</b>
<b class="nc"><i>3913</i>&nbsp;                case METHOD:</b>
<b class="nc"><i>3914</i>&nbsp;                case CONSTRUCTOR: {</b>
<b class="nc"><i>3915</i>&nbsp;                    suffix += &quot;.args&quot;;</b>
<b class="nc"><i>3916</i>&nbsp;                    suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;</b>
<b class="nc"><i>3917</i>&nbsp;                }</b>
<b class="nc"><i>3918</i>&nbsp;            }</b>
<b class="nc"><i>3919</i>&nbsp;            return key + suffix;</b>
<i>3920</i>&nbsp;        }
<i>3921</i>&nbsp;        private JCDiagnostic getLocationDiag(Symbol location, Type site) {
<i>3922</i>&nbsp;            if (location.kind == VAR) {
<b class="nc"><i>3923</i>&nbsp;                return diags.fragment(Fragments.Location1(kindName(location),</b>
<i>3924</i>&nbsp;                                                          location,
<i>3925</i>&nbsp;                                                          location.type));
<i>3926</i>&nbsp;            } else {
<i>3927</i>&nbsp;                return diags.fragment(Fragments.Location(typeKindName(site),
<i>3928</i>&nbsp;                                      site,
<i>3929</i>&nbsp;                                      null));
<i>3930</i>&nbsp;            }
<i>3931</i>&nbsp;        }
<i>3932</i>&nbsp;    }
<i>3933</i>&nbsp;
<i>3934</i>&nbsp;    /**
<i>3935</i>&nbsp;     * InvalidSymbolError error class indicating that a given symbol
<i>3936</i>&nbsp;     * (either a method, a constructor or an operand) is not applicable
<b class="nc"><i>3937</i>&nbsp;     * given an actual arguments/type argument list.</b>
<i>3938</i>&nbsp;     */
<i>3939</i>&nbsp;    class InapplicableSymbolError extends ResolveError {
<b class="nc"><i>3940</i>&nbsp;</b>
<b class="nc"><i>3941</i>&nbsp;        protected MethodResolutionContext resolveContext;</b>
<b class="nc"><i>3942</i>&nbsp;</b>
<b class="nc"><i>3943</i>&nbsp;        InapplicableSymbolError(MethodResolutionContext context) {</b>
<b class="nc"><i>3944</i>&nbsp;            this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);</b>
<b class="nc"><i>3945</i>&nbsp;        }</b>
<i>3946</i>&nbsp;
<i>3947</i>&nbsp;        protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
<i>3948</i>&nbsp;            super(kind, debugName);
<i>3949</i>&nbsp;            this.resolveContext = context;
<b class="nc"><i>3950</i>&nbsp;        }</b>
<i>3951</i>&nbsp;
<i>3952</i>&nbsp;        @Override
<i>3953</i>&nbsp;        public String toString() {
<i>3954</i>&nbsp;            return super.toString();
<i>3955</i>&nbsp;        }
<i>3956</i>&nbsp;
<i>3957</i>&nbsp;        @Override
<i>3958</i>&nbsp;        public boolean exists() {
<i>3959</i>&nbsp;            return true;
<i>3960</i>&nbsp;        }
<b class="nc"><i>3961</i>&nbsp;</b>
<b class="nc"><i>3962</i>&nbsp;        @Override</b>
<i>3963</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
<b class="nc"><i>3964</i>&nbsp;                DiagnosticPosition pos,</b>
<b class="nc"><i>3965</i>&nbsp;                Symbol location,</b>
<i>3966</i>&nbsp;                Type site,
<i>3967</i>&nbsp;                Name name,
<b class="nc"><i>3968</i>&nbsp;                List&lt;Type&gt; argtypes,</b>
<i>3969</i>&nbsp;                List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>3970</i>&nbsp;            if (name == names.error)</b>
<b class="nc"><i>3971</i>&nbsp;                return null;</b>
<i>3972</i>&nbsp;
<b class="nc"><i>3973</i>&nbsp;            Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();</b>
<i>3974</i>&nbsp;            if (compactMethodDiags) {
<b class="nc"><i>3975</i>&nbsp;                JCDiagnostic simpleDiag =</b>
<b class="nc"><i>3976</i>&nbsp;                    MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);</b>
<i>3977</i>&nbsp;                if (simpleDiag != null) {
<b class="nc"><i>3978</i>&nbsp;                    return simpleDiag;</b>
<b class="nc"><i>3979</i>&nbsp;                }</b>
<i>3980</i>&nbsp;            }
<i>3981</i>&nbsp;            Symbol ws = c.fst.asMemberOf(site, types);
<b class="nc"><i>3982</i>&nbsp;            return diags.create(dkind, log.currentSource(), pos,</b>
<b class="nc"><i>3983</i>&nbsp;                      &quot;cant.apply.symbol&quot;,</b>
<i>3984</i>&nbsp;                      kindName(ws),
<i>3985</i>&nbsp;                      ws.name == names.init ? ws.owner.name : ws.name,
<i>3986</i>&nbsp;                      methodArguments(ws.type.getParameterTypes()),
<i>3987</i>&nbsp;                      methodArguments(argtypes),
<i>3988</i>&nbsp;                      kindName(ws.owner),
<i>3989</i>&nbsp;                      ws.owner.type,
<i>3990</i>&nbsp;                      c.snd);
<i>3991</i>&nbsp;        }
<i>3992</i>&nbsp;
<i>3993</i>&nbsp;        @Override
<b class="nc"><i>3994</i>&nbsp;        public Symbol access(Name name, TypeSymbol location) {</b>
<b class="nc"><i>3995</i>&nbsp;            return types.createErrorType(name, location, syms.errSymbol.type).tsym;</b>
<i>3996</i>&nbsp;        }
<i>3997</i>&nbsp;
<i>3998</i>&nbsp;        protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
<i>3999</i>&nbsp;            Candidate bestSoFar = null;
<i>4000</i>&nbsp;            for (Candidate c : resolveContext.candidates) {
<i>4001</i>&nbsp;                if (c.isApplicable()) continue;
<i>4002</i>&nbsp;                bestSoFar = c;
<i>4003</i>&nbsp;            }
<i>4004</i>&nbsp;            Assert.checkNonNull(bestSoFar);
<i>4005</i>&nbsp;            return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
<b class="nc"><i>4006</i>&nbsp;        }</b>
<b class="nc"><i>4007</i>&nbsp;    }</b>
<i>4008</i>&nbsp;
<b class="nc"><i>4009</i>&nbsp;    /**</b>
<b class="nc"><i>4010</i>&nbsp;     * ResolveError error class indicating that a symbol (either methods, constructors or operand)</b>
<i>4011</i>&nbsp;     * is not applicable given an actual arguments/type argument list.
<i>4012</i>&nbsp;     */
<i>4013</i>&nbsp;    class InapplicableSymbolsError extends InapplicableSymbolError {
<i>4014</i>&nbsp;
<i>4015</i>&nbsp;        InapplicableSymbolsError(MethodResolutionContext context) {
<i>4016</i>&nbsp;            super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
<i>4017</i>&nbsp;        }
<i>4018</i>&nbsp;
<i>4019</i>&nbsp;        @Override
<i>4020</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
<i>4021</i>&nbsp;                DiagnosticPosition pos,
<b class="nc"><i>4022</i>&nbsp;                Symbol location,</b>
<i>4023</i>&nbsp;                Type site,
<i>4024</i>&nbsp;                Name name,
<i>4025</i>&nbsp;                List&lt;Type&gt; argtypes,
<b class="nc"><i>4026</i>&nbsp;                List&lt;Type&gt; typeargtypes) {</b>
<i>4027</i>&nbsp;            Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
<i>4028</i>&nbsp;            Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
<b class="nc"><i>4029</i>&nbsp;                    filterCandidates(candidatesMap) :</b>
<b class="nc"><i>4030</i>&nbsp;                    mapCandidates();</b>
<b class="nc"><i>4031</i>&nbsp;            if (filteredCandidates.isEmpty()) {</b>
<i>4032</i>&nbsp;                filteredCandidates = candidatesMap;
<i>4033</i>&nbsp;            }
<i>4034</i>&nbsp;            boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
<b class="nc"><i>4035</i>&nbsp;            if (filteredCandidates.size() &gt; 1) {</b>
<b class="nc"><i>4036</i>&nbsp;                JCDiagnostic err = diags.create(dkind,</b>
<i>4037</i>&nbsp;                        null,
<b class="nc"><i>4038</i>&nbsp;                        truncatedDiag ?</b>
<i>4039</i>&nbsp;                            EnumSet.of(DiagnosticFlag.COMPRESSED) :
<i>4040</i>&nbsp;                            EnumSet.noneOf(DiagnosticFlag.class),
<i>4041</i>&nbsp;                        log.currentSource(),
<i>4042</i>&nbsp;                        pos,
<b class="nc"><i>4043</i>&nbsp;                        &quot;cant.apply.symbols&quot;,</b>
<b class="nc"><i>4044</i>&nbsp;                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),</b>
<i>4045</i>&nbsp;                        name == names.init ? site.tsym.name : name,
<i>4046</i>&nbsp;                        methodArguments(argtypes));
<i>4047</i>&nbsp;                return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
<i>4048</i>&nbsp;            } else if (filteredCandidates.size() == 1) {
<i>4049</i>&nbsp;                Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
<i>4050</i>&nbsp;                                filteredCandidates.entrySet().iterator().next();
<i>4051</i>&nbsp;                final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
<i>4052</i>&nbsp;                JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
<i>4053</i>&nbsp;                    @Override
<i>4054</i>&nbsp;                    protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
<b class="nc"><i>4055</i>&nbsp;                        return p;</b>
<b class="nc"><i>4056</i>&nbsp;                    }</b>
<b class="nc"><i>4057</i>&nbsp;                }.getDiagnostic(dkind, pos,</b>
<b class="nc"><i>4058</i>&nbsp;                    location, site, name, argtypes, typeargtypes);</b>
<b class="nc"><i>4059</i>&nbsp;                if (truncatedDiag) {</b>
<b class="nc"><i>4060</i>&nbsp;                    d.setFlag(DiagnosticFlag.COMPRESSED);</b>
<i>4061</i>&nbsp;                }
<b class="nc"><i>4062</i>&nbsp;                return d;</b>
<i>4063</i>&nbsp;            } else {
<b class="nc"><i>4064</i>&nbsp;                return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,</b>
<b class="nc"><i>4065</i>&nbsp;                    location, site, name, argtypes, typeargtypes);</b>
<i>4066</i>&nbsp;            }
<b class="nc"><i>4067</i>&nbsp;        }</b>
<i>4068</i>&nbsp;        //where
<i>4069</i>&nbsp;            private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
<i>4070</i>&nbsp;                MostSpecificMap candidates = new MostSpecificMap();
<i>4071</i>&nbsp;                for (Candidate c : resolveContext.candidates) {
<i>4072</i>&nbsp;                    if (c.isApplicable()) continue;
<i>4073</i>&nbsp;                    candidates.put(c);
<i>4074</i>&nbsp;                }
<b class="nc"><i>4075</i>&nbsp;                return candidates;</b>
<b class="nc"><i>4076</i>&nbsp;            }</b>
<b class="nc"><i>4077</i>&nbsp;</b>
<b class="nc"><i>4078</i>&nbsp;            @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>4079</i>&nbsp;            private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {</b>
<b class="nc"><i>4080</i>&nbsp;                private void put(Candidate c) {</b>
<b class="nc"><i>4081</i>&nbsp;                    ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>4082</i>&nbsp;                    for (Symbol s : keySet()) {</b>
<b class="nc"><i>4083</i>&nbsp;                        if (s == c.sym) {</b>
<b class="nc"><i>4084</i>&nbsp;                            continue;</b>
<b class="nc"><i>4085</i>&nbsp;                        }</b>
<i>4086</i>&nbsp;                        if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
<b class="nc"><i>4087</i>&nbsp;                            overridden.add(s);</b>
<i>4088</i>&nbsp;                        } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
<b class="nc"><i>4089</i>&nbsp;                            return;</b>
<b class="nc"><i>4090</i>&nbsp;                        }</b>
<b class="nc"><i>4091</i>&nbsp;                    }</b>
<b class="nc"><i>4092</i>&nbsp;                    for (Symbol s : overridden) {</b>
<i>4093</i>&nbsp;                        remove(s);
<b class="nc"><i>4094</i>&nbsp;                    }</b>
<b class="nc"><i>4095</i>&nbsp;                    put(c.sym, c.details);</b>
<b class="nc"><i>4096</i>&nbsp;                }</b>
<i>4097</i>&nbsp;            }
<i>4098</i>&nbsp;
<b class="nc"><i>4099</i>&nbsp;            Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {</b>
<i>4100</i>&nbsp;                Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
<b class="nc"><i>4101</i>&nbsp;                for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {</b>
<i>4102</i>&nbsp;                    JCDiagnostic d = _entry.getValue();
<b class="nc"><i>4103</i>&nbsp;                    if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {</b>
<i>4104</i>&nbsp;                        candidates.put(_entry.getKey(), d);
<i>4105</i>&nbsp;                    }
<b class="nc"><i>4106</i>&nbsp;                }</b>
<b class="nc"><i>4107</i>&nbsp;                return candidates;</b>
<i>4108</i>&nbsp;            }
<i>4109</i>&nbsp;
<i>4110</i>&nbsp;            private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
<i>4111</i>&nbsp;                List&lt;JCDiagnostic&gt; details = List.nil();
<b class="nc"><i>4112</i>&nbsp;                for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {</b>
<b class="nc"><i>4113</i>&nbsp;                    Symbol sym = _entry.getKey();</b>
<b class="nc"><i>4114</i>&nbsp;                    JCDiagnostic detailDiag =</b>
<i>4115</i>&nbsp;                            diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
<i>4116</i>&nbsp;                                                                        sym.location(site, types),
<i>4117</i>&nbsp;                                                                        sym.asMemberOf(site, types),
<i>4118</i>&nbsp;                                                                        _entry.getValue()));
<i>4119</i>&nbsp;                    details = details.prepend(detailDiag);
<i>4120</i>&nbsp;                }
<i>4121</i>&nbsp;                //typically members are visited in reverse order (see Scope)
<i>4122</i>&nbsp;                //so we need to reverse the candidate list so that candidates
<b class="nc"><i>4123</i>&nbsp;                //conform to source order</b>
<b class="nc"><i>4124</i>&nbsp;                return details;</b>
<b class="nc"><i>4125</i>&nbsp;            }</b>
<i>4126</i>&nbsp;    }
<i>4127</i>&nbsp;
<i>4128</i>&nbsp;    /**
<i>4129</i>&nbsp;     * DiamondError error class indicating that a constructor symbol is not applicable
<b class="nc"><i>4130</i>&nbsp;     * given an actual arguments/type argument list using diamond inference.</b>
<i>4131</i>&nbsp;     */
<i>4132</i>&nbsp;    class DiamondError extends InapplicableSymbolError {
<i>4133</i>&nbsp;
<i>4134</i>&nbsp;        Symbol sym;
<b class="nc"><i>4135</i>&nbsp;</b>
<i>4136</i>&nbsp;        public DiamondError(Symbol sym, MethodResolutionContext context) {
<i>4137</i>&nbsp;            super(sym.kind, &quot;diamondError&quot;, context);
<i>4138</i>&nbsp;            this.sym = sym;
<i>4139</i>&nbsp;        }
<b class="nc"><i>4140</i>&nbsp;</b>
<i>4141</i>&nbsp;        JCDiagnostic getDetails() {
<i>4142</i>&nbsp;            return (sym.kind == WRONG_MTH) ?
<i>4143</i>&nbsp;                    ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
<i>4144</i>&nbsp;                    null;
<b class="nc"><i>4145</i>&nbsp;        }</b>
<i>4146</i>&nbsp;
<i>4147</i>&nbsp;        @Override
<i>4148</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
<i>4149</i>&nbsp;                Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>4150</i>&nbsp;            JCDiagnostic details = getDetails();
<i>4151</i>&nbsp;            if (details != null &amp;&amp; compactMethodDiags) {
<i>4152</i>&nbsp;                JCDiagnostic simpleDiag =
<i>4153</i>&nbsp;                        MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
<i>4154</i>&nbsp;                if (simpleDiag != null) {
<i>4155</i>&nbsp;                    return simpleDiag;
<i>4156</i>&nbsp;                }
<i>4157</i>&nbsp;            }
<i>4158</i>&nbsp;            String key = details == null ?
<i>4159</i>&nbsp;                &quot;cant.apply.diamond&quot; :
<b class="nc"><i>4160</i>&nbsp;                &quot;cant.apply.diamond.1&quot;;</b>
<i>4161</i>&nbsp;            return diags.create(dkind, log.currentSource(), pos, key,
<i>4162</i>&nbsp;                    Fragments.Diamond(site.tsym), details);
<i>4163</i>&nbsp;        }
<i>4164</i>&nbsp;    }
<i>4165</i>&nbsp;
<i>4166</i>&nbsp;    /**
<i>4167</i>&nbsp;     * An InvalidSymbolError error class indicating that a symbol is not
<i>4168</i>&nbsp;     * accessible from a given site
<i>4169</i>&nbsp;     */
<i>4170</i>&nbsp;    class AccessError extends InvalidSymbolError {
<i>4171</i>&nbsp;
<i>4172</i>&nbsp;        private Env&lt;AttrContext&gt; env;
<i>4173</i>&nbsp;        private Type site;
<i>4174</i>&nbsp;
<i>4175</i>&nbsp;        AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
<i>4176</i>&nbsp;            super(HIDDEN, sym, &quot;access error&quot;);
<i>4177</i>&nbsp;            this.env = env;
<i>4178</i>&nbsp;            this.site = site;
<i>4179</i>&nbsp;        }
<i>4180</i>&nbsp;
<i>4181</i>&nbsp;        @Override
<i>4182</i>&nbsp;        public boolean exists() {
<i>4183</i>&nbsp;            return false;
<i>4184</i>&nbsp;        }
<b class="nc"><i>4185</i>&nbsp;</b>
<b class="nc"><i>4186</i>&nbsp;        @Override</b>
<b class="nc"><i>4187</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,</b>
<i>4188</i>&nbsp;                DiagnosticPosition pos,
<i>4189</i>&nbsp;                Symbol location,
<i>4190</i>&nbsp;                Type site,
<i>4191</i>&nbsp;                Name name,
<i>4192</i>&nbsp;                List&lt;Type&gt; argtypes,
<i>4193</i>&nbsp;                List&lt;Type&gt; typeargtypes) {
<i>4194</i>&nbsp;            if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
<b class="nc"><i>4195</i>&nbsp;                return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,</b>
<b class="nc"><i>4196</i>&nbsp;                        pos, location, site, name, argtypes, typeargtypes);</b>
<b class="nc"><i>4197</i>&nbsp;            }</b>
<b class="nc"><i>4198</i>&nbsp;            else if ((sym.flags() &amp; PUBLIC) != 0</b>
<b class="nc"><i>4199</i>&nbsp;                || (env != null &amp;&amp; this.site != null</b>
<i>4200</i>&nbsp;                    &amp;&amp; !isAccessible(env, this.site))) {
<b class="nc"><i>4201</i>&nbsp;                if (sym.owner.kind == PCK) {</b>
<b class="nc"><i>4202</i>&nbsp;                    return diags.create(dkind, log.currentSource(),</b>
<b class="nc"><i>4203</i>&nbsp;                            pos, &quot;not.def.access.package.cant.access&quot;,</b>
<i>4204</i>&nbsp;                        sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
<i>4205</i>&nbsp;                } else if (   sym.packge() != syms.rootPackage
<b class="nc"><i>4206</i>&nbsp;                           &amp;&amp; !symbolPackageVisible(env, sym)) {</b>
<i>4207</i>&nbsp;                    return diags.create(dkind, log.currentSource(),
<i>4208</i>&nbsp;                            pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
<i>4209</i>&nbsp;                            sym, sym.location(), sym.location().packge(),
<i>4210</i>&nbsp;                            inaccessiblePackageReason(env, sym.packge()));
<b class="nc"><i>4211</i>&nbsp;                } else {</b>
<i>4212</i>&nbsp;                    return diags.create(dkind, log.currentSource(),
<i>4213</i>&nbsp;                            pos, &quot;not.def.access.class.intf.cant.access&quot;,
<b class="nc"><i>4214</i>&nbsp;                        sym, sym.location());</b>
<i>4215</i>&nbsp;                }
<i>4216</i>&nbsp;            }
<i>4217</i>&nbsp;            else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
<i>4218</i>&nbsp;                return diags.create(dkind, log.currentSource(),
<b class="nc"><i>4219</i>&nbsp;                        pos, &quot;report.access&quot;, sym,</b>
<i>4220</i>&nbsp;                        asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
<i>4221</i>&nbsp;                        sym.location());
<i>4222</i>&nbsp;            }
<b class="nc"><i>4223</i>&nbsp;            else {</b>
<b class="nc"><i>4224</i>&nbsp;                return diags.create(dkind, log.currentSource(),</b>
<b class="nc"><i>4225</i>&nbsp;                        pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());</b>
<i>4226</i>&nbsp;            }
<i>4227</i>&nbsp;        }
<i>4228</i>&nbsp;
<i>4229</i>&nbsp;        private String toString(Type type) {
<b class="nc"><i>4230</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>4231</i>&nbsp;            sb.append(type);</b>
<b class="nc"><i>4232</i>&nbsp;            if (type != null) {</b>
<b class="nc"><i>4233</i>&nbsp;                sb.append(&quot;[tsym:&quot;).append(type.tsym);</b>
<i>4234</i>&nbsp;                if (type.tsym != null)
<b class="nc"><i>4235</i>&nbsp;                    sb.append(&quot;packge:&quot;).append(type.tsym.packge());</b>
<i>4236</i>&nbsp;                sb.append(&quot;]&quot;);
<i>4237</i>&nbsp;            }
<i>4238</i>&nbsp;            return sb.toString();
<i>4239</i>&nbsp;        }
<i>4240</i>&nbsp;    }
<i>4241</i>&nbsp;
<b class="nc"><i>4242</i>&nbsp;    class InvisibleSymbolError extends InvalidSymbolError {</b>
<b class="nc"><i>4243</i>&nbsp;</b>
<b class="nc"><i>4244</i>&nbsp;        private final Env&lt;AttrContext&gt; env;</b>
<b class="nc"><i>4245</i>&nbsp;        private final boolean suppressError;</b>
<i>4246</i>&nbsp;
<i>4247</i>&nbsp;        InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
<i>4248</i>&nbsp;            super(HIDDEN, sym, &quot;invisible class error&quot;);
<b class="nc"><i>4249</i>&nbsp;            this.env = env;</b>
<b class="nc"><i>4250</i>&nbsp;            this.suppressError = suppressError;</b>
<i>4251</i>&nbsp;            this.name = sym.name;
<b class="nc"><i>4252</i>&nbsp;        }</b>
<i>4253</i>&nbsp;
<i>4254</i>&nbsp;        @Override
<b class="nc"><i>4255</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,</b>
<i>4256</i>&nbsp;                DiagnosticPosition pos,
<i>4257</i>&nbsp;                Symbol location,
<i>4258</i>&nbsp;                Type site,
<i>4259</i>&nbsp;                Name name,
<i>4260</i>&nbsp;                List&lt;Type&gt; argtypes,
<i>4261</i>&nbsp;                List&lt;Type&gt; typeargtypes) {
<b class="nc"><i>4262</i>&nbsp;            if (suppressError)</b>
<i>4263</i>&nbsp;                return null;
<i>4264</i>&nbsp;
<i>4265</i>&nbsp;            if (sym.kind == PCK) {
<b class="nc"><i>4266</i>&nbsp;                JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());</b>
<i>4267</i>&nbsp;                return diags.create(dkind, log.currentSource(),
<i>4268</i>&nbsp;                        pos, &quot;package.not.visible&quot;, sym, details);
<i>4269</i>&nbsp;            }
<i>4270</i>&nbsp;
<b class="nc"><i>4271</i>&nbsp;            JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());</b>
<i>4272</i>&nbsp;
<i>4273</i>&nbsp;            if (pos.getTree() != null) {
<i>4274</i>&nbsp;                Symbol o = sym;
<b class="nc"><i>4275</i>&nbsp;                JCTree tree = pos.getTree();</b>
<i>4276</i>&nbsp;
<i>4277</i>&nbsp;                while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
<i>4278</i>&nbsp;                    o = o.owner;
<b class="nc"><i>4279</i>&nbsp;                    tree = ((JCFieldAccess) tree).selected;</b>
<i>4280</i>&nbsp;                }
<i>4281</i>&nbsp;
<i>4282</i>&nbsp;                if (o.kind == PCK) {
<i>4283</i>&nbsp;                    pos = tree.pos();
<i>4284</i>&nbsp;
<i>4285</i>&nbsp;                    return diags.create(dkind, log.currentSource(),
<i>4286</i>&nbsp;                            pos, &quot;package.not.visible&quot;, o, details);
<i>4287</i>&nbsp;                }
<b class="nc"><i>4288</i>&nbsp;            }</b>
<b class="nc"><i>4289</i>&nbsp;</b>
<b class="nc"><i>4290</i>&nbsp;            return diags.create(dkind, log.currentSource(),</b>
<i>4291</i>&nbsp;                    pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
<i>4292</i>&nbsp;        }
<i>4293</i>&nbsp;    }
<b class="nc"><i>4294</i>&nbsp;</b>
<i>4295</i>&nbsp;    JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
<i>4296</i>&nbsp;        //no dependency:
<i>4297</i>&nbsp;        if (!env.toplevel.modle.readModules.contains(sym.modle)) {
<b class="nc"><i>4298</i>&nbsp;            //does not read:</b>
<i>4299</i>&nbsp;            if (sym.modle != syms.unnamedModule) {
<i>4300</i>&nbsp;                if (env.toplevel.modle != syms.unnamedModule) {
<i>4301</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
<b class="nc"><i>4302</i>&nbsp;                                                                            sym,</b>
<i>4303</i>&nbsp;                                                                            sym.modle));
<i>4304</i>&nbsp;                } else {
<i>4305</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
<i>4306</i>&nbsp;                                                                                       sym.modle));
<b class="nc"><i>4307</i>&nbsp;                }</b>
<i>4308</i>&nbsp;            } else {
<i>4309</i>&nbsp;                return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
<i>4310</i>&nbsp;                                                                               env.toplevel.modle));
<b class="nc"><i>4311</i>&nbsp;            }</b>
<i>4312</i>&nbsp;        } else {
<i>4313</i>&nbsp;            if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
<i>4314</i>&nbsp;                //not exported to this module:
<i>4315</i>&nbsp;                if (env.toplevel.modle != syms.unnamedModule) {
<i>4316</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
<i>4317</i>&nbsp;                                                                                    sym.modle,
<i>4318</i>&nbsp;                                                                                    env.toplevel.modle));
<i>4319</i>&nbsp;                } else {
<b class="nc"><i>4320</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,</b>
<i>4321</i>&nbsp;                                                                                               sym.modle));
<b class="nc"><i>4322</i>&nbsp;                }</b>
<i>4323</i>&nbsp;            } else {
<b class="nc"><i>4324</i>&nbsp;                //not exported:</b>
<i>4325</i>&nbsp;                if (env.toplevel.modle != syms.unnamedModule) {
<b class="nc"><i>4326</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessNotExported(sym,</b>
<i>4327</i>&nbsp;                                                                            sym.modle));
<b class="nc"><i>4328</i>&nbsp;                } else {</b>
<b class="nc"><i>4329</i>&nbsp;                    return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,</b>
<i>4330</i>&nbsp;                                                                                       sym.modle));
<i>4331</i>&nbsp;                }
<b class="nc"><i>4332</i>&nbsp;            }</b>
<b class="nc"><i>4333</i>&nbsp;        }</b>
<i>4334</i>&nbsp;    }
<i>4335</i>&nbsp;
<i>4336</i>&nbsp;    /**
<b class="nc"><i>4337</i>&nbsp;     * InvalidSymbolError error class indicating that an instance member</b>
<b class="nc"><i>4338</i>&nbsp;     * has erroneously been accessed from a static context.</b>
<i>4339</i>&nbsp;     */
<i>4340</i>&nbsp;    class StaticError extends InvalidSymbolError {
<i>4341</i>&nbsp;
<b class="nc"><i>4342</i>&nbsp;        StaticError(Symbol sym) {</b>
<i>4343</i>&nbsp;            super(STATICERR, sym, &quot;static error&quot;);
<b class="nc"><i>4344</i>&nbsp;        }</b>
<b class="nc"><i>4345</i>&nbsp;</b>
<i>4346</i>&nbsp;        @Override
<i>4347</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
<i>4348</i>&nbsp;                DiagnosticPosition pos,
<i>4349</i>&nbsp;                Symbol location,
<i>4350</i>&nbsp;                Type site,
<i>4351</i>&nbsp;                Name name,
<i>4352</i>&nbsp;                List&lt;Type&gt; argtypes,
<i>4353</i>&nbsp;                List&lt;Type&gt; typeargtypes) {
<i>4354</i>&nbsp;            Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
<i>4355</i>&nbsp;                ? types.erasure(sym.type).tsym
<i>4356</i>&nbsp;                : sym);
<b class="nc"><i>4357</i>&nbsp;            return diags.create(dkind, log.currentSource(), pos,</b>
<i>4358</i>&nbsp;                    &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
<i>4359</i>&nbsp;        }
<i>4360</i>&nbsp;    }
<i>4361</i>&nbsp;
<i>4362</i>&nbsp;    /**
<i>4363</i>&nbsp;     * InvalidSymbolError error class indicating that a pair of symbols
<b class="nc"><i>4364</i>&nbsp;     * (either methods, constructors or operands) are ambiguous</b>
<b class="nc"><i>4365</i>&nbsp;     * given an actual arguments/type argument list.</b>
<b class="nc"><i>4366</i>&nbsp;     */</b>
<b class="nc"><i>4367</i>&nbsp;    class AmbiguityError extends ResolveError {</b>
<b class="nc"><i>4368</i>&nbsp;</b>
<i>4369</i>&nbsp;        /** The other maximally specific symbol */
<i>4370</i>&nbsp;        List&lt;Symbol&gt; ambiguousSyms = List.nil();
<i>4371</i>&nbsp;
<i>4372</i>&nbsp;        @Override
<b class="nc"><i>4373</i>&nbsp;        public boolean exists() {</b>
<b class="nc"><i>4374</i>&nbsp;            return true;</b>
<b class="nc"><i>4375</i>&nbsp;        }</b>
<b class="nc"><i>4376</i>&nbsp;</b>
<b class="nc"><i>4377</i>&nbsp;        AmbiguityError(Symbol sym1, Symbol sym2) {</b>
<b class="nc"><i>4378</i>&nbsp;            super(AMBIGUOUS, &quot;ambiguity error&quot;);</b>
<b class="nc"><i>4379</i>&nbsp;            ambiguousSyms = flatten(sym2).appendList(flatten(sym1));</b>
<b class="nc"><i>4380</i>&nbsp;        }</b>
<i>4381</i>&nbsp;
<b class="nc"><i>4382</i>&nbsp;        private List&lt;Symbol&gt; flatten(Symbol sym) {</b>
<i>4383</i>&nbsp;            if (sym.kind == AMBIGUOUS) {
<i>4384</i>&nbsp;                return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
<i>4385</i>&nbsp;            } else {
<b class="nc"><i>4386</i>&nbsp;                return List.of(sym);</b>
<i>4387</i>&nbsp;            }
<i>4388</i>&nbsp;        }
<i>4389</i>&nbsp;
<i>4390</i>&nbsp;        AmbiguityError addAmbiguousSymbol(Symbol s) {
<b class="nc"><i>4391</i>&nbsp;            ambiguousSyms = ambiguousSyms.prepend(s);</b>
<i>4392</i>&nbsp;            return this;
<i>4393</i>&nbsp;        }
<i>4394</i>&nbsp;
<b class="nc"><i>4395</i>&nbsp;        @Override</b>
<i>4396</i>&nbsp;        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
<i>4397</i>&nbsp;                DiagnosticPosition pos,
<i>4398</i>&nbsp;                Symbol location,
<b class="nc"><i>4399</i>&nbsp;                Type site,</b>
<i>4400</i>&nbsp;                Name name,
<i>4401</i>&nbsp;                List&lt;Type&gt; argtypes,
<i>4402</i>&nbsp;                List&lt;Type&gt; typeargtypes) {
<i>4403</i>&nbsp;            List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
<i>4404</i>&nbsp;            Symbol s1 = diagSyms.head;
<i>4405</i>&nbsp;            Symbol s2 = diagSyms.tail.head;
<i>4406</i>&nbsp;            Name sname = s1.name;
<i>4407</i>&nbsp;            if (sname == names.init) sname = s1.owner.name;
<i>4408</i>&nbsp;            return diags.create(dkind, log.currentSource(),
<i>4409</i>&nbsp;                    pos, &quot;ref.ambiguous&quot;, sname,
<i>4410</i>&nbsp;                    kindName(s1),
<i>4411</i>&nbsp;                    s1,
<i>4412</i>&nbsp;                    s1.location(site, types),
<i>4413</i>&nbsp;                    kindName(s2),
<i>4414</i>&nbsp;                    s2,
<i>4415</i>&nbsp;                    s2.location(site, types));
<i>4416</i>&nbsp;        }
<i>4417</i>&nbsp;
<i>4418</i>&nbsp;        /**
<i>4419</i>&nbsp;         * If multiple applicable methods are found during overload and none of them
<i>4420</i>&nbsp;         * is more specific than the others, attempt to merge their signatures.
<i>4421</i>&nbsp;         */
<i>4422</i>&nbsp;        Symbol mergeAbstracts(Type site) {
<i>4423</i>&nbsp;            List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
<i>4424</i>&nbsp;            return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
<i>4425</i>&nbsp;        }
<i>4426</i>&nbsp;
<i>4427</i>&nbsp;        @Override
<i>4428</i>&nbsp;        protected Symbol access(Name name, TypeSymbol location) {
<i>4429</i>&nbsp;            Symbol firstAmbiguity = ambiguousSyms.last();
<i>4430</i>&nbsp;            return firstAmbiguity.kind == TYP ?
<i>4431</i>&nbsp;                    types.createErrorType(name, location, firstAmbiguity.type).tsym :
<i>4432</i>&nbsp;                    firstAmbiguity;
<i>4433</i>&nbsp;        }
<i>4434</i>&nbsp;    }
<i>4435</i>&nbsp;
<i>4436</i>&nbsp;    class BadVarargsMethod extends ResolveError {
<i>4437</i>&nbsp;
<i>4438</i>&nbsp;        ResolveError delegatedError;
<i>4439</i>&nbsp;
<i>4440</i>&nbsp;        BadVarargsMethod(ResolveError delegatedError) {
<i>4441</i>&nbsp;            super(delegatedError.kind, &quot;badVarargs&quot;);
<i>4442</i>&nbsp;            this.delegatedError = delegatedError;
<i>4443</i>&nbsp;        }
<i>4444</i>&nbsp;
<i>4445</i>&nbsp;        @Override
<i>4446</i>&nbsp;        public Symbol baseSymbol() {
<i>4447</i>&nbsp;            return delegatedError.baseSymbol();
<i>4448</i>&nbsp;        }
<i>4449</i>&nbsp;
<i>4450</i>&nbsp;        @Override
<i>4451</i>&nbsp;        protected Symbol access(Name name, TypeSymbol location) {
<i>4452</i>&nbsp;            return delegatedError.access(name, location);
<i>4453</i>&nbsp;        }
<i>4454</i>&nbsp;
<i>4455</i>&nbsp;        @Override
<i>4456</i>&nbsp;        public boolean exists() {
<i>4457</i>&nbsp;            return true;
<i>4458</i>&nbsp;        }
<i>4459</i>&nbsp;
<i>4460</i>&nbsp;        @Override
<i>4461</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>4462</i>&nbsp;            return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
<i>4463</i>&nbsp;        }
<i>4464</i>&nbsp;    }
<i>4465</i>&nbsp;
<i>4466</i>&nbsp;    /**
<i>4467</i>&nbsp;     * BadMethodReferenceError error class indicating that a method reference symbol has been found,
<i>4468</i>&nbsp;     * but with the wrong staticness.
<i>4469</i>&nbsp;     */
<i>4470</i>&nbsp;    class BadMethodReferenceError extends StaticError {
<i>4471</i>&nbsp;
<i>4472</i>&nbsp;        boolean unboundLookup;
<i>4473</i>&nbsp;
<i>4474</i>&nbsp;        public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
<i>4475</i>&nbsp;            super(sym);
<i>4476</i>&nbsp;            this.unboundLookup = unboundLookup;
<i>4477</i>&nbsp;        }
<i>4478</i>&nbsp;
<i>4479</i>&nbsp;        @Override
<i>4480</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>4481</i>&nbsp;            final String key;
<i>4482</i>&nbsp;            if (!unboundLookup) {
<i>4483</i>&nbsp;                key = &quot;bad.static.method.in.bound.lookup&quot;;
<i>4484</i>&nbsp;            } else if (sym.isStatic()) {
<i>4485</i>&nbsp;                key = &quot;bad.static.method.in.unbound.lookup&quot;;
<i>4486</i>&nbsp;            } else {
<i>4487</i>&nbsp;                key = &quot;bad.instance.method.in.unbound.lookup&quot;;
<i>4488</i>&nbsp;            }
<i>4489</i>&nbsp;            return sym.kind.isResolutionError() ?
<i>4490</i>&nbsp;                    ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
<i>4491</i>&nbsp;                    diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
<i>4492</i>&nbsp;        }
<i>4493</i>&nbsp;    }
<i>4494</i>&nbsp;
<i>4495</i>&nbsp;    /**
<i>4496</i>&nbsp;     * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
<i>4497</i>&nbsp;     * but pointing to a class for which an enclosing instance is not available.
<i>4498</i>&nbsp;     */
<i>4499</i>&nbsp;    class BadConstructorReferenceError extends InvalidSymbolError {
<i>4500</i>&nbsp;
<i>4501</i>&nbsp;        public BadConstructorReferenceError(Symbol sym) {
<i>4502</i>&nbsp;            super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
<i>4503</i>&nbsp;        }
<i>4504</i>&nbsp;
<i>4505</i>&nbsp;        @Override
<i>4506</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>4507</i>&nbsp;           return diags.create(dkind, log.currentSource(), pos,
<i>4508</i>&nbsp;                &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
<i>4509</i>&nbsp;        }
<i>4510</i>&nbsp;    }
<i>4511</i>&nbsp;
<i>4512</i>&nbsp;    class BadClassFileError extends InvalidSymbolError {
<i>4513</i>&nbsp;
<i>4514</i>&nbsp;        private final CompletionFailure ex;
<i>4515</i>&nbsp;
<i>4516</i>&nbsp;        public BadClassFileError(CompletionFailure ex) {
<i>4517</i>&nbsp;            super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
<i>4518</i>&nbsp;            this.name = sym.name;
<i>4519</i>&nbsp;            this.ex = ex;
<i>4520</i>&nbsp;        }
<i>4521</i>&nbsp;
<i>4522</i>&nbsp;        @Override
<i>4523</i>&nbsp;        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<i>4524</i>&nbsp;            JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
<i>4525</i>&nbsp;                &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
<i>4526</i>&nbsp;
<i>4527</i>&nbsp;            d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
<i>4528</i>&nbsp;            return d;
<i>4529</i>&nbsp;        }
<i>4530</i>&nbsp;
<i>4531</i>&nbsp;    }
<i>4532</i>&nbsp;
<i>4533</i>&nbsp;    /**
<i>4534</i>&nbsp;     * Helper class for method resolution diagnostic simplification.
<i>4535</i>&nbsp;     * Certain resolution diagnostic are rewritten as simpler diagnostic
<i>4536</i>&nbsp;     * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
<i>4537</i>&nbsp;     * is stripped away, as it doesn&#39;t carry additional info. The logic
<i>4538</i>&nbsp;     * for matching a given diagnostic is given in terms of a template
<i>4539</i>&nbsp;     * hierarchy: a diagnostic template can be specified programmatically,
<i>4540</i>&nbsp;     * so that only certain diagnostics are matched. Each templete is then
<i>4541</i>&nbsp;     * associated with a rewriter object that carries out the task of rewtiting
<i>4542</i>&nbsp;     * the diagnostic to a simpler one.
<i>4543</i>&nbsp;     */
<i>4544</i>&nbsp;    static class MethodResolutionDiagHelper {
<i>4545</i>&nbsp;
<i>4546</i>&nbsp;        /**
<i>4547</i>&nbsp;         * A diagnostic rewriter transforms a method resolution diagnostic
<i>4548</i>&nbsp;         * into a simpler one
<i>4549</i>&nbsp;         */
<i>4550</i>&nbsp;        interface DiagnosticRewriter {
<i>4551</i>&nbsp;            JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<i>4552</i>&nbsp;                    DiagnosticPosition preferedPos, DiagnosticSource preferredSource,
<i>4553</i>&nbsp;                    DiagnosticType preferredKind, JCDiagnostic d);
<i>4554</i>&nbsp;        }
<i>4555</i>&nbsp;
<i>4556</i>&nbsp;        /**
<i>4557</i>&nbsp;         * A diagnostic template is made up of two ingredients: (i) a regular
<i>4558</i>&nbsp;         * expression for matching a diagnostic key and (ii) a list of sub-templates
<i>4559</i>&nbsp;         * for matching diagnostic arguments.
<i>4560</i>&nbsp;         */
<i>4561</i>&nbsp;        static class Template {
<i>4562</i>&nbsp;
<i>4563</i>&nbsp;            /** regex used to match diag key */
<i>4564</i>&nbsp;            String regex;
<i>4565</i>&nbsp;
<i>4566</i>&nbsp;            /** templates used to match diagnostic args */
<i>4567</i>&nbsp;            Template[] subTemplates;
<i>4568</i>&nbsp;
<i>4569</i>&nbsp;            Template(String key, Template... subTemplates) {
<i>4570</i>&nbsp;                this.regex = key;
<i>4571</i>&nbsp;                this.subTemplates = subTemplates;
<i>4572</i>&nbsp;            }
<i>4573</i>&nbsp;
<i>4574</i>&nbsp;            /**
<i>4575</i>&nbsp;             * Returns true if the regex matches the diagnostic key and if
<i>4576</i>&nbsp;             * all diagnostic arguments are matches by corresponding sub-templates.
<i>4577</i>&nbsp;             */
<i>4578</i>&nbsp;            boolean matches(Object o) {
<i>4579</i>&nbsp;                JCDiagnostic d = (JCDiagnostic)o;
<i>4580</i>&nbsp;                Object[] args = d.getArgs();
<i>4581</i>&nbsp;                if (!d.getCode().matches(regex) ||
<i>4582</i>&nbsp;                        subTemplates.length != d.getArgs().length) {
<i>4583</i>&nbsp;                    return false;
<i>4584</i>&nbsp;                }
<i>4585</i>&nbsp;                for (int i = 0; i &lt; args.length ; i++) {
<i>4586</i>&nbsp;                    if (!subTemplates[i].matches(args[i])) {
<i>4587</i>&nbsp;                        return false;
<i>4588</i>&nbsp;                    }
<i>4589</i>&nbsp;                }
<i>4590</i>&nbsp;                return true;
<i>4591</i>&nbsp;            }
<i>4592</i>&nbsp;        }
<i>4593</i>&nbsp;
<i>4594</i>&nbsp;        /**
<i>4595</i>&nbsp;         * Common rewriter for all argument mismatch simplifications.
<i>4596</i>&nbsp;         */
<i>4597</i>&nbsp;        static class ArgMismatchRewriter implements DiagnosticRewriter {
<i>4598</i>&nbsp;
<i>4599</i>&nbsp;            /** the index of the subdiagnostic to be used as primary. */
<i>4600</i>&nbsp;            int causeIndex;
<i>4601</i>&nbsp;
<i>4602</i>&nbsp;            public ArgMismatchRewriter(int causeIndex) {
<i>4603</i>&nbsp;                this.causeIndex = causeIndex;
<i>4604</i>&nbsp;            }
<i>4605</i>&nbsp;
<i>4606</i>&nbsp;            @Override
<i>4607</i>&nbsp;            public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<i>4608</i>&nbsp;                    DiagnosticPosition preferedPos, DiagnosticSource preferredSource,
<i>4609</i>&nbsp;                    DiagnosticType preferredKind, JCDiagnostic d) {
<i>4610</i>&nbsp;                JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
<i>4611</i>&nbsp;                DiagnosticPosition pos = d.getDiagnosticPosition();
<i>4612</i>&nbsp;                if (pos == null) {
<i>4613</i>&nbsp;                    pos = preferedPos;
<i>4614</i>&nbsp;                }
<i>4615</i>&nbsp;                return diags.create(preferredKind, preferredSource, pos,
<i>4616</i>&nbsp;                        &quot;prob.found.req&quot;, cause);
<i>4617</i>&nbsp;            }
<i>4618</i>&nbsp;        }
<i>4619</i>&nbsp;
<i>4620</i>&nbsp;        /** a dummy template that match any diagnostic argument */
<i>4621</i>&nbsp;        static final Template skip = new Template(&quot;&quot;) {
<i>4622</i>&nbsp;            @Override
<i>4623</i>&nbsp;            boolean matches(Object d) {
<i>4624</i>&nbsp;                return true;
<i>4625</i>&nbsp;            }
<i>4626</i>&nbsp;        };
<i>4627</i>&nbsp;
<i>4628</i>&nbsp;        /** template for matching inference-free arguments mismatch failures */
<i>4629</i>&nbsp;        static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
<i>4630</i>&nbsp;
<i>4631</i>&nbsp;        /** template for matching inference related arguments mismatch failures */
<i>4632</i>&nbsp;        static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
<i>4633</i>&nbsp;            @Override
<i>4634</i>&nbsp;            boolean matches(Object o) {
<i>4635</i>&nbsp;                if (!super.matches(o)) {
<i>4636</i>&nbsp;                    return false;
<i>4637</i>&nbsp;                }
<i>4638</i>&nbsp;                JCDiagnostic d = (JCDiagnostic)o;
<i>4639</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>4640</i>&nbsp;                List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
<i>4641</i>&nbsp;                return !containsAny(d, tvars);
<i>4642</i>&nbsp;            }
<i>4643</i>&nbsp;
<i>4644</i>&nbsp;            BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
<i>4645</i>&nbsp;                if (o instanceof Type) {
<i>4646</i>&nbsp;                    return ((Type)o).containsAny(ts);
<i>4647</i>&nbsp;                } else if (o instanceof JCDiagnostic) {
<i>4648</i>&nbsp;                    return containsAny((JCDiagnostic)o, ts);
<i>4649</i>&nbsp;                } else {
<i>4650</i>&nbsp;                    return false;
<i>4651</i>&nbsp;                }
<i>4652</i>&nbsp;            };
<i>4653</i>&nbsp;
<i>4654</i>&nbsp;            boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
<i>4655</i>&nbsp;                return Stream.of(d.getArgs())
<i>4656</i>&nbsp;                        .anyMatch(o -&gt; containsPredicate.test(o, ts));
<i>4657</i>&nbsp;            }
<i>4658</i>&nbsp;        };
<i>4659</i>&nbsp;
<i>4660</i>&nbsp;        /** rewriter map used for method resolution simplification */
<i>4661</i>&nbsp;        static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
<i>4662</i>&nbsp;
<i>4663</i>&nbsp;        static {
<i>4664</i>&nbsp;            rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
<i>4665</i>&nbsp;            rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
<i>4666</i>&nbsp;        }
<i>4667</i>&nbsp;
<i>4668</i>&nbsp;        /**
<i>4669</i>&nbsp;         * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
<i>4670</i>&nbsp;         * and rewrite it accordingly.
<i>4671</i>&nbsp;         */
<i>4672</i>&nbsp;        static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
<i>4673</i>&nbsp;                                    DiagnosticType dkind, JCDiagnostic d) {
<i>4674</i>&nbsp;            for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
<i>4675</i>&nbsp;                if (_entry.getKey().matches(d)) {
<i>4676</i>&nbsp;                    JCDiagnostic simpleDiag =
<i>4677</i>&nbsp;                            _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
<i>4678</i>&nbsp;                    simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
<i>4679</i>&nbsp;                    return simpleDiag;
<i>4680</i>&nbsp;                }
<i>4681</i>&nbsp;            }
<i>4682</i>&nbsp;            return null;
<i>4683</i>&nbsp;        }
<i>4684</i>&nbsp;    }
<i>4685</i>&nbsp;
<i>4686</i>&nbsp;    enum MethodResolutionPhase {
<i>4687</i>&nbsp;        BASIC(false, false),
<i>4688</i>&nbsp;        BOX(true, false),
<i>4689</i>&nbsp;        VARARITY(true, true) {
<i>4690</i>&nbsp;            @Override
<i>4691</i>&nbsp;            public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
<i>4692</i>&nbsp;                //Check invariants (see {@code LookupHelper.shouldStop})
<i>4693</i>&nbsp;                Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
<i>4694</i>&nbsp;                if (!sym.kind.isResolutionError()) {
<i>4695</i>&nbsp;                    //varargs resolution successful
<i>4696</i>&nbsp;                    return sym;
<i>4697</i>&nbsp;                } else {
<i>4698</i>&nbsp;                    //pick best error
<i>4699</i>&nbsp;                    switch (bestSoFar.kind) {
<i>4700</i>&nbsp;                        case WRONG_MTH:
<i>4701</i>&nbsp;                        case WRONG_MTHS:
<i>4702</i>&nbsp;                            //Override previous errors if they were caused by argument mismatch.
<i>4703</i>&nbsp;                            //This generally means preferring current symbols - but we need to pay
<i>4704</i>&nbsp;                            //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
<i>4705</i>&nbsp;                            //than the previous rounds, and adjust that accordingly.
<i>4706</i>&nbsp;                            switch (sym.kind) {
<i>4707</i>&nbsp;                                case WRONG_MTH:
<i>4708</i>&nbsp;                                    //if the previous round matched more than one method, return that
<i>4709</i>&nbsp;                                    //result instead
<i>4710</i>&nbsp;                                    return bestSoFar.kind == WRONG_MTHS ?
<i>4711</i>&nbsp;                                            bestSoFar : sym;
<i>4712</i>&nbsp;                                case ABSENT_MTH:
<i>4713</i>&nbsp;                                    //do not override erroneous symbol if the arity lookup did not
<i>4714</i>&nbsp;                                    //match any method
<i>4715</i>&nbsp;                                    return bestSoFar;
<i>4716</i>&nbsp;                                case WRONG_MTHS:
<i>4717</i>&nbsp;                                default:
<i>4718</i>&nbsp;                                    //safe to override
<i>4719</i>&nbsp;                                    return sym;
<i>4720</i>&nbsp;                            }
<i>4721</i>&nbsp;                        default:
<i>4722</i>&nbsp;                            //otherwise, return first error
<i>4723</i>&nbsp;                            return bestSoFar;
<i>4724</i>&nbsp;                    }
<i>4725</i>&nbsp;                }
<i>4726</i>&nbsp;            }
<i>4727</i>&nbsp;        };
<i>4728</i>&nbsp;
<i>4729</i>&nbsp;        final boolean isBoxingRequired;
<i>4730</i>&nbsp;        final boolean isVarargsRequired;
<i>4731</i>&nbsp;
<i>4732</i>&nbsp;        MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
<i>4733</i>&nbsp;           this.isBoxingRequired = isBoxingRequired;
<i>4734</i>&nbsp;           this.isVarargsRequired = isVarargsRequired;
<i>4735</i>&nbsp;        }
<i>4736</i>&nbsp;
<i>4737</i>&nbsp;        public boolean isBoxingRequired() {
<i>4738</i>&nbsp;            return isBoxingRequired;
<i>4739</i>&nbsp;        }
<i>4740</i>&nbsp;
<i>4741</i>&nbsp;        public boolean isVarargsRequired() {
<i>4742</i>&nbsp;            return isVarargsRequired;
<i>4743</i>&nbsp;        }
<i>4744</i>&nbsp;
<i>4745</i>&nbsp;        public Symbol mergeResults(Symbol prev, Symbol sym) {
<i>4746</i>&nbsp;            return sym;
<i>4747</i>&nbsp;        }
<i>4748</i>&nbsp;    }
<i>4749</i>&nbsp;
<i>4750</i>&nbsp;    final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
<i>4751</i>&nbsp;
<i>4752</i>&nbsp;    /**
<i>4753</i>&nbsp;     * A resolution context is used to keep track of intermediate results of
<i>4754</i>&nbsp;     * overload resolution, such as list of method that are not applicable
<i>4755</i>&nbsp;     * (used to generate more precise diagnostics) and so on. Resolution contexts
<i>4756</i>&nbsp;     * can be nested - this means that when each overload resolution routine should
<i>4757</i>&nbsp;     * work within the resolution context it created.
<i>4758</i>&nbsp;     */
<i>4759</i>&nbsp;    class MethodResolutionContext {
<i>4760</i>&nbsp;
<i>4761</i>&nbsp;        private List&lt;Candidate&gt; candidates = List.nil();
<i>4762</i>&nbsp;
<i>4763</i>&nbsp;        MethodResolutionPhase step = null;
<i>4764</i>&nbsp;
<i>4765</i>&nbsp;        MethodCheck methodCheck = resolveMethodCheck;
<i>4766</i>&nbsp;
<i>4767</i>&nbsp;        private boolean internalResolution = false;
<i>4768</i>&nbsp;        private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
<i>4769</i>&nbsp;
<i>4770</i>&nbsp;        void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
<i>4771</i>&nbsp;            Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
<i>4772</i>&nbsp;            candidates = candidates.append(c);
<i>4773</i>&nbsp;        }
<i>4774</i>&nbsp;
<i>4775</i>&nbsp;        void addApplicableCandidate(Symbol sym, Type mtype) {
<i>4776</i>&nbsp;            Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
<i>4777</i>&nbsp;            candidates = candidates.append(c);
<i>4778</i>&nbsp;        }
<i>4779</i>&nbsp;
<i>4780</i>&nbsp;        DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
<i>4781</i>&nbsp;            DeferredAttrContext parent = (pendingResult == null)
<i>4782</i>&nbsp;                ? deferredAttr.emptyDeferredAttrContext
<i>4783</i>&nbsp;                : pendingResult.checkContext.deferredAttrContext();
<i>4784</i>&nbsp;            return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
<i>4785</i>&nbsp;                    inferenceContext, parent, warn);
<i>4786</i>&nbsp;        }
<i>4787</i>&nbsp;
<i>4788</i>&nbsp;        /**
<i>4789</i>&nbsp;         * This class represents an overload resolution candidate. There are two
<i>4790</i>&nbsp;         * kinds of candidates: applicable methods and inapplicable methods;
<i>4791</i>&nbsp;         * applicable methods have a pointer to the instantiated method type,
<i>4792</i>&nbsp;         * while inapplicable candidates contain further details about the
<i>4793</i>&nbsp;         * reason why the method has been considered inapplicable.
<i>4794</i>&nbsp;         */
<i>4795</i>&nbsp;        @SuppressWarnings(&quot;overrides&quot;)
<i>4796</i>&nbsp;        class Candidate {
<i>4797</i>&nbsp;
<i>4798</i>&nbsp;            final MethodResolutionPhase step;
<i>4799</i>&nbsp;            final Symbol sym;
<i>4800</i>&nbsp;            final JCDiagnostic details;
<i>4801</i>&nbsp;            final Type mtype;
<i>4802</i>&nbsp;
<i>4803</i>&nbsp;            private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
<i>4804</i>&nbsp;                this.step = step;
<i>4805</i>&nbsp;                this.sym = sym;
<i>4806</i>&nbsp;                this.details = details;
<i>4807</i>&nbsp;                this.mtype = mtype;
<i>4808</i>&nbsp;            }
<i>4809</i>&nbsp;
<i>4810</i>&nbsp;            boolean isApplicable() {
<i>4811</i>&nbsp;                return mtype != null;
<i>4812</i>&nbsp;            }
<i>4813</i>&nbsp;        }
<i>4814</i>&nbsp;
<i>4815</i>&nbsp;        DeferredAttr.AttrMode attrMode() {
<i>4816</i>&nbsp;            return attrMode;
<i>4817</i>&nbsp;        }
<i>4818</i>&nbsp;
<i>4819</i>&nbsp;        boolean internal() {
<i>4820</i>&nbsp;            return internalResolution;
<i>4821</i>&nbsp;        }
<i>4822</i>&nbsp;    }
<i>4823</i>&nbsp;
<i>4824</i>&nbsp;    MethodResolutionContext currentResolutionContext = null;
<i>4825</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
