


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: LambdaToMethod</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.comp</a> ]
</div>

<h1>Coverage Summary for Class: LambdaToMethod (com.sun.tools.javac.comp)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">LambdaToMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 374)
  </span>
</td>
</tr>
  <tr>
    <td class="name">LambdaToMethod$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$1LambdaBodyTranslator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$KlassInfo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$L2MSignatureGenerator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 264)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$Frame</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 136)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$LambdaTranslationContext$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$ReferenceTranslationContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$SyntheticMethodNameCounter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaAnalyzerPreprocessor$TranslationContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$LambdaSymbolKind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">LambdaToMethod$MemberReferenceToLambda</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 91)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 128)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 997)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.comp;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.tools.javac.tree.*;
<i>29</i>&nbsp;import com.sun.tools.javac.tree.JCTree.*;
<i>30</i>&nbsp;import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
<i>31</i>&nbsp;import com.sun.tools.javac.tree.TreeMaker;
<i>32</i>&nbsp;import com.sun.tools.javac.tree.TreeTranslator;
<i>33</i>&nbsp;import com.sun.tools.javac.code.Attribute;
<i>34</i>&nbsp;import com.sun.tools.javac.code.Scope.WriteableScope;
<i>35</i>&nbsp;import com.sun.tools.javac.code.Symbol;
<i>36</i>&nbsp;import com.sun.tools.javac.code.Symbol.ClassSymbol;
<i>37</i>&nbsp;import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;
<i>38</i>&nbsp;import com.sun.tools.javac.code.Symbol.MethodSymbol;
<i>39</i>&nbsp;import com.sun.tools.javac.code.Symbol.TypeSymbol;
<i>40</i>&nbsp;import com.sun.tools.javac.code.Symbol.VarSymbol;
<i>41</i>&nbsp;import com.sun.tools.javac.code.Symtab;
<i>42</i>&nbsp;import com.sun.tools.javac.code.Type;
<i>43</i>&nbsp;import com.sun.tools.javac.code.Type.MethodType;
<i>44</i>&nbsp;import com.sun.tools.javac.code.Type.TypeVar;
<i>45</i>&nbsp;import com.sun.tools.javac.code.Types;
<i>46</i>&nbsp;import com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.*;
<i>47</i>&nbsp;import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;
<i>48</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Notes;
<i>49</i>&nbsp;import com.sun.tools.javac.jvm.*;
<i>50</i>&nbsp;import com.sun.tools.javac.util.*;
<i>51</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<i>52</i>&nbsp;import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
<i>53</i>&nbsp;
<i>54</i>&nbsp;import java.util.EnumMap;
<i>55</i>&nbsp;import java.util.HashMap;
<i>56</i>&nbsp;import java.util.HashSet;
<i>57</i>&nbsp;import java.util.LinkedHashMap;
<i>58</i>&nbsp;import java.util.Map;
<i>59</i>&nbsp;import java.util.Objects;
<i>60</i>&nbsp;import java.util.Optional;
<i>61</i>&nbsp;import java.util.Set;
<i>62</i>&nbsp;import java.util.function.Consumer;
<i>63</i>&nbsp;import java.util.function.Supplier;
<i>64</i>&nbsp;
<i>65</i>&nbsp;import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;
<i>66</i>&nbsp;import static com.sun.tools.javac.code.Flags.*;
<i>67</i>&nbsp;import static com.sun.tools.javac.code.Kinds.Kind.*;
<i>68</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.*;
<i>69</i>&nbsp;import static com.sun.tools.javac.tree.JCTree.Tag.*;
<i>70</i>&nbsp;import static com.sun.tools.javac.jvm.Pool.DynamicMethod;
<i>71</i>&nbsp;
<i>72</i>&nbsp;import javax.lang.model.element.ElementKind;
<i>73</i>&nbsp;import javax.lang.model.type.TypeKind;
<i>74</i>&nbsp;
<b class="nc"><i>75</i>&nbsp;import com.sun.tools.javac.code.Type.IntersectionClassType;</b>
<i>76</i>&nbsp;import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
<i>77</i>&nbsp;import com.sun.tools.javac.main.Option;
<i>78</i>&nbsp;
<i>79</i>&nbsp;/**
<i>80</i>&nbsp; * This pass desugars lambda expressions into static methods
<i>81</i>&nbsp; *
<i>82</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>83</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>84</i>&nbsp; *  This code and its internal interfaces are subject to change or
<i>85</i>&nbsp; *  deletion without notice.&lt;/b&gt;
<i>86</i>&nbsp; */
<i>87</i>&nbsp;public class LambdaToMethod extends TreeTranslator {
<i>88</i>&nbsp;
<i>89</i>&nbsp;    private Attr attr;
<i>90</i>&nbsp;    private JCDiagnostic.Factory diags;
<i>91</i>&nbsp;    private Log log;
<i>92</i>&nbsp;    private Lower lower;
<i>93</i>&nbsp;    private Names names;
<i>94</i>&nbsp;    private Symtab syms;
<i>95</i>&nbsp;    private Resolve rs;
<i>96</i>&nbsp;    private Operators operators;
<i>97</i>&nbsp;    private TreeMaker make;
<i>98</i>&nbsp;    private Types types;
<i>99</i>&nbsp;    private TransTypes transTypes;
<i>100</i>&nbsp;    private Env&lt;AttrContext&gt; attrEnv;
<i>101</i>&nbsp;
<i>102</i>&nbsp;    /** the analyzer scanner */
<i>103</i>&nbsp;    private LambdaAnalyzerPreprocessor analyzer;
<i>104</i>&nbsp;
<i>105</i>&nbsp;    /** map from lambda trees to translation contexts */
<i>106</i>&nbsp;    private Map&lt;JCTree, TranslationContext&lt;?&gt;&gt; contextMap;
<i>107</i>&nbsp;
<i>108</i>&nbsp;    /** current translation context (visitor argument) */
<i>109</i>&nbsp;    private TranslationContext&lt;?&gt; context;
<i>110</i>&nbsp;
<i>111</i>&nbsp;    /** info about the current class being processed */
<i>112</i>&nbsp;    private KlassInfo kInfo;
<i>113</i>&nbsp;
<i>114</i>&nbsp;    /** dump statistics about lambda code generation */
<i>115</i>&nbsp;    private final boolean dumpLambdaToMethodStats;
<i>116</i>&nbsp;
<b class="nc"><i>117</i>&nbsp;    /** force serializable representation, for stress testing **/</b>
<i>118</i>&nbsp;    private final boolean forceSerializable;
<i>119</i>&nbsp;
<i>120</i>&nbsp;    /** true if line or local variable debug info has been requested */
<b class="nc"><i>121</i>&nbsp;    private final boolean debugLinesOrVars;</b>
<b class="nc"><i>122</i>&nbsp;</b>
<b class="nc"><i>123</i>&nbsp;    /** dump statistics about lambda method deduplication */</b>
<i>124</i>&nbsp;    private final boolean verboseDeduplication;
<b class="nc"><i>125</i>&nbsp;</b>
<i>126</i>&nbsp;    /** deduplicate lambda implementation methods */
<b class="nc"><i>127</i>&nbsp;    private final boolean deduplicateLambdas;</b>
<b class="nc"><i>128</i>&nbsp;</b>
<b class="nc"><i>129</i>&nbsp;    /** Flag for alternate metafactories indicating the lambda object is intended to be serializable */</b>
<b class="nc"><i>130</i>&nbsp;    public static final int FLAG_SERIALIZABLE = 1 &lt;&lt; 0;</b>
<b class="nc"><i>131</i>&nbsp;</b>
<b class="nc"><i>132</i>&nbsp;    /** Flag for alternate metafactories indicating the lambda object has multiple targets */</b>
<b class="nc"><i>133</i>&nbsp;    public static final int FLAG_MARKERS = 1 &lt;&lt; 1;</b>
<b class="nc"><i>134</i>&nbsp;</b>
<b class="nc"><i>135</i>&nbsp;    /** Flag for alternate metafactories indicating the lambda object requires multiple bridges */</b>
<b class="nc"><i>136</i>&nbsp;    public static final int FLAG_BRIDGES = 1 &lt;&lt; 2;</b>
<b class="nc"><i>137</i>&nbsp;</b>
<b class="nc"><i>138</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;</b>
<b class="nc"><i>139</i>&nbsp;    protected static final Context.Key&lt;LambdaToMethod&gt; unlambdaKey = new Context.Key&lt;&gt;();</b>
<b class="nc"><i>140</i>&nbsp;</b>
<b class="nc"><i>141</i>&nbsp;    public static LambdaToMethod instance(Context context) {</b>
<b class="nc"><i>142</i>&nbsp;        LambdaToMethod instance = context.get(unlambdaKey);</b>
<i>143</i>&nbsp;        if (instance == null) {
<i>144</i>&nbsp;            instance = new LambdaToMethod(context);
<i>145</i>&nbsp;        }
<b class="nc"><i>146</i>&nbsp;        return instance;</b>
<i>147</i>&nbsp;    }
<i>148</i>&nbsp;    private LambdaToMethod(Context context) {
<i>149</i>&nbsp;        context.put(unlambdaKey, this);
<i>150</i>&nbsp;        diags = JCDiagnostic.Factory.instance(context);
<i>151</i>&nbsp;        log = Log.instance(context);
<i>152</i>&nbsp;        lower = Lower.instance(context);
<i>153</i>&nbsp;        names = Names.instance(context);
<i>154</i>&nbsp;        syms = Symtab.instance(context);
<i>155</i>&nbsp;        rs = Resolve.instance(context);
<i>156</i>&nbsp;        operators = Operators.instance(context);
<i>157</i>&nbsp;        make = TreeMaker.instance(context);
<i>158</i>&nbsp;        types = Types.instance(context);
<i>159</i>&nbsp;        transTypes = TransTypes.instance(context);
<i>160</i>&nbsp;        analyzer = new LambdaAnalyzerPreprocessor();
<i>161</i>&nbsp;        Options options = Options.instance(context);
<i>162</i>&nbsp;        dumpLambdaToMethodStats = options.isSet(&quot;debug.dumpLambdaToMethodStats&quot;);
<i>163</i>&nbsp;        attr = Attr.instance(context);
<i>164</i>&nbsp;        forceSerializable = options.isSet(&quot;forceSerializable&quot;);
<i>165</i>&nbsp;        debugLinesOrVars = options.isSet(Option.G)
<i>166</i>&nbsp;                || options.isSet(Option.G_CUSTOM, &quot;lines&quot;)
<i>167</i>&nbsp;                || options.isSet(Option.G_CUSTOM, &quot;vars&quot;);
<i>168</i>&nbsp;        verboseDeduplication = options.isSet(&quot;debug.dumpLambdaToMethodDeduplication&quot;);
<i>169</i>&nbsp;        deduplicateLambdas = options.getBoolean(&quot;deduplicateLambdas&quot;, true);
<b class="nc"><i>170</i>&nbsp;    }</b>
<b class="nc"><i>171</i>&nbsp;    // &lt;/editor-fold&gt;</b>
<b class="nc"><i>172</i>&nbsp;</b>
<b class="nc"><i>173</i>&nbsp;    class DedupedLambda {</b>
<b class="nc"><i>174</i>&nbsp;        private final MethodSymbol symbol;</b>
<b class="nc"><i>175</i>&nbsp;        private final JCTree tree;</b>
<b class="nc"><i>176</i>&nbsp;</b>
<b class="nc"><i>177</i>&nbsp;        private int hashCode;</b>
<b class="nc"><i>178</i>&nbsp;</b>
<i>179</i>&nbsp;        DedupedLambda(MethodSymbol symbol, JCTree tree) {
<i>180</i>&nbsp;            this.symbol = symbol;
<i>181</i>&nbsp;            this.tree = tree;
<b class="nc"><i>182</i>&nbsp;        }</b>
<i>183</i>&nbsp;
<i>184</i>&nbsp;
<i>185</i>&nbsp;        @Override
<i>186</i>&nbsp;        public int hashCode() {
<i>187</i>&nbsp;            int hashCode = this.hashCode;
<i>188</i>&nbsp;            if (hashCode == 0) {
<b class="nc"><i>189</i>&nbsp;                this.hashCode = hashCode = TreeHasher.hash(tree, symbol.params());</b>
<b class="nc"><i>190</i>&nbsp;            }</b>
<i>191</i>&nbsp;            return hashCode;
<i>192</i>&nbsp;        }
<i>193</i>&nbsp;
<b class="nc"><i>194</i>&nbsp;        @Override</b>
<i>195</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>196</i>&nbsp;            if (!(o instanceof DedupedLambda)) {</b>
<b class="nc"><i>197</i>&nbsp;                return false;</b>
<i>198</i>&nbsp;            }
<i>199</i>&nbsp;            DedupedLambda that = (DedupedLambda) o;
<b class="nc"><i>200</i>&nbsp;            return types.isSameType(symbol.asType(), that.symbol.asType())</b>
<i>201</i>&nbsp;                    &amp;&amp; new TreeDiffer(symbol.params(), that.symbol.params()).scan(tree, that.tree);
<i>202</i>&nbsp;        }
<i>203</i>&nbsp;    }
<i>204</i>&nbsp;
<b class="nc"><i>205</i>&nbsp;    private class KlassInfo {</b>
<b class="nc"><i>206</i>&nbsp;</b>
<b class="nc"><i>207</i>&nbsp;        /**</b>
<b class="nc"><i>208</i>&nbsp;         * list of methods to append</b>
<b class="nc"><i>209</i>&nbsp;         */</b>
<i>210</i>&nbsp;        private ListBuffer&lt;JCTree&gt; appendedMethodList;
<i>211</i>&nbsp;
<i>212</i>&nbsp;        private Map&lt;DedupedLambda, DedupedLambda&gt; dedupedLambdas;
<b class="nc"><i>213</i>&nbsp;</b>
<b class="nc"><i>214</i>&nbsp;        private Map&lt;DynamicMethod, DynamicMethodSymbol&gt; dynMethSyms = new HashMap&lt;&gt;();</b>
<b class="nc"><i>215</i>&nbsp;</b>
<b class="nc"><i>216</i>&nbsp;        /**</b>
<b class="nc"><i>217</i>&nbsp;         * list of deserialization cases</b>
<i>218</i>&nbsp;         */
<i>219</i>&nbsp;        private final Map&lt;String, ListBuffer&lt;JCStatement&gt;&gt; deserializeCases;
<i>220</i>&nbsp;
<i>221</i>&nbsp;       /**
<i>222</i>&nbsp;         * deserialize method symbol
<i>223</i>&nbsp;         */
<i>224</i>&nbsp;        private final MethodSymbol deserMethodSym;
<i>225</i>&nbsp;
<i>226</i>&nbsp;        /**
<i>227</i>&nbsp;         * deserialize method parameter symbol
<i>228</i>&nbsp;         */
<i>229</i>&nbsp;        private final VarSymbol deserParamSym;
<b class="nc"><i>230</i>&nbsp;</b>
<i>231</i>&nbsp;        private final JCClassDecl clazz;
<b class="nc"><i>232</i>&nbsp;</b>
<i>233</i>&nbsp;        private KlassInfo(JCClassDecl clazz) {
<b class="nc"><i>234</i>&nbsp;            this.clazz = clazz;</b>
<i>235</i>&nbsp;            appendedMethodList = new ListBuffer&lt;&gt;();
<b class="nc"><i>236</i>&nbsp;            dedupedLambdas = new HashMap&lt;&gt;();</b>
<b class="nc"><i>237</i>&nbsp;            deserializeCases = new HashMap&lt;&gt;();</b>
<b class="nc"><i>238</i>&nbsp;            MethodType type = new MethodType(List.of(syms.serializedLambdaType), syms.objectType,</b>
<b class="nc"><i>239</i>&nbsp;                    List.nil(), syms.methodClass);</b>
<i>240</i>&nbsp;            deserMethodSym = makePrivateSyntheticMethod(STATIC, names.deserializeLambda, type, clazz.sym);
<b class="nc"><i>241</i>&nbsp;            deserParamSym = new VarSymbol(FINAL, names.fromString(&quot;lambda&quot;),</b>
<b class="nc"><i>242</i>&nbsp;                    syms.serializedLambdaType, deserMethodSym);</b>
<i>243</i>&nbsp;        }
<b class="nc"><i>244</i>&nbsp;</b>
<b class="nc"><i>245</i>&nbsp;        private void addMethod(JCTree decl) {</b>
<i>246</i>&nbsp;            appendedMethodList = appendedMethodList.prepend(decl);
<i>247</i>&nbsp;        }
<b class="nc"><i>248</i>&nbsp;    }</b>
<b class="nc"><i>249</i>&nbsp;</b>
<b class="nc"><i>250</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;translate methods&quot;&gt;</b>
<b class="nc"><i>251</i>&nbsp;    @Override</b>
<b class="nc"><i>252</i>&nbsp;    public &lt;T extends JCTree&gt; T translate(T tree) {</b>
<b class="nc"><i>253</i>&nbsp;        TranslationContext&lt;?&gt; newContext = contextMap.get(tree);</b>
<i>254</i>&nbsp;        return translate(tree, newContext != null ? newContext : context);
<b class="nc"><i>255</i>&nbsp;    }</b>
<b class="nc"><i>256</i>&nbsp;</b>
<i>257</i>&nbsp;    &lt;T extends JCTree&gt; T translate(T tree, TranslationContext&lt;?&gt; newContext) {
<i>258</i>&nbsp;        TranslationContext&lt;?&gt; prevContext = context;
<i>259</i>&nbsp;        try {
<i>260</i>&nbsp;            context = newContext;
<i>261</i>&nbsp;            return super.translate(tree);
<i>262</i>&nbsp;        }
<i>263</i>&nbsp;        finally {
<i>264</i>&nbsp;            context = prevContext;
<i>265</i>&nbsp;        }
<i>266</i>&nbsp;    }
<b class="nc"><i>267</i>&nbsp;</b>
<b class="nc"><i>268</i>&nbsp;    &lt;T extends JCTree&gt; List&lt;T&gt; translate(List&lt;T&gt; trees, TranslationContext&lt;?&gt; newContext) {</b>
<b class="nc"><i>269</i>&nbsp;        ListBuffer&lt;T&gt; buf = new ListBuffer&lt;&gt;();</b>
<i>270</i>&nbsp;        for (T tree : trees) {
<i>271</i>&nbsp;            buf.append(translate(tree, newContext));
<b class="nc"><i>272</i>&nbsp;        }</b>
<b class="nc"><i>273</i>&nbsp;        return buf.toList();</b>
<b class="nc"><i>274</i>&nbsp;    }</b>
<i>275</i>&nbsp;
<b class="nc"><i>276</i>&nbsp;    public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {</b>
<b class="nc"><i>277</i>&nbsp;        this.make = make;</b>
<b class="nc"><i>278</i>&nbsp;        this.attrEnv = env;</b>
<i>279</i>&nbsp;        this.context = null;
<b class="nc"><i>280</i>&nbsp;        this.contextMap = new HashMap&lt;&gt;();</b>
<i>281</i>&nbsp;        return translate(cdef);
<b class="nc"><i>282</i>&nbsp;    }</b>
<b class="nc"><i>283</i>&nbsp;    // &lt;/editor-fold&gt;</b>
<b class="nc"><i>284</i>&nbsp;</b>
<b class="nc"><i>285</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;visitor methods&quot;&gt;</b>
<i>286</i>&nbsp;    /**
<i>287</i>&nbsp;     * Visit a class.
<i>288</i>&nbsp;     * Maintain the translatedMethodList across nested classes.
<i>289</i>&nbsp;     * Append the translatedMethodList to the class after it is translated.
<b class="nc"><i>290</i>&nbsp;     * @param tree</b>
<i>291</i>&nbsp;     */
<b class="nc"><i>292</i>&nbsp;    @Override</b>
<b class="nc"><i>293</i>&nbsp;    public void visitClassDef(JCClassDecl tree) {</b>
<i>294</i>&nbsp;        if (tree.sym.owner.kind == PCK) {
<b class="nc"><i>295</i>&nbsp;            //analyze class</b>
<b class="nc"><i>296</i>&nbsp;            tree = analyzer.analyzeAndPreprocessClass(tree);</b>
<b class="nc"><i>297</i>&nbsp;        }</b>
<i>298</i>&nbsp;        KlassInfo prevKlassInfo = kInfo;
<i>299</i>&nbsp;        try {
<b class="nc"><i>300</i>&nbsp;            kInfo = new KlassInfo(tree);</b>
<b class="nc"><i>301</i>&nbsp;            super.visitClassDef(tree);</b>
<i>302</i>&nbsp;            if (!kInfo.deserializeCases.isEmpty()) {
<i>303</i>&nbsp;                int prevPos = make.pos;
<i>304</i>&nbsp;                try {
<i>305</i>&nbsp;                    make.at(tree);
<i>306</i>&nbsp;                    kInfo.addMethod(makeDeserializeMethod(tree.sym));
<i>307</i>&nbsp;                } finally {
<b class="nc"><i>308</i>&nbsp;                    make.at(prevPos);</b>
<i>309</i>&nbsp;                }
<i>310</i>&nbsp;            }
<b class="nc"><i>311</i>&nbsp;            //add all translated instance methods here</b>
<i>312</i>&nbsp;            List&lt;JCTree&gt; newMethods = kInfo.appendedMethodList.toList();
<i>313</i>&nbsp;            tree.defs = tree.defs.appendList(newMethods);
<i>314</i>&nbsp;            for (JCTree lambda : newMethods) {
<i>315</i>&nbsp;                tree.sym.members().enter(((JCMethodDecl)lambda).sym);
<i>316</i>&nbsp;            }
<i>317</i>&nbsp;            result = tree;
<i>318</i>&nbsp;        } finally {
<i>319</i>&nbsp;            kInfo = prevKlassInfo;
<i>320</i>&nbsp;        }
<i>321</i>&nbsp;    }
<i>322</i>&nbsp;
<i>323</i>&nbsp;    /**
<b class="nc"><i>324</i>&nbsp;     * Translate a lambda into a method to be inserted into the class.</b>
<i>325</i>&nbsp;     * Then replace the lambda site with an invokedynamic call of to lambda
<b class="nc"><i>326</i>&nbsp;     * meta-factory, which will use the lambda method.</b>
<b class="nc"><i>327</i>&nbsp;     * @param tree</b>
<b class="nc"><i>328</i>&nbsp;     */</b>
<b class="nc"><i>329</i>&nbsp;    @Override</b>
<b class="nc"><i>330</i>&nbsp;    public void visitLambda(JCLambda tree) {</b>
<b class="nc"><i>331</i>&nbsp;        LambdaTranslationContext localContext = (LambdaTranslationContext)context;</b>
<i>332</i>&nbsp;        MethodSymbol sym = localContext.translatedSym;
<i>333</i>&nbsp;        MethodType lambdaType = (MethodType) sym.type;
<i>334</i>&nbsp;
<b class="nc"><i>335</i>&nbsp;        {   /* Type annotation management: Based on where the lambda features, type annotations that</b>
<b class="nc"><i>336</i>&nbsp;               are interior to it, may at this point be attached to the enclosing method, or the first</b>
<b class="nc"><i>337</i>&nbsp;               constructor in the class, or in the enclosing class symbol or in the field whose</b>
<b class="nc"><i>338</i>&nbsp;               initializer is the lambda. In any event, gather up the annotations that belong to the</b>
<i>339</i>&nbsp;               lambda and attach it to the implementation method.
<b class="nc"><i>340</i>&nbsp;            */</b>
<i>341</i>&nbsp;
<b class="nc"><i>342</i>&nbsp;            Symbol owner = localContext.owner;</b>
<b class="nc"><i>343</i>&nbsp;            apportionTypeAnnotations(tree,</b>
<b class="nc"><i>344</i>&nbsp;                    owner::getRawTypeAttributes,</b>
<b class="nc"><i>345</i>&nbsp;                    owner::setTypeAttributes,</b>
<i>346</i>&nbsp;                    sym::setTypeAttributes);
<i>347</i>&nbsp;
<b class="nc"><i>348</i>&nbsp;</b>
<i>349</i>&nbsp;            boolean init;
<i>350</i>&nbsp;            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {
<b class="nc"><i>351</i>&nbsp;                owner = owner.owner;</b>
<i>352</i>&nbsp;                apportionTypeAnnotations(tree,
<i>353</i>&nbsp;                        init ? owner::getInitTypeAttributes : owner::getClassInitTypeAttributes,
<b class="nc"><i>354</i>&nbsp;                        init ? owner::setInitTypeAttributes : owner::setClassInitTypeAttributes,</b>
<i>355</i>&nbsp;                        sym::appendUniqueTypeAttributes);
<i>356</i>&nbsp;            }
<i>357</i>&nbsp;            if (localContext.self != null &amp;&amp; localContext.self.getKind() == ElementKind.FIELD) {
<b class="nc"><i>358</i>&nbsp;                owner = localContext.self;</b>
<i>359</i>&nbsp;                apportionTypeAnnotations(tree,
<i>360</i>&nbsp;                        owner::getRawTypeAttributes,
<i>361</i>&nbsp;                        owner::setTypeAttributes,
<b class="nc"><i>362</i>&nbsp;                        sym::appendUniqueTypeAttributes);</b>
<i>363</i>&nbsp;            }
<i>364</i>&nbsp;        }
<i>365</i>&nbsp;
<i>366</i>&nbsp;        //create the method declaration hoisting the lambda body
<i>367</i>&nbsp;        JCMethodDecl lambdaDecl = make.MethodDef(make.Modifiers(sym.flags_field),
<i>368</i>&nbsp;                sym.name,
<i>369</i>&nbsp;                make.QualIdent(lambdaType.getReturnType().tsym),
<i>370</i>&nbsp;                List.nil(),
<i>371</i>&nbsp;                localContext.syntheticParams,
<b class="nc"><i>372</i>&nbsp;                lambdaType.getThrownTypes() == null ?</b>
<i>373</i>&nbsp;                    List.nil() :
<i>374</i>&nbsp;                    make.Types(lambdaType.getThrownTypes()),
<i>375</i>&nbsp;                null,
<b class="nc"><i>376</i>&nbsp;                null);</b>
<i>377</i>&nbsp;        lambdaDecl.sym = sym;
<i>378</i>&nbsp;        lambdaDecl.type = lambdaType;
<i>379</i>&nbsp;
<i>380</i>&nbsp;        //translate lambda body
<i>381</i>&nbsp;        //As the lambda body is translated, all references to lambda locals,
<b class="nc"><i>382</i>&nbsp;        //captured variables, enclosing members are adjusted accordingly</b>
<i>383</i>&nbsp;        //to refer to the static method parameters (rather than i.e. acessing to
<i>384</i>&nbsp;        //captured members directly).
<i>385</i>&nbsp;        lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
<b class="nc"><i>386</i>&nbsp;</b>
<b class="nc"><i>387</i>&nbsp;        boolean dedupe = false;</b>
<b class="nc"><i>388</i>&nbsp;        if (deduplicateLambdas &amp;&amp; !debugLinesOrVars &amp;&amp; !localContext.isSerializable()) {</b>
<b class="nc"><i>389</i>&nbsp;            DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);</b>
<i>390</i>&nbsp;            DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);
<i>391</i>&nbsp;            if (existing != null) {
<b class="nc"><i>392</i>&nbsp;                sym = existing.symbol;</b>
<b class="nc"><i>393</i>&nbsp;                dedupe = true;</b>
<b class="nc"><i>394</i>&nbsp;                if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));</b>
<i>395</i>&nbsp;            }
<i>396</i>&nbsp;        }
<i>397</i>&nbsp;        if (!dedupe) {
<i>398</i>&nbsp;            //Add the method to the list of methods to be added to this class.
<i>399</i>&nbsp;            kInfo.addMethod(lambdaDecl);
<b class="nc"><i>400</i>&nbsp;        }</b>
<b class="nc"><i>401</i>&nbsp;</b>
<i>402</i>&nbsp;        //now that we have generated a method for the lambda expression,
<i>403</i>&nbsp;        //we can translate the lambda into a method reference pointing to the newly
<b class="nc"><i>404</i>&nbsp;        //created method.</b>
<i>405</i>&nbsp;        //
<i>406</i>&nbsp;        //Note that we need to adjust the method handle so that it will match the
<b class="nc"><i>407</i>&nbsp;        //signature of the SAM descriptor - this means that the method reference</b>
<i>408</i>&nbsp;        //should be added the following synthetic arguments:
<i>409</i>&nbsp;        //
<i>410</i>&nbsp;        // * the &quot;this&quot; argument if it is an instance method
<b class="nc"><i>411</i>&nbsp;        // * enclosing locals captured by the lambda expression</b>
<i>412</i>&nbsp;
<i>413</i>&nbsp;        ListBuffer&lt;JCExpression&gt; syntheticInits = new ListBuffer&lt;&gt;();
<i>414</i>&nbsp;
<i>415</i>&nbsp;        if (localContext.methodReferenceReceiver != null) {
<i>416</i>&nbsp;            syntheticInits.append(localContext.methodReferenceReceiver);
<i>417</i>&nbsp;        } else if (!sym.isStatic()) {
<i>418</i>&nbsp;            syntheticInits.append(makeThis(
<i>419</i>&nbsp;                    sym.owner.enclClass().asType(),
<b class="nc"><i>420</i>&nbsp;                    localContext.owner.enclClass()));</b>
<b class="nc"><i>421</i>&nbsp;        }</b>
<i>422</i>&nbsp;
<b class="nc"><i>423</i>&nbsp;        //add captured locals</b>
<i>424</i>&nbsp;        for (Symbol fv : localContext.getSymbolMap(CAPTURED_VAR).keySet()) {
<b class="nc"><i>425</i>&nbsp;            if (fv != localContext.self) {</b>
<i>426</i>&nbsp;                JCTree captured_local = make.Ident(fv).setType(fv.type);
<b class="nc"><i>427</i>&nbsp;                syntheticInits.append((JCExpression) captured_local);</b>
<b class="nc"><i>428</i>&nbsp;            }</b>
<b class="nc"><i>429</i>&nbsp;        }</b>
<b class="nc"><i>430</i>&nbsp;        // add captured outer this instances (used only when `this&#39; capture itself is illegal)</b>
<i>431</i>&nbsp;        for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {
<i>432</i>&nbsp;            JCTree captured_local = make.QualThis(fv.type);
<i>433</i>&nbsp;            syntheticInits.append((JCExpression) captured_local);
<b class="nc"><i>434</i>&nbsp;        }</b>
<i>435</i>&nbsp;
<i>436</i>&nbsp;        //then, determine the arguments to the indy call
<b class="nc"><i>437</i>&nbsp;        List&lt;JCExpression&gt; indy_args = translate(syntheticInits.toList(), localContext.prev);</b>
<b class="nc"><i>438</i>&nbsp;</b>
<i>439</i>&nbsp;        //build a sam instance using an indy call to the meta-factory
<i>440</i>&nbsp;        int refKind = referenceKind(sym);
<i>441</i>&nbsp;
<i>442</i>&nbsp;        //convert to an invokedynamic call
<i>443</i>&nbsp;        result = makeMetafactoryIndyCall(context, refKind, sym, indy_args);
<i>444</i>&nbsp;    }
<i>445</i>&nbsp;
<i>446</i>&nbsp;    // where
<i>447</i>&nbsp;        // Reassign type annotations from the source that should really belong to the lambda
<b class="nc"><i>448</i>&nbsp;        private void apportionTypeAnnotations(JCLambda tree,</b>
<b class="nc"><i>449</i>&nbsp;                                              Supplier&lt;List&lt;Attribute.TypeCompound&gt;&gt; source,</b>
<i>450</i>&nbsp;                                              Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; owner,
<b class="nc"><i>451</i>&nbsp;                                              Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; lambda) {</b>
<i>452</i>&nbsp;
<b class="nc"><i>453</i>&nbsp;            ListBuffer&lt;Attribute.TypeCompound&gt; ownerTypeAnnos = new ListBuffer&lt;&gt;();</b>
<i>454</i>&nbsp;            ListBuffer&lt;Attribute.TypeCompound&gt; lambdaTypeAnnos = new ListBuffer&lt;&gt;();
<b class="nc"><i>455</i>&nbsp;</b>
<b class="nc"><i>456</i>&nbsp;            for (Attribute.TypeCompound tc : source.get()) {</b>
<b class="nc"><i>457</i>&nbsp;                if (tc.position.onLambda == tree) {</b>
<b class="nc"><i>458</i>&nbsp;                    lambdaTypeAnnos.append(tc);</b>
<i>459</i>&nbsp;                } else {
<b class="nc"><i>460</i>&nbsp;                    ownerTypeAnnos.append(tc);</b>
<i>461</i>&nbsp;                }
<i>462</i>&nbsp;            }
<b class="nc"><i>463</i>&nbsp;            if (lambdaTypeAnnos.nonEmpty()) {</b>
<b class="nc"><i>464</i>&nbsp;                owner.accept(ownerTypeAnnos.toList());</b>
<i>465</i>&nbsp;                lambda.accept(lambdaTypeAnnos.toList());
<i>466</i>&nbsp;            }
<i>467</i>&nbsp;        }
<i>468</i>&nbsp;
<i>469</i>&nbsp;    private JCIdent makeThis(Type type, Symbol owner) {
<b class="nc"><i>470</i>&nbsp;        VarSymbol _this = new VarSymbol(PARAMETER | FINAL | SYNTHETIC,</b>
<b class="nc"><i>471</i>&nbsp;                names._this,</b>
<b class="nc"><i>472</i>&nbsp;                type,</b>
<b class="nc"><i>473</i>&nbsp;                owner);</b>
<b class="nc"><i>474</i>&nbsp;        return make.Ident(_this);</b>
<b class="nc"><i>475</i>&nbsp;    }</b>
<b class="nc"><i>476</i>&nbsp;</b>
<b class="nc"><i>477</i>&nbsp;    /**</b>
<b class="nc"><i>478</i>&nbsp;     * Translate a method reference into an invokedynamic call to the</b>
<i>479</i>&nbsp;     * meta-factory.
<b class="nc"><i>480</i>&nbsp;     * @param tree</b>
<i>481</i>&nbsp;     */
<b class="nc"><i>482</i>&nbsp;    @Override</b>
<b class="nc"><i>483</i>&nbsp;    public void visitReference(JCMemberReference tree) {</b>
<i>484</i>&nbsp;        ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
<b class="nc"><i>485</i>&nbsp;</b>
<b class="nc"><i>486</i>&nbsp;        //first determine the method symbol to be used to generate the sam instance</b>
<b class="nc"><i>487</i>&nbsp;        //this is either the method reference symbol, or the bridged reference symbol</b>
<b class="nc"><i>488</i>&nbsp;        Symbol refSym = tree.sym;</b>
<i>489</i>&nbsp;
<b class="nc"><i>490</i>&nbsp;        //the qualifying expression is treated as a special captured arg</b>
<b class="nc"><i>491</i>&nbsp;        JCExpression init;</b>
<i>492</i>&nbsp;        switch(tree.kind) {
<i>493</i>&nbsp;
<i>494</i>&nbsp;            case IMPLICIT_INNER:    /** Inner :: new */
<i>495</i>&nbsp;            case SUPER:             /** super :: instMethod */
<i>496</i>&nbsp;                init = makeThis(
<i>497</i>&nbsp;                    localContext.owner.enclClass().asType(),
<i>498</i>&nbsp;                    localContext.owner.enclClass());
<i>499</i>&nbsp;                break;
<b class="nc"><i>500</i>&nbsp;</b>
<b class="nc"><i>501</i>&nbsp;            case BOUND:             /** Expr :: instMethod */</b>
<b class="nc"><i>502</i>&nbsp;                init = tree.getQualifierExpression();</b>
<i>503</i>&nbsp;                init = attr.makeNullCheck(init);
<i>504</i>&nbsp;                break;
<i>505</i>&nbsp;
<b class="nc"><i>506</i>&nbsp;            case UNBOUND:           /** Type :: instMethod */</b>
<b class="nc"><i>507</i>&nbsp;            case STATIC:            /** Type :: staticMethod */</b>
<b class="nc"><i>508</i>&nbsp;            case TOPLEVEL:          /** Top level :: new */</b>
<b class="nc"><i>509</i>&nbsp;            case ARRAY_CTOR:        /** ArrayType :: new */</b>
<b class="nc"><i>510</i>&nbsp;                init = null;</b>
<i>511</i>&nbsp;                break;
<b class="nc"><i>512</i>&nbsp;</b>
<i>513</i>&nbsp;            default:
<i>514</i>&nbsp;                throw new InternalError(&quot;Should not have an invalid kind&quot;);
<b class="nc"><i>515</i>&nbsp;        }</b>
<b class="nc"><i>516</i>&nbsp;</b>
<b class="nc"><i>517</i>&nbsp;        List&lt;JCExpression&gt; indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);</b>
<i>518</i>&nbsp;
<i>519</i>&nbsp;
<b class="nc"><i>520</i>&nbsp;        //build a sam instance using an indy call to the meta-factory</b>
<b class="nc"><i>521</i>&nbsp;        result = makeMetafactoryIndyCall(localContext, localContext.referenceKind(), refSym, indy_args);</b>
<b class="nc"><i>522</i>&nbsp;    }</b>
<b class="nc"><i>523</i>&nbsp;</b>
<i>524</i>&nbsp;    /**
<i>525</i>&nbsp;     * Translate identifiers within a lambda to the mapped identifier
<i>526</i>&nbsp;     * @param tree
<b class="nc"><i>527</i>&nbsp;     */</b>
<b class="nc"><i>528</i>&nbsp;    @Override</b>
<i>529</i>&nbsp;    public void visitIdent(JCIdent tree) {
<i>530</i>&nbsp;        if (context == null || !analyzer.lambdaIdentSymbolFilter(tree.sym)) {
<b class="nc"><i>531</i>&nbsp;            super.visitIdent(tree);</b>
<i>532</i>&nbsp;        } else {
<i>533</i>&nbsp;            int prevPos = make.pos;
<i>534</i>&nbsp;            try {
<i>535</i>&nbsp;                make.at(tree);
<b class="nc"><i>536</i>&nbsp;</b>
<b class="nc"><i>537</i>&nbsp;                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;</b>
<b class="nc"><i>538</i>&nbsp;                JCTree ltree = lambdaContext.translate(tree);</b>
<i>539</i>&nbsp;                if (ltree != null) {
<b class="nc"><i>540</i>&nbsp;                    result = ltree;</b>
<i>541</i>&nbsp;                } else {
<i>542</i>&nbsp;                    //access to untranslated symbols (i.e. compile-time constants,
<i>543</i>&nbsp;                    //members defined inside the lambda body, etc.) )
<i>544</i>&nbsp;                    super.visitIdent(tree);
<b class="nc"><i>545</i>&nbsp;                }</b>
<i>546</i>&nbsp;            } finally {
<i>547</i>&nbsp;                make.at(prevPos);
<i>548</i>&nbsp;            }
<i>549</i>&nbsp;        }
<i>550</i>&nbsp;    }
<b class="nc"><i>551</i>&nbsp;</b>
<i>552</i>&nbsp;    /**
<i>553</i>&nbsp;     * Translate qualified `this&#39; references within a lambda to the mapped identifier
<i>554</i>&nbsp;     * @param tree
<i>555</i>&nbsp;     */
<b class="nc"><i>556</i>&nbsp;    @Override</b>
<b class="nc"><i>557</i>&nbsp;    public void visitSelect(JCFieldAccess tree) {</b>
<i>558</i>&nbsp;        if (context == null || !analyzer.lambdaFieldAccessFilter(tree)) {
<i>559</i>&nbsp;            super.visitSelect(tree);
<b class="nc"><i>560</i>&nbsp;        } else {</b>
<b class="nc"><i>561</i>&nbsp;            int prevPos = make.pos;</b>
<b class="nc"><i>562</i>&nbsp;            try {</b>
<b class="nc"><i>563</i>&nbsp;                make.at(tree);</b>
<i>564</i>&nbsp;
<i>565</i>&nbsp;                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;
<b class="nc"><i>566</i>&nbsp;                JCTree ltree = lambdaContext.translate(tree);</b>
<b class="nc"><i>567</i>&nbsp;                if (ltree != null) {</b>
<i>568</i>&nbsp;                    result = ltree;
<b class="nc"><i>569</i>&nbsp;                } else {</b>
<i>570</i>&nbsp;                    super.visitSelect(tree);
<i>571</i>&nbsp;                }
<i>572</i>&nbsp;            } finally {
<i>573</i>&nbsp;                make.at(prevPos);
<i>574</i>&nbsp;            }
<b class="nc"><i>575</i>&nbsp;        }</b>
<b class="nc"><i>576</i>&nbsp;    }</b>
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<b class="nc"><i>579</i>&nbsp;     * Translate instance creation expressions with implicit enclosing instances</b>
<i>580</i>&nbsp;     * @param tree
<b class="nc"><i>581</i>&nbsp;     */</b>
<i>582</i>&nbsp;    @Override
<i>583</i>&nbsp;    public void visitNewClass(JCNewClass tree) {
<i>584</i>&nbsp;        if (context == null || !analyzer.lambdaNewClassFilter(context, tree)) {
<b class="nc"><i>585</i>&nbsp;            super.visitNewClass(tree);</b>
<b class="nc"><i>586</i>&nbsp;        } else {</b>
<b class="nc"><i>587</i>&nbsp;            int prevPos = make.pos;</b>
<b class="nc"><i>588</i>&nbsp;            try {</b>
<b class="nc"><i>589</i>&nbsp;                make.at(tree);</b>
<b class="nc"><i>590</i>&nbsp;</b>
<b class="nc"><i>591</i>&nbsp;                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;</b>
<b class="nc"><i>592</i>&nbsp;                tree = lambdaContext.translate(tree);</b>
<b class="nc"><i>593</i>&nbsp;                super.visitNewClass(tree);</b>
<b class="nc"><i>594</i>&nbsp;            } finally {</b>
<b class="nc"><i>595</i>&nbsp;                make.at(prevPos);</b>
<b class="nc"><i>596</i>&nbsp;            }</b>
<b class="nc"><i>597</i>&nbsp;        }</b>
<i>598</i>&nbsp;    }
<b class="nc"><i>599</i>&nbsp;</b>
<i>600</i>&nbsp;    @Override
<b class="nc"><i>601</i>&nbsp;    public void visitVarDef(JCVariableDecl tree) {</b>
<b class="nc"><i>602</i>&nbsp;        LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;</b>
<i>603</i>&nbsp;        if (context != null &amp;&amp; lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {
<b class="nc"><i>604</i>&nbsp;            tree.init = translate(tree.init);</b>
<b class="nc"><i>605</i>&nbsp;            tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);</b>
<b class="nc"><i>606</i>&nbsp;            result = tree;</b>
<b class="nc"><i>607</i>&nbsp;        } else if (context != null &amp;&amp; lambdaContext.getSymbolMap(TYPE_VAR).containsKey(tree.sym)) {</b>
<i>608</i>&nbsp;            JCExpression init = translate(tree.init);
<i>609</i>&nbsp;            VarSymbol xsym = (VarSymbol)lambdaContext.getSymbolMap(TYPE_VAR).get(tree.sym);
<b class="nc"><i>610</i>&nbsp;            int prevPos = make.pos;</b>
<b class="nc"><i>611</i>&nbsp;            try {</b>
<i>612</i>&nbsp;                result = make.at(tree).VarDef(xsym, init);
<b class="nc"><i>613</i>&nbsp;            } finally {</b>
<i>614</i>&nbsp;                make.at(prevPos);
<i>615</i>&nbsp;            }
<i>616</i>&nbsp;            // Replace the entered symbol for this variable
<i>617</i>&nbsp;            WriteableScope sc = tree.sym.owner.members();
<i>618</i>&nbsp;            if (sc != null) {
<i>619</i>&nbsp;                sc.remove(tree.sym);
<i>620</i>&nbsp;                sc.enter(xsym);
<i>621</i>&nbsp;            }
<b class="nc"><i>622</i>&nbsp;        } else {</b>
<b class="nc"><i>623</i>&nbsp;            super.visitVarDef(tree);</b>
<b class="nc"><i>624</i>&nbsp;        }</b>
<b class="nc"><i>625</i>&nbsp;    }</b>
<b class="nc"><i>626</i>&nbsp;</b>
<i>627</i>&nbsp;    // &lt;/editor-fold&gt;
<i>628</i>&nbsp;
<i>629</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Translation helper methods&quot;&gt;
<i>630</i>&nbsp;
<i>631</i>&nbsp;    private JCBlock makeLambdaBody(JCLambda tree, JCMethodDecl lambdaMethodDecl) {
<i>632</i>&nbsp;        return tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
<i>633</i>&nbsp;                makeLambdaExpressionBody((JCExpression)tree.body, lambdaMethodDecl) :
<b class="nc"><i>634</i>&nbsp;                makeLambdaStatementBody((JCBlock)tree.body, lambdaMethodDecl, tree.canCompleteNormally);</b>
<b class="nc"><i>635</i>&nbsp;    }</b>
<i>636</i>&nbsp;
<i>637</i>&nbsp;    private JCBlock makeLambdaExpressionBody(JCExpression expr, JCMethodDecl lambdaMethodDecl) {
<i>638</i>&nbsp;        Type restype = lambdaMethodDecl.type.getReturnType();
<i>639</i>&nbsp;        boolean isLambda_void = expr.type.hasTag(VOID);
<b class="nc"><i>640</i>&nbsp;        boolean isTarget_void = restype.hasTag(VOID);</b>
<b class="nc"><i>641</i>&nbsp;        boolean isTarget_Void = types.isSameType(restype, types.boxedClass(syms.voidType).type);</b>
<b class="nc"><i>642</i>&nbsp;        int prevPos = make.pos;</b>
<b class="nc"><i>643</i>&nbsp;        try {</b>
<b class="nc"><i>644</i>&nbsp;            if (isTarget_void) {</b>
<b class="nc"><i>645</i>&nbsp;                //target is void:</b>
<i>646</i>&nbsp;                // BODY;
<b class="nc"><i>647</i>&nbsp;                JCStatement stat = make.at(expr).Exec(expr);</b>
<b class="nc"><i>648</i>&nbsp;                return make.Block(0, List.of(stat));</b>
<b class="nc"><i>649</i>&nbsp;            } else if (isLambda_void &amp;&amp; isTarget_Void) {</b>
<b class="nc"><i>650</i>&nbsp;                //void to Void conversion:</b>
<b class="nc"><i>651</i>&nbsp;                // BODY; return null;</b>
<b class="nc"><i>652</i>&nbsp;                ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>653</i>&nbsp;                stats.append(make.at(expr).Exec(expr));</b>
<b class="nc"><i>654</i>&nbsp;                stats.append(make.Return(make.Literal(BOT, null).setType(syms.botType)));</b>
<b class="nc"><i>655</i>&nbsp;                return make.Block(0, stats.toList());</b>
<b class="nc"><i>656</i>&nbsp;            } else {</b>
<b class="nc"><i>657</i>&nbsp;                //non-void to non-void conversion:</b>
<i>658</i>&nbsp;                // return BODY;
<i>659</i>&nbsp;                return make.at(expr).Block(0, List.of(make.Return(expr)));
<i>660</i>&nbsp;            }
<i>661</i>&nbsp;        } finally {
<i>662</i>&nbsp;            make.at(prevPos);
<i>663</i>&nbsp;        }
<b class="nc"><i>664</i>&nbsp;    }</b>
<i>665</i>&nbsp;
<i>666</i>&nbsp;    private JCBlock makeLambdaStatementBody(JCBlock block, final JCMethodDecl lambdaMethodDecl, boolean completeNormally) {
<i>667</i>&nbsp;        final Type restype = lambdaMethodDecl.type.getReturnType();
<b class="nc"><i>668</i>&nbsp;        final boolean isTarget_void = restype.hasTag(VOID);</b>
<i>669</i>&nbsp;        boolean isTarget_Void = types.isSameType(restype, types.boxedClass(syms.voidType).type);
<b class="nc"><i>670</i>&nbsp;</b>
<b class="nc"><i>671</i>&nbsp;        class LambdaBodyTranslator extends TreeTranslator {</b>
<b class="nc"><i>672</i>&nbsp;</b>
<b class="nc"><i>673</i>&nbsp;            @Override</b>
<i>674</i>&nbsp;            public void visitClassDef(JCClassDecl tree) {
<i>675</i>&nbsp;                //do NOT recurse on any inner classes
<i>676</i>&nbsp;                result = tree;
<i>677</i>&nbsp;            }
<i>678</i>&nbsp;
<i>679</i>&nbsp;            @Override
<i>680</i>&nbsp;            public void visitLambda(JCLambda tree) {
<i>681</i>&nbsp;                //do NOT recurse on any nested lambdas
<i>682</i>&nbsp;                result = tree;
<i>683</i>&nbsp;            }
<i>684</i>&nbsp;
<b class="nc"><i>685</i>&nbsp;            @Override</b>
<i>686</i>&nbsp;            public void visitReturn(JCReturn tree) {
<i>687</i>&nbsp;                boolean isLambda_void = tree.expr == null;
<i>688</i>&nbsp;                if (isTarget_void &amp;&amp; !isLambda_void) {
<b class="nc"><i>689</i>&nbsp;                    //Void to void conversion:</b>
<b class="nc"><i>690</i>&nbsp;                    // { TYPE $loc = RET-EXPR; return; }</b>
<b class="nc"><i>691</i>&nbsp;                    VarSymbol loc = makeSyntheticVar(0, names.fromString(&quot;$loc&quot;), tree.expr.type, lambdaMethodDecl.sym);</b>
<b class="nc"><i>692</i>&nbsp;                    JCVariableDecl varDef = make.VarDef(loc, tree.expr);</b>
<i>693</i>&nbsp;                    result = make.Block(0, List.of(varDef, make.Return(null)));
<i>694</i>&nbsp;                } else {
<i>695</i>&nbsp;                    result = tree;
<b class="nc"><i>696</i>&nbsp;                }</b>
<b class="nc"><i>697</i>&nbsp;</b>
<b class="nc"><i>698</i>&nbsp;            }</b>
<b class="nc"><i>699</i>&nbsp;        }</b>
<b class="nc"><i>700</i>&nbsp;</b>
<b class="nc"><i>701</i>&nbsp;        JCBlock trans_block = new LambdaBodyTranslator().translate(block);</b>
<b class="nc"><i>702</i>&nbsp;        if (completeNormally &amp;&amp; isTarget_Void) {</b>
<b class="nc"><i>703</i>&nbsp;            //there&#39;s no return statement and the lambda (possibly inferred)</b>
<b class="nc"><i>704</i>&nbsp;            //return type is java.lang.Void; emit a synthetic return statement</b>
<b class="nc"><i>705</i>&nbsp;            trans_block.stats = trans_block.stats.append(make.Return(make.Literal(BOT, null).setType(syms.botType)));</b>
<b class="nc"><i>706</i>&nbsp;        }</b>
<i>707</i>&nbsp;        return trans_block;
<i>708</i>&nbsp;    }
<i>709</i>&nbsp;
<b class="nc"><i>710</i>&nbsp;    private JCMethodDecl makeDeserializeMethod(Symbol kSym) {</b>
<i>711</i>&nbsp;        ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
<i>712</i>&nbsp;        ListBuffer&lt;JCBreak&gt; breaks = new ListBuffer&lt;&gt;();
<i>713</i>&nbsp;        for (Map.Entry&lt;String, ListBuffer&lt;JCStatement&gt;&gt; entry : kInfo.deserializeCases.entrySet()) {
<b class="nc"><i>714</i>&nbsp;            JCBreak br = make.Break(null);</b>
<b class="nc"><i>715</i>&nbsp;            breaks.add(br);</b>
<b class="nc"><i>716</i>&nbsp;            List&lt;JCStatement&gt; stmts = entry.getValue().append(br).toList();</b>
<b class="nc"><i>717</i>&nbsp;            cases.add(make.Case(make.Literal(entry.getKey()), stmts));</b>
<b class="nc"><i>718</i>&nbsp;        }</b>
<b class="nc"><i>719</i>&nbsp;        JCSwitch sw = make.Switch(deserGetter(&quot;getImplMethodName&quot;, syms.stringType), cases.toList());</b>
<i>720</i>&nbsp;        for (JCBreak br : breaks) {
<i>721</i>&nbsp;            br.target = sw;
<i>722</i>&nbsp;        }
<i>723</i>&nbsp;        JCBlock body = make.Block(0L, List.of(
<i>724</i>&nbsp;                sw,
<i>725</i>&nbsp;                make.Throw(makeNewClass(
<b class="nc"><i>726</i>&nbsp;                    syms.illegalArgumentExceptionType,</b>
<i>727</i>&nbsp;                    List.of(make.Literal(&quot;Invalid lambda deserialization&quot;))))));
<i>728</i>&nbsp;        JCMethodDecl deser = make.MethodDef(make.Modifiers(kInfo.deserMethodSym.flags()),
<i>729</i>&nbsp;                        names.deserializeLambda,
<i>730</i>&nbsp;                        make.QualIdent(kInfo.deserMethodSym.getReturnType().tsym),
<i>731</i>&nbsp;                        List.nil(),
<i>732</i>&nbsp;                        List.of(make.VarDef(kInfo.deserParamSym, null)),
<b class="nc"><i>733</i>&nbsp;                        List.nil(),</b>
<i>734</i>&nbsp;                        body,
<i>735</i>&nbsp;                        null);
<i>736</i>&nbsp;        deser.sym = kInfo.deserMethodSym;
<i>737</i>&nbsp;        deser.type = kInfo.deserMethodSym.type;
<i>738</i>&nbsp;        //System.err.printf(&quot;DESER: &#39;%s&#39;\n&quot;, deser);
<i>739</i>&nbsp;        return deser;
<b class="nc"><i>740</i>&nbsp;    }</b>
<i>741</i>&nbsp;
<i>742</i>&nbsp;    /** Make an attributed class instance creation expression.
<i>743</i>&nbsp;     *  @param ctype    The class type.
<i>744</i>&nbsp;     *  @param args     The constructor arguments.
<i>745</i>&nbsp;     *  @param cons     The constructor symbol
<i>746</i>&nbsp;     */
<i>747</i>&nbsp;    JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args, Symbol cons) {
<b class="nc"><i>748</i>&nbsp;        JCNewClass tree = make.NewClass(null,</b>
<b class="nc"><i>749</i>&nbsp;            null, make.QualIdent(ctype.tsym), args, null);</b>
<b class="nc"><i>750</i>&nbsp;        tree.constructor = cons;</b>
<b class="nc"><i>751</i>&nbsp;        tree.type = ctype;</b>
<b class="nc"><i>752</i>&nbsp;        return tree;</b>
<i>753</i>&nbsp;    }
<i>754</i>&nbsp;
<i>755</i>&nbsp;    /** Make an attributed class instance creation expression.
<i>756</i>&nbsp;     *  @param ctype    The class type.
<i>757</i>&nbsp;     *  @param args     The constructor arguments.
<i>758</i>&nbsp;     */
<i>759</i>&nbsp;    JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
<i>760</i>&nbsp;        return makeNewClass(ctype, args,
<i>761</i>&nbsp;                rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
<i>762</i>&nbsp;     }
<i>763</i>&nbsp;
<b class="nc"><i>764</i>&nbsp;    private void addDeserializationCase(int implMethodKind, Symbol refSym, Type targetType, MethodSymbol samSym,</b>
<b class="nc"><i>765</i>&nbsp;            DiagnosticPosition pos, List&lt;Object&gt; staticArgs, MethodType indyType) {</b>
<b class="nc"><i>766</i>&nbsp;        String functionalInterfaceClass = classSig(targetType);</b>
<b class="nc"><i>767</i>&nbsp;        String functionalInterfaceMethodName = samSym.getSimpleName().toString();</b>
<i>768</i>&nbsp;        String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
<b class="nc"><i>769</i>&nbsp;        String implClass = classSig(types.erasure(refSym.owner.type));</b>
<i>770</i>&nbsp;        String implMethodName = refSym.getQualifiedName().toString();
<i>771</i>&nbsp;        String implMethodSignature = typeSig(types.erasure(refSym.type));
<i>772</i>&nbsp;
<i>773</i>&nbsp;        JCExpression kindTest = eqTest(syms.intType, deserGetter(&quot;getImplMethodKind&quot;, syms.intType), make.Literal(implMethodKind));
<i>774</i>&nbsp;        ListBuffer&lt;JCExpression&gt; serArgs = new ListBuffer&lt;&gt;();
<i>775</i>&nbsp;        int i = 0;
<i>776</i>&nbsp;        for (Type t : indyType.getParameterTypes()) {
<i>777</i>&nbsp;            List&lt;JCExpression&gt; indexAsArg = new ListBuffer&lt;JCExpression&gt;().append(make.Literal(i)).toList();
<i>778</i>&nbsp;            List&lt;Type&gt; argTypes = new ListBuffer&lt;Type&gt;().append(syms.intType).toList();
<i>779</i>&nbsp;            serArgs.add(make.TypeCast(types.erasure(t), deserGetter(&quot;getCapturedArg&quot;, syms.objectType, argTypes, indexAsArg)));
<i>780</i>&nbsp;            ++i;
<i>781</i>&nbsp;        }
<b class="nc"><i>782</i>&nbsp;        JCStatement stmt = make.If(</b>
<b class="nc"><i>783</i>&nbsp;                deserTest(deserTest(deserTest(deserTest(deserTest(</b>
<i>784</i>&nbsp;                    kindTest,
<b class="nc"><i>785</i>&nbsp;                    &quot;getFunctionalInterfaceClass&quot;, functionalInterfaceClass),</b>
<i>786</i>&nbsp;                    &quot;getFunctionalInterfaceMethodName&quot;, functionalInterfaceMethodName),
<b class="nc"><i>787</i>&nbsp;                    &quot;getFunctionalInterfaceMethodSignature&quot;, functionalInterfaceMethodSignature),</b>
<b class="nc"><i>788</i>&nbsp;                    &quot;getImplClass&quot;, implClass),</b>
<b class="nc"><i>789</i>&nbsp;                    &quot;getImplMethodSignature&quot;, implMethodSignature),</b>
<b class="nc"><i>790</i>&nbsp;                make.Return(makeIndyCall(</b>
<i>791</i>&nbsp;                    pos,
<i>792</i>&nbsp;                    syms.lambdaMetafactory,
<i>793</i>&nbsp;                    names.altMetafactory,
<b class="nc"><i>794</i>&nbsp;                    staticArgs, indyType, serArgs.toList(), samSym.name)),</b>
<i>795</i>&nbsp;                null);
<b class="nc"><i>796</i>&nbsp;        ListBuffer&lt;JCStatement&gt; stmts = kInfo.deserializeCases.get(implMethodName);</b>
<i>797</i>&nbsp;        if (stmts == null) {
<i>798</i>&nbsp;            stmts = new ListBuffer&lt;&gt;();
<i>799</i>&nbsp;            kInfo.deserializeCases.put(implMethodName, stmts);
<b class="nc"><i>800</i>&nbsp;        }</b>
<b class="nc"><i>801</i>&nbsp;        /****</b>
<b class="nc"><i>802</i>&nbsp;        System.err.printf(&quot;+++++++++++++++++\n&quot;);</b>
<b class="nc"><i>803</i>&nbsp;        System.err.printf(&quot;*functionalInterfaceClass: &#39;%s&#39;\n&quot;, functionalInterfaceClass);</b>
<i>804</i>&nbsp;        System.err.printf(&quot;*functionalInterfaceMethodName: &#39;%s&#39;\n&quot;, functionalInterfaceMethodName);
<b class="nc"><i>805</i>&nbsp;        System.err.printf(&quot;*functionalInterfaceMethodSignature: &#39;%s&#39;\n&quot;, functionalInterfaceMethodSignature);</b>
<b class="nc"><i>806</i>&nbsp;        System.err.printf(&quot;*implMethodKind: %d\n&quot;, implMethodKind);</b>
<b class="nc"><i>807</i>&nbsp;        System.err.printf(&quot;*implClass: &#39;%s&#39;\n&quot;, implClass);</b>
<b class="nc"><i>808</i>&nbsp;        System.err.printf(&quot;*implMethodName: &#39;%s&#39;\n&quot;, implMethodName);</b>
<b class="nc"><i>809</i>&nbsp;        System.err.printf(&quot;*implMethodSignature: &#39;%s&#39;\n&quot;, implMethodSignature);</b>
<i>810</i>&nbsp;        ****/
<b class="nc"><i>811</i>&nbsp;        stmts.append(stmt);</b>
<i>812</i>&nbsp;    }
<i>813</i>&nbsp;
<i>814</i>&nbsp;    private JCExpression eqTest(Type argType, JCExpression arg1, JCExpression arg2) {
<i>815</i>&nbsp;        JCBinary testExpr = make.Binary(JCTree.Tag.EQ, arg1, arg2);
<i>816</i>&nbsp;        testExpr.operator = operators.resolveBinary(testExpr, JCTree.Tag.EQ, argType, argType);
<i>817</i>&nbsp;        testExpr.setType(syms.booleanType);
<i>818</i>&nbsp;        return testExpr;
<i>819</i>&nbsp;    }
<i>820</i>&nbsp;
<b class="nc"><i>821</i>&nbsp;    private JCExpression deserTest(JCExpression prev, String func, String lit) {</b>
<b class="nc"><i>822</i>&nbsp;        MethodType eqmt = new MethodType(List.of(syms.objectType), syms.booleanType, List.nil(), syms.methodClass);</b>
<b class="nc"><i>823</i>&nbsp;        Symbol eqsym = rs.resolveQualifiedMethod(null, attrEnv, syms.objectType, names.equals, List.of(syms.objectType), List.nil());</b>
<i>824</i>&nbsp;        JCMethodInvocation eqtest = make.Apply(
<i>825</i>&nbsp;                List.nil(),
<i>826</i>&nbsp;                make.Select(deserGetter(func, syms.stringType), eqsym).setType(eqmt),
<b class="nc"><i>827</i>&nbsp;                List.of(make.Literal(lit)));</b>
<i>828</i>&nbsp;        eqtest.setType(syms.booleanType);
<i>829</i>&nbsp;        JCBinary compound = make.Binary(JCTree.Tag.AND, prev, eqtest);
<b class="nc"><i>830</i>&nbsp;        compound.operator = operators.resolveBinary(compound, JCTree.Tag.AND, syms.booleanType, syms.booleanType);</b>
<b class="nc"><i>831</i>&nbsp;        compound.setType(syms.booleanType);</b>
<b class="nc"><i>832</i>&nbsp;        return compound;</b>
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;    private JCExpression deserGetter(String func, Type type) {
<b class="nc"><i>836</i>&nbsp;        return deserGetter(func, type, List.nil(), List.nil());</b>
<b class="nc"><i>837</i>&nbsp;    }</b>
<b class="nc"><i>838</i>&nbsp;</b>
<b class="nc"><i>839</i>&nbsp;    private JCExpression deserGetter(String func, Type type, List&lt;Type&gt; argTypes, List&lt;JCExpression&gt; args) {</b>
<i>840</i>&nbsp;        MethodType getmt = new MethodType(argTypes, type, List.nil(), syms.methodClass);
<b class="nc"><i>841</i>&nbsp;        Symbol getsym = rs.resolveQualifiedMethod(null, attrEnv, syms.serializedLambdaType, names.fromString(func), argTypes, List.nil());</b>
<i>842</i>&nbsp;        return make.Apply(
<i>843</i>&nbsp;                    List.nil(),
<b class="nc"><i>844</i>&nbsp;                    make.Select(make.Ident(kInfo.deserParamSym).setType(syms.serializedLambdaType), getsym).setType(getmt),</b>
<b class="nc"><i>845</i>&nbsp;                    args).setType(type);</b>
<b class="nc"><i>846</i>&nbsp;    }</b>
<i>847</i>&nbsp;
<b class="nc"><i>848</i>&nbsp;    /**</b>
<i>849</i>&nbsp;     * Create new synthetic method with given flags, name, type, owner
<i>850</i>&nbsp;     */
<b class="nc"><i>851</i>&nbsp;    private MethodSymbol makePrivateSyntheticMethod(long flags, Name name, Type type, Symbol owner) {</b>
<i>852</i>&nbsp;        return new MethodSymbol(flags | SYNTHETIC | PRIVATE, name, type, owner);
<i>853</i>&nbsp;    }
<i>854</i>&nbsp;
<i>855</i>&nbsp;    /**
<i>856</i>&nbsp;     * Create new synthetic variable with given flags, name, type, owner
<i>857</i>&nbsp;     */
<i>858</i>&nbsp;    private VarSymbol makeSyntheticVar(long flags, Name name, Type type, Symbol owner) {
<i>859</i>&nbsp;        return new VarSymbol(flags | SYNTHETIC, name, type, owner);
<b class="nc"><i>860</i>&nbsp;    }</b>
<i>861</i>&nbsp;
<b class="nc"><i>862</i>&nbsp;    /**</b>
<i>863</i>&nbsp;     * Set varargsElement field on a given tree (must be either a new class tree
<i>864</i>&nbsp;     * or a method call tree)
<i>865</i>&nbsp;     */
<b class="nc"><i>866</i>&nbsp;    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {</b>
<b class="nc"><i>867</i>&nbsp;        if (varargsElement != null) {</b>
<b class="nc"><i>868</i>&nbsp;            switch (tree.getTag()) {</b>
<b class="nc"><i>869</i>&nbsp;                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;</b>
<i>870</i>&nbsp;                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;
<i>871</i>&nbsp;                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;
<b class="nc"><i>872</i>&nbsp;                default: throw new AssertionError();</b>
<i>873</i>&nbsp;            }
<i>874</i>&nbsp;        }
<b class="nc"><i>875</i>&nbsp;    }</b>
<b class="nc"><i>876</i>&nbsp;</b>
<b class="nc"><i>877</i>&nbsp;    /**</b>
<i>878</i>&nbsp;     * Convert method/constructor arguments by inserting appropriate cast
<i>879</i>&nbsp;     * as required by type-erasure - this is needed when bridging a lambda/method
<b class="nc"><i>880</i>&nbsp;     * reference, as the bridged signature might require downcast to be compatible</b>
<b class="nc"><i>881</i>&nbsp;     * with the generated signature.</b>
<i>882</i>&nbsp;     */
<i>883</i>&nbsp;    private List&lt;JCExpression&gt; convertArgs(Symbol meth, List&lt;JCExpression&gt; args, Type varargsElement) {
<b class="nc"><i>884</i>&nbsp;       Assert.check(meth.kind == MTH);</b>
<i>885</i>&nbsp;       List&lt;Type&gt; formals = types.erasure(meth.type).getParameterTypes();
<i>886</i>&nbsp;       if (varargsElement != null) {
<i>887</i>&nbsp;           Assert.check((meth.flags() &amp; VARARGS) != 0);
<b class="nc"><i>888</i>&nbsp;       }</b>
<i>889</i>&nbsp;       return transTypes.translateArgs(args, formals, varargsElement, attrEnv);
<i>890</i>&nbsp;    }
<i>891</i>&nbsp;
<b class="nc"><i>892</i>&nbsp;    // &lt;/editor-fold&gt;</b>
<b class="nc"><i>893</i>&nbsp;</b>
<b class="nc"><i>894</i>&nbsp;    /**</b>
<b class="nc"><i>895</i>&nbsp;     * Converts a method reference which cannot be used directly into a lambda</b>
<i>896</i>&nbsp;     */
<b class="nc"><i>897</i>&nbsp;    private class MemberReferenceToLambda {</b>
<i>898</i>&nbsp;
<b class="nc"><i>899</i>&nbsp;        private final JCMemberReference tree;</b>
<b class="nc"><i>900</i>&nbsp;        private final ReferenceTranslationContext localContext;</b>
<i>901</i>&nbsp;        private final Symbol owner;
<b class="nc"><i>902</i>&nbsp;        private final ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();</b>
<i>903</i>&nbsp;        private final ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
<i>904</i>&nbsp;
<i>905</i>&nbsp;        private JCExpression receiverExpression = null;
<i>906</i>&nbsp;
<i>907</i>&nbsp;        MemberReferenceToLambda(JCMemberReference tree, ReferenceTranslationContext localContext, Symbol owner) {
<i>908</i>&nbsp;            this.tree = tree;
<i>909</i>&nbsp;            this.localContext = localContext;
<b class="nc"><i>910</i>&nbsp;            this.owner = owner;</b>
<i>911</i>&nbsp;        }
<b class="nc"><i>912</i>&nbsp;</b>
<b class="nc"><i>913</i>&nbsp;        JCLambda lambda() {</b>
<i>914</i>&nbsp;            int prevPos = make.pos;
<i>915</i>&nbsp;            try {
<b class="nc"><i>916</i>&nbsp;                make.at(tree);</b>
<b class="nc"><i>917</i>&nbsp;</b>
<b class="nc"><i>918</i>&nbsp;                //body generation - this can be either a method call or a</b>
<i>919</i>&nbsp;                //new instance creation expression, depending on the member reference kind
<i>920</i>&nbsp;                VarSymbol rcvr = addParametersReturnReceiver();
<b class="nc"><i>921</i>&nbsp;                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)</b>
<b class="nc"><i>922</i>&nbsp;                        ? expressionInvoke(rcvr)</b>
<b class="nc"><i>923</i>&nbsp;                        : expressionNew();</b>
<i>924</i>&nbsp;
<b class="nc"><i>925</i>&nbsp;                JCLambda slam = make.Lambda(params.toList(), expr);</b>
<b class="nc"><i>926</i>&nbsp;                slam.target = tree.target;</b>
<b class="nc"><i>927</i>&nbsp;                slam.type = tree.type;</b>
<i>928</i>&nbsp;                slam.pos = tree.pos;
<i>929</i>&nbsp;                return slam;
<i>930</i>&nbsp;            } finally {
<i>931</i>&nbsp;                make.at(prevPos);
<i>932</i>&nbsp;            }
<i>933</i>&nbsp;        }
<b class="nc"><i>934</i>&nbsp;</b>
<i>935</i>&nbsp;        /**
<b class="nc"><i>936</i>&nbsp;         * Generate the parameter list for the converted member reference.</b>
<b class="nc"><i>937</i>&nbsp;         *</b>
<b class="nc"><i>938</i>&nbsp;         * @return The receiver variable symbol, if any</b>
<i>939</i>&nbsp;         */
<b class="nc"><i>940</i>&nbsp;        VarSymbol addParametersReturnReceiver() {</b>
<b class="nc"><i>941</i>&nbsp;            Type samDesc = localContext.bridgedRefSig();</b>
<i>942</i>&nbsp;            List&lt;Type&gt; samPTypes = samDesc.getParameterTypes();
<i>943</i>&nbsp;            List&lt;Type&gt; descPTypes = tree.getDescriptorType(types).getParameterTypes();
<i>944</i>&nbsp;
<i>945</i>&nbsp;            // Determine the receiver, if any
<b class="nc"><i>946</i>&nbsp;            VarSymbol rcvr;</b>
<b class="nc"><i>947</i>&nbsp;            switch (tree.kind) {</b>
<b class="nc"><i>948</i>&nbsp;                case BOUND:</b>
<b class="nc"><i>949</i>&nbsp;                    // The receiver is explicit in the method reference</b>
<i>950</i>&nbsp;                    rcvr = addParameter(&quot;rec$&quot;, tree.getQualifierExpression().type, false);
<b class="nc"><i>951</i>&nbsp;                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());</b>
<b class="nc"><i>952</i>&nbsp;                    break;</b>
<b class="nc"><i>953</i>&nbsp;                case UNBOUND:</b>
<b class="nc"><i>954</i>&nbsp;                    // The receiver is the first parameter, extract it and</b>
<b class="nc"><i>955</i>&nbsp;                    // adjust the SAM and unerased type lists accordingly</b>
<i>956</i>&nbsp;                    rcvr = addParameter(&quot;rec$&quot;, samDesc.getParameterTypes().head, false);
<i>957</i>&nbsp;                    samPTypes = samPTypes.tail;
<i>958</i>&nbsp;                    descPTypes = descPTypes.tail;
<i>959</i>&nbsp;                    break;
<b class="nc"><i>960</i>&nbsp;                default:</b>
<b class="nc"><i>961</i>&nbsp;                    rcvr = null;</b>
<b class="nc"><i>962</i>&nbsp;                    break;</b>
<b class="nc"><i>963</i>&nbsp;            }</b>
<b class="nc"><i>964</i>&nbsp;            List&lt;Type&gt; implPTypes = tree.sym.type.getParameterTypes();</b>
<i>965</i>&nbsp;            int implSize = implPTypes.size();
<b class="nc"><i>966</i>&nbsp;            int samSize = samPTypes.size();</b>
<i>967</i>&nbsp;            // Last parameter to copy from referenced method, exclude final var args
<i>968</i>&nbsp;            int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;
<i>969</i>&nbsp;
<i>970</i>&nbsp;            // Failsafe -- assure match-up
<b class="nc"><i>971</i>&nbsp;            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();</b>
<b class="nc"><i>972</i>&nbsp;</b>
<b class="nc"><i>973</i>&nbsp;            // Use parameter types of the implementation method unless the unerased</b>
<b class="nc"><i>974</i>&nbsp;            // SAM parameter type is an intersection type, in that case use the</b>
<i>975</i>&nbsp;            // erased SAM parameter type so that the supertype relationship
<i>976</i>&nbsp;            // the implementation method parameters is not obscured.
<i>977</i>&nbsp;            // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
<i>978</i>&nbsp;            // are used as pointers to the current parameter type information
<i>979</i>&nbsp;            // and are thus not usable afterwards.
<i>980</i>&nbsp;            for (int i = 0; implPTypes.nonEmpty() &amp;&amp; i &lt; last; ++i) {
<i>981</i>&nbsp;                // By default use the implementation method parmeter type
<i>982</i>&nbsp;                Type parmType = implPTypes.head;
<b class="nc"><i>983</i>&nbsp;                // If the unerased parameter type is a type variable whose</b>
<i>984</i>&nbsp;                // bound is an intersection (eg. &lt;T extends A &amp; B&gt;) then
<b class="nc"><i>985</i>&nbsp;                // use the SAM parameter type</b>
<b class="nc"><i>986</i>&nbsp;                if (checkForIntersection &amp;&amp; descPTypes.head.getKind() == TypeKind.TYPEVAR) {</b>
<b class="nc"><i>987</i>&nbsp;                    TypeVar tv = (TypeVar) descPTypes.head;</b>
<i>988</i>&nbsp;                    if (tv.bound.getKind() == TypeKind.INTERSECTION) {
<b class="nc"><i>989</i>&nbsp;                        parmType = samPTypes.head;</b>
<i>990</i>&nbsp;                    }
<i>991</i>&nbsp;                }
<b class="nc"><i>992</i>&nbsp;                addParameter(&quot;x$&quot; + i, parmType, true);</b>
<b class="nc"><i>993</i>&nbsp;</b>
<b class="nc"><i>994</i>&nbsp;                // Advance to the next parameter</b>
<b class="nc"><i>995</i>&nbsp;                implPTypes = implPTypes.tail;</b>
<i>996</i>&nbsp;                samPTypes = samPTypes.tail;
<i>997</i>&nbsp;                descPTypes = descPTypes.tail;
<b class="nc"><i>998</i>&nbsp;            }</b>
<i>999</i>&nbsp;            // Flatten out the var args
<b class="nc"><i>1000</i>&nbsp;            for (int i = last; i &lt; samSize; ++i) {</b>
<i>1001</i>&nbsp;                addParameter(&quot;xva$&quot; + i, tree.varargsElement, true);
<i>1002</i>&nbsp;            }
<b class="nc"><i>1003</i>&nbsp;</b>
<i>1004</i>&nbsp;            return rcvr;
<i>1005</i>&nbsp;        }
<b class="nc"><i>1006</i>&nbsp;</b>
<b class="nc"><i>1007</i>&nbsp;        JCExpression getReceiverExpression() {</b>
<b class="nc"><i>1008</i>&nbsp;            return receiverExpression;</b>
<b class="nc"><i>1009</i>&nbsp;        }</b>
<b class="nc"><i>1010</i>&nbsp;</b>
<i>1011</i>&nbsp;        private JCExpression makeReceiver(VarSymbol rcvr) {
<b class="nc"><i>1012</i>&nbsp;            if (rcvr == null) return null;</b>
<b class="nc"><i>1013</i>&nbsp;            JCExpression rcvrExpr = make.Ident(rcvr);</b>
<b class="nc"><i>1014</i>&nbsp;            Type rcvrType = tree.ownerAccessible ? tree.sym.enclClass().type : tree.expr.type;</b>
<b class="nc"><i>1015</i>&nbsp;            if (rcvrType == syms.arrayClass.type) {</b>
<b class="nc"><i>1016</i>&nbsp;                // Map the receiver type to the actually type, not just &quot;array&quot;</b>
<b class="nc"><i>1017</i>&nbsp;                rcvrType = tree.getQualifierExpression().type;</b>
<i>1018</i>&nbsp;            }
<b class="nc"><i>1019</i>&nbsp;            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {</b>
<b class="nc"><i>1020</i>&nbsp;                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);</b>
<i>1021</i>&nbsp;            }
<b class="nc"><i>1022</i>&nbsp;            return rcvrExpr;</b>
<b class="nc"><i>1023</i>&nbsp;        }</b>
<b class="nc"><i>1024</i>&nbsp;</b>
<b class="nc"><i>1025</i>&nbsp;        /**</b>
<i>1026</i>&nbsp;         * determine the receiver of the method call - the receiver can
<b class="nc"><i>1027</i>&nbsp;         * be a type qualifier, the synthetic receiver parameter or &#39;super&#39;.</b>
<b class="nc"><i>1028</i>&nbsp;         */</b>
<b class="nc"><i>1029</i>&nbsp;        private JCExpression expressionInvoke(VarSymbol rcvr) {</b>
<b class="nc"><i>1030</i>&nbsp;            JCExpression qualifier =</b>
<b class="nc"><i>1031</i>&nbsp;                    (rcvr != null) ?</b>
<b class="nc"><i>1032</i>&nbsp;                        makeReceiver(rcvr) :</b>
<i>1033</i>&nbsp;                        tree.getQualifierExpression();
<b class="nc"><i>1034</i>&nbsp;</b>
<i>1035</i>&nbsp;            //create the qualifier expression
<b class="nc"><i>1036</i>&nbsp;            JCFieldAccess select = make.Select(qualifier, tree.sym.name);</b>
<b class="nc"><i>1037</i>&nbsp;            select.sym = tree.sym;</b>
<i>1038</i>&nbsp;            select.type = tree.sym.erasure(types);
<b class="nc"><i>1039</i>&nbsp;</b>
<b class="nc"><i>1040</i>&nbsp;            //create the method call expression</b>
<i>1041</i>&nbsp;            JCExpression apply = make.Apply(List.nil(), select,
<i>1042</i>&nbsp;                    convertArgs(tree.sym, args.toList(), tree.varargsElement)).
<b class="nc"><i>1043</i>&nbsp;                    setType(tree.sym.erasure(types).getReturnType());</b>
<b class="nc"><i>1044</i>&nbsp;</b>
<i>1045</i>&nbsp;            apply = transTypes.coerce(attrEnv, apply,
<i>1046</i>&nbsp;                    types.erasure(localContext.tree.referentType.getReturnType()));
<i>1047</i>&nbsp;
<b class="nc"><i>1048</i>&nbsp;            setVarargsIfNeeded(apply, tree.varargsElement);</b>
<i>1049</i>&nbsp;            return apply;
<i>1050</i>&nbsp;        }
<i>1051</i>&nbsp;
<i>1052</i>&nbsp;        /**
<i>1053</i>&nbsp;         * Lambda body to use for a &#39;new&#39;.
<i>1054</i>&nbsp;         */
<i>1055</i>&nbsp;        private JCExpression expressionNew() {
<i>1056</i>&nbsp;            if (tree.kind == ReferenceKind.ARRAY_CTOR) {
<i>1057</i>&nbsp;                //create the array creation expression
<b class="nc"><i>1058</i>&nbsp;                JCNewArray newArr = make.NewArray(</b>
<i>1059</i>&nbsp;                        make.Type(types.elemtype(tree.getQualifierExpression().type)),
<b class="nc"><i>1060</i>&nbsp;                        List.of(make.Ident(params.first())),</b>
<b class="nc"><i>1061</i>&nbsp;                        null);</b>
<i>1062</i>&nbsp;                newArr.type = tree.getQualifierExpression().type;
<b class="nc"><i>1063</i>&nbsp;                return newArr;</b>
<i>1064</i>&nbsp;            } else {
<b class="nc"><i>1065</i>&nbsp;                //create the instance creation expression</b>
<b class="nc"><i>1066</i>&nbsp;                //note that method reference syntax does not allow an explicit</b>
<i>1067</i>&nbsp;                //enclosing class (so the enclosing class is null)
<b class="nc"><i>1068</i>&nbsp;                // but this may need to be patched up later with the proxy for the outer this</b>
<i>1069</i>&nbsp;                JCNewClass newClass = make.NewClass(null,
<i>1070</i>&nbsp;                        List.nil(),
<b class="nc"><i>1071</i>&nbsp;                        make.Type(tree.getQualifierExpression().type),</b>
<i>1072</i>&nbsp;                        convertArgs(tree.sym, args.toList(), tree.varargsElement),
<i>1073</i>&nbsp;                        null);
<i>1074</i>&nbsp;                newClass.constructor = tree.sym;
<i>1075</i>&nbsp;                newClass.constructorType = tree.sym.erasure(types);
<b class="nc"><i>1076</i>&nbsp;                newClass.type = tree.getQualifierExpression().type;</b>
<i>1077</i>&nbsp;                setVarargsIfNeeded(newClass, tree.varargsElement);
<b class="nc"><i>1078</i>&nbsp;                return newClass;</b>
<b class="nc"><i>1079</i>&nbsp;            }</b>
<b class="nc"><i>1080</i>&nbsp;        }</b>
<i>1081</i>&nbsp;
<b class="nc"><i>1082</i>&nbsp;        private VarSymbol addParameter(String name, Type p, boolean genArg) {</b>
<b class="nc"><i>1083</i>&nbsp;            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);</b>
<b class="nc"><i>1084</i>&nbsp;            vsym.pos = tree.pos;</b>
<i>1085</i>&nbsp;            params.append(make.VarDef(vsym, null));
<b class="nc"><i>1086</i>&nbsp;            if (genArg) {</b>
<i>1087</i>&nbsp;                args.append(make.Ident(vsym));
<i>1088</i>&nbsp;            }
<i>1089</i>&nbsp;            return vsym;
<i>1090</i>&nbsp;        }
<b class="nc"><i>1091</i>&nbsp;    }</b>
<b class="nc"><i>1092</i>&nbsp;</b>
<b class="nc"><i>1093</i>&nbsp;    private MethodType typeToMethodType(Type mt) {</b>
<b class="nc"><i>1094</i>&nbsp;        Type type = types.erasure(mt);</b>
<b class="nc"><i>1095</i>&nbsp;        return new MethodType(type.getParameterTypes(),</b>
<i>1096</i>&nbsp;                        type.getReturnType(),
<i>1097</i>&nbsp;                        type.getThrownTypes(),
<i>1098</i>&nbsp;                        syms.methodClass);
<b class="nc"><i>1099</i>&nbsp;    }</b>
<b class="nc"><i>1100</i>&nbsp;</b>
<b class="nc"><i>1101</i>&nbsp;    /**</b>
<b class="nc"><i>1102</i>&nbsp;     * Generate an indy method call to the meta factory</b>
<b class="nc"><i>1103</i>&nbsp;     */</b>
<b class="nc"><i>1104</i>&nbsp;    private JCExpression makeMetafactoryIndyCall(TranslationContext&lt;?&gt; context,</b>
<b class="nc"><i>1105</i>&nbsp;            int refKind, Symbol refSym, List&lt;JCExpression&gt; indy_args) {</b>
<b class="nc"><i>1106</i>&nbsp;        JCFunctionalExpression tree = context.tree;</b>
<b class="nc"><i>1107</i>&nbsp;        //determine the static bsm args</b>
<b class="nc"><i>1108</i>&nbsp;        MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);</b>
<b class="nc"><i>1109</i>&nbsp;        List&lt;Object&gt; staticArgs = List.of(</b>
<b class="nc"><i>1110</i>&nbsp;                typeToMethodType(samSym.type),</b>
<b class="nc"><i>1111</i>&nbsp;                new Pool.MethodHandle(refKind, refSym, types),</b>
<b class="nc"><i>1112</i>&nbsp;                typeToMethodType(tree.getDescriptorType(types)));</b>
<b class="nc"><i>1113</i>&nbsp;</b>
<b class="nc"><i>1114</i>&nbsp;        //computed indy arg types</b>
<b class="nc"><i>1115</i>&nbsp;        ListBuffer&lt;Type&gt; indy_args_types = new ListBuffer&lt;&gt;();</b>
<i>1116</i>&nbsp;        for (JCExpression arg : indy_args) {
<b class="nc"><i>1117</i>&nbsp;            indy_args_types.append(arg.type);</b>
<b class="nc"><i>1118</i>&nbsp;        }</b>
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;        //finally, compute the type of the indy call
<i>1121</i>&nbsp;        MethodType indyType = new MethodType(indy_args_types.toList(),
<i>1122</i>&nbsp;                tree.type,
<i>1123</i>&nbsp;                List.nil(),
<i>1124</i>&nbsp;                syms.methodClass);
<i>1125</i>&nbsp;
<b class="nc"><i>1126</i>&nbsp;        Name metafactoryName = context.needsAltMetafactory() ?</b>
<b class="nc"><i>1127</i>&nbsp;                names.altMetafactory : names.metafactory;</b>
<i>1128</i>&nbsp;
<b class="nc"><i>1129</i>&nbsp;        if (context.needsAltMetafactory()) {</b>
<b class="nc"><i>1130</i>&nbsp;            ListBuffer&lt;Object&gt; markers = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1131</i>&nbsp;            List&lt;Type&gt; targets = tree.target.isIntersection() ?</b>
<b class="nc"><i>1132</i>&nbsp;                    types.directSupertypes(tree.target) :</b>
<b class="nc"><i>1133</i>&nbsp;                    List.nil();</b>
<b class="nc"><i>1134</i>&nbsp;            for (Type t : targets) {</b>
<i>1135</i>&nbsp;                t = types.erasure(t);
<b class="nc"><i>1136</i>&nbsp;                if (t.tsym != syms.serializableType.tsym &amp;&amp;</b>
<i>1137</i>&nbsp;                    t.tsym != tree.type.tsym &amp;&amp;
<i>1138</i>&nbsp;                    t.tsym != syms.objectType.tsym) {
<i>1139</i>&nbsp;                    markers.append(t.tsym);
<i>1140</i>&nbsp;                }
<i>1141</i>&nbsp;            }
<i>1142</i>&nbsp;            int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
<i>1143</i>&nbsp;            boolean hasMarkers = markers.nonEmpty();
<i>1144</i>&nbsp;            boolean hasBridges = context.bridges.nonEmpty();
<i>1145</i>&nbsp;            if (hasMarkers) {
<i>1146</i>&nbsp;                flags |= FLAG_MARKERS;
<i>1147</i>&nbsp;            }
<b class="nc"><i>1148</i>&nbsp;            if (hasBridges) {</b>
<i>1149</i>&nbsp;                flags |= FLAG_BRIDGES;
<i>1150</i>&nbsp;            }
<i>1151</i>&nbsp;            staticArgs = staticArgs.append(flags);
<i>1152</i>&nbsp;            if (hasMarkers) {
<i>1153</i>&nbsp;                staticArgs = staticArgs.append(markers.length());
<i>1154</i>&nbsp;                staticArgs = staticArgs.appendList(markers.toList());
<i>1155</i>&nbsp;            }
<i>1156</i>&nbsp;            if (hasBridges) {
<b class="nc"><i>1157</i>&nbsp;                staticArgs = staticArgs.append(context.bridges.length() - 1);</b>
<i>1158</i>&nbsp;                for (Symbol s : context.bridges) {
<i>1159</i>&nbsp;                    Type s_erasure = s.erasure(types);
<i>1160</i>&nbsp;                    if (!types.isSameType(s_erasure, samSym.erasure(types))) {
<i>1161</i>&nbsp;                        staticArgs = staticArgs.append(s.erasure(types));
<i>1162</i>&nbsp;                    }
<i>1163</i>&nbsp;                }
<i>1164</i>&nbsp;            }
<i>1165</i>&nbsp;            if (context.isSerializable()) {
<i>1166</i>&nbsp;                int prevPos = make.pos;
<i>1167</i>&nbsp;                try {
<b class="nc"><i>1168</i>&nbsp;                    make.at(kInfo.clazz);</b>
<b class="nc"><i>1169</i>&nbsp;                    addDeserializationCase(refKind, refSym, tree.type, samSym,</b>
<i>1170</i>&nbsp;                            tree, staticArgs, indyType);
<b class="nc"><i>1171</i>&nbsp;                } finally {</b>
<b class="nc"><i>1172</i>&nbsp;                    make.at(prevPos);</b>
<b class="nc"><i>1173</i>&nbsp;                }</b>
<b class="nc"><i>1174</i>&nbsp;            }</b>
<i>1175</i>&nbsp;        }
<b class="nc"><i>1176</i>&nbsp;</b>
<b class="nc"><i>1177</i>&nbsp;        return makeIndyCall(tree, syms.lambdaMetafactory, metafactoryName, staticArgs, indyType, indy_args, samSym.name);</b>
<b class="nc"><i>1178</i>&nbsp;    }</b>
<i>1179</i>&nbsp;
<i>1180</i>&nbsp;    /**
<b class="nc"><i>1181</i>&nbsp;     * Generate an indy method call with given name, type and static bootstrap</b>
<i>1182</i>&nbsp;     * arguments types
<i>1183</i>&nbsp;     */
<i>1184</i>&nbsp;    private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
<i>1185</i>&nbsp;            List&lt;Object&gt; staticArgs, MethodType indyType, List&lt;JCExpression&gt; indyArgs,
<i>1186</i>&nbsp;            Name methName) {
<i>1187</i>&nbsp;        int prevPos = make.pos;
<i>1188</i>&nbsp;        try {
<i>1189</i>&nbsp;            make.at(pos);
<b class="nc"><i>1190</i>&nbsp;            List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,</b>
<i>1191</i>&nbsp;                    syms.stringType,
<i>1192</i>&nbsp;                    syms.methodTypeType).appendList(bsmStaticArgToTypes(staticArgs));
<i>1193</i>&nbsp;
<b class="nc"><i>1194</i>&nbsp;            Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,</b>
<b class="nc"><i>1195</i>&nbsp;                    bsmName, bsm_staticArgs, List.nil());</b>
<b class="nc"><i>1196</i>&nbsp;</b>
<b class="nc"><i>1197</i>&nbsp;            DynamicMethodSymbol dynSym =</b>
<i>1198</i>&nbsp;                    new DynamicMethodSymbol(methName,
<i>1199</i>&nbsp;                                            syms.noSymbol,
<i>1200</i>&nbsp;                                            bsm.isStatic() ?
<i>1201</i>&nbsp;                                                ClassFile.REF_invokeStatic :
<b class="nc"><i>1202</i>&nbsp;                                                ClassFile.REF_invokeVirtual,</b>
<i>1203</i>&nbsp;                                            (MethodSymbol)bsm,
<b class="nc"><i>1204</i>&nbsp;                                            indyType,</b>
<b class="nc"><i>1205</i>&nbsp;                                            staticArgs.toArray());</b>
<b class="nc"><i>1206</i>&nbsp;            JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);</b>
<i>1207</i>&nbsp;            DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
<b class="nc"><i>1208</i>&nbsp;                    new DynamicMethod(dynSym, types), dynSym);</b>
<i>1209</i>&nbsp;            qualifier.sym = existing != null ? existing : dynSym;
<b class="nc"><i>1210</i>&nbsp;            qualifier.type = indyType.getReturnType();</b>
<b class="nc"><i>1211</i>&nbsp;</b>
<i>1212</i>&nbsp;            JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
<i>1213</i>&nbsp;            proxyCall.type = indyType.getReturnType();
<i>1214</i>&nbsp;            return proxyCall;
<b class="nc"><i>1215</i>&nbsp;        } finally {</b>
<b class="nc"><i>1216</i>&nbsp;            make.at(prevPos);</b>
<b class="nc"><i>1217</i>&nbsp;        }</b>
<b class="nc"><i>1218</i>&nbsp;    }</b>
<i>1219</i>&nbsp;    //where
<b class="nc"><i>1220</i>&nbsp;    private List&lt;Type&gt; bsmStaticArgToTypes(List&lt;Object&gt; args) {</b>
<b class="nc"><i>1221</i>&nbsp;        ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();</b>
<i>1222</i>&nbsp;        for (Object arg : args) {
<i>1223</i>&nbsp;            argtypes.append(bsmStaticArgToType(arg));
<i>1224</i>&nbsp;        }
<i>1225</i>&nbsp;        return argtypes.toList();
<b class="nc"><i>1226</i>&nbsp;    }</b>
<i>1227</i>&nbsp;
<b class="nc"><i>1228</i>&nbsp;    private Type bsmStaticArgToType(Object arg) {</b>
<b class="nc"><i>1229</i>&nbsp;        Assert.checkNonNull(arg);</b>
<i>1230</i>&nbsp;        if (arg instanceof ClassSymbol) {
<b class="nc"><i>1231</i>&nbsp;            return syms.classType;</b>
<i>1232</i>&nbsp;        } else if (arg instanceof Integer) {
<i>1233</i>&nbsp;            return syms.intType;
<b class="nc"><i>1234</i>&nbsp;        } else if (arg instanceof Long) {</b>
<b class="nc"><i>1235</i>&nbsp;            return syms.longType;</b>
<i>1236</i>&nbsp;        } else if (arg instanceof Float) {
<i>1237</i>&nbsp;            return syms.floatType;
<i>1238</i>&nbsp;        } else if (arg instanceof Double) {
<i>1239</i>&nbsp;            return syms.doubleType;
<b class="nc"><i>1240</i>&nbsp;        } else if (arg instanceof String) {</b>
<b class="nc"><i>1241</i>&nbsp;            return syms.stringType;</b>
<b class="nc"><i>1242</i>&nbsp;        } else if (arg instanceof Pool.MethodHandle) {</b>
<i>1243</i>&nbsp;            return syms.methodHandleType;
<b class="nc"><i>1244</i>&nbsp;        } else if (arg instanceof MethodType) {</b>
<b class="nc"><i>1245</i>&nbsp;            return syms.methodTypeType;</b>
<i>1246</i>&nbsp;        } else {
<b class="nc"><i>1247</i>&nbsp;            Assert.error(&quot;bad static arg &quot; + arg.getClass());</b>
<b class="nc"><i>1248</i>&nbsp;            return null;</b>
<b class="nc"><i>1249</i>&nbsp;        }</b>
<b class="nc"><i>1250</i>&nbsp;    }</b>
<b class="nc"><i>1251</i>&nbsp;</b>
<b class="nc"><i>1252</i>&nbsp;    /**</b>
<i>1253</i>&nbsp;     * Get the opcode associated with this method reference
<b class="nc"><i>1254</i>&nbsp;     */</b>
<b class="nc"><i>1255</i>&nbsp;    private int referenceKind(Symbol refSym) {</b>
<b class="nc"><i>1256</i>&nbsp;        if (refSym.isConstructor()) {</b>
<i>1257</i>&nbsp;            return ClassFile.REF_newInvokeSpecial;
<i>1258</i>&nbsp;        } else {
<b class="nc"><i>1259</i>&nbsp;            if (refSym.isStatic()) {</b>
<b class="nc"><i>1260</i>&nbsp;                return ClassFile.REF_invokeStatic;</b>
<b class="nc"><i>1261</i>&nbsp;            } else if ((refSym.flags() &amp; PRIVATE) != 0) {</b>
<b class="nc"><i>1262</i>&nbsp;                return ClassFile.REF_invokeSpecial;</b>
<b class="nc"><i>1263</i>&nbsp;            } else if (refSym.enclClass().isInterface()) {</b>
<i>1264</i>&nbsp;                return ClassFile.REF_invokeInterface;
<b class="nc"><i>1265</i>&nbsp;            } else {</b>
<i>1266</i>&nbsp;                return ClassFile.REF_invokeVirtual;
<i>1267</i>&nbsp;            }
<i>1268</i>&nbsp;        }
<b class="nc"><i>1269</i>&nbsp;    }</b>
<b class="nc"><i>1270</i>&nbsp;</b>
<i>1271</i>&nbsp;    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Lambda/reference analyzer&quot;&gt;
<i>1272</i>&nbsp;    /**
<b class="nc"><i>1273</i>&nbsp;     * This visitor collects information about translation of a lambda expression.</b>
<b class="nc"><i>1274</i>&nbsp;     * More specifically, it keeps track of the enclosing contexts and captured locals</b>
<b class="nc"><i>1275</i>&nbsp;     * accessed by the lambda being translated (as well as other useful info).</b>
<b class="nc"><i>1276</i>&nbsp;     * It also translates away problems for LambdaToMethod.</b>
<b class="nc"><i>1277</i>&nbsp;     */</b>
<b class="nc"><i>1278</i>&nbsp;    class LambdaAnalyzerPreprocessor extends TreeTranslator {</b>
<i>1279</i>&nbsp;
<i>1280</i>&nbsp;        /** the frame stack - used to reconstruct translation info about enclosing scopes */
<i>1281</i>&nbsp;        private List&lt;Frame&gt; frameStack;
<i>1282</i>&nbsp;
<b class="nc"><i>1283</i>&nbsp;        /**</b>
<b class="nc"><i>1284</i>&nbsp;         * keep the count of lambda expression (used to generate unambiguous</b>
<i>1285</i>&nbsp;         * names)
<b class="nc"><i>1286</i>&nbsp;         */</b>
<b class="nc"><i>1287</i>&nbsp;        private int lambdaCount = 0;</b>
<b class="nc"><i>1288</i>&nbsp;</b>
<b class="nc"><i>1289</i>&nbsp;        /**</b>
<b class="nc"><i>1290</i>&nbsp;         * List of types undergoing construction via explicit constructor chaining.</b>
<b class="nc"><i>1291</i>&nbsp;         */</b>
<b class="nc"><i>1292</i>&nbsp;        private List&lt;ClassSymbol&gt; typesUnderConstruction;</b>
<b class="nc"><i>1293</i>&nbsp;</b>
<i>1294</i>&nbsp;        /**
<b class="nc"><i>1295</i>&nbsp;         * keep the count of lambda expression defined in given context (used to</b>
<i>1296</i>&nbsp;         * generate unambiguous names for serializable lambdas)
<b class="nc"><i>1297</i>&nbsp;         */</b>
<b class="nc"><i>1298</i>&nbsp;        private class SyntheticMethodNameCounter {</b>
<b class="nc"><i>1299</i>&nbsp;            private Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</b>
<b class="nc"><i>1300</i>&nbsp;            int getIndex(StringBuilder buf) {</b>
<b class="nc"><i>1301</i>&nbsp;                String temp = buf.toString();</b>
<b class="nc"><i>1302</i>&nbsp;                Integer count = map.get(temp);</b>
<b class="nc"><i>1303</i>&nbsp;                if (count == null) {</b>
<i>1304</i>&nbsp;                    count = 0;
<b class="nc"><i>1305</i>&nbsp;                }</b>
<b class="nc"><i>1306</i>&nbsp;                ++count;</b>
<b class="nc"><i>1307</i>&nbsp;                map.put(temp, count);</b>
<b class="nc"><i>1308</i>&nbsp;                return count;</b>
<i>1309</i>&nbsp;            }
<b class="nc"><i>1310</i>&nbsp;        }</b>
<i>1311</i>&nbsp;        private SyntheticMethodNameCounter syntheticMethodNameCounts =
<i>1312</i>&nbsp;                new SyntheticMethodNameCounter();
<b class="nc"><i>1313</i>&nbsp;</b>
<i>1314</i>&nbsp;        private Map&lt;Symbol, JCClassDecl&gt; localClassDefs;
<i>1315</i>&nbsp;
<i>1316</i>&nbsp;        /**
<b class="nc"><i>1317</i>&nbsp;         * maps for fake clinit symbols to be used as owners of lambda occurring in</b>
<i>1318</i>&nbsp;         * a static var init context
<i>1319</i>&nbsp;         */
<i>1320</i>&nbsp;        private Map&lt;ClassSymbol, Symbol&gt; clinits = new HashMap&lt;&gt;();
<i>1321</i>&nbsp;
<b class="nc"><i>1322</i>&nbsp;        private JCClassDecl analyzeAndPreprocessClass(JCClassDecl tree) {</b>
<i>1323</i>&nbsp;            frameStack = List.nil();
<i>1324</i>&nbsp;            typesUnderConstruction = List.nil();
<i>1325</i>&nbsp;            localClassDefs = new HashMap&lt;&gt;();
<i>1326</i>&nbsp;            return translate(tree);
<b class="nc"><i>1327</i>&nbsp;        }</b>
<b class="nc"><i>1328</i>&nbsp;</b>
<b class="nc"><i>1329</i>&nbsp;        @Override</b>
<b class="nc"><i>1330</i>&nbsp;        public void visitApply(JCMethodInvocation tree) {</b>
<i>1331</i>&nbsp;            List&lt;ClassSymbol&gt; previousNascentTypes = typesUnderConstruction;
<i>1332</i>&nbsp;            try {
<i>1333</i>&nbsp;                Name methName = TreeInfo.name(tree.meth);
<i>1334</i>&nbsp;                if (methName == names._this || methName == names._super) {
<b class="nc"><i>1335</i>&nbsp;                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());</b>
<i>1336</i>&nbsp;                }
<b class="nc"><i>1337</i>&nbsp;                super.visitApply(tree);</b>
<b class="nc"><i>1338</i>&nbsp;            } finally {</b>
<b class="nc"><i>1339</i>&nbsp;                typesUnderConstruction = previousNascentTypes;</b>
<i>1340</i>&nbsp;            }
<b class="nc"><i>1341</i>&nbsp;        }</b>
<b class="nc"><i>1342</i>&nbsp;            // where</b>
<b class="nc"><i>1343</i>&nbsp;            private ClassSymbol currentClass() {</b>
<b class="nc"><i>1344</i>&nbsp;                for (Frame frame : frameStack) {</b>
<b class="nc"><i>1345</i>&nbsp;                    if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {</b>
<b class="nc"><i>1346</i>&nbsp;                        JCClassDecl cdef = (JCClassDecl) frame.tree;</b>
<b class="nc"><i>1347</i>&nbsp;                        return cdef.sym;</b>
<b class="nc"><i>1348</i>&nbsp;                    }</b>
<b class="nc"><i>1349</i>&nbsp;                }</b>
<i>1350</i>&nbsp;                return null;
<i>1351</i>&nbsp;            }
<b class="nc"><i>1352</i>&nbsp;</b>
<i>1353</i>&nbsp;        @Override
<i>1354</i>&nbsp;        public void visitBlock(JCBlock tree) {
<i>1355</i>&nbsp;            List&lt;Frame&gt; prevStack = frameStack;
<i>1356</i>&nbsp;            try {
<i>1357</i>&nbsp;                if (frameStack.nonEmpty() &amp;&amp; frameStack.head.tree.hasTag(CLASSDEF)) {
<b class="nc"><i>1358</i>&nbsp;                    frameStack = frameStack.prepend(new Frame(tree));</b>
<i>1359</i>&nbsp;                }
<b class="nc"><i>1360</i>&nbsp;                super.visitBlock(tree);</b>
<b class="nc"><i>1361</i>&nbsp;            }</b>
<i>1362</i>&nbsp;            finally {
<i>1363</i>&nbsp;                frameStack = prevStack;
<b class="nc"><i>1364</i>&nbsp;            }</b>
<b class="nc"><i>1365</i>&nbsp;        }</b>
<i>1366</i>&nbsp;
<i>1367</i>&nbsp;        @Override
<i>1368</i>&nbsp;        public void visitClassDef(JCClassDecl tree) {
<i>1369</i>&nbsp;            List&lt;Frame&gt; prevStack = frameStack;
<b class="nc"><i>1370</i>&nbsp;            int prevLambdaCount = lambdaCount;</b>
<b class="nc"><i>1371</i>&nbsp;            SyntheticMethodNameCounter prevSyntheticMethodNameCounts =</b>
<b class="nc"><i>1372</i>&nbsp;                    syntheticMethodNameCounts;</b>
<b class="nc"><i>1373</i>&nbsp;            Map&lt;ClassSymbol, Symbol&gt; prevClinits = clinits;</b>
<b class="nc"><i>1374</i>&nbsp;            DiagnosticSource prevSource = log.currentSource();</b>
<b class="nc"><i>1375</i>&nbsp;            try {</b>
<b class="nc"><i>1376</i>&nbsp;                log.useSource(tree.sym.sourcefile);</b>
<b class="nc"><i>1377</i>&nbsp;                lambdaCount = 0;</b>
<b class="nc"><i>1378</i>&nbsp;                syntheticMethodNameCounts = new SyntheticMethodNameCounter();</b>
<i>1379</i>&nbsp;                prevClinits = new HashMap&lt;&gt;();
<b class="nc"><i>1380</i>&nbsp;                if (tree.sym.owner.kind == MTH) {</b>
<i>1381</i>&nbsp;                    localClassDefs.put(tree.sym, tree);
<i>1382</i>&nbsp;                }
<b class="nc"><i>1383</i>&nbsp;                if (directlyEnclosingLambda() != null) {</b>
<b class="nc"><i>1384</i>&nbsp;                    tree.sym.owner = owner();</b>
<b class="nc"><i>1385</i>&nbsp;                    if (tree.sym.hasOuterInstance()) {</b>
<i>1386</i>&nbsp;                        //if a class is defined within a lambda, the lambda must capture
<b class="nc"><i>1387</i>&nbsp;                        //its enclosing instance (if any)</b>
<i>1388</i>&nbsp;                        TranslationContext&lt;?&gt; localContext = context();
<i>1389</i>&nbsp;                        final TypeSymbol outerInstanceSymbol = tree.sym.type.getEnclosingType().tsym;
<i>1390</i>&nbsp;                        while (localContext != null &amp;&amp; !localContext.owner.isStatic()) {
<b class="nc"><i>1391</i>&nbsp;                            if (localContext.tree.hasTag(LAMBDA)) {</b>
<b class="nc"><i>1392</i>&nbsp;                                JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);</b>
<b class="nc"><i>1393</i>&nbsp;                                if (block == null) break;</b>
<i>1394</i>&nbsp;                                ((LambdaTranslationContext)localContext)
<i>1395</i>&nbsp;                                        .addSymbol(outerInstanceSymbol, CAPTURED_THIS);
<b class="nc"><i>1396</i>&nbsp;                            }</b>
<i>1397</i>&nbsp;                            localContext = localContext.prev;
<i>1398</i>&nbsp;                        }
<i>1399</i>&nbsp;                    }
<b class="nc"><i>1400</i>&nbsp;                }</b>
<i>1401</i>&nbsp;                frameStack = frameStack.prepend(new Frame(tree));
<b class="nc"><i>1402</i>&nbsp;                super.visitClassDef(tree);</b>
<b class="nc"><i>1403</i>&nbsp;            }</b>
<b class="nc"><i>1404</i>&nbsp;            finally {</b>
<b class="nc"><i>1405</i>&nbsp;                log.useSource(prevSource.getFile());</b>
<b class="nc"><i>1406</i>&nbsp;                frameStack = prevStack;</b>
<b class="nc"><i>1407</i>&nbsp;                lambdaCount = prevLambdaCount;</b>
<b class="nc"><i>1408</i>&nbsp;                syntheticMethodNameCounts = prevSyntheticMethodNameCounts;</b>
<i>1409</i>&nbsp;                clinits = prevClinits;
<b class="nc"><i>1410</i>&nbsp;            }</b>
<i>1411</i>&nbsp;        }
<i>1412</i>&nbsp;
<i>1413</i>&nbsp;        @Override
<i>1414</i>&nbsp;        public void visitIdent(JCIdent tree) {
<b class="nc"><i>1415</i>&nbsp;            if (context() != null &amp;&amp; lambdaIdentSymbolFilter(tree.sym)) {</b>
<i>1416</i>&nbsp;                if (tree.sym.kind == VAR &amp;&amp;
<i>1417</i>&nbsp;                        tree.sym.owner.kind == MTH &amp;&amp;
<i>1418</i>&nbsp;                        tree.type.constValue() == null) {
<i>1419</i>&nbsp;                    TranslationContext&lt;?&gt; localContext = context();
<b class="nc"><i>1420</i>&nbsp;                    while (localContext != null) {</b>
<b class="nc"><i>1421</i>&nbsp;                        if (localContext.tree.getTag() == LAMBDA) {</b>
<b class="nc"><i>1422</i>&nbsp;                            JCTree block = capturedDecl(localContext.depth, tree.sym);</b>
<b class="nc"><i>1423</i>&nbsp;                            if (block == null) break;</b>
<b class="nc"><i>1424</i>&nbsp;                            ((LambdaTranslationContext)localContext)</b>
<i>1425</i>&nbsp;                                    .addSymbol(tree.sym, CAPTURED_VAR);
<i>1426</i>&nbsp;                        }
<b class="nc"><i>1427</i>&nbsp;                        localContext = localContext.prev;</b>
<b class="nc"><i>1428</i>&nbsp;                    }</b>
<i>1429</i>&nbsp;                } else if (tree.sym.owner.kind == TYP) {
<i>1430</i>&nbsp;                    TranslationContext&lt;?&gt; localContext = context();
<i>1431</i>&nbsp;                    while (localContext != null  &amp;&amp; !localContext.owner.isStatic()) {
<i>1432</i>&nbsp;                        if (localContext.tree.hasTag(LAMBDA)) {
<i>1433</i>&nbsp;                            JCTree block = capturedDecl(localContext.depth, tree.sym);
<i>1434</i>&nbsp;                            if (block == null) break;
<i>1435</i>&nbsp;                            switch (block.getTag()) {
<i>1436</i>&nbsp;                                case CLASSDEF:
<i>1437</i>&nbsp;                                    JCClassDecl cdecl = (JCClassDecl)block;
<i>1438</i>&nbsp;                                    ((LambdaTranslationContext)localContext)
<i>1439</i>&nbsp;                                            .addSymbol(cdecl.sym, CAPTURED_THIS);
<i>1440</i>&nbsp;                                    break;
<i>1441</i>&nbsp;                                default:
<i>1442</i>&nbsp;                                    Assert.error(&quot;bad block kind&quot;);
<i>1443</i>&nbsp;                            }
<i>1444</i>&nbsp;                        }
<b class="nc"><i>1445</i>&nbsp;                        localContext = localContext.prev;</b>
<b class="nc"><i>1446</i>&nbsp;                    }</b>
<b class="nc"><i>1447</i>&nbsp;                }</b>
<i>1448</i>&nbsp;            }
<b class="nc"><i>1449</i>&nbsp;            super.visitIdent(tree);</b>
<b class="nc"><i>1450</i>&nbsp;        }</b>
<b class="nc"><i>1451</i>&nbsp;</b>
<b class="nc"><i>1452</i>&nbsp;        @Override</b>
<b class="nc"><i>1453</i>&nbsp;        public void visitLambda(JCLambda tree) {</b>
<b class="nc"><i>1454</i>&nbsp;            analyzeLambda(tree, &quot;lambda.stat&quot;);</b>
<i>1455</i>&nbsp;        }
<i>1456</i>&nbsp;
<i>1457</i>&nbsp;        private void analyzeLambda(JCLambda tree, JCExpression methodReferenceReceiver) {
<i>1458</i>&nbsp;            // Translation of the receiver expression must occur first
<i>1459</i>&nbsp;            JCExpression rcvr = translate(methodReferenceReceiver);
<i>1460</i>&nbsp;            LambdaTranslationContext context = analyzeLambda(tree, &quot;mref.stat.1&quot;);
<b class="nc"><i>1461</i>&nbsp;            if (rcvr != null) {</b>
<b class="nc"><i>1462</i>&nbsp;                context.methodReferenceReceiver = rcvr;</b>
<b class="nc"><i>1463</i>&nbsp;            }</b>
<i>1464</i>&nbsp;        }
<i>1465</i>&nbsp;
<b class="nc"><i>1466</i>&nbsp;        private LambdaTranslationContext analyzeLambda(JCLambda tree, String statKey) {</b>
<b class="nc"><i>1467</i>&nbsp;            List&lt;Frame&gt; prevStack = frameStack;</b>
<b class="nc"><i>1468</i>&nbsp;            try {</b>
<b class="nc"><i>1469</i>&nbsp;                LambdaTranslationContext context = new LambdaTranslationContext(tree);</b>
<b class="nc"><i>1470</i>&nbsp;                frameStack = frameStack.prepend(new Frame(tree));</b>
<b class="nc"><i>1471</i>&nbsp;                for (JCVariableDecl param : tree.params) {</b>
<i>1472</i>&nbsp;                    context.addSymbol(param.sym, PARAM);
<b class="nc"><i>1473</i>&nbsp;                    frameStack.head.addLocal(param.sym);</b>
<i>1474</i>&nbsp;                }
<i>1475</i>&nbsp;                contextMap.put(tree, context);
<b class="nc"><i>1476</i>&nbsp;                super.visitLambda(tree);</b>
<i>1477</i>&nbsp;                context.complete();
<i>1478</i>&nbsp;                if (dumpLambdaToMethodStats) {
<i>1479</i>&nbsp;                    log.note(tree, diags.noteKey(statKey, context.needsAltMetafactory(), context.translatedSym));
<i>1480</i>&nbsp;                }
<b class="nc"><i>1481</i>&nbsp;                return context;</b>
<b class="nc"><i>1482</i>&nbsp;            }</b>
<i>1483</i>&nbsp;            finally {
<i>1484</i>&nbsp;                frameStack = prevStack;
<b class="nc"><i>1485</i>&nbsp;            }</b>
<b class="nc"><i>1486</i>&nbsp;        }</b>
<b class="nc"><i>1487</i>&nbsp;</b>
<i>1488</i>&nbsp;        @Override
<i>1489</i>&nbsp;        public void visitMethodDef(JCMethodDecl tree) {
<i>1490</i>&nbsp;            List&lt;Frame&gt; prevStack = frameStack;
<b class="nc"><i>1491</i>&nbsp;            try {</b>
<b class="nc"><i>1492</i>&nbsp;                frameStack = frameStack.prepend(new Frame(tree));</b>
<b class="nc"><i>1493</i>&nbsp;                super.visitMethodDef(tree);</b>
<i>1494</i>&nbsp;            }
<i>1495</i>&nbsp;            finally {
<i>1496</i>&nbsp;                frameStack = prevStack;
<b class="nc"><i>1497</i>&nbsp;            }</b>
<i>1498</i>&nbsp;        }
<b class="nc"><i>1499</i>&nbsp;</b>
<b class="nc"><i>1500</i>&nbsp;        @Override</b>
<i>1501</i>&nbsp;        public void visitNewClass(JCNewClass tree) {
<b class="nc"><i>1502</i>&nbsp;            TypeSymbol def = tree.type.tsym;</b>
<b class="nc"><i>1503</i>&nbsp;            boolean inReferencedClass = currentlyInClass(def);</b>
<i>1504</i>&nbsp;            boolean isLocal = def.isLocal();
<i>1505</i>&nbsp;            if ((inReferencedClass &amp;&amp; isLocal || lambdaNewClassFilter(context(), tree))) {
<b class="nc"><i>1506</i>&nbsp;                TranslationContext&lt;?&gt; localContext = context();</b>
<b class="nc"><i>1507</i>&nbsp;                final TypeSymbol outerInstanceSymbol = tree.type.getEnclosingType().tsym;</b>
<i>1508</i>&nbsp;                while (localContext != null  &amp;&amp; !localContext.owner.isStatic()) {
<i>1509</i>&nbsp;                    if (localContext.tree.hasTag(LAMBDA)) {
<i>1510</i>&nbsp;                        if (outerInstanceSymbol != null) {
<i>1511</i>&nbsp;                            JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);
<i>1512</i>&nbsp;                            if (block == null) break;
<i>1513</i>&nbsp;                        }
<i>1514</i>&nbsp;                        ((LambdaTranslationContext)localContext)
<b class="nc"><i>1515</i>&nbsp;                                .addSymbol(outerInstanceSymbol, CAPTURED_THIS);</b>
<i>1516</i>&nbsp;                    }
<i>1517</i>&nbsp;                    localContext = localContext.prev;
<i>1518</i>&nbsp;                }
<i>1519</i>&nbsp;            }
<b class="nc"><i>1520</i>&nbsp;            if (context() != null &amp;&amp; !inReferencedClass &amp;&amp; isLocal) {</b>
<b class="nc"><i>1521</i>&nbsp;                LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context();</b>
<b class="nc"><i>1522</i>&nbsp;                captureLocalClassDefs(def, lambdaContext);</b>
<i>1523</i>&nbsp;            }
<b class="nc"><i>1524</i>&nbsp;            super.visitNewClass(tree);</b>
<b class="nc"><i>1525</i>&nbsp;        }</b>
<b class="nc"><i>1526</i>&nbsp;        //where</b>
<i>1527</i>&nbsp;            void captureLocalClassDefs(Symbol csym, final LambdaTranslationContext lambdaContext) {
<b class="nc"><i>1528</i>&nbsp;                JCClassDecl localCDef = localClassDefs.get(csym);</b>
<b class="nc"><i>1529</i>&nbsp;                if (localCDef != null &amp;&amp; lambdaContext.freeVarProcessedLocalClasses.add(csym)) {</b>
<b class="nc"><i>1530</i>&nbsp;                    BasicFreeVarCollector fvc = lower.new BasicFreeVarCollector() {</b>
<i>1531</i>&nbsp;                        @Override
<b class="nc"><i>1532</i>&nbsp;                        void addFreeVars(ClassSymbol c) {</b>
<b class="nc"><i>1533</i>&nbsp;                            captureLocalClassDefs(c, lambdaContext);</b>
<i>1534</i>&nbsp;                        }
<i>1535</i>&nbsp;                        @Override
<b class="nc"><i>1536</i>&nbsp;                        void visitSymbol(Symbol sym) {</b>
<i>1537</i>&nbsp;                            if (sym.kind == VAR &amp;&amp;
<b class="nc"><i>1538</i>&nbsp;                                    sym.owner.kind == MTH &amp;&amp;</b>
<i>1539</i>&nbsp;                                    ((VarSymbol)sym).getConstValue() == null) {
<b class="nc"><i>1540</i>&nbsp;                                TranslationContext&lt;?&gt; localContext = context();</b>
<b class="nc"><i>1541</i>&nbsp;                                while (localContext != null) {</b>
<b class="nc"><i>1542</i>&nbsp;                                    if (localContext.tree.getTag() == LAMBDA) {</b>
<i>1543</i>&nbsp;                                        JCTree block = capturedDecl(localContext.depth, sym);
<b class="nc"><i>1544</i>&nbsp;                                        if (block == null) break;</b>
<i>1545</i>&nbsp;                                        ((LambdaTranslationContext)localContext).addSymbol(sym, CAPTURED_VAR);
<i>1546</i>&nbsp;                                    }
<b class="nc"><i>1547</i>&nbsp;                                    localContext = localContext.prev;</b>
<b class="nc"><i>1548</i>&nbsp;                                }</b>
<i>1549</i>&nbsp;                            }
<i>1550</i>&nbsp;                        }
<i>1551</i>&nbsp;                    };
<b class="nc"><i>1552</i>&nbsp;                    fvc.scan(localCDef);</b>
<b class="nc"><i>1553</i>&nbsp;                }</b>
<i>1554</i>&nbsp;        }
<i>1555</i>&nbsp;        //where
<i>1556</i>&nbsp;        boolean currentlyInClass(Symbol csym) {
<i>1557</i>&nbsp;            for (Frame frame : frameStack) {
<i>1558</i>&nbsp;                if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {
<b class="nc"><i>1559</i>&nbsp;                    JCClassDecl cdef = (JCClassDecl) frame.tree;</b>
<b class="nc"><i>1560</i>&nbsp;                    if (cdef.sym == csym) {</b>
<b class="nc"><i>1561</i>&nbsp;                        return true;</b>
<b class="nc"><i>1562</i>&nbsp;                    }</b>
<i>1563</i>&nbsp;                }
<i>1564</i>&nbsp;            }
<i>1565</i>&nbsp;            return false;
<i>1566</i>&nbsp;        }
<b class="nc"><i>1567</i>&nbsp;</b>
<b class="nc"><i>1568</i>&nbsp;        /**</b>
<i>1569</i>&nbsp;         * Method references to local class constructors, may, if the local
<i>1570</i>&nbsp;         * class references local variables, have implicit constructor
<b class="nc"><i>1571</i>&nbsp;         * parameters added in Lower; As a result, the invokedynamic bootstrap</b>
<b class="nc"><i>1572</i>&nbsp;         * information added in the LambdaToMethod pass will have the wrong</b>
<b class="nc"><i>1573</i>&nbsp;         * signature. Hooks between Lower and LambdaToMethod have been added to</b>
<b class="nc"><i>1574</i>&nbsp;         * handle normal &quot;new&quot; in this case. This visitor converts potentially</b>
<i>1575</i>&nbsp;         * affected method references into a lambda containing a normal
<b class="nc"><i>1576</i>&nbsp;         * expression.</b>
<i>1577</i>&nbsp;         *
<b class="nc"><i>1578</i>&nbsp;         * @param tree</b>
<i>1579</i>&nbsp;         */
<i>1580</i>&nbsp;        @Override
<b class="nc"><i>1581</i>&nbsp;        public void visitReference(JCMemberReference tree) {</b>
<b class="nc"><i>1582</i>&nbsp;            ReferenceTranslationContext rcontext = new ReferenceTranslationContext(tree);</b>
<i>1583</i>&nbsp;            contextMap.put(tree, rcontext);
<i>1584</i>&nbsp;            if (rcontext.needsConversionToLambda()) {
<b class="nc"><i>1585</i>&nbsp;                 // Convert to a lambda, and process as such</b>
<b class="nc"><i>1586</i>&nbsp;                MemberReferenceToLambda conv = new MemberReferenceToLambda(tree, rcontext, owner());</b>
<i>1587</i>&nbsp;                analyzeLambda(conv.lambda(), conv.getReceiverExpression());
<i>1588</i>&nbsp;            } else {
<i>1589</i>&nbsp;                super.visitReference(tree);
<b class="nc"><i>1590</i>&nbsp;                if (dumpLambdaToMethodStats) {</b>
<b class="nc"><i>1591</i>&nbsp;                    log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));</b>
<i>1592</i>&nbsp;                }
<b class="nc"><i>1593</i>&nbsp;            }</b>
<b class="nc"><i>1594</i>&nbsp;        }</b>
<b class="nc"><i>1595</i>&nbsp;</b>
<i>1596</i>&nbsp;        @Override
<i>1597</i>&nbsp;        public void visitSelect(JCFieldAccess tree) {
<b class="nc"><i>1598</i>&nbsp;            if (context() != null &amp;&amp; tree.sym.kind == VAR &amp;&amp;</b>
<i>1599</i>&nbsp;                        (tree.sym.name == names._this ||
<b class="nc"><i>1600</i>&nbsp;                         tree.sym.name == names._super)) {</b>
<i>1601</i>&nbsp;                // A select of this or super means, if we are in a lambda,
<b class="nc"><i>1602</i>&nbsp;                // we much have an instance context</b>
<i>1603</i>&nbsp;                TranslationContext&lt;?&gt; localContext = context();
<i>1604</i>&nbsp;                while (localContext != null  &amp;&amp; !localContext.owner.isStatic()) {
<b class="nc"><i>1605</i>&nbsp;                    if (localContext.tree.hasTag(LAMBDA)) {</b>
<b class="nc"><i>1606</i>&nbsp;                        JCClassDecl clazz = (JCClassDecl)capturedDecl(localContext.depth, tree.sym);</b>
<i>1607</i>&nbsp;                        if (clazz == null) break;
<i>1608</i>&nbsp;                        ((LambdaTranslationContext)localContext).addSymbol(clazz.sym, CAPTURED_THIS);
<i>1609</i>&nbsp;                    }
<b class="nc"><i>1610</i>&nbsp;                    localContext = localContext.prev;</b>
<b class="nc"><i>1611</i>&nbsp;                }</b>
<i>1612</i>&nbsp;            }
<b class="nc"><i>1613</i>&nbsp;            super.visitSelect(tree);</b>
<b class="nc"><i>1614</i>&nbsp;        }</b>
<b class="nc"><i>1615</i>&nbsp;</b>
<b class="nc"><i>1616</i>&nbsp;        @Override</b>
<i>1617</i>&nbsp;        public void visitVarDef(JCVariableDecl tree) {
<b class="nc"><i>1618</i>&nbsp;            TranslationContext&lt;?&gt; context = context();</b>
<i>1619</i>&nbsp;            LambdaTranslationContext ltc = (context != null &amp;&amp; context instanceof LambdaTranslationContext)?
<b class="nc"><i>1620</i>&nbsp;                    (LambdaTranslationContext)context :</b>
<b class="nc"><i>1621</i>&nbsp;                    null;</b>
<b class="nc"><i>1622</i>&nbsp;            if (ltc != null) {</b>
<i>1623</i>&nbsp;                if (frameStack.head.tree.hasTag(LAMBDA)) {
<b class="nc"><i>1624</i>&nbsp;                    ltc.addSymbol(tree.sym, LOCAL_VAR);</b>
<i>1625</i>&nbsp;                }
<i>1626</i>&nbsp;                // Check for type variables (including as type arguments).
<i>1627</i>&nbsp;                // If they occur within class nested in a lambda, mark for erasure
<b class="nc"><i>1628</i>&nbsp;                Type type = tree.sym.asType();</b>
<i>1629</i>&nbsp;                if (inClassWithinLambda() &amp;&amp; !types.isSameType(types.erasure(type), type)) {
<i>1630</i>&nbsp;                    ltc.addSymbol(tree.sym, TYPE_VAR);
<i>1631</i>&nbsp;                }
<i>1632</i>&nbsp;            }
<i>1633</i>&nbsp;
<i>1634</i>&nbsp;            List&lt;Frame&gt; prevStack = frameStack;
<i>1635</i>&nbsp;            try {
<i>1636</i>&nbsp;                if (tree.sym.owner.kind == MTH) {
<b class="nc"><i>1637</i>&nbsp;                    frameStack.head.addLocal(tree.sym);</b>
<b class="nc"><i>1638</i>&nbsp;                }</b>
<b class="nc"><i>1639</i>&nbsp;                frameStack = frameStack.prepend(new Frame(tree));</b>
<i>1640</i>&nbsp;                super.visitVarDef(tree);
<b class="nc"><i>1641</i>&nbsp;            }</b>
<b class="nc"><i>1642</i>&nbsp;            finally {</b>
<b class="nc"><i>1643</i>&nbsp;                frameStack = prevStack;</b>
<i>1644</i>&nbsp;            }
<i>1645</i>&nbsp;        }
<i>1646</i>&nbsp;
<b class="nc"><i>1647</i>&nbsp;        /**</b>
<i>1648</i>&nbsp;         * Return a valid owner given the current declaration stack
<b class="nc"><i>1649</i>&nbsp;         * (required to skip synthetic lambda symbols)</b>
<i>1650</i>&nbsp;         */
<i>1651</i>&nbsp;        private Symbol owner() {
<i>1652</i>&nbsp;            return owner(false);
<i>1653</i>&nbsp;        }
<i>1654</i>&nbsp;
<b class="nc"><i>1655</i>&nbsp;        @SuppressWarnings(&quot;fallthrough&quot;)</b>
<b class="nc"><i>1656</i>&nbsp;        private Symbol owner(boolean skipLambda) {</b>
<i>1657</i>&nbsp;            List&lt;Frame&gt; frameStack2 = frameStack;
<i>1658</i>&nbsp;            while (frameStack2.nonEmpty()) {
<i>1659</i>&nbsp;                switch (frameStack2.head.tree.getTag()) {
<b class="nc"><i>1660</i>&nbsp;                    case VARDEF:</b>
<i>1661</i>&nbsp;                        if (((JCVariableDecl)frameStack2.head.tree).sym.isLocal()) {
<b class="nc"><i>1662</i>&nbsp;                            frameStack2 = frameStack2.tail;</b>
<b class="nc"><i>1663</i>&nbsp;                            break;</b>
<b class="nc"><i>1664</i>&nbsp;                        }</b>
<i>1665</i>&nbsp;                        JCClassDecl cdecl = (JCClassDecl)frameStack2.tail.head.tree;
<i>1666</i>&nbsp;                        return initSym(cdecl.sym,
<i>1667</i>&nbsp;                                ((JCVariableDecl)frameStack2.head.tree).sym.flags() &amp; STATIC);
<b class="nc"><i>1668</i>&nbsp;                    case BLOCK:</b>
<b class="nc"><i>1669</i>&nbsp;                        JCClassDecl cdecl2 = (JCClassDecl)frameStack2.tail.head.tree;</b>
<b class="nc"><i>1670</i>&nbsp;                        return initSym(cdecl2.sym,</b>
<b class="nc"><i>1671</i>&nbsp;                                ((JCBlock)frameStack2.head.tree).flags &amp; STATIC);</b>
<i>1672</i>&nbsp;                    case CLASSDEF:
<b class="nc"><i>1673</i>&nbsp;                        return ((JCClassDecl)frameStack2.head.tree).sym;</b>
<b class="nc"><i>1674</i>&nbsp;                    case METHODDEF:</b>
<i>1675</i>&nbsp;                        return ((JCMethodDecl)frameStack2.head.tree).sym;
<i>1676</i>&nbsp;                    case LAMBDA:
<i>1677</i>&nbsp;                        if (!skipLambda)
<i>1678</i>&nbsp;                            return ((LambdaTranslationContext)contextMap
<i>1679</i>&nbsp;                                    .get(frameStack2.head.tree)).translatedSym;
<i>1680</i>&nbsp;                    default:
<i>1681</i>&nbsp;                        frameStack2 = frameStack2.tail;
<b class="nc"><i>1682</i>&nbsp;                }</b>
<b class="nc"><i>1683</i>&nbsp;            }</b>
<b class="nc"><i>1684</i>&nbsp;            Assert.error();</b>
<i>1685</i>&nbsp;            return null;
<i>1686</i>&nbsp;        }
<i>1687</i>&nbsp;
<i>1688</i>&nbsp;        private Symbol initSym(ClassSymbol csym, long flags) {
<i>1689</i>&nbsp;            boolean isStatic = (flags &amp; STATIC) != 0;
<i>1690</i>&nbsp;            if (isStatic) {
<i>1691</i>&nbsp;                /* static clinits are generated in Gen, so we need to use a fake
<i>1692</i>&nbsp;                 * one. Attr creates a fake clinit method while attributing
<b class="nc"><i>1693</i>&nbsp;                 * lambda expressions used as initializers of static fields, so</b>
<b class="nc"><i>1694</i>&nbsp;                 * let&#39;s use that one.</b>
<b class="nc"><i>1695</i>&nbsp;                 */</b>
<b class="nc"><i>1696</i>&nbsp;                MethodSymbol clinit = attr.removeClinit(csym);</b>
<b class="nc"><i>1697</i>&nbsp;                if (clinit != null) {</b>
<b class="nc"><i>1698</i>&nbsp;                    clinits.put(csym, clinit);</b>
<i>1699</i>&nbsp;                    return clinit;
<b class="nc"><i>1700</i>&nbsp;                }</b>
<i>1701</i>&nbsp;
<i>1702</i>&nbsp;                /* if no clinit is found at Attr, then let&#39;s try at clinits.
<i>1703</i>&nbsp;                 */
<i>1704</i>&nbsp;                clinit = (MethodSymbol)clinits.get(csym);
<i>1705</i>&nbsp;                if (clinit == null) {
<i>1706</i>&nbsp;                    /* no luck, let&#39;s create a new one
<i>1707</i>&nbsp;                     */
<b class="nc"><i>1708</i>&nbsp;                    clinit = makePrivateSyntheticMethod(STATIC,</b>
<i>1709</i>&nbsp;                            names.clinit,
<i>1710</i>&nbsp;                            new MethodType(List.nil(), syms.voidType,
<b class="nc"><i>1711</i>&nbsp;                                List.nil(), syms.methodClass),</b>
<b class="nc"><i>1712</i>&nbsp;                            csym);</b>
<b class="nc"><i>1713</i>&nbsp;                    clinits.put(csym, clinit);</b>
<b class="nc"><i>1714</i>&nbsp;                }</b>
<b class="nc"><i>1715</i>&nbsp;                return clinit;</b>
<b class="nc"><i>1716</i>&nbsp;            } else {</b>
<i>1717</i>&nbsp;                //get the first constructor and treat it as the instance init sym
<b class="nc"><i>1718</i>&nbsp;                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {</b>
<i>1719</i>&nbsp;                    return s;
<b class="nc"><i>1720</i>&nbsp;                }</b>
<i>1721</i>&nbsp;            }
<b class="nc"><i>1722</i>&nbsp;            Assert.error(&quot;init not found&quot;);</b>
<i>1723</i>&nbsp;            return null;
<i>1724</i>&nbsp;        }
<i>1725</i>&nbsp;
<i>1726</i>&nbsp;        private JCTree directlyEnclosingLambda() {
<i>1727</i>&nbsp;            if (frameStack.isEmpty()) {
<i>1728</i>&nbsp;                return null;
<i>1729</i>&nbsp;            }
<b class="nc"><i>1730</i>&nbsp;            List&lt;Frame&gt; frameStack2 = frameStack;</b>
<b class="nc"><i>1731</i>&nbsp;            while (frameStack2.nonEmpty()) {</b>
<i>1732</i>&nbsp;                switch (frameStack2.head.tree.getTag()) {
<i>1733</i>&nbsp;                    case CLASSDEF:
<i>1734</i>&nbsp;                    case METHODDEF:
<b class="nc"><i>1735</i>&nbsp;                        return null;</b>
<b class="nc"><i>1736</i>&nbsp;                    case LAMBDA:</b>
<i>1737</i>&nbsp;                        return frameStack2.head.tree;
<b class="nc"><i>1738</i>&nbsp;                    default:</b>
<i>1739</i>&nbsp;                        frameStack2 = frameStack2.tail;
<i>1740</i>&nbsp;                }
<i>1741</i>&nbsp;            }
<i>1742</i>&nbsp;            Assert.error();
<i>1743</i>&nbsp;            return null;
<i>1744</i>&nbsp;        }
<i>1745</i>&nbsp;
<i>1746</i>&nbsp;        private boolean inClassWithinLambda() {
<i>1747</i>&nbsp;            if (frameStack.isEmpty()) {
<i>1748</i>&nbsp;                return false;
<i>1749</i>&nbsp;            }
<i>1750</i>&nbsp;            List&lt;Frame&gt; frameStack2 = frameStack;
<i>1751</i>&nbsp;            boolean classFound = false;
<i>1752</i>&nbsp;            while (frameStack2.nonEmpty()) {
<i>1753</i>&nbsp;                switch (frameStack2.head.tree.getTag()) {
<i>1754</i>&nbsp;                    case LAMBDA:
<i>1755</i>&nbsp;                        return classFound;
<i>1756</i>&nbsp;                    case CLASSDEF:
<i>1757</i>&nbsp;                        classFound = true;
<i>1758</i>&nbsp;                        frameStack2 = frameStack2.tail;
<i>1759</i>&nbsp;                        break;
<i>1760</i>&nbsp;                    default:
<i>1761</i>&nbsp;                        frameStack2 = frameStack2.tail;
<i>1762</i>&nbsp;                }
<b class="nc"><i>1763</i>&nbsp;            }</b>
<b class="nc"><i>1764</i>&nbsp;            // No lambda</b>
<b class="nc"><i>1765</i>&nbsp;            return false;</b>
<b class="nc"><i>1766</i>&nbsp;        }</b>
<b class="nc"><i>1767</i>&nbsp;</b>
<b class="nc"><i>1768</i>&nbsp;        /**</b>
<b class="nc"><i>1769</i>&nbsp;         * Return the declaration corresponding to a symbol in the enclosing</b>
<b class="nc"><i>1770</i>&nbsp;         * scope; the depth parameter is used to filter out symbols defined</b>
<i>1771</i>&nbsp;         * in nested scopes (which do not need to undergo capture).
<i>1772</i>&nbsp;         */
<i>1773</i>&nbsp;        private JCTree capturedDecl(int depth, Symbol sym) {
<i>1774</i>&nbsp;            int currentDepth = frameStack.size() - 1;
<b class="nc"><i>1775</i>&nbsp;            for (Frame block : frameStack) {</b>
<b class="nc"><i>1776</i>&nbsp;                switch (block.tree.getTag()) {</b>
<b class="nc"><i>1777</i>&nbsp;                    case CLASSDEF:</b>
<i>1778</i>&nbsp;                        ClassSymbol clazz = ((JCClassDecl)block.tree).sym;
<i>1779</i>&nbsp;                        if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
<i>1780</i>&nbsp;                            return currentDepth &gt; depth ? null : block.tree;
<i>1781</i>&nbsp;                        }
<b class="nc"><i>1782</i>&nbsp;                        break;</b>
<b class="nc"><i>1783</i>&nbsp;                    case VARDEF:</b>
<i>1784</i>&nbsp;                        if (((JCVariableDecl)block.tree).sym == sym &amp;&amp;
<b class="nc"><i>1785</i>&nbsp;                                sym.owner.kind == MTH) { //only locals are captured</b>
<b class="nc"><i>1786</i>&nbsp;                            return currentDepth &gt; depth ? null : block.tree;</b>
<b class="nc"><i>1787</i>&nbsp;                        }</b>
<i>1788</i>&nbsp;                        break;
<b class="nc"><i>1789</i>&nbsp;                    case BLOCK:</b>
<b class="nc"><i>1790</i>&nbsp;                    case METHODDEF:</b>
<i>1791</i>&nbsp;                    case LAMBDA:
<i>1792</i>&nbsp;                        if (block.locals != null &amp;&amp; block.locals.contains(sym)) {
<i>1793</i>&nbsp;                            return currentDepth &gt; depth ? null : block.tree;
<i>1794</i>&nbsp;                        }
<i>1795</i>&nbsp;                        break;
<i>1796</i>&nbsp;                    default:
<i>1797</i>&nbsp;                        Assert.error(&quot;bad decl kind &quot; + block.tree.getTag());
<b class="nc"><i>1798</i>&nbsp;                }</b>
<i>1799</i>&nbsp;                currentDepth--;
<i>1800</i>&nbsp;            }
<i>1801</i>&nbsp;            return null;
<i>1802</i>&nbsp;        }
<i>1803</i>&nbsp;
<i>1804</i>&nbsp;        private TranslationContext&lt;?&gt; context() {
<i>1805</i>&nbsp;            for (Frame frame : frameStack) {
<b class="nc"><i>1806</i>&nbsp;                TranslationContext&lt;?&gt; context = contextMap.get(frame.tree);</b>
<b class="nc"><i>1807</i>&nbsp;                if (context != null) {</b>
<i>1808</i>&nbsp;                    return context;
<b class="nc"><i>1809</i>&nbsp;                }</b>
<b class="nc"><i>1810</i>&nbsp;            }</b>
<b class="nc"><i>1811</i>&nbsp;            return null;</b>
<b class="nc"><i>1812</i>&nbsp;        }</b>
<b class="nc"><i>1813</i>&nbsp;</b>
<i>1814</i>&nbsp;        /**
<b class="nc"><i>1815</i>&nbsp;         *  This is used to filter out those identifiers that needs to be adjusted</b>
<i>1816</i>&nbsp;         *  when translating away lambda expressions
<i>1817</i>&nbsp;         */
<i>1818</i>&nbsp;        private boolean lambdaIdentSymbolFilter(Symbol sym) {
<i>1819</i>&nbsp;            return (sym.kind == VAR || sym.kind == MTH)
<i>1820</i>&nbsp;                    &amp;&amp; !sym.isStatic()
<i>1821</i>&nbsp;                    &amp;&amp; sym.name != names.init;
<i>1822</i>&nbsp;        }
<i>1823</i>&nbsp;
<i>1824</i>&nbsp;        /**
<i>1825</i>&nbsp;         *  This is used to filter out those select nodes that need to be adjusted
<i>1826</i>&nbsp;         *  when translating away lambda expressions - at the moment, this is the
<i>1827</i>&nbsp;         *  set of nodes that select `this&#39; (qualified this)
<i>1828</i>&nbsp;         */
<i>1829</i>&nbsp;        private boolean lambdaFieldAccessFilter(JCFieldAccess fAccess) {
<i>1830</i>&nbsp;            LambdaTranslationContext lambdaContext =
<i>1831</i>&nbsp;                    context instanceof LambdaTranslationContext ?
<i>1832</i>&nbsp;                            (LambdaTranslationContext) context : null;
<i>1833</i>&nbsp;            return lambdaContext != null
<i>1834</i>&nbsp;                    &amp;&amp; !fAccess.sym.isStatic()
<i>1835</i>&nbsp;                    &amp;&amp; fAccess.name == names._this
<i>1836</i>&nbsp;                    &amp;&amp; (fAccess.sym.owner.kind == TYP)
<i>1837</i>&nbsp;                    &amp;&amp; !lambdaContext.translatedSymbols.get(CAPTURED_OUTER_THIS).isEmpty();
<i>1838</i>&nbsp;        }
<i>1839</i>&nbsp;
<i>1840</i>&nbsp;        /**
<i>1841</i>&nbsp;         * This is used to filter out those new class expressions that need to
<i>1842</i>&nbsp;         * be qualified with an enclosing tree
<i>1843</i>&nbsp;         */
<i>1844</i>&nbsp;        private boolean lambdaNewClassFilter(TranslationContext&lt;?&gt; context, JCNewClass tree) {
<i>1845</i>&nbsp;            if (context != null
<i>1846</i>&nbsp;                    &amp;&amp; tree.encl == null
<i>1847</i>&nbsp;                    &amp;&amp; tree.def == null
<i>1848</i>&nbsp;                    &amp;&amp; !tree.type.getEnclosingType().hasTag(NONE)) {
<i>1849</i>&nbsp;                Type encl = tree.type.getEnclosingType();
<i>1850</i>&nbsp;                Type current = context.owner.enclClass().type;
<i>1851</i>&nbsp;                while (!current.hasTag(NONE)) {
<b class="nc"><i>1852</i>&nbsp;                    if (current.tsym.isSubClass(encl.tsym, types)) {</b>
<b class="nc"><i>1853</i>&nbsp;                        return true;</b>
<b class="nc"><i>1854</i>&nbsp;                    }</b>
<b class="nc"><i>1855</i>&nbsp;                    current = current.getEnclosingType();</b>
<i>1856</i>&nbsp;                }
<b class="nc"><i>1857</i>&nbsp;                return false;</b>
<b class="nc"><i>1858</i>&nbsp;            } else {</b>
<i>1859</i>&nbsp;                return false;
<b class="nc"><i>1860</i>&nbsp;            }</b>
<b class="nc"><i>1861</i>&nbsp;        }</b>
<b class="nc"><i>1862</i>&nbsp;</b>
<i>1863</i>&nbsp;        private class Frame {
<b class="nc"><i>1864</i>&nbsp;            final JCTree tree;</b>
<i>1865</i>&nbsp;            List&lt;Symbol&gt; locals;
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;            public Frame(JCTree tree) {
<i>1868</i>&nbsp;                this.tree = tree;
<b class="nc"><i>1869</i>&nbsp;            }</b>
<i>1870</i>&nbsp;
<b class="nc"><i>1871</i>&nbsp;            void addLocal(Symbol sym) {</b>
<i>1872</i>&nbsp;                if (locals == null) {
<b class="nc"><i>1873</i>&nbsp;                    locals = List.nil();</b>
<b class="nc"><i>1874</i>&nbsp;                }</b>
<b class="nc"><i>1875</i>&nbsp;                locals = locals.prepend(sym);</b>
<b class="nc"><i>1876</i>&nbsp;            }</b>
<b class="nc"><i>1877</i>&nbsp;        }</b>
<b class="nc"><i>1878</i>&nbsp;</b>
<i>1879</i>&nbsp;        /**
<b class="nc"><i>1880</i>&nbsp;         * This class is used to store important information regarding translation of</b>
<i>1881</i>&nbsp;         * lambda expression/method references (see subclasses).
<i>1882</i>&nbsp;         */
<i>1883</i>&nbsp;        abstract class TranslationContext&lt;T extends JCFunctionalExpression&gt; {
<i>1884</i>&nbsp;
<i>1885</i>&nbsp;            /** the underlying (untranslated) tree */
<i>1886</i>&nbsp;            final T tree;
<i>1887</i>&nbsp;
<i>1888</i>&nbsp;            /** points to the adjusted enclosing scope in which this lambda/mref expression occurs */
<i>1889</i>&nbsp;            final Symbol owner;
<b class="nc"><i>1890</i>&nbsp;</b>
<i>1891</i>&nbsp;            /** the depth of this lambda expression in the frame stack */
<i>1892</i>&nbsp;            final int depth;
<i>1893</i>&nbsp;
<i>1894</i>&nbsp;            /** the enclosing translation context (set for nested lambdas/mref) */
<i>1895</i>&nbsp;            final TranslationContext&lt;?&gt; prev;
<i>1896</i>&nbsp;
<b class="nc"><i>1897</i>&nbsp;            /** list of methods to be bridged by the meta-factory */</b>
<i>1898</i>&nbsp;            final List&lt;Symbol&gt; bridges;
<b class="nc"><i>1899</i>&nbsp;</b>
<b class="nc"><i>1900</i>&nbsp;            TranslationContext(T tree) {</b>
<b class="nc"><i>1901</i>&nbsp;                this.tree = tree;</b>
<b class="nc"><i>1902</i>&nbsp;                this.owner = owner(true);</b>
<i>1903</i>&nbsp;                this.depth = frameStack.size() - 1;
<i>1904</i>&nbsp;                this.prev = context();
<i>1905</i>&nbsp;                ClassSymbol csym =
<b class="nc"><i>1906</i>&nbsp;                        types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);</b>
<b class="nc"><i>1907</i>&nbsp;                this.bridges = types.functionalInterfaceBridges(csym);</b>
<i>1908</i>&nbsp;            }
<i>1909</i>&nbsp;
<b class="nc"><i>1910</i>&nbsp;            /** does this functional expression need to be created using alternate metafactory? */</b>
<b class="nc"><i>1911</i>&nbsp;            boolean needsAltMetafactory() {</b>
<b class="nc"><i>1912</i>&nbsp;                return tree.target.isIntersection() ||</b>
<i>1913</i>&nbsp;                        isSerializable() ||
<i>1914</i>&nbsp;                        bridges.length() &gt; 1;
<b class="nc"><i>1915</i>&nbsp;            }</b>
<b class="nc"><i>1916</i>&nbsp;</b>
<b class="nc"><i>1917</i>&nbsp;            /** does this functional expression require serialization support? */</b>
<b class="nc"><i>1918</i>&nbsp;            boolean isSerializable() {</b>
<b class="nc"><i>1919</i>&nbsp;                if (forceSerializable) {</b>
<b class="nc"><i>1920</i>&nbsp;                    return true;</b>
<i>1921</i>&nbsp;                }
<b class="nc"><i>1922</i>&nbsp;                return types.asSuper(tree.target, syms.serializableType.tsym) != null;</b>
<i>1923</i>&nbsp;            }
<b class="nc"><i>1924</i>&nbsp;</b>
<i>1925</i>&nbsp;            /**
<i>1926</i>&nbsp;             * @return Name of the enclosing method to be folded into synthetic
<i>1927</i>&nbsp;             * method name
<i>1928</i>&nbsp;             */
<i>1929</i>&nbsp;            String enclosingMethodName() {
<i>1930</i>&nbsp;                return syntheticMethodNameComponent(owner.name);
<i>1931</i>&nbsp;            }
<i>1932</i>&nbsp;
<b class="nc"><i>1933</i>&nbsp;            /**</b>
<i>1934</i>&nbsp;             * @return Method name in a form that can be folded into a
<i>1935</i>&nbsp;             * component of a synthetic method name
<i>1936</i>&nbsp;             */
<i>1937</i>&nbsp;            String syntheticMethodNameComponent(Name name) {
<i>1938</i>&nbsp;                if (name == null) {
<i>1939</i>&nbsp;                    return &quot;null&quot;;
<i>1940</i>&nbsp;                }
<i>1941</i>&nbsp;                String methodName = name.toString();
<i>1942</i>&nbsp;                if (methodName.equals(&quot;&lt;clinit&gt;&quot;)) {
<b class="nc"><i>1943</i>&nbsp;                    methodName = &quot;static&quot;;</b>
<b class="nc"><i>1944</i>&nbsp;                } else if (methodName.equals(&quot;&lt;init&gt;&quot;)) {</b>
<i>1945</i>&nbsp;                    methodName = &quot;new&quot;;
<b class="nc"><i>1946</i>&nbsp;                }</b>
<b class="nc"><i>1947</i>&nbsp;                return methodName;</b>
<i>1948</i>&nbsp;            }
<i>1949</i>&nbsp;        }
<b class="nc"><i>1950</i>&nbsp;</b>
<b class="nc"><i>1951</i>&nbsp;        /**</b>
<b class="nc"><i>1952</i>&nbsp;         * This class retains all the useful information about a lambda expression;</b>
<i>1953</i>&nbsp;         * the contents of this class are filled by the LambdaAnalyzer visitor,
<i>1954</i>&nbsp;         * and the used by the main translation routines in order to adjust references
<b class="nc"><i>1955</i>&nbsp;         * to captured locals/members, etc.</b>
<b class="nc"><i>1956</i>&nbsp;         */</b>
<i>1957</i>&nbsp;        class LambdaTranslationContext extends TranslationContext&lt;JCLambda&gt; {
<b class="nc"><i>1958</i>&nbsp;</b>
<i>1959</i>&nbsp;            /** variable in the enclosing context to which this lambda is assigned */
<i>1960</i>&nbsp;            final Symbol self;
<i>1961</i>&nbsp;
<i>1962</i>&nbsp;            /** variable in the enclosing context to which this lambda is assigned */
<i>1963</i>&nbsp;            final Symbol assignedTo;
<i>1964</i>&nbsp;
<i>1965</i>&nbsp;            Map&lt;LambdaSymbolKind, Map&lt;Symbol, Symbol&gt;&gt; translatedSymbols;
<i>1966</i>&nbsp;
<b class="nc"><i>1967</i>&nbsp;            /** the synthetic symbol for the method hoisting the translated lambda */</b>
<i>1968</i>&nbsp;            MethodSymbol translatedSym;
<b class="nc"><i>1969</i>&nbsp;</b>
<b class="nc"><i>1970</i>&nbsp;            List&lt;JCVariableDecl&gt; syntheticParams;</b>
<i>1971</i>&nbsp;
<i>1972</i>&nbsp;            /**
<b class="nc"><i>1973</i>&nbsp;             * to prevent recursion, track local classes processed</b>
<b class="nc"><i>1974</i>&nbsp;             */</b>
<i>1975</i>&nbsp;            final Set&lt;Symbol&gt; freeVarProcessedLocalClasses;
<i>1976</i>&nbsp;
<i>1977</i>&nbsp;            /**
<i>1978</i>&nbsp;             * For method references converted to lambdas.  The method
<b class="nc"><i>1979</i>&nbsp;             * reference receiver expression. Must be treated like a captured</b>
<b class="nc"><i>1980</i>&nbsp;             * variable.</b>
<i>1981</i>&nbsp;             */
<b class="nc"><i>1982</i>&nbsp;            JCExpression methodReferenceReceiver;</b>
<i>1983</i>&nbsp;
<i>1984</i>&nbsp;            LambdaTranslationContext(JCLambda tree) {
<i>1985</i>&nbsp;                super(tree);
<b class="nc"><i>1986</i>&nbsp;                Frame frame = frameStack.head;</b>
<i>1987</i>&nbsp;                switch (frame.tree.getTag()) {
<i>1988</i>&nbsp;                    case VARDEF:
<b class="nc"><i>1989</i>&nbsp;                        assignedTo = self = ((JCVariableDecl) frame.tree).sym;</b>
<i>1990</i>&nbsp;                        break;
<b class="nc"><i>1991</i>&nbsp;                    case ASSIGN:</b>
<b class="nc"><i>1992</i>&nbsp;                        self = null;</b>
<i>1993</i>&nbsp;                        assignedTo = TreeInfo.symbol(((JCAssign) frame.tree).getVariable());
<i>1994</i>&nbsp;                        break;
<i>1995</i>&nbsp;                    default:
<b class="nc"><i>1996</i>&nbsp;                        assignedTo = self = null;</b>
<i>1997</i>&nbsp;                        break;
<i>1998</i>&nbsp;                 }
<b class="nc"><i>1999</i>&nbsp;</b>
<i>2000</i>&nbsp;                // This symbol will be filled-in in complete
<b class="nc"><i>2001</i>&nbsp;                this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());</b>
<b class="nc"><i>2002</i>&nbsp;</b>
<b class="nc"><i>2003</i>&nbsp;                translatedSymbols = new EnumMap&lt;&gt;(LambdaSymbolKind.class);</b>
<i>2004</i>&nbsp;
<b class="nc"><i>2005</i>&nbsp;                translatedSymbols.put(PARAM, new LinkedHashMap&lt;Symbol, Symbol&gt;());</b>
<b class="nc"><i>2006</i>&nbsp;                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());</b>
<b class="nc"><i>2007</i>&nbsp;                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());</b>
<i>2008</i>&nbsp;                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
<b class="nc"><i>2009</i>&nbsp;                translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());</b>
<b class="nc"><i>2010</i>&nbsp;                translatedSymbols.put(TYPE_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());</b>
<i>2011</i>&nbsp;
<b class="nc"><i>2012</i>&nbsp;                freeVarProcessedLocalClasses = new HashSet&lt;&gt;();</b>
<b class="nc"><i>2013</i>&nbsp;            }</b>
<b class="nc"><i>2014</i>&nbsp;</b>
<i>2015</i>&nbsp;             /**
<b class="nc"><i>2016</i>&nbsp;             * For a serializable lambda, generate a disambiguating string</b>
<i>2017</i>&nbsp;             * which maximizes stability across deserialization.
<i>2018</i>&nbsp;             *
<i>2019</i>&nbsp;             * @return String to differentiate synthetic lambda method names
<b class="nc"><i>2020</i>&nbsp;             */</b>
<b class="nc"><i>2021</i>&nbsp;            private String serializedLambdaDisambiguation() {</b>
<b class="nc"><i>2022</i>&nbsp;                StringBuilder buf = new StringBuilder();</b>
<i>2023</i>&nbsp;                // Append the enclosing method signature to differentiate
<b class="nc"><i>2024</i>&nbsp;                // overloaded enclosing methods.  For lambdas enclosed in</b>
<b class="nc"><i>2025</i>&nbsp;                // lambdas, the generated lambda method will not have type yet,</b>
<i>2026</i>&nbsp;                // but the enclosing method&#39;s name will have been generated
<i>2027</i>&nbsp;                // with this same method, so it will be unique and never be
<b class="nc"><i>2028</i>&nbsp;                // overloaded.</b>
<b class="nc"><i>2029</i>&nbsp;                Assert.check(</b>
<b class="nc"><i>2030</i>&nbsp;                        owner.type != null ||</b>
<i>2031</i>&nbsp;                        directlyEnclosingLambda() != null);
<i>2032</i>&nbsp;                if (owner.type != null) {
<i>2033</i>&nbsp;                    buf.append(typeSig(owner.type));
<i>2034</i>&nbsp;                    buf.append(&quot;:&quot;);
<b class="nc"><i>2035</i>&nbsp;                }</b>
<b class="nc"><i>2036</i>&nbsp;</b>
<b class="nc"><i>2037</i>&nbsp;                // Add target type info</b>
<i>2038</i>&nbsp;                buf.append(types.findDescriptorSymbol(tree.type.tsym).owner.flatName());
<i>2039</i>&nbsp;                buf.append(&quot; &quot;);
<i>2040</i>&nbsp;
<b class="nc"><i>2041</i>&nbsp;                // Add variable assigned to</b>
<b class="nc"><i>2042</i>&nbsp;                if (assignedTo != null) {</b>
<b class="nc"><i>2043</i>&nbsp;                    buf.append(assignedTo.flatName());</b>
<i>2044</i>&nbsp;                    buf.append(&quot;=&quot;);
<b class="nc"><i>2045</i>&nbsp;                }</b>
<b class="nc"><i>2046</i>&nbsp;                //add captured locals info: type, name, order</b>
<b class="nc"><i>2047</i>&nbsp;                for (Symbol fv : getSymbolMap(CAPTURED_VAR).keySet()) {</b>
<b class="nc"><i>2048</i>&nbsp;                    if (fv != self) {</b>
<b class="nc"><i>2049</i>&nbsp;                        buf.append(typeSig(fv.type));</b>
<i>2050</i>&nbsp;                        buf.append(&quot; &quot;);
<i>2051</i>&nbsp;                        buf.append(fv.flatName());
<i>2052</i>&nbsp;                        buf.append(&quot;,&quot;);
<b class="nc"><i>2053</i>&nbsp;                    }</b>
<i>2054</i>&nbsp;                }
<b class="nc"><i>2055</i>&nbsp;</b>
<b class="nc"><i>2056</i>&nbsp;                return buf.toString();</b>
<b class="nc"><i>2057</i>&nbsp;            }</b>
<b class="nc"><i>2058</i>&nbsp;</b>
<b class="nc"><i>2059</i>&nbsp;            /**</b>
<b class="nc"><i>2060</i>&nbsp;             * For a non-serializable lambda, generate a simple method.</b>
<b class="nc"><i>2061</i>&nbsp;             *</b>
<i>2062</i>&nbsp;             * @return Name to use for the synthetic lambda method name
<i>2063</i>&nbsp;             */
<i>2064</i>&nbsp;            private Name lambdaName() {
<i>2065</i>&nbsp;                return names.lambda.append(names.fromString(enclosingMethodName() + &quot;$&quot; + lambdaCount++));
<b class="nc"><i>2066</i>&nbsp;            }</b>
<i>2067</i>&nbsp;
<i>2068</i>&nbsp;            /**
<i>2069</i>&nbsp;             * For a serializable lambda, generate a method name which maximizes
<i>2070</i>&nbsp;             * name stability across deserialization.
<i>2071</i>&nbsp;             *
<i>2072</i>&nbsp;             * @return Name to use for the synthetic lambda method name
<b class="nc"><i>2073</i>&nbsp;             */</b>
<b class="nc"><i>2074</i>&nbsp;            private Name serializedLambdaName() {</b>
<b class="nc"><i>2075</i>&nbsp;                StringBuilder buf = new StringBuilder();</b>
<b class="nc"><i>2076</i>&nbsp;                buf.append(names.lambda);</b>
<b class="nc"><i>2077</i>&nbsp;                // Append the name of the method enclosing the lambda.</b>
<b class="nc"><i>2078</i>&nbsp;                buf.append(enclosingMethodName());</b>
<b class="nc"><i>2079</i>&nbsp;                buf.append(&#39;$&#39;);</b>
<i>2080</i>&nbsp;                // Append a hash of the disambiguating string : enclosing method
<b class="nc"><i>2081</i>&nbsp;                // signature, etc.</b>
<i>2082</i>&nbsp;                String disam = serializedLambdaDisambiguation();
<i>2083</i>&nbsp;                buf.append(Integer.toHexString(disam.hashCode()));
<i>2084</i>&nbsp;                buf.append(&#39;$&#39;);
<i>2085</i>&nbsp;                // The above appended name components may not be unique, append
<i>2086</i>&nbsp;                // a count based on the above name components.
<i>2087</i>&nbsp;                buf.append(syntheticMethodNameCounts.getIndex(buf));
<i>2088</i>&nbsp;                String result = buf.toString();
<i>2089</i>&nbsp;                //System.err.printf(&quot;serializedLambdaName: %s -- %s\n&quot;, result, disam);
<i>2090</i>&nbsp;                return names.fromString(result);
<b class="nc"><i>2091</i>&nbsp;            }</b>
<i>2092</i>&nbsp;
<i>2093</i>&nbsp;            /**
<b class="nc"><i>2094</i>&nbsp;             * Translate a symbol of a given kind into something suitable for the</b>
<b class="nc"><i>2095</i>&nbsp;             * synthetic lambda body</b>
<i>2096</i>&nbsp;             */
<i>2097</i>&nbsp;            Symbol translate(final Symbol sym, LambdaSymbolKind skind) {
<i>2098</i>&nbsp;                Symbol ret;
<i>2099</i>&nbsp;                switch (skind) {
<i>2100</i>&nbsp;                    case CAPTURED_THIS:
<i>2101</i>&nbsp;                        ret = sym;  // self represented
<b class="nc"><i>2102</i>&nbsp;                        break;</b>
<i>2103</i>&nbsp;                    case TYPE_VAR:
<i>2104</i>&nbsp;                        // Just erase the type var
<i>2105</i>&nbsp;                        ret = new VarSymbol(sym.flags(), sym.name,
<i>2106</i>&nbsp;                                types.erasure(sym.type), sym.owner);
<i>2107</i>&nbsp;
<i>2108</i>&nbsp;                        /* this information should also be kept for LVT generation at Gen
<b class="nc"><i>2109</i>&nbsp;                         * a Symbol with pos &lt; startPos won&#39;t be tracked.</b>
<b class="nc"><i>2110</i>&nbsp;                         */</b>
<i>2111</i>&nbsp;                        ((VarSymbol)ret).pos = ((VarSymbol)sym).pos;
<i>2112</i>&nbsp;                        break;
<i>2113</i>&nbsp;                    case CAPTURED_VAR:
<i>2114</i>&nbsp;                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {
<i>2115</i>&nbsp;                            @Override
<i>2116</i>&nbsp;                            public Symbol baseSymbol() {
<b class="nc"><i>2117</i>&nbsp;                                //keep mapping with original captured symbol</b>
<b class="nc"><i>2118</i>&nbsp;                                return sym;</b>
<b class="nc"><i>2119</i>&nbsp;                            }</b>
<b class="nc"><i>2120</i>&nbsp;                        };</b>
<b class="nc"><i>2121</i>&nbsp;                        break;</b>
<b class="nc"><i>2122</i>&nbsp;                    case CAPTURED_OUTER_THIS:</b>
<b class="nc"><i>2123</i>&nbsp;                        Name name = names.fromString(new String(sym.flatName().toString().replace(&#39;.&#39;, &#39;$&#39;) + names.dollarThis));</b>
<b class="nc"><i>2124</i>&nbsp;                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {</b>
<b class="nc"><i>2125</i>&nbsp;                            @Override</b>
<b class="nc"><i>2126</i>&nbsp;                            public Symbol baseSymbol() {</b>
<b class="nc"><i>2127</i>&nbsp;                                //keep mapping with original captured symbol</b>
<b class="nc"><i>2128</i>&nbsp;                                return sym;</b>
<b class="nc"><i>2129</i>&nbsp;                            }</b>
<i>2130</i>&nbsp;                        };
<b class="nc"><i>2131</i>&nbsp;                        break;</b>
<i>2132</i>&nbsp;                    case LOCAL_VAR:
<i>2133</i>&nbsp;                        ret = new VarSymbol(sym.flags() &amp; FINAL, sym.name, sym.type, translatedSym);
<b class="nc"><i>2134</i>&nbsp;                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;</b>
<b class="nc"><i>2135</i>&nbsp;                        break;</b>
<b class="nc"><i>2136</i>&nbsp;                    case PARAM:</b>
<i>2137</i>&nbsp;                        ret = new VarSymbol((sym.flags() &amp; FINAL) | PARAMETER, sym.name, types.erasure(sym.type), translatedSym);
<i>2138</i>&nbsp;                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;
<b class="nc"><i>2139</i>&nbsp;                        break;</b>
<b class="nc"><i>2140</i>&nbsp;                    default:</b>
<b class="nc"><i>2141</i>&nbsp;                        Assert.error(skind.name());</b>
<i>2142</i>&nbsp;                        throw new AssertionError();
<i>2143</i>&nbsp;                }
<i>2144</i>&nbsp;                if (ret != sym &amp;&amp; skind.propagateAnnotations()) {
<b class="nc"><i>2145</i>&nbsp;                    ret.setDeclarationAttributes(sym.getRawAttributes());</b>
<i>2146</i>&nbsp;                    ret.setTypeAttributes(sym.getRawTypeAttributes());
<i>2147</i>&nbsp;                }
<i>2148</i>&nbsp;                return ret;
<i>2149</i>&nbsp;            }
<i>2150</i>&nbsp;
<i>2151</i>&nbsp;            void addSymbol(Symbol sym, LambdaSymbolKind skind) {
<i>2152</i>&nbsp;                if (skind == CAPTURED_THIS &amp;&amp; sym != null &amp;&amp; sym.kind == TYP &amp;&amp; !typesUnderConstruction.isEmpty()) {
<i>2153</i>&nbsp;                    ClassSymbol currentClass = currentClass();
<i>2154</i>&nbsp;                    if (currentClass != null &amp;&amp; typesUnderConstruction.contains(currentClass)) {
<i>2155</i>&nbsp;                        // reference must be to enclosing outer instance, mutate capture kind.
<i>2156</i>&nbsp;                        Assert.check(sym != currentClass); // should have been caught right in Attr
<i>2157</i>&nbsp;                        skind = CAPTURED_OUTER_THIS;
<i>2158</i>&nbsp;                    }
<i>2159</i>&nbsp;                }
<b class="nc"><i>2160</i>&nbsp;                Map&lt;Symbol, Symbol&gt; transMap = getSymbolMap(skind);</b>
<b class="nc"><i>2161</i>&nbsp;                if (!transMap.containsKey(sym)) {</b>
<b class="nc"><i>2162</i>&nbsp;                    transMap.put(sym, translate(sym, skind));</b>
<b class="nc"><i>2163</i>&nbsp;                }</b>
<b class="nc"><i>2164</i>&nbsp;            }</b>
<i>2165</i>&nbsp;
<b class="nc"><i>2166</i>&nbsp;            Map&lt;Symbol, Symbol&gt; getSymbolMap(LambdaSymbolKind skind) {</b>
<b class="nc"><i>2167</i>&nbsp;                Map&lt;Symbol, Symbol&gt; m = translatedSymbols.get(skind);</b>
<i>2168</i>&nbsp;                Assert.checkNonNull(m);
<i>2169</i>&nbsp;                return m;
<i>2170</i>&nbsp;            }
<i>2171</i>&nbsp;
<i>2172</i>&nbsp;            JCTree translate(JCIdent lambdaIdent) {
<i>2173</i>&nbsp;                for (LambdaSymbolKind kind : LambdaSymbolKind.values()) {
<i>2174</i>&nbsp;                    Map&lt;Symbol, Symbol&gt; m = getSymbolMap(kind);
<b class="nc"><i>2175</i>&nbsp;                    switch(kind) {</b>
<i>2176</i>&nbsp;                        default:
<i>2177</i>&nbsp;                            if (m.containsKey(lambdaIdent.sym)) {
<i>2178</i>&nbsp;                                Symbol tSym = m.get(lambdaIdent.sym);
<b class="nc"><i>2179</i>&nbsp;                                JCTree t = make.Ident(tSym).setType(lambdaIdent.type);</b>
<i>2180</i>&nbsp;                                return t;
<i>2181</i>&nbsp;                            }
<i>2182</i>&nbsp;                            break;
<i>2183</i>&nbsp;                        case CAPTURED_OUTER_THIS:
<i>2184</i>&nbsp;                            Optional&lt;Symbol&gt; proxy = m.keySet().stream()
<i>2185</i>&nbsp;                                    .filter(out -&gt; lambdaIdent.sym.isMemberOf(out.type.tsym, types))
<b class="nc"><i>2186</i>&nbsp;                                    .reduce((a, b) -&gt; a.isEnclosedBy((ClassSymbol)b) ? a : b);</b>
<i>2187</i>&nbsp;                            if (proxy.isPresent()) {
<i>2188</i>&nbsp;                                // Transform outer instance variable references anchoring them to the captured synthetic.
<i>2189</i>&nbsp;                                Symbol tSym = m.get(proxy.get());
<i>2190</i>&nbsp;                                JCExpression t = make.Ident(tSym).setType(lambdaIdent.sym.owner.type);
<i>2191</i>&nbsp;                                t = make.Select(t, lambdaIdent.name);
<i>2192</i>&nbsp;                                t.setType(lambdaIdent.type);
<b class="nc"><i>2193</i>&nbsp;                                TreeInfo.setSymbol(t, lambdaIdent.sym);</b>
<i>2194</i>&nbsp;                                return t;
<i>2195</i>&nbsp;                            }
<i>2196</i>&nbsp;                            break;
<i>2197</i>&nbsp;                    }
<i>2198</i>&nbsp;                }
<i>2199</i>&nbsp;                return null;
<i>2200</i>&nbsp;            }
<b class="nc"><i>2201</i>&nbsp;</b>
<b class="nc"><i>2202</i>&nbsp;            /* Translate away qualified this expressions, anchoring them to synthetic parameters that</b>
<b class="nc"><i>2203</i>&nbsp;               capture the qualified this handle. `fieldAccess&#39; is guaranteed to one such.</b>
<b class="nc"><i>2204</i>&nbsp;            */</b>
<i>2205</i>&nbsp;            public JCTree translate(JCFieldAccess fieldAccess) {
<i>2206</i>&nbsp;                Assert.check(fieldAccess.name == names._this);
<i>2207</i>&nbsp;                Map&lt;Symbol, Symbol&gt; m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);
<i>2208</i>&nbsp;                if (m.containsKey(fieldAccess.sym.owner)) {
<i>2209</i>&nbsp;                    Symbol tSym = m.get(fieldAccess.sym.owner);
<i>2210</i>&nbsp;                    JCExpression t = make.Ident(tSym).setType(fieldAccess.sym.owner.type);
<i>2211</i>&nbsp;                    return t;
<b class="nc"><i>2212</i>&nbsp;                }</b>
<b class="nc"><i>2213</i>&nbsp;                return null;</b>
<i>2214</i>&nbsp;            }
<i>2215</i>&nbsp;
<i>2216</i>&nbsp;            /* Translate away naked new instance creation expressions with implicit enclosing instances,
<i>2217</i>&nbsp;               anchoring them to synthetic parameters that stand proxy for the qualified outer this handle.
<i>2218</i>&nbsp;            */
<i>2219</i>&nbsp;            public JCNewClass translate(JCNewClass newClass) {
<i>2220</i>&nbsp;                Assert.check(newClass.clazz.type.tsym.hasOuterInstance() &amp;&amp; newClass.encl == null);
<b class="nc"><i>2221</i>&nbsp;                Map&lt;Symbol, Symbol&gt; m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);</b>
<b class="nc"><i>2222</i>&nbsp;                final Type enclosingType = newClass.clazz.type.getEnclosingType();</b>
<b class="nc"><i>2223</i>&nbsp;                if (m.containsKey(enclosingType.tsym)) {</b>
<i>2224</i>&nbsp;                      Symbol tSym = m.get(enclosingType.tsym);
<b class="nc"><i>2225</i>&nbsp;                      JCExpression encl = make.Ident(tSym).setType(enclosingType);</b>
<b class="nc"><i>2226</i>&nbsp;                      newClass.encl = encl;</b>
<b class="nc"><i>2227</i>&nbsp;                }</b>
<b class="nc"><i>2228</i>&nbsp;                return newClass;</b>
<b class="nc"><i>2229</i>&nbsp;            }</b>
<b class="nc"><i>2230</i>&nbsp;</b>
<i>2231</i>&nbsp;            /**
<i>2232</i>&nbsp;             * The translatedSym is not complete/accurate until the analysis is
<i>2233</i>&nbsp;             * finished.  Once the analysis is finished, the translatedSym is
<b class="nc"><i>2234</i>&nbsp;             * &quot;completed&quot; -- updated with type information, access modifiers,</b>
<i>2235</i>&nbsp;             * and full parameter list.
<i>2236</i>&nbsp;             */
<i>2237</i>&nbsp;            void complete() {
<i>2238</i>&nbsp;                if (syntheticParams != null) {
<i>2239</i>&nbsp;                    return;
<i>2240</i>&nbsp;                }
<i>2241</i>&nbsp;                boolean inInterface = translatedSym.owner.isInterface();
<b class="nc"><i>2242</i>&nbsp;                boolean thisReferenced = !getSymbolMap(CAPTURED_THIS).isEmpty();</b>
<i>2243</i>&nbsp;
<b class="nc"><i>2244</i>&nbsp;                // If instance access isn&#39;t needed, make it static.</b>
<b class="nc"><i>2245</i>&nbsp;                // Interface instance methods must be default methods.</b>
<b class="nc"><i>2246</i>&nbsp;                // Lambda methods are private synthetic.</b>
<b class="nc"><i>2247</i>&nbsp;                // Inherit ACC_STRICT from the enclosing method, or, for clinit,</b>
<b class="nc"><i>2248</i>&nbsp;                // from the class.</b>
<i>2249</i>&nbsp;                translatedSym.flags_field = SYNTHETIC | LAMBDA_METHOD |
<b class="nc"><i>2250</i>&nbsp;                        owner.flags_field &amp; STRICTFP |</b>
<i>2251</i>&nbsp;                        owner.owner.flags_field &amp; STRICTFP |
<i>2252</i>&nbsp;                        PRIVATE |
<i>2253</i>&nbsp;                        (thisReferenced? (inInterface? DEFAULT : 0) : STATIC);
<b class="nc"><i>2254</i>&nbsp;</b>
<i>2255</i>&nbsp;                //compute synthetic params
<i>2256</i>&nbsp;                ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
<i>2257</i>&nbsp;                ListBuffer&lt;VarSymbol&gt; parameterSymbols = new ListBuffer&lt;&gt;();
<b class="nc"><i>2258</i>&nbsp;</b>
<i>2259</i>&nbsp;                // The signature of the method is augmented with the following
<i>2260</i>&nbsp;                // synthetic parameters:
<i>2261</i>&nbsp;                //
<i>2262</i>&nbsp;                // 1) reference to enclosing contexts captured by the lambda expression
<i>2263</i>&nbsp;                // 2) enclosing locals captured by the lambda expression
<i>2264</i>&nbsp;                for (Symbol thisSym : getSymbolMap(CAPTURED_VAR).values()) {
<i>2265</i>&nbsp;                    params.append(make.VarDef((VarSymbol) thisSym, null));
<i>2266</i>&nbsp;                    parameterSymbols.append((VarSymbol) thisSym);
<i>2267</i>&nbsp;                }
<b class="nc"><i>2268</i>&nbsp;                for (Symbol thisSym : getSymbolMap(CAPTURED_OUTER_THIS).values()) {</b>
<b class="nc"><i>2269</i>&nbsp;                    params.append(make.VarDef((VarSymbol) thisSym, null));</b>
<b class="nc"><i>2270</i>&nbsp;                    parameterSymbols.append((VarSymbol) thisSym);</b>
<b class="nc"><i>2271</i>&nbsp;                }</b>
<b class="nc"><i>2272</i>&nbsp;                for (Symbol thisSym : getSymbolMap(PARAM).values()) {</b>
<b class="nc"><i>2273</i>&nbsp;                    params.append(make.VarDef((VarSymbol) thisSym, null));</b>
<b class="nc"><i>2274</i>&nbsp;                    parameterSymbols.append((VarSymbol) thisSym);</b>
<i>2275</i>&nbsp;                }
<i>2276</i>&nbsp;                syntheticParams = params.toList();
<i>2277</i>&nbsp;
<i>2278</i>&nbsp;                translatedSym.params = parameterSymbols.toList();
<i>2279</i>&nbsp;
<i>2280</i>&nbsp;                // Compute and set the lambda name
<i>2281</i>&nbsp;                translatedSym.name = isSerializable()
<i>2282</i>&nbsp;                        ? serializedLambdaName()
<i>2283</i>&nbsp;                        : lambdaName();
<b class="nc"><i>2284</i>&nbsp;</b>
<b class="nc"><i>2285</i>&nbsp;                //prepend synthetic args to translated lambda method signature</b>
<b class="nc"><i>2286</i>&nbsp;                translatedSym.type = types.createMethodTypeWithParameters(</b>
<i>2287</i>&nbsp;                        generatedLambdaSig(),
<i>2288</i>&nbsp;                        TreeInfo.types(syntheticParams));
<i>2289</i>&nbsp;            }
<b class="nc"><i>2290</i>&nbsp;</b>
<b class="nc"><i>2291</i>&nbsp;            Type generatedLambdaSig() {</b>
<b class="nc"><i>2292</i>&nbsp;                return types.erasure(tree.getDescriptorType(types));</b>
<i>2293</i>&nbsp;            }
<i>2294</i>&nbsp;        }
<i>2295</i>&nbsp;
<i>2296</i>&nbsp;        /**
<i>2297</i>&nbsp;         * This class retains all the useful information about a method reference;
<i>2298</i>&nbsp;         * the contents of this class are filled by the LambdaAnalyzer visitor,
<i>2299</i>&nbsp;         * and the used by the main translation routines in order to adjust method
<i>2300</i>&nbsp;         * references (i.e. in case a bridge is needed)
<i>2301</i>&nbsp;         */
<i>2302</i>&nbsp;        final class ReferenceTranslationContext extends TranslationContext&lt;JCMemberReference&gt; {
<b class="nc"><i>2303</i>&nbsp;</b>
<i>2304</i>&nbsp;            final boolean isSuper;
<b class="nc"><i>2305</i>&nbsp;</b>
<b class="nc"><i>2306</i>&nbsp;            ReferenceTranslationContext(JCMemberReference tree) {</b>
<i>2307</i>&nbsp;                super(tree);
<i>2308</i>&nbsp;                this.isSuper = tree.hasKind(ReferenceKind.SUPER);
<i>2309</i>&nbsp;            }
<i>2310</i>&nbsp;
<b class="nc"><i>2311</i>&nbsp;            /**</b>
<i>2312</i>&nbsp;             * Get the opcode associated with this method reference
<i>2313</i>&nbsp;             */
<i>2314</i>&nbsp;            int referenceKind() {
<i>2315</i>&nbsp;                return LambdaToMethod.this.referenceKind(tree.sym);
<b class="nc"><i>2316</i>&nbsp;            }</b>
<i>2317</i>&nbsp;
<i>2318</i>&nbsp;            boolean needsVarArgsConversion() {
<i>2319</i>&nbsp;                return tree.varargsElement != null;
<i>2320</i>&nbsp;            }
<b class="nc"><i>2321</i>&nbsp;</b>
<i>2322</i>&nbsp;            /**
<i>2323</i>&nbsp;             * @return Is this an array operation like clone()
<i>2324</i>&nbsp;             */
<i>2325</i>&nbsp;            boolean isArrayOp() {
<b class="nc"><i>2326</i>&nbsp;                return tree.sym.owner == syms.arrayClass;</b>
<i>2327</i>&nbsp;            }
<i>2328</i>&nbsp;
<i>2329</i>&nbsp;            boolean receiverAccessible() {
<i>2330</i>&nbsp;                //hack needed to workaround 292 bug (7087658)
<i>2331</i>&nbsp;                //when 292 issue is fixed we should remove this and change the backend
<i>2332</i>&nbsp;                //code to always generate a method handle to an accessible method
<i>2333</i>&nbsp;                return tree.ownerAccessible;
<i>2334</i>&nbsp;            }
<i>2335</i>&nbsp;
<i>2336</i>&nbsp;            /**
<i>2337</i>&nbsp;             * The VM does not support access across nested classes (8010319).
<i>2338</i>&nbsp;             * Were that ever to change, this should be removed.
<i>2339</i>&nbsp;             */
<i>2340</i>&nbsp;            boolean isPrivateInOtherClass() {
<i>2341</i>&nbsp;                return  (tree.sym.flags() &amp; PRIVATE) != 0 &amp;&amp;
<i>2342</i>&nbsp;                        !types.isSameType(
<i>2343</i>&nbsp;                              types.erasure(tree.sym.enclClass().asType()),
<i>2344</i>&nbsp;                              types.erasure(owner.enclClass().asType()));
<i>2345</i>&nbsp;            }
<i>2346</i>&nbsp;
<i>2347</i>&nbsp;            boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
<i>2348</i>&nbsp;                return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
<i>2349</i>&nbsp;                        tree.sym.packge() != owner.packge() &amp;&amp;
<i>2350</i>&nbsp;                        !owner.enclClass().isSubClass(tree.sym.owner, types));
<i>2351</i>&nbsp;            }
<i>2352</i>&nbsp;
<i>2353</i>&nbsp;            /**
<i>2354</i>&nbsp;             * Erasure destroys the implementation parameter subtype
<i>2355</i>&nbsp;             * relationship for intersection types.
<i>2356</i>&nbsp;             * Have similar problems for union types too.
<i>2357</i>&nbsp;             */
<i>2358</i>&nbsp;            boolean interfaceParameterIsIntersectionOrUnionType() {
<i>2359</i>&nbsp;                List&lt;Type&gt; tl = tree.getDescriptorType(types).getParameterTypes();
<i>2360</i>&nbsp;                for (; tl.nonEmpty(); tl = tl.tail) {
<i>2361</i>&nbsp;                    Type pt = tl.head;
<i>2362</i>&nbsp;                    switch (pt.getKind()) {
<i>2363</i>&nbsp;                        case INTERSECTION:
<i>2364</i>&nbsp;                        case UNION:
<i>2365</i>&nbsp;                            return true;
<i>2366</i>&nbsp;                        case TYPEVAR:
<i>2367</i>&nbsp;                            TypeVar tv = (TypeVar) pt;
<i>2368</i>&nbsp;                            if (tv.bound.getKind() == TypeKind.INTERSECTION) {
<i>2369</i>&nbsp;                                return true;
<i>2370</i>&nbsp;                            }
<i>2371</i>&nbsp;                    }
<i>2372</i>&nbsp;                }
<i>2373</i>&nbsp;                return false;
<i>2374</i>&nbsp;            }
<i>2375</i>&nbsp;
<i>2376</i>&nbsp;            /**
<i>2377</i>&nbsp;             * Does this reference need to be converted to a lambda
<i>2378</i>&nbsp;             * (i.e. var args need to be expanded or &quot;super&quot; is used)
<i>2379</i>&nbsp;             */
<i>2380</i>&nbsp;            final boolean needsConversionToLambda() {
<i>2381</i>&nbsp;                return interfaceParameterIsIntersectionOrUnionType() ||
<i>2382</i>&nbsp;                        isSuper ||
<i>2383</i>&nbsp;                        needsVarArgsConversion() ||
<i>2384</i>&nbsp;                        isArrayOp() ||
<i>2385</i>&nbsp;                        isPrivateInOtherClass() ||
<i>2386</i>&nbsp;                        isProtectedInSuperClassOfEnclosingClassInOtherPackage() ||
<i>2387</i>&nbsp;                        !receiverAccessible() ||
<i>2388</i>&nbsp;                        (tree.getMode() == ReferenceMode.NEW &amp;&amp;
<i>2389</i>&nbsp;                          tree.kind != ReferenceKind.ARRAY_CTOR &amp;&amp;
<i>2390</i>&nbsp;                          (tree.sym.owner.isLocal() || tree.sym.owner.isInner()));
<i>2391</i>&nbsp;            }
<i>2392</i>&nbsp;
<i>2393</i>&nbsp;            Type generatedRefSig() {
<i>2394</i>&nbsp;                return types.erasure(tree.sym.type);
<i>2395</i>&nbsp;            }
<i>2396</i>&nbsp;
<i>2397</i>&nbsp;            Type bridgedRefSig() {
<i>2398</i>&nbsp;                return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);
<i>2399</i>&nbsp;            }
<i>2400</i>&nbsp;        }
<i>2401</i>&nbsp;    }
<i>2402</i>&nbsp;    // &lt;/editor-fold&gt;
<i>2403</i>&nbsp;
<i>2404</i>&nbsp;    /*
<i>2405</i>&nbsp;     * These keys provide mappings for various translated lambda symbols
<i>2406</i>&nbsp;     * and the prevailing order must be maintained.
<i>2407</i>&nbsp;     */
<i>2408</i>&nbsp;    enum LambdaSymbolKind {
<i>2409</i>&nbsp;        PARAM,          // original to translated lambda parameters
<i>2410</i>&nbsp;        LOCAL_VAR,      // original to translated lambda locals
<i>2411</i>&nbsp;        CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
<i>2412</i>&nbsp;        CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
<i>2413</i>&nbsp;        CAPTURED_OUTER_THIS, // used when `this&#39; capture is illegal, but outer this capture is legit (JDK-8129740)
<i>2414</i>&nbsp;        TYPE_VAR;      // original to translated lambda type variables
<i>2415</i>&nbsp;
<i>2416</i>&nbsp;        boolean propagateAnnotations() {
<i>2417</i>&nbsp;            switch (this) {
<i>2418</i>&nbsp;                case CAPTURED_VAR:
<i>2419</i>&nbsp;                case CAPTURED_THIS:
<i>2420</i>&nbsp;                case CAPTURED_OUTER_THIS:
<i>2421</i>&nbsp;                    return false;
<i>2422</i>&nbsp;                default:
<i>2423</i>&nbsp;                    return true;
<i>2424</i>&nbsp;           }
<i>2425</i>&nbsp;        }
<i>2426</i>&nbsp;    }
<i>2427</i>&nbsp;
<i>2428</i>&nbsp;    /**
<i>2429</i>&nbsp;     * ****************************************************************
<i>2430</i>&nbsp;     * Signature Generation
<i>2431</i>&nbsp;     * ****************************************************************
<i>2432</i>&nbsp;     */
<i>2433</i>&nbsp;
<i>2434</i>&nbsp;    private String typeSig(Type type) {
<i>2435</i>&nbsp;        L2MSignatureGenerator sg = new L2MSignatureGenerator();
<i>2436</i>&nbsp;        sg.assembleSig(type);
<i>2437</i>&nbsp;        return sg.toString();
<i>2438</i>&nbsp;    }
<i>2439</i>&nbsp;
<i>2440</i>&nbsp;    private String classSig(Type type) {
<i>2441</i>&nbsp;        L2MSignatureGenerator sg = new L2MSignatureGenerator();
<i>2442</i>&nbsp;        sg.assembleClassSig(type);
<i>2443</i>&nbsp;        return sg.toString();
<i>2444</i>&nbsp;    }
<i>2445</i>&nbsp;
<i>2446</i>&nbsp;    /**
<i>2447</i>&nbsp;     * Signature Generation
<i>2448</i>&nbsp;     */
<i>2449</i>&nbsp;    private class L2MSignatureGenerator extends Types.SignatureGenerator {
<i>2450</i>&nbsp;
<i>2451</i>&nbsp;        /**
<i>2452</i>&nbsp;         * An output buffer for type signatures.
<i>2453</i>&nbsp;         */
<i>2454</i>&nbsp;        StringBuilder sb = new StringBuilder();
<i>2455</i>&nbsp;
<i>2456</i>&nbsp;        L2MSignatureGenerator() {
<i>2457</i>&nbsp;            super(types);
<i>2458</i>&nbsp;        }
<i>2459</i>&nbsp;
<i>2460</i>&nbsp;        @Override
<i>2461</i>&nbsp;        protected void append(char ch) {
<i>2462</i>&nbsp;            sb.append(ch);
<i>2463</i>&nbsp;        }
<i>2464</i>&nbsp;
<i>2465</i>&nbsp;        @Override
<i>2466</i>&nbsp;        protected void append(byte[] ba) {
<i>2467</i>&nbsp;            sb.append(new String(ba));
<i>2468</i>&nbsp;        }
<i>2469</i>&nbsp;
<i>2470</i>&nbsp;        @Override
<i>2471</i>&nbsp;        protected void append(Name name) {
<i>2472</i>&nbsp;            sb.append(name.toString());
<i>2473</i>&nbsp;        }
<i>2474</i>&nbsp;
<i>2475</i>&nbsp;        @Override
<i>2476</i>&nbsp;        public String toString() {
<i>2477</i>&nbsp;            return sb.toString();
<i>2478</i>&nbsp;        }
<i>2479</i>&nbsp;    }
<i>2480</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
