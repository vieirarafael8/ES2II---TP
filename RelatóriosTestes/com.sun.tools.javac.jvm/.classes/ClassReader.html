


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ClassReader</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.tools.javac.jvm</a> ]
</div>

<h1>Coverage Summary for Class: ClassReader (com.sun.tools.javac.jvm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 959)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ClassReader$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$20</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$21</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$22</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$23</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$24</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$25</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$AnnotationCompleter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$AnnotationDefaultCompleter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$AnnotationDeproxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 73)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$ArrayAttributeProxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$AttributeKind</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$AttributeReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$BadClassFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$CompoundAnnotationProxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$EnumAttributeProxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$SourceFileObject</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$TypeAnnotationCompleter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassReader$TypeAnnotationProxy</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 194)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1278)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.tools.javac.jvm;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.*;
<i>29</i>&nbsp;import java.net.URI;
<i>30</i>&nbsp;import java.net.URISyntaxException;
<i>31</i>&nbsp;import java.nio.CharBuffer;
<i>32</i>&nbsp;import java.nio.file.ClosedFileSystemException;
<i>33</i>&nbsp;import java.util.Arrays;
<i>34</i>&nbsp;import java.util.EnumSet;
<i>35</i>&nbsp;import java.util.HashMap;
<i>36</i>&nbsp;import java.util.HashSet;
<i>37</i>&nbsp;import java.util.Map;
<i>38</i>&nbsp;import java.util.Set;
<i>39</i>&nbsp;
<i>40</i>&nbsp;import javax.lang.model.element.Modifier;
<i>41</i>&nbsp;import javax.lang.model.element.NestingKind;
<i>42</i>&nbsp;import javax.tools.JavaFileManager;
<i>43</i>&nbsp;import javax.tools.JavaFileObject;
<i>44</i>&nbsp;
<i>45</i>&nbsp;import com.sun.tools.javac.code.Source.Feature;
<i>46</i>&nbsp;import com.sun.tools.javac.comp.Annotate;
<i>47</i>&nbsp;import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
<i>48</i>&nbsp;import com.sun.tools.javac.code.*;
<i>49</i>&nbsp;import com.sun.tools.javac.code.Directive.*;
<i>50</i>&nbsp;import com.sun.tools.javac.code.Lint.LintCategory;
<i>51</i>&nbsp;import com.sun.tools.javac.code.Scope.WriteableScope;
<i>52</i>&nbsp;import com.sun.tools.javac.code.Symbol.*;
<i>53</i>&nbsp;import com.sun.tools.javac.code.Symtab;
<i>54</i>&nbsp;import com.sun.tools.javac.code.Type.*;
<i>55</i>&nbsp;import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
<i>56</i>&nbsp;import com.sun.tools.javac.file.BaseFileManager;
<i>57</i>&nbsp;import com.sun.tools.javac.file.PathFileObject;
<i>58</i>&nbsp;import com.sun.tools.javac.jvm.ClassFile.NameAndType;
<i>59</i>&nbsp;import com.sun.tools.javac.jvm.ClassFile.Version;
<i>60</i>&nbsp;import com.sun.tools.javac.main.Option;
<i>61</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<i>62</i>&nbsp;import com.sun.tools.javac.resources.CompilerProperties.Warnings;
<i>63</i>&nbsp;import com.sun.tools.javac.util.*;
<i>64</i>&nbsp;import com.sun.tools.javac.util.DefinedBy.Api;
<i>65</i>&nbsp;import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<i>66</i>&nbsp;
<i>67</i>&nbsp;import static com.sun.tools.javac.code.Flags.*;
<i>68</i>&nbsp;import static com.sun.tools.javac.code.Kinds.Kind.*;
<i>69</i>&nbsp;
<i>70</i>&nbsp;import com.sun.tools.javac.code.Scope.LookupKind;
<i>71</i>&nbsp;
<i>72</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.ARRAY;
<i>73</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.CLASS;
<i>74</i>&nbsp;import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
<i>75</i>&nbsp;import static com.sun.tools.javac.jvm.ClassFile.*;
<b class="nc"><i>76</i>&nbsp;import static com.sun.tools.javac.jvm.ClassFile.Version.*;</b>
<i>77</i>&nbsp;
<b class="nc"><i>78</i>&nbsp;import static com.sun.tools.javac.main.Option.PARAMETERS;</b>
<i>79</i>&nbsp;
<i>80</i>&nbsp;/** This class provides operations to read a classfile into an internal
<i>81</i>&nbsp; *  representation. The internal representation is anchored in a
<i>82</i>&nbsp; *  ClassSymbol which contains in its scope symbol representations
<i>83</i>&nbsp; *  for all other definitions in the classfile. Top-level Classes themselves
<i>84</i>&nbsp; *  appear as members of the scopes of PackageSymbols.
<i>85</i>&nbsp; *
<i>86</i>&nbsp; *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
<i>87</i>&nbsp; *  If you write code that depends on this, you do so at your own risk.
<i>88</i>&nbsp; *  This code and its internal interfaces are subject to change or
<i>89</i>&nbsp; *  deletion without notice.&lt;/b&gt;
<i>90</i>&nbsp; */
<i>91</i>&nbsp;public class ClassReader {
<i>92</i>&nbsp;    /** The context key for the class reader. */
<i>93</i>&nbsp;    protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
<i>94</i>&nbsp;
<i>95</i>&nbsp;    public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
<i>96</i>&nbsp;
<b class="nc"><i>97</i>&nbsp;    private final Annotate annotate;</b>
<i>98</i>&nbsp;
<i>99</i>&nbsp;    /** Switch: verbose output.
<i>100</i>&nbsp;     */
<i>101</i>&nbsp;    boolean verbose;
<i>102</i>&nbsp;
<i>103</i>&nbsp;    /** Switch: read constant pool and code sections. This switch is initially
<i>104</i>&nbsp;     *  set to false but can be turned on from outside.
<i>105</i>&nbsp;     */
<i>106</i>&nbsp;    public boolean readAllOfClassFile = false;
<i>107</i>&nbsp;
<i>108</i>&nbsp;    /** Switch: allow simplified varargs.
<i>109</i>&nbsp;     */
<i>110</i>&nbsp;    boolean allowSimplifiedVarargs;
<i>111</i>&nbsp;
<i>112</i>&nbsp;    /** Switch: allow modules.
<i>113</i>&nbsp;     */
<i>114</i>&nbsp;    boolean allowModules;
<i>115</i>&nbsp;
<i>116</i>&nbsp;   /** Lint option: warn about classfile issues
<i>117</i>&nbsp;     */
<i>118</i>&nbsp;    boolean lintClassfile;
<i>119</i>&nbsp;
<i>120</i>&nbsp;    /** Switch: preserve parameter names from the variable table.
<i>121</i>&nbsp;     */
<i>122</i>&nbsp;    public boolean saveParameterNames;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    /**
<i>125</i>&nbsp;     * The currently selected profile.
<i>126</i>&nbsp;     */
<i>127</i>&nbsp;    public final Profile profile;
<i>128</i>&nbsp;
<i>129</i>&nbsp;    /** The log to use for verbose output
<i>130</i>&nbsp;     */
<i>131</i>&nbsp;    final Log log;
<i>132</i>&nbsp;
<i>133</i>&nbsp;    /** The symbol table. */
<i>134</i>&nbsp;    Symtab syms;
<i>135</i>&nbsp;
<i>136</i>&nbsp;    Types types;
<i>137</i>&nbsp;
<i>138</i>&nbsp;    /** The name table. */
<i>139</i>&nbsp;    final Names names;
<i>140</i>&nbsp;
<i>141</i>&nbsp;    /** Access to files
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    private final JavaFileManager fileManager;
<i>144</i>&nbsp;
<i>145</i>&nbsp;    /** Factory for diagnostics
<i>146</i>&nbsp;     */
<i>147</i>&nbsp;    JCDiagnostic.Factory diagFactory;
<i>148</i>&nbsp;
<i>149</i>&nbsp;    DeferredCompletionFailureHandler dcfh;
<i>150</i>&nbsp;
<i>151</i>&nbsp;    /**
<i>152</i>&nbsp;     * Support for preview language features.
<i>153</i>&nbsp;     */
<i>154</i>&nbsp;    Preview preview;
<i>155</i>&nbsp;
<i>156</i>&nbsp;    /** The current scope where type variables are entered.
<i>157</i>&nbsp;     */
<i>158</i>&nbsp;    protected WriteableScope typevars;
<i>159</i>&nbsp;
<i>160</i>&nbsp;    private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
<i>161</i>&nbsp;    private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
<i>162</i>&nbsp;
<i>163</i>&nbsp;    /** The path name of the class file currently being read.
<i>164</i>&nbsp;     */
<i>165</i>&nbsp;    protected JavaFileObject currentClassFile = null;
<i>166</i>&nbsp;
<b class="nc"><i>167</i>&nbsp;    /** The class or method currently being read.</b>
<i>168</i>&nbsp;     */
<i>169</i>&nbsp;    protected Symbol currentOwner = null;
<i>170</i>&nbsp;
<i>171</i>&nbsp;    /** The module containing the class currently being read.
<i>172</i>&nbsp;     */
<i>173</i>&nbsp;    protected ModuleSymbol currentModule = null;
<i>174</i>&nbsp;
<i>175</i>&nbsp;    /** The buffer containing the currently read class file.
<i>176</i>&nbsp;     */
<i>177</i>&nbsp;    byte[] buf = new byte[INITIAL_BUFFER_SIZE];
<i>178</i>&nbsp;
<i>179</i>&nbsp;    /** The current input pointer.
<i>180</i>&nbsp;     */
<i>181</i>&nbsp;    protected int bp;
<i>182</i>&nbsp;
<i>183</i>&nbsp;    /** The objects of the constant pool.
<b class="nc"><i>184</i>&nbsp;     */</b>
<i>185</i>&nbsp;    Object[] poolObj;
<i>186</i>&nbsp;
<i>187</i>&nbsp;    /** For every constant pool entry, an index into buf where the
<b class="nc"><i>188</i>&nbsp;     *  defining section of the entry is found.</b>
<i>189</i>&nbsp;     */
<i>190</i>&nbsp;    int[] poolIdx;
<i>191</i>&nbsp;
<b class="nc"><i>192</i>&nbsp;    /** The major version number of the class file being read. */</b>
<i>193</i>&nbsp;    int majorVersion;
<i>194</i>&nbsp;    /** The minor version number of the class file being read. */
<i>195</i>&nbsp;    int minorVersion;
<i>196</i>&nbsp;
<i>197</i>&nbsp;    /** A table to hold the constant pool indices for method parameter
<i>198</i>&nbsp;     * names, as given in LocalVariableTable attributes.
<i>199</i>&nbsp;     */
<i>200</i>&nbsp;    int[] parameterNameIndices;
<i>201</i>&nbsp;
<i>202</i>&nbsp;    /**
<i>203</i>&nbsp;     * A table to hold annotations for method parameters.
<i>204</i>&nbsp;     */
<i>205</i>&nbsp;    ParameterAnnotations[] parameterAnnotations;
<i>206</i>&nbsp;
<i>207</i>&nbsp;    /**
<i>208</i>&nbsp;     * A holder for parameter annotations.
<i>209</i>&nbsp;     */
<i>210</i>&nbsp;    static class ParameterAnnotations {
<i>211</i>&nbsp;        List&lt;CompoundAnnotationProxy&gt; proxies;
<i>212</i>&nbsp;
<i>213</i>&nbsp;        void add(List&lt;CompoundAnnotationProxy&gt; newAnnotations) {
<i>214</i>&nbsp;            if (proxies == null) {
<i>215</i>&nbsp;                proxies = newAnnotations;
<i>216</i>&nbsp;            } else {
<i>217</i>&nbsp;                proxies = proxies.prependList(newAnnotations);
<i>218</i>&nbsp;            }
<i>219</i>&nbsp;        }
<i>220</i>&nbsp;    }
<i>221</i>&nbsp;
<i>222</i>&nbsp;    /**
<i>223</i>&nbsp;     * Whether or not any parameter names have been found.
<i>224</i>&nbsp;     */
<i>225</i>&nbsp;    boolean haveParameterNameIndices;
<i>226</i>&nbsp;
<i>227</i>&nbsp;    /** Set this to false every time we start reading a method
<i>228</i>&nbsp;     * and are saving parameter names.  Set it to true when we see
<i>229</i>&nbsp;     * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
<i>230</i>&nbsp;     * then we ignore the parameter names from the LVT.
<i>231</i>&nbsp;     */
<b class="nc"><i>232</i>&nbsp;    boolean sawMethodParameters;</b>
<i>233</i>&nbsp;
<i>234</i>&nbsp;    /**
<i>235</i>&nbsp;     * The set of attribute names for which warnings have been generated for the current class
<i>236</i>&nbsp;     */
<b class="nc"><i>237</i>&nbsp;    Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();</b>
<i>238</i>&nbsp;
<i>239</i>&nbsp;    /**
<b class="nc"><i>240</i>&nbsp;     * The prototype @Target Attribute.Compound if this class is an annotation annotated with</b>
<i>241</i>&nbsp;     * @Target
<i>242</i>&nbsp;     */
<i>243</i>&nbsp;    CompoundAnnotationProxy target;
<i>244</i>&nbsp;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * The prototype @Repetable Attribute.Compound if this class is an annotation annotated with
<b class="nc"><i>247</i>&nbsp;     * @Repeatable</b>
<b class="nc"><i>248</i>&nbsp;     */</b>
<b class="nc"><i>249</i>&nbsp;    CompoundAnnotationProxy repeatable;</b>
<b class="nc"><i>250</i>&nbsp;</b>
<i>251</i>&nbsp;    /** Get the ClassReader instance for this invocation. */
<i>252</i>&nbsp;    public static ClassReader instance(Context context) {
<i>253</i>&nbsp;        ClassReader instance = context.get(classReaderKey);
<i>254</i>&nbsp;        if (instance == null)
<b class="nc"><i>255</i>&nbsp;            instance = new ClassReader(context);</b>
<i>256</i>&nbsp;        return instance;
<i>257</i>&nbsp;    }
<i>258</i>&nbsp;
<i>259</i>&nbsp;    /** Construct a new class reader. */
<i>260</i>&nbsp;    protected ClassReader(Context context) {
<i>261</i>&nbsp;        context.put(classReaderKey, this);
<b class="nc"><i>262</i>&nbsp;        annotate = Annotate.instance(context);</b>
<i>263</i>&nbsp;        names = Names.instance(context);
<b class="nc"><i>264</i>&nbsp;        syms = Symtab.instance(context);</b>
<b class="nc"><i>265</i>&nbsp;        types = Types.instance(context);</b>
<b class="nc"><i>266</i>&nbsp;        fileManager = context.get(JavaFileManager.class);</b>
<b class="nc"><i>267</i>&nbsp;        if (fileManager == null)</b>
<b class="nc"><i>268</i>&nbsp;            throw new AssertionError(&quot;FileManager initialization error&quot;);</b>
<i>269</i>&nbsp;        diagFactory = JCDiagnostic.Factory.instance(context);
<b class="nc"><i>270</i>&nbsp;        dcfh = DeferredCompletionFailureHandler.instance(context);</b>
<b class="nc"><i>271</i>&nbsp;</b>
<i>272</i>&nbsp;        log = Log.instance(context);
<i>273</i>&nbsp;
<b class="nc"><i>274</i>&nbsp;        Options options = Options.instance(context);</b>
<b class="nc"><i>275</i>&nbsp;        verbose         = options.isSet(Option.VERBOSE);</b>
<b class="nc"><i>276</i>&nbsp;</b>
<i>277</i>&nbsp;        Source source = Source.instance(context);
<i>278</i>&nbsp;        preview = Preview.instance(context);
<i>279</i>&nbsp;        allowSimplifiedVarargs = Feature.SIMPLIFIED_VARARGS.allowedInSource(source);
<i>280</i>&nbsp;        allowModules     = Feature.MODULES.allowedInSource(source);
<i>281</i>&nbsp;
<b class="nc"><i>282</i>&nbsp;        saveParameterNames = options.isSet(PARAMETERS);</b>
<b class="nc"><i>283</i>&nbsp;</b>
<i>284</i>&nbsp;        profile = Profile.instance(context);
<b class="nc"><i>285</i>&nbsp;</b>
<b class="nc"><i>286</i>&nbsp;        typevars = WriteableScope.create(syms.noSymbol);</b>
<b class="nc"><i>287</i>&nbsp;</b>
<b class="nc"><i>288</i>&nbsp;        lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);</b>
<b class="nc"><i>289</i>&nbsp;</b>
<b class="nc"><i>290</i>&nbsp;        initAttributeReaders();</b>
<b class="nc"><i>291</i>&nbsp;    }</b>
<i>292</i>&nbsp;
<b class="nc"><i>293</i>&nbsp;    /** Add member to class unless it is synthetic.</b>
<b class="nc"><i>294</i>&nbsp;     */</b>
<i>295</i>&nbsp;    private void enterMember(ClassSymbol c, Symbol sym) {
<b class="nc"><i>296</i>&nbsp;        // Synthetic members are not entered -- reason lost to history (optimization?).</b>
<b class="nc"><i>297</i>&nbsp;        // Lambda methods must be entered because they may have inner classes (which reference them)</b>
<b class="nc"><i>298</i>&nbsp;        if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))</b>
<b class="nc"><i>299</i>&nbsp;            c.members_field.enter(sym);</b>
<i>300</i>&nbsp;    }
<b class="nc"><i>301</i>&nbsp;</b>
<b class="nc"><i>302</i>&nbsp;/************************************************************************</b>
<b class="nc"><i>303</i>&nbsp; * Error Diagnoses</b>
<b class="nc"><i>304</i>&nbsp; ***********************************************************************/</b>
<b class="nc"><i>305</i>&nbsp;</b>
<i>306</i>&nbsp;    public ClassFinder.BadClassFile badClassFile(String key, Object... args) {
<b class="nc"><i>307</i>&nbsp;        return new ClassFinder.BadClassFile (</b>
<b class="nc"><i>308</i>&nbsp;            currentOwner.enclClass(),</b>
<b class="nc"><i>309</i>&nbsp;            currentClassFile,</b>
<i>310</i>&nbsp;            diagFactory.fragment(key, args),
<b class="nc"><i>311</i>&nbsp;            diagFactory,</b>
<i>312</i>&nbsp;            dcfh);
<b class="nc"><i>313</i>&nbsp;    }</b>
<b class="nc"><i>314</i>&nbsp;</b>
<b class="nc"><i>315</i>&nbsp;    public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {</b>
<i>316</i>&nbsp;        return new ClassFinder.BadEnclosingMethodAttr (
<i>317</i>&nbsp;            currentOwner.enclClass(),
<b class="nc"><i>318</i>&nbsp;            currentClassFile,</b>
<i>319</i>&nbsp;            diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
<b class="nc"><i>320</i>&nbsp;            diagFactory,</b>
<i>321</i>&nbsp;            dcfh);
<b class="nc"><i>322</i>&nbsp;    }</b>
<i>323</i>&nbsp;
<i>324</i>&nbsp;/************************************************************************
<i>325</i>&nbsp; * Buffer Access
<i>326</i>&nbsp; ***********************************************************************/
<i>327</i>&nbsp;
<i>328</i>&nbsp;    /** Read a character.
<i>329</i>&nbsp;     */
<b class="nc"><i>330</i>&nbsp;    char nextChar() {</b>
<b class="nc"><i>331</i>&nbsp;        return (char)(((buf[bp++] &amp; 0xFF) &lt;&lt; 8) + (buf[bp++] &amp; 0xFF));</b>
<i>332</i>&nbsp;    }
<i>333</i>&nbsp;
<i>334</i>&nbsp;    /** Read a byte.
<i>335</i>&nbsp;     */
<i>336</i>&nbsp;    int nextByte() {
<i>337</i>&nbsp;        return buf[bp++] &amp; 0xFF;
<i>338</i>&nbsp;    }
<i>339</i>&nbsp;
<i>340</i>&nbsp;    /** Read an integer.
<i>341</i>&nbsp;     */
<b class="nc"><i>342</i>&nbsp;    int nextInt() {</b>
<b class="nc"><i>343</i>&nbsp;        return</b>
<i>344</i>&nbsp;            ((buf[bp++] &amp; 0xFF) &lt;&lt; 24) +
<i>345</i>&nbsp;            ((buf[bp++] &amp; 0xFF) &lt;&lt; 16) +
<i>346</i>&nbsp;            ((buf[bp++] &amp; 0xFF) &lt;&lt; 8) +
<i>347</i>&nbsp;            (buf[bp++] &amp; 0xFF);
<b class="nc"><i>348</i>&nbsp;    }</b>
<i>349</i>&nbsp;
<b class="nc"><i>350</i>&nbsp;    /** Extract a character at position bp from buf.</b>
<i>351</i>&nbsp;     */
<i>352</i>&nbsp;    char getChar(int bp) {
<i>353</i>&nbsp;        return
<b class="nc"><i>354</i>&nbsp;            (char)(((buf[bp] &amp; 0xFF) &lt;&lt; 8) + (buf[bp+1] &amp; 0xFF));</b>
<b class="nc"><i>355</i>&nbsp;    }</b>
<i>356</i>&nbsp;
<b class="nc"><i>357</i>&nbsp;    /** Extract an integer at position bp from buf.</b>
<i>358</i>&nbsp;     */
<i>359</i>&nbsp;    int getInt(int bp) {
<i>360</i>&nbsp;        return
<i>361</i>&nbsp;            ((buf[bp] &amp; 0xFF) &lt;&lt; 24) +
<i>362</i>&nbsp;            ((buf[bp+1] &amp; 0xFF) &lt;&lt; 16) +
<i>363</i>&nbsp;            ((buf[bp+2] &amp; 0xFF) &lt;&lt; 8) +
<i>364</i>&nbsp;            (buf[bp+3] &amp; 0xFF);
<i>365</i>&nbsp;    }
<i>366</i>&nbsp;
<b class="nc"><i>367</i>&nbsp;</b>
<i>368</i>&nbsp;    /** Extract a long integer at position bp from buf.
<i>369</i>&nbsp;     */
<i>370</i>&nbsp;    long getLong(int bp) {
<i>371</i>&nbsp;        DataInputStream bufin =
<i>372</i>&nbsp;            new DataInputStream(new ByteArrayInputStream(buf, bp, 8));
<b class="nc"><i>373</i>&nbsp;        try {</b>
<i>374</i>&nbsp;            return bufin.readLong();
<i>375</i>&nbsp;        } catch (IOException e) {
<i>376</i>&nbsp;            throw new AssertionError(e);
<i>377</i>&nbsp;        }
<i>378</i>&nbsp;    }
<b class="nc"><i>379</i>&nbsp;</b>
<i>380</i>&nbsp;    /** Extract a float at position bp from buf.
<i>381</i>&nbsp;     */
<i>382</i>&nbsp;    float getFloat(int bp) {
<i>383</i>&nbsp;        DataInputStream bufin =
<i>384</i>&nbsp;            new DataInputStream(new ByteArrayInputStream(buf, bp, 4));
<i>385</i>&nbsp;        try {
<i>386</i>&nbsp;            return bufin.readFloat();
<i>387</i>&nbsp;        } catch (IOException e) {
<i>388</i>&nbsp;            throw new AssertionError(e);
<b class="nc"><i>389</i>&nbsp;        }</b>
<i>390</i>&nbsp;    }
<i>391</i>&nbsp;
<i>392</i>&nbsp;    /** Extract a double at position bp from buf.
<i>393</i>&nbsp;     */
<i>394</i>&nbsp;    double getDouble(int bp) {
<i>395</i>&nbsp;        DataInputStream bufin =
<b class="nc"><i>396</i>&nbsp;            new DataInputStream(new ByteArrayInputStream(buf, bp, 8));</b>
<i>397</i>&nbsp;        try {
<i>398</i>&nbsp;            return bufin.readDouble();
<i>399</i>&nbsp;        } catch (IOException e) {
<i>400</i>&nbsp;            throw new AssertionError(e);
<i>401</i>&nbsp;        }
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;
<i>404</i>&nbsp;/************************************************************************
<i>405</i>&nbsp; * Constant Pool Access
<i>406</i>&nbsp; ***********************************************************************/
<b class="nc"><i>407</i>&nbsp;</b>
<i>408</i>&nbsp;    /** Index all constant pool entries, writing their start addresses into
<i>409</i>&nbsp;     *  poolIdx.
<b class="nc"><i>410</i>&nbsp;     */</b>
<b class="nc"><i>411</i>&nbsp;    void indexPool() {</b>
<b class="nc"><i>412</i>&nbsp;        poolIdx = new int[nextChar()];</b>
<i>413</i>&nbsp;        poolObj = new Object[poolIdx.length];
<i>414</i>&nbsp;        int i = 1;
<i>415</i>&nbsp;        while (i &lt; poolIdx.length) {
<i>416</i>&nbsp;            poolIdx[i++] = bp;
<i>417</i>&nbsp;            byte tag = buf[bp++];
<i>418</i>&nbsp;            switch (tag) {
<b class="nc"><i>419</i>&nbsp;            case CONSTANT_Utf8: case CONSTANT_Unicode: {</b>
<i>420</i>&nbsp;                int len = nextChar();
<i>421</i>&nbsp;                bp = bp + len;
<b class="nc"><i>422</i>&nbsp;                break;</b>
<b class="nc"><i>423</i>&nbsp;            }</b>
<b class="nc"><i>424</i>&nbsp;            case CONSTANT_Class:</b>
<i>425</i>&nbsp;            case CONSTANT_String:
<i>426</i>&nbsp;            case CONSTANT_MethodType:
<i>427</i>&nbsp;            case CONSTANT_Module:
<i>428</i>&nbsp;            case CONSTANT_Package:
<i>429</i>&nbsp;                bp = bp + 2;
<i>430</i>&nbsp;                break;
<b class="nc"><i>431</i>&nbsp;            case CONSTANT_MethodHandle:</b>
<i>432</i>&nbsp;                bp = bp + 3;
<i>433</i>&nbsp;                break;
<b class="nc"><i>434</i>&nbsp;            case CONSTANT_Fieldref:</b>
<b class="nc"><i>435</i>&nbsp;            case CONSTANT_Methodref:</b>
<b class="nc"><i>436</i>&nbsp;            case CONSTANT_InterfaceMethodref:</b>
<i>437</i>&nbsp;            case CONSTANT_NameandType:
<i>438</i>&nbsp;            case CONSTANT_Integer:
<i>439</i>&nbsp;            case CONSTANT_Float:
<i>440</i>&nbsp;            case CONSTANT_Dynamic:
<i>441</i>&nbsp;            case CONSTANT_InvokeDynamic:
<i>442</i>&nbsp;                bp = bp + 4;
<i>443</i>&nbsp;                break;
<i>444</i>&nbsp;            case CONSTANT_Long:
<i>445</i>&nbsp;            case CONSTANT_Double:
<i>446</i>&nbsp;                bp = bp + 8;
<i>447</i>&nbsp;                i++;
<b class="nc"><i>448</i>&nbsp;                break;</b>
<b class="nc"><i>449</i>&nbsp;            default:</b>
<b class="nc"><i>450</i>&nbsp;                throw badClassFile(&quot;bad.const.pool.tag.at&quot;,</b>
<b class="nc"><i>451</i>&nbsp;                                   Byte.toString(tag),</b>
<b class="nc"><i>452</i>&nbsp;                                   Integer.toString(bp -1));</b>
<b class="nc"><i>453</i>&nbsp;            }</b>
<b class="nc"><i>454</i>&nbsp;        }</b>
<i>455</i>&nbsp;    }
<b class="nc"><i>456</i>&nbsp;</b>
<b class="nc"><i>457</i>&nbsp;    /** Read constant pool entry at start address i, use pool as a cache.</b>
<b class="nc"><i>458</i>&nbsp;     */</b>
<i>459</i>&nbsp;    Object readPool(int i) {
<i>460</i>&nbsp;        Object result = poolObj[i];
<i>461</i>&nbsp;        if (result != null) return result;
<i>462</i>&nbsp;
<b class="nc"><i>463</i>&nbsp;        int index = poolIdx[i];</b>
<b class="nc"><i>464</i>&nbsp;        if (index == 0) return null;</b>
<i>465</i>&nbsp;
<b class="nc"><i>466</i>&nbsp;        byte tag = buf[index];</b>
<b class="nc"><i>467</i>&nbsp;        switch (tag) {</b>
<i>468</i>&nbsp;        case CONSTANT_Utf8:
<i>469</i>&nbsp;            poolObj[i] = names.fromUtf(buf, index + 3, getChar(index + 1));
<i>470</i>&nbsp;            break;
<i>471</i>&nbsp;        case CONSTANT_Unicode:
<i>472</i>&nbsp;            throw badClassFile(&quot;unicode.str.not.supported&quot;);
<i>473</i>&nbsp;        case CONSTANT_Class:
<i>474</i>&nbsp;            poolObj[i] = readClassOrType(getChar(index + 1));
<b class="nc"><i>475</i>&nbsp;            break;</b>
<b class="nc"><i>476</i>&nbsp;        case CONSTANT_String:</b>
<i>477</i>&nbsp;            // FIXME: (footprint) do not use toString here
<i>478</i>&nbsp;            poolObj[i] = readName(getChar(index + 1)).toString();
<b class="nc"><i>479</i>&nbsp;            break;</b>
<b class="nc"><i>480</i>&nbsp;        case CONSTANT_Fieldref: {</b>
<b class="nc"><i>481</i>&nbsp;            ClassSymbol owner = readClassSymbol(getChar(index + 1));</b>
<i>482</i>&nbsp;            NameAndType nt = readNameAndType(getChar(index + 3));
<b class="nc"><i>483</i>&nbsp;            poolObj[i] = new VarSymbol(0, nt.name, nt.uniqueType.type, owner);</b>
<b class="nc"><i>484</i>&nbsp;            break;</b>
<b class="nc"><i>485</i>&nbsp;        }</b>
<i>486</i>&nbsp;        case CONSTANT_Methodref:
<b class="nc"><i>487</i>&nbsp;        case CONSTANT_InterfaceMethodref: {</b>
<i>488</i>&nbsp;            ClassSymbol owner = readClassSymbol(getChar(index + 1));
<i>489</i>&nbsp;            NameAndType nt = readNameAndType(getChar(index + 3));
<i>490</i>&nbsp;            poolObj[i] = new MethodSymbol(0, nt.name, nt.uniqueType.type, owner);
<i>491</i>&nbsp;            break;
<i>492</i>&nbsp;        }
<b class="nc"><i>493</i>&nbsp;        case CONSTANT_NameandType:</b>
<b class="nc"><i>494</i>&nbsp;            poolObj[i] = new NameAndType(</b>
<i>495</i>&nbsp;                readName(getChar(index + 1)),
<b class="nc"><i>496</i>&nbsp;                readType(getChar(index + 3)), types);</b>
<b class="nc"><i>497</i>&nbsp;            break;</b>
<i>498</i>&nbsp;        case CONSTANT_Integer:
<b class="nc"><i>499</i>&nbsp;            poolObj[i] = getInt(index + 1);</b>
<b class="nc"><i>500</i>&nbsp;            break;</b>
<i>501</i>&nbsp;        case CONSTANT_Float:
<b class="nc"><i>502</i>&nbsp;            poolObj[i] = Float.valueOf(getFloat(index + 1));</b>
<b class="nc"><i>503</i>&nbsp;            break;</b>
<i>504</i>&nbsp;        case CONSTANT_Long:
<b class="nc"><i>505</i>&nbsp;            poolObj[i] = Long.valueOf(getLong(index + 1));</b>
<i>506</i>&nbsp;            break;
<b class="nc"><i>507</i>&nbsp;        case CONSTANT_Double:</b>
<b class="nc"><i>508</i>&nbsp;            poolObj[i] = Double.valueOf(getDouble(index + 1));</b>
<i>509</i>&nbsp;            break;
<i>510</i>&nbsp;        case CONSTANT_MethodHandle:
<b class="nc"><i>511</i>&nbsp;            skipBytes(4);</b>
<b class="nc"><i>512</i>&nbsp;            break;</b>
<i>513</i>&nbsp;        case CONSTANT_MethodType:
<b class="nc"><i>514</i>&nbsp;            skipBytes(3);</b>
<b class="nc"><i>515</i>&nbsp;            break;</b>
<b class="nc"><i>516</i>&nbsp;        case CONSTANT_Dynamic:</b>
<b class="nc"><i>517</i>&nbsp;        case CONSTANT_InvokeDynamic:</b>
<i>518</i>&nbsp;            skipBytes(5);
<i>519</i>&nbsp;            break;
<i>520</i>&nbsp;        case CONSTANT_Module:
<b class="nc"><i>521</i>&nbsp;        case CONSTANT_Package:</b>
<b class="nc"><i>522</i>&nbsp;            // this is temporary for now: treat as a simple reference to the underlying Utf8.</b>
<b class="nc"><i>523</i>&nbsp;            poolObj[i] = readName(getChar(index + 1));</b>
<b class="nc"><i>524</i>&nbsp;            break;</b>
<i>525</i>&nbsp;        default:
<i>526</i>&nbsp;            throw badClassFile(&quot;bad.const.pool.tag&quot;, Byte.toString(tag));
<b class="nc"><i>527</i>&nbsp;        }</b>
<b class="nc"><i>528</i>&nbsp;        return poolObj[i];</b>
<b class="nc"><i>529</i>&nbsp;    }</b>
<b class="nc"><i>530</i>&nbsp;</b>
<i>531</i>&nbsp;    /** Read signature and convert to type.
<b class="nc"><i>532</i>&nbsp;     */</b>
<b class="nc"><i>533</i>&nbsp;    Type readType(int i) {</b>
<i>534</i>&nbsp;        int index = poolIdx[i];
<b class="nc"><i>535</i>&nbsp;        return sigToType(buf, index + 3, getChar(index + 1));</b>
<b class="nc"><i>536</i>&nbsp;    }</b>
<i>537</i>&nbsp;
<b class="nc"><i>538</i>&nbsp;    /** If name is an array type or class signature, return the</b>
<b class="nc"><i>539</i>&nbsp;     *  corresponding type; otherwise return a ClassSymbol with given name.</b>
<i>540</i>&nbsp;     */
<b class="nc"><i>541</i>&nbsp;    Object readClassOrType(int i) {</b>
<b class="nc"><i>542</i>&nbsp;        int index =  poolIdx[i];</b>
<i>543</i>&nbsp;        int len = getChar(index + 1);
<b class="nc"><i>544</i>&nbsp;        int start = index + 3;</b>
<b class="nc"><i>545</i>&nbsp;        Assert.check(buf[start] == &#39;[&#39; || buf[start + len - 1] != &#39;;&#39;);</b>
<i>546</i>&nbsp;        // by the above assertion, the following test can be
<b class="nc"><i>547</i>&nbsp;        // simplified to (buf[start] == &#39;[&#39;)</b>
<b class="nc"><i>548</i>&nbsp;        return (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</b>
<i>549</i>&nbsp;            ? (Object)sigToType(buf, start, len)
<b class="nc"><i>550</i>&nbsp;            : (Object)enterClass(names.fromUtf(internalize(buf, start,</b>
<b class="nc"><i>551</i>&nbsp;                                                           len)));</b>
<i>552</i>&nbsp;    }
<b class="nc"><i>553</i>&nbsp;</b>
<i>554</i>&nbsp;    /** Read signature and convert to type parameters.
<b class="nc"><i>555</i>&nbsp;     */</b>
<i>556</i>&nbsp;    List&lt;Type&gt; readTypeParams(int i) {
<i>557</i>&nbsp;        int index = poolIdx[i];
<i>558</i>&nbsp;        return sigToTypeParams(buf, index + 3, getChar(index + 1));
<i>559</i>&nbsp;    }
<i>560</i>&nbsp;
<b class="nc"><i>561</i>&nbsp;    /** Read class entry.</b>
<b class="nc"><i>562</i>&nbsp;     */</b>
<i>563</i>&nbsp;    ClassSymbol readClassSymbol(int i) {
<i>564</i>&nbsp;        Object obj = readPool(i);
<i>565</i>&nbsp;        if (obj != null &amp;&amp; !(obj instanceof ClassSymbol))
<i>566</i>&nbsp;            throw badClassFile(&quot;bad.const.pool.entry&quot;,
<i>567</i>&nbsp;                               currentClassFile.toString(),
<i>568</i>&nbsp;                               &quot;CONSTANT_Class_info&quot;, i);
<b class="nc"><i>569</i>&nbsp;        return (ClassSymbol)obj;</b>
<b class="nc"><i>570</i>&nbsp;    }</b>
<b class="nc"><i>571</i>&nbsp;</b>
<b class="nc"><i>572</i>&nbsp;    Name readClassName(int i) {</b>
<i>573</i>&nbsp;        int index = poolIdx[i];
<i>574</i>&nbsp;        if (index == 0) return null;
<b class="nc"><i>575</i>&nbsp;        byte tag = buf[index];</b>
<b class="nc"><i>576</i>&nbsp;        if (tag != CONSTANT_Class) {</b>
<b class="nc"><i>577</i>&nbsp;            throw badClassFile(&quot;bad.const.pool.entry&quot;,</b>
<i>578</i>&nbsp;                               currentClassFile.toString(),
<i>579</i>&nbsp;                               &quot;CONSTANT_Class_info&quot;, i);
<i>580</i>&nbsp;        }
<i>581</i>&nbsp;        int nameIndex =  poolIdx[getChar(index + 1)];
<i>582</i>&nbsp;        int len = getChar(nameIndex + 1);
<i>583</i>&nbsp;        int start = nameIndex + 3;
<b class="nc"><i>584</i>&nbsp;        if (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</b>
<b class="nc"><i>585</i>&nbsp;            throw badClassFile(&quot;wrong class name&quot;); //TODO: proper diagnostics</b>
<i>586</i>&nbsp;        return names.fromUtf(internalize(buf, start, len));
<i>587</i>&nbsp;    }
<i>588</i>&nbsp;
<i>589</i>&nbsp;    /** Read name.
<i>590</i>&nbsp;     */
<b class="nc"><i>591</i>&nbsp;    Name readName(int i) {</b>
<b class="nc"><i>592</i>&nbsp;        Object obj = readPool(i);</b>
<b class="nc"><i>593</i>&nbsp;        if (obj != null &amp;&amp; !(obj instanceof Name))</b>
<b class="nc"><i>594</i>&nbsp;            throw badClassFile(&quot;bad.const.pool.entry&quot;,</b>
<b class="nc"><i>595</i>&nbsp;                               currentClassFile.toString(),</b>
<b class="nc"><i>596</i>&nbsp;                               &quot;CONSTANT_Utf8_info or CONSTANT_String_info&quot;, i);</b>
<i>597</i>&nbsp;        return (Name)obj;
<i>598</i>&nbsp;    }
<i>599</i>&nbsp;
<i>600</i>&nbsp;    /** Read name and type.
<i>601</i>&nbsp;     */
<b class="nc"><i>602</i>&nbsp;    NameAndType readNameAndType(int i) {</b>
<b class="nc"><i>603</i>&nbsp;        Object obj = readPool(i);</b>
<b class="nc"><i>604</i>&nbsp;        if (obj != null &amp;&amp; !(obj instanceof NameAndType))</b>
<b class="nc"><i>605</i>&nbsp;            throw badClassFile(&quot;bad.const.pool.entry&quot;,</b>
<b class="nc"><i>606</i>&nbsp;                               currentClassFile.toString(),</b>
<b class="nc"><i>607</i>&nbsp;                               &quot;CONSTANT_NameAndType_info&quot;, i);</b>
<i>608</i>&nbsp;        return (NameAndType)obj;
<i>609</i>&nbsp;    }
<i>610</i>&nbsp;
<i>611</i>&nbsp;    /** Read the name of a module.
<i>612</i>&nbsp;     * The name is stored in a CONSTANT_Module entry, in
<b class="nc"><i>613</i>&nbsp;     * JVMS 4.2 binary form (using &quot;.&quot;, not &quot;/&quot;)</b>
<b class="nc"><i>614</i>&nbsp;     */</b>
<b class="nc"><i>615</i>&nbsp;    Name readModuleName(int i) {</b>
<b class="nc"><i>616</i>&nbsp;        return readName(i);</b>
<b class="nc"><i>617</i>&nbsp;    }</b>
<b class="nc"><i>618</i>&nbsp;</b>
<i>619</i>&nbsp;    /** Read module_flags.
<i>620</i>&nbsp;     */
<i>621</i>&nbsp;    Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
<i>622</i>&nbsp;        Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
<i>623</i>&nbsp;        for (ModuleFlags f : ModuleFlags.values()) {
<i>624</i>&nbsp;            if ((flags &amp; f.value) != 0)
<i>625</i>&nbsp;                set.add(f);
<i>626</i>&nbsp;        }
<i>627</i>&nbsp;        return set;
<i>628</i>&nbsp;    }
<i>629</i>&nbsp;
<i>630</i>&nbsp;    /** Read resolution_flags.
<b class="nc"><i>631</i>&nbsp;     */</b>
<i>632</i>&nbsp;    Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
<i>633</i>&nbsp;        Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
<i>634</i>&nbsp;        for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
<i>635</i>&nbsp;            if ((flags &amp; f.value) != 0)
<b class="nc"><i>636</i>&nbsp;                set.add(f);</b>
<b class="nc"><i>637</i>&nbsp;        }</b>
<b class="nc"><i>638</i>&nbsp;        return set;</b>
<b class="nc"><i>639</i>&nbsp;    }</b>
<i>640</i>&nbsp;
<i>641</i>&nbsp;    /** Read exports_flags.
<i>642</i>&nbsp;     */
<i>643</i>&nbsp;    Set&lt;ExportsFlag&gt; readExportsFlags(int flags) {
<i>644</i>&nbsp;        Set&lt;ExportsFlag&gt; set = EnumSet.noneOf(ExportsFlag.class);
<b class="nc"><i>645</i>&nbsp;        for (ExportsFlag f: ExportsFlag.values()) {</b>
<i>646</i>&nbsp;            if ((flags &amp; f.value) != 0)
<b class="nc"><i>647</i>&nbsp;                set.add(f);</b>
<b class="nc"><i>648</i>&nbsp;        }</b>
<b class="nc"><i>649</i>&nbsp;        return set;</b>
<b class="nc"><i>650</i>&nbsp;    }</b>
<b class="nc"><i>651</i>&nbsp;</b>
<i>652</i>&nbsp;    /** Read opens_flags.
<b class="nc"><i>653</i>&nbsp;     */</b>
<i>654</i>&nbsp;    Set&lt;OpensFlag&gt; readOpensFlags(int flags) {
<b class="nc"><i>655</i>&nbsp;        Set&lt;OpensFlag&gt; set = EnumSet.noneOf(OpensFlag.class);</b>
<b class="nc"><i>656</i>&nbsp;        for (OpensFlag f: OpensFlag.values()) {</b>
<b class="nc"><i>657</i>&nbsp;            if ((flags &amp; f.value) != 0)</b>
<i>658</i>&nbsp;                set.add(f);
<i>659</i>&nbsp;        }
<i>660</i>&nbsp;        return set;
<b class="nc"><i>661</i>&nbsp;    }</b>
<b class="nc"><i>662</i>&nbsp;</b>
<i>663</i>&nbsp;    /** Read requires_flags.
<i>664</i>&nbsp;     */
<b class="nc"><i>665</i>&nbsp;    Set&lt;RequiresFlag&gt; readRequiresFlags(int flags) {</b>
<b class="nc"><i>666</i>&nbsp;        Set&lt;RequiresFlag&gt; set = EnumSet.noneOf(RequiresFlag.class);</b>
<b class="nc"><i>667</i>&nbsp;        for (RequiresFlag f: RequiresFlag.values()) {</b>
<i>668</i>&nbsp;            if ((flags &amp; f.value) != 0)
<i>669</i>&nbsp;                set.add(f);
<i>670</i>&nbsp;        }
<b class="nc"><i>671</i>&nbsp;        return set;</b>
<b class="nc"><i>672</i>&nbsp;    }</b>
<i>673</i>&nbsp;
<b class="nc"><i>674</i>&nbsp;/************************************************************************</b>
<b class="nc"><i>675</i>&nbsp; * Reading Types</b>
<i>676</i>&nbsp; ***********************************************************************/
<b class="nc"><i>677</i>&nbsp;</b>
<b class="nc"><i>678</i>&nbsp;    /** The unread portion of the currently read type is</b>
<i>679</i>&nbsp;     *  signature[sigp..siglimit-1].
<b class="nc"><i>680</i>&nbsp;     */</b>
<b class="nc"><i>681</i>&nbsp;    byte[] signature;</b>
<i>682</i>&nbsp;    int sigp;
<b class="nc"><i>683</i>&nbsp;    int siglimit;</b>
<b class="nc"><i>684</i>&nbsp;    boolean sigEnterPhase = false;</b>
<i>685</i>&nbsp;
<b class="nc"><i>686</i>&nbsp;    /** Convert signature to type, where signature is a byte array segment.</b>
<b class="nc"><i>687</i>&nbsp;     */</b>
<i>688</i>&nbsp;    Type sigToType(byte[] sig, int offset, int len) {
<i>689</i>&nbsp;        signature = sig;
<i>690</i>&nbsp;        sigp = offset;
<b class="nc"><i>691</i>&nbsp;        siglimit = offset + len;</b>
<b class="nc"><i>692</i>&nbsp;        return sigToType();</b>
<b class="nc"><i>693</i>&nbsp;    }</b>
<i>694</i>&nbsp;
<i>695</i>&nbsp;    /** Convert signature to type, where signature is implicit.
<i>696</i>&nbsp;     */
<i>697</i>&nbsp;    Type sigToType() {
<i>698</i>&nbsp;        switch ((char) signature[sigp]) {
<i>699</i>&nbsp;        case &#39;T&#39;:
<b class="nc"><i>700</i>&nbsp;            sigp++;</b>
<i>701</i>&nbsp;            int start = sigp;
<i>702</i>&nbsp;            while (signature[sigp] != &#39;;&#39;) sigp++;
<b class="nc"><i>703</i>&nbsp;            sigp++;</b>
<b class="nc"><i>704</i>&nbsp;            return sigEnterPhase</b>
<i>705</i>&nbsp;                ? Type.noType
<b class="nc"><i>706</i>&nbsp;                : findTypeVar(names.fromUtf(signature, start, sigp - 1 - start));</b>
<b class="nc"><i>707</i>&nbsp;        case &#39;+&#39;: {</b>
<i>708</i>&nbsp;            sigp++;
<b class="nc"><i>709</i>&nbsp;            Type t = sigToType();</b>
<b class="nc"><i>710</i>&nbsp;            return new WildcardType(t, BoundKind.EXTENDS, syms.boundClass);</b>
<i>711</i>&nbsp;        }
<b class="nc"><i>712</i>&nbsp;        case &#39;*&#39;:</b>
<b class="nc"><i>713</i>&nbsp;            sigp++;</b>
<i>714</i>&nbsp;            return new WildcardType(syms.objectType, BoundKind.UNBOUND,
<b class="nc"><i>715</i>&nbsp;                                    syms.boundClass);</b>
<b class="nc"><i>716</i>&nbsp;        case &#39;-&#39;: {</b>
<b class="nc"><i>717</i>&nbsp;            sigp++;</b>
<b class="nc"><i>718</i>&nbsp;            Type t = sigToType();</b>
<b class="nc"><i>719</i>&nbsp;            return new WildcardType(t, BoundKind.SUPER, syms.boundClass);</b>
<b class="nc"><i>720</i>&nbsp;        }</b>
<b class="nc"><i>721</i>&nbsp;        case &#39;B&#39;:</b>
<i>722</i>&nbsp;            sigp++;
<i>723</i>&nbsp;            return syms.byteType;
<b class="nc"><i>724</i>&nbsp;        case &#39;C&#39;:</b>
<b class="nc"><i>725</i>&nbsp;            sigp++;</b>
<b class="nc"><i>726</i>&nbsp;            return syms.charType;</b>
<i>727</i>&nbsp;        case &#39;D&#39;:
<i>728</i>&nbsp;            sigp++;
<b class="nc"><i>729</i>&nbsp;            return syms.doubleType;</b>
<i>730</i>&nbsp;        case &#39;F&#39;:
<b class="nc"><i>731</i>&nbsp;            sigp++;</b>
<i>732</i>&nbsp;            return syms.floatType;
<i>733</i>&nbsp;        case &#39;I&#39;:
<b class="nc"><i>734</i>&nbsp;            sigp++;</b>
<b class="nc"><i>735</i>&nbsp;            return syms.intType;</b>
<b class="nc"><i>736</i>&nbsp;        case &#39;J&#39;:</b>
<b class="nc"><i>737</i>&nbsp;            sigp++;</b>
<i>738</i>&nbsp;            return syms.longType;
<b class="nc"><i>739</i>&nbsp;        case &#39;L&#39;:</b>
<b class="nc"><i>740</i>&nbsp;            {</b>
<i>741</i>&nbsp;                // int oldsigp = sigp;
<i>742</i>&nbsp;                Type t = classSigToType();
<i>743</i>&nbsp;                if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;)
<b class="nc"><i>744</i>&nbsp;                    throw badClassFile(&quot;deprecated inner class signature syntax &quot; +</b>
<b class="nc"><i>745</i>&nbsp;                                       &quot;(please recompile from source)&quot;);</b>
<i>746</i>&nbsp;                /*
<i>747</i>&nbsp;                System.err.println(&quot; decoded &quot; +
<i>748</i>&nbsp;                                   new String(signature, oldsigp, sigp-oldsigp) +
<b class="nc"><i>749</i>&nbsp;                                   &quot; =&gt; &quot; + t + &quot; outer &quot; + t.outer());</b>
<b class="nc"><i>750</i>&nbsp;                */</b>
<b class="nc"><i>751</i>&nbsp;                return t;</b>
<b class="nc"><i>752</i>&nbsp;            }</b>
<b class="nc"><i>753</i>&nbsp;        case &#39;S&#39;:</b>
<b class="nc"><i>754</i>&nbsp;            sigp++;</b>
<i>755</i>&nbsp;            return syms.shortType;
<i>756</i>&nbsp;        case &#39;V&#39;:
<b class="nc"><i>757</i>&nbsp;            sigp++;</b>
<b class="nc"><i>758</i>&nbsp;            return syms.voidType;</b>
<i>759</i>&nbsp;        case &#39;Z&#39;:
<i>760</i>&nbsp;            sigp++;
<b class="nc"><i>761</i>&nbsp;            return syms.booleanType;</b>
<i>762</i>&nbsp;        case &#39;[&#39;:
<i>763</i>&nbsp;            sigp++;
<i>764</i>&nbsp;            return new ArrayType(sigToType(), syms.arrayClass);
<i>765</i>&nbsp;        case &#39;(&#39;:
<b class="nc"><i>766</i>&nbsp;            sigp++;</b>
<b class="nc"><i>767</i>&nbsp;            List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);</b>
<b class="nc"><i>768</i>&nbsp;            Type restype = sigToType();</b>
<i>769</i>&nbsp;            List&lt;Type&gt; thrown = List.nil();
<b class="nc"><i>770</i>&nbsp;            while (signature[sigp] == &#39;^&#39;) {</b>
<i>771</i>&nbsp;                sigp++;
<i>772</i>&nbsp;                thrown = thrown.prepend(sigToType());
<i>773</i>&nbsp;            }
<i>774</i>&nbsp;            // if there is a typevar in the throws clause we should state it.
<b class="nc"><i>775</i>&nbsp;            for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {</b>
<i>776</i>&nbsp;                if (l.head.hasTag(TYPEVAR)) {
<i>777</i>&nbsp;                    l.head.tsym.flags_field |= THROWS;
<b class="nc"><i>778</i>&nbsp;                }</b>
<b class="nc"><i>779</i>&nbsp;            }</b>
<i>780</i>&nbsp;            return new MethodType(argtypes,
<i>781</i>&nbsp;                                  restype,
<b class="nc"><i>782</i>&nbsp;                                  thrown.reverse(),</b>
<b class="nc"><i>783</i>&nbsp;                                  syms.methodClass);</b>
<b class="nc"><i>784</i>&nbsp;        case &#39;&lt;&#39;:</b>
<b class="nc"><i>785</i>&nbsp;            typevars = typevars.dup(currentOwner);</b>
<b class="nc"><i>786</i>&nbsp;            Type poly = new ForAll(sigToTypeParams(), sigToType());</b>
<b class="nc"><i>787</i>&nbsp;            typevars = typevars.leave();</b>
<b class="nc"><i>788</i>&nbsp;            return poly;</b>
<b class="nc"><i>789</i>&nbsp;        default:</b>
<b class="nc"><i>790</i>&nbsp;            throw badClassFile(&quot;bad.signature&quot;,</b>
<b class="nc"><i>791</i>&nbsp;                               Convert.utf2string(signature, sigp, 10));</b>
<i>792</i>&nbsp;        }
<b class="nc"><i>793</i>&nbsp;    }</b>
<i>794</i>&nbsp;
<b class="nc"><i>795</i>&nbsp;    byte[] signatureBuffer = new byte[0];</b>
<i>796</i>&nbsp;    int sbp = 0;
<i>797</i>&nbsp;    /** Convert class signature to type, where signature is implicit.
<i>798</i>&nbsp;     */
<b class="nc"><i>799</i>&nbsp;    Type classSigToType() {</b>
<b class="nc"><i>800</i>&nbsp;        if (signature[sigp] != &#39;L&#39;)</b>
<i>801</i>&nbsp;            throw badClassFile(&quot;bad.class.signature&quot;,
<i>802</i>&nbsp;                               Convert.utf2string(signature, sigp, 10));
<b class="nc"><i>803</i>&nbsp;        sigp++;</b>
<i>804</i>&nbsp;        Type outer = Type.noType;
<i>805</i>&nbsp;        int startSbp = sbp;
<i>806</i>&nbsp;
<b class="nc"><i>807</i>&nbsp;        while (true) {</b>
<i>808</i>&nbsp;            final byte c = signature[sigp++];
<i>809</i>&nbsp;            switch (c) {
<b class="nc"><i>810</i>&nbsp;</b>
<i>811</i>&nbsp;            case &#39;;&#39;: {         // end
<b class="nc"><i>812</i>&nbsp;                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,</b>
<i>813</i>&nbsp;                                                         startSbp,
<i>814</i>&nbsp;                                                         sbp - startSbp));
<i>815</i>&nbsp;
<i>816</i>&nbsp;                try {
<i>817</i>&nbsp;                    return (outer == Type.noType) ?
<i>818</i>&nbsp;                            t.erasure(types) :
<b class="nc"><i>819</i>&nbsp;                        new ClassType(outer, List.nil(), t);</b>
<i>820</i>&nbsp;                } finally {
<b class="nc"><i>821</i>&nbsp;                    sbp = startSbp;</b>
<b class="nc"><i>822</i>&nbsp;                }</b>
<i>823</i>&nbsp;            }
<b class="nc"><i>824</i>&nbsp;</b>
<b class="nc"><i>825</i>&nbsp;            case &#39;&lt;&#39;:           // generic arguments</b>
<i>826</i>&nbsp;                ClassSymbol t = enterClass(names.fromUtf(signatureBuffer,
<i>827</i>&nbsp;                                                         startSbp,
<b class="nc"><i>828</i>&nbsp;                                                         sbp - startSbp));</b>
<b class="nc"><i>829</i>&nbsp;                outer = new ClassType(outer, sigToTypes(&#39;&gt;&#39;), t) {</b>
<i>830</i>&nbsp;                        boolean completed = false;
<b class="nc"><i>831</i>&nbsp;                        @Override @DefinedBy(Api.LANGUAGE_MODEL)</b>
<i>832</i>&nbsp;                        public Type getEnclosingType() {
<i>833</i>&nbsp;                            if (!completed) {
<i>834</i>&nbsp;                                completed = true;
<i>835</i>&nbsp;                                tsym.complete();
<i>836</i>&nbsp;                                Type enclosingType = tsym.type.getEnclosingType();
<b class="nc"><i>837</i>&nbsp;                                if (enclosingType != Type.noType) {</b>
<b class="nc"><i>838</i>&nbsp;                                    List&lt;Type&gt; typeArgs =</b>
<i>839</i>&nbsp;                                        super.getEnclosingType().allparams();
<i>840</i>&nbsp;                                    List&lt;Type&gt; typeParams =
<b class="nc"><i>841</i>&nbsp;                                        enclosingType.allparams();</b>
<i>842</i>&nbsp;                                    if (typeParams.length() != typeArgs.length()) {
<b class="nc"><i>843</i>&nbsp;                                        // no &quot;rare&quot; types</b>
<b class="nc"><i>844</i>&nbsp;                                        super.setEnclosingType(types.erasure(enclosingType));</b>
<i>845</i>&nbsp;                                    } else {
<b class="nc"><i>846</i>&nbsp;                                        super.setEnclosingType(types.subst(enclosingType,</b>
<b class="nc"><i>847</i>&nbsp;                                                                           typeParams,</b>
<i>848</i>&nbsp;                                                                           typeArgs));
<b class="nc"><i>849</i>&nbsp;                                    }</b>
<b class="nc"><i>850</i>&nbsp;                                } else {</b>
<i>851</i>&nbsp;                                    super.setEnclosingType(Type.noType);
<i>852</i>&nbsp;                                }
<i>853</i>&nbsp;                            }
<i>854</i>&nbsp;                            return super.getEnclosingType();
<i>855</i>&nbsp;                        }
<i>856</i>&nbsp;                        @Override
<i>857</i>&nbsp;                        public void setEnclosingType(Type outer) {
<i>858</i>&nbsp;                            throw new UnsupportedOperationException();
<b class="nc"><i>859</i>&nbsp;                        }</b>
<b class="nc"><i>860</i>&nbsp;                    };</b>
<b class="nc"><i>861</i>&nbsp;                switch (signature[sigp++]) {</b>
<b class="nc"><i>862</i>&nbsp;                case &#39;;&#39;:</b>
<b class="nc"><i>863</i>&nbsp;                    if (sigp &lt; signature.length &amp;&amp; signature[sigp] == &#39;.&#39;) {</b>
<b class="nc"><i>864</i>&nbsp;                        // support old-style GJC signatures</b>
<i>865</i>&nbsp;                        // The signature produced was
<i>866</i>&nbsp;                        // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
<i>867</i>&nbsp;                        // rather than say
<i>868</i>&nbsp;                        // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
<i>869</i>&nbsp;                        // so we skip past &quot;.Lfoo/Outer$&quot;
<i>870</i>&nbsp;                        sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
<b class="nc"><i>871</i>&nbsp;                            3;  // &quot;.L&quot; and &quot;$&quot;</b>
<b class="nc"><i>872</i>&nbsp;                        signatureBuffer[sbp++] = (byte)&#39;$&#39;;</b>
<b class="nc"><i>873</i>&nbsp;                        break;</b>
<b class="nc"><i>874</i>&nbsp;                    } else {</b>
<i>875</i>&nbsp;                        sbp = startSbp;
<i>876</i>&nbsp;                        return outer;
<i>877</i>&nbsp;                    }
<i>878</i>&nbsp;                case &#39;.&#39;:
<i>879</i>&nbsp;                    signatureBuffer[sbp++] = (byte)&#39;$&#39;;
<b class="nc"><i>880</i>&nbsp;                    break;</b>
<b class="nc"><i>881</i>&nbsp;                default:</b>
<b class="nc"><i>882</i>&nbsp;                    throw new AssertionError(signature[sigp-1]);</b>
<b class="nc"><i>883</i>&nbsp;                }</b>
<b class="nc"><i>884</i>&nbsp;                continue;</b>
<b class="nc"><i>885</i>&nbsp;</b>
<b class="nc"><i>886</i>&nbsp;            case &#39;.&#39;:</b>
<b class="nc"><i>887</i>&nbsp;                //we have seen an enclosing non-generic class</b>
<b class="nc"><i>888</i>&nbsp;                if (outer != Type.noType) {</b>
<b class="nc"><i>889</i>&nbsp;                    t = enterClass(names.fromUtf(signatureBuffer,</b>
<b class="nc"><i>890</i>&nbsp;                                                 startSbp,</b>
<b class="nc"><i>891</i>&nbsp;                                                 sbp - startSbp));</b>
<i>892</i>&nbsp;                    outer = new ClassType(outer, List.nil(), t);
<b class="nc"><i>893</i>&nbsp;                }</b>
<i>894</i>&nbsp;                signatureBuffer[sbp++] = (byte)&#39;$&#39;;
<i>895</i>&nbsp;                continue;
<i>896</i>&nbsp;            case &#39;/&#39;:
<i>897</i>&nbsp;                signatureBuffer[sbp++] = (byte)&#39;.&#39;;
<i>898</i>&nbsp;                continue;
<b class="nc"><i>899</i>&nbsp;            default:</b>
<b class="nc"><i>900</i>&nbsp;                signatureBuffer[sbp++] = c;</b>
<b class="nc"><i>901</i>&nbsp;                continue;</b>
<i>902</i>&nbsp;            }
<b class="nc"><i>903</i>&nbsp;        }</b>
<b class="nc"><i>904</i>&nbsp;    }</b>
<b class="nc"><i>905</i>&nbsp;</b>
<i>906</i>&nbsp;    /** Convert (implicit) signature to list of types
<b class="nc"><i>907</i>&nbsp;     *  until `terminator&#39; is encountered.</b>
<i>908</i>&nbsp;     */
<b class="nc"><i>909</i>&nbsp;    List&lt;Type&gt; sigToTypes(char terminator) {</b>
<b class="nc"><i>910</i>&nbsp;        List&lt;Type&gt; head = List.of(null);</b>
<b class="nc"><i>911</i>&nbsp;        List&lt;Type&gt; tail = head;</b>
<b class="nc"><i>912</i>&nbsp;        while (signature[sigp] != terminator)</b>
<b class="nc"><i>913</i>&nbsp;            tail = tail.setTail(List.of(sigToType()));</b>
<i>914</i>&nbsp;        sigp++;
<b class="nc"><i>915</i>&nbsp;        return head.tail;</b>
<b class="nc"><i>916</i>&nbsp;    }</b>
<b class="nc"><i>917</i>&nbsp;</b>
<i>918</i>&nbsp;    /** Convert signature to type parameters, where signature is a byte
<b class="nc"><i>919</i>&nbsp;     *  array segment.</b>
<b class="nc"><i>920</i>&nbsp;     */</b>
<i>921</i>&nbsp;    List&lt;Type&gt; sigToTypeParams(byte[] sig, int offset, int len) {
<b class="nc"><i>922</i>&nbsp;        signature = sig;</b>
<i>923</i>&nbsp;        sigp = offset;
<i>924</i>&nbsp;        siglimit = offset + len;
<i>925</i>&nbsp;        return sigToTypeParams();
<i>926</i>&nbsp;    }
<i>927</i>&nbsp;
<b class="nc"><i>928</i>&nbsp;    /** Convert signature to type parameters, where signature is implicit.</b>
<b class="nc"><i>929</i>&nbsp;     */</b>
<b class="nc"><i>930</i>&nbsp;    List&lt;Type&gt; sigToTypeParams() {</b>
<i>931</i>&nbsp;        List&lt;Type&gt; tvars = List.nil();
<b class="nc"><i>932</i>&nbsp;        if (signature[sigp] == &#39;&lt;&#39;) {</b>
<i>933</i>&nbsp;            sigp++;
<i>934</i>&nbsp;            int start = sigp;
<i>935</i>&nbsp;            sigEnterPhase = true;
<i>936</i>&nbsp;            while (signature[sigp] != &#39;&gt;&#39;)
<i>937</i>&nbsp;                tvars = tvars.prepend(sigToTypeParam());
<i>938</i>&nbsp;            sigEnterPhase = false;
<i>939</i>&nbsp;            sigp = start;
<i>940</i>&nbsp;            while (signature[sigp] != &#39;&gt;&#39;)
<i>941</i>&nbsp;                sigToTypeParam();
<i>942</i>&nbsp;            sigp++;
<b class="nc"><i>943</i>&nbsp;        }</b>
<b class="nc"><i>944</i>&nbsp;        return tvars.reverse();</b>
<i>945</i>&nbsp;    }
<b class="nc"><i>946</i>&nbsp;</b>
<i>947</i>&nbsp;    /** Convert (implicit) signature to type parameter.
<b class="nc"><i>948</i>&nbsp;     */</b>
<i>949</i>&nbsp;    Type sigToTypeParam() {
<i>950</i>&nbsp;        int start = sigp;
<i>951</i>&nbsp;        while (signature[sigp] != &#39;:&#39;) sigp++;
<i>952</i>&nbsp;        Name name = names.fromUtf(signature, start, sigp - start);
<i>953</i>&nbsp;        TypeVar tvar;
<i>954</i>&nbsp;        if (sigEnterPhase) {
<i>955</i>&nbsp;            tvar = new TypeVar(name, currentOwner, syms.botType);
<b class="nc"><i>956</i>&nbsp;            typevars.enter(tvar.tsym);</b>
<i>957</i>&nbsp;        } else {
<b class="nc"><i>958</i>&nbsp;            tvar = (TypeVar)findTypeVar(name);</b>
<b class="nc"><i>959</i>&nbsp;        }</b>
<b class="nc"><i>960</i>&nbsp;        List&lt;Type&gt; bounds = List.nil();</b>
<b class="nc"><i>961</i>&nbsp;        boolean allInterfaces = false;</b>
<i>962</i>&nbsp;        if (signature[sigp] == &#39;:&#39; &amp;&amp; signature[sigp+1] == &#39;:&#39;) {
<i>963</i>&nbsp;            sigp++;
<i>964</i>&nbsp;            allInterfaces = true;
<b class="nc"><i>965</i>&nbsp;        }</b>
<b class="nc"><i>966</i>&nbsp;        while (signature[sigp] == &#39;:&#39;) {</b>
<b class="nc"><i>967</i>&nbsp;            sigp++;</b>
<i>968</i>&nbsp;            bounds = bounds.prepend(sigToType());
<b class="nc"><i>969</i>&nbsp;        }</b>
<b class="nc"><i>970</i>&nbsp;        if (!sigEnterPhase) {</b>
<i>971</i>&nbsp;            types.setBounds(tvar, bounds.reverse(), allInterfaces);
<b class="nc"><i>972</i>&nbsp;        }</b>
<b class="nc"><i>973</i>&nbsp;        return tvar;</b>
<i>974</i>&nbsp;    }
<b class="nc"><i>975</i>&nbsp;</b>
<b class="nc"><i>976</i>&nbsp;    /** Find type variable with given name in `typevars&#39; scope.</b>
<b class="nc"><i>977</i>&nbsp;     */</b>
<i>978</i>&nbsp;    Type findTypeVar(Name name) {
<i>979</i>&nbsp;        Symbol s = typevars.findFirst(name);
<b class="nc"><i>980</i>&nbsp;        if (s != null) {</b>
<i>981</i>&nbsp;            return s.type;
<i>982</i>&nbsp;        } else {
<i>983</i>&nbsp;            if (readingClassAttr) {
<i>984</i>&nbsp;                // While reading the class attribute, the supertypes
<i>985</i>&nbsp;                // might refer to a type variable from an enclosing element
<i>986</i>&nbsp;                // (method or class).
<i>987</i>&nbsp;                // If the type variable is defined in the enclosing class,
<i>988</i>&nbsp;                // we can actually find it in
<i>989</i>&nbsp;                // currentOwner.owner.type.getTypeArguments()
<b class="nc"><i>990</i>&nbsp;                // However, until we have read the enclosing method attribute</b>
<b class="nc"><i>991</i>&nbsp;                // we don&#39;t know for sure if this owner is correct.  It could</b>
<b class="nc"><i>992</i>&nbsp;                // be a method and there is no way to tell before reading the</b>
<b class="nc"><i>993</i>&nbsp;                // enclosing method attribute.</b>
<b class="nc"><i>994</i>&nbsp;                TypeVar t = new TypeVar(name, currentOwner, syms.botType);</b>
<b class="nc"><i>995</i>&nbsp;                missingTypeVariables = missingTypeVariables.prepend(t);</b>
<i>996</i>&nbsp;                // System.err.println(&quot;Missing type var &quot; + name);
<b class="nc"><i>997</i>&nbsp;                return t;</b>
<i>998</i>&nbsp;            }
<i>999</i>&nbsp;            throw badClassFile(&quot;undecl.type.var&quot;, name);
<b class="nc"><i>1000</i>&nbsp;        }</b>
<i>1001</i>&nbsp;    }
<i>1002</i>&nbsp;
<b class="nc"><i>1003</i>&nbsp;/************************************************************************</b>
<i>1004</i>&nbsp; * Reading Attributes
<b class="nc"><i>1005</i>&nbsp; ***********************************************************************/</b>
<b class="nc"><i>1006</i>&nbsp;</b>
<i>1007</i>&nbsp;    protected enum AttributeKind { CLASS, MEMBER }
<b class="nc"><i>1008</i>&nbsp;</b>
<i>1009</i>&nbsp;    protected abstract class AttributeReader {
<i>1010</i>&nbsp;        protected AttributeReader(Name name, ClassFile.Version version, Set&lt;AttributeKind&gt; kinds) {
<i>1011</i>&nbsp;            this.name = name;
<b class="nc"><i>1012</i>&nbsp;            this.version = version;</b>
<i>1013</i>&nbsp;            this.kinds = kinds;
<b class="nc"><i>1014</i>&nbsp;        }</b>
<i>1015</i>&nbsp;
<b class="nc"><i>1016</i>&nbsp;        protected boolean accepts(AttributeKind kind) {</b>
<b class="nc"><i>1017</i>&nbsp;            if (kinds.contains(kind)) {</b>
<i>1018</i>&nbsp;                if (majorVersion &gt; version.major || (majorVersion == version.major &amp;&amp; minorVersion &gt;= version.minor))
<i>1019</i>&nbsp;                    return true;
<i>1020</i>&nbsp;
<b class="nc"><i>1021</i>&nbsp;                if (lintClassfile &amp;&amp; !warnedAttrs.contains(name)) {</b>
<i>1022</i>&nbsp;                    JavaFileObject prev = log.useSource(currentClassFile);
<b class="nc"><i>1023</i>&nbsp;                    try {</b>
<i>1024</i>&nbsp;                        log.warning(LintCategory.CLASSFILE, (DiagnosticPosition) null,
<i>1025</i>&nbsp;                                    Warnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));
<i>1026</i>&nbsp;                    } finally {
<b class="nc"><i>1027</i>&nbsp;                        log.useSource(prev);</b>
<i>1028</i>&nbsp;                    }
<b class="nc"><i>1029</i>&nbsp;                    warnedAttrs.add(name);</b>
<b class="nc"><i>1030</i>&nbsp;                }</b>
<b class="nc"><i>1031</i>&nbsp;            }</b>
<b class="nc"><i>1032</i>&nbsp;            return false;</b>
<b class="nc"><i>1033</i>&nbsp;        }</b>
<b class="nc"><i>1034</i>&nbsp;</b>
<i>1035</i>&nbsp;        protected abstract void read(Symbol sym, int attrLen);
<i>1036</i>&nbsp;
<i>1037</i>&nbsp;        protected final Name name;
<b class="nc"><i>1038</i>&nbsp;        protected final ClassFile.Version version;</b>
<i>1039</i>&nbsp;        protected final Set&lt;AttributeKind&gt; kinds;
<b class="nc"><i>1040</i>&nbsp;    }</b>
<b class="nc"><i>1041</i>&nbsp;</b>
<i>1042</i>&nbsp;    protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
<i>1043</i>&nbsp;            EnumSet.of(AttributeKind.CLASS);
<i>1044</i>&nbsp;    protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
<b class="nc"><i>1045</i>&nbsp;            EnumSet.of(AttributeKind.MEMBER);</b>
<i>1046</i>&nbsp;    protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
<b class="nc"><i>1047</i>&nbsp;            EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);</b>
<b class="nc"><i>1048</i>&nbsp;</b>
<i>1049</i>&nbsp;    protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;    private void initAttributeReaders() {
<i>1052</i>&nbsp;        AttributeReader[] readers = {
<i>1053</i>&nbsp;            // v45.3 attributes
<i>1054</i>&nbsp;
<i>1055</i>&nbsp;            new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
<i>1056</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1057</i>&nbsp;                    if (readAllOfClassFile || saveParameterNames)
<b class="nc"><i>1058</i>&nbsp;                        ((MethodSymbol)sym).code = readCode(sym);</b>
<b class="nc"><i>1059</i>&nbsp;                    else</b>
<b class="nc"><i>1060</i>&nbsp;                        bp = bp + attrLen;</b>
<b class="nc"><i>1061</i>&nbsp;                }</b>
<b class="nc"><i>1062</i>&nbsp;            },</b>
<b class="nc"><i>1063</i>&nbsp;</b>
<b class="nc"><i>1064</i>&nbsp;            new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {</b>
<b class="nc"><i>1065</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<i>1066</i>&nbsp;                    Object v = readPool(nextChar());
<b class="nc"><i>1067</i>&nbsp;                    // Ignore ConstantValue attribute if field not final.</b>
<b class="nc"><i>1068</i>&nbsp;                    if ((sym.flags() &amp; FINAL) == 0) {</b>
<b class="nc"><i>1069</i>&nbsp;                        return;</b>
<b class="nc"><i>1070</i>&nbsp;                    }</b>
<i>1071</i>&nbsp;                    VarSymbol var = (VarSymbol) sym;
<b class="nc"><i>1072</i>&nbsp;                    switch (var.type.getTag()) {</b>
<b class="nc"><i>1073</i>&nbsp;                       case BOOLEAN:</b>
<i>1074</i>&nbsp;                       case BYTE:
<i>1075</i>&nbsp;                       case CHAR:
<i>1076</i>&nbsp;                       case SHORT:
<b class="nc"><i>1077</i>&nbsp;                       case INT:</b>
<i>1078</i>&nbsp;                           checkType(var, Integer.class, v);
<i>1079</i>&nbsp;                           break;
<i>1080</i>&nbsp;                       case LONG:
<b class="nc"><i>1081</i>&nbsp;                           checkType(var, Long.class, v);</b>
<i>1082</i>&nbsp;                           break;
<b class="nc"><i>1083</i>&nbsp;                       case FLOAT:</b>
<b class="nc"><i>1084</i>&nbsp;                           checkType(var, Float.class, v);</b>
<b class="nc"><i>1085</i>&nbsp;                           break;</b>
<b class="nc"><i>1086</i>&nbsp;                       case DOUBLE:</b>
<b class="nc"><i>1087</i>&nbsp;                           checkType(var, Double.class, v);</b>
<b class="nc"><i>1088</i>&nbsp;                           break;</b>
<b class="nc"><i>1089</i>&nbsp;                       case CLASS:</b>
<b class="nc"><i>1090</i>&nbsp;                           Assert.check(var.type.tsym == syms.stringType.tsym);</b>
<b class="nc"><i>1091</i>&nbsp;                           checkType(var, String.class, v);</b>
<b class="nc"><i>1092</i>&nbsp;                           break;</b>
<i>1093</i>&nbsp;                       default:
<i>1094</i>&nbsp;                           // ignore ConstantValue attribute if type is not primitive or String
<b class="nc"><i>1095</i>&nbsp;                           return;</b>
<i>1096</i>&nbsp;                    }
<i>1097</i>&nbsp;                    if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
<i>1098</i>&nbsp;                        throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
<i>1099</i>&nbsp;                    }
<b class="nc"><i>1100</i>&nbsp;                    var.setData(v);</b>
<i>1101</i>&nbsp;                }
<b class="nc"><i>1102</i>&nbsp;</b>
<b class="nc"><i>1103</i>&nbsp;                void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {</b>
<b class="nc"><i>1104</i>&nbsp;                    if (!clazz.isInstance(value)) {</b>
<i>1105</i>&nbsp;                        throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
<i>1106</i>&nbsp;                    }
<i>1107</i>&nbsp;                }
<b class="nc"><i>1108</i>&nbsp;            },</b>
<b class="nc"><i>1109</i>&nbsp;</b>
<b class="nc"><i>1110</i>&nbsp;            new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<b class="nc"><i>1111</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1112</i>&nbsp;                    Symbol s = sym.owner.kind == MDL ? sym.owner : sym;</b>
<i>1113</i>&nbsp;
<i>1114</i>&nbsp;                    s.flags_field |= DEPRECATED;
<i>1115</i>&nbsp;                }
<i>1116</i>&nbsp;            },
<b class="nc"><i>1117</i>&nbsp;</b>
<i>1118</i>&nbsp;            new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1119</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<b class="nc"><i>1120</i>&nbsp;                    int nexceptions = nextChar();</b>
<b class="nc"><i>1121</i>&nbsp;                    List&lt;Type&gt; thrown = List.nil();</b>
<i>1122</i>&nbsp;                    for (int j = 0; j &lt; nexceptions; j++)
<i>1123</i>&nbsp;                        thrown = thrown.prepend(readClassSymbol(nextChar()).type);
<i>1124</i>&nbsp;                    if (sym.type.getThrownTypes().isEmpty())
<i>1125</i>&nbsp;                        sym.type.asMethodType().thrown = thrown.reverse();
<i>1126</i>&nbsp;                }
<b class="nc"><i>1127</i>&nbsp;            },</b>
<i>1128</i>&nbsp;
<b class="nc"><i>1129</i>&nbsp;            new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {</b>
<b class="nc"><i>1130</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1131</i>&nbsp;                    ClassSymbol c = (ClassSymbol) sym;</b>
<i>1132</i>&nbsp;                    if (currentModule.module_info == c) {
<i>1133</i>&nbsp;                        //prevent entering the classes too soon:
<i>1134</i>&nbsp;                        skipInnerClasses();
<b class="nc"><i>1135</i>&nbsp;                    } else {</b>
<i>1136</i>&nbsp;                        readInnerClasses(c);
<i>1137</i>&nbsp;                    }
<b class="nc"><i>1138</i>&nbsp;                }</b>
<i>1139</i>&nbsp;            },
<i>1140</i>&nbsp;
<i>1141</i>&nbsp;            new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
<b class="nc"><i>1142</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1143</i>&nbsp;                    int newbp = bp + attrLen;</b>
<b class="nc"><i>1144</i>&nbsp;                    if (saveParameterNames &amp;&amp; !sawMethodParameters) {</b>
<i>1145</i>&nbsp;                        // Pick up parameter names from the variable table.
<b class="nc"><i>1146</i>&nbsp;                        // Parameter names are not explicitly identified as such,</b>
<b class="nc"><i>1147</i>&nbsp;                        // but all parameter name entries in the LocalVariableTable</b>
<b class="nc"><i>1148</i>&nbsp;                        // have a start_pc of 0.  Therefore, we record the name</b>
<b class="nc"><i>1149</i>&nbsp;                        // indicies of all slots with a start_pc of zero in the</b>
<b class="nc"><i>1150</i>&nbsp;                        // parameterNameIndicies array.</b>
<b class="nc"><i>1151</i>&nbsp;                        // Note that this implicitly honors the JVMS spec that</b>
<b class="nc"><i>1152</i>&nbsp;                        // there may be more than one LocalVariableTable, and that</b>
<i>1153</i>&nbsp;                        // there is no specified ordering for the entries.
<b class="nc"><i>1154</i>&nbsp;                        int numEntries = nextChar();</b>
<b class="nc"><i>1155</i>&nbsp;                        for (int i = 0; i &lt; numEntries; i++) {</b>
<b class="nc"><i>1156</i>&nbsp;                            int start_pc = nextChar();</b>
<b class="nc"><i>1157</i>&nbsp;                            int length = nextChar();</b>
<b class="nc"><i>1158</i>&nbsp;                            int nameIndex = nextChar();</b>
<i>1159</i>&nbsp;                            int sigIndex = nextChar();
<b class="nc"><i>1160</i>&nbsp;                            int register = nextChar();</b>
<b class="nc"><i>1161</i>&nbsp;                            if (start_pc == 0) {</b>
<i>1162</i>&nbsp;                                // ensure array large enough
<i>1163</i>&nbsp;                                if (register &gt;= parameterNameIndices.length) {
<i>1164</i>&nbsp;                                    int newSize =
<i>1165</i>&nbsp;                                            Math.max(register + 1, parameterNameIndices.length + 8);
<i>1166</i>&nbsp;                                    parameterNameIndices =
<i>1167</i>&nbsp;                                            Arrays.copyOf(parameterNameIndices, newSize);
<i>1168</i>&nbsp;                                }
<b class="nc"><i>1169</i>&nbsp;                                parameterNameIndices[register] = nameIndex;</b>
<i>1170</i>&nbsp;                                haveParameterNameIndices = true;
<b class="nc"><i>1171</i>&nbsp;                            }</b>
<i>1172</i>&nbsp;                        }
<i>1173</i>&nbsp;                    }
<i>1174</i>&nbsp;                    bp = newbp;
<b class="nc"><i>1175</i>&nbsp;                }</b>
<i>1176</i>&nbsp;            },
<b class="nc"><i>1177</i>&nbsp;</b>
<i>1178</i>&nbsp;            new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
<i>1179</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1180</i>&nbsp;                    ClassSymbol c = (ClassSymbol) sym;
<b class="nc"><i>1181</i>&nbsp;                    Name n = readName(nextChar());</b>
<i>1182</i>&nbsp;                    c.sourcefile = new SourceFileObject(n, c.flatname);
<b class="nc"><i>1183</i>&nbsp;                    // If the class is a toplevel class, originating from a Java source file,</b>
<i>1184</i>&nbsp;                    // but the class name does not match the file name, then it is
<i>1185</i>&nbsp;                    // an auxiliary class.
<i>1186</i>&nbsp;                    String sn = n.toString();
<b class="nc"><i>1187</i>&nbsp;                    if (c.owner.kind == PCK &amp;&amp;</b>
<i>1188</i>&nbsp;                        sn.endsWith(&quot;.java&quot;) &amp;&amp;
<b class="nc"><i>1189</i>&nbsp;                        !sn.equals(c.name.toString()+&quot;.java&quot;)) {</b>
<i>1190</i>&nbsp;                        c.flags_field |= AUXILIARY;
<i>1191</i>&nbsp;                    }
<i>1192</i>&nbsp;                }
<b class="nc"><i>1193</i>&nbsp;            },</b>
<i>1194</i>&nbsp;
<b class="nc"><i>1195</i>&nbsp;            new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<i>1196</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1197</i>&nbsp;                    sym.flags_field |= SYNTHETIC;
<i>1198</i>&nbsp;                }
<i>1199</i>&nbsp;            },
<i>1200</i>&nbsp;
<b class="nc"><i>1201</i>&nbsp;            // standard v49 attributes</b>
<i>1202</i>&nbsp;
<b class="nc"><i>1203</i>&nbsp;            new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {</b>
<b class="nc"><i>1204</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<i>1205</i>&nbsp;                    int newbp = bp + attrLen;
<i>1206</i>&nbsp;                    readEnclosingMethodAttr(sym);
<i>1207</i>&nbsp;                    bp = newbp;
<b class="nc"><i>1208</i>&nbsp;                }</b>
<i>1209</i>&nbsp;            },
<b class="nc"><i>1210</i>&nbsp;</b>
<b class="nc"><i>1211</i>&nbsp;            new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<b class="nc"><i>1212</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<i>1213</i>&nbsp;                    if (sym.kind == TYP) {
<i>1214</i>&nbsp;                        ClassSymbol c = (ClassSymbol) sym;
<i>1215</i>&nbsp;                        readingClassAttr = true;
<b class="nc"><i>1216</i>&nbsp;                        try {</b>
<i>1217</i>&nbsp;                            ClassType ct1 = (ClassType)c.type;
<b class="nc"><i>1218</i>&nbsp;                            Assert.check(c == currentOwner);</b>
<i>1219</i>&nbsp;                            ct1.typarams_field = readTypeParams(nextChar());
<i>1220</i>&nbsp;                            ct1.supertype_field = sigToType();
<i>1221</i>&nbsp;                            ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
<b class="nc"><i>1222</i>&nbsp;                            while (sigp != siglimit) is.append(sigToType());</b>
<i>1223</i>&nbsp;                            ct1.interfaces_field = is.toList();
<b class="nc"><i>1224</i>&nbsp;                        } finally {</b>
<b class="nc"><i>1225</i>&nbsp;                            readingClassAttr = false;</b>
<i>1226</i>&nbsp;                        }
<i>1227</i>&nbsp;                    } else {
<i>1228</i>&nbsp;                        List&lt;Type&gt; thrown = sym.type.getThrownTypes();
<b class="nc"><i>1229</i>&nbsp;                        sym.type = readType(nextChar());</b>
<i>1230</i>&nbsp;                        //- System.err.println(&quot; # &quot; + sym.type);
<b class="nc"><i>1231</i>&nbsp;                        if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())</b>
<i>1232</i>&nbsp;                            sym.type.asMethodType().thrown = thrown;
<i>1233</i>&nbsp;
<i>1234</i>&nbsp;                    }
<b class="nc"><i>1235</i>&nbsp;                }</b>
<i>1236</i>&nbsp;            },
<b class="nc"><i>1237</i>&nbsp;</b>
<i>1238</i>&nbsp;            // v49 annotation attributes
<i>1239</i>&nbsp;
<i>1240</i>&nbsp;            new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1241</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1242</i>&nbsp;                    attachAnnotationDefault(sym);
<i>1243</i>&nbsp;                }
<i>1244</i>&nbsp;            },
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;            new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1247</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1248</i>&nbsp;                    attachAnnotations(sym);
<b class="nc"><i>1249</i>&nbsp;                }</b>
<b class="nc"><i>1250</i>&nbsp;            },</b>
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;            new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1253</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1254</i>&nbsp;                    readParameterAnnotations(sym);
<i>1255</i>&nbsp;                }
<b class="nc"><i>1256</i>&nbsp;            },</b>
<b class="nc"><i>1257</i>&nbsp;</b>
<i>1258</i>&nbsp;            new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1259</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1260</i>&nbsp;                    attachAnnotations(sym);
<i>1261</i>&nbsp;                }
<i>1262</i>&nbsp;            },
<i>1263</i>&nbsp;
<i>1264</i>&nbsp;            new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1265</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<b class="nc"><i>1266</i>&nbsp;                    readParameterAnnotations(sym);</b>
<b class="nc"><i>1267</i>&nbsp;                }</b>
<b class="nc"><i>1268</i>&nbsp;            },</b>
<b class="nc"><i>1269</i>&nbsp;</b>
<i>1270</i>&nbsp;            // additional &quot;legacy&quot; v49 attributes, superceded by flags
<b class="nc"><i>1271</i>&nbsp;</b>
<b class="nc"><i>1272</i>&nbsp;            new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<i>1273</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<b class="nc"><i>1274</i>&nbsp;                    sym.flags_field |= ANNOTATION;</b>
<b class="nc"><i>1275</i>&nbsp;                }</b>
<b class="nc"><i>1276</i>&nbsp;            },</b>
<i>1277</i>&nbsp;
<b class="nc"><i>1278</i>&nbsp;            new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {</b>
<b class="nc"><i>1279</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1280</i>&nbsp;                    sym.flags_field |= BRIDGE;</b>
<b class="nc"><i>1281</i>&nbsp;                }</b>
<i>1282</i>&nbsp;            },
<b class="nc"><i>1283</i>&nbsp;</b>
<i>1284</i>&nbsp;            new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
<b class="nc"><i>1285</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1286</i>&nbsp;                    sym.flags_field |= ENUM;</b>
<b class="nc"><i>1287</i>&nbsp;                }</b>
<b class="nc"><i>1288</i>&nbsp;            },</b>
<i>1289</i>&nbsp;
<b class="nc"><i>1290</i>&nbsp;            new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<i>1291</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<b class="nc"><i>1292</i>&nbsp;                    sym.flags_field |= VARARGS;</b>
<b class="nc"><i>1293</i>&nbsp;                }</b>
<b class="nc"><i>1294</i>&nbsp;            },</b>
<b class="nc"><i>1295</i>&nbsp;</b>
<b class="nc"><i>1296</i>&nbsp;            new AttributeReader(names.RuntimeVisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {</b>
<b class="nc"><i>1297</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1298</i>&nbsp;                    attachTypeAnnotations(sym);</b>
<b class="nc"><i>1299</i>&nbsp;                }</b>
<b class="nc"><i>1300</i>&nbsp;            },</b>
<i>1301</i>&nbsp;
<i>1302</i>&nbsp;            new AttributeReader(names.RuntimeInvisibleTypeAnnotations, V52, CLASS_OR_MEMBER_ATTRIBUTE) {
<i>1303</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1304</i>&nbsp;                    attachTypeAnnotations(sym);
<i>1305</i>&nbsp;                }
<b class="nc"><i>1306</i>&nbsp;            },</b>
<b class="nc"><i>1307</i>&nbsp;</b>
<b class="nc"><i>1308</i>&nbsp;            // The following attributes for a Code attribute are not currently handled</b>
<b class="nc"><i>1309</i>&nbsp;            // StackMapTable</b>
<b class="nc"><i>1310</i>&nbsp;            // SourceDebugExtension</b>
<b class="nc"><i>1311</i>&nbsp;            // LineNumberTable</b>
<b class="nc"><i>1312</i>&nbsp;            // LocalVariableTypeTable</b>
<b class="nc"><i>1313</i>&nbsp;</b>
<i>1314</i>&nbsp;            // standard v52 attributes
<i>1315</i>&nbsp;
<i>1316</i>&nbsp;            new AttributeReader(names.MethodParameters, V52, MEMBER_ATTRIBUTE) {
<b class="nc"><i>1317</i>&nbsp;                protected void read(Symbol sym, int attrlen) {</b>
<b class="nc"><i>1318</i>&nbsp;                    int newbp = bp + attrlen;</b>
<i>1319</i>&nbsp;                    if (saveParameterNames) {
<b class="nc"><i>1320</i>&nbsp;                        sawMethodParameters = true;</b>
<i>1321</i>&nbsp;                        int numEntries = nextByte();
<b class="nc"><i>1322</i>&nbsp;                        parameterNameIndices = new int[numEntries];</b>
<b class="nc"><i>1323</i>&nbsp;                        haveParameterNameIndices = true;</b>
<b class="nc"><i>1324</i>&nbsp;                        int index = 0;</b>
<i>1325</i>&nbsp;                        for (int i = 0; i &lt; numEntries; i++) {
<b class="nc"><i>1326</i>&nbsp;                            int nameIndex = nextChar();</b>
<i>1327</i>&nbsp;                            int flags = nextChar();
<b class="nc"><i>1328</i>&nbsp;                            if ((flags &amp; (Flags.MANDATED | Flags.SYNTHETIC)) != 0) {</b>
<b class="nc"><i>1329</i>&nbsp;                                continue;</b>
<i>1330</i>&nbsp;                            }
<b class="nc"><i>1331</i>&nbsp;                            parameterNameIndices[index++] = nameIndex;</b>
<b class="nc"><i>1332</i>&nbsp;                        }</b>
<i>1333</i>&nbsp;                    }
<b class="nc"><i>1334</i>&nbsp;                    bp = newbp;</b>
<i>1335</i>&nbsp;                }
<i>1336</i>&nbsp;            },
<i>1337</i>&nbsp;
<b class="nc"><i>1338</i>&nbsp;            // standard v53 attributes</b>
<b class="nc"><i>1339</i>&nbsp;</b>
<b class="nc"><i>1340</i>&nbsp;            new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {</b>
<i>1341</i>&nbsp;                @Override
<i>1342</i>&nbsp;                protected boolean accepts(AttributeKind kind) {
<b class="nc"><i>1343</i>&nbsp;                    return super.accepts(kind) &amp;&amp; allowModules;</b>
<i>1344</i>&nbsp;                }
<i>1345</i>&nbsp;                protected void read(Symbol sym, int attrLen) {
<i>1346</i>&nbsp;                    if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
<i>1347</i>&nbsp;                        ModuleSymbol msym = (ModuleSymbol) sym.owner;
<b class="nc"><i>1348</i>&nbsp;                        ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1349</i>&nbsp;</b>
<b class="nc"><i>1350</i>&nbsp;                        Name moduleName = readModuleName(nextChar());</b>
<b class="nc"><i>1351</i>&nbsp;                        if (currentModule.name != moduleName) {</b>
<b class="nc"><i>1352</i>&nbsp;                            throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);</b>
<b class="nc"><i>1353</i>&nbsp;                        }</b>
<b class="nc"><i>1354</i>&nbsp;</b>
<b class="nc"><i>1355</i>&nbsp;                        Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());</b>
<i>1356</i>&nbsp;                        msym.flags.addAll(moduleFlags);
<b class="nc"><i>1357</i>&nbsp;                        msym.version = readName(nextChar());</b>
<i>1358</i>&nbsp;
<i>1359</i>&nbsp;                        ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
<i>1360</i>&nbsp;                        int nrequires = nextChar();
<i>1361</i>&nbsp;                        for (int i = 0; i &lt; nrequires; i++) {
<i>1362</i>&nbsp;                            ModuleSymbol rsym = syms.enterModule(readModuleName(nextChar()));
<i>1363</i>&nbsp;                            Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
<i>1364</i>&nbsp;                            if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
<b class="nc"><i>1365</i>&nbsp;                                if (flags.contains(RequiresFlag.TRANSITIVE)) {</b>
<i>1366</i>&nbsp;                                    throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
<i>1367</i>&nbsp;                                }
<i>1368</i>&nbsp;                                if (flags.contains(RequiresFlag.STATIC_PHASE)) {
<i>1369</i>&nbsp;                                    throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
<i>1370</i>&nbsp;                                }
<b class="nc"><i>1371</i>&nbsp;                            }</b>
<i>1372</i>&nbsp;                            nextChar(); // skip compiled version
<i>1373</i>&nbsp;                            requires.add(new RequiresDirective(rsym, flags));
<i>1374</i>&nbsp;                        }
<b class="nc"><i>1375</i>&nbsp;                        msym.requires = requires.toList();</b>
<b class="nc"><i>1376</i>&nbsp;                        directives.addAll(msym.requires);</b>
<b class="nc"><i>1377</i>&nbsp;</b>
<b class="nc"><i>1378</i>&nbsp;                        ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1379</i>&nbsp;                        int nexports = nextChar();</b>
<b class="nc"><i>1380</i>&nbsp;                        for (int i = 0; i &lt; nexports; i++) {</b>
<b class="nc"><i>1381</i>&nbsp;                            Name n = readName(nextChar());</b>
<i>1382</i>&nbsp;                            PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));
<b class="nc"><i>1383</i>&nbsp;                            Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());</b>
<b class="nc"><i>1384</i>&nbsp;                            int nto = nextChar();</b>
<i>1385</i>&nbsp;                            List&lt;ModuleSymbol&gt; to;
<i>1386</i>&nbsp;                            if (nto == 0) {
<i>1387</i>&nbsp;                                to = null;
<i>1388</i>&nbsp;                            } else {
<b class="nc"><i>1389</i>&nbsp;                                ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1390</i>&nbsp;                                for (int t = 0; t &lt; nto; t++)</b>
<b class="nc"><i>1391</i>&nbsp;                                    lb.append(syms.enterModule(readModuleName(nextChar())));</b>
<i>1392</i>&nbsp;                                to = lb.toList();
<i>1393</i>&nbsp;                            }
<i>1394</i>&nbsp;                            exports.add(new ExportsDirective(p, to, flags));
<i>1395</i>&nbsp;                        }
<b class="nc"><i>1396</i>&nbsp;                        msym.exports = exports.toList();</b>
<i>1397</i>&nbsp;                        directives.addAll(msym.exports);
<i>1398</i>&nbsp;                        ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
<i>1399</i>&nbsp;                        int nopens = nextChar();
<i>1400</i>&nbsp;                        if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
<i>1401</i>&nbsp;                            throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
<b class="nc"><i>1402</i>&nbsp;                        }</b>
<b class="nc"><i>1403</i>&nbsp;                        for (int i = 0; i &lt; nopens; i++) {</b>
<b class="nc"><i>1404</i>&nbsp;                            Name n = readName(nextChar());</b>
<b class="nc"><i>1405</i>&nbsp;                            PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));</b>
<b class="nc"><i>1406</i>&nbsp;                            Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());</b>
<b class="nc"><i>1407</i>&nbsp;                            int nto = nextChar();</b>
<b class="nc"><i>1408</i>&nbsp;                            List&lt;ModuleSymbol&gt; to;</b>
<b class="nc"><i>1409</i>&nbsp;                            if (nto == 0) {</b>
<i>1410</i>&nbsp;                                to = null;
<i>1411</i>&nbsp;                            } else {
<i>1412</i>&nbsp;                                ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
<i>1413</i>&nbsp;                                for (int t = 0; t &lt; nto; t++)
<i>1414</i>&nbsp;                                    lb.append(syms.enterModule(readModuleName(nextChar())));
<i>1415</i>&nbsp;                                to = lb.toList();
<i>1416</i>&nbsp;                            }
<i>1417</i>&nbsp;                            opens.add(new OpensDirective(p, to, flags));
<i>1418</i>&nbsp;                        }
<b class="nc"><i>1419</i>&nbsp;                        msym.opens = opens.toList();</b>
<b class="nc"><i>1420</i>&nbsp;                        directives.addAll(msym.opens);</b>
<b class="nc"><i>1421</i>&nbsp;</b>
<i>1422</i>&nbsp;                        msym.directives = directives.toList();
<b class="nc"><i>1423</i>&nbsp;</b>
<b class="nc"><i>1424</i>&nbsp;                        ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1425</i>&nbsp;                        int nuses = nextChar();</b>
<b class="nc"><i>1426</i>&nbsp;                        for (int i = 0; i &lt; nuses; i++) {</b>
<b class="nc"><i>1427</i>&nbsp;                            Name srvc = readClassName(nextChar());</b>
<b class="nc"><i>1428</i>&nbsp;                            uses.add(new InterimUsesDirective(srvc));</b>
<b class="nc"><i>1429</i>&nbsp;                        }</b>
<b class="nc"><i>1430</i>&nbsp;                        interimUses = uses.toList();</b>
<b class="nc"><i>1431</i>&nbsp;</b>
<b class="nc"><i>1432</i>&nbsp;                        ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1433</i>&nbsp;                        int nprovides = nextChar();</b>
<i>1434</i>&nbsp;                        for (int p = 0; p &lt; nprovides; p++) {
<i>1435</i>&nbsp;                            Name srvc = readClassName(nextChar());
<b class="nc"><i>1436</i>&nbsp;                            int nimpls = nextChar();</b>
<i>1437</i>&nbsp;                            ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
<i>1438</i>&nbsp;                            for (int i = 0; i &lt; nimpls; i++) {
<b class="nc"><i>1439</i>&nbsp;                                impls.append(readClassName(nextChar()));</b>
<i>1440</i>&nbsp;                            provides.add(new InterimProvidesDirective(srvc, impls.toList()));
<b class="nc"><i>1441</i>&nbsp;                            }</b>
<i>1442</i>&nbsp;                        }
<i>1443</i>&nbsp;                        interimProvides = provides.toList();
<i>1444</i>&nbsp;                    }
<i>1445</i>&nbsp;                }
<i>1446</i>&nbsp;            },
<i>1447</i>&nbsp;
<b class="nc"><i>1448</i>&nbsp;            new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {</b>
<b class="nc"><i>1449</i>&nbsp;                @Override</b>
<b class="nc"><i>1450</i>&nbsp;                protected boolean accepts(AttributeKind kind) {</b>
<b class="nc"><i>1451</i>&nbsp;                    return super.accepts(kind) &amp;&amp; allowModules;</b>
<b class="nc"><i>1452</i>&nbsp;                }</b>
<b class="nc"><i>1453</i>&nbsp;                protected void read(Symbol sym, int attrLen) {</b>
<b class="nc"><i>1454</i>&nbsp;                    if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {</b>
<b class="nc"><i>1455</i>&nbsp;                        ModuleSymbol msym = (ModuleSymbol) sym.owner;</b>
<i>1456</i>&nbsp;                        msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
<b class="nc"><i>1457</i>&nbsp;                    }</b>
<b class="nc"><i>1458</i>&nbsp;                }</b>
<i>1459</i>&nbsp;            },
<i>1460</i>&nbsp;        };
<i>1461</i>&nbsp;
<i>1462</i>&nbsp;        for (AttributeReader r: readers)
<b class="nc"><i>1463</i>&nbsp;            attributeReaders.put(r.name, r);</b>
<b class="nc"><i>1464</i>&nbsp;    }</b>
<b class="nc"><i>1465</i>&nbsp;</b>
<b class="nc"><i>1466</i>&nbsp;    protected void readEnclosingMethodAttr(Symbol sym) {</b>
<b class="nc"><i>1467</i>&nbsp;        // sym is a nested class with an &quot;Enclosing Method&quot; attribute</b>
<b class="nc"><i>1468</i>&nbsp;        // remove sym from it&#39;s current owners scope and place it in</b>
<i>1469</i>&nbsp;        // the scope specified by the attribute
<i>1470</i>&nbsp;        sym.owner.members().remove(sym);
<i>1471</i>&nbsp;        ClassSymbol self = (ClassSymbol)sym;
<i>1472</i>&nbsp;        ClassSymbol c = readClassSymbol(nextChar());
<i>1473</i>&nbsp;        NameAndType nt = readNameAndType(nextChar());
<i>1474</i>&nbsp;
<b class="nc"><i>1475</i>&nbsp;        if (c.members_field == null || c.kind != TYP)</b>
<b class="nc"><i>1476</i>&nbsp;            throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);</b>
<i>1477</i>&nbsp;
<i>1478</i>&nbsp;        MethodSymbol m = findMethod(nt, c.members_field, self.flags());
<i>1479</i>&nbsp;        if (nt != null &amp;&amp; m == null)
<i>1480</i>&nbsp;            throw badEnclosingMethod(self);
<i>1481</i>&nbsp;
<i>1482</i>&nbsp;        self.name = simpleBinaryName(self.flatname, c.flatname) ;
<i>1483</i>&nbsp;        self.owner = m != null ? m : c;
<i>1484</i>&nbsp;        if (self.name.isEmpty())
<i>1485</i>&nbsp;            self.fullname = names.empty;
<b class="nc"><i>1486</i>&nbsp;        else</b>
<b class="nc"><i>1487</i>&nbsp;            self.fullname = ClassSymbol.formFullName(self.name, self.owner);</b>
<i>1488</i>&nbsp;
<i>1489</i>&nbsp;        if (m != null) {
<i>1490</i>&nbsp;            ((ClassType)sym.type).setEnclosingType(m.type);
<i>1491</i>&nbsp;        } else if ((self.flags_field &amp; STATIC) == 0) {
<b class="nc"><i>1492</i>&nbsp;            ((ClassType)sym.type).setEnclosingType(c.type);</b>
<b class="nc"><i>1493</i>&nbsp;        } else {</b>
<b class="nc"><i>1494</i>&nbsp;            ((ClassType)sym.type).setEnclosingType(Type.noType);</b>
<i>1495</i>&nbsp;        }
<i>1496</i>&nbsp;        enterTypevars(self, self.type);
<i>1497</i>&nbsp;        if (!missingTypeVariables.isEmpty()) {
<b class="nc"><i>1498</i>&nbsp;            ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1499</i>&nbsp;            for (Type typevar : missingTypeVariables) {</b>
<b class="nc"><i>1500</i>&nbsp;                typeVars.append(findTypeVar(typevar.tsym.name));</b>
<b class="nc"><i>1501</i>&nbsp;            }</b>
<b class="nc"><i>1502</i>&nbsp;            foundTypeVariables = typeVars.toList();</b>
<i>1503</i>&nbsp;        } else {
<i>1504</i>&nbsp;            foundTypeVariables = List.nil();
<i>1505</i>&nbsp;        }
<b class="nc"><i>1506</i>&nbsp;    }</b>
<b class="nc"><i>1507</i>&nbsp;</b>
<b class="nc"><i>1508</i>&nbsp;    // See java.lang.Class</b>
<i>1509</i>&nbsp;    private Name simpleBinaryName(Name self, Name enclosing) {
<b class="nc"><i>1510</i>&nbsp;        String simpleBinaryName = self.toString().substring(enclosing.toString().length());</b>
<b class="nc"><i>1511</i>&nbsp;        if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)</b>
<b class="nc"><i>1512</i>&nbsp;            throw badClassFile(&quot;bad.enclosing.method&quot;, self);</b>
<b class="nc"><i>1513</i>&nbsp;        int index = 1;</b>
<i>1514</i>&nbsp;        while (index &lt; simpleBinaryName.length() &amp;&amp;
<b class="nc"><i>1515</i>&nbsp;               isAsciiDigit(simpleBinaryName.charAt(index)))</b>
<i>1516</i>&nbsp;            index++;
<i>1517</i>&nbsp;        return names.fromString(simpleBinaryName.substring(index));
<i>1518</i>&nbsp;    }
<b class="nc"><i>1519</i>&nbsp;</b>
<b class="nc"><i>1520</i>&nbsp;    private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {</b>
<i>1521</i>&nbsp;        if (nt == null)
<b class="nc"><i>1522</i>&nbsp;            return null;</b>
<i>1523</i>&nbsp;
<i>1524</i>&nbsp;        MethodType type = nt.uniqueType.type.asMethodType();
<i>1525</i>&nbsp;
<b class="nc"><i>1526</i>&nbsp;        for (Symbol sym : scope.getSymbolsByName(nt.name)) {</b>
<i>1527</i>&nbsp;            if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
<b class="nc"><i>1528</i>&nbsp;                return (MethodSymbol)sym;</b>
<b class="nc"><i>1529</i>&nbsp;        }</b>
<i>1530</i>&nbsp;
<b class="nc"><i>1531</i>&nbsp;        if (nt.name != names.init)</b>
<b class="nc"><i>1532</i>&nbsp;            // not a constructor</b>
<i>1533</i>&nbsp;            return null;
<b class="nc"><i>1534</i>&nbsp;        if ((flags &amp; INTERFACE) != 0)</b>
<i>1535</i>&nbsp;            // no enclosing instance
<b class="nc"><i>1536</i>&nbsp;            return null;</b>
<i>1537</i>&nbsp;        if (nt.uniqueType.type.getParameterTypes().isEmpty())
<i>1538</i>&nbsp;            // no parameters
<i>1539</i>&nbsp;            return null;
<i>1540</i>&nbsp;
<i>1541</i>&nbsp;        // A constructor of an inner class.
<i>1542</i>&nbsp;        // Remove the first argument (the enclosing instance)
<i>1543</i>&nbsp;        nt.setType(new MethodType(nt.uniqueType.type.getParameterTypes().tail,
<b class="nc"><i>1544</i>&nbsp;                                 nt.uniqueType.type.getReturnType(),</b>
<b class="nc"><i>1545</i>&nbsp;                                 nt.uniqueType.type.getThrownTypes(),</b>
<i>1546</i>&nbsp;                                 syms.methodClass));
<i>1547</i>&nbsp;        // Try searching again
<i>1548</i>&nbsp;        return findMethod(nt, scope, flags);
<i>1549</i>&nbsp;    }
<b class="nc"><i>1550</i>&nbsp;</b>
<b class="nc"><i>1551</i>&nbsp;    /** Similar to Types.isSameType but avoids completion */</b>
<b class="nc"><i>1552</i>&nbsp;    private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {</b>
<b class="nc"><i>1553</i>&nbsp;        List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())</b>
<i>1554</i>&nbsp;            .prepend(types.erasure(mt1.getReturnType()));
<b class="nc"><i>1555</i>&nbsp;        List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());</b>
<b class="nc"><i>1556</i>&nbsp;        while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {</b>
<b class="nc"><i>1557</i>&nbsp;            if (types1.head.tsym != types2.head.tsym)</b>
<b class="nc"><i>1558</i>&nbsp;                return false;</b>
<i>1559</i>&nbsp;            types1 = types1.tail;
<b class="nc"><i>1560</i>&nbsp;            types2 = types2.tail;</b>
<i>1561</i>&nbsp;        }
<i>1562</i>&nbsp;        return types1.isEmpty() &amp;&amp; types2.isEmpty();
<b class="nc"><i>1563</i>&nbsp;    }</b>
<b class="nc"><i>1564</i>&nbsp;</b>
<i>1565</i>&nbsp;    /**
<i>1566</i>&nbsp;     * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
<i>1567</i>&nbsp;     * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
<b class="nc"><i>1568</i>&nbsp;     */</b>
<i>1569</i>&nbsp;    private static boolean isAsciiDigit(char c) {
<i>1570</i>&nbsp;        return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
<i>1571</i>&nbsp;    }
<b class="nc"><i>1572</i>&nbsp;</b>
<b class="nc"><i>1573</i>&nbsp;    /** Read member attributes.</b>
<i>1574</i>&nbsp;     */
<i>1575</i>&nbsp;    void readMemberAttrs(Symbol sym) {
<i>1576</i>&nbsp;        readAttrs(sym, AttributeKind.MEMBER);
<b class="nc"><i>1577</i>&nbsp;    }</b>
<b class="nc"><i>1578</i>&nbsp;</b>
<b class="nc"><i>1579</i>&nbsp;    void readAttrs(Symbol sym, AttributeKind kind) {</b>
<i>1580</i>&nbsp;        char ac = nextChar();
<i>1581</i>&nbsp;        for (int i = 0; i &lt; ac; i++) {
<b class="nc"><i>1582</i>&nbsp;            Name attrName = readName(nextChar());</b>
<b class="nc"><i>1583</i>&nbsp;            int attrLen = nextInt();</b>
<i>1584</i>&nbsp;            AttributeReader r = attributeReaders.get(attrName);
<i>1585</i>&nbsp;            if (r != null &amp;&amp; r.accepts(kind))
<b class="nc"><i>1586</i>&nbsp;                r.read(sym, attrLen);</b>
<b class="nc"><i>1587</i>&nbsp;            else  {</b>
<i>1588</i>&nbsp;                bp = bp + attrLen;
<i>1589</i>&nbsp;            }
<b class="nc"><i>1590</i>&nbsp;        }</b>
<b class="nc"><i>1591</i>&nbsp;    }</b>
<i>1592</i>&nbsp;
<i>1593</i>&nbsp;    private boolean readingClassAttr = false;
<i>1594</i>&nbsp;    private List&lt;Type&gt; missingTypeVariables = List.nil();
<i>1595</i>&nbsp;    private List&lt;Type&gt; foundTypeVariables = List.nil();
<i>1596</i>&nbsp;
<i>1597</i>&nbsp;    /** Read class attributes.
<i>1598</i>&nbsp;     */
<b class="nc"><i>1599</i>&nbsp;    void readClassAttrs(ClassSymbol c) {</b>
<b class="nc"><i>1600</i>&nbsp;        readAttrs(c, AttributeKind.CLASS);</b>
<b class="nc"><i>1601</i>&nbsp;    }</b>
<i>1602</i>&nbsp;
<i>1603</i>&nbsp;    /** Read code block.
<i>1604</i>&nbsp;     */
<b class="nc"><i>1605</i>&nbsp;    Code readCode(Symbol owner) {</b>
<i>1606</i>&nbsp;        nextChar(); // max_stack
<b class="nc"><i>1607</i>&nbsp;        nextChar(); // max_locals</b>
<i>1608</i>&nbsp;        final int  code_length = nextInt();
<b class="nc"><i>1609</i>&nbsp;        bp += code_length;</b>
<i>1610</i>&nbsp;        final char exception_table_length = nextChar();
<i>1611</i>&nbsp;        bp += exception_table_length * 8;
<i>1612</i>&nbsp;        readMemberAttrs(owner);
<b class="nc"><i>1613</i>&nbsp;        return null;</b>
<b class="nc"><i>1614</i>&nbsp;    }</b>
<b class="nc"><i>1615</i>&nbsp;</b>
<b class="nc"><i>1616</i>&nbsp;/************************************************************************</b>
<b class="nc"><i>1617</i>&nbsp; * Reading Java-language annotations</b>
<i>1618</i>&nbsp; ***********************************************************************/
<i>1619</i>&nbsp;
<b class="nc"><i>1620</i>&nbsp;    /**</b>
<i>1621</i>&nbsp;     * Save annotations.
<i>1622</i>&nbsp;     */
<i>1623</i>&nbsp;    List&lt;CompoundAnnotationProxy&gt; readAnnotations() {
<b class="nc"><i>1624</i>&nbsp;        int numAttributes = nextChar();</b>
<b class="nc"><i>1625</i>&nbsp;        ListBuffer&lt;CompoundAnnotationProxy&gt; annotations = new ListBuffer&lt;&gt;();</b>
<i>1626</i>&nbsp;        for (int i = 0; i &lt; numAttributes; i++) {
<b class="nc"><i>1627</i>&nbsp;            annotations.append(readCompoundAnnotation());</b>
<i>1628</i>&nbsp;        }
<b class="nc"><i>1629</i>&nbsp;        return annotations.toList();</b>
<i>1630</i>&nbsp;    }
<b class="nc"><i>1631</i>&nbsp;</b>
<i>1632</i>&nbsp;    /** Attach annotations.
<b class="nc"><i>1633</i>&nbsp;     */</b>
<i>1634</i>&nbsp;    void attachAnnotations(final Symbol sym) {
<b class="nc"><i>1635</i>&nbsp;        attachAnnotations(sym, readAnnotations());</b>
<i>1636</i>&nbsp;    }
<b class="nc"><i>1637</i>&nbsp;</b>
<i>1638</i>&nbsp;    /**
<b class="nc"><i>1639</i>&nbsp;     * Attach annotations.</b>
<i>1640</i>&nbsp;     */
<b class="nc"><i>1641</i>&nbsp;    void attachAnnotations(final Symbol sym, List&lt;CompoundAnnotationProxy&gt; annotations) {</b>
<i>1642</i>&nbsp;        if (annotations.isEmpty()) {
<b class="nc"><i>1643</i>&nbsp;            return;</b>
<i>1644</i>&nbsp;        }
<b class="nc"><i>1645</i>&nbsp;        ListBuffer&lt;CompoundAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();</b>
<i>1646</i>&nbsp;        for (CompoundAnnotationProxy proxy : annotations) {
<b class="nc"><i>1647</i>&nbsp;            if (proxy.type.tsym == syms.proprietaryType.tsym)</b>
<i>1648</i>&nbsp;                sym.flags_field |= PROPRIETARY;
<b class="nc"><i>1649</i>&nbsp;            else if (proxy.type.tsym == syms.profileType.tsym) {</b>
<b class="nc"><i>1650</i>&nbsp;                if (profile != Profile.DEFAULT) {</b>
<b class="nc"><i>1651</i>&nbsp;                    for (Pair&lt;Name, Attribute&gt; v : proxy.values) {</b>
<b class="nc"><i>1652</i>&nbsp;                        if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {</b>
<b class="nc"><i>1653</i>&nbsp;                            Attribute.Constant c = (Attribute.Constant)v.snd;</b>
<i>1654</i>&nbsp;                            if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
<i>1655</i>&nbsp;                                sym.flags_field |= NOT_IN_PROFILE;
<b class="nc"><i>1656</i>&nbsp;                            }</b>
<i>1657</i>&nbsp;                        }
<b class="nc"><i>1658</i>&nbsp;                    }</b>
<i>1659</i>&nbsp;                }
<i>1660</i>&nbsp;            } else {
<i>1661</i>&nbsp;                if (proxy.type.tsym == syms.annotationTargetType.tsym) {
<i>1662</i>&nbsp;                    target = proxy;
<i>1663</i>&nbsp;                } else if (proxy.type.tsym == syms.repeatableType.tsym) {
<i>1664</i>&nbsp;                    repeatable = proxy;
<i>1665</i>&nbsp;                } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
<i>1666</i>&nbsp;                    sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
<i>1667</i>&nbsp;                    for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
<i>1668</i>&nbsp;                        if (v.fst == names.forRemoval &amp;&amp; v.snd instanceof Attribute.Constant) {
<i>1669</i>&nbsp;                            Attribute.Constant c = (Attribute.Constant)v.snd;
<i>1670</i>&nbsp;                            if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {
<i>1671</i>&nbsp;                                sym.flags_field |= DEPRECATED_REMOVAL;
<b class="nc"><i>1672</i>&nbsp;                            }</b>
<b class="nc"><i>1673</i>&nbsp;                        }</b>
<b class="nc"><i>1674</i>&nbsp;                    }</b>
<i>1675</i>&nbsp;                }
<b class="nc"><i>1676</i>&nbsp;                proxies.append(proxy);</b>
<i>1677</i>&nbsp;            }
<i>1678</i>&nbsp;        }
<b class="nc"><i>1679</i>&nbsp;        annotate.normal(new AnnotationCompleter(sym, proxies.toList()));</b>
<i>1680</i>&nbsp;    }
<i>1681</i>&nbsp;
<i>1682</i>&nbsp;    /** Read parameter annotations.
<i>1683</i>&nbsp;     */
<i>1684</i>&nbsp;    void readParameterAnnotations(Symbol meth) {
<i>1685</i>&nbsp;        int numParameters = buf[bp++] &amp; 0xFF;
<b class="nc"><i>1686</i>&nbsp;        if (parameterAnnotations == null) {</b>
<b class="nc"><i>1687</i>&nbsp;            parameterAnnotations = new ParameterAnnotations[numParameters];</b>
<i>1688</i>&nbsp;        } else if (parameterAnnotations.length != numParameters) {
<b class="nc"><i>1689</i>&nbsp;            throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);</b>
<i>1690</i>&nbsp;        }
<i>1691</i>&nbsp;        for (int pnum = 0; pnum &lt; numParameters; pnum++) {
<b class="nc"><i>1692</i>&nbsp;            if (parameterAnnotations[pnum] == null) {</b>
<i>1693</i>&nbsp;                parameterAnnotations[pnum] = new ParameterAnnotations();
<i>1694</i>&nbsp;            }
<i>1695</i>&nbsp;            parameterAnnotations[pnum].add(readAnnotations());
<i>1696</i>&nbsp;        }
<i>1697</i>&nbsp;    }
<i>1698</i>&nbsp;
<i>1699</i>&nbsp;    void attachTypeAnnotations(final Symbol sym) {
<i>1700</i>&nbsp;        int numAttributes = nextChar();
<i>1701</i>&nbsp;        if (numAttributes != 0) {
<b class="nc"><i>1702</i>&nbsp;            ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1703</i>&nbsp;            for (int i = 0; i &lt; numAttributes; i++)</b>
<i>1704</i>&nbsp;                proxies.append(readTypeAnnotation());
<b class="nc"><i>1705</i>&nbsp;            annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));</b>
<i>1706</i>&nbsp;        }
<i>1707</i>&nbsp;    }
<b class="nc"><i>1708</i>&nbsp;</b>
<b class="nc"><i>1709</i>&nbsp;    /** Attach the default value for an annotation element.</b>
<b class="nc"><i>1710</i>&nbsp;     */</b>
<b class="nc"><i>1711</i>&nbsp;    void attachAnnotationDefault(final Symbol sym) {</b>
<b class="nc"><i>1712</i>&nbsp;        final MethodSymbol meth = (MethodSymbol)sym; // only on methods</b>
<b class="nc"><i>1713</i>&nbsp;        final Attribute value = readAttributeValue();</b>
<b class="nc"><i>1714</i>&nbsp;</b>
<b class="nc"><i>1715</i>&nbsp;        // The default value is set later during annotation. It might</b>
<b class="nc"><i>1716</i>&nbsp;        // be the case that the Symbol sym is annotated _after_ the</b>
<b class="nc"><i>1717</i>&nbsp;        // repeating instances that depend on this default value,</b>
<b class="nc"><i>1718</i>&nbsp;        // because of this we set an interim value that tells us this</b>
<b class="nc"><i>1719</i>&nbsp;        // element (most likely) has a default.</b>
<b class="nc"><i>1720</i>&nbsp;        //</b>
<i>1721</i>&nbsp;        // Set interim value for now, reset just before we do this
<b class="nc"><i>1722</i>&nbsp;        // properly at annotate time.</b>
<b class="nc"><i>1723</i>&nbsp;        meth.defaultValue = value;</b>
<i>1724</i>&nbsp;        annotate.normal(new AnnotationDefaultCompleter(meth, value));
<i>1725</i>&nbsp;    }
<i>1726</i>&nbsp;
<i>1727</i>&nbsp;    Type readTypeOrClassSymbol(int i) {
<i>1728</i>&nbsp;        // support preliminary jsr175-format class files
<i>1729</i>&nbsp;        if (buf[poolIdx[i]] == CONSTANT_Class)
<i>1730</i>&nbsp;            return readClassSymbol(i).type;
<i>1731</i>&nbsp;        return readTypeToProxy(i);
<i>1732</i>&nbsp;    }
<b class="nc"><i>1733</i>&nbsp;    Type readEnumType(int i) {</b>
<b class="nc"><i>1734</i>&nbsp;        // support preliminary jsr175-format class files</b>
<b class="nc"><i>1735</i>&nbsp;        int index = poolIdx[i];</b>
<i>1736</i>&nbsp;        int length = getChar(index + 1);
<i>1737</i>&nbsp;        if (buf[index + length + 2] != &#39;;&#39;)
<i>1738</i>&nbsp;            return enterClass(readName(i)).type;
<b class="nc"><i>1739</i>&nbsp;        return readTypeToProxy(i);</b>
<i>1740</i>&nbsp;    }
<b class="nc"><i>1741</i>&nbsp;    Type readTypeToProxy(int i) {</b>
<i>1742</i>&nbsp;        if (currentModule.module_info == currentOwner) {
<i>1743</i>&nbsp;            int index = poolIdx[i];
<i>1744</i>&nbsp;            return new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));
<b class="nc"><i>1745</i>&nbsp;        } else {</b>
<i>1746</i>&nbsp;            return readType(i);
<b class="nc"><i>1747</i>&nbsp;        }</b>
<b class="nc"><i>1748</i>&nbsp;    }</b>
<i>1749</i>&nbsp;
<b class="nc"><i>1750</i>&nbsp;    CompoundAnnotationProxy readCompoundAnnotation() {</b>
<i>1751</i>&nbsp;        Type t;
<i>1752</i>&nbsp;        if (currentModule.module_info == currentOwner) {
<i>1753</i>&nbsp;            int index = poolIdx[nextChar()];
<b class="nc"><i>1754</i>&nbsp;            t = new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));</b>
<i>1755</i>&nbsp;        } else {
<b class="nc"><i>1756</i>&nbsp;            t = readTypeOrClassSymbol(nextChar());</b>
<b class="nc"><i>1757</i>&nbsp;        }</b>
<b class="nc"><i>1758</i>&nbsp;        int numFields = nextChar();</b>
<b class="nc"><i>1759</i>&nbsp;        ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1760</i>&nbsp;        for (int i=0; i&lt;numFields; i++) {</b>
<b class="nc"><i>1761</i>&nbsp;            Name name = readName(nextChar());</b>
<i>1762</i>&nbsp;            Attribute value = readAttributeValue();
<b class="nc"><i>1763</i>&nbsp;            pairs.append(new Pair&lt;&gt;(name, value));</b>
<i>1764</i>&nbsp;        }
<i>1765</i>&nbsp;        return new CompoundAnnotationProxy(t, pairs.toList());
<i>1766</i>&nbsp;    }
<b class="nc"><i>1767</i>&nbsp;</b>
<i>1768</i>&nbsp;    TypeAnnotationProxy readTypeAnnotation() {
<b class="nc"><i>1769</i>&nbsp;        TypeAnnotationPosition position = readPosition();</b>
<b class="nc"><i>1770</i>&nbsp;        CompoundAnnotationProxy proxy = readCompoundAnnotation();</b>
<b class="nc"><i>1771</i>&nbsp;</b>
<b class="nc"><i>1772</i>&nbsp;        return new TypeAnnotationProxy(proxy, position);</b>
<b class="nc"><i>1773</i>&nbsp;    }</b>
<b class="nc"><i>1774</i>&nbsp;</b>
<i>1775</i>&nbsp;    TypeAnnotationPosition readPosition() {
<b class="nc"><i>1776</i>&nbsp;        int tag = nextByte(); // TargetType tag is a byte</b>
<b class="nc"><i>1777</i>&nbsp;</b>
<b class="nc"><i>1778</i>&nbsp;        if (!TargetType.isValidTargetTypeValue(tag))</b>
<i>1779</i>&nbsp;            throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
<b class="nc"><i>1780</i>&nbsp;</b>
<i>1781</i>&nbsp;        TargetType type = TargetType.fromTargetTypeValue(tag);
<b class="nc"><i>1782</i>&nbsp;</b>
<b class="nc"><i>1783</i>&nbsp;        switch (type) {</b>
<b class="nc"><i>1784</i>&nbsp;        // instanceof</b>
<i>1785</i>&nbsp;        case INSTANCEOF: {
<i>1786</i>&nbsp;            final int offset = nextChar();
<i>1787</i>&nbsp;            final TypeAnnotationPosition position =
<b class="nc"><i>1788</i>&nbsp;                TypeAnnotationPosition.instanceOf(readTypePath());</b>
<i>1789</i>&nbsp;            position.offset = offset;
<i>1790</i>&nbsp;            return position;
<b class="nc"><i>1791</i>&nbsp;        }</b>
<i>1792</i>&nbsp;        // new expression
<i>1793</i>&nbsp;        case NEW: {
<i>1794</i>&nbsp;            final int offset = nextChar();
<b class="nc"><i>1795</i>&nbsp;            final TypeAnnotationPosition position =</b>
<b class="nc"><i>1796</i>&nbsp;                TypeAnnotationPosition.newObj(readTypePath());</b>
<i>1797</i>&nbsp;            position.offset = offset;
<i>1798</i>&nbsp;            return position;
<i>1799</i>&nbsp;        }
<i>1800</i>&nbsp;        // constructor/method reference receiver
<b class="nc"><i>1801</i>&nbsp;        case CONSTRUCTOR_REFERENCE: {</b>
<i>1802</i>&nbsp;            final int offset = nextChar();
<b class="nc"><i>1803</i>&nbsp;            final TypeAnnotationPosition position =</b>
<i>1804</i>&nbsp;                TypeAnnotationPosition.constructorRef(readTypePath());
<b class="nc"><i>1805</i>&nbsp;            position.offset = offset;</b>
<i>1806</i>&nbsp;            return position;
<i>1807</i>&nbsp;        }
<i>1808</i>&nbsp;        case METHOD_REFERENCE: {
<i>1809</i>&nbsp;            final int offset = nextChar();
<i>1810</i>&nbsp;            final TypeAnnotationPosition position =
<b class="nc"><i>1811</i>&nbsp;                TypeAnnotationPosition.methodRef(readTypePath());</b>
<i>1812</i>&nbsp;            position.offset = offset;
<b class="nc"><i>1813</i>&nbsp;            return position;</b>
<b class="nc"><i>1814</i>&nbsp;        }</b>
<b class="nc"><i>1815</i>&nbsp;        // local variable</b>
<i>1816</i>&nbsp;        case LOCAL_VARIABLE: {
<b class="nc"><i>1817</i>&nbsp;            final int table_length = nextChar();</b>
<i>1818</i>&nbsp;            final int[] newLvarOffset = new int[table_length];
<i>1819</i>&nbsp;            final int[] newLvarLength = new int[table_length];
<i>1820</i>&nbsp;            final int[] newLvarIndex = new int[table_length];
<i>1821</i>&nbsp;
<i>1822</i>&nbsp;            for (int i = 0; i &lt; table_length; ++i) {
<i>1823</i>&nbsp;                newLvarOffset[i] = nextChar();
<i>1824</i>&nbsp;                newLvarLength[i] = nextChar();
<b class="nc"><i>1825</i>&nbsp;                newLvarIndex[i] = nextChar();</b>
<i>1826</i>&nbsp;            }
<i>1827</i>&nbsp;
<i>1828</i>&nbsp;            final TypeAnnotationPosition position =
<b class="nc"><i>1829</i>&nbsp;                    TypeAnnotationPosition.localVariable(readTypePath());</b>
<i>1830</i>&nbsp;            position.lvarOffset = newLvarOffset;
<i>1831</i>&nbsp;            position.lvarLength = newLvarLength;
<i>1832</i>&nbsp;            position.lvarIndex = newLvarIndex;
<b class="nc"><i>1833</i>&nbsp;            return position;</b>
<i>1834</i>&nbsp;        }
<i>1835</i>&nbsp;        // resource variable
<i>1836</i>&nbsp;        case RESOURCE_VARIABLE: {
<b class="nc"><i>1837</i>&nbsp;            final int table_length = nextChar();</b>
<i>1838</i>&nbsp;            final int[] newLvarOffset = new int[table_length];
<i>1839</i>&nbsp;            final int[] newLvarLength = new int[table_length];
<i>1840</i>&nbsp;            final int[] newLvarIndex = new int[table_length];
<b class="nc"><i>1841</i>&nbsp;</b>
<i>1842</i>&nbsp;            for (int i = 0; i &lt; table_length; ++i) {
<i>1843</i>&nbsp;                newLvarOffset[i] = nextChar();
<i>1844</i>&nbsp;                newLvarLength[i] = nextChar();
<b class="nc"><i>1845</i>&nbsp;                newLvarIndex[i] = nextChar();</b>
<i>1846</i>&nbsp;            }
<i>1847</i>&nbsp;
<i>1848</i>&nbsp;            final TypeAnnotationPosition position =
<i>1849</i>&nbsp;                    TypeAnnotationPosition.resourceVariable(readTypePath());
<b class="nc"><i>1850</i>&nbsp;            position.lvarOffset = newLvarOffset;</b>
<b class="nc"><i>1851</i>&nbsp;            position.lvarLength = newLvarLength;</b>
<b class="nc"><i>1852</i>&nbsp;            position.lvarIndex = newLvarIndex;</b>
<i>1853</i>&nbsp;            return position;
<b class="nc"><i>1854</i>&nbsp;        }</b>
<b class="nc"><i>1855</i>&nbsp;        // exception parameter</b>
<b class="nc"><i>1856</i>&nbsp;        case EXCEPTION_PARAMETER: {</b>
<b class="nc"><i>1857</i>&nbsp;            final int exception_index = nextChar();</b>
<b class="nc"><i>1858</i>&nbsp;            final TypeAnnotationPosition position =</b>
<b class="nc"><i>1859</i>&nbsp;                TypeAnnotationPosition.exceptionParameter(readTypePath());</b>
<i>1860</i>&nbsp;            position.setExceptionIndex(exception_index);
<i>1861</i>&nbsp;            return position;
<i>1862</i>&nbsp;        }
<b class="nc"><i>1863</i>&nbsp;        // method receiver</b>
<b class="nc"><i>1864</i>&nbsp;        case METHOD_RECEIVER:</b>
<b class="nc"><i>1865</i>&nbsp;            return TypeAnnotationPosition.methodReceiver(readTypePath());</b>
<b class="nc"><i>1866</i>&nbsp;        // type parameter</b>
<b class="nc"><i>1867</i>&nbsp;        case CLASS_TYPE_PARAMETER: {</b>
<b class="nc"><i>1868</i>&nbsp;            final int parameter_index = nextByte();</b>
<i>1869</i>&nbsp;            return TypeAnnotationPosition
<b class="nc"><i>1870</i>&nbsp;                .typeParameter(readTypePath(), parameter_index);</b>
<i>1871</i>&nbsp;        }
<b class="nc"><i>1872</i>&nbsp;        case METHOD_TYPE_PARAMETER: {</b>
<i>1873</i>&nbsp;            final int parameter_index = nextByte();
<i>1874</i>&nbsp;            return TypeAnnotationPosition
<b class="nc"><i>1875</i>&nbsp;                .methodTypeParameter(readTypePath(), parameter_index);</b>
<i>1876</i>&nbsp;        }
<i>1877</i>&nbsp;        // type parameter bound
<b class="nc"><i>1878</i>&nbsp;        case CLASS_TYPE_PARAMETER_BOUND: {</b>
<i>1879</i>&nbsp;            final int parameter_index = nextByte();
<i>1880</i>&nbsp;            final int bound_index = nextByte();
<i>1881</i>&nbsp;            return TypeAnnotationPosition
<i>1882</i>&nbsp;                .typeParameterBound(readTypePath(), parameter_index,
<b class="nc"><i>1883</i>&nbsp;                                    bound_index);</b>
<b class="nc"><i>1884</i>&nbsp;        }</b>
<b class="nc"><i>1885</i>&nbsp;        case METHOD_TYPE_PARAMETER_BOUND: {</b>
<b class="nc"><i>1886</i>&nbsp;            final int parameter_index = nextByte();</b>
<b class="nc"><i>1887</i>&nbsp;            final int bound_index = nextByte();</b>
<b class="nc"><i>1888</i>&nbsp;            return TypeAnnotationPosition</b>
<i>1889</i>&nbsp;                .methodTypeParameterBound(readTypePath(), parameter_index,
<b class="nc"><i>1890</i>&nbsp;                                          bound_index);</b>
<i>1891</i>&nbsp;        }
<i>1892</i>&nbsp;        // class extends or implements clause
<i>1893</i>&nbsp;        case CLASS_EXTENDS: {
<b class="nc"><i>1894</i>&nbsp;            final int type_index = nextChar();</b>
<i>1895</i>&nbsp;            return TypeAnnotationPosition.classExtends(readTypePath(),
<i>1896</i>&nbsp;                                                       type_index);
<i>1897</i>&nbsp;        }
<i>1898</i>&nbsp;        // throws
<i>1899</i>&nbsp;        case THROWS: {
<i>1900</i>&nbsp;            final int type_index = nextChar();
<b class="nc"><i>1901</i>&nbsp;            return TypeAnnotationPosition.methodThrows(readTypePath(),</b>
<i>1902</i>&nbsp;                                                       type_index);
<i>1903</i>&nbsp;        }
<b class="nc"><i>1904</i>&nbsp;        // method parameter</b>
<i>1905</i>&nbsp;        case METHOD_FORMAL_PARAMETER: {
<b class="nc"><i>1906</i>&nbsp;            final int parameter_index = nextByte();</b>
<b class="nc"><i>1907</i>&nbsp;            return TypeAnnotationPosition.methodParameter(readTypePath(),</b>
<b class="nc"><i>1908</i>&nbsp;                                                          parameter_index);</b>
<i>1909</i>&nbsp;        }
<i>1910</i>&nbsp;        // type cast
<i>1911</i>&nbsp;        case CAST: {
<b class="nc"><i>1912</i>&nbsp;            final int offset = nextChar();</b>
<i>1913</i>&nbsp;            final int type_index = nextByte();
<i>1914</i>&nbsp;            final TypeAnnotationPosition position =
<i>1915</i>&nbsp;                TypeAnnotationPosition.typeCast(readTypePath(), type_index);
<b class="nc"><i>1916</i>&nbsp;            position.offset = offset;</b>
<b class="nc"><i>1917</i>&nbsp;            return position;</b>
<b class="nc"><i>1918</i>&nbsp;        }</b>
<i>1919</i>&nbsp;        // method/constructor/reference type argument
<b class="nc"><i>1920</i>&nbsp;        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT: {</b>
<b class="nc"><i>1921</i>&nbsp;            final int offset = nextChar();</b>
<i>1922</i>&nbsp;            final int type_index = nextByte();
<i>1923</i>&nbsp;            final TypeAnnotationPosition position = TypeAnnotationPosition
<i>1924</i>&nbsp;                .constructorInvocationTypeArg(readTypePath(), type_index);
<i>1925</i>&nbsp;            position.offset = offset;
<i>1926</i>&nbsp;            return position;
<i>1927</i>&nbsp;        }
<i>1928</i>&nbsp;        case METHOD_INVOCATION_TYPE_ARGUMENT: {
<i>1929</i>&nbsp;            final int offset = nextChar();
<i>1930</i>&nbsp;            final int type_index = nextByte();
<b class="nc"><i>1931</i>&nbsp;            final TypeAnnotationPosition position = TypeAnnotationPosition</b>
<i>1932</i>&nbsp;                .methodInvocationTypeArg(readTypePath(), type_index);
<b class="nc"><i>1933</i>&nbsp;            position.offset = offset;</b>
<b class="nc"><i>1934</i>&nbsp;            return position;</b>
<b class="nc"><i>1935</i>&nbsp;        }</b>
<b class="nc"><i>1936</i>&nbsp;        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT: {</b>
<i>1937</i>&nbsp;            final int offset = nextChar();
<i>1938</i>&nbsp;            final int type_index = nextByte();
<i>1939</i>&nbsp;            final TypeAnnotationPosition position = TypeAnnotationPosition
<b class="nc"><i>1940</i>&nbsp;                .constructorRefTypeArg(readTypePath(), type_index);</b>
<i>1941</i>&nbsp;            position.offset = offset;
<b class="nc"><i>1942</i>&nbsp;            return position;</b>
<b class="nc"><i>1943</i>&nbsp;        }</b>
<b class="nc"><i>1944</i>&nbsp;        case METHOD_REFERENCE_TYPE_ARGUMENT: {</b>
<b class="nc"><i>1945</i>&nbsp;            final int offset = nextChar();</b>
<i>1946</i>&nbsp;            final int type_index = nextByte();
<b class="nc"><i>1947</i>&nbsp;            final TypeAnnotationPosition position = TypeAnnotationPosition</b>
<i>1948</i>&nbsp;                .methodRefTypeArg(readTypePath(), type_index);
<i>1949</i>&nbsp;            position.offset = offset;
<b class="nc"><i>1950</i>&nbsp;            return position;</b>
<b class="nc"><i>1951</i>&nbsp;        }</b>
<i>1952</i>&nbsp;        // We don&#39;t need to worry about these
<i>1953</i>&nbsp;        case METHOD_RETURN:
<i>1954</i>&nbsp;            return TypeAnnotationPosition.methodReturn(readTypePath());
<i>1955</i>&nbsp;        case FIELD:
<i>1956</i>&nbsp;            return TypeAnnotationPosition.field(readTypePath());
<i>1957</i>&nbsp;        case UNKNOWN:
<i>1958</i>&nbsp;            throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
<i>1959</i>&nbsp;        default:
<b class="nc"><i>1960</i>&nbsp;            throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);</b>
<b class="nc"><i>1961</i>&nbsp;        }</b>
<b class="nc"><i>1962</i>&nbsp;    }</b>
<i>1963</i>&nbsp;
<i>1964</i>&nbsp;    List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
<i>1965</i>&nbsp;        int len = nextByte();
<b class="nc"><i>1966</i>&nbsp;        ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>1967</i>&nbsp;        for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)</b>
<b class="nc"><i>1968</i>&nbsp;            loc = loc.append(nextByte());</b>
<b class="nc"><i>1969</i>&nbsp;</b>
<b class="nc"><i>1970</i>&nbsp;        return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());</b>
<b class="nc"><i>1971</i>&nbsp;</b>
<b class="nc"><i>1972</i>&nbsp;    }</b>
<i>1973</i>&nbsp;
<i>1974</i>&nbsp;    Attribute readAttributeValue() {
<i>1975</i>&nbsp;        char c = (char) buf[bp++];
<i>1976</i>&nbsp;        switch (c) {
<b class="nc"><i>1977</i>&nbsp;        case &#39;B&#39;:</b>
<i>1978</i>&nbsp;            return new Attribute.Constant(syms.byteType, readPool(nextChar()));
<b class="nc"><i>1979</i>&nbsp;        case &#39;C&#39;:</b>
<b class="nc"><i>1980</i>&nbsp;            return new Attribute.Constant(syms.charType, readPool(nextChar()));</b>
<b class="nc"><i>1981</i>&nbsp;        case &#39;D&#39;:</b>
<i>1982</i>&nbsp;            return new Attribute.Constant(syms.doubleType, readPool(nextChar()));
<b class="nc"><i>1983</i>&nbsp;        case &#39;F&#39;:</b>
<b class="nc"><i>1984</i>&nbsp;            return new Attribute.Constant(syms.floatType, readPool(nextChar()));</b>
<i>1985</i>&nbsp;        case &#39;I&#39;:
<i>1986</i>&nbsp;            return new Attribute.Constant(syms.intType, readPool(nextChar()));
<i>1987</i>&nbsp;        case &#39;J&#39;:
<i>1988</i>&nbsp;            return new Attribute.Constant(syms.longType, readPool(nextChar()));
<i>1989</i>&nbsp;        case &#39;S&#39;:
<i>1990</i>&nbsp;            return new Attribute.Constant(syms.shortType, readPool(nextChar()));
<i>1991</i>&nbsp;        case &#39;Z&#39;:
<i>1992</i>&nbsp;            return new Attribute.Constant(syms.booleanType, readPool(nextChar()));
<i>1993</i>&nbsp;        case &#39;s&#39;:
<i>1994</i>&nbsp;            return new Attribute.Constant(syms.stringType, readPool(nextChar()).toString());
<i>1995</i>&nbsp;        case &#39;e&#39;:
<b class="nc"><i>1996</i>&nbsp;            return new EnumAttributeProxy(readEnumType(nextChar()), readName(nextChar()));</b>
<b class="nc"><i>1997</i>&nbsp;        case &#39;c&#39;:</b>
<b class="nc"><i>1998</i>&nbsp;            return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));</b>
<b class="nc"><i>1999</i>&nbsp;        case &#39;[&#39;: {</b>
<b class="nc"><i>2000</i>&nbsp;            int n = nextChar();</b>
<b class="nc"><i>2001</i>&nbsp;            ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();</b>
<i>2002</i>&nbsp;            for (int i=0; i&lt;n; i++)
<i>2003</i>&nbsp;                l.append(readAttributeValue());
<i>2004</i>&nbsp;            return new ArrayAttributeProxy(l.toList());
<i>2005</i>&nbsp;        }
<i>2006</i>&nbsp;        case &#39;@&#39;:
<b class="nc"><i>2007</i>&nbsp;            return readCompoundAnnotation();</b>
<b class="nc"><i>2008</i>&nbsp;        default:</b>
<b class="nc"><i>2009</i>&nbsp;            throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);</b>
<b class="nc"><i>2010</i>&nbsp;        }</b>
<b class="nc"><i>2011</i>&nbsp;    }</b>
<b class="nc"><i>2012</i>&nbsp;</b>
<i>2013</i>&nbsp;    interface ProxyVisitor extends Attribute.Visitor {
<b class="nc"><i>2014</i>&nbsp;        void visitEnumAttributeProxy(EnumAttributeProxy proxy);</b>
<b class="nc"><i>2015</i>&nbsp;        void visitClassAttributeProxy(ClassAttributeProxy proxy);</b>
<b class="nc"><i>2016</i>&nbsp;        void visitArrayAttributeProxy(ArrayAttributeProxy proxy);</b>
<i>2017</i>&nbsp;        void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy);
<i>2018</i>&nbsp;    }
<i>2019</i>&nbsp;
<b class="nc"><i>2020</i>&nbsp;    static class EnumAttributeProxy extends Attribute {</b>
<b class="nc"><i>2021</i>&nbsp;        Type enumType;</b>
<b class="nc"><i>2022</i>&nbsp;        Name enumerator;</b>
<i>2023</i>&nbsp;        public EnumAttributeProxy(Type enumType, Name enumerator) {
<i>2024</i>&nbsp;            super(null);
<b class="nc"><i>2025</i>&nbsp;            this.enumType = enumType;</b>
<i>2026</i>&nbsp;            this.enumerator = enumerator;
<i>2027</i>&nbsp;        }
<i>2028</i>&nbsp;        public void accept(Visitor v) { ((ProxyVisitor)v).visitEnumAttributeProxy(this); }
<b class="nc"><i>2029</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)</b>
<b class="nc"><i>2030</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>2031</i>&nbsp;            return &quot;/*proxy enum*/&quot; + enumType + &quot;.&quot; + enumerator;</b>
<b class="nc"><i>2032</i>&nbsp;        }</b>
<i>2033</i>&nbsp;    }
<i>2034</i>&nbsp;
<b class="nc"><i>2035</i>&nbsp;    static class ClassAttributeProxy extends Attribute {</b>
<b class="nc"><i>2036</i>&nbsp;        Type classType;</b>
<b class="nc"><i>2037</i>&nbsp;        public ClassAttributeProxy(Type classType) {</b>
<i>2038</i>&nbsp;            super(null);
<b class="nc"><i>2039</i>&nbsp;            this.classType = classType;</b>
<b class="nc"><i>2040</i>&nbsp;        }</b>
<b class="nc"><i>2041</i>&nbsp;        public void accept(Visitor v) { ((ProxyVisitor)v).visitClassAttributeProxy(this); }</b>
<b class="nc"><i>2042</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)</b>
<i>2043</i>&nbsp;        public String toString() {
<b class="nc"><i>2044</i>&nbsp;            return &quot;/*proxy class*/&quot; + classType + &quot;.class&quot;;</b>
<i>2045</i>&nbsp;        }
<b class="nc"><i>2046</i>&nbsp;    }</b>
<b class="nc"><i>2047</i>&nbsp;</b>
<b class="nc"><i>2048</i>&nbsp;    static class ArrayAttributeProxy extends Attribute {</b>
<b class="nc"><i>2049</i>&nbsp;        List&lt;Attribute&gt; values;</b>
<b class="nc"><i>2050</i>&nbsp;        ArrayAttributeProxy(List&lt;Attribute&gt; values) {</b>
<i>2051</i>&nbsp;            super(null);
<i>2052</i>&nbsp;            this.values = values;
<i>2053</i>&nbsp;        }
<b class="nc"><i>2054</i>&nbsp;        public void accept(Visitor v) { ((ProxyVisitor)v).visitArrayAttributeProxy(this); }</b>
<b class="nc"><i>2055</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)</b>
<b class="nc"><i>2056</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>2057</i>&nbsp;            return &quot;{&quot; + values + &quot;}&quot;;</b>
<b class="nc"><i>2058</i>&nbsp;        }</b>
<b class="nc"><i>2059</i>&nbsp;    }</b>
<i>2060</i>&nbsp;
<b class="nc"><i>2061</i>&nbsp;    /** A temporary proxy representing a compound attribute.</b>
<b class="nc"><i>2062</i>&nbsp;     */</b>
<b class="nc"><i>2063</i>&nbsp;    static class CompoundAnnotationProxy extends Attribute {</b>
<i>2064</i>&nbsp;        final List&lt;Pair&lt;Name,Attribute&gt;&gt; values;
<b class="nc"><i>2065</i>&nbsp;        public CompoundAnnotationProxy(Type type,</b>
<i>2066</i>&nbsp;                                      List&lt;Pair&lt;Name,Attribute&gt;&gt; values) {
<i>2067</i>&nbsp;            super(type);
<i>2068</i>&nbsp;            this.values = values;
<i>2069</i>&nbsp;        }
<i>2070</i>&nbsp;        public void accept(Visitor v) { ((ProxyVisitor)v).visitCompoundAnnotationProxy(this); }
<i>2071</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)
<i>2072</i>&nbsp;        public String toString() {
<i>2073</i>&nbsp;            StringBuilder buf = new StringBuilder();
<i>2074</i>&nbsp;            buf.append(&quot;@&quot;);
<i>2075</i>&nbsp;            buf.append(type.tsym.getQualifiedName());
<i>2076</i>&nbsp;            buf.append(&quot;/*proxy*/{&quot;);
<i>2077</i>&nbsp;            boolean first = true;
<i>2078</i>&nbsp;            for (List&lt;Pair&lt;Name,Attribute&gt;&gt; v = values;
<i>2079</i>&nbsp;                 v.nonEmpty(); v = v.tail) {
<i>2080</i>&nbsp;                Pair&lt;Name,Attribute&gt; value = v.head;
<b class="nc"><i>2081</i>&nbsp;                if (!first) buf.append(&quot;,&quot;);</b>
<b class="nc"><i>2082</i>&nbsp;                first = false;</b>
<b class="nc"><i>2083</i>&nbsp;                buf.append(value.fst);</b>
<i>2084</i>&nbsp;                buf.append(&quot;=&quot;);
<b class="nc"><i>2085</i>&nbsp;                buf.append(value.snd);</b>
<i>2086</i>&nbsp;            }
<b class="nc"><i>2087</i>&nbsp;            buf.append(&quot;}&quot;);</b>
<b class="nc"><i>2088</i>&nbsp;            return buf.toString();</b>
<b class="nc"><i>2089</i>&nbsp;        }</b>
<i>2090</i>&nbsp;    }
<i>2091</i>&nbsp;
<i>2092</i>&nbsp;    /** A temporary proxy representing a type annotation.
<i>2093</i>&nbsp;     */
<i>2094</i>&nbsp;    static class TypeAnnotationProxy {
<i>2095</i>&nbsp;        final CompoundAnnotationProxy compound;
<i>2096</i>&nbsp;        final TypeAnnotationPosition position;
<i>2097</i>&nbsp;        public TypeAnnotationProxy(CompoundAnnotationProxy compound,
<i>2098</i>&nbsp;                TypeAnnotationPosition position) {
<i>2099</i>&nbsp;            this.compound = compound;
<i>2100</i>&nbsp;            this.position = position;
<i>2101</i>&nbsp;        }
<i>2102</i>&nbsp;    }
<i>2103</i>&nbsp;
<i>2104</i>&nbsp;    class AnnotationDeproxy implements ProxyVisitor {
<i>2105</i>&nbsp;        private ClassSymbol requestingOwner;
<i>2106</i>&nbsp;
<b class="nc"><i>2107</i>&nbsp;        AnnotationDeproxy(ClassSymbol owner) {</b>
<i>2108</i>&nbsp;            this.requestingOwner = owner;
<i>2109</i>&nbsp;        }
<i>2110</i>&nbsp;
<b class="nc"><i>2111</i>&nbsp;        List&lt;Attribute.Compound&gt; deproxyCompoundList(List&lt;CompoundAnnotationProxy&gt; pl) {</b>
<b class="nc"><i>2112</i>&nbsp;            // also must fill in types!!!!</b>
<b class="nc"><i>2113</i>&nbsp;            ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();</b>
<i>2114</i>&nbsp;            for (List&lt;CompoundAnnotationProxy&gt; l = pl; l.nonEmpty(); l=l.tail) {
<i>2115</i>&nbsp;                buf.append(deproxyCompound(l.head));
<i>2116</i>&nbsp;            }
<i>2117</i>&nbsp;            return buf.toList();
<i>2118</i>&nbsp;        }
<i>2119</i>&nbsp;
<b class="nc"><i>2120</i>&nbsp;        Attribute.Compound deproxyCompound(CompoundAnnotationProxy a) {</b>
<i>2121</i>&nbsp;            Type annotationType = resolvePossibleProxyType(a.type);
<i>2122</i>&nbsp;            ListBuffer&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; buf = new ListBuffer&lt;&gt;();
<i>2123</i>&nbsp;            for (List&lt;Pair&lt;Name,Attribute&gt;&gt; l = a.values;
<b class="nc"><i>2124</i>&nbsp;                 l.nonEmpty();</b>
<b class="nc"><i>2125</i>&nbsp;                 l = l.tail) {</b>
<i>2126</i>&nbsp;                MethodSymbol meth = findAccessMethod(annotationType, l.head.fst);
<i>2127</i>&nbsp;                buf.append(new Pair&lt;&gt;(meth, deproxy(meth.type.getReturnType(), l.head.snd)));
<b class="nc"><i>2128</i>&nbsp;            }</b>
<i>2129</i>&nbsp;            return new Attribute.Compound(annotationType, buf.toList());
<i>2130</i>&nbsp;        }
<i>2131</i>&nbsp;
<i>2132</i>&nbsp;        MethodSymbol findAccessMethod(Type container, Name name) {
<i>2133</i>&nbsp;            CompletionFailure failure = null;
<i>2134</i>&nbsp;            try {
<i>2135</i>&nbsp;                for (Symbol sym : container.tsym.members().getSymbolsByName(name)) {
<i>2136</i>&nbsp;                    if (sym.kind == MTH &amp;&amp; sym.type.getParameterTypes().length() == 0)
<i>2137</i>&nbsp;                        return (MethodSymbol) sym;
<b class="nc"><i>2138</i>&nbsp;                }</b>
<b class="nc"><i>2139</i>&nbsp;            } catch (CompletionFailure ex) {</b>
<b class="nc"><i>2140</i>&nbsp;                failure = ex;</b>
<i>2141</i>&nbsp;            }
<i>2142</i>&nbsp;            // The method wasn&#39;t found: emit a warning and recover
<b class="nc"><i>2143</i>&nbsp;            JavaFileObject prevSource = log.useSource(requestingOwner.classfile);</b>
<b class="nc"><i>2144</i>&nbsp;            try {</b>
<b class="nc"><i>2145</i>&nbsp;                if (lintClassfile) {</b>
<b class="nc"><i>2146</i>&nbsp;                    if (failure == null) {</b>
<i>2147</i>&nbsp;                        log.warning(Warnings.AnnotationMethodNotFound(container, name));
<b class="nc"><i>2148</i>&nbsp;                    } else {</b>
<b class="nc"><i>2149</i>&nbsp;                        log.warning(Warnings.AnnotationMethodNotFoundReason(container,</b>
<b class="nc"><i>2150</i>&nbsp;                                                                            name,</b>
<b class="nc"><i>2151</i>&nbsp;                                                                            failure.getDetailValue()));//diagnostic, if present</b>
<b class="nc"><i>2152</i>&nbsp;                    }</b>
<i>2153</i>&nbsp;                }
<i>2154</i>&nbsp;            } finally {
<i>2155</i>&nbsp;                log.useSource(prevSource);
<i>2156</i>&nbsp;            }
<i>2157</i>&nbsp;            // Construct a new method type and symbol.  Use bottom
<i>2158</i>&nbsp;            // type (typeof null) as return type because this type is
<b class="nc"><i>2159</i>&nbsp;            // a subtype of all reference types and can be converted</b>
<i>2160</i>&nbsp;            // to primitive types by unboxing.
<i>2161</i>&nbsp;            MethodType mt = new MethodType(List.nil(),
<i>2162</i>&nbsp;                                           syms.botType,
<i>2163</i>&nbsp;                                           List.nil(),
<i>2164</i>&nbsp;                                           syms.methodClass);
<b class="nc"><i>2165</i>&nbsp;            return new MethodSymbol(PUBLIC | ABSTRACT, name, mt, container.tsym);</b>
<b class="nc"><i>2166</i>&nbsp;        }</b>
<b class="nc"><i>2167</i>&nbsp;</b>
<b class="nc"><i>2168</i>&nbsp;        Attribute result;</b>
<b class="nc"><i>2169</i>&nbsp;        Type type;</b>
<b class="nc"><i>2170</i>&nbsp;        Attribute deproxy(Type t, Attribute a) {</b>
<i>2171</i>&nbsp;            Type oldType = type;
<i>2172</i>&nbsp;            try {
<i>2173</i>&nbsp;                type = t;
<i>2174</i>&nbsp;                a.accept(this);
<i>2175</i>&nbsp;                return result;
<i>2176</i>&nbsp;            } finally {
<i>2177</i>&nbsp;                type = oldType;
<b class="nc"><i>2178</i>&nbsp;            }</b>
<b class="nc"><i>2179</i>&nbsp;        }</b>
<b class="nc"><i>2180</i>&nbsp;</b>
<b class="nc"><i>2181</i>&nbsp;        // implement Attribute.Visitor below</b>
<i>2182</i>&nbsp;
<i>2183</i>&nbsp;        public void visitConstant(Attribute.Constant value) {
<i>2184</i>&nbsp;            // assert value.type == type;
<b class="nc"><i>2185</i>&nbsp;            result = value;</b>
<b class="nc"><i>2186</i>&nbsp;        }</b>
<b class="nc"><i>2187</i>&nbsp;</b>
<i>2188</i>&nbsp;        public void visitClass(Attribute.Class clazz) {
<b class="nc"><i>2189</i>&nbsp;            result = clazz;</b>
<i>2190</i>&nbsp;        }
<i>2191</i>&nbsp;
<i>2192</i>&nbsp;        public void visitEnum(Attribute.Enum e) {
<i>2193</i>&nbsp;            throw new AssertionError(); // shouldn&#39;t happen
<i>2194</i>&nbsp;        }
<i>2195</i>&nbsp;
<b class="nc"><i>2196</i>&nbsp;        public void visitCompound(Attribute.Compound compound) {</b>
<i>2197</i>&nbsp;            throw new AssertionError(); // shouldn&#39;t happen
<i>2198</i>&nbsp;        }
<b class="nc"><i>2199</i>&nbsp;</b>
<i>2200</i>&nbsp;        public void visitArray(Attribute.Array array) {
<i>2201</i>&nbsp;            throw new AssertionError(); // shouldn&#39;t happen
<b class="nc"><i>2202</i>&nbsp;        }</b>
<b class="nc"><i>2203</i>&nbsp;</b>
<b class="nc"><i>2204</i>&nbsp;        public void visitError(Attribute.Error e) {</b>
<i>2205</i>&nbsp;            throw new AssertionError(); // shouldn&#39;t happen
<i>2206</i>&nbsp;        }
<b class="nc"><i>2207</i>&nbsp;</b>
<b class="nc"><i>2208</i>&nbsp;        public void visitEnumAttributeProxy(EnumAttributeProxy proxy) {</b>
<i>2209</i>&nbsp;            // type.tsym.flatName() should == proxy.enumFlatName
<i>2210</i>&nbsp;            Type enumType = resolvePossibleProxyType(proxy.enumType);
<b class="nc"><i>2211</i>&nbsp;            TypeSymbol enumTypeSym = enumType.tsym;</b>
<b class="nc"><i>2212</i>&nbsp;            VarSymbol enumerator = null;</b>
<b class="nc"><i>2213</i>&nbsp;            CompletionFailure failure = null;</b>
<i>2214</i>&nbsp;            try {
<i>2215</i>&nbsp;                for (Symbol sym : enumTypeSym.members().getSymbolsByName(proxy.enumerator)) {
<i>2216</i>&nbsp;                    if (sym.kind == VAR) {
<i>2217</i>&nbsp;                        enumerator = (VarSymbol)sym;
<b class="nc"><i>2218</i>&nbsp;                        break;</b>
<b class="nc"><i>2219</i>&nbsp;                    }</b>
<b class="nc"><i>2220</i>&nbsp;                }</b>
<b class="nc"><i>2221</i>&nbsp;            }</b>
<b class="nc"><i>2222</i>&nbsp;            catch (CompletionFailure ex) {</b>
<b class="nc"><i>2223</i>&nbsp;                failure = ex;</b>
<b class="nc"><i>2224</i>&nbsp;            }</b>
<b class="nc"><i>2225</i>&nbsp;            if (enumerator == null) {</b>
<b class="nc"><i>2226</i>&nbsp;                if (failure != null) {</b>
<i>2227</i>&nbsp;                    log.warning(Warnings.UnknownEnumConstantReason(currentClassFile,
<b class="nc"><i>2228</i>&nbsp;                                                                   enumTypeSym,</b>
<b class="nc"><i>2229</i>&nbsp;                                                                   proxy.enumerator,</b>
<b class="nc"><i>2230</i>&nbsp;                                                                   failure.getDiagnostic()));</b>
<i>2231</i>&nbsp;                } else {
<i>2232</i>&nbsp;                    log.warning(Warnings.UnknownEnumConstant(currentClassFile,
<i>2233</i>&nbsp;                                                             enumTypeSym,
<b class="nc"><i>2234</i>&nbsp;                                                             proxy.enumerator));</b>
<b class="nc"><i>2235</i>&nbsp;                }</b>
<b class="nc"><i>2236</i>&nbsp;                result = new Attribute.Enum(enumTypeSym.type,</b>
<b class="nc"><i>2237</i>&nbsp;                        new VarSymbol(0, proxy.enumerator, syms.botType, enumTypeSym));</b>
<i>2238</i>&nbsp;            } else {
<b class="nc"><i>2239</i>&nbsp;                result = new Attribute.Enum(enumTypeSym.type, enumerator);</b>
<b class="nc"><i>2240</i>&nbsp;            }</b>
<b class="nc"><i>2241</i>&nbsp;        }</b>
<b class="nc"><i>2242</i>&nbsp;</b>
<b class="nc"><i>2243</i>&nbsp;        @Override</b>
<b class="nc"><i>2244</i>&nbsp;        public void visitClassAttributeProxy(ClassAttributeProxy proxy) {</b>
<i>2245</i>&nbsp;            Type classType = resolvePossibleProxyType(proxy.classType);
<b class="nc"><i>2246</i>&nbsp;            result = new Attribute.Class(types, classType);</b>
<b class="nc"><i>2247</i>&nbsp;        }</b>
<i>2248</i>&nbsp;
<b class="nc"><i>2249</i>&nbsp;        public void visitArrayAttributeProxy(ArrayAttributeProxy proxy) {</b>
<b class="nc"><i>2250</i>&nbsp;            int length = proxy.values.length();</b>
<b class="nc"><i>2251</i>&nbsp;            Attribute[] ats = new Attribute[length];</b>
<b class="nc"><i>2252</i>&nbsp;            Type elemtype = types.elemtype(type);</b>
<i>2253</i>&nbsp;            int i = 0;
<b class="nc"><i>2254</i>&nbsp;            for (List&lt;Attribute&gt; p = proxy.values; p.nonEmpty(); p = p.tail) {</b>
<i>2255</i>&nbsp;                ats[i++] = deproxy(elemtype, p.head);
<i>2256</i>&nbsp;            }
<i>2257</i>&nbsp;            result = new Attribute.Array(type, ats);
<i>2258</i>&nbsp;        }
<i>2259</i>&nbsp;
<i>2260</i>&nbsp;        public void visitCompoundAnnotationProxy(CompoundAnnotationProxy proxy) {
<b class="nc"><i>2261</i>&nbsp;            result = deproxyCompound(proxy);</b>
<b class="nc"><i>2262</i>&nbsp;        }</b>
<b class="nc"><i>2263</i>&nbsp;</b>
<b class="nc"><i>2264</i>&nbsp;        Type resolvePossibleProxyType(Type t) {</b>
<b class="nc"><i>2265</i>&nbsp;            if (t instanceof ProxyType) {</b>
<b class="nc"><i>2266</i>&nbsp;                Assert.check(requestingOwner.owner.kind == MDL);</b>
<b class="nc"><i>2267</i>&nbsp;                ModuleSymbol prevCurrentModule = currentModule;</b>
<b class="nc"><i>2268</i>&nbsp;                currentModule = (ModuleSymbol) requestingOwner.owner;</b>
<b class="nc"><i>2269</i>&nbsp;                try {</b>
<b class="nc"><i>2270</i>&nbsp;                    return ((ProxyType) t).resolve();</b>
<b class="nc"><i>2271</i>&nbsp;                } finally {</b>
<b class="nc"><i>2272</i>&nbsp;                    currentModule = prevCurrentModule;</b>
<b class="nc"><i>2273</i>&nbsp;                }</b>
<b class="nc"><i>2274</i>&nbsp;            } else {</b>
<b class="nc"><i>2275</i>&nbsp;                return t;</b>
<i>2276</i>&nbsp;            }
<b class="nc"><i>2277</i>&nbsp;        }</b>
<b class="nc"><i>2278</i>&nbsp;    }</b>
<b class="nc"><i>2279</i>&nbsp;</b>
<i>2280</i>&nbsp;    class AnnotationDefaultCompleter extends AnnotationDeproxy implements Runnable {
<i>2281</i>&nbsp;        final MethodSymbol sym;
<i>2282</i>&nbsp;        final Attribute value;
<i>2283</i>&nbsp;        final JavaFileObject classFile = currentClassFile;
<i>2284</i>&nbsp;
<i>2285</i>&nbsp;        AnnotationDefaultCompleter(MethodSymbol sym, Attribute value) {
<i>2286</i>&nbsp;            super(currentOwner.kind == MTH
<i>2287</i>&nbsp;                    ? currentOwner.enclClass() : (ClassSymbol)currentOwner);
<b class="nc"><i>2288</i>&nbsp;            this.sym = sym;</b>
<b class="nc"><i>2289</i>&nbsp;            this.value = value;</b>
<b class="nc"><i>2290</i>&nbsp;        }</b>
<i>2291</i>&nbsp;
<b class="nc"><i>2292</i>&nbsp;        @Override</b>
<b class="nc"><i>2293</i>&nbsp;        public void run() {</b>
<b class="nc"><i>2294</i>&nbsp;            JavaFileObject previousClassFile = currentClassFile;</b>
<b class="nc"><i>2295</i>&nbsp;            try {</b>
<b class="nc"><i>2296</i>&nbsp;                // Reset the interim value set earlier in</b>
<i>2297</i>&nbsp;                // attachAnnotationDefault().
<b class="nc"><i>2298</i>&nbsp;                sym.defaultValue = null;</b>
<i>2299</i>&nbsp;                currentClassFile = classFile;
<b class="nc"><i>2300</i>&nbsp;                sym.defaultValue = deproxy(sym.type.getReturnType(), value);</b>
<b class="nc"><i>2301</i>&nbsp;            } finally {</b>
<i>2302</i>&nbsp;                currentClassFile = previousClassFile;
<b class="nc"><i>2303</i>&nbsp;            }</b>
<b class="nc"><i>2304</i>&nbsp;        }</b>
<i>2305</i>&nbsp;
<b class="nc"><i>2306</i>&nbsp;        @Override</b>
<b class="nc"><i>2307</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>2308</i>&nbsp;            return &quot; ClassReader store default for &quot; + sym.owner + &quot;.&quot; + sym + &quot; is &quot; + value;</b>
<b class="nc"><i>2309</i>&nbsp;        }</b>
<b class="nc"><i>2310</i>&nbsp;    }</b>
<i>2311</i>&nbsp;
<b class="nc"><i>2312</i>&nbsp;    class AnnotationCompleter extends AnnotationDeproxy implements Runnable {</b>
<i>2313</i>&nbsp;        final Symbol sym;
<i>2314</i>&nbsp;        final List&lt;CompoundAnnotationProxy&gt; l;
<i>2315</i>&nbsp;        final JavaFileObject classFile;
<b class="nc"><i>2316</i>&nbsp;</b>
<b class="nc"><i>2317</i>&nbsp;        AnnotationCompleter(Symbol sym, List&lt;CompoundAnnotationProxy&gt; l) {</b>
<i>2318</i>&nbsp;            super(currentOwner.kind == MTH
<b class="nc"><i>2319</i>&nbsp;                    ? currentOwner.enclClass() : (ClassSymbol)currentOwner);</b>
<b class="nc"><i>2320</i>&nbsp;            if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {</b>
<b class="nc"><i>2321</i>&nbsp;                this.sym = sym.owner;</b>
<b class="nc"><i>2322</i>&nbsp;            } else {</b>
<i>2323</i>&nbsp;                this.sym = sym;
<b class="nc"><i>2324</i>&nbsp;            }</b>
<i>2325</i>&nbsp;            this.l = l;
<i>2326</i>&nbsp;            this.classFile = currentClassFile;
<i>2327</i>&nbsp;        }
<i>2328</i>&nbsp;
<i>2329</i>&nbsp;        @Override
<i>2330</i>&nbsp;        public void run() {
<i>2331</i>&nbsp;            JavaFileObject previousClassFile = currentClassFile;
<b class="nc"><i>2332</i>&nbsp;            try {</b>
<i>2333</i>&nbsp;                currentClassFile = classFile;
<i>2334</i>&nbsp;                List&lt;Attribute.Compound&gt; newList = deproxyCompoundList(l);
<b class="nc"><i>2335</i>&nbsp;                for (Attribute.Compound attr : newList) {</b>
<b class="nc"><i>2336</i>&nbsp;                    if (attr.type.tsym == syms.deprecatedType.tsym) {</b>
<b class="nc"><i>2337</i>&nbsp;                        sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);</b>
<b class="nc"><i>2338</i>&nbsp;                        Attribute forRemoval = attr.member(names.forRemoval);</b>
<b class="nc"><i>2339</i>&nbsp;                        if (forRemoval instanceof Attribute.Constant) {</b>
<i>2340</i>&nbsp;                            Attribute.Constant c = (Attribute.Constant) forRemoval;
<b class="nc"><i>2341</i>&nbsp;                            if (c.type == syms.booleanType &amp;&amp; ((Integer) c.value) != 0) {</b>
<b class="nc"><i>2342</i>&nbsp;                                sym.flags_field |= DEPRECATED_REMOVAL;</b>
<b class="nc"><i>2343</i>&nbsp;                            }</b>
<i>2344</i>&nbsp;                        }
<b class="nc"><i>2345</i>&nbsp;                    }</b>
<i>2346</i>&nbsp;                }
<i>2347</i>&nbsp;                if (sym.annotationsPendingCompletion()) {
<b class="nc"><i>2348</i>&nbsp;                    sym.setDeclarationAttributes(newList);</b>
<i>2349</i>&nbsp;                } else {
<i>2350</i>&nbsp;                    sym.appendAttributes(newList);
<i>2351</i>&nbsp;                }
<i>2352</i>&nbsp;            } finally {
<i>2353</i>&nbsp;                currentClassFile = previousClassFile;
<i>2354</i>&nbsp;            }
<i>2355</i>&nbsp;        }
<i>2356</i>&nbsp;
<i>2357</i>&nbsp;        @Override
<b class="nc"><i>2358</i>&nbsp;        public String toString() {</b>
<b class="nc"><i>2359</i>&nbsp;            return &quot; ClassReader annotate &quot; + sym.owner + &quot;.&quot; + sym + &quot; with &quot; + l;</b>
<b class="nc"><i>2360</i>&nbsp;        }</b>
<b class="nc"><i>2361</i>&nbsp;    }</b>
<b class="nc"><i>2362</i>&nbsp;</b>
<i>2363</i>&nbsp;    class TypeAnnotationCompleter extends AnnotationCompleter {
<i>2364</i>&nbsp;
<i>2365</i>&nbsp;        List&lt;TypeAnnotationProxy&gt; proxies;
<i>2366</i>&nbsp;
<i>2367</i>&nbsp;        TypeAnnotationCompleter(Symbol sym,
<i>2368</i>&nbsp;                List&lt;TypeAnnotationProxy&gt; proxies) {
<b class="nc"><i>2369</i>&nbsp;            super(sym, List.nil());</b>
<b class="nc"><i>2370</i>&nbsp;            this.proxies = proxies;</b>
<b class="nc"><i>2371</i>&nbsp;        }</b>
<b class="nc"><i>2372</i>&nbsp;</b>
<b class="nc"><i>2373</i>&nbsp;        List&lt;Attribute.TypeCompound&gt; deproxyTypeCompoundList(List&lt;TypeAnnotationProxy&gt; proxies) {</b>
<b class="nc"><i>2374</i>&nbsp;            ListBuffer&lt;Attribute.TypeCompound&gt; buf = new ListBuffer&lt;&gt;();</b>
<i>2375</i>&nbsp;            for (TypeAnnotationProxy proxy: proxies) {
<i>2376</i>&nbsp;                Attribute.Compound compound = deproxyCompound(proxy.compound);
<b class="nc"><i>2377</i>&nbsp;                Attribute.TypeCompound typeCompound = new Attribute.TypeCompound(compound, proxy.position);</b>
<b class="nc"><i>2378</i>&nbsp;                buf.add(typeCompound);</b>
<b class="nc"><i>2379</i>&nbsp;            }</b>
<b class="nc"><i>2380</i>&nbsp;            return buf.toList();</b>
<i>2381</i>&nbsp;        }
<b class="nc"><i>2382</i>&nbsp;</b>
<i>2383</i>&nbsp;        @Override
<i>2384</i>&nbsp;        public void run() {
<i>2385</i>&nbsp;            JavaFileObject previousClassFile = currentClassFile;
<i>2386</i>&nbsp;            try {
<i>2387</i>&nbsp;                currentClassFile = classFile;
<i>2388</i>&nbsp;                List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
<i>2389</i>&nbsp;                sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
<i>2390</i>&nbsp;            } finally {
<i>2391</i>&nbsp;                currentClassFile = previousClassFile;
<i>2392</i>&nbsp;            }
<i>2393</i>&nbsp;        }
<i>2394</i>&nbsp;    }
<i>2395</i>&nbsp;
<b class="nc"><i>2396</i>&nbsp;</b>
<b class="nc"><i>2397</i>&nbsp;/************************************************************************</b>
<b class="nc"><i>2398</i>&nbsp; * Reading Symbols</b>
<i>2399</i>&nbsp; ***********************************************************************/
<i>2400</i>&nbsp;
<i>2401</i>&nbsp;    /** Read a field.
<i>2402</i>&nbsp;     */
<b class="nc"><i>2403</i>&nbsp;    VarSymbol readField() {</b>
<i>2404</i>&nbsp;        long flags = adjustFieldFlags(nextChar());
<b class="nc"><i>2405</i>&nbsp;        Name name = readName(nextChar());</b>
<b class="nc"><i>2406</i>&nbsp;        Type type = readType(nextChar());</b>
<i>2407</i>&nbsp;        VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
<b class="nc"><i>2408</i>&nbsp;        readMemberAttrs(v);</b>
<b class="nc"><i>2409</i>&nbsp;        return v;</b>
<b class="nc"><i>2410</i>&nbsp;    }</b>
<b class="nc"><i>2411</i>&nbsp;</b>
<b class="nc"><i>2412</i>&nbsp;    /** Read a method.</b>
<i>2413</i>&nbsp;     */
<i>2414</i>&nbsp;    MethodSymbol readMethod() {
<i>2415</i>&nbsp;        long flags = adjustMethodFlags(nextChar());
<i>2416</i>&nbsp;        Name name = readName(nextChar());
<i>2417</i>&nbsp;        Type type = readType(nextChar());
<i>2418</i>&nbsp;        if (currentOwner.isInterface() &amp;&amp;
<b class="nc"><i>2419</i>&nbsp;                (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {</b>
<b class="nc"><i>2420</i>&nbsp;            if (majorVersion &gt; Version.V52.major ||</b>
<b class="nc"><i>2421</i>&nbsp;                    (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {</b>
<i>2422</i>&nbsp;                if ((flags &amp; (STATIC | PRIVATE)) == 0) {
<b class="nc"><i>2423</i>&nbsp;                    currentOwner.flags_field |= DEFAULT;</b>
<i>2424</i>&nbsp;                    flags |= DEFAULT | ABSTRACT;
<i>2425</i>&nbsp;                }
<i>2426</i>&nbsp;            } else {
<i>2427</i>&nbsp;                //protect against ill-formed classfiles
<i>2428</i>&nbsp;                throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
<i>2429</i>&nbsp;                                   Integer.toString(majorVersion),
<b class="nc"><i>2430</i>&nbsp;                                   Integer.toString(minorVersion));</b>
<b class="nc"><i>2431</i>&nbsp;            }</b>
<b class="nc"><i>2432</i>&nbsp;        }</b>
<b class="nc"><i>2433</i>&nbsp;        if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {</b>
<i>2434</i>&nbsp;            // Sometimes anonymous classes don&#39;t have an outer
<b class="nc"><i>2435</i>&nbsp;            // instance, however, there is no reliable way to tell so</b>
<b class="nc"><i>2436</i>&nbsp;            // we never strip this$n</b>
<i>2437</i>&nbsp;            // ditto for local classes. Local classes that have an enclosing method set
<i>2438</i>&nbsp;            // won&#39;t pass the &quot;hasOuterInstance&quot; check above, but those that don&#39;t have an
<i>2439</i>&nbsp;            // enclosing method (i.e. from initializers) will pass that check.
<b class="nc"><i>2440</i>&nbsp;            boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);</b>
<b class="nc"><i>2441</i>&nbsp;            if (!currentOwner.name.isEmpty() &amp;&amp; !local)</b>
<b class="nc"><i>2442</i>&nbsp;                type = new MethodType(adjustMethodParams(flags, type.getParameterTypes()),</b>
<b class="nc"><i>2443</i>&nbsp;                                      type.getReturnType(),</b>
<b class="nc"><i>2444</i>&nbsp;                                      type.getThrownTypes(),</b>
<i>2445</i>&nbsp;                                      syms.methodClass);
<b class="nc"><i>2446</i>&nbsp;        }</b>
<b class="nc"><i>2447</i>&nbsp;        MethodSymbol m = new MethodSymbol(flags, name, type, currentOwner);</b>
<b class="nc"><i>2448</i>&nbsp;        if (types.isSignaturePolymorphic(m)) {</b>
<b class="nc"><i>2449</i>&nbsp;            m.flags_field |= SIGNATURE_POLYMORPHIC;</b>
<i>2450</i>&nbsp;        }
<b class="nc"><i>2451</i>&nbsp;        if (saveParameterNames)</b>
<b class="nc"><i>2452</i>&nbsp;            initParameterNames(m);</b>
<i>2453</i>&nbsp;        Symbol prevOwner = currentOwner;
<i>2454</i>&nbsp;        currentOwner = m;
<i>2455</i>&nbsp;        try {
<i>2456</i>&nbsp;            readMemberAttrs(m);
<b class="nc"><i>2457</i>&nbsp;        } finally {</b>
<b class="nc"><i>2458</i>&nbsp;            currentOwner = prevOwner;</b>
<i>2459</i>&nbsp;        }
<i>2460</i>&nbsp;        setParameters(m, type);
<i>2461</i>&nbsp;
<i>2462</i>&nbsp;        if ((flags &amp; VARARGS) != 0) {
<i>2463</i>&nbsp;            final Type last = type.getParameterTypes().last();
<i>2464</i>&nbsp;            if (last == null || !last.hasTag(ARRAY)) {
<i>2465</i>&nbsp;                m.flags_field &amp;= ~VARARGS;
<i>2466</i>&nbsp;                throw badClassFile(&quot;malformed.vararg.method&quot;, m);
<i>2467</i>&nbsp;            }
<b class="nc"><i>2468</i>&nbsp;        }</b>
<b class="nc"><i>2469</i>&nbsp;</b>
<b class="nc"><i>2470</i>&nbsp;        return m;</b>
<b class="nc"><i>2471</i>&nbsp;    }</b>
<b class="nc"><i>2472</i>&nbsp;</b>
<b class="nc"><i>2473</i>&nbsp;    private List&lt;Type&gt; adjustMethodParams(long flags, List&lt;Type&gt; args) {</b>
<b class="nc"><i>2474</i>&nbsp;        boolean isVarargs = (flags &amp; VARARGS) != 0;</b>
<b class="nc"><i>2475</i>&nbsp;        if (isVarargs) {</b>
<b class="nc"><i>2476</i>&nbsp;            Type varargsElem = args.last();</b>
<i>2477</i>&nbsp;            ListBuffer&lt;Type&gt; adjustedArgs = new ListBuffer&lt;&gt;();
<i>2478</i>&nbsp;            for (Type t : args) {
<i>2479</i>&nbsp;                adjustedArgs.append(t != varargsElem ?
<i>2480</i>&nbsp;                    t :
<i>2481</i>&nbsp;                    ((ArrayType)t).makeVarargs());
<i>2482</i>&nbsp;            }
<i>2483</i>&nbsp;            args = adjustedArgs.toList();
<b class="nc"><i>2484</i>&nbsp;        }</b>
<i>2485</i>&nbsp;        return args.tail;
<i>2486</i>&nbsp;    }
<i>2487</i>&nbsp;
<i>2488</i>&nbsp;    /**
<i>2489</i>&nbsp;     * Init the parameter names array.
<b class="nc"><i>2490</i>&nbsp;     * Parameter names are currently inferred from the names in the</b>
<b class="nc"><i>2491</i>&nbsp;     * LocalVariableTable attributes of a Code attribute.</b>
<i>2492</i>&nbsp;     * (Note: this means parameter names are currently not available for
<b class="nc"><i>2493</i>&nbsp;     * methods without a Code attribute.)</b>
<b class="nc"><i>2494</i>&nbsp;     * This method initializes an array in which to store the name indexes</b>
<b class="nc"><i>2495</i>&nbsp;     * of parameter names found in LocalVariableTable attributes. It is</b>
<b class="nc"><i>2496</i>&nbsp;     * slightly supersized to allow for additional slots with a start_pc of 0.</b>
<b class="nc"><i>2497</i>&nbsp;     */</b>
<i>2498</i>&nbsp;    void initParameterNames(MethodSymbol sym) {
<b class="nc"><i>2499</i>&nbsp;        // make allowance for synthetic parameters.</b>
<b class="nc"><i>2500</i>&nbsp;        final int excessSlots = 4;</b>
<i>2501</i>&nbsp;        int expectedParameterSlots =
<b class="nc"><i>2502</i>&nbsp;                Code.width(sym.type.getParameterTypes()) + excessSlots;</b>
<b class="nc"><i>2503</i>&nbsp;        if (parameterNameIndices == null</b>
<b class="nc"><i>2504</i>&nbsp;                || parameterNameIndices.length &lt; expectedParameterSlots) {</b>
<i>2505</i>&nbsp;            parameterNameIndices = new int[expectedParameterSlots];
<b class="nc"><i>2506</i>&nbsp;        } else</b>
<b class="nc"><i>2507</i>&nbsp;            Arrays.fill(parameterNameIndices, 0);</b>
<i>2508</i>&nbsp;        haveParameterNameIndices = false;
<b class="nc"><i>2509</i>&nbsp;        sawMethodParameters = false;</b>
<b class="nc"><i>2510</i>&nbsp;    }</b>
<b class="nc"><i>2511</i>&nbsp;</b>
<b class="nc"><i>2512</i>&nbsp;    /**</b>
<b class="nc"><i>2513</i>&nbsp;     * Set the parameters for a method symbol, including any names and</b>
<b class="nc"><i>2514</i>&nbsp;     * annotations that were read.</b>
<b class="nc"><i>2515</i>&nbsp;     *</b>
<b class="nc"><i>2516</i>&nbsp;     * &lt;p&gt;The type of the symbol may have changed while reading the</b>
<b class="nc"><i>2517</i>&nbsp;     * method attributes (see the Signature attribute). This may be</b>
<b class="nc"><i>2518</i>&nbsp;     * because of generic information or because anonymous synthetic</b>
<b class="nc"><i>2519</i>&nbsp;     * parameters were added.   The original type (as read from the</b>
<b class="nc"><i>2520</i>&nbsp;     * method descriptor) is used to help guess the existence of</b>
<b class="nc"><i>2521</i>&nbsp;     * anonymous synthetic parameters.</b>
<b class="nc"><i>2522</i>&nbsp;     */</b>
<b class="nc"><i>2523</i>&nbsp;    void setParameters(MethodSymbol sym, Type jvmType) {</b>
<b class="nc"><i>2524</i>&nbsp;        // If we get parameter names from MethodParameters, then we</b>
<b class="nc"><i>2525</i>&nbsp;        // don&#39;t need to skip.</b>
<b class="nc"><i>2526</i>&nbsp;        int firstParam = 0;</b>
<i>2527</i>&nbsp;        if (!sawMethodParameters) {
<i>2528</i>&nbsp;            firstParam = ((sym.flags() &amp; STATIC) == 0) ? 1 : 0;
<b class="nc"><i>2529</i>&nbsp;            // the code in readMethod may have skipped the first</b>
<b class="nc"><i>2530</i>&nbsp;            // parameter when setting up the MethodType. If so, we</b>
<b class="nc"><i>2531</i>&nbsp;            // make a corresponding allowance here for the position of</b>
<b class="nc"><i>2532</i>&nbsp;            // the first parameter.  Note that this assumes the</b>
<i>2533</i>&nbsp;            // skipped parameter has a width of 1 -- i.e. it is not
<b class="nc"><i>2534</i>&nbsp;            // a double width type (long or double.)</b>
<b class="nc"><i>2535</i>&nbsp;            if (sym.name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {</b>
<i>2536</i>&nbsp;                // Sometimes anonymous classes don&#39;t have an outer
<b class="nc"><i>2537</i>&nbsp;                // instance, however, there is no reliable way to tell so</b>
<b class="nc"><i>2538</i>&nbsp;                // we never strip this$n</b>
<i>2539</i>&nbsp;                if (!currentOwner.name.isEmpty())
<i>2540</i>&nbsp;                    firstParam += 1;
<i>2541</i>&nbsp;            }
<b class="nc"><i>2542</i>&nbsp;</b>
<b class="nc"><i>2543</i>&nbsp;            if (sym.type != jvmType) {</b>
<i>2544</i>&nbsp;                // reading the method attributes has caused the
<b class="nc"><i>2545</i>&nbsp;                // symbol&#39;s type to be changed. (i.e. the Signature</b>
<i>2546</i>&nbsp;                // attribute.)  This may happen if there are hidden
<i>2547</i>&nbsp;                // (synthetic) parameters in the descriptor, but not
<b class="nc"><i>2548</i>&nbsp;                // in the Signature.  The position of these hidden</b>
<b class="nc"><i>2549</i>&nbsp;                // parameters is unspecified; for now, assume they are</b>
<b class="nc"><i>2550</i>&nbsp;                // at the beginning, and so skip over them. The</b>
<b class="nc"><i>2551</i>&nbsp;                // primary case for this is two hidden parameters</b>
<i>2552</i>&nbsp;                // passed into Enum constructors.
<i>2553</i>&nbsp;                int skip = Code.width(jvmType.getParameterTypes())
<i>2554</i>&nbsp;                        - Code.width(sym.type.getParameterTypes());
<i>2555</i>&nbsp;                firstParam += skip;
<i>2556</i>&nbsp;            }
<b class="nc"><i>2557</i>&nbsp;        }</b>
<b class="nc"><i>2558</i>&nbsp;        List&lt;Name&gt; paramNames = List.nil();</b>
<b class="nc"><i>2559</i>&nbsp;        ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();</b>
<b class="nc"><i>2560</i>&nbsp;        int nameIndex = firstParam;</b>
<b class="nc"><i>2561</i>&nbsp;        int annotationIndex = 0;</b>
<b class="nc"><i>2562</i>&nbsp;        for (Type t: sym.type.getParameterTypes()) {</b>
<b class="nc"><i>2563</i>&nbsp;            Name name = parameterName(nameIndex, paramNames);</b>
<i>2564</i>&nbsp;            paramNames = paramNames.prepend(name);
<b class="nc"><i>2565</i>&nbsp;            VarSymbol param = new VarSymbol(PARAMETER, name, t, sym);</b>
<i>2566</i>&nbsp;            params.append(param);
<b class="nc"><i>2567</i>&nbsp;            if (parameterAnnotations != null) {</b>
<b class="nc"><i>2568</i>&nbsp;                ParameterAnnotations annotations = parameterAnnotations[annotationIndex];</b>
<b class="nc"><i>2569</i>&nbsp;                if (annotations != null &amp;&amp; annotations.proxies != null</b>
<i>2570</i>&nbsp;                        &amp;&amp; !annotations.proxies.isEmpty()) {
<i>2571</i>&nbsp;                    annotate.normal(new AnnotationCompleter(param, annotations.proxies));
<i>2572</i>&nbsp;                }
<i>2573</i>&nbsp;            }
<b class="nc"><i>2574</i>&nbsp;            nameIndex += sawMethodParameters ? 1 : Code.width(t);</b>
<i>2575</i>&nbsp;            annotationIndex++;
<i>2576</i>&nbsp;        }
<i>2577</i>&nbsp;        if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
<i>2578</i>&nbsp;            throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
<i>2579</i>&nbsp;        }
<i>2580</i>&nbsp;        Assert.checkNull(sym.params);
<i>2581</i>&nbsp;        sym.params = params.toList();
<i>2582</i>&nbsp;        parameterAnnotations = null;
<i>2583</i>&nbsp;        parameterNameIndices = null;
<b class="nc"><i>2584</i>&nbsp;    }</b>
<b class="nc"><i>2585</i>&nbsp;</b>
<b class="nc"><i>2586</i>&nbsp;</b>
<b class="nc"><i>2587</i>&nbsp;    // Returns the name for the parameter at position &#39;index&#39;, either using</b>
<i>2588</i>&nbsp;    // names read from the MethodParameters, or by synthesizing a name that
<b class="nc"><i>2589</i>&nbsp;    // is not on the &#39;exclude&#39; list.</b>
<i>2590</i>&nbsp;    private Name parameterName(int index, List&lt;Name&gt; exclude) {
<i>2591</i>&nbsp;        if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
<i>2592</i>&nbsp;                &amp;&amp; parameterNameIndices[index] != 0) {
<i>2593</i>&nbsp;            return readName(parameterNameIndices[index]);
<i>2594</i>&nbsp;        }
<i>2595</i>&nbsp;        String prefix = &quot;arg&quot;;
<i>2596</i>&nbsp;        while (true) {
<b class="nc"><i>2597</i>&nbsp;            Name argName = names.fromString(prefix + exclude.size());</b>
<i>2598</i>&nbsp;            if (!exclude.contains(argName))
<i>2599</i>&nbsp;                return argName;
<i>2600</i>&nbsp;            prefix += &quot;$&quot;;
<b class="nc"><i>2601</i>&nbsp;        }</b>
<i>2602</i>&nbsp;    }
<b class="nc"><i>2603</i>&nbsp;</b>
<b class="nc"><i>2604</i>&nbsp;    /**</b>
<b class="nc"><i>2605</i>&nbsp;     * skip n bytes</b>
<b class="nc"><i>2606</i>&nbsp;     */</b>
<i>2607</i>&nbsp;    void skipBytes(int n) {
<i>2608</i>&nbsp;        bp = bp + n;
<b class="nc"><i>2609</i>&nbsp;    }</b>
<i>2610</i>&nbsp;
<i>2611</i>&nbsp;    /** Skip a field or method
<b class="nc"><i>2612</i>&nbsp;     */</b>
<i>2613</i>&nbsp;    void skipMember() {
<i>2614</i>&nbsp;        bp = bp + 6;
<i>2615</i>&nbsp;        char ac = nextChar();
<i>2616</i>&nbsp;        for (int i = 0; i &lt; ac; i++) {
<i>2617</i>&nbsp;            bp = bp + 2;
<i>2618</i>&nbsp;            int attrLen = nextInt();
<b class="nc"><i>2619</i>&nbsp;            bp = bp + attrLen;</b>
<b class="nc"><i>2620</i>&nbsp;        }</b>
<b class="nc"><i>2621</i>&nbsp;    }</b>
<i>2622</i>&nbsp;
<b class="nc"><i>2623</i>&nbsp;    void skipInnerClasses() {</b>
<b class="nc"><i>2624</i>&nbsp;        int n = nextChar();</b>
<b class="nc"><i>2625</i>&nbsp;        for (int i = 0; i &lt; n; i++) {</b>
<b class="nc"><i>2626</i>&nbsp;            nextChar();</b>
<b class="nc"><i>2627</i>&nbsp;            nextChar();</b>
<i>2628</i>&nbsp;            nextChar();
<b class="nc"><i>2629</i>&nbsp;            nextChar();</b>
<i>2630</i>&nbsp;        }
<i>2631</i>&nbsp;    }
<i>2632</i>&nbsp;
<i>2633</i>&nbsp;    /** Enter type variables of this classtype and all enclosing ones in
<i>2634</i>&nbsp;     *  `typevars&#39;.
<i>2635</i>&nbsp;     */
<i>2636</i>&nbsp;    protected void enterTypevars(Symbol sym, Type t) {
<i>2637</i>&nbsp;        if (t.getEnclosingType() != null) {
<i>2638</i>&nbsp;            if (!t.getEnclosingType().hasTag(TypeTag.NONE)) {
<b class="nc"><i>2639</i>&nbsp;                enterTypevars(sym.owner, t.getEnclosingType());</b>
<i>2640</i>&nbsp;            }
<i>2641</i>&nbsp;        } else if (sym.kind == MTH &amp;&amp; !sym.isStatic()) {
<i>2642</i>&nbsp;            enterTypevars(sym.owner, sym.owner.type);
<i>2643</i>&nbsp;        }
<i>2644</i>&nbsp;        for (List&lt;Type&gt; xs = t.getTypeArguments(); xs.nonEmpty(); xs = xs.tail) {
<b class="nc"><i>2645</i>&nbsp;            typevars.enter(xs.head.tsym);</b>
<b class="nc"><i>2646</i>&nbsp;        }</b>
<b class="nc"><i>2647</i>&nbsp;    }</b>
<b class="nc"><i>2648</i>&nbsp;</b>
<b class="nc"><i>2649</i>&nbsp;    protected ClassSymbol enterClass(Name name) {</b>
<b class="nc"><i>2650</i>&nbsp;        if (syms.proprietaryType.tsym.flatName() == name)</b>
<b class="nc"><i>2651</i>&nbsp;            return (ClassSymbol) syms.proprietaryType.tsym;</b>
<b class="nc"><i>2652</i>&nbsp;        return syms.enterClass(currentModule, name);</b>
<i>2653</i>&nbsp;    }
<b class="nc"><i>2654</i>&nbsp;</b>
<i>2655</i>&nbsp;    protected ClassSymbol enterClass(Name name, TypeSymbol owner) {
<i>2656</i>&nbsp;        return syms.enterClass(currentModule, name, owner);
<i>2657</i>&nbsp;    }
<i>2658</i>&nbsp;
<i>2659</i>&nbsp;    /** Read contents of a given class symbol `c&#39;. Both external and internal
<b class="nc"><i>2660</i>&nbsp;     *  versions of an inner class are read.</b>
<i>2661</i>&nbsp;     */
<i>2662</i>&nbsp;    void readClass(ClassSymbol c) {
<i>2663</i>&nbsp;        ClassType ct = (ClassType)c.type;
<i>2664</i>&nbsp;
<i>2665</i>&nbsp;        // allocate scope for members
<i>2666</i>&nbsp;        c.members_field = WriteableScope.create(c);
<i>2667</i>&nbsp;
<i>2668</i>&nbsp;        // prepare type variable table
<b class="nc"><i>2669</i>&nbsp;        typevars = typevars.dup(currentOwner);</b>
<b class="nc"><i>2670</i>&nbsp;        if (ct.getEnclosingType().hasTag(CLASS))</b>
<b class="nc"><i>2671</i>&nbsp;            enterTypevars(c.owner, ct.getEnclosingType());</b>
<b class="nc"><i>2672</i>&nbsp;</b>
<i>2673</i>&nbsp;        // read flags, or skip if this is an inner class
<b class="nc"><i>2674</i>&nbsp;        long f = nextChar();</b>
<b class="nc"><i>2675</i>&nbsp;        long flags = adjustClassFlags(f);</b>
<i>2676</i>&nbsp;        if ((flags &amp; MODULE) == 0) {
<b class="nc"><i>2677</i>&nbsp;            if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;</b>
<b class="nc"><i>2678</i>&nbsp;            // read own class name and check that it matches</b>
<b class="nc"><i>2679</i>&nbsp;            currentModule = c.packge().modle;</b>
<b class="nc"><i>2680</i>&nbsp;            ClassSymbol self = readClassSymbol(nextChar());</b>
<b class="nc"><i>2681</i>&nbsp;            if (c != self) {</b>
<b class="nc"><i>2682</i>&nbsp;                throw badClassFile(&quot;class.file.wrong.class&quot;,</b>
<i>2683</i>&nbsp;                                   self.flatname);
<b class="nc"><i>2684</i>&nbsp;            }</b>
<b class="nc"><i>2685</i>&nbsp;        } else {</b>
<b class="nc"><i>2686</i>&nbsp;            if (majorVersion &lt; Version.V53.major) {</b>
<b class="nc"><i>2687</i>&nbsp;                throw badClassFile(&quot;anachronistic.module.info&quot;,</b>
<b class="nc"><i>2688</i>&nbsp;                        Integer.toString(majorVersion),</b>
<b class="nc"><i>2689</i>&nbsp;                        Integer.toString(minorVersion));</b>
<b class="nc"><i>2690</i>&nbsp;            }</b>
<i>2691</i>&nbsp;            c.flags_field = flags;
<b class="nc"><i>2692</i>&nbsp;            currentModule = (ModuleSymbol) c.owner;</b>
<b class="nc"><i>2693</i>&nbsp;            int this_class = nextChar();</b>
<i>2694</i>&nbsp;            // temp, no check on this_class
<b class="nc"><i>2695</i>&nbsp;        }</b>
<i>2696</i>&nbsp;
<i>2697</i>&nbsp;        // class attributes must be read before class
<i>2698</i>&nbsp;        // skip ahead to read class attributes
<i>2699</i>&nbsp;        int startbp = bp;
<b class="nc"><i>2700</i>&nbsp;        nextChar();</b>
<b class="nc"><i>2701</i>&nbsp;        char interfaceCount = nextChar();</b>
<i>2702</i>&nbsp;        bp += interfaceCount * 2;
<b class="nc"><i>2703</i>&nbsp;        char fieldCount = nextChar();</b>
<i>2704</i>&nbsp;        for (int i = 0; i &lt; fieldCount; i++) skipMember();
<i>2705</i>&nbsp;        char methodCount = nextChar();
<i>2706</i>&nbsp;        for (int i = 0; i &lt; methodCount; i++) skipMember();
<i>2707</i>&nbsp;        readClassAttrs(c);
<i>2708</i>&nbsp;
<i>2709</i>&nbsp;        if (readAllOfClassFile) {
<i>2710</i>&nbsp;            for (int i = 1; i &lt; poolObj.length; i++) readPool(i);
<i>2711</i>&nbsp;            c.pool = new Pool(poolObj.length, poolObj, types);
<i>2712</i>&nbsp;        }
<b class="nc"><i>2713</i>&nbsp;</b>
<b class="nc"><i>2714</i>&nbsp;        // reset and read rest of classinfo</b>
<i>2715</i>&nbsp;        bp = startbp;
<b class="nc"><i>2716</i>&nbsp;        int n = nextChar();</b>
<b class="nc"><i>2717</i>&nbsp;        if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {</b>
<i>2718</i>&nbsp;            throw badClassFile(&quot;module.info.invalid.super.class&quot;);
<i>2719</i>&nbsp;        }
<b class="nc"><i>2720</i>&nbsp;        if (ct.supertype_field == null)</b>
<i>2721</i>&nbsp;            ct.supertype_field = (n == 0)
<i>2722</i>&nbsp;                ? Type.noType
<i>2723</i>&nbsp;                : readClassSymbol(n).erasure(types);
<i>2724</i>&nbsp;        n = nextChar();
<i>2725</i>&nbsp;        List&lt;Type&gt; is = List.nil();
<i>2726</i>&nbsp;        for (int i = 0; i &lt; n; i++) {
<i>2727</i>&nbsp;            Type _inter = readClassSymbol(nextChar()).erasure(types);
<b class="nc"><i>2728</i>&nbsp;            is = is.prepend(_inter);</b>
<i>2729</i>&nbsp;        }
<i>2730</i>&nbsp;        if (ct.interfaces_field == null)
<i>2731</i>&nbsp;            ct.interfaces_field = is.reverse();
<i>2732</i>&nbsp;
<i>2733</i>&nbsp;        Assert.check(fieldCount == nextChar());
<i>2734</i>&nbsp;        for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
<i>2735</i>&nbsp;        Assert.check(methodCount == nextChar());
<i>2736</i>&nbsp;        for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
<i>2737</i>&nbsp;
<i>2738</i>&nbsp;        typevars = typevars.leave();
<b class="nc"><i>2739</i>&nbsp;    }</b>
<i>2740</i>&nbsp;
<i>2741</i>&nbsp;    /** Read inner class info. For each inner/outer pair allocate a
<i>2742</i>&nbsp;     *  member class.
<i>2743</i>&nbsp;     */
<b class="nc"><i>2744</i>&nbsp;    void readInnerClasses(ClassSymbol c) {</b>
<b class="nc"><i>2745</i>&nbsp;        int n = nextChar();</b>
<i>2746</i>&nbsp;        for (int i = 0; i &lt; n; i++) {
<b class="nc"><i>2747</i>&nbsp;            nextChar(); // skip inner class symbol</b>
<i>2748</i>&nbsp;            ClassSymbol outer = readClassSymbol(nextChar());
<b class="nc"><i>2749</i>&nbsp;            Name name = readName(nextChar());</b>
<b class="nc"><i>2750</i>&nbsp;            if (name == null) name = names.empty;</b>
<i>2751</i>&nbsp;            long flags = adjustClassFlags(nextChar());
<b class="nc"><i>2752</i>&nbsp;            if (outer != null) { // we have a member class</b>
<i>2753</i>&nbsp;                if (name == names.empty)
<i>2754</i>&nbsp;                    name = names.one;
<b class="nc"><i>2755</i>&nbsp;                ClassSymbol member = enterClass(name, outer);</b>
<b class="nc"><i>2756</i>&nbsp;                if ((flags &amp; STATIC) == 0) {</b>
<b class="nc"><i>2757</i>&nbsp;                    ((ClassType)member.type).setEnclosingType(outer.type);</b>
<i>2758</i>&nbsp;                    if (member.erasure_field != null)
<b class="nc"><i>2759</i>&nbsp;                        ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));</b>
<b class="nc"><i>2760</i>&nbsp;                }</b>
<b class="nc"><i>2761</i>&nbsp;                if (c == outer) {</b>
<i>2762</i>&nbsp;                    member.flags_field = flags;
<b class="nc"><i>2763</i>&nbsp;                    enterMember(c, member);</b>
<i>2764</i>&nbsp;                }
<b class="nc"><i>2765</i>&nbsp;            }</b>
<b class="nc"><i>2766</i>&nbsp;        }</b>
<b class="nc"><i>2767</i>&nbsp;    }</b>
<b class="nc"><i>2768</i>&nbsp;</b>
<b class="nc"><i>2769</i>&nbsp;    /** Read a class definition from the bytes in buf.</b>
<b class="nc"><i>2770</i>&nbsp;     */</b>
<b class="nc"><i>2771</i>&nbsp;    private void readClassBuffer(ClassSymbol c) throws IOException {</b>
<b class="nc"><i>2772</i>&nbsp;        int magic = nextInt();</b>
<b class="nc"><i>2773</i>&nbsp;        if (magic != JAVA_MAGIC)</b>
<b class="nc"><i>2774</i>&nbsp;            throw badClassFile(&quot;illegal.start.of.class.file&quot;);</b>
<b class="nc"><i>2775</i>&nbsp;</b>
<b class="nc"><i>2776</i>&nbsp;        minorVersion = nextChar();</b>
<b class="nc"><i>2777</i>&nbsp;        majorVersion = nextChar();</b>
<b class="nc"><i>2778</i>&nbsp;        int maxMajor = Version.MAX().major;</b>
<b class="nc"><i>2779</i>&nbsp;        int maxMinor = Version.MAX().minor;</b>
<i>2780</i>&nbsp;        if (majorVersion &gt; maxMajor ||
<b class="nc"><i>2781</i>&nbsp;            majorVersion * 1000 + minorVersion &lt;</b>
<b class="nc"><i>2782</i>&nbsp;            Version.MIN().major * 1000 + Version.MIN().minor) {</b>
<b class="nc"><i>2783</i>&nbsp;            if (majorVersion == (maxMajor + 1))</b>
<b class="nc"><i>2784</i>&nbsp;                log.warning(Warnings.BigMajorVersion(currentClassFile,</b>
<b class="nc"><i>2785</i>&nbsp;                                                     majorVersion,</b>
<b class="nc"><i>2786</i>&nbsp;                                                     maxMajor));</b>
<b class="nc"><i>2787</i>&nbsp;            else</b>
<b class="nc"><i>2788</i>&nbsp;                throw badClassFile(&quot;wrong.version&quot;,</b>
<b class="nc"><i>2789</i>&nbsp;                                   Integer.toString(majorVersion),</b>
<i>2790</i>&nbsp;                                   Integer.toString(minorVersion),
<i>2791</i>&nbsp;                                   Integer.toString(maxMajor),
<i>2792</i>&nbsp;                                   Integer.toString(maxMinor));
<i>2793</i>&nbsp;        }
<b class="nc"><i>2794</i>&nbsp;</b>
<b class="nc"><i>2795</i>&nbsp;        if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {</b>
<b class="nc"><i>2796</i>&nbsp;            if (!preview.isEnabled()) {</b>
<i>2797</i>&nbsp;                log.error(preview.disabledError(currentClassFile, majorVersion));
<i>2798</i>&nbsp;            } else {
<i>2799</i>&nbsp;                preview.warnPreview(c.classfile, majorVersion);
<i>2800</i>&nbsp;            }
<b class="nc"><i>2801</i>&nbsp;        }</b>
<b class="nc"><i>2802</i>&nbsp;</b>
<b class="nc"><i>2803</i>&nbsp;        indexPool();</b>
<i>2804</i>&nbsp;        if (signatureBuffer.length &lt; bp) {
<i>2805</i>&nbsp;            int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
<i>2806</i>&nbsp;            signatureBuffer = new byte[ns];
<b class="nc"><i>2807</i>&nbsp;        }</b>
<b class="nc"><i>2808</i>&nbsp;        readClass(c);</b>
<b class="nc"><i>2809</i>&nbsp;    }</b>
<i>2810</i>&nbsp;
<i>2811</i>&nbsp;    public void readClassFile(ClassSymbol c) {
<i>2812</i>&nbsp;        currentOwner = c;
<i>2813</i>&nbsp;        currentClassFile = c.classfile;
<b class="nc"><i>2814</i>&nbsp;        warnedAttrs.clear();</b>
<i>2815</i>&nbsp;        filling = true;
<i>2816</i>&nbsp;        target = null;
<i>2817</i>&nbsp;        repeatable = null;
<i>2818</i>&nbsp;        try {
<i>2819</i>&nbsp;            bp = 0;
<i>2820</i>&nbsp;            buf = readInputStream(buf, c.classfile.openInputStream());
<b class="nc"><i>2821</i>&nbsp;            readClassBuffer(c);</b>
<b class="nc"><i>2822</i>&nbsp;            if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {</b>
<b class="nc"><i>2823</i>&nbsp;                List&lt;Type&gt; missing = missingTypeVariables;</b>
<i>2824</i>&nbsp;                List&lt;Type&gt; found = foundTypeVariables;
<i>2825</i>&nbsp;                missingTypeVariables = List.nil();
<i>2826</i>&nbsp;                foundTypeVariables = List.nil();
<b class="nc"><i>2827</i>&nbsp;                interimUses = List.nil();</b>
<b class="nc"><i>2828</i>&nbsp;                interimProvides = List.nil();</b>
<b class="nc"><i>2829</i>&nbsp;                filling = false;</b>
<b class="nc"><i>2830</i>&nbsp;                ClassType ct = (ClassType)currentOwner.type;</b>
<b class="nc"><i>2831</i>&nbsp;                ct.supertype_field =</b>
<i>2832</i>&nbsp;                    types.subst(ct.supertype_field, missing, found);
<i>2833</i>&nbsp;                ct.interfaces_field =
<i>2834</i>&nbsp;                    types.subst(ct.interfaces_field, missing, found);
<b class="nc"><i>2835</i>&nbsp;                ct.typarams_field =</b>
<i>2836</i>&nbsp;                    types.substBounds(ct.typarams_field, missing, found);
<b class="nc"><i>2837</i>&nbsp;                for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {</b>
<i>2838</i>&nbsp;                    types.head.tsym.type = types.head;
<i>2839</i>&nbsp;                }
<i>2840</i>&nbsp;            } else if (missingTypeVariables.isEmpty() !=
<i>2841</i>&nbsp;                       foundTypeVariables.isEmpty()) {
<i>2842</i>&nbsp;                Name name = missingTypeVariables.head.tsym.name;
<i>2843</i>&nbsp;                throw badClassFile(&quot;undecl.type.var&quot;, name);
<i>2844</i>&nbsp;            }
<b class="nc"><i>2845</i>&nbsp;</b>
<i>2846</i>&nbsp;            if ((c.flags_field &amp; Flags.ANNOTATION) != 0) {
<i>2847</i>&nbsp;                c.setAnnotationTypeMetadata(new AnnotationTypeMetadata(c, new CompleterDeproxy(c, target, repeatable)));
<i>2848</i>&nbsp;            } else {
<i>2849</i>&nbsp;                c.setAnnotationTypeMetadata(AnnotationTypeMetadata.notAnAnnotationType());
<i>2850</i>&nbsp;            }
<i>2851</i>&nbsp;
<i>2852</i>&nbsp;            if (c == currentModule.module_info) {
<i>2853</i>&nbsp;                if (interimUses.nonEmpty() || interimProvides.nonEmpty()) {
<i>2854</i>&nbsp;                    Assert.check(currentModule.isCompleted());
<i>2855</i>&nbsp;                    currentModule.usesProvidesCompleter =
<i>2856</i>&nbsp;                            new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
<i>2857</i>&nbsp;                } else {
<i>2858</i>&nbsp;                    currentModule.uses = List.nil();
<i>2859</i>&nbsp;                    currentModule.provides = List.nil();
<i>2860</i>&nbsp;                }
<i>2861</i>&nbsp;            }
<i>2862</i>&nbsp;        } catch (IOException | ClosedFileSystemException ex) {
<i>2863</i>&nbsp;            throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
<i>2864</i>&nbsp;        } catch (ArrayIndexOutOfBoundsException ex) {
<i>2865</i>&nbsp;            throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
<i>2866</i>&nbsp;        } finally {
<i>2867</i>&nbsp;            interimUses = List.nil();
<b class="nc"><i>2868</i>&nbsp;            interimProvides = List.nil();</b>
<b class="nc"><i>2869</i>&nbsp;            missingTypeVariables = List.nil();</b>
<b class="nc"><i>2870</i>&nbsp;            foundTypeVariables = List.nil();</b>
<i>2871</i>&nbsp;            filling = false;
<i>2872</i>&nbsp;        }
<i>2873</i>&nbsp;    }
<i>2874</i>&nbsp;    // where
<i>2875</i>&nbsp;        private static byte[] readInputStream(byte[] buf, InputStream s) throws IOException {
<b class="nc"><i>2876</i>&nbsp;            try {</b>
<b class="nc"><i>2877</i>&nbsp;                buf = ensureCapacity(buf, s.available());</b>
<b class="nc"><i>2878</i>&nbsp;                int r = s.read(buf);</b>
<i>2879</i>&nbsp;                int bp = 0;
<i>2880</i>&nbsp;                while (r != -1) {
<i>2881</i>&nbsp;                    bp += r;
<i>2882</i>&nbsp;                    buf = ensureCapacity(buf, bp);
<i>2883</i>&nbsp;                    r = s.read(buf, bp, buf.length - bp);
<b class="nc"><i>2884</i>&nbsp;                }</b>
<i>2885</i>&nbsp;                return buf;
<i>2886</i>&nbsp;            } finally {
<i>2887</i>&nbsp;                try {
<i>2888</i>&nbsp;                    s.close();
<b class="nc"><i>2889</i>&nbsp;                } catch (IOException e) {</b>
<i>2890</i>&nbsp;                    /* Ignore any errors, as this stream may have already
<i>2891</i>&nbsp;                     * thrown a related exception which is the one that
<i>2892</i>&nbsp;                     * should be reported.
<i>2893</i>&nbsp;                     */
<b class="nc"><i>2894</i>&nbsp;                }</b>
<i>2895</i>&nbsp;            }
<i>2896</i>&nbsp;        }
<i>2897</i>&nbsp;        /*
<i>2898</i>&nbsp;         * ensureCapacity will increase the buffer as needed, taking note that
<b class="nc"><i>2899</i>&nbsp;         * the new buffer will always be greater than the needed and never</b>
<i>2900</i>&nbsp;         * exactly equal to the needed size or bp. If equal then the read (above)
<i>2901</i>&nbsp;         * will infinitely loop as buf.length - bp == 0.
<i>2902</i>&nbsp;         */
<i>2903</i>&nbsp;        private static byte[] ensureCapacity(byte[] buf, int needed) {
<b class="nc"><i>2904</i>&nbsp;            if (buf.length &lt;= needed) {</b>
<i>2905</i>&nbsp;                byte[] old = buf;
<i>2906</i>&nbsp;                buf = new byte[Integer.highestOneBit(needed) &lt;&lt; 1];
<i>2907</i>&nbsp;                System.arraycopy(old, 0, buf, 0, old.length);
<i>2908</i>&nbsp;            }
<b class="nc"><i>2909</i>&nbsp;            return buf;</b>
<i>2910</i>&nbsp;        }
<i>2911</i>&nbsp;
<i>2912</i>&nbsp;    /** We can only read a single class file at a time; this
<i>2913</i>&nbsp;     *  flag keeps track of when we are currently reading a class
<b class="nc"><i>2914</i>&nbsp;     *  file.</b>
<i>2915</i>&nbsp;     */
<i>2916</i>&nbsp;    public boolean filling = false;
<i>2917</i>&nbsp;
<i>2918</i>&nbsp;/************************************************************************
<b class="nc"><i>2919</i>&nbsp; * Adjusting flags</b>
<i>2920</i>&nbsp; ***********************************************************************/
<i>2921</i>&nbsp;
<i>2922</i>&nbsp;    long adjustFieldFlags(long flags) {
<i>2923</i>&nbsp;        return flags;
<b class="nc"><i>2924</i>&nbsp;    }</b>
<i>2925</i>&nbsp;
<i>2926</i>&nbsp;    long adjustMethodFlags(long flags) {
<i>2927</i>&nbsp;        if ((flags &amp; ACC_BRIDGE) != 0) {
<i>2928</i>&nbsp;            flags &amp;= ~ACC_BRIDGE;
<b class="nc"><i>2929</i>&nbsp;            flags |= BRIDGE;</b>
<i>2930</i>&nbsp;        }
<i>2931</i>&nbsp;        if ((flags &amp; ACC_VARARGS) != 0) {
<i>2932</i>&nbsp;            flags &amp;= ~ACC_VARARGS;
<i>2933</i>&nbsp;            flags |= VARARGS;
<b class="nc"><i>2934</i>&nbsp;        }</b>
<i>2935</i>&nbsp;        return flags;
<i>2936</i>&nbsp;    }
<i>2937</i>&nbsp;
<i>2938</i>&nbsp;    long adjustClassFlags(long flags) {
<b class="nc"><i>2939</i>&nbsp;        if ((flags &amp; ACC_MODULE) != 0) {</b>
<i>2940</i>&nbsp;            flags &amp;= ~ACC_MODULE;
<i>2941</i>&nbsp;            flags |= MODULE;
<i>2942</i>&nbsp;        }
<i>2943</i>&nbsp;        return flags &amp; ~ACC_SUPER; // SUPER and SYNCHRONIZED bits overloaded
<i>2944</i>&nbsp;    }
<i>2945</i>&nbsp;
<i>2946</i>&nbsp;    /**
<i>2947</i>&nbsp;     * A subclass of JavaFileObject for the sourcefile attribute found in a classfile.
<i>2948</i>&nbsp;     * The attribute is only the last component of the original filename, so is unlikely
<i>2949</i>&nbsp;     * to be valid as is, so operations other than those to access the name throw
<b class="nc"><i>2950</i>&nbsp;     * UnsupportedOperationException</b>
<b class="nc"><i>2951</i>&nbsp;     */</b>
<i>2952</i>&nbsp;    private static class SourceFileObject implements JavaFileObject {
<b class="nc"><i>2953</i>&nbsp;</b>
<b class="nc"><i>2954</i>&nbsp;        /** The file&#39;s name.</b>
<i>2955</i>&nbsp;         */
<b class="nc"><i>2956</i>&nbsp;        private final Name name;</b>
<b class="nc"><i>2957</i>&nbsp;        private final Name flatname;</b>
<i>2958</i>&nbsp;
<i>2959</i>&nbsp;        public SourceFileObject(Name name, Name flatname) {
<i>2960</i>&nbsp;            this.name = name;
<i>2961</i>&nbsp;            this.flatname = flatname;
<b class="nc"><i>2962</i>&nbsp;        }</b>
<i>2963</i>&nbsp;
<i>2964</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2965</i>&nbsp;        public URI toUri() {
<i>2966</i>&nbsp;            try {
<i>2967</i>&nbsp;                return new URI(null, name.toString(), null);
<i>2968</i>&nbsp;            } catch (URISyntaxException e) {
<i>2969</i>&nbsp;                throw new PathFileObject.CannotCreateUriError(name.toString(), e);
<i>2970</i>&nbsp;            }
<i>2971</i>&nbsp;        }
<i>2972</i>&nbsp;
<i>2973</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2974</i>&nbsp;        public String getName() {
<i>2975</i>&nbsp;            return name.toString();
<i>2976</i>&nbsp;        }
<i>2977</i>&nbsp;
<i>2978</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2979</i>&nbsp;        public JavaFileObject.Kind getKind() {
<i>2980</i>&nbsp;            return BaseFileManager.getKind(getName());
<i>2981</i>&nbsp;        }
<i>2982</i>&nbsp;
<i>2983</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2984</i>&nbsp;        public InputStream openInputStream() {
<i>2985</i>&nbsp;            throw new UnsupportedOperationException();
<i>2986</i>&nbsp;        }
<i>2987</i>&nbsp;
<i>2988</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2989</i>&nbsp;        public OutputStream openOutputStream() {
<i>2990</i>&nbsp;            throw new UnsupportedOperationException();
<i>2991</i>&nbsp;        }
<i>2992</i>&nbsp;
<i>2993</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2994</i>&nbsp;        public CharBuffer getCharContent(boolean ignoreEncodingErrors) {
<i>2995</i>&nbsp;            throw new UnsupportedOperationException();
<i>2996</i>&nbsp;        }
<i>2997</i>&nbsp;
<i>2998</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>2999</i>&nbsp;        public Reader openReader(boolean ignoreEncodingErrors) {
<i>3000</i>&nbsp;            throw new UnsupportedOperationException();
<i>3001</i>&nbsp;        }
<i>3002</i>&nbsp;
<i>3003</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3004</i>&nbsp;        public Writer openWriter() {
<i>3005</i>&nbsp;            throw new UnsupportedOperationException();
<i>3006</i>&nbsp;        }
<i>3007</i>&nbsp;
<i>3008</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3009</i>&nbsp;        public long getLastModified() {
<i>3010</i>&nbsp;            throw new UnsupportedOperationException();
<i>3011</i>&nbsp;        }
<i>3012</i>&nbsp;
<i>3013</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3014</i>&nbsp;        public boolean delete() {
<i>3015</i>&nbsp;            throw new UnsupportedOperationException();
<i>3016</i>&nbsp;        }
<i>3017</i>&nbsp;
<i>3018</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3019</i>&nbsp;        public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {
<i>3020</i>&nbsp;            return true; // fail-safe mode
<i>3021</i>&nbsp;        }
<i>3022</i>&nbsp;
<i>3023</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3024</i>&nbsp;        public NestingKind getNestingKind() {
<i>3025</i>&nbsp;            return null;
<i>3026</i>&nbsp;        }
<i>3027</i>&nbsp;
<i>3028</i>&nbsp;        @Override @DefinedBy(Api.COMPILER)
<i>3029</i>&nbsp;        public Modifier getAccessLevel() {
<i>3030</i>&nbsp;            return null;
<i>3031</i>&nbsp;        }
<i>3032</i>&nbsp;
<i>3033</i>&nbsp;        /**
<i>3034</i>&nbsp;         * Check if two file objects are equal.
<i>3035</i>&nbsp;         * SourceFileObjects are just placeholder objects for the value of a
<i>3036</i>&nbsp;         * SourceFile attribute, and do not directly represent specific files.
<i>3037</i>&nbsp;         * Two SourceFileObjects are equal if their names are equal.
<i>3038</i>&nbsp;         */
<i>3039</i>&nbsp;        @Override
<i>3040</i>&nbsp;        public boolean equals(Object other) {
<i>3041</i>&nbsp;            if (this == other)
<i>3042</i>&nbsp;                return true;
<i>3043</i>&nbsp;
<i>3044</i>&nbsp;            if (!(other instanceof SourceFileObject))
<i>3045</i>&nbsp;                return false;
<i>3046</i>&nbsp;
<i>3047</i>&nbsp;            SourceFileObject o = (SourceFileObject) other;
<i>3048</i>&nbsp;            return name.equals(o.name);
<i>3049</i>&nbsp;        }
<i>3050</i>&nbsp;
<i>3051</i>&nbsp;        @Override
<i>3052</i>&nbsp;        public int hashCode() {
<i>3053</i>&nbsp;            return name.hashCode();
<i>3054</i>&nbsp;        }
<i>3055</i>&nbsp;    }
<i>3056</i>&nbsp;
<i>3057</i>&nbsp;    private class CompleterDeproxy implements AnnotationTypeCompleter {
<i>3058</i>&nbsp;        ClassSymbol proxyOn;
<i>3059</i>&nbsp;        CompoundAnnotationProxy target;
<i>3060</i>&nbsp;        CompoundAnnotationProxy repeatable;
<i>3061</i>&nbsp;
<i>3062</i>&nbsp;        public CompleterDeproxy(ClassSymbol c, CompoundAnnotationProxy target,
<i>3063</i>&nbsp;                CompoundAnnotationProxy repeatable)
<i>3064</i>&nbsp;        {
<i>3065</i>&nbsp;            this.proxyOn = c;
<i>3066</i>&nbsp;            this.target = target;
<i>3067</i>&nbsp;            this.repeatable = repeatable;
<i>3068</i>&nbsp;        }
<i>3069</i>&nbsp;
<i>3070</i>&nbsp;        @Override
<i>3071</i>&nbsp;        public void complete(ClassSymbol sym) {
<i>3072</i>&nbsp;            Assert.check(proxyOn == sym);
<i>3073</i>&nbsp;            Attribute.Compound theTarget = null, theRepeatable = null;
<i>3074</i>&nbsp;            AnnotationDeproxy deproxy;
<i>3075</i>&nbsp;
<i>3076</i>&nbsp;            try {
<i>3077</i>&nbsp;                if (target != null) {
<i>3078</i>&nbsp;                    deproxy = new AnnotationDeproxy(proxyOn);
<i>3079</i>&nbsp;                    theTarget = deproxy.deproxyCompound(target);
<i>3080</i>&nbsp;                }
<i>3081</i>&nbsp;
<i>3082</i>&nbsp;                if (repeatable != null) {
<i>3083</i>&nbsp;                    deproxy = new AnnotationDeproxy(proxyOn);
<i>3084</i>&nbsp;                    theRepeatable = deproxy.deproxyCompound(repeatable);
<i>3085</i>&nbsp;                }
<i>3086</i>&nbsp;            } catch (Exception e) {
<i>3087</i>&nbsp;                throw new CompletionFailure(sym,
<i>3088</i>&nbsp;                                            ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),
<i>3089</i>&nbsp;                                            dcfh);
<i>3090</i>&nbsp;            }
<i>3091</i>&nbsp;
<i>3092</i>&nbsp;            sym.getAnnotationTypeMetadata().setTarget(theTarget);
<i>3093</i>&nbsp;            sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
<i>3094</i>&nbsp;        }
<i>3095</i>&nbsp;    }
<i>3096</i>&nbsp;
<i>3097</i>&nbsp;    private class ProxyType extends Type {
<i>3098</i>&nbsp;
<i>3099</i>&nbsp;        private final byte[] content;
<i>3100</i>&nbsp;
<i>3101</i>&nbsp;        public ProxyType(byte[] content) {
<i>3102</i>&nbsp;            super(syms.noSymbol, TypeMetadata.EMPTY);
<i>3103</i>&nbsp;            this.content = content;
<i>3104</i>&nbsp;        }
<i>3105</i>&nbsp;
<i>3106</i>&nbsp;        @Override
<i>3107</i>&nbsp;        public TypeTag getTag() {
<i>3108</i>&nbsp;            return TypeTag.NONE;
<i>3109</i>&nbsp;        }
<i>3110</i>&nbsp;
<i>3111</i>&nbsp;        @Override
<i>3112</i>&nbsp;        public Type cloneWithMetadata(TypeMetadata metadata) {
<i>3113</i>&nbsp;            throw new UnsupportedOperationException();
<i>3114</i>&nbsp;        }
<i>3115</i>&nbsp;
<i>3116</i>&nbsp;        public Type resolve() {
<i>3117</i>&nbsp;            return sigToType(content, 0, content.length);
<i>3118</i>&nbsp;        }
<i>3119</i>&nbsp;
<i>3120</i>&nbsp;        @Override @DefinedBy(Api.LANGUAGE_MODEL)
<i>3121</i>&nbsp;        public String toString() {
<i>3122</i>&nbsp;            return &quot;&lt;ProxyType&gt;&quot;;
<i>3123</i>&nbsp;        }
<i>3124</i>&nbsp;
<i>3125</i>&nbsp;    }
<i>3126</i>&nbsp;
<i>3127</i>&nbsp;    private static final class InterimUsesDirective {
<i>3128</i>&nbsp;        public final Name service;
<i>3129</i>&nbsp;
<i>3130</i>&nbsp;        public InterimUsesDirective(Name service) {
<i>3131</i>&nbsp;            this.service = service;
<i>3132</i>&nbsp;        }
<i>3133</i>&nbsp;
<i>3134</i>&nbsp;    }
<i>3135</i>&nbsp;
<i>3136</i>&nbsp;    private static final class InterimProvidesDirective {
<i>3137</i>&nbsp;        public final Name service;
<i>3138</i>&nbsp;        public final List&lt;Name&gt; impls;
<i>3139</i>&nbsp;
<i>3140</i>&nbsp;        public InterimProvidesDirective(Name service, List&lt;Name&gt; impls) {
<i>3141</i>&nbsp;            this.service = service;
<i>3142</i>&nbsp;            this.impls = impls;
<i>3143</i>&nbsp;        }
<i>3144</i>&nbsp;
<i>3145</i>&nbsp;    }
<i>3146</i>&nbsp;
<i>3147</i>&nbsp;    private final class UsesProvidesCompleter implements Completer {
<i>3148</i>&nbsp;        private final ModuleSymbol currentModule;
<i>3149</i>&nbsp;        private final List&lt;InterimUsesDirective&gt; interimUsesCopy;
<i>3150</i>&nbsp;        private final List&lt;InterimProvidesDirective&gt; interimProvidesCopy;
<i>3151</i>&nbsp;
<i>3152</i>&nbsp;        public UsesProvidesCompleter(ModuleSymbol currentModule, List&lt;InterimUsesDirective&gt; interimUsesCopy, List&lt;InterimProvidesDirective&gt; interimProvidesCopy) {
<i>3153</i>&nbsp;            this.currentModule = currentModule;
<i>3154</i>&nbsp;            this.interimUsesCopy = interimUsesCopy;
<i>3155</i>&nbsp;            this.interimProvidesCopy = interimProvidesCopy;
<i>3156</i>&nbsp;        }
<i>3157</i>&nbsp;
<i>3158</i>&nbsp;        @Override
<i>3159</i>&nbsp;        public void complete(Symbol sym) throws CompletionFailure {
<i>3160</i>&nbsp;            ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
<i>3161</i>&nbsp;            directives.addAll(currentModule.directives);
<i>3162</i>&nbsp;            ListBuffer&lt;UsesDirective&gt; uses = new ListBuffer&lt;&gt;();
<i>3163</i>&nbsp;            for (InterimUsesDirective interim : interimUsesCopy) {
<i>3164</i>&nbsp;                UsesDirective d = new UsesDirective(syms.enterClass(currentModule, interim.service));
<i>3165</i>&nbsp;                uses.add(d);
<i>3166</i>&nbsp;                directives.add(d);
<i>3167</i>&nbsp;            }
<i>3168</i>&nbsp;            currentModule.uses = uses.toList();
<i>3169</i>&nbsp;            ListBuffer&lt;ProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
<i>3170</i>&nbsp;            for (InterimProvidesDirective interim : interimProvidesCopy) {
<i>3171</i>&nbsp;                ListBuffer&lt;ClassSymbol&gt; impls = new ListBuffer&lt;&gt;();
<i>3172</i>&nbsp;                for (Name impl : interim.impls) {
<i>3173</i>&nbsp;                    impls.append(syms.enterClass(currentModule, impl));
<i>3174</i>&nbsp;                }
<i>3175</i>&nbsp;                ProvidesDirective d = new ProvidesDirective(syms.enterClass(currentModule, interim.service),
<i>3176</i>&nbsp;                                                            impls.toList());
<i>3177</i>&nbsp;                provides.add(d);
<i>3178</i>&nbsp;                directives.add(d);
<i>3179</i>&nbsp;            }
<i>3180</i>&nbsp;            currentModule.provides = provides.toList();
<i>3181</i>&nbsp;            currentModule.directives = directives.toList();
<i>3182</i>&nbsp;        }
<i>3183</i>&nbsp;    }
<i>3184</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
