


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ObjectName</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.management</a> ]
</div>

<h1>Coverage Summary for Class: ObjectName (javax.management)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ObjectName</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 490)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ObjectName$PatternProperty</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectName$Property</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 500)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javax.management;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.jmx.mbeanserver.GetPropertyAction;
<i>29</i>&nbsp;import com.sun.jmx.mbeanserver.Util;
<i>30</i>&nbsp;import java.io.IOException;
<i>31</i>&nbsp;import java.io.InvalidObjectException;
<i>32</i>&nbsp;import java.io.ObjectInputStream;
<i>33</i>&nbsp;import java.io.ObjectOutputStream;
<i>34</i>&nbsp;import java.io.ObjectStreamField;
<i>35</i>&nbsp;import java.security.AccessController;
<i>36</i>&nbsp;import java.util.Arrays;
<i>37</i>&nbsp;import java.util.Collections;
<i>38</i>&nbsp;import java.util.HashMap;
<i>39</i>&nbsp;import java.util.Hashtable;
<i>40</i>&nbsp;import java.util.Map;
<i>41</i>&nbsp;
<i>42</i>&nbsp;/**
<i>43</i>&nbsp; * &lt;p&gt;Represents the object name of an MBean, or a pattern that can
<i>44</i>&nbsp; * match the names of several MBeans.  Instances of this class are
<i>45</i>&nbsp; * immutable.&lt;/p&gt;
<i>46</i>&nbsp; *
<i>47</i>&nbsp; * &lt;p&gt;An instance of this class can be used to represent:&lt;/p&gt;
<i>48</i>&nbsp; * &lt;ul&gt;
<i>49</i>&nbsp; * &lt;li&gt;An object name&lt;/li&gt;
<i>50</i>&nbsp; * &lt;li&gt;An object name pattern, within the context of a query&lt;/li&gt;
<i>51</i>&nbsp; * &lt;/ul&gt;
<i>52</i>&nbsp; *
<i>53</i>&nbsp; * &lt;p&gt;An object name consists of two parts, the domain and the key
<i>54</i>&nbsp; * properties.&lt;/p&gt;
<i>55</i>&nbsp; *
<i>56</i>&nbsp; * &lt;p&gt;The &lt;em&gt;domain&lt;/em&gt; is a string of characters not including
<i>57</i>&nbsp; * the character colon (&lt;code&gt;:&lt;/code&gt;).  It is recommended that the domain
<i>58</i>&nbsp; * should not contain the string &quot;{@code //}&quot;, which is reserved for future use.
<i>59</i>&nbsp; *
<i>60</i>&nbsp; * &lt;p&gt;If the domain includes at least one occurrence of the wildcard
<i>61</i>&nbsp; * characters asterisk (&lt;code&gt;*&lt;/code&gt;) or question mark
<i>62</i>&nbsp; * (&lt;code&gt;?&lt;/code&gt;), then the object name is a pattern.  The asterisk
<i>63</i>&nbsp; * matches any sequence of zero or more characters, while the question
<i>64</i>&nbsp; * mark matches any single character.&lt;/p&gt;
<i>65</i>&nbsp; *
<i>66</i>&nbsp; * &lt;p&gt;If the domain is empty, it will be replaced in certain contexts
<i>67</i>&nbsp; * by the &lt;em&gt;default domain&lt;/em&gt; of the MBean server in which the
<i>68</i>&nbsp; * ObjectName is used.&lt;/p&gt;
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * &lt;p&gt;The &lt;em&gt;key properties&lt;/em&gt; are an unordered set of keys and
<i>71</i>&nbsp; * associated values.&lt;/p&gt;
<i>72</i>&nbsp; *
<i>73</i>&nbsp; * &lt;p&gt;Each &lt;em&gt;key&lt;/em&gt; is a nonempty string of characters which may
<i>74</i>&nbsp; * not contain any of the characters comma (&lt;code&gt;,&lt;/code&gt;), equals
<i>75</i>&nbsp; * (&lt;code&gt;=&lt;/code&gt;), colon, asterisk, or question mark.  The same key
<i>76</i>&nbsp; * may not occur twice in a given ObjectName.&lt;/p&gt;
<i>77</i>&nbsp; *
<i>78</i>&nbsp; * &lt;p&gt;Each &lt;em&gt;value&lt;/em&gt; associated with a key is a string of
<i>79</i>&nbsp; * characters that is either unquoted or quoted.&lt;/p&gt;
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * &lt;p&gt;An &lt;em&gt;unquoted value&lt;/em&gt; is a possibly empty string of
<i>82</i>&nbsp; * characters which may not contain any of the characters comma,
<i>83</i>&nbsp; * equals, colon, or quote.&lt;/p&gt;
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * &lt;p&gt;If the &lt;em&gt;unquoted value&lt;/em&gt; contains at least one occurrence
<i>86</i>&nbsp; * of the wildcard characters asterisk or question mark, then the object
<i>87</i>&nbsp; * name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk matches any
<i>88</i>&nbsp; * sequence of zero or more characters, while the question mark matches
<i>89</i>&nbsp; * any single character.&lt;/p&gt;
<i>90</i>&nbsp; *
<i>91</i>&nbsp; * &lt;p&gt;A &lt;em&gt;quoted value&lt;/em&gt; consists of a quote (&lt;code&gt;&quot;&lt;/code&gt;),
<i>92</i>&nbsp; * followed by a possibly empty string of characters, followed by
<i>93</i>&nbsp; * another quote.  Within the string of characters, the backslash
<i>94</i>&nbsp; * (&lt;code&gt;\&lt;/code&gt;) has a special meaning.  It must be followed by
<i>95</i>&nbsp; * one of the following characters:&lt;/p&gt;
<i>96</i>&nbsp; *
<i>97</i>&nbsp; * &lt;ul&gt;
<i>98</i>&nbsp; * &lt;li&gt;Another backslash.  The second backslash has no special
<i>99</i>&nbsp; * meaning and the two characters represent a single backslash.&lt;/li&gt;
<i>100</i>&nbsp; *
<i>101</i>&nbsp; * &lt;li&gt;The character &#39;n&#39;.  The two characters represent a newline
<i>102</i>&nbsp; * (&#39;\n&#39; in Java).&lt;/li&gt;
<i>103</i>&nbsp; *
<i>104</i>&nbsp; * &lt;li&gt;A quote.  The two characters represent a quote, and that quote
<i>105</i>&nbsp; * is not considered to terminate the quoted value. An ending closing
<i>106</i>&nbsp; * quote must be present for the quoted value to be valid.&lt;/li&gt;
<i>107</i>&nbsp; *
<i>108</i>&nbsp; * &lt;li&gt;A question mark (?) or asterisk (*).  The two characters represent
<i>109</i>&nbsp; * a question mark or asterisk respectively.&lt;/li&gt;
<i>110</i>&nbsp; * &lt;/ul&gt;
<i>111</i>&nbsp; *
<i>112</i>&nbsp; * &lt;p&gt;A quote may not appear inside a quoted value except immediately
<i>113</i>&nbsp; * after an odd number of consecutive backslashes.&lt;/p&gt;
<i>114</i>&nbsp; *
<i>115</i>&nbsp; * &lt;p&gt;The quotes surrounding a quoted value, and any backslashes
<i>116</i>&nbsp; * within that value, are considered to be part of the value.&lt;/p&gt;
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * &lt;p&gt;If the &lt;em&gt;quoted value&lt;/em&gt; contains at least one occurrence of
<i>119</i>&nbsp; * the characters asterisk or question mark and they are not preceded
<i>120</i>&nbsp; * by a backslash, then they are considered as wildcard characters and
<i>121</i>&nbsp; * the object name is a &lt;em&gt;property value pattern&lt;/em&gt;. The asterisk
<i>122</i>&nbsp; * matches any sequence of zero or more characters, while the question
<i>123</i>&nbsp; * mark matches any single character.&lt;/p&gt;
<i>124</i>&nbsp; *
<i>125</i>&nbsp; * &lt;p&gt;An ObjectName may be a &lt;em&gt;property list pattern&lt;/em&gt;. In this
<i>126</i>&nbsp; * case it may have zero or more keys and associated values. It matches
<i>127</i>&nbsp; * a nonpattern ObjectName whose domain matches and that contains the
<i>128</i>&nbsp; * same keys and associated values, as well as possibly other keys and
<i>129</i>&nbsp; * values.&lt;/p&gt;
<i>130</i>&nbsp; *
<i>131</i>&nbsp; * &lt;p&gt;An ObjectName is a &lt;em&gt;property value pattern&lt;/em&gt; when at least
<i>132</i>&nbsp; * one of its &lt;em&gt;quoted&lt;/em&gt; or &lt;em&gt;unquoted&lt;/em&gt; key property values
<i>133</i>&nbsp; * contains the wildcard characters asterisk or question mark as described
<i>134</i>&nbsp; * above. In this case it has one or more keys and associated values, with
<i>135</i>&nbsp; * at least one of the values containing wildcard characters. It matches a
<i>136</i>&nbsp; * nonpattern ObjectName whose domain matches and that contains the same
<i>137</i>&nbsp; * keys whose values match; if the property value pattern is also a
<i>138</i>&nbsp; * property list pattern then the nonpattern ObjectName can contain
<i>139</i>&nbsp; * other keys and values.&lt;/p&gt;
<i>140</i>&nbsp; *
<i>141</i>&nbsp; * &lt;p&gt;An ObjectName is a &lt;em&gt;property pattern&lt;/em&gt; if it is either a
<i>142</i>&nbsp; * &lt;em&gt;property list pattern&lt;/em&gt; or a &lt;em&gt;property value pattern&lt;/em&gt;
<i>143</i>&nbsp; * or both.&lt;/p&gt;
<i>144</i>&nbsp; *
<i>145</i>&nbsp; * &lt;p&gt;An ObjectName is a pattern if its domain contains a wildcard or
<i>146</i>&nbsp; * if the ObjectName is a property pattern.&lt;/p&gt;
<i>147</i>&nbsp; *
<i>148</i>&nbsp; * &lt;p&gt;If an ObjectName is not a pattern, it must contain at least one
<i>149</i>&nbsp; * key with its associated value.&lt;/p&gt;
<i>150</i>&nbsp; *
<i>151</i>&nbsp; * &lt;p&gt;Examples of ObjectName patterns are:&lt;/p&gt;
<i>152</i>&nbsp; *
<i>153</i>&nbsp; * &lt;ul&gt;
<i>154</i>&nbsp; * &lt;li&gt;{@code *:type=Foo,name=Bar} to match names in any domain whose
<i>155</i>&nbsp; *     exact set of keys is {@code type=Foo,name=Bar}.&lt;/li&gt;
<i>156</i>&nbsp; * &lt;li&gt;{@code d:type=Foo,name=Bar,*} to match names in the domain
<i>157</i>&nbsp; *     {@code d} that have the keys {@code type=Foo,name=Bar} plus
<i>158</i>&nbsp; *     zero or more other keys.&lt;/li&gt;
<i>159</i>&nbsp; * &lt;li&gt;{@code *:type=Foo,name=Bar,*} to match names in any domain
<i>160</i>&nbsp; *     that has the keys {@code type=Foo,name=Bar} plus zero or
<i>161</i>&nbsp; *     more other keys.&lt;/li&gt;
<i>162</i>&nbsp; * &lt;li&gt;{@code d:type=F?o,name=Bar} will match e.g.
<i>163</i>&nbsp; *     {@code d:type=Foo,name=Bar} and {@code d:type=Fro,name=Bar}.&lt;/li&gt;
<i>164</i>&nbsp; * &lt;li&gt;{@code d:type=F*o,name=Bar} will match e.g.
<i>165</i>&nbsp; *     {@code d:type=Fo,name=Bar} and {@code d:type=Frodo,name=Bar}.&lt;/li&gt;
<i>166</i>&nbsp; * &lt;li&gt;{@code d:type=Foo,name=&quot;B*&quot;} will match e.g.
<i>167</i>&nbsp; *     {@code d:type=Foo,name=&quot;Bling&quot;}. Wildcards are recognized even
<i>168</i>&nbsp; *     inside quotes, and like other special characters can be escaped
<i>169</i>&nbsp; *     with {@code \}.&lt;/li&gt;
<i>170</i>&nbsp; * &lt;/ul&gt;
<i>171</i>&nbsp; *
<i>172</i>&nbsp; * &lt;p&gt;An ObjectName can be written as a String with the following
<i>173</i>&nbsp; * elements in order:&lt;/p&gt;
<i>174</i>&nbsp; *
<i>175</i>&nbsp; * &lt;ul&gt;
<i>176</i>&nbsp; * &lt;li&gt;The domain.
<i>177</i>&nbsp; * &lt;li&gt;A colon (&lt;code&gt;:&lt;/code&gt;).
<i>178</i>&nbsp; * &lt;li&gt;A key property list as defined below.
<i>179</i>&nbsp; * &lt;/ul&gt;
<i>180</i>&nbsp; *
<i>181</i>&nbsp; * &lt;p&gt;A key property list written as a String is a comma-separated
<i>182</i>&nbsp; * list of elements.  Each element is either an asterisk or a key
<i>183</i>&nbsp; * property.  A key property consists of a key, an equals
<i>184</i>&nbsp; * (&lt;code&gt;=&lt;/code&gt;), and the associated value.&lt;/p&gt;
<i>185</i>&nbsp; *
<i>186</i>&nbsp; * &lt;p&gt;At most one element of a key property list may be an asterisk.
<i>187</i>&nbsp; * If the key property list contains an asterisk element, the
<i>188</i>&nbsp; * ObjectName is a property list pattern.&lt;/p&gt;
<i>189</i>&nbsp; *
<i>190</i>&nbsp; * &lt;p&gt;Spaces have no special significance in a String representing an
<i>191</i>&nbsp; * ObjectName.  For example, the String:
<i>192</i>&nbsp; * &lt;pre&gt;
<i>193</i>&nbsp; * domain: key1 = value1 , key2 = value2
<i>194</i>&nbsp; * &lt;/pre&gt;
<i>195</i>&nbsp; * represents an ObjectName with two keys.  The name of each key
<i>196</i>&nbsp; * contains six characters, of which the first and last are spaces.
<i>197</i>&nbsp; * The value associated with the key &lt;code&gt;&quot;&amp;nbsp;key1&amp;nbsp;&quot;&lt;/code&gt;
<i>198</i>&nbsp; * also begins and ends with a space.
<i>199</i>&nbsp; *
<i>200</i>&nbsp; * &lt;p&gt;In addition to the restrictions on characters spelt out above,
<i>201</i>&nbsp; * no part of an ObjectName may contain a newline character
<i>202</i>&nbsp; * (&lt;code&gt;&#39;\n&#39;&lt;/code&gt;), whether the domain, a key, or a value, whether
<i>203</i>&nbsp; * quoted or unquoted.  The newline character can be represented in a
<i>204</i>&nbsp; * quoted value with the sequence &lt;code&gt;\n&lt;/code&gt;.
<i>205</i>&nbsp; *
<i>206</i>&nbsp; * &lt;p&gt;The rules on special characters and quoting apply regardless of
<i>207</i>&nbsp; * which constructor is used to make an ObjectName.&lt;/p&gt;
<i>208</i>&nbsp; *
<i>209</i>&nbsp; * &lt;p&gt;To avoid collisions between MBeans supplied by different
<i>210</i>&nbsp; * vendors, a useful convention is to begin the domain name with the
<i>211</i>&nbsp; * reverse DNS name of the organization that specifies the MBeans,
<i>212</i>&nbsp; * followed by a period and a string whose interpretation is
<i>213</i>&nbsp; * determined by that organization.  For example, MBeans specified by
<i>214</i>&nbsp; * &lt;code&gt;example.com&lt;/code&gt;  would have
<i>215</i>&nbsp; * domains such as &lt;code&gt;com.example.MyDomain&lt;/code&gt;.  This is essentially
<i>216</i>&nbsp; * the same convention as for Java-language package names.&lt;/p&gt;
<i>217</i>&nbsp; *
<i>218</i>&nbsp; * &lt;p&gt;The &lt;b&gt;serialVersionUID&lt;/b&gt; of this class is &lt;code&gt;1081892073854801359L&lt;/code&gt;.
<i>219</i>&nbsp; *
<i>220</i>&nbsp; * @since 1.5
<i>221</i>&nbsp; *
<i>222</i>&nbsp; * @implNote The maximum allowed length of the domain name in this implementation
<i>223</i>&nbsp; *           is {@code Integer.MAX_VALUE/4}
<i>224</i>&nbsp; */
<i>225</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // don&#39;t complain serialVersionUID not constant
<i>226</i>&nbsp;public class ObjectName implements Comparable&lt;ObjectName&gt;, QueryExp {
<i>227</i>&nbsp;    private static final int DOMAIN_PATTERN = 0x8000_0000;
<i>228</i>&nbsp;    private static final int PROPLIST_PATTERN = 0x4000_0000;
<i>229</i>&nbsp;    private static final int PROPVAL_PATTERN = 0x2000_0000;
<i>230</i>&nbsp;
<i>231</i>&nbsp;    private static final int FLAG_MASK = DOMAIN_PATTERN | PROPLIST_PATTERN |
<i>232</i>&nbsp;                                         PROPVAL_PATTERN;
<i>233</i>&nbsp;    private static final int DOMAIN_LENGTH_MASK = ~FLAG_MASK;
<i>234</i>&nbsp;
<i>235</i>&nbsp;    /**
<i>236</i>&nbsp;     * A structure recording property structure and
<i>237</i>&nbsp;     * proposing minimal services
<b class="nc"><i>238</i>&nbsp;     */</b>
<b class="nc"><i>239</i>&nbsp;    private static class Property {</b>
<b class="nc"><i>240</i>&nbsp;</b>
<b class="nc"><i>241</i>&nbsp;        int _key_index;</b>
<i>242</i>&nbsp;        int _key_length;
<i>243</i>&nbsp;        int _value_length;
<i>244</i>&nbsp;
<i>245</i>&nbsp;        /**
<i>246</i>&nbsp;         * Constructor.
<i>247</i>&nbsp;         */
<b class="nc"><i>248</i>&nbsp;        Property(int key_index, int key_length, int value_length) {</b>
<i>249</i>&nbsp;            _key_index = key_index;
<i>250</i>&nbsp;            _key_length = key_length;
<i>251</i>&nbsp;            _value_length = value_length;
<i>252</i>&nbsp;        }
<i>253</i>&nbsp;
<i>254</i>&nbsp;        /**
<b class="nc"><i>255</i>&nbsp;         * Assigns the key index of property</b>
<i>256</i>&nbsp;         */
<i>257</i>&nbsp;        void setKeyIndex(int key_index) {
<i>258</i>&nbsp;            _key_index = key_index;
<i>259</i>&nbsp;        }
<i>260</i>&nbsp;
<i>261</i>&nbsp;        /**
<b class="nc"><i>262</i>&nbsp;         * Returns a key string for receiver key</b>
<b class="nc"><i>263</i>&nbsp;         */</b>
<b class="nc"><i>264</i>&nbsp;        String getKeyString(String name) {</b>
<i>265</i>&nbsp;            return name.substring(_key_index, _key_index + _key_length);
<i>266</i>&nbsp;        }
<i>267</i>&nbsp;
<i>268</i>&nbsp;        /**
<i>269</i>&nbsp;         * Returns a value string for receiver key
<i>270</i>&nbsp;         */
<i>271</i>&nbsp;        String getValueString(String name) {
<i>272</i>&nbsp;            int in_begin = _key_index + _key_length + 1;
<i>273</i>&nbsp;            int out_end = in_begin + _value_length;
<i>274</i>&nbsp;            return name.substring(in_begin, out_end);
<i>275</i>&nbsp;        }
<b class="nc"><i>276</i>&nbsp;    }</b>
<i>277</i>&nbsp;
<i>278</i>&nbsp;    /**
<i>279</i>&nbsp;     * Marker class for value pattern property.
<i>280</i>&nbsp;     */
<i>281</i>&nbsp;    private static class PatternProperty extends Property {
<i>282</i>&nbsp;        /**
<i>283</i>&nbsp;         * Constructor.
<i>284</i>&nbsp;         */
<i>285</i>&nbsp;        PatternProperty(int key_index, int key_length, int value_length) {
<i>286</i>&nbsp;            super(key_index, key_length, value_length);
<i>287</i>&nbsp;        }
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;    // Inner classes &lt;========================================
<i>291</i>&nbsp;
<i>292</i>&nbsp;
<i>293</i>&nbsp;
<i>294</i>&nbsp;    // Private fields ----------------------------------------&gt;
<i>295</i>&nbsp;
<i>296</i>&nbsp;
<i>297</i>&nbsp;    // Serialization compatibility stuff --------------------&gt;
<i>298</i>&nbsp;
<i>299</i>&nbsp;    // Two serial forms are supported in this class. The selected form depends
<i>300</i>&nbsp;    // on system property &quot;jmx.serial.form&quot;:
<b class="nc"><i>301</i>&nbsp;    //  - &quot;1.0&quot; for JMX 1.0</b>
<i>302</i>&nbsp;    //  - any other value for JMX 1.1 and higher
<i>303</i>&nbsp;    //
<i>304</i>&nbsp;    // Serial version for old serial form
<i>305</i>&nbsp;    private static final long oldSerialVersionUID = -5467795090068647408L;
<i>306</i>&nbsp;    //
<i>307</i>&nbsp;    // Serial version for new serial form
<i>308</i>&nbsp;    private static final long newSerialVersionUID = 1081892073854801359L;
<i>309</i>&nbsp;    //
<i>310</i>&nbsp;    // Serializable fields in old serial form
<i>311</i>&nbsp;    private static final ObjectStreamField[] oldSerialPersistentFields =
<b class="nc"><i>312</i>&nbsp;    {</b>
<i>313</i>&nbsp;        new ObjectStreamField(&quot;domain&quot;, String.class),
<i>314</i>&nbsp;        new ObjectStreamField(&quot;propertyList&quot;, Hashtable.class),
<i>315</i>&nbsp;        new ObjectStreamField(&quot;propertyListString&quot;, String.class),
<i>316</i>&nbsp;        new ObjectStreamField(&quot;canonicalName&quot;, String.class),
<b class="nc"><i>317</i>&nbsp;        new ObjectStreamField(&quot;pattern&quot;, Boolean.TYPE),</b>
<i>318</i>&nbsp;        new ObjectStreamField(&quot;propertyPattern&quot;, Boolean.TYPE)
<i>319</i>&nbsp;    };
<b class="nc"><i>320</i>&nbsp;    //</b>
<b class="nc"><i>321</i>&nbsp;    // Serializable fields in new serial form</b>
<b class="nc"><i>322</i>&nbsp;    private static final ObjectStreamField[] newSerialPersistentFields = { };</b>
<b class="nc"><i>323</i>&nbsp;    //</b>
<i>324</i>&nbsp;    // Actual serial version and serial form
<b class="nc"><i>325</i>&nbsp;    private static final long serialVersionUID;</b>
<b class="nc"><i>326</i>&nbsp;    private static final ObjectStreamField[] serialPersistentFields;</b>
<b class="nc"><i>327</i>&nbsp;    private static boolean compat = false;</b>
<b class="nc"><i>328</i>&nbsp;    static {</b>
<i>329</i>&nbsp;        try {
<b class="nc"><i>330</i>&nbsp;            GetPropertyAction act = new GetPropertyAction(&quot;jmx.serial.form&quot;);</b>
<b class="nc"><i>331</i>&nbsp;            String form = AccessController.doPrivileged(act);</b>
<i>332</i>&nbsp;            compat = (form != null &amp;&amp; form.equals(&quot;1.0&quot;));
<i>333</i>&nbsp;        } catch (Exception e) {
<i>334</i>&nbsp;            // OK: exception means no compat with 1.0, too bad
<i>335</i>&nbsp;        }
<i>336</i>&nbsp;        if (compat) {
<i>337</i>&nbsp;            serialPersistentFields = oldSerialPersistentFields;
<i>338</i>&nbsp;            serialVersionUID = oldSerialVersionUID;
<i>339</i>&nbsp;        } else {
<i>340</i>&nbsp;            serialPersistentFields = newSerialPersistentFields;
<i>341</i>&nbsp;            serialVersionUID = newSerialVersionUID;
<i>342</i>&nbsp;        }
<b class="nc"><i>343</i>&nbsp;    }</b>
<i>344</i>&nbsp;
<i>345</i>&nbsp;    //
<i>346</i>&nbsp;    // Serialization compatibility stuff &lt;==============================
<i>347</i>&nbsp;
<i>348</i>&nbsp;    // Class private fields -----------------------------------&gt;
<i>349</i>&nbsp;
<i>350</i>&nbsp;    /**
<i>351</i>&nbsp;     * a shared empty array for empty property lists
<i>352</i>&nbsp;     */
<i>353</i>&nbsp;    static final private Property[] _Empty_property_array = new Property[0];
<i>354</i>&nbsp;
<i>355</i>&nbsp;
<i>356</i>&nbsp;    // Class private fields &lt;==============================
<i>357</i>&nbsp;
<i>358</i>&nbsp;    // Instance private fields -----------------------------------&gt;
<i>359</i>&nbsp;
<i>360</i>&nbsp;    /**
<i>361</i>&nbsp;     * a String containing the canonical name
<i>362</i>&nbsp;     */
<i>363</i>&nbsp;    private transient String _canonicalName;
<i>364</i>&nbsp;
<i>365</i>&nbsp;
<i>366</i>&nbsp;    /**
<i>367</i>&nbsp;     * An array of properties in the same seq order as time creation
<i>368</i>&nbsp;     */
<i>369</i>&nbsp;    private transient Property[] _kp_array;
<b class="nc"><i>370</i>&nbsp;</b>
<i>371</i>&nbsp;    /**
<i>372</i>&nbsp;     * An array of properties in the same seq order as canonical order
<i>373</i>&nbsp;     */
<i>374</i>&nbsp;    private transient Property[] _ca_array;
<i>375</i>&nbsp;
<i>376</i>&nbsp;
<i>377</i>&nbsp;    /**
<i>378</i>&nbsp;     * The propertyList of built object name. Initialized lazily.
<i>379</i>&nbsp;     * Table that contains all the pairs (key,value) for this ObjectName.
<i>380</i>&nbsp;     */
<i>381</i>&nbsp;    private transient Map&lt;String,String&gt; _propertyList;
<b class="nc"><i>382</i>&nbsp;</b>
<i>383</i>&nbsp;    /**
<i>384</i>&nbsp;     * This field encodes _domain_pattern, _property_list_pattern and
<i>385</i>&nbsp;     * _property_value_pattern booleans and _domain_length integer.
<i>386</i>&nbsp;     * &lt;p&gt;
<i>387</i>&nbsp;     * The following masks can be used to extract the value:
<b class="nc"><i>388</i>&nbsp;     * &lt;ul&gt;</b>
<i>389</i>&nbsp;     * &lt;li&gt;{@linkplain ObjectName#DOMAIN_PATTERN}&lt;/li&gt;
<i>390</i>&nbsp;     * &lt;li&gt;{@linkplain ObjectName#PROPLIST_PATTERN}&lt;/li&gt;
<i>391</i>&nbsp;     * &lt;li&gt;{@linkplain ObjectName#PROPVAL_PATTERN}&lt;/li&gt;
<i>392</i>&nbsp;     * &lt;li&gt;{@linkplain ObjectName#DOMAIN_LENGTH_MASK}&lt;/li&gt;
<i>393</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>394</i>&nbsp;     * &lt;/p&gt;.</b>
<i>395</i>&nbsp;     */
<i>396</i>&nbsp;    private transient int _compressed_storage = 0x0;
<i>397</i>&nbsp;
<i>398</i>&nbsp;    // Instance private fields &lt;=======================================
<i>399</i>&nbsp;
<i>400</i>&nbsp;    // Private fields &lt;========================================
<i>401</i>&nbsp;
<i>402</i>&nbsp;
<i>403</i>&nbsp;    //  Private methods ----------------------------------------&gt;
<i>404</i>&nbsp;
<i>405</i>&nbsp;    // Category : Instance construction -------------------------&gt;
<i>406</i>&nbsp;
<i>407</i>&nbsp;    /**
<i>408</i>&nbsp;     * Initializes this {@link ObjectName} from the given string
<i>409</i>&nbsp;     * representation.
<i>410</i>&nbsp;     *
<i>411</i>&nbsp;     * @param name A string representation of the {@link ObjectName}
<i>412</i>&nbsp;     *
<i>413</i>&nbsp;     * @exception MalformedObjectNameException The string passed as a
<i>414</i>&nbsp;     * parameter does not have the right format.
<i>415</i>&nbsp;     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
<i>416</i>&nbsp;     * is null.
<i>417</i>&nbsp;     */
<i>418</i>&nbsp;    private void construct(String name)
<i>419</i>&nbsp;        throws MalformedObjectNameException {
<b class="nc"><i>420</i>&nbsp;</b>
<b class="nc"><i>421</i>&nbsp;        // The name cannot be null</b>
<i>422</i>&nbsp;        if (name == null)
<i>423</i>&nbsp;            throw new NullPointerException(&quot;name cannot be null&quot;);
<b class="nc"><i>424</i>&nbsp;</b>
<i>425</i>&nbsp;        // Test if the name is empty
<b class="nc"><i>426</i>&nbsp;        if (name.length() == 0) {</b>
<b class="nc"><i>427</i>&nbsp;            // this is equivalent to the whole word query object name.</b>
<b class="nc"><i>428</i>&nbsp;            _canonicalName = &quot;*:*&quot;;</b>
<b class="nc"><i>429</i>&nbsp;            _kp_array = _Empty_property_array;</b>
<b class="nc"><i>430</i>&nbsp;            _ca_array = _Empty_property_array;</b>
<b class="nc"><i>431</i>&nbsp;            setDomainLength(1);</b>
<b class="nc"><i>432</i>&nbsp;            _propertyList = null;</b>
<b class="nc"><i>433</i>&nbsp;            setDomainPattern(true);</b>
<i>434</i>&nbsp;            setPropertyListPattern(true);
<i>435</i>&nbsp;            setPropertyValuePattern(false);
<i>436</i>&nbsp;            return;
<i>437</i>&nbsp;        }
<b class="nc"><i>438</i>&nbsp;</b>
<b class="nc"><i>439</i>&nbsp;        // initialize parsing of the string</b>
<b class="nc"><i>440</i>&nbsp;        final char[] name_chars = name.toCharArray();</b>
<i>441</i>&nbsp;        final int len = name_chars.length;
<b class="nc"><i>442</i>&nbsp;        final char[] canonical_chars = new char[len]; // canonical form will</b>
<b class="nc"><i>443</i>&nbsp;                                                      // be same length at most</b>
<i>444</i>&nbsp;        int cname_index = 0;
<i>445</i>&nbsp;        int index = 0;
<i>446</i>&nbsp;        char c, c1;
<i>447</i>&nbsp;
<b class="nc"><i>448</i>&nbsp;        // parses domain part</b>
<b class="nc"><i>449</i>&nbsp;    domain_parsing:</b>
<i>450</i>&nbsp;        while (index &lt; len) {
<b class="nc"><i>451</i>&nbsp;            switch (name_chars[index]) {</b>
<b class="nc"><i>452</i>&nbsp;                case &#39;:&#39; :</b>
<i>453</i>&nbsp;                    setDomainLength(index++);
<i>454</i>&nbsp;                    break domain_parsing;
<i>455</i>&nbsp;                case &#39;=&#39; :
<i>456</i>&nbsp;                    // &quot;:&quot; omission check.
<i>457</i>&nbsp;                    //
<i>458</i>&nbsp;                    // Although &quot;=&quot; is a valid character in the domain part
<i>459</i>&nbsp;                    // it is true that it is rarely used in the real world.
<i>460</i>&nbsp;                    // So check straight away if the &quot;:&quot; has been omitted
<b class="nc"><i>461</i>&nbsp;                    // from the ObjectName. This allows us to provide a more</b>
<b class="nc"><i>462</i>&nbsp;                    // accurate exception message.</b>
<b class="nc"><i>463</i>&nbsp;                    int i = ++index;</b>
<b class="nc"><i>464</i>&nbsp;                    while ((i &lt; len) &amp;&amp; (name_chars[i++] != &#39;:&#39;))</b>
<i>465</i>&nbsp;                        if (i == len)
<i>466</i>&nbsp;                            throw new MalformedObjectNameException(
<i>467</i>&nbsp;                                &quot;Domain part must be specified&quot;);
<b class="nc"><i>468</i>&nbsp;                    break;</b>
<i>469</i>&nbsp;                case &#39;\n&#39; :
<i>470</i>&nbsp;                    throw new MalformedObjectNameException(
<i>471</i>&nbsp;                              &quot;Invalid character &#39;\\n&#39; in domain name&quot;);
<b class="nc"><i>472</i>&nbsp;                case &#39;*&#39; :</b>
<b class="nc"><i>473</i>&nbsp;                case &#39;?&#39; :</b>
<b class="nc"><i>474</i>&nbsp;                    setDomainPattern(true);</b>
<i>475</i>&nbsp;                    index++;
<b class="nc"><i>476</i>&nbsp;                    break;</b>
<b class="nc"><i>477</i>&nbsp;                default :</b>
<i>478</i>&nbsp;                    index++;
<i>479</i>&nbsp;                    break;
<i>480</i>&nbsp;            }
<i>481</i>&nbsp;        }
<b class="nc"><i>482</i>&nbsp;</b>
<b class="nc"><i>483</i>&nbsp;        // check for non-empty properties</b>
<i>484</i>&nbsp;        if (index == len)
<i>485</i>&nbsp;            throw new MalformedObjectNameException(
<i>486</i>&nbsp;                                         &quot;Key properties cannot be empty&quot;);
<b class="nc"><i>487</i>&nbsp;</b>
<b class="nc"><i>488</i>&nbsp;        // we have got the domain part, begins building of _canonicalName</b>
<b class="nc"><i>489</i>&nbsp;        int _domain_length = getDomainLength();</b>
<i>490</i>&nbsp;        System.arraycopy(name_chars, 0, canonical_chars, 0, _domain_length);
<i>491</i>&nbsp;        canonical_chars[_domain_length] = &#39;:&#39;;
<i>492</i>&nbsp;        cname_index = _domain_length + 1;
<b class="nc"><i>493</i>&nbsp;</b>
<i>494</i>&nbsp;        // parses property list
<i>495</i>&nbsp;        Property prop;
<i>496</i>&nbsp;        Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();
<b class="nc"><i>497</i>&nbsp;        String[] keys;</b>
<i>498</i>&nbsp;        String key_name;
<i>499</i>&nbsp;        boolean quoted_value;
<i>500</i>&nbsp;        int property_index = 0;
<b class="nc"><i>501</i>&nbsp;        int in_index;</b>
<b class="nc"><i>502</i>&nbsp;        int key_index, key_length, value_index, value_length;</b>
<b class="nc"><i>503</i>&nbsp;</b>
<b class="nc"><i>504</i>&nbsp;        keys = new String[10];</b>
<i>505</i>&nbsp;        _kp_array = new Property[10];
<b class="nc"><i>506</i>&nbsp;        setPropertyListPattern(false);</b>
<b class="nc"><i>507</i>&nbsp;        setPropertyValuePattern(false);</b>
<i>508</i>&nbsp;
<i>509</i>&nbsp;        while (index &lt; len) {
<b class="nc"><i>510</i>&nbsp;            c = name_chars[index];</b>
<b class="nc"><i>511</i>&nbsp;</b>
<b class="nc"><i>512</i>&nbsp;            // case of pattern properties</b>
<i>513</i>&nbsp;            if (c == &#39;*&#39;) {
<i>514</i>&nbsp;                if (isPropertyListPattern())
<i>515</i>&nbsp;                    throw new MalformedObjectNameException(
<b class="nc"><i>516</i>&nbsp;                              &quot;Cannot have several &#39;*&#39; characters in pattern &quot; +</b>
<b class="nc"><i>517</i>&nbsp;                              &quot;property list&quot;);</b>
<b class="nc"><i>518</i>&nbsp;                else {</b>
<i>519</i>&nbsp;                    setPropertyListPattern(true);
<i>520</i>&nbsp;                    if ((++index &lt; len ) &amp;&amp; (name_chars[index] != &#39;,&#39;))
<b class="nc"><i>521</i>&nbsp;                        throw new MalformedObjectNameException(</b>
<b class="nc"><i>522</i>&nbsp;                                  &quot;Invalid character found after &#39;*&#39;: end of &quot; +</b>
<i>523</i>&nbsp;                                  &quot;name or &#39;,&#39; expected&quot;);
<b class="nc"><i>524</i>&nbsp;                    else if (index == len) {</b>
<b class="nc"><i>525</i>&nbsp;                        if (property_index == 0) {</b>
<b class="nc"><i>526</i>&nbsp;                            // empty properties case</b>
<i>527</i>&nbsp;                            _kp_array = _Empty_property_array;
<i>528</i>&nbsp;                            _ca_array = _Empty_property_array;
<i>529</i>&nbsp;                            _propertyList = Collections.emptyMap();
<i>530</i>&nbsp;                        }
<b class="nc"><i>531</i>&nbsp;                        break;</b>
<b class="nc"><i>532</i>&nbsp;                    } else {</b>
<i>533</i>&nbsp;                        // correct pattern spec in props, continue
<i>534</i>&nbsp;                        index++;
<i>535</i>&nbsp;                        continue;
<i>536</i>&nbsp;                    }
<i>537</i>&nbsp;                }
<b class="nc"><i>538</i>&nbsp;            }</b>
<b class="nc"><i>539</i>&nbsp;</b>
<b class="nc"><i>540</i>&nbsp;            // standard property case, key part</b>
<b class="nc"><i>541</i>&nbsp;            in_index = index;</b>
<b class="nc"><i>542</i>&nbsp;            key_index = in_index;</b>
<b class="nc"><i>543</i>&nbsp;            if (name_chars[in_index] == &#39;=&#39;)</b>
<i>544</i>&nbsp;                throw new MalformedObjectNameException(&quot;Invalid key (empty)&quot;);
<i>545</i>&nbsp;            while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index++]) != &#39;=&#39;))
<i>546</i>&nbsp;                switch (c1) {
<i>547</i>&nbsp;                    // &#39;=&#39; considered to introduce value part
<i>548</i>&nbsp;                    case  &#39;*&#39; :
<i>549</i>&nbsp;                    case  &#39;?&#39; :
<b class="nc"><i>550</i>&nbsp;                    case  &#39;,&#39; :</b>
<b class="nc"><i>551</i>&nbsp;                    case  &#39;:&#39; :</b>
<i>552</i>&nbsp;                    case  &#39;\n&#39; :
<i>553</i>&nbsp;                        final String ichar = ((c1==&#39;\n&#39;)?&quot;\\n&quot;:&quot;&quot;+c1);
<i>554</i>&nbsp;                        throw new MalformedObjectNameException(
<b class="nc"><i>555</i>&nbsp;                                  &quot;Invalid character &#39;&quot; + ichar +</b>
<b class="nc"><i>556</i>&nbsp;                                  &quot;&#39; in key part of property&quot;);</b>
<i>557</i>&nbsp;                }
<b class="nc"><i>558</i>&nbsp;            if (name_chars[in_index - 1] != &#39;=&#39;)</b>
<b class="nc"><i>559</i>&nbsp;                throw new MalformedObjectNameException(</b>
<i>560</i>&nbsp;                                             &quot;Unterminated key property part&quot;);
<i>561</i>&nbsp;            value_index = in_index; // in_index pointing after &#39;=&#39; char
<b class="nc"><i>562</i>&nbsp;            key_length = value_index - key_index - 1; // found end of key</b>
<b class="nc"><i>563</i>&nbsp;</b>
<b class="nc"><i>564</i>&nbsp;            // standard property case, value part</b>
<i>565</i>&nbsp;            boolean value_pattern = false;
<i>566</i>&nbsp;            if (in_index &lt; len &amp;&amp; name_chars[in_index] == &#39;\&quot;&#39;) {
<b class="nc"><i>567</i>&nbsp;                quoted_value = true;</b>
<i>568</i>&nbsp;                // the case of quoted value part
<i>569</i>&nbsp;            quoted_value_parsing:
<b class="nc"><i>570</i>&nbsp;                while ((++in_index &lt; len) &amp;&amp;</b>
<b class="nc"><i>571</i>&nbsp;                       ((c1 = name_chars[in_index]) != &#39;\&quot;&#39;)) {</b>
<b class="nc"><i>572</i>&nbsp;                    // the case of an escaped character</b>
<i>573</i>&nbsp;                    if (c1 == &#39;\\&#39;) {
<b class="nc"><i>574</i>&nbsp;                        if (++in_index == len)</b>
<i>575</i>&nbsp;                            throw new MalformedObjectNameException(
<i>576</i>&nbsp;                                               &quot;Unterminated quoted value&quot;);
<i>577</i>&nbsp;                        switch (c1 = name_chars[in_index]) {
<i>578</i>&nbsp;                            case &#39;\\&#39; :
<i>579</i>&nbsp;                            case &#39;\&quot;&#39; :
<b class="nc"><i>580</i>&nbsp;                            case &#39;?&#39; :</b>
<i>581</i>&nbsp;                            case &#39;*&#39; :
<b class="nc"><i>582</i>&nbsp;                            case &#39;n&#39; :</b>
<i>583</i>&nbsp;                                break; // valid character
<i>584</i>&nbsp;                            default :
<i>585</i>&nbsp;                                throw new MalformedObjectNameException(
<b class="nc"><i>586</i>&nbsp;                                          &quot;Invalid escape sequence &#39;\\&quot; +</b>
<b class="nc"><i>587</i>&nbsp;                                          c1 + &quot;&#39; in quoted value&quot;);</b>
<i>588</i>&nbsp;                        }
<i>589</i>&nbsp;                    } else if (c1 == &#39;\n&#39;) {
<b class="nc"><i>590</i>&nbsp;                        throw new MalformedObjectNameException(</b>
<i>591</i>&nbsp;                                                     &quot;Newline in quoted value&quot;);
<i>592</i>&nbsp;                    } else {
<b class="nc"><i>593</i>&nbsp;                        switch (c1) {</b>
<b class="nc"><i>594</i>&nbsp;                            case &#39;?&#39; :</b>
<i>595</i>&nbsp;                            case &#39;*&#39; :
<i>596</i>&nbsp;                                value_pattern = true;
<i>597</i>&nbsp;                                break;
<b class="nc"><i>598</i>&nbsp;                        }</b>
<b class="nc"><i>599</i>&nbsp;                    }</b>
<i>600</i>&nbsp;                }
<b class="nc"><i>601</i>&nbsp;                if (in_index == len)</b>
<i>602</i>&nbsp;                    throw new MalformedObjectNameException(
<i>603</i>&nbsp;                                                 &quot;Unterminated quoted value&quot;);
<b class="nc"><i>604</i>&nbsp;                else value_length = ++in_index - value_index;</b>
<b class="nc"><i>605</i>&nbsp;            } else {</b>
<b class="nc"><i>606</i>&nbsp;                // the case of standard value part</b>
<i>607</i>&nbsp;                quoted_value = false;
<i>608</i>&nbsp;                while ((in_index &lt; len) &amp;&amp; ((c1 = name_chars[in_index]) != &#39;,&#39;))
<i>609</i>&nbsp;                switch (c1) {
<b class="nc"><i>610</i>&nbsp;                    // &#39;,&#39; considered to be the value separator</b>
<b class="nc"><i>611</i>&nbsp;                    case &#39;*&#39; :</b>
<b class="nc"><i>612</i>&nbsp;                    case &#39;?&#39; :</b>
<i>613</i>&nbsp;                        value_pattern = true;
<i>614</i>&nbsp;                        in_index++;
<i>615</i>&nbsp;                        break;
<i>616</i>&nbsp;                    case &#39;=&#39; :
<b class="nc"><i>617</i>&nbsp;                    case &#39;:&#39; :</b>
<b class="nc"><i>618</i>&nbsp;                    case &#39;&quot;&#39; :</b>
<i>619</i>&nbsp;                    case &#39;\n&#39; :
<i>620</i>&nbsp;                        final String ichar = ((c1==&#39;\n&#39;)?&quot;\\n&quot;:&quot;&quot;+c1);
<i>621</i>&nbsp;                        throw new MalformedObjectNameException(
<b class="nc"><i>622</i>&nbsp;                                                 &quot;Invalid character &#39;&quot; + ichar +</b>
<b class="nc"><i>623</i>&nbsp;                                                 &quot;&#39; in value part of property&quot;);</b>
<i>624</i>&nbsp;                    default :
<b class="nc"><i>625</i>&nbsp;                        in_index++;</b>
<i>626</i>&nbsp;                        break;
<i>627</i>&nbsp;                }
<i>628</i>&nbsp;                value_length = in_index - value_index;
<b class="nc"><i>629</i>&nbsp;            }</b>
<b class="nc"><i>630</i>&nbsp;</b>
<b class="nc"><i>631</i>&nbsp;            // Parsed property, checks the end of name</b>
<i>632</i>&nbsp;            if (in_index == len - 1) {
<i>633</i>&nbsp;                if (quoted_value)
<b class="nc"><i>634</i>&nbsp;                    throw new MalformedObjectNameException(</b>
<i>635</i>&nbsp;                                             &quot;Invalid ending character `&quot; +
<b class="nc"><i>636</i>&nbsp;                                             name_chars[in_index] + &quot;&#39;&quot;);</b>
<i>637</i>&nbsp;                else throw new MalformedObjectNameException(
<i>638</i>&nbsp;                                                  &quot;Invalid ending comma&quot;);
<b class="nc"><i>639</i>&nbsp;            } else in_index++;</b>
<b class="nc"><i>640</i>&nbsp;</b>
<i>641</i>&nbsp;            // we got the key and value part, prepare a property for this
<b class="nc"><i>642</i>&nbsp;            if (!value_pattern) {</b>
<b class="nc"><i>643</i>&nbsp;                prop = new Property(key_index, key_length, value_length);</b>
<i>644</i>&nbsp;            } else {
<b class="nc"><i>645</i>&nbsp;                setPropertyValuePattern(true);</b>
<i>646</i>&nbsp;                prop = new PatternProperty(key_index, key_length, value_length);
<b class="nc"><i>647</i>&nbsp;            }</b>
<b class="nc"><i>648</i>&nbsp;            key_name = name.substring(key_index, key_index + key_length);</b>
<b class="nc"><i>649</i>&nbsp;</b>
<b class="nc"><i>650</i>&nbsp;            if (property_index == keys.length) {</b>
<i>651</i>&nbsp;                String[] tmp_string_array = new String[property_index + 10];
<b class="nc"><i>652</i>&nbsp;                System.arraycopy(keys, 0, tmp_string_array, 0, property_index);</b>
<i>653</i>&nbsp;                keys = tmp_string_array;
<b class="nc"><i>654</i>&nbsp;            }</b>
<b class="nc"><i>655</i>&nbsp;            keys[property_index] = key_name;</b>
<b class="nc"><i>656</i>&nbsp;</b>
<b class="nc"><i>657</i>&nbsp;            addProperty(prop, property_index, keys_map, key_name);</b>
<i>658</i>&nbsp;            property_index++;
<i>659</i>&nbsp;            index = in_index;
<b class="nc"><i>660</i>&nbsp;        }</b>
<i>661</i>&nbsp;
<i>662</i>&nbsp;        // computes and set canonical name
<i>663</i>&nbsp;        setCanonicalName(name_chars, canonical_chars, keys,
<i>664</i>&nbsp;                         keys_map, cname_index, property_index);
<i>665</i>&nbsp;    }
<i>666</i>&nbsp;
<i>667</i>&nbsp;    /**
<i>668</i>&nbsp;     * Construct an ObjectName from a domain and a Hashtable.
<i>669</i>&nbsp;     *
<i>670</i>&nbsp;     * @param domain Domain of the ObjectName.
<i>671</i>&nbsp;     * @param props  Map containing couples &lt;i&gt;key&lt;/i&gt; {@literal -&gt;} &lt;i&gt;value&lt;/i&gt;.
<i>672</i>&nbsp;     *
<i>673</i>&nbsp;     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
<i>674</i>&nbsp;     * contains an illegal character, or one of the keys or values in
<i>675</i>&nbsp;     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
<i>676</i>&nbsp;     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for quoting,
<i>677</i>&nbsp;     * or the domain&#39;s length exceeds the maximum allowed length.
<i>678</i>&nbsp;     * @exception NullPointerException One of the parameters is null.
<i>679</i>&nbsp;     */
<b class="nc"><i>680</i>&nbsp;    private void construct(String domain, Map&lt;String,String&gt; props)</b>
<b class="nc"><i>681</i>&nbsp;        throws MalformedObjectNameException {</b>
<i>682</i>&nbsp;
<i>683</i>&nbsp;        // The domain cannot be null
<b class="nc"><i>684</i>&nbsp;        if (domain == null)</b>
<b class="nc"><i>685</i>&nbsp;            throw new NullPointerException(&quot;domain cannot be null&quot;);</b>
<i>686</i>&nbsp;
<i>687</i>&nbsp;        // The key property list cannot be null
<b class="nc"><i>688</i>&nbsp;        if (props == null)</b>
<b class="nc"><i>689</i>&nbsp;            throw new NullPointerException(&quot;key property list cannot be null&quot;);</b>
<i>690</i>&nbsp;
<i>691</i>&nbsp;        // The key property list cannot be empty
<i>692</i>&nbsp;        if (props.isEmpty())
<b class="nc"><i>693</i>&nbsp;            throw new MalformedObjectNameException(</b>
<b class="nc"><i>694</i>&nbsp;                                         &quot;key property list cannot be empty&quot;);</b>
<i>695</i>&nbsp;
<i>696</i>&nbsp;        // checks domain validity
<b class="nc"><i>697</i>&nbsp;        if (!isDomain(domain))</b>
<b class="nc"><i>698</i>&nbsp;            throw new MalformedObjectNameException(&quot;Invalid domain: &quot; + domain);</b>
<b class="nc"><i>699</i>&nbsp;</b>
<i>700</i>&nbsp;        // init canonicalname
<i>701</i>&nbsp;        final StringBuilder sb = new StringBuilder();
<b class="nc"><i>702</i>&nbsp;        sb.append(domain).append(&#39;:&#39;);</b>
<b class="nc"><i>703</i>&nbsp;        setDomainLength(domain.length());</b>
<i>704</i>&nbsp;
<b class="nc"><i>705</i>&nbsp;        // allocates the property array</b>
<b class="nc"><i>706</i>&nbsp;        int nb_props = props.size();</b>
<i>707</i>&nbsp;        _kp_array = new Property[nb_props];
<i>708</i>&nbsp;
<b class="nc"><i>709</i>&nbsp;        String[] keys = new String[nb_props];</b>
<b class="nc"><i>710</i>&nbsp;        final Map&lt;String,Property&gt; keys_map = new HashMap&lt;String,Property&gt;();</b>
<b class="nc"><i>711</i>&nbsp;        Property prop;</b>
<b class="nc"><i>712</i>&nbsp;        int key_index;</b>
<b class="nc"><i>713</i>&nbsp;        int i = 0;</b>
<i>714</i>&nbsp;        for (Map.Entry&lt;String,String&gt; entry : props.entrySet()) {
<i>715</i>&nbsp;            if (sb.length() &gt; 0)
<b class="nc"><i>716</i>&nbsp;                sb.append(&quot;,&quot;);</b>
<b class="nc"><i>717</i>&nbsp;            String key = entry.getKey();</b>
<b class="nc"><i>718</i>&nbsp;            String value;</b>
<b class="nc"><i>719</i>&nbsp;            try {</b>
<b class="nc"><i>720</i>&nbsp;                value = entry.getValue();</b>
<b class="nc"><i>721</i>&nbsp;            } catch (ClassCastException e) {</b>
<b class="nc"><i>722</i>&nbsp;                throw new MalformedObjectNameException(e.getMessage());</b>
<b class="nc"><i>723</i>&nbsp;            }</b>
<b class="nc"><i>724</i>&nbsp;            key_index = sb.length();</b>
<b class="nc"><i>725</i>&nbsp;            checkKey(key);</b>
<b class="nc"><i>726</i>&nbsp;            sb.append(key);</b>
<b class="nc"><i>727</i>&nbsp;            keys[i] = key;</b>
<b class="nc"><i>728</i>&nbsp;            sb.append(&quot;=&quot;);</b>
<b class="nc"><i>729</i>&nbsp;            boolean value_pattern = checkValue(value);</b>
<b class="nc"><i>730</i>&nbsp;            sb.append(value);</b>
<i>731</i>&nbsp;            if (!value_pattern) {
<b class="nc"><i>732</i>&nbsp;                prop = new Property(key_index,</b>
<b class="nc"><i>733</i>&nbsp;                                    key.length(),</b>
<b class="nc"><i>734</i>&nbsp;                                    value.length());</b>
<b class="nc"><i>735</i>&nbsp;            } else {</b>
<i>736</i>&nbsp;                setPropertyValuePattern(true);
<b class="nc"><i>737</i>&nbsp;                prop = new PatternProperty(key_index,</b>
<b class="nc"><i>738</i>&nbsp;                                           key.length(),</b>
<b class="nc"><i>739</i>&nbsp;                                           value.length());</b>
<i>740</i>&nbsp;            }
<i>741</i>&nbsp;            addProperty(prop, i, keys_map, key);
<b class="nc"><i>742</i>&nbsp;            i++;</b>
<b class="nc"><i>743</i>&nbsp;        }</b>
<b class="nc"><i>744</i>&nbsp;</b>
<b class="nc"><i>745</i>&nbsp;        // initialize canonical name and data structure</b>
<b class="nc"><i>746</i>&nbsp;        int len = sb.length();</b>
<i>747</i>&nbsp;        char[] initial_chars = new char[len];
<b class="nc"><i>748</i>&nbsp;        sb.getChars(0, len, initial_chars, 0);</b>
<i>749</i>&nbsp;        char[] canonical_chars = new char[len];
<i>750</i>&nbsp;        int copyLen = getDomainLength() + 1;
<i>751</i>&nbsp;        System.arraycopy(initial_chars, 0, canonical_chars, 0, copyLen);
<i>752</i>&nbsp;        setCanonicalName(initial_chars, canonical_chars, keys, keys_map,
<i>753</i>&nbsp;                         copyLen, _kp_array.length);
<i>754</i>&nbsp;    }
<i>755</i>&nbsp;    // Category : Instance construction &lt;==============================
<i>756</i>&nbsp;
<i>757</i>&nbsp;    // Category : Internal utilities ------------------------------&gt;
<i>758</i>&nbsp;
<i>759</i>&nbsp;    /**
<i>760</i>&nbsp;     * Add passed property to the list at the given index
<i>761</i>&nbsp;     * for the passed key name
<i>762</i>&nbsp;     */
<b class="nc"><i>763</i>&nbsp;    private void addProperty(Property prop, int index,</b>
<i>764</i>&nbsp;                             Map&lt;String,Property&gt; keys_map, String key_name)
<i>765</i>&nbsp;        throws MalformedObjectNameException {
<i>766</i>&nbsp;
<i>767</i>&nbsp;        if (keys_map.containsKey(key_name)) throw new
<b class="nc"><i>768</i>&nbsp;                MalformedObjectNameException(&quot;key `&quot; +</b>
<b class="nc"><i>769</i>&nbsp;                                         key_name +&quot;&#39; already defined&quot;);</b>
<b class="nc"><i>770</i>&nbsp;</b>
<b class="nc"><i>771</i>&nbsp;        // if no more space for property arrays, have to increase it</b>
<i>772</i>&nbsp;        if (index == _kp_array.length) {
<b class="nc"><i>773</i>&nbsp;            Property[] tmp_prop_array = new Property[index + 10];</b>
<b class="nc"><i>774</i>&nbsp;            System.arraycopy(_kp_array, 0, tmp_prop_array, 0, index);</b>
<i>775</i>&nbsp;            _kp_array = tmp_prop_array;
<i>776</i>&nbsp;        }
<i>777</i>&nbsp;        _kp_array[index] = prop;
<i>778</i>&nbsp;        keys_map.put(key_name, prop);
<i>779</i>&nbsp;    }
<i>780</i>&nbsp;
<i>781</i>&nbsp;    /**
<i>782</i>&nbsp;     * Sets the canonical name of receiver from input &#39;specified_chars&#39;
<i>783</i>&nbsp;     * array, by filling &#39;canonical_chars&#39; array with found &#39;nb-props&#39;
<i>784</i>&nbsp;     * properties starting at position &#39;prop_index&#39;.
<i>785</i>&nbsp;     */
<i>786</i>&nbsp;    private void setCanonicalName(char[] specified_chars,
<i>787</i>&nbsp;                                  char[] canonical_chars,
<b class="nc"><i>788</i>&nbsp;                                  String[] keys, Map&lt;String,Property&gt; keys_map,</b>
<b class="nc"><i>789</i>&nbsp;                                  int prop_index, int nb_props) {</b>
<b class="nc"><i>790</i>&nbsp;</b>
<i>791</i>&nbsp;        // Sort the list of found properties
<b class="nc"><i>792</i>&nbsp;        if (_kp_array != _Empty_property_array) {</b>
<b class="nc"><i>793</i>&nbsp;            String[] tmp_keys = new String[nb_props];</b>
<b class="nc"><i>794</i>&nbsp;            Property[] tmp_props = new Property[nb_props];</b>
<b class="nc"><i>795</i>&nbsp;</b>
<b class="nc"><i>796</i>&nbsp;            System.arraycopy(keys, 0, tmp_keys, 0, nb_props);</b>
<b class="nc"><i>797</i>&nbsp;            Arrays.sort(tmp_keys);</b>
<i>798</i>&nbsp;            keys = tmp_keys;
<i>799</i>&nbsp;            System.arraycopy(_kp_array, 0, tmp_props, 0 , nb_props);
<i>800</i>&nbsp;            _kp_array = tmp_props;
<b class="nc"><i>801</i>&nbsp;            _ca_array = new Property[nb_props];</b>
<b class="nc"><i>802</i>&nbsp;</b>
<i>803</i>&nbsp;            // now assigns _ca_array to the sorted list of keys
<i>804</i>&nbsp;            // (there cannot be two identical keys in an objectname.
<i>805</i>&nbsp;            for (int i = 0; i &lt; nb_props; i++)
<b class="nc"><i>806</i>&nbsp;                _ca_array[i] = keys_map.get(keys[i]);</b>
<i>807</i>&nbsp;
<i>808</i>&nbsp;            // now we build the canonical name and set begin indexes of
<b class="nc"><i>809</i>&nbsp;            // properties to reflect canonical form</b>
<b class="nc"><i>810</i>&nbsp;            int last_index = nb_props - 1;</b>
<i>811</i>&nbsp;            int prop_len;
<b class="nc"><i>812</i>&nbsp;            Property prop;</b>
<b class="nc"><i>813</i>&nbsp;            for (int i = 0; i &lt;= last_index; i++) {</b>
<i>814</i>&nbsp;                prop = _ca_array[i];
<b class="nc"><i>815</i>&nbsp;                // length of prop including &#39;=&#39; char</b>
<b class="nc"><i>816</i>&nbsp;                prop_len = prop._key_length + prop._value_length + 1;</b>
<b class="nc"><i>817</i>&nbsp;                System.arraycopy(specified_chars, prop._key_index,</b>
<b class="nc"><i>818</i>&nbsp;                                 canonical_chars, prop_index, prop_len);</b>
<b class="nc"><i>819</i>&nbsp;                prop.setKeyIndex(prop_index);</b>
<i>820</i>&nbsp;                prop_index += prop_len;
<i>821</i>&nbsp;                if (i != last_index) {
<i>822</i>&nbsp;                    canonical_chars[prop_index] = &#39;,&#39;;
<i>823</i>&nbsp;                    prop_index++;
<i>824</i>&nbsp;                }
<b class="nc"><i>825</i>&nbsp;            }</b>
<b class="nc"><i>826</i>&nbsp;        }</b>
<b class="nc"><i>827</i>&nbsp;</b>
<b class="nc"><i>828</i>&nbsp;        // terminate canonicalname with &#39;*&#39; in case of pattern</b>
<i>829</i>&nbsp;        if (isPropertyListPattern()) {
<i>830</i>&nbsp;            if (_kp_array != _Empty_property_array)
<i>831</i>&nbsp;                canonical_chars[prop_index++] = &#39;,&#39;;
<b class="nc"><i>832</i>&nbsp;            canonical_chars[prop_index++] = &#39;*&#39;;</b>
<i>833</i>&nbsp;        }
<i>834</i>&nbsp;
<i>835</i>&nbsp;        // we now build the canonicalname string
<i>836</i>&nbsp;        _canonicalName = (new String(canonical_chars, 0, prop_index)).intern();
<i>837</i>&nbsp;    }
<i>838</i>&nbsp;
<i>839</i>&nbsp;    /**
<i>840</i>&nbsp;     * Parse a key.
<i>841</i>&nbsp;     * &lt;pre&gt;final int endKey=parseKey(s,startKey);&lt;/pre&gt;
<i>842</i>&nbsp;     * &lt;p&gt;key starts at startKey (included), and ends at endKey (excluded).
<i>843</i>&nbsp;     * If (startKey == endKey), then the key is empty.
<i>844</i>&nbsp;     *
<i>845</i>&nbsp;     * @param s The char array of the original string.
<i>846</i>&nbsp;     * @param startKey index at which to begin parsing.
<b class="nc"><i>847</i>&nbsp;     * @return The index following the last character of the key.</b>
<b class="nc"><i>848</i>&nbsp;     **/</b>
<b class="nc"><i>849</i>&nbsp;    private static int parseKey(final char[] s, final int startKey)</b>
<b class="nc"><i>850</i>&nbsp;        throws MalformedObjectNameException {</b>
<b class="nc"><i>851</i>&nbsp;        int next   = startKey;</b>
<b class="nc"><i>852</i>&nbsp;        int endKey = startKey;</b>
<i>853</i>&nbsp;        final int len = s.length;
<i>854</i>&nbsp;        while (next &lt; len) {
<i>855</i>&nbsp;            final char k = s[next++];
<i>856</i>&nbsp;            switch (k) {
<i>857</i>&nbsp;            case &#39;*&#39;:
<b class="nc"><i>858</i>&nbsp;            case &#39;?&#39;:</b>
<b class="nc"><i>859</i>&nbsp;            case &#39;,&#39;:</b>
<i>860</i>&nbsp;            case &#39;:&#39;:
<i>861</i>&nbsp;            case &#39;\n&#39;:
<i>862</i>&nbsp;                final String ichar = ((k==&#39;\n&#39;)?&quot;\\n&quot;:&quot;&quot;+k);
<i>863</i>&nbsp;                throw new
<b class="nc"><i>864</i>&nbsp;                    MalformedObjectNameException(&quot;Invalid character in key: `&quot;</b>
<b class="nc"><i>865</i>&nbsp;                                                 + ichar + &quot;&#39;&quot;);</b>
<i>866</i>&nbsp;            case &#39;=&#39;:
<b class="nc"><i>867</i>&nbsp;                // we got the key.</b>
<b class="nc"><i>868</i>&nbsp;                endKey = next-1;</b>
<i>869</i>&nbsp;                break;
<b class="nc"><i>870</i>&nbsp;            default:</b>
<i>871</i>&nbsp;                if (next &lt; len) continue;
<b class="nc"><i>872</i>&nbsp;                else endKey=next;</b>
<i>873</i>&nbsp;            }
<i>874</i>&nbsp;            break;
<i>875</i>&nbsp;        }
<i>876</i>&nbsp;        return endKey;
<i>877</i>&nbsp;    }
<i>878</i>&nbsp;
<i>879</i>&nbsp;    /**
<i>880</i>&nbsp;     * Parse a value.
<i>881</i>&nbsp;     * &lt;pre&gt;final int endVal=parseValue(s,startVal);&lt;/pre&gt;
<i>882</i>&nbsp;     * &lt;p&gt;value starts at startVal (included), and ends at endVal (excluded).
<i>883</i>&nbsp;     * If (startVal == endVal), then the key is empty.
<i>884</i>&nbsp;     *
<i>885</i>&nbsp;     * @param s The char array of the original string.
<i>886</i>&nbsp;     * @param startValue index at which to begin parsing.
<i>887</i>&nbsp;     * @return The first element of the int array indicates the index
<i>888</i>&nbsp;     *         following the last character of the value. The second
<i>889</i>&nbsp;     *         element of the int array indicates that the value is
<i>890</i>&nbsp;     *         a pattern when its value equals 1.
<b class="nc"><i>891</i>&nbsp;     **/</b>
<i>892</i>&nbsp;    private static int[] parseValue(final char[] s, final int startValue)
<b class="nc"><i>893</i>&nbsp;        throws MalformedObjectNameException {</b>
<b class="nc"><i>894</i>&nbsp;</b>
<i>895</i>&nbsp;        boolean value_pattern = false;
<b class="nc"><i>896</i>&nbsp;</b>
<b class="nc"><i>897</i>&nbsp;        int next   = startValue;</b>
<i>898</i>&nbsp;        int endValue = startValue;
<b class="nc"><i>899</i>&nbsp;</b>
<i>900</i>&nbsp;        final int len = s.length;
<b class="nc"><i>901</i>&nbsp;        final char q=s[startValue];</b>
<i>902</i>&nbsp;
<b class="nc"><i>903</i>&nbsp;        if (q == &#39;&quot;&#39;) {</b>
<b class="nc"><i>904</i>&nbsp;            // quoted value</b>
<b class="nc"><i>905</i>&nbsp;            if (++next == len) throw new</b>
<b class="nc"><i>906</i>&nbsp;                MalformedObjectNameException(&quot;Invalid quote&quot;);</b>
<i>907</i>&nbsp;            while (next &lt; len) {
<i>908</i>&nbsp;                char last = s[next];
<b class="nc"><i>909</i>&nbsp;                if (last == &#39;\\&#39;) {</b>
<b class="nc"><i>910</i>&nbsp;                    if (++next == len) throw new</b>
<i>911</i>&nbsp;                        MalformedObjectNameException(
<i>912</i>&nbsp;                           &quot;Invalid unterminated quoted character sequence&quot;);
<i>913</i>&nbsp;                    last = s[next];
<i>914</i>&nbsp;                    switch (last) {
<b class="nc"><i>915</i>&nbsp;                        case &#39;\\&#39; :</b>
<i>916</i>&nbsp;                        case &#39;?&#39; :
<i>917</i>&nbsp;                        case &#39;*&#39; :
<i>918</i>&nbsp;                        case &#39;n&#39; :
<i>919</i>&nbsp;                            break;
<i>920</i>&nbsp;                        case &#39;\&quot;&#39; :
<b class="nc"><i>921</i>&nbsp;                            // We have an escaped quote. If this escaped</b>
<i>922</i>&nbsp;                            // quote is the last character, it does not
<i>923</i>&nbsp;                            // qualify as a valid termination quote.
<i>924</i>&nbsp;                            //
<i>925</i>&nbsp;                            if (next+1 == len) throw new
<b class="nc"><i>926</i>&nbsp;                                MalformedObjectNameException(</b>
<i>927</i>&nbsp;                                                 &quot;Missing termination quote&quot;);
<i>928</i>&nbsp;                            break;
<i>929</i>&nbsp;                        default:
<i>930</i>&nbsp;                            throw new
<b class="nc"><i>931</i>&nbsp;                                MalformedObjectNameException(</b>
<b class="nc"><i>932</i>&nbsp;                                &quot;Invalid quoted character sequence &#39;\\&quot; +</b>
<i>933</i>&nbsp;                                last + &quot;&#39;&quot;);
<b class="nc"><i>934</i>&nbsp;                    }</b>
<b class="nc"><i>935</i>&nbsp;                } else if (last == &#39;\n&#39;) {</b>
<b class="nc"><i>936</i>&nbsp;                    throw new MalformedObjectNameException(</b>
<i>937</i>&nbsp;                                                 &quot;Newline in quoted value&quot;);
<b class="nc"><i>938</i>&nbsp;                } else if (last == &#39;\&quot;&#39;) {</b>
<i>939</i>&nbsp;                    next++;
<i>940</i>&nbsp;                    break;
<b class="nc"><i>941</i>&nbsp;                } else {</b>
<i>942</i>&nbsp;                    switch (last) {
<i>943</i>&nbsp;                        case &#39;?&#39; :
<i>944</i>&nbsp;                        case &#39;*&#39; :
<b class="nc"><i>945</i>&nbsp;                            value_pattern = true;</b>
<i>946</i>&nbsp;                            break;
<i>947</i>&nbsp;                    }
<i>948</i>&nbsp;                }
<i>949</i>&nbsp;                next++;
<i>950</i>&nbsp;
<b class="nc"><i>951</i>&nbsp;                // Check that last character is a termination quote.</b>
<i>952</i>&nbsp;                // We have already handled the case were the last
<b class="nc"><i>953</i>&nbsp;                // character is an escaped quote earlier.</b>
<b class="nc"><i>954</i>&nbsp;                //</b>
<b class="nc"><i>955</i>&nbsp;                if ((next &gt;= len) &amp;&amp; (last != &#39;\&quot;&#39;)) throw new</b>
<b class="nc"><i>956</i>&nbsp;                    MalformedObjectNameException(&quot;Missing termination quote&quot;);</b>
<i>957</i>&nbsp;            }
<i>958</i>&nbsp;            endValue = next;
<i>959</i>&nbsp;            if (next &lt; len) {
<i>960</i>&nbsp;                if (s[next++] != &#39;,&#39;) throw new
<b class="nc"><i>961</i>&nbsp;                    MalformedObjectNameException(&quot;Invalid quote&quot;);</b>
<b class="nc"><i>962</i>&nbsp;            }</b>
<b class="nc"><i>963</i>&nbsp;        } else {</b>
<i>964</i>&nbsp;            // Non quoted value.
<i>965</i>&nbsp;            while (next &lt; len) {
<b class="nc"><i>966</i>&nbsp;                final char v=s[next++];</b>
<b class="nc"><i>967</i>&nbsp;                switch(v) {</b>
<b class="nc"><i>968</i>&nbsp;                    case &#39;*&#39;:</b>
<b class="nc"><i>969</i>&nbsp;                    case &#39;?&#39;:</b>
<i>970</i>&nbsp;                        value_pattern = true;
<i>971</i>&nbsp;                        if (next &lt; len) continue;
<i>972</i>&nbsp;                        else endValue=next;
<b class="nc"><i>973</i>&nbsp;                        break;</b>
<b class="nc"><i>974</i>&nbsp;                    case &#39;=&#39;:</b>
<i>975</i>&nbsp;                    case &#39;:&#39;:
<i>976</i>&nbsp;                    case &#39;\n&#39; :
<i>977</i>&nbsp;                        final String ichar = ((v==&#39;\n&#39;)?&quot;\\n&quot;:&quot;&quot;+v);
<b class="nc"><i>978</i>&nbsp;                        throw new</b>
<b class="nc"><i>979</i>&nbsp;                            MalformedObjectNameException(&quot;Invalid character `&quot; +</b>
<i>980</i>&nbsp;                                                         ichar + &quot;&#39; in value&quot;);
<b class="nc"><i>981</i>&nbsp;                    case &#39;,&#39;:</b>
<b class="nc"><i>982</i>&nbsp;                        endValue = next-1;</b>
<i>983</i>&nbsp;                        break;
<b class="nc"><i>984</i>&nbsp;                    default:</b>
<i>985</i>&nbsp;                        if (next &lt; len) continue;
<i>986</i>&nbsp;                        else endValue=next;
<b class="nc"><i>987</i>&nbsp;                }</b>
<i>988</i>&nbsp;                break;
<i>989</i>&nbsp;            }
<i>990</i>&nbsp;        }
<i>991</i>&nbsp;        return new int[] { endValue, value_pattern ? 1 : 0 };
<i>992</i>&nbsp;    }
<i>993</i>&nbsp;
<i>994</i>&nbsp;    /**
<i>995</i>&nbsp;     * Check if the supplied value is a valid value.
<i>996</i>&nbsp;     *
<i>997</i>&nbsp;     * @return true if the value is a pattern, otherwise false.
<b class="nc"><i>998</i>&nbsp;     */</b>
<i>999</i>&nbsp;    private static boolean checkValue(String val)
<i>1000</i>&nbsp;        throws MalformedObjectNameException {
<b class="nc"><i>1001</i>&nbsp;</b>
<b class="nc"><i>1002</i>&nbsp;        if (val == null) throw new</b>
<b class="nc"><i>1003</i>&nbsp;            NullPointerException(&quot;Invalid value (null)&quot;);</b>
<i>1004</i>&nbsp;
<b class="nc"><i>1005</i>&nbsp;        final int len = val.length();</b>
<b class="nc"><i>1006</i>&nbsp;        if (len == 0)</b>
<b class="nc"><i>1007</i>&nbsp;            return false;</b>
<b class="nc"><i>1008</i>&nbsp;</b>
<b class="nc"><i>1009</i>&nbsp;        final char[] s = val.toCharArray();</b>
<i>1010</i>&nbsp;        final int[] result = parseValue(s,0);
<i>1011</i>&nbsp;        final int endValue = result[0];
<b class="nc"><i>1012</i>&nbsp;        final boolean value_pattern = result[1] == 1;</b>
<i>1013</i>&nbsp;        if (endValue &lt; len) throw new
<i>1014</i>&nbsp;            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
<i>1015</i>&nbsp;                                         s[endValue] + &quot;&#39;&quot;);
<i>1016</i>&nbsp;        return value_pattern;
<i>1017</i>&nbsp;    }
<i>1018</i>&nbsp;
<i>1019</i>&nbsp;    /**
<i>1020</i>&nbsp;     * Check if the supplied key is a valid key.
<b class="nc"><i>1021</i>&nbsp;     */</b>
<i>1022</i>&nbsp;    private static void checkKey(String key)
<i>1023</i>&nbsp;        throws MalformedObjectNameException {
<b class="nc"><i>1024</i>&nbsp;</b>
<b class="nc"><i>1025</i>&nbsp;        if (key == null) throw new</b>
<i>1026</i>&nbsp;            NullPointerException(&quot;Invalid key (null)&quot;);
<b class="nc"><i>1027</i>&nbsp;</b>
<b class="nc"><i>1028</i>&nbsp;        final int len = key.length();</b>
<b class="nc"><i>1029</i>&nbsp;        if (len == 0) throw new</b>
<i>1030</i>&nbsp;            MalformedObjectNameException(&quot;Invalid key (empty)&quot;);
<i>1031</i>&nbsp;        final char[] k=key.toCharArray();
<i>1032</i>&nbsp;        final int endKey = parseKey(k,0);
<i>1033</i>&nbsp;        if (endKey &lt; len) throw new
<i>1034</i>&nbsp;            MalformedObjectNameException(&quot;Invalid character in value: `&quot; +
<i>1035</i>&nbsp;                                         k[endKey] + &quot;&#39;&quot;);
<i>1036</i>&nbsp;    }
<i>1037</i>&nbsp;
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    // Category : Internal utilities &lt;==============================
<i>1040</i>&nbsp;
<i>1041</i>&nbsp;    // Category : Internal accessors ------------------------------&gt;
<i>1042</i>&nbsp;
<b class="nc"><i>1043</i>&nbsp;    /**</b>
<b class="nc"><i>1044</i>&nbsp;     * Check if domain is a valid domain.  Set _domain_pattern if appropriate.</b>
<b class="nc"><i>1045</i>&nbsp;     */</b>
<b class="nc"><i>1046</i>&nbsp;    private boolean isDomain(String domain) {</b>
<b class="nc"><i>1047</i>&nbsp;        if (domain == null) return true;</b>
<b class="nc"><i>1048</i>&nbsp;        final int len = domain.length();</b>
<i>1049</i>&nbsp;        int next = 0;
<i>1050</i>&nbsp;        while (next &lt; len) {
<b class="nc"><i>1051</i>&nbsp;            final char c = domain.charAt(next++);</b>
<i>1052</i>&nbsp;            switch (c) {
<i>1053</i>&nbsp;                case &#39;:&#39; :
<b class="nc"><i>1054</i>&nbsp;                case &#39;\n&#39; :</b>
<i>1055</i>&nbsp;                    return false;
<i>1056</i>&nbsp;                case &#39;*&#39; :
<b class="nc"><i>1057</i>&nbsp;                case &#39;?&#39; :</b>
<b class="nc"><i>1058</i>&nbsp;                    setDomainPattern(true);</b>
<i>1059</i>&nbsp;                    break;
<i>1060</i>&nbsp;            }
<i>1061</i>&nbsp;        }
<i>1062</i>&nbsp;        return true;
<i>1063</i>&nbsp;    }
<i>1064</i>&nbsp;
<i>1065</i>&nbsp;    private int getDomainLength() {
<i>1066</i>&nbsp;        return _compressed_storage &amp; DOMAIN_LENGTH_MASK;
<i>1067</i>&nbsp;    }
<i>1068</i>&nbsp;
<i>1069</i>&nbsp;    /**
<i>1070</i>&nbsp;     * Validates and sets the domain length
<i>1071</i>&nbsp;     * @param length The domain length
<i>1072</i>&nbsp;     * @throws MalformedObjectNameException
<i>1073</i>&nbsp;     *    When the given domain length exceeds the maximum allowed length
<i>1074</i>&nbsp;     */
<i>1075</i>&nbsp;    private void setDomainLength(int length) throws MalformedObjectNameException {
<i>1076</i>&nbsp;        if ((length &amp; FLAG_MASK) != 0 ) {
<i>1077</i>&nbsp;            throw new MalformedObjectNameException(
<i>1078</i>&nbsp;                &quot;Domain name too long. Maximum allowed domain name length is:&quot; +
<i>1079</i>&nbsp;                DOMAIN_LENGTH_MASK);
<i>1080</i>&nbsp;        }
<i>1081</i>&nbsp;        _compressed_storage = (_compressed_storage &amp; FLAG_MASK) | length;
<i>1082</i>&nbsp;    }
<i>1083</i>&nbsp;
<i>1084</i>&nbsp;    // Category : Internal accessors &lt;==============================
<i>1085</i>&nbsp;
<i>1086</i>&nbsp;    // Category : Serialization -----------------------------------&gt;
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;    /**
<i>1089</i>&nbsp;     * Deserializes an {@link ObjectName} from an {@link ObjectInputStream}.
<i>1090</i>&nbsp;     * @serialData &lt;ul&gt;
<i>1091</i>&nbsp;     *               &lt;li&gt;In the current serial form (value of property
<i>1092</i>&nbsp;     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
<i>1093</i>&nbsp;     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
<i>1094</i>&nbsp;     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
<i>1095</i>&nbsp;     *                   where: &lt;ul&gt;
<i>1096</i>&nbsp;     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
<i>1097</i>&nbsp;     *                                of the {@link ObjectName}&lt;/li&gt;
<i>1098</i>&nbsp;     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
<i>1099</i>&nbsp;     *                                properties, as returned by
<i>1100</i>&nbsp;     *                                {@link #getKeyPropertyListString}
<i>1101</i>&nbsp;     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
<i>1102</i>&nbsp;     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
<i>1103</i>&nbsp;     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
<i>1104</i>&nbsp;     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;
<i>1105</i>&nbsp;     *                                and &amp;lt;properties&amp;gt; is empty, or
<i>1106</i>&nbsp;     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
<i>1107</i>&nbsp;     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
<i>1108</i>&nbsp;     *                                &amp;lt;properties&amp;gt; is not empty.
<i>1109</i>&nbsp;     *                            &lt;/li&gt;
<i>1110</i>&nbsp;     *                          &lt;/ul&gt;
<i>1111</i>&nbsp;     *                   The intent is that this string could be supplied
<i>1112</i>&nbsp;     *                   to the {@link #ObjectName(String)} constructor to
<i>1113</i>&nbsp;     *                   produce an equivalent {@link ObjectName}.
<i>1114</i>&nbsp;     *               &lt;/li&gt;
<i>1115</i>&nbsp;     *               &lt;li&gt;In the old serial form (value of property
<i>1116</i>&nbsp;     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
<i>1117</i>&nbsp;     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
<i>1118</i>&nbsp;     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
<i>1119</i>&nbsp;     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
<i>1120</i>&nbsp;     *                   where: &lt;ul&gt;
<i>1121</i>&nbsp;     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
<i>1122</i>&nbsp;     *                                of the {@link ObjectName}&lt;/li&gt;
<i>1123</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
<i>1124</i>&nbsp;     *                                {@link Hashtable} that contains all the
<i>1125</i>&nbsp;     *                                pairs (key,value) for this
<i>1126</i>&nbsp;     *                                {@link ObjectName}&lt;/li&gt;
<b class="nc"><i>1127</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the</b>
<i>1128</i>&nbsp;     *                                {@link String} representation of the
<i>1129</i>&nbsp;     *                                list of properties in any order (not
<i>1130</i>&nbsp;     *                                mandatorily a canonical representation)
<b class="nc"><i>1131</i>&nbsp;     *                                &lt;/li&gt;</b>
<b class="nc"><i>1132</i>&nbsp;     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the</b>
<b class="nc"><i>1133</i>&nbsp;     *                                {@link String} containing this</b>
<i>1134</i>&nbsp;     *                                {@link ObjectName}&#39;s canonical name&lt;/li&gt;
<i>1135</i>&nbsp;     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is
<b class="nc"><i>1136</i>&nbsp;     *                                &lt;code&gt;true&lt;/code&gt; if this</b>
<b class="nc"><i>1137</i>&nbsp;     *                                {@link ObjectName} contains a pattern&lt;/li&gt;</b>
<b class="nc"><i>1138</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which</b>
<b class="nc"><i>1139</i>&nbsp;     *                                is &lt;code&gt;true&lt;/code&gt; if this</b>
<b class="nc"><i>1140</i>&nbsp;     *                                {@link ObjectName} contains a pattern in</b>
<i>1141</i>&nbsp;     *                                the list of properties&lt;/li&gt;
<i>1142</i>&nbsp;     *                          &lt;/ul&gt;
<b class="nc"><i>1143</i>&nbsp;     *               &lt;/li&gt;</b>
<i>1144</i>&nbsp;     *             &lt;/ul&gt;
<b class="nc"><i>1145</i>&nbsp;     */</b>
<i>1146</i>&nbsp;    private void readObject(ObjectInputStream in)
<i>1147</i>&nbsp;        throws IOException, ClassNotFoundException {
<b class="nc"><i>1148</i>&nbsp;</b>
<b class="nc"><i>1149</i>&nbsp;        String cn;</b>
<i>1150</i>&nbsp;        if (compat) {
<i>1151</i>&nbsp;            // Read an object serialized in the old serial form
<i>1152</i>&nbsp;            //
<b class="nc"><i>1153</i>&nbsp;            //in.defaultReadObject();</b>
<b class="nc"><i>1154</i>&nbsp;            final ObjectInputStream.GetField fields = in.readFields();</b>
<b class="nc"><i>1155</i>&nbsp;            String propListString =</b>
<b class="nc"><i>1156</i>&nbsp;                    (String)fields.get(&quot;propertyListString&quot;, &quot;&quot;);</b>
<b class="nc"><i>1157</i>&nbsp;</b>
<b class="nc"><i>1158</i>&nbsp;            // 6616825: take care of property patterns</b>
<i>1159</i>&nbsp;            final boolean propPattern =
<i>1160</i>&nbsp;                    fields.get(&quot;propertyPattern&quot; , false);
<i>1161</i>&nbsp;            if (propPattern) {
<i>1162</i>&nbsp;                propListString =
<i>1163</i>&nbsp;                        (propListString.length()==0?&quot;*&quot;:(propListString+&quot;,*&quot;));
<i>1164</i>&nbsp;            }
<i>1165</i>&nbsp;
<i>1166</i>&nbsp;            cn = (String)fields.get(&quot;domain&quot;, &quot;default&quot;)+
<i>1167</i>&nbsp;                &quot;:&quot;+ propListString;
<i>1168</i>&nbsp;        } else {
<i>1169</i>&nbsp;            // Read an object serialized in the new serial form
<i>1170</i>&nbsp;            //
<i>1171</i>&nbsp;            in.defaultReadObject();
<i>1172</i>&nbsp;            cn = (String)in.readObject();
<i>1173</i>&nbsp;        }
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;        try {
<i>1176</i>&nbsp;            construct(cn);
<i>1177</i>&nbsp;        } catch (NullPointerException e) {
<i>1178</i>&nbsp;            throw new InvalidObjectException(e.toString());
<i>1179</i>&nbsp;        } catch (MalformedObjectNameException e) {
<i>1180</i>&nbsp;            throw new InvalidObjectException(e.toString());
<i>1181</i>&nbsp;        }
<i>1182</i>&nbsp;    }
<i>1183</i>&nbsp;
<i>1184</i>&nbsp;
<i>1185</i>&nbsp;    /**
<i>1186</i>&nbsp;     * Serializes an {@link ObjectName} to an {@link ObjectOutputStream}.
<i>1187</i>&nbsp;     * @serialData &lt;ul&gt;
<i>1188</i>&nbsp;     *               &lt;li&gt;In the current serial form (value of property
<i>1189</i>&nbsp;     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; differs from
<i>1190</i>&nbsp;     *                   &lt;code&gt;1.0&lt;/code&gt;): the string
<i>1191</i>&nbsp;     *                   &amp;quot;&amp;lt;domain&amp;gt;:&amp;lt;properties&amp;gt;&amp;lt;wild&amp;gt;&amp;quot;,
<i>1192</i>&nbsp;     *                   where: &lt;ul&gt;
<i>1193</i>&nbsp;     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
<i>1194</i>&nbsp;     *                                of the {@link ObjectName}&lt;/li&gt;
<i>1195</i>&nbsp;     *                            &lt;li&gt;&amp;lt;properties&amp;gt; represents the list of
<i>1196</i>&nbsp;     *                                properties, as returned by
<i>1197</i>&nbsp;     *                                {@link #getKeyPropertyListString}
<i>1198</i>&nbsp;     *                            &lt;li&gt;&amp;lt;wild&amp;gt; is empty if not
<i>1199</i>&nbsp;     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt;, or
<i>1200</i>&nbsp;     *                                is the character &quot;&lt;code&gt;*&lt;/code&gt;&quot; if
<i>1201</i>&nbsp;     *                                this &lt;code&gt;isPropertyPattern&lt;/code&gt;
<i>1202</i>&nbsp;     *                                and &amp;lt;properties&amp;gt; is empty, or
<i>1203</i>&nbsp;     *                                is &quot;&lt;code&gt;,*&lt;/code&gt;&quot; if
<i>1204</i>&nbsp;     *                                &lt;code&gt;isPropertyPattern&lt;/code&gt; and
<i>1205</i>&nbsp;     *                                &amp;lt;properties&amp;gt; is not empty.
<i>1206</i>&nbsp;     *                            &lt;/li&gt;
<i>1207</i>&nbsp;     *                          &lt;/ul&gt;
<i>1208</i>&nbsp;     *                   The intent is that this string could be supplied
<i>1209</i>&nbsp;     *                   to the {@link #ObjectName(String)} constructor to
<i>1210</i>&nbsp;     *                   produce an equivalent {@link ObjectName}.
<i>1211</i>&nbsp;     *               &lt;/li&gt;
<i>1212</i>&nbsp;     *               &lt;li&gt;In the old serial form (value of property
<i>1213</i>&nbsp;     *                   &lt;code&gt;jmx.serial.form&lt;/code&gt; is
<i>1214</i>&nbsp;     *                   &lt;code&gt;1.0&lt;/code&gt;): &amp;lt;domain&amp;gt; &amp;lt;propertyList&amp;gt;
<i>1215</i>&nbsp;     *                   &amp;lt;propertyListString&amp;gt; &amp;lt;canonicalName&amp;gt;
<i>1216</i>&nbsp;     *                   &amp;lt;pattern&amp;gt; &amp;lt;propertyPattern&amp;gt;,
<i>1217</i>&nbsp;     *                   where: &lt;ul&gt;
<i>1218</i>&nbsp;     *                            &lt;li&gt;&amp;lt;domain&amp;gt; represents the domain part
<i>1219</i>&nbsp;     *                                of the {@link ObjectName}&lt;/li&gt;
<i>1220</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyList&amp;gt; is the
<i>1221</i>&nbsp;     *                                {@link Hashtable} that contains all the
<i>1222</i>&nbsp;     *                                pairs (key,value) for this
<b class="nc"><i>1223</i>&nbsp;     *                                {@link ObjectName}&lt;/li&gt;</b>
<i>1224</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyListString&amp;gt; is the
<i>1225</i>&nbsp;     *                                {@link String} representation of the
<i>1226</i>&nbsp;     *                                list of properties in any order (not
<b class="nc"><i>1227</i>&nbsp;     *                                mandatorily a canonical representation)</b>
<b class="nc"><i>1228</i>&nbsp;     *                                &lt;/li&gt;</b>
<b class="nc"><i>1229</i>&nbsp;     *                            &lt;li&gt;&amp;lt;canonicalName&amp;gt; is the</b>
<b class="nc"><i>1230</i>&nbsp;     *                                {@link String} containing this</b>
<b class="nc"><i>1231</i>&nbsp;     *                                {@link ObjectName}&#39;s canonical name&lt;/li&gt;</b>
<b class="nc"><i>1232</i>&nbsp;     *                            &lt;li&gt;&amp;lt;pattern&amp;gt; is a boolean which is</b>
<b class="nc"><i>1233</i>&nbsp;     *                                &lt;code&gt;true&lt;/code&gt; if this</b>
<b class="nc"><i>1234</i>&nbsp;     *                                {@link ObjectName} contains a pattern&lt;/li&gt;</b>
<b class="nc"><i>1235</i>&nbsp;     *                            &lt;li&gt;&amp;lt;propertyPattern&amp;gt; is a boolean which</b>
<i>1236</i>&nbsp;     *                                is &lt;code&gt;true&lt;/code&gt; if this
<i>1237</i>&nbsp;     *                                {@link ObjectName} contains a pattern in
<i>1238</i>&nbsp;     *                                the list of properties&lt;/li&gt;
<i>1239</i>&nbsp;     *                          &lt;/ul&gt;
<b class="nc"><i>1240</i>&nbsp;     *               &lt;/li&gt;</b>
<b class="nc"><i>1241</i>&nbsp;     *             &lt;/ul&gt;</b>
<i>1242</i>&nbsp;     */
<i>1243</i>&nbsp;    private void writeObject(ObjectOutputStream out)
<i>1244</i>&nbsp;            throws IOException {
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;      if (compat)
<i>1247</i>&nbsp;      {
<i>1248</i>&nbsp;        // Serializes this instance in the old serial form
<i>1249</i>&nbsp;        // Read CR 6441274 before making any changes to this code
<i>1250</i>&nbsp;        ObjectOutputStream.PutField fields = out.putFields();
<i>1251</i>&nbsp;        fields.put(&quot;domain&quot;, _canonicalName.substring(0, getDomainLength()));
<i>1252</i>&nbsp;        fields.put(&quot;propertyList&quot;, getKeyPropertyList());
<i>1253</i>&nbsp;        fields.put(&quot;propertyListString&quot;, getKeyPropertyListString());
<i>1254</i>&nbsp;        fields.put(&quot;canonicalName&quot;, _canonicalName);
<i>1255</i>&nbsp;        fields.put(&quot;pattern&quot;, (_compressed_storage &amp; (DOMAIN_PATTERN | PROPLIST_PATTERN)) != 0);
<i>1256</i>&nbsp;        fields.put(&quot;propertyPattern&quot;, isPropertyListPattern());
<i>1257</i>&nbsp;        out.writeFields();
<i>1258</i>&nbsp;      }
<i>1259</i>&nbsp;      else
<i>1260</i>&nbsp;      {
<i>1261</i>&nbsp;        // Serializes this instance in the new serial form
<i>1262</i>&nbsp;        //
<i>1263</i>&nbsp;        out.defaultWriteObject();
<i>1264</i>&nbsp;        out.writeObject(getSerializedNameString());
<i>1265</i>&nbsp;      }
<i>1266</i>&nbsp;    }
<i>1267</i>&nbsp;
<i>1268</i>&nbsp;    //  Category : Serialization &lt;===================================
<i>1269</i>&nbsp;
<i>1270</i>&nbsp;    // Private methods &lt;========================================
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;    // Public methods ----------------------------------------&gt;
<b class="nc"><i>1273</i>&nbsp;</b>
<i>1274</i>&nbsp;    // Category : ObjectName Construction ------------------------------&gt;
<i>1275</i>&nbsp;
<i>1276</i>&nbsp;    /**
<i>1277</i>&nbsp;     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
<i>1278</i>&nbsp;     * an object obtained with {@link #ObjectName(String) new
<i>1279</i>&nbsp;     * ObjectName(name)} can be used.  The returned object may be of
<i>1280</i>&nbsp;     * a subclass of ObjectName.  Calling this method twice with the
<i>1281</i>&nbsp;     * same parameters may return the same object or two equal but
<i>1282</i>&nbsp;     * not identical objects.&lt;/p&gt;
<i>1283</i>&nbsp;     *
<i>1284</i>&nbsp;     * @param name  A string representation of the object name.
<i>1285</i>&nbsp;     *
<i>1286</i>&nbsp;     * @return an ObjectName corresponding to the given String.
<i>1287</i>&nbsp;     *
<i>1288</i>&nbsp;     * @exception MalformedObjectNameException The string passed as a
<i>1289</i>&nbsp;     * parameter does not have the right format.
<i>1290</i>&nbsp;     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
<i>1291</i>&nbsp;     * is null.
<i>1292</i>&nbsp;     *
<i>1293</i>&nbsp;     */
<i>1294</i>&nbsp;    public static ObjectName getInstance(String name)
<i>1295</i>&nbsp;            throws MalformedObjectNameException, NullPointerException {
<i>1296</i>&nbsp;        return new ObjectName(name);
<i>1297</i>&nbsp;    }
<i>1298</i>&nbsp;
<i>1299</i>&nbsp;    /**
<i>1300</i>&nbsp;     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
<b class="nc"><i>1301</i>&nbsp;     * an object obtained with {@link #ObjectName(String, String,</b>
<i>1302</i>&nbsp;     * String) new ObjectName(domain, key, value)} can be used.  The
<i>1303</i>&nbsp;     * returned object may be of a subclass of ObjectName.  Calling
<i>1304</i>&nbsp;     * this method twice with the same parameters may return the same
<i>1305</i>&nbsp;     * object or two equal but not identical objects.&lt;/p&gt;
<i>1306</i>&nbsp;     *
<i>1307</i>&nbsp;     * @param domain  The domain part of the object name.
<i>1308</i>&nbsp;     * @param key  The attribute in the key property of the object name.
<i>1309</i>&nbsp;     * @param value The value in the key property of the object name.
<i>1310</i>&nbsp;     *
<i>1311</i>&nbsp;     * @return an ObjectName corresponding to the given domain,
<i>1312</i>&nbsp;     * key, and value.
<i>1313</i>&nbsp;     *
<i>1314</i>&nbsp;     * @exception MalformedObjectNameException The
<i>1315</i>&nbsp;     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
<i>1316</i>&nbsp;     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
<i>1317</i>&nbsp;     * follow the rules for quoting, or the domain&#39;s length exceeds
<i>1318</i>&nbsp;     * the maximum allowed length.
<i>1319</i>&nbsp;     * @exception NullPointerException One of the parameters is null.
<i>1320</i>&nbsp;     *
<i>1321</i>&nbsp;     */
<i>1322</i>&nbsp;    public static ObjectName getInstance(String domain, String key,
<i>1323</i>&nbsp;                                         String value)
<i>1324</i>&nbsp;            throws MalformedObjectNameException {
<i>1325</i>&nbsp;        return new ObjectName(domain, key, value);
<i>1326</i>&nbsp;    }
<i>1327</i>&nbsp;
<i>1328</i>&nbsp;    /**
<i>1329</i>&nbsp;     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
<i>1330</i>&nbsp;     * an object obtained with {@link #ObjectName(String, Hashtable)
<i>1331</i>&nbsp;     * new ObjectName(domain, table)} can be used.  The returned
<b class="nc"><i>1332</i>&nbsp;     * object may be of a subclass of ObjectName.  Calling this method</b>
<i>1333</i>&nbsp;     * twice with the same parameters may return the same object or
<i>1334</i>&nbsp;     * two equal but not identical objects.&lt;/p&gt;
<i>1335</i>&nbsp;     *
<i>1336</i>&nbsp;     * @param domain  The domain part of the object name.
<i>1337</i>&nbsp;     * @param table A hash table containing one or more key
<i>1338</i>&nbsp;     * properties.  The key of each entry in the table is the key of a
<i>1339</i>&nbsp;     * key property in the object name.  The associated value in the
<i>1340</i>&nbsp;     * table is the associated value in the object name.
<i>1341</i>&nbsp;     *
<i>1342</i>&nbsp;     * @return an ObjectName corresponding to the given domain and
<i>1343</i>&nbsp;     * key mappings.
<i>1344</i>&nbsp;     *
<i>1345</i>&nbsp;     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
<i>1346</i>&nbsp;     * contains an illegal character, or one of the keys or values in
<i>1347</i>&nbsp;     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
<i>1348</i>&nbsp;     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
<i>1349</i>&nbsp;     * quoting, or the domain&#39;s length exceeds the maximum allowed length.
<i>1350</i>&nbsp;     * @exception NullPointerException One of the parameters is null.
<i>1351</i>&nbsp;     *
<i>1352</i>&nbsp;     */
<i>1353</i>&nbsp;    public static ObjectName getInstance(String domain,
<i>1354</i>&nbsp;                                         Hashtable&lt;String,String&gt; table)
<i>1355</i>&nbsp;        throws MalformedObjectNameException {
<i>1356</i>&nbsp;        return new ObjectName(domain, table);
<i>1357</i>&nbsp;    }
<i>1358</i>&nbsp;
<i>1359</i>&nbsp;    /**
<i>1360</i>&nbsp;     * &lt;p&gt;Return an instance of ObjectName that can be used anywhere
<i>1361</i>&nbsp;     * the given object can be used.  The returned object may be of a
<i>1362</i>&nbsp;     * subclass of ObjectName.  If &lt;code&gt;name&lt;/code&gt; is of a subclass
<i>1363</i>&nbsp;     * of ObjectName, it is not guaranteed that the returned object
<i>1364</i>&nbsp;     * will be of the same class.&lt;/p&gt;
<b class="nc"><i>1365</i>&nbsp;     *</b>
<b class="nc"><i>1366</i>&nbsp;     * &lt;p&gt;The returned value may or may not be identical to</b>
<b class="nc"><i>1367</i>&nbsp;     * &lt;code&gt;name&lt;/code&gt;.  Calling this method twice with the same</b>
<i>1368</i>&nbsp;     * parameters may return the same object or two equal but not
<i>1369</i>&nbsp;     * identical objects.&lt;/p&gt;
<i>1370</i>&nbsp;     *
<i>1371</i>&nbsp;     * &lt;p&gt;Since ObjectName is immutable, it is not usually useful to
<i>1372</i>&nbsp;     * make a copy of an ObjectName.  The principal use of this method
<i>1373</i>&nbsp;     * is to guard against a malicious caller who might pass an
<i>1374</i>&nbsp;     * instance of a subclass with surprising behavior to sensitive
<i>1375</i>&nbsp;     * code.  Such code can call this method to obtain an ObjectName
<i>1376</i>&nbsp;     * that is known not to have surprising behavior.&lt;/p&gt;
<i>1377</i>&nbsp;     *
<i>1378</i>&nbsp;     * @param name an instance of the ObjectName class or of a subclass
<i>1379</i>&nbsp;     *
<i>1380</i>&nbsp;     * @return an instance of ObjectName or a subclass that is known to
<b class="nc"><i>1381</i>&nbsp;     * have the same semantics.  If &lt;code&gt;name&lt;/code&gt; respects the</b>
<b class="nc"><i>1382</i>&nbsp;     * semantics of ObjectName, then the returned object is equal</b>
<i>1383</i>&nbsp;     * (though not necessarily identical) to &lt;code&gt;name&lt;/code&gt;.
<i>1384</i>&nbsp;     *
<i>1385</i>&nbsp;     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; is null.
<i>1386</i>&nbsp;     *
<i>1387</i>&nbsp;     */
<i>1388</i>&nbsp;    public static ObjectName getInstance(ObjectName name) {
<i>1389</i>&nbsp;        if (name.getClass().equals(ObjectName.class))
<i>1390</i>&nbsp;            return name;
<i>1391</i>&nbsp;        return Util.newObjectName(name.getSerializedNameString());
<i>1392</i>&nbsp;    }
<i>1393</i>&nbsp;
<i>1394</i>&nbsp;    /**
<i>1395</i>&nbsp;     * Construct an object name from the given string.
<i>1396</i>&nbsp;     *
<i>1397</i>&nbsp;     * @param name  A string representation of the object name.
<i>1398</i>&nbsp;     *
<b class="nc"><i>1399</i>&nbsp;     * @exception MalformedObjectNameException The string passed as a</b>
<i>1400</i>&nbsp;     * parameter does not have the right format.
<i>1401</i>&nbsp;     * @exception NullPointerException The &lt;code&gt;name&lt;/code&gt; parameter
<i>1402</i>&nbsp;     * is null.
<b class="nc"><i>1403</i>&nbsp;     */</b>
<b class="nc"><i>1404</i>&nbsp;    public ObjectName(String name)</b>
<i>1405</i>&nbsp;        throws MalformedObjectNameException {
<i>1406</i>&nbsp;        construct(name);
<i>1407</i>&nbsp;    }
<i>1408</i>&nbsp;
<i>1409</i>&nbsp;    /**
<i>1410</i>&nbsp;     * Construct an object name with exactly one key property.
<i>1411</i>&nbsp;     *
<i>1412</i>&nbsp;     * @param domain  The domain part of the object name.
<i>1413</i>&nbsp;     * @param key  The attribute in the key property of the object name.
<i>1414</i>&nbsp;     * @param value The value in the key property of the object name.
<i>1415</i>&nbsp;     *
<i>1416</i>&nbsp;     * @exception MalformedObjectNameException The
<i>1417</i>&nbsp;     * &lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;value&lt;/code&gt;
<i>1418</i>&nbsp;     * contains an illegal character, or &lt;code&gt;value&lt;/code&gt; does not
<i>1419</i>&nbsp;     * follow the rules for quoting, or the domain&#39;s length exceeds
<i>1420</i>&nbsp;     * the maximum allowed length.
<i>1421</i>&nbsp;     * @exception NullPointerException One of the parameters is null.
<i>1422</i>&nbsp;     */
<i>1423</i>&nbsp;    public ObjectName(String domain, String key, String value)
<b class="nc"><i>1424</i>&nbsp;        throws MalformedObjectNameException {</b>
<b class="nc"><i>1425</i>&nbsp;        // If key or value are null a NullPointerException</b>
<i>1426</i>&nbsp;        // will be thrown by the put method in Hashtable.
<i>1427</i>&nbsp;        //
<i>1428</i>&nbsp;        Map&lt;String,String&gt; table = Collections.singletonMap(key, value);
<i>1429</i>&nbsp;        construct(domain, table);
<i>1430</i>&nbsp;    }
<i>1431</i>&nbsp;
<i>1432</i>&nbsp;    /**
<i>1433</i>&nbsp;     * Construct an object name with several key properties from a Hashtable.
<i>1434</i>&nbsp;     *
<i>1435</i>&nbsp;     * @param domain  The domain part of the object name.
<i>1436</i>&nbsp;     * @param table A hash table containing one or more key
<i>1437</i>&nbsp;     * properties.  The key of each entry in the table is the key of a
<i>1438</i>&nbsp;     * key property in the object name.  The associated value in the
<i>1439</i>&nbsp;     * table is the associated value in the object name.
<i>1440</i>&nbsp;     *
<i>1441</i>&nbsp;     * @exception MalformedObjectNameException The &lt;code&gt;domain&lt;/code&gt;
<i>1442</i>&nbsp;     * contains an illegal character, or one of the keys or values in
<i>1443</i>&nbsp;     * &lt;code&gt;table&lt;/code&gt; contains an illegal character, or one of the
<i>1444</i>&nbsp;     * values in &lt;code&gt;table&lt;/code&gt; does not follow the rules for
<i>1445</i>&nbsp;     * quoting, or the domain&#39;s length exceeds the maximum allowed length.
<b class="nc"><i>1446</i>&nbsp;     * @exception NullPointerException One of the parameters is null.</b>
<i>1447</i>&nbsp;     */
<i>1448</i>&nbsp;    public ObjectName(String domain, Hashtable&lt;String,String&gt; table)
<i>1449</i>&nbsp;            throws MalformedObjectNameException {
<i>1450</i>&nbsp;        construct(domain, table);
<i>1451</i>&nbsp;        /* The exception for when a key or value in the table is not a
<i>1452</i>&nbsp;           String is now ClassCastException rather than
<i>1453</i>&nbsp;           MalformedObjectNameException.  This was not previously
<i>1454</i>&nbsp;           specified.  */
<i>1455</i>&nbsp;    }
<i>1456</i>&nbsp;
<i>1457</i>&nbsp;    // Category : ObjectName Construction &lt;==============================
<b class="nc"><i>1458</i>&nbsp;</b>
<i>1459</i>&nbsp;
<i>1460</i>&nbsp;    // Category : Getter methods ------------------------------&gt;
<i>1461</i>&nbsp;
<i>1462</i>&nbsp;    /**
<i>1463</i>&nbsp;     * Checks whether the object name is a pattern.
<i>1464</i>&nbsp;     * &lt;p&gt;
<i>1465</i>&nbsp;     * An object name is a pattern if its domain contains a
<i>1466</i>&nbsp;     * wildcard or if the object name is a property pattern.
<i>1467</i>&nbsp;     *
<i>1468</i>&nbsp;     * @return  True if the name is a pattern, otherwise false.
<i>1469</i>&nbsp;     */
<i>1470</i>&nbsp;    public boolean isPattern() {
<b class="nc"><i>1471</i>&nbsp;        return (_compressed_storage &amp; FLAG_MASK) != 0;</b>
<i>1472</i>&nbsp;    }
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;    /**
<i>1475</i>&nbsp;     * Checks whether the object name is a pattern on the domain part.
<i>1476</i>&nbsp;     *
<i>1477</i>&nbsp;     * @return  True if the name is a domain pattern, otherwise false.
<i>1478</i>&nbsp;     *
<i>1479</i>&nbsp;     */
<i>1480</i>&nbsp;    public boolean isDomainPattern() {
<i>1481</i>&nbsp;        return (_compressed_storage &amp; DOMAIN_PATTERN) != 0;
<i>1482</i>&nbsp;    }
<i>1483</i>&nbsp;
<i>1484</i>&nbsp;    /**
<b class="nc"><i>1485</i>&nbsp;     * Marks the object name as representing a pattern on the domain part.</b>
<i>1486</i>&nbsp;     * @param value {@code true} if the domain name is a pattern,
<i>1487</i>&nbsp;     *              {@code false} otherwise
<i>1488</i>&nbsp;     */
<i>1489</i>&nbsp;    private void setDomainPattern(boolean value) {
<i>1490</i>&nbsp;        if (value) {
<i>1491</i>&nbsp;            _compressed_storage |= DOMAIN_PATTERN;
<i>1492</i>&nbsp;        } else {
<i>1493</i>&nbsp;            _compressed_storage &amp;= ~DOMAIN_PATTERN;
<i>1494</i>&nbsp;        }
<i>1495</i>&nbsp;    }
<i>1496</i>&nbsp;
<i>1497</i>&nbsp;    /**
<i>1498</i>&nbsp;     * Checks whether the object name is a pattern on the key properties.
<i>1499</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1500</i>&nbsp;     * An object name is a pattern on the key properties if it is a</b>
<i>1501</i>&nbsp;     * pattern on the key property list (e.g. &quot;d:k=v,*&quot;) or on the
<i>1502</i>&nbsp;     * property values (e.g. &quot;d:k=*&quot;) or on both (e.g. &quot;d:k=*,*&quot;).
<i>1503</i>&nbsp;     *
<i>1504</i>&nbsp;     * @return  True if the name is a property pattern, otherwise false.
<i>1505</i>&nbsp;     */
<i>1506</i>&nbsp;    public boolean isPropertyPattern() {
<i>1507</i>&nbsp;        return (_compressed_storage &amp; (PROPVAL_PATTERN | PROPLIST_PATTERN)) != 0;
<i>1508</i>&nbsp;    }
<i>1509</i>&nbsp;
<i>1510</i>&nbsp;    /**
<i>1511</i>&nbsp;     * Checks whether the object name is a pattern on the key property list.
<i>1512</i>&nbsp;     * &lt;p&gt;
<i>1513</i>&nbsp;     * For example, &quot;d:k=v,*&quot; and &quot;d:k=*,*&quot; are key property list patterns
<i>1514</i>&nbsp;     * whereas &quot;d:k=*&quot; is not.
<i>1515</i>&nbsp;     *
<i>1516</i>&nbsp;     * @return  True if the name is a property list pattern, otherwise false.
<i>1517</i>&nbsp;     *
<i>1518</i>&nbsp;     * @since 1.6
<b class="nc"><i>1519</i>&nbsp;     */</b>
<b class="nc"><i>1520</i>&nbsp;    public boolean isPropertyListPattern() {</b>
<b class="nc"><i>1521</i>&nbsp;        return (_compressed_storage &amp; PROPLIST_PATTERN) != 0;</b>
<b class="nc"><i>1522</i>&nbsp;    }</b>
<b class="nc"><i>1523</i>&nbsp;</b>
<b class="nc"><i>1524</i>&nbsp;    /**</b>
<b class="nc"><i>1525</i>&nbsp;     * Marks the object name as representing a pattern on the key property list.</b>
<i>1526</i>&nbsp;     * @param value {@code true} if the key property list is a pattern,
<b class="nc"><i>1527</i>&nbsp;     *              {@code false} otherwise</b>
<i>1528</i>&nbsp;     */
<i>1529</i>&nbsp;    private void setPropertyListPattern(boolean value) {
<i>1530</i>&nbsp;        if (value) {
<i>1531</i>&nbsp;            _compressed_storage |= PROPLIST_PATTERN;
<i>1532</i>&nbsp;        } else {
<i>1533</i>&nbsp;            _compressed_storage &amp;= ~PROPLIST_PATTERN;
<i>1534</i>&nbsp;        }
<i>1535</i>&nbsp;    }
<i>1536</i>&nbsp;
<i>1537</i>&nbsp;    /**
<i>1538</i>&nbsp;     * Checks whether the object name is a pattern on the value part
<i>1539</i>&nbsp;     * of at least one of the key properties.
<i>1540</i>&nbsp;     * &lt;p&gt;
<i>1541</i>&nbsp;     * For example, &quot;d:k=*&quot; and &quot;d:k=*,*&quot; are property value patterns
<i>1542</i>&nbsp;     * whereas &quot;d:k=v,*&quot; is not.
<i>1543</i>&nbsp;     *
<i>1544</i>&nbsp;     * @return  True if the name is a property value pattern, otherwise false.
<i>1545</i>&nbsp;     *
<i>1546</i>&nbsp;     * @since 1.6
<i>1547</i>&nbsp;     */
<i>1548</i>&nbsp;    public boolean isPropertyValuePattern() {
<i>1549</i>&nbsp;        return (_compressed_storage &amp; PROPVAL_PATTERN) != 0;
<i>1550</i>&nbsp;    }
<i>1551</i>&nbsp;
<i>1552</i>&nbsp;    /**
<i>1553</i>&nbsp;     * Marks the object name as representing a pattern on the value part.
<i>1554</i>&nbsp;     * @param value {@code true} if the value part of at least one of the
<i>1555</i>&nbsp;     *              key properties is a pattern, {@code false} otherwise
<i>1556</i>&nbsp;     */
<b class="nc"><i>1557</i>&nbsp;    private void setPropertyValuePattern(boolean value) {</b>
<i>1558</i>&nbsp;        if (value) {
<i>1559</i>&nbsp;            _compressed_storage |= PROPVAL_PATTERN;
<i>1560</i>&nbsp;        } else {
<i>1561</i>&nbsp;            _compressed_storage &amp;= ~PROPVAL_PATTERN;
<i>1562</i>&nbsp;        }
<i>1563</i>&nbsp;    }
<i>1564</i>&nbsp;
<i>1565</i>&nbsp;    /**
<b class="nc"><i>1566</i>&nbsp;     * Checks whether the value associated with a key in a key</b>
<i>1567</i>&nbsp;     * property is a pattern.
<i>1568</i>&nbsp;     *
<i>1569</i>&nbsp;     * @param property The property whose value is to be checked.
<i>1570</i>&nbsp;     *
<i>1571</i>&nbsp;     * @return True if the value associated with the given key property
<i>1572</i>&nbsp;     * is a pattern, otherwise false.
<i>1573</i>&nbsp;     *
<i>1574</i>&nbsp;     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.
<i>1575</i>&nbsp;     * @exception IllegalArgumentException If &lt;code&gt;property&lt;/code&gt; is not
<i>1576</i>&nbsp;     * a valid key property for this ObjectName.
<i>1577</i>&nbsp;     *
<i>1578</i>&nbsp;     * @since 1.6
<i>1579</i>&nbsp;     */
<b class="nc"><i>1580</i>&nbsp;    public boolean isPropertyValuePattern(String property) {</b>
<i>1581</i>&nbsp;        if (property == null)
<i>1582</i>&nbsp;            throw new NullPointerException(&quot;key property can&#39;t be null&quot;);
<i>1583</i>&nbsp;        for (int i = 0; i &lt; _ca_array.length; i++) {
<i>1584</i>&nbsp;            Property prop = _ca_array[i];
<i>1585</i>&nbsp;            String key = prop.getKeyString(_canonicalName);
<i>1586</i>&nbsp;            if (key.equals(property))
<i>1587</i>&nbsp;                return (prop instanceof PatternProperty);
<i>1588</i>&nbsp;        }
<i>1589</i>&nbsp;        throw new IllegalArgumentException(&quot;key property not found&quot;);
<i>1590</i>&nbsp;    }
<i>1591</i>&nbsp;
<i>1592</i>&nbsp;    /**
<i>1593</i>&nbsp;     * &lt;p&gt;Returns the canonical form of the name; that is, a string
<b class="nc"><i>1594</i>&nbsp;     * representation where the properties are sorted in lexical</b>
<b class="nc"><i>1595</i>&nbsp;     * order.&lt;/p&gt;</b>
<i>1596</i>&nbsp;     *
<i>1597</i>&nbsp;     * &lt;p&gt;More precisely, the canonical form of the name is a String
<b class="nc"><i>1598</i>&nbsp;     * consisting of the &lt;em&gt;domain part&lt;/em&gt;, a colon</b>
<b class="nc"><i>1599</i>&nbsp;     * (&lt;code&gt;:&lt;/code&gt;), the &lt;em&gt;canonical key property list&lt;/em&gt;, and</b>
<i>1600</i>&nbsp;     * a &lt;em&gt;pattern indication&lt;/em&gt;.&lt;/p&gt;
<b class="nc"><i>1601</i>&nbsp;     *</b>
<b class="nc"><i>1602</i>&nbsp;     * &lt;p&gt;The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string</b>
<b class="nc"><i>1603</i>&nbsp;     * as described for {@link #getCanonicalKeyPropertyListString()}.&lt;/p&gt;</b>
<b class="nc"><i>1604</i>&nbsp;     *</b>
<i>1605</i>&nbsp;     * &lt;p&gt;The &lt;em&gt;pattern indication&lt;/em&gt; is:
<i>1606</i>&nbsp;     * &lt;ul&gt;
<b class="nc"><i>1607</i>&nbsp;     * &lt;li&gt;empty for an ObjectName</b>
<b class="nc"><i>1608</i>&nbsp;     * that is not a property list pattern;</b>
<i>1609</i>&nbsp;     * &lt;li&gt;an asterisk for an ObjectName
<i>1610</i>&nbsp;     * that is a property list pattern with no keys; or
<i>1611</i>&nbsp;     * &lt;li&gt;a comma and an
<i>1612</i>&nbsp;     * asterisk (&lt;code&gt;,*&lt;/code&gt;) for an ObjectName that is a property
<i>1613</i>&nbsp;     * list pattern with at least one key.
<i>1614</i>&nbsp;     * &lt;/ul&gt;
<i>1615</i>&nbsp;     *
<i>1616</i>&nbsp;     * @return The canonical form of the name.
<i>1617</i>&nbsp;     */
<i>1618</i>&nbsp;    public String getCanonicalName()  {
<i>1619</i>&nbsp;        return _canonicalName;
<i>1620</i>&nbsp;    }
<i>1621</i>&nbsp;
<i>1622</i>&nbsp;    /**
<i>1623</i>&nbsp;     * Returns the domain part.
<b class="nc"><i>1624</i>&nbsp;     *</b>
<i>1625</i>&nbsp;     * @return The domain.
<i>1626</i>&nbsp;     */
<i>1627</i>&nbsp;    public String getDomain()  {
<i>1628</i>&nbsp;        return _canonicalName.substring(0, getDomainLength());
<i>1629</i>&nbsp;    }
<i>1630</i>&nbsp;
<i>1631</i>&nbsp;    /**
<i>1632</i>&nbsp;     * Obtains the value associated with a key in a key property.
<i>1633</i>&nbsp;     *
<i>1634</i>&nbsp;     * @param property The property whose value is to be obtained.
<i>1635</i>&nbsp;     *
<i>1636</i>&nbsp;     * @return The value of the property, or null if there is no such
<i>1637</i>&nbsp;     * property in this ObjectName.
<i>1638</i>&nbsp;     *
<b class="nc"><i>1639</i>&nbsp;     * @exception NullPointerException If &lt;code&gt;property&lt;/code&gt; is null.</b>
<i>1640</i>&nbsp;     */
<i>1641</i>&nbsp;    public String getKeyProperty(String property) {
<i>1642</i>&nbsp;        return _getKeyPropertyList().get(property);
<b class="nc"><i>1643</i>&nbsp;    }</b>
<i>1644</i>&nbsp;
<i>1645</i>&nbsp;    /**
<b class="nc"><i>1646</i>&nbsp;     * &lt;p&gt;Returns the key properties as a Map.  The returned</b>
<b class="nc"><i>1647</i>&nbsp;     * value is a Map in which each key is a key in the</b>
<b class="nc"><i>1648</i>&nbsp;     * ObjectName&#39;s key property list and each value is the associated</b>
<b class="nc"><i>1649</i>&nbsp;     * value.&lt;/p&gt;</b>
<i>1650</i>&nbsp;     *
<i>1651</i>&nbsp;     * &lt;p&gt;The returned value must not be modified.&lt;/p&gt;
<i>1652</i>&nbsp;     *
<i>1653</i>&nbsp;     * @return The table of key properties.
<i>1654</i>&nbsp;     */
<i>1655</i>&nbsp;    private Map&lt;String,String&gt; _getKeyPropertyList()  {
<i>1656</i>&nbsp;        synchronized (this) {
<i>1657</i>&nbsp;            if (_propertyList == null) {
<i>1658</i>&nbsp;                // build (lazy eval) the property list from the canonical
<i>1659</i>&nbsp;                // properties array
<i>1660</i>&nbsp;                _propertyList = new HashMap&lt;String,String&gt;();
<i>1661</i>&nbsp;                int len = _ca_array.length;
<i>1662</i>&nbsp;                Property prop;
<i>1663</i>&nbsp;                for (int i = len - 1; i &gt;= 0; i--) {
<i>1664</i>&nbsp;                    prop = _ca_array[i];
<b class="nc"><i>1665</i>&nbsp;                    _propertyList.put(prop.getKeyString(_canonicalName),</b>
<b class="nc"><i>1666</i>&nbsp;                                      prop.getValueString(_canonicalName));</b>
<b class="nc"><i>1667</i>&nbsp;                }</b>
<b class="nc"><i>1668</i>&nbsp;            }</b>
<i>1669</i>&nbsp;        }
<i>1670</i>&nbsp;        return _propertyList;
<i>1671</i>&nbsp;    }
<b class="nc"><i>1672</i>&nbsp;</b>
<i>1673</i>&nbsp;    /**
<i>1674</i>&nbsp;     * &lt;p&gt;Returns the key properties as a Hashtable.  The returned
<b class="nc"><i>1675</i>&nbsp;     * value is a Hashtable in which each key is a key in the</b>
<i>1676</i>&nbsp;     * ObjectName&#39;s key property list and each value is the associated
<i>1677</i>&nbsp;     * value.&lt;/p&gt;
<b class="nc"><i>1678</i>&nbsp;     *</b>
<b class="nc"><i>1679</i>&nbsp;     * &lt;p&gt;The returned value may be unmodifiable.  If it is</b>
<i>1680</i>&nbsp;     * modifiable, changing it has no effect on this ObjectName.&lt;/p&gt;
<b class="nc"><i>1681</i>&nbsp;     *</b>
<i>1682</i>&nbsp;     * @return The table of key properties.
<i>1683</i>&nbsp;     */
<b class="nc"><i>1684</i>&nbsp;    // CR 6441274 depends on the modification property defined above</b>
<b class="nc"><i>1685</i>&nbsp;    public Hashtable&lt;String,String&gt; getKeyPropertyList()  {</b>
<i>1686</i>&nbsp;        return new Hashtable&lt;String,String&gt;(_getKeyPropertyList());
<i>1687</i>&nbsp;    }
<i>1688</i>&nbsp;
<b class="nc"><i>1689</i>&nbsp;    /**</b>
<i>1690</i>&nbsp;     * &lt;p&gt;Returns a string representation of the list of key
<i>1691</i>&nbsp;     * properties specified at creation time.  If this ObjectName was
<i>1692</i>&nbsp;     * constructed with the constructor {@link #ObjectName(String)},
<i>1693</i>&nbsp;     * the key properties in the returned String will be in the same
<i>1694</i>&nbsp;     * order as in the argument to the constructor.&lt;/p&gt;
<i>1695</i>&nbsp;     *
<i>1696</i>&nbsp;     * @return The key property list string.  This string is
<i>1697</i>&nbsp;     * independent of whether the ObjectName is a pattern.
<i>1698</i>&nbsp;     */
<i>1699</i>&nbsp;    public String getKeyPropertyListString()  {
<i>1700</i>&nbsp;        // BEWARE : we rebuild the propertyliststring at each call !!
<i>1701</i>&nbsp;        if (_kp_array.length == 0) return &quot;&quot;;
<i>1702</i>&nbsp;
<i>1703</i>&nbsp;        // the size of the string is the canonical one minus domain
<b class="nc"><i>1704</i>&nbsp;        // part and pattern part</b>
<i>1705</i>&nbsp;        final int total_size = _canonicalName.length() - getDomainLength() - 1
<b class="nc"><i>1706</i>&nbsp;            - (isPropertyListPattern()?2:0);</b>
<b class="nc"><i>1707</i>&nbsp;</b>
<i>1708</i>&nbsp;        final char[] dest_chars = new char[total_size];
<b class="nc"><i>1709</i>&nbsp;        final char[] value = _canonicalName.toCharArray();</b>
<b class="nc"><i>1710</i>&nbsp;        writeKeyPropertyListString(value,dest_chars,0);</b>
<b class="nc"><i>1711</i>&nbsp;        return new String(dest_chars);</b>
<b class="nc"><i>1712</i>&nbsp;    }</b>
<b class="nc"><i>1713</i>&nbsp;</b>
<b class="nc"><i>1714</i>&nbsp;    /**</b>
<b class="nc"><i>1715</i>&nbsp;     * &lt;p&gt;Returns the serialized string of the ObjectName.</b>
<i>1716</i>&nbsp;     * properties specified at creation time.  If this ObjectName was
<b class="nc"><i>1717</i>&nbsp;     * constructed with the constructor {@link #ObjectName(String)},</b>
<b class="nc"><i>1718</i>&nbsp;     * the key properties in the returned String will be in the same</b>
<i>1719</i>&nbsp;     * order as in the argument to the constructor.&lt;/p&gt;
<b class="nc"><i>1720</i>&nbsp;     *</b>
<i>1721</i>&nbsp;     * @return The key property list string.  This string is
<i>1722</i>&nbsp;     * independent of whether the ObjectName is a pattern.
<i>1723</i>&nbsp;     */
<i>1724</i>&nbsp;    private String getSerializedNameString()  {
<i>1725</i>&nbsp;
<i>1726</i>&nbsp;        // the size of the string is the canonical one
<i>1727</i>&nbsp;        final int total_size = _canonicalName.length();
<i>1728</i>&nbsp;        final char[] dest_chars = new char[total_size];
<i>1729</i>&nbsp;        final char[] value = _canonicalName.toCharArray();
<i>1730</i>&nbsp;        final int offset = getDomainLength() + 1;
<i>1731</i>&nbsp;
<i>1732</i>&nbsp;        // copy &quot;domain:&quot; into dest_chars
<i>1733</i>&nbsp;        //
<i>1734</i>&nbsp;        System.arraycopy(value, 0, dest_chars, 0, offset);
<i>1735</i>&nbsp;
<i>1736</i>&nbsp;        // Add property list string
<b class="nc"><i>1737</i>&nbsp;        final int end = writeKeyPropertyListString(value,dest_chars,offset);</b>
<i>1738</i>&nbsp;
<b class="nc"><i>1739</i>&nbsp;        // Add &quot;,*&quot; if necessary</b>
<b class="nc"><i>1740</i>&nbsp;        if (isPropertyListPattern()) {</b>
<b class="nc"><i>1741</i>&nbsp;            if (end == offset)  {</b>
<i>1742</i>&nbsp;                // Property list string is empty.
<i>1743</i>&nbsp;                dest_chars[end] = &#39;*&#39;;
<i>1744</i>&nbsp;            } else {
<i>1745</i>&nbsp;                // Property list string is not empty.
<i>1746</i>&nbsp;                dest_chars[end]   = &#39;,&#39;;
<i>1747</i>&nbsp;                dest_chars[end+1] = &#39;*&#39;;
<i>1748</i>&nbsp;            }
<i>1749</i>&nbsp;        }
<i>1750</i>&nbsp;
<i>1751</i>&nbsp;        return new String(dest_chars);
<i>1752</i>&nbsp;    }
<i>1753</i>&nbsp;
<i>1754</i>&nbsp;    /**
<i>1755</i>&nbsp;     * &lt;p&gt;Write a string representation of the list of key
<i>1756</i>&nbsp;     * properties specified at creation time in the given array, starting
<b class="nc"><i>1757</i>&nbsp;     * at the specified offset.  If this ObjectName was</b>
<i>1758</i>&nbsp;     * constructed with the constructor {@link #ObjectName(String)},
<i>1759</i>&nbsp;     * the key properties in the returned String will be in the same
<i>1760</i>&nbsp;     * order as in the argument to the constructor.&lt;/p&gt;
<i>1761</i>&nbsp;     *
<i>1762</i>&nbsp;     * @return offset + #of chars written
<i>1763</i>&nbsp;     */
<i>1764</i>&nbsp;    private int writeKeyPropertyListString(char[] canonicalChars,
<i>1765</i>&nbsp;                                           char[] data, int offset)  {
<i>1766</i>&nbsp;        if (_kp_array.length == 0) return offset;
<i>1767</i>&nbsp;
<i>1768</i>&nbsp;        final char[] dest_chars = data;
<i>1769</i>&nbsp;        final char[] value = canonicalChars;
<i>1770</i>&nbsp;
<i>1771</i>&nbsp;        int index = offset;
<i>1772</i>&nbsp;        final int len = _kp_array.length;
<i>1773</i>&nbsp;        final int last = len - 1;
<i>1774</i>&nbsp;        for (int i = 0; i &lt; len; i++) {
<i>1775</i>&nbsp;            final Property prop = _kp_array[i];
<b class="nc"><i>1776</i>&nbsp;            final int prop_len = prop._key_length + prop._value_length + 1;</b>
<i>1777</i>&nbsp;            System.arraycopy(value, prop._key_index, dest_chars, index,
<i>1778</i>&nbsp;                             prop_len);
<b class="nc"><i>1779</i>&nbsp;            index += prop_len;</b>
<i>1780</i>&nbsp;            if (i &lt; last ) dest_chars[index++] = &#39;,&#39;;
<i>1781</i>&nbsp;        }
<i>1782</i>&nbsp;        return index;
<b class="nc"><i>1783</i>&nbsp;    }</b>
<b class="nc"><i>1784</i>&nbsp;</b>
<b class="nc"><i>1785</i>&nbsp;</b>
<i>1786</i>&nbsp;
<i>1787</i>&nbsp;    /**
<i>1788</i>&nbsp;     * Returns a string representation of the list of key properties,
<b class="nc"><i>1789</i>&nbsp;     * in which the key properties are sorted in lexical order. This</b>
<i>1790</i>&nbsp;     * is used in lexicographic comparisons performed in order to
<i>1791</i>&nbsp;     * select MBeans based on their key property list.  Lexical order
<i>1792</i>&nbsp;     * is the order implied by {@link String#compareTo(String)
<i>1793</i>&nbsp;     * String.compareTo(String)}.
<i>1794</i>&nbsp;     *
<i>1795</i>&nbsp;     * @return The canonical key property list string.  This string is
<i>1796</i>&nbsp;     * independent of whether the ObjectName is a pattern.
<i>1797</i>&nbsp;     */
<b class="nc"><i>1798</i>&nbsp;    public String getCanonicalKeyPropertyListString()  {</b>
<i>1799</i>&nbsp;        if (_ca_array.length == 0) return &quot;&quot;;
<i>1800</i>&nbsp;
<i>1801</i>&nbsp;        int len = _canonicalName.length();
<i>1802</i>&nbsp;        if (isPropertyListPattern()) len -= 2;
<i>1803</i>&nbsp;        return _canonicalName.substring(getDomainLength() + 1, len);
<i>1804</i>&nbsp;    }
<i>1805</i>&nbsp;    // Category : Getter methods &lt;===================================
<i>1806</i>&nbsp;
<i>1807</i>&nbsp;    // Category : Utilities ----------------------------------------&gt;
<i>1808</i>&nbsp;
<i>1809</i>&nbsp;    /**
<i>1810</i>&nbsp;     * &lt;p&gt;Returns a string representation of the object name.  The
<i>1811</i>&nbsp;     * format of this string is not specified, but users can expect
<i>1812</i>&nbsp;     * that two ObjectNames return the same string if and only if they
<i>1813</i>&nbsp;     * are equal.&lt;/p&gt;
<i>1814</i>&nbsp;     *
<i>1815</i>&nbsp;     * @return a string representation of this object name.
<i>1816</i>&nbsp;     */
<i>1817</i>&nbsp;    @Override
<i>1818</i>&nbsp;    public String toString()  {
<i>1819</i>&nbsp;        return getSerializedNameString();
<i>1820</i>&nbsp;    }
<i>1821</i>&nbsp;
<i>1822</i>&nbsp;    /**
<i>1823</i>&nbsp;     * Compares the current object name with another object name.  Two
<i>1824</i>&nbsp;     * ObjectName instances are equal if and only if their canonical
<i>1825</i>&nbsp;     * forms are equal.  The canonical form is the string described
<i>1826</i>&nbsp;     * for {@link #getCanonicalName()}.
<i>1827</i>&nbsp;     *
<i>1828</i>&nbsp;     * @param object  The object name that the current object name is to be
<i>1829</i>&nbsp;     *        compared with.
<i>1830</i>&nbsp;     *
<i>1831</i>&nbsp;     * @return True if &lt;code&gt;object&lt;/code&gt; is an ObjectName whose
<b class="nc"><i>1832</i>&nbsp;     * canonical form is equal to that of this ObjectName.</b>
<b class="nc"><i>1833</i>&nbsp;     */</b>
<b class="nc"><i>1834</i>&nbsp;    @Override</b>
<b class="nc"><i>1835</i>&nbsp;    public boolean equals(Object object)  {</b>
<b class="nc"><i>1836</i>&nbsp;</b>
<i>1837</i>&nbsp;        // same object case
<b class="nc"><i>1838</i>&nbsp;        if (this == object) return true;</b>
<b class="nc"><i>1839</i>&nbsp;</b>
<b class="nc"><i>1840</i>&nbsp;        // object is not an object name case</b>
<i>1841</i>&nbsp;        if (!(object instanceof ObjectName)) return false;
<i>1842</i>&nbsp;
<i>1843</i>&nbsp;        // equality when canonical names are the same
<i>1844</i>&nbsp;        // (because usage of intern())
<b class="nc"><i>1845</i>&nbsp;        ObjectName on = (ObjectName) object;</b>
<i>1846</i>&nbsp;        String on_string = on._canonicalName;
<i>1847</i>&nbsp;        if (_canonicalName == on_string) return true;  // ES: OK
<b class="nc"><i>1848</i>&nbsp;</b>
<i>1849</i>&nbsp;        // Because we are sharing canonical form between object names,
<b class="nc"><i>1850</i>&nbsp;        // we have finished the comparison at this stage ==&gt; unequal</b>
<b class="nc"><i>1851</i>&nbsp;        return false;</b>
<i>1852</i>&nbsp;   }
<i>1853</i>&nbsp;
<i>1854</i>&nbsp;    /**
<i>1855</i>&nbsp;     * Returns a hash code for this object name.
<i>1856</i>&nbsp;     *
<i>1857</i>&nbsp;     */
<i>1858</i>&nbsp;    @Override
<i>1859</i>&nbsp;    public int hashCode() {
<i>1860</i>&nbsp;        return _canonicalName.hashCode();
<i>1861</i>&nbsp;    }
<i>1862</i>&nbsp;
<i>1863</i>&nbsp;    /**
<i>1864</i>&nbsp;     * &lt;p&gt;Returns a quoted form of the given String, suitable for
<i>1865</i>&nbsp;     * inclusion in an ObjectName.  The returned value can be used as
<i>1866</i>&nbsp;     * the value associated with a key in an ObjectName.  The String
<i>1867</i>&nbsp;     * &lt;code&gt;s&lt;/code&gt; may contain any character.  Appropriate quoting
<i>1868</i>&nbsp;     * ensures that the returned value is legal in an ObjectName.&lt;/p&gt;
<i>1869</i>&nbsp;     *
<i>1870</i>&nbsp;     * &lt;p&gt;The returned value consists of a quote (&#39;&quot;&#39;), a sequence of
<i>1871</i>&nbsp;     * characters corresponding to the characters of &lt;code&gt;s&lt;/code&gt;,
<i>1872</i>&nbsp;     * and another quote.  Characters in &lt;code&gt;s&lt;/code&gt; appear
<i>1873</i>&nbsp;     * unchanged within the returned value except:&lt;/p&gt;
<i>1874</i>&nbsp;     *
<i>1875</i>&nbsp;     * &lt;ul&gt;
<b class="nc"><i>1876</i>&nbsp;     * &lt;li&gt;A quote (&#39;&quot;&#39;) is replaced by a backslash (\) followed by a quote.&lt;/li&gt;</b>
<b class="nc"><i>1877</i>&nbsp;     * &lt;li&gt;An asterisk (&#39;*&#39;) is replaced by a backslash (\) followed by an</b>
<b class="nc"><i>1878</i>&nbsp;     * asterisk.&lt;/li&gt;</b>
<b class="nc"><i>1879</i>&nbsp;     * &lt;li&gt;A question mark (&#39;?&#39;) is replaced by a backslash (\) followed by</b>
<b class="nc"><i>1880</i>&nbsp;     * a question mark.&lt;/li&gt;</b>
<b class="nc"><i>1881</i>&nbsp;     * &lt;li&gt;A backslash (&#39;\&#39;) is replaced by two backslashes.&lt;/li&gt;</b>
<b class="nc"><i>1882</i>&nbsp;     * &lt;li&gt;A newline character (the character &#39;\n&#39; in Java) is replaced</b>
<b class="nc"><i>1883</i>&nbsp;     * by a backslash followed by the character &#39;\n&#39;.&lt;/li&gt;</b>
<b class="nc"><i>1884</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>1885</i>&nbsp;     *</b>
<b class="nc"><i>1886</i>&nbsp;     * @param s the String to be quoted.</b>
<i>1887</i>&nbsp;     *
<b class="nc"><i>1888</i>&nbsp;     * @return the quoted String.</b>
<b class="nc"><i>1889</i>&nbsp;     *</b>
<i>1890</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;s&lt;/code&gt; is null.
<i>1891</i>&nbsp;     *
<i>1892</i>&nbsp;     */
<i>1893</i>&nbsp;    public static String quote(String s) {
<b class="nc"><i>1894</i>&nbsp;        final StringBuilder buf = new StringBuilder(&quot;\&quot;&quot;);</b>
<i>1895</i>&nbsp;        final int len = s.length();
<b class="nc"><i>1896</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<i>1897</i>&nbsp;            char c = s.charAt(i);
<i>1898</i>&nbsp;            switch (c) {
<i>1899</i>&nbsp;            case &#39;\n&#39;:
<b class="nc"><i>1900</i>&nbsp;                c = &#39;n&#39;;</b>
<i>1901</i>&nbsp;                buf.append(&#39;\\&#39;);
<i>1902</i>&nbsp;                break;
<i>1903</i>&nbsp;            case &#39;\\&#39;:
<i>1904</i>&nbsp;            case &#39;\&quot;&#39;:
<b class="nc"><i>1905</i>&nbsp;            case &#39;*&#39;:</b>
<i>1906</i>&nbsp;            case &#39;?&#39;:
<i>1907</i>&nbsp;                buf.append(&#39;\\&#39;);
<i>1908</i>&nbsp;                break;
<i>1909</i>&nbsp;            }
<b class="nc"><i>1910</i>&nbsp;            buf.append(c);</b>
<i>1911</i>&nbsp;        }
<b class="nc"><i>1912</i>&nbsp;        buf.append(&#39;&quot;&#39;);</b>
<i>1913</i>&nbsp;        return buf.toString();
<i>1914</i>&nbsp;    }
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;    /**
<i>1917</i>&nbsp;     * &lt;p&gt;Returns an unquoted form of the given String.  If
<i>1918</i>&nbsp;     * &lt;code&gt;q&lt;/code&gt; is a String returned by {@link #quote quote(s)},
<i>1919</i>&nbsp;     * then &lt;code&gt;unquote(q).equals(s)&lt;/code&gt;.  If there is no String
<b class="nc"><i>1920</i>&nbsp;     * &lt;code&gt;s&lt;/code&gt; for which &lt;code&gt;quote(s).equals(q)&lt;/code&gt;, then</b>
<i>1921</i>&nbsp;     * unquote(q) throws an IllegalArgumentException.&lt;/p&gt;
<i>1922</i>&nbsp;     *
<i>1923</i>&nbsp;     * &lt;p&gt;These rules imply that there is a one-to-one mapping between
<i>1924</i>&nbsp;     * quoted and unquoted forms.&lt;/p&gt;
<i>1925</i>&nbsp;     *
<i>1926</i>&nbsp;     * @param q the String to be unquoted.
<i>1927</i>&nbsp;     *
<i>1928</i>&nbsp;     * @return the unquoted String.
<i>1929</i>&nbsp;     *
<i>1930</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;q&lt;/code&gt; could not
<i>1931</i>&nbsp;     * have been returned by the {@link #quote} method, for instance
<i>1932</i>&nbsp;     * if it does not begin and end with a quote (&quot;).
<i>1933</i>&nbsp;     *
<i>1934</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;q&lt;/code&gt; is null.
<i>1935</i>&nbsp;     *
<i>1936</i>&nbsp;     */
<i>1937</i>&nbsp;    public static String unquote(String q) {
<i>1938</i>&nbsp;        final StringBuilder buf = new StringBuilder();
<i>1939</i>&nbsp;        final int len = q.length();
<i>1940</i>&nbsp;        if (len &lt; 2 || q.charAt(0) != &#39;&quot;&#39; || q.charAt(len - 1) != &#39;&quot;&#39;)
<i>1941</i>&nbsp;            throw new IllegalArgumentException(&quot;Argument not quoted&quot;);
<i>1942</i>&nbsp;        for (int i = 1; i &lt; len - 1; i++) {
<i>1943</i>&nbsp;            char c = q.charAt(i);
<i>1944</i>&nbsp;            if (c == &#39;\\&#39;) {
<b class="nc"><i>1945</i>&nbsp;                if (i == len - 2)</b>
<i>1946</i>&nbsp;                    throw new IllegalArgumentException(&quot;Trailing backslash&quot;);
<b class="nc"><i>1947</i>&nbsp;                c = q.charAt(++i);</b>
<i>1948</i>&nbsp;                switch (c) {
<i>1949</i>&nbsp;                case &#39;n&#39;:
<b class="nc"><i>1950</i>&nbsp;                    c = &#39;\n&#39;;</b>
<i>1951</i>&nbsp;                    break;
<i>1952</i>&nbsp;                case &#39;\\&#39;:
<b class="nc"><i>1953</i>&nbsp;                case &#39;\&quot;&#39;:</b>
<i>1954</i>&nbsp;                case &#39;*&#39;:
<i>1955</i>&nbsp;                case &#39;?&#39;:
<b class="nc"><i>1956</i>&nbsp;                    break;</b>
<i>1957</i>&nbsp;                default:
<b class="nc"><i>1958</i>&nbsp;                  throw new IllegalArgumentException(</b>
<i>1959</i>&nbsp;                                   &quot;Bad character &#39;&quot; + c + &quot;&#39; after backslash&quot;);
<i>1960</i>&nbsp;                }
<i>1961</i>&nbsp;            } else {
<b class="nc"><i>1962</i>&nbsp;                switch (c) {</b>
<i>1963</i>&nbsp;                    case &#39;*&#39; :
<i>1964</i>&nbsp;                    case &#39;?&#39; :
<i>1965</i>&nbsp;                    case &#39;\&quot;&#39;:
<b class="nc"><i>1966</i>&nbsp;                    case &#39;\n&#39;:</b>
<i>1967</i>&nbsp;                         throw new IllegalArgumentException(
<b class="nc"><i>1968</i>&nbsp;                                          &quot;Invalid unescaped character &#39;&quot; + c +</b>
<i>1969</i>&nbsp;                                          &quot;&#39; in the string to unquote&quot;);
<i>1970</i>&nbsp;                }
<i>1971</i>&nbsp;            }
<i>1972</i>&nbsp;            buf.append(c);
<i>1973</i>&nbsp;        }
<i>1974</i>&nbsp;        return buf.toString();
<b class="nc"><i>1975</i>&nbsp;    }</b>
<i>1976</i>&nbsp;
<i>1977</i>&nbsp;    /**
<b class="nc"><i>1978</i>&nbsp;     * Defines the wildcard &quot;*:*&quot; ObjectName.</b>
<i>1979</i>&nbsp;     *
<i>1980</i>&nbsp;     * @since 1.6
<i>1981</i>&nbsp;     */
<i>1982</i>&nbsp;    public static final ObjectName WILDCARD = Util.newObjectName(&quot;*:*&quot;);
<b class="nc"><i>1983</i>&nbsp;</b>
<b class="nc"><i>1984</i>&nbsp;    // Category : Utilities &lt;===================================</b>
<b class="nc"><i>1985</i>&nbsp;</b>
<b class="nc"><i>1986</i>&nbsp;    // Category : QueryExp Interface ----------------------------------------&gt;</b>
<b class="nc"><i>1987</i>&nbsp;</b>
<i>1988</i>&nbsp;    /**
<i>1989</i>&nbsp;     * &lt;p&gt;Test whether this ObjectName, which may be a pattern,
<i>1990</i>&nbsp;     * matches another ObjectName.  If &lt;code&gt;name&lt;/code&gt; is a pattern,
<b class="nc"><i>1991</i>&nbsp;     * the result is false.  If this ObjectName is a pattern, the</b>
<b class="nc"><i>1992</i>&nbsp;     * result is true if and only if &lt;code&gt;name&lt;/code&gt; matches the</b>
<b class="nc"><i>1993</i>&nbsp;     * pattern.  If neither this ObjectName nor &lt;code&gt;name&lt;/code&gt; is</b>
<i>1994</i>&nbsp;     * a pattern, the result is true if and only if the two
<i>1995</i>&nbsp;     * ObjectNames are equal as described for the {@link
<b class="nc"><i>1996</i>&nbsp;     * #equals(Object)} method.&lt;/p&gt;</b>
<i>1997</i>&nbsp;     *
<i>1998</i>&nbsp;     * @param name The name of the MBean to compare to.
<b class="nc"><i>1999</i>&nbsp;     *</b>
<i>2000</i>&nbsp;     * @return True if &lt;code&gt;name&lt;/code&gt; matches this ObjectName.
<i>2001</i>&nbsp;     *
<b class="nc"><i>2002</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;name&lt;/code&gt; is null.</b>
<b class="nc"><i>2003</i>&nbsp;     *</b>
<i>2004</i>&nbsp;     */
<b class="nc"><i>2005</i>&nbsp;    public boolean apply(ObjectName name) {</b>
<i>2006</i>&nbsp;
<b class="nc"><i>2007</i>&nbsp;        if (name == null) throw new NullPointerException();</b>
<b class="nc"><i>2008</i>&nbsp;</b>
<i>2009</i>&nbsp;        if (name.isPattern())
<b class="nc"><i>2010</i>&nbsp;            return false;</b>
<i>2011</i>&nbsp;
<i>2012</i>&nbsp;        // No pattern
<i>2013</i>&nbsp;        if (!isPattern())
<i>2014</i>&nbsp;            return _canonicalName.equals(name._canonicalName);
<b class="nc"><i>2015</i>&nbsp;</b>
<b class="nc"><i>2016</i>&nbsp;        return matchDomains(name) &amp;&amp; matchKeys(name);</b>
<b class="nc"><i>2017</i>&nbsp;    }</b>
<i>2018</i>&nbsp;
<i>2019</i>&nbsp;    private final boolean matchDomains(ObjectName name) {
<i>2020</i>&nbsp;        if (isDomainPattern()) {
<i>2021</i>&nbsp;            // wildmatch domains
<i>2022</i>&nbsp;            // This ObjectName is the pattern
<i>2023</i>&nbsp;            // The other ObjectName is the string.
<i>2024</i>&nbsp;            return Util.wildmatch(name.getDomain(),getDomain());
<i>2025</i>&nbsp;        }
<i>2026</i>&nbsp;        return getDomain().equals(name.getDomain());
<i>2027</i>&nbsp;    }
<i>2028</i>&nbsp;
<i>2029</i>&nbsp;    private final boolean matchKeys(ObjectName name) {
<i>2030</i>&nbsp;        // If key property value pattern but not key property list
<i>2031</i>&nbsp;        // pattern, then the number of key properties must be equal
<i>2032</i>&nbsp;        //
<i>2033</i>&nbsp;        if (isPropertyValuePattern() &amp;&amp;
<i>2034</i>&nbsp;            !isPropertyListPattern() &amp;&amp;
<i>2035</i>&nbsp;            (name._ca_array.length != _ca_array.length))
<i>2036</i>&nbsp;                return false;
<i>2037</i>&nbsp;
<i>2038</i>&nbsp;        // If key property value pattern or key property list pattern,
<i>2039</i>&nbsp;        // then every property inside pattern should exist in name
<i>2040</i>&nbsp;        //
<i>2041</i>&nbsp;        if (isPropertyPattern()) {
<i>2042</i>&nbsp;            final Map&lt;String,String&gt; nameProps = name._getKeyPropertyList();
<i>2043</i>&nbsp;            final Property[] props = _ca_array;
<i>2044</i>&nbsp;            final String cn = _canonicalName;
<i>2045</i>&nbsp;            for (int i = props.length - 1; i &gt;= 0 ; i--) {
<i>2046</i>&nbsp;                // Find value in given object name for key at current
<i>2047</i>&nbsp;                // index in receiver
<i>2048</i>&nbsp;                //
<i>2049</i>&nbsp;                final Property p = props[i];
<i>2050</i>&nbsp;                final String   k = p.getKeyString(cn);
<i>2051</i>&nbsp;                final String   v = nameProps.get(k);
<i>2052</i>&nbsp;                // Did we find a value for this key ?
<i>2053</i>&nbsp;                //
<i>2054</i>&nbsp;                if (v == null) return false;
<i>2055</i>&nbsp;                // If this property is ok (same key, same value), go to next
<i>2056</i>&nbsp;                //
<i>2057</i>&nbsp;                if (isPropertyValuePattern() &amp;&amp; (p instanceof PatternProperty)) {
<i>2058</i>&nbsp;                    // wildmatch key property values
<i>2059</i>&nbsp;                    // p is the property pattern, v is the string
<i>2060</i>&nbsp;                    if (Util.wildmatch(v,p.getValueString(cn)))
<i>2061</i>&nbsp;                        continue;
<i>2062</i>&nbsp;                    else
<i>2063</i>&nbsp;                        return false;
<i>2064</i>&nbsp;                }
<i>2065</i>&nbsp;                if (v.equals(p.getValueString(cn))) continue;
<i>2066</i>&nbsp;                return false;
<i>2067</i>&nbsp;            }
<i>2068</i>&nbsp;            return true;
<i>2069</i>&nbsp;        }
<i>2070</i>&nbsp;
<i>2071</i>&nbsp;        // If no pattern, then canonical names must be equal
<i>2072</i>&nbsp;        //
<i>2073</i>&nbsp;        final String p1 = name.getCanonicalKeyPropertyListString();
<i>2074</i>&nbsp;        final String p2 = getCanonicalKeyPropertyListString();
<i>2075</i>&nbsp;        return (p1.equals(p2));
<b class="nc"><i>2076</i>&nbsp;    }</b>
<i>2077</i>&nbsp;
<i>2078</i>&nbsp;    /* Method inherited from QueryExp, no implementation needed here
<i>2079</i>&nbsp;       because ObjectName is not relative to an MBeanServer and does
<b class="nc"><i>2080</i>&nbsp;       not contain a subquery.</b>
<b class="nc"><i>2081</i>&nbsp;    */</b>
<b class="nc"><i>2082</i>&nbsp;    public void setMBeanServer(MBeanServer mbs) { }</b>
<i>2083</i>&nbsp;
<i>2084</i>&nbsp;    // Category : QueryExp Interface &lt;=========================
<i>2085</i>&nbsp;
<i>2086</i>&nbsp;    // Category : Comparable Interface ----------------------------------------&gt;
<i>2087</i>&nbsp;
<i>2088</i>&nbsp;    /**
<i>2089</i>&nbsp;     * &lt;p&gt;Compares two ObjectName instances. The ordering relation between
<i>2090</i>&nbsp;     * ObjectNames is not completely specified but is intended to be such
<i>2091</i>&nbsp;     * that a sorted list of ObjectNames will appear in an order that is
<b class="nc"><i>2092</i>&nbsp;     * convenient for a person to read.&lt;/p&gt;</b>
<b class="nc"><i>2093</i>&nbsp;     *</b>
<b class="nc"><i>2094</i>&nbsp;     * &lt;p&gt;In particular, if the two ObjectName instances have different</b>
<b class="nc"><i>2095</i>&nbsp;     * domains then their order is the lexicographical order of the domains.</b>
<b class="nc"><i>2096</i>&nbsp;     * The ordering of the key property list remains unspecified.&lt;/p&gt;</b>
<b class="nc"><i>2097</i>&nbsp;     *</b>
<b class="nc"><i>2098</i>&nbsp;     * &lt;p&gt;For example, the ObjectName instances below:&lt;/p&gt;</b>
<b class="nc"><i>2099</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>2100</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;</b>
<i>2101</i>&nbsp;     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
<i>2102</i>&nbsp;     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
<i>2103</i>&nbsp;     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
<b class="nc"><i>2104</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;</b>
<i>2105</i>&nbsp;     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
<i>2106</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
<i>2107</i>&nbsp;     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
<i>2108</i>&nbsp;     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
<i>2109</i>&nbsp;     * &lt;/ul&gt;
<i>2110</i>&nbsp;     * &lt;p&gt;could be ordered as follows:&lt;/p&gt;
<i>2111</i>&nbsp;     * &lt;ul&gt;
<i>2112</i>&nbsp;     * &lt;li&gt;Colors:type=Blue,name=1&lt;/li&gt;
<i>2113</i>&nbsp;     * &lt;li&gt;Colors:type=Red,name=1&lt;/li&gt;
<i>2114</i>&nbsp;     * &lt;li&gt;Colors:type=Red,name=2&lt;/li&gt;
<i>2115</i>&nbsp;     * &lt;li&gt;JMImplementation:type=MBeanServerDelegate&lt;/li&gt;
<i>2116</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=1&lt;/li&gt;
<i>2117</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=2&lt;/li&gt;
<i>2118</i>&nbsp;     * &lt;li&gt;Shapes:type=Square,name=3&lt;/li&gt;
<i>2119</i>&nbsp;     * &lt;li&gt;Shapes:type=Triangle,side=scalene,name=1&lt;/li&gt;
<i>2120</i>&nbsp;     * &lt;li&gt;Shapes:type=Triangle,side=isosceles,name=2&lt;/li&gt;
<i>2121</i>&nbsp;     * &lt;/ul&gt;
<i>2122</i>&nbsp;     *
<i>2123</i>&nbsp;     * @param name the ObjectName to be compared.
<i>2124</i>&nbsp;     *
<i>2125</i>&nbsp;     * @return a negative integer, zero, or a positive integer as this
<i>2126</i>&nbsp;     *         ObjectName is less than, equal to, or greater than the
<i>2127</i>&nbsp;     *         specified ObjectName.
<i>2128</i>&nbsp;     *
<i>2129</i>&nbsp;     * @since 1.6
<i>2130</i>&nbsp;     */
<i>2131</i>&nbsp;    public int compareTo(ObjectName name) {
<i>2132</i>&nbsp;        // Quick optimization:
<i>2133</i>&nbsp;        //
<i>2134</i>&nbsp;        if (name == this) return 0;
<i>2135</i>&nbsp;
<i>2136</i>&nbsp;        // (1) Compare domains
<i>2137</i>&nbsp;        //
<i>2138</i>&nbsp;        int domainValue = this.getDomain().compareTo(name.getDomain());
<i>2139</i>&nbsp;        if (domainValue != 0)
<i>2140</i>&nbsp;            return domainValue;
<i>2141</i>&nbsp;
<i>2142</i>&nbsp;        // (2) Compare &quot;type=&quot; keys
<i>2143</i>&nbsp;        //
<i>2144</i>&nbsp;        // Within a given domain, all names with missing or empty &quot;type=&quot;
<i>2145</i>&nbsp;        // come before all names with non-empty type.
<i>2146</i>&nbsp;        //
<i>2147</i>&nbsp;        // When both types are missing or empty, canonical-name ordering
<i>2148</i>&nbsp;        // applies which is a total order.
<i>2149</i>&nbsp;        //
<i>2150</i>&nbsp;        String thisTypeKey = this.getKeyProperty(&quot;type&quot;);
<i>2151</i>&nbsp;        String anotherTypeKey = name.getKeyProperty(&quot;type&quot;);
<i>2152</i>&nbsp;        if (thisTypeKey == null)
<i>2153</i>&nbsp;            thisTypeKey = &quot;&quot;;
<i>2154</i>&nbsp;        if (anotherTypeKey == null)
<i>2155</i>&nbsp;            anotherTypeKey = &quot;&quot;;
<i>2156</i>&nbsp;        int typeKeyValue = thisTypeKey.compareTo(anotherTypeKey);
<i>2157</i>&nbsp;        if (typeKeyValue != 0)
<i>2158</i>&nbsp;            return typeKeyValue;
<i>2159</i>&nbsp;
<i>2160</i>&nbsp;        // (3) Compare canonical names
<i>2161</i>&nbsp;        //
<i>2162</i>&nbsp;        return this.getCanonicalName().compareTo(name.getCanonicalName());
<i>2163</i>&nbsp;    }
<i>2164</i>&nbsp;
<i>2165</i>&nbsp;    // Category : Comparable Interface &lt;=========================
<i>2166</i>&nbsp;
<i>2167</i>&nbsp;    // Public methods &lt;========================================
<i>2168</i>&nbsp;
<i>2169</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
