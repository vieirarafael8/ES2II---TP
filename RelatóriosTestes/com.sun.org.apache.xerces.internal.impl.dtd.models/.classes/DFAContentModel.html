


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DFAContentModel</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.org.apache.xerces.internal.impl.dtd.models</a> ]
</div>

<h1>Coverage Summary for Class: DFAContentModel (com.sun.org.apache.xerces.internal.impl.dtd.models)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DFAContentModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 233)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; */
<i>4</i>&nbsp;/*
<i>5</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>6</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>7</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>8</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>9</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>10</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>13</i>&nbsp; *
<i>14</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>15</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>16</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>17</i>&nbsp; * See the License for the specific language governing permissions and
<i>18</i>&nbsp; * limitations under the License.
<i>19</i>&nbsp; */
<i>20</i>&nbsp;
<i>21</i>&nbsp;package com.sun.org.apache.xerces.internal.impl.dtd.models;
<i>22</i>&nbsp;
<i>23</i>&nbsp;import com.sun.org.apache.xerces.internal.impl.dtd.XMLContentSpec;
<i>24</i>&nbsp;import com.sun.org.apache.xerces.internal.xni.QName;
<i>25</i>&nbsp;import java.util.HashMap;
<i>26</i>&nbsp;import java.util.Map;
<i>27</i>&nbsp;
<i>28</i>&nbsp;/**
<i>29</i>&nbsp;
<i>30</i>&nbsp; * DFAContentModel is the derivative of ContentModel that does
<i>31</i>&nbsp; * all of the non-trivial element content validation. This class does
<i>32</i>&nbsp; * the conversion from the regular expression to the DFA that
<i>33</i>&nbsp; * it then uses in its validation algorithm.
<i>34</i>&nbsp; * &lt;p&gt;
<i>35</i>&nbsp; * &lt;b&gt;Note:&lt;/b&gt; Upstream work insures that this class will never see
<i>36</i>&nbsp; * a content model with PCDATA in it. Any model with PCDATA is &#39;mixed&#39;
<i>37</i>&nbsp; * and is handled via the MixedContentModel class since mixed models
<i>38</i>&nbsp; * are very constrained in form and easily handled via a special case.
<i>39</i>&nbsp; * This also makes implementation of this class much easier.
<i>40</i>&nbsp; *
<i>41</i>&nbsp; * @xerces.internal
<i>42</i>&nbsp; *
<i>43</i>&nbsp; * @LastModified: Oct 2017
<i>44</i>&nbsp; */
<i>45</i>&nbsp;public class DFAContentModel
<i>46</i>&nbsp;    implements ContentModelValidator {
<i>47</i>&nbsp;
<i>48</i>&nbsp;    //
<i>49</i>&nbsp;    // Constants
<i>50</i>&nbsp;    //
<i>51</i>&nbsp;    // special strings
<i>52</i>&nbsp;
<i>53</i>&nbsp;    /** Epsilon string. */
<i>54</i>&nbsp;    private static String fEpsilonString = &quot;&lt;&lt;CMNODE_EPSILON&gt;&gt;&quot;;
<i>55</i>&nbsp;
<i>56</i>&nbsp;    /** End-of-content string. */
<i>57</i>&nbsp;    private static String fEOCString = &quot;&lt;&lt;CMNODE_EOC&gt;&gt;&quot;;
<i>58</i>&nbsp;
<i>59</i>&nbsp;    /** initializing static members **/
<i>60</i>&nbsp;    static {
<i>61</i>&nbsp;        fEpsilonString = fEpsilonString.intern();
<i>62</i>&nbsp;        fEOCString = fEOCString.intern();
<i>63</i>&nbsp;    }
<i>64</i>&nbsp;
<i>65</i>&nbsp;    // debugging
<i>66</i>&nbsp;
<i>67</i>&nbsp;    /** Set to true to debug content model validation. */
<i>68</i>&nbsp;    private static final boolean DEBUG_VALIDATE_CONTENT = false;
<i>69</i>&nbsp;
<i>70</i>&nbsp;    //
<i>71</i>&nbsp;    // Data
<i>72</i>&nbsp;    //
<i>73</i>&nbsp;
<i>74</i>&nbsp;    /* this is the EquivClassComparator object */
<i>75</i>&nbsp;    //private EquivClassComparator comparator = null;
<i>76</i>&nbsp;
<i>77</i>&nbsp;    /**
<i>78</i>&nbsp;     * This is the map of unique input symbol elements to indices into
<i>79</i>&nbsp;     * each state&#39;s per-input symbol transition table entry. This is part
<i>80</i>&nbsp;     * of the built DFA information that must be kept around to do the
<i>81</i>&nbsp;     * actual validation.
<i>82</i>&nbsp;     */
<i>83</i>&nbsp;    private QName fElemMap[] = null;
<i>84</i>&nbsp;
<i>85</i>&nbsp;    /**
<i>86</i>&nbsp;     * This is a map of whether the element map contains information
<i>87</i>&nbsp;     * related to ANY models.
<i>88</i>&nbsp;     */
<i>89</i>&nbsp;    private int fElemMapType[] = null;
<i>90</i>&nbsp;
<i>91</i>&nbsp;    /** The element map size. */
<i>92</i>&nbsp;    private int fElemMapSize = 0;
<i>93</i>&nbsp;
<i>94</i>&nbsp;    /** Boolean to distinguish Schema Mixed Content */
<i>95</i>&nbsp;    private boolean fMixed;
<b class="nc"><i>96</i>&nbsp;</b>
<i>97</i>&nbsp;    /**
<i>98</i>&nbsp;     * The NFA position of the special EOC (end of content) node. This
<b class="nc"><i>99</i>&nbsp;     * is saved away since it&#39;s used during the DFA build.</b>
<i>100</i>&nbsp;     */
<i>101</i>&nbsp;    private int fEOCPos = 0;
<i>102</i>&nbsp;
<b class="nc"><i>103</i>&nbsp;</b>
<b class="nc"><i>104</i>&nbsp;    /**</b>
<i>105</i>&nbsp;     * This is an array of booleans, one per state (there are
<i>106</i>&nbsp;     * fTransTableSize states in the DFA) that indicates whether that
<i>107</i>&nbsp;     * state is a final state.
<i>108</i>&nbsp;     */
<i>109</i>&nbsp;    private boolean fFinalStateFlags[] = null;
<i>110</i>&nbsp;
<i>111</i>&nbsp;    /**
<i>112</i>&nbsp;     * The list of follow positions for each NFA position (i.e. for each
<i>113</i>&nbsp;     * non-epsilon leaf node.) This is only used during the building of
<i>114</i>&nbsp;     * the DFA, and is let go afterwards.
<i>115</i>&nbsp;     */
<i>116</i>&nbsp;    private CMStateSet fFollowList[] = null;
<i>117</i>&nbsp;
<i>118</i>&nbsp;    /**
<i>119</i>&nbsp;     * This is the head node of our intermediate representation. It is
<i>120</i>&nbsp;     * only non-null during the building of the DFA (just so that it
<i>121</i>&nbsp;     * does not have to be passed all around.) Once the DFA is built,
<i>122</i>&nbsp;     * this is no longer required so its nulled out.
<i>123</i>&nbsp;     */
<i>124</i>&nbsp;    private CMNode fHeadNode = null;
<b class="nc"><i>125</i>&nbsp;</b>
<i>126</i>&nbsp;    /**
<i>127</i>&nbsp;     * The count of leaf nodes. This is an important number that set some
<i>128</i>&nbsp;     * limits on the sizes of data structures in the DFA process.
<i>129</i>&nbsp;     */
<i>130</i>&nbsp;    private int fLeafCount = 0;
<b class="nc"><i>131</i>&nbsp;</b>
<i>132</i>&nbsp;    /**
<i>133</i>&nbsp;     * An array of non-epsilon leaf nodes, which is used during the DFA
<b class="nc"><i>134</i>&nbsp;     * build operation, then dropped.</b>
<i>135</i>&nbsp;     */
<i>136</i>&nbsp;    private CMLeaf fLeafList[] = null;
<i>137</i>&nbsp;
<i>138</i>&nbsp;    /** Array mapping ANY types to the leaf list. */
<i>139</i>&nbsp;    private int fLeafListType[] = null;
<i>140</i>&nbsp;
<i>141</i>&nbsp;    //private ContentLeafNameTypeVector fLeafNameTypeVector = null;
<i>142</i>&nbsp;
<b class="nc"><i>143</i>&nbsp;    /**</b>
<i>144</i>&nbsp;     * The string pool of our parser session. This is set during construction
<i>145</i>&nbsp;     * and kept around.
<i>146</i>&nbsp;     */
<i>147</i>&nbsp;    //private StringPool fStringPool = null;
<i>148</i>&nbsp;
<i>149</i>&nbsp;    /**
<i>150</i>&nbsp;     * This is the transition table that is the main by product of all
<b class="nc"><i>151</i>&nbsp;     * of the effort here. It is an array of arrays of ints. The first</b>
<i>152</i>&nbsp;     * dimension is the number of states we end up with in the DFA. The
<i>153</i>&nbsp;     * second dimensions is the number of unique elements in the content
<i>154</i>&nbsp;     * model (fElemMapSize). Each entry in the second dimension indicates
<i>155</i>&nbsp;     * the new state given that input for the first dimension&#39;s start
<i>156</i>&nbsp;     * state.
<i>157</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>158</i>&nbsp;     * The fElemMap array handles mapping from element indexes to</b>
<i>159</i>&nbsp;     * positions in the second dimension of the transition table.
<i>160</i>&nbsp;     */
<i>161</i>&nbsp;    private int fTransTable[][] = null;
<i>162</i>&nbsp;
<i>163</i>&nbsp;    /**
<i>164</i>&nbsp;     * The number of valid entries in the transition table, and in the other
<i>165</i>&nbsp;     * related tables such as fFinalStateFlags.
<b class="nc"><i>166</i>&nbsp;     */</b>
<i>167</i>&nbsp;    private int fTransTableSize = 0;
<i>168</i>&nbsp;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * Flag that indicates that even though we have a &quot;complicated&quot;
<i>171</i>&nbsp;     * content model, it is valid to have no content. In other words,
<b class="nc"><i>172</i>&nbsp;     * all parts of the content model are optional. For example:</b>
<i>173</i>&nbsp;     * &lt;pre&gt;
<i>174</i>&nbsp;     *      &amp;lt;!ELEMENT AllOptional (Optional*,NotRequired?)&amp;gt;
<i>175</i>&nbsp;     * &lt;/pre&gt;
<i>176</i>&nbsp;     */
<i>177</i>&nbsp;    private boolean fEmptyContentIsValid = false;
<b class="nc"><i>178</i>&nbsp;</b>
<i>179</i>&nbsp;    // temp variables
<i>180</i>&nbsp;
<b class="nc"><i>181</i>&nbsp;    /** Temporary qualified name. */</b>
<i>182</i>&nbsp;    private final QName fQName = new QName();
<i>183</i>&nbsp;
<i>184</i>&nbsp;    //
<i>185</i>&nbsp;    // Constructors
<i>186</i>&nbsp;    //
<i>187</i>&nbsp;
<i>188</i>&nbsp;
<i>189</i>&nbsp;    //
<i>190</i>&nbsp;    // Constructors
<i>191</i>&nbsp;    //
<i>192</i>&nbsp;
<i>193</i>&nbsp;    /**
<i>194</i>&nbsp;     * Constructs a DFA content model.
<i>195</i>&nbsp;     *
<i>196</i>&nbsp;     * @param syntaxTree    The syntax tree of the content model.
<i>197</i>&nbsp;     * @param leafCount     The number of leaves.
<i>198</i>&nbsp;     * @param mixed
<i>199</i>&nbsp;     *
<i>200</i>&nbsp;     */
<i>201</i>&nbsp;    public DFAContentModel(CMNode syntaxTree, int leafCount, boolean mixed) {
<i>202</i>&nbsp;        // Store away our index and pools in members
<b class="nc"><i>203</i>&nbsp;        //fStringPool = stringPool;</b>
<i>204</i>&nbsp;        fLeafCount = leafCount;
<i>205</i>&nbsp;
<i>206</i>&nbsp;
<i>207</i>&nbsp;        // this is for Schema Mixed Content
<i>208</i>&nbsp;        fMixed = mixed;
<b class="nc"><i>209</i>&nbsp;</b>
<i>210</i>&nbsp;        //
<i>211</i>&nbsp;        //  Ok, so lets grind through the building of the DFA. This method
<i>212</i>&nbsp;        //  handles the high level logic of the algorithm, but it uses a
<i>213</i>&nbsp;        //  number of helper classes to do its thing.
<i>214</i>&nbsp;        //
<i>215</i>&nbsp;        //  In order to avoid having hundreds of references to the error and
<i>216</i>&nbsp;        //  string handlers around, this guy and all of his helper classes
<i>217</i>&nbsp;        //  just throw a simple exception and we then pass it along.
<i>218</i>&nbsp;        //
<b class="nc"><i>219</i>&nbsp;        buildDFA(syntaxTree);</b>
<i>220</i>&nbsp;    }
<i>221</i>&nbsp;
<i>222</i>&nbsp;    //
<i>223</i>&nbsp;    // ContentModelValidator methods
<b class="nc"><i>224</i>&nbsp;    //</b>
<i>225</i>&nbsp;
<i>226</i>&nbsp;    /**
<i>227</i>&nbsp;     * Check that the specified content is valid according to this
<i>228</i>&nbsp;     * content model. This method can also be called to do &#39;what if&#39;
<i>229</i>&nbsp;     * testing of content models just to see if they would be valid.
<i>230</i>&nbsp;     * &lt;p&gt;
<i>231</i>&nbsp;     * A value of -1 in the children array indicates a PCDATA node. All other
<i>232</i>&nbsp;     * indexes will be positive and represent child elements. The count can be
<i>233</i>&nbsp;     * zero, since some elements have the EMPTY content model and that must be
<i>234</i>&nbsp;     * confirmed.
<i>235</i>&nbsp;     *
<i>236</i>&nbsp;     * @param children The children of this element.  Each integer is an index within
<i>237</i>&nbsp;     *                 the &lt;code&gt;StringPool&lt;/code&gt; of the child element name.  An index
<i>238</i>&nbsp;     *                 of -1 is used to indicate an occurrence of non-whitespace character
<i>239</i>&nbsp;     *                 data.
<i>240</i>&nbsp;     * @param offset Offset into the array where the children starts.
<i>241</i>&nbsp;     * @param length The number of entries in the &lt;code&gt;children&lt;/code&gt; array.
<i>242</i>&nbsp;     *
<b class="nc"><i>243</i>&nbsp;     * @return The value -1 if fully valid, else the 0 based index of the child</b>
<i>244</i>&nbsp;     *         that first failed. If the value returned is equal to the number
<i>245</i>&nbsp;     *         of children, then the specified children are valid but additional
<b class="nc"><i>246</i>&nbsp;     *         content is required to reach a valid ending state.</b>
<i>247</i>&nbsp;     *
<i>248</i>&nbsp;     */
<i>249</i>&nbsp;    public int validate(QName[] children, int offset, int length) {
<b class="nc"><i>250</i>&nbsp;</b>
<i>251</i>&nbsp;        if (DEBUG_VALIDATE_CONTENT)
<i>252</i>&nbsp;            System.out.println(&quot;DFAContentModel#validateContent&quot;);
<i>253</i>&nbsp;
<i>254</i>&nbsp;        //
<i>255</i>&nbsp;        // A DFA content model must *always* have at least 1 child
<i>256</i>&nbsp;        // so a failure is given if no children present.
<i>257</i>&nbsp;        //
<i>258</i>&nbsp;        // Defect 782: This is an incorrect statement because a DFA
<i>259</i>&nbsp;        // content model is also used for constructions such as:
<i>260</i>&nbsp;        //
<b class="nc"><i>261</i>&nbsp;        //     (Optional*,NotRequired?)</b>
<i>262</i>&nbsp;        //
<i>263</i>&nbsp;        // where a perfectly valid content would be NO CHILDREN.
<i>264</i>&nbsp;        // Therefore, if there are no children, we must check to
<i>265</i>&nbsp;        // see if the CMNODE_EOC marker is a valid start state! -Ac
<i>266</i>&nbsp;        //
<i>267</i>&nbsp;        if (length == 0) {
<i>268</i>&nbsp;            if (DEBUG_VALIDATE_CONTENT) {
<i>269</i>&nbsp;                System.out.println(&quot;!!! no children&quot;);
<i>270</i>&nbsp;                System.out.println(&quot;elemMap=&quot;+fElemMap);
<i>271</i>&nbsp;                for (int i = 0; i &lt; fElemMap.length; i++) {
<i>272</i>&nbsp;                    String uri = fElemMap[i].uri;
<i>273</i>&nbsp;                    String localpart = fElemMap[i].localpart;
<i>274</i>&nbsp;
<i>275</i>&nbsp;                    System.out.println(&quot;fElemMap[&quot;+i+&quot;]=&quot;+uri+&quot;,&quot;+
<i>276</i>&nbsp;                                       localpart+&quot; (&quot;+
<i>277</i>&nbsp;                                       uri+&quot;, &quot;+
<i>278</i>&nbsp;                                       localpart+
<i>279</i>&nbsp;                                       &#39;)&#39;);
<i>280</i>&nbsp;
<i>281</i>&nbsp;                }
<i>282</i>&nbsp;                System.out.println(&quot;EOCIndex=&quot;+fEOCString);
<i>283</i>&nbsp;            }
<i>284</i>&nbsp;
<i>285</i>&nbsp;            return fEmptyContentIsValid ? -1 : 0;
<i>286</i>&nbsp;
<i>287</i>&nbsp;        } // if child count == 0
<i>288</i>&nbsp;
<i>289</i>&nbsp;        //
<i>290</i>&nbsp;        //  Lets loop through the children in the array and move our way
<i>291</i>&nbsp;        //  through the states. Note that we use the fElemMap array to map
<i>292</i>&nbsp;        //  an element index to a state index.
<i>293</i>&nbsp;        //
<i>294</i>&nbsp;        int curState = 0;
<i>295</i>&nbsp;        for (int childIndex = 0; childIndex &lt; length; childIndex++)
<i>296</i>&nbsp;        {
<i>297</i>&nbsp;            // Get the current element index out
<i>298</i>&nbsp;            final QName curElem = children[offset + childIndex];
<i>299</i>&nbsp;            // ignore mixed text
<i>300</i>&nbsp;            if (fMixed &amp;&amp; curElem.localpart == null) {
<i>301</i>&nbsp;                continue;
<i>302</i>&nbsp;            }
<i>303</i>&nbsp;
<i>304</i>&nbsp;            // Look up this child in our element map
<i>305</i>&nbsp;            int elemIndex = 0;
<i>306</i>&nbsp;            for (; elemIndex &lt; fElemMapSize; elemIndex++)
<i>307</i>&nbsp;            {
<i>308</i>&nbsp;                int type = fElemMapType[elemIndex] &amp; 0x0f ;
<b class="nc"><i>309</i>&nbsp;                if (type == XMLContentSpec.CONTENTSPECNODE_LEAF) {</b>
<i>310</i>&nbsp;                    //System.out.println(&quot;fElemMap[&quot;+elemIndex+&quot;]: &quot;+fElemMap[elemIndex]);
<i>311</i>&nbsp;                    if (fElemMap[elemIndex].rawname == curElem.rawname) {
<i>312</i>&nbsp;                        break;
<i>313</i>&nbsp;                    }
<i>314</i>&nbsp;                }
<i>315</i>&nbsp;                else if (type == XMLContentSpec.CONTENTSPECNODE_ANY) {
<i>316</i>&nbsp;                    String uri = fElemMap[elemIndex].uri;
<i>317</i>&nbsp;                    if (uri == null || uri == curElem.uri) {
<i>318</i>&nbsp;                        break;
<i>319</i>&nbsp;                    }
<i>320</i>&nbsp;                }
<i>321</i>&nbsp;                else if (type == XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL) {
<i>322</i>&nbsp;                    if (curElem.uri == null) {
<i>323</i>&nbsp;                        break;
<i>324</i>&nbsp;                    }
<i>325</i>&nbsp;                }
<i>326</i>&nbsp;                else if (type == XMLContentSpec.CONTENTSPECNODE_ANY_OTHER) {
<b class="nc"><i>327</i>&nbsp;                    if (fElemMap[elemIndex].uri != curElem.uri) {</b>
<i>328</i>&nbsp;                        break;
<i>329</i>&nbsp;                    }
<i>330</i>&nbsp;                }
<i>331</i>&nbsp;            }
<i>332</i>&nbsp;
<i>333</i>&nbsp;            // If we didn&#39;t find it, then obviously not valid
<i>334</i>&nbsp;            if (elemIndex == fElemMapSize) {
<i>335</i>&nbsp;                if (DEBUG_VALIDATE_CONTENT) {
<b class="nc"><i>336</i>&nbsp;                    System.out.println(&quot;!!! didn&#39;t find it&quot;);</b>
<b class="nc"><i>337</i>&nbsp;</b>
<i>338</i>&nbsp;                    System.out.println(&quot;curElem : &quot; +curElem );
<i>339</i>&nbsp;                    for (int i=0; i&lt;fElemMapSize; i++) {
<b class="nc"><i>340</i>&nbsp;                        System.out.println(&quot;fElemMap[&quot;+i+&quot;] = &quot; +fElemMap[i] );</b>
<i>341</i>&nbsp;                        System.out.println(&quot;fElemMapType[&quot;+i+&quot;] = &quot; +fElemMapType[i] );
<b class="nc"><i>342</i>&nbsp;                    }</b>
<b class="nc"><i>343</i>&nbsp;                }</b>
<i>344</i>&nbsp;
<i>345</i>&nbsp;                return childIndex;
<i>346</i>&nbsp;            }
<b class="nc"><i>347</i>&nbsp;</b>
<b class="nc"><i>348</i>&nbsp;            //</b>
<i>349</i>&nbsp;            //  Look up the next state for this input symbol when in the
<b class="nc"><i>350</i>&nbsp;            //  current state.</b>
<b class="nc"><i>351</i>&nbsp;            //</b>
<i>352</i>&nbsp;            curState = fTransTable[curState][elemIndex];
<b class="nc"><i>353</i>&nbsp;</b>
<b class="nc"><i>354</i>&nbsp;            // If its not a legal transition, then invalid</b>
<i>355</i>&nbsp;            if (curState == -1) {
<i>356</i>&nbsp;                if (DEBUG_VALIDATE_CONTENT)
<b class="nc"><i>357</i>&nbsp;                    System.out.println(&quot;!!! not a legal transition&quot;);</b>
<b class="nc"><i>358</i>&nbsp;                return childIndex;</b>
<b class="nc"><i>359</i>&nbsp;            }</b>
<b class="nc"><i>360</i>&nbsp;        }</b>
<i>361</i>&nbsp;
<b class="nc"><i>362</i>&nbsp;        //</b>
<b class="nc"><i>363</i>&nbsp;        //  We transitioned all the way through the input list. However, that</b>
<b class="nc"><i>364</i>&nbsp;        //  does not mean that we ended in a final state. So check whether</b>
<b class="nc"><i>365</i>&nbsp;        //  our ending state is a final state.</b>
<i>366</i>&nbsp;        //
<i>367</i>&nbsp;        if (DEBUG_VALIDATE_CONTENT)
<b class="nc"><i>368</i>&nbsp;            System.out.println(&quot;curState=&quot;+curState+&quot;, childCount=&quot;+length);</b>
<b class="nc"><i>369</i>&nbsp;        if (!fFinalStateFlags[curState])</b>
<b class="nc"><i>370</i>&nbsp;            return length;</b>
<i>371</i>&nbsp;
<i>372</i>&nbsp;        // success!
<i>373</i>&nbsp;        return -1;
<i>374</i>&nbsp;    } // validate
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;</b>
<i>377</i>&nbsp;    //
<i>378</i>&nbsp;    // Private methods
<i>379</i>&nbsp;    //
<i>380</i>&nbsp;
<i>381</i>&nbsp;    /**
<i>382</i>&nbsp;     * Builds the internal DFA transition table from the given syntax tree.
<i>383</i>&nbsp;     *
<i>384</i>&nbsp;     * @param syntaxTree The syntax tree.
<i>385</i>&nbsp;     *
<i>386</i>&nbsp;     * @exception CMException Thrown if DFA cannot be built.
<b class="nc"><i>387</i>&nbsp;     */</b>
<i>388</i>&nbsp;    private void buildDFA(CMNode syntaxTree)
<i>389</i>&nbsp;    {
<i>390</i>&nbsp;        //
<i>391</i>&nbsp;        //  The first step we need to take is to rewrite the content model
<i>392</i>&nbsp;        //  using our CMNode objects, and in the process get rid of any
<i>393</i>&nbsp;        //  repetition short cuts, converting them into &#39;*&#39; style repetitions
<b class="nc"><i>394</i>&nbsp;        //  or getting rid of repetitions altogether.</b>
<i>395</i>&nbsp;        //
<i>396</i>&nbsp;        //  The conversions done are:
<b class="nc"><i>397</i>&nbsp;        //</b>
<i>398</i>&nbsp;        //  x+ -&gt; (x|x*)
<i>399</i>&nbsp;        //  x? -&gt; (x|epsilon)
<b class="nc"><i>400</i>&nbsp;        //</b>
<i>401</i>&nbsp;        //  This is a relatively complex scenario. What is happening is that
<i>402</i>&nbsp;        //  we create a top level binary node of which the special EOC value
<i>403</i>&nbsp;        //  is set as the right side node. The the left side is set to the
<i>404</i>&nbsp;        //  rewritten syntax tree. The source is the original content model
<i>405</i>&nbsp;        //  info from the decl pool. The rewrite is done by buildSyntaxTree()
<i>406</i>&nbsp;        //  which recurses the decl pool&#39;s content of the element and builds
<i>407</i>&nbsp;        //  a new tree in the process.
<i>408</i>&nbsp;        //
<i>409</i>&nbsp;        //  Note that, during this operation, we set each non-epsilon leaf
<i>410</i>&nbsp;        //  node&#39;s DFA state position and count the number of such leafs, which
<b class="nc"><i>411</i>&nbsp;        //  is left in the fLeafCount member.</b>
<b class="nc"><i>412</i>&nbsp;        //</b>
<i>413</i>&nbsp;        //  The nodeTmp object is passed in just as a temp node to use during
<i>414</i>&nbsp;        //  the recursion. Otherwise, we&#39;d have to create a new node on every
<b class="nc"><i>415</i>&nbsp;        //  level of recursion, which would be piggy in Java (as is everything</b>
<i>416</i>&nbsp;        //  for that matter.)
<i>417</i>&nbsp;        //
<i>418</i>&nbsp;
<i>419</i>&nbsp;        /* MODIFIED (Jan, 2001)
<i>420</i>&nbsp;         *
<i>421</i>&nbsp;         * Use following rules.
<i>422</i>&nbsp;         *   nullable(x+) := nullable(x), first(x+) := first(x),  last(x+) := last(x)
<i>423</i>&nbsp;         *   nullable(x?) := true, first(x?) := first(x),  last(x?) := last(x)
<i>424</i>&nbsp;         *
<i>425</i>&nbsp;         * The same computation of follow as x* is applied to x+
<i>426</i>&nbsp;         *
<i>427</i>&nbsp;         * The modification drastically reduces computation time of
<i>428</i>&nbsp;         * &quot;(a, (b, a+, (c, (b, a+)+, a+, (d,  (c, (b, a+)+, a+)+, (b, a+)+, a+)+)+)+)+&quot;
<i>429</i>&nbsp;         */
<i>430</i>&nbsp;
<i>431</i>&nbsp;        fQName.setValues(null, fEOCString, fEOCString, null);
<i>432</i>&nbsp;        CMLeaf nodeEOC = new CMLeaf(fQName);
<i>433</i>&nbsp;        fHeadNode = new CMBinOp
<i>434</i>&nbsp;        (
<i>435</i>&nbsp;            XMLContentSpec.CONTENTSPECNODE_SEQ
<i>436</i>&nbsp;            , syntaxTree
<i>437</i>&nbsp;            , nodeEOC
<i>438</i>&nbsp;        );
<i>439</i>&nbsp;
<i>440</i>&nbsp;        //
<i>441</i>&nbsp;        //  And handle specially the EOC node, which also must be numbered
<i>442</i>&nbsp;        //  and counted as a non-epsilon leaf node. It could not be handled
<i>443</i>&nbsp;        //  in the above tree build because it was created before all that
<i>444</i>&nbsp;        //  started. We save the EOC position since its used during the DFA
<i>445</i>&nbsp;        //  building loop.
<i>446</i>&nbsp;        //
<i>447</i>&nbsp;        fEOCPos = fLeafCount;
<i>448</i>&nbsp;        nodeEOC.setPosition(fLeafCount++);
<i>449</i>&nbsp;
<i>450</i>&nbsp;        //
<i>451</i>&nbsp;        //  Ok, so now we have to iterate the new tree and do a little more
<i>452</i>&nbsp;        //  work now that we know the leaf count. One thing we need to do is
<i>453</i>&nbsp;        //  to calculate the first and last position sets of each node. This
<i>454</i>&nbsp;        //  is cached away in each of the nodes.
<i>455</i>&nbsp;        //
<i>456</i>&nbsp;        //  Along the way we also set the leaf count in each node as the
<i>457</i>&nbsp;        //  maximum state count. They must know this in order to create their
<i>458</i>&nbsp;        //  first/last pos sets.
<i>459</i>&nbsp;        //
<i>460</i>&nbsp;        //  We also need to build an array of references to the non-epsilon
<i>461</i>&nbsp;        //  leaf nodes. Since we iterate it in the same way as before, this
<i>462</i>&nbsp;        //  will put them in the array according to their position values.
<i>463</i>&nbsp;        //
<i>464</i>&nbsp;        fLeafList = new CMLeaf[fLeafCount];
<i>465</i>&nbsp;        fLeafListType = new int[fLeafCount];
<i>466</i>&nbsp;        postTreeBuildInit(fHeadNode, 0);
<i>467</i>&nbsp;
<i>468</i>&nbsp;        //
<i>469</i>&nbsp;        //  And, moving onward... We now need to build the follow position
<i>470</i>&nbsp;        //  sets for all the nodes. So we allocate an array of state sets,
<i>471</i>&nbsp;        //  one for each leaf node (i.e. each DFA position.)
<i>472</i>&nbsp;        //
<b class="nc"><i>473</i>&nbsp;        fFollowList = new CMStateSet[fLeafCount];</b>
<b class="nc"><i>474</i>&nbsp;        for (int index = 0; index &lt; fLeafCount; index++)</b>
<b class="nc"><i>475</i>&nbsp;            fFollowList[index] = new CMStateSet(fLeafCount);</b>
<i>476</i>&nbsp;        calcFollowList(fHeadNode);
<i>477</i>&nbsp;        //
<i>478</i>&nbsp;        //  And finally the big push... Now we build the DFA using all the
<i>479</i>&nbsp;        //  states and the tree we&#39;ve built up. First we set up the various
<i>480</i>&nbsp;        //  data structures we are going to use while we do this.
<i>481</i>&nbsp;        //
<i>482</i>&nbsp;        //  First of all we need an array of unique element names in our
<i>483</i>&nbsp;        //  content model. For each transition table entry, we need a set of
<i>484</i>&nbsp;        //  contiguous indices to represent the transitions for a particular
<i>485</i>&nbsp;        //  input element. So we need to a zero based range of indexes that
<i>486</i>&nbsp;        //  map to element types. This element map provides that mapping.
<i>487</i>&nbsp;        //
<i>488</i>&nbsp;        fElemMap = new QName[fLeafCount];
<b class="nc"><i>489</i>&nbsp;        fElemMapType = new int[fLeafCount];</b>
<b class="nc"><i>490</i>&nbsp;        fElemMapSize = 0;</b>
<i>491</i>&nbsp;        for (int outIndex = 0; outIndex &lt; fLeafCount; outIndex++)
<i>492</i>&nbsp;        {
<i>493</i>&nbsp;            fElemMap[outIndex] = new QName();
<i>494</i>&nbsp;
<i>495</i>&nbsp;            /****
<i>496</i>&nbsp;            if ( (fLeafListType[outIndex] &amp; 0x0f) != 0 ) {
<i>497</i>&nbsp;                if (fLeafNameTypeVector == null) {
<i>498</i>&nbsp;                    fLeafNameTypeVector = new ContentLeafNameTypeVector();
<i>499</i>&nbsp;                }
<i>500</i>&nbsp;            }
<i>501</i>&nbsp;            /****/
<i>502</i>&nbsp;
<i>503</i>&nbsp;            // Get the current leaf&#39;s element index
<i>504</i>&nbsp;            final QName element = fLeafList[outIndex].getElement();
<i>505</i>&nbsp;
<b class="nc"><i>506</i>&nbsp;            // See if the current leaf node&#39;s element index is in the list</b>
<b class="nc"><i>507</i>&nbsp;            int inIndex = 0;</b>
<b class="nc"><i>508</i>&nbsp;            for (; inIndex &lt; fElemMapSize; inIndex++)</b>
<i>509</i>&nbsp;            {
<i>510</i>&nbsp;                if (fElemMap[inIndex].rawname == element.rawname) {
<i>511</i>&nbsp;                    break;
<i>512</i>&nbsp;                }
<i>513</i>&nbsp;            }
<i>514</i>&nbsp;
<b class="nc"><i>515</i>&nbsp;            // If it was not in the list, then add it, if not the EOC node</b>
<b class="nc"><i>516</i>&nbsp;            if (inIndex == fElemMapSize) {</b>
<b class="nc"><i>517</i>&nbsp;                fElemMap[fElemMapSize].setValues(element);</b>
<b class="nc"><i>518</i>&nbsp;                fElemMapType[fElemMapSize] = fLeafListType[outIndex];</b>
<i>519</i>&nbsp;                fElemMapSize++;
<i>520</i>&nbsp;            }
<i>521</i>&nbsp;        }
<i>522</i>&nbsp;        // set up the fLeafNameTypeVector object if there is one.
<i>523</i>&nbsp;        /*****
<i>524</i>&nbsp;        if (fLeafNameTypeVector != null) {
<i>525</i>&nbsp;            fLeafNameTypeVector.setValues(fElemMap, fElemMapType, fElemMapSize);
<i>526</i>&nbsp;        }
<i>527</i>&nbsp;
<i>528</i>&nbsp;        /***
<i>529</i>&nbsp;        * Optimization(Jan, 2001); We sort fLeafList according to
<b class="nc"><i>530</i>&nbsp;        * elemIndex which is *uniquely* associated to each leaf.</b>
<b class="nc"><i>531</i>&nbsp;        * We are *assuming* that each element appears in at least one leaf.</b>
<b class="nc"><i>532</i>&nbsp;        **/</b>
<b class="nc"><i>533</i>&nbsp;</b>
<i>534</i>&nbsp;        int[] fLeafSorter = new int[fLeafCount + fElemMapSize];
<b class="nc"><i>535</i>&nbsp;        int fSortCount = 0;</b>
<i>536</i>&nbsp;
<i>537</i>&nbsp;        for (int elemIndex = 0; elemIndex &lt; fElemMapSize; elemIndex++) {
<i>538</i>&nbsp;            for (int leafIndex = 0; leafIndex &lt; fLeafCount; leafIndex++) {
<i>539</i>&nbsp;                    final QName leaf = fLeafList[leafIndex].getElement();
<i>540</i>&nbsp;                    final QName element = fElemMap[elemIndex];
<i>541</i>&nbsp;                    if (leaf.rawname == element.rawname) {
<i>542</i>&nbsp;                            fLeafSorter[fSortCount++] = leafIndex;
<i>543</i>&nbsp;                    }
<i>544</i>&nbsp;            }
<i>545</i>&nbsp;            fLeafSorter[fSortCount++] = -1;
<b class="nc"><i>546</i>&nbsp;        }</b>
<i>547</i>&nbsp;
<i>548</i>&nbsp;        /* Optimization(Jan, 2001) */
<b class="nc"><i>549</i>&nbsp;</b>
<b class="nc"><i>550</i>&nbsp;        //</b>
<i>551</i>&nbsp;        //  Next lets create some arrays, some that that hold transient
<b class="nc"><i>552</i>&nbsp;        //  information during the DFA build and some that are permament.</b>
<b class="nc"><i>553</i>&nbsp;        //  These are kind of sticky since we cannot know how big they will</b>
<i>554</i>&nbsp;        //  get, but we don&#39;t want to use any Java collections because of
<i>555</i>&nbsp;        //  performance.
<i>556</i>&nbsp;        //
<i>557</i>&nbsp;        //  Basically they will probably be about fLeafCount*2 on average,
<b class="nc"><i>558</i>&nbsp;        //  but can be as large as 2^(fLeafCount*2), worst case. So we start</b>
<b class="nc"><i>559</i>&nbsp;        //  with fLeafCount*4 as a middle ground. This will be very unlikely</b>
<b class="nc"><i>560</i>&nbsp;        //  to ever have to expand, though it if does, the overhead will be</b>
<b class="nc"><i>561</i>&nbsp;        //  somewhat ugly.</b>
<i>562</i>&nbsp;        //
<i>563</i>&nbsp;        int curArraySize = fLeafCount * 4;
<i>564</i>&nbsp;        CMStateSet[] statesToDo = new CMStateSet[curArraySize];
<i>565</i>&nbsp;        fFinalStateFlags = new boolean[curArraySize];
<i>566</i>&nbsp;        fTransTable = new int[curArraySize][];
<i>567</i>&nbsp;
<i>568</i>&nbsp;        //
<i>569</i>&nbsp;        //  Ok we start with the initial set as the first pos set of the
<i>570</i>&nbsp;        //  head node (which is the seq node that holds the content model
<i>571</i>&nbsp;        //  and the EOC node.)
<i>572</i>&nbsp;        //
<i>573</i>&nbsp;        CMStateSet setT = fHeadNode.firstPos();
<i>574</i>&nbsp;
<i>575</i>&nbsp;        //
<b class="nc"><i>576</i>&nbsp;        //  Init our two state flags. Basically the unmarked state counter</b>
<b class="nc"><i>577</i>&nbsp;        //  is always chasing the current state counter. When it catches up,</b>
<i>578</i>&nbsp;        //  that means we made a pass through that did not add any new states
<b class="nc"><i>579</i>&nbsp;        //  to the lists, at which time we are done. We could have used a</b>
<b class="nc"><i>580</i>&nbsp;        //  expanding array of flags which we used to mark off states as we</b>
<b class="nc"><i>581</i>&nbsp;        //  complete them, but this is easier though less readable maybe.</b>
<b class="nc"><i>582</i>&nbsp;        //</b>
<b class="nc"><i>583</i>&nbsp;        int unmarkedState = 0;</b>
<b class="nc"><i>584</i>&nbsp;        int curState = 0;</b>
<i>585</i>&nbsp;
<i>586</i>&nbsp;        //
<b class="nc"><i>587</i>&nbsp;        //  Init the first transition table entry, and put the initial state</b>
<i>588</i>&nbsp;        //  into the states to do list, then bump the current state.
<i>589</i>&nbsp;        //
<i>590</i>&nbsp;        fTransTable[curState] = makeDefStateList();
<i>591</i>&nbsp;        statesToDo[curState] = setT;
<i>592</i>&nbsp;        curState++;
<i>593</i>&nbsp;
<i>594</i>&nbsp;            /* Optimization(Jan, 2001); This is faster for
<i>595</i>&nbsp;             * a large content model such as, &quot;(t001+|t002+|.... |t500+)&quot;.
<i>596</i>&nbsp;             */
<i>597</i>&nbsp;
<i>598</i>&nbsp;        Map&lt;CMStateSet, Integer&gt; stateTable = new HashMap&lt;&gt;();
<i>599</i>&nbsp;
<i>600</i>&nbsp;            /* Optimization(Jan, 2001) */
<i>601</i>&nbsp;
<i>602</i>&nbsp;        //
<i>603</i>&nbsp;        //  Ok, almost done with the algorithm... We now enter the
<i>604</i>&nbsp;        //  loop where we go until the states done counter catches up with
<b class="nc"><i>605</i>&nbsp;        //  the states to do counter.</b>
<b class="nc"><i>606</i>&nbsp;        //</b>
<b class="nc"><i>607</i>&nbsp;        while (unmarkedState &lt; curState)</b>
<b class="nc"><i>608</i>&nbsp;        {</b>
<i>609</i>&nbsp;            //
<i>610</i>&nbsp;            //  Get the first unmarked state out of the list of states to do.
<i>611</i>&nbsp;            //  And get the associated transition table entry.
<i>612</i>&nbsp;            //
<i>613</i>&nbsp;            setT = statesToDo[unmarkedState];
<i>614</i>&nbsp;            int[] transEntry = fTransTable[unmarkedState];
<b class="nc"><i>615</i>&nbsp;</b>
<i>616</i>&nbsp;            // Mark this one final if it contains the EOC state
<i>617</i>&nbsp;            fFinalStateFlags[unmarkedState] = setT.getBit(fEOCPos);
<i>618</i>&nbsp;
<i>619</i>&nbsp;            // Bump up the unmarked state count, marking this state done
<i>620</i>&nbsp;            unmarkedState++;
<i>621</i>&nbsp;
<i>622</i>&nbsp;            // Loop through each possible input symbol in the element map
<i>623</i>&nbsp;            CMStateSet newSet = null;
<i>624</i>&nbsp;            /* Optimization(Jan, 2001) */
<b class="nc"><i>625</i>&nbsp;            int sorterIndex = 0;</b>
<b class="nc"><i>626</i>&nbsp;            /* Optimization(Jan, 2001) */</b>
<i>627</i>&nbsp;            for (int elemIndex = 0; elemIndex &lt; fElemMapSize; elemIndex++)
<i>628</i>&nbsp;            {
<i>629</i>&nbsp;                //
<i>630</i>&nbsp;                //  Build up a set of states which is the union of all of
<i>631</i>&nbsp;                //  the follow sets of DFA positions that are in the current
<b class="nc"><i>632</i>&nbsp;                //  state. If we gave away the new set last time through then</b>
<b class="nc"><i>633</i>&nbsp;                //  create a new one. Otherwise, zero out the existing one.</b>
<b class="nc"><i>634</i>&nbsp;                //</b>
<i>635</i>&nbsp;                if (newSet == null)
<i>636</i>&nbsp;                    newSet = new CMStateSet(fLeafCount);
<i>637</i>&nbsp;                else
<i>638</i>&nbsp;                    newSet.zeroBits();
<i>639</i>&nbsp;
<b class="nc"><i>640</i>&nbsp;            /* Optimization(Jan, 2001) */</b>
<i>641</i>&nbsp;                int leafIndex = fLeafSorter[sorterIndex++];
<i>642</i>&nbsp;
<i>643</i>&nbsp;                while (leafIndex != -1) {
<i>644</i>&nbsp;                // If this leaf index (DFA position) is in the current set...
<i>645</i>&nbsp;                    if (setT.getBit(leafIndex))
<i>646</i>&nbsp;                    {
<i>647</i>&nbsp;                        //
<i>648</i>&nbsp;                        //  If this leaf is the current input symbol, then we
<b class="nc"><i>649</i>&nbsp;                        //  want to add its follow list to the set of states to</b>
<i>650</i>&nbsp;                        //  transition to from the current state.
<i>651</i>&nbsp;                        //
<i>652</i>&nbsp;                                newSet.union(fFollowList[leafIndex]);
<i>653</i>&nbsp;                            }
<i>654</i>&nbsp;
<b class="nc"><i>655</i>&nbsp;                   leafIndex = fLeafSorter[sorterIndex++];</b>
<b class="nc"><i>656</i>&nbsp;        }</b>
<i>657</i>&nbsp;            /* Optimization(Jan, 2001) */
<i>658</i>&nbsp;
<b class="nc"><i>659</i>&nbsp;                //</b>
<i>660</i>&nbsp;                //  If this new set is not empty, then see if its in the list
<i>661</i>&nbsp;                //  of states to do. If not, then add it.
<b class="nc"><i>662</i>&nbsp;                //</b>
<i>663</i>&nbsp;                if (!newSet.isEmpty())
<i>664</i>&nbsp;                {
<b class="nc"><i>665</i>&nbsp;                    //</b>
<i>666</i>&nbsp;                    //  Search the &#39;states to do&#39; list to see if this new
<b class="nc"><i>667</i>&nbsp;                    //  state set is already in there.</b>
<i>668</i>&nbsp;                    //
<b class="nc"><i>669</i>&nbsp;</b>
<i>670</i>&nbsp;            /* Optimization(Jan, 2001) */
<i>671</i>&nbsp;            Integer stateObj = stateTable.get(newSet);
<i>672</i>&nbsp;            int stateIndex = (stateObj == null ? curState : stateObj.intValue());
<i>673</i>&nbsp;            /* Optimization(Jan, 2001) */
<i>674</i>&nbsp;
<i>675</i>&nbsp;                    // If we did not find it, then add it
<i>676</i>&nbsp;                    if (stateIndex == curState)
<b class="nc"><i>677</i>&nbsp;                    {</b>
<b class="nc"><i>678</i>&nbsp;                        //</b>
<i>679</i>&nbsp;                        //  Put this new state into the states to do and init
<b class="nc"><i>680</i>&nbsp;                        //  a new entry at the same index in the transition</b>
<i>681</i>&nbsp;                        //  table.
<i>682</i>&nbsp;                        //
<b class="nc"><i>683</i>&nbsp;                        statesToDo[curState] = newSet;</b>
<i>684</i>&nbsp;                        fTransTable[curState] = makeDefStateList();
<b class="nc"><i>685</i>&nbsp;</b>
<i>686</i>&nbsp;            /* Optimization(Jan, 2001) */
<b class="nc"><i>687</i>&nbsp;                        stateTable.put(newSet, curState);</b>
<i>688</i>&nbsp;            /* Optimization(Jan, 2001) */
<i>689</i>&nbsp;
<i>690</i>&nbsp;                        // We now have a new state to do so bump the count
<i>691</i>&nbsp;                        curState++;
<i>692</i>&nbsp;
<i>693</i>&nbsp;                        //
<b class="nc"><i>694</i>&nbsp;                        //  Null out the new set to indicate we adopted it.</b>
<i>695</i>&nbsp;                        //  This will cause the creation of a new set on the
<i>696</i>&nbsp;                        //  next time around the loop.
<b class="nc"><i>697</i>&nbsp;                        //</b>
<i>698</i>&nbsp;                        newSet = null;
<i>699</i>&nbsp;                    }
<i>700</i>&nbsp;
<i>701</i>&nbsp;                    //
<i>702</i>&nbsp;                    //  Now set this state in the transition table&#39;s entry
<i>703</i>&nbsp;                    //  for this element (using its index), with the DFA
<i>704</i>&nbsp;                    //  state we will move to from the current state when we
<b class="nc"><i>705</i>&nbsp;                    //  see this input element.</b>
<i>706</i>&nbsp;                    //
<i>707</i>&nbsp;                    transEntry[elemIndex] = stateIndex;
<i>708</i>&nbsp;
<i>709</i>&nbsp;                    // Expand the arrays if we&#39;re full
<i>710</i>&nbsp;                    if (curState == curArraySize)
<i>711</i>&nbsp;                    {
<i>712</i>&nbsp;                        //
<b class="nc"><i>713</i>&nbsp;                        //  Yikes, we overflowed the initial array size, so</b>
<b class="nc"><i>714</i>&nbsp;                        //  we&#39;ve got to expand all of these arrays. So adjust</b>
<i>715</i>&nbsp;                        //  up the size by 50% and allocate new arrays.
<i>716</i>&nbsp;                        //
<i>717</i>&nbsp;                        final int newSize = (int)(curArraySize * 1.5);
<b class="nc"><i>718</i>&nbsp;                        CMStateSet[] newToDo = new CMStateSet[newSize];</b>
<i>719</i>&nbsp;                        boolean[] newFinalFlags = new boolean[newSize];
<i>720</i>&nbsp;                        int[][] newTransTable = new int[newSize][];
<i>721</i>&nbsp;
<i>722</i>&nbsp;                        // Copy over all of the existing content
<i>723</i>&nbsp;                        System.arraycopy(statesToDo, 0, newToDo, 0, curArraySize);
<i>724</i>&nbsp;                        System.arraycopy(fFinalStateFlags, 0, newFinalFlags, 0, curArraySize);
<b class="nc"><i>725</i>&nbsp;                        System.arraycopy(fTransTable, 0, newTransTable, 0, curArraySize);</b>
<b class="nc"><i>726</i>&nbsp;</b>
<i>727</i>&nbsp;                        // Store the new array size
<i>728</i>&nbsp;                        curArraySize = newSize;
<b class="nc"><i>729</i>&nbsp;                        statesToDo = newToDo;</b>
<i>730</i>&nbsp;                        fFinalStateFlags = newFinalFlags;
<i>731</i>&nbsp;                        fTransTable = newTransTable;
<i>732</i>&nbsp;                    }
<b class="nc"><i>733</i>&nbsp;                }</b>
<i>734</i>&nbsp;            }
<i>735</i>&nbsp;        }
<i>736</i>&nbsp;
<i>737</i>&nbsp;        // Check to see if we can set the fEmptyContentIsValid flag.
<i>738</i>&nbsp;        fEmptyContentIsValid = ((CMBinOp)fHeadNode).getLeft().isNullable();
<i>739</i>&nbsp;
<b class="nc"><i>740</i>&nbsp;        //</b>
<i>741</i>&nbsp;        //  And now we can say bye bye to the temp representation since we&#39;ve
<i>742</i>&nbsp;        //  built the DFA.
<i>743</i>&nbsp;        //
<i>744</i>&nbsp;        if (DEBUG_VALIDATE_CONTENT)
<i>745</i>&nbsp;            dumpTree(fHeadNode, 0);
<i>746</i>&nbsp;        fHeadNode = null;
<i>747</i>&nbsp;        fLeafList = null;
<i>748</i>&nbsp;        fFollowList = null;
<b class="nc"><i>749</i>&nbsp;</b>
<i>750</i>&nbsp;    }
<i>751</i>&nbsp;
<b class="nc"><i>752</i>&nbsp;    /**</b>
<i>753</i>&nbsp;     * Calculates the follow list of the current node.
<i>754</i>&nbsp;     *
<i>755</i>&nbsp;     * @param nodeCur The curent node.
<i>756</i>&nbsp;     *
<i>757</i>&nbsp;     * @exception CMException Thrown if follow list cannot be calculated.
<i>758</i>&nbsp;     */
<b class="nc"><i>759</i>&nbsp;    private void calcFollowList(CMNode nodeCur)</b>
<b class="nc"><i>760</i>&nbsp;    {</b>
<b class="nc"><i>761</i>&nbsp;        // Recurse as required</b>
<b class="nc"><i>762</i>&nbsp;        if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_CHOICE)</b>
<i>763</i>&nbsp;        {
<i>764</i>&nbsp;            // Recurse only
<b class="nc"><i>765</i>&nbsp;            calcFollowList(((CMBinOp)nodeCur).getLeft());</b>
<b class="nc"><i>766</i>&nbsp;            calcFollowList(((CMBinOp)nodeCur).getRight());</b>
<b class="nc"><i>767</i>&nbsp;        }</b>
<i>768</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_SEQ)
<i>769</i>&nbsp;        {
<b class="nc"><i>770</i>&nbsp;            // Recurse first</b>
<b class="nc"><i>771</i>&nbsp;            calcFollowList(((CMBinOp)nodeCur).getLeft());</b>
<b class="nc"><i>772</i>&nbsp;            calcFollowList(((CMBinOp)nodeCur).getRight());</b>
<b class="nc"><i>773</i>&nbsp;</b>
<i>774</i>&nbsp;            //
<i>775</i>&nbsp;            //  Now handle our level. We use our left child&#39;s last pos
<i>776</i>&nbsp;            //  set and our right child&#39;s first pos set, so go ahead and
<b class="nc"><i>777</i>&nbsp;            //  get them ahead of time.</b>
<i>778</i>&nbsp;            //
<i>779</i>&nbsp;            final CMStateSet last  = ((CMBinOp)nodeCur).getLeft().lastPos();
<b class="nc"><i>780</i>&nbsp;            final CMStateSet first = ((CMBinOp)nodeCur).getRight().firstPos();</b>
<i>781</i>&nbsp;
<i>782</i>&nbsp;            //
<i>783</i>&nbsp;            //  Now, for every position which is in our left child&#39;s last set
<i>784</i>&nbsp;            //  add all of the states in our right child&#39;s first set to the
<i>785</i>&nbsp;            //  follow set for that position.
<i>786</i>&nbsp;            //
<i>787</i>&nbsp;            for (int index = 0; index &lt; fLeafCount; index++)
<b class="nc"><i>788</i>&nbsp;            {</b>
<b class="nc"><i>789</i>&nbsp;                if (last.getBit(index))</b>
<b class="nc"><i>790</i>&nbsp;                    fFollowList[index].union(first);</b>
<i>791</i>&nbsp;            }
<i>792</i>&nbsp;        }
<i>793</i>&nbsp;         /***
<i>794</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE)
<i>795</i>&nbsp;        {
<i>796</i>&nbsp;            // Recurse first
<i>797</i>&nbsp;            calcFollowList(((CMUniOp)nodeCur).getChild());
<i>798</i>&nbsp;
<i>799</i>&nbsp;            //
<i>800</i>&nbsp;            //  Now handle our level. We use our own first and last position
<i>801</i>&nbsp;            //  sets, so get them up front.
<i>802</i>&nbsp;            //
<i>803</i>&nbsp;            final CMStateSet first = nodeCur.firstPos();
<b class="nc"><i>804</i>&nbsp;            final CMStateSet last  = nodeCur.lastPos();</b>
<i>805</i>&nbsp;
<i>806</i>&nbsp;            //
<b class="nc"><i>807</i>&nbsp;            //  For every position which is in our last position set, add all</b>
<b class="nc"><i>808</i>&nbsp;            //  of our first position states to the follow set for that</b>
<i>809</i>&nbsp;            //  position.
<b class="nc"><i>810</i>&nbsp;            //</b>
<i>811</i>&nbsp;            for (int index = 0; index &lt; fLeafCount; index++)
<i>812</i>&nbsp;            {
<b class="nc"><i>813</i>&nbsp;                if (last.getBit(index))</b>
<b class="nc"><i>814</i>&nbsp;                    fFollowList[index].union(first);</b>
<i>815</i>&nbsp;            }
<i>816</i>&nbsp;        }
<i>817</i>&nbsp;         else if ((nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE)
<i>818</i>&nbsp;              ||  (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE))
<i>819</i>&nbsp;        {
<i>820</i>&nbsp;            throw new RuntimeException(&quot;ImplementationMessages.VAL_NIICM&quot;);
<b class="nc"><i>821</i>&nbsp;        }</b>
<b class="nc"><i>822</i>&nbsp;        /***/</b>
<i>823</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE
<i>824</i>&nbsp;            || nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE)
<i>825</i>&nbsp;        {
<i>826</i>&nbsp;            // Recurse first
<i>827</i>&nbsp;            calcFollowList(((CMUniOp)nodeCur).getChild());
<i>828</i>&nbsp;
<b class="nc"><i>829</i>&nbsp;            //</b>
<i>830</i>&nbsp;            //  Now handle our level. We use our own first and last position
<b class="nc"><i>831</i>&nbsp;            //  sets, so get them up front.</b>
<b class="nc"><i>832</i>&nbsp;            //</b>
<i>833</i>&nbsp;            final CMStateSet first = nodeCur.firstPos();
<b class="nc"><i>834</i>&nbsp;            final CMStateSet last  = nodeCur.lastPos();</b>
<i>835</i>&nbsp;
<i>836</i>&nbsp;            //
<i>837</i>&nbsp;            //  For every position which is in our last position set, add all
<i>838</i>&nbsp;            //  of our first position states to the follow set for that
<i>839</i>&nbsp;            //  position.
<i>840</i>&nbsp;            //
<i>841</i>&nbsp;            for (int index = 0; index &lt; fLeafCount; index++)
<i>842</i>&nbsp;            {
<i>843</i>&nbsp;                if (last.getBit(index))
<i>844</i>&nbsp;                    fFollowList[index].union(first);
<i>845</i>&nbsp;            }
<i>846</i>&nbsp;        }
<i>847</i>&nbsp;
<i>848</i>&nbsp;        else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE) {
<i>849</i>&nbsp;            // Recurse only
<i>850</i>&nbsp;            calcFollowList(((CMUniOp)nodeCur).getChild());
<i>851</i>&nbsp;        }
<i>852</i>&nbsp;         /***/
<i>853</i>&nbsp;    }
<i>854</i>&nbsp;
<i>855</i>&nbsp;    /**
<i>856</i>&nbsp;     * Dumps the tree of the current node to standard output.
<i>857</i>&nbsp;     *
<i>858</i>&nbsp;     * @param nodeCur The current node.
<i>859</i>&nbsp;     * @param level   The maximum levels to output.
<i>860</i>&nbsp;     *
<i>861</i>&nbsp;     * @exception CMException Thrown on error.
<i>862</i>&nbsp;     */
<i>863</i>&nbsp;    private void dumpTree(CMNode nodeCur, int level)
<i>864</i>&nbsp;    {
<b class="nc"><i>865</i>&nbsp;        for (int index = 0; index &lt; level; index++)</b>
<b class="nc"><i>866</i>&nbsp;            System.out.print(&quot;   &quot;);</b>
<i>867</i>&nbsp;
<i>868</i>&nbsp;        int type = nodeCur.type();
<b class="nc"><i>869</i>&nbsp;        if ((type == XMLContentSpec.CONTENTSPECNODE_CHOICE)</b>
<i>870</i>&nbsp;        ||  (type == XMLContentSpec.CONTENTSPECNODE_SEQ))
<i>871</i>&nbsp;        {
<i>872</i>&nbsp;            if (type == XMLContentSpec.CONTENTSPECNODE_CHOICE)
<i>873</i>&nbsp;                System.out.print(&quot;Choice Node &quot;);
<i>874</i>&nbsp;            else
<b class="nc"><i>875</i>&nbsp;                System.out.print(&quot;Seq Node &quot;);</b>
<b class="nc"><i>876</i>&nbsp;</b>
<i>877</i>&nbsp;            if (nodeCur.isNullable())
<i>878</i>&nbsp;                System.out.print(&quot;Nullable &quot;);
<i>879</i>&nbsp;
<i>880</i>&nbsp;            System.out.print(&quot;firstPos=&quot;);
<i>881</i>&nbsp;            System.out.print(nodeCur.firstPos().toString());
<i>882</i>&nbsp;            System.out.print(&quot; lastPos=&quot;);
<b class="nc"><i>883</i>&nbsp;            System.out.println(nodeCur.lastPos().toString());</b>
<i>884</i>&nbsp;
<b class="nc"><i>885</i>&nbsp;            dumpTree(((CMBinOp)nodeCur).getLeft(), level+1);</b>
<b class="nc"><i>886</i>&nbsp;            dumpTree(((CMBinOp)nodeCur).getRight(), level+1);</b>
<i>887</i>&nbsp;        }
<b class="nc"><i>888</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE)</b>
<i>889</i>&nbsp;        {
<b class="nc"><i>890</i>&nbsp;            System.out.print(&quot;Rep Node &quot;);</b>
<i>891</i>&nbsp;
<b class="nc"><i>892</i>&nbsp;            if (nodeCur.isNullable())</b>
<i>893</i>&nbsp;                System.out.print(&quot;Nullable &quot;);
<i>894</i>&nbsp;
<i>895</i>&nbsp;            System.out.print(&quot;firstPos=&quot;);
<i>896</i>&nbsp;            System.out.print(nodeCur.firstPos().toString());
<i>897</i>&nbsp;            System.out.print(&quot; lastPos=&quot;);
<i>898</i>&nbsp;            System.out.println(nodeCur.lastPos().toString());
<i>899</i>&nbsp;
<i>900</i>&nbsp;            dumpTree(((CMUniOp)nodeCur).getChild(), level+1);
<i>901</i>&nbsp;        }
<i>902</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_LEAF)
<i>903</i>&nbsp;        {
<i>904</i>&nbsp;            System.out.print
<i>905</i>&nbsp;            (
<i>906</i>&nbsp;                &quot;Leaf: (pos=&quot;
<b class="nc"><i>907</i>&nbsp;                + ((CMLeaf)nodeCur).getPosition()</b>
<b class="nc"><i>908</i>&nbsp;                + &quot;), &quot;</b>
<i>909</i>&nbsp;                + ((CMLeaf)nodeCur).getElement()
<b class="nc"><i>910</i>&nbsp;                + &quot;(elemIndex=&quot;</b>
<b class="nc"><i>911</i>&nbsp;                + ((CMLeaf)nodeCur).getElement()</b>
<i>912</i>&nbsp;                + &quot;) &quot;
<i>913</i>&nbsp;            );
<b class="nc"><i>914</i>&nbsp;</b>
<b class="nc"><i>915</i>&nbsp;            if (nodeCur.isNullable())</b>
<i>916</i>&nbsp;                System.out.print(&quot; Nullable &quot;);
<b class="nc"><i>917</i>&nbsp;</b>
<i>918</i>&nbsp;            System.out.print(&quot;firstPos=&quot;);
<b class="nc"><i>919</i>&nbsp;            System.out.print(nodeCur.firstPos().toString());</b>
<b class="nc"><i>920</i>&nbsp;            System.out.print(&quot; lastPos=&quot;);</b>
<i>921</i>&nbsp;            System.out.println(nodeCur.lastPos().toString());
<b class="nc"><i>922</i>&nbsp;        }</b>
<b class="nc"><i>923</i>&nbsp;         else</b>
<b class="nc"><i>924</i>&nbsp;        {</b>
<b class="nc"><i>925</i>&nbsp;            throw new RuntimeException(&quot;ImplementationMessages.VAL_NIICM&quot;);</b>
<i>926</i>&nbsp;        }
<b class="nc"><i>927</i>&nbsp;    }</b>
<b class="nc"><i>928</i>&nbsp;</b>
<i>929</i>&nbsp;
<b class="nc"><i>930</i>&nbsp;    /**</b>
<i>931</i>&nbsp;     * -1 is used to represent bad transitions in the transition table
<b class="nc"><i>932</i>&nbsp;     * entry for each state. So each entry is initialized to an all -1</b>
<i>933</i>&nbsp;     * array. This method creates a new entry and initializes it.
<b class="nc"><i>934</i>&nbsp;     */</b>
<b class="nc"><i>935</i>&nbsp;    private int[] makeDefStateList()</b>
<i>936</i>&nbsp;    {
<b class="nc"><i>937</i>&nbsp;        int[] retArray = new int[fElemMapSize];</b>
<b class="nc"><i>938</i>&nbsp;        for (int index = 0; index &lt; fElemMapSize; index++)</b>
<b class="nc"><i>939</i>&nbsp;            retArray[index] = -1;</b>
<b class="nc"><i>940</i>&nbsp;        return retArray;</b>
<i>941</i>&nbsp;    }
<b class="nc"><i>942</i>&nbsp;</b>
<i>943</i>&nbsp;    /** Post tree build initialization. */
<b class="nc"><i>944</i>&nbsp;    private int postTreeBuildInit(CMNode nodeCur, int curIndex)</b>
<i>945</i>&nbsp;    {
<b class="nc"><i>946</i>&nbsp;        // Set the maximum states on this node</b>
<b class="nc"><i>947</i>&nbsp;        nodeCur.setMaxStates(fLeafCount);</b>
<i>948</i>&nbsp;
<b class="nc"><i>949</i>&nbsp;        // Recurse as required</b>
<i>950</i>&nbsp;        if ((nodeCur.type() &amp; 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY ||
<b class="nc"><i>951</i>&nbsp;            (nodeCur.type() &amp; 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_LOCAL ||</b>
<i>952</i>&nbsp;            (nodeCur.type() &amp; 0x0f) == XMLContentSpec.CONTENTSPECNODE_ANY_OTHER) {
<b class="nc"><i>953</i>&nbsp;            // REVISIT: Don&#39;t waste these structures.</b>
<i>954</i>&nbsp;            QName qname = new QName(null, null, null, ((CMAny)nodeCur).getURI());
<i>955</i>&nbsp;            fLeafList[curIndex] = new CMLeaf(qname, ((CMAny)nodeCur).getPosition());
<i>956</i>&nbsp;            fLeafListType[curIndex] = nodeCur.type();
<b class="nc"><i>957</i>&nbsp;            curIndex++;</b>
<b class="nc"><i>958</i>&nbsp;        }</b>
<i>959</i>&nbsp;        else if ((nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_CHOICE)
<b class="nc"><i>960</i>&nbsp;        ||  (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_SEQ))</b>
<b class="nc"><i>961</i>&nbsp;        {</b>
<b class="nc"><i>962</i>&nbsp;            curIndex = postTreeBuildInit(((CMBinOp)nodeCur).getLeft(), curIndex);</b>
<b class="nc"><i>963</i>&nbsp;            curIndex = postTreeBuildInit(((CMBinOp)nodeCur).getRight(), curIndex);</b>
<i>964</i>&nbsp;        }
<i>965</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_MORE
<i>966</i>&nbsp;             || nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ONE_OR_MORE
<b class="nc"><i>967</i>&nbsp;             || nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_ZERO_OR_ONE)</b>
<i>968</i>&nbsp;        {
<i>969</i>&nbsp;            curIndex = postTreeBuildInit(((CMUniOp)nodeCur).getChild(), curIndex);
<i>970</i>&nbsp;        }
<i>971</i>&nbsp;         else if (nodeCur.type() == XMLContentSpec.CONTENTSPECNODE_LEAF)
<i>972</i>&nbsp;        {
<i>973</i>&nbsp;            //
<i>974</i>&nbsp;            //  Put this node in the leaf list at the current index if its
<i>975</i>&nbsp;            //  a non-epsilon leaf.
<i>976</i>&nbsp;            //
<i>977</i>&nbsp;             final QName node = ((CMLeaf)nodeCur).getElement();
<i>978</i>&nbsp;            if (node.localpart != fEpsilonString) {
<b class="nc"><i>979</i>&nbsp;                fLeafList[curIndex] = (CMLeaf)nodeCur;</b>
<b class="nc"><i>980</i>&nbsp;                fLeafListType[curIndex] = XMLContentSpec.CONTENTSPECNODE_LEAF;</b>
<b class="nc"><i>981</i>&nbsp;                curIndex++;</b>
<b class="nc"><i>982</i>&nbsp;            }</b>
<i>983</i>&nbsp;        }
<i>984</i>&nbsp;         else
<i>985</i>&nbsp;        {
<i>986</i>&nbsp;            throw new RuntimeException(&quot;ImplementationMessages.VAL_NIICM: type=&quot;+nodeCur.type());
<i>987</i>&nbsp;        }
<i>988</i>&nbsp;        return curIndex;
<b class="nc"><i>989</i>&nbsp;    }</b>
<i>990</i>&nbsp;
<i>991</i>&nbsp;} // class DFAContentModel
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
