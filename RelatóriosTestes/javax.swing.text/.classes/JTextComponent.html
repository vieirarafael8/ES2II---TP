


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: JTextComponent</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.text</a> ]
</div>

<h1>Coverage Summary for Class: JTextComponent (javax.swing.text)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JTextComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 595)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JTextComponent$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$3$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$3$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$4$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 362)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$AccessibleJTextComponent$IndexedSegment</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$ComposedTextCaret</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$DefaultKeymap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 69)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$DefaultTransferHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$DoSetCaretPosition</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$DropLocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$InputMethodRequestsHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 78)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$KeyBinding</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$KeymapActionMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$KeymapWrapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JTextComponent$MutableCaretEvent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 233)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1341)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.text;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import com.sun.beans.util.Cache;
<i>28</i>&nbsp;
<i>29</i>&nbsp;import java.security.AccessController;
<i>30</i>&nbsp;import java.security.PrivilegedAction;
<i>31</i>&nbsp;
<i>32</i>&nbsp;import java.beans.JavaBean;
<i>33</i>&nbsp;import java.beans.BeanProperty;
<i>34</i>&nbsp;import java.beans.Transient;
<i>35</i>&nbsp;import java.util.HashMap;
<i>36</i>&nbsp;import java.util.Hashtable;
<i>37</i>&nbsp;import java.util.Enumeration;
<i>38</i>&nbsp;import java.util.Vector;
<i>39</i>&nbsp;
<i>40</i>&nbsp;import java.util.concurrent.*;
<i>41</i>&nbsp;
<i>42</i>&nbsp;import java.io.*;
<i>43</i>&nbsp;
<i>44</i>&nbsp;import java.awt.*;
<i>45</i>&nbsp;import java.awt.event.*;
<i>46</i>&nbsp;import java.awt.print.*;
<i>47</i>&nbsp;import java.awt.datatransfer.*;
<i>48</i>&nbsp;import java.awt.im.InputContext;
<i>49</i>&nbsp;import java.awt.im.InputMethodRequests;
<i>50</i>&nbsp;import java.awt.font.TextHitInfo;
<i>51</i>&nbsp;import java.awt.font.TextAttribute;
<i>52</i>&nbsp;import java.awt.geom.Point2D;
<i>53</i>&nbsp;import java.awt.geom.Rectangle2D;
<i>54</i>&nbsp;
<i>55</i>&nbsp;import java.awt.print.Printable;
<i>56</i>&nbsp;import java.awt.print.PrinterException;
<i>57</i>&nbsp;
<i>58</i>&nbsp;import javax.print.PrintService;
<i>59</i>&nbsp;import javax.print.attribute.PrintRequestAttributeSet;
<i>60</i>&nbsp;
<i>61</i>&nbsp;import java.text.*;
<i>62</i>&nbsp;import java.text.AttributedCharacterIterator.Attribute;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import javax.swing.*;
<i>65</i>&nbsp;import javax.swing.event.*;
<i>66</i>&nbsp;import javax.swing.plaf.*;
<i>67</i>&nbsp;
<i>68</i>&nbsp;import javax.accessibility.*;
<i>69</i>&nbsp;
<i>70</i>&nbsp;import javax.print.attribute.*;
<i>71</i>&nbsp;
<i>72</i>&nbsp;import sun.awt.AppContext;
<i>73</i>&nbsp;
<i>74</i>&nbsp;
<i>75</i>&nbsp;import sun.swing.PrintingStatus;
<i>76</i>&nbsp;import sun.swing.SwingUtilities2;
<i>77</i>&nbsp;import sun.swing.text.TextComponentPrintable;
<i>78</i>&nbsp;import sun.swing.SwingAccessor;
<i>79</i>&nbsp;
<i>80</i>&nbsp;/**
<i>81</i>&nbsp; * &lt;code&gt;JTextComponent&lt;/code&gt; is the base class for swing text
<i>82</i>&nbsp; * components.  It tries to be compatible with the
<i>83</i>&nbsp; * &lt;code&gt;java.awt.TextComponent&lt;/code&gt; class
<i>84</i>&nbsp; * where it can reasonably do so.  Also provided are other services
<i>85</i>&nbsp; * for additional flexibility (beyond the pluggable UI and bean
<i>86</i>&nbsp; * support).
<i>87</i>&nbsp; * You can find information on how to use the functionality
<i>88</i>&nbsp; * this class provides in
<i>89</i>&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/generaltext.html&quot;&gt;General Rules for Using Text Components&lt;/a&gt;,
<i>90</i>&nbsp; * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
<i>91</i>&nbsp; *
<i>92</i>&nbsp; * &lt;dl&gt;
<i>93</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Caret Changes&lt;/b&gt;
<i>94</i>&nbsp; * &lt;dd&gt;
<i>95</i>&nbsp; * The caret is a pluggable object in swing text components.
<i>96</i>&nbsp; * Notification of changes to the caret position and the selection
<i>97</i>&nbsp; * are sent to implementations of the &lt;code&gt;CaretListener&lt;/code&gt;
<i>98</i>&nbsp; * interface that have been registered with the text component.
<i>99</i>&nbsp; * The UI will install a default caret unless a customized caret
<i>100</i>&nbsp; * has been set. &lt;br&gt;
<i>101</i>&nbsp; * By default the caret tracks all the document changes
<i>102</i>&nbsp; * performed on the Event Dispatching Thread and updates it&#39;s position
<i>103</i>&nbsp; * accordingly if an insertion occurs before or at the caret position
<i>104</i>&nbsp; * or a removal occurs before the caret position. &lt;code&gt;DefaultCaret&lt;/code&gt;
<i>105</i>&nbsp; * tries to make itself visible which may lead to scrolling
<i>106</i>&nbsp; * of a text component within &lt;code&gt;JScrollPane&lt;/code&gt;. The default caret
<i>107</i>&nbsp; * behavior can be changed by the {@link DefaultCaret#setUpdatePolicy} method.
<i>108</i>&nbsp; * &lt;br&gt;
<i>109</i>&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Non-editable text components also have a caret though
<i>110</i>&nbsp; * it may not be painted.
<i>111</i>&nbsp; *
<i>112</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Commands&lt;/b&gt;
<i>113</i>&nbsp; * &lt;dd&gt;
<i>114</i>&nbsp; * Text components provide a number of commands that can be used
<i>115</i>&nbsp; * to manipulate the component.  This is essentially the way that
<i>116</i>&nbsp; * the component expresses its capabilities.  These are expressed
<i>117</i>&nbsp; * in terms of the swing &lt;code&gt;Action&lt;/code&gt; interface,
<i>118</i>&nbsp; * using the &lt;code&gt;TextAction&lt;/code&gt; implementation.
<i>119</i>&nbsp; * The set of commands supported by the text component can be
<i>120</i>&nbsp; * found with the {@link #getActions} method.  These actions
<i>121</i>&nbsp; * can be bound to key events, fired from buttons, etc.
<i>122</i>&nbsp; *
<i>123</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Text Input&lt;/b&gt;
<i>124</i>&nbsp; * &lt;dd&gt;
<i>125</i>&nbsp; * The text components support flexible and internationalized text input, using
<i>126</i>&nbsp; * keymaps and the input method framework, while maintaining compatibility with
<i>127</i>&nbsp; * the AWT listener model.
<i>128</i>&nbsp; * &lt;p&gt;
<i>129</i>&nbsp; * A {@link javax.swing.text.Keymap} lets an application bind key
<i>130</i>&nbsp; * strokes to actions.
<i>131</i>&nbsp; * In order to allow keymaps to be shared across multiple text components, they
<i>132</i>&nbsp; * can use actions that extend &lt;code&gt;TextAction&lt;/code&gt;.
<i>133</i>&nbsp; * &lt;code&gt;TextAction&lt;/code&gt; can determine which &lt;code&gt;JTextComponent&lt;/code&gt;
<i>134</i>&nbsp; * most recently has or had focus and therefore is the subject of
<i>135</i>&nbsp; * the action (In the case that the &lt;code&gt;ActionEvent&lt;/code&gt;
<i>136</i>&nbsp; * sent to the action doesn&#39;t contain the target text component as its source).
<i>137</i>&nbsp; * &lt;p&gt;
<i>138</i>&nbsp; * The {@extLink imf_overview Input Method Framework}
<i>139</i>&nbsp; * lets text components interact with input methods, separate software
<i>140</i>&nbsp; * components that preprocess events to let users enter thousands of
<i>141</i>&nbsp; * different characters using keyboards with far fewer keys.
<i>142</i>&nbsp; * &lt;code&gt;JTextComponent&lt;/code&gt; is an &lt;em&gt;active client&lt;/em&gt; of
<i>143</i>&nbsp; * the framework, so it implements the preferred user interface for interacting
<i>144</i>&nbsp; * with input methods. As a consequence, some key events do not reach the text
<i>145</i>&nbsp; * component because they are handled by an input method, and some text input
<i>146</i>&nbsp; * reaches the text component as committed text within an {@link
<i>147</i>&nbsp; * java.awt.event.InputMethodEvent} instead of as a key event.
<i>148</i>&nbsp; * The complete text input is the combination of the characters in
<i>149</i>&nbsp; * &lt;code&gt;keyTyped&lt;/code&gt; key events and committed text in input method events.
<i>150</i>&nbsp; * &lt;p&gt;
<i>151</i>&nbsp; * The AWT listener model lets applications attach event listeners to
<i>152</i>&nbsp; * components in order to bind events to actions. Swing encourages the
<i>153</i>&nbsp; * use of keymaps instead of listeners, but maintains compatibility
<i>154</i>&nbsp; * with listeners by giving the listeners a chance to steal an event
<i>155</i>&nbsp; * by consuming it.
<i>156</i>&nbsp; * &lt;p&gt;
<i>157</i>&nbsp; * Keyboard event and input method events are handled in the following stages,
<i>158</i>&nbsp; * with each stage capable of consuming the event:
<i>159</i>&nbsp; *
<i>160</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>161</i>&nbsp; * &lt;caption&gt;Stages of keyboard and input method event handling&lt;/caption&gt;
<i>162</i>&nbsp; * &lt;thead&gt;
<i>163</i>&nbsp; *   &lt;tr&gt;
<i>164</i>&nbsp; *     &lt;th scope=&quot;col&quot;&gt;Stage
<i>165</i>&nbsp; *     &lt;th scope=&quot;col&quot;&gt;KeyEvent
<i>166</i>&nbsp; *     &lt;th scope=&quot;col&quot;&gt;InputMethodEvent
<i>167</i>&nbsp; * &lt;/thead&gt;
<i>168</i>&nbsp; * &lt;tbody&gt;
<i>169</i>&nbsp; *   &lt;tr&gt;
<i>170</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;1.
<i>171</i>&nbsp; *     &lt;td&gt;input methods
<i>172</i>&nbsp; *     &lt;td&gt;(generated here)
<i>173</i>&nbsp; *   &lt;tr&gt;
<i>174</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;2.
<i>175</i>&nbsp; *     &lt;td&gt;focus manager
<i>176</i>&nbsp; *     &lt;td&gt;
<i>177</i>&nbsp; *   &lt;/tr&gt;
<i>178</i>&nbsp; *   &lt;tr&gt;
<i>179</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;3.
<i>180</i>&nbsp; *     &lt;td&gt;registered key listeners
<i>181</i>&nbsp; *     &lt;td&gt;registered input method listeners
<i>182</i>&nbsp; *   &lt;tr&gt;
<i>183</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;4.
<i>184</i>&nbsp; *     &lt;td&gt;
<i>185</i>&nbsp; *     &lt;td&gt;input method handling in JTextComponent
<i>186</i>&nbsp; *   &lt;tr&gt;
<i>187</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;5.
<i>188</i>&nbsp; *     &lt;td colspan=2&gt;keymap handling using the current keymap
<i>189</i>&nbsp; *   &lt;tr&gt;
<i>190</i>&nbsp; *     &lt;th scope=&quot;row&quot;&gt;6.
<i>191</i>&nbsp; *     &lt;td&gt;keyboard handling in JComponent (e.g. accelerators, component
<i>192</i>&nbsp; *     navigation, etc.)
<i>193</i>&nbsp; *     &lt;td&gt;
<i>194</i>&nbsp; * &lt;/tbody&gt;
<i>195</i>&nbsp; * &lt;/table&gt;
<i>196</i>&nbsp; * &lt;p&gt;
<i>197</i>&nbsp; * To maintain compatibility with applications that listen to key
<i>198</i>&nbsp; * events but are not aware of input method events, the input
<i>199</i>&nbsp; * method handling in stage 4 provides a compatibility mode for
<i>200</i>&nbsp; * components that do not process input method events. For these
<i>201</i>&nbsp; * components, the committed text is converted to keyTyped key events
<i>202</i>&nbsp; * and processed in the key event pipeline starting at stage 3
<i>203</i>&nbsp; * instead of in the input method event pipeline.
<i>204</i>&nbsp; * &lt;p&gt;
<i>205</i>&nbsp; * By default the component will create a keymap (named &lt;b&gt;DEFAULT_KEYMAP&lt;/b&gt;)
<i>206</i>&nbsp; * that is shared by all JTextComponent instances as the default keymap.
<i>207</i>&nbsp; * Typically a look-and-feel implementation will install a different keymap
<i>208</i>&nbsp; * that resolves to the default keymap for those bindings not found in the
<i>209</i>&nbsp; * different keymap. The minimal bindings include:
<i>210</i>&nbsp; * &lt;ul&gt;
<i>211</i>&nbsp; * &lt;li&gt;inserting content into the editor for the
<i>212</i>&nbsp; *  printable keys.
<i>213</i>&nbsp; * &lt;li&gt;removing content with the backspace and del
<i>214</i>&nbsp; *  keys.
<i>215</i>&nbsp; * &lt;li&gt;caret movement forward and backward
<i>216</i>&nbsp; * &lt;/ul&gt;
<i>217</i>&nbsp; *
<i>218</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Model/View Split&lt;/b&gt;
<i>219</i>&nbsp; * &lt;dd&gt;
<i>220</i>&nbsp; * The text components have a model-view split.  A text component pulls
<i>221</i>&nbsp; * together the objects used to represent the model, view, and controller.
<i>222</i>&nbsp; * The text document model may be shared by other views which act as observers
<i>223</i>&nbsp; * of the model (e.g. a document may be shared by multiple components).
<i>224</i>&nbsp; *
<i>225</i>&nbsp; * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/editor.gif&quot; alt=&quot;Diagram showing interaction between Controller, Document, events, and ViewFactory&quot;
<i>226</i>&nbsp; *                  HEIGHT=358 WIDTH=587&gt;&lt;/p&gt;
<i>227</i>&nbsp; *
<i>228</i>&nbsp; * &lt;p&gt;
<i>229</i>&nbsp; * The model is defined by the {@link Document} interface.
<i>230</i>&nbsp; * This is intended to provide a flexible text storage mechanism
<i>231</i>&nbsp; * that tracks change during edits and can be extended to more sophisticated
<i>232</i>&nbsp; * models.  The model interfaces are meant to capture the capabilities of
<i>233</i>&nbsp; * expression given by SGML, a system used to express a wide variety of
<i>234</i>&nbsp; * content.
<i>235</i>&nbsp; * Each modification to the document causes notification of the
<i>236</i>&nbsp; * details of the change to be sent to all observers in the form of a
<i>237</i>&nbsp; * {@link DocumentEvent} which allows the views to stay up to date with the model.
<i>238</i>&nbsp; * This event is sent to observers that have implemented the
<i>239</i>&nbsp; * {@link DocumentListener}
<i>240</i>&nbsp; * interface and registered interest with the model being observed.
<i>241</i>&nbsp; *
<i>242</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Location Information&lt;/b&gt;
<i>243</i>&nbsp; * &lt;dd&gt;
<i>244</i>&nbsp; * The capability of determining the location of text in
<i>245</i>&nbsp; * the view is provided.  There are two methods, {@link #modelToView}
<i>246</i>&nbsp; * and {@link #viewToModel} for determining this information.
<i>247</i>&nbsp; *
<i>248</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Undo/Redo support&lt;/b&gt;
<i>249</i>&nbsp; * &lt;dd&gt;
<i>250</i>&nbsp; * Support for an edit history mechanism is provided to allow
<i>251</i>&nbsp; * undo/redo operations.  The text component does not itself
<i>252</i>&nbsp; * provide the history buffer by default, but does provide
<i>253</i>&nbsp; * the &lt;code&gt;UndoableEdit&lt;/code&gt; records that can be used in conjunction
<i>254</i>&nbsp; * with a history buffer to provide the undo/redo support.
<i>255</i>&nbsp; * The support is provided by the Document model, which allows
<i>256</i>&nbsp; * one to attach UndoableEditListener implementations.
<i>257</i>&nbsp; *
<i>258</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Thread Safety&lt;/b&gt;
<i>259</i>&nbsp; * &lt;dd&gt;
<i>260</i>&nbsp; * The swing text components provide some support of thread
<i>261</i>&nbsp; * safe operations.  Because of the high level of configurability
<i>262</i>&nbsp; * of the text components, it is possible to circumvent the
<i>263</i>&nbsp; * protection provided.  The protection primarily comes from
<i>264</i>&nbsp; * the model, so the documentation of &lt;code&gt;AbstractDocument&lt;/code&gt;
<i>265</i>&nbsp; * describes the assumptions of the protection provided.
<i>266</i>&nbsp; * The methods that are safe to call asynchronously are marked
<i>267</i>&nbsp; * with comments.
<i>268</i>&nbsp; *
<i>269</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Newlines&lt;/b&gt;
<i>270</i>&nbsp; * &lt;dd&gt;
<i>271</i>&nbsp; * For a discussion on how newlines are handled, see
<i>272</i>&nbsp; * &lt;a href=&quot;DefaultEditorKit.html&quot;&gt;DefaultEditorKit&lt;/a&gt;.
<i>273</i>&nbsp; *
<i>274</i>&nbsp; *
<i>275</i>&nbsp; * &lt;dt&gt;&lt;b&gt;Printing support&lt;/b&gt;
<i>276</i>&nbsp; * &lt;dd&gt;
<i>277</i>&nbsp; * Several {@link #print print} methods are provided for basic
<i>278</i>&nbsp; * document printing.  If more advanced printing is needed, use the
<i>279</i>&nbsp; * {@link #getPrintable} method.
<i>280</i>&nbsp; * &lt;/dl&gt;
<i>281</i>&nbsp; *
<i>282</i>&nbsp; * &lt;p&gt;
<i>283</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>284</i>&nbsp; * Serialized objects of this class will not be compatible with
<i>285</i>&nbsp; * future Swing releases. The current serialization support is
<i>286</i>&nbsp; * appropriate for short term storage or RMI between applications running
<i>287</i>&nbsp; * the same version of Swing.  As of 1.4, support for long term storage
<i>288</i>&nbsp; * of all JavaBeans&amp;trade;
<i>289</i>&nbsp; * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>290</i>&nbsp; * Please see {@link java.beans.XMLEncoder}.
<i>291</i>&nbsp; *
<i>292</i>&nbsp; * @author  Timothy Prinzing
<i>293</i>&nbsp; * @author Igor Kushnirskiy (printing support)
<i>294</i>&nbsp; * @see Document
<b class="nc"><i>295</i>&nbsp; * @see DocumentEvent</b>
<i>296</i>&nbsp; * @see DocumentListener
<i>297</i>&nbsp; * @see Caret
<i>298</i>&nbsp; * @see CaretEvent
<i>299</i>&nbsp; * @see CaretListener
<i>300</i>&nbsp; * @see TextUI
<i>301</i>&nbsp; * @see View
<i>302</i>&nbsp; * @see ViewFactory
<i>303</i>&nbsp; */
<i>304</i>&nbsp;@JavaBean(defaultProperty = &quot;UI&quot;)
<b class="nc"><i>305</i>&nbsp;@SwingContainer(false)</b>
<i>306</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<b class="nc"><i>307</i>&nbsp;public abstract class JTextComponent extends JComponent implements Scrollable, Accessible</b>
<b class="nc"><i>308</i>&nbsp;{</b>
<b class="nc"><i>309</i>&nbsp;    /**</b>
<b class="nc"><i>310</i>&nbsp;     * Creates a new &lt;code&gt;JTextComponent&lt;/code&gt;.</b>
<b class="nc"><i>311</i>&nbsp;     * Listeners for caret events are established, and the pluggable</b>
<b class="nc"><i>312</i>&nbsp;     * UI installed.  The component is marked as editable.  No layout manager</b>
<b class="nc"><i>313</i>&nbsp;     * is used, because layout is managed by the view subsystem of text.</b>
<b class="nc"><i>314</i>&nbsp;     * The document model is set to &lt;code&gt;null&lt;/code&gt;.</b>
<i>315</i>&nbsp;     */
<i>316</i>&nbsp;    public JTextComponent() {
<i>317</i>&nbsp;        super();
<i>318</i>&nbsp;        // enable InputMethodEvent for on-the-spot pre-editing
<i>319</i>&nbsp;        enableEvents(AWTEvent.KEY_EVENT_MASK | AWTEvent.INPUT_METHOD_EVENT_MASK);
<i>320</i>&nbsp;        caretEvent = new MutableCaretEvent(this);
<i>321</i>&nbsp;        addMouseListener(caretEvent);
<b class="nc"><i>322</i>&nbsp;        addFocusListener(caretEvent);</b>
<i>323</i>&nbsp;        setEditable(true);
<i>324</i>&nbsp;        setDragEnabled(false);
<i>325</i>&nbsp;        setLayout(null); // layout is managed by View hierarchy
<i>326</i>&nbsp;        updateUI();
<i>327</i>&nbsp;    }
<i>328</i>&nbsp;
<i>329</i>&nbsp;    /**
<b class="nc"><i>330</i>&nbsp;     * Fetches the user-interface factory for this text-oriented editor.</b>
<i>331</i>&nbsp;     *
<i>332</i>&nbsp;     * @return the factory
<i>333</i>&nbsp;     */
<i>334</i>&nbsp;    public TextUI getUI() { return (TextUI)ui; }
<i>335</i>&nbsp;
<i>336</i>&nbsp;    /**
<i>337</i>&nbsp;     * Sets the user-interface factory for this text-oriented editor.
<i>338</i>&nbsp;     *
<i>339</i>&nbsp;     * @param ui the factory
<b class="nc"><i>340</i>&nbsp;     */</b>
<b class="nc"><i>341</i>&nbsp;    public void setUI(TextUI ui) {</b>
<i>342</i>&nbsp;        super.setUI(ui);
<i>343</i>&nbsp;    }
<i>344</i>&nbsp;
<i>345</i>&nbsp;    /**
<i>346</i>&nbsp;     * Reloads the pluggable UI.  The key used to fetch the
<i>347</i>&nbsp;     * new interface is &lt;code&gt;getUIClassID()&lt;/code&gt;.  The type of
<i>348</i>&nbsp;     * the UI is &lt;code&gt;TextUI&lt;/code&gt;.  &lt;code&gt;invalidate&lt;/code&gt;
<i>349</i>&nbsp;     * is called after setting the UI.
<i>350</i>&nbsp;     */
<i>351</i>&nbsp;    public void updateUI() {
<b class="nc"><i>352</i>&nbsp;        setUI((TextUI)UIManager.getUI(this));</b>
<i>353</i>&nbsp;        invalidate();
<i>354</i>&nbsp;    }
<i>355</i>&nbsp;
<i>356</i>&nbsp;    /**
<i>357</i>&nbsp;     * Adds a caret listener for notification of any changes
<i>358</i>&nbsp;     * to the caret.
<i>359</i>&nbsp;     *
<i>360</i>&nbsp;     * @param listener the listener to be added
<i>361</i>&nbsp;     * @see javax.swing.event.CaretEvent
<b class="nc"><i>362</i>&nbsp;     */</b>
<i>363</i>&nbsp;    public void addCaretListener(CaretListener listener) {
<i>364</i>&nbsp;        listenerList.add(CaretListener.class, listener);
<i>365</i>&nbsp;    }
<i>366</i>&nbsp;
<i>367</i>&nbsp;    /**
<i>368</i>&nbsp;     * Removes a caret listener.
<i>369</i>&nbsp;     *
<i>370</i>&nbsp;     * @param listener the listener to be removed
<i>371</i>&nbsp;     * @see javax.swing.event.CaretEvent
<i>372</i>&nbsp;     */
<i>373</i>&nbsp;    public void removeCaretListener(CaretListener listener) {
<i>374</i>&nbsp;        listenerList.remove(CaretListener.class, listener);
<i>375</i>&nbsp;    }
<i>376</i>&nbsp;
<i>377</i>&nbsp;    /**
<i>378</i>&nbsp;     * Returns an array of all the caret listeners
<b class="nc"><i>379</i>&nbsp;     * registered on this text component.</b>
<i>380</i>&nbsp;     *
<i>381</i>&nbsp;     * @return all of this component&#39;s &lt;code&gt;CaretListener&lt;/code&gt;s
<i>382</i>&nbsp;     *         or an empty
<i>383</i>&nbsp;     *         array if no caret listeners are currently registered
<i>384</i>&nbsp;     *
<i>385</i>&nbsp;     * @see #addCaretListener
<i>386</i>&nbsp;     * @see #removeCaretListener
<i>387</i>&nbsp;     *
<i>388</i>&nbsp;     * @since 1.4
<i>389</i>&nbsp;     */
<i>390</i>&nbsp;    @BeanProperty(bound = false)
<i>391</i>&nbsp;    public CaretListener[] getCaretListeners() {
<i>392</i>&nbsp;        return listenerList.getListeners(CaretListener.class);
<i>393</i>&nbsp;    }
<b class="nc"><i>394</i>&nbsp;</b>
<i>395</i>&nbsp;    /**
<i>396</i>&nbsp;     * Notifies all listeners that have registered interest for
<b class="nc"><i>397</i>&nbsp;     * notification on this event type.  The event instance</b>
<b class="nc"><i>398</i>&nbsp;     * is lazily created using the parameters passed into</b>
<b class="nc"><i>399</i>&nbsp;     * the fire method.  The listener list is processed in a</b>
<i>400</i>&nbsp;     * last-to-first manner.
<i>401</i>&nbsp;     *
<i>402</i>&nbsp;     * @param e the event
<i>403</i>&nbsp;     * @see EventListenerList
<i>404</i>&nbsp;     */
<i>405</i>&nbsp;    protected void fireCaretUpdate(CaretEvent e) {
<i>406</i>&nbsp;        // Guaranteed to return a non-null array
<i>407</i>&nbsp;        Object[] listeners = listenerList.getListenerList();
<i>408</i>&nbsp;        // Process the listeners last to first, notifying
<i>409</i>&nbsp;        // those that are interested in this event
<i>410</i>&nbsp;        for (int i = listeners.length-2; i&gt;=0; i-=2) {
<i>411</i>&nbsp;            if (listeners[i]==CaretListener.class) {
<i>412</i>&nbsp;                ((CaretListener)listeners[i+1]).caretUpdate(e);
<i>413</i>&nbsp;            }
<i>414</i>&nbsp;        }
<i>415</i>&nbsp;    }
<i>416</i>&nbsp;
<i>417</i>&nbsp;    /**
<b class="nc"><i>418</i>&nbsp;     * Associates the editor with a text document.</b>
<i>419</i>&nbsp;     * The currently registered factory is used to build a view for
<i>420</i>&nbsp;     * the document, which gets displayed by the editor after revalidation.
<i>421</i>&nbsp;     * A PropertyChange event (&quot;document&quot;) is propagated to each listener.
<i>422</i>&nbsp;     *
<i>423</i>&nbsp;     * @param doc  the document to display/edit
<i>424</i>&nbsp;     * @see #getDocument
<b class="nc"><i>425</i>&nbsp;     */</b>
<b class="nc"><i>426</i>&nbsp;    @BeanProperty(expert = true, description</b>
<i>427</i>&nbsp;            = &quot;the text document model&quot;)
<b class="nc"><i>428</i>&nbsp;    public void setDocument(Document doc) {</b>
<b class="nc"><i>429</i>&nbsp;        Document old = model;</b>
<i>430</i>&nbsp;
<i>431</i>&nbsp;        /*
<b class="nc"><i>432</i>&nbsp;         * acquire a read lock on the old model to prevent notification of</b>
<b class="nc"><i>433</i>&nbsp;         * mutations while we disconnecting the old model.</b>
<i>434</i>&nbsp;         */
<b class="nc"><i>435</i>&nbsp;        try {</b>
<i>436</i>&nbsp;            if (old instanceof AbstractDocument) {
<i>437</i>&nbsp;                ((AbstractDocument)old).readLock();
<i>438</i>&nbsp;            }
<b class="nc"><i>439</i>&nbsp;            if (accessibleContext != null) {</b>
<i>440</i>&nbsp;                model.removeDocumentListener(
<i>441</i>&nbsp;                    ((AccessibleJTextComponent)accessibleContext));
<b class="nc"><i>442</i>&nbsp;            }</b>
<b class="nc"><i>443</i>&nbsp;            if (inputMethodRequestsHandler != null) {</b>
<i>444</i>&nbsp;                model.removeDocumentListener((DocumentListener)inputMethodRequestsHandler);
<b class="nc"><i>445</i>&nbsp;            }</b>
<i>446</i>&nbsp;            model = doc;
<b class="nc"><i>447</i>&nbsp;</b>
<b class="nc"><i>448</i>&nbsp;            // Set the document&#39;s run direction property to match the</b>
<i>449</i>&nbsp;            // component&#39;s ComponentOrientation property.
<i>450</i>&nbsp;            Boolean runDir = getComponentOrientation().isLeftToRight()
<i>451</i>&nbsp;                             ? TextAttribute.RUN_DIRECTION_LTR
<b class="nc"><i>452</i>&nbsp;                             : TextAttribute.RUN_DIRECTION_RTL;</b>
<b class="nc"><i>453</i>&nbsp;            if (runDir != doc.getProperty(TextAttribute.RUN_DIRECTION)) {</b>
<b class="nc"><i>454</i>&nbsp;                doc.putProperty(TextAttribute.RUN_DIRECTION, runDir );</b>
<b class="nc"><i>455</i>&nbsp;            }</b>
<i>456</i>&nbsp;            firePropertyChange(&quot;document&quot;, old, doc);
<i>457</i>&nbsp;        } finally {
<b class="nc"><i>458</i>&nbsp;            if (old instanceof AbstractDocument) {</b>
<b class="nc"><i>459</i>&nbsp;                ((AbstractDocument)old).readUnlock();</b>
<i>460</i>&nbsp;            }
<i>461</i>&nbsp;        }
<i>462</i>&nbsp;
<i>463</i>&nbsp;        revalidate();
<i>464</i>&nbsp;        repaint();
<i>465</i>&nbsp;        if (accessibleContext != null) {
<i>466</i>&nbsp;            model.addDocumentListener(
<i>467</i>&nbsp;                ((AccessibleJTextComponent)accessibleContext));
<i>468</i>&nbsp;        }
<i>469</i>&nbsp;        if (inputMethodRequestsHandler != null) {
<i>470</i>&nbsp;            model.addDocumentListener((DocumentListener)inputMethodRequestsHandler);
<i>471</i>&nbsp;        }
<i>472</i>&nbsp;    }
<b class="nc"><i>473</i>&nbsp;</b>
<i>474</i>&nbsp;    /**
<i>475</i>&nbsp;     * Fetches the model associated with the editor.  This is
<i>476</i>&nbsp;     * primarily for the UI to get at the minimal amount of
<i>477</i>&nbsp;     * state required to be a text editor.  Subclasses will
<i>478</i>&nbsp;     * return the actual type of the model which will typically
<i>479</i>&nbsp;     * be something that extends Document.
<b class="nc"><i>480</i>&nbsp;     *</b>
<b class="nc"><i>481</i>&nbsp;     * @return the model</b>
<b class="nc"><i>482</i>&nbsp;     */</b>
<i>483</i>&nbsp;    public Document getDocument() {
<i>484</i>&nbsp;        return model;
<b class="nc"><i>485</i>&nbsp;    }</b>
<i>486</i>&nbsp;
<b class="nc"><i>487</i>&nbsp;    // Override of Component.setComponentOrientation</b>
<i>488</i>&nbsp;    public void setComponentOrientation( ComponentOrientation o ) {
<i>489</i>&nbsp;        // Set the document&#39;s run direction property to match the
<i>490</i>&nbsp;        // ComponentOrientation property.
<i>491</i>&nbsp;        Document doc = getDocument();
<i>492</i>&nbsp;        if( doc !=  null ) {
<i>493</i>&nbsp;            Boolean runDir = o.isLeftToRight()
<i>494</i>&nbsp;                             ? TextAttribute.RUN_DIRECTION_LTR
<i>495</i>&nbsp;                             : TextAttribute.RUN_DIRECTION_RTL;
<i>496</i>&nbsp;            doc.putProperty( TextAttribute.RUN_DIRECTION, runDir );
<i>497</i>&nbsp;        }
<i>498</i>&nbsp;        super.setComponentOrientation( o );
<i>499</i>&nbsp;    }
<b class="nc"><i>500</i>&nbsp;</b>
<i>501</i>&nbsp;    /**
<i>502</i>&nbsp;     * Fetches the command list for the editor.  This is
<i>503</i>&nbsp;     * the list of commands supported by the plugged-in UI
<i>504</i>&nbsp;     * augmented by the collection of commands that the
<i>505</i>&nbsp;     * editor itself supports.  These are useful for binding
<i>506</i>&nbsp;     * to events, such as in a keymap.
<i>507</i>&nbsp;     *
<i>508</i>&nbsp;     * @return the command list
<i>509</i>&nbsp;     */
<i>510</i>&nbsp;    @BeanProperty(bound = false)
<i>511</i>&nbsp;    public Action[] getActions() {
<i>512</i>&nbsp;        return getUI().getEditorKit(this).getActions();
<i>513</i>&nbsp;    }
<i>514</i>&nbsp;
<i>515</i>&nbsp;    /**
<i>516</i>&nbsp;     * Sets margin space between the text component&#39;s border
<i>517</i>&nbsp;     * and its text.  The text component&#39;s default &lt;code&gt;Border&lt;/code&gt;
<i>518</i>&nbsp;     * object will use this value to create the proper margin.
<b class="nc"><i>519</i>&nbsp;     * However, if a non-default border is set on the text component,</b>
<b class="nc"><i>520</i>&nbsp;     * it is that &lt;code&gt;Border&lt;/code&gt; object&#39;s responsibility to create the</b>
<b class="nc"><i>521</i>&nbsp;     * appropriate margin space (else this property will effectively</b>
<b class="nc"><i>522</i>&nbsp;     * be ignored).  This causes a redraw of the component.</b>
<i>523</i>&nbsp;     * A PropertyChange event (&quot;margin&quot;) is sent to all listeners.
<i>524</i>&nbsp;     *
<i>525</i>&nbsp;     * @param m the space between the border and the text
<i>526</i>&nbsp;     */
<i>527</i>&nbsp;    @BeanProperty(description
<i>528</i>&nbsp;            = &quot;desired space between the border and text area&quot;)
<i>529</i>&nbsp;    public void setMargin(Insets m) {
<i>530</i>&nbsp;        Insets old = margin;
<i>531</i>&nbsp;        margin = m;
<b class="nc"><i>532</i>&nbsp;        firePropertyChange(&quot;margin&quot;, old, m);</b>
<i>533</i>&nbsp;        invalidate();
<i>534</i>&nbsp;    }
<i>535</i>&nbsp;
<i>536</i>&nbsp;    /**
<i>537</i>&nbsp;     * Returns the margin between the text component&#39;s border and
<i>538</i>&nbsp;     * its text.
<i>539</i>&nbsp;     *
<i>540</i>&nbsp;     * @return the margin
<i>541</i>&nbsp;     */
<i>542</i>&nbsp;    public Insets getMargin() {
<b class="nc"><i>543</i>&nbsp;        return margin;</b>
<i>544</i>&nbsp;    }
<i>545</i>&nbsp;
<i>546</i>&nbsp;    /**
<i>547</i>&nbsp;     * Sets the &lt;code&gt;NavigationFilter&lt;/code&gt;. &lt;code&gt;NavigationFilter&lt;/code&gt;
<i>548</i>&nbsp;     * is used by &lt;code&gt;DefaultCaret&lt;/code&gt; and the default cursor movement
<i>549</i>&nbsp;     * actions as a way to restrict the cursor movement.
<i>550</i>&nbsp;     * @param filter the filter
<i>551</i>&nbsp;     *
<i>552</i>&nbsp;     * @since 1.4
<i>553</i>&nbsp;     */
<i>554</i>&nbsp;    public void setNavigationFilter(NavigationFilter filter) {
<i>555</i>&nbsp;        navigationFilter = filter;
<b class="nc"><i>556</i>&nbsp;    }</b>
<i>557</i>&nbsp;
<i>558</i>&nbsp;    /**
<i>559</i>&nbsp;     * Returns the &lt;code&gt;NavigationFilter&lt;/code&gt;. &lt;code&gt;NavigationFilter&lt;/code&gt;
<i>560</i>&nbsp;     * is used by &lt;code&gt;DefaultCaret&lt;/code&gt; and the default cursor movement
<i>561</i>&nbsp;     * actions as a way to restrict the cursor movement. A null return value
<i>562</i>&nbsp;     * implies the cursor movement and selection should not be restricted.
<i>563</i>&nbsp;     *
<i>564</i>&nbsp;     * @since 1.4
<i>565</i>&nbsp;     * @return the NavigationFilter
<i>566</i>&nbsp;     */
<b class="nc"><i>567</i>&nbsp;    public NavigationFilter getNavigationFilter() {</b>
<i>568</i>&nbsp;        return navigationFilter;
<i>569</i>&nbsp;    }
<i>570</i>&nbsp;
<i>571</i>&nbsp;    /**
<i>572</i>&nbsp;     * Fetches the caret that allows text-oriented navigation over
<i>573</i>&nbsp;     * the view.
<i>574</i>&nbsp;     *
<i>575</i>&nbsp;     * @return the caret
<i>576</i>&nbsp;     */
<i>577</i>&nbsp;    @Transient
<i>578</i>&nbsp;    public Caret getCaret() {
<i>579</i>&nbsp;        return caret;
<i>580</i>&nbsp;    }
<i>581</i>&nbsp;
<i>582</i>&nbsp;    /**
<i>583</i>&nbsp;     * Sets the caret to be used.  By default this will be set
<b class="nc"><i>584</i>&nbsp;     * by the UI that gets installed.  This can be changed to</b>
<b class="nc"><i>585</i>&nbsp;     * a custom caret if desired.  Setting the caret results in a</b>
<b class="nc"><i>586</i>&nbsp;     * PropertyChange event (&quot;caret&quot;) being fired.</b>
<i>587</i>&nbsp;     *
<b class="nc"><i>588</i>&nbsp;     * @param c the caret</b>
<b class="nc"><i>589</i>&nbsp;     * @see #getCaret</b>
<b class="nc"><i>590</i>&nbsp;     */</b>
<b class="nc"><i>591</i>&nbsp;    @BeanProperty(expert = true, description</b>
<b class="nc"><i>592</i>&nbsp;            = &quot;the caret used to select/navigate&quot;)</b>
<i>593</i>&nbsp;    public void setCaret(Caret c) {
<b class="nc"><i>594</i>&nbsp;        if (caret != null) {</b>
<i>595</i>&nbsp;            caret.removeChangeListener(caretEvent);
<i>596</i>&nbsp;            caret.deinstall(this);
<i>597</i>&nbsp;        }
<i>598</i>&nbsp;        Caret old = caret;
<i>599</i>&nbsp;        caret = c;
<i>600</i>&nbsp;        if (caret != null) {
<i>601</i>&nbsp;            caret.install(this);
<i>602</i>&nbsp;            caret.addChangeListener(caretEvent);
<b class="nc"><i>603</i>&nbsp;        }</b>
<i>604</i>&nbsp;        firePropertyChange(&quot;caret&quot;, old, caret);
<i>605</i>&nbsp;    }
<i>606</i>&nbsp;
<i>607</i>&nbsp;    /**
<i>608</i>&nbsp;     * Fetches the object responsible for making highlights.
<i>609</i>&nbsp;     *
<i>610</i>&nbsp;     * @return the highlighter
<i>611</i>&nbsp;     */
<i>612</i>&nbsp;    public Highlighter getHighlighter() {
<i>613</i>&nbsp;        return highlighter;
<i>614</i>&nbsp;    }
<i>615</i>&nbsp;
<i>616</i>&nbsp;    /**
<i>617</i>&nbsp;     * Sets the highlighter to be used.  By default this will be set
<i>618</i>&nbsp;     * by the UI that gets installed.  This can be changed to
<i>619</i>&nbsp;     * a custom highlighter if desired.  The highlighter can be set to
<i>620</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; to disable it.
<i>621</i>&nbsp;     * A PropertyChange event (&quot;highlighter&quot;) is fired
<b class="nc"><i>622</i>&nbsp;     * when a new highlighter is installed.</b>
<b class="nc"><i>623</i>&nbsp;     *</b>
<i>624</i>&nbsp;     * @param h the highlighter
<b class="nc"><i>625</i>&nbsp;     * @see #getHighlighter</b>
<b class="nc"><i>626</i>&nbsp;     */</b>
<b class="nc"><i>627</i>&nbsp;    @BeanProperty(expert = true, description</b>
<b class="nc"><i>628</i>&nbsp;            = &quot;object responsible for background highlights&quot;)</b>
<i>629</i>&nbsp;    public void setHighlighter(Highlighter h) {
<b class="nc"><i>630</i>&nbsp;        if (highlighter != null) {</b>
<i>631</i>&nbsp;            highlighter.deinstall(this);
<i>632</i>&nbsp;        }
<i>633</i>&nbsp;        Highlighter old = highlighter;
<i>634</i>&nbsp;        highlighter = h;
<i>635</i>&nbsp;        if (highlighter != null) {
<i>636</i>&nbsp;            highlighter.install(this);
<i>637</i>&nbsp;        }
<i>638</i>&nbsp;        firePropertyChange(&quot;highlighter&quot;, old, h);
<i>639</i>&nbsp;    }
<i>640</i>&nbsp;
<i>641</i>&nbsp;    /**
<i>642</i>&nbsp;     * Sets the keymap to use for binding events to
<i>643</i>&nbsp;     * actions.  Setting to &lt;code&gt;null&lt;/code&gt; effectively disables
<i>644</i>&nbsp;     * keyboard input.
<i>645</i>&nbsp;     * A PropertyChange event (&quot;keymap&quot;) is fired when a new keymap
<i>646</i>&nbsp;     * is installed.
<b class="nc"><i>647</i>&nbsp;     *</b>
<b class="nc"><i>648</i>&nbsp;     * @param map the keymap</b>
<b class="nc"><i>649</i>&nbsp;     * @see #getKeymap</b>
<b class="nc"><i>650</i>&nbsp;     */</b>
<i>651</i>&nbsp;    @BeanProperty(description
<i>652</i>&nbsp;            = &quot;set of key event to action bindings to use&quot;)
<i>653</i>&nbsp;    public void setKeymap(Keymap map) {
<i>654</i>&nbsp;        Keymap old = keymap;
<i>655</i>&nbsp;        keymap = map;
<i>656</i>&nbsp;        firePropertyChange(&quot;keymap&quot;, old, keymap);
<i>657</i>&nbsp;        updateInputMap(old, map);
<i>658</i>&nbsp;    }
<i>659</i>&nbsp;
<i>660</i>&nbsp;    /**
<i>661</i>&nbsp;     * Turns on or off automatic drag handling. In order to enable automatic
<i>662</i>&nbsp;     * drag handling, this property should be set to {@code true}, and the
<i>663</i>&nbsp;     * component&#39;s {@code TransferHandler} needs to be {@code non-null}.
<i>664</i>&nbsp;     * The default value of the {@code dragEnabled} property is {@code false}.
<i>665</i>&nbsp;     * &lt;p&gt;
<i>666</i>&nbsp;     * The job of honoring this property, and recognizing a user drag gesture,
<i>667</i>&nbsp;     * lies with the look and feel implementation, and in particular, the component&#39;s
<i>668</i>&nbsp;     * {@code TextUI}. When automatic drag handling is enabled, most look and
<i>669</i>&nbsp;     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
<i>670</i>&nbsp;     * drag and drop operation whenever the user presses the mouse button over
<i>671</i>&nbsp;     * a selection and then moves the mouse a few pixels. Setting this property to
<i>672</i>&nbsp;     * {@code true} can therefore have a subtle effect on how selections behave.
<i>673</i>&nbsp;     * &lt;p&gt;
<i>674</i>&nbsp;     * If a look and feel is used that ignores this property, you can still
<i>675</i>&nbsp;     * begin a drag and drop operation by calling {@code exportAsDrag} on the
<i>676</i>&nbsp;     * component&#39;s {@code TransferHandler}.
<i>677</i>&nbsp;     *
<i>678</i>&nbsp;     * @param b whether or not to enable automatic drag handling
<i>679</i>&nbsp;     * @exception HeadlessException if
<i>680</i>&nbsp;     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
<i>681</i>&nbsp;     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
<i>682</i>&nbsp;     *            returns &lt;code&gt;true&lt;/code&gt;
<i>683</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless
<i>684</i>&nbsp;     * @see #getDragEnabled
<i>685</i>&nbsp;     * @see #setTransferHandler
<i>686</i>&nbsp;     * @see TransferHandler
<b class="nc"><i>687</i>&nbsp;     * @since 1.4</b>
<b class="nc"><i>688</i>&nbsp;     */</b>
<i>689</i>&nbsp;    @BeanProperty(bound = false, description
<b class="nc"><i>690</i>&nbsp;            = &quot;determines whether automatic drag handling is enabled&quot;)</b>
<i>691</i>&nbsp;    public void setDragEnabled(boolean b) {
<i>692</i>&nbsp;        checkDragEnabled(b);
<i>693</i>&nbsp;        dragEnabled = b;
<i>694</i>&nbsp;    }
<i>695</i>&nbsp;
<i>696</i>&nbsp;    private static void checkDragEnabled(boolean b) {
<i>697</i>&nbsp;        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {
<i>698</i>&nbsp;            throw new HeadlessException();
<i>699</i>&nbsp;        }
<i>700</i>&nbsp;    }
<b class="nc"><i>701</i>&nbsp;</b>
<i>702</i>&nbsp;    /**
<i>703</i>&nbsp;     * Returns whether or not automatic drag handling is enabled.
<i>704</i>&nbsp;     *
<i>705</i>&nbsp;     * @return the value of the {@code dragEnabled} property
<i>706</i>&nbsp;     * @see #setDragEnabled
<i>707</i>&nbsp;     * @since 1.4
<i>708</i>&nbsp;     */
<i>709</i>&nbsp;    public boolean getDragEnabled() {
<i>710</i>&nbsp;        return dragEnabled;
<i>711</i>&nbsp;    }
<i>712</i>&nbsp;
<i>713</i>&nbsp;    /**
<i>714</i>&nbsp;     * Sets the drop mode for this component. For backward compatibility,
<i>715</i>&nbsp;     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
<i>716</i>&nbsp;     * Usage of &lt;code&gt;DropMode.INSERT&lt;/code&gt; is recommended, however,
<i>717</i>&nbsp;     * for an improved user experience. It offers similar behavior of dropping
<i>718</i>&nbsp;     * between text locations, but does so without affecting the actual text
<i>719</i>&nbsp;     * selection and caret location.
<i>720</i>&nbsp;     * &lt;p&gt;
<i>721</i>&nbsp;     * &lt;code&gt;JTextComponents&lt;/code&gt; support the following drop modes:
<i>722</i>&nbsp;     * &lt;ul&gt;
<i>723</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
<i>724</i>&nbsp;     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
<i>725</i>&nbsp;     * &lt;/ul&gt;
<i>726</i>&nbsp;     * &lt;p&gt;
<i>727</i>&nbsp;     * The drop mode is only meaningful if this component has a
<i>728</i>&nbsp;     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
<i>729</i>&nbsp;     *
<i>730</i>&nbsp;     * @param dropMode the drop mode to use
<b class="nc"><i>731</i>&nbsp;     * @throws IllegalArgumentException if the drop mode is unsupported</b>
<b class="nc"><i>732</i>&nbsp;     *         or &lt;code&gt;null&lt;/code&gt;</b>
<i>733</i>&nbsp;     * @see #getDropMode
<i>734</i>&nbsp;     * @see #getDropLocation
<b class="nc"><i>735</i>&nbsp;     * @see #setTransferHandler</b>
<i>736</i>&nbsp;     * @see javax.swing.TransferHandler
<i>737</i>&nbsp;     * @since 1.6
<i>738</i>&nbsp;     */
<i>739</i>&nbsp;    public final void setDropMode(DropMode dropMode) {
<b class="nc"><i>740</i>&nbsp;        checkDropMode(dropMode);</b>
<i>741</i>&nbsp;        this.dropMode = dropMode;
<i>742</i>&nbsp;    }
<i>743</i>&nbsp;
<i>744</i>&nbsp;    private static void checkDropMode(DropMode dropMode) {
<i>745</i>&nbsp;        if (dropMode != null) {
<i>746</i>&nbsp;            switch (dropMode) {
<i>747</i>&nbsp;                case USE_SELECTION:
<i>748</i>&nbsp;                case INSERT:
<i>749</i>&nbsp;                    return;
<i>750</i>&nbsp;            }
<b class="nc"><i>751</i>&nbsp;        }</b>
<i>752</i>&nbsp;
<i>753</i>&nbsp;        throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for text&quot;);
<i>754</i>&nbsp;    }
<b class="nc"><i>755</i>&nbsp;</b>
<b class="nc"><i>756</i>&nbsp;    /**</b>
<i>757</i>&nbsp;     * Returns the drop mode for this component.
<i>758</i>&nbsp;     *
<i>759</i>&nbsp;     * @return the drop mode for this component
<b class="nc"><i>760</i>&nbsp;     * @see #setDropMode</b>
<i>761</i>&nbsp;     * @since 1.6
<i>762</i>&nbsp;     */
<i>763</i>&nbsp;    public final DropMode getDropMode() {
<i>764</i>&nbsp;        return dropMode;
<i>765</i>&nbsp;    }
<b class="nc"><i>766</i>&nbsp;</b>
<i>767</i>&nbsp;    static {
<i>768</i>&nbsp;        SwingAccessor.setJTextComponentAccessor(
<i>769</i>&nbsp;            new SwingAccessor.JTextComponentAccessor() {
<i>770</i>&nbsp;                public TransferHandler.DropLocation dropLocationForPoint(JTextComponent textComp,
<i>771</i>&nbsp;                                                                         Point p)
<i>772</i>&nbsp;                {
<i>773</i>&nbsp;                    return textComp.dropLocationForPoint(p);
<i>774</i>&nbsp;                }
<i>775</i>&nbsp;                public Object setDropLocation(JTextComponent textComp,
<i>776</i>&nbsp;                                              TransferHandler.DropLocation location,
<i>777</i>&nbsp;                                              Object state, boolean forDrop)
<i>778</i>&nbsp;                {
<i>779</i>&nbsp;                    return textComp.setDropLocation(location, state, forDrop);
<i>780</i>&nbsp;                }
<i>781</i>&nbsp;            });
<i>782</i>&nbsp;    }
<i>783</i>&nbsp;
<i>784</i>&nbsp;
<i>785</i>&nbsp;    /**
<b class="nc"><i>786</i>&nbsp;     * Calculates a drop location in this component, representing where a</b>
<b class="nc"><i>787</i>&nbsp;     * drop at the given point should insert data.</b>
<i>788</i>&nbsp;     * &lt;p&gt;
<i>789</i>&nbsp;     * Note: This method is meant to override
<i>790</i>&nbsp;     * &lt;code&gt;JComponent.dropLocationForPoint()&lt;/code&gt;, which is package-private
<b class="nc"><i>791</i>&nbsp;     * in javax.swing. &lt;code&gt;TransferHandler&lt;/code&gt; will detect text components</b>
<b class="nc"><i>792</i>&nbsp;     * and call this method instead via reflection. It&#39;s name should therefore</b>
<i>793</i>&nbsp;     * not be changed.
<i>794</i>&nbsp;     *
<b class="nc"><i>795</i>&nbsp;     * @param p the point to calculate a drop location for</b>
<i>796</i>&nbsp;     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
<i>797</i>&nbsp;     */
<i>798</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>799</i>&nbsp;    DropLocation dropLocationForPoint(Point p) {
<i>800</i>&nbsp;        Position.Bias[] bias = new Position.Bias[1];
<i>801</i>&nbsp;        int index = getUI().viewToModel(this, p, bias);
<i>802</i>&nbsp;
<i>803</i>&nbsp;        // viewToModel currently returns null for some HTML content
<i>804</i>&nbsp;        // when the point is within the component&#39;s top inset
<i>805</i>&nbsp;        if (bias[0] == null) {
<i>806</i>&nbsp;            bias[0] = Position.Bias.Forward;
<i>807</i>&nbsp;        }
<i>808</i>&nbsp;
<i>809</i>&nbsp;        return new DropLocation(p, index, bias[0]);
<i>810</i>&nbsp;    }
<i>811</i>&nbsp;
<i>812</i>&nbsp;    /**
<i>813</i>&nbsp;     * Called to set or clear the drop location during a DnD operation.
<i>814</i>&nbsp;     * In some cases, the component may need to use it&#39;s internal selection
<i>815</i>&nbsp;     * temporarily to indicate the drop location. To help facilitate this,
<i>816</i>&nbsp;     * this method returns and accepts as a parameter a state object.
<i>817</i>&nbsp;     * This state object can be used to store, and later restore, the selection
<i>818</i>&nbsp;     * state. Whatever this method returns will be passed back to it in
<i>819</i>&nbsp;     * future calls, as the state parameter. If it wants the DnD system to
<i>820</i>&nbsp;     * continue storing the same state, it must pass it back every time.
<i>821</i>&nbsp;     * Here&#39;s how this is used:
<i>822</i>&nbsp;     * &lt;p&gt;
<i>823</i>&nbsp;     * Let&#39;s say that on the first call to this method the component decides
<i>824</i>&nbsp;     * to save some state (because it is about to use the selection to show
<i>825</i>&nbsp;     * a drop index). It can return a state object to the caller encapsulating
<i>826</i>&nbsp;     * any saved selection state. On a second call, let&#39;s say the drop location
<i>827</i>&nbsp;     * is being changed to something else. The component doesn&#39;t need to
<i>828</i>&nbsp;     * restore anything yet, so it simply passes back the same state object
<i>829</i>&nbsp;     * to have the DnD system continue storing it. Finally, let&#39;s say this
<i>830</i>&nbsp;     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
<i>831</i>&nbsp;     * is finished with this component for now, meaning it should restore
<i>832</i>&nbsp;     * state. At this point, it can use the state parameter to restore
<i>833</i>&nbsp;     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there&#39;s
<i>834</i>&nbsp;     * no longer anything to store.
<i>835</i>&nbsp;     * &lt;p&gt;
<i>836</i>&nbsp;     * Note: This method is meant to override
<i>837</i>&nbsp;     * &lt;code&gt;JComponent.setDropLocation()&lt;/code&gt;, which is package-private
<i>838</i>&nbsp;     * in javax.swing. &lt;code&gt;TransferHandler&lt;/code&gt; will detect text components
<i>839</i>&nbsp;     * and call this method instead via reflection. It&#39;s name should therefore
<i>840</i>&nbsp;     * not be changed.
<b class="nc"><i>841</i>&nbsp;     *</b>
<b class="nc"><i>842</i>&nbsp;     * @param location the drop location (as calculated by</b>
<i>843</i>&nbsp;     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>844</i>&nbsp;     *        if there&#39;s no longer a valid drop location</b>
<b class="nc"><i>845</i>&nbsp;     * @param state the state object saved earlier for this component,</b>
<b class="nc"><i>846</i>&nbsp;     *        or &lt;code&gt;null&lt;/code&gt;</b>
<i>847</i>&nbsp;     * @param forDrop whether or not the method is being called because an
<i>848</i>&nbsp;     *        actual drop occurred
<i>849</i>&nbsp;     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
<i>850</i>&nbsp;     */
<i>851</i>&nbsp;    Object setDropLocation(TransferHandler.DropLocation location,
<i>852</i>&nbsp;                           Object state,
<i>853</i>&nbsp;                           boolean forDrop) {
<i>854</i>&nbsp;
<i>855</i>&nbsp;        Object retVal = null;
<i>856</i>&nbsp;        DropLocation textLocation = (DropLocation)location;
<i>857</i>&nbsp;
<i>858</i>&nbsp;        if (dropMode == DropMode.USE_SELECTION) {
<i>859</i>&nbsp;            if (textLocation == null) {
<b class="nc"><i>860</i>&nbsp;                if (state != null) {</b>
<i>861</i>&nbsp;                    /*
<b class="nc"><i>862</i>&nbsp;                     * This object represents the state saved earlier.</b>
<b class="nc"><i>863</i>&nbsp;                     *     If the caret is a DefaultCaret it will be</b>
<b class="nc"><i>864</i>&nbsp;                     *     an Object array containing, in order:</b>
<i>865</i>&nbsp;                     *         - the saved caret mark (Integer)
<b class="nc"><i>866</i>&nbsp;                     *         - the saved caret dot (Integer)</b>
<i>867</i>&nbsp;                     *         - the saved caret visibility (Boolean)
<i>868</i>&nbsp;                     *         - the saved mark bias (Position.Bias)
<b class="nc"><i>869</i>&nbsp;                     *         - the saved dot bias (Position.Bias)</b>
<b class="nc"><i>870</i>&nbsp;                     *     If the caret is not a DefaultCaret it will</b>
<i>871</i>&nbsp;                     *     be similar, but will not contain the dot
<i>872</i>&nbsp;                     *     or mark bias.
<i>873</i>&nbsp;                     */
<b class="nc"><i>874</i>&nbsp;                    Object[] vals = (Object[])state;</b>
<b class="nc"><i>875</i>&nbsp;</b>
<i>876</i>&nbsp;                    if (!forDrop) {
<b class="nc"><i>877</i>&nbsp;                        if (caret instanceof DefaultCaret) {</b>
<i>878</i>&nbsp;                            ((DefaultCaret)caret).setDot(((Integer)vals[0]).intValue(),
<i>879</i>&nbsp;                                                         (Position.Bias)vals[3]);
<b class="nc"><i>880</i>&nbsp;                            ((DefaultCaret)caret).moveDot(((Integer)vals[1]).intValue(),</b>
<b class="nc"><i>881</i>&nbsp;                                                         (Position.Bias)vals[4]);</b>
<b class="nc"><i>882</i>&nbsp;                        } else {</b>
<b class="nc"><i>883</i>&nbsp;                            caret.setDot(((Integer)vals[0]).intValue());</b>
<b class="nc"><i>884</i>&nbsp;                            caret.moveDot(((Integer)vals[1]).intValue());</b>
<b class="nc"><i>885</i>&nbsp;                        }</b>
<b class="nc"><i>886</i>&nbsp;                    }</b>
<b class="nc"><i>887</i>&nbsp;</b>
<b class="nc"><i>888</i>&nbsp;                    caret.setVisible(((Boolean)vals[2]).booleanValue());</b>
<b class="nc"><i>889</i>&nbsp;                }</b>
<b class="nc"><i>890</i>&nbsp;            } else {</b>
<b class="nc"><i>891</i>&nbsp;                if (dropLocation == null) {</b>
<b class="nc"><i>892</i>&nbsp;                    boolean visible;</b>
<i>893</i>&nbsp;
<i>894</i>&nbsp;                    if (caret instanceof DefaultCaret) {
<b class="nc"><i>895</i>&nbsp;                        DefaultCaret dc = (DefaultCaret)caret;</b>
<b class="nc"><i>896</i>&nbsp;                        visible = dc.isActive();</b>
<b class="nc"><i>897</i>&nbsp;                        retVal = new Object[] {Integer.valueOf(dc.getMark()),</b>
<i>898</i>&nbsp;                                               Integer.valueOf(dc.getDot()),
<i>899</i>&nbsp;                                               Boolean.valueOf(visible),
<b class="nc"><i>900</i>&nbsp;                                               dc.getMarkBias(),</b>
<b class="nc"><i>901</i>&nbsp;                                               dc.getDotBias()};</b>
<i>902</i>&nbsp;                    } else {
<b class="nc"><i>903</i>&nbsp;                        visible = caret.isVisible();</b>
<i>904</i>&nbsp;                        retVal = new Object[] {Integer.valueOf(caret.getMark()),
<i>905</i>&nbsp;                                               Integer.valueOf(caret.getDot()),
<i>906</i>&nbsp;                                               Boolean.valueOf(visible)};
<b class="nc"><i>907</i>&nbsp;                    }</b>
<b class="nc"><i>908</i>&nbsp;</b>
<b class="nc"><i>909</i>&nbsp;                    caret.setVisible(true);</b>
<i>910</i>&nbsp;                } else {
<i>911</i>&nbsp;                    retVal = state;
<b class="nc"><i>912</i>&nbsp;                }</b>
<b class="nc"><i>913</i>&nbsp;</b>
<b class="nc"><i>914</i>&nbsp;                if (caret instanceof DefaultCaret) {</b>
<b class="nc"><i>915</i>&nbsp;                    ((DefaultCaret)caret).setDot(textLocation.getIndex(), textLocation.getBias());</b>
<b class="nc"><i>916</i>&nbsp;                } else {</b>
<b class="nc"><i>917</i>&nbsp;                    caret.setDot(textLocation.getIndex());</b>
<b class="nc"><i>918</i>&nbsp;                }</b>
<b class="nc"><i>919</i>&nbsp;            }</b>
<i>920</i>&nbsp;        } else {
<i>921</i>&nbsp;            if (textLocation == null) {
<i>922</i>&nbsp;                if (state != null) {
<i>923</i>&nbsp;                    caret.setVisible(((Boolean)state).booleanValue());
<b class="nc"><i>924</i>&nbsp;                }</b>
<b class="nc"><i>925</i>&nbsp;            } else {</b>
<b class="nc"><i>926</i>&nbsp;                if (dropLocation == null) {</b>
<i>927</i>&nbsp;                    boolean visible = caret instanceof DefaultCaret
<b class="nc"><i>928</i>&nbsp;                                      ? ((DefaultCaret)caret).isActive()</b>
<i>929</i>&nbsp;                                      : caret.isVisible();
<i>930</i>&nbsp;                    retVal = Boolean.valueOf(visible);
<i>931</i>&nbsp;                    caret.setVisible(false);
<i>932</i>&nbsp;                } else {
<i>933</i>&nbsp;                    retVal = state;
<i>934</i>&nbsp;                }
<i>935</i>&nbsp;            }
<i>936</i>&nbsp;        }
<i>937</i>&nbsp;
<i>938</i>&nbsp;        DropLocation old = dropLocation;
<i>939</i>&nbsp;        dropLocation = textLocation;
<i>940</i>&nbsp;        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);
<i>941</i>&nbsp;
<i>942</i>&nbsp;        return retVal;
<i>943</i>&nbsp;    }
<i>944</i>&nbsp;
<i>945</i>&nbsp;    /**
<i>946</i>&nbsp;     * Returns the location that this component should visually indicate
<i>947</i>&nbsp;     * as the drop location during a DnD operation over the component,
<i>948</i>&nbsp;     * or {@code null} if no location is to currently be shown.
<i>949</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>950</i>&nbsp;     * This method is not meant for querying the drop location</b>
<i>951</i>&nbsp;     * from a {@code TransferHandler}, as the drop location is only
<i>952</i>&nbsp;     * set after the {@code TransferHandler}&#39;s &lt;code&gt;canImport&lt;/code&gt;
<i>953</i>&nbsp;     * has returned and has allowed for the location to be shown.
<i>954</i>&nbsp;     * &lt;p&gt;
<i>955</i>&nbsp;     * When this property changes, a property change event with
<i>956</i>&nbsp;     * name &quot;dropLocation&quot; is fired by the component.
<i>957</i>&nbsp;     *
<i>958</i>&nbsp;     * @return the drop location
<i>959</i>&nbsp;     * @see #setDropMode
<i>960</i>&nbsp;     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
<i>961</i>&nbsp;     * @since 1.6
<b class="nc"><i>962</i>&nbsp;     */</b>
<b class="nc"><i>963</i>&nbsp;    @BeanProperty(bound = false)</b>
<b class="nc"><i>964</i>&nbsp;    public final DropLocation getDropLocation() {</b>
<b class="nc"><i>965</i>&nbsp;        return dropLocation;</b>
<b class="nc"><i>966</i>&nbsp;    }</b>
<i>967</i>&nbsp;
<b class="nc"><i>968</i>&nbsp;</b>
<i>969</i>&nbsp;    /**
<i>970</i>&nbsp;     * Updates the &lt;code&gt;InputMap&lt;/code&gt;s in response to a
<b class="nc"><i>971</i>&nbsp;     * &lt;code&gt;Keymap&lt;/code&gt; change.</b>
<b class="nc"><i>972</i>&nbsp;     * @param oldKm  the old &lt;code&gt;Keymap&lt;/code&gt;</b>
<b class="nc"><i>973</i>&nbsp;     * @param newKm  the new &lt;code&gt;Keymap&lt;/code&gt;</b>
<i>974</i>&nbsp;     */
<i>975</i>&nbsp;    void updateInputMap(Keymap oldKm, Keymap newKm) {
<b class="nc"><i>976</i>&nbsp;        // Locate the current KeymapWrapper.</b>
<i>977</i>&nbsp;        InputMap km = getInputMap(JComponent.WHEN_FOCUSED);
<i>978</i>&nbsp;        InputMap last = km;
<i>979</i>&nbsp;        while (km != null &amp;&amp; !(km instanceof KeymapWrapper)) {
<b class="nc"><i>980</i>&nbsp;            last = km;</b>
<b class="nc"><i>981</i>&nbsp;            km = km.getParent();</b>
<b class="nc"><i>982</i>&nbsp;        }</b>
<b class="nc"><i>983</i>&nbsp;        if (km != null) {</b>
<i>984</i>&nbsp;            // Found it, tweak the InputMap that points to it, as well
<b class="nc"><i>985</i>&nbsp;            // as anything it points to.</b>
<i>986</i>&nbsp;            if (newKm == null) {
<b class="nc"><i>987</i>&nbsp;                if (last != km) {</b>
<b class="nc"><i>988</i>&nbsp;                    last.setParent(km.getParent());</b>
<b class="nc"><i>989</i>&nbsp;                }</b>
<i>990</i>&nbsp;                else {
<i>991</i>&nbsp;                    last.setParent(null);
<b class="nc"><i>992</i>&nbsp;                }</b>
<b class="nc"><i>993</i>&nbsp;            }</b>
<b class="nc"><i>994</i>&nbsp;            else {</b>
<i>995</i>&nbsp;                InputMap newKM = new KeymapWrapper(newKm);
<i>996</i>&nbsp;                last.setParent(newKM);
<i>997</i>&nbsp;                if (last != km) {
<i>998</i>&nbsp;                    newKM.setParent(km.getParent());
<b class="nc"><i>999</i>&nbsp;                }</b>
<b class="nc"><i>1000</i>&nbsp;            }</b>
<b class="nc"><i>1001</i>&nbsp;        }</b>
<b class="nc"><i>1002</i>&nbsp;        else if (newKm != null) {</b>
<b class="nc"><i>1003</i>&nbsp;            km = getInputMap(JComponent.WHEN_FOCUSED);</b>
<i>1004</i>&nbsp;            if (km != null) {
<b class="nc"><i>1005</i>&nbsp;                // Couldn&#39;t find it.</b>
<i>1006</i>&nbsp;                // Set the parent of WHEN_FOCUSED InputMap to be the new one.
<i>1007</i>&nbsp;                InputMap newKM = new KeymapWrapper(newKm);
<b class="nc"><i>1008</i>&nbsp;                newKM.setParent(km.getParent());</b>
<b class="nc"><i>1009</i>&nbsp;                km.setParent(newKM);</b>
<b class="nc"><i>1010</i>&nbsp;            }</b>
<i>1011</i>&nbsp;        }
<i>1012</i>&nbsp;
<b class="nc"><i>1013</i>&nbsp;        // Do the same thing with the ActionMap</b>
<i>1014</i>&nbsp;        ActionMap am = getActionMap();
<i>1015</i>&nbsp;        ActionMap lastAM = am;
<i>1016</i>&nbsp;        while (am != null &amp;&amp; !(am instanceof KeymapActionMap)) {
<b class="nc"><i>1017</i>&nbsp;            lastAM = am;</b>
<b class="nc"><i>1018</i>&nbsp;            am = am.getParent();</b>
<b class="nc"><i>1019</i>&nbsp;        }</b>
<b class="nc"><i>1020</i>&nbsp;        if (am != null) {</b>
<i>1021</i>&nbsp;            // Found it, tweak the Actionap that points to it, as well
<b class="nc"><i>1022</i>&nbsp;            // as anything it points to.</b>
<i>1023</i>&nbsp;            if (newKm == null) {
<b class="nc"><i>1024</i>&nbsp;                if (lastAM != am) {</b>
<b class="nc"><i>1025</i>&nbsp;                    lastAM.setParent(am.getParent());</b>
<b class="nc"><i>1026</i>&nbsp;                }</b>
<i>1027</i>&nbsp;                else {
<i>1028</i>&nbsp;                    lastAM.setParent(null);
<b class="nc"><i>1029</i>&nbsp;                }</b>
<b class="nc"><i>1030</i>&nbsp;            }</b>
<b class="nc"><i>1031</i>&nbsp;            else {</b>
<i>1032</i>&nbsp;                ActionMap newAM = new KeymapActionMap(newKm);
<i>1033</i>&nbsp;                lastAM.setParent(newAM);
<i>1034</i>&nbsp;                if (lastAM != am) {
<i>1035</i>&nbsp;                    newAM.setParent(am.getParent());
<i>1036</i>&nbsp;                }
<i>1037</i>&nbsp;            }
<i>1038</i>&nbsp;        }
<i>1039</i>&nbsp;        else if (newKm != null) {
<i>1040</i>&nbsp;            am = getActionMap();
<i>1041</i>&nbsp;            if (am != null) {
<i>1042</i>&nbsp;                // Couldn&#39;t find it.
<b class="nc"><i>1043</i>&nbsp;                // Set the parent of ActionMap to be the new one.</b>
<i>1044</i>&nbsp;                ActionMap newAM = new KeymapActionMap(newKm);
<i>1045</i>&nbsp;                newAM.setParent(am.getParent());
<i>1046</i>&nbsp;                am.setParent(newAM);
<i>1047</i>&nbsp;            }
<i>1048</i>&nbsp;        }
<i>1049</i>&nbsp;    }
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;    /**
<i>1052</i>&nbsp;     * Fetches the keymap currently active in this text
<i>1053</i>&nbsp;     * component.
<i>1054</i>&nbsp;     *
<i>1055</i>&nbsp;     * @return the keymap
<i>1056</i>&nbsp;     */
<i>1057</i>&nbsp;    public Keymap getKeymap() {
<i>1058</i>&nbsp;        return keymap;
<i>1059</i>&nbsp;    }
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;    /**
<b class="nc"><i>1062</i>&nbsp;     * Adds a new keymap into the keymap hierarchy.  Keymap bindings</b>
<b class="nc"><i>1063</i>&nbsp;     * resolve from bottom up so an attribute specified in a child</b>
<i>1064</i>&nbsp;     * will override an attribute specified in the parent.
<b class="nc"><i>1065</i>&nbsp;     *</b>
<i>1066</i>&nbsp;     * @param nm   the name of the keymap (must be unique within the
<b class="nc"><i>1067</i>&nbsp;     *   collection of named keymaps in the document); the name may</b>
<i>1068</i>&nbsp;     *   be &lt;code&gt;null&lt;/code&gt; if the keymap is unnamed,
<i>1069</i>&nbsp;     *   but the caller is responsible for managing the reference
<i>1070</i>&nbsp;     *   returned as an unnamed keymap can&#39;t
<i>1071</i>&nbsp;     *   be fetched by name
<i>1072</i>&nbsp;     * @param parent the parent keymap; this may be &lt;code&gt;null&lt;/code&gt; if
<i>1073</i>&nbsp;     *   unspecified bindings need not be resolved in some other keymap
<i>1074</i>&nbsp;     * @return the keymap
<i>1075</i>&nbsp;     */
<i>1076</i>&nbsp;    public static Keymap addKeymap(String nm, Keymap parent) {
<i>1077</i>&nbsp;        Keymap map = new DefaultKeymap(nm, parent);
<b class="nc"><i>1078</i>&nbsp;        if (nm != null) {</b>
<i>1079</i>&nbsp;            // add a named keymap, a class of bindings
<i>1080</i>&nbsp;            getKeymapTable().put(nm, map);
<i>1081</i>&nbsp;        }
<i>1082</i>&nbsp;        return map;
<i>1083</i>&nbsp;    }
<i>1084</i>&nbsp;
<i>1085</i>&nbsp;    /**
<i>1086</i>&nbsp;     * Removes a named keymap previously added to the document.  Keymaps
<i>1087</i>&nbsp;     * with &lt;code&gt;null&lt;/code&gt; names may not be removed in this way.
<i>1088</i>&nbsp;     *
<b class="nc"><i>1089</i>&nbsp;     * @param nm  the name of the keymap to remove</b>
<i>1090</i>&nbsp;     * @return the keymap that was removed
<i>1091</i>&nbsp;     */
<i>1092</i>&nbsp;    public static Keymap removeKeymap(String nm) {
<b class="nc"><i>1093</i>&nbsp;        return getKeymapTable().remove(nm);</b>
<b class="nc"><i>1094</i>&nbsp;    }</b>
<b class="nc"><i>1095</i>&nbsp;</b>
<b class="nc"><i>1096</i>&nbsp;    /**</b>
<b class="nc"><i>1097</i>&nbsp;     * Fetches a named keymap previously added to the document.</b>
<b class="nc"><i>1098</i>&nbsp;     * This does not work with &lt;code&gt;null&lt;/code&gt;-named keymaps.</b>
<b class="nc"><i>1099</i>&nbsp;     *</b>
<i>1100</i>&nbsp;     * @param nm  the name of the keymap
<b class="nc"><i>1101</i>&nbsp;     * @return the keymap</b>
<b class="nc"><i>1102</i>&nbsp;     */</b>
<i>1103</i>&nbsp;    public static Keymap getKeymap(String nm) {
<i>1104</i>&nbsp;        return getKeymapTable().get(nm);
<b class="nc"><i>1105</i>&nbsp;    }</b>
<b class="nc"><i>1106</i>&nbsp;</b>
<i>1107</i>&nbsp;    private static HashMap&lt;String,Keymap&gt; getKeymapTable() {
<i>1108</i>&nbsp;        synchronized (KEYMAP_TABLE) {
<i>1109</i>&nbsp;            AppContext appContext = AppContext.getAppContext();
<i>1110</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>1111</i>&nbsp;            HashMap&lt;String,Keymap&gt; keymapTable =
<i>1112</i>&nbsp;                (HashMap&lt;String,Keymap&gt;)appContext.get(KEYMAP_TABLE);
<i>1113</i>&nbsp;            if (keymapTable == null) {
<i>1114</i>&nbsp;                keymapTable = new HashMap&lt;String,Keymap&gt;(17);
<i>1115</i>&nbsp;                appContext.put(KEYMAP_TABLE, keymapTable);
<i>1116</i>&nbsp;                //initialize default keymap
<i>1117</i>&nbsp;                Keymap binding = addKeymap(DEFAULT_KEYMAP, null);
<i>1118</i>&nbsp;                binding.setDefaultAction(new
<i>1119</i>&nbsp;                                         DefaultEditorKit.DefaultKeyTypedAction());
<i>1120</i>&nbsp;            }
<i>1121</i>&nbsp;            return keymapTable;
<i>1122</i>&nbsp;        }
<i>1123</i>&nbsp;    }
<i>1124</i>&nbsp;
<i>1125</i>&nbsp;    /**
<i>1126</i>&nbsp;     * Binding record for creating key bindings.
<i>1127</i>&nbsp;     * &lt;p&gt;
<i>1128</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>1129</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>1130</i>&nbsp;     * future Swing releases. The current serialization support is
<i>1131</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>1132</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>1133</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>1134</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>1135</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<i>1136</i>&nbsp;     */
<i>1137</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>1138</i>&nbsp;    public static class KeyBinding {
<b class="nc"><i>1139</i>&nbsp;</b>
<b class="nc"><i>1140</i>&nbsp;        /**</b>
<b class="nc"><i>1141</i>&nbsp;         * The key.</b>
<i>1142</i>&nbsp;         */
<i>1143</i>&nbsp;        public KeyStroke key;
<i>1144</i>&nbsp;
<i>1145</i>&nbsp;        /**
<i>1146</i>&nbsp;         * The name of the action for the key.
<i>1147</i>&nbsp;         */
<i>1148</i>&nbsp;        public String actionName;
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;        /**
<i>1151</i>&nbsp;         * Creates a new key binding.
<i>1152</i>&nbsp;         *
<i>1153</i>&nbsp;         * @param key the key
<i>1154</i>&nbsp;         * @param actionName the name of the action for the key
<i>1155</i>&nbsp;         */
<i>1156</i>&nbsp;        public KeyBinding(KeyStroke key, String actionName) {
<i>1157</i>&nbsp;            this.key = key;
<i>1158</i>&nbsp;            this.actionName = actionName;
<i>1159</i>&nbsp;        }
<i>1160</i>&nbsp;    }
<i>1161</i>&nbsp;
<i>1162</i>&nbsp;    /**
<i>1163</i>&nbsp;     * &lt;p&gt;
<i>1164</i>&nbsp;     * Loads a keymap with a bunch of
<i>1165</i>&nbsp;     * bindings.  This can be used to take a static table of
<i>1166</i>&nbsp;     * definitions and load them into some keymap.  The following
<i>1167</i>&nbsp;     * example illustrates an example of binding some keys to
<i>1168</i>&nbsp;     * the cut, copy, and paste actions associated with a
<i>1169</i>&nbsp;     * JTextComponent.  A code fragment to accomplish
<i>1170</i>&nbsp;     * this might look as follows:
<i>1171</i>&nbsp;     * &lt;pre&gt;&lt;code&gt;
<i>1172</i>&nbsp;     *
<i>1173</i>&nbsp;     *   static final JTextComponent.KeyBinding[] defaultBindings = {
<i>1174</i>&nbsp;     *     new JTextComponent.KeyBinding(
<i>1175</i>&nbsp;     *       KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_MASK),
<i>1176</i>&nbsp;     *       DefaultEditorKit.copyAction),
<i>1177</i>&nbsp;     *     new JTextComponent.KeyBinding(
<i>1178</i>&nbsp;     *       KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_MASK),
<i>1179</i>&nbsp;     *       DefaultEditorKit.pasteAction),
<i>1180</i>&nbsp;     *     new JTextComponent.KeyBinding(
<b class="nc"><i>1181</i>&nbsp;     *       KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_MASK),</b>
<b class="nc"><i>1182</i>&nbsp;     *       DefaultEditorKit.cutAction),</b>
<b class="nc"><i>1183</i>&nbsp;     *   };</b>
<b class="nc"><i>1184</i>&nbsp;     *</b>
<i>1185</i>&nbsp;     *   JTextComponent c = new JTextPane();
<b class="nc"><i>1186</i>&nbsp;     *   Keymap k = c.getKeymap();</b>
<b class="nc"><i>1187</i>&nbsp;     *   JTextComponent.loadKeymap(k, defaultBindings, c.getActions());</b>
<b class="nc"><i>1188</i>&nbsp;     *</b>
<b class="nc"><i>1189</i>&nbsp;     * &lt;/code&gt;&lt;/pre&gt;</b>
<i>1190</i>&nbsp;     * The sets of bindings and actions may be empty but must be
<i>1191</i>&nbsp;     * non-&lt;code&gt;null&lt;/code&gt;.
<i>1192</i>&nbsp;     *
<i>1193</i>&nbsp;     * @param map the keymap
<i>1194</i>&nbsp;     * @param bindings the bindings
<i>1195</i>&nbsp;     * @param actions the set of actions
<i>1196</i>&nbsp;     */
<i>1197</i>&nbsp;    public static void loadKeymap(Keymap map, KeyBinding[] bindings, Action[] actions) {
<i>1198</i>&nbsp;        Hashtable&lt;String, Action&gt; h = new Hashtable&lt;String, Action&gt;();
<i>1199</i>&nbsp;        for (Action a : actions) {
<i>1200</i>&nbsp;            String value = (String)a.getValue(Action.NAME);
<b class="nc"><i>1201</i>&nbsp;            h.put((value!=null ? value:&quot;&quot;), a);</b>
<i>1202</i>&nbsp;        }
<i>1203</i>&nbsp;        for (KeyBinding binding : bindings) {
<i>1204</i>&nbsp;            Action a = h.get(binding.actionName);
<i>1205</i>&nbsp;            if (a != null) {
<i>1206</i>&nbsp;                map.addActionForKeyStroke(binding.key, a);
<i>1207</i>&nbsp;            }
<i>1208</i>&nbsp;        }
<i>1209</i>&nbsp;    }
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;    /**
<i>1212</i>&nbsp;     * Fetches the current color used to render the
<i>1213</i>&nbsp;     * caret.
<i>1214</i>&nbsp;     *
<i>1215</i>&nbsp;     * @return the color
<i>1216</i>&nbsp;     */
<i>1217</i>&nbsp;    public Color getCaretColor() {
<b class="nc"><i>1218</i>&nbsp;        return caretColor;</b>
<b class="nc"><i>1219</i>&nbsp;    }</b>
<b class="nc"><i>1220</i>&nbsp;</b>
<i>1221</i>&nbsp;    /**
<i>1222</i>&nbsp;     * Sets the current color used to render the caret.
<i>1223</i>&nbsp;     * Setting to &lt;code&gt;null&lt;/code&gt; effectively restores the default color.
<i>1224</i>&nbsp;     * Setting the color results in a PropertyChange event (&quot;caretColor&quot;)
<i>1225</i>&nbsp;     * being fired.
<i>1226</i>&nbsp;     *
<i>1227</i>&nbsp;     * @param c the color
<i>1228</i>&nbsp;     * @see #getCaretColor
<i>1229</i>&nbsp;     */
<b class="nc"><i>1230</i>&nbsp;    @BeanProperty(preferred = true, description</b>
<i>1231</i>&nbsp;            = &quot;the color used to render the caret&quot;)
<i>1232</i>&nbsp;    public void setCaretColor(Color c) {
<i>1233</i>&nbsp;        Color old = caretColor;
<i>1234</i>&nbsp;        caretColor = c;
<i>1235</i>&nbsp;        firePropertyChange(&quot;caretColor&quot;, old, caretColor);
<i>1236</i>&nbsp;    }
<i>1237</i>&nbsp;
<i>1238</i>&nbsp;    /**
<i>1239</i>&nbsp;     * Fetches the current color used to render the
<i>1240</i>&nbsp;     * selection.
<i>1241</i>&nbsp;     *
<i>1242</i>&nbsp;     * @return the color
<i>1243</i>&nbsp;     */
<i>1244</i>&nbsp;    public Color getSelectionColor() {
<i>1245</i>&nbsp;        return selectionColor;
<i>1246</i>&nbsp;    }
<b class="nc"><i>1247</i>&nbsp;</b>
<b class="nc"><i>1248</i>&nbsp;    /**</b>
<b class="nc"><i>1249</i>&nbsp;     * Sets the current color used to render the selection.</b>
<i>1250</i>&nbsp;     * Setting the color to &lt;code&gt;null&lt;/code&gt; is the same as setting
<i>1251</i>&nbsp;     * &lt;code&gt;Color.white&lt;/code&gt;.  Setting the color results in a
<i>1252</i>&nbsp;     * PropertyChange event (&quot;selectionColor&quot;).
<i>1253</i>&nbsp;     *
<i>1254</i>&nbsp;     * @param c the color
<i>1255</i>&nbsp;     * @see #getSelectionColor
<i>1256</i>&nbsp;     */
<i>1257</i>&nbsp;    @BeanProperty(preferred = true, description
<i>1258</i>&nbsp;            = &quot;color used to render selection background&quot;)
<b class="nc"><i>1259</i>&nbsp;    public void setSelectionColor(Color c) {</b>
<i>1260</i>&nbsp;        Color old = selectionColor;
<i>1261</i>&nbsp;        selectionColor = c;
<i>1262</i>&nbsp;        firePropertyChange(&quot;selectionColor&quot;, old, selectionColor);
<i>1263</i>&nbsp;    }
<i>1264</i>&nbsp;
<i>1265</i>&nbsp;    /**
<i>1266</i>&nbsp;     * Fetches the current color used to render the
<i>1267</i>&nbsp;     * selected text.
<i>1268</i>&nbsp;     *
<i>1269</i>&nbsp;     * @return the color
<i>1270</i>&nbsp;     */
<i>1271</i>&nbsp;    public Color getSelectedTextColor() {
<i>1272</i>&nbsp;        return selectedTextColor;
<i>1273</i>&nbsp;    }
<i>1274</i>&nbsp;
<i>1275</i>&nbsp;    /**
<b class="nc"><i>1276</i>&nbsp;     * Sets the current color used to render the selected text.</b>
<b class="nc"><i>1277</i>&nbsp;     * Setting the color to &lt;code&gt;null&lt;/code&gt; is the same as</b>
<b class="nc"><i>1278</i>&nbsp;     * &lt;code&gt;Color.black&lt;/code&gt;. Setting the color results in a</b>
<i>1279</i>&nbsp;     * PropertyChange event (&quot;selectedTextColor&quot;) being fired.
<i>1280</i>&nbsp;     *
<i>1281</i>&nbsp;     * @param c the color
<i>1282</i>&nbsp;     * @see #getSelectedTextColor
<i>1283</i>&nbsp;     */
<i>1284</i>&nbsp;    @BeanProperty(preferred = true, description
<i>1285</i>&nbsp;            = &quot;color used to render selected text&quot;)
<i>1286</i>&nbsp;    public void setSelectedTextColor(Color c) {
<i>1287</i>&nbsp;        Color old = selectedTextColor;
<b class="nc"><i>1288</i>&nbsp;        selectedTextColor = c;</b>
<i>1289</i>&nbsp;        firePropertyChange(&quot;selectedTextColor&quot;, old, selectedTextColor);
<i>1290</i>&nbsp;    }
<i>1291</i>&nbsp;
<i>1292</i>&nbsp;    /**
<i>1293</i>&nbsp;     * Fetches the current color used to render the
<i>1294</i>&nbsp;     * disabled text.
<i>1295</i>&nbsp;     *
<i>1296</i>&nbsp;     * @return the color
<i>1297</i>&nbsp;     */
<i>1298</i>&nbsp;    public Color getDisabledTextColor() {
<i>1299</i>&nbsp;        return disabledTextColor;
<i>1300</i>&nbsp;    }
<i>1301</i>&nbsp;
<i>1302</i>&nbsp;    /**
<i>1303</i>&nbsp;     * Sets the current color used to render the
<b class="nc"><i>1304</i>&nbsp;     * disabled text.  Setting the color fires off a</b>
<b class="nc"><i>1305</i>&nbsp;     * PropertyChange event (&quot;disabledTextColor&quot;).</b>
<b class="nc"><i>1306</i>&nbsp;     *</b>
<i>1307</i>&nbsp;     * @param c the color
<i>1308</i>&nbsp;     * @see #getDisabledTextColor
<i>1309</i>&nbsp;     */
<i>1310</i>&nbsp;    @BeanProperty(preferred = true, description
<i>1311</i>&nbsp;            = &quot;color used to render disabled text&quot;)
<i>1312</i>&nbsp;    public void setDisabledTextColor(Color c) {
<i>1313</i>&nbsp;        Color old = disabledTextColor;
<i>1314</i>&nbsp;        disabledTextColor = c;
<i>1315</i>&nbsp;        firePropertyChange(&quot;disabledTextColor&quot;, old, disabledTextColor);
<i>1316</i>&nbsp;    }
<i>1317</i>&nbsp;
<i>1318</i>&nbsp;    /**
<i>1319</i>&nbsp;     * Replaces the currently selected content with new content
<i>1320</i>&nbsp;     * represented by the given string.  If there is no selection
<i>1321</i>&nbsp;     * this amounts to an insert of the given text.  If there
<i>1322</i>&nbsp;     * is no replacement text this amounts to a removal of the
<b class="nc"><i>1323</i>&nbsp;     * current selection.</b>
<b class="nc"><i>1324</i>&nbsp;     * &lt;p&gt;</b>
<i>1325</i>&nbsp;     * This is the method that is used by the default implementation
<b class="nc"><i>1326</i>&nbsp;     * of the action for inserting content that gets bound to the</b>
<b class="nc"><i>1327</i>&nbsp;     * keymap actions.</b>
<b class="nc"><i>1328</i>&nbsp;     *</b>
<b class="nc"><i>1329</i>&nbsp;     * @param content  the content to replace the selection with</b>
<b class="nc"><i>1330</i>&nbsp;     */</b>
<i>1331</i>&nbsp;    public void replaceSelection(String content) {
<i>1332</i>&nbsp;        Document doc = getDocument();
<b class="nc"><i>1333</i>&nbsp;        if (doc != null) {</b>
<b class="nc"><i>1334</i>&nbsp;            try {</b>
<i>1335</i>&nbsp;                boolean composedTextSaved = saveComposedText(caret.getDot());
<b class="nc"><i>1336</i>&nbsp;                int p0 = Math.min(caret.getDot(), caret.getMark());</b>
<b class="nc"><i>1337</i>&nbsp;                int p1 = Math.max(caret.getDot(), caret.getMark());</b>
<i>1338</i>&nbsp;                if (doc instanceof AbstractDocument) {
<i>1339</i>&nbsp;                    ((AbstractDocument)doc).replace(p0, p1 - p0, content,null);
<b class="nc"><i>1340</i>&nbsp;                }</b>
<b class="nc"><i>1341</i>&nbsp;                else {</b>
<i>1342</i>&nbsp;                    if (p0 != p1) {
<b class="nc"><i>1343</i>&nbsp;                        doc.remove(p0, p1 - p0);</b>
<b class="nc"><i>1344</i>&nbsp;                    }</b>
<b class="nc"><i>1345</i>&nbsp;                    if (content != null &amp;&amp; content.length() &gt; 0) {</b>
<i>1346</i>&nbsp;                        doc.insertString(p0, content, null);
<i>1347</i>&nbsp;                    }
<i>1348</i>&nbsp;                }
<i>1349</i>&nbsp;                if (composedTextSaved) {
<i>1350</i>&nbsp;                    restoreComposedText();
<i>1351</i>&nbsp;                }
<i>1352</i>&nbsp;            } catch (BadLocationException e) {
<i>1353</i>&nbsp;                UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);
<i>1354</i>&nbsp;            }
<i>1355</i>&nbsp;        }
<i>1356</i>&nbsp;    }
<i>1357</i>&nbsp;
<i>1358</i>&nbsp;    /**
<b class="nc"><i>1359</i>&nbsp;     * Fetches a portion of the text represented by the</b>
<i>1360</i>&nbsp;     * component.  Returns an empty string if length is 0.
<i>1361</i>&nbsp;     *
<i>1362</i>&nbsp;     * @param offs the offset &amp;ge; 0
<i>1363</i>&nbsp;     * @param len the length &amp;ge; 0
<i>1364</i>&nbsp;     * @return the text
<i>1365</i>&nbsp;     * @exception BadLocationException if the offset or length are invalid
<i>1366</i>&nbsp;     */
<i>1367</i>&nbsp;    public String getText(int offs, int len) throws BadLocationException {
<i>1368</i>&nbsp;        return getDocument().getText(offs, len);
<i>1369</i>&nbsp;    }
<i>1370</i>&nbsp;
<i>1371</i>&nbsp;    /**
<i>1372</i>&nbsp;     * Converts the given location in the model to a place in
<i>1373</i>&nbsp;     * the view coordinate system.
<i>1374</i>&nbsp;     * The component must have a positive size for
<i>1375</i>&nbsp;     * this translation to be computed (i.e. layout cannot
<i>1376</i>&nbsp;     * be computed until the component has been sized).  The
<i>1377</i>&nbsp;     * component does not have to be visible or painted.
<i>1378</i>&nbsp;     *
<i>1379</i>&nbsp;     * @param pos the position &amp;ge; 0
<i>1380</i>&nbsp;     * @return the coordinates as a rectangle, with (r.x, r.y) as the location
<i>1381</i>&nbsp;     *   in the coordinate system, or null if the component does
<i>1382</i>&nbsp;     *   not yet have a positive size.
<b class="nc"><i>1383</i>&nbsp;     * @exception BadLocationException if the given position does not</b>
<i>1384</i>&nbsp;     *   represent a valid location in the associated document
<i>1385</i>&nbsp;     * @see TextUI#modelToView
<i>1386</i>&nbsp;     *
<i>1387</i>&nbsp;     * @deprecated replaced by
<i>1388</i>&nbsp;     *     {@link #modelToView2D(int)}
<i>1389</i>&nbsp;     */
<i>1390</i>&nbsp;    @Deprecated(since = &quot;9&quot;)
<i>1391</i>&nbsp;    public Rectangle modelToView(int pos) throws BadLocationException {
<i>1392</i>&nbsp;        return getUI().modelToView(this, pos);
<i>1393</i>&nbsp;    }
<i>1394</i>&nbsp;
<i>1395</i>&nbsp;    /**
<i>1396</i>&nbsp;     * Converts the given location in the model to a place in
<i>1397</i>&nbsp;     * the view coordinate system.
<i>1398</i>&nbsp;     * The component must have a positive size for
<i>1399</i>&nbsp;     * this translation to be computed (i.e. layout cannot
<i>1400</i>&nbsp;     * be computed until the component has been sized).  The
<i>1401</i>&nbsp;     * component does not have to be visible or painted.
<i>1402</i>&nbsp;     *
<b class="nc"><i>1403</i>&nbsp;     * @param pos the position {@code &gt;= 0}</b>
<i>1404</i>&nbsp;     * @return the coordinates as a rectangle, with (r.x, r.y) as the location
<i>1405</i>&nbsp;     *   in the coordinate system, or null if the component does
<i>1406</i>&nbsp;     *   not yet have a positive size.
<i>1407</i>&nbsp;     * @exception BadLocationException if the given position does not
<i>1408</i>&nbsp;     *   represent a valid location in the associated document
<i>1409</i>&nbsp;     * @see TextUI#modelToView2D
<i>1410</i>&nbsp;     *
<i>1411</i>&nbsp;     * @since 9
<i>1412</i>&nbsp;     */
<i>1413</i>&nbsp;    public Rectangle2D modelToView2D(int pos) throws BadLocationException {
<i>1414</i>&nbsp;        return getUI().modelToView2D(this, pos, Position.Bias.Forward);
<i>1415</i>&nbsp;    }
<i>1416</i>&nbsp;
<i>1417</i>&nbsp;    /**
<i>1418</i>&nbsp;     * Converts the given place in the view coordinate system
<i>1419</i>&nbsp;     * to the nearest representative location in the model.
<i>1420</i>&nbsp;     * The component must have a positive size for
<i>1421</i>&nbsp;     * this translation to be computed (i.e. layout cannot
<i>1422</i>&nbsp;     * be computed until the component has been sized).  The
<i>1423</i>&nbsp;     * component does not have to be visible or painted.
<i>1424</i>&nbsp;     *
<b class="nc"><i>1425</i>&nbsp;     * @param pt the location in the view to translate</b>
<i>1426</i>&nbsp;     * @return the offset &amp;ge; 0 from the start of the document,
<i>1427</i>&nbsp;     *   or -1 if the component does not yet have a positive
<i>1428</i>&nbsp;     *   size.
<i>1429</i>&nbsp;     * @see TextUI#viewToModel
<i>1430</i>&nbsp;     *
<i>1431</i>&nbsp;     * @deprecated replaced by
<i>1432</i>&nbsp;     *     {@link #viewToModel2D(Point2D)}
<i>1433</i>&nbsp;     */
<i>1434</i>&nbsp;    @Deprecated(since = &quot;9&quot;)
<i>1435</i>&nbsp;    public int viewToModel(Point pt) {
<i>1436</i>&nbsp;        return getUI().viewToModel(this, pt);
<i>1437</i>&nbsp;    }
<i>1438</i>&nbsp;
<i>1439</i>&nbsp;    /**
<i>1440</i>&nbsp;     * Converts the given place in the view coordinate system
<i>1441</i>&nbsp;     * to the nearest representative location in the model.
<i>1442</i>&nbsp;     * The component must have a positive size for
<b class="nc"><i>1443</i>&nbsp;     * this translation to be computed (i.e. layout cannot</b>
<i>1444</i>&nbsp;     * be computed until the component has been sized).  The
<i>1445</i>&nbsp;     * component does not have to be visible or painted.
<i>1446</i>&nbsp;     *
<i>1447</i>&nbsp;     * @param pt the location in the view to translate
<i>1448</i>&nbsp;     * @return the offset {@code &gt;= 0} from the start of the document,
<i>1449</i>&nbsp;     *   or {@code -1} if the component does not yet have a positive
<i>1450</i>&nbsp;     *   size.
<i>1451</i>&nbsp;     * @see TextUI#viewToModel2D
<i>1452</i>&nbsp;     *
<i>1453</i>&nbsp;     * @since 9
<i>1454</i>&nbsp;     */
<i>1455</i>&nbsp;    public int viewToModel2D(Point2D pt) {
<b class="nc"><i>1456</i>&nbsp;        return getUI().viewToModel2D(this, pt, new Position.Bias[1]);</b>
<b class="nc"><i>1457</i>&nbsp;    }</b>
<i>1458</i>&nbsp;
<i>1459</i>&nbsp;    /**
<i>1460</i>&nbsp;     * Transfers the currently selected range in the associated
<i>1461</i>&nbsp;     * text model to the system clipboard, removing the contents
<i>1462</i>&nbsp;     * from the model.  The current selection is reset.  Does nothing
<i>1463</i>&nbsp;     * for &lt;code&gt;null&lt;/code&gt; selections.
<i>1464</i>&nbsp;     *
<i>1465</i>&nbsp;     * @see java.awt.Toolkit#getSystemClipboard
<i>1466</i>&nbsp;     * @see java.awt.datatransfer.Clipboard
<i>1467</i>&nbsp;     */
<i>1468</i>&nbsp;    public void cut() {
<i>1469</i>&nbsp;        if (isEditable() &amp;&amp; isEnabled()) {
<i>1470</i>&nbsp;            invokeAction(&quot;cut&quot;, TransferHandler.getCutAction());
<b class="nc"><i>1471</i>&nbsp;        }</b>
<i>1472</i>&nbsp;    }
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;    /**
<i>1475</i>&nbsp;     * Transfers the currently selected range in the associated
<i>1476</i>&nbsp;     * text model to the system clipboard, leaving the contents
<i>1477</i>&nbsp;     * in the text model.  The current selection remains intact.
<i>1478</i>&nbsp;     * Does nothing for &lt;code&gt;null&lt;/code&gt; selections.
<i>1479</i>&nbsp;     *
<i>1480</i>&nbsp;     * @see java.awt.Toolkit#getSystemClipboard
<i>1481</i>&nbsp;     * @see java.awt.datatransfer.Clipboard
<i>1482</i>&nbsp;     */
<i>1483</i>&nbsp;    public void copy() {
<i>1484</i>&nbsp;        invokeAction(&quot;copy&quot;, TransferHandler.getCopyAction());
<i>1485</i>&nbsp;    }
<i>1486</i>&nbsp;
<b class="nc"><i>1487</i>&nbsp;    /**</b>
<b class="nc"><i>1488</i>&nbsp;     * Transfers the contents of the system clipboard into the</b>
<i>1489</i>&nbsp;     * associated text model.  If there is a selection in the
<i>1490</i>&nbsp;     * associated view, it is replaced with the contents of the
<i>1491</i>&nbsp;     * clipboard.  If there is no selection, the clipboard contents
<i>1492</i>&nbsp;     * are inserted in front of the current insert position in
<i>1493</i>&nbsp;     * the associated view.  If the clipboard is empty, does nothing.
<i>1494</i>&nbsp;     *
<i>1495</i>&nbsp;     * @see #replaceSelection
<i>1496</i>&nbsp;     * @see java.awt.Toolkit#getSystemClipboard
<i>1497</i>&nbsp;     * @see java.awt.datatransfer.Clipboard
<i>1498</i>&nbsp;     */
<i>1499</i>&nbsp;    public void paste() {
<b class="nc"><i>1500</i>&nbsp;        if (isEditable() &amp;&amp; isEnabled()) {</b>
<b class="nc"><i>1501</i>&nbsp;            invokeAction(&quot;paste&quot;, TransferHandler.getPasteAction());</b>
<i>1502</i>&nbsp;        }
<b class="nc"><i>1503</i>&nbsp;    }</b>
<b class="nc"><i>1504</i>&nbsp;</b>
<i>1505</i>&nbsp;    /**
<b class="nc"><i>1506</i>&nbsp;     * This is a convenience method that is only useful for</b>
<b class="nc"><i>1507</i>&nbsp;     * &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;copy&lt;/code&gt; and &lt;code&gt;paste&lt;/code&gt;.  If</b>
<b class="nc"><i>1508</i>&nbsp;     * an &lt;code&gt;Action&lt;/code&gt; with the name &lt;code&gt;name&lt;/code&gt; does not</b>
<i>1509</i>&nbsp;     * exist in the &lt;code&gt;ActionMap&lt;/code&gt;, this will attempt to install a
<b class="nc"><i>1510</i>&nbsp;     * &lt;code&gt;TransferHandler&lt;/code&gt; and then use &lt;code&gt;altAction&lt;/code&gt;.</b>
<i>1511</i>&nbsp;     */
<b class="nc"><i>1512</i>&nbsp;    private void invokeAction(String name, Action altAction) {</b>
<b class="nc"><i>1513</i>&nbsp;        ActionMap map = getActionMap();</b>
<b class="nc"><i>1514</i>&nbsp;        Action action = null;</b>
<i>1515</i>&nbsp;
<i>1516</i>&nbsp;        if (map != null) {
<i>1517</i>&nbsp;            action = map.get(name);
<i>1518</i>&nbsp;        }
<i>1519</i>&nbsp;        if (action == null) {
<i>1520</i>&nbsp;            installDefaultTransferHandlerIfNecessary();
<i>1521</i>&nbsp;            action = altAction;
<b class="nc"><i>1522</i>&nbsp;        }</b>
<b class="nc"><i>1523</i>&nbsp;        action.actionPerformed(new ActionEvent(this,</b>
<b class="nc"><i>1524</i>&nbsp;                               ActionEvent.ACTION_PERFORMED, (String)action.</b>
<i>1525</i>&nbsp;                               getValue(Action.NAME),
<b class="nc"><i>1526</i>&nbsp;                               EventQueue.getMostRecentEventTime(),</b>
<i>1527</i>&nbsp;                               getCurrentEventModifiers()));
<i>1528</i>&nbsp;    }
<i>1529</i>&nbsp;
<i>1530</i>&nbsp;    /**
<i>1531</i>&nbsp;     * If the current &lt;code&gt;TransferHandler&lt;/code&gt; is null, this will
<i>1532</i>&nbsp;     * install a new one.
<i>1533</i>&nbsp;     */
<i>1534</i>&nbsp;    private void installDefaultTransferHandlerIfNecessary() {
<i>1535</i>&nbsp;        if (getTransferHandler() == null) {
<i>1536</i>&nbsp;            if (defaultTransferHandler == null) {
<i>1537</i>&nbsp;                defaultTransferHandler = new DefaultTransferHandler();
<i>1538</i>&nbsp;            }
<i>1539</i>&nbsp;            setTransferHandler(defaultTransferHandler);
<i>1540</i>&nbsp;        }
<i>1541</i>&nbsp;    }
<i>1542</i>&nbsp;
<i>1543</i>&nbsp;    /**
<i>1544</i>&nbsp;     * Moves the caret to a new position, leaving behind a mark
<b class="nc"><i>1545</i>&nbsp;     * defined by the last time &lt;code&gt;setCaretPosition&lt;/code&gt; was</b>
<b class="nc"><i>1546</i>&nbsp;     * called.  This forms a selection.</b>
<b class="nc"><i>1547</i>&nbsp;     * If the document is &lt;code&gt;null&lt;/code&gt;, does nothing. The position</b>
<b class="nc"><i>1548</i>&nbsp;     * must be between 0 and the length of the component&#39;s text or else</b>
<i>1549</i>&nbsp;     * an exception is thrown.
<b class="nc"><i>1550</i>&nbsp;     *</b>
<i>1551</i>&nbsp;     * @param pos the position
<i>1552</i>&nbsp;     * @exception    IllegalArgumentException if the value supplied
<i>1553</i>&nbsp;     *               for &lt;code&gt;position&lt;/code&gt; is less than zero or greater
<i>1554</i>&nbsp;     *               than the component&#39;s text length
<i>1555</i>&nbsp;     * @see #setCaretPosition
<i>1556</i>&nbsp;     */
<i>1557</i>&nbsp;    public void moveCaretPosition(int pos) {
<i>1558</i>&nbsp;        Document doc = getDocument();
<i>1559</i>&nbsp;        if (doc != null) {
<i>1560</i>&nbsp;            if (pos &gt; doc.getLength() || pos &lt; 0) {
<i>1561</i>&nbsp;                throw new IllegalArgumentException(&quot;bad position: &quot; + pos);
<i>1562</i>&nbsp;            }
<i>1563</i>&nbsp;            caret.moveDot(pos);
<i>1564</i>&nbsp;        }
<i>1565</i>&nbsp;    }
<i>1566</i>&nbsp;
<i>1567</i>&nbsp;    /**
<i>1568</i>&nbsp;     * The bound property name for the focus accelerator.
<i>1569</i>&nbsp;     */
<i>1570</i>&nbsp;    public static final String FOCUS_ACCELERATOR_KEY = &quot;focusAcceleratorKey&quot;;
<i>1571</i>&nbsp;
<i>1572</i>&nbsp;    /**
<i>1573</i>&nbsp;     * Sets the key accelerator that will cause the receiving text
<i>1574</i>&nbsp;     * component to get the focus.  The accelerator will be the
<i>1575</i>&nbsp;     * key combination of the platform-specific modifier key and
<i>1576</i>&nbsp;     * the character given (converted to upper case).  For example,
<i>1577</i>&nbsp;     * the ALT key is used as a modifier on Windows and the CTRL+ALT
<b class="nc"><i>1578</i>&nbsp;     * combination is used on Mac.  By default, there is no focus</b>
<b class="nc"><i>1579</i>&nbsp;     * accelerator key.  Any previous key accelerator setting will be</b>
<b class="nc"><i>1580</i>&nbsp;     * superseded.  A &#39;\0&#39; key setting will be registered, and has the</b>
<i>1581</i>&nbsp;     * effect of turning off the focus accelerator.  When the new key
<i>1582</i>&nbsp;     * is set, a PropertyChange event (FOCUS_ACCELERATOR_KEY) will be fired.
<i>1583</i>&nbsp;     *
<b class="nc"><i>1584</i>&nbsp;     * @param aKey the key</b>
<b class="nc"><i>1585</i>&nbsp;     * @see #getFocusAccelerator</b>
<i>1586</i>&nbsp;     */
<i>1587</i>&nbsp;    @BeanProperty(description
<i>1588</i>&nbsp;            = &quot;accelerator character used to grab focus&quot;)
<i>1589</i>&nbsp;    public void setFocusAccelerator(char aKey) {
<i>1590</i>&nbsp;        aKey = Character.toUpperCase(aKey);
<i>1591</i>&nbsp;        char old = focusAccelerator;
<i>1592</i>&nbsp;        focusAccelerator = aKey;
<i>1593</i>&nbsp;        // Fix for 4341002: value of FOCUS_ACCELERATOR_KEY is wrong.
<i>1594</i>&nbsp;        // So we fire both FOCUS_ACCELERATOR_KEY, for compatibility,
<i>1595</i>&nbsp;        // and the correct event here.
<b class="nc"><i>1596</i>&nbsp;        firePropertyChange(FOCUS_ACCELERATOR_KEY, old, focusAccelerator);</b>
<i>1597</i>&nbsp;        firePropertyChange(&quot;focusAccelerator&quot;, old, focusAccelerator);
<i>1598</i>&nbsp;    }
<i>1599</i>&nbsp;
<i>1600</i>&nbsp;    /**
<i>1601</i>&nbsp;     * Returns the key accelerator that will cause the receiving
<i>1602</i>&nbsp;     * text component to get the focus.  Return &#39;\0&#39; if no focus
<i>1603</i>&nbsp;     * accelerator has been set.
<i>1604</i>&nbsp;     *
<i>1605</i>&nbsp;     * @return the key
<i>1606</i>&nbsp;     */
<i>1607</i>&nbsp;    public char getFocusAccelerator() {
<i>1608</i>&nbsp;        return focusAccelerator;
<i>1609</i>&nbsp;    }
<i>1610</i>&nbsp;
<i>1611</i>&nbsp;    /**
<i>1612</i>&nbsp;     * Initializes from a stream.  This creates a
<i>1613</i>&nbsp;     * model of the type appropriate for the component
<i>1614</i>&nbsp;     * and initializes the model from the stream.
<i>1615</i>&nbsp;     * By default this will load the model as plain
<i>1616</i>&nbsp;     * text.  Previous contents of the model are discarded.
<i>1617</i>&nbsp;     *
<i>1618</i>&nbsp;     * @param in the stream to read from
<b class="nc"><i>1619</i>&nbsp;     * @param desc an object describing the stream; this</b>
<b class="nc"><i>1620</i>&nbsp;     *   might be a string, a File, a URL, etc.  Some kinds</b>
<b class="nc"><i>1621</i>&nbsp;     *   of documents (such as html for example) might be</b>
<b class="nc"><i>1622</i>&nbsp;     *   able to make use of this information; if non-&lt;code&gt;null&lt;/code&gt;,</b>
<i>1623</i>&nbsp;     *   it is added as a property of the document
<i>1624</i>&nbsp;     * @exception IOException as thrown by the stream being
<b class="nc"><i>1625</i>&nbsp;     *  used to initialize</b>
<b class="nc"><i>1626</i>&nbsp;     * @see EditorKit#createDefaultDocument</b>
<b class="nc"><i>1627</i>&nbsp;     * @see #setDocument</b>
<b class="nc"><i>1628</i>&nbsp;     * @see PlainDocument</b>
<b class="nc"><i>1629</i>&nbsp;     */</b>
<i>1630</i>&nbsp;    public void read(Reader in, Object desc) throws IOException {
<i>1631</i>&nbsp;        EditorKit kit = getUI().getEditorKit(this);
<i>1632</i>&nbsp;        Document doc = kit.createDefaultDocument();
<i>1633</i>&nbsp;        if (desc != null) {
<i>1634</i>&nbsp;            doc.putProperty(Document.StreamDescriptionProperty, desc);
<i>1635</i>&nbsp;        }
<i>1636</i>&nbsp;        try {
<i>1637</i>&nbsp;            kit.read(in, doc, 0);
<i>1638</i>&nbsp;            setDocument(doc);
<i>1639</i>&nbsp;        } catch (BadLocationException e) {
<i>1640</i>&nbsp;            throw new IOException(e.getMessage());
<b class="nc"><i>1641</i>&nbsp;        }</b>
<i>1642</i>&nbsp;    }
<b class="nc"><i>1643</i>&nbsp;</b>
<b class="nc"><i>1644</i>&nbsp;    /**</b>
<b class="nc"><i>1645</i>&nbsp;     * Stores the contents of the model into the given</b>
<b class="nc"><i>1646</i>&nbsp;     * stream.  By default this will store the model as plain</b>
<i>1647</i>&nbsp;     * text.
<i>1648</i>&nbsp;     *
<i>1649</i>&nbsp;     * @param out the output stream
<b class="nc"><i>1650</i>&nbsp;     * @exception IOException on any I/O error</b>
<b class="nc"><i>1651</i>&nbsp;     */</b>
<b class="nc"><i>1652</i>&nbsp;    public void write(Writer out) throws IOException {</b>
<i>1653</i>&nbsp;        Document doc = getDocument();
<i>1654</i>&nbsp;        try {
<i>1655</i>&nbsp;            getUI().getEditorKit(this).write(out, doc, 0, doc.getLength());
<i>1656</i>&nbsp;        } catch (BadLocationException e) {
<i>1657</i>&nbsp;            throw new IOException(e.getMessage());
<i>1658</i>&nbsp;        }
<i>1659</i>&nbsp;    }
<i>1660</i>&nbsp;
<i>1661</i>&nbsp;    public void removeNotify() {
<i>1662</i>&nbsp;        super.removeNotify();
<i>1663</i>&nbsp;        if (getFocusedComponent() == this) {
<i>1664</i>&nbsp;            AppContext.getAppContext().remove(FOCUSED_COMPONENT);
<i>1665</i>&nbsp;        }
<i>1666</i>&nbsp;    }
<i>1667</i>&nbsp;
<i>1668</i>&nbsp;    // --- java.awt.TextComponent methods ------------------------
<i>1669</i>&nbsp;
<i>1670</i>&nbsp;    /**
<i>1671</i>&nbsp;     * Sets the position of the text insertion caret for the
<i>1672</i>&nbsp;     * &lt;code&gt;TextComponent&lt;/code&gt;.  Note that the caret tracks change,
<i>1673</i>&nbsp;     * so this may move if the underlying text of the component is changed.
<b class="nc"><i>1674</i>&nbsp;     * If the document is &lt;code&gt;null&lt;/code&gt;, does nothing. The position</b>
<b class="nc"><i>1675</i>&nbsp;     * must be between 0 and the length of the component&#39;s text or else</b>
<b class="nc"><i>1676</i>&nbsp;     * an exception is thrown.</b>
<b class="nc"><i>1677</i>&nbsp;     *</b>
<i>1678</i>&nbsp;     * @param position the position
<b class="nc"><i>1679</i>&nbsp;     * @exception    IllegalArgumentException if the value supplied</b>
<i>1680</i>&nbsp;     *               for &lt;code&gt;position&lt;/code&gt; is less than zero or greater
<i>1681</i>&nbsp;     *               than the component&#39;s text length
<i>1682</i>&nbsp;     */
<i>1683</i>&nbsp;    @BeanProperty(bound = false, description
<i>1684</i>&nbsp;            = &quot;the caret position&quot;)
<i>1685</i>&nbsp;    public void setCaretPosition(int position) {
<i>1686</i>&nbsp;        Document doc = getDocument();
<i>1687</i>&nbsp;        if (doc != null) {
<i>1688</i>&nbsp;            if (position &gt; doc.getLength() || position &lt; 0) {
<i>1689</i>&nbsp;                throw new IllegalArgumentException(&quot;bad position: &quot; + position);
<i>1690</i>&nbsp;            }
<i>1691</i>&nbsp;            caret.setDot(position);
<b class="nc"><i>1692</i>&nbsp;        }</b>
<i>1693</i>&nbsp;    }
<i>1694</i>&nbsp;
<i>1695</i>&nbsp;    /**
<i>1696</i>&nbsp;     * Returns the position of the text insertion caret for the
<i>1697</i>&nbsp;     * text component.
<i>1698</i>&nbsp;     *
<i>1699</i>&nbsp;     * @return the position of the text insertion caret for the
<i>1700</i>&nbsp;     *  text component &amp;ge; 0
<i>1701</i>&nbsp;     */
<i>1702</i>&nbsp;    @Transient
<i>1703</i>&nbsp;    public int getCaretPosition() {
<i>1704</i>&nbsp;        return caret.getDot();
<i>1705</i>&nbsp;    }
<i>1706</i>&nbsp;
<i>1707</i>&nbsp;    /**
<i>1708</i>&nbsp;     * Sets the text of this &lt;code&gt;TextComponent&lt;/code&gt;
<i>1709</i>&nbsp;     * to the specified text.  If the text is &lt;code&gt;null&lt;/code&gt;
<i>1710</i>&nbsp;     * or empty, has the effect of simply deleting the old text.
<i>1711</i>&nbsp;     * When text has been inserted, the resulting caret location
<i>1712</i>&nbsp;     * is determined by the implementation of the caret class.
<i>1713</i>&nbsp;     *
<i>1714</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1715</i>&nbsp;     * Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent</b>
<b class="nc"><i>1716</i>&nbsp;     * &lt;/code&gt; is fired when it changes. To listen for changes to the text,</b>
<b class="nc"><i>1717</i>&nbsp;     * use &lt;code&gt;DocumentListener&lt;/code&gt;.</b>
<i>1718</i>&nbsp;     *
<i>1719</i>&nbsp;     * @param t the new text to be set
<b class="nc"><i>1720</i>&nbsp;     * @see #getText</b>
<b class="nc"><i>1721</i>&nbsp;     * @see DefaultCaret</b>
<i>1722</i>&nbsp;     */
<b class="nc"><i>1723</i>&nbsp;    @BeanProperty(bound = false, description</b>
<b class="nc"><i>1724</i>&nbsp;            = &quot;the text of this component&quot;)</b>
<b class="nc"><i>1725</i>&nbsp;    public void setText(String t) {</b>
<i>1726</i>&nbsp;        try {
<i>1727</i>&nbsp;            Document doc = getDocument();
<i>1728</i>&nbsp;            if (doc instanceof AbstractDocument) {
<i>1729</i>&nbsp;                ((AbstractDocument)doc).replace(0, doc.getLength(), t,null);
<i>1730</i>&nbsp;            }
<i>1731</i>&nbsp;            else {
<i>1732</i>&nbsp;                doc.remove(0, doc.getLength());
<i>1733</i>&nbsp;                doc.insertString(0, t, null);
<i>1734</i>&nbsp;            }
<i>1735</i>&nbsp;        } catch (BadLocationException e) {
<i>1736</i>&nbsp;            UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);
<i>1737</i>&nbsp;        }
<i>1738</i>&nbsp;    }
<i>1739</i>&nbsp;
<i>1740</i>&nbsp;    /**
<i>1741</i>&nbsp;     * Returns the text contained in this &lt;code&gt;TextComponent&lt;/code&gt;.
<b class="nc"><i>1742</i>&nbsp;     * If the underlying document is &lt;code&gt;null&lt;/code&gt;,</b>
<i>1743</i>&nbsp;     * will give a &lt;code&gt;NullPointerException&lt;/code&gt;.
<i>1744</i>&nbsp;     *
<b class="nc"><i>1745</i>&nbsp;     * Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent</b>
<b class="nc"><i>1746</i>&nbsp;     * &lt;/code&gt; is fired when it changes. To listen for changes to the text,</b>
<b class="nc"><i>1747</i>&nbsp;     * use &lt;code&gt;DocumentListener&lt;/code&gt;.</b>
<b class="nc"><i>1748</i>&nbsp;     *</b>
<b class="nc"><i>1749</i>&nbsp;     * @return the text</b>
<i>1750</i>&nbsp;     * @exception NullPointerException if the document is &lt;code&gt;null&lt;/code&gt;
<i>1751</i>&nbsp;     * @see #setText
<i>1752</i>&nbsp;     */
<i>1753</i>&nbsp;    public String getText() {
<i>1754</i>&nbsp;        Document doc = getDocument();
<i>1755</i>&nbsp;        String txt;
<i>1756</i>&nbsp;        try {
<i>1757</i>&nbsp;            txt = doc.getText(0, doc.getLength());
<i>1758</i>&nbsp;        } catch (BadLocationException e) {
<i>1759</i>&nbsp;            txt = null;
<i>1760</i>&nbsp;        }
<i>1761</i>&nbsp;        return txt;
<i>1762</i>&nbsp;    }
<b class="nc"><i>1763</i>&nbsp;</b>
<b class="nc"><i>1764</i>&nbsp;    /**</b>
<b class="nc"><i>1765</i>&nbsp;     * Returns the selected text contained in this</b>
<b class="nc"><i>1766</i>&nbsp;     * &lt;code&gt;TextComponent&lt;/code&gt;.  If the selection is</b>
<i>1767</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; or the document empty, returns &lt;code&gt;null&lt;/code&gt;.
<b class="nc"><i>1768</i>&nbsp;     *</b>
<b class="nc"><i>1769</i>&nbsp;     * @return the text</b>
<b class="nc"><i>1770</i>&nbsp;     * @exception IllegalArgumentException if the selection doesn&#39;t</b>
<b class="nc"><i>1771</i>&nbsp;     *  have a valid mapping into the document for some reason</b>
<b class="nc"><i>1772</i>&nbsp;     * @see #setText</b>
<i>1773</i>&nbsp;     */
<b class="nc"><i>1774</i>&nbsp;    @BeanProperty(bound = false)</b>
<i>1775</i>&nbsp;    public String getSelectedText() {
<i>1776</i>&nbsp;        String txt = null;
<i>1777</i>&nbsp;        int p0 = Math.min(caret.getDot(), caret.getMark());
<i>1778</i>&nbsp;        int p1 = Math.max(caret.getDot(), caret.getMark());
<i>1779</i>&nbsp;        if (p0 != p1) {
<i>1780</i>&nbsp;            try {
<i>1781</i>&nbsp;                Document doc = getDocument();
<i>1782</i>&nbsp;                txt = doc.getText(p0, p1 - p0);
<i>1783</i>&nbsp;            } catch (BadLocationException e) {
<i>1784</i>&nbsp;                throw new IllegalArgumentException(e.getMessage());
<b class="nc"><i>1785</i>&nbsp;            }</b>
<i>1786</i>&nbsp;        }
<i>1787</i>&nbsp;        return txt;
<i>1788</i>&nbsp;    }
<i>1789</i>&nbsp;
<i>1790</i>&nbsp;    /**
<i>1791</i>&nbsp;     * Returns the boolean indicating whether this
<i>1792</i>&nbsp;     * &lt;code&gt;TextComponent&lt;/code&gt; is editable or not.
<i>1793</i>&nbsp;     *
<i>1794</i>&nbsp;     * @return the boolean value
<i>1795</i>&nbsp;     * @see #setEditable
<i>1796</i>&nbsp;     */
<i>1797</i>&nbsp;    public boolean isEditable() {
<i>1798</i>&nbsp;        return editable;
<i>1799</i>&nbsp;    }
<i>1800</i>&nbsp;
<b class="nc"><i>1801</i>&nbsp;    /**</b>
<b class="nc"><i>1802</i>&nbsp;     * Sets the specified boolean to indicate whether or not this</b>
<b class="nc"><i>1803</i>&nbsp;     * &lt;code&gt;TextComponent&lt;/code&gt; should be editable.</b>
<b class="nc"><i>1804</i>&nbsp;     * A PropertyChange event (&quot;editable&quot;) is fired when the</b>
<b class="nc"><i>1805</i>&nbsp;     * state is changed.</b>
<b class="nc"><i>1806</i>&nbsp;     *</b>
<i>1807</i>&nbsp;     * @param b the boolean to be set
<i>1808</i>&nbsp;     * @see #isEditable
<i>1809</i>&nbsp;     */
<i>1810</i>&nbsp;    @BeanProperty(description
<i>1811</i>&nbsp;            = &quot;specifies if the text can be edited&quot;)
<i>1812</i>&nbsp;    public void setEditable(boolean b) {
<i>1813</i>&nbsp;        if (b != editable) {
<i>1814</i>&nbsp;            boolean oldVal = editable;
<i>1815</i>&nbsp;            editable = b;
<i>1816</i>&nbsp;            enableInputMethods(editable);
<i>1817</i>&nbsp;            firePropertyChange(&quot;editable&quot;, Boolean.valueOf(oldVal), Boolean.valueOf(editable));
<b class="nc"><i>1818</i>&nbsp;            repaint();</b>
<b class="nc"><i>1819</i>&nbsp;        }</b>
<i>1820</i>&nbsp;    }
<i>1821</i>&nbsp;
<i>1822</i>&nbsp;    /**
<i>1823</i>&nbsp;     * Returns the selected text&#39;s start position.  Return 0 for an
<i>1824</i>&nbsp;     * empty document, or the value of dot if no selection.
<i>1825</i>&nbsp;     *
<i>1826</i>&nbsp;     * @return the start position &amp;ge; 0
<i>1827</i>&nbsp;     */
<i>1828</i>&nbsp;    @Transient
<i>1829</i>&nbsp;    public int getSelectionStart() {
<i>1830</i>&nbsp;        int start = Math.min(caret.getDot(), caret.getMark());
<i>1831</i>&nbsp;        return start;
<i>1832</i>&nbsp;    }
<i>1833</i>&nbsp;
<i>1834</i>&nbsp;    /**
<i>1835</i>&nbsp;     * Sets the selection start to the specified position.  The new
<i>1836</i>&nbsp;     * starting point is constrained to be before or at the current
<i>1837</i>&nbsp;     * selection end.
<i>1838</i>&nbsp;     * &lt;p&gt;
<i>1839</i>&nbsp;     * This is available for backward compatibility to code
<b class="nc"><i>1840</i>&nbsp;     * that called this method on &lt;code&gt;java.awt.TextComponent&lt;/code&gt;.</b>
<i>1841</i>&nbsp;     * This is implemented to forward to the &lt;code&gt;Caret&lt;/code&gt;
<i>1842</i>&nbsp;     * implementation which is where the actual selection is maintained.
<i>1843</i>&nbsp;     *
<i>1844</i>&nbsp;     * @param selectionStart the start position of the text &amp;ge; 0
<i>1845</i>&nbsp;     */
<i>1846</i>&nbsp;    @BeanProperty(bound = false, description
<i>1847</i>&nbsp;            = &quot;starting location of the selection.&quot;)
<i>1848</i>&nbsp;    public void setSelectionStart(int selectionStart) {
<i>1849</i>&nbsp;        /* Route through select method to enforce consistent policy
<i>1850</i>&nbsp;         * between selectionStart and selectionEnd.
<b class="nc"><i>1851</i>&nbsp;         */</b>
<b class="nc"><i>1852</i>&nbsp;        select(selectionStart, getSelectionEnd());</b>
<i>1853</i>&nbsp;    }
<i>1854</i>&nbsp;
<i>1855</i>&nbsp;    /**
<i>1856</i>&nbsp;     * Returns the selected text&#39;s end position.  Return 0 if the document
<i>1857</i>&nbsp;     * is empty, or the value of dot if there is no selection.
<i>1858</i>&nbsp;     *
<i>1859</i>&nbsp;     * @return the end position &amp;ge; 0
<i>1860</i>&nbsp;     */
<i>1861</i>&nbsp;    @Transient
<i>1862</i>&nbsp;    public int getSelectionEnd() {
<i>1863</i>&nbsp;        int end = Math.max(caret.getDot(), caret.getMark());
<i>1864</i>&nbsp;        return end;
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    /**
<i>1868</i>&nbsp;     * Sets the selection end to the specified position.  The new
<i>1869</i>&nbsp;     * end point is constrained to be at or after the current
<i>1870</i>&nbsp;     * selection start.
<i>1871</i>&nbsp;     * &lt;p&gt;
<i>1872</i>&nbsp;     * This is available for backward compatibility to code
<b class="nc"><i>1873</i>&nbsp;     * that called this method on &lt;code&gt;java.awt.TextComponent&lt;/code&gt;.</b>
<i>1874</i>&nbsp;     * This is implemented to forward to the &lt;code&gt;Caret&lt;/code&gt;
<i>1875</i>&nbsp;     * implementation which is where the actual selection is maintained.
<i>1876</i>&nbsp;     *
<i>1877</i>&nbsp;     * @param selectionEnd the end position of the text &amp;ge; 0
<i>1878</i>&nbsp;     */
<i>1879</i>&nbsp;    @BeanProperty(bound = false, description
<i>1880</i>&nbsp;            = &quot;ending location of the selection.&quot;)
<i>1881</i>&nbsp;    public void setSelectionEnd(int selectionEnd) {
<i>1882</i>&nbsp;        /* Route through select method to enforce consistent policy
<i>1883</i>&nbsp;         * between selectionStart and selectionEnd.
<i>1884</i>&nbsp;         */
<i>1885</i>&nbsp;        select(getSelectionStart(), selectionEnd);
<i>1886</i>&nbsp;    }
<i>1887</i>&nbsp;
<i>1888</i>&nbsp;    /**
<i>1889</i>&nbsp;     * Selects the text between the specified start and end positions.
<i>1890</i>&nbsp;     * &lt;p&gt;
<i>1891</i>&nbsp;     * This method sets the start and end positions of the
<i>1892</i>&nbsp;     * selected text, enforcing the restriction that the start position
<i>1893</i>&nbsp;     * must be greater than or equal to zero.  The end position must be
<i>1894</i>&nbsp;     * greater than or equal to the start position, and less than or
<i>1895</i>&nbsp;     * equal to the length of the text component&#39;s text.
<i>1896</i>&nbsp;     * &lt;p&gt;
<i>1897</i>&nbsp;     * If the caller supplies values that are inconsistent or out of
<i>1898</i>&nbsp;     * bounds, the method enforces these constraints silently, and
<i>1899</i>&nbsp;     * without failure. Specifically, if the start position or end
<i>1900</i>&nbsp;     * position is greater than the length of the text, it is reset to
<i>1901</i>&nbsp;     * equal the text length. If the start position is less than zero,
<i>1902</i>&nbsp;     * it is reset to zero, and if the end position is less than the
<i>1903</i>&nbsp;     * start position, it is reset to the start position.
<i>1904</i>&nbsp;     * &lt;p&gt;
<i>1905</i>&nbsp;     * This call is provided for backward compatibility.
<b class="nc"><i>1906</i>&nbsp;     * It is routed to a call to &lt;code&gt;setCaretPosition&lt;/code&gt;</b>
<i>1907</i>&nbsp;     * followed by a call to &lt;code&gt;moveCaretPosition&lt;/code&gt;.
<b class="nc"><i>1908</i>&nbsp;     * The preferred way to manage selection is by calling</b>
<b class="nc"><i>1909</i>&nbsp;     * those methods directly.</b>
<i>1910</i>&nbsp;     *
<b class="nc"><i>1911</i>&nbsp;     * @param selectionStart the start position of the text</b>
<b class="nc"><i>1912</i>&nbsp;     * @param selectionEnd the end position of the text</b>
<i>1913</i>&nbsp;     * @see #setCaretPosition
<b class="nc"><i>1914</i>&nbsp;     * @see #moveCaretPosition</b>
<b class="nc"><i>1915</i>&nbsp;     */</b>
<i>1916</i>&nbsp;    public void select(int selectionStart, int selectionEnd) {
<b class="nc"><i>1917</i>&nbsp;        // argument adjustment done by java.awt.TextComponent</b>
<b class="nc"><i>1918</i>&nbsp;        int docLength = getDocument().getLength();</b>
<i>1919</i>&nbsp;
<i>1920</i>&nbsp;        if (selectionStart &lt; 0) {
<b class="nc"><i>1921</i>&nbsp;            selectionStart = 0;</b>
<b class="nc"><i>1922</i>&nbsp;        }</b>
<i>1923</i>&nbsp;        if (selectionStart &gt; docLength) {
<i>1924</i>&nbsp;            selectionStart = docLength;
<i>1925</i>&nbsp;        }
<i>1926</i>&nbsp;        if (selectionEnd &gt; docLength) {
<i>1927</i>&nbsp;            selectionEnd = docLength;
<i>1928</i>&nbsp;        }
<i>1929</i>&nbsp;        if (selectionEnd &lt; selectionStart) {
<b class="nc"><i>1930</i>&nbsp;            selectionEnd = selectionStart;</b>
<b class="nc"><i>1931</i>&nbsp;        }</b>
<b class="nc"><i>1932</i>&nbsp;</b>
<b class="nc"><i>1933</i>&nbsp;        setCaretPosition(selectionStart);</b>
<i>1934</i>&nbsp;        moveCaretPosition(selectionEnd);
<i>1935</i>&nbsp;    }
<i>1936</i>&nbsp;
<i>1937</i>&nbsp;    /**
<i>1938</i>&nbsp;     * Selects all the text in the &lt;code&gt;TextComponent&lt;/code&gt;.
<i>1939</i>&nbsp;     * Does nothing on a &lt;code&gt;null&lt;/code&gt; or empty document.
<i>1940</i>&nbsp;     */
<i>1941</i>&nbsp;    public void selectAll() {
<i>1942</i>&nbsp;        Document doc = getDocument();
<i>1943</i>&nbsp;        if (doc != null) {
<i>1944</i>&nbsp;            setCaretPosition(0);
<i>1945</i>&nbsp;            moveCaretPosition(doc.getLength());
<i>1946</i>&nbsp;        }
<i>1947</i>&nbsp;    }
<i>1948</i>&nbsp;
<i>1949</i>&nbsp;    // --- Tooltip Methods ---------------------------------------------
<i>1950</i>&nbsp;
<i>1951</i>&nbsp;    /**
<i>1952</i>&nbsp;     * Returns the string to be used as the tooltip for &lt;code&gt;event&lt;/code&gt;.
<i>1953</i>&nbsp;     * This will return one of:
<i>1954</i>&nbsp;     * &lt;ol&gt;
<i>1955</i>&nbsp;     *  &lt;li&gt;If &lt;code&gt;setToolTipText&lt;/code&gt; has been invoked with a
<i>1956</i>&nbsp;     *      non-&lt;code&gt;null&lt;/code&gt;
<i>1957</i>&nbsp;     *      value, it will be returned, otherwise
<i>1958</i>&nbsp;     *  &lt;li&gt;The value from invoking &lt;code&gt;getToolTipText&lt;/code&gt; on
<i>1959</i>&nbsp;     *      the UI will be returned.
<i>1960</i>&nbsp;     * &lt;/ol&gt;
<i>1961</i>&nbsp;     * By default &lt;code&gt;JTextComponent&lt;/code&gt; does not register
<b class="nc"><i>1962</i>&nbsp;     * itself with the &lt;code&gt;ToolTipManager&lt;/code&gt;.</b>
<i>1963</i>&nbsp;     * This means that tooltips will NOT be shown from the
<b class="nc"><i>1964</i>&nbsp;     * &lt;code&gt;TextUI&lt;/code&gt; unless &lt;code&gt;registerComponent&lt;/code&gt; has</b>
<b class="nc"><i>1965</i>&nbsp;     * been invoked on the &lt;code&gt;ToolTipManager&lt;/code&gt;.</b>
<b class="nc"><i>1966</i>&nbsp;     *</b>
<b class="nc"><i>1967</i>&nbsp;     * @param event the event in question</b>
<b class="nc"><i>1968</i>&nbsp;     * @return the string to be used as the tooltip for &lt;code&gt;event&lt;/code&gt;</b>
<i>1969</i>&nbsp;     * @see javax.swing.JComponent#setToolTipText
<i>1970</i>&nbsp;     * @see javax.swing.plaf.TextUI#getToolTipText
<b class="nc"><i>1971</i>&nbsp;     * @see javax.swing.ToolTipManager#registerComponent</b>
<i>1972</i>&nbsp;     */
<i>1973</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>1974</i>&nbsp;    public String getToolTipText(MouseEvent event) {
<i>1975</i>&nbsp;        String retValue = super.getToolTipText(event);
<i>1976</i>&nbsp;
<i>1977</i>&nbsp;        if (retValue == null) {
<i>1978</i>&nbsp;            TextUI ui = getUI();
<i>1979</i>&nbsp;            if (ui != null) {
<i>1980</i>&nbsp;                retValue = ui.getToolTipText(this, new Point(event.getX(),
<i>1981</i>&nbsp;                                                             event.getY()));
<i>1982</i>&nbsp;            }
<i>1983</i>&nbsp;        }
<i>1984</i>&nbsp;        return retValue;
<b class="nc"><i>1985</i>&nbsp;    }</b>
<i>1986</i>&nbsp;
<i>1987</i>&nbsp;    // --- Scrollable methods ---------------------------------------------
<i>1988</i>&nbsp;
<i>1989</i>&nbsp;    /**
<i>1990</i>&nbsp;     * Returns the preferred size of the viewport for a view component.
<i>1991</i>&nbsp;     * This is implemented to do the default behavior of returning
<i>1992</i>&nbsp;     * the preferred size of the component.
<i>1993</i>&nbsp;     *
<i>1994</i>&nbsp;     * @return the &lt;code&gt;preferredSize&lt;/code&gt; of a &lt;code&gt;JViewport&lt;/code&gt;
<i>1995</i>&nbsp;     * whose view is this &lt;code&gt;Scrollable&lt;/code&gt;
<i>1996</i>&nbsp;     */
<i>1997</i>&nbsp;    @BeanProperty(bound = false)
<i>1998</i>&nbsp;    public Dimension getPreferredScrollableViewportSize() {
<i>1999</i>&nbsp;        return getPreferredSize();
<i>2000</i>&nbsp;    }
<i>2001</i>&nbsp;
<i>2002</i>&nbsp;
<i>2003</i>&nbsp;    /**
<i>2004</i>&nbsp;     * Components that display logical rows or columns should compute
<i>2005</i>&nbsp;     * the scroll increment that will completely expose one new row
<i>2006</i>&nbsp;     * or column, depending on the value of orientation.  Ideally,
<i>2007</i>&nbsp;     * components should handle a partially exposed row or column by
<i>2008</i>&nbsp;     * returning the distance required to completely expose the item.
<i>2009</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2010</i>&nbsp;     * The default implementation of this is to simply return 10% of</b>
<i>2011</i>&nbsp;     * the visible area.  Subclasses are likely to be able to provide
<b class="nc"><i>2012</i>&nbsp;     * a much more reasonable value.</b>
<i>2013</i>&nbsp;     *
<b class="nc"><i>2014</i>&nbsp;     * @param visibleRect the view area visible within the viewport</b>
<i>2015</i>&nbsp;     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
<b class="nc"><i>2016</i>&nbsp;     *   &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;</b>
<i>2017</i>&nbsp;     * @param direction less than zero to scroll up/left, greater than
<i>2018</i>&nbsp;     *   zero for down/right
<i>2019</i>&nbsp;     * @return the &quot;unit&quot; increment for scrolling in the specified direction
<i>2020</i>&nbsp;     * @exception IllegalArgumentException for an invalid orientation
<i>2021</i>&nbsp;     * @see JScrollBar#setUnitIncrement
<i>2022</i>&nbsp;     */
<i>2023</i>&nbsp;    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
<i>2024</i>&nbsp;        switch(orientation) {
<i>2025</i>&nbsp;        case SwingConstants.VERTICAL:
<i>2026</i>&nbsp;            return visibleRect.height / 10;
<i>2027</i>&nbsp;        case SwingConstants.HORIZONTAL:
<i>2028</i>&nbsp;            return visibleRect.width / 10;
<i>2029</i>&nbsp;        default:
<i>2030</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid orientation: &quot; + orientation);
<i>2031</i>&nbsp;        }
<i>2032</i>&nbsp;    }
<i>2033</i>&nbsp;
<i>2034</i>&nbsp;
<i>2035</i>&nbsp;    /**
<i>2036</i>&nbsp;     * Components that display logical rows or columns should compute
<i>2037</i>&nbsp;     * the scroll increment that will completely expose one block
<i>2038</i>&nbsp;     * of rows or columns, depending on the value of orientation.
<i>2039</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>2040</i>&nbsp;     * The default implementation of this is to simply return the visible</b>
<i>2041</i>&nbsp;     * area.  Subclasses will likely be able to provide a much more
<b class="nc"><i>2042</i>&nbsp;     * reasonable value.</b>
<i>2043</i>&nbsp;     *
<b class="nc"><i>2044</i>&nbsp;     * @param visibleRect the view area visible within the viewport</b>
<i>2045</i>&nbsp;     * @param orientation either &lt;code&gt;SwingConstants.VERTICAL&lt;/code&gt; or
<b class="nc"><i>2046</i>&nbsp;     *   &lt;code&gt;SwingConstants.HORIZONTAL&lt;/code&gt;</b>
<i>2047</i>&nbsp;     * @param direction less than zero to scroll up/left, greater than zero
<i>2048</i>&nbsp;     *  for down/right
<i>2049</i>&nbsp;     * @return the &quot;block&quot; increment for scrolling in the specified direction
<i>2050</i>&nbsp;     * @exception IllegalArgumentException for an invalid orientation
<i>2051</i>&nbsp;     * @see JScrollBar#setBlockIncrement
<i>2052</i>&nbsp;     */
<i>2053</i>&nbsp;    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
<i>2054</i>&nbsp;        switch(orientation) {
<i>2055</i>&nbsp;        case SwingConstants.VERTICAL:
<i>2056</i>&nbsp;            return visibleRect.height;
<i>2057</i>&nbsp;        case SwingConstants.HORIZONTAL:
<i>2058</i>&nbsp;            return visibleRect.width;
<i>2059</i>&nbsp;        default:
<i>2060</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid orientation: &quot; + orientation);
<i>2061</i>&nbsp;        }
<i>2062</i>&nbsp;    }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;
<i>2065</i>&nbsp;    /**
<i>2066</i>&nbsp;     * Returns true if a viewport should always force the width of this
<i>2067</i>&nbsp;     * &lt;code&gt;Scrollable&lt;/code&gt; to match the width of the viewport.
<b class="nc"><i>2068</i>&nbsp;     * For example a normal text view that supported line wrapping</b>
<b class="nc"><i>2069</i>&nbsp;     * would return true here, since it would be undesirable for</b>
<b class="nc"><i>2070</i>&nbsp;     * wrapped lines to disappear beyond the right</b>
<i>2071</i>&nbsp;     * edge of the viewport.  Note that returning true for a
<b class="nc"><i>2072</i>&nbsp;     * &lt;code&gt;Scrollable&lt;/code&gt; whose ancestor is a &lt;code&gt;JScrollPane&lt;/code&gt;</b>
<i>2073</i>&nbsp;     * effectively disables horizontal scrolling.
<i>2074</i>&nbsp;     * &lt;p&gt;
<i>2075</i>&nbsp;     * Scrolling containers, like &lt;code&gt;JViewport&lt;/code&gt;,
<i>2076</i>&nbsp;     * will use this method each time they are validated.
<i>2077</i>&nbsp;     *
<i>2078</i>&nbsp;     * @return true if a viewport should force the &lt;code&gt;Scrollable&lt;/code&gt;s
<i>2079</i>&nbsp;     *   width to match its own
<i>2080</i>&nbsp;     */
<i>2081</i>&nbsp;    @BeanProperty(bound = false)
<i>2082</i>&nbsp;    public boolean getScrollableTracksViewportWidth() {
<i>2083</i>&nbsp;        Container parent = SwingUtilities.getUnwrappedParent(this);
<i>2084</i>&nbsp;        if (parent instanceof JViewport) {
<i>2085</i>&nbsp;            return parent.getWidth() &gt; getPreferredSize().width;
<i>2086</i>&nbsp;        }
<i>2087</i>&nbsp;        return false;
<i>2088</i>&nbsp;    }
<b class="nc"><i>2089</i>&nbsp;</b>
<b class="nc"><i>2090</i>&nbsp;    /**</b>
<b class="nc"><i>2091</i>&nbsp;     * Returns true if a viewport should always force the height of this</b>
<i>2092</i>&nbsp;     * &lt;code&gt;Scrollable&lt;/code&gt; to match the height of the viewport.
<b class="nc"><i>2093</i>&nbsp;     * For example a columnar text view that flowed text in left to</b>
<i>2094</i>&nbsp;     * right columns could effectively disable vertical scrolling by
<i>2095</i>&nbsp;     * returning true here.
<i>2096</i>&nbsp;     * &lt;p&gt;
<i>2097</i>&nbsp;     * Scrolling containers, like &lt;code&gt;JViewport&lt;/code&gt;,
<i>2098</i>&nbsp;     * will use this method each time they are validated.
<i>2099</i>&nbsp;     *
<i>2100</i>&nbsp;     * @return true if a viewport should force the Scrollables height
<i>2101</i>&nbsp;     *   to match its own
<i>2102</i>&nbsp;     */
<i>2103</i>&nbsp;    @BeanProperty(bound = false)
<i>2104</i>&nbsp;    public boolean getScrollableTracksViewportHeight() {
<i>2105</i>&nbsp;        Container parent = SwingUtilities.getUnwrappedParent(this);
<i>2106</i>&nbsp;        if (parent instanceof JViewport) {
<i>2107</i>&nbsp;            return parent.getHeight() &gt; getPreferredSize().height;
<i>2108</i>&nbsp;        }
<i>2109</i>&nbsp;        return false;
<i>2110</i>&nbsp;    }
<i>2111</i>&nbsp;
<i>2112</i>&nbsp;
<i>2113</i>&nbsp;//////////////////
<i>2114</i>&nbsp;// Printing Support
<i>2115</i>&nbsp;//////////////////
<i>2116</i>&nbsp;
<i>2117</i>&nbsp;    /**
<i>2118</i>&nbsp;     * A convenience print method that displays a print dialog, and then
<i>2119</i>&nbsp;     * prints this {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode with no
<i>2120</i>&nbsp;     * header or footer text. Note: this method
<i>2121</i>&nbsp;     * blocks until printing is done.
<i>2122</i>&nbsp;     * &lt;p&gt;
<i>2123</i>&nbsp;     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, no dialogs will be shown.
<b class="nc"><i>2124</i>&nbsp;     *</b>
<i>2125</i>&nbsp;     * &lt;p&gt; This method calls the full featured
<i>2126</i>&nbsp;     * {@link #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
<i>2127</i>&nbsp;     * print} method to perform printing.
<i>2128</i>&nbsp;     * @return {@code true}, unless printing is canceled by the user
<i>2129</i>&nbsp;     * @throws PrinterException if an error in the print system causes the job
<i>2130</i>&nbsp;     *         to be aborted
<i>2131</i>&nbsp;     * @throws SecurityException if this thread is not allowed to
<i>2132</i>&nbsp;     *                           initiate a print job request
<i>2133</i>&nbsp;     *
<i>2134</i>&nbsp;     * @see #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
<i>2135</i>&nbsp;     *
<i>2136</i>&nbsp;     * @since 1.6
<i>2137</i>&nbsp;     */
<i>2138</i>&nbsp;
<i>2139</i>&nbsp;    public boolean print() throws PrinterException {
<i>2140</i>&nbsp;        return print(null, null, true, null, null, true);
<i>2141</i>&nbsp;    }
<i>2142</i>&nbsp;
<i>2143</i>&nbsp;    /**
<i>2144</i>&nbsp;     * A convenience print method that displays a print dialog, and then
<i>2145</i>&nbsp;     * prints this {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode with
<i>2146</i>&nbsp;     * the specified header and footer text. Note: this method
<i>2147</i>&nbsp;     * blocks until printing is done.
<i>2148</i>&nbsp;     * &lt;p&gt;
<i>2149</i>&nbsp;     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, no dialogs will be shown.
<i>2150</i>&nbsp;     *
<i>2151</i>&nbsp;     * &lt;p&gt; This method calls the full featured
<i>2152</i>&nbsp;     * {@link #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
<i>2153</i>&nbsp;     * print} method to perform printing.
<b class="nc"><i>2154</i>&nbsp;     * @param headerFormat the text, in {@code MessageFormat}, to be</b>
<i>2155</i>&nbsp;     *        used as the header, or {@code null} for no header
<i>2156</i>&nbsp;     * @param footerFormat the text, in {@code MessageFormat}, to be
<i>2157</i>&nbsp;     *        used as the footer, or {@code null} for no footer
<i>2158</i>&nbsp;     * @return {@code true}, unless printing is canceled by the user
<i>2159</i>&nbsp;     * @throws PrinterException if an error in the print system causes the job
<i>2160</i>&nbsp;     *         to be aborted
<i>2161</i>&nbsp;     * @throws SecurityException if this thread is not allowed to
<i>2162</i>&nbsp;     *                           initiate a print job request
<i>2163</i>&nbsp;     *
<i>2164</i>&nbsp;     * @see #print(MessageFormat, MessageFormat, boolean, PrintService, PrintRequestAttributeSet, boolean)
<i>2165</i>&nbsp;     * @see java.text.MessageFormat
<i>2166</i>&nbsp;     * @since 1.6
<i>2167</i>&nbsp;     */
<i>2168</i>&nbsp;    public boolean print(final MessageFormat headerFormat,
<i>2169</i>&nbsp;            final MessageFormat footerFormat) throws PrinterException {
<i>2170</i>&nbsp;        return print(headerFormat, footerFormat, true, null, null, true);
<i>2171</i>&nbsp;    }
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;    /**
<i>2174</i>&nbsp;     * Prints the content of this {@code JTextComponent}. Note: this method
<i>2175</i>&nbsp;     * blocks until printing is done.
<i>2176</i>&nbsp;     *
<i>2177</i>&nbsp;     * &lt;p&gt;
<i>2178</i>&nbsp;     * Page header and footer text can be added to the output by providing
<i>2179</i>&nbsp;     * {@code MessageFormat} arguments. The printing code requests
<i>2180</i>&nbsp;     * {@code Strings} from the formats, providing a single item which may be
<i>2181</i>&nbsp;     * included in the formatted string: an {@code Integer} representing the
<i>2182</i>&nbsp;     * current page number.
<i>2183</i>&nbsp;     *
<i>2184</i>&nbsp;     * &lt;p&gt;
<i>2185</i>&nbsp;     * {@code showPrintDialog boolean} parameter allows you to specify whether
<i>2186</i>&nbsp;     * a print dialog is displayed to the user. When it is, the user
<i>2187</i>&nbsp;     * may use the dialog to change printing attributes or even cancel the
<i>2188</i>&nbsp;     * print.
<i>2189</i>&nbsp;     *
<i>2190</i>&nbsp;     * &lt;p&gt;
<i>2191</i>&nbsp;     * {@code service} allows you to provide the initial
<i>2192</i>&nbsp;     * {@code PrintService} for the print dialog, or to specify
<i>2193</i>&nbsp;     * {@code PrintService} to print to when the dialog is not shown.
<i>2194</i>&nbsp;     *
<i>2195</i>&nbsp;     * &lt;p&gt;
<i>2196</i>&nbsp;     * {@code attributes} can be used to provide the
<i>2197</i>&nbsp;     * initial values for the print dialog, or to supply any needed
<i>2198</i>&nbsp;     * attributes when the dialog is not shown. {@code attributes} can
<i>2199</i>&nbsp;     * be used to control how the job will print, for example
<i>2200</i>&nbsp;     * &lt;i&gt;duplex&lt;/i&gt; or &lt;i&gt;single-sided&lt;/i&gt;.
<i>2201</i>&nbsp;     *
<i>2202</i>&nbsp;     * &lt;p&gt;
<i>2203</i>&nbsp;     * {@code interactive boolean} parameter allows you to specify
<i>2204</i>&nbsp;     * whether to perform printing in &lt;i&gt;interactive&lt;/i&gt;
<i>2205</i>&nbsp;     * mode. If {@code true}, a progress dialog, with an abort option,
<i>2206</i>&nbsp;     * is displayed for the duration of printing.  This dialog is
<i>2207</i>&nbsp;     * &lt;i&gt;modal&lt;/i&gt; when {@code print} is invoked on the &lt;i&gt;Event Dispatch
<i>2208</i>&nbsp;     * Thread&lt;/i&gt; and &lt;i&gt;non-modal&lt;/i&gt; otherwise. &lt;b&gt;Warning&lt;/b&gt;:
<i>2209</i>&nbsp;     * calling this method on the &lt;i&gt;Event Dispatch Thread&lt;/i&gt; with {@code
<i>2210</i>&nbsp;     * interactive false} blocks &lt;i&gt;all&lt;/i&gt; events, including repaints, from
<i>2211</i>&nbsp;     * being processed until printing is complete. It is only
<i>2212</i>&nbsp;     * recommended when printing from an application with no
<i>2213</i>&nbsp;     * visible GUI.
<i>2214</i>&nbsp;     *
<i>2215</i>&nbsp;     * &lt;p&gt;
<i>2216</i>&nbsp;     * Note: In &lt;i&gt;headless&lt;/i&gt; mode, {@code showPrintDialog} and
<i>2217</i>&nbsp;     * {@code interactive} parameters are ignored and no dialogs are
<i>2218</i>&nbsp;     * shown.
<i>2219</i>&nbsp;     *
<i>2220</i>&nbsp;     * &lt;p&gt;
<i>2221</i>&nbsp;     * This method ensures the {@code document} is not mutated during printing.
<i>2222</i>&nbsp;     * To indicate it visually, {@code setEnabled(false)} is set for the
<i>2223</i>&nbsp;     * duration of printing.
<i>2224</i>&nbsp;     *
<i>2225</i>&nbsp;     * &lt;p&gt;
<i>2226</i>&nbsp;     * This method uses {@link #getPrintable} to render document content.
<i>2227</i>&nbsp;     *
<i>2228</i>&nbsp;     * &lt;p&gt;
<i>2229</i>&nbsp;     * This method is thread-safe, although most Swing methods are not. Please
<i>2230</i>&nbsp;     * see &lt;A
<i>2231</i>&nbsp;     * HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;
<i>2232</i>&nbsp;     * Concurrency in Swing&lt;/A&gt; for more information.
<i>2233</i>&nbsp;     *
<i>2234</i>&nbsp;     * &lt;p&gt;
<i>2235</i>&nbsp;     * &lt;b&gt;Sample Usage&lt;/b&gt;. This code snippet shows a cross-platform print
<i>2236</i>&nbsp;     * dialog and then prints the {@code JTextComponent} in &lt;i&gt;interactive&lt;/i&gt; mode
<i>2237</i>&nbsp;     * unless the user cancels the dialog:
<i>2238</i>&nbsp;     *
<i>2239</i>&nbsp;     * &lt;pre&gt;
<i>2240</i>&nbsp;     * textComponent.print(new MessageFormat(&amp;quot;My text component header&amp;quot;),
<i>2241</i>&nbsp;     *     new MessageFormat(&amp;quot;Footer. Page - {0}&amp;quot;), true, null, null, true);
<i>2242</i>&nbsp;     * &lt;/pre&gt;
<i>2243</i>&nbsp;     * &lt;p&gt;
<i>2244</i>&nbsp;     * Executing this code off the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;
<i>2245</i>&nbsp;     * performs printing on the &lt;i&gt;background&lt;/i&gt;.
<i>2246</i>&nbsp;     * The following pattern might be used for &lt;i&gt;background&lt;/i&gt;
<i>2247</i>&nbsp;     * printing:
<i>2248</i>&nbsp;     * &lt;pre&gt;
<i>2249</i>&nbsp;     *     FutureTask&amp;lt;Boolean&amp;gt; future =
<i>2250</i>&nbsp;     *         new FutureTask&amp;lt;Boolean&amp;gt;(
<i>2251</i>&nbsp;     *             new Callable&amp;lt;Boolean&amp;gt;() {
<i>2252</i>&nbsp;     *                 public Boolean call() {
<i>2253</i>&nbsp;     *                     return textComponent.print(.....);
<i>2254</i>&nbsp;     *                 }
<i>2255</i>&nbsp;     *             });
<i>2256</i>&nbsp;     *     executor.execute(future);
<i>2257</i>&nbsp;     * &lt;/pre&gt;
<i>2258</i>&nbsp;     *
<i>2259</i>&nbsp;     * @param headerFormat the text, in {@code MessageFormat}, to be
<i>2260</i>&nbsp;     *        used as the header, or {@code null} for no header
<i>2261</i>&nbsp;     * @param footerFormat the text, in {@code MessageFormat}, to be
<i>2262</i>&nbsp;     *        used as the footer, or {@code null} for no footer
<i>2263</i>&nbsp;     * @param showPrintDialog {@code true} to display a print dialog,
<i>2264</i>&nbsp;     *        {@code false} otherwise
<i>2265</i>&nbsp;     * @param service initial {@code PrintService}, or {@code null} for the
<i>2266</i>&nbsp;     *        default
<i>2267</i>&nbsp;     * @param attributes the job attributes to be applied to the print job, or
<i>2268</i>&nbsp;     *        {@code null} for none
<i>2269</i>&nbsp;     * @param interactive whether to print in an interactive mode
<i>2270</i>&nbsp;     * @return {@code true}, unless printing is canceled by the user
<i>2271</i>&nbsp;     * @throws PrinterException if an error in the print system causes the job
<i>2272</i>&nbsp;     *         to be aborted
<i>2273</i>&nbsp;     * @throws SecurityException if this thread is not allowed to
<i>2274</i>&nbsp;     *                           initiate a print job request
<b class="nc"><i>2275</i>&nbsp;     *</b>
<i>2276</i>&nbsp;     * @see #getPrintable
<i>2277</i>&nbsp;     * @see java.text.MessageFormat
<b class="nc"><i>2278</i>&nbsp;     * @see java.awt.GraphicsEnvironment#isHeadless</b>
<i>2279</i>&nbsp;     * @see java.util.concurrent.FutureTask
<b class="nc"><i>2280</i>&nbsp;     *</b>
<b class="nc"><i>2281</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>2282</i>&nbsp;     */</b>
<b class="nc"><i>2283</i>&nbsp;    public boolean print(final MessageFormat headerFormat,</b>
<b class="nc"><i>2284</i>&nbsp;            final MessageFormat footerFormat,</b>
<b class="nc"><i>2285</i>&nbsp;            final boolean showPrintDialog,</b>
<b class="nc"><i>2286</i>&nbsp;            final PrintService service,</b>
<i>2287</i>&nbsp;            final PrintRequestAttributeSet attributes,
<b class="nc"><i>2288</i>&nbsp;            final boolean interactive)</b>
<b class="nc"><i>2289</i>&nbsp;            throws PrinterException {</b>
<i>2290</i>&nbsp;
<i>2291</i>&nbsp;        final PrinterJob job = PrinterJob.getPrinterJob();
<b class="nc"><i>2292</i>&nbsp;        final Printable printable;</b>
<b class="nc"><i>2293</i>&nbsp;        final PrintingStatus printingStatus;</b>
<i>2294</i>&nbsp;        final boolean isHeadless = GraphicsEnvironment.isHeadless();
<i>2295</i>&nbsp;        final boolean isEventDispatchThread =
<b class="nc"><i>2296</i>&nbsp;            SwingUtilities.isEventDispatchThread();</b>
<i>2297</i>&nbsp;        final Printable textPrintable = getPrintable(headerFormat, footerFormat);
<b class="nc"><i>2298</i>&nbsp;        if (interactive &amp;&amp; ! isHeadless) {</b>
<i>2299</i>&nbsp;            printingStatus =
<i>2300</i>&nbsp;                PrintingStatus.createPrintingStatus(this, job);
<i>2301</i>&nbsp;            printable =
<b class="nc"><i>2302</i>&nbsp;                printingStatus.createNotificationPrintable(textPrintable);</b>
<b class="nc"><i>2303</i>&nbsp;        } else {</b>
<i>2304</i>&nbsp;            printingStatus = null;
<i>2305</i>&nbsp;            printable = textPrintable;
<i>2306</i>&nbsp;        }
<i>2307</i>&nbsp;
<i>2308</i>&nbsp;        if (service != null) {
<i>2309</i>&nbsp;            job.setPrintService(service);
<i>2310</i>&nbsp;        }
<i>2311</i>&nbsp;
<i>2312</i>&nbsp;        job.setPrintable(printable);
<i>2313</i>&nbsp;
<i>2314</i>&nbsp;        final PrintRequestAttributeSet attr = (attributes == null)
<b class="nc"><i>2315</i>&nbsp;            ? new HashPrintRequestAttributeSet()</b>
<b class="nc"><i>2316</i>&nbsp;            : attributes;</b>
<i>2317</i>&nbsp;
<i>2318</i>&nbsp;        if (showPrintDialog &amp;&amp; ! isHeadless &amp;&amp; ! job.printDialog(attr)) {
<b class="nc"><i>2319</i>&nbsp;            return false;</b>
<i>2320</i>&nbsp;        }
<b class="nc"><i>2321</i>&nbsp;</b>
<b class="nc"><i>2322</i>&nbsp;        /*</b>
<i>2323</i>&nbsp;         * there are three cases for printing:
<i>2324</i>&nbsp;         * 1. print non interactively (! interactive || isHeadless)
<b class="nc"><i>2325</i>&nbsp;         * 2. print interactively off EDT</b>
<i>2326</i>&nbsp;         * 3. print interactively on EDT
<i>2327</i>&nbsp;         *
<i>2328</i>&nbsp;         * 1 and 2 prints on the current thread (3 prints on another thread)
<b class="nc"><i>2329</i>&nbsp;         * 2 and 3 deal with PrintingStatusDialog</b>
<i>2330</i>&nbsp;         */
<i>2331</i>&nbsp;        final Callable&lt;Object&gt; doPrint =
<b class="nc"><i>2332</i>&nbsp;            new Callable&lt;Object&gt;() {</b>
<b class="nc"><i>2333</i>&nbsp;                public Object call() throws Exception {</b>
<i>2334</i>&nbsp;                    try {
<i>2335</i>&nbsp;                        job.print(attr);
<b class="nc"><i>2336</i>&nbsp;                    } finally {</b>
<b class="nc"><i>2337</i>&nbsp;                        if (printingStatus != null) {</b>
<b class="nc"><i>2338</i>&nbsp;                            printingStatus.dispose();</b>
<b class="nc"><i>2339</i>&nbsp;                        }</b>
<b class="nc"><i>2340</i>&nbsp;                    }</b>
<i>2341</i>&nbsp;                    return null;
<i>2342</i>&nbsp;                }
<i>2343</i>&nbsp;            };
<b class="nc"><i>2344</i>&nbsp;</b>
<b class="nc"><i>2345</i>&nbsp;        final FutureTask&lt;Object&gt; futurePrinting =</b>
<i>2346</i>&nbsp;            new FutureTask&lt;Object&gt;(doPrint);
<b class="nc"><i>2347</i>&nbsp;</b>
<b class="nc"><i>2348</i>&nbsp;        final Runnable runnablePrinting =</b>
<b class="nc"><i>2349</i>&nbsp;            new Runnable() {</b>
<i>2350</i>&nbsp;                public void run() {
<b class="nc"><i>2351</i>&nbsp;                    //disable component</b>
<i>2352</i>&nbsp;                    boolean wasEnabled = false;
<b class="nc"><i>2353</i>&nbsp;                    if (isEventDispatchThread) {</b>
<b class="nc"><i>2354</i>&nbsp;                        if (isEnabled()) {</b>
<b class="nc"><i>2355</i>&nbsp;                            wasEnabled = true;</b>
<b class="nc"><i>2356</i>&nbsp;                            setEnabled(false);</b>
<b class="nc"><i>2357</i>&nbsp;                        }</b>
<b class="nc"><i>2358</i>&nbsp;                    } else {</b>
<b class="nc"><i>2359</i>&nbsp;                        try {</b>
<i>2360</i>&nbsp;                            wasEnabled = SwingUtilities2.submit(
<b class="nc"><i>2361</i>&nbsp;                                new Callable&lt;Boolean&gt;() {</b>
<b class="nc"><i>2362</i>&nbsp;                                    public Boolean call() throws Exception {</b>
<i>2363</i>&nbsp;                                        boolean rv = isEnabled();
<b class="nc"><i>2364</i>&nbsp;                                        if (rv) {</b>
<b class="nc"><i>2365</i>&nbsp;                                            setEnabled(false);</b>
<i>2366</i>&nbsp;                                        }
<i>2367</i>&nbsp;                                        return rv;
<b class="nc"><i>2368</i>&nbsp;                                    }</b>
<i>2369</i>&nbsp;                                }).get();
<i>2370</i>&nbsp;                        } catch (InterruptedException e) {
<b class="nc"><i>2371</i>&nbsp;                            throw new RuntimeException(e);</b>
<b class="nc"><i>2372</i>&nbsp;                        } catch (ExecutionException e) {</b>
<b class="nc"><i>2373</i>&nbsp;                            Throwable cause = e.getCause();</b>
<i>2374</i>&nbsp;                            if (cause instanceof Error) {
<i>2375</i>&nbsp;                                throw (Error) cause;
<b class="nc"><i>2376</i>&nbsp;                            }</b>
<b class="nc"><i>2377</i>&nbsp;                            if (cause instanceof RuntimeException) {</b>
<i>2378</i>&nbsp;                                throw (RuntimeException) cause;
<b class="nc"><i>2379</i>&nbsp;                            }</b>
<i>2380</i>&nbsp;                            throw new AssertionError(cause);
<b class="nc"><i>2381</i>&nbsp;                        }</b>
<b class="nc"><i>2382</i>&nbsp;                    }</b>
<b class="nc"><i>2383</i>&nbsp;</b>
<b class="nc"><i>2384</i>&nbsp;                    getDocument().render(futurePrinting);</b>
<b class="nc"><i>2385</i>&nbsp;</b>
<b class="nc"><i>2386</i>&nbsp;                    //enable component</b>
<b class="nc"><i>2387</i>&nbsp;                    if (wasEnabled) {</b>
<i>2388</i>&nbsp;                        if (isEventDispatchThread) {
<b class="nc"><i>2389</i>&nbsp;                            setEnabled(true);</b>
<b class="nc"><i>2390</i>&nbsp;                        } else {</b>
<i>2391</i>&nbsp;                            try {
<b class="nc"><i>2392</i>&nbsp;                                SwingUtilities2.submit(</b>
<b class="nc"><i>2393</i>&nbsp;                                    new Runnable() {</b>
<i>2394</i>&nbsp;                                        public void run() {
<i>2395</i>&nbsp;                                            setEnabled(true);
<i>2396</i>&nbsp;                                        }
<i>2397</i>&nbsp;                                    }, null).get();
<i>2398</i>&nbsp;                            } catch (InterruptedException e) {
<b class="nc"><i>2399</i>&nbsp;                                throw new RuntimeException(e);</b>
<b class="nc"><i>2400</i>&nbsp;                            } catch (ExecutionException e) {</b>
<i>2401</i>&nbsp;                                Throwable cause = e.getCause();
<b class="nc"><i>2402</i>&nbsp;                                if (cause instanceof Error) {</b>
<b class="nc"><i>2403</i>&nbsp;                                    throw (Error) cause;</b>
<b class="nc"><i>2404</i>&nbsp;                                }</b>
<i>2405</i>&nbsp;                                if (cause instanceof RuntimeException) {
<b class="nc"><i>2406</i>&nbsp;                                    throw (RuntimeException) cause;</b>
<b class="nc"><i>2407</i>&nbsp;                                }</b>
<i>2408</i>&nbsp;                                throw new AssertionError(cause);
<i>2409</i>&nbsp;                            }
<i>2410</i>&nbsp;                        }
<i>2411</i>&nbsp;                    }
<i>2412</i>&nbsp;                }
<i>2413</i>&nbsp;            };
<b class="nc"><i>2414</i>&nbsp;</b>
<b class="nc"><i>2415</i>&nbsp;        if (! interactive || isHeadless) {</b>
<b class="nc"><i>2416</i>&nbsp;            runnablePrinting.run();</b>
<b class="nc"><i>2417</i>&nbsp;        } else {</b>
<b class="nc"><i>2418</i>&nbsp;            if (isEventDispatchThread) {</b>
<b class="nc"><i>2419</i>&nbsp;                new Thread(null, runnablePrinting,</b>
<b class="nc"><i>2420</i>&nbsp;                           &quot;JTextComponentPrint&quot;, 0, false ).start();</b>
<b class="nc"><i>2421</i>&nbsp;                printingStatus.showModal(true);</b>
<b class="nc"><i>2422</i>&nbsp;            } else {</b>
<i>2423</i>&nbsp;                printingStatus.showModal(false);
<b class="nc"><i>2424</i>&nbsp;                runnablePrinting.run();</b>
<i>2425</i>&nbsp;            }
<b class="nc"><i>2426</i>&nbsp;        }</b>
<b class="nc"><i>2427</i>&nbsp;</b>
<b class="nc"><i>2428</i>&nbsp;        //the printing is done successfully or otherwise.</b>
<b class="nc"><i>2429</i>&nbsp;        //dialog is hidden if needed.</b>
<b class="nc"><i>2430</i>&nbsp;        try {</b>
<b class="nc"><i>2431</i>&nbsp;            futurePrinting.get();</b>
<i>2432</i>&nbsp;        } catch (InterruptedException e) {
<b class="nc"><i>2433</i>&nbsp;            throw new RuntimeException(e);</b>
<i>2434</i>&nbsp;        } catch (ExecutionException e) {
<b class="nc"><i>2435</i>&nbsp;            Throwable cause = e.getCause();</b>
<b class="nc"><i>2436</i>&nbsp;            if (cause instanceof PrinterAbortException) {</b>
<i>2437</i>&nbsp;                if (printingStatus != null
<i>2438</i>&nbsp;                    &amp;&amp; printingStatus.isAborted()) {
<i>2439</i>&nbsp;                    return false;
<i>2440</i>&nbsp;                } else {
<i>2441</i>&nbsp;                    throw (PrinterAbortException) cause;
<i>2442</i>&nbsp;                }
<i>2443</i>&nbsp;            } else if (cause instanceof PrinterException) {
<i>2444</i>&nbsp;                throw (PrinterException) cause;
<i>2445</i>&nbsp;            } else if (cause instanceof RuntimeException) {
<i>2446</i>&nbsp;                throw (RuntimeException) cause;
<i>2447</i>&nbsp;            } else if (cause instanceof Error) {
<i>2448</i>&nbsp;                throw (Error) cause;
<i>2449</i>&nbsp;            } else {
<i>2450</i>&nbsp;                throw new AssertionError(cause);
<i>2451</i>&nbsp;            }
<i>2452</i>&nbsp;        }
<i>2453</i>&nbsp;        return true;
<i>2454</i>&nbsp;    }
<i>2455</i>&nbsp;
<i>2456</i>&nbsp;
<i>2457</i>&nbsp;    /**
<i>2458</i>&nbsp;     * Returns a {@code Printable} to use for printing the content of this
<i>2459</i>&nbsp;     * {@code JTextComponent}. The returned {@code Printable} prints
<i>2460</i>&nbsp;     * the document as it looks on the screen except being reformatted
<i>2461</i>&nbsp;     * to fit the paper.
<i>2462</i>&nbsp;     * The returned {@code Printable} can be wrapped inside another
<i>2463</i>&nbsp;     * {@code Printable} in order to create complex reports and
<i>2464</i>&nbsp;     * documents.
<i>2465</i>&nbsp;     *
<i>2466</i>&nbsp;     *
<i>2467</i>&nbsp;     * &lt;p&gt;
<i>2468</i>&nbsp;     * The returned {@code Printable} shares the {@code document} with this
<i>2469</i>&nbsp;     * {@code JTextComponent}. It is the responsibility of the developer to
<i>2470</i>&nbsp;     * ensure that the {@code document} is not mutated while this {@code Printable}
<i>2471</i>&nbsp;     * is used. Printing behavior is undefined when the {@code document} is
<i>2472</i>&nbsp;     * mutated during printing.
<i>2473</i>&nbsp;     *
<i>2474</i>&nbsp;     * &lt;p&gt;
<i>2475</i>&nbsp;     * Page header and footer text can be added to the output by providing
<i>2476</i>&nbsp;     * {@code MessageFormat} arguments. The printing code requests
<i>2477</i>&nbsp;     * {@code Strings} from the formats, providing a single item which may be
<i>2478</i>&nbsp;     * included in the formatted string: an {@code Integer} representing the
<i>2479</i>&nbsp;     * current page number.
<i>2480</i>&nbsp;     *
<i>2481</i>&nbsp;     * &lt;p&gt;
<i>2482</i>&nbsp;     * The returned {@code Printable} when printed, formats the
<i>2483</i>&nbsp;     * document content appropriately for the page size. For correct
<i>2484</i>&nbsp;     * line wrapping the {@code imageable width} of all pages must be the
<i>2485</i>&nbsp;     * same. See {@link java.awt.print.PageFormat#getImageableWidth}.
<i>2486</i>&nbsp;     *
<i>2487</i>&nbsp;     * &lt;p&gt;
<i>2488</i>&nbsp;     * This method is thread-safe, although most Swing methods are not. Please
<i>2489</i>&nbsp;     * see &lt;A
<i>2490</i>&nbsp;     * HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;
<i>2491</i>&nbsp;     * Concurrency in Swing&lt;/A&gt; for more information.
<i>2492</i>&nbsp;     *
<i>2493</i>&nbsp;     * &lt;p&gt;
<i>2494</i>&nbsp;     * The returned {@code Printable} can be printed on any thread.
<i>2495</i>&nbsp;     *
<i>2496</i>&nbsp;     * &lt;p&gt;
<i>2497</i>&nbsp;     * This implementation returned {@code Printable} performs all painting on
<i>2498</i>&nbsp;     * the &lt;i&gt;Event Dispatch Thread&lt;/i&gt;, regardless of what thread it is
<i>2499</i>&nbsp;     * used on.
<b class="nc"><i>2500</i>&nbsp;     *</b>
<i>2501</i>&nbsp;     * @param headerFormat the text, in {@code MessageFormat}, to be
<i>2502</i>&nbsp;     *        used as the header, or {@code null} for no header
<i>2503</i>&nbsp;     * @param footerFormat the text, in {@code MessageFormat}, to be
<i>2504</i>&nbsp;     *        used as the footer, or {@code null} for no footer
<i>2505</i>&nbsp;     * @return a {@code Printable} for use in printing content of this
<i>2506</i>&nbsp;     *         {@code JTextComponent}
<i>2507</i>&nbsp;     *
<i>2508</i>&nbsp;     *
<i>2509</i>&nbsp;     * @see java.awt.print.Printable
<i>2510</i>&nbsp;     * @see java.awt.print.PageFormat
<i>2511</i>&nbsp;     * @see javax.swing.text.Document#render(java.lang.Runnable)
<i>2512</i>&nbsp;     *
<i>2513</i>&nbsp;     * @since 1.6
<i>2514</i>&nbsp;     */
<i>2515</i>&nbsp;    public Printable getPrintable(final MessageFormat headerFormat,
<i>2516</i>&nbsp;                                  final MessageFormat footerFormat) {
<i>2517</i>&nbsp;        return TextComponentPrintable.getPrintable(
<i>2518</i>&nbsp;                   this, headerFormat, footerFormat);
<i>2519</i>&nbsp;    }
<i>2520</i>&nbsp;
<i>2521</i>&nbsp;
<i>2522</i>&nbsp;/////////////////
<b class="nc"><i>2523</i>&nbsp;// Accessibility support</b>
<b class="nc"><i>2524</i>&nbsp;////////////////</b>
<i>2525</i>&nbsp;
<b class="nc"><i>2526</i>&nbsp;</b>
<i>2527</i>&nbsp;    /**
<i>2528</i>&nbsp;     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
<i>2529</i>&nbsp;     * &lt;code&gt;JTextComponent&lt;/code&gt;. For text components,
<i>2530</i>&nbsp;     * the &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
<i>2531</i>&nbsp;     * &lt;code&gt;AccessibleJTextComponent&lt;/code&gt;.
<i>2532</i>&nbsp;     * A new &lt;code&gt;AccessibleJTextComponent&lt;/code&gt; instance
<i>2533</i>&nbsp;     * is created if necessary.
<i>2534</i>&nbsp;     *
<i>2535</i>&nbsp;     * @return an &lt;code&gt;AccessibleJTextComponent&lt;/code&gt; that serves as the
<i>2536</i>&nbsp;     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this
<i>2537</i>&nbsp;     *         &lt;code&gt;JTextComponent&lt;/code&gt;
<i>2538</i>&nbsp;     */
<i>2539</i>&nbsp;    @BeanProperty(bound = false)
<i>2540</i>&nbsp;    public AccessibleContext getAccessibleContext() {
<i>2541</i>&nbsp;        if (accessibleContext == null) {
<i>2542</i>&nbsp;            accessibleContext = new AccessibleJTextComponent();
<i>2543</i>&nbsp;        }
<i>2544</i>&nbsp;        return accessibleContext;
<i>2545</i>&nbsp;    }
<i>2546</i>&nbsp;
<i>2547</i>&nbsp;    /**
<i>2548</i>&nbsp;     * This class implements accessibility support for the
<i>2549</i>&nbsp;     * &lt;code&gt;JTextComponent&lt;/code&gt; class.  It provides an implementation of
<i>2550</i>&nbsp;     * the Java Accessibility API appropriate to menu user-interface elements.
<i>2551</i>&nbsp;     * &lt;p&gt;
<i>2552</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>2553</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>2554</i>&nbsp;     * future Swing releases. The current serialization support is
<b class="nc"><i>2555</i>&nbsp;     * appropriate for short term storage or RMI between applications running</b>
<b class="nc"><i>2556</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage</b>
<b class="nc"><i>2557</i>&nbsp;     * of all JavaBeans&amp;trade;</b>
<b class="nc"><i>2558</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.</b>
<i>2559</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<b class="nc"><i>2560</i>&nbsp;     */</b>
<b class="nc"><i>2561</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only</b>
<i>2562</i>&nbsp;    public class AccessibleJTextComponent extends AccessibleJComponent
<i>2563</i>&nbsp;    implements AccessibleText, CaretListener, DocumentListener,
<b class="nc"><i>2564</i>&nbsp;               AccessibleAction, AccessibleEditableText,</b>
<b class="nc"><i>2565</i>&nbsp;               AccessibleExtendedText {</b>
<b class="nc"><i>2566</i>&nbsp;</b>
<i>2567</i>&nbsp;        int caretPos;
<i>2568</i>&nbsp;        Point oldLocationOnScreen;
<i>2569</i>&nbsp;
<i>2570</i>&nbsp;        /**
<i>2571</i>&nbsp;         * Constructs an AccessibleJTextComponent.  Adds a listener to track
<b class="nc"><i>2572</i>&nbsp;         * caret change.</b>
<i>2573</i>&nbsp;         */
<i>2574</i>&nbsp;        public AccessibleJTextComponent() {
<i>2575</i>&nbsp;            Document doc = JTextComponent.this.getDocument();
<b class="nc"><i>2576</i>&nbsp;            if (doc != null) {</b>
<b class="nc"><i>2577</i>&nbsp;                doc.addDocumentListener(this);</b>
<i>2578</i>&nbsp;            }
<i>2579</i>&nbsp;            JTextComponent.this.addCaretListener(this);
<i>2580</i>&nbsp;            caretPos = getCaretPosition();
<b class="nc"><i>2581</i>&nbsp;</b>
<b class="nc"><i>2582</i>&nbsp;            try {</b>
<b class="nc"><i>2583</i>&nbsp;                oldLocationOnScreen = getLocationOnScreen();</b>
<i>2584</i>&nbsp;            } catch (IllegalComponentStateException iae) {
<i>2585</i>&nbsp;            }
<i>2586</i>&nbsp;
<i>2587</i>&nbsp;            // Fire a ACCESSIBLE_VISIBLE_DATA_PROPERTY PropertyChangeEvent
<i>2588</i>&nbsp;            // when the text component moves (e.g., when scrolling).
<i>2589</i>&nbsp;            // Using an anonymous class since making AccessibleJTextComponent
<i>2590</i>&nbsp;            // implement ComponentListener would be an API change.
<i>2591</i>&nbsp;            JTextComponent.this.addComponentListener(new ComponentAdapter() {
<i>2592</i>&nbsp;
<i>2593</i>&nbsp;                public void componentMoved(ComponentEvent e) {
<i>2594</i>&nbsp;                    try {
<i>2595</i>&nbsp;                        Point newLocationOnScreen = getLocationOnScreen();
<i>2596</i>&nbsp;                        firePropertyChange(ACCESSIBLE_VISIBLE_DATA_PROPERTY,
<i>2597</i>&nbsp;                                           oldLocationOnScreen,
<b class="nc"><i>2598</i>&nbsp;                                           newLocationOnScreen);</b>
<b class="nc"><i>2599</i>&nbsp;</b>
<b class="nc"><i>2600</i>&nbsp;                        oldLocationOnScreen = newLocationOnScreen;</b>
<i>2601</i>&nbsp;                    } catch (IllegalComponentStateException iae) {
<b class="nc"><i>2602</i>&nbsp;                    }</b>
<i>2603</i>&nbsp;                }
<b class="nc"><i>2604</i>&nbsp;            });</b>
<i>2605</i>&nbsp;        }
<i>2606</i>&nbsp;
<b class="nc"><i>2607</i>&nbsp;        /**</b>
<b class="nc"><i>2608</i>&nbsp;         * Handles caret updates (fire appropriate property change event,</b>
<b class="nc"><i>2609</i>&nbsp;         * which are AccessibleContext.ACCESSIBLE_CARET_PROPERTY and</b>
<i>2610</i>&nbsp;         * AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY).
<b class="nc"><i>2611</i>&nbsp;         * This keeps track of the dot position internally.  When the caret</b>
<i>2612</i>&nbsp;         * moves, the internal position is updated after firing the event.
<b class="nc"><i>2613</i>&nbsp;         *</b>
<b class="nc"><i>2614</i>&nbsp;         * @param e the CaretEvent</b>
<i>2615</i>&nbsp;         */
<i>2616</i>&nbsp;        public void caretUpdate(CaretEvent e) {
<i>2617</i>&nbsp;            int dot = e.getDot();
<i>2618</i>&nbsp;            int mark = e.getMark();
<i>2619</i>&nbsp;            if (caretPos != dot) {
<i>2620</i>&nbsp;                // the caret moved
<i>2621</i>&nbsp;                firePropertyChange(ACCESSIBLE_CARET_PROPERTY,
<i>2622</i>&nbsp;                    caretPos, dot);
<i>2623</i>&nbsp;                caretPos = dot;
<i>2624</i>&nbsp;
<i>2625</i>&nbsp;                try {
<i>2626</i>&nbsp;                    oldLocationOnScreen = getLocationOnScreen();
<i>2627</i>&nbsp;                } catch (IllegalComponentStateException iae) {
<b class="nc"><i>2628</i>&nbsp;                }</b>
<b class="nc"><i>2629</i>&nbsp;            }</b>
<b class="nc"><i>2630</i>&nbsp;            if (mark != dot) {</b>
<i>2631</i>&nbsp;                // there is a selection
<b class="nc"><i>2632</i>&nbsp;                firePropertyChange(ACCESSIBLE_SELECTION_PROPERTY, null,</b>
<i>2633</i>&nbsp;                    getSelectedText());
<b class="nc"><i>2634</i>&nbsp;            }</b>
<i>2635</i>&nbsp;        }
<i>2636</i>&nbsp;
<i>2637</i>&nbsp;        // DocumentListener methods
<b class="nc"><i>2638</i>&nbsp;</b>
<i>2639</i>&nbsp;        /**
<i>2640</i>&nbsp;         * Handles document insert (fire appropriate property change event
<i>2641</i>&nbsp;         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
<i>2642</i>&nbsp;         * This tracks the changed offset via the event.
<i>2643</i>&nbsp;         *
<i>2644</i>&nbsp;         * @param e the DocumentEvent
<i>2645</i>&nbsp;         */
<i>2646</i>&nbsp;        public void insertUpdate(DocumentEvent e) {
<i>2647</i>&nbsp;            final Integer pos = e.getOffset();
<i>2648</i>&nbsp;            if (SwingUtilities.isEventDispatchThread()) {
<i>2649</i>&nbsp;                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);
<b class="nc"><i>2650</i>&nbsp;            } else {</b>
<b class="nc"><i>2651</i>&nbsp;                Runnable doFire = new Runnable() {</b>
<b class="nc"><i>2652</i>&nbsp;                    public void run() {</b>
<i>2653</i>&nbsp;                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,
<b class="nc"><i>2654</i>&nbsp;                                           null, pos);</b>
<i>2655</i>&nbsp;                    }
<b class="nc"><i>2656</i>&nbsp;                };</b>
<i>2657</i>&nbsp;                SwingUtilities.invokeLater(doFire);
<i>2658</i>&nbsp;            }
<i>2659</i>&nbsp;        }
<b class="nc"><i>2660</i>&nbsp;</b>
<i>2661</i>&nbsp;        /**
<i>2662</i>&nbsp;         * Handles document remove (fire appropriate property change event,
<i>2663</i>&nbsp;         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
<i>2664</i>&nbsp;         * This tracks the changed offset via the event.
<i>2665</i>&nbsp;         *
<i>2666</i>&nbsp;         * @param e the DocumentEvent
<i>2667</i>&nbsp;         */
<i>2668</i>&nbsp;        public void removeUpdate(DocumentEvent e) {
<i>2669</i>&nbsp;            final Integer pos = e.getOffset();
<i>2670</i>&nbsp;            if (SwingUtilities.isEventDispatchThread()) {
<i>2671</i>&nbsp;                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);
<b class="nc"><i>2672</i>&nbsp;            } else {</b>
<b class="nc"><i>2673</i>&nbsp;                Runnable doFire = new Runnable() {</b>
<b class="nc"><i>2674</i>&nbsp;                    public void run() {</b>
<i>2675</i>&nbsp;                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,
<b class="nc"><i>2676</i>&nbsp;                                           null, pos);</b>
<i>2677</i>&nbsp;                    }
<b class="nc"><i>2678</i>&nbsp;                };</b>
<i>2679</i>&nbsp;                SwingUtilities.invokeLater(doFire);
<i>2680</i>&nbsp;            }
<i>2681</i>&nbsp;        }
<b class="nc"><i>2682</i>&nbsp;</b>
<i>2683</i>&nbsp;        /**
<i>2684</i>&nbsp;         * Handles document remove (fire appropriate property change event,
<i>2685</i>&nbsp;         * which is AccessibleContext.ACCESSIBLE_TEXT_PROPERTY).
<i>2686</i>&nbsp;         * This tracks the changed offset via the event.
<i>2687</i>&nbsp;         *
<i>2688</i>&nbsp;         * @param e the DocumentEvent
<i>2689</i>&nbsp;         */
<i>2690</i>&nbsp;        public void changedUpdate(DocumentEvent e) {
<i>2691</i>&nbsp;            final Integer pos = e.getOffset();
<i>2692</i>&nbsp;            if (SwingUtilities.isEventDispatchThread()) {
<i>2693</i>&nbsp;                firePropertyChange(ACCESSIBLE_TEXT_PROPERTY, null, pos);
<i>2694</i>&nbsp;            } else {
<i>2695</i>&nbsp;                Runnable doFire = new Runnable() {
<i>2696</i>&nbsp;                    public void run() {
<i>2697</i>&nbsp;                        firePropertyChange(ACCESSIBLE_TEXT_PROPERTY,
<i>2698</i>&nbsp;                                           null, pos);
<i>2699</i>&nbsp;                    }
<b class="nc"><i>2700</i>&nbsp;                };</b>
<b class="nc"><i>2701</i>&nbsp;                SwingUtilities.invokeLater(doFire);</b>
<b class="nc"><i>2702</i>&nbsp;            }</b>
<i>2703</i>&nbsp;        }
<b class="nc"><i>2704</i>&nbsp;</b>
<i>2705</i>&nbsp;        /**
<i>2706</i>&nbsp;         * Gets the state set of the JTextComponent.
<i>2707</i>&nbsp;         * The AccessibleStateSet of an object is composed of a set of
<i>2708</i>&nbsp;         * unique AccessibleState&#39;s.  A change in the AccessibleStateSet
<i>2709</i>&nbsp;         * of an object will cause a PropertyChangeEvent to be fired
<i>2710</i>&nbsp;         * for the AccessibleContext.ACCESSIBLE_STATE_PROPERTY property.
<i>2711</i>&nbsp;         *
<i>2712</i>&nbsp;         * @return an instance of AccessibleStateSet containing the
<i>2713</i>&nbsp;         * current state set of the object
<i>2714</i>&nbsp;         * @see AccessibleStateSet
<i>2715</i>&nbsp;         * @see AccessibleState
<b class="nc"><i>2716</i>&nbsp;         * @see #addPropertyChangeListener</b>
<i>2717</i>&nbsp;         */
<i>2718</i>&nbsp;        public AccessibleStateSet getAccessibleStateSet() {
<i>2719</i>&nbsp;            AccessibleStateSet states = super.getAccessibleStateSet();
<i>2720</i>&nbsp;            if (JTextComponent.this.isEditable()) {
<i>2721</i>&nbsp;                states.add(AccessibleState.EDITABLE);
<i>2722</i>&nbsp;            }
<i>2723</i>&nbsp;            return states;
<i>2724</i>&nbsp;        }
<i>2725</i>&nbsp;
<i>2726</i>&nbsp;
<i>2727</i>&nbsp;        /**
<b class="nc"><i>2728</i>&nbsp;         * Gets the role of this object.</b>
<i>2729</i>&nbsp;         *
<i>2730</i>&nbsp;         * @return an instance of AccessibleRole describing the role of the
<i>2731</i>&nbsp;         * object (AccessibleRole.TEXT)
<i>2732</i>&nbsp;         * @see AccessibleRole
<i>2733</i>&nbsp;         */
<i>2734</i>&nbsp;        public AccessibleRole getAccessibleRole() {
<i>2735</i>&nbsp;            return AccessibleRole.TEXT;
<i>2736</i>&nbsp;        }
<i>2737</i>&nbsp;
<i>2738</i>&nbsp;        /**
<i>2739</i>&nbsp;         * Get the AccessibleText associated with this object.  In the
<i>2740</i>&nbsp;         * implementation of the Java Accessibility API for this class,
<i>2741</i>&nbsp;         * return this object, which is responsible for implementing the
<i>2742</i>&nbsp;         * AccessibleText interface on behalf of itself.
<i>2743</i>&nbsp;         *
<i>2744</i>&nbsp;         * @return this object
<i>2745</i>&nbsp;         */
<i>2746</i>&nbsp;        public AccessibleText getAccessibleText() {
<i>2747</i>&nbsp;            return this;
<b class="nc"><i>2748</i>&nbsp;        }</b>
<b class="nc"><i>2749</i>&nbsp;</b>
<i>2750</i>&nbsp;
<b class="nc"><i>2751</i>&nbsp;        // --- interface AccessibleText methods ------------------------</b>
<i>2752</i>&nbsp;
<i>2753</i>&nbsp;        /**
<i>2754</i>&nbsp;         * Many of these methods are just convenience methods; they
<i>2755</i>&nbsp;         * just call the equivalent on the parent
<i>2756</i>&nbsp;         */
<i>2757</i>&nbsp;
<i>2758</i>&nbsp;        /**
<i>2759</i>&nbsp;         * Given a point in local coordinates, return the zero-based index
<i>2760</i>&nbsp;         * of the character under that Point.  If the point is invalid,
<i>2761</i>&nbsp;         * this method returns -1.
<b class="nc"><i>2762</i>&nbsp;         *</b>
<b class="nc"><i>2763</i>&nbsp;         * @param p the Point in local coordinates</b>
<b class="nc"><i>2764</i>&nbsp;         * @return the zero-based index of the character under Point p.</b>
<b class="nc"><i>2765</i>&nbsp;         */</b>
<b class="nc"><i>2766</i>&nbsp;        public int getIndexAtPoint(Point p) {</b>
<b class="nc"><i>2767</i>&nbsp;            if (p == null) {</b>
<b class="nc"><i>2768</i>&nbsp;                return -1;</b>
<b class="nc"><i>2769</i>&nbsp;            }</b>
<b class="nc"><i>2770</i>&nbsp;            return JTextComponent.this.viewToModel(p);</b>
<i>2771</i>&nbsp;        }
<b class="nc"><i>2772</i>&nbsp;</b>
<i>2773</i>&nbsp;            /**
<i>2774</i>&nbsp;             * Gets the editor&#39;s drawing rectangle.  Stolen
<i>2775</i>&nbsp;             * from the unfortunately named
<i>2776</i>&nbsp;             * BasicTextUI.getVisibleEditorRect()
<i>2777</i>&nbsp;             *
<i>2778</i>&nbsp;             * @return the bounding box for the root view
<i>2779</i>&nbsp;             */
<i>2780</i>&nbsp;            Rectangle getRootEditorRect() {
<i>2781</i>&nbsp;                Rectangle alloc = JTextComponent.this.getBounds();
<i>2782</i>&nbsp;                if ((alloc.width &gt; 0) &amp;&amp; (alloc.height &gt; 0)) {
<i>2783</i>&nbsp;                        alloc.x = alloc.y = 0;
<i>2784</i>&nbsp;                        Insets insets = JTextComponent.this.getInsets();
<i>2785</i>&nbsp;                        alloc.x += insets.left;
<i>2786</i>&nbsp;                        alloc.y += insets.top;
<i>2787</i>&nbsp;                        alloc.width -= insets.left + insets.right;
<i>2788</i>&nbsp;                        alloc.height -= insets.top + insets.bottom;
<i>2789</i>&nbsp;                        return alloc;
<i>2790</i>&nbsp;                }
<i>2791</i>&nbsp;                return null;
<i>2792</i>&nbsp;            }
<i>2793</i>&nbsp;
<i>2794</i>&nbsp;        /**
<i>2795</i>&nbsp;         * Determines the bounding box of the character at the given
<i>2796</i>&nbsp;         * index into the string.  The bounds are returned in local
<i>2797</i>&nbsp;         * coordinates.  If the index is invalid a null rectangle
<i>2798</i>&nbsp;         * is returned.
<i>2799</i>&nbsp;         *
<i>2800</i>&nbsp;         * The screen coordinates returned are &quot;unscrolled coordinates&quot;
<i>2801</i>&nbsp;         * if the JTextComponent is contained in a JScrollPane in which
<i>2802</i>&nbsp;         * case the resulting rectangle should be composed with the parent
<i>2803</i>&nbsp;         * coordinates.  A good algorithm to use is:
<b class="nc"><i>2804</i>&nbsp;         * &lt;pre&gt;</b>
<b class="nc"><i>2805</i>&nbsp;         * Accessible a:</b>
<i>2806</i>&nbsp;         * AccessibleText at = a.getAccessibleText();
<b class="nc"><i>2807</i>&nbsp;         * AccessibleComponent ac = a.getAccessibleComponent();</b>
<b class="nc"><i>2808</i>&nbsp;         * Rectangle r = at.getCharacterBounds();</b>
<b class="nc"><i>2809</i>&nbsp;         * Point p = ac.getLocation();</b>
<i>2810</i>&nbsp;         * r.x += p.x;
<b class="nc"><i>2811</i>&nbsp;         * r.y += p.y;</b>
<b class="nc"><i>2812</i>&nbsp;         * &lt;/pre&gt;</b>
<b class="nc"><i>2813</i>&nbsp;         *</b>
<b class="nc"><i>2814</i>&nbsp;         * Note: the JTextComponent must have a valid size (e.g. have</b>
<i>2815</i>&nbsp;         * been added to a parent container whose ancestor container
<b class="nc"><i>2816</i>&nbsp;         * is a valid top-level window) for this method to be able</b>
<b class="nc"><i>2817</i>&nbsp;         * to return a meaningful (non-null) value.</b>
<i>2818</i>&nbsp;         *
<i>2819</i>&nbsp;         * @param i the index into the String &amp;ge; 0
<b class="nc"><i>2820</i>&nbsp;         * @return the screen coordinates of the character&#39;s bounding box</b>
<b class="nc"><i>2821</i>&nbsp;         */</b>
<b class="nc"><i>2822</i>&nbsp;        public Rectangle getCharacterBounds(int i) {</b>
<i>2823</i>&nbsp;            if (i &lt; 0 || i &gt; model.getLength()-1) {
<b class="nc"><i>2824</i>&nbsp;                return null;</b>
<i>2825</i>&nbsp;            }
<i>2826</i>&nbsp;            TextUI ui = getUI();
<i>2827</i>&nbsp;            if (ui == null) {
<b class="nc"><i>2828</i>&nbsp;                return null;</b>
<b class="nc"><i>2829</i>&nbsp;            }</b>
<i>2830</i>&nbsp;            Rectangle rect = null;
<i>2831</i>&nbsp;            Rectangle alloc = getRootEditorRect();
<b class="nc"><i>2832</i>&nbsp;            if (alloc == null) {</b>
<i>2833</i>&nbsp;                return null;
<b class="nc"><i>2834</i>&nbsp;            }</b>
<b class="nc"><i>2835</i>&nbsp;            if (model instanceof AbstractDocument) {</b>
<i>2836</i>&nbsp;                ((AbstractDocument)model).readLock();
<i>2837</i>&nbsp;            }
<b class="nc"><i>2838</i>&nbsp;            try {</b>
<i>2839</i>&nbsp;                View rootView = ui.getRootView(JTextComponent.this);
<i>2840</i>&nbsp;                if (rootView != null) {
<i>2841</i>&nbsp;                    rootView.setSize(alloc.width, alloc.height);
<i>2842</i>&nbsp;
<i>2843</i>&nbsp;                    Shape bounds = rootView.modelToView(i,
<i>2844</i>&nbsp;                                    Position.Bias.Forward, i+1,
<i>2845</i>&nbsp;                                    Position.Bias.Backward, alloc);
<i>2846</i>&nbsp;
<b class="nc"><i>2847</i>&nbsp;                    rect = (bounds instanceof Rectangle) ?</b>
<i>2848</i>&nbsp;                     (Rectangle)bounds : bounds.getBounds();
<i>2849</i>&nbsp;
<i>2850</i>&nbsp;                }
<i>2851</i>&nbsp;            } catch (BadLocationException e) {
<i>2852</i>&nbsp;            } finally {
<i>2853</i>&nbsp;                if (model instanceof AbstractDocument) {
<i>2854</i>&nbsp;                    ((AbstractDocument)model).readUnlock();
<i>2855</i>&nbsp;                }
<i>2856</i>&nbsp;            }
<i>2857</i>&nbsp;            return rect;
<i>2858</i>&nbsp;        }
<i>2859</i>&nbsp;
<b class="nc"><i>2860</i>&nbsp;        /**</b>
<i>2861</i>&nbsp;         * Returns the number of characters (valid indices)
<i>2862</i>&nbsp;         *
<i>2863</i>&nbsp;         * @return the number of characters &amp;ge; 0
<i>2864</i>&nbsp;         */
<i>2865</i>&nbsp;        public int getCharCount() {
<i>2866</i>&nbsp;            return model.getLength();
<i>2867</i>&nbsp;        }
<i>2868</i>&nbsp;
<i>2869</i>&nbsp;        /**
<b class="nc"><i>2870</i>&nbsp;         * Returns the zero-based offset of the caret.</b>
<b class="nc"><i>2871</i>&nbsp;         *</b>
<b class="nc"><i>2872</i>&nbsp;         * Note: The character to the right of the caret will have the</b>
<i>2873</i>&nbsp;         * same index value as the offset (the caret is between
<i>2874</i>&nbsp;         * two characters).
<b class="nc"><i>2875</i>&nbsp;         *</b>
<b class="nc"><i>2876</i>&nbsp;         * @return the zero-based offset of the caret.</b>
<b class="nc"><i>2877</i>&nbsp;         */</b>
<b class="nc"><i>2878</i>&nbsp;        public int getCaretPosition() {</b>
<i>2879</i>&nbsp;            return JTextComponent.this.getCaretPosition();
<b class="nc"><i>2880</i>&nbsp;        }</b>
<b class="nc"><i>2881</i>&nbsp;</b>
<i>2882</i>&nbsp;        /**
<i>2883</i>&nbsp;         * Returns the AttributeSet for a given character (at a given index).
<b class="nc"><i>2884</i>&nbsp;         *</b>
<i>2885</i>&nbsp;         * @param i the zero-based index into the text
<i>2886</i>&nbsp;         * @return the AttributeSet of the character
<i>2887</i>&nbsp;         */
<i>2888</i>&nbsp;        public AttributeSet getCharacterAttribute(int i) {
<i>2889</i>&nbsp;            Element e = null;
<i>2890</i>&nbsp;            if (model instanceof AbstractDocument) {
<i>2891</i>&nbsp;                ((AbstractDocument)model).readLock();
<i>2892</i>&nbsp;            }
<i>2893</i>&nbsp;            try {
<i>2894</i>&nbsp;                for (e = model.getDefaultRootElement(); ! e.isLeaf(); ) {
<i>2895</i>&nbsp;                    int index = e.getElementIndex(i);
<i>2896</i>&nbsp;                    e = e.getElement(index);
<i>2897</i>&nbsp;                }
<b class="nc"><i>2898</i>&nbsp;            } finally {</b>
<i>2899</i>&nbsp;                if (model instanceof AbstractDocument) {
<i>2900</i>&nbsp;                    ((AbstractDocument)model).readUnlock();
<i>2901</i>&nbsp;                }
<i>2902</i>&nbsp;            }
<i>2903</i>&nbsp;            return e.getAttributes();
<i>2904</i>&nbsp;        }
<i>2905</i>&nbsp;
<i>2906</i>&nbsp;
<i>2907</i>&nbsp;        /**
<i>2908</i>&nbsp;         * Returns the start offset within the selected text.
<i>2909</i>&nbsp;         * If there is no selection, but there is
<i>2910</i>&nbsp;         * a caret, the start and end offsets will be the same.
<b class="nc"><i>2911</i>&nbsp;         * Return 0 if the text is empty, or the caret position</b>
<i>2912</i>&nbsp;         * if no selection.
<i>2913</i>&nbsp;         *
<i>2914</i>&nbsp;         * @return the index into the text of the start of the selection &amp;ge; 0
<i>2915</i>&nbsp;         */
<i>2916</i>&nbsp;        public int getSelectionStart() {
<i>2917</i>&nbsp;            return JTextComponent.this.getSelectionStart();
<i>2918</i>&nbsp;        }
<i>2919</i>&nbsp;
<b class="nc"><i>2920</i>&nbsp;        /**</b>
<i>2921</i>&nbsp;         * Returns the end offset within the selected text.
<i>2922</i>&nbsp;         * If there is no selection, but there is
<i>2923</i>&nbsp;         * a caret, the start and end offsets will be the same.
<i>2924</i>&nbsp;         * Return 0 if the text is empty, or the caret position
<i>2925</i>&nbsp;         * if no selection.
<i>2926</i>&nbsp;         *
<b class="nc"><i>2927</i>&nbsp;         * @return the index into the text of the end of the selection &amp;ge; 0</b>
<i>2928</i>&nbsp;         */
<i>2929</i>&nbsp;        public int getSelectionEnd() {
<i>2930</i>&nbsp;            return JTextComponent.this.getSelectionEnd();
<i>2931</i>&nbsp;        }
<i>2932</i>&nbsp;
<i>2933</i>&nbsp;        /**
<i>2934</i>&nbsp;         * Returns the portion of the text that is selected.
<i>2935</i>&nbsp;         *
<i>2936</i>&nbsp;         * @return the text, null if no selection
<i>2937</i>&nbsp;         */
<i>2938</i>&nbsp;        public String getSelectedText() {
<i>2939</i>&nbsp;            return JTextComponent.this.getSelectedText();
<i>2940</i>&nbsp;        }
<i>2941</i>&nbsp;
<i>2942</i>&nbsp;       /**
<i>2943</i>&nbsp;         * IndexedSegment extends Segment adding the offset into the
<i>2944</i>&nbsp;         * the model the &lt;code&gt;Segment&lt;/code&gt; was asked for.
<i>2945</i>&nbsp;         */
<b class="nc"><i>2946</i>&nbsp;        private class IndexedSegment extends Segment {</b>
<i>2947</i>&nbsp;            /**
<i>2948</i>&nbsp;             * Offset into the model that the position represents.
<i>2949</i>&nbsp;             */
<i>2950</i>&nbsp;            public int modelOffset;
<i>2951</i>&nbsp;        }
<i>2952</i>&nbsp;
<i>2953</i>&nbsp;
<i>2954</i>&nbsp;        // TIGER - 4170173
<i>2955</i>&nbsp;        /**
<i>2956</i>&nbsp;         * Returns the String at a given index. Whitespace
<i>2957</i>&nbsp;         * between words is treated as a word.
<i>2958</i>&nbsp;         *
<b class="nc"><i>2959</i>&nbsp;         * @param part the CHARACTER, WORD, or SENTENCE to retrieve</b>
<i>2960</i>&nbsp;         * @param index an index within the text
<i>2961</i>&nbsp;         * @return the letter, word, or sentence.
<i>2962</i>&nbsp;         *
<i>2963</i>&nbsp;         */
<i>2964</i>&nbsp;        public String getAtIndex(int part, int index) {
<i>2965</i>&nbsp;            return getAtIndex(part, index, 0);
<i>2966</i>&nbsp;        }
<i>2967</i>&nbsp;
<i>2968</i>&nbsp;
<i>2969</i>&nbsp;        /**
<i>2970</i>&nbsp;         * Returns the String after a given index. Whitespace
<i>2971</i>&nbsp;         * between words is treated as a word.
<b class="nc"><i>2972</i>&nbsp;         *</b>
<i>2973</i>&nbsp;         * @param part the CHARACTER, WORD, or SENTENCE to retrieve
<i>2974</i>&nbsp;         * @param index an index within the text
<i>2975</i>&nbsp;         * @return the letter, word, or sentence.
<i>2976</i>&nbsp;         */
<i>2977</i>&nbsp;        public String getAfterIndex(int part, int index) {
<i>2978</i>&nbsp;            return getAtIndex(part, index, 1);
<i>2979</i>&nbsp;        }
<i>2980</i>&nbsp;
<i>2981</i>&nbsp;
<b class="nc"><i>2982</i>&nbsp;        /**</b>
<b class="nc"><i>2983</i>&nbsp;         * Returns the String before a given index. Whitespace</b>
<i>2984</i>&nbsp;         * between words is treated a word.
<i>2985</i>&nbsp;         *
<b class="nc"><i>2986</i>&nbsp;         * @param part the CHARACTER, WORD, or SENTENCE to retrieve</b>
<b class="nc"><i>2987</i>&nbsp;         * @param index an index within the text</b>
<i>2988</i>&nbsp;         * @return the letter, word, or sentence.
<b class="nc"><i>2989</i>&nbsp;         */</b>
<i>2990</i>&nbsp;        public String getBeforeIndex(int part, int index) {
<b class="nc"><i>2991</i>&nbsp;            return getAtIndex(part, index, -1);</b>
<i>2992</i>&nbsp;        }
<b class="nc"><i>2993</i>&nbsp;</b>
<i>2994</i>&nbsp;
<i>2995</i>&nbsp;        /**
<i>2996</i>&nbsp;         * Gets the word, sentence, or character at &lt;code&gt;index&lt;/code&gt;.
<i>2997</i>&nbsp;         * If &lt;code&gt;direction&lt;/code&gt; is non-null this will find the
<i>2998</i>&nbsp;         * next/previous word/sentence/character.
<i>2999</i>&nbsp;         */
<b class="nc"><i>3000</i>&nbsp;        private String getAtIndex(int part, int index, int direction) {</b>
<b class="nc"><i>3001</i>&nbsp;            if (model instanceof AbstractDocument) {</b>
<b class="nc"><i>3002</i>&nbsp;                ((AbstractDocument)model).readLock();</b>
<i>3003</i>&nbsp;            }
<i>3004</i>&nbsp;            try {
<i>3005</i>&nbsp;                if (index &lt; 0 || index &gt;= model.getLength()) {
<b class="nc"><i>3006</i>&nbsp;                    return null;</b>
<b class="nc"><i>3007</i>&nbsp;                }</b>
<i>3008</i>&nbsp;                switch (part) {
<i>3009</i>&nbsp;                case AccessibleText.CHARACTER:
<b class="nc"><i>3010</i>&nbsp;                    if (index + direction &lt; model.getLength() &amp;&amp;</b>
<i>3011</i>&nbsp;                        index + direction &gt;= 0) {
<b class="nc"><i>3012</i>&nbsp;                        return model.getText(index + direction, 1);</b>
<b class="nc"><i>3013</i>&nbsp;                    }</b>
<i>3014</i>&nbsp;                    break;
<i>3015</i>&nbsp;
<b class="nc"><i>3016</i>&nbsp;</b>
<i>3017</i>&nbsp;                case AccessibleText.WORD:
<i>3018</i>&nbsp;                case AccessibleText.SENTENCE:
<b class="nc"><i>3019</i>&nbsp;                    IndexedSegment seg = getSegmentAt(part, index);</b>
<b class="nc"><i>3020</i>&nbsp;                    if (seg != null) {</b>
<i>3021</i>&nbsp;                        if (direction != 0) {
<i>3022</i>&nbsp;                            int next;
<i>3023</i>&nbsp;
<i>3024</i>&nbsp;
<i>3025</i>&nbsp;                            if (direction &lt; 0) {
<i>3026</i>&nbsp;                                next = seg.modelOffset - 1;
<i>3027</i>&nbsp;                            }
<i>3028</i>&nbsp;                            else {
<i>3029</i>&nbsp;                                next = seg.modelOffset + direction * seg.count;
<b class="nc"><i>3030</i>&nbsp;                            }</b>
<i>3031</i>&nbsp;                            if (next &gt;= 0 &amp;&amp; next &lt;= model.getLength()) {
<b class="nc"><i>3032</i>&nbsp;                                seg = getSegmentAt(part, next);</b>
<b class="nc"><i>3033</i>&nbsp;                            }</b>
<i>3034</i>&nbsp;                            else {
<i>3035</i>&nbsp;                                seg = null;
<b class="nc"><i>3036</i>&nbsp;                            }</b>
<i>3037</i>&nbsp;                        }
<i>3038</i>&nbsp;                        if (seg != null) {
<i>3039</i>&nbsp;                            return new String(seg.array, seg.offset,
<i>3040</i>&nbsp;                                                  seg.count);
<i>3041</i>&nbsp;                        }
<i>3042</i>&nbsp;                    }
<i>3043</i>&nbsp;                    break;
<b class="nc"><i>3044</i>&nbsp;</b>
<b class="nc"><i>3045</i>&nbsp;</b>
<b class="nc"><i>3046</i>&nbsp;                default:</b>
<b class="nc"><i>3047</i>&nbsp;                    break;</b>
<b class="nc"><i>3048</i>&nbsp;                }</b>
<b class="nc"><i>3049</i>&nbsp;            } catch (BadLocationException e) {</b>
<i>3050</i>&nbsp;            } finally {
<i>3051</i>&nbsp;                if (model instanceof AbstractDocument) {
<b class="nc"><i>3052</i>&nbsp;                    ((AbstractDocument)model).readUnlock();</b>
<b class="nc"><i>3053</i>&nbsp;                }</b>
<b class="nc"><i>3054</i>&nbsp;            }</b>
<b class="nc"><i>3055</i>&nbsp;            return null;</b>
<b class="nc"><i>3056</i>&nbsp;        }</b>
<b class="nc"><i>3057</i>&nbsp;</b>
<i>3058</i>&nbsp;
<b class="nc"><i>3059</i>&nbsp;        /*</b>
<i>3060</i>&nbsp;         * Returns the paragraph element for the specified index.
<i>3061</i>&nbsp;         */
<i>3062</i>&nbsp;        private Element getParagraphElement(int index) {
<i>3063</i>&nbsp;            if (model instanceof PlainDocument ) {
<i>3064</i>&nbsp;                PlainDocument sdoc = (PlainDocument)model;
<i>3065</i>&nbsp;                return sdoc.getParagraphElement(index);
<i>3066</i>&nbsp;            } else if (model instanceof StyledDocument) {
<i>3067</i>&nbsp;                StyledDocument sdoc = (StyledDocument)model;
<i>3068</i>&nbsp;                return sdoc.getParagraphElement(index);
<i>3069</i>&nbsp;            } else {
<b class="nc"><i>3070</i>&nbsp;                Element para;</b>
<i>3071</i>&nbsp;                for (para = model.getDefaultRootElement(); ! para.isLeaf(); ) {
<i>3072</i>&nbsp;                    int pos = para.getElementIndex(index);
<b class="nc"><i>3073</i>&nbsp;                    para = para.getElement(pos);</b>
<b class="nc"><i>3074</i>&nbsp;                }</b>
<i>3075</i>&nbsp;                if (para == null) {
<b class="nc"><i>3076</i>&nbsp;                    return null;</b>
<b class="nc"><i>3077</i>&nbsp;                }</b>
<b class="nc"><i>3078</i>&nbsp;                return para.getParentElement();</b>
<b class="nc"><i>3079</i>&nbsp;            }</b>
<b class="nc"><i>3080</i>&nbsp;        }</b>
<b class="nc"><i>3081</i>&nbsp;</b>
<b class="nc"><i>3082</i>&nbsp;        /*</b>
<i>3083</i>&nbsp;         * Returns a &lt;code&gt;Segment&lt;/code&gt; containing the paragraph text
<b class="nc"><i>3084</i>&nbsp;         * at &lt;code&gt;index&lt;/code&gt;, or null if &lt;code&gt;index&lt;/code&gt; isn&#39;t</b>
<i>3085</i>&nbsp;         * valid.
<i>3086</i>&nbsp;         */
<i>3087</i>&nbsp;        private IndexedSegment getParagraphElementText(int index)
<i>3088</i>&nbsp;                                  throws BadLocationException {
<i>3089</i>&nbsp;            Element para = getParagraphElement(index);
<i>3090</i>&nbsp;
<i>3091</i>&nbsp;
<i>3092</i>&nbsp;            if (para != null) {
<i>3093</i>&nbsp;                IndexedSegment segment = new IndexedSegment();
<i>3094</i>&nbsp;                try {
<i>3095</i>&nbsp;                    int length = para.getEndOffset() - para.getStartOffset();
<i>3096</i>&nbsp;                    model.getText(para.getStartOffset(), length, segment);
<i>3097</i>&nbsp;                } catch (BadLocationException e) {
<b class="nc"><i>3098</i>&nbsp;                    return null;</b>
<b class="nc"><i>3099</i>&nbsp;                }</b>
<b class="nc"><i>3100</i>&nbsp;                segment.modelOffset = para.getStartOffset();</b>
<i>3101</i>&nbsp;                return segment;
<i>3102</i>&nbsp;            }
<b class="nc"><i>3103</i>&nbsp;            return null;</b>
<i>3104</i>&nbsp;        }
<b class="nc"><i>3105</i>&nbsp;</b>
<b class="nc"><i>3106</i>&nbsp;</b>
<i>3107</i>&nbsp;        /**
<b class="nc"><i>3108</i>&nbsp;         * Returns the Segment at &lt;code&gt;index&lt;/code&gt; representing either</b>
<b class="nc"><i>3109</i>&nbsp;         * the paragraph or sentence as identified by &lt;code&gt;part&lt;/code&gt;, or</b>
<i>3110</i>&nbsp;         * null if a valid paragraph/sentence can&#39;t be found. The offset
<b class="nc"><i>3111</i>&nbsp;         * will point to the start of the word/sentence in the array, and</b>
<i>3112</i>&nbsp;         * the modelOffset will point to the location of the word/sentence
<b class="nc"><i>3113</i>&nbsp;         * in the model.</b>
<b class="nc"><i>3114</i>&nbsp;         */</b>
<b class="nc"><i>3115</i>&nbsp;        private IndexedSegment getSegmentAt(int part, int index) throws</b>
<b class="nc"><i>3116</i>&nbsp;                                  BadLocationException {</b>
<b class="nc"><i>3117</i>&nbsp;            IndexedSegment seg = getParagraphElementText(index);</b>
<i>3118</i>&nbsp;            if (seg == null) {
<b class="nc"><i>3119</i>&nbsp;                return null;</b>
<b class="nc"><i>3120</i>&nbsp;            }</b>
<i>3121</i>&nbsp;            BreakIterator iterator;
<b class="nc"><i>3122</i>&nbsp;            switch (part) {</b>
<b class="nc"><i>3123</i>&nbsp;            case AccessibleText.WORD:</b>
<i>3124</i>&nbsp;                iterator = BreakIterator.getWordInstance(getLocale());
<b class="nc"><i>3125</i>&nbsp;                break;</b>
<i>3126</i>&nbsp;            case AccessibleText.SENTENCE:
<b class="nc"><i>3127</i>&nbsp;                iterator = BreakIterator.getSentenceInstance(getLocale());</b>
<b class="nc"><i>3128</i>&nbsp;                break;</b>
<b class="nc"><i>3129</i>&nbsp;            default:</b>
<b class="nc"><i>3130</i>&nbsp;                return null;</b>
<i>3131</i>&nbsp;            }
<i>3132</i>&nbsp;            seg.first();
<i>3133</i>&nbsp;            iterator.setText(seg);
<i>3134</i>&nbsp;            int end = iterator.following(index - seg.modelOffset + seg.offset);
<i>3135</i>&nbsp;            if (end == BreakIterator.DONE) {
<i>3136</i>&nbsp;                return null;
<i>3137</i>&nbsp;            }
<i>3138</i>&nbsp;            if (end &gt; seg.offset + seg.count) {
<i>3139</i>&nbsp;                return null;
<i>3140</i>&nbsp;            }
<i>3141</i>&nbsp;            int begin = iterator.previous();
<i>3142</i>&nbsp;            if (begin == BreakIterator.DONE ||
<b class="nc"><i>3143</i>&nbsp;                         begin &gt;= seg.offset + seg.count) {</b>
<i>3144</i>&nbsp;                return null;
<i>3145</i>&nbsp;            }
<i>3146</i>&nbsp;            seg.modelOffset = seg.modelOffset + begin - seg.offset;
<i>3147</i>&nbsp;            seg.offset = begin;
<i>3148</i>&nbsp;            seg.count = end - begin;
<i>3149</i>&nbsp;            return seg;
<i>3150</i>&nbsp;        }
<i>3151</i>&nbsp;
<i>3152</i>&nbsp;        // begin AccessibleEditableText methods -----
<b class="nc"><i>3153</i>&nbsp;</b>
<i>3154</i>&nbsp;        /**
<i>3155</i>&nbsp;         * Returns the AccessibleEditableText interface for
<i>3156</i>&nbsp;         * this text component.
<i>3157</i>&nbsp;         *
<i>3158</i>&nbsp;         * @return the AccessibleEditableText interface
<i>3159</i>&nbsp;         * @since 1.4
<i>3160</i>&nbsp;         */
<i>3161</i>&nbsp;        public AccessibleEditableText getAccessibleEditableText() {
<i>3162</i>&nbsp;            return this;
<i>3163</i>&nbsp;        }
<i>3164</i>&nbsp;
<b class="nc"><i>3165</i>&nbsp;        /**</b>
<b class="nc"><i>3166</i>&nbsp;         * Sets the text contents to the specified string.</b>
<i>3167</i>&nbsp;         *
<b class="nc"><i>3168</i>&nbsp;         * @param s the string to set the text contents</b>
<b class="nc"><i>3169</i>&nbsp;         * @since 1.4</b>
<b class="nc"><i>3170</i>&nbsp;         */</b>
<b class="nc"><i>3171</i>&nbsp;        public void setTextContents(String s) {</b>
<b class="nc"><i>3172</i>&nbsp;            JTextComponent.this.setText(s);</b>
<i>3173</i>&nbsp;        }
<i>3174</i>&nbsp;
<b class="nc"><i>3175</i>&nbsp;        /**</b>
<b class="nc"><i>3176</i>&nbsp;         * Inserts the specified string at the given index</b>
<b class="nc"><i>3177</i>&nbsp;         *</b>
<i>3178</i>&nbsp;         * @param index the index in the text where the string will
<i>3179</i>&nbsp;         * be inserted
<i>3180</i>&nbsp;         * @param s the string to insert in the text
<i>3181</i>&nbsp;         * @since 1.4
<i>3182</i>&nbsp;         */
<i>3183</i>&nbsp;        public void insertTextAtIndex(int index, String s) {
<i>3184</i>&nbsp;            Document doc = JTextComponent.this.getDocument();
<i>3185</i>&nbsp;            if (doc != null) {
<i>3186</i>&nbsp;                try {
<i>3187</i>&nbsp;                    if (s != null &amp;&amp; s.length() &gt; 0) {
<i>3188</i>&nbsp;                        boolean composedTextSaved = saveComposedText(index);
<i>3189</i>&nbsp;                        doc.insertString(index, s, null);
<b class="nc"><i>3190</i>&nbsp;                        if (composedTextSaved) {</b>
<b class="nc"><i>3191</i>&nbsp;                            restoreComposedText();</b>
<b class="nc"><i>3192</i>&nbsp;                        }</b>
<b class="nc"><i>3193</i>&nbsp;                    }</b>
<i>3194</i>&nbsp;                } catch (BadLocationException e) {
<b class="nc"><i>3195</i>&nbsp;                    UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);</b>
<b class="nc"><i>3196</i>&nbsp;                }</b>
<b class="nc"><i>3197</i>&nbsp;            }</b>
<b class="nc"><i>3198</i>&nbsp;        }</b>
<b class="nc"><i>3199</i>&nbsp;</b>
<i>3200</i>&nbsp;        /**
<b class="nc"><i>3201</i>&nbsp;         * Returns the text string between two indices.</b>
<i>3202</i>&nbsp;         *
<i>3203</i>&nbsp;         * @param startIndex the starting index in the text
<i>3204</i>&nbsp;         * @param endIndex the ending index in the text
<i>3205</i>&nbsp;         * @return the text string between the indices
<i>3206</i>&nbsp;         * @since 1.4
<i>3207</i>&nbsp;         */
<i>3208</i>&nbsp;        public String getTextRange(int startIndex, int endIndex) {
<i>3209</i>&nbsp;            String txt = null;
<i>3210</i>&nbsp;            int p0 = Math.min(startIndex, endIndex);
<i>3211</i>&nbsp;            int p1 = Math.max(startIndex, endIndex);
<b class="nc"><i>3212</i>&nbsp;            if (p0 != p1) {</b>
<i>3213</i>&nbsp;                try {
<b class="nc"><i>3214</i>&nbsp;                    Document doc = JTextComponent.this.getDocument();</b>
<b class="nc"><i>3215</i>&nbsp;                    txt = doc.getText(p0, p1 - p0);</b>
<b class="nc"><i>3216</i>&nbsp;                } catch (BadLocationException e) {</b>
<b class="nc"><i>3217</i>&nbsp;                    throw new IllegalArgumentException(e.getMessage());</b>
<b class="nc"><i>3218</i>&nbsp;                }</b>
<i>3219</i>&nbsp;            }
<b class="nc"><i>3220</i>&nbsp;            return txt;</b>
<b class="nc"><i>3221</i>&nbsp;        }</b>
<i>3222</i>&nbsp;
<b class="nc"><i>3223</i>&nbsp;        /**</b>
<i>3224</i>&nbsp;         * Deletes the text between two indices
<i>3225</i>&nbsp;         *
<i>3226</i>&nbsp;         * @param startIndex the starting index in the text
<i>3227</i>&nbsp;         * @param endIndex the ending index in the text
<i>3228</i>&nbsp;         * @since 1.4
<i>3229</i>&nbsp;         */
<i>3230</i>&nbsp;        public void delete(int startIndex, int endIndex) {
<i>3231</i>&nbsp;            if (isEditable() &amp;&amp; isEnabled()) {
<i>3232</i>&nbsp;                try {
<i>3233</i>&nbsp;                    int p0 = Math.min(startIndex, endIndex);
<i>3234</i>&nbsp;                    int p1 = Math.max(startIndex, endIndex);
<b class="nc"><i>3235</i>&nbsp;                    if (p0 != p1) {</b>
<b class="nc"><i>3236</i>&nbsp;                        Document doc = getDocument();</b>
<i>3237</i>&nbsp;                        doc.remove(p0, p1 - p0);
<i>3238</i>&nbsp;                    }
<i>3239</i>&nbsp;                } catch (BadLocationException e) {
<i>3240</i>&nbsp;                }
<i>3241</i>&nbsp;            } else {
<i>3242</i>&nbsp;                UIManager.getLookAndFeel().provideErrorFeedback(JTextComponent.this);
<i>3243</i>&nbsp;            }
<i>3244</i>&nbsp;        }
<i>3245</i>&nbsp;
<i>3246</i>&nbsp;        /**
<b class="nc"><i>3247</i>&nbsp;         * Cuts the text between two indices into the system clipboard.</b>
<b class="nc"><i>3248</i>&nbsp;         *</b>
<i>3249</i>&nbsp;         * @param startIndex the starting index in the text
<i>3250</i>&nbsp;         * @param endIndex the ending index in the text
<i>3251</i>&nbsp;         * @since 1.4
<i>3252</i>&nbsp;         */
<i>3253</i>&nbsp;        public void cut(int startIndex, int endIndex) {
<i>3254</i>&nbsp;            selectText(startIndex, endIndex);
<i>3255</i>&nbsp;            JTextComponent.this.cut();
<i>3256</i>&nbsp;        }
<i>3257</i>&nbsp;
<i>3258</i>&nbsp;        /**
<i>3259</i>&nbsp;         * Pastes the text from the system clipboard into the text
<i>3260</i>&nbsp;         * starting at the specified index.
<b class="nc"><i>3261</i>&nbsp;         *</b>
<b class="nc"><i>3262</i>&nbsp;         * @param startIndex the starting index in the text</b>
<i>3263</i>&nbsp;         * @since 1.4
<i>3264</i>&nbsp;         */
<i>3265</i>&nbsp;        public void paste(int startIndex) {
<i>3266</i>&nbsp;            setCaretPosition(startIndex);
<i>3267</i>&nbsp;            JTextComponent.this.paste();
<i>3268</i>&nbsp;        }
<i>3269</i>&nbsp;
<i>3270</i>&nbsp;        /**
<i>3271</i>&nbsp;         * Replaces the text between two indices with the specified
<i>3272</i>&nbsp;         * string.
<b class="nc"><i>3273</i>&nbsp;         *</b>
<i>3274</i>&nbsp;         * @param startIndex the starting index in the text
<i>3275</i>&nbsp;         * @param endIndex the ending index in the text
<i>3276</i>&nbsp;         * @param s the string to replace the text between two indices
<i>3277</i>&nbsp;         * @since 1.4
<i>3278</i>&nbsp;         */
<i>3279</i>&nbsp;        public void replaceText(int startIndex, int endIndex, String s) {
<i>3280</i>&nbsp;            selectText(startIndex, endIndex);
<i>3281</i>&nbsp;            JTextComponent.this.replaceSelection(s);
<i>3282</i>&nbsp;        }
<i>3283</i>&nbsp;
<i>3284</i>&nbsp;        /**
<i>3285</i>&nbsp;         * Selects the text between two indices.
<i>3286</i>&nbsp;         *
<i>3287</i>&nbsp;         * @param startIndex the starting index in the text
<i>3288</i>&nbsp;         * @param endIndex the ending index in the text
<b class="nc"><i>3289</i>&nbsp;         * @since 1.4</b>
<b class="nc"><i>3290</i>&nbsp;         */</b>
<b class="nc"><i>3291</i>&nbsp;        public void selectText(int startIndex, int endIndex) {</b>
<b class="nc"><i>3292</i>&nbsp;            JTextComponent.this.select(startIndex, endIndex);</b>
<b class="nc"><i>3293</i>&nbsp;        }</b>
<b class="nc"><i>3294</i>&nbsp;</b>
<i>3295</i>&nbsp;        /**
<i>3296</i>&nbsp;         * Sets attributes for the text between two indices.
<i>3297</i>&nbsp;         *
<i>3298</i>&nbsp;         * @param startIndex the starting index in the text
<i>3299</i>&nbsp;         * @param endIndex the ending index in the text
<i>3300</i>&nbsp;         * @param as the attribute set
<i>3301</i>&nbsp;         * @see AttributeSet
<i>3302</i>&nbsp;         * @since 1.4
<i>3303</i>&nbsp;         */
<i>3304</i>&nbsp;        public void setAttributes(int startIndex, int endIndex,
<i>3305</i>&nbsp;            AttributeSet as) {
<i>3306</i>&nbsp;
<i>3307</i>&nbsp;            // Fixes bug 4487492
<i>3308</i>&nbsp;            Document doc = JTextComponent.this.getDocument();
<i>3309</i>&nbsp;            if (doc != null &amp;&amp; doc instanceof StyledDocument) {
<i>3310</i>&nbsp;                StyledDocument sDoc = (StyledDocument)doc;
<i>3311</i>&nbsp;                int offset = startIndex;
<i>3312</i>&nbsp;                int length = endIndex - startIndex;
<i>3313</i>&nbsp;                sDoc.setCharacterAttributes(offset, length, as, true);
<i>3314</i>&nbsp;            }
<i>3315</i>&nbsp;        }
<i>3316</i>&nbsp;
<i>3317</i>&nbsp;        // ----- end AccessibleEditableText methods
<i>3318</i>&nbsp;
<i>3319</i>&nbsp;
<i>3320</i>&nbsp;        // ----- begin AccessibleExtendedText methods
<i>3321</i>&nbsp;
<i>3322</i>&nbsp;// Probably should replace the helper method getAtIndex() to return
<i>3323</i>&nbsp;// instead an AccessibleTextSequence also for LINE &amp; ATTRIBUTE_RUN
<i>3324</i>&nbsp;// and then make the AccessibleText methods get[At|After|Before]Point
<i>3325</i>&nbsp;// call this new method instead and return only the string portion
<i>3326</i>&nbsp;
<i>3327</i>&nbsp;        /**
<i>3328</i>&nbsp;         * Returns the AccessibleTextSequence at a given &lt;code&gt;index&lt;/code&gt;.
<i>3329</i>&nbsp;         * If &lt;code&gt;direction&lt;/code&gt; is non-null this will find the
<i>3330</i>&nbsp;         * next/previous word/sentence/character.
<i>3331</i>&nbsp;         *
<b class="nc"><i>3332</i>&nbsp;         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,</b>
<b class="nc"><i>3333</i>&nbsp;         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or</b>
<i>3334</i>&nbsp;         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
<b class="nc"><i>3335</i>&nbsp;         * @param index an index within the text</b>
<b class="nc"><i>3336</i>&nbsp;         * @param direction is either -1, 0, or 1</b>
<i>3337</i>&nbsp;         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
<i>3338</i>&nbsp;         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
<b class="nc"><i>3339</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; is returned.</b>
<i>3340</i>&nbsp;         *
<b class="nc"><i>3341</i>&nbsp;         * @see javax.accessibility.AccessibleText#CHARACTER</b>
<b class="nc"><i>3342</i>&nbsp;         * @see javax.accessibility.AccessibleText#WORD</b>
<i>3343</i>&nbsp;         * @see javax.accessibility.AccessibleText#SENTENCE
<b class="nc"><i>3344</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#LINE</b>
<i>3345</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
<b class="nc"><i>3346</i>&nbsp;         *</b>
<i>3347</i>&nbsp;         * @since 1.6
<b class="nc"><i>3348</i>&nbsp;         */</b>
<i>3349</i>&nbsp;        private AccessibleTextSequence getSequenceAtIndex(int part,
<i>3350</i>&nbsp;            int index, int direction) {
<b class="nc"><i>3351</i>&nbsp;            if (index &lt; 0 || index &gt;= model.getLength()) {</b>
<i>3352</i>&nbsp;                return null;
<i>3353</i>&nbsp;            }
<b class="nc"><i>3354</i>&nbsp;            if (direction &lt; -1 || direction &gt; 1) {</b>
<i>3355</i>&nbsp;                return null;    // direction must be 1, 0, or -1
<i>3356</i>&nbsp;            }
<i>3357</i>&nbsp;
<b class="nc"><i>3358</i>&nbsp;            switch (part) {</b>
<b class="nc"><i>3359</i>&nbsp;            case AccessibleText.CHARACTER:</b>
<i>3360</i>&nbsp;                if (model instanceof AbstractDocument) {
<i>3361</i>&nbsp;                    ((AbstractDocument)model).readLock();
<b class="nc"><i>3362</i>&nbsp;                }</b>
<i>3363</i>&nbsp;                AccessibleTextSequence charSequence = null;
<i>3364</i>&nbsp;                try {
<i>3365</i>&nbsp;                    if (index + direction &lt; model.getLength() &amp;&amp;
<b class="nc"><i>3366</i>&nbsp;                        index + direction &gt;= 0) {</b>
<b class="nc"><i>3367</i>&nbsp;                        charSequence =</b>
<i>3368</i>&nbsp;                            new AccessibleTextSequence(index + direction,
<b class="nc"><i>3369</i>&nbsp;                            index + direction + 1,</b>
<i>3370</i>&nbsp;                            model.getText(index + direction, 1));
<b class="nc"><i>3371</i>&nbsp;                    }</b>
<b class="nc"><i>3372</i>&nbsp;</b>
<b class="nc"><i>3373</i>&nbsp;                } catch (BadLocationException e) {</b>
<i>3374</i>&nbsp;                    // we are intentionally silent; our contract says we return
<i>3375</i>&nbsp;                    // null if there is any failure in this method
<b class="nc"><i>3376</i>&nbsp;                } finally {</b>
<b class="nc"><i>3377</i>&nbsp;                    if (model instanceof AbstractDocument) {</b>
<i>3378</i>&nbsp;                        ((AbstractDocument)model).readUnlock();
<i>3379</i>&nbsp;                    }
<b class="nc"><i>3380</i>&nbsp;                }</b>
<i>3381</i>&nbsp;                return charSequence;
<b class="nc"><i>3382</i>&nbsp;</b>
<b class="nc"><i>3383</i>&nbsp;            case AccessibleText.WORD:</b>
<i>3384</i>&nbsp;            case AccessibleText.SENTENCE:
<i>3385</i>&nbsp;                if (model instanceof AbstractDocument) {
<b class="nc"><i>3386</i>&nbsp;                    ((AbstractDocument)model).readLock();</b>
<i>3387</i>&nbsp;                }
<i>3388</i>&nbsp;                AccessibleTextSequence rangeSequence = null;
<b class="nc"><i>3389</i>&nbsp;                try {</b>
<b class="nc"><i>3390</i>&nbsp;                    IndexedSegment seg = getSegmentAt(part, index);</b>
<b class="nc"><i>3391</i>&nbsp;                    if (seg != null) {</b>
<i>3392</i>&nbsp;                        if (direction != 0) {
<i>3393</i>&nbsp;                            int next;
<i>3394</i>&nbsp;
<i>3395</i>&nbsp;                            if (direction &lt; 0) {
<i>3396</i>&nbsp;                                next = seg.modelOffset - 1;
<b class="nc"><i>3397</i>&nbsp;                            }</b>
<i>3398</i>&nbsp;                            else {
<i>3399</i>&nbsp;                                next = seg.modelOffset + seg.count;
<i>3400</i>&nbsp;                            }
<b class="nc"><i>3401</i>&nbsp;                            if (next &gt;= 0 &amp;&amp; next &lt;= model.getLength()) {</b>
<b class="nc"><i>3402</i>&nbsp;                                seg = getSegmentAt(part, next);</b>
<i>3403</i>&nbsp;                            }
<i>3404</i>&nbsp;                            else {
<b class="nc"><i>3405</i>&nbsp;                                seg = null;</b>
<i>3406</i>&nbsp;                            }
<i>3407</i>&nbsp;                        }
<b class="nc"><i>3408</i>&nbsp;                        if (seg != null &amp;&amp;</b>
<b class="nc"><i>3409</i>&nbsp;                            (seg.offset + seg.count) &lt;= model.getLength()) {</b>
<b class="nc"><i>3410</i>&nbsp;                            rangeSequence =</b>
<i>3411</i>&nbsp;                                new AccessibleTextSequence (seg.offset,
<i>3412</i>&nbsp;                                seg.offset + seg.count,
<b class="nc"><i>3413</i>&nbsp;                                new String(seg.array, seg.offset, seg.count));</b>
<b class="nc"><i>3414</i>&nbsp;                        } // else we leave rangeSequence set to null</b>
<b class="nc"><i>3415</i>&nbsp;                    }</b>
<b class="nc"><i>3416</i>&nbsp;                } catch(BadLocationException e) {</b>
<b class="nc"><i>3417</i>&nbsp;                    // we are intentionally silent; our contract says we return</b>
<b class="nc"><i>3418</i>&nbsp;                    // null if there is any failure in this method</b>
<b class="nc"><i>3419</i>&nbsp;                } finally {</b>
<i>3420</i>&nbsp;                    if (model instanceof AbstractDocument) {
<b class="nc"><i>3421</i>&nbsp;                        ((AbstractDocument)model).readUnlock();</b>
<i>3422</i>&nbsp;                    }
<b class="nc"><i>3423</i>&nbsp;                }</b>
<b class="nc"><i>3424</i>&nbsp;                return rangeSequence;</b>
<b class="nc"><i>3425</i>&nbsp;</b>
<i>3426</i>&nbsp;            case AccessibleExtendedText.LINE:
<b class="nc"><i>3427</i>&nbsp;                AccessibleTextSequence lineSequence = null;</b>
<b class="nc"><i>3428</i>&nbsp;                if (model instanceof AbstractDocument) {</b>
<i>3429</i>&nbsp;                    ((AbstractDocument)model).readLock();
<b class="nc"><i>3430</i>&nbsp;                }</b>
<b class="nc"><i>3431</i>&nbsp;                try {</b>
<i>3432</i>&nbsp;                    int startIndex =
<i>3433</i>&nbsp;                        Utilities.getRowStart(JTextComponent.this, index);
<b class="nc"><i>3434</i>&nbsp;                    int endIndex =</b>
<i>3435</i>&nbsp;                        Utilities.getRowEnd(JTextComponent.this, index);
<i>3436</i>&nbsp;                    if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {
<b class="nc"><i>3437</i>&nbsp;                        if (direction == 0) {</b>
<b class="nc"><i>3438</i>&nbsp;                            lineSequence =</b>
<b class="nc"><i>3439</i>&nbsp;                                new AccessibleTextSequence(startIndex, endIndex,</b>
<b class="nc"><i>3440</i>&nbsp;                                    model.getText(startIndex,</b>
<i>3441</i>&nbsp;                                        endIndex - startIndex + 1));
<b class="nc"><i>3442</i>&nbsp;                        } else if (direction == -1 &amp;&amp; startIndex &gt; 0) {</b>
<b class="nc"><i>3443</i>&nbsp;                            endIndex =</b>
<i>3444</i>&nbsp;                                Utilities.getRowEnd(JTextComponent.this,
<b class="nc"><i>3445</i>&nbsp;                                    startIndex - 1);</b>
<b class="nc"><i>3446</i>&nbsp;                            startIndex =</b>
<i>3447</i>&nbsp;                                Utilities.getRowStart(JTextComponent.this,
<b class="nc"><i>3448</i>&nbsp;                                    startIndex - 1);</b>
<i>3449</i>&nbsp;                            if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {
<i>3450</i>&nbsp;                                lineSequence =
<i>3451</i>&nbsp;                                    new AccessibleTextSequence(startIndex,
<i>3452</i>&nbsp;                                        endIndex,
<i>3453</i>&nbsp;                                        model.getText(startIndex,
<b class="nc"><i>3454</i>&nbsp;                                            endIndex - startIndex + 1));</b>
<i>3455</i>&nbsp;                            }
<i>3456</i>&nbsp;                        } else if (direction == 1 &amp;&amp;
<i>3457</i>&nbsp;                         endIndex &lt; model.getLength()) {
<b class="nc"><i>3458</i>&nbsp;                            startIndex =</b>
<b class="nc"><i>3459</i>&nbsp;                                Utilities.getRowStart(JTextComponent.this,</b>
<i>3460</i>&nbsp;                                    endIndex + 1);
<i>3461</i>&nbsp;                            endIndex =
<b class="nc"><i>3462</i>&nbsp;                                Utilities.getRowEnd(JTextComponent.this,</b>
<i>3463</i>&nbsp;                                    endIndex + 1);
<i>3464</i>&nbsp;                            if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= startIndex) {
<i>3465</i>&nbsp;                                lineSequence =
<i>3466</i>&nbsp;                                    new AccessibleTextSequence(startIndex,
<i>3467</i>&nbsp;                                        endIndex, model.getText(startIndex,
<i>3468</i>&nbsp;                                            endIndex - startIndex + 1));
<i>3469</i>&nbsp;                            }
<b class="nc"><i>3470</i>&nbsp;                        }</b>
<b class="nc"><i>3471</i>&nbsp;                        // already validated &#39;direction&#39; above...</b>
<b class="nc"><i>3472</i>&nbsp;                    }</b>
<i>3473</i>&nbsp;                } catch(BadLocationException e) {
<i>3474</i>&nbsp;                    // we are intentionally silent; our contract says we return
<i>3475</i>&nbsp;                    // null if there is any failure in this method
<b class="nc"><i>3476</i>&nbsp;                } finally {</b>
<i>3477</i>&nbsp;                    if (model instanceof AbstractDocument) {
<b class="nc"><i>3478</i>&nbsp;                        ((AbstractDocument)model).readUnlock();</b>
<b class="nc"><i>3479</i>&nbsp;                    }</b>
<i>3480</i>&nbsp;                }
<i>3481</i>&nbsp;                return lineSequence;
<i>3482</i>&nbsp;
<i>3483</i>&nbsp;            case AccessibleExtendedText.ATTRIBUTE_RUN:
<b class="nc"><i>3484</i>&nbsp;                // assumptions: (1) that all characters in a single element</b>
<i>3485</i>&nbsp;                // share the same attribute set; (2) that adjacent elements
<i>3486</i>&nbsp;                // *may* share the same attribute set
<b class="nc"><i>3487</i>&nbsp;</b>
<b class="nc"><i>3488</i>&nbsp;                int attributeRunStartIndex, attributeRunEndIndex;</b>
<i>3489</i>&nbsp;                String runText = null;
<i>3490</i>&nbsp;                if (model instanceof AbstractDocument) {
<i>3491</i>&nbsp;                    ((AbstractDocument)model).readLock();
<i>3492</i>&nbsp;                }
<b class="nc"><i>3493</i>&nbsp;</b>
<i>3494</i>&nbsp;                try {
<i>3495</i>&nbsp;                    attributeRunStartIndex = attributeRunEndIndex =
<b class="nc"><i>3496</i>&nbsp;                     Integer.MIN_VALUE;</b>
<b class="nc"><i>3497</i>&nbsp;                    int tempIndex = index;</b>
<i>3498</i>&nbsp;                    switch (direction) {
<i>3499</i>&nbsp;                    case -1:
<i>3500</i>&nbsp;                        // going backwards, so find left edge of this run -
<b class="nc"><i>3501</i>&nbsp;                        // that&#39;ll be the end of the previous run</b>
<i>3502</i>&nbsp;                        // (off-by-one counting)
<i>3503</i>&nbsp;                        attributeRunEndIndex = getRunEdge(index, direction);
<b class="nc"><i>3504</i>&nbsp;                        // now set ourselves up to find the left edge of the</b>
<i>3505</i>&nbsp;                        // prev. run
<i>3506</i>&nbsp;                        tempIndex = attributeRunEndIndex - 1;
<i>3507</i>&nbsp;                        break;
<i>3508</i>&nbsp;                    case 1:
<b class="nc"><i>3509</i>&nbsp;                        // going forward, so find right edge of this run -</b>
<i>3510</i>&nbsp;                        // that&#39;ll be the start of the next run
<b class="nc"><i>3511</i>&nbsp;                        // (off-by-one counting)</b>
<b class="nc"><i>3512</i>&nbsp;                        attributeRunStartIndex = getRunEdge(index, direction);</b>
<i>3513</i>&nbsp;                        // now set ourselves up to find the right edge of the
<b class="nc"><i>3514</i>&nbsp;                        // next run</b>
<i>3515</i>&nbsp;                        tempIndex = attributeRunStartIndex;
<b class="nc"><i>3516</i>&nbsp;                        break;</b>
<i>3517</i>&nbsp;                    case 0:
<i>3518</i>&nbsp;                        // interested in the current run, so nothing special to
<b class="nc"><i>3519</i>&nbsp;                        // set up in advance...</b>
<i>3520</i>&nbsp;                        break;
<i>3521</i>&nbsp;                    default:
<b class="nc"><i>3522</i>&nbsp;                        // only those three values of direction allowed...</b>
<i>3523</i>&nbsp;                        throw new AssertionError(direction);
<b class="nc"><i>3524</i>&nbsp;                    }</b>
<b class="nc"><i>3525</i>&nbsp;</b>
<i>3526</i>&nbsp;                    // set the unset edge; if neither set then we&#39;re getting
<i>3527</i>&nbsp;                    // both edges of the current run around our &#39;index&#39;
<b class="nc"><i>3528</i>&nbsp;                    attributeRunStartIndex =</b>
<i>3529</i>&nbsp;                        (attributeRunStartIndex != Integer.MIN_VALUE) ?
<i>3530</i>&nbsp;                        attributeRunStartIndex : getRunEdge(tempIndex, -1);
<i>3531</i>&nbsp;                    attributeRunEndIndex =
<i>3532</i>&nbsp;                        (attributeRunEndIndex != Integer.MIN_VALUE) ?
<i>3533</i>&nbsp;                        attributeRunEndIndex : getRunEdge(tempIndex, 1);
<i>3534</i>&nbsp;
<b class="nc"><i>3535</i>&nbsp;                    runText = model.getText(attributeRunStartIndex,</b>
<i>3536</i>&nbsp;                                            attributeRunEndIndex -
<i>3537</i>&nbsp;                                            attributeRunStartIndex);
<i>3538</i>&nbsp;                } catch (BadLocationException e) {
<i>3539</i>&nbsp;                    // we are intentionally silent; our contract says we return
<i>3540</i>&nbsp;                    // null if there is any failure in this method
<i>3541</i>&nbsp;                    return null;
<i>3542</i>&nbsp;                } finally {
<i>3543</i>&nbsp;                    if (model instanceof AbstractDocument) {
<i>3544</i>&nbsp;                        ((AbstractDocument)model).readUnlock();
<i>3545</i>&nbsp;                    }
<i>3546</i>&nbsp;                }
<i>3547</i>&nbsp;                return new AccessibleTextSequence(attributeRunStartIndex,
<i>3548</i>&nbsp;                                                  attributeRunEndIndex,
<b class="nc"><i>3549</i>&nbsp;                                                  runText);</b>
<b class="nc"><i>3550</i>&nbsp;</b>
<i>3551</i>&nbsp;            default:
<i>3552</i>&nbsp;                break;
<i>3553</i>&nbsp;            }
<i>3554</i>&nbsp;            return null;
<b class="nc"><i>3555</i>&nbsp;        }</b>
<b class="nc"><i>3556</i>&nbsp;</b>
<b class="nc"><i>3557</i>&nbsp;</b>
<b class="nc"><i>3558</i>&nbsp;        /**</b>
<b class="nc"><i>3559</i>&nbsp;         * Starting at text position &lt;code&gt;index&lt;/code&gt;, and going in</b>
<i>3560</i>&nbsp;         * &lt;code&gt;direction&lt;/code&gt;, return the edge of run that shares the
<b class="nc"><i>3561</i>&nbsp;         * same &lt;code&gt;AttributeSet&lt;/code&gt; and parent element as those at</b>
<b class="nc"><i>3562</i>&nbsp;         * &lt;code&gt;index&lt;/code&gt;.</b>
<i>3563</i>&nbsp;         *
<i>3564</i>&nbsp;         * Note: we assume the document is already locked...
<b class="nc"><i>3565</i>&nbsp;         */</b>
<b class="nc"><i>3566</i>&nbsp;        private int getRunEdge(int index, int direction) throws</b>
<i>3567</i>&nbsp;         BadLocationException {
<i>3568</i>&nbsp;            if (index &lt; 0 || index &gt;= model.getLength()) {
<i>3569</i>&nbsp;                throw new BadLocationException(&quot;Location out of bounds&quot;, index);
<i>3570</i>&nbsp;            }
<i>3571</i>&nbsp;            // locate the Element at index
<b class="nc"><i>3572</i>&nbsp;            Element indexElement;</b>
<i>3573</i>&nbsp;            // locate the Element at our index/offset
<i>3574</i>&nbsp;            int elementIndex = -1;        // test for initialization
<b class="nc"><i>3575</i>&nbsp;            for (indexElement = model.getDefaultRootElement();</b>
<b class="nc"><i>3576</i>&nbsp;                 ! indexElement.isLeaf(); ) {</b>
<b class="nc"><i>3577</i>&nbsp;                elementIndex = indexElement.getElementIndex(index);</b>
<i>3578</i>&nbsp;                indexElement = indexElement.getElement(elementIndex);
<b class="nc"><i>3579</i>&nbsp;            }</b>
<b class="nc"><i>3580</i>&nbsp;            if (elementIndex == -1) {</b>
<b class="nc"><i>3581</i>&nbsp;                throw new AssertionError(index);</b>
<i>3582</i>&nbsp;            }
<b class="nc"><i>3583</i>&nbsp;            // cache the AttributeSet and parentElement atindex</b>
<b class="nc"><i>3584</i>&nbsp;            AttributeSet indexAS = indexElement.getAttributes();</b>
<i>3585</i>&nbsp;            Element parent = indexElement.getParentElement();
<b class="nc"><i>3586</i>&nbsp;</b>
<i>3587</i>&nbsp;            // find the first Element before/after ours w/the same AttributeSet
<b class="nc"><i>3588</i>&nbsp;            // if we are already at edge of the first element in our parent</b>
<i>3589</i>&nbsp;            // then return that edge
<b class="nc"><i>3590</i>&nbsp;            Element edgeElement;</b>
<i>3591</i>&nbsp;            switch (direction) {
<b class="nc"><i>3592</i>&nbsp;            case -1:</b>
<i>3593</i>&nbsp;            case 1:
<i>3594</i>&nbsp;                int edgeElementIndex = elementIndex;
<i>3595</i>&nbsp;                int elementCount = parent.getElementCount();
<b class="nc"><i>3596</i>&nbsp;                while ((edgeElementIndex + direction) &gt; 0 &amp;&amp;</b>
<i>3597</i>&nbsp;                       ((edgeElementIndex + direction) &lt; elementCount) &amp;&amp;
<i>3598</i>&nbsp;                       parent.getElement(edgeElementIndex
<i>3599</i>&nbsp;                       + direction).getAttributes().isEqual(indexAS)) {
<i>3600</i>&nbsp;                    edgeElementIndex += direction;
<i>3601</i>&nbsp;                }
<i>3602</i>&nbsp;                edgeElement = parent.getElement(edgeElementIndex);
<i>3603</i>&nbsp;                break;
<i>3604</i>&nbsp;            default:
<i>3605</i>&nbsp;                throw new AssertionError(direction);
<i>3606</i>&nbsp;            }
<i>3607</i>&nbsp;            switch (direction) {
<i>3608</i>&nbsp;            case -1:
<i>3609</i>&nbsp;                return edgeElement.getStartOffset();
<i>3610</i>&nbsp;            case 1:
<i>3611</i>&nbsp;                return edgeElement.getEndOffset();
<i>3612</i>&nbsp;            default:
<i>3613</i>&nbsp;                // we already caught this case earlier; this is to satisfy
<i>3614</i>&nbsp;                // the compiler...
<i>3615</i>&nbsp;                return Integer.MIN_VALUE;
<i>3616</i>&nbsp;            }
<i>3617</i>&nbsp;        }
<i>3618</i>&nbsp;
<i>3619</i>&nbsp;        // getTextRange() not needed; defined in AccessibleEditableText
<i>3620</i>&nbsp;
<i>3621</i>&nbsp;        /**
<i>3622</i>&nbsp;         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; at a given
<b class="nc"><i>3623</i>&nbsp;         * &lt;code&gt;index&lt;/code&gt;.</b>
<i>3624</i>&nbsp;         *
<i>3625</i>&nbsp;         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
<i>3626</i>&nbsp;         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
<i>3627</i>&nbsp;         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
<i>3628</i>&nbsp;         * @param index an index within the text
<i>3629</i>&nbsp;         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text if
<i>3630</i>&nbsp;         * &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
<i>3631</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; is returned
<i>3632</i>&nbsp;         *
<i>3633</i>&nbsp;         * @see javax.accessibility.AccessibleText#CHARACTER
<i>3634</i>&nbsp;         * @see javax.accessibility.AccessibleText#WORD
<i>3635</i>&nbsp;         * @see javax.accessibility.AccessibleText#SENTENCE
<i>3636</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#LINE
<i>3637</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
<i>3638</i>&nbsp;         *
<i>3639</i>&nbsp;         * @since 1.6
<i>3640</i>&nbsp;         */
<i>3641</i>&nbsp;        public AccessibleTextSequence getTextSequenceAt(int part, int index) {
<i>3642</i>&nbsp;            return getSequenceAtIndex(part, index, 0);
<i>3643</i>&nbsp;        }
<i>3644</i>&nbsp;
<i>3645</i>&nbsp;        /**
<i>3646</i>&nbsp;         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; after a given
<b class="nc"><i>3647</i>&nbsp;         * &lt;code&gt;index&lt;/code&gt;.</b>
<i>3648</i>&nbsp;         *
<i>3649</i>&nbsp;         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
<i>3650</i>&nbsp;         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
<i>3651</i>&nbsp;         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
<i>3652</i>&nbsp;         * @param index an index within the text
<i>3653</i>&nbsp;         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
<i>3654</i>&nbsp;         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
<i>3655</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; is returned
<i>3656</i>&nbsp;         *
<i>3657</i>&nbsp;         * @see javax.accessibility.AccessibleText#CHARACTER
<i>3658</i>&nbsp;         * @see javax.accessibility.AccessibleText#WORD
<i>3659</i>&nbsp;         * @see javax.accessibility.AccessibleText#SENTENCE
<i>3660</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#LINE
<i>3661</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
<i>3662</i>&nbsp;         *
<i>3663</i>&nbsp;         * @since 1.6
<i>3664</i>&nbsp;         */
<i>3665</i>&nbsp;        public AccessibleTextSequence getTextSequenceAfter(int part, int index) {
<i>3666</i>&nbsp;            return getSequenceAtIndex(part, index, 1);
<i>3667</i>&nbsp;        }
<i>3668</i>&nbsp;
<i>3669</i>&nbsp;        /**
<i>3670</i>&nbsp;         * Returns the &lt;code&gt;AccessibleTextSequence&lt;/code&gt; before a given
<b class="nc"><i>3671</i>&nbsp;         * &lt;code&gt;index&lt;/code&gt;.</b>
<i>3672</i>&nbsp;         *
<i>3673</i>&nbsp;         * @param part the &lt;code&gt;CHARACTER&lt;/code&gt;, &lt;code&gt;WORD&lt;/code&gt;,
<i>3674</i>&nbsp;         * &lt;code&gt;SENTENCE&lt;/code&gt;, &lt;code&gt;LINE&lt;/code&gt; or
<i>3675</i>&nbsp;         * &lt;code&gt;ATTRIBUTE_RUN&lt;/code&gt; to retrieve
<i>3676</i>&nbsp;         * @param index an index within the text
<i>3677</i>&nbsp;         * @return an &lt;code&gt;AccessibleTextSequence&lt;/code&gt; specifying the text
<i>3678</i>&nbsp;         * if &lt;code&gt;part&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are valid.  Otherwise,
<i>3679</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; is returned
<i>3680</i>&nbsp;         *
<i>3681</i>&nbsp;         * @see javax.accessibility.AccessibleText#CHARACTER
<i>3682</i>&nbsp;         * @see javax.accessibility.AccessibleText#WORD
<i>3683</i>&nbsp;         * @see javax.accessibility.AccessibleText#SENTENCE
<i>3684</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#LINE
<i>3685</i>&nbsp;         * @see javax.accessibility.AccessibleExtendedText#ATTRIBUTE_RUN
<b class="nc"><i>3686</i>&nbsp;         *</b>
<b class="nc"><i>3687</i>&nbsp;         * @since 1.6</b>
<i>3688</i>&nbsp;         */
<b class="nc"><i>3689</i>&nbsp;        public AccessibleTextSequence getTextSequenceBefore(int part, int index) {</b>
<i>3690</i>&nbsp;            return getSequenceAtIndex(part, index, -1);
<b class="nc"><i>3691</i>&nbsp;        }</b>
<b class="nc"><i>3692</i>&nbsp;</b>
<b class="nc"><i>3693</i>&nbsp;        /**</b>
<i>3694</i>&nbsp;         * Returns the &lt;code&gt;Rectangle&lt;/code&gt; enclosing the text between
<b class="nc"><i>3695</i>&nbsp;         * two indicies.</b>
<b class="nc"><i>3696</i>&nbsp;         *</b>
<b class="nc"><i>3697</i>&nbsp;         * @param startIndex the start index in the text</b>
<b class="nc"><i>3698</i>&nbsp;         * @param endIndex the end index in the text</b>
<i>3699</i>&nbsp;         * @return the bounding rectangle of the text if the indices are valid.
<b class="nc"><i>3700</i>&nbsp;         * Otherwise, &lt;code&gt;null&lt;/code&gt; is returned</b>
<b class="nc"><i>3701</i>&nbsp;         *</b>
<i>3702</i>&nbsp;         * @since 1.6
<i>3703</i>&nbsp;         */
<b class="nc"><i>3704</i>&nbsp;        public Rectangle getTextBounds(int startIndex, int endIndex) {</b>
<b class="nc"><i>3705</i>&nbsp;            if (startIndex &lt; 0 || startIndex &gt; model.getLength()-1 ||</b>
<b class="nc"><i>3706</i>&nbsp;                endIndex &lt; 0 || endIndex &gt; model.getLength()-1 ||</b>
<i>3707</i>&nbsp;                startIndex &gt; endIndex) {
<i>3708</i>&nbsp;                return null;
<i>3709</i>&nbsp;            }
<b class="nc"><i>3710</i>&nbsp;            TextUI ui = getUI();</b>
<b class="nc"><i>3711</i>&nbsp;            if (ui == null) {</b>
<i>3712</i>&nbsp;                return null;
<i>3713</i>&nbsp;            }
<b class="nc"><i>3714</i>&nbsp;            Rectangle rect = null;</b>
<i>3715</i>&nbsp;            Rectangle alloc = getRootEditorRect();
<b class="nc"><i>3716</i>&nbsp;            if (alloc == null) {</b>
<b class="nc"><i>3717</i>&nbsp;                return null;</b>
<i>3718</i>&nbsp;            }
<i>3719</i>&nbsp;            if (model instanceof AbstractDocument) {
<b class="nc"><i>3720</i>&nbsp;                ((AbstractDocument)model).readLock();</b>
<i>3721</i>&nbsp;            }
<i>3722</i>&nbsp;            try {
<i>3723</i>&nbsp;                View rootView = ui.getRootView(JTextComponent.this);
<i>3724</i>&nbsp;                if (rootView != null) {
<i>3725</i>&nbsp;                    Shape bounds = rootView.modelToView(startIndex,
<i>3726</i>&nbsp;                                    Position.Bias.Forward, endIndex,
<i>3727</i>&nbsp;                                    Position.Bias.Backward, alloc);
<i>3728</i>&nbsp;
<b class="nc"><i>3729</i>&nbsp;                    rect = (bounds instanceof Rectangle) ?</b>
<i>3730</i>&nbsp;                     (Rectangle)bounds : bounds.getBounds();
<i>3731</i>&nbsp;
<i>3732</i>&nbsp;                }
<i>3733</i>&nbsp;            } catch (BadLocationException e) {
<i>3734</i>&nbsp;            } finally {
<i>3735</i>&nbsp;                if (model instanceof AbstractDocument) {
<i>3736</i>&nbsp;                    ((AbstractDocument)model).readUnlock();
<i>3737</i>&nbsp;                }
<i>3738</i>&nbsp;            }
<i>3739</i>&nbsp;            return rect;
<i>3740</i>&nbsp;        }
<b class="nc"><i>3741</i>&nbsp;</b>
<b class="nc"><i>3742</i>&nbsp;        // ----- end AccessibleExtendedText methods</b>
<i>3743</i>&nbsp;
<i>3744</i>&nbsp;
<i>3745</i>&nbsp;        // --- interface AccessibleAction methods ------------------------
<i>3746</i>&nbsp;
<i>3747</i>&nbsp;        public AccessibleAction getAccessibleAction() {
<i>3748</i>&nbsp;            return this;
<i>3749</i>&nbsp;        }
<i>3750</i>&nbsp;
<i>3751</i>&nbsp;        /**
<i>3752</i>&nbsp;         * Returns the number of accessible actions available in this object
<i>3753</i>&nbsp;         * If there are more than one, the first one is considered the
<b class="nc"><i>3754</i>&nbsp;         * &quot;default&quot; action of the object.</b>
<b class="nc"><i>3755</i>&nbsp;         *</b>
<b class="nc"><i>3756</i>&nbsp;         * @return the zero-based number of Actions in this object</b>
<i>3757</i>&nbsp;         * @since 1.4
<b class="nc"><i>3758</i>&nbsp;         */</b>
<i>3759</i>&nbsp;        public int getAccessibleActionCount() {
<i>3760</i>&nbsp;            Action [] actions = JTextComponent.this.getActions();
<i>3761</i>&nbsp;            return actions.length;
<i>3762</i>&nbsp;        }
<i>3763</i>&nbsp;
<i>3764</i>&nbsp;        /**
<i>3765</i>&nbsp;         * Returns a description of the specified action of the object.
<i>3766</i>&nbsp;         *
<i>3767</i>&nbsp;         * @param i zero-based index of the actions
<i>3768</i>&nbsp;         * @return a String description of the action
<i>3769</i>&nbsp;         * @see #getAccessibleActionCount
<b class="nc"><i>3770</i>&nbsp;         * @since 1.4</b>
<b class="nc"><i>3771</i>&nbsp;         */</b>
<b class="nc"><i>3772</i>&nbsp;        public String getAccessibleActionDescription(int i) {</b>
<i>3773</i>&nbsp;            Action [] actions = JTextComponent.this.getActions();
<b class="nc"><i>3774</i>&nbsp;            if (i &lt; 0 || i &gt;= actions.length) {</b>
<i>3775</i>&nbsp;                return null;
<i>3776</i>&nbsp;            }
<b class="nc"><i>3777</i>&nbsp;            return (String)actions[i].getValue(Action.NAME);</b>
<b class="nc"><i>3778</i>&nbsp;        }</b>
<b class="nc"><i>3779</i>&nbsp;</b>
<b class="nc"><i>3780</i>&nbsp;        /**</b>
<i>3781</i>&nbsp;         * Performs the specified Action on the object
<i>3782</i>&nbsp;         *
<i>3783</i>&nbsp;         * @param i zero-based index of actions
<i>3784</i>&nbsp;         * @return true if the action was performed; otherwise false.
<i>3785</i>&nbsp;         * @see #getAccessibleActionCount
<i>3786</i>&nbsp;         * @since 1.4
<i>3787</i>&nbsp;         */
<i>3788</i>&nbsp;        public boolean doAccessibleAction(int i) {
<i>3789</i>&nbsp;            Action [] actions = JTextComponent.this.getActions();
<i>3790</i>&nbsp;            if (i &lt; 0 || i &gt;= actions.length) {
<i>3791</i>&nbsp;                return false;
<i>3792</i>&nbsp;            }
<i>3793</i>&nbsp;            ActionEvent ae =
<b class="nc"><i>3794</i>&nbsp;                new ActionEvent(JTextComponent.this,</b>
<b class="nc"><i>3795</i>&nbsp;                                ActionEvent.ACTION_PERFORMED, null,</b>
<b class="nc"><i>3796</i>&nbsp;                                EventQueue.getMostRecentEventTime(),</b>
<b class="nc"><i>3797</i>&nbsp;                                getCurrentEventModifiers());</b>
<i>3798</i>&nbsp;            actions[i].actionPerformed(ae);
<i>3799</i>&nbsp;            return true;
<i>3800</i>&nbsp;        }
<i>3801</i>&nbsp;
<i>3802</i>&nbsp;        // ----- end AccessibleAction methods
<i>3803</i>&nbsp;
<i>3804</i>&nbsp;
<i>3805</i>&nbsp;    }
<i>3806</i>&nbsp;
<i>3807</i>&nbsp;
<i>3808</i>&nbsp;    // --- serialization ---------------------------------------------
<i>3809</i>&nbsp;
<i>3810</i>&nbsp;    private void readObject(ObjectInputStream s)
<i>3811</i>&nbsp;        throws IOException, ClassNotFoundException
<i>3812</i>&nbsp;    {
<i>3813</i>&nbsp;        ObjectInputStream.GetField f = s.readFields();
<i>3814</i>&nbsp;
<i>3815</i>&nbsp;        model = (Document) f.get(&quot;model&quot;, null);
<i>3816</i>&nbsp;        navigationFilter = (NavigationFilter) f.get(&quot;navigationFilter&quot;, null);
<i>3817</i>&nbsp;        caretColor = (Color) f.get(&quot;caretColor&quot;, null);
<i>3818</i>&nbsp;        selectionColor = (Color) f.get(&quot;selectionColor&quot;, null);
<i>3819</i>&nbsp;        selectedTextColor = (Color) f.get(&quot;selectedTextColor&quot;, null);
<i>3820</i>&nbsp;        disabledTextColor = (Color) f.get(&quot;disabledTextColor&quot;, null);
<i>3821</i>&nbsp;        editable = f.get(&quot;editable&quot;, false);
<i>3822</i>&nbsp;        margin = (Insets) f.get(&quot;margin&quot;, null);
<i>3823</i>&nbsp;        focusAccelerator = f.get(&quot;focusAccelerator&quot;, &#39;\0&#39;);
<i>3824</i>&nbsp;        boolean newDragEnabled = f.get(&quot;dragEnabled&quot;, false);
<i>3825</i>&nbsp;        checkDragEnabled(newDragEnabled);
<i>3826</i>&nbsp;        dragEnabled = newDragEnabled;
<i>3827</i>&nbsp;        DropMode newDropMode = (DropMode) f.get(&quot;dropMode&quot;,
<i>3828</i>&nbsp;                DropMode.USE_SELECTION);
<i>3829</i>&nbsp;        checkDropMode(newDropMode);
<i>3830</i>&nbsp;        dropMode = newDropMode;
<i>3831</i>&nbsp;        composedTextAttribute = (SimpleAttributeSet) f.get(&quot;composedTextAttribute&quot;, null);
<i>3832</i>&nbsp;        composedTextContent = (String) f.get(&quot;composedTextContent&quot;, null);
<i>3833</i>&nbsp;        composedTextStart = (Position) f.get(&quot;composedTextStart&quot;, null);
<i>3834</i>&nbsp;        composedTextEnd = (Position) f.get(&quot;composedTextEnd&quot;, null);
<i>3835</i>&nbsp;        latestCommittedTextStart = (Position) f.get(&quot;latestCommittedTextStart&quot;, null);
<i>3836</i>&nbsp;        latestCommittedTextEnd = (Position) f.get(&quot;latestCommittedTextEnd&quot;, null);
<i>3837</i>&nbsp;        composedTextCaret = (ComposedTextCaret) f.get(&quot;composedTextCaret&quot;, null);
<i>3838</i>&nbsp;        checkedInputOverride = f.get(&quot;checkedInputOverride&quot;, false);
<i>3839</i>&nbsp;        needToSendKeyTypedEvent = f.get(&quot;needToSendKeyTypedEvent&quot;, false);
<i>3840</i>&nbsp;
<i>3841</i>&nbsp;        caretEvent = new MutableCaretEvent(this);
<i>3842</i>&nbsp;        addMouseListener(caretEvent);
<i>3843</i>&nbsp;        addFocusListener(caretEvent);
<i>3844</i>&nbsp;    }
<i>3845</i>&nbsp;
<i>3846</i>&nbsp;    // --- member variables ----------------------------------
<i>3847</i>&nbsp;
<i>3848</i>&nbsp;    /**
<i>3849</i>&nbsp;     * The document model.
<i>3850</i>&nbsp;     */
<i>3851</i>&nbsp;    private Document model;
<i>3852</i>&nbsp;
<b class="nc"><i>3853</i>&nbsp;    /**</b>
<i>3854</i>&nbsp;     * The caret used to display the insert position
<i>3855</i>&nbsp;     * and navigate throughout the document.
<i>3856</i>&nbsp;     *
<i>3857</i>&nbsp;     * PENDING(prinz)
<i>3858</i>&nbsp;     * This should be serializable, default installed
<i>3859</i>&nbsp;     * by UI.
<i>3860</i>&nbsp;     */
<i>3861</i>&nbsp;    private transient Caret caret;
<i>3862</i>&nbsp;
<i>3863</i>&nbsp;    /**
<i>3864</i>&nbsp;     * Object responsible for restricting the cursor navigation.
<i>3865</i>&nbsp;     */
<b class="nc"><i>3866</i>&nbsp;    private NavigationFilter navigationFilter;</b>
<i>3867</i>&nbsp;
<i>3868</i>&nbsp;    /**
<i>3869</i>&nbsp;     * The object responsible for managing highlights.
<i>3870</i>&nbsp;     *
<b class="nc"><i>3871</i>&nbsp;     * PENDING(prinz)</b>
<b class="nc"><i>3872</i>&nbsp;     * This should be serializable, default installed</b>
<b class="nc"><i>3873</i>&nbsp;     * by UI.</b>
<i>3874</i>&nbsp;     */
<i>3875</i>&nbsp;    private transient Highlighter highlighter;
<i>3876</i>&nbsp;
<i>3877</i>&nbsp;    /**
<i>3878</i>&nbsp;     * The current key bindings in effect.
<i>3879</i>&nbsp;     *
<i>3880</i>&nbsp;     * PENDING(prinz)
<i>3881</i>&nbsp;     * This should be serializable, default installed
<i>3882</i>&nbsp;     * by UI.
<i>3883</i>&nbsp;     */
<b class="nc"><i>3884</i>&nbsp;    private transient Keymap keymap;</b>
<i>3885</i>&nbsp;
<i>3886</i>&nbsp;    private transient MutableCaretEvent caretEvent;
<i>3887</i>&nbsp;    private Color caretColor;
<i>3888</i>&nbsp;    private Color selectionColor;
<i>3889</i>&nbsp;    private Color selectedTextColor;
<i>3890</i>&nbsp;    private Color disabledTextColor;
<i>3891</i>&nbsp;    private boolean editable;
<i>3892</i>&nbsp;    private Insets margin;
<b class="nc"><i>3893</i>&nbsp;    private char focusAccelerator;</b>
<i>3894</i>&nbsp;    private boolean dragEnabled;
<i>3895</i>&nbsp;
<i>3896</i>&nbsp;    /**
<i>3897</i>&nbsp;     * The drop mode for this component.
<i>3898</i>&nbsp;     */
<i>3899</i>&nbsp;    private DropMode dropMode = DropMode.USE_SELECTION;
<i>3900</i>&nbsp;
<i>3901</i>&nbsp;    /**
<i>3902</i>&nbsp;     * The drop location.
<i>3903</i>&nbsp;     */
<i>3904</i>&nbsp;    private transient DropLocation dropLocation;
<b class="nc"><i>3905</i>&nbsp;</b>
<b class="nc"><i>3906</i>&nbsp;    /**</b>
<i>3907</i>&nbsp;     * Represents a drop location for &lt;code&gt;JTextComponent&lt;/code&gt;s.
<i>3908</i>&nbsp;     *
<i>3909</i>&nbsp;     * @see #getDropLocation
<i>3910</i>&nbsp;     * @since 1.6
<i>3911</i>&nbsp;     */
<i>3912</i>&nbsp;    public static final class DropLocation extends TransferHandler.DropLocation {
<i>3913</i>&nbsp;        private final int index;
<i>3914</i>&nbsp;        private final Position.Bias bias;
<i>3915</i>&nbsp;
<i>3916</i>&nbsp;        private DropLocation(Point p, int index, Position.Bias bias) {
<i>3917</i>&nbsp;            super(p);
<i>3918</i>&nbsp;            this.index = index;
<i>3919</i>&nbsp;            this.bias = bias;
<i>3920</i>&nbsp;        }
<b class="nc"><i>3921</i>&nbsp;</b>
<b class="nc"><i>3922</i>&nbsp;        /**</b>
<i>3923</i>&nbsp;         * Returns the index where dropped data should be inserted into the
<i>3924</i>&nbsp;         * associated component. This index represents a position between
<i>3925</i>&nbsp;         * characters, as would be interpreted by a caret.
<i>3926</i>&nbsp;         *
<i>3927</i>&nbsp;         * @return the drop index
<i>3928</i>&nbsp;         */
<b class="nc"><i>3929</i>&nbsp;        public int getIndex() {</b>
<b class="nc"><i>3930</i>&nbsp;            return index;</b>
<i>3931</i>&nbsp;        }
<b class="nc"><i>3932</i>&nbsp;</b>
<b class="nc"><i>3933</i>&nbsp;        /**</b>
<i>3934</i>&nbsp;         * Returns the bias for the drop index.
<b class="nc"><i>3935</i>&nbsp;         *</b>
<b class="nc"><i>3936</i>&nbsp;         * @return the drop bias</b>
<i>3937</i>&nbsp;         */
<i>3938</i>&nbsp;        public Position.Bias getBias() {
<b class="nc"><i>3939</i>&nbsp;            return bias;</b>
<b class="nc"><i>3940</i>&nbsp;        }</b>
<b class="nc"><i>3941</i>&nbsp;</b>
<b class="nc"><i>3942</i>&nbsp;        /**</b>
<i>3943</i>&nbsp;         * Returns a string representation of this drop location.
<i>3944</i>&nbsp;         * This method is intended to be used for debugging purposes,
<i>3945</i>&nbsp;         * and the content and format of the returned string may vary
<i>3946</i>&nbsp;         * between implementations.
<i>3947</i>&nbsp;         *
<i>3948</i>&nbsp;         * @return a string representation of this drop location
<i>3949</i>&nbsp;         */
<i>3950</i>&nbsp;        public String toString() {
<i>3951</i>&nbsp;            return getClass().getName()
<i>3952</i>&nbsp;                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;
<i>3953</i>&nbsp;                   + &quot;index=&quot; + index + &quot;,&quot;
<i>3954</i>&nbsp;                   + &quot;bias=&quot; + bias + &quot;]&quot;;
<i>3955</i>&nbsp;        }
<i>3956</i>&nbsp;    }
<i>3957</i>&nbsp;
<i>3958</i>&nbsp;    /**
<i>3959</i>&nbsp;     * TransferHandler used if one hasn&#39;t been supplied by the UI.
<i>3960</i>&nbsp;     */
<i>3961</i>&nbsp;    private static DefaultTransferHandler defaultTransferHandler;
<b class="nc"><i>3962</i>&nbsp;</b>
<i>3963</i>&nbsp;    /**
<b class="nc"><i>3964</i>&nbsp;     * Maps from class name to Boolean indicating if</b>
<b class="nc"><i>3965</i>&nbsp;     * &lt;code&gt;processInputMethodEvent&lt;/code&gt; has been overriden.</b>
<b class="nc"><i>3966</i>&nbsp;     */</b>
<b class="nc"><i>3967</i>&nbsp;    private static Cache&lt;Class&lt;?&gt;,Boolean&gt; METHOD_OVERRIDDEN</b>
<b class="nc"><i>3968</i>&nbsp;            = new Cache&lt;Class&lt;?&gt;,Boolean&gt;(Cache.Kind.WEAK, Cache.Kind.STRONG) {</b>
<b class="nc"><i>3969</i>&nbsp;        /**</b>
<b class="nc"><i>3970</i>&nbsp;         * Returns {@code true} if the specified {@code type} extends {@link JTextComponent}</b>
<b class="nc"><i>3971</i>&nbsp;         * and the {@link JTextComponent#processInputMethodEvent} method is overridden.</b>
<b class="nc"><i>3972</i>&nbsp;         */</b>
<b class="nc"><i>3973</i>&nbsp;        @Override</b>
<i>3974</i>&nbsp;        public Boolean create(final Class&lt;?&gt; type) {
<b class="nc"><i>3975</i>&nbsp;            if (JTextComponent.class == type) {</b>
<i>3976</i>&nbsp;                return Boolean.FALSE;
<i>3977</i>&nbsp;            }
<i>3978</i>&nbsp;            if (get(type.getSuperclass())) {
<i>3979</i>&nbsp;                return Boolean.TRUE;
<i>3980</i>&nbsp;            }
<i>3981</i>&nbsp;            return AccessController.doPrivileged(
<i>3982</i>&nbsp;                    new PrivilegedAction&lt;Boolean&gt;() {
<i>3983</i>&nbsp;                        public Boolean run() {
<i>3984</i>&nbsp;                            try {
<i>3985</i>&nbsp;                                type.getDeclaredMethod(&quot;processInputMethodEvent&quot;, InputMethodEvent.class);
<i>3986</i>&nbsp;                                return Boolean.TRUE;
<i>3987</i>&nbsp;                            } catch (NoSuchMethodException exception) {
<i>3988</i>&nbsp;                                return Boolean.FALSE;
<i>3989</i>&nbsp;                            }
<i>3990</i>&nbsp;                        }
<b class="nc"><i>3991</i>&nbsp;                    });</b>
<i>3992</i>&nbsp;        }
<i>3993</i>&nbsp;    };
<i>3994</i>&nbsp;
<b class="nc"><i>3995</i>&nbsp;    /**</b>
<b class="nc"><i>3996</i>&nbsp;     * Returns a string representation of this &lt;code&gt;JTextComponent&lt;/code&gt;.</b>
<b class="nc"><i>3997</i>&nbsp;     * This method is intended to be used only for debugging purposes, and the</b>
<b class="nc"><i>3998</i>&nbsp;     * content and format of the returned string may vary between</b>
<b class="nc"><i>3999</i>&nbsp;     * implementations. The returned string may be empty but may not</b>
<i>4000</i>&nbsp;     * be &lt;code&gt;null&lt;/code&gt;.
<b class="nc"><i>4001</i>&nbsp;     * &lt;P&gt;</b>
<b class="nc"><i>4002</i>&nbsp;     * Overriding &lt;code&gt;paramString&lt;/code&gt; to provide information about the</b>
<b class="nc"><i>4003</i>&nbsp;     * specific new aspects of the JFC components.</b>
<i>4004</i>&nbsp;     *
<i>4005</i>&nbsp;     * @return  a string representation of this &lt;code&gt;JTextComponent&lt;/code&gt;
<i>4006</i>&nbsp;     */
<i>4007</i>&nbsp;    protected String paramString() {
<b class="nc"><i>4008</i>&nbsp;        String editableString = (editable ?</b>
<i>4009</i>&nbsp;                                 &quot;true&quot; : &quot;false&quot;);
<b class="nc"><i>4010</i>&nbsp;        String caretColorString = (caretColor != null ?</b>
<b class="nc"><i>4011</i>&nbsp;                                   caretColor.toString() : &quot;&quot;);</b>
<i>4012</i>&nbsp;        String selectionColorString = (selectionColor != null ?
<b class="nc"><i>4013</i>&nbsp;                                       selectionColor.toString() : &quot;&quot;);</b>
<i>4014</i>&nbsp;        String selectedTextColorString = (selectedTextColor != null ?
<i>4015</i>&nbsp;                                          selectedTextColor.toString() : &quot;&quot;);
<i>4016</i>&nbsp;        String disabledTextColorString = (disabledTextColor != null ?
<i>4017</i>&nbsp;                                          disabledTextColor.toString() : &quot;&quot;);
<b class="nc"><i>4018</i>&nbsp;        String marginString = (margin != null ?</b>
<b class="nc"><i>4019</i>&nbsp;                               margin.toString() : &quot;&quot;);</b>
<i>4020</i>&nbsp;
<b class="nc"><i>4021</i>&nbsp;        return super.paramString() +</b>
<b class="nc"><i>4022</i>&nbsp;        &quot;,caretColor=&quot; + caretColorString +</b>
<b class="nc"><i>4023</i>&nbsp;        &quot;,disabledTextColor=&quot; + disabledTextColorString +</b>
<b class="nc"><i>4024</i>&nbsp;        &quot;,editable=&quot; + editableString +</b>
<i>4025</i>&nbsp;        &quot;,margin=&quot; + marginString +
<i>4026</i>&nbsp;        &quot;,selectedTextColor=&quot; + selectedTextColorString +
<b class="nc"><i>4027</i>&nbsp;        &quot;,selectionColor=&quot; + selectionColorString;</b>
<i>4028</i>&nbsp;    }
<b class="nc"><i>4029</i>&nbsp;</b>
<b class="nc"><i>4030</i>&nbsp;</b>
<b class="nc"><i>4031</i>&nbsp;    /**</b>
<b class="nc"><i>4032</i>&nbsp;     * A Simple TransferHandler that exports the data as a String, and</b>
<b class="nc"><i>4033</i>&nbsp;     * imports the data from the String clipboard.  This is only used</b>
<i>4034</i>&nbsp;     * if the UI hasn&#39;t supplied one, which would only happen if someone
<i>4035</i>&nbsp;     * hasn&#39;t subclassed Basic.
<b class="nc"><i>4036</i>&nbsp;     */</b>
<i>4037</i>&nbsp;    static class DefaultTransferHandler extends TransferHandler implements
<i>4038</i>&nbsp;                                        UIResource {
<i>4039</i>&nbsp;        public void exportToClipboard(JComponent comp, Clipboard clipboard,
<b class="nc"><i>4040</i>&nbsp;                                      int action) throws IllegalStateException {</b>
<b class="nc"><i>4041</i>&nbsp;            if (comp instanceof JTextComponent) {</b>
<b class="nc"><i>4042</i>&nbsp;                JTextComponent text = (JTextComponent)comp;</b>
<i>4043</i>&nbsp;                int p0 = text.getSelectionStart();
<b class="nc"><i>4044</i>&nbsp;                int p1 = text.getSelectionEnd();</b>
<i>4045</i>&nbsp;                if (p0 != p1) {
<i>4046</i>&nbsp;                    try {
<b class="nc"><i>4047</i>&nbsp;                        Document doc = text.getDocument();</b>
<i>4048</i>&nbsp;                        String srcData = doc.getText(p0, p1 - p0);
<i>4049</i>&nbsp;                        StringSelection contents =new StringSelection(srcData);
<b class="nc"><i>4050</i>&nbsp;</b>
<b class="nc"><i>4051</i>&nbsp;                        // this may throw an IllegalStateException,</b>
<b class="nc"><i>4052</i>&nbsp;                        // but it will be caught and handled in the</b>
<b class="nc"><i>4053</i>&nbsp;                        // action that invoked this method</b>
<i>4054</i>&nbsp;                        clipboard.setContents(contents, null);
<i>4055</i>&nbsp;
<i>4056</i>&nbsp;                        if (action == TransferHandler.MOVE) {
<b class="nc"><i>4057</i>&nbsp;                            doc.remove(p0, p1 - p0);</b>
<i>4058</i>&nbsp;                        }
<i>4059</i>&nbsp;                    } catch (BadLocationException ble) {}
<i>4060</i>&nbsp;                }
<i>4061</i>&nbsp;            }
<i>4062</i>&nbsp;        }
<i>4063</i>&nbsp;        public boolean importData(JComponent comp, Transferable t) {
<i>4064</i>&nbsp;            if (comp instanceof JTextComponent) {
<i>4065</i>&nbsp;                DataFlavor flavor = getFlavor(t.getTransferDataFlavors());
<b class="nc"><i>4066</i>&nbsp;</b>
<b class="nc"><i>4067</i>&nbsp;                if (flavor != null) {</b>
<i>4068</i>&nbsp;                    InputContext ic = comp.getInputContext();
<i>4069</i>&nbsp;                    if (ic != null) {
<i>4070</i>&nbsp;                        ic.endComposition();
<b class="nc"><i>4071</i>&nbsp;                    }</b>
<b class="nc"><i>4072</i>&nbsp;                    try {</b>
<b class="nc"><i>4073</i>&nbsp;                        String data = (String)t.getTransferData(flavor);</b>
<b class="nc"><i>4074</i>&nbsp;</b>
<b class="nc"><i>4075</i>&nbsp;                        ((JTextComponent)comp).replaceSelection(data);</b>
<b class="nc"><i>4076</i>&nbsp;                        return true;</b>
<i>4077</i>&nbsp;                    } catch (UnsupportedFlavorException ufe) {
<b class="nc"><i>4078</i>&nbsp;                    } catch (IOException ioe) {</b>
<i>4079</i>&nbsp;                    }
<i>4080</i>&nbsp;                }
<b class="nc"><i>4081</i>&nbsp;            }</b>
<i>4082</i>&nbsp;            return false;
<i>4083</i>&nbsp;        }
<i>4084</i>&nbsp;        public boolean canImport(JComponent comp,
<i>4085</i>&nbsp;                                 DataFlavor[] transferFlavors) {
<i>4086</i>&nbsp;            JTextComponent c = (JTextComponent)comp;
<i>4087</i>&nbsp;            if (!(c.isEditable() &amp;&amp; c.isEnabled())) {
<i>4088</i>&nbsp;                return false;
<i>4089</i>&nbsp;            }
<i>4090</i>&nbsp;            return (getFlavor(transferFlavors) != null);
<i>4091</i>&nbsp;        }
<i>4092</i>&nbsp;        public int getSourceActions(JComponent c) {
<i>4093</i>&nbsp;            return NONE;
<i>4094</i>&nbsp;        }
<i>4095</i>&nbsp;        private DataFlavor getFlavor(DataFlavor[] flavors) {
<i>4096</i>&nbsp;            if (flavors != null) {
<i>4097</i>&nbsp;                for (DataFlavor flavor : flavors) {
<i>4098</i>&nbsp;                    if (flavor.equals(DataFlavor.stringFlavor)) {
<i>4099</i>&nbsp;                        return flavor;
<i>4100</i>&nbsp;                    }
<i>4101</i>&nbsp;                }
<i>4102</i>&nbsp;            }
<i>4103</i>&nbsp;            return null;
<i>4104</i>&nbsp;        }
<i>4105</i>&nbsp;    }
<b class="nc"><i>4106</i>&nbsp;</b>
<b class="nc"><i>4107</i>&nbsp;    /**</b>
<b class="nc"><i>4108</i>&nbsp;     * Returns the JTextComponent that most recently had focus. The returned</b>
<b class="nc"><i>4109</i>&nbsp;     * value may currently have focus.</b>
<i>4110</i>&nbsp;     */
<i>4111</i>&nbsp;    static final JTextComponent getFocusedComponent() {
<i>4112</i>&nbsp;        return (JTextComponent)AppContext.getAppContext().
<i>4113</i>&nbsp;            get(FOCUSED_COMPONENT);
<i>4114</i>&nbsp;    }
<i>4115</i>&nbsp;
<i>4116</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<i>4117</i>&nbsp;    private int getCurrentEventModifiers() {
<i>4118</i>&nbsp;        int modifiers = 0;
<i>4119</i>&nbsp;        AWTEvent currentEvent = EventQueue.getCurrentEvent();
<i>4120</i>&nbsp;        if (currentEvent instanceof InputEvent) {
<b class="nc"><i>4121</i>&nbsp;            modifiers = ((InputEvent)currentEvent).getModifiers();</b>
<b class="nc"><i>4122</i>&nbsp;        } else if (currentEvent instanceof ActionEvent) {</b>
<i>4123</i>&nbsp;            modifiers = ((ActionEvent)currentEvent).getModifiers();
<b class="nc"><i>4124</i>&nbsp;        }</b>
<i>4125</i>&nbsp;        return modifiers;
<i>4126</i>&nbsp;    }
<i>4127</i>&nbsp;
<i>4128</i>&nbsp;    private static final Object KEYMAP_TABLE =
<i>4129</i>&nbsp;        new StringBuilder(&quot;JTextComponent_KeymapTable&quot;);
<i>4130</i>&nbsp;
<b class="nc"><i>4131</i>&nbsp;    //</b>
<i>4132</i>&nbsp;    // member variables used for on-the-spot input method
<i>4133</i>&nbsp;    // editing style support
<i>4134</i>&nbsp;    //
<b class="nc"><i>4135</i>&nbsp;    private transient InputMethodRequests inputMethodRequestsHandler;</b>
<i>4136</i>&nbsp;    private SimpleAttributeSet composedTextAttribute;
<i>4137</i>&nbsp;    private String composedTextContent;
<i>4138</i>&nbsp;    private Position composedTextStart;
<b class="nc"><i>4139</i>&nbsp;    private Position composedTextEnd;</b>
<b class="nc"><i>4140</i>&nbsp;    private Position latestCommittedTextStart;</b>
<b class="nc"><i>4141</i>&nbsp;    private Position latestCommittedTextEnd;</b>
<i>4142</i>&nbsp;    private ComposedTextCaret composedTextCaret;
<b class="nc"><i>4143</i>&nbsp;    private transient Caret originalCaret;</b>
<i>4144</i>&nbsp;    /**
<i>4145</i>&nbsp;     * Set to true after the check for the override of processInputMethodEvent
<i>4146</i>&nbsp;     * has been checked.
<b class="nc"><i>4147</i>&nbsp;     */</b>
<b class="nc"><i>4148</i>&nbsp;    private boolean checkedInputOverride;</b>
<b class="nc"><i>4149</i>&nbsp;    private boolean needToSendKeyTypedEvent;</b>
<b class="nc"><i>4150</i>&nbsp;</b>
<i>4151</i>&nbsp;    static class DefaultKeymap implements Keymap {
<b class="nc"><i>4152</i>&nbsp;</b>
<i>4153</i>&nbsp;        DefaultKeymap(String nm, Keymap parent) {
<i>4154</i>&nbsp;            this.nm = nm;
<i>4155</i>&nbsp;            this.parent = parent;
<b class="nc"><i>4156</i>&nbsp;            bindings = new Hashtable&lt;KeyStroke, Action&gt;();</b>
<b class="nc"><i>4157</i>&nbsp;        }</b>
<b class="nc"><i>4158</i>&nbsp;</b>
<b class="nc"><i>4159</i>&nbsp;        /**</b>
<i>4160</i>&nbsp;         * Fetch the default action to fire if a
<b class="nc"><i>4161</i>&nbsp;         * key is typed (ie a KEY_TYPED KeyEvent is received)</b>
<i>4162</i>&nbsp;         * and there is no binding for it.  Typically this
<i>4163</i>&nbsp;         * would be some action that inserts text so that
<i>4164</i>&nbsp;         * the keymap doesn&#39;t require an action for each
<b class="nc"><i>4165</i>&nbsp;         * possible key.</b>
<b class="nc"><i>4166</i>&nbsp;         */</b>
<i>4167</i>&nbsp;        public Action getDefaultAction() {
<b class="nc"><i>4168</i>&nbsp;            if (defaultAction != null) {</b>
<i>4169</i>&nbsp;                return defaultAction;
<b class="nc"><i>4170</i>&nbsp;            }</b>
<b class="nc"><i>4171</i>&nbsp;            return (parent != null) ? parent.getDefaultAction() : null;</b>
<b class="nc"><i>4172</i>&nbsp;        }</b>
<b class="nc"><i>4173</i>&nbsp;</b>
<b class="nc"><i>4174</i>&nbsp;        /**</b>
<b class="nc"><i>4175</i>&nbsp;         * Set the default action to fire if a key is typed.</b>
<i>4176</i>&nbsp;         */
<b class="nc"><i>4177</i>&nbsp;        public void setDefaultAction(Action a) {</b>
<i>4178</i>&nbsp;            defaultAction = a;
<b class="nc"><i>4179</i>&nbsp;        }</b>
<i>4180</i>&nbsp;
<b class="nc"><i>4181</i>&nbsp;        public String getName() {</b>
<b class="nc"><i>4182</i>&nbsp;            return nm;</b>
<b class="nc"><i>4183</i>&nbsp;        }</b>
<i>4184</i>&nbsp;
<i>4185</i>&nbsp;        public Action getAction(KeyStroke key) {
<b class="nc"><i>4186</i>&nbsp;            Action a = bindings.get(key);</b>
<b class="nc"><i>4187</i>&nbsp;            if ((a == null) &amp;&amp; (parent != null)) {</b>
<b class="nc"><i>4188</i>&nbsp;                a = parent.getAction(key);</b>
<b class="nc"><i>4189</i>&nbsp;            }</b>
<b class="nc"><i>4190</i>&nbsp;            return a;</b>
<b class="nc"><i>4191</i>&nbsp;        }</b>
<i>4192</i>&nbsp;
<i>4193</i>&nbsp;        public KeyStroke[] getBoundKeyStrokes() {
<b class="nc"><i>4194</i>&nbsp;            KeyStroke[] keys = new KeyStroke[bindings.size()];</b>
<b class="nc"><i>4195</i>&nbsp;            int i = 0;</b>
<b class="nc"><i>4196</i>&nbsp;            for (Enumeration&lt;KeyStroke&gt; e = bindings.keys() ; e.hasMoreElements() ;) {</b>
<i>4197</i>&nbsp;                keys[i++] = e.nextElement();
<b class="nc"><i>4198</i>&nbsp;            }</b>
<b class="nc"><i>4199</i>&nbsp;            return keys;</b>
<b class="nc"><i>4200</i>&nbsp;        }</b>
<b class="nc"><i>4201</i>&nbsp;</b>
<i>4202</i>&nbsp;        public Action[] getBoundActions() {
<i>4203</i>&nbsp;            Action[] actions = new Action[bindings.size()];
<i>4204</i>&nbsp;            int i = 0;
<b class="nc"><i>4205</i>&nbsp;            for (Enumeration&lt;Action&gt; e = bindings.elements() ; e.hasMoreElements() ;) {</b>
<b class="nc"><i>4206</i>&nbsp;                actions[i++] = e.nextElement();</b>
<b class="nc"><i>4207</i>&nbsp;            }</b>
<i>4208</i>&nbsp;            return actions;
<i>4209</i>&nbsp;        }
<b class="nc"><i>4210</i>&nbsp;</b>
<i>4211</i>&nbsp;        public KeyStroke[] getKeyStrokesForAction(Action a) {
<b class="nc"><i>4212</i>&nbsp;            if (a == null) {</b>
<b class="nc"><i>4213</i>&nbsp;                return null;</b>
<b class="nc"><i>4214</i>&nbsp;            }</b>
<b class="nc"><i>4215</i>&nbsp;            KeyStroke[] retValue = null;</b>
<i>4216</i>&nbsp;            // Determine local bindings first.
<i>4217</i>&nbsp;            Vector&lt;KeyStroke&gt; keyStrokes = null;
<i>4218</i>&nbsp;            for (Enumeration&lt;KeyStroke&gt; keys = bindings.keys(); keys.hasMoreElements();) {
<i>4219</i>&nbsp;                KeyStroke key = keys.nextElement();
<b class="nc"><i>4220</i>&nbsp;                if (bindings.get(key) == a) {</b>
<b class="nc"><i>4221</i>&nbsp;                    if (keyStrokes == null) {</b>
<b class="nc"><i>4222</i>&nbsp;                        keyStrokes = new Vector&lt;KeyStroke&gt;();</b>
<i>4223</i>&nbsp;                    }
<b class="nc"><i>4224</i>&nbsp;                    keyStrokes.addElement(key);</b>
<i>4225</i>&nbsp;                }
<i>4226</i>&nbsp;            }
<i>4227</i>&nbsp;            // See if the parent has any.
<b class="nc"><i>4228</i>&nbsp;            if (parent != null) {</b>
<i>4229</i>&nbsp;                KeyStroke[] pStrokes = parent.getKeyStrokesForAction(a);
<i>4230</i>&nbsp;                if (pStrokes != null) {
<i>4231</i>&nbsp;                    // Remove any bindings defined in the parent that
<b class="nc"><i>4232</i>&nbsp;                    // are locally defined.</b>
<i>4233</i>&nbsp;                    int rCount = 0;
<i>4234</i>&nbsp;                    for (int counter = pStrokes.length - 1; counter &gt;= 0;
<i>4235</i>&nbsp;                         counter--) {
<b class="nc"><i>4236</i>&nbsp;                        if (isLocallyDefined(pStrokes[counter])) {</b>
<i>4237</i>&nbsp;                            pStrokes[counter] = null;
<i>4238</i>&nbsp;                            rCount++;
<i>4239</i>&nbsp;                        }
<b class="nc"><i>4240</i>&nbsp;                    }</b>
<i>4241</i>&nbsp;                    if (rCount &gt; 0 &amp;&amp; rCount &lt; pStrokes.length) {
<i>4242</i>&nbsp;                        if (keyStrokes == null) {
<i>4243</i>&nbsp;                            keyStrokes = new Vector&lt;KeyStroke&gt;();
<b class="nc"><i>4244</i>&nbsp;                        }</b>
<i>4245</i>&nbsp;                        for (int counter = pStrokes.length - 1; counter &gt;= 0;
<i>4246</i>&nbsp;                             counter--) {
<i>4247</i>&nbsp;                            if (pStrokes[counter] != null) {
<b class="nc"><i>4248</i>&nbsp;                                keyStrokes.addElement(pStrokes[counter]);</b>
<i>4249</i>&nbsp;                            }
<i>4250</i>&nbsp;                        }
<i>4251</i>&nbsp;                    }
<i>4252</i>&nbsp;                    else if (rCount == 0) {
<i>4253</i>&nbsp;                        if (keyStrokes == null) {
<i>4254</i>&nbsp;                            retValue = pStrokes;
<i>4255</i>&nbsp;                        }
<b class="nc"><i>4256</i>&nbsp;                        else {</b>
<i>4257</i>&nbsp;                            retValue = new KeyStroke[keyStrokes.size() +
<i>4258</i>&nbsp;                                                    pStrokes.length];
<i>4259</i>&nbsp;                            keyStrokes.copyInto(retValue);
<i>4260</i>&nbsp;                            System.arraycopy(pStrokes, 0, retValue,
<i>4261</i>&nbsp;                                        keyStrokes.size(), pStrokes.length);
<i>4262</i>&nbsp;                            keyStrokes = null;
<i>4263</i>&nbsp;                        }
<i>4264</i>&nbsp;                    }
<i>4265</i>&nbsp;                }
<i>4266</i>&nbsp;            }
<i>4267</i>&nbsp;            if (keyStrokes != null) {
<i>4268</i>&nbsp;                retValue = new KeyStroke[keyStrokes.size()];
<i>4269</i>&nbsp;                keyStrokes.copyInto(retValue);
<i>4270</i>&nbsp;            }
<i>4271</i>&nbsp;            return retValue;
<i>4272</i>&nbsp;        }
<i>4273</i>&nbsp;
<i>4274</i>&nbsp;        public boolean isLocallyDefined(KeyStroke key) {
<i>4275</i>&nbsp;            return bindings.containsKey(key);
<i>4276</i>&nbsp;        }
<i>4277</i>&nbsp;
<i>4278</i>&nbsp;        public void addActionForKeyStroke(KeyStroke key, Action a) {
<i>4279</i>&nbsp;            bindings.put(key, a);
<i>4280</i>&nbsp;        }
<i>4281</i>&nbsp;
<b class="nc"><i>4282</i>&nbsp;        public void removeKeyStrokeBinding(KeyStroke key) {</b>
<i>4283</i>&nbsp;            bindings.remove(key);
<i>4284</i>&nbsp;        }
<i>4285</i>&nbsp;
<b class="nc"><i>4286</i>&nbsp;        public void removeBindings() {</b>
<b class="nc"><i>4287</i>&nbsp;            bindings.clear();</b>
<i>4288</i>&nbsp;        }
<i>4289</i>&nbsp;
<i>4290</i>&nbsp;        public Keymap getResolveParent() {
<b class="nc"><i>4291</i>&nbsp;            return parent;</b>
<b class="nc"><i>4292</i>&nbsp;        }</b>
<b class="nc"><i>4293</i>&nbsp;</b>
<b class="nc"><i>4294</i>&nbsp;        public void setResolveParent(Keymap parent) {</b>
<b class="nc"><i>4295</i>&nbsp;            this.parent = parent;</b>
<b class="nc"><i>4296</i>&nbsp;        }</b>
<i>4297</i>&nbsp;
<b class="nc"><i>4298</i>&nbsp;        /**</b>
<b class="nc"><i>4299</i>&nbsp;         * String representation of the keymap... potentially</b>
<i>4300</i>&nbsp;         * a very long string.
<b class="nc"><i>4301</i>&nbsp;         */</b>
<i>4302</i>&nbsp;        public String toString() {
<b class="nc"><i>4303</i>&nbsp;            return &quot;Keymap[&quot; + nm + &quot;]&quot; + bindings;</b>
<b class="nc"><i>4304</i>&nbsp;        }</b>
<b class="nc"><i>4305</i>&nbsp;</b>
<i>4306</i>&nbsp;        String nm;
<i>4307</i>&nbsp;        Keymap parent;
<i>4308</i>&nbsp;        Hashtable&lt;KeyStroke, Action&gt; bindings;
<i>4309</i>&nbsp;        Action defaultAction;
<b class="nc"><i>4310</i>&nbsp;    }</b>
<b class="nc"><i>4311</i>&nbsp;</b>
<i>4312</i>&nbsp;
<b class="nc"><i>4313</i>&nbsp;    /**</b>
<i>4314</i>&nbsp;     * KeymapWrapper wraps a Keymap inside an InputMap. For KeymapWrapper
<i>4315</i>&nbsp;     * to be useful it must be used with a KeymapActionMap.
<i>4316</i>&nbsp;     * KeymapWrapper for the most part, is an InputMap with two parents.
<b class="nc"><i>4317</i>&nbsp;     * The first parent visited is ALWAYS the Keymap, with the second</b>
<b class="nc"><i>4318</i>&nbsp;     * parent being the parent inherited from InputMap. If</b>
<b class="nc"><i>4319</i>&nbsp;     * &lt;code&gt;keymap.getAction&lt;/code&gt; returns null, implying the Keymap</b>
<b class="nc"><i>4320</i>&nbsp;     * does not have a binding for the KeyStroke,</b>
<b class="nc"><i>4321</i>&nbsp;     * the parent is then visited. If the Keymap has a binding, the</b>
<b class="nc"><i>4322</i>&nbsp;     * Action is returned, if not and the KeyStroke represents a</b>
<i>4323</i>&nbsp;     * KeyTyped event and the Keymap has a defaultAction,
<i>4324</i>&nbsp;     * &lt;code&gt;DefaultActionKey&lt;/code&gt; is returned.
<b class="nc"><i>4325</i>&nbsp;     * &lt;p&gt;KeymapActionMap is then able to transate the object passed in</b>
<i>4326</i>&nbsp;     * to either message the Keymap, or message its default implementation.
<i>4327</i>&nbsp;     */
<b class="nc"><i>4328</i>&nbsp;    static class KeymapWrapper extends InputMap {</b>
<i>4329</i>&nbsp;        static final Object DefaultActionKey = new Object();
<i>4330</i>&nbsp;
<i>4331</i>&nbsp;        private Keymap keymap;
<i>4332</i>&nbsp;
<i>4333</i>&nbsp;        KeymapWrapper(Keymap keymap) {
<i>4334</i>&nbsp;            this.keymap = keymap;
<i>4335</i>&nbsp;        }
<i>4336</i>&nbsp;
<i>4337</i>&nbsp;        public KeyStroke[] keys() {
<i>4338</i>&nbsp;            KeyStroke[] sKeys = super.keys();
<i>4339</i>&nbsp;            KeyStroke[] keymapKeys = keymap.getBoundKeyStrokes();
<i>4340</i>&nbsp;            int sCount = (sKeys == null) ? 0 : sKeys.length;
<i>4341</i>&nbsp;            int keymapCount = (keymapKeys == null) ? 0 : keymapKeys.length;
<b class="nc"><i>4342</i>&nbsp;            if (sCount == 0) {</b>
<b class="nc"><i>4343</i>&nbsp;                return keymapKeys;</b>
<i>4344</i>&nbsp;            }
<i>4345</i>&nbsp;            if (keymapCount == 0) {
<i>4346</i>&nbsp;                return sKeys;
<b class="nc"><i>4347</i>&nbsp;            }</b>
<b class="nc"><i>4348</i>&nbsp;            KeyStroke[] retValue = new KeyStroke[sCount + keymapCount];</b>
<b class="nc"><i>4349</i>&nbsp;            // There may be some duplication here...</b>
<b class="nc"><i>4350</i>&nbsp;            System.arraycopy(sKeys, 0, retValue, 0, sCount);</b>
<b class="nc"><i>4351</i>&nbsp;            System.arraycopy(keymapKeys, 0, retValue, sCount, keymapCount);</b>
<b class="nc"><i>4352</i>&nbsp;            return retValue;</b>
<b class="nc"><i>4353</i>&nbsp;        }</b>
<i>4354</i>&nbsp;
<b class="nc"><i>4355</i>&nbsp;        public int size() {</b>
<b class="nc"><i>4356</i>&nbsp;            // There may be some duplication here...</b>
<b class="nc"><i>4357</i>&nbsp;            KeyStroke[] keymapStrokes = keymap.getBoundKeyStrokes();</b>
<b class="nc"><i>4358</i>&nbsp;            int keymapCount = (keymapStrokes == null) ? 0:</b>
<b class="nc"><i>4359</i>&nbsp;                               keymapStrokes.length;</b>
<i>4360</i>&nbsp;            return super.size() + keymapCount;
<i>4361</i>&nbsp;        }
<b class="nc"><i>4362</i>&nbsp;</b>
<b class="nc"><i>4363</i>&nbsp;        public Object get(KeyStroke keyStroke) {</b>
<i>4364</i>&nbsp;            Object retValue = keymap.getAction(keyStroke);
<b class="nc"><i>4365</i>&nbsp;            if (retValue == null) {</b>
<i>4366</i>&nbsp;                retValue = super.get(keyStroke);
<b class="nc"><i>4367</i>&nbsp;                if (retValue == null &amp;&amp;</b>
<b class="nc"><i>4368</i>&nbsp;                    keyStroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED &amp;&amp;</b>
<i>4369</i>&nbsp;                    keymap.getDefaultAction() != null) {
<b class="nc"><i>4370</i>&nbsp;                    // Implies this is a KeyTyped event, use the default</b>
<i>4371</i>&nbsp;                    // action.
<b class="nc"><i>4372</i>&nbsp;                    retValue = DefaultActionKey;</b>
<b class="nc"><i>4373</i>&nbsp;                }</b>
<b class="nc"><i>4374</i>&nbsp;            }</b>
<b class="nc"><i>4375</i>&nbsp;            return retValue;</b>
<i>4376</i>&nbsp;        }
<i>4377</i>&nbsp;    }
<b class="nc"><i>4378</i>&nbsp;</b>
<i>4379</i>&nbsp;
<i>4380</i>&nbsp;    /**
<i>4381</i>&nbsp;     * Wraps a Keymap inside an ActionMap. This is used with
<b class="nc"><i>4382</i>&nbsp;     * a KeymapWrapper. If &lt;code&gt;get&lt;/code&gt; is passed in</b>
<i>4383</i>&nbsp;     * &lt;code&gt;KeymapWrapper.DefaultActionKey&lt;/code&gt;, the default action is
<b class="nc"><i>4384</i>&nbsp;     * returned, otherwise if the key is an Action, it is returned.</b>
<i>4385</i>&nbsp;     */
<i>4386</i>&nbsp;    static class KeymapActionMap extends ActionMap {
<i>4387</i>&nbsp;        private Keymap keymap;
<i>4388</i>&nbsp;
<b class="nc"><i>4389</i>&nbsp;        KeymapActionMap(Keymap keymap) {</b>
<b class="nc"><i>4390</i>&nbsp;            this.keymap = keymap;</b>
<b class="nc"><i>4391</i>&nbsp;        }</b>
<b class="nc"><i>4392</i>&nbsp;</b>
<i>4393</i>&nbsp;        public Object[] keys() {
<b class="nc"><i>4394</i>&nbsp;            Object[] sKeys = super.keys();</b>
<i>4395</i>&nbsp;            Object[] keymapKeys = keymap.getBoundActions();
<i>4396</i>&nbsp;            int sCount = (sKeys == null) ? 0 : sKeys.length;
<i>4397</i>&nbsp;            int keymapCount = (keymapKeys == null) ? 0 : keymapKeys.length;
<b class="nc"><i>4398</i>&nbsp;            boolean hasDefault = (keymap.getDefaultAction() != null);</b>
<b class="nc"><i>4399</i>&nbsp;            if (hasDefault) {</b>
<i>4400</i>&nbsp;                keymapCount++;
<b class="nc"><i>4401</i>&nbsp;            }</b>
<b class="nc"><i>4402</i>&nbsp;            if (sCount == 0) {</b>
<i>4403</i>&nbsp;                if (hasDefault) {
<b class="nc"><i>4404</i>&nbsp;                    Object[] retValue = new Object[keymapCount];</b>
<i>4405</i>&nbsp;                    if (keymapCount &gt; 1) {
<i>4406</i>&nbsp;                        System.arraycopy(keymapKeys, 0, retValue, 0,
<i>4407</i>&nbsp;                                         keymapCount - 1);
<b class="nc"><i>4408</i>&nbsp;                    }</b>
<i>4409</i>&nbsp;                    retValue[keymapCount - 1] = KeymapWrapper.DefaultActionKey;
<i>4410</i>&nbsp;                    return retValue;
<b class="nc"><i>4411</i>&nbsp;                }</b>
<i>4412</i>&nbsp;                return keymapKeys;
<i>4413</i>&nbsp;            }
<i>4414</i>&nbsp;            if (keymapCount == 0) {
<b class="nc"><i>4415</i>&nbsp;                return sKeys;</b>
<i>4416</i>&nbsp;            }
<i>4417</i>&nbsp;            Object[] retValue = new Object[sCount + keymapCount];
<i>4418</i>&nbsp;            // There may be some duplication here...
<i>4419</i>&nbsp;            System.arraycopy(sKeys, 0, retValue, 0, sCount);
<i>4420</i>&nbsp;            if (hasDefault) {
<i>4421</i>&nbsp;                if (keymapCount &gt; 1) {
<i>4422</i>&nbsp;                    System.arraycopy(keymapKeys, 0, retValue, sCount,
<i>4423</i>&nbsp;                                     keymapCount - 1);
<i>4424</i>&nbsp;                }
<i>4425</i>&nbsp;                retValue[sCount + keymapCount - 1] = KeymapWrapper.
<i>4426</i>&nbsp;                                                 DefaultActionKey;
<i>4427</i>&nbsp;            }
<i>4428</i>&nbsp;            else {
<i>4429</i>&nbsp;                System.arraycopy(keymapKeys, 0, retValue, sCount, keymapCount);
<i>4430</i>&nbsp;            }
<i>4431</i>&nbsp;            return retValue;
<i>4432</i>&nbsp;        }
<b class="nc"><i>4433</i>&nbsp;</b>
<i>4434</i>&nbsp;        public int size() {
<i>4435</i>&nbsp;            // There may be some duplication here...
<i>4436</i>&nbsp;            Object[] actions = keymap.getBoundActions();
<b class="nc"><i>4437</i>&nbsp;            int keymapCount = (actions == null) ? 0 : actions.length;</b>
<b class="nc"><i>4438</i>&nbsp;            if (keymap.getDefaultAction() != null) {</b>
<b class="nc"><i>4439</i>&nbsp;                keymapCount++;</b>
<b class="nc"><i>4440</i>&nbsp;            }</b>
<b class="nc"><i>4441</i>&nbsp;            return super.size() + keymapCount;</b>
<b class="nc"><i>4442</i>&nbsp;        }</b>
<i>4443</i>&nbsp;
<i>4444</i>&nbsp;        public Action get(Object key) {
<i>4445</i>&nbsp;            Action retValue = super.get(key);
<i>4446</i>&nbsp;            if (retValue == null) {
<b class="nc"><i>4447</i>&nbsp;                // Try the Keymap.</b>
<i>4448</i>&nbsp;                if (key == KeymapWrapper.DefaultActionKey) {
<i>4449</i>&nbsp;                    retValue = keymap.getDefaultAction();
<i>4450</i>&nbsp;                }
<i>4451</i>&nbsp;                else if (key instanceof Action) {
<i>4452</i>&nbsp;                    // This is a little iffy, technically an Action is
<b class="nc"><i>4453</i>&nbsp;                    // a valid Key. We&#39;re assuming the Action came from</b>
<i>4454</i>&nbsp;                    // the InputMap though.
<i>4455</i>&nbsp;                    retValue = (Action)key;
<i>4456</i>&nbsp;                }
<b class="nc"><i>4457</i>&nbsp;            }</b>
<i>4458</i>&nbsp;            return retValue;
<i>4459</i>&nbsp;        }
<i>4460</i>&nbsp;    }
<i>4461</i>&nbsp;
<i>4462</i>&nbsp;    private static final Object FOCUSED_COMPONENT =
<b class="nc"><i>4463</i>&nbsp;        new StringBuilder(&quot;JTextComponent_FocusedComponent&quot;);</b>
<b class="nc"><i>4464</i>&nbsp;</b>
<i>4465</i>&nbsp;    /**
<i>4466</i>&nbsp;     * The default keymap that will be shared by all
<i>4467</i>&nbsp;     * &lt;code&gt;JTextComponent&lt;/code&gt; instances unless they
<i>4468</i>&nbsp;     * have had a different keymap set.
<i>4469</i>&nbsp;     */
<b class="nc"><i>4470</i>&nbsp;    public static final String DEFAULT_KEYMAP = &quot;default&quot;;</b>
<b class="nc"><i>4471</i>&nbsp;</b>
<i>4472</i>&nbsp;    /**
<i>4473</i>&nbsp;     * Event to use when firing a notification of change to caret
<i>4474</i>&nbsp;     * position.  This is mutable so that the event can be reused
<i>4475</i>&nbsp;     * since caret events can be fairly high in bandwidth.
<i>4476</i>&nbsp;     */
<i>4477</i>&nbsp;    static class MutableCaretEvent extends CaretEvent implements ChangeListener, FocusListener, MouseListener {
<i>4478</i>&nbsp;
<i>4479</i>&nbsp;        MutableCaretEvent(JTextComponent c) {
<i>4480</i>&nbsp;            super(c);
<i>4481</i>&nbsp;        }
<i>4482</i>&nbsp;
<i>4483</i>&nbsp;        final void fire() {
<i>4484</i>&nbsp;            JTextComponent c = (JTextComponent) getSource();
<i>4485</i>&nbsp;            if (c != null) {
<i>4486</i>&nbsp;                Caret caret = c.getCaret();
<b class="nc"><i>4487</i>&nbsp;                dot = caret.getDot();</b>
<i>4488</i>&nbsp;                mark = caret.getMark();
<i>4489</i>&nbsp;                c.fireCaretUpdate(this);
<i>4490</i>&nbsp;            }
<i>4491</i>&nbsp;        }
<i>4492</i>&nbsp;
<i>4493</i>&nbsp;        public final String toString() {
<i>4494</i>&nbsp;            return &quot;dot=&quot; + dot + &quot;,&quot; + &quot;mark=&quot; + mark;
<i>4495</i>&nbsp;        }
<i>4496</i>&nbsp;
<b class="nc"><i>4497</i>&nbsp;        // --- CaretEvent methods -----------------------</b>
<b class="nc"><i>4498</i>&nbsp;</b>
<i>4499</i>&nbsp;        public final int getDot() {
<i>4500</i>&nbsp;            return dot;
<i>4501</i>&nbsp;        }
<i>4502</i>&nbsp;
<i>4503</i>&nbsp;        public final int getMark() {
<i>4504</i>&nbsp;            return mark;
<i>4505</i>&nbsp;        }
<i>4506</i>&nbsp;
<i>4507</i>&nbsp;        // --- ChangeListener methods -------------------
<i>4508</i>&nbsp;
<i>4509</i>&nbsp;        public final void stateChanged(ChangeEvent e) {
<i>4510</i>&nbsp;            if (! dragActive) {
<i>4511</i>&nbsp;                fire();
<i>4512</i>&nbsp;            }
<i>4513</i>&nbsp;        }
<i>4514</i>&nbsp;
<i>4515</i>&nbsp;        // --- FocusListener methods -----------------------------------
<i>4516</i>&nbsp;        public void focusGained(FocusEvent fe) {
<i>4517</i>&nbsp;            AppContext.getAppContext().put(FOCUSED_COMPONENT,
<i>4518</i>&nbsp;                                           fe.getSource());
<i>4519</i>&nbsp;        }
<i>4520</i>&nbsp;
<i>4521</i>&nbsp;        public void focusLost(FocusEvent fe) {
<i>4522</i>&nbsp;        }
<b class="nc"><i>4523</i>&nbsp;</b>
<i>4524</i>&nbsp;        // --- MouseListener methods -----------------------------------
<b class="nc"><i>4525</i>&nbsp;</b>
<b class="nc"><i>4526</i>&nbsp;        /**</b>
<i>4527</i>&nbsp;         * Requests focus on the associated
<i>4528</i>&nbsp;         * text component, and try to set the cursor position.
<b class="nc"><i>4529</i>&nbsp;         *</b>
<i>4530</i>&nbsp;         * @param e the mouse event
<b class="nc"><i>4531</i>&nbsp;         * @see MouseListener#mousePressed</b>
<i>4532</i>&nbsp;         */
<i>4533</i>&nbsp;        public final void mousePressed(MouseEvent e) {
<i>4534</i>&nbsp;            dragActive = true;
<i>4535</i>&nbsp;        }
<b class="nc"><i>4536</i>&nbsp;</b>
<i>4537</i>&nbsp;        /**
<i>4538</i>&nbsp;         * Called when the mouse is released.
<i>4539</i>&nbsp;         *
<i>4540</i>&nbsp;         * @param e the mouse event
<b class="nc"><i>4541</i>&nbsp;         * @see MouseListener#mouseReleased</b>
<i>4542</i>&nbsp;         */
<i>4543</i>&nbsp;        public final void mouseReleased(MouseEvent e) {
<i>4544</i>&nbsp;            dragActive = false;
<i>4545</i>&nbsp;            fire();
<i>4546</i>&nbsp;        }
<i>4547</i>&nbsp;
<i>4548</i>&nbsp;        public final void mouseClicked(MouseEvent e) {
<b class="nc"><i>4549</i>&nbsp;        }</b>
<b class="nc"><i>4550</i>&nbsp;</b>
<b class="nc"><i>4551</i>&nbsp;        public final void mouseEntered(MouseEvent e) {</b>
<b class="nc"><i>4552</i>&nbsp;        }</b>
<b class="nc"><i>4553</i>&nbsp;</b>
<i>4554</i>&nbsp;        public final void mouseExited(MouseEvent e) {
<i>4555</i>&nbsp;        }
<i>4556</i>&nbsp;
<b class="nc"><i>4557</i>&nbsp;        private boolean dragActive;</b>
<i>4558</i>&nbsp;        private int dot;
<i>4559</i>&nbsp;        private int mark;
<i>4560</i>&nbsp;    }
<i>4561</i>&nbsp;
<i>4562</i>&nbsp;    //
<i>4563</i>&nbsp;    // Process any input method events that the component itself
<b class="nc"><i>4564</i>&nbsp;    // recognizes. The default on-the-spot handling for input method</b>
<b class="nc"><i>4565</i>&nbsp;    // composed(uncommitted) text is done here after all input</b>
<b class="nc"><i>4566</i>&nbsp;    // method listeners get called for stealing the events.</b>
<b class="nc"><i>4567</i>&nbsp;    //</b>
<i>4568</i>&nbsp;    @SuppressWarnings(&quot;fallthrough&quot;)
<i>4569</i>&nbsp;    protected void processInputMethodEvent(InputMethodEvent e) {
<i>4570</i>&nbsp;        // let listeners handle the events
<i>4571</i>&nbsp;        super.processInputMethodEvent(e);
<i>4572</i>&nbsp;
<i>4573</i>&nbsp;        if (!e.isConsumed()) {
<i>4574</i>&nbsp;            if (! isEditable()) {
<b class="nc"><i>4575</i>&nbsp;                return;</b>
<i>4576</i>&nbsp;            } else {
<i>4577</i>&nbsp;                switch (e.getID()) {
<i>4578</i>&nbsp;                case InputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
<i>4579</i>&nbsp;                    replaceInputMethodText(e);
<i>4580</i>&nbsp;
<b class="nc"><i>4581</i>&nbsp;                    // fall through</b>
<b class="nc"><i>4582</i>&nbsp;</b>
<b class="nc"><i>4583</i>&nbsp;                case InputMethodEvent.CARET_POSITION_CHANGED:</b>
<i>4584</i>&nbsp;                    setInputMethodCaretPosition(e);
<b class="nc"><i>4585</i>&nbsp;                    break;</b>
<b class="nc"><i>4586</i>&nbsp;                }</b>
<b class="nc"><i>4587</i>&nbsp;            }</b>
<b class="nc"><i>4588</i>&nbsp;</b>
<b class="nc"><i>4589</i>&nbsp;            e.consume();</b>
<b class="nc"><i>4590</i>&nbsp;        }</b>
<b class="nc"><i>4591</i>&nbsp;    }</b>
<i>4592</i>&nbsp;
<b class="nc"><i>4593</i>&nbsp;    //</b>
<i>4594</i>&nbsp;    // Overrides this method to become an active input method client.
<i>4595</i>&nbsp;    //
<i>4596</i>&nbsp;    @BeanProperty(bound = false)
<i>4597</i>&nbsp;    public InputMethodRequests getInputMethodRequests() {
<b class="nc"><i>4598</i>&nbsp;        if (inputMethodRequestsHandler == null) {</b>
<b class="nc"><i>4599</i>&nbsp;            inputMethodRequestsHandler = new InputMethodRequestsHandler();</b>
<b class="nc"><i>4600</i>&nbsp;            Document doc = getDocument();</b>
<b class="nc"><i>4601</i>&nbsp;            if (doc != null) {</b>
<b class="nc"><i>4602</i>&nbsp;                doc.addDocumentListener((DocumentListener)inputMethodRequestsHandler);</b>
<i>4603</i>&nbsp;            }
<i>4604</i>&nbsp;        }
<i>4605</i>&nbsp;
<i>4606</i>&nbsp;        return inputMethodRequestsHandler;
<b class="nc"><i>4607</i>&nbsp;    }</b>
<b class="nc"><i>4608</i>&nbsp;</b>
<b class="nc"><i>4609</i>&nbsp;    //</b>
<i>4610</i>&nbsp;    // Overrides this method to watch the listener installed.
<b class="nc"><i>4611</i>&nbsp;    //</b>
<b class="nc"><i>4612</i>&nbsp;    public void addInputMethodListener(InputMethodListener l) {</b>
<b class="nc"><i>4613</i>&nbsp;        super.addInputMethodListener(l);</b>
<b class="nc"><i>4614</i>&nbsp;        if (l != null) {</b>
<i>4615</i>&nbsp;            needToSendKeyTypedEvent = false;
<b class="nc"><i>4616</i>&nbsp;            checkedInputOverride = true;</b>
<i>4617</i>&nbsp;        }
<i>4618</i>&nbsp;    }
<b class="nc"><i>4619</i>&nbsp;</b>
<b class="nc"><i>4620</i>&nbsp;</b>
<b class="nc"><i>4621</i>&nbsp;    //</b>
<b class="nc"><i>4622</i>&nbsp;    // Default implementation of the InputMethodRequests interface.</b>
<i>4623</i>&nbsp;    //
<i>4624</i>&nbsp;    class InputMethodRequestsHandler implements InputMethodRequests, DocumentListener {
<i>4625</i>&nbsp;
<b class="nc"><i>4626</i>&nbsp;        // --- InputMethodRequests methods ---</b>
<b class="nc"><i>4627</i>&nbsp;</b>
<b class="nc"><i>4628</i>&nbsp;        public AttributedCharacterIterator cancelLatestCommittedText(</b>
<b class="nc"><i>4629</i>&nbsp;                                                Attribute[] attributes) {</b>
<b class="nc"><i>4630</i>&nbsp;            Document doc = getDocument();</b>
<b class="nc"><i>4631</i>&nbsp;            if ((doc != null) &amp;&amp; (latestCommittedTextStart != null)</b>
<b class="nc"><i>4632</i>&nbsp;                &amp;&amp; (!latestCommittedTextStart.equals(latestCommittedTextEnd))) {</b>
<i>4633</i>&nbsp;                try {
<i>4634</i>&nbsp;                    int startIndex = latestCommittedTextStart.getOffset();
<i>4635</i>&nbsp;                    int endIndex = latestCommittedTextEnd.getOffset();
<i>4636</i>&nbsp;                    String latestCommittedText =
<i>4637</i>&nbsp;                        doc.getText(startIndex, endIndex - startIndex);
<i>4638</i>&nbsp;                    doc.remove(startIndex, endIndex - startIndex);
<i>4639</i>&nbsp;                    return new AttributedString(latestCommittedText).getIterator();
<b class="nc"><i>4640</i>&nbsp;                } catch (BadLocationException ble) {}</b>
<i>4641</i>&nbsp;            }
<b class="nc"><i>4642</i>&nbsp;            return null;</b>
<b class="nc"><i>4643</i>&nbsp;        }</b>
<i>4644</i>&nbsp;
<i>4645</i>&nbsp;        public AttributedCharacterIterator getCommittedText(int beginIndex,
<i>4646</i>&nbsp;                                        int endIndex, Attribute[] attributes) {
<b class="nc"><i>4647</i>&nbsp;            int composedStartIndex = 0;</b>
<i>4648</i>&nbsp;            int composedEndIndex = 0;
<i>4649</i>&nbsp;            if (composedTextExists()) {
<i>4650</i>&nbsp;                composedStartIndex = composedTextStart.getOffset();
<b class="nc"><i>4651</i>&nbsp;                composedEndIndex = composedTextEnd.getOffset();</b>
<b class="nc"><i>4652</i>&nbsp;            }</b>
<b class="nc"><i>4653</i>&nbsp;</b>
<b class="nc"><i>4654</i>&nbsp;            String committed;</b>
<b class="nc"><i>4655</i>&nbsp;            try {</b>
<i>4656</i>&nbsp;                if (beginIndex &lt; composedStartIndex) {
<b class="nc"><i>4657</i>&nbsp;                    if (endIndex &lt;= composedStartIndex) {</b>
<i>4658</i>&nbsp;                        committed = getText(beginIndex, endIndex - beginIndex);
<b class="nc"><i>4659</i>&nbsp;                    } else {</b>
<b class="nc"><i>4660</i>&nbsp;                        int firstPartLength = composedStartIndex - beginIndex;</b>
<b class="nc"><i>4661</i>&nbsp;                        committed = getText(beginIndex, firstPartLength) +</b>
<b class="nc"><i>4662</i>&nbsp;                            getText(composedEndIndex, endIndex - beginIndex - firstPartLength);</b>
<i>4663</i>&nbsp;                    }
<b class="nc"><i>4664</i>&nbsp;                } else {</b>
<i>4665</i>&nbsp;                    committed = getText(beginIndex + (composedEndIndex - composedStartIndex),
<i>4666</i>&nbsp;                                        endIndex - beginIndex);
<i>4667</i>&nbsp;                }
<i>4668</i>&nbsp;            } catch (BadLocationException ble) {
<b class="nc"><i>4669</i>&nbsp;                throw new IllegalArgumentException(&quot;Invalid range&quot;);</b>
<b class="nc"><i>4670</i>&nbsp;            }</b>
<i>4671</i>&nbsp;            return new AttributedString(committed).getIterator();
<b class="nc"><i>4672</i>&nbsp;        }</b>
<b class="nc"><i>4673</i>&nbsp;</b>
<b class="nc"><i>4674</i>&nbsp;        public int getCommittedTextLength() {</b>
<b class="nc"><i>4675</i>&nbsp;            Document doc = getDocument();</b>
<b class="nc"><i>4676</i>&nbsp;            int length = 0;</b>
<b class="nc"><i>4677</i>&nbsp;            if (doc != null) {</b>
<b class="nc"><i>4678</i>&nbsp;                length = doc.getLength();</b>
<i>4679</i>&nbsp;                if (composedTextContent != null) {
<b class="nc"><i>4680</i>&nbsp;                    if (composedTextEnd == null</b>
<i>4681</i>&nbsp;                          || composedTextStart == null) {
<i>4682</i>&nbsp;                        /*
<i>4683</i>&nbsp;                         * fix for : 6355666
<i>4684</i>&nbsp;                         * this is the case when this method is invoked
<i>4685</i>&nbsp;                         * from DocumentListener. At this point
<i>4686</i>&nbsp;                         * composedTextEnd and composedTextStart are
<i>4687</i>&nbsp;                         * not defined yet.
<i>4688</i>&nbsp;                         */
<b class="nc"><i>4689</i>&nbsp;                        length -= composedTextContent.length();</b>
<b class="nc"><i>4690</i>&nbsp;                    } else {</b>
<b class="nc"><i>4691</i>&nbsp;                        length -= composedTextEnd.getOffset() -</b>
<b class="nc"><i>4692</i>&nbsp;                            composedTextStart.getOffset();</b>
<i>4693</i>&nbsp;                    }
<b class="nc"><i>4694</i>&nbsp;                }</b>
<b class="nc"><i>4695</i>&nbsp;            }</b>
<b class="nc"><i>4696</i>&nbsp;            return length;</b>
<i>4697</i>&nbsp;        }
<b class="nc"><i>4698</i>&nbsp;</b>
<b class="nc"><i>4699</i>&nbsp;        public int getInsertPositionOffset() {</b>
<i>4700</i>&nbsp;            int composedStartIndex = 0;
<b class="nc"><i>4701</i>&nbsp;            int composedEndIndex = 0;</b>
<i>4702</i>&nbsp;            if (composedTextExists()) {
<i>4703</i>&nbsp;                composedStartIndex = composedTextStart.getOffset();
<i>4704</i>&nbsp;                composedEndIndex = composedTextEnd.getOffset();
<i>4705</i>&nbsp;            }
<b class="nc"><i>4706</i>&nbsp;            int caretIndex = getCaretPosition();</b>
<b class="nc"><i>4707</i>&nbsp;</b>
<b class="nc"><i>4708</i>&nbsp;            if (caretIndex &lt; composedStartIndex) {</b>
<i>4709</i>&nbsp;                return caretIndex;
<b class="nc"><i>4710</i>&nbsp;            } else if (caretIndex &lt; composedEndIndex) {</b>
<i>4711</i>&nbsp;                return composedStartIndex;
<i>4712</i>&nbsp;            } else {
<i>4713</i>&nbsp;                return caretIndex - (composedEndIndex - composedStartIndex);
<i>4714</i>&nbsp;            }
<i>4715</i>&nbsp;        }
<i>4716</i>&nbsp;
<b class="nc"><i>4717</i>&nbsp;        public TextHitInfo getLocationOffset(int x, int y) {</b>
<i>4718</i>&nbsp;            if (composedTextAttribute == null) {
<i>4719</i>&nbsp;                return null;
<i>4720</i>&nbsp;            } else {
<b class="nc"><i>4721</i>&nbsp;                Point p = getLocationOnScreen();</b>
<i>4722</i>&nbsp;                p.x = x - p.x;
<i>4723</i>&nbsp;                p.y = y - p.y;
<i>4724</i>&nbsp;                int pos = viewToModel(p);
<b class="nc"><i>4725</i>&nbsp;                if ((pos &gt;= composedTextStart.getOffset()) &amp;&amp;</b>
<i>4726</i>&nbsp;                    (pos &lt;= composedTextEnd.getOffset())) {
<i>4727</i>&nbsp;                    return TextHitInfo.leading(pos - composedTextStart.getOffset());
<i>4728</i>&nbsp;                } else {
<i>4729</i>&nbsp;                    return null;
<i>4730</i>&nbsp;                }
<i>4731</i>&nbsp;            }
<i>4732</i>&nbsp;        }
<i>4733</i>&nbsp;
<i>4734</i>&nbsp;        public Rectangle getTextLocation(TextHitInfo offset) {
<b class="nc"><i>4735</i>&nbsp;            Rectangle r;</b>
<b class="nc"><i>4736</i>&nbsp;</b>
<i>4737</i>&nbsp;            try {
<i>4738</i>&nbsp;                r = modelToView(getCaretPosition());
<i>4739</i>&nbsp;                if (r != null) {
<b class="nc"><i>4740</i>&nbsp;                    Point p = getLocationOnScreen();</b>
<b class="nc"><i>4741</i>&nbsp;                    r.translate(p.x, p.y);</b>
<i>4742</i>&nbsp;                }
<b class="nc"><i>4743</i>&nbsp;            } catch (BadLocationException ble) {</b>
<b class="nc"><i>4744</i>&nbsp;                r = null;</b>
<b class="nc"><i>4745</i>&nbsp;            }</b>
<b class="nc"><i>4746</i>&nbsp;</b>
<b class="nc"><i>4747</i>&nbsp;            if (r == null)</b>
<b class="nc"><i>4748</i>&nbsp;                r = new Rectangle();</b>
<b class="nc"><i>4749</i>&nbsp;</b>
<i>4750</i>&nbsp;            return r;
<i>4751</i>&nbsp;        }
<b class="nc"><i>4752</i>&nbsp;</b>
<b class="nc"><i>4753</i>&nbsp;        public AttributedCharacterIterator getSelectedText(</b>
<b class="nc"><i>4754</i>&nbsp;                                                Attribute[] attributes) {</b>
<b class="nc"><i>4755</i>&nbsp;            String selection = JTextComponent.this.getSelectedText();</b>
<i>4756</i>&nbsp;            if (selection != null) {
<i>4757</i>&nbsp;                return new AttributedString(selection).getIterator();
<b class="nc"><i>4758</i>&nbsp;            } else {</b>
<i>4759</i>&nbsp;                return null;
<b class="nc"><i>4760</i>&nbsp;            }</b>
<i>4761</i>&nbsp;        }
<i>4762</i>&nbsp;
<i>4763</i>&nbsp;        // --- DocumentListener methods ---
<b class="nc"><i>4764</i>&nbsp;</b>
<b class="nc"><i>4765</i>&nbsp;        public void changedUpdate(DocumentEvent e) {</b>
<b class="nc"><i>4766</i>&nbsp;            latestCommittedTextStart = latestCommittedTextEnd = null;</b>
<b class="nc"><i>4767</i>&nbsp;        }</b>
<b class="nc"><i>4768</i>&nbsp;</b>
<i>4769</i>&nbsp;        public void insertUpdate(DocumentEvent e) {
<b class="nc"><i>4770</i>&nbsp;            latestCommittedTextStart = latestCommittedTextEnd = null;</b>
<i>4771</i>&nbsp;        }
<i>4772</i>&nbsp;
<b class="nc"><i>4773</i>&nbsp;        public void removeUpdate(DocumentEvent e) {</b>
<b class="nc"><i>4774</i>&nbsp;            latestCommittedTextStart = latestCommittedTextEnd = null;</b>
<b class="nc"><i>4775</i>&nbsp;        }</b>
<b class="nc"><i>4776</i>&nbsp;    }</b>
<i>4777</i>&nbsp;
<i>4778</i>&nbsp;    //
<i>4779</i>&nbsp;    // Replaces the current input method (composed) text according to
<b class="nc"><i>4780</i>&nbsp;    // the passed input method event. This method also inserts the</b>
<i>4781</i>&nbsp;    // committed text into the document.
<i>4782</i>&nbsp;    //
<i>4783</i>&nbsp;    private void replaceInputMethodText(InputMethodEvent e) {
<b class="nc"><i>4784</i>&nbsp;        int commitCount = e.getCommittedCharacterCount();</b>
<i>4785</i>&nbsp;        AttributedCharacterIterator text = e.getText();
<i>4786</i>&nbsp;        int composedTextIndex;
<i>4787</i>&nbsp;
<b class="nc"><i>4788</i>&nbsp;        // old composed text deletion</b>
<b class="nc"><i>4789</i>&nbsp;        Document doc = getDocument();</b>
<b class="nc"><i>4790</i>&nbsp;        if (composedTextExists()) {</b>
<i>4791</i>&nbsp;            try {
<b class="nc"><i>4792</i>&nbsp;                doc.remove(composedTextStart.getOffset(),</b>
<b class="nc"><i>4793</i>&nbsp;                           composedTextEnd.getOffset() -</b>
<i>4794</i>&nbsp;                           composedTextStart.getOffset());
<b class="nc"><i>4795</i>&nbsp;            } catch (BadLocationException ble) {}</b>
<b class="nc"><i>4796</i>&nbsp;            composedTextStart = composedTextEnd = null;</b>
<b class="nc"><i>4797</i>&nbsp;            composedTextAttribute = null;</b>
<b class="nc"><i>4798</i>&nbsp;            composedTextContent = null;</b>
<b class="nc"><i>4799</i>&nbsp;        }</b>
<b class="nc"><i>4800</i>&nbsp;</b>
<b class="nc"><i>4801</i>&nbsp;        if (text != null) {</b>
<b class="nc"><i>4802</i>&nbsp;            text.first();</b>
<i>4803</i>&nbsp;            int committedTextStartIndex = 0;
<i>4804</i>&nbsp;            int committedTextEndIndex = 0;
<i>4805</i>&nbsp;
<b class="nc"><i>4806</i>&nbsp;            // committed text insertion</b>
<i>4807</i>&nbsp;            if (commitCount &gt; 0) {
<b class="nc"><i>4808</i>&nbsp;                // Remember latest committed text start index</b>
<b class="nc"><i>4809</i>&nbsp;                committedTextStartIndex = caret.getDot();</b>
<b class="nc"><i>4810</i>&nbsp;</b>
<b class="nc"><i>4811</i>&nbsp;                // Need to generate KeyTyped events for the committed text for components</b>
<b class="nc"><i>4812</i>&nbsp;                // that are not aware they are active input method clients.</b>
<b class="nc"><i>4813</i>&nbsp;                if (shouldSynthensizeKeyEvents()) {</b>
<i>4814</i>&nbsp;                    for (char c = text.current(); commitCount &gt; 0;
<b class="nc"><i>4815</i>&nbsp;                         c = text.next(), commitCount--) {</b>
<i>4816</i>&nbsp;                        KeyEvent ke = new KeyEvent(this, KeyEvent.KEY_TYPED,
<b class="nc"><i>4817</i>&nbsp;                                                   EventQueue.getMostRecentEventTime(),</b>
<i>4818</i>&nbsp;                                                   0, KeyEvent.VK_UNDEFINED, c);
<i>4819</i>&nbsp;                        processKeyEvent(ke);
<i>4820</i>&nbsp;                    }
<i>4821</i>&nbsp;                } else {
<i>4822</i>&nbsp;                    StringBuilder strBuf = new StringBuilder();
<i>4823</i>&nbsp;                    for (char c = text.current(); commitCount &gt; 0;
<i>4824</i>&nbsp;                         c = text.next(), commitCount--) {
<b class="nc"><i>4825</i>&nbsp;                        strBuf.append(c);</b>
<b class="nc"><i>4826</i>&nbsp;                    }</b>
<i>4827</i>&nbsp;
<i>4828</i>&nbsp;                    // map it to an ActionEvent
<b class="nc"><i>4829</i>&nbsp;                    mapCommittedTextToAction(strBuf.toString());</b>
<b class="nc"><i>4830</i>&nbsp;                }</b>
<b class="nc"><i>4831</i>&nbsp;</b>
<i>4832</i>&nbsp;                // Remember latest committed text end index
<i>4833</i>&nbsp;                committedTextEndIndex = caret.getDot();
<b class="nc"><i>4834</i>&nbsp;            }</b>
<b class="nc"><i>4835</i>&nbsp;</b>
<b class="nc"><i>4836</i>&nbsp;            // new composed text insertion</b>
<b class="nc"><i>4837</i>&nbsp;            composedTextIndex = text.getIndex();</b>
<i>4838</i>&nbsp;            if (composedTextIndex &lt; text.getEndIndex()) {
<i>4839</i>&nbsp;                createComposedTextAttribute(composedTextIndex, text);
<i>4840</i>&nbsp;                try {
<i>4841</i>&nbsp;                    replaceSelection(null);
<i>4842</i>&nbsp;                    doc.insertString(caret.getDot(), composedTextContent,
<i>4843</i>&nbsp;                                        composedTextAttribute);
<i>4844</i>&nbsp;                    composedTextStart = doc.createPosition(caret.getDot() -
<i>4845</i>&nbsp;                                                composedTextContent.length());
<i>4846</i>&nbsp;                    composedTextEnd = doc.createPosition(caret.getDot());
<i>4847</i>&nbsp;                } catch (BadLocationException ble) {
<i>4848</i>&nbsp;                    composedTextStart = composedTextEnd = null;
<i>4849</i>&nbsp;                    composedTextAttribute = null;
<i>4850</i>&nbsp;                    composedTextContent = null;
<i>4851</i>&nbsp;                }
<i>4852</i>&nbsp;            }
<b class="nc"><i>4853</i>&nbsp;</b>
<b class="nc"><i>4854</i>&nbsp;            // Save the latest committed text information</b>
<b class="nc"><i>4855</i>&nbsp;            if (committedTextStartIndex != committedTextEndIndex) {</b>
<b class="nc"><i>4856</i>&nbsp;                try {</b>
<b class="nc"><i>4857</i>&nbsp;                    latestCommittedTextStart = doc.</b>
<i>4858</i>&nbsp;                        createPosition(committedTextStartIndex);
<b class="nc"><i>4859</i>&nbsp;                    latestCommittedTextEnd = doc.</b>
<b class="nc"><i>4860</i>&nbsp;                        createPosition(committedTextEndIndex);</b>
<b class="nc"><i>4861</i>&nbsp;                } catch (BadLocationException ble) {</b>
<i>4862</i>&nbsp;                    latestCommittedTextStart =
<i>4863</i>&nbsp;                        latestCommittedTextEnd = null;
<b class="nc"><i>4864</i>&nbsp;                }</b>
<i>4865</i>&nbsp;            } else {
<i>4866</i>&nbsp;                latestCommittedTextStart =
<i>4867</i>&nbsp;                    latestCommittedTextEnd = null;
<i>4868</i>&nbsp;            }
<i>4869</i>&nbsp;        }
<i>4870</i>&nbsp;    }
<i>4871</i>&nbsp;
<i>4872</i>&nbsp;    private void createComposedTextAttribute(int composedIndex,
<i>4873</i>&nbsp;                                        AttributedCharacterIterator text) {
<i>4874</i>&nbsp;        Document doc = getDocument();
<i>4875</i>&nbsp;        StringBuilder strBuf = new StringBuilder();
<i>4876</i>&nbsp;
<b class="nc"><i>4877</i>&nbsp;        // create attributed string with no attributes</b>
<i>4878</i>&nbsp;        for (char c = text.setIndex(composedIndex);
<b class="nc"><i>4879</i>&nbsp;             c != CharacterIterator.DONE; c = text.next()) {</b>
<i>4880</i>&nbsp;            strBuf.append(c);
<i>4881</i>&nbsp;        }
<b class="nc"><i>4882</i>&nbsp;</b>
<b class="nc"><i>4883</i>&nbsp;        composedTextContent = strBuf.toString();</b>
<b class="nc"><i>4884</i>&nbsp;        composedTextAttribute = new SimpleAttributeSet();</b>
<b class="nc"><i>4885</i>&nbsp;        composedTextAttribute.addAttribute(StyleConstants.ComposedTextAttribute,</b>
<i>4886</i>&nbsp;                new AttributedString(text, composedIndex, text.getEndIndex()));
<i>4887</i>&nbsp;    }
<i>4888</i>&nbsp;
<i>4889</i>&nbsp;    /**
<i>4890</i>&nbsp;     * Saves composed text around the specified position.
<i>4891</i>&nbsp;     *
<i>4892</i>&nbsp;     * The composed text (if any) around the specified position is saved
<i>4893</i>&nbsp;     * in a backing store and removed from the document.
<b class="nc"><i>4894</i>&nbsp;     *</b>
<b class="nc"><i>4895</i>&nbsp;     * @param pos  document position to identify the composed text location</b>
<b class="nc"><i>4896</i>&nbsp;     * @return  {@code true} if the composed text exists and is saved,</b>
<b class="nc"><i>4897</i>&nbsp;     *          {@code false} otherwise</b>
<b class="nc"><i>4898</i>&nbsp;     * @see #restoreComposedText</b>
<b class="nc"><i>4899</i>&nbsp;     * @since 1.7</b>
<i>4900</i>&nbsp;     */
<i>4901</i>&nbsp;    protected boolean saveComposedText(int pos) {
<b class="nc"><i>4902</i>&nbsp;        if (composedTextExists()) {</b>
<b class="nc"><i>4903</i>&nbsp;            int start = composedTextStart.getOffset();</b>
<i>4904</i>&nbsp;            int len = composedTextEnd.getOffset() -
<i>4905</i>&nbsp;                composedTextStart.getOffset();
<b class="nc"><i>4906</i>&nbsp;            if (pos &gt;= start &amp;&amp; pos &lt;= start + len) {</b>
<b class="nc"><i>4907</i>&nbsp;                try {</b>
<i>4908</i>&nbsp;                    getDocument().remove(start, len);
<i>4909</i>&nbsp;                    return true;
<b class="nc"><i>4910</i>&nbsp;                } catch (BadLocationException ble) {}</b>
<b class="nc"><i>4911</i>&nbsp;            }</b>
<b class="nc"><i>4912</i>&nbsp;        }</b>
<i>4913</i>&nbsp;        return false;
<i>4914</i>&nbsp;    }
<i>4915</i>&nbsp;
<i>4916</i>&nbsp;    /**
<i>4917</i>&nbsp;     * Restores composed text previously saved by {@code saveComposedText}.
<i>4918</i>&nbsp;     *
<i>4919</i>&nbsp;     * The saved composed text is inserted back into the document. This method
<i>4920</i>&nbsp;     * should be invoked only if {@code saveComposedText} returns {@code true}.
<i>4921</i>&nbsp;     *
<i>4922</i>&nbsp;     * @see #saveComposedText
<i>4923</i>&nbsp;     * @since 1.7
<b class="nc"><i>4924</i>&nbsp;     */</b>
<b class="nc"><i>4925</i>&nbsp;    protected void restoreComposedText() {</b>
<b class="nc"><i>4926</i>&nbsp;        Document doc = getDocument();</b>
<b class="nc"><i>4927</i>&nbsp;        try {</b>
<b class="nc"><i>4928</i>&nbsp;            doc.insertString(caret.getDot(),</b>
<i>4929</i>&nbsp;                             composedTextContent,
<b class="nc"><i>4930</i>&nbsp;                             composedTextAttribute);</b>
<i>4931</i>&nbsp;            composedTextStart = doc.createPosition(caret.getDot() -
<b class="nc"><i>4932</i>&nbsp;                                composedTextContent.length());</b>
<i>4933</i>&nbsp;            composedTextEnd = doc.createPosition(caret.getDot());
<i>4934</i>&nbsp;        } catch (BadLocationException ble) {}
<b class="nc"><i>4935</i>&nbsp;    }</b>
<b class="nc"><i>4936</i>&nbsp;</b>
<b class="nc"><i>4937</i>&nbsp;    //</b>
<b class="nc"><i>4938</i>&nbsp;    // Map committed text to an ActionEvent. If the committed text length is 1,</b>
<b class="nc"><i>4939</i>&nbsp;    // treat it as a KeyStroke, otherwise or there is no KeyStroke defined,</b>
<i>4940</i>&nbsp;    // treat it just as a default action.
<i>4941</i>&nbsp;    //
<i>4942</i>&nbsp;    private void mapCommittedTextToAction(String committedText) {
<b class="nc"><i>4943</i>&nbsp;        Keymap binding = getKeymap();</b>
<b class="nc"><i>4944</i>&nbsp;        if (binding != null) {</b>
<b class="nc"><i>4945</i>&nbsp;            Action a = null;</b>
<b class="nc"><i>4946</i>&nbsp;            if (committedText.length() == 1) {</b>
<b class="nc"><i>4947</i>&nbsp;                KeyStroke k = KeyStroke.getKeyStroke(committedText.charAt(0));</b>
<b class="nc"><i>4948</i>&nbsp;                a = binding.getAction(k);</b>
<i>4949</i>&nbsp;            }
<i>4950</i>&nbsp;
<b class="nc"><i>4951</i>&nbsp;            if (a == null) {</b>
<b class="nc"><i>4952</i>&nbsp;                a = binding.getDefaultAction();</b>
<b class="nc"><i>4953</i>&nbsp;            }</b>
<i>4954</i>&nbsp;
<b class="nc"><i>4955</i>&nbsp;            if (a != null) {</b>
<b class="nc"><i>4956</i>&nbsp;                ActionEvent ae =</b>
<i>4957</i>&nbsp;                    new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
<i>4958</i>&nbsp;                                    committedText,
<i>4959</i>&nbsp;                                    EventQueue.getMostRecentEventTime(),
<i>4960</i>&nbsp;                                    getCurrentEventModifiers());
<b class="nc"><i>4961</i>&nbsp;                a.actionPerformed(ae);</b>
<b class="nc"><i>4962</i>&nbsp;            }</b>
<b class="nc"><i>4963</i>&nbsp;        }</b>
<b class="nc"><i>4964</i>&nbsp;    }</b>
<i>4965</i>&nbsp;
<i>4966</i>&nbsp;    //
<i>4967</i>&nbsp;    // Sets the caret position according to the passed input method
<i>4968</i>&nbsp;    // event. Also, sets/resets composed text caret appropriately.
<i>4969</i>&nbsp;    //
<i>4970</i>&nbsp;    private void setInputMethodCaretPosition(InputMethodEvent e) {
<b class="nc"><i>4971</i>&nbsp;        int dot;</b>
<i>4972</i>&nbsp;
<i>4973</i>&nbsp;        if (composedTextExists()) {
<i>4974</i>&nbsp;            dot = composedTextStart.getOffset();
<b class="nc"><i>4975</i>&nbsp;            if (!(caret instanceof ComposedTextCaret)) {</b>
<b class="nc"><i>4976</i>&nbsp;                if (composedTextCaret == null) {</b>
<i>4977</i>&nbsp;                    composedTextCaret = new ComposedTextCaret();
<b class="nc"><i>4978</i>&nbsp;                }</b>
<i>4979</i>&nbsp;                originalCaret = caret;
<i>4980</i>&nbsp;                // Sets composed text caret
<i>4981</i>&nbsp;                exchangeCaret(originalCaret, composedTextCaret);
<i>4982</i>&nbsp;            }
<i>4983</i>&nbsp;
<i>4984</i>&nbsp;            TextHitInfo caretPos = e.getCaret();
<b class="nc"><i>4985</i>&nbsp;            if (caretPos != null) {</b>
<i>4986</i>&nbsp;                int index = caretPos.getInsertionIndex();
<i>4987</i>&nbsp;                dot += index;
<i>4988</i>&nbsp;                if (index == 0) {
<i>4989</i>&nbsp;                    // Scroll the component if needed so that the composed text
<i>4990</i>&nbsp;                    // becomes visible.
<b class="nc"><i>4991</i>&nbsp;                    try {</b>
<i>4992</i>&nbsp;                        Rectangle d = modelToView(dot);
<i>4993</i>&nbsp;                        Rectangle end = modelToView(composedTextEnd.getOffset());
<i>4994</i>&nbsp;                        Rectangle b = getBounds();
<i>4995</i>&nbsp;                        d.x += Math.min(end.x - d.x, b.width);
<i>4996</i>&nbsp;                        scrollRectToVisible(d);
<i>4997</i>&nbsp;                    } catch (BadLocationException ble) {}
<b class="nc"><i>4998</i>&nbsp;                }</b>
<i>4999</i>&nbsp;            }
<b class="nc"><i>5000</i>&nbsp;            caret.setDot(dot);</b>
<b class="nc"><i>5001</i>&nbsp;        } else if (caret instanceof ComposedTextCaret) {</b>
<b class="nc"><i>5002</i>&nbsp;            dot = caret.getDot();</b>
<b class="nc"><i>5003</i>&nbsp;            // Restores original caret</b>
<b class="nc"><i>5004</i>&nbsp;            exchangeCaret(caret, originalCaret);</b>
<b class="nc"><i>5005</i>&nbsp;            caret.setDot(dot);</b>
<i>5006</i>&nbsp;        }
<i>5007</i>&nbsp;    }
<b class="nc"><i>5008</i>&nbsp;</b>
<b class="nc"><i>5009</i>&nbsp;    private void exchangeCaret(Caret oldCaret, Caret newCaret) {</b>
<i>5010</i>&nbsp;        int blinkRate = oldCaret.getBlinkRate();
<i>5011</i>&nbsp;        setCaret(newCaret);
<i>5012</i>&nbsp;        caret.setBlinkRate(blinkRate);
<i>5013</i>&nbsp;        caret.setVisible(hasFocus());
<i>5014</i>&nbsp;    }
<i>5015</i>&nbsp;
<i>5016</i>&nbsp;    /**
<b class="nc"><i>5017</i>&nbsp;     * Returns true if KeyEvents should be synthesized from an InputEvent.</b>
<i>5018</i>&nbsp;     */
<b class="nc"><i>5019</i>&nbsp;    private boolean shouldSynthensizeKeyEvents() {</b>
<b class="nc"><i>5020</i>&nbsp;        if (!checkedInputOverride) {</b>
<b class="nc"><i>5021</i>&nbsp;            // Checks whether the client code overrides processInputMethodEvent.</b>
<b class="nc"><i>5022</i>&nbsp;            // If it is overridden, need not to generate KeyTyped events for committed text.</b>
<b class="nc"><i>5023</i>&nbsp;            // If it&#39;s not, behave as an passive input method client.</b>
<i>5024</i>&nbsp;            needToSendKeyTypedEvent = !METHOD_OVERRIDDEN.get(getClass());
<i>5025</i>&nbsp;            checkedInputOverride = true;
<b class="nc"><i>5026</i>&nbsp;        }</b>
<i>5027</i>&nbsp;        return needToSendKeyTypedEvent;
<i>5028</i>&nbsp;    }
<i>5029</i>&nbsp;
<i>5030</i>&nbsp;    //
<i>5031</i>&nbsp;    // Checks whether a composed text in this text component
<i>5032</i>&nbsp;    //
<i>5033</i>&nbsp;    boolean composedTextExists() {
<i>5034</i>&nbsp;        return (composedTextStart != null);
<b class="nc"><i>5035</i>&nbsp;    }</b>
<b class="nc"><i>5036</i>&nbsp;</b>
<b class="nc"><i>5037</i>&nbsp;    //</b>
<b class="nc"><i>5038</i>&nbsp;    // Caret implementation for editing the composed text.</b>
<b class="nc"><i>5039</i>&nbsp;    //</b>
<b class="nc"><i>5040</i>&nbsp;    class ComposedTextCaret extends DefaultCaret implements Serializable {</b>
<i>5041</i>&nbsp;        Color bg;
<i>5042</i>&nbsp;
<b class="nc"><i>5043</i>&nbsp;        //</b>
<b class="nc"><i>5044</i>&nbsp;        // Get the background color of the component</b>
<i>5045</i>&nbsp;        //
<i>5046</i>&nbsp;        public void install(JTextComponent c) {
<i>5047</i>&nbsp;            super.install(c);
<b class="nc"><i>5048</i>&nbsp;</b>
<b class="nc"><i>5049</i>&nbsp;            Document doc = c.getDocument();</b>
<b class="nc"><i>5050</i>&nbsp;            if (doc instanceof StyledDocument) {</b>
<b class="nc"><i>5051</i>&nbsp;                StyledDocument sDoc = (StyledDocument)doc;</b>
<i>5052</i>&nbsp;                Element elem = sDoc.getCharacterElement(c.composedTextStart.getOffset());
<i>5053</i>&nbsp;                AttributeSet attr = elem.getAttributes();
<b class="nc"><i>5054</i>&nbsp;                bg = sDoc.getBackground(attr);</b>
<i>5055</i>&nbsp;            }
<i>5056</i>&nbsp;
<i>5057</i>&nbsp;            if (bg == null) {
<i>5058</i>&nbsp;                bg = c.getBackground();
<i>5059</i>&nbsp;            }
<i>5060</i>&nbsp;        }
<i>5061</i>&nbsp;
<i>5062</i>&nbsp;        //
<i>5063</i>&nbsp;        // Draw caret in XOR mode.
<i>5064</i>&nbsp;        //
<i>5065</i>&nbsp;        public void paint(Graphics g) {
<b class="nc"><i>5066</i>&nbsp;            if(isVisible()) {</b>
<b class="nc"><i>5067</i>&nbsp;                try {</b>
<b class="nc"><i>5068</i>&nbsp;                    Rectangle r = component.modelToView(getDot());</b>
<i>5069</i>&nbsp;                    g.setXORMode(bg);
<i>5070</i>&nbsp;                    g.drawLine(r.x, r.y, r.x, r.y + r.height - 1);
<i>5071</i>&nbsp;                    g.setPaintMode();
<b class="nc"><i>5072</i>&nbsp;                } catch (BadLocationException e) {</b>
<i>5073</i>&nbsp;                    // can&#39;t render I guess
<i>5074</i>&nbsp;                    //System.err.println(&quot;Can&#39;t render cursor&quot;);
<i>5075</i>&nbsp;                }
<i>5076</i>&nbsp;            }
<i>5077</i>&nbsp;        }
<i>5078</i>&nbsp;
<i>5079</i>&nbsp;        //
<i>5080</i>&nbsp;        // If some area other than the composed text is clicked by mouse,
<i>5081</i>&nbsp;        // issue endComposition() to force commit the composed text.
<i>5082</i>&nbsp;        //
<i>5083</i>&nbsp;        protected void positionCaret(MouseEvent me) {
<i>5084</i>&nbsp;            JTextComponent host = component;
<i>5085</i>&nbsp;            Point pt = new Point(me.getX(), me.getY());
<i>5086</i>&nbsp;            int offset = host.viewToModel(pt);
<i>5087</i>&nbsp;            int composedStartIndex = host.composedTextStart.getOffset();
<i>5088</i>&nbsp;            if ((offset &lt; composedStartIndex) ||
<i>5089</i>&nbsp;                (offset &gt; composedTextEnd.getOffset())) {
<i>5090</i>&nbsp;                try {
<i>5091</i>&nbsp;                    // Issue endComposition
<i>5092</i>&nbsp;                    Position newPos = host.getDocument().createPosition(offset);
<i>5093</i>&nbsp;                    host.getInputContext().endComposition();
<i>5094</i>&nbsp;
<i>5095</i>&nbsp;                    // Post a caret positioning runnable to assure that the positioning
<i>5096</i>&nbsp;                    // occurs *after* committing the composed text.
<i>5097</i>&nbsp;                    EventQueue.invokeLater(new DoSetCaretPosition(host, newPos));
<i>5098</i>&nbsp;                } catch (BadLocationException ble) {
<i>5099</i>&nbsp;                    System.err.println(ble);
<i>5100</i>&nbsp;                }
<i>5101</i>&nbsp;            } else {
<i>5102</i>&nbsp;                // Normal processing
<i>5103</i>&nbsp;                super.positionCaret(me);
<i>5104</i>&nbsp;            }
<i>5105</i>&nbsp;        }
<i>5106</i>&nbsp;    }
<i>5107</i>&nbsp;
<i>5108</i>&nbsp;    //
<i>5109</i>&nbsp;    // Runnable class for invokeLater() to set caret position later.
<i>5110</i>&nbsp;    //
<i>5111</i>&nbsp;    private class DoSetCaretPosition implements Runnable {
<i>5112</i>&nbsp;        JTextComponent host;
<i>5113</i>&nbsp;        Position newPos;
<i>5114</i>&nbsp;
<i>5115</i>&nbsp;        DoSetCaretPosition(JTextComponent host, Position newPos) {
<i>5116</i>&nbsp;            this.host = host;
<i>5117</i>&nbsp;            this.newPos = newPos;
<i>5118</i>&nbsp;        }
<i>5119</i>&nbsp;
<i>5120</i>&nbsp;        public void run() {
<i>5121</i>&nbsp;            host.setCaretPosition(newPos.getOffset());
<i>5122</i>&nbsp;        }
<i>5123</i>&nbsp;    }
<i>5124</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
