


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: CompositeView</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.text</a> ]
</div>

<h1>Coverage Summary for Class: CompositeView (javax.swing.text)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CompositeView</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 177)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.text;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.util.*;
<i>28</i>&nbsp;import java.awt.*;
<i>29</i>&nbsp;import javax.swing.event.*;
<i>30</i>&nbsp;import javax.swing.SwingConstants;
<i>31</i>&nbsp;
<i>32</i>&nbsp;/**
<i>33</i>&nbsp; * &lt;code&gt;CompositeView&lt;/code&gt; is an abstract &lt;code&gt;View&lt;/code&gt;
<i>34</i>&nbsp; * implementation which manages one or more child views.
<i>35</i>&nbsp; * (Note that &lt;code&gt;CompositeView&lt;/code&gt; is intended
<i>36</i>&nbsp; * for managing relatively small numbers of child views.)
<i>37</i>&nbsp; * &lt;code&gt;CompositeView&lt;/code&gt; is intended to be used as
<i>38</i>&nbsp; * a starting point for &lt;code&gt;View&lt;/code&gt; implementations,
<i>39</i>&nbsp; * such as &lt;code&gt;BoxView&lt;/code&gt;, that will contain child
<i>40</i>&nbsp; * &lt;code&gt;View&lt;/code&gt;s. Subclasses that wish to manage the
<i>41</i>&nbsp; * collection of child &lt;code&gt;View&lt;/code&gt;s should use the
<i>42</i>&nbsp; * {@link #replace} method.  As &lt;code&gt;View&lt;/code&gt; invokes
<i>43</i>&nbsp; * &lt;code&gt;replace&lt;/code&gt; during &lt;code&gt;DocumentListener&lt;/code&gt;
<i>44</i>&nbsp; * notification, you normally won&#39;t need to directly
<i>45</i>&nbsp; * invoke &lt;code&gt;replace&lt;/code&gt;.
<i>46</i>&nbsp; *
<i>47</i>&nbsp; * &lt;p&gt;While &lt;code&gt;CompositeView&lt;/code&gt;
<i>48</i>&nbsp; * does not impose a layout policy on its child &lt;code&gt;View&lt;/code&gt;s,
<i>49</i>&nbsp; * it does allow for inseting the child &lt;code&gt;View&lt;/code&gt;s
<i>50</i>&nbsp; * it will contain.  The insets can be set by either
<i>51</i>&nbsp; * {@link #setInsets} or {@link #setParagraphInsets}.
<i>52</i>&nbsp; *
<i>53</i>&nbsp; * &lt;p&gt;In addition to the abstract methods of
<i>54</i>&nbsp; * {@link javax.swing.text.View},
<i>55</i>&nbsp; * subclasses of &lt;code&gt;CompositeView&lt;/code&gt; will need to
<i>56</i>&nbsp; * override:
<i>57</i>&nbsp; * &lt;ul&gt;
<i>58</i>&nbsp; * &lt;li&gt;{@link #isBefore} - Used to test if a given
<i>59</i>&nbsp; *     &lt;code&gt;View&lt;/code&gt; location is before the visual space
<i>60</i>&nbsp; *     of the &lt;code&gt;CompositeView&lt;/code&gt;.
<i>61</i>&nbsp; * &lt;li&gt;{@link #isAfter} - Used to test if a given
<i>62</i>&nbsp; *     &lt;code&gt;View&lt;/code&gt; location is after the visual space
<i>63</i>&nbsp; *     of the &lt;code&gt;CompositeView&lt;/code&gt;.
<i>64</i>&nbsp; * &lt;li&gt;{@link #getViewAtPoint} - Returns the view at
<i>65</i>&nbsp; *     a given visual location.
<i>66</i>&nbsp; * &lt;li&gt;{@link #childAllocation} - Returns the bounds of
<i>67</i>&nbsp; *     a particular child &lt;code&gt;View&lt;/code&gt;.
<i>68</i>&nbsp; *     &lt;code&gt;getChildAllocation&lt;/code&gt; will invoke
<i>69</i>&nbsp; *     &lt;code&gt;childAllocation&lt;/code&gt; after offseting
<i>70</i>&nbsp; *     the bounds by the &lt;code&gt;Inset&lt;/code&gt;s of the
<i>71</i>&nbsp; *     &lt;code&gt;CompositeView&lt;/code&gt;.
<i>72</i>&nbsp; * &lt;/ul&gt;
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * @author  Timothy Prinzing
<i>75</i>&nbsp; */
<i>76</i>&nbsp;public abstract class CompositeView extends View {
<i>77</i>&nbsp;
<i>78</i>&nbsp;    /**
<i>79</i>&nbsp;     * Constructs a &lt;code&gt;CompositeView&lt;/code&gt; for the given element.
<i>80</i>&nbsp;     *
<i>81</i>&nbsp;     * @param elem  the element this view is responsible for
<i>82</i>&nbsp;     */
<i>83</i>&nbsp;    public CompositeView(Element elem) {
<b class="nc"><i>84</i>&nbsp;        super(elem);</b>
<b class="nc"><i>85</i>&nbsp;        children = new View[1];</b>
<b class="nc"><i>86</i>&nbsp;        nchildren = 0;</b>
<b class="nc"><i>87</i>&nbsp;        childAlloc = new Rectangle();</b>
<i>88</i>&nbsp;    }
<i>89</i>&nbsp;
<i>90</i>&nbsp;    /**
<i>91</i>&nbsp;     * Loads all of the children to initialize the view.
<i>92</i>&nbsp;     * This is called by the {@link #setParent}
<i>93</i>&nbsp;     * method.  Subclasses can reimplement this to initialize
<i>94</i>&nbsp;     * their child views in a different manner.  The default
<i>95</i>&nbsp;     * implementation creates a child view for each
<i>96</i>&nbsp;     * child element.
<i>97</i>&nbsp;     *
<i>98</i>&nbsp;     * @param f the view factory
<i>99</i>&nbsp;     * @see #setParent
<i>100</i>&nbsp;     */
<i>101</i>&nbsp;    protected void loadChildren(ViewFactory f) {
<b class="nc"><i>102</i>&nbsp;        if (f == null) {</b>
<i>103</i>&nbsp;            // No factory. This most likely indicates the parent view
<i>104</i>&nbsp;            // has changed out from under us, bail!
<i>105</i>&nbsp;            return;
<i>106</i>&nbsp;        }
<b class="nc"><i>107</i>&nbsp;        Element e = getElement();</b>
<b class="nc"><i>108</i>&nbsp;        int n = e.getElementCount();</b>
<b class="nc"><i>109</i>&nbsp;        if (n &gt; 0) {</b>
<b class="nc"><i>110</i>&nbsp;            View[] added = new View[n];</b>
<b class="nc"><i>111</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<b class="nc"><i>112</i>&nbsp;                added[i] = f.create(e.getElement(i));</b>
<i>113</i>&nbsp;            }
<b class="nc"><i>114</i>&nbsp;            replace(0, 0, added);</b>
<i>115</i>&nbsp;        }
<i>116</i>&nbsp;    }
<i>117</i>&nbsp;
<i>118</i>&nbsp;    // --- View methods ---------------------------------------------
<i>119</i>&nbsp;
<i>120</i>&nbsp;    /**
<i>121</i>&nbsp;     * Sets the parent of the view.
<i>122</i>&nbsp;     * This is reimplemented to provide the superclass
<i>123</i>&nbsp;     * behavior as well as calling the &lt;code&gt;loadChildren&lt;/code&gt;
<i>124</i>&nbsp;     * method if this view does not already have children.
<i>125</i>&nbsp;     * The children should not be loaded in the
<i>126</i>&nbsp;     * constructor because the act of setting the parent
<i>127</i>&nbsp;     * may cause them to try to search up the hierarchy
<i>128</i>&nbsp;     * (to get the hosting &lt;code&gt;Container&lt;/code&gt; for example).
<i>129</i>&nbsp;     * If this view has children (the view is being moved
<i>130</i>&nbsp;     * from one place in the view hierarchy to another),
<i>131</i>&nbsp;     * the &lt;code&gt;loadChildren&lt;/code&gt; method will not be called.
<i>132</i>&nbsp;     *
<i>133</i>&nbsp;     * @param parent the parent of the view, &lt;code&gt;null&lt;/code&gt; if none
<i>134</i>&nbsp;     */
<i>135</i>&nbsp;    public void setParent(View parent) {
<b class="nc"><i>136</i>&nbsp;        super.setParent(parent);</b>
<b class="nc"><i>137</i>&nbsp;        if ((parent != null) &amp;&amp; (nchildren == 0)) {</b>
<b class="nc"><i>138</i>&nbsp;            ViewFactory f = getViewFactory();</b>
<b class="nc"><i>139</i>&nbsp;            loadChildren(f);</b>
<i>140</i>&nbsp;        }
<i>141</i>&nbsp;    }
<i>142</i>&nbsp;
<i>143</i>&nbsp;    /**
<i>144</i>&nbsp;     * Returns the number of child views of this view.
<i>145</i>&nbsp;     *
<i>146</i>&nbsp;     * @return the number of views &amp;gt;= 0
<i>147</i>&nbsp;     * @see #getView
<i>148</i>&nbsp;     */
<i>149</i>&nbsp;    public int getViewCount() {
<b class="nc"><i>150</i>&nbsp;        return nchildren;</b>
<i>151</i>&nbsp;    }
<i>152</i>&nbsp;
<i>153</i>&nbsp;    /**
<i>154</i>&nbsp;     * Returns the n-th view in this container.
<i>155</i>&nbsp;     *
<i>156</i>&nbsp;     * @param n the number of the desired view, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
<i>157</i>&nbsp;     * @return the view at index &lt;code&gt;n&lt;/code&gt;
<i>158</i>&nbsp;     */
<i>159</i>&nbsp;    public View getView(int n) {
<b class="nc"><i>160</i>&nbsp;        return children[n];</b>
<i>161</i>&nbsp;    }
<i>162</i>&nbsp;
<i>163</i>&nbsp;    /**
<i>164</i>&nbsp;     * Replaces child views.  If there are no views to remove
<i>165</i>&nbsp;     * this acts as an insert.  If there are no views to
<i>166</i>&nbsp;     * add this acts as a remove.  Views being removed will
<i>167</i>&nbsp;     * have the parent set to &lt;code&gt;null&lt;/code&gt;,
<i>168</i>&nbsp;     * and the internal reference to them removed so that they
<i>169</i>&nbsp;     * may be garbage collected.
<i>170</i>&nbsp;     *
<i>171</i>&nbsp;     * @param offset the starting index into the child views to insert
<i>172</i>&nbsp;     *   the new views; &amp;gt;= 0 and &amp;lt;= getViewCount
<i>173</i>&nbsp;     * @param length the number of existing child views to remove;
<i>174</i>&nbsp;     *   this should be a value &amp;gt;= 0 and &amp;lt;= (getViewCount() - offset)
<i>175</i>&nbsp;     * @param views the child views to add; this value can be
<i>176</i>&nbsp;     *  &lt;code&gt;null&lt;/code&gt;
<i>177</i>&nbsp;     *   to indicate no children are being added (useful to remove)
<i>178</i>&nbsp;     */
<i>179</i>&nbsp;    public void replace(int offset, int length, View[] views) {
<i>180</i>&nbsp;        // make sure an array exists
<b class="nc"><i>181</i>&nbsp;        if (views == null) {</b>
<b class="nc"><i>182</i>&nbsp;            views = ZERO;</b>
<i>183</i>&nbsp;        }
<i>184</i>&nbsp;
<i>185</i>&nbsp;        Set&lt;View&gt; set = new HashSet&lt;&gt;(Arrays.asList(views));
<b class="nc"><i>186</i>&nbsp;        // update parent reference on removed views</b>
<b class="nc"><i>187</i>&nbsp;        for (int i = offset; i &lt; offset + length; i++) {</b>
<i>188</i>&nbsp;            View child = children[i];
<i>189</i>&nbsp;            if (child.getParent() == this &amp;&amp; !set.contains(child)) {
<b class="nc"><i>190</i>&nbsp;                // in FlowView.java view might be referenced</b>
<i>191</i>&nbsp;                // from two super-views as a child. see logicalView
<b class="nc"><i>192</i>&nbsp;                children[i].setParent(null);</b>
<i>193</i>&nbsp;            }
<i>194</i>&nbsp;            children[i] = null;
<i>195</i>&nbsp;        }
<b class="nc"><i>196</i>&nbsp;</b>
<b class="nc"><i>197</i>&nbsp;        // update the array</b>
<b class="nc"><i>198</i>&nbsp;        int delta = views.length - length;</b>
<b class="nc"><i>199</i>&nbsp;        int src = offset + length;</b>
<b class="nc"><i>200</i>&nbsp;        int nmove = nchildren - src;</b>
<i>201</i>&nbsp;        int dest = src + delta;
<b class="nc"><i>202</i>&nbsp;        if ((nchildren + delta) &gt;= children.length) {</b>
<b class="nc"><i>203</i>&nbsp;            // need to grow the array</b>
<b class="nc"><i>204</i>&nbsp;            int newLength = Math.max(2*children.length, nchildren + delta);</b>
<b class="nc"><i>205</i>&nbsp;            View[] newChildren = new View[newLength];</b>
<b class="nc"><i>206</i>&nbsp;            System.arraycopy(children, 0, newChildren, 0, offset);</b>
<b class="nc"><i>207</i>&nbsp;            System.arraycopy(views, 0, newChildren, offset, views.length);</b>
<b class="nc"><i>208</i>&nbsp;            System.arraycopy(children, src, newChildren, dest, nmove);</b>
<i>209</i>&nbsp;            children = newChildren;
<b class="nc"><i>210</i>&nbsp;        } else {</b>
<b class="nc"><i>211</i>&nbsp;            // patch the existing array</b>
<i>212</i>&nbsp;            System.arraycopy(children, src, children, dest, nmove);
<b class="nc"><i>213</i>&nbsp;            System.arraycopy(views, 0, children, offset, views.length);</b>
<i>214</i>&nbsp;        }
<i>215</i>&nbsp;        nchildren = nchildren + delta;
<b class="nc"><i>216</i>&nbsp;</b>
<b class="nc"><i>217</i>&nbsp;        // update parent reference on added views</b>
<i>218</i>&nbsp;        for (int i = 0; i &lt; views.length; i++) {
<i>219</i>&nbsp;            views[i].setParent(this);
<i>220</i>&nbsp;        }
<i>221</i>&nbsp;    }
<i>222</i>&nbsp;
<i>223</i>&nbsp;    /**
<i>224</i>&nbsp;     * Fetches the allocation for the given child view to
<i>225</i>&nbsp;     * render into. This enables finding out where various views
<i>226</i>&nbsp;     * are located.
<i>227</i>&nbsp;     *
<i>228</i>&nbsp;     * @param index the index of the child, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
<i>229</i>&nbsp;     * @param a  the allocation to this view
<i>230</i>&nbsp;     * @return the allocation to the child
<b class="nc"><i>231</i>&nbsp;     */</b>
<b class="nc"><i>232</i>&nbsp;    public Shape getChildAllocation(int index, Shape a) {</b>
<b class="nc"><i>233</i>&nbsp;        Rectangle alloc = getInsideAllocation(a);</b>
<i>234</i>&nbsp;        childAllocation(index, alloc);
<i>235</i>&nbsp;        return alloc;
<i>236</i>&nbsp;    }
<i>237</i>&nbsp;
<i>238</i>&nbsp;    /**
<i>239</i>&nbsp;     * Provides a mapping from the document model coordinate space
<i>240</i>&nbsp;     * to the coordinate space of the view mapped to it.
<i>241</i>&nbsp;     *
<i>242</i>&nbsp;     * @param pos the position to convert &amp;gt;= 0
<i>243</i>&nbsp;     * @param a the allocated region to render into
<i>244</i>&nbsp;     * @param b a bias value of either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
<i>245</i>&nbsp;     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>246</i>&nbsp;     * @return the bounding box of the given position
<i>247</i>&nbsp;     * @exception BadLocationException  if the given position does
<i>248</i>&nbsp;     *   not represent a valid location in the associated document
<i>249</i>&nbsp;     * @see View#modelToView
<b class="nc"><i>250</i>&nbsp;     */</b>
<b class="nc"><i>251</i>&nbsp;    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {</b>
<b class="nc"><i>252</i>&nbsp;        boolean isBackward = (b == Position.Bias.Backward);</b>
<b class="nc"><i>253</i>&nbsp;        int testPos = (isBackward) ? Math.max(0, pos - 1) : pos;</b>
<i>254</i>&nbsp;        if(isBackward &amp;&amp; testPos &lt; getStartOffset()) {
<b class="nc"><i>255</i>&nbsp;            return null;</b>
<b class="nc"><i>256</i>&nbsp;        }</b>
<b class="nc"><i>257</i>&nbsp;        int vIndex = getViewIndexAtPosition(testPos);</b>
<b class="nc"><i>258</i>&nbsp;        if ((vIndex != -1) &amp;&amp; (vIndex &lt; getViewCount())) {</b>
<b class="nc"><i>259</i>&nbsp;            View v = getView(vIndex);</b>
<b class="nc"><i>260</i>&nbsp;            if(v != null &amp;&amp; testPos &gt;= v.getStartOffset() &amp;&amp;</b>
<b class="nc"><i>261</i>&nbsp;               testPos &lt; v.getEndOffset()) {</b>
<i>262</i>&nbsp;                Shape childShape = getChildAllocation(vIndex, a);
<b class="nc"><i>263</i>&nbsp;                if (childShape == null) {</b>
<i>264</i>&nbsp;                    // We are likely invalid, fail.
<b class="nc"><i>265</i>&nbsp;                    return null;</b>
<b class="nc"><i>266</i>&nbsp;                }</b>
<b class="nc"><i>267</i>&nbsp;                Shape retShape = v.modelToView(pos, childShape, b);</b>
<b class="nc"><i>268</i>&nbsp;                if(retShape == null &amp;&amp; v.getEndOffset() == pos) {</b>
<b class="nc"><i>269</i>&nbsp;                    if(++vIndex &lt; getViewCount()) {</b>
<i>270</i>&nbsp;                        v = getView(vIndex);
<i>271</i>&nbsp;                        retShape = v.modelToView(pos, getChildAllocation(vIndex, a), b);
<b class="nc"><i>272</i>&nbsp;                    }</b>
<i>273</i>&nbsp;                }
<i>274</i>&nbsp;                return retShape;
<b class="nc"><i>275</i>&nbsp;            }</b>
<i>276</i>&nbsp;        }
<i>277</i>&nbsp;        throw new BadLocationException(&quot;Position not represented by view&quot;,
<i>278</i>&nbsp;                                       pos);
<i>279</i>&nbsp;    }
<i>280</i>&nbsp;
<i>281</i>&nbsp;    /**
<i>282</i>&nbsp;     * Provides a mapping from the document model coordinate space
<i>283</i>&nbsp;     * to the coordinate space of the view mapped to it.
<i>284</i>&nbsp;     *
<i>285</i>&nbsp;     * @param p0 the position to convert &amp;gt;= 0
<i>286</i>&nbsp;     * @param b0 the bias toward the previous character or the
<i>287</i>&nbsp;     *  next character represented by p0, in case the
<i>288</i>&nbsp;     *  position is a boundary of two views; either
<i>289</i>&nbsp;     *  &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
<i>290</i>&nbsp;     *  &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>291</i>&nbsp;     * @param p1 the position to convert &amp;gt;= 0
<i>292</i>&nbsp;     * @param b1 the bias toward the previous character or the
<i>293</i>&nbsp;     *  next character represented by p1, in case the
<i>294</i>&nbsp;     *  position is a boundary of two views
<i>295</i>&nbsp;     * @param a the allocated region to render into
<i>296</i>&nbsp;     * @return the bounding box of the given position is returned
<i>297</i>&nbsp;     * @exception BadLocationException  if the given position does
<i>298</i>&nbsp;     *   not represent a valid location in the associated document
<i>299</i>&nbsp;     * @exception IllegalArgumentException for an invalid bias argument
<i>300</i>&nbsp;     * @see View#viewToModel
<b class="nc"><i>301</i>&nbsp;     */</b>
<b class="nc"><i>302</i>&nbsp;    public Shape modelToView(int p0, Position.Bias b0, int p1, Position.Bias b1, Shape a) throws BadLocationException {</b>
<i>303</i>&nbsp;        if (p0 == getStartOffset() &amp;&amp; p1 == getEndOffset()) {
<b class="nc"><i>304</i>&nbsp;            return a;</b>
<b class="nc"><i>305</i>&nbsp;        }</b>
<b class="nc"><i>306</i>&nbsp;        Rectangle alloc = getInsideAllocation(a);</b>
<b class="nc"><i>307</i>&nbsp;        Rectangle r0 = new Rectangle(alloc);</b>
<b class="nc"><i>308</i>&nbsp;        View v0 = getViewAtPosition((b0 == Position.Bias.Backward) ?</b>
<b class="nc"><i>309</i>&nbsp;                                    Math.max(0, p0 - 1) : p0, r0);</b>
<b class="nc"><i>310</i>&nbsp;        Rectangle r1 = new Rectangle(alloc);</b>
<b class="nc"><i>311</i>&nbsp;        View v1 = getViewAtPosition((b1 == Position.Bias.Backward) ?</b>
<b class="nc"><i>312</i>&nbsp;                                    Math.max(0, p1 - 1) : p1, r1);</b>
<b class="nc"><i>313</i>&nbsp;        if (v0 == v1) {</b>
<i>314</i>&nbsp;            if (v0 == null) {
<i>315</i>&nbsp;                return a;
<b class="nc"><i>316</i>&nbsp;            }</b>
<i>317</i>&nbsp;            // Range contained in one view
<i>318</i>&nbsp;            return v0.modelToView(p0, b0, p1, b1, r0);
<b class="nc"><i>319</i>&nbsp;        }</b>
<b class="nc"><i>320</i>&nbsp;        // Straddles some views.</b>
<b class="nc"><i>321</i>&nbsp;        int viewCount = getViewCount();</b>
<i>322</i>&nbsp;        int counter = 0;
<i>323</i>&nbsp;        while (counter &lt; viewCount) {
<i>324</i>&nbsp;            View v;
<i>325</i>&nbsp;            // Views may not be in same order as model.
<b class="nc"><i>326</i>&nbsp;            // v0 or v1 may be null if there is a gap in the range this</b>
<i>327</i>&nbsp;            // view contains.
<i>328</i>&nbsp;            if ((v = getView(counter)) == v0 || v == v1) {
<b class="nc"><i>329</i>&nbsp;                View endView;</b>
<b class="nc"><i>330</i>&nbsp;                Rectangle retRect;</b>
<b class="nc"><i>331</i>&nbsp;                Rectangle tempRect = new Rectangle();</b>
<i>332</i>&nbsp;                if (v == v0) {
<b class="nc"><i>333</i>&nbsp;                    retRect = v0.modelToView(p0, b0, v0.getEndOffset(),</b>
<b class="nc"><i>334</i>&nbsp;                                             Position.Bias.Backward, r0).</b>
<i>335</i>&nbsp;                              getBounds();
<i>336</i>&nbsp;                    endView = v1;
<b class="nc"><i>337</i>&nbsp;                }</b>
<i>338</i>&nbsp;                else {
<b class="nc"><i>339</i>&nbsp;                    retRect = v1.modelToView(v1.getStartOffset(),</b>
<b class="nc"><i>340</i>&nbsp;                                             Position.Bias.Forward,</b>
<i>341</i>&nbsp;                                             p1, b1, r1).getBounds();
<i>342</i>&nbsp;                    endView = v0;
<i>343</i>&nbsp;                }
<b class="nc"><i>344</i>&nbsp;</b>
<b class="nc"><i>345</i>&nbsp;                // Views entirely covered by range.</b>
<b class="nc"><i>346</i>&nbsp;                while (++counter &lt; viewCount &amp;&amp;</b>
<b class="nc"><i>347</i>&nbsp;                       (v = getView(counter)) != endView) {</b>
<b class="nc"><i>348</i>&nbsp;                    tempRect.setBounds(alloc);</b>
<i>349</i>&nbsp;                    childAllocation(counter, tempRect);
<i>350</i>&nbsp;                    retRect.add(tempRect);
<i>351</i>&nbsp;                }
<b class="nc"><i>352</i>&nbsp;</b>
<i>353</i>&nbsp;                // End view.
<b class="nc"><i>354</i>&nbsp;                if (endView != null) {</b>
<b class="nc"><i>355</i>&nbsp;                    Shape endShape;</b>
<i>356</i>&nbsp;                    if (endView == v1) {
<i>357</i>&nbsp;                        endShape = v1.modelToView(v1.getStartOffset(),
<i>358</i>&nbsp;                                                  Position.Bias.Forward,
<i>359</i>&nbsp;                                                  p1, b1, r1);
<b class="nc"><i>360</i>&nbsp;                    }</b>
<i>361</i>&nbsp;                    else {
<i>362</i>&nbsp;                        endShape = v0.modelToView(p0, b0, v0.getEndOffset(),
<b class="nc"><i>363</i>&nbsp;                                                  Position.Bias.Backward, r0);</b>
<b class="nc"><i>364</i>&nbsp;                    }</b>
<i>365</i>&nbsp;                    if (endShape instanceof Rectangle) {
<i>366</i>&nbsp;                        retRect.add((Rectangle)endShape);
<b class="nc"><i>367</i>&nbsp;                    }</b>
<i>368</i>&nbsp;                    else {
<i>369</i>&nbsp;                        retRect.add(endShape.getBounds());
<b class="nc"><i>370</i>&nbsp;                    }</b>
<i>371</i>&nbsp;                }
<b class="nc"><i>372</i>&nbsp;                return retRect;</b>
<b class="nc"><i>373</i>&nbsp;            }</b>
<b class="nc"><i>374</i>&nbsp;            counter++;</b>
<i>375</i>&nbsp;        }
<i>376</i>&nbsp;        throw new BadLocationException(&quot;Position not represented by view&quot;, p0);
<i>377</i>&nbsp;    }
<i>378</i>&nbsp;
<i>379</i>&nbsp;    /**
<i>380</i>&nbsp;     * Provides a mapping from the view coordinate space to the logical
<i>381</i>&nbsp;     * coordinate space of the model.
<i>382</i>&nbsp;     *
<i>383</i>&nbsp;     * @param x   x coordinate of the view location to convert &amp;gt;= 0
<i>384</i>&nbsp;     * @param y   y coordinate of the view location to convert &amp;gt;= 0
<i>385</i>&nbsp;     * @param a the allocated region to render into
<i>386</i>&nbsp;     * @param bias either &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
<i>387</i>&nbsp;     *  &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>388</i>&nbsp;     * @return the location within the model that best represents the
<i>389</i>&nbsp;     *  given point in the view &amp;gt;= 0
<i>390</i>&nbsp;     * @see View#viewToModel
<b class="nc"><i>391</i>&nbsp;     */</b>
<b class="nc"><i>392</i>&nbsp;    public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {</b>
<i>393</i>&nbsp;        Rectangle alloc = getInsideAllocation(a);
<b class="nc"><i>394</i>&nbsp;        if (isBefore((int) x, (int) y, alloc)) {</b>
<i>395</i>&nbsp;            // point is before the range represented
<i>396</i>&nbsp;            int retValue = -1;
<b class="nc"><i>397</i>&nbsp;</b>
<i>398</i>&nbsp;            try {
<b class="nc"><i>399</i>&nbsp;                retValue = getNextVisualPositionFrom(-1, Position.Bias.Forward,</b>
<b class="nc"><i>400</i>&nbsp;                                                     a, EAST, bias);</b>
<b class="nc"><i>401</i>&nbsp;            } catch (BadLocationException ble) { }</b>
<b class="nc"><i>402</i>&nbsp;            catch (IllegalArgumentException iae) { }</b>
<b class="nc"><i>403</i>&nbsp;            if(retValue == -1) {</b>
<i>404</i>&nbsp;                retValue = getStartOffset();
<b class="nc"><i>405</i>&nbsp;                bias[0] = Position.Bias.Forward;</b>
<b class="nc"><i>406</i>&nbsp;            }</b>
<i>407</i>&nbsp;            return retValue;
<b class="nc"><i>408</i>&nbsp;        } else if (isAfter((int) x, (int) y, alloc)) {</b>
<i>409</i>&nbsp;            // point is after the range represented.
<b class="nc"><i>410</i>&nbsp;            int retValue = -1;</b>
<i>411</i>&nbsp;            try {
<b class="nc"><i>412</i>&nbsp;                retValue = getNextVisualPositionFrom(-1, Position.Bias.Forward,</b>
<b class="nc"><i>413</i>&nbsp;                                                     a, WEST, bias);</b>
<i>414</i>&nbsp;            } catch (BadLocationException ble) { }
<b class="nc"><i>415</i>&nbsp;            catch (IllegalArgumentException iae) { }</b>
<i>416</i>&nbsp;
<b class="nc"><i>417</i>&nbsp;            if(retValue == -1) {</b>
<b class="nc"><i>418</i>&nbsp;                // NOTE: this could actually use end offset with backward.</b>
<i>419</i>&nbsp;                retValue = getEndOffset() - 1;
<b class="nc"><i>420</i>&nbsp;                bias[0] = Position.Bias.Forward;</b>
<i>421</i>&nbsp;            }
<i>422</i>&nbsp;            return retValue;
<b class="nc"><i>423</i>&nbsp;        } else {</b>
<b class="nc"><i>424</i>&nbsp;            // locate the child and pass along the request</b>
<b class="nc"><i>425</i>&nbsp;            View v = getViewAtPoint((int) x, (int) y, alloc);</b>
<i>426</i>&nbsp;            if (v != null) {
<i>427</i>&nbsp;              return v.viewToModel(x, y, alloc, bias);
<b class="nc"><i>428</i>&nbsp;            }</b>
<i>429</i>&nbsp;        }
<i>430</i>&nbsp;        return -1;
<i>431</i>&nbsp;    }
<i>432</i>&nbsp;
<i>433</i>&nbsp;    /**
<i>434</i>&nbsp;     * Provides a way to determine the next visually represented model
<i>435</i>&nbsp;     * location that one might place a caret.  Some views may not be visible,
<i>436</i>&nbsp;     * they might not be in the same order found in the model, or they just
<i>437</i>&nbsp;     * might not allow access to some of the locations in the model.
<i>438</i>&nbsp;     * This is a convenience method for {@link #getNextNorthSouthVisualPositionFrom}
<i>439</i>&nbsp;     * and {@link #getNextEastWestVisualPositionFrom}.
<i>440</i>&nbsp;     * This method enables specifying a position to convert
<i>441</i>&nbsp;     * within the range of &amp;gt;=0.  If the value is -1, a position
<i>442</i>&nbsp;     * will be calculated automatically.  If the value &amp;lt; -1,
<i>443</i>&nbsp;     * the {@code BadLocationException} will be thrown.
<i>444</i>&nbsp;     *
<i>445</i>&nbsp;     * @param pos the position to convert
<i>446</i>&nbsp;     * @param b a bias value of either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
<i>447</i>&nbsp;     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>448</i>&nbsp;     * @param a the allocated region to render into
<i>449</i>&nbsp;     * @param direction the direction from the current position that can
<i>450</i>&nbsp;     *  be thought of as the arrow keys typically found on a keyboard;
<i>451</i>&nbsp;     *  this may be one of the following:
<i>452</i>&nbsp;     *  &lt;ul&gt;
<i>453</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.WEST&lt;/code&gt;
<i>454</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.EAST&lt;/code&gt;
<i>455</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
<i>456</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
<i>457</i>&nbsp;     *  &lt;/ul&gt;
<i>458</i>&nbsp;     * @param biasRet an array containing the bias that was checked
<i>459</i>&nbsp;     * @return the location within the model that best represents the next
<i>460</i>&nbsp;     *  location visual position
<i>461</i>&nbsp;     * @exception BadLocationException the given position is not a valid
<i>462</i>&nbsp;     *                                 position within the document
<i>463</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
<i>464</i>&nbsp;     */
<i>465</i>&nbsp;    public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,
<b class="nc"><i>466</i>&nbsp;                                         int direction, Position.Bias[] biasRet)</b>
<b class="nc"><i>467</i>&nbsp;      throws BadLocationException {</b>
<i>468</i>&nbsp;        if (pos &lt; -1 || pos &gt; getDocument().getLength()) {
<b class="nc"><i>469</i>&nbsp;            throw new BadLocationException(&quot;invalid position&quot;, pos);</b>
<i>470</i>&nbsp;        }
<b class="nc"><i>471</i>&nbsp;        Rectangle alloc = getInsideAllocation(a);</b>
<i>472</i>&nbsp;
<b class="nc"><i>473</i>&nbsp;        switch (direction) {</b>
<i>474</i>&nbsp;        case NORTH:
<i>475</i>&nbsp;            return getNextNorthSouthVisualPositionFrom(pos, b, a, direction,
<b class="nc"><i>476</i>&nbsp;                                                       biasRet);</b>
<i>477</i>&nbsp;        case SOUTH:
<i>478</i>&nbsp;            return getNextNorthSouthVisualPositionFrom(pos, b, a, direction,
<b class="nc"><i>479</i>&nbsp;                                                       biasRet);</b>
<i>480</i>&nbsp;        case EAST:
<i>481</i>&nbsp;            return getNextEastWestVisualPositionFrom(pos, b, a, direction,
<b class="nc"><i>482</i>&nbsp;                                                     biasRet);</b>
<i>483</i>&nbsp;        case WEST:
<i>484</i>&nbsp;            return getNextEastWestVisualPositionFrom(pos, b, a, direction,
<b class="nc"><i>485</i>&nbsp;                                                     biasRet);</b>
<i>486</i>&nbsp;        default:
<i>487</i>&nbsp;            throw new IllegalArgumentException(&quot;Bad direction: &quot; + direction);
<i>488</i>&nbsp;        }
<i>489</i>&nbsp;    }
<i>490</i>&nbsp;
<i>491</i>&nbsp;    /**
<i>492</i>&nbsp;     * Returns the child view index representing the given
<i>493</i>&nbsp;     * position in the model.  This is implemented to call the
<i>494</i>&nbsp;     * &lt;code&gt;getViewIndexByPosition&lt;/code&gt;
<i>495</i>&nbsp;     * method for backward compatibility.
<i>496</i>&nbsp;     *
<i>497</i>&nbsp;     * @param pos the position &amp;gt;= 0
<i>498</i>&nbsp;     * @return  index of the view representing the given position, or
<i>499</i>&nbsp;     *   -1 if no view represents that position
<i>500</i>&nbsp;     * @since 1.3
<b class="nc"><i>501</i>&nbsp;     */</b>
<b class="nc"><i>502</i>&nbsp;    public int getViewIndex(int pos, Position.Bias b) {</b>
<i>503</i>&nbsp;        if(b == Position.Bias.Backward) {
<b class="nc"><i>504</i>&nbsp;            pos -= 1;</b>
<b class="nc"><i>505</i>&nbsp;        }</b>
<i>506</i>&nbsp;        if ((pos &gt;= getStartOffset()) &amp;&amp; (pos &lt; getEndOffset())) {
<b class="nc"><i>507</i>&nbsp;            return getViewIndexAtPosition(pos);</b>
<i>508</i>&nbsp;        }
<i>509</i>&nbsp;        return -1;
<i>510</i>&nbsp;    }
<i>511</i>&nbsp;
<i>512</i>&nbsp;    // --- local methods ----------------------------------------------------
<i>513</i>&nbsp;
<i>514</i>&nbsp;
<i>515</i>&nbsp;    /**
<i>516</i>&nbsp;     * Tests whether a point lies before the rectangle range.
<i>517</i>&nbsp;     *
<i>518</i>&nbsp;     * @param x the X coordinate &amp;gt;= 0
<i>519</i>&nbsp;     * @param y the Y coordinate &amp;gt;= 0
<i>520</i>&nbsp;     * @param alloc the rectangle
<i>521</i>&nbsp;     * @return true if the point is before the specified range
<i>522</i>&nbsp;     */
<i>523</i>&nbsp;    protected abstract boolean isBefore(int x, int y, Rectangle alloc);
<i>524</i>&nbsp;
<i>525</i>&nbsp;    /**
<i>526</i>&nbsp;     * Tests whether a point lies after the rectangle range.
<i>527</i>&nbsp;     *
<i>528</i>&nbsp;     * @param x the X coordinate &amp;gt;= 0
<i>529</i>&nbsp;     * @param y the Y coordinate &amp;gt;= 0
<i>530</i>&nbsp;     * @param alloc the rectangle
<i>531</i>&nbsp;     * @return true if the point is after the specified range
<i>532</i>&nbsp;     */
<i>533</i>&nbsp;    protected abstract boolean isAfter(int x, int y, Rectangle alloc);
<i>534</i>&nbsp;
<i>535</i>&nbsp;    /**
<i>536</i>&nbsp;     * Fetches the child view at the given coordinates.
<i>537</i>&nbsp;     *
<i>538</i>&nbsp;     * @param x the X coordinate &amp;gt;= 0
<i>539</i>&nbsp;     * @param y the Y coordinate &amp;gt;= 0
<i>540</i>&nbsp;     * @param alloc the parent&#39;s allocation on entry, which should
<i>541</i>&nbsp;     *   be changed to the child&#39;s allocation on exit
<i>542</i>&nbsp;     * @return the child view
<i>543</i>&nbsp;     */
<i>544</i>&nbsp;    protected abstract View getViewAtPoint(int x, int y, Rectangle alloc);
<i>545</i>&nbsp;
<i>546</i>&nbsp;    /**
<i>547</i>&nbsp;     * Returns the allocation for a given child.
<i>548</i>&nbsp;     *
<i>549</i>&nbsp;     * @param index the index of the child, &amp;gt;= 0 &amp;amp;&amp;amp; &amp;lt; getViewCount()
<i>550</i>&nbsp;     * @param a  the allocation to the interior of the box on entry,
<i>551</i>&nbsp;     *   and the allocation of the child view at the index on exit.
<i>552</i>&nbsp;     */
<i>553</i>&nbsp;    protected abstract void childAllocation(int index, Rectangle a);
<i>554</i>&nbsp;
<i>555</i>&nbsp;    /**
<i>556</i>&nbsp;     * Fetches the child view that represents the given position in
<i>557</i>&nbsp;     * the model.  This is implemented to fetch the view in the case
<i>558</i>&nbsp;     * where there is a child view for each child element.
<i>559</i>&nbsp;     *
<i>560</i>&nbsp;     * @param pos the position &amp;gt;= 0
<i>561</i>&nbsp;     * @param a  the allocation to the interior of the box on entry,
<i>562</i>&nbsp;     *   and the allocation of the view containing the position on exit
<i>563</i>&nbsp;     * @return  the view representing the given position, or
<i>564</i>&nbsp;     *   &lt;code&gt;null&lt;/code&gt; if there isn&#39;t one
<b class="nc"><i>565</i>&nbsp;     */</b>
<b class="nc"><i>566</i>&nbsp;    protected View getViewAtPosition(int pos, Rectangle a) {</b>
<b class="nc"><i>567</i>&nbsp;        int index = getViewIndexAtPosition(pos);</b>
<b class="nc"><i>568</i>&nbsp;        if ((index &gt;= 0) &amp;&amp; (index &lt; getViewCount())) {</b>
<b class="nc"><i>569</i>&nbsp;            View v = getView(index);</b>
<i>570</i>&nbsp;            if (a != null) {
<b class="nc"><i>571</i>&nbsp;                childAllocation(index, a);</b>
<i>572</i>&nbsp;            }
<b class="nc"><i>573</i>&nbsp;            return v;</b>
<i>574</i>&nbsp;        }
<i>575</i>&nbsp;        return null;
<i>576</i>&nbsp;    }
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Fetches the child view index representing the given position in
<i>580</i>&nbsp;     * the model.  This is implemented to fetch the view in the case
<i>581</i>&nbsp;     * where there is a child view for each child element.
<i>582</i>&nbsp;     *
<i>583</i>&nbsp;     * @param pos the position &amp;gt;= 0
<i>584</i>&nbsp;     * @return  index of the view representing the given position, or
<i>585</i>&nbsp;     *   -1 if no view represents that position
<b class="nc"><i>586</i>&nbsp;     */</b>
<b class="nc"><i>587</i>&nbsp;    protected int getViewIndexAtPosition(int pos) {</b>
<i>588</i>&nbsp;        Element elem = getElement();
<i>589</i>&nbsp;        return elem.getElementIndex(pos);
<i>590</i>&nbsp;    }
<i>591</i>&nbsp;
<i>592</i>&nbsp;    /**
<i>593</i>&nbsp;     * Translates the immutable allocation given to the view
<i>594</i>&nbsp;     * to a mutable allocation that represents the interior
<i>595</i>&nbsp;     * allocation (i.e. the bounds of the given allocation
<i>596</i>&nbsp;     * with the top, left, bottom, and right insets removed.
<i>597</i>&nbsp;     * It is expected that the returned value would be further
<i>598</i>&nbsp;     * mutated to represent an allocation to a child view.
<i>599</i>&nbsp;     * This is implemented to reuse an instance variable so
<i>600</i>&nbsp;     * it avoids creating excessive Rectangles.  Typically
<i>601</i>&nbsp;     * the result of calling this method would be fed to
<i>602</i>&nbsp;     * the &lt;code&gt;childAllocation&lt;/code&gt; method.
<i>603</i>&nbsp;     *
<i>604</i>&nbsp;     * @param a the allocation given to the view
<i>605</i>&nbsp;     * @return the allocation that represents the inside of the
<i>606</i>&nbsp;     *   view after the margins have all been removed; if the
<i>607</i>&nbsp;     *   given allocation was &lt;code&gt;null&lt;/code&gt;,
<i>608</i>&nbsp;     *   the return value is &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>609</i>&nbsp;     */</b>
<i>610</i>&nbsp;    protected Rectangle getInsideAllocation(Shape a) {
<i>611</i>&nbsp;        if (a != null) {
<i>612</i>&nbsp;            // get the bounds, hopefully without allocating
<i>613</i>&nbsp;            // a new rectangle.  The Shape argument should
<i>614</i>&nbsp;            // not be modified... we copy it into the
<b class="nc"><i>615</i>&nbsp;            // child allocation.</b>
<b class="nc"><i>616</i>&nbsp;            Rectangle alloc;</b>
<i>617</i>&nbsp;            if (a instanceof Rectangle) {
<b class="nc"><i>618</i>&nbsp;                alloc = (Rectangle) a;</b>
<i>619</i>&nbsp;            } else {
<i>620</i>&nbsp;                alloc = a.getBounds();
<b class="nc"><i>621</i>&nbsp;            }</b>
<b class="nc"><i>622</i>&nbsp;</b>
<b class="nc"><i>623</i>&nbsp;            childAlloc.setBounds(alloc);</b>
<b class="nc"><i>624</i>&nbsp;            childAlloc.x += getLeftInset();</b>
<b class="nc"><i>625</i>&nbsp;            childAlloc.y += getTopInset();</b>
<b class="nc"><i>626</i>&nbsp;            childAlloc.width -= getLeftInset() + getRightInset();</b>
<i>627</i>&nbsp;            childAlloc.height -= getTopInset() + getBottomInset();
<b class="nc"><i>628</i>&nbsp;            return childAlloc;</b>
<i>629</i>&nbsp;        }
<i>630</i>&nbsp;        return null;
<i>631</i>&nbsp;    }
<i>632</i>&nbsp;
<i>633</i>&nbsp;    /**
<i>634</i>&nbsp;     * Sets the insets from the paragraph attributes specified in
<i>635</i>&nbsp;     * the given attributes.
<i>636</i>&nbsp;     *
<i>637</i>&nbsp;     * @param attr the attributes
<i>638</i>&nbsp;     */
<i>639</i>&nbsp;    protected void setParagraphInsets(AttributeSet attr) {
<i>640</i>&nbsp;        // Since version 1.1 doesn&#39;t have scaling and assumes
<b class="nc"><i>641</i>&nbsp;        // a pixel is equal to a point, we just cast the point</b>
<b class="nc"><i>642</i>&nbsp;        // sizes to integers.</b>
<b class="nc"><i>643</i>&nbsp;        top = (short) StyleConstants.getSpaceAbove(attr);</b>
<b class="nc"><i>644</i>&nbsp;        left = (short) StyleConstants.getLeftIndent(attr);</b>
<i>645</i>&nbsp;        bottom = (short) StyleConstants.getSpaceBelow(attr);
<i>646</i>&nbsp;        right = (short) StyleConstants.getRightIndent(attr);
<i>647</i>&nbsp;    }
<i>648</i>&nbsp;
<i>649</i>&nbsp;    /**
<i>650</i>&nbsp;     * Sets the insets for the view.
<i>651</i>&nbsp;     *
<i>652</i>&nbsp;     * @param top the top inset &amp;gt;= 0
<i>653</i>&nbsp;     * @param left the left inset &amp;gt;= 0
<i>654</i>&nbsp;     * @param bottom the bottom inset &amp;gt;= 0
<i>655</i>&nbsp;     * @param right the right inset &amp;gt;= 0
<b class="nc"><i>656</i>&nbsp;     */</b>
<b class="nc"><i>657</i>&nbsp;    protected void setInsets(short top, short left, short bottom, short right) {</b>
<b class="nc"><i>658</i>&nbsp;        this.top = top;</b>
<b class="nc"><i>659</i>&nbsp;        this.left = left;</b>
<i>660</i>&nbsp;        this.right = right;
<i>661</i>&nbsp;        this.bottom = bottom;
<i>662</i>&nbsp;    }
<i>663</i>&nbsp;
<i>664</i>&nbsp;    /**
<i>665</i>&nbsp;     * Gets the left inset.
<i>666</i>&nbsp;     *
<i>667</i>&nbsp;     * @return the inset &amp;gt;= 0
<b class="nc"><i>668</i>&nbsp;     */</b>
<i>669</i>&nbsp;    protected short getLeftInset() {
<i>670</i>&nbsp;        return left;
<i>671</i>&nbsp;    }
<i>672</i>&nbsp;
<i>673</i>&nbsp;    /**
<i>674</i>&nbsp;     * Gets the right inset.
<i>675</i>&nbsp;     *
<i>676</i>&nbsp;     * @return the inset &amp;gt;= 0
<b class="nc"><i>677</i>&nbsp;     */</b>
<i>678</i>&nbsp;    protected short getRightInset() {
<i>679</i>&nbsp;        return right;
<i>680</i>&nbsp;    }
<i>681</i>&nbsp;
<i>682</i>&nbsp;    /**
<i>683</i>&nbsp;     * Gets the top inset.
<i>684</i>&nbsp;     *
<i>685</i>&nbsp;     * @return the inset &amp;gt;= 0
<b class="nc"><i>686</i>&nbsp;     */</b>
<i>687</i>&nbsp;    protected short getTopInset() {
<i>688</i>&nbsp;        return top;
<i>689</i>&nbsp;    }
<i>690</i>&nbsp;
<i>691</i>&nbsp;    /**
<i>692</i>&nbsp;     * Gets the bottom inset.
<i>693</i>&nbsp;     *
<i>694</i>&nbsp;     * @return the inset &amp;gt;= 0
<b class="nc"><i>695</i>&nbsp;     */</b>
<i>696</i>&nbsp;    protected short getBottomInset() {
<i>697</i>&nbsp;        return bottom;
<i>698</i>&nbsp;    }
<i>699</i>&nbsp;
<i>700</i>&nbsp;    /**
<i>701</i>&nbsp;     * Returns the next visual position for the cursor, in either the
<i>702</i>&nbsp;     * north or south direction.
<i>703</i>&nbsp;     *
<i>704</i>&nbsp;     * @param pos the position to convert &amp;gt;= 0
<i>705</i>&nbsp;     * @param b a bias value of either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
<i>706</i>&nbsp;     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>707</i>&nbsp;     * @param a the allocated region to render into
<i>708</i>&nbsp;     * @param direction the direction from the current position that can
<i>709</i>&nbsp;     *  be thought of as the arrow keys typically found on a keyboard;
<i>710</i>&nbsp;     *  this may be one of the following:
<i>711</i>&nbsp;     *  &lt;ul&gt;
<i>712</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
<i>713</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
<i>714</i>&nbsp;     *  &lt;/ul&gt;
<i>715</i>&nbsp;     * @param biasRet an array containing the bias that was checked
<i>716</i>&nbsp;     * @return the location within the model that best represents the next
<i>717</i>&nbsp;     *  north or south location
<i>718</i>&nbsp;     * @exception BadLocationException for a bad location within a document model
<i>719</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
<i>720</i>&nbsp;     * @see #getNextVisualPositionFrom
<i>721</i>&nbsp;     *
<i>722</i>&nbsp;     * @return the next position west of the passed in position
<i>723</i>&nbsp;     */
<i>724</i>&nbsp;    protected int getNextNorthSouthVisualPositionFrom(int pos, Position.Bias b,
<i>725</i>&nbsp;                                                      Shape a, int direction,
<b class="nc"><i>726</i>&nbsp;                                                      Position.Bias[] biasRet)</b>
<i>727</i>&nbsp;                                                throws BadLocationException {
<i>728</i>&nbsp;        if (pos &lt; -1 || pos &gt; getDocument().getLength()) {
<i>729</i>&nbsp;            throw new BadLocationException(&quot;invalid position&quot;, pos);
<i>730</i>&nbsp;        }
<i>731</i>&nbsp;        return Utilities.getNextVisualPositionFrom(
<i>732</i>&nbsp;                            this, pos, b, a, direction, biasRet);
<i>733</i>&nbsp;    }
<i>734</i>&nbsp;
<i>735</i>&nbsp;    /**
<i>736</i>&nbsp;     * Returns the next visual position for the cursor, in either the
<i>737</i>&nbsp;     * east or west direction.
<i>738</i>&nbsp;     *
<i>739</i>&nbsp;    * @param pos the position to convert &amp;gt;= 0
<i>740</i>&nbsp;     * @param b a bias value of either &lt;code&gt;Position.Bias.Forward&lt;/code&gt;
<i>741</i>&nbsp;     *  or &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>742</i>&nbsp;     * @param a the allocated region to render into
<i>743</i>&nbsp;     * @param direction the direction from the current position that can
<i>744</i>&nbsp;     *  be thought of as the arrow keys typically found on a keyboard;
<i>745</i>&nbsp;     *  this may be one of the following:
<i>746</i>&nbsp;     *  &lt;ul&gt;
<i>747</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.WEST&lt;/code&gt;
<i>748</i>&nbsp;     *  &lt;li&gt;&lt;code&gt;SwingConstants.EAST&lt;/code&gt;
<i>749</i>&nbsp;     *  &lt;/ul&gt;
<i>750</i>&nbsp;     * @param biasRet an array containing the bias that was checked
<i>751</i>&nbsp;     * @return the location within the model that best represents the next
<i>752</i>&nbsp;     *  west or east location
<i>753</i>&nbsp;     * @exception BadLocationException for a bad location within a document model
<i>754</i>&nbsp;     * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
<i>755</i>&nbsp;     * @see #getNextVisualPositionFrom
<i>756</i>&nbsp;     */
<b class="nc"><i>757</i>&nbsp;    protected int getNextEastWestVisualPositionFrom(int pos, Position.Bias b,</b>
<i>758</i>&nbsp;                                                    Shape a,
<i>759</i>&nbsp;                                                    int direction,
<i>760</i>&nbsp;                                                    Position.Bias[] biasRet)
<i>761</i>&nbsp;                                                throws BadLocationException {
<i>762</i>&nbsp;        if (pos &lt; -1 || pos &gt; getDocument().getLength()) {
<i>763</i>&nbsp;            throw new BadLocationException(&quot;invalid position&quot;, pos);
<i>764</i>&nbsp;        }
<i>765</i>&nbsp;        return Utilities.getNextVisualPositionFrom(
<i>766</i>&nbsp;                            this, pos, b, a, direction, biasRet);
<i>767</i>&nbsp;    }
<i>768</i>&nbsp;
<i>769</i>&nbsp;    /**
<i>770</i>&nbsp;     * Determines in which direction the next view lays.
<i>771</i>&nbsp;     * Consider the &lt;code&gt;View&lt;/code&gt; at index n. Typically the
<i>772</i>&nbsp;     * &lt;code&gt;View&lt;/code&gt;s are layed out from left to right,
<i>773</i>&nbsp;     * so that the &lt;code&gt;View&lt;/code&gt; to the EAST will be
<i>774</i>&nbsp;     * at index n + 1, and the &lt;code&gt;View&lt;/code&gt; to the WEST
<i>775</i>&nbsp;     * will be at index n - 1. In certain situations,
<i>776</i>&nbsp;     * such as with bidirectional text, it is possible
<i>777</i>&nbsp;     * that the &lt;code&gt;View&lt;/code&gt; to EAST is not at index n + 1,
<i>778</i>&nbsp;     * but rather at index n - 1, or that the &lt;code&gt;View&lt;/code&gt;
<i>779</i>&nbsp;     * to the WEST is not at index n - 1, but index n + 1.
<i>780</i>&nbsp;     * In this case this method would return true, indicating the
<i>781</i>&nbsp;     * &lt;code&gt;View&lt;/code&gt;s are layed out in descending order.
<i>782</i>&nbsp;     * &lt;p&gt;
<i>783</i>&nbsp;     * This unconditionally returns false, subclasses should override this
<i>784</i>&nbsp;     * method if there is the possibility for laying &lt;code&gt;View&lt;/code&gt;s in
<i>785</i>&nbsp;     * descending order.
<b class="nc"><i>786</i>&nbsp;     *</b>
<i>787</i>&nbsp;     * @param position position into the model
<i>788</i>&nbsp;     * @param bias either &lt;code&gt;Position.Bias.Forward&lt;/code&gt; or
<i>789</i>&nbsp;     *          &lt;code&gt;Position.Bias.Backward&lt;/code&gt;
<i>790</i>&nbsp;     * @return false
<i>791</i>&nbsp;     */
<i>792</i>&nbsp;    protected boolean flipEastAndWestAtEnds(int position,
<b class="nc"><i>793</i>&nbsp;                                            Position.Bias bias) {</b>
<i>794</i>&nbsp;        return false;
<i>795</i>&nbsp;    }
<i>796</i>&nbsp;
<i>797</i>&nbsp;
<i>798</i>&nbsp;    // ---- member variables ---------------------------------------------
<i>799</i>&nbsp;
<i>800</i>&nbsp;
<i>801</i>&nbsp;    private static View[] ZERO = new View[0];
<i>802</i>&nbsp;
<i>803</i>&nbsp;    private View[] children;
<i>804</i>&nbsp;    private int nchildren;
<i>805</i>&nbsp;    private short left;
<i>806</i>&nbsp;    private short right;
<i>807</i>&nbsp;    private short top;
<i>808</i>&nbsp;    private short bottom;
<i>809</i>&nbsp;    private Rectangle childAlloc;
<i>810</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
