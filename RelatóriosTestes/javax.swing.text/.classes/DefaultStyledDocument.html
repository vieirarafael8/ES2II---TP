


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DefaultStyledDocument</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.text</a> ]
</div>

<h1>Coverage Summary for Class: DefaultStyledDocument (javax.swing.text)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DefaultStyledDocument</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 427)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DefaultStyledDocument$AbstractChangeHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$AbstractChangeHandler$DocReference</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$AttributeUndoableEdit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$ChangeUpdateRunnable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$ElementBuffer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 514)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$ElementBuffer$ElemChanges</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$ElementSpec</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$SectionElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$StyleChangeHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$StyleChangeUndoableEdit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DefaultStyledDocument$StyleContextChangeHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 93)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1051)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.text;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.awt.Color;
<i>28</i>&nbsp;import java.awt.Font;
<i>29</i>&nbsp;import java.awt.font.TextAttribute;
<i>30</i>&nbsp;import java.lang.ref.ReferenceQueue;
<i>31</i>&nbsp;import java.lang.ref.WeakReference;
<i>32</i>&nbsp;import java.util.Enumeration;
<i>33</i>&nbsp;import java.util.HashMap;
<i>34</i>&nbsp;import java.util.List;
<i>35</i>&nbsp;import java.util.Map;
<i>36</i>&nbsp;import java.util.Stack;
<i>37</i>&nbsp;import java.util.Vector;
<i>38</i>&nbsp;import java.util.ArrayList;
<i>39</i>&nbsp;import java.io.IOException;
<i>40</i>&nbsp;import java.io.ObjectInputStream;
<i>41</i>&nbsp;import java.io.Serializable;
<i>42</i>&nbsp;import java.util.Arrays;
<i>43</i>&nbsp;import javax.swing.event.*;
<i>44</i>&nbsp;import javax.swing.undo.AbstractUndoableEdit;
<i>45</i>&nbsp;import javax.swing.undo.CannotRedoException;
<i>46</i>&nbsp;import javax.swing.undo.CannotUndoException;
<i>47</i>&nbsp;import javax.swing.undo.UndoableEdit;
<i>48</i>&nbsp;import javax.swing.SwingUtilities;
<i>49</i>&nbsp;import static sun.swing.SwingUtilities2.IMPLIED_CR;
<i>50</i>&nbsp;
<i>51</i>&nbsp;/**
<i>52</i>&nbsp; * A document that can be marked up with character and paragraph
<i>53</i>&nbsp; * styles in a manner similar to the Rich Text Format.  The element
<i>54</i>&nbsp; * structure for this document represents style crossings for
<i>55</i>&nbsp; * style runs.  These style runs are mapped into a paragraph element
<i>56</i>&nbsp; * structure (which may reside in some other structure).  The
<i>57</i>&nbsp; * style runs break at paragraph boundaries since logical styles are
<i>58</i>&nbsp; * assigned to paragraph boundaries.
<i>59</i>&nbsp; * &lt;p&gt;
<i>60</i>&nbsp; * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>61</i>&nbsp; * Serialized objects of this class will not be compatible with
<i>62</i>&nbsp; * future Swing releases. The current serialization support is
<i>63</i>&nbsp; * appropriate for short term storage or RMI between applications running
<i>64</i>&nbsp; * the same version of Swing.  As of 1.4, support for long term storage
<i>65</i>&nbsp; * of all JavaBeans&amp;trade;
<i>66</i>&nbsp; * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>67</i>&nbsp; * Please see {@link java.beans.XMLEncoder}.
<i>68</i>&nbsp; *
<i>69</i>&nbsp; * @author  Timothy Prinzing
<i>70</i>&nbsp; * @see     Document
<i>71</i>&nbsp; * @see     AbstractDocument
<i>72</i>&nbsp; */
<i>73</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>74</i>&nbsp;public class DefaultStyledDocument extends AbstractDocument implements StyledDocument {
<i>75</i>&nbsp;
<i>76</i>&nbsp;    /**
<i>77</i>&nbsp;     * Constructs a styled document.
<i>78</i>&nbsp;     *
<i>79</i>&nbsp;     * @param c  the container for the content
<i>80</i>&nbsp;     * @param styles resources and style definitions which may
<i>81</i>&nbsp;     *  be shared across documents
<b class="nc"><i>82</i>&nbsp;     */</b>
<b class="nc"><i>83</i>&nbsp;    public DefaultStyledDocument(Content c, StyleContext styles) {</b>
<b class="nc"><i>84</i>&nbsp;        super(c, styles);</b>
<b class="nc"><i>85</i>&nbsp;        listeningStyles = new Vector&lt;Style&gt;();</b>
<b class="nc"><i>86</i>&nbsp;        buffer = new ElementBuffer(createDefaultRoot());</b>
<i>87</i>&nbsp;        Style defaultStyle = styles.getStyle(StyleContext.DEFAULT_STYLE);
<i>88</i>&nbsp;        setLogicalStyle(0, defaultStyle);
<i>89</i>&nbsp;    }
<i>90</i>&nbsp;
<i>91</i>&nbsp;    /**
<i>92</i>&nbsp;     * Constructs a styled document with the default content
<i>93</i>&nbsp;     * storage implementation and a shared set of styles.
<i>94</i>&nbsp;     *
<i>95</i>&nbsp;     * @param styles the styles
<b class="nc"><i>96</i>&nbsp;     */</b>
<i>97</i>&nbsp;    public DefaultStyledDocument(StyleContext styles) {
<i>98</i>&nbsp;        this(new GapContent(BUFFER_SIZE_DEFAULT), styles);
<i>99</i>&nbsp;    }
<i>100</i>&nbsp;
<i>101</i>&nbsp;    /**
<i>102</i>&nbsp;     * Constructs a default styled document.  This buffers
<i>103</i>&nbsp;     * input content by a size of &lt;em&gt;BUFFER_SIZE_DEFAULT&lt;/em&gt;
<i>104</i>&nbsp;     * and has a style context that is scoped by the lifetime
<i>105</i>&nbsp;     * of the document and is not shared with other documents.
<b class="nc"><i>106</i>&nbsp;     */</b>
<i>107</i>&nbsp;    public DefaultStyledDocument() {
<i>108</i>&nbsp;        this(new GapContent(BUFFER_SIZE_DEFAULT), new StyleContext());
<i>109</i>&nbsp;    }
<i>110</i>&nbsp;
<i>111</i>&nbsp;    /**
<i>112</i>&nbsp;     * Gets the default root element.
<i>113</i>&nbsp;     *
<i>114</i>&nbsp;     * @return the root
<i>115</i>&nbsp;     * @see Document#getDefaultRootElement
<b class="nc"><i>116</i>&nbsp;     */</b>
<i>117</i>&nbsp;    public Element getDefaultRootElement() {
<i>118</i>&nbsp;        return buffer.getRootElement();
<i>119</i>&nbsp;    }
<i>120</i>&nbsp;
<i>121</i>&nbsp;    /**
<i>122</i>&nbsp;     * Initialize the document to reflect the given element
<i>123</i>&nbsp;     * structure (i.e. the structure reported by the
<i>124</i>&nbsp;     * &lt;code&gt;getDefaultRootElement&lt;/code&gt; method.  If the
<i>125</i>&nbsp;     * document contained any data it will first be removed.
<i>126</i>&nbsp;     * @param data the element data
<b class="nc"><i>127</i>&nbsp;     */</b>
<b class="nc"><i>128</i>&nbsp;    protected void create(ElementSpec[] data) {</b>
<i>129</i>&nbsp;        try {
<b class="nc"><i>130</i>&nbsp;            if (getLength() != 0) {</b>
<i>131</i>&nbsp;                remove(0, getLength());
<i>132</i>&nbsp;            }
<b class="nc"><i>133</i>&nbsp;            writeLock();</b>
<b class="nc"><i>134</i>&nbsp;</b>
<b class="nc"><i>135</i>&nbsp;            // install the content</b>
<b class="nc"><i>136</i>&nbsp;            Content c = getContent();</b>
<b class="nc"><i>137</i>&nbsp;            int n = data.length;</b>
<b class="nc"><i>138</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>139</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<i>140</i>&nbsp;                ElementSpec es = data[i];
<i>141</i>&nbsp;                if (es.getLength() &gt; 0) {
<b class="nc"><i>142</i>&nbsp;                    sb.append(es.getArray(), es.getOffset(),  es.getLength());</b>
<i>143</i>&nbsp;                }
<i>144</i>&nbsp;            }
<b class="nc"><i>145</i>&nbsp;            UndoableEdit cEdit = c.insertString(0, sb.toString());</b>
<b class="nc"><i>146</i>&nbsp;</b>
<i>147</i>&nbsp;            // build the event and element structure
<b class="nc"><i>148</i>&nbsp;            int length = sb.length();</b>
<b class="nc"><i>149</i>&nbsp;            DefaultDocumentEvent evnt =</b>
<i>150</i>&nbsp;                new DefaultDocumentEvent(0, length, DocumentEvent.EventType.INSERT);
<i>151</i>&nbsp;            evnt.addEdit(cEdit);
<b class="nc"><i>152</i>&nbsp;            buffer.create(length, data, evnt);</b>
<i>153</i>&nbsp;
<i>154</i>&nbsp;            // update bidi (possibly)
<b class="nc"><i>155</i>&nbsp;            super.insertUpdate(evnt, null);</b>
<b class="nc"><i>156</i>&nbsp;</b>
<b class="nc"><i>157</i>&nbsp;            // notify the listeners</b>
<b class="nc"><i>158</i>&nbsp;            evnt.end();</b>
<b class="nc"><i>159</i>&nbsp;            fireInsertUpdate(evnt);</b>
<i>160</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));
<b class="nc"><i>161</i>&nbsp;        } catch (BadLocationException ble) {</b>
<b class="nc"><i>162</i>&nbsp;            throw new StateInvariantError(&quot;problem initializing&quot;);</b>
<i>163</i>&nbsp;        } finally {
<i>164</i>&nbsp;            writeUnlock();
<i>165</i>&nbsp;        }
<i>166</i>&nbsp;
<i>167</i>&nbsp;    }
<i>168</i>&nbsp;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * Inserts new elements in bulk.  This is useful to allow
<i>171</i>&nbsp;     * parsing with the document in an unlocked state and
<i>172</i>&nbsp;     * prepare an element structure modification.  This method
<i>173</i>&nbsp;     * takes an array of tokens that describe how to update an
<i>174</i>&nbsp;     * element structure so the time within a write lock can
<i>175</i>&nbsp;     * be greatly reduced in an asynchronous update situation.
<i>176</i>&nbsp;     * &lt;p&gt;
<i>177</i>&nbsp;     * This method is thread safe, although most Swing methods
<i>178</i>&nbsp;     * are not. Please see
<i>179</i>&nbsp;     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
<i>180</i>&nbsp;     * in Swing&lt;/A&gt; for more information.
<i>181</i>&nbsp;     *
<i>182</i>&nbsp;     * @param offset the starting offset &amp;gt;= 0
<i>183</i>&nbsp;     * @param data the element data
<b class="nc"><i>184</i>&nbsp;     * @exception BadLocationException for an invalid starting offset</b>
<i>185</i>&nbsp;     */
<i>186</i>&nbsp;    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {
<i>187</i>&nbsp;        if (data == null || data.length == 0) {
<i>188</i>&nbsp;            return;
<b class="nc"><i>189</i>&nbsp;        }</b>
<i>190</i>&nbsp;
<i>191</i>&nbsp;        try {
<b class="nc"><i>192</i>&nbsp;            writeLock();</b>
<b class="nc"><i>193</i>&nbsp;</b>
<b class="nc"><i>194</i>&nbsp;            // install the content</b>
<b class="nc"><i>195</i>&nbsp;            Content c = getContent();</b>
<b class="nc"><i>196</i>&nbsp;            int n = data.length;</b>
<b class="nc"><i>197</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>198</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<i>199</i>&nbsp;                ElementSpec es = data[i];
<i>200</i>&nbsp;                if (es.getLength() &gt; 0) {
<b class="nc"><i>201</i>&nbsp;                    sb.append(es.getArray(), es.getOffset(),  es.getLength());</b>
<i>202</i>&nbsp;                }
<i>203</i>&nbsp;            }
<i>204</i>&nbsp;            if (sb.length() == 0) {
<b class="nc"><i>205</i>&nbsp;                // Nothing to insert, bail.</b>
<i>206</i>&nbsp;                return;
<i>207</i>&nbsp;            }
<b class="nc"><i>208</i>&nbsp;            UndoableEdit cEdit = c.insertString(offset, sb.toString());</b>
<b class="nc"><i>209</i>&nbsp;</b>
<i>210</i>&nbsp;            // create event and build the element structure
<b class="nc"><i>211</i>&nbsp;            int length = sb.length();</b>
<b class="nc"><i>212</i>&nbsp;            DefaultDocumentEvent evnt =</b>
<i>213</i>&nbsp;                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.INSERT);
<i>214</i>&nbsp;            evnt.addEdit(cEdit);
<b class="nc"><i>215</i>&nbsp;            buffer.insert(offset, length, data, evnt);</b>
<i>216</i>&nbsp;
<i>217</i>&nbsp;            // update bidi (possibly)
<b class="nc"><i>218</i>&nbsp;            super.insertUpdate(evnt, null);</b>
<b class="nc"><i>219</i>&nbsp;</b>
<b class="nc"><i>220</i>&nbsp;            // notify the listeners</b>
<i>221</i>&nbsp;            evnt.end();
<b class="nc"><i>222</i>&nbsp;            fireInsertUpdate(evnt);</b>
<b class="nc"><i>223</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));</b>
<i>224</i>&nbsp;        } finally {
<i>225</i>&nbsp;            writeUnlock();
<i>226</i>&nbsp;        }
<i>227</i>&nbsp;    }
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Removes an element from this document.
<i>231</i>&nbsp;     *
<i>232</i>&nbsp;     * &lt;p&gt;The element is removed from its parent element, as well as
<i>233</i>&nbsp;     * the text in the range identified by the element.  If the
<i>234</i>&nbsp;     * element isn&#39;t associated with the document, {@code
<i>235</i>&nbsp;     * IllegalArgumentException} is thrown.&lt;/p&gt;
<i>236</i>&nbsp;     *
<i>237</i>&nbsp;     * &lt;p&gt;As empty branch elements are not allowed in the document, if the
<i>238</i>&nbsp;     * element is the sole child, its parent element is removed as well,
<i>239</i>&nbsp;     * recursively.  This means that when replacing all the children of a
<i>240</i>&nbsp;     * particular element, new children should be added &lt;em&gt;before&lt;/em&gt;
<i>241</i>&nbsp;     * removing old children.
<i>242</i>&nbsp;     *
<i>243</i>&nbsp;     * &lt;p&gt;Element removal results in two events being fired, the
<i>244</i>&nbsp;     * {@code DocumentEvent} for changes in element structure and {@code
<i>245</i>&nbsp;     * UndoableEditEvent} for changes in document content.&lt;/p&gt;
<i>246</i>&nbsp;     *
<i>247</i>&nbsp;     * &lt;p&gt;If the element contains end-of-content mark (the last {@code
<i>248</i>&nbsp;     * &quot;\n&quot;} character in document), this character is not removed;
<i>249</i>&nbsp;     * instead, preceding leaf element is extended to cover the
<i>250</i>&nbsp;     * character.  If the last leaf already ends with {@code &quot;\n&quot;,} it is
<i>251</i>&nbsp;     * included in content removal.&lt;/p&gt;
<i>252</i>&nbsp;     *
<i>253</i>&nbsp;     * &lt;p&gt;If the element is {@code null,} {@code NullPointerException} is
<i>254</i>&nbsp;     * thrown.  If the element structure would become invalid after the removal,
<i>255</i>&nbsp;     * for example if the element is the document root element, {@code
<i>256</i>&nbsp;     * IllegalArgumentException} is thrown.  If the current element structure is
<i>257</i>&nbsp;     * invalid, {@code IllegalStateException} is thrown.&lt;/p&gt;
<i>258</i>&nbsp;     *
<i>259</i>&nbsp;     * @param  elem                      the element to remove
<i>260</i>&nbsp;     * @throws NullPointerException      if the element is {@code null}
<i>261</i>&nbsp;     * @throws IllegalArgumentException  if the element could not be removed
<i>262</i>&nbsp;     * @throws IllegalStateException     if the element structure is invalid
<i>263</i>&nbsp;     *
<i>264</i>&nbsp;     * @since  1.7
<b class="nc"><i>265</i>&nbsp;     */</b>
<b class="nc"><i>266</i>&nbsp;    public void removeElement(Element elem) {</b>
<i>267</i>&nbsp;        try {
<b class="nc"><i>268</i>&nbsp;            writeLock();</b>
<b class="nc"><i>269</i>&nbsp;            removeElementImpl(elem);</b>
<i>270</i>&nbsp;        } finally {
<i>271</i>&nbsp;            writeUnlock();
<i>272</i>&nbsp;        }
<b class="nc"><i>273</i>&nbsp;    }</b>
<b class="nc"><i>274</i>&nbsp;</b>
<i>275</i>&nbsp;    private void removeElementImpl(Element elem) {
<b class="nc"><i>276</i>&nbsp;        if (elem.getDocument() != this) {</b>
<b class="nc"><i>277</i>&nbsp;            throw new IllegalArgumentException(&quot;element doesn&#39;t belong to document&quot;);</b>
<b class="nc"><i>278</i>&nbsp;        }</b>
<i>279</i>&nbsp;        BranchElement parent = (BranchElement) elem.getParentElement();
<i>280</i>&nbsp;        if (parent == null) {
<b class="nc"><i>281</i>&nbsp;            throw new IllegalArgumentException(&quot;can&#39;t remove the root element&quot;);</b>
<b class="nc"><i>282</i>&nbsp;        }</b>
<b class="nc"><i>283</i>&nbsp;</b>
<b class="nc"><i>284</i>&nbsp;        int startOffset = elem.getStartOffset();</b>
<b class="nc"><i>285</i>&nbsp;        int removeFrom = startOffset;</b>
<b class="nc"><i>286</i>&nbsp;        int endOffset = elem.getEndOffset();</b>
<b class="nc"><i>287</i>&nbsp;        int removeTo = endOffset;</b>
<b class="nc"><i>288</i>&nbsp;        int lastEndOffset = getLength() + 1;</b>
<i>289</i>&nbsp;        Content content = getContent();
<b class="nc"><i>290</i>&nbsp;        boolean atEnd = false;</b>
<i>291</i>&nbsp;        boolean isComposedText = Utilities.isComposedTextElement(elem);
<b class="nc"><i>292</i>&nbsp;</b>
<b class="nc"><i>293</i>&nbsp;        if (endOffset &gt;= lastEndOffset) {</b>
<i>294</i>&nbsp;            // element includes the last &quot;\n&quot; character, needs special handling
<b class="nc"><i>295</i>&nbsp;            if (startOffset &lt;= 0) {</b>
<i>296</i>&nbsp;                throw new IllegalArgumentException(&quot;can&#39;t remove the whole content&quot;);
<b class="nc"><i>297</i>&nbsp;            }</b>
<b class="nc"><i>298</i>&nbsp;            removeTo = lastEndOffset - 1; // last &quot;\n&quot; must not be removed</b>
<i>299</i>&nbsp;            try {
<b class="nc"><i>300</i>&nbsp;                if (content.getString(startOffset - 1, 1).charAt(0) == &#39;\n&#39;) {</b>
<b class="nc"><i>301</i>&nbsp;                    removeFrom--; // preceding leaf ends with &quot;\n&quot;, remove it</b>
<b class="nc"><i>302</i>&nbsp;                }</b>
<b class="nc"><i>303</i>&nbsp;            } catch (BadLocationException ble) { // can&#39;t happen</b>
<i>304</i>&nbsp;                throw new IllegalStateException(ble);
<b class="nc"><i>305</i>&nbsp;            }</b>
<i>306</i>&nbsp;            atEnd = true;
<b class="nc"><i>307</i>&nbsp;        }</b>
<i>308</i>&nbsp;        int length = removeTo - removeFrom;
<b class="nc"><i>309</i>&nbsp;</b>
<i>310</i>&nbsp;        DefaultDocumentEvent dde = new DefaultDocumentEvent(removeFrom,
<b class="nc"><i>311</i>&nbsp;                length, DefaultDocumentEvent.EventType.REMOVE);</b>
<b class="nc"><i>312</i>&nbsp;        UndoableEdit ue = null;</b>
<b class="nc"><i>313</i>&nbsp;        // do not leave empty branch elements</b>
<b class="nc"><i>314</i>&nbsp;        while (parent.getElementCount() == 1) {</b>
<b class="nc"><i>315</i>&nbsp;            elem = parent;</b>
<i>316</i>&nbsp;            parent = (BranchElement) parent.getParentElement();
<i>317</i>&nbsp;            if (parent == null) { // shouldn&#39;t happen
<b class="nc"><i>318</i>&nbsp;                throw new IllegalStateException(&quot;invalid element structure&quot;);</b>
<b class="nc"><i>319</i>&nbsp;            }</b>
<b class="nc"><i>320</i>&nbsp;        }</b>
<b class="nc"><i>321</i>&nbsp;        Element[] removed = { elem };</b>
<b class="nc"><i>322</i>&nbsp;        Element[] added = {};</b>
<b class="nc"><i>323</i>&nbsp;        int index = parent.getElementIndex(startOffset);</b>
<i>324</i>&nbsp;        parent.replace(index, 1, added);
<b class="nc"><i>325</i>&nbsp;        dde.addEdit(new ElementEdit(parent, index, removed, added));</b>
<b class="nc"><i>326</i>&nbsp;        if (length &gt; 0) {</b>
<b class="nc"><i>327</i>&nbsp;            try {</b>
<i>328</i>&nbsp;                ue = content.remove(removeFrom, length);
<b class="nc"><i>329</i>&nbsp;                if (ue != null) {</b>
<i>330</i>&nbsp;                    dde.addEdit(ue);
<b class="nc"><i>331</i>&nbsp;                }</b>
<b class="nc"><i>332</i>&nbsp;            } catch (BadLocationException ble) {</b>
<b class="nc"><i>333</i>&nbsp;                // can only happen if the element structure is severely broken</b>
<i>334</i>&nbsp;                throw new IllegalStateException(ble);
<i>335</i>&nbsp;            }
<b class="nc"><i>336</i>&nbsp;            lastEndOffset -= length;</b>
<i>337</i>&nbsp;        }
<b class="nc"><i>338</i>&nbsp;</b>
<b class="nc"><i>339</i>&nbsp;        if (atEnd) {</b>
<b class="nc"><i>340</i>&nbsp;            // preceding leaf element should be extended to cover orphaned &quot;\n&quot;</b>
<i>341</i>&nbsp;            Element prevLeaf = parent.getElement(parent.getElementCount() - 1);
<b class="nc"><i>342</i>&nbsp;            while ((prevLeaf != null) &amp;&amp; !prevLeaf.isLeaf()) {</b>
<b class="nc"><i>343</i>&nbsp;                prevLeaf = prevLeaf.getElement(prevLeaf.getElementCount() - 1);</b>
<i>344</i>&nbsp;            }
<b class="nc"><i>345</i>&nbsp;            if (prevLeaf == null) { // shouldn&#39;t happen</b>
<b class="nc"><i>346</i>&nbsp;                throw new IllegalStateException(&quot;invalid element structure&quot;);</b>
<b class="nc"><i>347</i>&nbsp;            }</b>
<i>348</i>&nbsp;            int prevStartOffset = prevLeaf.getStartOffset();
<b class="nc"><i>349</i>&nbsp;            BranchElement prevParent = (BranchElement) prevLeaf.getParentElement();</b>
<i>350</i>&nbsp;            int prevIndex = prevParent.getElementIndex(prevStartOffset);
<b class="nc"><i>351</i>&nbsp;            Element newElem;</b>
<b class="nc"><i>352</i>&nbsp;            newElem = createLeafElement(prevParent, prevLeaf.getAttributes(),</b>
<b class="nc"><i>353</i>&nbsp;                                            prevStartOffset, lastEndOffset);</b>
<b class="nc"><i>354</i>&nbsp;            Element[] prevRemoved = { prevLeaf };</b>
<i>355</i>&nbsp;            Element[] prevAdded = { newElem };
<i>356</i>&nbsp;            prevParent.replace(prevIndex, 1, prevAdded);
<i>357</i>&nbsp;            dde.addEdit(new ElementEdit(prevParent, prevIndex,
<b class="nc"><i>358</i>&nbsp;                                                    prevRemoved, prevAdded));</b>
<b class="nc"><i>359</i>&nbsp;        }</b>
<b class="nc"><i>360</i>&nbsp;</b>
<b class="nc"><i>361</i>&nbsp;        postRemoveUpdate(dde);</b>
<i>362</i>&nbsp;        dde.end();
<b class="nc"><i>363</i>&nbsp;        fireRemoveUpdate(dde);</b>
<i>364</i>&nbsp;        if (! (isComposedText &amp;&amp; (ue != null))) {
<i>365</i>&nbsp;            // do not fire UndoabeEdit event for composed text edit (unsupported)
<i>366</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, dde));
<i>367</i>&nbsp;        }
<i>368</i>&nbsp;    }
<i>369</i>&nbsp;
<i>370</i>&nbsp;    /**
<i>371</i>&nbsp;     * Adds a new style into the logical style hierarchy.  Style attributes
<i>372</i>&nbsp;     * resolve from bottom up so an attribute specified in a child
<i>373</i>&nbsp;     * will override an attribute specified in the parent.
<i>374</i>&nbsp;     *
<i>375</i>&nbsp;     * @param nm   the name of the style (must be unique within the
<i>376</i>&nbsp;     *   collection of named styles).  The name may be null if the style
<i>377</i>&nbsp;     *   is unnamed, but the caller is responsible
<i>378</i>&nbsp;     *   for managing the reference returned as an unnamed style can&#39;t
<i>379</i>&nbsp;     *   be fetched by name.  An unnamed style may be useful for things
<i>380</i>&nbsp;     *   like character attribute overrides such as found in a style
<i>381</i>&nbsp;     *   run.
<i>382</i>&nbsp;     * @param parent the parent style.  This may be null if unspecified
<i>383</i>&nbsp;     *   attributes need not be resolved in some other style.
<b class="nc"><i>384</i>&nbsp;     * @return the style</b>
<b class="nc"><i>385</i>&nbsp;     */</b>
<i>386</i>&nbsp;    public Style addStyle(String nm, Style parent) {
<i>387</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>388</i>&nbsp;        return styles.addStyle(nm, parent);
<i>389</i>&nbsp;    }
<i>390</i>&nbsp;
<i>391</i>&nbsp;    /**
<i>392</i>&nbsp;     * Removes a named style previously added to the document.
<i>393</i>&nbsp;     *
<b class="nc"><i>394</i>&nbsp;     * @param nm  the name of the style to remove</b>
<b class="nc"><i>395</i>&nbsp;     */</b>
<i>396</i>&nbsp;    public void removeStyle(String nm) {
<i>397</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>398</i>&nbsp;        styles.removeStyle(nm);
<i>399</i>&nbsp;    }
<i>400</i>&nbsp;
<i>401</i>&nbsp;    /**
<i>402</i>&nbsp;     * Fetches a named style previously added.
<i>403</i>&nbsp;     *
<i>404</i>&nbsp;     * @param nm  the name of the style
<b class="nc"><i>405</i>&nbsp;     * @return the style</b>
<b class="nc"><i>406</i>&nbsp;     */</b>
<i>407</i>&nbsp;    public Style getStyle(String nm) {
<i>408</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>409</i>&nbsp;        return styles.getStyle(nm);
<i>410</i>&nbsp;    }
<i>411</i>&nbsp;
<i>412</i>&nbsp;
<i>413</i>&nbsp;    /**
<i>414</i>&nbsp;     * Fetches the list of style names.
<i>415</i>&nbsp;     *
<b class="nc"><i>416</i>&nbsp;     * @return all the style names</b>
<i>417</i>&nbsp;     */
<i>418</i>&nbsp;    public Enumeration&lt;?&gt; getStyleNames() {
<i>419</i>&nbsp;        return ((StyleContext) getAttributeContext()).getStyleNames();
<i>420</i>&nbsp;    }
<i>421</i>&nbsp;
<i>422</i>&nbsp;    /**
<i>423</i>&nbsp;     * Sets the logical style to use for the paragraph at the
<i>424</i>&nbsp;     * given position.  If attributes aren&#39;t explicitly set
<i>425</i>&nbsp;     * for character and paragraph attributes they will resolve
<i>426</i>&nbsp;     * through the logical style assigned to the paragraph, which
<i>427</i>&nbsp;     * in turn may resolve through some hierarchy completely
<i>428</i>&nbsp;     * independent of the element hierarchy in the document.
<i>429</i>&nbsp;     * &lt;p&gt;
<i>430</i>&nbsp;     * This method is thread safe, although most Swing methods
<i>431</i>&nbsp;     * are not. Please see
<i>432</i>&nbsp;     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
<i>433</i>&nbsp;     * in Swing&lt;/A&gt; for more information.
<i>434</i>&nbsp;     *
<i>435</i>&nbsp;     * @param pos the offset from the start of the document &amp;gt;= 0
<b class="nc"><i>436</i>&nbsp;     * @param s  the logical style to assign to the paragraph, null if none</b>
<b class="nc"><i>437</i>&nbsp;     */</b>
<i>438</i>&nbsp;    public void setLogicalStyle(int pos, Style s) {
<b class="nc"><i>439</i>&nbsp;        Element paragraph = getParagraphElement(pos);</b>
<b class="nc"><i>440</i>&nbsp;        if ((paragraph != null) &amp;&amp; (paragraph instanceof AbstractElement)) {</b>
<b class="nc"><i>441</i>&nbsp;            try {</b>
<b class="nc"><i>442</i>&nbsp;                writeLock();</b>
<b class="nc"><i>443</i>&nbsp;                StyleChangeUndoableEdit edit = new StyleChangeUndoableEdit((AbstractElement)paragraph, s);</b>
<b class="nc"><i>444</i>&nbsp;                ((AbstractElement)paragraph).setResolveParent(s);</b>
<i>445</i>&nbsp;                int p0 = paragraph.getStartOffset();
<b class="nc"><i>446</i>&nbsp;                int p1 = paragraph.getEndOffset();</b>
<b class="nc"><i>447</i>&nbsp;                DefaultDocumentEvent e =</b>
<b class="nc"><i>448</i>&nbsp;                  new DefaultDocumentEvent(p0, p1 - p0, DocumentEvent.EventType.CHANGE);</b>
<b class="nc"><i>449</i>&nbsp;                e.addEdit(edit);</b>
<i>450</i>&nbsp;                e.end();
<b class="nc"><i>451</i>&nbsp;                fireChangedUpdate(e);</b>
<b class="nc"><i>452</i>&nbsp;                fireUndoableEditUpdate(new UndoableEditEvent(this, e));</b>
<i>453</i>&nbsp;            } finally {
<i>454</i>&nbsp;                writeUnlock();
<i>455</i>&nbsp;            }
<i>456</i>&nbsp;        }
<i>457</i>&nbsp;    }
<i>458</i>&nbsp;
<i>459</i>&nbsp;    /**
<i>460</i>&nbsp;     * Fetches the logical style assigned to the paragraph
<i>461</i>&nbsp;     * represented by the given position.
<i>462</i>&nbsp;     *
<i>463</i>&nbsp;     * @param p the location to translate to a paragraph
<i>464</i>&nbsp;     *  and determine the logical style assigned &amp;gt;= 0.  This
<i>465</i>&nbsp;     *  is an offset from the start of the document.
<b class="nc"><i>466</i>&nbsp;     * @return the style, null if none</b>
<b class="nc"><i>467</i>&nbsp;     */</b>
<b class="nc"><i>468</i>&nbsp;    public Style getLogicalStyle(int p) {</b>
<b class="nc"><i>469</i>&nbsp;        Style s = null;</b>
<b class="nc"><i>470</i>&nbsp;        Element paragraph = getParagraphElement(p);</b>
<b class="nc"><i>471</i>&nbsp;        if (paragraph != null) {</b>
<b class="nc"><i>472</i>&nbsp;            AttributeSet a = paragraph.getAttributes();</b>
<i>473</i>&nbsp;            AttributeSet parent = a.getResolveParent();
<i>474</i>&nbsp;            if (parent instanceof Style) {
<b class="nc"><i>475</i>&nbsp;                s = (Style) parent;</b>
<i>476</i>&nbsp;            }
<i>477</i>&nbsp;        }
<i>478</i>&nbsp;        return s;
<i>479</i>&nbsp;    }
<i>480</i>&nbsp;
<i>481</i>&nbsp;    /**
<i>482</i>&nbsp;     * Sets attributes for some part of the document.
<i>483</i>&nbsp;     * A write lock is held by this operation while changes
<i>484</i>&nbsp;     * are being made, and a DocumentEvent is sent to the listeners
<i>485</i>&nbsp;     * after the change has been successfully completed.
<i>486</i>&nbsp;     * &lt;p&gt;
<i>487</i>&nbsp;     * This method is thread safe, although most Swing methods
<i>488</i>&nbsp;     * are not. Please see
<i>489</i>&nbsp;     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
<i>490</i>&nbsp;     * in Swing&lt;/A&gt; for more information.
<i>491</i>&nbsp;     *
<i>492</i>&nbsp;     * @param offset the offset in the document &amp;gt;= 0
<i>493</i>&nbsp;     * @param length the length &amp;gt;= 0
<i>494</i>&nbsp;     * @param s the attributes
<i>495</i>&nbsp;     * @param replace true if the previous attributes should be replaced
<b class="nc"><i>496</i>&nbsp;     *  before setting the new attributes</b>
<i>497</i>&nbsp;     */
<i>498</i>&nbsp;    public void setCharacterAttributes(int offset, int length, AttributeSet s, boolean replace) {
<i>499</i>&nbsp;        if (length == 0) {
<b class="nc"><i>500</i>&nbsp;            return;</b>
<b class="nc"><i>501</i>&nbsp;        }</b>
<i>502</i>&nbsp;        try {
<i>503</i>&nbsp;            writeLock();
<i>504</i>&nbsp;            DefaultDocumentEvent changes =
<b class="nc"><i>505</i>&nbsp;                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.CHANGE);</b>
<i>506</i>&nbsp;
<b class="nc"><i>507</i>&nbsp;            // split elements that need it</b>
<i>508</i>&nbsp;            buffer.change(offset, length, changes);
<i>509</i>&nbsp;
<i>510</i>&nbsp;            AttributeSet sCopy = s.copyAttributes();
<b class="nc"><i>511</i>&nbsp;</b>
<b class="nc"><i>512</i>&nbsp;            // PENDING(prinz) - this isn&#39;t a very efficient way to iterate</b>
<b class="nc"><i>513</i>&nbsp;            int lastEnd;</b>
<b class="nc"><i>514</i>&nbsp;            for (int pos = offset; pos &lt; (offset + length); pos = lastEnd) {</b>
<i>515</i>&nbsp;                Element run = getCharacterElement(pos);
<b class="nc"><i>516</i>&nbsp;                lastEnd = run.getEndOffset();</b>
<i>517</i>&nbsp;                if (pos == lastEnd) {
<b class="nc"><i>518</i>&nbsp;                    // offset + length beyond length of document, bail.</b>
<b class="nc"><i>519</i>&nbsp;                    break;</b>
<b class="nc"><i>520</i>&nbsp;                }</b>
<b class="nc"><i>521</i>&nbsp;                MutableAttributeSet attr = (MutableAttributeSet) run.getAttributes();</b>
<i>522</i>&nbsp;                changes.addEdit(new AttributeUndoableEdit(run, sCopy, replace));
<b class="nc"><i>523</i>&nbsp;                if (replace) {</b>
<i>524</i>&nbsp;                    attr.removeAttributes(attr);
<b class="nc"><i>525</i>&nbsp;                }</b>
<b class="nc"><i>526</i>&nbsp;                attr.addAttributes(s);</b>
<b class="nc"><i>527</i>&nbsp;            }</b>
<i>528</i>&nbsp;            changes.end();
<b class="nc"><i>529</i>&nbsp;            fireChangedUpdate(changes);</b>
<b class="nc"><i>530</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</b>
<i>531</i>&nbsp;        } finally {
<i>532</i>&nbsp;            writeUnlock();
<i>533</i>&nbsp;        }
<i>534</i>&nbsp;
<i>535</i>&nbsp;    }
<i>536</i>&nbsp;
<i>537</i>&nbsp;    /**
<i>538</i>&nbsp;     * Sets attributes for a paragraph.
<i>539</i>&nbsp;     * &lt;p&gt;
<i>540</i>&nbsp;     * This method is thread safe, although most Swing methods
<i>541</i>&nbsp;     * are not. Please see
<i>542</i>&nbsp;     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
<i>543</i>&nbsp;     * in Swing&lt;/A&gt; for more information.
<i>544</i>&nbsp;     *
<i>545</i>&nbsp;     * @param offset the offset into the paragraph &amp;gt;= 0
<i>546</i>&nbsp;     * @param length the number of characters affected &amp;gt;= 0
<i>547</i>&nbsp;     * @param s the attributes
<i>548</i>&nbsp;     * @param replace whether to replace existing attributes, or merge them
<i>549</i>&nbsp;     */
<b class="nc"><i>550</i>&nbsp;    public void setParagraphAttributes(int offset, int length, AttributeSet s,</b>
<b class="nc"><i>551</i>&nbsp;                                       boolean replace) {</b>
<i>552</i>&nbsp;        try {
<i>553</i>&nbsp;            writeLock();
<b class="nc"><i>554</i>&nbsp;            DefaultDocumentEvent changes =</b>
<i>555</i>&nbsp;                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.CHANGE);
<i>556</i>&nbsp;
<b class="nc"><i>557</i>&nbsp;            AttributeSet sCopy = s.copyAttributes();</b>
<b class="nc"><i>558</i>&nbsp;</b>
<b class="nc"><i>559</i>&nbsp;            // PENDING(prinz) - this assumes a particular element structure</b>
<b class="nc"><i>560</i>&nbsp;            Element section = getDefaultRootElement();</b>
<b class="nc"><i>561</i>&nbsp;            int index0 = section.getElementIndex(offset);</b>
<b class="nc"><i>562</i>&nbsp;            int index1 = section.getElementIndex(offset + ((length &gt; 0) ? length - 1 : 0));</b>
<b class="nc"><i>563</i>&nbsp;            boolean isI18N = Boolean.TRUE.equals(getProperty(I18NProperty));</b>
<b class="nc"><i>564</i>&nbsp;            boolean hasRuns = false;</b>
<b class="nc"><i>565</i>&nbsp;            for (int i = index0; i &lt;= index1; i++) {</b>
<b class="nc"><i>566</i>&nbsp;                Element paragraph = section.getElement(i);</b>
<b class="nc"><i>567</i>&nbsp;                MutableAttributeSet attr = (MutableAttributeSet) paragraph.getAttributes();</b>
<i>568</i>&nbsp;                changes.addEdit(new AttributeUndoableEdit(paragraph, sCopy, replace));
<b class="nc"><i>569</i>&nbsp;                if (replace) {</b>
<b class="nc"><i>570</i>&nbsp;                    attr.removeAttributes(attr);</b>
<b class="nc"><i>571</i>&nbsp;                }</b>
<i>572</i>&nbsp;                attr.addAttributes(s);
<i>573</i>&nbsp;                if (isI18N &amp;&amp; !hasRuns) {
<i>574</i>&nbsp;                    hasRuns = (attr.getAttribute(TextAttribute.RUN_DIRECTION) != null);
<b class="nc"><i>575</i>&nbsp;                }</b>
<b class="nc"><i>576</i>&nbsp;            }</b>
<i>577</i>&nbsp;
<i>578</i>&nbsp;            if (hasRuns) {
<b class="nc"><i>579</i>&nbsp;                updateBidi( changes );</b>
<b class="nc"><i>580</i>&nbsp;            }</b>
<b class="nc"><i>581</i>&nbsp;</b>
<i>582</i>&nbsp;            changes.end();
<b class="nc"><i>583</i>&nbsp;            fireChangedUpdate(changes);</b>
<b class="nc"><i>584</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</b>
<i>585</i>&nbsp;        } finally {
<i>586</i>&nbsp;            writeUnlock();
<i>587</i>&nbsp;        }
<i>588</i>&nbsp;    }
<i>589</i>&nbsp;
<i>590</i>&nbsp;    /**
<i>591</i>&nbsp;     * Gets the paragraph element at the offset &lt;code&gt;pos&lt;/code&gt;.
<i>592</i>&nbsp;     * A paragraph consists of at least one child Element, which is usually
<i>593</i>&nbsp;     * a leaf.
<i>594</i>&nbsp;     *
<i>595</i>&nbsp;     * @param pos the starting offset &amp;gt;= 0
<i>596</i>&nbsp;     * @return the element
<b class="nc"><i>597</i>&nbsp;     */</b>
<b class="nc"><i>598</i>&nbsp;    public Element getParagraphElement(int pos) {</b>
<b class="nc"><i>599</i>&nbsp;        Element e;</b>
<b class="nc"><i>600</i>&nbsp;        for (e = getDefaultRootElement(); ! e.isLeaf(); ) {</b>
<b class="nc"><i>601</i>&nbsp;            int index = e.getElementIndex(pos);</b>
<b class="nc"><i>602</i>&nbsp;            e = e.getElement(index);</b>
<b class="nc"><i>603</i>&nbsp;        }</b>
<i>604</i>&nbsp;        if(e != null)
<i>605</i>&nbsp;            return e.getParentElement();
<i>606</i>&nbsp;        return e;
<i>607</i>&nbsp;    }
<i>608</i>&nbsp;
<i>609</i>&nbsp;    /**
<i>610</i>&nbsp;     * Gets a character element based on a position.
<i>611</i>&nbsp;     *
<i>612</i>&nbsp;     * @param pos the position in the document &amp;gt;= 0
<i>613</i>&nbsp;     * @return the element
<b class="nc"><i>614</i>&nbsp;     */</b>
<b class="nc"><i>615</i>&nbsp;    public Element getCharacterElement(int pos) {</b>
<b class="nc"><i>616</i>&nbsp;        Element e;</b>
<b class="nc"><i>617</i>&nbsp;        for (e = getDefaultRootElement(); ! e.isLeaf(); ) {</b>
<b class="nc"><i>618</i>&nbsp;            int index = e.getElementIndex(pos);</b>
<i>619</i>&nbsp;            e = e.getElement(index);
<i>620</i>&nbsp;        }
<i>621</i>&nbsp;        return e;
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;
<i>624</i>&nbsp;    // --- local methods -------------------------------------------------
<i>625</i>&nbsp;
<i>626</i>&nbsp;    /**
<i>627</i>&nbsp;     * Updates document structure as a result of text insertion.  This
<i>628</i>&nbsp;     * will happen within a write lock.  This implementation simply
<i>629</i>&nbsp;     * parses the inserted content for line breaks and builds up a set
<i>630</i>&nbsp;     * of instructions for the element buffer.
<i>631</i>&nbsp;     *
<i>632</i>&nbsp;     * @param chng a description of the document change
<b class="nc"><i>633</i>&nbsp;     * @param attr the attributes</b>
<b class="nc"><i>634</i>&nbsp;     */</b>
<b class="nc"><i>635</i>&nbsp;    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {</b>
<b class="nc"><i>636</i>&nbsp;        int offset = chng.getOffset();</b>
<i>637</i>&nbsp;        int length = chng.getLength();
<i>638</i>&nbsp;        if (attr == null) {
<i>639</i>&nbsp;            attr = SimpleAttributeSet.EMPTY;
<i>640</i>&nbsp;        }
<i>641</i>&nbsp;
<b class="nc"><i>642</i>&nbsp;        // Paragraph attributes should come from point after insertion.</b>
<b class="nc"><i>643</i>&nbsp;        // You really only notice this when inserting at a paragraph</b>
<i>644</i>&nbsp;        // boundary.
<b class="nc"><i>645</i>&nbsp;        Element paragraph = getParagraphElement(offset + length);</b>
<b class="nc"><i>646</i>&nbsp;        AttributeSet pattr = paragraph.getAttributes();</b>
<b class="nc"><i>647</i>&nbsp;        // Character attributes should come from actual insertion point.</b>
<b class="nc"><i>648</i>&nbsp;        Element pParagraph = getParagraphElement(offset);</b>
<b class="nc"><i>649</i>&nbsp;        Element run = pParagraph.getElement(pParagraph.getElementIndex</b>
<b class="nc"><i>650</i>&nbsp;                                            (offset));</b>
<i>651</i>&nbsp;        int endOffset = offset + length;
<i>652</i>&nbsp;        boolean insertingAtBoundry = (run.getEndOffset() == endOffset);
<b class="nc"><i>653</i>&nbsp;        AttributeSet cattr = run.getAttributes();</b>
<b class="nc"><i>654</i>&nbsp;</b>
<b class="nc"><i>655</i>&nbsp;        try {</b>
<b class="nc"><i>656</i>&nbsp;            Segment s = new Segment();</b>
<b class="nc"><i>657</i>&nbsp;            Vector&lt;ElementSpec&gt; parseBuffer = new Vector&lt;ElementSpec&gt;();</b>
<i>658</i>&nbsp;            ElementSpec lastStartSpec = null;
<b class="nc"><i>659</i>&nbsp;            boolean insertingAfterNewline = false;</b>
<b class="nc"><i>660</i>&nbsp;            short lastStartDirection = ElementSpec.OriginateDirection;</b>
<b class="nc"><i>661</i>&nbsp;            // Check if the previous character was a newline.</b>
<i>662</i>&nbsp;            if (offset &gt; 0) {
<b class="nc"><i>663</i>&nbsp;                getText(offset - 1, 1, s);</b>
<b class="nc"><i>664</i>&nbsp;                if (s.array[s.offset] == &#39;\n&#39;) {</b>
<b class="nc"><i>665</i>&nbsp;                    // Inserting after a newline.</b>
<i>666</i>&nbsp;                    insertingAfterNewline = true;
<b class="nc"><i>667</i>&nbsp;                    lastStartDirection = createSpecsForInsertAfterNewline</b>
<b class="nc"><i>668</i>&nbsp;                                  (paragraph, pParagraph, pattr, parseBuffer,</b>
<b class="nc"><i>669</i>&nbsp;                                   offset, endOffset);</b>
<b class="nc"><i>670</i>&nbsp;                    for(int counter = parseBuffer.size() - 1; counter &gt;= 0;</b>
<b class="nc"><i>671</i>&nbsp;                        counter--) {</b>
<b class="nc"><i>672</i>&nbsp;                        ElementSpec spec = parseBuffer.elementAt(counter);</b>
<i>673</i>&nbsp;                        if(spec.getType() == ElementSpec.StartTagType) {
<i>674</i>&nbsp;                            lastStartSpec = spec;
<i>675</i>&nbsp;                            break;
<i>676</i>&nbsp;                        }
<i>677</i>&nbsp;                    }
<i>678</i>&nbsp;                }
<b class="nc"><i>679</i>&nbsp;            }</b>
<b class="nc"><i>680</i>&nbsp;            // If not inserting after a new line, pull the attributes for</b>
<i>681</i>&nbsp;            // new paragraphs from the paragraph under the insertion point.
<b class="nc"><i>682</i>&nbsp;            if(!insertingAfterNewline)</b>
<b class="nc"><i>683</i>&nbsp;                pattr = pParagraph.getAttributes();</b>
<b class="nc"><i>684</i>&nbsp;</b>
<b class="nc"><i>685</i>&nbsp;            getText(offset, length, s);</b>
<i>686</i>&nbsp;            char[] txt = s.array;
<b class="nc"><i>687</i>&nbsp;            int n = s.offset + s.count;</b>
<b class="nc"><i>688</i>&nbsp;            int lastOffset = s.offset;</b>
<b class="nc"><i>689</i>&nbsp;</b>
<b class="nc"><i>690</i>&nbsp;            for (int i = s.offset; i &lt; n; i++) {</b>
<i>691</i>&nbsp;                if (txt[i] == &#39;\n&#39;) {
<i>692</i>&nbsp;                    int breakOffset = i + 1;
<b class="nc"><i>693</i>&nbsp;                    parseBuffer.addElement(</b>
<i>694</i>&nbsp;                        new ElementSpec(attr, ElementSpec.ContentType,
<b class="nc"><i>695</i>&nbsp;                                               breakOffset - lastOffset));</b>
<i>696</i>&nbsp;                    parseBuffer.addElement(
<b class="nc"><i>697</i>&nbsp;                        new ElementSpec(null, ElementSpec.EndTagType));</b>
<b class="nc"><i>698</i>&nbsp;                    lastStartSpec = new ElementSpec(pattr, ElementSpec.</b>
<i>699</i>&nbsp;                                                   StartTagType);
<i>700</i>&nbsp;                    parseBuffer.addElement(lastStartSpec);
<b class="nc"><i>701</i>&nbsp;                    lastOffset = breakOffset;</b>
<b class="nc"><i>702</i>&nbsp;                }</b>
<i>703</i>&nbsp;            }
<i>704</i>&nbsp;            if (lastOffset &lt; n) {
<i>705</i>&nbsp;                parseBuffer.addElement(
<i>706</i>&nbsp;                    new ElementSpec(attr, ElementSpec.ContentType,
<b class="nc"><i>707</i>&nbsp;                                           n - lastOffset));</b>
<i>708</i>&nbsp;            }
<b class="nc"><i>709</i>&nbsp;</b>
<i>710</i>&nbsp;            ElementSpec first = parseBuffer.firstElement();
<i>711</i>&nbsp;
<b class="nc"><i>712</i>&nbsp;            int docLength = getLength();</b>
<b class="nc"><i>713</i>&nbsp;</b>
<b class="nc"><i>714</i>&nbsp;            // Check for join previous of first content.</b>
<i>715</i>&nbsp;            if(first.getType() == ElementSpec.ContentType &amp;&amp;
<i>716</i>&nbsp;               cattr.isEqual(attr)) {
<i>717</i>&nbsp;                first.setDirection(ElementSpec.JoinPreviousDirection);
<b class="nc"><i>718</i>&nbsp;            }</b>
<b class="nc"><i>719</i>&nbsp;</b>
<b class="nc"><i>720</i>&nbsp;            // Do a join fracture/next for last start spec if necessary.</b>
<i>721</i>&nbsp;            if(lastStartSpec != null) {
<i>722</i>&nbsp;                if(insertingAfterNewline) {
<i>723</i>&nbsp;                    lastStartSpec.setDirection(lastStartDirection);
<i>724</i>&nbsp;                }
<b class="nc"><i>725</i>&nbsp;                // Join to the fracture if NOT inserting at the end</b>
<b class="nc"><i>726</i>&nbsp;                // (fracture only happens when not inserting at end of</b>
<i>727</i>&nbsp;                // paragraph).
<i>728</i>&nbsp;                else if(pParagraph.getEndOffset() != endOffset) {
<i>729</i>&nbsp;                    lastStartSpec.setDirection(ElementSpec.
<i>730</i>&nbsp;                                               JoinFractureDirection);
<i>731</i>&nbsp;                }
<b class="nc"><i>732</i>&nbsp;                // Join to next if parent of pParagraph has another</b>
<b class="nc"><i>733</i>&nbsp;                // element after pParagraph, and it isn&#39;t a leaf.</b>
<b class="nc"><i>734</i>&nbsp;                else {</b>
<b class="nc"><i>735</i>&nbsp;                    Element parent = pParagraph.getParentElement();</b>
<b class="nc"><i>736</i>&nbsp;                    int pParagraphIndex = parent.getElementIndex(offset);</b>
<i>737</i>&nbsp;                    if((pParagraphIndex + 1) &lt; parent.getElementCount() &amp;&amp;
<i>738</i>&nbsp;                       !parent.getElement(pParagraphIndex + 1).isLeaf()) {
<i>739</i>&nbsp;                        lastStartSpec.setDirection(ElementSpec.
<i>740</i>&nbsp;                                                   JoinNextDirection);
<i>741</i>&nbsp;                    }
<i>742</i>&nbsp;                }
<i>743</i>&nbsp;            }
<i>744</i>&nbsp;
<i>745</i>&nbsp;            // Do a JoinNext for last spec if it is content, it doesn&#39;t
<i>746</i>&nbsp;            // already have a direction set, no new paragraphs have been
<b class="nc"><i>747</i>&nbsp;            // inserted or a new paragraph has been inserted and its join</b>
<b class="nc"><i>748</i>&nbsp;            // direction isn&#39;t originate, and the element at endOffset</b>
<b class="nc"><i>749</i>&nbsp;            // is a leaf.</b>
<b class="nc"><i>750</i>&nbsp;            if(insertingAtBoundry &amp;&amp; endOffset &lt; docLength) {</b>
<i>751</i>&nbsp;                ElementSpec last = parseBuffer.lastElement();
<i>752</i>&nbsp;                if(last.getType() == ElementSpec.ContentType &amp;&amp;
<b class="nc"><i>753</i>&nbsp;                   last.getDirection() != ElementSpec.JoinPreviousDirection &amp;&amp;</b>
<i>754</i>&nbsp;                   ((lastStartSpec == null &amp;&amp; (paragraph == pParagraph ||
<b class="nc"><i>755</i>&nbsp;                                               insertingAfterNewline)) ||</b>
<b class="nc"><i>756</i>&nbsp;                    (lastStartSpec != null &amp;&amp; lastStartSpec.getDirection() !=</b>
<i>757</i>&nbsp;                     ElementSpec.OriginateDirection))) {
<b class="nc"><i>758</i>&nbsp;                    Element nextRun = paragraph.getElement(paragraph.</b>
<b class="nc"><i>759</i>&nbsp;                                           getElementIndex(endOffset));</b>
<b class="nc"><i>760</i>&nbsp;                    // Don&#39;t try joining to a branch!</b>
<i>761</i>&nbsp;                    if(nextRun.isLeaf() &amp;&amp;
<i>762</i>&nbsp;                       attr.isEqual(nextRun.getAttributes())) {
<b class="nc"><i>763</i>&nbsp;                        last.setDirection(ElementSpec.JoinNextDirection);</b>
<i>764</i>&nbsp;                    }
<i>765</i>&nbsp;                }
<i>766</i>&nbsp;            }
<b class="nc"><i>767</i>&nbsp;            // If not inserting at boundary and there is going to be a</b>
<b class="nc"><i>768</i>&nbsp;            // fracture, then can join next on last content if cattr</b>
<i>769</i>&nbsp;            // matches the new attributes.
<b class="nc"><i>770</i>&nbsp;            else if(!insertingAtBoundry &amp;&amp; lastStartSpec != null &amp;&amp;</b>
<b class="nc"><i>771</i>&nbsp;                    lastStartSpec.getDirection() ==</b>
<b class="nc"><i>772</i>&nbsp;                    ElementSpec.JoinFractureDirection) {</b>
<b class="nc"><i>773</i>&nbsp;                ElementSpec last = parseBuffer.lastElement();</b>
<b class="nc"><i>774</i>&nbsp;                if(last.getType() == ElementSpec.ContentType &amp;&amp;</b>
<i>775</i>&nbsp;                   last.getDirection() != ElementSpec.JoinPreviousDirection &amp;&amp;
<i>776</i>&nbsp;                   attr.isEqual(cattr)) {
<i>777</i>&nbsp;                    last.setDirection(ElementSpec.JoinNextDirection);
<i>778</i>&nbsp;                }
<i>779</i>&nbsp;            }
<b class="nc"><i>780</i>&nbsp;</b>
<b class="nc"><i>781</i>&nbsp;            // Check for the composed text element. If it is, merge the character attributes</b>
<b class="nc"><i>782</i>&nbsp;            // into this element as well.</b>
<b class="nc"><i>783</i>&nbsp;            if (Utilities.isComposedTextAttributeDefined(attr)) {</b>
<i>784</i>&nbsp;                MutableAttributeSet mattr = (MutableAttributeSet) attr;
<i>785</i>&nbsp;                mattr.addAttributes(cattr);
<i>786</i>&nbsp;                mattr.addAttribute(AbstractDocument.ElementNameAttribute,
<i>787</i>&nbsp;                        AbstractDocument.ContentElementName);
<b class="nc"><i>788</i>&nbsp;</b>
<i>789</i>&nbsp;                // Assure that the composed text element is named properly
<b class="nc"><i>790</i>&nbsp;                // and doesn&#39;t have the CR attribute defined.</b>
<b class="nc"><i>791</i>&nbsp;                mattr.addAttribute(StyleConstants.NameAttribute,</b>
<i>792</i>&nbsp;                        AbstractDocument.ContentElementName);
<i>793</i>&nbsp;                if (mattr.isDefined(IMPLIED_CR)) {
<i>794</i>&nbsp;                    mattr.removeAttribute(IMPLIED_CR);
<b class="nc"><i>795</i>&nbsp;                }</b>
<b class="nc"><i>796</i>&nbsp;            }</b>
<b class="nc"><i>797</i>&nbsp;</b>
<b class="nc"><i>798</i>&nbsp;            ElementSpec[] spec = new ElementSpec[parseBuffer.size()];</b>
<b class="nc"><i>799</i>&nbsp;            parseBuffer.copyInto(spec);</b>
<i>800</i>&nbsp;            buffer.insert(offset, length, spec, chng);
<b class="nc"><i>801</i>&nbsp;        } catch (BadLocationException bl) {</b>
<i>802</i>&nbsp;        }
<i>803</i>&nbsp;
<i>804</i>&nbsp;        super.insertUpdate( chng, attr );
<i>805</i>&nbsp;    }
<i>806</i>&nbsp;
<i>807</i>&nbsp;    /**
<i>808</i>&nbsp;     * This is called by insertUpdate when inserting after a new line.
<i>809</i>&nbsp;     * It generates, in &lt;code&gt;parseBuffer&lt;/code&gt;, ElementSpecs that will
<i>810</i>&nbsp;     * position the stack in &lt;code&gt;paragraph&lt;/code&gt;.&lt;p&gt;
<i>811</i>&nbsp;     * It returns the direction the last StartSpec should have (this don&#39;t
<i>812</i>&nbsp;     * necessarily create the last start spec).
<i>813</i>&nbsp;     */
<i>814</i>&nbsp;    short createSpecsForInsertAfterNewline(Element paragraph,
<b class="nc"><i>815</i>&nbsp;            Element pParagraph, AttributeSet pattr, Vector&lt;ElementSpec&gt; parseBuffer,</b>
<i>816</i>&nbsp;                                                 int offset, int endOffset) {
<i>817</i>&nbsp;        // Need to find the common parent of pParagraph and paragraph.
<b class="nc"><i>818</i>&nbsp;        if(paragraph.getParentElement() == pParagraph.getParentElement()) {</b>
<b class="nc"><i>819</i>&nbsp;            // The simple (and common) case that pParagraph and</b>
<b class="nc"><i>820</i>&nbsp;            // paragraph have the same parent.</b>
<b class="nc"><i>821</i>&nbsp;            ElementSpec spec = new ElementSpec(pattr, ElementSpec.EndTagType);</b>
<b class="nc"><i>822</i>&nbsp;            parseBuffer.addElement(spec);</b>
<b class="nc"><i>823</i>&nbsp;            spec = new ElementSpec(pattr, ElementSpec.StartTagType);</b>
<i>824</i>&nbsp;            parseBuffer.addElement(spec);
<b class="nc"><i>825</i>&nbsp;            if(pParagraph.getEndOffset() != endOffset)</b>
<b class="nc"><i>826</i>&nbsp;                return ElementSpec.JoinFractureDirection;</b>
<b class="nc"><i>827</i>&nbsp;</b>
<b class="nc"><i>828</i>&nbsp;            Element parent = pParagraph.getParentElement();</b>
<i>829</i>&nbsp;            if((parent.getElementIndex(offset) + 1) &lt; parent.getElementCount())
<i>830</i>&nbsp;                return ElementSpec.JoinNextDirection;
<i>831</i>&nbsp;        }
<b class="nc"><i>832</i>&nbsp;        else {</b>
<b class="nc"><i>833</i>&nbsp;            // Will only happen for text with more than 2 levels.</b>
<b class="nc"><i>834</i>&nbsp;            // Find the common parent of a paragraph and pParagraph</b>
<b class="nc"><i>835</i>&nbsp;            Vector&lt;Element&gt; leftParents = new Vector&lt;Element&gt;();</b>
<b class="nc"><i>836</i>&nbsp;            Vector&lt;Element&gt; rightParents = new Vector&lt;Element&gt;();</b>
<b class="nc"><i>837</i>&nbsp;            Element e = pParagraph;</b>
<i>838</i>&nbsp;            while(e != null) {
<b class="nc"><i>839</i>&nbsp;                leftParents.addElement(e);</b>
<b class="nc"><i>840</i>&nbsp;                e = e.getParentElement();</b>
<b class="nc"><i>841</i>&nbsp;            }</b>
<b class="nc"><i>842</i>&nbsp;            e = paragraph;</b>
<b class="nc"><i>843</i>&nbsp;            int leftIndex = -1;</b>
<i>844</i>&nbsp;            while(e != null &amp;&amp; (leftIndex = leftParents.indexOf(e)) == -1) {
<b class="nc"><i>845</i>&nbsp;                rightParents.addElement(e);</b>
<i>846</i>&nbsp;                e = e.getParentElement();
<i>847</i>&nbsp;            }
<b class="nc"><i>848</i>&nbsp;            if(e != null) {</b>
<b class="nc"><i>849</i>&nbsp;                // e identifies the common parent.</b>
<b class="nc"><i>850</i>&nbsp;                // Build the ends.</b>
<i>851</i>&nbsp;                for(int counter = 0; counter &lt; leftIndex;
<i>852</i>&nbsp;                    counter++) {
<i>853</i>&nbsp;                    parseBuffer.addElement(new ElementSpec
<i>854</i>&nbsp;                                              (null, ElementSpec.EndTagType));
<b class="nc"><i>855</i>&nbsp;                }</b>
<b class="nc"><i>856</i>&nbsp;                // And the starts.</b>
<b class="nc"><i>857</i>&nbsp;                ElementSpec spec;</b>
<i>858</i>&nbsp;                for(int counter = rightParents.size() - 1;
<b class="nc"><i>859</i>&nbsp;                    counter &gt;= 0; counter--) {</b>
<b class="nc"><i>860</i>&nbsp;                    spec = new ElementSpec(rightParents.elementAt(counter).getAttributes(),</b>
<b class="nc"><i>861</i>&nbsp;                                   ElementSpec.StartTagType);</b>
<i>862</i>&nbsp;                    if(counter &gt; 0)
<i>863</i>&nbsp;                        spec.setDirection(ElementSpec.JoinNextDirection);
<i>864</i>&nbsp;                    parseBuffer.addElement(spec);
<i>865</i>&nbsp;                }
<b class="nc"><i>866</i>&nbsp;                // If there are right parents, then we generated starts</b>
<b class="nc"><i>867</i>&nbsp;                // down the right subtree and there will be an element to</b>
<i>868</i>&nbsp;                // join to.
<i>869</i>&nbsp;                if(rightParents.size() &gt; 0)
<b class="nc"><i>870</i>&nbsp;                    return ElementSpec.JoinNextDirection;</b>
<i>871</i>&nbsp;                // No right subtree, e.getElement(endOffset) is a
<i>872</i>&nbsp;                // leaf. There will be a facture.
<i>873</i>&nbsp;                return ElementSpec.JoinFractureDirection;
<b class="nc"><i>874</i>&nbsp;            }</b>
<i>875</i>&nbsp;            // else: Could throw an exception here, but should never get here!
<i>876</i>&nbsp;        }
<i>877</i>&nbsp;        return ElementSpec.OriginateDirection;
<i>878</i>&nbsp;    }
<i>879</i>&nbsp;
<i>880</i>&nbsp;    /**
<i>881</i>&nbsp;     * Updates document structure as a result of text removal.
<i>882</i>&nbsp;     *
<b class="nc"><i>883</i>&nbsp;     * @param chng a description of the document change</b>
<b class="nc"><i>884</i>&nbsp;     */</b>
<i>885</i>&nbsp;    protected void removeUpdate(DefaultDocumentEvent chng) {
<i>886</i>&nbsp;        super.removeUpdate(chng);
<i>887</i>&nbsp;        buffer.remove(chng.getOffset(), chng.getLength(), chng);
<i>888</i>&nbsp;    }
<i>889</i>&nbsp;
<i>890</i>&nbsp;    /**
<i>891</i>&nbsp;     * Creates the root element to be used to represent the
<i>892</i>&nbsp;     * default document structure.
<i>893</i>&nbsp;     *
<i>894</i>&nbsp;     * @return the element base
<i>895</i>&nbsp;     */
<i>896</i>&nbsp;    protected AbstractElement createDefaultRoot() {
<i>897</i>&nbsp;        // grabs a write-lock for this initialization and
<b class="nc"><i>898</i>&nbsp;        // abandon it during initialization so in normal</b>
<b class="nc"><i>899</i>&nbsp;        // operation we can detect an illegitimate attempt</b>
<b class="nc"><i>900</i>&nbsp;        // to mutate attributes.</b>
<i>901</i>&nbsp;        writeLock();
<b class="nc"><i>902</i>&nbsp;        BranchElement section = new SectionElement();</b>
<b class="nc"><i>903</i>&nbsp;        BranchElement paragraph = new BranchElement(section, null);</b>
<b class="nc"><i>904</i>&nbsp;</b>
<b class="nc"><i>905</i>&nbsp;        LeafElement brk = new LeafElement(paragraph, null, 0, 1);</b>
<i>906</i>&nbsp;        Element[] buff = new Element[1];
<b class="nc"><i>907</i>&nbsp;        buff[0] = brk;</b>
<b class="nc"><i>908</i>&nbsp;        paragraph.replace(0, 0, buff);</b>
<b class="nc"><i>909</i>&nbsp;</b>
<b class="nc"><i>910</i>&nbsp;        buff[0] = paragraph;</b>
<i>911</i>&nbsp;        section.replace(0, 0, buff);
<i>912</i>&nbsp;        writeUnlock();
<i>913</i>&nbsp;        return section;
<i>914</i>&nbsp;    }
<i>915</i>&nbsp;
<i>916</i>&nbsp;    /**
<i>917</i>&nbsp;     * Gets the foreground color from an attribute set.
<i>918</i>&nbsp;     *
<i>919</i>&nbsp;     * @param attr the attribute set
<b class="nc"><i>920</i>&nbsp;     * @return the color</b>
<b class="nc"><i>921</i>&nbsp;     */</b>
<i>922</i>&nbsp;    public Color getForeground(AttributeSet attr) {
<i>923</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>924</i>&nbsp;        return styles.getForeground(attr);
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<i>927</i>&nbsp;    /**
<i>928</i>&nbsp;     * Gets the background color from an attribute set.
<i>929</i>&nbsp;     *
<i>930</i>&nbsp;     * @param attr the attribute set
<b class="nc"><i>931</i>&nbsp;     * @return the color</b>
<b class="nc"><i>932</i>&nbsp;     */</b>
<i>933</i>&nbsp;    public Color getBackground(AttributeSet attr) {
<i>934</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>935</i>&nbsp;        return styles.getBackground(attr);
<i>936</i>&nbsp;    }
<i>937</i>&nbsp;
<i>938</i>&nbsp;    /**
<i>939</i>&nbsp;     * Gets the font from an attribute set.
<i>940</i>&nbsp;     *
<i>941</i>&nbsp;     * @param attr the attribute set
<b class="nc"><i>942</i>&nbsp;     * @return the font</b>
<b class="nc"><i>943</i>&nbsp;     */</b>
<i>944</i>&nbsp;    public Font getFont(AttributeSet attr) {
<i>945</i>&nbsp;        StyleContext styles = (StyleContext) getAttributeContext();
<i>946</i>&nbsp;        return styles.getFont(attr);
<i>947</i>&nbsp;    }
<i>948</i>&nbsp;
<i>949</i>&nbsp;    /**
<i>950</i>&nbsp;     * Called when any of this document&#39;s styles have changed.
<i>951</i>&nbsp;     * Subclasses may wish to be intelligent about what gets damaged.
<i>952</i>&nbsp;     *
<i>953</i>&nbsp;     * @param style The Style that has changed.
<b class="nc"><i>954</i>&nbsp;     */</b>
<i>955</i>&nbsp;    protected void styleChanged(Style style) {
<b class="nc"><i>956</i>&nbsp;        // Only propagate change updated if have content</b>
<b class="nc"><i>957</i>&nbsp;        if (getLength() != 0) {</b>
<i>958</i>&nbsp;            // lazily create a ChangeUpdateRunnable
<i>959</i>&nbsp;            if (updateRunnable == null) {
<i>960</i>&nbsp;                updateRunnable = new ChangeUpdateRunnable();
<i>961</i>&nbsp;            }
<b class="nc"><i>962</i>&nbsp;</b>
<b class="nc"><i>963</i>&nbsp;            // We may get a whole batch of these at once, so only</b>
<b class="nc"><i>964</i>&nbsp;            // queue the runnable if it is not already pending</b>
<b class="nc"><i>965</i>&nbsp;            synchronized(updateRunnable) {</b>
<i>966</i>&nbsp;                if (!updateRunnable.isPending) {
<b class="nc"><i>967</i>&nbsp;                    SwingUtilities.invokeLater(updateRunnable);</b>
<i>968</i>&nbsp;                    updateRunnable.isPending = true;
<i>969</i>&nbsp;                }
<i>970</i>&nbsp;            }
<i>971</i>&nbsp;        }
<i>972</i>&nbsp;    }
<i>973</i>&nbsp;
<i>974</i>&nbsp;    /**
<i>975</i>&nbsp;     * Adds a document listener for notification of any changes.
<i>976</i>&nbsp;     *
<i>977</i>&nbsp;     * @param listener the listener
<b class="nc"><i>978</i>&nbsp;     * @see Document#addDocumentListener</b>
<b class="nc"><i>979</i>&nbsp;     */</b>
<b class="nc"><i>980</i>&nbsp;    public void addDocumentListener(DocumentListener listener) {</b>
<b class="nc"><i>981</i>&nbsp;        synchronized(listeningStyles) {</b>
<b class="nc"><i>982</i>&nbsp;            int oldDLCount = listenerList.getListenerCount</b>
<b class="nc"><i>983</i>&nbsp;                                          (DocumentListener.class);</b>
<b class="nc"><i>984</i>&nbsp;            super.addDocumentListener(listener);</b>
<b class="nc"><i>985</i>&nbsp;            if (oldDLCount == 0) {</b>
<i>986</i>&nbsp;                if (styleContextChangeListener == null) {
<b class="nc"><i>987</i>&nbsp;                    styleContextChangeListener =</b>
<b class="nc"><i>988</i>&nbsp;                                      createStyleContextChangeListener();</b>
<b class="nc"><i>989</i>&nbsp;                }</b>
<b class="nc"><i>990</i>&nbsp;                if (styleContextChangeListener != null) {</b>
<b class="nc"><i>991</i>&nbsp;                    StyleContext styles = (StyleContext)getAttributeContext();</b>
<b class="nc"><i>992</i>&nbsp;                    List&lt;ChangeListener&gt; staleListeners =</b>
<b class="nc"><i>993</i>&nbsp;                        AbstractChangeHandler.getStaleListeners(styleContextChangeListener);</b>
<b class="nc"><i>994</i>&nbsp;                    for (ChangeListener l: staleListeners) {</b>
<i>995</i>&nbsp;                        styles.removeChangeListener(l);
<b class="nc"><i>996</i>&nbsp;                    }</b>
<i>997</i>&nbsp;                    styles.addChangeListener(styleContextChangeListener);
<b class="nc"><i>998</i>&nbsp;                }</b>
<i>999</i>&nbsp;                updateStylesListeningTo();
<i>1000</i>&nbsp;            }
<i>1001</i>&nbsp;        }
<i>1002</i>&nbsp;    }
<i>1003</i>&nbsp;
<i>1004</i>&nbsp;    /**
<i>1005</i>&nbsp;     * Removes a document listener.
<i>1006</i>&nbsp;     *
<i>1007</i>&nbsp;     * @param listener the listener
<b class="nc"><i>1008</i>&nbsp;     * @see Document#removeDocumentListener</b>
<b class="nc"><i>1009</i>&nbsp;     */</b>
<b class="nc"><i>1010</i>&nbsp;    public void removeDocumentListener(DocumentListener listener) {</b>
<b class="nc"><i>1011</i>&nbsp;        synchronized(listeningStyles) {</b>
<b class="nc"><i>1012</i>&nbsp;            super.removeDocumentListener(listener);</b>
<b class="nc"><i>1013</i>&nbsp;            if (listenerList.getListenerCount(DocumentListener.class) == 0) {</b>
<b class="nc"><i>1014</i>&nbsp;                for (int counter = listeningStyles.size() - 1; counter &gt;= 0;</b>
<i>1015</i>&nbsp;                     counter--) {
<b class="nc"><i>1016</i>&nbsp;                    listeningStyles.elementAt(counter).</b>
<b class="nc"><i>1017</i>&nbsp;                                    removeChangeListener(styleChangeListener);</b>
<b class="nc"><i>1018</i>&nbsp;                }</b>
<b class="nc"><i>1019</i>&nbsp;                listeningStyles.removeAllElements();</b>
<i>1020</i>&nbsp;                if (styleContextChangeListener != null) {
<i>1021</i>&nbsp;                    StyleContext styles = (StyleContext)getAttributeContext();
<b class="nc"><i>1022</i>&nbsp;                    styles.removeChangeListener(styleContextChangeListener);</b>
<i>1023</i>&nbsp;                }
<i>1024</i>&nbsp;            }
<i>1025</i>&nbsp;        }
<i>1026</i>&nbsp;    }
<i>1027</i>&nbsp;
<i>1028</i>&nbsp;    /**
<b class="nc"><i>1029</i>&nbsp;     * Returns a new instance of StyleChangeHandler.</b>
<i>1030</i>&nbsp;     */
<i>1031</i>&nbsp;    ChangeListener createStyleChangeListener() {
<i>1032</i>&nbsp;        return new StyleChangeHandler(this);
<i>1033</i>&nbsp;    }
<i>1034</i>&nbsp;
<i>1035</i>&nbsp;    /**
<b class="nc"><i>1036</i>&nbsp;     * Returns a new instance of StyleContextChangeHandler.</b>
<i>1037</i>&nbsp;     */
<i>1038</i>&nbsp;    ChangeListener createStyleContextChangeListener() {
<i>1039</i>&nbsp;        return new StyleContextChangeHandler(this);
<i>1040</i>&nbsp;    }
<i>1041</i>&nbsp;
<i>1042</i>&nbsp;    /**
<i>1043</i>&nbsp;     * Adds a ChangeListener to new styles, and removes ChangeListener from
<b class="nc"><i>1044</i>&nbsp;     * old styles.</b>
<b class="nc"><i>1045</i>&nbsp;     */</b>
<b class="nc"><i>1046</i>&nbsp;    void updateStylesListeningTo() {</b>
<b class="nc"><i>1047</i>&nbsp;        synchronized(listeningStyles) {</b>
<i>1048</i>&nbsp;            StyleContext styles = (StyleContext)getAttributeContext();
<b class="nc"><i>1049</i>&nbsp;            if (styleChangeListener == null) {</b>
<b class="nc"><i>1050</i>&nbsp;                styleChangeListener = createStyleChangeListener();</b>
<b class="nc"><i>1051</i>&nbsp;            }</b>
<b class="nc"><i>1052</i>&nbsp;            if (styleChangeListener != null &amp;&amp; styles != null) {</b>
<b class="nc"><i>1053</i>&nbsp;                Enumeration&lt;?&gt; styleNames = styles.getStyleNames();</b>
<b class="nc"><i>1054</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1055</i>&nbsp;                Vector&lt;Style&gt; v = (Vector&lt;Style&gt;)listeningStyles.clone();</b>
<b class="nc"><i>1056</i>&nbsp;                listeningStyles.removeAllElements();</b>
<b class="nc"><i>1057</i>&nbsp;                List&lt;ChangeListener&gt; staleListeners =</b>
<b class="nc"><i>1058</i>&nbsp;                    AbstractChangeHandler.getStaleListeners(styleChangeListener);</b>
<b class="nc"><i>1059</i>&nbsp;                while (styleNames.hasMoreElements()) {</b>
<b class="nc"><i>1060</i>&nbsp;                    String name = (String)styleNames.nextElement();</b>
<b class="nc"><i>1061</i>&nbsp;                    Style aStyle = styles.getStyle(name);</b>
<b class="nc"><i>1062</i>&nbsp;                    int index = v.indexOf(aStyle);</b>
<b class="nc"><i>1063</i>&nbsp;                    listeningStyles.addElement(aStyle);</b>
<b class="nc"><i>1064</i>&nbsp;                    if (index == -1) {</b>
<i>1065</i>&nbsp;                        for (ChangeListener l: staleListeners) {
<i>1066</i>&nbsp;                            aStyle.removeChangeListener(l);
<b class="nc"><i>1067</i>&nbsp;                        }</b>
<i>1068</i>&nbsp;                        aStyle.addChangeListener(styleChangeListener);
<b class="nc"><i>1069</i>&nbsp;                    }</b>
<b class="nc"><i>1070</i>&nbsp;                    else {</b>
<b class="nc"><i>1071</i>&nbsp;                        v.removeElementAt(index);</b>
<b class="nc"><i>1072</i>&nbsp;                    }</b>
<i>1073</i>&nbsp;                }
<b class="nc"><i>1074</i>&nbsp;                for (int counter = v.size() - 1; counter &gt;= 0; counter--) {</b>
<b class="nc"><i>1075</i>&nbsp;                    Style aStyle = v.elementAt(counter);</b>
<i>1076</i>&nbsp;                    aStyle.removeChangeListener(styleChangeListener);
<i>1077</i>&nbsp;                }
<b class="nc"><i>1078</i>&nbsp;                if (listeningStyles.size() == 0) {</b>
<i>1079</i>&nbsp;                    styleChangeListener = null;
<i>1080</i>&nbsp;                }
<i>1081</i>&nbsp;            }
<i>1082</i>&nbsp;        }
<b class="nc"><i>1083</i>&nbsp;    }</b>
<b class="nc"><i>1084</i>&nbsp;</b>
<i>1085</i>&nbsp;    private void readObject(ObjectInputStream s)
<b class="nc"><i>1086</i>&nbsp;            throws ClassNotFoundException, IOException {</b>
<b class="nc"><i>1087</i>&nbsp;        listeningStyles = new Vector&lt;&gt;();</b>
<b class="nc"><i>1088</i>&nbsp;        ObjectInputStream.GetField f = s.readFields();</b>
<b class="nc"><i>1089</i>&nbsp;        buffer = (ElementBuffer) f.get(&quot;buffer&quot;, null);</b>
<b class="nc"><i>1090</i>&nbsp;        // Reinstall style listeners.</b>
<b class="nc"><i>1091</i>&nbsp;        if (styleContextChangeListener == null &amp;&amp;</b>
<i>1092</i>&nbsp;            listenerList.getListenerCount(DocumentListener.class) &gt; 0) {
<b class="nc"><i>1093</i>&nbsp;            styleContextChangeListener = createStyleContextChangeListener();</b>
<i>1094</i>&nbsp;            if (styleContextChangeListener != null) {
<i>1095</i>&nbsp;                StyleContext styles = (StyleContext)getAttributeContext();
<i>1096</i>&nbsp;                styles.addChangeListener(styleContextChangeListener);
<i>1097</i>&nbsp;            }
<i>1098</i>&nbsp;            updateStylesListeningTo();
<i>1099</i>&nbsp;        }
<i>1100</i>&nbsp;    }
<i>1101</i>&nbsp;
<i>1102</i>&nbsp;    // --- member variables -----------------------------------------------------------
<i>1103</i>&nbsp;
<i>1104</i>&nbsp;    /**
<i>1105</i>&nbsp;     * The default size of the initial content buffer.
<i>1106</i>&nbsp;     */
<i>1107</i>&nbsp;    public static final int BUFFER_SIZE_DEFAULT = 4096;
<i>1108</i>&nbsp;
<i>1109</i>&nbsp;    /**
<i>1110</i>&nbsp;     * The element buffer.
<i>1111</i>&nbsp;     */
<i>1112</i>&nbsp;    protected ElementBuffer buffer;
<i>1113</i>&nbsp;
<i>1114</i>&nbsp;    /** Styles listening to. */
<i>1115</i>&nbsp;    private transient Vector&lt;Style&gt; listeningStyles;
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;    /** Listens to Styles. */
<i>1118</i>&nbsp;    private transient ChangeListener styleChangeListener;
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;    /** Listens to Styles. */
<i>1121</i>&nbsp;    private transient ChangeListener styleContextChangeListener;
<i>1122</i>&nbsp;
<i>1123</i>&nbsp;    /** Run to create a change event for the document */
<i>1124</i>&nbsp;    private transient ChangeUpdateRunnable updateRunnable;
<i>1125</i>&nbsp;
<i>1126</i>&nbsp;    /**
<i>1127</i>&nbsp;     * Default root element for a document... maps out the
<i>1128</i>&nbsp;     * paragraphs/lines contained.
<i>1129</i>&nbsp;     * &lt;p&gt;
<i>1130</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>1131</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>1132</i>&nbsp;     * future Swing releases. The current serialization support is
<i>1133</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>1134</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>1135</i>&nbsp;     * of all JavaBeans&amp;trade;
<b class="nc"><i>1136</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.</b>
<b class="nc"><i>1137</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.</b>
<i>1138</i>&nbsp;     */
<i>1139</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>1140</i>&nbsp;    protected class SectionElement extends BranchElement {
<i>1141</i>&nbsp;
<i>1142</i>&nbsp;        /**
<i>1143</i>&nbsp;         * Creates a new SectionElement.
<i>1144</i>&nbsp;         */
<i>1145</i>&nbsp;        public SectionElement() {
<b class="nc"><i>1146</i>&nbsp;            super(null, null);</b>
<i>1147</i>&nbsp;        }
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;        /**
<i>1150</i>&nbsp;         * Gets the name of the element.
<i>1151</i>&nbsp;         *
<i>1152</i>&nbsp;         * @return the name
<i>1153</i>&nbsp;         */
<i>1154</i>&nbsp;        public String getName() {
<i>1155</i>&nbsp;            return SectionElementName;
<i>1156</i>&nbsp;        }
<i>1157</i>&nbsp;    }
<i>1158</i>&nbsp;
<i>1159</i>&nbsp;    /**
<i>1160</i>&nbsp;     * Specification for building elements.
<i>1161</i>&nbsp;     * &lt;p&gt;
<i>1162</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>1163</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>1164</i>&nbsp;     * future Swing releases. The current serialization support is
<i>1165</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>1166</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>1167</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>1168</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<i>1169</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.
<i>1170</i>&nbsp;     */
<i>1171</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>1172</i>&nbsp;    public static class ElementSpec {
<i>1173</i>&nbsp;
<i>1174</i>&nbsp;        /**
<i>1175</i>&nbsp;         * A possible value for getType.  This specifies
<i>1176</i>&nbsp;         * that this record type is a start tag and
<i>1177</i>&nbsp;         * represents markup that specifies the start
<i>1178</i>&nbsp;         * of an element.
<i>1179</i>&nbsp;         */
<i>1180</i>&nbsp;        public static final short StartTagType = 1;
<i>1181</i>&nbsp;
<i>1182</i>&nbsp;        /**
<i>1183</i>&nbsp;         * A possible value for getType.  This specifies
<i>1184</i>&nbsp;         * that this record type is a end tag and
<i>1185</i>&nbsp;         * represents markup that specifies the end
<i>1186</i>&nbsp;         * of an element.
<i>1187</i>&nbsp;         */
<i>1188</i>&nbsp;        public static final short EndTagType = 2;
<i>1189</i>&nbsp;
<i>1190</i>&nbsp;        /**
<i>1191</i>&nbsp;         * A possible value for getType.  This specifies
<i>1192</i>&nbsp;         * that this record type represents content.
<i>1193</i>&nbsp;         */
<i>1194</i>&nbsp;        public static final short ContentType = 3;
<i>1195</i>&nbsp;
<i>1196</i>&nbsp;        /**
<i>1197</i>&nbsp;         * A possible value for getDirection.  This specifies
<i>1198</i>&nbsp;         * that the data associated with this record should
<i>1199</i>&nbsp;         * be joined to what precedes it.
<i>1200</i>&nbsp;         */
<i>1201</i>&nbsp;        public static final short JoinPreviousDirection = 4;
<i>1202</i>&nbsp;
<i>1203</i>&nbsp;        /**
<i>1204</i>&nbsp;         * A possible value for getDirection.  This specifies
<i>1205</i>&nbsp;         * that the data associated with this record should
<i>1206</i>&nbsp;         * be joined to what follows it.
<i>1207</i>&nbsp;         */
<i>1208</i>&nbsp;        public static final short JoinNextDirection = 5;
<i>1209</i>&nbsp;
<i>1210</i>&nbsp;        /**
<i>1211</i>&nbsp;         * A possible value for getDirection.  This specifies
<i>1212</i>&nbsp;         * that the data associated with this record should
<i>1213</i>&nbsp;         * be used to originate a new element.  This would be
<i>1214</i>&nbsp;         * the normal value.
<i>1215</i>&nbsp;         */
<i>1216</i>&nbsp;        public static final short OriginateDirection = 6;
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;        /**
<i>1219</i>&nbsp;         * A possible value for getDirection.  This specifies
<i>1220</i>&nbsp;         * that the data associated with this record should
<i>1221</i>&nbsp;         * be joined to the fractured element.
<i>1222</i>&nbsp;         */
<i>1223</i>&nbsp;        public static final short JoinFractureDirection = 7;
<i>1224</i>&nbsp;
<b class="nc"><i>1225</i>&nbsp;</b>
<i>1226</i>&nbsp;        /**
<i>1227</i>&nbsp;         * Constructor useful for markup when the markup will not
<i>1228</i>&nbsp;         * be stored in the document.
<i>1229</i>&nbsp;         *
<i>1230</i>&nbsp;         * @param a the attributes for the element
<i>1231</i>&nbsp;         * @param type the type of the element (StartTagType, EndTagType,
<i>1232</i>&nbsp;         *  ContentType)
<i>1233</i>&nbsp;         */
<i>1234</i>&nbsp;        public ElementSpec(AttributeSet a, short type) {
<i>1235</i>&nbsp;            this(a, type, null, 0, 0);
<i>1236</i>&nbsp;        }
<i>1237</i>&nbsp;
<i>1238</i>&nbsp;        /**
<b class="nc"><i>1239</i>&nbsp;         * Constructor for parsing inside the document when</b>
<i>1240</i>&nbsp;         * the data has already been added, but len information
<i>1241</i>&nbsp;         * is needed.
<i>1242</i>&nbsp;         *
<i>1243</i>&nbsp;         * @param a the attributes for the element
<i>1244</i>&nbsp;         * @param type the type of the element (StartTagType, EndTagType,
<i>1245</i>&nbsp;         *  ContentType)
<i>1246</i>&nbsp;         * @param len the length &amp;gt;= 0
<i>1247</i>&nbsp;         */
<i>1248</i>&nbsp;        public ElementSpec(AttributeSet a, short type, int len) {
<i>1249</i>&nbsp;            this(a, type, null, 0, len);
<i>1250</i>&nbsp;        }
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;        /**
<i>1253</i>&nbsp;         * Constructor for creating a spec externally for batch
<b class="nc"><i>1254</i>&nbsp;         * input of content and markup into the document.</b>
<b class="nc"><i>1255</i>&nbsp;         *</b>
<b class="nc"><i>1256</i>&nbsp;         * @param a the attributes for the element</b>
<b class="nc"><i>1257</i>&nbsp;         * @param type the type of the element (StartTagType, EndTagType,</b>
<b class="nc"><i>1258</i>&nbsp;         *  ContentType)</b>
<b class="nc"><i>1259</i>&nbsp;         * @param txt the text for the element</b>
<b class="nc"><i>1260</i>&nbsp;         * @param offs the offset into the text &amp;gt;= 0</b>
<i>1261</i>&nbsp;         * @param len the length of the text &amp;gt;= 0
<i>1262</i>&nbsp;         */
<i>1263</i>&nbsp;        public ElementSpec(AttributeSet a, short type, char[] txt,
<i>1264</i>&nbsp;                                  int offs, int len) {
<i>1265</i>&nbsp;            attr = a;
<i>1266</i>&nbsp;            this.type = type;
<i>1267</i>&nbsp;            this.data = txt == null ? null : Arrays.copyOf(txt, txt.length);
<i>1268</i>&nbsp;            this.offs = offs;
<i>1269</i>&nbsp;            this.len = len;
<b class="nc"><i>1270</i>&nbsp;            this.direction = OriginateDirection;</b>
<i>1271</i>&nbsp;        }
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;        /**
<i>1274</i>&nbsp;         * Sets the element type.
<i>1275</i>&nbsp;         *
<i>1276</i>&nbsp;         * @param type the type of the element (StartTagType, EndTagType,
<i>1277</i>&nbsp;         *  ContentType)
<i>1278</i>&nbsp;         */
<i>1279</i>&nbsp;        public void setType(short type) {
<b class="nc"><i>1280</i>&nbsp;            this.type = type;</b>
<i>1281</i>&nbsp;        }
<i>1282</i>&nbsp;
<i>1283</i>&nbsp;        /**
<i>1284</i>&nbsp;         * Gets the element type.
<i>1285</i>&nbsp;         *
<i>1286</i>&nbsp;         * @return  the type of the element (StartTagType, EndTagType,
<i>1287</i>&nbsp;         *  ContentType)
<i>1288</i>&nbsp;         */
<i>1289</i>&nbsp;        public short getType() {
<b class="nc"><i>1290</i>&nbsp;            return type;</b>
<i>1291</i>&nbsp;        }
<i>1292</i>&nbsp;
<i>1293</i>&nbsp;        /**
<i>1294</i>&nbsp;         * Sets the direction.
<i>1295</i>&nbsp;         *
<i>1296</i>&nbsp;         * @param direction the direction (JoinPreviousDirection,
<i>1297</i>&nbsp;         *   JoinNextDirection)
<i>1298</i>&nbsp;         */
<b class="nc"><i>1299</i>&nbsp;        public void setDirection(short direction) {</b>
<i>1300</i>&nbsp;            this.direction = direction;
<i>1301</i>&nbsp;        }
<i>1302</i>&nbsp;
<i>1303</i>&nbsp;        /**
<i>1304</i>&nbsp;         * Gets the direction.
<i>1305</i>&nbsp;         *
<i>1306</i>&nbsp;         * @return the direction (JoinPreviousDirection, JoinNextDirection)
<i>1307</i>&nbsp;         */
<b class="nc"><i>1308</i>&nbsp;        public short getDirection() {</b>
<i>1309</i>&nbsp;            return direction;
<i>1310</i>&nbsp;        }
<i>1311</i>&nbsp;
<i>1312</i>&nbsp;        /**
<i>1313</i>&nbsp;         * Gets the element attributes.
<i>1314</i>&nbsp;         *
<i>1315</i>&nbsp;         * @return the attribute set
<i>1316</i>&nbsp;         */
<b class="nc"><i>1317</i>&nbsp;        public AttributeSet getAttributes() {</b>
<i>1318</i>&nbsp;            return attr;
<i>1319</i>&nbsp;        }
<i>1320</i>&nbsp;
<i>1321</i>&nbsp;        /**
<i>1322</i>&nbsp;         * Gets the array of characters.
<i>1323</i>&nbsp;         *
<i>1324</i>&nbsp;         * @return the array
<i>1325</i>&nbsp;         */
<i>1326</i>&nbsp;        public char[] getArray() {
<b class="nc"><i>1327</i>&nbsp;            return data == null ? null : Arrays.copyOf(data, data.length);</b>
<i>1328</i>&nbsp;        }
<i>1329</i>&nbsp;
<i>1330</i>&nbsp;
<i>1331</i>&nbsp;        /**
<i>1332</i>&nbsp;         * Gets the starting offset.
<i>1333</i>&nbsp;         *
<i>1334</i>&nbsp;         * @return the offset &amp;gt;= 0
<i>1335</i>&nbsp;         */
<b class="nc"><i>1336</i>&nbsp;        public int getOffset() {</b>
<i>1337</i>&nbsp;            return offs;
<i>1338</i>&nbsp;        }
<i>1339</i>&nbsp;
<i>1340</i>&nbsp;        /**
<i>1341</i>&nbsp;         * Gets the length.
<i>1342</i>&nbsp;         *
<i>1343</i>&nbsp;         * @return the length &amp;gt;= 0
<i>1344</i>&nbsp;         */
<b class="nc"><i>1345</i>&nbsp;        public int getLength() {</b>
<b class="nc"><i>1346</i>&nbsp;            return len;</b>
<b class="nc"><i>1347</i>&nbsp;        }</b>
<i>1348</i>&nbsp;
<b class="nc"><i>1349</i>&nbsp;        /**</b>
<b class="nc"><i>1350</i>&nbsp;         * Converts the element to a string.</b>
<i>1351</i>&nbsp;         *
<b class="nc"><i>1352</i>&nbsp;         * @return the string</b>
<b class="nc"><i>1353</i>&nbsp;         */</b>
<i>1354</i>&nbsp;        public String toString() {
<b class="nc"><i>1355</i>&nbsp;            String tlbl = &quot;??&quot;;</b>
<i>1356</i>&nbsp;            String plbl = &quot;??&quot;;
<i>1357</i>&nbsp;            switch(type) {
<b class="nc"><i>1358</i>&nbsp;            case StartTagType:</b>
<i>1359</i>&nbsp;                tlbl = &quot;StartTag&quot;;
<b class="nc"><i>1360</i>&nbsp;                break;</b>
<b class="nc"><i>1361</i>&nbsp;            case ContentType:</b>
<i>1362</i>&nbsp;                tlbl = &quot;Content&quot;;
<b class="nc"><i>1363</i>&nbsp;                break;</b>
<b class="nc"><i>1364</i>&nbsp;            case EndTagType:</b>
<i>1365</i>&nbsp;                tlbl = &quot;EndTag&quot;;
<b class="nc"><i>1366</i>&nbsp;                break;</b>
<b class="nc"><i>1367</i>&nbsp;            }</b>
<i>1368</i>&nbsp;            switch(direction) {
<b class="nc"><i>1369</i>&nbsp;            case JoinPreviousDirection:</b>
<i>1370</i>&nbsp;                plbl = &quot;JoinPrevious&quot;;
<i>1371</i>&nbsp;                break;
<b class="nc"><i>1372</i>&nbsp;            case JoinNextDirection:</b>
<i>1373</i>&nbsp;                plbl = &quot;JoinNext&quot;;
<i>1374</i>&nbsp;                break;
<i>1375</i>&nbsp;            case OriginateDirection:
<i>1376</i>&nbsp;                plbl = &quot;Originate&quot;;
<i>1377</i>&nbsp;                break;
<i>1378</i>&nbsp;            case JoinFractureDirection:
<i>1379</i>&nbsp;                plbl = &quot;Fracture&quot;;
<i>1380</i>&nbsp;                break;
<i>1381</i>&nbsp;            }
<i>1382</i>&nbsp;            return tlbl + &quot;:&quot; + plbl + &quot;:&quot; + getLength();
<i>1383</i>&nbsp;        }
<i>1384</i>&nbsp;
<i>1385</i>&nbsp;        private AttributeSet attr;
<i>1386</i>&nbsp;        private int len;
<i>1387</i>&nbsp;        private short type;
<i>1388</i>&nbsp;        private short direction;
<i>1389</i>&nbsp;
<i>1390</i>&nbsp;        private int offs;
<i>1391</i>&nbsp;        private char[] data;
<i>1392</i>&nbsp;    }
<i>1393</i>&nbsp;
<i>1394</i>&nbsp;    /**
<i>1395</i>&nbsp;     * Class to manage changes to the element
<i>1396</i>&nbsp;     * hierarchy.
<i>1397</i>&nbsp;     * &lt;p&gt;
<i>1398</i>&nbsp;     * &lt;strong&gt;Warning:&lt;/strong&gt;
<i>1399</i>&nbsp;     * Serialized objects of this class will not be compatible with
<i>1400</i>&nbsp;     * future Swing releases. The current serialization support is
<i>1401</i>&nbsp;     * appropriate for short term storage or RMI between applications running
<i>1402</i>&nbsp;     * the same version of Swing.  As of 1.4, support for long term storage
<i>1403</i>&nbsp;     * of all JavaBeans&amp;trade;
<i>1404</i>&nbsp;     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
<b class="nc"><i>1405</i>&nbsp;     * Please see {@link java.beans.XMLEncoder}.</b>
<b class="nc"><i>1406</i>&nbsp;     */</b>
<b class="nc"><i>1407</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only</b>
<b class="nc"><i>1408</i>&nbsp;    public class ElementBuffer implements Serializable {</b>
<i>1409</i>&nbsp;
<i>1410</i>&nbsp;        /**
<i>1411</i>&nbsp;         * Creates a new ElementBuffer.
<i>1412</i>&nbsp;         *
<i>1413</i>&nbsp;         * @param root the root element
<i>1414</i>&nbsp;         * @since 1.4
<i>1415</i>&nbsp;         */
<i>1416</i>&nbsp;        public ElementBuffer(Element root) {
<b class="nc"><i>1417</i>&nbsp;            this.root = root;</b>
<i>1418</i>&nbsp;            changes = new Vector&lt;ElemChanges&gt;();
<i>1419</i>&nbsp;            path = new Stack&lt;ElemChanges&gt;();
<i>1420</i>&nbsp;        }
<i>1421</i>&nbsp;
<i>1422</i>&nbsp;        /**
<i>1423</i>&nbsp;         * Gets the root element.
<i>1424</i>&nbsp;         *
<i>1425</i>&nbsp;         * @return the root element
<i>1426</i>&nbsp;         */
<i>1427</i>&nbsp;        public Element getRootElement() {
<i>1428</i>&nbsp;            return root;
<i>1429</i>&nbsp;        }
<b class="nc"><i>1430</i>&nbsp;</b>
<i>1431</i>&nbsp;        /**
<i>1432</i>&nbsp;         * Inserts new content.
<i>1433</i>&nbsp;         *
<b class="nc"><i>1434</i>&nbsp;         * @param offset the starting offset &amp;gt;= 0</b>
<b class="nc"><i>1435</i>&nbsp;         * @param length the length &amp;gt;= 0</b>
<b class="nc"><i>1436</i>&nbsp;         * @param data the data to insert</b>
<b class="nc"><i>1437</i>&nbsp;         * @param de the event capturing this edit</b>
<i>1438</i>&nbsp;         */
<b class="nc"><i>1439</i>&nbsp;        public void insert(int offset, int length, ElementSpec[] data,</b>
<i>1440</i>&nbsp;                                 DefaultDocumentEvent de) {
<i>1441</i>&nbsp;            if (length == 0) {
<i>1442</i>&nbsp;                // Nothing was inserted, no structure change.
<b class="nc"><i>1443</i>&nbsp;                return;</b>
<b class="nc"><i>1444</i>&nbsp;            }</b>
<i>1445</i>&nbsp;            insertOp = true;
<i>1446</i>&nbsp;            beginEdits(offset, length);
<i>1447</i>&nbsp;            insertUpdate(data);
<i>1448</i>&nbsp;            endEdits(de);
<i>1449</i>&nbsp;
<i>1450</i>&nbsp;            insertOp = false;
<i>1451</i>&nbsp;        }
<b class="nc"><i>1452</i>&nbsp;</b>
<b class="nc"><i>1453</i>&nbsp;        void create(int length, ElementSpec[] data, DefaultDocumentEvent de) {</b>
<b class="nc"><i>1454</i>&nbsp;            insertOp = true;</b>
<b class="nc"><i>1455</i>&nbsp;            beginEdits(offset, length);</b>
<b class="nc"><i>1456</i>&nbsp;</b>
<b class="nc"><i>1457</i>&nbsp;            // PENDING(prinz) this needs to be fixed to create a new</b>
<b class="nc"><i>1458</i>&nbsp;            // root element as well, but requires changes to the</b>
<b class="nc"><i>1459</i>&nbsp;            // DocumentEvent to inform the views that there is a new</b>
<b class="nc"><i>1460</i>&nbsp;            // root element.</b>
<b class="nc"><i>1461</i>&nbsp;</b>
<b class="nc"><i>1462</i>&nbsp;            // Recreate the ending fake element to have the correct offsets.</b>
<b class="nc"><i>1463</i>&nbsp;            Element elem = root;</b>
<b class="nc"><i>1464</i>&nbsp;            int index = elem.getElementIndex(0);</b>
<b class="nc"><i>1465</i>&nbsp;            while (! elem.isLeaf()) {</b>
<b class="nc"><i>1466</i>&nbsp;                Element child = elem.getElement(index);</b>
<b class="nc"><i>1467</i>&nbsp;                push(elem, index);</b>
<i>1468</i>&nbsp;                elem = child;
<i>1469</i>&nbsp;                index = elem.getElementIndex(0);
<b class="nc"><i>1470</i>&nbsp;            }</b>
<i>1471</i>&nbsp;            ElemChanges ec = path.peek();
<i>1472</i>&nbsp;            Element child = ec.parent.getElement(ec.index);
<b class="nc"><i>1473</i>&nbsp;            ec.added.addElement(createLeafElement(ec.parent,</b>
<b class="nc"><i>1474</i>&nbsp;                                child.getAttributes(), getLength(),</b>
<b class="nc"><i>1475</i>&nbsp;                                child.getEndOffset()));</b>
<i>1476</i>&nbsp;            ec.removed.addElement(child);
<b class="nc"><i>1477</i>&nbsp;            while (path.size() &gt; 1) {</b>
<b class="nc"><i>1478</i>&nbsp;                pop();</b>
<i>1479</i>&nbsp;            }
<b class="nc"><i>1480</i>&nbsp;</b>
<b class="nc"><i>1481</i>&nbsp;            int n = data.length;</b>
<b class="nc"><i>1482</i>&nbsp;</b>
<b class="nc"><i>1483</i>&nbsp;            // Reset the root elements attributes.</b>
<b class="nc"><i>1484</i>&nbsp;            AttributeSet newAttrs = null;</b>
<i>1485</i>&nbsp;            if (n &gt; 0 &amp;&amp; data[0].getType() == ElementSpec.StartTagType) {
<i>1486</i>&nbsp;                newAttrs = data[0].getAttributes();
<b class="nc"><i>1487</i>&nbsp;            }</b>
<b class="nc"><i>1488</i>&nbsp;            if (newAttrs == null) {</b>
<i>1489</i>&nbsp;                newAttrs = SimpleAttributeSet.EMPTY;
<i>1490</i>&nbsp;            }
<i>1491</i>&nbsp;            MutableAttributeSet attr = (MutableAttributeSet)root.
<b class="nc"><i>1492</i>&nbsp;                                       getAttributes();</b>
<b class="nc"><i>1493</i>&nbsp;            de.addEdit(new AttributeUndoableEdit(root, newAttrs, true));</b>
<i>1494</i>&nbsp;            attr.removeAttributes(attr);
<i>1495</i>&nbsp;            attr.addAttributes(newAttrs);
<b class="nc"><i>1496</i>&nbsp;</b>
<b class="nc"><i>1497</i>&nbsp;            // fold in the specified subtree</b>
<i>1498</i>&nbsp;            for (int i = 1; i &lt; n; i++) {
<i>1499</i>&nbsp;                insertElement(data[i]);
<i>1500</i>&nbsp;            }
<i>1501</i>&nbsp;
<i>1502</i>&nbsp;            // pop the remaining path
<i>1503</i>&nbsp;            while (path.size() != 0) {
<i>1504</i>&nbsp;                pop();
<i>1505</i>&nbsp;            }
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;            endEdits(de);
<b class="nc"><i>1508</i>&nbsp;            insertOp = false;</b>
<b class="nc"><i>1509</i>&nbsp;        }</b>
<b class="nc"><i>1510</i>&nbsp;</b>
<i>1511</i>&nbsp;        /**
<i>1512</i>&nbsp;         * Removes content.
<i>1513</i>&nbsp;         *
<i>1514</i>&nbsp;         * @param offset the starting offset &amp;gt;= 0
<i>1515</i>&nbsp;         * @param length the length &amp;gt;= 0
<i>1516</i>&nbsp;         * @param de the event capturing this edit
<i>1517</i>&nbsp;         */
<i>1518</i>&nbsp;        public void remove(int offset, int length, DefaultDocumentEvent de) {
<i>1519</i>&nbsp;            beginEdits(offset, length);
<i>1520</i>&nbsp;            removeUpdate();
<b class="nc"><i>1521</i>&nbsp;            endEdits(de);</b>
<b class="nc"><i>1522</i>&nbsp;        }</b>
<b class="nc"><i>1523</i>&nbsp;</b>
<i>1524</i>&nbsp;        /**
<i>1525</i>&nbsp;         * Changes content.
<i>1526</i>&nbsp;         *
<i>1527</i>&nbsp;         * @param offset the starting offset &amp;gt;= 0
<i>1528</i>&nbsp;         * @param length the length &amp;gt;= 0
<i>1529</i>&nbsp;         * @param de the event capturing this edit
<i>1530</i>&nbsp;         */
<i>1531</i>&nbsp;        public void change(int offset, int length, DefaultDocumentEvent de) {
<i>1532</i>&nbsp;            beginEdits(offset, length);
<b class="nc"><i>1533</i>&nbsp;            changeUpdate();</b>
<b class="nc"><i>1534</i>&nbsp;            endEdits(de);</b>
<b class="nc"><i>1535</i>&nbsp;        }</b>
<b class="nc"><i>1536</i>&nbsp;</b>
<b class="nc"><i>1537</i>&nbsp;        /**</b>
<b class="nc"><i>1538</i>&nbsp;         * Inserts an update into the document.</b>
<b class="nc"><i>1539</i>&nbsp;         *</b>
<b class="nc"><i>1540</i>&nbsp;         * @param data the elements to insert</b>
<i>1541</i>&nbsp;         */
<i>1542</i>&nbsp;        protected void insertUpdate(ElementSpec[] data) {
<b class="nc"><i>1543</i>&nbsp;            // push the path</b>
<b class="nc"><i>1544</i>&nbsp;            Element elem = root;</b>
<i>1545</i>&nbsp;            int index = elem.getElementIndex(offset);
<i>1546</i>&nbsp;            while (! elem.isLeaf()) {
<b class="nc"><i>1547</i>&nbsp;                Element child = elem.getElement(index);</b>
<i>1548</i>&nbsp;                push(elem, (child.isLeaf() ? index : index+1));
<i>1549</i>&nbsp;                elem = child;
<i>1550</i>&nbsp;                index = elem.getElementIndex(offset);
<i>1551</i>&nbsp;            }
<b class="nc"><i>1552</i>&nbsp;</b>
<b class="nc"><i>1553</i>&nbsp;            // Build a copy of the original path.</b>
<b class="nc"><i>1554</i>&nbsp;            insertPath = new ElemChanges[path.size()];</b>
<b class="nc"><i>1555</i>&nbsp;            path.copyInto(insertPath);</b>
<b class="nc"><i>1556</i>&nbsp;</b>
<i>1557</i>&nbsp;            // Haven&#39;t created the fracture yet.
<i>1558</i>&nbsp;            createdFracture = false;
<b class="nc"><i>1559</i>&nbsp;</b>
<b class="nc"><i>1560</i>&nbsp;            // Insert the first content.</b>
<i>1561</i>&nbsp;            int i;
<i>1562</i>&nbsp;
<i>1563</i>&nbsp;            recreateLeafs = false;
<b class="nc"><i>1564</i>&nbsp;            if(data[0].getType() == ElementSpec.ContentType) {</b>
<b class="nc"><i>1565</i>&nbsp;                insertFirstContent(data);</b>
<b class="nc"><i>1566</i>&nbsp;                pos += data[0].getLength();</b>
<i>1567</i>&nbsp;                i = 1;
<i>1568</i>&nbsp;            }
<i>1569</i>&nbsp;            else {
<b class="nc"><i>1570</i>&nbsp;                fractureDeepestLeaf(data);</b>
<b class="nc"><i>1571</i>&nbsp;                i = 0;</b>
<i>1572</i>&nbsp;            }
<i>1573</i>&nbsp;
<b class="nc"><i>1574</i>&nbsp;            // fold in the specified subtree</b>
<b class="nc"><i>1575</i>&nbsp;            int n = data.length;</b>
<i>1576</i>&nbsp;            for (; i &lt; n; i++) {
<i>1577</i>&nbsp;                insertElement(data[i]);
<i>1578</i>&nbsp;            }
<b class="nc"><i>1579</i>&nbsp;</b>
<b class="nc"><i>1580</i>&nbsp;            // Fracture, if we haven&#39;t yet.</b>
<i>1581</i>&nbsp;            if(!createdFracture)
<i>1582</i>&nbsp;                fracture(-1);
<i>1583</i>&nbsp;
<i>1584</i>&nbsp;            // pop the remaining path
<b class="nc"><i>1585</i>&nbsp;            while (path.size() != 0) {</b>
<b class="nc"><i>1586</i>&nbsp;                pop();</b>
<b class="nc"><i>1587</i>&nbsp;            }</b>
<b class="nc"><i>1588</i>&nbsp;</b>
<b class="nc"><i>1589</i>&nbsp;            // Offset the last index if necessary.</b>
<b class="nc"><i>1590</i>&nbsp;            if(offsetLastIndex &amp;&amp; offsetLastIndexOnReplace) {</b>
<b class="nc"><i>1591</i>&nbsp;                insertPath[insertPath.length - 1].index++;</b>
<i>1592</i>&nbsp;            }
<b class="nc"><i>1593</i>&nbsp;</b>
<i>1594</i>&nbsp;            // Make sure an edit is going to be created for each of the
<i>1595</i>&nbsp;            // original path items that have a change.
<i>1596</i>&nbsp;            for(int counter = insertPath.length - 1; counter &gt;= 0;
<i>1597</i>&nbsp;                counter--) {
<i>1598</i>&nbsp;                ElemChanges change = insertPath[counter];
<i>1599</i>&nbsp;                if(change.parent == fracturedParent)
<b class="nc"><i>1600</i>&nbsp;                    change.added.addElement(fracturedChild);</b>
<b class="nc"><i>1601</i>&nbsp;                if((change.added.size() &gt; 0 ||</b>
<b class="nc"><i>1602</i>&nbsp;                    change.removed.size() &gt; 0) &amp;&amp; !changes.contains(change)) {</b>
<b class="nc"><i>1603</i>&nbsp;                    // PENDING(sky): Do I need to worry about order here?</b>
<b class="nc"><i>1604</i>&nbsp;                    changes.addElement(change);</b>
<b class="nc"><i>1605</i>&nbsp;                }</b>
<i>1606</i>&nbsp;            }
<b class="nc"><i>1607</i>&nbsp;</b>
<i>1608</i>&nbsp;            // An insert at 0 with an initial end implies some elements
<b class="nc"><i>1609</i>&nbsp;            // will have no children (the bottomost leaf would have length 0)</b>
<b class="nc"><i>1610</i>&nbsp;            // this will find what element need to be removed and remove it.</b>
<i>1611</i>&nbsp;            if (offset == 0 &amp;&amp; fracturedParent != null &amp;&amp;
<i>1612</i>&nbsp;                data[0].getType() == ElementSpec.EndTagType) {
<i>1613</i>&nbsp;                int counter = 0;
<i>1614</i>&nbsp;                while (counter &lt; data.length &amp;&amp;
<i>1615</i>&nbsp;                       data[counter].getType() == ElementSpec.EndTagType) {
<i>1616</i>&nbsp;                    counter++;
<i>1617</i>&nbsp;                }
<i>1618</i>&nbsp;                ElemChanges change = insertPath[insertPath.length -
<i>1619</i>&nbsp;                                               counter - 1];
<b class="nc"><i>1620</i>&nbsp;                change.removed.insertElementAt(change.parent.getElement</b>
<i>1621</i>&nbsp;                                               (--change.index), 0);
<i>1622</i>&nbsp;            }
<i>1623</i>&nbsp;        }
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;        /**
<i>1626</i>&nbsp;         * Updates the element structure in response to a removal from the
<i>1627</i>&nbsp;         * associated sequence in the document.  Any elements consumed by the
<b class="nc"><i>1628</i>&nbsp;         * span of the removal are removed.</b>
<b class="nc"><i>1629</i>&nbsp;         */</b>
<i>1630</i>&nbsp;        protected void removeUpdate() {
<b class="nc"><i>1631</i>&nbsp;            removeElements(root, offset, offset + length);</b>
<b class="nc"><i>1632</i>&nbsp;        }</b>
<i>1633</i>&nbsp;
<b class="nc"><i>1634</i>&nbsp;        /**</b>
<i>1635</i>&nbsp;         * Updates the element structure in response to a change in the
<b class="nc"><i>1636</i>&nbsp;         * document.</b>
<b class="nc"><i>1637</i>&nbsp;         */</b>
<i>1638</i>&nbsp;        protected void changeUpdate() {
<i>1639</i>&nbsp;            boolean didEnd = split(offset, length);
<i>1640</i>&nbsp;            if (! didEnd) {
<i>1641</i>&nbsp;                // need to do the other end
<b class="nc"><i>1642</i>&nbsp;                while (path.size() != 0) {</b>
<i>1643</i>&nbsp;                    pop();
<b class="nc"><i>1644</i>&nbsp;                }</b>
<b class="nc"><i>1645</i>&nbsp;                split(offset + length, 0);</b>
<b class="nc"><i>1646</i>&nbsp;            }</b>
<b class="nc"><i>1647</i>&nbsp;            while (path.size() != 0) {</b>
<b class="nc"><i>1648</i>&nbsp;                pop();</b>
<b class="nc"><i>1649</i>&nbsp;            }</b>
<i>1650</i>&nbsp;        }
<i>1651</i>&nbsp;
<b class="nc"><i>1652</i>&nbsp;        boolean split(int offs, int len) {</b>
<b class="nc"><i>1653</i>&nbsp;            boolean splitEnd = false;</b>
<i>1654</i>&nbsp;            // push the path
<i>1655</i>&nbsp;            Element e = root;
<i>1656</i>&nbsp;            int index = e.getElementIndex(offs);
<b class="nc"><i>1657</i>&nbsp;            while (! e.isLeaf()) {</b>
<i>1658</i>&nbsp;                push(e, index);
<i>1659</i>&nbsp;                e = e.getElement(index);
<b class="nc"><i>1660</i>&nbsp;                index = e.getElementIndex(offs);</b>
<b class="nc"><i>1661</i>&nbsp;            }</b>
<b class="nc"><i>1662</i>&nbsp;</b>
<i>1663</i>&nbsp;            ElemChanges ec = path.peek();
<b class="nc"><i>1664</i>&nbsp;            Element child = ec.parent.getElement(ec.index);</b>
<b class="nc"><i>1665</i>&nbsp;            // make sure there is something to do... if the</b>
<i>1666</i>&nbsp;            // offset is already at a boundary then there is
<b class="nc"><i>1667</i>&nbsp;            // nothing to do.</b>
<b class="nc"><i>1668</i>&nbsp;            if (child.getStartOffset() &lt; offs &amp;&amp; offs &lt; child.getEndOffset()) {</b>
<b class="nc"><i>1669</i>&nbsp;                // we need to split, now see if the other end is within</b>
<b class="nc"><i>1670</i>&nbsp;                // the same parent.</b>
<b class="nc"><i>1671</i>&nbsp;                int index0 = ec.index;</b>
<i>1672</i>&nbsp;                int index1 = index0;
<b class="nc"><i>1673</i>&nbsp;                if (((offs + len) &lt; ec.parent.getEndOffset()) &amp;&amp; (len != 0)) {</b>
<b class="nc"><i>1674</i>&nbsp;                    // it&#39;s a range split in the same parent</b>
<b class="nc"><i>1675</i>&nbsp;                    index1 = ec.parent.getElementIndex(offs+len);</b>
<b class="nc"><i>1676</i>&nbsp;                    if (index1 == index0) {</b>
<b class="nc"><i>1677</i>&nbsp;                        // it&#39;s a three-way split</b>
<i>1678</i>&nbsp;                        ec.removed.addElement(child);
<b class="nc"><i>1679</i>&nbsp;                        e = createLeafElement(ec.parent, child.getAttributes(),</b>
<b class="nc"><i>1680</i>&nbsp;                                              child.getStartOffset(), offs);</b>
<i>1681</i>&nbsp;                        ec.added.addElement(e);
<b class="nc"><i>1682</i>&nbsp;                        e = createLeafElement(ec.parent, child.getAttributes(),</b>
<i>1683</i>&nbsp;                                          offs, offs + len);
<i>1684</i>&nbsp;                        ec.added.addElement(e);
<b class="nc"><i>1685</i>&nbsp;                        e = createLeafElement(ec.parent, child.getAttributes(),</b>
<i>1686</i>&nbsp;                                              offs + len, child.getEndOffset());
<i>1687</i>&nbsp;                        ec.added.addElement(e);
<i>1688</i>&nbsp;                        return true;
<b class="nc"><i>1689</i>&nbsp;                    } else {</b>
<b class="nc"><i>1690</i>&nbsp;                        child = ec.parent.getElement(index1);</b>
<b class="nc"><i>1691</i>&nbsp;                        if ((offs + len) == child.getStartOffset()) {</b>
<b class="nc"><i>1692</i>&nbsp;                            // end is already on a boundary</b>
<b class="nc"><i>1693</i>&nbsp;                            index1 = index0;</b>
<b class="nc"><i>1694</i>&nbsp;                        }</b>
<b class="nc"><i>1695</i>&nbsp;                    }</b>
<b class="nc"><i>1696</i>&nbsp;                    splitEnd = true;</b>
<b class="nc"><i>1697</i>&nbsp;                }</b>
<i>1698</i>&nbsp;
<i>1699</i>&nbsp;                // split the first location
<b class="nc"><i>1700</i>&nbsp;                pos = offs;</b>
<b class="nc"><i>1701</i>&nbsp;                child = ec.parent.getElement(index0);</b>
<b class="nc"><i>1702</i>&nbsp;                ec.removed.addElement(child);</b>
<b class="nc"><i>1703</i>&nbsp;                e = createLeafElement(ec.parent, child.getAttributes(),</b>
<i>1704</i>&nbsp;                                      child.getStartOffset(), pos);
<i>1705</i>&nbsp;                ec.added.addElement(e);
<b class="nc"><i>1706</i>&nbsp;                e = createLeafElement(ec.parent, child.getAttributes(),</b>
<b class="nc"><i>1707</i>&nbsp;                                      pos, child.getEndOffset());</b>
<b class="nc"><i>1708</i>&nbsp;                ec.added.addElement(e);</b>
<b class="nc"><i>1709</i>&nbsp;</b>
<b class="nc"><i>1710</i>&nbsp;                // pick up things in the middle</b>
<b class="nc"><i>1711</i>&nbsp;                for (int i = index0 + 1; i &lt; index1; i++) {</b>
<b class="nc"><i>1712</i>&nbsp;                    child = ec.parent.getElement(i);</b>
<b class="nc"><i>1713</i>&nbsp;                    ec.removed.addElement(child);</b>
<b class="nc"><i>1714</i>&nbsp;                    ec.added.addElement(child);</b>
<b class="nc"><i>1715</i>&nbsp;                }</b>
<i>1716</i>&nbsp;
<i>1717</i>&nbsp;                if (index1 != index0) {
<b class="nc"><i>1718</i>&nbsp;                    child = ec.parent.getElement(index1);</b>
<i>1719</i>&nbsp;                    pos = offs + len;
<i>1720</i>&nbsp;                    ec.removed.addElement(child);
<i>1721</i>&nbsp;                    e = createLeafElement(ec.parent, child.getAttributes(),
<i>1722</i>&nbsp;                                          child.getStartOffset(), pos);
<i>1723</i>&nbsp;                    ec.added.addElement(e);
<i>1724</i>&nbsp;                    e = createLeafElement(ec.parent, child.getAttributes(),
<i>1725</i>&nbsp;                                          pos, child.getEndOffset());
<b class="nc"><i>1726</i>&nbsp;                    ec.added.addElement(e);</b>
<b class="nc"><i>1727</i>&nbsp;                }</b>
<b class="nc"><i>1728</i>&nbsp;            }</b>
<b class="nc"><i>1729</i>&nbsp;            return splitEnd;</b>
<b class="nc"><i>1730</i>&nbsp;        }</b>
<b class="nc"><i>1731</i>&nbsp;</b>
<b class="nc"><i>1732</i>&nbsp;        /**</b>
<b class="nc"><i>1733</i>&nbsp;         * Creates the UndoableEdit record for the edits made</b>
<b class="nc"><i>1734</i>&nbsp;         * in the buffer.</b>
<b class="nc"><i>1735</i>&nbsp;         */</b>
<b class="nc"><i>1736</i>&nbsp;        void endEdits(DefaultDocumentEvent de) {</b>
<i>1737</i>&nbsp;            int n = changes.size();
<i>1738</i>&nbsp;            for (int i = 0; i &lt; n; i++) {
<b class="nc"><i>1739</i>&nbsp;                ElemChanges ec = changes.elementAt(i);</b>
<b class="nc"><i>1740</i>&nbsp;                Element[] removed = new Element[ec.removed.size()];</b>
<i>1741</i>&nbsp;                ec.removed.copyInto(removed);
<i>1742</i>&nbsp;                Element[] added = new Element[ec.added.size()];
<i>1743</i>&nbsp;                ec.added.copyInto(added);
<i>1744</i>&nbsp;                int index = ec.index;
<i>1745</i>&nbsp;                ((BranchElement) ec.parent).replace(index, removed.length, added);
<i>1746</i>&nbsp;                ElementEdit ee = new ElementEdit(ec.parent, index, removed, added);
<i>1747</i>&nbsp;                de.addEdit(ee);
<i>1748</i>&nbsp;            }
<i>1749</i>&nbsp;
<i>1750</i>&nbsp;            changes.removeAllElements();
<i>1751</i>&nbsp;            path.removeAllElements();
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;            /*
<i>1754</i>&nbsp;            for (int i = 0; i &lt; n; i++) {
<i>1755</i>&nbsp;                ElemChanges ec = (ElemChanges) changes.elementAt(i);
<i>1756</i>&nbsp;                System.err.print(&quot;edited: &quot; + ec.parent + &quot; at: &quot; + ec.index +
<i>1757</i>&nbsp;                    &quot; removed &quot; + ec.removed.size());
<i>1758</i>&nbsp;                if (ec.removed.size() &gt; 0) {
<i>1759</i>&nbsp;                    int r0 = ((Element) ec.removed.firstElement()).getStartOffset();
<i>1760</i>&nbsp;                    int r1 = ((Element) ec.removed.lastElement()).getEndOffset();
<i>1761</i>&nbsp;                    System.err.print(&quot;[&quot; + r0 + &quot;,&quot; + r1 + &quot;]&quot;);
<i>1762</i>&nbsp;                }
<i>1763</i>&nbsp;                System.err.print(&quot; added &quot; + ec.added.size());
<i>1764</i>&nbsp;                if (ec.added.size() &gt; 0) {
<i>1765</i>&nbsp;                    int p0 = ((Element) ec.added.firstElement()).getStartOffset();
<i>1766</i>&nbsp;                    int p1 = ((Element) ec.added.lastElement()).getEndOffset();
<b class="nc"><i>1767</i>&nbsp;                    System.err.print(&quot;[&quot; + p0 + &quot;,&quot; + p1 + &quot;]&quot;);</b>
<b class="nc"><i>1768</i>&nbsp;                }</b>
<b class="nc"><i>1769</i>&nbsp;                System.err.println(&quot;&quot;);</b>
<b class="nc"><i>1770</i>&nbsp;            }</b>
<b class="nc"><i>1771</i>&nbsp;            */</b>
<b class="nc"><i>1772</i>&nbsp;        }</b>
<i>1773</i>&nbsp;
<b class="nc"><i>1774</i>&nbsp;        /**</b>
<i>1775</i>&nbsp;         * Initialize the buffer
<b class="nc"><i>1776</i>&nbsp;         */</b>
<b class="nc"><i>1777</i>&nbsp;        void beginEdits(int offset, int length) {</b>
<i>1778</i>&nbsp;            this.offset = offset;
<b class="nc"><i>1779</i>&nbsp;            this.length = length;</b>
<i>1780</i>&nbsp;            this.endOffset = offset + length;
<b class="nc"><i>1781</i>&nbsp;            pos = offset;</b>
<b class="nc"><i>1782</i>&nbsp;            if (changes == null) {</b>
<b class="nc"><i>1783</i>&nbsp;                changes = new Vector&lt;ElemChanges&gt;();</b>
<i>1784</i>&nbsp;            } else {
<i>1785</i>&nbsp;                changes.removeAllElements();
<i>1786</i>&nbsp;            }
<i>1787</i>&nbsp;            if (path == null) {
<i>1788</i>&nbsp;                path = new Stack&lt;ElemChanges&gt;();
<i>1789</i>&nbsp;            } else {
<i>1790</i>&nbsp;                path.removeAllElements();
<i>1791</i>&nbsp;            }
<i>1792</i>&nbsp;            fracturedParent = null;
<i>1793</i>&nbsp;            fracturedChild = null;
<i>1794</i>&nbsp;            offsetLastIndex = offsetLastIndexOnReplace = false;
<b class="nc"><i>1795</i>&nbsp;        }</b>
<b class="nc"><i>1796</i>&nbsp;</b>
<i>1797</i>&nbsp;        /**
<i>1798</i>&nbsp;         * Pushes a new element onto the stack that represents
<i>1799</i>&nbsp;         * the current path.
<b class="nc"><i>1800</i>&nbsp;         * @param isFracture true if pushing on an element that was created</b>
<i>1801</i>&nbsp;         * as the result of a fracture.
<i>1802</i>&nbsp;         */
<i>1803</i>&nbsp;        void push(Element e, int index, boolean isFracture) {
<b class="nc"><i>1804</i>&nbsp;            ElemChanges ec = new ElemChanges(e, index, isFracture);</b>
<b class="nc"><i>1805</i>&nbsp;            path.push(ec);</b>
<b class="nc"><i>1806</i>&nbsp;        }</b>
<b class="nc"><i>1807</i>&nbsp;</b>
<b class="nc"><i>1808</i>&nbsp;        void push(Element e, int index) {</b>
<b class="nc"><i>1809</i>&nbsp;            push(e, index, false);</b>
<b class="nc"><i>1810</i>&nbsp;        }</b>
<i>1811</i>&nbsp;
<i>1812</i>&nbsp;        void pop() {
<b class="nc"><i>1813</i>&nbsp;            ElemChanges ec = path.peek();</b>
<b class="nc"><i>1814</i>&nbsp;            path.pop();</b>
<i>1815</i>&nbsp;            if ((ec.added.size() &gt; 0) || (ec.removed.size() &gt; 0)) {
<i>1816</i>&nbsp;                changes.addElement(ec);
<i>1817</i>&nbsp;            } else if (! path.isEmpty()) {
<i>1818</i>&nbsp;                Element e = ec.parent;
<i>1819</i>&nbsp;                if(e.getElementCount() == 0) {
<i>1820</i>&nbsp;                    // if we pushed a branch element that didn&#39;t get
<i>1821</i>&nbsp;                    // used, make sure its not marked as having been added.
<i>1822</i>&nbsp;                    ec = path.peek();
<b class="nc"><i>1823</i>&nbsp;                    ec.added.removeElement(e);</b>
<i>1824</i>&nbsp;                }
<i>1825</i>&nbsp;            }
<i>1826</i>&nbsp;        }
<b class="nc"><i>1827</i>&nbsp;</b>
<b class="nc"><i>1828</i>&nbsp;        /**</b>
<i>1829</i>&nbsp;         * move the current offset forward by n.
<b class="nc"><i>1830</i>&nbsp;         */</b>
<i>1831</i>&nbsp;        void advance(int n) {
<i>1832</i>&nbsp;            pos += n;
<i>1833</i>&nbsp;        }
<b class="nc"><i>1834</i>&nbsp;</b>
<i>1835</i>&nbsp;        void insertElement(ElementSpec es) {
<b class="nc"><i>1836</i>&nbsp;            ElemChanges ec = path.peek();</b>
<i>1837</i>&nbsp;            switch(es.getType()) {
<i>1838</i>&nbsp;            case ElementSpec.StartTagType:
<b class="nc"><i>1839</i>&nbsp;                switch(es.getDirection()) {</b>
<b class="nc"><i>1840</i>&nbsp;                case ElementSpec.JoinNextDirection:</b>
<i>1841</i>&nbsp;                    // Don&#39;t create a new element, use the existing one
<b class="nc"><i>1842</i>&nbsp;                    // at the specified location.</b>
<i>1843</i>&nbsp;                    Element parent = ec.parent.getElement(ec.index);
<i>1844</i>&nbsp;
<i>1845</i>&nbsp;                    if(parent.isLeaf()) {
<i>1846</i>&nbsp;                        // This happens if inserting into a leaf, followed
<i>1847</i>&nbsp;                        // by a join next where next sibling is not a leaf.
<b class="nc"><i>1848</i>&nbsp;                        if((ec.index + 1) &lt; ec.parent.getElementCount())</b>
<b class="nc"><i>1849</i>&nbsp;                            parent = ec.parent.getElement(ec.index + 1);</b>
<i>1850</i>&nbsp;                        else
<b class="nc"><i>1851</i>&nbsp;                            throw new StateInvariantError(&quot;Join next to leaf&quot;);</b>
<i>1852</i>&nbsp;                    }
<b class="nc"><i>1853</i>&nbsp;                    // Not really a fracture, but need to treat it like</b>
<i>1854</i>&nbsp;                    // one so that content join next will work correctly.
<i>1855</i>&nbsp;                    // We can do this because there will never be a join
<i>1856</i>&nbsp;                    // next followed by a join fracture.
<b class="nc"><i>1857</i>&nbsp;                    push(parent, 0, true);</b>
<b class="nc"><i>1858</i>&nbsp;                    break;</b>
<i>1859</i>&nbsp;                case ElementSpec.JoinFractureDirection:
<i>1860</i>&nbsp;                    if(!createdFracture) {
<i>1861</i>&nbsp;                        // Should always be something on the stack!
<b class="nc"><i>1862</i>&nbsp;                        fracture(path.size() - 1);</b>
<b class="nc"><i>1863</i>&nbsp;                    }</b>
<i>1864</i>&nbsp;                    // If parent isn&#39;t a fracture, fracture will be
<b class="nc"><i>1865</i>&nbsp;                    // fracturedChild.</b>
<b class="nc"><i>1866</i>&nbsp;                    if(!ec.isFracture) {</b>
<b class="nc"><i>1867</i>&nbsp;                        push(fracturedChild, 0, true);</b>
<b class="nc"><i>1868</i>&nbsp;                    }</b>
<i>1869</i>&nbsp;                    else
<i>1870</i>&nbsp;                        // Parent is a fracture, use 1st element.
<b class="nc"><i>1871</i>&nbsp;                        push(ec.parent.getElement(0), 0, true);</b>
<i>1872</i>&nbsp;                    break;
<b class="nc"><i>1873</i>&nbsp;                default:</b>
<b class="nc"><i>1874</i>&nbsp;                    Element belem = createBranchElement(ec.parent,</b>
<i>1875</i>&nbsp;                                                        es.getAttributes());
<b class="nc"><i>1876</i>&nbsp;                    ec.added.addElement(belem);</b>
<b class="nc"><i>1877</i>&nbsp;                    push(belem, 0);</b>
<b class="nc"><i>1878</i>&nbsp;                    break;</b>
<i>1879</i>&nbsp;                }
<b class="nc"><i>1880</i>&nbsp;                break;</b>
<b class="nc"><i>1881</i>&nbsp;            case ElementSpec.EndTagType:</b>
<i>1882</i>&nbsp;                pop();
<i>1883</i>&nbsp;                break;
<i>1884</i>&nbsp;            case ElementSpec.ContentType:
<i>1885</i>&nbsp;              int len = es.getLength();
<i>1886</i>&nbsp;                if (es.getDirection() != ElementSpec.JoinNextDirection) {
<i>1887</i>&nbsp;                    Element leaf = createLeafElement(ec.parent, es.getAttributes(),
<b class="nc"><i>1888</i>&nbsp;                                                     pos, pos + len);</b>
<b class="nc"><i>1889</i>&nbsp;                    ec.added.addElement(leaf);</b>
<b class="nc"><i>1890</i>&nbsp;                }</b>
<b class="nc"><i>1891</i>&nbsp;                else {</b>
<b class="nc"><i>1892</i>&nbsp;                    // JoinNext on tail is only applicable if last element</b>
<b class="nc"><i>1893</i>&nbsp;                    // and attributes come from that of first element.</b>
<b class="nc"><i>1894</i>&nbsp;                    // With a little extra testing it would be possible</b>
<b class="nc"><i>1895</i>&nbsp;                    // to NOT due this again, as more than likely fracture()</b>
<i>1896</i>&nbsp;                    // created this element.
<i>1897</i>&nbsp;                    if(!ec.isFracture) {
<i>1898</i>&nbsp;                        Element first = null;
<i>1899</i>&nbsp;                        if(insertPath != null) {
<b class="nc"><i>1900</i>&nbsp;                            for(int counter = insertPath.length - 1;</b>
<b class="nc"><i>1901</i>&nbsp;                                counter &gt;= 0; counter--) {</b>
<b class="nc"><i>1902</i>&nbsp;                                if(insertPath[counter] == ec) {</b>
<b class="nc"><i>1903</i>&nbsp;                                    if(counter != (insertPath.length - 1))</b>
<b class="nc"><i>1904</i>&nbsp;                                        first = ec.parent.getElement(ec.index);</b>
<b class="nc"><i>1905</i>&nbsp;                                    break;</b>
<b class="nc"><i>1906</i>&nbsp;                                }</b>
<i>1907</i>&nbsp;                            }
<i>1908</i>&nbsp;                        }
<b class="nc"><i>1909</i>&nbsp;                        if(first == null)</b>
<b class="nc"><i>1910</i>&nbsp;                            first = ec.parent.getElement(ec.index + 1);</b>
<b class="nc"><i>1911</i>&nbsp;                        Element leaf = createLeafElement(ec.parent, first.</b>
<b class="nc"><i>1912</i>&nbsp;                                 getAttributes(), pos, first.getEndOffset());</b>
<b class="nc"><i>1913</i>&nbsp;                        ec.added.addElement(leaf);</b>
<i>1914</i>&nbsp;                        ec.removed.addElement(first);
<i>1915</i>&nbsp;                    }
<b class="nc"><i>1916</i>&nbsp;                    else {</b>
<i>1917</i>&nbsp;                        // Parent was fractured element.
<i>1918</i>&nbsp;                        Element first = ec.parent.getElement(0);
<i>1919</i>&nbsp;                        Element leaf = createLeafElement(ec.parent, first.
<i>1920</i>&nbsp;                                 getAttributes(), pos, first.getEndOffset());
<i>1921</i>&nbsp;                        ec.added.addElement(leaf);
<i>1922</i>&nbsp;                        ec.removed.addElement(first);
<i>1923</i>&nbsp;                    }
<i>1924</i>&nbsp;                }
<i>1925</i>&nbsp;                pos += len;
<i>1926</i>&nbsp;                break;
<i>1927</i>&nbsp;            }
<i>1928</i>&nbsp;        }
<i>1929</i>&nbsp;
<b class="nc"><i>1930</i>&nbsp;        /**</b>
<i>1931</i>&nbsp;         * Remove the elements from &lt;code&gt;elem&lt;/code&gt; in range
<b class="nc"><i>1932</i>&nbsp;         * &lt;code&gt;rmOffs0&lt;/code&gt;, &lt;code&gt;rmOffs1&lt;/code&gt;. This uses</b>
<b class="nc"><i>1933</i>&nbsp;         * &lt;code&gt;canJoin&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; to handle joining</b>
<b class="nc"><i>1934</i>&nbsp;         * the endpoints of the insertion.</b>
<b class="nc"><i>1935</i>&nbsp;         *</b>
<i>1936</i>&nbsp;         * @return true if elem will no longer have any elements.
<i>1937</i>&nbsp;         */
<i>1938</i>&nbsp;        boolean removeElements(Element elem, int rmOffs0, int rmOffs1) {
<b class="nc"><i>1939</i>&nbsp;            if (! elem.isLeaf()) {</b>
<b class="nc"><i>1940</i>&nbsp;                // update path for changes</b>
<b class="nc"><i>1941</i>&nbsp;                int index0 = elem.getElementIndex(rmOffs0);</b>
<b class="nc"><i>1942</i>&nbsp;                int index1 = elem.getElementIndex(rmOffs1);</b>
<i>1943</i>&nbsp;                push(elem, index0);
<b class="nc"><i>1944</i>&nbsp;                ElemChanges ec = path.peek();</b>
<i>1945</i>&nbsp;
<b class="nc"><i>1946</i>&nbsp;                // if the range is contained by one element,</b>
<b class="nc"><i>1947</i>&nbsp;                // we just forward the request</b>
<i>1948</i>&nbsp;                if (index0 == index1) {
<b class="nc"><i>1949</i>&nbsp;                    Element child0 = elem.getElement(index0);</b>
<i>1950</i>&nbsp;                    if(rmOffs0 &lt;= child0.getStartOffset() &amp;&amp;
<i>1951</i>&nbsp;                       rmOffs1 &gt;= child0.getEndOffset()) {
<i>1952</i>&nbsp;                        // Element totally removed.
<b class="nc"><i>1953</i>&nbsp;                        ec.removed.addElement(child0);</b>
<b class="nc"><i>1954</i>&nbsp;                    }</b>
<b class="nc"><i>1955</i>&nbsp;                    else if(removeElements(child0, rmOffs0, rmOffs1)) {</b>
<b class="nc"><i>1956</i>&nbsp;                        ec.removed.addElement(child0);</b>
<i>1957</i>&nbsp;                    }
<b class="nc"><i>1958</i>&nbsp;                } else {</b>
<b class="nc"><i>1959</i>&nbsp;                    // the removal range spans elements.  If we can join</b>
<i>1960</i>&nbsp;                    // the two endpoints, do it.  Otherwise we remove the
<b class="nc"><i>1961</i>&nbsp;                    // interior and forward to the endpoints.</b>
<b class="nc"><i>1962</i>&nbsp;                    Element child0 = elem.getElement(index0);</b>
<b class="nc"><i>1963</i>&nbsp;                    Element child1 = elem.getElement(index1);</b>
<i>1964</i>&nbsp;                    boolean containsOffs1 = (rmOffs1 &lt; elem.getEndOffset());
<b class="nc"><i>1965</i>&nbsp;                    if (containsOffs1 &amp;&amp; canJoin(child0, child1)) {</b>
<b class="nc"><i>1966</i>&nbsp;                        // remove and join</b>
<b class="nc"><i>1967</i>&nbsp;                        for (int i = index0; i &lt;= index1; i++) {</b>
<i>1968</i>&nbsp;                            ec.removed.addElement(elem.getElement(i));
<b class="nc"><i>1969</i>&nbsp;                        }</b>
<b class="nc"><i>1970</i>&nbsp;                        Element e = join(elem, child0, child1, rmOffs0, rmOffs1);</b>
<i>1971</i>&nbsp;                        ec.added.addElement(e);
<b class="nc"><i>1972</i>&nbsp;                    } else {</b>
<b class="nc"><i>1973</i>&nbsp;                        // remove interior and forward</b>
<i>1974</i>&nbsp;                        int rmIndex0 = index0 + 1;
<b class="nc"><i>1975</i>&nbsp;                        int rmIndex1 = index1 - 1;</b>
<b class="nc"><i>1976</i>&nbsp;                        if (child0.getStartOffset() == rmOffs0 ||</b>
<b class="nc"><i>1977</i>&nbsp;                            (index0 == 0 &amp;&amp;</b>
<i>1978</i>&nbsp;                             child0.getStartOffset() &gt; rmOffs0 &amp;&amp;
<b class="nc"><i>1979</i>&nbsp;                             child0.getEndOffset() &lt;= rmOffs1)) {</b>
<i>1980</i>&nbsp;                            // start element completely consumed
<b class="nc"><i>1981</i>&nbsp;                            child0 = null;</b>
<i>1982</i>&nbsp;                            rmIndex0 = index0;
<b class="nc"><i>1983</i>&nbsp;                        }</b>
<b class="nc"><i>1984</i>&nbsp;                        if (!containsOffs1) {</b>
<i>1985</i>&nbsp;                            child1 = null;
<b class="nc"><i>1986</i>&nbsp;                            rmIndex1++;</b>
<b class="nc"><i>1987</i>&nbsp;                        }</b>
<i>1988</i>&nbsp;                        else if (child1.getStartOffset() == rmOffs1) {
<b class="nc"><i>1989</i>&nbsp;                            // end element not touched</b>
<b class="nc"><i>1990</i>&nbsp;                            child1 = null;</b>
<b class="nc"><i>1991</i>&nbsp;                        }</b>
<b class="nc"><i>1992</i>&nbsp;                        if (rmIndex0 &lt;= rmIndex1) {</b>
<i>1993</i>&nbsp;                            ec.index = rmIndex0;
<i>1994</i>&nbsp;                        }
<b class="nc"><i>1995</i>&nbsp;                        for (int i = rmIndex0; i &lt;= rmIndex1; i++) {</b>
<b class="nc"><i>1996</i>&nbsp;                            ec.removed.addElement(elem.getElement(i));</b>
<b class="nc"><i>1997</i>&nbsp;                        }</b>
<i>1998</i>&nbsp;                        if (child0 != null) {
<i>1999</i>&nbsp;                            if(removeElements(child0, rmOffs0, rmOffs1)) {
<i>2000</i>&nbsp;                                ec.removed.insertElementAt(child0, 0);
<i>2001</i>&nbsp;                                ec.index = index0;
<i>2002</i>&nbsp;                            }
<i>2003</i>&nbsp;                        }
<b class="nc"><i>2004</i>&nbsp;                        if (child1 != null) {</b>
<i>2005</i>&nbsp;                            if(removeElements(child1, rmOffs0, rmOffs1)) {
<i>2006</i>&nbsp;                                ec.removed.addElement(child1);
<b class="nc"><i>2007</i>&nbsp;                            }</b>
<b class="nc"><i>2008</i>&nbsp;                        }</b>
<b class="nc"><i>2009</i>&nbsp;                    }</b>
<i>2010</i>&nbsp;                }
<i>2011</i>&nbsp;
<b class="nc"><i>2012</i>&nbsp;                // publish changes</b>
<i>2013</i>&nbsp;                pop();
<i>2014</i>&nbsp;
<i>2015</i>&nbsp;                // Return true if we no longer have any children.
<i>2016</i>&nbsp;                if(elem.getElementCount() == (ec.removed.size() -
<i>2017</i>&nbsp;                                              ec.added.size())) {
<i>2018</i>&nbsp;                    return true;
<i>2019</i>&nbsp;                }
<b class="nc"><i>2020</i>&nbsp;            }</b>
<b class="nc"><i>2021</i>&nbsp;            return false;</b>
<i>2022</i>&nbsp;        }
<i>2023</i>&nbsp;
<b class="nc"><i>2024</i>&nbsp;        /**</b>
<b class="nc"><i>2025</i>&nbsp;         * Can the two given elements be coelesced together</b>
<b class="nc"><i>2026</i>&nbsp;         * into one element?</b>
<b class="nc"><i>2027</i>&nbsp;         */</b>
<i>2028</i>&nbsp;        boolean canJoin(Element e0, Element e1) {
<b class="nc"><i>2029</i>&nbsp;            if ((e0 == null) || (e1 == null)) {</b>
<i>2030</i>&nbsp;                return false;
<i>2031</i>&nbsp;            }
<b class="nc"><i>2032</i>&nbsp;            // Don&#39;t join a leaf to a branch.</b>
<i>2033</i>&nbsp;            boolean leaf0 = e0.isLeaf();
<i>2034</i>&nbsp;            boolean leaf1 = e1.isLeaf();
<i>2035</i>&nbsp;            if(leaf0 != leaf1) {
<i>2036</i>&nbsp;                return false;
<b class="nc"><i>2037</i>&nbsp;            }</b>
<b class="nc"><i>2038</i>&nbsp;            if (leaf0) {</b>
<b class="nc"><i>2039</i>&nbsp;                // Only join leaves if the attributes match, otherwise</b>
<b class="nc"><i>2040</i>&nbsp;                // style information will be lost.</b>
<i>2041</i>&nbsp;                return e0.getAttributes().isEqual(e1.getAttributes());
<b class="nc"><i>2042</i>&nbsp;            }</b>
<b class="nc"><i>2043</i>&nbsp;            // Only join non-leafs if the names are equal. This may result</b>
<i>2044</i>&nbsp;            // in loss of style information, but this is typically acceptable
<i>2045</i>&nbsp;            // for non-leafs.
<b class="nc"><i>2046</i>&nbsp;            String name0 = e0.getName();</b>
<i>2047</i>&nbsp;            String name1 = e1.getName();
<i>2048</i>&nbsp;            if (name0 != null) {
<i>2049</i>&nbsp;                return name0.equals(name1);
<i>2050</i>&nbsp;            }
<i>2051</i>&nbsp;            if (name1 != null) {
<i>2052</i>&nbsp;                return name1.equals(name0);
<i>2053</i>&nbsp;            }
<b class="nc"><i>2054</i>&nbsp;            // Both names null, treat as equal.</b>
<b class="nc"><i>2055</i>&nbsp;            return true;</b>
<b class="nc"><i>2056</i>&nbsp;        }</b>
<b class="nc"><i>2057</i>&nbsp;</b>
<i>2058</i>&nbsp;        /**
<i>2059</i>&nbsp;         * Joins the two elements carving out a hole for the
<i>2060</i>&nbsp;         * given removed range.
<i>2061</i>&nbsp;         */
<b class="nc"><i>2062</i>&nbsp;        Element join(Element p, Element left, Element right, int rmOffs0, int rmOffs1) {</b>
<b class="nc"><i>2063</i>&nbsp;            if (left.isLeaf() &amp;&amp; right.isLeaf()) {</b>
<b class="nc"><i>2064</i>&nbsp;                return createLeafElement(p, left.getAttributes(), left.getStartOffset(),</b>
<b class="nc"><i>2065</i>&nbsp;                                         right.getEndOffset());</b>
<b class="nc"><i>2066</i>&nbsp;            } else if ((!left.isLeaf()) &amp;&amp; (!right.isLeaf())) {</b>
<b class="nc"><i>2067</i>&nbsp;                // join two branch elements.  This copies the children before</b>
<i>2068</i>&nbsp;                // the removal range on the left element, and after the removal
<b class="nc"><i>2069</i>&nbsp;                // range on the right element.  The two elements on the edge</b>
<b class="nc"><i>2070</i>&nbsp;                // are joined if possible and needed.</b>
<b class="nc"><i>2071</i>&nbsp;                Element to = createBranchElement(p, left.getAttributes());</b>
<i>2072</i>&nbsp;                int ljIndex = left.getElementIndex(rmOffs0);
<b class="nc"><i>2073</i>&nbsp;                int rjIndex = right.getElementIndex(rmOffs1);</b>
<i>2074</i>&nbsp;                Element lj = left.getElement(ljIndex);
<i>2075</i>&nbsp;                if (lj.getStartOffset() &gt;= rmOffs0) {
<b class="nc"><i>2076</i>&nbsp;                    lj = null;</b>
<b class="nc"><i>2077</i>&nbsp;                }</b>
<i>2078</i>&nbsp;                Element rj = right.getElement(rjIndex);
<i>2079</i>&nbsp;                if (rj.getStartOffset() == rmOffs1) {
<i>2080</i>&nbsp;                    rj = null;
<b class="nc"><i>2081</i>&nbsp;                }</b>
<b class="nc"><i>2082</i>&nbsp;                Vector&lt;Element&gt; children = new Vector&lt;Element&gt;();</b>
<b class="nc"><i>2083</i>&nbsp;</b>
<b class="nc"><i>2084</i>&nbsp;                // transfer the left</b>
<b class="nc"><i>2085</i>&nbsp;                for (int i = 0; i &lt; ljIndex; i++) {</b>
<b class="nc"><i>2086</i>&nbsp;                    children.addElement(clone(to, left.getElement(i)));</b>
<i>2087</i>&nbsp;                }
<b class="nc"><i>2088</i>&nbsp;</b>
<b class="nc"><i>2089</i>&nbsp;                // transfer the join/middle</b>
<i>2090</i>&nbsp;                if (canJoin(lj, rj)) {
<i>2091</i>&nbsp;                    Element e = join(to, lj, rj, rmOffs0, rmOffs1);
<i>2092</i>&nbsp;                    children.addElement(e);
<i>2093</i>&nbsp;                } else {
<b class="nc"><i>2094</i>&nbsp;                    if (lj != null) {</b>
<b class="nc"><i>2095</i>&nbsp;                        children.addElement(cloneAsNecessary(to, lj, rmOffs0, rmOffs1));</b>
<b class="nc"><i>2096</i>&nbsp;                    }</b>
<i>2097</i>&nbsp;                    if (rj != null) {
<i>2098</i>&nbsp;                        children.addElement(cloneAsNecessary(to, rj, rmOffs0, rmOffs1));
<i>2099</i>&nbsp;                    }
<b class="nc"><i>2100</i>&nbsp;                }</b>
<b class="nc"><i>2101</i>&nbsp;</b>
<b class="nc"><i>2102</i>&nbsp;                // transfer the right</b>
<b class="nc"><i>2103</i>&nbsp;                int n = right.getElementCount();</b>
<i>2104</i>&nbsp;                for (int i = (rj == null) ? rjIndex : rjIndex + 1; i &lt; n; i++) {
<b class="nc"><i>2105</i>&nbsp;                    children.addElement(clone(to, right.getElement(i)));</b>
<i>2106</i>&nbsp;                }
<i>2107</i>&nbsp;
<i>2108</i>&nbsp;                // install the children
<i>2109</i>&nbsp;                Element[] c = new Element[children.size()];
<i>2110</i>&nbsp;                children.copyInto(c);
<i>2111</i>&nbsp;                ((BranchElement)to).replace(0, 0, c);
<i>2112</i>&nbsp;                return to;
<i>2113</i>&nbsp;            } else {
<i>2114</i>&nbsp;                throw new StateInvariantError(
<i>2115</i>&nbsp;                    &quot;No support to join leaf element with non-leaf element&quot;);
<i>2116</i>&nbsp;            }
<i>2117</i>&nbsp;        }
<i>2118</i>&nbsp;
<b class="nc"><i>2119</i>&nbsp;        /**</b>
<b class="nc"><i>2120</i>&nbsp;         * Creates a copy of this element, with a different</b>
<b class="nc"><i>2121</i>&nbsp;         * parent.</b>
<b class="nc"><i>2122</i>&nbsp;         *</b>
<i>2123</i>&nbsp;         * @param parent the parent element
<b class="nc"><i>2124</i>&nbsp;         * @param clonee the element to be cloned</b>
<b class="nc"><i>2125</i>&nbsp;         * @return the copy</b>
<b class="nc"><i>2126</i>&nbsp;         */</b>
<b class="nc"><i>2127</i>&nbsp;        public Element clone(Element parent, Element clonee) {</b>
<b class="nc"><i>2128</i>&nbsp;            if (clonee.isLeaf()) {</b>
<i>2129</i>&nbsp;                return createLeafElement(parent, clonee.getAttributes(),
<b class="nc"><i>2130</i>&nbsp;                                         clonee.getStartOffset(),</b>
<b class="nc"><i>2131</i>&nbsp;                                         clonee.getEndOffset());</b>
<i>2132</i>&nbsp;            }
<i>2133</i>&nbsp;            Element e = createBranchElement(parent, clonee.getAttributes());
<i>2134</i>&nbsp;            int n = clonee.getElementCount();
<i>2135</i>&nbsp;            Element[] children = new Element[n];
<i>2136</i>&nbsp;            for (int i = 0; i &lt; n; i++) {
<i>2137</i>&nbsp;                children[i] = clone(e, clonee.getElement(i));
<i>2138</i>&nbsp;            }
<i>2139</i>&nbsp;            ((BranchElement)e).replace(0, 0, children);
<b class="nc"><i>2140</i>&nbsp;            return e;</b>
<b class="nc"><i>2141</i>&nbsp;        }</b>
<b class="nc"><i>2142</i>&nbsp;</b>
<b class="nc"><i>2143</i>&nbsp;        /**</b>
<i>2144</i>&nbsp;         * Creates a copy of this element, with a different
<b class="nc"><i>2145</i>&nbsp;         * parent. Children of this element included in the</b>
<b class="nc"><i>2146</i>&nbsp;         * removal range will be discarded.</b>
<b class="nc"><i>2147</i>&nbsp;         */</b>
<b class="nc"><i>2148</i>&nbsp;        Element cloneAsNecessary(Element parent, Element clonee, int rmOffs0, int rmOffs1) {</b>
<b class="nc"><i>2149</i>&nbsp;            if (clonee.isLeaf()) {</b>
<b class="nc"><i>2150</i>&nbsp;                return createLeafElement(parent, clonee.getAttributes(),</b>
<b class="nc"><i>2151</i>&nbsp;                                         clonee.getStartOffset(),</b>
<i>2152</i>&nbsp;                                         clonee.getEndOffset());
<i>2153</i>&nbsp;            }
<b class="nc"><i>2154</i>&nbsp;            Element e = createBranchElement(parent, clonee.getAttributes());</b>
<b class="nc"><i>2155</i>&nbsp;            int n = clonee.getElementCount();</b>
<b class="nc"><i>2156</i>&nbsp;            ArrayList&lt;Element&gt; childrenList = new ArrayList&lt;Element&gt;(n);</b>
<b class="nc"><i>2157</i>&nbsp;            for (int i = 0; i &lt; n; i++) {</b>
<i>2158</i>&nbsp;                Element elem = clonee.getElement(i);
<i>2159</i>&nbsp;                if (elem.getStartOffset() &lt; rmOffs0 || elem.getEndOffset() &gt; rmOffs1) {
<i>2160</i>&nbsp;                    childrenList.add(cloneAsNecessary(e, elem, rmOffs0, rmOffs1));
<i>2161</i>&nbsp;                }
<i>2162</i>&nbsp;            }
<i>2163</i>&nbsp;            Element[] children = new Element[childrenList.size()];
<i>2164</i>&nbsp;            children = childrenList.toArray(children);
<i>2165</i>&nbsp;            ((BranchElement)e).replace(0, 0, children);
<i>2166</i>&nbsp;            return e;
<i>2167</i>&nbsp;        }
<i>2168</i>&nbsp;
<i>2169</i>&nbsp;        /**
<i>2170</i>&nbsp;         * Determines if a fracture needs to be performed. A fracture
<i>2171</i>&nbsp;         * can be thought of as moving the right part of a tree to a
<b class="nc"><i>2172</i>&nbsp;         * new location, where the right part is determined by what has</b>
<b class="nc"><i>2173</i>&nbsp;         * been inserted. &lt;code&gt;depth&lt;/code&gt; is used to indicate a</b>
<b class="nc"><i>2174</i>&nbsp;         * JoinToFracture is needed to an element at a depth</b>
<b class="nc"><i>2175</i>&nbsp;         * of &lt;code&gt;depth&lt;/code&gt;. Where the root is 0, 1 is the children</b>
<i>2176</i>&nbsp;         * of the root...
<i>2177</i>&nbsp;         * &lt;p&gt;This will invoke &lt;code&gt;fractureFrom&lt;/code&gt; if it is determined
<b class="nc"><i>2178</i>&nbsp;         * a fracture needs to happen.</b>
<b class="nc"><i>2179</i>&nbsp;         */</b>
<b class="nc"><i>2180</i>&nbsp;        void fracture(int depth) {</b>
<b class="nc"><i>2181</i>&nbsp;            int cLength = insertPath.length;</b>
<i>2182</i>&nbsp;            int lastIndex = -1;
<b class="nc"><i>2183</i>&nbsp;            boolean needRecreate = recreateLeafs;</b>
<i>2184</i>&nbsp;            ElemChanges lastChange = insertPath[cLength - 1];
<i>2185</i>&nbsp;            // Use childAltered to determine when a child has been altered,
<i>2186</i>&nbsp;            // that is the point of insertion is less than the element count.
<b class="nc"><i>2187</i>&nbsp;            boolean childAltered = ((lastChange.index + 1) &lt;</b>
<b class="nc"><i>2188</i>&nbsp;                                    lastChange.parent.getElementCount());</b>
<b class="nc"><i>2189</i>&nbsp;            int deepestAlteredIndex = (needRecreate) ? cLength : -1;</b>
<b class="nc"><i>2190</i>&nbsp;            int lastAlteredIndex = cLength - 1;</b>
<b class="nc"><i>2191</i>&nbsp;</b>
<b class="nc"><i>2192</i>&nbsp;            createdFracture = true;</b>
<b class="nc"><i>2193</i>&nbsp;            // Determine where to start recreating from.</b>
<b class="nc"><i>2194</i>&nbsp;            // Start at - 2, as first one is indicated by recreateLeafs and</b>
<i>2195</i>&nbsp;            // childAltered.
<i>2196</i>&nbsp;            for(int counter = cLength - 2; counter &gt;= 0; counter--) {
<b class="nc"><i>2197</i>&nbsp;                ElemChanges change = insertPath[counter];</b>
<b class="nc"><i>2198</i>&nbsp;                if(change.added.size() &gt; 0 || counter == depth) {</b>
<b class="nc"><i>2199</i>&nbsp;                    lastIndex = counter;</b>
<b class="nc"><i>2200</i>&nbsp;                    if(!needRecreate &amp;&amp; childAltered) {</b>
<i>2201</i>&nbsp;                        needRecreate = true;
<i>2202</i>&nbsp;                        if(deepestAlteredIndex == -1)
<b class="nc"><i>2203</i>&nbsp;                            deepestAlteredIndex = lastAlteredIndex + 1;</b>
<i>2204</i>&nbsp;                    }
<i>2205</i>&nbsp;                }
<b class="nc"><i>2206</i>&nbsp;                if(!childAltered &amp;&amp; change.index &lt;</b>
<b class="nc"><i>2207</i>&nbsp;                   change.parent.getElementCount()) {</b>
<b class="nc"><i>2208</i>&nbsp;                    childAltered = true;</b>
<i>2209</i>&nbsp;                    lastAlteredIndex = counter;
<i>2210</i>&nbsp;                }
<i>2211</i>&nbsp;            }
<i>2212</i>&nbsp;            if(needRecreate) {
<i>2213</i>&nbsp;                // Recreate all children to right of parent starting
<i>2214</i>&nbsp;                // at lastIndex.
<i>2215</i>&nbsp;                if(lastIndex == -1)
<i>2216</i>&nbsp;                    lastIndex = cLength - 1;
<i>2217</i>&nbsp;                fractureFrom(insertPath, lastIndex, deepestAlteredIndex);
<i>2218</i>&nbsp;            }
<i>2219</i>&nbsp;        }
<i>2220</i>&nbsp;
<i>2221</i>&nbsp;        /**
<i>2222</i>&nbsp;         * Recreates the elements to the right of the insertion point.
<i>2223</i>&nbsp;         * This starts at &lt;code&gt;startIndex&lt;/code&gt; in &lt;code&gt;changed&lt;/code&gt;,
<b class="nc"><i>2224</i>&nbsp;         * and calls duplicate to duplicate existing elements.</b>
<i>2225</i>&nbsp;         * This will also duplicate the elements along the insertion
<i>2226</i>&nbsp;         * point, until a depth of &lt;code&gt;endFractureIndex&lt;/code&gt; is
<b class="nc"><i>2227</i>&nbsp;         * reached, at which point only the elements to the right of</b>
<i>2228</i>&nbsp;         * the insertion point are duplicated.
<b class="nc"><i>2229</i>&nbsp;         */</b>
<b class="nc"><i>2230</i>&nbsp;        void fractureFrom(ElemChanges[] changed, int startIndex,</b>
<i>2231</i>&nbsp;                          int endFractureIndex) {
<b class="nc"><i>2232</i>&nbsp;            // Recreate the element representing the inserted index.</b>
<b class="nc"><i>2233</i>&nbsp;            ElemChanges change = changed[startIndex];</b>
<b class="nc"><i>2234</i>&nbsp;            Element child;</b>
<b class="nc"><i>2235</i>&nbsp;            Element newChild;</b>
<b class="nc"><i>2236</i>&nbsp;            int changeLength = changed.length;</b>
<i>2237</i>&nbsp;
<i>2238</i>&nbsp;            if((startIndex + 1) == changeLength)
<b class="nc"><i>2239</i>&nbsp;                child = change.parent.getElement(change.index);</b>
<b class="nc"><i>2240</i>&nbsp;            else</b>
<i>2241</i>&nbsp;                child = change.parent.getElement(change.index - 1);
<b class="nc"><i>2242</i>&nbsp;            if(child.isLeaf()) {</b>
<b class="nc"><i>2243</i>&nbsp;                newChild = createLeafElement(change.parent,</b>
<i>2244</i>&nbsp;                               child.getAttributes(), Math.max(endOffset,
<i>2245</i>&nbsp;                               child.getStartOffset()), child.getEndOffset());
<i>2246</i>&nbsp;            }
<b class="nc"><i>2247</i>&nbsp;            else {</b>
<i>2248</i>&nbsp;                newChild = createBranchElement(change.parent,
<b class="nc"><i>2249</i>&nbsp;                                               child.getAttributes());</b>
<b class="nc"><i>2250</i>&nbsp;            }</b>
<b class="nc"><i>2251</i>&nbsp;            fracturedParent = change.parent;</b>
<i>2252</i>&nbsp;            fracturedChild = newChild;
<i>2253</i>&nbsp;
<i>2254</i>&nbsp;            // Recreate all the elements to the right of the
<i>2255</i>&nbsp;            // insertion point.
<b class="nc"><i>2256</i>&nbsp;            Element parent = newChild;</b>
<i>2257</i>&nbsp;
<i>2258</i>&nbsp;            while(++startIndex &lt; endFractureIndex) {
<i>2259</i>&nbsp;                boolean isEnd = ((startIndex + 1) == endFractureIndex);
<b class="nc"><i>2260</i>&nbsp;                boolean isEndLeaf = ((startIndex + 1) == changeLength);</b>
<b class="nc"><i>2261</i>&nbsp;</b>
<b class="nc"><i>2262</i>&nbsp;                // Create the newChild, a duplicate of the elment at</b>
<i>2263</i>&nbsp;                // index. This isn&#39;t done if isEnd and offsetLastIndex are true
<b class="nc"><i>2264</i>&nbsp;                // indicating a join previous was done.</b>
<i>2265</i>&nbsp;                change = changed[startIndex];
<i>2266</i>&nbsp;
<b class="nc"><i>2267</i>&nbsp;                // Determine the child to duplicate, won&#39;t have to duplicate</b>
<i>2268</i>&nbsp;                // if at end of fracture, or offseting index.
<i>2269</i>&nbsp;                if(isEnd) {
<b class="nc"><i>2270</i>&nbsp;                    if(offsetLastIndex || !isEndLeaf)</b>
<b class="nc"><i>2271</i>&nbsp;                        child = null;</b>
<b class="nc"><i>2272</i>&nbsp;                    else</b>
<b class="nc"><i>2273</i>&nbsp;                        child = change.parent.getElement(change.index);</b>
<b class="nc"><i>2274</i>&nbsp;                }</b>
<i>2275</i>&nbsp;                else {
<i>2276</i>&nbsp;                    child = change.parent.getElement(change.index - 1);
<b class="nc"><i>2277</i>&nbsp;                }</b>
<b class="nc"><i>2278</i>&nbsp;                // Duplicate it.</b>
<i>2279</i>&nbsp;                if(child != null) {
<i>2280</i>&nbsp;                    if(child.isLeaf()) {
<i>2281</i>&nbsp;                        newChild = createLeafElement(parent,
<b class="nc"><i>2282</i>&nbsp;                               child.getAttributes(), Math.max(endOffset,</b>
<i>2283</i>&nbsp;                               child.getStartOffset()), child.getEndOffset());
<i>2284</i>&nbsp;                    }
<b class="nc"><i>2285</i>&nbsp;                    else {</b>
<i>2286</i>&nbsp;                        newChild = createBranchElement(parent,
<i>2287</i>&nbsp;                                                   child.getAttributes());
<i>2288</i>&nbsp;                    }
<b class="nc"><i>2289</i>&nbsp;                }</b>
<i>2290</i>&nbsp;                else
<b class="nc"><i>2291</i>&nbsp;                    newChild = null;</b>
<i>2292</i>&nbsp;
<b class="nc"><i>2293</i>&nbsp;                // Recreate the remaining children (there may be none).</b>
<b class="nc"><i>2294</i>&nbsp;                int kidsToMove = change.parent.getElementCount() -</b>
<b class="nc"><i>2295</i>&nbsp;                                 change.index;</b>
<i>2296</i>&nbsp;                Element[] kids;
<i>2297</i>&nbsp;                int moveStartIndex;
<b class="nc"><i>2298</i>&nbsp;                int kidStartIndex = 1;</b>
<i>2299</i>&nbsp;
<b class="nc"><i>2300</i>&nbsp;                if(newChild == null) {</b>
<b class="nc"><i>2301</i>&nbsp;                    // Last part of fracture.</b>
<i>2302</i>&nbsp;                    if(isEndLeaf) {
<i>2303</i>&nbsp;                        kidsToMove--;
<b class="nc"><i>2304</i>&nbsp;                        moveStartIndex = change.index + 1;</b>
<i>2305</i>&nbsp;                    }
<b class="nc"><i>2306</i>&nbsp;                    else {</b>
<b class="nc"><i>2307</i>&nbsp;                        moveStartIndex = change.index;</b>
<i>2308</i>&nbsp;                    }
<i>2309</i>&nbsp;                    kidStartIndex = 0;
<i>2310</i>&nbsp;                    kids = new Element[kidsToMove];
<b class="nc"><i>2311</i>&nbsp;                }</b>
<i>2312</i>&nbsp;                else {
<b class="nc"><i>2313</i>&nbsp;                    if(!isEnd) {</b>
<b class="nc"><i>2314</i>&nbsp;                        // Branch.</b>
<i>2315</i>&nbsp;                        kidsToMove++;
<i>2316</i>&nbsp;                        moveStartIndex = change.index;
<b class="nc"><i>2317</i>&nbsp;                    }</b>
<b class="nc"><i>2318</i>&nbsp;                    else {</b>
<b class="nc"><i>2319</i>&nbsp;                        // Last leaf, need to recreate part of it.</b>
<b class="nc"><i>2320</i>&nbsp;                        moveStartIndex = change.index + 1;</b>
<b class="nc"><i>2321</i>&nbsp;                    }</b>
<i>2322</i>&nbsp;                    kids = new Element[kidsToMove];
<b class="nc"><i>2323</i>&nbsp;                    kids[0] = newChild;</b>
<b class="nc"><i>2324</i>&nbsp;                }</b>
<b class="nc"><i>2325</i>&nbsp;</b>
<i>2326</i>&nbsp;                for(int counter = kidStartIndex; counter &lt; kidsToMove;
<i>2327</i>&nbsp;                    counter++) {
<i>2328</i>&nbsp;                    Element toMove =change.parent.getElement(moveStartIndex++);
<i>2329</i>&nbsp;                    kids[counter] = recreateFracturedElement(parent, toMove);
<i>2330</i>&nbsp;                    change.removed.addElement(toMove);
<i>2331</i>&nbsp;                }
<i>2332</i>&nbsp;                ((BranchElement)parent).replace(0, 0, kids);
<i>2333</i>&nbsp;                parent = newChild;
<i>2334</i>&nbsp;            }
<b class="nc"><i>2335</i>&nbsp;        }</b>
<b class="nc"><i>2336</i>&nbsp;</b>
<b class="nc"><i>2337</i>&nbsp;        /**</b>
<i>2338</i>&nbsp;         * Recreates &lt;code&gt;toDuplicate&lt;/code&gt;. This is called when an
<b class="nc"><i>2339</i>&nbsp;         * element needs to be created as the result of an insertion. This</b>
<i>2340</i>&nbsp;         * will recurse and create all the children. This is similar to
<i>2341</i>&nbsp;         * &lt;code&gt;clone&lt;/code&gt;, but deteremines the offsets differently.
<b class="nc"><i>2342</i>&nbsp;         */</b>
<b class="nc"><i>2343</i>&nbsp;        Element recreateFracturedElement(Element parent, Element toDuplicate) {</b>
<b class="nc"><i>2344</i>&nbsp;            if(toDuplicate.isLeaf()) {</b>
<b class="nc"><i>2345</i>&nbsp;                return createLeafElement(parent, toDuplicate.getAttributes(),</b>
<b class="nc"><i>2346</i>&nbsp;                                         Math.max(toDuplicate.getStartOffset(),</b>
<b class="nc"><i>2347</i>&nbsp;                                                  endOffset),</b>
<b class="nc"><i>2348</i>&nbsp;                                         toDuplicate.getEndOffset());</b>
<i>2349</i>&nbsp;            }
<b class="nc"><i>2350</i>&nbsp;            // Not a leaf</b>
<b class="nc"><i>2351</i>&nbsp;            Element newParent = createBranchElement(parent, toDuplicate.</b>
<i>2352</i>&nbsp;                                                    getAttributes());
<i>2353</i>&nbsp;            int childCount = toDuplicate.getElementCount();
<i>2354</i>&nbsp;            Element[] newKids = new Element[childCount];
<i>2355</i>&nbsp;            for(int counter = 0; counter &lt; childCount; counter++) {
<i>2356</i>&nbsp;                newKids[counter] = recreateFracturedElement(newParent,
<i>2357</i>&nbsp;                                             toDuplicate.getElement(counter));
<i>2358</i>&nbsp;            }
<i>2359</i>&nbsp;            ((BranchElement)newParent).replace(0, 0, newKids);
<b class="nc"><i>2360</i>&nbsp;            return newParent;</b>
<b class="nc"><i>2361</i>&nbsp;        }</b>
<i>2362</i>&nbsp;
<i>2363</i>&nbsp;        /**
<b class="nc"><i>2364</i>&nbsp;         * Splits the bottommost leaf in &lt;code&gt;path&lt;/code&gt;.</b>
<b class="nc"><i>2365</i>&nbsp;         * This is called from insert when the first element is NOT content.</b>
<b class="nc"><i>2366</i>&nbsp;         */</b>
<b class="nc"><i>2367</i>&nbsp;        void fractureDeepestLeaf(ElementSpec[] specs) {</b>
<i>2368</i>&nbsp;            // Split the bottommost leaf. It will be recreated elsewhere.
<i>2369</i>&nbsp;            ElemChanges ec = path.peek();
<b class="nc"><i>2370</i>&nbsp;            Element child = ec.parent.getElement(ec.index);</b>
<i>2371</i>&nbsp;            // Inserts at offset 0 do not need to recreate child (it would
<b class="nc"><i>2372</i>&nbsp;            // have a length of 0!).</b>
<b class="nc"><i>2373</i>&nbsp;            if (offset != 0) {</b>
<b class="nc"><i>2374</i>&nbsp;                Element newChild = createLeafElement(ec.parent,</b>
<i>2375</i>&nbsp;                                                 child.getAttributes(),
<b class="nc"><i>2376</i>&nbsp;                                                 child.getStartOffset(),</b>
<i>2377</i>&nbsp;                                                 offset);
<i>2378</i>&nbsp;
<i>2379</i>&nbsp;                ec.added.addElement(newChild);
<i>2380</i>&nbsp;            }
<i>2381</i>&nbsp;            ec.removed.addElement(child);
<i>2382</i>&nbsp;            if(child.getEndOffset() != endOffset)
<i>2383</i>&nbsp;                recreateLeafs = true;
<b class="nc"><i>2384</i>&nbsp;            else</b>
<b class="nc"><i>2385</i>&nbsp;                offsetLastIndex = true;</b>
<b class="nc"><i>2386</i>&nbsp;        }</b>
<b class="nc"><i>2387</i>&nbsp;</b>
<b class="nc"><i>2388</i>&nbsp;        /**</b>
<i>2389</i>&nbsp;         * Inserts the first content. This needs to be separate to handle
<b class="nc"><i>2390</i>&nbsp;         * joining.</b>
<i>2391</i>&nbsp;         */
<b class="nc"><i>2392</i>&nbsp;        void insertFirstContent(ElementSpec[] specs) {</b>
<i>2393</i>&nbsp;            ElementSpec firstSpec = specs[0];
<i>2394</i>&nbsp;            ElemChanges ec = path.peek();
<b class="nc"><i>2395</i>&nbsp;            Element child = ec.parent.getElement(ec.index);</b>
<b class="nc"><i>2396</i>&nbsp;            int firstEndOffset = offset + firstSpec.getLength();</b>
<i>2397</i>&nbsp;            boolean isOnlyContent = (specs.length == 1);
<b class="nc"><i>2398</i>&nbsp;</b>
<b class="nc"><i>2399</i>&nbsp;            switch(firstSpec.getDirection()) {</b>
<i>2400</i>&nbsp;            case ElementSpec.JoinPreviousDirection:
<b class="nc"><i>2401</i>&nbsp;                if(child.getEndOffset() != firstEndOffset &amp;&amp;</b>
<b class="nc"><i>2402</i>&nbsp;                    !isOnlyContent) {</b>
<i>2403</i>&nbsp;                    // Create the left split part containing new content.
<b class="nc"><i>2404</i>&nbsp;                    Element newE = createLeafElement(ec.parent,</b>
<b class="nc"><i>2405</i>&nbsp;                            child.getAttributes(), child.getStartOffset(),</b>
<i>2406</i>&nbsp;                            firstEndOffset);
<b class="nc"><i>2407</i>&nbsp;                    ec.added.addElement(newE);</b>
<b class="nc"><i>2408</i>&nbsp;                    ec.removed.addElement(child);</b>
<i>2409</i>&nbsp;                    // Remainder will be created later.
<i>2410</i>&nbsp;                    if(child.getEndOffset() != endOffset)
<i>2411</i>&nbsp;                        recreateLeafs = true;
<b class="nc"><i>2412</i>&nbsp;                    else</b>
<i>2413</i>&nbsp;                        offsetLastIndex = true;
<b class="nc"><i>2414</i>&nbsp;                }</b>
<i>2415</i>&nbsp;                else {
<i>2416</i>&nbsp;                    offsetLastIndex = true;
<b class="nc"><i>2417</i>&nbsp;                    offsetLastIndexOnReplace = true;</b>
<b class="nc"><i>2418</i>&nbsp;                }</b>
<i>2419</i>&nbsp;                // else Inserted at end, and is total length.
<b class="nc"><i>2420</i>&nbsp;                // Update index incase something added/removed.</b>
<i>2421</i>&nbsp;                break;
<i>2422</i>&nbsp;            case ElementSpec.JoinNextDirection:
<b class="nc"><i>2423</i>&nbsp;                if(offset != 0) {</b>
<b class="nc"><i>2424</i>&nbsp;                    // Recreate the first element, its offset will have</b>
<b class="nc"><i>2425</i>&nbsp;                    // changed.</b>
<b class="nc"><i>2426</i>&nbsp;                    Element newE = createLeafElement(ec.parent,</b>
<i>2427</i>&nbsp;                            child.getAttributes(), child.getStartOffset(),
<b class="nc"><i>2428</i>&nbsp;                            offset);</b>
<b class="nc"><i>2429</i>&nbsp;                    ec.added.addElement(newE);</b>
<b class="nc"><i>2430</i>&nbsp;                    // Recreate the second, merge part. We do no checking</b>
<b class="nc"><i>2431</i>&nbsp;                    // to see if JoinNextDirection is valid here!</b>
<b class="nc"><i>2432</i>&nbsp;                    Element nextChild = ec.parent.getElement(ec.index + 1);</b>
<b class="nc"><i>2433</i>&nbsp;                    if(isOnlyContent)</b>
<i>2434</i>&nbsp;                        newE = createLeafElement(ec.parent, nextChild.
<i>2435</i>&nbsp;                            getAttributes(), offset, nextChild.getEndOffset());
<i>2436</i>&nbsp;                    else
<i>2437</i>&nbsp;                        newE = createLeafElement(ec.parent, nextChild.
<i>2438</i>&nbsp;                            getAttributes(), offset, firstEndOffset);
<i>2439</i>&nbsp;                    ec.added.addElement(newE);
<b class="nc"><i>2440</i>&nbsp;                    ec.removed.addElement(child);</b>
<b class="nc"><i>2441</i>&nbsp;                    ec.removed.addElement(nextChild);</b>
<b class="nc"><i>2442</i>&nbsp;                }</b>
<i>2443</i>&nbsp;                // else nothin to do.
<b class="nc"><i>2444</i>&nbsp;                // PENDING: if !isOnlyContent could raise here!</b>
<i>2445</i>&nbsp;                break;
<b class="nc"><i>2446</i>&nbsp;            default:</b>
<i>2447</i>&nbsp;                // Inserted into middle, need to recreate split left
<b class="nc"><i>2448</i>&nbsp;                // new content, and split right.</b>
<b class="nc"><i>2449</i>&nbsp;                if(child.getStartOffset() != offset) {</b>
<i>2450</i>&nbsp;                    Element newE = createLeafElement(ec.parent,
<b class="nc"><i>2451</i>&nbsp;                            child.getAttributes(), child.getStartOffset(),</b>
<b class="nc"><i>2452</i>&nbsp;                            offset);</b>
<i>2453</i>&nbsp;                    ec.added.addElement(newE);
<b class="nc"><i>2454</i>&nbsp;                }</b>
<i>2455</i>&nbsp;                ec.removed.addElement(child);
<i>2456</i>&nbsp;                // new content
<b class="nc"><i>2457</i>&nbsp;                Element newE = createLeafElement(ec.parent,</b>
<i>2458</i>&nbsp;                                                 firstSpec.getAttributes(),
<i>2459</i>&nbsp;                                                 offset, firstEndOffset);
<i>2460</i>&nbsp;                ec.added.addElement(newE);
<i>2461</i>&nbsp;                if(child.getEndOffset() != endOffset) {
<i>2462</i>&nbsp;                    // Signals need to recreate right split later.
<i>2463</i>&nbsp;                    recreateLeafs = true;
<i>2464</i>&nbsp;                }
<i>2465</i>&nbsp;                else {
<i>2466</i>&nbsp;                    offsetLastIndex = true;
<i>2467</i>&nbsp;                }
<i>2468</i>&nbsp;                break;
<i>2469</i>&nbsp;            }
<i>2470</i>&nbsp;        }
<i>2471</i>&nbsp;
<i>2472</i>&nbsp;        Element root;
<i>2473</i>&nbsp;        transient int pos;          // current position
<i>2474</i>&nbsp;        transient int offset;
<i>2475</i>&nbsp;        transient int length;
<i>2476</i>&nbsp;        transient int endOffset;
<i>2477</i>&nbsp;        transient Vector&lt;ElemChanges&gt; changes;
<i>2478</i>&nbsp;        transient Stack&lt;ElemChanges&gt; path;
<i>2479</i>&nbsp;        transient boolean insertOp;
<i>2480</i>&nbsp;
<i>2481</i>&nbsp;        transient boolean recreateLeafs; // For insert.
<i>2482</i>&nbsp;
<i>2483</i>&nbsp;        /** For insert, path to inserted elements. */
<i>2484</i>&nbsp;        transient ElemChanges[] insertPath;
<i>2485</i>&nbsp;        /** Only for insert, set to true when the fracture has been created. */
<i>2486</i>&nbsp;        transient boolean createdFracture;
<i>2487</i>&nbsp;        /** Parent that contains the fractured child. */
<i>2488</i>&nbsp;        transient Element fracturedParent;
<i>2489</i>&nbsp;        /** Fractured child. */
<i>2490</i>&nbsp;        transient Element fracturedChild;
<i>2491</i>&nbsp;        /** Used to indicate when fracturing that the last leaf should be
<i>2492</i>&nbsp;         * skipped. */
<i>2493</i>&nbsp;        transient boolean offsetLastIndex;
<i>2494</i>&nbsp;        /** Used to indicate that the parent of the deepest leaf should
<b class="nc"><i>2495</i>&nbsp;         * offset the index by 1 when adding/removing elements in an</b>
<b class="nc"><i>2496</i>&nbsp;         * insert. */</b>
<b class="nc"><i>2497</i>&nbsp;        transient boolean offsetLastIndexOnReplace;</b>
<b class="nc"><i>2498</i>&nbsp;</b>
<b class="nc"><i>2499</i>&nbsp;        /*</b>
<b class="nc"><i>2500</i>&nbsp;         * Internal record used to hold element change specifications</b>
<i>2501</i>&nbsp;         */
<i>2502</i>&nbsp;        class ElemChanges {
<i>2503</i>&nbsp;
<b class="nc"><i>2504</i>&nbsp;            ElemChanges(Element parent, int index, boolean isFracture) {</b>
<i>2505</i>&nbsp;                this.parent = parent;
<i>2506</i>&nbsp;                this.index = index;
<i>2507</i>&nbsp;                this.isFracture = isFracture;
<i>2508</i>&nbsp;                added = new Vector&lt;Element&gt;();
<i>2509</i>&nbsp;                removed = new Vector&lt;Element&gt;();
<i>2510</i>&nbsp;            }
<i>2511</i>&nbsp;
<i>2512</i>&nbsp;            public String toString() {
<i>2513</i>&nbsp;                return &quot;added: &quot; + added + &quot;\nremoved: &quot; + removed + &quot;\n&quot;;
<i>2514</i>&nbsp;            }
<i>2515</i>&nbsp;
<i>2516</i>&nbsp;            Element parent;
<i>2517</i>&nbsp;            int index;
<i>2518</i>&nbsp;            Vector&lt;Element&gt; added;
<i>2519</i>&nbsp;            Vector&lt;Element&gt; removed;
<i>2520</i>&nbsp;            boolean isFracture;
<i>2521</i>&nbsp;        }
<i>2522</i>&nbsp;
<b class="nc"><i>2523</i>&nbsp;    }</b>
<b class="nc"><i>2524</i>&nbsp;</b>
<b class="nc"><i>2525</i>&nbsp;    /**</b>
<b class="nc"><i>2526</i>&nbsp;     * An UndoableEdit used to remember AttributeSet changes to an</b>
<i>2527</i>&nbsp;     * Element.
<i>2528</i>&nbsp;     */
<b class="nc"><i>2529</i>&nbsp;    public static class AttributeUndoableEdit extends AbstractUndoableEdit {</b>
<i>2530</i>&nbsp;        /**
<i>2531</i>&nbsp;         * Constructs an {@code AttributeUndoableEdit}.
<i>2532</i>&nbsp;         * @param element the element
<i>2533</i>&nbsp;         * @param newAttributes the new attributes
<i>2534</i>&nbsp;         * @param isReplacing true if all the attributes in the element were removed first.
<i>2535</i>&nbsp;         */
<i>2536</i>&nbsp;        public AttributeUndoableEdit(Element element, AttributeSet newAttributes,
<i>2537</i>&nbsp;                              boolean isReplacing) {
<b class="nc"><i>2538</i>&nbsp;            super();</b>
<b class="nc"><i>2539</i>&nbsp;            this.element = element;</b>
<b class="nc"><i>2540</i>&nbsp;            this.newAttributes = newAttributes;</b>
<b class="nc"><i>2541</i>&nbsp;            this.isReplacing = isReplacing;</b>
<b class="nc"><i>2542</i>&nbsp;            // If not replacing, it may be more efficient to only copy the</b>
<b class="nc"><i>2543</i>&nbsp;            // changed values...</b>
<i>2544</i>&nbsp;            copy = element.getAttributes().copyAttributes();
<i>2545</i>&nbsp;        }
<i>2546</i>&nbsp;
<i>2547</i>&nbsp;        /**
<i>2548</i>&nbsp;         * Redoes a change.
<i>2549</i>&nbsp;         *
<i>2550</i>&nbsp;         * @exception CannotRedoException if the change cannot be redone
<i>2551</i>&nbsp;         */
<b class="nc"><i>2552</i>&nbsp;        public void redo() throws CannotRedoException {</b>
<b class="nc"><i>2553</i>&nbsp;            super.redo();</b>
<b class="nc"><i>2554</i>&nbsp;            MutableAttributeSet as = (MutableAttributeSet)element</b>
<b class="nc"><i>2555</i>&nbsp;                                     .getAttributes();</b>
<i>2556</i>&nbsp;            if(isReplacing)
<i>2557</i>&nbsp;                as.removeAttributes(as);
<i>2558</i>&nbsp;            as.addAttributes(newAttributes);
<i>2559</i>&nbsp;        }
<i>2560</i>&nbsp;
<i>2561</i>&nbsp;        /**
<i>2562</i>&nbsp;         * Undoes a change.
<i>2563</i>&nbsp;         *
<i>2564</i>&nbsp;         * @exception CannotUndoException if the change cannot be undone
<i>2565</i>&nbsp;         */
<i>2566</i>&nbsp;        public void undo() throws CannotUndoException {
<i>2567</i>&nbsp;            super.undo();
<i>2568</i>&nbsp;            MutableAttributeSet as = (MutableAttributeSet)element.getAttributes();
<i>2569</i>&nbsp;            as.removeAttributes(as);
<i>2570</i>&nbsp;            as.addAttributes(copy);
<i>2571</i>&nbsp;        }
<i>2572</i>&nbsp;
<i>2573</i>&nbsp;        /**
<b class="nc"><i>2574</i>&nbsp;         * AttributeSet containing additional entries, must be non-mutable!</b>
<b class="nc"><i>2575</i>&nbsp;         */</b>
<b class="nc"><i>2576</i>&nbsp;        protected AttributeSet newAttributes;</b>
<b class="nc"><i>2577</i>&nbsp;        /**</b>
<i>2578</i>&nbsp;         * Copy of the AttributeSet the Element contained.
<i>2579</i>&nbsp;         */
<i>2580</i>&nbsp;        protected AttributeSet copy;
<i>2581</i>&nbsp;        /**
<i>2582</i>&nbsp;         * true if all the attributes in the element were removed first.
<i>2583</i>&nbsp;         */
<i>2584</i>&nbsp;        protected boolean isReplacing;
<i>2585</i>&nbsp;        /**
<b class="nc"><i>2586</i>&nbsp;         * Affected Element.</b>
<b class="nc"><i>2587</i>&nbsp;         */</b>
<i>2588</i>&nbsp;        protected Element element;
<i>2589</i>&nbsp;    }
<i>2590</i>&nbsp;
<i>2591</i>&nbsp;    /**
<i>2592</i>&nbsp;     * UndoableEdit for changing the resolve parent of an Element.
<i>2593</i>&nbsp;     */
<i>2594</i>&nbsp;    static class StyleChangeUndoableEdit extends AbstractUndoableEdit {
<i>2595</i>&nbsp;        public StyleChangeUndoableEdit(AbstractElement element,
<b class="nc"><i>2596</i>&nbsp;                                       Style newStyle) {</b>
<b class="nc"><i>2597</i>&nbsp;            super();</b>
<i>2598</i>&nbsp;            this.element = element;
<i>2599</i>&nbsp;            this.newStyle = newStyle;
<i>2600</i>&nbsp;            oldStyle = element.getResolveParent();
<i>2601</i>&nbsp;        }
<i>2602</i>&nbsp;
<i>2603</i>&nbsp;        /**
<i>2604</i>&nbsp;         * Redoes a change.
<i>2605</i>&nbsp;         *
<i>2606</i>&nbsp;         * @exception CannotRedoException if the change cannot be redone
<i>2607</i>&nbsp;         */
<i>2608</i>&nbsp;        public void redo() throws CannotRedoException {
<i>2609</i>&nbsp;            super.redo();
<i>2610</i>&nbsp;            element.setResolveParent(newStyle);
<i>2611</i>&nbsp;        }
<i>2612</i>&nbsp;
<i>2613</i>&nbsp;        /**
<i>2614</i>&nbsp;         * Undoes a change.
<i>2615</i>&nbsp;         *
<b class="nc"><i>2616</i>&nbsp;         * @exception CannotUndoException if the change cannot be undone</b>
<b class="nc"><i>2617</i>&nbsp;         */</b>
<i>2618</i>&nbsp;        public void undo() throws CannotUndoException {
<i>2619</i>&nbsp;            super.undo();
<i>2620</i>&nbsp;            element.setResolveParent(oldStyle);
<i>2621</i>&nbsp;        }
<i>2622</i>&nbsp;
<i>2623</i>&nbsp;        /** Element to change resolve parent of. */
<b class="nc"><i>2624</i>&nbsp;        protected AbstractElement element;</b>
<i>2625</i>&nbsp;        /** New style. */
<i>2626</i>&nbsp;        protected Style newStyle;
<i>2627</i>&nbsp;        /** Old style, before setting newStyle. */
<i>2628</i>&nbsp;        protected AttributeSet oldStyle;
<b class="nc"><i>2629</i>&nbsp;    }</b>
<i>2630</i>&nbsp;
<i>2631</i>&nbsp;    /**
<i>2632</i>&nbsp;     * Base class for style change handlers with support for stale objects detection.
<i>2633</i>&nbsp;     */
<i>2634</i>&nbsp;    abstract static class AbstractChangeHandler implements ChangeListener {
<b class="nc"><i>2635</i>&nbsp;</b>
<b class="nc"><i>2636</i>&nbsp;        /* This has an implicit reference to the handler object.  */</b>
<i>2637</i>&nbsp;        private class DocReference extends WeakReference&lt;DefaultStyledDocument&gt; {
<b class="nc"><i>2638</i>&nbsp;</b>
<b class="nc"><i>2639</i>&nbsp;            DocReference(DefaultStyledDocument d, ReferenceQueue&lt;DefaultStyledDocument&gt; q) {</b>
<b class="nc"><i>2640</i>&nbsp;                super(d, q);</b>
<b class="nc"><i>2641</i>&nbsp;            }</b>
<b class="nc"><i>2642</i>&nbsp;</b>
<i>2643</i>&nbsp;            /**
<b class="nc"><i>2644</i>&nbsp;             * Return a reference to the style change handler object.</b>
<b class="nc"><i>2645</i>&nbsp;             */</b>
<i>2646</i>&nbsp;            ChangeListener getListener() {
<i>2647</i>&nbsp;                return AbstractChangeHandler.this;
<i>2648</i>&nbsp;            }
<i>2649</i>&nbsp;        }
<i>2650</i>&nbsp;
<i>2651</i>&nbsp;        /** Class-specific reference queues.  */
<i>2652</i>&nbsp;        private static final Map&lt;Class&lt;?&gt;, ReferenceQueue&lt;DefaultStyledDocument&gt;&gt; queueMap
<i>2653</i>&nbsp;                = new HashMap&lt;Class&lt;?&gt;, ReferenceQueue&lt;DefaultStyledDocument&gt;&gt;();
<b class="nc"><i>2654</i>&nbsp;</b>
<b class="nc"><i>2655</i>&nbsp;        /** A weak reference to the document object.  */</b>
<i>2656</i>&nbsp;        private DocReference doc;
<b class="nc"><i>2657</i>&nbsp;</b>
<i>2658</i>&nbsp;        AbstractChangeHandler(DefaultStyledDocument d) {
<b class="nc"><i>2659</i>&nbsp;            Class&lt;?&gt; c = getClass();</b>
<b class="nc"><i>2660</i>&nbsp;            ReferenceQueue&lt;DefaultStyledDocument&gt; q;</b>
<b class="nc"><i>2661</i>&nbsp;            synchronized (queueMap) {</b>
<i>2662</i>&nbsp;                q = queueMap.get(c);
<b class="nc"><i>2663</i>&nbsp;                if (q == null) {</b>
<i>2664</i>&nbsp;                    q = new ReferenceQueue&lt;DefaultStyledDocument&gt;();
<i>2665</i>&nbsp;                    queueMap.put(c, q);
<b class="nc"><i>2666</i>&nbsp;                }</b>
<i>2667</i>&nbsp;            }
<i>2668</i>&nbsp;            doc = new DocReference(d, q);
<i>2669</i>&nbsp;        }
<i>2670</i>&nbsp;
<i>2671</i>&nbsp;        /**
<i>2672</i>&nbsp;         * Return a list of stale change listeners.
<b class="nc"><i>2673</i>&nbsp;         *</b>
<b class="nc"><i>2674</i>&nbsp;         * A change listener becomes &quot;stale&quot; when its document is cleaned by GC.</b>
<b class="nc"><i>2675</i>&nbsp;         */</b>
<i>2676</i>&nbsp;        static List&lt;ChangeListener&gt; getStaleListeners(ChangeListener l) {
<i>2677</i>&nbsp;            List&lt;ChangeListener&gt; staleListeners = new ArrayList&lt;ChangeListener&gt;();
<i>2678</i>&nbsp;            ReferenceQueue&lt;DefaultStyledDocument&gt; q = queueMap.get(l.getClass());
<i>2679</i>&nbsp;
<i>2680</i>&nbsp;            if (q != null) {
<i>2681</i>&nbsp;                DocReference r;
<i>2682</i>&nbsp;                synchronized (q) {
<i>2683</i>&nbsp;                    while ((r = (DocReference) q.poll()) != null) {
<i>2684</i>&nbsp;                        staleListeners.add(r.getListener());
<i>2685</i>&nbsp;                    }
<i>2686</i>&nbsp;                }
<i>2687</i>&nbsp;            }
<i>2688</i>&nbsp;
<i>2689</i>&nbsp;            return staleListeners;
<b class="nc"><i>2690</i>&nbsp;        }</b>
<i>2691</i>&nbsp;
<i>2692</i>&nbsp;        /**
<i>2693</i>&nbsp;         * The ChangeListener wrapper which guards against dead documents.
<b class="nc"><i>2694</i>&nbsp;         */</b>
<b class="nc"><i>2695</i>&nbsp;        public void stateChanged(ChangeEvent e) {</b>
<b class="nc"><i>2696</i>&nbsp;            DefaultStyledDocument d = doc.get();</b>
<i>2697</i>&nbsp;            if (d != null) {
<b class="nc"><i>2698</i>&nbsp;                fireStateChanged(d, e);</b>
<i>2699</i>&nbsp;            }
<i>2700</i>&nbsp;        }
<i>2701</i>&nbsp;
<i>2702</i>&nbsp;        /** Run the actual class-specific stateChanged() method.  */
<i>2703</i>&nbsp;        abstract void fireStateChanged(DefaultStyledDocument d, ChangeEvent e);
<i>2704</i>&nbsp;    }
<i>2705</i>&nbsp;
<i>2706</i>&nbsp;    /**
<i>2707</i>&nbsp;     * Added to all the Styles. When instances of this receive a
<i>2708</i>&nbsp;     * stateChanged method, styleChanged is invoked.
<i>2709</i>&nbsp;     */
<i>2710</i>&nbsp;    static class StyleChangeHandler extends AbstractChangeHandler {
<b class="nc"><i>2711</i>&nbsp;</b>
<i>2712</i>&nbsp;        StyleChangeHandler(DefaultStyledDocument d) {
<i>2713</i>&nbsp;            super(d);
<i>2714</i>&nbsp;        }
<b class="nc"><i>2715</i>&nbsp;</b>
<i>2716</i>&nbsp;        void fireStateChanged(DefaultStyledDocument d, ChangeEvent e) {
<i>2717</i>&nbsp;            Object source = e.getSource();
<i>2718</i>&nbsp;            if (source instanceof Style) {
<i>2719</i>&nbsp;                d.styleChanged((Style) source);
<i>2720</i>&nbsp;            } else {
<i>2721</i>&nbsp;                d.styleChanged(null);
<i>2722</i>&nbsp;            }
<i>2723</i>&nbsp;        }
<b class="nc"><i>2724</i>&nbsp;    }</b>
<b class="nc"><i>2725</i>&nbsp;</b>
<i>2726</i>&nbsp;
<i>2727</i>&nbsp;    /**
<b class="nc"><i>2728</i>&nbsp;     * Added to the StyleContext. When the StyleContext changes, this invokes</b>
<b class="nc"><i>2729</i>&nbsp;     * &lt;code&gt;updateStylesListeningTo&lt;/code&gt;.</b>
<b class="nc"><i>2730</i>&nbsp;     */</b>
<i>2731</i>&nbsp;    static class StyleContextChangeHandler extends AbstractChangeHandler {
<i>2732</i>&nbsp;
<b class="nc"><i>2733</i>&nbsp;        StyleContextChangeHandler(DefaultStyledDocument d) {</b>
<b class="nc"><i>2734</i>&nbsp;            super(d);</b>
<b class="nc"><i>2735</i>&nbsp;        }</b>
<i>2736</i>&nbsp;
<b class="nc"><i>2737</i>&nbsp;        void fireStateChanged(DefaultStyledDocument d, ChangeEvent e) {</b>
<b class="nc"><i>2738</i>&nbsp;            d.updateStylesListeningTo();</b>
<i>2739</i>&nbsp;        }
<b class="nc"><i>2740</i>&nbsp;    }</b>
<b class="nc"><i>2741</i>&nbsp;</b>
<i>2742</i>&nbsp;
<i>2743</i>&nbsp;    /**
<i>2744</i>&nbsp;     * When run this creates a change event for the complete document
<i>2745</i>&nbsp;     * and fires it.
<i>2746</i>&nbsp;     */
<i>2747</i>&nbsp;    class ChangeUpdateRunnable implements Runnable {
<i>2748</i>&nbsp;        boolean isPending = false;
<i>2749</i>&nbsp;
<i>2750</i>&nbsp;        public void run() {
<i>2751</i>&nbsp;            synchronized(this) {
<i>2752</i>&nbsp;                isPending = false;
<i>2753</i>&nbsp;            }
<i>2754</i>&nbsp;
<i>2755</i>&nbsp;            try {
<i>2756</i>&nbsp;                writeLock();
<i>2757</i>&nbsp;                DefaultDocumentEvent dde = new DefaultDocumentEvent(0,
<i>2758</i>&nbsp;                                              getLength(),
<i>2759</i>&nbsp;                                              DocumentEvent.EventType.CHANGE);
<i>2760</i>&nbsp;                dde.end();
<i>2761</i>&nbsp;                fireChangedUpdate(dde);
<i>2762</i>&nbsp;            } finally {
<i>2763</i>&nbsp;                writeUnlock();
<i>2764</i>&nbsp;            }
<i>2765</i>&nbsp;        }
<i>2766</i>&nbsp;    }
<i>2767</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
