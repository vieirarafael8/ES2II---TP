


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Formatter</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util</a> ]
</div>

<h1>Coverage Summary for Class: Formatter (java.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Formatter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 101)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Formatter$BigDecimalLayoutForm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$Conversion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$DateTime</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$FixedString</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$Flags</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$FormatSpecifier</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 939)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Formatter$FormatSpecifier$BigDecimalLayout</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 68)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 123)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1187)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.util;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.BufferedWriter;
<i>29</i>&nbsp;import java.io.Closeable;
<i>30</i>&nbsp;import java.io.IOException;
<i>31</i>&nbsp;import java.io.File;
<i>32</i>&nbsp;import java.io.FileOutputStream;
<i>33</i>&nbsp;import java.io.FileNotFoundException;
<i>34</i>&nbsp;import java.io.Flushable;
<i>35</i>&nbsp;import java.io.OutputStream;
<i>36</i>&nbsp;import java.io.OutputStreamWriter;
<i>37</i>&nbsp;import java.io.PrintStream;
<i>38</i>&nbsp;import java.io.UnsupportedEncodingException;
<i>39</i>&nbsp;import java.math.BigDecimal;
<i>40</i>&nbsp;import java.math.BigInteger;
<i>41</i>&nbsp;import java.math.MathContext;
<i>42</i>&nbsp;import java.math.RoundingMode;
<i>43</i>&nbsp;import java.nio.charset.Charset;
<i>44</i>&nbsp;import java.nio.charset.IllegalCharsetNameException;
<i>45</i>&nbsp;import java.nio.charset.UnsupportedCharsetException;
<i>46</i>&nbsp;import java.text.DateFormatSymbols;
<i>47</i>&nbsp;import java.text.DecimalFormat;
<i>48</i>&nbsp;import java.text.DecimalFormatSymbols;
<i>49</i>&nbsp;import java.text.NumberFormat;
<i>50</i>&nbsp;import java.text.spi.NumberFormatProvider;
<i>51</i>&nbsp;import java.util.regex.Matcher;
<i>52</i>&nbsp;import java.util.regex.Pattern;
<i>53</i>&nbsp;import java.util.Objects;
<i>54</i>&nbsp;
<i>55</i>&nbsp;import java.time.DateTimeException;
<i>56</i>&nbsp;import java.time.Instant;
<i>57</i>&nbsp;import java.time.ZoneId;
<i>58</i>&nbsp;import java.time.ZoneOffset;
<i>59</i>&nbsp;import java.time.temporal.ChronoField;
<i>60</i>&nbsp;import java.time.temporal.TemporalAccessor;
<i>61</i>&nbsp;import java.time.temporal.TemporalQueries;
<i>62</i>&nbsp;import java.time.temporal.UnsupportedTemporalTypeException;
<i>63</i>&nbsp;
<i>64</i>&nbsp;import jdk.internal.math.DoubleConsts;
<i>65</i>&nbsp;import jdk.internal.math.FormattedFloatingDecimal;
<i>66</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>67</i>&nbsp;import sun.util.locale.provider.ResourceBundleBasedAdapter;
<i>68</i>&nbsp;
<i>69</i>&nbsp;/**
<i>70</i>&nbsp; * An interpreter for printf-style format strings.  This class provides support
<i>71</i>&nbsp; * for layout justification and alignment, common formats for numeric, string,
<i>72</i>&nbsp; * and date/time data, and locale-specific output.  Common Java types such as
<i>73</i>&nbsp; * {@code byte}, {@link java.math.BigDecimal BigDecimal}, and {@link Calendar}
<i>74</i>&nbsp; * are supported.  Limited formatting customization for arbitrary user types is
<i>75</i>&nbsp; * provided through the {@link Formattable} interface.
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * &lt;p&gt; Formatters are not necessarily safe for multithreaded access.  Thread
<i>78</i>&nbsp; * safety is optional and is the responsibility of users of methods in this
<i>79</i>&nbsp; * class.
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * &lt;p&gt; Formatted printing for the Java language is heavily inspired by C&#39;s
<i>82</i>&nbsp; * {@code printf}.  Although the format strings are similar to C, some
<i>83</i>&nbsp; * customizations have been made to accommodate the Java language and exploit
<i>84</i>&nbsp; * some of its features.  Also, Java formatting is more strict than C&#39;s; for
<i>85</i>&nbsp; * example, if a conversion is incompatible with a flag, an exception will be
<i>86</i>&nbsp; * thrown.  In C inapplicable flags are silently ignored.  The format strings
<i>87</i>&nbsp; * are thus intended to be recognizable to C programmers but not necessarily
<i>88</i>&nbsp; * completely compatible with those in C.
<i>89</i>&nbsp; *
<i>90</i>&nbsp; * &lt;p&gt; Examples of expected usage:
<i>91</i>&nbsp; *
<i>92</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>93</i>&nbsp; *   StringBuilder sb = new StringBuilder();
<i>94</i>&nbsp; *   // Send all output to the Appendable object sb
<i>95</i>&nbsp; *   Formatter formatter = new Formatter(sb, Locale.US);
<i>96</i>&nbsp; *
<i>97</i>&nbsp; *   // Explicit argument indices may be used to re-order output.
<i>98</i>&nbsp; *   formatter.format(&quot;%4$2s %3$2s %2$2s %1$2s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
<i>99</i>&nbsp; *   // -&amp;gt; &quot; d  c  b  a&quot;
<i>100</i>&nbsp; *
<i>101</i>&nbsp; *   // Optional locale as the first argument can be used to get
<i>102</i>&nbsp; *   // locale-specific formatting of numbers.  The precision and width can be
<i>103</i>&nbsp; *   // given to round and align the value.
<i>104</i>&nbsp; *   formatter.format(Locale.FRANCE, &quot;e = %+10.4f&quot;, Math.E);
<i>105</i>&nbsp; *   // -&amp;gt; &quot;e =    +2,7183&quot;
<i>106</i>&nbsp; *
<i>107</i>&nbsp; *   // The &#39;(&#39; numeric flag may be used to format negative numbers with
<i>108</i>&nbsp; *   // parentheses rather than a minus sign.  Group separators are
<i>109</i>&nbsp; *   // automatically inserted.
<i>110</i>&nbsp; *   formatter.format(&quot;Amount gained or lost since last statement: $ %(,.2f&quot;,
<i>111</i>&nbsp; *                    balanceDelta);
<i>112</i>&nbsp; *   // -&amp;gt; &quot;Amount gained or lost since last statement: $ (6,217.58)&quot;
<i>113</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>114</i>&nbsp; *
<i>115</i>&nbsp; * &lt;p&gt; Convenience methods for common formatting requests exist as illustrated
<i>116</i>&nbsp; * by the following invocations:
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>119</i>&nbsp; *   // Writes a formatted string to System.out.
<i>120</i>&nbsp; *   System.out.format(&quot;Local time: %tT&quot;, Calendar.getInstance());
<i>121</i>&nbsp; *   // -&amp;gt; &quot;Local time: 13:34:18&quot;
<i>122</i>&nbsp; *
<i>123</i>&nbsp; *   // Writes formatted output to System.err.
<i>124</i>&nbsp; *   System.err.printf(&quot;Unable to open file &#39;%1$s&#39;: %2$s&quot;,
<i>125</i>&nbsp; *                     fileName, exception.getMessage());
<i>126</i>&nbsp; *   // -&amp;gt; &quot;Unable to open file &#39;food&#39;: No such file or directory&quot;
<i>127</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>128</i>&nbsp; *
<i>129</i>&nbsp; * &lt;p&gt; Like C&#39;s {@code sprintf(3)}, Strings may be formatted using the static
<i>130</i>&nbsp; * method {@link String#format(String,Object...) String.format}:
<i>131</i>&nbsp; *
<i>132</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>133</i>&nbsp; *   // Format a string containing a date.
<i>134</i>&nbsp; *   import java.util.Calendar;
<i>135</i>&nbsp; *   import java.util.GregorianCalendar;
<i>136</i>&nbsp; *   import static java.util.Calendar.*;
<i>137</i>&nbsp; *
<i>138</i>&nbsp; *   Calendar c = new GregorianCalendar(1995, MAY, 23);
<i>139</i>&nbsp; *   String s = String.format(&quot;Duke&#39;s Birthday: %1$tb %1$te, %1$tY&quot;, c);
<i>140</i>&nbsp; *   // -&amp;gt; s == &quot;Duke&#39;s Birthday: May 23, 1995&quot;
<i>141</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>142</i>&nbsp; *
<i>143</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;org&quot;&gt;Organization&lt;/a&gt;&lt;/h3&gt;
<i>144</i>&nbsp; *
<i>145</i>&nbsp; * &lt;p&gt; This specification is divided into two sections.  The first section, &lt;a
<i>146</i>&nbsp; * href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;, covers the basic formatting concepts.  This
<i>147</i>&nbsp; * section is intended for users who want to get started quickly and are
<i>148</i>&nbsp; * familiar with formatted printing in other programming languages.  The second
<i>149</i>&nbsp; * section, &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;, covers the specific implementation
<i>150</i>&nbsp; * details.  It is intended for users who want more precise specification of
<i>151</i>&nbsp; * formatting behavior.
<i>152</i>&nbsp; *
<i>153</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;summary&quot;&gt;Summary&lt;/a&gt;&lt;/h3&gt;
<i>154</i>&nbsp; *
<i>155</i>&nbsp; * &lt;p&gt; This section is intended to provide a brief overview of formatting
<i>156</i>&nbsp; * concepts.  For precise behavioral details, refer to the &lt;a
<i>157</i>&nbsp; * href=&quot;#detail&quot;&gt;Details&lt;/a&gt; section.
<i>158</i>&nbsp; *
<i>159</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;syntax&quot;&gt;Format String Syntax&lt;/a&gt;&lt;/h4&gt;
<i>160</i>&nbsp; *
<i>161</i>&nbsp; * &lt;p&gt; Every method which produces formatted output requires a &lt;i&gt;format
<i>162</i>&nbsp; * string&lt;/i&gt; and an &lt;i&gt;argument list&lt;/i&gt;.  The format string is a {@link
<i>163</i>&nbsp; * String} which may contain fixed text and one or more embedded &lt;i&gt;format
<i>164</i>&nbsp; * specifiers&lt;/i&gt;.  Consider the following example:
<i>165</i>&nbsp; *
<i>166</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>167</i>&nbsp; *   Calendar c = ...;
<i>168</i>&nbsp; *   String s = String.format(&quot;Duke&#39;s Birthday: %1$tm %1$te,%1$tY&quot;, c);
<i>169</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>170</i>&nbsp; *
<i>171</i>&nbsp; * This format string is the first argument to the {@code format} method.  It
<i>172</i>&nbsp; * contains three format specifiers &quot;{@code %1$tm}&quot;, &quot;{@code %1$te}&quot;, and
<i>173</i>&nbsp; * &quot;{@code %1$tY}&quot; which indicate how the arguments should be processed and
<i>174</i>&nbsp; * where they should be inserted in the text.  The remaining portions of the
<i>175</i>&nbsp; * format string are fixed text including {@code &quot;Dukes Birthday: &quot;} and any
<i>176</i>&nbsp; * other spaces or punctuation.
<i>177</i>&nbsp; *
<i>178</i>&nbsp; * The argument list consists of all arguments passed to the method after the
<i>179</i>&nbsp; * format string.  In the above example, the argument list is of size one and
<i>180</i>&nbsp; * consists of the {@link java.util.Calendar Calendar} object {@code c}.
<i>181</i>&nbsp; *
<i>182</i>&nbsp; * &lt;ul&gt;
<i>183</i>&nbsp; *
<i>184</i>&nbsp; * &lt;li&gt; The format specifiers for general, character, and numeric types have
<i>185</i>&nbsp; * the following syntax:
<i>186</i>&nbsp; *
<i>187</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>188</i>&nbsp; *   %[argument_index$][flags][width][.precision]conversion
<i>189</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>190</i>&nbsp; *
<i>191</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt; is a decimal integer indicating the
<i>192</i>&nbsp; * position of the argument in the argument list.  The first argument is
<i>193</i>&nbsp; * referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
<i>194</i>&nbsp; *
<i>195</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; is a set of characters that modify the output
<i>196</i>&nbsp; * format.  The set of valid flags depends on the conversion.
<i>197</i>&nbsp; *
<i>198</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;width&lt;/i&gt; is a positive decimal integer indicating
<i>199</i>&nbsp; * the minimum number of characters to be written to the output.
<i>200</i>&nbsp; *
<i>201</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;precision&lt;/i&gt; is a non-negative decimal integer usually
<i>202</i>&nbsp; * used to restrict the number of characters.  The specific behavior depends on
<i>203</i>&nbsp; * the conversion.
<i>204</i>&nbsp; *
<i>205</i>&nbsp; * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating how the
<i>206</i>&nbsp; * argument should be formatted.  The set of valid conversions for a given
<i>207</i>&nbsp; * argument depends on the argument&#39;s data type.
<i>208</i>&nbsp; *
<i>209</i>&nbsp; * &lt;li&gt; The format specifiers for types which are used to represents dates and
<i>210</i>&nbsp; * times have the following syntax:
<i>211</i>&nbsp; *
<i>212</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>213</i>&nbsp; *   %[argument_index$][flags][width]conversion
<i>214</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>215</i>&nbsp; *
<i>216</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;argument_index&lt;/i&gt;, &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; are
<i>217</i>&nbsp; * defined as above.
<i>218</i>&nbsp; *
<i>219</i>&nbsp; * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a two character sequence.  The first
<i>220</i>&nbsp; * character is {@code &#39;t&#39;} or {@code &#39;T&#39;}.  The second character indicates
<i>221</i>&nbsp; * the format to be used.  These characters are similar to but not completely
<i>222</i>&nbsp; * identical to those defined by GNU {@code date} and POSIX
<i>223</i>&nbsp; * {@code strftime(3c)}.
<i>224</i>&nbsp; *
<i>225</i>&nbsp; * &lt;li&gt; The format specifiers which do not correspond to arguments have the
<i>226</i>&nbsp; * following syntax:
<i>227</i>&nbsp; *
<i>228</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>229</i>&nbsp; *   %[flags][width]conversion
<i>230</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>231</i>&nbsp; *
<i>232</i>&nbsp; * &lt;p&gt; The optional &lt;i&gt;flags&lt;/i&gt; and &lt;i&gt;width&lt;/i&gt; is defined as above.
<i>233</i>&nbsp; *
<i>234</i>&nbsp; * &lt;p&gt; The required &lt;i&gt;conversion&lt;/i&gt; is a character indicating content to be
<i>235</i>&nbsp; * inserted in the output.
<i>236</i>&nbsp; *
<i>237</i>&nbsp; * &lt;/ul&gt;
<i>238</i>&nbsp; *
<i>239</i>&nbsp; * &lt;h4&gt; Conversions &lt;/h4&gt;
<i>240</i>&nbsp; *
<i>241</i>&nbsp; * &lt;p&gt; Conversions are divided into the following categories:
<i>242</i>&nbsp; *
<i>243</i>&nbsp; * &lt;ol&gt;
<i>244</i>&nbsp; *
<i>245</i>&nbsp; * &lt;li&gt; &lt;b&gt;General&lt;/b&gt; - may be applied to any argument
<i>246</i>&nbsp; * type
<i>247</i>&nbsp; *
<i>248</i>&nbsp; * &lt;li&gt; &lt;b&gt;Character&lt;/b&gt; - may be applied to basic types which represent
<i>249</i>&nbsp; * Unicode characters: {@code char}, {@link Character}, {@code byte}, {@link
<i>250</i>&nbsp; * Byte}, {@code short}, and {@link Short}. This conversion may also be
<i>251</i>&nbsp; * applied to the types {@code int} and {@link Integer} when {@link
<i>252</i>&nbsp; * Character#isValidCodePoint} returns {@code true}
<i>253</i>&nbsp; *
<i>254</i>&nbsp; * &lt;li&gt; &lt;b&gt;Numeric&lt;/b&gt;
<i>255</i>&nbsp; *
<i>256</i>&nbsp; * &lt;ol&gt;
<i>257</i>&nbsp; *
<i>258</i>&nbsp; * &lt;li&gt; &lt;b&gt;Integral&lt;/b&gt; - may be applied to Java integral types: {@code byte},
<i>259</i>&nbsp; * {@link Byte}, {@code short}, {@link Short}, {@code int} and {@link
<i>260</i>&nbsp; * Integer}, {@code long}, {@link Long}, and {@link java.math.BigInteger
<i>261</i>&nbsp; * BigInteger} (but not {@code char} or {@link Character})
<i>262</i>&nbsp; *
<i>263</i>&nbsp; * &lt;li&gt;&lt;b&gt;Floating Point&lt;/b&gt; - may be applied to Java floating-point types:
<i>264</i>&nbsp; * {@code float}, {@link Float}, {@code double}, {@link Double}, and {@link
<i>265</i>&nbsp; * java.math.BigDecimal BigDecimal}
<i>266</i>&nbsp; *
<i>267</i>&nbsp; * &lt;/ol&gt;
<i>268</i>&nbsp; *
<i>269</i>&nbsp; * &lt;li&gt; &lt;b&gt;Date/Time&lt;/b&gt; - may be applied to Java types which are capable of
<i>270</i>&nbsp; * encoding a date or time: {@code long}, {@link Long}, {@link Calendar},
<i>271</i>&nbsp; * {@link Date} and {@link TemporalAccessor TemporalAccessor}
<i>272</i>&nbsp; *
<i>273</i>&nbsp; * &lt;li&gt; &lt;b&gt;Percent&lt;/b&gt; - produces a literal {@code &#39;%&#39;}
<i>274</i>&nbsp; * (&lt;code&gt;&#39;&amp;#92;u0025&#39;&lt;/code&gt;)
<i>275</i>&nbsp; *
<i>276</i>&nbsp; * &lt;li&gt; &lt;b&gt;Line Separator&lt;/b&gt; - produces the platform-specific line separator
<i>277</i>&nbsp; *
<i>278</i>&nbsp; * &lt;/ol&gt;
<i>279</i>&nbsp; *
<i>280</i>&nbsp; * &lt;p&gt; For category &lt;i&gt;General&lt;/i&gt;, &lt;i&gt;Character&lt;/i&gt;, &lt;i&gt;Numberic&lt;/i&gt;,
<i>281</i>&nbsp; * &lt;i&gt;Integral&lt;/i&gt; and &lt;i&gt;Date/Time&lt;/i&gt; conversion, unless otherwise specified,
<i>282</i>&nbsp; * if the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is &quot;{@code null}&quot;.
<i>283</i>&nbsp; *
<i>284</i>&nbsp; * &lt;p&gt; The following table summarizes the supported conversions.  Conversions
<i>285</i>&nbsp; * denoted by an upper-case character (i.e. {@code &#39;B&#39;}, {@code &#39;H&#39;},
<i>286</i>&nbsp; * {@code &#39;S&#39;}, {@code &#39;C&#39;}, {@code &#39;X&#39;}, {@code &#39;E&#39;}, {@code &#39;G&#39;},
<i>287</i>&nbsp; * {@code &#39;A&#39;}, and {@code &#39;T&#39;}) are the same as those for the corresponding
<i>288</i>&nbsp; * lower-case conversion characters except that the result is converted to
<i>289</i>&nbsp; * upper case according to the rules of the prevailing {@link java.util.Locale
<i>290</i>&nbsp; * Locale}. If there is no explicit locale specified, either at the
<i>291</i>&nbsp; * construction of the instance or as a parameter to its method
<i>292</i>&nbsp; * invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
<i>293</i>&nbsp; * is used.
<i>294</i>&nbsp; *
<i>295</i>&nbsp; *
<i>296</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>297</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;genConv&lt;/caption&gt;
<i>298</i>&nbsp; * &lt;thead&gt;
<i>299</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Conversion
<i>300</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Argument Category
<i>301</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Description
<i>302</i>&nbsp; * &lt;/thead&gt;
<i>303</i>&nbsp; * &lt;tbody&gt;
<i>304</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;b&#39;}, {@code &#39;B&#39;}
<i>305</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; general
<i>306</i>&nbsp; *     &lt;td&gt; If the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is
<i>307</i>&nbsp; *     &quot;{@code false}&quot;.  If &lt;i&gt;arg&lt;/i&gt; is a {@code boolean} or {@link
<i>308</i>&nbsp; *     Boolean}, then the result is the string returned by {@link
<i>309</i>&nbsp; *     String#valueOf(boolean) String.valueOf(arg)}.  Otherwise, the result is
<i>310</i>&nbsp; *     &quot;true&quot;.
<i>311</i>&nbsp; *
<i>312</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;h&#39;}, {@code &#39;H&#39;}
<i>313</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; general
<i>314</i>&nbsp; *     &lt;td&gt; The result is obtained by invoking
<i>315</i>&nbsp; *     {@code Integer.toHexString(arg.hashCode())}.
<i>316</i>&nbsp; *
<i>317</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;s&#39;}, {@code &#39;S&#39;}
<i>318</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; general
<i>319</i>&nbsp; *     &lt;td&gt; If &lt;i&gt;arg&lt;/i&gt; implements {@link Formattable}, then
<i>320</i>&nbsp; *     {@link Formattable#formatTo arg.formatTo} is invoked. Otherwise, the
<i>321</i>&nbsp; *     result is obtained by invoking {@code arg.toString()}.
<i>322</i>&nbsp; *
<i>323</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;c&#39;}, {@code &#39;C&#39;}
<i>324</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; character
<i>325</i>&nbsp; *     &lt;td&gt; The result is a Unicode character
<i>326</i>&nbsp; *
<i>327</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;d&#39;}
<i>328</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; integral
<i>329</i>&nbsp; *     &lt;td&gt; The result is formatted as a decimal integer
<i>330</i>&nbsp; *
<i>331</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;o&#39;}
<i>332</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; integral
<i>333</i>&nbsp; *     &lt;td&gt; The result is formatted as an octal integer
<i>334</i>&nbsp; *
<i>335</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;x&#39;}, {@code &#39;X&#39;}
<i>336</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; integral
<i>337</i>&nbsp; *     &lt;td&gt; The result is formatted as a hexadecimal integer
<i>338</i>&nbsp; *
<i>339</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;e&#39;}, {@code &#39;E&#39;}
<i>340</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; floating point
<i>341</i>&nbsp; *     &lt;td&gt; The result is formatted as a decimal number in computerized
<i>342</i>&nbsp; *     scientific notation
<i>343</i>&nbsp; *
<i>344</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;f&#39;}
<i>345</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; floating point
<i>346</i>&nbsp; *     &lt;td&gt; The result is formatted as a decimal number
<i>347</i>&nbsp; *
<i>348</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;g&#39;}, {@code &#39;G&#39;}
<i>349</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; floating point
<i>350</i>&nbsp; *     &lt;td&gt; The result is formatted using computerized scientific notation or
<i>351</i>&nbsp; *     decimal format, depending on the precision and the value after rounding.
<i>352</i>&nbsp; *
<i>353</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;a&#39;}, {@code &#39;A&#39;}
<i>354</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; floating point
<i>355</i>&nbsp; *     &lt;td&gt; The result is formatted as a hexadecimal floating-point number with
<i>356</i>&nbsp; *     a significand and an exponent. This conversion is &lt;b&gt;not&lt;/b&gt; supported
<i>357</i>&nbsp; *     for the {@code BigDecimal} type despite the latter&#39;s being in the
<i>358</i>&nbsp; *     &lt;i&gt;floating point&lt;/i&gt; argument category.
<i>359</i>&nbsp; *
<i>360</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;t&#39;}, {@code &#39;T&#39;}
<i>361</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; date/time
<i>362</i>&nbsp; *     &lt;td&gt; Prefix for date and time conversion characters.  See &lt;a
<i>363</i>&nbsp; *     href=&quot;#dt&quot;&gt;Date/Time Conversions&lt;/a&gt;.
<i>364</i>&nbsp; *
<i>365</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;%&#39;}
<i>366</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; percent
<i>367</i>&nbsp; *     &lt;td&gt; The result is a literal {@code &#39;%&#39;} (&lt;code&gt;&#39;&amp;#92;u0025&#39;&lt;/code&gt;)
<i>368</i>&nbsp; *
<i>369</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;n&#39;}
<i>370</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; line separator
<i>371</i>&nbsp; *     &lt;td&gt; The result is the platform-specific line separator
<i>372</i>&nbsp; *
<i>373</i>&nbsp; * &lt;/tbody&gt;
<i>374</i>&nbsp; * &lt;/table&gt;
<i>375</i>&nbsp; *
<i>376</i>&nbsp; * &lt;p&gt; Any characters not explicitly defined as conversions are illegal and are
<i>377</i>&nbsp; * reserved for future extensions.
<i>378</i>&nbsp; *
<i>379</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dt&quot;&gt;Date/Time Conversions&lt;/a&gt;&lt;/h4&gt;
<i>380</i>&nbsp; *
<i>381</i>&nbsp; * &lt;p&gt; The following date and time conversion suffix characters are defined for
<i>382</i>&nbsp; * the {@code &#39;t&#39;} and {@code &#39;T&#39;} conversions.  The types are similar to but
<i>383</i>&nbsp; * not completely identical to those defined by GNU {@code date} and POSIX
<i>384</i>&nbsp; * {@code strftime(3c)}.  Additional conversion types are provided to access
<i>385</i>&nbsp; * Java-specific functionality (e.g. {@code &#39;L&#39;} for milliseconds within the
<i>386</i>&nbsp; * second).
<i>387</i>&nbsp; *
<i>388</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting times:
<i>389</i>&nbsp; *
<i>390</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>391</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;time&lt;/caption&gt;
<i>392</i>&nbsp; * &lt;tbody&gt;
<i>393</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;H&#39;}
<i>394</i>&nbsp; *     &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
<i>395</i>&nbsp; *     a leading zero as necessary i.e. {@code 00 - 23}.
<i>396</i>&nbsp; *
<i>397</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;I&#39;}
<i>398</i>&nbsp; *     &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
<i>399</i>&nbsp; *     zero as necessary, i.e.  {@code 01 - 12}.
<i>400</i>&nbsp; *
<i>401</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;k&#39;}
<i>402</i>&nbsp; *     &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
<i>403</i>&nbsp; *
<i>404</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;l&#39;}
<i>405</i>&nbsp; *     &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.
<i>406</i>&nbsp; *
<i>407</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;M&#39;}
<i>408</i>&nbsp; *     &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
<i>409</i>&nbsp; *     as necessary, i.e.  {@code 00 - 59}.
<i>410</i>&nbsp; *
<i>411</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;S&#39;}
<i>412</i>&nbsp; *     &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
<i>413</i>&nbsp; *     zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
<i>414</i>&nbsp; *     value required to support leap seconds).
<i>415</i>&nbsp; *
<i>416</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;L&#39;}
<i>417</i>&nbsp; *     &lt;td&gt; Millisecond within the second formatted as three digits with
<i>418</i>&nbsp; *     leading zeros as necessary, i.e. {@code 000 - 999}.
<i>419</i>&nbsp; *
<i>420</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;N&#39;}
<i>421</i>&nbsp; *     &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
<i>422</i>&nbsp; *     zeros as necessary, i.e. {@code 000000000 - 999999999}.
<i>423</i>&nbsp; *
<i>424</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;p&#39;}
<i>425</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain
<i>426</i>&nbsp; *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
<i>427</i>&nbsp; *     in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;. Use of the conversion
<i>428</i>&nbsp; *     prefix {@code &#39;T&#39;} forces this output to upper case.
<i>429</i>&nbsp; *
<i>430</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;z&#39;}
<i>431</i>&nbsp; *     &lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
<i>432</i>&nbsp; *     style numeric time zone offset from GMT, e.g. {@code -0800}.  This
<i>433</i>&nbsp; *     value will be adjusted as necessary for Daylight Saving Time.  For
<i>434</i>&nbsp; *     {@code long}, {@link Long}, and {@link Date} the time zone used is
<i>435</i>&nbsp; *     the {@linkplain TimeZone#getDefault() default time zone} for this
<i>436</i>&nbsp; *     instance of the Java virtual machine.
<i>437</i>&nbsp; *
<i>438</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Z&#39;}
<i>439</i>&nbsp; *     &lt;td&gt; A string representing the abbreviation for the time zone.  This
<i>440</i>&nbsp; *     value will be adjusted as necessary for Daylight Saving Time.  For
<i>441</i>&nbsp; *     {@code long}, {@link Long}, and {@link Date} the  time zone used is
<i>442</i>&nbsp; *     the {@linkplain TimeZone#getDefault() default time zone} for this
<i>443</i>&nbsp; *     instance of the Java virtual machine.  The Formatter&#39;s locale will
<i>444</i>&nbsp; *     supersede the locale of the argument (if any).
<i>445</i>&nbsp; *
<i>446</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;s&#39;}
<i>447</i>&nbsp; *     &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
<i>448</i>&nbsp; *     {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
<i>449</i>&nbsp; *     {@code Long.MAX_VALUE/1000}.
<i>450</i>&nbsp; *
<i>451</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Q&#39;}
<i>452</i>&nbsp; *     &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
<i>453</i>&nbsp; *     1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
<i>454</i>&nbsp; *     {@code Long.MAX_VALUE}.
<i>455</i>&nbsp; *
<i>456</i>&nbsp; * &lt;/tbody&gt;
<i>457</i>&nbsp; * &lt;/table&gt;
<i>458</i>&nbsp; *
<i>459</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting dates:
<i>460</i>&nbsp; *
<i>461</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>462</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;date&lt;/caption&gt;
<i>463</i>&nbsp; * &lt;tbody&gt;
<i>464</i>&nbsp; *
<i>465</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;B&#39;}
<i>466</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
<i>467</i>&nbsp; *     full month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
<i>468</i>&nbsp; *
<i>469</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;b&#39;}
<i>470</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain
<i>471</i>&nbsp; *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
<i>472</i>&nbsp; *     e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
<i>473</i>&nbsp; *
<i>474</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;h&#39;}
<i>475</i>&nbsp; *     &lt;td&gt; Same as {@code &#39;b&#39;}.
<i>476</i>&nbsp; *
<i>477</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;A&#39;}
<i>478</i>&nbsp; *     &lt;td&gt; Locale-specific full name of the {@linkplain
<i>479</i>&nbsp; *     java.text.DateFormatSymbols#getWeekdays day of the week},
<i>480</i>&nbsp; *     e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}
<i>481</i>&nbsp; *
<i>482</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;a&#39;}
<i>483</i>&nbsp; *     &lt;td&gt; Locale-specific short name of the {@linkplain
<i>484</i>&nbsp; *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
<i>485</i>&nbsp; *     e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}
<i>486</i>&nbsp; *
<i>487</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;C&#39;}
<i>488</i>&nbsp; *     &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
<i>489</i>&nbsp; *     with leading zero as necessary, i.e. {@code 00 - 99}
<i>490</i>&nbsp; *
<i>491</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Y&#39;}
<i>492</i>&nbsp; *     &lt;td&gt; Year, formatted as at least four digits with leading zeros as
<i>493</i>&nbsp; *     necessary, e.g. {@code 0092} equals {@code 92} CE for the Gregorian
<i>494</i>&nbsp; *     calendar.
<i>495</i>&nbsp; *
<i>496</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;y&#39;}
<i>497</i>&nbsp; *     &lt;td&gt; Last two digits of the year, formatted with leading zeros as
<i>498</i>&nbsp; *     necessary, i.e. {@code 00 - 99}.
<i>499</i>&nbsp; *
<i>500</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;j&#39;}
<i>501</i>&nbsp; *     &lt;td&gt; Day of year, formatted as three digits with leading zeros as
<i>502</i>&nbsp; *     necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
<i>503</i>&nbsp; *
<i>504</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;m&#39;}
<i>505</i>&nbsp; *     &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
<i>506</i>&nbsp; *     i.e. {@code 01 - 13}.
<i>507</i>&nbsp; *
<i>508</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;d&#39;}
<i>509</i>&nbsp; *     &lt;td&gt; Day of month, formatted as two digits with leading zeros as
<i>510</i>&nbsp; *     necessary, i.e. {@code 01 - 31}
<i>511</i>&nbsp; *
<i>512</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;e&#39;}
<i>513</i>&nbsp; *     &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31}.
<i>514</i>&nbsp; *
<i>515</i>&nbsp; * &lt;/tbody&gt;
<i>516</i>&nbsp; * &lt;/table&gt;
<i>517</i>&nbsp; *
<i>518</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting common
<i>519</i>&nbsp; * date/time compositions.
<i>520</i>&nbsp; *
<i>521</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>522</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;composites&lt;/caption&gt;
<i>523</i>&nbsp; * &lt;tbody&gt;
<i>524</i>&nbsp; *
<i>525</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;R&#39;}
<i>526</i>&nbsp; *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}
<i>527</i>&nbsp; *
<i>528</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;T&#39;}
<i>529</i>&nbsp; *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
<i>530</i>&nbsp; *
<i>531</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;r&#39;}
<i>532</i>&nbsp; *     &lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS %Tp&quot;}.
<i>533</i>&nbsp; *     The location of the morning or afternoon marker ({@code &#39;%Tp&#39;}) may be
<i>534</i>&nbsp; *     locale-dependent.
<i>535</i>&nbsp; *
<i>536</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;D&#39;}
<i>537</i>&nbsp; *     &lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
<i>538</i>&nbsp; *
<i>539</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;F&#39;}
<i>540</i>&nbsp; *     &lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
<i>541</i>&nbsp; *     complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
<i>542</i>&nbsp; *
<i>543</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;c&#39;}
<i>544</i>&nbsp; *     &lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
<i>545</i>&nbsp; *     e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
<i>546</i>&nbsp; *
<i>547</i>&nbsp; * &lt;/tbody&gt;
<i>548</i>&nbsp; * &lt;/table&gt;
<i>549</i>&nbsp; *
<i>550</i>&nbsp; * &lt;p&gt; Any characters not explicitly defined as date/time conversion suffixes
<i>551</i>&nbsp; * are illegal and are reserved for future extensions.
<i>552</i>&nbsp; *
<i>553</i>&nbsp; * &lt;h4&gt; Flags &lt;/h4&gt;
<i>554</i>&nbsp; *
<i>555</i>&nbsp; * &lt;p&gt; The following table summarizes the supported flags.  &lt;i&gt;y&lt;/i&gt; means the
<i>556</i>&nbsp; * flag is supported for the indicated argument types.
<i>557</i>&nbsp; *
<i>558</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>559</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;genConv&lt;/caption&gt;
<i>560</i>&nbsp; * &lt;thead&gt;
<i>561</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Flag &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; General
<i>562</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Character &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Integral
<i>563</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Floating Point
<i>564</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Date/Time
<i>565</i>&nbsp; *     &lt;th scope=&quot;col&quot; style=&quot;vertical-align:bottom&quot;&gt; Description
<i>566</i>&nbsp; * &lt;/thead&gt;
<i>567</i>&nbsp; * &lt;tbody&gt;
<i>568</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;-&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>569</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>570</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>571</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>572</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>573</i>&nbsp; *     &lt;td&gt; The result will be left-justified.
<i>574</i>&nbsp; *
<i>575</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;#&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;1&lt;/sup&gt;
<i>576</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>577</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;3&lt;/sup&gt;
<i>578</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>579</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>580</i>&nbsp; *     &lt;td&gt; The result should use a conversion-dependent alternate form
<i>581</i>&nbsp; *
<i>582</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;+&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>583</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>584</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
<i>585</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>586</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>587</i>&nbsp; *     &lt;td&gt; The result will always include a sign
<i>588</i>&nbsp; *
<i>589</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;&amp;nbsp;&amp;nbsp;&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>590</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>591</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
<i>592</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>593</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>594</i>&nbsp; *     &lt;td&gt; The result will include a leading space for positive values
<i>595</i>&nbsp; *
<i>596</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;0&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>597</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>598</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>599</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y
<i>600</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>601</i>&nbsp; *     &lt;td&gt; The result will be zero-padded
<i>602</i>&nbsp; *
<i>603</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;,&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>604</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>605</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;2&lt;/sup&gt;
<i>606</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
<i>607</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>608</i>&nbsp; *     &lt;td&gt; The result will include locale-specific {@linkplain
<i>609</i>&nbsp; *     java.text.DecimalFormatSymbols#getGroupingSeparator grouping separators}
<i>610</i>&nbsp; *
<i>611</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; &#39;(&#39; &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>612</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; -
<i>613</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;4&lt;/sup&gt;
<i>614</i>&nbsp; *     &lt;td style=&quot;text-align:center; vertical-align:top&quot;&gt; y&lt;sup&gt;5&lt;/sup&gt;
<i>615</i>&nbsp; *     &lt;td style=&quot;text-align:center&quot;&gt; -
<i>616</i>&nbsp; *     &lt;td&gt; The result will enclose negative numbers in parentheses
<i>617</i>&nbsp; *
<i>618</i>&nbsp; * &lt;/tbody&gt;
<i>619</i>&nbsp; * &lt;/table&gt;
<i>620</i>&nbsp; *
<i>621</i>&nbsp; * &lt;p&gt; &lt;sup&gt;1&lt;/sup&gt; Depends on the definition of {@link Formattable}.
<i>622</i>&nbsp; *
<i>623</i>&nbsp; * &lt;p&gt; &lt;sup&gt;2&lt;/sup&gt; For {@code &#39;d&#39;} conversion only.
<i>624</i>&nbsp; *
<i>625</i>&nbsp; * &lt;p&gt; &lt;sup&gt;3&lt;/sup&gt; For {@code &#39;o&#39;}, {@code &#39;x&#39;}, and {@code &#39;X&#39;}
<i>626</i>&nbsp; * conversions only.
<i>627</i>&nbsp; *
<i>628</i>&nbsp; * &lt;p&gt; &lt;sup&gt;4&lt;/sup&gt; For {@code &#39;d&#39;}, {@code &#39;o&#39;}, {@code &#39;x&#39;}, and
<i>629</i>&nbsp; * {@code &#39;X&#39;} conversions applied to {@link java.math.BigInteger BigInteger}
<i>630</i>&nbsp; * or {@code &#39;d&#39;} applied to {@code byte}, {@link Byte}, {@code short}, {@link
<i>631</i>&nbsp; * Short}, {@code int} and {@link Integer}, {@code long}, and {@link Long}.
<i>632</i>&nbsp; *
<i>633</i>&nbsp; * &lt;p&gt; &lt;sup&gt;5&lt;/sup&gt; For {@code &#39;e&#39;}, {@code &#39;E&#39;}, {@code &#39;f&#39;},
<i>634</i>&nbsp; * {@code &#39;g&#39;}, and {@code &#39;G&#39;} conversions only.
<i>635</i>&nbsp; *
<i>636</i>&nbsp; * &lt;p&gt; Any characters not explicitly defined as flags are illegal and are
<i>637</i>&nbsp; * reserved for future extensions.
<i>638</i>&nbsp; *
<i>639</i>&nbsp; * &lt;h4&gt; Width &lt;/h4&gt;
<i>640</i>&nbsp; *
<i>641</i>&nbsp; * &lt;p&gt; The width is the minimum number of characters to be written to the
<i>642</i>&nbsp; * output.  For the line separator conversion, width is not applicable; if it
<i>643</i>&nbsp; * is provided, an exception will be thrown.
<i>644</i>&nbsp; *
<i>645</i>&nbsp; * &lt;h4&gt; Precision &lt;/h4&gt;
<i>646</i>&nbsp; *
<i>647</i>&nbsp; * &lt;p&gt; For general argument types, the precision is the maximum number of
<i>648</i>&nbsp; * characters to be written to the output.
<i>649</i>&nbsp; *
<i>650</i>&nbsp; * &lt;p&gt; For the floating-point conversions {@code &#39;a&#39;}, {@code &#39;A&#39;}, {@code &#39;e&#39;},
<i>651</i>&nbsp; * {@code &#39;E&#39;}, and {@code &#39;f&#39;} the precision is the number of digits after the
<i>652</i>&nbsp; * radix point.  If the conversion is {@code &#39;g&#39;} or {@code &#39;G&#39;}, then the
<i>653</i>&nbsp; * precision is the total number of digits in the resulting magnitude after
<i>654</i>&nbsp; * rounding.
<i>655</i>&nbsp; *
<i>656</i>&nbsp; * &lt;p&gt; For character, integral, and date/time argument types and the percent
<i>657</i>&nbsp; * and line separator conversions, the precision is not applicable; if a
<i>658</i>&nbsp; * precision is provided, an exception will be thrown.
<i>659</i>&nbsp; *
<i>660</i>&nbsp; * &lt;h4&gt; Argument Index &lt;/h4&gt;
<i>661</i>&nbsp; *
<i>662</i>&nbsp; * &lt;p&gt; The argument index is a decimal integer indicating the position of the
<i>663</i>&nbsp; * argument in the argument list.  The first argument is referenced by
<i>664</i>&nbsp; * &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.
<i>665</i>&nbsp; *
<i>666</i>&nbsp; * &lt;p&gt; Another way to reference arguments by position is to use the
<i>667</i>&nbsp; * {@code &#39;&lt;&#39;} (&lt;code&gt;&#39;&amp;#92;u003c&#39;&lt;/code&gt;) flag, which causes the argument for
<i>668</i>&nbsp; * the previous format specifier to be re-used.  For example, the following two
<i>669</i>&nbsp; * statements would produce identical strings:
<i>670</i>&nbsp; *
<i>671</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>672</i>&nbsp; *   Calendar c = ...;
<i>673</i>&nbsp; *   String s1 = String.format(&quot;Duke&#39;s Birthday: %1$tm %1$te,%1$tY&quot;, c);
<i>674</i>&nbsp; *
<i>675</i>&nbsp; *   String s2 = String.format(&quot;Duke&#39;s Birthday: %1$tm %&amp;lt;te,%&amp;lt;tY&quot;, c);
<i>676</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>677</i>&nbsp; *
<i>678</i>&nbsp; * &lt;hr&gt;
<i>679</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;detail&quot;&gt;Details&lt;/a&gt;&lt;/h3&gt;
<i>680</i>&nbsp; *
<i>681</i>&nbsp; * &lt;p&gt; This section is intended to provide behavioral details for formatting,
<i>682</i>&nbsp; * including conditions and exceptions, supported data types, localization, and
<i>683</i>&nbsp; * interactions between flags, conversions, and data types.  For an overview of
<i>684</i>&nbsp; * formatting concepts, refer to the &lt;a href=&quot;#summary&quot;&gt;Summary&lt;/a&gt;
<i>685</i>&nbsp; *
<i>686</i>&nbsp; * &lt;p&gt; Any characters not explicitly defined as conversions, date/time
<i>687</i>&nbsp; * conversion suffixes, or flags are illegal and are reserved for
<i>688</i>&nbsp; * future extensions.  Use of such a character in a format string will
<i>689</i>&nbsp; * cause an {@link UnknownFormatConversionException} or {@link
<i>690</i>&nbsp; * UnknownFormatFlagsException} to be thrown.
<i>691</i>&nbsp; *
<i>692</i>&nbsp; * &lt;p&gt; If the format specifier contains a width or precision with an invalid
<i>693</i>&nbsp; * value or which is otherwise unsupported, then a {@link
<i>694</i>&nbsp; * IllegalFormatWidthException} or {@link IllegalFormatPrecisionException}
<i>695</i>&nbsp; * respectively will be thrown.
<i>696</i>&nbsp; *
<i>697</i>&nbsp; * &lt;p&gt; If a format specifier contains a conversion character that is not
<i>698</i>&nbsp; * applicable to the corresponding argument, then an {@link
<i>699</i>&nbsp; * IllegalFormatConversionException} will be thrown.
<i>700</i>&nbsp; *
<i>701</i>&nbsp; * &lt;p&gt; All specified exceptions may be thrown by any of the {@code format}
<i>702</i>&nbsp; * methods of {@code Formatter} as well as by any {@code format} convenience
<i>703</i>&nbsp; * methods such as {@link String#format(String,Object...) String.format} and
<i>704</i>&nbsp; * {@link java.io.PrintStream#printf(String,Object...) PrintStream.printf}.
<i>705</i>&nbsp; *
<i>706</i>&nbsp; * &lt;p&gt; For category &lt;i&gt;General&lt;/i&gt;, &lt;i&gt;Character&lt;/i&gt;, &lt;i&gt;Numberic&lt;/i&gt;,
<i>707</i>&nbsp; * &lt;i&gt;Integral&lt;/i&gt; and &lt;i&gt;Date/Time&lt;/i&gt; conversion, unless otherwise specified,
<i>708</i>&nbsp; * if the argument &lt;i&gt;arg&lt;/i&gt; is {@code null}, then the result is &quot;{@code null}&quot;.
<i>709</i>&nbsp; *
<i>710</i>&nbsp; * &lt;p&gt; Conversions denoted by an upper-case character (i.e. {@code &#39;B&#39;},
<i>711</i>&nbsp; * {@code &#39;H&#39;}, {@code &#39;S&#39;}, {@code &#39;C&#39;}, {@code &#39;X&#39;}, {@code &#39;E&#39;},
<i>712</i>&nbsp; * {@code &#39;G&#39;}, {@code &#39;A&#39;}, and {@code &#39;T&#39;}) are the same as those for the
<i>713</i>&nbsp; * corresponding lower-case conversion characters except that the result is
<i>714</i>&nbsp; * converted to upper case according to the rules of the prevailing {@link
<i>715</i>&nbsp; * java.util.Locale Locale}. If there is no explicit locale specified,
<i>716</i>&nbsp; * either at the construction of the instance or as a parameter to its method
<i>717</i>&nbsp; * invocation, then the {@link java.util.Locale.Category#FORMAT default locale}
<i>718</i>&nbsp; * is used.
<i>719</i>&nbsp; *
<i>720</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dgen&quot;&gt;General&lt;/a&gt;&lt;/h4&gt;
<i>721</i>&nbsp; *
<i>722</i>&nbsp; * &lt;p&gt; The following general conversions may be applied to any argument type:
<i>723</i>&nbsp; *
<i>724</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>725</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;dgConv&lt;/caption&gt;
<i>726</i>&nbsp; * &lt;tbody&gt;
<i>727</i>&nbsp; *
<i>728</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;b&#39;}
<i>729</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0062&#39;&lt;/code&gt;
<i>730</i>&nbsp; *     &lt;td&gt; Produces either &quot;{@code true}&quot; or &quot;{@code false}&quot; as returned by
<i>731</i>&nbsp; *     {@link Boolean#toString(boolean)}.
<i>732</i>&nbsp; *
<i>733</i>&nbsp; *     &lt;p&gt; If the argument is {@code null}, then the result is
<i>734</i>&nbsp; *     &quot;{@code false}&quot;.  If the argument is a {@code boolean} or {@link
<i>735</i>&nbsp; *     Boolean}, then the result is the string returned by {@link
<i>736</i>&nbsp; *     String#valueOf(boolean) String.valueOf()}.  Otherwise, the result is
<i>737</i>&nbsp; *     &quot;{@code true}&quot;.
<i>738</i>&nbsp; *
<i>739</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given, then a {@link
<i>740</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>741</i>&nbsp; *
<i>742</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;B&#39;}
<i>743</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0042&#39;&lt;/code&gt;
<i>744</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;b&#39;}.
<i>745</i>&nbsp; *
<i>746</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;h&#39;}
<i>747</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0068&#39;&lt;/code&gt;
<i>748</i>&nbsp; *     &lt;td&gt; Produces a string representing the hash code value of the object.
<i>749</i>&nbsp; *
<i>750</i>&nbsp; *     &lt;p&gt; The result is obtained by invoking
<i>751</i>&nbsp; *     {@code Integer.toHexString(arg.hashCode())}.
<i>752</i>&nbsp; *
<i>753</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given, then a {@link
<i>754</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>755</i>&nbsp; *
<i>756</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;H&#39;}
<i>757</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0048&#39;&lt;/code&gt;
<i>758</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;h&#39;}.
<i>759</i>&nbsp; *
<i>760</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;s&#39;}
<i>761</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0073&#39;&lt;/code&gt;
<i>762</i>&nbsp; *     &lt;td&gt; Produces a string.
<i>763</i>&nbsp; *
<i>764</i>&nbsp; *     &lt;p&gt; If the argument implements {@link Formattable}, then
<i>765</i>&nbsp; *     its {@link Formattable#formatTo formatTo} method is invoked.
<i>766</i>&nbsp; *     Otherwise, the result is obtained by invoking the argument&#39;s
<i>767</i>&nbsp; *     {@code toString()} method.
<i>768</i>&nbsp; *
<i>769</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given and the argument is not a {@link
<i>770</i>&nbsp; *     Formattable} , then a {@link FormatFlagsConversionMismatchException}
<i>771</i>&nbsp; *     will be thrown.
<i>772</i>&nbsp; *
<i>773</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;S&#39;}
<i>774</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0053&#39;&lt;/code&gt;
<i>775</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;s&#39;}.
<i>776</i>&nbsp; *
<i>777</i>&nbsp; * &lt;/tbody&gt;
<i>778</i>&nbsp; * &lt;/table&gt;
<i>779</i>&nbsp; *
<i>780</i>&nbsp; * &lt;p&gt; The following &lt;a id=&quot;dFlags&quot;&gt;flags&lt;/a&gt; apply to general conversions:
<i>781</i>&nbsp; *
<i>782</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>783</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;dFlags&lt;/caption&gt;
<i>784</i>&nbsp; * &lt;tbody&gt;
<i>785</i>&nbsp; *
<i>786</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;-&#39;}
<i>787</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;
<i>788</i>&nbsp; *     &lt;td&gt; Left justifies the output.  Spaces (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) will be
<i>789</i>&nbsp; *     added at the end of the converted value as required to fill the minimum
<i>790</i>&nbsp; *     width of the field.  If the width is not provided, then a {@link
<i>791</i>&nbsp; *     MissingFormatWidthException} will be thrown.  If this flag is not given
<i>792</i>&nbsp; *     then the output will be right-justified.
<i>793</i>&nbsp; *
<i>794</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;#&#39;}
<i>795</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0023&#39;&lt;/code&gt;
<i>796</i>&nbsp; *     &lt;td&gt; Requires the output use an alternate form.  The definition of the
<i>797</i>&nbsp; *     form is specified by the conversion.
<i>798</i>&nbsp; *
<i>799</i>&nbsp; * &lt;/tbody&gt;
<i>800</i>&nbsp; * &lt;/table&gt;
<i>801</i>&nbsp; *
<i>802</i>&nbsp; * &lt;p&gt; The &lt;a id=&quot;genWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
<i>803</i>&nbsp; * be written to the
<i>804</i>&nbsp; * output.  If the length of the converted value is less than the width then
<i>805</i>&nbsp; * the output will be padded by &lt;code&gt;&#39;&amp;nbsp;&amp;nbsp;&#39;&lt;/code&gt; (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;)
<i>806</i>&nbsp; * until the total number of characters equals the width.  The padding is on
<i>807</i>&nbsp; * the left by default.  If the {@code &#39;-&#39;} flag is given, then the padding
<i>808</i>&nbsp; * will be on the right.  If the width is not specified then there is no
<i>809</i>&nbsp; * minimum.
<i>810</i>&nbsp; *
<i>811</i>&nbsp; * &lt;p&gt; The precision is the maximum number of characters to be written to the
<i>812</i>&nbsp; * output.  The precision is applied before the width, thus the output will be
<i>813</i>&nbsp; * truncated to {@code precision} characters even if the width is greater than
<i>814</i>&nbsp; * the precision.  If the precision is not specified then there is no explicit
<i>815</i>&nbsp; * limit on the number of characters.
<i>816</i>&nbsp; *
<i>817</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dchar&quot;&gt;Character&lt;/a&gt;&lt;/h4&gt;
<i>818</i>&nbsp; *
<i>819</i>&nbsp; * This conversion may be applied to {@code char} and {@link Character}.  It
<i>820</i>&nbsp; * may also be applied to the types {@code byte}, {@link Byte},
<i>821</i>&nbsp; * {@code short}, and {@link Short}, {@code int} and {@link Integer} when
<i>822</i>&nbsp; * {@link Character#isValidCodePoint} returns {@code true}.  If it returns
<i>823</i>&nbsp; * {@code false} then an {@link IllegalFormatCodePointException} will be
<i>824</i>&nbsp; * thrown.
<i>825</i>&nbsp; *
<i>826</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>827</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;charConv&lt;/caption&gt;
<i>828</i>&nbsp; * &lt;tbody&gt;
<i>829</i>&nbsp; *
<i>830</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;c&#39;}
<i>831</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0063&#39;&lt;/code&gt;
<i>832</i>&nbsp; *     &lt;td&gt; Formats the argument as a Unicode character as described in &lt;a
<i>833</i>&nbsp; *     href=&quot;../lang/Character.html#unicode&quot;&gt;Unicode Character
<i>834</i>&nbsp; *     Representation&lt;/a&gt;.  This may be more than one 16-bit {@code char} in
<i>835</i>&nbsp; *     the case where the argument represents a supplementary character.
<i>836</i>&nbsp; *
<i>837</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given, then a {@link
<i>838</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>839</i>&nbsp; *
<i>840</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;C&#39;}
<i>841</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0043&#39;&lt;/code&gt;
<i>842</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;c&#39;}.
<i>843</i>&nbsp; *
<i>844</i>&nbsp; * &lt;/tbody&gt;
<i>845</i>&nbsp; * &lt;/table&gt;
<i>846</i>&nbsp; *
<i>847</i>&nbsp; * &lt;p&gt; The {@code &#39;-&#39;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
<i>848</i>&nbsp; * conversions&lt;/a&gt; applies.  If the {@code &#39;#&#39;} flag is given, then a {@link
<i>849</i>&nbsp; * FormatFlagsConversionMismatchException} will be thrown.
<i>850</i>&nbsp; *
<i>851</i>&nbsp; * &lt;p&gt; The width is defined as for &lt;a href=&quot;#genWidth&quot;&gt;General conversions&lt;/a&gt;.
<i>852</i>&nbsp; *
<i>853</i>&nbsp; * &lt;p&gt; The precision is not applicable.  If the precision is specified then an
<i>854</i>&nbsp; * {@link IllegalFormatPrecisionException} will be thrown.
<i>855</i>&nbsp; *
<i>856</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dnum&quot;&gt;Numeric&lt;/a&gt;&lt;/h4&gt;
<i>857</i>&nbsp; *
<i>858</i>&nbsp; * &lt;p&gt; Numeric conversions are divided into the following categories:
<i>859</i>&nbsp; *
<i>860</i>&nbsp; * &lt;ol&gt;
<i>861</i>&nbsp; *
<i>862</i>&nbsp; * &lt;li&gt; &lt;a href=&quot;#dnint&quot;&gt;&lt;b&gt;Byte, Short, Integer, and Long&lt;/b&gt;&lt;/a&gt;
<i>863</i>&nbsp; *
<i>864</i>&nbsp; * &lt;li&gt; &lt;a href=&quot;#dnbint&quot;&gt;&lt;b&gt;BigInteger&lt;/b&gt;&lt;/a&gt;
<i>865</i>&nbsp; *
<i>866</i>&nbsp; * &lt;li&gt; &lt;a href=&quot;#dndec&quot;&gt;&lt;b&gt;Float and Double&lt;/b&gt;&lt;/a&gt;
<i>867</i>&nbsp; *
<i>868</i>&nbsp; * &lt;li&gt; &lt;a href=&quot;#dnbdec&quot;&gt;&lt;b&gt;BigDecimal&lt;/b&gt;&lt;/a&gt;
<i>869</i>&nbsp; *
<i>870</i>&nbsp; * &lt;/ol&gt;
<i>871</i>&nbsp; *
<i>872</i>&nbsp; * &lt;p&gt; Numeric types will be formatted according to the following algorithm:
<i>873</i>&nbsp; *
<i>874</i>&nbsp; * &lt;p&gt;&lt;b&gt;&lt;a id=&quot;L10nAlgorithm&quot;&gt; Number Localization Algorithm&lt;/a&gt;&lt;/b&gt;
<i>875</i>&nbsp; *
<i>876</i>&nbsp; * &lt;p&gt; After digits are obtained for the integer part, fractional part, and
<i>877</i>&nbsp; * exponent (as appropriate for the data type), the following transformation
<i>878</i>&nbsp; * is applied:
<i>879</i>&nbsp; *
<i>880</i>&nbsp; * &lt;ol&gt;
<i>881</i>&nbsp; *
<i>882</i>&nbsp; * &lt;li&gt; Each digit character &lt;i&gt;d&lt;/i&gt; in the string is replaced by a
<i>883</i>&nbsp; * locale-specific digit computed relative to the current locale&#39;s
<i>884</i>&nbsp; * {@linkplain java.text.DecimalFormatSymbols#getZeroDigit() zero digit}
<i>885</i>&nbsp; * &lt;i&gt;z&lt;/i&gt;; that is &lt;i&gt;d&amp;nbsp;-&amp;nbsp;&lt;/i&gt; {@code &#39;0&#39;}
<i>886</i>&nbsp; * &lt;i&gt;&amp;nbsp;+&amp;nbsp;z&lt;/i&gt;.
<i>887</i>&nbsp; *
<i>888</i>&nbsp; * &lt;li&gt; If a decimal separator is present, a locale-specific {@linkplain
<i>889</i>&nbsp; * java.text.DecimalFormatSymbols#getDecimalSeparator decimal separator} is
<i>890</i>&nbsp; * substituted.
<i>891</i>&nbsp; *
<i>892</i>&nbsp; * &lt;li&gt; If the {@code &#39;,&#39;} (&lt;code&gt;&#39;&amp;#92;u002c&#39;&lt;/code&gt;)
<i>893</i>&nbsp; * &lt;a id=&quot;L10nGroup&quot;&gt;flag&lt;/a&gt; is given, then the locale-specific {@linkplain
<i>894</i>&nbsp; * java.text.DecimalFormatSymbols#getGroupingSeparator grouping separator} is
<i>895</i>&nbsp; * inserted by scanning the integer part of the string from least significant
<i>896</i>&nbsp; * to most significant digits and inserting a separator at intervals defined by
<i>897</i>&nbsp; * the locale&#39;s {@linkplain java.text.DecimalFormat#getGroupingSize() grouping
<i>898</i>&nbsp; * size}.
<i>899</i>&nbsp; *
<i>900</i>&nbsp; * &lt;li&gt; If the {@code &#39;0&#39;} flag is given, then the locale-specific {@linkplain
<i>901</i>&nbsp; * java.text.DecimalFormatSymbols#getZeroDigit() zero digits} are inserted
<i>902</i>&nbsp; * after the sign character, if any, and before the first non-zero digit, until
<i>903</i>&nbsp; * the length of the string is equal to the requested field width.
<i>904</i>&nbsp; *
<i>905</i>&nbsp; * &lt;li&gt; If the value is negative and the {@code &#39;(&#39;} flag is given, then a
<i>906</i>&nbsp; * {@code &#39;(&#39;} (&lt;code&gt;&#39;&amp;#92;u0028&#39;&lt;/code&gt;) is prepended and a {@code &#39;)&#39;}
<i>907</i>&nbsp; * (&lt;code&gt;&#39;&amp;#92;u0029&#39;&lt;/code&gt;) is appended.
<i>908</i>&nbsp; *
<i>909</i>&nbsp; * &lt;li&gt; If the value is negative (or floating-point negative zero) and
<i>910</i>&nbsp; * {@code &#39;(&#39;} flag is not given, then a {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;)
<i>911</i>&nbsp; * is prepended.
<i>912</i>&nbsp; *
<i>913</i>&nbsp; * &lt;li&gt; If the {@code &#39;+&#39;} flag is given and the value is positive or zero (or
<i>914</i>&nbsp; * floating-point positive zero), then a {@code &#39;+&#39;} (&lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;)
<i>915</i>&nbsp; * will be prepended.
<i>916</i>&nbsp; *
<i>917</i>&nbsp; * &lt;/ol&gt;
<i>918</i>&nbsp; *
<i>919</i>&nbsp; * &lt;p&gt; If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or
<i>920</i>&nbsp; * &quot;Infinity&quot; respectively, will be output.  If the value is negative infinity,
<i>921</i>&nbsp; * then the output will be &quot;(Infinity)&quot; if the {@code &#39;(&#39;} flag is given
<i>922</i>&nbsp; * otherwise the output will be &quot;-Infinity&quot;.  These values are not localized.
<i>923</i>&nbsp; *
<i>924</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;dnint&quot;&gt;&lt;b&gt; Byte, Short, Integer, and Long &lt;/b&gt;&lt;/a&gt;
<i>925</i>&nbsp; *
<i>926</i>&nbsp; * &lt;p&gt; The following conversions may be applied to {@code byte}, {@link Byte},
<i>927</i>&nbsp; * {@code short}, {@link Short}, {@code int} and {@link Integer},
<i>928</i>&nbsp; * {@code long}, and {@link Long}.
<i>929</i>&nbsp; *
<i>930</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>931</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;IntConv&lt;/caption&gt;
<i>932</i>&nbsp; * &lt;tbody&gt;
<i>933</i>&nbsp; *
<i>934</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;d&#39;}
<i>935</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0064&#39;&lt;/code&gt;
<i>936</i>&nbsp; *     &lt;td&gt; Formats the argument as a decimal integer. The &lt;a
<i>937</i>&nbsp; *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
<i>938</i>&nbsp; *
<i>939</i>&nbsp; *     &lt;p&gt; If the {@code &#39;0&#39;} flag is given and the value is negative, then
<i>940</i>&nbsp; *     the zero padding will occur after the sign.
<i>941</i>&nbsp; *
<i>942</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then a {@link
<i>943</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>944</i>&nbsp; *
<i>945</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;o&#39;}
<i>946</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006f&#39;&lt;/code&gt;
<i>947</i>&nbsp; *     &lt;td&gt; Formats the argument as an integer in base eight.  No localization
<i>948</i>&nbsp; *     is applied.
<i>949</i>&nbsp; *
<i>950</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
<i>951</i>&nbsp; *     generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
<i>952</i>&nbsp; *     number of bits in the type as returned by the static {@code SIZE} field
<i>953</i>&nbsp; *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
<i>954</i>&nbsp; *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
<i>955</i>&nbsp; *     classes as appropriate.
<i>956</i>&nbsp; *
<i>957</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then the output will always begin
<i>958</i>&nbsp; *     with the radix indicator {@code &#39;0&#39;}.
<i>959</i>&nbsp; *
<i>960</i>&nbsp; *     &lt;p&gt; If the {@code &#39;0&#39;} flag is given then the output will be padded
<i>961</i>&nbsp; *     with leading zeros to the field width following any indication of sign.
<i>962</i>&nbsp; *
<i>963</i>&nbsp; *     &lt;p&gt; If {@code &#39;(&#39;}, {@code &#39;+&#39;}, &#39;&amp;nbsp;&amp;nbsp;&#39;, or {@code &#39;,&#39;} flags
<i>964</i>&nbsp; *     are given then a {@link FormatFlagsConversionMismatchException} will be
<i>965</i>&nbsp; *     thrown.
<i>966</i>&nbsp; *
<i>967</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;x&#39;}
<i>968</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0078&#39;&lt;/code&gt;
<i>969</i>&nbsp; *     &lt;td&gt; Formats the argument as an integer in base sixteen. No
<i>970</i>&nbsp; *     localization is applied.
<i>971</i>&nbsp; *
<i>972</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be an unsigned value
<i>973</i>&nbsp; *     generated by adding 2&lt;sup&gt;n&lt;/sup&gt; to the value where {@code n} is the
<i>974</i>&nbsp; *     number of bits in the type as returned by the static {@code SIZE} field
<i>975</i>&nbsp; *     in the {@linkplain Byte#SIZE Byte}, {@linkplain Short#SIZE Short},
<i>976</i>&nbsp; *     {@linkplain Integer#SIZE Integer}, or {@linkplain Long#SIZE Long}
<i>977</i>&nbsp; *     classes as appropriate.
<i>978</i>&nbsp; *
<i>979</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then the output will always begin
<i>980</i>&nbsp; *     with the radix indicator {@code &quot;0x&quot;}.
<i>981</i>&nbsp; *
<i>982</i>&nbsp; *     &lt;p&gt; If the {@code &#39;0&#39;} flag is given then the output will be padded to
<i>983</i>&nbsp; *     the field width with leading zeros after the radix indicator or sign (if
<i>984</i>&nbsp; *     present).
<i>985</i>&nbsp; *
<i>986</i>&nbsp; *     &lt;p&gt; If {@code &#39;(&#39;}, &lt;code&gt;&#39;&amp;nbsp;&amp;nbsp;&#39;&lt;/code&gt;, {@code &#39;+&#39;}, or
<i>987</i>&nbsp; *     {@code &#39;,&#39;} flags are given then a {@link
<i>988</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>989</i>&nbsp; *
<i>990</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;X&#39;}
<i>991</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0058&#39;&lt;/code&gt;
<i>992</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;x&#39;}.  The entire string
<i>993</i>&nbsp; *     representing the number will be converted to {@linkplain
<i>994</i>&nbsp; *     String#toUpperCase upper case} including the {@code &#39;x&#39;} (if any) and
<i>995</i>&nbsp; *     all hexadecimal digits {@code &#39;a&#39;} - {@code &#39;f&#39;}
<i>996</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt; -  &lt;code&gt;&#39;&amp;#92;u0066&#39;&lt;/code&gt;).
<i>997</i>&nbsp; *
<i>998</i>&nbsp; * &lt;/tbody&gt;
<i>999</i>&nbsp; * &lt;/table&gt;
<i>1000</i>&nbsp; *
<i>1001</i>&nbsp; * &lt;p&gt; If the conversion is {@code &#39;o&#39;}, {@code &#39;x&#39;}, or {@code &#39;X&#39;} and
<i>1002</i>&nbsp; * both the {@code &#39;#&#39;} and the {@code &#39;0&#39;} flags are given, then result will
<i>1003</i>&nbsp; * contain the radix indicator ({@code &#39;0&#39;} for octal and {@code &quot;0x&quot;} or
<i>1004</i>&nbsp; * {@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
<i>1005</i>&nbsp; * and the value.
<i>1006</i>&nbsp; *
<i>1007</i>&nbsp; * &lt;p&gt; If the {@code &#39;-&#39;} flag is not given, then the space padding will occur
<i>1008</i>&nbsp; * before the sign.
<i>1009</i>&nbsp; *
<i>1010</i>&nbsp; * &lt;p&gt; The following &lt;a id=&quot;intFlags&quot;&gt;flags&lt;/a&gt; apply to numeric integral
<i>1011</i>&nbsp; * conversions:
<i>1012</i>&nbsp; *
<i>1013</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1014</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;intFlags&lt;/caption&gt;
<i>1015</i>&nbsp; * &lt;tbody&gt;
<i>1016</i>&nbsp; *
<i>1017</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;+&#39;}
<i>1018</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;
<i>1019</i>&nbsp; *     &lt;td&gt; Requires the output to include a positive sign for all positive
<i>1020</i>&nbsp; *     numbers.  If this flag is not given then only negative values will
<i>1021</i>&nbsp; *     include a sign.
<i>1022</i>&nbsp; *
<i>1023</i>&nbsp; *     &lt;p&gt; If both the {@code &#39;+&#39;} and &lt;code&gt;&#39;&amp;nbsp;&amp;nbsp;&#39;&lt;/code&gt; flags are given
<i>1024</i>&nbsp; *     then an {@link IllegalFormatFlagsException} will be thrown.
<i>1025</i>&nbsp; *
<i>1026</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;nbsp;&amp;nbsp;&#39;&lt;/code&gt;
<i>1027</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;
<i>1028</i>&nbsp; *     &lt;td&gt; Requires the output to include a single extra space
<i>1029</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) for non-negative values.
<i>1030</i>&nbsp; *
<i>1031</i>&nbsp; *     &lt;p&gt; If both the {@code &#39;+&#39;} and &lt;code&gt;&#39;&amp;nbsp;&amp;nbsp;&#39;&lt;/code&gt; flags are given
<i>1032</i>&nbsp; *     then an {@link IllegalFormatFlagsException} will be thrown.
<i>1033</i>&nbsp; *
<i>1034</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;0&#39;}
<i>1035</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0030&#39;&lt;/code&gt;
<i>1036</i>&nbsp; *     &lt;td&gt; Requires the output to be padded with leading {@linkplain
<i>1037</i>&nbsp; *     java.text.DecimalFormatSymbols#getZeroDigit zeros} to the minimum field
<i>1038</i>&nbsp; *     width following any sign or radix indicator except when converting NaN
<i>1039</i>&nbsp; *     or infinity.  If the width is not provided, then a {@link
<i>1040</i>&nbsp; *     MissingFormatWidthException} will be thrown.
<i>1041</i>&nbsp; *
<i>1042</i>&nbsp; *     &lt;p&gt; If both the {@code &#39;-&#39;} and {@code &#39;0&#39;} flags are given then an
<i>1043</i>&nbsp; *     {@link IllegalFormatFlagsException} will be thrown.
<i>1044</i>&nbsp; *
<i>1045</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;,&#39;}
<i>1046</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u002c&#39;&lt;/code&gt;
<i>1047</i>&nbsp; *     &lt;td&gt; Requires the output to include the locale-specific {@linkplain
<i>1048</i>&nbsp; *     java.text.DecimalFormatSymbols#getGroupingSeparator group separators} as
<i>1049</i>&nbsp; *     described in the &lt;a href=&quot;#L10nGroup&quot;&gt;&quot;group&quot; section&lt;/a&gt; of the
<i>1050</i>&nbsp; *     localization algorithm.
<i>1051</i>&nbsp; *
<i>1052</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;(&#39;}
<i>1053</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0028&#39;&lt;/code&gt;
<i>1054</i>&nbsp; *     &lt;td&gt; Requires the output to prepend a {@code &#39;(&#39;}
<i>1055</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0028&#39;&lt;/code&gt;) and append a {@code &#39;)&#39;}
<i>1056</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0029&#39;&lt;/code&gt;) to negative values.
<i>1057</i>&nbsp; *
<i>1058</i>&nbsp; * &lt;/tbody&gt;
<i>1059</i>&nbsp; * &lt;/table&gt;
<i>1060</i>&nbsp; *
<i>1061</i>&nbsp; * &lt;p&gt; If no &lt;a id=&quot;intdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting is
<i>1062</i>&nbsp; * as follows:
<i>1063</i>&nbsp; *
<i>1064</i>&nbsp; * &lt;ul&gt;
<i>1065</i>&nbsp; *
<i>1066</i>&nbsp; * &lt;li&gt; The output is right-justified within the {@code width}
<i>1067</i>&nbsp; *
<i>1068</i>&nbsp; * &lt;li&gt; Negative numbers begin with a {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;)
<i>1069</i>&nbsp; *
<i>1070</i>&nbsp; * &lt;li&gt; Positive numbers and zero do not include a sign or extra leading
<i>1071</i>&nbsp; * space
<i>1072</i>&nbsp; *
<i>1073</i>&nbsp; * &lt;li&gt; No grouping separators are included
<i>1074</i>&nbsp; *
<i>1075</i>&nbsp; * &lt;/ul&gt;
<i>1076</i>&nbsp; *
<i>1077</i>&nbsp; * &lt;p&gt; The &lt;a id=&quot;intWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters to
<i>1078</i>&nbsp; * be written to the output.  This includes any signs, digits, grouping
<i>1079</i>&nbsp; * separators, radix indicator, and parentheses.  If the length of the
<i>1080</i>&nbsp; * converted value is less than the width then the output will be padded by
<i>1081</i>&nbsp; * spaces (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) until the total number of characters equals
<i>1082</i>&nbsp; * width.  The padding is on the left by default.  If {@code &#39;-&#39;} flag is
<i>1083</i>&nbsp; * given then the padding will be on the right.  If width is not specified then
<i>1084</i>&nbsp; * there is no minimum.
<i>1085</i>&nbsp; *
<i>1086</i>&nbsp; * &lt;p&gt; The precision is not applicable.  If precision is specified then an
<i>1087</i>&nbsp; * {@link IllegalFormatPrecisionException} will be thrown.
<i>1088</i>&nbsp; *
<i>1089</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;dnbint&quot;&gt;&lt;b&gt; BigInteger &lt;/b&gt;&lt;/a&gt;
<i>1090</i>&nbsp; *
<i>1091</i>&nbsp; * &lt;p&gt; The following conversions may be applied to {@link
<i>1092</i>&nbsp; * java.math.BigInteger}.
<i>1093</i>&nbsp; *
<i>1094</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1095</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;bIntConv&lt;/caption&gt;
<i>1096</i>&nbsp; * &lt;tbody&gt;
<i>1097</i>&nbsp; *
<i>1098</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;d&#39;}
<i>1099</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0064&#39;&lt;/code&gt;
<i>1100</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted as a decimal integer. The &lt;a
<i>1101</i>&nbsp; *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
<i>1102</i>&nbsp; *
<i>1103</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given {@link
<i>1104</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1105</i>&nbsp; *
<i>1106</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;o&#39;}
<i>1107</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006f&#39;&lt;/code&gt;
<i>1108</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted as an integer in base eight.
<i>1109</i>&nbsp; *     No localization is applied.
<i>1110</i>&nbsp; *
<i>1111</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
<i>1112</i>&nbsp; *     beginning with {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;).  Signed output is
<i>1113</i>&nbsp; *     allowed for this type because unlike the primitive types it is not
<i>1114</i>&nbsp; *     possible to create an unsigned equivalent without assuming an explicit
<i>1115</i>&nbsp; *     data-type size.
<i>1116</i>&nbsp; *
<i>1117</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code &#39;+&#39;} flag is given
<i>1118</i>&nbsp; *     then the result will begin with {@code &#39;+&#39;} (&lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;).
<i>1119</i>&nbsp; *
<i>1120</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then the output will always begin
<i>1121</i>&nbsp; *     with {@code &#39;0&#39;} prefix.
<i>1122</i>&nbsp; *
<i>1123</i>&nbsp; *     &lt;p&gt; If the {@code &#39;0&#39;} flag is given then the output will be padded
<i>1124</i>&nbsp; *     with leading zeros to the field width following any indication of sign.
<i>1125</i>&nbsp; *
<i>1126</i>&nbsp; *     &lt;p&gt; If the {@code &#39;,&#39;} flag is given then a {@link
<i>1127</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1128</i>&nbsp; *
<i>1129</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;x&#39;}
<i>1130</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0078&#39;&lt;/code&gt;
<i>1131</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted as an integer in base
<i>1132</i>&nbsp; *     sixteen.  No localization is applied.
<i>1133</i>&nbsp; *
<i>1134</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative then the result will be a signed value
<i>1135</i>&nbsp; *     beginning with {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;).  Signed output is
<i>1136</i>&nbsp; *     allowed for this type because unlike the primitive types it is not
<i>1137</i>&nbsp; *     possible to create an unsigned equivalent without assuming an explicit
<i>1138</i>&nbsp; *     data-type size.
<i>1139</i>&nbsp; *
<i>1140</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or zero and the {@code &#39;+&#39;} flag is given
<i>1141</i>&nbsp; *     then the result will begin with {@code &#39;+&#39;} (&lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;).
<i>1142</i>&nbsp; *
<i>1143</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then the output will always begin
<i>1144</i>&nbsp; *     with the radix indicator {@code &quot;0x&quot;}.
<i>1145</i>&nbsp; *
<i>1146</i>&nbsp; *     &lt;p&gt; If the {@code &#39;0&#39;} flag is given then the output will be padded to
<i>1147</i>&nbsp; *     the field width with leading zeros after the radix indicator or sign (if
<i>1148</i>&nbsp; *     present).
<i>1149</i>&nbsp; *
<i>1150</i>&nbsp; *     &lt;p&gt; If the {@code &#39;,&#39;} flag is given then a {@link
<i>1151</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1152</i>&nbsp; *
<i>1153</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;X&#39;}
<i>1154</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0058&#39;&lt;/code&gt;
<i>1155</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;x&#39;}.  The entire string
<i>1156</i>&nbsp; *     representing the number will be converted to {@linkplain
<i>1157</i>&nbsp; *     String#toUpperCase upper case} including the {@code &#39;x&#39;} (if any) and
<i>1158</i>&nbsp; *     all hexadecimal digits {@code &#39;a&#39;} - {@code &#39;f&#39;}
<i>1159</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt; - &lt;code&gt;&#39;&amp;#92;u0066&#39;&lt;/code&gt;).
<i>1160</i>&nbsp; *
<i>1161</i>&nbsp; * &lt;/tbody&gt;
<i>1162</i>&nbsp; * &lt;/table&gt;
<i>1163</i>&nbsp; *
<i>1164</i>&nbsp; * &lt;p&gt; If the conversion is {@code &#39;o&#39;}, {@code &#39;x&#39;}, or {@code &#39;X&#39;} and
<i>1165</i>&nbsp; * both the {@code &#39;#&#39;} and the {@code &#39;0&#39;} flags are given, then result will
<i>1166</i>&nbsp; * contain the base indicator ({@code &#39;0&#39;} for octal and {@code &quot;0x&quot;} or
<i>1167</i>&nbsp; * {@code &quot;0X&quot;} for hexadecimal), some number of zeros (based on the width),
<i>1168</i>&nbsp; * and the value.
<i>1169</i>&nbsp; *
<i>1170</i>&nbsp; * &lt;p&gt; If the {@code &#39;0&#39;} flag is given and the value is negative, then the
<i>1171</i>&nbsp; * zero padding will occur after the sign.
<i>1172</i>&nbsp; *
<i>1173</i>&nbsp; * &lt;p&gt; If the {@code &#39;-&#39;} flag is not given, then the space padding will occur
<i>1174</i>&nbsp; * before the sign.
<i>1175</i>&nbsp; *
<i>1176</i>&nbsp; * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
<i>1177</i>&nbsp; * Long apply.  The &lt;a href=&quot;#intdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
<i>1178</i>&nbsp; * given is the same as for Byte, Short, Integer, and Long.
<i>1179</i>&nbsp; *
<i>1180</i>&nbsp; * &lt;p&gt; The specification of &lt;a href=&quot;#intWidth&quot;&gt;width&lt;/a&gt; is the same as
<i>1181</i>&nbsp; * defined for Byte, Short, Integer, and Long.
<i>1182</i>&nbsp; *
<i>1183</i>&nbsp; * &lt;p&gt; The precision is not applicable.  If precision is specified then an
<i>1184</i>&nbsp; * {@link IllegalFormatPrecisionException} will be thrown.
<i>1185</i>&nbsp; *
<i>1186</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;dndec&quot;&gt;&lt;b&gt; Float and Double&lt;/b&gt;&lt;/a&gt;
<i>1187</i>&nbsp; *
<i>1188</i>&nbsp; * &lt;p&gt; The following conversions may be applied to {@code float}, {@link
<i>1189</i>&nbsp; * Float}, {@code double} and {@link Double}.
<i>1190</i>&nbsp; *
<i>1191</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1192</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;floatConv&lt;/caption&gt;
<i>1193</i>&nbsp; * &lt;tbody&gt;
<i>1194</i>&nbsp; *
<i>1195</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;e&#39;}
<i>1196</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;
<i>1197</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted using &lt;a
<i>1198</i>&nbsp; *     id=&quot;scientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
<i>1199</i>&nbsp; *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
<i>1200</i>&nbsp; *
<i>1201</i>&nbsp; *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
<i>1202</i>&nbsp; *
<i>1203</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is NaN or infinite, the literal strings &quot;NaN&quot; or
<i>1204</i>&nbsp; *     &quot;Infinity&quot;, respectively, will be output.  These values are not
<i>1205</i>&nbsp; *     localized.
<i>1206</i>&nbsp; *
<i>1207</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
<i>1208</i>&nbsp; *     will be {@code &quot;+00&quot;}.
<i>1209</i>&nbsp; *
<i>1210</i>&nbsp; *     &lt;p&gt; Otherwise, the result is a string that represents the sign and
<i>1211</i>&nbsp; *     magnitude (absolute value) of the argument.  The formatting of the sign
<i>1212</i>&nbsp; *     is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1213</i>&nbsp; *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
<i>1214</i>&nbsp; *     value.
<i>1215</i>&nbsp; *
<i>1216</i>&nbsp; *     &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
<i>1217</i>&nbsp; *     &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
<i>1218</i>&nbsp; *     mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
<i>1219</i>&nbsp; *     that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
<i>1220</i>&nbsp; *     integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
<i>1221</i>&nbsp; *     decimal separator followed by decimal digits representing the fractional
<i>1222</i>&nbsp; *     part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code &#39;e&#39;}
<i>1223</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;), followed by the sign of the exponent, followed
<i>1224</i>&nbsp; *     by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
<i>1225</i>&nbsp; *     method {@link Long#toString(long, int)}, and zero-padded to include at
<i>1226</i>&nbsp; *     least two digits.
<i>1227</i>&nbsp; *
<i>1228</i>&nbsp; *     &lt;p&gt; The number of digits in the result for the fractional part of
<i>1229</i>&nbsp; *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
<i>1230</i>&nbsp; *     specified then the default value is {@code 6}. If the precision is less
<i>1231</i>&nbsp; *     than the number of digits which would appear after the decimal point in
<i>1232</i>&nbsp; *     the string returned by {@link Float#toString(float)} or {@link
<i>1233</i>&nbsp; *     Double#toString(double)} respectively, then the value will be rounded
<i>1234</i>&nbsp; *     using the {@linkplain java.math.RoundingMode#HALF_UP round half up
<i>1235</i>&nbsp; *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
<i>1236</i>&nbsp; *     For a canonical representation of the value, use {@link
<i>1237</i>&nbsp; *     Float#toString(float)} or {@link Double#toString(double)} as
<i>1238</i>&nbsp; *     appropriate.
<i>1239</i>&nbsp; *
<i>1240</i>&nbsp; *     &lt;p&gt;If the {@code &#39;,&#39;} flag is given, then an {@link
<i>1241</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1242</i>&nbsp; *
<i>1243</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;E&#39;}
<i>1244</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0045&#39;&lt;/code&gt;
<i>1245</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;e&#39;}.  The exponent symbol
<i>1246</i>&nbsp; *     will be {@code &#39;E&#39;} (&lt;code&gt;&#39;&amp;#92;u0045&#39;&lt;/code&gt;).
<i>1247</i>&nbsp; *
<i>1248</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;g&#39;}
<i>1249</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0067&#39;&lt;/code&gt;
<i>1250</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted in general scientific notation
<i>1251</i>&nbsp; *     as described below. The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1252</i>&nbsp; *     algorithm&lt;/a&gt; is applied.
<i>1253</i>&nbsp; *
<i>1254</i>&nbsp; *     &lt;p&gt; After rounding for the precision, the formatting of the resulting
<i>1255</i>&nbsp; *     magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
<i>1256</i>&nbsp; *
<i>1257</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
<i>1258</i>&nbsp; *     than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
<i>1259</i>&nbsp; *     href=&quot;#decimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
<i>1260</i>&nbsp; *
<i>1261</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
<i>1262</i>&nbsp; *     10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
<i>1263</i>&nbsp; *     href=&quot;#scientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
<i>1264</i>&nbsp; *
<i>1265</i>&nbsp; *     &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
<i>1266</i>&nbsp; *     precision.  If the precision is not specified, then the default value is
<i>1267</i>&nbsp; *     {@code 6}.  If the precision is {@code 0}, then it is taken to be
<i>1268</i>&nbsp; *     {@code 1}.
<i>1269</i>&nbsp; *
<i>1270</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then an {@link
<i>1271</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1272</i>&nbsp; *
<i>1273</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;G&#39;}
<i>1274</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0047&#39;&lt;/code&gt;
<i>1275</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;g&#39;}.
<i>1276</i>&nbsp; *
<i>1277</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;f&#39;}
<i>1278</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0066&#39;&lt;/code&gt;
<i>1279</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted using &lt;a id=&quot;decimal&quot;&gt;decimal
<i>1280</i>&nbsp; *     format&lt;/a&gt;.  The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is
<i>1281</i>&nbsp; *     applied.
<i>1282</i>&nbsp; *
<i>1283</i>&nbsp; *     &lt;p&gt; The result is a string that represents the sign and magnitude
<i>1284</i>&nbsp; *     (absolute value) of the argument.  The formatting of the sign is
<i>1285</i>&nbsp; *     described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1286</i>&nbsp; *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
<i>1287</i>&nbsp; *     value.
<i>1288</i>&nbsp; *
<i>1289</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; NaN or infinite, the literal strings &quot;NaN&quot; or
<i>1290</i>&nbsp; *     &quot;Infinity&quot;, respectively, will be output.  These values are not
<i>1291</i>&nbsp; *     localized.
<i>1292</i>&nbsp; *
<i>1293</i>&nbsp; *     &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
<i>1294</i>&nbsp; *     leading zeroes, followed by the decimal separator followed by one or
<i>1295</i>&nbsp; *     more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
<i>1296</i>&nbsp; *
<i>1297</i>&nbsp; *     &lt;p&gt; The number of digits in the result for the fractional part of
<i>1298</i>&nbsp; *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
<i>1299</i>&nbsp; *     specified then the default value is {@code 6}. If the precision is less
<i>1300</i>&nbsp; *     than the number of digits which would appear after the decimal point in
<i>1301</i>&nbsp; *     the string returned by {@link Float#toString(float)} or {@link
<i>1302</i>&nbsp; *     Double#toString(double)} respectively, then the value will be rounded
<i>1303</i>&nbsp; *     using the {@linkplain java.math.RoundingMode#HALF_UP round half up
<i>1304</i>&nbsp; *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
<i>1305</i>&nbsp; *     For a canonical representation of the value, use {@link
<i>1306</i>&nbsp; *     Float#toString(float)} or {@link Double#toString(double)} as
<i>1307</i>&nbsp; *     appropriate.
<i>1308</i>&nbsp; *
<i>1309</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;a&#39;}
<i>1310</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;
<i>1311</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted in hexadecimal exponential
<i>1312</i>&nbsp; *     form.  No localization is applied.
<i>1313</i>&nbsp; *
<i>1314</i>&nbsp; *     &lt;p&gt; The result is a string that represents the sign and magnitude
<i>1315</i>&nbsp; *     (absolute value) of the argument &lt;i&gt;x&lt;/i&gt;.
<i>1316</i>&nbsp; *
<i>1317</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is negative or a negative-zero value then the result
<i>1318</i>&nbsp; *     will begin with {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002d&#39;&lt;/code&gt;).
<i>1319</i>&nbsp; *
<i>1320</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;x&lt;/i&gt; is positive or a positive-zero value and the
<i>1321</i>&nbsp; *     {@code &#39;+&#39;} flag is given then the result will begin with {@code &#39;+&#39;}
<i>1322</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u002b&#39;&lt;/code&gt;).
<i>1323</i>&nbsp; *
<i>1324</i>&nbsp; *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
<i>1325</i>&nbsp; *
<i>1326</i>&nbsp; *     &lt;ul&gt;
<i>1327</i>&nbsp; *
<i>1328</i>&nbsp; *     &lt;li&gt; If the value is NaN or infinite, the literal strings &quot;NaN&quot; or
<i>1329</i>&nbsp; *     &quot;Infinity&quot;, respectively, will be output.
<i>1330</i>&nbsp; *
<i>1331</i>&nbsp; *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is zero then it is represented by the string
<i>1332</i>&nbsp; *     {@code &quot;0x0.0p0&quot;}.
<i>1333</i>&nbsp; *
<i>1334</i>&nbsp; *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a normalized
<i>1335</i>&nbsp; *     representation then substrings are used to represent the significand and
<i>1336</i>&nbsp; *     exponent fields.  The significand is represented by the characters
<i>1337</i>&nbsp; *     {@code &quot;0x1.&quot;} followed by the hexadecimal representation of the rest
<i>1338</i>&nbsp; *     of the significand as a fraction.  The exponent is represented by
<i>1339</i>&nbsp; *     {@code &#39;p&#39;} (&lt;code&gt;&#39;&amp;#92;u0070&#39;&lt;/code&gt;) followed by a decimal string of the
<i>1340</i>&nbsp; *     unbiased exponent as if produced by invoking {@link
<i>1341</i>&nbsp; *     Integer#toString(int) Integer.toString} on the exponent value.  If the
<i>1342</i>&nbsp; *     precision is specified, the value is rounded to the given number of
<i>1343</i>&nbsp; *     hexadecimal digits.
<i>1344</i>&nbsp; *
<i>1345</i>&nbsp; *     &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is a {@code double} value with a subnormal
<i>1346</i>&nbsp; *     representation then, unless the precision is specified to be in the range
<i>1347</i>&nbsp; *     1 through 12, inclusive, the significand is represented by the characters
<i>1348</i>&nbsp; *     {@code &#39;0x0.&#39;} followed by the hexadecimal representation of the rest of
<i>1349</i>&nbsp; *     the significand as a fraction, and the exponent represented by
<i>1350</i>&nbsp; *     {@code &#39;p-1022&#39;}.  If the precision is in the interval
<i>1351</i>&nbsp; *     [1,&amp;nbsp;12], the subnormal value is normalized such that it
<i>1352</i>&nbsp; *     begins with the characters {@code &#39;0x1.&#39;}, rounded to the number of
<i>1353</i>&nbsp; *     hexadecimal digits of precision, and the exponent adjusted
<i>1354</i>&nbsp; *     accordingly.  Note that there must be at least one nonzero digit in a
<i>1355</i>&nbsp; *     subnormal significand.
<i>1356</i>&nbsp; *
<i>1357</i>&nbsp; *     &lt;/ul&gt;
<i>1358</i>&nbsp; *
<i>1359</i>&nbsp; *     &lt;p&gt; If the {@code &#39;(&#39;} or {@code &#39;,&#39;} flags are given, then a {@link
<i>1360</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1361</i>&nbsp; *
<i>1362</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;A&#39;}
<i>1363</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;
<i>1364</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;a&#39;}.  The entire string
<i>1365</i>&nbsp; *     representing the number will be converted to upper case including the
<i>1366</i>&nbsp; *     {@code &#39;x&#39;} (&lt;code&gt;&#39;&amp;#92;u0078&#39;&lt;/code&gt;) and {@code &#39;p&#39;}
<i>1367</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0070&#39;&lt;/code&gt; and all hexadecimal digits {@code &#39;a&#39;} -
<i>1368</i>&nbsp; *     {@code &#39;f&#39;} (&lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt; - &lt;code&gt;&#39;&amp;#92;u0066&#39;&lt;/code&gt;).
<i>1369</i>&nbsp; *
<i>1370</i>&nbsp; * &lt;/tbody&gt;
<i>1371</i>&nbsp; * &lt;/table&gt;
<i>1372</i>&nbsp; *
<i>1373</i>&nbsp; * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
<i>1374</i>&nbsp; * Long apply.
<i>1375</i>&nbsp; *
<i>1376</i>&nbsp; * &lt;p&gt; If the {@code &#39;#&#39;} flag is given, then the decimal separator will
<i>1377</i>&nbsp; * always be present.
<i>1378</i>&nbsp; *
<i>1379</i>&nbsp; * &lt;p&gt; If no &lt;a id=&quot;floatdFlags&quot;&gt;flags&lt;/a&gt; are given the default formatting
<i>1380</i>&nbsp; * is as follows:
<i>1381</i>&nbsp; *
<i>1382</i>&nbsp; * &lt;ul&gt;
<i>1383</i>&nbsp; *
<i>1384</i>&nbsp; * &lt;li&gt; The output is right-justified within the {@code width}
<i>1385</i>&nbsp; *
<i>1386</i>&nbsp; * &lt;li&gt; Negative numbers begin with a {@code &#39;-&#39;}
<i>1387</i>&nbsp; *
<i>1388</i>&nbsp; * &lt;li&gt; Positive numbers and positive zero do not include a sign or extra
<i>1389</i>&nbsp; * leading space
<i>1390</i>&nbsp; *
<i>1391</i>&nbsp; * &lt;li&gt; No grouping separators are included
<i>1392</i>&nbsp; *
<i>1393</i>&nbsp; * &lt;li&gt; The decimal separator will only appear if a digit follows it
<i>1394</i>&nbsp; *
<i>1395</i>&nbsp; * &lt;/ul&gt;
<i>1396</i>&nbsp; *
<i>1397</i>&nbsp; * &lt;p&gt; The &lt;a id=&quot;floatDWidth&quot;&gt;width&lt;/a&gt; is the minimum number of characters
<i>1398</i>&nbsp; * to be written to the output.  This includes any signs, digits, grouping
<i>1399</i>&nbsp; * separators, decimal separators, exponential symbol, radix indicator,
<i>1400</i>&nbsp; * parentheses, and strings representing infinity and NaN as applicable.  If
<i>1401</i>&nbsp; * the length of the converted value is less than the width then the output
<i>1402</i>&nbsp; * will be padded by spaces (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) until the total number of
<i>1403</i>&nbsp; * characters equals width.  The padding is on the left by default.  If the
<i>1404</i>&nbsp; * {@code &#39;-&#39;} flag is given then the padding will be on the right.  If width
<i>1405</i>&nbsp; * is not specified then there is no minimum.
<i>1406</i>&nbsp; *
<i>1407</i>&nbsp; * &lt;p&gt; If the &lt;a id=&quot;floatDPrec&quot;&gt;conversion&lt;/a&gt; is {@code &#39;e&#39;},
<i>1408</i>&nbsp; * {@code &#39;E&#39;} or {@code &#39;f&#39;}, then the precision is the number of digits
<i>1409</i>&nbsp; * after the decimal separator.  If the precision is not specified, then it is
<i>1410</i>&nbsp; * assumed to be {@code 6}.
<i>1411</i>&nbsp; *
<i>1412</i>&nbsp; * &lt;p&gt; If the conversion is {@code &#39;g&#39;} or {@code &#39;G&#39;}, then the precision is
<i>1413</i>&nbsp; * the total number of significant digits in the resulting magnitude after
<i>1414</i>&nbsp; * rounding.  If the precision is not specified, then the default value is
<i>1415</i>&nbsp; * {@code 6}.  If the precision is {@code 0}, then it is taken to be
<i>1416</i>&nbsp; * {@code 1}.
<i>1417</i>&nbsp; *
<i>1418</i>&nbsp; * &lt;p&gt; If the conversion is {@code &#39;a&#39;} or {@code &#39;A&#39;}, then the precision
<i>1419</i>&nbsp; * is the number of hexadecimal digits after the radix point.  If the
<i>1420</i>&nbsp; * precision is not provided, then all of the digits as returned by {@link
<i>1421</i>&nbsp; * Double#toHexString(double)} will be output.
<i>1422</i>&nbsp; *
<i>1423</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;dnbdec&quot;&gt;&lt;b&gt; BigDecimal &lt;/b&gt;&lt;/a&gt;
<i>1424</i>&nbsp; *
<i>1425</i>&nbsp; * &lt;p&gt; The following conversions may be applied {@link java.math.BigDecimal
<i>1426</i>&nbsp; * BigDecimal}.
<i>1427</i>&nbsp; *
<i>1428</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1429</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;floatConv&lt;/caption&gt;
<i>1430</i>&nbsp; * &lt;tbody&gt;
<i>1431</i>&nbsp; *
<i>1432</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;e&#39;}
<i>1433</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;
<i>1434</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted using &lt;a
<i>1435</i>&nbsp; *     id=&quot;bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;.  The &lt;a
<i>1436</i>&nbsp; *     href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is applied.
<i>1437</i>&nbsp; *
<i>1438</i>&nbsp; *     &lt;p&gt; The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its value.
<i>1439</i>&nbsp; *
<i>1440</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is positive-zero or negative-zero, then the exponent
<i>1441</i>&nbsp; *     will be {@code &quot;+00&quot;}.
<i>1442</i>&nbsp; *
<i>1443</i>&nbsp; *     &lt;p&gt; Otherwise, the result is a string that represents the sign and
<i>1444</i>&nbsp; *     magnitude (absolute value) of the argument.  The formatting of the sign
<i>1445</i>&nbsp; *     is described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1446</i>&nbsp; *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
<i>1447</i>&nbsp; *     value.
<i>1448</i>&nbsp; *
<i>1449</i>&nbsp; *     &lt;p&gt; Let &lt;i&gt;n&lt;/i&gt; be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;
<i>1450</i>&nbsp; *     &amp;lt;= &lt;i&gt;m&lt;/i&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt; be the
<i>1451</i>&nbsp; *     mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so
<i>1452</i>&nbsp; *     that 1 &amp;lt;= &lt;i&gt;a&lt;/i&gt; &amp;lt; 10. The magnitude is then represented as the
<i>1453</i>&nbsp; *     integer part of &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by the
<i>1454</i>&nbsp; *     decimal separator followed by decimal digits representing the fractional
<i>1455</i>&nbsp; *     part of &lt;i&gt;a&lt;/i&gt;, followed by the exponent symbol {@code &#39;e&#39;}
<i>1456</i>&nbsp; *     (&lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;), followed by the sign of the exponent, followed
<i>1457</i>&nbsp; *     by a representation of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
<i>1458</i>&nbsp; *     method {@link Long#toString(long, int)}, and zero-padded to include at
<i>1459</i>&nbsp; *     least two digits.
<i>1460</i>&nbsp; *
<i>1461</i>&nbsp; *     &lt;p&gt; The number of digits in the result for the fractional part of
<i>1462</i>&nbsp; *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision.  If the precision is not
<i>1463</i>&nbsp; *     specified then the default value is {@code 6}.  If the precision is
<i>1464</i>&nbsp; *     less than the number of digits to the right of the decimal point then
<i>1465</i>&nbsp; *     the value will be rounded using the
<i>1466</i>&nbsp; *     {@linkplain java.math.RoundingMode#HALF_UP round half up
<i>1467</i>&nbsp; *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
<i>1468</i>&nbsp; *     For a canonical representation of the value, use {@link
<i>1469</i>&nbsp; *     BigDecimal#toString()}.
<i>1470</i>&nbsp; *
<i>1471</i>&nbsp; *     &lt;p&gt; If the {@code &#39;,&#39;} flag is given, then an {@link
<i>1472</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1473</i>&nbsp; *
<i>1474</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;E&#39;}
<i>1475</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0045&#39;&lt;/code&gt;
<i>1476</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;e&#39;}.  The exponent symbol
<i>1477</i>&nbsp; *     will be {@code &#39;E&#39;} (&lt;code&gt;&#39;&amp;#92;u0045&#39;&lt;/code&gt;).
<i>1478</i>&nbsp; *
<i>1479</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;g&#39;}
<i>1480</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0067&#39;&lt;/code&gt;
<i>1481</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted in general scientific notation
<i>1482</i>&nbsp; *     as described below. The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1483</i>&nbsp; *     algorithm&lt;/a&gt; is applied.
<i>1484</i>&nbsp; *
<i>1485</i>&nbsp; *     &lt;p&gt; After rounding for the precision, the formatting of the resulting
<i>1486</i>&nbsp; *     magnitude &lt;i&gt;m&lt;/i&gt; depends on its value.
<i>1487</i>&nbsp; *
<i>1488</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-4&lt;/sup&gt; but less
<i>1489</i>&nbsp; *     than 10&lt;sup&gt;precision&lt;/sup&gt; then it is represented in &lt;i&gt;&lt;a
<i>1490</i>&nbsp; *     href=&quot;#bdecimal&quot;&gt;decimal format&lt;/a&gt;&lt;/i&gt;.
<i>1491</i>&nbsp; *
<i>1492</i>&nbsp; *     &lt;p&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-4&lt;/sup&gt; or greater than or equal to
<i>1493</i>&nbsp; *     10&lt;sup&gt;precision&lt;/sup&gt;, then it is represented in &lt;i&gt;&lt;a
<i>1494</i>&nbsp; *     href=&quot;#bscientific&quot;&gt;computerized scientific notation&lt;/a&gt;&lt;/i&gt;.
<i>1495</i>&nbsp; *
<i>1496</i>&nbsp; *     &lt;p&gt; The total number of significant digits in &lt;i&gt;m&lt;/i&gt; is equal to the
<i>1497</i>&nbsp; *     precision.  If the precision is not specified, then the default value is
<i>1498</i>&nbsp; *     {@code 6}.  If the precision is {@code 0}, then it is taken to be
<i>1499</i>&nbsp; *     {@code 1}.
<i>1500</i>&nbsp; *
<i>1501</i>&nbsp; *     &lt;p&gt; If the {@code &#39;#&#39;} flag is given then an {@link
<i>1502</i>&nbsp; *     FormatFlagsConversionMismatchException} will be thrown.
<i>1503</i>&nbsp; *
<i>1504</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;G&#39;}
<i>1505</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0047&#39;&lt;/code&gt;
<i>1506</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;g&#39;}.
<i>1507</i>&nbsp; *
<i>1508</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;f&#39;}
<i>1509</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0066&#39;&lt;/code&gt;
<i>1510</i>&nbsp; *     &lt;td&gt; Requires the output to be formatted using &lt;a id=&quot;bdecimal&quot;&gt;decimal
<i>1511</i>&nbsp; *     format&lt;/a&gt;.  The &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization algorithm&lt;/a&gt; is
<i>1512</i>&nbsp; *     applied.
<i>1513</i>&nbsp; *
<i>1514</i>&nbsp; *     &lt;p&gt; The result is a string that represents the sign and magnitude
<i>1515</i>&nbsp; *     (absolute value) of the argument.  The formatting of the sign is
<i>1516</i>&nbsp; *     described in the &lt;a href=&quot;#L10nAlgorithm&quot;&gt;localization
<i>1517</i>&nbsp; *     algorithm&lt;/a&gt;. The formatting of the magnitude &lt;i&gt;m&lt;/i&gt; depends upon its
<i>1518</i>&nbsp; *     value.
<i>1519</i>&nbsp; *
<i>1520</i>&nbsp; *     &lt;p&gt; The magnitude is formatted as the integer part of &lt;i&gt;m&lt;/i&gt;, with no
<i>1521</i>&nbsp; *     leading zeroes, followed by the decimal separator followed by one or
<i>1522</i>&nbsp; *     more decimal digits representing the fractional part of &lt;i&gt;m&lt;/i&gt;.
<i>1523</i>&nbsp; *
<i>1524</i>&nbsp; *     &lt;p&gt; The number of digits in the result for the fractional part of
<i>1525</i>&nbsp; *     &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt; is equal to the precision. If the precision is not
<i>1526</i>&nbsp; *     specified then the default value is {@code 6}.  If the precision is
<i>1527</i>&nbsp; *     less than the number of digits to the right of the decimal point
<i>1528</i>&nbsp; *     then the value will be rounded using the
<i>1529</i>&nbsp; *     {@linkplain java.math.RoundingMode#HALF_UP round half up
<i>1530</i>&nbsp; *     algorithm}.  Otherwise, zeros may be appended to reach the precision.
<i>1531</i>&nbsp; *     For a canonical representation of the value, use {@link
<i>1532</i>&nbsp; *     BigDecimal#toString()}.
<i>1533</i>&nbsp; *
<i>1534</i>&nbsp; * &lt;/tbody&gt;
<i>1535</i>&nbsp; * &lt;/table&gt;
<i>1536</i>&nbsp; *
<i>1537</i>&nbsp; * &lt;p&gt; All &lt;a href=&quot;#intFlags&quot;&gt;flags&lt;/a&gt; defined for Byte, Short, Integer, and
<i>1538</i>&nbsp; * Long apply.
<i>1539</i>&nbsp; *
<i>1540</i>&nbsp; * &lt;p&gt; If the {@code &#39;#&#39;} flag is given, then the decimal separator will
<i>1541</i>&nbsp; * always be present.
<i>1542</i>&nbsp; *
<i>1543</i>&nbsp; * &lt;p&gt; The &lt;a href=&quot;#floatdFlags&quot;&gt;default behavior&lt;/a&gt; when no flags are
<i>1544</i>&nbsp; * given is the same as for Float and Double.
<i>1545</i>&nbsp; *
<i>1546</i>&nbsp; * &lt;p&gt; The specification of &lt;a href=&quot;#floatDWidth&quot;&gt;width&lt;/a&gt; and &lt;a
<i>1547</i>&nbsp; * href=&quot;#floatDPrec&quot;&gt;precision&lt;/a&gt; is the same as defined for Float and
<i>1548</i>&nbsp; * Double.
<i>1549</i>&nbsp; *
<i>1550</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;ddt&quot;&gt;Date/Time&lt;/a&gt;&lt;/h4&gt;
<i>1551</i>&nbsp; *
<i>1552</i>&nbsp; * &lt;p&gt; This conversion may be applied to {@code long}, {@link Long}, {@link
<i>1553</i>&nbsp; * Calendar}, {@link Date} and {@link TemporalAccessor TemporalAccessor}
<i>1554</i>&nbsp; *
<i>1555</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1556</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;DTConv&lt;/caption&gt;
<i>1557</i>&nbsp; * &lt;tbody&gt;
<i>1558</i>&nbsp; *
<i>1559</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;t&#39;}
<i>1560</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0074&#39;&lt;/code&gt;
<i>1561</i>&nbsp; *     &lt;td&gt; Prefix for date and time conversion characters.
<i>1562</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;T&#39;}
<i>1563</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0054&#39;&lt;/code&gt;
<i>1564</i>&nbsp; *     &lt;td&gt; The upper-case variant of {@code &#39;t&#39;}.
<i>1565</i>&nbsp; *
<i>1566</i>&nbsp; * &lt;/tbody&gt;
<i>1567</i>&nbsp; * &lt;/table&gt;
<i>1568</i>&nbsp; *
<i>1569</i>&nbsp; * &lt;p&gt; The following date and time conversion character suffixes are defined
<i>1570</i>&nbsp; * for the {@code &#39;t&#39;} and {@code &#39;T&#39;} conversions.  The types are similar to
<i>1571</i>&nbsp; * but not completely identical to those defined by GNU {@code date} and
<i>1572</i>&nbsp; * POSIX {@code strftime(3c)}.  Additional conversion types are provided to
<i>1573</i>&nbsp; * access Java-specific functionality (e.g. {@code &#39;L&#39;} for milliseconds
<i>1574</i>&nbsp; * within the second).
<i>1575</i>&nbsp; *
<i>1576</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting times:
<i>1577</i>&nbsp; *
<i>1578</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1579</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;time&lt;/caption&gt;
<i>1580</i>&nbsp; * &lt;tbody&gt;
<i>1581</i>&nbsp; *
<i>1582</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt; {@code &#39;H&#39;}
<i>1583</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0048&#39;&lt;/code&gt;
<i>1584</i>&nbsp; *     &lt;td&gt; Hour of the day for the 24-hour clock, formatted as two digits with
<i>1585</i>&nbsp; *     a leading zero as necessary i.e. {@code 00 - 23}. {@code 00}
<i>1586</i>&nbsp; *     corresponds to midnight.
<i>1587</i>&nbsp; *
<i>1588</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;I&#39;}
<i>1589</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0049&#39;&lt;/code&gt;
<i>1590</i>&nbsp; *     &lt;td&gt; Hour for the 12-hour clock, formatted as two digits with a leading
<i>1591</i>&nbsp; *     zero as necessary, i.e.  {@code 01 - 12}.  {@code 01} corresponds to
<i>1592</i>&nbsp; *     one o&#39;clock (either morning or afternoon).
<i>1593</i>&nbsp; *
<i>1594</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;k&#39;}
<i>1595</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006b&#39;&lt;/code&gt;
<i>1596</i>&nbsp; *     &lt;td&gt; Hour of the day for the 24-hour clock, i.e. {@code 0 - 23}.
<i>1597</i>&nbsp; *     {@code 0} corresponds to midnight.
<i>1598</i>&nbsp; *
<i>1599</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;l&#39;}
<i>1600</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006c&#39;&lt;/code&gt;
<i>1601</i>&nbsp; *     &lt;td&gt; Hour for the 12-hour clock, i.e. {@code 1 - 12}.  {@code 1}
<i>1602</i>&nbsp; *     corresponds to one o&#39;clock (either morning or afternoon).
<i>1603</i>&nbsp; *
<i>1604</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;M&#39;}
<i>1605</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u004d&#39;&lt;/code&gt;
<i>1606</i>&nbsp; *     &lt;td&gt; Minute within the hour formatted as two digits with a leading zero
<i>1607</i>&nbsp; *     as necessary, i.e.  {@code 00 - 59}.
<i>1608</i>&nbsp; *
<i>1609</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;S&#39;}
<i>1610</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0053&#39;&lt;/code&gt;
<i>1611</i>&nbsp; *     &lt;td&gt; Seconds within the minute, formatted as two digits with a leading
<i>1612</i>&nbsp; *     zero as necessary, i.e. {@code 00 - 60} (&quot;{@code 60}&quot; is a special
<i>1613</i>&nbsp; *     value required to support leap seconds).
<i>1614</i>&nbsp; *
<i>1615</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;L&#39;}
<i>1616</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u004c&#39;&lt;/code&gt;
<i>1617</i>&nbsp; *     &lt;td&gt; Millisecond within the second formatted as three digits with
<i>1618</i>&nbsp; *     leading zeros as necessary, i.e. {@code 000 - 999}.
<i>1619</i>&nbsp; *
<i>1620</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;N&#39;}
<i>1621</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u004e&#39;&lt;/code&gt;
<i>1622</i>&nbsp; *     &lt;td&gt; Nanosecond within the second, formatted as nine digits with leading
<i>1623</i>&nbsp; *     zeros as necessary, i.e. {@code 000000000 - 999999999}.  The precision
<i>1624</i>&nbsp; *     of this value is limited by the resolution of the underlying operating
<i>1625</i>&nbsp; *     system or hardware.
<i>1626</i>&nbsp; *
<i>1627</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;p&#39;}
<i>1628</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0070&#39;&lt;/code&gt;
<i>1629</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain
<i>1630</i>&nbsp; *     java.text.DateFormatSymbols#getAmPmStrings morning or afternoon} marker
<i>1631</i>&nbsp; *     in lower case, e.g.&quot;{@code am}&quot; or &quot;{@code pm}&quot;.  Use of the
<i>1632</i>&nbsp; *     conversion prefix {@code &#39;T&#39;} forces this output to upper case.  (Note
<i>1633</i>&nbsp; *     that {@code &#39;p&#39;} produces lower-case output.  This is different from
<i>1634</i>&nbsp; *     GNU {@code date} and POSIX {@code strftime(3c)} which produce
<i>1635</i>&nbsp; *     upper-case output.)
<i>1636</i>&nbsp; *
<i>1637</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;z&#39;}
<i>1638</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u007a&#39;&lt;/code&gt;
<i>1639</i>&nbsp; *     &lt;td&gt; &lt;a href=&quot;http://www.ietf.org/rfc/rfc0822.txt&quot;&gt;RFC&amp;nbsp;822&lt;/a&gt;
<i>1640</i>&nbsp; *     style numeric time zone offset from GMT, e.g. {@code -0800}.  This
<i>1641</i>&nbsp; *     value will be adjusted as necessary for Daylight Saving Time.  For
<i>1642</i>&nbsp; *     {@code long}, {@link Long}, and {@link Date} the time zone used is
<i>1643</i>&nbsp; *     the {@linkplain TimeZone#getDefault() default time zone} for this
<i>1644</i>&nbsp; *     instance of the Java virtual machine.
<i>1645</i>&nbsp; *
<i>1646</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Z&#39;}
<i>1647</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u005a&#39;&lt;/code&gt;
<i>1648</i>&nbsp; *     &lt;td&gt; A string representing the abbreviation for the time zone.  This
<i>1649</i>&nbsp; *     value will be adjusted as necessary for Daylight Saving Time.  For
<i>1650</i>&nbsp; *     {@code long}, {@link Long}, and {@link Date} the time zone used is
<i>1651</i>&nbsp; *     the {@linkplain TimeZone#getDefault() default time zone} for this
<i>1652</i>&nbsp; *     instance of the Java virtual machine.  The Formatter&#39;s locale will
<i>1653</i>&nbsp; *     supersede the locale of the argument (if any).
<i>1654</i>&nbsp; *
<i>1655</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;s&#39;}
<i>1656</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0073&#39;&lt;/code&gt;
<i>1657</i>&nbsp; *     &lt;td&gt; Seconds since the beginning of the epoch starting at 1 January 1970
<i>1658</i>&nbsp; *     {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE/1000} to
<i>1659</i>&nbsp; *     {@code Long.MAX_VALUE/1000}.
<i>1660</i>&nbsp; *
<i>1661</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Q&#39;}
<i>1662</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u004f&#39;&lt;/code&gt;
<i>1663</i>&nbsp; *     &lt;td&gt; Milliseconds since the beginning of the epoch starting at 1 January
<i>1664</i>&nbsp; *     1970 {@code 00:00:00} UTC, i.e. {@code Long.MIN_VALUE} to
<i>1665</i>&nbsp; *     {@code Long.MAX_VALUE}. The precision of this value is limited by
<i>1666</i>&nbsp; *     the resolution of the underlying operating system or hardware.
<i>1667</i>&nbsp; *
<i>1668</i>&nbsp; * &lt;/tbody&gt;
<i>1669</i>&nbsp; * &lt;/table&gt;
<i>1670</i>&nbsp; *
<i>1671</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting dates:
<i>1672</i>&nbsp; *
<i>1673</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1674</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;date&lt;/caption&gt;
<i>1675</i>&nbsp; * &lt;tbody&gt;
<i>1676</i>&nbsp; *
<i>1677</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;B&#39;}
<i>1678</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0042&#39;&lt;/code&gt;
<i>1679</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain java.text.DateFormatSymbols#getMonths
<i>1680</i>&nbsp; *     full month name}, e.g. {@code &quot;January&quot;}, {@code &quot;February&quot;}.
<i>1681</i>&nbsp; *
<i>1682</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;b&#39;}
<i>1683</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0062&#39;&lt;/code&gt;
<i>1684</i>&nbsp; *     &lt;td&gt; Locale-specific {@linkplain
<i>1685</i>&nbsp; *     java.text.DateFormatSymbols#getShortMonths abbreviated month name},
<i>1686</i>&nbsp; *     e.g. {@code &quot;Jan&quot;}, {@code &quot;Feb&quot;}.
<i>1687</i>&nbsp; *
<i>1688</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;h&#39;}
<i>1689</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0068&#39;&lt;/code&gt;
<i>1690</i>&nbsp; *     &lt;td&gt; Same as {@code &#39;b&#39;}.
<i>1691</i>&nbsp; *
<i>1692</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;A&#39;}
<i>1693</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0041&#39;&lt;/code&gt;
<i>1694</i>&nbsp; *     &lt;td&gt; Locale-specific full name of the {@linkplain
<i>1695</i>&nbsp; *     java.text.DateFormatSymbols#getWeekdays day of the week},
<i>1696</i>&nbsp; *     e.g. {@code &quot;Sunday&quot;}, {@code &quot;Monday&quot;}
<i>1697</i>&nbsp; *
<i>1698</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;a&#39;}
<i>1699</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0061&#39;&lt;/code&gt;
<i>1700</i>&nbsp; *     &lt;td&gt; Locale-specific short name of the {@linkplain
<i>1701</i>&nbsp; *     java.text.DateFormatSymbols#getShortWeekdays day of the week},
<i>1702</i>&nbsp; *     e.g. {@code &quot;Sun&quot;}, {@code &quot;Mon&quot;}
<i>1703</i>&nbsp; *
<i>1704</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;C&#39;}
<i>1705</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0043&#39;&lt;/code&gt;
<i>1706</i>&nbsp; *     &lt;td&gt; Four-digit year divided by {@code 100}, formatted as two digits
<i>1707</i>&nbsp; *     with leading zero as necessary, i.e. {@code 00 - 99}
<i>1708</i>&nbsp; *
<i>1709</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;Y&#39;}
<i>1710</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0059&#39;&lt;/code&gt; &lt;td&gt; Year, formatted to at least
<i>1711</i>&nbsp; *     four digits with leading zeros as necessary, e.g. {@code 0092} equals
<i>1712</i>&nbsp; *     {@code 92} CE for the Gregorian calendar.
<i>1713</i>&nbsp; *
<i>1714</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;y&#39;}
<i>1715</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0079&#39;&lt;/code&gt;
<i>1716</i>&nbsp; *     &lt;td&gt; Last two digits of the year, formatted with leading zeros as
<i>1717</i>&nbsp; *     necessary, i.e. {@code 00 - 99}.
<i>1718</i>&nbsp; *
<i>1719</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;j&#39;}
<i>1720</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006a&#39;&lt;/code&gt;
<i>1721</i>&nbsp; *     &lt;td&gt; Day of year, formatted as three digits with leading zeros as
<i>1722</i>&nbsp; *     necessary, e.g. {@code 001 - 366} for the Gregorian calendar.
<i>1723</i>&nbsp; *     {@code 001} corresponds to the first day of the year.
<i>1724</i>&nbsp; *
<i>1725</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;m&#39;}
<i>1726</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u006d&#39;&lt;/code&gt;
<i>1727</i>&nbsp; *     &lt;td&gt; Month, formatted as two digits with leading zeros as necessary,
<i>1728</i>&nbsp; *     i.e. {@code 01 - 13}, where &quot;{@code 01}&quot; is the first month of the
<i>1729</i>&nbsp; *     year and (&quot;{@code 13}&quot; is a special value required to support lunar
<i>1730</i>&nbsp; *     calendars).
<i>1731</i>&nbsp; *
<i>1732</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;d&#39;}
<i>1733</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0064&#39;&lt;/code&gt;
<i>1734</i>&nbsp; *     &lt;td&gt; Day of month, formatted as two digits with leading zeros as
<i>1735</i>&nbsp; *     necessary, i.e. {@code 01 - 31}, where &quot;{@code 01}&quot; is the first day
<i>1736</i>&nbsp; *     of the month.
<i>1737</i>&nbsp; *
<i>1738</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;e&#39;}
<i>1739</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;
<i>1740</i>&nbsp; *     &lt;td&gt; Day of month, formatted as two digits, i.e. {@code 1 - 31} where
<i>1741</i>&nbsp; *     &quot;{@code 1}&quot; is the first day of the month.
<i>1742</i>&nbsp; *
<i>1743</i>&nbsp; * &lt;/tbody&gt;
<i>1744</i>&nbsp; * &lt;/table&gt;
<i>1745</i>&nbsp; *
<i>1746</i>&nbsp; * &lt;p&gt; The following conversion characters are used for formatting common
<i>1747</i>&nbsp; * date/time compositions.
<i>1748</i>&nbsp; *
<i>1749</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1750</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;composites&lt;/caption&gt;
<i>1751</i>&nbsp; * &lt;tbody&gt;
<i>1752</i>&nbsp; *
<i>1753</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;R&#39;}
<i>1754</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0052&#39;&lt;/code&gt;
<i>1755</i>&nbsp; *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM&quot;}
<i>1756</i>&nbsp; *
<i>1757</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;T&#39;}
<i>1758</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0054&#39;&lt;/code&gt;
<i>1759</i>&nbsp; *     &lt;td&gt; Time formatted for the 24-hour clock as {@code &quot;%tH:%tM:%tS&quot;}.
<i>1760</i>&nbsp; *
<i>1761</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;r&#39;}
<i>1762</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0072&#39;&lt;/code&gt;
<i>1763</i>&nbsp; *     &lt;td&gt; Time formatted for the 12-hour clock as {@code &quot;%tI:%tM:%tS
<i>1764</i>&nbsp; *     %Tp&quot;}.  The location of the morning or afternoon marker
<i>1765</i>&nbsp; *     ({@code &#39;%Tp&#39;}) may be locale-dependent.
<i>1766</i>&nbsp; *
<i>1767</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;D&#39;}
<i>1768</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0044&#39;&lt;/code&gt;
<i>1769</i>&nbsp; *     &lt;td&gt; Date formatted as {@code &quot;%tm/%td/%ty&quot;}.
<i>1770</i>&nbsp; *
<i>1771</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;F&#39;}
<i>1772</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0046&#39;&lt;/code&gt;
<i>1773</i>&nbsp; *     &lt;td&gt; &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO&amp;nbsp;8601&lt;/a&gt;
<i>1774</i>&nbsp; *     complete date formatted as {@code &quot;%tY-%tm-%td&quot;}.
<i>1775</i>&nbsp; *
<i>1776</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;c&#39;}
<i>1777</i>&nbsp; *     &lt;td style=&quot;vertical-align:top&quot;&gt; &lt;code&gt;&#39;&amp;#92;u0063&#39;&lt;/code&gt;
<i>1778</i>&nbsp; *     &lt;td&gt; Date and time formatted as {@code &quot;%ta %tb %td %tT %tZ %tY&quot;},
<i>1779</i>&nbsp; *     e.g. {@code &quot;Sun Jul 20 16:17:00 EDT 1969&quot;}.
<i>1780</i>&nbsp; *
<i>1781</i>&nbsp; * &lt;/tbody&gt;
<i>1782</i>&nbsp; * &lt;/table&gt;
<i>1783</i>&nbsp; *
<i>1784</i>&nbsp; * &lt;p&gt; The {@code &#39;-&#39;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
<i>1785</i>&nbsp; * conversions&lt;/a&gt; applies.  If the {@code &#39;#&#39;} flag is given, then a {@link
<i>1786</i>&nbsp; * FormatFlagsConversionMismatchException} will be thrown.
<i>1787</i>&nbsp; *
<i>1788</i>&nbsp; * &lt;p&gt; The width is the minimum number of characters to
<i>1789</i>&nbsp; * be written to the output.  If the length of the converted value is less than
<i>1790</i>&nbsp; * the {@code width} then the output will be padded by spaces
<i>1791</i>&nbsp; * (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) until the total number of characters equals width.
<i>1792</i>&nbsp; * The padding is on the left by default.  If the {@code &#39;-&#39;} flag is given
<i>1793</i>&nbsp; * then the padding will be on the right.  If width is not specified then there
<i>1794</i>&nbsp; * is no minimum.
<i>1795</i>&nbsp; *
<i>1796</i>&nbsp; * &lt;p&gt; The precision is not applicable.  If the precision is specified then an
<i>1797</i>&nbsp; * {@link IllegalFormatPrecisionException} will be thrown.
<i>1798</i>&nbsp; *
<i>1799</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dper&quot;&gt;Percent&lt;/a&gt;&lt;/h4&gt;
<i>1800</i>&nbsp; *
<i>1801</i>&nbsp; * &lt;p&gt; The conversion does not correspond to any argument.
<i>1802</i>&nbsp; *
<i>1803</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1804</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;DTConv&lt;/caption&gt;
<i>1805</i>&nbsp; * &lt;tbody&gt;
<i>1806</i>&nbsp; *
<i>1807</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;%&#39;}
<i>1808</i>&nbsp; *     &lt;td&gt; The result is a literal {@code &#39;%&#39;} (&lt;code&gt;&#39;&amp;#92;u0025&#39;&lt;/code&gt;)
<i>1809</i>&nbsp; *
<i>1810</i>&nbsp; * &lt;p&gt; The width is the minimum number of characters to
<i>1811</i>&nbsp; * be written to the output including the {@code &#39;%&#39;}.  If the length of the
<i>1812</i>&nbsp; * converted value is less than the {@code width} then the output will be
<i>1813</i>&nbsp; * padded by spaces (&lt;code&gt;&#39;&amp;#92;u0020&#39;&lt;/code&gt;) until the total number of
<i>1814</i>&nbsp; * characters equals width.  The padding is on the left.  If width is not
<i>1815</i>&nbsp; * specified then just the {@code &#39;%&#39;} is output.
<i>1816</i>&nbsp; *
<i>1817</i>&nbsp; * &lt;p&gt; The {@code &#39;-&#39;} flag defined for &lt;a href=&quot;#dFlags&quot;&gt;General
<i>1818</i>&nbsp; * conversions&lt;/a&gt; applies.  If any other flags are provided, then a
<i>1819</i>&nbsp; * {@link FormatFlagsConversionMismatchException} will be thrown.
<i>1820</i>&nbsp; *
<i>1821</i>&nbsp; * &lt;p&gt; The precision is not applicable.  If the precision is specified an
<i>1822</i>&nbsp; * {@link IllegalFormatPrecisionException} will be thrown.
<i>1823</i>&nbsp; *
<i>1824</i>&nbsp; * &lt;/tbody&gt;
<i>1825</i>&nbsp; * &lt;/table&gt;
<i>1826</i>&nbsp; *
<i>1827</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dls&quot;&gt;Line Separator&lt;/a&gt;&lt;/h4&gt;
<i>1828</i>&nbsp; *
<i>1829</i>&nbsp; * &lt;p&gt; The conversion does not correspond to any argument.
<i>1830</i>&nbsp; *
<i>1831</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>1832</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;DTConv&lt;/caption&gt;
<i>1833</i>&nbsp; * &lt;tbody&gt;
<i>1834</i>&nbsp; *
<i>1835</i>&nbsp; * &lt;tr&gt;&lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;{@code &#39;n&#39;}
<i>1836</i>&nbsp; *     &lt;td&gt; the platform-specific line separator as returned by {@link
<i>1837</i>&nbsp; *     System#lineSeparator()}.
<i>1838</i>&nbsp; *
<i>1839</i>&nbsp; * &lt;/tbody&gt;
<i>1840</i>&nbsp; * &lt;/table&gt;
<i>1841</i>&nbsp; *
<i>1842</i>&nbsp; * &lt;p&gt; Flags, width, and precision are not applicable.  If any are provided an
<i>1843</i>&nbsp; * {@link IllegalFormatFlagsException}, {@link IllegalFormatWidthException},
<i>1844</i>&nbsp; * and {@link IllegalFormatPrecisionException}, respectively will be thrown.
<i>1845</i>&nbsp; *
<i>1846</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;dpos&quot;&gt;Argument Index&lt;/a&gt;&lt;/h4&gt;
<i>1847</i>&nbsp; *
<i>1848</i>&nbsp; * &lt;p&gt; Format specifiers can reference arguments in three ways:
<i>1849</i>&nbsp; *
<i>1850</i>&nbsp; * &lt;ul&gt;
<b class="nc"><i>1851</i>&nbsp; *</b>
<i>1852</i>&nbsp; * &lt;li&gt; &lt;i&gt;Explicit indexing&lt;/i&gt; is used when the format specifier contains an
<i>1853</i>&nbsp; * argument index.  The argument index is a decimal integer indicating the
<i>1854</i>&nbsp; * position of the argument in the argument list.  The first argument is
<i>1855</i>&nbsp; * referenced by &quot;{@code 1$}&quot;, the second by &quot;{@code 2$}&quot;, etc.  An argument
<i>1856</i>&nbsp; * may be referenced more than once.
<i>1857</i>&nbsp; *
<i>1858</i>&nbsp; * &lt;p&gt; For example:
<i>1859</i>&nbsp; *
<i>1860</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>1861</i>&nbsp; *   formatter.format(&quot;%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s&quot;,
<i>1862</i>&nbsp; *                    &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
<i>1863</i>&nbsp; *   // -&amp;gt; &quot;d c b a d c b a&quot;
<i>1864</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>1865</i>&nbsp; *
<i>1866</i>&nbsp; * &lt;li&gt; &lt;i&gt;Relative indexing&lt;/i&gt; is used when the format specifier contains a
<i>1867</i>&nbsp; * {@code &#39;&lt;&#39;} (&lt;code&gt;&#39;&amp;#92;u003c&#39;&lt;/code&gt;) flag which causes the argument for
<i>1868</i>&nbsp; * the previous format specifier to be re-used.  If there is no previous
<i>1869</i>&nbsp; * argument, then a {@link MissingFormatArgumentException} is thrown.
<i>1870</i>&nbsp; *
<i>1871</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<b class="nc"><i>1872</i>&nbsp; *    formatter.format(&quot;%s %s %&amp;lt;s %&amp;lt;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</b>
<i>1873</i>&nbsp; *    // -&amp;gt; &quot;a b b b&quot;
<b class="nc"><i>1874</i>&nbsp; *    // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced</b>
<b class="nc"><i>1875</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;</b>
<i>1876</i>&nbsp; *
<b class="nc"><i>1877</i>&nbsp; * &lt;li&gt; &lt;i&gt;Ordinary indexing&lt;/i&gt; is used when the format specifier contains</b>
<i>1878</i>&nbsp; * neither an argument index nor a {@code &#39;&lt;&#39;} flag.  Each format specifier
<i>1879</i>&nbsp; * which uses ordinary indexing is assigned a sequential implicit index into
<i>1880</i>&nbsp; * argument list which is independent of the indices used by explicit or
<i>1881</i>&nbsp; * relative indexing.
<b class="nc"><i>1882</i>&nbsp; *</b>
<b class="nc"><i>1883</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;</b>
<i>1884</i>&nbsp; *   formatter.format(&quot;%s %s %s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
<b class="nc"><i>1885</i>&nbsp; *   // -&amp;gt; &quot;a b c d&quot;</b>
<i>1886</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>1887</i>&nbsp; *
<i>1888</i>&nbsp; * &lt;/ul&gt;
<b class="nc"><i>1889</i>&nbsp; *</b>
<b class="nc"><i>1890</i>&nbsp; * &lt;p&gt; It is possible to have a format string which uses all forms of indexing,</b>
<b class="nc"><i>1891</i>&nbsp; * for example:</b>
<b class="nc"><i>1892</i>&nbsp; *</b>
<i>1893</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>1894</i>&nbsp; *   formatter.format(&quot;%2$s %s %&amp;lt;s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)
<i>1895</i>&nbsp; *   // -&amp;gt; &quot;b a a b&quot;
<i>1896</i>&nbsp; *   // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced
<i>1897</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<b class="nc"><i>1898</i>&nbsp; *</b>
<i>1899</i>&nbsp; * &lt;p&gt; The maximum number of arguments is limited by the maximum dimension of a
<i>1900</i>&nbsp; * Java array as defined by
<i>1901</i>&nbsp; * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
<i>1902</i>&nbsp; * If the argument index does not correspond to an
<i>1903</i>&nbsp; * available argument, then a {@link MissingFormatArgumentException} is thrown.
<i>1904</i>&nbsp; *
<i>1905</i>&nbsp; * &lt;p&gt; If there are more arguments than format specifiers, the extra arguments
<i>1906</i>&nbsp; * are ignored.
<i>1907</i>&nbsp; *
<i>1908</i>&nbsp; * &lt;p&gt; Unless otherwise specified, passing a {@code null} argument to any
<i>1909</i>&nbsp; * method or constructor in this class will cause a {@link
<i>1910</i>&nbsp; * NullPointerException} to be thrown.
<i>1911</i>&nbsp; *
<i>1912</i>&nbsp; * @author  Iris Clark
<i>1913</i>&nbsp; * @since 1.5
<b class="nc"><i>1914</i>&nbsp; */</b>
<i>1915</i>&nbsp;public final class Formatter implements Closeable, Flushable {
<i>1916</i>&nbsp;    private Appendable a;
<i>1917</i>&nbsp;    private final Locale l;
<i>1918</i>&nbsp;
<i>1919</i>&nbsp;    private IOException lastException;
<i>1920</i>&nbsp;
<i>1921</i>&nbsp;    private final char zero;
<i>1922</i>&nbsp;    private static double scaleUp;
<i>1923</i>&nbsp;
<i>1924</i>&nbsp;    // 1 (sign) + 19 (max # sig digits) + 1 (&#39;.&#39;) + 1 (&#39;e&#39;) + 1 (sign)
<i>1925</i>&nbsp;    // + 3 (max # exp digits) + 4 (error) = 30
<i>1926</i>&nbsp;    private static final int MAX_FD_CHARS = 30;
<i>1927</i>&nbsp;
<i>1928</i>&nbsp;    /**
<i>1929</i>&nbsp;     * Returns a charset object for the given charset name.
<b class="nc"><i>1930</i>&nbsp;     * @throws NullPointerException          is csn is null</b>
<i>1931</i>&nbsp;     * @throws UnsupportedEncodingException  if the charset is not supported
<i>1932</i>&nbsp;     */
<i>1933</i>&nbsp;    private static Charset toCharset(String csn)
<i>1934</i>&nbsp;        throws UnsupportedEncodingException
<i>1935</i>&nbsp;    {
<i>1936</i>&nbsp;        Objects.requireNonNull(csn, &quot;charsetName&quot;);
<i>1937</i>&nbsp;        try {
<i>1938</i>&nbsp;            return Charset.forName(csn);
<i>1939</i>&nbsp;        } catch (IllegalCharsetNameException|UnsupportedCharsetException unused) {
<i>1940</i>&nbsp;            // UnsupportedEncodingException should be thrown
<i>1941</i>&nbsp;            throw new UnsupportedEncodingException(csn);
<i>1942</i>&nbsp;        }
<i>1943</i>&nbsp;    }
<i>1944</i>&nbsp;
<i>1945</i>&nbsp;    private static final Appendable nonNullAppendable(Appendable a) {
<i>1946</i>&nbsp;        if (a == null)
<b class="nc"><i>1947</i>&nbsp;            return new StringBuilder();</b>
<i>1948</i>&nbsp;
<i>1949</i>&nbsp;        return a;
<i>1950</i>&nbsp;    }
<i>1951</i>&nbsp;
<i>1952</i>&nbsp;    /* Private constructors */
<i>1953</i>&nbsp;    private Formatter(Locale l, Appendable a) {
<i>1954</i>&nbsp;        this.a = a;
<i>1955</i>&nbsp;        this.l = l;
<i>1956</i>&nbsp;        this.zero = getZero(l);
<i>1957</i>&nbsp;    }
<i>1958</i>&nbsp;
<i>1959</i>&nbsp;    private Formatter(Charset charset, Locale l, File file)
<i>1960</i>&nbsp;        throws FileNotFoundException
<i>1961</i>&nbsp;    {
<i>1962</i>&nbsp;        this(l,
<b class="nc"><i>1963</i>&nbsp;             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset)));</b>
<i>1964</i>&nbsp;    }
<i>1965</i>&nbsp;
<i>1966</i>&nbsp;    /**
<i>1967</i>&nbsp;     * Constructs a new formatter.
<i>1968</i>&nbsp;     *
<i>1969</i>&nbsp;     * &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}
<i>1970</i>&nbsp;     * which may be retrieved by invoking {@link #out out()} and whose
<i>1971</i>&nbsp;     * current content may be converted into a string by invoking {@link
<i>1972</i>&nbsp;     * #toString toString()}.  The locale used is the {@linkplain
<i>1973</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>1974</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>1975</i>&nbsp;     * virtual machine.
<i>1976</i>&nbsp;     */
<i>1977</i>&nbsp;    public Formatter() {
<i>1978</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT), new StringBuilder());
<i>1979</i>&nbsp;    }
<i>1980</i>&nbsp;
<i>1981</i>&nbsp;    /**
<i>1982</i>&nbsp;     * Constructs a new formatter with the specified destination.
<i>1983</i>&nbsp;     *
<i>1984</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>1985</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>1986</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>1987</i>&nbsp;     * virtual machine.
<i>1988</i>&nbsp;     *
<i>1989</i>&nbsp;     * @param  a
<i>1990</i>&nbsp;     *         Destination for the formatted output.  If {@code a} is
<i>1991</i>&nbsp;     *         {@code null} then a {@link StringBuilder} will be created.
<i>1992</i>&nbsp;     */
<i>1993</i>&nbsp;    public Formatter(Appendable a) {
<i>1994</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT), nonNullAppendable(a));
<i>1995</i>&nbsp;    }
<b class="nc"><i>1996</i>&nbsp;</b>
<i>1997</i>&nbsp;    /**
<i>1998</i>&nbsp;     * Constructs a new formatter with the specified locale.
<i>1999</i>&nbsp;     *
<i>2000</i>&nbsp;     * &lt;p&gt; The destination of the formatted output is a {@link StringBuilder}
<i>2001</i>&nbsp;     * which may be retrieved by invoking {@link #out out()} and whose current
<i>2002</i>&nbsp;     * content may be converted into a string by invoking {@link #toString
<i>2003</i>&nbsp;     * toString()}.
<i>2004</i>&nbsp;     *
<i>2005</i>&nbsp;     * @param  l
<i>2006</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2007</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2008</i>&nbsp;     *         is applied.
<i>2009</i>&nbsp;     */
<i>2010</i>&nbsp;    public Formatter(Locale l) {
<i>2011</i>&nbsp;        this(l, new StringBuilder());
<i>2012</i>&nbsp;    }
<i>2013</i>&nbsp;
<i>2014</i>&nbsp;    /**
<i>2015</i>&nbsp;     * Constructs a new formatter with the specified destination and locale.
<i>2016</i>&nbsp;     *
<i>2017</i>&nbsp;     * @param  a
<i>2018</i>&nbsp;     *         Destination for the formatted output.  If {@code a} is
<i>2019</i>&nbsp;     *         {@code null} then a {@link StringBuilder} will be created.
<i>2020</i>&nbsp;     *
<i>2021</i>&nbsp;     * @param  l
<i>2022</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2023</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2024</i>&nbsp;     *         is applied.
<i>2025</i>&nbsp;     */
<i>2026</i>&nbsp;    public Formatter(Appendable a, Locale l) {
<i>2027</i>&nbsp;        this(l, nonNullAppendable(a));
<i>2028</i>&nbsp;    }
<i>2029</i>&nbsp;
<i>2030</i>&nbsp;    /**
<i>2031</i>&nbsp;     * Constructs a new formatter with the specified file name.
<i>2032</i>&nbsp;     *
<i>2033</i>&nbsp;     * &lt;p&gt; The charset used is the {@linkplain
<i>2034</i>&nbsp;     * java.nio.charset.Charset#defaultCharset() default charset} for this
<b class="nc"><i>2035</i>&nbsp;     * instance of the Java virtual machine.</b>
<i>2036</i>&nbsp;     *
<i>2037</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2038</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2039</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2040</i>&nbsp;     * virtual machine.
<i>2041</i>&nbsp;     *
<i>2042</i>&nbsp;     * @param  fileName
<i>2043</i>&nbsp;     *         The name of the file to use as the destination of this
<i>2044</i>&nbsp;     *         formatter.  If the file exists then it will be truncated to
<i>2045</i>&nbsp;     *         zero size; otherwise, a new file will be created.  The output
<i>2046</i>&nbsp;     *         will be written to the file and is buffered.
<i>2047</i>&nbsp;     *
<i>2048</i>&nbsp;     * @throws  SecurityException
<i>2049</i>&nbsp;     *          If a security manager is present and {@link
<i>2050</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
<i>2051</i>&nbsp;     *          access to the file
<i>2052</i>&nbsp;     *
<i>2053</i>&nbsp;     * @throws  FileNotFoundException
<i>2054</i>&nbsp;     *          If the given file name does not denote an existing, writable
<i>2055</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2056</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2057</i>&nbsp;     *          creating the file
<i>2058</i>&nbsp;     */
<i>2059</i>&nbsp;    public Formatter(String fileName) throws FileNotFoundException {
<i>2060</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT),
<i>2061</i>&nbsp;             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName))));
<i>2062</i>&nbsp;    }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;    /**
<i>2065</i>&nbsp;     * Constructs a new formatter with the specified file name and charset.
<i>2066</i>&nbsp;     *
<i>2067</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2068</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2069</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2070</i>&nbsp;     * virtual machine.
<i>2071</i>&nbsp;     *
<i>2072</i>&nbsp;     * @param  fileName
<i>2073</i>&nbsp;     *         The name of the file to use as the destination of this
<b class="nc"><i>2074</i>&nbsp;     *         formatter.  If the file exists then it will be truncated to</b>
<i>2075</i>&nbsp;     *         zero size; otherwise, a new file will be created.  The output
<i>2076</i>&nbsp;     *         will be written to the file and is buffered.
<i>2077</i>&nbsp;     *
<i>2078</i>&nbsp;     * @param  csn
<i>2079</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset
<i>2080</i>&nbsp;     *         charset}
<i>2081</i>&nbsp;     *
<i>2082</i>&nbsp;     * @throws  FileNotFoundException
<i>2083</i>&nbsp;     *          If the given file name does not denote an existing, writable
<i>2084</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2085</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2086</i>&nbsp;     *          creating the file
<i>2087</i>&nbsp;     *
<i>2088</i>&nbsp;     * @throws  SecurityException
<i>2089</i>&nbsp;     *          If a security manager is present and {@link
<i>2090</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
<i>2091</i>&nbsp;     *          access to the file
<i>2092</i>&nbsp;     *
<i>2093</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2094</i>&nbsp;     *          If the named charset is not supported
<i>2095</i>&nbsp;     */
<i>2096</i>&nbsp;    public Formatter(String fileName, String csn)
<i>2097</i>&nbsp;        throws FileNotFoundException, UnsupportedEncodingException
<i>2098</i>&nbsp;    {
<i>2099</i>&nbsp;        this(fileName, csn, Locale.getDefault(Locale.Category.FORMAT));
<i>2100</i>&nbsp;    }
<i>2101</i>&nbsp;
<i>2102</i>&nbsp;    /**
<i>2103</i>&nbsp;     * Constructs a new formatter with the specified file name, charset, and
<i>2104</i>&nbsp;     * locale.
<i>2105</i>&nbsp;     *
<i>2106</i>&nbsp;     * @param  fileName
<b class="nc"><i>2107</i>&nbsp;     *         The name of the file to use as the destination of this</b>
<i>2108</i>&nbsp;     *         formatter.  If the file exists then it will be truncated to
<i>2109</i>&nbsp;     *         zero size; otherwise, a new file will be created.  The output
<i>2110</i>&nbsp;     *         will be written to the file and is buffered.
<i>2111</i>&nbsp;     *
<i>2112</i>&nbsp;     * @param  csn
<i>2113</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset
<i>2114</i>&nbsp;     *         charset}
<i>2115</i>&nbsp;     *
<i>2116</i>&nbsp;     * @param  l
<i>2117</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2118</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2119</i>&nbsp;     *         is applied.
<i>2120</i>&nbsp;     *
<i>2121</i>&nbsp;     * @throws  FileNotFoundException
<i>2122</i>&nbsp;     *          If the given file name does not denote an existing, writable
<i>2123</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2124</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2125</i>&nbsp;     *          creating the file
<i>2126</i>&nbsp;     *
<i>2127</i>&nbsp;     * @throws  SecurityException
<i>2128</i>&nbsp;     *          If a security manager is present and {@link
<i>2129</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
<i>2130</i>&nbsp;     *          access to the file
<i>2131</i>&nbsp;     *
<i>2132</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2133</i>&nbsp;     *          If the named charset is not supported
<i>2134</i>&nbsp;     */
<i>2135</i>&nbsp;    public Formatter(String fileName, String csn, Locale l)
<i>2136</i>&nbsp;        throws FileNotFoundException, UnsupportedEncodingException
<i>2137</i>&nbsp;    {
<i>2138</i>&nbsp;        this(toCharset(csn), l, new File(fileName));
<i>2139</i>&nbsp;    }
<i>2140</i>&nbsp;
<i>2141</i>&nbsp;    /**
<i>2142</i>&nbsp;     * Constructs a new formatter with the specified file name, charset, and
<i>2143</i>&nbsp;     * locale.
<i>2144</i>&nbsp;     *
<i>2145</i>&nbsp;     * @param  fileName
<b class="nc"><i>2146</i>&nbsp;     *         The name of the file to use as the destination of this</b>
<i>2147</i>&nbsp;     *         formatter.  If the file exists then it will be truncated to
<i>2148</i>&nbsp;     *         zero size; otherwise, a new file will be created.  The output
<i>2149</i>&nbsp;     *         will be written to the file and is buffered.
<i>2150</i>&nbsp;     *
<i>2151</i>&nbsp;     * @param  charset
<i>2152</i>&nbsp;     *         A {@linkplain java.nio.charset.Charset charset}
<i>2153</i>&nbsp;     *
<i>2154</i>&nbsp;     * @param  l
<i>2155</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2156</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2157</i>&nbsp;     *         is applied.
<i>2158</i>&nbsp;     *
<i>2159</i>&nbsp;     * @throws  IOException
<i>2160</i>&nbsp;     *          if an I/O error occurs while opening or creating the file
<i>2161</i>&nbsp;     *
<i>2162</i>&nbsp;     * @throws  SecurityException
<i>2163</i>&nbsp;     *          If a security manager is present and {@link
<i>2164</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(fileName)} denies write
<i>2165</i>&nbsp;     *          access to the file
<i>2166</i>&nbsp;     *
<i>2167</i>&nbsp;     * @throws NullPointerException
<i>2168</i>&nbsp;     *         if {@code fileName} or {@code charset} is {@code null}.
<i>2169</i>&nbsp;     */
<i>2170</i>&nbsp;    public Formatter(String fileName, Charset charset, Locale l) throws IOException {
<i>2171</i>&nbsp;        this(Objects.requireNonNull(charset, &quot;charset&quot;), l, new File(fileName));
<i>2172</i>&nbsp;    }
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;    /**
<i>2175</i>&nbsp;     * Constructs a new formatter with the specified file.
<i>2176</i>&nbsp;     *
<i>2177</i>&nbsp;     * &lt;p&gt; The charset used is the {@linkplain
<i>2178</i>&nbsp;     * java.nio.charset.Charset#defaultCharset() default charset} for this
<i>2179</i>&nbsp;     * instance of the Java virtual machine.
<i>2180</i>&nbsp;     *
<i>2181</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2182</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2183</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2184</i>&nbsp;     * virtual machine.
<b class="nc"><i>2185</i>&nbsp;     *</b>
<i>2186</i>&nbsp;     * @param  file
<i>2187</i>&nbsp;     *         The file to use as the destination of this formatter.  If the
<i>2188</i>&nbsp;     *         file exists then it will be truncated to zero size; otherwise,
<i>2189</i>&nbsp;     *         a new file will be created.  The output will be written to the
<i>2190</i>&nbsp;     *         file and is buffered.
<i>2191</i>&nbsp;     *
<i>2192</i>&nbsp;     * @throws  SecurityException
<i>2193</i>&nbsp;     *          If a security manager is present and {@link
<i>2194</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
<i>2195</i>&nbsp;     *          write access to the file
<i>2196</i>&nbsp;     *
<i>2197</i>&nbsp;     * @throws  FileNotFoundException
<i>2198</i>&nbsp;     *          If the given file object does not denote an existing, writable
<i>2199</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2200</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2201</i>&nbsp;     *          creating the file
<i>2202</i>&nbsp;     */
<i>2203</i>&nbsp;    public Formatter(File file) throws FileNotFoundException {
<b class="nc"><i>2204</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT),</b>
<b class="nc"><i>2205</i>&nbsp;             new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file))));</b>
<i>2206</i>&nbsp;    }
<i>2207</i>&nbsp;
<i>2208</i>&nbsp;    /**
<i>2209</i>&nbsp;     * Constructs a new formatter with the specified file and charset.
<i>2210</i>&nbsp;     *
<i>2211</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2212</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2213</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2214</i>&nbsp;     * virtual machine.
<i>2215</i>&nbsp;     *
<i>2216</i>&nbsp;     * @param  file
<i>2217</i>&nbsp;     *         The file to use as the destination of this formatter.  If the
<i>2218</i>&nbsp;     *         file exists then it will be truncated to zero size; otherwise,
<i>2219</i>&nbsp;     *         a new file will be created.  The output will be written to the
<i>2220</i>&nbsp;     *         file and is buffered.
<i>2221</i>&nbsp;     *
<i>2222</i>&nbsp;     * @param  csn
<i>2223</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset
<i>2224</i>&nbsp;     *         charset}
<b class="nc"><i>2225</i>&nbsp;     *</b>
<i>2226</i>&nbsp;     * @throws  FileNotFoundException
<i>2227</i>&nbsp;     *          If the given file object does not denote an existing, writable
<i>2228</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2229</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2230</i>&nbsp;     *          creating the file
<i>2231</i>&nbsp;     *
<i>2232</i>&nbsp;     * @throws  SecurityException
<i>2233</i>&nbsp;     *          If a security manager is present and {@link
<i>2234</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
<i>2235</i>&nbsp;     *          write access to the file
<i>2236</i>&nbsp;     *
<i>2237</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2238</i>&nbsp;     *          If the named charset is not supported
<i>2239</i>&nbsp;     */
<i>2240</i>&nbsp;    public Formatter(File file, String csn)
<i>2241</i>&nbsp;        throws FileNotFoundException, UnsupportedEncodingException
<i>2242</i>&nbsp;    {
<i>2243</i>&nbsp;        this(file, csn, Locale.getDefault(Locale.Category.FORMAT));
<i>2244</i>&nbsp;    }
<i>2245</i>&nbsp;
<i>2246</i>&nbsp;    /**
<i>2247</i>&nbsp;     * Constructs a new formatter with the specified file, charset, and
<i>2248</i>&nbsp;     * locale.
<i>2249</i>&nbsp;     *
<i>2250</i>&nbsp;     * @param  file
<i>2251</i>&nbsp;     *         The file to use as the destination of this formatter.  If the
<b class="nc"><i>2252</i>&nbsp;     *         file exists then it will be truncated to zero size; otherwise,</b>
<i>2253</i>&nbsp;     *         a new file will be created.  The output will be written to the
<i>2254</i>&nbsp;     *         file and is buffered.
<i>2255</i>&nbsp;     *
<i>2256</i>&nbsp;     * @param  csn
<i>2257</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset
<i>2258</i>&nbsp;     *         charset}
<i>2259</i>&nbsp;     *
<i>2260</i>&nbsp;     * @param  l
<i>2261</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2262</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2263</i>&nbsp;     *         is applied.
<i>2264</i>&nbsp;     *
<i>2265</i>&nbsp;     * @throws  FileNotFoundException
<i>2266</i>&nbsp;     *          If the given file object does not denote an existing, writable
<i>2267</i>&nbsp;     *          regular file and a new regular file of that name cannot be
<i>2268</i>&nbsp;     *          created, or if some other error occurs while opening or
<i>2269</i>&nbsp;     *          creating the file
<i>2270</i>&nbsp;     *
<i>2271</i>&nbsp;     * @throws  SecurityException
<i>2272</i>&nbsp;     *          If a security manager is present and {@link
<i>2273</i>&nbsp;     *          SecurityManager#checkWrite checkWrite(file.getPath())} denies
<i>2274</i>&nbsp;     *          write access to the file
<i>2275</i>&nbsp;     *
<i>2276</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2277</i>&nbsp;     *          If the named charset is not supported
<b class="nc"><i>2278</i>&nbsp;     */</b>
<i>2279</i>&nbsp;    public Formatter(File file, String csn, Locale l)
<i>2280</i>&nbsp;        throws FileNotFoundException, UnsupportedEncodingException
<i>2281</i>&nbsp;    {
<b class="nc"><i>2282</i>&nbsp;        this(toCharset(csn), l, file);</b>
<b class="nc"><i>2283</i>&nbsp;    }</b>
<b class="nc"><i>2284</i>&nbsp;</b>
<i>2285</i>&nbsp;    /**
<b class="nc"><i>2286</i>&nbsp;     * Constructs a new formatter with the specified file, charset, and</b>
<i>2287</i>&nbsp;     * locale.
<i>2288</i>&nbsp;     *
<i>2289</i>&nbsp;     * @param  file
<i>2290</i>&nbsp;     *         The file to use as the destination of this formatter.  If the
<i>2291</i>&nbsp;     *         file exists then it will be truncated to zero size; otherwise,
<i>2292</i>&nbsp;     *         a new file will be created.  The output will be written to the
<i>2293</i>&nbsp;     *         file and is buffered.
<i>2294</i>&nbsp;     *
<i>2295</i>&nbsp;     * @param  charset
<i>2296</i>&nbsp;     *         A {@linkplain java.nio.charset.Charset charset}
<i>2297</i>&nbsp;     *
<i>2298</i>&nbsp;     * @param  l
<i>2299</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2300</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2301</i>&nbsp;     *         is applied.
<i>2302</i>&nbsp;     *
<i>2303</i>&nbsp;     * @throws IOException
<b class="nc"><i>2304</i>&nbsp;     *         if an I/O error occurs while opening or creating the file</b>
<b class="nc"><i>2305</i>&nbsp;     *</b>
<i>2306</i>&nbsp;     * @throws SecurityException
<i>2307</i>&nbsp;     *         If a security manager is present and {@link
<i>2308</i>&nbsp;     *         SecurityManager#checkWrite checkWrite(file.getPath())} denies
<i>2309</i>&nbsp;     *         write access to the file
<i>2310</i>&nbsp;     *
<i>2311</i>&nbsp;     * @throws NullPointerException
<i>2312</i>&nbsp;     *         if {@code file} or {@code charset} is {@code null}.
<i>2313</i>&nbsp;     */
<i>2314</i>&nbsp;    public Formatter(File file, Charset charset, Locale l) throws IOException {
<i>2315</i>&nbsp;        this(Objects.requireNonNull(charset, &quot;charset&quot;), l, file);
<i>2316</i>&nbsp;    }
<i>2317</i>&nbsp;
<b class="nc"><i>2318</i>&nbsp;</b>
<b class="nc"><i>2319</i>&nbsp;    /**</b>
<i>2320</i>&nbsp;     * Constructs a new formatter with the specified print stream.
<i>2321</i>&nbsp;     *
<i>2322</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2323</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2324</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2325</i>&nbsp;     * virtual machine.
<i>2326</i>&nbsp;     *
<i>2327</i>&nbsp;     * &lt;p&gt; Characters are written to the given {@link java.io.PrintStream
<i>2328</i>&nbsp;     * PrintStream} object and are therefore encoded using that object&#39;s
<i>2329</i>&nbsp;     * charset.
<i>2330</i>&nbsp;     *
<i>2331</i>&nbsp;     * @param  ps
<i>2332</i>&nbsp;     *         The stream to use as the destination of this formatter.
<i>2333</i>&nbsp;     */
<i>2334</i>&nbsp;    public Formatter(PrintStream ps) {
<i>2335</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT),
<i>2336</i>&nbsp;             (Appendable)Objects.requireNonNull(ps));
<i>2337</i>&nbsp;    }
<i>2338</i>&nbsp;
<i>2339</i>&nbsp;    /**
<i>2340</i>&nbsp;     * Constructs a new formatter with the specified output stream.
<i>2341</i>&nbsp;     *
<i>2342</i>&nbsp;     * &lt;p&gt; The charset used is the {@linkplain
<i>2343</i>&nbsp;     * java.nio.charset.Charset#defaultCharset() default charset} for this
<i>2344</i>&nbsp;     * instance of the Java virtual machine.
<i>2345</i>&nbsp;     *
<i>2346</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2347</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2348</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2349</i>&nbsp;     * virtual machine.
<i>2350</i>&nbsp;     *
<i>2351</i>&nbsp;     * @param  os
<i>2352</i>&nbsp;     *         The output stream to use as the destination of this formatter.
<i>2353</i>&nbsp;     *         The output will be buffered.
<b class="nc"><i>2354</i>&nbsp;     */</b>
<b class="nc"><i>2355</i>&nbsp;    public Formatter(OutputStream os) {</b>
<i>2356</i>&nbsp;        this(Locale.getDefault(Locale.Category.FORMAT),
<i>2357</i>&nbsp;             new BufferedWriter(new OutputStreamWriter(os)));
<i>2358</i>&nbsp;    }
<i>2359</i>&nbsp;
<i>2360</i>&nbsp;    /**
<i>2361</i>&nbsp;     * Constructs a new formatter with the specified output stream and
<i>2362</i>&nbsp;     * charset.
<i>2363</i>&nbsp;     *
<i>2364</i>&nbsp;     * &lt;p&gt; The locale used is the {@linkplain
<i>2365</i>&nbsp;     * Locale#getDefault(Locale.Category) default locale} for
<i>2366</i>&nbsp;     * {@linkplain Locale.Category#FORMAT formatting} for this instance of the Java
<i>2367</i>&nbsp;     * virtual machine.
<i>2368</i>&nbsp;     *
<i>2369</i>&nbsp;     * @param  os
<b class="nc"><i>2370</i>&nbsp;     *         The output stream to use as the destination of this formatter.</b>
<b class="nc"><i>2371</i>&nbsp;     *         The output will be buffered.</b>
<i>2372</i>&nbsp;     *
<b class="nc"><i>2373</i>&nbsp;     * @param  csn</b>
<b class="nc"><i>2374</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset</b>
<b class="nc"><i>2375</i>&nbsp;     *         charset}</b>
<b class="nc"><i>2376</i>&nbsp;     *</b>
<i>2377</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2378</i>&nbsp;     *          If the named charset is not supported
<i>2379</i>&nbsp;     */
<i>2380</i>&nbsp;    public Formatter(OutputStream os, String csn)
<i>2381</i>&nbsp;        throws UnsupportedEncodingException
<i>2382</i>&nbsp;    {
<i>2383</i>&nbsp;        this(os, csn, Locale.getDefault(Locale.Category.FORMAT));
<i>2384</i>&nbsp;    }
<i>2385</i>&nbsp;
<i>2386</i>&nbsp;    /**
<i>2387</i>&nbsp;     * Constructs a new formatter with the specified output stream, charset,
<i>2388</i>&nbsp;     * and locale.
<i>2389</i>&nbsp;     *
<i>2390</i>&nbsp;     * @param  os
<i>2391</i>&nbsp;     *         The output stream to use as the destination of this formatter.
<i>2392</i>&nbsp;     *         The output will be buffered.
<b class="nc"><i>2393</i>&nbsp;     *</b>
<i>2394</i>&nbsp;     * @param  csn
<i>2395</i>&nbsp;     *         The name of a supported {@linkplain java.nio.charset.Charset
<b class="nc"><i>2396</i>&nbsp;     *         charset}</b>
<b class="nc"><i>2397</i>&nbsp;     *</b>
<b class="nc"><i>2398</i>&nbsp;     * @param  l</b>
<b class="nc"><i>2399</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during</b>
<i>2400</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<b class="nc"><i>2401</i>&nbsp;     *         is applied.</b>
<b class="nc"><i>2402</i>&nbsp;     *</b>
<i>2403</i>&nbsp;     * @throws  UnsupportedEncodingException
<i>2404</i>&nbsp;     *          If the named charset is not supported
<i>2405</i>&nbsp;     */
<b class="nc"><i>2406</i>&nbsp;    public Formatter(OutputStream os, String csn, Locale l)</b>
<b class="nc"><i>2407</i>&nbsp;        throws UnsupportedEncodingException</b>
<i>2408</i>&nbsp;    {
<i>2409</i>&nbsp;        this(l, new BufferedWriter(new OutputStreamWriter(os, csn)));
<i>2410</i>&nbsp;    }
<i>2411</i>&nbsp;
<i>2412</i>&nbsp;    /**
<i>2413</i>&nbsp;     * Constructs a new formatter with the specified output stream, charset,
<i>2414</i>&nbsp;     * and locale.
<i>2415</i>&nbsp;     *
<i>2416</i>&nbsp;     * @param  os
<i>2417</i>&nbsp;     *         The output stream to use as the destination of this formatter.
<i>2418</i>&nbsp;     *         The output will be buffered.
<i>2419</i>&nbsp;     *
<i>2420</i>&nbsp;     * @param  charset
<b class="nc"><i>2421</i>&nbsp;     *         A {@linkplain java.nio.charset.Charset charset}</b>
<i>2422</i>&nbsp;     *
<i>2423</i>&nbsp;     * @param  l
<i>2424</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2425</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<i>2426</i>&nbsp;     *         is applied.
<i>2427</i>&nbsp;     *
<i>2428</i>&nbsp;     * @throws NullPointerException
<i>2429</i>&nbsp;     *         if {@code os} or {@code charset} is {@code null}.
<i>2430</i>&nbsp;     */
<i>2431</i>&nbsp;    public Formatter(OutputStream os, Charset charset, Locale l) {
<i>2432</i>&nbsp;        this(l, new BufferedWriter(new OutputStreamWriter(os, charset)));
<i>2433</i>&nbsp;    }
<i>2434</i>&nbsp;
<i>2435</i>&nbsp;    private static char getZero(Locale l) {
<i>2436</i>&nbsp;        if ((l != null) &amp;&amp; !l.equals(Locale.US)) {
<i>2437</i>&nbsp;            DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);
<i>2438</i>&nbsp;            return dfs.getZeroDigit();
<i>2439</i>&nbsp;        } else {
<i>2440</i>&nbsp;            return &#39;0&#39;;
<i>2441</i>&nbsp;        }
<i>2442</i>&nbsp;    }
<i>2443</i>&nbsp;
<i>2444</i>&nbsp;    /**
<i>2445</i>&nbsp;     * Returns the locale set by the construction of this formatter.
<i>2446</i>&nbsp;     *
<i>2447</i>&nbsp;     * &lt;p&gt; The {@link #format(java.util.Locale,String,Object...) format} method
<i>2448</i>&nbsp;     * for this object which has a locale argument does not change this value.
<i>2449</i>&nbsp;     *
<i>2450</i>&nbsp;     * @return  {@code null} if no localization is applied, otherwise a
<i>2451</i>&nbsp;     *          locale
<i>2452</i>&nbsp;     *
<i>2453</i>&nbsp;     * @throws  FormatterClosedException
<i>2454</i>&nbsp;     *          If this formatter has been closed by invoking its {@link
<b class="nc"><i>2455</i>&nbsp;     *          #close()} method</b>
<i>2456</i>&nbsp;     */
<i>2457</i>&nbsp;    public Locale locale() {
<i>2458</i>&nbsp;        ensureOpen();
<i>2459</i>&nbsp;        return l;
<i>2460</i>&nbsp;    }
<i>2461</i>&nbsp;
<i>2462</i>&nbsp;    /**
<i>2463</i>&nbsp;     * Returns the destination for the output.
<i>2464</i>&nbsp;     *
<i>2465</i>&nbsp;     * @return  The destination for the output
<i>2466</i>&nbsp;     *
<i>2467</i>&nbsp;     * @throws  FormatterClosedException
<i>2468</i>&nbsp;     *          If this formatter has been closed by invoking its {@link
<i>2469</i>&nbsp;     *          #close()} method
<i>2470</i>&nbsp;     */
<i>2471</i>&nbsp;    public Appendable out() {
<i>2472</i>&nbsp;        ensureOpen();
<i>2473</i>&nbsp;        return a;
<i>2474</i>&nbsp;    }
<i>2475</i>&nbsp;
<i>2476</i>&nbsp;    /**
<i>2477</i>&nbsp;     * Returns the result of invoking {@code toString()} on the destination
<i>2478</i>&nbsp;     * for the output.  For example, the following code formats text into a
<i>2479</i>&nbsp;     * {@link StringBuilder} then retrieves the resultant string:
<i>2480</i>&nbsp;     *
<i>2481</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>2482</i>&nbsp;     *   Formatter f = new Formatter();
<i>2483</i>&nbsp;     *   f.format(&quot;Last reboot at %tc&quot;, lastRebootDate);
<i>2484</i>&nbsp;     *   String s = f.toString();
<i>2485</i>&nbsp;     *   // -&amp;gt; s == &quot;Last reboot at Sat Jan 01 00:00:00 PST 2000&quot;
<i>2486</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>2487</i>&nbsp;     *
<i>2488</i>&nbsp;     * &lt;p&gt; An invocation of this method behaves in exactly the same way as the
<i>2489</i>&nbsp;     * invocation
<i>2490</i>&nbsp;     *
<i>2491</i>&nbsp;     * &lt;pre&gt;
<i>2492</i>&nbsp;     *     out().toString() &lt;/pre&gt;
<i>2493</i>&nbsp;     *
<b class="nc"><i>2494</i>&nbsp;     * &lt;p&gt; Depending on the specification of {@code toString} for the {@link</b>
<i>2495</i>&nbsp;     * Appendable}, the returned string may or may not contain the characters
<i>2496</i>&nbsp;     * written to the destination.  For instance, buffers typically return
<b class="nc"><i>2497</i>&nbsp;     * their contents in {@code toString()}, but streams cannot since the</b>
<i>2498</i>&nbsp;     * data is discarded.
<b class="nc"><i>2499</i>&nbsp;     *</b>
<i>2500</i>&nbsp;     * @return  The result of invoking {@code toString()} on the destination
<b class="nc"><i>2501</i>&nbsp;     *          for the output</b>
<b class="nc"><i>2502</i>&nbsp;     *</b>
<b class="nc"><i>2503</i>&nbsp;     * @throws  FormatterClosedException</b>
<b class="nc"><i>2504</i>&nbsp;     *          If this formatter has been closed by invoking its {@link</b>
<i>2505</i>&nbsp;     *          #close()} method
<b class="nc"><i>2506</i>&nbsp;     */</b>
<i>2507</i>&nbsp;    public String toString() {
<b class="nc"><i>2508</i>&nbsp;        ensureOpen();</b>
<b class="nc"><i>2509</i>&nbsp;        return a.toString();</b>
<i>2510</i>&nbsp;    }
<b class="nc"><i>2511</i>&nbsp;</b>
<b class="nc"><i>2512</i>&nbsp;    /**</b>
<b class="nc"><i>2513</i>&nbsp;     * Flushes this formatter.  If the destination implements the {@link</b>
<b class="nc"><i>2514</i>&nbsp;     * java.io.Flushable} interface, its {@code flush} method will be invoked.</b>
<i>2515</i>&nbsp;     *
<b class="nc"><i>2516</i>&nbsp;     * &lt;p&gt; Flushing a formatter writes any buffered output in the destination</b>
<b class="nc"><i>2517</i>&nbsp;     * to the underlying stream.</b>
<b class="nc"><i>2518</i>&nbsp;     *</b>
<b class="nc"><i>2519</i>&nbsp;     * @throws  FormatterClosedException</b>
<b class="nc"><i>2520</i>&nbsp;     *          If this formatter has been closed by invoking its {@link</b>
<b class="nc"><i>2521</i>&nbsp;     *          #close()} method</b>
<i>2522</i>&nbsp;     */
<b class="nc"><i>2523</i>&nbsp;    public void flush() {</b>
<b class="nc"><i>2524</i>&nbsp;        ensureOpen();</b>
<b class="nc"><i>2525</i>&nbsp;        if (a instanceof Flushable) {</b>
<b class="nc"><i>2526</i>&nbsp;            try {</b>
<i>2527</i>&nbsp;                ((Flushable)a).flush();
<i>2528</i>&nbsp;            } catch (IOException ioe) {
<b class="nc"><i>2529</i>&nbsp;                lastException = ioe;</b>
<b class="nc"><i>2530</i>&nbsp;            }</b>
<b class="nc"><i>2531</i>&nbsp;        }</b>
<i>2532</i>&nbsp;    }
<b class="nc"><i>2533</i>&nbsp;</b>
<i>2534</i>&nbsp;    /**
<i>2535</i>&nbsp;     * Closes this formatter.  If the destination implements the {@link
<i>2536</i>&nbsp;     * java.io.Closeable} interface, its {@code close} method will be invoked.
<i>2537</i>&nbsp;     *
<i>2538</i>&nbsp;     * &lt;p&gt; Closing a formatter allows it to release resources it may be holding
<i>2539</i>&nbsp;     * (such as open files).  If the formatter is already closed, then invoking
<b class="nc"><i>2540</i>&nbsp;     * this method has no effect.</b>
<i>2541</i>&nbsp;     *
<i>2542</i>&nbsp;     * &lt;p&gt; Attempting to invoke any methods except {@link #ioException()} in
<i>2543</i>&nbsp;     * this formatter after it has been closed will result in a {@link
<i>2544</i>&nbsp;     * FormatterClosedException}.
<i>2545</i>&nbsp;     */
<b class="nc"><i>2546</i>&nbsp;    public void close() {</b>
<b class="nc"><i>2547</i>&nbsp;        if (a == null)</b>
<b class="nc"><i>2548</i>&nbsp;            return;</b>
<b class="nc"><i>2549</i>&nbsp;        try {</b>
<i>2550</i>&nbsp;            if (a instanceof Closeable)
<i>2551</i>&nbsp;                ((Closeable)a).close();
<i>2552</i>&nbsp;        } catch (IOException ioe) {
<b class="nc"><i>2553</i>&nbsp;            lastException = ioe;</b>
<i>2554</i>&nbsp;        } finally {
<b class="nc"><i>2555</i>&nbsp;            a = null;</b>
<i>2556</i>&nbsp;        }
<b class="nc"><i>2557</i>&nbsp;    }</b>
<i>2558</i>&nbsp;
<i>2559</i>&nbsp;    private void ensureOpen() {
<b class="nc"><i>2560</i>&nbsp;        if (a == null)</b>
<b class="nc"><i>2561</i>&nbsp;            throw new FormatterClosedException();</b>
<i>2562</i>&nbsp;    }
<i>2563</i>&nbsp;
<i>2564</i>&nbsp;    /**
<b class="nc"><i>2565</i>&nbsp;     * Returns the {@code IOException} last thrown by this formatter&#39;s {@link</b>
<i>2566</i>&nbsp;     * Appendable}.
<b class="nc"><i>2567</i>&nbsp;     *</b>
<b class="nc"><i>2568</i>&nbsp;     * &lt;p&gt; If the destination&#39;s {@code append()} method never throws</b>
<i>2569</i>&nbsp;     * {@code IOException}, then this method will always return {@code null}.
<i>2570</i>&nbsp;     *
<b class="nc"><i>2571</i>&nbsp;     * @return  The last exception thrown by the Appendable or {@code null} if</b>
<i>2572</i>&nbsp;     *          no such exception exists.
<i>2573</i>&nbsp;     */
<i>2574</i>&nbsp;    public IOException ioException() {
<b class="nc"><i>2575</i>&nbsp;        return lastException;</b>
<i>2576</i>&nbsp;    }
<b class="nc"><i>2577</i>&nbsp;</b>
<b class="nc"><i>2578</i>&nbsp;    /**</b>
<b class="nc"><i>2579</i>&nbsp;     * Writes a formatted string to this object&#39;s destination using the</b>
<i>2580</i>&nbsp;     * specified format string and arguments.  The locale used is the one
<i>2581</i>&nbsp;     * defined during the construction of this formatter.
<i>2582</i>&nbsp;     *
<i>2583</i>&nbsp;     * @param  format
<i>2584</i>&nbsp;     *         A format string as described in &lt;a href=&quot;#syntax&quot;&gt;Format string
<i>2585</i>&nbsp;     *         syntax&lt;/a&gt;.
<i>2586</i>&nbsp;     *
<i>2587</i>&nbsp;     * @param  args
<i>2588</i>&nbsp;     *         Arguments referenced by the format specifiers in the format
<i>2589</i>&nbsp;     *         string.  If there are more arguments than format specifiers, the
<i>2590</i>&nbsp;     *         extra arguments are ignored.  The maximum number of arguments is
<i>2591</i>&nbsp;     *         limited by the maximum dimension of a Java array as defined by
<b class="nc"><i>2592</i>&nbsp;     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</b>
<b class="nc"><i>2593</i>&nbsp;     *</b>
<i>2594</i>&nbsp;     * @throws  IllegalFormatException
<b class="nc"><i>2595</i>&nbsp;     *          If a format string contains an illegal syntax, a format</b>
<b class="nc"><i>2596</i>&nbsp;     *          specifier that is incompatible with the given arguments,</b>
<i>2597</i>&nbsp;     *          insufficient arguments given the format string, or other
<i>2598</i>&nbsp;     *          illegal conditions.  For specification of all possible
<i>2599</i>&nbsp;     *          formatting errors, see the &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;
<i>2600</i>&nbsp;     *          section of the formatter class specification.
<i>2601</i>&nbsp;     *
<b class="nc"><i>2602</i>&nbsp;     * @throws  FormatterClosedException</b>
<i>2603</i>&nbsp;     *          If this formatter has been closed by invoking its {@link
<i>2604</i>&nbsp;     *          #close()} method
<i>2605</i>&nbsp;     *
<b class="nc"><i>2606</i>&nbsp;     * @return  This formatter</b>
<i>2607</i>&nbsp;     */
<i>2608</i>&nbsp;    public Formatter format(String format, Object ... args) {
<i>2609</i>&nbsp;        return format(l, format, args);
<i>2610</i>&nbsp;    }
<b class="nc"><i>2611</i>&nbsp;</b>
<i>2612</i>&nbsp;    /**
<i>2613</i>&nbsp;     * Writes a formatted string to this object&#39;s destination using the
<b class="nc"><i>2614</i>&nbsp;     * specified locale, format string, and arguments.</b>
<b class="nc"><i>2615</i>&nbsp;     *</b>
<b class="nc"><i>2616</i>&nbsp;     * @param  l</b>
<i>2617</i>&nbsp;     *         The {@linkplain java.util.Locale locale} to apply during
<i>2618</i>&nbsp;     *         formatting.  If {@code l} is {@code null} then no localization
<b class="nc"><i>2619</i>&nbsp;     *         is applied.  This does not change this object&#39;s locale that was</b>
<i>2620</i>&nbsp;     *         set during construction.
<i>2621</i>&nbsp;     *
<i>2622</i>&nbsp;     * @param  format
<b class="nc"><i>2623</i>&nbsp;     *         A format string as described in &lt;a href=&quot;#syntax&quot;&gt;Format string</b>
<i>2624</i>&nbsp;     *         syntax&lt;/a&gt;
<b class="nc"><i>2625</i>&nbsp;     *</b>
<b class="nc"><i>2626</i>&nbsp;     * @param  args</b>
<b class="nc"><i>2627</i>&nbsp;     *         Arguments referenced by the format specifiers in the format</b>
<b class="nc"><i>2628</i>&nbsp;     *         string.  If there are more arguments than format specifiers, the</b>
<i>2629</i>&nbsp;     *         extra arguments are ignored.  The maximum number of arguments is
<b class="nc"><i>2630</i>&nbsp;     *         limited by the maximum dimension of a Java array as defined by</b>
<i>2631</i>&nbsp;     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
<b class="nc"><i>2632</i>&nbsp;     *</b>
<i>2633</i>&nbsp;     * @throws  IllegalFormatException
<i>2634</i>&nbsp;     *          If a format string contains an illegal syntax, a format
<i>2635</i>&nbsp;     *          specifier that is incompatible with the given arguments,
<b class="nc"><i>2636</i>&nbsp;     *          insufficient arguments given the format string, or other</b>
<i>2637</i>&nbsp;     *          illegal conditions.  For specification of all possible
<i>2638</i>&nbsp;     *          formatting errors, see the &lt;a href=&quot;#detail&quot;&gt;Details&lt;/a&gt;
<i>2639</i>&nbsp;     *          section of the formatter class specification.
<b class="nc"><i>2640</i>&nbsp;     *</b>
<b class="nc"><i>2641</i>&nbsp;     * @throws  FormatterClosedException</b>
<b class="nc"><i>2642</i>&nbsp;     *          If this formatter has been closed by invoking its {@link</b>
<b class="nc"><i>2643</i>&nbsp;     *          #close()} method</b>
<i>2644</i>&nbsp;     *
<i>2645</i>&nbsp;     * @return  This formatter
<i>2646</i>&nbsp;     */
<b class="nc"><i>2647</i>&nbsp;    public Formatter format(Locale l, String format, Object ... args) {</b>
<i>2648</i>&nbsp;        ensureOpen();
<i>2649</i>&nbsp;
<i>2650</i>&nbsp;        // index of last argument referenced
<b class="nc"><i>2651</i>&nbsp;        int last = -1;</b>
<b class="nc"><i>2652</i>&nbsp;        // last ordinary index</b>
<i>2653</i>&nbsp;        int lasto = -1;
<b class="nc"><i>2654</i>&nbsp;</b>
<b class="nc"><i>2655</i>&nbsp;        List&lt;FormatString&gt; fsa = parse(format);</b>
<b class="nc"><i>2656</i>&nbsp;        for (FormatString fs : fsa) {</b>
<b class="nc"><i>2657</i>&nbsp;            int index = fs.index();</b>
<b class="nc"><i>2658</i>&nbsp;            try {</b>
<b class="nc"><i>2659</i>&nbsp;                switch (index) {</b>
<i>2660</i>&nbsp;                case -2:  // fixed string, &quot;%n&quot;, or &quot;%%&quot;
<b class="nc"><i>2661</i>&nbsp;                    fs.print(null, l);</b>
<i>2662</i>&nbsp;                    break;
<i>2663</i>&nbsp;                case -1:  // relative index
<i>2664</i>&nbsp;                    if (last &lt; 0 || (args != null &amp;&amp; last &gt; args.length - 1))
<b class="nc"><i>2665</i>&nbsp;                        throw new MissingFormatArgumentException(fs.toString());</b>
<i>2666</i>&nbsp;                    fs.print((args == null ? null : args[last]), l);
<i>2667</i>&nbsp;                    break;
<i>2668</i>&nbsp;                case 0:  // ordinary index
<b class="nc"><i>2669</i>&nbsp;                    lasto++;</b>
<b class="nc"><i>2670</i>&nbsp;                    last = lasto;</b>
<i>2671</i>&nbsp;                    if (args != null &amp;&amp; lasto &gt; args.length - 1)
<i>2672</i>&nbsp;                        throw new MissingFormatArgumentException(fs.toString());
<b class="nc"><i>2673</i>&nbsp;                    fs.print((args == null ? null : args[lasto]), l);</b>
<b class="nc"><i>2674</i>&nbsp;                    break;</b>
<b class="nc"><i>2675</i>&nbsp;                default:  // explicit index</b>
<b class="nc"><i>2676</i>&nbsp;                    last = index - 1;</b>
<b class="nc"><i>2677</i>&nbsp;                    if (args != null &amp;&amp; last &gt; args.length - 1)</b>
<b class="nc"><i>2678</i>&nbsp;                        throw new MissingFormatArgumentException(fs.toString());</b>
<i>2679</i>&nbsp;                    fs.print((args == null ? null : args[last]), l);
<b class="nc"><i>2680</i>&nbsp;                    break;</b>
<i>2681</i>&nbsp;                }
<i>2682</i>&nbsp;            } catch (IOException x) {
<i>2683</i>&nbsp;                lastException = x;
<b class="nc"><i>2684</i>&nbsp;            }</b>
<i>2685</i>&nbsp;        }
<i>2686</i>&nbsp;        return this;
<i>2687</i>&nbsp;    }
<b class="nc"><i>2688</i>&nbsp;</b>
<b class="nc"><i>2689</i>&nbsp;    // %[argument_index$][flags][width][.precision][t]conversion</b>
<b class="nc"><i>2690</i>&nbsp;    private static final String formatSpecifier</b>
<b class="nc"><i>2691</i>&nbsp;        = &quot;%(\\d+\\$)?([-#+ 0,(\\&lt;]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])&quot;;</b>
<b class="nc"><i>2692</i>&nbsp;</b>
<b class="nc"><i>2693</i>&nbsp;    private static Pattern fsPattern = Pattern.compile(formatSpecifier);</b>
<b class="nc"><i>2694</i>&nbsp;</b>
<b class="nc"><i>2695</i>&nbsp;    /**</b>
<b class="nc"><i>2696</i>&nbsp;     * Finds format specifiers in the format string.</b>
<i>2697</i>&nbsp;     */
<b class="nc"><i>2698</i>&nbsp;    private List&lt;FormatString&gt; parse(String s) {</b>
<i>2699</i>&nbsp;        ArrayList&lt;FormatString&gt; al = new ArrayList&lt;&gt;();
<i>2700</i>&nbsp;        Matcher m = fsPattern.matcher(s);
<i>2701</i>&nbsp;        for (int i = 0, len = s.length(); i &lt; len; ) {
<b class="nc"><i>2702</i>&nbsp;            if (m.find(i)) {</b>
<i>2703</i>&nbsp;                // Anything between the start of the string and the beginning
<i>2704</i>&nbsp;                // of the format specifier is either fixed text or contains
<b class="nc"><i>2705</i>&nbsp;                // an invalid format string.</b>
<b class="nc"><i>2706</i>&nbsp;                if (m.start() != i) {</b>
<i>2707</i>&nbsp;                    // Make sure we didn&#39;t miss any invalid format specifiers
<b class="nc"><i>2708</i>&nbsp;                    checkText(s, i, m.start());</b>
<b class="nc"><i>2709</i>&nbsp;                    // Assume previous characters were fixed text</b>
<b class="nc"><i>2710</i>&nbsp;                    al.add(new FixedString(s, i, m.start()));</b>
<b class="nc"><i>2711</i>&nbsp;                }</b>
<i>2712</i>&nbsp;
<b class="nc"><i>2713</i>&nbsp;                al.add(new FormatSpecifier(s, m));</b>
<b class="nc"><i>2714</i>&nbsp;                i = m.end();</b>
<b class="nc"><i>2715</i>&nbsp;            } else {</b>
<b class="nc"><i>2716</i>&nbsp;                // No more valid format specifiers.  Check for possible invalid</b>
<b class="nc"><i>2717</i>&nbsp;                // format specifiers.</b>
<i>2718</i>&nbsp;                checkText(s, i, len);
<i>2719</i>&nbsp;                // The rest of the string is fixed text
<b class="nc"><i>2720</i>&nbsp;                al.add(new FixedString(s, i, s.length()));</b>
<i>2721</i>&nbsp;                break;
<b class="nc"><i>2722</i>&nbsp;            }</b>
<b class="nc"><i>2723</i>&nbsp;        }</b>
<b class="nc"><i>2724</i>&nbsp;        return al;</b>
<b class="nc"><i>2725</i>&nbsp;    }</b>
<b class="nc"><i>2726</i>&nbsp;</b>
<b class="nc"><i>2727</i>&nbsp;    private static void checkText(String s, int start, int end) {</b>
<b class="nc"><i>2728</i>&nbsp;        for (int i = start; i &lt; end; i++) {</b>
<b class="nc"><i>2729</i>&nbsp;            // Any &#39;%&#39; found in the region starts an invalid format specifier.</b>
<b class="nc"><i>2730</i>&nbsp;            if (s.charAt(i) == &#39;%&#39;) {</b>
<b class="nc"><i>2731</i>&nbsp;                char c = (i == end - 1) ? &#39;%&#39; : s.charAt(i + 1);</b>
<b class="nc"><i>2732</i>&nbsp;                throw new UnknownFormatConversionException(String.valueOf(c));</b>
<b class="nc"><i>2733</i>&nbsp;            }</b>
<i>2734</i>&nbsp;        }
<b class="nc"><i>2735</i>&nbsp;    }</b>
<i>2736</i>&nbsp;
<i>2737</i>&nbsp;    private interface FormatString {
<i>2738</i>&nbsp;        int index();
<b class="nc"><i>2739</i>&nbsp;        void print(Object arg, Locale l) throws IOException;</b>
<b class="nc"><i>2740</i>&nbsp;        String toString();</b>
<i>2741</i>&nbsp;    }
<i>2742</i>&nbsp;
<b class="nc"><i>2743</i>&nbsp;    private class FixedString implements FormatString {</b>
<i>2744</i>&nbsp;        private String s;
<i>2745</i>&nbsp;        private int start;
<i>2746</i>&nbsp;        private int end;
<b class="nc"><i>2747</i>&nbsp;        FixedString(String s, int start, int end) {</b>
<b class="nc"><i>2748</i>&nbsp;            this.s = s;</b>
<i>2749</i>&nbsp;            this.start = start;
<i>2750</i>&nbsp;            this.end = end;
<i>2751</i>&nbsp;        }
<i>2752</i>&nbsp;        public int index() { return -2; }
<b class="nc"><i>2753</i>&nbsp;        public void print(Object arg, Locale l)</b>
<b class="nc"><i>2754</i>&nbsp;            throws IOException { a.append(s, start, end); }</b>
<i>2755</i>&nbsp;        public String toString() { return s.substring(start, end); }
<i>2756</i>&nbsp;    }
<b class="nc"><i>2757</i>&nbsp;</b>
<b class="nc"><i>2758</i>&nbsp;    /**</b>
<i>2759</i>&nbsp;     * Enum for {@code BigDecimal} formatting.
<b class="nc"><i>2760</i>&nbsp;     */</b>
<b class="nc"><i>2761</i>&nbsp;    public enum BigDecimalLayoutForm {</b>
<i>2762</i>&nbsp;        /**
<b class="nc"><i>2763</i>&nbsp;         * Format the {@code BigDecimal} in computerized scientific notation.</b>
<b class="nc"><i>2764</i>&nbsp;         */</b>
<i>2765</i>&nbsp;        SCIENTIFIC,
<b class="nc"><i>2766</i>&nbsp;</b>
<b class="nc"><i>2767</i>&nbsp;        /**</b>
<i>2768</i>&nbsp;         * Format the {@code BigDecimal} as a decimal number.
<b class="nc"><i>2769</i>&nbsp;         */</b>
<b class="nc"><i>2770</i>&nbsp;        DECIMAL_FLOAT</b>
<i>2771</i>&nbsp;    };
<b class="nc"><i>2772</i>&nbsp;</b>
<b class="nc"><i>2773</i>&nbsp;    private class FormatSpecifier implements FormatString {</b>
<i>2774</i>&nbsp;        private int index = -1;
<b class="nc"><i>2775</i>&nbsp;        private Flags f = Flags.NONE;</b>
<i>2776</i>&nbsp;        private int width;
<i>2777</i>&nbsp;        private int precision;
<i>2778</i>&nbsp;        private boolean dt = false;
<i>2779</i>&nbsp;        private char c;
<b class="nc"><i>2780</i>&nbsp;</b>
<b class="nc"><i>2781</i>&nbsp;        private int index(String s, int start, int end) {</b>
<b class="nc"><i>2782</i>&nbsp;            if (start &gt;= 0) {</b>
<b class="nc"><i>2783</i>&nbsp;                try {</b>
<b class="nc"><i>2784</i>&nbsp;                    // skip the trailing &#39;$&#39;</b>
<b class="nc"><i>2785</i>&nbsp;                    index = Integer.parseInt(s, start, end - 1, 10);</b>
<b class="nc"><i>2786</i>&nbsp;                } catch (NumberFormatException x) {</b>
<b class="nc"><i>2787</i>&nbsp;                    assert(false);</b>
<b class="nc"><i>2788</i>&nbsp;                }</b>
<b class="nc"><i>2789</i>&nbsp;            } else {</b>
<b class="nc"><i>2790</i>&nbsp;                index = 0;</b>
<b class="nc"><i>2791</i>&nbsp;            }</b>
<i>2792</i>&nbsp;            return index;
<b class="nc"><i>2793</i>&nbsp;        }</b>
<i>2794</i>&nbsp;
<i>2795</i>&nbsp;        public int index() {
<i>2796</i>&nbsp;            return index;
<b class="nc"><i>2797</i>&nbsp;        }</b>
<b class="nc"><i>2798</i>&nbsp;</b>
<b class="nc"><i>2799</i>&nbsp;        private Flags flags(String s, int start, int end) {</b>
<b class="nc"><i>2800</i>&nbsp;            f = Flags.parse(s, start, end);</b>
<b class="nc"><i>2801</i>&nbsp;            if (f.contains(Flags.PREVIOUS))</b>
<b class="nc"><i>2802</i>&nbsp;                index = -1;</b>
<b class="nc"><i>2803</i>&nbsp;            return f;</b>
<b class="nc"><i>2804</i>&nbsp;        }</b>
<i>2805</i>&nbsp;
<b class="nc"><i>2806</i>&nbsp;        private int width(String s, int start, int end) {</b>
<i>2807</i>&nbsp;            width = -1;
<i>2808</i>&nbsp;            if (start &gt;= 0) {
<i>2809</i>&nbsp;                try {
<b class="nc"><i>2810</i>&nbsp;                    width = Integer.parseInt(s, start, end, 10);</b>
<b class="nc"><i>2811</i>&nbsp;                    if (width &lt; 0)</b>
<i>2812</i>&nbsp;                        throw new IllegalFormatWidthException(width);
<i>2813</i>&nbsp;                } catch (NumberFormatException x) {
<b class="nc"><i>2814</i>&nbsp;                    assert(false);</b>
<i>2815</i>&nbsp;                }
<i>2816</i>&nbsp;            }
<i>2817</i>&nbsp;            return width;
<b class="nc"><i>2818</i>&nbsp;        }</b>
<i>2819</i>&nbsp;
<i>2820</i>&nbsp;        private int precision(String s, int start, int end) {
<b class="nc"><i>2821</i>&nbsp;            precision = -1;</b>
<b class="nc"><i>2822</i>&nbsp;            if (start &gt;= 0) {</b>
<b class="nc"><i>2823</i>&nbsp;                try {</b>
<i>2824</i>&nbsp;                    // skip the leading &#39;.&#39;
<i>2825</i>&nbsp;                    precision = Integer.parseInt(s, start + 1, end, 10);
<b class="nc"><i>2826</i>&nbsp;                    if (precision &lt; 0)</b>
<b class="nc"><i>2827</i>&nbsp;                        throw new IllegalFormatPrecisionException(precision);</b>
<b class="nc"><i>2828</i>&nbsp;                } catch (NumberFormatException x) {</b>
<b class="nc"><i>2829</i>&nbsp;                    assert(false);</b>
<b class="nc"><i>2830</i>&nbsp;                }</b>
<b class="nc"><i>2831</i>&nbsp;            }</b>
<b class="nc"><i>2832</i>&nbsp;            return precision;</b>
<i>2833</i>&nbsp;        }
<i>2834</i>&nbsp;
<b class="nc"><i>2835</i>&nbsp;        private char conversion(char conv) {</b>
<i>2836</i>&nbsp;            c = conv;
<i>2837</i>&nbsp;            if (!dt) {
<i>2838</i>&nbsp;                if (!Conversion.isValid(c)) {
<b class="nc"><i>2839</i>&nbsp;                    throw new UnknownFormatConversionException(String.valueOf(c));</b>
<i>2840</i>&nbsp;                }
<i>2841</i>&nbsp;                if (Character.isUpperCase(c)) {
<i>2842</i>&nbsp;                    f.add(Flags.UPPERCASE);
<b class="nc"><i>2843</i>&nbsp;                    c = Character.toLowerCase(c);</b>
<b class="nc"><i>2844</i>&nbsp;                }</b>
<i>2845</i>&nbsp;                if (Conversion.isText(c)) {
<i>2846</i>&nbsp;                    index = -2;
<b class="nc"><i>2847</i>&nbsp;                }</b>
<b class="nc"><i>2848</i>&nbsp;            }</b>
<b class="nc"><i>2849</i>&nbsp;            return c;</b>
<b class="nc"><i>2850</i>&nbsp;        }</b>
<b class="nc"><i>2851</i>&nbsp;</b>
<b class="nc"><i>2852</i>&nbsp;        FormatSpecifier(String s, Matcher m) {</b>
<b class="nc"><i>2853</i>&nbsp;            index(s, m.start(1), m.end(1));</b>
<i>2854</i>&nbsp;            flags(s, m.start(2), m.end(2));
<b class="nc"><i>2855</i>&nbsp;            width(s, m.start(3), m.end(3));</b>
<b class="nc"><i>2856</i>&nbsp;            precision(s, m.start(4), m.end(4));</b>
<b class="nc"><i>2857</i>&nbsp;</b>
<b class="nc"><i>2858</i>&nbsp;            int tTStart = m.start(5);</b>
<b class="nc"><i>2859</i>&nbsp;            if (tTStart &gt;= 0) {</b>
<i>2860</i>&nbsp;                dt = true;
<b class="nc"><i>2861</i>&nbsp;                if (s.charAt(tTStart) == &#39;T&#39;) {</b>
<b class="nc"><i>2862</i>&nbsp;                    f.add(Flags.UPPERCASE);</b>
<b class="nc"><i>2863</i>&nbsp;                }</b>
<b class="nc"><i>2864</i>&nbsp;            }</b>
<b class="nc"><i>2865</i>&nbsp;            conversion(s.charAt(m.start(6)));</b>
<i>2866</i>&nbsp;
<b class="nc"><i>2867</i>&nbsp;            if (dt)</b>
<b class="nc"><i>2868</i>&nbsp;                checkDateTime();</b>
<b class="nc"><i>2869</i>&nbsp;            else if (Conversion.isGeneral(c))</b>
<i>2870</i>&nbsp;                checkGeneral();
<b class="nc"><i>2871</i>&nbsp;            else if (Conversion.isCharacter(c))</b>
<i>2872</i>&nbsp;                checkCharacter();
<i>2873</i>&nbsp;            else if (Conversion.isInteger(c))
<i>2874</i>&nbsp;                checkInteger();
<b class="nc"><i>2875</i>&nbsp;            else if (Conversion.isFloat(c))</b>
<b class="nc"><i>2876</i>&nbsp;                checkFloat();</b>
<b class="nc"><i>2877</i>&nbsp;            else if (Conversion.isText(c))</b>
<b class="nc"><i>2878</i>&nbsp;                checkText();</b>
<b class="nc"><i>2879</i>&nbsp;            else</b>
<b class="nc"><i>2880</i>&nbsp;                throw new UnknownFormatConversionException(String.valueOf(c));</b>
<b class="nc"><i>2881</i>&nbsp;        }</b>
<b class="nc"><i>2882</i>&nbsp;</b>
<b class="nc"><i>2883</i>&nbsp;        public void print(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>2884</i>&nbsp;            if (dt) {</b>
<i>2885</i>&nbsp;                printDateTime(arg, l);
<b class="nc"><i>2886</i>&nbsp;                return;</b>
<i>2887</i>&nbsp;            }
<i>2888</i>&nbsp;            switch(c) {
<i>2889</i>&nbsp;            case Conversion.DECIMAL_INTEGER:
<i>2890</i>&nbsp;            case Conversion.OCTAL_INTEGER:
<i>2891</i>&nbsp;            case Conversion.HEXADECIMAL_INTEGER:
<b class="nc"><i>2892</i>&nbsp;                printInteger(arg, l);</b>
<b class="nc"><i>2893</i>&nbsp;                break;</b>
<b class="nc"><i>2894</i>&nbsp;            case Conversion.SCIENTIFIC:</b>
<b class="nc"><i>2895</i>&nbsp;            case Conversion.GENERAL:</b>
<i>2896</i>&nbsp;            case Conversion.DECIMAL_FLOAT:
<b class="nc"><i>2897</i>&nbsp;            case Conversion.HEXADECIMAL_FLOAT:</b>
<b class="nc"><i>2898</i>&nbsp;                printFloat(arg, l);</b>
<i>2899</i>&nbsp;                break;
<i>2900</i>&nbsp;            case Conversion.CHARACTER:
<i>2901</i>&nbsp;            case Conversion.CHARACTER_UPPER:
<b class="nc"><i>2902</i>&nbsp;                printCharacter(arg, l);</b>
<i>2903</i>&nbsp;                break;
<b class="nc"><i>2904</i>&nbsp;            case Conversion.BOOLEAN:</b>
<b class="nc"><i>2905</i>&nbsp;                printBoolean(arg, l);</b>
<i>2906</i>&nbsp;                break;
<i>2907</i>&nbsp;            case Conversion.STRING:
<i>2908</i>&nbsp;                printString(arg, l);
<b class="nc"><i>2909</i>&nbsp;                break;</b>
<b class="nc"><i>2910</i>&nbsp;            case Conversion.HASHCODE:</b>
<b class="nc"><i>2911</i>&nbsp;                printHashCode(arg, l);</b>
<b class="nc"><i>2912</i>&nbsp;                break;</b>
<b class="nc"><i>2913</i>&nbsp;            case Conversion.LINE_SEPARATOR:</b>
<i>2914</i>&nbsp;                a.append(System.lineSeparator());
<i>2915</i>&nbsp;                break;
<i>2916</i>&nbsp;            case Conversion.PERCENT_SIGN:
<b class="nc"><i>2917</i>&nbsp;                print(&quot;%&quot;, l);</b>
<b class="nc"><i>2918</i>&nbsp;                break;</b>
<b class="nc"><i>2919</i>&nbsp;            default:</b>
<b class="nc"><i>2920</i>&nbsp;                assert false;</b>
<b class="nc"><i>2921</i>&nbsp;            }</b>
<b class="nc"><i>2922</i>&nbsp;        }</b>
<b class="nc"><i>2923</i>&nbsp;</b>
<b class="nc"><i>2924</i>&nbsp;        private void printInteger(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>2925</i>&nbsp;            if (arg == null)</b>
<b class="nc"><i>2926</i>&nbsp;                print(&quot;null&quot;, l);</b>
<b class="nc"><i>2927</i>&nbsp;            else if (arg instanceof Byte)</b>
<i>2928</i>&nbsp;                print(((Byte)arg).byteValue(), l);
<i>2929</i>&nbsp;            else if (arg instanceof Short)
<i>2930</i>&nbsp;                print(((Short)arg).shortValue(), l);
<b class="nc"><i>2931</i>&nbsp;            else if (arg instanceof Integer)</b>
<i>2932</i>&nbsp;                print(((Integer)arg).intValue(), l);
<b class="nc"><i>2933</i>&nbsp;            else if (arg instanceof Long)</b>
<b class="nc"><i>2934</i>&nbsp;                print(((Long)arg).longValue(), l);</b>
<b class="nc"><i>2935</i>&nbsp;            else if (arg instanceof BigInteger)</b>
<b class="nc"><i>2936</i>&nbsp;                print(((BigInteger)arg), l);</b>
<b class="nc"><i>2937</i>&nbsp;            else</b>
<b class="nc"><i>2938</i>&nbsp;                failConversion(c, arg);</b>
<b class="nc"><i>2939</i>&nbsp;        }</b>
<b class="nc"><i>2940</i>&nbsp;</b>
<b class="nc"><i>2941</i>&nbsp;        private void printFloat(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>2942</i>&nbsp;            if (arg == null)</b>
<b class="nc"><i>2943</i>&nbsp;                print(&quot;null&quot;, l);</b>
<b class="nc"><i>2944</i>&nbsp;            else if (arg instanceof Float)</b>
<b class="nc"><i>2945</i>&nbsp;                print(((Float)arg).floatValue(), l);</b>
<i>2946</i>&nbsp;            else if (arg instanceof Double)
<i>2947</i>&nbsp;                print(((Double)arg).doubleValue(), l);
<i>2948</i>&nbsp;            else if (arg instanceof BigDecimal)
<b class="nc"><i>2949</i>&nbsp;                print(((BigDecimal)arg), l);</b>
<b class="nc"><i>2950</i>&nbsp;            else</b>
<b class="nc"><i>2951</i>&nbsp;                failConversion(c, arg);</b>
<i>2952</i>&nbsp;        }
<b class="nc"><i>2953</i>&nbsp;</b>
<b class="nc"><i>2954</i>&nbsp;        private void printDateTime(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>2955</i>&nbsp;            if (arg == null) {</b>
<i>2956</i>&nbsp;                print(&quot;null&quot;, l);
<i>2957</i>&nbsp;                return;
<i>2958</i>&nbsp;            }
<i>2959</i>&nbsp;            Calendar cal = null;
<b class="nc"><i>2960</i>&nbsp;</b>
<b class="nc"><i>2961</i>&nbsp;            // Instead of Calendar.setLenient(true), perhaps we should</b>
<b class="nc"><i>2962</i>&nbsp;            // wrap the IllegalArgumentException that might be thrown?</b>
<b class="nc"><i>2963</i>&nbsp;            if (arg instanceof Long) {</b>
<b class="nc"><i>2964</i>&nbsp;                // Note that the following method uses an instance of the</b>
<i>2965</i>&nbsp;                // default time zone (TimeZone.getDefaultRef().
<i>2966</i>&nbsp;                cal = Calendar.getInstance(l == null ? Locale.US : l);
<b class="nc"><i>2967</i>&nbsp;                cal.setTimeInMillis((Long)arg);</b>
<b class="nc"><i>2968</i>&nbsp;            } else if (arg instanceof Date) {</b>
<i>2969</i>&nbsp;                // Note that the following method uses an instance of the
<i>2970</i>&nbsp;                // default time zone (TimeZone.getDefaultRef().
<i>2971</i>&nbsp;                cal = Calendar.getInstance(l == null ? Locale.US : l);
<b class="nc"><i>2972</i>&nbsp;                cal.setTime((Date)arg);</b>
<b class="nc"><i>2973</i>&nbsp;            } else if (arg instanceof Calendar) {</b>
<b class="nc"><i>2974</i>&nbsp;                cal = (Calendar) ((Calendar) arg).clone();</b>
<i>2975</i>&nbsp;                cal.setLenient(true);
<i>2976</i>&nbsp;            } else if (arg instanceof TemporalAccessor) {
<b class="nc"><i>2977</i>&nbsp;                print((TemporalAccessor) arg, c, l);</b>
<b class="nc"><i>2978</i>&nbsp;                return;</b>
<i>2979</i>&nbsp;            } else {
<i>2980</i>&nbsp;                failConversion(c, arg);
<i>2981</i>&nbsp;            }
<b class="nc"><i>2982</i>&nbsp;            // Use the provided locale so that invocations of</b>
<b class="nc"><i>2983</i>&nbsp;            // localizedMagnitude() use optimizations for null.</b>
<b class="nc"><i>2984</i>&nbsp;            print(cal, c, l);</b>
<i>2985</i>&nbsp;        }
<b class="nc"><i>2986</i>&nbsp;</b>
<b class="nc"><i>2987</i>&nbsp;        private void printCharacter(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>2988</i>&nbsp;            if (arg == null) {</b>
<b class="nc"><i>2989</i>&nbsp;                print(&quot;null&quot;, l);</b>
<i>2990</i>&nbsp;                return;
<b class="nc"><i>2991</i>&nbsp;            }</b>
<i>2992</i>&nbsp;            String s = null;
<i>2993</i>&nbsp;            if (arg instanceof Character) {
<i>2994</i>&nbsp;                s = ((Character)arg).toString();
<b class="nc"><i>2995</i>&nbsp;            } else if (arg instanceof Byte) {</b>
<b class="nc"><i>2996</i>&nbsp;                byte i = ((Byte)arg).byteValue();</b>
<b class="nc"><i>2997</i>&nbsp;                if (Character.isValidCodePoint(i))</b>
<i>2998</i>&nbsp;                    s = new String(Character.toChars(i));
<i>2999</i>&nbsp;                else
<i>3000</i>&nbsp;                    throw new IllegalFormatCodePointException(i);
<b class="nc"><i>3001</i>&nbsp;            } else if (arg instanceof Short) {</b>
<b class="nc"><i>3002</i>&nbsp;                short i = ((Short)arg).shortValue();</b>
<b class="nc"><i>3003</i>&nbsp;                if (Character.isValidCodePoint(i))</b>
<b class="nc"><i>3004</i>&nbsp;                    s = new String(Character.toChars(i));</b>
<b class="nc"><i>3005</i>&nbsp;                else</b>
<b class="nc"><i>3006</i>&nbsp;                    throw new IllegalFormatCodePointException(i);</b>
<b class="nc"><i>3007</i>&nbsp;            } else if (arg instanceof Integer) {</b>
<b class="nc"><i>3008</i>&nbsp;                int i = ((Integer)arg).intValue();</b>
<i>3009</i>&nbsp;                if (Character.isValidCodePoint(i))
<i>3010</i>&nbsp;                    s = new String(Character.toChars(i));
<i>3011</i>&nbsp;                else
<i>3012</i>&nbsp;                    throw new IllegalFormatCodePointException(i);
<b class="nc"><i>3013</i>&nbsp;            } else {</b>
<b class="nc"><i>3014</i>&nbsp;                failConversion(c, arg);</b>
<i>3015</i>&nbsp;            }
<b class="nc"><i>3016</i>&nbsp;            print(s, l);</b>
<b class="nc"><i>3017</i>&nbsp;        }</b>
<i>3018</i>&nbsp;
<i>3019</i>&nbsp;        private void printString(Object arg, Locale l) throws IOException {
<b class="nc"><i>3020</i>&nbsp;            if (arg instanceof Formattable) {</b>
<b class="nc"><i>3021</i>&nbsp;                Formatter fmt = Formatter.this;</b>
<b class="nc"><i>3022</i>&nbsp;                if (fmt.locale() != l)</b>
<i>3023</i>&nbsp;                    fmt = new Formatter(fmt.out(), l);
<i>3024</i>&nbsp;                ((Formattable)arg).formatTo(fmt, f.valueOf(), width, precision);
<b class="nc"><i>3025</i>&nbsp;            } else {</b>
<b class="nc"><i>3026</i>&nbsp;                if (f.contains(Flags.ALTERNATE))</b>
<b class="nc"><i>3027</i>&nbsp;                    failMismatch(Flags.ALTERNATE, &#39;s&#39;);</b>
<i>3028</i>&nbsp;                if (arg == null)
<i>3029</i>&nbsp;                    print(&quot;null&quot;, l);
<i>3030</i>&nbsp;                else
<b class="nc"><i>3031</i>&nbsp;                    print(arg.toString(), l);</b>
<b class="nc"><i>3032</i>&nbsp;            }</b>
<b class="nc"><i>3033</i>&nbsp;        }</b>
<i>3034</i>&nbsp;
<b class="nc"><i>3035</i>&nbsp;        private void printBoolean(Object arg, Locale l) throws IOException {</b>
<b class="nc"><i>3036</i>&nbsp;            String s;</b>
<b class="nc"><i>3037</i>&nbsp;            if (arg != null)</b>
<i>3038</i>&nbsp;                s = ((arg instanceof Boolean)
<b class="nc"><i>3039</i>&nbsp;                     ? ((Boolean)arg).toString()</b>
<b class="nc"><i>3040</i>&nbsp;                     : Boolean.toString(true));</b>
<i>3041</i>&nbsp;            else
<i>3042</i>&nbsp;                s = Boolean.toString(false);
<b class="nc"><i>3043</i>&nbsp;            print(s, l);</b>
<b class="nc"><i>3044</i>&nbsp;        }</b>
<b class="nc"><i>3045</i>&nbsp;</b>
<b class="nc"><i>3046</i>&nbsp;        private void printHashCode(Object arg, Locale l) throws IOException {</b>
<i>3047</i>&nbsp;            String s = (arg == null
<i>3048</i>&nbsp;                        ? &quot;null&quot;
<b class="nc"><i>3049</i>&nbsp;                        : Integer.toHexString(arg.hashCode()));</b>
<i>3050</i>&nbsp;            print(s, l);
<i>3051</i>&nbsp;        }
<i>3052</i>&nbsp;
<i>3053</i>&nbsp;        private void print(String s, Locale l) throws IOException {
<b class="nc"><i>3054</i>&nbsp;            if (precision != -1 &amp;&amp; precision &lt; s.length())</b>
<b class="nc"><i>3055</i>&nbsp;                s = s.substring(0, precision);</b>
<i>3056</i>&nbsp;            if (f.contains(Flags.UPPERCASE))
<i>3057</i>&nbsp;                s = toUpperCaseWithLocale(s, l);
<b class="nc"><i>3058</i>&nbsp;            appendJustified(a, s);</b>
<b class="nc"><i>3059</i>&nbsp;        }</b>
<i>3060</i>&nbsp;
<b class="nc"><i>3061</i>&nbsp;        private String toUpperCaseWithLocale(String s, Locale l) {</b>
<i>3062</i>&nbsp;            return s.toUpperCase(Objects.requireNonNullElse(l,
<i>3063</i>&nbsp;                    Locale.getDefault(Locale.Category.FORMAT)));
<i>3064</i>&nbsp;        }
<b class="nc"><i>3065</i>&nbsp;</b>
<b class="nc"><i>3066</i>&nbsp;        private Appendable appendJustified(Appendable a, CharSequence cs) throws IOException {</b>
<i>3067</i>&nbsp;             if (width == -1) {
<i>3068</i>&nbsp;                 return a.append(cs);
<b class="nc"><i>3069</i>&nbsp;             }</b>
<b class="nc"><i>3070</i>&nbsp;             boolean padRight = f.contains(Flags.LEFT_JUSTIFY);</b>
<i>3071</i>&nbsp;             int sp = width - cs.length();
<b class="nc"><i>3072</i>&nbsp;             if (padRight) {</b>
<i>3073</i>&nbsp;                 a.append(cs);
<i>3074</i>&nbsp;             }
<i>3075</i>&nbsp;             for (int i = 0; i &lt; sp; i++) {
<b class="nc"><i>3076</i>&nbsp;                 a.append(&#39; &#39;);</b>
<b class="nc"><i>3077</i>&nbsp;             }</b>
<i>3078</i>&nbsp;             if (!padRight) {
<i>3079</i>&nbsp;                 a.append(cs);
<b class="nc"><i>3080</i>&nbsp;             }</b>
<b class="nc"><i>3081</i>&nbsp;             return a;</b>
<i>3082</i>&nbsp;        }
<b class="nc"><i>3083</i>&nbsp;</b>
<i>3084</i>&nbsp;        public String toString() {
<i>3085</i>&nbsp;            StringBuilder sb = new StringBuilder(&quot;%&quot;);
<i>3086</i>&nbsp;            // Flags.UPPERCASE is set internally for legal conversions.
<i>3087</i>&nbsp;            Flags dupf = f.dup().remove(Flags.UPPERCASE);
<b class="nc"><i>3088</i>&nbsp;            sb.append(dupf.toString());</b>
<i>3089</i>&nbsp;            if (index &gt; 0)
<b class="nc"><i>3090</i>&nbsp;                sb.append(index).append(&#39;$&#39;);</b>
<b class="nc"><i>3091</i>&nbsp;            if (width != -1)</b>
<i>3092</i>&nbsp;                sb.append(width);
<b class="nc"><i>3093</i>&nbsp;            if (precision != -1)</b>
<b class="nc"><i>3094</i>&nbsp;                sb.append(&#39;.&#39;).append(precision);</b>
<i>3095</i>&nbsp;            if (dt)
<b class="nc"><i>3096</i>&nbsp;                sb.append(f.contains(Flags.UPPERCASE) ? &#39;T&#39; : &#39;t&#39;);</b>
<i>3097</i>&nbsp;            sb.append(f.contains(Flags.UPPERCASE)
<i>3098</i>&nbsp;                      ? Character.toUpperCase(c) : c);
<b class="nc"><i>3099</i>&nbsp;            return sb.toString();</b>
<i>3100</i>&nbsp;        }
<i>3101</i>&nbsp;
<b class="nc"><i>3102</i>&nbsp;        private void checkGeneral() {</b>
<i>3103</i>&nbsp;            if ((c == Conversion.BOOLEAN || c == Conversion.HASHCODE)
<i>3104</i>&nbsp;                &amp;&amp; f.contains(Flags.ALTERNATE))
<b class="nc"><i>3105</i>&nbsp;                failMismatch(Flags.ALTERNATE, c);</b>
<b class="nc"><i>3106</i>&nbsp;            // &#39;-&#39; requires a width</b>
<b class="nc"><i>3107</i>&nbsp;            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</b>
<i>3108</i>&nbsp;                throw new MissingFormatWidthException(toString());
<b class="nc"><i>3109</i>&nbsp;            checkBadFlags(Flags.PLUS, Flags.LEADING_SPACE, Flags.ZERO_PAD,</b>
<b class="nc"><i>3110</i>&nbsp;                          Flags.GROUP, Flags.PARENTHESES);</b>
<b class="nc"><i>3111</i>&nbsp;        }</b>
<b class="nc"><i>3112</i>&nbsp;</b>
<i>3113</i>&nbsp;        private void checkDateTime() {
<i>3114</i>&nbsp;            if (precision != -1)
<b class="nc"><i>3115</i>&nbsp;                throw new IllegalFormatPrecisionException(precision);</b>
<b class="nc"><i>3116</i>&nbsp;            if (!DateTime.isValid(c))</b>
<b class="nc"><i>3117</i>&nbsp;                throw new UnknownFormatConversionException(&quot;t&quot; + c);</b>
<b class="nc"><i>3118</i>&nbsp;            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,</b>
<b class="nc"><i>3119</i>&nbsp;                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);</b>
<b class="nc"><i>3120</i>&nbsp;            // &#39;-&#39; requires a width</b>
<b class="nc"><i>3121</i>&nbsp;            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</b>
<i>3122</i>&nbsp;                throw new MissingFormatWidthException(toString());
<b class="nc"><i>3123</i>&nbsp;        }</b>
<b class="nc"><i>3124</i>&nbsp;</b>
<b class="nc"><i>3125</i>&nbsp;        private void checkCharacter() {</b>
<b class="nc"><i>3126</i>&nbsp;            if (precision != -1)</b>
<i>3127</i>&nbsp;                throw new IllegalFormatPrecisionException(precision);
<i>3128</i>&nbsp;            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,
<b class="nc"><i>3129</i>&nbsp;                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);</b>
<b class="nc"><i>3130</i>&nbsp;            // &#39;-&#39; requires a width</b>
<b class="nc"><i>3131</i>&nbsp;            if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))</b>
<b class="nc"><i>3132</i>&nbsp;                throw new MissingFormatWidthException(toString());</b>
<b class="nc"><i>3133</i>&nbsp;        }</b>
<b class="nc"><i>3134</i>&nbsp;</b>
<b class="nc"><i>3135</i>&nbsp;        private void checkInteger() {</b>
<i>3136</i>&nbsp;            checkNumeric();
<i>3137</i>&nbsp;            if (precision != -1)
<i>3138</i>&nbsp;                throw new IllegalFormatPrecisionException(precision);
<b class="nc"><i>3139</i>&nbsp;</b>
<i>3140</i>&nbsp;            if (c == Conversion.DECIMAL_INTEGER)
<i>3141</i>&nbsp;                checkBadFlags(Flags.ALTERNATE);
<i>3142</i>&nbsp;            else if (c == Conversion.OCTAL_INTEGER)
<i>3143</i>&nbsp;                checkBadFlags(Flags.GROUP);
<b class="nc"><i>3144</i>&nbsp;            else</b>
<b class="nc"><i>3145</i>&nbsp;                checkBadFlags(Flags.GROUP);</b>
<b class="nc"><i>3146</i>&nbsp;        }</b>
<b class="nc"><i>3147</i>&nbsp;</b>
<b class="nc"><i>3148</i>&nbsp;        private void checkBadFlags(Flags ... badFlags) {</b>
<i>3149</i>&nbsp;            for (Flags badFlag : badFlags)
<i>3150</i>&nbsp;                if (f.contains(badFlag))
<b class="nc"><i>3151</i>&nbsp;                    failMismatch(badFlag, c);</b>
<b class="nc"><i>3152</i>&nbsp;        }</b>
<i>3153</i>&nbsp;
<b class="nc"><i>3154</i>&nbsp;        private void checkFloat() {</b>
<i>3155</i>&nbsp;            checkNumeric();
<b class="nc"><i>3156</i>&nbsp;            if (c == Conversion.DECIMAL_FLOAT) {</b>
<i>3157</i>&nbsp;            } else if (c == Conversion.HEXADECIMAL_FLOAT) {
<i>3158</i>&nbsp;                checkBadFlags(Flags.PARENTHESES, Flags.GROUP);
<i>3159</i>&nbsp;            } else if (c == Conversion.SCIENTIFIC) {
<i>3160</i>&nbsp;                checkBadFlags(Flags.GROUP);
<b class="nc"><i>3161</i>&nbsp;            } else if (c == Conversion.GENERAL) {</b>
<b class="nc"><i>3162</i>&nbsp;                checkBadFlags(Flags.ALTERNATE);</b>
<b class="nc"><i>3163</i>&nbsp;            }</b>
<i>3164</i>&nbsp;        }
<i>3165</i>&nbsp;
<i>3166</i>&nbsp;        private void checkNumeric() {
<b class="nc"><i>3167</i>&nbsp;            if (width != -1 &amp;&amp; width &lt; 0)</b>
<b class="nc"><i>3168</i>&nbsp;                throw new IllegalFormatWidthException(width);</b>
<b class="nc"><i>3169</i>&nbsp;</b>
<i>3170</i>&nbsp;            if (precision != -1 &amp;&amp; precision &lt; 0)
<i>3171</i>&nbsp;                throw new IllegalFormatPrecisionException(precision);
<b class="nc"><i>3172</i>&nbsp;</b>
<i>3173</i>&nbsp;            // &#39;-&#39; and &#39;0&#39; require a width
<i>3174</i>&nbsp;            if (width == -1
<b class="nc"><i>3175</i>&nbsp;                &amp;&amp; (f.contains(Flags.LEFT_JUSTIFY) || f.contains(Flags.ZERO_PAD)))</b>
<b class="nc"><i>3176</i>&nbsp;                throw new MissingFormatWidthException(toString());</b>
<b class="nc"><i>3177</i>&nbsp;</b>
<b class="nc"><i>3178</i>&nbsp;            // bad combination</b>
<b class="nc"><i>3179</i>&nbsp;            if ((f.contains(Flags.PLUS) &amp;&amp; f.contains(Flags.LEADING_SPACE))</b>
<i>3180</i>&nbsp;                || (f.contains(Flags.LEFT_JUSTIFY) &amp;&amp; f.contains(Flags.ZERO_PAD)))
<b class="nc"><i>3181</i>&nbsp;                throw new IllegalFormatFlagsException(f.toString());</b>
<b class="nc"><i>3182</i>&nbsp;        }</b>
<b class="nc"><i>3183</i>&nbsp;</b>
<i>3184</i>&nbsp;        private void checkText() {
<i>3185</i>&nbsp;            if (precision != -1)
<b class="nc"><i>3186</i>&nbsp;                throw new IllegalFormatPrecisionException(precision);</b>
<b class="nc"><i>3187</i>&nbsp;            switch (c) {</b>
<b class="nc"><i>3188</i>&nbsp;            case Conversion.PERCENT_SIGN:</b>
<i>3189</i>&nbsp;                if (f.valueOf() != Flags.LEFT_JUSTIFY.valueOf()
<b class="nc"><i>3190</i>&nbsp;                    &amp;&amp; f.valueOf() != Flags.NONE.valueOf())</b>
<b class="nc"><i>3191</i>&nbsp;                    throw new IllegalFormatFlagsException(f.toString());</b>
<b class="nc"><i>3192</i>&nbsp;                // &#39;-&#39; requires a width</b>
<i>3193</i>&nbsp;                if (width == -1 &amp;&amp; f.contains(Flags.LEFT_JUSTIFY))
<b class="nc"><i>3194</i>&nbsp;                    throw new MissingFormatWidthException(toString());</b>
<b class="nc"><i>3195</i>&nbsp;                break;</b>
<b class="nc"><i>3196</i>&nbsp;            case Conversion.LINE_SEPARATOR:</b>
<i>3197</i>&nbsp;                if (width != -1)
<b class="nc"><i>3198</i>&nbsp;                    throw new IllegalFormatWidthException(width);</b>
<b class="nc"><i>3199</i>&nbsp;                if (f.valueOf() != Flags.NONE.valueOf())</b>
<b class="nc"><i>3200</i>&nbsp;                    throw new IllegalFormatFlagsException(f.toString());</b>
<i>3201</i>&nbsp;                break;
<i>3202</i>&nbsp;            default:
<b class="nc"><i>3203</i>&nbsp;                assert false;</b>
<b class="nc"><i>3204</i>&nbsp;            }</b>
<b class="nc"><i>3205</i>&nbsp;        }</b>
<i>3206</i>&nbsp;
<b class="nc"><i>3207</i>&nbsp;        private void print(byte value, Locale l) throws IOException {</b>
<b class="nc"><i>3208</i>&nbsp;            long v = value;</b>
<b class="nc"><i>3209</i>&nbsp;            if (value &lt; 0</b>
<b class="nc"><i>3210</i>&nbsp;                &amp;&amp; (c == Conversion.OCTAL_INTEGER</b>
<b class="nc"><i>3211</i>&nbsp;                    || c == Conversion.HEXADECIMAL_INTEGER)) {</b>
<b class="nc"><i>3212</i>&nbsp;                v += (1L &lt;&lt; 8);</b>
<i>3213</i>&nbsp;                assert v &gt;= 0 : v;
<i>3214</i>&nbsp;            }
<i>3215</i>&nbsp;            print(v, l);
<b class="nc"><i>3216</i>&nbsp;        }</b>
<i>3217</i>&nbsp;
<i>3218</i>&nbsp;        private void print(short value, Locale l) throws IOException {
<b class="nc"><i>3219</i>&nbsp;            long v = value;</b>
<i>3220</i>&nbsp;            if (value &lt; 0
<i>3221</i>&nbsp;                &amp;&amp; (c == Conversion.OCTAL_INTEGER
<i>3222</i>&nbsp;                    || c == Conversion.HEXADECIMAL_INTEGER)) {
<b class="nc"><i>3223</i>&nbsp;                v += (1L &lt;&lt; 16);</b>
<i>3224</i>&nbsp;                assert v &gt;= 0 : v;
<i>3225</i>&nbsp;            }
<i>3226</i>&nbsp;            print(v, l);
<b class="nc"><i>3227</i>&nbsp;        }</b>
<b class="nc"><i>3228</i>&nbsp;</b>
<i>3229</i>&nbsp;        private void print(int value, Locale l) throws IOException {
<b class="nc"><i>3230</i>&nbsp;            long v = value;</b>
<b class="nc"><i>3231</i>&nbsp;            if (value &lt; 0</b>
<i>3232</i>&nbsp;                &amp;&amp; (c == Conversion.OCTAL_INTEGER
<i>3233</i>&nbsp;                    || c == Conversion.HEXADECIMAL_INTEGER)) {
<b class="nc"><i>3234</i>&nbsp;                v += (1L &lt;&lt; 32);</b>
<i>3235</i>&nbsp;                assert v &gt;= 0 : v;
<i>3236</i>&nbsp;            }
<b class="nc"><i>3237</i>&nbsp;            print(v, l);</b>
<b class="nc"><i>3238</i>&nbsp;        }</b>
<i>3239</i>&nbsp;
<b class="nc"><i>3240</i>&nbsp;        private void print(long value, Locale l) throws IOException {</b>
<i>3241</i>&nbsp;
<i>3242</i>&nbsp;            StringBuilder sb = new StringBuilder();
<i>3243</i>&nbsp;
<b class="nc"><i>3244</i>&nbsp;            if (c == Conversion.DECIMAL_INTEGER) {</b>
<b class="nc"><i>3245</i>&nbsp;                boolean neg = value &lt; 0;</b>
<b class="nc"><i>3246</i>&nbsp;                String valueStr = Long.toString(value, 10);</b>
<i>3247</i>&nbsp;
<i>3248</i>&nbsp;                // leading sign indicator
<i>3249</i>&nbsp;                leadingSign(sb, neg);
<b class="nc"><i>3250</i>&nbsp;</b>
<i>3251</i>&nbsp;                // the value
<i>3252</i>&nbsp;                localizedMagnitude(sb, valueStr, neg ? 1 : 0, f, adjustWidth(width, f, neg), l);
<i>3253</i>&nbsp;
<i>3254</i>&nbsp;                // trailing sign indicator
<i>3255</i>&nbsp;                trailingSign(sb, neg);
<i>3256</i>&nbsp;            } else if (c == Conversion.OCTAL_INTEGER) {
<i>3257</i>&nbsp;                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,
<b class="nc"><i>3258</i>&nbsp;                              Flags.PLUS);</b>
<i>3259</i>&nbsp;                String s = Long.toOctalString(value);
<i>3260</i>&nbsp;                int len = (f.contains(Flags.ALTERNATE)
<b class="nc"><i>3261</i>&nbsp;                           ? s.length() + 1</b>
<i>3262</i>&nbsp;                           : s.length());
<b class="nc"><i>3263</i>&nbsp;</b>
<b class="nc"><i>3264</i>&nbsp;                // apply ALTERNATE (radix indicator for octal) before ZERO_PAD</b>
<i>3265</i>&nbsp;                if (f.contains(Flags.ALTERNATE))
<i>3266</i>&nbsp;                    sb.append(&#39;0&#39;);
<b class="nc"><i>3267</i>&nbsp;                if (f.contains(Flags.ZERO_PAD)) {</b>
<i>3268</i>&nbsp;                    trailingZeros(sb, width - len);
<i>3269</i>&nbsp;                }
<i>3270</i>&nbsp;                sb.append(s);
<b class="nc"><i>3271</i>&nbsp;            } else if (c == Conversion.HEXADECIMAL_INTEGER) {</b>
<b class="nc"><i>3272</i>&nbsp;                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,</b>
<i>3273</i>&nbsp;                              Flags.PLUS);
<b class="nc"><i>3274</i>&nbsp;                String s = Long.toHexString(value);</b>
<b class="nc"><i>3275</i>&nbsp;                int len = (f.contains(Flags.ALTERNATE)</b>
<i>3276</i>&nbsp;                           ? s.length() + 2
<b class="nc"><i>3277</i>&nbsp;                           : s.length());</b>
<b class="nc"><i>3278</i>&nbsp;</b>
<b class="nc"><i>3279</i>&nbsp;                // apply ALTERNATE (radix indicator for hex) before ZERO_PAD</b>
<b class="nc"><i>3280</i>&nbsp;                if (f.contains(Flags.ALTERNATE))</b>
<i>3281</i>&nbsp;                    sb.append(f.contains(Flags.UPPERCASE) ? &quot;0X&quot; : &quot;0x&quot;);
<b class="nc"><i>3282</i>&nbsp;                if (f.contains(Flags.ZERO_PAD)) {</b>
<i>3283</i>&nbsp;                    trailingZeros(sb, width - len);
<b class="nc"><i>3284</i>&nbsp;                }</b>
<b class="nc"><i>3285</i>&nbsp;                if (f.contains(Flags.UPPERCASE))</b>
<b class="nc"><i>3286</i>&nbsp;                    s = toUpperCaseWithLocale(s, l);</b>
<b class="nc"><i>3287</i>&nbsp;                sb.append(s);</b>
<i>3288</i>&nbsp;            }
<b class="nc"><i>3289</i>&nbsp;</b>
<b class="nc"><i>3290</i>&nbsp;            // justify based on width</b>
<b class="nc"><i>3291</i>&nbsp;            appendJustified(a, sb);</b>
<b class="nc"><i>3292</i>&nbsp;        }</b>
<i>3293</i>&nbsp;
<i>3294</i>&nbsp;        // neg := val &lt; 0
<b class="nc"><i>3295</i>&nbsp;        private StringBuilder leadingSign(StringBuilder sb, boolean neg) {</b>
<i>3296</i>&nbsp;            if (!neg) {
<b class="nc"><i>3297</i>&nbsp;                if (f.contains(Flags.PLUS)) {</b>
<b class="nc"><i>3298</i>&nbsp;                    sb.append(&#39;+&#39;);</b>
<i>3299</i>&nbsp;                } else if (f.contains(Flags.LEADING_SPACE)) {
<i>3300</i>&nbsp;                    sb.append(&#39; &#39;);
<b class="nc"><i>3301</i>&nbsp;                }</b>
<i>3302</i>&nbsp;            } else {
<i>3303</i>&nbsp;                if (f.contains(Flags.PARENTHESES))
<i>3304</i>&nbsp;                    sb.append(&#39;(&#39;);
<b class="nc"><i>3305</i>&nbsp;                else</b>
<b class="nc"><i>3306</i>&nbsp;                    sb.append(&#39;-&#39;);</b>
<i>3307</i>&nbsp;            }
<b class="nc"><i>3308</i>&nbsp;            return sb;</b>
<b class="nc"><i>3309</i>&nbsp;        }</b>
<b class="nc"><i>3310</i>&nbsp;</b>
<b class="nc"><i>3311</i>&nbsp;        // neg := val &lt; 0</b>
<b class="nc"><i>3312</i>&nbsp;        private StringBuilder trailingSign(StringBuilder sb, boolean neg) {</b>
<b class="nc"><i>3313</i>&nbsp;            if (neg &amp;&amp; f.contains(Flags.PARENTHESES))</b>
<b class="nc"><i>3314</i>&nbsp;                sb.append(&#39;)&#39;);</b>
<b class="nc"><i>3315</i>&nbsp;            return sb;</b>
<b class="nc"><i>3316</i>&nbsp;        }</b>
<b class="nc"><i>3317</i>&nbsp;</b>
<i>3318</i>&nbsp;        private void print(BigInteger value, Locale l) throws IOException {
<i>3319</i>&nbsp;            StringBuilder sb = new StringBuilder();
<i>3320</i>&nbsp;            boolean neg = value.signum() == -1;
<i>3321</i>&nbsp;            BigInteger v = value.abs();
<b class="nc"><i>3322</i>&nbsp;</b>
<b class="nc"><i>3323</i>&nbsp;            // leading sign indicator</b>
<b class="nc"><i>3324</i>&nbsp;            leadingSign(sb, neg);</b>
<b class="nc"><i>3325</i>&nbsp;</b>
<i>3326</i>&nbsp;            // the value
<b class="nc"><i>3327</i>&nbsp;            if (c == Conversion.DECIMAL_INTEGER) {</b>
<b class="nc"><i>3328</i>&nbsp;                localizedMagnitude(sb, v.toString(), 0, f, adjustWidth(width, f, neg), l);</b>
<i>3329</i>&nbsp;            } else if (c == Conversion.OCTAL_INTEGER) {
<b class="nc"><i>3330</i>&nbsp;                String s = v.toString(8);</b>
<b class="nc"><i>3331</i>&nbsp;</b>
<b class="nc"><i>3332</i>&nbsp;                int len = s.length() + sb.length();</b>
<i>3333</i>&nbsp;                if (neg &amp;&amp; f.contains(Flags.PARENTHESES))
<i>3334</i>&nbsp;                    len++;
<b class="nc"><i>3335</i>&nbsp;</b>
<b class="nc"><i>3336</i>&nbsp;                // apply ALTERNATE (radix indicator for octal) before ZERO_PAD</b>
<i>3337</i>&nbsp;                if (f.contains(Flags.ALTERNATE)) {
<b class="nc"><i>3338</i>&nbsp;                    len++;</b>
<i>3339</i>&nbsp;                    sb.append(&#39;0&#39;);
<i>3340</i>&nbsp;                }
<b class="nc"><i>3341</i>&nbsp;                if (f.contains(Flags.ZERO_PAD)) {</b>
<i>3342</i>&nbsp;                    trailingZeros(sb, width - len);
<i>3343</i>&nbsp;                }
<b class="nc"><i>3344</i>&nbsp;                sb.append(s);</b>
<b class="nc"><i>3345</i>&nbsp;            } else if (c == Conversion.HEXADECIMAL_INTEGER) {</b>
<i>3346</i>&nbsp;                String s = v.toString(16);
<b class="nc"><i>3347</i>&nbsp;</b>
<b class="nc"><i>3348</i>&nbsp;                int len = s.length() + sb.length();</b>
<b class="nc"><i>3349</i>&nbsp;                if (neg &amp;&amp; f.contains(Flags.PARENTHESES))</b>
<b class="nc"><i>3350</i>&nbsp;                    len++;</b>
<i>3351</i>&nbsp;
<b class="nc"><i>3352</i>&nbsp;                // apply ALTERNATE (radix indicator for hex) before ZERO_PAD</b>
<i>3353</i>&nbsp;                if (f.contains(Flags.ALTERNATE)) {
<b class="nc"><i>3354</i>&nbsp;                    len += 2;</b>
<i>3355</i>&nbsp;                    sb.append(f.contains(Flags.UPPERCASE) ? &quot;0X&quot; : &quot;0x&quot;);
<b class="nc"><i>3356</i>&nbsp;                }</b>
<b class="nc"><i>3357</i>&nbsp;                if (f.contains(Flags.ZERO_PAD)) {</b>
<i>3358</i>&nbsp;                    trailingZeros(sb, width - len);
<b class="nc"><i>3359</i>&nbsp;                }</b>
<b class="nc"><i>3360</i>&nbsp;                if (f.contains(Flags.UPPERCASE))</b>
<b class="nc"><i>3361</i>&nbsp;                    s = toUpperCaseWithLocale(s, l);</b>
<b class="nc"><i>3362</i>&nbsp;                sb.append(s);</b>
<i>3363</i>&nbsp;            }
<b class="nc"><i>3364</i>&nbsp;</b>
<b class="nc"><i>3365</i>&nbsp;            // trailing sign indicator</b>
<b class="nc"><i>3366</i>&nbsp;            trailingSign(sb, (value.signum() == -1));</b>
<i>3367</i>&nbsp;
<b class="nc"><i>3368</i>&nbsp;            // justify based on width</b>
<b class="nc"><i>3369</i>&nbsp;            appendJustified(a, sb);</b>
<b class="nc"><i>3370</i>&nbsp;        }</b>
<i>3371</i>&nbsp;
<b class="nc"><i>3372</i>&nbsp;        private void print(float value, Locale l) throws IOException {</b>
<b class="nc"><i>3373</i>&nbsp;            print((double) value, l);</b>
<b class="nc"><i>3374</i>&nbsp;        }</b>
<i>3375</i>&nbsp;
<b class="nc"><i>3376</i>&nbsp;        private void print(double value, Locale l) throws IOException {</b>
<i>3377</i>&nbsp;            StringBuilder sb = new StringBuilder();
<i>3378</i>&nbsp;            boolean neg = Double.compare(value, 0.0) == -1;
<b class="nc"><i>3379</i>&nbsp;</b>
<b class="nc"><i>3380</i>&nbsp;            if (!Double.isNaN(value)) {</b>
<i>3381</i>&nbsp;                double v = Math.abs(value);
<b class="nc"><i>3382</i>&nbsp;</b>
<b class="nc"><i>3383</i>&nbsp;                // leading sign indicator</b>
<b class="nc"><i>3384</i>&nbsp;                leadingSign(sb, neg);</b>
<i>3385</i>&nbsp;
<b class="nc"><i>3386</i>&nbsp;                // the value</b>
<b class="nc"><i>3387</i>&nbsp;                if (!Double.isInfinite(v))</b>
<b class="nc"><i>3388</i>&nbsp;                    print(sb, v, l, f, c, precision, neg);</b>
<b class="nc"><i>3389</i>&nbsp;                else</b>
<i>3390</i>&nbsp;                    sb.append(f.contains(Flags.UPPERCASE)
<b class="nc"><i>3391</i>&nbsp;                              ? &quot;INFINITY&quot; : &quot;Infinity&quot;);</b>
<b class="nc"><i>3392</i>&nbsp;</b>
<i>3393</i>&nbsp;                // trailing sign indicator
<b class="nc"><i>3394</i>&nbsp;                trailingSign(sb, neg);</b>
<b class="nc"><i>3395</i>&nbsp;            } else {</b>
<b class="nc"><i>3396</i>&nbsp;                sb.append(f.contains(Flags.UPPERCASE) ? &quot;NAN&quot; : &quot;NaN&quot;);</b>
<i>3397</i>&nbsp;            }
<i>3398</i>&nbsp;
<i>3399</i>&nbsp;            // justify based on width
<i>3400</i>&nbsp;            appendJustified(a, sb);
<i>3401</i>&nbsp;        }
<i>3402</i>&nbsp;
<i>3403</i>&nbsp;        // !Double.isInfinite(value) &amp;&amp; !Double.isNaN(value)
<i>3404</i>&nbsp;        private void print(StringBuilder sb, double value, Locale l,
<b class="nc"><i>3405</i>&nbsp;                           Flags f, char c, int precision, boolean neg)</b>
<b class="nc"><i>3406</i>&nbsp;            throws IOException</b>
<b class="nc"><i>3407</i>&nbsp;        {</b>
<i>3408</i>&nbsp;            if (c == Conversion.SCIENTIFIC) {
<b class="nc"><i>3409</i>&nbsp;                // Create a new FormattedFloatingDecimal with the desired</b>
<b class="nc"><i>3410</i>&nbsp;                // precision.</b>
<b class="nc"><i>3411</i>&nbsp;                int prec = (precision == -1 ? 6 : precision);</b>
<i>3412</i>&nbsp;
<i>3413</i>&nbsp;                FormattedFloatingDecimal fd
<i>3414</i>&nbsp;                        = FormattedFloatingDecimal.valueOf(value, prec,
<b class="nc"><i>3415</i>&nbsp;                          FormattedFloatingDecimal.Form.SCIENTIFIC);</b>
<b class="nc"><i>3416</i>&nbsp;</b>
<b class="nc"><i>3417</i>&nbsp;                StringBuilder mant = new StringBuilder().append(fd.getMantissa());</b>
<b class="nc"><i>3418</i>&nbsp;                addZeros(mant, prec);</b>
<i>3419</i>&nbsp;
<i>3420</i>&nbsp;                // If the precision is zero and the &#39;#&#39; flag is set, add the
<b class="nc"><i>3421</i>&nbsp;                // requested decimal point.</b>
<i>3422</i>&nbsp;                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0)) {
<b class="nc"><i>3423</i>&nbsp;                    mant.append(&#39;.&#39;);</b>
<i>3424</i>&nbsp;                }
<i>3425</i>&nbsp;
<b class="nc"><i>3426</i>&nbsp;                char[] exp = (value == 0.0)</b>
<b class="nc"><i>3427</i>&nbsp;                    ? new char[] {&#39;+&#39;,&#39;0&#39;,&#39;0&#39;} : fd.getExponent();</b>
<b class="nc"><i>3428</i>&nbsp;</b>
<b class="nc"><i>3429</i>&nbsp;                int newW = width;</b>
<i>3430</i>&nbsp;                if (width != -1) {
<i>3431</i>&nbsp;                    newW = adjustWidth(width - exp.length - 1, f, neg);
<i>3432</i>&nbsp;                }
<b class="nc"><i>3433</i>&nbsp;                localizedMagnitude(sb, mant, 0, f, newW, l);</b>
<b class="nc"><i>3434</i>&nbsp;</b>
<i>3435</i>&nbsp;                sb.append(f.contains(Flags.UPPERCASE) ? &#39;E&#39; : &#39;e&#39;);
<b class="nc"><i>3436</i>&nbsp;</b>
<i>3437</i>&nbsp;                char sign = exp[0];
<i>3438</i>&nbsp;                assert(sign == &#39;+&#39; || sign == &#39;-&#39;);
<i>3439</i>&nbsp;                sb.append(sign);
<i>3440</i>&nbsp;
<i>3441</i>&nbsp;                localizedMagnitudeExp(sb, exp, 1, l);
<b class="nc"><i>3442</i>&nbsp;            } else if (c == Conversion.DECIMAL_FLOAT) {</b>
<i>3443</i>&nbsp;                // Create a new FormattedFloatingDecimal with the desired
<b class="nc"><i>3444</i>&nbsp;                // precision.</b>
<i>3445</i>&nbsp;                int prec = (precision == -1 ? 6 : precision);
<b class="nc"><i>3446</i>&nbsp;</b>
<i>3447</i>&nbsp;                FormattedFloatingDecimal fd
<b class="nc"><i>3448</i>&nbsp;                        = FormattedFloatingDecimal.valueOf(value, prec,</b>
<b class="nc"><i>3449</i>&nbsp;                          FormattedFloatingDecimal.Form.DECIMAL_FLOAT);</b>
<i>3450</i>&nbsp;
<i>3451</i>&nbsp;                StringBuilder mant = new StringBuilder().append(fd.getMantissa());
<i>3452</i>&nbsp;                addZeros(mant, prec);
<i>3453</i>&nbsp;
<b class="nc"><i>3454</i>&nbsp;                // If the precision is zero and the &#39;#&#39; flag is set, add the</b>
<b class="nc"><i>3455</i>&nbsp;                // requested decimal point.</b>
<b class="nc"><i>3456</i>&nbsp;                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0))</b>
<i>3457</i>&nbsp;                    mant.append(&#39;.&#39;);
<i>3458</i>&nbsp;
<b class="nc"><i>3459</i>&nbsp;                int newW = width;</b>
<b class="nc"><i>3460</i>&nbsp;                if (width != -1)</b>
<i>3461</i>&nbsp;                    newW = adjustWidth(width, f, neg);
<i>3462</i>&nbsp;                localizedMagnitude(sb, mant, 0, f, newW, l);
<i>3463</i>&nbsp;            } else if (c == Conversion.GENERAL) {
<b class="nc"><i>3464</i>&nbsp;                int prec = precision;</b>
<b class="nc"><i>3465</i>&nbsp;                if (precision == -1)</b>
<i>3466</i>&nbsp;                    prec = 6;
<b class="nc"><i>3467</i>&nbsp;                else if (precision == 0)</b>
<i>3468</i>&nbsp;                    prec = 1;
<b class="nc"><i>3469</i>&nbsp;</b>
<i>3470</i>&nbsp;                char[] exp;
<b class="nc"><i>3471</i>&nbsp;                StringBuilder mant = new StringBuilder();</b>
<i>3472</i>&nbsp;                int expRounded;
<i>3473</i>&nbsp;                if (value == 0.0) {
<i>3474</i>&nbsp;                    exp = null;
<i>3475</i>&nbsp;                    mant.append(&#39;0&#39;);
<b class="nc"><i>3476</i>&nbsp;                    expRounded = 0;</b>
<i>3477</i>&nbsp;                } else {
<i>3478</i>&nbsp;                    FormattedFloatingDecimal fd
<i>3479</i>&nbsp;                        = FormattedFloatingDecimal.valueOf(value, prec,
<i>3480</i>&nbsp;                          FormattedFloatingDecimal.Form.GENERAL);
<i>3481</i>&nbsp;                    exp = fd.getExponent();
<i>3482</i>&nbsp;                    mant.append(fd.getMantissa());
<b class="nc"><i>3483</i>&nbsp;                    expRounded = fd.getExponentRounded();</b>
<b class="nc"><i>3484</i>&nbsp;                }</b>
<i>3485</i>&nbsp;
<b class="nc"><i>3486</i>&nbsp;                if (exp != null) {</b>
<i>3487</i>&nbsp;                    prec -= 1;
<b class="nc"><i>3488</i>&nbsp;                } else {</b>
<b class="nc"><i>3489</i>&nbsp;                    prec -= expRounded + 1;</b>
<i>3490</i>&nbsp;                }
<i>3491</i>&nbsp;
<b class="nc"><i>3492</i>&nbsp;                addZeros(mant, prec);</b>
<b class="nc"><i>3493</i>&nbsp;                // If the precision is zero and the &#39;#&#39; flag is set, add the</b>
<b class="nc"><i>3494</i>&nbsp;                // requested decimal point.</b>
<i>3495</i>&nbsp;                if (f.contains(Flags.ALTERNATE) &amp;&amp; (prec == 0)) {
<b class="nc"><i>3496</i>&nbsp;                    mant.append(&#39;.&#39;);</b>
<i>3497</i>&nbsp;                }
<b class="nc"><i>3498</i>&nbsp;</b>
<i>3499</i>&nbsp;                int newW = width;
<b class="nc"><i>3500</i>&nbsp;                if (width != -1) {</b>
<b class="nc"><i>3501</i>&nbsp;                    if (exp != null)</b>
<b class="nc"><i>3502</i>&nbsp;                        newW = adjustWidth(width - exp.length - 1, f, neg);</b>
<i>3503</i>&nbsp;                    else
<i>3504</i>&nbsp;                        newW = adjustWidth(width, f, neg);
<b class="nc"><i>3505</i>&nbsp;                }</b>
<b class="nc"><i>3506</i>&nbsp;                localizedMagnitude(sb, mant, 0, f, newW, l);</b>
<i>3507</i>&nbsp;
<b class="nc"><i>3508</i>&nbsp;                if (exp != null) {</b>
<b class="nc"><i>3509</i>&nbsp;                    sb.append(f.contains(Flags.UPPERCASE) ? &#39;E&#39; : &#39;e&#39;);</b>
<i>3510</i>&nbsp;
<i>3511</i>&nbsp;                    char sign = exp[0];
<b class="nc"><i>3512</i>&nbsp;                    assert(sign == &#39;+&#39; || sign == &#39;-&#39;);</b>
<b class="nc"><i>3513</i>&nbsp;                    sb.append(sign);</b>
<b class="nc"><i>3514</i>&nbsp;</b>
<b class="nc"><i>3515</i>&nbsp;                    localizedMagnitudeExp(sb, exp, 1, l);</b>
<i>3516</i>&nbsp;                }
<i>3517</i>&nbsp;            } else if (c == Conversion.HEXADECIMAL_FLOAT) {
<i>3518</i>&nbsp;                int prec = precision;
<i>3519</i>&nbsp;                if (precision == -1)
<i>3520</i>&nbsp;                    // assume that we want all of the digits
<i>3521</i>&nbsp;                    prec = 0;
<i>3522</i>&nbsp;                else if (precision == 0)
<b class="nc"><i>3523</i>&nbsp;                    prec = 1;</b>
<b class="nc"><i>3524</i>&nbsp;</b>
<b class="nc"><i>3525</i>&nbsp;                String s = hexDouble(value, prec);</b>
<b class="nc"><i>3526</i>&nbsp;</b>
<b class="nc"><i>3527</i>&nbsp;                StringBuilder va = new StringBuilder();</b>
<i>3528</i>&nbsp;                boolean upper = f.contains(Flags.UPPERCASE);
<b class="nc"><i>3529</i>&nbsp;                sb.append(upper ? &quot;0X&quot; : &quot;0x&quot;);</b>
<i>3530</i>&nbsp;
<i>3531</i>&nbsp;                if (f.contains(Flags.ZERO_PAD)) {
<b class="nc"><i>3532</i>&nbsp;                    trailingZeros(sb, width - s.length() - 2);</b>
<i>3533</i>&nbsp;                }
<i>3534</i>&nbsp;
<b class="nc"><i>3535</i>&nbsp;                int idx = s.indexOf(&#39;p&#39;);</b>
<i>3536</i>&nbsp;                if (upper) {
<i>3537</i>&nbsp;                    String tmp = s.substring(0, idx);
<b class="nc"><i>3538</i>&nbsp;                    // don&#39;t localize hex</b>
<i>3539</i>&nbsp;                    tmp = tmp.toUpperCase(Locale.ROOT);
<i>3540</i>&nbsp;                    va.append(tmp);
<i>3541</i>&nbsp;                } else {
<i>3542</i>&nbsp;                    va.append(s, 0, idx);
<i>3543</i>&nbsp;                }
<i>3544</i>&nbsp;                if (prec != 0) {
<i>3545</i>&nbsp;                    addZeros(va, prec);
<b class="nc"><i>3546</i>&nbsp;                }</b>
<i>3547</i>&nbsp;                sb.append(va);
<b class="nc"><i>3548</i>&nbsp;                sb.append(upper ? &#39;P&#39; : &#39;p&#39;);</b>
<b class="nc"><i>3549</i>&nbsp;                sb.append(s, idx+1, s.length());</b>
<b class="nc"><i>3550</i>&nbsp;            }</b>
<b class="nc"><i>3551</i>&nbsp;        }</b>
<i>3552</i>&nbsp;
<i>3553</i>&nbsp;        // Add zeros to the requested precision.
<b class="nc"><i>3554</i>&nbsp;        private void addZeros(StringBuilder sb, int prec) {</b>
<b class="nc"><i>3555</i>&nbsp;            // Look for the dot.  If we don&#39;t find one, the we&#39;ll need to add</b>
<b class="nc"><i>3556</i>&nbsp;            // it before we add the zeros.</b>
<i>3557</i>&nbsp;            int len = sb.length();
<b class="nc"><i>3558</i>&nbsp;            int i;</b>
<i>3559</i>&nbsp;            for (i = 0; i &lt; len; i++) {
<i>3560</i>&nbsp;                if (sb.charAt(i) == &#39;.&#39;) {
<b class="nc"><i>3561</i>&nbsp;                    break;</b>
<b class="nc"><i>3562</i>&nbsp;                }</b>
<b class="nc"><i>3563</i>&nbsp;            }</b>
<i>3564</i>&nbsp;            boolean needDot = false;
<b class="nc"><i>3565</i>&nbsp;            if (i == len) {</b>
<b class="nc"><i>3566</i>&nbsp;                needDot = true;</b>
<i>3567</i>&nbsp;            }
<i>3568</i>&nbsp;
<b class="nc"><i>3569</i>&nbsp;            // Determine existing precision.</b>
<i>3570</i>&nbsp;            int outPrec = len - i - (needDot ? 0 : 1);
<i>3571</i>&nbsp;            assert (outPrec &lt;= prec);
<i>3572</i>&nbsp;            if (outPrec == prec) {
<i>3573</i>&nbsp;                return;
<i>3574</i>&nbsp;            }
<i>3575</i>&nbsp;
<b class="nc"><i>3576</i>&nbsp;            // Add dot if previously determined to be necessary.</b>
<b class="nc"><i>3577</i>&nbsp;            if (needDot) {</b>
<b class="nc"><i>3578</i>&nbsp;                sb.append(&#39;.&#39;);</b>
<i>3579</i>&nbsp;            }
<i>3580</i>&nbsp;
<i>3581</i>&nbsp;            // Add zeros.
<b class="nc"><i>3582</i>&nbsp;            trailingZeros(sb, prec - outPrec);</b>
<i>3583</i>&nbsp;        }
<b class="nc"><i>3584</i>&nbsp;</b>
<b class="nc"><i>3585</i>&nbsp;        // Method assumes that d &gt; 0.</b>
<b class="nc"><i>3586</i>&nbsp;        private String hexDouble(double d, int prec) {</b>
<b class="nc"><i>3587</i>&nbsp;            // Let Double.toHexString handle simple cases</b>
<b class="nc"><i>3588</i>&nbsp;            if (!Double.isFinite(d) || d == 0.0 || prec == 0 || prec &gt;= 13) {</b>
<i>3589</i>&nbsp;                // remove &quot;0x&quot;
<b class="nc"><i>3590</i>&nbsp;                return Double.toHexString(d).substring(2);</b>
<i>3591</i>&nbsp;            } else {
<b class="nc"><i>3592</i>&nbsp;                assert(prec &gt;= 1 &amp;&amp; prec &lt;= 12);</b>
<b class="nc"><i>3593</i>&nbsp;</b>
<b class="nc"><i>3594</i>&nbsp;                int exponent  = Math.getExponent(d);</b>
<b class="nc"><i>3595</i>&nbsp;                boolean subnormal</b>
<i>3596</i>&nbsp;                    = (exponent == Double.MIN_EXPONENT - 1);
<b class="nc"><i>3597</i>&nbsp;</b>
<b class="nc"><i>3598</i>&nbsp;                // If this is subnormal input so normalize (could be faster to</b>
<b class="nc"><i>3599</i>&nbsp;                // do as integer operation).</b>
<b class="nc"><i>3600</i>&nbsp;                if (subnormal) {</b>
<i>3601</i>&nbsp;                    scaleUp = Math.scalb(1.0, 54);
<b class="nc"><i>3602</i>&nbsp;                    d *= scaleUp;</b>
<b class="nc"><i>3603</i>&nbsp;                    // Calculate the exponent.  This is not just exponent + 54</b>
<i>3604</i>&nbsp;                    // since the former is not the normalized exponent.
<b class="nc"><i>3605</i>&nbsp;                    exponent = Math.getExponent(d);</b>
<i>3606</i>&nbsp;                    assert exponent &gt;= Double.MIN_EXPONENT &amp;&amp;
<b class="nc"><i>3607</i>&nbsp;                        exponent &lt;= Double.MAX_EXPONENT: exponent;</b>
<b class="nc"><i>3608</i>&nbsp;                }</b>
<i>3609</i>&nbsp;
<b class="nc"><i>3610</i>&nbsp;                int precision = 1 + prec*4;</b>
<i>3611</i>&nbsp;                int shiftDistance
<b class="nc"><i>3612</i>&nbsp;                    =  DoubleConsts.SIGNIFICAND_WIDTH - precision;</b>
<b class="nc"><i>3613</i>&nbsp;                assert(shiftDistance &gt;= 1 &amp;&amp; shiftDistance &lt; DoubleConsts.SIGNIFICAND_WIDTH);</b>
<i>3614</i>&nbsp;
<i>3615</i>&nbsp;                long doppel = Double.doubleToLongBits(d);
<i>3616</i>&nbsp;                // Deterime the number of bits to keep.
<i>3617</i>&nbsp;                long newSignif
<b class="nc"><i>3618</i>&nbsp;                    = (doppel &amp; (DoubleConsts.EXP_BIT_MASK</b>
<b class="nc"><i>3619</i>&nbsp;                                 | DoubleConsts.SIGNIF_BIT_MASK))</b>
<b class="nc"><i>3620</i>&nbsp;                                     &gt;&gt; shiftDistance;</b>
<i>3621</i>&nbsp;                // Bits to round away.
<i>3622</i>&nbsp;                long roundingBits = doppel &amp; ~(~0L &lt;&lt; shiftDistance);
<b class="nc"><i>3623</i>&nbsp;</b>
<b class="nc"><i>3624</i>&nbsp;                // To decide how to round, look at the low-order bit of the</b>
<i>3625</i>&nbsp;                // working significand, the highest order discarded bit (the
<i>3626</i>&nbsp;                // round bit) and whether any of the lower order discarded bits
<i>3627</i>&nbsp;                // are nonzero (the sticky bit).
<i>3628</i>&nbsp;
<i>3629</i>&nbsp;                boolean leastZero = (newSignif &amp; 0x1L) == 0L;
<i>3630</i>&nbsp;                boolean round
<b class="nc"><i>3631</i>&nbsp;                    = ((1L &lt;&lt; (shiftDistance - 1) ) &amp; roundingBits) != 0L;</b>
<b class="nc"><i>3632</i>&nbsp;                boolean sticky  = shiftDistance &gt; 1 &amp;&amp;</b>
<i>3633</i>&nbsp;                    (~(1L&lt;&lt; (shiftDistance - 1)) &amp; roundingBits) != 0;
<i>3634</i>&nbsp;                if((leastZero &amp;&amp; round &amp;&amp; sticky) || (!leastZero &amp;&amp; round)) {
<i>3635</i>&nbsp;                    newSignif++;
<b class="nc"><i>3636</i>&nbsp;                }</b>
<i>3637</i>&nbsp;
<b class="nc"><i>3638</i>&nbsp;                long signBit = doppel &amp; DoubleConsts.SIGN_BIT_MASK;</b>
<b class="nc"><i>3639</i>&nbsp;                newSignif = signBit | (newSignif &lt;&lt; shiftDistance);</b>
<b class="nc"><i>3640</i>&nbsp;                double result = Double.longBitsToDouble(newSignif);</b>
<b class="nc"><i>3641</i>&nbsp;</b>
<b class="nc"><i>3642</i>&nbsp;                if (Double.isInfinite(result) ) {</b>
<b class="nc"><i>3643</i>&nbsp;                    // Infinite result generated by rounding</b>
<b class="nc"><i>3644</i>&nbsp;                    return &quot;1.0p1024&quot;;</b>
<i>3645</i>&nbsp;                } else {
<b class="nc"><i>3646</i>&nbsp;                    String res = Double.toHexString(result).substring(2);</b>
<b class="nc"><i>3647</i>&nbsp;                    if (!subnormal)</b>
<b class="nc"><i>3648</i>&nbsp;                        return res;</b>
<b class="nc"><i>3649</i>&nbsp;                    else {</b>
<b class="nc"><i>3650</i>&nbsp;                        // Create a normalized subnormal string.</b>
<i>3651</i>&nbsp;                        int idx = res.indexOf(&#39;p&#39;);
<b class="nc"><i>3652</i>&nbsp;                        if (idx == -1) {</b>
<b class="nc"><i>3653</i>&nbsp;                            // No &#39;p&#39; character in hex string.</b>
<i>3654</i>&nbsp;                            assert false;
<i>3655</i>&nbsp;                            return null;
<i>3656</i>&nbsp;                        } else {
<i>3657</i>&nbsp;                            // Get exponent and append at the end.
<i>3658</i>&nbsp;                            String exp = res.substring(idx + 1);
<i>3659</i>&nbsp;                            int iexp = Integer.parseInt(exp) -54;
<i>3660</i>&nbsp;                            return res.substring(0, idx) + &quot;p&quot;
<i>3661</i>&nbsp;                                + Integer.toString(iexp);
<i>3662</i>&nbsp;                        }
<i>3663</i>&nbsp;                    }
<i>3664</i>&nbsp;                }
<b class="nc"><i>3665</i>&nbsp;            }</b>
<i>3666</i>&nbsp;        }
<b class="nc"><i>3667</i>&nbsp;</b>
<i>3668</i>&nbsp;        private void print(BigDecimal value, Locale l) throws IOException {
<b class="nc"><i>3669</i>&nbsp;            if (c == Conversion.HEXADECIMAL_FLOAT)</b>
<b class="nc"><i>3670</i>&nbsp;                failConversion(c, value);</b>
<i>3671</i>&nbsp;            StringBuilder sb = new StringBuilder();
<b class="nc"><i>3672</i>&nbsp;            boolean neg = value.signum() == -1;</b>
<i>3673</i>&nbsp;            BigDecimal v = value.abs();
<i>3674</i>&nbsp;            // leading sign indicator
<b class="nc"><i>3675</i>&nbsp;            leadingSign(sb, neg);</b>
<i>3676</i>&nbsp;
<i>3677</i>&nbsp;            // the value
<i>3678</i>&nbsp;            print(sb, v, l, f, c, precision, neg);
<i>3679</i>&nbsp;
<i>3680</i>&nbsp;            // trailing sign indicator
<i>3681</i>&nbsp;            trailingSign(sb, neg);
<b class="nc"><i>3682</i>&nbsp;</b>
<i>3683</i>&nbsp;            // justify based on width
<i>3684</i>&nbsp;            appendJustified(a, sb);
<b class="nc"><i>3685</i>&nbsp;        }</b>
<b class="nc"><i>3686</i>&nbsp;</b>
<i>3687</i>&nbsp;        // value &gt; 0
<i>3688</i>&nbsp;        private void print(StringBuilder sb, BigDecimal value, Locale l,
<i>3689</i>&nbsp;                           Flags f, char c, int precision, boolean neg)
<b class="nc"><i>3690</i>&nbsp;            throws IOException</b>
<i>3691</i>&nbsp;        {
<i>3692</i>&nbsp;            if (c == Conversion.SCIENTIFIC) {
<i>3693</i>&nbsp;                // Create a new BigDecimal with the desired precision.
<b class="nc"><i>3694</i>&nbsp;                int prec = (precision == -1 ? 6 : precision);</b>
<i>3695</i>&nbsp;                int scale = value.scale();
<i>3696</i>&nbsp;                int origPrec = value.precision();
<i>3697</i>&nbsp;                int nzeros = 0;
<i>3698</i>&nbsp;                int compPrec;
<b class="nc"><i>3699</i>&nbsp;</b>
<b class="nc"><i>3700</i>&nbsp;                if (prec &gt; origPrec - 1) {</b>
<b class="nc"><i>3701</i>&nbsp;                    compPrec = origPrec;</b>
<b class="nc"><i>3702</i>&nbsp;                    nzeros = prec - (origPrec - 1);</b>
<i>3703</i>&nbsp;                } else {
<b class="nc"><i>3704</i>&nbsp;                    compPrec = prec + 1;</b>
<i>3705</i>&nbsp;                }
<i>3706</i>&nbsp;
<i>3707</i>&nbsp;                MathContext mc = new MathContext(compPrec);
<b class="nc"><i>3708</i>&nbsp;                BigDecimal v</b>
<i>3709</i>&nbsp;                    = new BigDecimal(value.unscaledValue(), scale, mc);
<i>3710</i>&nbsp;
<i>3711</i>&nbsp;                BigDecimalLayout bdl
<i>3712</i>&nbsp;                    = new BigDecimalLayout(v.unscaledValue(), v.scale(),
<i>3713</i>&nbsp;                                           BigDecimalLayoutForm.SCIENTIFIC);
<b class="nc"><i>3714</i>&nbsp;</b>
<i>3715</i>&nbsp;                StringBuilder mant = bdl.mantissa();
<i>3716</i>&nbsp;
<i>3717</i>&nbsp;                // Add a decimal point if necessary.  The mantissa may not
<b class="nc"><i>3718</i>&nbsp;                // contain a decimal point if the scale is zero (the internal</b>
<b class="nc"><i>3719</i>&nbsp;                // representation has no fractional part) or the original</b>
<b class="nc"><i>3720</i>&nbsp;                // precision is one. Append a decimal point if &#39;#&#39; is set or if</b>
<b class="nc"><i>3721</i>&nbsp;                // we require zero padding to get to the requested precision.</b>
<b class="nc"><i>3722</i>&nbsp;                if ((origPrec == 1 || !bdl.hasDot())</b>
<i>3723</i>&nbsp;                        &amp;&amp; (nzeros &gt; 0 || (f.contains(Flags.ALTERNATE)))) {
<i>3724</i>&nbsp;                    mant.append(&#39;.&#39;);
<i>3725</i>&nbsp;                }
<b class="nc"><i>3726</i>&nbsp;</b>
<b class="nc"><i>3727</i>&nbsp;                // Add trailing zeros in the case precision is greater than</b>
<i>3728</i>&nbsp;                // the number of available digits after the decimal separator.
<i>3729</i>&nbsp;                trailingZeros(mant, nzeros);
<i>3730</i>&nbsp;
<i>3731</i>&nbsp;                StringBuilder exp = bdl.exponent();
<i>3732</i>&nbsp;                int newW = width;
<i>3733</i>&nbsp;                if (width != -1) {
<b class="nc"><i>3734</i>&nbsp;                    newW = adjustWidth(width - exp.length() - 1, f, neg);</b>
<i>3735</i>&nbsp;                }
<b class="nc"><i>3736</i>&nbsp;                localizedMagnitude(sb, mant, 0, f, newW, l);</b>
<b class="nc"><i>3737</i>&nbsp;</b>
<b class="nc"><i>3738</i>&nbsp;                sb.append(f.contains(Flags.UPPERCASE) ? &#39;E&#39; : &#39;e&#39;);</b>
<b class="nc"><i>3739</i>&nbsp;</b>
<b class="nc"><i>3740</i>&nbsp;                Flags flags = f.dup().remove(Flags.GROUP);</b>
<b class="nc"><i>3741</i>&nbsp;                char sign = exp.charAt(0);</b>
<b class="nc"><i>3742</i>&nbsp;                assert(sign == &#39;+&#39; || sign == &#39;-&#39;);</b>
<b class="nc"><i>3743</i>&nbsp;                sb.append(sign);</b>
<b class="nc"><i>3744</i>&nbsp;</b>
<b class="nc"><i>3745</i>&nbsp;                sb.append(localizedMagnitude(null, exp, 1, flags, -1, l));</b>
<b class="nc"><i>3746</i>&nbsp;            } else if (c == Conversion.DECIMAL_FLOAT) {</b>
<i>3747</i>&nbsp;                // Create a new BigDecimal with the desired precision.
<b class="nc"><i>3748</i>&nbsp;                int prec = (precision == -1 ? 6 : precision);</b>
<i>3749</i>&nbsp;                int scale = value.scale();
<b class="nc"><i>3750</i>&nbsp;</b>
<i>3751</i>&nbsp;                if (scale &gt; prec) {
<i>3752</i>&nbsp;                    // more &quot;scale&quot; digits than the requested &quot;precision&quot;
<b class="nc"><i>3753</i>&nbsp;                    int compPrec = value.precision();</b>
<b class="nc"><i>3754</i>&nbsp;                    if (compPrec &lt;= scale) {</b>
<b class="nc"><i>3755</i>&nbsp;                        // case of 0.xxxxxx</b>
<i>3756</i>&nbsp;                        value = value.setScale(prec, RoundingMode.HALF_UP);
<i>3757</i>&nbsp;                    } else {
<i>3758</i>&nbsp;                        compPrec -= (scale - prec);
<b class="nc"><i>3759</i>&nbsp;                        value = new BigDecimal(value.unscaledValue(),</b>
<b class="nc"><i>3760</i>&nbsp;                                               scale,</b>
<i>3761</i>&nbsp;                                               new MathContext(compPrec));
<b class="nc"><i>3762</i>&nbsp;                    }</b>
<b class="nc"><i>3763</i>&nbsp;                }</b>
<i>3764</i>&nbsp;                BigDecimalLayout bdl = new BigDecimalLayout(
<b class="nc"><i>3765</i>&nbsp;                                           value.unscaledValue(),</b>
<b class="nc"><i>3766</i>&nbsp;                                           value.scale(),</b>
<b class="nc"><i>3767</i>&nbsp;                                           BigDecimalLayoutForm.DECIMAL_FLOAT);</b>
<b class="nc"><i>3768</i>&nbsp;</b>
<i>3769</i>&nbsp;                StringBuilder mant = bdl.mantissa();
<b class="nc"><i>3770</i>&nbsp;                int nzeros = (bdl.scale() &lt; prec ? prec - bdl.scale() : 0);</b>
<i>3771</i>&nbsp;
<b class="nc"><i>3772</i>&nbsp;                // Add a decimal point if necessary.  The mantissa may not</b>
<b class="nc"><i>3773</i>&nbsp;                // contain a decimal point if the scale is zero (the internal</b>
<b class="nc"><i>3774</i>&nbsp;                // representation has no fractional part).  Append a decimal</b>
<b class="nc"><i>3775</i>&nbsp;                // point if &#39;#&#39; is set or we require zero padding to get to the</b>
<i>3776</i>&nbsp;                // requested precision.
<i>3777</i>&nbsp;                if (bdl.scale() == 0 &amp;&amp; (f.contains(Flags.ALTERNATE)
<b class="nc"><i>3778</i>&nbsp;                        || nzeros &gt; 0)) {</b>
<b class="nc"><i>3779</i>&nbsp;                    mant.append(&#39;.&#39;);</b>
<b class="nc"><i>3780</i>&nbsp;                }</b>
<b class="nc"><i>3781</i>&nbsp;</b>
<i>3782</i>&nbsp;                // Add trailing zeros if the precision is greater than the
<i>3783</i>&nbsp;                // number of available digits after the decimal separator.
<b class="nc"><i>3784</i>&nbsp;                trailingZeros(mant, nzeros);</b>
<i>3785</i>&nbsp;
<b class="nc"><i>3786</i>&nbsp;                localizedMagnitude(sb, mant, 0, f, adjustWidth(width, f, neg), l);</b>
<b class="nc"><i>3787</i>&nbsp;            } else if (c == Conversion.GENERAL) {</b>
<b class="nc"><i>3788</i>&nbsp;                int prec = precision;</b>
<b class="nc"><i>3789</i>&nbsp;                if (precision == -1)</b>
<b class="nc"><i>3790</i>&nbsp;                    prec = 6;</b>
<i>3791</i>&nbsp;                else if (precision == 0)
<b class="nc"><i>3792</i>&nbsp;                    prec = 1;</b>
<b class="nc"><i>3793</i>&nbsp;</b>
<b class="nc"><i>3794</i>&nbsp;                BigDecimal tenToTheNegFour = BigDecimal.valueOf(1, 4);</b>
<i>3795</i>&nbsp;                BigDecimal tenToThePrec = BigDecimal.valueOf(1, -prec);
<b class="nc"><i>3796</i>&nbsp;                if ((value.equals(BigDecimal.ZERO))</b>
<b class="nc"><i>3797</i>&nbsp;                    || ((value.compareTo(tenToTheNegFour) != -1)</b>
<b class="nc"><i>3798</i>&nbsp;                        &amp;&amp; (value.compareTo(tenToThePrec) == -1))) {</b>
<b class="nc"><i>3799</i>&nbsp;</b>
<b class="nc"><i>3800</i>&nbsp;                    int e = - value.scale()</b>
<b class="nc"><i>3801</i>&nbsp;                        + (value.unscaledValue().toString().length() - 1);</b>
<i>3802</i>&nbsp;
<i>3803</i>&nbsp;                    // xxx.yyy
<i>3804</i>&nbsp;                    //   g precision (# sig digits) = #x + #y
<i>3805</i>&nbsp;                    //   f precision = #y
<i>3806</i>&nbsp;                    //   exponent = #x - 1
<i>3807</i>&nbsp;                    // =&gt; f precision = g precision - exponent - 1
<b class="nc"><i>3808</i>&nbsp;                    // 0.000zzz</b>
<b class="nc"><i>3809</i>&nbsp;                    //   g precision (# sig digits) = #z</b>
<b class="nc"><i>3810</i>&nbsp;                    //   f precision = #0 (after &#39;.&#39;) + #z</b>
<b class="nc"><i>3811</i>&nbsp;                    //   exponent = - #0 (after &#39;.&#39;) - 1</b>
<i>3812</i>&nbsp;                    // =&gt; f precision = g precision - exponent - 1
<i>3813</i>&nbsp;                    prec = prec - e - 1;
<i>3814</i>&nbsp;
<i>3815</i>&nbsp;                    print(sb, value, l, f, Conversion.DECIMAL_FLOAT, prec,
<b class="nc"><i>3816</i>&nbsp;                          neg);</b>
<b class="nc"><i>3817</i>&nbsp;                } else {</b>
<b class="nc"><i>3818</i>&nbsp;                    print(sb, value, l, f, Conversion.SCIENTIFIC, prec - 1, neg);</b>
<b class="nc"><i>3819</i>&nbsp;                }</b>
<b class="nc"><i>3820</i>&nbsp;            } else if (c == Conversion.HEXADECIMAL_FLOAT) {</b>
<i>3821</i>&nbsp;                // This conversion isn&#39;t supported.  The error should be
<i>3822</i>&nbsp;                // reported earlier.
<i>3823</i>&nbsp;                assert false;
<i>3824</i>&nbsp;            }
<i>3825</i>&nbsp;        }
<b class="nc"><i>3826</i>&nbsp;</b>
<b class="nc"><i>3827</i>&nbsp;        private class BigDecimalLayout {</b>
<b class="nc"><i>3828</i>&nbsp;            private StringBuilder mant;</b>
<b class="nc"><i>3829</i>&nbsp;            private StringBuilder exp;</b>
<b class="nc"><i>3830</i>&nbsp;            private boolean dot = false;</b>
<b class="nc"><i>3831</i>&nbsp;            private int scale;</b>
<i>3832</i>&nbsp;
<b class="nc"><i>3833</i>&nbsp;            public BigDecimalLayout(BigInteger intVal, int scale, BigDecimalLayoutForm form) {</b>
<i>3834</i>&nbsp;                layout(intVal, scale, form);
<i>3835</i>&nbsp;            }
<i>3836</i>&nbsp;
<i>3837</i>&nbsp;            public boolean hasDot() {
<b class="nc"><i>3838</i>&nbsp;                return dot;</b>
<b class="nc"><i>3839</i>&nbsp;            }</b>
<i>3840</i>&nbsp;
<i>3841</i>&nbsp;            public int scale() {
<b class="nc"><i>3842</i>&nbsp;                return scale;</b>
<b class="nc"><i>3843</i>&nbsp;            }</b>
<b class="nc"><i>3844</i>&nbsp;</b>
<i>3845</i>&nbsp;            public StringBuilder mantissa() {
<b class="nc"><i>3846</i>&nbsp;                return mant;</b>
<i>3847</i>&nbsp;            }
<i>3848</i>&nbsp;
<i>3849</i>&nbsp;            // The exponent will be formatted as a sign (&#39;+&#39; or &#39;-&#39;) followed
<i>3850</i>&nbsp;            // by the exponent zero-padded to include at least two digits.
<i>3851</i>&nbsp;            public StringBuilder exponent() {
<i>3852</i>&nbsp;                return exp;
<b class="nc"><i>3853</i>&nbsp;            }</b>
<b class="nc"><i>3854</i>&nbsp;</b>
<b class="nc"><i>3855</i>&nbsp;            private void layout(BigInteger intVal, int scale, BigDecimalLayoutForm form) {</b>
<i>3856</i>&nbsp;                String coeff = intVal.toString();
<i>3857</i>&nbsp;                this.scale = scale;
<i>3858</i>&nbsp;
<i>3859</i>&nbsp;                // Construct a buffer, with sufficient capacity for all cases.
<b class="nc"><i>3860</i>&nbsp;                // If E-notation is needed, length will be: +1 if negative, +1</b>
<b class="nc"><i>3861</i>&nbsp;                // if &#39;.&#39; needed, +2 for &quot;E+&quot;, + up to 10 for adjusted</b>
<b class="nc"><i>3862</i>&nbsp;                // exponent.  Otherwise it could have +1 if negative, plus</b>
<b class="nc"><i>3863</i>&nbsp;                // leading &quot;0.00000&quot;</b>
<i>3864</i>&nbsp;                int len = coeff.length();
<i>3865</i>&nbsp;                mant = new StringBuilder(len + 14);
<i>3866</i>&nbsp;
<b class="nc"><i>3867</i>&nbsp;                if (scale == 0) {</b>
<b class="nc"><i>3868</i>&nbsp;                    if (len &gt; 1) {</b>
<i>3869</i>&nbsp;                        mant.append(coeff.charAt(0));
<i>3870</i>&nbsp;                        if (form == BigDecimalLayoutForm.SCIENTIFIC) {
<b class="nc"><i>3871</i>&nbsp;                            mant.append(&#39;.&#39;);</b>
<b class="nc"><i>3872</i>&nbsp;                            dot = true;</b>
<b class="nc"><i>3873</i>&nbsp;                            mant.append(coeff, 1, len);</b>
<b class="nc"><i>3874</i>&nbsp;                            exp = new StringBuilder(&quot;+&quot;);</b>
<i>3875</i>&nbsp;                            if (len &lt; 10) {
<i>3876</i>&nbsp;                                exp.append(&#39;0&#39;).append(len - 1);
<b class="nc"><i>3877</i>&nbsp;                            } else {</b>
<b class="nc"><i>3878</i>&nbsp;                                exp.append(len - 1);</b>
<b class="nc"><i>3879</i>&nbsp;                            }</b>
<b class="nc"><i>3880</i>&nbsp;                        } else {</b>
<i>3881</i>&nbsp;                            mant.append(coeff, 1, len);
<i>3882</i>&nbsp;                        }
<b class="nc"><i>3883</i>&nbsp;                    } else {</b>
<b class="nc"><i>3884</i>&nbsp;                        mant.append(coeff);</b>
<b class="nc"><i>3885</i>&nbsp;                        if (form == BigDecimalLayoutForm.SCIENTIFIC) {</b>
<b class="nc"><i>3886</i>&nbsp;                            exp = new StringBuilder(&quot;+00&quot;);</b>
<i>3887</i>&nbsp;                        }
<i>3888</i>&nbsp;                    }
<b class="nc"><i>3889</i>&nbsp;                } else if (form == BigDecimalLayoutForm.DECIMAL_FLOAT) {</b>
<b class="nc"><i>3890</i>&nbsp;                    // count of padding zeros</b>
<b class="nc"><i>3891</i>&nbsp;</b>
<b class="nc"><i>3892</i>&nbsp;                    if (scale &gt;= len) {</b>
<i>3893</i>&nbsp;                        // 0.xxx form
<i>3894</i>&nbsp;                        mant.append(&quot;0.&quot;);
<i>3895</i>&nbsp;                        dot = true;
<b class="nc"><i>3896</i>&nbsp;                        trailingZeros(mant, scale - len);</b>
<b class="nc"><i>3897</i>&nbsp;                        mant.append(coeff);</b>
<b class="nc"><i>3898</i>&nbsp;                    } else {</b>
<b class="nc"><i>3899</i>&nbsp;                        if (scale &gt; 0) {</b>
<i>3900</i>&nbsp;                            // xx.xx form
<b class="nc"><i>3901</i>&nbsp;                            int pad = len - scale;</b>
<b class="nc"><i>3902</i>&nbsp;                            mant.append(coeff, 0, pad);</b>
<b class="nc"><i>3903</i>&nbsp;                            mant.append(&#39;.&#39;);</b>
<i>3904</i>&nbsp;                            dot = true;
<i>3905</i>&nbsp;                            mant.append(coeff, pad, len);
<b class="nc"><i>3906</i>&nbsp;                        } else { // scale &lt; 0</b>
<b class="nc"><i>3907</i>&nbsp;                            // xx form</b>
<b class="nc"><i>3908</i>&nbsp;                            mant.append(coeff, 0, len);</b>
<b class="nc"><i>3909</i>&nbsp;                            if (intVal.signum() != 0) {</b>
<i>3910</i>&nbsp;                                trailingZeros(mant, -scale);
<i>3911</i>&nbsp;                            }
<b class="nc"><i>3912</i>&nbsp;                            this.scale = 0;</b>
<b class="nc"><i>3913</i>&nbsp;                        }</b>
<b class="nc"><i>3914</i>&nbsp;                    }</b>
<b class="nc"><i>3915</i>&nbsp;                } else {</b>
<i>3916</i>&nbsp;                    // x.xxx form
<i>3917</i>&nbsp;                    mant.append(coeff.charAt(0));
<b class="nc"><i>3918</i>&nbsp;                    if (len &gt; 1) {</b>
<b class="nc"><i>3919</i>&nbsp;                        mant.append(&#39;.&#39;);</b>
<b class="nc"><i>3920</i>&nbsp;                        dot = true;</b>
<b class="nc"><i>3921</i>&nbsp;                        mant.append(coeff, 1, len);</b>
<b class="nc"><i>3922</i>&nbsp;                    }</b>
<b class="nc"><i>3923</i>&nbsp;                    exp = new StringBuilder();</b>
<i>3924</i>&nbsp;                    long adjusted = -(long) scale + (len - 1);
<b class="nc"><i>3925</i>&nbsp;                    if (adjusted != 0) {</b>
<b class="nc"><i>3926</i>&nbsp;                        long abs = Math.abs(adjusted);</b>
<i>3927</i>&nbsp;                        // require sign
<b class="nc"><i>3928</i>&nbsp;                        exp.append(adjusted &lt; 0 ? &#39;-&#39; : &#39;+&#39;);</b>
<b class="nc"><i>3929</i>&nbsp;                        if (abs &lt; 10) {</b>
<i>3930</i>&nbsp;                            exp.append(&#39;0&#39;);
<i>3931</i>&nbsp;                        }
<b class="nc"><i>3932</i>&nbsp;                        exp.append(abs);</b>
<b class="nc"><i>3933</i>&nbsp;                    } else {</b>
<i>3934</i>&nbsp;                        exp.append(&quot;+00&quot;);
<i>3935</i>&nbsp;                    }
<b class="nc"><i>3936</i>&nbsp;                }</b>
<i>3937</i>&nbsp;            }
<i>3938</i>&nbsp;        }
<i>3939</i>&nbsp;
<i>3940</i>&nbsp;        private int adjustWidth(int width, Flags f, boolean neg) {
<i>3941</i>&nbsp;            int newW = width;
<b class="nc"><i>3942</i>&nbsp;            if (newW != -1 &amp;&amp; neg &amp;&amp; f.contains(Flags.PARENTHESES))</b>
<b class="nc"><i>3943</i>&nbsp;                newW--;</b>
<b class="nc"><i>3944</i>&nbsp;            return newW;</b>
<b class="nc"><i>3945</i>&nbsp;        }</b>
<b class="nc"><i>3946</i>&nbsp;</b>
<i>3947</i>&nbsp;        // Add trailing zeros
<b class="nc"><i>3948</i>&nbsp;        private void trailingZeros(StringBuilder sb, int nzeros) {</b>
<b class="nc"><i>3949</i>&nbsp;            for (int i = 0; i &lt; nzeros; i++) {</b>
<i>3950</i>&nbsp;                sb.append(&#39;0&#39;);
<i>3951</i>&nbsp;            }
<i>3952</i>&nbsp;        }
<i>3953</i>&nbsp;
<b class="nc"><i>3954</i>&nbsp;        private void print(Calendar t, char c, Locale l)  throws IOException {</b>
<b class="nc"><i>3955</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>3956</i>&nbsp;            print(sb, t, c, l);</b>
<b class="nc"><i>3957</i>&nbsp;</b>
<b class="nc"><i>3958</i>&nbsp;            // justify based on width</b>
<i>3959</i>&nbsp;            if (f.contains(Flags.UPPERCASE)) {
<b class="nc"><i>3960</i>&nbsp;                appendJustified(a, toUpperCaseWithLocale(sb.toString(), l));</b>
<b class="nc"><i>3961</i>&nbsp;            } else {</b>
<i>3962</i>&nbsp;                appendJustified(a, sb);
<i>3963</i>&nbsp;            }
<i>3964</i>&nbsp;        }
<i>3965</i>&nbsp;
<b class="nc"><i>3966</i>&nbsp;        private Appendable print(StringBuilder sb, Calendar t, char c, Locale l)</b>
<b class="nc"><i>3967</i>&nbsp;                throws IOException {</b>
<b class="nc"><i>3968</i>&nbsp;            if (sb == null)</b>
<i>3969</i>&nbsp;                sb = new StringBuilder();
<b class="nc"><i>3970</i>&nbsp;            switch (c) {</b>
<b class="nc"><i>3971</i>&nbsp;            case DateTime.HOUR_OF_DAY_0: // &#39;H&#39; (00 - 23)</b>
<i>3972</i>&nbsp;            case DateTime.HOUR_0:        // &#39;I&#39; (01 - 12)
<b class="nc"><i>3973</i>&nbsp;            case DateTime.HOUR_OF_DAY:   // &#39;k&#39; (0 - 23) -- like H</b>
<b class="nc"><i>3974</i>&nbsp;            case DateTime.HOUR:        { // &#39;l&#39; (1 - 12) -- like I</b>
<i>3975</i>&nbsp;                int i = t.get(Calendar.HOUR_OF_DAY);
<b class="nc"><i>3976</i>&nbsp;                if (c == DateTime.HOUR_0 || c == DateTime.HOUR)</b>
<i>3977</i>&nbsp;                    i = (i == 0 || i == 12 ? 12 : i % 12);
<i>3978</i>&nbsp;                Flags flags = (c == DateTime.HOUR_OF_DAY_0
<b class="nc"><i>3979</i>&nbsp;                               || c == DateTime.HOUR_0</b>
<b class="nc"><i>3980</i>&nbsp;                               ? Flags.ZERO_PAD</b>
<b class="nc"><i>3981</i>&nbsp;                               : Flags.NONE);</b>
<i>3982</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 2, l));
<i>3983</i>&nbsp;                break;
<i>3984</i>&nbsp;            }
<b class="nc"><i>3985</i>&nbsp;            case DateTime.MINUTE:      { // &#39;M&#39; (00 - 59)</b>
<b class="nc"><i>3986</i>&nbsp;                int i = t.get(Calendar.MINUTE);</b>
<i>3987</i>&nbsp;                Flags flags = Flags.ZERO_PAD;
<i>3988</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 2, l));
<b class="nc"><i>3989</i>&nbsp;                break;</b>
<b class="nc"><i>3990</i>&nbsp;            }</b>
<i>3991</i>&nbsp;            case DateTime.NANOSECOND:  { // &#39;N&#39; (000000000 - 999999999)
<i>3992</i>&nbsp;                int i = t.get(Calendar.MILLISECOND) * 1000000;
<b class="nc"><i>3993</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>3994</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 9, l));</b>
<b class="nc"><i>3995</i>&nbsp;                break;</b>
<b class="nc"><i>3996</i>&nbsp;            }</b>
<i>3997</i>&nbsp;            case DateTime.MILLISECOND: { // &#39;L&#39; (000 - 999)
<i>3998</i>&nbsp;                int i = t.get(Calendar.MILLISECOND);
<b class="nc"><i>3999</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4000</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 3, l));</b>
<b class="nc"><i>4001</i>&nbsp;                break;</b>
<b class="nc"><i>4002</i>&nbsp;            }</b>
<i>4003</i>&nbsp;            case DateTime.MILLISECOND_SINCE_EPOCH: { // &#39;Q&#39; (0 - 99...?)
<i>4004</i>&nbsp;                long i = t.getTimeInMillis();
<i>4005</i>&nbsp;                Flags flags = Flags.NONE;
<i>4006</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, width, l));
<i>4007</i>&nbsp;                break;
<b class="nc"><i>4008</i>&nbsp;            }</b>
<b class="nc"><i>4009</i>&nbsp;            case DateTime.AM_PM:       { // &#39;p&#39; (am or pm)</b>
<b class="nc"><i>4010</i>&nbsp;                // Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper</b>
<b class="nc"><i>4011</i>&nbsp;                String[] ampm = { &quot;AM&quot;, &quot;PM&quot; };</b>
<b class="nc"><i>4012</i>&nbsp;                if (l != null &amp;&amp; l != Locale.US) {</b>
<b class="nc"><i>4013</i>&nbsp;                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(l);</b>
<i>4014</i>&nbsp;                    ampm = dfs.getAmPmStrings();
<i>4015</i>&nbsp;                }
<i>4016</i>&nbsp;                String s = ampm[t.get(Calendar.AM_PM)];
<i>4017</i>&nbsp;                sb.append(s.toLowerCase(Objects.requireNonNullElse(l,
<b class="nc"><i>4018</i>&nbsp;                            Locale.getDefault(Locale.Category.FORMAT))));</b>
<b class="nc"><i>4019</i>&nbsp;                break;</b>
<b class="nc"><i>4020</i>&nbsp;            }</b>
<b class="nc"><i>4021</i>&nbsp;            case DateTime.SECONDS_SINCE_EPOCH: { // &#39;s&#39; (0 - 99...?)</b>
<i>4022</i>&nbsp;                long i = t.getTimeInMillis() / 1000;
<b class="nc"><i>4023</i>&nbsp;                Flags flags = Flags.NONE;</b>
<b class="nc"><i>4024</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, width, l));</b>
<b class="nc"><i>4025</i>&nbsp;                break;</b>
<b class="nc"><i>4026</i>&nbsp;            }</b>
<i>4027</i>&nbsp;            case DateTime.SECOND:      { // &#39;S&#39; (00 - 60 - leap second)
<i>4028</i>&nbsp;                int i = t.get(Calendar.SECOND);
<b class="nc"><i>4029</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4030</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 2, l));</b>
<b class="nc"><i>4031</i>&nbsp;                break;</b>
<b class="nc"><i>4032</i>&nbsp;            }</b>
<b class="nc"><i>4033</i>&nbsp;            case DateTime.ZONE_NUMERIC: { // &#39;z&#39; ({-|+}####) - ls minus?</b>
<b class="nc"><i>4034</i>&nbsp;                int i = t.get(Calendar.ZONE_OFFSET) + t.get(Calendar.DST_OFFSET);</b>
<b class="nc"><i>4035</i>&nbsp;                boolean neg = i &lt; 0;</b>
<b class="nc"><i>4036</i>&nbsp;                sb.append(neg ? &#39;-&#39; : &#39;+&#39;);</b>
<i>4037</i>&nbsp;                if (neg)
<i>4038</i>&nbsp;                    i = -i;
<b class="nc"><i>4039</i>&nbsp;                int min = i / 60000;</b>
<b class="nc"><i>4040</i>&nbsp;                // combine minute and hour into a single integer</b>
<b class="nc"><i>4041</i>&nbsp;                int offset = (min / 60) * 100 + (min % 60);</b>
<b class="nc"><i>4042</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4043</i>&nbsp;</b>
<i>4044</i>&nbsp;                sb.append(localizedMagnitude(null, offset, flags, 4, l));
<i>4045</i>&nbsp;                break;
<b class="nc"><i>4046</i>&nbsp;            }</b>
<b class="nc"><i>4047</i>&nbsp;            case DateTime.ZONE:        { // &#39;Z&#39; (symbol)</b>
<b class="nc"><i>4048</i>&nbsp;                TimeZone tz = t.getTimeZone();</b>
<b class="nc"><i>4049</i>&nbsp;                sb.append(tz.getDisplayName((t.get(Calendar.DST_OFFSET) != 0),</b>
<b class="nc"><i>4050</i>&nbsp;                                           TimeZone.SHORT,</b>
<i>4051</i>&nbsp;                                           Objects.requireNonNullElse(l, Locale.US)));
<i>4052</i>&nbsp;                break;
<b class="nc"><i>4053</i>&nbsp;            }</b>
<i>4054</i>&nbsp;
<b class="nc"><i>4055</i>&nbsp;            // Date</b>
<i>4056</i>&nbsp;            case DateTime.NAME_OF_DAY_ABBREV:     // &#39;a&#39;
<i>4057</i>&nbsp;            case DateTime.NAME_OF_DAY:          { // &#39;A&#39;
<i>4058</i>&nbsp;                int i = t.get(Calendar.DAY_OF_WEEK);
<b class="nc"><i>4059</i>&nbsp;                Locale lt = Objects.requireNonNullElse(l, Locale.US);</b>
<b class="nc"><i>4060</i>&nbsp;                DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);</b>
<i>4061</i>&nbsp;                if (c == DateTime.NAME_OF_DAY)
<b class="nc"><i>4062</i>&nbsp;                    sb.append(dfs.getWeekdays()[i]);</b>
<b class="nc"><i>4063</i>&nbsp;                else</b>
<b class="nc"><i>4064</i>&nbsp;                    sb.append(dfs.getShortWeekdays()[i]);</b>
<b class="nc"><i>4065</i>&nbsp;                break;</b>
<i>4066</i>&nbsp;            }
<i>4067</i>&nbsp;            case DateTime.NAME_OF_MONTH_ABBREV:   // &#39;b&#39;
<i>4068</i>&nbsp;            case DateTime.NAME_OF_MONTH_ABBREV_X: // &#39;h&#39; -- same b
<i>4069</i>&nbsp;            case DateTime.NAME_OF_MONTH:        { // &#39;B&#39;
<b class="nc"><i>4070</i>&nbsp;                int i = t.get(Calendar.MONTH);</b>
<b class="nc"><i>4071</i>&nbsp;                Locale lt = Objects.requireNonNullElse(l, Locale.US);</b>
<i>4072</i>&nbsp;                DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);
<b class="nc"><i>4073</i>&nbsp;                if (c == DateTime.NAME_OF_MONTH)</b>
<i>4074</i>&nbsp;                    sb.append(dfs.getMonths()[i]);
<b class="nc"><i>4075</i>&nbsp;                else</b>
<b class="nc"><i>4076</i>&nbsp;                    sb.append(dfs.getShortMonths()[i]);</b>
<b class="nc"><i>4077</i>&nbsp;                break;</b>
<i>4078</i>&nbsp;            }
<i>4079</i>&nbsp;            case DateTime.CENTURY:                // &#39;C&#39; (00 - 99)
<b class="nc"><i>4080</i>&nbsp;            case DateTime.YEAR_2:                 // &#39;y&#39; (00 - 99)</b>
<b class="nc"><i>4081</i>&nbsp;            case DateTime.YEAR_4:               { // &#39;Y&#39; (0000 - 9999)</b>
<b class="nc"><i>4082</i>&nbsp;                int i = t.get(Calendar.YEAR);</b>
<i>4083</i>&nbsp;                int size = 2;
<i>4084</i>&nbsp;                switch (c) {
<b class="nc"><i>4085</i>&nbsp;                case DateTime.CENTURY:</b>
<b class="nc"><i>4086</i>&nbsp;                    i /= 100;</b>
<b class="nc"><i>4087</i>&nbsp;                    break;</b>
<i>4088</i>&nbsp;                case DateTime.YEAR_2:
<i>4089</i>&nbsp;                    i %= 100;
<b class="nc"><i>4090</i>&nbsp;                    break;</b>
<b class="nc"><i>4091</i>&nbsp;                case DateTime.YEAR_4:</b>
<b class="nc"><i>4092</i>&nbsp;                    size = 4;</b>
<i>4093</i>&nbsp;                    break;
<i>4094</i>&nbsp;                }
<b class="nc"><i>4095</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4096</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, size, l));</b>
<b class="nc"><i>4097</i>&nbsp;                break;</b>
<b class="nc"><i>4098</i>&nbsp;            }</b>
<i>4099</i>&nbsp;            case DateTime.DAY_OF_MONTH_0:         // &#39;d&#39; (01 - 31)
<i>4100</i>&nbsp;            case DateTime.DAY_OF_MONTH:         { // &#39;e&#39; (1 - 31) -- like d
<b class="nc"><i>4101</i>&nbsp;                int i = t.get(Calendar.DATE);</b>
<b class="nc"><i>4102</i>&nbsp;                Flags flags = (c == DateTime.DAY_OF_MONTH_0</b>
<b class="nc"><i>4103</i>&nbsp;                               ? Flags.ZERO_PAD</b>
<b class="nc"><i>4104</i>&nbsp;                               : Flags.NONE);</b>
<i>4105</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 2, l));
<i>4106</i>&nbsp;                break;
<b class="nc"><i>4107</i>&nbsp;            }</b>
<b class="nc"><i>4108</i>&nbsp;            case DateTime.DAY_OF_YEAR:          { // &#39;j&#39; (001 - 366)</b>
<b class="nc"><i>4109</i>&nbsp;                int i = t.get(Calendar.DAY_OF_YEAR);</b>
<b class="nc"><i>4110</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<i>4111</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 3, l));
<i>4112</i>&nbsp;                break;
<b class="nc"><i>4113</i>&nbsp;            }</b>
<b class="nc"><i>4114</i>&nbsp;            case DateTime.MONTH:                { // &#39;m&#39; (01 - 12)</b>
<b class="nc"><i>4115</i>&nbsp;                int i = t.get(Calendar.MONTH) + 1;</b>
<b class="nc"><i>4116</i>&nbsp;                Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4117</i>&nbsp;                sb.append(localizedMagnitude(null, i, flags, 2, l));</b>
<i>4118</i>&nbsp;                break;
<i>4119</i>&nbsp;            }
<i>4120</i>&nbsp;
<b class="nc"><i>4121</i>&nbsp;            // Composites</b>
<b class="nc"><i>4122</i>&nbsp;            case DateTime.TIME:         // &#39;T&#39; (24 hour hh:mm:ss - %tH:%tM:%tS)</b>
<b class="nc"><i>4123</i>&nbsp;            case DateTime.TIME_24_HOUR:    { // &#39;R&#39; (hh:mm same as %H:%M)</b>
<b class="nc"><i>4124</i>&nbsp;                char sep = &#39;:&#39;;</b>
<i>4125</i>&nbsp;                print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);
<b class="nc"><i>4126</i>&nbsp;                print(sb, t, DateTime.MINUTE, l);</b>
<b class="nc"><i>4127</i>&nbsp;                if (c == DateTime.TIME) {</b>
<b class="nc"><i>4128</i>&nbsp;                    sb.append(sep);</b>
<i>4129</i>&nbsp;                    print(sb, t, DateTime.SECOND, l);
<i>4130</i>&nbsp;                }
<b class="nc"><i>4131</i>&nbsp;                break;</b>
<b class="nc"><i>4132</i>&nbsp;            }</b>
<b class="nc"><i>4133</i>&nbsp;            case DateTime.TIME_12_HOUR:    { // &#39;r&#39; (hh:mm:ss [AP]M)</b>
<b class="nc"><i>4134</i>&nbsp;                char sep = &#39;:&#39;;</b>
<i>4135</i>&nbsp;                print(sb, t, DateTime.HOUR_0, l).append(sep);
<i>4136</i>&nbsp;                print(sb, t, DateTime.MINUTE, l).append(sep);
<b class="nc"><i>4137</i>&nbsp;                print(sb, t, DateTime.SECOND, l).append(&#39; &#39;);</b>
<b class="nc"><i>4138</i>&nbsp;                // this may be in wrong place for some locales</b>
<b class="nc"><i>4139</i>&nbsp;                StringBuilder tsb = new StringBuilder();</b>
<b class="nc"><i>4140</i>&nbsp;                print(tsb, t, DateTime.AM_PM, l);</b>
<i>4141</i>&nbsp;
<i>4142</i>&nbsp;                sb.append(toUpperCaseWithLocale(tsb.toString(), l));
<b class="nc"><i>4143</i>&nbsp;                break;</b>
<b class="nc"><i>4144</i>&nbsp;            }</b>
<b class="nc"><i>4145</i>&nbsp;            case DateTime.DATE_TIME:    { // &#39;c&#39; (Sat Nov 04 12:02:33 EST 1999)</b>
<b class="nc"><i>4146</i>&nbsp;                char sep = &#39; &#39;;</b>
<b class="nc"><i>4147</i>&nbsp;                print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);</b>
<b class="nc"><i>4148</i>&nbsp;                print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);</b>
<i>4149</i>&nbsp;                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);
<b class="nc"><i>4150</i>&nbsp;                print(sb, t, DateTime.TIME, l).append(sep);</b>
<b class="nc"><i>4151</i>&nbsp;                print(sb, t, DateTime.ZONE, l).append(sep);</b>
<b class="nc"><i>4152</i>&nbsp;                print(sb, t, DateTime.YEAR_4, l);</b>
<b class="nc"><i>4153</i>&nbsp;                break;</b>
<i>4154</i>&nbsp;            }
<i>4155</i>&nbsp;            case DateTime.DATE:            { // &#39;D&#39; (mm/dd/yy)
<b class="nc"><i>4156</i>&nbsp;                char sep = &#39;/&#39;;</b>
<b class="nc"><i>4157</i>&nbsp;                print(sb, t, DateTime.MONTH, l).append(sep);</b>
<b class="nc"><i>4158</i>&nbsp;                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</b>
<i>4159</i>&nbsp;                print(sb, t, DateTime.YEAR_2, l);
<b class="nc"><i>4160</i>&nbsp;                break;</b>
<b class="nc"><i>4161</i>&nbsp;            }</b>
<b class="nc"><i>4162</i>&nbsp;            case DateTime.ISO_STANDARD_DATE: { // &#39;F&#39; (%Y-%m-%d)</b>
<b class="nc"><i>4163</i>&nbsp;                char sep = &#39;-&#39;;</b>
<b class="nc"><i>4164</i>&nbsp;                print(sb, t, DateTime.YEAR_4, l).append(sep);</b>
<i>4165</i>&nbsp;                print(sb, t, DateTime.MONTH, l).append(sep);
<i>4166</i>&nbsp;                print(sb, t, DateTime.DAY_OF_MONTH_0, l);
<b class="nc"><i>4167</i>&nbsp;                break;</b>
<i>4168</i>&nbsp;            }
<b class="nc"><i>4169</i>&nbsp;            default:</b>
<b class="nc"><i>4170</i>&nbsp;                assert false;</b>
<i>4171</i>&nbsp;            }
<i>4172</i>&nbsp;            return sb;
<i>4173</i>&nbsp;        }
<i>4174</i>&nbsp;
<b class="nc"><i>4175</i>&nbsp;        private void print(TemporalAccessor t, char c, Locale l)  throws IOException {</b>
<b class="nc"><i>4176</i>&nbsp;            StringBuilder sb = new StringBuilder();</b>
<b class="nc"><i>4177</i>&nbsp;            print(sb, t, c, l);</b>
<b class="nc"><i>4178</i>&nbsp;            // justify based on width</b>
<b class="nc"><i>4179</i>&nbsp;            if (f.contains(Flags.UPPERCASE)) {</b>
<i>4180</i>&nbsp;                appendJustified(a, toUpperCaseWithLocale(sb.toString(), l));
<b class="nc"><i>4181</i>&nbsp;            } else {</b>
<b class="nc"><i>4182</i>&nbsp;                appendJustified(a, sb);</b>
<i>4183</i>&nbsp;            }
<i>4184</i>&nbsp;        }
<i>4185</i>&nbsp;
<i>4186</i>&nbsp;        private Appendable print(StringBuilder sb, TemporalAccessor t, char c,
<b class="nc"><i>4187</i>&nbsp;                                 Locale l) throws IOException {</b>
<b class="nc"><i>4188</i>&nbsp;            if (sb == null)</b>
<b class="nc"><i>4189</i>&nbsp;                sb = new StringBuilder();</b>
<b class="nc"><i>4190</i>&nbsp;            try {</b>
<b class="nc"><i>4191</i>&nbsp;                switch (c) {</b>
<i>4192</i>&nbsp;                case DateTime.HOUR_OF_DAY_0: {  // &#39;H&#39; (00 - 23)
<b class="nc"><i>4193</i>&nbsp;                    int i = t.get(ChronoField.HOUR_OF_DAY);</b>
<b class="nc"><i>4194</i>&nbsp;                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));</b>
<i>4195</i>&nbsp;                    break;
<i>4196</i>&nbsp;                }
<i>4197</i>&nbsp;                case DateTime.HOUR_OF_DAY: {   // &#39;k&#39; (0 - 23) -- like H
<i>4198</i>&nbsp;                    int i = t.get(ChronoField.HOUR_OF_DAY);
<b class="nc"><i>4199</i>&nbsp;                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));</b>
<b class="nc"><i>4200</i>&nbsp;                    break;</b>
<b class="nc"><i>4201</i>&nbsp;                }</b>
<i>4202</i>&nbsp;                case DateTime.HOUR_0:      {  // &#39;I&#39; (01 - 12)
<b class="nc"><i>4203</i>&nbsp;                    int i = t.get(ChronoField.CLOCK_HOUR_OF_AMPM);</b>
<b class="nc"><i>4204</i>&nbsp;                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));</b>
<i>4205</i>&nbsp;                    break;
<b class="nc"><i>4206</i>&nbsp;                }</b>
<b class="nc"><i>4207</i>&nbsp;                case DateTime.HOUR:        { // &#39;l&#39; (1 - 12) -- like I</b>
<i>4208</i>&nbsp;                    int i = t.get(ChronoField.CLOCK_HOUR_OF_AMPM);
<b class="nc"><i>4209</i>&nbsp;                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));</b>
<i>4210</i>&nbsp;                    break;
<i>4211</i>&nbsp;                }
<b class="nc"><i>4212</i>&nbsp;                case DateTime.MINUTE:      { // &#39;M&#39; (00 - 59)</b>
<b class="nc"><i>4213</i>&nbsp;                    int i = t.get(ChronoField.MINUTE_OF_HOUR);</b>
<b class="nc"><i>4214</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;</b>
<i>4215</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 2, l));
<i>4216</i>&nbsp;                    break;
<i>4217</i>&nbsp;                }
<b class="nc"><i>4218</i>&nbsp;                case DateTime.NANOSECOND:  { // &#39;N&#39; (000000000 - 999999999)</b>
<b class="nc"><i>4219</i>&nbsp;                    int i;</b>
<i>4220</i>&nbsp;                    try {
<i>4221</i>&nbsp;                        i = t.get(ChronoField.NANO_OF_SECOND);
<b class="nc"><i>4222</i>&nbsp;                    } catch (UnsupportedTemporalTypeException u) {</b>
<b class="nc"><i>4223</i>&nbsp;                        i = t.get(ChronoField.MILLI_OF_SECOND) * 1000000;</b>
<i>4224</i>&nbsp;                    }
<i>4225</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;
<b class="nc"><i>4226</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 9, l));</b>
<b class="nc"><i>4227</i>&nbsp;                    break;</b>
<b class="nc"><i>4228</i>&nbsp;                }</b>
<b class="nc"><i>4229</i>&nbsp;                case DateTime.MILLISECOND: { // &#39;L&#39; (000 - 999)</b>
<i>4230</i>&nbsp;                    int i = t.get(ChronoField.MILLI_OF_SECOND);
<i>4231</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;
<b class="nc"><i>4232</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 3, l));</b>
<b class="nc"><i>4233</i>&nbsp;                    break;</b>
<b class="nc"><i>4234</i>&nbsp;                }</b>
<b class="nc"><i>4235</i>&nbsp;                case DateTime.MILLISECOND_SINCE_EPOCH: { // &#39;Q&#39; (0 - 99...?)</b>
<i>4236</i>&nbsp;                    long i = t.getLong(ChronoField.INSTANT_SECONDS) * 1000L +
<i>4237</i>&nbsp;                             t.getLong(ChronoField.MILLI_OF_SECOND);
<i>4238</i>&nbsp;                    Flags flags = Flags.NONE;
<i>4239</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, width, l));
<i>4240</i>&nbsp;                    break;
<b class="nc"><i>4241</i>&nbsp;                }</b>
<b class="nc"><i>4242</i>&nbsp;                case DateTime.AM_PM:       { // &#39;p&#39; (am or pm)</b>
<b class="nc"><i>4243</i>&nbsp;                    // Calendar.AM = 0, Calendar.PM = 1, LocaleElements defines upper</b>
<b class="nc"><i>4244</i>&nbsp;                    String[] ampm = { &quot;AM&quot;, &quot;PM&quot; };</b>
<b class="nc"><i>4245</i>&nbsp;                    if (l != null &amp;&amp; l != Locale.US) {</b>
<b class="nc"><i>4246</i>&nbsp;                        DateFormatSymbols dfs = DateFormatSymbols.getInstance(l);</b>
<i>4247</i>&nbsp;                        ampm = dfs.getAmPmStrings();
<i>4248</i>&nbsp;                    }
<i>4249</i>&nbsp;                    String s = ampm[t.get(ChronoField.AMPM_OF_DAY)];
<i>4250</i>&nbsp;                    sb.append(s.toLowerCase(Objects.requireNonNullElse(l,
<b class="nc"><i>4251</i>&nbsp;                            Locale.getDefault(Locale.Category.FORMAT))));</b>
<b class="nc"><i>4252</i>&nbsp;                    break;</b>
<b class="nc"><i>4253</i>&nbsp;                }</b>
<b class="nc"><i>4254</i>&nbsp;                case DateTime.SECONDS_SINCE_EPOCH: { // &#39;s&#39; (0 - 99...?)</b>
<i>4255</i>&nbsp;                    long i = t.getLong(ChronoField.INSTANT_SECONDS);
<b class="nc"><i>4256</i>&nbsp;                    Flags flags = Flags.NONE;</b>
<b class="nc"><i>4257</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, width, l));</b>
<b class="nc"><i>4258</i>&nbsp;                    break;</b>
<b class="nc"><i>4259</i>&nbsp;                }</b>
<i>4260</i>&nbsp;                case DateTime.SECOND:      { // &#39;S&#39; (00 - 60 - leap second)
<i>4261</i>&nbsp;                    int i = t.get(ChronoField.SECOND_OF_MINUTE);
<b class="nc"><i>4262</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4263</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 2, l));</b>
<b class="nc"><i>4264</i>&nbsp;                    break;</b>
<b class="nc"><i>4265</i>&nbsp;                }</b>
<b class="nc"><i>4266</i>&nbsp;                case DateTime.ZONE_NUMERIC: { // &#39;z&#39; ({-|+}####) - ls minus?</b>
<b class="nc"><i>4267</i>&nbsp;                    int i = t.get(ChronoField.OFFSET_SECONDS);</b>
<b class="nc"><i>4268</i>&nbsp;                    boolean neg = i &lt; 0;</b>
<b class="nc"><i>4269</i>&nbsp;                    sb.append(neg ? &#39;-&#39; : &#39;+&#39;);</b>
<i>4270</i>&nbsp;                    if (neg)
<i>4271</i>&nbsp;                        i = -i;
<b class="nc"><i>4272</i>&nbsp;                    int min = i / 60;</b>
<b class="nc"><i>4273</i>&nbsp;                    // combine minute and hour into a single integer</b>
<b class="nc"><i>4274</i>&nbsp;                    int offset = (min / 60) * 100 + (min % 60);</b>
<b class="nc"><i>4275</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4276</i>&nbsp;                    sb.append(localizedMagnitude(null, offset, flags, 4, l));</b>
<i>4277</i>&nbsp;                    break;
<i>4278</i>&nbsp;                }
<b class="nc"><i>4279</i>&nbsp;                case DateTime.ZONE:        { // &#39;Z&#39; (symbol)</b>
<b class="nc"><i>4280</i>&nbsp;                    ZoneId zid = t.query(TemporalQueries.zone());</b>
<b class="nc"><i>4281</i>&nbsp;                    if (zid == null) {</b>
<b class="nc"><i>4282</i>&nbsp;                        throw new IllegalFormatConversionException(c, t.getClass());</b>
<b class="nc"><i>4283</i>&nbsp;                    }</b>
<i>4284</i>&nbsp;                    if (!(zid instanceof ZoneOffset) &amp;&amp;
<i>4285</i>&nbsp;                        t.isSupported(ChronoField.INSTANT_SECONDS)) {
<b class="nc"><i>4286</i>&nbsp;                        Instant instant = Instant.from(t);</b>
<i>4287</i>&nbsp;                        sb.append(TimeZone.getTimeZone(zid.getId())
<b class="nc"><i>4288</i>&nbsp;                                          .getDisplayName(zid.getRules().isDaylightSavings(instant),</b>
<b class="nc"><i>4289</i>&nbsp;                                                          TimeZone.SHORT,</b>
<b class="nc"><i>4290</i>&nbsp;                                                          Objects.requireNonNullElse(l, Locale.US)));</b>
<b class="nc"><i>4291</i>&nbsp;                        break;</b>
<i>4292</i>&nbsp;                    }
<i>4293</i>&nbsp;                    sb.append(zid.getId());
<i>4294</i>&nbsp;                    break;
<i>4295</i>&nbsp;                }
<i>4296</i>&nbsp;                // Date
<b class="nc"><i>4297</i>&nbsp;                case DateTime.NAME_OF_DAY_ABBREV:     // &#39;a&#39;</b>
<b class="nc"><i>4298</i>&nbsp;                case DateTime.NAME_OF_DAY:          { // &#39;A&#39;</b>
<i>4299</i>&nbsp;                    int i = t.get(ChronoField.DAY_OF_WEEK) % 7 + 1;
<i>4300</i>&nbsp;                    Locale lt = Objects.requireNonNullElse(l, Locale.US);
<i>4301</i>&nbsp;                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);
<b class="nc"><i>4302</i>&nbsp;                    if (c == DateTime.NAME_OF_DAY)</b>
<i>4303</i>&nbsp;                        sb.append(dfs.getWeekdays()[i]);
<i>4304</i>&nbsp;                    else
<i>4305</i>&nbsp;                        sb.append(dfs.getShortWeekdays()[i]);
<b class="nc"><i>4306</i>&nbsp;                    break;</b>
<b class="nc"><i>4307</i>&nbsp;                }</b>
<b class="nc"><i>4308</i>&nbsp;                case DateTime.NAME_OF_MONTH_ABBREV:   // &#39;b&#39;</b>
<i>4309</i>&nbsp;                case DateTime.NAME_OF_MONTH_ABBREV_X: // &#39;h&#39; -- same b
<b class="nc"><i>4310</i>&nbsp;                case DateTime.NAME_OF_MONTH:        { // &#39;B&#39;</b>
<i>4311</i>&nbsp;                    int i = t.get(ChronoField.MONTH_OF_YEAR) - 1;
<i>4312</i>&nbsp;                    Locale lt = Objects.requireNonNullElse(l, Locale.US);
<i>4313</i>&nbsp;                    DateFormatSymbols dfs = DateFormatSymbols.getInstance(lt);
<i>4314</i>&nbsp;                    if (c == DateTime.NAME_OF_MONTH)
<i>4315</i>&nbsp;                        sb.append(dfs.getMonths()[i]);
<i>4316</i>&nbsp;                    else
<b class="nc"><i>4317</i>&nbsp;                        sb.append(dfs.getShortMonths()[i]);</b>
<b class="nc"><i>4318</i>&nbsp;                    break;</b>
<i>4319</i>&nbsp;                }
<i>4320</i>&nbsp;                case DateTime.CENTURY:                // &#39;C&#39; (00 - 99)
<i>4321</i>&nbsp;                case DateTime.YEAR_2:                 // &#39;y&#39; (00 - 99)
<i>4322</i>&nbsp;                case DateTime.YEAR_4:               { // &#39;Y&#39; (0000 - 9999)
<i>4323</i>&nbsp;                    int i = t.get(ChronoField.YEAR_OF_ERA);
<i>4324</i>&nbsp;                    int size = 2;
<b class="nc"><i>4325</i>&nbsp;                    switch (c) {</b>
<b class="nc"><i>4326</i>&nbsp;                    case DateTime.CENTURY:</b>
<b class="nc"><i>4327</i>&nbsp;                        i /= 100;</b>
<i>4328</i>&nbsp;                        break;
<b class="nc"><i>4329</i>&nbsp;                    case DateTime.YEAR_2:</b>
<i>4330</i>&nbsp;                        i %= 100;
<i>4331</i>&nbsp;                        break;
<b class="nc"><i>4332</i>&nbsp;                    case DateTime.YEAR_4:</b>
<b class="nc"><i>4333</i>&nbsp;                        size = 4;</b>
<b class="nc"><i>4334</i>&nbsp;                        break;</b>
<i>4335</i>&nbsp;                    }
<b class="nc"><i>4336</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;</b>
<b class="nc"><i>4337</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, size, l));</b>
<b class="nc"><i>4338</i>&nbsp;                    break;</b>
<b class="nc"><i>4339</i>&nbsp;                }</b>
<b class="nc"><i>4340</i>&nbsp;                case DateTime.DAY_OF_MONTH_0:         // &#39;d&#39; (01 - 31)</b>
<b class="nc"><i>4341</i>&nbsp;                case DateTime.DAY_OF_MONTH:         { // &#39;e&#39; (1 - 31) -- like d</b>
<i>4342</i>&nbsp;                    int i = t.get(ChronoField.DAY_OF_MONTH);
<i>4343</i>&nbsp;                    Flags flags = (c == DateTime.DAY_OF_MONTH_0
<i>4344</i>&nbsp;                                   ? Flags.ZERO_PAD
<b class="nc"><i>4345</i>&nbsp;                                   : Flags.NONE);</b>
<b class="nc"><i>4346</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 2, l));</b>
<b class="nc"><i>4347</i>&nbsp;                    break;</b>
<i>4348</i>&nbsp;                }
<b class="nc"><i>4349</i>&nbsp;                case DateTime.DAY_OF_YEAR:          { // &#39;j&#39; (001 - 366)</b>
<b class="nc"><i>4350</i>&nbsp;                    int i = t.get(ChronoField.DAY_OF_YEAR);</b>
<i>4351</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;
<i>4352</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 3, l));
<i>4353</i>&nbsp;                    break;
<b class="nc"><i>4354</i>&nbsp;                }</b>
<b class="nc"><i>4355</i>&nbsp;                case DateTime.MONTH:                { // &#39;m&#39; (01 - 12)</b>
<b class="nc"><i>4356</i>&nbsp;                    int i = t.get(ChronoField.MONTH_OF_YEAR);</b>
<b class="nc"><i>4357</i>&nbsp;                    Flags flags = Flags.ZERO_PAD;</b>
<i>4358</i>&nbsp;                    sb.append(localizedMagnitude(null, i, flags, 2, l));
<b class="nc"><i>4359</i>&nbsp;                    break;</b>
<b class="nc"><i>4360</i>&nbsp;                }</b>
<b class="nc"><i>4361</i>&nbsp;</b>
<b class="nc"><i>4362</i>&nbsp;                // Composites</b>
<i>4363</i>&nbsp;                case DateTime.TIME:         // &#39;T&#39; (24 hour hh:mm:ss - %tH:%tM:%tS)
<i>4364</i>&nbsp;                case DateTime.TIME_24_HOUR:    { // &#39;R&#39; (hh:mm same as %H:%M)
<i>4365</i>&nbsp;                    char sep = &#39;:&#39;;
<i>4366</i>&nbsp;                    print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);
<b class="nc"><i>4367</i>&nbsp;                    print(sb, t, DateTime.MINUTE, l);</b>
<b class="nc"><i>4368</i>&nbsp;                    if (c == DateTime.TIME) {</b>
<b class="nc"><i>4369</i>&nbsp;                        sb.append(sep);</b>
<i>4370</i>&nbsp;                        print(sb, t, DateTime.SECOND, l);
<b class="nc"><i>4371</i>&nbsp;                    }</b>
<b class="nc"><i>4372</i>&nbsp;                    break;</b>
<i>4373</i>&nbsp;                }
<i>4374</i>&nbsp;                case DateTime.TIME_12_HOUR:    { // &#39;r&#39; (hh:mm:ss [AP]M)
<b class="nc"><i>4375</i>&nbsp;                    char sep = &#39;:&#39;;</b>
<b class="nc"><i>4376</i>&nbsp;                    print(sb, t, DateTime.HOUR_0, l).append(sep);</b>
<b class="nc"><i>4377</i>&nbsp;                    print(sb, t, DateTime.MINUTE, l).append(sep);</b>
<b class="nc"><i>4378</i>&nbsp;                    print(sb, t, DateTime.SECOND, l).append(&#39; &#39;);</b>
<i>4379</i>&nbsp;                    // this may be in wrong place for some locales
<i>4380</i>&nbsp;                    StringBuilder tsb = new StringBuilder();
<i>4381</i>&nbsp;                    print(tsb, t, DateTime.AM_PM, l);
<b class="nc"><i>4382</i>&nbsp;                    sb.append(toUpperCaseWithLocale(tsb.toString(), l));</b>
<b class="nc"><i>4383</i>&nbsp;                    break;</b>
<b class="nc"><i>4384</i>&nbsp;                }</b>
<b class="nc"><i>4385</i>&nbsp;                case DateTime.DATE_TIME:    { // &#39;c&#39; (Sat Nov 04 12:02:33 EST 1999)</b>
<i>4386</i>&nbsp;                    char sep = &#39; &#39;;
<b class="nc"><i>4387</i>&nbsp;                    print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);</b>
<i>4388</i>&nbsp;                    print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);
<i>4389</i>&nbsp;                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);
<i>4390</i>&nbsp;                    print(sb, t, DateTime.TIME, l).append(sep);
<b class="nc"><i>4391</i>&nbsp;                    print(sb, t, DateTime.ZONE, l).append(sep);</b>
<i>4392</i>&nbsp;                    print(sb, t, DateTime.YEAR_4, l);
<i>4393</i>&nbsp;                    break;
<b class="nc"><i>4394</i>&nbsp;                }</b>
<i>4395</i>&nbsp;                case DateTime.DATE:            { // &#39;D&#39; (mm/dd/yy)
<i>4396</i>&nbsp;                    char sep = &#39;/&#39;;
<b class="nc"><i>4397</i>&nbsp;                    print(sb, t, DateTime.MONTH, l).append(sep);</b>
<b class="nc"><i>4398</i>&nbsp;                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);</b>
<b class="nc"><i>4399</i>&nbsp;                    print(sb, t, DateTime.YEAR_2, l);</b>
<i>4400</i>&nbsp;                    break;
<i>4401</i>&nbsp;                }
<b class="nc"><i>4402</i>&nbsp;                case DateTime.ISO_STANDARD_DATE: { // &#39;F&#39; (%Y-%m-%d)</b>
<b class="nc"><i>4403</i>&nbsp;                    char sep = &#39;-&#39;;</b>
<b class="nc"><i>4404</i>&nbsp;                    print(sb, t, DateTime.YEAR_4, l).append(sep);</b>
<b class="nc"><i>4405</i>&nbsp;                    print(sb, t, DateTime.MONTH, l).append(sep);</b>
<b class="nc"><i>4406</i>&nbsp;                    print(sb, t, DateTime.DAY_OF_MONTH_0, l);</b>
<i>4407</i>&nbsp;                    break;
<i>4408</i>&nbsp;                }
<b class="nc"><i>4409</i>&nbsp;                default:</b>
<i>4410</i>&nbsp;                    assert false;
<b class="nc"><i>4411</i>&nbsp;                }</b>
<b class="nc"><i>4412</i>&nbsp;            } catch (DateTimeException x) {</b>
<i>4413</i>&nbsp;                throw new IllegalFormatConversionException(c, t.getClass());
<i>4414</i>&nbsp;            }
<i>4415</i>&nbsp;            return sb;
<b class="nc"><i>4416</i>&nbsp;        }</b>
<i>4417</i>&nbsp;
<i>4418</i>&nbsp;        // -- Methods to support throwing exceptions --
<i>4419</i>&nbsp;
<b class="nc"><i>4420</i>&nbsp;        private void failMismatch(Flags f, char c) {</b>
<i>4421</i>&nbsp;            String fs = f.toString();
<i>4422</i>&nbsp;            throw new FormatFlagsConversionMismatchException(fs, c);
<i>4423</i>&nbsp;        }
<b class="nc"><i>4424</i>&nbsp;</b>
<i>4425</i>&nbsp;        private void failConversion(char c, Object arg) {
<i>4426</i>&nbsp;            throw new IllegalFormatConversionException(c, arg.getClass());
<i>4427</i>&nbsp;        }
<b class="nc"><i>4428</i>&nbsp;</b>
<b class="nc"><i>4429</i>&nbsp;        private char getZero(Locale l) {</b>
<i>4430</i>&nbsp;            if ((l != null) &amp;&amp;  !l.equals(locale())) {
<i>4431</i>&nbsp;                DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);
<i>4432</i>&nbsp;                return dfs.getZeroDigit();
<b class="nc"><i>4433</i>&nbsp;            }</b>
<b class="nc"><i>4434</i>&nbsp;            return zero;</b>
<i>4435</i>&nbsp;        }
<i>4436</i>&nbsp;
<i>4437</i>&nbsp;        private StringBuilder localizedMagnitude(StringBuilder sb,
<b class="nc"><i>4438</i>&nbsp;                long value, Flags f, int width, Locale l) {</b>
<b class="nc"><i>4439</i>&nbsp;            return localizedMagnitude(sb, Long.toString(value, 10), 0, f, width, l);</b>
<b class="nc"><i>4440</i>&nbsp;        }</b>
<b class="nc"><i>4441</i>&nbsp;</b>
<b class="nc"><i>4442</i>&nbsp;        private StringBuilder localizedMagnitude(StringBuilder sb,</b>
<b class="nc"><i>4443</i>&nbsp;                CharSequence value, final int offset, Flags f, int width,</b>
<b class="nc"><i>4444</i>&nbsp;                Locale l) {</b>
<i>4445</i>&nbsp;            if (sb == null) {
<b class="nc"><i>4446</i>&nbsp;                sb = new StringBuilder();</b>
<i>4447</i>&nbsp;            }
<i>4448</i>&nbsp;            int begin = sb.length();
<i>4449</i>&nbsp;
<i>4450</i>&nbsp;            char zero = getZero(l);
<b class="nc"><i>4451</i>&nbsp;</b>
<b class="nc"><i>4452</i>&nbsp;            // determine localized grouping separator and size</b>
<b class="nc"><i>4453</i>&nbsp;            char grpSep = &#39;\0&#39;;</b>
<b class="nc"><i>4454</i>&nbsp;            int  grpSize = -1;</b>
<b class="nc"><i>4455</i>&nbsp;            char decSep = &#39;\0&#39;;</b>
<b class="nc"><i>4456</i>&nbsp;</b>
<b class="nc"><i>4457</i>&nbsp;            int len = value.length();</b>
<b class="nc"><i>4458</i>&nbsp;            int dot = len;</b>
<b class="nc"><i>4459</i>&nbsp;            for (int j = offset; j &lt; len; j++) {</b>
<i>4460</i>&nbsp;                if (value.charAt(j) == &#39;.&#39;) {
<b class="nc"><i>4461</i>&nbsp;                    dot = j;</b>
<i>4462</i>&nbsp;                    break;
<i>4463</i>&nbsp;                }
<i>4464</i>&nbsp;            }
<i>4465</i>&nbsp;
<i>4466</i>&nbsp;            if (dot &lt; len) {
<b class="nc"><i>4467</i>&nbsp;                if (l == null || l.equals(Locale.US)) {</b>
<i>4468</i>&nbsp;                    decSep  = &#39;.&#39;;
<i>4469</i>&nbsp;                } else {
<i>4470</i>&nbsp;                    DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);
<b class="nc"><i>4471</i>&nbsp;                    decSep  = dfs.getDecimalSeparator();</b>
<b class="nc"><i>4472</i>&nbsp;                }</b>
<b class="nc"><i>4473</i>&nbsp;            }</b>
<b class="nc"><i>4474</i>&nbsp;</b>
<b class="nc"><i>4475</i>&nbsp;            if (f.contains(Flags.GROUP)) {</b>
<b class="nc"><i>4476</i>&nbsp;                if (l == null || l.equals(Locale.US)) {</b>
<b class="nc"><i>4477</i>&nbsp;                    grpSep = &#39;,&#39;;</b>
<b class="nc"><i>4478</i>&nbsp;                    grpSize = 3;</b>
<b class="nc"><i>4479</i>&nbsp;                } else {</b>
<b class="nc"><i>4480</i>&nbsp;                    DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);</b>
<b class="nc"><i>4481</i>&nbsp;                    grpSep = dfs.getGroupingSeparator();</b>
<i>4482</i>&nbsp;                    DecimalFormat df = null;
<i>4483</i>&nbsp;                    NumberFormat nf = NumberFormat.getNumberInstance(l);
<i>4484</i>&nbsp;                    if (nf instanceof DecimalFormat) {
<b class="nc"><i>4485</i>&nbsp;                        df = (DecimalFormat) nf;</b>
<i>4486</i>&nbsp;                    } else {
<i>4487</i>&nbsp;
<i>4488</i>&nbsp;                        // Use DecimalFormat constructor to obtain the instance,
<i>4489</i>&nbsp;                        // in case NumberFormat.getNumberInstance(l)
<i>4490</i>&nbsp;                        // returns instance other than DecimalFormat
<i>4491</i>&nbsp;                        LocaleProviderAdapter adapter = LocaleProviderAdapter
<i>4492</i>&nbsp;                                .getAdapter(NumberFormatProvider.class, l);
<i>4493</i>&nbsp;                        if (!(adapter instanceof ResourceBundleBasedAdapter)) {
<i>4494</i>&nbsp;                            adapter = LocaleProviderAdapter.getResourceBundleBased();
<i>4495</i>&nbsp;                        }
<i>4496</i>&nbsp;                        String[] all = adapter.getLocaleResources(l)
<i>4497</i>&nbsp;                                .getNumberPatterns();
<i>4498</i>&nbsp;                        df = new DecimalFormat(all[0], dfs);
<i>4499</i>&nbsp;                    }
<i>4500</i>&nbsp;                    grpSize = df.getGroupingSize();
<i>4501</i>&nbsp;                    // Some locales do not use grouping (the number
<i>4502</i>&nbsp;                    // pattern for these locales does not contain group, e.g.
<i>4503</i>&nbsp;                    // (&quot;#0.###&quot;)), but specify a grouping separator.
<i>4504</i>&nbsp;                    // To avoid unnecessary identification of the position of
<i>4505</i>&nbsp;                    // grouping separator, reset its value with null character
<i>4506</i>&nbsp;                    if (!df.isGroupingUsed() || grpSize == 0) {
<i>4507</i>&nbsp;                        grpSep = &#39;\0&#39;;
<i>4508</i>&nbsp;                    }
<i>4509</i>&nbsp;                }
<i>4510</i>&nbsp;            }
<i>4511</i>&nbsp;
<i>4512</i>&nbsp;            // localize the digits inserting group separators as necessary
<i>4513</i>&nbsp;            for (int j = offset; j &lt; len; j++) {
<i>4514</i>&nbsp;                if (j == dot) {
<i>4515</i>&nbsp;                    sb.append(decSep);
<i>4516</i>&nbsp;                    // no more group separators after the decimal separator
<i>4517</i>&nbsp;                    grpSep = &#39;\0&#39;;
<i>4518</i>&nbsp;                    continue;
<i>4519</i>&nbsp;                }
<i>4520</i>&nbsp;
<i>4521</i>&nbsp;                char c = value.charAt(j);
<i>4522</i>&nbsp;                sb.append((char) ((c - &#39;0&#39;) + zero));
<i>4523</i>&nbsp;                if (grpSep != &#39;\0&#39; &amp;&amp; j != dot - 1 &amp;&amp; ((dot - j) % grpSize == 1)) {
<i>4524</i>&nbsp;                    sb.append(grpSep);
<i>4525</i>&nbsp;                }
<i>4526</i>&nbsp;            }
<i>4527</i>&nbsp;
<b class="nc"><i>4528</i>&nbsp;            // apply zero padding</b>
<b class="nc"><i>4529</i>&nbsp;            if (width != -1 &amp;&amp; f.contains(Flags.ZERO_PAD)) {</b>
<i>4530</i>&nbsp;                for (int k = sb.length(); k &lt; width; k++) {
<i>4531</i>&nbsp;                    sb.insert(begin, zero);
<i>4532</i>&nbsp;                }
<i>4533</i>&nbsp;            }
<b class="nc"><i>4534</i>&nbsp;</b>
<i>4535</i>&nbsp;            return sb;
<i>4536</i>&nbsp;        }
<i>4537</i>&nbsp;
<i>4538</i>&nbsp;        // Specialized localization of exponents, where the source value can only
<i>4539</i>&nbsp;        // contain characters &#39;0&#39; through &#39;9&#39;, starting at index offset, and no
<i>4540</i>&nbsp;        // group separators is added for any locale.
<b class="nc"><i>4541</i>&nbsp;        private void localizedMagnitudeExp(StringBuilder sb, char[] value,</b>
<i>4542</i>&nbsp;                final int offset, Locale l) {
<b class="nc"><i>4543</i>&nbsp;            char zero = getZero(l);</b>
<i>4544</i>&nbsp;
<i>4545</i>&nbsp;            int len = value.length;
<i>4546</i>&nbsp;            for (int j = offset; j &lt; len; j++) {
<i>4547</i>&nbsp;                char c = value[j];
<i>4548</i>&nbsp;                sb.append((char) ((c - &#39;0&#39;) + zero));
<b class="nc"><i>4549</i>&nbsp;            }</b>
<i>4550</i>&nbsp;        }
<i>4551</i>&nbsp;    }
<b class="nc"><i>4552</i>&nbsp;</b>
<i>4553</i>&nbsp;    private static class Flags {
<b class="nc"><i>4554</i>&nbsp;        private int flags;</b>
<i>4555</i>&nbsp;
<i>4556</i>&nbsp;        static final Flags NONE          = new Flags(0);      // &#39;&#39;
<i>4557</i>&nbsp;
<i>4558</i>&nbsp;        // duplicate declarations from Formattable.java
<i>4559</i>&nbsp;        static final Flags LEFT_JUSTIFY  = new Flags(1&lt;&lt;0);   // &#39;-&#39;
<b class="nc"><i>4560</i>&nbsp;        static final Flags UPPERCASE     = new Flags(1&lt;&lt;1);   // &#39;^&#39;</b>
<i>4561</i>&nbsp;        static final Flags ALTERNATE     = new Flags(1&lt;&lt;2);   // &#39;#&#39;
<i>4562</i>&nbsp;
<i>4563</i>&nbsp;        // numerics
<i>4564</i>&nbsp;        static final Flags PLUS          = new Flags(1&lt;&lt;3);   // &#39;+&#39;
<b class="nc"><i>4565</i>&nbsp;        static final Flags LEADING_SPACE = new Flags(1&lt;&lt;4);   // &#39; &#39;</b>
<i>4566</i>&nbsp;        static final Flags ZERO_PAD      = new Flags(1&lt;&lt;5);   // &#39;0&#39;
<b class="nc"><i>4567</i>&nbsp;        static final Flags GROUP         = new Flags(1&lt;&lt;6);   // &#39;,&#39;</b>
<i>4568</i>&nbsp;        static final Flags PARENTHESES   = new Flags(1&lt;&lt;7);   // &#39;(&#39;
<i>4569</i>&nbsp;
<i>4570</i>&nbsp;        // indexing
<i>4571</i>&nbsp;        static final Flags PREVIOUS      = new Flags(1&lt;&lt;8);   // &#39;&lt;&#39;
<i>4572</i>&nbsp;
<b class="nc"><i>4573</i>&nbsp;        private Flags(int f) {</b>
<i>4574</i>&nbsp;            flags = f;
<i>4575</i>&nbsp;        }
<i>4576</i>&nbsp;
<i>4577</i>&nbsp;        public int valueOf() {
<i>4578</i>&nbsp;            return flags;
<i>4579</i>&nbsp;        }
<i>4580</i>&nbsp;
<b class="nc"><i>4581</i>&nbsp;        public boolean contains(Flags f) {</b>
<i>4582</i>&nbsp;            return (flags &amp; f.valueOf()) == f.valueOf();
<b class="nc"><i>4583</i>&nbsp;        }</b>
<i>4584</i>&nbsp;
<i>4585</i>&nbsp;        public Flags dup() {
<i>4586</i>&nbsp;            return new Flags(flags);
<i>4587</i>&nbsp;        }
<i>4588</i>&nbsp;
<b class="nc"><i>4589</i>&nbsp;        private Flags add(Flags f) {</b>
<i>4590</i>&nbsp;            flags |= f.valueOf();
<i>4591</i>&nbsp;            return this;
<b class="nc"><i>4592</i>&nbsp;        }</b>
<i>4593</i>&nbsp;
<b class="nc"><i>4594</i>&nbsp;        public Flags remove(Flags f) {</b>
<i>4595</i>&nbsp;            flags &amp;= ~f.valueOf();
<i>4596</i>&nbsp;            return this;
<i>4597</i>&nbsp;        }
<i>4598</i>&nbsp;
<b class="nc"><i>4599</i>&nbsp;        public static Flags parse(String s, int start, int end) {</b>
<i>4600</i>&nbsp;            Flags f = new Flags(0);
<i>4601</i>&nbsp;            for (int i = start; i &lt; end; i++) {
<i>4602</i>&nbsp;                char c = s.charAt(i);
<i>4603</i>&nbsp;                Flags v = parse(c);
<i>4604</i>&nbsp;                if (f.contains(v))
<i>4605</i>&nbsp;                    throw new DuplicateFormatFlagsException(v.toString());
<i>4606</i>&nbsp;                f.add(v);
<i>4607</i>&nbsp;            }
<i>4608</i>&nbsp;            return f;
<i>4609</i>&nbsp;        }
<i>4610</i>&nbsp;
<i>4611</i>&nbsp;        // parse those flags which may be provided by users
<i>4612</i>&nbsp;        private static Flags parse(char c) {
<i>4613</i>&nbsp;            switch (c) {
<i>4614</i>&nbsp;            case &#39;-&#39;: return LEFT_JUSTIFY;
<i>4615</i>&nbsp;            case &#39;#&#39;: return ALTERNATE;
<i>4616</i>&nbsp;            case &#39;+&#39;: return PLUS;
<i>4617</i>&nbsp;            case &#39; &#39;: return LEADING_SPACE;
<i>4618</i>&nbsp;            case &#39;0&#39;: return ZERO_PAD;
<i>4619</i>&nbsp;            case &#39;,&#39;: return GROUP;
<i>4620</i>&nbsp;            case &#39;(&#39;: return PARENTHESES;
<i>4621</i>&nbsp;            case &#39;&lt;&#39;: return PREVIOUS;
<i>4622</i>&nbsp;            default:
<i>4623</i>&nbsp;                throw new UnknownFormatFlagsException(String.valueOf(c));
<i>4624</i>&nbsp;            }
<i>4625</i>&nbsp;        }
<i>4626</i>&nbsp;
<i>4627</i>&nbsp;        // Returns a string representation of the current {@code Flags}.
<i>4628</i>&nbsp;        public static String toString(Flags f) {
<i>4629</i>&nbsp;            return f.toString();
<i>4630</i>&nbsp;        }
<i>4631</i>&nbsp;
<i>4632</i>&nbsp;        public String toString() {
<i>4633</i>&nbsp;            StringBuilder sb = new StringBuilder();
<i>4634</i>&nbsp;            if (contains(LEFT_JUSTIFY))  sb.append(&#39;-&#39;);
<i>4635</i>&nbsp;            if (contains(UPPERCASE))     sb.append(&#39;^&#39;);
<i>4636</i>&nbsp;            if (contains(ALTERNATE))     sb.append(&#39;#&#39;);
<i>4637</i>&nbsp;            if (contains(PLUS))          sb.append(&#39;+&#39;);
<i>4638</i>&nbsp;            if (contains(LEADING_SPACE)) sb.append(&#39; &#39;);
<i>4639</i>&nbsp;            if (contains(ZERO_PAD))      sb.append(&#39;0&#39;);
<i>4640</i>&nbsp;            if (contains(GROUP))         sb.append(&#39;,&#39;);
<i>4641</i>&nbsp;            if (contains(PARENTHESES))   sb.append(&#39;(&#39;);
<i>4642</i>&nbsp;            if (contains(PREVIOUS))      sb.append(&#39;&lt;&#39;);
<i>4643</i>&nbsp;            return sb.toString();
<i>4644</i>&nbsp;        }
<i>4645</i>&nbsp;    }
<i>4646</i>&nbsp;
<b class="nc"><i>4647</i>&nbsp;    private static class Conversion {</b>
<i>4648</i>&nbsp;        // Byte, Short, Integer, Long, BigInteger
<i>4649</i>&nbsp;        // (and associated primitives due to autoboxing)
<i>4650</i>&nbsp;        static final char DECIMAL_INTEGER     = &#39;d&#39;;
<i>4651</i>&nbsp;        static final char OCTAL_INTEGER       = &#39;o&#39;;
<i>4652</i>&nbsp;        static final char HEXADECIMAL_INTEGER = &#39;x&#39;;
<i>4653</i>&nbsp;        static final char HEXADECIMAL_INTEGER_UPPER = &#39;X&#39;;
<i>4654</i>&nbsp;
<i>4655</i>&nbsp;        // Float, Double, BigDecimal
<i>4656</i>&nbsp;        // (and associated primitives due to autoboxing)
<i>4657</i>&nbsp;        static final char SCIENTIFIC          = &#39;e&#39;;
<i>4658</i>&nbsp;        static final char SCIENTIFIC_UPPER    = &#39;E&#39;;
<i>4659</i>&nbsp;        static final char GENERAL             = &#39;g&#39;;
<i>4660</i>&nbsp;        static final char GENERAL_UPPER       = &#39;G&#39;;
<i>4661</i>&nbsp;        static final char DECIMAL_FLOAT       = &#39;f&#39;;
<i>4662</i>&nbsp;        static final char HEXADECIMAL_FLOAT   = &#39;a&#39;;
<i>4663</i>&nbsp;        static final char HEXADECIMAL_FLOAT_UPPER = &#39;A&#39;;
<i>4664</i>&nbsp;
<i>4665</i>&nbsp;        // Character, Byte, Short, Integer
<i>4666</i>&nbsp;        // (and associated primitives due to autoboxing)
<i>4667</i>&nbsp;        static final char CHARACTER           = &#39;c&#39;;
<i>4668</i>&nbsp;        static final char CHARACTER_UPPER     = &#39;C&#39;;
<i>4669</i>&nbsp;
<i>4670</i>&nbsp;        // java.util.Date, java.util.Calendar, long
<i>4671</i>&nbsp;        static final char DATE_TIME           = &#39;t&#39;;
<i>4672</i>&nbsp;        static final char DATE_TIME_UPPER     = &#39;T&#39;;
<i>4673</i>&nbsp;
<i>4674</i>&nbsp;        // if (arg.TYPE != boolean) return boolean
<i>4675</i>&nbsp;        // if (arg != null) return true; else return false;
<i>4676</i>&nbsp;        static final char BOOLEAN             = &#39;b&#39;;
<i>4677</i>&nbsp;        static final char BOOLEAN_UPPER       = &#39;B&#39;;
<i>4678</i>&nbsp;        // if (arg instanceof Formattable) arg.formatTo()
<i>4679</i>&nbsp;        // else arg.toString();
<i>4680</i>&nbsp;        static final char STRING              = &#39;s&#39;;
<i>4681</i>&nbsp;        static final char STRING_UPPER        = &#39;S&#39;;
<i>4682</i>&nbsp;        // arg.hashCode()
<i>4683</i>&nbsp;        static final char HASHCODE            = &#39;h&#39;;
<i>4684</i>&nbsp;        static final char HASHCODE_UPPER      = &#39;H&#39;;
<i>4685</i>&nbsp;
<i>4686</i>&nbsp;        static final char LINE_SEPARATOR      = &#39;n&#39;;
<i>4687</i>&nbsp;        static final char PERCENT_SIGN        = &#39;%&#39;;
<i>4688</i>&nbsp;
<i>4689</i>&nbsp;        static boolean isValid(char c) {
<i>4690</i>&nbsp;            return (isGeneral(c) || isInteger(c) || isFloat(c) || isText(c)
<i>4691</i>&nbsp;                    || c == &#39;t&#39; || isCharacter(c));
<b class="nc"><i>4692</i>&nbsp;        }</b>
<i>4693</i>&nbsp;
<b class="nc"><i>4694</i>&nbsp;        // Returns true iff the Conversion is applicable to all objects.</b>
<i>4695</i>&nbsp;        static boolean isGeneral(char c) {
<i>4696</i>&nbsp;            switch (c) {
<i>4697</i>&nbsp;            case BOOLEAN:
<i>4698</i>&nbsp;            case BOOLEAN_UPPER:
<i>4699</i>&nbsp;            case STRING:
<i>4700</i>&nbsp;            case STRING_UPPER:
<i>4701</i>&nbsp;            case HASHCODE:
<i>4702</i>&nbsp;            case HASHCODE_UPPER:
<i>4703</i>&nbsp;                return true;
<i>4704</i>&nbsp;            default:
<i>4705</i>&nbsp;                return false;
<i>4706</i>&nbsp;            }
<i>4707</i>&nbsp;        }
<i>4708</i>&nbsp;
<i>4709</i>&nbsp;        // Returns true iff the Conversion is applicable to character.
<i>4710</i>&nbsp;        static boolean isCharacter(char c) {
<i>4711</i>&nbsp;            switch (c) {
<i>4712</i>&nbsp;            case CHARACTER:
<i>4713</i>&nbsp;            case CHARACTER_UPPER:
<i>4714</i>&nbsp;                return true;
<i>4715</i>&nbsp;            default:
<i>4716</i>&nbsp;                return false;
<i>4717</i>&nbsp;            }
<i>4718</i>&nbsp;        }
<i>4719</i>&nbsp;
<i>4720</i>&nbsp;        // Returns true iff the Conversion is an integer type.
<i>4721</i>&nbsp;        static boolean isInteger(char c) {
<i>4722</i>&nbsp;            switch (c) {
<i>4723</i>&nbsp;            case DECIMAL_INTEGER:
<i>4724</i>&nbsp;            case OCTAL_INTEGER:
<i>4725</i>&nbsp;            case HEXADECIMAL_INTEGER:
<i>4726</i>&nbsp;            case HEXADECIMAL_INTEGER_UPPER:
<i>4727</i>&nbsp;                return true;
<i>4728</i>&nbsp;            default:
<i>4729</i>&nbsp;                return false;
<i>4730</i>&nbsp;            }
<i>4731</i>&nbsp;        }
<i>4732</i>&nbsp;
<i>4733</i>&nbsp;        // Returns true iff the Conversion is a floating-point type.
<i>4734</i>&nbsp;        static boolean isFloat(char c) {
<i>4735</i>&nbsp;            switch (c) {
<i>4736</i>&nbsp;            case SCIENTIFIC:
<i>4737</i>&nbsp;            case SCIENTIFIC_UPPER:
<i>4738</i>&nbsp;            case GENERAL:
<i>4739</i>&nbsp;            case GENERAL_UPPER:
<i>4740</i>&nbsp;            case DECIMAL_FLOAT:
<i>4741</i>&nbsp;            case HEXADECIMAL_FLOAT:
<i>4742</i>&nbsp;            case HEXADECIMAL_FLOAT_UPPER:
<i>4743</i>&nbsp;                return true;
<i>4744</i>&nbsp;            default:
<i>4745</i>&nbsp;                return false;
<i>4746</i>&nbsp;            }
<i>4747</i>&nbsp;        }
<i>4748</i>&nbsp;
<i>4749</i>&nbsp;        // Returns true iff the Conversion does not require an argument
<i>4750</i>&nbsp;        static boolean isText(char c) {
<i>4751</i>&nbsp;            switch (c) {
<i>4752</i>&nbsp;            case LINE_SEPARATOR:
<i>4753</i>&nbsp;            case PERCENT_SIGN:
<i>4754</i>&nbsp;                return true;
<i>4755</i>&nbsp;            default:
<i>4756</i>&nbsp;                return false;
<i>4757</i>&nbsp;            }
<i>4758</i>&nbsp;        }
<i>4759</i>&nbsp;    }
<i>4760</i>&nbsp;
<i>4761</i>&nbsp;    private static class DateTime {
<i>4762</i>&nbsp;        static final char HOUR_OF_DAY_0 = &#39;H&#39;; // (00 - 23)
<i>4763</i>&nbsp;        static final char HOUR_0        = &#39;I&#39;; // (01 - 12)
<i>4764</i>&nbsp;        static final char HOUR_OF_DAY   = &#39;k&#39;; // (0 - 23) -- like H
<i>4765</i>&nbsp;        static final char HOUR          = &#39;l&#39;; // (1 - 12) -- like I
<i>4766</i>&nbsp;        static final char MINUTE        = &#39;M&#39;; // (00 - 59)
<i>4767</i>&nbsp;        static final char NANOSECOND    = &#39;N&#39;; // (000000000 - 999999999)
<i>4768</i>&nbsp;        static final char MILLISECOND   = &#39;L&#39;; // jdk, not in gnu (000 - 999)
<i>4769</i>&nbsp;        static final char MILLISECOND_SINCE_EPOCH = &#39;Q&#39;; // (0 - 99...?)
<i>4770</i>&nbsp;        static final char AM_PM         = &#39;p&#39;; // (am or pm)
<i>4771</i>&nbsp;        static final char SECONDS_SINCE_EPOCH = &#39;s&#39;; // (0 - 99...?)
<i>4772</i>&nbsp;        static final char SECOND        = &#39;S&#39;; // (00 - 60 - leap second)
<i>4773</i>&nbsp;        static final char TIME          = &#39;T&#39;; // (24 hour hh:mm:ss)
<i>4774</i>&nbsp;        static final char ZONE_NUMERIC  = &#39;z&#39;; // (-1200 - +1200) - ls minus?
<i>4775</i>&nbsp;        static final char ZONE          = &#39;Z&#39;; // (symbol)
<i>4776</i>&nbsp;
<i>4777</i>&nbsp;        // Date
<i>4778</i>&nbsp;        static final char NAME_OF_DAY_ABBREV    = &#39;a&#39;; // &#39;a&#39;
<i>4779</i>&nbsp;        static final char NAME_OF_DAY           = &#39;A&#39;; // &#39;A&#39;
<i>4780</i>&nbsp;        static final char NAME_OF_MONTH_ABBREV  = &#39;b&#39;; // &#39;b&#39;
<i>4781</i>&nbsp;        static final char NAME_OF_MONTH         = &#39;B&#39;; // &#39;B&#39;
<i>4782</i>&nbsp;        static final char CENTURY               = &#39;C&#39;; // (00 - 99)
<i>4783</i>&nbsp;        static final char DAY_OF_MONTH_0        = &#39;d&#39;; // (01 - 31)
<i>4784</i>&nbsp;        static final char DAY_OF_MONTH          = &#39;e&#39;; // (1 - 31) -- like d
<i>4785</i>&nbsp;// *    static final char ISO_WEEK_OF_YEAR_2    = &#39;g&#39;; // cross %y %V
<i>4786</i>&nbsp;// *    static final char ISO_WEEK_OF_YEAR_4    = &#39;G&#39;; // cross %Y %V
<i>4787</i>&nbsp;        static final char NAME_OF_MONTH_ABBREV_X  = &#39;h&#39;; // -- same b
<i>4788</i>&nbsp;        static final char DAY_OF_YEAR           = &#39;j&#39;; // (001 - 366)
<i>4789</i>&nbsp;        static final char MONTH                 = &#39;m&#39;; // (01 - 12)
<i>4790</i>&nbsp;// *    static final char DAY_OF_WEEK_1         = &#39;u&#39;; // (1 - 7) Monday
<i>4791</i>&nbsp;// *    static final char WEEK_OF_YEAR_SUNDAY   = &#39;U&#39;; // (0 - 53) Sunday+
<i>4792</i>&nbsp;// *    static final char WEEK_OF_YEAR_MONDAY_01 = &#39;V&#39;; // (01 - 53) Monday+
<i>4793</i>&nbsp;// *    static final char DAY_OF_WEEK_0         = &#39;w&#39;; // (0 - 6) Sunday
<i>4794</i>&nbsp;// *    static final char WEEK_OF_YEAR_MONDAY   = &#39;W&#39;; // (00 - 53) Monday
<i>4795</i>&nbsp;        static final char YEAR_2                = &#39;y&#39;; // (00 - 99)
<i>4796</i>&nbsp;        static final char YEAR_4                = &#39;Y&#39;; // (0000 - 9999)
<i>4797</i>&nbsp;
<i>4798</i>&nbsp;        // Composites
<i>4799</i>&nbsp;        static final char TIME_12_HOUR  = &#39;r&#39;; // (hh:mm:ss [AP]M)
<i>4800</i>&nbsp;        static final char TIME_24_HOUR  = &#39;R&#39;; // (hh:mm same as %H:%M)
<i>4801</i>&nbsp;// *    static final char LOCALE_TIME   = &#39;X&#39;; // (%H:%M:%S) - parse format?
<i>4802</i>&nbsp;        static final char DATE_TIME             = &#39;c&#39;;
<i>4803</i>&nbsp;                                            // (Sat Nov 04 12:02:33 EST 1999)
<i>4804</i>&nbsp;        static final char DATE                  = &#39;D&#39;; // (mm/dd/yy)
<i>4805</i>&nbsp;        static final char ISO_STANDARD_DATE     = &#39;F&#39;; // (%Y-%m-%d)
<i>4806</i>&nbsp;// *    static final char LOCALE_DATE           = &#39;x&#39;; // (mm/dd/yy)
<i>4807</i>&nbsp;
<i>4808</i>&nbsp;        static boolean isValid(char c) {
<i>4809</i>&nbsp;            switch (c) {
<i>4810</i>&nbsp;            case HOUR_OF_DAY_0:
<i>4811</i>&nbsp;            case HOUR_0:
<i>4812</i>&nbsp;            case HOUR_OF_DAY:
<i>4813</i>&nbsp;            case HOUR:
<i>4814</i>&nbsp;            case MINUTE:
<i>4815</i>&nbsp;            case NANOSECOND:
<i>4816</i>&nbsp;            case MILLISECOND:
<i>4817</i>&nbsp;            case MILLISECOND_SINCE_EPOCH:
<i>4818</i>&nbsp;            case AM_PM:
<i>4819</i>&nbsp;            case SECONDS_SINCE_EPOCH:
<i>4820</i>&nbsp;            case SECOND:
<i>4821</i>&nbsp;            case TIME:
<i>4822</i>&nbsp;            case ZONE_NUMERIC:
<i>4823</i>&nbsp;            case ZONE:
<i>4824</i>&nbsp;
<i>4825</i>&nbsp;            // Date
<i>4826</i>&nbsp;            case NAME_OF_DAY_ABBREV:
<i>4827</i>&nbsp;            case NAME_OF_DAY:
<i>4828</i>&nbsp;            case NAME_OF_MONTH_ABBREV:
<i>4829</i>&nbsp;            case NAME_OF_MONTH:
<i>4830</i>&nbsp;            case CENTURY:
<i>4831</i>&nbsp;            case DAY_OF_MONTH_0:
<i>4832</i>&nbsp;            case DAY_OF_MONTH:
<i>4833</i>&nbsp;// *        case ISO_WEEK_OF_YEAR_2:
<i>4834</i>&nbsp;// *        case ISO_WEEK_OF_YEAR_4:
<i>4835</i>&nbsp;            case NAME_OF_MONTH_ABBREV_X:
<i>4836</i>&nbsp;            case DAY_OF_YEAR:
<i>4837</i>&nbsp;            case MONTH:
<i>4838</i>&nbsp;// *        case DAY_OF_WEEK_1:
<i>4839</i>&nbsp;// *        case WEEK_OF_YEAR_SUNDAY:
<i>4840</i>&nbsp;// *        case WEEK_OF_YEAR_MONDAY_01:
<i>4841</i>&nbsp;// *        case DAY_OF_WEEK_0:
<i>4842</i>&nbsp;// *        case WEEK_OF_YEAR_MONDAY:
<i>4843</i>&nbsp;            case YEAR_2:
<i>4844</i>&nbsp;            case YEAR_4:
<i>4845</i>&nbsp;
<i>4846</i>&nbsp;            // Composites
<i>4847</i>&nbsp;            case TIME_12_HOUR:
<i>4848</i>&nbsp;            case TIME_24_HOUR:
<i>4849</i>&nbsp;// *        case LOCALE_TIME:
<i>4850</i>&nbsp;            case DATE_TIME:
<i>4851</i>&nbsp;            case DATE:
<i>4852</i>&nbsp;            case ISO_STANDARD_DATE:
<i>4853</i>&nbsp;// *        case LOCALE_DATE:
<i>4854</i>&nbsp;                return true;
<i>4855</i>&nbsp;            default:
<i>4856</i>&nbsp;                return false;
<i>4857</i>&nbsp;            }
<i>4858</i>&nbsp;        }
<i>4859</i>&nbsp;    }
<i>4860</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
