


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Locale</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util</a> ]
</div>

<h1>Coverage Summary for Class: Locale (java.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Locale</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 405)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Locale$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$Cache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$Category</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$FilteringMode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$LanguageRange</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$LocaleKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Locale$LocaleNameGetter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 104)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 570)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
<i>28</i>&nbsp; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
<i>29</i>&nbsp; *
<i>30</i>&nbsp; * The original version of this source code and documentation
<i>31</i>&nbsp; * is copyrighted and owned by Taligent, Inc., a wholly-owned
<i>32</i>&nbsp; * subsidiary of IBM. These materials are provided under terms
<i>33</i>&nbsp; * of a License Agreement between Taligent and Sun. This technology
<i>34</i>&nbsp; * is protected by multiple US and International patents.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * This notice and attribution to Taligent may not be removed.
<i>37</i>&nbsp; * Taligent is a registered trademark of Taligent, Inc.
<i>38</i>&nbsp; *
<i>39</i>&nbsp; */
<i>40</i>&nbsp;
<i>41</i>&nbsp;package java.util;
<i>42</i>&nbsp;
<i>43</i>&nbsp;import java.io.IOException;
<i>44</i>&nbsp;import java.io.ObjectInputStream;
<i>45</i>&nbsp;import java.io.ObjectOutputStream;
<i>46</i>&nbsp;import java.io.ObjectStreamField;
<i>47</i>&nbsp;import java.io.Serializable;
<i>48</i>&nbsp;import java.text.MessageFormat;
<i>49</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>50</i>&nbsp;import java.util.spi.LocaleNameProvider;
<i>51</i>&nbsp;import java.util.stream.Collectors;
<i>52</i>&nbsp;
<i>53</i>&nbsp;import sun.security.action.GetPropertyAction;
<i>54</i>&nbsp;import sun.util.locale.BaseLocale;
<i>55</i>&nbsp;import sun.util.locale.InternalLocaleBuilder;
<i>56</i>&nbsp;import sun.util.locale.LanguageTag;
<i>57</i>&nbsp;import sun.util.locale.LocaleExtensions;
<i>58</i>&nbsp;import sun.util.locale.LocaleMatcher;
<i>59</i>&nbsp;import sun.util.locale.LocaleObjectCache;
<i>60</i>&nbsp;import sun.util.locale.LocaleSyntaxException;
<i>61</i>&nbsp;import sun.util.locale.LocaleUtils;
<i>62</i>&nbsp;import sun.util.locale.ParseStatus;
<i>63</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>64</i>&nbsp;import sun.util.locale.provider.LocaleResources;
<i>65</i>&nbsp;import sun.util.locale.provider.LocaleServiceProviderPool;
<i>66</i>&nbsp;import sun.util.locale.provider.TimeZoneNameUtility;
<i>67</i>&nbsp;
<i>68</i>&nbsp;/**
<i>69</i>&nbsp; * A &lt;code&gt;Locale&lt;/code&gt; object represents a specific geographical, political,
<i>70</i>&nbsp; * or cultural region. An operation that requires a &lt;code&gt;Locale&lt;/code&gt; to perform
<i>71</i>&nbsp; * its task is called &lt;em&gt;locale-sensitive&lt;/em&gt; and uses the &lt;code&gt;Locale&lt;/code&gt;
<i>72</i>&nbsp; * to tailor information for the user. For example, displaying a number
<i>73</i>&nbsp; * is a locale-sensitive operation&amp;mdash; the number should be formatted
<i>74</i>&nbsp; * according to the customs and conventions of the user&#39;s native country,
<i>75</i>&nbsp; * region, or culture.
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * &lt;p&gt; The {@code Locale} class implements IETF BCP 47 which is composed of
<i>78</i>&nbsp; * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 &quot;Matching of Language
<i>79</i>&nbsp; * Tags&quot;&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646 &quot;Tags
<i>80</i>&nbsp; * for Identifying Languages&quot;&lt;/a&gt; with support for the LDML (UTS#35, &quot;Unicode
<i>81</i>&nbsp; * Locale Data Markup Language&quot;) BCP 47-compatible extensions for locale data
<i>82</i>&nbsp; * exchange.
<i>83</i>&nbsp; *
<i>84</i>&nbsp; * &lt;p&gt; A &lt;code&gt;Locale&lt;/code&gt; object logically consists of the fields
<i>85</i>&nbsp; * described below.
<i>86</i>&nbsp; *
<i>87</i>&nbsp; * &lt;dl&gt;
<i>88</i>&nbsp; *   &lt;dt&gt;&lt;a id=&quot;def_language&quot;&gt;&lt;b&gt;language&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
<i>89</i>&nbsp; *
<i>90</i>&nbsp; *   &lt;dd&gt;ISO 639 alpha-2 or alpha-3 language code, or registered
<i>91</i>&nbsp; *   language subtags up to 8 alpha letters (for future enhancements).
<i>92</i>&nbsp; *   When a language has both an alpha-2 code and an alpha-3 code, the
<i>93</i>&nbsp; *   alpha-2 code must be used.  You can find a full list of valid
<i>94</i>&nbsp; *   language codes in the IANA Language Subtag Registry (search for
<i>95</i>&nbsp; *   &quot;Type: language&quot;).  The language field is case insensitive, but
<i>96</i>&nbsp; *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to lower case.&lt;/dd&gt;
<i>97</i>&nbsp; *
<i>98</i>&nbsp; *   &lt;dd&gt;Well-formed language values have the form
<i>99</i>&nbsp; *   &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;.  Note that this is not the full
<i>100</i>&nbsp; *   BCP47 language production, since it excludes extlang.  They are
<i>101</i>&nbsp; *   not needed since modern three-letter language codes replace
<i>102</i>&nbsp; *   them.&lt;/dd&gt;
<i>103</i>&nbsp; *
<i>104</i>&nbsp; *   &lt;dd&gt;Example: &quot;en&quot; (English), &quot;ja&quot; (Japanese), &quot;kok&quot; (Konkani)&lt;/dd&gt;
<i>105</i>&nbsp; *
<i>106</i>&nbsp; *   &lt;dt&gt;&lt;a id=&quot;def_script&quot;&gt;&lt;b&gt;script&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
<i>107</i>&nbsp; *
<i>108</i>&nbsp; *   &lt;dd&gt;ISO 15924 alpha-4 script code.  You can find a full list of
<i>109</i>&nbsp; *   valid script codes in the IANA Language Subtag Registry (search
<i>110</i>&nbsp; *   for &quot;Type: script&quot;).  The script field is case insensitive, but
<i>111</i>&nbsp; *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to title case (the first
<i>112</i>&nbsp; *   letter is upper case and the rest of the letters are lower
<i>113</i>&nbsp; *   case).&lt;/dd&gt;
<i>114</i>&nbsp; *
<i>115</i>&nbsp; *   &lt;dd&gt;Well-formed script values have the form
<i>116</i>&nbsp; *   &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;&lt;/dd&gt;
<i>117</i>&nbsp; *
<i>118</i>&nbsp; *   &lt;dd&gt;Example: &quot;Latn&quot; (Latin), &quot;Cyrl&quot; (Cyrillic)&lt;/dd&gt;
<i>119</i>&nbsp; *
<i>120</i>&nbsp; *   &lt;dt&gt;&lt;a id=&quot;def_region&quot;&gt;&lt;b&gt;country (region)&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
<i>121</i>&nbsp; *
<i>122</i>&nbsp; *   &lt;dd&gt;ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
<i>123</i>&nbsp; *   You can find a full list of valid country and region codes in the
<i>124</i>&nbsp; *   IANA Language Subtag Registry (search for &quot;Type: region&quot;).  The
<i>125</i>&nbsp; *   country (region) field is case insensitive, but
<i>126</i>&nbsp; *   &lt;code&gt;Locale&lt;/code&gt; always canonicalizes to upper case.&lt;/dd&gt;
<i>127</i>&nbsp; *
<i>128</i>&nbsp; *   &lt;dd&gt;Well-formed country/region values have
<i>129</i>&nbsp; *   the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;&lt;/dd&gt;
<i>130</i>&nbsp; *
<i>131</i>&nbsp; *   &lt;dd&gt;Example: &quot;US&quot; (United States), &quot;FR&quot; (France), &quot;029&quot;
<i>132</i>&nbsp; *   (Caribbean)&lt;/dd&gt;
<i>133</i>&nbsp; *
<i>134</i>&nbsp; *   &lt;dt&gt;&lt;a id=&quot;def_variant&quot;&gt;&lt;b&gt;variant&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
<i>135</i>&nbsp; *
<i>136</i>&nbsp; *   &lt;dd&gt;Any arbitrary value used to indicate a variation of a
<i>137</i>&nbsp; *   &lt;code&gt;Locale&lt;/code&gt;.  Where there are two or more variant values
<i>138</i>&nbsp; *   each indicating its own semantics, these values should be ordered
<i>139</i>&nbsp; *   by importance, with most important first, separated by
<i>140</i>&nbsp; *   underscore(&#39;_&#39;).  The variant field is case sensitive.&lt;/dd&gt;
<i>141</i>&nbsp; *
<i>142</i>&nbsp; *   &lt;dd&gt;Note: IETF BCP 47 places syntactic restrictions on variant
<i>143</i>&nbsp; *   subtags.  Also BCP 47 subtags are strictly used to indicate
<i>144</i>&nbsp; *   additional variations that define a language or its dialects that
<i>145</i>&nbsp; *   are not covered by any combinations of language, script and
<i>146</i>&nbsp; *   region subtags.  You can find a full list of valid variant codes
<i>147</i>&nbsp; *   in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).
<i>148</i>&nbsp; *
<i>149</i>&nbsp; *   &lt;p&gt;However, the variant field in &lt;code&gt;Locale&lt;/code&gt; has
<i>150</i>&nbsp; *   historically been used for any kind of variation, not just
<i>151</i>&nbsp; *   language variations.  For example, some supported variants
<i>152</i>&nbsp; *   available in Java SE Runtime Environments indicate alternative
<i>153</i>&nbsp; *   cultural behaviors such as calendar type or number script.  In
<i>154</i>&nbsp; *   BCP 47 this kind of information, which does not identify the
<i>155</i>&nbsp; *   language, is supported by extension subtags or private use
<i>156</i>&nbsp; *   subtags.&lt;/dd&gt;
<i>157</i>&nbsp; *
<i>158</i>&nbsp; *   &lt;dd&gt;Well-formed variant values have the form &lt;code&gt;SUBTAG
<i>159</i>&nbsp; *   ((&#39;_&#39;|&#39;-&#39;) SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
<i>160</i>&nbsp; *   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only
<i>161</i>&nbsp; *   uses hyphen (&#39;-&#39;) as a delimiter, this is more lenient).&lt;/dd&gt;
<i>162</i>&nbsp; *
<i>163</i>&nbsp; *   &lt;dd&gt;Example: &quot;polyton&quot; (Polytonic Greek), &quot;POSIX&quot;&lt;/dd&gt;
<i>164</i>&nbsp; *
<i>165</i>&nbsp; *   &lt;dt&gt;&lt;a id=&quot;def_extensions&quot;&gt;&lt;b&gt;extensions&lt;/b&gt;&lt;/a&gt;&lt;/dt&gt;
<i>166</i>&nbsp; *
<i>167</i>&nbsp; *   &lt;dd&gt;A map from single character keys to string values, indicating
<i>168</i>&nbsp; *   extensions apart from language identification.  The extensions in
<i>169</i>&nbsp; *   &lt;code&gt;Locale&lt;/code&gt; implement the semantics and syntax of BCP 47
<i>170</i>&nbsp; *   extension subtags and private use subtags. The extensions are
<i>171</i>&nbsp; *   case insensitive, but &lt;code&gt;Locale&lt;/code&gt; canonicalizes all
<i>172</i>&nbsp; *   extension keys and values to lower case. Note that extensions
<i>173</i>&nbsp; *   cannot have empty values.&lt;/dd&gt;
<i>174</i>&nbsp; *
<i>175</i>&nbsp; *   &lt;dd&gt;Well-formed keys are single characters from the set
<i>176</i>&nbsp; *   &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;.  Well-formed values have the form
<i>177</i>&nbsp; *   &lt;code&gt;SUBTAG (&#39;-&#39; SUBTAG)*&lt;/code&gt; where for the key &#39;x&#39;
<i>178</i>&nbsp; *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys
<i>179</i>&nbsp; *   &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, &#39;x&#39; allows
<i>180</i>&nbsp; *   single-character subtags).&lt;/dd&gt;
<i>181</i>&nbsp; *
<i>182</i>&nbsp; *   &lt;dd&gt;Example: key=&quot;u&quot;/value=&quot;ca-japanese&quot; (Japanese Calendar),
<i>183</i>&nbsp; *   key=&quot;x&quot;/value=&quot;java-1-7&quot;&lt;/dd&gt;
<i>184</i>&nbsp; * &lt;/dl&gt;
<i>185</i>&nbsp; *
<i>186</i>&nbsp; * &lt;b&gt;Note:&lt;/b&gt; Although BCP 47 requires field values to be registered
<i>187</i>&nbsp; * in the IANA Language Subtag Registry, the &lt;code&gt;Locale&lt;/code&gt; class
<i>188</i>&nbsp; * does not provide any validation features.  The &lt;code&gt;Builder&lt;/code&gt;
<i>189</i>&nbsp; * only checks if an individual field satisfies the syntactic
<i>190</i>&nbsp; * requirement (is well-formed), but does not validate the value
<i>191</i>&nbsp; * itself.  See {@link Builder} for details.
<i>192</i>&nbsp; *
<i>193</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;def_locale_extension&quot;&gt;Unicode locale/language extension&lt;/a&gt;&lt;/h3&gt;
<i>194</i>&nbsp; *
<i>195</i>&nbsp; * &lt;p&gt;UTS#35, &quot;Unicode Locale Data Markup Language&quot; defines optional
<i>196</i>&nbsp; * attributes and keywords to override or refine the default behavior
<i>197</i>&nbsp; * associated with a locale.  A keyword is represented by a pair of
<i>198</i>&nbsp; * key and type.  For example, &quot;nu-thai&quot; indicates that Thai local
<i>199</i>&nbsp; * digits (value:&quot;thai&quot;) should be used for formatting numbers
<i>200</i>&nbsp; * (key:&quot;nu&quot;).
<i>201</i>&nbsp; *
<i>202</i>&nbsp; * &lt;p&gt;The keywords are mapped to a BCP 47 extension value using the
<i>203</i>&nbsp; * extension key &#39;u&#39; ({@link #UNICODE_LOCALE_EXTENSION}).  The above
<i>204</i>&nbsp; * example, &quot;nu-thai&quot;, becomes the extension &quot;u-nu-thai&quot;.
<i>205</i>&nbsp; *
<i>206</i>&nbsp; * &lt;p&gt;Thus, when a &lt;code&gt;Locale&lt;/code&gt; object contains Unicode locale
<i>207</i>&nbsp; * attributes and keywords,
<i>208</i>&nbsp; * &lt;code&gt;getExtension(UNICODE_LOCALE_EXTENSION)&lt;/code&gt; will return a
<i>209</i>&nbsp; * String representing this information, for example, &quot;nu-thai&quot;.  The
<i>210</i>&nbsp; * &lt;code&gt;Locale&lt;/code&gt; class also provides {@link
<i>211</i>&nbsp; * #getUnicodeLocaleAttributes}, {@link #getUnicodeLocaleKeys}, and
<i>212</i>&nbsp; * {@link #getUnicodeLocaleType} which allow you to access Unicode
<i>213</i>&nbsp; * locale attributes and key/type pairs directly.  When represented as
<i>214</i>&nbsp; * a string, the Unicode Locale Extension lists attributes
<i>215</i>&nbsp; * alphabetically, followed by key/type sequences with keys listed
<i>216</i>&nbsp; * alphabetically (the order of subtags comprising a key&#39;s type is
<i>217</i>&nbsp; * fixed when the type is defined)
<i>218</i>&nbsp; *
<i>219</i>&nbsp; * &lt;p&gt;A well-formed locale key has the form
<i>220</i>&nbsp; * &lt;code&gt;[0-9a-zA-Z]{2}&lt;/code&gt;.  A well-formed locale type has the
<i>221</i>&nbsp; * form &lt;code&gt;&quot;&quot; | [0-9a-zA-Z]{3,8} (&#39;-&#39; [0-9a-zA-Z]{3,8})*&lt;/code&gt; (it
<i>222</i>&nbsp; * can be empty, or a series of subtags 3-8 alphanums in length).  A
<i>223</i>&nbsp; * well-formed locale attribute has the form
<i>224</i>&nbsp; * &lt;code&gt;[0-9a-zA-Z]{3,8}&lt;/code&gt; (it is a single subtag with the same
<i>225</i>&nbsp; * form as a locale type subtag).
<i>226</i>&nbsp; *
<i>227</i>&nbsp; * &lt;p&gt;The Unicode locale extension specifies optional behavior in
<i>228</i>&nbsp; * locale-sensitive services.  Although the LDML specification defines
<i>229</i>&nbsp; * various keys and values, actual locale-sensitive service
<i>230</i>&nbsp; * implementations in a Java Runtime Environment might not support any
<i>231</i>&nbsp; * particular Unicode locale attributes or key/type pairs.
<i>232</i>&nbsp; *
<i>233</i>&nbsp; * &lt;h4&gt;Creating a Locale&lt;/h4&gt;
<i>234</i>&nbsp; *
<i>235</i>&nbsp; * &lt;p&gt;There are several different ways to create a &lt;code&gt;Locale&lt;/code&gt;
<i>236</i>&nbsp; * object.
<i>237</i>&nbsp; *
<i>238</i>&nbsp; * &lt;h5&gt;Builder&lt;/h5&gt;
<i>239</i>&nbsp; *
<i>240</i>&nbsp; * &lt;p&gt;Using {@link Builder} you can construct a &lt;code&gt;Locale&lt;/code&gt; object
<i>241</i>&nbsp; * that conforms to BCP 47 syntax.
<i>242</i>&nbsp; *
<i>243</i>&nbsp; * &lt;h5&gt;Constructors&lt;/h5&gt;
<i>244</i>&nbsp; *
<i>245</i>&nbsp; * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides three constructors:
<i>246</i>&nbsp; * &lt;blockquote&gt;
<i>247</i>&nbsp; * &lt;pre&gt;
<i>248</i>&nbsp; *     {@link #Locale(String language)}
<i>249</i>&nbsp; *     {@link #Locale(String language, String country)}
<i>250</i>&nbsp; *     {@link #Locale(String language, String country, String variant)}
<i>251</i>&nbsp; * &lt;/pre&gt;
<i>252</i>&nbsp; * &lt;/blockquote&gt;
<i>253</i>&nbsp; * These constructors allow you to create a &lt;code&gt;Locale&lt;/code&gt; object
<i>254</i>&nbsp; * with language, country and variant, but you cannot specify
<i>255</i>&nbsp; * script or extensions.
<i>256</i>&nbsp; *
<i>257</i>&nbsp; * &lt;h5&gt;Factory Methods&lt;/h5&gt;
<i>258</i>&nbsp; *
<i>259</i>&nbsp; * &lt;p&gt;The method {@link #forLanguageTag} creates a &lt;code&gt;Locale&lt;/code&gt;
<i>260</i>&nbsp; * object for a well-formed BCP 47 language tag.
<i>261</i>&nbsp; *
<i>262</i>&nbsp; * &lt;h5&gt;Locale Constants&lt;/h5&gt;
<i>263</i>&nbsp; *
<i>264</i>&nbsp; * &lt;p&gt;The &lt;code&gt;Locale&lt;/code&gt; class provides a number of convenient constants
<i>265</i>&nbsp; * that you can use to create &lt;code&gt;Locale&lt;/code&gt; objects for commonly used
<i>266</i>&nbsp; * locales. For example, the following creates a &lt;code&gt;Locale&lt;/code&gt; object
<i>267</i>&nbsp; * for the United States:
<i>268</i>&nbsp; * &lt;blockquote&gt;
<i>269</i>&nbsp; * &lt;pre&gt;
<i>270</i>&nbsp; *     Locale.US
<i>271</i>&nbsp; * &lt;/pre&gt;
<i>272</i>&nbsp; * &lt;/blockquote&gt;
<i>273</i>&nbsp; *
<i>274</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;LocaleMatching&quot;&gt;Locale Matching&lt;/a&gt;&lt;/h4&gt;
<i>275</i>&nbsp; *
<i>276</i>&nbsp; * &lt;p&gt;If an application or a system is internationalized and provides localized
<i>277</i>&nbsp; * resources for multiple locales, it sometimes needs to find one or more
<i>278</i>&nbsp; * locales (or language tags) which meet each user&#39;s specific preferences. Note
<i>279</i>&nbsp; * that a term &quot;language tag&quot; is used interchangeably with &quot;locale&quot; in this
<i>280</i>&nbsp; * locale matching documentation.
<i>281</i>&nbsp; *
<i>282</i>&nbsp; * &lt;p&gt;In order to do matching a user&#39;s preferred locales to a set of language
<i>283</i>&nbsp; * tags, &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
<i>284</i>&nbsp; * Language Tags&lt;/a&gt; defines two mechanisms: filtering and lookup.
<i>285</i>&nbsp; * &lt;em&gt;Filtering&lt;/em&gt; is used to get all matching locales, whereas
<i>286</i>&nbsp; * &lt;em&gt;lookup&lt;/em&gt; is to choose the best matching locale.
<i>287</i>&nbsp; * Matching is done case-insensitively. These matching mechanisms are described
<i>288</i>&nbsp; * in the following sections.
<i>289</i>&nbsp; *
<i>290</i>&nbsp; * &lt;p&gt;A user&#39;s preference is called a &lt;em&gt;Language Priority List&lt;/em&gt; and is
<i>291</i>&nbsp; * expressed as a list of language ranges. There are syntactically two types of
<i>292</i>&nbsp; * language ranges: basic and extended. See
<i>293</i>&nbsp; * {@link Locale.LanguageRange Locale.LanguageRange} for details.
<i>294</i>&nbsp; *
<i>295</i>&nbsp; * &lt;h5&gt;Filtering&lt;/h5&gt;
<i>296</i>&nbsp; *
<i>297</i>&nbsp; * &lt;p&gt;The filtering operation returns all matching language tags. It is defined
<i>298</i>&nbsp; * in RFC 4647 as follows:
<i>299</i>&nbsp; * &quot;In filtering, each language range represents the least specific language
<i>300</i>&nbsp; * tag (that is, the language tag with fewest number of subtags) that is an
<i>301</i>&nbsp; * acceptable match. All of the language tags in the matching set of tags will
<i>302</i>&nbsp; * have an equal or greater number of subtags than the language range. Every
<i>303</i>&nbsp; * non-wildcard subtag in the language range will appear in every one of the
<i>304</i>&nbsp; * matching language tags.&quot;
<i>305</i>&nbsp; *
<i>306</i>&nbsp; * &lt;p&gt;There are two types of filtering: filtering for basic language ranges
<i>307</i>&nbsp; * (called &quot;basic filtering&quot;) and filtering for extended language ranges
<i>308</i>&nbsp; * (called &quot;extended filtering&quot;). They may return different results by what
<i>309</i>&nbsp; * kind of language ranges are included in the given Language Priority List.
<i>310</i>&nbsp; * {@link Locale.FilteringMode} is a parameter to specify how filtering should
<i>311</i>&nbsp; * be done.
<i>312</i>&nbsp; *
<i>313</i>&nbsp; * &lt;h5&gt;Lookup&lt;/h5&gt;
<i>314</i>&nbsp; *
<i>315</i>&nbsp; * &lt;p&gt;The lookup operation returns the best matching language tags. It is
<i>316</i>&nbsp; * defined in RFC 4647 as follows:
<i>317</i>&nbsp; * &quot;By contrast with filtering, each language range represents the most
<i>318</i>&nbsp; * specific tag that is an acceptable match.  The first matching tag found,
<i>319</i>&nbsp; * according to the user&#39;s priority, is considered the closest match and is the
<i>320</i>&nbsp; * item returned.&quot;
<i>321</i>&nbsp; *
<i>322</i>&nbsp; * &lt;p&gt;For example, if a Language Priority List consists of two language ranges,
<i>323</i>&nbsp; * {@code &quot;zh-Hant-TW&quot;} and {@code &quot;en-US&quot;}, in prioritized order, lookup
<i>324</i>&nbsp; * method progressively searches the language tags below in order to find the
<i>325</i>&nbsp; * best matching language tag.
<i>326</i>&nbsp; * &lt;blockquote&gt;
<i>327</i>&nbsp; * &lt;pre&gt;
<i>328</i>&nbsp; *    1. zh-Hant-TW
<i>329</i>&nbsp; *    2. zh-Hant
<i>330</i>&nbsp; *    3. zh
<i>331</i>&nbsp; *    4. en-US
<i>332</i>&nbsp; *    5. en
<i>333</i>&nbsp; * &lt;/pre&gt;
<i>334</i>&nbsp; * &lt;/blockquote&gt;
<i>335</i>&nbsp; * If there is a language tag which matches completely to a language range
<i>336</i>&nbsp; * above, the language tag is returned.
<i>337</i>&nbsp; *
<i>338</i>&nbsp; * &lt;p&gt;{@code &quot;*&quot;} is the special language range, and it is ignored in lookup.
<i>339</i>&nbsp; *
<i>340</i>&nbsp; * &lt;p&gt;If multiple language tags match as a result of the subtag {@code &#39;*&#39;}
<i>341</i>&nbsp; * included in a language range, the first matching language tag returned by
<i>342</i>&nbsp; * an {@link Iterator} over a {@link Collection} of language tags is treated as
<i>343</i>&nbsp; * the best matching one.
<i>344</i>&nbsp; *
<i>345</i>&nbsp; * &lt;h4&gt;Use of Locale&lt;/h4&gt;
<i>346</i>&nbsp; *
<i>347</i>&nbsp; * &lt;p&gt;Once you&#39;ve created a &lt;code&gt;Locale&lt;/code&gt; you can query it for information
<i>348</i>&nbsp; * about itself. Use &lt;code&gt;getCountry&lt;/code&gt; to get the country (or region)
<i>349</i>&nbsp; * code and &lt;code&gt;getLanguage&lt;/code&gt; to get the language code.
<i>350</i>&nbsp; * You can use &lt;code&gt;getDisplayCountry&lt;/code&gt; to get the
<i>351</i>&nbsp; * name of the country suitable for displaying to the user. Similarly,
<i>352</i>&nbsp; * you can use &lt;code&gt;getDisplayLanguage&lt;/code&gt; to get the name of
<i>353</i>&nbsp; * the language suitable for displaying to the user. Interestingly,
<i>354</i>&nbsp; * the &lt;code&gt;getDisplayXXX&lt;/code&gt; methods are themselves locale-sensitive
<i>355</i>&nbsp; * and have two versions: one that uses the default
<i>356</i>&nbsp; * {@link Locale.Category#DISPLAY DISPLAY} locale and one
<i>357</i>&nbsp; * that uses the locale specified as an argument.
<i>358</i>&nbsp; *
<i>359</i>&nbsp; * &lt;p&gt;The Java Platform provides a number of classes that perform locale-sensitive
<i>360</i>&nbsp; * operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats
<i>361</i>&nbsp; * numbers, currency, and percentages in a locale-sensitive manner. Classes
<i>362</i>&nbsp; * such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods
<i>363</i>&nbsp; * for creating a default object of that type. For example, the
<i>364</i>&nbsp; * &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods
<i>365</i>&nbsp; * for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:
<i>366</i>&nbsp; * &lt;blockquote&gt;
<i>367</i>&nbsp; * &lt;pre&gt;
<i>368</i>&nbsp; *     NumberFormat.getInstance()
<i>369</i>&nbsp; *     NumberFormat.getCurrencyInstance()
<i>370</i>&nbsp; *     NumberFormat.getPercentInstance()
<i>371</i>&nbsp; * &lt;/pre&gt;
<i>372</i>&nbsp; * &lt;/blockquote&gt;
<i>373</i>&nbsp; * Each of these methods has two variants; one with an explicit locale
<i>374</i>&nbsp; * and one without; the latter uses the default
<i>375</i>&nbsp; * {@link Locale.Category#FORMAT FORMAT} locale:
<i>376</i>&nbsp; * &lt;blockquote&gt;
<i>377</i>&nbsp; * &lt;pre&gt;
<i>378</i>&nbsp; *     NumberFormat.getInstance(myLocale)
<i>379</i>&nbsp; *     NumberFormat.getCurrencyInstance(myLocale)
<i>380</i>&nbsp; *     NumberFormat.getPercentInstance(myLocale)
<i>381</i>&nbsp; * &lt;/pre&gt;
<i>382</i>&nbsp; * &lt;/blockquote&gt;
<i>383</i>&nbsp; * A &lt;code&gt;Locale&lt;/code&gt; is the mechanism for identifying the kind of object
<i>384</i>&nbsp; * (&lt;code&gt;NumberFormat&lt;/code&gt;) that you would like to get. The locale is
<i>385</i>&nbsp; * &lt;STRONG&gt;just&lt;/STRONG&gt; a mechanism for identifying objects,
<i>386</i>&nbsp; * &lt;STRONG&gt;not&lt;/STRONG&gt; a container for the objects themselves.
<i>387</i>&nbsp; *
<i>388</i>&nbsp; * &lt;h4&gt;Compatibility&lt;/h4&gt;
<i>389</i>&nbsp; *
<i>390</i>&nbsp; * &lt;p&gt;In order to maintain compatibility with existing usage, Locale&#39;s
<i>391</i>&nbsp; * constructors retain their behavior prior to the Java Runtime
<i>392</i>&nbsp; * Environment version 1.7.  The same is largely true for the
<i>393</i>&nbsp; * &lt;code&gt;toString&lt;/code&gt; method. Thus Locale objects can continue to
<i>394</i>&nbsp; * be used as they were. In particular, clients who parse the output
<i>395</i>&nbsp; * of toString into language, country, and variant fields can continue
<i>396</i>&nbsp; * to do so (although this is strongly discouraged), although the
<i>397</i>&nbsp; * variant field will have additional information in it if script or
<i>398</i>&nbsp; * extensions are present.
<i>399</i>&nbsp; *
<i>400</i>&nbsp; * &lt;p&gt;In addition, BCP 47 imposes syntax restrictions that are not
<i>401</i>&nbsp; * imposed by Locale&#39;s constructors. This means that conversions
<i>402</i>&nbsp; * between some Locales and BCP 47 language tags cannot be made without
<i>403</i>&nbsp; * losing information. Thus &lt;code&gt;toLanguageTag&lt;/code&gt; cannot
<i>404</i>&nbsp; * represent the state of locales whose language, country, or variant
<i>405</i>&nbsp; * do not conform to BCP 47.
<i>406</i>&nbsp; *
<i>407</i>&nbsp; * &lt;p&gt;Because of these issues, it is recommended that clients migrate
<i>408</i>&nbsp; * away from constructing non-conforming locales and use the
<i>409</i>&nbsp; * &lt;code&gt;forLanguageTag&lt;/code&gt; and &lt;code&gt;Locale.Builder&lt;/code&gt; APIs instead.
<i>410</i>&nbsp; * Clients desiring a string representation of the complete locale can
<i>411</i>&nbsp; * then always rely on &lt;code&gt;toLanguageTag&lt;/code&gt; for this purpose.
<i>412</i>&nbsp; *
<i>413</i>&nbsp; * &lt;h5&gt;&lt;a id=&quot;special_cases_constructor&quot;&gt;Special cases&lt;/a&gt;&lt;/h5&gt;
<i>414</i>&nbsp; *
<i>415</i>&nbsp; * &lt;p&gt;For compatibility reasons, two
<i>416</i>&nbsp; * non-conforming locales are treated as special cases.  These are
<i>417</i>&nbsp; * &lt;b&gt;{@code ja_JP_JP}&lt;/b&gt; and &lt;b&gt;{@code th_TH_TH}&lt;/b&gt;. These are ill-formed
<i>418</i>&nbsp; * in BCP 47 since the variants are too short. To ease migration to BCP 47,
<i>419</i>&nbsp; * these are treated specially during construction.  These two cases (and only
<i>420</i>&nbsp; * these) cause a constructor to generate an extension, all other values behave
<i>421</i>&nbsp; * exactly as they did prior to Java 7.
<i>422</i>&nbsp; *
<i>423</i>&nbsp; * &lt;p&gt;Java has used {@code ja_JP_JP} to represent Japanese as used in
<i>424</i>&nbsp; * Japan together with the Japanese Imperial calendar. This is now
<i>425</i>&nbsp; * representable using a Unicode locale extension, by specifying the
<i>426</i>&nbsp; * Unicode locale key {@code ca} (for &quot;calendar&quot;) and type
<i>427</i>&nbsp; * {@code japanese}. When the Locale constructor is called with the
<i>428</i>&nbsp; * arguments &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;, the extension &quot;u-ca-japanese&quot; is
<i>429</i>&nbsp; * automatically added.
<i>430</i>&nbsp; *
<i>431</i>&nbsp; * &lt;p&gt;Java has used {@code th_TH_TH} to represent Thai as used in
<i>432</i>&nbsp; * Thailand together with Thai digits. This is also now representable using
<i>433</i>&nbsp; * a Unicode locale extension, by specifying the Unicode locale key
<i>434</i>&nbsp; * {@code nu} (for &quot;number&quot;) and value {@code thai}. When the Locale
<i>435</i>&nbsp; * constructor is called with the arguments &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;, the
<i>436</i>&nbsp; * extension &quot;u-nu-thai&quot; is automatically added.
<i>437</i>&nbsp; *
<i>438</i>&nbsp; * &lt;h5&gt;Serialization&lt;/h5&gt;
<i>439</i>&nbsp; *
<i>440</i>&nbsp; * &lt;p&gt;During serialization, writeObject writes all fields to the output
<i>441</i>&nbsp; * stream, including extensions.
<i>442</i>&nbsp; *
<i>443</i>&nbsp; * &lt;p&gt;During deserialization, readResolve adds extensions as described
<i>444</i>&nbsp; * in &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;, only
<i>445</i>&nbsp; * for the two cases th_TH_TH and ja_JP_JP.
<i>446</i>&nbsp; *
<i>447</i>&nbsp; * &lt;h5&gt;Legacy language codes&lt;/h5&gt;
<i>448</i>&nbsp; *
<i>449</i>&nbsp; * &lt;p&gt;Locale&#39;s constructor has always converted three language codes to
<i>450</i>&nbsp; * their earlier, obsoleted forms: {@code he} maps to {@code iw},
<i>451</i>&nbsp; * {@code yi} maps to {@code ji}, and {@code id} maps to
<i>452</i>&nbsp; * {@code in}.  This continues to be the case, in order to not break
<i>453</i>&nbsp; * backwards compatibility.
<i>454</i>&nbsp; *
<i>455</i>&nbsp; * &lt;p&gt;The APIs added in 1.7 map between the old and new language codes,
<i>456</i>&nbsp; * maintaining the old codes internal to Locale (so that
<i>457</i>&nbsp; * &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old
<i>458</i>&nbsp; * code), but using the new codes in the BCP 47 language tag APIs (so
<i>459</i>&nbsp; * that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This
<i>460</i>&nbsp; * preserves the equivalence between Locales no matter which code or
<i>461</i>&nbsp; * API is used to construct them. Java&#39;s default resource bundle
<i>462</i>&nbsp; * lookup mechanism also implements this mapping, so that resources
<i>463</i>&nbsp; * can be named using either convention, see {@link ResourceBundle.Control}.
<i>464</i>&nbsp; *
<i>465</i>&nbsp; * &lt;h5&gt;Three-letter language/country(region) codes&lt;/h5&gt;
<i>466</i>&nbsp; *
<i>467</i>&nbsp; * &lt;p&gt;The Locale constructors have always specified that the language
<i>468</i>&nbsp; * and the country param be two characters in length, although in
<i>469</i>&nbsp; * practice they have accepted any length.  The specification has now
<i>470</i>&nbsp; * been relaxed to allow language codes of two to eight characters and
<i>471</i>&nbsp; * country (region) codes of two to three characters, and in
<i>472</i>&nbsp; * particular, three-letter language codes and three-digit region
<i>473</i>&nbsp; * codes as specified in the IANA Language Subtag Registry.  For
<i>474</i>&nbsp; * compatibility, the implementation still does not impose a length
<i>475</i>&nbsp; * constraint.
<i>476</i>&nbsp; *
<i>477</i>&nbsp; * @see Builder
<i>478</i>&nbsp; * @see ResourceBundle
<i>479</i>&nbsp; * @see java.text.Format
<i>480</i>&nbsp; * @see java.text.NumberFormat
<i>481</i>&nbsp; * @see java.text.Collator
<i>482</i>&nbsp; * @author Mark Davis
<i>483</i>&nbsp; * @since 1.1
<b class="nc"><i>484</i>&nbsp; */</b>
<i>485</i>&nbsp;public final class Locale implements Cloneable, Serializable {
<b class="nc"><i>486</i>&nbsp;</b>
<i>487</i>&nbsp;    private static final  Cache LOCALECACHE = new Cache();
<i>488</i>&nbsp;
<i>489</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>490</i>&nbsp;     */</b>
<i>491</i>&nbsp;    public static final Locale ENGLISH = createConstant(&quot;en&quot;, &quot;&quot;);
<i>492</i>&nbsp;
<i>493</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>494</i>&nbsp;     */</b>
<i>495</i>&nbsp;    public static final Locale FRENCH = createConstant(&quot;fr&quot;, &quot;&quot;);
<i>496</i>&nbsp;
<i>497</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>498</i>&nbsp;     */</b>
<i>499</i>&nbsp;    public static final Locale GERMAN = createConstant(&quot;de&quot;, &quot;&quot;);
<i>500</i>&nbsp;
<i>501</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>502</i>&nbsp;     */</b>
<i>503</i>&nbsp;    public static final Locale ITALIAN = createConstant(&quot;it&quot;, &quot;&quot;);
<i>504</i>&nbsp;
<i>505</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>506</i>&nbsp;     */</b>
<i>507</i>&nbsp;    public static final Locale JAPANESE = createConstant(&quot;ja&quot;, &quot;&quot;);
<i>508</i>&nbsp;
<i>509</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>510</i>&nbsp;     */</b>
<i>511</i>&nbsp;    public static final Locale KOREAN = createConstant(&quot;ko&quot;, &quot;&quot;);
<i>512</i>&nbsp;
<i>513</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>514</i>&nbsp;     */</b>
<i>515</i>&nbsp;    public static final Locale CHINESE = createConstant(&quot;zh&quot;, &quot;&quot;);
<i>516</i>&nbsp;
<i>517</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>518</i>&nbsp;     */</b>
<i>519</i>&nbsp;    public static final Locale SIMPLIFIED_CHINESE = createConstant(&quot;zh&quot;, &quot;CN&quot;);
<i>520</i>&nbsp;
<i>521</i>&nbsp;    /** Useful constant for language.
<b class="nc"><i>522</i>&nbsp;     */</b>
<i>523</i>&nbsp;    public static final Locale TRADITIONAL_CHINESE = createConstant(&quot;zh&quot;, &quot;TW&quot;);
<i>524</i>&nbsp;
<i>525</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>526</i>&nbsp;     */</b>
<i>527</i>&nbsp;    public static final Locale FRANCE = createConstant(&quot;fr&quot;, &quot;FR&quot;);
<i>528</i>&nbsp;
<i>529</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>530</i>&nbsp;     */</b>
<i>531</i>&nbsp;    public static final Locale GERMANY = createConstant(&quot;de&quot;, &quot;DE&quot;);
<i>532</i>&nbsp;
<i>533</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>534</i>&nbsp;     */</b>
<i>535</i>&nbsp;    public static final Locale ITALY = createConstant(&quot;it&quot;, &quot;IT&quot;);
<i>536</i>&nbsp;
<i>537</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>538</i>&nbsp;     */</b>
<i>539</i>&nbsp;    public static final Locale JAPAN = createConstant(&quot;ja&quot;, &quot;JP&quot;);
<i>540</i>&nbsp;
<i>541</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>542</i>&nbsp;     */</b>
<i>543</i>&nbsp;    public static final Locale KOREA = createConstant(&quot;ko&quot;, &quot;KR&quot;);
<i>544</i>&nbsp;
<i>545</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>546</i>&nbsp;     */</b>
<i>547</i>&nbsp;    public static final Locale CHINA = SIMPLIFIED_CHINESE;
<i>548</i>&nbsp;
<i>549</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>550</i>&nbsp;     */</b>
<i>551</i>&nbsp;    public static final Locale PRC = SIMPLIFIED_CHINESE;
<i>552</i>&nbsp;
<i>553</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>554</i>&nbsp;     */</b>
<i>555</i>&nbsp;    public static final Locale TAIWAN = TRADITIONAL_CHINESE;
<i>556</i>&nbsp;
<i>557</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>558</i>&nbsp;     */</b>
<i>559</i>&nbsp;    public static final Locale UK = createConstant(&quot;en&quot;, &quot;GB&quot;);
<i>560</i>&nbsp;
<i>561</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>562</i>&nbsp;     */</b>
<i>563</i>&nbsp;    public static final Locale US = createConstant(&quot;en&quot;, &quot;US&quot;);
<i>564</i>&nbsp;
<i>565</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>566</i>&nbsp;     */</b>
<i>567</i>&nbsp;    public static final Locale CANADA = createConstant(&quot;en&quot;, &quot;CA&quot;);
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /** Useful constant for country.
<b class="nc"><i>570</i>&nbsp;     */</b>
<i>571</i>&nbsp;    public static final Locale CANADA_FRENCH = createConstant(&quot;fr&quot;, &quot;CA&quot;);
<i>572</i>&nbsp;
<i>573</i>&nbsp;    /**
<i>574</i>&nbsp;     * Useful constant for the root locale.  The root locale is the locale whose
<i>575</i>&nbsp;     * language, country, and variant are empty (&quot;&quot;) strings.  This is regarded
<i>576</i>&nbsp;     * as the base locale of all locales, and is used as the language/country
<i>577</i>&nbsp;     * neutral locale for the locale sensitive operations.
<i>578</i>&nbsp;     *
<i>579</i>&nbsp;     * @since 1.6
<b class="nc"><i>580</i>&nbsp;     */</b>
<i>581</i>&nbsp;    public static final Locale ROOT = createConstant(&quot;&quot;, &quot;&quot;);
<i>582</i>&nbsp;
<i>583</i>&nbsp;    /**
<i>584</i>&nbsp;     * The key for the private use extension (&#39;x&#39;).
<i>585</i>&nbsp;     *
<i>586</i>&nbsp;     * @see #getExtension(char)
<i>587</i>&nbsp;     * @see Builder#setExtension(char, String)
<i>588</i>&nbsp;     * @since 1.7
<i>589</i>&nbsp;     */
<i>590</i>&nbsp;    public static final char PRIVATE_USE_EXTENSION = &#39;x&#39;;
<i>591</i>&nbsp;
<i>592</i>&nbsp;    /**
<i>593</i>&nbsp;     * The key for Unicode locale extension (&#39;u&#39;).
<i>594</i>&nbsp;     *
<i>595</i>&nbsp;     * @see #getExtension(char)
<i>596</i>&nbsp;     * @see Builder#setExtension(char, String)
<i>597</i>&nbsp;     * @since 1.7
<i>598</i>&nbsp;     */
<i>599</i>&nbsp;    public static final char UNICODE_LOCALE_EXTENSION = &#39;u&#39;;
<i>600</i>&nbsp;
<i>601</i>&nbsp;    /** serialization ID
<i>602</i>&nbsp;     */
<i>603</i>&nbsp;    static final long serialVersionUID = 9149081749638150636L;
<i>604</i>&nbsp;
<i>605</i>&nbsp;    /**
<i>606</i>&nbsp;     * Enum for specifying the type defined in ISO 3166. This enum is used to
<i>607</i>&nbsp;     * retrieve the two-letter ISO3166-1 alpha-2, three-letter ISO3166-1
<i>608</i>&nbsp;     * alpha-3, four-letter ISO3166-3 country codes.
<i>609</i>&nbsp;     *
<i>610</i>&nbsp;     * @see #getISOCountries(Locale.IsoCountryCode)
<i>611</i>&nbsp;     * @since 9
<i>612</i>&nbsp;     */
<i>613</i>&nbsp;    public static enum IsoCountryCode {
<i>614</i>&nbsp;        /**
<b class="nc"><i>615</i>&nbsp;         * PART1_ALPHA2 is used to represent the ISO3166-1 alpha-2 two letter</b>
<b class="nc"><i>616</i>&nbsp;         * country codes.</b>
<b class="nc"><i>617</i>&nbsp;         */</b>
<i>618</i>&nbsp;        PART1_ALPHA2 {
<i>619</i>&nbsp;            @Override
<i>620</i>&nbsp;            Set&lt;String&gt; createCountryCodeSet() {
<i>621</i>&nbsp;                return Set.of(Locale.getISOCountries());
<i>622</i>&nbsp;            }
<i>623</i>&nbsp;        },
<i>624</i>&nbsp;
<i>625</i>&nbsp;        /**
<i>626</i>&nbsp;         *
<i>627</i>&nbsp;         * PART1_ALPHA3 is used to represent the ISO3166-1 alpha-3 three letter
<i>628</i>&nbsp;         * country codes.
<i>629</i>&nbsp;         */
<i>630</i>&nbsp;        PART1_ALPHA3 {
<i>631</i>&nbsp;            @Override
<i>632</i>&nbsp;            Set&lt;String&gt; createCountryCodeSet() {
<i>633</i>&nbsp;                return LocaleISOData.computeISO3166_1Alpha3Countries();
<i>634</i>&nbsp;            }
<i>635</i>&nbsp;        },
<i>636</i>&nbsp;
<i>637</i>&nbsp;        /**
<i>638</i>&nbsp;         * PART3 is used to represent the ISO3166-3 four letter country codes.
<i>639</i>&nbsp;         */
<i>640</i>&nbsp;        PART3 {
<i>641</i>&nbsp;            @Override
<i>642</i>&nbsp;            Set&lt;String&gt; createCountryCodeSet() {
<i>643</i>&nbsp;                return Set.of(LocaleISOData.ISO3166_3);
<i>644</i>&nbsp;            }
<i>645</i>&nbsp;        };
<b class="nc"><i>646</i>&nbsp;</b>
<b class="nc"><i>647</i>&nbsp;        /**</b>
<b class="nc"><i>648</i>&nbsp;         * Concrete implementation of this method attempts to compute value</b>
<i>649</i>&nbsp;         * for iso3166CodesMap for each IsoCountryCode type key.
<b class="nc"><i>650</i>&nbsp;         */</b>
<b class="nc"><i>651</i>&nbsp;        abstract Set&lt;String&gt; createCountryCodeSet();</b>
<i>652</i>&nbsp;
<i>653</i>&nbsp;        /**
<i>654</i>&nbsp;         * Map to hold country codes for each ISO3166 part.
<i>655</i>&nbsp;         */
<i>656</i>&nbsp;        private static Map&lt;IsoCountryCode, Set&lt;String&gt;&gt; iso3166CodesMap = new ConcurrentHashMap&lt;&gt;();
<i>657</i>&nbsp;
<i>658</i>&nbsp;        /**
<i>659</i>&nbsp;         * This method is called from Locale class to retrieve country code set
<i>660</i>&nbsp;         * for getISOCountries(type)
<i>661</i>&nbsp;         */
<i>662</i>&nbsp;        static Set&lt;String&gt; retrieveISOCountryCodes(IsoCountryCode type) {
<i>663</i>&nbsp;            return iso3166CodesMap.computeIfAbsent(type, IsoCountryCode::createCountryCodeSet);
<i>664</i>&nbsp;        }
<i>665</i>&nbsp;    }
<i>666</i>&nbsp;
<i>667</i>&nbsp;    /**
<i>668</i>&nbsp;     * Display types for retrieving localized names from the name providers.
<i>669</i>&nbsp;     */
<i>670</i>&nbsp;    private static final int DISPLAY_LANGUAGE  = 0;
<i>671</i>&nbsp;    private static final int DISPLAY_COUNTRY   = 1;
<i>672</i>&nbsp;    private static final int DISPLAY_VARIANT   = 2;
<i>673</i>&nbsp;    private static final int DISPLAY_SCRIPT    = 3;
<i>674</i>&nbsp;    private static final int DISPLAY_UEXT_KEY  = 4;
<i>675</i>&nbsp;    private static final int DISPLAY_UEXT_TYPE = 5;
<i>676</i>&nbsp;
<b class="nc"><i>677</i>&nbsp;    /**</b>
<i>678</i>&nbsp;     * Private constructor used by getInstance method
<i>679</i>&nbsp;     */
<i>680</i>&nbsp;    private Locale(BaseLocale baseLocale, LocaleExtensions extensions) {
<i>681</i>&nbsp;        this.baseLocale = baseLocale;
<i>682</i>&nbsp;        this.localeExtensions = extensions;
<i>683</i>&nbsp;    }
<i>684</i>&nbsp;
<i>685</i>&nbsp;    /**
<i>686</i>&nbsp;     * Construct a locale from language, country and variant.
<i>687</i>&nbsp;     * This constructor normalizes the language value to lowercase and
<i>688</i>&nbsp;     * the country value to uppercase.
<i>689</i>&nbsp;     * &lt;p&gt;
<i>690</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt;
<i>691</i>&nbsp;     * &lt;ul&gt;
<i>692</i>&nbsp;     * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
<i>693</i>&nbsp;     * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
<i>694</i>&nbsp;     * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
<i>695</i>&nbsp;     * API on Locale will return only the OLD codes.
<i>696</i>&nbsp;     * &lt;li&gt;For backward compatibility reasons, this constructor does not make
<i>697</i>&nbsp;     * any syntactic checks on the input.
<i>698</i>&nbsp;     * &lt;li&gt;The two cases (&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) and (&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) are handled specially,
<i>699</i>&nbsp;     * see &lt;a href=&quot;#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt; for more information.
<i>700</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>701</i>&nbsp;     *</b>
<i>702</i>&nbsp;     * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<i>703</i>&nbsp;     * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about
<i>704</i>&nbsp;     * valid language values.
<i>705</i>&nbsp;     * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.
<i>706</i>&nbsp;     * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.
<i>707</i>&nbsp;     * @param variant Any arbitrary value used to indicate a variation of a &lt;code&gt;Locale&lt;/code&gt;.
<i>708</i>&nbsp;     * See the &lt;code&gt;Locale&lt;/code&gt; class description for the details.
<b class="nc"><i>709</i>&nbsp;     * @exception NullPointerException thrown if any argument is null.</b>
<b class="nc"><i>710</i>&nbsp;     */</b>
<i>711</i>&nbsp;    public Locale(String language, String country, String variant) {
<i>712</i>&nbsp;        if (language== null || country == null || variant == null) {
<i>713</i>&nbsp;            throw new NullPointerException();
<i>714</i>&nbsp;        }
<i>715</i>&nbsp;        baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), &quot;&quot;, country, variant);
<i>716</i>&nbsp;        localeExtensions = getCompatibilityExtensions(language, &quot;&quot;, country, variant);
<i>717</i>&nbsp;    }
<i>718</i>&nbsp;
<i>719</i>&nbsp;    /**
<i>720</i>&nbsp;     * Construct a locale from language and country.
<i>721</i>&nbsp;     * This constructor normalizes the language value to lowercase and
<i>722</i>&nbsp;     * the country value to uppercase.
<i>723</i>&nbsp;     * &lt;p&gt;
<i>724</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt;
<i>725</i>&nbsp;     * &lt;ul&gt;
<i>726</i>&nbsp;     * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines
<i>727</i>&nbsp;     * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
<b class="nc"><i>728</i>&nbsp;     * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other</b>
<i>729</i>&nbsp;     * API on Locale will return only the OLD codes.
<i>730</i>&nbsp;     * &lt;li&gt;For backward compatibility reasons, this constructor does not make
<i>731</i>&nbsp;     * any syntactic checks on the input.
<i>732</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>733</i>&nbsp;     *</b>
<b class="nc"><i>734</i>&nbsp;     * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag</b>
<i>735</i>&nbsp;     * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about
<i>736</i>&nbsp;     * valid language values.
<b class="nc"><i>737</i>&nbsp;     * @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.</b>
<b class="nc"><i>738</i>&nbsp;     * See the &lt;code&gt;Locale&lt;/code&gt; class description about valid country values.</b>
<i>739</i>&nbsp;     * @exception NullPointerException thrown if either argument is null.
<i>740</i>&nbsp;     */
<b class="nc"><i>741</i>&nbsp;    public Locale(String language, String country) {</b>
<b class="nc"><i>742</i>&nbsp;        this(language, country, &quot;&quot;);</b>
<i>743</i>&nbsp;    }
<i>744</i>&nbsp;
<i>745</i>&nbsp;    /**
<b class="nc"><i>746</i>&nbsp;     * Construct a locale from a language code.</b>
<b class="nc"><i>747</i>&nbsp;     * This constructor normalizes the language value to lowercase.</b>
<i>748</i>&nbsp;     * &lt;p&gt;
<i>749</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt;
<b class="nc"><i>750</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>751</i>&nbsp;     * &lt;li&gt;ISO 639 is not a stable standard; some of the language codes it defines</b>
<i>752</i>&nbsp;     * (specifically &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) have changed.  This constructor accepts both the
<i>753</i>&nbsp;     * old codes (&quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot;) and the new codes (&quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;), but all other
<i>754</i>&nbsp;     * API on Locale will return only the OLD codes.
<i>755</i>&nbsp;     * &lt;li&gt;For backward compatibility reasons, this constructor does not make
<b class="nc"><i>756</i>&nbsp;     * any syntactic checks on the input.</b>
<i>757</i>&nbsp;     * &lt;/ul&gt;
<i>758</i>&nbsp;     *
<i>759</i>&nbsp;     * @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag
<b class="nc"><i>760</i>&nbsp;     * up to 8 characters in length.  See the &lt;code&gt;Locale&lt;/code&gt; class description about</b>
<i>761</i>&nbsp;     * valid language values.
<i>762</i>&nbsp;     * @exception NullPointerException thrown if argument is null.
<i>763</i>&nbsp;     * @since 1.4
<i>764</i>&nbsp;     */
<b class="nc"><i>765</i>&nbsp;    public Locale(String language) {</b>
<b class="nc"><i>766</i>&nbsp;        this(language, &quot;&quot;, &quot;&quot;);</b>
<b class="nc"><i>767</i>&nbsp;    }</b>
<i>768</i>&nbsp;
<i>769</i>&nbsp;    /**
<b class="nc"><i>770</i>&nbsp;     * This method must be called only for creating the Locale.*</b>
<b class="nc"><i>771</i>&nbsp;     * constants due to making shortcuts.</b>
<b class="nc"><i>772</i>&nbsp;     */</b>
<i>773</i>&nbsp;    private static Locale createConstant(String lang, String country) {
<b class="nc"><i>774</i>&nbsp;        BaseLocale base = BaseLocale.createInstance(lang, country);</b>
<i>775</i>&nbsp;        return getInstance(base, null);
<i>776</i>&nbsp;    }
<i>777</i>&nbsp;
<i>778</i>&nbsp;    /**
<b class="nc"><i>779</i>&nbsp;     * Returns a &lt;code&gt;Locale&lt;/code&gt; constructed from the given</b>
<b class="nc"><i>780</i>&nbsp;     * &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt; and</b>
<i>781</i>&nbsp;     * &lt;code&gt;variant&lt;/code&gt;. If the same &lt;code&gt;Locale&lt;/code&gt; instance
<b class="nc"><i>782</i>&nbsp;     * is available in the cache, then that instance is</b>
<b class="nc"><i>783</i>&nbsp;     * returned. Otherwise, a new &lt;code&gt;Locale&lt;/code&gt; instance is</b>
<i>784</i>&nbsp;     * created and cached.
<b class="nc"><i>785</i>&nbsp;     *</b>
<b class="nc"><i>786</i>&nbsp;     * @param language lowercase 2 to 8 language code.</b>
<b class="nc"><i>787</i>&nbsp;     * @param country uppercase two-letter ISO-3166 code and numeric-3 UN M.49 area code.</b>
<i>788</i>&nbsp;     * @param variant vendor and browser specific code. See class description.
<b class="nc"><i>789</i>&nbsp;     * @return the &lt;code&gt;Locale&lt;/code&gt; instance requested</b>
<b class="nc"><i>790</i>&nbsp;     * @exception NullPointerException if any argument is null.</b>
<i>791</i>&nbsp;     */
<b class="nc"><i>792</i>&nbsp;    static Locale getInstance(String language, String country, String variant) {</b>
<i>793</i>&nbsp;        return getInstance(language, &quot;&quot;, country, variant, null);
<i>794</i>&nbsp;    }
<i>795</i>&nbsp;
<i>796</i>&nbsp;    static Locale getInstance(String language, String script, String country,
<b class="nc"><i>797</i>&nbsp;                                      String variant, LocaleExtensions extensions) {</b>
<i>798</i>&nbsp;        if (language== null || script == null || country == null || variant == null) {
<i>799</i>&nbsp;            throw new NullPointerException();
<i>800</i>&nbsp;        }
<i>801</i>&nbsp;
<i>802</i>&nbsp;        if (extensions == null) {
<i>803</i>&nbsp;            extensions = getCompatibilityExtensions(language, script, country, variant);
<i>804</i>&nbsp;        }
<i>805</i>&nbsp;
<i>806</i>&nbsp;        BaseLocale baseloc = BaseLocale.getInstance(language, script, country, variant);
<i>807</i>&nbsp;        return getInstance(baseloc, extensions);
<i>808</i>&nbsp;    }
<i>809</i>&nbsp;
<i>810</i>&nbsp;    static Locale getInstance(BaseLocale baseloc, LocaleExtensions extensions) {
<i>811</i>&nbsp;        if (extensions == null) {
<i>812</i>&nbsp;            return LOCALECACHE.get(baseloc);
<i>813</i>&nbsp;        } else {
<i>814</i>&nbsp;            LocaleKey key = new LocaleKey(baseloc, extensions);
<b class="nc"><i>815</i>&nbsp;            return LOCALECACHE.get(key);</b>
<i>816</i>&nbsp;        }
<i>817</i>&nbsp;    }
<i>818</i>&nbsp;
<i>819</i>&nbsp;    private static class Cache extends LocaleObjectCache&lt;Object, Locale&gt; {
<i>820</i>&nbsp;        private Cache() {
<i>821</i>&nbsp;        }
<i>822</i>&nbsp;
<i>823</i>&nbsp;        @Override
<i>824</i>&nbsp;        protected Locale createObject(Object key) {
<i>825</i>&nbsp;            if (key instanceof BaseLocale) {
<i>826</i>&nbsp;                return new Locale((BaseLocale)key, null);
<i>827</i>&nbsp;            } else {
<i>828</i>&nbsp;                LocaleKey lk = (LocaleKey)key;
<i>829</i>&nbsp;                return new Locale(lk.base, lk.exts);
<i>830</i>&nbsp;            }
<i>831</i>&nbsp;        }
<i>832</i>&nbsp;    }
<i>833</i>&nbsp;
<i>834</i>&nbsp;    private static final class LocaleKey {
<i>835</i>&nbsp;        private final BaseLocale base;
<b class="nc"><i>836</i>&nbsp;        private final LocaleExtensions exts;</b>
<i>837</i>&nbsp;        private final int hash;
<b class="nc"><i>838</i>&nbsp;</b>
<b class="nc"><i>839</i>&nbsp;        private LocaleKey(BaseLocale baseLocale, LocaleExtensions extensions) {</b>
<b class="nc"><i>840</i>&nbsp;            base = baseLocale;</b>
<b class="nc"><i>841</i>&nbsp;            exts = extensions;</b>
<i>842</i>&nbsp;
<b class="nc"><i>843</i>&nbsp;            // Calculate the hash value here because it&#39;s always used.</b>
<i>844</i>&nbsp;            int h = base.hashCode();
<b class="nc"><i>845</i>&nbsp;            if (exts != null) {</b>
<i>846</i>&nbsp;                h ^= exts.hashCode();
<b class="nc"><i>847</i>&nbsp;            }</b>
<b class="nc"><i>848</i>&nbsp;            hash = h;</b>
<b class="nc"><i>849</i>&nbsp;        }</b>
<b class="nc"><i>850</i>&nbsp;</b>
<i>851</i>&nbsp;        @Override
<b class="nc"><i>852</i>&nbsp;        public boolean equals(Object obj) {</b>
<i>853</i>&nbsp;            if (this == obj) {
<b class="nc"><i>854</i>&nbsp;                return true;</b>
<i>855</i>&nbsp;            }
<b class="nc"><i>856</i>&nbsp;            if (!(obj instanceof LocaleKey)) {</b>
<i>857</i>&nbsp;                return false;
<b class="nc"><i>858</i>&nbsp;            }</b>
<i>859</i>&nbsp;            LocaleKey other = (LocaleKey)obj;
<i>860</i>&nbsp;            if (hash != other.hash || !base.equals(other.base)) {
<i>861</i>&nbsp;                return false;
<i>862</i>&nbsp;            }
<b class="nc"><i>863</i>&nbsp;            if (exts == null) {</b>
<i>864</i>&nbsp;                return other.exts == null;
<i>865</i>&nbsp;            }
<b class="nc"><i>866</i>&nbsp;            return exts.equals(other.exts);</b>
<i>867</i>&nbsp;        }
<b class="nc"><i>868</i>&nbsp;</b>
<i>869</i>&nbsp;        @Override
<b class="nc"><i>870</i>&nbsp;        public int hashCode() {</b>
<b class="nc"><i>871</i>&nbsp;            return hash;</b>
<b class="nc"><i>872</i>&nbsp;        }</b>
<b class="nc"><i>873</i>&nbsp;    }</b>
<i>874</i>&nbsp;
<b class="nc"><i>875</i>&nbsp;    /**</b>
<b class="nc"><i>876</i>&nbsp;     * Gets the current value of the default locale for this instance</b>
<i>877</i>&nbsp;     * of the Java Virtual Machine.
<b class="nc"><i>878</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>879</i>&nbsp;     * The Java Virtual Machine sets the default locale during startup</b>
<b class="nc"><i>880</i>&nbsp;     * based on the host environment. It is used by many locale-sensitive</b>
<i>881</i>&nbsp;     * methods if no locale is explicitly specified.
<b class="nc"><i>882</i>&nbsp;     * It can be changed using the</b>
<i>883</i>&nbsp;     * {@link #setDefault(java.util.Locale) setDefault} method.
<b class="nc"><i>884</i>&nbsp;     *</b>
<i>885</i>&nbsp;     * @return the default locale for this instance of the Java Virtual Machine
<i>886</i>&nbsp;     */
<i>887</i>&nbsp;    public static Locale getDefault() {
<b class="nc"><i>888</i>&nbsp;        // do not synchronize this method - see 4071298</b>
<i>889</i>&nbsp;        return defaultLocale;
<i>890</i>&nbsp;    }
<i>891</i>&nbsp;
<b class="nc"><i>892</i>&nbsp;    /**</b>
<b class="nc"><i>893</i>&nbsp;     * Gets the current value of the default locale for the specified Category</b>
<b class="nc"><i>894</i>&nbsp;     * for this instance of the Java Virtual Machine.</b>
<b class="nc"><i>895</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>896</i>&nbsp;     * The Java Virtual Machine sets the default locale during startup based</b>
<b class="nc"><i>897</i>&nbsp;     * on the host environment. It is used by many locale-sensitive methods</b>
<b class="nc"><i>898</i>&nbsp;     * if no locale is explicitly specified. It can be changed using the</b>
<b class="nc"><i>899</i>&nbsp;     * setDefault(Locale.Category, Locale) method.</b>
<b class="nc"><i>900</i>&nbsp;     *</b>
<i>901</i>&nbsp;     * @param category - the specified category to get the default locale
<i>902</i>&nbsp;     * @throws NullPointerException if category is null
<i>903</i>&nbsp;     * @return the default locale for the specified Category for this instance
<i>904</i>&nbsp;     *     of the Java Virtual Machine
<i>905</i>&nbsp;     * @see #setDefault(Locale.Category, Locale)
<i>906</i>&nbsp;     * @since 1.7
<i>907</i>&nbsp;     */
<i>908</i>&nbsp;    public static Locale getDefault(Locale.Category category) {
<i>909</i>&nbsp;        // do not synchronize this method - see 4071298
<i>910</i>&nbsp;        switch (category) {
<i>911</i>&nbsp;        case DISPLAY:
<i>912</i>&nbsp;            if (defaultDisplayLocale == null) {
<i>913</i>&nbsp;                synchronized(Locale.class) {
<i>914</i>&nbsp;                    if (defaultDisplayLocale == null) {
<i>915</i>&nbsp;                        defaultDisplayLocale = initDefault(category);
<i>916</i>&nbsp;                    }
<i>917</i>&nbsp;                }
<i>918</i>&nbsp;            }
<i>919</i>&nbsp;            return defaultDisplayLocale;
<i>920</i>&nbsp;        case FORMAT:
<i>921</i>&nbsp;            if (defaultFormatLocale == null) {
<i>922</i>&nbsp;                synchronized(Locale.class) {
<i>923</i>&nbsp;                    if (defaultFormatLocale == null) {
<i>924</i>&nbsp;                        defaultFormatLocale = initDefault(category);
<i>925</i>&nbsp;                    }
<i>926</i>&nbsp;                }
<i>927</i>&nbsp;            }
<i>928</i>&nbsp;            return defaultFormatLocale;
<i>929</i>&nbsp;        default:
<i>930</i>&nbsp;            assert false: &quot;Unknown Category&quot;;
<i>931</i>&nbsp;        }
<i>932</i>&nbsp;        return getDefault();
<b class="nc"><i>933</i>&nbsp;    }</b>
<b class="nc"><i>934</i>&nbsp;</b>
<b class="nc"><i>935</i>&nbsp;    private static Locale initDefault() {</b>
<i>936</i>&nbsp;        String language, region, script, country, variant;
<i>937</i>&nbsp;        Properties props = GetPropertyAction.privilegedGetProperties();
<i>938</i>&nbsp;        language = props.getProperty(&quot;user.language&quot;, &quot;en&quot;);
<i>939</i>&nbsp;        // for compatibility, check for old user.region property
<i>940</i>&nbsp;        region = props.getProperty(&quot;user.region&quot;);
<i>941</i>&nbsp;        if (region != null) {
<i>942</i>&nbsp;            // region can be of form country, country_variant, or _variant
<i>943</i>&nbsp;            int i = region.indexOf(&#39;_&#39;);
<i>944</i>&nbsp;            if (i &gt;= 0) {
<i>945</i>&nbsp;                country = region.substring(0, i);
<i>946</i>&nbsp;                variant = region.substring(i + 1);
<i>947</i>&nbsp;            } else {
<i>948</i>&nbsp;                country = region;
<i>949</i>&nbsp;                variant = &quot;&quot;;
<i>950</i>&nbsp;            }
<i>951</i>&nbsp;            script = &quot;&quot;;
<i>952</i>&nbsp;        } else {
<i>953</i>&nbsp;            script = props.getProperty(&quot;user.script&quot;, &quot;&quot;);
<i>954</i>&nbsp;            country = props.getProperty(&quot;user.country&quot;, &quot;&quot;);
<i>955</i>&nbsp;            variant = props.getProperty(&quot;user.variant&quot;, &quot;&quot;);
<i>956</i>&nbsp;        }
<i>957</i>&nbsp;
<i>958</i>&nbsp;        return getInstance(language, script, country, variant,
<i>959</i>&nbsp;                getDefaultExtensions(props.getProperty(&quot;user.extensions&quot;, &quot;&quot;))
<i>960</i>&nbsp;                    .orElse(null));
<i>961</i>&nbsp;    }
<i>962</i>&nbsp;
<i>963</i>&nbsp;    private static Locale initDefault(Locale.Category category) {
<i>964</i>&nbsp;        Properties props = GetPropertyAction.privilegedGetProperties();
<i>965</i>&nbsp;
<i>966</i>&nbsp;        return getInstance(
<i>967</i>&nbsp;            props.getProperty(category.languageKey,
<b class="nc"><i>968</i>&nbsp;                    defaultLocale.getLanguage()),</b>
<b class="nc"><i>969</i>&nbsp;            props.getProperty(category.scriptKey,</b>
<b class="nc"><i>970</i>&nbsp;                    defaultLocale.getScript()),</b>
<b class="nc"><i>971</i>&nbsp;            props.getProperty(category.countryKey,</b>
<i>972</i>&nbsp;                    defaultLocale.getCountry()),
<b class="nc"><i>973</i>&nbsp;            props.getProperty(category.variantKey,</b>
<b class="nc"><i>974</i>&nbsp;                    defaultLocale.getVariant()),</b>
<i>975</i>&nbsp;            getDefaultExtensions(props.getProperty(category.extensionsKey, &quot;&quot;))
<b class="nc"><i>976</i>&nbsp;                .orElse(defaultLocale.getLocaleExtensions()));</b>
<i>977</i>&nbsp;    }
<b class="nc"><i>978</i>&nbsp;</b>
<b class="nc"><i>979</i>&nbsp;    private static Optional&lt;LocaleExtensions&gt; getDefaultExtensions(String extensionsProp) {</b>
<i>980</i>&nbsp;        LocaleExtensions exts = null;
<b class="nc"><i>981</i>&nbsp;</b>
<b class="nc"><i>982</i>&nbsp;        try {</b>
<i>983</i>&nbsp;            exts = new InternalLocaleBuilder()
<b class="nc"><i>984</i>&nbsp;                .setExtensions(extensionsProp)</b>
<i>985</i>&nbsp;                .getLocaleExtensions();
<i>986</i>&nbsp;        } catch (LocaleSyntaxException e) {
<i>987</i>&nbsp;            // just ignore this incorrect property
<i>988</i>&nbsp;        }
<i>989</i>&nbsp;
<i>990</i>&nbsp;        return Optional.ofNullable(exts);
<i>991</i>&nbsp;    }
<i>992</i>&nbsp;
<i>993</i>&nbsp;    /**
<i>994</i>&nbsp;     * Sets the default locale for this instance of the Java Virtual Machine.
<i>995</i>&nbsp;     * This does not affect the host locale.
<i>996</i>&nbsp;     * &lt;p&gt;
<i>997</i>&nbsp;     * If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt;
<i>998</i>&nbsp;     * method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt;
<b class="nc"><i>999</i>&nbsp;     * permission before the default locale is changed.</b>
<i>1000</i>&nbsp;     * &lt;p&gt;
<i>1001</i>&nbsp;     * The Java Virtual Machine sets the default locale during startup
<i>1002</i>&nbsp;     * based on the host environment. It is used by many locale-sensitive
<i>1003</i>&nbsp;     * methods if no locale is explicitly specified.
<i>1004</i>&nbsp;     * &lt;p&gt;
<i>1005</i>&nbsp;     * Since changing the default locale may affect many different areas
<i>1006</i>&nbsp;     * of functionality, this method should only be used if the caller
<i>1007</i>&nbsp;     * is prepared to reinitialize locale-sensitive code running
<i>1008</i>&nbsp;     * within the same Java Virtual Machine.
<i>1009</i>&nbsp;     * &lt;p&gt;
<i>1010</i>&nbsp;     * By setting the default locale with this method, all of the default
<i>1011</i>&nbsp;     * locales for each Category are also set to the specified default locale.
<i>1012</i>&nbsp;     *
<i>1013</i>&nbsp;     * @throws SecurityException
<b class="nc"><i>1014</i>&nbsp;     *        if a security manager exists and its</b>
<b class="nc"><i>1015</i>&nbsp;     *        &lt;code&gt;checkPermission&lt;/code&gt; method doesn&#39;t allow the operation.</b>
<i>1016</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;newLocale&lt;/code&gt; is null
<b class="nc"><i>1017</i>&nbsp;     * @param newLocale the new default locale</b>
<b class="nc"><i>1018</i>&nbsp;     * @see SecurityManager#checkPermission</b>
<b class="nc"><i>1019</i>&nbsp;     * @see java.util.PropertyPermission</b>
<i>1020</i>&nbsp;     */
<i>1021</i>&nbsp;    public static synchronized void setDefault(Locale newLocale) {
<i>1022</i>&nbsp;        setDefault(Category.DISPLAY, newLocale);
<i>1023</i>&nbsp;        setDefault(Category.FORMAT, newLocale);
<i>1024</i>&nbsp;        defaultLocale = newLocale;
<i>1025</i>&nbsp;    }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;    /**
<i>1028</i>&nbsp;     * Sets the default locale for the specified Category for this instance
<i>1029</i>&nbsp;     * of the Java Virtual Machine. This does not affect the host locale.
<i>1030</i>&nbsp;     * &lt;p&gt;
<i>1031</i>&nbsp;     * If there is a security manager, its checkPermission method is called
<i>1032</i>&nbsp;     * with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before
<i>1033</i>&nbsp;     * the default locale is changed.
<i>1034</i>&nbsp;     * &lt;p&gt;
<i>1035</i>&nbsp;     * The Java Virtual Machine sets the default locale during startup based
<i>1036</i>&nbsp;     * on the host environment. It is used by many locale-sensitive methods
<i>1037</i>&nbsp;     * if no locale is explicitly specified.
<i>1038</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>1039</i>&nbsp;     * Since changing the default locale may affect many different areas of</b>
<b class="nc"><i>1040</i>&nbsp;     * functionality, this method should only be used if the caller is</b>
<i>1041</i>&nbsp;     * prepared to reinitialize locale-sensitive code running within the
<b class="nc"><i>1042</i>&nbsp;     * same Java Virtual Machine.</b>
<b class="nc"><i>1043</i>&nbsp;     *</b>
<b class="nc"><i>1044</i>&nbsp;     * @param category - the specified category to set the default locale</b>
<i>1045</i>&nbsp;     * @param newLocale - the new default locale
<i>1046</i>&nbsp;     * @throws SecurityException if a security manager exists and its
<i>1047</i>&nbsp;     *     checkPermission method doesn&#39;t allow the operation.
<b class="nc"><i>1048</i>&nbsp;     * @throws NullPointerException if category and/or newLocale is null</b>
<b class="nc"><i>1049</i>&nbsp;     * @see SecurityManager#checkPermission(java.security.Permission)</b>
<b class="nc"><i>1050</i>&nbsp;     * @see PropertyPermission</b>
<b class="nc"><i>1051</i>&nbsp;     * @see #getDefault(Locale.Category)</b>
<i>1052</i>&nbsp;     * @since 1.7
<b class="nc"><i>1053</i>&nbsp;     */</b>
<i>1054</i>&nbsp;    public static synchronized void setDefault(Locale.Category category,
<i>1055</i>&nbsp;        Locale newLocale) {
<i>1056</i>&nbsp;        if (category == null)
<i>1057</i>&nbsp;            throw new NullPointerException(&quot;Category cannot be NULL&quot;);
<i>1058</i>&nbsp;        if (newLocale == null)
<i>1059</i>&nbsp;            throw new NullPointerException(&quot;Can&#39;t set default locale to NULL&quot;);
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;        SecurityManager sm = System.getSecurityManager();
<i>1062</i>&nbsp;        if (sm != null) sm.checkPermission(new PropertyPermission
<i>1063</i>&nbsp;                        (&quot;user.language&quot;, &quot;write&quot;));
<i>1064</i>&nbsp;        switch (category) {
<i>1065</i>&nbsp;        case DISPLAY:
<i>1066</i>&nbsp;            defaultDisplayLocale = newLocale;
<i>1067</i>&nbsp;            break;
<i>1068</i>&nbsp;        case FORMAT:
<i>1069</i>&nbsp;            defaultFormatLocale = newLocale;
<i>1070</i>&nbsp;            break;
<i>1071</i>&nbsp;        default:
<i>1072</i>&nbsp;            assert false: &quot;Unknown Category&quot;;
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;    }
<i>1075</i>&nbsp;
<b class="nc"><i>1076</i>&nbsp;    /**</b>
<i>1077</i>&nbsp;     * Returns an array of all installed locales.
<i>1078</i>&nbsp;     * The returned array represents the union of locales supported
<i>1079</i>&nbsp;     * by the Java runtime environment and by installed
<i>1080</i>&nbsp;     * {@link java.util.spi.LocaleServiceProvider LocaleServiceProvider}
<i>1081</i>&nbsp;     * implementations.  It must contain at least a &lt;code&gt;Locale&lt;/code&gt;
<i>1082</i>&nbsp;     * instance equal to {@link java.util.Locale#US Locale.US}.
<i>1083</i>&nbsp;     *
<i>1084</i>&nbsp;     * @return An array of installed locales.
<i>1085</i>&nbsp;     */
<i>1086</i>&nbsp;    public static Locale[] getAvailableLocales() {
<i>1087</i>&nbsp;        return LocaleServiceProviderPool.getAllAvailableLocales();
<i>1088</i>&nbsp;    }
<i>1089</i>&nbsp;
<b class="nc"><i>1090</i>&nbsp;    /**</b>
<i>1091</i>&nbsp;     * Returns a list of all 2-letter country codes defined in ISO 3166.
<i>1092</i>&nbsp;     * Can be used to create Locales.
<i>1093</i>&nbsp;     * This method is equivalent to {@link #getISOCountries(Locale.IsoCountryCode type)}
<i>1094</i>&nbsp;     * with {@code type}  {@link IsoCountryCode#PART1_ALPHA2}.
<i>1095</i>&nbsp;     * &lt;p&gt;
<i>1096</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class also supports other codes for
<i>1097</i>&nbsp;     * country (region), such as 3-letter numeric UN M.49 area codes.
<i>1098</i>&nbsp;     * Therefore, the list returned by this method does not contain ALL valid
<i>1099</i>&nbsp;     * codes that can be used to create Locales.
<i>1100</i>&nbsp;     * &lt;p&gt;
<i>1101</i>&nbsp;     * Note that this method does not return obsolete 2-letter country codes.
<b class="nc"><i>1102</i>&nbsp;     * ISO3166-3 codes which designate country codes for those obsolete codes,</b>
<i>1103</i>&nbsp;     * can be retrieved from {@link #getISOCountries(Locale.IsoCountryCode type)} with
<i>1104</i>&nbsp;     * {@code type}  {@link IsoCountryCode#PART3}.
<i>1105</i>&nbsp;     * @return An array of ISO 3166 two-letter country codes.
<i>1106</i>&nbsp;     */
<i>1107</i>&nbsp;    public static String[] getISOCountries() {
<i>1108</i>&nbsp;        if (isoCountries == null) {
<i>1109</i>&nbsp;            isoCountries = getISO2Table(LocaleISOData.isoCountryTable);
<i>1110</i>&nbsp;        }
<i>1111</i>&nbsp;        String[] result = new String[isoCountries.length];
<b class="nc"><i>1112</i>&nbsp;        System.arraycopy(isoCountries, 0, result, 0, isoCountries.length);</b>
<i>1113</i>&nbsp;        return result;
<i>1114</i>&nbsp;    }
<i>1115</i>&nbsp;
<i>1116</i>&nbsp;    /**
<i>1117</i>&nbsp;     * Returns a {@code Set} of ISO3166 country codes for the specified type.
<i>1118</i>&nbsp;     *
<i>1119</i>&nbsp;     * @param type {@link Locale.IsoCountryCode} specified ISO code type.
<i>1120</i>&nbsp;     * @see java.util.Locale.IsoCountryCode
<i>1121</i>&nbsp;     * @throws NullPointerException if type is null
<i>1122</i>&nbsp;     * @return a {@code Set} of ISO country codes for the specified type.
<b class="nc"><i>1123</i>&nbsp;     * @since 9</b>
<i>1124</i>&nbsp;     */
<i>1125</i>&nbsp;    public static Set&lt;String&gt; getISOCountries(IsoCountryCode type) {
<i>1126</i>&nbsp;        Objects.requireNonNull(type);
<i>1127</i>&nbsp;        return IsoCountryCode.retrieveISOCountryCodes(type);
<i>1128</i>&nbsp;    }
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;    /**
<i>1131</i>&nbsp;     * Returns a list of all 2-letter language codes defined in ISO 639.
<i>1132</i>&nbsp;     * Can be used to create Locales.
<i>1133</i>&nbsp;     * &lt;p&gt;
<i>1134</i>&nbsp;     * &lt;b&gt;Note:&lt;/b&gt;
<i>1135</i>&nbsp;     * &lt;ul&gt;
<b class="nc"><i>1136</i>&nbsp;     * &lt;li&gt;ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.</b>
<i>1137</i>&nbsp;     * The list this function returns includes both the new and the old codes for the
<i>1138</i>&nbsp;     * languages whose codes have changed.
<i>1139</i>&nbsp;     * &lt;li&gt;The &lt;code&gt;Locale&lt;/code&gt; class also supports language codes up to
<i>1140</i>&nbsp;     * 8 characters in length.  Therefore, the list returned by this method does
<i>1141</i>&nbsp;     * not contain ALL valid codes that can be used to create Locales.
<i>1142</i>&nbsp;     * &lt;/ul&gt;
<i>1143</i>&nbsp;     *
<i>1144</i>&nbsp;     * @return An array of ISO 639 two-letter language codes.
<i>1145</i>&nbsp;     */
<i>1146</i>&nbsp;    public static String[] getISOLanguages() {
<i>1147</i>&nbsp;        if (isoLanguages == null) {
<i>1148</i>&nbsp;            isoLanguages = getISO2Table(LocaleISOData.isoLanguageTable);
<i>1149</i>&nbsp;        }
<i>1150</i>&nbsp;        String[] result = new String[isoLanguages.length];
<i>1151</i>&nbsp;        System.arraycopy(isoLanguages, 0, result, 0, isoLanguages.length);
<i>1152</i>&nbsp;        return result;
<i>1153</i>&nbsp;    }
<i>1154</i>&nbsp;
<b class="nc"><i>1155</i>&nbsp;    private static String[] getISO2Table(String table) {</b>
<b class="nc"><i>1156</i>&nbsp;        int len = table.length() / 5;</b>
<i>1157</i>&nbsp;        String[] isoTable = new String[len];
<b class="nc"><i>1158</i>&nbsp;        for (int i = 0, j = 0; i &lt; len; i++, j += 5) {</b>
<i>1159</i>&nbsp;            isoTable[i] = table.substring(j, j + 2);
<i>1160</i>&nbsp;        }
<i>1161</i>&nbsp;        return isoTable;
<i>1162</i>&nbsp;    }
<i>1163</i>&nbsp;
<i>1164</i>&nbsp;    /**
<i>1165</i>&nbsp;     * Returns the language code of this Locale.
<i>1166</i>&nbsp;     *
<i>1167</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; ISO 639 is not a stable standard&amp;mdash; some languages&#39; codes have changed.
<i>1168</i>&nbsp;     * Locale&#39;s constructor recognizes both the new and the old codes for the languages
<i>1169</i>&nbsp;     * whose codes have changed, but this function always returns the old code.  If you
<i>1170</i>&nbsp;     * want to check for a specific language whose code has changed, don&#39;t do
<b class="nc"><i>1171</i>&nbsp;     * &lt;pre&gt;</b>
<b class="nc"><i>1172</i>&nbsp;     * if (locale.getLanguage().equals(&quot;he&quot;)) // BAD!</b>
<i>1173</i>&nbsp;     *    ...
<b class="nc"><i>1174</i>&nbsp;     * &lt;/pre&gt;</b>
<i>1175</i>&nbsp;     * Instead, do
<i>1176</i>&nbsp;     * &lt;pre&gt;
<i>1177</i>&nbsp;     * if (locale.getLanguage().equals(new Locale(&quot;he&quot;).getLanguage()))
<i>1178</i>&nbsp;     *    ...
<i>1179</i>&nbsp;     * &lt;/pre&gt;
<i>1180</i>&nbsp;     * @return The language code, or the empty string if none is defined.
<i>1181</i>&nbsp;     * @see #getDisplayLanguage
<i>1182</i>&nbsp;     */
<i>1183</i>&nbsp;    public String getLanguage() {
<i>1184</i>&nbsp;        return baseLocale.getLanguage();
<i>1185</i>&nbsp;    }
<b class="nc"><i>1186</i>&nbsp;</b>
<b class="nc"><i>1187</i>&nbsp;    /**</b>
<i>1188</i>&nbsp;     * Returns the script for this locale, which should
<b class="nc"><i>1189</i>&nbsp;     * either be the empty string or an ISO 15924 4-letter script</b>
<i>1190</i>&nbsp;     * code. The first letter is uppercase and the rest are
<i>1191</i>&nbsp;     * lowercase, for example, &#39;Latn&#39;, &#39;Cyrl&#39;.
<i>1192</i>&nbsp;     *
<i>1193</i>&nbsp;     * @return The script code, or the empty string if none is defined.
<i>1194</i>&nbsp;     * @see #getDisplayScript
<i>1195</i>&nbsp;     * @since 1.7
<i>1196</i>&nbsp;     */
<i>1197</i>&nbsp;    public String getScript() {
<i>1198</i>&nbsp;        return baseLocale.getScript();
<i>1199</i>&nbsp;    }
<i>1200</i>&nbsp;
<i>1201</i>&nbsp;    /**
<i>1202</i>&nbsp;     * Returns the country/region code for this locale, which should
<i>1203</i>&nbsp;     * either be the empty string, an uppercase ISO 3166 2-letter code,
<i>1204</i>&nbsp;     * or a UN M.49 3-digit code.
<i>1205</i>&nbsp;     *
<i>1206</i>&nbsp;     * @return The country/region code, or the empty string if none is defined.
<b class="nc"><i>1207</i>&nbsp;     * @see #getDisplayCountry</b>
<b class="nc"><i>1208</i>&nbsp;     */</b>
<i>1209</i>&nbsp;    public String getCountry() {
<b class="nc"><i>1210</i>&nbsp;        return baseLocale.getRegion();</b>
<i>1211</i>&nbsp;    }
<i>1212</i>&nbsp;
<i>1213</i>&nbsp;    /**
<i>1214</i>&nbsp;     * Returns the variant code for this locale.
<i>1215</i>&nbsp;     *
<i>1216</i>&nbsp;     * @return The variant code, or the empty string if none is defined.
<i>1217</i>&nbsp;     * @see #getDisplayVariant
<i>1218</i>&nbsp;     */
<i>1219</i>&nbsp;    public String getVariant() {
<i>1220</i>&nbsp;        return baseLocale.getVariant();
<i>1221</i>&nbsp;    }
<b class="nc"><i>1222</i>&nbsp;</b>
<b class="nc"><i>1223</i>&nbsp;    /**</b>
<i>1224</i>&nbsp;     * Returns {@code true} if this {@code Locale} has any &lt;a href=&quot;#def_extensions&quot;&gt;
<b class="nc"><i>1225</i>&nbsp;     * extensions&lt;/a&gt;.</b>
<i>1226</i>&nbsp;     *
<i>1227</i>&nbsp;     * @return {@code true} if this {@code Locale} has any extensions
<i>1228</i>&nbsp;     * @since 1.8
<i>1229</i>&nbsp;     */
<i>1230</i>&nbsp;    public boolean hasExtensions() {
<i>1231</i>&nbsp;        return localeExtensions != null;
<i>1232</i>&nbsp;    }
<i>1233</i>&nbsp;
<b class="nc"><i>1234</i>&nbsp;    /**</b>
<i>1235</i>&nbsp;     * Returns a copy of this {@code Locale} with no &lt;a href=&quot;#def_extensions&quot;&gt;
<i>1236</i>&nbsp;     * extensions&lt;/a&gt;. If this {@code Locale} has no extensions, this {@code Locale}
<i>1237</i>&nbsp;     * is returned.
<i>1238</i>&nbsp;     *
<i>1239</i>&nbsp;     * @return a copy of this {@code Locale} with no extensions, or {@code this}
<i>1240</i>&nbsp;     *         if {@code this} has no extensions
<i>1241</i>&nbsp;     * @since 1.8
<i>1242</i>&nbsp;     */
<i>1243</i>&nbsp;    public Locale stripExtensions() {
<b class="nc"><i>1244</i>&nbsp;        return hasExtensions() ? Locale.getInstance(baseLocale, null) : this;</b>
<i>1245</i>&nbsp;    }
<i>1246</i>&nbsp;
<i>1247</i>&nbsp;    /**
<i>1248</i>&nbsp;     * Returns the extension (or private use) value associated with
<i>1249</i>&nbsp;     * the specified key, or null if there is no extension
<i>1250</i>&nbsp;     * associated with the key. To be well-formed, the key must be one
<i>1251</i>&nbsp;     * of &lt;code&gt;[0-9A-Za-z]&lt;/code&gt;. Keys are case-insensitive, so
<i>1252</i>&nbsp;     * for example &#39;z&#39; and &#39;Z&#39; represent the same extension.
<i>1253</i>&nbsp;     *
<i>1254</i>&nbsp;     * @param key the extension key
<i>1255</i>&nbsp;     * @return The extension, or null if this locale defines no
<i>1256</i>&nbsp;     * extension for the specified key.
<i>1257</i>&nbsp;     * @throws IllegalArgumentException if key is not well-formed
<i>1258</i>&nbsp;     * @see #PRIVATE_USE_EXTENSION
<i>1259</i>&nbsp;     * @see #UNICODE_LOCALE_EXTENSION
<i>1260</i>&nbsp;     * @since 1.7
<i>1261</i>&nbsp;     */
<i>1262</i>&nbsp;    public String getExtension(char key) {
<i>1263</i>&nbsp;        if (!LocaleExtensions.isValidKey(key)) {
<i>1264</i>&nbsp;            throw new IllegalArgumentException(&quot;Ill-formed extension key: &quot; + key);
<i>1265</i>&nbsp;        }
<i>1266</i>&nbsp;        return hasExtensions() ? localeExtensions.getExtensionValue(key) : null;
<i>1267</i>&nbsp;    }
<i>1268</i>&nbsp;
<i>1269</i>&nbsp;    /**
<i>1270</i>&nbsp;     * Returns the set of extension keys associated with this locale, or the
<i>1271</i>&nbsp;     * empty set if it has no extensions. The returned set is unmodifiable.
<i>1272</i>&nbsp;     * The keys will all be lower-case.
<i>1273</i>&nbsp;     *
<i>1274</i>&nbsp;     * @return The set of extension keys, or the empty set if this locale has
<i>1275</i>&nbsp;     * no extensions.
<i>1276</i>&nbsp;     * @since 1.7
<i>1277</i>&nbsp;     */
<i>1278</i>&nbsp;    public Set&lt;Character&gt; getExtensionKeys() {
<i>1279</i>&nbsp;        if (!hasExtensions()) {
<i>1280</i>&nbsp;            return Collections.emptySet();
<i>1281</i>&nbsp;        }
<i>1282</i>&nbsp;        return localeExtensions.getKeys();
<i>1283</i>&nbsp;    }
<i>1284</i>&nbsp;
<i>1285</i>&nbsp;    /**
<i>1286</i>&nbsp;     * Returns the set of unicode locale attributes associated with
<i>1287</i>&nbsp;     * this locale, or the empty set if it has no attributes. The
<i>1288</i>&nbsp;     * returned set is unmodifiable.
<i>1289</i>&nbsp;     *
<i>1290</i>&nbsp;     * @return The set of attributes.
<b class="nc"><i>1291</i>&nbsp;     * @since 1.7</b>
<b class="nc"><i>1292</i>&nbsp;     */</b>
<b class="nc"><i>1293</i>&nbsp;    public Set&lt;String&gt; getUnicodeLocaleAttributes() {</b>
<b class="nc"><i>1294</i>&nbsp;        if (!hasExtensions()) {</b>
<b class="nc"><i>1295</i>&nbsp;            return Collections.emptySet();</b>
<i>1296</i>&nbsp;        }
<b class="nc"><i>1297</i>&nbsp;        return localeExtensions.getUnicodeLocaleAttributes();</b>
<b class="nc"><i>1298</i>&nbsp;    }</b>
<b class="nc"><i>1299</i>&nbsp;</b>
<b class="nc"><i>1300</i>&nbsp;    /**</b>
<i>1301</i>&nbsp;     * Returns the Unicode locale type associated with the specified Unicode locale key
<b class="nc"><i>1302</i>&nbsp;     * for this locale. Returns the empty string for keys that are defined with no type.</b>
<b class="nc"><i>1303</i>&nbsp;     * Returns null if the key is not defined. Keys are case-insensitive. The key must</b>
<b class="nc"><i>1304</i>&nbsp;     * be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is</b>
<i>1305</i>&nbsp;     * thrown.
<i>1306</i>&nbsp;     *
<b class="nc"><i>1307</i>&nbsp;     * @param key the Unicode locale key</b>
<b class="nc"><i>1308</i>&nbsp;     * @return The Unicode locale type associated with the key, or null if the</b>
<b class="nc"><i>1309</i>&nbsp;     * locale does not define the key.</b>
<i>1310</i>&nbsp;     * @throws IllegalArgumentException if the key is not well-formed
<i>1311</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null
<b class="nc"><i>1312</i>&nbsp;     * @since 1.7</b>
<b class="nc"><i>1313</i>&nbsp;     */</b>
<b class="nc"><i>1314</i>&nbsp;    public String getUnicodeLocaleType(String key) {</b>
<b class="nc"><i>1315</i>&nbsp;        if (!isUnicodeExtensionKey(key)) {</b>
<i>1316</i>&nbsp;            throw new IllegalArgumentException(&quot;Ill-formed Unicode locale key: &quot; + key);
<b class="nc"><i>1317</i>&nbsp;        }</b>
<i>1318</i>&nbsp;        return hasExtensions() ? localeExtensions.getUnicodeLocaleType(key) : null;
<i>1319</i>&nbsp;    }
<b class="nc"><i>1320</i>&nbsp;</b>
<i>1321</i>&nbsp;    /**
<i>1322</i>&nbsp;     * Returns the set of Unicode locale keys defined by this locale, or the empty set if
<i>1323</i>&nbsp;     * this locale has none.  The returned set is immutable.  Keys are all lower case.
<i>1324</i>&nbsp;     *
<i>1325</i>&nbsp;     * @return The set of Unicode locale keys, or the empty set if this locale has
<i>1326</i>&nbsp;     * no Unicode locale keywords.
<i>1327</i>&nbsp;     * @since 1.7
<i>1328</i>&nbsp;     */
<i>1329</i>&nbsp;    public Set&lt;String&gt; getUnicodeLocaleKeys() {
<i>1330</i>&nbsp;        if (localeExtensions == null) {
<i>1331</i>&nbsp;            return Collections.emptySet();
<i>1332</i>&nbsp;        }
<i>1333</i>&nbsp;        return localeExtensions.getUnicodeLocaleKeys();
<i>1334</i>&nbsp;    }
<i>1335</i>&nbsp;
<i>1336</i>&nbsp;    /**
<i>1337</i>&nbsp;     * Package locale method returning the Locale&#39;s BaseLocale,
<i>1338</i>&nbsp;     * used by ResourceBundle
<i>1339</i>&nbsp;     * @return base locale of this Locale
<i>1340</i>&nbsp;     */
<i>1341</i>&nbsp;    BaseLocale getBaseLocale() {
<i>1342</i>&nbsp;        return baseLocale;
<i>1343</i>&nbsp;    }
<i>1344</i>&nbsp;
<i>1345</i>&nbsp;    /**
<i>1346</i>&nbsp;     * Package private method returning the Locale&#39;s LocaleExtensions,
<i>1347</i>&nbsp;     * used by ResourceBundle.
<i>1348</i>&nbsp;     * @return locale extensions of this Locale,
<i>1349</i>&nbsp;     *         or {@code null} if no extensions are defined
<i>1350</i>&nbsp;     */
<i>1351</i>&nbsp;     LocaleExtensions getLocaleExtensions() {
<i>1352</i>&nbsp;         return localeExtensions;
<i>1353</i>&nbsp;     }
<i>1354</i>&nbsp;
<i>1355</i>&nbsp;    /**
<i>1356</i>&nbsp;     * Returns a string representation of this &lt;code&gt;Locale&lt;/code&gt;
<i>1357</i>&nbsp;     * object, consisting of language, country, variant, script,
<i>1358</i>&nbsp;     * and extensions as below:
<i>1359</i>&nbsp;     * &lt;blockquote&gt;
<i>1360</i>&nbsp;     * language + &quot;_&quot; + country + &quot;_&quot; + (variant + &quot;_#&quot; | &quot;#&quot;) + script + &quot;_&quot; + extensions
<i>1361</i>&nbsp;     * &lt;/blockquote&gt;
<i>1362</i>&nbsp;     *
<i>1363</i>&nbsp;     * Language is always lower case, country is always upper case, script is always title
<i>1364</i>&nbsp;     * case, and extensions are always lower case.  Extensions and private use subtags
<i>1365</i>&nbsp;     * will be in canonical order as explained in {@link #toLanguageTag}.
<i>1366</i>&nbsp;     *
<i>1367</i>&nbsp;     * &lt;p&gt;When the locale has neither script nor extensions, the result is the same as in
<i>1368</i>&nbsp;     * Java 6 and prior.
<i>1369</i>&nbsp;     *
<i>1370</i>&nbsp;     * &lt;p&gt;If both the language and country fields are missing, this function will return
<i>1371</i>&nbsp;     * the empty string, even if the variant, script, or extensions field is present (you
<i>1372</i>&nbsp;     * can&#39;t have a locale with just a variant, the variant must accompany a well-formed
<i>1373</i>&nbsp;     * language or country code).
<i>1374</i>&nbsp;     *
<i>1375</i>&nbsp;     * &lt;p&gt;If script or extensions are present and variant is missing, no underscore is
<i>1376</i>&nbsp;     * added before the &quot;#&quot;.
<i>1377</i>&nbsp;     *
<i>1378</i>&nbsp;     * &lt;p&gt;This behavior is designed to support debugging and to be compatible with
<i>1379</i>&nbsp;     * previous uses of &lt;code&gt;toString&lt;/code&gt; that expected language, country, and variant
<i>1380</i>&nbsp;     * fields only.  To represent a Locale as a String for interchange purposes, use
<i>1381</i>&nbsp;     * {@link #toLanguageTag}.
<i>1382</i>&nbsp;     *
<i>1383</i>&nbsp;     * &lt;p&gt;Examples: &lt;ul&gt;
<i>1384</i>&nbsp;     * &lt;li&gt;{@code en}&lt;/li&gt;
<i>1385</i>&nbsp;     * &lt;li&gt;{@code de_DE}&lt;/li&gt;
<i>1386</i>&nbsp;     * &lt;li&gt;{@code _GB}&lt;/li&gt;
<i>1387</i>&nbsp;     * &lt;li&gt;{@code en_US_WIN}&lt;/li&gt;
<i>1388</i>&nbsp;     * &lt;li&gt;{@code de__POSIX}&lt;/li&gt;
<i>1389</i>&nbsp;     * &lt;li&gt;{@code zh_CN_#Hans}&lt;/li&gt;
<i>1390</i>&nbsp;     * &lt;li&gt;{@code zh_TW_#Hant_x-java}&lt;/li&gt;
<b class="nc"><i>1391</i>&nbsp;     * &lt;li&gt;{@code th_TH_TH_#u-nu-thai}&lt;/li&gt;&lt;/ul&gt;</b>
<b class="nc"><i>1392</i>&nbsp;     *</b>
<i>1393</i>&nbsp;     * @return A string representation of the Locale, for debugging.
<i>1394</i>&nbsp;     * @see #getDisplayName
<b class="nc"><i>1395</i>&nbsp;     * @see #toLanguageTag</b>
<b class="nc"><i>1396</i>&nbsp;     */</b>
<i>1397</i>&nbsp;    @Override
<b class="nc"><i>1398</i>&nbsp;    public final String toString() {</b>
<b class="nc"><i>1399</i>&nbsp;        boolean l = (baseLocale.getLanguage().length() != 0);</b>
<b class="nc"><i>1400</i>&nbsp;        boolean s = (baseLocale.getScript().length() != 0);</b>
<i>1401</i>&nbsp;        boolean r = (baseLocale.getRegion().length() != 0);
<i>1402</i>&nbsp;        boolean v = (baseLocale.getVariant().length() != 0);
<b class="nc"><i>1403</i>&nbsp;        boolean e = (localeExtensions != null &amp;&amp; localeExtensions.getID().length() != 0);</b>
<b class="nc"><i>1404</i>&nbsp;</b>
<b class="nc"><i>1405</i>&nbsp;        StringBuilder result = new StringBuilder(baseLocale.getLanguage());</b>
<b class="nc"><i>1406</i>&nbsp;        if (r || (l &amp;&amp; (v || s || e))) {</b>
<i>1407</i>&nbsp;            result.append(&#39;_&#39;)
<i>1408</i>&nbsp;                .append(baseLocale.getRegion()); // This may just append &#39;_&#39;
<b class="nc"><i>1409</i>&nbsp;        }</b>
<b class="nc"><i>1410</i>&nbsp;        if (v &amp;&amp; (l || r)) {</b>
<b class="nc"><i>1411</i>&nbsp;            result.append(&#39;_&#39;)</b>
<b class="nc"><i>1412</i>&nbsp;                .append(baseLocale.getVariant());</b>
<i>1413</i>&nbsp;        }
<i>1414</i>&nbsp;
<b class="nc"><i>1415</i>&nbsp;        if (s &amp;&amp; (l || r)) {</b>
<b class="nc"><i>1416</i>&nbsp;            result.append(&quot;_#&quot;)</b>
<b class="nc"><i>1417</i>&nbsp;                .append(baseLocale.getScript());</b>
<i>1418</i>&nbsp;        }
<b class="nc"><i>1419</i>&nbsp;</b>
<b class="nc"><i>1420</i>&nbsp;        if (e &amp;&amp; (l || r)) {</b>
<i>1421</i>&nbsp;            result.append(&#39;_&#39;);
<b class="nc"><i>1422</i>&nbsp;            if (!s) {</b>
<b class="nc"><i>1423</i>&nbsp;                result.append(&#39;#&#39;);</b>
<b class="nc"><i>1424</i>&nbsp;            }</b>
<b class="nc"><i>1425</i>&nbsp;            result.append(localeExtensions.getID());</b>
<b class="nc"><i>1426</i>&nbsp;        }</b>
<i>1427</i>&nbsp;
<b class="nc"><i>1428</i>&nbsp;        return result.toString();</b>
<b class="nc"><i>1429</i>&nbsp;    }</b>
<b class="nc"><i>1430</i>&nbsp;</b>
<b class="nc"><i>1431</i>&nbsp;    /**</b>
<i>1432</i>&nbsp;     * Returns a well-formed IETF BCP 47 language tag representing
<b class="nc"><i>1433</i>&nbsp;     * this locale.</b>
<i>1434</i>&nbsp;     *
<b class="nc"><i>1435</i>&nbsp;     * &lt;p&gt;If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or</b>
<i>1436</i>&nbsp;     * variant that does not satisfy the IETF BCP 47 language tag
<i>1437</i>&nbsp;     * syntax requirements, this method handles these fields as
<b class="nc"><i>1438</i>&nbsp;     * described below:</b>
<b class="nc"><i>1439</i>&nbsp;     *</b>
<b class="nc"><i>1440</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Language:&lt;/b&gt; If language is empty, or not &lt;a</b>
<b class="nc"><i>1441</i>&nbsp;     * href=&quot;#def_language&quot; &gt;well-formed&lt;/a&gt; (for example &quot;a&quot; or</b>
<i>1442</i>&nbsp;     * &quot;e2&quot;), it will be emitted as &quot;und&quot; (Undetermined).
<b class="nc"><i>1443</i>&nbsp;     *</b>
<b class="nc"><i>1444</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Country:&lt;/b&gt; If country is not &lt;a</b>
<i>1445</i>&nbsp;     * href=&quot;#def_region&quot;&gt;well-formed&lt;/a&gt; (for example &quot;12&quot; or &quot;USA&quot;),
<i>1446</i>&nbsp;     * it will be omitted.
<i>1447</i>&nbsp;     *
<i>1448</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Variant:&lt;/b&gt; If variant &lt;b&gt;is&lt;/b&gt; &lt;a
<i>1449</i>&nbsp;     * href=&quot;#def_variant&quot;&gt;well-formed&lt;/a&gt;, each sub-segment
<i>1450</i>&nbsp;     * (delimited by &#39;-&#39; or &#39;_&#39;) is emitted as a subtag.  Otherwise:
<i>1451</i>&nbsp;     * &lt;ul&gt;
<i>1452</i>&nbsp;     *
<i>1453</i>&nbsp;     * &lt;li&gt;if all sub-segments match &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;
<i>1454</i>&nbsp;     * (for example &quot;WIN&quot; or &quot;Oracle_JDK_Standard_Edition&quot;), the first
<i>1455</i>&nbsp;     * ill-formed sub-segment and all following will be appended to
<i>1456</i>&nbsp;     * the private use subtag.  The first appended subtag will be
<i>1457</i>&nbsp;     * &quot;lvariant&quot;, followed by the sub-segments in order, separated by
<i>1458</i>&nbsp;     * hyphen. For example, &quot;x-lvariant-WIN&quot;,
<i>1459</i>&nbsp;     * &quot;Oracle-x-lvariant-JDK-Standard-Edition&quot;.
<i>1460</i>&nbsp;     *
<i>1461</i>&nbsp;     * &lt;li&gt;if any sub-segment does not match
<i>1462</i>&nbsp;     * &lt;code&gt;[0-9a-zA-Z]{1,8}&lt;/code&gt;, the variant will be truncated
<i>1463</i>&nbsp;     * and the problematic sub-segment and all following sub-segments
<i>1464</i>&nbsp;     * will be omitted.  If the remainder is non-empty, it will be
<i>1465</i>&nbsp;     * emitted as a private use subtag as above (even if the remainder
<i>1466</i>&nbsp;     * turns out to be well-formed).  For example,
<i>1467</i>&nbsp;     * &quot;Solaris_isjustthecoolestthing&quot; is emitted as
<i>1468</i>&nbsp;     * &quot;x-lvariant-Solaris&quot;, not as &quot;solaris&quot;.&lt;/li&gt;&lt;/ul&gt;
<i>1469</i>&nbsp;     *
<i>1470</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Special Conversions:&lt;/b&gt; Java supports some old locale
<i>1471</i>&nbsp;     * representations, including deprecated ISO language codes,
<i>1472</i>&nbsp;     * for compatibility. This method performs the following
<i>1473</i>&nbsp;     * conversions:
<i>1474</i>&nbsp;     * &lt;ul&gt;
<i>1475</i>&nbsp;     *
<i>1476</i>&nbsp;     * &lt;li&gt;Deprecated ISO language codes &quot;iw&quot;, &quot;ji&quot;, and &quot;in&quot; are
<i>1477</i>&nbsp;     * converted to &quot;he&quot;, &quot;yi&quot;, and &quot;id&quot;, respectively.
<i>1478</i>&nbsp;     *
<i>1479</i>&nbsp;     * &lt;li&gt;A locale with language &quot;no&quot;, country &quot;NO&quot;, and variant
<i>1480</i>&nbsp;     * &quot;NY&quot;, representing Norwegian Nynorsk (Norway), is converted
<i>1481</i>&nbsp;     * to a language tag &quot;nn-NO&quot;.&lt;/li&gt;&lt;/ul&gt;
<i>1482</i>&nbsp;     *
<i>1483</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; Although the language tag created by this
<i>1484</i>&nbsp;     * method is well-formed (satisfies the syntax requirements
<i>1485</i>&nbsp;     * defined by the IETF BCP 47 specification), it is not
<i>1486</i>&nbsp;     * necessarily a valid BCP 47 language tag.  For example,
<i>1487</i>&nbsp;     * &lt;pre&gt;
<i>1488</i>&nbsp;     *   new Locale(&quot;xx&quot;, &quot;YY&quot;).toLanguageTag();&lt;/pre&gt;
<i>1489</i>&nbsp;     *
<i>1490</i>&nbsp;     * will return &quot;xx-YY&quot;, but the language subtag &quot;xx&quot; and the
<i>1491</i>&nbsp;     * region subtag &quot;YY&quot; are invalid because they are not registered
<i>1492</i>&nbsp;     * in the IANA Language Subtag Registry.
<i>1493</i>&nbsp;     *
<i>1494</i>&nbsp;     * @return a BCP47 language tag representing the locale
<i>1495</i>&nbsp;     * @see #forLanguageTag(String)
<i>1496</i>&nbsp;     * @since 1.7
<i>1497</i>&nbsp;     */
<i>1498</i>&nbsp;    public String toLanguageTag() {
<i>1499</i>&nbsp;        if (languageTag != null) {
<i>1500</i>&nbsp;            return languageTag;
<i>1501</i>&nbsp;        }
<i>1502</i>&nbsp;
<i>1503</i>&nbsp;        LanguageTag tag = LanguageTag.parseLocale(baseLocale, localeExtensions);
<i>1504</i>&nbsp;        StringBuilder buf = new StringBuilder();
<i>1505</i>&nbsp;
<i>1506</i>&nbsp;        String subtag = tag.getLanguage();
<i>1507</i>&nbsp;        if (subtag.length() &gt; 0) {
<i>1508</i>&nbsp;            buf.append(LanguageTag.canonicalizeLanguage(subtag));
<i>1509</i>&nbsp;        }
<i>1510</i>&nbsp;
<i>1511</i>&nbsp;        subtag = tag.getScript();
<i>1512</i>&nbsp;        if (subtag.length() &gt; 0) {
<i>1513</i>&nbsp;            buf.append(LanguageTag.SEP);
<i>1514</i>&nbsp;            buf.append(LanguageTag.canonicalizeScript(subtag));
<i>1515</i>&nbsp;        }
<i>1516</i>&nbsp;
<i>1517</i>&nbsp;        subtag = tag.getRegion();
<i>1518</i>&nbsp;        if (subtag.length() &gt; 0) {
<i>1519</i>&nbsp;            buf.append(LanguageTag.SEP);
<i>1520</i>&nbsp;            buf.append(LanguageTag.canonicalizeRegion(subtag));
<i>1521</i>&nbsp;        }
<i>1522</i>&nbsp;
<i>1523</i>&nbsp;        List&lt;String&gt;subtags = tag.getVariants();
<i>1524</i>&nbsp;        for (String s : subtags) {
<i>1525</i>&nbsp;            buf.append(LanguageTag.SEP);
<i>1526</i>&nbsp;            // preserve casing
<i>1527</i>&nbsp;            buf.append(s);
<i>1528</i>&nbsp;        }
<i>1529</i>&nbsp;
<i>1530</i>&nbsp;        subtags = tag.getExtensions();
<i>1531</i>&nbsp;        for (String s : subtags) {
<i>1532</i>&nbsp;            buf.append(LanguageTag.SEP);
<i>1533</i>&nbsp;            buf.append(LanguageTag.canonicalizeExtension(s));
<i>1534</i>&nbsp;        }
<i>1535</i>&nbsp;
<i>1536</i>&nbsp;        subtag = tag.getPrivateuse();
<i>1537</i>&nbsp;        if (subtag.length() &gt; 0) {
<i>1538</i>&nbsp;            if (buf.length() &gt; 0) {
<i>1539</i>&nbsp;                buf.append(LanguageTag.SEP);
<i>1540</i>&nbsp;            }
<i>1541</i>&nbsp;            buf.append(LanguageTag.PRIVATEUSE).append(LanguageTag.SEP);
<i>1542</i>&nbsp;            // preserve casing
<i>1543</i>&nbsp;            buf.append(subtag);
<i>1544</i>&nbsp;        }
<i>1545</i>&nbsp;
<i>1546</i>&nbsp;        String langTag = buf.toString();
<i>1547</i>&nbsp;        synchronized (this) {
<i>1548</i>&nbsp;            if (languageTag == null) {
<i>1549</i>&nbsp;                languageTag = langTag;
<i>1550</i>&nbsp;            }
<i>1551</i>&nbsp;        }
<i>1552</i>&nbsp;        return languageTag;
<i>1553</i>&nbsp;    }
<i>1554</i>&nbsp;
<i>1555</i>&nbsp;    /**
<i>1556</i>&nbsp;     * Returns a locale for the specified IETF BCP 47 language tag string.
<i>1557</i>&nbsp;     *
<i>1558</i>&nbsp;     * &lt;p&gt;If the specified language tag contains any ill-formed subtags,
<i>1559</i>&nbsp;     * the first such subtag and all following subtags are ignored.  Compare
<i>1560</i>&nbsp;     * to {@link Locale.Builder#setLanguageTag} which throws an exception
<i>1561</i>&nbsp;     * in this case.
<i>1562</i>&nbsp;     *
<i>1563</i>&nbsp;     * &lt;p&gt;The following &lt;b&gt;conversions&lt;/b&gt; are performed:&lt;ul&gt;
<i>1564</i>&nbsp;     *
<i>1565</i>&nbsp;     * &lt;li&gt;The language code &quot;und&quot; is mapped to language &quot;&quot;.
<i>1566</i>&nbsp;     *
<i>1567</i>&nbsp;     * &lt;li&gt;The language codes &quot;he&quot;, &quot;yi&quot;, and &quot;id&quot; are mapped to &quot;iw&quot;,
<b class="nc"><i>1568</i>&nbsp;     * &quot;ji&quot;, and &quot;in&quot; respectively. (This is the same canonicalization</b>
<b class="nc"><i>1569</i>&nbsp;     * that&#39;s done in Locale&#39;s constructors.)</b>
<b class="nc"><i>1570</i>&nbsp;     *</b>
<b class="nc"><i>1571</i>&nbsp;     * &lt;li&gt;The portion of a private use subtag prefixed by &quot;lvariant&quot;,</b>
<b class="nc"><i>1572</i>&nbsp;     * if any, is removed and appended to the variant field in the</b>
<b class="nc"><i>1573</i>&nbsp;     * result locale (without case normalization).  If it is then</b>
<b class="nc"><i>1574</i>&nbsp;     * empty, the private use subtag is discarded:</b>
<b class="nc"><i>1575</i>&nbsp;     *</b>
<i>1576</i>&nbsp;     * &lt;pre&gt;
<b class="nc"><i>1577</i>&nbsp;     *     Locale loc;</b>
<i>1578</i>&nbsp;     *     loc = Locale.forLanguageTag(&quot;en-US-x-lvariant-POSIX&quot;);
<i>1579</i>&nbsp;     *     loc.getVariant(); // returns &quot;POSIX&quot;
<i>1580</i>&nbsp;     *     loc.getExtension(&#39;x&#39;); // returns null
<i>1581</i>&nbsp;     *
<i>1582</i>&nbsp;     *     loc = Locale.forLanguageTag(&quot;de-POSIX-x-URP-lvariant-Abc-Def&quot;);
<i>1583</i>&nbsp;     *     loc.getVariant(); // returns &quot;POSIX_Abc_Def&quot;
<i>1584</i>&nbsp;     *     loc.getExtension(&#39;x&#39;); // returns &quot;urp&quot;
<i>1585</i>&nbsp;     * &lt;/pre&gt;
<i>1586</i>&nbsp;     *
<i>1587</i>&nbsp;     * &lt;li&gt;When the languageTag argument contains an extlang subtag,
<i>1588</i>&nbsp;     * the first such subtag is used as the language, and the primary
<i>1589</i>&nbsp;     * language subtag and other extlang subtags are ignored:
<i>1590</i>&nbsp;     *
<i>1591</i>&nbsp;     * &lt;pre&gt;
<i>1592</i>&nbsp;     *     Locale.forLanguageTag(&quot;ar-aao&quot;).getLanguage(); // returns &quot;aao&quot;
<i>1593</i>&nbsp;     *     Locale.forLanguageTag(&quot;en-abc-def-us&quot;).toString(); // returns &quot;abc_US&quot;
<i>1594</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1595</i>&nbsp;     *</b>
<b class="nc"><i>1596</i>&nbsp;     * &lt;li&gt;Case is normalized except for variant tags, which are left</b>
<b class="nc"><i>1597</i>&nbsp;     * unchanged.  Language is normalized to lower case, script to</b>
<i>1598</i>&nbsp;     * title case, country to upper case, and extensions to lower
<i>1599</i>&nbsp;     * case.
<b class="nc"><i>1600</i>&nbsp;     *</b>
<b class="nc"><i>1601</i>&nbsp;     * &lt;li&gt;If, after processing, the locale would exactly match either</b>
<b class="nc"><i>1602</i>&nbsp;     * ja_JP_JP or th_TH_TH with no extensions, the appropriate</b>
<b class="nc"><i>1603</i>&nbsp;     * extensions are added as though the constructor had been called:</b>
<i>1604</i>&nbsp;     *
<b class="nc"><i>1605</i>&nbsp;     * &lt;pre&gt;</b>
<i>1606</i>&nbsp;     *    Locale.forLanguageTag(&quot;ja-JP-x-lvariant-JP&quot;).toLanguageTag();
<i>1607</i>&nbsp;     *    // returns &quot;ja-JP-u-ca-japanese-x-lvariant-JP&quot;
<i>1608</i>&nbsp;     *    Locale.forLanguageTag(&quot;th-TH-x-lvariant-TH&quot;).toLanguageTag();
<i>1609</i>&nbsp;     *    // returns &quot;th-TH-u-nu-thai-x-lvariant-TH&quot;
<i>1610</i>&nbsp;     * &lt;/pre&gt;&lt;/ul&gt;
<i>1611</i>&nbsp;     *
<i>1612</i>&nbsp;     * &lt;p&gt;This implements the &#39;Language-Tag&#39; production of BCP47, and
<i>1613</i>&nbsp;     * so supports grandfathered (regular and irregular) as well as
<i>1614</i>&nbsp;     * private use language tags.  Stand alone private use tags are
<i>1615</i>&nbsp;     * represented as empty language and extension &#39;x-whatever&#39;,
<i>1616</i>&nbsp;     * and grandfathered tags are converted to their canonical replacements
<i>1617</i>&nbsp;     * where they exist.
<i>1618</i>&nbsp;     *
<i>1619</i>&nbsp;     * &lt;p&gt;Grandfathered tags with canonical replacements are as follows:
<i>1620</i>&nbsp;     *
<i>1621</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<b class="nc"><i>1622</i>&nbsp;     * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with canonical replacements&lt;/caption&gt;</b>
<b class="nc"><i>1623</i>&nbsp;     * &lt;thead style=&quot;text-align:center&quot;&gt;</b>
<b class="nc"><i>1624</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;modern replacement&lt;/th&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1625</i>&nbsp;     * &lt;/thead&gt;</b>
<i>1626</i>&nbsp;     * &lt;tbody style=&quot;text-align:center&quot;&gt;
<b class="nc"><i>1627</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;art-lojban&lt;/th&gt;&lt;td&gt;jbo&lt;/td&gt;&lt;/tr&gt;</b>
<i>1628</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-ami&lt;/th&gt;&lt;td&gt;ami&lt;/td&gt;&lt;/tr&gt;
<i>1629</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-bnn&lt;/th&gt;&lt;td&gt;bnn&lt;/td&gt;&lt;/tr&gt;
<i>1630</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-hak&lt;/th&gt;&lt;td&gt;hak&lt;/td&gt;&lt;/tr&gt;
<b class="nc"><i>1631</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-klingon&lt;/th&gt;&lt;td&gt;tlh&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1632</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-lux&lt;/th&gt;&lt;td&gt;lb&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1633</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-navajo&lt;/th&gt;&lt;td&gt;nv&lt;/td&gt;&lt;/tr&gt;</b>
<i>1634</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-pwn&lt;/th&gt;&lt;td&gt;pwn&lt;/td&gt;&lt;/tr&gt;
<i>1635</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tao&lt;/th&gt;&lt;td&gt;tao&lt;/td&gt;&lt;/tr&gt;
<b class="nc"><i>1636</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tay&lt;/th&gt;&lt;td&gt;tay&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1637</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-tsu&lt;/th&gt;&lt;td&gt;tsu&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1638</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;no-bok&lt;/th&gt;&lt;td&gt;nb&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1639</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;no-nyn&lt;/th&gt;&lt;td&gt;nn&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1640</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-BE-FR&lt;/th&gt;&lt;td&gt;sfb&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1641</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-BE-NL&lt;/th&gt;&lt;td&gt;vgt&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1642</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;sgn-CH-DE&lt;/th&gt;&lt;td&gt;sgg&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1643</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-guoyu&lt;/th&gt;&lt;td&gt;cmn&lt;/td&gt;&lt;/tr&gt;</b>
<b class="nc"><i>1644</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-hakka&lt;/th&gt;&lt;td&gt;hak&lt;/td&gt;&lt;/tr&gt;</b>
<i>1645</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min-nan&lt;/th&gt;&lt;td&gt;nan&lt;/td&gt;&lt;/tr&gt;
<i>1646</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-xiang&lt;/th&gt;&lt;td&gt;hsn&lt;/td&gt;&lt;/tr&gt;
<i>1647</i>&nbsp;     * &lt;/tbody&gt;
<b class="nc"><i>1648</i>&nbsp;     * &lt;/table&gt;</b>
<i>1649</i>&nbsp;     *
<i>1650</i>&nbsp;     * &lt;p&gt;Grandfathered tags with no modern replacement will be
<i>1651</i>&nbsp;     * converted as follows:
<i>1652</i>&nbsp;     *
<i>1653</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<i>1654</i>&nbsp;     * &lt;caption style=&quot;display:none&quot;&gt;Grandfathered tags with no modern replacement&lt;/caption&gt;
<i>1655</i>&nbsp;     * &lt;thead style=&quot;text-align:center&quot;&gt;
<i>1656</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;grandfathered tag&lt;/th&gt;&lt;th scope=&quot;col&quot; style=&quot;padding: 0 2px&quot;&gt;converts to&lt;/th&gt;&lt;/tr&gt;
<i>1657</i>&nbsp;     * &lt;/thead&gt;
<i>1658</i>&nbsp;     * &lt;tbody style=&quot;text-align:center&quot;&gt;
<i>1659</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;cel-gaulish&lt;/th&gt;&lt;td&gt;xtg-x-cel-gaulish&lt;/td&gt;&lt;/tr&gt;
<i>1660</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;en-GB-oed&lt;/th&gt;&lt;td&gt;en-GB-x-oed&lt;/td&gt;&lt;/tr&gt;
<i>1661</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-default&lt;/th&gt;&lt;td&gt;en-x-i-default&lt;/td&gt;&lt;/tr&gt;
<i>1662</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-enochian&lt;/th&gt;&lt;td&gt;und-x-i-enochian&lt;/td&gt;&lt;/tr&gt;
<i>1663</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;i-mingo&lt;/th&gt;&lt;td&gt;see-x-i-mingo&lt;/td&gt;&lt;/tr&gt;
<i>1664</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;zh-min&lt;/th&gt;&lt;td&gt;nan-x-zh-min&lt;/td&gt;&lt;/tr&gt;
<i>1665</i>&nbsp;     * &lt;/tbody&gt;
<i>1666</i>&nbsp;     * &lt;/table&gt;
<i>1667</i>&nbsp;     *
<i>1668</i>&nbsp;     * &lt;p&gt;For a list of all grandfathered tags, see the
<i>1669</i>&nbsp;     * IANA Language Subtag Registry (search for &quot;Type: grandfathered&quot;).
<b class="nc"><i>1670</i>&nbsp;     *</b>
<i>1671</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: there is no guarantee that &lt;code&gt;toLanguageTag&lt;/code&gt;
<i>1672</i>&nbsp;     * and &lt;code&gt;forLanguageTag&lt;/code&gt; will round-trip.
<i>1673</i>&nbsp;     *
<i>1674</i>&nbsp;     * @param languageTag the language tag
<i>1675</i>&nbsp;     * @return The locale that best represents the language tag.
<i>1676</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;languageTag&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1677</i>&nbsp;     * @see #toLanguageTag()
<i>1678</i>&nbsp;     * @see java.util.Locale.Builder#setLanguageTag(String)
<i>1679</i>&nbsp;     * @since 1.7
<i>1680</i>&nbsp;     */
<i>1681</i>&nbsp;    public static Locale forLanguageTag(String languageTag) {
<i>1682</i>&nbsp;        LanguageTag tag = LanguageTag.parse(languageTag, null);
<i>1683</i>&nbsp;        InternalLocaleBuilder bldr = new InternalLocaleBuilder();
<i>1684</i>&nbsp;        bldr.setLanguageTag(tag);
<i>1685</i>&nbsp;        BaseLocale base = bldr.getBaseLocale();
<i>1686</i>&nbsp;        LocaleExtensions exts = bldr.getLocaleExtensions();
<i>1687</i>&nbsp;        if (exts == null &amp;&amp; base.getVariant().length() &gt; 0) {
<i>1688</i>&nbsp;            exts = getCompatibilityExtensions(base.getLanguage(), base.getScript(),
<i>1689</i>&nbsp;                                              base.getRegion(), base.getVariant());
<i>1690</i>&nbsp;        }
<b class="nc"><i>1691</i>&nbsp;        return getInstance(base, exts);</b>
<i>1692</i>&nbsp;    }
<i>1693</i>&nbsp;
<i>1694</i>&nbsp;    /**
<i>1695</i>&nbsp;     * Returns a three-letter abbreviation of this locale&#39;s language.
<i>1696</i>&nbsp;     * If the language matches an ISO 639-1 two-letter code, the
<i>1697</i>&nbsp;     * corresponding ISO 639-2/T three-letter lowercase code is
<i>1698</i>&nbsp;     * returned.  The ISO 639-2 language codes can be found on-line,
<i>1699</i>&nbsp;     * see &quot;Codes for the Representation of Names of Languages Part 2:
<i>1700</i>&nbsp;     * Alpha-3 Code&quot;.  If the locale specifies a three-letter
<i>1701</i>&nbsp;     * language, the language is returned as is.  If the locale does
<i>1702</i>&nbsp;     * not specify a language the empty string is returned.
<i>1703</i>&nbsp;     *
<i>1704</i>&nbsp;     * @return A three-letter abbreviation of this locale&#39;s language.
<b class="nc"><i>1705</i>&nbsp;     * @exception MissingResourceException Throws MissingResourceException if</b>
<i>1706</i>&nbsp;     * three-letter language abbreviation is not available for this locale.
<i>1707</i>&nbsp;     */
<i>1708</i>&nbsp;    public String getISO3Language() throws MissingResourceException {
<i>1709</i>&nbsp;        String lang = baseLocale.getLanguage();
<i>1710</i>&nbsp;        if (lang.length() == 3) {
<i>1711</i>&nbsp;            return lang;
<i>1712</i>&nbsp;        }
<i>1713</i>&nbsp;
<i>1714</i>&nbsp;        String language3 = getISO3Code(lang, LocaleISOData.isoLanguageTable);
<i>1715</i>&nbsp;        if (language3 == null) {
<i>1716</i>&nbsp;            throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter language code for &quot;
<i>1717</i>&nbsp;                    + lang, &quot;FormatData_&quot; + toString(), &quot;ShortLanguage&quot;);
<i>1718</i>&nbsp;        }
<i>1719</i>&nbsp;        return language3;
<i>1720</i>&nbsp;    }
<b class="nc"><i>1721</i>&nbsp;</b>
<i>1722</i>&nbsp;    /**
<i>1723</i>&nbsp;     * Returns a three-letter abbreviation for this locale&#39;s country.
<i>1724</i>&nbsp;     * If the country matches an ISO 3166-1 alpha-2 code, the
<i>1725</i>&nbsp;     * corresponding ISO 3166-1 alpha-3 uppercase code is returned.
<i>1726</i>&nbsp;     * If the locale doesn&#39;t specify a country, this will be the empty
<i>1727</i>&nbsp;     * string.
<i>1728</i>&nbsp;     *
<i>1729</i>&nbsp;     * &lt;p&gt;The ISO 3166-1 codes can be found on-line.
<i>1730</i>&nbsp;     *
<i>1731</i>&nbsp;     * @return A three-letter abbreviation of this locale&#39;s country.
<i>1732</i>&nbsp;     * @exception MissingResourceException Throws MissingResourceException if the
<i>1733</i>&nbsp;     * three-letter country abbreviation is not available for this locale.
<i>1734</i>&nbsp;     */
<i>1735</i>&nbsp;    public String getISO3Country() throws MissingResourceException {
<i>1736</i>&nbsp;        String country3 = getISO3Code(baseLocale.getRegion(), LocaleISOData.isoCountryTable);
<i>1737</i>&nbsp;        if (country3 == null) {
<i>1738</i>&nbsp;            throw new MissingResourceException(&quot;Couldn&#39;t find 3-letter country code for &quot;
<i>1739</i>&nbsp;                    + baseLocale.getRegion(), &quot;FormatData_&quot; + toString(), &quot;ShortCountry&quot;);
<i>1740</i>&nbsp;        }
<i>1741</i>&nbsp;        return country3;
<i>1742</i>&nbsp;    }
<b class="nc"><i>1743</i>&nbsp;</b>
<i>1744</i>&nbsp;    private static String getISO3Code(String iso2Code, String table) {
<i>1745</i>&nbsp;        int codeLength = iso2Code.length();
<i>1746</i>&nbsp;        if (codeLength == 0) {
<i>1747</i>&nbsp;            return &quot;&quot;;
<i>1748</i>&nbsp;        }
<i>1749</i>&nbsp;
<i>1750</i>&nbsp;        int tableLength = table.length();
<i>1751</i>&nbsp;        int index = tableLength;
<i>1752</i>&nbsp;        if (codeLength == 2) {
<i>1753</i>&nbsp;            char c1 = iso2Code.charAt(0);
<i>1754</i>&nbsp;            char c2 = iso2Code.charAt(1);
<i>1755</i>&nbsp;            for (index = 0; index &lt; tableLength; index += 5) {
<i>1756</i>&nbsp;                if (table.charAt(index) == c1
<i>1757</i>&nbsp;                    &amp;&amp; table.charAt(index + 1) == c2) {
<i>1758</i>&nbsp;                    break;
<i>1759</i>&nbsp;                }
<i>1760</i>&nbsp;            }
<i>1761</i>&nbsp;        }
<i>1762</i>&nbsp;        return index &lt; tableLength ? table.substring(index + 2, index + 5) : null;
<i>1763</i>&nbsp;    }
<b class="nc"><i>1764</i>&nbsp;</b>
<i>1765</i>&nbsp;    /**
<i>1766</i>&nbsp;     * Returns a name for the locale&#39;s language that is appropriate for display to the
<i>1767</i>&nbsp;     * user.
<b class="nc"><i>1768</i>&nbsp;     * If possible, the name returned will be localized for the default</b>
<b class="nc"><i>1769</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale.</b>
<i>1770</i>&nbsp;     * For example, if the locale is fr_FR and the default
<i>1771</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale
<b class="nc"><i>1772</i>&nbsp;     * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and</b>
<b class="nc"><i>1773</i>&nbsp;     * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,</b>
<i>1774</i>&nbsp;     * getDisplayLanguage() will return &quot;anglais&quot;.
<i>1775</i>&nbsp;     * If the name returned cannot be localized for the default
<b class="nc"><i>1776</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale,</b>
<b class="nc"><i>1777</i>&nbsp;     * (say, we don&#39;t have a Japanese name for Croatian),</b>
<b class="nc"><i>1778</i>&nbsp;     * this function falls back on the English name, and uses the ISO code as a last-resort</b>
<b class="nc"><i>1779</i>&nbsp;     * value.  If the locale doesn&#39;t specify a language, this function returns the empty string.</b>
<b class="nc"><i>1780</i>&nbsp;     *</b>
<b class="nc"><i>1781</i>&nbsp;     * @return The name of the display language.</b>
<b class="nc"><i>1782</i>&nbsp;     */</b>
<b class="nc"><i>1783</i>&nbsp;    public final String getDisplayLanguage() {</b>
<i>1784</i>&nbsp;        return getDisplayLanguage(getDefault(Category.DISPLAY));
<i>1785</i>&nbsp;    }
<b class="nc"><i>1786</i>&nbsp;</b>
<i>1787</i>&nbsp;    /**
<i>1788</i>&nbsp;     * Returns a name for the locale&#39;s language that is appropriate for display to the
<i>1789</i>&nbsp;     * user.
<i>1790</i>&nbsp;     * If possible, the name returned will be localized according to inLocale.
<i>1791</i>&nbsp;     * For example, if the locale is fr_FR and inLocale
<i>1792</i>&nbsp;     * is en_US, getDisplayLanguage() will return &quot;French&quot;; if the locale is en_US and
<i>1793</i>&nbsp;     * inLocale is fr_FR, getDisplayLanguage() will return &quot;anglais&quot;.
<i>1794</i>&nbsp;     * If the name returned cannot be localized according to inLocale,
<i>1795</i>&nbsp;     * (say, we don&#39;t have a Japanese name for Croatian),
<i>1796</i>&nbsp;     * this function falls back on the English name, and finally
<i>1797</i>&nbsp;     * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a language,
<b class="nc"><i>1798</i>&nbsp;     * this function returns the empty string.</b>
<i>1799</i>&nbsp;     *
<i>1800</i>&nbsp;     * @param inLocale The locale for which to retrieve the display language.
<i>1801</i>&nbsp;     * @return The name of the display language appropriate to the given locale.
<i>1802</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1803</i>&nbsp;     */
<i>1804</i>&nbsp;    public String getDisplayLanguage(Locale inLocale) {
<i>1805</i>&nbsp;        return getDisplayString(baseLocale.getLanguage(), null, inLocale, DISPLAY_LANGUAGE);
<i>1806</i>&nbsp;    }
<i>1807</i>&nbsp;
<i>1808</i>&nbsp;    /**
<i>1809</i>&nbsp;     * Returns a name for the locale&#39;s script that is appropriate for display to
<i>1810</i>&nbsp;     * the user. If possible, the name will be localized for the default
<b class="nc"><i>1811</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale.  Returns</b>
<b class="nc"><i>1812</i>&nbsp;     * the empty string if this locale doesn&#39;t specify a script code.</b>
<i>1813</i>&nbsp;     *
<b class="nc"><i>1814</i>&nbsp;     * @return the display name of the script code for the current default</b>
<i>1815</i>&nbsp;     *     {@link Locale.Category#DISPLAY DISPLAY} locale
<b class="nc"><i>1816</i>&nbsp;     * @since 1.7</b>
<i>1817</i>&nbsp;     */
<i>1818</i>&nbsp;    public String getDisplayScript() {
<i>1819</i>&nbsp;        return getDisplayScript(getDefault(Category.DISPLAY));
<b class="nc"><i>1820</i>&nbsp;    }</b>
<b class="nc"><i>1821</i>&nbsp;</b>
<b class="nc"><i>1822</i>&nbsp;    /**</b>
<i>1823</i>&nbsp;     * Returns a name for the locale&#39;s script that is appropriate
<i>1824</i>&nbsp;     * for display to the user. If possible, the name will be
<i>1825</i>&nbsp;     * localized for the given locale. Returns the empty string if
<i>1826</i>&nbsp;     * this locale doesn&#39;t specify a script code.
<i>1827</i>&nbsp;     *
<i>1828</i>&nbsp;     * @param inLocale The locale for which to retrieve the display script.
<i>1829</i>&nbsp;     * @return the display name of the script code for the current default
<i>1830</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale
<i>1831</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1832</i>&nbsp;     * @since 1.7
<i>1833</i>&nbsp;     */
<i>1834</i>&nbsp;    public String getDisplayScript(Locale inLocale) {
<i>1835</i>&nbsp;        return getDisplayString(baseLocale.getScript(), null, inLocale, DISPLAY_SCRIPT);
<i>1836</i>&nbsp;    }
<i>1837</i>&nbsp;
<i>1838</i>&nbsp;    /**
<i>1839</i>&nbsp;     * Returns a name for the locale&#39;s country that is appropriate for display to the
<i>1840</i>&nbsp;     * user.
<i>1841</i>&nbsp;     * If possible, the name returned will be localized for the default
<i>1842</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale.
<i>1843</i>&nbsp;     * For example, if the locale is fr_FR and the default
<i>1844</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale
<b class="nc"><i>1845</i>&nbsp;     * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and</b>
<i>1846</i>&nbsp;     * the default {@link Locale.Category#DISPLAY DISPLAY} locale is fr_FR,
<i>1847</i>&nbsp;     * getDisplayCountry() will return &quot;Etats-Unis&quot;.
<i>1848</i>&nbsp;     * If the name returned cannot be localized for the default
<i>1849</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale,
<i>1850</i>&nbsp;     * (say, we don&#39;t have a Japanese name for Croatia),
<i>1851</i>&nbsp;     * this function falls back on the English name, and uses the ISO code as a last-resort
<i>1852</i>&nbsp;     * value.  If the locale doesn&#39;t specify a country, this function returns the empty string.
<i>1853</i>&nbsp;     *
<i>1854</i>&nbsp;     * @return The name of the country appropriate to the locale.
<i>1855</i>&nbsp;     */
<i>1856</i>&nbsp;    public final String getDisplayCountry() {
<i>1857</i>&nbsp;        return getDisplayCountry(getDefault(Category.DISPLAY));
<i>1858</i>&nbsp;    }
<i>1859</i>&nbsp;
<i>1860</i>&nbsp;    /**
<i>1861</i>&nbsp;     * Returns a name for the locale&#39;s country that is appropriate for display to the
<i>1862</i>&nbsp;     * user.
<i>1863</i>&nbsp;     * If possible, the name returned will be localized according to inLocale.
<i>1864</i>&nbsp;     * For example, if the locale is fr_FR and inLocale
<i>1865</i>&nbsp;     * is en_US, getDisplayCountry() will return &quot;France&quot;; if the locale is en_US and
<i>1866</i>&nbsp;     * inLocale is fr_FR, getDisplayCountry() will return &quot;Etats-Unis&quot;.
<i>1867</i>&nbsp;     * If the name returned cannot be localized according to inLocale.
<i>1868</i>&nbsp;     * (say, we don&#39;t have a Japanese name for Croatia),
<i>1869</i>&nbsp;     * this function falls back on the English name, and finally
<i>1870</i>&nbsp;     * on the ISO code as a last-resort value.  If the locale doesn&#39;t specify a country,
<b class="nc"><i>1871</i>&nbsp;     * this function returns the empty string.</b>
<i>1872</i>&nbsp;     *
<b class="nc"><i>1873</i>&nbsp;     * @param inLocale The locale for which to retrieve the display country.</b>
<b class="nc"><i>1874</i>&nbsp;     * @return The name of the country appropriate to the given locale.</b>
<b class="nc"><i>1875</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</b>
<b class="nc"><i>1876</i>&nbsp;     */</b>
<i>1877</i>&nbsp;    public String getDisplayCountry(Locale inLocale) {
<i>1878</i>&nbsp;        return getDisplayString(baseLocale.getRegion(), null, inLocale, DISPLAY_COUNTRY);
<b class="nc"><i>1879</i>&nbsp;    }</b>
<b class="nc"><i>1880</i>&nbsp;</b>
<b class="nc"><i>1881</i>&nbsp;    private String getDisplayString(String code, String cat, Locale inLocale, int type) {</b>
<i>1882</i>&nbsp;        Objects.requireNonNull(inLocale);
<i>1883</i>&nbsp;        Objects.requireNonNull(code);
<i>1884</i>&nbsp;
<i>1885</i>&nbsp;        if (code.isEmpty()) {
<b class="nc"><i>1886</i>&nbsp;            return &quot;&quot;;</b>
<b class="nc"><i>1887</i>&nbsp;        }</b>
<i>1888</i>&nbsp;
<i>1889</i>&nbsp;        LocaleServiceProviderPool pool =
<i>1890</i>&nbsp;            LocaleServiceProviderPool.getPool(LocaleNameProvider.class);
<i>1891</i>&nbsp;        String rbKey = (type == DISPLAY_VARIANT ? &quot;%%&quot;+code : code);
<i>1892</i>&nbsp;        String result = pool.getLocalizedObject(
<b class="nc"><i>1893</i>&nbsp;                                LocaleNameGetter.INSTANCE,</b>
<b class="nc"><i>1894</i>&nbsp;                                inLocale, rbKey, type, code, cat);</b>
<b class="nc"><i>1895</i>&nbsp;        return result != null ? result : code;</b>
<i>1896</i>&nbsp;    }
<b class="nc"><i>1897</i>&nbsp;</b>
<i>1898</i>&nbsp;    /**
<i>1899</i>&nbsp;     * Returns a name for the locale&#39;s variant code that is appropriate for display to the
<b class="nc"><i>1900</i>&nbsp;     * user.  If possible, the name will be localized for the default</b>
<b class="nc"><i>1901</i>&nbsp;     * {@link Locale.Category#DISPLAY DISPLAY} locale.  If the locale</b>
<b class="nc"><i>1902</i>&nbsp;     * doesn&#39;t specify a variant code, this function returns the empty string.</b>
<i>1903</i>&nbsp;     *
<b class="nc"><i>1904</i>&nbsp;     * @return The name of the display variant code appropriate to the locale.</b>
<b class="nc"><i>1905</i>&nbsp;     */</b>
<i>1906</i>&nbsp;    public final String getDisplayVariant() {
<b class="nc"><i>1907</i>&nbsp;        return getDisplayVariant(getDefault(Category.DISPLAY));</b>
<b class="nc"><i>1908</i>&nbsp;    }</b>
<i>1909</i>&nbsp;
<b class="nc"><i>1910</i>&nbsp;    /**</b>
<b class="nc"><i>1911</i>&nbsp;     * Returns a name for the locale&#39;s variant code that is appropriate for display to the</b>
<i>1912</i>&nbsp;     * user.  If possible, the name will be localized for inLocale.  If the locale
<i>1913</i>&nbsp;     * doesn&#39;t specify a variant code, this function returns the empty string.
<i>1914</i>&nbsp;     *
<b class="nc"><i>1915</i>&nbsp;     * @param inLocale The locale for which to retrieve the display variant code.</b>
<i>1916</i>&nbsp;     * @return The name of the display variant code appropriate to the given locale.
<i>1917</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>1918</i>&nbsp;     */</b>
<b class="nc"><i>1919</i>&nbsp;    public String getDisplayVariant(Locale inLocale) {</b>
<b class="nc"><i>1920</i>&nbsp;        if (baseLocale.getVariant().length() == 0)</b>
<i>1921</i>&nbsp;            return &quot;&quot;;
<i>1922</i>&nbsp;
<i>1923</i>&nbsp;        LocaleResources lr = LocaleProviderAdapter
<i>1924</i>&nbsp;            .getResourceBundleBased()
<i>1925</i>&nbsp;            .getLocaleResources(inLocale);
<i>1926</i>&nbsp;
<b class="nc"><i>1927</i>&nbsp;        String names[] = getDisplayVariantArray(inLocale);</b>
<i>1928</i>&nbsp;
<i>1929</i>&nbsp;        // Get the localized patterns for formatting a list, and use
<i>1930</i>&nbsp;        // them to format the list.
<i>1931</i>&nbsp;        return formatList(names,
<i>1932</i>&nbsp;                          lr.getLocaleName(&quot;ListCompositionPattern&quot;));
<i>1933</i>&nbsp;    }
<b class="nc"><i>1934</i>&nbsp;</b>
<i>1935</i>&nbsp;    /**
<i>1936</i>&nbsp;     * Returns a name for the locale that is appropriate for display to the
<b class="nc"><i>1937</i>&nbsp;     * user. This will be the values returned by getDisplayLanguage(),</b>
<b class="nc"><i>1938</i>&nbsp;     * getDisplayScript(), getDisplayCountry(), getDisplayVariant() and</b>
<i>1939</i>&nbsp;     * optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;
<i>1940</i>&nbsp;     * assembled into a single string. The non-empty values are used in order, with
<i>1941</i>&nbsp;     * the second and subsequent names in parentheses.  For example:
<i>1942</i>&nbsp;     * &lt;blockquote&gt;
<i>1943</i>&nbsp;     * language (script, country, variant(, extension)*)&lt;br&gt;
<b class="nc"><i>1944</i>&nbsp;     * language (country(, extension)*)&lt;br&gt;</b>
<b class="nc"><i>1945</i>&nbsp;     * language (variant(, extension)*)&lt;br&gt;</b>
<b class="nc"><i>1946</i>&nbsp;     * script (country(, extension)*)&lt;br&gt;</b>
<b class="nc"><i>1947</i>&nbsp;     * country (extension)*&lt;br&gt;</b>
<b class="nc"><i>1948</i>&nbsp;     * &lt;/blockquote&gt;</b>
<b class="nc"><i>1949</i>&nbsp;     * depending on which fields are specified in the locale. The field</b>
<i>1950</i>&nbsp;     * separator in the above parentheses, denoted as a comma character, may
<b class="nc"><i>1951</i>&nbsp;     * be localized depending on the locale. If the language, script, country,</b>
<i>1952</i>&nbsp;     * and variant fields are all empty, this function returns the empty string.
<i>1953</i>&nbsp;     *
<i>1954</i>&nbsp;     * @return The name of the locale appropriate to display.
<i>1955</i>&nbsp;     */
<i>1956</i>&nbsp;    public final String getDisplayName() {
<i>1957</i>&nbsp;        return getDisplayName(getDefault(Category.DISPLAY));
<i>1958</i>&nbsp;    }
<i>1959</i>&nbsp;
<i>1960</i>&nbsp;    /**
<i>1961</i>&nbsp;     * Returns a name for the locale that is appropriate for display
<b class="nc"><i>1962</i>&nbsp;     * to the user.  This will be the values returned by</b>
<b class="nc"><i>1963</i>&nbsp;     * getDisplayLanguage(), getDisplayScript(),getDisplayCountry()</b>
<b class="nc"><i>1964</i>&nbsp;     * getDisplayVariant(), and optional &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;</b>
<b class="nc"><i>1965</i>&nbsp;     * Unicode extensions&lt;/a&gt; assembled into a single string. The non-empty</b>
<i>1966</i>&nbsp;     * values are used in order, with the second and subsequent names in
<i>1967</i>&nbsp;     * parentheses.  For example:
<i>1968</i>&nbsp;     * &lt;blockquote&gt;
<i>1969</i>&nbsp;     * language (script, country, variant(, extension)*)&lt;br&gt;
<i>1970</i>&nbsp;     * language (country(, extension)*)&lt;br&gt;
<i>1971</i>&nbsp;     * language (variant(, extension)*)&lt;br&gt;
<i>1972</i>&nbsp;     * script (country(, extension)*)&lt;br&gt;
<i>1973</i>&nbsp;     * country (extension)*&lt;br&gt;
<i>1974</i>&nbsp;     * &lt;/blockquote&gt;
<i>1975</i>&nbsp;     * depending on which fields are specified in the locale. The field
<b class="nc"><i>1976</i>&nbsp;     * separator in the above parentheses, denoted as a comma character, may</b>
<b class="nc"><i>1977</i>&nbsp;     * be localized depending on the locale. If the language, script, country,</b>
<b class="nc"><i>1978</i>&nbsp;     * and variant fields are all empty, this function returns the empty string.</b>
<b class="nc"><i>1979</i>&nbsp;     *</b>
<b class="nc"><i>1980</i>&nbsp;     * @param inLocale The locale for which to retrieve the display name.</b>
<i>1981</i>&nbsp;     * @return The name of the locale appropriate to display.
<b class="nc"><i>1982</i>&nbsp;     * @throws NullPointerException if &lt;code&gt;inLocale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</b>
<i>1983</i>&nbsp;     */
<b class="nc"><i>1984</i>&nbsp;    public String getDisplayName(Locale inLocale) {</b>
<i>1985</i>&nbsp;        LocaleResources lr =  LocaleProviderAdapter
<i>1986</i>&nbsp;            .getResourceBundleBased()
<i>1987</i>&nbsp;            .getLocaleResources(inLocale);
<i>1988</i>&nbsp;
<i>1989</i>&nbsp;        String languageName = getDisplayLanguage(inLocale);
<i>1990</i>&nbsp;        String scriptName = getDisplayScript(inLocale);
<i>1991</i>&nbsp;        String countryName = getDisplayCountry(inLocale);
<i>1992</i>&nbsp;        String[] variantNames = getDisplayVariantArray(inLocale);
<i>1993</i>&nbsp;
<i>1994</i>&nbsp;        // Get the localized patterns for formatting a display name.
<i>1995</i>&nbsp;        String displayNamePattern = lr.getLocaleName(&quot;DisplayNamePattern&quot;);
<i>1996</i>&nbsp;        String listCompositionPattern = lr.getLocaleName(&quot;ListCompositionPattern&quot;);
<i>1997</i>&nbsp;
<b class="nc"><i>1998</i>&nbsp;        // The display name consists of a main name, followed by qualifiers.</b>
<b class="nc"><i>1999</i>&nbsp;        // Typically, the format is &quot;MainName (Qualifier, Qualifier)&quot; but this</b>
<b class="nc"><i>2000</i>&nbsp;        // depends on what pattern is stored in the display locale.</b>
<b class="nc"><i>2001</i>&nbsp;        String   mainName       = null;</b>
<b class="nc"><i>2002</i>&nbsp;        String[] qualifierNames = null;</b>
<b class="nc"><i>2003</i>&nbsp;</b>
<b class="nc"><i>2004</i>&nbsp;        // The main name is the language, or if there is no language, the script,</b>
<i>2005</i>&nbsp;        // then if no script, the country. If there is no language/script/country
<b class="nc"><i>2006</i>&nbsp;        // (an anomalous situation) then the display name is simply the variant&#39;s</b>
<b class="nc"><i>2007</i>&nbsp;        // display name.</b>
<i>2008</i>&nbsp;        if (languageName.length() == 0 &amp;&amp; scriptName.length() == 0 &amp;&amp; countryName.length() == 0) {
<b class="nc"><i>2009</i>&nbsp;            if (variantNames.length == 0) {</b>
<i>2010</i>&nbsp;                return &quot;&quot;;
<i>2011</i>&nbsp;            } else {
<i>2012</i>&nbsp;                return formatList(variantNames, listCompositionPattern);
<i>2013</i>&nbsp;            }
<i>2014</i>&nbsp;        }
<i>2015</i>&nbsp;        ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(4);
<i>2016</i>&nbsp;        if (languageName.length() != 0) {
<i>2017</i>&nbsp;            names.add(languageName);
<i>2018</i>&nbsp;        }
<i>2019</i>&nbsp;        if (scriptName.length() != 0) {
<b class="nc"><i>2020</i>&nbsp;            names.add(scriptName);</b>
<i>2021</i>&nbsp;        }
<b class="nc"><i>2022</i>&nbsp;        if (countryName.length() != 0) {</b>
<b class="nc"><i>2023</i>&nbsp;            names.add(countryName);</b>
<b class="nc"><i>2024</i>&nbsp;        }</b>
<i>2025</i>&nbsp;        if (variantNames.length != 0) {
<i>2026</i>&nbsp;            names.addAll(Arrays.asList(variantNames));
<i>2027</i>&nbsp;        }
<i>2028</i>&nbsp;
<i>2029</i>&nbsp;        // add Unicode extensions
<i>2030</i>&nbsp;        if (localeExtensions != null) {
<i>2031</i>&nbsp;            localeExtensions.getUnicodeLocaleAttributes().stream()
<i>2032</i>&nbsp;                .map(key -&gt; getDisplayString(key, null, inLocale, DISPLAY_UEXT_KEY))
<i>2033</i>&nbsp;                .forEach(names::add);
<i>2034</i>&nbsp;            localeExtensions.getUnicodeLocaleKeys().stream()
<b class="nc"><i>2035</i>&nbsp;                .map(key -&gt; getDisplayKeyTypeExtensionString(key, lr, inLocale))</b>
<b class="nc"><i>2036</i>&nbsp;                .forEach(names::add);</b>
<i>2037</i>&nbsp;        }
<i>2038</i>&nbsp;
<i>2039</i>&nbsp;        // The first one in the main name
<b class="nc"><i>2040</i>&nbsp;        mainName = names.get(0);</b>
<b class="nc"><i>2041</i>&nbsp;</b>
<i>2042</i>&nbsp;        // Others are qualifiers
<i>2043</i>&nbsp;        int numNames = names.size();
<i>2044</i>&nbsp;        qualifierNames = (numNames &gt; 1) ?
<b class="nc"><i>2045</i>&nbsp;                names.subList(1, numNames).toArray(new String[numNames - 1]) : new String[0];</b>
<i>2046</i>&nbsp;
<i>2047</i>&nbsp;        // Create an array whose first element is the number of remaining
<i>2048</i>&nbsp;        // elements.  This serves as a selector into a ChoiceFormat pattern from
<i>2049</i>&nbsp;        // the resource.  The second and third elements are the main name and
<i>2050</i>&nbsp;        // the qualifier; if there are no qualifiers, the third element is
<i>2051</i>&nbsp;        // unused by the format pattern.
<i>2052</i>&nbsp;        Object[] displayNames = {
<i>2053</i>&nbsp;            qualifierNames.length != 0 ? 2 : 1,
<i>2054</i>&nbsp;            mainName,
<i>2055</i>&nbsp;            // We could also just call formatList() and have it handle the empty
<i>2056</i>&nbsp;            // list case, but this is more efficient, and we want it to be
<i>2057</i>&nbsp;            // efficient since all the language-only locales will not have any
<i>2058</i>&nbsp;            // qualifiers.
<i>2059</i>&nbsp;            qualifierNames.length != 0 ? formatList(qualifierNames, listCompositionPattern) : null
<i>2060</i>&nbsp;        };
<i>2061</i>&nbsp;
<b class="nc"><i>2062</i>&nbsp;        if (displayNamePattern != null) {</b>
<b class="nc"><i>2063</i>&nbsp;            return new MessageFormat(displayNamePattern).format(displayNames);</b>
<b class="nc"><i>2064</i>&nbsp;        }</b>
<b class="nc"><i>2065</i>&nbsp;        else {</b>
<b class="nc"><i>2066</i>&nbsp;            // If we cannot get the message format pattern, then we use a simple</b>
<i>2067</i>&nbsp;            // hard-coded pattern.  This should not occur in practice unless the
<b class="nc"><i>2068</i>&nbsp;            // installation is missing some core files (FormatData etc.).</b>
<i>2069</i>&nbsp;            StringBuilder result = new StringBuilder();
<b class="nc"><i>2070</i>&nbsp;            result.append((String)displayNames[1]);</b>
<i>2071</i>&nbsp;            if (displayNames.length &gt; 2) {
<i>2072</i>&nbsp;                result.append(&quot; (&quot;);
<i>2073</i>&nbsp;                result.append((String)displayNames[2]);
<b class="nc"><i>2074</i>&nbsp;                result.append(&#39;)&#39;);</b>
<b class="nc"><i>2075</i>&nbsp;            }</b>
<b class="nc"><i>2076</i>&nbsp;            return result.toString();</b>
<i>2077</i>&nbsp;        }
<i>2078</i>&nbsp;    }
<i>2079</i>&nbsp;
<b class="nc"><i>2080</i>&nbsp;    /**</b>
<b class="nc"><i>2081</i>&nbsp;     * Overrides Cloneable.</b>
<b class="nc"><i>2082</i>&nbsp;     */</b>
<i>2083</i>&nbsp;    @Override
<i>2084</i>&nbsp;    public Object clone()
<b class="nc"><i>2085</i>&nbsp;    {</b>
<b class="nc"><i>2086</i>&nbsp;        try {</b>
<i>2087</i>&nbsp;            Locale that = (Locale)super.clone();
<i>2088</i>&nbsp;            return that;
<i>2089</i>&nbsp;        } catch (CloneNotSupportedException e) {
<i>2090</i>&nbsp;            throw new InternalError(e);
<i>2091</i>&nbsp;        }
<i>2092</i>&nbsp;    }
<i>2093</i>&nbsp;
<i>2094</i>&nbsp;    /**
<i>2095</i>&nbsp;     * Override hashCode.
<i>2096</i>&nbsp;     * Since Locales are often used in hashtables, caches the value
<i>2097</i>&nbsp;     * for speed.
<i>2098</i>&nbsp;     */
<b class="nc"><i>2099</i>&nbsp;    @Override</b>
<i>2100</i>&nbsp;    public int hashCode() {
<i>2101</i>&nbsp;        int hc = hashCodeValue;
<b class="nc"><i>2102</i>&nbsp;        if (hc == 0) {</b>
<b class="nc"><i>2103</i>&nbsp;            hc = baseLocale.hashCode();</b>
<i>2104</i>&nbsp;            if (localeExtensions != null) {
<i>2105</i>&nbsp;                hc ^= localeExtensions.hashCode();
<b class="nc"><i>2106</i>&nbsp;            }</b>
<b class="nc"><i>2107</i>&nbsp;            hashCodeValue = hc;</b>
<b class="nc"><i>2108</i>&nbsp;        }</b>
<i>2109</i>&nbsp;        return hc;
<i>2110</i>&nbsp;    }
<b class="nc"><i>2111</i>&nbsp;</b>
<i>2112</i>&nbsp;    // Overrides
<i>2113</i>&nbsp;
<i>2114</i>&nbsp;    /**
<i>2115</i>&nbsp;     * Returns true if this Locale is equal to another object.  A Locale is
<i>2116</i>&nbsp;     * deemed equal to another Locale with identical language, script, country,
<i>2117</i>&nbsp;     * variant and extensions, and unequal to all other objects.
<b class="nc"><i>2118</i>&nbsp;     *</b>
<i>2119</i>&nbsp;     * @return true if this Locale is equal to the specified object.
<i>2120</i>&nbsp;     */
<i>2121</i>&nbsp;    @Override
<i>2122</i>&nbsp;    public boolean equals(Object obj) {
<i>2123</i>&nbsp;        if (this == obj)                      // quick check
<i>2124</i>&nbsp;            return true;
<i>2125</i>&nbsp;        if (!(obj instanceof Locale))
<i>2126</i>&nbsp;            return false;
<i>2127</i>&nbsp;        BaseLocale otherBase = ((Locale)obj).baseLocale;
<i>2128</i>&nbsp;        if (!baseLocale.equals(otherBase)) {
<i>2129</i>&nbsp;            return false;
<i>2130</i>&nbsp;        }
<i>2131</i>&nbsp;        if (localeExtensions == null) {
<i>2132</i>&nbsp;            return ((Locale)obj).localeExtensions == null;
<i>2133</i>&nbsp;        }
<i>2134</i>&nbsp;        return localeExtensions.equals(((Locale)obj).localeExtensions);
<i>2135</i>&nbsp;    }
<i>2136</i>&nbsp;
<i>2137</i>&nbsp;    // ================= privates =====================================
<i>2138</i>&nbsp;
<i>2139</i>&nbsp;    private transient BaseLocale baseLocale;
<b class="nc"><i>2140</i>&nbsp;    private transient LocaleExtensions localeExtensions;</b>
<i>2141</i>&nbsp;
<i>2142</i>&nbsp;    /**
<i>2143</i>&nbsp;     * Calculated hashcode
<i>2144</i>&nbsp;     */
<i>2145</i>&nbsp;    private transient volatile int hashCodeValue;
<i>2146</i>&nbsp;
<i>2147</i>&nbsp;    private static volatile Locale defaultLocale = initDefault();
<i>2148</i>&nbsp;    private static volatile Locale defaultDisplayLocale;
<i>2149</i>&nbsp;    private static volatile Locale defaultFormatLocale;
<i>2150</i>&nbsp;
<i>2151</i>&nbsp;    private transient volatile String languageTag;
<i>2152</i>&nbsp;
<i>2153</i>&nbsp;    /**
<i>2154</i>&nbsp;     * Return an array of the display names of the variant.
<i>2155</i>&nbsp;     * @param bundle the ResourceBundle to use to get the display names
<b class="nc"><i>2156</i>&nbsp;     * @return an array of display names, possible of zero length.</b>
<b class="nc"><i>2157</i>&nbsp;     */</b>
<b class="nc"><i>2158</i>&nbsp;    private String[] getDisplayVariantArray(Locale inLocale) {</b>
<b class="nc"><i>2159</i>&nbsp;        // Split the variant name into tokens separated by &#39;_&#39;.</b>
<b class="nc"><i>2160</i>&nbsp;        StringTokenizer tokenizer = new StringTokenizer(baseLocale.getVariant(), &quot;_&quot;);</b>
<b class="nc"><i>2161</i>&nbsp;        String[] names = new String[tokenizer.countTokens()];</b>
<b class="nc"><i>2162</i>&nbsp;</b>
<b class="nc"><i>2163</i>&nbsp;        // For each variant token, lookup the display name.  If</b>
<i>2164</i>&nbsp;        // not found, use the variant name itself.
<i>2165</i>&nbsp;        for (int i=0; i&lt;names.length; ++i) {
<i>2166</i>&nbsp;            names[i] = getDisplayString(tokenizer.nextToken(), null,
<i>2167</i>&nbsp;                                inLocale, DISPLAY_VARIANT);
<i>2168</i>&nbsp;        }
<i>2169</i>&nbsp;
<i>2170</i>&nbsp;        return names;
<i>2171</i>&nbsp;    }
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;    private String getDisplayKeyTypeExtensionString(String key, LocaleResources lr, Locale inLocale) {
<i>2174</i>&nbsp;        String type = localeExtensions.getUnicodeLocaleType(key);
<b class="nc"><i>2175</i>&nbsp;        String ret = getDisplayString(type, key, inLocale, DISPLAY_UEXT_TYPE);</b>
<b class="nc"><i>2176</i>&nbsp;</b>
<b class="nc"><i>2177</i>&nbsp;        if (ret == null || ret.equals(type)) {</b>
<b class="nc"><i>2178</i>&nbsp;            // no localization for this type. try combining key/type separately</b>
<b class="nc"><i>2179</i>&nbsp;            String displayType = type;</b>
<b class="nc"><i>2180</i>&nbsp;            switch (key) {</b>
<b class="nc"><i>2181</i>&nbsp;            case &quot;cu&quot;:</b>
<b class="nc"><i>2182</i>&nbsp;                displayType = lr.getCurrencyName(type.toLowerCase(Locale.ROOT));</b>
<i>2183</i>&nbsp;                break;
<b class="nc"><i>2184</i>&nbsp;            case &quot;rg&quot;:</b>
<b class="nc"><i>2185</i>&nbsp;                if (type != null &amp;&amp;</b>
<b class="nc"><i>2186</i>&nbsp;                    // UN M.49 code should not be allowed here</b>
<b class="nc"><i>2187</i>&nbsp;                    type.matches(&quot;^[a-zA-Z]{2}[zZ]{4}$&quot;)) {</b>
<b class="nc"><i>2188</i>&nbsp;                        displayType = lr.getLocaleName(type.substring(0, 2).toUpperCase(Locale.ROOT));</b>
<b class="nc"><i>2189</i>&nbsp;                }</b>
<i>2190</i>&nbsp;                break;
<b class="nc"><i>2191</i>&nbsp;            case &quot;tz&quot;:</b>
<i>2192</i>&nbsp;                displayType = TimeZoneNameUtility.convertLDMLShortID(type)
<i>2193</i>&nbsp;                    .map(id -&gt; TimeZoneNameUtility.retrieveGenericDisplayName(id, TimeZone.LONG, inLocale))
<i>2194</i>&nbsp;                    .orElse(type);
<i>2195</i>&nbsp;                break;
<i>2196</i>&nbsp;            }
<i>2197</i>&nbsp;            ret = MessageFormat.format(lr.getLocaleName(&quot;ListKeyTypePattern&quot;),
<i>2198</i>&nbsp;                getDisplayString(key, null, inLocale, DISPLAY_UEXT_KEY),
<i>2199</i>&nbsp;                Optional.ofNullable(displayType).orElse(type));
<i>2200</i>&nbsp;        }
<i>2201</i>&nbsp;
<i>2202</i>&nbsp;        return ret;
<i>2203</i>&nbsp;    }
<i>2204</i>&nbsp;
<i>2205</i>&nbsp;    /**
<i>2206</i>&nbsp;     * Format a list using given pattern strings.
<i>2207</i>&nbsp;     * If either of the patterns is null, then a the list is
<i>2208</i>&nbsp;     * formatted by concatenation with the delimiter &#39;,&#39;.
<i>2209</i>&nbsp;     * @param stringList the list of strings to be formatted.
<b class="nc"><i>2210</i>&nbsp;     * and formatting them into a list.</b>
<b class="nc"><i>2211</i>&nbsp;     * @param pattern should take 2 arguments for reduction</b>
<i>2212</i>&nbsp;     * @return a string representing the list.
<i>2213</i>&nbsp;     */
<b class="nc"><i>2214</i>&nbsp;    private static String formatList(String[] stringList, String pattern) {</b>
<i>2215</i>&nbsp;        // If we have no list patterns, compose the list in a simple,
<b class="nc"><i>2216</i>&nbsp;        // non-localized way.</b>
<i>2217</i>&nbsp;        if (pattern == null) {
<i>2218</i>&nbsp;            return Arrays.stream(stringList).collect(Collectors.joining(&quot;,&quot;));
<i>2219</i>&nbsp;        }
<i>2220</i>&nbsp;
<b class="nc"><i>2221</i>&nbsp;        switch (stringList.length) {</b>
<b class="nc"><i>2222</i>&nbsp;            case 0:</b>
<b class="nc"><i>2223</i>&nbsp;                return &quot;&quot;;</b>
<b class="nc"><i>2224</i>&nbsp;            case 1:</b>
<b class="nc"><i>2225</i>&nbsp;                return stringList[0];</b>
<b class="nc"><i>2226</i>&nbsp;            default:</b>
<b class="nc"><i>2227</i>&nbsp;                return Arrays.stream(stringList).reduce(&quot;&quot;,</b>
<i>2228</i>&nbsp;                    (s1, s2) -&gt; {
<b class="nc"><i>2229</i>&nbsp;                        if (s1.equals(&quot;&quot;)) {</b>
<i>2230</i>&nbsp;                            return s2;
<i>2231</i>&nbsp;                        }
<i>2232</i>&nbsp;                        if (s2.equals(&quot;&quot;)) {
<i>2233</i>&nbsp;                            return s1;
<i>2234</i>&nbsp;                        }
<i>2235</i>&nbsp;                        return MessageFormat.format(pattern, s1, s2);
<i>2236</i>&nbsp;                    });
<b class="nc"><i>2237</i>&nbsp;        }</b>
<i>2238</i>&nbsp;    }
<b class="nc"><i>2239</i>&nbsp;</b>
<b class="nc"><i>2240</i>&nbsp;    // Duplicate of sun.util.locale.UnicodeLocaleExtension.isKey in order to</b>
<b class="nc"><i>2241</i>&nbsp;    // avoid its class loading.</b>
<b class="nc"><i>2242</i>&nbsp;    private static boolean isUnicodeExtensionKey(String s) {</b>
<i>2243</i>&nbsp;        // 2alphanum
<b class="nc"><i>2244</i>&nbsp;        return (s.length() == 2) &amp;&amp; LocaleUtils.isAlphaNumericString(s);</b>
<b class="nc"><i>2245</i>&nbsp;    }</b>
<b class="nc"><i>2246</i>&nbsp;</b>
<b class="nc"><i>2247</i>&nbsp;    /**</b>
<b class="nc"><i>2248</i>&nbsp;     * @serialField language    String</b>
<i>2249</i>&nbsp;     *      language subtag in lower case. (See &lt;a href=&quot;java/util/Locale.html#getLanguage()&quot;&gt;getLanguage()&lt;/a&gt;)
<b class="nc"><i>2250</i>&nbsp;     * @serialField country     String</b>
<i>2251</i>&nbsp;     *      country subtag in upper case. (See &lt;a href=&quot;java/util/Locale.html#getCountry()&quot;&gt;getCountry()&lt;/a&gt;)
<b class="nc"><i>2252</i>&nbsp;     * @serialField variant     String</b>
<i>2253</i>&nbsp;     *      variant subtags separated by LOWLINE characters. (See &lt;a href=&quot;java/util/Locale.html#getVariant()&quot;&gt;getVariant()&lt;/a&gt;)
<i>2254</i>&nbsp;     * @serialField hashcode    int
<i>2255</i>&nbsp;     *      deprecated, for forward compatibility only
<i>2256</i>&nbsp;     * @serialField script      String
<i>2257</i>&nbsp;     *      script subtag in title case (See &lt;a href=&quot;java/util/Locale.html#getScript()&quot;&gt;getScript()&lt;/a&gt;)
<i>2258</i>&nbsp;     * @serialField extensions  String
<b class="nc"><i>2259</i>&nbsp;     *      canonical representation of extensions, that is,</b>
<i>2260</i>&nbsp;     *      BCP47 extensions in alphabetical order followed by
<b class="nc"><i>2261</i>&nbsp;     *      BCP47 private use subtags, all in lower case letters</b>
<i>2262</i>&nbsp;     *      separated by HYPHEN-MINUS characters.
<i>2263</i>&nbsp;     *      (See &lt;a href=&quot;java/util/Locale.html#getExtensionKeys()&quot;&gt;getExtensionKeys()&lt;/a&gt;,
<i>2264</i>&nbsp;     *      &lt;a href=&quot;java/util/Locale.html#getExtension(char)&quot;&gt;getExtension(char)&lt;/a&gt;)
<i>2265</i>&nbsp;     */
<i>2266</i>&nbsp;    private static final ObjectStreamField[] serialPersistentFields = {
<i>2267</i>&nbsp;        new ObjectStreamField(&quot;language&quot;, String.class),
<b class="nc"><i>2268</i>&nbsp;        new ObjectStreamField(&quot;country&quot;, String.class),</b>
<b class="nc"><i>2269</i>&nbsp;        new ObjectStreamField(&quot;variant&quot;, String.class),</b>
<b class="nc"><i>2270</i>&nbsp;        new ObjectStreamField(&quot;hashcode&quot;, int.class),</b>
<i>2271</i>&nbsp;        new ObjectStreamField(&quot;script&quot;, String.class),
<b class="nc"><i>2272</i>&nbsp;        new ObjectStreamField(&quot;extensions&quot;, String.class),</b>
<i>2273</i>&nbsp;    };
<b class="nc"><i>2274</i>&nbsp;</b>
<i>2275</i>&nbsp;    /**
<b class="nc"><i>2276</i>&nbsp;     * Serializes this &lt;code&gt;Locale&lt;/code&gt; to the specified &lt;code&gt;ObjectOutputStream&lt;/code&gt;.</b>
<i>2277</i>&nbsp;     * @param out the &lt;code&gt;ObjectOutputStream&lt;/code&gt; to write
<b class="nc"><i>2278</i>&nbsp;     * @throws IOException</b>
<i>2279</i>&nbsp;     * @since 1.7
<b class="nc"><i>2280</i>&nbsp;     */</b>
<i>2281</i>&nbsp;    private void writeObject(ObjectOutputStream out) throws IOException {
<b class="nc"><i>2282</i>&nbsp;        ObjectOutputStream.PutField fields = out.putFields();</b>
<i>2283</i>&nbsp;        fields.put(&quot;language&quot;, baseLocale.getLanguage());
<i>2284</i>&nbsp;        fields.put(&quot;script&quot;, baseLocale.getScript());
<b class="nc"><i>2285</i>&nbsp;        fields.put(&quot;country&quot;, baseLocale.getRegion());</b>
<i>2286</i>&nbsp;        fields.put(&quot;variant&quot;, baseLocale.getVariant());
<i>2287</i>&nbsp;        fields.put(&quot;extensions&quot;, localeExtensions == null ? &quot;&quot; : localeExtensions.getID());
<i>2288</i>&nbsp;        fields.put(&quot;hashcode&quot;, -1); // place holder just for backward support
<i>2289</i>&nbsp;        out.writeFields();
<i>2290</i>&nbsp;    }
<i>2291</i>&nbsp;
<i>2292</i>&nbsp;    /**
<i>2293</i>&nbsp;     * Deserializes this &lt;code&gt;Locale&lt;/code&gt;.
<i>2294</i>&nbsp;     * @param in the &lt;code&gt;ObjectInputStream&lt;/code&gt; to read
<i>2295</i>&nbsp;     * @throws IOException
<i>2296</i>&nbsp;     * @throws ClassNotFoundException
<i>2297</i>&nbsp;     * @throws IllformedLocaleException
<b class="nc"><i>2298</i>&nbsp;     * @since 1.7</b>
<i>2299</i>&nbsp;     */
<i>2300</i>&nbsp;    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<i>2301</i>&nbsp;        ObjectInputStream.GetField fields = in.readFields();
<i>2302</i>&nbsp;        String language = (String)fields.get(&quot;language&quot;, &quot;&quot;);
<i>2303</i>&nbsp;        String script = (String)fields.get(&quot;script&quot;, &quot;&quot;);
<b class="nc"><i>2304</i>&nbsp;        String country = (String)fields.get(&quot;country&quot;, &quot;&quot;);</b>
<i>2305</i>&nbsp;        String variant = (String)fields.get(&quot;variant&quot;, &quot;&quot;);
<i>2306</i>&nbsp;        String extStr = (String)fields.get(&quot;extensions&quot;, &quot;&quot;);
<i>2307</i>&nbsp;        baseLocale = BaseLocale.getInstance(convertOldISOCodes(language), script, country, variant);
<i>2308</i>&nbsp;        if (extStr.length() &gt; 0) {
<i>2309</i>&nbsp;            try {
<i>2310</i>&nbsp;                InternalLocaleBuilder bldr = new InternalLocaleBuilder();
<i>2311</i>&nbsp;                bldr.setExtensions(extStr);
<i>2312</i>&nbsp;                localeExtensions = bldr.getLocaleExtensions();
<b class="nc"><i>2313</i>&nbsp;            } catch (LocaleSyntaxException e) {</b>
<i>2314</i>&nbsp;                throw new IllformedLocaleException(e.getMessage());
<i>2315</i>&nbsp;            }
<i>2316</i>&nbsp;        } else {
<i>2317</i>&nbsp;            localeExtensions = null;
<b class="nc"><i>2318</i>&nbsp;        }</b>
<b class="nc"><i>2319</i>&nbsp;    }</b>
<b class="nc"><i>2320</i>&nbsp;</b>
<b class="nc"><i>2321</i>&nbsp;    /**</b>
<b class="nc"><i>2322</i>&nbsp;     * Returns a cached &lt;code&gt;Locale&lt;/code&gt; instance equivalent to</b>
<i>2323</i>&nbsp;     * the deserialized &lt;code&gt;Locale&lt;/code&gt;. When serialized
<i>2324</i>&nbsp;     * language, country and variant fields read from the object data stream
<i>2325</i>&nbsp;     * are exactly &quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot; or &quot;th&quot;, &quot;TH&quot;, &quot;TH&quot; and script/extensions
<i>2326</i>&nbsp;     * fields are empty, this method supplies &lt;code&gt;UNICODE_LOCALE_EXTENSION&lt;/code&gt;
<i>2327</i>&nbsp;     * &quot;ca&quot;/&quot;japanese&quot; (calendar type is &quot;japanese&quot;) or &quot;nu&quot;/&quot;thai&quot; (number script
<i>2328</i>&nbsp;     * type is &quot;thai&quot;). See &lt;a href=&quot;Locale.html#special_cases_constructor&quot;&gt;Special Cases&lt;/a&gt;
<i>2329</i>&nbsp;     * for more information.
<i>2330</i>&nbsp;     *
<i>2331</i>&nbsp;     * @return an instance of &lt;code&gt;Locale&lt;/code&gt; equivalent to
<i>2332</i>&nbsp;     * the deserialized &lt;code&gt;Locale&lt;/code&gt;.
<i>2333</i>&nbsp;     * @throws java.io.ObjectStreamException
<i>2334</i>&nbsp;     */
<i>2335</i>&nbsp;    private Object readResolve() throws java.io.ObjectStreamException {
<i>2336</i>&nbsp;        return getInstance(baseLocale.getLanguage(), baseLocale.getScript(),
<i>2337</i>&nbsp;                baseLocale.getRegion(), baseLocale.getVariant(), localeExtensions);
<i>2338</i>&nbsp;    }
<i>2339</i>&nbsp;
<i>2340</i>&nbsp;    private static volatile String[] isoLanguages;
<i>2341</i>&nbsp;
<i>2342</i>&nbsp;    private static volatile String[] isoCountries;
<i>2343</i>&nbsp;
<i>2344</i>&nbsp;    private static String convertOldISOCodes(String language) {
<i>2345</i>&nbsp;        // we accept both the old and the new ISO codes for the languages whose ISO
<i>2346</i>&nbsp;        // codes have changed, but we always store the OLD code, for backward compatibility
<i>2347</i>&nbsp;        language = LocaleUtils.toLowerString(language).intern();
<i>2348</i>&nbsp;        if (language == &quot;he&quot;) {
<i>2349</i>&nbsp;            return &quot;iw&quot;;
<i>2350</i>&nbsp;        } else if (language == &quot;yi&quot;) {
<i>2351</i>&nbsp;            return &quot;ji&quot;;
<i>2352</i>&nbsp;        } else if (language == &quot;id&quot;) {
<i>2353</i>&nbsp;            return &quot;in&quot;;
<i>2354</i>&nbsp;        } else {
<i>2355</i>&nbsp;            return language;
<i>2356</i>&nbsp;        }
<i>2357</i>&nbsp;    }
<i>2358</i>&nbsp;
<i>2359</i>&nbsp;    private static LocaleExtensions getCompatibilityExtensions(String language,
<i>2360</i>&nbsp;                                                               String script,
<i>2361</i>&nbsp;                                                               String country,
<i>2362</i>&nbsp;                                                               String variant) {
<i>2363</i>&nbsp;        LocaleExtensions extensions = null;
<i>2364</i>&nbsp;        // Special cases for backward compatibility support
<i>2365</i>&nbsp;        if (LocaleUtils.caseIgnoreMatch(language, &quot;ja&quot;)
<i>2366</i>&nbsp;                &amp;&amp; script.length() == 0
<i>2367</i>&nbsp;                &amp;&amp; LocaleUtils.caseIgnoreMatch(country, &quot;jp&quot;)
<i>2368</i>&nbsp;                &amp;&amp; &quot;JP&quot;.equals(variant)) {
<i>2369</i>&nbsp;            // ja_JP_JP -&gt; u-ca-japanese (calendar = japanese)
<i>2370</i>&nbsp;            extensions = LocaleExtensions.CALENDAR_JAPANESE;
<i>2371</i>&nbsp;        } else if (LocaleUtils.caseIgnoreMatch(language, &quot;th&quot;)
<b class="nc"><i>2372</i>&nbsp;                &amp;&amp; script.length() == 0</b>
<b class="nc"><i>2373</i>&nbsp;                &amp;&amp; LocaleUtils.caseIgnoreMatch(country, &quot;th&quot;)</b>
<i>2374</i>&nbsp;                &amp;&amp; &quot;TH&quot;.equals(variant)) {
<i>2375</i>&nbsp;            // th_TH_TH -&gt; u-nu-thai (numbersystem = thai)
<i>2376</i>&nbsp;            extensions = LocaleExtensions.NUMBER_THAI;
<i>2377</i>&nbsp;        }
<i>2378</i>&nbsp;        return extensions;
<i>2379</i>&nbsp;    }
<i>2380</i>&nbsp;
<i>2381</i>&nbsp;    /**
<i>2382</i>&nbsp;     * Obtains a localized locale names from a LocaleNameProvider
<i>2383</i>&nbsp;     * implementation.
<i>2384</i>&nbsp;     */
<i>2385</i>&nbsp;    private static class LocaleNameGetter
<i>2386</i>&nbsp;        implements LocaleServiceProviderPool.LocalizedObjectGetter&lt;LocaleNameProvider, String&gt; {
<i>2387</i>&nbsp;        private static final LocaleNameGetter INSTANCE = new LocaleNameGetter();
<i>2388</i>&nbsp;
<i>2389</i>&nbsp;        @Override
<i>2390</i>&nbsp;        public String getObject(LocaleNameProvider localeNameProvider,
<i>2391</i>&nbsp;                                Locale locale,
<i>2392</i>&nbsp;                                String key,
<i>2393</i>&nbsp;                                Object... params) {
<i>2394</i>&nbsp;            assert params.length == 3;
<i>2395</i>&nbsp;            int type = (Integer)params[0];
<i>2396</i>&nbsp;            String code = (String)params[1];
<i>2397</i>&nbsp;            String cat = (String)params[2];
<b class="nc"><i>2398</i>&nbsp;</b>
<b class="nc"><i>2399</i>&nbsp;            switch(type) {</b>
<b class="nc"><i>2400</i>&nbsp;            case DISPLAY_LANGUAGE:</b>
<b class="nc"><i>2401</i>&nbsp;                return localeNameProvider.getDisplayLanguage(code, locale);</b>
<b class="nc"><i>2402</i>&nbsp;            case DISPLAY_COUNTRY:</b>
<i>2403</i>&nbsp;                return localeNameProvider.getDisplayCountry(code, locale);
<i>2404</i>&nbsp;            case DISPLAY_VARIANT:
<i>2405</i>&nbsp;                return localeNameProvider.getDisplayVariant(code, locale);
<i>2406</i>&nbsp;            case DISPLAY_SCRIPT:
<i>2407</i>&nbsp;                return localeNameProvider.getDisplayScript(code, locale);
<i>2408</i>&nbsp;            case DISPLAY_UEXT_KEY:
<i>2409</i>&nbsp;                return localeNameProvider.getDisplayUnicodeExtensionKey(code, locale);
<i>2410</i>&nbsp;            case DISPLAY_UEXT_TYPE:
<i>2411</i>&nbsp;                return localeNameProvider.getDisplayUnicodeExtensionType(code, cat, locale);
<i>2412</i>&nbsp;            default:
<i>2413</i>&nbsp;                assert false; // shouldn&#39;t happen
<i>2414</i>&nbsp;            }
<i>2415</i>&nbsp;
<i>2416</i>&nbsp;            return null;
<i>2417</i>&nbsp;        }
<i>2418</i>&nbsp;    }
<i>2419</i>&nbsp;
<i>2420</i>&nbsp;    /**
<i>2421</i>&nbsp;     * Enum for locale categories.  These locale categories are used to get/set
<i>2422</i>&nbsp;     * the default locale for the specific functionality represented by the
<b class="nc"><i>2423</i>&nbsp;     * category.</b>
<b class="nc"><i>2424</i>&nbsp;     *</b>
<b class="nc"><i>2425</i>&nbsp;     * @see #getDefault(Locale.Category)</b>
<b class="nc"><i>2426</i>&nbsp;     * @see #setDefault(Locale.Category, Locale)</b>
<i>2427</i>&nbsp;     * @since 1.7
<b class="nc"><i>2428</i>&nbsp;     */</b>
<b class="nc"><i>2429</i>&nbsp;    public enum Category {</b>
<i>2430</i>&nbsp;
<i>2431</i>&nbsp;        /**
<i>2432</i>&nbsp;         * Category used to represent the default locale for
<i>2433</i>&nbsp;         * displaying user interfaces.
<i>2434</i>&nbsp;         */
<i>2435</i>&nbsp;        DISPLAY(&quot;user.language.display&quot;,
<i>2436</i>&nbsp;                &quot;user.script.display&quot;,
<i>2437</i>&nbsp;                &quot;user.country.display&quot;,
<i>2438</i>&nbsp;                &quot;user.variant.display&quot;,
<i>2439</i>&nbsp;                &quot;user.extensions.display&quot;),
<i>2440</i>&nbsp;
<i>2441</i>&nbsp;        /**
<i>2442</i>&nbsp;         * Category used to represent the default locale for
<i>2443</i>&nbsp;         * formatting dates, numbers, and/or currencies.
<i>2444</i>&nbsp;         */
<i>2445</i>&nbsp;        FORMAT(&quot;user.language.format&quot;,
<i>2446</i>&nbsp;               &quot;user.script.format&quot;,
<b class="nc"><i>2447</i>&nbsp;               &quot;user.country.format&quot;,</b>
<b class="nc"><i>2448</i>&nbsp;               &quot;user.variant.format&quot;,</b>
<b class="nc"><i>2449</i>&nbsp;               &quot;user.extensions.format&quot;);</b>
<b class="nc"><i>2450</i>&nbsp;</b>
<b class="nc"><i>2451</i>&nbsp;        Category(String languageKey, String scriptKey, String countryKey,</b>
<i>2452</i>&nbsp;                String variantKey, String extensionsKey) {
<i>2453</i>&nbsp;            this.languageKey = languageKey;
<i>2454</i>&nbsp;            this.scriptKey = scriptKey;
<i>2455</i>&nbsp;            this.countryKey = countryKey;
<i>2456</i>&nbsp;            this.variantKey = variantKey;
<i>2457</i>&nbsp;            this.extensionsKey = extensionsKey;
<i>2458</i>&nbsp;        }
<i>2459</i>&nbsp;
<i>2460</i>&nbsp;        final String languageKey;
<i>2461</i>&nbsp;        final String scriptKey;
<i>2462</i>&nbsp;        final String countryKey;
<i>2463</i>&nbsp;        final String variantKey;
<i>2464</i>&nbsp;        final String extensionsKey;
<i>2465</i>&nbsp;    }
<i>2466</i>&nbsp;
<i>2467</i>&nbsp;    /**
<b class="nc"><i>2468</i>&nbsp;     * &lt;code&gt;Builder&lt;/code&gt; is used to build instances of &lt;code&gt;Locale&lt;/code&gt;</b>
<b class="nc"><i>2469</i>&nbsp;     * from values configured by the setters.  Unlike the &lt;code&gt;Locale&lt;/code&gt;</b>
<b class="nc"><i>2470</i>&nbsp;     * constructors, the &lt;code&gt;Builder&lt;/code&gt; checks if a value configured by a</b>
<b class="nc"><i>2471</i>&nbsp;     * setter satisfies the syntax requirements defined by the &lt;code&gt;Locale&lt;/code&gt;</b>
<b class="nc"><i>2472</i>&nbsp;     * class.  A &lt;code&gt;Locale&lt;/code&gt; object created by a &lt;code&gt;Builder&lt;/code&gt; is</b>
<i>2473</i>&nbsp;     * well-formed and can be transformed to a well-formed IETF BCP 47 language tag
<i>2474</i>&nbsp;     * without losing information.
<i>2475</i>&nbsp;     *
<i>2476</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;Locale&lt;/code&gt; class does not provide any
<i>2477</i>&nbsp;     * syntactic restrictions on variant, while BCP 47 requires each variant
<i>2478</i>&nbsp;     * subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
<i>2479</i>&nbsp;     * alphanumerics.  The method &lt;code&gt;setVariant&lt;/code&gt; throws
<i>2480</i>&nbsp;     * &lt;code&gt;IllformedLocaleException&lt;/code&gt; for a variant that does not satisfy
<i>2481</i>&nbsp;     * this restriction. If it is necessary to support such a variant, use a
<i>2482</i>&nbsp;     * Locale constructor.  However, keep in mind that a &lt;code&gt;Locale&lt;/code&gt;
<i>2483</i>&nbsp;     * object created this way might lose the variant information when
<i>2484</i>&nbsp;     * transformed to a BCP 47 language tag.
<i>2485</i>&nbsp;     *
<i>2486</i>&nbsp;     * &lt;p&gt;The following example shows how to create a &lt;code&gt;Locale&lt;/code&gt; object
<i>2487</i>&nbsp;     * with the &lt;code&gt;Builder&lt;/code&gt;.
<i>2488</i>&nbsp;     * &lt;blockquote&gt;
<i>2489</i>&nbsp;     * &lt;pre&gt;
<i>2490</i>&nbsp;     *     Locale aLocale = new Builder().setLanguage(&quot;sr&quot;).setScript(&quot;Latn&quot;).setRegion(&quot;RS&quot;).build();
<i>2491</i>&nbsp;     * &lt;/pre&gt;
<i>2492</i>&nbsp;     * &lt;/blockquote&gt;
<b class="nc"><i>2493</i>&nbsp;     *</b>
<b class="nc"><i>2494</i>&nbsp;     * &lt;p&gt;Builders can be reused; &lt;code&gt;clear()&lt;/code&gt; resets all</b>
<b class="nc"><i>2495</i>&nbsp;     * fields to their default values.</b>
<b class="nc"><i>2496</i>&nbsp;     *</b>
<b class="nc"><i>2497</i>&nbsp;     * @see Locale#forLanguageTag</b>
<i>2498</i>&nbsp;     * @since 1.7
<i>2499</i>&nbsp;     */
<i>2500</i>&nbsp;    public static final class Builder {
<i>2501</i>&nbsp;        private final InternalLocaleBuilder localeBuilder;
<i>2502</i>&nbsp;
<i>2503</i>&nbsp;        /**
<i>2504</i>&nbsp;         * Constructs an empty Builder. The default value of all
<i>2505</i>&nbsp;         * fields, extensions, and private use information is the
<i>2506</i>&nbsp;         * empty string.
<i>2507</i>&nbsp;         */
<i>2508</i>&nbsp;        public Builder() {
<i>2509</i>&nbsp;            localeBuilder = new InternalLocaleBuilder();
<i>2510</i>&nbsp;        }
<i>2511</i>&nbsp;
<i>2512</i>&nbsp;        /**
<i>2513</i>&nbsp;         * Resets the &lt;code&gt;Builder&lt;/code&gt; to match the provided
<i>2514</i>&nbsp;         * &lt;code&gt;locale&lt;/code&gt;.  Existing state is discarded.
<i>2515</i>&nbsp;         *
<i>2516</i>&nbsp;         * &lt;p&gt;All fields of the locale must be well-formed, see {@link Locale}.
<i>2517</i>&nbsp;         *
<i>2518</i>&nbsp;         * &lt;p&gt;Locales with any ill-formed fields cause
<i>2519</i>&nbsp;         * &lt;code&gt;IllformedLocaleException&lt;/code&gt; to be thrown, except for the
<b class="nc"><i>2520</i>&nbsp;         * following three cases which are accepted for compatibility</b>
<b class="nc"><i>2521</i>&nbsp;         * reasons:&lt;ul&gt;</b>
<b class="nc"><i>2522</i>&nbsp;         * &lt;li&gt;Locale(&quot;ja&quot;, &quot;JP&quot;, &quot;JP&quot;) is treated as &quot;ja-JP-u-ca-japanese&quot;</b>
<b class="nc"><i>2523</i>&nbsp;         * &lt;li&gt;Locale(&quot;th&quot;, &quot;TH&quot;, &quot;TH&quot;) is treated as &quot;th-TH-u-nu-thai&quot;</b>
<b class="nc"><i>2524</i>&nbsp;         * &lt;li&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;) is treated as &quot;nn-NO&quot;&lt;/ul&gt;</b>
<i>2525</i>&nbsp;         *
<i>2526</i>&nbsp;         * @param locale the locale
<i>2527</i>&nbsp;         * @return This builder.
<i>2528</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;locale&lt;/code&gt; has
<i>2529</i>&nbsp;         * any ill-formed fields.
<i>2530</i>&nbsp;         * @throws NullPointerException if &lt;code&gt;locale&lt;/code&gt; is null.
<i>2531</i>&nbsp;         */
<i>2532</i>&nbsp;        public Builder setLocale(Locale locale) {
<i>2533</i>&nbsp;            try {
<i>2534</i>&nbsp;                localeBuilder.setLocale(locale.baseLocale, locale.localeExtensions);
<i>2535</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2536</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2537</i>&nbsp;            }
<i>2538</i>&nbsp;            return this;
<i>2539</i>&nbsp;        }
<i>2540</i>&nbsp;
<i>2541</i>&nbsp;        /**
<i>2542</i>&nbsp;         * Resets the Builder to match the provided IETF BCP 47
<i>2543</i>&nbsp;         * language tag.  Discards the existing state.  Null and the
<i>2544</i>&nbsp;         * empty string cause the builder to be reset, like {@link
<i>2545</i>&nbsp;         * #clear}.  Grandfathered tags (see {@link
<i>2546</i>&nbsp;         * Locale#forLanguageTag}) are converted to their canonical
<i>2547</i>&nbsp;         * form before being processed.  Otherwise, the language tag
<i>2548</i>&nbsp;         * must be well-formed (see {@link Locale}) or an exception is
<i>2549</i>&nbsp;         * thrown (unlike &lt;code&gt;Locale.forLanguageTag&lt;/code&gt;, which
<i>2550</i>&nbsp;         * just discards ill-formed and following portions of the
<i>2551</i>&nbsp;         * tag).
<b class="nc"><i>2552</i>&nbsp;         *</b>
<b class="nc"><i>2553</i>&nbsp;         * @param languageTag the language tag</b>
<b class="nc"><i>2554</i>&nbsp;         * @return This builder.</b>
<b class="nc"><i>2555</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;languageTag&lt;/code&gt; is ill-formed</b>
<b class="nc"><i>2556</i>&nbsp;         * @see Locale#forLanguageTag(String)</b>
<i>2557</i>&nbsp;         */
<i>2558</i>&nbsp;        public Builder setLanguageTag(String languageTag) {
<i>2559</i>&nbsp;            ParseStatus sts = new ParseStatus();
<i>2560</i>&nbsp;            LanguageTag tag = LanguageTag.parse(languageTag, sts);
<i>2561</i>&nbsp;            if (sts.isError()) {
<i>2562</i>&nbsp;                throw new IllformedLocaleException(sts.getErrorMessage(), sts.getErrorIndex());
<i>2563</i>&nbsp;            }
<i>2564</i>&nbsp;            localeBuilder.setLanguageTag(tag);
<i>2565</i>&nbsp;            return this;
<i>2566</i>&nbsp;        }
<i>2567</i>&nbsp;
<i>2568</i>&nbsp;        /**
<i>2569</i>&nbsp;         * Sets the language.  If &lt;code&gt;language&lt;/code&gt; is the empty string or
<i>2570</i>&nbsp;         * null, the language in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,
<i>2571</i>&nbsp;         * the language must be &lt;a href=&quot;./Locale.html#def_language&quot;&gt;well-formed&lt;/a&gt;
<i>2572</i>&nbsp;         * or an exception is thrown.
<i>2573</i>&nbsp;         *
<i>2574</i>&nbsp;         * &lt;p&gt;The typical language value is a two or three-letter language
<i>2575</i>&nbsp;         * code as defined in ISO639.
<i>2576</i>&nbsp;         *
<i>2577</i>&nbsp;         * @param language the language
<i>2578</i>&nbsp;         * @return This builder.
<i>2579</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;language&lt;/code&gt; is ill-formed
<i>2580</i>&nbsp;         */
<i>2581</i>&nbsp;        public Builder setLanguage(String language) {
<b class="nc"><i>2582</i>&nbsp;            try {</b>
<b class="nc"><i>2583</i>&nbsp;                localeBuilder.setLanguage(language);</b>
<b class="nc"><i>2584</i>&nbsp;            } catch (LocaleSyntaxException e) {</b>
<b class="nc"><i>2585</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());</b>
<b class="nc"><i>2586</i>&nbsp;            }</b>
<i>2587</i>&nbsp;            return this;
<i>2588</i>&nbsp;        }
<i>2589</i>&nbsp;
<i>2590</i>&nbsp;        /**
<i>2591</i>&nbsp;         * Sets the script. If &lt;code&gt;script&lt;/code&gt; is null or the empty string,
<i>2592</i>&nbsp;         * the script in this &lt;code&gt;Builder&lt;/code&gt; is removed.
<i>2593</i>&nbsp;         * Otherwise, the script must be &lt;a href=&quot;./Locale.html#def_script&quot;&gt;well-formed&lt;/a&gt; or an
<i>2594</i>&nbsp;         * exception is thrown.
<i>2595</i>&nbsp;         *
<i>2596</i>&nbsp;         * &lt;p&gt;The typical script value is a four-letter script code as defined by ISO 15924.
<i>2597</i>&nbsp;         *
<i>2598</i>&nbsp;         * @param script the script
<i>2599</i>&nbsp;         * @return This builder.
<i>2600</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;script&lt;/code&gt; is ill-formed
<i>2601</i>&nbsp;         */
<i>2602</i>&nbsp;        public Builder setScript(String script) {
<b class="nc"><i>2603</i>&nbsp;            try {</b>
<b class="nc"><i>2604</i>&nbsp;                localeBuilder.setScript(script);</b>
<b class="nc"><i>2605</i>&nbsp;            } catch (LocaleSyntaxException e) {</b>
<b class="nc"><i>2606</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());</b>
<b class="nc"><i>2607</i>&nbsp;            }</b>
<i>2608</i>&nbsp;            return this;
<i>2609</i>&nbsp;        }
<i>2610</i>&nbsp;
<i>2611</i>&nbsp;        /**
<i>2612</i>&nbsp;         * Sets the region.  If region is null or the empty string, the region
<i>2613</i>&nbsp;         * in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise,
<i>2614</i>&nbsp;         * the region must be &lt;a href=&quot;./Locale.html#def_region&quot;&gt;well-formed&lt;/a&gt; or an
<i>2615</i>&nbsp;         * exception is thrown.
<i>2616</i>&nbsp;         *
<i>2617</i>&nbsp;         * &lt;p&gt;The typical region value is a two-letter ISO 3166 code or a
<i>2618</i>&nbsp;         * three-digit UN M.49 area code.
<i>2619</i>&nbsp;         *
<i>2620</i>&nbsp;         * &lt;p&gt;The country value in the &lt;code&gt;Locale&lt;/code&gt; created by the
<i>2621</i>&nbsp;         * &lt;code&gt;Builder&lt;/code&gt; is always normalized to upper case.
<i>2622</i>&nbsp;         *
<i>2623</i>&nbsp;         * @param region the region
<i>2624</i>&nbsp;         * @return This builder.
<i>2625</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;region&lt;/code&gt; is ill-formed
<b class="nc"><i>2626</i>&nbsp;         */</b>
<b class="nc"><i>2627</i>&nbsp;        public Builder setRegion(String region) {</b>
<b class="nc"><i>2628</i>&nbsp;            try {</b>
<b class="nc"><i>2629</i>&nbsp;                localeBuilder.setRegion(region);</b>
<b class="nc"><i>2630</i>&nbsp;            } catch (LocaleSyntaxException e) {</b>
<i>2631</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2632</i>&nbsp;            }
<i>2633</i>&nbsp;            return this;
<i>2634</i>&nbsp;        }
<i>2635</i>&nbsp;
<i>2636</i>&nbsp;        /**
<i>2637</i>&nbsp;         * Sets the variant.  If variant is null or the empty string, the
<i>2638</i>&nbsp;         * variant in this &lt;code&gt;Builder&lt;/code&gt; is removed.  Otherwise, it
<b class="nc"><i>2639</i>&nbsp;         * must consist of one or more &lt;a href=&quot;./Locale.html#def_variant&quot;&gt;well-formed&lt;/a&gt;</b>
<b class="nc"><i>2640</i>&nbsp;         * subtags, or an exception is thrown.</b>
<i>2641</i>&nbsp;         *
<i>2642</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This method checks if &lt;code&gt;variant&lt;/code&gt;
<i>2643</i>&nbsp;         * satisfies the IETF BCP 47 variant subtag&#39;s syntax requirements,
<i>2644</i>&nbsp;         * and normalizes the value to lowercase letters.  However,
<i>2645</i>&nbsp;         * the &lt;code&gt;Locale&lt;/code&gt; class does not impose any syntactic
<i>2646</i>&nbsp;         * restriction on variant, and the variant value in
<i>2647</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt; is case sensitive.  To set such a variant,
<i>2648</i>&nbsp;         * use a Locale constructor.
<i>2649</i>&nbsp;         *
<i>2650</i>&nbsp;         * @param variant the variant
<b class="nc"><i>2651</i>&nbsp;         * @return This builder.</b>
<b class="nc"><i>2652</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;variant&lt;/code&gt; is ill-formed</b>
<i>2653</i>&nbsp;         */
<i>2654</i>&nbsp;        public Builder setVariant(String variant) {
<i>2655</i>&nbsp;            try {
<i>2656</i>&nbsp;                localeBuilder.setVariant(variant);
<i>2657</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2658</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2659</i>&nbsp;            }
<i>2660</i>&nbsp;            return this;
<i>2661</i>&nbsp;        }
<i>2662</i>&nbsp;
<i>2663</i>&nbsp;        /**
<i>2664</i>&nbsp;         * Sets the extension for the given key. If the value is null or the
<i>2665</i>&nbsp;         * empty string, the extension is removed.  Otherwise, the extension
<b class="nc"><i>2666</i>&nbsp;         * must be &lt;a href=&quot;./Locale.html#def_extensions&quot;&gt;well-formed&lt;/a&gt; or an exception</b>
<b class="nc"><i>2667</i>&nbsp;         * is thrown.</b>
<b class="nc"><i>2668</i>&nbsp;         *</b>
<b class="nc"><i>2669</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#UNICODE_LOCALE_EXTENSION</b>
<b class="nc"><i>2670</i>&nbsp;         * UNICODE_LOCALE_EXTENSION} (&#39;u&#39;) is used for the Unicode locale extension.</b>
<i>2671</i>&nbsp;         * Setting a value for this key replaces any existing Unicode locale key/type
<b class="nc"><i>2672</i>&nbsp;         * pairs with those defined in the extension.</b>
<i>2673</i>&nbsp;         *
<i>2674</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; The key {@link Locale#PRIVATE_USE_EXTENSION
<i>2675</i>&nbsp;         * PRIVATE_USE_EXTENSION} (&#39;x&#39;) is used for the private use code. To be
<i>2676</i>&nbsp;         * well-formed, the value for this key needs only to have subtags of one to
<i>2677</i>&nbsp;         * eight alphanumeric characters, not two to eight as in the general case.
<i>2678</i>&nbsp;         *
<i>2679</i>&nbsp;         * @param key the extension key
<i>2680</i>&nbsp;         * @param value the extension value
<i>2681</i>&nbsp;         * @return This builder.
<i>2682</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; is illegal
<i>2683</i>&nbsp;         * or &lt;code&gt;value&lt;/code&gt; is ill-formed
<i>2684</i>&nbsp;         * @see #setUnicodeLocaleKeyword(String, String)
<i>2685</i>&nbsp;         */
<i>2686</i>&nbsp;        public Builder setExtension(char key, String value) {
<i>2687</i>&nbsp;            try {
<i>2688</i>&nbsp;                localeBuilder.setExtension(key, value);
<i>2689</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2690</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2691</i>&nbsp;            }
<i>2692</i>&nbsp;            return this;
<i>2693</i>&nbsp;        }
<i>2694</i>&nbsp;
<i>2695</i>&nbsp;        /**
<i>2696</i>&nbsp;         * Sets the Unicode locale keyword type for the given key.  If the type
<i>2697</i>&nbsp;         * is null, the Unicode keyword is removed.  Otherwise, the key must be
<i>2698</i>&nbsp;         * non-null and both key and type must be &lt;a
<i>2699</i>&nbsp;         * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
<i>2700</i>&nbsp;         * is thrown.
<i>2701</i>&nbsp;         *
<i>2702</i>&nbsp;         * &lt;p&gt;Keys and types are converted to lower case.
<i>2703</i>&nbsp;         *
<i>2704</i>&nbsp;         * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;:Setting the &#39;u&#39; extension via {@link #setExtension}
<i>2705</i>&nbsp;         * replaces all Unicode locale keywords with those defined in the
<i>2706</i>&nbsp;         * extension.
<i>2707</i>&nbsp;         *
<i>2708</i>&nbsp;         * @param key the Unicode locale key
<i>2709</i>&nbsp;         * @param type the Unicode locale type
<i>2710</i>&nbsp;         * @return This builder.
<i>2711</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;
<i>2712</i>&nbsp;         * is ill-formed
<i>2713</i>&nbsp;         * @throws NullPointerException if &lt;code&gt;key&lt;/code&gt; is null
<i>2714</i>&nbsp;         * @see #setExtension(char, String)
<i>2715</i>&nbsp;         */
<i>2716</i>&nbsp;        public Builder setUnicodeLocaleKeyword(String key, String type) {
<i>2717</i>&nbsp;            try {
<i>2718</i>&nbsp;                localeBuilder.setUnicodeLocaleKeyword(key, type);
<i>2719</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2720</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2721</i>&nbsp;            }
<i>2722</i>&nbsp;            return this;
<i>2723</i>&nbsp;        }
<i>2724</i>&nbsp;
<i>2725</i>&nbsp;        /**
<i>2726</i>&nbsp;         * Adds a unicode locale attribute, if not already present, otherwise
<i>2727</i>&nbsp;         * has no effect.  The attribute must not be null and must be &lt;a
<i>2728</i>&nbsp;         * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
<i>2729</i>&nbsp;         * is thrown.
<i>2730</i>&nbsp;         *
<i>2731</i>&nbsp;         * @param attribute the attribute
<i>2732</i>&nbsp;         * @return This builder.
<i>2733</i>&nbsp;         * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null
<i>2734</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed
<i>2735</i>&nbsp;         * @see #setExtension(char, String)
<i>2736</i>&nbsp;         */
<i>2737</i>&nbsp;        public Builder addUnicodeLocaleAttribute(String attribute) {
<i>2738</i>&nbsp;            try {
<i>2739</i>&nbsp;                localeBuilder.addUnicodeLocaleAttribute(attribute);
<i>2740</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2741</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2742</i>&nbsp;            }
<i>2743</i>&nbsp;            return this;
<i>2744</i>&nbsp;        }
<i>2745</i>&nbsp;
<i>2746</i>&nbsp;        /**
<i>2747</i>&nbsp;         * Removes a unicode locale attribute, if present, otherwise has no
<i>2748</i>&nbsp;         * effect.  The attribute must not be null and must be &lt;a
<i>2749</i>&nbsp;         * href=&quot;./Locale.html#def_locale_extension&quot;&gt;well-formed&lt;/a&gt; or an exception
<i>2750</i>&nbsp;         * is thrown.
<i>2751</i>&nbsp;         *
<i>2752</i>&nbsp;         * &lt;p&gt;Attribute comparison for removal is case-insensitive.
<i>2753</i>&nbsp;         *
<i>2754</i>&nbsp;         * @param attribute the attribute
<i>2755</i>&nbsp;         * @return This builder.
<i>2756</i>&nbsp;         * @throws NullPointerException if &lt;code&gt;attribute&lt;/code&gt; is null
<i>2757</i>&nbsp;         * @throws IllformedLocaleException if &lt;code&gt;attribute&lt;/code&gt; is ill-formed
<i>2758</i>&nbsp;         * @see #setExtension(char, String)
<i>2759</i>&nbsp;         */
<i>2760</i>&nbsp;        public Builder removeUnicodeLocaleAttribute(String attribute) {
<i>2761</i>&nbsp;            Objects.requireNonNull(attribute);
<i>2762</i>&nbsp;            try {
<i>2763</i>&nbsp;                localeBuilder.removeUnicodeLocaleAttribute(attribute);
<i>2764</i>&nbsp;            } catch (LocaleSyntaxException e) {
<i>2765</i>&nbsp;                throw new IllformedLocaleException(e.getMessage(), e.getErrorIndex());
<i>2766</i>&nbsp;            }
<i>2767</i>&nbsp;            return this;
<b class="nc"><i>2768</i>&nbsp;        }</b>
<i>2769</i>&nbsp;
<i>2770</i>&nbsp;        /**
<i>2771</i>&nbsp;         * Resets the builder to its initial, empty state.
<i>2772</i>&nbsp;         *
<i>2773</i>&nbsp;         * @return This builder.
<i>2774</i>&nbsp;         */
<b class="nc"><i>2775</i>&nbsp;        public Builder clear() {</b>
<i>2776</i>&nbsp;            localeBuilder.clear();
<i>2777</i>&nbsp;            return this;
<i>2778</i>&nbsp;        }
<i>2779</i>&nbsp;
<b class="nc"><i>2780</i>&nbsp;        /**</b>
<i>2781</i>&nbsp;         * Resets the extensions to their initial, empty state.
<i>2782</i>&nbsp;         * Language, script, region and variant are unchanged.
<i>2783</i>&nbsp;         *
<i>2784</i>&nbsp;         * @return This builder.
<i>2785</i>&nbsp;         * @see #setExtension(char, String)
<b class="nc"><i>2786</i>&nbsp;         */</b>
<i>2787</i>&nbsp;        public Builder clearExtensions() {
<i>2788</i>&nbsp;            localeBuilder.clearExtensions();
<i>2789</i>&nbsp;            return this;
<i>2790</i>&nbsp;        }
<i>2791</i>&nbsp;
<i>2792</i>&nbsp;        /**
<i>2793</i>&nbsp;         * Returns an instance of &lt;code&gt;Locale&lt;/code&gt; created from the fields set
<i>2794</i>&nbsp;         * on this builder.
<i>2795</i>&nbsp;         *
<i>2796</i>&nbsp;         * &lt;p&gt;This applies the conversions listed in {@link Locale#forLanguageTag}
<b class="nc"><i>2797</i>&nbsp;         * when constructing a Locale. (Grandfathered tags are handled in</b>
<i>2798</i>&nbsp;         * {@link #setLanguageTag}.)
<i>2799</i>&nbsp;         *
<i>2800</i>&nbsp;         * @return A Locale.
<i>2801</i>&nbsp;         */
<i>2802</i>&nbsp;        public Locale build() {
<i>2803</i>&nbsp;            BaseLocale baseloc = localeBuilder.getBaseLocale();
<b class="nc"><i>2804</i>&nbsp;            LocaleExtensions extensions = localeBuilder.getLocaleExtensions();</b>
<i>2805</i>&nbsp;            if (extensions == null &amp;&amp; baseloc.getVariant().length() &gt; 0) {
<i>2806</i>&nbsp;                extensions = getCompatibilityExtensions(baseloc.getLanguage(), baseloc.getScript(),
<i>2807</i>&nbsp;                        baseloc.getRegion(), baseloc.getVariant());
<i>2808</i>&nbsp;            }
<i>2809</i>&nbsp;            return Locale.getInstance(baseloc, extensions);
<i>2810</i>&nbsp;        }
<i>2811</i>&nbsp;    }
<i>2812</i>&nbsp;
<i>2813</i>&nbsp;    /**
<i>2814</i>&nbsp;     * This enum provides constants to select a filtering mode for locale
<i>2815</i>&nbsp;     * matching. Refer to &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647
<i>2816</i>&nbsp;     * Matching of Language Tags&lt;/a&gt; for details.
<i>2817</i>&nbsp;     *
<i>2818</i>&nbsp;     * &lt;p&gt;As an example, think of two Language Priority Lists each of which
<i>2819</i>&nbsp;     * includes only one language range and a set of following language tags:
<i>2820</i>&nbsp;     *
<i>2821</i>&nbsp;     * &lt;pre&gt;
<i>2822</i>&nbsp;     *    de (German)
<i>2823</i>&nbsp;     *    de-DE (German, Germany)
<i>2824</i>&nbsp;     *    de-Deva (German, in Devanagari script)
<i>2825</i>&nbsp;     *    de-Deva-DE (German, in Devanagari script, Germany)
<i>2826</i>&nbsp;     *    de-DE-1996 (German, Germany, orthography of 1996)
<i>2827</i>&nbsp;     *    de-Latn-DE (German, in Latin script, Germany)
<i>2828</i>&nbsp;     *    de-Latn-DE-1996 (German, in Latin script, Germany, orthography of 1996)
<i>2829</i>&nbsp;     * &lt;/pre&gt;
<i>2830</i>&nbsp;     *
<i>2831</i>&nbsp;     * The filtering method will behave as follows:
<i>2832</i>&nbsp;     *
<i>2833</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<i>2834</i>&nbsp;     * &lt;caption&gt;Filtering method behavior&lt;/caption&gt;
<i>2835</i>&nbsp;     * &lt;thead&gt;
<i>2836</i>&nbsp;     * &lt;tr&gt;
<i>2837</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;Filtering Mode&lt;/th&gt;
<i>2838</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;Language Priority List: {@code &quot;de-DE&quot;}&lt;/th&gt;
<i>2839</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;Language Priority List: {@code &quot;de-*-DE&quot;}&lt;/th&gt;
<i>2840</i>&nbsp;     * &lt;/tr&gt;
<i>2841</i>&nbsp;     * &lt;/thead&gt;
<i>2842</i>&nbsp;     * &lt;tbody&gt;
<i>2843</i>&nbsp;     * &lt;tr&gt;
<i>2844</i>&nbsp;     * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
<i>2845</i>&nbsp;     * {@link FilteringMode#AUTOSELECT_FILTERING AUTOSELECT_FILTERING}
<i>2846</i>&nbsp;     * &lt;/th&gt;
<i>2847</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2848</i>&nbsp;     * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
<i>2849</i>&nbsp;     * {@code &quot;de-DE-1996&quot;}.
<i>2850</i>&nbsp;     * &lt;/td&gt;
<i>2851</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2852</i>&nbsp;     * Performs &lt;em&gt;extended&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;},
<i>2853</i>&nbsp;     * {@code &quot;de-Deva-DE&quot;}, {@code &quot;de-DE-1996&quot;}, {@code &quot;de-Latn-DE&quot;}, and
<i>2854</i>&nbsp;     * {@code &quot;de-Latn-DE-1996&quot;}.
<i>2855</i>&nbsp;     * &lt;/td&gt;
<i>2856</i>&nbsp;     * &lt;/tr&gt;
<i>2857</i>&nbsp;     * &lt;tr&gt;
<b class="nc"><i>2858</i>&nbsp;     * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;</b>
<i>2859</i>&nbsp;     * {@link FilteringMode#EXTENDED_FILTERING EXTENDED_FILTERING}
<i>2860</i>&nbsp;     * &lt;/th&gt;
<i>2861</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2862</i>&nbsp;     * Performs &lt;em&gt;extended&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;},
<i>2863</i>&nbsp;     * {@code &quot;de-Deva-DE&quot;}, {@code &quot;de-DE-1996&quot;}, {@code &quot;de-Latn-DE&quot;}, and
<i>2864</i>&nbsp;     * {@code &quot;de-Latn-DE-1996&quot;}.
<i>2865</i>&nbsp;     * &lt;/td&gt;
<i>2866</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;
<i>2867</i>&nbsp;     * &lt;/tr&gt;
<i>2868</i>&nbsp;     * &lt;tr&gt;
<i>2869</i>&nbsp;     * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
<i>2870</i>&nbsp;     * {@link FilteringMode#IGNORE_EXTENDED_RANGES IGNORE_EXTENDED_RANGES}
<i>2871</i>&nbsp;     * &lt;/th&gt;
<b class="nc"><i>2872</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;</b>
<i>2873</i>&nbsp;     * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
<i>2874</i>&nbsp;     * {@code &quot;de-DE-1996&quot;}.
<i>2875</i>&nbsp;     * &lt;/td&gt;
<i>2876</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2877</i>&nbsp;     * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code null} because
<i>2878</i>&nbsp;     * nothing matches.
<i>2879</i>&nbsp;     * &lt;/td&gt;
<i>2880</i>&nbsp;     * &lt;/tr&gt;
<i>2881</i>&nbsp;     * &lt;tr&gt;
<i>2882</i>&nbsp;     * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;
<i>2883</i>&nbsp;     * {@link FilteringMode#MAP_EXTENDED_RANGES MAP_EXTENDED_RANGES}
<i>2884</i>&nbsp;     * &lt;/th&gt;
<i>2885</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;
<i>2886</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2887</i>&nbsp;     * Performs &lt;em&gt;basic&lt;/em&gt; filtering and returns {@code &quot;de-DE&quot;} and
<b class="nc"><i>2888</i>&nbsp;     * {@code &quot;de-DE-1996&quot;} because {@code &quot;de-*-DE&quot;} is mapped to</b>
<b class="nc"><i>2889</i>&nbsp;     * {@code &quot;de-DE&quot;}.</b>
<b class="nc"><i>2890</i>&nbsp;     * &lt;/td&gt;</b>
<i>2891</i>&nbsp;     * &lt;/tr&gt;
<b class="nc"><i>2892</i>&nbsp;     * &lt;tr&gt;</b>
<b class="nc"><i>2893</i>&nbsp;     * &lt;th scope=&quot;row&quot; style=&quot;vertical-align:top&quot;&gt;</b>
<i>2894</i>&nbsp;     * {@link FilteringMode#REJECT_EXTENDED_RANGES REJECT_EXTENDED_RANGES}
<i>2895</i>&nbsp;     * &lt;/th&gt;
<b class="nc"><i>2896</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;Same as above.&lt;/td&gt;</b>
<i>2897</i>&nbsp;     * &lt;td style=&quot;vertical-align:top&quot;&gt;
<i>2898</i>&nbsp;     * Throws {@link IllegalArgumentException} because {@code &quot;de-*-DE&quot;} is
<b class="nc"><i>2899</i>&nbsp;     * not a valid basic language range.</b>
<b class="nc"><i>2900</i>&nbsp;     * &lt;/td&gt;</b>
<b class="nc"><i>2901</i>&nbsp;     * &lt;/tr&gt;</b>
<b class="nc"><i>2902</i>&nbsp;     * &lt;/tbody&gt;</b>
<b class="nc"><i>2903</i>&nbsp;     * &lt;/table&gt;</b>
<i>2904</i>&nbsp;     *
<b class="nc"><i>2905</i>&nbsp;     * @see #filter(List, Collection, FilteringMode)</b>
<b class="nc"><i>2906</i>&nbsp;     * @see #filterTags(List, Collection, FilteringMode)</b>
<b class="nc"><i>2907</i>&nbsp;     *</b>
<b class="nc"><i>2908</i>&nbsp;     * @since 1.8</b>
<i>2909</i>&nbsp;     */
<i>2910</i>&nbsp;    public static enum FilteringMode {
<i>2911</i>&nbsp;        /**
<b class="nc"><i>2912</i>&nbsp;         * Specifies automatic filtering mode based on the given Language</b>
<b class="nc"><i>2913</i>&nbsp;         * Priority List consisting of language ranges. If all of the ranges</b>
<i>2914</i>&nbsp;         * are basic, basic filtering is selected. Otherwise, extended
<i>2915</i>&nbsp;         * filtering is selected.
<b class="nc"><i>2916</i>&nbsp;         */</b>
<b class="nc"><i>2917</i>&nbsp;        AUTOSELECT_FILTERING,</b>
<i>2918</i>&nbsp;
<i>2919</i>&nbsp;        /**
<i>2920</i>&nbsp;         * Specifies extended filtering.
<i>2921</i>&nbsp;         */
<b class="nc"><i>2922</i>&nbsp;        EXTENDED_FILTERING,</b>
<b class="nc"><i>2923</i>&nbsp;</b>
<b class="nc"><i>2924</i>&nbsp;        /**</b>
<b class="nc"><i>2925</i>&nbsp;         * Specifies basic filtering: Note that any extended language ranges</b>
<i>2926</i>&nbsp;         * included in the given Language Priority List are ignored.
<b class="nc"><i>2927</i>&nbsp;         */</b>
<b class="nc"><i>2928</i>&nbsp;        IGNORE_EXTENDED_RANGES,</b>
<b class="nc"><i>2929</i>&nbsp;</b>
<b class="nc"><i>2930</i>&nbsp;        /**</b>
<b class="nc"><i>2931</i>&nbsp;         * Specifies basic filtering: If any extended language ranges are</b>
<i>2932</i>&nbsp;         * included in the given Language Priority List, they are mapped to the
<i>2933</i>&nbsp;         * basic language range. Specifically, a language range starting with a
<i>2934</i>&nbsp;         * subtag {@code &quot;*&quot;} is treated as a language range {@code &quot;*&quot;}. For
<b class="nc"><i>2935</i>&nbsp;         * example, {@code &quot;*-US&quot;} is treated as {@code &quot;*&quot;}. If {@code &quot;*&quot;} is</b>
<b class="nc"><i>2936</i>&nbsp;         * not the first subtag, {@code &quot;*&quot;} and extra {@code &quot;-&quot;} are removed.</b>
<b class="nc"><i>2937</i>&nbsp;         * For example, {@code &quot;ja-*-JP&quot;} is mapped to {@code &quot;ja-JP&quot;}.</b>
<i>2938</i>&nbsp;         */
<i>2939</i>&nbsp;        MAP_EXTENDED_RANGES,
<i>2940</i>&nbsp;
<b class="nc"><i>2941</i>&nbsp;        /**</b>
<i>2942</i>&nbsp;         * Specifies basic filtering: If any extended language ranges are
<i>2943</i>&nbsp;         * included in the given Language Priority List, the list is rejected
<i>2944</i>&nbsp;         * and the filtering method throws {@link IllegalArgumentException}.
<i>2945</i>&nbsp;         */
<i>2946</i>&nbsp;        REJECT_EXTENDED_RANGES
<i>2947</i>&nbsp;    };
<i>2948</i>&nbsp;
<i>2949</i>&nbsp;    /**
<b class="nc"><i>2950</i>&nbsp;     * This class expresses a &lt;em&gt;Language Range&lt;/em&gt; defined in</b>
<i>2951</i>&nbsp;     * &lt;a href=&quot;http://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647 Matching of
<i>2952</i>&nbsp;     * Language Tags&lt;/a&gt;. A language range is an identifier which is used to
<i>2953</i>&nbsp;     * select language tag(s) meeting specific requirements by using the
<i>2954</i>&nbsp;     * mechanisms described in &lt;a href=&quot;Locale.html#LocaleMatching&quot;&gt;Locale
<i>2955</i>&nbsp;     * Matching&lt;/a&gt;. A list which represents a user&#39;s preferences and consists
<i>2956</i>&nbsp;     * of language ranges is called a &lt;em&gt;Language Priority List&lt;/em&gt;.
<i>2957</i>&nbsp;     *
<i>2958</i>&nbsp;     * &lt;p&gt;There are two types of language ranges: basic and extended. In RFC
<b class="nc"><i>2959</i>&nbsp;     * 4647, the syntax of language ranges is expressed in</b>
<i>2960</i>&nbsp;     * &lt;a href=&quot;http://tools.ietf.org/html/rfc4234&quot;&gt;ABNF&lt;/a&gt; as follows:
<i>2961</i>&nbsp;     * &lt;blockquote&gt;
<i>2962</i>&nbsp;     * &lt;pre&gt;
<i>2963</i>&nbsp;     *     basic-language-range    = (1*8ALPHA *(&quot;-&quot; 1*8alphanum)) / &quot;*&quot;
<i>2964</i>&nbsp;     *     extended-language-range = (1*8ALPHA / &quot;*&quot;)
<i>2965</i>&nbsp;     *                               *(&quot;-&quot; (1*8alphanum / &quot;*&quot;))
<i>2966</i>&nbsp;     *     alphanum                = ALPHA / DIGIT
<i>2967</i>&nbsp;     * &lt;/pre&gt;
<i>2968</i>&nbsp;     * &lt;/blockquote&gt;
<i>2969</i>&nbsp;     * For example, {@code &quot;en&quot;} (English), {@code &quot;ja-JP&quot;} (Japanese, Japan),
<i>2970</i>&nbsp;     * {@code &quot;*&quot;} (special language range which matches any language tag) are
<i>2971</i>&nbsp;     * basic language ranges, whereas {@code &quot;*-CH&quot;} (any languages,
<i>2972</i>&nbsp;     * Switzerland), {@code &quot;es-*&quot;} (Spanish, any regions), and
<i>2973</i>&nbsp;     * {@code &quot;zh-Hant-*&quot;} (Traditional Chinese, any regions) are extended
<i>2974</i>&nbsp;     * language ranges.
<i>2975</i>&nbsp;     *
<i>2976</i>&nbsp;     * @see #filter
<i>2977</i>&nbsp;     * @see #filterTags
<i>2978</i>&nbsp;     * @see #lookup
<i>2979</i>&nbsp;     * @see #lookupTag
<i>2980</i>&nbsp;     *
<i>2981</i>&nbsp;     * @since 1.8
<i>2982</i>&nbsp;     */
<i>2983</i>&nbsp;    public static final class LanguageRange {
<i>2984</i>&nbsp;
<i>2985</i>&nbsp;       /**
<i>2986</i>&nbsp;        * A constant holding the maximum value of weight, 1.0, which indicates
<i>2987</i>&nbsp;        * that the language range is a good fit for the user.
<i>2988</i>&nbsp;        */
<i>2989</i>&nbsp;        public static final double MAX_WEIGHT = 1.0;
<i>2990</i>&nbsp;
<i>2991</i>&nbsp;       /**
<i>2992</i>&nbsp;        * A constant holding the minimum value of weight, 0.0, which indicates
<i>2993</i>&nbsp;        * that the language range is not a good fit for the user.
<i>2994</i>&nbsp;        */
<i>2995</i>&nbsp;        public static final double MIN_WEIGHT = 0.0;
<i>2996</i>&nbsp;
<i>2997</i>&nbsp;        private final String range;
<i>2998</i>&nbsp;        private final double weight;
<i>2999</i>&nbsp;
<i>3000</i>&nbsp;        private volatile int hash;
<i>3001</i>&nbsp;
<i>3002</i>&nbsp;        /**
<i>3003</i>&nbsp;         * Constructs a {@code LanguageRange} using the given {@code range}.
<i>3004</i>&nbsp;         * Note that no validation is done against the IANA Language Subtag
<i>3005</i>&nbsp;         * Registry at time of construction.
<i>3006</i>&nbsp;         *
<i>3007</i>&nbsp;         * &lt;p&gt;This is equivalent to {@code LanguageRange(range, MAX_WEIGHT)}.
<i>3008</i>&nbsp;         *
<i>3009</i>&nbsp;         * @param range a language range
<i>3010</i>&nbsp;         * @throws NullPointerException if the given {@code range} is
<i>3011</i>&nbsp;         *     {@code null}
<i>3012</i>&nbsp;         * @throws IllegalArgumentException if the given {@code range} does not
<i>3013</i>&nbsp;         * comply with the syntax of the language range mentioned in RFC 4647
<i>3014</i>&nbsp;         */
<i>3015</i>&nbsp;        public LanguageRange(String range) {
<i>3016</i>&nbsp;            this(range, MAX_WEIGHT);
<i>3017</i>&nbsp;        }
<i>3018</i>&nbsp;
<i>3019</i>&nbsp;        /**
<i>3020</i>&nbsp;         * Constructs a {@code LanguageRange} using the given {@code range} and
<i>3021</i>&nbsp;         * {@code weight}. Note that no validation is done against the IANA
<i>3022</i>&nbsp;         * Language Subtag Registry at time of construction.
<i>3023</i>&nbsp;         *
<i>3024</i>&nbsp;         * @param range  a language range
<i>3025</i>&nbsp;         * @param weight a weight value between {@code MIN_WEIGHT} and
<i>3026</i>&nbsp;         *     {@code MAX_WEIGHT}
<i>3027</i>&nbsp;         * @throws NullPointerException if the given {@code range} is
<b class="nc"><i>3028</i>&nbsp;         *     {@code null}</b>
<i>3029</i>&nbsp;         * @throws IllegalArgumentException if the given {@code range} does not
<i>3030</i>&nbsp;         * comply with the syntax of the language range mentioned in RFC 4647
<i>3031</i>&nbsp;         * or if the given {@code weight} is less than {@code MIN_WEIGHT}
<i>3032</i>&nbsp;         * or greater than {@code MAX_WEIGHT}
<i>3033</i>&nbsp;         */
<i>3034</i>&nbsp;        public LanguageRange(String range, double weight) {
<i>3035</i>&nbsp;            if (range == null) {
<i>3036</i>&nbsp;                throw new NullPointerException();
<i>3037</i>&nbsp;            }
<i>3038</i>&nbsp;            if (weight &lt; MIN_WEIGHT || weight &gt; MAX_WEIGHT) {
<i>3039</i>&nbsp;                throw new IllegalArgumentException(&quot;weight=&quot; + weight);
<i>3040</i>&nbsp;            }
<i>3041</i>&nbsp;
<i>3042</i>&nbsp;            range = range.toLowerCase(Locale.ROOT);
<i>3043</i>&nbsp;
<i>3044</i>&nbsp;            // Do syntax check.
<i>3045</i>&nbsp;            boolean isIllFormed = false;
<i>3046</i>&nbsp;            String[] subtags = range.split(&quot;-&quot;);
<i>3047</i>&nbsp;            if (isSubtagIllFormed(subtags[0], true)
<i>3048</i>&nbsp;                || range.endsWith(&quot;-&quot;)) {
<i>3049</i>&nbsp;                isIllFormed = true;
<i>3050</i>&nbsp;            } else {
<i>3051</i>&nbsp;                for (int i = 1; i &lt; subtags.length; i++) {
<b class="nc"><i>3052</i>&nbsp;                    if (isSubtagIllFormed(subtags[i], false)) {</b>
<i>3053</i>&nbsp;                        isIllFormed = true;
<i>3054</i>&nbsp;                        break;
<i>3055</i>&nbsp;                    }
<i>3056</i>&nbsp;                }
<i>3057</i>&nbsp;            }
<i>3058</i>&nbsp;            if (isIllFormed) {
<i>3059</i>&nbsp;                throw new IllegalArgumentException(&quot;range=&quot; + range);
<i>3060</i>&nbsp;            }
<i>3061</i>&nbsp;
<i>3062</i>&nbsp;            this.range = range;
<i>3063</i>&nbsp;            this.weight = weight;
<i>3064</i>&nbsp;        }
<i>3065</i>&nbsp;
<i>3066</i>&nbsp;        private static boolean isSubtagIllFormed(String subtag,
<i>3067</i>&nbsp;                                                 boolean isFirstSubtag) {
<i>3068</i>&nbsp;            if (subtag.equals(&quot;&quot;) || subtag.length() &gt; 8) {
<i>3069</i>&nbsp;                return true;
<i>3070</i>&nbsp;            } else if (subtag.equals(&quot;*&quot;)) {
<i>3071</i>&nbsp;                return false;
<i>3072</i>&nbsp;            }
<i>3073</i>&nbsp;            char[] charArray = subtag.toCharArray();
<i>3074</i>&nbsp;            if (isFirstSubtag) { // ALPHA
<i>3075</i>&nbsp;                for (char c : charArray) {
<i>3076</i>&nbsp;                    if (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;) {
<i>3077</i>&nbsp;                        return true;
<i>3078</i>&nbsp;                    }
<i>3079</i>&nbsp;                }
<i>3080</i>&nbsp;            } else { // ALPHA / DIGIT
<i>3081</i>&nbsp;                for (char c : charArray) {
<i>3082</i>&nbsp;                    if (c &lt; &#39;0&#39; || (c &gt; &#39;9&#39; &amp;&amp; c &lt; &#39;a&#39;) || c &gt; &#39;z&#39;) {
<i>3083</i>&nbsp;                        return true;
<i>3084</i>&nbsp;                    }
<i>3085</i>&nbsp;                }
<i>3086</i>&nbsp;            }
<i>3087</i>&nbsp;            return false;
<i>3088</i>&nbsp;        }
<i>3089</i>&nbsp;
<i>3090</i>&nbsp;        /**
<i>3091</i>&nbsp;         * Returns the language range of this {@code LanguageRange}.
<i>3092</i>&nbsp;         *
<i>3093</i>&nbsp;         * @return the language range.
<i>3094</i>&nbsp;         */
<i>3095</i>&nbsp;        public String getRange() {
<i>3096</i>&nbsp;            return range;
<i>3097</i>&nbsp;        }
<i>3098</i>&nbsp;
<i>3099</i>&nbsp;        /**
<i>3100</i>&nbsp;         * Returns the weight of this {@code LanguageRange}.
<i>3101</i>&nbsp;         *
<i>3102</i>&nbsp;         * @return the weight value.
<i>3103</i>&nbsp;         */
<i>3104</i>&nbsp;        public double getWeight() {
<b class="nc"><i>3105</i>&nbsp;            return weight;</b>
<i>3106</i>&nbsp;        }
<i>3107</i>&nbsp;
<i>3108</i>&nbsp;        /**
<i>3109</i>&nbsp;         * Parses the given {@code ranges} to generate a Language Priority List.
<i>3110</i>&nbsp;         *
<i>3111</i>&nbsp;         * &lt;p&gt;This method performs a syntactic check for each language range in
<i>3112</i>&nbsp;         * the given {@code ranges} but doesn&#39;t do validation using the IANA
<i>3113</i>&nbsp;         * Language Subtag Registry.
<i>3114</i>&nbsp;         *
<b class="nc"><i>3115</i>&nbsp;         * &lt;p&gt;The {@code ranges} to be given can take one of the following</b>
<b class="nc"><i>3116</i>&nbsp;         * forms:</b>
<b class="nc"><i>3117</i>&nbsp;         *</b>
<b class="nc"><i>3118</i>&nbsp;         * &lt;pre&gt;</b>
<b class="nc"><i>3119</i>&nbsp;         *   &quot;Accept-Language: ja,en;q=0.4&quot;  (weighted list with Accept-Language prefix)</b>
<b class="nc"><i>3120</i>&nbsp;         *   &quot;ja,en;q=0.4&quot;                   (weighted list)</b>
<i>3121</i>&nbsp;         *   &quot;ja,en&quot;                         (prioritized list)
<b class="nc"><i>3122</i>&nbsp;         * &lt;/pre&gt;</b>
<i>3123</i>&nbsp;         *
<i>3124</i>&nbsp;         * In a weighted list, each language range is given a weight value.
<i>3125</i>&nbsp;         * The weight value is identical to the &quot;quality value&quot; in
<i>3126</i>&nbsp;         * &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, and it
<i>3127</i>&nbsp;         * expresses how much the user prefers  the language. A weight value is
<i>3128</i>&nbsp;         * specified after a corresponding language range followed by
<i>3129</i>&nbsp;         * {@code &quot;;q=&quot;}, and the default weight value is {@code MAX_WEIGHT}
<i>3130</i>&nbsp;         * when it is omitted.
<i>3131</i>&nbsp;         *
<i>3132</i>&nbsp;         * &lt;p&gt;Unlike a weighted list, language ranges in a prioritized list
<i>3133</i>&nbsp;         * are sorted in the descending order based on its priority. The first
<i>3134</i>&nbsp;         * language range has the highest priority and meets the user&#39;s
<i>3135</i>&nbsp;         * preference most.
<i>3136</i>&nbsp;         *
<i>3137</i>&nbsp;         * &lt;p&gt;In either case, language ranges are sorted in descending order in
<b class="nc"><i>3138</i>&nbsp;         * the Language Priority List based on priority or weight. If a</b>
<b class="nc"><i>3139</i>&nbsp;         * language range appears in the given {@code ranges} more than once,</b>
<i>3140</i>&nbsp;         * only the first one is included on the Language Priority List.
<b class="nc"><i>3141</i>&nbsp;         *</b>
<b class="nc"><i>3142</i>&nbsp;         * &lt;p&gt;The returned list consists of language ranges from the given</b>
<i>3143</i>&nbsp;         * {@code ranges} and their equivalents found in the IANA Language
<b class="nc"><i>3144</i>&nbsp;         * Subtag Registry. For example, if the given {@code ranges} is</b>
<b class="nc"><i>3145</i>&nbsp;         * {@code &quot;Accept-Language: iw,en-us;q=0.7,en;q=0.3&quot;}, the elements in</b>
<b class="nc"><i>3146</i>&nbsp;         * the list to be returned are:</b>
<i>3147</i>&nbsp;         *
<i>3148</i>&nbsp;         * &lt;pre&gt;
<i>3149</i>&nbsp;         *  &lt;b&gt;Range&lt;/b&gt;                                   &lt;b&gt;Weight&lt;/b&gt;
<i>3150</i>&nbsp;         *    &quot;iw&quot; (older tag for Hebrew)             1.0
<i>3151</i>&nbsp;         *    &quot;he&quot; (new preferred code for Hebrew)    1.0
<i>3152</i>&nbsp;         *    &quot;en-us&quot; (English, United States)        0.7
<i>3153</i>&nbsp;         *    &quot;en&quot; (English)                          0.3
<i>3154</i>&nbsp;         * &lt;/pre&gt;
<i>3155</i>&nbsp;         *
<i>3156</i>&nbsp;         * Two language ranges, {@code &quot;iw&quot;} and {@code &quot;he&quot;}, have the same
<i>3157</i>&nbsp;         * highest priority in the list. By adding {@code &quot;he&quot;} to the user&#39;s
<i>3158</i>&nbsp;         * Language Priority List, locale-matching method can find Hebrew as a
<i>3159</i>&nbsp;         * matching locale (or language tag) even if the application or system
<i>3160</i>&nbsp;         * offers only {@code &quot;he&quot;} as a supported locale (or language tag).
<i>3161</i>&nbsp;         *
<i>3162</i>&nbsp;         * @param ranges a list of comma-separated language ranges or a list of
<i>3163</i>&nbsp;         *     language ranges in the form of the &quot;Accept-Language&quot; header
<i>3164</i>&nbsp;         *     defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC
<i>3165</i>&nbsp;         *     2616&lt;/a&gt;
<i>3166</i>&nbsp;         * @return a Language Priority List consisting of language ranges
<i>3167</i>&nbsp;         *     included in the given {@code ranges} and their equivalent
<i>3168</i>&nbsp;         *     language ranges if available. The list is modifiable.
<i>3169</i>&nbsp;         * @throws NullPointerException if {@code ranges} is null
<i>3170</i>&nbsp;         * @throws IllegalArgumentException if a language range or a weight
<i>3171</i>&nbsp;         *     found in the given {@code ranges} is ill-formed
<i>3172</i>&nbsp;         */
<b class="nc"><i>3173</i>&nbsp;        public static List&lt;LanguageRange&gt; parse(String ranges) {</b>
<i>3174</i>&nbsp;            return LocaleMatcher.parse(ranges);
<i>3175</i>&nbsp;        }
<i>3176</i>&nbsp;
<i>3177</i>&nbsp;        /**
<i>3178</i>&nbsp;         * Parses the given {@code ranges} to generate a Language Priority
<i>3179</i>&nbsp;         * List, and then customizes the list using the given {@code map}.
<i>3180</i>&nbsp;         * This method is equivalent to
<i>3181</i>&nbsp;         * {@code mapEquivalents(parse(ranges), map)}.
<i>3182</i>&nbsp;         *
<i>3183</i>&nbsp;         * @param ranges a list of comma-separated language ranges or a list
<i>3184</i>&nbsp;         *     of language ranges in the form of the &quot;Accept-Language&quot; header
<i>3185</i>&nbsp;         *     defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC
<i>3186</i>&nbsp;         *     2616&lt;/a&gt;
<i>3187</i>&nbsp;         * @param map a map containing information to customize language ranges
<i>3188</i>&nbsp;         * @return a Language Priority List with customization. The list is
<i>3189</i>&nbsp;         *     modifiable.
<i>3190</i>&nbsp;         * @throws NullPointerException if {@code ranges} is null
<i>3191</i>&nbsp;         * @throws IllegalArgumentException if a language range or a weight
<i>3192</i>&nbsp;         *     found in the given {@code ranges} is ill-formed
<i>3193</i>&nbsp;         * @see #parse(String)
<i>3194</i>&nbsp;         * @see #mapEquivalents
<b class="nc"><i>3195</i>&nbsp;         */</b>
<i>3196</i>&nbsp;        public static List&lt;LanguageRange&gt; parse(String ranges,
<i>3197</i>&nbsp;                                                Map&lt;String, List&lt;String&gt;&gt; map) {
<i>3198</i>&nbsp;            return mapEquivalents(parse(ranges), map);
<i>3199</i>&nbsp;        }
<i>3200</i>&nbsp;
<i>3201</i>&nbsp;        /**
<i>3202</i>&nbsp;         * Generates a new customized Language Priority List using the given
<i>3203</i>&nbsp;         * {@code priorityList} and {@code map}. If the given {@code map} is
<i>3204</i>&nbsp;         * empty, this method returns a copy of the given {@code priorityList}.
<i>3205</i>&nbsp;         *
<i>3206</i>&nbsp;         * &lt;p&gt;In the map, a key represents a language range whereas a value is
<i>3207</i>&nbsp;         * a list of equivalents of it. {@code &#39;*&#39;} cannot be used in the map.
<i>3208</i>&nbsp;         * Each equivalent language range has the same weight value as its
<i>3209</i>&nbsp;         * original language range.
<i>3210</i>&nbsp;         *
<i>3211</i>&nbsp;         * &lt;pre&gt;
<i>3212</i>&nbsp;         *  An example of map:
<i>3213</i>&nbsp;         *    &lt;b&gt;Key&lt;/b&gt;                            &lt;b&gt;Value&lt;/b&gt;
<i>3214</i>&nbsp;         *      &quot;zh&quot; (Chinese)                 &quot;zh&quot;,
<i>3215</i>&nbsp;         *                                     &quot;zh-Hans&quot;(Simplified Chinese)
<i>3216</i>&nbsp;         *      &quot;zh-HK&quot; (Chinese, Hong Kong)   &quot;zh-HK&quot;
<i>3217</i>&nbsp;         *      &quot;zh-TW&quot; (Chinese, Taiwan)      &quot;zh-TW&quot;
<i>3218</i>&nbsp;         * &lt;/pre&gt;
<i>3219</i>&nbsp;         *
<b class="nc"><i>3220</i>&nbsp;         * The customization is performed after modification using the IANA</b>
<i>3221</i>&nbsp;         * Language Subtag Registry.
<i>3222</i>&nbsp;         *
<i>3223</i>&nbsp;         * &lt;p&gt;For example, if a user&#39;s Language Priority List consists of five
<i>3224</i>&nbsp;         * language ranges ({@code &quot;zh&quot;}, {@code &quot;zh-CN&quot;}, {@code &quot;en&quot;},
<i>3225</i>&nbsp;         * {@code &quot;zh-TW&quot;}, and {@code &quot;zh-HK&quot;}), the newly generated Language
<i>3226</i>&nbsp;         * Priority List which is customized using the above map example will
<i>3227</i>&nbsp;         * consists of {@code &quot;zh&quot;}, {@code &quot;zh-Hans&quot;}, {@code &quot;zh-CN&quot;},
<i>3228</i>&nbsp;         * {@code &quot;zh-Hans-CN&quot;}, {@code &quot;en&quot;}, {@code &quot;zh-TW&quot;}, and
<i>3229</i>&nbsp;         * {@code &quot;zh-HK&quot;}.
<i>3230</i>&nbsp;         *
<i>3231</i>&nbsp;         * &lt;p&gt;{@code &quot;zh-HK&quot;} and {@code &quot;zh-TW&quot;} aren&#39;t converted to
<i>3232</i>&nbsp;         * {@code &quot;zh-Hans-HK&quot;} nor {@code &quot;zh-Hans-TW&quot;} even if they are
<i>3233</i>&nbsp;         * included in the Language Priority List. In this example, mapping
<i>3234</i>&nbsp;         * is used to clearly distinguish Simplified Chinese and Traditional
<i>3235</i>&nbsp;         * Chinese.
<i>3236</i>&nbsp;         *
<i>3237</i>&nbsp;         * &lt;p&gt;If the {@code &quot;zh&quot;}-to-{@code &quot;zh&quot;} mapping isn&#39;t included in the
<i>3238</i>&nbsp;         * map, a simple replacement will be performed and the customized list
<i>3239</i>&nbsp;         * won&#39;t include {@code &quot;zh&quot;} and {@code &quot;zh-CN&quot;}.
<i>3240</i>&nbsp;         *
<i>3241</i>&nbsp;         * @param priorityList user&#39;s Language Priority List
<b class="nc"><i>3242</i>&nbsp;         * @param map a map containing information to customize language ranges</b>
<i>3243</i>&nbsp;         * @return a new Language Priority List with customization. The list is
<i>3244</i>&nbsp;         *     modifiable.
<i>3245</i>&nbsp;         * @throws NullPointerException if {@code priorityList} is {@code null}
<i>3246</i>&nbsp;         * @see #parse(String, Map)
<i>3247</i>&nbsp;         */
<i>3248</i>&nbsp;        public static List&lt;LanguageRange&gt; mapEquivalents(
<i>3249</i>&nbsp;                                              List&lt;LanguageRange&gt;priorityList,
<i>3250</i>&nbsp;                                              Map&lt;String, List&lt;String&gt;&gt; map) {
<i>3251</i>&nbsp;            return LocaleMatcher.mapEquivalents(priorityList, map);
<i>3252</i>&nbsp;        }
<i>3253</i>&nbsp;
<i>3254</i>&nbsp;        /**
<i>3255</i>&nbsp;         * Returns a hash code value for the object.
<i>3256</i>&nbsp;         *
<i>3257</i>&nbsp;         * @return  a hash code value for this object.
<i>3258</i>&nbsp;         */
<i>3259</i>&nbsp;        @Override
<i>3260</i>&nbsp;        public int hashCode() {
<b class="nc"><i>3261</i>&nbsp;            int h = hash;</b>
<i>3262</i>&nbsp;            if (h == 0) {
<i>3263</i>&nbsp;                h = 17;
<i>3264</i>&nbsp;                h = 37*h + range.hashCode();
<i>3265</i>&nbsp;                long bitsWeight = Double.doubleToLongBits(weight);
<i>3266</i>&nbsp;                h = 37*h + (int)(bitsWeight ^ (bitsWeight &gt;&gt;&gt; 32));
<i>3267</i>&nbsp;                if (h != 0) {
<i>3268</i>&nbsp;                    hash = h;
<i>3269</i>&nbsp;                }
<i>3270</i>&nbsp;            }
<i>3271</i>&nbsp;            return h;
<i>3272</i>&nbsp;        }
<i>3273</i>&nbsp;
<i>3274</i>&nbsp;        /**
<i>3275</i>&nbsp;         * Compares this object to the specified object. The result is true if
<i>3276</i>&nbsp;         * and only if the argument is not {@code null} and is a
<i>3277</i>&nbsp;         * {@code LanguageRange} object that contains the same {@code range}
<i>3278</i>&nbsp;         * and {@code weight} values as this object.
<i>3279</i>&nbsp;         *
<b class="nc"><i>3280</i>&nbsp;         * @param obj the object to compare with</b>
<i>3281</i>&nbsp;         * @return  {@code true} if this object&#39;s {@code range} and
<i>3282</i>&nbsp;         *     {@code weight} are the same as the {@code obj}&#39;s; {@code false}
<i>3283</i>&nbsp;         *     otherwise.
<i>3284</i>&nbsp;         */
<i>3285</i>&nbsp;        @Override
<i>3286</i>&nbsp;        public boolean equals(Object obj) {
<i>3287</i>&nbsp;            if (this == obj) {
<i>3288</i>&nbsp;                return true;
<i>3289</i>&nbsp;            }
<i>3290</i>&nbsp;            if (!(obj instanceof LanguageRange)) {
<i>3291</i>&nbsp;                return false;
<i>3292</i>&nbsp;            }
<i>3293</i>&nbsp;            LanguageRange other = (LanguageRange)obj;
<i>3294</i>&nbsp;            return hash == other.hash
<i>3295</i>&nbsp;                   &amp;&amp; range.equals(other.range)
<i>3296</i>&nbsp;                   &amp;&amp; weight == other.weight;
<i>3297</i>&nbsp;        }
<i>3298</i>&nbsp;
<i>3299</i>&nbsp;        /**
<i>3300</i>&nbsp;         * Returns an informative string representation of this {@code LanguageRange}
<i>3301</i>&nbsp;         * object, consisting of language range and weight if the range is
<i>3302</i>&nbsp;         * weighted and the weight is less than the max weight.
<i>3303</i>&nbsp;         *
<i>3304</i>&nbsp;         * @return a string representation of this {@code LanguageRange} object.
<i>3305</i>&nbsp;         */
<i>3306</i>&nbsp;        @Override
<i>3307</i>&nbsp;        public String toString() {
<i>3308</i>&nbsp;            return (weight == MAX_WEIGHT) ? range : range + &quot;;q=&quot; + weight;
<i>3309</i>&nbsp;        }
<i>3310</i>&nbsp;    }
<i>3311</i>&nbsp;
<i>3312</i>&nbsp;    /**
<i>3313</i>&nbsp;     * Returns a list of matching {@code Locale} instances using the filtering
<i>3314</i>&nbsp;     * mechanism defined in RFC 4647.
<i>3315</i>&nbsp;     *
<i>3316</i>&nbsp;     * This filter operation on the given {@code locales} ensures that only
<i>3317</i>&nbsp;     * unique matching locale(s) are returned.
<i>3318</i>&nbsp;     *
<i>3319</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3320</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3321</i>&nbsp;     * @param locales {@code Locale} instances used for matching
<i>3322</i>&nbsp;     * @param mode filtering mode
<i>3323</i>&nbsp;     * @return a list of {@code Locale} instances for matching language tags
<i>3324</i>&nbsp;     *     sorted in descending order based on priority or weight, or an empty
<i>3325</i>&nbsp;     *     list if nothing matches. The list is modifiable.
<i>3326</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code locales}
<i>3327</i>&nbsp;     *     is {@code null}
<i>3328</i>&nbsp;     * @throws IllegalArgumentException if one or more extended language ranges
<i>3329</i>&nbsp;     *     are included in the given list when
<i>3330</i>&nbsp;     *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
<i>3331</i>&nbsp;     *
<i>3332</i>&nbsp;     * @since 1.8
<i>3333</i>&nbsp;     */
<i>3334</i>&nbsp;    public static List&lt;Locale&gt; filter(List&lt;LanguageRange&gt; priorityList,
<i>3335</i>&nbsp;                                      Collection&lt;Locale&gt; locales,
<i>3336</i>&nbsp;                                      FilteringMode mode) {
<i>3337</i>&nbsp;        return LocaleMatcher.filter(priorityList, locales, mode);
<i>3338</i>&nbsp;    }
<i>3339</i>&nbsp;
<i>3340</i>&nbsp;    /**
<i>3341</i>&nbsp;     * Returns a list of matching {@code Locale} instances using the filtering
<i>3342</i>&nbsp;     * mechanism defined in RFC 4647. This is equivalent to
<i>3343</i>&nbsp;     * {@link #filter(List, Collection, FilteringMode)} when {@code mode} is
<i>3344</i>&nbsp;     * {@link FilteringMode#AUTOSELECT_FILTERING}.
<i>3345</i>&nbsp;     *
<i>3346</i>&nbsp;     * This filter operation on the given {@code locales} ensures that only
<i>3347</i>&nbsp;     * unique matching locale(s) are returned.
<i>3348</i>&nbsp;     *
<i>3349</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3350</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3351</i>&nbsp;     * @param locales {@code Locale} instances used for matching
<i>3352</i>&nbsp;     * @return a list of {@code Locale} instances for matching language tags
<i>3353</i>&nbsp;     *     sorted in descending order based on priority or weight, or an empty
<i>3354</i>&nbsp;     *     list if nothing matches. The list is modifiable.
<i>3355</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code locales}
<i>3356</i>&nbsp;     *     is {@code null}
<i>3357</i>&nbsp;     *
<i>3358</i>&nbsp;     * @since 1.8
<i>3359</i>&nbsp;     */
<i>3360</i>&nbsp;    public static List&lt;Locale&gt; filter(List&lt;LanguageRange&gt; priorityList,
<i>3361</i>&nbsp;                                      Collection&lt;Locale&gt; locales) {
<i>3362</i>&nbsp;        return filter(priorityList, locales, FilteringMode.AUTOSELECT_FILTERING);
<i>3363</i>&nbsp;    }
<i>3364</i>&nbsp;
<i>3365</i>&nbsp;    /**
<i>3366</i>&nbsp;     * Returns a list of matching languages tags using the basic filtering
<i>3367</i>&nbsp;     * mechanism defined in RFC 4647.
<i>3368</i>&nbsp;     *
<i>3369</i>&nbsp;     * This filter operation on the given {@code tags} ensures that only
<i>3370</i>&nbsp;     * unique matching tag(s) are returned with preserved case. In case of
<i>3371</i>&nbsp;     * duplicate matching tags with the case difference, the first matching
<i>3372</i>&nbsp;     * tag with preserved case is returned.
<i>3373</i>&nbsp;     * For example, &quot;de-ch&quot; is returned out of the duplicate matching tags
<i>3374</i>&nbsp;     * &quot;de-ch&quot; and &quot;de-CH&quot;, if &quot;de-ch&quot; is checked first for matching in the
<i>3375</i>&nbsp;     * given {@code tags}. Note that if the given {@code tags} is an unordered
<i>3376</i>&nbsp;     * {@code Collection}, the returned matching tag out of duplicate tags is
<i>3377</i>&nbsp;     * subject to change, depending on the implementation of the
<i>3378</i>&nbsp;     * {@code Collection}.
<i>3379</i>&nbsp;     *
<i>3380</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3381</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3382</i>&nbsp;     * @param tags language tags
<i>3383</i>&nbsp;     * @param mode filtering mode
<i>3384</i>&nbsp;     * @return a list of matching language tags sorted in descending order
<i>3385</i>&nbsp;     *     based on priority or weight, or an empty list if nothing matches.
<i>3386</i>&nbsp;     *     The list is modifiable.
<i>3387</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code tags} is
<i>3388</i>&nbsp;     *     {@code null}
<i>3389</i>&nbsp;     * @throws IllegalArgumentException if one or more extended language ranges
<i>3390</i>&nbsp;     *     are included in the given list when
<i>3391</i>&nbsp;     *     {@link FilteringMode#REJECT_EXTENDED_RANGES} is specified
<i>3392</i>&nbsp;     *
<i>3393</i>&nbsp;     * @since 1.8
<i>3394</i>&nbsp;     */
<i>3395</i>&nbsp;    public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
<i>3396</i>&nbsp;                                          Collection&lt;String&gt; tags,
<i>3397</i>&nbsp;                                          FilteringMode mode) {
<i>3398</i>&nbsp;        return LocaleMatcher.filterTags(priorityList, tags, mode);
<i>3399</i>&nbsp;    }
<i>3400</i>&nbsp;
<i>3401</i>&nbsp;    /**
<i>3402</i>&nbsp;     * Returns a list of matching languages tags using the basic filtering
<i>3403</i>&nbsp;     * mechanism defined in RFC 4647. This is equivalent to
<i>3404</i>&nbsp;     * {@link #filterTags(List, Collection, FilteringMode)} when {@code mode}
<i>3405</i>&nbsp;     * is {@link FilteringMode#AUTOSELECT_FILTERING}.
<i>3406</i>&nbsp;     *
<i>3407</i>&nbsp;     * This filter operation on the given {@code tags} ensures that only
<i>3408</i>&nbsp;     * unique matching tag(s) are returned with preserved case. In case of
<i>3409</i>&nbsp;     * duplicate matching tags with the case difference, the first matching
<i>3410</i>&nbsp;     * tag with preserved case is returned.
<i>3411</i>&nbsp;     * For example, &quot;de-ch&quot; is returned out of the duplicate matching tags
<i>3412</i>&nbsp;     * &quot;de-ch&quot; and &quot;de-CH&quot;, if &quot;de-ch&quot; is checked first for matching in the
<i>3413</i>&nbsp;     * given {@code tags}. Note that if the given {@code tags} is an unordered
<i>3414</i>&nbsp;     * {@code Collection}, the returned matching tag out of duplicate tags is
<i>3415</i>&nbsp;     * subject to change, depending on the implementation of the
<i>3416</i>&nbsp;     * {@code Collection}.
<i>3417</i>&nbsp;     *
<i>3418</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3419</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3420</i>&nbsp;     * @param tags language tags
<i>3421</i>&nbsp;     * @return a list of matching language tags sorted in descending order
<i>3422</i>&nbsp;     *     based on priority or weight, or an empty list if nothing matches.
<i>3423</i>&nbsp;     *     The list is modifiable.
<i>3424</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code tags} is
<i>3425</i>&nbsp;     *     {@code null}
<i>3426</i>&nbsp;     *
<i>3427</i>&nbsp;     * @since 1.8
<i>3428</i>&nbsp;     */
<i>3429</i>&nbsp;    public static List&lt;String&gt; filterTags(List&lt;LanguageRange&gt; priorityList,
<i>3430</i>&nbsp;                                          Collection&lt;String&gt; tags) {
<i>3431</i>&nbsp;        return filterTags(priorityList, tags, FilteringMode.AUTOSELECT_FILTERING);
<i>3432</i>&nbsp;    }
<i>3433</i>&nbsp;
<i>3434</i>&nbsp;    /**
<i>3435</i>&nbsp;     * Returns a {@code Locale} instance for the best-matching language
<i>3436</i>&nbsp;     * tag using the lookup mechanism defined in RFC 4647.
<i>3437</i>&nbsp;     *
<i>3438</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3439</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3440</i>&nbsp;     * @param locales {@code Locale} instances used for matching
<i>3441</i>&nbsp;     * @return the best matching &lt;code&gt;Locale&lt;/code&gt; instance chosen based on
<i>3442</i>&nbsp;     *     priority or weight, or {@code null} if nothing matches.
<i>3443</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code tags} is
<i>3444</i>&nbsp;     *     {@code null}
<i>3445</i>&nbsp;     *
<i>3446</i>&nbsp;     * @since 1.8
<i>3447</i>&nbsp;     */
<i>3448</i>&nbsp;    public static Locale lookup(List&lt;LanguageRange&gt; priorityList,
<i>3449</i>&nbsp;                                Collection&lt;Locale&gt; locales) {
<i>3450</i>&nbsp;        return LocaleMatcher.lookup(priorityList, locales);
<i>3451</i>&nbsp;    }
<i>3452</i>&nbsp;
<i>3453</i>&nbsp;    /**
<i>3454</i>&nbsp;     * Returns the best-matching language tag using the lookup mechanism
<i>3455</i>&nbsp;     * defined in RFC 4647.
<i>3456</i>&nbsp;     *
<i>3457</i>&nbsp;     * This lookup operation on the given {@code tags} ensures that the
<i>3458</i>&nbsp;     * first matching tag with preserved case is returned.
<i>3459</i>&nbsp;     *
<i>3460</i>&nbsp;     * @param priorityList user&#39;s Language Priority List in which each language
<i>3461</i>&nbsp;     *     tag is sorted in descending order based on priority or weight
<i>3462</i>&nbsp;     * @param tags language tangs used for matching
<i>3463</i>&nbsp;     * @return the best matching language tag chosen based on priority or
<i>3464</i>&nbsp;     *     weight, or {@code null} if nothing matches.
<i>3465</i>&nbsp;     * @throws NullPointerException if {@code priorityList} or {@code tags} is
<i>3466</i>&nbsp;     *     {@code null}
<i>3467</i>&nbsp;     *
<i>3468</i>&nbsp;     * @since 1.8
<i>3469</i>&nbsp;     */
<i>3470</i>&nbsp;    public static String lookupTag(List&lt;LanguageRange&gt; priorityList,
<i>3471</i>&nbsp;                                   Collection&lt;String&gt; tags) {
<i>3472</i>&nbsp;        return LocaleMatcher.lookupTag(priorityList, tags);
<i>3473</i>&nbsp;    }
<i>3474</i>&nbsp;
<i>3475</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
