


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Calendar</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util</a> ]
</div>

<h1>Coverage Summary for Class: Calendar (java.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Calendar</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 81)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 477)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Calendar$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Calendar$AvailableCalendarTypes</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Calendar$Builder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 126)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Calendar$CalendarAccessControlContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 109)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 618)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * (C) Copyright Taligent, Inc. 1996-1998 - All Rights Reserved
<i>28</i>&nbsp; * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *   The original version of this source code and documentation is copyrighted
<i>31</i>&nbsp; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
<i>32</i>&nbsp; * materials are provided under terms of a License Agreement between Taligent
<i>33</i>&nbsp; * and Sun. This technology is protected by multiple US and International
<i>34</i>&nbsp; * patents. This notice and attribution to Taligent may not be removed.
<i>35</i>&nbsp; *   Taligent is a registered trademark of Taligent, Inc.
<i>36</i>&nbsp; *
<i>37</i>&nbsp; */
<i>38</i>&nbsp;
<i>39</i>&nbsp;package java.util;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import java.io.IOException;
<i>42</i>&nbsp;import java.io.ObjectInputStream;
<i>43</i>&nbsp;import java.io.ObjectOutputStream;
<i>44</i>&nbsp;import java.io.OptionalDataException;
<i>45</i>&nbsp;import java.io.Serializable;
<i>46</i>&nbsp;import java.security.AccessControlContext;
<i>47</i>&nbsp;import java.security.AccessController;
<i>48</i>&nbsp;import java.security.PermissionCollection;
<i>49</i>&nbsp;import java.security.PrivilegedActionException;
<i>50</i>&nbsp;import java.security.PrivilegedExceptionAction;
<i>51</i>&nbsp;import java.security.ProtectionDomain;
<i>52</i>&nbsp;import java.text.DateFormat;
<i>53</i>&nbsp;import java.text.DateFormatSymbols;
<i>54</i>&nbsp;import java.time.Instant;
<i>55</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>56</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>57</i>&nbsp;import sun.util.BuddhistCalendar;
<i>58</i>&nbsp;import sun.util.calendar.ZoneInfo;
<i>59</i>&nbsp;import sun.util.locale.provider.CalendarDataUtility;
<i>60</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>61</i>&nbsp;import sun.util.locale.provider.TimeZoneNameUtility;
<i>62</i>&nbsp;import sun.util.spi.CalendarProvider;
<i>63</i>&nbsp;
<i>64</i>&nbsp;/**
<i>65</i>&nbsp; * The &lt;code&gt;Calendar&lt;/code&gt; class is an abstract class that provides methods
<i>66</i>&nbsp; * for converting between a specific instant in time and a set of {@link
<i>67</i>&nbsp; * #fields calendar fields} such as &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,
<i>68</i>&nbsp; * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR&lt;/code&gt;, and so on, and for
<i>69</i>&nbsp; * manipulating the calendar fields, such as getting the date of the next
<i>70</i>&nbsp; * week. An instant in time can be represented by a millisecond value that is
<i>71</i>&nbsp; * an offset from the &lt;a id=&quot;Epoch&quot;&gt;&lt;em&gt;Epoch&lt;/em&gt;&lt;/a&gt;, January 1, 1970
<i>72</i>&nbsp; * 00:00:00.000 GMT (Gregorian).
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * &lt;p&gt;The class also provides additional fields and methods for
<i>75</i>&nbsp; * implementing a concrete calendar system outside the package. Those
<i>76</i>&nbsp; * fields and methods are defined as &lt;code&gt;protected&lt;/code&gt;.
<i>77</i>&nbsp; *
<i>78</i>&nbsp; * &lt;p&gt;
<i>79</i>&nbsp; * Like other locale-sensitive classes, &lt;code&gt;Calendar&lt;/code&gt; provides a
<i>80</i>&nbsp; * class method, &lt;code&gt;getInstance&lt;/code&gt;, for getting a generally useful
<i>81</i>&nbsp; * object of this type. &lt;code&gt;Calendar&lt;/code&gt;&#39;s &lt;code&gt;getInstance&lt;/code&gt; method
<i>82</i>&nbsp; * returns a &lt;code&gt;Calendar&lt;/code&gt; object whose
<i>83</i>&nbsp; * calendar fields have been initialized with the current date and time:
<i>84</i>&nbsp; * &lt;blockquote&gt;
<i>85</i>&nbsp; * &lt;pre&gt;
<i>86</i>&nbsp; *     Calendar rightNow = Calendar.getInstance();
<i>87</i>&nbsp; * &lt;/pre&gt;
<i>88</i>&nbsp; * &lt;/blockquote&gt;
<i>89</i>&nbsp; *
<i>90</i>&nbsp; * &lt;p&gt;A &lt;code&gt;Calendar&lt;/code&gt; object can produce all the calendar field values
<i>91</i>&nbsp; * needed to implement the date-time formatting for a particular language and
<i>92</i>&nbsp; * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).
<i>93</i>&nbsp; * &lt;code&gt;Calendar&lt;/code&gt; defines the range of values returned by
<i>94</i>&nbsp; * certain calendar fields, as well as their meaning.  For example,
<i>95</i>&nbsp; * the first month of the calendar system has value &lt;code&gt;MONTH ==
<i>96</i>&nbsp; * JANUARY&lt;/code&gt; for all calendars.  Other values are defined by the
<i>97</i>&nbsp; * concrete subclass, such as &lt;code&gt;ERA&lt;/code&gt;.  See individual field
<i>98</i>&nbsp; * documentation and subclass documentation for details.
<i>99</i>&nbsp; *
<i>100</i>&nbsp; * &lt;h3&gt;Getting and Setting Calendar Field Values&lt;/h3&gt;
<i>101</i>&nbsp; *
<i>102</i>&nbsp; * &lt;p&gt;The calendar field values can be set by calling the &lt;code&gt;set&lt;/code&gt;
<i>103</i>&nbsp; * methods. Any field values set in a &lt;code&gt;Calendar&lt;/code&gt; will not be
<i>104</i>&nbsp; * interpreted until it needs to calculate its time value (milliseconds from
<i>105</i>&nbsp; * the Epoch) or values of the calendar fields. Calling the
<i>106</i>&nbsp; * &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;getTimeInMillis&lt;/code&gt;, &lt;code&gt;getTime&lt;/code&gt;,
<i>107</i>&nbsp; * &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;roll&lt;/code&gt; involves such calculation.
<i>108</i>&nbsp; *
<i>109</i>&nbsp; * &lt;h4&gt;Leniency&lt;/h4&gt;
<i>110</i>&nbsp; *
<i>111</i>&nbsp; * &lt;p&gt;&lt;code&gt;Calendar&lt;/code&gt; has two modes for interpreting the calendar
<i>112</i>&nbsp; * fields, &lt;em&gt;lenient&lt;/em&gt; and &lt;em&gt;non-lenient&lt;/em&gt;.  When a
<i>113</i>&nbsp; * &lt;code&gt;Calendar&lt;/code&gt; is in lenient mode, it accepts a wider range of
<i>114</i>&nbsp; * calendar field values than it produces.  When a &lt;code&gt;Calendar&lt;/code&gt;
<i>115</i>&nbsp; * recomputes calendar field values for return by &lt;code&gt;get()&lt;/code&gt;, all of
<i>116</i>&nbsp; * the calendar fields are normalized. For example, a lenient
<i>117</i>&nbsp; * &lt;code&gt;GregorianCalendar&lt;/code&gt; interprets &lt;code&gt;MONTH == JANUARY&lt;/code&gt;,
<i>118</i>&nbsp; * &lt;code&gt;DAY_OF_MONTH == 32&lt;/code&gt; as February 1.
<i>119</i>&nbsp;
<i>120</i>&nbsp; * &lt;p&gt;When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an
<i>121</i>&nbsp; * exception if there is any inconsistency in its calendar fields. For
<i>122</i>&nbsp; * example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces
<i>123</i>&nbsp; * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A
<i>124</i>&nbsp; * non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon
<i>125</i>&nbsp; * calculating its time or calendar field values if any out-of-range field
<i>126</i>&nbsp; * value has been set.
<i>127</i>&nbsp; *
<i>128</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;first_week&quot;&gt;First Week&lt;/a&gt;&lt;/h4&gt;
<i>129</i>&nbsp; *
<i>130</i>&nbsp; * &lt;code&gt;Calendar&lt;/code&gt; defines a locale-specific seven day week using two
<i>131</i>&nbsp; * parameters: the first day of the week and the minimal days in first week
<i>132</i>&nbsp; * (from 1 to 7).  These numbers are taken from the locale resource data or the
<i>133</i>&nbsp; * locale itself when a {@code Calendar} is constructed. If the designated
<i>134</i>&nbsp; * locale contains &quot;fw&quot; and/or &quot;rg&quot; &lt;a href=&quot;./Locale.html#def_locale_extension&quot;&gt;
<i>135</i>&nbsp; * Unicode extensions&lt;/a&gt;, the first day of the week will be obtained according to
<i>136</i>&nbsp; * those extensions. If both &quot;fw&quot; and &quot;rg&quot; are specified, the value from the &quot;fw&quot;
<i>137</i>&nbsp; * extension supersedes the implicit one from the &quot;rg&quot; extension.
<i>138</i>&nbsp; * They may also be specified explicitly through the methods for setting their
<i>139</i>&nbsp; * values.
<i>140</i>&nbsp; *
<i>141</i>&nbsp; * &lt;p&gt;When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or
<i>142</i>&nbsp; * &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the
<i>143</i>&nbsp; * first week of the month or year as a reference point.  The first week of a
<i>144</i>&nbsp; * month or year is defined as the earliest seven day period beginning on
<i>145</i>&nbsp; * &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least
<i>146</i>&nbsp; * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year.  Weeks
<i>147</i>&nbsp; * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
<i>148</i>&nbsp; * it.  Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be
<i>149</i>&nbsp; * different.  For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may
<i>150</i>&nbsp; * designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of
<i>151</i>&nbsp; * the previous year.
<i>152</i>&nbsp; *
<i>153</i>&nbsp; * &lt;h4&gt;Calendar Fields Resolution&lt;/h4&gt;
<i>154</i>&nbsp; *
<i>155</i>&nbsp; * When computing a date and time from the calendar fields, there
<i>156</i>&nbsp; * may be insufficient information for the computation (such as only
<i>157</i>&nbsp; * year and month with no day of month), or there may be inconsistent
<i>158</i>&nbsp; * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,
<i>159</i>&nbsp; * 1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve
<i>160</i>&nbsp; * calendar field values to determine the date and time in the
<i>161</i>&nbsp; * following way.
<i>162</i>&nbsp; *
<i>163</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;resolution&quot;&gt;If there is any conflict in calendar field values,
<i>164</i>&nbsp; * &lt;code&gt;Calendar&lt;/code&gt; gives priorities to calendar fields that have been set
<i>165</i>&nbsp; * more recently.&lt;/a&gt; The following are the default combinations of the
<i>166</i>&nbsp; * calendar fields. The most recent combination, as determined by the
<i>167</i>&nbsp; * most recently set single field, will be used.
<i>168</i>&nbsp; *
<i>169</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;date_resolution&quot;&gt;For the date fields&lt;/a&gt;:
<i>170</i>&nbsp; * &lt;blockquote&gt;
<i>171</i>&nbsp; * &lt;pre&gt;
<i>172</i>&nbsp; * YEAR + MONTH + DAY_OF_MONTH
<i>173</i>&nbsp; * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
<i>174</i>&nbsp; * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
<i>175</i>&nbsp; * YEAR + DAY_OF_YEAR
<i>176</i>&nbsp; * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR
<i>177</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>178</i>&nbsp; *
<i>179</i>&nbsp; * &lt;a id=&quot;time_resolution&quot;&gt;For the time of day fields&lt;/a&gt;:
<i>180</i>&nbsp; * &lt;blockquote&gt;
<i>181</i>&nbsp; * &lt;pre&gt;
<i>182</i>&nbsp; * HOUR_OF_DAY
<i>183</i>&nbsp; * AM_PM + HOUR
<i>184</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>185</i>&nbsp; *
<i>186</i>&nbsp; * &lt;p&gt;If there are any calendar fields whose values haven&#39;t been set in the selected
<i>187</i>&nbsp; * field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default
<i>188</i>&nbsp; * value of each field may vary by concrete calendar systems. For example, in
<i>189</i>&nbsp; * &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that
<i>190</i>&nbsp; * of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
<i>191</i>&nbsp; * JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.
<i>192</i>&nbsp; *
<i>193</i>&nbsp; * &lt;p&gt;
<i>194</i>&nbsp; * &lt;strong&gt;Note:&lt;/strong&gt; There are certain possible ambiguities in
<i>195</i>&nbsp; * interpretation of certain singular times, which are resolved in the
<i>196</i>&nbsp; * following ways:
<i>197</i>&nbsp; * &lt;ol&gt;
<i>198</i>&nbsp; *     &lt;li&gt; 23:59 is the last minute of the day and 00:00 is the first
<i>199</i>&nbsp; *          minute of the next day. Thus, 23:59 on Dec 31, 1999 &amp;lt; 00:00 on
<i>200</i>&nbsp; *          Jan 1, 2000 &amp;lt; 00:01 on Jan 1, 2000.
<i>201</i>&nbsp; *
<i>202</i>&nbsp; *     &lt;li&gt; Although historically not precise, midnight also belongs to &quot;am&quot;,
<i>203</i>&nbsp; *          and noon belongs to &quot;pm&quot;, so on the same day,
<i>204</i>&nbsp; *          12:00 am (midnight) &amp;lt; 12:01 am, and 12:00 pm (noon) &amp;lt; 12:01 pm
<i>205</i>&nbsp; * &lt;/ol&gt;
<i>206</i>&nbsp; *
<i>207</i>&nbsp; * &lt;p&gt;
<i>208</i>&nbsp; * The date or time format strings are not part of the definition of a
<i>209</i>&nbsp; * calendar, as those must be modifiable or overridable by the user at
<i>210</i>&nbsp; * runtime. Use {@link DateFormat}
<i>211</i>&nbsp; * to format dates.
<i>212</i>&nbsp; *
<i>213</i>&nbsp; * &lt;h4&gt;Field Manipulation&lt;/h4&gt;
<i>214</i>&nbsp; *
<i>215</i>&nbsp; * The calendar fields can be changed using three methods:
<i>216</i>&nbsp; * &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt;, and &lt;code&gt;roll()&lt;/code&gt;.
<i>217</i>&nbsp; *
<i>218</i>&nbsp; * &lt;p&gt;&lt;strong&gt;&lt;code&gt;set(f, value)&lt;/code&gt;&lt;/strong&gt; changes calendar field
<i>219</i>&nbsp; * &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;.  In addition, it sets an
<i>220</i>&nbsp; * internal member variable to indicate that calendar field &lt;code&gt;f&lt;/code&gt; has
<i>221</i>&nbsp; * been changed. Although calendar field &lt;code&gt;f&lt;/code&gt; is changed immediately,
<i>222</i>&nbsp; * the calendar&#39;s time value in milliseconds is not recomputed until the next call to
<i>223</i>&nbsp; * &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;getTime()&lt;/code&gt;, &lt;code&gt;getTimeInMillis()&lt;/code&gt;,
<i>224</i>&nbsp; * &lt;code&gt;add()&lt;/code&gt;, or &lt;code&gt;roll()&lt;/code&gt; is made. Thus, multiple calls to
<i>225</i>&nbsp; * &lt;code&gt;set()&lt;/code&gt; do not trigger multiple, unnecessary
<i>226</i>&nbsp; * computations. As a result of changing a calendar field using
<i>227</i>&nbsp; * &lt;code&gt;set()&lt;/code&gt;, other calendar fields may also change, depending on the
<i>228</i>&nbsp; * calendar field, the calendar field value, and the calendar system. In addition,
<i>229</i>&nbsp; * &lt;code&gt;get(f)&lt;/code&gt; will not necessarily return &lt;code&gt;value&lt;/code&gt; set by
<i>230</i>&nbsp; * the call to the &lt;code&gt;set&lt;/code&gt; method
<i>231</i>&nbsp; * after the calendar fields have been recomputed. The specifics are determined by
<i>232</i>&nbsp; * the concrete calendar class.&lt;/p&gt;
<i>233</i>&nbsp; *
<i>234</i>&nbsp; * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
<i>235</i>&nbsp; * originally set to August 31, 1999. Calling &lt;code&gt;set(Calendar.MONTH,
<i>236</i>&nbsp; * Calendar.SEPTEMBER)&lt;/code&gt; sets the date to September 31,
<i>237</i>&nbsp; * 1999. This is a temporary internal representation that resolves to
<i>238</i>&nbsp; * October 1, 1999 if &lt;code&gt;getTime()&lt;/code&gt;is then called. However, a
<i>239</i>&nbsp; * call to &lt;code&gt;set(Calendar.DAY_OF_MONTH, 30)&lt;/code&gt; before the call to
<i>240</i>&nbsp; * &lt;code&gt;getTime()&lt;/code&gt; sets the date to September 30, 1999, since
<i>241</i>&nbsp; * no recomputation occurs after &lt;code&gt;set()&lt;/code&gt; itself.&lt;/p&gt;
<i>242</i>&nbsp; *
<i>243</i>&nbsp; * &lt;p&gt;&lt;strong&gt;&lt;code&gt;add(f, delta)&lt;/code&gt;&lt;/strong&gt; adds &lt;code&gt;delta&lt;/code&gt;
<i>244</i>&nbsp; * to field &lt;code&gt;f&lt;/code&gt;.  This is equivalent to calling &lt;code&gt;set(f,
<i>245</i>&nbsp; * get(f) + delta)&lt;/code&gt; with two adjustments:&lt;/p&gt;
<i>246</i>&nbsp; *
<i>247</i>&nbsp; * &lt;blockquote&gt;
<i>248</i>&nbsp; *   &lt;p&gt;&lt;strong&gt;Add rule 1&lt;/strong&gt;. The value of field &lt;code&gt;f&lt;/code&gt;
<i>249</i>&nbsp; *   after the call minus the value of field &lt;code&gt;f&lt;/code&gt; before the
<i>250</i>&nbsp; *   call is &lt;code&gt;delta&lt;/code&gt;, modulo any overflow that has occurred in
<i>251</i>&nbsp; *   field &lt;code&gt;f&lt;/code&gt;. Overflow occurs when a field value exceeds its
<i>252</i>&nbsp; *   range and, as a result, the next larger field is incremented or
<i>253</i>&nbsp; *   decremented and the field value is adjusted back into its range.&lt;/p&gt;
<i>254</i>&nbsp; *
<i>255</i>&nbsp; *   &lt;p&gt;&lt;strong&gt;Add rule 2&lt;/strong&gt;. If a smaller field is expected to be
<i>256</i>&nbsp; *   invariant, but it is impossible for it to be equal to its
<i>257</i>&nbsp; *   prior value because of changes in its minimum or maximum after field
<i>258</i>&nbsp; *   &lt;code&gt;f&lt;/code&gt; is changed or other constraints, such as time zone
<i>259</i>&nbsp; *   offset changes, then its value is adjusted to be as close
<i>260</i>&nbsp; *   as possible to its expected value. A smaller field represents a
<i>261</i>&nbsp; *   smaller unit of time. &lt;code&gt;HOUR&lt;/code&gt; is a smaller field than
<i>262</i>&nbsp; *   &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;. No adjustment is made to smaller fields
<i>263</i>&nbsp; *   that are not expected to be invariant. The calendar system
<i>264</i>&nbsp; *   determines what fields are expected to be invariant.&lt;/p&gt;
<i>265</i>&nbsp; * &lt;/blockquote&gt;
<i>266</i>&nbsp; *
<i>267</i>&nbsp; * &lt;p&gt;In addition, unlike &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;add()&lt;/code&gt; forces
<i>268</i>&nbsp; * an immediate recomputation of the calendar&#39;s milliseconds and all
<i>269</i>&nbsp; * fields.&lt;/p&gt;
<i>270</i>&nbsp; *
<i>271</i>&nbsp; * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: Consider a &lt;code&gt;GregorianCalendar&lt;/code&gt;
<i>272</i>&nbsp; * originally set to August 31, 1999. Calling &lt;code&gt;add(Calendar.MONTH,
<i>273</i>&nbsp; * 13)&lt;/code&gt; sets the calendar to September 30, 2000. &lt;strong&gt;Add rule
<i>274</i>&nbsp; * 1&lt;/strong&gt; sets the &lt;code&gt;MONTH&lt;/code&gt; field to September, since
<i>275</i>&nbsp; * adding 13 months to August gives September of the next year. Since
<i>276</i>&nbsp; * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; cannot be 31 in September in a
<i>277</i>&nbsp; * &lt;code&gt;GregorianCalendar&lt;/code&gt;, &lt;strong&gt;add rule 2&lt;/strong&gt; sets the
<i>278</i>&nbsp; * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; to 30, the closest possible value. Although
<i>279</i>&nbsp; * it is a smaller field, &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; is not adjusted by
<i>280</i>&nbsp; * rule 2, since it is expected to change when the month changes in a
<i>281</i>&nbsp; * &lt;code&gt;GregorianCalendar&lt;/code&gt;.&lt;/p&gt;
<i>282</i>&nbsp; *
<i>283</i>&nbsp; * &lt;p&gt;&lt;strong&gt;&lt;code&gt;roll(f, delta)&lt;/code&gt;&lt;/strong&gt; adds
<i>284</i>&nbsp; * &lt;code&gt;delta&lt;/code&gt; to field &lt;code&gt;f&lt;/code&gt; without changing larger
<i>285</i>&nbsp; * fields. This is equivalent to calling &lt;code&gt;add(f, delta)&lt;/code&gt; with
<i>286</i>&nbsp; * the following adjustment:&lt;/p&gt;
<i>287</i>&nbsp; *
<i>288</i>&nbsp; * &lt;blockquote&gt;
<i>289</i>&nbsp; *   &lt;p&gt;&lt;strong&gt;Roll rule&lt;/strong&gt;. Larger fields are unchanged after the
<i>290</i>&nbsp; *   call. A larger field represents a larger unit of
<i>291</i>&nbsp; *   time. &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; is a larger field than
<i>292</i>&nbsp; *   &lt;code&gt;HOUR&lt;/code&gt;.&lt;/p&gt;
<i>293</i>&nbsp; * &lt;/blockquote&gt;
<i>294</i>&nbsp; *
<i>295</i>&nbsp; * &lt;p&gt;&lt;em&gt;Example&lt;/em&gt;: See {@link java.util.GregorianCalendar#roll(int, int)}.
<i>296</i>&nbsp; *
<i>297</i>&nbsp; * &lt;p&gt;&lt;strong&gt;Usage model&lt;/strong&gt;. To motivate the behavior of
<i>298</i>&nbsp; * &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;roll()&lt;/code&gt;, consider a user interface
<i>299</i>&nbsp; * component with increment and decrement buttons for the month, day, and
<i>300</i>&nbsp; * year, and an underlying &lt;code&gt;GregorianCalendar&lt;/code&gt;. If the
<i>301</i>&nbsp; * interface reads January 31, 1999 and the user presses the month
<i>302</i>&nbsp; * increment button, what should it read? If the underlying
<i>303</i>&nbsp; * implementation uses &lt;code&gt;set()&lt;/code&gt;, it might read March 3, 1999. A
<i>304</i>&nbsp; * better result would be February 28, 1999. Furthermore, if the user
<i>305</i>&nbsp; * presses the month increment button again, it should read March 31,
<i>306</i>&nbsp; * 1999, not March 28, 1999. By saving the original date and using either
<i>307</i>&nbsp; * &lt;code&gt;add()&lt;/code&gt; or &lt;code&gt;roll()&lt;/code&gt;, depending on whether larger
<i>308</i>&nbsp; * fields should be affected, the user interface can behave as most users
<i>309</i>&nbsp; * will intuitively expect.&lt;/p&gt;
<i>310</i>&nbsp; *
<i>311</i>&nbsp; * @see          java.lang.System#currentTimeMillis()
<i>312</i>&nbsp; * @see          Date
<b class="nc"><i>313</i>&nbsp; * @see          GregorianCalendar</b>
<i>314</i>&nbsp; * @see          TimeZone
<i>315</i>&nbsp; * @see          java.text.DateFormat
<i>316</i>&nbsp; * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu
<i>317</i>&nbsp; * @since 1.1
<i>318</i>&nbsp; */
<i>319</i>&nbsp;public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt; {
<i>320</i>&nbsp;
<i>321</i>&nbsp;    // Data flow in Calendar
<i>322</i>&nbsp;    // ---------------------
<i>323</i>&nbsp;
<i>324</i>&nbsp;    // The current time is represented in two ways by Calendar: as UTC
<i>325</i>&nbsp;    // milliseconds from the epoch (1 January 1970 0:00 UTC), and as local
<i>326</i>&nbsp;    // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the
<i>327</i>&nbsp;    // millis from the fields, and vice versa.  The data needed to do this
<i>328</i>&nbsp;    // conversion is encapsulated by a TimeZone object owned by the Calendar.
<i>329</i>&nbsp;    // The data provided by the TimeZone object may also be overridden if the
<i>330</i>&nbsp;    // user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class
<i>331</i>&nbsp;    // keeps track of what information was most recently set by the caller, and
<i>332</i>&nbsp;    // uses that to compute any other information as needed.
<i>333</i>&nbsp;
<i>334</i>&nbsp;    // If the user sets the fields using set(), the data flow is as follows.
<i>335</i>&nbsp;    // This is implemented by the Calendar subclass&#39;s computeTime() method.
<i>336</i>&nbsp;    // During this process, certain fields may be ignored.  The disambiguation
<i>337</i>&nbsp;    // algorithm for resolving which fields to pay attention to is described
<i>338</i>&nbsp;    // in the class documentation.
<i>339</i>&nbsp;
<i>340</i>&nbsp;    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
<i>341</i>&nbsp;    //           |
<i>342</i>&nbsp;    //           | Using Calendar-specific algorithm
<i>343</i>&nbsp;    //           V
<i>344</i>&nbsp;    //   local standard millis
<i>345</i>&nbsp;    //           |
<i>346</i>&nbsp;    //           | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET
<i>347</i>&nbsp;    //           V
<i>348</i>&nbsp;    //   UTC millis (in time data member)
<i>349</i>&nbsp;
<i>350</i>&nbsp;    // If the user sets the UTC millis using setTime() or setTimeInMillis(),
<i>351</i>&nbsp;    // the data flow is as follows.  This is implemented by the Calendar
<i>352</i>&nbsp;    // subclass&#39;s computeFields() method.
<i>353</i>&nbsp;
<i>354</i>&nbsp;    //   UTC millis (in time data member)
<i>355</i>&nbsp;    //           |
<i>356</i>&nbsp;    //           | Using TimeZone getOffset()
<i>357</i>&nbsp;    //           V
<i>358</i>&nbsp;    //   local standard millis
<i>359</i>&nbsp;    //           |
<i>360</i>&nbsp;    //           | Using Calendar-specific algorithm
<i>361</i>&nbsp;    //           V
<i>362</i>&nbsp;    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
<i>363</i>&nbsp;
<i>364</i>&nbsp;    // In general, a round trip from fields, through local and UTC millis, and
<i>365</i>&nbsp;    // back out to fields is made when necessary.  This is implemented by the
<i>366</i>&nbsp;    // complete() method.  Resolving a partial set of fields into a UTC millis
<i>367</i>&nbsp;    // value allows all remaining fields to be generated from that value.  If
<i>368</i>&nbsp;    // the Calendar is lenient, the fields are also renormalized to standard
<i>369</i>&nbsp;    // ranges when they are regenerated.
<i>370</i>&nbsp;
<i>371</i>&nbsp;    /**
<i>372</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>373</i>&nbsp;     * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
<i>374</i>&nbsp;     * value; see subclass documentation.
<i>375</i>&nbsp;     *
<i>376</i>&nbsp;     * @see GregorianCalendar#AD
<i>377</i>&nbsp;     * @see GregorianCalendar#BC
<i>378</i>&nbsp;     */
<i>379</i>&nbsp;    public static final int ERA = 0;
<i>380</i>&nbsp;
<i>381</i>&nbsp;    /**
<i>382</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>383</i>&nbsp;     * year. This is a calendar-specific value; see subclass documentation.
<i>384</i>&nbsp;     */
<i>385</i>&nbsp;    public static final int YEAR = 1;
<i>386</i>&nbsp;
<i>387</i>&nbsp;    /**
<i>388</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>389</i>&nbsp;     * month. This is a calendar-specific value. The first month of
<i>390</i>&nbsp;     * the year in the Gregorian and Julian calendars is
<i>391</i>&nbsp;     * &lt;code&gt;JANUARY&lt;/code&gt; which is 0; the last depends on the number
<i>392</i>&nbsp;     * of months in a year.
<i>393</i>&nbsp;     *
<i>394</i>&nbsp;     * @see #JANUARY
<i>395</i>&nbsp;     * @see #FEBRUARY
<i>396</i>&nbsp;     * @see #MARCH
<i>397</i>&nbsp;     * @see #APRIL
<i>398</i>&nbsp;     * @see #MAY
<i>399</i>&nbsp;     * @see #JUNE
<i>400</i>&nbsp;     * @see #JULY
<i>401</i>&nbsp;     * @see #AUGUST
<i>402</i>&nbsp;     * @see #SEPTEMBER
<i>403</i>&nbsp;     * @see #OCTOBER
<i>404</i>&nbsp;     * @see #NOVEMBER
<i>405</i>&nbsp;     * @see #DECEMBER
<i>406</i>&nbsp;     * @see #UNDECIMBER
<i>407</i>&nbsp;     */
<i>408</i>&nbsp;    public static final int MONTH = 2;
<i>409</i>&nbsp;
<i>410</i>&nbsp;    /**
<i>411</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>412</i>&nbsp;     * week number within the current year.  The first week of the year, as
<i>413</i>&nbsp;     * defined by &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and
<i>414</i>&nbsp;     * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;, has value 1.  Subclasses define
<i>415</i>&nbsp;     * the value of &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; for days before the first week of
<i>416</i>&nbsp;     * the year.
<i>417</i>&nbsp;     *
<i>418</i>&nbsp;     * @see #getFirstDayOfWeek
<i>419</i>&nbsp;     * @see #getMinimalDaysInFirstWeek
<i>420</i>&nbsp;     */
<i>421</i>&nbsp;    public static final int WEEK_OF_YEAR = 3;
<i>422</i>&nbsp;
<i>423</i>&nbsp;    /**
<i>424</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>425</i>&nbsp;     * week number within the current month.  The first week of the month, as
<i>426</i>&nbsp;     * defined by &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and
<i>427</i>&nbsp;     * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;, has value 1.  Subclasses define
<i>428</i>&nbsp;     * the value of &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; for days before the first week of
<i>429</i>&nbsp;     * the month.
<i>430</i>&nbsp;     *
<i>431</i>&nbsp;     * @see #getFirstDayOfWeek
<i>432</i>&nbsp;     * @see #getMinimalDaysInFirstWeek
<i>433</i>&nbsp;     */
<i>434</i>&nbsp;    public static final int WEEK_OF_MONTH = 4;
<i>435</i>&nbsp;
<i>436</i>&nbsp;    /**
<i>437</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>438</i>&nbsp;     * day of the month. This is a synonym for &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.
<i>439</i>&nbsp;     * The first day of the month has value 1.
<i>440</i>&nbsp;     *
<i>441</i>&nbsp;     * @see #DAY_OF_MONTH
<i>442</i>&nbsp;     */
<i>443</i>&nbsp;    public static final int DATE = 5;
<i>444</i>&nbsp;
<i>445</i>&nbsp;    /**
<i>446</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>447</i>&nbsp;     * day of the month. This is a synonym for &lt;code&gt;DATE&lt;/code&gt;.
<i>448</i>&nbsp;     * The first day of the month has value 1.
<i>449</i>&nbsp;     *
<i>450</i>&nbsp;     * @see #DATE
<i>451</i>&nbsp;     */
<i>452</i>&nbsp;    public static final int DAY_OF_MONTH = 5;
<i>453</i>&nbsp;
<i>454</i>&nbsp;    /**
<i>455</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day
<i>456</i>&nbsp;     * number within the current year.  The first day of the year has value 1.
<i>457</i>&nbsp;     */
<i>458</i>&nbsp;    public static final int DAY_OF_YEAR = 6;
<i>459</i>&nbsp;
<i>460</i>&nbsp;    /**
<i>461</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day
<i>462</i>&nbsp;     * of the week.  This field takes values &lt;code&gt;SUNDAY&lt;/code&gt;,
<i>463</i>&nbsp;     * &lt;code&gt;MONDAY&lt;/code&gt;, &lt;code&gt;TUESDAY&lt;/code&gt;, &lt;code&gt;WEDNESDAY&lt;/code&gt;,
<i>464</i>&nbsp;     * &lt;code&gt;THURSDAY&lt;/code&gt;, &lt;code&gt;FRIDAY&lt;/code&gt;, and &lt;code&gt;SATURDAY&lt;/code&gt;.
<i>465</i>&nbsp;     *
<i>466</i>&nbsp;     * @see #SUNDAY
<i>467</i>&nbsp;     * @see #MONDAY
<i>468</i>&nbsp;     * @see #TUESDAY
<i>469</i>&nbsp;     * @see #WEDNESDAY
<i>470</i>&nbsp;     * @see #THURSDAY
<i>471</i>&nbsp;     * @see #FRIDAY
<i>472</i>&nbsp;     * @see #SATURDAY
<i>473</i>&nbsp;     */
<i>474</i>&nbsp;    public static final int DAY_OF_WEEK = 7;
<i>475</i>&nbsp;
<i>476</i>&nbsp;    /**
<i>477</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>478</i>&nbsp;     * ordinal number of the day of the week within the current month. Together
<i>479</i>&nbsp;     * with the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; field, this uniquely specifies a day
<i>480</i>&nbsp;     * within a month.  Unlike &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; and
<i>481</i>&nbsp;     * &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt;, this field&#39;s value does &lt;em&gt;not&lt;/em&gt; depend on
<i>482</i>&nbsp;     * &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; or
<i>483</i>&nbsp;     * &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;.  &lt;code&gt;DAY_OF_MONTH 1&lt;/code&gt;
<i>484</i>&nbsp;     * through &lt;code&gt;7&lt;/code&gt; always correspond to &lt;code&gt;DAY_OF_WEEK_IN_MONTH
<i>485</i>&nbsp;     * 1&lt;/code&gt;; &lt;code&gt;8&lt;/code&gt; through &lt;code&gt;14&lt;/code&gt; correspond to
<i>486</i>&nbsp;     * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 2&lt;/code&gt;, and so on.
<i>487</i>&nbsp;     * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 0&lt;/code&gt; indicates the week before
<i>488</i>&nbsp;     * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 1&lt;/code&gt;.  Negative values count back from the
<i>489</i>&nbsp;     * end of the month, so the last Sunday of a month is specified as
<i>490</i>&nbsp;     * &lt;code&gt;DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1&lt;/code&gt;.  Because
<i>491</i>&nbsp;     * negative values count backward they will usually be aligned differently
<i>492</i>&nbsp;     * within the month than positive values.  For example, if a month has 31
<i>493</i>&nbsp;     * days, &lt;code&gt;DAY_OF_WEEK_IN_MONTH -1&lt;/code&gt; will overlap
<i>494</i>&nbsp;     * &lt;code&gt;DAY_OF_WEEK_IN_MONTH 5&lt;/code&gt; and the end of &lt;code&gt;4&lt;/code&gt;.
<i>495</i>&nbsp;     *
<i>496</i>&nbsp;     * @see #DAY_OF_WEEK
<i>497</i>&nbsp;     * @see #WEEK_OF_MONTH
<i>498</i>&nbsp;     */
<i>499</i>&nbsp;    public static final int DAY_OF_WEEK_IN_MONTH = 8;
<i>500</i>&nbsp;
<i>501</i>&nbsp;    /**
<i>502</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating
<i>503</i>&nbsp;     * whether the &lt;code&gt;HOUR&lt;/code&gt; is before or after noon.
<i>504</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;AM_PM&lt;/code&gt; is &lt;code&gt;PM&lt;/code&gt;.
<i>505</i>&nbsp;     *
<i>506</i>&nbsp;     * @see #AM
<i>507</i>&nbsp;     * @see #PM
<i>508</i>&nbsp;     * @see #HOUR
<i>509</i>&nbsp;     */
<i>510</i>&nbsp;    public static final int AM_PM = 9;
<i>511</i>&nbsp;
<i>512</i>&nbsp;    /**
<i>513</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>514</i>&nbsp;     * hour of the morning or afternoon. &lt;code&gt;HOUR&lt;/code&gt; is used for the
<i>515</i>&nbsp;     * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.
<i>516</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;HOUR&lt;/code&gt; is 10.
<i>517</i>&nbsp;     *
<i>518</i>&nbsp;     * @see #AM_PM
<i>519</i>&nbsp;     * @see #HOUR_OF_DAY
<i>520</i>&nbsp;     */
<i>521</i>&nbsp;    public static final int HOUR = 10;
<i>522</i>&nbsp;
<i>523</i>&nbsp;    /**
<i>524</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>525</i>&nbsp;     * hour of the day. &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; is used for the 24-hour clock.
<i>526</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; is 22.
<i>527</i>&nbsp;     *
<i>528</i>&nbsp;     * @see #HOUR
<i>529</i>&nbsp;     */
<i>530</i>&nbsp;    public static final int HOUR_OF_DAY = 11;
<i>531</i>&nbsp;
<i>532</i>&nbsp;    /**
<i>533</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>534</i>&nbsp;     * minute within the hour.
<i>535</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;MINUTE&lt;/code&gt; is 4.
<i>536</i>&nbsp;     */
<i>537</i>&nbsp;    public static final int MINUTE = 12;
<i>538</i>&nbsp;
<i>539</i>&nbsp;    /**
<i>540</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>541</i>&nbsp;     * second within the minute.
<i>542</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;SECOND&lt;/code&gt; is 15.
<i>543</i>&nbsp;     */
<i>544</i>&nbsp;    public static final int SECOND = 13;
<i>545</i>&nbsp;
<i>546</i>&nbsp;    /**
<i>547</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>548</i>&nbsp;     * millisecond within the second.
<i>549</i>&nbsp;     * E.g., at 10:04:15.250 PM the &lt;code&gt;MILLISECOND&lt;/code&gt; is 250.
<i>550</i>&nbsp;     */
<i>551</i>&nbsp;    public static final int MILLISECOND = 14;
<i>552</i>&nbsp;
<i>553</i>&nbsp;    /**
<i>554</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;
<i>555</i>&nbsp;     * indicating the raw offset from GMT in milliseconds.
<i>556</i>&nbsp;     * &lt;p&gt;
<i>557</i>&nbsp;     * This field reflects the correct GMT offset value of the time
<i>558</i>&nbsp;     * zone of this &lt;code&gt;Calendar&lt;/code&gt; if the
<i>559</i>&nbsp;     * &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports
<i>560</i>&nbsp;     * historical GMT offset changes.
<i>561</i>&nbsp;     */
<i>562</i>&nbsp;    public static final int ZONE_OFFSET = 15;
<i>563</i>&nbsp;
<i>564</i>&nbsp;    /**
<i>565</i>&nbsp;     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the
<i>566</i>&nbsp;     * daylight saving offset in milliseconds.
<i>567</i>&nbsp;     * &lt;p&gt;
<i>568</i>&nbsp;     * This field reflects the correct daylight saving offset value of
<i>569</i>&nbsp;     * the time zone of this &lt;code&gt;Calendar&lt;/code&gt; if the
<i>570</i>&nbsp;     * &lt;code&gt;TimeZone&lt;/code&gt; implementation subclass supports
<i>571</i>&nbsp;     * historical Daylight Saving Time schedule changes.
<i>572</i>&nbsp;     */
<i>573</i>&nbsp;    public static final int DST_OFFSET = 16;
<i>574</i>&nbsp;
<i>575</i>&nbsp;    /**
<i>576</i>&nbsp;     * The number of distinct fields recognized by &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.
<i>577</i>&nbsp;     * Field numbers range from &lt;code&gt;0..FIELD_COUNT-1&lt;/code&gt;.
<i>578</i>&nbsp;     */
<i>579</i>&nbsp;    public static final int FIELD_COUNT = 17;
<i>580</i>&nbsp;
<i>581</i>&nbsp;    /**
<i>582</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>583</i>&nbsp;     * Sunday.
<i>584</i>&nbsp;     */
<i>585</i>&nbsp;    public static final int SUNDAY = 1;
<i>586</i>&nbsp;
<i>587</i>&nbsp;    /**
<i>588</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>589</i>&nbsp;     * Monday.
<i>590</i>&nbsp;     */
<i>591</i>&nbsp;    public static final int MONDAY = 2;
<i>592</i>&nbsp;
<i>593</i>&nbsp;    /**
<i>594</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>595</i>&nbsp;     * Tuesday.
<i>596</i>&nbsp;     */
<i>597</i>&nbsp;    public static final int TUESDAY = 3;
<i>598</i>&nbsp;
<i>599</i>&nbsp;    /**
<i>600</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>601</i>&nbsp;     * Wednesday.
<i>602</i>&nbsp;     */
<i>603</i>&nbsp;    public static final int WEDNESDAY = 4;
<i>604</i>&nbsp;
<i>605</i>&nbsp;    /**
<i>606</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>607</i>&nbsp;     * Thursday.
<i>608</i>&nbsp;     */
<i>609</i>&nbsp;    public static final int THURSDAY = 5;
<i>610</i>&nbsp;
<i>611</i>&nbsp;    /**
<i>612</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>613</i>&nbsp;     * Friday.
<i>614</i>&nbsp;     */
<i>615</i>&nbsp;    public static final int FRIDAY = 6;
<i>616</i>&nbsp;
<i>617</i>&nbsp;    /**
<i>618</i>&nbsp;     * Value of the {@link #DAY_OF_WEEK} field indicating
<i>619</i>&nbsp;     * Saturday.
<i>620</i>&nbsp;     */
<i>621</i>&nbsp;    public static final int SATURDAY = 7;
<i>622</i>&nbsp;
<i>623</i>&nbsp;    /**
<i>624</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>625</i>&nbsp;     * first month of the year in the Gregorian and Julian calendars.
<i>626</i>&nbsp;     */
<i>627</i>&nbsp;    public static final int JANUARY = 0;
<i>628</i>&nbsp;
<i>629</i>&nbsp;    /**
<i>630</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>631</i>&nbsp;     * second month of the year in the Gregorian and Julian calendars.
<i>632</i>&nbsp;     */
<i>633</i>&nbsp;    public static final int FEBRUARY = 1;
<i>634</i>&nbsp;
<i>635</i>&nbsp;    /**
<i>636</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>637</i>&nbsp;     * third month of the year in the Gregorian and Julian calendars.
<i>638</i>&nbsp;     */
<i>639</i>&nbsp;    public static final int MARCH = 2;
<i>640</i>&nbsp;
<i>641</i>&nbsp;    /**
<i>642</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>643</i>&nbsp;     * fourth month of the year in the Gregorian and Julian calendars.
<i>644</i>&nbsp;     */
<i>645</i>&nbsp;    public static final int APRIL = 3;
<i>646</i>&nbsp;
<i>647</i>&nbsp;    /**
<i>648</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>649</i>&nbsp;     * fifth month of the year in the Gregorian and Julian calendars.
<i>650</i>&nbsp;     */
<i>651</i>&nbsp;    public static final int MAY = 4;
<i>652</i>&nbsp;
<i>653</i>&nbsp;    /**
<i>654</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>655</i>&nbsp;     * sixth month of the year in the Gregorian and Julian calendars.
<i>656</i>&nbsp;     */
<i>657</i>&nbsp;    public static final int JUNE = 5;
<i>658</i>&nbsp;
<i>659</i>&nbsp;    /**
<i>660</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>661</i>&nbsp;     * seventh month of the year in the Gregorian and Julian calendars.
<i>662</i>&nbsp;     */
<i>663</i>&nbsp;    public static final int JULY = 6;
<i>664</i>&nbsp;
<i>665</i>&nbsp;    /**
<i>666</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>667</i>&nbsp;     * eighth month of the year in the Gregorian and Julian calendars.
<i>668</i>&nbsp;     */
<i>669</i>&nbsp;    public static final int AUGUST = 7;
<i>670</i>&nbsp;
<i>671</i>&nbsp;    /**
<i>672</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>673</i>&nbsp;     * ninth month of the year in the Gregorian and Julian calendars.
<i>674</i>&nbsp;     */
<i>675</i>&nbsp;    public static final int SEPTEMBER = 8;
<i>676</i>&nbsp;
<i>677</i>&nbsp;    /**
<i>678</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>679</i>&nbsp;     * tenth month of the year in the Gregorian and Julian calendars.
<i>680</i>&nbsp;     */
<i>681</i>&nbsp;    public static final int OCTOBER = 9;
<i>682</i>&nbsp;
<i>683</i>&nbsp;    /**
<i>684</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>685</i>&nbsp;     * eleventh month of the year in the Gregorian and Julian calendars.
<i>686</i>&nbsp;     */
<i>687</i>&nbsp;    public static final int NOVEMBER = 10;
<i>688</i>&nbsp;
<i>689</i>&nbsp;    /**
<i>690</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>691</i>&nbsp;     * twelfth month of the year in the Gregorian and Julian calendars.
<i>692</i>&nbsp;     */
<i>693</i>&nbsp;    public static final int DECEMBER = 11;
<i>694</i>&nbsp;
<i>695</i>&nbsp;    /**
<i>696</i>&nbsp;     * Value of the {@link #MONTH} field indicating the
<i>697</i>&nbsp;     * thirteenth month of the year. Although &lt;code&gt;GregorianCalendar&lt;/code&gt;
<i>698</i>&nbsp;     * does not use this value, lunar calendars do.
<i>699</i>&nbsp;     */
<i>700</i>&nbsp;    public static final int UNDECIMBER = 12;
<i>701</i>&nbsp;
<i>702</i>&nbsp;    /**
<i>703</i>&nbsp;     * Value of the {@link #AM_PM} field indicating the
<i>704</i>&nbsp;     * period of the day from midnight to just before noon.
<i>705</i>&nbsp;     */
<i>706</i>&nbsp;    public static final int AM = 0;
<i>707</i>&nbsp;
<i>708</i>&nbsp;    /**
<i>709</i>&nbsp;     * Value of the {@link #AM_PM} field indicating the
<i>710</i>&nbsp;     * period of the day from noon to just before midnight.
<i>711</i>&nbsp;     */
<i>712</i>&nbsp;    public static final int PM = 1;
<i>713</i>&nbsp;
<i>714</i>&nbsp;    /**
<i>715</i>&nbsp;     * A style specifier for {@link #getDisplayNames(int, int, Locale)
<i>716</i>&nbsp;     * getDisplayNames} indicating names in all styles, such as
<i>717</i>&nbsp;     * &quot;January&quot; and &quot;Jan&quot;.
<i>718</i>&nbsp;     *
<i>719</i>&nbsp;     * @see #SHORT_FORMAT
<i>720</i>&nbsp;     * @see #LONG_FORMAT
<i>721</i>&nbsp;     * @see #SHORT_STANDALONE
<i>722</i>&nbsp;     * @see #LONG_STANDALONE
<i>723</i>&nbsp;     * @see #SHORT
<i>724</i>&nbsp;     * @see #LONG
<i>725</i>&nbsp;     * @since 1.6
<i>726</i>&nbsp;     */
<i>727</i>&nbsp;    public static final int ALL_STYLES = 0;
<i>728</i>&nbsp;
<i>729</i>&nbsp;    static final int STANDALONE_MASK = 0x8000;
<i>730</i>&nbsp;
<i>731</i>&nbsp;    /**
<i>732</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>733</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>734</i>&nbsp;     * getDisplayNames} equivalent to {@link #SHORT_FORMAT}.
<i>735</i>&nbsp;     *
<i>736</i>&nbsp;     * @see #SHORT_STANDALONE
<i>737</i>&nbsp;     * @see #LONG
<i>738</i>&nbsp;     * @since 1.6
<i>739</i>&nbsp;     */
<i>740</i>&nbsp;    public static final int SHORT = 1;
<i>741</i>&nbsp;
<i>742</i>&nbsp;    /**
<i>743</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>744</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>745</i>&nbsp;     * getDisplayNames} equivalent to {@link #LONG_FORMAT}.
<i>746</i>&nbsp;     *
<i>747</i>&nbsp;     * @see #LONG_STANDALONE
<i>748</i>&nbsp;     * @see #SHORT
<i>749</i>&nbsp;     * @since 1.6
<i>750</i>&nbsp;     */
<i>751</i>&nbsp;    public static final int LONG = 2;
<i>752</i>&nbsp;
<i>753</i>&nbsp;    /**
<i>754</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>755</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>756</i>&nbsp;     * getDisplayNames} indicating a narrow name used for format. Narrow names
<i>757</i>&nbsp;     * are typically single character strings, such as &quot;M&quot; for Monday.
<i>758</i>&nbsp;     *
<i>759</i>&nbsp;     * @see #NARROW_STANDALONE
<i>760</i>&nbsp;     * @see #SHORT_FORMAT
<i>761</i>&nbsp;     * @see #LONG_FORMAT
<i>762</i>&nbsp;     * @since 1.8
<i>763</i>&nbsp;     */
<i>764</i>&nbsp;    public static final int NARROW_FORMAT = 4;
<i>765</i>&nbsp;
<i>766</i>&nbsp;    /**
<i>767</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>768</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>769</i>&nbsp;     * getDisplayNames} indicating a narrow name independently. Narrow names
<i>770</i>&nbsp;     * are typically single character strings, such as &quot;M&quot; for Monday.
<i>771</i>&nbsp;     *
<i>772</i>&nbsp;     * @see #NARROW_FORMAT
<i>773</i>&nbsp;     * @see #SHORT_STANDALONE
<i>774</i>&nbsp;     * @see #LONG_STANDALONE
<i>775</i>&nbsp;     * @since 1.8
<i>776</i>&nbsp;     */
<i>777</i>&nbsp;    public static final int NARROW_STANDALONE = NARROW_FORMAT | STANDALONE_MASK;
<i>778</i>&nbsp;
<i>779</i>&nbsp;    /**
<i>780</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>781</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>782</i>&nbsp;     * getDisplayNames} indicating a short name used for format.
<i>783</i>&nbsp;     *
<i>784</i>&nbsp;     * @see #SHORT_STANDALONE
<i>785</i>&nbsp;     * @see #LONG_FORMAT
<i>786</i>&nbsp;     * @see #LONG_STANDALONE
<i>787</i>&nbsp;     * @since 1.8
<i>788</i>&nbsp;     */
<i>789</i>&nbsp;    public static final int SHORT_FORMAT = 1;
<i>790</i>&nbsp;
<i>791</i>&nbsp;    /**
<i>792</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>793</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>794</i>&nbsp;     * getDisplayNames} indicating a long name used for format.
<i>795</i>&nbsp;     *
<i>796</i>&nbsp;     * @see #LONG_STANDALONE
<i>797</i>&nbsp;     * @see #SHORT_FORMAT
<i>798</i>&nbsp;     * @see #SHORT_STANDALONE
<i>799</i>&nbsp;     * @since 1.8
<i>800</i>&nbsp;     */
<i>801</i>&nbsp;    public static final int LONG_FORMAT = 2;
<i>802</i>&nbsp;
<i>803</i>&nbsp;    /**
<i>804</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>805</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>806</i>&nbsp;     * getDisplayNames} indicating a short name used independently,
<i>807</i>&nbsp;     * such as a month abbreviation as calendar headers.
<i>808</i>&nbsp;     *
<i>809</i>&nbsp;     * @see #SHORT_FORMAT
<i>810</i>&nbsp;     * @see #LONG_FORMAT
<i>811</i>&nbsp;     * @see #LONG_STANDALONE
<i>812</i>&nbsp;     * @since 1.8
<i>813</i>&nbsp;     */
<i>814</i>&nbsp;    public static final int SHORT_STANDALONE = SHORT | STANDALONE_MASK;
<i>815</i>&nbsp;
<i>816</i>&nbsp;    /**
<i>817</i>&nbsp;     * A style specifier for {@link #getDisplayName(int, int, Locale)
<i>818</i>&nbsp;     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)
<i>819</i>&nbsp;     * getDisplayNames} indicating a long name used independently,
<i>820</i>&nbsp;     * such as a month name as calendar headers.
<i>821</i>&nbsp;     *
<i>822</i>&nbsp;     * @see #LONG_FORMAT
<i>823</i>&nbsp;     * @see #SHORT_FORMAT
<i>824</i>&nbsp;     * @see #SHORT_STANDALONE
<i>825</i>&nbsp;     * @since 1.8
<i>826</i>&nbsp;     */
<i>827</i>&nbsp;    public static final int LONG_STANDALONE = LONG | STANDALONE_MASK;
<i>828</i>&nbsp;
<i>829</i>&nbsp;    // Internal notes:
<i>830</i>&nbsp;    // Calendar contains two kinds of time representations: current &quot;time&quot; in
<i>831</i>&nbsp;    // milliseconds, and a set of calendar &quot;fields&quot; representing the current time.
<i>832</i>&nbsp;    // The two representations are usually in sync, but can get out of sync
<i>833</i>&nbsp;    // as follows.
<i>834</i>&nbsp;    // 1. Initially, no fields are set, and the time is invalid.
<i>835</i>&nbsp;    // 2. If the time is set, all fields are computed and in sync.
<i>836</i>&nbsp;    // 3. If a single field is set, the time is invalid.
<i>837</i>&nbsp;    // Recomputation of the time and fields happens when the object needs
<i>838</i>&nbsp;    // to return a result to the user, or use a result for a computation.
<i>839</i>&nbsp;
<i>840</i>&nbsp;    /**
<i>841</i>&nbsp;     * The calendar field values for the currently set time for this calendar.
<i>842</i>&nbsp;     * This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; integers, with index values
<i>843</i>&nbsp;     * &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.
<i>844</i>&nbsp;     * @serial
<i>845</i>&nbsp;     */
<i>846</i>&nbsp;    @SuppressWarnings(&quot;ProtectedField&quot;)
<i>847</i>&nbsp;    protected int           fields[];
<i>848</i>&nbsp;
<i>849</i>&nbsp;    /**
<i>850</i>&nbsp;     * The flags which tell if a specified calendar field for the calendar is set.
<i>851</i>&nbsp;     * A new object has no fields set.  After the first call to a method
<i>852</i>&nbsp;     * which generates the fields, they all remain set after that.
<i>853</i>&nbsp;     * This is an array of &lt;code&gt;FIELD_COUNT&lt;/code&gt; booleans, with index values
<i>854</i>&nbsp;     * &lt;code&gt;ERA&lt;/code&gt; through &lt;code&gt;DST_OFFSET&lt;/code&gt;.
<i>855</i>&nbsp;     * @serial
<i>856</i>&nbsp;     */
<i>857</i>&nbsp;    @SuppressWarnings(&quot;ProtectedField&quot;)
<i>858</i>&nbsp;    protected boolean       isSet[];
<i>859</i>&nbsp;
<i>860</i>&nbsp;    /**
<i>861</i>&nbsp;     * Pseudo-time-stamps which specify when each field was set. There
<i>862</i>&nbsp;     * are two special values, UNSET and COMPUTED. Values from
<i>863</i>&nbsp;     * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.
<i>864</i>&nbsp;     */
<i>865</i>&nbsp;    private transient int   stamp[];
<i>866</i>&nbsp;
<i>867</i>&nbsp;    /**
<i>868</i>&nbsp;     * The currently set time for this calendar, expressed in milliseconds after
<i>869</i>&nbsp;     * January 1, 1970, 0:00:00 GMT.
<i>870</i>&nbsp;     * @see #isTimeSet
<i>871</i>&nbsp;     * @serial
<i>872</i>&nbsp;     */
<i>873</i>&nbsp;    @SuppressWarnings(&quot;ProtectedField&quot;)
<i>874</i>&nbsp;    protected long          time;
<i>875</i>&nbsp;
<i>876</i>&nbsp;    /**
<i>877</i>&nbsp;     * True if then the value of &lt;code&gt;time&lt;/code&gt; is valid.
<i>878</i>&nbsp;     * The time is made invalid by a change to an item of &lt;code&gt;field[]&lt;/code&gt;.
<i>879</i>&nbsp;     * @see #time
<i>880</i>&nbsp;     * @serial
<i>881</i>&nbsp;     */
<i>882</i>&nbsp;    @SuppressWarnings(&quot;ProtectedField&quot;)
<i>883</i>&nbsp;    protected boolean       isTimeSet;
<i>884</i>&nbsp;
<i>885</i>&nbsp;    /**
<i>886</i>&nbsp;     * True if &lt;code&gt;fields[]&lt;/code&gt; are in sync with the currently set time.
<i>887</i>&nbsp;     * If false, then the next attempt to get the value of a field will
<i>888</i>&nbsp;     * force a recomputation of all fields from the current value of
<i>889</i>&nbsp;     * &lt;code&gt;time&lt;/code&gt;.
<i>890</i>&nbsp;     * @serial
<i>891</i>&nbsp;     */
<i>892</i>&nbsp;    @SuppressWarnings(&quot;ProtectedField&quot;)
<i>893</i>&nbsp;    protected boolean       areFieldsSet;
<i>894</i>&nbsp;
<i>895</i>&nbsp;    /**
<i>896</i>&nbsp;     * True if all fields have been set.
<i>897</i>&nbsp;     * @serial
<i>898</i>&nbsp;     */
<i>899</i>&nbsp;    transient boolean       areAllFieldsSet;
<i>900</i>&nbsp;
<i>901</i>&nbsp;    /**
<b class="nc"><i>902</i>&nbsp;     * &lt;code&gt;True&lt;/code&gt; if this calendar allows out-of-range field values during computation</b>
<i>903</i>&nbsp;     * of &lt;code&gt;time&lt;/code&gt; from &lt;code&gt;fields[]&lt;/code&gt;.
<i>904</i>&nbsp;     * @see #setLenient
<i>905</i>&nbsp;     * @see #isLenient
<i>906</i>&nbsp;     * @serial
<i>907</i>&nbsp;     */
<i>908</i>&nbsp;    private boolean         lenient = true;
<i>909</i>&nbsp;
<i>910</i>&nbsp;    /**
<i>911</i>&nbsp;     * The &lt;code&gt;TimeZone&lt;/code&gt; used by this calendar. &lt;code&gt;Calendar&lt;/code&gt;
<i>912</i>&nbsp;     * uses the time zone data to translate between locale and GMT time.
<i>913</i>&nbsp;     * @serial
<b class="nc"><i>914</i>&nbsp;     */</b>
<i>915</i>&nbsp;    private TimeZone        zone;
<i>916</i>&nbsp;
<i>917</i>&nbsp;    /**
<i>918</i>&nbsp;     * &lt;code&gt;True&lt;/code&gt; if zone references to a shared TimeZone object.
<i>919</i>&nbsp;     */
<i>920</i>&nbsp;    private transient boolean sharedZone = false;
<i>921</i>&nbsp;
<i>922</i>&nbsp;    /**
<i>923</i>&nbsp;     * The first day of the week, with possible values &lt;code&gt;SUNDAY&lt;/code&gt;,
<i>924</i>&nbsp;     * &lt;code&gt;MONDAY&lt;/code&gt;, etc.  This is a locale-dependent value.
<i>925</i>&nbsp;     * @serial
<i>926</i>&nbsp;     */
<i>927</i>&nbsp;    private int             firstDayOfWeek;
<i>928</i>&nbsp;
<i>929</i>&nbsp;    /**
<i>930</i>&nbsp;     * The number of days required for the first week in a month or year,
<i>931</i>&nbsp;     * with possible values from 1 to 7.  This is a locale-dependent value.
<i>932</i>&nbsp;     * @serial
<i>933</i>&nbsp;     */
<b class="nc"><i>934</i>&nbsp;    private int             minimalDaysInFirstWeek;</b>
<i>935</i>&nbsp;
<i>936</i>&nbsp;    /**
<i>937</i>&nbsp;     * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek
<i>938</i>&nbsp;     * of a Locale.
<i>939</i>&nbsp;     */
<i>940</i>&nbsp;    private static final ConcurrentMap&lt;Locale, int[]&gt; cachedLocaleData
<i>941</i>&nbsp;        = new ConcurrentHashMap&lt;&gt;(3);
<i>942</i>&nbsp;
<i>943</i>&nbsp;    // Special values of stamp[]
<i>944</i>&nbsp;    /**
<i>945</i>&nbsp;     * The corresponding fields[] has no value.
<i>946</i>&nbsp;     */
<i>947</i>&nbsp;    private static final int        UNSET = 0;
<i>948</i>&nbsp;
<i>949</i>&nbsp;    /**
<i>950</i>&nbsp;     * The value of the corresponding fields[] has been calculated internally.
<i>951</i>&nbsp;     */
<i>952</i>&nbsp;    private static final int        COMPUTED = 1;
<i>953</i>&nbsp;
<i>954</i>&nbsp;    /**
<i>955</i>&nbsp;     * The value of the corresponding fields[] has been set externally. Stamp
<i>956</i>&nbsp;     * values which are greater than 1 represents the (pseudo) time when the
<i>957</i>&nbsp;     * corresponding fields[] value was set.
<i>958</i>&nbsp;     */
<i>959</i>&nbsp;    private static final int        MINIMUM_USER_STAMP = 2;
<i>960</i>&nbsp;
<i>961</i>&nbsp;    /**
<i>962</i>&nbsp;     * The mask value that represents all of the fields.
<i>963</i>&nbsp;     */
<i>964</i>&nbsp;    static final int ALL_FIELDS = (1 &lt;&lt; FIELD_COUNT) - 1;
<i>965</i>&nbsp;
<i>966</i>&nbsp;    /**
<b class="nc"><i>967</i>&nbsp;     * The next available value for &lt;code&gt;stamp[]&lt;/code&gt;, an internal array.</b>
<i>968</i>&nbsp;     * This actually should not be written out to the stream, and will probably
<i>969</i>&nbsp;     * be removed from the stream in the near future.  In the meantime,
<i>970</i>&nbsp;     * a value of &lt;code&gt;MINIMUM_USER_STAMP&lt;/code&gt; should be used.
<i>971</i>&nbsp;     * @serial
<i>972</i>&nbsp;     */
<i>973</i>&nbsp;    private int             nextStamp = MINIMUM_USER_STAMP;
<i>974</i>&nbsp;
<i>975</i>&nbsp;    // the internal serial version which says which version was written
<i>976</i>&nbsp;    // - 0 (default) for version up to JDK 1.1.5
<i>977</i>&nbsp;    // - 1 for version from JDK 1.1.6, which writes a correct &#39;time&#39; value
<i>978</i>&nbsp;    //     as well as compatible values for other fields.  This is a
<i>979</i>&nbsp;    //     transitional format.
<i>980</i>&nbsp;    // - 2 (not implemented yet) a future version, in which fields[],
<i>981</i>&nbsp;    //     areFieldsSet, and isTimeSet become transient, and isSet[] is
<i>982</i>&nbsp;    //     removed. In JDK 1.1.6 we write a format compatible with version 2.
<i>983</i>&nbsp;    static final int        currentSerialVersion = 1;
<i>984</i>&nbsp;
<i>985</i>&nbsp;    /**
<i>986</i>&nbsp;     * The version of the serialized data on the stream.  Possible values:
<i>987</i>&nbsp;     * &lt;dl&gt;
<i>988</i>&nbsp;     * &lt;dt&gt;&lt;b&gt;0&lt;/b&gt; or not present on stream&lt;/dt&gt;
<i>989</i>&nbsp;     * &lt;dd&gt;
<i>990</i>&nbsp;     * JDK 1.1.5 or earlier.
<i>991</i>&nbsp;     * &lt;/dd&gt;
<i>992</i>&nbsp;     * &lt;dt&gt;&lt;b&gt;1&lt;/b&gt;&lt;/dt&gt;
<i>993</i>&nbsp;     * &lt;dd&gt;
<i>994</i>&nbsp;     * JDK 1.1.6 or later.  Writes a correct &#39;time&#39; value
<i>995</i>&nbsp;     * as well as compatible values for other fields.  This is a
<i>996</i>&nbsp;     * transitional format.
<i>997</i>&nbsp;     * &lt;/dd&gt;
<i>998</i>&nbsp;     * &lt;/dl&gt;
<b class="nc"><i>999</i>&nbsp;     * When streaming out this class, the most recent format</b>
<i>1000</i>&nbsp;     * and the highest allowable &lt;code&gt;serialVersionOnStream&lt;/code&gt;
<i>1001</i>&nbsp;     * is written.
<i>1002</i>&nbsp;     * @serial
<i>1003</i>&nbsp;     * @since 1.1.6
<i>1004</i>&nbsp;     */
<i>1005</i>&nbsp;    private int             serialVersionOnStream = currentSerialVersion;
<i>1006</i>&nbsp;
<i>1007</i>&nbsp;    // Proclaim serialization compatibility with JDK 1.1
<i>1008</i>&nbsp;    static final long       serialVersionUID = -1807547505821590642L;
<i>1009</i>&nbsp;
<i>1010</i>&nbsp;    // Mask values for calendar fields
<i>1011</i>&nbsp;    @SuppressWarnings(&quot;PointlessBitwiseExpression&quot;)
<i>1012</i>&nbsp;    static final int ERA_MASK           = (1 &lt;&lt; ERA);
<i>1013</i>&nbsp;    static final int YEAR_MASK          = (1 &lt;&lt; YEAR);
<i>1014</i>&nbsp;    static final int MONTH_MASK         = (1 &lt;&lt; MONTH);
<i>1015</i>&nbsp;    static final int WEEK_OF_YEAR_MASK  = (1 &lt;&lt; WEEK_OF_YEAR);
<i>1016</i>&nbsp;    static final int WEEK_OF_MONTH_MASK = (1 &lt;&lt; WEEK_OF_MONTH);
<i>1017</i>&nbsp;    static final int DAY_OF_MONTH_MASK  = (1 &lt;&lt; DAY_OF_MONTH);
<i>1018</i>&nbsp;    static final int DATE_MASK          = DAY_OF_MONTH_MASK;
<i>1019</i>&nbsp;    static final int DAY_OF_YEAR_MASK   = (1 &lt;&lt; DAY_OF_YEAR);
<i>1020</i>&nbsp;    static final int DAY_OF_WEEK_MASK   = (1 &lt;&lt; DAY_OF_WEEK);
<i>1021</i>&nbsp;    static final int DAY_OF_WEEK_IN_MONTH_MASK  = (1 &lt;&lt; DAY_OF_WEEK_IN_MONTH);
<i>1022</i>&nbsp;    static final int AM_PM_MASK         = (1 &lt;&lt; AM_PM);
<i>1023</i>&nbsp;    static final int HOUR_MASK          = (1 &lt;&lt; HOUR);
<i>1024</i>&nbsp;    static final int HOUR_OF_DAY_MASK   = (1 &lt;&lt; HOUR_OF_DAY);
<i>1025</i>&nbsp;    static final int MINUTE_MASK        = (1 &lt;&lt; MINUTE);
<i>1026</i>&nbsp;    static final int SECOND_MASK        = (1 &lt;&lt; SECOND);
<i>1027</i>&nbsp;    static final int MILLISECOND_MASK   = (1 &lt;&lt; MILLISECOND);
<i>1028</i>&nbsp;    static final int ZONE_OFFSET_MASK   = (1 &lt;&lt; ZONE_OFFSET);
<i>1029</i>&nbsp;    static final int DST_OFFSET_MASK    = (1 &lt;&lt; DST_OFFSET);
<i>1030</i>&nbsp;
<i>1031</i>&nbsp;    /**
<i>1032</i>&nbsp;     * {@code Calendar.Builder} is used for creating a {@code Calendar} from
<i>1033</i>&nbsp;     * various date-time parameters.
<i>1034</i>&nbsp;     *
<i>1035</i>&nbsp;     * &lt;p&gt;There are two ways to set a {@code Calendar} to a date-time value. One
<i>1036</i>&nbsp;     * is to set the instant parameter to a millisecond offset from the &lt;a
<i>1037</i>&nbsp;     * href=&quot;Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;. The other is to set individual
<i>1038</i>&nbsp;     * field parameters, such as {@link Calendar#YEAR YEAR}, to their desired
<i>1039</i>&nbsp;     * values. These two ways can&#39;t be mixed. Trying to set both the instant and
<i>1040</i>&nbsp;     * individual fields will cause an {@link IllegalStateException} to be
<i>1041</i>&nbsp;     * thrown. However, it is permitted to override previous values of the
<i>1042</i>&nbsp;     * instant or field parameters.
<i>1043</i>&nbsp;     *
<i>1044</i>&nbsp;     * &lt;p&gt;If no enough field parameters are given for determining date and/or
<i>1045</i>&nbsp;     * time, calendar specific default values are used when building a
<i>1046</i>&nbsp;     * {@code Calendar}. For example, if the {@link Calendar#YEAR YEAR} value
<i>1047</i>&nbsp;     * isn&#39;t given for the Gregorian calendar, 1970 will be used. If there are
<i>1048</i>&nbsp;     * any conflicts among field parameters, the &lt;a
<i>1049</i>&nbsp;     * href=&quot;Calendar.html#resolution&quot;&gt; resolution rules&lt;/a&gt; are applied.
<i>1050</i>&nbsp;     * Therefore, the order of field setting matters.
<i>1051</i>&nbsp;     *
<i>1052</i>&nbsp;     * &lt;p&gt;In addition to the date-time parameters,
<i>1053</i>&nbsp;     * the {@linkplain #setLocale(Locale) locale},
<i>1054</i>&nbsp;     * {@linkplain #setTimeZone(TimeZone) time zone},
<i>1055</i>&nbsp;     * {@linkplain #setWeekDefinition(int, int) week definition}, and
<i>1056</i>&nbsp;     * {@linkplain #setLenient(boolean) leniency mode} parameters can be set.
<i>1057</i>&nbsp;     *
<i>1058</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Examples&lt;/b&gt;
<i>1059</i>&nbsp;     * &lt;p&gt;The following are sample usages. Sample code assumes that the
<i>1060</i>&nbsp;     * {@code Calendar} constants are statically imported.
<i>1061</i>&nbsp;     *
<i>1062</i>&nbsp;     * &lt;p&gt;The following code produces a {@code Calendar} with date 2012-12-31
<i>1063</i>&nbsp;     * (Gregorian) because Monday is the first day of a week with the &lt;a
<i>1064</i>&nbsp;     * href=&quot;GregorianCalendar.html#iso8601_compatible_setting&quot;&gt; ISO 8601
<i>1065</i>&nbsp;     * compatible week parameters&lt;/a&gt;.
<i>1066</i>&nbsp;     * &lt;pre&gt;
<i>1067</i>&nbsp;     *   Calendar cal = new Calendar.Builder().setCalendarType(&quot;iso8601&quot;)
<i>1068</i>&nbsp;     *                        .setWeekDate(2013, 1, MONDAY).build();&lt;/pre&gt;
<i>1069</i>&nbsp;     * &lt;p&gt;The following code produces a Japanese {@code Calendar} with date
<i>1070</i>&nbsp;     * 1989-01-08 (Gregorian), assuming that the default {@link Calendar#ERA ERA}
<i>1071</i>&nbsp;     * is &lt;em&gt;Heisei&lt;/em&gt; that started on that day.
<i>1072</i>&nbsp;     * &lt;pre&gt;
<i>1073</i>&nbsp;     *   Calendar cal = new Calendar.Builder().setCalendarType(&quot;japanese&quot;)
<i>1074</i>&nbsp;     *                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();&lt;/pre&gt;
<i>1075</i>&nbsp;     *
<i>1076</i>&nbsp;     * @since 1.8
<i>1077</i>&nbsp;     * @see Calendar#getInstance(TimeZone, Locale)
<i>1078</i>&nbsp;     * @see Calendar#fields
<i>1079</i>&nbsp;     */
<i>1080</i>&nbsp;    public static class Builder {
<i>1081</i>&nbsp;        private static final int NFIELDS = FIELD_COUNT + 1; // +1 for WEEK_YEAR
<i>1082</i>&nbsp;        private static final int WEEK_YEAR = FIELD_COUNT;
<i>1083</i>&nbsp;
<i>1084</i>&nbsp;        private long instant;
<i>1085</i>&nbsp;        // Calendar.stamp[] (lower half) and Calendar.fields[] (upper half) combined
<i>1086</i>&nbsp;        private int[] fields;
<i>1087</i>&nbsp;        // Pseudo timestamp starting from MINIMUM_USER_STAMP.
<i>1088</i>&nbsp;        // (COMPUTED is used to indicate that the instant has been set.)
<b class="nc"><i>1089</i>&nbsp;        private int nextStamp;</b>
<i>1090</i>&nbsp;        // maxFieldIndex keeps the max index of fields which have been set.
<i>1091</i>&nbsp;        // (WEEK_YEAR is never included.)
<i>1092</i>&nbsp;        private int maxFieldIndex;
<i>1093</i>&nbsp;        private String type;
<i>1094</i>&nbsp;        private TimeZone zone;
<i>1095</i>&nbsp;        private boolean lenient = true;
<b class="nc"><i>1096</i>&nbsp;        private Locale locale;</b>
<i>1097</i>&nbsp;        private int firstDayOfWeek, minimalDaysInFirstWeek;
<i>1098</i>&nbsp;
<i>1099</i>&nbsp;        /**
<i>1100</i>&nbsp;         * Constructs a {@code Calendar.Builder}.
<i>1101</i>&nbsp;         */
<i>1102</i>&nbsp;        public Builder() {
<i>1103</i>&nbsp;        }
<i>1104</i>&nbsp;
<i>1105</i>&nbsp;        /**
<i>1106</i>&nbsp;         * Sets the instant parameter to the given {@code instant} value that is
<i>1107</i>&nbsp;         * a millisecond offset from &lt;a href=&quot;Calendar.html#Epoch&quot;&gt;the
<i>1108</i>&nbsp;         * Epoch&lt;/a&gt;.
<i>1109</i>&nbsp;         *
<i>1110</i>&nbsp;         * @param instant a millisecond offset from the Epoch
<i>1111</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1112</i>&nbsp;         * @throws IllegalStateException if any of the field parameters have
<b class="nc"><i>1113</i>&nbsp;         *                               already been set</b>
<b class="nc"><i>1114</i>&nbsp;         * @see Calendar#setTime(Date)</b>
<i>1115</i>&nbsp;         * @see Calendar#setTimeInMillis(long)
<b class="nc"><i>1116</i>&nbsp;         * @see Calendar#time</b>
<b class="nc"><i>1117</i>&nbsp;         */</b>
<b class="nc"><i>1118</i>&nbsp;        public Builder setInstant(long instant) {</b>
<i>1119</i>&nbsp;            if (fields != null) {
<i>1120</i>&nbsp;                throw new IllegalStateException();
<i>1121</i>&nbsp;            }
<i>1122</i>&nbsp;            this.instant = instant;
<i>1123</i>&nbsp;            nextStamp = COMPUTED;
<i>1124</i>&nbsp;            return this;
<i>1125</i>&nbsp;        }
<i>1126</i>&nbsp;
<i>1127</i>&nbsp;        /**
<i>1128</i>&nbsp;         * Sets the instant parameter to the {@code instant} value given by a
<i>1129</i>&nbsp;         * {@link Date}. This method is equivalent to a call to
<i>1130</i>&nbsp;         * {@link #setInstant(long) setInstant(instant.getTime())}.
<i>1131</i>&nbsp;         *
<i>1132</i>&nbsp;         * @param instant a {@code Date} representing a millisecond offset from
<i>1133</i>&nbsp;         *                the Epoch
<i>1134</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1135</i>&nbsp;         * @throws NullPointerException  if {@code instant} is {@code null}
<i>1136</i>&nbsp;         * @throws IllegalStateException if any of the field parameters have
<b class="nc"><i>1137</i>&nbsp;         *                               already been set</b>
<i>1138</i>&nbsp;         * @see Calendar#setTime(Date)
<i>1139</i>&nbsp;         * @see Calendar#setTimeInMillis(long)
<i>1140</i>&nbsp;         * @see Calendar#time
<i>1141</i>&nbsp;         */
<i>1142</i>&nbsp;        public Builder setInstant(Date instant) {
<i>1143</i>&nbsp;            return setInstant(instant.getTime()); // NPE if instant == null
<i>1144</i>&nbsp;        }
<i>1145</i>&nbsp;
<i>1146</i>&nbsp;        /**
<i>1147</i>&nbsp;         * Sets the {@code field} parameter to the given {@code value}.
<i>1148</i>&nbsp;         * {@code field} is an index to the {@link Calendar#fields}, such as
<i>1149</i>&nbsp;         * {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH}. Field value validation is
<i>1150</i>&nbsp;         * not performed in this method. Any out of range values are either
<i>1151</i>&nbsp;         * normalized in lenient mode or detected as an invalid value in
<i>1152</i>&nbsp;         * non-lenient mode when building a {@code Calendar}.
<i>1153</i>&nbsp;         *
<i>1154</i>&nbsp;         * @param field an index to the {@code Calendar} fields
<i>1155</i>&nbsp;         * @param value the field value
<i>1156</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1157</i>&nbsp;         * @throws IllegalArgumentException if {@code field} is invalid
<i>1158</i>&nbsp;         * @throws IllegalStateException if the instant value has already been set,
<b class="nc"><i>1159</i>&nbsp;         *                      or if fields have been set too many</b>
<b class="nc"><i>1160</i>&nbsp;         *                      (approximately {@link Integer#MAX_VALUE}) times.</b>
<i>1161</i>&nbsp;         * @see Calendar#set(int, int)
<b class="nc"><i>1162</i>&nbsp;         */</b>
<b class="nc"><i>1163</i>&nbsp;        public Builder set(int field, int value) {</b>
<i>1164</i>&nbsp;            // Note: WEEK_YEAR can&#39;t be set with this method.
<b class="nc"><i>1165</i>&nbsp;            if (field &lt; 0 || field &gt;= FIELD_COUNT) {</b>
<b class="nc"><i>1166</i>&nbsp;                throw new IllegalArgumentException(&quot;field is invalid&quot;);</b>
<b class="nc"><i>1167</i>&nbsp;            }</b>
<i>1168</i>&nbsp;            if (isInstantSet()) {
<i>1169</i>&nbsp;                throw new IllegalStateException(&quot;instant has been set&quot;);
<i>1170</i>&nbsp;            }
<i>1171</i>&nbsp;            allocateFields();
<i>1172</i>&nbsp;            internalSet(field, value);
<i>1173</i>&nbsp;            return this;
<i>1174</i>&nbsp;        }
<i>1175</i>&nbsp;
<i>1176</i>&nbsp;        /**
<i>1177</i>&nbsp;         * Sets field parameters to their values given by
<i>1178</i>&nbsp;         * {@code fieldValuePairs} that are pairs of a field and its value.
<i>1179</i>&nbsp;         * For example,
<i>1180</i>&nbsp;         * &lt;pre&gt;
<i>1181</i>&nbsp;         *   setFields(Calendar.YEAR, 2013,
<i>1182</i>&nbsp;         *             Calendar.MONTH, Calendar.DECEMBER,
<i>1183</i>&nbsp;         *             Calendar.DAY_OF_MONTH, 23);&lt;/pre&gt;
<i>1184</i>&nbsp;         * is equivalent to the sequence of the following
<i>1185</i>&nbsp;         * {@link #set(int, int) set} calls:
<i>1186</i>&nbsp;         * &lt;pre&gt;
<i>1187</i>&nbsp;         *   set(Calendar.YEAR, 2013)
<i>1188</i>&nbsp;         *   .set(Calendar.MONTH, Calendar.DECEMBER)
<i>1189</i>&nbsp;         *   .set(Calendar.DAY_OF_MONTH, 23);&lt;/pre&gt;
<i>1190</i>&nbsp;         *
<i>1191</i>&nbsp;         * @param fieldValuePairs field-value pairs
<i>1192</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1193</i>&nbsp;         * @throws NullPointerException if {@code fieldValuePairs} is {@code null}
<i>1194</i>&nbsp;         * @throws IllegalArgumentException if any of fields are invalid,
<b class="nc"><i>1195</i>&nbsp;         *             or if {@code fieldValuePairs.length} is an odd number.</b>
<b class="nc"><i>1196</i>&nbsp;         * @throws IllegalStateException    if the instant value has been set,</b>
<b class="nc"><i>1197</i>&nbsp;         *             or if fields have been set too many (approximately</b>
<i>1198</i>&nbsp;         *             {@link Integer#MAX_VALUE}) times.
<b class="nc"><i>1199</i>&nbsp;         */</b>
<b class="nc"><i>1200</i>&nbsp;        public Builder setFields(int... fieldValuePairs) {</b>
<i>1201</i>&nbsp;            int len = fieldValuePairs.length;
<b class="nc"><i>1202</i>&nbsp;            if ((len % 2) != 0) {</b>
<b class="nc"><i>1203</i>&nbsp;                throw new IllegalArgumentException();</b>
<i>1204</i>&nbsp;            }
<b class="nc"><i>1205</i>&nbsp;            if (isInstantSet()) {</b>
<b class="nc"><i>1206</i>&nbsp;                throw new IllegalStateException(&quot;instant has been set&quot;);</b>
<b class="nc"><i>1207</i>&nbsp;            }</b>
<i>1208</i>&nbsp;            if ((nextStamp + len / 2) &lt; 0) {
<b class="nc"><i>1209</i>&nbsp;                throw new IllegalStateException(&quot;stamp counter overflow&quot;);</b>
<b class="nc"><i>1210</i>&nbsp;            }</b>
<i>1211</i>&nbsp;            allocateFields();
<b class="nc"><i>1212</i>&nbsp;            for (int i = 0; i &lt; len; ) {</b>
<b class="nc"><i>1213</i>&nbsp;                int field = fieldValuePairs[i++];</b>
<b class="nc"><i>1214</i>&nbsp;                // Note: WEEK_YEAR can&#39;t be set with this method.</b>
<i>1215</i>&nbsp;                if (field &lt; 0 || field &gt;= FIELD_COUNT) {
<i>1216</i>&nbsp;                    throw new IllegalArgumentException(&quot;field is invalid&quot;);
<i>1217</i>&nbsp;                }
<i>1218</i>&nbsp;                internalSet(field, fieldValuePairs[i++]);
<i>1219</i>&nbsp;            }
<i>1220</i>&nbsp;            return this;
<i>1221</i>&nbsp;        }
<i>1222</i>&nbsp;
<i>1223</i>&nbsp;        /**
<i>1224</i>&nbsp;         * Sets the date field parameters to the values given by {@code year},
<i>1225</i>&nbsp;         * {@code month}, and {@code dayOfMonth}. This method is equivalent to
<i>1226</i>&nbsp;         * a call to:
<i>1227</i>&nbsp;         * &lt;pre&gt;
<i>1228</i>&nbsp;         *   setFields(Calendar.YEAR, year,
<i>1229</i>&nbsp;         *             Calendar.MONTH, month,
<i>1230</i>&nbsp;         *             Calendar.DAY_OF_MONTH, dayOfMonth);&lt;/pre&gt;
<i>1231</i>&nbsp;         *
<i>1232</i>&nbsp;         * @param year       the {@link Calendar#YEAR YEAR} value
<b class="nc"><i>1233</i>&nbsp;         * @param month      the {@link Calendar#MONTH MONTH} value</b>
<i>1234</i>&nbsp;         *                   (the month numbering is &lt;em&gt;0-based&lt;/em&gt;).
<i>1235</i>&nbsp;         * @param dayOfMonth the {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH} value
<i>1236</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1237</i>&nbsp;         */
<i>1238</i>&nbsp;        public Builder setDate(int year, int month, int dayOfMonth) {
<i>1239</i>&nbsp;            return setFields(YEAR, year, MONTH, month, DAY_OF_MONTH, dayOfMonth);
<i>1240</i>&nbsp;        }
<i>1241</i>&nbsp;
<i>1242</i>&nbsp;        /**
<i>1243</i>&nbsp;         * Sets the time of day field parameters to the values given by
<i>1244</i>&nbsp;         * {@code hourOfDay}, {@code minute}, and {@code second}. This method is
<i>1245</i>&nbsp;         * equivalent to a call to:
<i>1246</i>&nbsp;         * &lt;pre&gt;
<i>1247</i>&nbsp;         *   setTimeOfDay(hourOfDay, minute, second, 0);&lt;/pre&gt;
<i>1248</i>&nbsp;         *
<i>1249</i>&nbsp;         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value
<b class="nc"><i>1250</i>&nbsp;         *                  (24-hour clock)</b>
<i>1251</i>&nbsp;         * @param minute    the {@link Calendar#MINUTE MINUTE} value
<i>1252</i>&nbsp;         * @param second    the {@link Calendar#SECOND SECOND} value
<i>1253</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1254</i>&nbsp;         */
<i>1255</i>&nbsp;        public Builder setTimeOfDay(int hourOfDay, int minute, int second) {
<i>1256</i>&nbsp;            return setTimeOfDay(hourOfDay, minute, second, 0);
<i>1257</i>&nbsp;        }
<i>1258</i>&nbsp;
<i>1259</i>&nbsp;        /**
<i>1260</i>&nbsp;         * Sets the time of day field parameters to the values given by
<i>1261</i>&nbsp;         * {@code hourOfDay}, {@code minute}, {@code second}, and
<i>1262</i>&nbsp;         * {@code millis}. This method is equivalent to a call to:
<i>1263</i>&nbsp;         * &lt;pre&gt;
<i>1264</i>&nbsp;         *   setFields(Calendar.HOUR_OF_DAY, hourOfDay,
<i>1265</i>&nbsp;         *             Calendar.MINUTE, minute,
<i>1266</i>&nbsp;         *             Calendar.SECOND, second,
<i>1267</i>&nbsp;         *             Calendar.MILLISECOND, millis);&lt;/pre&gt;
<i>1268</i>&nbsp;         *
<i>1269</i>&nbsp;         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value
<i>1270</i>&nbsp;         *                  (24-hour clock)
<b class="nc"><i>1271</i>&nbsp;         * @param minute    the {@link Calendar#MINUTE MINUTE} value</b>
<i>1272</i>&nbsp;         * @param second    the {@link Calendar#SECOND SECOND} value
<i>1273</i>&nbsp;         * @param millis    the {@link Calendar#MILLISECOND MILLISECOND} value
<i>1274</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1275</i>&nbsp;         */
<i>1276</i>&nbsp;        public Builder setTimeOfDay(int hourOfDay, int minute, int second, int millis) {
<i>1277</i>&nbsp;            return setFields(HOUR_OF_DAY, hourOfDay, MINUTE, minute,
<i>1278</i>&nbsp;                             SECOND, second, MILLISECOND, millis);
<i>1279</i>&nbsp;        }
<i>1280</i>&nbsp;
<i>1281</i>&nbsp;        /**
<i>1282</i>&nbsp;         * Sets the week-based date parameters to the values with the given
<i>1283</i>&nbsp;         * date specifiers - week year, week of year, and day of week.
<i>1284</i>&nbsp;         *
<i>1285</i>&nbsp;         * &lt;p&gt;If the specified calendar doesn&#39;t support week dates, the
<i>1286</i>&nbsp;         * {@link #build() build} method will throw an {@link IllegalArgumentException}.
<i>1287</i>&nbsp;         *
<i>1288</i>&nbsp;         * @param weekYear   the week year
<i>1289</i>&nbsp;         * @param weekOfYear the week number based on {@code weekYear}
<i>1290</i>&nbsp;         * @param dayOfWeek  the day of week value: one of the constants
<i>1291</i>&nbsp;         *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:
<b class="nc"><i>1292</i>&nbsp;         *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.</b>
<b class="nc"><i>1293</i>&nbsp;         * @return this {@code Calendar.Builder}</b>
<b class="nc"><i>1294</i>&nbsp;         * @see Calendar#setWeekDate(int, int, int)</b>
<b class="nc"><i>1295</i>&nbsp;         * @see Calendar#isWeekDateSupported()</b>
<b class="nc"><i>1296</i>&nbsp;         */</b>
<i>1297</i>&nbsp;        public Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
<i>1298</i>&nbsp;            allocateFields();
<i>1299</i>&nbsp;            internalSet(WEEK_YEAR, weekYear);
<i>1300</i>&nbsp;            internalSet(WEEK_OF_YEAR, weekOfYear);
<i>1301</i>&nbsp;            internalSet(DAY_OF_WEEK, dayOfWeek);
<i>1302</i>&nbsp;            return this;
<i>1303</i>&nbsp;        }
<i>1304</i>&nbsp;
<i>1305</i>&nbsp;        /**
<i>1306</i>&nbsp;         * Sets the time zone parameter to the given {@code zone}. If no time
<i>1307</i>&nbsp;         * zone parameter is given to this {@code Calendar.Builder}, the
<i>1308</i>&nbsp;         * {@linkplain TimeZone#getDefault() default
<i>1309</i>&nbsp;         * &lt;code&gt;TimeZone&lt;/code&gt;} will be used in the {@link #build() build}
<i>1310</i>&nbsp;         * method.
<i>1311</i>&nbsp;         *
<b class="nc"><i>1312</i>&nbsp;         * @param zone the {@link TimeZone}</b>
<b class="nc"><i>1313</i>&nbsp;         * @return this {@code Calendar.Builder}</b>
<i>1314</i>&nbsp;         * @throws NullPointerException if {@code zone} is {@code null}
<b class="nc"><i>1315</i>&nbsp;         * @see Calendar#setTimeZone(TimeZone)</b>
<b class="nc"><i>1316</i>&nbsp;         */</b>
<i>1317</i>&nbsp;        public Builder setTimeZone(TimeZone zone) {
<i>1318</i>&nbsp;            if (zone == null) {
<i>1319</i>&nbsp;                throw new NullPointerException();
<i>1320</i>&nbsp;            }
<i>1321</i>&nbsp;            this.zone = zone;
<i>1322</i>&nbsp;            return this;
<i>1323</i>&nbsp;        }
<i>1324</i>&nbsp;
<i>1325</i>&nbsp;        /**
<i>1326</i>&nbsp;         * Sets the lenient mode parameter to the value given by {@code lenient}.
<i>1327</i>&nbsp;         * If no lenient parameter is given to this {@code Calendar.Builder},
<i>1328</i>&nbsp;         * lenient mode will be used in the {@link #build() build} method.
<i>1329</i>&nbsp;         *
<b class="nc"><i>1330</i>&nbsp;         * @param lenient {@code true} for lenient mode;</b>
<b class="nc"><i>1331</i>&nbsp;         *                {@code false} for non-lenient mode</b>
<i>1332</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1333</i>&nbsp;         * @see Calendar#setLenient(boolean)
<i>1334</i>&nbsp;         */
<i>1335</i>&nbsp;        public Builder setLenient(boolean lenient) {
<i>1336</i>&nbsp;            this.lenient = lenient;
<i>1337</i>&nbsp;            return this;
<i>1338</i>&nbsp;        }
<i>1339</i>&nbsp;
<i>1340</i>&nbsp;        /**
<i>1341</i>&nbsp;         * Sets the calendar type parameter to the given {@code type}. The
<i>1342</i>&nbsp;         * calendar type given by this method has precedence over any explicit
<i>1343</i>&nbsp;         * or implicit calendar type given by the
<i>1344</i>&nbsp;         * {@linkplain #setLocale(Locale) locale}.
<i>1345</i>&nbsp;         *
<i>1346</i>&nbsp;         * &lt;p&gt;In addition to the available calendar types returned by the
<i>1347</i>&nbsp;         * {@link Calendar#getAvailableCalendarTypes() Calendar.getAvailableCalendarTypes}
<i>1348</i>&nbsp;         * method, {@code &quot;gregorian&quot;} and {@code &quot;iso8601&quot;} as aliases of
<i>1349</i>&nbsp;         * {@code &quot;gregory&quot;} can be used with this method.
<i>1350</i>&nbsp;         *
<i>1351</i>&nbsp;         * @param type the calendar type
<i>1352</i>&nbsp;         * @return this {@code Calendar.Builder}
<i>1353</i>&nbsp;         * @throws NullPointerException if {@code type} is {@code null}
<b class="nc"><i>1354</i>&nbsp;         * @throws IllegalArgumentException if {@code type} is unknown</b>
<b class="nc"><i>1355</i>&nbsp;         * @throws IllegalStateException if another calendar type has already been set</b>
<i>1356</i>&nbsp;         * @see Calendar#getCalendarType()
<b class="nc"><i>1357</i>&nbsp;         * @see Calendar#getAvailableCalendarTypes()</b>
<b class="nc"><i>1358</i>&nbsp;         */</b>
<b class="nc"><i>1359</i>&nbsp;        public Builder setCalendarType(String type) {</b>
<i>1360</i>&nbsp;            if (type.equals(&quot;gregorian&quot;)) { // NPE if type == null
<b class="nc"><i>1361</i>&nbsp;                type = &quot;gregory&quot;;</b>
<b class="nc"><i>1362</i>&nbsp;            }</b>
<i>1363</i>&nbsp;            if (!Calendar.getAvailableCalendarTypes().contains(type)
<b class="nc"><i>1364</i>&nbsp;                    &amp;&amp; !type.equals(&quot;iso8601&quot;)) {</b>
<b class="nc"><i>1365</i>&nbsp;                throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);</b>
<i>1366</i>&nbsp;            }
<i>1367</i>&nbsp;            if (this.type == null) {
<b class="nc"><i>1368</i>&nbsp;                this.type = type;</b>
<i>1369</i>&nbsp;            } else {
<i>1370</i>&nbsp;                if (!this.type.equals(type)) {
<i>1371</i>&nbsp;                    throw new IllegalStateException(&quot;calendar type override&quot;);
<i>1372</i>&nbsp;                }
<i>1373</i>&nbsp;            }
<i>1374</i>&nbsp;            return this;
<i>1375</i>&nbsp;        }
<i>1376</i>&nbsp;
<i>1377</i>&nbsp;        /**
<i>1378</i>&nbsp;         * Sets the locale parameter to the given {@code locale}. If no locale
<i>1379</i>&nbsp;         * is given to this {@code Calendar.Builder}, the {@linkplain
<i>1380</i>&nbsp;         * Locale#getDefault(Locale.Category) default &lt;code&gt;Locale&lt;/code&gt;}
<i>1381</i>&nbsp;         * for {@link Locale.Category#FORMAT} will be used.
<i>1382</i>&nbsp;         *
<i>1383</i>&nbsp;         * &lt;p&gt;If no calendar type is explicitly given by a call to the
<i>1384</i>&nbsp;         * {@link #setCalendarType(String) setCalendarType} method,
<i>1385</i>&nbsp;         * the {@code Locale} value is used to determine what type of
<i>1386</i>&nbsp;         * {@code Calendar} to be built.
<i>1387</i>&nbsp;         *
<i>1388</i>&nbsp;         * &lt;p&gt;If no week definition parameters are explicitly given by a call to
<i>1389</i>&nbsp;         * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the
<i>1390</i>&nbsp;         * {@code Locale}&#39;s default values are used.
<i>1391</i>&nbsp;         *
<b class="nc"><i>1392</i>&nbsp;         * @param locale the {@link Locale}</b>
<b class="nc"><i>1393</i>&nbsp;         * @throws NullPointerException if {@code locale} is {@code null}</b>
<i>1394</i>&nbsp;         * @return this {@code Calendar.Builder}
<b class="nc"><i>1395</i>&nbsp;         * @see Calendar#getInstance(Locale)</b>
<b class="nc"><i>1396</i>&nbsp;         */</b>
<i>1397</i>&nbsp;        public Builder setLocale(Locale locale) {
<i>1398</i>&nbsp;            if (locale == null) {
<i>1399</i>&nbsp;                throw new NullPointerException();
<i>1400</i>&nbsp;            }
<i>1401</i>&nbsp;            this.locale = locale;
<i>1402</i>&nbsp;            return this;
<i>1403</i>&nbsp;        }
<i>1404</i>&nbsp;
<i>1405</i>&nbsp;        /**
<i>1406</i>&nbsp;         * Sets the week definition parameters to the values given by
<i>1407</i>&nbsp;         * {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} that are
<i>1408</i>&nbsp;         * used to determine the &lt;a href=&quot;Calendar.html#first_week&quot;&gt;first
<i>1409</i>&nbsp;         * week&lt;/a&gt; of a year. The parameters given by this method have
<i>1410</i>&nbsp;         * precedence over the default values given by the
<i>1411</i>&nbsp;         * {@linkplain #setLocale(Locale) locale}.
<i>1412</i>&nbsp;         *
<i>1413</i>&nbsp;         * @param firstDayOfWeek the first day of a week; one of
<i>1414</i>&nbsp;         *                       {@link Calendar#SUNDAY} to {@link Calendar#SATURDAY}
<i>1415</i>&nbsp;         * @param minimalDaysInFirstWeek the minimal number of days in the first
<i>1416</i>&nbsp;         *                               week (1..7)
<i>1417</i>&nbsp;         * @return this {@code Calendar.Builder}
<b class="nc"><i>1418</i>&nbsp;         * @throws IllegalArgumentException if {@code firstDayOfWeek} or</b>
<b class="nc"><i>1419</i>&nbsp;         *                                  {@code minimalDaysInFirstWeek} is invalid</b>
<b class="nc"><i>1420</i>&nbsp;         * @see Calendar#getFirstDayOfWeek()</b>
<i>1421</i>&nbsp;         * @see Calendar#getMinimalDaysInFirstWeek()
<b class="nc"><i>1422</i>&nbsp;         */</b>
<b class="nc"><i>1423</i>&nbsp;        public Builder setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek) {</b>
<b class="nc"><i>1424</i>&nbsp;            if (!isValidWeekParameter(firstDayOfWeek)</b>
<i>1425</i>&nbsp;                    || !isValidWeekParameter(minimalDaysInFirstWeek)) {
<i>1426</i>&nbsp;                throw new IllegalArgumentException();
<i>1427</i>&nbsp;            }
<i>1428</i>&nbsp;            this.firstDayOfWeek = firstDayOfWeek;
<i>1429</i>&nbsp;            this.minimalDaysInFirstWeek = minimalDaysInFirstWeek;
<i>1430</i>&nbsp;            return this;
<i>1431</i>&nbsp;        }
<i>1432</i>&nbsp;
<i>1433</i>&nbsp;        /**
<i>1434</i>&nbsp;         * Returns a {@code Calendar} built from the parameters set by the
<i>1435</i>&nbsp;         * setter methods. The calendar type given by the {@link #setCalendarType(String)
<i>1436</i>&nbsp;         * setCalendarType} method or the {@linkplain #setLocale(Locale) locale} is
<i>1437</i>&nbsp;         * used to determine what {@code Calendar} to be created. If no explicit
<i>1438</i>&nbsp;         * calendar type is given, the locale&#39;s default calendar is created.
<i>1439</i>&nbsp;         *
<i>1440</i>&nbsp;         * &lt;p&gt;If the calendar type is {@code &quot;iso8601&quot;}, the
<i>1441</i>&nbsp;         * {@linkplain GregorianCalendar#setGregorianChange(Date) Gregorian change date}
<i>1442</i>&nbsp;         * of a {@link GregorianCalendar} is set to {@code Date(Long.MIN_VALUE)}
<i>1443</i>&nbsp;         * to be the &lt;em&gt;proleptic&lt;/em&gt; Gregorian calendar. Its week definition
<i>1444</i>&nbsp;         * parameters are also set to be &lt;a
<i>1445</i>&nbsp;         * href=&quot;GregorianCalendar.html#iso8601_compatible_setting&quot;&gt;compatible
<i>1446</i>&nbsp;         * with the ISO 8601 standard&lt;/a&gt;. Note that the
<i>1447</i>&nbsp;         * {@link GregorianCalendar#getCalendarType() getCalendarType} method of
<i>1448</i>&nbsp;         * a {@code GregorianCalendar} created with {@code &quot;iso8601&quot;} returns
<i>1449</i>&nbsp;         * {@code &quot;gregory&quot;}.
<i>1450</i>&nbsp;         *
<i>1451</i>&nbsp;         * &lt;p&gt;The default values are used for locale and time zone if these
<i>1452</i>&nbsp;         * parameters haven&#39;t been given explicitly.
<i>1453</i>&nbsp;         * &lt;p&gt;
<i>1454</i>&nbsp;         * If the locale contains the time zone with &quot;tz&quot;
<i>1455</i>&nbsp;         * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
<i>1456</i>&nbsp;         * and time zone hasn&#39;t been given explicitly, time zone in the locale
<i>1457</i>&nbsp;         * is used.
<i>1458</i>&nbsp;         *
<i>1459</i>&nbsp;         * &lt;p&gt;Any out of range field values are either normalized in lenient
<i>1460</i>&nbsp;         * mode or detected as an invalid value in non-lenient mode.
<i>1461</i>&nbsp;         *
<b class="nc"><i>1462</i>&nbsp;         * @return a {@code Calendar} built with parameters of this {@code</b>
<b class="nc"><i>1463</i>&nbsp;         *         Calendar.Builder}</b>
<i>1464</i>&nbsp;         * @throws IllegalArgumentException if the calendar type is unknown, or
<b class="nc"><i>1465</i>&nbsp;         *             if any invalid field values are given in non-lenient mode, or</b>
<b class="nc"><i>1466</i>&nbsp;         *             if a week date is given for the calendar type that doesn&#39;t</b>
<i>1467</i>&nbsp;         *             support week dates.
<i>1468</i>&nbsp;         * @see Calendar#getInstance(TimeZone, Locale)
<b class="nc"><i>1469</i>&nbsp;         * @see Locale#getDefault(Locale.Category)</b>
<b class="nc"><i>1470</i>&nbsp;         * @see TimeZone#getDefault()</b>
<i>1471</i>&nbsp;         */
<b class="nc"><i>1472</i>&nbsp;        public Calendar build() {</b>
<b class="nc"><i>1473</i>&nbsp;            if (locale == null) {</b>
<b class="nc"><i>1474</i>&nbsp;                locale = Locale.getDefault();</b>
<b class="nc"><i>1475</i>&nbsp;            }</b>
<i>1476</i>&nbsp;            if (zone == null) {
<b class="nc"><i>1477</i>&nbsp;                zone = defaultTimeZone(locale);</b>
<i>1478</i>&nbsp;            }
<i>1479</i>&nbsp;            Calendar cal;
<b class="nc"><i>1480</i>&nbsp;            if (type == null) {</b>
<i>1481</i>&nbsp;                type = locale.getUnicodeLocaleType(&quot;ca&quot;);
<b class="nc"><i>1482</i>&nbsp;            }</b>
<b class="nc"><i>1483</i>&nbsp;            if (type == null) {</b>
<i>1484</i>&nbsp;                if (locale.getCountry() == &quot;TH&quot;
<b class="nc"><i>1485</i>&nbsp;                    &amp;&amp; locale.getLanguage() == &quot;th&quot;) {</b>
<i>1486</i>&nbsp;                    type = &quot;buddhist&quot;;
<b class="nc"><i>1487</i>&nbsp;                } else {</b>
<i>1488</i>&nbsp;                    type = &quot;gregory&quot;;
<b class="nc"><i>1489</i>&nbsp;                }</b>
<b class="nc"><i>1490</i>&nbsp;            }</b>
<b class="nc"><i>1491</i>&nbsp;            switch (type) {</b>
<i>1492</i>&nbsp;            case &quot;gregory&quot;:
<b class="nc"><i>1493</i>&nbsp;                cal = new GregorianCalendar(zone, locale, true);</b>
<b class="nc"><i>1494</i>&nbsp;                break;</b>
<b class="nc"><i>1495</i>&nbsp;            case &quot;iso8601&quot;:</b>
<i>1496</i>&nbsp;                GregorianCalendar gcal = new GregorianCalendar(zone, locale, true);
<b class="nc"><i>1497</i>&nbsp;                // make gcal a proleptic Gregorian</b>
<b class="nc"><i>1498</i>&nbsp;                gcal.setGregorianChange(new Date(Long.MIN_VALUE));</b>
<i>1499</i>&nbsp;                // and week definition to be compatible with ISO 8601
<b class="nc"><i>1500</i>&nbsp;                setWeekDefinition(MONDAY, 4);</b>
<i>1501</i>&nbsp;                cal = gcal;
<b class="nc"><i>1502</i>&nbsp;                break;</b>
<b class="nc"><i>1503</i>&nbsp;            case &quot;buddhist&quot;:</b>
<b class="nc"><i>1504</i>&nbsp;                cal = new BuddhistCalendar(zone, locale);</b>
<b class="nc"><i>1505</i>&nbsp;                cal.clear();</b>
<i>1506</i>&nbsp;                break;
<b class="nc"><i>1507</i>&nbsp;            case &quot;japanese&quot;:</b>
<b class="nc"><i>1508</i>&nbsp;                cal = new JapaneseImperialCalendar(zone, locale, true);</b>
<b class="nc"><i>1509</i>&nbsp;                break;</b>
<b class="nc"><i>1510</i>&nbsp;            default:</b>
<i>1511</i>&nbsp;                throw new IllegalArgumentException(&quot;unknown calendar type: &quot; + type);
<i>1512</i>&nbsp;            }
<b class="nc"><i>1513</i>&nbsp;            cal.setLenient(lenient);</b>
<b class="nc"><i>1514</i>&nbsp;            if (firstDayOfWeek != 0) {</b>
<i>1515</i>&nbsp;                cal.setFirstDayOfWeek(firstDayOfWeek);
<b class="nc"><i>1516</i>&nbsp;                cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);</b>
<b class="nc"><i>1517</i>&nbsp;            }</b>
<i>1518</i>&nbsp;            if (isInstantSet()) {
<i>1519</i>&nbsp;                cal.setTimeInMillis(instant);
<i>1520</i>&nbsp;                cal.complete();
<i>1521</i>&nbsp;                return cal;
<b class="nc"><i>1522</i>&nbsp;            }</b>
<b class="nc"><i>1523</i>&nbsp;</b>
<b class="nc"><i>1524</i>&nbsp;            if (fields != null) {</b>
<b class="nc"><i>1525</i>&nbsp;                boolean weekDate = isSet(WEEK_YEAR)</b>
<b class="nc"><i>1526</i>&nbsp;                                       &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR];</b>
<i>1527</i>&nbsp;                if (weekDate &amp;&amp; !cal.isWeekDateSupported()) {
<i>1528</i>&nbsp;                    throw new IllegalArgumentException(&quot;week date is unsupported by &quot; + type);
<i>1529</i>&nbsp;                }
<i>1530</i>&nbsp;
<b class="nc"><i>1531</i>&nbsp;                // Set the fields from the min stamp to the max stamp so that</b>
<b class="nc"><i>1532</i>&nbsp;                // the fields resolution works in the Calendar.</b>
<b class="nc"><i>1533</i>&nbsp;                for (int stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) {</b>
<b class="nc"><i>1534</i>&nbsp;                    for (int index = 0; index &lt;= maxFieldIndex; index++) {</b>
<b class="nc"><i>1535</i>&nbsp;                        if (fields[index] == stamp) {</b>
<i>1536</i>&nbsp;                            cal.set(index, fields[NFIELDS + index]);
<b class="nc"><i>1537</i>&nbsp;                            break;</b>
<i>1538</i>&nbsp;                        }
<i>1539</i>&nbsp;                    }
<b class="nc"><i>1540</i>&nbsp;                }</b>
<i>1541</i>&nbsp;
<i>1542</i>&nbsp;                if (weekDate) {
<i>1543</i>&nbsp;                    int weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;
<b class="nc"><i>1544</i>&nbsp;                    int dayOfWeek = isSet(DAY_OF_WEEK)</b>
<b class="nc"><i>1545</i>&nbsp;                                    ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();</b>
<b class="nc"><i>1546</i>&nbsp;                    cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);</b>
<b class="nc"><i>1547</i>&nbsp;                }</b>
<i>1548</i>&nbsp;                cal.complete();
<i>1549</i>&nbsp;            }
<i>1550</i>&nbsp;
<i>1551</i>&nbsp;            return cal;
<b class="nc"><i>1552</i>&nbsp;        }</b>
<b class="nc"><i>1553</i>&nbsp;</b>
<b class="nc"><i>1554</i>&nbsp;        private void allocateFields() {</b>
<i>1555</i>&nbsp;            if (fields == null) {
<b class="nc"><i>1556</i>&nbsp;                fields = new int[NFIELDS * 2];</b>
<b class="nc"><i>1557</i>&nbsp;                nextStamp = MINIMUM_USER_STAMP;</b>
<b class="nc"><i>1558</i>&nbsp;                maxFieldIndex = -1;</b>
<i>1559</i>&nbsp;            }
<i>1560</i>&nbsp;        }
<i>1561</i>&nbsp;
<i>1562</i>&nbsp;        private void internalSet(int field, int value) {
<b class="nc"><i>1563</i>&nbsp;            fields[field] = nextStamp++;</b>
<i>1564</i>&nbsp;            if (nextStamp &lt; 0) {
<i>1565</i>&nbsp;                throw new IllegalStateException(&quot;stamp counter overflow&quot;);
<i>1566</i>&nbsp;            }
<b class="nc"><i>1567</i>&nbsp;            fields[NFIELDS + field] = value;</b>
<i>1568</i>&nbsp;            if (field &gt; maxFieldIndex &amp;&amp; field &lt; WEEK_YEAR) {
<i>1569</i>&nbsp;                maxFieldIndex = field;
<i>1570</i>&nbsp;            }
<b class="nc"><i>1571</i>&nbsp;        }</b>
<i>1572</i>&nbsp;
<i>1573</i>&nbsp;        private boolean isInstantSet() {
<i>1574</i>&nbsp;            return nextStamp == COMPUTED;
<i>1575</i>&nbsp;        }
<i>1576</i>&nbsp;
<i>1577</i>&nbsp;        private boolean isSet(int index) {
<i>1578</i>&nbsp;            return fields != null &amp;&amp; fields[index] &gt; UNSET;
<i>1579</i>&nbsp;        }
<i>1580</i>&nbsp;
<i>1581</i>&nbsp;        private boolean isValidWeekParameter(int value) {
<i>1582</i>&nbsp;            return value &gt; 0 &amp;&amp; value &lt;= 7;
<b class="nc"><i>1583</i>&nbsp;        }</b>
<b class="nc"><i>1584</i>&nbsp;    }</b>
<i>1585</i>&nbsp;
<i>1586</i>&nbsp;    /**
<i>1587</i>&nbsp;     * Constructs a Calendar with the default time zone
<i>1588</i>&nbsp;     * and the default {@link java.util.Locale.Category#FORMAT FORMAT}
<i>1589</i>&nbsp;     * locale.
<i>1590</i>&nbsp;     * @see     TimeZone#getDefault
<i>1591</i>&nbsp;     */
<i>1592</i>&nbsp;    protected Calendar()
<i>1593</i>&nbsp;    {
<b class="nc"><i>1594</i>&nbsp;        this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));</b>
<b class="nc"><i>1595</i>&nbsp;        sharedZone = true;</b>
<b class="nc"><i>1596</i>&nbsp;    }</b>
<b class="nc"><i>1597</i>&nbsp;</b>
<i>1598</i>&nbsp;    /**
<b class="nc"><i>1599</i>&nbsp;     * Constructs a calendar with the specified time zone and locale.</b>
<b class="nc"><i>1600</i>&nbsp;     *</b>
<i>1601</i>&nbsp;     * @param zone the time zone to use
<i>1602</i>&nbsp;     * @param aLocale the locale for the week data
<i>1603</i>&nbsp;     */
<i>1604</i>&nbsp;    protected Calendar(TimeZone zone, Locale aLocale)
<i>1605</i>&nbsp;    {
<i>1606</i>&nbsp;        fields = new int[FIELD_COUNT];
<i>1607</i>&nbsp;        isSet = new boolean[FIELD_COUNT];
<i>1608</i>&nbsp;        stamp = new int[FIELD_COUNT];
<i>1609</i>&nbsp;
<i>1610</i>&nbsp;        this.zone = zone;
<i>1611</i>&nbsp;        setWeekCountData(aLocale);
<i>1612</i>&nbsp;    }
<b class="nc"><i>1613</i>&nbsp;</b>
<i>1614</i>&nbsp;    /**
<i>1615</i>&nbsp;     * Gets a calendar using the default time zone and locale. The
<i>1616</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time
<i>1617</i>&nbsp;     * in the default time zone with the default
<i>1618</i>&nbsp;     * {@link Locale.Category#FORMAT FORMAT} locale.
<i>1619</i>&nbsp;     * &lt;p&gt;
<i>1620</i>&nbsp;     * If the locale contains the time zone with &quot;tz&quot;
<i>1621</i>&nbsp;     * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
<i>1622</i>&nbsp;     * that time zone is used instead.
<i>1623</i>&nbsp;     *
<i>1624</i>&nbsp;     * @return a Calendar.
<i>1625</i>&nbsp;     */
<i>1626</i>&nbsp;    public static Calendar getInstance()
<b class="nc"><i>1627</i>&nbsp;    {</b>
<i>1628</i>&nbsp;        Locale aLocale = Locale.getDefault(Locale.Category.FORMAT);
<i>1629</i>&nbsp;        return createCalendar(defaultTimeZone(aLocale), aLocale);
<i>1630</i>&nbsp;    }
<i>1631</i>&nbsp;
<i>1632</i>&nbsp;    /**
<i>1633</i>&nbsp;     * Gets a calendar using the specified time zone and default locale.
<i>1634</i>&nbsp;     * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time
<i>1635</i>&nbsp;     * in the given time zone with the default
<i>1636</i>&nbsp;     * {@link Locale.Category#FORMAT FORMAT} locale.
<i>1637</i>&nbsp;     *
<i>1638</i>&nbsp;     * @param zone the time zone to use
<i>1639</i>&nbsp;     * @return a Calendar.
<b class="nc"><i>1640</i>&nbsp;     */</b>
<i>1641</i>&nbsp;    public static Calendar getInstance(TimeZone zone)
<i>1642</i>&nbsp;    {
<i>1643</i>&nbsp;        return createCalendar(zone, Locale.getDefault(Locale.Category.FORMAT));
<i>1644</i>&nbsp;    }
<i>1645</i>&nbsp;
<i>1646</i>&nbsp;    /**
<i>1647</i>&nbsp;     * Gets a calendar using the default time zone and specified locale.
<i>1648</i>&nbsp;     * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time
<i>1649</i>&nbsp;     * in the default time zone with the given locale.
<i>1650</i>&nbsp;     * &lt;p&gt;
<i>1651</i>&nbsp;     * If the locale contains the time zone with &quot;tz&quot;
<i>1652</i>&nbsp;     * &lt;a href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
<i>1653</i>&nbsp;     * that time zone is used instead.
<i>1654</i>&nbsp;     *
<b class="nc"><i>1655</i>&nbsp;     * @param aLocale the locale for the week data</b>
<i>1656</i>&nbsp;     * @return a Calendar.
<i>1657</i>&nbsp;     */
<i>1658</i>&nbsp;    public static Calendar getInstance(Locale aLocale)
<i>1659</i>&nbsp;    {
<i>1660</i>&nbsp;        return createCalendar(defaultTimeZone(aLocale), aLocale);
<b class="nc"><i>1661</i>&nbsp;    }</b>
<b class="nc"><i>1662</i>&nbsp;</b>
<b class="nc"><i>1663</i>&nbsp;    /**</b>
<b class="nc"><i>1664</i>&nbsp;     * Gets a calendar with the specified time zone and locale.</b>
<i>1665</i>&nbsp;     * The &lt;code&gt;Calendar&lt;/code&gt; returned is based on the current time
<b class="nc"><i>1666</i>&nbsp;     * in the given time zone with the given locale.</b>
<b class="nc"><i>1667</i>&nbsp;     *</b>
<i>1668</i>&nbsp;     * @param zone the time zone to use
<i>1669</i>&nbsp;     * @param aLocale the locale for the week data
<i>1670</i>&nbsp;     * @return a Calendar.
<i>1671</i>&nbsp;     */
<b class="nc"><i>1672</i>&nbsp;    public static Calendar getInstance(TimeZone zone,</b>
<i>1673</i>&nbsp;                                       Locale aLocale)
<b class="nc"><i>1674</i>&nbsp;    {</b>
<b class="nc"><i>1675</i>&nbsp;        return createCalendar(zone, aLocale);</b>
<b class="nc"><i>1676</i>&nbsp;    }</b>
<b class="nc"><i>1677</i>&nbsp;</b>
<i>1678</i>&nbsp;    private static TimeZone defaultTimeZone(Locale l) {
<b class="nc"><i>1679</i>&nbsp;        TimeZone defaultTZ = TimeZone.getDefault();</b>
<b class="nc"><i>1680</i>&nbsp;        String shortTZID = l.getUnicodeLocaleType(&quot;tz&quot;);</b>
<i>1681</i>&nbsp;        return shortTZID != null ?
<b class="nc"><i>1682</i>&nbsp;            TimeZoneNameUtility.convertLDMLShortID(shortTZID)</b>
<b class="nc"><i>1683</i>&nbsp;                .map(TimeZone::getTimeZone)</b>
<i>1684</i>&nbsp;                .orElse(defaultTZ) :
<b class="nc"><i>1685</i>&nbsp;            defaultTZ;</b>
<i>1686</i>&nbsp;    }
<i>1687</i>&nbsp;
<i>1688</i>&nbsp;    private static Calendar createCalendar(TimeZone zone,
<i>1689</i>&nbsp;                                           Locale aLocale)
<b class="nc"><i>1690</i>&nbsp;    {</b>
<i>1691</i>&nbsp;        CalendarProvider provider =
<i>1692</i>&nbsp;            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
<i>1693</i>&nbsp;                                 .getCalendarProvider();
<i>1694</i>&nbsp;        if (provider != null) {
<i>1695</i>&nbsp;            try {
<i>1696</i>&nbsp;                return provider.getInstance(zone, aLocale);
<b class="nc"><i>1697</i>&nbsp;            } catch (IllegalArgumentException iae) {</b>
<b class="nc"><i>1698</i>&nbsp;                // fall back to the default instantiation</b>
<b class="nc"><i>1699</i>&nbsp;            }</b>
<b class="nc"><i>1700</i>&nbsp;        }</b>
<b class="nc"><i>1701</i>&nbsp;</b>
<i>1702</i>&nbsp;        Calendar cal = null;
<b class="nc"><i>1703</i>&nbsp;</b>
<i>1704</i>&nbsp;        if (aLocale.hasExtensions()) {
<i>1705</i>&nbsp;            String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);
<b class="nc"><i>1706</i>&nbsp;            if (caltype != null) {</b>
<i>1707</i>&nbsp;                switch (caltype) {
<i>1708</i>&nbsp;                case &quot;buddhist&quot;:
<i>1709</i>&nbsp;                cal = new BuddhistCalendar(zone, aLocale);
<i>1710</i>&nbsp;                    break;
<i>1711</i>&nbsp;                case &quot;japanese&quot;:
<i>1712</i>&nbsp;                    cal = new JapaneseImperialCalendar(zone, aLocale);
<i>1713</i>&nbsp;                    break;
<i>1714</i>&nbsp;                case &quot;gregory&quot;:
<i>1715</i>&nbsp;                    cal = new GregorianCalendar(zone, aLocale);
<i>1716</i>&nbsp;                    break;
<i>1717</i>&nbsp;                }
<i>1718</i>&nbsp;            }
<i>1719</i>&nbsp;        }
<b class="nc"><i>1720</i>&nbsp;        if (cal == null) {</b>
<i>1721</i>&nbsp;            // If no known calendar type is explicitly specified,
<i>1722</i>&nbsp;            // perform the traditional way to create a Calendar:
<i>1723</i>&nbsp;            // create a BuddhistCalendar for th_TH locale,
<i>1724</i>&nbsp;            // a JapaneseImperialCalendar for ja_JP_JP locale, or
<i>1725</i>&nbsp;            // a GregorianCalendar for any other locales.
<i>1726</i>&nbsp;            // NOTE: The language, country and variant strings are interned.
<i>1727</i>&nbsp;            if (aLocale.getLanguage() == &quot;th&quot; &amp;&amp; aLocale.getCountry() == &quot;TH&quot;) {
<i>1728</i>&nbsp;                cal = new BuddhistCalendar(zone, aLocale);
<i>1729</i>&nbsp;            } else if (aLocale.getVariant() == &quot;JP&quot; &amp;&amp; aLocale.getLanguage() == &quot;ja&quot;
<i>1730</i>&nbsp;                       &amp;&amp; aLocale.getCountry() == &quot;JP&quot;) {
<i>1731</i>&nbsp;                cal = new JapaneseImperialCalendar(zone, aLocale);
<i>1732</i>&nbsp;            } else {
<i>1733</i>&nbsp;                cal = new GregorianCalendar(zone, aLocale);
<i>1734</i>&nbsp;            }
<i>1735</i>&nbsp;        }
<i>1736</i>&nbsp;        return cal;
<i>1737</i>&nbsp;    }
<i>1738</i>&nbsp;
<i>1739</i>&nbsp;    /**
<i>1740</i>&nbsp;     * Returns an array of all locales for which the &lt;code&gt;getInstance&lt;/code&gt;
<i>1741</i>&nbsp;     * methods of this class can return localized instances.
<i>1742</i>&nbsp;     * The array returned must contain at least a &lt;code&gt;Locale&lt;/code&gt;
<i>1743</i>&nbsp;     * instance equal to {@link java.util.Locale#US Locale.US}.
<i>1744</i>&nbsp;     *
<i>1745</i>&nbsp;     * @return An array of locales for which localized
<i>1746</i>&nbsp;     *         &lt;code&gt;Calendar&lt;/code&gt; instances are available.
<i>1747</i>&nbsp;     */
<i>1748</i>&nbsp;    public static synchronized Locale[] getAvailableLocales()
<i>1749</i>&nbsp;    {
<i>1750</i>&nbsp;        return DateFormat.getAvailableLocales();
<i>1751</i>&nbsp;    }
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;    /**
<i>1754</i>&nbsp;     * Converts the current calendar field values in {@link #fields fields[]}
<b class="nc"><i>1755</i>&nbsp;     * to the millisecond time value</b>
<i>1756</i>&nbsp;     * {@link #time}.
<i>1757</i>&nbsp;     *
<i>1758</i>&nbsp;     * @see #complete()
<i>1759</i>&nbsp;     * @see #computeFields()
<i>1760</i>&nbsp;     */
<i>1761</i>&nbsp;    protected abstract void computeTime();
<i>1762</i>&nbsp;
<i>1763</i>&nbsp;    /**
<i>1764</i>&nbsp;     * Converts the current millisecond time value {@link #time}
<i>1765</i>&nbsp;     * to calendar field values in {@link #fields fields[]}.
<i>1766</i>&nbsp;     * This allows you to sync up the calendar field values with
<i>1767</i>&nbsp;     * a new time that is set for the calendar.  The time is &lt;em&gt;not&lt;/em&gt;
<i>1768</i>&nbsp;     * recomputed first; to recompute the time, then the fields, call the
<i>1769</i>&nbsp;     * {@link #complete()} method.
<b class="nc"><i>1770</i>&nbsp;     *</b>
<i>1771</i>&nbsp;     * @see #computeTime()
<i>1772</i>&nbsp;     */
<i>1773</i>&nbsp;    protected abstract void computeFields();
<i>1774</i>&nbsp;
<i>1775</i>&nbsp;    /**
<i>1776</i>&nbsp;     * Returns a &lt;code&gt;Date&lt;/code&gt; object representing this
<i>1777</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt;&#39;s time value (millisecond offset from the &lt;a
<i>1778</i>&nbsp;     * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;&quot;).
<i>1779</i>&nbsp;     *
<i>1780</i>&nbsp;     * @return a &lt;code&gt;Date&lt;/code&gt; representing the time value.
<b class="nc"><i>1781</i>&nbsp;     * @see #setTime(Date)</b>
<b class="nc"><i>1782</i>&nbsp;     * @see #getTimeInMillis()</b>
<i>1783</i>&nbsp;     */
<b class="nc"><i>1784</i>&nbsp;    public final Date getTime() {</b>
<i>1785</i>&nbsp;        return new Date(getTimeInMillis());
<i>1786</i>&nbsp;    }
<i>1787</i>&nbsp;
<i>1788</i>&nbsp;    /**
<i>1789</i>&nbsp;     * Sets this Calendar&#39;s time with the given &lt;code&gt;Date&lt;/code&gt;.
<i>1790</i>&nbsp;     * &lt;p&gt;
<i>1791</i>&nbsp;     * Note: Calling &lt;code&gt;setTime()&lt;/code&gt; with
<i>1792</i>&nbsp;     * &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt; or &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt;
<i>1793</i>&nbsp;     * may yield incorrect field values from &lt;code&gt;get()&lt;/code&gt;.
<i>1794</i>&nbsp;     *
<i>1795</i>&nbsp;     * @param date the given Date.
<i>1796</i>&nbsp;     * @see #getTime()
<b class="nc"><i>1797</i>&nbsp;     * @see #setTimeInMillis(long)</b>
<b class="nc"><i>1798</i>&nbsp;     */</b>
<i>1799</i>&nbsp;    public final void setTime(Date date) {
<i>1800</i>&nbsp;        setTimeInMillis(date.getTime());
<b class="nc"><i>1801</i>&nbsp;    }</b>
<b class="nc"><i>1802</i>&nbsp;</b>
<b class="nc"><i>1803</i>&nbsp;    /**</b>
<b class="nc"><i>1804</i>&nbsp;     * Returns this Calendar&#39;s time value in milliseconds.</b>
<b class="nc"><i>1805</i>&nbsp;     *</b>
<i>1806</i>&nbsp;     * @return the current time as UTC milliseconds from the epoch.
<i>1807</i>&nbsp;     * @see #getTime()
<i>1808</i>&nbsp;     * @see #setTimeInMillis(long)
<i>1809</i>&nbsp;     */
<i>1810</i>&nbsp;    public long getTimeInMillis() {
<i>1811</i>&nbsp;        if (!isTimeSet) {
<i>1812</i>&nbsp;            updateTime();
<i>1813</i>&nbsp;        }
<i>1814</i>&nbsp;        return time;
<i>1815</i>&nbsp;    }
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;    /**
<i>1818</i>&nbsp;     * Sets this Calendar&#39;s current time from the given long value.
<i>1819</i>&nbsp;     *
<i>1820</i>&nbsp;     * @param millis the new time in UTC milliseconds from the epoch.
<i>1821</i>&nbsp;     * @see #setTime(Date)
<i>1822</i>&nbsp;     * @see #getTimeInMillis()
<i>1823</i>&nbsp;     */
<i>1824</i>&nbsp;    public void setTimeInMillis(long millis) {
<i>1825</i>&nbsp;        // If we don&#39;t need to recalculate the calendar field values,
<b class="nc"><i>1826</i>&nbsp;        // do nothing.</b>
<b class="nc"><i>1827</i>&nbsp;        if (time == millis &amp;&amp; isTimeSet &amp;&amp; areFieldsSet &amp;&amp; areAllFieldsSet</b>
<i>1828</i>&nbsp;            &amp;&amp; (zone instanceof ZoneInfo) &amp;&amp; !((ZoneInfo)zone).isDirty()) {
<i>1829</i>&nbsp;            return;
<i>1830</i>&nbsp;        }
<i>1831</i>&nbsp;        time = millis;
<i>1832</i>&nbsp;        isTimeSet = true;
<i>1833</i>&nbsp;        areFieldsSet = false;
<i>1834</i>&nbsp;        computeFields();
<i>1835</i>&nbsp;        areAllFieldsSet = areFieldsSet = true;
<i>1836</i>&nbsp;    }
<i>1837</i>&nbsp;
<i>1838</i>&nbsp;    /**
<i>1839</i>&nbsp;     * Returns the value of the given calendar field. In lenient mode,
<b class="nc"><i>1840</i>&nbsp;     * all calendar fields are normalized. In non-lenient mode, all</b>
<i>1841</i>&nbsp;     * calendar fields are validated and this method throws an
<i>1842</i>&nbsp;     * exception if any calendar fields have out-of-range values. The
<i>1843</i>&nbsp;     * normalization and validation are handled by the
<i>1844</i>&nbsp;     * {@link #complete()} method, which process is calendar
<i>1845</i>&nbsp;     * system dependent.
<i>1846</i>&nbsp;     *
<i>1847</i>&nbsp;     * @param field the given calendar field.
<i>1848</i>&nbsp;     * @return the value for the given calendar field.
<i>1849</i>&nbsp;     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
<i>1850</i>&nbsp;     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
<i>1851</i>&nbsp;     * @see #set(int,int)
<i>1852</i>&nbsp;     * @see #complete()
<i>1853</i>&nbsp;     */
<i>1854</i>&nbsp;    public int get(int field)
<i>1855</i>&nbsp;    {
<i>1856</i>&nbsp;        complete();
<b class="nc"><i>1857</i>&nbsp;        return internalGet(field);</b>
<i>1858</i>&nbsp;    }
<i>1859</i>&nbsp;
<i>1860</i>&nbsp;    /**
<i>1861</i>&nbsp;     * Returns the value of the given calendar field. This method does
<i>1862</i>&nbsp;     * not involve normalization or validation of the field value.
<i>1863</i>&nbsp;     *
<i>1864</i>&nbsp;     * @param field the given calendar field.
<i>1865</i>&nbsp;     * @return the value for the given calendar field.
<i>1866</i>&nbsp;     * @see #get(int)
<i>1867</i>&nbsp;     */
<i>1868</i>&nbsp;    protected final int internalGet(int field)
<i>1869</i>&nbsp;    {
<i>1870</i>&nbsp;        return fields[field];
<i>1871</i>&nbsp;    }
<i>1872</i>&nbsp;
<i>1873</i>&nbsp;    /**
<i>1874</i>&nbsp;     * Sets the value of the given calendar field. This method does
<i>1875</i>&nbsp;     * not affect any setting state of the field in this
<i>1876</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; instance.
<i>1877</i>&nbsp;     *
<b class="nc"><i>1878</i>&nbsp;     * @throws IndexOutOfBoundsException if the specified field is out of range</b>
<b class="nc"><i>1879</i>&nbsp;     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).</b>
<i>1880</i>&nbsp;     * @see #areFieldsSet
<b class="nc"><i>1881</i>&nbsp;     * @see #isTimeSet</b>
<b class="nc"><i>1882</i>&nbsp;     * @see #areAllFieldsSet</b>
<b class="nc"><i>1883</i>&nbsp;     * @see #set(int,int)</b>
<b class="nc"><i>1884</i>&nbsp;     */</b>
<b class="nc"><i>1885</i>&nbsp;    final void internalSet(int field, int value)</b>
<b class="nc"><i>1886</i>&nbsp;    {</b>
<b class="nc"><i>1887</i>&nbsp;        fields[field] = value;</b>
<i>1888</i>&nbsp;    }
<i>1889</i>&nbsp;
<i>1890</i>&nbsp;    /**
<i>1891</i>&nbsp;     * Sets the given calendar field to the given value. The value is not
<i>1892</i>&nbsp;     * interpreted by this method regardless of the leniency mode.
<i>1893</i>&nbsp;     *
<i>1894</i>&nbsp;     * @param field the given calendar field.
<i>1895</i>&nbsp;     * @param value the value to be set for the given calendar field.
<i>1896</i>&nbsp;     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range
<i>1897</i>&nbsp;     *             (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
<i>1898</i>&nbsp;     * in non-lenient mode.
<i>1899</i>&nbsp;     * @see #set(int,int,int)
<i>1900</i>&nbsp;     * @see #set(int,int,int,int,int)
<i>1901</i>&nbsp;     * @see #set(int,int,int,int,int,int)
<i>1902</i>&nbsp;     * @see #get(int)
<i>1903</i>&nbsp;     */
<i>1904</i>&nbsp;    public void set(int field, int value)
<i>1905</i>&nbsp;    {
<i>1906</i>&nbsp;        // If the fields are partially normalized, calculate all the
<b class="nc"><i>1907</i>&nbsp;        // fields before changing any fields.</b>
<b class="nc"><i>1908</i>&nbsp;        if (areFieldsSet &amp;&amp; !areAllFieldsSet) {</b>
<b class="nc"><i>1909</i>&nbsp;            computeFields();</b>
<i>1910</i>&nbsp;        }
<i>1911</i>&nbsp;        internalSet(field, value);
<i>1912</i>&nbsp;        isTimeSet = false;
<i>1913</i>&nbsp;        areFieldsSet = false;
<i>1914</i>&nbsp;        isSet[field] = true;
<i>1915</i>&nbsp;        stamp[field] = nextStamp++;
<i>1916</i>&nbsp;        if (nextStamp == Integer.MAX_VALUE) {
<i>1917</i>&nbsp;            adjustStamp();
<i>1918</i>&nbsp;        }
<i>1919</i>&nbsp;    }
<i>1920</i>&nbsp;
<i>1921</i>&nbsp;    /**
<i>1922</i>&nbsp;     * Sets the values for the calendar fields &lt;code&gt;YEAR&lt;/code&gt;,
<i>1923</i>&nbsp;     * &lt;code&gt;MONTH&lt;/code&gt;, and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.
<i>1924</i>&nbsp;     * Previous values of other calendar fields are retained.  If this is not desired,
<i>1925</i>&nbsp;     * call {@link #clear()} first.
<i>1926</i>&nbsp;     *
<i>1927</i>&nbsp;     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.
<i>1928</i>&nbsp;     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.
<i>1929</i>&nbsp;     * Month value is 0-based. e.g., 0 for January.
<i>1930</i>&nbsp;     * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.
<b class="nc"><i>1931</i>&nbsp;     * @see #set(int,int)</b>
<b class="nc"><i>1932</i>&nbsp;     * @see #set(int,int,int,int,int)</b>
<b class="nc"><i>1933</i>&nbsp;     * @see #set(int,int,int,int,int,int)</b>
<b class="nc"><i>1934</i>&nbsp;     */</b>
<b class="nc"><i>1935</i>&nbsp;    public final void set(int year, int month, int date)</b>
<i>1936</i>&nbsp;    {
<i>1937</i>&nbsp;        set(YEAR, year);
<i>1938</i>&nbsp;        set(MONTH, month);
<i>1939</i>&nbsp;        set(DATE, date);
<i>1940</i>&nbsp;    }
<i>1941</i>&nbsp;
<i>1942</i>&nbsp;    /**
<i>1943</i>&nbsp;     * Sets the values for the calendar fields &lt;code&gt;YEAR&lt;/code&gt;,
<i>1944</i>&nbsp;     * &lt;code&gt;MONTH&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;,
<i>1945</i>&nbsp;     * &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;, and &lt;code&gt;MINUTE&lt;/code&gt;.
<i>1946</i>&nbsp;     * Previous values of other fields are retained.  If this is not desired,
<i>1947</i>&nbsp;     * call {@link #clear()} first.
<i>1948</i>&nbsp;     *
<i>1949</i>&nbsp;     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.
<i>1950</i>&nbsp;     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.
<i>1951</i>&nbsp;     * Month value is 0-based. e.g., 0 for January.
<i>1952</i>&nbsp;     * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.
<i>1953</i>&nbsp;     * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field.
<i>1954</i>&nbsp;     * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field.
<i>1955</i>&nbsp;     * @see #set(int,int)
<i>1956</i>&nbsp;     * @see #set(int,int,int)
<i>1957</i>&nbsp;     * @see #set(int,int,int,int,int,int)
<i>1958</i>&nbsp;     */
<b class="nc"><i>1959</i>&nbsp;    public final void set(int year, int month, int date, int hourOfDay, int minute)</b>
<b class="nc"><i>1960</i>&nbsp;    {</b>
<b class="nc"><i>1961</i>&nbsp;        set(YEAR, year);</b>
<b class="nc"><i>1962</i>&nbsp;        set(MONTH, month);</b>
<b class="nc"><i>1963</i>&nbsp;        set(DATE, date);</b>
<b class="nc"><i>1964</i>&nbsp;        set(HOUR_OF_DAY, hourOfDay);</b>
<i>1965</i>&nbsp;        set(MINUTE, minute);
<i>1966</i>&nbsp;    }
<i>1967</i>&nbsp;
<i>1968</i>&nbsp;    /**
<i>1969</i>&nbsp;     * Sets the values for the fields &lt;code&gt;YEAR&lt;/code&gt;, &lt;code&gt;MONTH&lt;/code&gt;,
<i>1970</i>&nbsp;     * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;, &lt;code&gt;HOUR_OF_DAY&lt;/code&gt;, &lt;code&gt;MINUTE&lt;/code&gt;, and
<i>1971</i>&nbsp;     * &lt;code&gt;SECOND&lt;/code&gt;.
<i>1972</i>&nbsp;     * Previous values of other fields are retained.  If this is not desired,
<i>1973</i>&nbsp;     * call {@link #clear()} first.
<i>1974</i>&nbsp;     *
<i>1975</i>&nbsp;     * @param year the value used to set the &lt;code&gt;YEAR&lt;/code&gt; calendar field.
<i>1976</i>&nbsp;     * @param month the value used to set the &lt;code&gt;MONTH&lt;/code&gt; calendar field.
<i>1977</i>&nbsp;     * Month value is 0-based. e.g., 0 for January.
<i>1978</i>&nbsp;     * @param date the value used to set the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; calendar field.
<i>1979</i>&nbsp;     * @param hourOfDay the value used to set the &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; calendar field.
<i>1980</i>&nbsp;     * @param minute the value used to set the &lt;code&gt;MINUTE&lt;/code&gt; calendar field.
<i>1981</i>&nbsp;     * @param second the value used to set the &lt;code&gt;SECOND&lt;/code&gt; calendar field.
<i>1982</i>&nbsp;     * @see #set(int,int)
<b class="nc"><i>1983</i>&nbsp;     * @see #set(int,int,int)</b>
<b class="nc"><i>1984</i>&nbsp;     * @see #set(int,int,int,int,int)</b>
<b class="nc"><i>1985</i>&nbsp;     */</b>
<i>1986</i>&nbsp;    public final void set(int year, int month, int date, int hourOfDay, int minute,
<b class="nc"><i>1987</i>&nbsp;                          int second)</b>
<b class="nc"><i>1988</i>&nbsp;    {</b>
<i>1989</i>&nbsp;        set(YEAR, year);
<i>1990</i>&nbsp;        set(MONTH, month);
<i>1991</i>&nbsp;        set(DATE, date);
<i>1992</i>&nbsp;        set(HOUR_OF_DAY, hourOfDay);
<i>1993</i>&nbsp;        set(MINUTE, minute);
<i>1994</i>&nbsp;        set(SECOND, second);
<i>1995</i>&nbsp;    }
<i>1996</i>&nbsp;
<i>1997</i>&nbsp;    /**
<i>1998</i>&nbsp;     * Sets all the calendar field values and the time value
<i>1999</i>&nbsp;     * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<i>2000</i>&nbsp;     * this &lt;code&gt;Calendar&lt;/code&gt; undefined. This means that {@link
<i>2001</i>&nbsp;     * #isSet(int) isSet()} will return &lt;code&gt;false&lt;/code&gt; for all the
<i>2002</i>&nbsp;     * calendar fields, and the date and time calculations will treat
<i>2003</i>&nbsp;     * the fields as if they had never been set. A
<i>2004</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; implementation class may use its specific
<i>2005</i>&nbsp;     * default field values for date/time calculations. For example,
<i>2006</i>&nbsp;     * &lt;code&gt;GregorianCalendar&lt;/code&gt; uses 1970 if the
<i>2007</i>&nbsp;     * &lt;code&gt;YEAR&lt;/code&gt; field value is undefined.
<i>2008</i>&nbsp;     *
<i>2009</i>&nbsp;     * @see #clear(int)
<i>2010</i>&nbsp;     */
<i>2011</i>&nbsp;    public final void clear()
<i>2012</i>&nbsp;    {
<i>2013</i>&nbsp;        for (int i = 0; i &lt; fields.length; ) {
<b class="nc"><i>2014</i>&nbsp;            stamp[i] = fields[i] = 0; // UNSET == 0</b>
<b class="nc"><i>2015</i>&nbsp;            isSet[i++] = false;</b>
<b class="nc"><i>2016</i>&nbsp;        }</b>
<i>2017</i>&nbsp;        areAllFieldsSet = areFieldsSet = false;
<b class="nc"><i>2018</i>&nbsp;        isTimeSet = false;</b>
<b class="nc"><i>2019</i>&nbsp;    }</b>
<i>2020</i>&nbsp;
<i>2021</i>&nbsp;    /**
<i>2022</i>&nbsp;     * Sets the given calendar field value and the time value
<i>2023</i>&nbsp;     * (millisecond offset from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) of
<i>2024</i>&nbsp;     * this &lt;code&gt;Calendar&lt;/code&gt; undefined. This means that {@link
<i>2025</i>&nbsp;     * #isSet(int) isSet(field)} will return &lt;code&gt;false&lt;/code&gt;, and
<i>2026</i>&nbsp;     * the date and time calculations will treat the field as if it
<i>2027</i>&nbsp;     * had never been set. A &lt;code&gt;Calendar&lt;/code&gt; implementation
<i>2028</i>&nbsp;     * class may use the field&#39;s specific default value for date and
<i>2029</i>&nbsp;     * time calculations.
<i>2030</i>&nbsp;     *
<i>2031</i>&nbsp;     * &lt;p&gt;The {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}
<i>2032</i>&nbsp;     * fields are handled independently and the &lt;a
<b class="nc"><i>2033</i>&nbsp;     * href=&quot;#time_resolution&quot;&gt;the resolution rule for the time of</b>
<i>2034</i>&nbsp;     * day&lt;/a&gt; is applied. Clearing one of the fields doesn&#39;t reset
<i>2035</i>&nbsp;     * the hour of day value of this &lt;code&gt;Calendar&lt;/code&gt;. Use {@link
<i>2036</i>&nbsp;     * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour
<i>2037</i>&nbsp;     * value.
<i>2038</i>&nbsp;     *
<i>2039</i>&nbsp;     * @param field the calendar field to be cleared.
<i>2040</i>&nbsp;     * @see #clear()
<i>2041</i>&nbsp;     */
<i>2042</i>&nbsp;    public final void clear(int field)
<i>2043</i>&nbsp;    {
<i>2044</i>&nbsp;        fields[field] = 0;
<i>2045</i>&nbsp;        stamp[field] = UNSET;
<i>2046</i>&nbsp;        isSet[field] = false;
<i>2047</i>&nbsp;
<i>2048</i>&nbsp;        areAllFieldsSet = areFieldsSet = false;
<i>2049</i>&nbsp;        isTimeSet = false;
<i>2050</i>&nbsp;    }
<i>2051</i>&nbsp;
<i>2052</i>&nbsp;    /**
<i>2053</i>&nbsp;     * Determines if the given calendar field has a value set,
<i>2054</i>&nbsp;     * including cases that the value has been set by internal fields
<i>2055</i>&nbsp;     * calculations triggered by a &lt;code&gt;get&lt;/code&gt; method call.
<i>2056</i>&nbsp;     *
<i>2057</i>&nbsp;     * @param field the calendar field to test
<i>2058</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the given calendar field has a value set;
<i>2059</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
<i>2060</i>&nbsp;     */
<i>2061</i>&nbsp;    public final boolean isSet(int field)
<i>2062</i>&nbsp;    {
<i>2063</i>&nbsp;        return stamp[field] != UNSET;
<i>2064</i>&nbsp;    }
<i>2065</i>&nbsp;
<i>2066</i>&nbsp;    /**
<i>2067</i>&nbsp;     * Returns the string representation of the calendar
<i>2068</i>&nbsp;     * &lt;code&gt;field&lt;/code&gt; value in the given &lt;code&gt;style&lt;/code&gt; and
<i>2069</i>&nbsp;     * &lt;code&gt;locale&lt;/code&gt;.  If no string representation is
<i>2070</i>&nbsp;     * applicable, &lt;code&gt;null&lt;/code&gt; is returned. This method calls
<i>2071</i>&nbsp;     * {@link Calendar#get(int) get(field)} to get the calendar
<i>2072</i>&nbsp;     * &lt;code&gt;field&lt;/code&gt; value if the string representation is
<i>2073</i>&nbsp;     * applicable to the given calendar &lt;code&gt;field&lt;/code&gt;.
<i>2074</i>&nbsp;     *
<i>2075</i>&nbsp;     * &lt;p&gt;For example, if this &lt;code&gt;Calendar&lt;/code&gt; is a
<i>2076</i>&nbsp;     * &lt;code&gt;GregorianCalendar&lt;/code&gt; and its date is 2005-01-01, then
<i>2077</i>&nbsp;     * the string representation of the {@link #MONTH} field would be
<i>2078</i>&nbsp;     * &quot;January&quot; in the long style in an English locale or &quot;Jan&quot; in
<i>2079</i>&nbsp;     * the short style. However, no string representation would be
<i>2080</i>&nbsp;     * available for the {@link #DAY_OF_MONTH} field, and this method
<b class="nc"><i>2081</i>&nbsp;     * would return &lt;code&gt;null&lt;/code&gt;.</b>
<i>2082</i>&nbsp;     *
<b class="nc"><i>2083</i>&nbsp;     * &lt;p&gt;The default implementation supports the calendar fields for</b>
<i>2084</i>&nbsp;     * which a {@link DateFormatSymbols} has names in the given
<i>2085</i>&nbsp;     * &lt;code&gt;locale&lt;/code&gt;.
<b class="nc"><i>2086</i>&nbsp;     *</b>
<b class="nc"><i>2087</i>&nbsp;     * @param field</b>
<i>2088</i>&nbsp;     *        the calendar field for which the string representation
<b class="nc"><i>2089</i>&nbsp;     *        is returned</b>
<b class="nc"><i>2090</i>&nbsp;     * @param style</b>
<i>2091</i>&nbsp;     *        the style applied to the string representation; one of {@link
<i>2092</i>&nbsp;     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},
<i>2093</i>&nbsp;     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},
<b class="nc"><i>2094</i>&nbsp;     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.</b>
<b class="nc"><i>2095</i>&nbsp;     * @param locale</b>
<b class="nc"><i>2096</i>&nbsp;     *        the locale for the string representation</b>
<i>2097</i>&nbsp;     *        (any calendar types specified by {@code locale} are ignored)
<b class="nc"><i>2098</i>&nbsp;     * @return the string representation of the given</b>
<i>2099</i>&nbsp;     *        {@code field} in the given {@code style}, or
<b class="nc"><i>2100</i>&nbsp;     *        {@code null} if no string representation is</b>
<b class="nc"><i>2101</i>&nbsp;     *        applicable.</b>
<i>2102</i>&nbsp;     * @exception IllegalArgumentException
<b class="nc"><i>2103</i>&nbsp;     *        if {@code field} or {@code style} is invalid,</b>
<i>2104</i>&nbsp;     *        or if this {@code Calendar} is non-lenient and any
<i>2105</i>&nbsp;     *        of the calendar fields have invalid values
<i>2106</i>&nbsp;     * @exception NullPointerException
<b class="nc"><i>2107</i>&nbsp;     *        if {@code locale} is null</b>
<i>2108</i>&nbsp;     * @since 1.6
<i>2109</i>&nbsp;     */
<b class="nc"><i>2110</i>&nbsp;    public String getDisplayName(int field, int style, Locale locale) {</b>
<b class="nc"><i>2111</i>&nbsp;        if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,</b>
<b class="nc"><i>2112</i>&nbsp;                            ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {</b>
<b class="nc"><i>2113</i>&nbsp;            return null;</b>
<b class="nc"><i>2114</i>&nbsp;        }</b>
<i>2115</i>&nbsp;
<i>2116</i>&nbsp;        String calendarType = getCalendarType();
<b class="nc"><i>2117</i>&nbsp;        int fieldValue = get(field);</b>
<i>2118</i>&nbsp;        // the standalone/narrow styles and short era are supported only through
<i>2119</i>&nbsp;        // CalendarNameProviders.
<i>2120</i>&nbsp;        if (isStandaloneStyle(style) || isNarrowFormatStyle(style) ||
<i>2121</i>&nbsp;            field == ERA &amp;&amp; (style &amp; SHORT) == SHORT) {
<i>2122</i>&nbsp;            String val = CalendarDataUtility.retrieveFieldValueName(calendarType,
<i>2123</i>&nbsp;                                                                    field, fieldValue,
<i>2124</i>&nbsp;                                                                    style, locale);
<i>2125</i>&nbsp;            // Perform fallback here to follow the CLDR rules
<i>2126</i>&nbsp;            if (val == null) {
<i>2127</i>&nbsp;                if (isNarrowFormatStyle(style)) {
<i>2128</i>&nbsp;                    val = CalendarDataUtility.retrieveFieldValueName(calendarType,
<i>2129</i>&nbsp;                                                                     field, fieldValue,
<i>2130</i>&nbsp;                                                                     toStandaloneStyle(style),
<i>2131</i>&nbsp;                                                                     locale);
<i>2132</i>&nbsp;                } else if (isStandaloneStyle(style)) {
<i>2133</i>&nbsp;                    val = CalendarDataUtility.retrieveFieldValueName(calendarType,
<i>2134</i>&nbsp;                                                                     field, fieldValue,
<i>2135</i>&nbsp;                                                                     getBaseStyle(style),
<i>2136</i>&nbsp;                                                                     locale);
<i>2137</i>&nbsp;                }
<i>2138</i>&nbsp;            }
<i>2139</i>&nbsp;            return val;
<i>2140</i>&nbsp;        }
<i>2141</i>&nbsp;
<i>2142</i>&nbsp;        DateFormatSymbols symbols = DateFormatSymbols.getInstance(locale);
<i>2143</i>&nbsp;        String[] strings = getFieldStrings(field, style, symbols);
<i>2144</i>&nbsp;        if (strings != null) {
<i>2145</i>&nbsp;            if (fieldValue &lt; strings.length) {
<i>2146</i>&nbsp;                return strings[fieldValue];
<i>2147</i>&nbsp;            }
<i>2148</i>&nbsp;        }
<i>2149</i>&nbsp;        return null;
<i>2150</i>&nbsp;    }
<i>2151</i>&nbsp;
<i>2152</i>&nbsp;    /**
<i>2153</i>&nbsp;     * Returns a {@code Map} containing all names of the calendar
<i>2154</i>&nbsp;     * {@code field} in the given {@code style} and
<i>2155</i>&nbsp;     * {@code locale} and their corresponding field values. For
<i>2156</i>&nbsp;     * example, if this {@code Calendar} is a {@link
<i>2157</i>&nbsp;     * GregorianCalendar}, the returned map would contain &quot;Jan&quot; to
<i>2158</i>&nbsp;     * {@link #JANUARY}, &quot;Feb&quot; to {@link #FEBRUARY}, and so on, in the
<i>2159</i>&nbsp;     * {@linkplain #SHORT short} style in an English locale.
<i>2160</i>&nbsp;     *
<i>2161</i>&nbsp;     * &lt;p&gt;Narrow names may not be unique due to use of single characters,
<i>2162</i>&nbsp;     * such as &quot;S&quot; for Sunday and Saturday. In that case narrow names are not
<i>2163</i>&nbsp;     * included in the returned {@code Map}.
<i>2164</i>&nbsp;     *
<i>2165</i>&nbsp;     * &lt;p&gt;The values of other calendar fields may be taken into
<i>2166</i>&nbsp;     * account to determine a set of display names. For example, if
<i>2167</i>&nbsp;     * this {@code Calendar} is a lunisolar calendar system and
<i>2168</i>&nbsp;     * the year value given by the {@link #YEAR} field has a leap
<i>2169</i>&nbsp;     * month, this method would return month names containing the leap
<b class="nc"><i>2170</i>&nbsp;     * month name, and month names are mapped to their values specific</b>
<i>2171</i>&nbsp;     * for the year.
<b class="nc"><i>2172</i>&nbsp;     *</b>
<i>2173</i>&nbsp;     * &lt;p&gt;The default implementation supports display names contained in
<i>2174</i>&nbsp;     * a {@link DateFormatSymbols}. For example, if {@code field}
<b class="nc"><i>2175</i>&nbsp;     * is {@link #MONTH} and {@code style} is {@link</b>
<b class="nc"><i>2176</i>&nbsp;     * #ALL_STYLES}, this method returns a {@code Map} containing</b>
<i>2177</i>&nbsp;     * all strings returned by {@link DateFormatSymbols#getShortMonths()}
<b class="nc"><i>2178</i>&nbsp;     * and {@link DateFormatSymbols#getMonths()}.</b>
<i>2179</i>&nbsp;     *
<i>2180</i>&nbsp;     * @param field
<b class="nc"><i>2181</i>&nbsp;     *        the calendar field for which the display names are returned</b>
<b class="nc"><i>2182</i>&nbsp;     * @param style</b>
<b class="nc"><i>2183</i>&nbsp;     *        the style applied to the string representation; one of {@link</b>
<b class="nc"><i>2184</i>&nbsp;     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},</b>
<b class="nc"><i>2185</i>&nbsp;     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},</b>
<b class="nc"><i>2186</i>&nbsp;     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}</b>
<b class="nc"><i>2187</i>&nbsp;     * @param locale</b>
<i>2188</i>&nbsp;     *        the locale for the display names
<i>2189</i>&nbsp;     * @return a {@code Map} containing all display names in
<b class="nc"><i>2190</i>&nbsp;     *        {@code style} and {@code locale} and their</b>
<i>2191</i>&nbsp;     *        field values, or {@code null} if no display names
<i>2192</i>&nbsp;     *        are defined for {@code field}
<i>2193</i>&nbsp;     * @exception IllegalArgumentException
<b class="nc"><i>2194</i>&nbsp;     *        if {@code field} or {@code style} is invalid,</b>
<i>2195</i>&nbsp;     *        or if this {@code Calendar} is non-lenient and any
<i>2196</i>&nbsp;     *        of the calendar fields have invalid values
<i>2197</i>&nbsp;     * @exception NullPointerException
<b class="nc"><i>2198</i>&nbsp;     *        if {@code locale} is null</b>
<b class="nc"><i>2199</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>2200</i>&nbsp;     */</b>
<b class="nc"><i>2201</i>&nbsp;    public Map&lt;String, Integer&gt; getDisplayNames(int field, int style, Locale locale) {</b>
<b class="nc"><i>2202</i>&nbsp;        if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,</b>
<b class="nc"><i>2203</i>&nbsp;                                    ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {</b>
<b class="nc"><i>2204</i>&nbsp;            return null;</b>
<i>2205</i>&nbsp;        }
<b class="nc"><i>2206</i>&nbsp;</b>
<i>2207</i>&nbsp;        String calendarType = getCalendarType();
<b class="nc"><i>2208</i>&nbsp;        if (style == ALL_STYLES || isStandaloneStyle(style) || isNarrowFormatStyle(style)) {</b>
<i>2209</i>&nbsp;            Map&lt;String, Integer&gt; map;
<b class="nc"><i>2210</i>&nbsp;            map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field, style, locale);</b>
<i>2211</i>&nbsp;
<i>2212</i>&nbsp;            // Perform fallback here to follow the CLDR rules
<i>2213</i>&nbsp;            if (map == null) {
<i>2214</i>&nbsp;                if (isNarrowFormatStyle(style)) {
<b class="nc"><i>2215</i>&nbsp;                    map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,</b>
<b class="nc"><i>2216</i>&nbsp;                                                                      toStandaloneStyle(style), locale);</b>
<i>2217</i>&nbsp;                } else if (style != ALL_STYLES) {
<b class="nc"><i>2218</i>&nbsp;                    map = CalendarDataUtility.retrieveFieldValueNames(calendarType, field,</b>
<i>2219</i>&nbsp;                                                                      getBaseStyle(style), locale);
<b class="nc"><i>2220</i>&nbsp;                }</b>
<b class="nc"><i>2221</i>&nbsp;            }</b>
<i>2222</i>&nbsp;            return map;
<b class="nc"><i>2223</i>&nbsp;        }</b>
<i>2224</i>&nbsp;
<i>2225</i>&nbsp;        // SHORT or LONG
<i>2226</i>&nbsp;        return getDisplayNamesImpl(field, style, locale);
<b class="nc"><i>2227</i>&nbsp;    }</b>
<i>2228</i>&nbsp;
<i>2229</i>&nbsp;    private Map&lt;String,Integer&gt; getDisplayNamesImpl(int field, int style, Locale locale) {
<b class="nc"><i>2230</i>&nbsp;        DateFormatSymbols symbols = DateFormatSymbols.getInstance(locale);</b>
<b class="nc"><i>2231</i>&nbsp;        String[] strings = getFieldStrings(field, style, symbols);</b>
<i>2232</i>&nbsp;        if (strings != null) {
<i>2233</i>&nbsp;            Map&lt;String,Integer&gt; names = new HashMap&lt;&gt;();
<b class="nc"><i>2234</i>&nbsp;            for (int i = 0; i &lt; strings.length; i++) {</b>
<b class="nc"><i>2235</i>&nbsp;                if (strings[i].length() == 0) {</b>
<i>2236</i>&nbsp;                    continue;
<b class="nc"><i>2237</i>&nbsp;                }</b>
<b class="nc"><i>2238</i>&nbsp;                names.put(strings[i], i);</b>
<i>2239</i>&nbsp;            }
<i>2240</i>&nbsp;            return names;
<b class="nc"><i>2241</i>&nbsp;        }</b>
<b class="nc"><i>2242</i>&nbsp;        return null;</b>
<i>2243</i>&nbsp;    }
<i>2244</i>&nbsp;
<b class="nc"><i>2245</i>&nbsp;    boolean checkDisplayNameParams(int field, int style, int minStyle, int maxStyle,</b>
<b class="nc"><i>2246</i>&nbsp;                                   Locale locale, int fieldMask) {</b>
<i>2247</i>&nbsp;        int baseStyle = getBaseStyle(style); // Ignore the standalone mask
<i>2248</i>&nbsp;        if (field &lt; 0 || field &gt;= fields.length ||
<b class="nc"><i>2249</i>&nbsp;            baseStyle &lt; minStyle || baseStyle &gt; maxStyle || baseStyle == 3) {</b>
<i>2250</i>&nbsp;            throw new IllegalArgumentException();
<i>2251</i>&nbsp;        }
<b class="nc"><i>2252</i>&nbsp;        if (locale == null) {</b>
<i>2253</i>&nbsp;            throw new NullPointerException();
<i>2254</i>&nbsp;        }
<i>2255</i>&nbsp;        return isFieldSet(fieldMask, field);
<i>2256</i>&nbsp;    }
<i>2257</i>&nbsp;
<i>2258</i>&nbsp;    private String[] getFieldStrings(int field, int style, DateFormatSymbols symbols) {
<i>2259</i>&nbsp;        int baseStyle = getBaseStyle(style); // ignore the standalone mask
<i>2260</i>&nbsp;
<i>2261</i>&nbsp;        // DateFormatSymbols doesn&#39;t support any narrow names.
<i>2262</i>&nbsp;        if (baseStyle == NARROW_FORMAT) {
<i>2263</i>&nbsp;            return null;
<b class="nc"><i>2264</i>&nbsp;        }</b>
<b class="nc"><i>2265</i>&nbsp;</b>
<i>2266</i>&nbsp;        String[] strings = null;
<b class="nc"><i>2267</i>&nbsp;        switch (field) {</b>
<b class="nc"><i>2268</i>&nbsp;        case ERA:</b>
<b class="nc"><i>2269</i>&nbsp;            strings = symbols.getEras();</b>
<i>2270</i>&nbsp;            break;
<i>2271</i>&nbsp;
<i>2272</i>&nbsp;        case MONTH:
<i>2273</i>&nbsp;            strings = (baseStyle == LONG) ? symbols.getMonths() : symbols.getShortMonths();
<i>2274</i>&nbsp;            break;
<i>2275</i>&nbsp;
<i>2276</i>&nbsp;        case DAY_OF_WEEK:
<i>2277</i>&nbsp;            strings = (baseStyle == LONG) ? symbols.getWeekdays() : symbols.getShortWeekdays();
<i>2278</i>&nbsp;            break;
<i>2279</i>&nbsp;
<i>2280</i>&nbsp;        case AM_PM:
<i>2281</i>&nbsp;            strings = symbols.getAmPmStrings();
<i>2282</i>&nbsp;            break;
<i>2283</i>&nbsp;        }
<i>2284</i>&nbsp;        return strings;
<i>2285</i>&nbsp;    }
<i>2286</i>&nbsp;
<b class="nc"><i>2287</i>&nbsp;    /**</b>
<i>2288</i>&nbsp;     * Fills in any unset fields in the calendar fields. First, the {@link
<i>2289</i>&nbsp;     * #computeTime()} method is called if the time value (millisecond offset
<i>2290</i>&nbsp;     * from the &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) has not been calculated from
<i>2291</i>&nbsp;     * calendar field values. Then, the {@link #computeFields()} method is
<i>2292</i>&nbsp;     * called to calculate all calendar field values.
<i>2293</i>&nbsp;     */
<i>2294</i>&nbsp;    protected void complete()
<i>2295</i>&nbsp;    {
<i>2296</i>&nbsp;        if (!isTimeSet) {
<b class="nc"><i>2297</i>&nbsp;            updateTime();</b>
<b class="nc"><i>2298</i>&nbsp;        }</b>
<b class="nc"><i>2299</i>&nbsp;        if (!areFieldsSet || !areAllFieldsSet) {</b>
<b class="nc"><i>2300</i>&nbsp;            computeFields(); // fills in unset fields</b>
<i>2301</i>&nbsp;            areAllFieldsSet = areFieldsSet = true;
<i>2302</i>&nbsp;        }
<b class="nc"><i>2303</i>&nbsp;    }</b>
<i>2304</i>&nbsp;
<i>2305</i>&nbsp;    /**
<i>2306</i>&nbsp;     * Returns whether the value of the specified calendar field has been set
<i>2307</i>&nbsp;     * externally by calling one of the setter methods rather than by the
<i>2308</i>&nbsp;     * internal time calculation.
<i>2309</i>&nbsp;     *
<i>2310</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the field has been set externally,
<i>2311</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
<i>2312</i>&nbsp;     * @exception IndexOutOfBoundsException if the specified
<i>2313</i>&nbsp;     *                &lt;code&gt;field&lt;/code&gt; is out of range
<i>2314</i>&nbsp;     *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
<i>2315</i>&nbsp;     * @see #selectFields()
<i>2316</i>&nbsp;     * @see #setFieldsComputed(int)
<i>2317</i>&nbsp;     */
<i>2318</i>&nbsp;    final boolean isExternallySet(int field) {
<i>2319</i>&nbsp;        return stamp[field] &gt;= MINIMUM_USER_STAMP;
<b class="nc"><i>2320</i>&nbsp;    }</b>
<b class="nc"><i>2321</i>&nbsp;</b>
<b class="nc"><i>2322</i>&nbsp;    /**</b>
<b class="nc"><i>2323</i>&nbsp;     * Returns a field mask (bit mask) indicating all calendar fields that</b>
<i>2324</i>&nbsp;     * have the state of externally or internally set.
<b class="nc"><i>2325</i>&nbsp;     *</b>
<i>2326</i>&nbsp;     * @return a bit mask indicating set state fields
<b class="nc"><i>2327</i>&nbsp;     */</b>
<b class="nc"><i>2328</i>&nbsp;    final int getSetStateFields() {</b>
<b class="nc"><i>2329</i>&nbsp;        int mask = 0;</b>
<b class="nc"><i>2330</i>&nbsp;        for (int i = 0; i &lt; fields.length; i++) {</b>
<i>2331</i>&nbsp;            if (stamp[i] != UNSET) {
<b class="nc"><i>2332</i>&nbsp;                mask |= 1 &lt;&lt; i;</b>
<b class="nc"><i>2333</i>&nbsp;            }</b>
<i>2334</i>&nbsp;        }
<i>2335</i>&nbsp;        return mask;
<b class="nc"><i>2336</i>&nbsp;    }</b>
<i>2337</i>&nbsp;
<i>2338</i>&nbsp;    /**
<i>2339</i>&nbsp;     * Sets the state of the specified calendar fields to
<i>2340</i>&nbsp;     * &lt;em&gt;computed&lt;/em&gt;. This state means that the specified calendar fields
<i>2341</i>&nbsp;     * have valid values that have been set by internal time calculation
<i>2342</i>&nbsp;     * rather than by calling one of the setter methods.
<i>2343</i>&nbsp;     *
<i>2344</i>&nbsp;     * @param fieldMask the field to be marked as computed.
<i>2345</i>&nbsp;     * @exception IndexOutOfBoundsException if the specified
<i>2346</i>&nbsp;     *                &lt;code&gt;field&lt;/code&gt; is out of range
<i>2347</i>&nbsp;     *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
<i>2348</i>&nbsp;     * @see #isExternallySet(int)
<i>2349</i>&nbsp;     * @see #selectFields()
<i>2350</i>&nbsp;     */
<i>2351</i>&nbsp;    final void setFieldsComputed(int fieldMask) {
<i>2352</i>&nbsp;        if (fieldMask == ALL_FIELDS) {
<i>2353</i>&nbsp;            for (int i = 0; i &lt; fields.length; i++) {
<i>2354</i>&nbsp;                stamp[i] = COMPUTED;
<i>2355</i>&nbsp;                isSet[i] = true;
<i>2356</i>&nbsp;            }
<b class="nc"><i>2357</i>&nbsp;            areFieldsSet = areAllFieldsSet = true;</b>
<b class="nc"><i>2358</i>&nbsp;        } else {</b>
<b class="nc"><i>2359</i>&nbsp;            for (int i = 0; i &lt; fields.length; i++) {</b>
<b class="nc"><i>2360</i>&nbsp;                if ((fieldMask &amp; 1) == 1) {</b>
<b class="nc"><i>2361</i>&nbsp;                    stamp[i] = COMPUTED;</b>
<i>2362</i>&nbsp;                    isSet[i] = true;
<b class="nc"><i>2363</i>&nbsp;                } else {</b>
<i>2364</i>&nbsp;                    if (areAllFieldsSet &amp;&amp; !isSet[i]) {
<i>2365</i>&nbsp;                        areAllFieldsSet = false;
<i>2366</i>&nbsp;                    }
<i>2367</i>&nbsp;                }
<i>2368</i>&nbsp;                fieldMask &gt;&gt;&gt;= 1;
<b class="nc"><i>2369</i>&nbsp;            }</b>
<b class="nc"><i>2370</i>&nbsp;        }</b>
<i>2371</i>&nbsp;    }
<i>2372</i>&nbsp;
<i>2373</i>&nbsp;    /**
<i>2374</i>&nbsp;     * Sets the state of the calendar fields that are &lt;em&gt;not&lt;/em&gt; specified
<i>2375</i>&nbsp;     * by &lt;code&gt;fieldMask&lt;/code&gt; to &lt;em&gt;unset&lt;/em&gt;. If &lt;code&gt;fieldMask&lt;/code&gt;
<i>2376</i>&nbsp;     * specifies all the calendar fields, then the state of this
<i>2377</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; becomes that all the calendar fields are in sync
<b class="nc"><i>2378</i>&nbsp;     * with the time value (millisecond offset from the Epoch).</b>
<i>2379</i>&nbsp;     *
<i>2380</i>&nbsp;     * @param fieldMask the field mask indicating which calendar fields are in
<i>2381</i>&nbsp;     * sync with the time value.
<i>2382</i>&nbsp;     * @exception IndexOutOfBoundsException if the specified
<i>2383</i>&nbsp;     *                &lt;code&gt;field&lt;/code&gt; is out of range
<i>2384</i>&nbsp;     *               (&lt;code&gt;field &amp;lt; 0 || field &amp;gt;= FIELD_COUNT&lt;/code&gt;).
<i>2385</i>&nbsp;     * @see #isExternallySet(int)
<b class="nc"><i>2386</i>&nbsp;     * @see #selectFields()</b>
<i>2387</i>&nbsp;     */
<i>2388</i>&nbsp;    final void setFieldsNormalized(int fieldMask) {
<i>2389</i>&nbsp;        if (fieldMask != ALL_FIELDS) {
<i>2390</i>&nbsp;            for (int i = 0; i &lt; fields.length; i++) {
<i>2391</i>&nbsp;                if ((fieldMask &amp; 1) == 0) {
<i>2392</i>&nbsp;                    stamp[i] = fields[i] = 0; // UNSET == 0
<b class="nc"><i>2393</i>&nbsp;                    isSet[i] = false;</b>
<i>2394</i>&nbsp;                }
<i>2395</i>&nbsp;                fieldMask &gt;&gt;= 1;
<i>2396</i>&nbsp;            }
<i>2397</i>&nbsp;        }
<i>2398</i>&nbsp;
<i>2399</i>&nbsp;        // Some or all of the fields are in sync with the
<i>2400</i>&nbsp;        // milliseconds, but the stamp values are not normalized yet.
<b class="nc"><i>2401</i>&nbsp;        areFieldsSet = true;</b>
<i>2402</i>&nbsp;        areAllFieldsSet = false;
<i>2403</i>&nbsp;    }
<i>2404</i>&nbsp;
<i>2405</i>&nbsp;    /**
<i>2406</i>&nbsp;     * Returns whether the calendar fields are partially in sync with the time
<i>2407</i>&nbsp;     * value or fully in sync but not stamp values are not normalized yet.
<i>2408</i>&nbsp;     */
<i>2409</i>&nbsp;    final boolean isPartiallyNormalized() {
<i>2410</i>&nbsp;        return areFieldsSet &amp;&amp; !areAllFieldsSet;
<i>2411</i>&nbsp;    }
<i>2412</i>&nbsp;
<i>2413</i>&nbsp;    /**
<i>2414</i>&nbsp;     * Returns whether the calendar fields are fully in sync with the time
<i>2415</i>&nbsp;     * value.
<i>2416</i>&nbsp;     */
<i>2417</i>&nbsp;    final boolean isFullyNormalized() {
<i>2418</i>&nbsp;        return areFieldsSet &amp;&amp; areAllFieldsSet;
<i>2419</i>&nbsp;    }
<i>2420</i>&nbsp;
<i>2421</i>&nbsp;    /**
<i>2422</i>&nbsp;     * Marks this Calendar as not sync&#39;d.
<i>2423</i>&nbsp;     */
<i>2424</i>&nbsp;    final void setUnnormalized() {
<i>2425</i>&nbsp;        areFieldsSet = areAllFieldsSet = false;
<i>2426</i>&nbsp;    }
<i>2427</i>&nbsp;
<i>2428</i>&nbsp;    /**
<i>2429</i>&nbsp;     * Returns whether the specified &lt;code&gt;field&lt;/code&gt; is on in the
<i>2430</i>&nbsp;     * &lt;code&gt;fieldMask&lt;/code&gt;.
<b class="nc"><i>2431</i>&nbsp;     */</b>
<i>2432</i>&nbsp;    static boolean isFieldSet(int fieldMask, int field) {
<b class="nc"><i>2433</i>&nbsp;        return (fieldMask &amp; (1 &lt;&lt; field)) != 0;</b>
<b class="nc"><i>2434</i>&nbsp;    }</b>
<i>2435</i>&nbsp;
<i>2436</i>&nbsp;    /**
<i>2437</i>&nbsp;     * Returns a field mask indicating which calendar field values
<i>2438</i>&nbsp;     * to be used to calculate the time value. The calendar fields are
<i>2439</i>&nbsp;     * returned as a bit mask, each bit of which corresponds to a field, i.e.,
<i>2440</i>&nbsp;     * the mask value of &lt;code&gt;field&lt;/code&gt; is &lt;code&gt;(1 &amp;lt;&amp;lt;
<i>2441</i>&nbsp;     * field)&lt;/code&gt;. For example, 0x26 represents the &lt;code&gt;YEAR&lt;/code&gt;,
<i>2442</i>&nbsp;     * &lt;code&gt;MONTH&lt;/code&gt;, and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields (i.e., 0x26 is
<i>2443</i>&nbsp;     * equal to
<i>2444</i>&nbsp;     * &lt;code&gt;(1&amp;lt;&amp;lt;YEAR)|(1&amp;lt;&amp;lt;MONTH)|(1&amp;lt;&amp;lt;DAY_OF_MONTH))&lt;/code&gt;.
<i>2445</i>&nbsp;     *
<i>2446</i>&nbsp;     * &lt;p&gt;This method supports the calendar fields resolution as described in
<i>2447</i>&nbsp;     * the class description. If the bit mask for a given field is on and its
<b class="nc"><i>2448</i>&nbsp;     * field has not been set (i.e., &lt;code&gt;isSet(field)&lt;/code&gt; is</b>
<b class="nc"><i>2449</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt;), then the default value of the field has to be</b>
<b class="nc"><i>2450</i>&nbsp;     * used, which case means that the field has been selected because the</b>
<b class="nc"><i>2451</i>&nbsp;     * selected combination involves the field.</b>
<b class="nc"><i>2452</i>&nbsp;     *</b>
<b class="nc"><i>2453</i>&nbsp;     * @return a bit mask of selected fields</b>
<b class="nc"><i>2454</i>&nbsp;     * @see #isExternallySet(int)</b>
<i>2455</i>&nbsp;     */
<b class="nc"><i>2456</i>&nbsp;    final int selectFields() {</b>
<b class="nc"><i>2457</i>&nbsp;        // This implementation has been taken from the GregorianCalendar class.</b>
<b class="nc"><i>2458</i>&nbsp;</b>
<i>2459</i>&nbsp;        // The YEAR field must always be used regardless of its SET
<b class="nc"><i>2460</i>&nbsp;        // state because YEAR is a mandatory field to determine the date</b>
<b class="nc"><i>2461</i>&nbsp;        // and the default value (EPOCH_YEAR) may change through the</b>
<i>2462</i>&nbsp;        // normalization process.
<b class="nc"><i>2463</i>&nbsp;        int fieldMask = YEAR_MASK;</b>
<b class="nc"><i>2464</i>&nbsp;</b>
<i>2465</i>&nbsp;        if (stamp[ERA] != UNSET) {
<b class="nc"><i>2466</i>&nbsp;            fieldMask |= ERA_MASK;</b>
<b class="nc"><i>2467</i>&nbsp;        }</b>
<i>2468</i>&nbsp;        // Find the most recent group of fields specifying the day within
<i>2469</i>&nbsp;        // the year.  These may be any of the following combinations:
<i>2470</i>&nbsp;        //   MONTH + DAY_OF_MONTH
<i>2471</i>&nbsp;        //   MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
<i>2472</i>&nbsp;        //   MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
<i>2473</i>&nbsp;        //   DAY_OF_YEAR
<b class="nc"><i>2474</i>&nbsp;        //   WEEK_OF_YEAR + DAY_OF_WEEK</b>
<b class="nc"><i>2475</i>&nbsp;        // We look for the most recent of the fields in each group to determine</b>
<b class="nc"><i>2476</i>&nbsp;        // the age of the group.  For groups involving a week-related field such</b>
<b class="nc"><i>2477</i>&nbsp;        // as WEEK_OF_MONTH, DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR, both the</b>
<b class="nc"><i>2478</i>&nbsp;        // week-related field and the DAY_OF_WEEK must be set for the group as a</b>
<i>2479</i>&nbsp;        // whole to be considered.  (See bug 4153860 - liu 7/24/98.)
<i>2480</i>&nbsp;        int dowStamp = stamp[DAY_OF_WEEK];
<i>2481</i>&nbsp;        int monthStamp = stamp[MONTH];
<i>2482</i>&nbsp;        int domStamp = stamp[DAY_OF_MONTH];
<i>2483</i>&nbsp;        int womStamp = aggregateStamp(stamp[WEEK_OF_MONTH], dowStamp);
<b class="nc"><i>2484</i>&nbsp;        int dowimStamp = aggregateStamp(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);</b>
<b class="nc"><i>2485</i>&nbsp;        int doyStamp = stamp[DAY_OF_YEAR];</b>
<i>2486</i>&nbsp;        int woyStamp = aggregateStamp(stamp[WEEK_OF_YEAR], dowStamp);
<i>2487</i>&nbsp;
<i>2488</i>&nbsp;        int bestStamp = domStamp;
<b class="nc"><i>2489</i>&nbsp;        if (womStamp &gt; bestStamp) {</b>
<i>2490</i>&nbsp;            bestStamp = womStamp;
<i>2491</i>&nbsp;        }
<b class="nc"><i>2492</i>&nbsp;        if (dowimStamp &gt; bestStamp) {</b>
<b class="nc"><i>2493</i>&nbsp;            bestStamp = dowimStamp;</b>
<b class="nc"><i>2494</i>&nbsp;        }</b>
<i>2495</i>&nbsp;        if (doyStamp &gt; bestStamp) {
<b class="nc"><i>2496</i>&nbsp;            bestStamp = doyStamp;</b>
<b class="nc"><i>2497</i>&nbsp;        }</b>
<b class="nc"><i>2498</i>&nbsp;        if (woyStamp &gt; bestStamp) {</b>
<i>2499</i>&nbsp;            bestStamp = woyStamp;
<b class="nc"><i>2500</i>&nbsp;        }</b>
<i>2501</i>&nbsp;
<i>2502</i>&nbsp;        /* No complete combination exists.  Look for WEEK_OF_MONTH,
<b class="nc"><i>2503</i>&nbsp;         * DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR alone.  Treat DAY_OF_WEEK alone</b>
<b class="nc"><i>2504</i>&nbsp;         * as DAY_OF_WEEK_IN_MONTH.</b>
<i>2505</i>&nbsp;         */
<b class="nc"><i>2506</i>&nbsp;        if (bestStamp == UNSET) {</b>
<i>2507</i>&nbsp;            womStamp = stamp[WEEK_OF_MONTH];
<i>2508</i>&nbsp;            dowimStamp = Math.max(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);
<b class="nc"><i>2509</i>&nbsp;            woyStamp = stamp[WEEK_OF_YEAR];</b>
<b class="nc"><i>2510</i>&nbsp;            bestStamp = Math.max(Math.max(womStamp, dowimStamp), woyStamp);</b>
<i>2511</i>&nbsp;
<b class="nc"><i>2512</i>&nbsp;            /* Treat MONTH alone or no fields at all as DAY_OF_MONTH.  This may</b>
<b class="nc"><i>2513</i>&nbsp;             * result in bestStamp = domStamp = UNSET if no fields are set,</b>
<b class="nc"><i>2514</i>&nbsp;             * which indicates DAY_OF_MONTH.</b>
<i>2515</i>&nbsp;             */
<i>2516</i>&nbsp;            if (bestStamp == UNSET) {
<i>2517</i>&nbsp;                bestStamp = domStamp = monthStamp;
<i>2518</i>&nbsp;            }
<i>2519</i>&nbsp;        }
<b class="nc"><i>2520</i>&nbsp;</b>
<i>2521</i>&nbsp;        if (bestStamp == domStamp ||
<b class="nc"><i>2522</i>&nbsp;           (bestStamp == womStamp &amp;&amp; stamp[WEEK_OF_MONTH] &gt;= stamp[WEEK_OF_YEAR]) ||</b>
<b class="nc"><i>2523</i>&nbsp;           (bestStamp == dowimStamp &amp;&amp; stamp[DAY_OF_WEEK_IN_MONTH] &gt;= stamp[WEEK_OF_YEAR])) {</b>
<i>2524</i>&nbsp;            fieldMask |= MONTH_MASK;
<b class="nc"><i>2525</i>&nbsp;            if (bestStamp == domStamp) {</b>
<b class="nc"><i>2526</i>&nbsp;                fieldMask |= DAY_OF_MONTH_MASK;</b>
<b class="nc"><i>2527</i>&nbsp;            } else {</b>
<i>2528</i>&nbsp;                assert (bestStamp == womStamp || bestStamp == dowimStamp);
<b class="nc"><i>2529</i>&nbsp;                if (dowStamp != UNSET) {</b>
<i>2530</i>&nbsp;                    fieldMask |= DAY_OF_WEEK_MASK;
<i>2531</i>&nbsp;                }
<i>2532</i>&nbsp;                if (womStamp == dowimStamp) {
<i>2533</i>&nbsp;                    // When they are equal, give the priority to
<i>2534</i>&nbsp;                    // WEEK_OF_MONTH for compatibility.
<i>2535</i>&nbsp;                    if (stamp[WEEK_OF_MONTH] &gt;= stamp[DAY_OF_WEEK_IN_MONTH]) {
<b class="nc"><i>2536</i>&nbsp;                        fieldMask |= WEEK_OF_MONTH_MASK;</b>
<b class="nc"><i>2537</i>&nbsp;                    } else {</b>
<b class="nc"><i>2538</i>&nbsp;                        fieldMask |= DAY_OF_WEEK_IN_MONTH_MASK;</b>
<i>2539</i>&nbsp;                    }
<i>2540</i>&nbsp;                } else {
<b class="nc"><i>2541</i>&nbsp;                    if (bestStamp == womStamp) {</b>
<b class="nc"><i>2542</i>&nbsp;                        fieldMask |= WEEK_OF_MONTH_MASK;</b>
<i>2543</i>&nbsp;                    } else {
<i>2544</i>&nbsp;                        assert (bestStamp == dowimStamp);
<i>2545</i>&nbsp;                        if (stamp[DAY_OF_WEEK_IN_MONTH] != UNSET) {
<b class="nc"><i>2546</i>&nbsp;                            fieldMask |= DAY_OF_WEEK_IN_MONTH_MASK;</b>
<b class="nc"><i>2547</i>&nbsp;                        }</b>
<b class="nc"><i>2548</i>&nbsp;                    }</b>
<i>2549</i>&nbsp;                }
<b class="nc"><i>2550</i>&nbsp;            }</b>
<b class="nc"><i>2551</i>&nbsp;        } else {</b>
<b class="nc"><i>2552</i>&nbsp;            assert (bestStamp == doyStamp || bestStamp == woyStamp ||</b>
<i>2553</i>&nbsp;                    bestStamp == UNSET);
<i>2554</i>&nbsp;            if (bestStamp == doyStamp) {
<i>2555</i>&nbsp;                fieldMask |= DAY_OF_YEAR_MASK;
<b class="nc"><i>2556</i>&nbsp;            } else {</b>
<b class="nc"><i>2557</i>&nbsp;                assert (bestStamp == woyStamp);</b>
<i>2558</i>&nbsp;                if (dowStamp != UNSET) {
<b class="nc"><i>2559</i>&nbsp;                    fieldMask |= DAY_OF_WEEK_MASK;</b>
<b class="nc"><i>2560</i>&nbsp;                }</b>
<i>2561</i>&nbsp;                fieldMask |= WEEK_OF_YEAR_MASK;
<b class="nc"><i>2562</i>&nbsp;            }</b>
<b class="nc"><i>2563</i>&nbsp;        }</b>
<i>2564</i>&nbsp;
<b class="nc"><i>2565</i>&nbsp;        // Find the best set of fields specifying the time of day.  There</b>
<b class="nc"><i>2566</i>&nbsp;        // are only two possibilities here; the HOUR_OF_DAY or the</b>
<i>2567</i>&nbsp;        // AM_PM and the HOUR.
<b class="nc"><i>2568</i>&nbsp;        int hourOfDayStamp = stamp[HOUR_OF_DAY];</b>
<b class="nc"><i>2569</i>&nbsp;        int hourStamp = aggregateStamp(stamp[HOUR], stamp[AM_PM]);</b>
<i>2570</i>&nbsp;        bestStamp = (hourStamp &gt; hourOfDayStamp) ? hourStamp : hourOfDayStamp;
<i>2571</i>&nbsp;
<b class="nc"><i>2572</i>&nbsp;        // if bestStamp is still UNSET, then take HOUR or AM_PM. (See 4846659)</b>
<i>2573</i>&nbsp;        if (bestStamp == UNSET) {
<i>2574</i>&nbsp;            bestStamp = Math.max(stamp[HOUR], stamp[AM_PM]);
<i>2575</i>&nbsp;        }
<b class="nc"><i>2576</i>&nbsp;</b>
<i>2577</i>&nbsp;        // Hours
<i>2578</i>&nbsp;        if (bestStamp != UNSET) {
<i>2579</i>&nbsp;            if (bestStamp == hourOfDayStamp) {
<b class="nc"><i>2580</i>&nbsp;                fieldMask |= HOUR_OF_DAY_MASK;</b>
<i>2581</i>&nbsp;            } else {
<i>2582</i>&nbsp;                fieldMask |= HOUR_MASK;
<i>2583</i>&nbsp;                if (stamp[AM_PM] != UNSET) {
<b class="nc"><i>2584</i>&nbsp;                    fieldMask |= AM_PM_MASK;</b>
<i>2585</i>&nbsp;                }
<i>2586</i>&nbsp;            }
<i>2587</i>&nbsp;        }
<b class="nc"><i>2588</i>&nbsp;        if (stamp[MINUTE] != UNSET) {</b>
<i>2589</i>&nbsp;            fieldMask |= MINUTE_MASK;
<i>2590</i>&nbsp;        }
<i>2591</i>&nbsp;        if (stamp[SECOND] != UNSET) {
<b class="nc"><i>2592</i>&nbsp;            fieldMask |= SECOND_MASK;</b>
<i>2593</i>&nbsp;        }
<i>2594</i>&nbsp;        if (stamp[MILLISECOND] != UNSET) {
<i>2595</i>&nbsp;            fieldMask |= MILLISECOND_MASK;
<i>2596</i>&nbsp;        }
<i>2597</i>&nbsp;        if (stamp[ZONE_OFFSET] &gt;= MINIMUM_USER_STAMP) {
<i>2598</i>&nbsp;                fieldMask |= ZONE_OFFSET_MASK;
<i>2599</i>&nbsp;        }
<i>2600</i>&nbsp;        if (stamp[DST_OFFSET] &gt;= MINIMUM_USER_STAMP) {
<i>2601</i>&nbsp;            fieldMask |= DST_OFFSET_MASK;
<b class="nc"><i>2602</i>&nbsp;        }</b>
<b class="nc"><i>2603</i>&nbsp;</b>
<i>2604</i>&nbsp;        return fieldMask;
<b class="nc"><i>2605</i>&nbsp;    }</b>
<i>2606</i>&nbsp;
<i>2607</i>&nbsp;    int getBaseStyle(int style) {
<i>2608</i>&nbsp;        return style &amp; ~STANDALONE_MASK;
<i>2609</i>&nbsp;    }
<i>2610</i>&nbsp;
<i>2611</i>&nbsp;    private int toStandaloneStyle(int style) {
<i>2612</i>&nbsp;        return style | STANDALONE_MASK;
<i>2613</i>&nbsp;    }
<i>2614</i>&nbsp;
<i>2615</i>&nbsp;    private boolean isStandaloneStyle(int style) {
<i>2616</i>&nbsp;        return (style &amp; STANDALONE_MASK) != 0;
<i>2617</i>&nbsp;    }
<i>2618</i>&nbsp;
<i>2619</i>&nbsp;    private boolean isNarrowStyle(int style) {
<i>2620</i>&nbsp;        return style == NARROW_FORMAT || style == NARROW_STANDALONE;
<i>2621</i>&nbsp;    }
<i>2622</i>&nbsp;
<i>2623</i>&nbsp;    private boolean isNarrowFormatStyle(int style) {
<b class="nc"><i>2624</i>&nbsp;        return style == NARROW_FORMAT;</b>
<i>2625</i>&nbsp;    }
<i>2626</i>&nbsp;
<b class="nc"><i>2627</i>&nbsp;    /**</b>
<i>2628</i>&nbsp;     * Returns the pseudo-time-stamp for two fields, given their
<i>2629</i>&nbsp;     * individual pseudo-time-stamps.  If either of the fields
<b class="nc"><i>2630</i>&nbsp;     * is unset, then the aggregate is unset.  Otherwise, the</b>
<b class="nc"><i>2631</i>&nbsp;     * aggregate is the later of the two stamps.</b>
<b class="nc"><i>2632</i>&nbsp;     */</b>
<b class="nc"><i>2633</i>&nbsp;    private static int aggregateStamp(int stamp_a, int stamp_b) {</b>
<b class="nc"><i>2634</i>&nbsp;        if (stamp_a == UNSET || stamp_b == UNSET) {</b>
<i>2635</i>&nbsp;            return UNSET;
<b class="nc"><i>2636</i>&nbsp;        }</b>
<i>2637</i>&nbsp;        return (stamp_a &gt; stamp_b) ? stamp_a : stamp_b;
<i>2638</i>&nbsp;    }
<i>2639</i>&nbsp;
<i>2640</i>&nbsp;    /**
<i>2641</i>&nbsp;     * Returns an unmodifiable {@code Set} containing all calendar types
<i>2642</i>&nbsp;     * supported by {@code Calendar} in the runtime environment. The available
<i>2643</i>&nbsp;     * calendar types can be used for the &lt;a
<i>2644</i>&nbsp;     * href=&quot;Locale.html#def_locale_extension&quot;&gt;Unicode locale extensions&lt;/a&gt;.
<i>2645</i>&nbsp;     * The {@code Set} returned contains at least {@code &quot;gregory&quot;}. The
<i>2646</i>&nbsp;     * calendar types don&#39;t include aliases, such as {@code &quot;gregorian&quot;} for
<i>2647</i>&nbsp;     * {@code &quot;gregory&quot;}.
<i>2648</i>&nbsp;     *
<i>2649</i>&nbsp;     * @return an unmodifiable {@code Set} containing all available calendar types
<i>2650</i>&nbsp;     * @since 1.8
<i>2651</i>&nbsp;     * @see #getCalendarType()
<i>2652</i>&nbsp;     * @see Calendar.Builder#setCalendarType(String)
<i>2653</i>&nbsp;     * @see Locale#getUnicodeLocaleType(String)
<i>2654</i>&nbsp;     */
<i>2655</i>&nbsp;    public static Set&lt;String&gt; getAvailableCalendarTypes() {
<i>2656</i>&nbsp;        return AvailableCalendarTypes.SET;
<i>2657</i>&nbsp;    }
<b class="nc"><i>2658</i>&nbsp;</b>
<i>2659</i>&nbsp;    private static class AvailableCalendarTypes {
<i>2660</i>&nbsp;        private static final Set&lt;String&gt; SET;
<i>2661</i>&nbsp;        static {
<i>2662</i>&nbsp;            Set&lt;String&gt; set = new HashSet&lt;&gt;(3);
<i>2663</i>&nbsp;            set.add(&quot;gregory&quot;);
<i>2664</i>&nbsp;            set.add(&quot;buddhist&quot;);
<i>2665</i>&nbsp;            set.add(&quot;japanese&quot;);
<i>2666</i>&nbsp;            SET = Collections.unmodifiableSet(set);
<i>2667</i>&nbsp;        }
<i>2668</i>&nbsp;        private AvailableCalendarTypes() {
<i>2669</i>&nbsp;        }
<i>2670</i>&nbsp;    }
<i>2671</i>&nbsp;
<i>2672</i>&nbsp;    /**
<i>2673</i>&nbsp;     * Returns the calendar type of this {@code Calendar}. Calendar types are
<i>2674</i>&nbsp;     * defined by the &lt;em&gt;Unicode Locale Data Markup Language (LDML)&lt;/em&gt;
<i>2675</i>&nbsp;     * specification.
<i>2676</i>&nbsp;     *
<i>2677</i>&nbsp;     * &lt;p&gt;The default implementation of this method returns the class name of
<i>2678</i>&nbsp;     * this {@code Calendar} instance. Any subclasses that implement
<i>2679</i>&nbsp;     * LDML-defined calendar systems should override this method to return
<i>2680</i>&nbsp;     * appropriate calendar types.
<i>2681</i>&nbsp;     *
<i>2682</i>&nbsp;     * @return the LDML-defined calendar type or the class name of this
<i>2683</i>&nbsp;     *         {@code Calendar} instance
<i>2684</i>&nbsp;     * @since 1.8
<i>2685</i>&nbsp;     * @see &lt;a href=&quot;Locale.html#def_extensions&quot;&gt;Locale extensions&lt;/a&gt;
<b class="nc"><i>2686</i>&nbsp;     * @see Locale.Builder#setLocale(Locale)</b>
<b class="nc"><i>2687</i>&nbsp;     * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)</b>
<i>2688</i>&nbsp;     */
<i>2689</i>&nbsp;    public String getCalendarType() {
<b class="nc"><i>2690</i>&nbsp;        return this.getClass().getName();</b>
<b class="nc"><i>2691</i>&nbsp;    }</b>
<i>2692</i>&nbsp;
<i>2693</i>&nbsp;    /**
<i>2694</i>&nbsp;     * Compares this &lt;code&gt;Calendar&lt;/code&gt; to the specified
<b class="nc"><i>2695</i>&nbsp;     * &lt;code&gt;Object&lt;/code&gt;.  The result is &lt;code&gt;true&lt;/code&gt; if and only if</b>
<b class="nc"><i>2696</i>&nbsp;     * the argument is a &lt;code&gt;Calendar&lt;/code&gt; object of the same calendar</b>
<i>2697</i>&nbsp;     * system that represents the same time value (millisecond offset from the
<i>2698</i>&nbsp;     * &lt;a href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) under the same
<i>2699</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; parameters as this object.
<i>2700</i>&nbsp;     *
<b class="nc"><i>2701</i>&nbsp;     * &lt;p&gt;The &lt;code&gt;Calendar&lt;/code&gt; parameters are the values represented</b>
<i>2702</i>&nbsp;     * by the &lt;code&gt;isLenient&lt;/code&gt;, &lt;code&gt;getFirstDayOfWeek&lt;/code&gt;,
<i>2703</i>&nbsp;     * &lt;code&gt;getMinimalDaysInFirstWeek&lt;/code&gt; and &lt;code&gt;getTimeZone&lt;/code&gt;
<i>2704</i>&nbsp;     * methods. If there is any difference in those parameters
<i>2705</i>&nbsp;     * between the two &lt;code&gt;Calendar&lt;/code&gt;s, this method returns
<i>2706</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt;.
<i>2707</i>&nbsp;     *
<i>2708</i>&nbsp;     * &lt;p&gt;Use the {@link #compareTo(Calendar) compareTo} method to
<i>2709</i>&nbsp;     * compare only the time values.
<i>2710</i>&nbsp;     *
<i>2711</i>&nbsp;     * @param obj the object to compare with.
<i>2712</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if this object is equal to &lt;code&gt;obj&lt;/code&gt;;
<b class="nc"><i>2713</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.</b>
<i>2714</i>&nbsp;     */
<i>2715</i>&nbsp;    @SuppressWarnings(&quot;EqualsWhichDoesntCheckParameterClass&quot;)
<b class="nc"><i>2716</i>&nbsp;    @Override</b>
<b class="nc"><i>2717</i>&nbsp;    public boolean equals(Object obj) {</b>
<b class="nc"><i>2718</i>&nbsp;        if (this == obj) {</b>
<i>2719</i>&nbsp;            return true;
<i>2720</i>&nbsp;        }
<i>2721</i>&nbsp;        try {
<i>2722</i>&nbsp;            Calendar that = (Calendar)obj;
<i>2723</i>&nbsp;            return compareTo(getMillisOf(that)) == 0 &amp;&amp;
<i>2724</i>&nbsp;                lenient == that.lenient &amp;&amp;
<i>2725</i>&nbsp;                firstDayOfWeek == that.firstDayOfWeek &amp;&amp;
<i>2726</i>&nbsp;                minimalDaysInFirstWeek == that.minimalDaysInFirstWeek &amp;&amp;
<i>2727</i>&nbsp;                zone.equals(that.zone);
<i>2728</i>&nbsp;        } catch (Exception e) {
<i>2729</i>&nbsp;            // Note: GregorianCalendar.computeTime throws
<i>2730</i>&nbsp;            // IllegalArgumentException if the ERA value is invalid
<i>2731</i>&nbsp;            // even it&#39;s in lenient mode.
<i>2732</i>&nbsp;        }
<i>2733</i>&nbsp;        return false;
<i>2734</i>&nbsp;    }
<i>2735</i>&nbsp;
<i>2736</i>&nbsp;    /**
<i>2737</i>&nbsp;     * Returns a hash code for this calendar.
<b class="nc"><i>2738</i>&nbsp;     *</b>
<b class="nc"><i>2739</i>&nbsp;     * @return a hash code value for this object.</b>
<i>2740</i>&nbsp;     * @since 1.2
<i>2741</i>&nbsp;     */
<i>2742</i>&nbsp;    @Override
<i>2743</i>&nbsp;    public int hashCode() {
<i>2744</i>&nbsp;        // &#39;otheritems&#39; represents the hash code for the previous versions.
<i>2745</i>&nbsp;        int otheritems = (lenient ? 1 : 0)
<i>2746</i>&nbsp;            | (firstDayOfWeek &lt;&lt; 1)
<i>2747</i>&nbsp;            | (minimalDaysInFirstWeek &lt;&lt; 4)
<i>2748</i>&nbsp;            | (zone.hashCode() &lt;&lt; 7);
<i>2749</i>&nbsp;        long t = getMillisOf(this);
<i>2750</i>&nbsp;        return (int) t ^ (int)(t &gt;&gt; 32) ^ otheritems;
<i>2751</i>&nbsp;    }
<i>2752</i>&nbsp;
<i>2753</i>&nbsp;    /**
<i>2754</i>&nbsp;     * Returns whether this &lt;code&gt;Calendar&lt;/code&gt; represents a time
<i>2755</i>&nbsp;     * before the time represented by the specified
<i>2756</i>&nbsp;     * &lt;code&gt;Object&lt;/code&gt;. This method is equivalent to:
<i>2757</i>&nbsp;     * &lt;pre&gt;{@code
<i>2758</i>&nbsp;     *         compareTo(when) &lt; 0
<b class="nc"><i>2759</i>&nbsp;     * }&lt;/pre&gt;</b>
<b class="nc"><i>2760</i>&nbsp;     * if and only if &lt;code&gt;when&lt;/code&gt; is a &lt;code&gt;Calendar&lt;/code&gt;</b>
<i>2761</i>&nbsp;     * instance. Otherwise, the method returns &lt;code&gt;false&lt;/code&gt;.
<i>2762</i>&nbsp;     *
<i>2763</i>&nbsp;     * @param when the &lt;code&gt;Object&lt;/code&gt; to be compared
<i>2764</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the time of this
<i>2765</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; is before the time represented by
<i>2766</i>&nbsp;     * &lt;code&gt;when&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
<i>2767</i>&nbsp;     * @see     #compareTo(Calendar)
<i>2768</i>&nbsp;     */
<i>2769</i>&nbsp;    public boolean before(Object when) {
<i>2770</i>&nbsp;        return when instanceof Calendar
<i>2771</i>&nbsp;            &amp;&amp; compareTo((Calendar)when) &lt; 0;
<i>2772</i>&nbsp;    }
<i>2773</i>&nbsp;
<i>2774</i>&nbsp;    /**
<i>2775</i>&nbsp;     * Returns whether this &lt;code&gt;Calendar&lt;/code&gt; represents a time
<i>2776</i>&nbsp;     * after the time represented by the specified
<i>2777</i>&nbsp;     * &lt;code&gt;Object&lt;/code&gt;. This method is equivalent to:
<i>2778</i>&nbsp;     * &lt;pre&gt;{@code
<i>2779</i>&nbsp;     *         compareTo(when) &gt; 0
<i>2780</i>&nbsp;     * }&lt;/pre&gt;
<i>2781</i>&nbsp;     * if and only if &lt;code&gt;when&lt;/code&gt; is a &lt;code&gt;Calendar&lt;/code&gt;
<i>2782</i>&nbsp;     * instance. Otherwise, the method returns &lt;code&gt;false&lt;/code&gt;.
<i>2783</i>&nbsp;     *
<b class="nc"><i>2784</i>&nbsp;     * @param when the &lt;code&gt;Object&lt;/code&gt; to be compared</b>
<i>2785</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is
<i>2786</i>&nbsp;     * after the time represented by &lt;code&gt;when&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;
<i>2787</i>&nbsp;     * otherwise.
<i>2788</i>&nbsp;     * @see     #compareTo(Calendar)
<i>2789</i>&nbsp;     */
<i>2790</i>&nbsp;    public boolean after(Object when) {
<i>2791</i>&nbsp;        return when instanceof Calendar
<i>2792</i>&nbsp;            &amp;&amp; compareTo((Calendar)when) &gt; 0;
<i>2793</i>&nbsp;    }
<i>2794</i>&nbsp;
<i>2795</i>&nbsp;    /**
<i>2796</i>&nbsp;     * Compares the time values (millisecond offsets from the &lt;a
<i>2797</i>&nbsp;     * href=&quot;#Epoch&quot;&gt;Epoch&lt;/a&gt;) represented by two
<i>2798</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; objects.
<i>2799</i>&nbsp;     *
<i>2800</i>&nbsp;     * @param anotherCalendar the &lt;code&gt;Calendar&lt;/code&gt; to be compared.
<i>2801</i>&nbsp;     * @return the value &lt;code&gt;0&lt;/code&gt; if the time represented by the argument
<i>2802</i>&nbsp;     * is equal to the time represented by this &lt;code&gt;Calendar&lt;/code&gt;; a value
<i>2803</i>&nbsp;     * less than &lt;code&gt;0&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is
<i>2804</i>&nbsp;     * before the time represented by the argument; and a value greater than
<i>2805</i>&nbsp;     * &lt;code&gt;0&lt;/code&gt; if the time of this &lt;code&gt;Calendar&lt;/code&gt; is after the
<i>2806</i>&nbsp;     * time represented by the argument.
<i>2807</i>&nbsp;     * @exception NullPointerException if the specified &lt;code&gt;Calendar&lt;/code&gt; is
<i>2808</i>&nbsp;     *            &lt;code&gt;null&lt;/code&gt;.
<i>2809</i>&nbsp;     * @exception IllegalArgumentException if the time value of the
<i>2810</i>&nbsp;     * specified &lt;code&gt;Calendar&lt;/code&gt; object can&#39;t be obtained due to
<i>2811</i>&nbsp;     * any invalid calendar values.
<i>2812</i>&nbsp;     * @since   1.5
<i>2813</i>&nbsp;     */
<i>2814</i>&nbsp;    @Override
<i>2815</i>&nbsp;    public int compareTo(Calendar anotherCalendar) {
<i>2816</i>&nbsp;        return compareTo(getMillisOf(anotherCalendar));
<i>2817</i>&nbsp;    }
<i>2818</i>&nbsp;
<i>2819</i>&nbsp;    /**
<i>2820</i>&nbsp;     * Adds or subtracts the specified amount of time to the given calendar field,
<i>2821</i>&nbsp;     * based on the calendar&#39;s rules. For example, to subtract 5 days from
<i>2822</i>&nbsp;     * the current time of the calendar, you can achieve it by calling:
<i>2823</i>&nbsp;     * &lt;p&gt;&lt;code&gt;add(Calendar.DAY_OF_MONTH, -5)&lt;/code&gt;.
<i>2824</i>&nbsp;     *
<i>2825</i>&nbsp;     * @param field the calendar field.
<i>2826</i>&nbsp;     * @param amount the amount of date or time to be added to the field.
<i>2827</i>&nbsp;     * @see #roll(int,int)
<i>2828</i>&nbsp;     * @see #set(int,int)
<i>2829</i>&nbsp;     */
<i>2830</i>&nbsp;    public abstract void add(int field, int amount);
<i>2831</i>&nbsp;
<i>2832</i>&nbsp;    /**
<i>2833</i>&nbsp;     * Adds or subtracts (up/down) a single unit of time on the given time
<i>2834</i>&nbsp;     * field without changing larger fields. For example, to roll the current
<i>2835</i>&nbsp;     * date up by one day, you can achieve it by calling:
<i>2836</i>&nbsp;     * &lt;p&gt;roll(Calendar.DATE, true).
<i>2837</i>&nbsp;     * When rolling on the year or Calendar.YEAR field, it will roll the year
<i>2838</i>&nbsp;     * value in the range between 1 and the value returned by calling
<i>2839</i>&nbsp;     * &lt;code&gt;getMaximum(Calendar.YEAR)&lt;/code&gt;.
<i>2840</i>&nbsp;     * When rolling on the month or Calendar.MONTH field, other fields like
<i>2841</i>&nbsp;     * date might conflict and, need to be changed. For instance,
<i>2842</i>&nbsp;     * rolling the month on the date 01/31/96 will result in 02/29/96.
<b class="nc"><i>2843</i>&nbsp;     * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will</b>
<b class="nc"><i>2844</i>&nbsp;     * roll the hour value in the range between 0 and 23, which is zero-based.</b>
<b class="nc"><i>2845</i>&nbsp;     *</b>
<i>2846</i>&nbsp;     * @param field the time field.
<b class="nc"><i>2847</i>&nbsp;     * @param up indicates if the value of the specified time field is to be</b>
<b class="nc"><i>2848</i>&nbsp;     * rolled up or rolled down. Use true if rolling up, false otherwise.</b>
<b class="nc"><i>2849</i>&nbsp;     * @see Calendar#add(int,int)</b>
<i>2850</i>&nbsp;     * @see Calendar#set(int,int)
<i>2851</i>&nbsp;     */
<i>2852</i>&nbsp;    public abstract void roll(int field, boolean up);
<i>2853</i>&nbsp;
<i>2854</i>&nbsp;    /**
<i>2855</i>&nbsp;     * Adds the specified (signed) amount to the specified calendar field
<i>2856</i>&nbsp;     * without changing larger fields.  A negative amount means to roll
<i>2857</i>&nbsp;     * down.
<i>2858</i>&nbsp;     *
<i>2859</i>&nbsp;     * &lt;p&gt;NOTE:  This default implementation on &lt;code&gt;Calendar&lt;/code&gt; just repeatedly calls the
<b class="nc"><i>2860</i>&nbsp;     * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not</b>
<b class="nc"><i>2861</i>&nbsp;     * always do the right thing.  For example, if the &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field is 31,</b>
<i>2862</i>&nbsp;     * rolling through February will leave it set to 28.  The &lt;code&gt;GregorianCalendar&lt;/code&gt;
<i>2863</i>&nbsp;     * version of this function takes care of this problem.  Other subclasses
<i>2864</i>&nbsp;     * should also provide overrides of this function that do the right thing.
<i>2865</i>&nbsp;     *
<i>2866</i>&nbsp;     * @param field the calendar field.
<i>2867</i>&nbsp;     * @param amount the signed amount to add to the calendar &lt;code&gt;field&lt;/code&gt;.
<i>2868</i>&nbsp;     * @since 1.2
<i>2869</i>&nbsp;     * @see #roll(int,boolean)
<i>2870</i>&nbsp;     * @see #add(int,int)
<b class="nc"><i>2871</i>&nbsp;     * @see #set(int,int)</b>
<i>2872</i>&nbsp;     */
<i>2873</i>&nbsp;    public void roll(int field, int amount)
<i>2874</i>&nbsp;    {
<i>2875</i>&nbsp;        while (amount &gt; 0) {
<i>2876</i>&nbsp;            roll(field, true);
<i>2877</i>&nbsp;            amount--;
<i>2878</i>&nbsp;        }
<i>2879</i>&nbsp;        while (amount &lt; 0) {
<i>2880</i>&nbsp;            roll(field, false);
<i>2881</i>&nbsp;            amount++;
<i>2882</i>&nbsp;        }
<b class="nc"><i>2883</i>&nbsp;    }</b>
<b class="nc"><i>2884</i>&nbsp;</b>
<b class="nc"><i>2885</i>&nbsp;    /**</b>
<i>2886</i>&nbsp;     * Sets the time zone with the given time zone value.
<b class="nc"><i>2887</i>&nbsp;     *</b>
<i>2888</i>&nbsp;     * @param value the given time zone.
<i>2889</i>&nbsp;     */
<i>2890</i>&nbsp;    public void setTimeZone(TimeZone value)
<i>2891</i>&nbsp;    {
<i>2892</i>&nbsp;        zone = value;
<i>2893</i>&nbsp;        sharedZone = false;
<b class="nc"><i>2894</i>&nbsp;        /* Recompute the fields from the time using the new zone.  This also</b>
<i>2895</i>&nbsp;         * works if isTimeSet is false (after a call to set()).  In that case
<i>2896</i>&nbsp;         * the time will be computed from the fields using the new zone, then
<i>2897</i>&nbsp;         * the fields will get recomputed from that.  Consider the sequence of
<i>2898</i>&nbsp;         * calls: cal.setTimeZone(EST); cal.set(HOUR, 1); cal.setTimeZone(PST).
<i>2899</i>&nbsp;         * Is cal set to 1 o&#39;clock EST or 1 o&#39;clock PST?  Answer: PST.  More
<i>2900</i>&nbsp;         * generally, a call to setTimeZone() affects calls to set() BEFORE AND
<b class="nc"><i>2901</i>&nbsp;         * AFTER it up to the next call to complete().</b>
<i>2902</i>&nbsp;         */
<i>2903</i>&nbsp;        areAllFieldsSet = areFieldsSet = false;
<i>2904</i>&nbsp;    }
<i>2905</i>&nbsp;
<i>2906</i>&nbsp;    /**
<i>2907</i>&nbsp;     * Gets the time zone.
<i>2908</i>&nbsp;     *
<i>2909</i>&nbsp;     * @return the time zone object associated with this calendar.
<i>2910</i>&nbsp;     */
<i>2911</i>&nbsp;    public TimeZone getTimeZone()
<i>2912</i>&nbsp;    {
<i>2913</i>&nbsp;        // If the TimeZone object is shared by other Calendar instances, then
<i>2914</i>&nbsp;        // create a clone.
<i>2915</i>&nbsp;        if (sharedZone) {
<i>2916</i>&nbsp;            zone = (TimeZone) zone.clone();
<i>2917</i>&nbsp;            sharedZone = false;
<b class="nc"><i>2918</i>&nbsp;        }</b>
<i>2919</i>&nbsp;        return zone;
<i>2920</i>&nbsp;    }
<i>2921</i>&nbsp;
<i>2922</i>&nbsp;    /**
<i>2923</i>&nbsp;     * Returns the time zone (without cloning).
<i>2924</i>&nbsp;     */
<i>2925</i>&nbsp;    TimeZone getZone() {
<i>2926</i>&nbsp;        return zone;
<i>2927</i>&nbsp;    }
<i>2928</i>&nbsp;
<i>2929</i>&nbsp;    /**
<b class="nc"><i>2930</i>&nbsp;     * Sets the sharedZone flag to &lt;code&gt;shared&lt;/code&gt;.</b>
<i>2931</i>&nbsp;     */
<i>2932</i>&nbsp;    void setZoneShared(boolean shared) {
<i>2933</i>&nbsp;        sharedZone = shared;
<i>2934</i>&nbsp;    }
<i>2935</i>&nbsp;
<i>2936</i>&nbsp;    /**
<i>2937</i>&nbsp;     * Specifies whether or not date/time interpretation is to be lenient.  With
<i>2938</i>&nbsp;     * lenient interpretation, a date such as &quot;February 942, 1996&quot; will be
<i>2939</i>&nbsp;     * treated as being equivalent to the 941st day after February 1, 1996.
<i>2940</i>&nbsp;     * With strict (non-lenient) interpretation, such dates will cause an exception to be
<i>2941</i>&nbsp;     * thrown. The default is lenient.
<i>2942</i>&nbsp;     *
<b class="nc"><i>2943</i>&nbsp;     * @param lenient &lt;code&gt;true&lt;/code&gt; if the lenient mode is to be turned</b>
<i>2944</i>&nbsp;     * on; &lt;code&gt;false&lt;/code&gt; if it is to be turned off.
<i>2945</i>&nbsp;     * @see #isLenient()
<b class="nc"><i>2946</i>&nbsp;     * @see java.text.DateFormat#setLenient</b>
<b class="nc"><i>2947</i>&nbsp;     */</b>
<i>2948</i>&nbsp;    public void setLenient(boolean lenient)
<i>2949</i>&nbsp;    {
<i>2950</i>&nbsp;        this.lenient = lenient;
<i>2951</i>&nbsp;    }
<i>2952</i>&nbsp;
<i>2953</i>&nbsp;    /**
<i>2954</i>&nbsp;     * Tells whether date/time interpretation is to be lenient.
<i>2955</i>&nbsp;     *
<i>2956</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the interpretation mode of this calendar is lenient;
<i>2957</i>&nbsp;     * &lt;code&gt;false&lt;/code&gt; otherwise.
<i>2958</i>&nbsp;     * @see #setLenient(boolean)
<i>2959</i>&nbsp;     */
<b class="nc"><i>2960</i>&nbsp;    public boolean isLenient()</b>
<i>2961</i>&nbsp;    {
<i>2962</i>&nbsp;        return lenient;
<i>2963</i>&nbsp;    }
<i>2964</i>&nbsp;
<i>2965</i>&nbsp;    /**
<i>2966</i>&nbsp;     * Sets what the first day of the week is; e.g., &lt;code&gt;SUNDAY&lt;/code&gt; in the U.S.,
<i>2967</i>&nbsp;     * &lt;code&gt;MONDAY&lt;/code&gt; in France.
<i>2968</i>&nbsp;     *
<i>2969</i>&nbsp;     * @param value the given first day of the week.
<i>2970</i>&nbsp;     * @see #getFirstDayOfWeek()
<i>2971</i>&nbsp;     * @see #getMinimalDaysInFirstWeek()
<i>2972</i>&nbsp;     */
<i>2973</i>&nbsp;    public void setFirstDayOfWeek(int value)
<i>2974</i>&nbsp;    {
<b class="nc"><i>2975</i>&nbsp;        if (firstDayOfWeek == value) {</b>
<i>2976</i>&nbsp;            return;
<i>2977</i>&nbsp;        }
<b class="nc"><i>2978</i>&nbsp;        firstDayOfWeek = value;</b>
<b class="nc"><i>2979</i>&nbsp;        invalidateWeekFields();</b>
<i>2980</i>&nbsp;    }
<i>2981</i>&nbsp;
<i>2982</i>&nbsp;    /**
<i>2983</i>&nbsp;     * Gets what the first day of the week is; e.g., &lt;code&gt;SUNDAY&lt;/code&gt; in the U.S.,
<i>2984</i>&nbsp;     * &lt;code&gt;MONDAY&lt;/code&gt; in France.
<i>2985</i>&nbsp;     *
<i>2986</i>&nbsp;     * @return the first day of the week.
<i>2987</i>&nbsp;     * @see #setFirstDayOfWeek(int)
<i>2988</i>&nbsp;     * @see #getMinimalDaysInFirstWeek()
<i>2989</i>&nbsp;     */
<i>2990</i>&nbsp;    public int getFirstDayOfWeek()
<i>2991</i>&nbsp;    {
<i>2992</i>&nbsp;        return firstDayOfWeek;
<i>2993</i>&nbsp;    }
<b class="nc"><i>2994</i>&nbsp;</b>
<i>2995</i>&nbsp;    /**
<i>2996</i>&nbsp;     * Sets what the minimal days required in the first week of the year are;
<i>2997</i>&nbsp;     * For example, if the first week is defined as one that contains the first
<i>2998</i>&nbsp;     * day of the first month of a year, call this method with value 1. If it
<i>2999</i>&nbsp;     * must be a full week, use value 7.
<i>3000</i>&nbsp;     *
<i>3001</i>&nbsp;     * @param value the given minimal days required in the first week
<i>3002</i>&nbsp;     * of the year.
<i>3003</i>&nbsp;     * @see #getMinimalDaysInFirstWeek()
<i>3004</i>&nbsp;     */
<i>3005</i>&nbsp;    public void setMinimalDaysInFirstWeek(int value)
<i>3006</i>&nbsp;    {
<i>3007</i>&nbsp;        if (minimalDaysInFirstWeek == value) {
<i>3008</i>&nbsp;            return;
<i>3009</i>&nbsp;        }
<b class="nc"><i>3010</i>&nbsp;        minimalDaysInFirstWeek = value;</b>
<i>3011</i>&nbsp;        invalidateWeekFields();
<i>3012</i>&nbsp;    }
<i>3013</i>&nbsp;
<i>3014</i>&nbsp;    /**
<i>3015</i>&nbsp;     * Gets what the minimal days required in the first week of the year are;
<i>3016</i>&nbsp;     * e.g., if the first week is defined as one that contains the first day
<i>3017</i>&nbsp;     * of the first month of a year, this method returns 1. If
<i>3018</i>&nbsp;     * the minimal days required must be a full week, this method
<i>3019</i>&nbsp;     * returns 7.
<i>3020</i>&nbsp;     *
<i>3021</i>&nbsp;     * @return the minimal days required in the first week of the year.
<i>3022</i>&nbsp;     * @see #setMinimalDaysInFirstWeek(int)
<i>3023</i>&nbsp;     */
<i>3024</i>&nbsp;    public int getMinimalDaysInFirstWeek()
<i>3025</i>&nbsp;    {
<i>3026</i>&nbsp;        return minimalDaysInFirstWeek;
<i>3027</i>&nbsp;    }
<i>3028</i>&nbsp;
<i>3029</i>&nbsp;    /**
<i>3030</i>&nbsp;     * Returns whether this {@code Calendar} supports week dates.
<i>3031</i>&nbsp;     *
<b class="nc"><i>3032</i>&nbsp;     * &lt;p&gt;The default implementation of this method returns {@code false}.</b>
<i>3033</i>&nbsp;     *
<i>3034</i>&nbsp;     * @return {@code true} if this {@code Calendar} supports week dates;
<i>3035</i>&nbsp;     *         {@code false} otherwise.
<i>3036</i>&nbsp;     * @see #getWeekYear()
<i>3037</i>&nbsp;     * @see #setWeekDate(int,int,int)
<i>3038</i>&nbsp;     * @see #getWeeksInWeekYear()
<i>3039</i>&nbsp;     * @since 1.7
<i>3040</i>&nbsp;     */
<i>3041</i>&nbsp;    public boolean isWeekDateSupported() {
<i>3042</i>&nbsp;        return false;
<i>3043</i>&nbsp;    }
<i>3044</i>&nbsp;
<i>3045</i>&nbsp;    /**
<i>3046</i>&nbsp;     * Returns the week year represented by this {@code Calendar}. The
<i>3047</i>&nbsp;     * week year is in sync with the week cycle. The {@linkplain
<i>3048</i>&nbsp;     * #getFirstDayOfWeek() first day of the first week} is the first
<i>3049</i>&nbsp;     * day of the week year.
<i>3050</i>&nbsp;     *
<i>3051</i>&nbsp;     * &lt;p&gt;The default implementation of this method throws an
<i>3052</i>&nbsp;     * {@link UnsupportedOperationException}.
<i>3053</i>&nbsp;     *
<i>3054</i>&nbsp;     * @return the week year of this {@code Calendar}
<i>3055</i>&nbsp;     * @exception UnsupportedOperationException
<i>3056</i>&nbsp;     *            if any week year numbering isn&#39;t supported
<i>3057</i>&nbsp;     *            in this {@code Calendar}.
<i>3058</i>&nbsp;     * @see #isWeekDateSupported()
<i>3059</i>&nbsp;     * @see #getFirstDayOfWeek()
<i>3060</i>&nbsp;     * @see #getMinimalDaysInFirstWeek()
<i>3061</i>&nbsp;     * @since 1.7
<i>3062</i>&nbsp;     */
<i>3063</i>&nbsp;    public int getWeekYear() {
<i>3064</i>&nbsp;        throw new UnsupportedOperationException();
<i>3065</i>&nbsp;    }
<i>3066</i>&nbsp;
<i>3067</i>&nbsp;    /**
<b class="nc"><i>3068</i>&nbsp;     * Sets the date of this {@code Calendar} with the given date</b>
<i>3069</i>&nbsp;     * specifiers - week year, week of year, and day of week.
<i>3070</i>&nbsp;     *
<i>3071</i>&nbsp;     * &lt;p&gt;Unlike the {@code set} method, all of the calendar fields
<i>3072</i>&nbsp;     * and {@code time} values are calculated upon return.
<i>3073</i>&nbsp;     *
<i>3074</i>&nbsp;     * &lt;p&gt;If {@code weekOfYear} is out of the valid week-of-year range
<i>3075</i>&nbsp;     * in {@code weekYear}, the {@code weekYear} and {@code
<i>3076</i>&nbsp;     * weekOfYear} values are adjusted in lenient mode, or an {@code
<i>3077</i>&nbsp;     * IllegalArgumentException} is thrown in non-lenient mode.
<i>3078</i>&nbsp;     *
<i>3079</i>&nbsp;     * &lt;p&gt;The default implementation of this method throws an
<i>3080</i>&nbsp;     * {@code UnsupportedOperationException}.
<i>3081</i>&nbsp;     *
<i>3082</i>&nbsp;     * @param weekYear   the week year
<i>3083</i>&nbsp;     * @param weekOfYear the week number based on {@code weekYear}
<i>3084</i>&nbsp;     * @param dayOfWeek  the day of week value: one of the constants
<i>3085</i>&nbsp;     *                   for the {@link #DAY_OF_WEEK} field: {@link
<i>3086</i>&nbsp;     *                   #SUNDAY}, ..., {@link #SATURDAY}.
<i>3087</i>&nbsp;     * @exception IllegalArgumentException
<i>3088</i>&nbsp;     *            if any of the given date specifiers is invalid
<b class="nc"><i>3089</i>&nbsp;     *            or any of the calendar fields are inconsistent</b>
<i>3090</i>&nbsp;     *            with the given date specifiers in non-lenient mode
<i>3091</i>&nbsp;     * @exception UnsupportedOperationException
<i>3092</i>&nbsp;     *            if any week year numbering isn&#39;t supported in this
<i>3093</i>&nbsp;     *            {@code Calendar}.
<i>3094</i>&nbsp;     * @see #isWeekDateSupported()
<i>3095</i>&nbsp;     * @see #getFirstDayOfWeek()
<i>3096</i>&nbsp;     * @see #getMinimalDaysInFirstWeek()
<i>3097</i>&nbsp;     * @since 1.7
<i>3098</i>&nbsp;     */
<i>3099</i>&nbsp;    public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {
<i>3100</i>&nbsp;        throw new UnsupportedOperationException();
<i>3101</i>&nbsp;    }
<i>3102</i>&nbsp;
<i>3103</i>&nbsp;    /**
<i>3104</i>&nbsp;     * Returns the number of weeks in the week year represented by this
<i>3105</i>&nbsp;     * {@code Calendar}.
<i>3106</i>&nbsp;     *
<i>3107</i>&nbsp;     * &lt;p&gt;The default implementation of this method throws an
<i>3108</i>&nbsp;     * {@code UnsupportedOperationException}.
<i>3109</i>&nbsp;     *
<i>3110</i>&nbsp;     * @return the number of weeks in the week year.
<i>3111</i>&nbsp;     * @exception UnsupportedOperationException
<i>3112</i>&nbsp;     *            if any week year numbering isn&#39;t supported in this
<i>3113</i>&nbsp;     *            {@code Calendar}.
<i>3114</i>&nbsp;     * @see #WEEK_OF_YEAR
<i>3115</i>&nbsp;     * @see #isWeekDateSupported()
<i>3116</i>&nbsp;     * @see #getWeekYear()
<i>3117</i>&nbsp;     * @see #getActualMaximum(int)
<i>3118</i>&nbsp;     * @since 1.7
<i>3119</i>&nbsp;     */
<i>3120</i>&nbsp;    public int getWeeksInWeekYear() {
<i>3121</i>&nbsp;        throw new UnsupportedOperationException();
<i>3122</i>&nbsp;    }
<i>3123</i>&nbsp;
<i>3124</i>&nbsp;    /**
<i>3125</i>&nbsp;     * Returns the minimum value for the given calendar field of this
<i>3126</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; instance. The minimum value is defined as
<i>3127</i>&nbsp;     * the smallest value returned by the {@link #get(int) get} method
<i>3128</i>&nbsp;     * for any possible time value.  The minimum value depends on
<i>3129</i>&nbsp;     * calendar system specific parameters of the instance.
<i>3130</i>&nbsp;     *
<i>3131</i>&nbsp;     * @param field the calendar field.
<i>3132</i>&nbsp;     * @return the minimum value for the given calendar field.
<i>3133</i>&nbsp;     * @see #getMaximum(int)
<i>3134</i>&nbsp;     * @see #getGreatestMinimum(int)
<i>3135</i>&nbsp;     * @see #getLeastMaximum(int)
<i>3136</i>&nbsp;     * @see #getActualMinimum(int)
<i>3137</i>&nbsp;     * @see #getActualMaximum(int)
<i>3138</i>&nbsp;     */
<i>3139</i>&nbsp;    public abstract int getMinimum(int field);
<i>3140</i>&nbsp;
<i>3141</i>&nbsp;    /**
<i>3142</i>&nbsp;     * Returns the maximum value for the given calendar field of this
<i>3143</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt; instance. The maximum value is defined as
<i>3144</i>&nbsp;     * the largest value returned by the {@link #get(int) get} method
<i>3145</i>&nbsp;     * for any possible time value. The maximum value depends on
<i>3146</i>&nbsp;     * calendar system specific parameters of the instance.
<i>3147</i>&nbsp;     *
<i>3148</i>&nbsp;     * @param field the calendar field.
<i>3149</i>&nbsp;     * @return the maximum value for the given calendar field.
<i>3150</i>&nbsp;     * @see #getMinimum(int)
<i>3151</i>&nbsp;     * @see #getGreatestMinimum(int)
<i>3152</i>&nbsp;     * @see #getLeastMaximum(int)
<i>3153</i>&nbsp;     * @see #getActualMinimum(int)
<i>3154</i>&nbsp;     * @see #getActualMaximum(int)
<i>3155</i>&nbsp;     */
<i>3156</i>&nbsp;    public abstract int getMaximum(int field);
<i>3157</i>&nbsp;
<i>3158</i>&nbsp;    /**
<i>3159</i>&nbsp;     * Returns the highest minimum value for the given calendar field
<i>3160</i>&nbsp;     * of this &lt;code&gt;Calendar&lt;/code&gt; instance. The highest minimum
<i>3161</i>&nbsp;     * value is defined as the largest value returned by {@link
<i>3162</i>&nbsp;     * #getActualMinimum(int)} for any possible time value. The
<i>3163</i>&nbsp;     * greatest minimum value depends on calendar system specific
<i>3164</i>&nbsp;     * parameters of the instance.
<i>3165</i>&nbsp;     *
<i>3166</i>&nbsp;     * @param field the calendar field.
<i>3167</i>&nbsp;     * @return the highest minimum value for the given calendar field.
<i>3168</i>&nbsp;     * @see #getMinimum(int)
<i>3169</i>&nbsp;     * @see #getMaximum(int)
<i>3170</i>&nbsp;     * @see #getLeastMaximum(int)
<i>3171</i>&nbsp;     * @see #getActualMinimum(int)
<i>3172</i>&nbsp;     * @see #getActualMaximum(int)
<i>3173</i>&nbsp;     */
<i>3174</i>&nbsp;    public abstract int getGreatestMinimum(int field);
<i>3175</i>&nbsp;
<i>3176</i>&nbsp;    /**
<i>3177</i>&nbsp;     * Returns the lowest maximum value for the given calendar field
<i>3178</i>&nbsp;     * of this &lt;code&gt;Calendar&lt;/code&gt; instance. The lowest maximum
<i>3179</i>&nbsp;     * value is defined as the smallest value returned by {@link
<i>3180</i>&nbsp;     * #getActualMaximum(int)} for any possible time value. The least
<i>3181</i>&nbsp;     * maximum value depends on calendar system specific parameters of
<i>3182</i>&nbsp;     * the instance. For example, a &lt;code&gt;Calendar&lt;/code&gt; for the
<i>3183</i>&nbsp;     * Gregorian calendar system returns 28 for the
<i>3184</i>&nbsp;     * &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; field, because the 28th is the last
<i>3185</i>&nbsp;     * day of the shortest month of this calendar, February in a
<i>3186</i>&nbsp;     * common year.
<b class="nc"><i>3187</i>&nbsp;     *</b>
<b class="nc"><i>3188</i>&nbsp;     * @param field the calendar field.</b>
<i>3189</i>&nbsp;     * @return the lowest maximum value for the given calendar field.
<i>3190</i>&nbsp;     * @see #getMinimum(int)
<b class="nc"><i>3191</i>&nbsp;     * @see #getMaximum(int)</b>
<b class="nc"><i>3192</i>&nbsp;     * @see #getGreatestMinimum(int)</b>
<i>3193</i>&nbsp;     * @see #getActualMinimum(int)
<i>3194</i>&nbsp;     * @see #getActualMaximum(int)
<i>3195</i>&nbsp;     */
<i>3196</i>&nbsp;    public abstract int getLeastMaximum(int field);
<b class="nc"><i>3197</i>&nbsp;</b>
<b class="nc"><i>3198</i>&nbsp;    /**</b>
<i>3199</i>&nbsp;     * Returns the minimum value that the specified calendar field
<i>3200</i>&nbsp;     * could have, given the time value of this &lt;code&gt;Calendar&lt;/code&gt;.
<i>3201</i>&nbsp;     *
<i>3202</i>&nbsp;     * &lt;p&gt;The default implementation of this method uses an iterative
<b class="nc"><i>3203</i>&nbsp;     * algorithm to determine the actual minimum value for the</b>
<i>3204</i>&nbsp;     * calendar field. Subclasses should, if possible, override this
<i>3205</i>&nbsp;     * with a more efficient implementation - in many cases, they can
<b class="nc"><i>3206</i>&nbsp;     * simply return &lt;code&gt;getMinimum()&lt;/code&gt;.</b>
<b class="nc"><i>3207</i>&nbsp;     *</b>
<b class="nc"><i>3208</i>&nbsp;     * @param field the calendar field</b>
<i>3209</i>&nbsp;     * @return the minimum of the given calendar field for the time
<b class="nc"><i>3210</i>&nbsp;     * value of this &lt;code&gt;Calendar&lt;/code&gt;</b>
<b class="nc"><i>3211</i>&nbsp;     * @see #getMinimum(int)</b>
<i>3212</i>&nbsp;     * @see #getMaximum(int)
<b class="nc"><i>3213</i>&nbsp;     * @see #getGreatestMinimum(int)</b>
<i>3214</i>&nbsp;     * @see #getLeastMaximum(int)
<b class="nc"><i>3215</i>&nbsp;     * @see #getActualMaximum(int)</b>
<i>3216</i>&nbsp;     * @since 1.2
<i>3217</i>&nbsp;     */
<i>3218</i>&nbsp;    public int getActualMinimum(int field) {
<i>3219</i>&nbsp;        int fieldValue = getGreatestMinimum(field);
<i>3220</i>&nbsp;        int endValue = getMinimum(field);
<i>3221</i>&nbsp;
<i>3222</i>&nbsp;        // if we know that the minimum value is always the same, just return it
<i>3223</i>&nbsp;        if (fieldValue == endValue) {
<i>3224</i>&nbsp;            return fieldValue;
<i>3225</i>&nbsp;        }
<i>3226</i>&nbsp;
<i>3227</i>&nbsp;        // clone the calendar so we don&#39;t mess with the real one, and set it to
<i>3228</i>&nbsp;        // accept anything for the field values
<i>3229</i>&nbsp;        Calendar work = (Calendar)this.clone();
<i>3230</i>&nbsp;        work.setLenient(true);
<i>3231</i>&nbsp;
<i>3232</i>&nbsp;        // now try each value from getLeastMaximum() to getMaximum() one by one until
<i>3233</i>&nbsp;        // we get a value that normalizes to another value.  The last value that
<i>3234</i>&nbsp;        // normalizes to itself is the actual minimum for the current date
<i>3235</i>&nbsp;        int result = fieldValue;
<i>3236</i>&nbsp;
<i>3237</i>&nbsp;        do {
<i>3238</i>&nbsp;            work.set(field, fieldValue);
<i>3239</i>&nbsp;            if (work.get(field) != fieldValue) {
<i>3240</i>&nbsp;                break;
<b class="nc"><i>3241</i>&nbsp;            } else {</b>
<b class="nc"><i>3242</i>&nbsp;                result = fieldValue;</b>
<i>3243</i>&nbsp;                fieldValue--;
<i>3244</i>&nbsp;            }
<b class="nc"><i>3245</i>&nbsp;        } while (fieldValue &gt;= endValue);</b>
<b class="nc"><i>3246</i>&nbsp;</b>
<i>3247</i>&nbsp;        return result;
<i>3248</i>&nbsp;    }
<i>3249</i>&nbsp;
<i>3250</i>&nbsp;    /**
<b class="nc"><i>3251</i>&nbsp;     * Returns the maximum value that the specified calendar field</b>
<b class="nc"><i>3252</i>&nbsp;     * could have, given the time value of this</b>
<i>3253</i>&nbsp;     * &lt;code&gt;Calendar&lt;/code&gt;. For example, the actual maximum value of
<i>3254</i>&nbsp;     * the &lt;code&gt;MONTH&lt;/code&gt; field is 12 in some years, and 13 in
<i>3255</i>&nbsp;     * other years in the Hebrew calendar system.
<b class="nc"><i>3256</i>&nbsp;     *</b>
<b class="nc"><i>3257</i>&nbsp;     * &lt;p&gt;The default implementation of this method uses an iterative</b>
<i>3258</i>&nbsp;     * algorithm to determine the actual maximum value for the
<i>3259</i>&nbsp;     * calendar field. Subclasses should, if possible, override this
<i>3260</i>&nbsp;     * with a more efficient implementation.
<i>3261</i>&nbsp;     *
<i>3262</i>&nbsp;     * @param field the calendar field
<b class="nc"><i>3263</i>&nbsp;     * @return the maximum of the given calendar field for the time</b>
<i>3264</i>&nbsp;     * value of this &lt;code&gt;Calendar&lt;/code&gt;
<i>3265</i>&nbsp;     * @see #getMinimum(int)
<b class="nc"><i>3266</i>&nbsp;     * @see #getMaximum(int)</b>
<b class="nc"><i>3267</i>&nbsp;     * @see #getGreatestMinimum(int)</b>
<b class="nc"><i>3268</i>&nbsp;     * @see #getLeastMaximum(int)</b>
<i>3269</i>&nbsp;     * @see #getActualMinimum(int)
<b class="nc"><i>3270</i>&nbsp;     * @since 1.2</b>
<b class="nc"><i>3271</i>&nbsp;     */</b>
<i>3272</i>&nbsp;    public int getActualMaximum(int field) {
<b class="nc"><i>3273</i>&nbsp;        int fieldValue = getLeastMaximum(field);</b>
<i>3274</i>&nbsp;        int endValue = getMaximum(field);
<b class="nc"><i>3275</i>&nbsp;</b>
<i>3276</i>&nbsp;        // if we know that the maximum value is always the same, just return it.
<i>3277</i>&nbsp;        if (fieldValue == endValue) {
<i>3278</i>&nbsp;            return fieldValue;
<i>3279</i>&nbsp;        }
<i>3280</i>&nbsp;
<i>3281</i>&nbsp;        // clone the calendar so we don&#39;t mess with the real one, and set it to
<i>3282</i>&nbsp;        // accept anything for the field values.
<i>3283</i>&nbsp;        Calendar work = (Calendar)this.clone();
<i>3284</i>&nbsp;        work.setLenient(true);
<i>3285</i>&nbsp;
<i>3286</i>&nbsp;        // if we&#39;re counting weeks, set the day of the week to Sunday.  We know the
<b class="nc"><i>3287</i>&nbsp;        // last week of a month or year will contain the first day of the week.</b>
<i>3288</i>&nbsp;        if (field == WEEK_OF_YEAR || field == WEEK_OF_MONTH) {
<b class="nc"><i>3289</i>&nbsp;            work.set(DAY_OF_WEEK, firstDayOfWeek);</b>
<b class="nc"><i>3290</i>&nbsp;        }</b>
<b class="nc"><i>3291</i>&nbsp;</b>
<b class="nc"><i>3292</i>&nbsp;        // now try each value from getLeastMaximum() to getMaximum() one by one until</b>
<b class="nc"><i>3293</i>&nbsp;        // we get a value that normalizes to another value.  The last value that</b>
<b class="nc"><i>3294</i>&nbsp;        // normalizes to itself is the actual maximum for the current date</b>
<b class="nc"><i>3295</i>&nbsp;        int result = fieldValue;</b>
<i>3296</i>&nbsp;
<b class="nc"><i>3297</i>&nbsp;        do {</b>
<b class="nc"><i>3298</i>&nbsp;            work.set(field, fieldValue);</b>
<i>3299</i>&nbsp;            if (work.get(field) != fieldValue) {
<b class="nc"><i>3300</i>&nbsp;                break;</b>
<i>3301</i>&nbsp;            } else {
<b class="nc"><i>3302</i>&nbsp;                result = fieldValue;</b>
<i>3303</i>&nbsp;                fieldValue++;
<i>3304</i>&nbsp;            }
<i>3305</i>&nbsp;        } while (fieldValue &lt;= endValue);
<b class="nc"><i>3306</i>&nbsp;</b>
<i>3307</i>&nbsp;        return result;
<i>3308</i>&nbsp;    }
<i>3309</i>&nbsp;
<i>3310</i>&nbsp;    /**
<i>3311</i>&nbsp;     * Creates and returns a copy of this object.
<i>3312</i>&nbsp;     *
<i>3313</i>&nbsp;     * @return a copy of this object.
<i>3314</i>&nbsp;     */
<i>3315</i>&nbsp;    @Override
<i>3316</i>&nbsp;    public Object clone()
<i>3317</i>&nbsp;    {
<i>3318</i>&nbsp;        try {
<i>3319</i>&nbsp;            Calendar other = (Calendar) super.clone();
<i>3320</i>&nbsp;
<i>3321</i>&nbsp;            other.fields = new int[FIELD_COUNT];
<b class="nc"><i>3322</i>&nbsp;            other.isSet = new boolean[FIELD_COUNT];</b>
<i>3323</i>&nbsp;            other.stamp = new int[FIELD_COUNT];
<i>3324</i>&nbsp;            for (int i = 0; i &lt; FIELD_COUNT; i++) {
<i>3325</i>&nbsp;                other.fields[i] = fields[i];
<i>3326</i>&nbsp;                other.stamp[i] = stamp[i];
<i>3327</i>&nbsp;                other.isSet[i] = isSet[i];
<i>3328</i>&nbsp;            }
<i>3329</i>&nbsp;            other.zone = (TimeZone) zone.clone();
<i>3330</i>&nbsp;            return other;
<i>3331</i>&nbsp;        }
<i>3332</i>&nbsp;        catch (CloneNotSupportedException e) {
<i>3333</i>&nbsp;            // this shouldn&#39;t happen, since we are Cloneable
<i>3334</i>&nbsp;            throw new InternalError(e);
<i>3335</i>&nbsp;        }
<i>3336</i>&nbsp;    }
<i>3337</i>&nbsp;
<i>3338</i>&nbsp;    private static final String[] FIELD_NAME = {
<b class="nc"><i>3339</i>&nbsp;        &quot;ERA&quot;, &quot;YEAR&quot;, &quot;MONTH&quot;, &quot;WEEK_OF_YEAR&quot;, &quot;WEEK_OF_MONTH&quot;, &quot;DAY_OF_MONTH&quot;,</b>
<b class="nc"><i>3340</i>&nbsp;        &quot;DAY_OF_YEAR&quot;, &quot;DAY_OF_WEEK&quot;, &quot;DAY_OF_WEEK_IN_MONTH&quot;, &quot;AM_PM&quot;, &quot;HOUR&quot;,</b>
<b class="nc"><i>3341</i>&nbsp;        &quot;HOUR_OF_DAY&quot;, &quot;MINUTE&quot;, &quot;SECOND&quot;, &quot;MILLISECOND&quot;, &quot;ZONE_OFFSET&quot;,</b>
<b class="nc"><i>3342</i>&nbsp;        &quot;DST_OFFSET&quot;</b>
<b class="nc"><i>3343</i>&nbsp;    };</b>
<b class="nc"><i>3344</i>&nbsp;</b>
<b class="nc"><i>3345</i>&nbsp;    /**</b>
<b class="nc"><i>3346</i>&nbsp;     * Returns the name of the specified calendar field.</b>
<b class="nc"><i>3347</i>&nbsp;     *</b>
<b class="nc"><i>3348</i>&nbsp;     * @param field the calendar field</b>
<b class="nc"><i>3349</i>&nbsp;     * @return the calendar field name</b>
<b class="nc"><i>3350</i>&nbsp;     * @exception IndexOutOfBoundsException if &lt;code&gt;field&lt;/code&gt; is negative,</b>
<i>3351</i>&nbsp;     * equal to or greater than {@code FIELD_COUNT}.
<b class="nc"><i>3352</i>&nbsp;     */</b>
<b class="nc"><i>3353</i>&nbsp;    static String getFieldName(int field) {</b>
<i>3354</i>&nbsp;        return FIELD_NAME[field];
<i>3355</i>&nbsp;    }
<i>3356</i>&nbsp;
<i>3357</i>&nbsp;    /**
<i>3358</i>&nbsp;     * Return a string representation of this calendar. This method
<b class="nc"><i>3359</i>&nbsp;     * is intended to be used only for debugging purposes, and the</b>
<b class="nc"><i>3360</i>&nbsp;     * format of the returned string may vary between implementations.</b>
<b class="nc"><i>3361</i>&nbsp;     * The returned string may be empty but may not be &lt;code&gt;null&lt;/code&gt;.</b>
<i>3362</i>&nbsp;     *
<b class="nc"><i>3363</i>&nbsp;     * @return  a string representation of this calendar.</b>
<i>3364</i>&nbsp;     */
<i>3365</i>&nbsp;    @Override
<i>3366</i>&nbsp;    public String toString() {
<i>3367</i>&nbsp;        // NOTE: BuddhistCalendar.toString() interprets the string
<i>3368</i>&nbsp;        // produced by this method so that the Gregorian year number
<i>3369</i>&nbsp;        // is substituted by its B.E. year value. It relies on
<i>3370</i>&nbsp;        // &quot;...,YEAR=&lt;year&gt;,...&quot; or &quot;...,YEAR=?,...&quot;.
<i>3371</i>&nbsp;        StringBuilder buffer = new StringBuilder(800);
<i>3372</i>&nbsp;        buffer.append(getClass().getName()).append(&#39;[&#39;);
<i>3373</i>&nbsp;        appendValue(buffer, &quot;time&quot;, isTimeSet, time);
<i>3374</i>&nbsp;        buffer.append(&quot;,areFieldsSet=&quot;).append(areFieldsSet);
<i>3375</i>&nbsp;        buffer.append(&quot;,areAllFieldsSet=&quot;).append(areAllFieldsSet);
<b class="nc"><i>3376</i>&nbsp;        buffer.append(&quot;,lenient=&quot;).append(lenient);</b>
<b class="nc"><i>3377</i>&nbsp;        buffer.append(&quot;,zone=&quot;).append(zone);</b>
<b class="nc"><i>3378</i>&nbsp;        appendValue(buffer, &quot;,firstDayOfWeek&quot;, true, (long) firstDayOfWeek);</b>
<b class="nc"><i>3379</i>&nbsp;        appendValue(buffer, &quot;,minimalDaysInFirstWeek&quot;, true, (long) minimalDaysInFirstWeek);</b>
<b class="nc"><i>3380</i>&nbsp;        for (int i = 0; i &lt; FIELD_COUNT; ++i) {</b>
<b class="nc"><i>3381</i>&nbsp;            buffer.append(&#39;,&#39;);</b>
<i>3382</i>&nbsp;            appendValue(buffer, FIELD_NAME[i], isSet(i), (long) fields[i]);
<b class="nc"><i>3383</i>&nbsp;        }</b>
<b class="nc"><i>3384</i>&nbsp;        buffer.append(&#39;]&#39;);</b>
<i>3385</i>&nbsp;        return buffer.toString();
<i>3386</i>&nbsp;    }
<i>3387</i>&nbsp;
<i>3388</i>&nbsp;    // =======================privates===============================
<i>3389</i>&nbsp;
<i>3390</i>&nbsp;    private static void appendValue(StringBuilder sb, String item, boolean valid, long value) {
<i>3391</i>&nbsp;        sb.append(item).append(&#39;=&#39;);
<i>3392</i>&nbsp;        if (valid) {
<b class="nc"><i>3393</i>&nbsp;            sb.append(value);</b>
<i>3394</i>&nbsp;        } else {
<i>3395</i>&nbsp;            sb.append(&#39;?&#39;);
<b class="nc"><i>3396</i>&nbsp;        }</b>
<i>3397</i>&nbsp;    }
<i>3398</i>&nbsp;
<i>3399</i>&nbsp;    /**
<b class="nc"><i>3400</i>&nbsp;     * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent.</b>
<b class="nc"><i>3401</i>&nbsp;     * They are used to figure out the week count for a specific date for</b>
<i>3402</i>&nbsp;     * a given locale. These must be set when a Calendar is constructed.
<i>3403</i>&nbsp;     * @param desiredLocale the given locale.
<i>3404</i>&nbsp;     */
<b class="nc"><i>3405</i>&nbsp;    private void setWeekCountData(Locale desiredLocale)</b>
<b class="nc"><i>3406</i>&nbsp;    {</b>
<i>3407</i>&nbsp;        /* try to get the Locale data from the cache */
<b class="nc"><i>3408</i>&nbsp;        int[] data = cachedLocaleData.get(desiredLocale);</b>
<b class="nc"><i>3409</i>&nbsp;        if (data == null) {  /* cache miss */</b>
<b class="nc"><i>3410</i>&nbsp;            data = new int[2];</b>
<i>3411</i>&nbsp;            data[0] = CalendarDataUtility.retrieveFirstDayOfWeek(desiredLocale);
<i>3412</i>&nbsp;            data[1] = CalendarDataUtility.retrieveMinimalDaysInFirstWeek(desiredLocale);
<i>3413</i>&nbsp;            cachedLocaleData.putIfAbsent(desiredLocale, data);
<i>3414</i>&nbsp;        }
<i>3415</i>&nbsp;        firstDayOfWeek = data[0];
<i>3416</i>&nbsp;        minimalDaysInFirstWeek = data[1];
<i>3417</i>&nbsp;    }
<b class="nc"><i>3418</i>&nbsp;</b>
<b class="nc"><i>3419</i>&nbsp;    /**</b>
<i>3420</i>&nbsp;     * Recomputes the time and updates the status fields isTimeSet
<i>3421</i>&nbsp;     * and areFieldsSet.  Callers should check isTimeSet and only
<b class="nc"><i>3422</i>&nbsp;     * call this method if isTimeSet is false.</b>
<b class="nc"><i>3423</i>&nbsp;     */</b>
<b class="nc"><i>3424</i>&nbsp;    private void updateTime() {</b>
<b class="nc"><i>3425</i>&nbsp;        computeTime();</b>
<b class="nc"><i>3426</i>&nbsp;        // The areFieldsSet and areAllFieldsSet values are no longer</b>
<i>3427</i>&nbsp;        // controlled here (as of 1.5).
<b class="nc"><i>3428</i>&nbsp;        isTimeSet = true;</b>
<b class="nc"><i>3429</i>&nbsp;    }</b>
<i>3430</i>&nbsp;
<i>3431</i>&nbsp;    private int compareTo(long t) {
<b class="nc"><i>3432</i>&nbsp;        long thisTime = getMillisOf(this);</b>
<b class="nc"><i>3433</i>&nbsp;        return (thisTime &gt; t) ? 1 : (thisTime == t) ? 0 : -1;</b>
<i>3434</i>&nbsp;    }
<b class="nc"><i>3435</i>&nbsp;</b>
<b class="nc"><i>3436</i>&nbsp;    private static long getMillisOf(Calendar calendar) {</b>
<b class="nc"><i>3437</i>&nbsp;        if (calendar.isTimeSet) {</b>
<i>3438</i>&nbsp;            return calendar.time;
<i>3439</i>&nbsp;        }
<b class="nc"><i>3440</i>&nbsp;        Calendar cal = (Calendar) calendar.clone();</b>
<b class="nc"><i>3441</i>&nbsp;        cal.setLenient(true);</b>
<b class="nc"><i>3442</i>&nbsp;        return cal.getTimeInMillis();</b>
<i>3443</i>&nbsp;    }
<b class="nc"><i>3444</i>&nbsp;</b>
<b class="nc"><i>3445</i>&nbsp;    /**</b>
<i>3446</i>&nbsp;     * Adjusts the stamp[] values before nextStamp overflow. nextStamp
<i>3447</i>&nbsp;     * is set to the next stamp value upon the return.
<i>3448</i>&nbsp;     */
<i>3449</i>&nbsp;    private void adjustStamp() {
<i>3450</i>&nbsp;        int max = MINIMUM_USER_STAMP;
<i>3451</i>&nbsp;        int newStamp = MINIMUM_USER_STAMP;
<i>3452</i>&nbsp;
<i>3453</i>&nbsp;        for (;;) {
<b class="nc"><i>3454</i>&nbsp;            int min = Integer.MAX_VALUE;</b>
<i>3455</i>&nbsp;            for (int v : stamp) {
<i>3456</i>&nbsp;                if (v &gt;= newStamp &amp;&amp; min &gt; v) {
<i>3457</i>&nbsp;                    min = v;
<i>3458</i>&nbsp;                }
<i>3459</i>&nbsp;                if (max &lt; v) {
<i>3460</i>&nbsp;                    max = v;
<i>3461</i>&nbsp;                }
<b class="nc"><i>3462</i>&nbsp;            }</b>
<b class="nc"><i>3463</i>&nbsp;            if (max != min &amp;&amp; min == Integer.MAX_VALUE) {</b>
<b class="nc"><i>3464</i>&nbsp;                break;</b>
<b class="nc"><i>3465</i>&nbsp;            }</b>
<i>3466</i>&nbsp;            for (int i = 0; i &lt; stamp.length; i++) {
<b class="nc"><i>3467</i>&nbsp;                if (stamp[i] == min) {</b>
<b class="nc"><i>3468</i>&nbsp;                    stamp[i] = newStamp;</b>
<b class="nc"><i>3469</i>&nbsp;                }</b>
<b class="nc"><i>3470</i>&nbsp;            }</b>
<i>3471</i>&nbsp;            newStamp++;
<i>3472</i>&nbsp;            if (min == max) {
<i>3473</i>&nbsp;                break;
<b class="nc"><i>3474</i>&nbsp;            }</b>
<b class="nc"><i>3475</i>&nbsp;        }</b>
<b class="nc"><i>3476</i>&nbsp;        nextStamp = newStamp;</b>
<b class="nc"><i>3477</i>&nbsp;    }</b>
<i>3478</i>&nbsp;
<i>3479</i>&nbsp;    /**
<i>3480</i>&nbsp;     * Sets the WEEK_OF_MONTH and WEEK_OF_YEAR fields to new values with the
<i>3481</i>&nbsp;     * new parameter value if they have been calculated internally.
<i>3482</i>&nbsp;     */
<i>3483</i>&nbsp;    private void invalidateWeekFields()
<i>3484</i>&nbsp;    {
<i>3485</i>&nbsp;        if (stamp[WEEK_OF_MONTH] != COMPUTED &amp;&amp;
<i>3486</i>&nbsp;            stamp[WEEK_OF_YEAR] != COMPUTED) {
<i>3487</i>&nbsp;            return;
<i>3488</i>&nbsp;        }
<i>3489</i>&nbsp;
<i>3490</i>&nbsp;        // We have to check the new values of these fields after changing
<i>3491</i>&nbsp;        // firstDayOfWeek and/or minimalDaysInFirstWeek. If the field values
<i>3492</i>&nbsp;        // have been changed, then set the new values. (4822110)
<i>3493</i>&nbsp;        Calendar cal = (Calendar) clone();
<i>3494</i>&nbsp;        cal.setLenient(true);
<i>3495</i>&nbsp;        cal.clear(WEEK_OF_MONTH);
<i>3496</i>&nbsp;        cal.clear(WEEK_OF_YEAR);
<i>3497</i>&nbsp;
<i>3498</i>&nbsp;        if (stamp[WEEK_OF_MONTH] == COMPUTED) {
<i>3499</i>&nbsp;            int weekOfMonth = cal.get(WEEK_OF_MONTH);
<b class="nc"><i>3500</i>&nbsp;            if (fields[WEEK_OF_MONTH] != weekOfMonth) {</b>
<i>3501</i>&nbsp;                fields[WEEK_OF_MONTH] = weekOfMonth;
<b class="nc"><i>3502</i>&nbsp;            }</b>
<i>3503</i>&nbsp;        }
<b class="nc"><i>3504</i>&nbsp;</b>
<i>3505</i>&nbsp;        if (stamp[WEEK_OF_YEAR] == COMPUTED) {
<i>3506</i>&nbsp;            int weekOfYear = cal.get(WEEK_OF_YEAR);
<i>3507</i>&nbsp;            if (fields[WEEK_OF_YEAR] != weekOfYear) {
<i>3508</i>&nbsp;                fields[WEEK_OF_YEAR] = weekOfYear;
<i>3509</i>&nbsp;            }
<b class="nc"><i>3510</i>&nbsp;        }</b>
<b class="nc"><i>3511</i>&nbsp;    }</b>
<b class="nc"><i>3512</i>&nbsp;</b>
<b class="nc"><i>3513</i>&nbsp;    /**</b>
<b class="nc"><i>3514</i>&nbsp;     * Save the state of this object to a stream (i.e., serialize it).</b>
<i>3515</i>&nbsp;     *
<b class="nc"><i>3516</i>&nbsp;     * Ideally, &lt;code&gt;Calendar&lt;/code&gt; would only write out its state data and</b>
<b class="nc"><i>3517</i>&nbsp;     * the current time, and not write any field data out, such as</b>
<i>3518</i>&nbsp;     * &lt;code&gt;fields[]&lt;/code&gt;, &lt;code&gt;isTimeSet&lt;/code&gt;, &lt;code&gt;areFieldsSet&lt;/code&gt;,
<i>3519</i>&nbsp;     * and &lt;code&gt;isSet[]&lt;/code&gt;.  &lt;code&gt;nextStamp&lt;/code&gt; also should not be part
<i>3520</i>&nbsp;     * of the persistent state. Unfortunately, this didn&#39;t happen before JDK 1.1
<b class="nc"><i>3521</i>&nbsp;     * shipped. To be compatible with JDK 1.1, we will always have to write out</b>
<i>3522</i>&nbsp;     * the field values and state flags.  However, &lt;code&gt;nextStamp&lt;/code&gt; can be
<i>3523</i>&nbsp;     * removed from the serialization stream; this will probably happen in the
<i>3524</i>&nbsp;     * near future.
<i>3525</i>&nbsp;     */
<b class="nc"><i>3526</i>&nbsp;    private synchronized void writeObject(ObjectOutputStream stream)</b>
<b class="nc"><i>3527</i>&nbsp;         throws IOException</b>
<b class="nc"><i>3528</i>&nbsp;    {</b>
<i>3529</i>&nbsp;        // Try to compute the time correctly, for the future (stream
<i>3530</i>&nbsp;        // version 2) in which we don&#39;t write out fields[] or isSet[].
<i>3531</i>&nbsp;        if (!isTimeSet) {
<b class="nc"><i>3532</i>&nbsp;            try {</b>
<i>3533</i>&nbsp;                updateTime();
<i>3534</i>&nbsp;            }
<b class="nc"><i>3535</i>&nbsp;            catch (IllegalArgumentException e) {}</b>
<b class="nc"><i>3536</i>&nbsp;        }</b>
<b class="nc"><i>3537</i>&nbsp;</b>
<b class="nc"><i>3538</i>&nbsp;        // If this Calendar has a ZoneInfo, save it and set a</b>
<i>3539</i>&nbsp;        // SimpleTimeZone equivalent (as a single DST schedule) for
<i>3540</i>&nbsp;        // backward compatibility.
<i>3541</i>&nbsp;        TimeZone savedZone = null;
<b class="nc"><i>3542</i>&nbsp;        if (zone instanceof ZoneInfo) {</b>
<i>3543</i>&nbsp;            SimpleTimeZone stz = ((ZoneInfo)zone).getLastRuleInstance();
<i>3544</i>&nbsp;            if (stz == null) {
<i>3545</i>&nbsp;                stz = new SimpleTimeZone(zone.getRawOffset(), zone.getID());
<i>3546</i>&nbsp;            }
<i>3547</i>&nbsp;            savedZone = zone;
<i>3548</i>&nbsp;            zone = stz;
<i>3549</i>&nbsp;        }
<i>3550</i>&nbsp;
<i>3551</i>&nbsp;        // Write out the 1.1 FCS object.
<b class="nc"><i>3552</i>&nbsp;        stream.defaultWriteObject();</b>
<b class="nc"><i>3553</i>&nbsp;</b>
<i>3554</i>&nbsp;        // Write out the ZoneInfo object
<b class="nc"><i>3555</i>&nbsp;        // 4802409: we write out even if it is null, a temporary workaround</b>
<i>3556</i>&nbsp;        // the real fix for bug 4844924 in corba-iiop
<i>3557</i>&nbsp;        stream.writeObject(savedZone);
<i>3558</i>&nbsp;        if (savedZone != null) {
<i>3559</i>&nbsp;            zone = savedZone;
<b class="nc"><i>3560</i>&nbsp;        }</b>
<i>3561</i>&nbsp;    }
<b class="nc"><i>3562</i>&nbsp;</b>
<b class="nc"><i>3563</i>&nbsp;    private static class CalendarAccessControlContext {</b>
<b class="nc"><i>3564</i>&nbsp;        private static final AccessControlContext INSTANCE;</b>
<i>3565</i>&nbsp;        static {
<b class="nc"><i>3566</i>&nbsp;            RuntimePermission perm = new RuntimePermission(&quot;accessClassInPackage.sun.util.calendar&quot;);</b>
<b class="nc"><i>3567</i>&nbsp;            PermissionCollection perms = perm.newPermissionCollection();</b>
<i>3568</i>&nbsp;            perms.add(perm);
<i>3569</i>&nbsp;            INSTANCE = new AccessControlContext(new ProtectionDomain[] {
<b class="nc"><i>3570</i>&nbsp;                                                    new ProtectionDomain(null, perms)</b>
<i>3571</i>&nbsp;                                                });
<b class="nc"><i>3572</i>&nbsp;        }</b>
<b class="nc"><i>3573</i>&nbsp;        private CalendarAccessControlContext() {</b>
<i>3574</i>&nbsp;        }
<i>3575</i>&nbsp;    }
<i>3576</i>&nbsp;
<b class="nc"><i>3577</i>&nbsp;    /**</b>
<i>3578</i>&nbsp;     * Reconstitutes this object from a stream (i.e., deserialize it).
<i>3579</i>&nbsp;     */
<b class="nc"><i>3580</i>&nbsp;    private void readObject(ObjectInputStream stream)</b>
<i>3581</i>&nbsp;         throws IOException, ClassNotFoundException
<b class="nc"><i>3582</i>&nbsp;    {</b>
<b class="nc"><i>3583</i>&nbsp;        final ObjectInputStream input = stream;</b>
<i>3584</i>&nbsp;        input.defaultReadObject();
<i>3585</i>&nbsp;
<b class="nc"><i>3586</i>&nbsp;        stamp = new int[FIELD_COUNT];</b>
<i>3587</i>&nbsp;
<i>3588</i>&nbsp;        // Starting with version 2 (not implemented yet), we expect that
<b class="nc"><i>3589</i>&nbsp;        // fields[], isSet[], isTimeSet, and areFieldsSet may not be</b>
<b class="nc"><i>3590</i>&nbsp;        // streamed out anymore.  We expect &#39;time&#39; to be correct.</b>
<b class="nc"><i>3591</i>&nbsp;        if (serialVersionOnStream &gt;= 2)</b>
<b class="nc"><i>3592</i>&nbsp;        {</b>
<b class="nc"><i>3593</i>&nbsp;            isTimeSet = true;</b>
<b class="nc"><i>3594</i>&nbsp;            if (fields == null) {</b>
<b class="nc"><i>3595</i>&nbsp;                fields = new int[FIELD_COUNT];</b>
<b class="nc"><i>3596</i>&nbsp;            }</b>
<b class="nc"><i>3597</i>&nbsp;            if (isSet == null) {</b>
<b class="nc"><i>3598</i>&nbsp;                isSet = new boolean[FIELD_COUNT];</b>
<i>3599</i>&nbsp;            }
<b class="nc"><i>3600</i>&nbsp;        }</b>
<i>3601</i>&nbsp;        else if (serialVersionOnStream &gt;= 0)
<b class="nc"><i>3602</i>&nbsp;        {</b>
<b class="nc"><i>3603</i>&nbsp;            for (int i=0; i&lt;FIELD_COUNT; ++i) {</b>
<b class="nc"><i>3604</i>&nbsp;                stamp[i] = isSet[i] ? COMPUTED : UNSET;</b>
<i>3605</i>&nbsp;            }
<i>3606</i>&nbsp;        }
<i>3607</i>&nbsp;
<i>3608</i>&nbsp;        serialVersionOnStream = currentSerialVersion;
<i>3609</i>&nbsp;
<i>3610</i>&nbsp;        // If there&#39;s a ZoneInfo object, use it for zone.
<b class="nc"><i>3611</i>&nbsp;        ZoneInfo zi = null;</b>
<b class="nc"><i>3612</i>&nbsp;        try {</b>
<b class="nc"><i>3613</i>&nbsp;            zi = AccessController.doPrivileged(</b>
<b class="nc"><i>3614</i>&nbsp;                    new PrivilegedExceptionAction&lt;&gt;() {</b>
<b class="nc"><i>3615</i>&nbsp;                        @Override</b>
<i>3616</i>&nbsp;                        public ZoneInfo run() throws Exception {
<i>3617</i>&nbsp;                            return (ZoneInfo) input.readObject();
<i>3618</i>&nbsp;                        }
<i>3619</i>&nbsp;                    },
<i>3620</i>&nbsp;                    CalendarAccessControlContext.INSTANCE);
<i>3621</i>&nbsp;        } catch (PrivilegedActionException pae) {
<i>3622</i>&nbsp;            Exception e = pae.getException();
<i>3623</i>&nbsp;            if (!(e instanceof OptionalDataException)) {
<i>3624</i>&nbsp;                if (e instanceof RuntimeException) {
<i>3625</i>&nbsp;                    throw (RuntimeException) e;
<i>3626</i>&nbsp;                } else if (e instanceof IOException) {
<i>3627</i>&nbsp;                    throw (IOException) e;
<i>3628</i>&nbsp;                } else if (e instanceof ClassNotFoundException) {
<i>3629</i>&nbsp;                    throw (ClassNotFoundException) e;
<b class="nc"><i>3630</i>&nbsp;                }</b>
<i>3631</i>&nbsp;                throw new RuntimeException(e);
<i>3632</i>&nbsp;            }
<i>3633</i>&nbsp;        }
<i>3634</i>&nbsp;        if (zi != null) {
<i>3635</i>&nbsp;            zone = zi;
<i>3636</i>&nbsp;        }
<i>3637</i>&nbsp;
<i>3638</i>&nbsp;        // If the deserialized object has a SimpleTimeZone, try to
<i>3639</i>&nbsp;        // replace it with a ZoneInfo equivalent (as of 1.4) in order
<i>3640</i>&nbsp;        // to be compatible with the SimpleTimeZone-based
<i>3641</i>&nbsp;        // implementation as much as possible.
<i>3642</i>&nbsp;        if (zone instanceof SimpleTimeZone) {
<i>3643</i>&nbsp;            String id = zone.getID();
<i>3644</i>&nbsp;            TimeZone tz = TimeZone.getTimeZone(id);
<i>3645</i>&nbsp;            if (tz != null &amp;&amp; tz.hasSameRules(zone) &amp;&amp; tz.getID().equals(id)) {
<i>3646</i>&nbsp;                zone = tz;
<i>3647</i>&nbsp;            }
<i>3648</i>&nbsp;        }
<i>3649</i>&nbsp;    }
<i>3650</i>&nbsp;
<i>3651</i>&nbsp;    /**
<i>3652</i>&nbsp;     * Converts this object to an {@link Instant}.
<i>3653</i>&nbsp;     * &lt;p&gt;
<i>3654</i>&nbsp;     * The conversion creates an {@code Instant} that represents the
<i>3655</i>&nbsp;     * same point on the time-line as this {@code Calendar}.
<i>3656</i>&nbsp;     *
<i>3657</i>&nbsp;     * @return the instant representing the same point on the time-line
<i>3658</i>&nbsp;     * @since 1.8
<i>3659</i>&nbsp;     */
<i>3660</i>&nbsp;    public final Instant toInstant() {
<i>3661</i>&nbsp;        return Instant.ofEpochMilli(getTimeInMillis());
<i>3662</i>&nbsp;    }
<i>3663</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
