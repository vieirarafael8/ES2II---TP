


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ResourceBundle</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util</a> ]
</div>

<h1>Coverage Summary for Class: ResourceBundle (java.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ResourceBundle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 259)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ResourceBundle$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$BundleReference</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$CacheKey</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$Control</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 121)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$Control$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$Control$CandidateListCache</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 69)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$LoaderReference</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$NoFallbackControl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$RBClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$RBClassLoader$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResourceBundle$SingleFormatControl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 564)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
<i>28</i>&nbsp; * (C) Copyright IBM Corp. 1996 - 1999 - All Rights Reserved
<i>29</i>&nbsp; *
<i>30</i>&nbsp; * The original version of this source code and documentation
<i>31</i>&nbsp; * is copyrighted and owned by Taligent, Inc., a wholly-owned
<i>32</i>&nbsp; * subsidiary of IBM. These materials are provided under terms
<i>33</i>&nbsp; * of a License Agreement between Taligent and Sun. This technology
<i>34</i>&nbsp; * is protected by multiple US and International patents.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * This notice and attribution to Taligent may not be removed.
<i>37</i>&nbsp; * Taligent is a registered trademark of Taligent, Inc.
<i>38</i>&nbsp; *
<i>39</i>&nbsp; */
<i>40</i>&nbsp;
<i>41</i>&nbsp;package java.util;
<i>42</i>&nbsp;
<i>43</i>&nbsp;import java.io.IOException;
<i>44</i>&nbsp;import java.io.InputStream;
<i>45</i>&nbsp;import java.io.UncheckedIOException;
<i>46</i>&nbsp;import java.lang.ref.Reference;
<i>47</i>&nbsp;import java.lang.ref.ReferenceQueue;
<i>48</i>&nbsp;import java.lang.ref.SoftReference;
<i>49</i>&nbsp;import java.lang.ref.WeakReference;
<i>50</i>&nbsp;import java.lang.reflect.Constructor;
<i>51</i>&nbsp;import java.lang.reflect.InvocationTargetException;
<i>52</i>&nbsp;import java.lang.reflect.Modifier;
<i>53</i>&nbsp;import java.net.JarURLConnection;
<i>54</i>&nbsp;import java.net.URL;
<i>55</i>&nbsp;import java.net.URLConnection;
<i>56</i>&nbsp;import java.security.AccessController;
<i>57</i>&nbsp;import java.security.PrivilegedAction;
<i>58</i>&nbsp;import java.security.PrivilegedActionException;
<i>59</i>&nbsp;import java.security.PrivilegedExceptionAction;
<i>60</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>61</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>62</i>&nbsp;import java.util.jar.JarEntry;
<i>63</i>&nbsp;import java.util.spi.ResourceBundleControlProvider;
<i>64</i>&nbsp;import java.util.spi.ResourceBundleProvider;
<i>65</i>&nbsp;import java.util.stream.Collectors;
<i>66</i>&nbsp;import java.util.stream.Stream;
<i>67</i>&nbsp;
<i>68</i>&nbsp;import jdk.internal.loader.BootLoader;
<i>69</i>&nbsp;import jdk.internal.misc.JavaUtilResourceBundleAccess;
<i>70</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>71</i>&nbsp;import jdk.internal.reflect.CallerSensitive;
<i>72</i>&nbsp;import jdk.internal.reflect.Reflection;
<i>73</i>&nbsp;import sun.security.action.GetPropertyAction;
<i>74</i>&nbsp;import sun.util.locale.BaseLocale;
<i>75</i>&nbsp;import sun.util.locale.LocaleObjectCache;
<i>76</i>&nbsp;import static sun.security.util.SecurityConstants.GET_CLASSLOADER_PERMISSION;
<i>77</i>&nbsp;
<i>78</i>&nbsp;
<i>79</i>&nbsp;/**
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * Resource bundles contain locale-specific objects.  When your program needs a
<i>82</i>&nbsp; * locale-specific resource, a &lt;code&gt;String&lt;/code&gt; for example, your program can
<i>83</i>&nbsp; * load it from the resource bundle that is appropriate for the current user&#39;s
<i>84</i>&nbsp; * locale. In this way, you can write program code that is largely independent
<i>85</i>&nbsp; * of the user&#39;s locale isolating most, if not all, of the locale-specific
<i>86</i>&nbsp; * information in resource bundles.
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * &lt;p&gt;
<i>89</i>&nbsp; * This allows you to write programs that can:
<i>90</i>&nbsp; * &lt;UL&gt;
<i>91</i>&nbsp; * &lt;LI&gt; be easily localized, or translated, into different languages
<i>92</i>&nbsp; * &lt;LI&gt; handle multiple locales at once
<i>93</i>&nbsp; * &lt;LI&gt; be easily modified later to support even more locales
<i>94</i>&nbsp; * &lt;/UL&gt;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;P&gt;
<i>97</i>&nbsp; * Resource bundles belong to families whose members share a common base
<i>98</i>&nbsp; * name, but whose names also have additional components that identify
<i>99</i>&nbsp; * their locales. For example, the base name of a family of resource
<i>100</i>&nbsp; * bundles might be &quot;MyResources&quot;. The family should have a default
<i>101</i>&nbsp; * resource bundle which simply has the same name as its family -
<i>102</i>&nbsp; * &quot;MyResources&quot; - and will be used as the bundle of last resort if a
<i>103</i>&nbsp; * specific locale is not supported. The family can then provide as
<i>104</i>&nbsp; * many locale-specific members as needed, for example a German one
<i>105</i>&nbsp; * named &quot;MyResources_de&quot;.
<i>106</i>&nbsp; *
<i>107</i>&nbsp; * &lt;P&gt;
<i>108</i>&nbsp; * Each resource bundle in a family contains the same items, but the items have
<i>109</i>&nbsp; * been translated for the locale represented by that resource bundle.
<i>110</i>&nbsp; * For example, both &quot;MyResources&quot; and &quot;MyResources_de&quot; may have a
<i>111</i>&nbsp; * &lt;code&gt;String&lt;/code&gt; that&#39;s used on a button for canceling operations.
<i>112</i>&nbsp; * In &quot;MyResources&quot; the &lt;code&gt;String&lt;/code&gt; may contain &quot;Cancel&quot; and in
<i>113</i>&nbsp; * &quot;MyResources_de&quot; it may contain &quot;Abbrechen&quot;.
<i>114</i>&nbsp; *
<i>115</i>&nbsp; * &lt;P&gt;
<i>116</i>&nbsp; * If there are different resources for different countries, you
<i>117</i>&nbsp; * can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for
<i>118</i>&nbsp; * the German language (de) in Switzerland (CH). If you want to only
<i>119</i>&nbsp; * modify some of the resources
<i>120</i>&nbsp; * in the specialization, you can do so.
<i>121</i>&nbsp; *
<i>122</i>&nbsp; * &lt;P&gt;
<i>123</i>&nbsp; * When your program needs a locale-specific object, it loads
<i>124</i>&nbsp; * the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the
<i>125</i>&nbsp; * {@link #getBundle(java.lang.String, java.util.Locale) getBundle}
<i>126</i>&nbsp; * method:
<i>127</i>&nbsp; * &lt;blockquote&gt;
<i>128</i>&nbsp; * &lt;pre&gt;
<i>129</i>&nbsp; * ResourceBundle myResources =
<i>130</i>&nbsp; *      ResourceBundle.getBundle(&quot;MyResources&quot;, currentLocale);
<i>131</i>&nbsp; * &lt;/pre&gt;
<i>132</i>&nbsp; * &lt;/blockquote&gt;
<i>133</i>&nbsp; *
<i>134</i>&nbsp; * &lt;P&gt;
<i>135</i>&nbsp; * Resource bundles contain key/value pairs. The keys uniquely
<i>136</i>&nbsp; * identify a locale-specific object in the bundle. Here&#39;s an
<i>137</i>&nbsp; * example of a &lt;code&gt;ListResourceBundle&lt;/code&gt; that contains
<i>138</i>&nbsp; * two key/value pairs:
<i>139</i>&nbsp; * &lt;blockquote&gt;
<i>140</i>&nbsp; * &lt;pre&gt;
<i>141</i>&nbsp; * public class MyResources extends ListResourceBundle {
<i>142</i>&nbsp; *     protected Object[][] getContents() {
<i>143</i>&nbsp; *         return new Object[][] {
<i>144</i>&nbsp; *             // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., &quot;OK&quot;)
<i>145</i>&nbsp; *             {&quot;OkKey&quot;, &quot;OK&quot;},
<i>146</i>&nbsp; *             {&quot;CancelKey&quot;, &quot;Cancel&quot;},
<i>147</i>&nbsp; *             // END OF MATERIAL TO LOCALIZE
<i>148</i>&nbsp; *        };
<i>149</i>&nbsp; *     }
<i>150</i>&nbsp; * }
<i>151</i>&nbsp; * &lt;/pre&gt;
<i>152</i>&nbsp; * &lt;/blockquote&gt;
<i>153</i>&nbsp; * Keys are always &lt;code&gt;String&lt;/code&gt;s.
<i>154</i>&nbsp; * In this example, the keys are &quot;OkKey&quot; and &quot;CancelKey&quot;.
<i>155</i>&nbsp; * In the above example, the values
<i>156</i>&nbsp; * are also &lt;code&gt;String&lt;/code&gt;s--&quot;OK&quot; and &quot;Cancel&quot;--but
<i>157</i>&nbsp; * they don&#39;t have to be. The values can be any type of object.
<i>158</i>&nbsp; *
<i>159</i>&nbsp; * &lt;P&gt;
<i>160</i>&nbsp; * You retrieve an object from resource bundle using the appropriate
<i>161</i>&nbsp; * getter method. Because &quot;OkKey&quot; and &quot;CancelKey&quot;
<i>162</i>&nbsp; * are both strings, you would use &lt;code&gt;getString&lt;/code&gt; to retrieve them:
<i>163</i>&nbsp; * &lt;blockquote&gt;
<i>164</i>&nbsp; * &lt;pre&gt;
<i>165</i>&nbsp; * button1 = new Button(myResources.getString(&quot;OkKey&quot;));
<i>166</i>&nbsp; * button2 = new Button(myResources.getString(&quot;CancelKey&quot;));
<i>167</i>&nbsp; * &lt;/pre&gt;
<i>168</i>&nbsp; * &lt;/blockquote&gt;
<i>169</i>&nbsp; * The getter methods all require the key as an argument and return
<i>170</i>&nbsp; * the object if found. If the object is not found, the getter method
<i>171</i>&nbsp; * throws a &lt;code&gt;MissingResourceException&lt;/code&gt;.
<i>172</i>&nbsp; *
<i>173</i>&nbsp; * &lt;P&gt;
<i>174</i>&nbsp; * Besides &lt;code&gt;getString&lt;/code&gt;, &lt;code&gt;ResourceBundle&lt;/code&gt; also provides
<i>175</i>&nbsp; * a method for getting string arrays, &lt;code&gt;getStringArray&lt;/code&gt;,
<i>176</i>&nbsp; * as well as a generic &lt;code&gt;getObject&lt;/code&gt; method for any other
<i>177</i>&nbsp; * type of object. When using &lt;code&gt;getObject&lt;/code&gt;, you&#39;ll
<i>178</i>&nbsp; * have to cast the result to the appropriate type. For example:
<i>179</i>&nbsp; * &lt;blockquote&gt;
<i>180</i>&nbsp; * &lt;pre&gt;
<i>181</i>&nbsp; * int[] myIntegers = (int[]) myResources.getObject(&quot;intList&quot;);
<i>182</i>&nbsp; * &lt;/pre&gt;
<i>183</i>&nbsp; * &lt;/blockquote&gt;
<i>184</i>&nbsp; *
<i>185</i>&nbsp; * &lt;P&gt;
<i>186</i>&nbsp; * The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;,
<i>187</i>&nbsp; * &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;,
<i>188</i>&nbsp; * that provide a fairly simple way to create resources.
<i>189</i>&nbsp; * As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt;
<i>190</i>&nbsp; * manages its resource as a list of key/value pairs.
<i>191</i>&nbsp; * &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage
<i>192</i>&nbsp; * its resources.
<i>193</i>&nbsp; *
<i>194</i>&nbsp; * &lt;p&gt;
<i>195</i>&nbsp; * If &lt;code&gt;ListResourceBundle&lt;/code&gt; or &lt;code&gt;PropertyResourceBundle&lt;/code&gt;
<i>196</i>&nbsp; * do not suit your needs, you can write your own &lt;code&gt;ResourceBundle&lt;/code&gt;
<i>197</i>&nbsp; * subclass.  Your subclasses must override two methods: &lt;code&gt;handleGetObject&lt;/code&gt;
<i>198</i>&nbsp; * and &lt;code&gt;getKeys()&lt;/code&gt;.
<i>199</i>&nbsp; *
<i>200</i>&nbsp; * &lt;p&gt;
<i>201</i>&nbsp; * The implementation of a {@code ResourceBundle} subclass must be thread-safe
<i>202</i>&nbsp; * if it&#39;s simultaneously used by multiple threads. The default implementations
<i>203</i>&nbsp; * of the non-abstract methods in this class, and the methods in the direct
<i>204</i>&nbsp; * known concrete subclasses {@code ListResourceBundle} and
<i>205</i>&nbsp; * {@code PropertyResourceBundle} are thread-safe.
<i>206</i>&nbsp; *
<i>207</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;&lt;/h3&gt;
<i>208</i>&nbsp; *
<i>209</i>&nbsp; * Resource bundles can be deployed in modules in the following ways:
<i>210</i>&nbsp; *
<i>211</i>&nbsp; * &lt;h4&gt;Resource bundles together with an application&lt;/h4&gt;
<i>212</i>&nbsp; *
<i>213</i>&nbsp; * Resource bundles can be deployed together with an application in the same
<i>214</i>&nbsp; * module.  In that case, the resource bundles are loaded
<i>215</i>&nbsp; * by code in the module by calling the {@link #getBundle(String)}
<i>216</i>&nbsp; * or {@link #getBundle(String, Locale)} method.
<i>217</i>&nbsp; *
<i>218</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;service-providers&quot;&gt;Resource bundles as service providers&lt;/a&gt;&lt;/h4&gt;
<i>219</i>&nbsp; *
<i>220</i>&nbsp; * Resource bundles can be deployed in one or more &lt;em&gt;service provider modules&lt;/em&gt;
<i>221</i>&nbsp; * and they can be located using {@link ServiceLoader}.
<i>222</i>&nbsp; * A {@linkplain ResourceBundleProvider service} interface or class must be
<i>223</i>&nbsp; * defined. The caller module declares that it uses the service, the service
<i>224</i>&nbsp; * provider modules declare that they provide implementations of the service.
<i>225</i>&nbsp; * Refer to {@link ResourceBundleProvider} for developing resource bundle
<i>226</i>&nbsp; * services and deploying resource bundle providers.
<i>227</i>&nbsp; * The module obtaining the resource bundle can be a resource bundle
<i>228</i>&nbsp; * provider itself; in which case this module only locates the resource bundle
<i>229</i>&nbsp; * via service provider mechanism.
<i>230</i>&nbsp; *
<i>231</i>&nbsp; * &lt;p&gt;A {@linkplain ResourceBundleProvider resource bundle provider} can
<i>232</i>&nbsp; * provide resource bundles in any format such XML which replaces the need
<i>233</i>&nbsp; * of {@link Control ResourceBundle.Control}.
<i>234</i>&nbsp; *
<i>235</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;other-modules&quot;&gt;Resource bundles in other modules and class path&lt;/a&gt;&lt;/h4&gt;
<i>236</i>&nbsp; *
<i>237</i>&nbsp; * Resource bundles in a named module may be &lt;em&gt;encapsulated&lt;/em&gt; so that
<i>238</i>&nbsp; * it cannot be located by code in other modules.  Resource bundles
<i>239</i>&nbsp; * in unnamed modules and class path are open for any module to access.
<i>240</i>&nbsp; * Resource bundle follows the resource encapsulation rules as specified
<i>241</i>&nbsp; * in {@link Module#getResourceAsStream(String)}.
<i>242</i>&nbsp; *
<i>243</i>&nbsp; * &lt;p&gt;The {@code getBundle} factory methods with no {@code Control} parameter
<i>244</i>&nbsp; * locate and load resource bundles from
<i>245</i>&nbsp; * {@linkplain ResourceBundleProvider service providers}.
<i>246</i>&nbsp; * It may continue the search as if calling {@link Module#getResourceAsStream(String)}
<i>247</i>&nbsp; * to find the named resource from a given module and calling
<i>248</i>&nbsp; * {@link ClassLoader#getResourceAsStream(String)}; refer to
<i>249</i>&nbsp; * the specification of the {@code getBundle} method for details.
<i>250</i>&nbsp; * Only non-encapsulated resource bundles of &quot;{@code java.class}&quot;
<i>251</i>&nbsp; * or &quot;{@code java.properties}&quot; format are searched.
<i>252</i>&nbsp; *
<i>253</i>&nbsp; * &lt;p&gt;If the caller module is a
<i>254</i>&nbsp; * &lt;a href=&quot;{@docRoot}/java.base/java/util/spi/ResourceBundleProvider.html#obtain-resource-bundle&quot;&gt;
<i>255</i>&nbsp; * resource bundle provider&lt;/a&gt;, it does not fall back to the
<i>256</i>&nbsp; * class loader search.
<i>257</i>&nbsp; *
<i>258</i>&nbsp; * &lt;h4&gt;Resource bundles in automatic modules&lt;/h4&gt;
<i>259</i>&nbsp; *
<i>260</i>&nbsp; * A common format of resource bundles is in {@linkplain PropertyResourceBundle
<i>261</i>&nbsp; * .properties} file format.  Typically {@code .properties} resource bundles
<i>262</i>&nbsp; * are packaged in a JAR file.  Resource bundle only JAR file can be readily
<i>263</i>&nbsp; * deployed as an &lt;a href=&quot;{@docRoot}/java.base/java/lang/module/ModuleFinder.html#automatic-modules&quot;&gt;
<i>264</i>&nbsp; * automatic module&lt;/a&gt;.  For example, if the JAR file contains the
<i>265</i>&nbsp; * entry &quot;{@code p/q/Foo_ja.properties}&quot; and no {@code .class} entry,
<i>266</i>&nbsp; * when resolved and defined as an automatic module, no package is derived
<i>267</i>&nbsp; * for this module.  This allows resource bundles in {@code .properties}
<i>268</i>&nbsp; * format packaged in one or more JAR files that may contain entries
<i>269</i>&nbsp; * in the same directory and can be resolved successfully as
<i>270</i>&nbsp; * automatic modules.
<i>271</i>&nbsp; *
<i>272</i>&nbsp; * &lt;h3&gt;ResourceBundle.Control&lt;/h3&gt;
<i>273</i>&nbsp; *
<i>274</i>&nbsp; * The {@link ResourceBundle.Control} class provides information necessary
<i>275</i>&nbsp; * to perform the bundle loading process by the &lt;code&gt;getBundle&lt;/code&gt;
<i>276</i>&nbsp; * factory methods that take a &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
<i>277</i>&nbsp; * instance. You can implement your own subclass in order to enable
<i>278</i>&nbsp; * non-standard resource bundle formats, change the search strategy, or
<i>279</i>&nbsp; * define caching parameters. Refer to the descriptions of the class and the
<i>280</i>&nbsp; * {@link #getBundle(String, Locale, ClassLoader, Control) getBundle}
<i>281</i>&nbsp; * factory method for details.
<i>282</i>&nbsp; *
<i>283</i>&nbsp; * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed
<i>284</i>&nbsp; * in an unnamed module, for example to support resource bundles in
<i>285</i>&nbsp; * non-standard formats or package localized resources in a non-traditional
<i>286</i>&nbsp; * convention. {@link ResourceBundleProvider} is the replacement for
<b class="nc"><i>287</i>&nbsp; * {@code ResourceBundle.Control} when migrating to modules.</b>
<i>288</i>&nbsp; * {@code UnsupportedOperationException} will be thrown when a factory
<i>289</i>&nbsp; * method that takes the {@code ResourceBundle.Control} parameter is called.
<i>290</i>&nbsp; *
<i>291</i>&nbsp; * &lt;p&gt;&lt;a id=&quot;modify_default_behavior&quot;&gt;For the {@code getBundle} factory&lt;/a&gt;
<i>292</i>&nbsp; * methods that take no {@link Control} instance, their &lt;a
<b class="nc"><i>293</i>&nbsp; * href=&quot;#default_behavior&quot;&gt; default behavior&lt;/a&gt; of resource bundle loading</b>
<b class="nc"><i>294</i>&nbsp; * can be modified with custom {@link</b>
<b class="nc"><i>295</i>&nbsp; * ResourceBundleControlProvider} implementations.</b>
<b class="nc"><i>296</i>&nbsp; * If any of the</b>
<i>297</i>&nbsp; * providers provides a {@link Control} for the given base name, that {@link
<i>298</i>&nbsp; * Control} will be used instead of the default {@link Control}. If there is
<i>299</i>&nbsp; * more than one service provider for supporting the same base name,
<i>300</i>&nbsp; * the first one returned from {@link ServiceLoader} will be used.
<i>301</i>&nbsp; * A custom {@link Control} implementation is ignored by named modules.
<i>302</i>&nbsp; *
<i>303</i>&nbsp; * &lt;h3&gt;Cache Management&lt;/h3&gt;
<i>304</i>&nbsp; *
<i>305</i>&nbsp; * Resource bundle instances created by the &lt;code&gt;getBundle&lt;/code&gt; factory
<i>306</i>&nbsp; * methods are cached by default, and the factory methods return the same
<i>307</i>&nbsp; * resource bundle instance multiple times if it has been
<i>308</i>&nbsp; * cached. &lt;code&gt;getBundle&lt;/code&gt; clients may clear the cache, manage the
<i>309</i>&nbsp; * lifetime of cached resource bundle instances using time-to-live values,
<i>310</i>&nbsp; * or specify not to cache resource bundle instances. Refer to the
<i>311</i>&nbsp; * descriptions of the {@linkplain #getBundle(String, Locale, ClassLoader,
<b class="nc"><i>312</i>&nbsp; * Control) &lt;code&gt;getBundle&lt;/code&gt; factory method}, {@link</b>
<i>313</i>&nbsp; * #clearCache(ClassLoader) clearCache}, {@link
<i>314</i>&nbsp; * Control#getTimeToLive(String, Locale)
<i>315</i>&nbsp; * ResourceBundle.Control.getTimeToLive}, and {@link
<i>316</i>&nbsp; * Control#needsReload(String, Locale, String, ClassLoader, ResourceBundle,
<i>317</i>&nbsp; * long) ResourceBundle.Control.needsReload} for details.
<b class="nc"><i>318</i>&nbsp; *</b>
<i>319</i>&nbsp; * &lt;h3&gt;Example&lt;/h3&gt;
<i>320</i>&nbsp; *
<i>321</i>&nbsp; * The following is a very simple example of a &lt;code&gt;ResourceBundle&lt;/code&gt;
<i>322</i>&nbsp; * subclass, &lt;code&gt;MyResources&lt;/code&gt;, that manages two resources (for a larger number of
<i>323</i>&nbsp; * resources you would probably use a &lt;code&gt;Map&lt;/code&gt;).
<i>324</i>&nbsp; * Notice that you don&#39;t need to supply a value if
<i>325</i>&nbsp; * a &quot;parent-level&quot; &lt;code&gt;ResourceBundle&lt;/code&gt; handles the same
<i>326</i>&nbsp; * key with the same value (as for the okKey below).
<i>327</i>&nbsp; * &lt;blockquote&gt;
<i>328</i>&nbsp; * &lt;pre&gt;
<i>329</i>&nbsp; * // default (English language, United States)
<i>330</i>&nbsp; * public class MyResources extends ResourceBundle {
<i>331</i>&nbsp; *     public Object handleGetObject(String key) {
<i>332</i>&nbsp; *         if (key.equals(&quot;okKey&quot;)) return &quot;Ok&quot;;
<i>333</i>&nbsp; *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Cancel&quot;;
<i>334</i>&nbsp; *         return null;
<b class="nc"><i>335</i>&nbsp; *     }</b>
<i>336</i>&nbsp; *
<i>337</i>&nbsp; *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
<i>338</i>&nbsp; *         return Collections.enumeration(keySet());
<i>339</i>&nbsp; *     }
<i>340</i>&nbsp; *
<i>341</i>&nbsp; *     // Overrides handleKeySet() so that the getKeys() implementation
<i>342</i>&nbsp; *     // can rely on the keySet() value.
<b class="nc"><i>343</i>&nbsp; *     protected Set&amp;lt;String&amp;gt; handleKeySet() {</b>
<i>344</i>&nbsp; *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;okKey&quot;, &quot;cancelKey&quot;));
<i>345</i>&nbsp; *     }
<i>346</i>&nbsp; * }
<i>347</i>&nbsp; *
<b class="nc"><i>348</i>&nbsp; * // German language</b>
<i>349</i>&nbsp; * public class MyResources_de extends MyResources {
<i>350</i>&nbsp; *     public Object handleGetObject(String key) {
<i>351</i>&nbsp; *         // don&#39;t need okKey, since parent level handles it.
<i>352</i>&nbsp; *         if (key.equals(&quot;cancelKey&quot;)) return &quot;Abbrechen&quot;;
<i>353</i>&nbsp; *         return null;
<i>354</i>&nbsp; *     }
<i>355</i>&nbsp; *
<i>356</i>&nbsp; *     protected Set&amp;lt;String&amp;gt; handleKeySet() {
<i>357</i>&nbsp; *         return new HashSet&amp;lt;String&amp;gt;(Arrays.asList(&quot;cancelKey&quot;));
<i>358</i>&nbsp; *     }
<i>359</i>&nbsp; * }
<i>360</i>&nbsp; * &lt;/pre&gt;
<i>361</i>&nbsp; * &lt;/blockquote&gt;
<i>362</i>&nbsp; * You do not have to restrict yourself to using a single family of
<i>363</i>&nbsp; * &lt;code&gt;ResourceBundle&lt;/code&gt;s. For example, you could have a set of bundles for
<i>364</i>&nbsp; * exception messages, &lt;code&gt;ExceptionResources&lt;/code&gt;
<i>365</i>&nbsp; * (&lt;code&gt;ExceptionResources_fr&lt;/code&gt;, &lt;code&gt;ExceptionResources_de&lt;/code&gt;, ...),
<i>366</i>&nbsp; * and one for widgets, &lt;code&gt;WidgetResource&lt;/code&gt; (&lt;code&gt;WidgetResources_fr&lt;/code&gt;,
<i>367</i>&nbsp; * &lt;code&gt;WidgetResources_de&lt;/code&gt;, ...); breaking up the resources however you like.
<i>368</i>&nbsp; *
<i>369</i>&nbsp; * @see ListResourceBundle
<i>370</i>&nbsp; * @see PropertyResourceBundle
<i>371</i>&nbsp; * @see MissingResourceException
<i>372</i>&nbsp; * @see ResourceBundleProvider
<i>373</i>&nbsp; * @since 1.1
<b class="nc"><i>374</i>&nbsp; * @revised 9</b>
<b class="nc"><i>375</i>&nbsp; * @spec JPMS</b>
<b class="nc"><i>376</i>&nbsp; */</b>
<b class="nc"><i>377</i>&nbsp;public abstract class ResourceBundle {</b>
<b class="nc"><i>378</i>&nbsp;</b>
<b class="nc"><i>379</i>&nbsp;    /** initial size of the bundle cache */</b>
<i>380</i>&nbsp;    private static final int INITIAL_CACHE_SIZE = 32;
<b class="nc"><i>381</i>&nbsp;</b>
<b class="nc"><i>382</i>&nbsp;    static {</b>
<b class="nc"><i>383</i>&nbsp;        SharedSecrets.setJavaUtilResourceBundleAccess(</b>
<i>384</i>&nbsp;            new JavaUtilResourceBundleAccess() {
<i>385</i>&nbsp;                @Override
<i>386</i>&nbsp;                public void setParent(ResourceBundle bundle,
<i>387</i>&nbsp;                                      ResourceBundle parent) {
<i>388</i>&nbsp;                    bundle.setParent(parent);
<i>389</i>&nbsp;                }
<b class="nc"><i>390</i>&nbsp;</b>
<i>391</i>&nbsp;                @Override
<i>392</i>&nbsp;                public ResourceBundle getParent(ResourceBundle bundle) {
<i>393</i>&nbsp;                    return bundle.parent;
<i>394</i>&nbsp;                }
<i>395</i>&nbsp;
<i>396</i>&nbsp;                @Override
<i>397</i>&nbsp;                public void setLocale(ResourceBundle bundle, Locale locale) {
<i>398</i>&nbsp;                    bundle.locale = locale;
<i>399</i>&nbsp;                }
<i>400</i>&nbsp;
<i>401</i>&nbsp;                @Override
<i>402</i>&nbsp;                public void setName(ResourceBundle bundle, String name) {
<i>403</i>&nbsp;                    bundle.name = name;
<i>404</i>&nbsp;                }
<i>405</i>&nbsp;
<i>406</i>&nbsp;                @Override
<b class="nc"><i>407</i>&nbsp;                public ResourceBundle getBundle(String baseName, Locale locale, Module module) {</b>
<i>408</i>&nbsp;                    // use the given module as the caller to bypass the access check
<i>409</i>&nbsp;                    return getBundleImpl(module, module,
<i>410</i>&nbsp;                                         baseName, locale,
<i>411</i>&nbsp;                                         getDefaultControl(module, baseName));
<i>412</i>&nbsp;                }
<i>413</i>&nbsp;
<i>414</i>&nbsp;                @Override
<i>415</i>&nbsp;                public ResourceBundle newResourceBundle(Class&lt;? extends ResourceBundle&gt; bundleClass) {
<i>416</i>&nbsp;                    return ResourceBundleProviderHelper.newResourceBundle(bundleClass);
<i>417</i>&nbsp;                }
<i>418</i>&nbsp;            });
<i>419</i>&nbsp;    }
<i>420</i>&nbsp;
<i>421</i>&nbsp;    /** constant indicating that no resource bundle exists */
<i>422</i>&nbsp;    private static final ResourceBundle NONEXISTENT_BUNDLE = new ResourceBundle() {
<i>423</i>&nbsp;            public Enumeration&lt;String&gt; getKeys() { return null; }
<b class="nc"><i>424</i>&nbsp;            protected Object handleGetObject(String key) { return null; }</b>
<i>425</i>&nbsp;            public String toString() { return &quot;NONEXISTENT_BUNDLE&quot;; }
<i>426</i>&nbsp;        };
<i>427</i>&nbsp;
<i>428</i>&nbsp;
<i>429</i>&nbsp;    /**
<i>430</i>&nbsp;     * The cache is a map from cache keys (with bundle base name, locale, and
<i>431</i>&nbsp;     * class loader) to either a resource bundle or NONEXISTENT_BUNDLE wrapped by a
<i>432</i>&nbsp;     * BundleReference.
<i>433</i>&nbsp;     *
<i>434</i>&nbsp;     * The cache is a ConcurrentMap, allowing the cache to be searched
<i>435</i>&nbsp;     * concurrently by multiple threads.  This will also allow the cache keys
<i>436</i>&nbsp;     * to be reclaimed along with the ClassLoaders they reference.
<i>437</i>&nbsp;     *
<i>438</i>&nbsp;     * This variable would be better named &quot;cache&quot;, but we keep the old
<i>439</i>&nbsp;     * name for compatibility with some workarounds for bug 4212439.
<i>440</i>&nbsp;     */
<b class="nc"><i>441</i>&nbsp;    private static final ConcurrentMap&lt;CacheKey, BundleReference&gt; cacheList</b>
<b class="nc"><i>442</i>&nbsp;        = new ConcurrentHashMap&lt;&gt;(INITIAL_CACHE_SIZE);</b>
<b class="nc"><i>443</i>&nbsp;</b>
<b class="nc"><i>444</i>&nbsp;    /**</b>
<i>445</i>&nbsp;     * Queue for reference objects referring to class loaders or bundles.
<b class="nc"><i>446</i>&nbsp;     */</b>
<b class="nc"><i>447</i>&nbsp;    private static final ReferenceQueue&lt;Object&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</b>
<b class="nc"><i>448</i>&nbsp;</b>
<i>449</i>&nbsp;    /**
<b class="nc"><i>450</i>&nbsp;     * Returns the base name of this bundle, if known, or {@code null} if unknown.</b>
<i>451</i>&nbsp;     *
<i>452</i>&nbsp;     * If not null, then this is the value of the {@code baseName} parameter
<i>453</i>&nbsp;     * that was passed to the {@code ResourceBundle.getBundle(...)} method
<b class="nc"><i>454</i>&nbsp;     * when the resource bundle was loaded.</b>
<i>455</i>&nbsp;     *
<i>456</i>&nbsp;     * @return The base name of the resource bundle, as provided to and expected
<i>457</i>&nbsp;     * by the {@code ResourceBundle.getBundle(...)} methods.
<i>458</i>&nbsp;     *
<i>459</i>&nbsp;     * @see #getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)
<i>460</i>&nbsp;     *
<i>461</i>&nbsp;     * @since 1.8
<i>462</i>&nbsp;     */
<i>463</i>&nbsp;    public String getBaseBundleName() {
<i>464</i>&nbsp;        return name;
<b class="nc"><i>465</i>&nbsp;    }</b>
<i>466</i>&nbsp;
<i>467</i>&nbsp;    /**
<i>468</i>&nbsp;     * The parent bundle of this bundle.
<i>469</i>&nbsp;     * The parent bundle is searched by {@link #getObject getObject}
<i>470</i>&nbsp;     * when this bundle does not contain a particular resource.
<i>471</i>&nbsp;     */
<i>472</i>&nbsp;    protected ResourceBundle parent = null;
<b class="nc"><i>473</i>&nbsp;</b>
<b class="nc"><i>474</i>&nbsp;    /**</b>
<i>475</i>&nbsp;     * The locale for this bundle.
<i>476</i>&nbsp;     */
<i>477</i>&nbsp;    private Locale locale = null;
<i>478</i>&nbsp;
<i>479</i>&nbsp;    /**
<i>480</i>&nbsp;     * The base bundle name for this bundle.
<i>481</i>&nbsp;     */
<b class="nc"><i>482</i>&nbsp;    private String name;</b>
<i>483</i>&nbsp;
<b class="nc"><i>484</i>&nbsp;    /**</b>
<i>485</i>&nbsp;     * The flag indicating this bundle has expired in the cache.
<i>486</i>&nbsp;     */
<i>487</i>&nbsp;    private volatile boolean expired;
<i>488</i>&nbsp;
<i>489</i>&nbsp;    /**
<b class="nc"><i>490</i>&nbsp;     * The back link to the cache key. null if this bundle isn&#39;t in</b>
<b class="nc"><i>491</i>&nbsp;     * the cache (yet) or has expired.</b>
<b class="nc"><i>492</i>&nbsp;     */</b>
<i>493</i>&nbsp;    private volatile CacheKey cacheKey;
<b class="nc"><i>494</i>&nbsp;</b>
<i>495</i>&nbsp;    /**
<i>496</i>&nbsp;     * A Set of the keys contained only in this ResourceBundle.
<b class="nc"><i>497</i>&nbsp;     */</b>
<i>498</i>&nbsp;    private volatile Set&lt;String&gt; keySet;
<b class="nc"><i>499</i>&nbsp;</b>
<i>500</i>&nbsp;    /**
<i>501</i>&nbsp;     * Sole constructor.  (For invocation by subclass constructors, typically
<b class="nc"><i>502</i>&nbsp;     * implicit.)</b>
<b class="nc"><i>503</i>&nbsp;     */</b>
<i>504</i>&nbsp;    public ResourceBundle() {
<b class="nc"><i>505</i>&nbsp;    }</b>
<i>506</i>&nbsp;
<i>507</i>&nbsp;    /**
<b class="nc"><i>508</i>&nbsp;     * Gets a string for the given key from this resource bundle or one of its parents.</b>
<b class="nc"><i>509</i>&nbsp;     * Calling this method is equivalent to calling</b>
<i>510</i>&nbsp;     * &lt;blockquote&gt;
<b class="nc"><i>511</i>&nbsp;     * &lt;code&gt;(String) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.</b>
<i>512</i>&nbsp;     * &lt;/blockquote&gt;
<i>513</i>&nbsp;     *
<b class="nc"><i>514</i>&nbsp;     * @param key the key for the desired string</b>
<b class="nc"><i>515</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</b>
<i>516</i>&nbsp;     * @exception MissingResourceException if no object for the given key can be found
<b class="nc"><i>517</i>&nbsp;     * @exception ClassCastException if the object found for the given key is not a string</b>
<i>518</i>&nbsp;     * @return the string for the given key
<i>519</i>&nbsp;     */
<i>520</i>&nbsp;    public final String getString(String key) {
<i>521</i>&nbsp;        return (String) getObject(key);
<i>522</i>&nbsp;    }
<i>523</i>&nbsp;
<i>524</i>&nbsp;    /**
<i>525</i>&nbsp;     * Gets a string array for the given key from this resource bundle or one of its parents.
<i>526</i>&nbsp;     * Calling this method is equivalent to calling
<i>527</i>&nbsp;     * &lt;blockquote&gt;
<i>528</i>&nbsp;     * &lt;code&gt;(String[]) {@link #getObject(java.lang.String) getObject}(key)&lt;/code&gt;.
<b class="nc"><i>529</i>&nbsp;     * &lt;/blockquote&gt;</b>
<b class="nc"><i>530</i>&nbsp;     *</b>
<i>531</i>&nbsp;     * @param key the key for the desired string array
<i>532</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>533</i>&nbsp;     * @exception MissingResourceException if no object for the given key can be found
<i>534</i>&nbsp;     * @exception ClassCastException if the object found for the given key is not a string array
<i>535</i>&nbsp;     * @return the string array for the given key
<i>536</i>&nbsp;     */
<i>537</i>&nbsp;    public final String[] getStringArray(String key) {
<i>538</i>&nbsp;        return (String[]) getObject(key);
<i>539</i>&nbsp;    }
<b class="nc"><i>540</i>&nbsp;</b>
<i>541</i>&nbsp;    /**
<i>542</i>&nbsp;     * Gets an object for the given key from this resource bundle or one of its parents.
<i>543</i>&nbsp;     * This method first tries to obtain the object from this resource bundle using
<i>544</i>&nbsp;     * {@link #handleGetObject(java.lang.String) handleGetObject}.
<i>545</i>&nbsp;     * If not successful, and the parent resource bundle is not null,
<i>546</i>&nbsp;     * it calls the parent&#39;s &lt;code&gt;getObject&lt;/code&gt; method.
<i>547</i>&nbsp;     * If still not successful, it throws a MissingResourceException.
<i>548</i>&nbsp;     *
<i>549</i>&nbsp;     * @param key the key for the desired object
<i>550</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>551</i>&nbsp;     * @exception MissingResourceException if no object for the given key can be found
<i>552</i>&nbsp;     * @return the object for the given key
<i>553</i>&nbsp;     */
<i>554</i>&nbsp;    public final Object getObject(String key) {
<i>555</i>&nbsp;        Object obj = handleGetObject(key);
<i>556</i>&nbsp;        if (obj == null) {
<i>557</i>&nbsp;            if (parent != null) {
<i>558</i>&nbsp;                obj = parent.getObject(key);
<i>559</i>&nbsp;            }
<i>560</i>&nbsp;            if (obj == null) {
<i>561</i>&nbsp;                throw new MissingResourceException(&quot;Can&#39;t find resource for bundle &quot;
<i>562</i>&nbsp;                                                   +this.getClass().getName()
<i>563</i>&nbsp;                                                   +&quot;, key &quot;+key,
<i>564</i>&nbsp;                                                   this.getClass().getName(),
<i>565</i>&nbsp;                                                   key);
<i>566</i>&nbsp;            }
<b class="nc"><i>567</i>&nbsp;        }</b>
<b class="nc"><i>568</i>&nbsp;        return obj;</b>
<b class="nc"><i>569</i>&nbsp;    }</b>
<b class="nc"><i>570</i>&nbsp;</b>
<b class="nc"><i>571</i>&nbsp;    /**</b>
<i>572</i>&nbsp;     * Returns the locale of this resource bundle. This method can be used after a
<b class="nc"><i>573</i>&nbsp;     * call to getBundle() to determine whether the resource bundle returned really</b>
<i>574</i>&nbsp;     * corresponds to the requested locale or is a fallback.
<b class="nc"><i>575</i>&nbsp;     *</b>
<i>576</i>&nbsp;     * @return the locale of this resource bundle
<i>577</i>&nbsp;     */
<i>578</i>&nbsp;    public Locale getLocale() {
<b class="nc"><i>579</i>&nbsp;        return locale;</b>
<i>580</i>&nbsp;    }
<i>581</i>&nbsp;
<i>582</i>&nbsp;    private static ClassLoader getLoader(Module module) {
<b class="nc"><i>583</i>&nbsp;        PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;</b>
<b class="nc"><i>584</i>&nbsp;        return AccessController.doPrivileged(pa);</b>
<b class="nc"><i>585</i>&nbsp;    }</b>
<i>586</i>&nbsp;
<b class="nc"><i>587</i>&nbsp;    /**</b>
<i>588</i>&nbsp;     * @param module a non-null-screened module form the {@link CacheKey#getModule()}.
<i>589</i>&nbsp;     * @return the ClassLoader to use in {@link Control#needsReload}
<i>590</i>&nbsp;     *         and {@link Control#newBundle}
<b class="nc"><i>591</i>&nbsp;     */</b>
<i>592</i>&nbsp;    private static ClassLoader getLoaderForControl(Module module) {
<i>593</i>&nbsp;        ClassLoader loader = getLoader(module);
<i>594</i>&nbsp;        return loader == null ? ClassLoader.getPlatformClassLoader() : loader;
<b class="nc"><i>595</i>&nbsp;    }</b>
<b class="nc"><i>596</i>&nbsp;</b>
<b class="nc"><i>597</i>&nbsp;    /**</b>
<i>598</i>&nbsp;     * Sets the parent bundle of this bundle.
<b class="nc"><i>599</i>&nbsp;     * The parent bundle is searched by {@link #getObject getObject}</b>
<i>600</i>&nbsp;     * when this bundle does not contain a particular resource.
<i>601</i>&nbsp;     *
<i>602</i>&nbsp;     * @param parent this bundle&#39;s parent bundle.
<b class="nc"><i>603</i>&nbsp;     */</b>
<i>604</i>&nbsp;    protected void setParent(ResourceBundle parent) {
<i>605</i>&nbsp;        assert parent != NONEXISTENT_BUNDLE;
<i>606</i>&nbsp;        this.parent = parent;
<b class="nc"><i>607</i>&nbsp;    }</b>
<b class="nc"><i>608</i>&nbsp;</b>
<i>609</i>&nbsp;    /**
<i>610</i>&nbsp;     * Key used for cached resource bundles.  The key checks the base
<b class="nc"><i>611</i>&nbsp;     * name, the locale, the bundle module, and the caller module</b>
<i>612</i>&nbsp;     * to determine if the resource is a match to the requested one.
<b class="nc"><i>613</i>&nbsp;     * The base name, the locale and both modules must have a non-null value.</b>
<b class="nc"><i>614</i>&nbsp;     */</b>
<i>615</i>&nbsp;    private static final class CacheKey {
<i>616</i>&nbsp;        // These four are the actual keys for lookup in Map.
<b class="nc"><i>617</i>&nbsp;        private final String name;</b>
<b class="nc"><i>618</i>&nbsp;        private volatile Locale locale;</b>
<i>619</i>&nbsp;        private final KeyElementReference&lt;Module&gt; moduleRef;
<i>620</i>&nbsp;        private final KeyElementReference&lt;Module&gt; callerRef;
<b class="nc"><i>621</i>&nbsp;        // this is the part of hashCode that pertains to module and callerModule</b>
<b class="nc"><i>622</i>&nbsp;        // which can be GCed..</b>
<i>623</i>&nbsp;        private final int modulesHash;
<i>624</i>&nbsp;
<b class="nc"><i>625</i>&nbsp;        // bundle format which is necessary for calling</b>
<b class="nc"><i>626</i>&nbsp;        // Control.needsReload().</b>
<i>627</i>&nbsp;        private volatile String format;
<b class="nc"><i>628</i>&nbsp;</b>
<b class="nc"><i>629</i>&nbsp;        // These time values are in CacheKey so that NONEXISTENT_BUNDLE</b>
<i>630</i>&nbsp;        // doesn&#39;t need to be cloned for caching.
<i>631</i>&nbsp;
<i>632</i>&nbsp;        // The time when the bundle has been loaded
<i>633</i>&nbsp;        private volatile long loadTime;
<b class="nc"><i>634</i>&nbsp;</b>
<b class="nc"><i>635</i>&nbsp;        // The time when the bundle expires in the cache, or either</b>
<i>636</i>&nbsp;        // Control.TTL_DONT_CACHE or Control.TTL_NO_EXPIRATION_CONTROL.
<b class="nc"><i>637</i>&nbsp;        private volatile long expirationTime;</b>
<i>638</i>&nbsp;
<i>639</i>&nbsp;        // Placeholder for an error report by a Throwable
<i>640</i>&nbsp;        private volatile Throwable cause;
<b class="nc"><i>641</i>&nbsp;</b>
<i>642</i>&nbsp;        // ResourceBundleProviders for loading ResourceBundles
<i>643</i>&nbsp;        private volatile ServiceLoader&lt;ResourceBundleProvider&gt; providers;
<i>644</i>&nbsp;        private volatile boolean providersChecked;
<b class="nc"><i>645</i>&nbsp;</b>
<b class="nc"><i>646</i>&nbsp;        // Boolean.TRUE if the factory method caller provides a ResourceBundleProvier.</b>
<b class="nc"><i>647</i>&nbsp;        private volatile Boolean callerHasProvider;</b>
<b class="nc"><i>648</i>&nbsp;</b>
<b class="nc"><i>649</i>&nbsp;        CacheKey(String baseName, Locale locale, Module module, Module caller) {</b>
<i>650</i>&nbsp;            Objects.requireNonNull(module);
<i>651</i>&nbsp;            Objects.requireNonNull(caller);
<i>652</i>&nbsp;
<i>653</i>&nbsp;            this.name = baseName;
<i>654</i>&nbsp;            this.locale = locale;
<b class="nc"><i>655</i>&nbsp;            this.moduleRef = new KeyElementReference&lt;&gt;(module, referenceQueue, this);</b>
<b class="nc"><i>656</i>&nbsp;            this.callerRef = new KeyElementReference&lt;&gt;(caller, referenceQueue, this);</b>
<b class="nc"><i>657</i>&nbsp;            this.modulesHash = module.hashCode() ^ caller.hashCode();</b>
<b class="nc"><i>658</i>&nbsp;        }</b>
<i>659</i>&nbsp;
<i>660</i>&nbsp;        CacheKey(CacheKey src) {
<b class="nc"><i>661</i>&nbsp;            // Create References to src&#39;s modules</b>
<b class="nc"><i>662</i>&nbsp;            this.moduleRef = new KeyElementReference&lt;&gt;(</b>
<b class="nc"><i>663</i>&nbsp;                Objects.requireNonNull(src.getModule()), referenceQueue, this);</b>
<i>664</i>&nbsp;            this.callerRef = new KeyElementReference&lt;&gt;(
<b class="nc"><i>665</i>&nbsp;                Objects.requireNonNull(src.getCallerModule()), referenceQueue, this);</b>
<i>666</i>&nbsp;            // Copy fields from src. ResourceBundleProviders related fields
<i>667</i>&nbsp;            // and &quot;cause&quot; should not be copied.
<i>668</i>&nbsp;            this.name = src.name;
<i>669</i>&nbsp;            this.locale = src.locale;
<b class="nc"><i>670</i>&nbsp;            this.modulesHash = src.modulesHash;</b>
<i>671</i>&nbsp;            this.format = src.format;
<i>672</i>&nbsp;            this.loadTime = src.loadTime;
<i>673</i>&nbsp;            this.expirationTime = src.expirationTime;
<b class="nc"><i>674</i>&nbsp;        }</b>
<i>675</i>&nbsp;
<i>676</i>&nbsp;        String getName() {
<i>677</i>&nbsp;            return name;
<b class="nc"><i>678</i>&nbsp;        }</b>
<b class="nc"><i>679</i>&nbsp;</b>
<i>680</i>&nbsp;        Locale getLocale() {
<i>681</i>&nbsp;            return locale;
<i>682</i>&nbsp;        }
<b class="nc"><i>683</i>&nbsp;</b>
<b class="nc"><i>684</i>&nbsp;        CacheKey setLocale(Locale locale) {</b>
<i>685</i>&nbsp;            this.locale = locale;
<i>686</i>&nbsp;            return this;
<i>687</i>&nbsp;        }
<i>688</i>&nbsp;
<i>689</i>&nbsp;        Module getModule() {
<b class="nc"><i>690</i>&nbsp;            return moduleRef.get();</b>
<i>691</i>&nbsp;        }
<i>692</i>&nbsp;
<i>693</i>&nbsp;        Module getCallerModule() {
<b class="nc"><i>694</i>&nbsp;            return callerRef.get();</b>
<b class="nc"><i>695</i>&nbsp;        }</b>
<b class="nc"><i>696</i>&nbsp;</b>
<b class="nc"><i>697</i>&nbsp;        ServiceLoader&lt;ResourceBundleProvider&gt; getProviders() {</b>
<i>698</i>&nbsp;            if (!providersChecked) {
<b class="nc"><i>699</i>&nbsp;                providers = getServiceLoader(getModule(), name);</b>
<i>700</i>&nbsp;                providersChecked = true;
<i>701</i>&nbsp;            }
<b class="nc"><i>702</i>&nbsp;            return providers;</b>
<i>703</i>&nbsp;        }
<i>704</i>&nbsp;
<i>705</i>&nbsp;        boolean hasProviders() {
<i>706</i>&nbsp;            return getProviders() != null;
<i>707</i>&nbsp;        }
<i>708</i>&nbsp;
<i>709</i>&nbsp;        boolean callerHasProvider() {
<i>710</i>&nbsp;            return callerHasProvider == Boolean.TRUE;
<i>711</i>&nbsp;        }
<i>712</i>&nbsp;
<i>713</i>&nbsp;        @Override
<i>714</i>&nbsp;        public boolean equals(Object other) {
<i>715</i>&nbsp;            if (this == other) {
<i>716</i>&nbsp;                return true;
<i>717</i>&nbsp;            }
<i>718</i>&nbsp;            try {
<i>719</i>&nbsp;                final CacheKey otherEntry = (CacheKey)other;
<i>720</i>&nbsp;                //quick check to see if they are not equal
<i>721</i>&nbsp;                if (modulesHash != otherEntry.modulesHash) {
<i>722</i>&nbsp;                    return false;
<i>723</i>&nbsp;                }
<i>724</i>&nbsp;                //are the names the same?
<b class="nc"><i>725</i>&nbsp;                if (!name.equals(otherEntry.name)) {</b>
<b class="nc"><i>726</i>&nbsp;                    return false;</b>
<i>727</i>&nbsp;                }
<i>728</i>&nbsp;                // are the locales the same?
<i>729</i>&nbsp;                if (!locale.equals(otherEntry.locale)) {
<b class="nc"><i>730</i>&nbsp;                    return false;</b>
<i>731</i>&nbsp;                }
<i>732</i>&nbsp;                // are modules and callerModules the same and non-null?
<i>733</i>&nbsp;                Module module = getModule();
<i>734</i>&nbsp;                Module caller = getCallerModule();
<i>735</i>&nbsp;                return ((module != null) &amp;&amp; (module.equals(otherEntry.getModule())) &amp;&amp;
<i>736</i>&nbsp;                        (caller != null) &amp;&amp; (caller.equals(otherEntry.getCallerModule())));
<i>737</i>&nbsp;            } catch (NullPointerException | ClassCastException e) {
<i>738</i>&nbsp;            }
<i>739</i>&nbsp;            return false;
<i>740</i>&nbsp;        }
<i>741</i>&nbsp;
<i>742</i>&nbsp;        @Override
<b class="nc"><i>743</i>&nbsp;        public int hashCode() {</b>
<b class="nc"><i>744</i>&nbsp;            return (name.hashCode() &lt;&lt; 3) ^ locale.hashCode() ^ modulesHash;</b>
<i>745</i>&nbsp;        }
<i>746</i>&nbsp;
<i>747</i>&nbsp;        String getFormat() {
<b class="nc"><i>748</i>&nbsp;            return format;</b>
<i>749</i>&nbsp;        }
<i>750</i>&nbsp;
<i>751</i>&nbsp;        void setFormat(String format) {
<i>752</i>&nbsp;            this.format = format;
<i>753</i>&nbsp;        }
<i>754</i>&nbsp;
<i>755</i>&nbsp;        private void setCause(Throwable cause) {
<i>756</i>&nbsp;            if (this.cause == null) {
<i>757</i>&nbsp;                this.cause = cause;
<i>758</i>&nbsp;            } else {
<i>759</i>&nbsp;                // Override the cause if the previous one is
<i>760</i>&nbsp;                // ClassNotFoundException.
<i>761</i>&nbsp;                if (this.cause instanceof ClassNotFoundException) {
<i>762</i>&nbsp;                    this.cause = cause;
<i>763</i>&nbsp;                }
<i>764</i>&nbsp;            }
<i>765</i>&nbsp;        }
<i>766</i>&nbsp;
<i>767</i>&nbsp;        private Throwable getCause() {
<i>768</i>&nbsp;            return cause;
<i>769</i>&nbsp;        }
<i>770</i>&nbsp;
<i>771</i>&nbsp;        @Override
<i>772</i>&nbsp;        public String toString() {
<b class="nc"><i>773</i>&nbsp;            String l = locale.toString();</b>
<b class="nc"><i>774</i>&nbsp;            if (l.length() == 0) {</b>
<b class="nc"><i>775</i>&nbsp;                if (locale.getVariant().length() != 0) {</b>
<i>776</i>&nbsp;                    l = &quot;__&quot; + locale.getVariant();
<i>777</i>&nbsp;                } else {
<i>778</i>&nbsp;                    l = &quot;\&quot;\&quot;&quot;;
<i>779</i>&nbsp;                }
<i>780</i>&nbsp;            }
<i>781</i>&nbsp;            return &quot;CacheKey[&quot; + name +
<i>782</i>&nbsp;                   &quot;, locale=&quot; + l +
<i>783</i>&nbsp;                   &quot;, module=&quot; + getModule() +
<i>784</i>&nbsp;                   &quot;, callerModule=&quot; + getCallerModule() +
<i>785</i>&nbsp;                   &quot;, format=&quot; + format +
<i>786</i>&nbsp;                   &quot;]&quot;;
<i>787</i>&nbsp;        }
<i>788</i>&nbsp;    }
<i>789</i>&nbsp;
<i>790</i>&nbsp;    /**
<i>791</i>&nbsp;     * The common interface to get a CacheKey in LoaderReference and
<i>792</i>&nbsp;     * BundleReference.
<i>793</i>&nbsp;     */
<i>794</i>&nbsp;    private static interface CacheKeyReference {
<i>795</i>&nbsp;        public CacheKey getCacheKey();
<i>796</i>&nbsp;    }
<i>797</i>&nbsp;
<i>798</i>&nbsp;    /**
<i>799</i>&nbsp;     * References to a CacheKey element as a WeakReference so that it can be
<i>800</i>&nbsp;     * garbage collected when nobody else is using it.
<i>801</i>&nbsp;     */
<i>802</i>&nbsp;    private static class KeyElementReference&lt;T&gt; extends WeakReference&lt;T&gt;
<i>803</i>&nbsp;                                                implements CacheKeyReference {
<i>804</i>&nbsp;        private final CacheKey cacheKey;
<i>805</i>&nbsp;
<i>806</i>&nbsp;        KeyElementReference(T referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
<i>807</i>&nbsp;            super(referent, q);
<i>808</i>&nbsp;            cacheKey = key;
<i>809</i>&nbsp;        }
<i>810</i>&nbsp;
<i>811</i>&nbsp;        @Override
<i>812</i>&nbsp;        public CacheKey getCacheKey() {
<i>813</i>&nbsp;            return cacheKey;
<i>814</i>&nbsp;        }
<b class="nc"><i>815</i>&nbsp;    }</b>
<b class="nc"><i>816</i>&nbsp;</b>
<i>817</i>&nbsp;    /**
<i>818</i>&nbsp;     * References to bundles are soft references so that they can be garbage
<i>819</i>&nbsp;     * collected when they have no hard references.
<i>820</i>&nbsp;     */
<i>821</i>&nbsp;    private static class BundleReference extends SoftReference&lt;ResourceBundle&gt;
<i>822</i>&nbsp;                                         implements CacheKeyReference {
<i>823</i>&nbsp;        private final CacheKey cacheKey;
<i>824</i>&nbsp;
<i>825</i>&nbsp;        BundleReference(ResourceBundle referent, ReferenceQueue&lt;Object&gt; q, CacheKey key) {
<i>826</i>&nbsp;            super(referent, q);
<i>827</i>&nbsp;            cacheKey = key;
<i>828</i>&nbsp;        }
<i>829</i>&nbsp;
<i>830</i>&nbsp;        @Override
<i>831</i>&nbsp;        public CacheKey getCacheKey() {
<i>832</i>&nbsp;            return cacheKey;
<i>833</i>&nbsp;        }
<i>834</i>&nbsp;    }
<i>835</i>&nbsp;
<i>836</i>&nbsp;    /**
<i>837</i>&nbsp;     * Gets a resource bundle using the specified base name, the default locale,
<i>838</i>&nbsp;     * and the caller module. Calling this method is equivalent to calling
<i>839</i>&nbsp;     * &lt;blockquote&gt;
<i>840</i>&nbsp;     * &lt;code&gt;getBundle(baseName, Locale.getDefault(), callerModule)&lt;/code&gt;,
<i>841</i>&nbsp;     * &lt;/blockquote&gt;
<i>842</i>&nbsp;     *
<i>843</i>&nbsp;     * @param baseName the base name of the resource bundle, a fully qualified class name
<i>844</i>&nbsp;     * @exception java.lang.NullPointerException
<b class="nc"><i>845</i>&nbsp;     *     if &lt;code&gt;baseName&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;</b>
<b class="nc"><i>846</i>&nbsp;     * @exception MissingResourceException</b>
<b class="nc"><i>847</i>&nbsp;     *     if no resource bundle for the specified base name can be found</b>
<i>848</i>&nbsp;     * @return a resource bundle for the given base name and the default locale
<i>849</i>&nbsp;     *
<i>850</i>&nbsp;     * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
<i>851</i>&nbsp;     * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<i>852</i>&nbsp;     */
<i>853</i>&nbsp;    @CallerSensitive
<i>854</i>&nbsp;    public static final ResourceBundle getBundle(String baseName)
<i>855</i>&nbsp;    {
<i>856</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>857</i>&nbsp;        return getBundleImpl(baseName, Locale.getDefault(),
<i>858</i>&nbsp;                             caller, getDefaultControl(caller, baseName));
<i>859</i>&nbsp;    }
<i>860</i>&nbsp;
<i>861</i>&nbsp;    /**
<i>862</i>&nbsp;     * Returns a resource bundle using the specified base name, the
<i>863</i>&nbsp;     * default locale and the specified control. Calling this method
<i>864</i>&nbsp;     * is equivalent to calling
<i>865</i>&nbsp;     * &lt;pre&gt;
<i>866</i>&nbsp;     * getBundle(baseName, Locale.getDefault(),
<i>867</i>&nbsp;     *           this.getClass().getClassLoader(), control),
<i>868</i>&nbsp;     * &lt;/pre&gt;
<i>869</i>&nbsp;     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
<i>870</i>&nbsp;     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link
<i>871</i>&nbsp;     * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
<i>872</i>&nbsp;     * complete description of the resource bundle loading process with a
<i>873</i>&nbsp;     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.
<i>874</i>&nbsp;     *
<i>875</i>&nbsp;     * @param baseName
<i>876</i>&nbsp;     *        the base name of the resource bundle, a fully qualified class
<i>877</i>&nbsp;     *        name
<i>878</i>&nbsp;     * @param control
<i>879</i>&nbsp;     *        the control which gives information for the resource bundle
<i>880</i>&nbsp;     *        loading process
<i>881</i>&nbsp;     * @return a resource bundle for the given base name and the default locale
<i>882</i>&nbsp;     * @throws NullPointerException
<i>883</i>&nbsp;     *         if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;control&lt;/code&gt; is
<i>884</i>&nbsp;     *         &lt;code&gt;null&lt;/code&gt;
<i>885</i>&nbsp;     * @throws MissingResourceException
<i>886</i>&nbsp;     *         if no resource bundle for the specified base name can be found
<i>887</i>&nbsp;     * @throws IllegalArgumentException
<i>888</i>&nbsp;     *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly
<i>889</i>&nbsp;     *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
<b class="nc"><i>890</i>&nbsp;     *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as</b>
<b class="nc"><i>891</i>&nbsp;     *         needed.</b>
<i>892</i>&nbsp;     * @throws UnsupportedOperationException
<i>893</i>&nbsp;     *         if this method is called in a named module
<i>894</i>&nbsp;     * @since 1.6
<i>895</i>&nbsp;     * @revised 9
<i>896</i>&nbsp;     * @spec JPMS
<i>897</i>&nbsp;     */
<i>898</i>&nbsp;    @CallerSensitive
<i>899</i>&nbsp;    public static final ResourceBundle getBundle(String baseName,
<i>900</i>&nbsp;                                                 Control control) {
<i>901</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>902</i>&nbsp;        Locale targetLocale = Locale.getDefault();
<i>903</i>&nbsp;        checkNamedModule(caller);
<i>904</i>&nbsp;        return getBundleImpl(baseName, targetLocale, caller, control);
<i>905</i>&nbsp;    }
<i>906</i>&nbsp;
<i>907</i>&nbsp;    /**
<i>908</i>&nbsp;     * Gets a resource bundle using the specified base name and locale,
<i>909</i>&nbsp;     * and the caller module. Calling this method is equivalent to calling
<i>910</i>&nbsp;     * &lt;blockquote&gt;
<i>911</i>&nbsp;     * &lt;code&gt;getBundle(baseName, locale, callerModule)&lt;/code&gt;,
<i>912</i>&nbsp;     * &lt;/blockquote&gt;
<i>913</i>&nbsp;     *
<i>914</i>&nbsp;     * @param baseName
<i>915</i>&nbsp;     *        the base name of the resource bundle, a fully qualified class name
<i>916</i>&nbsp;     * @param locale
<i>917</i>&nbsp;     *        the locale for which a resource bundle is desired
<i>918</i>&nbsp;     * @exception NullPointerException
<i>919</i>&nbsp;     *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>920</i>&nbsp;     * @exception MissingResourceException
<i>921</i>&nbsp;     *        if no resource bundle for the specified base name can be found
<i>922</i>&nbsp;     * @return a resource bundle for the given base name and locale
<i>923</i>&nbsp;     *
<i>924</i>&nbsp;     * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
<i>925</i>&nbsp;     * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<i>926</i>&nbsp;     */
<i>927</i>&nbsp;    @CallerSensitive
<i>928</i>&nbsp;    public static final ResourceBundle getBundle(String baseName,
<i>929</i>&nbsp;                                                 Locale locale)
<i>930</i>&nbsp;    {
<i>931</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>932</i>&nbsp;        return getBundleImpl(baseName, locale,
<i>933</i>&nbsp;                             caller, getDefaultControl(caller, baseName));
<i>934</i>&nbsp;    }
<i>935</i>&nbsp;
<i>936</i>&nbsp;    /**
<i>937</i>&nbsp;     * Gets a resource bundle using the specified base name and the default locale
<i>938</i>&nbsp;     * on behalf of the specified module. This method is equivalent to calling
<i>939</i>&nbsp;     * &lt;blockquote&gt;
<i>940</i>&nbsp;     * &lt;code&gt;getBundle(baseName, Locale.getDefault(), module)&lt;/code&gt;
<i>941</i>&nbsp;     * &lt;/blockquote&gt;
<i>942</i>&nbsp;     *
<i>943</i>&nbsp;     * @param baseName the base name of the resource bundle,
<i>944</i>&nbsp;     *                 a fully qualified class name
<i>945</i>&nbsp;     * @param module   the module for which the resource bundle is searched
<i>946</i>&nbsp;     * @throws NullPointerException
<i>947</i>&nbsp;     *         if {@code baseName} or {@code module} is {@code null}
<i>948</i>&nbsp;     * @throws SecurityException
<i>949</i>&nbsp;     *         if a security manager exists and the caller is not the specified
<i>950</i>&nbsp;     *         module and doesn&#39;t have {@code RuntimePermission(&quot;getClassLoader&quot;)}
<i>951</i>&nbsp;     * @throws MissingResourceException
<i>952</i>&nbsp;     *         if no resource bundle for the specified base name can be found in the
<i>953</i>&nbsp;     *         specified module
<i>954</i>&nbsp;     * @return a resource bundle for the given base name and the default locale
<i>955</i>&nbsp;     * @since 9
<i>956</i>&nbsp;     * @spec JPMS
<i>957</i>&nbsp;     * @see ResourceBundleProvider
<i>958</i>&nbsp;     * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
<i>959</i>&nbsp;     * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<i>960</i>&nbsp;     */
<i>961</i>&nbsp;    @CallerSensitive
<i>962</i>&nbsp;    public static ResourceBundle getBundle(String baseName, Module module) {
<i>963</i>&nbsp;        return getBundleFromModule(Reflection.getCallerClass(), module, baseName,
<i>964</i>&nbsp;                                   Locale.getDefault(),
<i>965</i>&nbsp;                                   getDefaultControl(module, baseName));
<i>966</i>&nbsp;    }
<i>967</i>&nbsp;
<i>968</i>&nbsp;    /**
<i>969</i>&nbsp;     * Gets a resource bundle using the specified base name and locale
<i>970</i>&nbsp;     * on behalf of the specified module.
<i>971</i>&nbsp;     *
<i>972</i>&nbsp;     * &lt;p&gt; Resource bundles in named modules may be encapsulated.  When
<i>973</i>&nbsp;     * the resource bundle is loaded from a
<i>974</i>&nbsp;     * {@linkplain ResourceBundleProvider service provider}, the caller module
<i>975</i>&nbsp;     * must have an appropriate &lt;i&gt;uses&lt;/i&gt; clause in its &lt;i&gt;module descriptor&lt;/i&gt;
<i>976</i>&nbsp;     * to declare that the module uses of {@link ResourceBundleProvider}
<i>977</i>&nbsp;     * for the named resource bundle.
<i>978</i>&nbsp;     * Otherwise, it will load the resource bundles that are local in the
<i>979</i>&nbsp;     * given module as if calling {@link Module#getResourceAsStream(String)}
<i>980</i>&nbsp;     * or that are visible to the class loader of the given module
<i>981</i>&nbsp;     * as if calling {@link ClassLoader#getResourceAsStream(String)}.
<i>982</i>&nbsp;     * When the resource bundle is loaded from the specified module, it is
<i>983</i>&nbsp;     * subject to the encapsulation rules specified by
<i>984</i>&nbsp;     * {@link Module#getResourceAsStream Module.getResourceAsStream}.
<i>985</i>&nbsp;     *
<i>986</i>&nbsp;     * &lt;p&gt;
<i>987</i>&nbsp;     * If the given {@code module} is an unnamed module, then this method is
<i>988</i>&nbsp;     * equivalent to calling {@link #getBundle(String, Locale, ClassLoader)
<i>989</i>&nbsp;     * getBundle(baseName, targetLocale, module.getClassLoader()} to load
<i>990</i>&nbsp;     * resource bundles that are visible to the class loader of the given
<i>991</i>&nbsp;     * unnamed module. Custom {@link java.util.spi.ResourceBundleControlProvider}
<i>992</i>&nbsp;     * implementations, if present, will only be invoked if the specified
<i>993</i>&nbsp;     * module is an unnamed module.
<i>994</i>&nbsp;     *
<i>995</i>&nbsp;     * @param baseName the base name of the resource bundle,
<i>996</i>&nbsp;     *                 a fully qualified class name
<i>997</i>&nbsp;     * @param targetLocale the locale for which a resource bundle is desired
<i>998</i>&nbsp;     * @param module   the module for which the resource bundle is searched
<i>999</i>&nbsp;     * @throws NullPointerException
<i>1000</i>&nbsp;     *         if {@code baseName}, {@code targetLocale}, or {@code module} is
<i>1001</i>&nbsp;     *         {@code null}
<i>1002</i>&nbsp;     * @throws SecurityException
<i>1003</i>&nbsp;     *         if a security manager exists and the caller is not the specified
<i>1004</i>&nbsp;     *         module and doesn&#39;t have {@code RuntimePermission(&quot;getClassLoader&quot;)}
<i>1005</i>&nbsp;     * @throws MissingResourceException
<i>1006</i>&nbsp;     *         if no resource bundle for the specified base name and locale can
<i>1007</i>&nbsp;     *         be found in the specified {@code module}
<i>1008</i>&nbsp;     * @return a resource bundle for the given base name and locale in the module
<i>1009</i>&nbsp;     * @since 9
<i>1010</i>&nbsp;     * @spec JPMS
<i>1011</i>&nbsp;     * @see &lt;a href=&quot;#default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;
<i>1012</i>&nbsp;     * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<i>1013</i>&nbsp;     */
<i>1014</i>&nbsp;    @CallerSensitive
<i>1015</i>&nbsp;    public static ResourceBundle getBundle(String baseName, Locale targetLocale, Module module) {
<i>1016</i>&nbsp;        return getBundleFromModule(Reflection.getCallerClass(), module, baseName, targetLocale,
<i>1017</i>&nbsp;                                   getDefaultControl(module, baseName));
<i>1018</i>&nbsp;    }
<i>1019</i>&nbsp;
<i>1020</i>&nbsp;    /**
<i>1021</i>&nbsp;     * Returns a resource bundle using the specified base name, target
<i>1022</i>&nbsp;     * locale and control, and the caller&#39;s class loader. Calling this
<i>1023</i>&nbsp;     * method is equivalent to calling
<i>1024</i>&nbsp;     * &lt;pre&gt;
<i>1025</i>&nbsp;     * getBundle(baseName, targetLocale, this.getClass().getClassLoader(),
<i>1026</i>&nbsp;     *           control),
<i>1027</i>&nbsp;     * &lt;/pre&gt;
<i>1028</i>&nbsp;     * except that &lt;code&gt;getClassLoader()&lt;/code&gt; is run with the security
<i>1029</i>&nbsp;     * privileges of &lt;code&gt;ResourceBundle&lt;/code&gt;.  See {@link
<i>1030</i>&nbsp;     * #getBundle(String, Locale, ClassLoader, Control) getBundle} for the
<i>1031</i>&nbsp;     * complete description of the resource bundle loading process with a
<i>1032</i>&nbsp;     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;.
<i>1033</i>&nbsp;     *
<i>1034</i>&nbsp;     * @param baseName
<i>1035</i>&nbsp;     *        the base name of the resource bundle, a fully qualified
<i>1036</i>&nbsp;     *        class name
<i>1037</i>&nbsp;     * @param targetLocale
<i>1038</i>&nbsp;     *        the locale for which a resource bundle is desired
<i>1039</i>&nbsp;     * @param control
<i>1040</i>&nbsp;     *        the control which gives information for the resource
<i>1041</i>&nbsp;     *        bundle loading process
<i>1042</i>&nbsp;     * @return a resource bundle for the given base name and a
<i>1043</i>&nbsp;     *         &lt;code&gt;Locale&lt;/code&gt; in &lt;code&gt;locales&lt;/code&gt;
<i>1044</i>&nbsp;     * @throws NullPointerException
<i>1045</i>&nbsp;     *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locales&lt;/code&gt; or
<i>1046</i>&nbsp;     *         &lt;code&gt;control&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1047</i>&nbsp;     * @throws MissingResourceException
<i>1048</i>&nbsp;     *         if no resource bundle for the specified base name in any
<i>1049</i>&nbsp;     *         of the &lt;code&gt;locales&lt;/code&gt; can be found.
<i>1050</i>&nbsp;     * @throws IllegalArgumentException
<i>1051</i>&nbsp;     *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly
<i>1052</i>&nbsp;     *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
<i>1053</i>&nbsp;     *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
<i>1054</i>&nbsp;     *         needed.
<i>1055</i>&nbsp;     * @throws UnsupportedOperationException
<i>1056</i>&nbsp;     *         if this method is called in a named module
<i>1057</i>&nbsp;     * @since 1.6
<i>1058</i>&nbsp;     * @revised 9
<i>1059</i>&nbsp;     * @spec JPMS
<i>1060</i>&nbsp;     */
<i>1061</i>&nbsp;    @CallerSensitive
<i>1062</i>&nbsp;    public static final ResourceBundle getBundle(String baseName, Locale targetLocale,
<i>1063</i>&nbsp;                                                 Control control) {
<i>1064</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>1065</i>&nbsp;        checkNamedModule(caller);
<i>1066</i>&nbsp;        return getBundleImpl(baseName, targetLocale, caller, control);
<i>1067</i>&nbsp;    }
<i>1068</i>&nbsp;
<i>1069</i>&nbsp;    /**
<i>1070</i>&nbsp;     * Gets a resource bundle using the specified base name, locale, and class
<i>1071</i>&nbsp;     * loader.
<i>1072</i>&nbsp;     *
<i>1073</i>&nbsp;     * &lt;p&gt;When this method is called from a named module and the given
<i>1074</i>&nbsp;     * loader is the class loader of the caller module, this is equivalent
<i>1075</i>&nbsp;     * to calling:
<i>1076</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>1077</i>&nbsp;     * getBundle(baseName, targetLocale, callerModule)
<i>1078</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<b class="nc"><i>1079</i>&nbsp;     *</b>
<b class="nc"><i>1080</i>&nbsp;     * otherwise, this is equivalent to calling:</b>
<i>1081</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<b class="nc"><i>1082</i>&nbsp;     * getBundle(baseName, targetLocale, loader, control)</b>
<i>1083</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>1084</i>&nbsp;     * where {@code control} is the default instance of {@link Control} unless
<i>1085</i>&nbsp;     * a {@code Control} instance is provided by
<i>1086</i>&nbsp;     * {@link ResourceBundleControlProvider} SPI.  Refer to the
<i>1087</i>&nbsp;     * description of &lt;a href=&quot;#modify_default_behavior&quot;&gt;modifying the default
<i>1088</i>&nbsp;     * behavior&lt;/a&gt;. The following describes the default behavior.
<i>1089</i>&nbsp;     *
<i>1090</i>&nbsp;     * &lt;p&gt;
<i>1091</i>&nbsp;     * &lt;b&gt;&lt;a id=&quot;default_behavior&quot;&gt;Resource Bundle Search and Loading Strategy&lt;/a&gt;&lt;/b&gt;
<i>1092</i>&nbsp;     *
<i>1093</i>&nbsp;     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; uses the base name, the specified locale, and
<i>1094</i>&nbsp;     * the default locale (obtained from {@link java.util.Locale#getDefault()
<i>1095</i>&nbsp;     * Locale.getDefault}) to generate a sequence of &lt;a
<i>1096</i>&nbsp;     * id=&quot;candidates&quot;&gt;&lt;em&gt;candidate bundle names&lt;/em&gt;&lt;/a&gt;.  If the specified
<i>1097</i>&nbsp;     * locale&#39;s language, script, country, and variant are all empty strings,
<i>1098</i>&nbsp;     * then the base name is the only candidate bundle name.  Otherwise, a list
<i>1099</i>&nbsp;     * of candidate locales is generated from the attribute values of the
<i>1100</i>&nbsp;     * specified locale (language, script, country and variant) and appended to
<i>1101</i>&nbsp;     * the base name.  Typically, this will look like the following:
<i>1102</i>&nbsp;     *
<i>1103</i>&nbsp;     * &lt;pre&gt;
<i>1104</i>&nbsp;     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
<i>1105</i>&nbsp;     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country
<i>1106</i>&nbsp;     *     baseName + &quot;_&quot; + language + &quot;_&quot; + script
<i>1107</i>&nbsp;     *     baseName + &quot;_&quot; + language + &quot;_&quot; + country + &quot;_&quot; + variant
<i>1108</i>&nbsp;     *     baseName + &quot;_&quot; + language + &quot;_&quot; + country
<i>1109</i>&nbsp;     *     baseName + &quot;_&quot; + language
<i>1110</i>&nbsp;     * &lt;/pre&gt;
<i>1111</i>&nbsp;     *
<i>1112</i>&nbsp;     * &lt;p&gt;Candidate bundle names where the final component is an empty string
<i>1113</i>&nbsp;     * are omitted, along with the underscore.  For example, if country is an
<i>1114</i>&nbsp;     * empty string, the second and the fifth candidate bundle names above
<i>1115</i>&nbsp;     * would be omitted.  Also, if script is an empty string, the candidate names
<i>1116</i>&nbsp;     * including script are omitted.  For example, a locale with language &quot;de&quot;
<i>1117</i>&nbsp;     * and variant &quot;JAVA&quot; will produce candidate names with base name
<i>1118</i>&nbsp;     * &quot;MyResource&quot; below.
<i>1119</i>&nbsp;     *
<i>1120</i>&nbsp;     * &lt;pre&gt;
<i>1121</i>&nbsp;     *     MyResource_de__JAVA
<i>1122</i>&nbsp;     *     MyResource_de
<i>1123</i>&nbsp;     * &lt;/pre&gt;
<i>1124</i>&nbsp;     *
<i>1125</i>&nbsp;     * In the case that the variant contains one or more underscores (&#39;_&#39;), a
<i>1126</i>&nbsp;     * sequence of bundle names generated by truncating the last underscore and
<i>1127</i>&nbsp;     * the part following it is inserted after a candidate bundle name with the
<i>1128</i>&nbsp;     * original variant.  For example, for a locale with language &quot;en&quot;, script
<i>1129</i>&nbsp;     * &quot;Latn, country &quot;US&quot; and variant &quot;WINDOWS_VISTA&quot;, and bundle base name
<i>1130</i>&nbsp;     * &quot;MyResource&quot;, the list of candidate bundle names below is generated:
<i>1131</i>&nbsp;     *
<i>1132</i>&nbsp;     * &lt;pre&gt;
<i>1133</i>&nbsp;     * MyResource_en_Latn_US_WINDOWS_VISTA
<i>1134</i>&nbsp;     * MyResource_en_Latn_US_WINDOWS
<i>1135</i>&nbsp;     * MyResource_en_Latn_US
<i>1136</i>&nbsp;     * MyResource_en_Latn
<i>1137</i>&nbsp;     * MyResource_en_US_WINDOWS_VISTA
<i>1138</i>&nbsp;     * MyResource_en_US_WINDOWS
<i>1139</i>&nbsp;     * MyResource_en_US
<i>1140</i>&nbsp;     * MyResource_en
<i>1141</i>&nbsp;     * &lt;/pre&gt;
<i>1142</i>&nbsp;     *
<i>1143</i>&nbsp;     * &lt;blockquote&gt;&lt;b&gt;Note:&lt;/b&gt; For some &lt;code&gt;Locale&lt;/code&gt;s, the list of
<i>1144</i>&nbsp;     * candidate bundle names contains extra names, or the order of bundle names
<i>1145</i>&nbsp;     * is slightly modified.  See the description of the default implementation
<i>1146</i>&nbsp;     * of {@link Control#getCandidateLocales(String, Locale)
<i>1147</i>&nbsp;     * getCandidateLocales} for details.&lt;/blockquote&gt;
<i>1148</i>&nbsp;     *
<i>1149</i>&nbsp;     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; then iterates over the candidate bundle names
<i>1150</i>&nbsp;     * to find the first one for which it can &lt;em&gt;instantiate&lt;/em&gt; an actual
<i>1151</i>&nbsp;     * resource bundle. It uses the default controls&#39; {@link Control#getFormats
<i>1152</i>&nbsp;     * getFormats} method, which generates two bundle names for each generated
<i>1153</i>&nbsp;     * name, the first a class name and the second a properties file name. For
<i>1154</i>&nbsp;     * each candidate bundle name, it attempts to create a resource bundle:
<i>1155</i>&nbsp;     *
<i>1156</i>&nbsp;     * &lt;ul&gt;&lt;li&gt;First, it attempts to load a class using the generated class name.
<i>1157</i>&nbsp;     * If such a class can be found and loaded using the specified class
<i>1158</i>&nbsp;     * loader, is assignment compatible with ResourceBundle, is accessible from
<i>1159</i>&nbsp;     * ResourceBundle, and can be instantiated, &lt;code&gt;getBundle&lt;/code&gt; creates a
<i>1160</i>&nbsp;     * new instance of this class and uses it as the &lt;em&gt;result resource
<i>1161</i>&nbsp;     * bundle&lt;/em&gt;.
<i>1162</i>&nbsp;     *
<i>1163</i>&nbsp;     * &lt;li&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; attempts to locate a property
<i>1164</i>&nbsp;     * resource file using the generated properties file name.  It generates a
<i>1165</i>&nbsp;     * path name from the candidate bundle name by replacing all &quot;.&quot; characters
<i>1166</i>&nbsp;     * with &quot;/&quot; and appending the string &quot;.properties&quot;.  It attempts to find a
<i>1167</i>&nbsp;     * &quot;resource&quot; with this name using {@link
<i>1168</i>&nbsp;     * java.lang.ClassLoader#getResource(java.lang.String)
<i>1169</i>&nbsp;     * ClassLoader.getResource}.  (Note that a &quot;resource&quot; in the sense of
<i>1170</i>&nbsp;     * &lt;code&gt;getResource&lt;/code&gt; has nothing to do with the contents of a
<i>1171</i>&nbsp;     * resource bundle, it is just a container of data, such as a file.)  If it
<i>1172</i>&nbsp;     * finds a &quot;resource&quot;, it attempts to create a new {@link
<i>1173</i>&nbsp;     * PropertyResourceBundle} instance from its contents.  If successful, this
<i>1174</i>&nbsp;     * instance becomes the &lt;em&gt;result resource bundle&lt;/em&gt;.  &lt;/ul&gt;
<i>1175</i>&nbsp;     *
<i>1176</i>&nbsp;     * &lt;p&gt;This continues until a result resource bundle is instantiated or the
<i>1177</i>&nbsp;     * list of candidate bundle names is exhausted.  If no matching resource
<i>1178</i>&nbsp;     * bundle is found, the default control&#39;s {@link Control#getFallbackLocale
<i>1179</i>&nbsp;     * getFallbackLocale} method is called, which returns the current default
<i>1180</i>&nbsp;     * locale.  A new sequence of candidate locale names is generated using this
<i>1181</i>&nbsp;     * locale and searched again, as above.
<i>1182</i>&nbsp;     *
<i>1183</i>&nbsp;     * &lt;p&gt;If still no result bundle is found, the base name alone is looked up. If
<i>1184</i>&nbsp;     * this still fails, a &lt;code&gt;MissingResourceException&lt;/code&gt; is thrown.
<i>1185</i>&nbsp;     *
<i>1186</i>&nbsp;     * &lt;p&gt;&lt;a id=&quot;parent_chain&quot;&gt; Once a result resource bundle has been found,
<i>1187</i>&nbsp;     * its &lt;em&gt;parent chain&lt;/em&gt; is instantiated&lt;/a&gt;.  If the result bundle already
<i>1188</i>&nbsp;     * has a parent (perhaps because it was returned from a cache) the chain is
<i>1189</i>&nbsp;     * complete.
<i>1190</i>&nbsp;     *
<i>1191</i>&nbsp;     * &lt;p&gt;Otherwise, &lt;code&gt;getBundle&lt;/code&gt; examines the remainder of the
<i>1192</i>&nbsp;     * candidate locale list that was used during the pass that generated the
<i>1193</i>&nbsp;     * result resource bundle.  (As before, candidate bundle names where the
<i>1194</i>&nbsp;     * final component is an empty string are omitted.)  When it comes to the
<i>1195</i>&nbsp;     * end of the candidate list, it tries the plain bundle name.  With each of the
<i>1196</i>&nbsp;     * candidate bundle names it attempts to instantiate a resource bundle (first
<i>1197</i>&nbsp;     * looking for a class and then a properties file, as described above).
<i>1198</i>&nbsp;     *
<i>1199</i>&nbsp;     * &lt;p&gt;Whenever it succeeds, it calls the previously instantiated resource
<i>1200</i>&nbsp;     * bundle&#39;s {@link #setParent(java.util.ResourceBundle) setParent} method
<i>1201</i>&nbsp;     * with the new resource bundle.  This continues until the list of names
<i>1202</i>&nbsp;     * is exhausted or the current bundle already has a non-null parent.
<i>1203</i>&nbsp;     *
<i>1204</i>&nbsp;     * &lt;p&gt;Once the parent chain is complete, the bundle is returned.
<i>1205</i>&nbsp;     *
<i>1206</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;code&gt;getBundle&lt;/code&gt; caches instantiated resource
<i>1207</i>&nbsp;     * bundles and might return the same resource bundle instance multiple times.
<i>1208</i>&nbsp;     *
<i>1209</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt;The &lt;code&gt;baseName&lt;/code&gt; argument should be a fully
<i>1210</i>&nbsp;     * qualified class name. However, for compatibility with earlier versions,
<i>1211</i>&nbsp;     * Java SE Runtime Environments do not verify this, and so it is
<i>1212</i>&nbsp;     * possible to access &lt;code&gt;PropertyResourceBundle&lt;/code&gt;s by specifying a
<i>1213</i>&nbsp;     * path name (using &quot;/&quot;) instead of a fully qualified class name (using
<i>1214</i>&nbsp;     * &quot;.&quot;).
<i>1215</i>&nbsp;     *
<i>1216</i>&nbsp;     * &lt;p&gt;&lt;a id=&quot;default_behavior_example&quot;&gt;
<i>1217</i>&nbsp;     * &lt;strong&gt;Example:&lt;/strong&gt;&lt;/a&gt;
<i>1218</i>&nbsp;     * &lt;p&gt;
<i>1219</i>&nbsp;     * The following class and property files are provided:
<i>1220</i>&nbsp;     * &lt;ul&gt;
<i>1221</i>&nbsp;     *     &lt;li&gt;MyResources.class
<i>1222</i>&nbsp;     *     &lt;li&gt;MyResources.properties
<i>1223</i>&nbsp;     *     &lt;li&gt;MyResources_fr.properties
<i>1224</i>&nbsp;     *     &lt;li&gt;MyResources_fr_CH.class
<i>1225</i>&nbsp;     *     &lt;li&gt;MyResources_fr_CH.properties
<i>1226</i>&nbsp;     *     &lt;li&gt;MyResources_en.properties
<i>1227</i>&nbsp;     *     &lt;li&gt;MyResources_es_ES.class
<i>1228</i>&nbsp;     * &lt;/ul&gt;
<i>1229</i>&nbsp;     *
<i>1230</i>&nbsp;     * The contents of all files are valid (that is, public non-abstract
<i>1231</i>&nbsp;     * subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt; for the &quot;.class&quot; files,
<i>1232</i>&nbsp;     * syntactically correct &quot;.properties&quot; files).  The default locale is
<i>1233</i>&nbsp;     * &lt;code&gt;Locale(&quot;en&quot;, &quot;GB&quot;)&lt;/code&gt;.
<i>1234</i>&nbsp;     *
<i>1235</i>&nbsp;     * &lt;p&gt;Calling &lt;code&gt;getBundle&lt;/code&gt; with the locale arguments below will
<i>1236</i>&nbsp;     * instantiate resource bundles as follows:
<i>1237</i>&nbsp;     *
<i>1238</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<i>1239</i>&nbsp;     * &lt;caption style=&quot;display:none&quot;&gt;getBundle() locale to resource bundle mapping&lt;/caption&gt;
<i>1240</i>&nbsp;     * &lt;thead&gt;
<i>1241</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Locale&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Resource bundle&lt;/th&gt;&lt;/tr&gt;
<i>1242</i>&nbsp;     * &lt;/thead&gt;
<i>1243</i>&nbsp;     * &lt;tbody&gt;
<i>1244</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;CH&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
<i>1245</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;fr&quot;, &quot;FR&quot;)&lt;/th&gt;&lt;td&gt;MyResources_fr.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
<i>1246</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
<i>1247</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;en&quot;, &quot;US&quot;)&lt;/th&gt;&lt;td&gt;MyResources_en.properties, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
<i>1248</i>&nbsp;     * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Locale(&quot;es&quot;, &quot;ES&quot;)&lt;/th&gt;&lt;td&gt;MyResources_es_ES.class, parent MyResources.class&lt;/td&gt;&lt;/tr&gt;
<i>1249</i>&nbsp;     * &lt;/tbody&gt;
<i>1250</i>&nbsp;     * &lt;/table&gt;
<i>1251</i>&nbsp;     *
<i>1252</i>&nbsp;     * &lt;p&gt;The file MyResources_fr_CH.properties is never used because it is
<i>1253</i>&nbsp;     * hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties
<i>1254</i>&nbsp;     * is also hidden by MyResources.class.
<i>1255</i>&nbsp;     *
<i>1256</i>&nbsp;     * @apiNote If the caller module is a named module and the given
<i>1257</i>&nbsp;     * {@code loader} is the caller module&#39;s class loader, this method is
<i>1258</i>&nbsp;     * equivalent to {@code getBundle(baseName, locale)}; otherwise, it may not
<i>1259</i>&nbsp;     * find resource bundles from named modules.
<i>1260</i>&nbsp;     * Use {@link #getBundle(String, Locale, Module)} to load resource bundles
<i>1261</i>&nbsp;     * on behalf on a specific module instead.
<i>1262</i>&nbsp;     *
<i>1263</i>&nbsp;     * @param baseName the base name of the resource bundle, a fully qualified class name
<i>1264</i>&nbsp;     * @param locale the locale for which a resource bundle is desired
<i>1265</i>&nbsp;     * @param loader the class loader from which to load the resource bundle
<i>1266</i>&nbsp;     * @return a resource bundle for the given base name and locale
<i>1267</i>&nbsp;     * @exception java.lang.NullPointerException
<i>1268</i>&nbsp;     *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1269</i>&nbsp;     * @exception MissingResourceException
<i>1270</i>&nbsp;     *        if no resource bundle for the specified base name can be found
<i>1271</i>&nbsp;     * @since 1.2
<i>1272</i>&nbsp;     * @revised 9
<i>1273</i>&nbsp;     * @spec JPMS
<i>1274</i>&nbsp;     * @see &lt;a href=&quot;#resource-bundle-modules&quot;&gt;Resource Bundles and Named Modules&lt;/a&gt;
<i>1275</i>&nbsp;     */
<i>1276</i>&nbsp;    @CallerSensitive
<i>1277</i>&nbsp;    public static ResourceBundle getBundle(String baseName, Locale locale,
<i>1278</i>&nbsp;                                           ClassLoader loader)
<i>1279</i>&nbsp;    {
<i>1280</i>&nbsp;        if (loader == null) {
<i>1281</i>&nbsp;            throw new NullPointerException();
<i>1282</i>&nbsp;        }
<i>1283</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>1284</i>&nbsp;        return getBundleImpl(baseName, locale, caller, loader, getDefaultControl(caller, baseName));
<i>1285</i>&nbsp;    }
<i>1286</i>&nbsp;
<i>1287</i>&nbsp;    /**
<i>1288</i>&nbsp;     * Returns a resource bundle using the specified base name, target
<i>1289</i>&nbsp;     * locale, class loader and control. Unlike the {@link
<i>1290</i>&nbsp;     * #getBundle(String, Locale, ClassLoader) getBundle}
<i>1291</i>&nbsp;     * factory methods with no {@code control} argument, the given
<i>1292</i>&nbsp;     * &lt;code&gt;control&lt;/code&gt; specifies how to locate and instantiate resource
<i>1293</i>&nbsp;     * bundles. Conceptually, the bundle loading process with the given
<i>1294</i>&nbsp;     * &lt;code&gt;control&lt;/code&gt; is performed in the following steps.
<i>1295</i>&nbsp;     *
<b class="nc"><i>1296</i>&nbsp;     * &lt;ol&gt;</b>
<b class="nc"><i>1297</i>&nbsp;     * &lt;li&gt;This factory method looks up the resource bundle in the cache for</b>
<i>1298</i>&nbsp;     * the specified &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt; and
<b class="nc"><i>1299</i>&nbsp;     * &lt;code&gt;loader&lt;/code&gt;.  If the requested resource bundle instance is</b>
<i>1300</i>&nbsp;     * found in the cache and the time-to-live periods of the instance and
<i>1301</i>&nbsp;     * all of its parent instances have not expired, the instance is returned
<i>1302</i>&nbsp;     * to the caller. Otherwise, this factory method proceeds with the
<b class="nc"><i>1303</i>&nbsp;     * loading process below.&lt;/li&gt;</b>
<b class="nc"><i>1304</i>&nbsp;     *</b>
<b class="nc"><i>1305</i>&nbsp;     * &lt;li&gt;The {@link ResourceBundle.Control#getFormats(String)</b>
<b class="nc"><i>1306</i>&nbsp;     * control.getFormats} method is called to get resource bundle formats</b>
<b class="nc"><i>1307</i>&nbsp;     * to produce bundle or resource names. The strings</b>
<i>1308</i>&nbsp;     * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;
<b class="nc"><i>1309</i>&nbsp;     * designate class-based and {@linkplain PropertyResourceBundle</b>
<i>1310</i>&nbsp;     * property}-based resource bundles, respectively. Other strings
<b class="nc"><i>1311</i>&nbsp;     * starting with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions</b>
<i>1312</i>&nbsp;     * and must not be used for application-defined formats. Other strings
<i>1313</i>&nbsp;     * designate application-defined formats.&lt;/li&gt;
<i>1314</i>&nbsp;     *
<i>1315</i>&nbsp;     * &lt;li&gt;The {@link ResourceBundle.Control#getCandidateLocales(String,
<b class="nc"><i>1316</i>&nbsp;     * Locale) control.getCandidateLocales} method is called with the target</b>
<b class="nc"><i>1317</i>&nbsp;     * locale to get a list of &lt;em&gt;candidate &lt;code&gt;Locale&lt;/code&gt;s&lt;/em&gt; for</b>
<i>1318</i>&nbsp;     * which resource bundles are searched.&lt;/li&gt;
<i>1319</i>&nbsp;     *
<i>1320</i>&nbsp;     * &lt;li&gt;The {@link ResourceBundle.Control#newBundle(String, Locale,
<i>1321</i>&nbsp;     * String, ClassLoader, boolean) control.newBundle} method is called to
<i>1322</i>&nbsp;     * instantiate a &lt;code&gt;ResourceBundle&lt;/code&gt; for the base bundle name, a
<i>1323</i>&nbsp;     * candidate locale, and a format. (Refer to the note on the cache
<b class="nc"><i>1324</i>&nbsp;     * lookup below.) This step is iterated over all combinations of the</b>
<b class="nc"><i>1325</i>&nbsp;     * candidate locales and formats until the &lt;code&gt;newBundle&lt;/code&gt; method</b>
<i>1326</i>&nbsp;     * returns a &lt;code&gt;ResourceBundle&lt;/code&gt; instance or the iteration has
<i>1327</i>&nbsp;     * used up all the combinations. For example, if the candidate locales
<b class="nc"><i>1328</i>&nbsp;     * are &lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;, &lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt; and</b>
<b class="nc"><i>1329</i>&nbsp;     * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; and the formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;</b>
<b class="nc"><i>1330</i>&nbsp;     * and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, then the following is the</b>
<b class="nc"><i>1331</i>&nbsp;     * sequence of locale-format combinations to be used to call</b>
<i>1332</i>&nbsp;     * &lt;code&gt;control.newBundle&lt;/code&gt;.
<i>1333</i>&nbsp;     *
<i>1334</i>&nbsp;     * &lt;table class=striped style=&quot;width: 50%; text-align: left; margin-left: 40px;&quot;&gt;
<i>1335</i>&nbsp;     * &lt;caption style=&quot;display:none&quot;&gt;locale-format combinations for newBundle&lt;/caption&gt;
<i>1336</i>&nbsp;     * &lt;thead&gt;
<i>1337</i>&nbsp;     * &lt;tr&gt;
<b class="nc"><i>1338</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;Index&lt;/th&gt;</b>
<b class="nc"><i>1339</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;Locale&lt;/code&gt;&lt;/th&gt;</b>
<i>1340</i>&nbsp;     * &lt;th scope=&quot;col&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/th&gt;
<i>1341</i>&nbsp;     * &lt;/tr&gt;
<i>1342</i>&nbsp;     * &lt;/thead&gt;
<i>1343</i>&nbsp;     * &lt;tbody&gt;
<i>1344</i>&nbsp;     * &lt;tr&gt;
<b class="nc"><i>1345</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;</b>
<i>1346</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;
<b class="nc"><i>1347</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1348</i>&nbsp;     * &lt;/tr&gt;</b>
<b class="nc"><i>1349</i>&nbsp;     * &lt;tr&gt;</b>
<i>1350</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
<i>1351</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;, &quot;DE&quot;)&lt;/code&gt;&lt;/td&gt;
<b class="nc"><i>1352</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1353</i>&nbsp;     * &lt;/tr&gt;</b>
<b class="nc"><i>1354</i>&nbsp;     * &lt;tr&gt;</b>
<b class="nc"><i>1355</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;</b>
<b class="nc"><i>1356</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1357</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1358</i>&nbsp;     * &lt;/tr&gt;</b>
<i>1359</i>&nbsp;     * &lt;tr&gt;
<i>1360</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;4&lt;/th&gt;
<b class="nc"><i>1361</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;de&quot;)&lt;/code&gt;&lt;/td&gt;</b>
<i>1362</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;
<i>1363</i>&nbsp;     * &lt;/tr&gt;
<i>1364</i>&nbsp;     * &lt;tr&gt;
<i>1365</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;5&lt;/th&gt;
<i>1366</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;
<i>1367</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.class&lt;/code&gt;&lt;/td&gt;
<b class="nc"><i>1368</i>&nbsp;     * &lt;/tr&gt;</b>
<b class="nc"><i>1369</i>&nbsp;     * &lt;tr&gt;</b>
<b class="nc"><i>1370</i>&nbsp;     * &lt;th scope=&quot;row&quot;&gt;6&lt;/th&gt;</b>
<b class="nc"><i>1371</i>&nbsp;     * &lt;td&gt;&lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1372</i>&nbsp;     * &lt;td&gt;&lt;code&gt;java.properties&lt;/code&gt;&lt;/td&gt;</b>
<b class="nc"><i>1373</i>&nbsp;     * &lt;/tr&gt;</b>
<i>1374</i>&nbsp;     * &lt;/tbody&gt;
<i>1375</i>&nbsp;     * &lt;/table&gt;
<i>1376</i>&nbsp;     * &lt;/li&gt;
<i>1377</i>&nbsp;     *
<i>1378</i>&nbsp;     * &lt;li&gt;If the previous step has found no resource bundle, proceed to
<b class="nc"><i>1379</i>&nbsp;     * Step 6. If a bundle has been found that is a base bundle (a bundle</b>
<b class="nc"><i>1380</i>&nbsp;     * for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained</b>
<i>1381</i>&nbsp;     * &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle
<i>1382</i>&nbsp;     * has been found that is a base bundle, but the candidate locale list
<i>1383</i>&nbsp;     * contained locales other than Locale(&quot;&quot;), put the bundle on hold and
<i>1384</i>&nbsp;     * proceed to Step 6. If a bundle has been found that is not a base
<b class="nc"><i>1385</i>&nbsp;     * bundle, proceed to Step 7.&lt;/li&gt;</b>
<b class="nc"><i>1386</i>&nbsp;     *</b>
<b class="nc"><i>1387</i>&nbsp;     * &lt;li&gt;The {@link ResourceBundle.Control#getFallbackLocale(String,</b>
<i>1388</i>&nbsp;     * Locale) control.getFallbackLocale} method is called to get a fallback
<b class="nc"><i>1389</i>&nbsp;     * locale (alternative to the current target locale) to try further</b>
<i>1390</i>&nbsp;     * finding a resource bundle. If the method returns a non-null locale,
<i>1391</i>&nbsp;     * it becomes the next target locale and the loading process starts over
<b class="nc"><i>1392</i>&nbsp;     * from Step 3. Otherwise, if a base bundle was found and put on hold in</b>
<i>1393</i>&nbsp;     * a previous Step 5, it is returned to the caller now. Otherwise, a
<i>1394</i>&nbsp;     * MissingResourceException is thrown.&lt;/li&gt;
<i>1395</i>&nbsp;     *
<i>1396</i>&nbsp;     * &lt;li&gt;At this point, we have found a resource bundle that&#39;s not the
<i>1397</i>&nbsp;     * base bundle. If this bundle set its parent during its instantiation,
<i>1398</i>&nbsp;     * it is returned to the caller. Otherwise, its &lt;a
<i>1399</i>&nbsp;     * href=&quot;./ResourceBundle.html#parent_chain&quot;&gt;parent chain&lt;/a&gt; is
<b class="nc"><i>1400</i>&nbsp;     * instantiated based on the list of candidate locales from which it was</b>
<b class="nc"><i>1401</i>&nbsp;     * found. Finally, the bundle is returned to the caller.&lt;/li&gt;</b>
<b class="nc"><i>1402</i>&nbsp;     * &lt;/ol&gt;</b>
<b class="nc"><i>1403</i>&nbsp;     *</b>
<b class="nc"><i>1404</i>&nbsp;     * &lt;p&gt;During the resource bundle loading process above, this factory</b>
<i>1405</i>&nbsp;     * method looks up the cache before calling the {@link
<i>1406</i>&nbsp;     * Control#newBundle(String, Locale, String, ClassLoader, boolean)
<b class="nc"><i>1407</i>&nbsp;     * control.newBundle} method.  If the time-to-live period of the</b>
<i>1408</i>&nbsp;     * resource bundle found in the cache has expired, the factory method
<i>1409</i>&nbsp;     * calls the {@link ResourceBundle.Control#needsReload(String, Locale,
<i>1410</i>&nbsp;     * String, ClassLoader, ResourceBundle, long) control.needsReload}
<i>1411</i>&nbsp;     * method to determine whether the resource bundle needs to be reloaded.
<i>1412</i>&nbsp;     * If reloading is required, the factory method calls
<i>1413</i>&nbsp;     * &lt;code&gt;control.newBundle&lt;/code&gt; to reload the resource bundle.  If
<i>1414</i>&nbsp;     * &lt;code&gt;control.newBundle&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the factory
<i>1415</i>&nbsp;     * method puts a dummy resource bundle in the cache as a mark of
<b class="nc"><i>1416</i>&nbsp;     * nonexistent resource bundles in order to avoid lookup overhead for</b>
<b class="nc"><i>1417</i>&nbsp;     * subsequent requests. Such dummy resource bundles are under the same</b>
<b class="nc"><i>1418</i>&nbsp;     * expiration control as specified by &lt;code&gt;control&lt;/code&gt;.</b>
<b class="nc"><i>1419</i>&nbsp;     *</b>
<i>1420</i>&nbsp;     * &lt;p&gt;All resource bundles loaded are cached by default. Refer to
<b class="nc"><i>1421</i>&nbsp;     * {@link Control#getTimeToLive(String,Locale)</b>
<b class="nc"><i>1422</i>&nbsp;     * control.getTimeToLive} for details.</b>
<i>1423</i>&nbsp;     *
<i>1424</i>&nbsp;     * &lt;p&gt;The following is an example of the bundle loading process with the
<i>1425</i>&nbsp;     * default &lt;code&gt;ResourceBundle.Control&lt;/code&gt; implementation.
<i>1426</i>&nbsp;     *
<i>1427</i>&nbsp;     * &lt;p&gt;Conditions:
<i>1428</i>&nbsp;     * &lt;ul&gt;
<i>1429</i>&nbsp;     * &lt;li&gt;Base bundle name: &lt;code&gt;foo.bar.Messages&lt;/code&gt;
<b class="nc"><i>1430</i>&nbsp;     * &lt;li&gt;Requested &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#ITALY}&lt;/li&gt;</b>
<b class="nc"><i>1431</i>&nbsp;     * &lt;li&gt;Default &lt;code&gt;Locale&lt;/code&gt;: {@link Locale#FRENCH}&lt;/li&gt;</b>
<i>1432</i>&nbsp;     * &lt;li&gt;Available resource bundles:
<i>1433</i>&nbsp;     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and
<i>1434</i>&nbsp;     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
<b class="nc"><i>1435</i>&nbsp;     * &lt;/ul&gt;</b>
<i>1436</i>&nbsp;     *
<i>1437</i>&nbsp;     * &lt;p&gt;First, &lt;code&gt;getBundle&lt;/code&gt; tries loading a resource bundle in
<i>1438</i>&nbsp;     * the following sequence.
<b class="nc"><i>1439</i>&nbsp;     *</b>
<b class="nc"><i>1440</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>1441</i>&nbsp;     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it_IT&lt;/code&gt;</b>
<b class="nc"><i>1442</i>&nbsp;     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it_IT.properties&lt;/code&gt;</b>
<b class="nc"><i>1443</i>&nbsp;     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_it&lt;/code&gt;&lt;/li&gt;</b>
<i>1444</i>&nbsp;     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_it.properties&lt;/code&gt;&lt;/li&gt;
<i>1445</i>&nbsp;     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
<i>1446</i>&nbsp;     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;
<i>1447</i>&nbsp;     * &lt;/ul&gt;
<i>1448</i>&nbsp;     *
<b class="nc"><i>1449</i>&nbsp;     * &lt;p&gt;At this point, &lt;code&gt;getBundle&lt;/code&gt; finds</b>
<b class="nc"><i>1450</i>&nbsp;     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;, which is put on hold</b>
<i>1451</i>&nbsp;     * because it&#39;s the base bundle.  &lt;code&gt;getBundle&lt;/code&gt; calls {@link
<i>1452</i>&nbsp;     * Control#getFallbackLocale(String, Locale)
<i>1453</i>&nbsp;     * control.getFallbackLocale(&quot;foo.bar.Messages&quot;, Locale.ITALY)} which
<b class="nc"><i>1454</i>&nbsp;     * returns &lt;code&gt;Locale.FRENCH&lt;/code&gt;. Next, &lt;code&gt;getBundle&lt;/code&gt;</b>
<b class="nc"><i>1455</i>&nbsp;     * tries loading a bundle in the following sequence.</b>
<b class="nc"><i>1456</i>&nbsp;     *</b>
<i>1457</i>&nbsp;     * &lt;ul&gt;
<i>1458</i>&nbsp;     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages_fr&lt;/code&gt;&lt;/li&gt;
<i>1459</i>&nbsp;     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;&lt;/li&gt;
<i>1460</i>&nbsp;     * &lt;li&gt;class &lt;code&gt;foo.bar.Messages&lt;/code&gt;&lt;/li&gt;
<b class="nc"><i>1461</i>&nbsp;     * &lt;li&gt;file &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt;&lt;/li&gt;</b>
<b class="nc"><i>1462</i>&nbsp;     * &lt;/ul&gt;</b>
<i>1463</i>&nbsp;     *
<i>1464</i>&nbsp;     * &lt;p&gt;&lt;code&gt;getBundle&lt;/code&gt; finds
<b class="nc"><i>1465</i>&nbsp;     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt; and creates a</b>
<b class="nc"><i>1466</i>&nbsp;     * &lt;code&gt;ResourceBundle&lt;/code&gt; instance. Then, &lt;code&gt;getBundle&lt;/code&gt;</b>
<b class="nc"><i>1467</i>&nbsp;     * sets up its parent chain from the list of the candidate locales.  Only</b>
<b class="nc"><i>1468</i>&nbsp;     * &lt;code&gt;foo/bar/Messages.properties&lt;/code&gt; is found in the list and</b>
<i>1469</i>&nbsp;     * &lt;code&gt;getBundle&lt;/code&gt; creates a &lt;code&gt;ResourceBundle&lt;/code&gt; instance
<b class="nc"><i>1470</i>&nbsp;     * that becomes the parent of the instance for</b>
<b class="nc"><i>1471</i>&nbsp;     * &lt;code&gt;foo/bar/Messages_fr.properties&lt;/code&gt;.</b>
<b class="nc"><i>1472</i>&nbsp;     *</b>
<i>1473</i>&nbsp;     * @param baseName
<i>1474</i>&nbsp;     *        the base name of the resource bundle, a fully qualified
<i>1475</i>&nbsp;     *        class name
<i>1476</i>&nbsp;     * @param targetLocale
<b class="nc"><i>1477</i>&nbsp;     *        the locale for which a resource bundle is desired</b>
<i>1478</i>&nbsp;     * @param loader
<b class="nc"><i>1479</i>&nbsp;     *        the class loader from which to load the resource bundle</b>
<b class="nc"><i>1480</i>&nbsp;     * @param control</b>
<i>1481</i>&nbsp;     *        the control which gives information for the resource
<i>1482</i>&nbsp;     *        bundle loading process
<i>1483</i>&nbsp;     * @return a resource bundle for the given base name and locale
<b class="nc"><i>1484</i>&nbsp;     * @throws NullPointerException</b>
<i>1485</i>&nbsp;     *         if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;targetLocale&lt;/code&gt;,
<i>1486</i>&nbsp;     *         &lt;code&gt;loader&lt;/code&gt;, or &lt;code&gt;control&lt;/code&gt; is
<i>1487</i>&nbsp;     *         &lt;code&gt;null&lt;/code&gt;
<i>1488</i>&nbsp;     * @throws MissingResourceException
<i>1489</i>&nbsp;     *         if no resource bundle for the specified base name can be found
<i>1490</i>&nbsp;     * @throws IllegalArgumentException
<i>1491</i>&nbsp;     *         if the given &lt;code&gt;control&lt;/code&gt; doesn&#39;t perform properly
<i>1492</i>&nbsp;     *         (e.g., &lt;code&gt;control.getCandidateLocales&lt;/code&gt; returns null.)
<i>1493</i>&nbsp;     *         Note that validation of &lt;code&gt;control&lt;/code&gt; is performed as
<b class="nc"><i>1494</i>&nbsp;     *         needed.</b>
<i>1495</i>&nbsp;     * @throws UnsupportedOperationException
<b class="nc"><i>1496</i>&nbsp;     *         if this method is called in a named module</b>
<b class="nc"><i>1497</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>1498</i>&nbsp;     * @revised 9</b>
<b class="nc"><i>1499</i>&nbsp;     * @spec JPMS</b>
<i>1500</i>&nbsp;     */
<b class="nc"><i>1501</i>&nbsp;    @CallerSensitive</b>
<b class="nc"><i>1502</i>&nbsp;    public static ResourceBundle getBundle(String baseName, Locale targetLocale,</b>
<b class="nc"><i>1503</i>&nbsp;                                           ClassLoader loader, Control control) {</b>
<i>1504</i>&nbsp;        if (loader == null || control == null) {
<i>1505</i>&nbsp;            throw new NullPointerException();
<i>1506</i>&nbsp;        }
<b class="nc"><i>1507</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();</b>
<b class="nc"><i>1508</i>&nbsp;        checkNamedModule(caller);</b>
<b class="nc"><i>1509</i>&nbsp;        return getBundleImpl(baseName, targetLocale, caller, loader, control);</b>
<b class="nc"><i>1510</i>&nbsp;    }</b>
<b class="nc"><i>1511</i>&nbsp;</b>
<i>1512</i>&nbsp;    private static Control getDefaultControl(Class&lt;?&gt; caller, String baseName) {
<i>1513</i>&nbsp;        return getDefaultControl(caller.getModule(), baseName);
<b class="nc"><i>1514</i>&nbsp;    }</b>
<b class="nc"><i>1515</i>&nbsp;</b>
<b class="nc"><i>1516</i>&nbsp;    private static Control getDefaultControl(Module targetModule, String baseName) {</b>
<i>1517</i>&nbsp;        return targetModule.isNamed() ?
<i>1518</i>&nbsp;            Control.INSTANCE :
<b class="nc"><i>1519</i>&nbsp;            ResourceBundleControlProviderHolder.getControl(baseName);</b>
<b class="nc"><i>1520</i>&nbsp;    }</b>
<i>1521</i>&nbsp;
<i>1522</i>&nbsp;    private static class ResourceBundleControlProviderHolder {
<i>1523</i>&nbsp;        private static final PrivilegedAction&lt;List&lt;ResourceBundleControlProvider&gt;&gt; pa =
<b class="nc"><i>1524</i>&nbsp;            () -&gt; {</b>
<i>1525</i>&nbsp;                return Collections.unmodifiableList(
<i>1526</i>&nbsp;                    ServiceLoader.load(ResourceBundleControlProvider.class,
<i>1527</i>&nbsp;                                       ClassLoader.getSystemClassLoader()).stream()
<b class="nc"><i>1528</i>&nbsp;                        .map(ServiceLoader.Provider::get)</b>
<i>1529</i>&nbsp;                        .collect(Collectors.toList()));
<i>1530</i>&nbsp;            };
<i>1531</i>&nbsp;
<i>1532</i>&nbsp;        private static final List&lt;ResourceBundleControlProvider&gt; CONTROL_PROVIDERS =
<i>1533</i>&nbsp;            AccessController.doPrivileged(pa);
<i>1534</i>&nbsp;
<i>1535</i>&nbsp;        private static Control getControl(String baseName) {
<b class="nc"><i>1536</i>&nbsp;            return CONTROL_PROVIDERS.isEmpty() ?</b>
<b class="nc"><i>1537</i>&nbsp;                Control.INSTANCE :</b>
<b class="nc"><i>1538</i>&nbsp;                CONTROL_PROVIDERS.stream()</b>
<b class="nc"><i>1539</i>&nbsp;                    .flatMap(provider -&gt; Stream.ofNullable(provider.getControl(baseName)))</b>
<i>1540</i>&nbsp;                    .findFirst()
<b class="nc"><i>1541</i>&nbsp;                    .orElse(Control.INSTANCE);</b>
<b class="nc"><i>1542</i>&nbsp;        }</b>
<b class="nc"><i>1543</i>&nbsp;    }</b>
<b class="nc"><i>1544</i>&nbsp;</b>
<b class="nc"><i>1545</i>&nbsp;    private static void checkNamedModule(Class&lt;?&gt; caller) {</b>
<i>1546</i>&nbsp;        if (caller.getModule().isNamed()) {
<i>1547</i>&nbsp;            throw new UnsupportedOperationException(
<b class="nc"><i>1548</i>&nbsp;                    &quot;ResourceBundle.Control not supported in named modules&quot;);</b>
<b class="nc"><i>1549</i>&nbsp;        }</b>
<b class="nc"><i>1550</i>&nbsp;    }</b>
<i>1551</i>&nbsp;
<i>1552</i>&nbsp;    private static ResourceBundle getBundleImpl(String baseName,
<i>1553</i>&nbsp;                                                Locale locale,
<i>1554</i>&nbsp;                                                Class&lt;?&gt; caller,
<i>1555</i>&nbsp;                                                Control control) {
<i>1556</i>&nbsp;        return getBundleImpl(baseName, locale, caller, caller.getClassLoader(), control);
<i>1557</i>&nbsp;    }
<i>1558</i>&nbsp;
<i>1559</i>&nbsp;    /**
<i>1560</i>&nbsp;     * This method will find resource bundles using the legacy mechanism
<b class="nc"><i>1561</i>&nbsp;     * if the caller is unnamed module or the given class loader is</b>
<b class="nc"><i>1562</i>&nbsp;     * not the class loader of the caller module getting the resource</b>
<i>1563</i>&nbsp;     * bundle, i.e. find the class that is visible to the class loader
<b class="nc"><i>1564</i>&nbsp;     * and properties from unnamed module.</b>
<i>1565</i>&nbsp;     *
<i>1566</i>&nbsp;     * The module-aware resource bundle lookup mechanism will load
<i>1567</i>&nbsp;     * the service providers using the service loader mechanism
<i>1568</i>&nbsp;     * as well as properties local in the caller module.
<i>1569</i>&nbsp;     */
<i>1570</i>&nbsp;    private static ResourceBundle getBundleImpl(String baseName,
<i>1571</i>&nbsp;                                                Locale locale,
<i>1572</i>&nbsp;                                                Class&lt;?&gt; caller,
<i>1573</i>&nbsp;                                                ClassLoader loader,
<i>1574</i>&nbsp;                                                Control control) {
<i>1575</i>&nbsp;        if (caller == null) {
<i>1576</i>&nbsp;            throw new InternalError(&quot;null caller&quot;);
<i>1577</i>&nbsp;        }
<i>1578</i>&nbsp;        Module callerModule = caller.getModule();
<i>1579</i>&nbsp;
<i>1580</i>&nbsp;        // get resource bundles for a named module only if loader is the module&#39;s class loader
<i>1581</i>&nbsp;        if (callerModule.isNamed() &amp;&amp; loader == getLoader(callerModule)) {
<i>1582</i>&nbsp;            return getBundleImpl(callerModule, callerModule, baseName, locale, control);
<b class="nc"><i>1583</i>&nbsp;        }</b>
<b class="nc"><i>1584</i>&nbsp;</b>
<b class="nc"><i>1585</i>&nbsp;        // find resource bundles from unnamed module of given class loader</b>
<i>1586</i>&nbsp;        // Java agent can add to the bootclasspath e.g. via
<b class="nc"><i>1587</i>&nbsp;        // java.lang.instrument.Instrumentation and load classes in unnamed module.</b>
<b class="nc"><i>1588</i>&nbsp;        // It may call RB::getBundle that will end up here with loader == null.</b>
<b class="nc"><i>1589</i>&nbsp;        Module unnamedModule = loader != null</b>
<i>1590</i>&nbsp;            ? loader.getUnnamedModule()
<b class="nc"><i>1591</i>&nbsp;            : BootLoader.getUnnamedModule();</b>
<b class="nc"><i>1592</i>&nbsp;</b>
<i>1593</i>&nbsp;        return getBundleImpl(callerModule, unnamedModule, baseName, locale, control);
<i>1594</i>&nbsp;    }
<i>1595</i>&nbsp;
<i>1596</i>&nbsp;    private static ResourceBundle getBundleFromModule(Class&lt;?&gt; caller,
<i>1597</i>&nbsp;                                                      Module module,
<i>1598</i>&nbsp;                                                      String baseName,
<i>1599</i>&nbsp;                                                      Locale locale,
<i>1600</i>&nbsp;                                                      Control control) {
<i>1601</i>&nbsp;        Objects.requireNonNull(module);
<i>1602</i>&nbsp;        Module callerModule = caller.getModule();
<i>1603</i>&nbsp;        if (callerModule != module) {
<i>1604</i>&nbsp;            SecurityManager sm = System.getSecurityManager();
<i>1605</i>&nbsp;            if (sm != null) {
<i>1606</i>&nbsp;                sm.checkPermission(GET_CLASSLOADER_PERMISSION);
<i>1607</i>&nbsp;            }
<i>1608</i>&nbsp;        }
<i>1609</i>&nbsp;        return getBundleImpl(callerModule, module, baseName, locale, control);
<i>1610</i>&nbsp;    }
<i>1611</i>&nbsp;
<i>1612</i>&nbsp;    private static ResourceBundle getBundleImpl(Module callerModule,
<i>1613</i>&nbsp;                                                Module module,
<i>1614</i>&nbsp;                                                String baseName,
<i>1615</i>&nbsp;                                                Locale locale,
<i>1616</i>&nbsp;                                                Control control) {
<i>1617</i>&nbsp;        if (locale == null || control == null) {
<i>1618</i>&nbsp;            throw new NullPointerException();
<i>1619</i>&nbsp;        }
<i>1620</i>&nbsp;
<i>1621</i>&nbsp;        // We create a CacheKey here for use by this call. The base name
<i>1622</i>&nbsp;        // and modules will never change during the bundle loading
<i>1623</i>&nbsp;        // process. We have to make sure that the locale is set before
<i>1624</i>&nbsp;        // using it as a cache key.
<i>1625</i>&nbsp;        CacheKey cacheKey = new CacheKey(baseName, locale, module, callerModule);
<b class="nc"><i>1626</i>&nbsp;        ResourceBundle bundle = null;</b>
<b class="nc"><i>1627</i>&nbsp;</b>
<b class="nc"><i>1628</i>&nbsp;        // Quick lookup of the cache.</b>
<b class="nc"><i>1629</i>&nbsp;        BundleReference bundleRef = cacheList.get(cacheKey);</b>
<b class="nc"><i>1630</i>&nbsp;        if (bundleRef != null) {</b>
<b class="nc"><i>1631</i>&nbsp;            bundle = bundleRef.get();</b>
<i>1632</i>&nbsp;            bundleRef = null;
<b class="nc"><i>1633</i>&nbsp;        }</b>
<b class="nc"><i>1634</i>&nbsp;</b>
<b class="nc"><i>1635</i>&nbsp;        // If this bundle and all of its parents are valid (not expired),</b>
<b class="nc"><i>1636</i>&nbsp;        // then return this bundle. If any of the bundles is expired, we</b>
<i>1637</i>&nbsp;        // don&#39;t call control.needsReload here but instead drop into the
<b class="nc"><i>1638</i>&nbsp;        // complete loading process below.</b>
<i>1639</i>&nbsp;        if (isValidBundle(bundle) &amp;&amp; hasValidParentChain(bundle)) {
<i>1640</i>&nbsp;            return bundle;
<b class="nc"><i>1641</i>&nbsp;        }</b>
<b class="nc"><i>1642</i>&nbsp;</b>
<b class="nc"><i>1643</i>&nbsp;        // No valid bundle was found in the cache, so we need to load the</b>
<b class="nc"><i>1644</i>&nbsp;        // resource bundle and its parents.</b>
<i>1645</i>&nbsp;
<b class="nc"><i>1646</i>&nbsp;        boolean isKnownControl = (control == Control.INSTANCE) ||</b>
<b class="nc"><i>1647</i>&nbsp;                                   (control instanceof SingleFormatControl);</b>
<b class="nc"><i>1648</i>&nbsp;        List&lt;String&gt; formats = control.getFormats(baseName);</b>
<b class="nc"><i>1649</i>&nbsp;        if (!isKnownControl &amp;&amp; !checkList(formats)) {</b>
<i>1650</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid Control: getFormats&quot;);
<b class="nc"><i>1651</i>&nbsp;        }</b>
<b class="nc"><i>1652</i>&nbsp;</b>
<b class="nc"><i>1653</i>&nbsp;        ResourceBundle baseBundle = null;</b>
<b class="nc"><i>1654</i>&nbsp;        for (Locale targetLocale = locale;</b>
<b class="nc"><i>1655</i>&nbsp;             targetLocale != null;</b>
<i>1656</i>&nbsp;             targetLocale = control.getFallbackLocale(baseName, targetLocale)) {
<i>1657</i>&nbsp;            List&lt;Locale&gt; candidateLocales = control.getCandidateLocales(baseName, targetLocale);
<i>1658</i>&nbsp;            if (!isKnownControl &amp;&amp; !checkList(candidateLocales)) {
<i>1659</i>&nbsp;                throw new IllegalArgumentException(&quot;Invalid Control: getCandidateLocales&quot;);
<b class="nc"><i>1660</i>&nbsp;            }</b>
<b class="nc"><i>1661</i>&nbsp;</b>
<i>1662</i>&nbsp;            bundle = findBundle(callerModule, module, cacheKey,
<i>1663</i>&nbsp;                                candidateLocales, formats, 0, control, baseBundle);
<i>1664</i>&nbsp;
<b class="nc"><i>1665</i>&nbsp;            // If the loaded bundle is the base bundle and exactly for the</b>
<i>1666</i>&nbsp;            // requested locale or the only candidate locale, then take the
<i>1667</i>&nbsp;            // bundle as the resulting one. If the loaded bundle is the base
<b class="nc"><i>1668</i>&nbsp;            // bundle, it&#39;s put on hold until we finish processing all</b>
<i>1669</i>&nbsp;            // fallback locales.
<i>1670</i>&nbsp;            if (isValidBundle(bundle)) {
<b class="nc"><i>1671</i>&nbsp;                boolean isBaseBundle = Locale.ROOT.equals(bundle.locale);</b>
<b class="nc"><i>1672</i>&nbsp;                if (!isBaseBundle || bundle.locale.equals(locale)</b>
<i>1673</i>&nbsp;                    || (candidateLocales.size() == 1
<i>1674</i>&nbsp;                        &amp;&amp; bundle.locale.equals(candidateLocales.get(0)))) {
<i>1675</i>&nbsp;                    break;
<b class="nc"><i>1676</i>&nbsp;                }</b>
<i>1677</i>&nbsp;
<i>1678</i>&nbsp;                // If the base bundle has been loaded, keep the reference in
<i>1679</i>&nbsp;                // baseBundle so that we can avoid any redundant loading in case
<i>1680</i>&nbsp;                // the control specify not to cache bundles.
<i>1681</i>&nbsp;                if (isBaseBundle &amp;&amp; baseBundle == null) {
<i>1682</i>&nbsp;                    baseBundle = bundle;
<i>1683</i>&nbsp;                }
<i>1684</i>&nbsp;            }
<i>1685</i>&nbsp;        }
<i>1686</i>&nbsp;
<i>1687</i>&nbsp;        if (bundle == null) {
<i>1688</i>&nbsp;            if (baseBundle == null) {
<i>1689</i>&nbsp;                throwMissingResourceException(baseName, locale, cacheKey.getCause());
<i>1690</i>&nbsp;            }
<b class="nc"><i>1691</i>&nbsp;            bundle = baseBundle;</b>
<b class="nc"><i>1692</i>&nbsp;        }</b>
<b class="nc"><i>1693</i>&nbsp;</b>
<b class="nc"><i>1694</i>&nbsp;        // keep callerModule and module reachable for as long as we are operating</b>
<b class="nc"><i>1695</i>&nbsp;        // with WeakReference(s) to them (in CacheKey)...</b>
<i>1696</i>&nbsp;        Reference.reachabilityFence(callerModule);
<i>1697</i>&nbsp;        Reference.reachabilityFence(module);
<b class="nc"><i>1698</i>&nbsp;</b>
<i>1699</i>&nbsp;        return bundle;
<i>1700</i>&nbsp;    }
<i>1701</i>&nbsp;
<b class="nc"><i>1702</i>&nbsp;    /**</b>
<b class="nc"><i>1703</i>&nbsp;     * Checks if the given &lt;code&gt;List&lt;/code&gt; is not null, not empty,</b>
<b class="nc"><i>1704</i>&nbsp;     * not having null in its elements.</b>
<i>1705</i>&nbsp;     */
<b class="nc"><i>1706</i>&nbsp;    private static boolean checkList(List&lt;?&gt; a) {</b>
<b class="nc"><i>1707</i>&nbsp;        boolean valid = (a != null &amp;&amp; !a.isEmpty());</b>
<i>1708</i>&nbsp;        if (valid) {
<i>1709</i>&nbsp;            int size = a.size();
<b class="nc"><i>1710</i>&nbsp;            for (int i = 0; valid &amp;&amp; i &lt; size; i++) {</b>
<i>1711</i>&nbsp;                valid = (a.get(i) != null);
<i>1712</i>&nbsp;            }
<i>1713</i>&nbsp;        }
<b class="nc"><i>1714</i>&nbsp;        return valid;</b>
<i>1715</i>&nbsp;    }
<i>1716</i>&nbsp;
<i>1717</i>&nbsp;    private static ResourceBundle findBundle(Module callerModule,
<b class="nc"><i>1718</i>&nbsp;                                             Module module,</b>
<i>1719</i>&nbsp;                                             CacheKey cacheKey,
<i>1720</i>&nbsp;                                             List&lt;Locale&gt; candidateLocales,
<i>1721</i>&nbsp;                                             List&lt;String&gt; formats,
<b class="nc"><i>1722</i>&nbsp;                                             int index,</b>
<b class="nc"><i>1723</i>&nbsp;                                             Control control,</b>
<b class="nc"><i>1724</i>&nbsp;                                             ResourceBundle baseBundle) {</b>
<i>1725</i>&nbsp;        Locale targetLocale = candidateLocales.get(index);
<i>1726</i>&nbsp;        ResourceBundle parent = null;
<b class="nc"><i>1727</i>&nbsp;        if (index != candidateLocales.size() - 1) {</b>
<b class="nc"><i>1728</i>&nbsp;            parent = findBundle(callerModule, module, cacheKey,</b>
<b class="nc"><i>1729</i>&nbsp;                                candidateLocales, formats, index + 1,</b>
<b class="nc"><i>1730</i>&nbsp;                                control, baseBundle);</b>
<b class="nc"><i>1731</i>&nbsp;        } else if (baseBundle != null &amp;&amp; Locale.ROOT.equals(targetLocale)) {</b>
<i>1732</i>&nbsp;            return baseBundle;
<b class="nc"><i>1733</i>&nbsp;        }</b>
<i>1734</i>&nbsp;
<i>1735</i>&nbsp;        // Before we do the real loading work, see whether we need to
<i>1736</i>&nbsp;        // do some housekeeping: If references to modules or
<i>1737</i>&nbsp;        // resource bundles have been nulled out, remove all related
<i>1738</i>&nbsp;        // information from the cache.
<i>1739</i>&nbsp;        Object ref;
<i>1740</i>&nbsp;        while ((ref = referenceQueue.poll()) != null) {
<i>1741</i>&nbsp;            cacheList.remove(((CacheKeyReference)ref).getCacheKey());
<i>1742</i>&nbsp;        }
<i>1743</i>&nbsp;
<i>1744</i>&nbsp;        // flag indicating the resource bundle has expired in the cache
<i>1745</i>&nbsp;        boolean expiredBundle = false;
<b class="nc"><i>1746</i>&nbsp;</b>
<i>1747</i>&nbsp;        // First, look up the cache to see if it&#39;s in the cache, without
<i>1748</i>&nbsp;        // attempting to load bundle.
<i>1749</i>&nbsp;        cacheKey.setLocale(targetLocale);
<i>1750</i>&nbsp;        ResourceBundle bundle = findBundleInCache(cacheKey, control);
<i>1751</i>&nbsp;        if (isValidBundle(bundle)) {
<i>1752</i>&nbsp;            expiredBundle = bundle.expired;
<i>1753</i>&nbsp;            if (!expiredBundle) {
<i>1754</i>&nbsp;                // If its parent is the one asked for by the candidate
<i>1755</i>&nbsp;                // locales (the runtime lookup path), we can take the cached
<i>1756</i>&nbsp;                // one. (If it&#39;s not identical, then we&#39;d have to check the
<i>1757</i>&nbsp;                // parent&#39;s parents to be consistent with what&#39;s been
<i>1758</i>&nbsp;                // requested.)
<b class="nc"><i>1759</i>&nbsp;                if (bundle.parent == parent) {</b>
<b class="nc"><i>1760</i>&nbsp;                    return bundle;</b>
<i>1761</i>&nbsp;                }
<b class="nc"><i>1762</i>&nbsp;                // Otherwise, remove the cached one since we can&#39;t keep</b>
<b class="nc"><i>1763</i>&nbsp;                // the same bundles having different parents.</b>
<b class="nc"><i>1764</i>&nbsp;                BundleReference bundleRef = cacheList.get(cacheKey);</b>
<b class="nc"><i>1765</i>&nbsp;                if (bundleRef != null &amp;&amp; bundleRef.get() == bundle) {</b>
<i>1766</i>&nbsp;                    cacheList.remove(cacheKey, bundleRef);
<b class="nc"><i>1767</i>&nbsp;                }</b>
<i>1768</i>&nbsp;            }
<i>1769</i>&nbsp;        }
<i>1770</i>&nbsp;
<i>1771</i>&nbsp;        if (bundle != NONEXISTENT_BUNDLE) {
<i>1772</i>&nbsp;            trace(&quot;findBundle: %d %s %s formats: %s%n&quot;, index, candidateLocales, cacheKey, formats);
<i>1773</i>&nbsp;            if (module.isNamed()) {
<i>1774</i>&nbsp;                bundle = loadBundle(cacheKey, formats, control, module, callerModule);
<i>1775</i>&nbsp;            } else {
<i>1776</i>&nbsp;                bundle = loadBundle(cacheKey, formats, control, expiredBundle);
<i>1777</i>&nbsp;            }
<i>1778</i>&nbsp;            if (bundle != null) {
<i>1779</i>&nbsp;                if (bundle.parent == null) {
<i>1780</i>&nbsp;                    bundle.setParent(parent);
<i>1781</i>&nbsp;                }
<i>1782</i>&nbsp;                bundle.locale = targetLocale;
<i>1783</i>&nbsp;                bundle = putBundleInCache(cacheKey, bundle, control);
<i>1784</i>&nbsp;                return bundle;
<i>1785</i>&nbsp;            }
<i>1786</i>&nbsp;
<i>1787</i>&nbsp;            // Put NONEXISTENT_BUNDLE in the cache as a mark that there&#39;s no bundle
<i>1788</i>&nbsp;            // instance for the locale.
<i>1789</i>&nbsp;            putBundleInCache(cacheKey, NONEXISTENT_BUNDLE, control);
<i>1790</i>&nbsp;        }
<i>1791</i>&nbsp;        return parent;
<i>1792</i>&nbsp;    }
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;    private static final String UNKNOWN_FORMAT = &quot;&quot;;
<i>1795</i>&nbsp;
<i>1796</i>&nbsp;
<i>1797</i>&nbsp;    /*
<i>1798</i>&nbsp;     * Loads a ResourceBundle in named modules
<i>1799</i>&nbsp;     */
<i>1800</i>&nbsp;    private static ResourceBundle loadBundle(CacheKey cacheKey,
<i>1801</i>&nbsp;                                             List&lt;String&gt; formats,
<i>1802</i>&nbsp;                                             Control control,
<b class="nc"><i>1803</i>&nbsp;                                             Module module,</b>
<b class="nc"><i>1804</i>&nbsp;                                             Module callerModule) {</b>
<i>1805</i>&nbsp;        String baseName = cacheKey.getName();
<b class="nc"><i>1806</i>&nbsp;        Locale targetLocale = cacheKey.getLocale();</b>
<b class="nc"><i>1807</i>&nbsp;</b>
<b class="nc"><i>1808</i>&nbsp;        ResourceBundle bundle = null;</b>
<i>1809</i>&nbsp;        if (cacheKey.hasProviders()) {
<i>1810</i>&nbsp;            if (callerModule == module) {
<b class="nc"><i>1811</i>&nbsp;                bundle = loadBundleFromProviders(baseName,</b>
<i>1812</i>&nbsp;                                                 targetLocale,
<i>1813</i>&nbsp;                                                 cacheKey.getProviders(),
<i>1814</i>&nbsp;                                                 cacheKey);
<i>1815</i>&nbsp;            } else {
<i>1816</i>&nbsp;                // load from provider if the caller module has access to the
<i>1817</i>&nbsp;                // service type and also declares `uses`
<i>1818</i>&nbsp;                ClassLoader loader = getLoader(module);
<i>1819</i>&nbsp;                Class&lt;ResourceBundleProvider&gt; svc =
<i>1820</i>&nbsp;                    getResourceBundleProviderType(baseName, loader);
<i>1821</i>&nbsp;                if (svc != null
<i>1822</i>&nbsp;                        &amp;&amp; Reflection.verifyModuleAccess(callerModule, svc)
<b class="nc"><i>1823</i>&nbsp;                        &amp;&amp; callerModule.canUse(svc)) {</b>
<b class="nc"><i>1824</i>&nbsp;                    bundle = loadBundleFromProviders(baseName,</b>
<b class="nc"><i>1825</i>&nbsp;                                                     targetLocale,</b>
<i>1826</i>&nbsp;                                                     cacheKey.getProviders(),
<b class="nc"><i>1827</i>&nbsp;                                                     cacheKey);</b>
<i>1828</i>&nbsp;                }
<i>1829</i>&nbsp;            }
<i>1830</i>&nbsp;
<i>1831</i>&nbsp;            if (bundle != null) {
<i>1832</i>&nbsp;                cacheKey.setFormat(UNKNOWN_FORMAT);
<i>1833</i>&nbsp;            }
<i>1834</i>&nbsp;        }
<i>1835</i>&nbsp;
<i>1836</i>&nbsp;        // If none of providers returned a bundle and the caller has no provider,
<i>1837</i>&nbsp;        // look up module-local bundles or from the class path
<i>1838</i>&nbsp;        if (bundle == null &amp;&amp; !cacheKey.callerHasProvider()) {
<i>1839</i>&nbsp;            for (String format : formats) {
<i>1840</i>&nbsp;                try {
<i>1841</i>&nbsp;                    switch (format) {
<i>1842</i>&nbsp;                    case &quot;java.class&quot;:
<i>1843</i>&nbsp;                        bundle = ResourceBundleProviderHelper
<i>1844</i>&nbsp;                            .loadResourceBundle(callerModule, module, baseName, targetLocale);
<i>1845</i>&nbsp;
<i>1846</i>&nbsp;                        break;
<i>1847</i>&nbsp;                    case &quot;java.properties&quot;:
<b class="nc"><i>1848</i>&nbsp;                        bundle = ResourceBundleProviderHelper</b>
<b class="nc"><i>1849</i>&nbsp;                            .loadPropertyResourceBundle(callerModule, module, baseName, targetLocale);</b>
<b class="nc"><i>1850</i>&nbsp;                        break;</b>
<b class="nc"><i>1851</i>&nbsp;                    default:</b>
<b class="nc"><i>1852</i>&nbsp;                        throw new InternalError(&quot;unexpected format: &quot; + format);</b>
<b class="nc"><i>1853</i>&nbsp;                    }</b>
<b class="nc"><i>1854</i>&nbsp;</b>
<b class="nc"><i>1855</i>&nbsp;                    if (bundle != null) {</b>
<b class="nc"><i>1856</i>&nbsp;                        cacheKey.setFormat(format);</b>
<i>1857</i>&nbsp;                        break;
<b class="nc"><i>1858</i>&nbsp;                    }</b>
<b class="nc"><i>1859</i>&nbsp;                } catch (LinkageError|Exception e) {</b>
<i>1860</i>&nbsp;                    cacheKey.setCause(e);
<b class="nc"><i>1861</i>&nbsp;                }</b>
<i>1862</i>&nbsp;            }
<b class="nc"><i>1863</i>&nbsp;        }</b>
<i>1864</i>&nbsp;        return bundle;
<i>1865</i>&nbsp;    }
<i>1866</i>&nbsp;
<i>1867</i>&nbsp;    /**
<i>1868</i>&nbsp;     * Returns a ServiceLoader that will find providers that are bound to
<i>1869</i>&nbsp;     * a given named module.
<i>1870</i>&nbsp;     */
<i>1871</i>&nbsp;    private static ServiceLoader&lt;ResourceBundleProvider&gt; getServiceLoader(Module module,
<i>1872</i>&nbsp;                                                                          String baseName)
<i>1873</i>&nbsp;    {
<i>1874</i>&nbsp;        if (!module.isNamed()) {
<i>1875</i>&nbsp;            return null;
<i>1876</i>&nbsp;        }
<i>1877</i>&nbsp;
<i>1878</i>&nbsp;        ClassLoader loader = getLoader(module);
<i>1879</i>&nbsp;        Class&lt;ResourceBundleProvider&gt; service =
<i>1880</i>&nbsp;                getResourceBundleProviderType(baseName, loader);
<i>1881</i>&nbsp;        if (service != null &amp;&amp; Reflection.verifyModuleAccess(module, service)) {
<i>1882</i>&nbsp;            try {
<i>1883</i>&nbsp;                // locate providers that are visible to the class loader
<i>1884</i>&nbsp;                // ServiceConfigurationError will be thrown if the module
<i>1885</i>&nbsp;                // does not declare `uses` the service type
<i>1886</i>&nbsp;                return ServiceLoader.load(service, loader, module);
<i>1887</i>&nbsp;            } catch (ServiceConfigurationError e) {
<i>1888</i>&nbsp;                // &quot;uses&quot; not declared
<i>1889</i>&nbsp;                return null;
<i>1890</i>&nbsp;            }
<i>1891</i>&nbsp;        }
<i>1892</i>&nbsp;        return null;
<i>1893</i>&nbsp;    }
<i>1894</i>&nbsp;
<i>1895</i>&nbsp;    /**
<i>1896</i>&nbsp;     * Returns the service type of the given baseName that is visible
<i>1897</i>&nbsp;     * to the given class loader
<i>1898</i>&nbsp;     */
<i>1899</i>&nbsp;    private static Class&lt;ResourceBundleProvider&gt;
<i>1900</i>&nbsp;            getResourceBundleProviderType(String baseName, ClassLoader loader)
<i>1901</i>&nbsp;    {
<i>1902</i>&nbsp;        // Look up &lt;packagename&gt; + &quot;.spi.&quot; + &lt;name&gt;&quot;Provider&quot;
<i>1903</i>&nbsp;        int i = baseName.lastIndexOf(&#39;.&#39;);
<i>1904</i>&nbsp;        if (i &lt;= 0) {
<i>1905</i>&nbsp;            return null;
<i>1906</i>&nbsp;        }
<i>1907</i>&nbsp;
<i>1908</i>&nbsp;        String name = baseName.substring(i+1, baseName.length()) + &quot;Provider&quot;;
<i>1909</i>&nbsp;        String providerName = baseName.substring(0, i) + &quot;.spi.&quot; + name;
<i>1910</i>&nbsp;
<i>1911</i>&nbsp;        // Use the class loader of the getBundle caller so that the caller&#39;s
<i>1912</i>&nbsp;        // visibility of the provider type is checked.
<i>1913</i>&nbsp;        return AccessController.doPrivileged(
<i>1914</i>&nbsp;            new PrivilegedAction&lt;&gt;() {
<i>1915</i>&nbsp;                @Override
<i>1916</i>&nbsp;                public Class&lt;ResourceBundleProvider&gt; run() {
<i>1917</i>&nbsp;                    try {
<i>1918</i>&nbsp;                        Class&lt;?&gt; c = Class.forName(providerName, false, loader);
<i>1919</i>&nbsp;                        if (ResourceBundleProvider.class.isAssignableFrom(c)) {
<i>1920</i>&nbsp;                            @SuppressWarnings(&quot;unchecked&quot;)
<i>1921</i>&nbsp;                            Class&lt;ResourceBundleProvider&gt; s = (Class&lt;ResourceBundleProvider&gt;) c;
<i>1922</i>&nbsp;                            return s;
<i>1923</i>&nbsp;                        }
<i>1924</i>&nbsp;                    } catch (ClassNotFoundException e) {}
<i>1925</i>&nbsp;                    return null;
<i>1926</i>&nbsp;                }
<i>1927</i>&nbsp;            });
<i>1928</i>&nbsp;    }
<i>1929</i>&nbsp;
<i>1930</i>&nbsp;    /**
<i>1931</i>&nbsp;     * Loads ResourceBundle from service providers.
<i>1932</i>&nbsp;     */
<i>1933</i>&nbsp;    private static ResourceBundle loadBundleFromProviders(String baseName,
<i>1934</i>&nbsp;                                                          Locale locale,
<i>1935</i>&nbsp;                                                          ServiceLoader&lt;ResourceBundleProvider&gt; providers,
<i>1936</i>&nbsp;                                                          CacheKey cacheKey)
<i>1937</i>&nbsp;    {
<i>1938</i>&nbsp;        if (providers == null) return null;
<i>1939</i>&nbsp;
<i>1940</i>&nbsp;        return AccessController.doPrivileged(
<i>1941</i>&nbsp;                new PrivilegedAction&lt;&gt;() {
<i>1942</i>&nbsp;                    public ResourceBundle run() {
<i>1943</i>&nbsp;                        for (Iterator&lt;ResourceBundleProvider&gt; itr = providers.iterator(); itr.hasNext(); ) {
<i>1944</i>&nbsp;                            try {
<i>1945</i>&nbsp;                                ResourceBundleProvider provider = itr.next();
<i>1946</i>&nbsp;                                if (cacheKey != null &amp;&amp; cacheKey.callerHasProvider == null
<i>1947</i>&nbsp;                                        &amp;&amp; cacheKey.getModule() == provider.getClass().getModule()) {
<i>1948</i>&nbsp;                                    cacheKey.callerHasProvider = Boolean.TRUE;
<i>1949</i>&nbsp;                                }
<i>1950</i>&nbsp;                                ResourceBundle bundle = provider.getBundle(baseName, locale);
<i>1951</i>&nbsp;                                trace(&quot;provider %s %s locale: %s bundle: %s%n&quot;, provider, baseName, locale, bundle);
<i>1952</i>&nbsp;                                if (bundle != null) {
<i>1953</i>&nbsp;                                    return bundle;
<i>1954</i>&nbsp;                                }
<i>1955</i>&nbsp;                            } catch (ServiceConfigurationError | SecurityException e) {
<i>1956</i>&nbsp;                                if (cacheKey != null) {
<i>1957</i>&nbsp;                                    cacheKey.setCause(e);
<i>1958</i>&nbsp;                                }
<i>1959</i>&nbsp;                            }
<i>1960</i>&nbsp;                        }
<i>1961</i>&nbsp;                        if (cacheKey != null &amp;&amp; cacheKey.callerHasProvider == null) {
<i>1962</i>&nbsp;                            cacheKey.callerHasProvider = Boolean.FALSE;
<i>1963</i>&nbsp;                        }
<i>1964</i>&nbsp;                        return null;
<i>1965</i>&nbsp;                    }
<i>1966</i>&nbsp;                });
<i>1967</i>&nbsp;
<i>1968</i>&nbsp;    }
<i>1969</i>&nbsp;
<i>1970</i>&nbsp;    /*
<i>1971</i>&nbsp;     * Legacy mechanism to load resource bundles
<i>1972</i>&nbsp;     */
<i>1973</i>&nbsp;    private static ResourceBundle loadBundle(CacheKey cacheKey,
<i>1974</i>&nbsp;                                             List&lt;String&gt; formats,
<i>1975</i>&nbsp;                                             Control control,
<i>1976</i>&nbsp;                                             boolean reload) {
<i>1977</i>&nbsp;
<i>1978</i>&nbsp;        // Here we actually load the bundle in the order of formats
<i>1979</i>&nbsp;        // specified by the getFormats() value.
<i>1980</i>&nbsp;        Locale targetLocale = cacheKey.getLocale();
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;        Module module = cacheKey.getModule();
<i>1983</i>&nbsp;        if (module == null) {
<i>1984</i>&nbsp;            // should not happen
<i>1985</i>&nbsp;            throw new InternalError(
<i>1986</i>&nbsp;                &quot;Module for cache key: &quot; + cacheKey + &quot; has been GCed.&quot;);
<i>1987</i>&nbsp;        }
<i>1988</i>&nbsp;        ClassLoader loader = getLoaderForControl(module);
<i>1989</i>&nbsp;
<i>1990</i>&nbsp;        ResourceBundle bundle = null;
<i>1991</i>&nbsp;        for (String format : formats) {
<i>1992</i>&nbsp;            try {
<i>1993</i>&nbsp;                // ResourceBundle.Control.newBundle may be overridden
<i>1994</i>&nbsp;                bundle = control.newBundle(cacheKey.getName(), targetLocale, format,
<i>1995</i>&nbsp;                                           loader, reload);
<i>1996</i>&nbsp;            } catch (LinkageError | Exception error) {
<i>1997</i>&nbsp;                // We need to handle the LinkageError case due to
<i>1998</i>&nbsp;                // inconsistent case-sensitivity in ClassLoader.
<i>1999</i>&nbsp;                // See 6572242 for details.
<i>2000</i>&nbsp;                cacheKey.setCause(error);
<i>2001</i>&nbsp;            }
<i>2002</i>&nbsp;            if (bundle != null) {
<i>2003</i>&nbsp;                // Set the format in the cache key so that it can be
<i>2004</i>&nbsp;                // used when calling needsReload later.
<i>2005</i>&nbsp;                cacheKey.setFormat(format);
<i>2006</i>&nbsp;                bundle.name = cacheKey.getName();
<i>2007</i>&nbsp;                bundle.locale = targetLocale;
<i>2008</i>&nbsp;                // Bundle provider might reuse instances. So we should make
<i>2009</i>&nbsp;                // sure to clear the expired flag here.
<i>2010</i>&nbsp;                bundle.expired = false;
<i>2011</i>&nbsp;                break;
<i>2012</i>&nbsp;            }
<i>2013</i>&nbsp;        }
<i>2014</i>&nbsp;
<b class="nc"><i>2015</i>&nbsp;        return bundle;</b>
<i>2016</i>&nbsp;    }
<i>2017</i>&nbsp;
<i>2018</i>&nbsp;    private static boolean isValidBundle(ResourceBundle bundle) {
<i>2019</i>&nbsp;        return bundle != null &amp;&amp; bundle != NONEXISTENT_BUNDLE;
<i>2020</i>&nbsp;    }
<i>2021</i>&nbsp;
<i>2022</i>&nbsp;    /**
<i>2023</i>&nbsp;     * Determines whether any of resource bundles in the parent chain,
<b class="nc"><i>2024</i>&nbsp;     * including the leaf, have expired.</b>
<b class="nc"><i>2025</i>&nbsp;     */</b>
<i>2026</i>&nbsp;    private static boolean hasValidParentChain(ResourceBundle bundle) {
<i>2027</i>&nbsp;        long now = System.currentTimeMillis();
<i>2028</i>&nbsp;        while (bundle != null) {
<i>2029</i>&nbsp;            if (bundle.expired) {
<i>2030</i>&nbsp;                return false;
<i>2031</i>&nbsp;            }
<i>2032</i>&nbsp;            CacheKey key = bundle.cacheKey;
<i>2033</i>&nbsp;            if (key != null) {
<i>2034</i>&nbsp;                long expirationTime = key.expirationTime;
<b class="nc"><i>2035</i>&nbsp;                if (expirationTime &gt;= 0 &amp;&amp; expirationTime &lt;= now) {</b>
<b class="nc"><i>2036</i>&nbsp;                    return false;</b>
<i>2037</i>&nbsp;                }
<i>2038</i>&nbsp;            }
<i>2039</i>&nbsp;            bundle = bundle.parent;
<i>2040</i>&nbsp;        }
<i>2041</i>&nbsp;        return true;
<i>2042</i>&nbsp;    }
<i>2043</i>&nbsp;
<i>2044</i>&nbsp;    /**
<b class="nc"><i>2045</i>&nbsp;     * Throw a MissingResourceException with proper message</b>
<b class="nc"><i>2046</i>&nbsp;     */</b>
<i>2047</i>&nbsp;    private static void throwMissingResourceException(String baseName,
<i>2048</i>&nbsp;                                                      Locale locale,
<i>2049</i>&nbsp;                                                      Throwable cause) {
<i>2050</i>&nbsp;        // If the cause is a MissingResourceException, avoid creating
<i>2051</i>&nbsp;        // a long chain. (6355009)
<i>2052</i>&nbsp;        if (cause instanceof MissingResourceException) {
<i>2053</i>&nbsp;            cause = null;
<i>2054</i>&nbsp;        }
<i>2055</i>&nbsp;        throw new MissingResourceException(&quot;Can&#39;t find bundle for base name &quot;
<i>2056</i>&nbsp;                                           + baseName + &quot;, locale &quot; + locale,
<i>2057</i>&nbsp;                                           baseName + &quot;_&quot; + locale, // className
<i>2058</i>&nbsp;                                           &quot;&quot;,                      // key
<i>2059</i>&nbsp;                                           cause);
<i>2060</i>&nbsp;    }
<i>2061</i>&nbsp;
<i>2062</i>&nbsp;    /**
<i>2063</i>&nbsp;     * Finds a bundle in the cache. Any expired bundles are marked as
<b class="nc"><i>2064</i>&nbsp;     * `expired&#39; and removed from the cache upon return.</b>
<i>2065</i>&nbsp;     *
<i>2066</i>&nbsp;     * @param cacheKey the key to look up the cache
<i>2067</i>&nbsp;     * @param control the Control to be used for the expiration control
<i>2068</i>&nbsp;     * @return the cached bundle, or null if the bundle is not found in the
<i>2069</i>&nbsp;     * cache or its parent has expired. &lt;code&gt;bundle.expire&lt;/code&gt; is true
<b class="nc"><i>2070</i>&nbsp;     * upon return if the bundle in the cache has expired.</b>
<i>2071</i>&nbsp;     */
<i>2072</i>&nbsp;    private static ResourceBundle findBundleInCache(CacheKey cacheKey,
<i>2073</i>&nbsp;                                                    Control control) {
<i>2074</i>&nbsp;        BundleReference bundleRef = cacheList.get(cacheKey);
<i>2075</i>&nbsp;        if (bundleRef == null) {
<i>2076</i>&nbsp;            return null;
<i>2077</i>&nbsp;        }
<i>2078</i>&nbsp;        ResourceBundle bundle = bundleRef.get();
<i>2079</i>&nbsp;        if (bundle == null) {
<i>2080</i>&nbsp;            return null;
<i>2081</i>&nbsp;        }
<i>2082</i>&nbsp;        ResourceBundle p = bundle.parent;
<i>2083</i>&nbsp;        assert p != NONEXISTENT_BUNDLE;
<i>2084</i>&nbsp;        // If the parent has expired, then this one must also expire. We
<i>2085</i>&nbsp;        // check only the immediate parent because the actual loading is
<i>2086</i>&nbsp;        // done from the root (base) to leaf (child) and the purpose of
<i>2087</i>&nbsp;        // checking is to propagate expiration towards the leaf. For
<i>2088</i>&nbsp;        // example, if the requested locale is ja_JP_JP and there are
<i>2089</i>&nbsp;        // bundles for all of the candidates in the cache, we have a list,
<i>2090</i>&nbsp;        //
<i>2091</i>&nbsp;        // base &lt;- ja &lt;- ja_JP &lt;- ja_JP_JP
<i>2092</i>&nbsp;        //
<i>2093</i>&nbsp;        // If ja has expired, then it will reload ja and the list becomes a
<i>2094</i>&nbsp;        // tree.
<i>2095</i>&nbsp;        //
<i>2096</i>&nbsp;        // base &lt;- ja (new)
<b class="nc"><i>2097</i>&nbsp;        //  &quot;   &lt;- ja (expired) &lt;- ja_JP &lt;- ja_JP_JP</b>
<b class="nc"><i>2098</i>&nbsp;        //</b>
<i>2099</i>&nbsp;        // When looking up ja_JP in the cache, it finds ja_JP in the cache
<b class="nc"><i>2100</i>&nbsp;        // which references to the expired ja. Then, ja_JP is marked as</b>
<b class="nc"><i>2101</i>&nbsp;        // expired and removed from the cache. This will be propagated to</b>
<i>2102</i>&nbsp;        // ja_JP_JP.
<b class="nc"><i>2103</i>&nbsp;        //</b>
<b class="nc"><i>2104</i>&nbsp;        // Now, it&#39;s possible, for example, that while loading new ja_JP,</b>
<i>2105</i>&nbsp;        // someone else has started loading the same bundle and finds the
<b class="nc"><i>2106</i>&nbsp;        // base bundle has expired. Then, what we get from the first</b>
<i>2107</i>&nbsp;        // getBundle call includes the expired base bundle. However, if
<i>2108</i>&nbsp;        // someone else didn&#39;t start its loading, we wouldn&#39;t know if the
<i>2109</i>&nbsp;        // base bundle has expired at the end of the loading process. The
<i>2110</i>&nbsp;        // expiration control doesn&#39;t guarantee that the returned bundle and
<i>2111</i>&nbsp;        // its parents haven&#39;t expired.
<i>2112</i>&nbsp;        //
<i>2113</i>&nbsp;        // We could check the entire parent chain to see if there&#39;s any in
<i>2114</i>&nbsp;        // the chain that has expired. But this process may never end. An
<i>2115</i>&nbsp;        // extreme case would be that getTimeToLive returns 0 and
<i>2116</i>&nbsp;        // needsReload always returns true.
<i>2117</i>&nbsp;        if (p != null &amp;&amp; p.expired) {
<i>2118</i>&nbsp;            assert bundle != NONEXISTENT_BUNDLE;
<i>2119</i>&nbsp;            bundle.expired = true;
<i>2120</i>&nbsp;            bundle.cacheKey = null;
<i>2121</i>&nbsp;            cacheList.remove(cacheKey, bundleRef);
<i>2122</i>&nbsp;            bundle = null;
<i>2123</i>&nbsp;        } else {
<i>2124</i>&nbsp;            CacheKey key = bundleRef.getCacheKey();
<i>2125</i>&nbsp;            long expirationTime = key.expirationTime;
<i>2126</i>&nbsp;            if (!bundle.expired &amp;&amp; expirationTime &gt;= 0 &amp;&amp;
<i>2127</i>&nbsp;                expirationTime &lt;= System.currentTimeMillis()) {
<i>2128</i>&nbsp;                // its TTL period has expired.
<i>2129</i>&nbsp;                if (bundle != NONEXISTENT_BUNDLE) {
<i>2130</i>&nbsp;                    // Synchronize here to call needsReload to avoid
<i>2131</i>&nbsp;                    // redundant concurrent calls for the same bundle.
<b class="nc"><i>2132</i>&nbsp;                    synchronized (bundle) {</b>
<b class="nc"><i>2133</i>&nbsp;                        expirationTime = key.expirationTime;</b>
<i>2134</i>&nbsp;                        if (!bundle.expired &amp;&amp; expirationTime &gt;= 0 &amp;&amp;
<b class="nc"><i>2135</i>&nbsp;                            expirationTime &lt;= System.currentTimeMillis()) {</b>
<b class="nc"><i>2136</i>&nbsp;                            try {</b>
<i>2137</i>&nbsp;                                Module module = cacheKey.getModule();
<b class="nc"><i>2138</i>&nbsp;                                bundle.expired =</b>
<b class="nc"><i>2139</i>&nbsp;                                    module == null || // already GCed</b>
<i>2140</i>&nbsp;                                    control.needsReload(key.getName(),
<b class="nc"><i>2141</i>&nbsp;                                                        key.getLocale(),</b>
<i>2142</i>&nbsp;                                                        key.getFormat(),
<i>2143</i>&nbsp;                                                        getLoaderForControl(module),
<i>2144</i>&nbsp;                                                        bundle,
<i>2145</i>&nbsp;                                                        key.loadTime);
<i>2146</i>&nbsp;                            } catch (Exception e) {
<i>2147</i>&nbsp;                                cacheKey.setCause(e);
<i>2148</i>&nbsp;                            }
<i>2149</i>&nbsp;                            if (bundle.expired) {
<i>2150</i>&nbsp;                                // If the bundle needs to be reloaded, then
<i>2151</i>&nbsp;                                // remove the bundle from the cache, but
<i>2152</i>&nbsp;                                // return the bundle with the expired flag
<i>2153</i>&nbsp;                                // on.
<i>2154</i>&nbsp;                                bundle.cacheKey = null;
<i>2155</i>&nbsp;                                cacheList.remove(cacheKey, bundleRef);
<i>2156</i>&nbsp;                            } else {
<i>2157</i>&nbsp;                                // Update the expiration control info. and reuse
<i>2158</i>&nbsp;                                // the same bundle instance
<i>2159</i>&nbsp;                                setExpirationTime(key, control);
<i>2160</i>&nbsp;                            }
<i>2161</i>&nbsp;                        }
<i>2162</i>&nbsp;                    }
<i>2163</i>&nbsp;                } else {
<i>2164</i>&nbsp;                    // We just remove NONEXISTENT_BUNDLE from the cache.
<i>2165</i>&nbsp;                    cacheList.remove(cacheKey, bundleRef);
<i>2166</i>&nbsp;                    bundle = null;
<i>2167</i>&nbsp;                }
<i>2168</i>&nbsp;            }
<i>2169</i>&nbsp;        }
<i>2170</i>&nbsp;        return bundle;
<i>2171</i>&nbsp;    }
<i>2172</i>&nbsp;
<i>2173</i>&nbsp;    /**
<i>2174</i>&nbsp;     * Put a new bundle in the cache.
<i>2175</i>&nbsp;     *
<i>2176</i>&nbsp;     * @param cacheKey the key for the resource bundle
<i>2177</i>&nbsp;     * @param bundle the resource bundle to be put in the cache
<i>2178</i>&nbsp;     * @return the ResourceBundle for the cacheKey; if someone has put
<b class="nc"><i>2179</i>&nbsp;     * the bundle before this call, the one found in the cache is</b>
<b class="nc"><i>2180</i>&nbsp;     * returned.</b>
<i>2181</i>&nbsp;     */
<b class="nc"><i>2182</i>&nbsp;    private static ResourceBundle putBundleInCache(CacheKey cacheKey,</b>
<i>2183</i>&nbsp;                                                   ResourceBundle bundle,
<i>2184</i>&nbsp;                                                   Control control) {
<i>2185</i>&nbsp;        setExpirationTime(cacheKey, control);
<i>2186</i>&nbsp;        if (cacheKey.expirationTime != Control.TTL_DONT_CACHE) {
<i>2187</i>&nbsp;            CacheKey key = new CacheKey(cacheKey);
<i>2188</i>&nbsp;            BundleReference bundleRef = new BundleReference(bundle, referenceQueue, key);
<i>2189</i>&nbsp;            bundle.cacheKey = key;
<i>2190</i>&nbsp;
<i>2191</i>&nbsp;            // Put the bundle in the cache if it&#39;s not been in the cache.
<i>2192</i>&nbsp;            BundleReference result = cacheList.putIfAbsent(key, bundleRef);
<i>2193</i>&nbsp;
<i>2194</i>&nbsp;            // If someone else has put the same bundle in the cache before
<i>2195</i>&nbsp;            // us and it has not expired, we should use the one in the cache.
<i>2196</i>&nbsp;            if (result != null) {
<i>2197</i>&nbsp;                ResourceBundle rb = result.get();
<i>2198</i>&nbsp;                if (rb != null &amp;&amp; !rb.expired) {
<i>2199</i>&nbsp;                    // Clear the back link to the cache key
<i>2200</i>&nbsp;                    bundle.cacheKey = null;
<i>2201</i>&nbsp;                    bundle = rb;
<i>2202</i>&nbsp;                    // Clear the reference in the BundleReference so that
<i>2203</i>&nbsp;                    // it won&#39;t be enqueued.
<i>2204</i>&nbsp;                    bundleRef.clear();
<i>2205</i>&nbsp;                } else {
<i>2206</i>&nbsp;                    // Replace the invalid (garbage collected or expired)
<i>2207</i>&nbsp;                    // instance with the valid one.
<i>2208</i>&nbsp;                    cacheList.put(key, bundleRef);
<i>2209</i>&nbsp;                }
<i>2210</i>&nbsp;            }
<i>2211</i>&nbsp;        }
<i>2212</i>&nbsp;        return bundle;
<i>2213</i>&nbsp;    }
<i>2214</i>&nbsp;
<i>2215</i>&nbsp;    private static void setExpirationTime(CacheKey cacheKey, Control control) {
<i>2216</i>&nbsp;        long ttl = control.getTimeToLive(cacheKey.getName(),
<i>2217</i>&nbsp;                                         cacheKey.getLocale());
<i>2218</i>&nbsp;        if (ttl &gt;= 0) {
<i>2219</i>&nbsp;            // If any expiration time is specified, set the time to be
<i>2220</i>&nbsp;            // expired in the cache.
<i>2221</i>&nbsp;            long now = System.currentTimeMillis();
<i>2222</i>&nbsp;            cacheKey.loadTime = now;
<i>2223</i>&nbsp;            cacheKey.expirationTime = now + ttl;
<i>2224</i>&nbsp;        } else if (ttl &gt;= Control.TTL_NO_EXPIRATION_CONTROL) {
<i>2225</i>&nbsp;            cacheKey.expirationTime = ttl;
<i>2226</i>&nbsp;        } else {
<i>2227</i>&nbsp;            throw new IllegalArgumentException(&quot;Invalid Control: TTL=&quot; + ttl);
<i>2228</i>&nbsp;        }
<i>2229</i>&nbsp;    }
<i>2230</i>&nbsp;
<i>2231</i>&nbsp;    /**
<i>2232</i>&nbsp;     * Removes all resource bundles from the cache that have been loaded
<i>2233</i>&nbsp;     * by the caller&#39;s module.
<i>2234</i>&nbsp;     *
<i>2235</i>&nbsp;     * @since 1.6
<i>2236</i>&nbsp;     * @revised 9
<i>2237</i>&nbsp;     * @spec JPMS
<i>2238</i>&nbsp;     * @see ResourceBundle.Control#getTimeToLive(String,Locale)
<i>2239</i>&nbsp;     */
<i>2240</i>&nbsp;    @CallerSensitive
<i>2241</i>&nbsp;    public static final void clearCache() {
<i>2242</i>&nbsp;        Class&lt;?&gt; caller = Reflection.getCallerClass();
<i>2243</i>&nbsp;        cacheList.keySet().removeIf(
<i>2244</i>&nbsp;            key -&gt; key.getCallerModule() == caller.getModule()
<i>2245</i>&nbsp;        );
<i>2246</i>&nbsp;    }
<i>2247</i>&nbsp;
<i>2248</i>&nbsp;    /**
<i>2249</i>&nbsp;     * Removes all resource bundles from the cache that have been loaded
<i>2250</i>&nbsp;     * by the given class loader.
<i>2251</i>&nbsp;     *
<i>2252</i>&nbsp;     * @param loader the class loader
<i>2253</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;loader&lt;/code&gt; is null
<i>2254</i>&nbsp;     * @since 1.6
<i>2255</i>&nbsp;     * @see ResourceBundle.Control#getTimeToLive(String,Locale)
<i>2256</i>&nbsp;     */
<i>2257</i>&nbsp;    public static final void clearCache(ClassLoader loader) {
<i>2258</i>&nbsp;        Objects.requireNonNull(loader);
<i>2259</i>&nbsp;        cacheList.keySet().removeIf(
<i>2260</i>&nbsp;            key -&gt; {
<i>2261</i>&nbsp;                Module m;
<i>2262</i>&nbsp;                return (m = key.getModule()) != null &amp;&amp;
<i>2263</i>&nbsp;                       getLoader(m) == loader;
<i>2264</i>&nbsp;            }
<i>2265</i>&nbsp;        );
<i>2266</i>&nbsp;    }
<i>2267</i>&nbsp;
<i>2268</i>&nbsp;    /**
<i>2269</i>&nbsp;     * Gets an object for the given key from this resource bundle.
<i>2270</i>&nbsp;     * Returns null if this resource bundle does not contain an
<i>2271</i>&nbsp;     * object for the given key.
<i>2272</i>&nbsp;     *
<i>2273</i>&nbsp;     * @param key the key for the desired object
<i>2274</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>2275</i>&nbsp;     * @return the object for the given key, or null
<i>2276</i>&nbsp;     */
<i>2277</i>&nbsp;    protected abstract Object handleGetObject(String key);
<i>2278</i>&nbsp;
<i>2279</i>&nbsp;    /**
<i>2280</i>&nbsp;     * Returns an enumeration of the keys.
<i>2281</i>&nbsp;     *
<i>2282</i>&nbsp;     * @return an &lt;code&gt;Enumeration&lt;/code&gt; of the keys contained in
<i>2283</i>&nbsp;     *         this &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
<i>2284</i>&nbsp;     */
<i>2285</i>&nbsp;    public abstract Enumeration&lt;String&gt; getKeys();
<i>2286</i>&nbsp;
<i>2287</i>&nbsp;    /**
<i>2288</i>&nbsp;     * Determines whether the given &lt;code&gt;key&lt;/code&gt; is contained in
<i>2289</i>&nbsp;     * this &lt;code&gt;ResourceBundle&lt;/code&gt; or its parent bundles.
<i>2290</i>&nbsp;     *
<i>2291</i>&nbsp;     * @param key
<i>2292</i>&nbsp;     *        the resource &lt;code&gt;key&lt;/code&gt;
<i>2293</i>&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;key&lt;/code&gt; is
<i>2294</i>&nbsp;     *        contained in this &lt;code&gt;ResourceBundle&lt;/code&gt; or its
<i>2295</i>&nbsp;     *        parent bundles; &lt;code&gt;false&lt;/code&gt; otherwise.
<i>2296</i>&nbsp;     * @exception NullPointerException
<i>2297</i>&nbsp;     *         if &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>2298</i>&nbsp;     * @since 1.6
<i>2299</i>&nbsp;     */
<i>2300</i>&nbsp;    public boolean containsKey(String key) {
<i>2301</i>&nbsp;        if (key == null) {
<i>2302</i>&nbsp;            throw new NullPointerException();
<i>2303</i>&nbsp;        }
<i>2304</i>&nbsp;        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
<i>2305</i>&nbsp;            if (rb.handleKeySet().contains(key)) {
<i>2306</i>&nbsp;                return true;
<i>2307</i>&nbsp;            }
<i>2308</i>&nbsp;        }
<i>2309</i>&nbsp;        return false;
<i>2310</i>&nbsp;    }
<i>2311</i>&nbsp;
<i>2312</i>&nbsp;    /**
<i>2313</i>&nbsp;     * Returns a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
<i>2314</i>&nbsp;     * &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
<i>2315</i>&nbsp;     *
<i>2316</i>&nbsp;     * @return a &lt;code&gt;Set&lt;/code&gt; of all keys contained in this
<i>2317</i>&nbsp;     *         &lt;code&gt;ResourceBundle&lt;/code&gt; and its parent bundles.
<i>2318</i>&nbsp;     * @since 1.6
<i>2319</i>&nbsp;     */
<i>2320</i>&nbsp;    public Set&lt;String&gt; keySet() {
<i>2321</i>&nbsp;        Set&lt;String&gt; keys = new HashSet&lt;&gt;();
<i>2322</i>&nbsp;        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
<i>2323</i>&nbsp;            keys.addAll(rb.handleKeySet());
<i>2324</i>&nbsp;        }
<i>2325</i>&nbsp;        return keys;
<i>2326</i>&nbsp;    }
<i>2327</i>&nbsp;
<i>2328</i>&nbsp;    /**
<i>2329</i>&nbsp;     * Returns a &lt;code&gt;Set&lt;/code&gt; of the keys contained &lt;em&gt;only&lt;/em&gt;
<i>2330</i>&nbsp;     * in this &lt;code&gt;ResourceBundle&lt;/code&gt;.
<i>2331</i>&nbsp;     *
<i>2332</i>&nbsp;     * &lt;p&gt;The default implementation returns a &lt;code&gt;Set&lt;/code&gt; of the
<i>2333</i>&nbsp;     * keys returned by the {@link #getKeys() getKeys} method except
<i>2334</i>&nbsp;     * for the ones for which the {@link #handleGetObject(String)
<i>2335</i>&nbsp;     * handleGetObject} method returns &lt;code&gt;null&lt;/code&gt;. Once the
<i>2336</i>&nbsp;     * &lt;code&gt;Set&lt;/code&gt; has been created, the value is kept in this
<i>2337</i>&nbsp;     * &lt;code&gt;ResourceBundle&lt;/code&gt; in order to avoid producing the
<i>2338</i>&nbsp;     * same &lt;code&gt;Set&lt;/code&gt; in subsequent calls. Subclasses can
<i>2339</i>&nbsp;     * override this method for faster handling.
<i>2340</i>&nbsp;     *
<i>2341</i>&nbsp;     * @return a &lt;code&gt;Set&lt;/code&gt; of the keys contained only in this
<i>2342</i>&nbsp;     *        &lt;code&gt;ResourceBundle&lt;/code&gt;
<i>2343</i>&nbsp;     * @since 1.6
<i>2344</i>&nbsp;     */
<i>2345</i>&nbsp;    protected Set&lt;String&gt; handleKeySet() {
<i>2346</i>&nbsp;        if (keySet == null) {
<i>2347</i>&nbsp;            synchronized (this) {
<i>2348</i>&nbsp;                if (keySet == null) {
<i>2349</i>&nbsp;                    Set&lt;String&gt; keys = new HashSet&lt;&gt;();
<i>2350</i>&nbsp;                    Enumeration&lt;String&gt; enumKeys = getKeys();
<i>2351</i>&nbsp;                    while (enumKeys.hasMoreElements()) {
<i>2352</i>&nbsp;                        String key = enumKeys.nextElement();
<i>2353</i>&nbsp;                        if (handleGetObject(key) != null) {
<i>2354</i>&nbsp;                            keys.add(key);
<i>2355</i>&nbsp;                        }
<i>2356</i>&nbsp;                    }
<i>2357</i>&nbsp;                    keySet = keys;
<i>2358</i>&nbsp;                }
<i>2359</i>&nbsp;            }
<i>2360</i>&nbsp;        }
<i>2361</i>&nbsp;        return keySet;
<i>2362</i>&nbsp;    }
<i>2363</i>&nbsp;
<b class="nc"><i>2364</i>&nbsp;</b>
<b class="nc"><i>2365</i>&nbsp;</b>
<i>2366</i>&nbsp;    /**
<b class="nc"><i>2367</i>&nbsp;     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; defines a set of callback methods</b>
<i>2368</i>&nbsp;     * that are invoked by the {@link ResourceBundle#getBundle(String,
<i>2369</i>&nbsp;     * Locale, ClassLoader, Control) ResourceBundle.getBundle} factory
<b class="nc"><i>2370</i>&nbsp;     * methods during the bundle loading process. In other words, a</b>
<i>2371</i>&nbsp;     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; collaborates with the factory
<b class="nc"><i>2372</i>&nbsp;     * methods for loading resource bundles. The default implementation of</b>
<i>2373</i>&nbsp;     * the callback methods provides the information necessary for the
<b class="nc"><i>2374</i>&nbsp;     * factory methods to perform the &lt;a</b>
<b class="nc"><i>2375</i>&nbsp;     * href=&quot;./ResourceBundle.html#default_behavior&quot;&gt;default behavior&lt;/a&gt;.</b>
<b class="nc"><i>2376</i>&nbsp;     *</b>
<b class="nc"><i>2377</i>&nbsp;     * &lt;p&gt; {@link ResourceBundle.Control} is designed for an application deployed</b>
<i>2378</i>&nbsp;     * in an unnamed module, for example to support resource bundles in
<i>2379</i>&nbsp;     * non-standard formats or package localized resources in a non-traditional
<b class="nc"><i>2380</i>&nbsp;     * convention. {@link ResourceBundleProvider} is the replacement for</b>
<b class="nc"><i>2381</i>&nbsp;     * {@code ResourceBundle.Control} when migrating to modules.</b>
<b class="nc"><i>2382</i>&nbsp;     * {@code UnsupportedOperationException} will be thrown when a factory</b>
<b class="nc"><i>2383</i>&nbsp;     * method that takes the {@code ResourceBundle.Control} parameter is called.</b>
<b class="nc"><i>2384</i>&nbsp;     *</b>
<b class="nc"><i>2385</i>&nbsp;     * &lt;p&gt;In addition to the callback methods, the {@link</b>
<i>2386</i>&nbsp;     * #toBundleName(String, Locale) toBundleName} and {@link
<b class="nc"><i>2387</i>&nbsp;     * #toResourceName(String, String) toResourceName} methods are defined</b>
<i>2388</i>&nbsp;     * primarily for convenience in implementing the callback
<i>2389</i>&nbsp;     * methods. However, the &lt;code&gt;toBundleName&lt;/code&gt; method could be
<b class="nc"><i>2390</i>&nbsp;     * overridden to provide different conventions in the organization and</b>
<b class="nc"><i>2391</i>&nbsp;     * packaging of localized resources.  The &lt;code&gt;toResourceName&lt;/code&gt;</b>
<i>2392</i>&nbsp;     * method is &lt;code&gt;final&lt;/code&gt; to avoid use of wrong resource and class
<b class="nc"><i>2393</i>&nbsp;     * name separators.</b>
<b class="nc"><i>2394</i>&nbsp;     *</b>
<b class="nc"><i>2395</i>&nbsp;     * &lt;p&gt;Two factory methods, {@link #getControl(List)} and {@link</b>
<b class="nc"><i>2396</i>&nbsp;     * #getNoFallbackControl(List)}, provide</b>
<b class="nc"><i>2397</i>&nbsp;     * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances that implement common</b>
<i>2398</i>&nbsp;     * variations of the default bundle loading process.
<b class="nc"><i>2399</i>&nbsp;     *</b>
<b class="nc"><i>2400</i>&nbsp;     * &lt;p&gt;The formats returned by the {@link Control#getFormats(String)</b>
<b class="nc"><i>2401</i>&nbsp;     * getFormats} method and candidate locales returned by the {@link</b>
<b class="nc"><i>2402</i>&nbsp;     * ResourceBundle.Control#getCandidateLocales(String, Locale)</b>
<b class="nc"><i>2403</i>&nbsp;     * getCandidateLocales} method must be consistent in all</b>
<i>2404</i>&nbsp;     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; invocations for the same base
<b class="nc"><i>2405</i>&nbsp;     * bundle. Otherwise, the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; methods</b>
<b class="nc"><i>2406</i>&nbsp;     * may return unintended bundles. For example, if only</b>
<b class="nc"><i>2407</i>&nbsp;     * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; is returned by the &lt;code&gt;getFormats&lt;/code&gt;</b>
<b class="nc"><i>2408</i>&nbsp;     * method for the first call to &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</b>
<b class="nc"><i>2409</i>&nbsp;     * and only &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for the second call, then the</b>
<b class="nc"><i>2410</i>&nbsp;     * second call will return the class-based one that has been cached</b>
<i>2411</i>&nbsp;     * during the first call.
<i>2412</i>&nbsp;     *
<b class="nc"><i>2413</i>&nbsp;     * &lt;p&gt;A &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instance must be thread-safe</b>
<b class="nc"><i>2414</i>&nbsp;     * if it&#39;s simultaneously used by multiple threads.</b>
<i>2415</i>&nbsp;     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; does not synchronize to call
<i>2416</i>&nbsp;     * the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; methods. The default
<b class="nc"><i>2417</i>&nbsp;     * implementations of the methods are thread-safe.</b>
<i>2418</i>&nbsp;     *
<i>2419</i>&nbsp;     * &lt;p&gt;Applications can specify &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
<i>2420</i>&nbsp;     * instances returned by the &lt;code&gt;getControl&lt;/code&gt; factory methods or
<b class="nc"><i>2421</i>&nbsp;     * created from a subclass of &lt;code&gt;ResourceBundle.Control&lt;/code&gt; to</b>
<b class="nc"><i>2422</i>&nbsp;     * customize the bundle loading process. The following are examples of</b>
<i>2423</i>&nbsp;     * changing the default bundle loading process.
<i>2424</i>&nbsp;     *
<b class="nc"><i>2425</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;</b>
<b class="nc"><i>2426</i>&nbsp;     *</b>
<i>2427</i>&nbsp;     * &lt;p&gt;The following code lets &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; look
<b class="nc"><i>2428</i>&nbsp;     * up only properties-based resources.</b>
<i>2429</i>&nbsp;     *
<i>2430</i>&nbsp;     * &lt;pre&gt;
<b class="nc"><i>2431</i>&nbsp;     * import java.util.*;</b>
<i>2432</i>&nbsp;     * import static java.util.ResourceBundle.Control.*;
<b class="nc"><i>2433</i>&nbsp;     * ...</b>
<b class="nc"><i>2434</i>&nbsp;     * ResourceBundle bundle =</b>
<i>2435</i>&nbsp;     *   ResourceBundle.getBundle(&quot;MyResources&quot;, new Locale(&quot;fr&quot;, &quot;CH&quot;),
<b class="nc"><i>2436</i>&nbsp;     *                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));</b>
<i>2437</i>&nbsp;     * &lt;/pre&gt;
<i>2438</i>&nbsp;     *
<i>2439</i>&nbsp;     * Given the resource bundles in the &lt;a
<i>2440</i>&nbsp;     * href=&quot;./ResourceBundle.html#default_behavior_example&quot;&gt;example&lt;/a&gt; in
<i>2441</i>&nbsp;     * the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; description, this
<b class="nc"><i>2442</i>&nbsp;     * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; call loads</b>
<i>2443</i>&nbsp;     * &lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt; whose parent is
<i>2444</i>&nbsp;     * &lt;code&gt;MyResources_fr.properties&lt;/code&gt; whose parent is
<i>2445</i>&nbsp;     * &lt;code&gt;MyResources.properties&lt;/code&gt;. (&lt;code&gt;MyResources_fr_CH.properties&lt;/code&gt;
<b class="nc"><i>2446</i>&nbsp;     * is not hidden, but &lt;code&gt;MyResources_fr_CH.class&lt;/code&gt; is.)</b>
<i>2447</i>&nbsp;     *
<b class="nc"><i>2448</i>&nbsp;     * &lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;</b>
<b class="nc"><i>2449</i>&nbsp;     *</b>
<b class="nc"><i>2450</i>&nbsp;     * &lt;p&gt;The following is an example of loading XML-based bundles</b>
<b class="nc"><i>2451</i>&nbsp;     * using {@link Properties#loadFromXML(java.io.InputStream)</b>
<b class="nc"><i>2452</i>&nbsp;     * Properties.loadFromXML}.</b>
<b class="nc"><i>2453</i>&nbsp;     *</b>
<i>2454</i>&nbsp;     * &lt;pre&gt;
<i>2455</i>&nbsp;     * ResourceBundle rb = ResourceBundle.getBundle(&quot;Messages&quot;,
<i>2456</i>&nbsp;     *     new ResourceBundle.Control() {
<b class="nc"><i>2457</i>&nbsp;     *         public List&amp;lt;String&amp;gt; getFormats(String baseName) {</b>
<i>2458</i>&nbsp;     *             if (baseName == null)
<b class="nc"><i>2459</i>&nbsp;     *                 throw new NullPointerException();</b>
<b class="nc"><i>2460</i>&nbsp;     *             return Arrays.asList(&quot;xml&quot;);</b>
<b class="nc"><i>2461</i>&nbsp;     *         }</b>
<b class="nc"><i>2462</i>&nbsp;     *         public ResourceBundle newBundle(String baseName,</b>
<i>2463</i>&nbsp;     *                                         Locale locale,
<b class="nc"><i>2464</i>&nbsp;     *                                         String format,</b>
<b class="nc"><i>2465</i>&nbsp;     *                                         ClassLoader loader,</b>
<i>2466</i>&nbsp;     *                                         boolean reload)
<b class="nc"><i>2467</i>&nbsp;     *                          throws IllegalAccessException,</b>
<b class="nc"><i>2468</i>&nbsp;     *                                 InstantiationException,</b>
<i>2469</i>&nbsp;     *                                 IOException {
<i>2470</i>&nbsp;     *             if (baseName == null || locale == null
<i>2471</i>&nbsp;     *                   || format == null || loader == null)
<b class="nc"><i>2472</i>&nbsp;     *                 throw new NullPointerException();</b>
<b class="nc"><i>2473</i>&nbsp;     *             ResourceBundle bundle = null;</b>
<b class="nc"><i>2474</i>&nbsp;     *             if (format.equals(&quot;xml&quot;)) {</b>
<b class="nc"><i>2475</i>&nbsp;     *                 String bundleName = toBundleName(baseName, locale);</b>
<i>2476</i>&nbsp;     *                 String resourceName = toResourceName(bundleName, format);
<b class="nc"><i>2477</i>&nbsp;     *                 InputStream stream = null;</b>
<b class="nc"><i>2478</i>&nbsp;     *                 if (reload) {</b>
<i>2479</i>&nbsp;     *                     URL url = loader.getResource(resourceName);
<i>2480</i>&nbsp;     *                     if (url != null) {
<b class="nc"><i>2481</i>&nbsp;     *                         URLConnection connection = url.openConnection();</b>
<b class="nc"><i>2482</i>&nbsp;     *                         if (connection != null) {</b>
<i>2483</i>&nbsp;     *                             // Disable caches to get fresh data for
<i>2484</i>&nbsp;     *                             // reloading.
<b class="nc"><i>2485</i>&nbsp;     *                             connection.setUseCaches(false);</b>
<i>2486</i>&nbsp;     *                             stream = connection.getInputStream();
<b class="nc"><i>2487</i>&nbsp;     *                         }</b>
<i>2488</i>&nbsp;     *                     }
<i>2489</i>&nbsp;     *                 } else {
<i>2490</i>&nbsp;     *                     stream = loader.getResourceAsStream(resourceName);
<i>2491</i>&nbsp;     *                 }
<i>2492</i>&nbsp;     *                 if (stream != null) {
<i>2493</i>&nbsp;     *                     BufferedInputStream bis = new BufferedInputStream(stream);
<i>2494</i>&nbsp;     *                     bundle = new XMLResourceBundle(bis);
<i>2495</i>&nbsp;     *                     bis.close();
<i>2496</i>&nbsp;     *                 }
<i>2497</i>&nbsp;     *             }
<i>2498</i>&nbsp;     *             return bundle;
<i>2499</i>&nbsp;     *         }
<i>2500</i>&nbsp;     *     });
<i>2501</i>&nbsp;     *
<i>2502</i>&nbsp;     * ...
<i>2503</i>&nbsp;     *
<i>2504</i>&nbsp;     * private static class XMLResourceBundle extends ResourceBundle {
<i>2505</i>&nbsp;     *     private Properties props;
<i>2506</i>&nbsp;     *     XMLResourceBundle(InputStream stream) throws IOException {
<i>2507</i>&nbsp;     *         props = new Properties();
<i>2508</i>&nbsp;     *         props.loadFromXML(stream);
<i>2509</i>&nbsp;     *     }
<i>2510</i>&nbsp;     *     protected Object handleGetObject(String key) {
<i>2511</i>&nbsp;     *         return props.getProperty(key);
<i>2512</i>&nbsp;     *     }
<i>2513</i>&nbsp;     *     public Enumeration&amp;lt;String&amp;gt; getKeys() {
<i>2514</i>&nbsp;     *         ...
<i>2515</i>&nbsp;     *     }
<i>2516</i>&nbsp;     * }
<i>2517</i>&nbsp;     * &lt;/pre&gt;
<i>2518</i>&nbsp;     *
<i>2519</i>&nbsp;     * @apiNote {@code ResourceBundle.Control} is not supported
<i>2520</i>&nbsp;     * in named modules. If the {@code ResourceBundle.getBundle} method with
<i>2521</i>&nbsp;     * a {@code ResourceBundle.Control} is called in a named module, the method
<i>2522</i>&nbsp;     * will throw an {@link UnsupportedOperationException}. Any service providers
<i>2523</i>&nbsp;     * of {@link ResourceBundleControlProvider} are ignored in named modules.
<i>2524</i>&nbsp;     *
<i>2525</i>&nbsp;     * @since 1.6
<i>2526</i>&nbsp;     * @revised 9
<i>2527</i>&nbsp;     * @spec JPMS
<b class="nc"><i>2528</i>&nbsp;     * @see java.util.spi.ResourceBundleProvider</b>
<b class="nc"><i>2529</i>&nbsp;     */</b>
<i>2530</i>&nbsp;    public static class Control {
<b class="nc"><i>2531</i>&nbsp;        /**</b>
<b class="nc"><i>2532</i>&nbsp;         * The default format &lt;code&gt;List&lt;/code&gt;, which contains the strings</b>
<i>2533</i>&nbsp;         * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, in
<i>2534</i>&nbsp;         * this order. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.
<i>2535</i>&nbsp;         *
<i>2536</i>&nbsp;         * @see #getFormats(String)
<i>2537</i>&nbsp;         */
<i>2538</i>&nbsp;        public static final List&lt;String&gt; FORMAT_DEFAULT
<i>2539</i>&nbsp;            = List.of(&quot;java.class&quot;, &quot;java.properties&quot;);
<i>2540</i>&nbsp;
<i>2541</i>&nbsp;        /**
<i>2542</i>&nbsp;         * The class-only format &lt;code&gt;List&lt;/code&gt; containing
<i>2543</i>&nbsp;         * &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.
<i>2544</i>&nbsp;         *
<i>2545</i>&nbsp;         * @see #getFormats(String)
<i>2546</i>&nbsp;         */
<i>2547</i>&nbsp;        public static final List&lt;String&gt; FORMAT_CLASS = List.of(&quot;java.class&quot;);
<i>2548</i>&nbsp;
<i>2549</i>&nbsp;        /**
<i>2550</i>&nbsp;         * The properties-only format &lt;code&gt;List&lt;/code&gt; containing
<i>2551</i>&nbsp;         * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;. This &lt;code&gt;List&lt;/code&gt; is unmodifiable.
<i>2552</i>&nbsp;         *
<i>2553</i>&nbsp;         * @see #getFormats(String)
<i>2554</i>&nbsp;         */
<i>2555</i>&nbsp;        public static final List&lt;String&gt; FORMAT_PROPERTIES
<i>2556</i>&nbsp;            = List.of(&quot;java.properties&quot;);
<i>2557</i>&nbsp;
<i>2558</i>&nbsp;        /**
<i>2559</i>&nbsp;         * The time-to-live constant for not caching loaded resource bundle
<i>2560</i>&nbsp;         * instances.
<i>2561</i>&nbsp;         *
<i>2562</i>&nbsp;         * @see #getTimeToLive(String, Locale)
<i>2563</i>&nbsp;         */
<i>2564</i>&nbsp;        public static final long TTL_DONT_CACHE = -1;
<i>2565</i>&nbsp;
<i>2566</i>&nbsp;        /**
<i>2567</i>&nbsp;         * The time-to-live constant for disabling the expiration control
<i>2568</i>&nbsp;         * for loaded resource bundle instances in the cache.
<i>2569</i>&nbsp;         *
<i>2570</i>&nbsp;         * @see #getTimeToLive(String, Locale)
<i>2571</i>&nbsp;         */
<i>2572</i>&nbsp;        public static final long TTL_NO_EXPIRATION_CONTROL = -2;
<i>2573</i>&nbsp;
<i>2574</i>&nbsp;        private static final Control INSTANCE = new Control();
<i>2575</i>&nbsp;
<i>2576</i>&nbsp;        /**
<i>2577</i>&nbsp;         * Sole constructor. (For invocation by subclass constructors,
<i>2578</i>&nbsp;         * typically implicit.)
<i>2579</i>&nbsp;         */
<i>2580</i>&nbsp;        protected Control() {
<i>2581</i>&nbsp;        }
<i>2582</i>&nbsp;
<i>2583</i>&nbsp;        /**
<i>2584</i>&nbsp;         * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link
<i>2585</i>&nbsp;         * #getFormats(String) getFormats} method returns the specified
<i>2586</i>&nbsp;         * &lt;code&gt;formats&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must be equal to
<i>2587</i>&nbsp;         * one of {@link Control#FORMAT_PROPERTIES}, {@link
<i>2588</i>&nbsp;         * Control#FORMAT_CLASS} or {@link
<i>2589</i>&nbsp;         * Control#FORMAT_DEFAULT}. &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
<i>2590</i>&nbsp;         * instances returned by this method are singletons and thread-safe.
<i>2591</i>&nbsp;         *
<i>2592</i>&nbsp;         * &lt;p&gt;Specifying {@link Control#FORMAT_DEFAULT} is equivalent to
<i>2593</i>&nbsp;         * instantiating the &lt;code&gt;ResourceBundle.Control&lt;/code&gt; class,
<i>2594</i>&nbsp;         * except that this method returns a singleton.
<i>2595</i>&nbsp;         *
<i>2596</i>&nbsp;         * @param formats
<i>2597</i>&nbsp;         *        the formats to be returned by the
<i>2598</i>&nbsp;         *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method
<i>2599</i>&nbsp;         * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
<i>2600</i>&nbsp;         *        specified &lt;code&gt;formats&lt;/code&gt;
<i>2601</i>&nbsp;         * @exception NullPointerException
<i>2602</i>&nbsp;         *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>2603</i>&nbsp;         * @exception IllegalArgumentException
<i>2604</i>&nbsp;         *        if &lt;code&gt;formats&lt;/code&gt; is unknown
<i>2605</i>&nbsp;         */
<i>2606</i>&nbsp;        public static final Control getControl(List&lt;String&gt; formats) {
<i>2607</i>&nbsp;            if (formats.equals(Control.FORMAT_PROPERTIES)) {
<i>2608</i>&nbsp;                return SingleFormatControl.PROPERTIES_ONLY;
<i>2609</i>&nbsp;            }
<i>2610</i>&nbsp;            if (formats.equals(Control.FORMAT_CLASS)) {
<i>2611</i>&nbsp;                return SingleFormatControl.CLASS_ONLY;
<i>2612</i>&nbsp;            }
<i>2613</i>&nbsp;            if (formats.equals(Control.FORMAT_DEFAULT)) {
<i>2614</i>&nbsp;                return Control.INSTANCE;
<i>2615</i>&nbsp;            }
<i>2616</i>&nbsp;            throw new IllegalArgumentException();
<i>2617</i>&nbsp;        }
<i>2618</i>&nbsp;
<i>2619</i>&nbsp;        /**
<i>2620</i>&nbsp;         * Returns a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; in which the {@link
<i>2621</i>&nbsp;         * #getFormats(String) getFormats} method returns the specified
<i>2622</i>&nbsp;         * &lt;code&gt;formats&lt;/code&gt; and the {@link
<i>2623</i>&nbsp;         * Control#getFallbackLocale(String, Locale) getFallbackLocale}
<i>2624</i>&nbsp;         * method returns &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;formats&lt;/code&gt; must
<i>2625</i>&nbsp;         * be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link
<i>2626</i>&nbsp;         * Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
<i>2627</i>&nbsp;         * &lt;code&gt;ResourceBundle.Control&lt;/code&gt; instances returned by this
<i>2628</i>&nbsp;         * method are singletons and thread-safe.
<i>2629</i>&nbsp;         *
<i>2630</i>&nbsp;         * @param formats
<i>2631</i>&nbsp;         *        the formats to be returned by the
<i>2632</i>&nbsp;         *        &lt;code&gt;ResourceBundle.Control.getFormats&lt;/code&gt; method
<i>2633</i>&nbsp;         * @return a &lt;code&gt;ResourceBundle.Control&lt;/code&gt; supporting the
<b class="nc"><i>2634</i>&nbsp;         *        specified &lt;code&gt;formats&lt;/code&gt; with no fallback</b>
<b class="nc"><i>2635</i>&nbsp;         *        &lt;code&gt;Locale&lt;/code&gt; support</b>
<b class="nc"><i>2636</i>&nbsp;         * @exception NullPointerException</b>
<i>2637</i>&nbsp;         *        if &lt;code&gt;formats&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>2638</i>&nbsp;         * @exception IllegalArgumentException
<b class="nc"><i>2639</i>&nbsp;         *        if &lt;code&gt;formats&lt;/code&gt; is unknown</b>
<b class="nc"><i>2640</i>&nbsp;         */</b>
<i>2641</i>&nbsp;        public static final Control getNoFallbackControl(List&lt;String&gt; formats) {
<i>2642</i>&nbsp;            if (formats.equals(Control.FORMAT_DEFAULT)) {
<i>2643</i>&nbsp;                return NoFallbackControl.NO_FALLBACK;
<b class="nc"><i>2644</i>&nbsp;            }</b>
<b class="nc"><i>2645</i>&nbsp;            if (formats.equals(Control.FORMAT_PROPERTIES)) {</b>
<i>2646</i>&nbsp;                return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;
<b class="nc"><i>2647</i>&nbsp;            }</b>
<i>2648</i>&nbsp;            if (formats.equals(Control.FORMAT_CLASS)) {
<i>2649</i>&nbsp;                return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;
<b class="nc"><i>2650</i>&nbsp;            }</b>
<b class="nc"><i>2651</i>&nbsp;            throw new IllegalArgumentException();</b>
<b class="nc"><i>2652</i>&nbsp;        }</b>
<b class="nc"><i>2653</i>&nbsp;</b>
<b class="nc"><i>2654</i>&nbsp;        /**</b>
<b class="nc"><i>2655</i>&nbsp;         * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing</b>
<i>2656</i>&nbsp;         * formats to be used to load resource bundles for the given
<b class="nc"><i>2657</i>&nbsp;         * &lt;code&gt;baseName&lt;/code&gt;. The &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;</b>
<b class="nc"><i>2658</i>&nbsp;         * factory method tries to load resource bundles with formats in the</b>
<b class="nc"><i>2659</i>&nbsp;         * order specified by the list. The list returned by this method</b>
<i>2660</i>&nbsp;         * must have at least one &lt;code&gt;String&lt;/code&gt;. The predefined
<b class="nc"><i>2661</i>&nbsp;         * formats are &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; for class-based resource</b>
<b class="nc"><i>2662</i>&nbsp;         * bundles and &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt; for {@linkplain</b>
<i>2663</i>&nbsp;         * PropertyResourceBundle properties-based} ones. Strings starting
<b class="nc"><i>2664</i>&nbsp;         * with &lt;code&gt;&quot;java.&quot;&lt;/code&gt; are reserved for future extensions and</b>
<b class="nc"><i>2665</i>&nbsp;         * must not be used by application-defined formats.</b>
<b class="nc"><i>2666</i>&nbsp;         *</b>
<b class="nc"><i>2667</i>&nbsp;         * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)</b>
<b class="nc"><i>2668</i>&nbsp;         * &lt;code&gt;List&lt;/code&gt;.  However, the returned &lt;code&gt;List&lt;/code&gt; must</b>
<b class="nc"><i>2669</i>&nbsp;         * not be mutated after it has been returned by</b>
<i>2670</i>&nbsp;         * &lt;code&gt;getFormats&lt;/code&gt;.
<i>2671</i>&nbsp;         *
<b class="nc"><i>2672</i>&nbsp;         * &lt;p&gt;The default implementation returns {@link #FORMAT_DEFAULT} so</b>
<b class="nc"><i>2673</i>&nbsp;         * that the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method</b>
<i>2674</i>&nbsp;         * looks up first class-based resource bundles, then
<i>2675</i>&nbsp;         * properties-based ones.
<b class="nc"><i>2676</i>&nbsp;         *</b>
<b class="nc"><i>2677</i>&nbsp;         * @param baseName</b>
<i>2678</i>&nbsp;         *        the base name of the resource bundle, a fully qualified class
<b class="nc"><i>2679</i>&nbsp;         *        name</b>
<i>2680</i>&nbsp;         * @return a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt;s containing
<i>2681</i>&nbsp;         *        formats for loading resource bundles.
<b class="nc"><i>2682</i>&nbsp;         * @exception NullPointerException</b>
<b class="nc"><i>2683</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt; is null</b>
<b class="nc"><i>2684</i>&nbsp;         * @see #FORMAT_DEFAULT</b>
<b class="nc"><i>2685</i>&nbsp;         * @see #FORMAT_CLASS</b>
<i>2686</i>&nbsp;         * @see #FORMAT_PROPERTIES
<b class="nc"><i>2687</i>&nbsp;         */</b>
<i>2688</i>&nbsp;        public List&lt;String&gt; getFormats(String baseName) {
<b class="nc"><i>2689</i>&nbsp;            if (baseName == null) {</b>
<b class="nc"><i>2690</i>&nbsp;                throw new NullPointerException();</b>
<i>2691</i>&nbsp;            }
<b class="nc"><i>2692</i>&nbsp;            return FORMAT_DEFAULT;</b>
<b class="nc"><i>2693</i>&nbsp;        }</b>
<i>2694</i>&nbsp;
<b class="nc"><i>2695</i>&nbsp;        /**</b>
<i>2696</i>&nbsp;         * Returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s as candidate
<i>2697</i>&nbsp;         * locales for &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;. This
<i>2698</i>&nbsp;         * method is called by the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt;
<i>2699</i>&nbsp;         * factory method each time the factory method tries finding a
<i>2700</i>&nbsp;         * resource bundle for a target &lt;code&gt;Locale&lt;/code&gt;.
<i>2701</i>&nbsp;         *
<i>2702</i>&nbsp;         * &lt;p&gt;The sequence of the candidate locales also corresponds to the
<i>2703</i>&nbsp;         * runtime resource lookup path (also known as the &lt;I&gt;parent
<i>2704</i>&nbsp;         * chain&lt;/I&gt;), if the corresponding resource bundles for the
<i>2705</i>&nbsp;         * candidate locales exist and their parents are not defined by
<i>2706</i>&nbsp;         * loaded resource bundles themselves.  The last element of the list
<i>2707</i>&nbsp;         * must be a {@linkplain Locale#ROOT root locale} if it is desired to
<i>2708</i>&nbsp;         * have the base bundle as the terminal of the parent chain.
<i>2709</i>&nbsp;         *
<i>2710</i>&nbsp;         * &lt;p&gt;If the given locale is equal to &lt;code&gt;Locale.ROOT&lt;/code&gt; (the
<i>2711</i>&nbsp;         * root locale), a &lt;code&gt;List&lt;/code&gt; containing only the root
<i>2712</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt; must be returned. In this case, the
<i>2713</i>&nbsp;         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method loads only
<i>2714</i>&nbsp;         * the base bundle as the resulting resource bundle.
<i>2715</i>&nbsp;         *
<i>2716</i>&nbsp;         * &lt;p&gt;It is not a requirement to return an immutable (unmodifiable)
<i>2717</i>&nbsp;         * &lt;code&gt;List&lt;/code&gt;. However, the returned &lt;code&gt;List&lt;/code&gt; must not
<i>2718</i>&nbsp;         * be mutated after it has been returned by
<i>2719</i>&nbsp;         * &lt;code&gt;getCandidateLocales&lt;/code&gt;.
<i>2720</i>&nbsp;         *
<i>2721</i>&nbsp;         * &lt;p&gt;The default implementation returns a &lt;code&gt;List&lt;/code&gt; containing
<i>2722</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt;s using the rules described below.  In the
<i>2723</i>&nbsp;         * description below, &lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt; and &lt;em&gt;V&lt;/em&gt;
<i>2724</i>&nbsp;         * respectively represent non-empty language, script, country, and
<i>2725</i>&nbsp;         * variant.  For example, [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] represents a
<i>2726</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt; that has non-empty values only for language and
<i>2727</i>&nbsp;         * country.  The form &lt;em&gt;L&lt;/em&gt;(&quot;xx&quot;) represents the (non-empty)
<i>2728</i>&nbsp;         * language value is &quot;xx&quot;.  For all cases, &lt;code&gt;Locale&lt;/code&gt;s whose
<i>2729</i>&nbsp;         * final component values are empty strings are omitted.
<i>2730</i>&nbsp;         *
<i>2731</i>&nbsp;         * &lt;ol&gt;&lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with an empty script value,
<i>2732</i>&nbsp;         * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
<i>2733</i>&nbsp;         * one by one as below:
<i>2734</i>&nbsp;         *
<i>2735</i>&nbsp;         * &lt;ul&gt;
<i>2736</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;] &lt;/li&gt;
<i>2737</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;] &lt;/li&gt;
<i>2738</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;] &lt;/li&gt;
<i>2739</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; &lt;/li&gt;
<i>2740</i>&nbsp;         * &lt;/ul&gt;&lt;/li&gt;
<i>2741</i>&nbsp;         *
<i>2742</i>&nbsp;         * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a non-empty script value,
<i>2743</i>&nbsp;         * append candidate &lt;code&gt;Locale&lt;/code&gt;s by omitting the final component
<i>2744</i>&nbsp;         * up to language, then append candidates generated from the
<b class="nc"><i>2745</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt; with country and variant restored:</b>
<b class="nc"><i>2746</i>&nbsp;         *</b>
<i>2747</i>&nbsp;         * &lt;ul&gt;
<b class="nc"><i>2748</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;</b>
<i>2749</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
<i>2750</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
<i>2751</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V&lt;/em&gt;]&lt;/li&gt;
<i>2752</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
<i>2753</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<i>2754</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
<i>2755</i>&nbsp;         * &lt;/ul&gt;&lt;/li&gt;
<i>2756</i>&nbsp;         *
<i>2757</i>&nbsp;         * &lt;li&gt;For an input &lt;code&gt;Locale&lt;/code&gt; with a variant value consisting
<i>2758</i>&nbsp;         * of multiple subtags separated by underscore, generate candidate
<i>2759</i>&nbsp;         * &lt;code&gt;Locale&lt;/code&gt;s by omitting the variant subtags one by one, then
<i>2760</i>&nbsp;         * insert them after every occurrence of &lt;code&gt; Locale&lt;/code&gt;s with the
<i>2761</i>&nbsp;         * full variant value in the original list.  For example, if
<i>2762</i>&nbsp;         * the variant consists of two subtags &lt;em&gt;V1&lt;/em&gt; and &lt;em&gt;V2&lt;/em&gt;:
<i>2763</i>&nbsp;         *
<i>2764</i>&nbsp;         * &lt;ul&gt;
<i>2765</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
<i>2766</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
<i>2767</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
<i>2768</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;S&lt;/em&gt;]&lt;/li&gt;
<i>2769</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;, &lt;em&gt;V2&lt;/em&gt;]&lt;/li&gt;
<i>2770</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;, &lt;em&gt;V1&lt;/em&gt;]&lt;/li&gt;
<i>2771</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;, &lt;em&gt;C&lt;/em&gt;]&lt;/li&gt;
<i>2772</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;]&lt;/li&gt;
<i>2773</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
<i>2774</i>&nbsp;         * &lt;/ul&gt;&lt;/li&gt;
<i>2775</i>&nbsp;         *
<i>2776</i>&nbsp;         * &lt;li&gt;Special cases for Chinese.  When an input &lt;code&gt;Locale&lt;/code&gt; has the
<i>2777</i>&nbsp;         * language &quot;zh&quot; (Chinese) and an empty script value, either &quot;Hans&quot; (Simplified) or
<i>2778</i>&nbsp;         * &quot;Hant&quot; (Traditional) might be supplied, depending on the country.
<i>2779</i>&nbsp;         * When the country is &quot;CN&quot; (China) or &quot;SG&quot; (Singapore), &quot;Hans&quot; is supplied.
<i>2780</i>&nbsp;         * When the country is &quot;HK&quot; (Hong Kong SAR China), &quot;MO&quot; (Macau SAR China),
<i>2781</i>&nbsp;         * or &quot;TW&quot; (Taiwan), &quot;Hant&quot; is supplied.  For all other countries or when the country
<i>2782</i>&nbsp;         * is empty, no script is supplied.  For example, for &lt;code&gt;Locale(&quot;zh&quot;, &quot;CN&quot;)
<i>2783</i>&nbsp;         * &lt;/code&gt;, the candidate list will be:
<i>2784</i>&nbsp;         * &lt;ul&gt;
<i>2785</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
<i>2786</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hans&quot;)]&lt;/li&gt;
<i>2787</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;CN&quot;)]&lt;/li&gt;
<i>2788</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<i>2789</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
<i>2790</i>&nbsp;         * &lt;/ul&gt;
<i>2791</i>&nbsp;         *
<i>2792</i>&nbsp;         * For &lt;code&gt;Locale(&quot;zh&quot;, &quot;TW&quot;)&lt;/code&gt;, the candidate list will be:
<i>2793</i>&nbsp;         * &lt;ul&gt;
<i>2794</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
<i>2795</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;S&lt;/em&gt;(&quot;Hant&quot;)]&lt;/li&gt;
<i>2796</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;TW&quot;)]&lt;/li&gt;
<i>2797</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;zh&quot;)]&lt;/li&gt;
<i>2798</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;
<i>2799</i>&nbsp;         * &lt;/ul&gt;&lt;/li&gt;
<i>2800</i>&nbsp;         *
<i>2801</i>&nbsp;         * &lt;li&gt;Special cases for Norwegian.  Both &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;,
<b class="nc"><i>2802</i>&nbsp;         * &quot;NY&quot;)&lt;/code&gt; and &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; represent Norwegian</b>
<b class="nc"><i>2803</i>&nbsp;         * Nynorsk.  When a locale&#39;s language is &quot;nn&quot;, the standard candidate</b>
<i>2804</i>&nbsp;         * list is generated up to [&lt;em&gt;L&lt;/em&gt;(&quot;nn&quot;)], and then the following
<b class="nc"><i>2805</i>&nbsp;         * candidates are added:</b>
<b class="nc"><i>2806</i>&nbsp;         *</b>
<i>2807</i>&nbsp;         * &lt;ul&gt;&lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;NY&quot;)]&lt;/li&gt;
<b class="nc"><i>2808</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;</b>
<i>2809</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<b class="nc"><i>2810</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</b>
<b class="nc"><i>2811</i>&nbsp;         * &lt;/ul&gt;</b>
<b class="nc"><i>2812</i>&nbsp;         *</b>
<i>2813</i>&nbsp;         * If the locale is exactly &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt;, it is first
<b class="nc"><i>2814</i>&nbsp;         * converted to &lt;code&gt;Locale(&quot;nn&quot;, &quot;NO&quot;)&lt;/code&gt; and then the above procedure is</b>
<b class="nc"><i>2815</i>&nbsp;         * followed.</b>
<b class="nc"><i>2816</i>&nbsp;         *</b>
<b class="nc"><i>2817</i>&nbsp;         * &lt;p&gt;Also, Java treats the language &quot;no&quot; as a synonym of Norwegian</b>
<b class="nc"><i>2818</i>&nbsp;         * Bokm&amp;#xE5;l &quot;nb&quot;.  Except for the single case &lt;code&gt;Locale(&quot;no&quot;,</b>
<i>2819</i>&nbsp;         * &quot;NO&quot;, &quot;NY&quot;)&lt;/code&gt; (handled above), when an input &lt;code&gt;Locale&lt;/code&gt;
<b class="nc"><i>2820</i>&nbsp;         * has language &quot;no&quot; or &quot;nb&quot;, candidate &lt;code&gt;Locale&lt;/code&gt;s with</b>
<b class="nc"><i>2821</i>&nbsp;         * language code &quot;no&quot; and &quot;nb&quot; are interleaved, first using the</b>
<b class="nc"><i>2822</i>&nbsp;         * requested language, then using its synonym. For example,</b>
<b class="nc"><i>2823</i>&nbsp;         * &lt;code&gt;Locale(&quot;nb&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; generates the following</b>
<b class="nc"><i>2824</i>&nbsp;         * candidate list:</b>
<b class="nc"><i>2825</i>&nbsp;         *</b>
<b class="nc"><i>2826</i>&nbsp;         * &lt;ul&gt;</b>
<i>2827</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
<i>2828</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;), &lt;em&gt;V&lt;/em&gt;(&quot;POSIX&quot;)]&lt;/li&gt;
<b class="nc"><i>2829</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;</b>
<b class="nc"><i>2830</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;), &lt;em&gt;C&lt;/em&gt;(&quot;NO&quot;)]&lt;/li&gt;</b>
<i>2831</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;nb&quot;)]&lt;/li&gt;
<i>2832</i>&nbsp;         * &lt;li&gt; [&lt;em&gt;L&lt;/em&gt;(&quot;no&quot;)]&lt;/li&gt;
<b class="nc"><i>2833</i>&nbsp;         * &lt;li&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/li&gt;</b>
<i>2834</i>&nbsp;         * &lt;/ul&gt;
<b class="nc"><i>2835</i>&nbsp;         *</b>
<b class="nc"><i>2836</i>&nbsp;         * &lt;code&gt;Locale(&quot;no&quot;, &quot;NO&quot;, &quot;POSIX&quot;)&lt;/code&gt; would generate the same list</b>
<b class="nc"><i>2837</i>&nbsp;         * except that locales with &quot;no&quot; would appear before the corresponding</b>
<i>2838</i>&nbsp;         * locales with &quot;nb&quot;.&lt;/li&gt;
<b class="nc"><i>2839</i>&nbsp;         * &lt;/ol&gt;</b>
<b class="nc"><i>2840</i>&nbsp;         *</b>
<i>2841</i>&nbsp;         * &lt;p&gt;The default implementation uses an {@link ArrayList} that
<i>2842</i>&nbsp;         * overriding implementations may modify before returning it to the
<i>2843</i>&nbsp;         * caller. However, a subclass must not modify it after it has
<i>2844</i>&nbsp;         * been returned by &lt;code&gt;getCandidateLocales&lt;/code&gt;.
<i>2845</i>&nbsp;         *
<i>2846</i>&nbsp;         * &lt;p&gt;For example, if the given &lt;code&gt;baseName&lt;/code&gt; is &quot;Messages&quot;
<i>2847</i>&nbsp;         * and the given &lt;code&gt;locale&lt;/code&gt; is
<i>2848</i>&nbsp;         * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then a
<i>2849</i>&nbsp;         * &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Locale&lt;/code&gt;s:
<i>2850</i>&nbsp;         * &lt;pre&gt;
<i>2851</i>&nbsp;         *     Locale(&quot;ja&quot;, &quot;&quot;, &quot;XX&quot;)
<i>2852</i>&nbsp;         *     Locale(&quot;ja&quot;)
<i>2853</i>&nbsp;         *     Locale.ROOT
<i>2854</i>&nbsp;         * &lt;/pre&gt;
<i>2855</i>&nbsp;         * is returned. And if the resource bundles for the &quot;ja&quot; and
<i>2856</i>&nbsp;         * &quot;&quot; &lt;code&gt;Locale&lt;/code&gt;s are found, then the runtime resource
<i>2857</i>&nbsp;         * lookup path (parent chain) is:
<i>2858</i>&nbsp;         * &lt;pre&gt;{@code
<i>2859</i>&nbsp;         *     Messages_ja -&gt; Messages
<i>2860</i>&nbsp;         * }&lt;/pre&gt;
<i>2861</i>&nbsp;         *
<i>2862</i>&nbsp;         * @param baseName
<i>2863</i>&nbsp;         *        the base name of the resource bundle, a fully
<i>2864</i>&nbsp;         *        qualified class name
<i>2865</i>&nbsp;         * @param locale
<i>2866</i>&nbsp;         *        the locale for which a resource bundle is desired
<i>2867</i>&nbsp;         * @return a &lt;code&gt;List&lt;/code&gt; of candidate
<i>2868</i>&nbsp;         *        &lt;code&gt;Locale&lt;/code&gt;s for the given &lt;code&gt;locale&lt;/code&gt;
<i>2869</i>&nbsp;         * @exception NullPointerException
<i>2870</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
<i>2871</i>&nbsp;         *        &lt;code&gt;null&lt;/code&gt;
<i>2872</i>&nbsp;         */
<i>2873</i>&nbsp;        public List&lt;Locale&gt; getCandidateLocales(String baseName, Locale locale) {
<i>2874</i>&nbsp;            if (baseName == null) {
<i>2875</i>&nbsp;                throw new NullPointerException();
<i>2876</i>&nbsp;            }
<i>2877</i>&nbsp;            return new ArrayList&lt;&gt;(CANDIDATES_CACHE.get(locale.getBaseLocale()));
<i>2878</i>&nbsp;        }
<i>2879</i>&nbsp;
<i>2880</i>&nbsp;        private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
<i>2881</i>&nbsp;
<i>2882</i>&nbsp;        private static class CandidateListCache extends LocaleObjectCache&lt;BaseLocale, List&lt;Locale&gt;&gt; {
<i>2883</i>&nbsp;            protected List&lt;Locale&gt; createObject(BaseLocale base) {
<i>2884</i>&nbsp;                String language = base.getLanguage();
<i>2885</i>&nbsp;                String script = base.getScript();
<b class="nc"><i>2886</i>&nbsp;                String region = base.getRegion();</b>
<b class="nc"><i>2887</i>&nbsp;                String variant = base.getVariant();</b>
<i>2888</i>&nbsp;
<i>2889</i>&nbsp;                // Special handling for Norwegian
<b class="nc"><i>2890</i>&nbsp;                boolean isNorwegianBokmal = false;</b>
<b class="nc"><i>2891</i>&nbsp;                boolean isNorwegianNynorsk = false;</b>
<b class="nc"><i>2892</i>&nbsp;                if (language.equals(&quot;no&quot;)) {</b>
<b class="nc"><i>2893</i>&nbsp;                    if (region.equals(&quot;NO&quot;) &amp;&amp; variant.equals(&quot;NY&quot;)) {</b>
<i>2894</i>&nbsp;                        variant = &quot;&quot;;
<b class="nc"><i>2895</i>&nbsp;                        isNorwegianNynorsk = true;</b>
<b class="nc"><i>2896</i>&nbsp;                    } else {</b>
<i>2897</i>&nbsp;                        isNorwegianBokmal = true;
<i>2898</i>&nbsp;                    }
<b class="nc"><i>2899</i>&nbsp;                }</b>
<b class="nc"><i>2900</i>&nbsp;                if (language.equals(&quot;nb&quot;) || isNorwegianBokmal) {</b>
<b class="nc"><i>2901</i>&nbsp;                    List&lt;Locale&gt; tmpList = getDefaultList(&quot;nb&quot;, script, region, variant);</b>
<b class="nc"><i>2902</i>&nbsp;                    // Insert a locale replacing &quot;nb&quot; with &quot;no&quot; for every list entry</b>
<b class="nc"><i>2903</i>&nbsp;                    List&lt;Locale&gt; bokmalList = new LinkedList&lt;&gt;();</b>
<b class="nc"><i>2904</i>&nbsp;                    for (Locale l : tmpList) {</b>
<b class="nc"><i>2905</i>&nbsp;                        bokmalList.add(l);</b>
<i>2906</i>&nbsp;                        if (l.getLanguage().length() == 0) {
<b class="nc"><i>2907</i>&nbsp;                            break;</b>
<i>2908</i>&nbsp;                        }
<i>2909</i>&nbsp;                        bokmalList.add(Locale.getInstance(&quot;no&quot;, l.getScript(), l.getCountry(),
<b class="nc"><i>2910</i>&nbsp;                                l.getVariant(), null));</b>
<b class="nc"><i>2911</i>&nbsp;                    }</b>
<b class="nc"><i>2912</i>&nbsp;                    return bokmalList;</b>
<b class="nc"><i>2913</i>&nbsp;                } else if (language.equals(&quot;nn&quot;) || isNorwegianNynorsk) {</b>
<i>2914</i>&nbsp;                    // Insert no_NO_NY, no_NO, no after nn
<b class="nc"><i>2915</i>&nbsp;                    List&lt;Locale&gt; nynorskList = getDefaultList(&quot;nn&quot;, script, region, variant);</b>
<i>2916</i>&nbsp;                    int idx = nynorskList.size() - 1;
<i>2917</i>&nbsp;                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;NO&quot;, &quot;NY&quot;));
<b class="nc"><i>2918</i>&nbsp;                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;NO&quot;, &quot;&quot;));</b>
<i>2919</i>&nbsp;                    nynorskList.add(idx++, Locale.getInstance(&quot;no&quot;, &quot;&quot;, &quot;&quot;));
<i>2920</i>&nbsp;                    return nynorskList;
<i>2921</i>&nbsp;                }
<i>2922</i>&nbsp;                // Special handling for Chinese
<i>2923</i>&nbsp;                else if (language.equals(&quot;zh&quot;)) {
<i>2924</i>&nbsp;                    if (script.length() == 0 &amp;&amp; region.length() &gt; 0) {
<i>2925</i>&nbsp;                        // Supply script for users who want to use zh_Hans/zh_Hant
<i>2926</i>&nbsp;                        // as bundle names (recommended for Java7+)
<i>2927</i>&nbsp;                        switch (region) {
<i>2928</i>&nbsp;                        case &quot;TW&quot;:
<i>2929</i>&nbsp;                        case &quot;HK&quot;:
<i>2930</i>&nbsp;                        case &quot;MO&quot;:
<i>2931</i>&nbsp;                            script = &quot;Hant&quot;;
<i>2932</i>&nbsp;                            break;
<i>2933</i>&nbsp;                        case &quot;CN&quot;:
<i>2934</i>&nbsp;                        case &quot;SG&quot;:
<i>2935</i>&nbsp;                            script = &quot;Hans&quot;;
<i>2936</i>&nbsp;                            break;
<i>2937</i>&nbsp;                        }
<i>2938</i>&nbsp;                    }
<i>2939</i>&nbsp;                }
<i>2940</i>&nbsp;
<i>2941</i>&nbsp;                return getDefaultList(language, script, region, variant);
<i>2942</i>&nbsp;            }
<b class="nc"><i>2943</i>&nbsp;</b>
<b class="nc"><i>2944</i>&nbsp;            private static List&lt;Locale&gt; getDefaultList(String language, String script, String region, String variant) {</b>
<b class="nc"><i>2945</i>&nbsp;                List&lt;String&gt; variants = null;</b>
<i>2946</i>&nbsp;
<i>2947</i>&nbsp;                if (variant.length() &gt; 0) {
<i>2948</i>&nbsp;                    variants = new LinkedList&lt;&gt;();
<i>2949</i>&nbsp;                    int idx = variant.length();
<b class="nc"><i>2950</i>&nbsp;                    while (idx != -1) {</b>
<b class="nc"><i>2951</i>&nbsp;                        variants.add(variant.substring(0, idx));</b>
<i>2952</i>&nbsp;                        idx = variant.lastIndexOf(&#39;_&#39;, --idx);
<b class="nc"><i>2953</i>&nbsp;                    }</b>
<i>2954</i>&nbsp;                }
<i>2955</i>&nbsp;
<i>2956</i>&nbsp;                List&lt;Locale&gt; list = new LinkedList&lt;&gt;();
<i>2957</i>&nbsp;
<b class="nc"><i>2958</i>&nbsp;                if (variants != null) {</b>
<b class="nc"><i>2959</i>&nbsp;                    for (String v : variants) {</b>
<i>2960</i>&nbsp;                        list.add(Locale.getInstance(language, script, region, v, null));
<i>2961</i>&nbsp;                    }
<b class="nc"><i>2962</i>&nbsp;                }</b>
<i>2963</i>&nbsp;                if (region.length() &gt; 0) {
<i>2964</i>&nbsp;                    list.add(Locale.getInstance(language, script, region, &quot;&quot;, null));
<i>2965</i>&nbsp;                }
<i>2966</i>&nbsp;                if (script.length() &gt; 0) {
<b class="nc"><i>2967</i>&nbsp;                    list.add(Locale.getInstance(language, script, &quot;&quot;, &quot;&quot;, null));</b>
<b class="nc"><i>2968</i>&nbsp;                    // Special handling for Chinese</b>
<i>2969</i>&nbsp;                    if (language.equals(&quot;zh&quot;)) {
<i>2970</i>&nbsp;                        if (region.length() == 0) {
<i>2971</i>&nbsp;                            // Supply region(country) for users who still package Chinese
<b class="nc"><i>2972</i>&nbsp;                            // bundles using old convension.</b>
<b class="nc"><i>2973</i>&nbsp;                            switch (script) {</b>
<i>2974</i>&nbsp;                                case &quot;Hans&quot;:
<b class="nc"><i>2975</i>&nbsp;                                    region = &quot;CN&quot;;</b>
<i>2976</i>&nbsp;                                    break;
<i>2977</i>&nbsp;                                case &quot;Hant&quot;:
<i>2978</i>&nbsp;                                    region = &quot;TW&quot;;
<b class="nc"><i>2979</i>&nbsp;                                    break;</b>
<b class="nc"><i>2980</i>&nbsp;                            }</b>
<i>2981</i>&nbsp;                        }
<i>2982</i>&nbsp;                    }
<b class="nc"><i>2983</i>&nbsp;</b>
<i>2984</i>&nbsp;                    // With script, after truncating variant, region and script,
<i>2985</i>&nbsp;                    // start over without script.
<b class="nc"><i>2986</i>&nbsp;                    if (variants != null) {</b>
<i>2987</i>&nbsp;                        for (String v : variants) {
<i>2988</i>&nbsp;                            list.add(Locale.getInstance(language, &quot;&quot;, region, v, null));
<i>2989</i>&nbsp;                        }
<b class="nc"><i>2990</i>&nbsp;                    }</b>
<i>2991</i>&nbsp;                    if (region.length() &gt; 0) {
<i>2992</i>&nbsp;                        list.add(Locale.getInstance(language, &quot;&quot;, region, &quot;&quot;, null));
<i>2993</i>&nbsp;                    }
<b class="nc"><i>2994</i>&nbsp;                }</b>
<b class="nc"><i>2995</i>&nbsp;                if (language.length() &gt; 0) {</b>
<i>2996</i>&nbsp;                    list.add(Locale.getInstance(language, &quot;&quot;, &quot;&quot;, &quot;&quot;, null));
<b class="nc"><i>2997</i>&nbsp;                }</b>
<i>2998</i>&nbsp;                // Add root locale at the end
<i>2999</i>&nbsp;                list.add(Locale.ROOT);
<i>3000</i>&nbsp;
<i>3001</i>&nbsp;                return list;
<i>3002</i>&nbsp;            }
<i>3003</i>&nbsp;        }
<i>3004</i>&nbsp;
<i>3005</i>&nbsp;        /**
<i>3006</i>&nbsp;         * Returns a &lt;code&gt;Locale&lt;/code&gt; to be used as a fallback locale for
<i>3007</i>&nbsp;         * further resource bundle searches by the
<i>3008</i>&nbsp;         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method. This method
<i>3009</i>&nbsp;         * is called from the factory method every time when no resulting
<i>3010</i>&nbsp;         * resource bundle has been found for &lt;code&gt;baseName&lt;/code&gt; and
<i>3011</i>&nbsp;         * &lt;code&gt;locale&lt;/code&gt;, where locale is either the parameter for
<i>3012</i>&nbsp;         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; or the previous fallback
<i>3013</i>&nbsp;         * locale returned by this method.
<i>3014</i>&nbsp;         *
<i>3015</i>&nbsp;         * &lt;p&gt;The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback
<i>3016</i>&nbsp;         * search is desired.
<i>3017</i>&nbsp;         *
<i>3018</i>&nbsp;         * &lt;p&gt;The default implementation returns the {@linkplain
<i>3019</i>&nbsp;         * Locale#getDefault() default &lt;code&gt;Locale&lt;/code&gt;} if the given
<i>3020</i>&nbsp;         * &lt;code&gt;locale&lt;/code&gt; isn&#39;t the default one.  Otherwise,
<i>3021</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt; is returned.
<i>3022</i>&nbsp;         *
<i>3023</i>&nbsp;         * @param baseName
<i>3024</i>&nbsp;         *        the base name of the resource bundle, a fully
<i>3025</i>&nbsp;         *        qualified class name for which
<i>3026</i>&nbsp;         *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
<i>3027</i>&nbsp;         *        unable to find any resource bundles (except for the
<i>3028</i>&nbsp;         *        base bundle)
<i>3029</i>&nbsp;         * @param locale
<i>3030</i>&nbsp;         *        the &lt;code&gt;Locale&lt;/code&gt; for which
<i>3031</i>&nbsp;         *        &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; has been
<i>3032</i>&nbsp;         *        unable to find any resource bundles (except for the
<i>3033</i>&nbsp;         *        base bundle)
<i>3034</i>&nbsp;         * @return a &lt;code&gt;Locale&lt;/code&gt; for the fallback search,
<i>3035</i>&nbsp;         *        or &lt;code&gt;null&lt;/code&gt; if no further fallback search
<i>3036</i>&nbsp;         *        is desired.
<i>3037</i>&nbsp;         * @exception NullPointerException
<i>3038</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
<i>3039</i>&nbsp;         *        is &lt;code&gt;null&lt;/code&gt;
<i>3040</i>&nbsp;         */
<i>3041</i>&nbsp;        public Locale getFallbackLocale(String baseName, Locale locale) {
<i>3042</i>&nbsp;            if (baseName == null) {
<i>3043</i>&nbsp;                throw new NullPointerException();
<i>3044</i>&nbsp;            }
<i>3045</i>&nbsp;            Locale defaultLocale = Locale.getDefault();
<i>3046</i>&nbsp;            return locale.equals(defaultLocale) ? null : defaultLocale;
<i>3047</i>&nbsp;        }
<i>3048</i>&nbsp;
<i>3049</i>&nbsp;        /**
<i>3050</i>&nbsp;         * Instantiates a resource bundle for the given bundle name of the
<i>3051</i>&nbsp;         * given format and locale, using the given class loader if
<i>3052</i>&nbsp;         * necessary. This method returns &lt;code&gt;null&lt;/code&gt; if there is no
<i>3053</i>&nbsp;         * resource bundle available for the given parameters. If a resource
<i>3054</i>&nbsp;         * bundle can&#39;t be instantiated due to an unexpected error, the
<i>3055</i>&nbsp;         * error must be reported by throwing an &lt;code&gt;Error&lt;/code&gt; or
<i>3056</i>&nbsp;         * &lt;code&gt;Exception&lt;/code&gt; rather than simply returning
<i>3057</i>&nbsp;         * &lt;code&gt;null&lt;/code&gt;.
<i>3058</i>&nbsp;         *
<i>3059</i>&nbsp;         * &lt;p&gt;If the &lt;code&gt;reload&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, it
<i>3060</i>&nbsp;         * indicates that this method is being called because the previously
<i>3061</i>&nbsp;         * loaded resource bundle has expired.
<i>3062</i>&nbsp;         *
<i>3063</i>&nbsp;         * @implSpec
<i>3064</i>&nbsp;         *
<i>3065</i>&nbsp;         * Resource bundles in named modules are subject to the encapsulation
<i>3066</i>&nbsp;         * rules specified by {@link Module#getResourceAsStream Module.getResourceAsStream}.
<i>3067</i>&nbsp;         * A resource bundle in a named module visible to the given class loader
<i>3068</i>&nbsp;         * is accessible when the package of the resource file corresponding
<i>3069</i>&nbsp;         * to the resource bundle is open unconditionally.
<i>3070</i>&nbsp;         *
<i>3071</i>&nbsp;         * &lt;p&gt;The default implementation instantiates a
<i>3072</i>&nbsp;         * &lt;code&gt;ResourceBundle&lt;/code&gt; as follows.
<i>3073</i>&nbsp;         *
<i>3074</i>&nbsp;         * &lt;ul&gt;
<i>3075</i>&nbsp;         *
<i>3076</i>&nbsp;         * &lt;li&gt;The bundle name is obtained by calling {@link
<i>3077</i>&nbsp;         * #toBundleName(String, Locale) toBundleName(baseName,
<i>3078</i>&nbsp;         * locale)}.&lt;/li&gt;
<i>3079</i>&nbsp;         *
<i>3080</i>&nbsp;         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;, the
<i>3081</i>&nbsp;         * {@link Class} specified by the bundle name is loaded with the
<i>3082</i>&nbsp;         * given class loader. If the {@code Class} is found and accessible
<i>3083</i>&nbsp;         * then the &lt;code&gt;ResourceBundle&lt;/code&gt; is instantiated.  The
<i>3084</i>&nbsp;         * resource bundle is accessible if the package of the bundle class file
<i>3085</i>&nbsp;         * is open unconditionally; otherwise, {@code IllegalAccessException}
<i>3086</i>&nbsp;         * will be thrown.
<i>3087</i>&nbsp;         * Note that the &lt;code&gt;reload&lt;/code&gt; flag is ignored for loading
<i>3088</i>&nbsp;         * class-based resource bundles in this default implementation.
<i>3089</i>&nbsp;         * &lt;/li&gt;
<i>3090</i>&nbsp;         *
<i>3091</i>&nbsp;         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;,
<i>3092</i>&nbsp;         * {@link #toResourceName(String, String) toResourceName(bundlename,
<i>3093</i>&nbsp;         * &quot;properties&quot;)} is called to get the resource name.
<i>3094</i>&nbsp;         * If &lt;code&gt;reload&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, {@link
<i>3095</i>&nbsp;         * ClassLoader#getResource(String) load.getResource} is called
<i>3096</i>&nbsp;         * to get a {@link URL} for creating a {@link
<i>3097</i>&nbsp;         * URLConnection}. This &lt;code&gt;URLConnection&lt;/code&gt; is used to
<i>3098</i>&nbsp;         * {@linkplain URLConnection#setUseCaches(boolean) disable the
<i>3099</i>&nbsp;         * caches} of the underlying resource loading layers,
<i>3100</i>&nbsp;         * and to {@linkplain URLConnection#getInputStream() get an
<i>3101</i>&nbsp;         * &lt;code&gt;InputStream&lt;/code&gt;}.
<i>3102</i>&nbsp;         * Otherwise, {@link ClassLoader#getResourceAsStream(String)
<i>3103</i>&nbsp;         * loader.getResourceAsStream} is called to get an {@link
<i>3104</i>&nbsp;         * InputStream}. Then, a {@link
<i>3105</i>&nbsp;         * PropertyResourceBundle} is constructed with the
<i>3106</i>&nbsp;         * &lt;code&gt;InputStream&lt;/code&gt;.&lt;/li&gt;
<i>3107</i>&nbsp;         *
<i>3108</i>&nbsp;         * &lt;li&gt;If &lt;code&gt;format&lt;/code&gt; is neither &lt;code&gt;&quot;java.class&quot;&lt;/code&gt;
<i>3109</i>&nbsp;         * nor &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;, an
<i>3110</i>&nbsp;         * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.&lt;/li&gt;
<i>3111</i>&nbsp;         *
<i>3112</i>&nbsp;         * &lt;/ul&gt;
<i>3113</i>&nbsp;         *
<i>3114</i>&nbsp;         * @param baseName
<i>3115</i>&nbsp;         *        the base bundle name of the resource bundle, a fully
<i>3116</i>&nbsp;         *        qualified class name
<i>3117</i>&nbsp;         * @param locale
<i>3118</i>&nbsp;         *        the locale for which the resource bundle should be
<i>3119</i>&nbsp;         *        instantiated
<i>3120</i>&nbsp;         * @param format
<i>3121</i>&nbsp;         *        the resource bundle format to be loaded
<i>3122</i>&nbsp;         * @param loader
<i>3123</i>&nbsp;         *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle
<i>3124</i>&nbsp;         * @param reload
<i>3125</i>&nbsp;         *        the flag to indicate bundle reloading; &lt;code&gt;true&lt;/code&gt;
<i>3126</i>&nbsp;         *        if reloading an expired resource bundle,
<i>3127</i>&nbsp;         *        &lt;code&gt;false&lt;/code&gt; otherwise
<i>3128</i>&nbsp;         * @return the resource bundle instance,
<i>3129</i>&nbsp;         *        or &lt;code&gt;null&lt;/code&gt; if none could be found.
<i>3130</i>&nbsp;         * @exception NullPointerException
<i>3131</i>&nbsp;         *        if &lt;code&gt;bundleName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
<i>3132</i>&nbsp;         *        &lt;code&gt;format&lt;/code&gt;, or &lt;code&gt;loader&lt;/code&gt; is
<i>3133</i>&nbsp;         *        &lt;code&gt;null&lt;/code&gt;, or if &lt;code&gt;null&lt;/code&gt; is returned by
<i>3134</i>&nbsp;         *        {@link #toBundleName(String, Locale) toBundleName}
<i>3135</i>&nbsp;         * @exception IllegalArgumentException
<i>3136</i>&nbsp;         *        if &lt;code&gt;format&lt;/code&gt; is unknown, or if the resource
<i>3137</i>&nbsp;         *        found for the given parameters contains malformed data.
<i>3138</i>&nbsp;         * @exception ClassCastException
<i>3139</i>&nbsp;         *        if the loaded class cannot be cast to &lt;code&gt;ResourceBundle&lt;/code&gt;
<i>3140</i>&nbsp;         * @exception IllegalAccessException
<i>3141</i>&nbsp;         *        if the class or its nullary constructor is not
<i>3142</i>&nbsp;         *        accessible.
<i>3143</i>&nbsp;         * @exception InstantiationException
<i>3144</i>&nbsp;         *        if the instantiation of a class fails for some other
<i>3145</i>&nbsp;         *        reason.
<i>3146</i>&nbsp;         * @exception ExceptionInInitializerError
<i>3147</i>&nbsp;         *        if the initialization provoked by this method fails.
<i>3148</i>&nbsp;         * @exception SecurityException
<i>3149</i>&nbsp;         *        If a security manager is present and creation of new
<i>3150</i>&nbsp;         *        instances is denied. See {@link Class#newInstance()}
<i>3151</i>&nbsp;         *        for details.
<i>3152</i>&nbsp;         * @exception IOException
<i>3153</i>&nbsp;         *        if an error occurred when reading resources using
<i>3154</i>&nbsp;         *        any I/O operations
<i>3155</i>&nbsp;         * @see java.util.spi.ResourceBundleProvider#getBundle(String, Locale)
<i>3156</i>&nbsp;         * @revised 9
<i>3157</i>&nbsp;         * @spec JPMS
<i>3158</i>&nbsp;         */
<i>3159</i>&nbsp;        public ResourceBundle newBundle(String baseName, Locale locale, String format,
<i>3160</i>&nbsp;                                        ClassLoader loader, boolean reload)
<i>3161</i>&nbsp;                    throws IllegalAccessException, InstantiationException, IOException {
<i>3162</i>&nbsp;            /*
<i>3163</i>&nbsp;             * Legacy mechanism to locate resource bundle in unnamed module only
<i>3164</i>&nbsp;             * that is visible to the given loader and accessible to the given caller.
<i>3165</i>&nbsp;             */
<i>3166</i>&nbsp;            String bundleName = toBundleName(baseName, locale);
<i>3167</i>&nbsp;            ResourceBundle bundle = null;
<i>3168</i>&nbsp;            if (format.equals(&quot;java.class&quot;)) {
<i>3169</i>&nbsp;                try {
<i>3170</i>&nbsp;                    Class&lt;?&gt; c = loader.loadClass(bundleName);
<i>3171</i>&nbsp;                    // If the class isn&#39;t a ResourceBundle subclass, throw a
<i>3172</i>&nbsp;                    // ClassCastException.
<i>3173</i>&nbsp;                    if (ResourceBundle.class.isAssignableFrom(c)) {
<i>3174</i>&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
<i>3175</i>&nbsp;                        Class&lt;ResourceBundle&gt; bundleClass = (Class&lt;ResourceBundle&gt;)c;
<i>3176</i>&nbsp;                        Module m = bundleClass.getModule();
<i>3177</i>&nbsp;
<i>3178</i>&nbsp;                        // To access a resource bundle in a named module,
<i>3179</i>&nbsp;                        // either class-based or properties-based, the resource
<i>3180</i>&nbsp;                        // bundle must be opened unconditionally,
<i>3181</i>&nbsp;                        // same rule as accessing a resource file.
<i>3182</i>&nbsp;                        if (m.isNamed() &amp;&amp; !m.isOpen(bundleClass.getPackageName())) {
<i>3183</i>&nbsp;                            throw new IllegalAccessException(&quot;unnamed module can&#39;t load &quot; +
<i>3184</i>&nbsp;                                bundleClass.getName() + &quot; in &quot; + m.toString());
<i>3185</i>&nbsp;                        }
<i>3186</i>&nbsp;                        try {
<i>3187</i>&nbsp;                            // bundle in a unnamed module
<i>3188</i>&nbsp;                            Constructor&lt;ResourceBundle&gt; ctor = bundleClass.getConstructor();
<i>3189</i>&nbsp;                            if (!Modifier.isPublic(ctor.getModifiers())) {
<i>3190</i>&nbsp;                                return null;
<i>3191</i>&nbsp;                            }
<i>3192</i>&nbsp;
<i>3193</i>&nbsp;                            // java.base may not be able to read the bundleClass&#39;s module.
<i>3194</i>&nbsp;                            PrivilegedAction&lt;Void&gt; pa1 = () -&gt; { ctor.setAccessible(true); return null; };
<i>3195</i>&nbsp;                            AccessController.doPrivileged(pa1);
<i>3196</i>&nbsp;                            bundle = ctor.newInstance((Object[]) null);
<i>3197</i>&nbsp;                        } catch (InvocationTargetException e) {
<i>3198</i>&nbsp;                            uncheckedThrow(e);
<i>3199</i>&nbsp;                        }
<i>3200</i>&nbsp;                    } else {
<i>3201</i>&nbsp;                        throw new ClassCastException(c.getName()
<i>3202</i>&nbsp;                                + &quot; cannot be cast to ResourceBundle&quot;);
<i>3203</i>&nbsp;                    }
<i>3204</i>&nbsp;                } catch (ClassNotFoundException|NoSuchMethodException e) {
<i>3205</i>&nbsp;                }
<i>3206</i>&nbsp;            } else if (format.equals(&quot;java.properties&quot;)) {
<i>3207</i>&nbsp;                final String resourceName = toResourceName0(bundleName, &quot;properties&quot;);
<i>3208</i>&nbsp;                if (resourceName == null) {
<i>3209</i>&nbsp;                    return bundle;
<i>3210</i>&nbsp;                }
<i>3211</i>&nbsp;
<i>3212</i>&nbsp;                final boolean reloadFlag = reload;
<i>3213</i>&nbsp;                InputStream stream = null;
<i>3214</i>&nbsp;                try {
<i>3215</i>&nbsp;                    stream = AccessController.doPrivileged(
<i>3216</i>&nbsp;                        new PrivilegedExceptionAction&lt;&gt;() {
<i>3217</i>&nbsp;                            public InputStream run() throws IOException {
<i>3218</i>&nbsp;                                URL url = loader.getResource(resourceName);
<i>3219</i>&nbsp;                                if (url == null) return null;
<i>3220</i>&nbsp;
<i>3221</i>&nbsp;                                URLConnection connection = url.openConnection();
<i>3222</i>&nbsp;                                if (reloadFlag) {
<i>3223</i>&nbsp;                                    // Disable caches to get fresh data for
<i>3224</i>&nbsp;                                    // reloading.
<i>3225</i>&nbsp;                                    connection.setUseCaches(false);
<i>3226</i>&nbsp;                                }
<i>3227</i>&nbsp;                                return connection.getInputStream();
<i>3228</i>&nbsp;                            }
<i>3229</i>&nbsp;                        });
<i>3230</i>&nbsp;                } catch (PrivilegedActionException e) {
<i>3231</i>&nbsp;                    throw (IOException) e.getException();
<i>3232</i>&nbsp;                }
<i>3233</i>&nbsp;                if (stream != null) {
<i>3234</i>&nbsp;                    try {
<i>3235</i>&nbsp;                        bundle = new PropertyResourceBundle(stream);
<i>3236</i>&nbsp;                    } finally {
<i>3237</i>&nbsp;                        stream.close();
<i>3238</i>&nbsp;                    }
<i>3239</i>&nbsp;                }
<i>3240</i>&nbsp;            } else {
<i>3241</i>&nbsp;                throw new IllegalArgumentException(&quot;unknown format: &quot; + format);
<i>3242</i>&nbsp;            }
<i>3243</i>&nbsp;            return bundle;
<i>3244</i>&nbsp;        }
<i>3245</i>&nbsp;
<i>3246</i>&nbsp;        /**
<i>3247</i>&nbsp;         * Returns the time-to-live (TTL) value for resource bundles that
<i>3248</i>&nbsp;         * are loaded under this
<i>3249</i>&nbsp;         * &lt;code&gt;ResourceBundle.Control&lt;/code&gt;. Positive time-to-live values
<i>3250</i>&nbsp;         * specify the number of milliseconds a bundle can remain in the
<i>3251</i>&nbsp;         * cache without being validated against the source data from which
<i>3252</i>&nbsp;         * it was constructed. The value 0 indicates that a bundle must be
<i>3253</i>&nbsp;         * validated each time it is retrieved from the cache. {@link
<i>3254</i>&nbsp;         * #TTL_DONT_CACHE} specifies that loaded resource bundles are not
<i>3255</i>&nbsp;         * put in the cache. {@link #TTL_NO_EXPIRATION_CONTROL} specifies
<i>3256</i>&nbsp;         * that loaded resource bundles are put in the cache with no
<i>3257</i>&nbsp;         * expiration control.
<i>3258</i>&nbsp;         *
<i>3259</i>&nbsp;         * &lt;p&gt;The expiration affects only the bundle loading process by the
<i>3260</i>&nbsp;         * &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method.  That is,
<i>3261</i>&nbsp;         * if the factory method finds a resource bundle in the cache that
<i>3262</i>&nbsp;         * has expired, the factory method calls the {@link
<i>3263</i>&nbsp;         * #needsReload(String, Locale, String, ClassLoader, ResourceBundle,
<i>3264</i>&nbsp;         * long) needsReload} method to determine whether the resource
<i>3265</i>&nbsp;         * bundle needs to be reloaded. If &lt;code&gt;needsReload&lt;/code&gt; returns
<i>3266</i>&nbsp;         * &lt;code&gt;true&lt;/code&gt;, the cached resource bundle instance is removed
<i>3267</i>&nbsp;         * from the cache. Otherwise, the instance stays in the cache,
<i>3268</i>&nbsp;         * updated with the new TTL value returned by this method.
<i>3269</i>&nbsp;         *
<i>3270</i>&nbsp;         * &lt;p&gt;All cached resource bundles are subject to removal from the
<i>3271</i>&nbsp;         * cache due to memory constraints of the runtime environment.
<i>3272</i>&nbsp;         * Returning a large positive value doesn&#39;t mean to lock loaded
<i>3273</i>&nbsp;         * resource bundles in the cache.
<i>3274</i>&nbsp;         *
<i>3275</i>&nbsp;         * &lt;p&gt;The default implementation returns {@link #TTL_NO_EXPIRATION_CONTROL}.
<i>3276</i>&nbsp;         *
<i>3277</i>&nbsp;         * @param baseName
<i>3278</i>&nbsp;         *        the base name of the resource bundle for which the
<i>3279</i>&nbsp;         *        expiration value is specified.
<i>3280</i>&nbsp;         * @param locale
<i>3281</i>&nbsp;         *        the locale of the resource bundle for which the
<i>3282</i>&nbsp;         *        expiration value is specified.
<i>3283</i>&nbsp;         * @return the time (0 or a positive millisecond offset from the
<i>3284</i>&nbsp;         *        cached time) to get loaded bundles expired in the cache,
<i>3285</i>&nbsp;         *        {@link #TTL_NO_EXPIRATION_CONTROL} to disable the
<i>3286</i>&nbsp;         *        expiration control, or {@link #TTL_DONT_CACHE} to disable
<i>3287</i>&nbsp;         *        caching.
<i>3288</i>&nbsp;         * @exception NullPointerException
<i>3289</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt; is
<i>3290</i>&nbsp;         *        &lt;code&gt;null&lt;/code&gt;
<i>3291</i>&nbsp;         */
<i>3292</i>&nbsp;        public long getTimeToLive(String baseName, Locale locale) {
<i>3293</i>&nbsp;            if (baseName == null || locale == null) {
<i>3294</i>&nbsp;                throw new NullPointerException();
<i>3295</i>&nbsp;            }
<i>3296</i>&nbsp;            return TTL_NO_EXPIRATION_CONTROL;
<i>3297</i>&nbsp;        }
<i>3298</i>&nbsp;
<i>3299</i>&nbsp;        /**
<i>3300</i>&nbsp;         * Determines if the expired &lt;code&gt;bundle&lt;/code&gt; in the cache needs
<i>3301</i>&nbsp;         * to be reloaded based on the loading time given by
<i>3302</i>&nbsp;         * &lt;code&gt;loadTime&lt;/code&gt; or some other criteria. The method returns
<i>3303</i>&nbsp;         * &lt;code&gt;true&lt;/code&gt; if reloading is required; &lt;code&gt;false&lt;/code&gt;
<i>3304</i>&nbsp;         * otherwise. &lt;code&gt;loadTime&lt;/code&gt; is a millisecond offset since
<i>3305</i>&nbsp;         * the &lt;a href=&quot;Calendar.html#Epoch&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt;
<i>3306</i>&nbsp;         * Epoch&lt;/a&gt;.
<i>3307</i>&nbsp;         *
<i>3308</i>&nbsp;         * &lt;p&gt;
<i>3309</i>&nbsp;         * The calling &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory method
<i>3310</i>&nbsp;         * calls this method on the &lt;code&gt;ResourceBundle.Control&lt;/code&gt;
<i>3311</i>&nbsp;         * instance used for its current invocation, not on the instance
<i>3312</i>&nbsp;         * used in the invocation that originally loaded the resource
<i>3313</i>&nbsp;         * bundle.
<i>3314</i>&nbsp;         *
<i>3315</i>&nbsp;         * &lt;p&gt;The default implementation compares &lt;code&gt;loadTime&lt;/code&gt; and
<i>3316</i>&nbsp;         * the last modified time of the source data of the resource
<i>3317</i>&nbsp;         * bundle. If it&#39;s determined that the source data has been modified
<i>3318</i>&nbsp;         * since &lt;code&gt;loadTime&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is
<i>3319</i>&nbsp;         * returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. This
<i>3320</i>&nbsp;         * implementation assumes that the given &lt;code&gt;format&lt;/code&gt; is the
<i>3321</i>&nbsp;         * same string as its file suffix if it&#39;s not one of the default
<i>3322</i>&nbsp;         * formats, &lt;code&gt;&quot;java.class&quot;&lt;/code&gt; or
<i>3323</i>&nbsp;         * &lt;code&gt;&quot;java.properties&quot;&lt;/code&gt;.
<i>3324</i>&nbsp;         *
<i>3325</i>&nbsp;         * @param baseName
<i>3326</i>&nbsp;         *        the base bundle name of the resource bundle, a
<i>3327</i>&nbsp;         *        fully qualified class name
<i>3328</i>&nbsp;         * @param locale
<i>3329</i>&nbsp;         *        the locale for which the resource bundle
<i>3330</i>&nbsp;         *        should be instantiated
<i>3331</i>&nbsp;         * @param format
<i>3332</i>&nbsp;         *        the resource bundle format to be loaded
<i>3333</i>&nbsp;         * @param loader
<i>3334</i>&nbsp;         *        the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the bundle
<i>3335</i>&nbsp;         * @param bundle
<i>3336</i>&nbsp;         *        the resource bundle instance that has been expired
<i>3337</i>&nbsp;         *        in the cache
<i>3338</i>&nbsp;         * @param loadTime
<i>3339</i>&nbsp;         *        the time when &lt;code&gt;bundle&lt;/code&gt; was loaded and put
<i>3340</i>&nbsp;         *        in the cache
<i>3341</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if the expired bundle needs to be
<i>3342</i>&nbsp;         *        reloaded; &lt;code&gt;false&lt;/code&gt; otherwise.
<i>3343</i>&nbsp;         * @exception NullPointerException
<i>3344</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt;, &lt;code&gt;locale&lt;/code&gt;,
<i>3345</i>&nbsp;         *        &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;loader&lt;/code&gt;, or
<i>3346</i>&nbsp;         *        &lt;code&gt;bundle&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>3347</i>&nbsp;         */
<i>3348</i>&nbsp;        public boolean needsReload(String baseName, Locale locale,
<i>3349</i>&nbsp;                                   String format, ClassLoader loader,
<i>3350</i>&nbsp;                                   ResourceBundle bundle, long loadTime) {
<i>3351</i>&nbsp;            if (bundle == null) {
<i>3352</i>&nbsp;                throw new NullPointerException();
<i>3353</i>&nbsp;            }
<i>3354</i>&nbsp;            if (format.equals(&quot;java.class&quot;) || format.equals(&quot;java.properties&quot;)) {
<i>3355</i>&nbsp;                format = format.substring(5);
<i>3356</i>&nbsp;            }
<i>3357</i>&nbsp;            boolean result = false;
<i>3358</i>&nbsp;            try {
<i>3359</i>&nbsp;                String resourceName = toResourceName0(toBundleName(baseName, locale), format);
<i>3360</i>&nbsp;                if (resourceName == null) {
<i>3361</i>&nbsp;                    return result;
<i>3362</i>&nbsp;                }
<i>3363</i>&nbsp;                URL url = loader.getResource(resourceName);
<i>3364</i>&nbsp;                if (url != null) {
<i>3365</i>&nbsp;                    long lastModified = 0;
<i>3366</i>&nbsp;                    URLConnection connection = url.openConnection();
<i>3367</i>&nbsp;                    if (connection != null) {
<i>3368</i>&nbsp;                        // disable caches to get the correct data
<i>3369</i>&nbsp;                        connection.setUseCaches(false);
<i>3370</i>&nbsp;                        if (connection instanceof JarURLConnection) {
<i>3371</i>&nbsp;                            JarEntry ent = ((JarURLConnection)connection).getJarEntry();
<i>3372</i>&nbsp;                            if (ent != null) {
<i>3373</i>&nbsp;                                lastModified = ent.getTime();
<i>3374</i>&nbsp;                                if (lastModified == -1) {
<i>3375</i>&nbsp;                                    lastModified = 0;
<i>3376</i>&nbsp;                                }
<i>3377</i>&nbsp;                            }
<i>3378</i>&nbsp;                        } else {
<i>3379</i>&nbsp;                            lastModified = connection.getLastModified();
<i>3380</i>&nbsp;                        }
<i>3381</i>&nbsp;                    }
<i>3382</i>&nbsp;                    result = lastModified &gt;= loadTime;
<i>3383</i>&nbsp;                }
<i>3384</i>&nbsp;            } catch (NullPointerException npe) {
<i>3385</i>&nbsp;                throw npe;
<i>3386</i>&nbsp;            } catch (Exception e) {
<i>3387</i>&nbsp;                // ignore other exceptions
<i>3388</i>&nbsp;            }
<i>3389</i>&nbsp;            return result;
<i>3390</i>&nbsp;        }
<i>3391</i>&nbsp;
<i>3392</i>&nbsp;        /**
<i>3393</i>&nbsp;         * Converts the given &lt;code&gt;baseName&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt;
<i>3394</i>&nbsp;         * to the bundle name. This method is called from the default
<i>3395</i>&nbsp;         * implementation of the {@link #newBundle(String, Locale, String,
<i>3396</i>&nbsp;         * ClassLoader, boolean) newBundle} and {@link #needsReload(String,
<i>3397</i>&nbsp;         * Locale, String, ClassLoader, ResourceBundle, long) needsReload}
<i>3398</i>&nbsp;         * methods.
<i>3399</i>&nbsp;         *
<i>3400</i>&nbsp;         * &lt;p&gt;This implementation returns the following value:
<i>3401</i>&nbsp;         * &lt;pre&gt;
<i>3402</i>&nbsp;         *     baseName + &quot;_&quot; + language + &quot;_&quot; + script + &quot;_&quot; + country + &quot;_&quot; + variant
<i>3403</i>&nbsp;         * &lt;/pre&gt;
<i>3404</i>&nbsp;         * where &lt;code&gt;language&lt;/code&gt;, &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;country&lt;/code&gt;,
<i>3405</i>&nbsp;         * and &lt;code&gt;variant&lt;/code&gt; are the language, script, country, and variant
<i>3406</i>&nbsp;         * values of &lt;code&gt;locale&lt;/code&gt;, respectively. Final component values that
<i>3407</i>&nbsp;         * are empty Strings are omitted along with the preceding &#39;_&#39;.  When the
<i>3408</i>&nbsp;         * script is empty, the script value is omitted along with the preceding &#39;_&#39;.
<i>3409</i>&nbsp;         * If all of the values are empty strings, then &lt;code&gt;baseName&lt;/code&gt;
<i>3410</i>&nbsp;         * is returned.
<i>3411</i>&nbsp;         *
<i>3412</i>&nbsp;         * &lt;p&gt;For example, if &lt;code&gt;baseName&lt;/code&gt; is
<i>3413</i>&nbsp;         * &lt;code&gt;&quot;baseName&quot;&lt;/code&gt; and &lt;code&gt;locale&lt;/code&gt; is
<i>3414</i>&nbsp;         * &lt;code&gt;Locale(&quot;ja&quot;,&amp;nbsp;&quot;&quot;,&amp;nbsp;&quot;XX&quot;)&lt;/code&gt;, then
<i>3415</i>&nbsp;         * &lt;code&gt;&quot;baseName_ja_&amp;thinsp;_XX&quot;&lt;/code&gt; is returned. If the given
<i>3416</i>&nbsp;         * locale is &lt;code&gt;Locale(&quot;en&quot;)&lt;/code&gt;, then
<i>3417</i>&nbsp;         * &lt;code&gt;&quot;baseName_en&quot;&lt;/code&gt; is returned.
<i>3418</i>&nbsp;         *
<i>3419</i>&nbsp;         * &lt;p&gt;Overriding this method allows applications to use different
<i>3420</i>&nbsp;         * conventions in the organization and packaging of localized
<i>3421</i>&nbsp;         * resources.
<i>3422</i>&nbsp;         *
<i>3423</i>&nbsp;         * @param baseName
<i>3424</i>&nbsp;         *        the base name of the resource bundle, a fully
<i>3425</i>&nbsp;         *        qualified class name
<i>3426</i>&nbsp;         * @param locale
<i>3427</i>&nbsp;         *        the locale for which a resource bundle should be
<i>3428</i>&nbsp;         *        loaded
<i>3429</i>&nbsp;         * @return the bundle name for the resource bundle
<i>3430</i>&nbsp;         * @exception NullPointerException
<i>3431</i>&nbsp;         *        if &lt;code&gt;baseName&lt;/code&gt; or &lt;code&gt;locale&lt;/code&gt;
<i>3432</i>&nbsp;         *        is &lt;code&gt;null&lt;/code&gt;
<i>3433</i>&nbsp;         * @see java.util.spi.AbstractResourceBundleProvider#toBundleName(String, Locale)
<i>3434</i>&nbsp;         */
<i>3435</i>&nbsp;        public String toBundleName(String baseName, Locale locale) {
<i>3436</i>&nbsp;            if (locale == Locale.ROOT) {
<i>3437</i>&nbsp;                return baseName;
<i>3438</i>&nbsp;            }
<i>3439</i>&nbsp;
<i>3440</i>&nbsp;            String language = locale.getLanguage();
<i>3441</i>&nbsp;            String script = locale.getScript();
<i>3442</i>&nbsp;            String country = locale.getCountry();
<i>3443</i>&nbsp;            String variant = locale.getVariant();
<i>3444</i>&nbsp;
<i>3445</i>&nbsp;            if (language == &quot;&quot; &amp;&amp; country == &quot;&quot; &amp;&amp; variant == &quot;&quot;) {
<i>3446</i>&nbsp;                return baseName;
<i>3447</i>&nbsp;            }
<i>3448</i>&nbsp;
<i>3449</i>&nbsp;            StringBuilder sb = new StringBuilder(baseName);
<i>3450</i>&nbsp;            sb.append(&#39;_&#39;);
<i>3451</i>&nbsp;            if (script != &quot;&quot;) {
<i>3452</i>&nbsp;                if (variant != &quot;&quot;) {
<i>3453</i>&nbsp;                    sb.append(language).append(&#39;_&#39;).append(script).append(&#39;_&#39;).append(country).append(&#39;_&#39;).append(variant);
<i>3454</i>&nbsp;                } else if (country != &quot;&quot;) {
<i>3455</i>&nbsp;                    sb.append(language).append(&#39;_&#39;).append(script).append(&#39;_&#39;).append(country);
<i>3456</i>&nbsp;                } else {
<i>3457</i>&nbsp;                    sb.append(language).append(&#39;_&#39;).append(script);
<i>3458</i>&nbsp;                }
<i>3459</i>&nbsp;            } else {
<i>3460</i>&nbsp;                if (variant != &quot;&quot;) {
<i>3461</i>&nbsp;                    sb.append(language).append(&#39;_&#39;).append(country).append(&#39;_&#39;).append(variant);
<i>3462</i>&nbsp;                } else if (country != &quot;&quot;) {
<i>3463</i>&nbsp;                    sb.append(language).append(&#39;_&#39;).append(country);
<i>3464</i>&nbsp;                } else {
<i>3465</i>&nbsp;                    sb.append(language);
<i>3466</i>&nbsp;                }
<i>3467</i>&nbsp;            }
<i>3468</i>&nbsp;            return sb.toString();
<i>3469</i>&nbsp;
<i>3470</i>&nbsp;        }
<i>3471</i>&nbsp;
<i>3472</i>&nbsp;        /**
<i>3473</i>&nbsp;         * Converts the given {@code bundleName} to the form required
<i>3474</i>&nbsp;         * by the {@link ClassLoader#getResource ClassLoader.getResource}
<i>3475</i>&nbsp;         * method by replacing all occurrences of {@code &#39;.&#39;} in
<i>3476</i>&nbsp;         * {@code bundleName} with {@code &#39;/&#39;} and appending a
<i>3477</i>&nbsp;         * {@code &#39;.&#39;} and the given file {@code suffix}. For
<i>3478</i>&nbsp;         * example, if {@code bundleName} is
<i>3479</i>&nbsp;         * {@code &quot;foo.bar.MyResources_ja_JP&quot;} and {@code suffix}
<i>3480</i>&nbsp;         * is {@code &quot;properties&quot;}, then
<i>3481</i>&nbsp;         * {@code &quot;foo/bar/MyResources_ja_JP.properties&quot;} is returned.
<i>3482</i>&nbsp;         *
<i>3483</i>&nbsp;         * @param bundleName
<i>3484</i>&nbsp;         *        the bundle name
<i>3485</i>&nbsp;         * @param suffix
<i>3486</i>&nbsp;         *        the file type suffix
<i>3487</i>&nbsp;         * @return the converted resource name
<i>3488</i>&nbsp;         * @exception NullPointerException
<i>3489</i>&nbsp;         *         if {@code bundleName} or {@code suffix}
<i>3490</i>&nbsp;         *         is {@code null}
<i>3491</i>&nbsp;         */
<i>3492</i>&nbsp;        public final String toResourceName(String bundleName, String suffix) {
<i>3493</i>&nbsp;            StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
<i>3494</i>&nbsp;            sb.append(bundleName.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;.&#39;).append(suffix);
<i>3495</i>&nbsp;            return sb.toString();
<i>3496</i>&nbsp;        }
<i>3497</i>&nbsp;
<i>3498</i>&nbsp;        private String toResourceName0(String bundleName, String suffix) {
<i>3499</i>&nbsp;            // application protocol check
<i>3500</i>&nbsp;            if (bundleName.contains(&quot;://&quot;)) {
<i>3501</i>&nbsp;                return null;
<i>3502</i>&nbsp;            } else {
<i>3503</i>&nbsp;                return toResourceName(bundleName, suffix);
<i>3504</i>&nbsp;            }
<i>3505</i>&nbsp;        }
<i>3506</i>&nbsp;    }
<i>3507</i>&nbsp;
<i>3508</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>3509</i>&nbsp;    private static &lt;T extends Throwable&gt; void uncheckedThrow(Throwable t) throws T {
<i>3510</i>&nbsp;        if (t != null)
<i>3511</i>&nbsp;            throw (T)t;
<i>3512</i>&nbsp;        else
<i>3513</i>&nbsp;            throw new Error(&quot;Unknown Exception&quot;);
<i>3514</i>&nbsp;    }
<i>3515</i>&nbsp;
<i>3516</i>&nbsp;    private static class SingleFormatControl extends Control {
<i>3517</i>&nbsp;        private static final Control PROPERTIES_ONLY
<i>3518</i>&nbsp;            = new SingleFormatControl(FORMAT_PROPERTIES);
<i>3519</i>&nbsp;
<i>3520</i>&nbsp;        private static final Control CLASS_ONLY
<i>3521</i>&nbsp;            = new SingleFormatControl(FORMAT_CLASS);
<i>3522</i>&nbsp;
<i>3523</i>&nbsp;        private final List&lt;String&gt; formats;
<i>3524</i>&nbsp;
<i>3525</i>&nbsp;        protected SingleFormatControl(List&lt;String&gt; formats) {
<i>3526</i>&nbsp;            this.formats = formats;
<i>3527</i>&nbsp;        }
<i>3528</i>&nbsp;
<i>3529</i>&nbsp;        public List&lt;String&gt; getFormats(String baseName) {
<i>3530</i>&nbsp;            if (baseName == null) {
<i>3531</i>&nbsp;                throw new NullPointerException();
<i>3532</i>&nbsp;            }
<i>3533</i>&nbsp;            return formats;
<i>3534</i>&nbsp;        }
<i>3535</i>&nbsp;    }
<i>3536</i>&nbsp;
<i>3537</i>&nbsp;    private static final class NoFallbackControl extends SingleFormatControl {
<i>3538</i>&nbsp;        private static final Control NO_FALLBACK
<i>3539</i>&nbsp;            = new NoFallbackControl(FORMAT_DEFAULT);
<i>3540</i>&nbsp;
<i>3541</i>&nbsp;        private static final Control PROPERTIES_ONLY_NO_FALLBACK
<i>3542</i>&nbsp;            = new NoFallbackControl(FORMAT_PROPERTIES);
<i>3543</i>&nbsp;
<i>3544</i>&nbsp;        private static final Control CLASS_ONLY_NO_FALLBACK
<i>3545</i>&nbsp;            = new NoFallbackControl(FORMAT_CLASS);
<i>3546</i>&nbsp;
<i>3547</i>&nbsp;        protected NoFallbackControl(List&lt;String&gt; formats) {
<i>3548</i>&nbsp;            super(formats);
<i>3549</i>&nbsp;        }
<i>3550</i>&nbsp;
<i>3551</i>&nbsp;        public Locale getFallbackLocale(String baseName, Locale locale) {
<i>3552</i>&nbsp;            if (baseName == null || locale == null) {
<i>3553</i>&nbsp;                throw new NullPointerException();
<i>3554</i>&nbsp;            }
<i>3555</i>&nbsp;            return null;
<i>3556</i>&nbsp;        }
<i>3557</i>&nbsp;    }
<i>3558</i>&nbsp;
<i>3559</i>&nbsp;    private static class ResourceBundleProviderHelper {
<i>3560</i>&nbsp;        /**
<i>3561</i>&nbsp;         * Returns a new ResourceBundle instance of the given bundleClass
<i>3562</i>&nbsp;         */
<i>3563</i>&nbsp;        static ResourceBundle newResourceBundle(Class&lt;? extends ResourceBundle&gt; bundleClass) {
<i>3564</i>&nbsp;            try {
<i>3565</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>3566</i>&nbsp;                Constructor&lt;? extends ResourceBundle&gt; ctor =
<i>3567</i>&nbsp;                    bundleClass.getConstructor();
<i>3568</i>&nbsp;                if (!Modifier.isPublic(ctor.getModifiers())) {
<i>3569</i>&nbsp;                    return null;
<i>3570</i>&nbsp;                }
<i>3571</i>&nbsp;                // java.base may not be able to read the bundleClass&#39;s module.
<i>3572</i>&nbsp;                PrivilegedAction&lt;Void&gt; pa = () -&gt; { ctor.setAccessible(true); return null;};
<i>3573</i>&nbsp;                AccessController.doPrivileged(pa);
<i>3574</i>&nbsp;                try {
<i>3575</i>&nbsp;                    return ctor.newInstance((Object[]) null);
<i>3576</i>&nbsp;                } catch (InvocationTargetException e) {
<i>3577</i>&nbsp;                    uncheckedThrow(e);
<i>3578</i>&nbsp;                } catch (InstantiationException | IllegalAccessException e) {
<i>3579</i>&nbsp;                    throw new InternalError(e);
<i>3580</i>&nbsp;                }
<i>3581</i>&nbsp;            } catch (NoSuchMethodException e) {
<i>3582</i>&nbsp;                throw new InternalError(e);
<i>3583</i>&nbsp;            }
<i>3584</i>&nbsp;            return null;
<i>3585</i>&nbsp;        }
<i>3586</i>&nbsp;
<i>3587</i>&nbsp;        /**
<i>3588</i>&nbsp;         * Loads a {@code ResourceBundle} of the given {@code bundleName} local to
<i>3589</i>&nbsp;         * the given {@code module}. If not found, search the bundle class
<i>3590</i>&nbsp;         * that is visible from the module&#39;s class loader.
<i>3591</i>&nbsp;         *
<i>3592</i>&nbsp;         * The caller module is used for access check only.
<i>3593</i>&nbsp;         */
<i>3594</i>&nbsp;        static ResourceBundle loadResourceBundle(Module callerModule,
<i>3595</i>&nbsp;                                                 Module module,
<i>3596</i>&nbsp;                                                 String baseName,
<i>3597</i>&nbsp;                                                 Locale locale)
<i>3598</i>&nbsp;        {
<i>3599</i>&nbsp;            String bundleName = Control.INSTANCE.toBundleName(baseName, locale);
<i>3600</i>&nbsp;            try {
<i>3601</i>&nbsp;                PrivilegedAction&lt;Class&lt;?&gt;&gt; pa = () -&gt; Class.forName(module, bundleName);
<i>3602</i>&nbsp;                Class&lt;?&gt; c = AccessController.doPrivileged(pa, null, GET_CLASSLOADER_PERMISSION);
<i>3603</i>&nbsp;                trace(&quot;local in %s %s caller %s: %s%n&quot;, module, bundleName, callerModule, c);
<i>3604</i>&nbsp;
<i>3605</i>&nbsp;                if (c == null) {
<i>3606</i>&nbsp;                    // if not found from the given module, locate resource bundle
<i>3607</i>&nbsp;                    // that is visible to the module&#39;s class loader
<i>3608</i>&nbsp;                    ClassLoader loader = getLoader(module);
<i>3609</i>&nbsp;                    if (loader != null) {
<i>3610</i>&nbsp;                        c = Class.forName(bundleName, false, loader);
<i>3611</i>&nbsp;                    } else {
<i>3612</i>&nbsp;                        c = BootLoader.loadClassOrNull(bundleName);
<i>3613</i>&nbsp;                    }
<i>3614</i>&nbsp;                    trace(&quot;loader for %s %s caller %s: %s%n&quot;, module, bundleName, callerModule, c);
<i>3615</i>&nbsp;                }
<i>3616</i>&nbsp;
<i>3617</i>&nbsp;                if (c != null &amp;&amp; ResourceBundle.class.isAssignableFrom(c)) {
<i>3618</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
<i>3619</i>&nbsp;                    Class&lt;ResourceBundle&gt; bundleClass = (Class&lt;ResourceBundle&gt;) c;
<i>3620</i>&nbsp;                    Module m = bundleClass.getModule();
<i>3621</i>&nbsp;                    if (!isAccessible(callerModule, m, bundleClass.getPackageName())) {
<i>3622</i>&nbsp;                        trace(&quot;   %s does not have access to %s/%s%n&quot;, callerModule,
<i>3623</i>&nbsp;                              m.getName(), bundleClass.getPackageName());
<i>3624</i>&nbsp;                        return null;
<i>3625</i>&nbsp;                    }
<i>3626</i>&nbsp;
<i>3627</i>&nbsp;                    return newResourceBundle(bundleClass);
<i>3628</i>&nbsp;                }
<i>3629</i>&nbsp;            } catch (ClassNotFoundException e) {}
<i>3630</i>&nbsp;            return null;
<i>3631</i>&nbsp;        }
<i>3632</i>&nbsp;
<i>3633</i>&nbsp;        /**
<i>3634</i>&nbsp;         * Tests if resources of the given package name from the given module are
<i>3635</i>&nbsp;         * open to the caller module.
<i>3636</i>&nbsp;         */
<i>3637</i>&nbsp;        static boolean isAccessible(Module callerModule, Module module, String pn) {
<i>3638</i>&nbsp;            if (!module.isNamed() || callerModule == module)
<i>3639</i>&nbsp;                return true;
<i>3640</i>&nbsp;
<i>3641</i>&nbsp;            return module.isOpen(pn, callerModule);
<i>3642</i>&nbsp;        }
<i>3643</i>&nbsp;
<i>3644</i>&nbsp;        /**
<i>3645</i>&nbsp;         * Loads properties of the given {@code bundleName} local in the given
<i>3646</i>&nbsp;         * {@code module}.  If the .properties is not found or not open
<i>3647</i>&nbsp;         * to the caller module to access, it will find the resource that
<i>3648</i>&nbsp;         * is visible to the module&#39;s class loader.
<i>3649</i>&nbsp;         *
<i>3650</i>&nbsp;         * The caller module is used for access check only.
<i>3651</i>&nbsp;         */
<i>3652</i>&nbsp;        static ResourceBundle loadPropertyResourceBundle(Module callerModule,
<i>3653</i>&nbsp;                                                         Module module,
<i>3654</i>&nbsp;                                                         String baseName,
<i>3655</i>&nbsp;                                                         Locale locale)
<i>3656</i>&nbsp;            throws IOException
<i>3657</i>&nbsp;        {
<i>3658</i>&nbsp;            String bundleName = Control.INSTANCE.toBundleName(baseName, locale);
<i>3659</i>&nbsp;
<i>3660</i>&nbsp;            PrivilegedAction&lt;InputStream&gt; pa = () -&gt; {
<i>3661</i>&nbsp;                try {
<i>3662</i>&nbsp;                    String resourceName = Control.INSTANCE
<i>3663</i>&nbsp;                        .toResourceName0(bundleName, &quot;properties&quot;);
<i>3664</i>&nbsp;                    if (resourceName == null) {
<i>3665</i>&nbsp;                        return null;
<i>3666</i>&nbsp;                    }
<i>3667</i>&nbsp;                    trace(&quot;local in %s %s caller %s%n&quot;, module, resourceName, callerModule);
<i>3668</i>&nbsp;
<i>3669</i>&nbsp;                    // if the package is in the given module but not opened
<i>3670</i>&nbsp;                    // locate it from the given module first.
<i>3671</i>&nbsp;                    String pn = toPackageName(bundleName);
<i>3672</i>&nbsp;                    trace(&quot;   %s/%s is accessible to %s : %s%n&quot;,
<i>3673</i>&nbsp;                            module.getName(), pn, callerModule,
<i>3674</i>&nbsp;                            isAccessible(callerModule, module, pn));
<i>3675</i>&nbsp;                    if (isAccessible(callerModule, module, pn)) {
<i>3676</i>&nbsp;                        InputStream in = module.getResourceAsStream(resourceName);
<i>3677</i>&nbsp;                        if (in != null) {
<i>3678</i>&nbsp;                            return in;
<i>3679</i>&nbsp;                        }
<i>3680</i>&nbsp;                    }
<i>3681</i>&nbsp;
<i>3682</i>&nbsp;                    ClassLoader loader = module.getClassLoader();
<i>3683</i>&nbsp;                    trace(&quot;loader for %s %s caller %s%n&quot;, module, resourceName, callerModule);
<i>3684</i>&nbsp;
<i>3685</i>&nbsp;                    try {
<i>3686</i>&nbsp;                        if (loader != null) {
<i>3687</i>&nbsp;                            return loader.getResourceAsStream(resourceName);
<i>3688</i>&nbsp;                        } else {
<i>3689</i>&nbsp;                            URL url = BootLoader.findResource(resourceName);
<i>3690</i>&nbsp;                            if (url != null) {
<i>3691</i>&nbsp;                                return url.openStream();
<i>3692</i>&nbsp;                            }
<i>3693</i>&nbsp;                        }
<i>3694</i>&nbsp;                    } catch (Exception e) {}
<i>3695</i>&nbsp;                    return null;
<i>3696</i>&nbsp;
<i>3697</i>&nbsp;                } catch (IOException e) {
<i>3698</i>&nbsp;                    throw new UncheckedIOException(e);
<i>3699</i>&nbsp;                }
<i>3700</i>&nbsp;            };
<i>3701</i>&nbsp;
<i>3702</i>&nbsp;            try (InputStream stream = AccessController.doPrivileged(pa)) {
<i>3703</i>&nbsp;                if (stream != null) {
<i>3704</i>&nbsp;                    return new PropertyResourceBundle(stream);
<i>3705</i>&nbsp;                } else {
<i>3706</i>&nbsp;                    return null;
<i>3707</i>&nbsp;                }
<i>3708</i>&nbsp;            } catch (UncheckedIOException e) {
<i>3709</i>&nbsp;                throw e.getCause();
<i>3710</i>&nbsp;            }
<i>3711</i>&nbsp;        }
<i>3712</i>&nbsp;
<i>3713</i>&nbsp;        private static String toPackageName(String bundleName) {
<i>3714</i>&nbsp;            int i = bundleName.lastIndexOf(&#39;.&#39;);
<i>3715</i>&nbsp;            return i != -1 ? bundleName.substring(0, i) : &quot;&quot;;
<i>3716</i>&nbsp;        }
<i>3717</i>&nbsp;
<i>3718</i>&nbsp;    }
<i>3719</i>&nbsp;
<i>3720</i>&nbsp;    private static final boolean TRACE_ON = Boolean.valueOf(
<i>3721</i>&nbsp;        GetPropertyAction.privilegedGetProperty(&quot;resource.bundle.debug&quot;, &quot;false&quot;));
<i>3722</i>&nbsp;
<i>3723</i>&nbsp;    private static void trace(String format, Object... params) {
<i>3724</i>&nbsp;        if (TRACE_ON)
<i>3725</i>&nbsp;            System.out.format(format, params);
<i>3726</i>&nbsp;    }
<i>3727</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
