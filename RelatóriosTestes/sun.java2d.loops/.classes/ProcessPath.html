


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ProcessPath</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.java2d.loops</a> ]
</div>

<h1>Coverage Summary for Class: ProcessPath (sun.java2d.loops)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ProcessPath</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 522)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ProcessPath$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$ActiveEdgeList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$DrawHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$DrawProcessHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$Edge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$FillData</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$FillProcessHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$Point</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ProcessPath$ProcessHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 745)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.java2d.loops;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.geom.Path2D;
<i>29</i>&nbsp;import java.awt.geom.PathIterator;
<i>30</i>&nbsp;import java.awt.geom.QuadCurve2D;
<i>31</i>&nbsp;import sun.awt.SunHints;
<i>32</i>&nbsp;import java.util.*;
<i>33</i>&nbsp;
<i>34</i>&nbsp;/* This is the java implementation of the native code from
<i>35</i>&nbsp; * src/share/native/sun/java2d/loops/ProcessPath.[c,h]
<i>36</i>&nbsp; * This code is written to be as much similar to the native
<i>37</i>&nbsp; * as it possible. So, it sometimes does not follow java naming conventions.
<i>38</i>&nbsp; *
<i>39</i>&nbsp; * It&#39;s important to keep this code synchronized with native one.  See more
<i>40</i>&nbsp; * comments, description and high level scheme of the rendering process in the
<i>41</i>&nbsp; * ProcessPath.c
<i>42</i>&nbsp; */
<i>43</i>&nbsp;
<b class="nc"><i>44</i>&nbsp;public class ProcessPath {</b>
<i>45</i>&nbsp;
<i>46</i>&nbsp;    /* Public interfaces and methods for drawing and filling general paths */
<i>47</i>&nbsp;
<i>48</i>&nbsp;    public abstract static class DrawHandler {
<i>49</i>&nbsp;        public int xMin;
<i>50</i>&nbsp;        public int yMin;
<i>51</i>&nbsp;        public int xMax;
<i>52</i>&nbsp;        public int yMax;
<i>53</i>&nbsp;        public float xMinf;
<i>54</i>&nbsp;        public float yMinf;
<i>55</i>&nbsp;        public float xMaxf;
<i>56</i>&nbsp;        public float yMaxf;
<i>57</i>&nbsp;
<i>58</i>&nbsp;        public int strokeControl;
<i>59</i>&nbsp;
<i>60</i>&nbsp;        public DrawHandler(int xMin, int yMin, int xMax, int yMax,
<i>61</i>&nbsp;                           int strokeControl)
<b class="nc"><i>62</i>&nbsp;        {</b>
<b class="nc"><i>63</i>&nbsp;            setBounds(xMin, yMin, xMax, yMax, strokeControl);</b>
<i>64</i>&nbsp;        }
<i>65</i>&nbsp;
<i>66</i>&nbsp;        public void setBounds(int xMin, int yMin, int xMax, int yMax)
<i>67</i>&nbsp;        {
<b class="nc"><i>68</i>&nbsp;            this.xMin = xMin;</b>
<b class="nc"><i>69</i>&nbsp;            this.yMin = yMin;</b>
<b class="nc"><i>70</i>&nbsp;            this.xMax = xMax;</b>
<b class="nc"><i>71</i>&nbsp;            this.yMax = yMax;</b>
<i>72</i>&nbsp;
<i>73</i>&nbsp;            /*                Setting up fractional clipping box
<i>74</i>&nbsp;             *
<i>75</i>&nbsp;             * We are using following float -&gt; int mapping:
<i>76</i>&nbsp;             *
<i>77</i>&nbsp;             *      xi = floor(xf + 0.5)
<i>78</i>&nbsp;             *
<i>79</i>&nbsp;             * So, fractional values that hit the [xmin, xmax) integer interval
<i>80</i>&nbsp;             * will be situated inside the [xmin-0.5, xmax - 0.5) fractional
<i>81</i>&nbsp;             * interval. We are using EPSF constant to provide that upper
<i>82</i>&nbsp;             * boundary is not included.
<i>83</i>&nbsp;             */
<b class="nc"><i>84</i>&nbsp;            xMinf = xMin - 0.5f;</b>
<b class="nc"><i>85</i>&nbsp;            yMinf = yMin - 0.5f;</b>
<b class="nc"><i>86</i>&nbsp;            xMaxf = xMax - 0.5f - EPSF;</b>
<b class="nc"><i>87</i>&nbsp;            yMaxf = yMax - 0.5f - EPSF;</b>
<i>88</i>&nbsp;        }
<i>89</i>&nbsp;
<i>90</i>&nbsp;        public void setBounds(int xMin, int yMin, int xMax, int yMax,
<i>91</i>&nbsp;                              int strokeControl)
<i>92</i>&nbsp;        {
<b class="nc"><i>93</i>&nbsp;            this.strokeControl = strokeControl;</b>
<b class="nc"><i>94</i>&nbsp;            setBounds(xMin, yMin, xMax, yMax);</b>
<i>95</i>&nbsp;        }
<i>96</i>&nbsp;
<i>97</i>&nbsp;        public void adjustBounds(int bxMin, int byMin, int bxMax, int byMax)
<i>98</i>&nbsp;        {
<b class="nc"><i>99</i>&nbsp;            if (xMin &gt; bxMin) bxMin = xMin;</b>
<b class="nc"><i>100</i>&nbsp;            if (xMax &lt; bxMax) bxMax = xMax;</b>
<b class="nc"><i>101</i>&nbsp;            if (yMin &gt; byMin) byMin = yMin;</b>
<b class="nc"><i>102</i>&nbsp;            if (yMax &lt; byMax) byMax = yMax;</b>
<b class="nc"><i>103</i>&nbsp;            setBounds(bxMin, byMin, bxMax, byMax);</b>
<i>104</i>&nbsp;        }
<i>105</i>&nbsp;
<i>106</i>&nbsp;        public DrawHandler(int xMin, int yMin, int xMax, int yMax) {
<b class="nc"><i>107</i>&nbsp;            this(xMin, yMin, xMax, yMax, SunHints.INTVAL_STROKE_DEFAULT);</b>
<i>108</i>&nbsp;        }
<i>109</i>&nbsp;
<i>110</i>&nbsp;        public abstract void drawLine(int x0, int y0, int x1, int y1);
<i>111</i>&nbsp;
<i>112</i>&nbsp;        public abstract void drawPixel(int x0, int y0);
<i>113</i>&nbsp;
<i>114</i>&nbsp;        public abstract void drawScanline(int x0, int x1, int y0);
<i>115</i>&nbsp;    }
<i>116</i>&nbsp;
<i>117</i>&nbsp;    public interface EndSubPathHandler {
<i>118</i>&nbsp;        public void processEndSubPath();
<i>119</i>&nbsp;    }
<i>120</i>&nbsp;
<i>121</i>&nbsp;    public static final int PH_MODE_DRAW_CLIP = 0;
<i>122</i>&nbsp;    public static final int PH_MODE_FILL_CLIP = 1;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    public abstract static class ProcessHandler implements EndSubPathHandler {
<i>125</i>&nbsp;        DrawHandler dhnd;
<i>126</i>&nbsp;        int clipMode;
<i>127</i>&nbsp;
<i>128</i>&nbsp;        public ProcessHandler(DrawHandler dhnd,
<b class="nc"><i>129</i>&nbsp;                              int clipMode) {</b>
<b class="nc"><i>130</i>&nbsp;            this.dhnd = dhnd;</b>
<b class="nc"><i>131</i>&nbsp;            this.clipMode = clipMode;</b>
<i>132</i>&nbsp;        }
<i>133</i>&nbsp;
<i>134</i>&nbsp;        public abstract void processFixedLine(int x1, int y1,
<i>135</i>&nbsp;                                              int x2, int y2, int [] pixelInfo,
<i>136</i>&nbsp;                                              boolean checkBounds,
<i>137</i>&nbsp;                                              boolean endSubPath);
<i>138</i>&nbsp;    }
<i>139</i>&nbsp;
<b class="nc"><i>140</i>&nbsp;    public static EndSubPathHandler noopEndSubPathHandler =</b>
<b class="nc"><i>141</i>&nbsp;        new EndSubPathHandler() {</b>
<i>142</i>&nbsp;            public void processEndSubPath() { }
<i>143</i>&nbsp;        };
<i>144</i>&nbsp;
<i>145</i>&nbsp;    public static boolean fillPath(DrawHandler dhnd, Path2D.Float p2df,
<i>146</i>&nbsp;                                   int transX, int transY)
<i>147</i>&nbsp;    {
<b class="nc"><i>148</i>&nbsp;        FillProcessHandler fhnd = new FillProcessHandler(dhnd);</b>
<b class="nc"><i>149</i>&nbsp;        if (!doProcessPath(fhnd, p2df, transX, transY)) {</b>
<b class="nc"><i>150</i>&nbsp;            return false;</b>
<i>151</i>&nbsp;        }
<b class="nc"><i>152</i>&nbsp;        FillPolygon(fhnd, p2df.getWindingRule());</b>
<b class="nc"><i>153</i>&nbsp;        return true;</b>
<i>154</i>&nbsp;    }
<i>155</i>&nbsp;
<i>156</i>&nbsp;    public static boolean drawPath(DrawHandler dhnd,
<i>157</i>&nbsp;                                   EndSubPathHandler endSubPath,
<i>158</i>&nbsp;                                   Path2D.Float p2df,
<i>159</i>&nbsp;                                   int transX, int transY)
<i>160</i>&nbsp;    {
<b class="nc"><i>161</i>&nbsp;        return doProcessPath(new DrawProcessHandler(dhnd, endSubPath),</b>
<i>162</i>&nbsp;                             p2df, transX, transY);
<i>163</i>&nbsp;    }
<i>164</i>&nbsp;
<i>165</i>&nbsp;    public static boolean drawPath(DrawHandler dhnd,
<i>166</i>&nbsp;                                   Path2D.Float p2df,
<i>167</i>&nbsp;                                   int transX, int transY)
<i>168</i>&nbsp;    {
<b class="nc"><i>169</i>&nbsp;        return doProcessPath(new DrawProcessHandler(dhnd,</b>
<i>170</i>&nbsp;                                                    noopEndSubPathHandler),
<i>171</i>&nbsp;                             p2df, transX, transY);
<i>172</i>&nbsp;    }
<i>173</i>&nbsp;
<i>174</i>&nbsp;    /* Private implementation of the rendering process */
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /* Boundaries used for skipping huge path segments */
<i>177</i>&nbsp;    private static final float UPPER_BND = Float.MAX_VALUE/4.0f;
<i>178</i>&nbsp;    private static final float LOWER_BND = -UPPER_BND;
<i>179</i>&nbsp;
<i>180</i>&nbsp;    /* Precision (in bits) used in forward differencing */
<i>181</i>&nbsp;    private static final int FWD_PREC = 7;
<i>182</i>&nbsp;
<i>183</i>&nbsp;    /* Precision (in bits) used for the rounding in the midpoint test */
<i>184</i>&nbsp;    private static final int MDP_PREC = 10;
<i>185</i>&nbsp;
<i>186</i>&nbsp;    private static final int MDP_MULT = 1 &lt;&lt; MDP_PREC;
<i>187</i>&nbsp;    private static final int MDP_HALF_MULT = MDP_MULT &gt;&gt; 1;
<i>188</i>&nbsp;
<i>189</i>&nbsp;    /* Boundaries used for clipping large path segments (those are inside
<i>190</i>&nbsp;     * [UPPER/LOWER]_BND boundaries)
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    private static final int UPPER_OUT_BND = 1 &lt;&lt; (30 - MDP_PREC);
<i>193</i>&nbsp;    private static final int LOWER_OUT_BND = -UPPER_OUT_BND;
<i>194</i>&nbsp;
<i>195</i>&nbsp;
<i>196</i>&nbsp;    /* Calculation boundaries. They are used for switching to the more slow but
<i>197</i>&nbsp;     * allowing larger input values method of calculation of the initial values
<i>198</i>&nbsp;     * of the scan converted line segments inside the FillPolygon
<i>199</i>&nbsp;     */
<i>200</i>&nbsp;    private static final float CALC_UBND = 1 &lt;&lt; (30 - MDP_PREC);
<i>201</i>&nbsp;    private static final float CALC_LBND = -CALC_UBND;
<i>202</i>&nbsp;
<i>203</i>&nbsp;
<i>204</i>&nbsp;    /* Following constants are used for providing open boundaries of the
<i>205</i>&nbsp;     * intervals
<i>206</i>&nbsp;     */
<i>207</i>&nbsp;    public static final int EPSFX = 1;
<i>208</i>&nbsp;    public static final float EPSF = ((float)EPSFX)/MDP_MULT;
<i>209</i>&nbsp;
<i>210</i>&nbsp;    /* Bit mask used to separate whole part from the fraction part of the
<i>211</i>&nbsp;     * number
<i>212</i>&nbsp;     */
<i>213</i>&nbsp;    private static final int MDP_W_MASK = -MDP_MULT;
<i>214</i>&nbsp;
<i>215</i>&nbsp;    /* Bit mask used to separate fractional part from the whole part of the
<i>216</i>&nbsp;     * number
<i>217</i>&nbsp;     */
<i>218</i>&nbsp;    private static final int MDP_F_MASK = MDP_MULT - 1;
<i>219</i>&nbsp;
<i>220</i>&nbsp;    /*
<i>221</i>&nbsp;     *                  Constants for the forward differencing
<i>222</i>&nbsp;     *                      of the cubic and quad curves
<i>223</i>&nbsp;     */
<i>224</i>&nbsp;
<i>225</i>&nbsp;    /* Maximum size of the cubic curve (calculated as the size of the bounding
<i>226</i>&nbsp;     * box of the control points) which could be rendered without splitting
<i>227</i>&nbsp;     */
<i>228</i>&nbsp;    private static final int MAX_CUB_SIZE = 256;
<i>229</i>&nbsp;
<i>230</i>&nbsp;    /* Maximum size of the quad curve (calculated as the size of the bounding
<i>231</i>&nbsp;     * box of the control points) which could be rendered without splitting
<i>232</i>&nbsp;     */
<i>233</i>&nbsp;    private static final int MAX_QUAD_SIZE = 1024;
<i>234</i>&nbsp;
<i>235</i>&nbsp;    /* Default power of 2 steps used in the forward differencing. Here DF prefix
<i>236</i>&nbsp;     * stands for DeFault. Constants below are used as initial values for the
<i>237</i>&nbsp;     * adaptive forward differencing algorithm.
<i>238</i>&nbsp;     */
<i>239</i>&nbsp;    private static final int DF_CUB_STEPS = 3;
<i>240</i>&nbsp;    private static final int DF_QUAD_STEPS = 2;
<i>241</i>&nbsp;
<i>242</i>&nbsp;    /* Shift of the current point of the curve for preparing to the midpoint
<i>243</i>&nbsp;     * rounding
<i>244</i>&nbsp;     */
<i>245</i>&nbsp;    private static final int DF_CUB_SHIFT = FWD_PREC + DF_CUB_STEPS*3 -
<i>246</i>&nbsp;                                            MDP_PREC;
<i>247</i>&nbsp;    private static final int DF_QUAD_SHIFT = FWD_PREC + DF_QUAD_STEPS*2 -
<i>248</i>&nbsp;                                             MDP_PREC;
<i>249</i>&nbsp;
<i>250</i>&nbsp;    /* Default amount of steps of the forward differencing */
<i>251</i>&nbsp;    private static final int DF_CUB_COUNT = (1&lt;&lt;DF_CUB_STEPS);
<i>252</i>&nbsp;    private static final int DF_QUAD_COUNT = (1&lt;&lt;DF_QUAD_STEPS);
<i>253</i>&nbsp;
<i>254</i>&nbsp;    /* Default boundary constants used to check the necessity of the restepping
<i>255</i>&nbsp;     */
<i>256</i>&nbsp;    private static final int DF_CUB_DEC_BND = 1&lt;&lt;DF_CUB_STEPS*3 + FWD_PREC + 2;
<i>257</i>&nbsp;    private static final int DF_CUB_INC_BND = 1&lt;&lt;DF_CUB_STEPS*3 + FWD_PREC - 1;
<i>258</i>&nbsp;    private static final int DF_QUAD_DEC_BND = 1&lt;&lt;DF_QUAD_STEPS*2 +
<i>259</i>&nbsp;                                                  FWD_PREC + 2;
<i>260</i>&nbsp;    private static final int DF_QUAD_INC_BND = 1&lt;&lt;DF_QUAD_STEPS*2 +
<i>261</i>&nbsp;                                                  FWD_PREC - 1;
<i>262</i>&nbsp;
<i>263</i>&nbsp;    /* Multipliers for the coefficients of the polynomial form of the cubic and
<i>264</i>&nbsp;     * quad curves representation
<i>265</i>&nbsp;     */
<i>266</i>&nbsp;    private static final int CUB_A_SHIFT = FWD_PREC;
<i>267</i>&nbsp;    private static final int CUB_B_SHIFT = (DF_CUB_STEPS + FWD_PREC + 1);
<i>268</i>&nbsp;    private static final int CUB_C_SHIFT = (DF_CUB_STEPS*2 + FWD_PREC);
<i>269</i>&nbsp;
<i>270</i>&nbsp;    private static final int CUB_A_MDP_MULT = (1&lt;&lt;CUB_A_SHIFT);
<i>271</i>&nbsp;    private static final int CUB_B_MDP_MULT = (1&lt;&lt;CUB_B_SHIFT);
<i>272</i>&nbsp;    private static final int CUB_C_MDP_MULT = (1&lt;&lt;CUB_C_SHIFT);
<i>273</i>&nbsp;
<i>274</i>&nbsp;    private static final int QUAD_A_SHIFT = FWD_PREC;
<i>275</i>&nbsp;    private static final int QUAD_B_SHIFT = (DF_QUAD_STEPS + FWD_PREC);
<i>276</i>&nbsp;
<i>277</i>&nbsp;    private static final int QUAD_A_MDP_MULT = (1&lt;&lt;QUAD_A_SHIFT);
<i>278</i>&nbsp;    private static final int QUAD_B_MDP_MULT = (1&lt;&lt;QUAD_B_SHIFT);
<i>279</i>&nbsp;
<i>280</i>&nbsp;    /* Clipping macros for drawing and filling algorithms */
<i>281</i>&nbsp;    private static float CLIP(float a1, float b1, float a2, float b2,
<i>282</i>&nbsp;                              double t) {
<b class="nc"><i>283</i>&nbsp;        return (float)(b1 + (t - a1)*(b2 - b1) / (a2 - a1));</b>
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;    private static int CLIP(int a1, int b1, int a2, int b2, double t) {
<b class="nc"><i>287</i>&nbsp;        return (int)(b1 + (t - a1)*(b2 - b1) / (a2 - a1));</b>
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;
<i>291</i>&nbsp;    private static final int CRES_MIN_CLIPPED = 0;
<i>292</i>&nbsp;    private static final int CRES_MAX_CLIPPED = 1;
<i>293</i>&nbsp;    private static final int CRES_NOT_CLIPPED = 3;
<i>294</i>&nbsp;    private static final int CRES_INVISIBLE = 4;
<i>295</i>&nbsp;
<i>296</i>&nbsp;    private static boolean IS_CLIPPED(int res) {
<b class="nc"><i>297</i>&nbsp;        return res == CRES_MIN_CLIPPED || res == CRES_MAX_CLIPPED;</b>
<i>298</i>&nbsp;    }
<i>299</i>&nbsp;
<i>300</i>&nbsp;    /* This is java implementation of the macro from ProcessGeneralPath.c.
<i>301</i>&nbsp;     * To keep the logic of the java code similar to the native one
<i>302</i>&nbsp;     * array and set of indexes are used to point out the data.
<i>303</i>&nbsp;     */
<i>304</i>&nbsp;    private static int TESTANDCLIP(float LINE_MIN, float LINE_MAX, float[] c,
<i>305</i>&nbsp;                                   int a1, int b1, int a2, int b2) {
<i>306</i>&nbsp;        double t;
<b class="nc"><i>307</i>&nbsp;        int res = CRES_NOT_CLIPPED;</b>
<b class="nc"><i>308</i>&nbsp;        if (c[a1] &lt; (LINE_MIN) || c[a1] &gt; (LINE_MAX)) {</b>
<b class="nc"><i>309</i>&nbsp;            if (c[a1] &lt; (LINE_MIN)) {</b>
<b class="nc"><i>310</i>&nbsp;                if (c[a2] &lt; (LINE_MIN)) {</b>
<b class="nc"><i>311</i>&nbsp;                    return CRES_INVISIBLE;</b>
<i>312</i>&nbsp;                };
<b class="nc"><i>313</i>&nbsp;                res = CRES_MIN_CLIPPED;</b>
<b class="nc"><i>314</i>&nbsp;                t = (LINE_MIN);</b>
<i>315</i>&nbsp;            } else {
<b class="nc"><i>316</i>&nbsp;                if (c[a2] &gt; (LINE_MAX)) {</b>
<b class="nc"><i>317</i>&nbsp;                    return CRES_INVISIBLE;</b>
<i>318</i>&nbsp;                };
<b class="nc"><i>319</i>&nbsp;                res = CRES_MAX_CLIPPED;</b>
<b class="nc"><i>320</i>&nbsp;                t = (LINE_MAX);</b>
<i>321</i>&nbsp;            }
<b class="nc"><i>322</i>&nbsp;            c[b1] = CLIP(c[a1], c[b1], c[a2], c[b2], t);</b>
<b class="nc"><i>323</i>&nbsp;            c[a1] = (float)t;</b>
<i>324</i>&nbsp;        }
<b class="nc"><i>325</i>&nbsp;        return res;</b>
<i>326</i>&nbsp;    }
<i>327</i>&nbsp;
<i>328</i>&nbsp;    /* Integer version of the method above */
<i>329</i>&nbsp;    private static int TESTANDCLIP(int LINE_MIN, int LINE_MAX, int[] c,
<i>330</i>&nbsp;                                   int a1, int b1, int a2, int b2) {
<i>331</i>&nbsp;        double t;
<b class="nc"><i>332</i>&nbsp;        int res = CRES_NOT_CLIPPED;</b>
<b class="nc"><i>333</i>&nbsp;        if (c[a1] &lt; (LINE_MIN) || c[a1] &gt; (LINE_MAX)) {</b>
<b class="nc"><i>334</i>&nbsp;            if (c[a1] &lt; (LINE_MIN)) {</b>
<b class="nc"><i>335</i>&nbsp;                if (c[a2] &lt; (LINE_MIN)) {</b>
<b class="nc"><i>336</i>&nbsp;                    return CRES_INVISIBLE;</b>
<i>337</i>&nbsp;                };
<b class="nc"><i>338</i>&nbsp;                res = CRES_MIN_CLIPPED;</b>
<b class="nc"><i>339</i>&nbsp;                t = (LINE_MIN);</b>
<i>340</i>&nbsp;            } else {
<b class="nc"><i>341</i>&nbsp;                if (c[a2] &gt; (LINE_MAX)) {</b>
<b class="nc"><i>342</i>&nbsp;                    return CRES_INVISIBLE;</b>
<i>343</i>&nbsp;                };
<b class="nc"><i>344</i>&nbsp;                res = CRES_MAX_CLIPPED;</b>
<b class="nc"><i>345</i>&nbsp;                t = (LINE_MAX);</b>
<i>346</i>&nbsp;            }
<b class="nc"><i>347</i>&nbsp;            c[b1] = CLIP(c[a1], c[b1], c[a2], c[b2], t);</b>
<b class="nc"><i>348</i>&nbsp;            c[a1] = (int)t;</b>
<i>349</i>&nbsp;        }
<b class="nc"><i>350</i>&nbsp;        return res;</b>
<i>351</i>&nbsp;    }
<i>352</i>&nbsp;
<i>353</i>&nbsp;
<i>354</i>&nbsp;
<i>355</i>&nbsp;    /* Following method is used for clipping and clumping filled shapes.
<i>356</i>&nbsp;     * An example of this process is shown on the picture below:
<i>357</i>&nbsp;     *                      ----+          ----+
<i>358</i>&nbsp;     *                    |/    |        |/    |
<i>359</i>&nbsp;     *                    +     |        +     |
<i>360</i>&nbsp;     *                   /|     |        I     |
<i>361</i>&nbsp;     *                  / |     |        I     |
<i>362</i>&nbsp;     *                  | |     |  ===&gt;  I     |
<i>363</i>&nbsp;     *                  \ |     |        I     |
<i>364</i>&nbsp;     *                   \|     |        I     |
<i>365</i>&nbsp;     *                    +     |        +     |
<i>366</i>&nbsp;     *                    |\    |        |\    |
<i>367</i>&nbsp;     *                    | ----+        | ----+
<i>368</i>&nbsp;     *                 boundary       boundary
<i>369</i>&nbsp;     *
<i>370</i>&nbsp;     * We can only perform clipping in case of right side of the output area
<i>371</i>&nbsp;     * because all segments passed out the right boundary don&#39;t influence on the
<i>372</i>&nbsp;     * result of scan conversion algorithm (it correctly handles half open
<i>373</i>&nbsp;     * contours).
<i>374</i>&nbsp;     *
<i>375</i>&nbsp;     * This is java implementation of the macro from ProcessGeneralPath.c.
<i>376</i>&nbsp;     * To keep the logic of the java code similar to the native one
<i>377</i>&nbsp;     * array and set of indexes are used to point out the data.
<i>378</i>&nbsp;     *
<i>379</i>&nbsp;     */
<i>380</i>&nbsp;    private static int CLIPCLAMP(float LINE_MIN, float LINE_MAX, float[] c,
<i>381</i>&nbsp;                                 int a1, int b1, int a2, int b2,
<i>382</i>&nbsp;                                 int a3, int b3) {
<b class="nc"><i>383</i>&nbsp;        c[a3] = c[a1];</b>
<b class="nc"><i>384</i>&nbsp;        c[b3] = c[b1];</b>
<b class="nc"><i>385</i>&nbsp;        int res = TESTANDCLIP(LINE_MIN, LINE_MAX, c, a1, b1, a2, b2);</b>
<b class="nc"><i>386</i>&nbsp;        if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>387</i>&nbsp;            c[a3] = c[a1];</b>
<b class="nc"><i>388</i>&nbsp;        } else if (res == CRES_MAX_CLIPPED) {</b>
<b class="nc"><i>389</i>&nbsp;            c[a3] = c[a1];</b>
<b class="nc"><i>390</i>&nbsp;            res = CRES_MAX_CLIPPED;</b>
<b class="nc"><i>391</i>&nbsp;        } else if (res == CRES_INVISIBLE) {</b>
<b class="nc"><i>392</i>&nbsp;            if (c[a1] &gt; LINE_MAX) {</b>
<b class="nc"><i>393</i>&nbsp;                res =  CRES_INVISIBLE;</b>
<i>394</i>&nbsp;            } else {
<b class="nc"><i>395</i>&nbsp;                c[a1] = LINE_MIN;</b>
<b class="nc"><i>396</i>&nbsp;                c[a2] = LINE_MIN;</b>
<b class="nc"><i>397</i>&nbsp;                res = CRES_NOT_CLIPPED;</b>
<i>398</i>&nbsp;            }
<i>399</i>&nbsp;        }
<b class="nc"><i>400</i>&nbsp;        return res;</b>
<i>401</i>&nbsp;    }
<i>402</i>&nbsp;
<i>403</i>&nbsp;    /* Integer version of the method above */
<i>404</i>&nbsp;    private static int CLIPCLAMP(int LINE_MIN, int LINE_MAX, int[] c,
<i>405</i>&nbsp;                                 int a1, int b1, int a2, int b2,
<i>406</i>&nbsp;                                 int a3, int b3) {
<b class="nc"><i>407</i>&nbsp;        c[a3] = c[a1];</b>
<b class="nc"><i>408</i>&nbsp;        c[b3] = c[b1];</b>
<b class="nc"><i>409</i>&nbsp;        int res = TESTANDCLIP(LINE_MIN, LINE_MAX, c, a1, b1, a2, b2);</b>
<b class="nc"><i>410</i>&nbsp;        if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>411</i>&nbsp;            c[a3] = c[a1];</b>
<b class="nc"><i>412</i>&nbsp;        } else if (res == CRES_MAX_CLIPPED) {</b>
<b class="nc"><i>413</i>&nbsp;            c[a3] = c[a1];</b>
<b class="nc"><i>414</i>&nbsp;            res = CRES_MAX_CLIPPED;</b>
<b class="nc"><i>415</i>&nbsp;        } else if (res == CRES_INVISIBLE) {</b>
<b class="nc"><i>416</i>&nbsp;            if (c[a1] &gt; LINE_MAX) {</b>
<b class="nc"><i>417</i>&nbsp;                res =  CRES_INVISIBLE;</b>
<i>418</i>&nbsp;            } else {
<b class="nc"><i>419</i>&nbsp;                c[a1] = LINE_MIN;</b>
<b class="nc"><i>420</i>&nbsp;                c[a2] = LINE_MIN;</b>
<b class="nc"><i>421</i>&nbsp;                res = CRES_NOT_CLIPPED;</b>
<i>422</i>&nbsp;            }
<i>423</i>&nbsp;        }
<b class="nc"><i>424</i>&nbsp;        return res;</b>
<i>425</i>&nbsp;    }
<i>426</i>&nbsp;
<i>427</i>&nbsp;    private static class DrawProcessHandler extends ProcessHandler {
<i>428</i>&nbsp;
<i>429</i>&nbsp;        EndSubPathHandler processESP;
<i>430</i>&nbsp;
<i>431</i>&nbsp;        public DrawProcessHandler(DrawHandler dhnd,
<i>432</i>&nbsp;                                  EndSubPathHandler processESP) {
<b class="nc"><i>433</i>&nbsp;            super(dhnd, PH_MODE_DRAW_CLIP);</b>
<b class="nc"><i>434</i>&nbsp;            this.dhnd = dhnd;</b>
<b class="nc"><i>435</i>&nbsp;            this.processESP = processESP;</b>
<i>436</i>&nbsp;        }
<i>437</i>&nbsp;
<i>438</i>&nbsp;        public void processEndSubPath() {
<b class="nc"><i>439</i>&nbsp;            processESP.processEndSubPath();</b>
<i>440</i>&nbsp;        }
<i>441</i>&nbsp;
<i>442</i>&nbsp;        void PROCESS_LINE(int fX0, int fY0, int fX1, int fY1,
<i>443</i>&nbsp;                          boolean checkBounds, int[] pixelInfo) {
<b class="nc"><i>444</i>&nbsp;            int X0 = fX0 &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>445</i>&nbsp;            int Y0 = fY0 &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>446</i>&nbsp;            int X1 = fX1 &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>447</i>&nbsp;            int Y1 = fY1 &gt;&gt; MDP_PREC;</b>
<i>448</i>&nbsp;
<i>449</i>&nbsp;           /* Handling lines having just one pixel */
<b class="nc"><i>450</i>&nbsp;            if (((X0^X1) | (Y0^Y1)) == 0) {</b>
<b class="nc"><i>451</i>&nbsp;                if (checkBounds &amp;&amp;</b>
<i>452</i>&nbsp;                    (dhnd.yMin &gt; Y0  ||
<i>453</i>&nbsp;                     dhnd.yMax &lt;= Y0 ||
<i>454</i>&nbsp;                     dhnd.xMin &gt; X0  ||
<i>455</i>&nbsp;                     dhnd.xMax &lt;= X0)) return;
<i>456</i>&nbsp;
<b class="nc"><i>457</i>&nbsp;                if (pixelInfo[0] == 0) {</b>
<b class="nc"><i>458</i>&nbsp;                    pixelInfo[0] = 1;</b>
<b class="nc"><i>459</i>&nbsp;                    pixelInfo[1] = X0;</b>
<b class="nc"><i>460</i>&nbsp;                    pixelInfo[2] = Y0;</b>
<b class="nc"><i>461</i>&nbsp;                    pixelInfo[3] = X0;</b>
<b class="nc"><i>462</i>&nbsp;                    pixelInfo[4] = Y0;</b>
<b class="nc"><i>463</i>&nbsp;                    dhnd.drawPixel(X0, Y0);</b>
<b class="nc"><i>464</i>&nbsp;                } else if ((X0 != pixelInfo[3] || Y0 != pixelInfo[4]) &amp;&amp;</b>
<i>465</i>&nbsp;                           (X0 != pixelInfo[1] || Y0 != pixelInfo[2])) {
<b class="nc"><i>466</i>&nbsp;                    dhnd.drawPixel(X0, Y0);</b>
<b class="nc"><i>467</i>&nbsp;                    pixelInfo[3] = X0;</b>
<b class="nc"><i>468</i>&nbsp;                    pixelInfo[4] = Y0;</b>
<i>469</i>&nbsp;                }
<i>470</i>&nbsp;                return;
<i>471</i>&nbsp;            }
<i>472</i>&nbsp;
<b class="nc"><i>473</i>&nbsp;            if (!checkBounds ||</b>
<i>474</i>&nbsp;                (dhnd.yMin &lt;= Y0  &amp;&amp;
<i>475</i>&nbsp;                 dhnd.yMax &gt; Y0 &amp;&amp;
<i>476</i>&nbsp;                 dhnd.xMin &lt;= X0  &amp;&amp;
<i>477</i>&nbsp;                 dhnd.xMax &gt; X0))
<i>478</i>&nbsp;            {
<i>479</i>&nbsp;                /* Switch off first pixel of the line before drawing */
<b class="nc"><i>480</i>&nbsp;                if (pixelInfo[0] == 1 &amp;&amp;</b>
<i>481</i>&nbsp;                    ((pixelInfo[1] == X0 &amp;&amp; pixelInfo[2] == Y0) ||
<i>482</i>&nbsp;                     (pixelInfo[3] == X0 &amp;&amp; pixelInfo[4] == Y0)))
<i>483</i>&nbsp;                {
<b class="nc"><i>484</i>&nbsp;                    dhnd.drawPixel(X0, Y0);</b>
<i>485</i>&nbsp;                }
<i>486</i>&nbsp;            }
<i>487</i>&nbsp;
<b class="nc"><i>488</i>&nbsp;            dhnd.drawLine(X0, Y0, X1, Y1);</b>
<i>489</i>&nbsp;
<b class="nc"><i>490</i>&nbsp;            if (pixelInfo[0] == 0) {</b>
<b class="nc"><i>491</i>&nbsp;                pixelInfo[0] = 1;</b>
<b class="nc"><i>492</i>&nbsp;                pixelInfo[1] = X0;</b>
<b class="nc"><i>493</i>&nbsp;                pixelInfo[2] = Y0;</b>
<b class="nc"><i>494</i>&nbsp;                pixelInfo[3] = X0;</b>
<b class="nc"><i>495</i>&nbsp;                pixelInfo[4] = Y0;</b>
<i>496</i>&nbsp;            }
<i>497</i>&nbsp;
<i>498</i>&nbsp;            /* Switch on last pixel of the line if it was already
<i>499</i>&nbsp;             * drawn during rendering of the previous segments
<i>500</i>&nbsp;             */
<b class="nc"><i>501</i>&nbsp;            if ((pixelInfo[1] == X1 &amp;&amp; pixelInfo[2] == Y1) ||</b>
<i>502</i>&nbsp;                (pixelInfo[3] == X1 &amp;&amp; pixelInfo[4] == Y1))
<i>503</i>&nbsp;            {
<b class="nc"><i>504</i>&nbsp;                if (checkBounds &amp;&amp;</b>
<i>505</i>&nbsp;                    (dhnd.yMin &gt; Y1  ||
<i>506</i>&nbsp;                     dhnd.yMax &lt;= Y1 ||
<i>507</i>&nbsp;                     dhnd.xMin &gt; X1  ||
<i>508</i>&nbsp;                     dhnd.xMax &lt;= X1)) {
<i>509</i>&nbsp;                    return;
<i>510</i>&nbsp;                }
<i>511</i>&nbsp;
<b class="nc"><i>512</i>&nbsp;                dhnd.drawPixel(X1, Y1);</b>
<i>513</i>&nbsp;            }
<b class="nc"><i>514</i>&nbsp;            pixelInfo[3] = X1;</b>
<b class="nc"><i>515</i>&nbsp;            pixelInfo[4] = Y1;</b>
<i>516</i>&nbsp;        }
<i>517</i>&nbsp;
<i>518</i>&nbsp;        void PROCESS_POINT(int fX, int fY, boolean checkBounds,
<i>519</i>&nbsp;                           int[] pixelInfo) {
<b class="nc"><i>520</i>&nbsp;            int _X = fX&gt;&gt; MDP_PREC;</b>
<b class="nc"><i>521</i>&nbsp;            int _Y = fY&gt;&gt; MDP_PREC;</b>
<b class="nc"><i>522</i>&nbsp;            if (checkBounds &amp;&amp;</b>
<i>523</i>&nbsp;                (dhnd.yMin &gt; _Y  ||
<i>524</i>&nbsp;                 dhnd.yMax &lt;= _Y ||
<i>525</i>&nbsp;                 dhnd.xMin &gt; _X  ||
<i>526</i>&nbsp;                 dhnd.xMax &lt;= _X)) return;
<i>527</i>&nbsp;            /*
<i>528</i>&nbsp;             *  (_X,_Y) should be inside boundaries
<i>529</i>&nbsp;             *
<i>530</i>&nbsp;             *  assert(dhnd.yMin &lt;= _Y &amp;&amp;
<i>531</i>&nbsp;             *         dhnd.yMax &gt;  _Y &amp;&amp;
<i>532</i>&nbsp;             *         dhnd.xMin &lt;= _X &amp;&amp;
<i>533</i>&nbsp;             *         dhnd.xMax &gt;  _X);
<i>534</i>&nbsp;             *
<i>535</i>&nbsp;             */
<b class="nc"><i>536</i>&nbsp;            if (pixelInfo[0] == 0) {</b>
<b class="nc"><i>537</i>&nbsp;                pixelInfo[0] = 1;</b>
<b class="nc"><i>538</i>&nbsp;                pixelInfo[1] = _X;</b>
<b class="nc"><i>539</i>&nbsp;                pixelInfo[2] = _Y;</b>
<b class="nc"><i>540</i>&nbsp;                pixelInfo[3] = _X;</b>
<b class="nc"><i>541</i>&nbsp;                pixelInfo[4] = _Y;</b>
<b class="nc"><i>542</i>&nbsp;                dhnd.drawPixel(_X, _Y);</b>
<b class="nc"><i>543</i>&nbsp;            } else if ((_X != pixelInfo[3] || _Y != pixelInfo[4]) &amp;&amp;</b>
<i>544</i>&nbsp;                       (_X != pixelInfo[1] || _Y != pixelInfo[2])) {
<b class="nc"><i>545</i>&nbsp;                dhnd.drawPixel(_X, _Y);</b>
<b class="nc"><i>546</i>&nbsp;                pixelInfo[3] = _X;</b>
<b class="nc"><i>547</i>&nbsp;                pixelInfo[4] = _Y;</b>
<i>548</i>&nbsp;            }
<i>549</i>&nbsp;        }
<i>550</i>&nbsp;
<i>551</i>&nbsp;        /*                  Drawing line with subpixel endpoints
<i>552</i>&nbsp;         *
<i>553</i>&nbsp;         * (x1, y1), (x2, y2) -  fixed point coordinates of the endpoints
<i>554</i>&nbsp;         *                       with MDP_PREC bits for the fractional part
<i>555</i>&nbsp;         *
<i>556</i>&nbsp;         * pixelInfo          -  structure which keeps drawing info for avoiding
<i>557</i>&nbsp;         *                       multiple drawing at the same position on the
<i>558</i>&nbsp;         *                       screen (required for the XOR mode of drawing)
<i>559</i>&nbsp;         *
<i>560</i>&nbsp;         *                          pixelInfo[0]   - state of the drawing
<i>561</i>&nbsp;         *                                           0 - no pixel drawn between
<i>562</i>&nbsp;         *                                           moveTo/close of the path
<i>563</i>&nbsp;         *                                           1 - there are drawn pixels
<i>564</i>&nbsp;         *
<i>565</i>&nbsp;         *                          pixelInfo[1,2] - first pixel of the path
<i>566</i>&nbsp;         *                                           between moveTo/close of the
<i>567</i>&nbsp;         *                                           path
<i>568</i>&nbsp;         *
<i>569</i>&nbsp;         *                          pixelInfo[3,4] - last drawn pixel between
<i>570</i>&nbsp;         *                                           moveTo/close of the path
<i>571</i>&nbsp;         *
<i>572</i>&nbsp;         * checkBounds        - flag showing necessity of checking the clip
<i>573</i>&nbsp;         *
<i>574</i>&nbsp;         */
<i>575</i>&nbsp;        public void  processFixedLine(int x1, int y1, int x2, int y2,
<i>576</i>&nbsp;                                      int[] pixelInfo, boolean checkBounds,
<i>577</i>&nbsp;                                      boolean endSubPath)  {
<i>578</i>&nbsp;
<i>579</i>&nbsp;            /* Checking if line is inside a (X,Y),(X+MDP_MULT,Y+MDP_MULT) box */
<b class="nc"><i>580</i>&nbsp;            int c = ((x1 ^ x2) | (y1 ^ y2));</b>
<i>581</i>&nbsp;            int rx1, ry1, rx2, ry2;
<b class="nc"><i>582</i>&nbsp;            if ((c &amp; MDP_W_MASK) == 0) {</b>
<i>583</i>&nbsp;                /* Checking for the segments with integer coordinates having
<i>584</i>&nbsp;                 * the same start and end points
<i>585</i>&nbsp;                 */
<b class="nc"><i>586</i>&nbsp;                if (c == 0) {</b>
<b class="nc"><i>587</i>&nbsp;                    PROCESS_POINT(x1 + MDP_HALF_MULT, y1 + MDP_HALF_MULT,</b>
<i>588</i>&nbsp;                                  checkBounds, pixelInfo);
<i>589</i>&nbsp;                }
<i>590</i>&nbsp;                return;
<i>591</i>&nbsp;            }
<i>592</i>&nbsp;
<b class="nc"><i>593</i>&nbsp;            if (x1 == x2 || y1 == y2) {</b>
<b class="nc"><i>594</i>&nbsp;                rx1 = x1 + MDP_HALF_MULT;</b>
<b class="nc"><i>595</i>&nbsp;                rx2 = x2 + MDP_HALF_MULT;</b>
<b class="nc"><i>596</i>&nbsp;                ry1 = y1 + MDP_HALF_MULT;</b>
<b class="nc"><i>597</i>&nbsp;                ry2 = y2 + MDP_HALF_MULT;</b>
<i>598</i>&nbsp;            } else {
<i>599</i>&nbsp;                /* Neither dx nor dy can be zero because of the check above */
<b class="nc"><i>600</i>&nbsp;                int dx = x2 - x1;</b>
<b class="nc"><i>601</i>&nbsp;                int dy = y2 - y1;</b>
<i>602</i>&nbsp;
<i>603</i>&nbsp;                /* Floor of x1, y1, x2, y2 */
<b class="nc"><i>604</i>&nbsp;                int fx1 = x1 &amp; MDP_W_MASK;</b>
<b class="nc"><i>605</i>&nbsp;                int fy1 = y1 &amp; MDP_W_MASK;</b>
<b class="nc"><i>606</i>&nbsp;                int fx2 = x2 &amp; MDP_W_MASK;</b>
<b class="nc"><i>607</i>&nbsp;                int fy2 = y2 &amp; MDP_W_MASK;</b>
<i>608</i>&nbsp;
<i>609</i>&nbsp;                /* Processing first endpoint */
<b class="nc"><i>610</i>&nbsp;                if (fx1 == x1 || fy1 == y1) {</b>
<i>611</i>&nbsp;                    /* Adding MDP_HALF_MULT to the [xy]1 if f[xy]1 == [xy]1
<i>612</i>&nbsp;                     * will not affect the result
<i>613</i>&nbsp;                     */
<b class="nc"><i>614</i>&nbsp;                    rx1 = x1 + MDP_HALF_MULT;</b>
<b class="nc"><i>615</i>&nbsp;                    ry1 = y1 + MDP_HALF_MULT;</b>
<i>616</i>&nbsp;                } else {
<i>617</i>&nbsp;                    /* Boundary at the direction from (x1,y1) to (x2,y2) */
<b class="nc"><i>618</i>&nbsp;                    int bx1 = (x1 &lt; x2) ? fx1 + MDP_MULT : fx1;</b>
<b class="nc"><i>619</i>&nbsp;                    int by1 = (y1 &lt; y2) ? fy1 + MDP_MULT : fy1;</b>
<i>620</i>&nbsp;
<i>621</i>&nbsp;                    /* intersection with column bx1 */
<b class="nc"><i>622</i>&nbsp;                    int cross = y1 + ((bx1 - x1)*dy)/dx;</b>
<b class="nc"><i>623</i>&nbsp;                    if (cross &gt;= fy1 &amp;&amp; cross &lt;= fy1 + MDP_MULT) {</b>
<b class="nc"><i>624</i>&nbsp;                        rx1 = bx1;</b>
<b class="nc"><i>625</i>&nbsp;                        ry1 = cross + MDP_HALF_MULT;</b>
<i>626</i>&nbsp;                    } else {
<i>627</i>&nbsp;                        /* intersection with row by1 */
<b class="nc"><i>628</i>&nbsp;                        cross = x1 + ((by1 - y1)*dx)/dy;</b>
<b class="nc"><i>629</i>&nbsp;                        rx1 = cross + MDP_HALF_MULT;</b>
<b class="nc"><i>630</i>&nbsp;                        ry1 = by1;</b>
<i>631</i>&nbsp;                    }
<i>632</i>&nbsp;                }
<i>633</i>&nbsp;
<i>634</i>&nbsp;                /* Processing second endpoint */
<b class="nc"><i>635</i>&nbsp;                if (fx2 == x2 || fy2 == y2) {</b>
<i>636</i>&nbsp;                    /* Adding MDP_HALF_MULT to the [xy]2 if f[xy]2 == [xy]2
<i>637</i>&nbsp;                     * will not affect the result
<i>638</i>&nbsp;                     */
<b class="nc"><i>639</i>&nbsp;                    rx2 = x2 + MDP_HALF_MULT;</b>
<b class="nc"><i>640</i>&nbsp;                    ry2 = y2 + MDP_HALF_MULT;</b>
<i>641</i>&nbsp;                } else {
<i>642</i>&nbsp;                    /* Boundary at the direction from (x2,y2) to (x1,y1) */
<b class="nc"><i>643</i>&nbsp;                    int bx2 = (x1 &gt; x2) ? fx2 + MDP_MULT : fx2;</b>
<b class="nc"><i>644</i>&nbsp;                    int by2 = (y1 &gt; y2) ? fy2 + MDP_MULT : fy2;</b>
<i>645</i>&nbsp;
<i>646</i>&nbsp;                    /* intersection with column bx2 */
<b class="nc"><i>647</i>&nbsp;                    int cross = y2 + ((bx2 - x2)*dy)/dx;</b>
<b class="nc"><i>648</i>&nbsp;                    if (cross &gt;= fy2 &amp;&amp; cross &lt;= fy2 + MDP_MULT) {</b>
<b class="nc"><i>649</i>&nbsp;                        rx2 = bx2;</b>
<b class="nc"><i>650</i>&nbsp;                        ry2 = cross + MDP_HALF_MULT;</b>
<i>651</i>&nbsp;                    } else {
<i>652</i>&nbsp;                        /* intersection with row by2 */
<b class="nc"><i>653</i>&nbsp;                        cross = x2 + ((by2 - y2)*dx)/dy;</b>
<b class="nc"><i>654</i>&nbsp;                        rx2 = cross + MDP_HALF_MULT;</b>
<b class="nc"><i>655</i>&nbsp;                        ry2 = by2;</b>
<i>656</i>&nbsp;                    }
<i>657</i>&nbsp;                }
<i>658</i>&nbsp;            }
<b class="nc"><i>659</i>&nbsp;            PROCESS_LINE(rx1, ry1, rx2, ry2, checkBounds, pixelInfo);</b>
<i>660</i>&nbsp;        }
<i>661</i>&nbsp;    }
<i>662</i>&nbsp;
<i>663</i>&nbsp;    /* Performing drawing of the monotonic in X and Y quadratic curves with
<i>664</i>&nbsp;     * sizes less than MAX_QUAD_SIZE by using forward differencing method of
<i>665</i>&nbsp;     * calculation. See comments to the DrawMonotonicQuad in the
<i>666</i>&nbsp;     * ProcessGeneralPath.c
<i>667</i>&nbsp;     */
<i>668</i>&nbsp;    private static void DrawMonotonicQuad(ProcessHandler hnd,
<i>669</i>&nbsp;                                          float[] coords,
<i>670</i>&nbsp;                                          boolean checkBounds,
<i>671</i>&nbsp;                                          int[] pixelInfo) {
<i>672</i>&nbsp;
<b class="nc"><i>673</i>&nbsp;        int x0 = (int)(coords[0]*MDP_MULT);</b>
<b class="nc"><i>674</i>&nbsp;        int y0 = (int)(coords[1]*MDP_MULT);</b>
<i>675</i>&nbsp;
<b class="nc"><i>676</i>&nbsp;        int xe = (int)(coords[4]*MDP_MULT);</b>
<b class="nc"><i>677</i>&nbsp;        int ye = (int)(coords[5]*MDP_MULT);</b>
<i>678</i>&nbsp;
<i>679</i>&nbsp;        /* Extracting fractional part of coordinates of first control point */
<b class="nc"><i>680</i>&nbsp;        int px = (x0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_QUAD_SHIFT;</b>
<b class="nc"><i>681</i>&nbsp;        int py = (y0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_QUAD_SHIFT;</b>
<i>682</i>&nbsp;
<i>683</i>&nbsp;        /* Setting default amount of steps */
<b class="nc"><i>684</i>&nbsp;        int count = DF_QUAD_COUNT;</b>
<i>685</i>&nbsp;
<i>686</i>&nbsp;        /* Setting default shift for preparing to the midpoint rounding */
<b class="nc"><i>687</i>&nbsp;        int shift =  DF_QUAD_SHIFT;</b>
<i>688</i>&nbsp;
<b class="nc"><i>689</i>&nbsp;        int ax = (int)((coords[0] - 2*coords[2] +</b>
<i>690</i>&nbsp;                         coords[4])*QUAD_A_MDP_MULT);
<b class="nc"><i>691</i>&nbsp;        int ay = (int)((coords[1] - 2*coords[3] +</b>
<i>692</i>&nbsp;                         coords[5])*QUAD_A_MDP_MULT);
<i>693</i>&nbsp;
<b class="nc"><i>694</i>&nbsp;        int bx = (int)((-2*coords[0] + 2*coords[2])*QUAD_B_MDP_MULT);</b>
<b class="nc"><i>695</i>&nbsp;        int by = (int)((-2*coords[1] + 2*coords[3])*QUAD_B_MDP_MULT);</b>
<i>696</i>&nbsp;
<b class="nc"><i>697</i>&nbsp;        int ddpx = 2*ax;</b>
<b class="nc"><i>698</i>&nbsp;        int ddpy = 2*ay;</b>
<i>699</i>&nbsp;
<b class="nc"><i>700</i>&nbsp;        int dpx = ax + bx;</b>
<b class="nc"><i>701</i>&nbsp;        int dpy = ay + by;</b>
<i>702</i>&nbsp;
<i>703</i>&nbsp;        int x1, y1;
<i>704</i>&nbsp;
<b class="nc"><i>705</i>&nbsp;        int x2 = x0;</b>
<b class="nc"><i>706</i>&nbsp;        int y2 = y0;</b>
<i>707</i>&nbsp;
<b class="nc"><i>708</i>&nbsp;        int maxDD = Math.max(Math.abs(ddpx),Math.abs(ddpy));</b>
<i>709</i>&nbsp;
<b class="nc"><i>710</i>&nbsp;        int dx = xe - x0;</b>
<b class="nc"><i>711</i>&nbsp;        int dy = ye - y0;</b>
<i>712</i>&nbsp;
<b class="nc"><i>713</i>&nbsp;        int x0w = x0 &amp; MDP_W_MASK;</b>
<b class="nc"><i>714</i>&nbsp;        int y0w = y0 &amp; MDP_W_MASK;</b>
<i>715</i>&nbsp;
<i>716</i>&nbsp;        /* Perform decreasing step in 2 times if slope of the first forward
<i>717</i>&nbsp;         * difference changes too quickly (more than a pixel per step in X or Y
<i>718</i>&nbsp;         * direction).  We can perform adjusting of the step size before the
<i>719</i>&nbsp;         * rendering loop because the curvature of the quad curve remains the
<i>720</i>&nbsp;         * same along all the curve
<i>721</i>&nbsp;         */
<b class="nc"><i>722</i>&nbsp;        while (maxDD &gt; DF_QUAD_DEC_BND) {</b>
<b class="nc"><i>723</i>&nbsp;            dpx = (dpx&lt;&lt;1) - ax;</b>
<b class="nc"><i>724</i>&nbsp;            dpy = (dpy&lt;&lt;1) - ay;</b>
<b class="nc"><i>725</i>&nbsp;            count &lt;&lt;= 1;</b>
<b class="nc"><i>726</i>&nbsp;            maxDD &gt;&gt;= 2;</b>
<b class="nc"><i>727</i>&nbsp;            px &lt;&lt;=2;</b>
<b class="nc"><i>728</i>&nbsp;            py &lt;&lt;=2;</b>
<b class="nc"><i>729</i>&nbsp;            shift += 2;</b>
<i>730</i>&nbsp;        }
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;        while(count-- &gt; 1) {</b>
<b class="nc"><i>733</i>&nbsp;            px += dpx;</b>
<b class="nc"><i>734</i>&nbsp;            py += dpy;</b>
<i>735</i>&nbsp;
<b class="nc"><i>736</i>&nbsp;            dpx += ddpx;</b>
<b class="nc"><i>737</i>&nbsp;            dpy += ddpy;</b>
<i>738</i>&nbsp;
<b class="nc"><i>739</i>&nbsp;            x1 = x2;</b>
<b class="nc"><i>740</i>&nbsp;            y1 = y2;</b>
<i>741</i>&nbsp;
<b class="nc"><i>742</i>&nbsp;            x2 = x0w + (px &gt;&gt; shift);</b>
<b class="nc"><i>743</i>&nbsp;            y2 = y0w + (py &gt;&gt; shift);</b>
<i>744</i>&nbsp;
<i>745</i>&nbsp;            /* Checking that we are not running out of the endpoint and bounding
<i>746</i>&nbsp;             * violating coordinate.  The check is pretty simple because the
<i>747</i>&nbsp;             * curve passed to the DrawCubic already split into the
<i>748</i>&nbsp;             * monotonic in X and Y pieces
<i>749</i>&nbsp;             */
<i>750</i>&nbsp;
<i>751</i>&nbsp;            /* Bounding x2 by xe */
<b class="nc"><i>752</i>&nbsp;            if (((xe-x2)^dx) &lt; 0) {</b>
<b class="nc"><i>753</i>&nbsp;                x2 = xe;</b>
<i>754</i>&nbsp;            }
<i>755</i>&nbsp;
<i>756</i>&nbsp;            /* Bounding y2 by ye */
<b class="nc"><i>757</i>&nbsp;            if (((ye-y2)^dy) &lt; 0) {</b>
<b class="nc"><i>758</i>&nbsp;                y2 = ye;</b>
<i>759</i>&nbsp;            }
<i>760</i>&nbsp;
<b class="nc"><i>761</i>&nbsp;            hnd.processFixedLine(x1, y1, x2, y2, pixelInfo, checkBounds, false);</b>
<i>762</i>&nbsp;        }
<i>763</i>&nbsp;
<i>764</i>&nbsp;        /* We are performing one step less than necessary and use actual
<i>765</i>&nbsp;         * (xe,ye) endpoint of the curve instead of calculated. This prevent us
<i>766</i>&nbsp;         * from running above the curve endpoint due to the accumulated errors
<i>767</i>&nbsp;         * during the iterations.
<i>768</i>&nbsp;         */
<i>769</i>&nbsp;
<b class="nc"><i>770</i>&nbsp;        hnd.processFixedLine(x2, y2, xe, ye, pixelInfo, checkBounds, false);</b>
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /*
<i>774</i>&nbsp;     * Checking size of the quad curves and split them if necessary.
<i>775</i>&nbsp;     * Calling DrawMonotonicQuad for the curves of the appropriate size.
<i>776</i>&nbsp;     * Note: coords array could be changed
<i>777</i>&nbsp;     */
<i>778</i>&nbsp;    private static void ProcessMonotonicQuad(ProcessHandler hnd,
<i>779</i>&nbsp;                                             float[] coords,
<i>780</i>&nbsp;                                             int[] pixelInfo) {
<i>781</i>&nbsp;
<b class="nc"><i>782</i>&nbsp;        float[] coords1 = new float[6];</b>
<i>783</i>&nbsp;        float tx, ty;
<i>784</i>&nbsp;        float xMin, yMin, xMax, yMax;
<i>785</i>&nbsp;
<b class="nc"><i>786</i>&nbsp;        xMin = xMax = coords[0];</b>
<b class="nc"><i>787</i>&nbsp;        yMin = yMax = coords[1];</b>
<b class="nc"><i>788</i>&nbsp;        for (int i = 2; i &lt; 6; i += 2) {</b>
<b class="nc"><i>789</i>&nbsp;            xMin = (xMin &gt; coords[i])? coords[i] : xMin;</b>
<b class="nc"><i>790</i>&nbsp;            xMax = (xMax &lt; coords[i])? coords[i] : xMax;</b>
<b class="nc"><i>791</i>&nbsp;            yMin = (yMin &gt; coords[i + 1])? coords[i + 1] : yMin;</b>
<b class="nc"><i>792</i>&nbsp;            yMax = (yMax &lt; coords[i + 1])? coords[i + 1] : yMax;</b>
<i>793</i>&nbsp;        }
<i>794</i>&nbsp;
<b class="nc"><i>795</i>&nbsp;        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</b>
<i>796</i>&nbsp;
<i>797</i>&nbsp;           /* In case of drawing we could just skip curves which are
<i>798</i>&nbsp;            * completely out of bounds
<i>799</i>&nbsp;            */
<b class="nc"><i>800</i>&nbsp;           if (hnd.dhnd.xMaxf &lt; xMin || hnd.dhnd.xMinf &gt; xMax ||</b>
<i>801</i>&nbsp;               hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax) {
<i>802</i>&nbsp;               return;
<i>803</i>&nbsp;           }
<i>804</i>&nbsp;        } else {
<i>805</i>&nbsp;
<i>806</i>&nbsp;            /* In case of filling we could skip curves which are above,
<i>807</i>&nbsp;             * below and behind the right boundary of the visible area
<i>808</i>&nbsp;             */
<i>809</i>&nbsp;
<b class="nc"><i>810</i>&nbsp;            if (hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax ||</b>
<i>811</i>&nbsp;                hnd.dhnd.xMaxf &lt; xMin)
<i>812</i>&nbsp;            {
<i>813</i>&nbsp;                return;
<i>814</i>&nbsp;            }
<i>815</i>&nbsp;
<i>816</i>&nbsp;            /* We could clamp x coordinates to the corresponding boundary
<i>817</i>&nbsp;             * if the curve is completely behind the left one
<i>818</i>&nbsp;             */
<i>819</i>&nbsp;
<b class="nc"><i>820</i>&nbsp;            if (hnd.dhnd.xMinf &gt; xMax) {</b>
<b class="nc"><i>821</i>&nbsp;                coords[0] = coords[2] = coords[4] = hnd.dhnd.xMinf;</b>
<i>822</i>&nbsp;            }
<i>823</i>&nbsp;        }
<i>824</i>&nbsp;
<b class="nc"><i>825</i>&nbsp;        if (xMax - xMin &gt; MAX_QUAD_SIZE || yMax - yMin &gt; MAX_QUAD_SIZE) {</b>
<b class="nc"><i>826</i>&nbsp;            coords1[4] = coords[4];</b>
<b class="nc"><i>827</i>&nbsp;            coords1[5] = coords[5];</b>
<b class="nc"><i>828</i>&nbsp;            coords1[2] = (coords[2] + coords[4])/2.0f;</b>
<b class="nc"><i>829</i>&nbsp;            coords1[3] = (coords[3] + coords[5])/2.0f;</b>
<b class="nc"><i>830</i>&nbsp;            coords[2] = (coords[0] + coords[2])/2.0f;</b>
<b class="nc"><i>831</i>&nbsp;            coords[3] = (coords[1] + coords[3])/2.0f;</b>
<b class="nc"><i>832</i>&nbsp;            coords[4] = coords1[0] = (coords[2] + coords1[2])/2.0f;</b>
<b class="nc"><i>833</i>&nbsp;            coords[5] = coords1[1] = (coords[3] + coords1[3])/2.0f;</b>
<i>834</i>&nbsp;
<b class="nc"><i>835</i>&nbsp;            ProcessMonotonicQuad(hnd, coords, pixelInfo);</b>
<i>836</i>&nbsp;
<b class="nc"><i>837</i>&nbsp;            ProcessMonotonicQuad(hnd, coords1, pixelInfo);</b>
<i>838</i>&nbsp;        } else {
<b class="nc"><i>839</i>&nbsp;            DrawMonotonicQuad(hnd, coords,</b>
<i>840</i>&nbsp;                              /* Set checkBounds parameter if curve intersects
<i>841</i>&nbsp;                               * boundary of the visible area. We know that the
<i>842</i>&nbsp;                               * curve is visible, so the check is pretty
<i>843</i>&nbsp;                               * simple
<i>844</i>&nbsp;                               */
<i>845</i>&nbsp;                              hnd.dhnd.xMinf &gt;= xMin ||
<i>846</i>&nbsp;                              hnd.dhnd.xMaxf &lt;= xMax ||
<i>847</i>&nbsp;                              hnd.dhnd.yMinf &gt;= yMin ||
<i>848</i>&nbsp;                              hnd.dhnd.yMaxf &lt;= yMax,
<i>849</i>&nbsp;                              pixelInfo);
<i>850</i>&nbsp;        }
<i>851</i>&nbsp;    }
<i>852</i>&nbsp;
<i>853</i>&nbsp;    /*
<i>854</i>&nbsp;     * Split quadratic curve into monotonic in X and Y parts. Calling
<i>855</i>&nbsp;     * ProcessMonotonicQuad for each monotonic piece of the curve.
<i>856</i>&nbsp;     * Note: coords array could be changed
<i>857</i>&nbsp;     */
<i>858</i>&nbsp;    private static void ProcessQuad(ProcessHandler hnd, float[] coords,
<i>859</i>&nbsp;                                    int[] pixelInfo) {
<i>860</i>&nbsp;        /* Temporary array for holding parameters corresponding to the extreme
<i>861</i>&nbsp;         * in X and Y points
<i>862</i>&nbsp;         */
<b class="nc"><i>863</i>&nbsp;        double params[] = new double[2];</b>
<b class="nc"><i>864</i>&nbsp;        int cnt = 0;</b>
<i>865</i>&nbsp;        double param;
<i>866</i>&nbsp;
<i>867</i>&nbsp;        /* Simple check for monotonicity in X before searching for the extreme
<i>868</i>&nbsp;         * points of the X(t) function. We first check if the curve is
<i>869</i>&nbsp;         * monotonic in X by seeing if all of the X coordinates are strongly
<i>870</i>&nbsp;         * ordered.
<i>871</i>&nbsp;         */
<b class="nc"><i>872</i>&nbsp;        if ((coords[0] &gt; coords[2] || coords[2] &gt; coords[4]) &amp;&amp;</b>
<i>873</i>&nbsp;            (coords[0] &lt; coords[2] || coords[2] &lt; coords[4]))
<i>874</i>&nbsp;        {
<i>875</i>&nbsp;            /* Searching for extreme points of the X(t) function  by solving
<i>876</i>&nbsp;             * dX(t)
<i>877</i>&nbsp;             * ----  = 0 equation
<i>878</i>&nbsp;             *  dt
<i>879</i>&nbsp;             */
<b class="nc"><i>880</i>&nbsp;            double ax = coords[0] - 2*coords[2] + coords[4];</b>
<b class="nc"><i>881</i>&nbsp;            if (ax != 0) {</b>
<i>882</i>&nbsp;                /* Calculating root of the following equation
<i>883</i>&nbsp;                 * ax*t + bx = 0
<i>884</i>&nbsp;                 */
<b class="nc"><i>885</i>&nbsp;                double bx = coords[0] - coords[2];</b>
<i>886</i>&nbsp;
<b class="nc"><i>887</i>&nbsp;                param = bx/ax;</b>
<b class="nc"><i>888</i>&nbsp;                if (param &lt; 1.0 &amp;&amp; param &gt; 0.0) {</b>
<b class="nc"><i>889</i>&nbsp;                    params[cnt++] = param;</b>
<i>890</i>&nbsp;                }
<i>891</i>&nbsp;            }
<i>892</i>&nbsp;        }
<i>893</i>&nbsp;
<i>894</i>&nbsp;        /* Simple check for monotonicity in Y before searching for the extreme
<i>895</i>&nbsp;         * points of the Y(t) function. We first check if the curve is
<i>896</i>&nbsp;         * monotonic in Y by seeing if all of the Y coordinates are strongly
<i>897</i>&nbsp;         * ordered.
<i>898</i>&nbsp;         */
<b class="nc"><i>899</i>&nbsp;        if ((coords[1] &gt; coords[3] || coords[3] &gt; coords[5]) &amp;&amp;</b>
<i>900</i>&nbsp;            (coords[1] &lt; coords[3] || coords[3] &lt; coords[5]))
<i>901</i>&nbsp;        {
<i>902</i>&nbsp;            /* Searching for extreme points of the Y(t) function by solving
<i>903</i>&nbsp;             * dY(t)
<i>904</i>&nbsp;             * ----- = 0 equation
<i>905</i>&nbsp;             *  dt
<i>906</i>&nbsp;             */
<b class="nc"><i>907</i>&nbsp;            double ay = coords[1] - 2*coords[3] + coords[5];</b>
<i>908</i>&nbsp;
<b class="nc"><i>909</i>&nbsp;            if (ay != 0) {</b>
<i>910</i>&nbsp;                /* Calculating root of the following equation
<i>911</i>&nbsp;                 * ay*t + by = 0
<i>912</i>&nbsp;                 */
<b class="nc"><i>913</i>&nbsp;                double by = coords[1] - coords[3];</b>
<i>914</i>&nbsp;
<b class="nc"><i>915</i>&nbsp;                param = by/ay;</b>
<b class="nc"><i>916</i>&nbsp;                if (param &lt; 1.0 &amp;&amp; param &gt; 0.0) {</b>
<b class="nc"><i>917</i>&nbsp;                    if (cnt &gt; 0) {</b>
<i>918</i>&nbsp;                        /* Inserting parameter only if it differs from
<i>919</i>&nbsp;                         * already stored
<i>920</i>&nbsp;                         */
<b class="nc"><i>921</i>&nbsp;                        if (params[0] &gt;  param) {</b>
<b class="nc"><i>922</i>&nbsp;                            params[cnt++] = params[0];</b>
<b class="nc"><i>923</i>&nbsp;                            params[0] = param;</b>
<b class="nc"><i>924</i>&nbsp;                        } else if (params[0] &lt;  param) {</b>
<b class="nc"><i>925</i>&nbsp;                            params[cnt++] = param;</b>
<i>926</i>&nbsp;                        }
<i>927</i>&nbsp;                    } else {
<b class="nc"><i>928</i>&nbsp;                        params[cnt++] = param;</b>
<i>929</i>&nbsp;                    }
<i>930</i>&nbsp;                }
<i>931</i>&nbsp;            }
<i>932</i>&nbsp;        }
<i>933</i>&nbsp;
<i>934</i>&nbsp;        /* Processing obtained monotonic parts */
<b class="nc"><i>935</i>&nbsp;        switch(cnt) {</b>
<i>936</i>&nbsp;            case 0:
<b class="nc"><i>937</i>&nbsp;                break;</b>
<i>938</i>&nbsp;            case 1:
<b class="nc"><i>939</i>&nbsp;                ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</b>
<i>940</i>&nbsp;                                                (float)params[0]);
<b class="nc"><i>941</i>&nbsp;                break;</b>
<i>942</i>&nbsp;            case 2:
<b class="nc"><i>943</i>&nbsp;                ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</b>
<i>944</i>&nbsp;                                                (float)params[0]);
<b class="nc"><i>945</i>&nbsp;                param = params[1] - params[0];</b>
<b class="nc"><i>946</i>&nbsp;                if (param &gt; 0) {</b>
<b class="nc"><i>947</i>&nbsp;                    ProcessFirstMonotonicPartOfQuad(hnd, coords, pixelInfo,</b>
<i>948</i>&nbsp;                                           /* Scale parameter to match with
<i>949</i>&nbsp;                                            * rest of the curve
<i>950</i>&nbsp;                                            */
<i>951</i>&nbsp;                                           (float)(param/(1.0 - params[0])));
<i>952</i>&nbsp;                }
<i>953</i>&nbsp;                break;
<i>954</i>&nbsp;        }
<i>955</i>&nbsp;
<b class="nc"><i>956</i>&nbsp;        ProcessMonotonicQuad(hnd,coords,pixelInfo);</b>
<i>957</i>&nbsp;    }
<i>958</i>&nbsp;
<i>959</i>&nbsp;    /*
<i>960</i>&nbsp;     * Bite the piece of the quadratic curve from start point till the point
<i>961</i>&nbsp;     * corresponding to the specified parameter then call ProcessQuad for the
<i>962</i>&nbsp;     * bitten part.
<i>963</i>&nbsp;     * Note: coords array will be changed
<i>964</i>&nbsp;     */
<i>965</i>&nbsp;    private static void ProcessFirstMonotonicPartOfQuad(ProcessHandler hnd,
<i>966</i>&nbsp;                                                        float[] coords,
<i>967</i>&nbsp;                                                        int[] pixelInfo,
<i>968</i>&nbsp;                                                        float t) {
<b class="nc"><i>969</i>&nbsp;        float[] coords1 = new float[6];</b>
<i>970</i>&nbsp;
<b class="nc"><i>971</i>&nbsp;        coords1[0] = coords[0];</b>
<b class="nc"><i>972</i>&nbsp;        coords1[1] = coords[1];</b>
<b class="nc"><i>973</i>&nbsp;        coords1[2] = coords[0] + t*(coords[2] - coords[0]);</b>
<b class="nc"><i>974</i>&nbsp;        coords1[3] = coords[1] + t*(coords[3] - coords[1]);</b>
<b class="nc"><i>975</i>&nbsp;        coords[2] = coords[2] + t*(coords[4] - coords[2]);</b>
<b class="nc"><i>976</i>&nbsp;        coords[3] = coords[3] + t*(coords[5] - coords[3]);</b>
<b class="nc"><i>977</i>&nbsp;        coords[0] = coords1[4] = coords1[2] + t*(coords[2] - coords1[2]);</b>
<b class="nc"><i>978</i>&nbsp;        coords[1] = coords1[5] = coords1[3] + t*(coords[3] - coords1[3]);</b>
<i>979</i>&nbsp;
<b class="nc"><i>980</i>&nbsp;        ProcessMonotonicQuad(hnd, coords1, pixelInfo);</b>
<i>981</i>&nbsp;    }
<i>982</i>&nbsp;
<i>983</i>&nbsp;    /* Performing drawing of the monotonic in X and Y cubic curves with sizes
<i>984</i>&nbsp;     * less than MAX_CUB_SIZE by using forward differencing method of
<i>985</i>&nbsp;     * calculation.  See comments to the DrawMonotonicCubic in the
<i>986</i>&nbsp;     * ProcessGeneralPath.c
<i>987</i>&nbsp;     */
<i>988</i>&nbsp;    private static void DrawMonotonicCubic(ProcessHandler hnd,
<i>989</i>&nbsp;                                           float[] coords,
<i>990</i>&nbsp;                                           boolean checkBounds,
<i>991</i>&nbsp;                                           int[] pixelInfo) {
<b class="nc"><i>992</i>&nbsp;        int x0 = (int)(coords[0]*MDP_MULT);</b>
<b class="nc"><i>993</i>&nbsp;        int y0 = (int)(coords[1]*MDP_MULT);</b>
<i>994</i>&nbsp;
<b class="nc"><i>995</i>&nbsp;        int xe = (int)(coords[6]*MDP_MULT);</b>
<b class="nc"><i>996</i>&nbsp;        int ye = (int)(coords[7]*MDP_MULT);</b>
<i>997</i>&nbsp;
<i>998</i>&nbsp;        /* Extracting fractional part of coordinates of first control point */
<b class="nc"><i>999</i>&nbsp;        int px = (x0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_CUB_SHIFT;</b>
<b class="nc"><i>1000</i>&nbsp;        int py = (y0 &amp; (~MDP_W_MASK)) &lt;&lt; DF_CUB_SHIFT;</b>
<i>1001</i>&nbsp;
<i>1002</i>&nbsp;        /* Setting default boundary values for checking first and second forward
<i>1003</i>&nbsp;         * difference for the necessity of the restepping. See comments to the
<i>1004</i>&nbsp;         * boundary values in ProcessQuad for more info.
<i>1005</i>&nbsp;         */
<b class="nc"><i>1006</i>&nbsp;        int incStepBnd = DF_CUB_INC_BND;</b>
<b class="nc"><i>1007</i>&nbsp;        int decStepBnd = DF_CUB_DEC_BND;</b>
<i>1008</i>&nbsp;
<i>1009</i>&nbsp;        /* Setting default amount of steps */
<b class="nc"><i>1010</i>&nbsp;        int count = DF_CUB_COUNT;</b>
<i>1011</i>&nbsp;
<i>1012</i>&nbsp;        /* Setting default shift for preparing to the midpoint rounding */
<b class="nc"><i>1013</i>&nbsp;        int shift =  DF_CUB_SHIFT;</b>
<i>1014</i>&nbsp;
<b class="nc"><i>1015</i>&nbsp;        int ax = (int)((-coords[0] + 3*coords[2] - 3*coords[4] +</b>
<i>1016</i>&nbsp;                 coords[6])*CUB_A_MDP_MULT);
<b class="nc"><i>1017</i>&nbsp;        int ay = (int)((-coords[1] + 3*coords[3] - 3*coords[5] +</b>
<i>1018</i>&nbsp;                 coords[7])*CUB_A_MDP_MULT);
<i>1019</i>&nbsp;
<b class="nc"><i>1020</i>&nbsp;        int bx = (int)((3*coords[0] - 6*coords[2] +</b>
<i>1021</i>&nbsp;                 3*coords[4])*CUB_B_MDP_MULT);
<b class="nc"><i>1022</i>&nbsp;        int by = (int)((3*coords[1] - 6*coords[3] +</b>
<i>1023</i>&nbsp;                 3*coords[5])*CUB_B_MDP_MULT);
<i>1024</i>&nbsp;
<b class="nc"><i>1025</i>&nbsp;        int cx = (int)((-3*coords[0] + 3*coords[2])*(CUB_C_MDP_MULT));</b>
<b class="nc"><i>1026</i>&nbsp;        int cy = (int)((-3*coords[1] + 3*coords[3])*(CUB_C_MDP_MULT));</b>
<i>1027</i>&nbsp;
<b class="nc"><i>1028</i>&nbsp;        int dddpx = 6*ax;</b>
<b class="nc"><i>1029</i>&nbsp;        int dddpy = 6*ay;</b>
<i>1030</i>&nbsp;
<b class="nc"><i>1031</i>&nbsp;        int ddpx = dddpx + bx;</b>
<b class="nc"><i>1032</i>&nbsp;        int ddpy = dddpy + by;</b>
<i>1033</i>&nbsp;
<b class="nc"><i>1034</i>&nbsp;        int dpx = ax + (bx&gt;&gt;1) + cx;</b>
<b class="nc"><i>1035</i>&nbsp;        int dpy = ay + (by&gt;&gt;1) + cy;</b>
<i>1036</i>&nbsp;
<i>1037</i>&nbsp;        int x1, y1;
<i>1038</i>&nbsp;
<b class="nc"><i>1039</i>&nbsp;        int x2 = x0;</b>
<b class="nc"><i>1040</i>&nbsp;        int y2 = y0;</b>
<i>1041</i>&nbsp;
<i>1042</i>&nbsp;        /* Calculating whole part of the first point of the curve */
<b class="nc"><i>1043</i>&nbsp;        int x0w = x0 &amp; MDP_W_MASK;</b>
<b class="nc"><i>1044</i>&nbsp;        int y0w = y0 &amp; MDP_W_MASK;</b>
<i>1045</i>&nbsp;
<b class="nc"><i>1046</i>&nbsp;        int dx = xe - x0;</b>
<b class="nc"><i>1047</i>&nbsp;        int dy = ye - y0;</b>
<i>1048</i>&nbsp;
<b class="nc"><i>1049</i>&nbsp;        while (count &gt; 0) {</b>
<i>1050</i>&nbsp;            /* Perform decreasing step in 2 times if necessary */
<b class="nc"><i>1051</i>&nbsp;            while (Math.abs(ddpx) &gt; decStepBnd ||</b>
<b class="nc"><i>1052</i>&nbsp;                   Math.abs(ddpy) &gt; decStepBnd) {</b>
<b class="nc"><i>1053</i>&nbsp;                ddpx = (ddpx&lt;&lt;1) - dddpx;</b>
<b class="nc"><i>1054</i>&nbsp;                ddpy = (ddpy&lt;&lt;1) - dddpy;</b>
<b class="nc"><i>1055</i>&nbsp;                dpx = (dpx&lt;&lt;2) - (ddpx&gt;&gt;1);</b>
<b class="nc"><i>1056</i>&nbsp;                dpy = (dpy&lt;&lt;2) - (ddpy&gt;&gt;1);</b>
<b class="nc"><i>1057</i>&nbsp;                count &lt;&lt;=1;</b>
<b class="nc"><i>1058</i>&nbsp;                decStepBnd &lt;&lt;=3;</b>
<b class="nc"><i>1059</i>&nbsp;                incStepBnd &lt;&lt;=3;</b>
<b class="nc"><i>1060</i>&nbsp;                px &lt;&lt;=3;</b>
<b class="nc"><i>1061</i>&nbsp;                py &lt;&lt;=3;</b>
<b class="nc"><i>1062</i>&nbsp;                shift += 3;</b>
<i>1063</i>&nbsp;            }
<i>1064</i>&nbsp;
<i>1065</i>&nbsp;            /* Perform increasing step in 2 times if necessary.
<i>1066</i>&nbsp;             * Note: we could do it only in even steps
<i>1067</i>&nbsp;             */
<i>1068</i>&nbsp;
<b class="nc"><i>1069</i>&nbsp;            while ((count &amp; 1) == 0 &amp;&amp; shift &gt; DF_CUB_SHIFT &amp;&amp;</b>
<b class="nc"><i>1070</i>&nbsp;                   Math.abs(dpx) &lt;= incStepBnd &amp;&amp;</b>
<b class="nc"><i>1071</i>&nbsp;                   Math.abs(dpy) &lt;= incStepBnd) {</b>
<b class="nc"><i>1072</i>&nbsp;                dpx = (dpx&gt;&gt;2) + (ddpx&gt;&gt;3);</b>
<b class="nc"><i>1073</i>&nbsp;                dpy = (dpy&gt;&gt;2) + (ddpy&gt;&gt;3);</b>
<b class="nc"><i>1074</i>&nbsp;                ddpx = (ddpx + dddpx)&gt;&gt;1;</b>
<b class="nc"><i>1075</i>&nbsp;                ddpy = (ddpy + dddpy)&gt;&gt;1;</b>
<b class="nc"><i>1076</i>&nbsp;                count &gt;&gt;=1;</b>
<b class="nc"><i>1077</i>&nbsp;                decStepBnd &gt;&gt;=3;</b>
<b class="nc"><i>1078</i>&nbsp;                incStepBnd &gt;&gt;=3;</b>
<b class="nc"><i>1079</i>&nbsp;                px &gt;&gt;=3;</b>
<b class="nc"><i>1080</i>&nbsp;                py &gt;&gt;=3;</b>
<b class="nc"><i>1081</i>&nbsp;                shift -= 3;</b>
<i>1082</i>&nbsp;            }
<i>1083</i>&nbsp;
<b class="nc"><i>1084</i>&nbsp;            count--;</b>
<i>1085</i>&nbsp;
<i>1086</i>&nbsp;            /* Performing one step less than necessary and use actual (xe,ye)
<i>1087</i>&nbsp;             * curve&#39;s endpoint instead of calculated. This prevent us from
<i>1088</i>&nbsp;             * running above the curve endpoint due to the accumulated errors
<i>1089</i>&nbsp;             * during the iterations.
<i>1090</i>&nbsp;             */
<b class="nc"><i>1091</i>&nbsp;            if (count &gt; 0) {</b>
<b class="nc"><i>1092</i>&nbsp;                px += dpx;</b>
<b class="nc"><i>1093</i>&nbsp;                py += dpy;</b>
<i>1094</i>&nbsp;
<b class="nc"><i>1095</i>&nbsp;                dpx += ddpx;</b>
<b class="nc"><i>1096</i>&nbsp;                dpy += ddpy;</b>
<b class="nc"><i>1097</i>&nbsp;                ddpx += dddpx;</b>
<b class="nc"><i>1098</i>&nbsp;                ddpy += dddpy;</b>
<i>1099</i>&nbsp;
<b class="nc"><i>1100</i>&nbsp;                x1 = x2;</b>
<b class="nc"><i>1101</i>&nbsp;                y1 = y2;</b>
<i>1102</i>&nbsp;
<b class="nc"><i>1103</i>&nbsp;                x2 = x0w + (px &gt;&gt; shift);</b>
<b class="nc"><i>1104</i>&nbsp;                y2 = y0w + (py &gt;&gt; shift);</b>
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;                /* Checking that we are not running out of the endpoint and
<i>1107</i>&nbsp;                 * bounding violating coordinate.  The check is pretty simple
<i>1108</i>&nbsp;                 * because the curve passed to the DrawCubic already split
<i>1109</i>&nbsp;                 * into the monotonic in X and Y pieces
<i>1110</i>&nbsp;                 */
<i>1111</i>&nbsp;
<i>1112</i>&nbsp;                /* Bounding x2 by xe */
<b class="nc"><i>1113</i>&nbsp;                if (((xe-x2)^dx) &lt; 0) {</b>
<b class="nc"><i>1114</i>&nbsp;                    x2 = xe;</b>
<i>1115</i>&nbsp;                }
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;                /* Bounding y2 by ye */
<b class="nc"><i>1118</i>&nbsp;                if (((ye-y2)^dy) &lt; 0) {</b>
<b class="nc"><i>1119</i>&nbsp;                    y2 = ye;</b>
<i>1120</i>&nbsp;                }
<i>1121</i>&nbsp;
<b class="nc"><i>1122</i>&nbsp;                hnd.processFixedLine(x1, y1, x2, y2, pixelInfo, checkBounds,</b>
<i>1123</i>&nbsp;                                     false);
<i>1124</i>&nbsp;            } else {
<b class="nc"><i>1125</i>&nbsp;                hnd.processFixedLine(x2, y2, xe, ye, pixelInfo, checkBounds,</b>
<i>1126</i>&nbsp;                                     false);
<i>1127</i>&nbsp;            }
<i>1128</i>&nbsp;        }
<i>1129</i>&nbsp;    }
<i>1130</i>&nbsp;
<i>1131</i>&nbsp;    /*
<i>1132</i>&nbsp;     * Checking size of the cubic curves and split them if necessary.
<i>1133</i>&nbsp;     * Calling DrawMonotonicCubic for the curves of the appropriate size.
<i>1134</i>&nbsp;     * Note: coords array could be changed
<i>1135</i>&nbsp;     */
<i>1136</i>&nbsp;    private static void ProcessMonotonicCubic(ProcessHandler hnd,
<i>1137</i>&nbsp;                                              float[] coords,
<i>1138</i>&nbsp;                                              int[] pixelInfo) {
<i>1139</i>&nbsp;
<b class="nc"><i>1140</i>&nbsp;        float[] coords1 = new float[8];</b>
<i>1141</i>&nbsp;        float tx, ty;
<i>1142</i>&nbsp;        float xMin, xMax;
<i>1143</i>&nbsp;        float yMin, yMax;
<i>1144</i>&nbsp;
<b class="nc"><i>1145</i>&nbsp;        xMin = xMax = coords[0];</b>
<b class="nc"><i>1146</i>&nbsp;        yMin = yMax = coords[1];</b>
<i>1147</i>&nbsp;
<b class="nc"><i>1148</i>&nbsp;        for (int i = 2; i &lt; 8; i += 2) {</b>
<b class="nc"><i>1149</i>&nbsp;            xMin = (xMin &gt; coords[i])? coords[i] : xMin;</b>
<b class="nc"><i>1150</i>&nbsp;            xMax = (xMax &lt; coords[i])? coords[i] : xMax;</b>
<b class="nc"><i>1151</i>&nbsp;            yMin = (yMin &gt; coords[i + 1])? coords[i + 1] : yMin;</b>
<b class="nc"><i>1152</i>&nbsp;            yMax = (yMax &lt; coords[i + 1])? coords[i + 1] : yMax;</b>
<i>1153</i>&nbsp;        }
<i>1154</i>&nbsp;
<b class="nc"><i>1155</i>&nbsp;        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</b>
<i>1156</i>&nbsp;            /* In case of drawing we could just skip curves which are
<i>1157</i>&nbsp;             * completely out of bounds
<i>1158</i>&nbsp;             */
<b class="nc"><i>1159</i>&nbsp;            if (hnd.dhnd.xMaxf &lt; xMin || hnd.dhnd.xMinf &gt; xMax ||</b>
<i>1160</i>&nbsp;                hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax) {
<i>1161</i>&nbsp;                return;
<i>1162</i>&nbsp;            }
<i>1163</i>&nbsp;        } else {
<i>1164</i>&nbsp;
<i>1165</i>&nbsp;            /* In case of filling we could skip curves which are above,
<i>1166</i>&nbsp;             * below and behind the right boundary of the visible area
<i>1167</i>&nbsp;             */
<i>1168</i>&nbsp;
<b class="nc"><i>1169</i>&nbsp;            if (hnd.dhnd.yMaxf &lt; yMin || hnd.dhnd.yMinf &gt; yMax ||</b>
<i>1170</i>&nbsp;                hnd.dhnd.xMaxf &lt; xMin)
<i>1171</i>&nbsp;            {
<i>1172</i>&nbsp;                return;
<i>1173</i>&nbsp;            }
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;            /* We could clamp x coordinates to the corresponding boundary
<i>1176</i>&nbsp;             * if the curve is completely behind the left one
<i>1177</i>&nbsp;             */
<i>1178</i>&nbsp;
<b class="nc"><i>1179</i>&nbsp;            if (hnd.dhnd.xMinf &gt; xMax) {</b>
<b class="nc"><i>1180</i>&nbsp;                coords[0] = coords[2] = coords[4] = coords[6] =</b>
<i>1181</i>&nbsp;                    hnd.dhnd.xMinf;
<i>1182</i>&nbsp;            }
<i>1183</i>&nbsp;        }
<i>1184</i>&nbsp;
<b class="nc"><i>1185</i>&nbsp;        if (xMax - xMin &gt; MAX_CUB_SIZE || yMax - yMin &gt; MAX_CUB_SIZE) {</b>
<b class="nc"><i>1186</i>&nbsp;            coords1[6] = coords[6];</b>
<b class="nc"><i>1187</i>&nbsp;            coords1[7] = coords[7];</b>
<b class="nc"><i>1188</i>&nbsp;            coords1[4] = (coords[4] + coords[6])/2.0f;</b>
<b class="nc"><i>1189</i>&nbsp;            coords1[5] = (coords[5] + coords[7])/2.0f;</b>
<b class="nc"><i>1190</i>&nbsp;            tx = (coords[2] + coords[4])/2.0f;</b>
<b class="nc"><i>1191</i>&nbsp;            ty = (coords[3] + coords[5])/2.0f;</b>
<b class="nc"><i>1192</i>&nbsp;            coords1[2] = (tx + coords1[4])/2.0f;</b>
<b class="nc"><i>1193</i>&nbsp;            coords1[3] = (ty + coords1[5])/2.0f;</b>
<b class="nc"><i>1194</i>&nbsp;            coords[2] =  (coords[0] + coords[2])/2.0f;</b>
<b class="nc"><i>1195</i>&nbsp;            coords[3] =  (coords[1] + coords[3])/2.0f;</b>
<b class="nc"><i>1196</i>&nbsp;            coords[4] = (coords[2] + tx)/2.0f;</b>
<b class="nc"><i>1197</i>&nbsp;            coords[5] = (coords[3] + ty)/2.0f;</b>
<b class="nc"><i>1198</i>&nbsp;            coords[6]=coords1[0]=(coords[4] + coords1[2])/2.0f;</b>
<b class="nc"><i>1199</i>&nbsp;            coords[7]=coords1[1]=(coords[5] + coords1[3])/2.0f;</b>
<i>1200</i>&nbsp;
<b class="nc"><i>1201</i>&nbsp;            ProcessMonotonicCubic(hnd, coords, pixelInfo);</b>
<i>1202</i>&nbsp;
<b class="nc"><i>1203</i>&nbsp;            ProcessMonotonicCubic(hnd, coords1, pixelInfo);</b>
<i>1204</i>&nbsp;        } else {
<b class="nc"><i>1205</i>&nbsp;            DrawMonotonicCubic(hnd, coords,</b>
<i>1206</i>&nbsp;                               /* Set checkBounds parameter if curve intersects
<i>1207</i>&nbsp;                                * boundary of the visible area. We know that
<i>1208</i>&nbsp;                                * the curve is visible, so the check is pretty
<i>1209</i>&nbsp;                                * simple
<i>1210</i>&nbsp;                                */
<i>1211</i>&nbsp;                                hnd.dhnd.xMinf &gt; xMin ||
<i>1212</i>&nbsp;                                hnd.dhnd.xMaxf &lt; xMax ||
<i>1213</i>&nbsp;                                hnd.dhnd.yMinf &gt; yMin ||
<i>1214</i>&nbsp;                                hnd.dhnd.yMaxf &lt; yMax,
<i>1215</i>&nbsp;                                pixelInfo);
<i>1216</i>&nbsp;        }
<i>1217</i>&nbsp;    }
<i>1218</i>&nbsp;
<i>1219</i>&nbsp;    /*
<i>1220</i>&nbsp;     * Split cubic curve into monotonic in X and Y parts. Calling
<i>1221</i>&nbsp;     * ProcessMonotonicCubic for each monotonic piece of the curve.
<i>1222</i>&nbsp;     *
<i>1223</i>&nbsp;     * Note: coords array could be changed
<i>1224</i>&nbsp;     */
<i>1225</i>&nbsp;    private static void ProcessCubic(ProcessHandler hnd,
<i>1226</i>&nbsp;                                     float[] coords,
<i>1227</i>&nbsp;                                     int[] pixelInfo) {
<i>1228</i>&nbsp;        /* Temporary array for holding parameters corresponding to the extreme
<i>1229</i>&nbsp;         * in X and Y points
<i>1230</i>&nbsp;         */
<b class="nc"><i>1231</i>&nbsp;        double params[] = new double[4];</b>
<b class="nc"><i>1232</i>&nbsp;        double eqn[] = new double[3];</b>
<b class="nc"><i>1233</i>&nbsp;        double res[] = new double[2];</b>
<b class="nc"><i>1234</i>&nbsp;        int cnt = 0;</b>
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;        /* Simple check for monotonicity in X before searching for the extreme
<i>1237</i>&nbsp;         * points of the X(t) function. We first check if the curve is
<i>1238</i>&nbsp;         * monotonic in X by seeing if all of the X coordinates are strongly
<i>1239</i>&nbsp;         * ordered.
<i>1240</i>&nbsp;         */
<b class="nc"><i>1241</i>&nbsp;        if ((coords[0] &gt; coords[2] || coords[2] &gt; coords[4] ||</b>
<i>1242</i>&nbsp;             coords[4] &gt; coords[6]) &amp;&amp;
<i>1243</i>&nbsp;            (coords[0] &lt; coords[2] || coords[2] &lt; coords[4] ||
<i>1244</i>&nbsp;             coords[4] &lt; coords[6]))
<i>1245</i>&nbsp;        {
<i>1246</i>&nbsp;            /* Searching for extreme points of the X(t) function  by solving
<i>1247</i>&nbsp;             * dX(t)
<i>1248</i>&nbsp;             * ----  = 0 equation
<i>1249</i>&nbsp;             *  dt
<i>1250</i>&nbsp;             */
<b class="nc"><i>1251</i>&nbsp;            eqn[2] = -coords[0] + 3*coords[2] - 3*coords[4] + coords[6];</b>
<b class="nc"><i>1252</i>&nbsp;            eqn[1] = 2*(coords[0] - 2*coords[2] + coords[4]);</b>
<b class="nc"><i>1253</i>&nbsp;            eqn[0] = -coords[0] + coords[2];</b>
<i>1254</i>&nbsp;
<b class="nc"><i>1255</i>&nbsp;            int nr = QuadCurve2D.solveQuadratic(eqn, res);</b>
<i>1256</i>&nbsp;
<i>1257</i>&nbsp;            /* Following code also correctly works in degenerate case of
<i>1258</i>&nbsp;             * the quadratic equation (nr = -1) because we do not need
<i>1259</i>&nbsp;             * splitting in this case.
<i>1260</i>&nbsp;             */
<b class="nc"><i>1261</i>&nbsp;            for (int i = 0; i &lt; nr; i++) {</b>
<b class="nc"><i>1262</i>&nbsp;                if (res[i] &gt; 0 &amp;&amp; res[i] &lt; 1) {</b>
<b class="nc"><i>1263</i>&nbsp;                    params[cnt++] = res[i];</b>
<i>1264</i>&nbsp;                }
<i>1265</i>&nbsp;            }
<i>1266</i>&nbsp;        }
<i>1267</i>&nbsp;
<i>1268</i>&nbsp;        /* Simple check for monotonicity in Y before searching for the extreme
<i>1269</i>&nbsp;         * points of the Y(t) function. We first check if the curve is
<i>1270</i>&nbsp;         * monotonic in Y by seeing if all of the Y coordinates are strongly
<i>1271</i>&nbsp;         * ordered.
<i>1272</i>&nbsp;         */
<b class="nc"><i>1273</i>&nbsp;        if ((coords[1] &gt; coords[3] || coords[3] &gt; coords[5] ||</b>
<i>1274</i>&nbsp;             coords[5] &gt; coords[7]) &amp;&amp;
<i>1275</i>&nbsp;            (coords[1] &lt; coords[3] || coords[3] &lt; coords[5] ||
<i>1276</i>&nbsp;             coords[5] &lt; coords[7]))
<i>1277</i>&nbsp;        {
<i>1278</i>&nbsp;            /* Searching for extreme points of the Y(t) function by solving
<i>1279</i>&nbsp;             * dY(t)
<i>1280</i>&nbsp;             * ----- = 0 equation
<i>1281</i>&nbsp;             *  dt
<i>1282</i>&nbsp;             */
<b class="nc"><i>1283</i>&nbsp;            eqn[2] = -coords[1] + 3*coords[3] - 3*coords[5] + coords[7];</b>
<b class="nc"><i>1284</i>&nbsp;            eqn[1] = 2*(coords[1] - 2*coords[3] + coords[5]);</b>
<b class="nc"><i>1285</i>&nbsp;            eqn[0] = -coords[1] + coords[3];</b>
<i>1286</i>&nbsp;
<b class="nc"><i>1287</i>&nbsp;            int nr = QuadCurve2D.solveQuadratic(eqn, res);</b>
<i>1288</i>&nbsp;
<i>1289</i>&nbsp;            /* Following code also correctly works in degenerate case of
<i>1290</i>&nbsp;             * the quadratic equation (nr = -1) because we do not need
<i>1291</i>&nbsp;             * splitting in this case.
<i>1292</i>&nbsp;             */
<b class="nc"><i>1293</i>&nbsp;            for (int i = 0; i &lt; nr; i++) {</b>
<b class="nc"><i>1294</i>&nbsp;                if (res[i] &gt; 0 &amp;&amp; res[i] &lt; 1) {</b>
<b class="nc"><i>1295</i>&nbsp;                    params[cnt++] = res[i];</b>
<i>1296</i>&nbsp;                }
<i>1297</i>&nbsp;            }
<i>1298</i>&nbsp;        }
<i>1299</i>&nbsp;
<b class="nc"><i>1300</i>&nbsp;        if (cnt &gt; 0) {</b>
<i>1301</i>&nbsp;            /* Sorting parameter values corresponding to the extreme points
<i>1302</i>&nbsp;             * of the curve
<i>1303</i>&nbsp;             */
<b class="nc"><i>1304</i>&nbsp;            Arrays.sort(params, 0, cnt);</b>
<i>1305</i>&nbsp;
<i>1306</i>&nbsp;            /* Processing obtained monotonic parts */
<b class="nc"><i>1307</i>&nbsp;            ProcessFirstMonotonicPartOfCubic(hnd, coords, pixelInfo,</b>
<i>1308</i>&nbsp;                                             (float)params[0]);
<b class="nc"><i>1309</i>&nbsp;            for (int i = 1; i &lt; cnt; i++) {</b>
<b class="nc"><i>1310</i>&nbsp;                double param = params[i] - params[i-1];</b>
<b class="nc"><i>1311</i>&nbsp;                if (param &gt; 0) {</b>
<b class="nc"><i>1312</i>&nbsp;                    ProcessFirstMonotonicPartOfCubic(hnd, coords, pixelInfo,</b>
<i>1313</i>&nbsp;                        /* Scale parameter to match with rest of the curve */
<i>1314</i>&nbsp;                        (float)(param/(1.0 - params[i - 1])));
<i>1315</i>&nbsp;                }
<i>1316</i>&nbsp;            }
<i>1317</i>&nbsp;        }
<i>1318</i>&nbsp;
<b class="nc"><i>1319</i>&nbsp;        ProcessMonotonicCubic(hnd,coords,pixelInfo);</b>
<i>1320</i>&nbsp;    }
<i>1321</i>&nbsp;
<i>1322</i>&nbsp;    /*
<i>1323</i>&nbsp;     * Bite the piece of the cubic curve from start point till the point
<i>1324</i>&nbsp;     * corresponding to the specified parameter then call ProcessCubic for the
<i>1325</i>&nbsp;     * bitten part.
<i>1326</i>&nbsp;     * Note: coords array will be changed
<i>1327</i>&nbsp;     */
<i>1328</i>&nbsp;    private static void ProcessFirstMonotonicPartOfCubic(ProcessHandler hnd,
<i>1329</i>&nbsp;                                                         float[] coords,
<i>1330</i>&nbsp;                                                         int[] pixelInfo,
<i>1331</i>&nbsp;                                                         float t)
<i>1332</i>&nbsp;    {
<b class="nc"><i>1333</i>&nbsp;        float[] coords1 = new float[8];</b>
<i>1334</i>&nbsp;        float tx, ty;
<i>1335</i>&nbsp;
<b class="nc"><i>1336</i>&nbsp;        coords1[0] = coords[0];</b>
<b class="nc"><i>1337</i>&nbsp;        coords1[1] = coords[1];</b>
<b class="nc"><i>1338</i>&nbsp;        tx = coords[2] + t*(coords[4] - coords[2]);</b>
<b class="nc"><i>1339</i>&nbsp;        ty = coords[3] + t*(coords[5] - coords[3]);</b>
<b class="nc"><i>1340</i>&nbsp;        coords1[2] =  coords[0] + t*(coords[2] - coords[0]);</b>
<b class="nc"><i>1341</i>&nbsp;        coords1[3] =  coords[1] + t*(coords[3] - coords[1]);</b>
<b class="nc"><i>1342</i>&nbsp;        coords1[4] = coords1[2] + t*(tx - coords1[2]);</b>
<b class="nc"><i>1343</i>&nbsp;        coords1[5] = coords1[3] + t*(ty - coords1[3]);</b>
<b class="nc"><i>1344</i>&nbsp;        coords[4] = coords[4] + t*(coords[6] - coords[4]);</b>
<b class="nc"><i>1345</i>&nbsp;        coords[5] = coords[5] + t*(coords[7] - coords[5]);</b>
<b class="nc"><i>1346</i>&nbsp;        coords[2] = tx + t*(coords[4] - tx);</b>
<b class="nc"><i>1347</i>&nbsp;        coords[3] = ty + t*(coords[5] - ty);</b>
<b class="nc"><i>1348</i>&nbsp;        coords[0]=coords1[6]=coords1[4] + t*(coords[2] - coords1[4]);</b>
<b class="nc"><i>1349</i>&nbsp;        coords[1]=coords1[7]=coords1[5] + t*(coords[3] - coords1[5]);</b>
<i>1350</i>&nbsp;
<b class="nc"><i>1351</i>&nbsp;        ProcessMonotonicCubic(hnd, coords1, pixelInfo);</b>
<i>1352</i>&nbsp;    }
<i>1353</i>&nbsp;
<i>1354</i>&nbsp;    /* Note:
<i>1355</i>&nbsp;     * For more easy reading of the code below each java version of the macros
<i>1356</i>&nbsp;     * from the ProcessPath.c preceded by the commented origin call
<i>1357</i>&nbsp;     * containing verbose names of the parameters
<i>1358</i>&nbsp;     */
<i>1359</i>&nbsp;    private static void ProcessLine(ProcessHandler hnd, float x1, float y1,
<i>1360</i>&nbsp;                                    float x2, float y2, int[] pixelInfo) {
<i>1361</i>&nbsp;        float xMin, yMin, xMax, yMax;
<i>1362</i>&nbsp;        int X1, Y1, X2, Y2, X3, Y3, res;
<b class="nc"><i>1363</i>&nbsp;        boolean clipped = false;</b>
<i>1364</i>&nbsp;        float x3,y3;
<b class="nc"><i>1365</i>&nbsp;        float c[] = new float[]{x1, y1, x2, y2, 0, 0};</b>
<i>1366</i>&nbsp;
<i>1367</i>&nbsp;        boolean lastClipped;
<i>1368</i>&nbsp;
<b class="nc"><i>1369</i>&nbsp;        xMin = hnd.dhnd.xMinf;</b>
<b class="nc"><i>1370</i>&nbsp;        yMin = hnd.dhnd.yMinf;</b>
<b class="nc"><i>1371</i>&nbsp;        xMax = hnd.dhnd.xMaxf;</b>
<b class="nc"><i>1372</i>&nbsp;        yMax = hnd.dhnd.yMaxf;</b>
<i>1373</i>&nbsp;
<i>1374</i>&nbsp;        //
<i>1375</i>&nbsp;        // TESTANDCLIP(yMin, yMax, y1, x1, y2, x2, res);
<i>1376</i>&nbsp;        //
<b class="nc"><i>1377</i>&nbsp;        res = TESTANDCLIP(yMin, yMax, c, 1, 0, 3, 2);</b>
<b class="nc"><i>1378</i>&nbsp;        if (res == CRES_INVISIBLE) return;</b>
<b class="nc"><i>1379</i>&nbsp;        clipped = IS_CLIPPED(res);</b>
<i>1380</i>&nbsp;        //
<i>1381</i>&nbsp;        // TESTANDCLIP(yMin, yMax, y2, x2, y1, x1, res);
<i>1382</i>&nbsp;        //
<b class="nc"><i>1383</i>&nbsp;        res = TESTANDCLIP(yMin, yMax, c, 3, 2, 1, 0);</b>
<b class="nc"><i>1384</i>&nbsp;        if (res == CRES_INVISIBLE) return;</b>
<b class="nc"><i>1385</i>&nbsp;        lastClipped = IS_CLIPPED(res);</b>
<b class="nc"><i>1386</i>&nbsp;        clipped = clipped || lastClipped;</b>
<i>1387</i>&nbsp;
<b class="nc"><i>1388</i>&nbsp;        if (hnd.clipMode == PH_MODE_DRAW_CLIP) {</b>
<i>1389</i>&nbsp;            //
<i>1390</i>&nbsp;            // TESTANDCLIP(xMin, xMax, x1, y1, x2, y2, res);
<i>1391</i>&nbsp;            //
<b class="nc"><i>1392</i>&nbsp;            res = TESTANDCLIP(xMin, xMax, c, 0, 1, 2, 3);</b>
<b class="nc"><i>1393</i>&nbsp;            if (res == CRES_INVISIBLE) return;</b>
<b class="nc"><i>1394</i>&nbsp;            clipped = clipped || IS_CLIPPED(res);</b>
<i>1395</i>&nbsp;            //
<i>1396</i>&nbsp;            // TESTANDCLIP(xMin, xMax, x2, y2, x1, y1, res);
<i>1397</i>&nbsp;            //
<b class="nc"><i>1398</i>&nbsp;            res = TESTANDCLIP(xMin, xMax, c, 2, 3, 0, 1);</b>
<b class="nc"><i>1399</i>&nbsp;            if (res == CRES_INVISIBLE) return;</b>
<b class="nc"><i>1400</i>&nbsp;            lastClipped = lastClipped || IS_CLIPPED(res);</b>
<b class="nc"><i>1401</i>&nbsp;            clipped = clipped || lastClipped;</b>
<b class="nc"><i>1402</i>&nbsp;            X1 = (int)(c[0]*MDP_MULT);</b>
<b class="nc"><i>1403</i>&nbsp;            Y1 = (int)(c[1]*MDP_MULT);</b>
<b class="nc"><i>1404</i>&nbsp;            X2 = (int)(c[2]*MDP_MULT);</b>
<b class="nc"><i>1405</i>&nbsp;            Y2 = (int)(c[3]*MDP_MULT);</b>
<i>1406</i>&nbsp;
<b class="nc"><i>1407</i>&nbsp;            hnd.processFixedLine(X1, Y1, X2, Y2, pixelInfo,</b>
<i>1408</i>&nbsp;                                 clipped, /* enable boundary checking in
<i>1409</i>&nbsp;                                             case of clipping to avoid
<i>1410</i>&nbsp;                                             entering out of bounds which
<i>1411</i>&nbsp;                                             could happens during rounding
<i>1412</i>&nbsp;                                           */
<i>1413</i>&nbsp;                                 lastClipped /* Notify pProcessFixedLine
<i>1414</i>&nbsp;                                                that
<i>1415</i>&nbsp;                                                this is the end of the
<i>1416</i>&nbsp;                                                subpath (because of exiting
<i>1417</i>&nbsp;                                                out of boundaries)
<i>1418</i>&nbsp;                                              */
<i>1419</i>&nbsp;                                 );
<i>1420</i>&nbsp;        } else {
<i>1421</i>&nbsp;            /* Clamping starting from first vertex of the processed
<i>1422</i>&nbsp;             * segment
<i>1423</i>&nbsp;             *
<i>1424</i>&nbsp;             * CLIPCLAMP(xMin, xMax, x1, y1, x2, y2, x3, y3, res);
<i>1425</i>&nbsp;             */
<b class="nc"><i>1426</i>&nbsp;            res = CLIPCLAMP(xMin, xMax, c, 0, 1, 2, 3, 4, 5);</b>
<b class="nc"><i>1427</i>&nbsp;            X1 = (int)(c[0]*MDP_MULT);</b>
<b class="nc"><i>1428</i>&nbsp;            Y1 = (int)(c[1]*MDP_MULT);</b>
<i>1429</i>&nbsp;
<i>1430</i>&nbsp;            /* Clamping only by left boundary */
<b class="nc"><i>1431</i>&nbsp;            if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>1432</i>&nbsp;                X3 = (int)(c[4]*MDP_MULT);</b>
<b class="nc"><i>1433</i>&nbsp;                Y3 = (int)(c[5]*MDP_MULT);</b>
<b class="nc"><i>1434</i>&nbsp;                hnd.processFixedLine(X3, Y3, X1, Y1, pixelInfo,</b>
<i>1435</i>&nbsp;                                     false, lastClipped);
<i>1436</i>&nbsp;
<b class="nc"><i>1437</i>&nbsp;            } else if (res == CRES_INVISIBLE) {</b>
<i>1438</i>&nbsp;                return;
<i>1439</i>&nbsp;            }
<i>1440</i>&nbsp;
<i>1441</i>&nbsp;            /* Clamping starting from last vertex of the processed
<i>1442</i>&nbsp;             * segment
<i>1443</i>&nbsp;             *
<i>1444</i>&nbsp;             * CLIPCLAMP(xMin, xMax, x2, y2, x1, y1, x3, y3, res);
<i>1445</i>&nbsp;             */
<b class="nc"><i>1446</i>&nbsp;            res = CLIPCLAMP(xMin, xMax, c, 2, 3, 0, 1, 4, 5);</b>
<i>1447</i>&nbsp;
<i>1448</i>&nbsp;            /* Checking if there was a clip by right boundary */
<b class="nc"><i>1449</i>&nbsp;            lastClipped = lastClipped || (res == CRES_MAX_CLIPPED);</b>
<i>1450</i>&nbsp;
<b class="nc"><i>1451</i>&nbsp;            X2 = (int)(c[2]*MDP_MULT);</b>
<b class="nc"><i>1452</i>&nbsp;            Y2 = (int)(c[3]*MDP_MULT);</b>
<b class="nc"><i>1453</i>&nbsp;            hnd.processFixedLine(X1, Y1, X2, Y2, pixelInfo,</b>
<i>1454</i>&nbsp;                                 false, lastClipped);
<i>1455</i>&nbsp;
<i>1456</i>&nbsp;            /* Clamping only by left boundary */
<b class="nc"><i>1457</i>&nbsp;            if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>1458</i>&nbsp;                X3 = (int)(c[4]*MDP_MULT);</b>
<b class="nc"><i>1459</i>&nbsp;                Y3 = (int)(c[5]*MDP_MULT);</b>
<b class="nc"><i>1460</i>&nbsp;                hnd.processFixedLine(X2, Y2, X3, Y3, pixelInfo,</b>
<i>1461</i>&nbsp;                                     false, lastClipped);
<i>1462</i>&nbsp;            }
<i>1463</i>&nbsp;        }
<i>1464</i>&nbsp;    }
<i>1465</i>&nbsp;
<i>1466</i>&nbsp;    private static boolean doProcessPath(ProcessHandler hnd,
<i>1467</i>&nbsp;                                         Path2D.Float p2df,
<i>1468</i>&nbsp;                                         float transXf, float transYf) {
<b class="nc"><i>1469</i>&nbsp;        float coords[] = new float[8];</b>
<b class="nc"><i>1470</i>&nbsp;        float tCoords[] = new float[8];</b>
<b class="nc"><i>1471</i>&nbsp;        float closeCoord[] = new float[] {0.0f, 0.0f};</b>
<b class="nc"><i>1472</i>&nbsp;        float firstCoord[] = new float[2];</b>
<b class="nc"><i>1473</i>&nbsp;        int pixelInfo[] = new int[5];</b>
<b class="nc"><i>1474</i>&nbsp;        boolean subpathStarted = false;</b>
<b class="nc"><i>1475</i>&nbsp;        boolean skip = false;</b>
<i>1476</i>&nbsp;        float lastX, lastY;
<b class="nc"><i>1477</i>&nbsp;        pixelInfo[0] = 0;</b>
<i>1478</i>&nbsp;
<i>1479</i>&nbsp;        /* Adjusting boundaries to the capabilities of the
<i>1480</i>&nbsp;         * ProcessPath code
<i>1481</i>&nbsp;         */
<b class="nc"><i>1482</i>&nbsp;        hnd.dhnd.adjustBounds(LOWER_OUT_BND, LOWER_OUT_BND,</b>
<i>1483</i>&nbsp;                              UPPER_OUT_BND, UPPER_OUT_BND);
<i>1484</i>&nbsp;
<i>1485</i>&nbsp;        /* Adding support of the KEY_STROKE_CONTROL rendering hint.
<i>1486</i>&nbsp;         * Now we are supporting two modes: &quot;pixels at centers&quot; and
<i>1487</i>&nbsp;         * &quot;pixels at corners&quot;.
<i>1488</i>&nbsp;         * First one is disabled by default but could be enabled by setting
<i>1489</i>&nbsp;         * VALUE_STROKE_PURE to the rendering hint. It means that pixel at the
<i>1490</i>&nbsp;         * screen (x,y) has (x + 0.5, y + 0.5) float coordinates.
<i>1491</i>&nbsp;         *
<i>1492</i>&nbsp;         * Second one is enabled by default and means straightforward mapping
<i>1493</i>&nbsp;         * (x,y) --&gt; (x,y)
<i>1494</i>&nbsp;         */
<b class="nc"><i>1495</i>&nbsp;        if (hnd.dhnd.strokeControl == SunHints.INTVAL_STROKE_PURE) {</b>
<b class="nc"><i>1496</i>&nbsp;            closeCoord[0] = -0.5f;</b>
<b class="nc"><i>1497</i>&nbsp;            closeCoord[1] = -0.5f;</b>
<b class="nc"><i>1498</i>&nbsp;            transXf -= 0.5;</b>
<b class="nc"><i>1499</i>&nbsp;            transYf -= 0.5;</b>
<i>1500</i>&nbsp;        }
<i>1501</i>&nbsp;
<b class="nc"><i>1502</i>&nbsp;        PathIterator pi = p2df.getPathIterator(null);</b>
<i>1503</i>&nbsp;
<b class="nc"><i>1504</i>&nbsp;        while (!pi.isDone()) {</b>
<b class="nc"><i>1505</i>&nbsp;            switch (pi.currentSegment(coords)) {</b>
<i>1506</i>&nbsp;                case PathIterator.SEG_MOVETO:
<i>1507</i>&nbsp;                    /* Performing closing of the unclosed segments */
<b class="nc"><i>1508</i>&nbsp;                    if (subpathStarted &amp;&amp; !skip) {</b>
<b class="nc"><i>1509</i>&nbsp;                        if (hnd.clipMode == PH_MODE_FILL_CLIP) {</b>
<b class="nc"><i>1510</i>&nbsp;                            if (tCoords[0] != closeCoord[0] ||</b>
<i>1511</i>&nbsp;                                tCoords[1] != closeCoord[1])
<i>1512</i>&nbsp;                            {
<b class="nc"><i>1513</i>&nbsp;                                ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1514</i>&nbsp;                                            closeCoord[0], closeCoord[1],
<i>1515</i>&nbsp;                                            pixelInfo);
<i>1516</i>&nbsp;                            }
<i>1517</i>&nbsp;                        }
<b class="nc"><i>1518</i>&nbsp;                        hnd.processEndSubPath();</b>
<i>1519</i>&nbsp;                    }
<i>1520</i>&nbsp;
<b class="nc"><i>1521</i>&nbsp;                    tCoords[0] = coords[0] + transXf;</b>
<b class="nc"><i>1522</i>&nbsp;                    tCoords[1] = coords[1] + transYf;</b>
<i>1523</i>&nbsp;
<i>1524</i>&nbsp;                    /* Checking SEG_MOVETO coordinates if they are out of the
<i>1525</i>&nbsp;                     * [LOWER_BND, UPPER_BND] range.  This check also handles
<i>1526</i>&nbsp;                     * NaN and Infinity values. Skipping next path segment in
<i>1527</i>&nbsp;                     * case of invalid data.
<i>1528</i>&nbsp;                     */
<i>1529</i>&nbsp;
<b class="nc"><i>1530</i>&nbsp;                    if (tCoords[0] &lt; UPPER_BND &amp;&amp;</b>
<i>1531</i>&nbsp;                        tCoords[0] &gt; LOWER_BND &amp;&amp;
<i>1532</i>&nbsp;                        tCoords[1] &lt; UPPER_BND &amp;&amp;
<i>1533</i>&nbsp;                        tCoords[1] &gt; LOWER_BND)
<i>1534</i>&nbsp;                    {
<b class="nc"><i>1535</i>&nbsp;                        subpathStarted = true;</b>
<b class="nc"><i>1536</i>&nbsp;                        skip = false;</b>
<b class="nc"><i>1537</i>&nbsp;                        closeCoord[0] = tCoords[0];</b>
<b class="nc"><i>1538</i>&nbsp;                        closeCoord[1] = tCoords[1];</b>
<i>1539</i>&nbsp;                    } else {
<b class="nc"><i>1540</i>&nbsp;                        skip = true;</b>
<i>1541</i>&nbsp;                    }
<b class="nc"><i>1542</i>&nbsp;                    pixelInfo[0] = 0;</b>
<b class="nc"><i>1543</i>&nbsp;                    break;</b>
<i>1544</i>&nbsp;                case PathIterator.SEG_LINETO:
<b class="nc"><i>1545</i>&nbsp;                    lastX = tCoords[2] = coords[0] + transXf;</b>
<b class="nc"><i>1546</i>&nbsp;                    lastY = tCoords[3] = coords[1] + transYf;</b>
<i>1547</i>&nbsp;
<i>1548</i>&nbsp;                    /* Checking SEG_LINETO coordinates if they are out of the
<i>1549</i>&nbsp;                     * [LOWER_BND, UPPER_BND] range.  This check also handles
<i>1550</i>&nbsp;                     * NaN and Infinity values. Ignoring current path segment
<i>1551</i>&nbsp;                     * in case  of invalid data. If segment is skipped its
<i>1552</i>&nbsp;                     * endpoint (if valid) is used to begin new subpath.
<i>1553</i>&nbsp;                     */
<i>1554</i>&nbsp;
<b class="nc"><i>1555</i>&nbsp;                    if (lastX &lt; UPPER_BND &amp;&amp;</b>
<i>1556</i>&nbsp;                        lastX &gt; LOWER_BND &amp;&amp;
<i>1557</i>&nbsp;                        lastY &lt; UPPER_BND &amp;&amp;
<i>1558</i>&nbsp;                        lastY &gt; LOWER_BND)
<i>1559</i>&nbsp;                    {
<b class="nc"><i>1560</i>&nbsp;                        if (skip) {</b>
<b class="nc"><i>1561</i>&nbsp;                            tCoords[0] = closeCoord[0] = lastX;</b>
<b class="nc"><i>1562</i>&nbsp;                            tCoords[1] = closeCoord[1] = lastY;</b>
<b class="nc"><i>1563</i>&nbsp;                            subpathStarted = true;</b>
<b class="nc"><i>1564</i>&nbsp;                            skip = false;</b>
<i>1565</i>&nbsp;                        } else {
<b class="nc"><i>1566</i>&nbsp;                            ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1567</i>&nbsp;                                        tCoords[2], tCoords[3], pixelInfo);
<b class="nc"><i>1568</i>&nbsp;                            tCoords[0] = lastX;</b>
<b class="nc"><i>1569</i>&nbsp;                            tCoords[1] = lastY;</b>
<i>1570</i>&nbsp;                        }
<i>1571</i>&nbsp;                    }
<i>1572</i>&nbsp;                    break;
<i>1573</i>&nbsp;                case PathIterator.SEG_QUADTO:
<b class="nc"><i>1574</i>&nbsp;                    tCoords[2] = coords[0] + transXf;</b>
<b class="nc"><i>1575</i>&nbsp;                    tCoords[3] = coords[1] + transYf;</b>
<b class="nc"><i>1576</i>&nbsp;                    lastX = tCoords[4] = coords[2] + transXf;</b>
<b class="nc"><i>1577</i>&nbsp;                    lastY = tCoords[5] = coords[3] + transYf;</b>
<i>1578</i>&nbsp;
<i>1579</i>&nbsp;                    /* Checking SEG_QUADTO coordinates if they are out of the
<i>1580</i>&nbsp;                     * [LOWER_BND, UPPER_BND] range.  This check also handles
<i>1581</i>&nbsp;                     * NaN and Infinity values. Ignoring current path segment
<i>1582</i>&nbsp;                     * in case  of invalid endpoints&#39;s data.  Equivalent to
<i>1583</i>&nbsp;                     * the SEG_LINETO if endpoint coordinates are valid but
<i>1584</i>&nbsp;                     * there are invalid data among other coordinates
<i>1585</i>&nbsp;                     */
<i>1586</i>&nbsp;
<b class="nc"><i>1587</i>&nbsp;                    if (lastX &lt; UPPER_BND &amp;&amp;</b>
<i>1588</i>&nbsp;                        lastX &gt; LOWER_BND &amp;&amp;
<i>1589</i>&nbsp;                        lastY &lt; UPPER_BND &amp;&amp;
<i>1590</i>&nbsp;                        lastY &gt; LOWER_BND)
<i>1591</i>&nbsp;                    {
<b class="nc"><i>1592</i>&nbsp;                        if (skip) {</b>
<b class="nc"><i>1593</i>&nbsp;                            tCoords[0] = closeCoord[0] = lastX;</b>
<b class="nc"><i>1594</i>&nbsp;                            tCoords[1] = closeCoord[1] = lastY;</b>
<b class="nc"><i>1595</i>&nbsp;                            subpathStarted = true;</b>
<b class="nc"><i>1596</i>&nbsp;                            skip = false;</b>
<i>1597</i>&nbsp;                        } else {
<b class="nc"><i>1598</i>&nbsp;                            if (tCoords[2] &lt; UPPER_BND &amp;&amp;</b>
<i>1599</i>&nbsp;                                tCoords[2] &gt; LOWER_BND &amp;&amp;
<i>1600</i>&nbsp;                                tCoords[3] &lt; UPPER_BND &amp;&amp;
<i>1601</i>&nbsp;                                tCoords[3] &gt; LOWER_BND)
<i>1602</i>&nbsp;                            {
<b class="nc"><i>1603</i>&nbsp;                                ProcessQuad(hnd, tCoords, pixelInfo);</b>
<i>1604</i>&nbsp;                            } else {
<b class="nc"><i>1605</i>&nbsp;                                ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1606</i>&nbsp;                                            tCoords[4], tCoords[5],
<i>1607</i>&nbsp;                                            pixelInfo);
<i>1608</i>&nbsp;                            }
<b class="nc"><i>1609</i>&nbsp;                            tCoords[0] = lastX;</b>
<b class="nc"><i>1610</i>&nbsp;                            tCoords[1] = lastY;</b>
<i>1611</i>&nbsp;                        }
<i>1612</i>&nbsp;                    }
<i>1613</i>&nbsp;                    break;
<i>1614</i>&nbsp;                case PathIterator.SEG_CUBICTO:
<b class="nc"><i>1615</i>&nbsp;                    tCoords[2] = coords[0] + transXf;</b>
<b class="nc"><i>1616</i>&nbsp;                    tCoords[3] = coords[1] + transYf;</b>
<b class="nc"><i>1617</i>&nbsp;                    tCoords[4] = coords[2] + transXf;</b>
<b class="nc"><i>1618</i>&nbsp;                    tCoords[5] = coords[3] + transYf;</b>
<b class="nc"><i>1619</i>&nbsp;                    lastX = tCoords[6] = coords[4] + transXf;</b>
<b class="nc"><i>1620</i>&nbsp;                    lastY = tCoords[7] = coords[5] + transYf;</b>
<i>1621</i>&nbsp;
<i>1622</i>&nbsp;                    /* Checking SEG_CUBICTO coordinates if they are out of the
<i>1623</i>&nbsp;                     * [LOWER_BND, UPPER_BND] range.  This check also handles
<i>1624</i>&nbsp;                     * NaN and Infinity values. Ignoring current path segment
<i>1625</i>&nbsp;                     * in case  of invalid endpoints&#39;s data.  Equivalent to
<i>1626</i>&nbsp;                     * the SEG_LINETO if endpoint coordinates are valid but
<i>1627</i>&nbsp;                     * there are invalid data among other coordinates
<i>1628</i>&nbsp;                     */
<i>1629</i>&nbsp;
<b class="nc"><i>1630</i>&nbsp;                    if (lastX &lt; UPPER_BND &amp;&amp;</b>
<i>1631</i>&nbsp;                        lastX &gt; LOWER_BND &amp;&amp;
<i>1632</i>&nbsp;                        lastY &lt; UPPER_BND &amp;&amp;
<i>1633</i>&nbsp;                        lastY &gt; LOWER_BND)
<i>1634</i>&nbsp;                    {
<b class="nc"><i>1635</i>&nbsp;                        if (skip) {</b>
<b class="nc"><i>1636</i>&nbsp;                            tCoords[0] = closeCoord[0] = tCoords[6];</b>
<b class="nc"><i>1637</i>&nbsp;                            tCoords[1] = closeCoord[1] = tCoords[7];</b>
<b class="nc"><i>1638</i>&nbsp;                            subpathStarted = true;</b>
<b class="nc"><i>1639</i>&nbsp;                            skip = false;</b>
<i>1640</i>&nbsp;                        } else {
<b class="nc"><i>1641</i>&nbsp;                            if (tCoords[2] &lt; UPPER_BND &amp;&amp;</b>
<i>1642</i>&nbsp;                                tCoords[2] &gt; LOWER_BND &amp;&amp;
<i>1643</i>&nbsp;                                tCoords[3] &lt; UPPER_BND &amp;&amp;
<i>1644</i>&nbsp;                                tCoords[3] &gt; LOWER_BND &amp;&amp;
<i>1645</i>&nbsp;                                tCoords[4] &lt; UPPER_BND &amp;&amp;
<i>1646</i>&nbsp;                                tCoords[4] &gt; LOWER_BND &amp;&amp;
<i>1647</i>&nbsp;                                tCoords[5] &lt; UPPER_BND &amp;&amp;
<i>1648</i>&nbsp;                                tCoords[5] &gt; LOWER_BND)
<i>1649</i>&nbsp;                            {
<b class="nc"><i>1650</i>&nbsp;                                ProcessCubic(hnd, tCoords, pixelInfo);</b>
<i>1651</i>&nbsp;                            } else {
<b class="nc"><i>1652</i>&nbsp;                                ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1653</i>&nbsp;                                            tCoords[6], tCoords[7],
<i>1654</i>&nbsp;                                            pixelInfo);
<i>1655</i>&nbsp;                            }
<b class="nc"><i>1656</i>&nbsp;                            tCoords[0] = lastX;</b>
<b class="nc"><i>1657</i>&nbsp;                            tCoords[1] = lastY;</b>
<i>1658</i>&nbsp;                        }
<i>1659</i>&nbsp;                    }
<i>1660</i>&nbsp;                    break;
<i>1661</i>&nbsp;                case PathIterator.SEG_CLOSE:
<b class="nc"><i>1662</i>&nbsp;                    if (subpathStarted &amp;&amp; !skip) {</b>
<b class="nc"><i>1663</i>&nbsp;                        skip = false;</b>
<b class="nc"><i>1664</i>&nbsp;                        if (tCoords[0] != closeCoord[0] ||</b>
<i>1665</i>&nbsp;                            tCoords[1] != closeCoord[1])
<i>1666</i>&nbsp;                        {
<b class="nc"><i>1667</i>&nbsp;                            ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1668</i>&nbsp;                                        closeCoord[0], closeCoord[1],
<i>1669</i>&nbsp;                                        pixelInfo);
<i>1670</i>&nbsp;
<i>1671</i>&nbsp;                            /* Storing last path&#39;s point for using in following
<i>1672</i>&nbsp;                             * segments without initial moveTo
<i>1673</i>&nbsp;                             */
<b class="nc"><i>1674</i>&nbsp;                            tCoords[0] = closeCoord[0];</b>
<b class="nc"><i>1675</i>&nbsp;                            tCoords[1] = closeCoord[1];</b>
<i>1676</i>&nbsp;                        }
<b class="nc"><i>1677</i>&nbsp;                        hnd.processEndSubPath();</b>
<i>1678</i>&nbsp;                    }
<i>1679</i>&nbsp;                    break;
<i>1680</i>&nbsp;            }
<b class="nc"><i>1681</i>&nbsp;            pi.next();</b>
<i>1682</i>&nbsp;        }
<i>1683</i>&nbsp;
<i>1684</i>&nbsp;        /* Performing closing of the unclosed segments */
<b class="nc"><i>1685</i>&nbsp;        if (subpathStarted &amp; !skip) {</b>
<b class="nc"><i>1686</i>&nbsp;            if (hnd.clipMode == PH_MODE_FILL_CLIP) {</b>
<b class="nc"><i>1687</i>&nbsp;                if (tCoords[0] != closeCoord[0] ||</b>
<i>1688</i>&nbsp;                    tCoords[1] != closeCoord[1])
<i>1689</i>&nbsp;                {
<b class="nc"><i>1690</i>&nbsp;                    ProcessLine(hnd, tCoords[0], tCoords[1],</b>
<i>1691</i>&nbsp;                                closeCoord[0], closeCoord[1],
<i>1692</i>&nbsp;                                pixelInfo);
<i>1693</i>&nbsp;                }
<i>1694</i>&nbsp;            }
<b class="nc"><i>1695</i>&nbsp;            hnd.processEndSubPath();</b>
<i>1696</i>&nbsp;        }
<b class="nc"><i>1697</i>&nbsp;        return true;</b>
<i>1698</i>&nbsp;    }
<i>1699</i>&nbsp;
<i>1700</i>&nbsp;    private static class Point {
<i>1701</i>&nbsp;        public int x;
<i>1702</i>&nbsp;        public int y;
<i>1703</i>&nbsp;        public boolean lastPoint;
<i>1704</i>&nbsp;        public Point prev;
<i>1705</i>&nbsp;        public Point next;
<i>1706</i>&nbsp;        public Point nextByY;
<i>1707</i>&nbsp;        public Edge edge;
<b class="nc"><i>1708</i>&nbsp;        public Point(int x, int y, boolean lastPoint) {</b>
<b class="nc"><i>1709</i>&nbsp;            this.x = x;</b>
<b class="nc"><i>1710</i>&nbsp;            this.y = y;</b>
<b class="nc"><i>1711</i>&nbsp;            this.lastPoint = lastPoint;</b>
<i>1712</i>&nbsp;        }
<i>1713</i>&nbsp;    };
<i>1714</i>&nbsp;
<i>1715</i>&nbsp;    private static class Edge {
<i>1716</i>&nbsp;        int x;
<i>1717</i>&nbsp;        int dx;
<i>1718</i>&nbsp;        Point p;
<i>1719</i>&nbsp;        int  dir;
<i>1720</i>&nbsp;        Edge prev;
<i>1721</i>&nbsp;        Edge next;
<i>1722</i>&nbsp;
<b class="nc"><i>1723</i>&nbsp;        public Edge(Point p, int x, int dx, int dir) {</b>
<b class="nc"><i>1724</i>&nbsp;            this.p = p;</b>
<b class="nc"><i>1725</i>&nbsp;            this.x = x;</b>
<b class="nc"><i>1726</i>&nbsp;            this.dx = dx;</b>
<b class="nc"><i>1727</i>&nbsp;            this.dir = dir;</b>
<i>1728</i>&nbsp;        }
<i>1729</i>&nbsp;    };
<i>1730</i>&nbsp;
<i>1731</i>&nbsp;    /* Size of the default buffer in the FillData structure. This buffer is
<i>1732</i>&nbsp;     * replaced with heap allocated in case of large paths.
<i>1733</i>&nbsp;     */
<i>1734</i>&nbsp;    private static final int DF_MAX_POINT = 256;
<i>1735</i>&nbsp;
<i>1736</i>&nbsp;    /* Following class accumulates points of the non-continuous flattened
<i>1737</i>&nbsp;     * general path during iteration through the origin path&#39;s segments . The
<i>1738</i>&nbsp;     * end of the each subpath is marked as lastPoint flag set at the last
<i>1739</i>&nbsp;     * point
<i>1740</i>&nbsp;     */
<i>1741</i>&nbsp;    private static class FillData {
<i>1742</i>&nbsp;        List&lt;Point&gt;  plgPnts;
<i>1743</i>&nbsp;        public int  plgYMin;
<i>1744</i>&nbsp;        public int  plgYMax;
<i>1745</i>&nbsp;
<b class="nc"><i>1746</i>&nbsp;        public FillData() {</b>
<b class="nc"><i>1747</i>&nbsp;            plgPnts = new Vector&lt;Point&gt;(DF_MAX_POINT);</b>
<i>1748</i>&nbsp;        }
<i>1749</i>&nbsp;
<i>1750</i>&nbsp;        public void addPoint(int x, int y, boolean lastPoint) {
<b class="nc"><i>1751</i>&nbsp;            if (plgPnts.size() == 0) {</b>
<b class="nc"><i>1752</i>&nbsp;                plgYMin = plgYMax = y;</b>
<i>1753</i>&nbsp;            } else {
<b class="nc"><i>1754</i>&nbsp;                plgYMin = (plgYMin &gt; y)?y:plgYMin;</b>
<b class="nc"><i>1755</i>&nbsp;                plgYMax = (plgYMax &lt; y)?y:plgYMax;</b>
<i>1756</i>&nbsp;            }
<i>1757</i>&nbsp;
<b class="nc"><i>1758</i>&nbsp;            plgPnts.add(new Point(x, y, lastPoint));</b>
<i>1759</i>&nbsp;        }
<i>1760</i>&nbsp;
<i>1761</i>&nbsp;        public boolean isEmpty() {
<b class="nc"><i>1762</i>&nbsp;            return plgPnts.size() == 0;</b>
<i>1763</i>&nbsp;        }
<i>1764</i>&nbsp;
<i>1765</i>&nbsp;        public boolean isEnded() {
<b class="nc"><i>1766</i>&nbsp;            return plgPnts.get(plgPnts.size() - 1).lastPoint;</b>
<i>1767</i>&nbsp;        }
<i>1768</i>&nbsp;
<i>1769</i>&nbsp;        public boolean setEnded() {
<b class="nc"><i>1770</i>&nbsp;            return plgPnts.get(plgPnts.size() - 1).lastPoint = true;</b>
<i>1771</i>&nbsp;        }
<i>1772</i>&nbsp;    }
<i>1773</i>&nbsp;
<b class="nc"><i>1774</i>&nbsp;    private static class ActiveEdgeList {</b>
<i>1775</i>&nbsp;        Edge head;
<i>1776</i>&nbsp;
<i>1777</i>&nbsp;        public boolean isEmpty() {
<b class="nc"><i>1778</i>&nbsp;            return (head == null);</b>
<i>1779</i>&nbsp;        }
<i>1780</i>&nbsp;
<i>1781</i>&nbsp;        public void insert(Point pnt, int cy) {
<b class="nc"><i>1782</i>&nbsp;            Point np = pnt.next;</b>
<b class="nc"><i>1783</i>&nbsp;            int X1 = pnt.x, Y1 = pnt.y;</b>
<b class="nc"><i>1784</i>&nbsp;            int X2 = np.x, Y2 = np.y;</b>
<i>1785</i>&nbsp;            Edge ne;
<b class="nc"><i>1786</i>&nbsp;            if (Y1 == Y2) {</b>
<i>1787</i>&nbsp;                /* Skipping horizontal segments */
<i>1788</i>&nbsp;                return;
<i>1789</i>&nbsp;            } else {
<b class="nc"><i>1790</i>&nbsp;                int dX = X2 - X1;</b>
<b class="nc"><i>1791</i>&nbsp;                int dY = Y2 - Y1;</b>
<i>1792</i>&nbsp;                int stepx, x0, dy, dir;
<i>1793</i>&nbsp;
<b class="nc"><i>1794</i>&nbsp;                if (Y1 &lt; Y2) {</b>
<b class="nc"><i>1795</i>&nbsp;                    x0 = X1;</b>
<b class="nc"><i>1796</i>&nbsp;                    dy = cy - Y1;</b>
<b class="nc"><i>1797</i>&nbsp;                    dir = -1;</b>
<i>1798</i>&nbsp;                } else { // (Y1 &gt; Y2)
<b class="nc"><i>1799</i>&nbsp;                    x0 = X2;</b>
<b class="nc"><i>1800</i>&nbsp;                    dy = cy - Y2;</b>
<b class="nc"><i>1801</i>&nbsp;                    dir = 1;</b>
<i>1802</i>&nbsp;                }
<i>1803</i>&nbsp;
<i>1804</i>&nbsp;                /* We need to worry only about dX because dY is in denominator
<i>1805</i>&nbsp;                 * and abs(dy) &lt; MDP_MULT (cy is a first scanline of the scan
<i>1806</i>&nbsp;                 * converted segment and we subtract y coordinate of the
<i>1807</i>&nbsp;                 * nearest segment&#39;s end from it to obtain dy)
<i>1808</i>&nbsp;                 */
<b class="nc"><i>1809</i>&nbsp;                if (dX &gt; CALC_UBND || dX &lt; CALC_LBND)  {</b>
<b class="nc"><i>1810</i>&nbsp;                    stepx = (int)((((double)dX)*MDP_MULT)/dY);</b>
<b class="nc"><i>1811</i>&nbsp;                    x0 = x0 + (int)((((double)dX)*dy)/dY);</b>
<i>1812</i>&nbsp;                } else {
<b class="nc"><i>1813</i>&nbsp;                    stepx = (dX&lt;&lt;MDP_PREC)/dY;</b>
<b class="nc"><i>1814</i>&nbsp;                    x0 += (dX*dy)/dY;</b>
<i>1815</i>&nbsp;                }
<i>1816</i>&nbsp;
<b class="nc"><i>1817</i>&nbsp;                ne = new Edge(pnt, x0, stepx, dir);</b>
<i>1818</i>&nbsp;            }
<i>1819</i>&nbsp;
<b class="nc"><i>1820</i>&nbsp;            ne.next = head;</b>
<b class="nc"><i>1821</i>&nbsp;            ne.prev = null;</b>
<b class="nc"><i>1822</i>&nbsp;            if (head != null) {</b>
<b class="nc"><i>1823</i>&nbsp;                head.prev = ne;</b>
<i>1824</i>&nbsp;            }
<b class="nc"><i>1825</i>&nbsp;            head = pnt.edge = ne;</b>
<i>1826</i>&nbsp;        }
<i>1827</i>&nbsp;
<i>1828</i>&nbsp;        public void delete(Edge e) {
<b class="nc"><i>1829</i>&nbsp;            Edge prevp = e.prev;</b>
<b class="nc"><i>1830</i>&nbsp;            Edge nextp = e.next;</b>
<b class="nc"><i>1831</i>&nbsp;            if (prevp != null) {</b>
<b class="nc"><i>1832</i>&nbsp;                prevp.next = nextp;</b>
<i>1833</i>&nbsp;            } else {
<b class="nc"><i>1834</i>&nbsp;                head = nextp;</b>
<i>1835</i>&nbsp;            }
<b class="nc"><i>1836</i>&nbsp;            if (nextp != null) {</b>
<b class="nc"><i>1837</i>&nbsp;                nextp.prev = prevp;</b>
<i>1838</i>&nbsp;            }
<i>1839</i>&nbsp;        }
<i>1840</i>&nbsp;
<i>1841</i>&nbsp;        /**
<i>1842</i>&nbsp;         * Bubble sorting in the ascending order of the linked list.  This
<i>1843</i>&nbsp;         * implementation stops processing the list if there were no changes
<i>1844</i>&nbsp;         * during the previous pass.
<i>1845</i>&nbsp;         *
<i>1846</i>&nbsp;         * We could not use O(N) Radix sort here because in most cases list of
<i>1847</i>&nbsp;         * edges almost sorted.  So, bubble sort (O(N^2)) is working much
<i>1848</i>&nbsp;         * better.  Note, in case of array of edges Shell sort is more
<i>1849</i>&nbsp;         * efficient.
<i>1850</i>&nbsp;         */
<i>1851</i>&nbsp;        public void sort() {
<b class="nc"><i>1852</i>&nbsp;            Edge p, q, r, s = null, temp;</b>
<b class="nc"><i>1853</i>&nbsp;            boolean wasSwap = true;</b>
<i>1854</i>&nbsp;
<i>1855</i>&nbsp;            // r precedes p and s points to the node up to which
<i>1856</i>&nbsp;            // comparisons are to be made
<b class="nc"><i>1857</i>&nbsp;            while (s != head.next &amp;&amp; wasSwap) {</b>
<b class="nc"><i>1858</i>&nbsp;                r = p = head;</b>
<b class="nc"><i>1859</i>&nbsp;                q = p.next;</b>
<b class="nc"><i>1860</i>&nbsp;                wasSwap = false;</b>
<b class="nc"><i>1861</i>&nbsp;                while (p != s) {</b>
<b class="nc"><i>1862</i>&nbsp;                    if (p.x &gt;= q.x) {</b>
<b class="nc"><i>1863</i>&nbsp;                        wasSwap = true;</b>
<b class="nc"><i>1864</i>&nbsp;                        if (p == head) {</b>
<b class="nc"><i>1865</i>&nbsp;                            temp = q.next;</b>
<b class="nc"><i>1866</i>&nbsp;                            q.next = p;</b>
<b class="nc"><i>1867</i>&nbsp;                            p.next = temp;</b>
<b class="nc"><i>1868</i>&nbsp;                            head = q;</b>
<b class="nc"><i>1869</i>&nbsp;                            r = q;</b>
<i>1870</i>&nbsp;                        } else {
<b class="nc"><i>1871</i>&nbsp;                            temp = q.next;</b>
<b class="nc"><i>1872</i>&nbsp;                            q.next = p;</b>
<b class="nc"><i>1873</i>&nbsp;                            p.next = temp;</b>
<b class="nc"><i>1874</i>&nbsp;                            r.next = q;</b>
<b class="nc"><i>1875</i>&nbsp;                            r = q;</b>
<i>1876</i>&nbsp;                        }
<i>1877</i>&nbsp;                    } else {
<b class="nc"><i>1878</i>&nbsp;                        r = p;</b>
<b class="nc"><i>1879</i>&nbsp;                        p = p.next;</b>
<i>1880</i>&nbsp;                    }
<b class="nc"><i>1881</i>&nbsp;                    q = p.next;</b>
<b class="nc"><i>1882</i>&nbsp;                    if (q == s) s = p;</b>
<i>1883</i>&nbsp;                }
<i>1884</i>&nbsp;            }
<i>1885</i>&nbsp;
<i>1886</i>&nbsp;            // correction of the back links in the double linked edge list
<b class="nc"><i>1887</i>&nbsp;            p = head;</b>
<b class="nc"><i>1888</i>&nbsp;            q = null;</b>
<b class="nc"><i>1889</i>&nbsp;            while (p != null) {</b>
<b class="nc"><i>1890</i>&nbsp;                p.prev = q;</b>
<b class="nc"><i>1891</i>&nbsp;                q = p;</b>
<b class="nc"><i>1892</i>&nbsp;                p = p.next;</b>
<i>1893</i>&nbsp;            }
<i>1894</i>&nbsp;        }
<i>1895</i>&nbsp;    }
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;    private static void FillPolygon(FillProcessHandler hnd,
<i>1898</i>&nbsp;                                    int fillRule) {
<i>1899</i>&nbsp;        int k, y, n;
<i>1900</i>&nbsp;        boolean drawing;
<i>1901</i>&nbsp;        Edge active;
<b class="nc"><i>1902</i>&nbsp;        int rightBnd = hnd.dhnd.xMax - 1;</b>
<b class="nc"><i>1903</i>&nbsp;        FillData fd = hnd.fd;</b>
<b class="nc"><i>1904</i>&nbsp;        int yMin = fd.plgYMin;</b>
<b class="nc"><i>1905</i>&nbsp;        int yMax = fd.plgYMax;</b>
<b class="nc"><i>1906</i>&nbsp;        int hashSize = ((yMax - yMin)&gt;&gt;MDP_PREC) + 4;</b>
<i>1907</i>&nbsp;
<i>1908</i>&nbsp;        /* Because of support of the KEY_STROKE_CONTROL hint we are performing
<i>1909</i>&nbsp;         * shift of the coordinates at the higher level
<i>1910</i>&nbsp;         */
<b class="nc"><i>1911</i>&nbsp;        int hashOffset = ((yMin - 1) &amp; MDP_W_MASK);</b>
<i>1912</i>&nbsp;
<i>1913</i>&nbsp;        /* Winding counter */
<i>1914</i>&nbsp;        int counter;
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;        /* Calculating mask to be applied to the winding counter */
<b class="nc"><i>1917</i>&nbsp;        int counterMask =</b>
<i>1918</i>&nbsp;            (fillRule == PathIterator.WIND_NON_ZERO)? -1:1;
<i>1919</i>&nbsp;
<i>1920</i>&nbsp;        int pntOffset;
<b class="nc"><i>1921</i>&nbsp;        List&lt;Point&gt; pnts = fd.plgPnts;</b>
<b class="nc"><i>1922</i>&nbsp;        n = pnts.size();</b>
<i>1923</i>&nbsp;
<b class="nc"><i>1924</i>&nbsp;        if (n &lt;=1) return;</b>
<i>1925</i>&nbsp;
<b class="nc"><i>1926</i>&nbsp;        Point[] yHash = new Point[hashSize];</b>
<i>1927</i>&nbsp;
<i>1928</i>&nbsp;        /* Creating double linked list (prev, next links) describing path order
<i>1929</i>&nbsp;         * and hash table with points which fall between scanlines. nextByY
<i>1930</i>&nbsp;         * link is used for the points which are between same scanlines.
<i>1931</i>&nbsp;         * Scanlines are passed through the centers of the pixels.
<i>1932</i>&nbsp;         */
<b class="nc"><i>1933</i>&nbsp;        Point curpt = pnts.get(0);</b>
<b class="nc"><i>1934</i>&nbsp;        curpt.prev = null;</b>
<b class="nc"><i>1935</i>&nbsp;        for (int i = 0; i &lt; n - 1; i++) {</b>
<b class="nc"><i>1936</i>&nbsp;            curpt = pnts.get(i);</b>
<b class="nc"><i>1937</i>&nbsp;            Point nextpt = pnts.get(i + 1);</b>
<b class="nc"><i>1938</i>&nbsp;            int curHashInd = (curpt.y - hashOffset - 1) &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>1939</i>&nbsp;            curpt.nextByY = yHash[curHashInd];</b>
<b class="nc"><i>1940</i>&nbsp;            yHash[curHashInd] = curpt;</b>
<b class="nc"><i>1941</i>&nbsp;            curpt.next = nextpt;</b>
<b class="nc"><i>1942</i>&nbsp;            nextpt.prev = curpt;</b>
<i>1943</i>&nbsp;        }
<i>1944</i>&nbsp;
<b class="nc"><i>1945</i>&nbsp;        Point ept = pnts.get(n - 1);</b>
<b class="nc"><i>1946</i>&nbsp;        int curHashInd = (ept.y - hashOffset - 1) &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>1947</i>&nbsp;        ept.nextByY = yHash[curHashInd];</b>
<b class="nc"><i>1948</i>&nbsp;        yHash[curHashInd] = ept;</b>
<i>1949</i>&nbsp;
<b class="nc"><i>1950</i>&nbsp;        ActiveEdgeList activeList = new ActiveEdgeList();</b>
<i>1951</i>&nbsp;
<b class="nc"><i>1952</i>&nbsp;        for (y=hashOffset + MDP_MULT,k = 0;</b>
<b class="nc"><i>1953</i>&nbsp;             y&lt;=yMax &amp;&amp; k &lt; hashSize; y += MDP_MULT, k++)</b>
<i>1954</i>&nbsp;        {
<b class="nc"><i>1955</i>&nbsp;            for(Point pt = yHash[k];pt != null; pt=pt.nextByY) {</b>
<i>1956</i>&nbsp;                /* pt.y should be inside hashed interval
<i>1957</i>&nbsp;                 * assert(y-MDP_MULT &lt;= pt.y &amp;&amp; pt.y &lt; y);
<i>1958</i>&nbsp;                 */
<b class="nc"><i>1959</i>&nbsp;                if (pt.prev != null &amp;&amp; !pt.prev.lastPoint) {</b>
<b class="nc"><i>1960</i>&nbsp;                    if (pt.prev.edge != null &amp;&amp; pt.prev.y &lt;= y) {</b>
<b class="nc"><i>1961</i>&nbsp;                        activeList.delete(pt.prev.edge);</b>
<b class="nc"><i>1962</i>&nbsp;                        pt.prev.edge = null;</b>
<b class="nc"><i>1963</i>&nbsp;                    } else  if (pt.prev.y &gt; y) {</b>
<b class="nc"><i>1964</i>&nbsp;                        activeList.insert(pt.prev, y);</b>
<i>1965</i>&nbsp;                    }
<i>1966</i>&nbsp;                }
<i>1967</i>&nbsp;
<b class="nc"><i>1968</i>&nbsp;                if (!pt.lastPoint &amp;&amp; pt.next != null) {</b>
<b class="nc"><i>1969</i>&nbsp;                    if (pt.edge != null &amp;&amp; pt.next.y &lt;= y) {</b>
<b class="nc"><i>1970</i>&nbsp;                        activeList.delete(pt.edge);</b>
<b class="nc"><i>1971</i>&nbsp;                        pt.edge = null;</b>
<b class="nc"><i>1972</i>&nbsp;                    } else if (pt.next.y &gt; y) {</b>
<b class="nc"><i>1973</i>&nbsp;                        activeList.insert(pt, y);</b>
<i>1974</i>&nbsp;                    }
<i>1975</i>&nbsp;                }
<i>1976</i>&nbsp;            }
<i>1977</i>&nbsp;
<b class="nc"><i>1978</i>&nbsp;            if (activeList.isEmpty()) continue;</b>
<i>1979</i>&nbsp;
<b class="nc"><i>1980</i>&nbsp;            activeList.sort();</b>
<i>1981</i>&nbsp;
<b class="nc"><i>1982</i>&nbsp;            counter = 0;</b>
<b class="nc"><i>1983</i>&nbsp;            drawing = false;</b>
<i>1984</i>&nbsp;            int xl, xr;
<b class="nc"><i>1985</i>&nbsp;            xl = xr = hnd.dhnd.xMin;</b>
<b class="nc"><i>1986</i>&nbsp;            Edge curEdge = activeList.head;</b>
<b class="nc"><i>1987</i>&nbsp;            while (curEdge != null) {</b>
<b class="nc"><i>1988</i>&nbsp;                counter += curEdge.dir;</b>
<b class="nc"><i>1989</i>&nbsp;                if ((counter &amp; counterMask) != 0 &amp;&amp; !drawing) {</b>
<b class="nc"><i>1990</i>&nbsp;                    xl = (curEdge.x + MDP_MULT - 1)&gt;&gt;MDP_PREC;</b>
<b class="nc"><i>1991</i>&nbsp;                    drawing = true;</b>
<i>1992</i>&nbsp;                }
<i>1993</i>&nbsp;
<b class="nc"><i>1994</i>&nbsp;                if ((counter &amp; counterMask) == 0 &amp;&amp; drawing) {</b>
<b class="nc"><i>1995</i>&nbsp;                    xr = (curEdge.x - 1) &gt;&gt; MDP_PREC;</b>
<b class="nc"><i>1996</i>&nbsp;                    if (xl &lt;= xr) {</b>
<b class="nc"><i>1997</i>&nbsp;                        hnd.dhnd.drawScanline(xl, xr, y &gt;&gt; MDP_PREC);</b>
<i>1998</i>&nbsp;                    }
<b class="nc"><i>1999</i>&nbsp;                    drawing = false;</b>
<i>2000</i>&nbsp;                }
<i>2001</i>&nbsp;
<b class="nc"><i>2002</i>&nbsp;                curEdge.x += curEdge.dx;</b>
<b class="nc"><i>2003</i>&nbsp;                curEdge = curEdge.next;</b>
<i>2004</i>&nbsp;            }
<i>2005</i>&nbsp;
<i>2006</i>&nbsp;            /* Performing drawing till the right boundary (for correct
<i>2007</i>&nbsp;             * rendering shapes clipped at the right side)
<i>2008</i>&nbsp;             */
<b class="nc"><i>2009</i>&nbsp;            if (drawing &amp;&amp; xl &lt;= rightBnd) {</b>
<i>2010</i>&nbsp;
<i>2011</i>&nbsp;                /* Support of the strokeHint was added into the
<i>2012</i>&nbsp;                 * draw and fill methods of the sun.java2d.pipe.LoopPipe
<i>2013</i>&nbsp;                 */
<b class="nc"><i>2014</i>&nbsp;                hnd.dhnd.drawScanline(xl, rightBnd, y  &gt;&gt; MDP_PREC);</b>
<i>2015</i>&nbsp;            }
<i>2016</i>&nbsp;        }
<i>2017</i>&nbsp;    }
<i>2018</i>&nbsp;
<i>2019</i>&nbsp;    private static class FillProcessHandler extends ProcessHandler {
<i>2020</i>&nbsp;
<i>2021</i>&nbsp;        FillData fd;
<i>2022</i>&nbsp;
<i>2023</i>&nbsp;        /* Note: For more easy reading of the code below each java version of
<i>2024</i>&nbsp;         * the macros from the ProcessPath.c preceded by the commented
<i>2025</i>&nbsp;         * origin call containing verbose names of the parameters
<i>2026</i>&nbsp;         */
<i>2027</i>&nbsp;        public void  processFixedLine(int x1, int y1, int x2, int y2,
<i>2028</i>&nbsp;                                      int[] pixelInfo, boolean checkBounds,
<i>2029</i>&nbsp;                                      boolean endSubPath)
<i>2030</i>&nbsp;        {
<i>2031</i>&nbsp;            int outXMin, outXMax, outYMin, outYMax;
<i>2032</i>&nbsp;            int res;
<i>2033</i>&nbsp;
<i>2034</i>&nbsp;            /* There is no need to round line coordinates to the forward
<i>2035</i>&nbsp;             * differencing precision anymore. Such a rounding was used for
<i>2036</i>&nbsp;             * preventing the curve go out the endpoint (this sometimes does
<i>2037</i>&nbsp;             * not help). The problem was fixed in the forward differencing
<i>2038</i>&nbsp;             * loops.
<i>2039</i>&nbsp;             */
<b class="nc"><i>2040</i>&nbsp;            if (checkBounds) {</b>
<i>2041</i>&nbsp;                boolean lastClipped;
<i>2042</i>&nbsp;
<i>2043</i>&nbsp;                /* This function is used only for filling shapes, so there is no
<i>2044</i>&nbsp;                 * check for the type of clipping
<i>2045</i>&nbsp;                 */
<b class="nc"><i>2046</i>&nbsp;                int c[] = new int[]{x1, y1, x2, y2, 0, 0};</b>
<b class="nc"><i>2047</i>&nbsp;                outXMin = (int)(dhnd.xMinf * MDP_MULT);</b>
<b class="nc"><i>2048</i>&nbsp;                outXMax = (int)(dhnd.xMaxf * MDP_MULT);</b>
<b class="nc"><i>2049</i>&nbsp;                outYMin = (int)(dhnd.yMinf * MDP_MULT);</b>
<b class="nc"><i>2050</i>&nbsp;                outYMax = (int)(dhnd.yMaxf * MDP_MULT);</b>
<i>2051</i>&nbsp;
<i>2052</i>&nbsp;                /*
<i>2053</i>&nbsp;                 * TESTANDCLIP(outYMin, outYMax, y1, x1, y2, x2, res);
<i>2054</i>&nbsp;                 */
<b class="nc"><i>2055</i>&nbsp;                res = TESTANDCLIP(outYMin, outYMax, c, 1, 0, 3, 2);</b>
<b class="nc"><i>2056</i>&nbsp;                if (res == CRES_INVISIBLE) return;</b>
<i>2057</i>&nbsp;
<i>2058</i>&nbsp;                /*
<i>2059</i>&nbsp;                 * TESTANDCLIP(outYMin, outYMax, y2, x2, y1, x1, res);
<i>2060</i>&nbsp;                 */
<b class="nc"><i>2061</i>&nbsp;                res = TESTANDCLIP(outYMin, outYMax, c, 3, 2, 1, 0);</b>
<b class="nc"><i>2062</i>&nbsp;                if (res == CRES_INVISIBLE) return;</b>
<b class="nc"><i>2063</i>&nbsp;                lastClipped = IS_CLIPPED(res);</b>
<i>2064</i>&nbsp;
<i>2065</i>&nbsp;                /* Clamping starting from first vertex of the processed
<i>2066</i>&nbsp;                 * segment
<i>2067</i>&nbsp;                 *
<i>2068</i>&nbsp;                 * CLIPCLAMP(outXMin, outXMax, x1, y1, x2, y2, x3, y3, res);
<i>2069</i>&nbsp;                 */
<b class="nc"><i>2070</i>&nbsp;                res = CLIPCLAMP(outXMin, outXMax, c, 0, 1, 2, 3, 4, 5);</b>
<i>2071</i>&nbsp;
<i>2072</i>&nbsp;                /* Clamping only by left boundary */
<b class="nc"><i>2073</i>&nbsp;                if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>2074</i>&nbsp;                    processFixedLine(c[4], c[5], c[0], c[1], pixelInfo,</b>
<i>2075</i>&nbsp;                                     false, lastClipped);
<i>2076</i>&nbsp;
<b class="nc"><i>2077</i>&nbsp;                } else if (res == CRES_INVISIBLE) {</b>
<i>2078</i>&nbsp;                    return;
<i>2079</i>&nbsp;                }
<i>2080</i>&nbsp;
<i>2081</i>&nbsp;                /* Clamping starting from last vertex of the processed
<i>2082</i>&nbsp;                 * segment
<i>2083</i>&nbsp;                 *
<i>2084</i>&nbsp;                 * CLIPCLAMP(outXMin, outXMax, x2, y2, x1, y1, x3, y3, res);
<i>2085</i>&nbsp;                 */
<b class="nc"><i>2086</i>&nbsp;                res = CLIPCLAMP(outXMin, outXMax, c, 2, 3, 0, 1, 4, 5);</b>
<i>2087</i>&nbsp;
<i>2088</i>&nbsp;                /* Checking if there was a clip by right boundary */
<b class="nc"><i>2089</i>&nbsp;                lastClipped = lastClipped || (res == CRES_MAX_CLIPPED);</b>
<i>2090</i>&nbsp;
<b class="nc"><i>2091</i>&nbsp;                processFixedLine(c[0], c[1], c[2], c[3], pixelInfo,</b>
<i>2092</i>&nbsp;                                 false, lastClipped);
<i>2093</i>&nbsp;
<i>2094</i>&nbsp;                /* Clamping only by left boundary */
<b class="nc"><i>2095</i>&nbsp;                if (res == CRES_MIN_CLIPPED) {</b>
<b class="nc"><i>2096</i>&nbsp;                    processFixedLine(c[2], c[3], c[4], c[5], pixelInfo,</b>
<i>2097</i>&nbsp;                                     false, lastClipped);
<i>2098</i>&nbsp;                }
<i>2099</i>&nbsp;
<i>2100</i>&nbsp;                return;
<i>2101</i>&nbsp;            }
<i>2102</i>&nbsp;
<i>2103</i>&nbsp;            /* Adding first point of the line only in case of empty or just
<i>2104</i>&nbsp;             * finished path
<i>2105</i>&nbsp;             */
<b class="nc"><i>2106</i>&nbsp;            if (fd.isEmpty() || fd.isEnded()) {</b>
<b class="nc"><i>2107</i>&nbsp;                fd.addPoint(x1, y1, false);</b>
<i>2108</i>&nbsp;            }
<i>2109</i>&nbsp;
<b class="nc"><i>2110</i>&nbsp;            fd.addPoint(x2, y2, false);</b>
<i>2111</i>&nbsp;
<b class="nc"><i>2112</i>&nbsp;            if (endSubPath) {</b>
<b class="nc"><i>2113</i>&nbsp;                fd.setEnded();</b>
<i>2114</i>&nbsp;            }
<i>2115</i>&nbsp;        }
<i>2116</i>&nbsp;
<i>2117</i>&nbsp;        FillProcessHandler(DrawHandler dhnd) {
<b class="nc"><i>2118</i>&nbsp;            super(dhnd, PH_MODE_FILL_CLIP);</b>
<b class="nc"><i>2119</i>&nbsp;            this.fd = new FillData();</b>
<i>2120</i>&nbsp;        }
<i>2121</i>&nbsp;
<i>2122</i>&nbsp;        public void processEndSubPath() {
<b class="nc"><i>2123</i>&nbsp;            if (!fd.isEmpty()) {</b>
<b class="nc"><i>2124</i>&nbsp;                fd.setEnded();</b>
<i>2125</i>&nbsp;            }
<i>2126</i>&nbsp;        }
<i>2127</i>&nbsp;    }
<i>2128</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
