


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DStroker</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.java2d.marlin</a> ]
</div>

<h1>Coverage Summary for Class: DStroker (sun.java2d.marlin)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DStroker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 555)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.java2d.marlin;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.Arrays;
<i>29</i>&nbsp;import sun.java2d.marlin.DHelpers.PolyStack;
<i>30</i>&nbsp;import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;
<i>31</i>&nbsp;import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;
<i>32</i>&nbsp;
<i>33</i>&nbsp;// TODO: some of the arithmetic here is too verbose and prone to hard to
<i>34</i>&nbsp;// debug typos. We should consider making a small Point/Vector class that
<i>35</i>&nbsp;// has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
<b class="nc"><i>36</i>&nbsp;final class DStroker implements DPathConsumer2D, MarlinConst {</b>
<i>37</i>&nbsp;
<i>38</i>&nbsp;    private static final int MOVE_TO = 0;
<i>39</i>&nbsp;    private static final int DRAWING_OP_TO = 1; // ie. curve, line, or quad
<i>40</i>&nbsp;    private static final int CLOSE = 2;
<i>41</i>&nbsp;
<i>42</i>&nbsp;    // round join threshold = 1 subpixel
<b class="nc"><i>43</i>&nbsp;    private static final double ERR_JOIN = (1.0f / MIN_SUBPIXELS);</b>
<b class="nc"><i>44</i>&nbsp;    private static final double ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;</b>
<i>45</i>&nbsp;
<i>46</i>&nbsp;    // kappa = (4/3) * (SQRT(2) - 1)
<b class="nc"><i>47</i>&nbsp;    private static final double C = (4.0d * (Math.sqrt(2.0d) - 1.0d) / 3.0d);</b>
<i>48</i>&nbsp;
<i>49</i>&nbsp;    // SQRT(2)
<b class="nc"><i>50</i>&nbsp;    private static final double SQRT_2 = Math.sqrt(2.0d);</b>
<i>51</i>&nbsp;
<i>52</i>&nbsp;    private DPathConsumer2D out;
<i>53</i>&nbsp;
<i>54</i>&nbsp;    private int capStyle;
<i>55</i>&nbsp;    private int joinStyle;
<i>56</i>&nbsp;
<i>57</i>&nbsp;    private double lineWidth2;
<i>58</i>&nbsp;    private double invHalfLineWidth2Sq;
<i>59</i>&nbsp;
<b class="nc"><i>60</i>&nbsp;    private final double[] offset0 = new double[2];</b>
<b class="nc"><i>61</i>&nbsp;    private final double[] offset1 = new double[2];</b>
<b class="nc"><i>62</i>&nbsp;    private final double[] offset2 = new double[2];</b>
<b class="nc"><i>63</i>&nbsp;    private final double[] miter = new double[2];</b>
<i>64</i>&nbsp;    private double miterLimitSq;
<i>65</i>&nbsp;
<i>66</i>&nbsp;    private int prev;
<i>67</i>&nbsp;
<i>68</i>&nbsp;    // The starting point of the path, and the slope there.
<i>69</i>&nbsp;    private double sx0, sy0, sdx, sdy;
<i>70</i>&nbsp;    // the current point and the slope there.
<i>71</i>&nbsp;    private double cx0, cy0, cdx, cdy; // c stands for current
<i>72</i>&nbsp;    // vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the
<i>73</i>&nbsp;    // first and last points on the left parallel path. Since this path is
<i>74</i>&nbsp;    // parallel, it&#39;s slope at any point is parallel to the slope of the
<i>75</i>&nbsp;    // original path (thought they may have different directions), so these
<i>76</i>&nbsp;    // could be computed from sdx,sdy and cdx,cdy (and vice versa), but that
<i>77</i>&nbsp;    // would be error prone and hard to read, so we keep these anyway.
<i>78</i>&nbsp;    private double smx, smy, cmx, cmy;
<i>79</i>&nbsp;
<i>80</i>&nbsp;    private final PolyStack reverse;
<i>81</i>&nbsp;
<b class="nc"><i>82</i>&nbsp;    private final double[] lp = new double[8];</b>
<b class="nc"><i>83</i>&nbsp;    private final double[] rp = new double[8];</b>
<i>84</i>&nbsp;
<i>85</i>&nbsp;    // per-thread renderer context
<i>86</i>&nbsp;    final DRendererContext rdrCtx;
<i>87</i>&nbsp;
<i>88</i>&nbsp;    // dirty curve
<i>89</i>&nbsp;    final DCurve curve;
<i>90</i>&nbsp;
<i>91</i>&nbsp;    // Bounds of the drawing region, at pixel precision.
<i>92</i>&nbsp;    private double[] clipRect;
<i>93</i>&nbsp;
<i>94</i>&nbsp;    // the outcode of the current point
<b class="nc"><i>95</i>&nbsp;    private int cOutCode = 0;</b>
<i>96</i>&nbsp;
<i>97</i>&nbsp;    // the outcode of the starting point
<b class="nc"><i>98</i>&nbsp;    private int sOutCode = 0;</b>
<i>99</i>&nbsp;
<i>100</i>&nbsp;    // flag indicating if the path is opened (clipped)
<b class="nc"><i>101</i>&nbsp;    private boolean opened = false;</b>
<i>102</i>&nbsp;    // flag indicating if the starting point&#39;s cap is done
<b class="nc"><i>103</i>&nbsp;    private boolean capStart = false;</b>
<i>104</i>&nbsp;    // flag indicating to monotonize curves
<i>105</i>&nbsp;    private boolean monotonize;
<i>106</i>&nbsp;
<b class="nc"><i>107</i>&nbsp;    private boolean subdivide = false;</b>
<i>108</i>&nbsp;    private final CurveClipSplitter curveSplitter;
<i>109</i>&nbsp;
<i>110</i>&nbsp;    /**
<i>111</i>&nbsp;     * Constructs a &lt;code&gt;DStroker&lt;/code&gt;.
<i>112</i>&nbsp;     * @param rdrCtx per-thread renderer context
<i>113</i>&nbsp;     */
<b class="nc"><i>114</i>&nbsp;    DStroker(final DRendererContext rdrCtx) {</b>
<b class="nc"><i>115</i>&nbsp;        this.rdrCtx = rdrCtx;</b>
<i>116</i>&nbsp;
<b class="nc"><i>117</i>&nbsp;        this.reverse = (rdrCtx.stats != null) ?</b>
<i>118</i>&nbsp;            new PolyStack(rdrCtx,
<i>119</i>&nbsp;                    rdrCtx.stats.stat_str_polystack_types,
<i>120</i>&nbsp;                    rdrCtx.stats.stat_str_polystack_curves,
<i>121</i>&nbsp;                    rdrCtx.stats.hist_str_polystack_curves,
<i>122</i>&nbsp;                    rdrCtx.stats.stat_array_str_polystack_curves,
<i>123</i>&nbsp;                    rdrCtx.stats.stat_array_str_polystack_types)
<i>124</i>&nbsp;            : new PolyStack(rdrCtx);
<i>125</i>&nbsp;
<b class="nc"><i>126</i>&nbsp;        this.curve = rdrCtx.curve;</b>
<b class="nc"><i>127</i>&nbsp;        this.curveSplitter = rdrCtx.curveClipSplitter;</b>
<i>128</i>&nbsp;    }
<i>129</i>&nbsp;
<i>130</i>&nbsp;    /**
<i>131</i>&nbsp;     * Inits the &lt;code&gt;DStroker&lt;/code&gt;.
<i>132</i>&nbsp;     *
<i>133</i>&nbsp;     * @param pc2d an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
<i>134</i>&nbsp;     * @param lineWidth the desired line width in pixels
<i>135</i>&nbsp;     * @param capStyle the desired end cap style, one of
<i>136</i>&nbsp;     * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
<i>137</i>&nbsp;     * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
<i>138</i>&nbsp;     * @param joinStyle the desired line join style, one of
<i>139</i>&nbsp;     * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
<i>140</i>&nbsp;     * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
<i>141</i>&nbsp;     * @param miterLimit the desired miter limit
<i>142</i>&nbsp;     * @param scale scaling factor applied to clip boundaries
<i>143</i>&nbsp;     * @param subdivideCurves true to indicate to subdivide curves, false if dasher does
<i>144</i>&nbsp;     * @return this instance
<i>145</i>&nbsp;     */
<i>146</i>&nbsp;    DStroker init(final DPathConsumer2D pc2d,
<i>147</i>&nbsp;                  final double lineWidth,
<i>148</i>&nbsp;                  final int capStyle,
<i>149</i>&nbsp;                  final int joinStyle,
<i>150</i>&nbsp;                  final double miterLimit,
<i>151</i>&nbsp;                  final double scale,
<i>152</i>&nbsp;                  final boolean subdivideCurves)
<i>153</i>&nbsp;    {
<b class="nc"><i>154</i>&nbsp;        this.out = pc2d;</b>
<i>155</i>&nbsp;
<b class="nc"><i>156</i>&nbsp;        this.lineWidth2 = lineWidth / 2.0d;</b>
<b class="nc"><i>157</i>&nbsp;        this.invHalfLineWidth2Sq = 1.0d / (2.0d * lineWidth2 * lineWidth2);</b>
<b class="nc"><i>158</i>&nbsp;        this.monotonize = subdivideCurves;</b>
<i>159</i>&nbsp;
<b class="nc"><i>160</i>&nbsp;        this.capStyle = capStyle;</b>
<b class="nc"><i>161</i>&nbsp;        this.joinStyle = joinStyle;</b>
<i>162</i>&nbsp;
<b class="nc"><i>163</i>&nbsp;        final double limit = miterLimit * lineWidth2;</b>
<b class="nc"><i>164</i>&nbsp;        this.miterLimitSq = limit * limit;</b>
<i>165</i>&nbsp;
<b class="nc"><i>166</i>&nbsp;        this.prev = CLOSE;</b>
<i>167</i>&nbsp;
<b class="nc"><i>168</i>&nbsp;        rdrCtx.stroking = 1;</b>
<i>169</i>&nbsp;
<b class="nc"><i>170</i>&nbsp;        if (rdrCtx.doClip) {</b>
<i>171</i>&nbsp;            // Adjust the clipping rectangle with the stroker margin (miter limit, width)
<b class="nc"><i>172</i>&nbsp;            double rdrOffX = 0.0d, rdrOffY = 0.0d;</b>
<b class="nc"><i>173</i>&nbsp;            double margin = lineWidth2;</b>
<i>174</i>&nbsp;
<b class="nc"><i>175</i>&nbsp;            if (capStyle == CAP_SQUARE) {</b>
<b class="nc"><i>176</i>&nbsp;                margin *= SQRT_2;</b>
<i>177</i>&nbsp;            }
<b class="nc"><i>178</i>&nbsp;            if ((joinStyle == JOIN_MITER) &amp;&amp; (margin &lt; limit)) {</b>
<b class="nc"><i>179</i>&nbsp;                margin = limit;</b>
<i>180</i>&nbsp;            }
<b class="nc"><i>181</i>&nbsp;            if (scale != 1.0d) {</b>
<b class="nc"><i>182</i>&nbsp;                margin *= scale;</b>
<b class="nc"><i>183</i>&nbsp;                rdrOffX = scale * DRenderer.RDR_OFFSET_X;</b>
<b class="nc"><i>184</i>&nbsp;                rdrOffY = scale * DRenderer.RDR_OFFSET_Y;</b>
<i>185</i>&nbsp;            }
<i>186</i>&nbsp;            // add a small rounding error:
<b class="nc"><i>187</i>&nbsp;            margin += 1e-3d;</b>
<i>188</i>&nbsp;
<i>189</i>&nbsp;            // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
<i>190</i>&nbsp;            // adjust clip rectangle (ymin, ymax, xmin, xmax):
<b class="nc"><i>191</i>&nbsp;            final double[] _clipRect = rdrCtx.clipRect;</b>
<b class="nc"><i>192</i>&nbsp;            _clipRect[0] -= margin - rdrOffY;</b>
<b class="nc"><i>193</i>&nbsp;            _clipRect[1] += margin + rdrOffY;</b>
<b class="nc"><i>194</i>&nbsp;            _clipRect[2] -= margin - rdrOffX;</b>
<b class="nc"><i>195</i>&nbsp;            _clipRect[3] += margin + rdrOffX;</b>
<b class="nc"><i>196</i>&nbsp;            this.clipRect = _clipRect;</b>
<i>197</i>&nbsp;
<i>198</i>&nbsp;            // initialize curve splitter here for stroker &amp; dasher:
<b class="nc"><i>199</i>&nbsp;            if (DO_CLIP_SUBDIVIDER) {</b>
<b class="nc"><i>200</i>&nbsp;                subdivide = subdivideCurves;</b>
<i>201</i>&nbsp;                // adjust padded clip rectangle:
<b class="nc"><i>202</i>&nbsp;                curveSplitter.init();</b>
<i>203</i>&nbsp;            } else {
<b class="nc"><i>204</i>&nbsp;                subdivide = false;</b>
<i>205</i>&nbsp;            }
<b class="nc"><i>206</i>&nbsp;        } else {</b>
<b class="nc"><i>207</i>&nbsp;            this.clipRect = null;</b>
<b class="nc"><i>208</i>&nbsp;            this.cOutCode = 0;</b>
<b class="nc"><i>209</i>&nbsp;            this.sOutCode = 0;</b>
<i>210</i>&nbsp;        }
<b class="nc"><i>211</i>&nbsp;        return this; // fluent API</b>
<i>212</i>&nbsp;    }
<i>213</i>&nbsp;
<i>214</i>&nbsp;    void disableClipping() {
<b class="nc"><i>215</i>&nbsp;        this.clipRect = null;</b>
<b class="nc"><i>216</i>&nbsp;        this.cOutCode = 0;</b>
<b class="nc"><i>217</i>&nbsp;        this.sOutCode = 0;</b>
<i>218</i>&nbsp;    }
<i>219</i>&nbsp;
<i>220</i>&nbsp;    /**
<i>221</i>&nbsp;     * Disposes this stroker:
<i>222</i>&nbsp;     * clean up before reusing this instance
<i>223</i>&nbsp;     */
<i>224</i>&nbsp;    void dispose() {
<b class="nc"><i>225</i>&nbsp;        reverse.dispose();</b>
<i>226</i>&nbsp;
<b class="nc"><i>227</i>&nbsp;        opened   = false;</b>
<b class="nc"><i>228</i>&nbsp;        capStart = false;</b>
<i>229</i>&nbsp;
<i>230</i>&nbsp;        if (DO_CLEAN_DIRTY) {
<i>231</i>&nbsp;            // Force zero-fill dirty arrays:
<i>232</i>&nbsp;            Arrays.fill(offset0, 0.0d);
<i>233</i>&nbsp;            Arrays.fill(offset1, 0.0d);
<i>234</i>&nbsp;            Arrays.fill(offset2, 0.0d);
<i>235</i>&nbsp;            Arrays.fill(miter, 0.0d);
<i>236</i>&nbsp;            Arrays.fill(lp, 0.0d);
<i>237</i>&nbsp;            Arrays.fill(rp, 0.0d);
<i>238</i>&nbsp;        }
<i>239</i>&nbsp;    }
<i>240</i>&nbsp;
<i>241</i>&nbsp;    private static void computeOffset(final double lx, final double ly,
<i>242</i>&nbsp;                                      final double w, final double[] m)
<i>243</i>&nbsp;    {
<b class="nc"><i>244</i>&nbsp;        double len = lx*lx + ly*ly;</b>
<b class="nc"><i>245</i>&nbsp;        if (len == 0.0d) {</b>
<b class="nc"><i>246</i>&nbsp;            m[0] = 0.0d;</b>
<b class="nc"><i>247</i>&nbsp;            m[1] = 0.0d;</b>
<i>248</i>&nbsp;        } else {
<b class="nc"><i>249</i>&nbsp;            len = Math.sqrt(len);</b>
<b class="nc"><i>250</i>&nbsp;            m[0] =  (ly * w) / len;</b>
<b class="nc"><i>251</i>&nbsp;            m[1] = -(lx * w) / len;</b>
<i>252</i>&nbsp;        }
<i>253</i>&nbsp;    }
<i>254</i>&nbsp;
<i>255</i>&nbsp;    // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
<i>256</i>&nbsp;    // clockwise (if dx1,dy1 needs to be rotated clockwise to close
<i>257</i>&nbsp;    // the smallest angle between it and dx2,dy2).
<i>258</i>&nbsp;    // This is equivalent to detecting whether a point q is on the right side
<i>259</i>&nbsp;    // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
<i>260</i>&nbsp;    // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
<i>261</i>&nbsp;    // clockwise order.
<i>262</i>&nbsp;    // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
<i>263</i>&nbsp;    private static boolean isCW(final double dx1, final double dy1,
<i>264</i>&nbsp;                                final double dx2, final double dy2)
<i>265</i>&nbsp;    {
<b class="nc"><i>266</i>&nbsp;        return dx1 * dy2 &lt;= dy1 * dx2;</b>
<i>267</i>&nbsp;    }
<i>268</i>&nbsp;
<i>269</i>&nbsp;    private void mayDrawRoundJoin(double cx, double cy,
<i>270</i>&nbsp;                                  double omx, double omy,
<i>271</i>&nbsp;                                  double mx, double my,
<i>272</i>&nbsp;                                  boolean rev)
<i>273</i>&nbsp;    {
<b class="nc"><i>274</i>&nbsp;        if ((omx == 0.0d &amp;&amp; omy == 0.0d) || (mx == 0.0d &amp;&amp; my == 0.0d)) {</b>
<i>275</i>&nbsp;            return;
<i>276</i>&nbsp;        }
<i>277</i>&nbsp;
<b class="nc"><i>278</i>&nbsp;        final double domx = omx - mx;</b>
<b class="nc"><i>279</i>&nbsp;        final double domy = omy - my;</b>
<b class="nc"><i>280</i>&nbsp;        final double lenSq = domx*domx + domy*domy;</b>
<i>281</i>&nbsp;
<b class="nc"><i>282</i>&nbsp;        if (lenSq &lt; ROUND_JOIN_THRESHOLD) {</b>
<i>283</i>&nbsp;            return;
<i>284</i>&nbsp;        }
<i>285</i>&nbsp;
<b class="nc"><i>286</i>&nbsp;        if (rev) {</b>
<b class="nc"><i>287</i>&nbsp;            omx = -omx;</b>
<b class="nc"><i>288</i>&nbsp;            omy = -omy;</b>
<b class="nc"><i>289</i>&nbsp;            mx  = -mx;</b>
<b class="nc"><i>290</i>&nbsp;            my  = -my;</b>
<i>291</i>&nbsp;        }
<b class="nc"><i>292</i>&nbsp;        drawRoundJoin(cx, cy, omx, omy, mx, my, rev);</b>
<i>293</i>&nbsp;    }
<i>294</i>&nbsp;
<i>295</i>&nbsp;    private void drawRoundJoin(double cx, double cy,
<i>296</i>&nbsp;                               double omx, double omy,
<i>297</i>&nbsp;                               double mx, double my,
<i>298</i>&nbsp;                               boolean rev)
<i>299</i>&nbsp;    {
<i>300</i>&nbsp;        // The sign of the dot product of mx,my and omx,omy is equal to the
<i>301</i>&nbsp;        // the sign of the cosine of ext
<i>302</i>&nbsp;        // (ext is the angle between omx,omy and mx,my).
<b class="nc"><i>303</i>&nbsp;        final double cosext = omx * mx + omy * my;</b>
<i>304</i>&nbsp;        // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
<i>305</i>&nbsp;        // need 1 curve to approximate the circle section that joins omx,omy
<i>306</i>&nbsp;        // and mx,my.
<b class="nc"><i>307</i>&nbsp;        final int numCurves = (cosext &gt;= 0.0d) ? 1 : 2;</b>
<i>308</i>&nbsp;
<b class="nc"><i>309</i>&nbsp;        switch (numCurves) {</b>
<i>310</i>&nbsp;        case 1:
<b class="nc"><i>311</i>&nbsp;            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);</b>
<b class="nc"><i>312</i>&nbsp;            break;</b>
<i>313</i>&nbsp;        case 2:
<i>314</i>&nbsp;            // we need to split the arc into 2 arcs spanning the same angle.
<i>315</i>&nbsp;            // The point we want will be one of the 2 intersections of the
<i>316</i>&nbsp;            // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
<i>317</i>&nbsp;            // circle. We could find this by scaling the vector
<i>318</i>&nbsp;            // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
<i>319</i>&nbsp;            // on the circle), but that can have numerical problems when the angle
<i>320</i>&nbsp;            // between omx,omy and mx,my is close to 180 degrees. So we compute a
<i>321</i>&nbsp;            // normal of (omx,omy)-(mx,my). This will be the direction of the
<i>322</i>&nbsp;            // perpendicular bisector. To get one of the intersections, we just scale
<i>323</i>&nbsp;            // this vector that its length is lineWidth2 (this works because the
<i>324</i>&nbsp;            // perpendicular bisector goes through the origin). This scaling doesn&#39;t
<i>325</i>&nbsp;            // have numerical problems because we know that lineWidth2 divided by
<i>326</i>&nbsp;            // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
<i>327</i>&nbsp;            // we know the angle of the arc is &gt; 90 degrees).
<b class="nc"><i>328</i>&nbsp;            double nx = my - omy, ny = omx - mx;</b>
<b class="nc"><i>329</i>&nbsp;            double nlen = Math.sqrt(nx*nx + ny*ny);</b>
<b class="nc"><i>330</i>&nbsp;            double scale = lineWidth2/nlen;</b>
<b class="nc"><i>331</i>&nbsp;            double mmx = nx * scale, mmy = ny * scale;</b>
<i>332</i>&nbsp;
<i>333</i>&nbsp;            // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
<i>334</i>&nbsp;            // computed the wrong intersection so we get the other one.
<i>335</i>&nbsp;            // The test above is equivalent to if (rev).
<b class="nc"><i>336</i>&nbsp;            if (rev) {</b>
<b class="nc"><i>337</i>&nbsp;                mmx = -mmx;</b>
<b class="nc"><i>338</i>&nbsp;                mmy = -mmy;</b>
<i>339</i>&nbsp;            }
<b class="nc"><i>340</i>&nbsp;            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);</b>
<b class="nc"><i>341</i>&nbsp;            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);</b>
<b class="nc"><i>342</i>&nbsp;            break;</b>
<i>343</i>&nbsp;        default:
<i>344</i>&nbsp;        }
<i>345</i>&nbsp;    }
<i>346</i>&nbsp;
<i>347</i>&nbsp;    // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
<i>348</i>&nbsp;    private void drawBezApproxForArc(final double cx, final double cy,
<i>349</i>&nbsp;                                     final double omx, final double omy,
<i>350</i>&nbsp;                                     final double mx, final double my,
<i>351</i>&nbsp;                                     boolean rev)
<i>352</i>&nbsp;    {
<b class="nc"><i>353</i>&nbsp;        final double cosext2 = (omx * mx + omy * my) * invHalfLineWidth2Sq;</b>
<i>354</i>&nbsp;
<i>355</i>&nbsp;        // check round off errors producing cos(ext) &gt; 1 and a NaN below
<i>356</i>&nbsp;        // cos(ext) == 1 implies colinear segments and an empty join anyway
<b class="nc"><i>357</i>&nbsp;        if (cosext2 &gt;= 0.5d) {</b>
<i>358</i>&nbsp;            // just return to avoid generating a flat curve:
<i>359</i>&nbsp;            return;
<i>360</i>&nbsp;        }
<i>361</i>&nbsp;
<i>362</i>&nbsp;        // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
<i>363</i>&nbsp;        // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
<i>364</i>&nbsp;        // define the bezier curve we&#39;re computing.
<i>365</i>&nbsp;        // It is computed using the constraints that P1-P0 and P3-P2 are parallel
<i>366</i>&nbsp;        // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
<b class="nc"><i>367</i>&nbsp;        double cv = ((4.0d / 3.0d) * Math.sqrt(0.5d - cosext2) /</b>
<b class="nc"><i>368</i>&nbsp;                            (1.0d + Math.sqrt(cosext2 + 0.5d)));</b>
<i>369</i>&nbsp;        // if clockwise, we need to negate cv.
<b class="nc"><i>370</i>&nbsp;        if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)</b>
<b class="nc"><i>371</i>&nbsp;            cv = -cv;</b>
<i>372</i>&nbsp;        }
<b class="nc"><i>373</i>&nbsp;        final double x1 = cx + omx;</b>
<b class="nc"><i>374</i>&nbsp;        final double y1 = cy + omy;</b>
<b class="nc"><i>375</i>&nbsp;        final double x2 = x1 - cv * omy;</b>
<b class="nc"><i>376</i>&nbsp;        final double y2 = y1 + cv * omx;</b>
<i>377</i>&nbsp;
<b class="nc"><i>378</i>&nbsp;        final double x4 = cx + mx;</b>
<b class="nc"><i>379</i>&nbsp;        final double y4 = cy + my;</b>
<b class="nc"><i>380</i>&nbsp;        final double x3 = x4 + cv * my;</b>
<b class="nc"><i>381</i>&nbsp;        final double y3 = y4 - cv * mx;</b>
<i>382</i>&nbsp;
<b class="nc"><i>383</i>&nbsp;        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);</b>
<i>384</i>&nbsp;    }
<i>385</i>&nbsp;
<i>386</i>&nbsp;    private void drawRoundCap(double cx, double cy, double mx, double my) {
<b class="nc"><i>387</i>&nbsp;        final double Cmx = C * mx;</b>
<b class="nc"><i>388</i>&nbsp;        final double Cmy = C * my;</b>
<b class="nc"><i>389</i>&nbsp;        emitCurveTo(cx + mx - Cmy, cy + my + Cmx,</b>
<i>390</i>&nbsp;                    cx - my + Cmx, cy + mx + Cmy,
<i>391</i>&nbsp;                    cx - my,       cy + mx);
<b class="nc"><i>392</i>&nbsp;        emitCurveTo(cx - my - Cmx, cy + mx - Cmy,</b>
<i>393</i>&nbsp;                    cx - mx - Cmy, cy - my + Cmx,
<i>394</i>&nbsp;                    cx - mx,       cy - my);
<i>395</i>&nbsp;    }
<i>396</i>&nbsp;
<i>397</i>&nbsp;    // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
<i>398</i>&nbsp;    // and (x0p, y0p) -&gt; (x1p, y1p) in m[off] and m[off+1]
<i>399</i>&nbsp;    private static void computeMiter(final double x0, final double y0,
<i>400</i>&nbsp;                                     final double x1, final double y1,
<i>401</i>&nbsp;                                     final double x0p, final double y0p,
<i>402</i>&nbsp;                                     final double x1p, final double y1p,
<i>403</i>&nbsp;                                     final double[] m)
<i>404</i>&nbsp;    {
<b class="nc"><i>405</i>&nbsp;        double x10 = x1 - x0;</b>
<b class="nc"><i>406</i>&nbsp;        double y10 = y1 - y0;</b>
<b class="nc"><i>407</i>&nbsp;        double x10p = x1p - x0p;</b>
<b class="nc"><i>408</i>&nbsp;        double y10p = y1p - y0p;</b>
<i>409</i>&nbsp;
<i>410</i>&nbsp;        // if this is 0, the lines are parallel. If they go in the
<i>411</i>&nbsp;        // same direction, there is no intersection so m[off] and
<i>412</i>&nbsp;        // m[off+1] will contain infinity, so no miter will be drawn.
<i>413</i>&nbsp;        // If they go in the same direction that means that the start of the
<i>414</i>&nbsp;        // current segment and the end of the previous segment have the same
<i>415</i>&nbsp;        // tangent, in which case this method won&#39;t even be involved in
<i>416</i>&nbsp;        // miter drawing because it won&#39;t be called by drawMiter (because
<i>417</i>&nbsp;        // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
<i>418</i>&nbsp;        // immediately).
<b class="nc"><i>419</i>&nbsp;        double den = x10*y10p - x10p*y10;</b>
<b class="nc"><i>420</i>&nbsp;        double t = x10p*(y0-y0p) - y10p*(x0-x0p);</b>
<b class="nc"><i>421</i>&nbsp;        t /= den;</b>
<b class="nc"><i>422</i>&nbsp;        m[0] = x0 + t*x10;</b>
<b class="nc"><i>423</i>&nbsp;        m[1] = y0 + t*y10;</b>
<i>424</i>&nbsp;    }
<i>425</i>&nbsp;
<i>426</i>&nbsp;    // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
<i>427</i>&nbsp;    // and (x0p, y0p) -&gt; (x1p, y1p) in m[off] and m[off+1]
<i>428</i>&nbsp;    private static void safeComputeMiter(final double x0, final double y0,
<i>429</i>&nbsp;                                         final double x1, final double y1,
<i>430</i>&nbsp;                                         final double x0p, final double y0p,
<i>431</i>&nbsp;                                         final double x1p, final double y1p,
<i>432</i>&nbsp;                                         final double[] m)
<i>433</i>&nbsp;    {
<b class="nc"><i>434</i>&nbsp;        double x10 = x1 - x0;</b>
<b class="nc"><i>435</i>&nbsp;        double y10 = y1 - y0;</b>
<b class="nc"><i>436</i>&nbsp;        double x10p = x1p - x0p;</b>
<b class="nc"><i>437</i>&nbsp;        double y10p = y1p - y0p;</b>
<i>438</i>&nbsp;
<i>439</i>&nbsp;        // if this is 0, the lines are parallel. If they go in the
<i>440</i>&nbsp;        // same direction, there is no intersection so m[off] and
<i>441</i>&nbsp;        // m[off+1] will contain infinity, so no miter will be drawn.
<i>442</i>&nbsp;        // If they go in the same direction that means that the start of the
<i>443</i>&nbsp;        // current segment and the end of the previous segment have the same
<i>444</i>&nbsp;        // tangent, in which case this method won&#39;t even be involved in
<i>445</i>&nbsp;        // miter drawing because it won&#39;t be called by drawMiter (because
<i>446</i>&nbsp;        // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
<i>447</i>&nbsp;        // immediately).
<b class="nc"><i>448</i>&nbsp;        double den = x10*y10p - x10p*y10;</b>
<b class="nc"><i>449</i>&nbsp;        if (den == 0.0d) {</b>
<b class="nc"><i>450</i>&nbsp;            m[2] = (x0 + x0p) / 2.0d;</b>
<b class="nc"><i>451</i>&nbsp;            m[3] = (y0 + y0p) / 2.0d;</b>
<i>452</i>&nbsp;        } else {
<b class="nc"><i>453</i>&nbsp;            double t = x10p*(y0-y0p) - y10p*(x0-x0p);</b>
<b class="nc"><i>454</i>&nbsp;            t /= den;</b>
<b class="nc"><i>455</i>&nbsp;            m[2] = x0 + t*x10;</b>
<b class="nc"><i>456</i>&nbsp;            m[3] = y0 + t*y10;</b>
<i>457</i>&nbsp;        }
<i>458</i>&nbsp;    }
<i>459</i>&nbsp;
<i>460</i>&nbsp;    private void drawMiter(final double pdx, final double pdy,
<i>461</i>&nbsp;                           final double x0, final double y0,
<i>462</i>&nbsp;                           final double dx, final double dy,
<i>463</i>&nbsp;                           double omx, double omy,
<i>464</i>&nbsp;                           double mx, double my,
<i>465</i>&nbsp;                           boolean rev)
<i>466</i>&nbsp;    {
<b class="nc"><i>467</i>&nbsp;        if ((mx == omx &amp;&amp; my == omy) ||</b>
<i>468</i>&nbsp;            (pdx == 0.0d &amp;&amp; pdy == 0.0d) ||
<i>469</i>&nbsp;            (dx == 0.0d &amp;&amp; dy == 0.0d))
<i>470</i>&nbsp;        {
<i>471</i>&nbsp;            return;
<i>472</i>&nbsp;        }
<i>473</i>&nbsp;
<b class="nc"><i>474</i>&nbsp;        if (rev) {</b>
<b class="nc"><i>475</i>&nbsp;            omx = -omx;</b>
<b class="nc"><i>476</i>&nbsp;            omy = -omy;</b>
<b class="nc"><i>477</i>&nbsp;            mx  = -mx;</b>
<b class="nc"><i>478</i>&nbsp;            my  = -my;</b>
<i>479</i>&nbsp;        }
<i>480</i>&nbsp;
<b class="nc"><i>481</i>&nbsp;        computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,</b>
<i>482</i>&nbsp;                     (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my, miter);
<i>483</i>&nbsp;
<b class="nc"><i>484</i>&nbsp;        final double miterX = miter[0];</b>
<b class="nc"><i>485</i>&nbsp;        final double miterY = miter[1];</b>
<b class="nc"><i>486</i>&nbsp;        double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);</b>
<i>487</i>&nbsp;
<i>488</i>&nbsp;        // If the lines are parallel, lenSq will be either NaN or +inf
<i>489</i>&nbsp;        // (actually, I&#39;m not sure if the latter is possible. The important
<i>490</i>&nbsp;        // thing is that -inf is not possible, because lenSq is a square).
<i>491</i>&nbsp;        // For both of those values, the comparison below will fail and
<i>492</i>&nbsp;        // no miter will be drawn, which is correct.
<b class="nc"><i>493</i>&nbsp;        if (lenSq &lt; miterLimitSq) {</b>
<b class="nc"><i>494</i>&nbsp;            emitLineTo(miterX, miterY, rev);</b>
<i>495</i>&nbsp;        }
<i>496</i>&nbsp;    }
<i>497</i>&nbsp;
<i>498</i>&nbsp;    @Override
<i>499</i>&nbsp;    public void moveTo(final double x0, final double y0) {
<b class="nc"><i>500</i>&nbsp;        _moveTo(x0, y0, cOutCode);</b>
<i>501</i>&nbsp;        // update starting point:
<b class="nc"><i>502</i>&nbsp;        this.sx0 = x0;</b>
<b class="nc"><i>503</i>&nbsp;        this.sy0 = y0;</b>
<b class="nc"><i>504</i>&nbsp;        this.sdx = 1.0d;</b>
<b class="nc"><i>505</i>&nbsp;        this.sdy = 0.0d;</b>
<b class="nc"><i>506</i>&nbsp;        this.opened   = false;</b>
<b class="nc"><i>507</i>&nbsp;        this.capStart = false;</b>
<i>508</i>&nbsp;
<b class="nc"><i>509</i>&nbsp;        if (clipRect != null) {</b>
<b class="nc"><i>510</i>&nbsp;            final int outcode = DHelpers.outcode(x0, y0, clipRect);</b>
<b class="nc"><i>511</i>&nbsp;            this.cOutCode = outcode;</b>
<b class="nc"><i>512</i>&nbsp;            this.sOutCode = outcode;</b>
<i>513</i>&nbsp;        }
<i>514</i>&nbsp;    }
<i>515</i>&nbsp;
<i>516</i>&nbsp;    private void _moveTo(final double x0, final double y0,
<i>517</i>&nbsp;                        final int outcode)
<i>518</i>&nbsp;    {
<b class="nc"><i>519</i>&nbsp;        if (prev == MOVE_TO) {</b>
<b class="nc"><i>520</i>&nbsp;            this.cx0 = x0;</b>
<b class="nc"><i>521</i>&nbsp;            this.cy0 = y0;</b>
<i>522</i>&nbsp;        } else {
<b class="nc"><i>523</i>&nbsp;            if (prev == DRAWING_OP_TO) {</b>
<b class="nc"><i>524</i>&nbsp;                finish(outcode);</b>
<i>525</i>&nbsp;            }
<b class="nc"><i>526</i>&nbsp;            this.prev = MOVE_TO;</b>
<b class="nc"><i>527</i>&nbsp;            this.cx0 = x0;</b>
<b class="nc"><i>528</i>&nbsp;            this.cy0 = y0;</b>
<b class="nc"><i>529</i>&nbsp;            this.cdx = 1.0d;</b>
<b class="nc"><i>530</i>&nbsp;            this.cdy = 0.0d;</b>
<i>531</i>&nbsp;        }
<i>532</i>&nbsp;    }
<i>533</i>&nbsp;
<i>534</i>&nbsp;    @Override
<i>535</i>&nbsp;    public void lineTo(final double x1, final double y1) {
<b class="nc"><i>536</i>&nbsp;        lineTo(x1, y1, false);</b>
<i>537</i>&nbsp;    }
<i>538</i>&nbsp;
<i>539</i>&nbsp;    private void lineTo(final double x1, final double y1,
<i>540</i>&nbsp;                        final boolean force)
<i>541</i>&nbsp;    {
<b class="nc"><i>542</i>&nbsp;        final int outcode0 = this.cOutCode;</b>
<i>543</i>&nbsp;
<b class="nc"><i>544</i>&nbsp;        if (!force &amp;&amp; clipRect != null) {</b>
<b class="nc"><i>545</i>&nbsp;            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</b>
<i>546</i>&nbsp;
<i>547</i>&nbsp;            // Should clip
<b class="nc"><i>548</i>&nbsp;            final int orCode = (outcode0 | outcode1);</b>
<b class="nc"><i>549</i>&nbsp;            if (orCode != 0) {</b>
<b class="nc"><i>550</i>&nbsp;                final int sideCode = outcode0 &amp; outcode1;</b>
<i>551</i>&nbsp;
<i>552</i>&nbsp;                // basic rejection criteria:
<b class="nc"><i>553</i>&nbsp;                if (sideCode == 0) {</b>
<i>554</i>&nbsp;                    // ovelap clip:
<b class="nc"><i>555</i>&nbsp;                    if (subdivide) {</b>
<i>556</i>&nbsp;                        // avoid reentrance
<b class="nc"><i>557</i>&nbsp;                        subdivide = false;</b>
<i>558</i>&nbsp;                        // subdivide curve =&gt; callback with subdivided parts:
<b class="nc"><i>559</i>&nbsp;                        boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,</b>
<i>560</i>&nbsp;                                                              orCode, this);
<i>561</i>&nbsp;                        // reentrance is done:
<b class="nc"><i>562</i>&nbsp;                        subdivide = true;</b>
<b class="nc"><i>563</i>&nbsp;                        if (ret) {</b>
<i>564</i>&nbsp;                            return;
<i>565</i>&nbsp;                        }
<b class="nc"><i>566</i>&nbsp;                    }</b>
<i>567</i>&nbsp;                    // already subdivided so render it
<i>568</i>&nbsp;                } else {
<b class="nc"><i>569</i>&nbsp;                    this.cOutCode = outcode1;</b>
<b class="nc"><i>570</i>&nbsp;                    _moveTo(x1, y1, outcode0);</b>
<b class="nc"><i>571</i>&nbsp;                    opened = true;</b>
<i>572</i>&nbsp;                    return;
<i>573</i>&nbsp;                }
<i>574</i>&nbsp;            }
<i>575</i>&nbsp;
<b class="nc"><i>576</i>&nbsp;            this.cOutCode = outcode1;</b>
<i>577</i>&nbsp;        }
<i>578</i>&nbsp;
<b class="nc"><i>579</i>&nbsp;        double dx = x1 - cx0;</b>
<b class="nc"><i>580</i>&nbsp;        double dy = y1 - cy0;</b>
<b class="nc"><i>581</i>&nbsp;        if (dx == 0.0d &amp;&amp; dy == 0.0d) {</b>
<b class="nc"><i>582</i>&nbsp;            dx = 1.0d;</b>
<i>583</i>&nbsp;        }
<b class="nc"><i>584</i>&nbsp;        computeOffset(dx, dy, lineWidth2, offset0);</b>
<b class="nc"><i>585</i>&nbsp;        final double mx = offset0[0];</b>
<b class="nc"><i>586</i>&nbsp;        final double my = offset0[1];</b>
<i>587</i>&nbsp;
<b class="nc"><i>588</i>&nbsp;        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my, outcode0);</b>
<i>589</i>&nbsp;
<b class="nc"><i>590</i>&nbsp;        emitLineTo(cx0 + mx, cy0 + my);</b>
<b class="nc"><i>591</i>&nbsp;        emitLineTo( x1 + mx,  y1 + my);</b>
<i>592</i>&nbsp;
<b class="nc"><i>593</i>&nbsp;        emitLineToRev(cx0 - mx, cy0 - my);</b>
<b class="nc"><i>594</i>&nbsp;        emitLineToRev( x1 - mx,  y1 - my);</b>
<i>595</i>&nbsp;
<b class="nc"><i>596</i>&nbsp;        this.prev = DRAWING_OP_TO;</b>
<b class="nc"><i>597</i>&nbsp;        this.cx0 = x1;</b>
<b class="nc"><i>598</i>&nbsp;        this.cy0 = y1;</b>
<b class="nc"><i>599</i>&nbsp;        this.cdx = dx;</b>
<b class="nc"><i>600</i>&nbsp;        this.cdy = dy;</b>
<b class="nc"><i>601</i>&nbsp;        this.cmx = mx;</b>
<b class="nc"><i>602</i>&nbsp;        this.cmy = my;</b>
<i>603</i>&nbsp;    }
<i>604</i>&nbsp;
<i>605</i>&nbsp;    @Override
<i>606</i>&nbsp;    public void closePath() {
<i>607</i>&nbsp;        // distinguish empty path at all vs opened path ?
<b class="nc"><i>608</i>&nbsp;        if (prev != DRAWING_OP_TO &amp;&amp; !opened) {</b>
<b class="nc"><i>609</i>&nbsp;            if (prev == CLOSE) {</b>
<i>610</i>&nbsp;                return;
<i>611</i>&nbsp;            }
<b class="nc"><i>612</i>&nbsp;            emitMoveTo(cx0, cy0 - lineWidth2);</b>
<i>613</i>&nbsp;
<b class="nc"><i>614</i>&nbsp;            this.sdx = 1.0d;</b>
<b class="nc"><i>615</i>&nbsp;            this.sdy = 0.0d;</b>
<b class="nc"><i>616</i>&nbsp;            this.cdx = 1.0d;</b>
<b class="nc"><i>617</i>&nbsp;            this.cdy = 0.0d;</b>
<i>618</i>&nbsp;
<b class="nc"><i>619</i>&nbsp;            this.smx = 0.0d;</b>
<b class="nc"><i>620</i>&nbsp;            this.smy = -lineWidth2;</b>
<b class="nc"><i>621</i>&nbsp;            this.cmx = 0.0d;</b>
<b class="nc"><i>622</i>&nbsp;            this.cmy = -lineWidth2;</b>
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;            finish(cOutCode);</b>
<i>625</i>&nbsp;            return;
<i>626</i>&nbsp;        }
<i>627</i>&nbsp;
<i>628</i>&nbsp;        // basic acceptance criteria
<b class="nc"><i>629</i>&nbsp;        if ((sOutCode &amp; cOutCode) == 0) {</b>
<b class="nc"><i>630</i>&nbsp;            if (cx0 != sx0 || cy0 != sy0) {</b>
<b class="nc"><i>631</i>&nbsp;                lineTo(sx0, sy0, true);</b>
<i>632</i>&nbsp;            }
<i>633</i>&nbsp;
<b class="nc"><i>634</i>&nbsp;            drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);</b>
<i>635</i>&nbsp;
<b class="nc"><i>636</i>&nbsp;            emitLineTo(sx0 + smx, sy0 + smy);</b>
<i>637</i>&nbsp;
<b class="nc"><i>638</i>&nbsp;            if (opened) {</b>
<b class="nc"><i>639</i>&nbsp;                emitLineTo(sx0 - smx, sy0 - smy);</b>
<i>640</i>&nbsp;            } else {
<b class="nc"><i>641</i>&nbsp;                emitMoveTo(sx0 - smx, sy0 - smy);</b>
<i>642</i>&nbsp;            }
<i>643</i>&nbsp;        }
<i>644</i>&nbsp;        // Ignore caps like finish(false)
<b class="nc"><i>645</i>&nbsp;        emitReverse();</b>
<i>646</i>&nbsp;
<b class="nc"><i>647</i>&nbsp;        this.prev = CLOSE;</b>
<i>648</i>&nbsp;
<b class="nc"><i>649</i>&nbsp;        if (opened) {</b>
<i>650</i>&nbsp;            // do not emit close
<b class="nc"><i>651</i>&nbsp;            opened = false;</b>
<i>652</i>&nbsp;        } else {
<b class="nc"><i>653</i>&nbsp;            emitClose();</b>
<i>654</i>&nbsp;        }
<i>655</i>&nbsp;    }
<i>656</i>&nbsp;
<i>657</i>&nbsp;    private void emitReverse() {
<b class="nc"><i>658</i>&nbsp;        reverse.popAll(out);</b>
<i>659</i>&nbsp;    }
<i>660</i>&nbsp;
<i>661</i>&nbsp;    @Override
<i>662</i>&nbsp;    public void pathDone() {
<b class="nc"><i>663</i>&nbsp;        if (prev == DRAWING_OP_TO) {</b>
<b class="nc"><i>664</i>&nbsp;            finish(cOutCode);</b>
<i>665</i>&nbsp;        }
<i>666</i>&nbsp;
<b class="nc"><i>667</i>&nbsp;        out.pathDone();</b>
<i>668</i>&nbsp;
<i>669</i>&nbsp;        // this shouldn&#39;t matter since this object won&#39;t be used
<i>670</i>&nbsp;        // after the call to this method.
<b class="nc"><i>671</i>&nbsp;        this.prev = CLOSE;</b>
<i>672</i>&nbsp;
<i>673</i>&nbsp;        // Dispose this instance:
<b class="nc"><i>674</i>&nbsp;        dispose();</b>
<i>675</i>&nbsp;    }
<i>676</i>&nbsp;
<i>677</i>&nbsp;    private void finish(final int outcode) {
<i>678</i>&nbsp;        // Problem: impossible to guess if the path will be closed in advance
<i>679</i>&nbsp;        //          i.e. if caps must be drawn or not ?
<i>680</i>&nbsp;        // Solution: use the ClosedPathDetector before Stroker to determine
<i>681</i>&nbsp;        // if the path is a closed path or not
<b class="nc"><i>682</i>&nbsp;        if (!rdrCtx.closedPath) {</b>
<b class="nc"><i>683</i>&nbsp;            if (outcode == 0) {</b>
<i>684</i>&nbsp;                // current point = end&#39;s cap:
<b class="nc"><i>685</i>&nbsp;                if (capStyle == CAP_ROUND) {</b>
<b class="nc"><i>686</i>&nbsp;                    drawRoundCap(cx0, cy0, cmx, cmy);</b>
<b class="nc"><i>687</i>&nbsp;                } else if (capStyle == CAP_SQUARE) {</b>
<b class="nc"><i>688</i>&nbsp;                    emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);</b>
<b class="nc"><i>689</i>&nbsp;                    emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);</b>
<i>690</i>&nbsp;                }
<i>691</i>&nbsp;            }
<b class="nc"><i>692</i>&nbsp;            emitReverse();</b>
<i>693</i>&nbsp;
<b class="nc"><i>694</i>&nbsp;            if (!capStart) {</b>
<b class="nc"><i>695</i>&nbsp;                capStart = true;</b>
<i>696</i>&nbsp;
<b class="nc"><i>697</i>&nbsp;                if (sOutCode == 0) {</b>
<i>698</i>&nbsp;                    // starting point = initial cap:
<b class="nc"><i>699</i>&nbsp;                    if (capStyle == CAP_ROUND) {</b>
<b class="nc"><i>700</i>&nbsp;                        drawRoundCap(sx0, sy0, -smx, -smy);</b>
<b class="nc"><i>701</i>&nbsp;                    } else if (capStyle == CAP_SQUARE) {</b>
<b class="nc"><i>702</i>&nbsp;                        emitLineTo(sx0 + smy - smx, sy0 - smx - smy);</b>
<b class="nc"><i>703</i>&nbsp;                        emitLineTo(sx0 + smy + smx, sy0 - smx + smy);</b>
<i>704</i>&nbsp;                    }
<i>705</i>&nbsp;                }
<i>706</i>&nbsp;            }
<i>707</i>&nbsp;        } else {
<b class="nc"><i>708</i>&nbsp;            emitReverse();</b>
<i>709</i>&nbsp;        }
<b class="nc"><i>710</i>&nbsp;        emitClose();</b>
<i>711</i>&nbsp;    }
<i>712</i>&nbsp;
<i>713</i>&nbsp;    private void emitMoveTo(final double x0, final double y0) {
<b class="nc"><i>714</i>&nbsp;        out.moveTo(x0, y0);</b>
<i>715</i>&nbsp;    }
<i>716</i>&nbsp;
<i>717</i>&nbsp;    private void emitLineTo(final double x1, final double y1) {
<b class="nc"><i>718</i>&nbsp;        out.lineTo(x1, y1);</b>
<i>719</i>&nbsp;    }
<i>720</i>&nbsp;
<i>721</i>&nbsp;    private void emitLineToRev(final double x1, final double y1) {
<b class="nc"><i>722</i>&nbsp;        reverse.pushLine(x1, y1);</b>
<i>723</i>&nbsp;    }
<i>724</i>&nbsp;
<i>725</i>&nbsp;    private void emitLineTo(final double x1, final double y1,
<i>726</i>&nbsp;                            final boolean rev)
<i>727</i>&nbsp;    {
<b class="nc"><i>728</i>&nbsp;        if (rev) {</b>
<b class="nc"><i>729</i>&nbsp;            emitLineToRev(x1, y1);</b>
<i>730</i>&nbsp;        } else {
<b class="nc"><i>731</i>&nbsp;            emitLineTo(x1, y1);</b>
<i>732</i>&nbsp;        }
<i>733</i>&nbsp;    }
<i>734</i>&nbsp;
<i>735</i>&nbsp;    private void emitQuadTo(final double x1, final double y1,
<i>736</i>&nbsp;                            final double x2, final double y2)
<i>737</i>&nbsp;    {
<b class="nc"><i>738</i>&nbsp;        out.quadTo(x1, y1, x2, y2);</b>
<i>739</i>&nbsp;    }
<i>740</i>&nbsp;
<i>741</i>&nbsp;    private void emitQuadToRev(final double x0, final double y0,
<i>742</i>&nbsp;                               final double x1, final double y1)
<i>743</i>&nbsp;    {
<b class="nc"><i>744</i>&nbsp;        reverse.pushQuad(x0, y0, x1, y1);</b>
<i>745</i>&nbsp;    }
<i>746</i>&nbsp;
<i>747</i>&nbsp;    private void emitCurveTo(final double x1, final double y1,
<i>748</i>&nbsp;                             final double x2, final double y2,
<i>749</i>&nbsp;                             final double x3, final double y3)
<i>750</i>&nbsp;    {
<b class="nc"><i>751</i>&nbsp;        out.curveTo(x1, y1, x2, y2, x3, y3);</b>
<i>752</i>&nbsp;    }
<i>753</i>&nbsp;
<i>754</i>&nbsp;    private void emitCurveToRev(final double x0, final double y0,
<i>755</i>&nbsp;                                final double x1, final double y1,
<i>756</i>&nbsp;                                final double x2, final double y2)
<i>757</i>&nbsp;    {
<b class="nc"><i>758</i>&nbsp;        reverse.pushCubic(x0, y0, x1, y1, x2, y2);</b>
<i>759</i>&nbsp;    }
<i>760</i>&nbsp;
<i>761</i>&nbsp;    private void emitCurveTo(final double x0, final double y0,
<i>762</i>&nbsp;                             final double x1, final double y1,
<i>763</i>&nbsp;                             final double x2, final double y2,
<i>764</i>&nbsp;                             final double x3, final double y3, final boolean rev)
<i>765</i>&nbsp;    {
<b class="nc"><i>766</i>&nbsp;        if (rev) {</b>
<b class="nc"><i>767</i>&nbsp;            reverse.pushCubic(x0, y0, x1, y1, x2, y2);</b>
<i>768</i>&nbsp;        } else {
<b class="nc"><i>769</i>&nbsp;            out.curveTo(x1, y1, x2, y2, x3, y3);</b>
<i>770</i>&nbsp;        }
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    private void emitClose() {
<b class="nc"><i>774</i>&nbsp;        out.closePath();</b>
<i>775</i>&nbsp;    }
<i>776</i>&nbsp;
<i>777</i>&nbsp;    private void drawJoin(double pdx, double pdy,
<i>778</i>&nbsp;                          double x0, double y0,
<i>779</i>&nbsp;                          double dx, double dy,
<i>780</i>&nbsp;                          double omx, double omy,
<i>781</i>&nbsp;                          double mx, double my,
<i>782</i>&nbsp;                          final int outcode)
<i>783</i>&nbsp;    {
<b class="nc"><i>784</i>&nbsp;        if (prev != DRAWING_OP_TO) {</b>
<b class="nc"><i>785</i>&nbsp;            emitMoveTo(x0 + mx, y0 + my);</b>
<b class="nc"><i>786</i>&nbsp;            if (!opened) {</b>
<b class="nc"><i>787</i>&nbsp;                this.sdx = dx;</b>
<b class="nc"><i>788</i>&nbsp;                this.sdy = dy;</b>
<b class="nc"><i>789</i>&nbsp;                this.smx = mx;</b>
<b class="nc"><i>790</i>&nbsp;                this.smy = my;</b>
<i>791</i>&nbsp;            }
<i>792</i>&nbsp;        } else {
<b class="nc"><i>793</i>&nbsp;            final boolean cw = isCW(pdx, pdy, dx, dy);</b>
<b class="nc"><i>794</i>&nbsp;            if (outcode == 0) {</b>
<b class="nc"><i>795</i>&nbsp;                if (joinStyle == JOIN_MITER) {</b>
<b class="nc"><i>796</i>&nbsp;                    drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</b>
<b class="nc"><i>797</i>&nbsp;                } else if (joinStyle == JOIN_ROUND) {</b>
<b class="nc"><i>798</i>&nbsp;                    mayDrawRoundJoin(x0, y0, omx, omy, mx, my, cw);</b>
<i>799</i>&nbsp;                }
<i>800</i>&nbsp;            }
<b class="nc"><i>801</i>&nbsp;            emitLineTo(x0, y0, !cw);</b>
<i>802</i>&nbsp;        }
<b class="nc"><i>803</i>&nbsp;        prev = DRAWING_OP_TO;</b>
<i>804</i>&nbsp;    }
<i>805</i>&nbsp;
<i>806</i>&nbsp;    private static boolean within(final double x1, final double y1,
<i>807</i>&nbsp;                                  final double x2, final double y2,
<i>808</i>&nbsp;                                  final double err)
<i>809</i>&nbsp;    {
<b class="nc"><i>810</i>&nbsp;        assert err &gt; 0 : &quot;&quot;;</b>
<i>811</i>&nbsp;        // compare taxicab distance. ERR will always be small, so using
<i>812</i>&nbsp;        // true distance won&#39;t give much benefit
<b class="nc"><i>813</i>&nbsp;        return (DHelpers.within(x1, x2, err) &amp;&amp; // we want to avoid calling Math.abs</b>
<b class="nc"><i>814</i>&nbsp;                DHelpers.within(y1, y2, err));  // this is just as good.</b>
<i>815</i>&nbsp;    }
<i>816</i>&nbsp;
<i>817</i>&nbsp;    private void getLineOffsets(final double x1, final double y1,
<i>818</i>&nbsp;                                final double x2, final double y2,
<i>819</i>&nbsp;                                final double[] left, final double[] right)
<i>820</i>&nbsp;    {
<b class="nc"><i>821</i>&nbsp;        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);</b>
<b class="nc"><i>822</i>&nbsp;        final double mx = offset0[0];</b>
<b class="nc"><i>823</i>&nbsp;        final double my = offset0[1];</b>
<b class="nc"><i>824</i>&nbsp;        left[0] = x1 + mx;</b>
<b class="nc"><i>825</i>&nbsp;        left[1] = y1 + my;</b>
<b class="nc"><i>826</i>&nbsp;        left[2] = x2 + mx;</b>
<b class="nc"><i>827</i>&nbsp;        left[3] = y2 + my;</b>
<i>828</i>&nbsp;
<b class="nc"><i>829</i>&nbsp;        right[0] = x1 - mx;</b>
<b class="nc"><i>830</i>&nbsp;        right[1] = y1 - my;</b>
<b class="nc"><i>831</i>&nbsp;        right[2] = x2 - mx;</b>
<b class="nc"><i>832</i>&nbsp;        right[3] = y2 - my;</b>
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;    private int computeOffsetCubic(final double[] pts, final int off,
<i>836</i>&nbsp;                                   final double[] leftOff,
<i>837</i>&nbsp;                                   final double[] rightOff)
<i>838</i>&nbsp;    {
<i>839</i>&nbsp;        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
<i>840</i>&nbsp;        // vanishes, which creates problems with computeOffset. Usually
<i>841</i>&nbsp;        // this happens when this stroker object is trying to widen
<i>842</i>&nbsp;        // a curve with a cusp. What happens is that curveTo splits
<i>843</i>&nbsp;        // the input curve at the cusp, and passes it to this function.
<i>844</i>&nbsp;        // because of inaccuracies in the splitting, we consider points
<i>845</i>&nbsp;        // equal if they&#39;re very close to each other.
<b class="nc"><i>846</i>&nbsp;        final double x1 = pts[off    ], y1 = pts[off + 1];</b>
<b class="nc"><i>847</i>&nbsp;        final double x2 = pts[off + 2], y2 = pts[off + 3];</b>
<b class="nc"><i>848</i>&nbsp;        final double x3 = pts[off + 4], y3 = pts[off + 5];</b>
<b class="nc"><i>849</i>&nbsp;        final double x4 = pts[off + 6], y4 = pts[off + 7];</b>
<i>850</i>&nbsp;
<b class="nc"><i>851</i>&nbsp;        double dx4 = x4 - x3;</b>
<b class="nc"><i>852</i>&nbsp;        double dy4 = y4 - y3;</b>
<b class="nc"><i>853</i>&nbsp;        double dx1 = x2 - x1;</b>
<b class="nc"><i>854</i>&nbsp;        double dy1 = y2 - y1;</b>
<i>855</i>&nbsp;
<i>856</i>&nbsp;        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
<i>857</i>&nbsp;        // in which case ignore if p1 == p2
<b class="nc"><i>858</i>&nbsp;        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));</b>
<b class="nc"><i>859</i>&nbsp;        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0d * Math.ulp(y4));</b>
<i>860</i>&nbsp;
<b class="nc"><i>861</i>&nbsp;        if (p1eqp2 &amp;&amp; p3eqp4) {</b>
<b class="nc"><i>862</i>&nbsp;            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</b>
<b class="nc"><i>863</i>&nbsp;            return 4;</b>
<b class="nc"><i>864</i>&nbsp;        } else if (p1eqp2) {</b>
<b class="nc"><i>865</i>&nbsp;            dx1 = x3 - x1;</b>
<b class="nc"><i>866</i>&nbsp;            dy1 = y3 - y1;</b>
<b class="nc"><i>867</i>&nbsp;        } else if (p3eqp4) {</b>
<b class="nc"><i>868</i>&nbsp;            dx4 = x4 - x2;</b>
<b class="nc"><i>869</i>&nbsp;            dy4 = y4 - y2;</b>
<i>870</i>&nbsp;        }
<i>871</i>&nbsp;
<i>872</i>&nbsp;        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
<b class="nc"><i>873</i>&nbsp;        double dotsq = (dx1 * dx4 + dy1 * dy4);</b>
<b class="nc"><i>874</i>&nbsp;        dotsq *= dotsq;</b>
<b class="nc"><i>875</i>&nbsp;        double l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;</b>
<i>876</i>&nbsp;
<b class="nc"><i>877</i>&nbsp;        if (DHelpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {</b>
<b class="nc"><i>878</i>&nbsp;            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);</b>
<b class="nc"><i>879</i>&nbsp;            return 4;</b>
<i>880</i>&nbsp;        }
<i>881</i>&nbsp;
<i>882</i>&nbsp;//      What we&#39;re trying to do in this function is to approximate an ideal
<i>883</i>&nbsp;//      offset curve (call it I) of the input curve B using a bezier curve Bp.
<i>884</i>&nbsp;//      The constraints I use to get the equations are:
<i>885</i>&nbsp;//
<i>886</i>&nbsp;//      1. The computed curve Bp should go through I(0) and I(1). These are
<i>887</i>&nbsp;//      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
<i>888</i>&nbsp;//      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
<i>889</i>&nbsp;//
<i>890</i>&nbsp;//      2. Bp should have slope equal in absolute value to I at the endpoints. So,
<i>891</i>&nbsp;//      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
<i>892</i>&nbsp;//      It is defined on vectors, so when we say I&#39;(0) || Bp&#39;(0) we mean that
<i>893</i>&nbsp;//      vectors I&#39;(0) and Bp&#39;(0) are aligned, which is the same as saying
<i>894</i>&nbsp;//      that the tangent lines of I and Bp at 0 are parallel. Mathematically
<i>895</i>&nbsp;//      this means (I&#39;(t) || Bp&#39;(t)) &lt;==&gt; (I&#39;(t) = c * Bp&#39;(t)) where c is some
<i>896</i>&nbsp;//      nonzero constant.)
<i>897</i>&nbsp;//      I&#39;(0) || Bp&#39;(0) and I&#39;(1) || Bp&#39;(1). Obviously, I&#39;(0) || B&#39;(0) and
<i>898</i>&nbsp;//      I&#39;(1) || B&#39;(1); therefore, Bp&#39;(0) || B&#39;(0) and Bp&#39;(1) || B&#39;(1).
<i>899</i>&nbsp;//      We know that Bp&#39;(0) || (p2p-p1p) and Bp&#39;(1) || (p4p-p3p) and the same
<i>900</i>&nbsp;//      is true for any bezier curve; therefore, we get the equations
<i>901</i>&nbsp;//          (1) p2p = c1 * (p2-p1) + p1p
<i>902</i>&nbsp;//          (2) p3p = c2 * (p4-p3) + p4p
<i>903</i>&nbsp;//      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
<i>904</i>&nbsp;//      of unknowns from 4 to 2 (i.e. just c1 and c2).
<i>905</i>&nbsp;//      To eliminate these 2 unknowns we use the following constraint:
<i>906</i>&nbsp;//
<i>907</i>&nbsp;//      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
<i>908</i>&nbsp;//      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
<i>909</i>&nbsp;//          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
<i>910</i>&nbsp;//          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
<i>911</i>&nbsp;//      We can substitute (1) and (2) from above into (4) and we get:
<i>912</i>&nbsp;//          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
<i>913</i>&nbsp;//      which is equivalent to
<i>914</i>&nbsp;//          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
<i>915</i>&nbsp;//
<i>916</i>&nbsp;//      The right side of this is a 2D vector, and we know I(0.5), which gives us
<i>917</i>&nbsp;//      Bp(0.5), which gives us the value of the right side.
<i>918</i>&nbsp;//      The left side is just a matrix vector multiplication in disguise. It is
<i>919</i>&nbsp;//
<i>920</i>&nbsp;//      [x2-x1, x4-x3][c1]
<i>921</i>&nbsp;//      [y2-y1, y4-y3][c2]
<i>922</i>&nbsp;//      which, is equal to
<i>923</i>&nbsp;//      [dx1, dx4][c1]
<i>924</i>&nbsp;//      [dy1, dy4][c2]
<i>925</i>&nbsp;//      At this point we are left with a simple linear system and we solve it by
<i>926</i>&nbsp;//      getting the inverse of the matrix above. Then we use [c1,c2] to compute
<i>927</i>&nbsp;//      p2p and p3p.
<i>928</i>&nbsp;
<b class="nc"><i>929</i>&nbsp;        double x = (x1 + 3.0d * (x2 + x3) + x4) / 8.0d;</b>
<b class="nc"><i>930</i>&nbsp;        double y = (y1 + 3.0d * (y2 + y3) + y4) / 8.0d;</b>
<i>931</i>&nbsp;        // (dxm,dym) is some tangent of B at t=0.5. This means it&#39;s equal to
<i>932</i>&nbsp;        // c*B&#39;(0.5) for some constant c.
<b class="nc"><i>933</i>&nbsp;        double dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;</b>
<i>934</i>&nbsp;
<i>935</i>&nbsp;        // this computes the offsets at t=0, 0.5, 1, using the property that
<i>936</i>&nbsp;        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
<i>937</i>&nbsp;        // the (dx/dt, dy/dt) vectors at the endpoints.
<b class="nc"><i>938</i>&nbsp;        computeOffset(dx1, dy1, lineWidth2, offset0);</b>
<b class="nc"><i>939</i>&nbsp;        computeOffset(dxm, dym, lineWidth2, offset1);</b>
<b class="nc"><i>940</i>&nbsp;        computeOffset(dx4, dy4, lineWidth2, offset2);</b>
<b class="nc"><i>941</i>&nbsp;        double x1p = x1 + offset0[0]; // start</b>
<b class="nc"><i>942</i>&nbsp;        double y1p = y1 + offset0[1]; // point</b>
<b class="nc"><i>943</i>&nbsp;        double xi  = x  + offset1[0]; // interpolation</b>
<b class="nc"><i>944</i>&nbsp;        double yi  = y  + offset1[1]; // point</b>
<b class="nc"><i>945</i>&nbsp;        double x4p = x4 + offset2[0]; // end</b>
<b class="nc"><i>946</i>&nbsp;        double y4p = y4 + offset2[1]; // point</b>
<i>947</i>&nbsp;
<b class="nc"><i>948</i>&nbsp;        double invdet43 = 4.0d / (3.0d * (dx1 * dy4 - dy1 * dx4));</b>
<i>949</i>&nbsp;
<b class="nc"><i>950</i>&nbsp;        double two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;</b>
<b class="nc"><i>951</i>&nbsp;        double two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;</b>
<b class="nc"><i>952</i>&nbsp;        double c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</b>
<b class="nc"><i>953</i>&nbsp;        double c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</b>
<i>954</i>&nbsp;
<i>955</i>&nbsp;        double x2p, y2p, x3p, y3p;
<b class="nc"><i>956</i>&nbsp;        x2p = x1p + c1*dx1;</b>
<b class="nc"><i>957</i>&nbsp;        y2p = y1p + c1*dy1;</b>
<b class="nc"><i>958</i>&nbsp;        x3p = x4p + c2*dx4;</b>
<b class="nc"><i>959</i>&nbsp;        y3p = y4p + c2*dy4;</b>
<i>960</i>&nbsp;
<b class="nc"><i>961</i>&nbsp;        leftOff[0] = x1p; leftOff[1] = y1p;</b>
<b class="nc"><i>962</i>&nbsp;        leftOff[2] = x2p; leftOff[3] = y2p;</b>
<b class="nc"><i>963</i>&nbsp;        leftOff[4] = x3p; leftOff[5] = y3p;</b>
<b class="nc"><i>964</i>&nbsp;        leftOff[6] = x4p; leftOff[7] = y4p;</b>
<i>965</i>&nbsp;
<b class="nc"><i>966</i>&nbsp;        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];</b>
<b class="nc"><i>967</i>&nbsp;        xi = xi - 2.0d * offset1[0]; yi = yi - 2.0d * offset1[1];</b>
<b class="nc"><i>968</i>&nbsp;        x4p = x4 - offset2[0]; y4p = y4 - offset2[1];</b>
<i>969</i>&nbsp;
<b class="nc"><i>970</i>&nbsp;        two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;</b>
<b class="nc"><i>971</i>&nbsp;        two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;</b>
<b class="nc"><i>972</i>&nbsp;        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);</b>
<b class="nc"><i>973</i>&nbsp;        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);</b>
<i>974</i>&nbsp;
<b class="nc"><i>975</i>&nbsp;        x2p = x1p + c1*dx1;</b>
<b class="nc"><i>976</i>&nbsp;        y2p = y1p + c1*dy1;</b>
<b class="nc"><i>977</i>&nbsp;        x3p = x4p + c2*dx4;</b>
<b class="nc"><i>978</i>&nbsp;        y3p = y4p + c2*dy4;</b>
<i>979</i>&nbsp;
<b class="nc"><i>980</i>&nbsp;        rightOff[0] = x1p; rightOff[1] = y1p;</b>
<b class="nc"><i>981</i>&nbsp;        rightOff[2] = x2p; rightOff[3] = y2p;</b>
<b class="nc"><i>982</i>&nbsp;        rightOff[4] = x3p; rightOff[5] = y3p;</b>
<b class="nc"><i>983</i>&nbsp;        rightOff[6] = x4p; rightOff[7] = y4p;</b>
<b class="nc"><i>984</i>&nbsp;        return 8;</b>
<i>985</i>&nbsp;    }
<i>986</i>&nbsp;
<i>987</i>&nbsp;    // compute offset curves using bezier spline through t=0.5 (i.e.
<i>988</i>&nbsp;    // ComputedCurve(0.5) == IdealParallelCurve(0.5))
<i>989</i>&nbsp;    // return the kind of curve in the right and left arrays.
<i>990</i>&nbsp;    private int computeOffsetQuad(final double[] pts, final int off,
<i>991</i>&nbsp;                                  final double[] leftOff,
<i>992</i>&nbsp;                                  final double[] rightOff)
<i>993</i>&nbsp;    {
<b class="nc"><i>994</i>&nbsp;        final double x1 = pts[off    ], y1 = pts[off + 1];</b>
<b class="nc"><i>995</i>&nbsp;        final double x2 = pts[off + 2], y2 = pts[off + 3];</b>
<b class="nc"><i>996</i>&nbsp;        final double x3 = pts[off + 4], y3 = pts[off + 5];</b>
<i>997</i>&nbsp;
<b class="nc"><i>998</i>&nbsp;        final double dx3 = x3 - x2;</b>
<b class="nc"><i>999</i>&nbsp;        final double dy3 = y3 - y2;</b>
<b class="nc"><i>1000</i>&nbsp;        final double dx1 = x2 - x1;</b>
<b class="nc"><i>1001</i>&nbsp;        final double dy1 = y2 - y1;</b>
<i>1002</i>&nbsp;
<i>1003</i>&nbsp;        // if p1=p2 or p3=p4 it means that the derivative at the endpoint
<i>1004</i>&nbsp;        // vanishes, which creates problems with computeOffset. Usually
<i>1005</i>&nbsp;        // this happens when this stroker object is trying to widen
<i>1006</i>&nbsp;        // a curve with a cusp. What happens is that curveTo splits
<i>1007</i>&nbsp;        // the input curve at the cusp, and passes it to this function.
<i>1008</i>&nbsp;        // because of inaccuracies in the splitting, we consider points
<i>1009</i>&nbsp;        // equal if they&#39;re very close to each other.
<i>1010</i>&nbsp;
<i>1011</i>&nbsp;        // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
<i>1012</i>&nbsp;        // in which case ignore.
<b class="nc"><i>1013</i>&nbsp;        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));</b>
<b class="nc"><i>1014</i>&nbsp;        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0d * Math.ulp(y3));</b>
<i>1015</i>&nbsp;
<b class="nc"><i>1016</i>&nbsp;        if (p1eqp2 || p2eqp3) {</b>
<b class="nc"><i>1017</i>&nbsp;            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);</b>
<b class="nc"><i>1018</i>&nbsp;            return 4;</b>
<i>1019</i>&nbsp;        }
<i>1020</i>&nbsp;
<i>1021</i>&nbsp;        // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
<b class="nc"><i>1022</i>&nbsp;        double dotsq = (dx1 * dx3 + dy1 * dy3);</b>
<b class="nc"><i>1023</i>&nbsp;        dotsq *= dotsq;</b>
<b class="nc"><i>1024</i>&nbsp;        double l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;</b>
<i>1025</i>&nbsp;
<b class="nc"><i>1026</i>&nbsp;        if (DHelpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {</b>
<b class="nc"><i>1027</i>&nbsp;            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);</b>
<b class="nc"><i>1028</i>&nbsp;            return 4;</b>
<i>1029</i>&nbsp;        }
<i>1030</i>&nbsp;
<i>1031</i>&nbsp;        // this computes the offsets at t=0, 0.5, 1, using the property that
<i>1032</i>&nbsp;        // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
<i>1033</i>&nbsp;        // the (dx/dt, dy/dt) vectors at the endpoints.
<b class="nc"><i>1034</i>&nbsp;        computeOffset(dx1, dy1, lineWidth2, offset0);</b>
<b class="nc"><i>1035</i>&nbsp;        computeOffset(dx3, dy3, lineWidth2, offset1);</b>
<i>1036</i>&nbsp;
<b class="nc"><i>1037</i>&nbsp;        double x1p = x1 + offset0[0]; // start</b>
<b class="nc"><i>1038</i>&nbsp;        double y1p = y1 + offset0[1]; // point</b>
<b class="nc"><i>1039</i>&nbsp;        double x3p = x3 + offset1[0]; // end</b>
<b class="nc"><i>1040</i>&nbsp;        double y3p = y3 + offset1[1]; // point</b>
<b class="nc"><i>1041</i>&nbsp;        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff);</b>
<b class="nc"><i>1042</i>&nbsp;        leftOff[0] = x1p; leftOff[1] = y1p;</b>
<b class="nc"><i>1043</i>&nbsp;        leftOff[4] = x3p; leftOff[5] = y3p;</b>
<i>1044</i>&nbsp;
<b class="nc"><i>1045</i>&nbsp;        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];</b>
<b class="nc"><i>1046</i>&nbsp;        x3p = x3 - offset1[0]; y3p = y3 - offset1[1];</b>
<b class="nc"><i>1047</i>&nbsp;        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff);</b>
<b class="nc"><i>1048</i>&nbsp;        rightOff[0] = x1p; rightOff[1] = y1p;</b>
<b class="nc"><i>1049</i>&nbsp;        rightOff[4] = x3p; rightOff[5] = y3p;</b>
<b class="nc"><i>1050</i>&nbsp;        return 6;</b>
<i>1051</i>&nbsp;    }
<i>1052</i>&nbsp;
<i>1053</i>&nbsp;    @Override
<i>1054</i>&nbsp;    public void curveTo(final double x1, final double y1,
<i>1055</i>&nbsp;                        final double x2, final double y2,
<i>1056</i>&nbsp;                        final double x3, final double y3)
<i>1057</i>&nbsp;    {
<b class="nc"><i>1058</i>&nbsp;        final int outcode0 = this.cOutCode;</b>
<i>1059</i>&nbsp;
<b class="nc"><i>1060</i>&nbsp;        if (clipRect != null) {</b>
<b class="nc"><i>1061</i>&nbsp;            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</b>
<b class="nc"><i>1062</i>&nbsp;            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);</b>
<b class="nc"><i>1063</i>&nbsp;            final int outcode3 = DHelpers.outcode(x3, y3, clipRect);</b>
<i>1064</i>&nbsp;
<i>1065</i>&nbsp;            // Should clip
<b class="nc"><i>1066</i>&nbsp;            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);</b>
<b class="nc"><i>1067</i>&nbsp;            if (orCode != 0) {</b>
<b class="nc"><i>1068</i>&nbsp;                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;</b>
<i>1069</i>&nbsp;
<i>1070</i>&nbsp;                // basic rejection criteria:
<b class="nc"><i>1071</i>&nbsp;                if (sideCode == 0) {</b>
<i>1072</i>&nbsp;                    // ovelap clip:
<b class="nc"><i>1073</i>&nbsp;                    if (subdivide) {</b>
<i>1074</i>&nbsp;                        // avoid reentrance
<b class="nc"><i>1075</i>&nbsp;                        subdivide = false;</b>
<i>1076</i>&nbsp;                        // subdivide curve =&gt; callback with subdivided parts:
<b class="nc"><i>1077</i>&nbsp;                        boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,</b>
<i>1078</i>&nbsp;                                                               x2, y2, x3, y3,
<i>1079</i>&nbsp;                                                               orCode, this);
<i>1080</i>&nbsp;                        // reentrance is done:
<b class="nc"><i>1081</i>&nbsp;                        subdivide = true;</b>
<b class="nc"><i>1082</i>&nbsp;                        if (ret) {</b>
<i>1083</i>&nbsp;                            return;
<i>1084</i>&nbsp;                        }
<b class="nc"><i>1085</i>&nbsp;                    }</b>
<i>1086</i>&nbsp;                    // already subdivided so render it
<i>1087</i>&nbsp;                } else {
<b class="nc"><i>1088</i>&nbsp;                    this.cOutCode = outcode3;</b>
<b class="nc"><i>1089</i>&nbsp;                    _moveTo(x3, y3, outcode0);</b>
<b class="nc"><i>1090</i>&nbsp;                    opened = true;</b>
<i>1091</i>&nbsp;                    return;
<i>1092</i>&nbsp;                }
<i>1093</i>&nbsp;            }
<i>1094</i>&nbsp;
<b class="nc"><i>1095</i>&nbsp;            this.cOutCode = outcode3;</b>
<i>1096</i>&nbsp;        }
<b class="nc"><i>1097</i>&nbsp;        _curveTo(x1, y1, x2, y2, x3, y3, outcode0);</b>
<i>1098</i>&nbsp;    }
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;    private void _curveTo(final double x1, final double y1,
<i>1101</i>&nbsp;                          final double x2, final double y2,
<i>1102</i>&nbsp;                          final double x3, final double y3,
<i>1103</i>&nbsp;                          final int outcode0)
<i>1104</i>&nbsp;    {
<i>1105</i>&nbsp;        // need these so we can update the state at the end of this method
<b class="nc"><i>1106</i>&nbsp;        double dxs = x1 - cx0;</b>
<b class="nc"><i>1107</i>&nbsp;        double dys = y1 - cy0;</b>
<b class="nc"><i>1108</i>&nbsp;        double dxf = x3 - x2;</b>
<b class="nc"><i>1109</i>&nbsp;        double dyf = y3 - y2;</b>
<i>1110</i>&nbsp;
<b class="nc"><i>1111</i>&nbsp;        if ((dxs == 0.0d) &amp;&amp; (dys == 0.0d)) {</b>
<b class="nc"><i>1112</i>&nbsp;            dxs = x2 - cx0;</b>
<b class="nc"><i>1113</i>&nbsp;            dys = y2 - cy0;</b>
<b class="nc"><i>1114</i>&nbsp;            if ((dxs == 0.0d) &amp;&amp; (dys == 0.0d)) {</b>
<b class="nc"><i>1115</i>&nbsp;                dxs = x3 - cx0;</b>
<b class="nc"><i>1116</i>&nbsp;                dys = y3 - cy0;</b>
<i>1117</i>&nbsp;            }
<i>1118</i>&nbsp;        }
<b class="nc"><i>1119</i>&nbsp;        if ((dxf == 0.0d) &amp;&amp; (dyf == 0.0d)) {</b>
<b class="nc"><i>1120</i>&nbsp;            dxf = x3 - x1;</b>
<b class="nc"><i>1121</i>&nbsp;            dyf = y3 - y1;</b>
<b class="nc"><i>1122</i>&nbsp;            if ((dxf == 0.0d) &amp;&amp; (dyf == 0.0d)) {</b>
<b class="nc"><i>1123</i>&nbsp;                dxf = x3 - cx0;</b>
<b class="nc"><i>1124</i>&nbsp;                dyf = y3 - cy0;</b>
<i>1125</i>&nbsp;            }
<i>1126</i>&nbsp;        }
<b class="nc"><i>1127</i>&nbsp;        if ((dxs == 0.0d) &amp;&amp; (dys == 0.0d)) {</b>
<i>1128</i>&nbsp;            // this happens if the &quot;curve&quot; is just a point
<i>1129</i>&nbsp;            // fix outcode0 for lineTo() call:
<b class="nc"><i>1130</i>&nbsp;            if (clipRect != null) {</b>
<b class="nc"><i>1131</i>&nbsp;                this.cOutCode = outcode0;</b>
<i>1132</i>&nbsp;            }
<b class="nc"><i>1133</i>&nbsp;            lineTo(cx0, cy0);</b>
<i>1134</i>&nbsp;            return;
<i>1135</i>&nbsp;        }
<i>1136</i>&nbsp;
<i>1137</i>&nbsp;        // if these vectors are too small, normalize them, to avoid future
<i>1138</i>&nbsp;        // precision problems.
<b class="nc"><i>1139</i>&nbsp;        if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {</b>
<b class="nc"><i>1140</i>&nbsp;            final double len = Math.sqrt(dxs * dxs + dys * dys);</b>
<b class="nc"><i>1141</i>&nbsp;            dxs /= len;</b>
<b class="nc"><i>1142</i>&nbsp;            dys /= len;</b>
<i>1143</i>&nbsp;        }
<b class="nc"><i>1144</i>&nbsp;        if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {</b>
<b class="nc"><i>1145</i>&nbsp;            final double len = Math.sqrt(dxf * dxf + dyf * dyf);</b>
<b class="nc"><i>1146</i>&nbsp;            dxf /= len;</b>
<b class="nc"><i>1147</i>&nbsp;            dyf /= len;</b>
<i>1148</i>&nbsp;        }
<i>1149</i>&nbsp;
<b class="nc"><i>1150</i>&nbsp;        computeOffset(dxs, dys, lineWidth2, offset0);</b>
<b class="nc"><i>1151</i>&nbsp;        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</b>
<i>1152</i>&nbsp;
<b class="nc"><i>1153</i>&nbsp;        int nSplits = 0;</b>
<i>1154</i>&nbsp;        final double[] mid;
<b class="nc"><i>1155</i>&nbsp;        final double[] l = lp;</b>
<i>1156</i>&nbsp;
<b class="nc"><i>1157</i>&nbsp;        if (monotonize) {</b>
<i>1158</i>&nbsp;            // monotonize curve:
<b class="nc"><i>1159</i>&nbsp;            final CurveBasicMonotonizer monotonizer</b>
<b class="nc"><i>1160</i>&nbsp;                = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);</b>
<i>1161</i>&nbsp;
<b class="nc"><i>1162</i>&nbsp;            nSplits = monotonizer.nbSplits;</b>
<b class="nc"><i>1163</i>&nbsp;            mid = monotonizer.middle;</b>
<b class="nc"><i>1164</i>&nbsp;        } else {</b>
<i>1165</i>&nbsp;            // use left instead:
<b class="nc"><i>1166</i>&nbsp;            mid = l;</b>
<b class="nc"><i>1167</i>&nbsp;            mid[0] = cx0; mid[1] = cy0;</b>
<b class="nc"><i>1168</i>&nbsp;            mid[2] = x1;  mid[3] = y1;</b>
<b class="nc"><i>1169</i>&nbsp;            mid[4] = x2;  mid[5] = y2;</b>
<b class="nc"><i>1170</i>&nbsp;            mid[6] = x3;  mid[7] = y3;</b>
<i>1171</i>&nbsp;        }
<b class="nc"><i>1172</i>&nbsp;        final double[] r = rp;</b>
<i>1173</i>&nbsp;
<b class="nc"><i>1174</i>&nbsp;        int kind = 0;</b>
<b class="nc"><i>1175</i>&nbsp;        for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {</b>
<b class="nc"><i>1176</i>&nbsp;            kind = computeOffsetCubic(mid, off, l, r);</b>
<i>1177</i>&nbsp;
<b class="nc"><i>1178</i>&nbsp;            emitLineTo(l[0], l[1]);</b>
<i>1179</i>&nbsp;
<b class="nc"><i>1180</i>&nbsp;            switch(kind) {</b>
<i>1181</i>&nbsp;            case 8:
<b class="nc"><i>1182</i>&nbsp;                emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);</b>
<b class="nc"><i>1183</i>&nbsp;                emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);</b>
<b class="nc"><i>1184</i>&nbsp;                break;</b>
<i>1185</i>&nbsp;            case 4:
<b class="nc"><i>1186</i>&nbsp;                emitLineTo(l[2], l[3]);</b>
<b class="nc"><i>1187</i>&nbsp;                emitLineToRev(r[0], r[1]);</b>
<b class="nc"><i>1188</i>&nbsp;                break;</b>
<i>1189</i>&nbsp;            default:
<i>1190</i>&nbsp;            }
<b class="nc"><i>1191</i>&nbsp;            emitLineToRev(r[kind - 2], r[kind - 1]);</b>
<i>1192</i>&nbsp;        }
<i>1193</i>&nbsp;
<b class="nc"><i>1194</i>&nbsp;        this.prev = DRAWING_OP_TO;</b>
<b class="nc"><i>1195</i>&nbsp;        this.cx0 = x3;</b>
<b class="nc"><i>1196</i>&nbsp;        this.cy0 = y3;</b>
<b class="nc"><i>1197</i>&nbsp;        this.cdx = dxf;</b>
<b class="nc"><i>1198</i>&nbsp;        this.cdy = dyf;</b>
<b class="nc"><i>1199</i>&nbsp;        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</b>
<b class="nc"><i>1200</i>&nbsp;        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</b>
<i>1201</i>&nbsp;    }
<i>1202</i>&nbsp;
<i>1203</i>&nbsp;    @Override
<i>1204</i>&nbsp;    public void quadTo(final double x1, final double y1,
<i>1205</i>&nbsp;                       final double x2, final double y2)
<i>1206</i>&nbsp;    {
<b class="nc"><i>1207</i>&nbsp;        final int outcode0 = this.cOutCode;</b>
<i>1208</i>&nbsp;
<b class="nc"><i>1209</i>&nbsp;        if (clipRect != null) {</b>
<b class="nc"><i>1210</i>&nbsp;            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);</b>
<b class="nc"><i>1211</i>&nbsp;            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);</b>
<i>1212</i>&nbsp;
<i>1213</i>&nbsp;            // Should clip
<b class="nc"><i>1214</i>&nbsp;            final int orCode = (outcode0 | outcode1 | outcode2);</b>
<b class="nc"><i>1215</i>&nbsp;            if (orCode != 0) {</b>
<b class="nc"><i>1216</i>&nbsp;                final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;</b>
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;                // basic rejection criteria:
<b class="nc"><i>1219</i>&nbsp;                if (sideCode == 0) {</b>
<i>1220</i>&nbsp;                    // ovelap clip:
<b class="nc"><i>1221</i>&nbsp;                    if (subdivide) {</b>
<i>1222</i>&nbsp;                        // avoid reentrance
<b class="nc"><i>1223</i>&nbsp;                        subdivide = false;</b>
<i>1224</i>&nbsp;                        // subdivide curve =&gt; call lineTo() with subdivided curves:
<b class="nc"><i>1225</i>&nbsp;                        boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,</b>
<i>1226</i>&nbsp;                                                              x2, y2, orCode, this);
<i>1227</i>&nbsp;                        // reentrance is done:
<b class="nc"><i>1228</i>&nbsp;                        subdivide = true;</b>
<b class="nc"><i>1229</i>&nbsp;                        if (ret) {</b>
<i>1230</i>&nbsp;                            return;
<i>1231</i>&nbsp;                        }
<b class="nc"><i>1232</i>&nbsp;                    }</b>
<i>1233</i>&nbsp;                    // already subdivided so render it
<i>1234</i>&nbsp;                } else {
<b class="nc"><i>1235</i>&nbsp;                    this.cOutCode = outcode2;</b>
<b class="nc"><i>1236</i>&nbsp;                    _moveTo(x2, y2, outcode0);</b>
<b class="nc"><i>1237</i>&nbsp;                    opened = true;</b>
<i>1238</i>&nbsp;                    return;
<i>1239</i>&nbsp;                }
<i>1240</i>&nbsp;            }
<i>1241</i>&nbsp;
<b class="nc"><i>1242</i>&nbsp;            this.cOutCode = outcode2;</b>
<i>1243</i>&nbsp;        }
<b class="nc"><i>1244</i>&nbsp;        _quadTo(x1, y1, x2, y2, outcode0);</b>
<i>1245</i>&nbsp;    }
<i>1246</i>&nbsp;
<i>1247</i>&nbsp;    private void _quadTo(final double x1, final double y1,
<i>1248</i>&nbsp;                         final double x2, final double y2,
<i>1249</i>&nbsp;                         final int outcode0)
<i>1250</i>&nbsp;    {
<i>1251</i>&nbsp;        // need these so we can update the state at the end of this method
<b class="nc"><i>1252</i>&nbsp;        double dxs = x1 - cx0;</b>
<b class="nc"><i>1253</i>&nbsp;        double dys = y1 - cy0;</b>
<b class="nc"><i>1254</i>&nbsp;        double dxf = x2 - x1;</b>
<b class="nc"><i>1255</i>&nbsp;        double dyf = y2 - y1;</b>
<i>1256</i>&nbsp;
<b class="nc"><i>1257</i>&nbsp;        if (((dxs == 0.0d) &amp;&amp; (dys == 0.0d)) || ((dxf == 0.0d) &amp;&amp; (dyf == 0.0d))) {</b>
<b class="nc"><i>1258</i>&nbsp;            dxs = dxf = x2 - cx0;</b>
<b class="nc"><i>1259</i>&nbsp;            dys = dyf = y2 - cy0;</b>
<i>1260</i>&nbsp;        }
<b class="nc"><i>1261</i>&nbsp;        if ((dxs == 0.0d) &amp;&amp; (dys == 0.0d)) {</b>
<i>1262</i>&nbsp;            // this happens if the &quot;curve&quot; is just a point
<i>1263</i>&nbsp;            // fix outcode0 for lineTo() call:
<b class="nc"><i>1264</i>&nbsp;            if (clipRect != null) {</b>
<b class="nc"><i>1265</i>&nbsp;                this.cOutCode = outcode0;</b>
<i>1266</i>&nbsp;            }
<b class="nc"><i>1267</i>&nbsp;            lineTo(cx0, cy0);</b>
<i>1268</i>&nbsp;            return;
<i>1269</i>&nbsp;        }
<i>1270</i>&nbsp;        // if these vectors are too small, normalize them, to avoid future
<i>1271</i>&nbsp;        // precision problems.
<b class="nc"><i>1272</i>&nbsp;        if (Math.abs(dxs) &lt; 0.1d &amp;&amp; Math.abs(dys) &lt; 0.1d) {</b>
<b class="nc"><i>1273</i>&nbsp;            final double len = Math.sqrt(dxs * dxs + dys * dys);</b>
<b class="nc"><i>1274</i>&nbsp;            dxs /= len;</b>
<b class="nc"><i>1275</i>&nbsp;            dys /= len;</b>
<i>1276</i>&nbsp;        }
<b class="nc"><i>1277</i>&nbsp;        if (Math.abs(dxf) &lt; 0.1d &amp;&amp; Math.abs(dyf) &lt; 0.1d) {</b>
<b class="nc"><i>1278</i>&nbsp;            final double len = Math.sqrt(dxf * dxf + dyf * dyf);</b>
<b class="nc"><i>1279</i>&nbsp;            dxf /= len;</b>
<b class="nc"><i>1280</i>&nbsp;            dyf /= len;</b>
<i>1281</i>&nbsp;        }
<b class="nc"><i>1282</i>&nbsp;        computeOffset(dxs, dys, lineWidth2, offset0);</b>
<b class="nc"><i>1283</i>&nbsp;        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);</b>
<i>1284</i>&nbsp;
<b class="nc"><i>1285</i>&nbsp;        int nSplits = 0;</b>
<i>1286</i>&nbsp;        final double[] mid;
<b class="nc"><i>1287</i>&nbsp;        final double[] l = lp;</b>
<i>1288</i>&nbsp;
<b class="nc"><i>1289</i>&nbsp;        if (monotonize) {</b>
<i>1290</i>&nbsp;            // monotonize quad:
<b class="nc"><i>1291</i>&nbsp;            final CurveBasicMonotonizer monotonizer</b>
<b class="nc"><i>1292</i>&nbsp;                = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);</b>
<i>1293</i>&nbsp;
<b class="nc"><i>1294</i>&nbsp;            nSplits = monotonizer.nbSplits;</b>
<b class="nc"><i>1295</i>&nbsp;            mid = monotonizer.middle;</b>
<b class="nc"><i>1296</i>&nbsp;        } else {</b>
<i>1297</i>&nbsp;            // use left instead:
<b class="nc"><i>1298</i>&nbsp;            mid = l;</b>
<b class="nc"><i>1299</i>&nbsp;            mid[0] = cx0; mid[1] = cy0;</b>
<b class="nc"><i>1300</i>&nbsp;            mid[2] = x1;  mid[3] = y1;</b>
<b class="nc"><i>1301</i>&nbsp;            mid[4] = x2;  mid[5] = y2;</b>
<i>1302</i>&nbsp;        }
<b class="nc"><i>1303</i>&nbsp;        final double[] r = rp;</b>
<i>1304</i>&nbsp;
<b class="nc"><i>1305</i>&nbsp;        int kind = 0;</b>
<b class="nc"><i>1306</i>&nbsp;        for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {</b>
<b class="nc"><i>1307</i>&nbsp;            kind = computeOffsetQuad(mid, off, l, r);</b>
<i>1308</i>&nbsp;
<b class="nc"><i>1309</i>&nbsp;            emitLineTo(l[0], l[1]);</b>
<i>1310</i>&nbsp;
<b class="nc"><i>1311</i>&nbsp;            switch(kind) {</b>
<i>1312</i>&nbsp;            case 6:
<b class="nc"><i>1313</i>&nbsp;                emitQuadTo(l[2], l[3], l[4], l[5]);</b>
<b class="nc"><i>1314</i>&nbsp;                emitQuadToRev(r[0], r[1], r[2], r[3]);</b>
<b class="nc"><i>1315</i>&nbsp;                break;</b>
<i>1316</i>&nbsp;            case 4:
<b class="nc"><i>1317</i>&nbsp;                emitLineTo(l[2], l[3]);</b>
<b class="nc"><i>1318</i>&nbsp;                emitLineToRev(r[0], r[1]);</b>
<b class="nc"><i>1319</i>&nbsp;                break;</b>
<i>1320</i>&nbsp;            default:
<i>1321</i>&nbsp;            }
<b class="nc"><i>1322</i>&nbsp;            emitLineToRev(r[kind - 2], r[kind - 1]);</b>
<i>1323</i>&nbsp;        }
<i>1324</i>&nbsp;
<b class="nc"><i>1325</i>&nbsp;        this.prev = DRAWING_OP_TO;</b>
<b class="nc"><i>1326</i>&nbsp;        this.cx0 = x2;</b>
<b class="nc"><i>1327</i>&nbsp;        this.cy0 = y2;</b>
<b class="nc"><i>1328</i>&nbsp;        this.cdx = dxf;</b>
<b class="nc"><i>1329</i>&nbsp;        this.cdy = dyf;</b>
<b class="nc"><i>1330</i>&nbsp;        this.cmx = (l[kind - 2] - r[kind - 2]) / 2.0d;</b>
<b class="nc"><i>1331</i>&nbsp;        this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;</b>
<i>1332</i>&nbsp;    }
<i>1333</i>&nbsp;
<i>1334</i>&nbsp;    @Override public long getNativeConsumer() {
<b class="nc"><i>1335</i>&nbsp;        throw new InternalError(&quot;Stroker doesn&#39;t use a native consumer&quot;);</b>
<i>1336</i>&nbsp;    }
<i>1337</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
