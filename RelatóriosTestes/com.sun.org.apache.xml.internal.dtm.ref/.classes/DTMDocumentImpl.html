


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DTMDocumentImpl</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.org.apache.xml.internal.dtm.ref</a> ]
</div>

<h1>Coverage Summary for Class: DTMDocumentImpl (com.sun.org.apache.xml.internal.dtm.ref)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DTMDocumentImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 93)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 363)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; */
<i>4</i>&nbsp;/*
<i>5</i>&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
<i>6</i>&nbsp; * contributor license agreements.  See the NOTICE file distributed with
<i>7</i>&nbsp; * this work for additional information regarding copyright ownership.
<i>8</i>&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
<i>9</i>&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
<i>10</i>&nbsp; * the License.  You may obtain a copy of the License at
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>13</i>&nbsp; *
<i>14</i>&nbsp; * Unless required by applicable law or agreed to in writing, software
<i>15</i>&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>16</i>&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>17</i>&nbsp; * See the License for the specific language governing permissions and
<i>18</i>&nbsp; * limitations under the License.
<i>19</i>&nbsp; */
<i>20</i>&nbsp;
<i>21</i>&nbsp;package com.sun.org.apache.xml.internal.dtm.ref;
<i>22</i>&nbsp;
<i>23</i>&nbsp;import javax.xml.transform.SourceLocator;
<i>24</i>&nbsp;
<i>25</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTM;
<i>26</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
<i>27</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTMAxisTraverser;
<i>28</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTMManager;
<i>29</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTMWSFilter;
<i>30</i>&nbsp;import com.sun.org.apache.xml.internal.utils.FastStringBuffer;
<i>31</i>&nbsp;import com.sun.org.apache.xml.internal.utils.XMLString;
<i>32</i>&nbsp;import com.sun.org.apache.xml.internal.utils.XMLStringFactory;
<i>33</i>&nbsp;
<i>34</i>&nbsp;import org.xml.sax.Attributes;
<i>35</i>&nbsp;import org.xml.sax.ContentHandler;
<i>36</i>&nbsp;import org.xml.sax.Locator;
<i>37</i>&nbsp;import org.xml.sax.ext.LexicalHandler;
<i>38</i>&nbsp;
<i>39</i>&nbsp;/**
<i>40</i>&nbsp; * This is the implementation of the DTM document interface.  It receives
<i>41</i>&nbsp; * requests from an XML content handler similar to that of an XML DOM or SAX parser
<i>42</i>&nbsp; * to store information from the xml document in an array based
<i>43</i>&nbsp; * dtm table structure.  This informtion is used later for document navigation,
<i>44</i>&nbsp; * query, and SAX event dispatch functions. The DTM can also be used directly as a
<i>45</i>&nbsp; * document composition model for an application.  The requests received are:
<i>46</i>&nbsp; * &lt;ul&gt;
<i>47</i>&nbsp; * &lt;li&gt;initiating DTM to set the doc handle&lt;/li&gt;
<i>48</i>&nbsp; * &lt;li&gt;resetting DTM for data structure reuse&lt;/li&gt;
<i>49</i>&nbsp; * &lt;li&gt;hinting the end of document to adjust the end of data structure pointers&lt;/li&gt;
<i>50</i>&nbsp; * &lt;li&gt;createnodes (element, comment, text, attribute, ....)&lt;/li&gt;
<i>51</i>&nbsp; * &lt;li&gt;hinting the end of an element to patch parent and siblings&lt;li&gt;
<i>52</i>&nbsp; * &lt;li&gt;setting application provided symbol name stringpool data structures&lt;/li&gt;
<i>53</i>&nbsp; * &lt;/ul&gt;
<i>54</i>&nbsp; * &lt;p&gt;State: In progress!!&lt;/p&gt;
<i>55</i>&nbsp; *
<i>56</i>&nbsp; * %REVIEW% I _think_ the SAX convention is that &quot;no namespace&quot; is expressed
<i>57</i>&nbsp; * as &quot;&quot; rather than as null (which is the DOM&#39;s convention). What should
<i>58</i>&nbsp; * DTM expect? What should it do with the other?
<i>59</i>&nbsp; *
<i>60</i>&nbsp; * &lt;p&gt;Origin: the implemention is a composite logic based on the DTM of XalanJ1 and
<i>61</i>&nbsp; *     DocImpl, DocumentImpl, ElementImpl, TextImpl, etc. of XalanJ2&lt;/p&gt;
<i>62</i>&nbsp; *
<i>63</i>&nbsp; * @LastModified: Oct 2017
<i>64</i>&nbsp; */
<i>65</i>&nbsp;public class DTMDocumentImpl
<i>66</i>&nbsp;implements DTM, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler
<i>67</i>&nbsp;{
<i>68</i>&nbsp;
<i>69</i>&nbsp;        // Number of lower bits used to represent node index.
<i>70</i>&nbsp;        protected static final byte DOCHANDLE_SHIFT = 22;
<i>71</i>&nbsp;        // Masks the lower order of node handle.
<i>72</i>&nbsp;        // Same as {@link DTMConstructor.IDENT_NODE_DEFAULT}
<i>73</i>&nbsp;        protected static final int NODEHANDLE_MASK = (1 &lt;&lt; (DOCHANDLE_SHIFT + 1)) - 1;
<i>74</i>&nbsp;        // Masks the higher order Document handle
<i>75</i>&nbsp;        // Same as {@link DTMConstructor.IDENT_DOC_DEFAULT}
<i>76</i>&nbsp;        protected static final int DOCHANDLE_MASK = -1 - NODEHANDLE_MASK;
<i>77</i>&nbsp;
<b class="nc"><i>78</i>&nbsp;        int m_docHandle = NULL;          // masked document handle for this dtm document</b>
<b class="nc"><i>79</i>&nbsp;        int m_docElement = NULL;         // nodeHandle to the root of the actual dtm doc content</b>
<i>80</i>&nbsp;
<i>81</i>&nbsp;        // Context for parse-and-append operations
<b class="nc"><i>82</i>&nbsp;        int currentParent = 0;                  // current parent - default is document root</b>
<b class="nc"><i>83</i>&nbsp;        int previousSibling = 0;                // previous sibling - no previous sibling</b>
<b class="nc"><i>84</i>&nbsp;        protected int m_currentNode = -1;               // current node</b>
<i>85</i>&nbsp;
<i>86</i>&nbsp;        // The tree under construction can itself be used as
<i>87</i>&nbsp;        // the element stack, so m_elemStack isn&#39;t needed.
<i>88</i>&nbsp;        //protected Stack m_elemStack = new Stack();     // element stack
<i>89</i>&nbsp;
<b class="nc"><i>90</i>&nbsp;        private boolean previousSiblingWasParent = false;</b>
<i>91</i>&nbsp;        // Local cache for record-at-a-time fetch
<b class="nc"><i>92</i>&nbsp;        int gotslot[] = new int[4];</b>
<i>93</i>&nbsp;
<i>94</i>&nbsp;        // endDocument recieved?
<b class="nc"><i>95</i>&nbsp;        private boolean done = false;</b>
<b class="nc"><i>96</i>&nbsp;        boolean m_isError = false;</b>
<i>97</i>&nbsp;
<b class="nc"><i>98</i>&nbsp;        private final boolean DEBUG = false;</b>
<i>99</i>&nbsp;
<i>100</i>&nbsp;        /** The document base URI. */
<i>101</i>&nbsp;        protected String m_documentBaseURI;
<i>102</i>&nbsp;
<i>103</i>&nbsp;  /** If we&#39;re building the model incrementally on demand, we need to
<i>104</i>&nbsp;   * be able to tell the source when to send us more data.
<i>105</i>&nbsp;   *
<i>106</i>&nbsp;   * Note that if this has not been set, and you attempt to read ahead
<i>107</i>&nbsp;   * of the current build point, we&#39;ll probably throw a null-pointer
<i>108</i>&nbsp;   * exception. We could try to wait-and-retry instead, as a very poor
<i>109</i>&nbsp;   * fallback, but that has all the known problems with multithreading
<i>110</i>&nbsp;   * on multiprocessors and we Don&#39;t Want to Go There.
<i>111</i>&nbsp;   *
<i>112</i>&nbsp;   * @see setIncrementalSAXSource
<i>113</i>&nbsp;   */
<b class="nc"><i>114</i>&nbsp;  private IncrementalSAXSource m_incrSAXSource=null;</b>
<i>115</i>&nbsp;
<i>116</i>&nbsp;
<i>117</i>&nbsp;        // ========= DTM data structure declarations. ==============
<i>118</i>&nbsp;
<i>119</i>&nbsp;        // nodes array: integer array blocks to hold the first level reference of the nodes,
<i>120</i>&nbsp;        // each reference slot is addressed by a nodeHandle index value.
<i>121</i>&nbsp;        // Assumes indices are not larger than {@link NODEHANDLE_MASK}
<i>122</i>&nbsp;        // ({@link DOCHANDLE_SHIFT} bits).
<b class="nc"><i>123</i>&nbsp;        ChunkedIntArray nodes = new ChunkedIntArray(4);</b>
<i>124</i>&nbsp;
<i>125</i>&nbsp;        // text/comment table: string buffer to hold the text string values of the document,
<i>126</i>&nbsp;        // each of which is addressed by the absolute offset and length in the buffer
<b class="nc"><i>127</i>&nbsp;        private FastStringBuffer m_char = new FastStringBuffer();</b>
<i>128</i>&nbsp;        // Start of string currently being accumulated into m_char;
<i>129</i>&nbsp;        // needed because the string may be appended in several chunks.
<b class="nc"><i>130</i>&nbsp;        private int m_char_current_start=0;</b>
<i>131</i>&nbsp;
<i>132</i>&nbsp;        // %TBD% INITIALIZATION/STARTUP ISSUES
<i>133</i>&nbsp;        // -- Should we really be creating these, or should they be
<i>134</i>&nbsp;        // passed in from outside? Scott want to be able to share
<i>135</i>&nbsp;        // pools across multiple documents, so setting them here is
<i>136</i>&nbsp;        // probably not the right default.
<b class="nc"><i>137</i>&nbsp;        private DTMStringPool m_localNames = new DTMStringPool();</b>
<b class="nc"><i>138</i>&nbsp;        private DTMStringPool m_nsNames = new DTMStringPool();</b>
<b class="nc"><i>139</i>&nbsp;        private DTMStringPool m_prefixNames = new DTMStringPool();</b>
<i>140</i>&nbsp;
<i>141</i>&nbsp;        // %TBD% If we use the current ExpandedNameTable mapper, it
<i>142</i>&nbsp;        // needs to be bound to the NS and local name pools. Which
<i>143</i>&nbsp;        // means it needs to attach to them AFTER we&#39;ve resolved their
<i>144</i>&nbsp;        // startup. Or it needs to attach to this document and
<i>145</i>&nbsp;        // retrieve them each time. Or this needs to be
<i>146</i>&nbsp;        // an interface _implemented_ by this class... which might be simplest!
<b class="nc"><i>147</i>&nbsp;        private ExpandedNameTable m_expandedNames=</b>
<i>148</i>&nbsp;                new ExpandedNameTable();
<i>149</i>&nbsp;
<i>150</i>&nbsp;        private XMLStringFactory m_xsf;
<i>151</i>&nbsp;
<i>152</i>&nbsp;
<i>153</i>&nbsp;        /**
<i>154</i>&nbsp;         * Construct a DTM.
<i>155</i>&nbsp;         *
<i>156</i>&nbsp;         * @param documentNumber the ID number assigned to this document.
<i>157</i>&nbsp;         * It will be shifted up into the high bits and returned as part of
<i>158</i>&nbsp;         * all node ID numbers, so those IDs indicate which document they
<i>159</i>&nbsp;         * came from as well as a location within the document. It is the
<i>160</i>&nbsp;         * DTMManager&#39;s responsibility to assign a unique number to each
<i>161</i>&nbsp;         * document.
<i>162</i>&nbsp;         */
<i>163</i>&nbsp;        public DTMDocumentImpl(DTMManager mgr, int documentNumber,
<i>164</i>&nbsp;                               DTMWSFilter whiteSpaceFilter,
<b class="nc"><i>165</i>&nbsp;                               XMLStringFactory xstringfactory){</b>
<b class="nc"><i>166</i>&nbsp;                initDocument(documentNumber);    // clear nodes and document handle</b>
<b class="nc"><i>167</i>&nbsp;                m_xsf = xstringfactory;</b>
<i>168</i>&nbsp;        }
<i>169</i>&nbsp;
<i>170</i>&nbsp;  /** Bind a IncrementalSAXSource to this DTM. If we discover we need nodes
<i>171</i>&nbsp;   * that have not yet been built, we will ask this object to send us more
<i>172</i>&nbsp;   * events, and it will manage interactions with its data sources.
<i>173</i>&nbsp;   *
<i>174</i>&nbsp;   * Note that we do not actually build the IncrementalSAXSource, since we don&#39;t
<i>175</i>&nbsp;   * know what source it&#39;s reading from, what thread that source will run in,
<i>176</i>&nbsp;   * or when it will run.
<i>177</i>&nbsp;   *
<i>178</i>&nbsp;   * @param source The IncrementalSAXSource that we want to recieve events from
<i>179</i>&nbsp;   * on demand.
<i>180</i>&nbsp;   */
<i>181</i>&nbsp;  public void setIncrementalSAXSource(IncrementalSAXSource source)
<i>182</i>&nbsp;  {
<b class="nc"><i>183</i>&nbsp;    m_incrSAXSource=source;</b>
<i>184</i>&nbsp;
<i>185</i>&nbsp;    // Establish SAX-stream link so we can receive the requested data
<b class="nc"><i>186</i>&nbsp;    source.setContentHandler(this);</b>
<b class="nc"><i>187</i>&nbsp;    source.setLexicalHandler(this);</b>
<i>188</i>&nbsp;
<i>189</i>&nbsp;    // Are the following really needed? IncrementalSAXSource doesn&#39;t yet
<i>190</i>&nbsp;    // support them, and they&#39;re mostly no-ops here...
<i>191</i>&nbsp;    //source.setErrorHandler(this);
<i>192</i>&nbsp;    //source.setDTDHandler(this);
<i>193</i>&nbsp;    //source.setDeclHandler(this);
<i>194</i>&nbsp;  }
<i>195</i>&nbsp;
<i>196</i>&nbsp;        /**
<i>197</i>&nbsp;         * Wrapper for ChunkedIntArray.append, to automatically update the
<i>198</i>&nbsp;         * previous sibling&#39;s &quot;next&quot; reference (if necessary) and periodically
<i>199</i>&nbsp;         * wake a reader who may have encountered incomplete data and entered
<i>200</i>&nbsp;         * a wait state.
<i>201</i>&nbsp;         * @param w0 int As in ChunkedIntArray.append
<i>202</i>&nbsp;         * @param w1 int As in ChunkedIntArray.append
<i>203</i>&nbsp;         * @param w2 int As in ChunkedIntArray.append
<i>204</i>&nbsp;         * @param w3 int As in ChunkedIntArray.append
<i>205</i>&nbsp;         * @return int As in ChunkedIntArray.append
<i>206</i>&nbsp;         * @see ChunkedIntArray.append
<i>207</i>&nbsp;         */
<i>208</i>&nbsp;        private final int appendNode(int w0, int w1, int w2, int w3)
<i>209</i>&nbsp;        {
<i>210</i>&nbsp;                // A decent compiler may inline this.
<b class="nc"><i>211</i>&nbsp;                int slotnumber = nodes.appendSlot(w0, w1, w2, w3);</b>
<i>212</i>&nbsp;
<i>213</i>&nbsp;                if (DEBUG) System.out.println(slotnumber+&quot;: &quot;+w0+&quot; &quot;+w1+&quot; &quot;+w2+&quot; &quot;+w3);
<i>214</i>&nbsp;
<b class="nc"><i>215</i>&nbsp;                if (previousSiblingWasParent)</b>
<b class="nc"><i>216</i>&nbsp;                        nodes.writeEntry(previousSibling,2,slotnumber);</b>
<i>217</i>&nbsp;
<b class="nc"><i>218</i>&nbsp;                previousSiblingWasParent = false;       // Set the default; endElement overrides</b>
<i>219</i>&nbsp;
<b class="nc"><i>220</i>&nbsp;                return slotnumber;</b>
<i>221</i>&nbsp;        }
<i>222</i>&nbsp;
<i>223</i>&nbsp;        // ========= DTM Implementation Control Functions. ==============
<i>224</i>&nbsp;
<i>225</i>&nbsp;        /**
<i>226</i>&nbsp;         * Set an implementation dependent feature.
<i>227</i>&nbsp;         * &lt;p&gt;
<i>228</i>&nbsp;         * %REVIEW% Do we really expect to set features on DTMs?
<i>229</i>&nbsp;         *
<i>230</i>&nbsp;         * @param featureId A feature URL.
<i>231</i>&nbsp;         * @param state true if this feature should be on, false otherwise.
<i>232</i>&nbsp;         */
<i>233</i>&nbsp;        public void setFeature(String featureId, boolean state) {};
<i>234</i>&nbsp;
<i>235</i>&nbsp;        /**
<i>236</i>&nbsp;         * Set a reference pointer to the element name symbol table.
<i>237</i>&nbsp;         * %REVIEW% Should this really be Public? Changing it while
<i>238</i>&nbsp;         * DTM is in use would be a disaster.
<i>239</i>&nbsp;         *
<i>240</i>&nbsp;         * @param poolRef DTMStringPool reference to an instance of table.
<i>241</i>&nbsp;         */
<i>242</i>&nbsp;        public void setLocalNameTable(DTMStringPool poolRef) {
<b class="nc"><i>243</i>&nbsp;                m_localNames = poolRef;</b>
<i>244</i>&nbsp;        }
<i>245</i>&nbsp;
<i>246</i>&nbsp;        /**
<i>247</i>&nbsp;         * Get a reference pointer to the element name symbol table.
<i>248</i>&nbsp;         *
<i>249</i>&nbsp;         * @return DTMStringPool reference to an instance of table.
<i>250</i>&nbsp;         */
<i>251</i>&nbsp;        public DTMStringPool getLocalNameTable() {
<b class="nc"><i>252</i>&nbsp;                 return m_localNames;</b>
<i>253</i>&nbsp;         }
<i>254</i>&nbsp;
<i>255</i>&nbsp;        /**
<i>256</i>&nbsp;         * Set a reference pointer to the namespace URI symbol table.
<i>257</i>&nbsp;         * %REVIEW% Should this really be Public? Changing it while
<i>258</i>&nbsp;         * DTM is in use would be a disaster.
<i>259</i>&nbsp;         *
<i>260</i>&nbsp;         * @param poolRef DTMStringPool reference to an instance of table.
<i>261</i>&nbsp;         */
<i>262</i>&nbsp;        public void setNsNameTable(DTMStringPool poolRef) {
<b class="nc"><i>263</i>&nbsp;                m_nsNames = poolRef;</b>
<i>264</i>&nbsp;        }
<i>265</i>&nbsp;
<i>266</i>&nbsp;        /**
<i>267</i>&nbsp;         * Get a reference pointer to the namespace URI symbol table.
<i>268</i>&nbsp;         *
<i>269</i>&nbsp;         * @return DTMStringPool reference to an instance of table.
<i>270</i>&nbsp;         */
<i>271</i>&nbsp;        public DTMStringPool getNsNameTable() {
<b class="nc"><i>272</i>&nbsp;                 return m_nsNames;</b>
<i>273</i>&nbsp;         }
<i>274</i>&nbsp;
<i>275</i>&nbsp;        /**
<i>276</i>&nbsp;         * Set a reference pointer to the prefix name symbol table.
<i>277</i>&nbsp;         * %REVIEW% Should this really be Public? Changing it while
<i>278</i>&nbsp;         * DTM is in use would be a disaster.
<i>279</i>&nbsp;         *
<i>280</i>&nbsp;         * @param poolRef DTMStringPool reference to an instance of table.
<i>281</i>&nbsp;         */
<i>282</i>&nbsp;        public void setPrefixNameTable(DTMStringPool poolRef) {
<b class="nc"><i>283</i>&nbsp;                m_prefixNames = poolRef;</b>
<i>284</i>&nbsp;        }
<i>285</i>&nbsp;
<i>286</i>&nbsp;        /**
<i>287</i>&nbsp;         * Get a reference pointer to the prefix name symbol table.
<i>288</i>&nbsp;         *
<i>289</i>&nbsp;         * @return DTMStringPool reference to an instance of table.
<i>290</i>&nbsp;         */
<i>291</i>&nbsp;        public DTMStringPool getPrefixNameTable() {
<b class="nc"><i>292</i>&nbsp;                return m_prefixNames;</b>
<i>293</i>&nbsp;        }
<i>294</i>&nbsp;
<i>295</i>&nbsp;         /**
<i>296</i>&nbsp;          * Set a reference pointer to the content-text repository
<i>297</i>&nbsp;          *
<i>298</i>&nbsp;          * @param buffer FastStringBuffer reference to an instance of
<i>299</i>&nbsp;          * buffer
<i>300</i>&nbsp;          */
<i>301</i>&nbsp;         void setContentBuffer(FastStringBuffer buffer) {
<b class="nc"><i>302</i>&nbsp;                 m_char = buffer;</b>
<i>303</i>&nbsp;         }
<i>304</i>&nbsp;
<i>305</i>&nbsp;         /**
<i>306</i>&nbsp;          * Get a reference pointer to the content-text repository
<i>307</i>&nbsp;          *
<i>308</i>&nbsp;          * @return FastStringBuffer reference to an instance of buffer
<i>309</i>&nbsp;          */
<i>310</i>&nbsp;         FastStringBuffer getContentBuffer() {
<b class="nc"><i>311</i>&nbsp;                 return m_char;</b>
<i>312</i>&nbsp;         }
<i>313</i>&nbsp;
<i>314</i>&nbsp;  /** getContentHandler returns &quot;our SAX builder&quot; -- the thing that
<i>315</i>&nbsp;   * someone else should send SAX events to in order to extend this
<i>316</i>&nbsp;   * DTM model.
<i>317</i>&nbsp;   *
<i>318</i>&nbsp;   * @return null if this model doesn&#39;t respond to SAX events,
<i>319</i>&nbsp;   * &quot;this&quot; if the DTM object has a built-in SAX ContentHandler,
<i>320</i>&nbsp;   * the IncrementalSAXSource if we&#39;re bound to one and should receive
<i>321</i>&nbsp;   * the SAX stream via it for incremental build purposes...
<i>322</i>&nbsp;   * */
<i>323</i>&nbsp;  public org.xml.sax.ContentHandler getContentHandler()
<i>324</i>&nbsp;  {
<b class="nc"><i>325</i>&nbsp;    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)</b>
<b class="nc"><i>326</i>&nbsp;      return (ContentHandler) m_incrSAXSource;</b>
<i>327</i>&nbsp;    else
<b class="nc"><i>328</i>&nbsp;      return this;</b>
<i>329</i>&nbsp;  }
<i>330</i>&nbsp;
<i>331</i>&nbsp;  /**
<i>332</i>&nbsp;   * Return this DTM&#39;s lexical handler.
<i>333</i>&nbsp;   *
<i>334</i>&nbsp;   * %REVIEW% Should this return null if constrution already done/begun?
<i>335</i>&nbsp;   *
<i>336</i>&nbsp;   * @return null if this model doesn&#39;t respond to lexical SAX events,
<i>337</i>&nbsp;   * &quot;this&quot; if the DTM object has a built-in SAX ContentHandler,
<i>338</i>&nbsp;   * the IncrementalSAXSource if we&#39;re bound to one and should receive
<i>339</i>&nbsp;   * the SAX stream via it for incremental build purposes...
<i>340</i>&nbsp;   */
<i>341</i>&nbsp;  public LexicalHandler getLexicalHandler()
<i>342</i>&nbsp;  {
<i>343</i>&nbsp;
<b class="nc"><i>344</i>&nbsp;    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)</b>
<b class="nc"><i>345</i>&nbsp;      return (LexicalHandler) m_incrSAXSource;</b>
<i>346</i>&nbsp;    else
<b class="nc"><i>347</i>&nbsp;      return this;</b>
<i>348</i>&nbsp;  }
<i>349</i>&nbsp;
<i>350</i>&nbsp;  /**
<i>351</i>&nbsp;   * Return this DTM&#39;s EntityResolver.
<i>352</i>&nbsp;   *
<i>353</i>&nbsp;   * @return null if this model doesn&#39;t respond to SAX entity ref events.
<i>354</i>&nbsp;   */
<i>355</i>&nbsp;  public org.xml.sax.EntityResolver getEntityResolver()
<i>356</i>&nbsp;  {
<i>357</i>&nbsp;
<b class="nc"><i>358</i>&nbsp;    return null;</b>
<i>359</i>&nbsp;  }
<i>360</i>&nbsp;
<i>361</i>&nbsp;  /**
<i>362</i>&nbsp;   * Return this DTM&#39;s DTDHandler.
<i>363</i>&nbsp;   *
<i>364</i>&nbsp;   * @return null if this model doesn&#39;t respond to SAX dtd events.
<i>365</i>&nbsp;   */
<i>366</i>&nbsp;  public org.xml.sax.DTDHandler getDTDHandler()
<i>367</i>&nbsp;  {
<i>368</i>&nbsp;
<b class="nc"><i>369</i>&nbsp;    return null;</b>
<i>370</i>&nbsp;  }
<i>371</i>&nbsp;
<i>372</i>&nbsp;  /**
<i>373</i>&nbsp;   * Return this DTM&#39;s ErrorHandler.
<i>374</i>&nbsp;   *
<i>375</i>&nbsp;   * @return null if this model doesn&#39;t respond to SAX error events.
<i>376</i>&nbsp;   */
<i>377</i>&nbsp;  public org.xml.sax.ErrorHandler getErrorHandler()
<i>378</i>&nbsp;  {
<i>379</i>&nbsp;
<b class="nc"><i>380</i>&nbsp;    return null;</b>
<i>381</i>&nbsp;  }
<i>382</i>&nbsp;
<i>383</i>&nbsp;  /**
<i>384</i>&nbsp;   * Return this DTM&#39;s DeclHandler.
<i>385</i>&nbsp;   *
<i>386</i>&nbsp;   * @return null if this model doesn&#39;t respond to SAX Decl events.
<i>387</i>&nbsp;   */
<i>388</i>&nbsp;  public org.xml.sax.ext.DeclHandler getDeclHandler()
<i>389</i>&nbsp;  {
<i>390</i>&nbsp;
<b class="nc"><i>391</i>&nbsp;    return null;</b>
<i>392</i>&nbsp;  }
<i>393</i>&nbsp;
<i>394</i>&nbsp;  /** @return true iff we&#39;re building this model incrementally (eg
<i>395</i>&nbsp;   * we&#39;re partnered with a IncrementalSAXSource) and thus require that the
<i>396</i>&nbsp;   * transformation and the parse run simultaneously. Guidance to the
<i>397</i>&nbsp;   * DTMManager.
<i>398</i>&nbsp;   * */
<i>399</i>&nbsp;  public boolean needsTwoThreads()
<i>400</i>&nbsp;  {
<b class="nc"><i>401</i>&nbsp;    return null!=m_incrSAXSource;</b>
<i>402</i>&nbsp;  }
<i>403</i>&nbsp;
<i>404</i>&nbsp;  //================================================================
<i>405</i>&nbsp;  // ========= SAX2 ContentHandler methods =========
<i>406</i>&nbsp;  // Accept SAX events, use them to build/extend the DTM tree.
<i>407</i>&nbsp;  // Replaces the deprecated DocumentHandler interface.
<i>408</i>&nbsp;
<i>409</i>&nbsp;  public void characters(char[] ch, int start, int length)
<i>410</i>&nbsp;       throws org.xml.sax.SAXException
<i>411</i>&nbsp;  {
<i>412</i>&nbsp;    // Actually creating the text node is handled by
<i>413</i>&nbsp;    // processAccumulatedText(); here we just accumulate the
<i>414</i>&nbsp;    // characters into the buffer.
<b class="nc"><i>415</i>&nbsp;    m_char.append(ch,start,length);</b>
<i>416</i>&nbsp;  }
<i>417</i>&nbsp;
<i>418</i>&nbsp;  // Flush string accumulation into a text node
<i>419</i>&nbsp;  private void processAccumulatedText()
<i>420</i>&nbsp;  {
<b class="nc"><i>421</i>&nbsp;    int len=m_char.length();</b>
<b class="nc"><i>422</i>&nbsp;    if(len!=m_char_current_start)</b>
<i>423</i>&nbsp;      {
<i>424</i>&nbsp;        // The FastStringBuffer has been previously agreed upon
<b class="nc"><i>425</i>&nbsp;        appendTextChild(m_char_current_start,len-m_char_current_start);</b>
<b class="nc"><i>426</i>&nbsp;        m_char_current_start=len;</b>
<i>427</i>&nbsp;      }
<i>428</i>&nbsp;  }
<i>429</i>&nbsp;  public void endDocument()
<i>430</i>&nbsp;       throws org.xml.sax.SAXException
<i>431</i>&nbsp;  {
<i>432</i>&nbsp;    // May need to tell the low-level builder code to pop up a level.
<i>433</i>&nbsp;    // There _should&#39;t_ be any significant pending text at this point.
<b class="nc"><i>434</i>&nbsp;    appendEndDocument();</b>
<i>435</i>&nbsp;  }
<i>436</i>&nbsp;  public void endElement(java.lang.String namespaceURI, java.lang.String localName,
<i>437</i>&nbsp;      java.lang.String qName)
<i>438</i>&nbsp;       throws org.xml.sax.SAXException
<i>439</i>&nbsp;  {
<b class="nc"><i>440</i>&nbsp;    processAccumulatedText();</b>
<i>441</i>&nbsp;    // No args but we do need to tell the low-level builder code to
<i>442</i>&nbsp;    // pop up a level.
<b class="nc"><i>443</i>&nbsp;    appendEndElement();</b>
<i>444</i>&nbsp;  }
<i>445</i>&nbsp;  public void endPrefixMapping(java.lang.String prefix)
<i>446</i>&nbsp;       throws org.xml.sax.SAXException
<i>447</i>&nbsp;  {
<i>448</i>&nbsp;    // No-op
<i>449</i>&nbsp;  }
<i>450</i>&nbsp;  public void ignorableWhitespace(char[] ch, int start, int length)
<i>451</i>&nbsp;       throws org.xml.sax.SAXException
<i>452</i>&nbsp;  {
<i>453</i>&nbsp;    // %TBD% I believe ignorable text isn&#39;t part of the DTM model...?
<i>454</i>&nbsp;  }
<i>455</i>&nbsp;  public void processingInstruction(java.lang.String target, java.lang.String data)
<i>456</i>&nbsp;       throws org.xml.sax.SAXException
<i>457</i>&nbsp;  {
<b class="nc"><i>458</i>&nbsp;    processAccumulatedText();</b>
<i>459</i>&nbsp;    // %TBD% Which pools do target and data go into?
<i>460</i>&nbsp;  }
<i>461</i>&nbsp;  public void setDocumentLocator(Locator locator)
<i>462</i>&nbsp;  {
<i>463</i>&nbsp;    // No-op for DTM
<i>464</i>&nbsp;  }
<i>465</i>&nbsp;  public void skippedEntity(java.lang.String name)
<i>466</i>&nbsp;       throws org.xml.sax.SAXException
<i>467</i>&nbsp;  {
<b class="nc"><i>468</i>&nbsp;    processAccumulatedText();</b>
<i>469</i>&nbsp;    //%TBD%
<i>470</i>&nbsp;  }
<i>471</i>&nbsp;  public void startDocument()
<i>472</i>&nbsp;       throws org.xml.sax.SAXException
<i>473</i>&nbsp;  {
<b class="nc"><i>474</i>&nbsp;    appendStartDocument();</b>
<i>475</i>&nbsp;  }
<i>476</i>&nbsp;  public void startElement(java.lang.String namespaceURI, java.lang.String localName,
<i>477</i>&nbsp;      java.lang.String qName, Attributes atts)
<i>478</i>&nbsp;       throws org.xml.sax.SAXException
<i>479</i>&nbsp;  {
<b class="nc"><i>480</i>&nbsp;    processAccumulatedText();</b>
<i>481</i>&nbsp;
<i>482</i>&nbsp;    // %TBD% Split prefix off qname
<b class="nc"><i>483</i>&nbsp;    String prefix=null;</b>
<b class="nc"><i>484</i>&nbsp;    int colon=qName.indexOf(&#39;:&#39;);</b>
<b class="nc"><i>485</i>&nbsp;    if(colon&gt;0)</b>
<b class="nc"><i>486</i>&nbsp;      prefix=qName.substring(0,colon);</b>
<i>487</i>&nbsp;
<i>488</i>&nbsp;    // %TBD% Where do we pool expandedName, or is it just the union, or...
<b class="nc"><i>489</i>&nbsp;    /**/System.out.println(&quot;Prefix=&quot;+prefix+&quot; index=&quot;+m_prefixNames.stringToIndex(prefix));</b>
<b class="nc"><i>490</i>&nbsp;    appendStartElement(m_nsNames.stringToIndex(namespaceURI),</b>
<b class="nc"><i>491</i>&nbsp;                     m_localNames.stringToIndex(localName),</b>
<b class="nc"><i>492</i>&nbsp;                     m_prefixNames.stringToIndex(prefix)); /////// %TBD%</b>
<i>493</i>&nbsp;
<i>494</i>&nbsp;    // %TBD% I&#39;m assuming that DTM will require resequencing of
<i>495</i>&nbsp;    // NS decls before other attrs, hence two passes are taken.
<i>496</i>&nbsp;    // %TBD% Is there an easier way to test for NSDecl?
<b class="nc"><i>497</i>&nbsp;    int nAtts=(atts==null) ? 0 : atts.getLength();</b>
<i>498</i>&nbsp;    // %TBD% Countdown is more efficient if nobody cares about sequence.
<b class="nc"><i>499</i>&nbsp;    for(int i=nAtts-1;i&gt;=0;--i)</b>
<i>500</i>&nbsp;      {
<b class="nc"><i>501</i>&nbsp;        qName=atts.getQName(i);</b>
<b class="nc"><i>502</i>&nbsp;        if(qName.startsWith(&quot;xmlns:&quot;) || &quot;xmlns&quot;.equals(qName))</b>
<i>503</i>&nbsp;          {
<b class="nc"><i>504</i>&nbsp;            prefix=null;</b>
<b class="nc"><i>505</i>&nbsp;            colon=qName.indexOf(&#39;:&#39;);</b>
<b class="nc"><i>506</i>&nbsp;            if(colon&gt;0)</b>
<i>507</i>&nbsp;              {
<b class="nc"><i>508</i>&nbsp;                prefix=qName.substring(0,colon);</b>
<i>509</i>&nbsp;              }
<i>510</i>&nbsp;            else
<i>511</i>&nbsp;              {
<i>512</i>&nbsp;                // %REVEIW% Null or &quot;&quot;?
<b class="nc"><i>513</i>&nbsp;                prefix=null; // Default prefix</b>
<i>514</i>&nbsp;              }
<i>515</i>&nbsp;
<i>516</i>&nbsp;
<b class="nc"><i>517</i>&nbsp;            appendNSDeclaration(</b>
<b class="nc"><i>518</i>&nbsp;                                    m_prefixNames.stringToIndex(prefix),</b>
<b class="nc"><i>519</i>&nbsp;                                    m_nsNames.stringToIndex(atts.getValue(i)),</b>
<b class="nc"><i>520</i>&nbsp;                                    atts.getType(i).equalsIgnoreCase(&quot;ID&quot;));</b>
<i>521</i>&nbsp;          }
<i>522</i>&nbsp;      }
<i>523</i>&nbsp;
<b class="nc"><i>524</i>&nbsp;    for(int i=nAtts-1;i&gt;=0;--i)</b>
<i>525</i>&nbsp;      {
<b class="nc"><i>526</i>&nbsp;        qName=atts.getQName(i);</b>
<b class="nc"><i>527</i>&nbsp;        if(!(qName.startsWith(&quot;xmlns:&quot;) || &quot;xmlns&quot;.equals(qName)))</b>
<i>528</i>&nbsp;          {
<i>529</i>&nbsp;            // %TBD% I hate having to extract the prefix into a new
<i>530</i>&nbsp;            // string when we may never use it. Consider pooling whole
<i>531</i>&nbsp;            // qNames, which are already strings?
<b class="nc"><i>532</i>&nbsp;            prefix=null;</b>
<b class="nc"><i>533</i>&nbsp;            colon=qName.indexOf(&#39;:&#39;);</b>
<b class="nc"><i>534</i>&nbsp;            if(colon&gt;0)</b>
<i>535</i>&nbsp;              {
<b class="nc"><i>536</i>&nbsp;                prefix=qName.substring(0,colon);</b>
<b class="nc"><i>537</i>&nbsp;                localName=qName.substring(colon+1);</b>
<i>538</i>&nbsp;              }
<i>539</i>&nbsp;            else
<i>540</i>&nbsp;              {
<b class="nc"><i>541</i>&nbsp;                prefix=&quot;&quot;; // Default prefix</b>
<b class="nc"><i>542</i>&nbsp;                localName=qName;</b>
<i>543</i>&nbsp;              }
<i>544</i>&nbsp;
<i>545</i>&nbsp;
<b class="nc"><i>546</i>&nbsp;            m_char.append(atts.getValue(i)); // Single-string value</b>
<b class="nc"><i>547</i>&nbsp;            int contentEnd=m_char.length();</b>
<i>548</i>&nbsp;
<b class="nc"><i>549</i>&nbsp;            if(!(&quot;xmlns&quot;.equals(prefix) || &quot;xmlns&quot;.equals(qName)))</b>
<b class="nc"><i>550</i>&nbsp;              appendAttribute(m_nsNames.stringToIndex(atts.getURI(i)),</b>
<b class="nc"><i>551</i>&nbsp;                                  m_localNames.stringToIndex(localName),</b>
<b class="nc"><i>552</i>&nbsp;                                  m_prefixNames.stringToIndex(prefix),</b>
<b class="nc"><i>553</i>&nbsp;                                  atts.getType(i).equalsIgnoreCase(&quot;ID&quot;),</b>
<i>554</i>&nbsp;                                  m_char_current_start, contentEnd-m_char_current_start);
<b class="nc"><i>555</i>&nbsp;            m_char_current_start=contentEnd;</b>
<i>556</i>&nbsp;          }
<i>557</i>&nbsp;      }
<i>558</i>&nbsp;  }
<i>559</i>&nbsp;  public void startPrefixMapping(java.lang.String prefix, java.lang.String uri)
<i>560</i>&nbsp;       throws org.xml.sax.SAXException
<i>561</i>&nbsp;  {
<i>562</i>&nbsp;    // No-op in DTM, handled during element/attr processing?
<i>563</i>&nbsp;  }
<i>564</i>&nbsp;
<i>565</i>&nbsp;  //
<i>566</i>&nbsp;  // LexicalHandler support. Not all SAX2 parsers support these events
<i>567</i>&nbsp;  // but we may want to pass them through when they exist...
<i>568</i>&nbsp;  //
<i>569</i>&nbsp;  public void comment(char[] ch, int start, int length)
<i>570</i>&nbsp;       throws org.xml.sax.SAXException
<i>571</i>&nbsp;  {
<b class="nc"><i>572</i>&nbsp;    processAccumulatedText();</b>
<i>573</i>&nbsp;
<b class="nc"><i>574</i>&nbsp;    m_char.append(ch,start,length); // Single-string value</b>
<b class="nc"><i>575</i>&nbsp;    appendComment(m_char_current_start,length);</b>
<b class="nc"><i>576</i>&nbsp;    m_char_current_start+=length;</b>
<i>577</i>&nbsp;  }
<i>578</i>&nbsp;  public void endCDATA()
<i>579</i>&nbsp;       throws org.xml.sax.SAXException
<i>580</i>&nbsp;  {
<i>581</i>&nbsp;    // No-op in DTM
<i>582</i>&nbsp;  }
<i>583</i>&nbsp;  public void endDTD()
<i>584</i>&nbsp;       throws org.xml.sax.SAXException
<i>585</i>&nbsp;  {
<i>586</i>&nbsp;    // No-op in DTM
<i>587</i>&nbsp;  }
<i>588</i>&nbsp;  public void endEntity(java.lang.String name)
<i>589</i>&nbsp;       throws org.xml.sax.SAXException
<i>590</i>&nbsp;  {
<i>591</i>&nbsp;    // No-op in DTM
<i>592</i>&nbsp;  }
<i>593</i>&nbsp;  public void startCDATA()
<i>594</i>&nbsp;       throws org.xml.sax.SAXException
<i>595</i>&nbsp;  {
<i>596</i>&nbsp;    // No-op in DTM
<i>597</i>&nbsp;  }
<i>598</i>&nbsp;  public void startDTD(java.lang.String name, java.lang.String publicId,
<i>599</i>&nbsp;      java.lang.String systemId)
<i>600</i>&nbsp;       throws org.xml.sax.SAXException
<i>601</i>&nbsp;  {
<i>602</i>&nbsp;    // No-op in DTM
<i>603</i>&nbsp;  }
<i>604</i>&nbsp;  public void startEntity(java.lang.String name)
<i>605</i>&nbsp;       throws org.xml.sax.SAXException
<i>606</i>&nbsp;  {
<i>607</i>&nbsp;    // No-op in DTM
<i>608</i>&nbsp;  }
<i>609</i>&nbsp;
<i>610</i>&nbsp;
<i>611</i>&nbsp;  //================================================================
<i>612</i>&nbsp;  // ========= Document Handler Functions =========
<i>613</i>&nbsp;  // %REVIEW% jjk -- DocumentHandler is  SAX Level 1, and deprecated....
<i>614</i>&nbsp;  // and this wasn&#39;t a fully compliant or declared implementation of that API
<i>615</i>&nbsp;  // in any case. Phase out in favor of SAX2 ContentHandler/LexicalHandler
<i>616</i>&nbsp;
<i>617</i>&nbsp;        /**
<i>618</i>&nbsp;         * Reset a dtm document to its initial (empty) state.
<i>619</i>&nbsp;         *
<i>620</i>&nbsp;         * The DTMManager will invoke this method when the dtm is created.
<i>621</i>&nbsp;         *
<i>622</i>&nbsp;         * @param documentNumber the handle for the DTM document.
<i>623</i>&nbsp;         */
<i>624</i>&nbsp;        final void initDocument(int documentNumber)
<i>625</i>&nbsp;        {
<i>626</i>&nbsp;                // save masked DTM document handle
<b class="nc"><i>627</i>&nbsp;                m_docHandle = documentNumber&lt;&lt;DOCHANDLE_SHIFT;</b>
<i>628</i>&nbsp;
<i>629</i>&nbsp;                // Initialize the doc -- no parent, no next-sib
<b class="nc"><i>630</i>&nbsp;                nodes.writeSlot(0,DOCUMENT_NODE,-1,-1,0);</b>
<i>631</i>&nbsp;                // wait for the first startElement to create the doc root node
<b class="nc"><i>632</i>&nbsp;                done = false;</b>
<i>633</i>&nbsp;        }
<i>634</i>&nbsp;
<i>635</i>&nbsp;//      /**
<i>636</i>&nbsp;//       * Receive hint of the end of a document.
<i>637</i>&nbsp;//       *
<i>638</i>&nbsp;//       * &lt;p&gt;The content handler will invoke this method only once, and it will
<i>639</i>&nbsp;//       * be the last method invoked during the parse.  The handler shall not
<i>640</i>&nbsp;//       * not invoke this method until it has either abandoned parsing
<i>641</i>&nbsp;//       * (because of an unrecoverable error) or reached the end of
<i>642</i>&nbsp;//       * input.&lt;/p&gt;
<i>643</i>&nbsp;//       */
<i>644</i>&nbsp;//      public void documentEnd()
<i>645</i>&nbsp;//      {
<i>646</i>&nbsp;//              done = true;
<i>647</i>&nbsp;//              // %TBD% may need to notice the last slot number and slot count to avoid
<i>648</i>&nbsp;//              // residual data from provious use of this DTM
<i>649</i>&nbsp;//      }
<i>650</i>&nbsp;
<i>651</i>&nbsp;//      /**
<i>652</i>&nbsp;//       * Receive notification of the beginning of a document.
<i>653</i>&nbsp;//       *
<i>654</i>&nbsp;//       * &lt;p&gt;The SAX parser will invoke this method only once, before any
<i>655</i>&nbsp;//       * other methods in this interface.&lt;/p&gt;
<i>656</i>&nbsp;//       */
<i>657</i>&nbsp;//      public void reset()
<i>658</i>&nbsp;//      {
<i>659</i>&nbsp;
<i>660</i>&nbsp;//              // %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for
<i>661</i>&nbsp;//              //       the next initDocument().
<i>662</i>&nbsp;//              m_docElement = NULL;     // reset nodeHandle to the root of the actual dtm doc content
<i>663</i>&nbsp;//              initDocument(0);
<i>664</i>&nbsp;//      }
<i>665</i>&nbsp;
<i>666</i>&nbsp;//      /**
<i>667</i>&nbsp;//       * Factory method; creates an Element node in this document.
<i>668</i>&nbsp;//       *
<i>669</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>670</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>671</i>&nbsp;//       *
<i>672</i>&nbsp;//       * &lt;p&gt;The XML content handler will invoke endElement() method after all
<i>673</i>&nbsp;//       * of the element&#39;s content are processed in order to give DTM the indication
<i>674</i>&nbsp;//       * to prepare and patch up parent and sibling node pointers.&lt;/p&gt;
<i>675</i>&nbsp;//       *
<i>676</i>&nbsp;//       * &lt;p&gt;The following interface for createElement will use an index value corresponds
<i>677</i>&nbsp;//       * to the symbol entry in the DTMDStringPool based symbol tables.&lt;/p&gt;
<i>678</i>&nbsp;//       *
<i>679</i>&nbsp;//       * @param nsIndex The namespace of the node
<i>680</i>&nbsp;//       * @param nameIndex The element name.
<i>681</i>&nbsp;//       * @see #endElement
<i>682</i>&nbsp;//       * @see org.xml.sax.Attributes
<i>683</i>&nbsp;//       * @return nodeHandle int of the element created
<i>684</i>&nbsp;//       */
<i>685</i>&nbsp;//      public int createElement(int nsIndex, int nameIndex, Attributes atts)
<i>686</i>&nbsp;//      {
<i>687</i>&nbsp;//              // do document root node creation here on the first element, create nodes for
<i>688</i>&nbsp;//              // this element and its attributes, store the element, namespace, and attritute
<i>689</i>&nbsp;//              // name indexes to the nodes array, keep track of the current node and parent
<i>690</i>&nbsp;//              // element used
<i>691</i>&nbsp;
<i>692</i>&nbsp;//              // W0  High:  Namespace  Low:  Node Type
<i>693</i>&nbsp;//              int w0 = (nsIndex &lt;&lt; 16) | ELEMENT_NODE;
<i>694</i>&nbsp;//              // W1: Parent
<i>695</i>&nbsp;//              int w1 = currentParent;
<i>696</i>&nbsp;//              // W2: Next  (initialized as 0)
<i>697</i>&nbsp;//              int w2 = 0;
<i>698</i>&nbsp;//              // W3: Tagname
<i>699</i>&nbsp;//              int w3 = nameIndex;
<i>700</i>&nbsp;//              //int ourslot = nodes.appendSlot(w0, w1, w2, w3);
<i>701</i>&nbsp;//              int ourslot = appendNode(w0, w1, w2, w3);
<i>702</i>&nbsp;//              currentParent = ourslot;
<i>703</i>&nbsp;//              previousSibling = 0;
<i>704</i>&nbsp;//              setAttributes(atts);
<i>705</i>&nbsp;
<i>706</i>&nbsp;//              // set the root element pointer when creating the first element node
<i>707</i>&nbsp;//              if (m_docElement == NULL)
<i>708</i>&nbsp;//                      m_docElement = ourslot;
<i>709</i>&nbsp;//              return (m_docHandle | ourslot);
<i>710</i>&nbsp;//      }
<i>711</i>&nbsp;
<i>712</i>&nbsp;//      // Factory method to create an Element node not associated with a given name space
<i>713</i>&nbsp;//      // using String value parameters passed in from a content handler or application
<i>714</i>&nbsp;//      /**
<i>715</i>&nbsp;//       * Factory method; creates an Element node not associated with a given name space in this document.
<i>716</i>&nbsp;//       *
<i>717</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>718</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>719</i>&nbsp;//       *
<i>720</i>&nbsp;//       * &lt;p&gt;The XML content handler or application will invoke endElement() method after all
<i>721</i>&nbsp;//       * of the element&#39;s content are processed in order to give DTM the indication
<i>722</i>&nbsp;//       * to prepare and patch up parent and sibling node pointers.&lt;/p&gt;
<i>723</i>&nbsp;//       *
<i>724</i>&nbsp;//       * &lt;p&gt;The following parameters for createElement contains raw string values for name
<i>725</i>&nbsp;//       * symbols used in an Element node.&lt;/p&gt;
<i>726</i>&nbsp;//       *
<i>727</i>&nbsp;//       * @param name String the element name, including the prefix if any.
<i>728</i>&nbsp;//       * @param atts The attributes attached to the element, if any.
<i>729</i>&nbsp;//       * @see #endElement
<i>730</i>&nbsp;//       * @see org.xml.sax.Attributes
<i>731</i>&nbsp;//       */
<i>732</i>&nbsp;//      public int createElement(String name, Attributes atts)
<i>733</i>&nbsp;//      {
<i>734</i>&nbsp;//              // This method wraps around the index valued interface of the createElement interface.
<i>735</i>&nbsp;//              // The raw string values are stored into the current DTM name symbol tables.  The method
<i>736</i>&nbsp;//              // method will then use the index values returned to invoke the other createElement()
<i>737</i>&nbsp;//              // onverted to index values modified to match a
<i>738</i>&nbsp;//              // method.
<i>739</i>&nbsp;//              int nsIndex = NULL;
<i>740</i>&nbsp;//              int nameIndex = m_localNames.stringToIndex(name);
<i>741</i>&nbsp;//              // note - there should be no prefix separator in the name because it is not associated
<i>742</i>&nbsp;//              // with a name space
<i>743</i>&nbsp;
<i>744</i>&nbsp;//              return createElement(nsIndex, nameIndex, atts);
<i>745</i>&nbsp;//      }
<i>746</i>&nbsp;
<i>747</i>&nbsp;//      // Factory method to create an Element node associated with a given name space
<i>748</i>&nbsp;//      // using String value parameters passed in from a content handler or application
<i>749</i>&nbsp;//      /**
<i>750</i>&nbsp;//       * Factory method; creates an Element node associated with a given name space in this document.
<i>751</i>&nbsp;//       *
<i>752</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>753</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>754</i>&nbsp;//       *
<i>755</i>&nbsp;//       * &lt;p&gt;The XML content handler or application will invoke endElement() method after all
<i>756</i>&nbsp;//       * of the element&#39;s content are processed in order to give DTM the indication
<i>757</i>&nbsp;//       * to prepare and patch up parent and sibling node pointers.&lt;/p&gt;
<i>758</i>&nbsp;//       *
<i>759</i>&nbsp;//       * &lt;p&gt;The following parameters for createElementNS contains raw string values for name
<i>760</i>&nbsp;//       * symbols used in an Element node.&lt;/p&gt;
<i>761</i>&nbsp;//       *
<i>762</i>&nbsp;//       * @param ns String the namespace of the node
<i>763</i>&nbsp;//       * @param name String the element name, including the prefix if any.
<i>764</i>&nbsp;//       * @param atts The attributes attached to the element, if any.
<i>765</i>&nbsp;//       * @see #endElement
<i>766</i>&nbsp;//       * @see org.xml.sax.Attributes
<i>767</i>&nbsp;//       */
<i>768</i>&nbsp;//      public int createElementNS(String ns, String name, Attributes atts)
<i>769</i>&nbsp;//      {
<i>770</i>&nbsp;//              // This method wraps around the index valued interface of the createElement interface.
<i>771</i>&nbsp;//              // The raw string values are stored into the current DTM name symbol tables.  The method
<i>772</i>&nbsp;//              // method will then use the index values returned to invoke the other createElement()
<i>773</i>&nbsp;//              // onverted to index values modified to match a
<i>774</i>&nbsp;//              // method.
<i>775</i>&nbsp;//              int nsIndex = m_nsNames.stringToIndex(ns);
<i>776</i>&nbsp;//              int nameIndex = m_localNames.stringToIndex(name);
<i>777</i>&nbsp;//              // The prefixIndex is not needed by the indexed interface of the createElement method
<i>778</i>&nbsp;//              int prefixSep = name.indexOf(&quot;:&quot;);
<i>779</i>&nbsp;//              int prefixIndex = m_prefixNames.stringToIndex(name.substring(0, prefixSep));
<i>780</i>&nbsp;//              return createElement(nsIndex, nameIndex, atts);
<i>781</i>&nbsp;//      }
<i>782</i>&nbsp;
<i>783</i>&nbsp;//      /**
<i>784</i>&nbsp;//       * Receive an indication for the end of an element.
<i>785</i>&nbsp;//       *
<i>786</i>&nbsp;//       * &lt;p&gt;The XML content handler will invoke this method at the end of every
<i>787</i>&nbsp;//       * element in the XML document to give hint its time to pop up the current
<i>788</i>&nbsp;//       * element and parent and patch up parent and sibling pointers if necessary
<i>789</i>&nbsp;//       *
<i>790</i>&nbsp;//       * &lt;p&gt;%tbd% The following interface may need to be modified to match a
<i>791</i>&nbsp;//       * coordinated access to the DTMDStringPool based symbol tables.&lt;/p&gt;
<i>792</i>&nbsp;//               *
<i>793</i>&nbsp;//       * @param ns the namespace of the element
<i>794</i>&nbsp;//       * @param name The element name
<i>795</i>&nbsp;//       */
<i>796</i>&nbsp;//      public void endElement(String ns, String name)
<i>797</i>&nbsp;//      {
<i>798</i>&nbsp;//              // pop up the stacks
<i>799</i>&nbsp;
<i>800</i>&nbsp;//              //
<i>801</i>&nbsp;//              if (previousSiblingWasParent)
<i>802</i>&nbsp;//                      nodes.writeEntry(previousSibling, 2, NULL);
<i>803</i>&nbsp;
<i>804</i>&nbsp;//              // Pop parentage
<i>805</i>&nbsp;//              previousSibling = currentParent;
<i>806</i>&nbsp;//              nodes.readSlot(currentParent, gotslot);
<i>807</i>&nbsp;//              currentParent = gotslot[1] &amp; 0xFFFF;
<i>808</i>&nbsp;
<i>809</i>&nbsp;//              // The element just being finished will be
<i>810</i>&nbsp;//              // the previous sibling for the next operation
<i>811</i>&nbsp;//              previousSiblingWasParent = true;
<i>812</i>&nbsp;
<i>813</i>&nbsp;//              // Pop a level of namespace table
<i>814</i>&nbsp;//              // namespaceTable.removeLastElem();
<i>815</i>&nbsp;//      }
<i>816</i>&nbsp;
<i>817</i>&nbsp;//      /**
<i>818</i>&nbsp;//       * Creates attributes for the current node.
<i>819</i>&nbsp;//       *
<i>820</i>&nbsp;//       * @param atts Attributes to be created.
<i>821</i>&nbsp;//       */
<i>822</i>&nbsp;//      void setAttributes(Attributes atts) {
<i>823</i>&nbsp;//              int atLength = (null == atts) ? 0 : atts.getLength();
<i>824</i>&nbsp;//              for (int i=0; i &lt; atLength; i++) {
<i>825</i>&nbsp;//                      String qname = atts.getQName(i);
<i>826</i>&nbsp;//                      createAttribute(atts.getQName(i), atts.getValue(i));
<i>827</i>&nbsp;//              }
<i>828</i>&nbsp;//      }
<i>829</i>&nbsp;
<i>830</i>&nbsp;//      /**
<i>831</i>&nbsp;//       * Appends an attribute to the document.
<i>832</i>&nbsp;//       * @param qname Qualified Name of the attribute
<i>833</i>&nbsp;//       * @param value Value of the attribute
<i>834</i>&nbsp;//       * @return Handle of node
<i>835</i>&nbsp;//       */
<i>836</i>&nbsp;//      public int createAttribute(String qname, String value) {
<i>837</i>&nbsp;//              int colonpos = qname.indexOf(&quot;:&quot;);
<i>838</i>&nbsp;//              String attName = qname.substring(colonpos+1);
<i>839</i>&nbsp;//              int w0 = 0;
<i>840</i>&nbsp;//              if (colonpos &gt; 0) {
<i>841</i>&nbsp;//                      String prefix = qname.substring(0, colonpos);
<i>842</i>&nbsp;//                      if (prefix.equals(&quot;xml&quot;)) {
<i>843</i>&nbsp;//                              //w0 = ATTRIBUTE_NODE |
<i>844</i>&nbsp;//                              //      (com.sun.org.apache.xalan.internal.templates.Constants.S_XMLNAMESPACEURI &lt;&lt; 16);
<i>845</i>&nbsp;//                      } else {
<i>846</i>&nbsp;//                              //w0 = ATTRIBUTE_NODE |
<i>847</i>&nbsp;//                      }
<i>848</i>&nbsp;//              } else {
<i>849</i>&nbsp;//                      w0 = ATTRIBUTE_NODE;
<i>850</i>&nbsp;//              }
<i>851</i>&nbsp;//              // W1:  Parent
<i>852</i>&nbsp;//              int w1 = currentParent;
<i>853</i>&nbsp;//              // W2:  Next (not yet resolved)
<i>854</i>&nbsp;//              int w2 = 0;
<i>855</i>&nbsp;//              // W3:  Tag name
<i>856</i>&nbsp;//              int w3 = m_localNames.stringToIndex(attName);
<i>857</i>&nbsp;//              // Add node
<i>858</i>&nbsp;//              int ourslot = appendNode(w0, w1, w2, w3);
<i>859</i>&nbsp;//              previousSibling = ourslot;      // Should attributes be previous siblings
<i>860</i>&nbsp;
<i>861</i>&nbsp;//              // W0: Node Type
<i>862</i>&nbsp;//              w0 = TEXT_NODE;
<i>863</i>&nbsp;//              // W1: Parent
<i>864</i>&nbsp;//              w1 = ourslot;
<i>865</i>&nbsp;//              // W2: Start Position within buffer
<i>866</i>&nbsp;//              w2 = m_char.length();
<i>867</i>&nbsp;//              m_char.append(value);
<i>868</i>&nbsp;//              // W3: Length
<i>869</i>&nbsp;//              w3 = m_char.length() - w2;
<i>870</i>&nbsp;//              appendNode(w0, w1, w2, w3);
<i>871</i>&nbsp;//              charStringStart=m_char.length();
<i>872</i>&nbsp;//              charStringLength = 0;
<i>873</i>&nbsp;//              //previousSibling = ourslot;
<i>874</i>&nbsp;//              // Attrs are Parents
<i>875</i>&nbsp;//              previousSiblingWasParent = true;
<i>876</i>&nbsp;//              return (m_docHandle | ourslot);
<i>877</i>&nbsp;//      }
<i>878</i>&nbsp;
<i>879</i>&nbsp;//      /**
<i>880</i>&nbsp;//       * Factory method; creates a Text node in this document.
<i>881</i>&nbsp;//       *
<i>882</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>883</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>884</i>&nbsp;//       *
<i>885</i>&nbsp;//       * @param text String The characters text string from the XML document.
<i>886</i>&nbsp;//       * @return int DTM node-number of the text node created
<i>887</i>&nbsp;//       */
<i>888</i>&nbsp;//      public int createTextNode(String text)
<i>889</i>&nbsp;//      throws DTMException
<i>890</i>&nbsp;//      {
<i>891</i>&nbsp;//              // wraps around the index value based createTextNode method
<i>892</i>&nbsp;//              return createTextNode(text.toCharArray(), 0, text.length());
<i>893</i>&nbsp;//      }
<i>894</i>&nbsp;
<i>895</i>&nbsp;//      /**
<i>896</i>&nbsp;//       * Factory method; creates a Text node in this document.
<i>897</i>&nbsp;//       *
<i>898</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>899</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>900</i>&nbsp;//       *
<i>901</i>&nbsp;//       * %REVIEW% for text normalization issues, unless we are willing to
<i>902</i>&nbsp;//       * insist that all adjacent text must be merged before this method
<i>903</i>&nbsp;//       * is called.
<i>904</i>&nbsp;//       *
<i>905</i>&nbsp;//       * @param ch The characters from the XML document.
<i>906</i>&nbsp;//       * @param start The start position in the array.
<i>907</i>&nbsp;//       * @param length The number of characters to read from the array.
<i>908</i>&nbsp;//       */
<i>909</i>&nbsp;//      public int createTextNode(char ch[], int start, int length)
<i>910</i>&nbsp;//      throws DTMException
<i>911</i>&nbsp;//      {
<i>912</i>&nbsp;//              m_char.append(ch, start, length);               // store the chunk to the text/comment string table
<i>913</i>&nbsp;
<i>914</i>&nbsp;//              // create a Text Node
<i>915</i>&nbsp;//              // %TBD% may be possible to combine with appendNode()to replace the next chunk of code
<i>916</i>&nbsp;//              int w0 = TEXT_NODE;
<i>917</i>&nbsp;//              // W1: Parent
<i>918</i>&nbsp;//              int w1 = currentParent;
<i>919</i>&nbsp;//              // W2: Start position within m_char
<i>920</i>&nbsp;//              int w2 = charStringStart;
<i>921</i>&nbsp;//              // W3: Length of the full string
<i>922</i>&nbsp;//              int w3 = length;
<i>923</i>&nbsp;//              int ourslot = appendNode(w0, w1, w2, w3);
<i>924</i>&nbsp;//              previousSibling = ourslot;
<i>925</i>&nbsp;
<i>926</i>&nbsp;//              charStringStart=m_char.length();
<i>927</i>&nbsp;//              charStringLength = 0;
<i>928</i>&nbsp;//              return (m_docHandle | ourslot);
<i>929</i>&nbsp;//      }
<i>930</i>&nbsp;
<i>931</i>&nbsp;//      /**
<i>932</i>&nbsp;//       * Factory method; creates a Comment node in this document.
<i>933</i>&nbsp;//       *
<i>934</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>935</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>936</i>&nbsp;//       *
<i>937</i>&nbsp;//       * @param text String The characters text string from the XML document.
<i>938</i>&nbsp;//       * @return int DTM node-number of the text node created
<i>939</i>&nbsp;//       */
<i>940</i>&nbsp;//      public int createComment(String text)
<i>941</i>&nbsp;//      throws DTMException
<i>942</i>&nbsp;//      {
<i>943</i>&nbsp;//              // wraps around the index value based createTextNode method
<i>944</i>&nbsp;//              return createComment(text.toCharArray(), 0, text.length());
<i>945</i>&nbsp;//      }
<i>946</i>&nbsp;
<i>947</i>&nbsp;//      /**
<i>948</i>&nbsp;//       * Factory method; creates a Comment node in this document.
<i>949</i>&nbsp;//       *
<i>950</i>&nbsp;//       * The node created will be chained according to its natural order of request
<i>951</i>&nbsp;//       * received.  %TBD% It can be rechained later via the optional DTM writable interface.
<i>952</i>&nbsp;//       *
<i>953</i>&nbsp;//       * @param ch An array holding the characters in the comment.
<i>954</i>&nbsp;//       * @param start The starting position in the array.
<i>955</i>&nbsp;//       * @param length The number of characters to use from the array.
<i>956</i>&nbsp;//       * @see DTMException
<i>957</i>&nbsp;//       */
<i>958</i>&nbsp;//      public int createComment(char ch[], int start, int length)
<i>959</i>&nbsp;//      throws DTMException
<i>960</i>&nbsp;//      {
<i>961</i>&nbsp;//              m_char.append(ch, start, length);               // store the comment string to the text/comment string table
<i>962</i>&nbsp;
<i>963</i>&nbsp;//              // create a Comment Node
<i>964</i>&nbsp;//              // %TBD% may be possible to combine with appendNode()to replace the next chunk of code
<i>965</i>&nbsp;//              int w0 = COMMENT_NODE;
<i>966</i>&nbsp;//              // W1: Parent
<i>967</i>&nbsp;//              int w1 = currentParent;
<i>968</i>&nbsp;//              // W2: Start position within m_char
<i>969</i>&nbsp;//              int w2 = charStringStart;
<i>970</i>&nbsp;//              // W3: Length of the full string
<i>971</i>&nbsp;//              int w3 = length;
<i>972</i>&nbsp;//              int ourslot = appendNode(w0, w1, w2, w3);
<i>973</i>&nbsp;//              previousSibling = ourslot;
<i>974</i>&nbsp;
<i>975</i>&nbsp;//              charStringStart=m_char.length();
<i>976</i>&nbsp;//              charStringLength = 0;
<i>977</i>&nbsp;//              return (m_docHandle | ourslot);
<i>978</i>&nbsp;//      }
<i>979</i>&nbsp;
<i>980</i>&nbsp;//      // Counters to keep track of the current text string being accumulated with respect
<i>981</i>&nbsp;//      // to the text/comment string table: charStringStart should point to the starting
<i>982</i>&nbsp;//      // offset of the string in the table and charStringLength the acccumulated length when
<i>983</i>&nbsp;//      // appendAccumulatedText starts, and reset to the end of the table and 0 at the end
<i>984</i>&nbsp;//      // of appendAccumulatedText for the next set of characters receives
<i>985</i>&nbsp;//      int charStringStart=0,charStringLength=0;
<i>986</i>&nbsp;
<i>987</i>&nbsp;        // ========= Document Navigation Functions =========
<i>988</i>&nbsp;
<i>989</i>&nbsp;        /** Given a node handle, test if it has child nodes.
<i>990</i>&nbsp;         * &lt;p&gt; %REVIEW% This is obviously useful at the DOM layer, where it
<i>991</i>&nbsp;         * would permit testing this without having to create a proxy
<i>992</i>&nbsp;         * node. It&#39;s less useful in the DTM API, where
<i>993</i>&nbsp;         * (dtm.getFirstChild(nodeHandle)!=DTM.NULL) is just as fast and
<i>994</i>&nbsp;         * almost as self-evident. But it&#39;s a convenience, and eases porting
<i>995</i>&nbsp;         * of DOM code to DTM.  &lt;/p&gt;
<i>996</i>&nbsp;         *
<i>997</i>&nbsp;         * @param nodeHandle int Handle of the node.
<i>998</i>&nbsp;         * @return int true if the given node has child nodes.
<i>999</i>&nbsp;         */
<i>1000</i>&nbsp;        public boolean hasChildNodes(int nodeHandle) {
<b class="nc"><i>1001</i>&nbsp;                return(getFirstChild(nodeHandle) != NULL);</b>
<i>1002</i>&nbsp;        }
<i>1003</i>&nbsp;
<i>1004</i>&nbsp;        /**
<i>1005</i>&nbsp;         * Given a node handle, get the handle of the node&#39;s first child.
<i>1006</i>&nbsp;         * If not yet resolved, waits for more nodes to be added to the document and
<i>1007</i>&nbsp;         * tries again.
<i>1008</i>&nbsp;         *
<i>1009</i>&nbsp;         * @param nodeHandle int Handle of the node.
<i>1010</i>&nbsp;         * @return int DTM node-number of first child, or DTM.NULL to indicate none exists.
<i>1011</i>&nbsp;         */
<i>1012</i>&nbsp;        public int getFirstChild(int nodeHandle) {
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;                // ###shs worry about tracing/debug later
<b class="nc"><i>1015</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1016</i>&nbsp;                // Read node into variable
<b class="nc"><i>1017</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<i>1018</i>&nbsp;
<i>1019</i>&nbsp;                // type is the last half of first slot
<b class="nc"><i>1020</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<i>1021</i>&nbsp;
<i>1022</i>&nbsp;                // Check to see if Element or Document node
<b class="nc"><i>1023</i>&nbsp;                if ((type == ELEMENT_NODE) || (type == DOCUMENT_NODE) ||</b>
<i>1024</i>&nbsp;                                (type == ENTITY_REFERENCE_NODE)) {
<i>1025</i>&nbsp;
<i>1026</i>&nbsp;                        // In case when Document root is given
<i>1027</i>&nbsp;                        //      if (nodeHandle == 0) nodeHandle = 1;
<i>1028</i>&nbsp;                        // %TBD% Probably was a mistake.
<i>1029</i>&nbsp;                        // If someone explicitly asks for first child
<i>1030</i>&nbsp;                        // of Document, I would expect them to want
<i>1031</i>&nbsp;                        // that and only that.
<i>1032</i>&nbsp;
<b class="nc"><i>1033</i>&nbsp;                        int kid = nodeHandle + 1;</b>
<b class="nc"><i>1034</i>&nbsp;                        nodes.readSlot(kid, gotslot);</b>
<b class="nc"><i>1035</i>&nbsp;                        while (ATTRIBUTE_NODE == (gotslot[0] &amp; 0xFFFF)) {</b>
<i>1036</i>&nbsp;                                // points to next sibling
<b class="nc"><i>1037</i>&nbsp;                                kid = gotslot[2];</b>
<i>1038</i>&nbsp;                                // Return NULL if node has only attributes
<b class="nc"><i>1039</i>&nbsp;                                if (kid == NULL) return NULL;</b>
<b class="nc"><i>1040</i>&nbsp;                                nodes.readSlot(kid, gotslot);</b>
<i>1041</i>&nbsp;                        }
<i>1042</i>&nbsp;                        // If parent slot matches given parent, return kid
<b class="nc"><i>1043</i>&nbsp;                        if (gotslot[1] == nodeHandle)</b>
<i>1044</i>&nbsp;                        {
<b class="nc"><i>1045</i>&nbsp;                          int firstChild = kid | m_docHandle;</b>
<i>1046</i>&nbsp;
<b class="nc"><i>1047</i>&nbsp;                          return firstChild;</b>
<i>1048</i>&nbsp;                        }
<i>1049</i>&nbsp;                }
<i>1050</i>&nbsp;                // No child found
<i>1051</i>&nbsp;
<b class="nc"><i>1052</i>&nbsp;                return NULL;</b>
<i>1053</i>&nbsp;        }
<i>1054</i>&nbsp;
<i>1055</i>&nbsp;        /**
<i>1056</i>&nbsp;        * Given a node handle, advance to its last child.
<i>1057</i>&nbsp;        * If not yet resolved, waits for more nodes to be added to the document and
<i>1058</i>&nbsp;        * tries again.
<i>1059</i>&nbsp;        *
<i>1060</i>&nbsp;        * @param nodeHandle int Handle of the node.
<i>1061</i>&nbsp;        * @return int Node-number of last child,
<i>1062</i>&nbsp;        * or DTM.NULL to indicate none exists.
<i>1063</i>&nbsp;        */
<i>1064</i>&nbsp;        public int getLastChild(int nodeHandle) {
<i>1065</i>&nbsp;                // ###shs put trace/debug later
<b class="nc"><i>1066</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1067</i>&nbsp;                // do not need to test node type since getFirstChild does that
<b class="nc"><i>1068</i>&nbsp;                int lastChild = NULL;</b>
<b class="nc"><i>1069</i>&nbsp;                for (int nextkid = getFirstChild(nodeHandle); nextkid != NULL;</b>
<b class="nc"><i>1070</i>&nbsp;                                nextkid = getNextSibling(nextkid)) {</b>
<b class="nc"><i>1071</i>&nbsp;                        lastChild = nextkid;</b>
<i>1072</i>&nbsp;                }
<b class="nc"><i>1073</i>&nbsp;                return lastChild | m_docHandle;</b>
<i>1074</i>&nbsp;        }
<i>1075</i>&nbsp;
<i>1076</i>&nbsp;        /**
<i>1077</i>&nbsp;         * Retrieves an attribute node by by qualified name and namespace URI.
<i>1078</i>&nbsp;         *
<i>1079</i>&nbsp;         * @param nodeHandle int Handle of the node upon which to look up this attribute.
<i>1080</i>&nbsp;         * @param namespaceURI The namespace URI of the attribute to
<i>1081</i>&nbsp;         *   retrieve, or null.
<i>1082</i>&nbsp;         * @param name The local name of the attribute to
<i>1083</i>&nbsp;         *   retrieve.
<i>1084</i>&nbsp;         * @return The attribute node handle with the specified name (
<i>1085</i>&nbsp;         *   &lt;code&gt;nodeName&lt;/code&gt;) or &lt;code&gt;DTM.NULL&lt;/code&gt; if there is no such
<i>1086</i>&nbsp;         *   attribute.
<i>1087</i>&nbsp;         */
<i>1088</i>&nbsp;        public int getAttributeNode(int nodeHandle, String namespaceURI, String name) {
<b class="nc"><i>1089</i>&nbsp;                int nsIndex = m_nsNames.stringToIndex(namespaceURI),</b>
<b class="nc"><i>1090</i>&nbsp;                                                                        nameIndex = m_localNames.stringToIndex(name);</b>
<b class="nc"><i>1091</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<b class="nc"><i>1092</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1093</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<i>1094</i>&nbsp;                // If nodeHandle points to element next slot would be first attribute
<b class="nc"><i>1095</i>&nbsp;                if (type == ELEMENT_NODE)</b>
<b class="nc"><i>1096</i>&nbsp;                        nodeHandle++;</b>
<i>1097</i>&nbsp;                // Iterate through Attribute Nodes
<b class="nc"><i>1098</i>&nbsp;                while (type == ATTRIBUTE_NODE) {</b>
<b class="nc"><i>1099</i>&nbsp;                        if ((nsIndex == (gotslot[0] &lt;&lt; 16)) &amp;&amp; (gotslot[3] == nameIndex))</b>
<b class="nc"><i>1100</i>&nbsp;                                return nodeHandle | m_docHandle;</b>
<i>1101</i>&nbsp;                        // Goto next sibling
<b class="nc"><i>1102</i>&nbsp;                        nodeHandle = gotslot[2];</b>
<b class="nc"><i>1103</i>&nbsp;                        nodes.readSlot(nodeHandle, gotslot);</b>
<i>1104</i>&nbsp;                }
<b class="nc"><i>1105</i>&nbsp;                return NULL;</b>
<i>1106</i>&nbsp;        }
<i>1107</i>&nbsp;
<i>1108</i>&nbsp;        /**
<i>1109</i>&nbsp;         * Given a node handle, get the index of the node&#39;s first attribute.
<i>1110</i>&nbsp;         *
<i>1111</i>&nbsp;         * @param nodeHandle int Handle of the Element node.
<i>1112</i>&nbsp;         * @return Handle of first attribute, or DTM.NULL to indicate none exists.
<i>1113</i>&nbsp;         */
<i>1114</i>&nbsp;        public int getFirstAttribute(int nodeHandle) {
<b class="nc"><i>1115</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;                // %REVIEW% jjk: Just a quick observation: If you&#39;re going to
<i>1118</i>&nbsp;                // call readEntry repeatedly on the same node, it may be
<i>1119</i>&nbsp;                // more efficiently to do a readSlot to get the data locally,
<i>1120</i>&nbsp;                // reducing the addressing and call-and-return overhead.
<i>1121</i>&nbsp;
<i>1122</i>&nbsp;                // Should we check if handle is element (do we want sanity checks?)
<b class="nc"><i>1123</i>&nbsp;                if (ELEMENT_NODE != (nodes.readEntry(nodeHandle, 0) &amp; 0xFFFF))</b>
<b class="nc"><i>1124</i>&nbsp;                        return NULL;</b>
<i>1125</i>&nbsp;                // First Attribute (if any) should be at next position in table
<b class="nc"><i>1126</i>&nbsp;                nodeHandle++;</b>
<b class="nc"><i>1127</i>&nbsp;                return(ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) &amp; 0xFFFF)) ?</b>
<i>1128</i>&nbsp;                nodeHandle | m_docHandle : NULL;
<i>1129</i>&nbsp;        }
<i>1130</i>&nbsp;
<i>1131</i>&nbsp;        /**
<i>1132</i>&nbsp;         * Given a node handle, get the index of the node&#39;s first child.
<i>1133</i>&nbsp;         * If not yet resolved, waits for more nodes to be added to the document and
<i>1134</i>&nbsp;         * tries again
<i>1135</i>&nbsp;         *
<i>1136</i>&nbsp;         * @param nodeHandle handle to node, which should probably be an element
<i>1137</i>&nbsp;         *                   node, but need not be.
<i>1138</i>&nbsp;         *
<i>1139</i>&nbsp;         * @param inScope    true if all namespaces in scope should be returned,
<i>1140</i>&nbsp;         *                   false if only the namespace declarations should be
<i>1141</i>&nbsp;         *                   returned.
<i>1142</i>&nbsp;         * @return handle of first namespace, or DTM.NULL to indicate none exists.
<i>1143</i>&nbsp;         */
<i>1144</i>&nbsp;        public int getFirstNamespaceNode(int nodeHandle, boolean inScope) {
<i>1145</i>&nbsp;
<b class="nc"><i>1146</i>&nbsp;                return NULL;</b>
<i>1147</i>&nbsp;        }
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;        /**
<i>1150</i>&nbsp;         * Given a node handle, advance to its next sibling.
<i>1151</i>&nbsp;         *
<i>1152</i>&nbsp;         * %TBD% This currently uses the DTM-internal definition of
<i>1153</i>&nbsp;         * sibling; eg, the last attr&#39;s next sib is the first
<i>1154</i>&nbsp;         * child. In the old DTM, the DOM proxy layer provided the
<i>1155</i>&nbsp;         * additional logic for the public view.  If we&#39;re rewriting
<i>1156</i>&nbsp;         * for XPath emulation, that test must be done here.
<i>1157</i>&nbsp;         *
<i>1158</i>&nbsp;         * %TBD% CODE INTERACTION WITH INCREMENTAL PARSE - If not yet
<i>1159</i>&nbsp;         * resolved, should wait for more nodes to be added to the document
<i>1160</i>&nbsp;         * and tries again.
<i>1161</i>&nbsp;         *
<i>1162</i>&nbsp;         * @param nodeHandle int Handle of the node.
<i>1163</i>&nbsp;         * @return int Node-number of next sibling,
<i>1164</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1165</i>&nbsp;         * */
<i>1166</i>&nbsp;        public int getNextSibling(int nodeHandle) {
<b class="nc"><i>1167</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1168</i>&nbsp;                // Document root has no next sibling
<b class="nc"><i>1169</i>&nbsp;                if (nodeHandle == 0)</b>
<b class="nc"><i>1170</i>&nbsp;                        return NULL;</b>
<i>1171</i>&nbsp;
<b class="nc"><i>1172</i>&nbsp;                short type = (short) (nodes.readEntry(nodeHandle, 0) &amp; 0xFFFF);</b>
<b class="nc"><i>1173</i>&nbsp;                if ((type == ELEMENT_NODE) || (type == ATTRIBUTE_NODE) ||</b>
<i>1174</i>&nbsp;                                (type == ENTITY_REFERENCE_NODE)) {
<b class="nc"><i>1175</i>&nbsp;                        int nextSib = nodes.readEntry(nodeHandle, 2);</b>
<b class="nc"><i>1176</i>&nbsp;                        if (nextSib == NULL)</b>
<b class="nc"><i>1177</i>&nbsp;                                return NULL;</b>
<b class="nc"><i>1178</i>&nbsp;                        if (nextSib != 0)</b>
<b class="nc"><i>1179</i>&nbsp;                                return (m_docHandle | nextSib);</b>
<i>1180</i>&nbsp;                        // ###shs should cycle/wait if nextSib is 0? Working on threading next
<i>1181</i>&nbsp;                }
<i>1182</i>&nbsp;                // Next Sibling is in the next position if it shares the same parent
<b class="nc"><i>1183</i>&nbsp;                int thisParent = nodes.readEntry(nodeHandle, 1);</b>
<i>1184</i>&nbsp;
<b class="nc"><i>1185</i>&nbsp;                if (nodes.readEntry(++nodeHandle, 1) == thisParent)</b>
<b class="nc"><i>1186</i>&nbsp;                        return (m_docHandle | nodeHandle);</b>
<i>1187</i>&nbsp;
<b class="nc"><i>1188</i>&nbsp;                return NULL;</b>
<i>1189</i>&nbsp;        }
<i>1190</i>&nbsp;
<i>1191</i>&nbsp;        /**
<i>1192</i>&nbsp;         * Given a node handle, find its preceeding sibling.
<i>1193</i>&nbsp;         * WARNING: DTM is asymmetric; this operation is resolved by search, and is
<i>1194</i>&nbsp;         * relatively expensive.
<i>1195</i>&nbsp;         *
<i>1196</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1197</i>&nbsp;         * @return int Node-number of the previous sib,
<i>1198</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1199</i>&nbsp;         */
<i>1200</i>&nbsp;        public int getPreviousSibling(int nodeHandle) {
<b class="nc"><i>1201</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1202</i>&nbsp;                // Document root has no previous sibling
<b class="nc"><i>1203</i>&nbsp;                if (nodeHandle == 0)</b>
<b class="nc"><i>1204</i>&nbsp;                        return NULL;</b>
<i>1205</i>&nbsp;
<b class="nc"><i>1206</i>&nbsp;                int parent = nodes.readEntry(nodeHandle, 1);</b>
<b class="nc"><i>1207</i>&nbsp;                int kid = NULL;</b>
<b class="nc"><i>1208</i>&nbsp;                for (int nextkid = getFirstChild(parent); nextkid != nodeHandle;</b>
<b class="nc"><i>1209</i>&nbsp;                                nextkid = getNextSibling(nextkid)) {</b>
<b class="nc"><i>1210</i>&nbsp;                        kid = nextkid;</b>
<i>1211</i>&nbsp;                }
<b class="nc"><i>1212</i>&nbsp;                return kid | m_docHandle;</b>
<i>1213</i>&nbsp;        }
<i>1214</i>&nbsp;
<i>1215</i>&nbsp;        /**
<i>1216</i>&nbsp;         * Given a node handle, advance to the next attribute. If an
<i>1217</i>&nbsp;         * element, we advance to its first attribute; if an attr, we advance to
<i>1218</i>&nbsp;         * the next attr on the same node.
<i>1219</i>&nbsp;         *
<i>1220</i>&nbsp;         * @param nodeHandle int Handle of the node.
<i>1221</i>&nbsp;         * @return int DTM node-number of the resolved attr,
<i>1222</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1223</i>&nbsp;         */
<i>1224</i>&nbsp;        public int getNextAttribute(int nodeHandle) {
<b class="nc"><i>1225</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<b class="nc"><i>1226</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<i>1227</i>&nbsp;
<i>1228</i>&nbsp;                //%REVIEW% Why are we using short here? There&#39;s no storage
<i>1229</i>&nbsp;                //reduction for an automatic variable, especially one used
<i>1230</i>&nbsp;                //so briefly, and it typically costs more cycles to process
<i>1231</i>&nbsp;                //than an int would.
<b class="nc"><i>1232</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<i>1233</i>&nbsp;
<b class="nc"><i>1234</i>&nbsp;                if (type == ELEMENT_NODE) {</b>
<b class="nc"><i>1235</i>&nbsp;                        return getFirstAttribute(nodeHandle);</b>
<b class="nc"><i>1236</i>&nbsp;                } else if (type == ATTRIBUTE_NODE) {</b>
<b class="nc"><i>1237</i>&nbsp;                        if (gotslot[2] != NULL)</b>
<b class="nc"><i>1238</i>&nbsp;                                return (m_docHandle | gotslot[2]);</b>
<i>1239</i>&nbsp;                }
<b class="nc"><i>1240</i>&nbsp;                return NULL;</b>
<i>1241</i>&nbsp;        }
<i>1242</i>&nbsp;
<i>1243</i>&nbsp;        /**
<i>1244</i>&nbsp;         * Given a namespace handle, advance to the next namespace.
<i>1245</i>&nbsp;         *
<i>1246</i>&nbsp;         * %TBD% THIS METHOD DOES NOT MATCH THE CURRENT SIGNATURE IN
<i>1247</i>&nbsp;         * THE DTM INTERFACE.  FIX IT, OR JUSTIFY CHANGING THE DTM
<i>1248</i>&nbsp;         * API.
<i>1249</i>&nbsp;         *
<i>1250</i>&nbsp;         * @param namespaceHandle handle to node which must be of type NAMESPACE_NODE.
<i>1251</i>&nbsp;         * @return handle of next namespace, or DTM.NULL to indicate none exists.
<i>1252</i>&nbsp;         */
<i>1253</i>&nbsp;        public int getNextNamespaceNode(int baseHandle,int namespaceHandle, boolean inScope) {
<i>1254</i>&nbsp;                // ###shs need to work on namespace
<b class="nc"><i>1255</i>&nbsp;                return NULL;</b>
<i>1256</i>&nbsp;        }
<i>1257</i>&nbsp;
<i>1258</i>&nbsp;        /**
<i>1259</i>&nbsp;         * Given a node handle, advance to its next descendant.
<i>1260</i>&nbsp;         * If not yet resolved, waits for more nodes to be added to the document and
<i>1261</i>&nbsp;         * tries again.
<i>1262</i>&nbsp;         *
<i>1263</i>&nbsp;         * @param subtreeRootHandle
<i>1264</i>&nbsp;         * @param nodeHandle int Handle of the node.
<i>1265</i>&nbsp;         * @return handle of next descendant,
<i>1266</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1267</i>&nbsp;         */
<i>1268</i>&nbsp;        public int getNextDescendant(int subtreeRootHandle, int nodeHandle) {
<b class="nc"><i>1269</i>&nbsp;                subtreeRootHandle &amp;= NODEHANDLE_MASK;</b>
<b class="nc"><i>1270</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<i>1271</i>&nbsp;                // Document root [Document Node? -- jjk] - no next-sib
<b class="nc"><i>1272</i>&nbsp;                if (nodeHandle == 0)</b>
<b class="nc"><i>1273</i>&nbsp;                        return NULL;</b>
<b class="nc"><i>1274</i>&nbsp;                while (!m_isError) {</b>
<i>1275</i>&nbsp;                        // Document done and node out of bounds
<b class="nc"><i>1276</i>&nbsp;                        if (done &amp;&amp; (nodeHandle &gt; nodes.slotsUsed()))</b>
<b class="nc"><i>1277</i>&nbsp;                                break;</b>
<b class="nc"><i>1278</i>&nbsp;                        if (nodeHandle &gt; subtreeRootHandle) {</b>
<b class="nc"><i>1279</i>&nbsp;                                nodes.readSlot(nodeHandle+1, gotslot);</b>
<b class="nc"><i>1280</i>&nbsp;                                if (gotslot[2] != 0) {</b>
<b class="nc"><i>1281</i>&nbsp;                                        short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<b class="nc"><i>1282</i>&nbsp;                                        if (type == ATTRIBUTE_NODE) {</b>
<b class="nc"><i>1283</i>&nbsp;                                                nodeHandle +=2;</b>
<i>1284</i>&nbsp;                                        } else {
<b class="nc"><i>1285</i>&nbsp;                                                int nextParentPos = gotslot[1];</b>
<b class="nc"><i>1286</i>&nbsp;                                                if (nextParentPos &gt;= subtreeRootHandle)</b>
<b class="nc"><i>1287</i>&nbsp;                                                        return (m_docHandle | (nodeHandle+1));</b>
<i>1288</i>&nbsp;                                                else
<i>1289</i>&nbsp;                                                        break;
<i>1290</i>&nbsp;                                        }
<b class="nc"><i>1291</i>&nbsp;                                } else if (!done) {</b>
<i>1292</i>&nbsp;                                        // Add wait logic here
<i>1293</i>&nbsp;                                } else
<i>1294</i>&nbsp;                                        break;
<i>1295</i>&nbsp;                        } else {
<b class="nc"><i>1296</i>&nbsp;                                nodeHandle++;</b>
<i>1297</i>&nbsp;                        }
<i>1298</i>&nbsp;                }
<i>1299</i>&nbsp;                // Probably should throw error here like original instead of returning
<b class="nc"><i>1300</i>&nbsp;                return NULL;</b>
<i>1301</i>&nbsp;        }
<i>1302</i>&nbsp;
<i>1303</i>&nbsp;        /**
<i>1304</i>&nbsp;         * Given a node handle, advance to the next node on the following axis.
<i>1305</i>&nbsp;         *
<i>1306</i>&nbsp;         * @param axisContextHandle the start of the axis that is being traversed.
<i>1307</i>&nbsp;         * @param nodeHandle
<i>1308</i>&nbsp;         * @return handle of next sibling,
<i>1309</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1310</i>&nbsp;         */
<i>1311</i>&nbsp;        public int getNextFollowing(int axisContextHandle, int nodeHandle) {
<i>1312</i>&nbsp;                //###shs still working on
<b class="nc"><i>1313</i>&nbsp;                return NULL;</b>
<i>1314</i>&nbsp;        }
<i>1315</i>&nbsp;
<i>1316</i>&nbsp;        /**
<i>1317</i>&nbsp;         * Given a node handle, advance to the next node on the preceding axis.
<i>1318</i>&nbsp;         *
<i>1319</i>&nbsp;         * @param axisContextHandle the start of the axis that is being traversed.
<i>1320</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1321</i>&nbsp;         * @return int Node-number of preceding sibling,
<i>1322</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1323</i>&nbsp;         */
<i>1324</i>&nbsp;        public int getNextPreceding(int axisContextHandle, int nodeHandle) {
<i>1325</i>&nbsp;                // ###shs copied from Xalan 1, what is this suppose to do?
<b class="nc"><i>1326</i>&nbsp;                nodeHandle &amp;= NODEHANDLE_MASK;</b>
<b class="nc"><i>1327</i>&nbsp;                while (nodeHandle &gt; 1) {</b>
<b class="nc"><i>1328</i>&nbsp;                        nodeHandle--;</b>
<b class="nc"><i>1329</i>&nbsp;                        if (ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) &amp; 0xFFFF))</b>
<b class="nc"><i>1330</i>&nbsp;                                continue;</b>
<i>1331</i>&nbsp;
<i>1332</i>&nbsp;                        // if nodeHandle is _not_ an ancestor of
<i>1333</i>&nbsp;                        // axisContextHandle, specialFind will return it.
<i>1334</i>&nbsp;                        // If it _is_ an ancestor, specialFind will return -1
<i>1335</i>&nbsp;
<i>1336</i>&nbsp;                        // %REVIEW% unconditional return defeats the
<i>1337</i>&nbsp;                        // purpose of the while loop -- does this
<i>1338</i>&nbsp;                        // logic make any sense?
<i>1339</i>&nbsp;
<b class="nc"><i>1340</i>&nbsp;                        return (m_docHandle | nodes.specialFind(axisContextHandle, nodeHandle));</b>
<i>1341</i>&nbsp;                }
<b class="nc"><i>1342</i>&nbsp;                return NULL;</b>
<i>1343</i>&nbsp;        }
<i>1344</i>&nbsp;
<i>1345</i>&nbsp;        /**
<i>1346</i>&nbsp;         * Given a node handle, find its parent node.
<i>1347</i>&nbsp;         *
<i>1348</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1349</i>&nbsp;         * @return int Node-number of parent,
<i>1350</i>&nbsp;         * or DTM.NULL to indicate none exists.
<i>1351</i>&nbsp;         */
<i>1352</i>&nbsp;        public int getParent(int nodeHandle) {
<i>1353</i>&nbsp;                // Should check to see within range?
<i>1354</i>&nbsp;
<i>1355</i>&nbsp;                // Document Root should not have to be handled differently
<b class="nc"><i>1356</i>&nbsp;                return (m_docHandle | nodes.readEntry(nodeHandle, 1));</b>
<i>1357</i>&nbsp;        }
<i>1358</i>&nbsp;
<i>1359</i>&nbsp;        /**
<i>1360</i>&nbsp;         * Returns the root element of the document.
<i>1361</i>&nbsp;         * @return nodeHandle to the Document Root.
<i>1362</i>&nbsp;         */
<i>1363</i>&nbsp;        public int getDocumentRoot() {
<b class="nc"><i>1364</i>&nbsp;                return (m_docHandle | m_docElement);</b>
<i>1365</i>&nbsp;        }
<i>1366</i>&nbsp;
<i>1367</i>&nbsp;        /**
<i>1368</i>&nbsp;         * Given a node handle, find the owning document node.
<i>1369</i>&nbsp;         *
<i>1370</i>&nbsp;         * @return int Node handle of document, which should always be valid.
<i>1371</i>&nbsp;         */
<i>1372</i>&nbsp;        public int getDocument() {
<b class="nc"><i>1373</i>&nbsp;                return m_docHandle;</b>
<i>1374</i>&nbsp;        }
<i>1375</i>&nbsp;
<i>1376</i>&nbsp;        /**
<i>1377</i>&nbsp;         * Given a node handle, find the owning document node.  This has the exact
<i>1378</i>&nbsp;         * same semantics as the DOM Document method of the same name, in that if
<i>1379</i>&nbsp;         * the nodeHandle is a document node, it will return NULL.
<i>1380</i>&nbsp;         *
<i>1381</i>&nbsp;         * &lt;p&gt;%REVIEW% Since this is DOM-specific, it may belong at the DOM
<i>1382</i>&nbsp;         * binding layer. Included here as a convenience function and to
<i>1383</i>&nbsp;         * aid porting of DOM code to DTM.&lt;/p&gt;
<i>1384</i>&nbsp;         *
<i>1385</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1386</i>&nbsp;         * @return int Node handle of owning document, or NULL if the nodeHandle is
<i>1387</i>&nbsp;         *             a document.
<i>1388</i>&nbsp;         */
<i>1389</i>&nbsp;        public int getOwnerDocument(int nodeHandle) {
<i>1390</i>&nbsp;                // Assumption that Document Node is always in 0 slot
<b class="nc"><i>1391</i>&nbsp;                if ((nodeHandle &amp; NODEHANDLE_MASK) == 0)</b>
<b class="nc"><i>1392</i>&nbsp;                        return NULL;</b>
<b class="nc"><i>1393</i>&nbsp;                return (nodeHandle &amp; DOCHANDLE_MASK);</b>
<i>1394</i>&nbsp;        }
<i>1395</i>&nbsp;
<i>1396</i>&nbsp;        /**
<i>1397</i>&nbsp;         * Given a node handle, find the owning document node.  This has the DTM
<i>1398</i>&nbsp;         * semantics; a Document node is its own owner.
<i>1399</i>&nbsp;         *
<i>1400</i>&nbsp;         * &lt;p&gt;%REVIEW% Since this is DOM-specific, it may belong at the DOM
<i>1401</i>&nbsp;         * binding layer. Included here as a convenience function and to
<i>1402</i>&nbsp;         * aid porting of DOM code to DTM.&lt;/p&gt;
<i>1403</i>&nbsp;         *
<i>1404</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1405</i>&nbsp;         * @return int Node handle of owning document, or NULL if the nodeHandle is
<i>1406</i>&nbsp;         *             a document.
<i>1407</i>&nbsp;         */
<i>1408</i>&nbsp;        public int getDocumentRoot(int nodeHandle) {
<i>1409</i>&nbsp;                // Assumption that Document Node is always in 0 slot
<b class="nc"><i>1410</i>&nbsp;                if ((nodeHandle &amp; NODEHANDLE_MASK) == 0)</b>
<b class="nc"><i>1411</i>&nbsp;                        return NULL;</b>
<b class="nc"><i>1412</i>&nbsp;                return (nodeHandle &amp; DOCHANDLE_MASK);</b>
<i>1413</i>&nbsp;        }
<i>1414</i>&nbsp;
<i>1415</i>&nbsp;        /**
<i>1416</i>&nbsp;         * Get the string-value of a node as a String object
<i>1417</i>&nbsp;         * (see http://www.w3.org/TR/xpath#data-model
<i>1418</i>&nbsp;         * for the definition of a node&#39;s string-value).
<i>1419</i>&nbsp;         *
<i>1420</i>&nbsp;         * @param nodeHandle The node ID.
<i>1421</i>&nbsp;         *
<i>1422</i>&nbsp;         * @return A string object that represents the string-value of the given node.
<i>1423</i>&nbsp;         */
<i>1424</i>&nbsp;        public XMLString getStringValue(int nodeHandle) {
<i>1425</i>&nbsp;        // ###zaj - researching
<b class="nc"><i>1426</i>&nbsp;        nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1427</i>&nbsp;        int nodetype=gotslot[0] &amp; 0xFF;</b>
<b class="nc"><i>1428</i>&nbsp;        String value=null;</b>
<i>1429</i>&nbsp;
<b class="nc"><i>1430</i>&nbsp;        switch (nodetype) {</b>
<i>1431</i>&nbsp;        case TEXT_NODE:
<i>1432</i>&nbsp;        case COMMENT_NODE:
<i>1433</i>&nbsp;        case CDATA_SECTION_NODE:
<b class="nc"><i>1434</i>&nbsp;                value= m_char.getString(gotslot[2], gotslot[3]);</b>
<b class="nc"><i>1435</i>&nbsp;                break;</b>
<i>1436</i>&nbsp;        case PROCESSING_INSTRUCTION_NODE:
<i>1437</i>&nbsp;        case ATTRIBUTE_NODE:
<i>1438</i>&nbsp;        case ELEMENT_NODE:
<i>1439</i>&nbsp;        case ENTITY_REFERENCE_NODE:
<i>1440</i>&nbsp;        default:
<i>1441</i>&nbsp;                break;
<i>1442</i>&nbsp;        }
<b class="nc"><i>1443</i>&nbsp;        return m_xsf.newstr( value );</b>
<i>1444</i>&nbsp;
<i>1445</i>&nbsp;        }
<i>1446</i>&nbsp;
<i>1447</i>&nbsp;        /**
<i>1448</i>&nbsp;         * Get number of character array chunks in
<i>1449</i>&nbsp;         * the string-value of a node.
<i>1450</i>&nbsp;         * (see http://www.w3.org/TR/xpath#data-model
<i>1451</i>&nbsp;         * for the definition of a node&#39;s string-value).
<i>1452</i>&nbsp;         * Note that a single text node may have multiple text chunks.
<i>1453</i>&nbsp;         *
<i>1454</i>&nbsp;         * EXPLANATION: This method is an artifact of the fact that the
<i>1455</i>&nbsp;         * underlying m_chars object may not store characters in a
<i>1456</i>&nbsp;         * single contiguous array -- for example,the current
<i>1457</i>&nbsp;         * FastStringBuffer may split a single node&#39;s text across
<i>1458</i>&nbsp;         * multiple allocation units.  This call tells us how many
<i>1459</i>&nbsp;         * separate accesses will be required to retrieve the entire
<i>1460</i>&nbsp;         * content. PLEASE NOTE that this may not be the same as the
<i>1461</i>&nbsp;         * number of SAX characters() events that caused the text node
<i>1462</i>&nbsp;         * to be built in the first place, since m_chars buffering may
<i>1463</i>&nbsp;         * be on different boundaries than the parser&#39;s buffers.
<i>1464</i>&nbsp;         *
<i>1465</i>&nbsp;         * @param nodeHandle The node ID.
<i>1466</i>&nbsp;         *
<i>1467</i>&nbsp;         * @return number of character array chunks in
<i>1468</i>&nbsp;         *         the string-value of a node.
<i>1469</i>&nbsp;         * */
<i>1470</i>&nbsp;        //###zaj - tbd
<i>1471</i>&nbsp;        public int getStringValueChunkCount(int nodeHandle)
<i>1472</i>&nbsp;        {
<i>1473</i>&nbsp;                //###zaj    return value
<b class="nc"><i>1474</i>&nbsp;                return 0;</b>
<i>1475</i>&nbsp;        }
<i>1476</i>&nbsp;
<i>1477</i>&nbsp;        /**
<i>1478</i>&nbsp;         * Get a character array chunk in the string-value of a node.
<i>1479</i>&nbsp;         * (see http://www.w3.org/TR/xpath#data-model
<i>1480</i>&nbsp;         * for the definition of a node&#39;s string-value).
<i>1481</i>&nbsp;         * Note that a single text node may have multiple text chunks.
<i>1482</i>&nbsp;         *
<i>1483</i>&nbsp;         * EXPLANATION: This method is an artifact of the fact that
<i>1484</i>&nbsp;         * the underlying m_chars object may not store characters in a
<i>1485</i>&nbsp;         * single contiguous array -- for example,the current
<i>1486</i>&nbsp;         * FastStringBuffer may split a single node&#39;s text across
<i>1487</i>&nbsp;         * multiple allocation units.  This call retrieves a single
<i>1488</i>&nbsp;         * contiguous portion of the text -- as much as m-chars was
<i>1489</i>&nbsp;         * able to store in a single allocation unit.  PLEASE NOTE
<i>1490</i>&nbsp;         * that this may not be the same granularityas the SAX
<i>1491</i>&nbsp;         * characters() events that caused the text node to be built
<i>1492</i>&nbsp;         * in the first place, since m_chars buffering may be on
<i>1493</i>&nbsp;         * different boundaries than the parser&#39;s buffers.
<i>1494</i>&nbsp;         *
<i>1495</i>&nbsp;         * @param nodeHandle The node ID.
<i>1496</i>&nbsp;         * @param chunkIndex Which chunk to get.
<i>1497</i>&nbsp;         * @param startAndLen An array of 2 where the start position and length of
<i>1498</i>&nbsp;         *                    the chunk will be returned.
<i>1499</i>&nbsp;         *
<i>1500</i>&nbsp;         * @return The character array reference where the chunk occurs.  */
<i>1501</i>&nbsp;        //###zaj - tbd
<i>1502</i>&nbsp;        public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
<b class="nc"><i>1503</i>&nbsp;                                                                                                                                                int[] startAndLen) {return new char[0];}</b>
<i>1504</i>&nbsp;
<i>1505</i>&nbsp;        /**
<i>1506</i>&nbsp;         * Given a node handle, return an ID that represents the node&#39;s expanded name.
<i>1507</i>&nbsp;         *
<i>1508</i>&nbsp;         * @param nodeHandle The handle to the node in question.
<i>1509</i>&nbsp;         *
<i>1510</i>&nbsp;         * @return the expanded-name id of the node.
<i>1511</i>&nbsp;         */
<i>1512</i>&nbsp;        public int getExpandedTypeID(int nodeHandle) {
<b class="nc"><i>1513</i>&nbsp;           nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1514</i>&nbsp;           String qName = m_localNames.indexToString(gotslot[3]);</b>
<i>1515</i>&nbsp;           // Remove prefix from qName
<i>1516</i>&nbsp;           // %TBD% jjk This is assuming the elementName is the qName.
<b class="nc"><i>1517</i>&nbsp;           int colonpos = qName.indexOf(&quot;:&quot;);</b>
<b class="nc"><i>1518</i>&nbsp;           String localName = qName.substring(colonpos+1);</b>
<i>1519</i>&nbsp;           // Get NS
<b class="nc"><i>1520</i>&nbsp;           String namespace = m_nsNames.indexToString(gotslot[0] &lt;&lt; 16);</b>
<i>1521</i>&nbsp;           // Create expanded name
<b class="nc"><i>1522</i>&nbsp;           String expandedName = namespace + &quot;:&quot; + localName;</b>
<b class="nc"><i>1523</i>&nbsp;           int expandedNameID = m_nsNames.stringToIndex(expandedName);</b>
<i>1524</i>&nbsp;
<b class="nc"><i>1525</i>&nbsp;        return expandedNameID;</b>
<i>1526</i>&nbsp;        }
<i>1527</i>&nbsp;
<i>1528</i>&nbsp;
<i>1529</i>&nbsp;        /**
<i>1530</i>&nbsp;         * Given an expanded name, return an ID.  If the expanded-name does not
<i>1531</i>&nbsp;         * exist in the internal tables, the entry will be created, and the ID will
<i>1532</i>&nbsp;         * be returned.  Any additional nodes that are created that have this
<i>1533</i>&nbsp;         * expanded name will use this ID.
<i>1534</i>&nbsp;         *
<i>1535</i>&nbsp;         * @return the expanded-name id of the node.
<i>1536</i>&nbsp;         */
<i>1537</i>&nbsp;        public int getExpandedTypeID(String namespace, String localName, int type) {
<i>1538</i>&nbsp;           // Create expanded name
<i>1539</i>&nbsp;          // %TBD% jjk Expanded name is bitfield-encoded as
<i>1540</i>&nbsp;          // typeID[6]nsuriID[10]localID[16]. Switch to that form, and to
<i>1541</i>&nbsp;          // accessing the ns/local via their tables rather than confusing
<i>1542</i>&nbsp;          // nsnames and expandednames.
<b class="nc"><i>1543</i>&nbsp;           String expandedName = namespace + &quot;:&quot; + localName;</b>
<b class="nc"><i>1544</i>&nbsp;           int expandedNameID = m_nsNames.stringToIndex(expandedName);</b>
<i>1545</i>&nbsp;
<b class="nc"><i>1546</i>&nbsp;           return expandedNameID;</b>
<i>1547</i>&nbsp;        }
<i>1548</i>&nbsp;
<i>1549</i>&nbsp;
<i>1550</i>&nbsp;        /**
<i>1551</i>&nbsp;         * Given an expanded-name ID, return the local name part.
<i>1552</i>&nbsp;         *
<i>1553</i>&nbsp;         * @param ExpandedNameID an ID that represents an expanded-name.
<i>1554</i>&nbsp;         * @return String Local name of this node.
<i>1555</i>&nbsp;         */
<i>1556</i>&nbsp;        public String getLocalNameFromExpandedNameID(int ExpandedNameID) {
<i>1557</i>&nbsp;
<i>1558</i>&nbsp;           // Get expanded name
<b class="nc"><i>1559</i>&nbsp;           String expandedName = m_localNames.indexToString(ExpandedNameID);</b>
<i>1560</i>&nbsp;           // Remove prefix from expanded name
<b class="nc"><i>1561</i>&nbsp;           int colonpos = expandedName.indexOf(&quot;:&quot;);</b>
<b class="nc"><i>1562</i>&nbsp;           String localName = expandedName.substring(colonpos+1);</b>
<b class="nc"><i>1563</i>&nbsp;           return localName;</b>
<i>1564</i>&nbsp;        }
<i>1565</i>&nbsp;
<i>1566</i>&nbsp;
<i>1567</i>&nbsp;        /**
<i>1568</i>&nbsp;         * Given an expanded-name ID, return the namespace URI part.
<i>1569</i>&nbsp;         *
<i>1570</i>&nbsp;         * @param ExpandedNameID an ID that represents an expanded-name.
<i>1571</i>&nbsp;         * @return String URI value of this node&#39;s namespace, or null if no
<i>1572</i>&nbsp;         * namespace was resolved.
<i>1573</i>&nbsp;        */
<i>1574</i>&nbsp;        public String getNamespaceFromExpandedNameID(int ExpandedNameID) {
<i>1575</i>&nbsp;
<b class="nc"><i>1576</i>&nbsp;           String expandedName = m_localNames.indexToString(ExpandedNameID);</b>
<i>1577</i>&nbsp;           // Remove local name from expanded name
<b class="nc"><i>1578</i>&nbsp;           int colonpos = expandedName.indexOf(&quot;:&quot;);</b>
<b class="nc"><i>1579</i>&nbsp;           String nsName = expandedName.substring(0, colonpos);</b>
<i>1580</i>&nbsp;
<b class="nc"><i>1581</i>&nbsp;        return nsName;</b>
<i>1582</i>&nbsp;        }
<i>1583</i>&nbsp;
<i>1584</i>&nbsp;
<i>1585</i>&nbsp;        /**
<i>1586</i>&nbsp;         * fixednames
<i>1587</i>&nbsp;        */
<b class="nc"><i>1588</i>&nbsp;        private static final String[] fixednames=</b>
<i>1589</i>&nbsp;        {
<i>1590</i>&nbsp;                null,null,                                                      // nothing, Element
<i>1591</i>&nbsp;                null,&quot;#text&quot;,                                           // Attr, Text
<i>1592</i>&nbsp;                &quot;#cdata_section&quot;,null,  // CDATA, EntityReference
<i>1593</i>&nbsp;                null,null,                                                      // Entity, PI
<i>1594</i>&nbsp;                &quot;#comment&quot;,&quot;#document&quot;, // Comment, Document
<i>1595</i>&nbsp;                null,&quot;#document-fragment&quot;, // Doctype, DocumentFragment
<i>1596</i>&nbsp;                null};                                                                  // Notation
<i>1597</i>&nbsp;
<i>1598</i>&nbsp;        /**
<i>1599</i>&nbsp;         * Given a node handle, return its DOM-style node name. This will
<i>1600</i>&nbsp;         * include names such as #text or #document.
<i>1601</i>&nbsp;         *
<i>1602</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1603</i>&nbsp;         * @return String Name of this node, which may be an empty string.
<i>1604</i>&nbsp;         * %REVIEW% Document when empty string is possible...
<i>1605</i>&nbsp;         */
<i>1606</i>&nbsp;        public String getNodeName(int nodeHandle) {
<b class="nc"><i>1607</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1608</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<b class="nc"><i>1609</i>&nbsp;                String name = fixednames[type];</b>
<b class="nc"><i>1610</i>&nbsp;                if (null == name) {</b>
<b class="nc"><i>1611</i>&nbsp;                  int i=gotslot[3];</b>
<b class="nc"><i>1612</i>&nbsp;                  /**/System.out.println(&quot;got i=&quot;+i+&quot; &quot;+(i&gt;&gt;16)+&quot;/&quot;+(i&amp;0xffff));</b>
<i>1613</i>&nbsp;
<b class="nc"><i>1614</i>&nbsp;                  name=m_localNames.indexToString(i &amp; 0xFFFF);</b>
<b class="nc"><i>1615</i>&nbsp;                  String prefix=m_prefixNames.indexToString(i &gt;&gt;16);</b>
<b class="nc"><i>1616</i>&nbsp;                  if(prefix!=null &amp;&amp; prefix.length()&gt;0)</b>
<b class="nc"><i>1617</i>&nbsp;                    name=prefix+&quot;:&quot;+name;</b>
<i>1618</i>&nbsp;                }
<b class="nc"><i>1619</i>&nbsp;                return name;</b>
<i>1620</i>&nbsp;        }
<i>1621</i>&nbsp;
<i>1622</i>&nbsp;        /**
<i>1623</i>&nbsp;         * Given a node handle, return the XPath node name.  This should be
<i>1624</i>&nbsp;         * the name as described by the XPath data model, NOT the DOM-style
<i>1625</i>&nbsp;         * name.
<i>1626</i>&nbsp;         *
<i>1627</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1628</i>&nbsp;         * @return String Name of this node.
<i>1629</i>&nbsp;         */
<b class="nc"><i>1630</i>&nbsp;        public String getNodeNameX(int nodeHandle) {return null;}</b>
<i>1631</i>&nbsp;
<i>1632</i>&nbsp;        /**
<i>1633</i>&nbsp;         * Given a node handle, return its DOM-style localname.
<i>1634</i>&nbsp;         * (As defined in Namespaces, this is the portion of the name after any
<i>1635</i>&nbsp;         * colon character)
<i>1636</i>&nbsp;         *
<i>1637</i>&nbsp;         * %REVIEW% What&#39;s the local name of something other than Element/Attr?
<i>1638</i>&nbsp;         * Should this be DOM-style (undefined unless namespaced), or other?
<i>1639</i>&nbsp;         *
<i>1640</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1641</i>&nbsp;         * @return String Local name of this node.
<i>1642</i>&nbsp;         */
<i>1643</i>&nbsp;        public String getLocalName(int nodeHandle) {
<b class="nc"><i>1644</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1645</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<b class="nc"><i>1646</i>&nbsp;                String name = &quot;&quot;;</b>
<b class="nc"><i>1647</i>&nbsp;                if ((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {</b>
<b class="nc"><i>1648</i>&nbsp;                  int i=gotslot[3];</b>
<b class="nc"><i>1649</i>&nbsp;                  name=m_localNames.indexToString(i &amp; 0xFFFF);</b>
<b class="nc"><i>1650</i>&nbsp;                  if(name==null) name=&quot;&quot;;</b>
<i>1651</i>&nbsp;                }
<b class="nc"><i>1652</i>&nbsp;                return name;</b>
<i>1653</i>&nbsp;        }
<i>1654</i>&nbsp;
<i>1655</i>&nbsp;        /**
<i>1656</i>&nbsp;         * Given a namespace handle, return the prefix that the namespace decl is
<i>1657</i>&nbsp;         * mapping.
<i>1658</i>&nbsp;         * Given a node handle, return the prefix used to map to the namespace.
<i>1659</i>&nbsp;         *
<i>1660</i>&nbsp;         * &lt;p&gt; %REVIEW% Are you sure you want &quot;&quot; for no prefix?  &lt;/p&gt;
<i>1661</i>&nbsp;         *
<i>1662</i>&nbsp;         * %REVIEW%  Should this be DOM-style (undefined unless namespaced),
<i>1663</i>&nbsp;         * or other?
<i>1664</i>&nbsp;         *
<i>1665</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1666</i>&nbsp;         * @return String prefix of this node&#39;s name, or &quot;&quot; if no explicit
<i>1667</i>&nbsp;         * namespace prefix was given.
<i>1668</i>&nbsp;         */
<i>1669</i>&nbsp;        public String getPrefix(int nodeHandle) {
<b class="nc"><i>1670</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1671</i>&nbsp;                short type = (short) (gotslot[0] &amp; 0xFFFF);</b>
<b class="nc"><i>1672</i>&nbsp;                String name = &quot;&quot;;</b>
<b class="nc"><i>1673</i>&nbsp;                if((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {</b>
<b class="nc"><i>1674</i>&nbsp;                  int i=gotslot[3];</b>
<b class="nc"><i>1675</i>&nbsp;                  name=m_prefixNames.indexToString(i &gt;&gt;16);</b>
<b class="nc"><i>1676</i>&nbsp;                  if(name==null) name=&quot;&quot;;</b>
<i>1677</i>&nbsp;                }
<b class="nc"><i>1678</i>&nbsp;                return name;</b>
<i>1679</i>&nbsp;        }
<i>1680</i>&nbsp;
<i>1681</i>&nbsp;        /**
<i>1682</i>&nbsp;         * Given a node handle, return its DOM-style namespace URI
<i>1683</i>&nbsp;         * (As defined in Namespaces, this is the declared URI which this node&#39;s
<i>1684</i>&nbsp;         * prefix -- or default in lieu thereof -- was mapped to.)
<i>1685</i>&nbsp;         *
<i>1686</i>&nbsp;         * @param nodeHandle the id of the node.
<i>1687</i>&nbsp;         * @return String URI value of this node&#39;s namespace, or null if no
<i>1688</i>&nbsp;         * namespace was resolved.
<i>1689</i>&nbsp;         */
<b class="nc"><i>1690</i>&nbsp;        public String getNamespaceURI(int nodeHandle) {return null;}</b>
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;        /**
<i>1693</i>&nbsp;         * Given a node handle, return its node value. This is mostly
<i>1694</i>&nbsp;         * as defined by the DOM, but may ignore some conveniences.
<i>1695</i>&nbsp;         * &lt;p&gt;
<i>1696</i>&nbsp;         *
<i>1697</i>&nbsp;         * @param nodeHandle The node id.
<i>1698</i>&nbsp;         * @return String Value of this node, or null if not
<i>1699</i>&nbsp;         * meaningful for this node type.
<i>1700</i>&nbsp;         */
<i>1701</i>&nbsp;        @SuppressWarnings(&quot;fallthrough&quot;)
<i>1702</i>&nbsp;        public String getNodeValue(int nodeHandle)
<b class="nc"><i>1703</i>&nbsp;        {</b>
<b class="nc"><i>1704</i>&nbsp;                nodes.readSlot(nodeHandle, gotslot);</b>
<b class="nc"><i>1705</i>&nbsp;                int nodetype=gotslot[0] &amp; 0xFF;         // ###zaj use mask to get node type</b>
<i>1706</i>&nbsp;                String value=null;
<b class="nc"><i>1707</i>&nbsp;</b>
<i>1708</i>&nbsp;                switch (nodetype) {                     // ###zaj todo - document nodetypes
<b class="nc"><i>1709</i>&nbsp;                case ATTRIBUTE_NODE:</b>
<i>1710</i>&nbsp;                        nodes.readSlot(nodeHandle+1, gotslot);
<i>1711</i>&nbsp;                case TEXT_NODE:
<i>1712</i>&nbsp;                case COMMENT_NODE:
<b class="nc"><i>1713</i>&nbsp;                case CDATA_SECTION_NODE:</b>
<b class="nc"><i>1714</i>&nbsp;                        value=m_char.getString(gotslot[2], gotslot[3]);         //###zaj</b>
<i>1715</i>&nbsp;                        break;
<i>1716</i>&nbsp;                case PROCESSING_INSTRUCTION_NODE:
<i>1717</i>&nbsp;                case ELEMENT_NODE:
<i>1718</i>&nbsp;                case ENTITY_REFERENCE_NODE:
<i>1719</i>&nbsp;                default:
<i>1720</i>&nbsp;                        break;
<b class="nc"><i>1721</i>&nbsp;                }</b>
<i>1722</i>&nbsp;                return value;
<i>1723</i>&nbsp;        }
<i>1724</i>&nbsp;
<i>1725</i>&nbsp;        /**
<i>1726</i>&nbsp;         * Given a node handle, return its DOM-style node type.
<i>1727</i>&nbsp;         * &lt;p&gt;
<i>1728</i>&nbsp;         * %REVIEW% Generally, returning short is false economy. Return int?
<i>1729</i>&nbsp;         *
<i>1730</i>&nbsp;         * @param nodeHandle The node id.
<i>1731</i>&nbsp;         * @return int Node type, as per the DOM&#39;s Node._NODE constants.
<i>1732</i>&nbsp;         */
<b class="nc"><i>1733</i>&nbsp;        public short getNodeType(int nodeHandle) {</b>
<i>1734</i>&nbsp;                return(short) (nodes.readEntry(nodeHandle, 0) &amp; 0xFFFF);
<i>1735</i>&nbsp;        }
<i>1736</i>&nbsp;
<i>1737</i>&nbsp;        /**
<i>1738</i>&nbsp;         * Get the depth level of this node in the tree (equals 1 for
<i>1739</i>&nbsp;         * a parentless node).
<i>1740</i>&nbsp;         *
<i>1741</i>&nbsp;         * @param nodeHandle The node id.
<i>1742</i>&nbsp;         * @return the number of ancestors, plus one
<i>1743</i>&nbsp;         * @xsl.usage internal
<i>1744</i>&nbsp;         */
<b class="nc"><i>1745</i>&nbsp;        public short getLevel(int nodeHandle) {</b>
<b class="nc"><i>1746</i>&nbsp;                short count = 0;</b>
<b class="nc"><i>1747</i>&nbsp;                while (nodeHandle != 0) {</b>
<b class="nc"><i>1748</i>&nbsp;                        count++;</b>
<i>1749</i>&nbsp;                        nodeHandle = nodes.readEntry(nodeHandle, 1);
<b class="nc"><i>1750</i>&nbsp;                }</b>
<i>1751</i>&nbsp;                return count;
<i>1752</i>&nbsp;        }
<i>1753</i>&nbsp;
<i>1754</i>&nbsp;        // ============== Document query functions ==============
<i>1755</i>&nbsp;
<i>1756</i>&nbsp;        /**
<i>1757</i>&nbsp;         * Tests whether DTM DOM implementation implements a specific feature and
<i>1758</i>&nbsp;         * that feature is supported by this node.
<i>1759</i>&nbsp;         *
<i>1760</i>&nbsp;         * @param feature The name of the feature to test.
<i>1761</i>&nbsp;         * @param version This is the version number of the feature to test.
<i>1762</i>&nbsp;         *   If the version is not
<i>1763</i>&nbsp;         *   specified, supporting any version of the feature will cause the
<i>1764</i>&nbsp;         *   method to return &lt;code&gt;true&lt;/code&gt;.
<i>1765</i>&nbsp;         * @return Returns &lt;code&gt;true&lt;/code&gt; if the specified feature is
<i>1766</i>&nbsp;         *   supported on this node, &lt;code&gt;false&lt;/code&gt; otherwise.
<b class="nc"><i>1767</i>&nbsp;         */</b>
<i>1768</i>&nbsp;        public boolean isSupported(String feature, String version) {return false;}
<i>1769</i>&nbsp;
<i>1770</i>&nbsp;        /**
<i>1771</i>&nbsp;         * Return the base URI of the document entity. If it is not known
<i>1772</i>&nbsp;         * (because the document was parsed from a socket connection or from
<i>1773</i>&nbsp;         * standard input, for example), the value of this property is unknown.
<i>1774</i>&nbsp;         *
<i>1775</i>&nbsp;         * @return the document base URI String object or null if unknown.
<i>1776</i>&nbsp;         */
<i>1777</i>&nbsp;        public String getDocumentBaseURI()
<i>1778</i>&nbsp;        {
<b class="nc"><i>1779</i>&nbsp;</b>
<i>1780</i>&nbsp;          return m_documentBaseURI;
<i>1781</i>&nbsp;        }
<i>1782</i>&nbsp;
<i>1783</i>&nbsp;        /**
<i>1784</i>&nbsp;         * Set the base URI of the document entity.
<i>1785</i>&nbsp;         *
<i>1786</i>&nbsp;         * @param baseURI the document base URI String object or null if unknown.
<i>1787</i>&nbsp;         */
<i>1788</i>&nbsp;        public void setDocumentBaseURI(String baseURI)
<i>1789</i>&nbsp;        {
<b class="nc"><i>1790</i>&nbsp;</b>
<i>1791</i>&nbsp;          m_documentBaseURI = baseURI;
<i>1792</i>&nbsp;        }
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;        /**
<i>1795</i>&nbsp;         * Return the system identifier of the document entity. If
<i>1796</i>&nbsp;         * it is not known, the value of this property is unknown.
<i>1797</i>&nbsp;         *
<i>1798</i>&nbsp;         * @param nodeHandle The node id, which can be any valid node handle.
<i>1799</i>&nbsp;         * @return the system identifier String object or null if unknown.
<b class="nc"><i>1800</i>&nbsp;         */</b>
<i>1801</i>&nbsp;        public String getDocumentSystemIdentifier(int nodeHandle) {return null;}
<i>1802</i>&nbsp;
<i>1803</i>&nbsp;        /**
<i>1804</i>&nbsp;         * Return the name of the character encoding scheme
<i>1805</i>&nbsp;         *        in which the document entity is expressed.
<i>1806</i>&nbsp;         *
<i>1807</i>&nbsp;         * @param nodeHandle The node id, which can be any valid node handle.
<i>1808</i>&nbsp;         * @return the document encoding String object.
<b class="nc"><i>1809</i>&nbsp;         */</b>
<i>1810</i>&nbsp;        public String getDocumentEncoding(int nodeHandle) {return null;}
<i>1811</i>&nbsp;
<i>1812</i>&nbsp;        /**
<i>1813</i>&nbsp;         * Return an indication of the standalone status of the document,
<i>1814</i>&nbsp;         *        either &quot;yes&quot; or &quot;no&quot;. This property is derived from the optional
<i>1815</i>&nbsp;         *        standalone document declaration in the XML declaration at the
<i>1816</i>&nbsp;         *        beginning of the document entity, and has no value if there is no
<i>1817</i>&nbsp;         *        standalone document declaration.
<i>1818</i>&nbsp;         *
<i>1819</i>&nbsp;         * @param nodeHandle The node id, which can be any valid node handle.
<i>1820</i>&nbsp;         * @return the document standalone String object, either &quot;yes&quot;, &quot;no&quot;, or null.
<b class="nc"><i>1821</i>&nbsp;         */</b>
<i>1822</i>&nbsp;        public String getDocumentStandalone(int nodeHandle) {return null;}
<i>1823</i>&nbsp;
<i>1824</i>&nbsp;        /**
<i>1825</i>&nbsp;         * Return a string representing the XML version of the document. This
<i>1826</i>&nbsp;         * property is derived from the XML declaration optionally present at the
<i>1827</i>&nbsp;         * beginning of the document entity, and has no value if there is no XML
<i>1828</i>&nbsp;         * declaration.
<i>1829</i>&nbsp;         *
<i>1830</i>&nbsp;         * @param documentHandle the document handle
<i>1831</i>&nbsp;         *
<i>1832</i>&nbsp;         * @return the document version String object
<b class="nc"><i>1833</i>&nbsp;         */</b>
<i>1834</i>&nbsp;        public String getDocumentVersion(int documentHandle) {return null;}
<i>1835</i>&nbsp;
<i>1836</i>&nbsp;        /**
<i>1837</i>&nbsp;         * Return an indication of
<i>1838</i>&nbsp;         * whether the processor has read the complete DTD. Its value is a
<i>1839</i>&nbsp;         * boolean. If it is false, then certain properties (indicated in their
<i>1840</i>&nbsp;         * descriptions below) may be unknown. If it is true, those properties
<i>1841</i>&nbsp;         * are never unknown.
<i>1842</i>&nbsp;         *
<i>1843</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if all declarations were processed {};
<i>1844</i>&nbsp;         *         &lt;code&gt;false&lt;/code&gt; otherwise.
<b class="nc"><i>1845</i>&nbsp;         */</b>
<i>1846</i>&nbsp;        public boolean getDocumentAllDeclarationsProcessed() {return false;}
<i>1847</i>&nbsp;
<i>1848</i>&nbsp;        /**
<i>1849</i>&nbsp;         *   A document type declaration information item has the following properties:
<i>1850</i>&nbsp;         *
<i>1851</i>&nbsp;         *     1. [system identifier] The system identifier of the external subset, if
<i>1852</i>&nbsp;         *        it exists. Otherwise this property has no value.
<i>1853</i>&nbsp;         *
<i>1854</i>&nbsp;         * @return the system identifier String object, or null if there is none.
<b class="nc"><i>1855</i>&nbsp;         */</b>
<i>1856</i>&nbsp;        public String getDocumentTypeDeclarationSystemIdentifier() {return null;}
<i>1857</i>&nbsp;
<i>1858</i>&nbsp;        /**
<i>1859</i>&nbsp;         * Return the public identifier of the external subset,
<i>1860</i>&nbsp;         * normalized as described in 4.2.2 External Entities [XML]. If there is
<i>1861</i>&nbsp;         * no external subset or if it has no public identifier, this property
<i>1862</i>&nbsp;         * has no value.
<i>1863</i>&nbsp;         *
<i>1864</i>&nbsp;         * @return the public identifier String object, or null if there is none.
<b class="nc"><i>1865</i>&nbsp;         */</b>
<i>1866</i>&nbsp;        public String getDocumentTypeDeclarationPublicIdentifier() {return null;}
<i>1867</i>&nbsp;
<i>1868</i>&nbsp;        /**
<i>1869</i>&nbsp;         * Returns the &lt;code&gt;Element&lt;/code&gt; whose &lt;code&gt;ID&lt;/code&gt; is given by
<i>1870</i>&nbsp;         * &lt;code&gt;elementId&lt;/code&gt;. If no such element exists, returns
<i>1871</i>&nbsp;         * &lt;code&gt;DTM.NULL&lt;/code&gt;. Behavior is not defined if more than one element
<i>1872</i>&nbsp;         * has this &lt;code&gt;ID&lt;/code&gt;. Attributes (including those
<i>1873</i>&nbsp;         * with the name &quot;ID&quot;) are not of type ID unless so defined by DTD/Schema
<i>1874</i>&nbsp;         * information available to the DTM implementation.
<i>1875</i>&nbsp;         * Implementations that do not know whether attributes are of type ID or
<i>1876</i>&nbsp;         * not are expected to return &lt;code&gt;DTM.NULL&lt;/code&gt;.
<i>1877</i>&nbsp;         *
<i>1878</i>&nbsp;         * &lt;p&gt;%REVIEW% Presumably IDs are still scoped to a single document,
<i>1879</i>&nbsp;         * and this operation searches only within a single document, right?
<i>1880</i>&nbsp;         * Wouldn&#39;t want collisions between DTMs in the same process.&lt;/p&gt;
<i>1881</i>&nbsp;         *
<i>1882</i>&nbsp;         * @param elementId The unique &lt;code&gt;id&lt;/code&gt; value for an element.
<i>1883</i>&nbsp;         * @return The handle of the matching element.
<b class="nc"><i>1884</i>&nbsp;         */</b>
<i>1885</i>&nbsp;        public int getElementById(String elementId) {return 0;}
<i>1886</i>&nbsp;
<i>1887</i>&nbsp;        /**
<i>1888</i>&nbsp;         * The getUnparsedEntityURI function returns the URI of the unparsed
<i>1889</i>&nbsp;         * entity with the specified name in the same document as the context
<i>1890</i>&nbsp;         * node (see [3.3 Unparsed Entities]). It returns the empty string if
<i>1891</i>&nbsp;         * there is no such entity.
<i>1892</i>&nbsp;         * &lt;p&gt;
<i>1893</i>&nbsp;         * XML processors may choose to use the System Identifier (if one
<i>1894</i>&nbsp;         * is provided) to resolve the entity, rather than the URI in the
<i>1895</i>&nbsp;         * Public Identifier. The details are dependent on the processor, and
<i>1896</i>&nbsp;         * we would have to support some form of plug-in resolver to handle
<i>1897</i>&nbsp;         * this properly. Currently, we simply return the System Identifier if
<i>1898</i>&nbsp;         * present, and hope that it a usable URI or that our caller can
<i>1899</i>&nbsp;         * map it to one.
<i>1900</i>&nbsp;         * TODO: Resolve Public Identifiers... or consider changing function name.
<i>1901</i>&nbsp;         * &lt;p&gt;
<i>1902</i>&nbsp;         * If we find a relative URI
<i>1903</i>&nbsp;         * reference, XML expects it to be resolved in terms of the base URI
<i>1904</i>&nbsp;         * of the document. The DOM doesn&#39;t do that for us, and it isn&#39;t
<i>1905</i>&nbsp;         * entirely clear whether that should be done here; currently that&#39;s
<i>1906</i>&nbsp;         * pushed up to a higher level of our application. (Note that DOM Level
<i>1907</i>&nbsp;         * 1 didn&#39;t store the document&#39;s base URI.)
<i>1908</i>&nbsp;         * TODO: Consider resolving Relative URIs.
<i>1909</i>&nbsp;         * &lt;p&gt;
<i>1910</i>&nbsp;         * (The DOM&#39;s statement that &quot;An XML processor may choose to
<i>1911</i>&nbsp;         * completely expand entities before the structure model is passed
<i>1912</i>&nbsp;         * to the DOM&quot; refers only to parsed entities, not unparsed, and hence
<i>1913</i>&nbsp;         * doesn&#39;t affect this function.)
<i>1914</i>&nbsp;         *
<i>1915</i>&nbsp;         * @param name A string containing the Entity Name of the unparsed
<i>1916</i>&nbsp;         * entity.
<i>1917</i>&nbsp;         *
<i>1918</i>&nbsp;         * @return String containing the URI of the Unparsed Entity, or an
<i>1919</i>&nbsp;         * empty string if no such entity exists.
<b class="nc"><i>1920</i>&nbsp;         */</b>
<i>1921</i>&nbsp;        public String getUnparsedEntityURI(String name) {return null;}
<i>1922</i>&nbsp;
<i>1923</i>&nbsp;
<i>1924</i>&nbsp;        // ============== Boolean methods ================
<i>1925</i>&nbsp;
<i>1926</i>&nbsp;        /**
<i>1927</i>&nbsp;         * Return true if the xsl:strip-space or xsl:preserve-space was processed
<i>1928</i>&nbsp;         * during construction of the DTM document.
<i>1929</i>&nbsp;         *
<i>1930</i>&nbsp;         * &lt;p&gt;%REVEIW% Presumes a 1:1 mapping from DTM to Document, since
<i>1931</i>&nbsp;         * we aren&#39;t saying which Document to query...?&lt;/p&gt;
<b class="nc"><i>1932</i>&nbsp;         */</b>
<i>1933</i>&nbsp;        public boolean supportsPreStripping() {return false;}
<i>1934</i>&nbsp;
<i>1935</i>&nbsp;        /**
<i>1936</i>&nbsp;         * Figure out whether nodeHandle2 should be considered as being later
<i>1937</i>&nbsp;         * in the document than nodeHandle1, in Document Order as defined
<i>1938</i>&nbsp;         * by the XPath model. This may not agree with the ordering defined
<i>1939</i>&nbsp;         * by other XML applications.
<i>1940</i>&nbsp;         * &lt;p&gt;
<i>1941</i>&nbsp;         * There are some cases where ordering isn&#39;t defined, and neither are
<i>1942</i>&nbsp;         * the results of this function -- though we&#39;ll generally return true.
<i>1943</i>&nbsp;         *
<i>1944</i>&nbsp;         * TODO: Make sure this does the right thing with attribute nodes!!!
<i>1945</i>&nbsp;         *
<i>1946</i>&nbsp;         * @param nodeHandle1 DOM Node to perform position comparison on.
<i>1947</i>&nbsp;         * @param nodeHandle2 DOM Node to perform position comparison on .
<i>1948</i>&nbsp;         *
<i>1949</i>&nbsp;         * @return false if node2 comes before node1, otherwise return true.
<i>1950</i>&nbsp;         * You can think of this as
<i>1951</i>&nbsp;         * &lt;code&gt;(node1.documentOrderPosition &amp;lt;= node2.documentOrderPosition)&lt;/code&gt;.
<b class="nc"><i>1952</i>&nbsp;         */</b>
<i>1953</i>&nbsp;        public boolean isNodeAfter(int nodeHandle1, int nodeHandle2) {return false;}
<i>1954</i>&nbsp;
<i>1955</i>&nbsp;        /**
<i>1956</i>&nbsp;         *     2. [element content whitespace] A boolean indicating whether the
<i>1957</i>&nbsp;         *        character is white space appearing within element content (see [XML],
<i>1958</i>&nbsp;         *        2.10 &quot;White Space Handling&quot;). Note that validating XML processors are
<i>1959</i>&nbsp;         *        required by XML 1.0 to provide this information. If there is no
<i>1960</i>&nbsp;         *        declaration for the containing element, this property has no value for
<i>1961</i>&nbsp;         *        white space characters. If no declaration has been read, but the [all
<i>1962</i>&nbsp;         *        declarations processed] property of the document information item is
<i>1963</i>&nbsp;         *        false (so there may be an unread declaration), then the value of this
<i>1964</i>&nbsp;         *        property is unknown for white space characters. It is always false for
<i>1965</i>&nbsp;         *        characters that are not white space.
<i>1966</i>&nbsp;         *
<i>1967</i>&nbsp;         * @param nodeHandle the node ID.
<i>1968</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if the character data is whitespace;
<i>1969</i>&nbsp;         *         &lt;code&gt;false&lt;/code&gt; otherwise.
<b class="nc"><i>1970</i>&nbsp;         */</b>
<i>1971</i>&nbsp;        public boolean isCharacterElementContentWhitespace(int nodeHandle) {return false;}
<i>1972</i>&nbsp;
<i>1973</i>&nbsp;        /**
<i>1974</i>&nbsp;         *    10. [all declarations processed] This property is not strictly speaking
<i>1975</i>&nbsp;         *        part of the infoset of the document. Rather it is an indication of
<i>1976</i>&nbsp;         *        whether the processor has read the complete DTD. Its value is a
<i>1977</i>&nbsp;         *        boolean. If it is false, then certain properties (indicated in their
<i>1978</i>&nbsp;         *        descriptions below) may be unknown. If it is true, those properties
<i>1979</i>&nbsp;         *        are never unknown.
<i>1980</i>&nbsp;         *
<i>1981</i>&nbsp;         * @param documentHandle A node handle that must identify a document.
<i>1982</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if all declarations were processed;
<i>1983</i>&nbsp;         *         &lt;code&gt;false&lt;/code&gt; otherwise.
<b class="nc"><i>1984</i>&nbsp;         */</b>
<i>1985</i>&nbsp;        public boolean isDocumentAllDeclarationsProcessed(int documentHandle) {return false;}
<i>1986</i>&nbsp;
<i>1987</i>&nbsp;        /**
<i>1988</i>&nbsp;         *     5. [specified] A flag indicating whether this attribute was actually
<i>1989</i>&nbsp;         *        specified in the start-tag of its element, or was defaulted from the
<i>1990</i>&nbsp;         *        DTD.
<i>1991</i>&nbsp;         *
<i>1992</i>&nbsp;         * @param attributeHandle the attribute handle
<i>1993</i>&nbsp;         * @return &lt;code&gt;true&lt;/code&gt; if the attribute was specified;
<i>1994</i>&nbsp;         *         &lt;code&gt;false&lt;/code&gt; if it was defaulted.
<b class="nc"><i>1995</i>&nbsp;         */</b>
<i>1996</i>&nbsp;        public boolean isAttributeSpecified(int attributeHandle) {return false;}
<i>1997</i>&nbsp;
<i>1998</i>&nbsp;        // ========== Direct SAX Dispatch, for optimization purposes ========
<i>1999</i>&nbsp;
<i>2000</i>&nbsp;        /**
<i>2001</i>&nbsp;         * Directly call the
<i>2002</i>&nbsp;         * characters method on the passed ContentHandler for the
<i>2003</i>&nbsp;         * string-value of the given node (see http://www.w3.org/TR/xpath#data-model
<i>2004</i>&nbsp;         * for the definition of a node&#39;s string-value). Multiple calls to the
<i>2005</i>&nbsp;         * ContentHandler&#39;s characters methods may well occur for a single call to
<i>2006</i>&nbsp;         * this method.
<i>2007</i>&nbsp;         *
<i>2008</i>&nbsp;         * @param nodeHandle The node ID.
<i>2009</i>&nbsp;         * @param ch A non-null reference to a ContentHandler.
<i>2010</i>&nbsp;         *
<i>2011</i>&nbsp;         * @throws org.xml.sax.SAXException
<i>2012</i>&nbsp;         */
<i>2013</i>&nbsp;        public void dispatchCharactersEvents(
<i>2014</i>&nbsp;                                                                                                                                                        int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
<i>2015</i>&nbsp;        throws org.xml.sax.SAXException {}
<i>2016</i>&nbsp;
<i>2017</i>&nbsp;        /**
<i>2018</i>&nbsp;         * Directly create SAX parser events from a subtree.
<i>2019</i>&nbsp;         *
<i>2020</i>&nbsp;         * @param nodeHandle The node ID.
<i>2021</i>&nbsp;         * @param ch A non-null reference to a ContentHandler.
<i>2022</i>&nbsp;         *
<i>2023</i>&nbsp;         * @throws org.xml.sax.SAXException
<i>2024</i>&nbsp;         */
<i>2025</i>&nbsp;
<i>2026</i>&nbsp;        public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
<i>2027</i>&nbsp;        throws org.xml.sax.SAXException {}
<i>2028</i>&nbsp;
<i>2029</i>&nbsp;        /**
<i>2030</i>&nbsp;         * Return an DOM node for the given node.
<i>2031</i>&nbsp;         *
<i>2032</i>&nbsp;         * @param nodeHandle The node ID.
<i>2033</i>&nbsp;         *
<i>2034</i>&nbsp;         * @return A node representation of the DTM node.
<i>2035</i>&nbsp;         */
<i>2036</i>&nbsp;        public org.w3c.dom.Node getNode(int nodeHandle)
<b class="nc"><i>2037</i>&nbsp;        {</b>
<i>2038</i>&nbsp;          return null;
<i>2039</i>&nbsp;        }
<i>2040</i>&nbsp;
<i>2041</i>&nbsp;        // ==== Construction methods (may not be supported by some implementations!) =====
<i>2042</i>&nbsp;        // %REVIEW% jjk: These probably aren&#39;t the right API. At the very least
<i>2043</i>&nbsp;        // they need to deal with current-insertion-location and end-element
<i>2044</i>&nbsp;        // issues.
<i>2045</i>&nbsp;
<i>2046</i>&nbsp;        /**
<i>2047</i>&nbsp;         * Append a child to the end of the child list of the current node. Please note that the node
<i>2048</i>&nbsp;         * is always cloned if it is owned by another document.
<i>2049</i>&nbsp;         *
<i>2050</i>&nbsp;         * &lt;p&gt;%REVIEW% &quot;End of the document&quot; needs to be defined more clearly.
<i>2051</i>&nbsp;         * Does it become the last child of the Document? Of the root element?&lt;/p&gt;
<i>2052</i>&nbsp;         *
<i>2053</i>&nbsp;         * @param newChild Must be a valid new node handle.
<i>2054</i>&nbsp;         * @param clone true if the child should be cloned into the document.
<i>2055</i>&nbsp;         * @param cloneDepth if the clone argument is true, specifies that the
<i>2056</i>&nbsp;         *                   clone should include all it&#39;s children.
<i>2057</i>&nbsp;         */
<b class="nc"><i>2058</i>&nbsp;        public void appendChild(int newChild, boolean clone, boolean cloneDepth) {</b>
<b class="nc"><i>2059</i>&nbsp;                boolean sameDoc = ((newChild &amp; DOCHANDLE_MASK) == m_docHandle);</b>
<i>2060</i>&nbsp;                if (clone || !sameDoc) {
<i>2061</i>&nbsp;
<i>2062</i>&nbsp;                } else {
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;                }
<i>2065</i>&nbsp;        }
<i>2066</i>&nbsp;
<i>2067</i>&nbsp;        /**
<i>2068</i>&nbsp;         * Append a text node child that will be constructed from a string,
<i>2069</i>&nbsp;         * to the end of the document.
<i>2070</i>&nbsp;         *
<i>2071</i>&nbsp;         * &lt;p&gt;%REVIEW% &quot;End of the document&quot; needs to be defined more clearly.
<i>2072</i>&nbsp;         * Does it become the last child of the Document? Of the root element?&lt;/p&gt;
<i>2073</i>&nbsp;         *
<i>2074</i>&nbsp;         * @param str Non-null reference to a string.
<i>2075</i>&nbsp;         */
<i>2076</i>&nbsp;        public void appendTextChild(String str) {
<i>2077</i>&nbsp;                // ###shs Think more about how this differs from createTextNode
<i>2078</i>&nbsp;          //%TBD%
<i>2079</i>&nbsp;        }
<i>2080</i>&nbsp;
<i>2081</i>&nbsp;
<i>2082</i>&nbsp;  //================================================================
<i>2083</i>&nbsp;  // ==== BUILDER methods ====
<i>2084</i>&nbsp;  // %TBD% jjk: SHOULD PROBABLY BE INLINED, unless we want to support
<i>2085</i>&nbsp;  // both SAX1 and SAX2 and share this logic between them.
<i>2086</i>&nbsp;
<i>2087</i>&nbsp;  /** Append a text child at the current insertion point. Assumes that the
<i>2088</i>&nbsp;   * actual content of the text has previously been appended to the m_char
<i>2089</i>&nbsp;   * buffer (shared with the builder).
<i>2090</i>&nbsp;   *
<i>2091</i>&nbsp;   * @param m_char_current_start int Starting offset of node&#39;s content in m_char.
<i>2092</i>&nbsp;   * @param contentLength int Length of node&#39;s content in m_char.
<i>2093</i>&nbsp;   * */
<i>2094</i>&nbsp;  void appendTextChild(int m_char_current_start,int contentLength)
<i>2095</i>&nbsp;  {
<i>2096</i>&nbsp;    // create a Text Node
<b class="nc"><i>2097</i>&nbsp;    // %TBD% may be possible to combine with appendNode()to replace the next chunk of code</b>
<i>2098</i>&nbsp;    int w0 = TEXT_NODE;
<b class="nc"><i>2099</i>&nbsp;    // W1: Parent</b>
<i>2100</i>&nbsp;    int w1 = currentParent;
<b class="nc"><i>2101</i>&nbsp;    // W2: Start position within m_char</b>
<i>2102</i>&nbsp;    int w2 = m_char_current_start;
<b class="nc"><i>2103</i>&nbsp;    // W3: Length of the full string</b>
<i>2104</i>&nbsp;    int w3 = contentLength;
<b class="nc"><i>2105</i>&nbsp;</b>
<b class="nc"><i>2106</i>&nbsp;    int ourslot = appendNode(w0, w1, w2, w3);</b>
<i>2107</i>&nbsp;    previousSibling = ourslot;
<i>2108</i>&nbsp;  }
<i>2109</i>&nbsp;
<i>2110</i>&nbsp;  /** Append a comment child at the current insertion point. Assumes that the
<i>2111</i>&nbsp;   * actual content of the comment has previously been appended to the m_char
<i>2112</i>&nbsp;   * buffer (shared with the builder).
<i>2113</i>&nbsp;   *
<i>2114</i>&nbsp;   * @param m_char_current_start int Starting offset of node&#39;s content in m_char.
<i>2115</i>&nbsp;   * @param contentLength int Length of node&#39;s content in m_char.
<i>2116</i>&nbsp;   * */
<i>2117</i>&nbsp;  void appendComment(int m_char_current_start,int contentLength)
<i>2118</i>&nbsp;  {
<i>2119</i>&nbsp;    // create a Comment Node
<b class="nc"><i>2120</i>&nbsp;    // %TBD% may be possible to combine with appendNode()to replace the next chunk of code</b>
<i>2121</i>&nbsp;    int w0 = COMMENT_NODE;
<b class="nc"><i>2122</i>&nbsp;    // W1: Parent</b>
<i>2123</i>&nbsp;    int w1 = currentParent;
<b class="nc"><i>2124</i>&nbsp;    // W2: Start position within m_char</b>
<i>2125</i>&nbsp;    int w2 = m_char_current_start;
<b class="nc"><i>2126</i>&nbsp;    // W3: Length of the full string</b>
<i>2127</i>&nbsp;    int w3 = contentLength;
<b class="nc"><i>2128</i>&nbsp;</b>
<b class="nc"><i>2129</i>&nbsp;    int ourslot = appendNode(w0, w1, w2, w3);</b>
<i>2130</i>&nbsp;    previousSibling = ourslot;
<i>2131</i>&nbsp;  }
<i>2132</i>&nbsp;
<i>2133</i>&nbsp;
<i>2134</i>&nbsp;  /** Append an Element child at the current insertion point. This
<i>2135</i>&nbsp;   * Element then _becomes_ the insertion point; subsequent appends
<i>2136</i>&nbsp;   * become its lastChild until an appendEndElement() call is made.
<i>2137</i>&nbsp;   *
<i>2138</i>&nbsp;   * Assumes that the symbols (local name, namespace URI and prefix)
<i>2139</i>&nbsp;   * have already been added to the pools
<i>2140</i>&nbsp;   *
<i>2141</i>&nbsp;   * Note that this _only_ handles the Element node itself. Attrs and
<i>2142</i>&nbsp;   * namespace nodes are unbundled in the ContentHandler layer
<i>2143</i>&nbsp;   * and appended separately.
<i>2144</i>&nbsp;   *
<i>2145</i>&nbsp;   * @param namespaceIndex: Index within the namespaceURI string pool
<i>2146</i>&nbsp;   * @param localNameIndex Index within the local name string pool
<i>2147</i>&nbsp;   * @param prefixIndex: Index within the prefix string pool
<i>2148</i>&nbsp;   * */
<i>2149</i>&nbsp;  void appendStartElement(int namespaceIndex,int localNameIndex, int prefixIndex)
<i>2150</i>&nbsp;  {
<i>2151</i>&nbsp;                // do document root node creation here on the first element, create nodes for
<i>2152</i>&nbsp;                // this element and its attributes, store the element, namespace, and attritute
<i>2153</i>&nbsp;                // name indexes to the nodes array, keep track of the current node and parent
<i>2154</i>&nbsp;                // element used
<i>2155</i>&nbsp;
<b class="nc"><i>2156</i>&nbsp;                // W0  High:  Namespace  Low:  Node Type</b>
<i>2157</i>&nbsp;                int w0 = (namespaceIndex &lt;&lt; 16) | ELEMENT_NODE;
<b class="nc"><i>2158</i>&nbsp;                // W1: Parent</b>
<i>2159</i>&nbsp;                int w1 = currentParent;
<b class="nc"><i>2160</i>&nbsp;                // W2: Next  (initialized as 0)</b>
<i>2161</i>&nbsp;                int w2 = 0;
<b class="nc"><i>2162</i>&nbsp;                // W3: Tagname high: prefix Low: local name</b>
<b class="nc"><i>2163</i>&nbsp;                int w3 = localNameIndex | prefixIndex&lt;&lt;16;</b>
<i>2164</i>&nbsp;                /**/System.out.println(&quot;set w3=&quot;+w3+&quot; &quot;+(w3&gt;&gt;16)+&quot;/&quot;+(w3&amp;0xffff));
<i>2165</i>&nbsp;
<b class="nc"><i>2166</i>&nbsp;                //int ourslot = nodes.appendSlot(w0, w1, w2, w3);</b>
<b class="nc"><i>2167</i>&nbsp;                int ourslot = appendNode(w0, w1, w2, w3);</b>
<b class="nc"><i>2168</i>&nbsp;                currentParent = ourslot;</b>
<i>2169</i>&nbsp;                previousSibling = 0;
<i>2170</i>&nbsp;
<b class="nc"><i>2171</i>&nbsp;                // set the root element pointer when creating the first element node</b>
<b class="nc"><i>2172</i>&nbsp;                if (m_docElement == NULL)</b>
<i>2173</i>&nbsp;                        m_docElement = ourslot;
<i>2174</i>&nbsp;  }
<i>2175</i>&nbsp;
<i>2176</i>&nbsp;  /** Append a Namespace Declaration child at the current insertion point.
<i>2177</i>&nbsp;   * Assumes that the symbols (namespace URI and prefix) have already been
<i>2178</i>&nbsp;   * added to the pools
<i>2179</i>&nbsp;   *
<i>2180</i>&nbsp;   * @param prefixIndex: Index within the prefix string pool
<i>2181</i>&nbsp;   * @param namespaceIndex: Index within the namespaceURI string pool
<i>2182</i>&nbsp;   * @param isID: If someone really insists on writing a bad DTD, it is
<i>2183</i>&nbsp;   * theoretically possible for a namespace declaration to also be declared
<i>2184</i>&nbsp;   * as being a node ID. I don&#39;t really want to support that stupidity,
<i>2185</i>&nbsp;   * but I&#39;m not sure we can refuse to accept it.
<i>2186</i>&nbsp;   * */
<i>2187</i>&nbsp;  void appendNSDeclaration(int prefixIndex, int namespaceIndex,
<i>2188</i>&nbsp;                           boolean isID)
<i>2189</i>&nbsp;  {
<i>2190</i>&nbsp;    // %REVIEW% I&#39;m assigning this node the &quot;namespace for namespaces&quot;
<i>2191</i>&nbsp;    // which the DOM defined. It is expected that the Namespace spec will
<i>2192</i>&nbsp;    // adopt this as official. It isn&#39;t strictly needed since it&#39;s implied
<i>2193</i>&nbsp;    // by the nodetype, but for now...
<i>2194</i>&nbsp;
<i>2195</i>&nbsp;    // %REVIEW% Prefix need not be recorded; it&#39;s implied too. But
<i>2196</i>&nbsp;    // recording it might simplify the design.
<i>2197</i>&nbsp;
<i>2198</i>&nbsp;    // %TBD% isID is not currently honored.
<b class="nc"><i>2199</i>&nbsp;</b>
<i>2200</i>&nbsp;    final int namespaceForNamespaces=m_nsNames.stringToIndex(&quot;http://www.w3.org/2000/xmlns/&quot;);
<i>2201</i>&nbsp;
<b class="nc"><i>2202</i>&nbsp;    // W0  High:  Namespace  Low:  Node Type</b>
<i>2203</i>&nbsp;    int w0 = NAMESPACE_NODE | (m_nsNames.stringToIndex(&quot;http://www.w3.org/2000/xmlns/&quot;)&lt;&lt;16);
<i>2204</i>&nbsp;
<b class="nc"><i>2205</i>&nbsp;    // W1:  Parent</b>
<i>2206</i>&nbsp;    int w1 = currentParent;
<b class="nc"><i>2207</i>&nbsp;    // W2:  CURRENTLY UNUSED -- It&#39;s next-sib in attrs, but we have no kids.</b>
<i>2208</i>&nbsp;    int w2 = 0;
<b class="nc"><i>2209</i>&nbsp;    // W3:  namespace name</b>
<i>2210</i>&nbsp;    int w3 = namespaceIndex;
<b class="nc"><i>2211</i>&nbsp;    // Add node</b>
<b class="nc"><i>2212</i>&nbsp;    int ourslot = appendNode(w0, w1, w2, w3);</b>
<b class="nc"><i>2213</i>&nbsp;    previousSibling = ourslot;  // Should attributes be previous siblings</b>
<i>2214</i>&nbsp;    previousSiblingWasParent = false;
<i>2215</i>&nbsp;    return ;//(m_docHandle | ourslot);
<i>2216</i>&nbsp;  }
<i>2217</i>&nbsp;
<i>2218</i>&nbsp;  /** Append an Attribute child at the current insertion
<i>2219</i>&nbsp;   * point.  Assumes that the symbols (namespace URI, local name, and
<i>2220</i>&nbsp;   * prefix) have already been added to the pools, and that the content has
<i>2221</i>&nbsp;   * already been appended to m_char. Note that the attribute&#39;s content has
<i>2222</i>&nbsp;   * been flattened into a single string; DTM does _NOT_ attempt to model
<i>2223</i>&nbsp;   * the details of entity references within attribute values.
<i>2224</i>&nbsp;   *
<i>2225</i>&nbsp;   * @param namespaceIndex int Index within the namespaceURI string pool
<i>2226</i>&nbsp;   * @param localNameIndex int Index within the local name string pool
<i>2227</i>&nbsp;   * @param prefixIndex int Index within the prefix string pool
<i>2228</i>&nbsp;   * @param isID boolean True if this attribute was declared as an ID
<i>2229</i>&nbsp;   * (for use in supporting getElementByID).
<i>2230</i>&nbsp;   * @param m_char_current_start int Starting offset of node&#39;s content in m_char.
<i>2231</i>&nbsp;   * @param contentLength int Length of node&#39;s content in m_char.
<i>2232</i>&nbsp;   * */
<i>2233</i>&nbsp;  void appendAttribute(int namespaceIndex, int localNameIndex, int prefixIndex,
<i>2234</i>&nbsp;                       boolean isID,
<i>2235</i>&nbsp;                       int m_char_current_start, int contentLength)
<i>2236</i>&nbsp;  {
<i>2237</i>&nbsp;    // %TBD% isID is not currently honored.
<i>2238</i>&nbsp;
<b class="nc"><i>2239</i>&nbsp;    // W0  High:  Namespace  Low:  Node Type</b>
<i>2240</i>&nbsp;    int w0 = ATTRIBUTE_NODE | namespaceIndex&lt;&lt;16;
<i>2241</i>&nbsp;
<b class="nc"><i>2242</i>&nbsp;    // W1:  Parent</b>
<i>2243</i>&nbsp;    int w1 = currentParent;
<b class="nc"><i>2244</i>&nbsp;    // W2:  Next (not yet resolved)</b>
<i>2245</i>&nbsp;    int w2 = 0;
<b class="nc"><i>2246</i>&nbsp;    // W3:  Tagname high: prefix Low: local name</b>
<b class="nc"><i>2247</i>&nbsp;    int w3 = localNameIndex | prefixIndex&lt;&lt;16;</b>
<i>2248</i>&nbsp;    /**/System.out.println(&quot;set w3=&quot;+w3+&quot; &quot;+(w3&gt;&gt;16)+&quot;/&quot;+(w3&amp;0xffff));
<b class="nc"><i>2249</i>&nbsp;    // Add node</b>
<b class="nc"><i>2250</i>&nbsp;    int ourslot = appendNode(w0, w1, w2, w3);</b>
<i>2251</i>&nbsp;    previousSibling = ourslot;  // Should attributes be previous siblings
<i>2252</i>&nbsp;
<i>2253</i>&nbsp;    // Attribute&#39;s content is currently appended as a Text Node
<i>2254</i>&nbsp;
<b class="nc"><i>2255</i>&nbsp;    // W0: Node Type</b>
<i>2256</i>&nbsp;    w0 = TEXT_NODE;
<b class="nc"><i>2257</i>&nbsp;    // W1: Parent</b>
<i>2258</i>&nbsp;    w1 = ourslot;
<b class="nc"><i>2259</i>&nbsp;    // W2: Start Position within buffer</b>
<i>2260</i>&nbsp;    w2 = m_char_current_start;
<b class="nc"><i>2261</i>&nbsp;    // W3: Length</b>
<b class="nc"><i>2262</i>&nbsp;    w3 = contentLength;</b>
<i>2263</i>&nbsp;    appendNode(w0, w1, w2, w3);
<i>2264</i>&nbsp;
<b class="nc"><i>2265</i>&nbsp;    // Attrs are Parents</b>
<i>2266</i>&nbsp;    previousSiblingWasParent = true;
<i>2267</i>&nbsp;    return ;//(m_docHandle | ourslot);
<i>2268</i>&nbsp;  }
<i>2269</i>&nbsp;
<i>2270</i>&nbsp;  /**
<i>2271</i>&nbsp;   * This returns a stateless &quot;traverser&quot;, that can navigate over an
<i>2272</i>&nbsp;   * XPath axis, though not in document order.
<i>2273</i>&nbsp;   *
<i>2274</i>&nbsp;   * @param axis One of Axes.ANCESTORORSELF, etc.
<i>2275</i>&nbsp;   *
<i>2276</i>&nbsp;   * @return A DTMAxisIterator, or null if the given axis isn&#39;t supported.
<i>2277</i>&nbsp;   */
<i>2278</i>&nbsp;  public DTMAxisTraverser getAxisTraverser(final int axis)
<b class="nc"><i>2279</i>&nbsp;  {</b>
<i>2280</i>&nbsp;    return null;
<i>2281</i>&nbsp;  }
<i>2282</i>&nbsp;
<i>2283</i>&nbsp;  /**
<i>2284</i>&nbsp;   * This is a shortcut to the iterators that implement the
<i>2285</i>&nbsp;   * supported XPath axes (only namespace::) is not supported.
<i>2286</i>&nbsp;   * Returns a bare-bones iterator that must be initialized
<i>2287</i>&nbsp;   * with a start node (using iterator.setStartNode()).
<i>2288</i>&nbsp;   *
<i>2289</i>&nbsp;   * @param axis One of Axes.ANCESTORORSELF, etc.
<i>2290</i>&nbsp;   *
<i>2291</i>&nbsp;   * @return A DTMAxisIterator, or null if the given axis isn&#39;t supported.
<i>2292</i>&nbsp;   */
<i>2293</i>&nbsp;  public DTMAxisIterator getAxisIterator(final int axis)
<i>2294</i>&nbsp;  {
<b class="nc"><i>2295</i>&nbsp;    // %TBD%</b>
<i>2296</i>&nbsp;    return null;
<i>2297</i>&nbsp;  }
<i>2298</i>&nbsp;
<i>2299</i>&nbsp;  /**
<i>2300</i>&nbsp;   * Get an iterator that can navigate over an XPath Axis, predicated by
<i>2301</i>&nbsp;   * the extended type ID.
<i>2302</i>&nbsp;   *
<i>2303</i>&nbsp;   *
<i>2304</i>&nbsp;   * @param axis
<i>2305</i>&nbsp;   * @param type An extended type ID.
<i>2306</i>&nbsp;   *
<i>2307</i>&nbsp;   * @return A DTMAxisIterator, or null if the given axis isn&#39;t supported.
<i>2308</i>&nbsp;   */
<i>2309</i>&nbsp;  public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
<i>2310</i>&nbsp;  {
<b class="nc"><i>2311</i>&nbsp;    // %TBD%</b>
<i>2312</i>&nbsp;    return null;
<i>2313</i>&nbsp;  }
<i>2314</i>&nbsp;
<i>2315</i>&nbsp;
<i>2316</i>&nbsp;  /** Terminate the element currently acting as an insertion point. Subsequent
<i>2317</i>&nbsp;   * insertions will occur as the last child of this element&#39;s parent.
<i>2318</i>&nbsp;   * */
<i>2319</i>&nbsp;  void appendEndElement()
<i>2320</i>&nbsp;  {
<i>2321</i>&nbsp;    // pop up the stacks
<b class="nc"><i>2322</i>&nbsp;</b>
<b class="nc"><i>2323</i>&nbsp;    if (previousSiblingWasParent)</b>
<i>2324</i>&nbsp;      nodes.writeEntry(previousSibling, 2, NULL);
<i>2325</i>&nbsp;
<b class="nc"><i>2326</i>&nbsp;    // Pop parentage</b>
<b class="nc"><i>2327</i>&nbsp;    previousSibling = currentParent;</b>
<b class="nc"><i>2328</i>&nbsp;    nodes.readSlot(currentParent, gotslot);</b>
<i>2329</i>&nbsp;    currentParent = gotslot[1] &amp; 0xFFFF;
<i>2330</i>&nbsp;
<i>2331</i>&nbsp;    // The element just being finished will be
<b class="nc"><i>2332</i>&nbsp;    // the previous sibling for the next operation</b>
<i>2333</i>&nbsp;    previousSiblingWasParent = true;
<i>2334</i>&nbsp;
<i>2335</i>&nbsp;    // Pop a level of namespace table
<i>2336</i>&nbsp;    // namespaceTable.removeLastElem();
<i>2337</i>&nbsp;  }
<i>2338</i>&nbsp;
<i>2339</i>&nbsp;  /**  Starting a new document. Perform any resets/initialization
<i>2340</i>&nbsp;   * not already handled.
<i>2341</i>&nbsp;   * */
<i>2342</i>&nbsp;  void appendStartDocument()
<i>2343</i>&nbsp;  {
<i>2344</i>&nbsp;
<i>2345</i>&nbsp;    // %TBD% reset slot 0 to indicate ChunkedIntArray reuse or wait for
<b class="nc"><i>2346</i>&nbsp;    //       the next initDocument().</b>
<b class="nc"><i>2347</i>&nbsp;    m_docElement = NULL;         // reset nodeHandle to the root of the actual dtm doc content</b>
<i>2348</i>&nbsp;    initDocument(0);
<i>2349</i>&nbsp;  }
<i>2350</i>&nbsp;
<i>2351</i>&nbsp;  /**  All appends to this document have finished; do whatever final
<i>2352</i>&nbsp;   * cleanup is needed.
<i>2353</i>&nbsp;   * */
<i>2354</i>&nbsp;  void appendEndDocument()
<b class="nc"><i>2355</i>&nbsp;  {</b>
<i>2356</i>&nbsp;    done = true;
<i>2357</i>&nbsp;    // %TBD% may need to notice the last slot number and slot count to avoid
<i>2358</i>&nbsp;    // residual data from provious use of this DTM
<i>2359</i>&nbsp;  }
<i>2360</i>&nbsp;
<i>2361</i>&nbsp;  /**
<i>2362</i>&nbsp;   * For the moment all the run time properties are ignored by this
<i>2363</i>&nbsp;   * class.
<i>2364</i>&nbsp;   *
<i>2365</i>&nbsp;   * @param property a &lt;code&gt;String&lt;/code&gt; value
<i>2366</i>&nbsp;   * @param value an &lt;code&gt;Object&lt;/code&gt; value
<i>2367</i>&nbsp;   */
<i>2368</i>&nbsp;  public void setProperty(String property, Object value)
<i>2369</i>&nbsp;  {
<i>2370</i>&nbsp;  }
<i>2371</i>&nbsp;
<i>2372</i>&nbsp;  /**
<i>2373</i>&nbsp;   * Source information is not handled yet, so return
<i>2374</i>&nbsp;   * &lt;code&gt;null&lt;/code&gt; here.
<i>2375</i>&nbsp;   *
<i>2376</i>&nbsp;   * @param node an &lt;code&gt;int&lt;/code&gt; value
<i>2377</i>&nbsp;   * @return null
<i>2378</i>&nbsp;   */
<i>2379</i>&nbsp;  public SourceLocator getSourceLocatorFor(int node)
<b class="nc"><i>2380</i>&nbsp;  {</b>
<i>2381</i>&nbsp;    return null;
<i>2382</i>&nbsp;  }
<i>2383</i>&nbsp;
<i>2384</i>&nbsp;
<i>2385</i>&nbsp;  /**
<i>2386</i>&nbsp;   * A dummy routine to satisify the abstract interface. If the DTM
<i>2387</i>&nbsp;   * implememtation that extends the default base requires notification
<i>2388</i>&nbsp;   * of registration, they can override this method.
<i>2389</i>&nbsp;   */
<i>2390</i>&nbsp;   public void documentRegistration()
<i>2391</i>&nbsp;   {
<i>2392</i>&nbsp;   }
<i>2393</i>&nbsp;
<i>2394</i>&nbsp;  /**
<i>2395</i>&nbsp;   * A dummy routine to satisify the abstract interface. If the DTM
<i>2396</i>&nbsp;   * implememtation that extends the default base requires notification
<i>2397</i>&nbsp;   * when the document is being released, they can override this method
<i>2398</i>&nbsp;   */
<i>2399</i>&nbsp;   public void documentRelease()
<i>2400</i>&nbsp;   {
<i>2401</i>&nbsp;   }
<i>2402</i>&nbsp;
<i>2403</i>&nbsp;   /**
<i>2404</i>&nbsp;    * Migrate a DTM built with an old DTMManager to a new DTMManager.
<i>2405</i>&nbsp;    * After the migration, the new DTMManager will treat the DTM as
<i>2406</i>&nbsp;    * one that is built by itself.
<i>2407</i>&nbsp;    * This is used to support DTM sharing between multiple transformations.
<i>2408</i>&nbsp;    * @param manager the DTMManager
<i>2409</i>&nbsp;    */
<i>2410</i>&nbsp;   public void migrateTo(DTMManager manager)
<i>2411</i>&nbsp;   {
<i>2412</i>&nbsp;   }
<i>2413</i>&nbsp;
<i>2414</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
