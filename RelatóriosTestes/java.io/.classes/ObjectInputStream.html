


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ObjectInputStream</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.io</a> ]
</div>

<h1>Coverage Summary for Class: ObjectInputStream (java.io)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ObjectInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 592)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ObjectInputStream$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$BlockDataInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 394)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$Caches</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$FilterValues</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$GetField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$GetFieldImpl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$HandleTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$HandleTable$HandleList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$Logging</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$PeekInputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$ValidationList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$ValidationList$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ObjectInputStream$ValidationList$Callback</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 170)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1225)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.io;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.ObjectStreamClass.WeakClassKey;
<i>29</i>&nbsp;import java.lang.System.Logger;
<i>30</i>&nbsp;import java.lang.ref.ReferenceQueue;
<i>31</i>&nbsp;import java.lang.reflect.Array;
<i>32</i>&nbsp;import java.lang.reflect.Modifier;
<i>33</i>&nbsp;import java.lang.reflect.Proxy;
<i>34</i>&nbsp;import java.security.AccessControlContext;
<i>35</i>&nbsp;import java.security.AccessController;
<i>36</i>&nbsp;import java.security.PrivilegedAction;
<i>37</i>&nbsp;import java.security.PrivilegedActionException;
<i>38</i>&nbsp;import java.security.PrivilegedExceptionAction;
<i>39</i>&nbsp;import java.util.Arrays;
<i>40</i>&nbsp;import java.util.Map;
<i>41</i>&nbsp;import java.util.Objects;
<i>42</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>43</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>44</i>&nbsp;
<i>45</i>&nbsp;import static java.io.ObjectStreamClass.processQueue;
<i>46</i>&nbsp;
<i>47</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>48</i>&nbsp;import jdk.internal.misc.Unsafe;
<i>49</i>&nbsp;import sun.reflect.misc.ReflectUtil;
<i>50</i>&nbsp;
<i>51</i>&nbsp;/**
<i>52</i>&nbsp; * An ObjectInputStream deserializes primitive data and objects previously
<i>53</i>&nbsp; * written using an ObjectOutputStream.
<i>54</i>&nbsp; *
<i>55</i>&nbsp; * &lt;p&gt;&lt;strong&gt;Warning: Deserialization of untrusted data is inherently dangerous
<i>56</i>&nbsp; * and should be avoided. Untrusted data should be carefully validated according to the
<i>57</i>&nbsp; * &quot;Serialization and Deserialization&quot; section of the
<i>58</i>&nbsp; * {@extLink secure_coding_guidelines_javase Secure Coding Guidelines for Java SE}.
<i>59</i>&nbsp; * {@extLink serialization_filter_guide Serialization Filtering} describes best
<i>60</i>&nbsp; * practices for defensive use of serial filters.
<i>61</i>&nbsp; * &lt;/strong&gt;&lt;/p&gt;
<i>62</i>&nbsp; *
<i>63</i>&nbsp; * &lt;p&gt;ObjectOutputStream and ObjectInputStream can provide an application with
<i>64</i>&nbsp; * persistent storage for graphs of objects when used with a FileOutputStream
<i>65</i>&nbsp; * and FileInputStream respectively.  ObjectInputStream is used to recover
<i>66</i>&nbsp; * those objects previously serialized. Other uses include passing objects
<i>67</i>&nbsp; * between hosts using a socket stream or for marshaling and unmarshaling
<i>68</i>&nbsp; * arguments and parameters in a remote communication system.
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * &lt;p&gt;ObjectInputStream ensures that the types of all objects in the graph
<i>71</i>&nbsp; * created from the stream match the classes present in the Java Virtual
<i>72</i>&nbsp; * Machine.  Classes are loaded as required using the standard mechanisms.
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * &lt;p&gt;Only objects that support the java.io.Serializable or
<i>75</i>&nbsp; * java.io.Externalizable interface can be read from streams.
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * &lt;p&gt;The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the
<i>78</i>&nbsp; * stream.  Java&#39;s safe casting should be used to get the desired type.  In
<i>79</i>&nbsp; * Java, strings and arrays are objects and are treated as objects during
<i>80</i>&nbsp; * serialization. When read they need to be cast to the expected type.
<i>81</i>&nbsp; *
<i>82</i>&nbsp; * &lt;p&gt;Primitive data types can be read from the stream using the appropriate
<i>83</i>&nbsp; * method on DataInput.
<i>84</i>&nbsp; *
<i>85</i>&nbsp; * &lt;p&gt;The default deserialization mechanism for objects restores the contents
<i>86</i>&nbsp; * of each field to the value and type it had when it was written.  Fields
<i>87</i>&nbsp; * declared as transient or static are ignored by the deserialization process.
<i>88</i>&nbsp; * References to other objects cause those objects to be read from the stream
<i>89</i>&nbsp; * as necessary.  Graphs of objects are restored correctly using a reference
<i>90</i>&nbsp; * sharing mechanism.  New objects are always allocated when deserializing,
<i>91</i>&nbsp; * which prevents existing objects from being overwritten.
<i>92</i>&nbsp; *
<i>93</i>&nbsp; * &lt;p&gt;Reading an object is analogous to running the constructors of a new
<i>94</i>&nbsp; * object.  Memory is allocated for the object and initialized to zero (NULL).
<i>95</i>&nbsp; * No-arg constructors are invoked for the non-serializable classes and then
<i>96</i>&nbsp; * the fields of the serializable classes are restored from the stream starting
<i>97</i>&nbsp; * with the serializable class closest to java.lang.object and finishing with
<i>98</i>&nbsp; * the object&#39;s most specific class.
<i>99</i>&nbsp; *
<i>100</i>&nbsp; * &lt;p&gt;For example to read from a stream as written by the example in
<i>101</i>&nbsp; * ObjectOutputStream:
<i>102</i>&nbsp; * &lt;br&gt;
<i>103</i>&nbsp; * &lt;pre&gt;
<i>104</i>&nbsp; *      FileInputStream fis = new FileInputStream(&quot;t.tmp&quot;);
<i>105</i>&nbsp; *      ObjectInputStream ois = new ObjectInputStream(fis);
<i>106</i>&nbsp; *
<i>107</i>&nbsp; *      int i = ois.readInt();
<i>108</i>&nbsp; *      String today = (String) ois.readObject();
<i>109</i>&nbsp; *      Date date = (Date) ois.readObject();
<i>110</i>&nbsp; *
<i>111</i>&nbsp; *      ois.close();
<i>112</i>&nbsp; * &lt;/pre&gt;
<i>113</i>&nbsp; *
<i>114</i>&nbsp; * &lt;p&gt;Classes control how they are serialized by implementing either the
<i>115</i>&nbsp; * java.io.Serializable or java.io.Externalizable interfaces.
<i>116</i>&nbsp; *
<i>117</i>&nbsp; * &lt;p&gt;Implementing the Serializable interface allows object serialization to
<i>118</i>&nbsp; * save and restore the entire state of the object and it allows classes to
<i>119</i>&nbsp; * evolve between the time the stream is written and the time it is read.  It
<i>120</i>&nbsp; * automatically traverses references between objects, saving and restoring
<i>121</i>&nbsp; * entire graphs.
<i>122</i>&nbsp; *
<i>123</i>&nbsp; * &lt;p&gt;Serializable classes that require special handling during the
<i>124</i>&nbsp; * serialization and deserialization process should implement the following
<i>125</i>&nbsp; * methods:
<i>126</i>&nbsp; *
<i>127</i>&nbsp; * &lt;pre&gt;
<i>128</i>&nbsp; * private void writeObject(java.io.ObjectOutputStream stream)
<i>129</i>&nbsp; *     throws IOException;
<i>130</i>&nbsp; * private void readObject(java.io.ObjectInputStream stream)
<i>131</i>&nbsp; *     throws IOException, ClassNotFoundException;
<i>132</i>&nbsp; * private void readObjectNoData()
<i>133</i>&nbsp; *     throws ObjectStreamException;
<i>134</i>&nbsp; * &lt;/pre&gt;
<i>135</i>&nbsp; *
<i>136</i>&nbsp; * &lt;p&gt;The readObject method is responsible for reading and restoring the state
<i>137</i>&nbsp; * of the object for its particular class using data written to the stream by
<i>138</i>&nbsp; * the corresponding writeObject method.  The method does not need to concern
<i>139</i>&nbsp; * itself with the state belonging to its superclasses or subclasses.  State is
<i>140</i>&nbsp; * restored by reading data from the ObjectInputStream for the individual
<i>141</i>&nbsp; * fields and making assignments to the appropriate fields of the object.
<i>142</i>&nbsp; * Reading primitive data types is supported by DataInput.
<i>143</i>&nbsp; *
<i>144</i>&nbsp; * &lt;p&gt;Any attempt to read object data which exceeds the boundaries of the
<i>145</i>&nbsp; * custom data written by the corresponding writeObject method will cause an
<i>146</i>&nbsp; * OptionalDataException to be thrown with an eof field value of true.
<i>147</i>&nbsp; * Non-object reads which exceed the end of the allotted data will reflect the
<i>148</i>&nbsp; * end of data in the same way that they would indicate the end of the stream:
<i>149</i>&nbsp; * bytewise reads will return -1 as the byte read or number of bytes read, and
<i>150</i>&nbsp; * primitive reads will throw EOFExceptions.  If there is no corresponding
<i>151</i>&nbsp; * writeObject method, then the end of default serialized data marks the end of
<i>152</i>&nbsp; * the allotted data.
<i>153</i>&nbsp; *
<i>154</i>&nbsp; * &lt;p&gt;Primitive and object read calls issued from within a readExternal method
<i>155</i>&nbsp; * behave in the same manner--if the stream is already positioned at the end of
<i>156</i>&nbsp; * data written by the corresponding writeExternal method, object reads will
<i>157</i>&nbsp; * throw OptionalDataExceptions with eof set to true, bytewise reads will
<i>158</i>&nbsp; * return -1, and primitive reads will throw EOFExceptions.  Note that this
<i>159</i>&nbsp; * behavior does not hold for streams written with the old
<i>160</i>&nbsp; * &lt;code&gt;ObjectStreamConstants.PROTOCOL_VERSION_1&lt;/code&gt; protocol, in which the
<i>161</i>&nbsp; * end of data written by writeExternal methods is not demarcated, and hence
<i>162</i>&nbsp; * cannot be detected.
<i>163</i>&nbsp; *
<i>164</i>&nbsp; * &lt;p&gt;The readObjectNoData method is responsible for initializing the state of
<i>165</i>&nbsp; * the object for its particular class in the event that the serialization
<i>166</i>&nbsp; * stream does not list the given class as a superclass of the object being
<i>167</i>&nbsp; * deserialized.  This may occur in cases where the receiving party uses a
<i>168</i>&nbsp; * different version of the deserialized instance&#39;s class than the sending
<i>169</i>&nbsp; * party, and the receiver&#39;s version extends classes that are not extended by
<i>170</i>&nbsp; * the sender&#39;s version.  This may also occur if the serialization stream has
<i>171</i>&nbsp; * been tampered; hence, readObjectNoData is useful for initializing
<i>172</i>&nbsp; * deserialized objects properly despite a &quot;hostile&quot; or incomplete source
<i>173</i>&nbsp; * stream.
<i>174</i>&nbsp; *
<i>175</i>&nbsp; * &lt;p&gt;Serialization does not read or assign values to the fields of any object
<i>176</i>&nbsp; * that does not implement the java.io.Serializable interface.  Subclasses of
<i>177</i>&nbsp; * Objects that are not serializable can be serializable. In this case the
<i>178</i>&nbsp; * non-serializable class must have a no-arg constructor to allow its fields to
<i>179</i>&nbsp; * be initialized.  In this case it is the responsibility of the subclass to
<i>180</i>&nbsp; * save and restore the state of the non-serializable class. It is frequently
<i>181</i>&nbsp; * the case that the fields of that class are accessible (public, package, or
<i>182</i>&nbsp; * protected) or that there are get and set methods that can be used to restore
<i>183</i>&nbsp; * the state.
<i>184</i>&nbsp; *
<i>185</i>&nbsp; * &lt;p&gt;The contents of the stream can be filtered during deserialization.
<i>186</i>&nbsp; * If a {@linkplain #setObjectInputFilter(ObjectInputFilter) filter is set}
<i>187</i>&nbsp; * on an ObjectInputStream, the {@link ObjectInputFilter} can check that
<i>188</i>&nbsp; * the classes, array lengths, number of references in the stream, depth, and
<i>189</i>&nbsp; * number of bytes consumed from the input stream are allowed and
<i>190</i>&nbsp; * if not, can terminate deserialization.
<i>191</i>&nbsp; * A {@linkplain ObjectInputFilter.Config#setSerialFilter(ObjectInputFilter) process-wide filter}
<i>192</i>&nbsp; * can be configured that is applied to each {@code ObjectInputStream} unless replaced
<i>193</i>&nbsp; * using {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter}.
<i>194</i>&nbsp; *
<i>195</i>&nbsp; * &lt;p&gt;Any exception that occurs while deserializing an object will be caught by
<i>196</i>&nbsp; * the ObjectInputStream and abort the reading process.
<i>197</i>&nbsp; *
<i>198</i>&nbsp; * &lt;p&gt;Implementing the Externalizable interface allows the object to assume
<i>199</i>&nbsp; * complete control over the contents and format of the object&#39;s serialized
<i>200</i>&nbsp; * form.  The methods of the Externalizable interface, writeExternal and
<i>201</i>&nbsp; * readExternal, are called to save and restore the objects state.  When
<i>202</i>&nbsp; * implemented by a class they can write and read their own state using all of
<i>203</i>&nbsp; * the methods of ObjectOutput and ObjectInput.  It is the responsibility of
<i>204</i>&nbsp; * the objects to handle any versioning that occurs.
<i>205</i>&nbsp; *
<i>206</i>&nbsp; * &lt;p&gt;Enum constants are deserialized differently than ordinary serializable or
<i>207</i>&nbsp; * externalizable objects.  The serialized form of an enum constant consists
<i>208</i>&nbsp; * solely of its name; field values of the constant are not transmitted.  To
<i>209</i>&nbsp; * deserialize an enum constant, ObjectInputStream reads the constant name from
<i>210</i>&nbsp; * the stream; the deserialized constant is then obtained by calling the static
<i>211</i>&nbsp; * method &lt;code&gt;Enum.valueOf(Class, String)&lt;/code&gt; with the enum constant&#39;s
<i>212</i>&nbsp; * base type and the received constant name as arguments.  Like other
<b class="nc"><i>213</i>&nbsp; * serializable or externalizable objects, enum constants can function as the</b>
<i>214</i>&nbsp; * targets of back references appearing subsequently in the serialization
<i>215</i>&nbsp; * stream.  The process by which enum constants are deserialized cannot be
<i>216</i>&nbsp; * customized: any class-specific readObject, readObjectNoData, and readResolve
<i>217</i>&nbsp; * methods defined by enum types are ignored during deserialization.
<i>218</i>&nbsp; * Similarly, any serialPersistentFields or serialVersionUID field declarations
<i>219</i>&nbsp; * are also ignored--all enum types have a fixed serialVersionUID of 0L.
<b class="nc"><i>220</i>&nbsp; *</b>
<i>221</i>&nbsp; * @author      Mike Warres
<i>222</i>&nbsp; * @author      Roger Riggs
<b class="nc"><i>223</i>&nbsp; * @see java.io.DataInput</b>
<i>224</i>&nbsp; * @see java.io.ObjectOutputStream
<i>225</i>&nbsp; * @see java.io.Serializable
<b class="nc"><i>226</i>&nbsp; * @see &lt;a href=&quot;{@docRoot}/../specs/serialization/input.html&quot;&gt;</b>
<b class="nc"><i>227</i>&nbsp; *     Object Serialization Specification, Section 3, Object Input Classes&lt;/a&gt;</b>
<b class="nc"><i>228</i>&nbsp; * @since   1.1</b>
<b class="nc"><i>229</i>&nbsp; */</b>
<b class="nc"><i>230</i>&nbsp;public class ObjectInputStream</b>
<b class="nc"><i>231</i>&nbsp;    extends InputStream implements ObjectInput, ObjectStreamConstants</b>
<b class="nc"><i>232</i>&nbsp;{</b>
<b class="nc"><i>233</i>&nbsp;    /** handle value representing null */</b>
<b class="nc"><i>234</i>&nbsp;    private static final int NULL_HANDLE = -1;</b>
<i>235</i>&nbsp;
<i>236</i>&nbsp;    /** marker for unshared objects in internal handle table */
<b class="nc"><i>237</i>&nbsp;    private static final Object unsharedMarker = new Object();</b>
<i>238</i>&nbsp;
<b class="nc"><i>239</i>&nbsp;    /**</b>
<i>240</i>&nbsp;     * immutable table mapping primitive type names to corresponding
<i>241</i>&nbsp;     * class objects
<i>242</i>&nbsp;     */
<b class="nc"><i>243</i>&nbsp;    private static final Map&lt;String, Class&lt;?&gt;&gt; primClasses =</b>
<i>244</i>&nbsp;        Map.of(&quot;boolean&quot;, boolean.class,
<i>245</i>&nbsp;               &quot;byte&quot;, byte.class,
<i>246</i>&nbsp;               &quot;char&quot;, char.class,
<i>247</i>&nbsp;               &quot;short&quot;, short.class,
<i>248</i>&nbsp;               &quot;int&quot;, int.class,
<b class="nc"><i>249</i>&nbsp;               &quot;long&quot;, long.class,</b>
<i>250</i>&nbsp;               &quot;float&quot;, float.class,
<b class="nc"><i>251</i>&nbsp;               &quot;double&quot;, double.class,</b>
<i>252</i>&nbsp;               &quot;void&quot;, void.class);
<i>253</i>&nbsp;
<i>254</i>&nbsp;    private static class Caches {
<b class="nc"><i>255</i>&nbsp;        /** cache of subclass security audit results */</b>
<i>256</i>&nbsp;        static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
<i>257</i>&nbsp;            new ConcurrentHashMap&lt;&gt;();
<i>258</i>&nbsp;
<i>259</i>&nbsp;        /** queue for WeakReferences to audited subclasses */
<i>260</i>&nbsp;        static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
<i>261</i>&nbsp;            new ReferenceQueue&lt;&gt;();
<i>262</i>&nbsp;    }
<b class="nc"><i>263</i>&nbsp;</b>
<i>264</i>&nbsp;    /*
<i>265</i>&nbsp;     * Separate class to defer initialization of logging until needed.
<i>266</i>&nbsp;     */
<i>267</i>&nbsp;    private static class Logging {
<i>268</i>&nbsp;        /*
<i>269</i>&nbsp;         * Logger for ObjectInputFilter results.
<i>270</i>&nbsp;         * Setup the filter logger if it is set to DEBUG or TRACE.
<i>271</i>&nbsp;         * (Assuming it will not change).
<i>272</i>&nbsp;         */
<b class="nc"><i>273</i>&nbsp;        static final System.Logger filterLogger;</b>
<b class="nc"><i>274</i>&nbsp;</b>
<b class="nc"><i>275</i>&nbsp;        static {</b>
<b class="nc"><i>276</i>&nbsp;            Logger filterLog = System.getLogger(&quot;java.io.serialization&quot;);</b>
<b class="nc"><i>277</i>&nbsp;            filterLogger = (filterLog.isLoggable(Logger.Level.DEBUG)</b>
<i>278</i>&nbsp;                    || filterLog.isLoggable(Logger.Level.TRACE)) ? filterLog : null;
<i>279</i>&nbsp;        }
<i>280</i>&nbsp;    }
<i>281</i>&nbsp;
<i>282</i>&nbsp;    /** filter stream for handling block data conversion */
<i>283</i>&nbsp;    private final BlockDataInputStream bin;
<i>284</i>&nbsp;    /** validation callback list */
<i>285</i>&nbsp;    private final ValidationList vlist;
<i>286</i>&nbsp;    /** recursion depth */
<i>287</i>&nbsp;    private long depth;
<i>288</i>&nbsp;    /** Total number of references to any type of object, class, enum, proxy, etc. */
<i>289</i>&nbsp;    private long totalObjectRefs;
<i>290</i>&nbsp;    /** whether stream is closed */
<i>291</i>&nbsp;    private boolean closed;
<i>292</i>&nbsp;
<i>293</i>&nbsp;    /** wire handle -&gt; obj/exception map */
<i>294</i>&nbsp;    private final HandleTable handles;
<b class="nc"><i>295</i>&nbsp;    /** scratch field for passing handle values up/down call stack */</b>
<i>296</i>&nbsp;    private int passHandle = NULL_HANDLE;
<b class="nc"><i>297</i>&nbsp;    /** flag set when at end of field value block with no TC_ENDBLOCKDATA */</b>
<i>298</i>&nbsp;    private boolean defaultDataEnd = false;
<i>299</i>&nbsp;
<i>300</i>&nbsp;    /** if true, invoke readObjectOverride() instead of readObject() */
<i>301</i>&nbsp;    private final boolean enableOverride;
<i>302</i>&nbsp;    /** if true, invoke resolveObject() */
<i>303</i>&nbsp;    private boolean enableResolve;
<i>304</i>&nbsp;
<i>305</i>&nbsp;    /**
<i>306</i>&nbsp;     * Context during upcalls to class-defined readObject methods; holds
<i>307</i>&nbsp;     * object currently being deserialized and descriptor for current class.
<i>308</i>&nbsp;     * Null when not during readObject upcall.
<i>309</i>&nbsp;     */
<i>310</i>&nbsp;    private SerialCallbackContext curContext;
<i>311</i>&nbsp;
<i>312</i>&nbsp;    /**
<i>313</i>&nbsp;     * Filter of class descriptors and classes read from the stream;
<i>314</i>&nbsp;     * may be null.
<i>315</i>&nbsp;     */
<i>316</i>&nbsp;    private ObjectInputFilter serialFilter;
<i>317</i>&nbsp;
<i>318</i>&nbsp;    /**
<i>319</i>&nbsp;     * Creates an ObjectInputStream that reads from the specified InputStream.
<i>320</i>&nbsp;     * A serialization stream header is read from the stream and verified.
<i>321</i>&nbsp;     * This constructor will block until the corresponding ObjectOutputStream
<i>322</i>&nbsp;     * has written and flushed the header.
<i>323</i>&nbsp;     *
<i>324</i>&nbsp;     * &lt;p&gt;The serialization filter is initialized to the value of
<i>325</i>&nbsp;     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the process-wide filter}.
<i>326</i>&nbsp;     *
<i>327</i>&nbsp;     * &lt;p&gt;If a security manager is installed, this constructor will check for
<i>328</i>&nbsp;     * the &quot;enableSubclassImplementation&quot; SerializablePermission when invoked
<i>329</i>&nbsp;     * directly or indirectly by the constructor of a subclass which overrides
<i>330</i>&nbsp;     * the ObjectInputStream.readFields or ObjectInputStream.readUnshared
<i>331</i>&nbsp;     * methods.
<i>332</i>&nbsp;     *
<i>333</i>&nbsp;     * @param   in input stream to read from
<i>334</i>&nbsp;     * @throws  StreamCorruptedException if the stream header is incorrect
<i>335</i>&nbsp;     * @throws  IOException if an I/O error occurs while reading stream header
<i>336</i>&nbsp;     * @throws  SecurityException if untrusted subclass illegally overrides
<i>337</i>&nbsp;     *          security-sensitive methods
<i>338</i>&nbsp;     * @throws  NullPointerException if &lt;code&gt;in&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>339</i>&nbsp;     * @see     ObjectInputStream#ObjectInputStream()
<i>340</i>&nbsp;     * @see     ObjectInputStream#readFields()
<i>341</i>&nbsp;     * @see     ObjectOutputStream#ObjectOutputStream(OutputStream)
<b class="nc"><i>342</i>&nbsp;     */</b>
<b class="nc"><i>343</i>&nbsp;    public ObjectInputStream(InputStream in) throws IOException {</b>
<b class="nc"><i>344</i>&nbsp;        verifySubclass();</b>
<b class="nc"><i>345</i>&nbsp;        bin = new BlockDataInputStream(in);</b>
<b class="nc"><i>346</i>&nbsp;        handles = new HandleTable(10);</b>
<b class="nc"><i>347</i>&nbsp;        vlist = new ValidationList();</b>
<b class="nc"><i>348</i>&nbsp;        serialFilter = ObjectInputFilter.Config.getSerialFilter();</b>
<b class="nc"><i>349</i>&nbsp;        enableOverride = false;</b>
<b class="nc"><i>350</i>&nbsp;        readStreamHeader();</b>
<i>351</i>&nbsp;        bin.setBlockDataMode(true);
<i>352</i>&nbsp;    }
<i>353</i>&nbsp;
<i>354</i>&nbsp;    /**
<i>355</i>&nbsp;     * Provide a way for subclasses that are completely reimplementing
<i>356</i>&nbsp;     * ObjectInputStream to not have to allocate private data just used by this
<i>357</i>&nbsp;     * implementation of ObjectInputStream.
<i>358</i>&nbsp;     *
<i>359</i>&nbsp;     * &lt;p&gt;The serialization filter is initialized to the value of
<i>360</i>&nbsp;     * {@linkplain ObjectInputFilter.Config#getSerialFilter() the process-wide filter}.
<i>361</i>&nbsp;     *
<i>362</i>&nbsp;     * &lt;p&gt;If there is a security manager installed, this method first calls the
<i>363</i>&nbsp;     * security manager&#39;s &lt;code&gt;checkPermission&lt;/code&gt; method with the
<i>364</i>&nbsp;     * &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt;
<i>365</i>&nbsp;     * permission to ensure it&#39;s ok to enable subclassing.
<i>366</i>&nbsp;     *
<i>367</i>&nbsp;     * @throws  SecurityException if a security manager exists and its
<i>368</i>&nbsp;     *          &lt;code&gt;checkPermission&lt;/code&gt; method denies enabling
<i>369</i>&nbsp;     *          subclassing.
<b class="nc"><i>370</i>&nbsp;     * @throws  IOException if an I/O error occurs while creating this stream</b>
<b class="nc"><i>371</i>&nbsp;     * @see SecurityManager#checkPermission</b>
<b class="nc"><i>372</i>&nbsp;     * @see java.io.SerializablePermission</b>
<b class="nc"><i>373</i>&nbsp;     */</b>
<i>374</i>&nbsp;    protected ObjectInputStream() throws IOException, SecurityException {
<b class="nc"><i>375</i>&nbsp;        SecurityManager sm = System.getSecurityManager();</b>
<b class="nc"><i>376</i>&nbsp;        if (sm != null) {</b>
<b class="nc"><i>377</i>&nbsp;            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</b>
<b class="nc"><i>378</i>&nbsp;        }</b>
<b class="nc"><i>379</i>&nbsp;        bin = null;</b>
<i>380</i>&nbsp;        handles = null;
<i>381</i>&nbsp;        vlist = null;
<i>382</i>&nbsp;        serialFilter = ObjectInputFilter.Config.getSerialFilter();
<i>383</i>&nbsp;        enableOverride = true;
<i>384</i>&nbsp;    }
<i>385</i>&nbsp;
<i>386</i>&nbsp;    /**
<i>387</i>&nbsp;     * Read an object from the ObjectInputStream.  The class of the object, the
<i>388</i>&nbsp;     * signature of the class, and the values of the non-transient and
<i>389</i>&nbsp;     * non-static fields of the class and all of its supertypes are read.
<i>390</i>&nbsp;     * Default deserializing for a class can be overridden using the writeObject
<i>391</i>&nbsp;     * and readObject methods.  Objects referenced by this object are read
<i>392</i>&nbsp;     * transitively so that a complete equivalent graph of objects is
<i>393</i>&nbsp;     * reconstructed by readObject.
<i>394</i>&nbsp;     *
<i>395</i>&nbsp;     * &lt;p&gt;The root object is completely restored when all of its fields and the
<i>396</i>&nbsp;     * objects it references are completely restored.  At this point the object
<i>397</i>&nbsp;     * validation callbacks are executed in order based on their registered
<i>398</i>&nbsp;     * priorities. The callbacks are registered by objects (in the readObject
<i>399</i>&nbsp;     * special methods) as they are individually restored.
<i>400</i>&nbsp;     *
<i>401</i>&nbsp;     * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
<i>402</i>&nbsp;     * each object (regular or class) read to reconstruct the root object.
<i>403</i>&nbsp;     * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
<i>404</i>&nbsp;     *
<i>405</i>&nbsp;     * &lt;p&gt;Exceptions are thrown for problems with the InputStream and for
<i>406</i>&nbsp;     * classes that should not be deserialized.  All exceptions are fatal to
<i>407</i>&nbsp;     * the InputStream and leave it in an indeterminate state; it is up to the
<i>408</i>&nbsp;     * caller to ignore or recover the stream state.
<i>409</i>&nbsp;     *
<i>410</i>&nbsp;     * @throws  ClassNotFoundException Class of a serialized object cannot be
<i>411</i>&nbsp;     *          found.
<i>412</i>&nbsp;     * @throws  InvalidClassException Something is wrong with a class used by
<i>413</i>&nbsp;     *          serialization.
<i>414</i>&nbsp;     * @throws  StreamCorruptedException Control information in the
<b class="nc"><i>415</i>&nbsp;     *          stream is inconsistent.</b>
<b class="nc"><i>416</i>&nbsp;     * @throws  OptionalDataException Primitive data was found in the</b>
<i>417</i>&nbsp;     *          stream instead of objects.
<i>418</i>&nbsp;     * @throws  IOException Any of the usual Input/Output related exceptions.
<i>419</i>&nbsp;     */
<b class="nc"><i>420</i>&nbsp;    public final Object readObject()</b>
<i>421</i>&nbsp;        throws IOException, ClassNotFoundException
<b class="nc"><i>422</i>&nbsp;    {</b>
<b class="nc"><i>423</i>&nbsp;        if (enableOverride) {</b>
<b class="nc"><i>424</i>&nbsp;            return readObjectOverride();</b>
<b class="nc"><i>425</i>&nbsp;        }</b>
<b class="nc"><i>426</i>&nbsp;</b>
<i>427</i>&nbsp;        // if nested read, passHandle contains handle of enclosing object
<b class="nc"><i>428</i>&nbsp;        int outerHandle = passHandle;</b>
<b class="nc"><i>429</i>&nbsp;        try {</b>
<i>430</i>&nbsp;            Object obj = readObject0(false);
<b class="nc"><i>431</i>&nbsp;            handles.markDependency(outerHandle, passHandle);</b>
<i>432</i>&nbsp;            ClassNotFoundException ex = handles.lookupException(passHandle);
<b class="nc"><i>433</i>&nbsp;            if (ex != null) {</b>
<b class="nc"><i>434</i>&nbsp;                throw ex;</b>
<b class="nc"><i>435</i>&nbsp;            }</b>
<i>436</i>&nbsp;            if (depth == 0) {
<i>437</i>&nbsp;                vlist.doCallbacks();
<i>438</i>&nbsp;                freeze();
<i>439</i>&nbsp;            }
<i>440</i>&nbsp;            return obj;
<i>441</i>&nbsp;        } finally {
<i>442</i>&nbsp;            passHandle = outerHandle;
<i>443</i>&nbsp;            if (closed &amp;&amp; depth == 0) {
<i>444</i>&nbsp;                clear();
<i>445</i>&nbsp;            }
<i>446</i>&nbsp;        }
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;    /**
<i>450</i>&nbsp;     * This method is called by trusted subclasses of ObjectOutputStream that
<i>451</i>&nbsp;     * constructed ObjectOutputStream using the protected no-arg constructor.
<i>452</i>&nbsp;     * The subclass is expected to provide an override method with the modifier
<i>453</i>&nbsp;     * &quot;final&quot;.
<i>454</i>&nbsp;     *
<i>455</i>&nbsp;     * @return  the Object read from the stream.
<i>456</i>&nbsp;     * @throws  ClassNotFoundException Class definition of a serialized object
<i>457</i>&nbsp;     *          cannot be found.
<i>458</i>&nbsp;     * @throws  OptionalDataException Primitive data was found in the stream
<i>459</i>&nbsp;     *          instead of objects.
<b class="nc"><i>460</i>&nbsp;     * @throws  IOException if I/O errors occurred while reading from the</b>
<i>461</i>&nbsp;     *          underlying stream
<i>462</i>&nbsp;     * @see #ObjectInputStream()
<i>463</i>&nbsp;     * @see #readObject()
<i>464</i>&nbsp;     * @since 1.2
<i>465</i>&nbsp;     */
<i>466</i>&nbsp;    protected Object readObjectOverride()
<i>467</i>&nbsp;        throws IOException, ClassNotFoundException
<i>468</i>&nbsp;    {
<i>469</i>&nbsp;        return null;
<i>470</i>&nbsp;    }
<i>471</i>&nbsp;
<i>472</i>&nbsp;    /**
<i>473</i>&nbsp;     * Reads an &quot;unshared&quot; object from the ObjectInputStream.  This method is
<i>474</i>&nbsp;     * identical to readObject, except that it prevents subsequent calls to
<i>475</i>&nbsp;     * readObject and readUnshared from returning additional references to the
<i>476</i>&nbsp;     * deserialized instance obtained via this call.  Specifically:
<i>477</i>&nbsp;     * &lt;ul&gt;
<i>478</i>&nbsp;     *   &lt;li&gt;If readUnshared is called to deserialize a back-reference (the
<i>479</i>&nbsp;     *       stream representation of an object which has been written
<i>480</i>&nbsp;     *       previously to the stream), an ObjectStreamException will be
<i>481</i>&nbsp;     *       thrown.
<i>482</i>&nbsp;     *
<i>483</i>&nbsp;     *   &lt;li&gt;If readUnshared returns successfully, then any subsequent attempts
<i>484</i>&nbsp;     *       to deserialize back-references to the stream handle deserialized
<i>485</i>&nbsp;     *       by readUnshared will cause an ObjectStreamException to be thrown.
<i>486</i>&nbsp;     * &lt;/ul&gt;
<i>487</i>&nbsp;     * Deserializing an object via readUnshared invalidates the stream handle
<i>488</i>&nbsp;     * associated with the returned object.  Note that this in itself does not
<i>489</i>&nbsp;     * always guarantee that the reference returned by readUnshared is unique;
<i>490</i>&nbsp;     * the deserialized object may define a readResolve method which returns an
<i>491</i>&nbsp;     * object visible to other parties, or readUnshared may return a Class
<i>492</i>&nbsp;     * object or enum constant obtainable elsewhere in the stream or through
<i>493</i>&nbsp;     * external means. If the deserialized object defines a readResolve method
<i>494</i>&nbsp;     * and the invocation of that method returns an array, then readUnshared
<i>495</i>&nbsp;     * returns a shallow clone of that array; this guarantees that the returned
<i>496</i>&nbsp;     * array object is unique and cannot be obtained a second time from an
<i>497</i>&nbsp;     * invocation of readObject or readUnshared on the ObjectInputStream,
<i>498</i>&nbsp;     * even if the underlying data stream has been manipulated.
<i>499</i>&nbsp;     *
<i>500</i>&nbsp;     * &lt;p&gt;The serialization filter, when not {@code null}, is invoked for
<i>501</i>&nbsp;     * each object (regular or class) read to reconstruct the root object.
<i>502</i>&nbsp;     * See {@link #setObjectInputFilter(ObjectInputFilter) setObjectInputFilter} for details.
<i>503</i>&nbsp;     *
<i>504</i>&nbsp;     * &lt;p&gt;ObjectInputStream subclasses which override this method can only be
<i>505</i>&nbsp;     * constructed in security contexts possessing the
<i>506</i>&nbsp;     * &quot;enableSubclassImplementation&quot; SerializablePermission; any attempt to
<i>507</i>&nbsp;     * instantiate such a subclass without this permission will cause a
<i>508</i>&nbsp;     * SecurityException to be thrown.
<i>509</i>&nbsp;     *
<b class="nc"><i>510</i>&nbsp;     * @return  reference to deserialized object</b>
<i>511</i>&nbsp;     * @throws  ClassNotFoundException if class of an object to deserialize
<b class="nc"><i>512</i>&nbsp;     *          cannot be found</b>
<b class="nc"><i>513</i>&nbsp;     * @throws  StreamCorruptedException if control information in the stream</b>
<b class="nc"><i>514</i>&nbsp;     *          is inconsistent</b>
<b class="nc"><i>515</i>&nbsp;     * @throws  ObjectStreamException if object to deserialize has already</b>
<b class="nc"><i>516</i>&nbsp;     *          appeared in stream</b>
<i>517</i>&nbsp;     * @throws  OptionalDataException if primitive data is next in stream
<b class="nc"><i>518</i>&nbsp;     * @throws  IOException if an I/O error occurs during deserialization</b>
<b class="nc"><i>519</i>&nbsp;     * @since   1.4</b>
<i>520</i>&nbsp;     */
<b class="nc"><i>521</i>&nbsp;    public Object readUnshared() throws IOException, ClassNotFoundException {</b>
<i>522</i>&nbsp;        // if nested read, passHandle contains handle of enclosing object
<b class="nc"><i>523</i>&nbsp;        int outerHandle = passHandle;</b>
<b class="nc"><i>524</i>&nbsp;        try {</b>
<b class="nc"><i>525</i>&nbsp;            Object obj = readObject0(true);</b>
<i>526</i>&nbsp;            handles.markDependency(outerHandle, passHandle);
<i>527</i>&nbsp;            ClassNotFoundException ex = handles.lookupException(passHandle);
<i>528</i>&nbsp;            if (ex != null) {
<i>529</i>&nbsp;                throw ex;
<i>530</i>&nbsp;            }
<i>531</i>&nbsp;            if (depth == 0) {
<i>532</i>&nbsp;                vlist.doCallbacks();
<i>533</i>&nbsp;                freeze();
<i>534</i>&nbsp;            }
<i>535</i>&nbsp;            return obj;
<i>536</i>&nbsp;        } finally {
<i>537</i>&nbsp;            passHandle = outerHandle;
<i>538</i>&nbsp;            if (closed &amp;&amp; depth == 0) {
<i>539</i>&nbsp;                clear();
<i>540</i>&nbsp;            }
<i>541</i>&nbsp;        }
<i>542</i>&nbsp;    }
<i>543</i>&nbsp;
<i>544</i>&nbsp;    /**
<b class="nc"><i>545</i>&nbsp;     * Read the non-static and non-transient fields of the current class from</b>
<b class="nc"><i>546</i>&nbsp;     * this stream.  This may only be called from the readObject method of the</b>
<b class="nc"><i>547</i>&nbsp;     * class being deserialized. It will throw the NotActiveException if it is</b>
<i>548</i>&nbsp;     * called otherwise.
<b class="nc"><i>549</i>&nbsp;     *</b>
<b class="nc"><i>550</i>&nbsp;     * @throws  ClassNotFoundException if the class of a serialized object</b>
<b class="nc"><i>551</i>&nbsp;     *          could not be found.</b>
<b class="nc"><i>552</i>&nbsp;     * @throws  IOException if an I/O error occurs.</b>
<b class="nc"><i>553</i>&nbsp;     * @throws  NotActiveException if the stream is not currently reading</b>
<b class="nc"><i>554</i>&nbsp;     *          objects.</b>
<i>555</i>&nbsp;     */
<i>556</i>&nbsp;    public void defaultReadObject()
<i>557</i>&nbsp;        throws IOException, ClassNotFoundException
<i>558</i>&nbsp;    {
<i>559</i>&nbsp;        SerialCallbackContext ctx = curContext;
<b class="nc"><i>560</i>&nbsp;        if (ctx == null) {</b>
<i>561</i>&nbsp;            throw new NotActiveException(&quot;not in call to readObject&quot;);
<b class="nc"><i>562</i>&nbsp;        }</b>
<b class="nc"><i>563</i>&nbsp;        Object curObj = ctx.getObj();</b>
<b class="nc"><i>564</i>&nbsp;        ObjectStreamClass curDesc = ctx.getDesc();</b>
<i>565</i>&nbsp;        bin.setBlockDataMode(false);
<i>566</i>&nbsp;        FieldValues vals = defaultReadFields(curObj, curDesc);
<i>567</i>&nbsp;        if (curObj != null) {
<i>568</i>&nbsp;            defaultCheckFieldValues(curObj, curDesc, vals);
<i>569</i>&nbsp;            defaultSetFieldValues(curObj, curDesc, vals);
<i>570</i>&nbsp;        }
<i>571</i>&nbsp;        bin.setBlockDataMode(true);
<i>572</i>&nbsp;        if (!curDesc.hasWriteObjectData()) {
<i>573</i>&nbsp;            /*
<i>574</i>&nbsp;             * Fix for 4360508: since stream does not contain terminating
<i>575</i>&nbsp;             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
<i>576</i>&nbsp;             * knows to simulate end-of-custom-data behavior.
<i>577</i>&nbsp;             */
<i>578</i>&nbsp;            defaultDataEnd = true;
<i>579</i>&nbsp;        }
<i>580</i>&nbsp;        ClassNotFoundException ex = handles.lookupException(passHandle);
<i>581</i>&nbsp;        if (ex != null) {
<i>582</i>&nbsp;            throw ex;
<i>583</i>&nbsp;        }
<b class="nc"><i>584</i>&nbsp;    }</b>
<b class="nc"><i>585</i>&nbsp;</b>
<b class="nc"><i>586</i>&nbsp;    /**</b>
<i>587</i>&nbsp;     * Reads the persistent fields from the stream and makes them available by
<b class="nc"><i>588</i>&nbsp;     * name.</b>
<b class="nc"><i>589</i>&nbsp;     *</b>
<b class="nc"><i>590</i>&nbsp;     * @return  the &lt;code&gt;GetField&lt;/code&gt; object representing the persistent</b>
<b class="nc"><i>591</i>&nbsp;     *          fields of the object being deserialized</b>
<b class="nc"><i>592</i>&nbsp;     * @throws  ClassNotFoundException if the class of a serialized object</b>
<b class="nc"><i>593</i>&nbsp;     *          could not be found.</b>
<b class="nc"><i>594</i>&nbsp;     * @throws  IOException if an I/O error occurs.</b>
<i>595</i>&nbsp;     * @throws  NotActiveException if the stream is not currently reading
<i>596</i>&nbsp;     *          objects.
<i>597</i>&nbsp;     * @since 1.2
<i>598</i>&nbsp;     */
<i>599</i>&nbsp;    public ObjectInputStream.GetField readFields()
<b class="nc"><i>600</i>&nbsp;        throws IOException, ClassNotFoundException</b>
<i>601</i>&nbsp;    {
<i>602</i>&nbsp;        SerialCallbackContext ctx = curContext;
<b class="nc"><i>603</i>&nbsp;        if (ctx == null) {</b>
<i>604</i>&nbsp;            throw new NotActiveException(&quot;not in call to readObject&quot;);
<i>605</i>&nbsp;        }
<i>606</i>&nbsp;        ctx.checkAndSetUsed();
<i>607</i>&nbsp;        ObjectStreamClass curDesc = ctx.getDesc();
<i>608</i>&nbsp;        bin.setBlockDataMode(false);
<i>609</i>&nbsp;        GetFieldImpl getField = new GetFieldImpl(curDesc);
<i>610</i>&nbsp;        getField.readFields();
<i>611</i>&nbsp;        bin.setBlockDataMode(true);
<i>612</i>&nbsp;        if (!curDesc.hasWriteObjectData()) {
<i>613</i>&nbsp;            /*
<i>614</i>&nbsp;             * Fix for 4360508: since stream does not contain terminating
<i>615</i>&nbsp;             * TC_ENDBLOCKDATA tag, set flag so that reading code elsewhere
<i>616</i>&nbsp;             * knows to simulate end-of-custom-data behavior.
<i>617</i>&nbsp;             */
<i>618</i>&nbsp;            defaultDataEnd = true;
<i>619</i>&nbsp;        }
<i>620</i>&nbsp;
<i>621</i>&nbsp;        return getField;
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;
<i>624</i>&nbsp;    /**
<b class="nc"><i>625</i>&nbsp;     * Register an object to be validated before the graph is returned.  While</b>
<b class="nc"><i>626</i>&nbsp;     * similar to resolveObject these validations are called after the entire</b>
<i>627</i>&nbsp;     * graph has been reconstituted.  Typically, a readObject method will
<b class="nc"><i>628</i>&nbsp;     * register the object with the stream so that when all of the objects are</b>
<i>629</i>&nbsp;     * restored a final set of validations can be performed.
<i>630</i>&nbsp;     *
<i>631</i>&nbsp;     * @param   obj the object to receive the validation callback.
<i>632</i>&nbsp;     * @param   prio controls the order of callbacks;zero is a good default.
<i>633</i>&nbsp;     *          Use higher numbers to be called back earlier, lower numbers for
<i>634</i>&nbsp;     *          later callbacks. Within a priority, callbacks are processed in
<i>635</i>&nbsp;     *          no particular order.
<i>636</i>&nbsp;     * @throws  NotActiveException The stream is not currently reading objects
<i>637</i>&nbsp;     *          so it is invalid to register a callback.
<i>638</i>&nbsp;     * @throws  InvalidObjectException The validation object is null.
<i>639</i>&nbsp;     */
<i>640</i>&nbsp;    public void registerValidation(ObjectInputValidation obj, int prio)
<i>641</i>&nbsp;        throws NotActiveException, InvalidObjectException
<i>642</i>&nbsp;    {
<i>643</i>&nbsp;        if (depth == 0) {
<i>644</i>&nbsp;            throw new NotActiveException(&quot;stream inactive&quot;);
<i>645</i>&nbsp;        }
<i>646</i>&nbsp;        vlist.register(obj, prio);
<i>647</i>&nbsp;    }
<i>648</i>&nbsp;
<i>649</i>&nbsp;    /**
<i>650</i>&nbsp;     * Load the local class equivalent of the specified stream class
<i>651</i>&nbsp;     * description.  Subclasses may implement this method to allow classes to
<i>652</i>&nbsp;     * be fetched from an alternate source.
<i>653</i>&nbsp;     *
<i>654</i>&nbsp;     * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
<i>655</i>&nbsp;     * &lt;code&gt;annotateClass&lt;/code&gt;.  This method will be invoked only once for
<i>656</i>&nbsp;     * each unique class in the stream.  This method can be implemented by
<i>657</i>&nbsp;     * subclasses to use an alternate loading mechanism but must return a
<i>658</i>&nbsp;     * &lt;code&gt;Class&lt;/code&gt; object. Once returned, if the class is not an array
<i>659</i>&nbsp;     * class, its serialVersionUID is compared to the serialVersionUID of the
<i>660</i>&nbsp;     * serialized class, and if there is a mismatch, the deserialization fails
<i>661</i>&nbsp;     * and an {@link InvalidClassException} is thrown.
<i>662</i>&nbsp;     *
<i>663</i>&nbsp;     * &lt;p&gt;The default implementation of this method in
<i>664</i>&nbsp;     * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
<i>665</i>&nbsp;     * &lt;pre&gt;
<i>666</i>&nbsp;     *     Class.forName(desc.getName(), false, loader)
<i>667</i>&nbsp;     * &lt;/pre&gt;
<i>668</i>&nbsp;     * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current
<i>669</i>&nbsp;     * thread&#39;s stack (starting from the currently executing method) that is
<i>670</i>&nbsp;     * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<i>671</i>&nbsp;     * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the
<i>672</i>&nbsp;     * &lt;em&gt;platform class loader&lt;/em&gt;. If this call results in a
<i>673</i>&nbsp;     * &lt;code&gt;ClassNotFoundException&lt;/code&gt; and the name of the passed
<i>674</i>&nbsp;     * &lt;code&gt;ObjectStreamClass&lt;/code&gt; instance is the Java language keyword
<b class="nc"><i>675</i>&nbsp;     * for a primitive type or void, then the &lt;code&gt;Class&lt;/code&gt; object</b>
<i>676</i>&nbsp;     * representing that primitive type or void will be returned
<b class="nc"><i>677</i>&nbsp;     * (e.g., an &lt;code&gt;ObjectStreamClass&lt;/code&gt; with the name</b>
<b class="nc"><i>678</i>&nbsp;     * &lt;code&gt;&quot;int&quot;&lt;/code&gt; will be resolved to &lt;code&gt;Integer.TYPE&lt;/code&gt;).</b>
<b class="nc"><i>679</i>&nbsp;     * Otherwise, the &lt;code&gt;ClassNotFoundException&lt;/code&gt; will be thrown to</b>
<b class="nc"><i>680</i>&nbsp;     * the caller of this method.</b>
<b class="nc"><i>681</i>&nbsp;     *</b>
<i>682</i>&nbsp;     * @param   desc an instance of class &lt;code&gt;ObjectStreamClass&lt;/code&gt;
<b class="nc"><i>683</i>&nbsp;     * @return  a &lt;code&gt;Class&lt;/code&gt; object corresponding to &lt;code&gt;desc&lt;/code&gt;</b>
<i>684</i>&nbsp;     * @throws  IOException any of the usual Input/Output exceptions.
<i>685</i>&nbsp;     * @throws  ClassNotFoundException if class of a serialized object cannot
<i>686</i>&nbsp;     *          be found.
<i>687</i>&nbsp;     */
<i>688</i>&nbsp;    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc)
<i>689</i>&nbsp;        throws IOException, ClassNotFoundException
<i>690</i>&nbsp;    {
<i>691</i>&nbsp;        String name = desc.getName();
<i>692</i>&nbsp;        try {
<i>693</i>&nbsp;            return Class.forName(name, false, latestUserDefinedLoader());
<i>694</i>&nbsp;        } catch (ClassNotFoundException ex) {
<i>695</i>&nbsp;            Class&lt;?&gt; cl = primClasses.get(name);
<i>696</i>&nbsp;            if (cl != null) {
<i>697</i>&nbsp;                return cl;
<i>698</i>&nbsp;            } else {
<i>699</i>&nbsp;                throw ex;
<i>700</i>&nbsp;            }
<i>701</i>&nbsp;        }
<i>702</i>&nbsp;    }
<i>703</i>&nbsp;
<i>704</i>&nbsp;    /**
<i>705</i>&nbsp;     * Returns a proxy class that implements the interfaces named in a proxy
<i>706</i>&nbsp;     * class descriptor; subclasses may implement this method to read custom
<i>707</i>&nbsp;     * data from the stream along with the descriptors for dynamic proxy
<i>708</i>&nbsp;     * classes, allowing them to use an alternate loading mechanism for the
<i>709</i>&nbsp;     * interfaces and the proxy class.
<i>710</i>&nbsp;     *
<i>711</i>&nbsp;     * &lt;p&gt;This method is called exactly once for each unique proxy class
<i>712</i>&nbsp;     * descriptor in the stream.
<i>713</i>&nbsp;     *
<i>714</i>&nbsp;     * &lt;p&gt;The corresponding method in &lt;code&gt;ObjectOutputStream&lt;/code&gt; is
<i>715</i>&nbsp;     * &lt;code&gt;annotateProxyClass&lt;/code&gt;.  For a given subclass of
<i>716</i>&nbsp;     * &lt;code&gt;ObjectInputStream&lt;/code&gt; that overrides this method, the
<i>717</i>&nbsp;     * &lt;code&gt;annotateProxyClass&lt;/code&gt; method in the corresponding subclass of
<i>718</i>&nbsp;     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; must write any data or objects read by
<i>719</i>&nbsp;     * this method.
<i>720</i>&nbsp;     *
<i>721</i>&nbsp;     * &lt;p&gt;The default implementation of this method in
<i>722</i>&nbsp;     * &lt;code&gt;ObjectInputStream&lt;/code&gt; returns the result of calling
<i>723</i>&nbsp;     * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; with the list of &lt;code&gt;Class&lt;/code&gt;
<i>724</i>&nbsp;     * objects for the interfaces that are named in the &lt;code&gt;interfaces&lt;/code&gt;
<i>725</i>&nbsp;     * parameter.  The &lt;code&gt;Class&lt;/code&gt; object for each interface name
<i>726</i>&nbsp;     * &lt;code&gt;i&lt;/code&gt; is the value returned by calling
<i>727</i>&nbsp;     * &lt;pre&gt;
<i>728</i>&nbsp;     *     Class.forName(i, false, loader)
<i>729</i>&nbsp;     * &lt;/pre&gt;
<i>730</i>&nbsp;     * where &lt;code&gt;loader&lt;/code&gt; is the first class loader on the current
<i>731</i>&nbsp;     * thread&#39;s stack (starting from the currently executing method) that is
<i>732</i>&nbsp;     * neither the {@linkplain ClassLoader#getPlatformClassLoader() platform
<i>733</i>&nbsp;     * class loader} nor its ancestor; otherwise, &lt;code&gt;loader&lt;/code&gt; is the
<i>734</i>&nbsp;     * &lt;em&gt;platform class loader&lt;/em&gt;.
<i>735</i>&nbsp;     * Unless any of the resolved interfaces are non-public, this same value
<i>736</i>&nbsp;     * of &lt;code&gt;loader&lt;/code&gt; is also the class loader passed to
<i>737</i>&nbsp;     * &lt;code&gt;Proxy.getProxyClass&lt;/code&gt;; if non-public interfaces are present,
<i>738</i>&nbsp;     * their class loader is passed instead (if more than one non-public
<i>739</i>&nbsp;     * interface class loader is encountered, an
<i>740</i>&nbsp;     * &lt;code&gt;IllegalAccessError&lt;/code&gt; is thrown).
<i>741</i>&nbsp;     * If &lt;code&gt;Proxy.getProxyClass&lt;/code&gt; throws an
<b class="nc"><i>742</i>&nbsp;     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;, &lt;code&gt;resolveProxyClass&lt;/code&gt;</b>
<b class="nc"><i>743</i>&nbsp;     * will throw a &lt;code&gt;ClassNotFoundException&lt;/code&gt; containing the</b>
<b class="nc"><i>744</i>&nbsp;     * &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</b>
<i>745</i>&nbsp;     *
<i>746</i>&nbsp;     * @param interfaces the list of interface names that were
<b class="nc"><i>747</i>&nbsp;     *                deserialized in the proxy class descriptor</b>
<b class="nc"><i>748</i>&nbsp;     * @return  a proxy class for the specified interfaces</b>
<b class="nc"><i>749</i>&nbsp;     * @throws        IOException any exception thrown by the underlying</b>
<b class="nc"><i>750</i>&nbsp;     *                &lt;code&gt;InputStream&lt;/code&gt;</b>
<b class="nc"><i>751</i>&nbsp;     * @throws        ClassNotFoundException if the proxy class or any of the</b>
<b class="nc"><i>752</i>&nbsp;     *                named interfaces could not be found</b>
<b class="nc"><i>753</i>&nbsp;     * @see ObjectOutputStream#annotateProxyClass(Class)</b>
<i>754</i>&nbsp;     * @since 1.3
<i>755</i>&nbsp;     */
<i>756</i>&nbsp;    protected Class&lt;?&gt; resolveProxyClass(String[] interfaces)
<b class="nc"><i>757</i>&nbsp;        throws IOException, ClassNotFoundException</b>
<b class="nc"><i>758</i>&nbsp;    {</b>
<i>759</i>&nbsp;        ClassLoader latestLoader = latestUserDefinedLoader();
<i>760</i>&nbsp;        ClassLoader nonPublicLoader = null;
<b class="nc"><i>761</i>&nbsp;        boolean hasNonPublicInterface = false;</b>
<i>762</i>&nbsp;
<i>763</i>&nbsp;        // define proxy in class loader of non-public interface(s), if any
<b class="nc"><i>764</i>&nbsp;        Class&lt;?&gt;[] classObjs = new Class&lt;?&gt;[interfaces.length];</b>
<i>765</i>&nbsp;        for (int i = 0; i &lt; interfaces.length; i++) {
<i>766</i>&nbsp;            Class&lt;?&gt; cl = Class.forName(interfaces[i], false, latestLoader);
<b class="nc"><i>767</i>&nbsp;            if ((cl.getModifiers() &amp; Modifier.PUBLIC) == 0) {</b>
<b class="nc"><i>768</i>&nbsp;                if (hasNonPublicInterface) {</b>
<i>769</i>&nbsp;                    if (nonPublicLoader != cl.getClassLoader()) {
<i>770</i>&nbsp;                        throw new IllegalAccessError(
<i>771</i>&nbsp;                            &quot;conflicting non-public interface class loaders&quot;);
<i>772</i>&nbsp;                    }
<i>773</i>&nbsp;                } else {
<i>774</i>&nbsp;                    nonPublicLoader = cl.getClassLoader();
<i>775</i>&nbsp;                    hasNonPublicInterface = true;
<i>776</i>&nbsp;                }
<i>777</i>&nbsp;            }
<i>778</i>&nbsp;            classObjs[i] = cl;
<i>779</i>&nbsp;        }
<i>780</i>&nbsp;        try {
<i>781</i>&nbsp;            @SuppressWarnings(&quot;deprecation&quot;)
<i>782</i>&nbsp;            Class&lt;?&gt; proxyClass = Proxy.getProxyClass(
<i>783</i>&nbsp;                hasNonPublicInterface ? nonPublicLoader : latestLoader,
<i>784</i>&nbsp;                classObjs);
<i>785</i>&nbsp;            return proxyClass;
<i>786</i>&nbsp;        } catch (IllegalArgumentException e) {
<i>787</i>&nbsp;            throw new ClassNotFoundException(null, e);
<i>788</i>&nbsp;        }
<i>789</i>&nbsp;    }
<i>790</i>&nbsp;
<i>791</i>&nbsp;    /**
<i>792</i>&nbsp;     * This method will allow trusted subclasses of ObjectInputStream to
<i>793</i>&nbsp;     * substitute one object for another during deserialization. Replacing
<i>794</i>&nbsp;     * objects is disabled until enableResolveObject is called. The
<i>795</i>&nbsp;     * enableResolveObject method checks that the stream requesting to resolve
<i>796</i>&nbsp;     * object can be trusted. Every reference to serializable objects is passed
<i>797</i>&nbsp;     * to resolveObject.  To insure that the private state of objects is not
<i>798</i>&nbsp;     * unintentionally exposed only trusted streams may use resolveObject.
<i>799</i>&nbsp;     *
<b class="nc"><i>800</i>&nbsp;     * &lt;p&gt;This method is called after an object has been read but before it is</b>
<i>801</i>&nbsp;     * returned from readObject.  The default resolveObject method just returns
<i>802</i>&nbsp;     * the same object.
<i>803</i>&nbsp;     *
<i>804</i>&nbsp;     * &lt;p&gt;When a subclass is replacing objects it must insure that the
<i>805</i>&nbsp;     * substituted object is compatible with every field where the reference
<i>806</i>&nbsp;     * will be stored.  Objects whose type is not a subclass of the type of the
<i>807</i>&nbsp;     * field or array element abort the serialization by raising an exception
<i>808</i>&nbsp;     * and the object is not be stored.
<i>809</i>&nbsp;     *
<i>810</i>&nbsp;     * &lt;p&gt;This method is called only once when each object is first
<i>811</i>&nbsp;     * encountered.  All subsequent references to the object will be redirected
<i>812</i>&nbsp;     * to the new object.
<i>813</i>&nbsp;     *
<i>814</i>&nbsp;     * @param   obj object to be substituted
<i>815</i>&nbsp;     * @return  the substituted object
<i>816</i>&nbsp;     * @throws  IOException Any of the usual Input/Output exceptions.
<i>817</i>&nbsp;     */
<i>818</i>&nbsp;    protected Object resolveObject(Object obj) throws IOException {
<i>819</i>&nbsp;        return obj;
<i>820</i>&nbsp;    }
<i>821</i>&nbsp;
<i>822</i>&nbsp;    /**
<i>823</i>&nbsp;     * Enables the stream to do replacement of objects read from the stream. When
<i>824</i>&nbsp;     * enabled, the {@link #resolveObject} method is called for every object being
<i>825</i>&nbsp;     * deserialized.
<i>826</i>&nbsp;     *
<b class="nc"><i>827</i>&nbsp;     * &lt;p&gt;If object replacement is currently not enabled, and</b>
<b class="nc"><i>828</i>&nbsp;     * {@code enable} is true, and there is a security manager installed,</b>
<i>829</i>&nbsp;     * this method first calls the security manager&#39;s
<b class="nc"><i>830</i>&nbsp;     * {@code checkPermission} method with the</b>
<b class="nc"><i>831</i>&nbsp;     * {@code SerializablePermission(&quot;enableSubstitution&quot;)} permission to</b>
<b class="nc"><i>832</i>&nbsp;     * ensure that the caller is permitted to enable the stream to do replacement</b>
<b class="nc"><i>833</i>&nbsp;     * of objects read from the stream.</b>
<i>834</i>&nbsp;     *
<i>835</i>&nbsp;     * @param   enable true for enabling use of {@code resolveObject} for
<b class="nc"><i>836</i>&nbsp;     *          every object being deserialized</b>
<b class="nc"><i>837</i>&nbsp;     * @return  the previous setting before this method was invoked</b>
<i>838</i>&nbsp;     * @throws  SecurityException if a security manager exists and its
<i>839</i>&nbsp;     *          {@code checkPermission} method denies enabling the stream
<i>840</i>&nbsp;     *          to do replacement of objects read from the stream.
<i>841</i>&nbsp;     * @see SecurityManager#checkPermission
<i>842</i>&nbsp;     * @see java.io.SerializablePermission
<i>843</i>&nbsp;     */
<i>844</i>&nbsp;    protected boolean enableResolveObject(boolean enable)
<i>845</i>&nbsp;        throws SecurityException
<i>846</i>&nbsp;    {
<i>847</i>&nbsp;        if (enable == enableResolve) {
<i>848</i>&nbsp;            return enable;
<i>849</i>&nbsp;        }
<i>850</i>&nbsp;        if (enable) {
<i>851</i>&nbsp;            SecurityManager sm = System.getSecurityManager();
<i>852</i>&nbsp;            if (sm != null) {
<b class="nc"><i>853</i>&nbsp;                sm.checkPermission(SUBSTITUTION_PERMISSION);</b>
<b class="nc"><i>854</i>&nbsp;            }</b>
<b class="nc"><i>855</i>&nbsp;        }</b>
<b class="nc"><i>856</i>&nbsp;        enableResolve = enable;</b>
<b class="nc"><i>857</i>&nbsp;        return !enableResolve;</b>
<i>858</i>&nbsp;    }
<i>859</i>&nbsp;
<i>860</i>&nbsp;    /**
<i>861</i>&nbsp;     * The readStreamHeader method is provided to allow subclasses to read and
<i>862</i>&nbsp;     * verify their own stream headers. It reads and verifies the magic number
<i>863</i>&nbsp;     * and version number.
<i>864</i>&nbsp;     *
<i>865</i>&nbsp;     * @throws  IOException if there are I/O errors while reading from the
<i>866</i>&nbsp;     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>867</i>&nbsp;     * @throws  StreamCorruptedException if control information in the stream
<i>868</i>&nbsp;     *          is inconsistent
<i>869</i>&nbsp;     */
<i>870</i>&nbsp;    protected void readStreamHeader()
<i>871</i>&nbsp;        throws IOException, StreamCorruptedException
<i>872</i>&nbsp;    {
<i>873</i>&nbsp;        short s0 = bin.readShort();
<i>874</i>&nbsp;        short s1 = bin.readShort();
<i>875</i>&nbsp;        if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {
<i>876</i>&nbsp;            throw new StreamCorruptedException(
<i>877</i>&nbsp;                String.format(&quot;invalid stream header: %04X%04X&quot;, s0, s1));
<i>878</i>&nbsp;        }
<i>879</i>&nbsp;    }
<i>880</i>&nbsp;
<b class="nc"><i>881</i>&nbsp;    /**</b>
<b class="nc"><i>882</i>&nbsp;     * Read a class descriptor from the serialization stream.  This method is</b>
<b class="nc"><i>883</i>&nbsp;     * called when the ObjectInputStream expects a class descriptor as the next</b>
<i>884</i>&nbsp;     * item in the serialization stream.  Subclasses of ObjectInputStream may
<i>885</i>&nbsp;     * override this method to read in class descriptors that have been written
<i>886</i>&nbsp;     * in non-standard formats (by subclasses of ObjectOutputStream which have
<i>887</i>&nbsp;     * overridden the &lt;code&gt;writeClassDescriptor&lt;/code&gt; method).  By default,
<i>888</i>&nbsp;     * this method reads class descriptors according to the format defined in
<i>889</i>&nbsp;     * the Object Serialization specification.
<i>890</i>&nbsp;     *
<i>891</i>&nbsp;     * @return  the class descriptor read
<i>892</i>&nbsp;     * @throws  IOException If an I/O error has occurred.
<b class="nc"><i>893</i>&nbsp;     * @throws  ClassNotFoundException If the Class of a serialized object used</b>
<i>894</i>&nbsp;     *          in the class descriptor representation cannot be found
<i>895</i>&nbsp;     * @see java.io.ObjectOutputStream#writeClassDescriptor(java.io.ObjectStreamClass)
<i>896</i>&nbsp;     * @since 1.3
<i>897</i>&nbsp;     */
<i>898</i>&nbsp;    protected ObjectStreamClass readClassDescriptor()
<i>899</i>&nbsp;        throws IOException, ClassNotFoundException
<i>900</i>&nbsp;    {
<i>901</i>&nbsp;        ObjectStreamClass desc = new ObjectStreamClass();
<i>902</i>&nbsp;        desc.readNonProxy(this);
<i>903</i>&nbsp;        return desc;
<i>904</i>&nbsp;    }
<i>905</i>&nbsp;
<i>906</i>&nbsp;    /**
<i>907</i>&nbsp;     * Reads a byte of data. This method will block if no input is available.
<i>908</i>&nbsp;     *
<i>909</i>&nbsp;     * @return  the byte read, or -1 if the end of the stream is reached.
<b class="nc"><i>910</i>&nbsp;     * @throws  IOException If an I/O error has occurred.</b>
<b class="nc"><i>911</i>&nbsp;     */</b>
<i>912</i>&nbsp;    public int read() throws IOException {
<b class="nc"><i>913</i>&nbsp;        return bin.read();</b>
<b class="nc"><i>914</i>&nbsp;    }</b>
<b class="nc"><i>915</i>&nbsp;</b>
<i>916</i>&nbsp;    /**
<b class="nc"><i>917</i>&nbsp;     * Reads into an array of bytes.  This method will block until some input</b>
<i>918</i>&nbsp;     * is available. Consider using java.io.DataInputStream.readFully to read
<i>919</i>&nbsp;     * exactly &#39;length&#39; bytes.
<i>920</i>&nbsp;     *
<i>921</i>&nbsp;     * @param   buf the buffer into which the data is read
<i>922</i>&nbsp;     * @param   off the start offset in the destination array {@code buf}
<i>923</i>&nbsp;     * @param   len the maximum number of bytes read
<i>924</i>&nbsp;     * @return  the actual number of bytes read, -1 is returned when the end of
<i>925</i>&nbsp;     *          the stream is reached.
<i>926</i>&nbsp;     * @throws  NullPointerException if {@code buf} is {@code null}.
<i>927</i>&nbsp;     * @throws  IndexOutOfBoundsException if {@code off} is negative,
<b class="nc"><i>928</i>&nbsp;     *          {@code len} is negative, or {@code len} is greater than</b>
<i>929</i>&nbsp;     *          {@code buf.length - off}.
<i>930</i>&nbsp;     * @throws  IOException If an I/O error has occurred.
<i>931</i>&nbsp;     * @see java.io.DataInputStream#readFully(byte[],int,int)
<i>932</i>&nbsp;     */
<i>933</i>&nbsp;    public int read(byte[] buf, int off, int len) throws IOException {
<i>934</i>&nbsp;        if (buf == null) {
<i>935</i>&nbsp;            throw new NullPointerException();
<i>936</i>&nbsp;        }
<i>937</i>&nbsp;        int endoff = off + len;
<i>938</i>&nbsp;        if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
<i>939</i>&nbsp;            throw new IndexOutOfBoundsException();
<i>940</i>&nbsp;        }
<i>941</i>&nbsp;        return bin.read(buf, off, len, false);
<b class="nc"><i>942</i>&nbsp;    }</b>
<b class="nc"><i>943</i>&nbsp;</b>
<b class="nc"><i>944</i>&nbsp;    /**</b>
<i>945</i>&nbsp;     * Returns the number of bytes that can be read without blocking.
<b class="nc"><i>946</i>&nbsp;     *</b>
<i>947</i>&nbsp;     * @return  the number of available bytes.
<i>948</i>&nbsp;     * @throws  IOException if there are I/O errors while reading from the
<i>949</i>&nbsp;     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>950</i>&nbsp;     */
<i>951</i>&nbsp;    public int available() throws IOException {
<i>952</i>&nbsp;        return bin.available();
<i>953</i>&nbsp;    }
<i>954</i>&nbsp;
<i>955</i>&nbsp;    /**
<i>956</i>&nbsp;     * Closes the input stream. Must be called to release any resources
<b class="nc"><i>957</i>&nbsp;     * associated with the stream.</b>
<i>958</i>&nbsp;     *
<i>959</i>&nbsp;     * @throws  IOException If an I/O error has occurred.
<i>960</i>&nbsp;     */
<i>961</i>&nbsp;    public void close() throws IOException {
<i>962</i>&nbsp;        /*
<i>963</i>&nbsp;         * Even if stream already closed, propagate redundant close to
<i>964</i>&nbsp;         * underlying stream to stay consistent with previous implementations.
<i>965</i>&nbsp;         */
<i>966</i>&nbsp;        closed = true;
<i>967</i>&nbsp;        if (depth == 0) {
<b class="nc"><i>968</i>&nbsp;            clear();</b>
<i>969</i>&nbsp;        }
<i>970</i>&nbsp;        bin.close();
<i>971</i>&nbsp;    }
<i>972</i>&nbsp;
<i>973</i>&nbsp;    /**
<i>974</i>&nbsp;     * Reads in a boolean.
<i>975</i>&nbsp;     *
<i>976</i>&nbsp;     * @return  the boolean read.
<i>977</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>978</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>979</i>&nbsp;     */</b>
<i>980</i>&nbsp;    public boolean readBoolean() throws IOException {
<i>981</i>&nbsp;        return bin.readBoolean();
<i>982</i>&nbsp;    }
<i>983</i>&nbsp;
<i>984</i>&nbsp;    /**
<i>985</i>&nbsp;     * Reads an 8 bit byte.
<i>986</i>&nbsp;     *
<i>987</i>&nbsp;     * @return  the 8 bit byte read.
<i>988</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>989</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>990</i>&nbsp;     */</b>
<i>991</i>&nbsp;    public byte readByte() throws IOException  {
<i>992</i>&nbsp;        return bin.readByte();
<i>993</i>&nbsp;    }
<i>994</i>&nbsp;
<i>995</i>&nbsp;    /**
<i>996</i>&nbsp;     * Reads an unsigned 8 bit byte.
<i>997</i>&nbsp;     *
<i>998</i>&nbsp;     * @return  the 8 bit byte read.
<i>999</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1000</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1001</i>&nbsp;     */</b>
<i>1002</i>&nbsp;    public int readUnsignedByte()  throws IOException {
<i>1003</i>&nbsp;        return bin.readUnsignedByte();
<i>1004</i>&nbsp;    }
<i>1005</i>&nbsp;
<i>1006</i>&nbsp;    /**
<i>1007</i>&nbsp;     * Reads a 16 bit char.
<i>1008</i>&nbsp;     *
<i>1009</i>&nbsp;     * @return  the 16 bit char read.
<i>1010</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1011</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1012</i>&nbsp;     */</b>
<i>1013</i>&nbsp;    public char readChar()  throws IOException {
<i>1014</i>&nbsp;        return bin.readChar();
<i>1015</i>&nbsp;    }
<i>1016</i>&nbsp;
<i>1017</i>&nbsp;    /**
<i>1018</i>&nbsp;     * Reads a 16 bit short.
<i>1019</i>&nbsp;     *
<i>1020</i>&nbsp;     * @return  the 16 bit short read.
<i>1021</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1022</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1023</i>&nbsp;     */</b>
<i>1024</i>&nbsp;    public short readShort()  throws IOException {
<i>1025</i>&nbsp;        return bin.readShort();
<i>1026</i>&nbsp;    }
<i>1027</i>&nbsp;
<i>1028</i>&nbsp;    /**
<i>1029</i>&nbsp;     * Reads an unsigned 16 bit short.
<i>1030</i>&nbsp;     *
<i>1031</i>&nbsp;     * @return  the 16 bit short read.
<i>1032</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1033</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1034</i>&nbsp;     */</b>
<i>1035</i>&nbsp;    public int readUnsignedShort() throws IOException {
<i>1036</i>&nbsp;        return bin.readUnsignedShort();
<i>1037</i>&nbsp;    }
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    /**
<i>1040</i>&nbsp;     * Reads a 32 bit int.
<i>1041</i>&nbsp;     *
<i>1042</i>&nbsp;     * @return  the 32 bit integer read.
<i>1043</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1044</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1045</i>&nbsp;     */</b>
<i>1046</i>&nbsp;    public int readInt()  throws IOException {
<i>1047</i>&nbsp;        return bin.readInt();
<i>1048</i>&nbsp;    }
<i>1049</i>&nbsp;
<i>1050</i>&nbsp;    /**
<i>1051</i>&nbsp;     * Reads a 64 bit long.
<i>1052</i>&nbsp;     *
<i>1053</i>&nbsp;     * @return  the read 64 bit long.
<i>1054</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1055</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1056</i>&nbsp;     */</b>
<i>1057</i>&nbsp;    public long readLong()  throws IOException {
<i>1058</i>&nbsp;        return bin.readLong();
<i>1059</i>&nbsp;    }
<i>1060</i>&nbsp;
<i>1061</i>&nbsp;    /**
<i>1062</i>&nbsp;     * Reads a 32 bit float.
<i>1063</i>&nbsp;     *
<i>1064</i>&nbsp;     * @return  the 32 bit float read.
<i>1065</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1066</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<b class="nc"><i>1067</i>&nbsp;     */</b>
<i>1068</i>&nbsp;    public float readFloat() throws IOException {
<i>1069</i>&nbsp;        return bin.readFloat();
<i>1070</i>&nbsp;    }
<i>1071</i>&nbsp;
<i>1072</i>&nbsp;    /**
<i>1073</i>&nbsp;     * Reads a 64 bit double.
<i>1074</i>&nbsp;     *
<i>1075</i>&nbsp;     * @return  the 64 bit double read.
<i>1076</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1077</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<i>1078</i>&nbsp;     */
<i>1079</i>&nbsp;    public double readDouble() throws IOException {
<b class="nc"><i>1080</i>&nbsp;        return bin.readDouble();</b>
<b class="nc"><i>1081</i>&nbsp;    }</b>
<b class="nc"><i>1082</i>&nbsp;</b>
<i>1083</i>&nbsp;    /**
<b class="nc"><i>1084</i>&nbsp;     * Reads bytes, blocking until all bytes are read.</b>
<i>1085</i>&nbsp;     *
<i>1086</i>&nbsp;     * @param   buf the buffer into which the data is read
<i>1087</i>&nbsp;     * @throws  NullPointerException If {@code buf} is {@code null}.
<i>1088</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1089</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<i>1090</i>&nbsp;     */
<i>1091</i>&nbsp;    public void readFully(byte[] buf) throws IOException {
<i>1092</i>&nbsp;        bin.readFully(buf, 0, buf.length, false);
<i>1093</i>&nbsp;    }
<i>1094</i>&nbsp;
<b class="nc"><i>1095</i>&nbsp;    /**</b>
<i>1096</i>&nbsp;     * Reads bytes, blocking until all bytes are read.
<i>1097</i>&nbsp;     *
<i>1098</i>&nbsp;     * @param   buf the buffer into which the data is read
<i>1099</i>&nbsp;     * @param   off the start offset into the data array {@code buf}
<i>1100</i>&nbsp;     * @param   len the maximum number of bytes to read
<i>1101</i>&nbsp;     * @throws  NullPointerException If {@code buf} is {@code null}.
<i>1102</i>&nbsp;     * @throws  IndexOutOfBoundsException If {@code off} is negative,
<i>1103</i>&nbsp;     *          {@code len} is negative, or {@code len} is greater than
<i>1104</i>&nbsp;     *          {@code buf.length - off}.
<i>1105</i>&nbsp;     * @throws  EOFException If end of file is reached.
<i>1106</i>&nbsp;     * @throws  IOException If other I/O error has occurred.
<i>1107</i>&nbsp;     */
<i>1108</i>&nbsp;    public void readFully(byte[] buf, int off, int len) throws IOException {
<b class="nc"><i>1109</i>&nbsp;        int endoff = off + len;</b>
<i>1110</i>&nbsp;        if (off &lt; 0 || len &lt; 0 || endoff &gt; buf.length || endoff &lt; 0) {
<i>1111</i>&nbsp;            throw new IndexOutOfBoundsException();
<i>1112</i>&nbsp;        }
<i>1113</i>&nbsp;        bin.readFully(buf, off, len, false);
<i>1114</i>&nbsp;    }
<i>1115</i>&nbsp;
<i>1116</i>&nbsp;    /**
<i>1117</i>&nbsp;     * Skips bytes.
<i>1118</i>&nbsp;     *
<i>1119</i>&nbsp;     * @param   len the number of bytes to be skipped
<i>1120</i>&nbsp;     * @return  the actual number of bytes skipped.
<i>1121</i>&nbsp;     * @throws  IOException If an I/O error has occurred.
<i>1122</i>&nbsp;     */
<i>1123</i>&nbsp;    public int skipBytes(int len) throws IOException {
<b class="nc"><i>1124</i>&nbsp;        return bin.skipBytes(len);</b>
<i>1125</i>&nbsp;    }
<i>1126</i>&nbsp;
<i>1127</i>&nbsp;    /**
<i>1128</i>&nbsp;     * Reads in a line that has been terminated by a \n, \r, \r\n or EOF.
<i>1129</i>&nbsp;     *
<i>1130</i>&nbsp;     * @return  a String copy of the line.
<i>1131</i>&nbsp;     * @throws  IOException if there are I/O errors while reading from the
<i>1132</i>&nbsp;     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1133</i>&nbsp;     * @deprecated This method does not properly convert bytes to characters.
<i>1134</i>&nbsp;     *          see DataInputStream for the details and alternatives.
<i>1135</i>&nbsp;     */
<i>1136</i>&nbsp;    @Deprecated
<b class="nc"><i>1137</i>&nbsp;    public String readLine() throws IOException {</b>
<i>1138</i>&nbsp;        return bin.readLine();
<i>1139</i>&nbsp;    }
<i>1140</i>&nbsp;
<i>1141</i>&nbsp;    /**
<i>1142</i>&nbsp;     * Reads a String in
<i>1143</i>&nbsp;     * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;
<i>1144</i>&nbsp;     * format.
<i>1145</i>&nbsp;     *
<i>1146</i>&nbsp;     * @return  the String.
<i>1147</i>&nbsp;     * @throws  IOException if there are I/O errors while reading from the
<i>1148</i>&nbsp;     *          underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1149</i>&nbsp;     * @throws  UTFDataFormatException if read bytes do not represent a valid
<i>1150</i>&nbsp;     *          modified UTF-8 encoding of a string
<i>1151</i>&nbsp;     */
<i>1152</i>&nbsp;    public String readUTF() throws IOException {
<i>1153</i>&nbsp;        return bin.readUTF();
<i>1154</i>&nbsp;    }
<i>1155</i>&nbsp;
<i>1156</i>&nbsp;    /**
<i>1157</i>&nbsp;     * Returns the serialization filter for this stream.
<i>1158</i>&nbsp;     * The serialization filter is the most recent filter set in
<i>1159</i>&nbsp;     * {@link #setObjectInputFilter setObjectInputFilter} or
<i>1160</i>&nbsp;     * the initial process-wide filter from
<i>1161</i>&nbsp;     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}.
<i>1162</i>&nbsp;     *
<i>1163</i>&nbsp;     * @return the serialization filter for the stream; may be null
<i>1164</i>&nbsp;     * @since 9
<i>1165</i>&nbsp;     */
<i>1166</i>&nbsp;    public final ObjectInputFilter getObjectInputFilter() {
<i>1167</i>&nbsp;        return serialFilter;
<i>1168</i>&nbsp;    }
<i>1169</i>&nbsp;
<i>1170</i>&nbsp;    /**
<i>1171</i>&nbsp;     * Set the serialization filter for the stream.
<i>1172</i>&nbsp;     * The filter&#39;s {@link ObjectInputFilter#checkInput checkInput} method is called
<i>1173</i>&nbsp;     * for each class and reference in the stream.
<i>1174</i>&nbsp;     * The filter can check any or all of the class, the array length, the number
<i>1175</i>&nbsp;     * of references, the depth of the graph, and the size of the input stream.
<i>1176</i>&nbsp;     * The depth is the number of nested {@linkplain #readObject readObject}
<i>1177</i>&nbsp;     * calls starting with the reading of the root of the graph being deserialized
<i>1178</i>&nbsp;     * and the current object being deserialized.
<i>1179</i>&nbsp;     * The number of references is the cumulative number of objects and references
<i>1180</i>&nbsp;     * to objects already read from the stream including the current object being read.
<i>1181</i>&nbsp;     * The filter is invoked only when reading objects from the stream and for
<i>1182</i>&nbsp;     * not primitives.
<i>1183</i>&nbsp;     * &lt;p&gt;
<i>1184</i>&nbsp;     * If the filter returns {@link ObjectInputFilter.Status#REJECTED Status.REJECTED},
<i>1185</i>&nbsp;     * {@code null} or throws a {@link RuntimeException},
<i>1186</i>&nbsp;     * the active {@code readObject} or {@code readUnshared}
<i>1187</i>&nbsp;     * throws {@link InvalidClassException}, otherwise deserialization
<i>1188</i>&nbsp;     * continues uninterrupted.
<i>1189</i>&nbsp;     * &lt;p&gt;
<i>1190</i>&nbsp;     * The serialization filter is initialized to the value of
<i>1191</i>&nbsp;     * {@link ObjectInputFilter.Config#getSerialFilter() ObjectInputFilter.Config.getSerialFilter}
<i>1192</i>&nbsp;     * when the {@code  ObjectInputStream} is constructed and can be set
<i>1193</i>&nbsp;     * to a custom filter only once.
<i>1194</i>&nbsp;     *
<i>1195</i>&nbsp;     * @implSpec
<i>1196</i>&nbsp;     * The filter, when not {@code null}, is invoked during {@link #readObject readObject}
<i>1197</i>&nbsp;     * and {@link #readUnshared readUnshared} for each object (regular or class) in the stream.
<i>1198</i>&nbsp;     * Strings are treated as primitives and do not invoke the filter.
<i>1199</i>&nbsp;     * The filter is called for:
<i>1200</i>&nbsp;     * &lt;ul&gt;
<b class="nc"><i>1201</i>&nbsp;     *     &lt;li&gt;each object reference previously deserialized from the stream</b>
<b class="nc"><i>1202</i>&nbsp;     *     (class is {@code null}, arrayLength is -1),</b>
<b class="nc"><i>1203</i>&nbsp;     *     &lt;li&gt;each regular class (class is not {@code null}, arrayLength is -1),</b>
<i>1204</i>&nbsp;     *     &lt;li&gt;each interface of a dynamic proxy and the dynamic proxy class itself
<i>1205</i>&nbsp;     *     (class is not {@code null}, arrayLength is -1),
<b class="nc"><i>1206</i>&nbsp;     *     &lt;li&gt;each array is filtered using the array type and length of the array</b>
<b class="nc"><i>1207</i>&nbsp;     *     (class is the array type, arrayLength is the requested length),</b>
<b class="nc"><i>1208</i>&nbsp;     *     &lt;li&gt;each object replaced by its class&#39; {@code readResolve} method</b>
<i>1209</i>&nbsp;     *         is filtered using the replacement object&#39;s class, if not {@code null},
<b class="nc"><i>1210</i>&nbsp;     *         and if it is an array, the arrayLength, otherwise -1,</b>
<i>1211</i>&nbsp;     *     &lt;li&gt;and each object replaced by {@link #resolveObject resolveObject}
<i>1212</i>&nbsp;     *         is filtered using the replacement object&#39;s class, if not {@code null},
<i>1213</i>&nbsp;     *         and if it is an array, the arrayLength, otherwise -1.
<i>1214</i>&nbsp;     * &lt;/ul&gt;
<i>1215</i>&nbsp;     *
<i>1216</i>&nbsp;     * When the {@link ObjectInputFilter#checkInput checkInput} method is invoked
<i>1217</i>&nbsp;     * it is given access to the current class, the array length,
<i>1218</i>&nbsp;     * the current number of references already read from the stream,
<i>1219</i>&nbsp;     * the depth of nested calls to {@link #readObject readObject} or
<i>1220</i>&nbsp;     * {@link #readUnshared readUnshared},
<i>1221</i>&nbsp;     * and the implementation dependent number of bytes consumed from the input stream.
<i>1222</i>&nbsp;     * &lt;p&gt;
<i>1223</i>&nbsp;     * Each call to {@link #readObject readObject} or
<b class="nc"><i>1224</i>&nbsp;     * {@link #readUnshared readUnshared} increases the depth by 1</b>
<b class="nc"><i>1225</i>&nbsp;     * before reading an object and decreases by 1 before returning</b>
<i>1226</i>&nbsp;     * normally or exceptionally.
<i>1227</i>&nbsp;     * The depth starts at {@code 1} and increases for each nested object and
<b class="nc"><i>1228</i>&nbsp;     * decrements when each nested call returns.</b>
<b class="nc"><i>1229</i>&nbsp;     * The count of references in the stream starts at {@code 1} and</b>
<b class="nc"><i>1230</i>&nbsp;     * is increased before reading an object.</b>
<i>1231</i>&nbsp;     *
<b class="nc"><i>1232</i>&nbsp;     * @param filter the filter, may be null</b>
<b class="nc"><i>1233</i>&nbsp;     * @throws SecurityException if there is security manager and the</b>
<b class="nc"><i>1234</i>&nbsp;     *       {@code SerializablePermission(&quot;serialFilter&quot;)} is not granted</b>
<b class="nc"><i>1235</i>&nbsp;     * @throws IllegalStateException if the {@linkplain #getObjectInputFilter() current filter}</b>
<i>1236</i>&nbsp;     *       is not {@code null} and is not the process-wide filter
<i>1237</i>&nbsp;     * @since 9
<b class="nc"><i>1238</i>&nbsp;     */</b>
<b class="nc"><i>1239</i>&nbsp;    public final void setObjectInputFilter(ObjectInputFilter filter) {</b>
<i>1240</i>&nbsp;        SecurityManager sm = System.getSecurityManager();
<b class="nc"><i>1241</i>&nbsp;        if (sm != null) {</b>
<b class="nc"><i>1242</i>&nbsp;            sm.checkPermission(ObjectStreamConstants.SERIAL_FILTER_PERMISSION);</b>
<i>1243</i>&nbsp;        }
<b class="nc"><i>1244</i>&nbsp;        // Allow replacement of the process-wide filter if not already set</b>
<b class="nc"><i>1245</i>&nbsp;        if (serialFilter != null &amp;&amp;</b>
<b class="nc"><i>1246</i>&nbsp;                serialFilter != ObjectInputFilter.Config.getSerialFilter()) {</b>
<i>1247</i>&nbsp;            throw new IllegalStateException(&quot;filter can not be set more than once&quot;);
<i>1248</i>&nbsp;        }
<b class="nc"><i>1249</i>&nbsp;        this.serialFilter = filter;</b>
<b class="nc"><i>1250</i>&nbsp;    }</b>
<i>1251</i>&nbsp;
<b class="nc"><i>1252</i>&nbsp;    /**</b>
<b class="nc"><i>1253</i>&nbsp;     * Invoke the serialization filter if non-null.</b>
<i>1254</i>&nbsp;     * If the filter rejects or an exception is thrown, throws InvalidClassException.
<i>1255</i>&nbsp;     *
<i>1256</i>&nbsp;     * @param clazz the class; may be null
<i>1257</i>&nbsp;     * @param arrayLength the array length requested; use {@code -1} if not creating an array
<i>1258</i>&nbsp;     * @throws InvalidClassException if it rejected by the filter or
<i>1259</i>&nbsp;     *        a {@link RuntimeException} is thrown
<i>1260</i>&nbsp;     */
<i>1261</i>&nbsp;    private void filterCheck(Class&lt;?&gt; clazz, int arrayLength)
<b class="nc"><i>1262</i>&nbsp;            throws InvalidClassException {</b>
<i>1263</i>&nbsp;        if (serialFilter != null) {
<i>1264</i>&nbsp;            RuntimeException ex = null;
<i>1265</i>&nbsp;            ObjectInputFilter.Status status;
<i>1266</i>&nbsp;            // Info about the stream is not available if overridden by subclass, return 0
<i>1267</i>&nbsp;            long bytesRead = (bin == null) ? 0 : bin.getBytesRead();
<i>1268</i>&nbsp;            try {
<i>1269</i>&nbsp;                status = serialFilter.checkInput(new FilterValues(clazz, arrayLength,
<i>1270</i>&nbsp;                        totalObjectRefs, depth, bytesRead));
<i>1271</i>&nbsp;            } catch (RuntimeException e) {
<i>1272</i>&nbsp;                // Preventive interception of an exception to log
<i>1273</i>&nbsp;                status = ObjectInputFilter.Status.REJECTED;
<i>1274</i>&nbsp;                ex = e;
<i>1275</i>&nbsp;            }
<i>1276</i>&nbsp;            if (Logging.filterLogger != null) {
<i>1277</i>&nbsp;                // Debug logging of filter checks that fail; Tracing for those that succeed
<i>1278</i>&nbsp;                Logging.filterLogger.log(status == null || status == ObjectInputFilter.Status.REJECTED
<i>1279</i>&nbsp;                                ? Logger.Level.DEBUG
<i>1280</i>&nbsp;                                : Logger.Level.TRACE,
<i>1281</i>&nbsp;                        &quot;ObjectInputFilter {0}: {1}, array length: {2}, nRefs: {3}, depth: {4}, bytes: {5}, ex: {6}&quot;,
<i>1282</i>&nbsp;                        status, clazz, arrayLength, totalObjectRefs, depth, bytesRead,
<i>1283</i>&nbsp;                        Objects.toString(ex, &quot;n/a&quot;));
<i>1284</i>&nbsp;            }
<i>1285</i>&nbsp;            if (status == null ||
<i>1286</i>&nbsp;                    status == ObjectInputFilter.Status.REJECTED) {
<i>1287</i>&nbsp;                InvalidClassException ice = new InvalidClassException(&quot;filter status: &quot; + status);
<i>1288</i>&nbsp;                ice.initCause(ex);
<i>1289</i>&nbsp;                throw ice;
<i>1290</i>&nbsp;            }
<i>1291</i>&nbsp;        }
<i>1292</i>&nbsp;    }
<i>1293</i>&nbsp;
<i>1294</i>&nbsp;    /**
<i>1295</i>&nbsp;     * Checks the given array type and length to ensure that creation of such
<i>1296</i>&nbsp;     * an array is permitted by this ObjectInputStream. The arrayType argument
<i>1297</i>&nbsp;     * must represent an actual array type.
<i>1298</i>&nbsp;     *
<i>1299</i>&nbsp;     * This private method is called via SharedSecrets.
<i>1300</i>&nbsp;     *
<i>1301</i>&nbsp;     * @param arrayType the array type
<i>1302</i>&nbsp;     * @param arrayLength the array length
<i>1303</i>&nbsp;     * @throws NullPointerException if arrayType is null
<i>1304</i>&nbsp;     * @throws IllegalArgumentException if arrayType isn&#39;t actually an array type
<i>1305</i>&nbsp;     * @throws NegativeArraySizeException if arrayLength is negative
<i>1306</i>&nbsp;     * @throws InvalidClassException if the filter rejects creation
<i>1307</i>&nbsp;     */
<i>1308</i>&nbsp;    private void checkArray(Class&lt;?&gt; arrayType, int arrayLength) throws InvalidClassException {
<i>1309</i>&nbsp;        if (! arrayType.isArray()) {
<i>1310</i>&nbsp;            throw new IllegalArgumentException(&quot;not an array type&quot;);
<i>1311</i>&nbsp;        }
<i>1312</i>&nbsp;
<i>1313</i>&nbsp;        if (arrayLength &lt; 0) {
<i>1314</i>&nbsp;            throw new NegativeArraySizeException();
<i>1315</i>&nbsp;        }
<i>1316</i>&nbsp;
<i>1317</i>&nbsp;        filterCheck(arrayType, arrayLength);
<i>1318</i>&nbsp;    }
<i>1319</i>&nbsp;
<i>1320</i>&nbsp;    /**
<i>1321</i>&nbsp;     * Provide access to the persistent fields read from the input stream.
<i>1322</i>&nbsp;     */
<i>1323</i>&nbsp;    public abstract static class GetField {
<i>1324</i>&nbsp;
<i>1325</i>&nbsp;        /**
<i>1326</i>&nbsp;         * Get the ObjectStreamClass that describes the fields in the stream.
<i>1327</i>&nbsp;         *
<i>1328</i>&nbsp;         * @return  the descriptor class that describes the serializable fields
<i>1329</i>&nbsp;         */
<i>1330</i>&nbsp;        public abstract ObjectStreamClass getObjectStreamClass();
<i>1331</i>&nbsp;
<i>1332</i>&nbsp;        /**
<i>1333</i>&nbsp;         * Return true if the named field is defaulted and has no value in this
<i>1334</i>&nbsp;         * stream.
<i>1335</i>&nbsp;         *
<i>1336</i>&nbsp;         * @param  name the name of the field
<i>1337</i>&nbsp;         * @return true, if and only if the named field is defaulted
<i>1338</i>&nbsp;         * @throws IOException if there are I/O errors while reading from
<i>1339</i>&nbsp;         *         the underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1340</i>&nbsp;         * @throws IllegalArgumentException if &lt;code&gt;name&lt;/code&gt; does not
<i>1341</i>&nbsp;         *         correspond to a serializable field
<i>1342</i>&nbsp;         */
<i>1343</i>&nbsp;        public abstract boolean defaulted(String name) throws IOException;
<i>1344</i>&nbsp;
<i>1345</i>&nbsp;        /**
<i>1346</i>&nbsp;         * Get the value of the named boolean field from the persistent field.
<i>1347</i>&nbsp;         *
<i>1348</i>&nbsp;         * @param  name the name of the field
<i>1349</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<i>1350</i>&nbsp;         *         have a value
<i>1351</i>&nbsp;         * @return the value of the named &lt;code&gt;boolean&lt;/code&gt; field
<i>1352</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the
<i>1353</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1354</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1355</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1356</i>&nbsp;         */
<i>1357</i>&nbsp;        public abstract boolean get(String name, boolean val)
<i>1358</i>&nbsp;            throws IOException;
<i>1359</i>&nbsp;
<i>1360</i>&nbsp;        /**
<i>1361</i>&nbsp;         * Get the value of the named byte field from the persistent field.
<i>1362</i>&nbsp;         *
<i>1363</i>&nbsp;         * @param  name the name of the field
<i>1364</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<i>1365</i>&nbsp;         *         have a value
<i>1366</i>&nbsp;         * @return the value of the named &lt;code&gt;byte&lt;/code&gt; field
<i>1367</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the
<i>1368</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1369</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1370</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1371</i>&nbsp;         */
<i>1372</i>&nbsp;        public abstract byte get(String name, byte val) throws IOException;
<i>1373</i>&nbsp;
<i>1374</i>&nbsp;        /**
<i>1375</i>&nbsp;         * Get the value of the named char field from the persistent field.
<i>1376</i>&nbsp;         *
<i>1377</i>&nbsp;         * @param  name the name of the field
<i>1378</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<i>1379</i>&nbsp;         *         have a value
<i>1380</i>&nbsp;         * @return the value of the named &lt;code&gt;char&lt;/code&gt; field
<i>1381</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the
<i>1382</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1383</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1384</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1385</i>&nbsp;         */
<i>1386</i>&nbsp;        public abstract char get(String name, char val) throws IOException;
<i>1387</i>&nbsp;
<i>1388</i>&nbsp;        /**
<i>1389</i>&nbsp;         * Get the value of the named short field from the persistent field.
<i>1390</i>&nbsp;         *
<i>1391</i>&nbsp;         * @param  name the name of the field
<i>1392</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<i>1393</i>&nbsp;         *         have a value
<i>1394</i>&nbsp;         * @return the value of the named &lt;code&gt;short&lt;/code&gt; field
<i>1395</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the
<i>1396</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1397</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1398</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1399</i>&nbsp;         */
<i>1400</i>&nbsp;        public abstract short get(String name, short val) throws IOException;
<i>1401</i>&nbsp;
<i>1402</i>&nbsp;        /**
<i>1403</i>&nbsp;         * Get the value of the named int field from the persistent field.
<i>1404</i>&nbsp;         *
<i>1405</i>&nbsp;         * @param  name the name of the field
<i>1406</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<i>1407</i>&nbsp;         *         have a value
<i>1408</i>&nbsp;         * @return the value of the named &lt;code&gt;int&lt;/code&gt; field
<i>1409</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the
<i>1410</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1411</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1412</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1413</i>&nbsp;         */
<i>1414</i>&nbsp;        public abstract int get(String name, int val) throws IOException;
<i>1415</i>&nbsp;
<i>1416</i>&nbsp;        /**
<i>1417</i>&nbsp;         * Get the value of the named long field from the persistent field.
<i>1418</i>&nbsp;         *
<b class="nc"><i>1419</i>&nbsp;         * @param  name the name of the field</b>
<b class="nc"><i>1420</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</b>
<i>1421</i>&nbsp;         *         have a value
<i>1422</i>&nbsp;         * @return the value of the named &lt;code&gt;long&lt;/code&gt; field
<b class="nc"><i>1423</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the</b>
<b class="nc"><i>1424</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;</b>
<i>1425</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1426</i>&nbsp;         *         not serializable or if the field type is incorrect
<b class="nc"><i>1427</i>&nbsp;         */</b>
<b class="nc"><i>1428</i>&nbsp;        public abstract long get(String name, long val) throws IOException;</b>
<b class="nc"><i>1429</i>&nbsp;</b>
<b class="nc"><i>1430</i>&nbsp;        /**</b>
<b class="nc"><i>1431</i>&nbsp;         * Get the value of the named float field from the persistent field.</b>
<b class="nc"><i>1432</i>&nbsp;         *</b>
<i>1433</i>&nbsp;         * @param  name the name of the field
<b class="nc"><i>1434</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</b>
<i>1435</i>&nbsp;         *         have a value
<i>1436</i>&nbsp;         * @return the value of the named &lt;code&gt;float&lt;/code&gt; field
<b class="nc"><i>1437</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the</b>
<i>1438</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1439</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1440</i>&nbsp;         *         not serializable or if the field type is incorrect
<i>1441</i>&nbsp;         */
<i>1442</i>&nbsp;        public abstract float get(String name, float val) throws IOException;
<i>1443</i>&nbsp;
<i>1444</i>&nbsp;        /**
<i>1445</i>&nbsp;         * Get the value of the named double field from the persistent field.
<b class="nc"><i>1446</i>&nbsp;         *</b>
<b class="nc"><i>1447</i>&nbsp;         * @param  name the name of the field</b>
<i>1448</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not
<b class="nc"><i>1449</i>&nbsp;         *         have a value</b>
<b class="nc"><i>1450</i>&nbsp;         * @return the value of the named &lt;code&gt;double&lt;/code&gt; field</b>
<b class="nc"><i>1451</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the</b>
<i>1452</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1453</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<b class="nc"><i>1454</i>&nbsp;         *         not serializable or if the field type is incorrect</b>
<i>1455</i>&nbsp;         */
<b class="nc"><i>1456</i>&nbsp;        public abstract double get(String name, double val) throws IOException;</b>
<b class="nc"><i>1457</i>&nbsp;</b>
<i>1458</i>&nbsp;        /**
<i>1459</i>&nbsp;         * Get the value of the named Object field from the persistent field.
<b class="nc"><i>1460</i>&nbsp;         *</b>
<b class="nc"><i>1461</i>&nbsp;         * @param  name the name of the field</b>
<b class="nc"><i>1462</i>&nbsp;         * @param  val the default value to use if &lt;code&gt;name&lt;/code&gt; does not</b>
<i>1463</i>&nbsp;         *         have a value
<i>1464</i>&nbsp;         * @return the value of the named &lt;code&gt;Object&lt;/code&gt; field
<b class="nc"><i>1465</i>&nbsp;         * @throws IOException if there are I/O errors while reading from the</b>
<i>1466</i>&nbsp;         *         underlying &lt;code&gt;InputStream&lt;/code&gt;
<i>1467</i>&nbsp;         * @throws IllegalArgumentException if type of &lt;code&gt;name&lt;/code&gt; is
<i>1468</i>&nbsp;         *         not serializable or if the field type is incorrect
<b class="nc"><i>1469</i>&nbsp;         */</b>
<i>1470</i>&nbsp;        public abstract Object get(String name, Object val) throws IOException;
<i>1471</i>&nbsp;    }
<i>1472</i>&nbsp;
<i>1473</i>&nbsp;    /**
<i>1474</i>&nbsp;     * Verifies that this (possibly subclass) instance can be constructed
<i>1475</i>&nbsp;     * without violating security constraints: the subclass must not override
<b class="nc"><i>1476</i>&nbsp;     * security-sensitive non-final methods, or else the</b>
<b class="nc"><i>1477</i>&nbsp;     * &quot;enableSubclassImplementation&quot; SerializablePermission is checked.</b>
<i>1478</i>&nbsp;     */
<i>1479</i>&nbsp;    private void verifySubclass() {
<i>1480</i>&nbsp;        Class&lt;?&gt; cl = getClass();
<i>1481</i>&nbsp;        if (cl == ObjectInputStream.class) {
<i>1482</i>&nbsp;            return;
<i>1483</i>&nbsp;        }
<b class="nc"><i>1484</i>&nbsp;        SecurityManager sm = System.getSecurityManager();</b>
<b class="nc"><i>1485</i>&nbsp;        if (sm == null) {</b>
<b class="nc"><i>1486</i>&nbsp;            return;</b>
<b class="nc"><i>1487</i>&nbsp;        }</b>
<b class="nc"><i>1488</i>&nbsp;        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</b>
<b class="nc"><i>1489</i>&nbsp;        WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);</b>
<i>1490</i>&nbsp;        Boolean result = Caches.subclassAudits.get(key);
<i>1491</i>&nbsp;        if (result == null) {
<i>1492</i>&nbsp;            result = auditSubclass(cl);
<i>1493</i>&nbsp;            Caches.subclassAudits.putIfAbsent(key, result);
<i>1494</i>&nbsp;        }
<i>1495</i>&nbsp;        if (!result) {
<b class="nc"><i>1496</i>&nbsp;            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</b>
<i>1497</i>&nbsp;        }
<b class="nc"><i>1498</i>&nbsp;    }</b>
<i>1499</i>&nbsp;
<i>1500</i>&nbsp;    /**
<i>1501</i>&nbsp;     * Performs reflective checks on given subclass to verify that it doesn&#39;t
<b class="nc"><i>1502</i>&nbsp;     * override security-sensitive non-final methods.  Returns TRUE if subclass</b>
<b class="nc"><i>1503</i>&nbsp;     * is &quot;safe&quot;, FALSE otherwise.</b>
<b class="nc"><i>1504</i>&nbsp;     */</b>
<i>1505</i>&nbsp;    private static Boolean auditSubclass(Class&lt;?&gt; subcl) {
<i>1506</i>&nbsp;        return AccessController.doPrivileged(
<b class="nc"><i>1507</i>&nbsp;            new PrivilegedAction&lt;Boolean&gt;() {</b>
<b class="nc"><i>1508</i>&nbsp;                public Boolean run() {</b>
<i>1509</i>&nbsp;                    for (Class&lt;?&gt; cl = subcl;
<b class="nc"><i>1510</i>&nbsp;                         cl != ObjectInputStream.class;</b>
<i>1511</i>&nbsp;                         cl = cl.getSuperclass())
<b class="nc"><i>1512</i>&nbsp;                    {</b>
<i>1513</i>&nbsp;                        try {
<i>1514</i>&nbsp;                            cl.getDeclaredMethod(
<b class="nc"><i>1515</i>&nbsp;                                &quot;readUnshared&quot;, (Class[]) null);</b>
<i>1516</i>&nbsp;                            return Boolean.FALSE;
<i>1517</i>&nbsp;                        } catch (NoSuchMethodException ex) {
<b class="nc"><i>1518</i>&nbsp;                        }</b>
<i>1519</i>&nbsp;                        try {
<i>1520</i>&nbsp;                            cl.getDeclaredMethod(&quot;readFields&quot;, (Class[]) null);
<i>1521</i>&nbsp;                            return Boolean.FALSE;
<b class="nc"><i>1522</i>&nbsp;                        } catch (NoSuchMethodException ex) {</b>
<i>1523</i>&nbsp;                        }
<i>1524</i>&nbsp;                    }
<i>1525</i>&nbsp;                    return Boolean.TRUE;
<b class="nc"><i>1526</i>&nbsp;                }</b>
<i>1527</i>&nbsp;            }
<i>1528</i>&nbsp;        );
<b class="nc"><i>1529</i>&nbsp;    }</b>
<i>1530</i>&nbsp;
<i>1531</i>&nbsp;    /**
<b class="nc"><i>1532</i>&nbsp;     * Clears internal data structures.</b>
<i>1533</i>&nbsp;     */
<i>1534</i>&nbsp;    private void clear() {
<b class="nc"><i>1535</i>&nbsp;        handles.clear();</b>
<i>1536</i>&nbsp;        vlist.clear();
<i>1537</i>&nbsp;    }
<b class="nc"><i>1538</i>&nbsp;</b>
<b class="nc"><i>1539</i>&nbsp;    /**</b>
<i>1540</i>&nbsp;     * Underlying readObject implementation.
<i>1541</i>&nbsp;     */
<i>1542</i>&nbsp;    private Object readObject0(boolean unshared) throws IOException {
<b class="nc"><i>1543</i>&nbsp;        boolean oldMode = bin.getBlockDataMode();</b>
<b class="nc"><i>1544</i>&nbsp;        if (oldMode) {</b>
<b class="nc"><i>1545</i>&nbsp;            int remain = bin.currentBlockRemaining();</b>
<b class="nc"><i>1546</i>&nbsp;            if (remain &gt; 0) {</b>
<b class="nc"><i>1547</i>&nbsp;                throw new OptionalDataException(remain);</b>
<i>1548</i>&nbsp;            } else if (defaultDataEnd) {
<b class="nc"><i>1549</i>&nbsp;                /*</b>
<i>1550</i>&nbsp;                 * Fix for 4360508: stream is currently at the end of a field
<i>1551</i>&nbsp;                 * value block written via default serialization; since there
<i>1552</i>&nbsp;                 * is no terminating TC_ENDBLOCKDATA tag, simulate
<i>1553</i>&nbsp;                 * end-of-custom-data behavior explicitly.
<b class="nc"><i>1554</i>&nbsp;                 */</b>
<b class="nc"><i>1555</i>&nbsp;                throw new OptionalDataException(true);</b>
<i>1556</i>&nbsp;            }
<b class="nc"><i>1557</i>&nbsp;            bin.setBlockDataMode(false);</b>
<i>1558</i>&nbsp;        }
<i>1559</i>&nbsp;
<i>1560</i>&nbsp;        byte tc;
<i>1561</i>&nbsp;        while ((tc = bin.peekByte()) == TC_RESET) {
<b class="nc"><i>1562</i>&nbsp;            bin.readByte();</b>
<b class="nc"><i>1563</i>&nbsp;            handleReset();</b>
<i>1564</i>&nbsp;        }
<i>1565</i>&nbsp;
<b class="nc"><i>1566</i>&nbsp;        depth++;</b>
<b class="nc"><i>1567</i>&nbsp;        totalObjectRefs++;</b>
<i>1568</i>&nbsp;        try {
<i>1569</i>&nbsp;            switch (tc) {
<i>1570</i>&nbsp;                case TC_NULL:
<i>1571</i>&nbsp;                    return readNull();
<i>1572</i>&nbsp;
<i>1573</i>&nbsp;                case TC_REFERENCE:
<i>1574</i>&nbsp;                    return readHandle(unshared);
<i>1575</i>&nbsp;
<i>1576</i>&nbsp;                case TC_CLASS:
<i>1577</i>&nbsp;                    return readClass(unshared);
<i>1578</i>&nbsp;
<i>1579</i>&nbsp;                case TC_CLASSDESC:
<b class="nc"><i>1580</i>&nbsp;                case TC_PROXYCLASSDESC:</b>
<b class="nc"><i>1581</i>&nbsp;                    return readClassDesc(unshared);</b>
<i>1582</i>&nbsp;
<b class="nc"><i>1583</i>&nbsp;                case TC_STRING:</b>
<b class="nc"><i>1584</i>&nbsp;                case TC_LONGSTRING:</b>
<i>1585</i>&nbsp;                    return checkResolve(readString(unshared));
<i>1586</i>&nbsp;
<b class="nc"><i>1587</i>&nbsp;                case TC_ARRAY:</b>
<b class="nc"><i>1588</i>&nbsp;                    return checkResolve(readArray(unshared));</b>
<b class="nc"><i>1589</i>&nbsp;</b>
<i>1590</i>&nbsp;                case TC_ENUM:
<b class="nc"><i>1591</i>&nbsp;                    return checkResolve(readEnum(unshared));</b>
<i>1592</i>&nbsp;
<i>1593</i>&nbsp;                case TC_OBJECT:
<b class="nc"><i>1594</i>&nbsp;                    return checkResolve(readOrdinaryObject(unshared));</b>
<i>1595</i>&nbsp;
<b class="nc"><i>1596</i>&nbsp;                case TC_EXCEPTION:</b>
<i>1597</i>&nbsp;                    IOException ex = readFatalException();
<i>1598</i>&nbsp;                    throw new WriteAbortedException(&quot;writing aborted&quot;, ex);
<i>1599</i>&nbsp;
<i>1600</i>&nbsp;                case TC_BLOCKDATA:
<i>1601</i>&nbsp;                case TC_BLOCKDATALONG:
<i>1602</i>&nbsp;                    if (oldMode) {
<i>1603</i>&nbsp;                        bin.setBlockDataMode(true);
<b class="nc"><i>1604</i>&nbsp;                        bin.peek();             // force header read</b>
<i>1605</i>&nbsp;                        throw new OptionalDataException(
<b class="nc"><i>1606</i>&nbsp;                            bin.currentBlockRemaining());</b>
<b class="nc"><i>1607</i>&nbsp;                    } else {</b>
<i>1608</i>&nbsp;                        throw new StreamCorruptedException(
<b class="nc"><i>1609</i>&nbsp;                            &quot;unexpected block data&quot;);</b>
<i>1610</i>&nbsp;                    }
<i>1611</i>&nbsp;
<b class="nc"><i>1612</i>&nbsp;                case TC_ENDBLOCKDATA:</b>
<i>1613</i>&nbsp;                    if (oldMode) {
<i>1614</i>&nbsp;                        throw new OptionalDataException(true);
<i>1615</i>&nbsp;                    } else {
<b class="nc"><i>1616</i>&nbsp;                        throw new StreamCorruptedException(</b>
<i>1617</i>&nbsp;                            &quot;unexpected end of block data&quot;);
<i>1618</i>&nbsp;                    }
<b class="nc"><i>1619</i>&nbsp;</b>
<b class="nc"><i>1620</i>&nbsp;                default:</b>
<i>1621</i>&nbsp;                    throw new StreamCorruptedException(
<i>1622</i>&nbsp;                        String.format(&quot;invalid type code: %02X&quot;, tc));
<b class="nc"><i>1623</i>&nbsp;            }</b>
<i>1624</i>&nbsp;        } finally {
<i>1625</i>&nbsp;            depth--;
<i>1626</i>&nbsp;            bin.setBlockDataMode(oldMode);
<i>1627</i>&nbsp;        }
<i>1628</i>&nbsp;    }
<i>1629</i>&nbsp;
<i>1630</i>&nbsp;    /**
<b class="nc"><i>1631</i>&nbsp;     * If resolveObject has been enabled and given object does not have an</b>
<b class="nc"><i>1632</i>&nbsp;     * exception associated with it, calls resolveObject to determine</b>
<i>1633</i>&nbsp;     * replacement for object, and updates handle table accordingly.  Returns
<b class="nc"><i>1634</i>&nbsp;     * replacement object, or echoes provided object if no replacement</b>
<b class="nc"><i>1635</i>&nbsp;     * occurred.  Expects that passHandle is set to given object&#39;s handle prior</b>
<i>1636</i>&nbsp;     * to calling this method.
<i>1637</i>&nbsp;     */
<i>1638</i>&nbsp;    private Object checkResolve(Object obj) throws IOException {
<i>1639</i>&nbsp;        if (!enableResolve || handles.lookupException(passHandle) != null) {
<i>1640</i>&nbsp;            return obj;
<i>1641</i>&nbsp;        }
<i>1642</i>&nbsp;        Object rep = resolveObject(obj);
<b class="nc"><i>1643</i>&nbsp;        if (rep != obj) {</b>
<b class="nc"><i>1644</i>&nbsp;            // The type of the original object has been filtered but resolveObject</b>
<i>1645</i>&nbsp;            // may have replaced it;  filter the replacement&#39;s type
<b class="nc"><i>1646</i>&nbsp;            if (rep != null) {</b>
<b class="nc"><i>1647</i>&nbsp;                if (rep.getClass().isArray()) {</b>
<b class="nc"><i>1648</i>&nbsp;                    filterCheck(rep.getClass(), Array.getLength(rep));</b>
<b class="nc"><i>1649</i>&nbsp;                } else {</b>
<i>1650</i>&nbsp;                    filterCheck(rep.getClass(), -1);
<i>1651</i>&nbsp;                }
<b class="nc"><i>1652</i>&nbsp;            }</b>
<i>1653</i>&nbsp;            handles.setObject(passHandle, rep);
<b class="nc"><i>1654</i>&nbsp;        }</b>
<i>1655</i>&nbsp;        return rep;
<i>1656</i>&nbsp;    }
<i>1657</i>&nbsp;
<b class="nc"><i>1658</i>&nbsp;    /**</b>
<b class="nc"><i>1659</i>&nbsp;     * Reads string without allowing it to be replaced in stream.  Called from</b>
<i>1660</i>&nbsp;     * within ObjectStreamClass.read().
<b class="nc"><i>1661</i>&nbsp;     */</b>
<i>1662</i>&nbsp;    String readTypeString() throws IOException {
<i>1663</i>&nbsp;        int oldHandle = passHandle;
<b class="nc"><i>1664</i>&nbsp;        try {</b>
<b class="nc"><i>1665</i>&nbsp;            byte tc = bin.peekByte();</b>
<i>1666</i>&nbsp;            switch (tc) {
<i>1667</i>&nbsp;                case TC_NULL:
<i>1668</i>&nbsp;                    return (String) readNull();
<i>1669</i>&nbsp;
<i>1670</i>&nbsp;                case TC_REFERENCE:
<i>1671</i>&nbsp;                    return (String) readHandle(false);
<i>1672</i>&nbsp;
<i>1673</i>&nbsp;                case TC_STRING:
<i>1674</i>&nbsp;                case TC_LONGSTRING:
<b class="nc"><i>1675</i>&nbsp;                    return readString(false);</b>
<b class="nc"><i>1676</i>&nbsp;</b>
<i>1677</i>&nbsp;                default:
<b class="nc"><i>1678</i>&nbsp;                    throw new StreamCorruptedException(</b>
<b class="nc"><i>1679</i>&nbsp;                        String.format(&quot;invalid type code: %02X&quot;, tc));</b>
<b class="nc"><i>1680</i>&nbsp;            }</b>
<i>1681</i>&nbsp;        } finally {
<b class="nc"><i>1682</i>&nbsp;            passHandle = oldHandle;</b>
<b class="nc"><i>1683</i>&nbsp;        }</b>
<b class="nc"><i>1684</i>&nbsp;    }</b>
<i>1685</i>&nbsp;
<i>1686</i>&nbsp;    /**
<b class="nc"><i>1687</i>&nbsp;     * Reads in null code, sets passHandle to NULL_HANDLE and returns null.</b>
<b class="nc"><i>1688</i>&nbsp;     */</b>
<i>1689</i>&nbsp;    private Object readNull() throws IOException {
<i>1690</i>&nbsp;        if (bin.readByte() != TC_NULL) {
<i>1691</i>&nbsp;            throw new InternalError();
<i>1692</i>&nbsp;        }
<i>1693</i>&nbsp;        passHandle = NULL_HANDLE;
<i>1694</i>&nbsp;        return null;
<i>1695</i>&nbsp;    }
<i>1696</i>&nbsp;
<i>1697</i>&nbsp;    /**
<i>1698</i>&nbsp;     * Reads in object handle, sets passHandle to the read handle, and returns
<i>1699</i>&nbsp;     * object associated with the handle.
<b class="nc"><i>1700</i>&nbsp;     */</b>
<i>1701</i>&nbsp;    private Object readHandle(boolean unshared) throws IOException {
<b class="nc"><i>1702</i>&nbsp;        if (bin.readByte() != TC_REFERENCE) {</b>
<i>1703</i>&nbsp;            throw new InternalError();
<b class="nc"><i>1704</i>&nbsp;        }</b>
<b class="nc"><i>1705</i>&nbsp;        passHandle = bin.readInt() - baseWireHandle;</b>
<i>1706</i>&nbsp;        if (passHandle &lt; 0 || passHandle &gt;= handles.size()) {
<b class="nc"><i>1707</i>&nbsp;            throw new StreamCorruptedException(</b>
<b class="nc"><i>1708</i>&nbsp;                String.format(&quot;invalid handle value: %08X&quot;, passHandle +</b>
<i>1709</i>&nbsp;                baseWireHandle));
<b class="nc"><i>1710</i>&nbsp;        }</b>
<b class="nc"><i>1711</i>&nbsp;        if (unshared) {</b>
<i>1712</i>&nbsp;            // REMIND: what type of exception to throw here?
<b class="nc"><i>1713</i>&nbsp;            throw new InvalidObjectException(</b>
<b class="nc"><i>1714</i>&nbsp;                &quot;cannot read back reference as unshared&quot;);</b>
<i>1715</i>&nbsp;        }
<b class="nc"><i>1716</i>&nbsp;</b>
<b class="nc"><i>1717</i>&nbsp;        Object obj = handles.lookupObject(passHandle);</b>
<i>1718</i>&nbsp;        if (obj == unsharedMarker) {
<b class="nc"><i>1719</i>&nbsp;            // REMIND: what type of exception to throw here?</b>
<b class="nc"><i>1720</i>&nbsp;            throw new InvalidObjectException(</b>
<i>1721</i>&nbsp;                &quot;cannot read back reference to unshared object&quot;);
<b class="nc"><i>1722</i>&nbsp;        }</b>
<i>1723</i>&nbsp;        filterCheck(null, -1);       // just a check for number of references, depth, no class
<i>1724</i>&nbsp;        return obj;
<i>1725</i>&nbsp;    }
<i>1726</i>&nbsp;
<b class="nc"><i>1727</i>&nbsp;    /**</b>
<b class="nc"><i>1728</i>&nbsp;     * Reads in and returns class object.  Sets passHandle to class object&#39;s</b>
<i>1729</i>&nbsp;     * assigned handle.  Returns null if class is unresolvable (in which case a
<i>1730</i>&nbsp;     * ClassNotFoundException will be associated with the class&#39; handle in the
<i>1731</i>&nbsp;     * handle table).
<i>1732</i>&nbsp;     */
<i>1733</i>&nbsp;    private Class&lt;?&gt; readClass(boolean unshared) throws IOException {
<i>1734</i>&nbsp;        if (bin.readByte() != TC_CLASS) {
<i>1735</i>&nbsp;            throw new InternalError();
<i>1736</i>&nbsp;        }
<i>1737</i>&nbsp;        ObjectStreamClass desc = readClassDesc(false);
<i>1738</i>&nbsp;        Class&lt;?&gt; cl = desc.forClass();
<i>1739</i>&nbsp;        passHandle = handles.assign(unshared ? unsharedMarker : cl);
<b class="nc"><i>1740</i>&nbsp;</b>
<b class="nc"><i>1741</i>&nbsp;        ClassNotFoundException resolveEx = desc.getResolveException();</b>
<i>1742</i>&nbsp;        if (resolveEx != null) {
<i>1743</i>&nbsp;            handles.markException(passHandle, resolveEx);
<b class="nc"><i>1744</i>&nbsp;        }</b>
<b class="nc"><i>1745</i>&nbsp;</b>
<b class="nc"><i>1746</i>&nbsp;        handles.finish(passHandle);</b>
<i>1747</i>&nbsp;        return cl;
<b class="nc"><i>1748</i>&nbsp;    }</b>
<b class="nc"><i>1749</i>&nbsp;</b>
<b class="nc"><i>1750</i>&nbsp;    /**</b>
<b class="nc"><i>1751</i>&nbsp;     * Reads in and returns (possibly null) class descriptor.  Sets passHandle</b>
<i>1752</i>&nbsp;     * to class descriptor&#39;s assigned handle.  If class descriptor cannot be
<i>1753</i>&nbsp;     * resolved to a class in the local VM, a ClassNotFoundException is
<b class="nc"><i>1754</i>&nbsp;     * associated with the class descriptor&#39;s handle.</b>
<b class="nc"><i>1755</i>&nbsp;     */</b>
<b class="nc"><i>1756</i>&nbsp;    private ObjectStreamClass readClassDesc(boolean unshared)</b>
<i>1757</i>&nbsp;        throws IOException
<b class="nc"><i>1758</i>&nbsp;    {</b>
<b class="nc"><i>1759</i>&nbsp;        byte tc = bin.peekByte();</b>
<b class="nc"><i>1760</i>&nbsp;        ObjectStreamClass descriptor;</b>
<b class="nc"><i>1761</i>&nbsp;        switch (tc) {</b>
<i>1762</i>&nbsp;            case TC_NULL:
<i>1763</i>&nbsp;                descriptor = (ObjectStreamClass) readNull();
<i>1764</i>&nbsp;                break;
<i>1765</i>&nbsp;            case TC_REFERENCE:
<b class="nc"><i>1766</i>&nbsp;                descriptor = (ObjectStreamClass) readHandle(unshared);</b>
<b class="nc"><i>1767</i>&nbsp;                break;</b>
<b class="nc"><i>1768</i>&nbsp;            case TC_PROXYCLASSDESC:</b>
<i>1769</i>&nbsp;                descriptor = readProxyDesc(unshared);
<b class="nc"><i>1770</i>&nbsp;                break;</b>
<b class="nc"><i>1771</i>&nbsp;            case TC_CLASSDESC:</b>
<i>1772</i>&nbsp;                descriptor = readNonProxyDesc(unshared);
<i>1773</i>&nbsp;                break;
<b class="nc"><i>1774</i>&nbsp;            default:</b>
<b class="nc"><i>1775</i>&nbsp;                throw new StreamCorruptedException(</b>
<b class="nc"><i>1776</i>&nbsp;                    String.format(&quot;invalid type code: %02X&quot;, tc));</b>
<b class="nc"><i>1777</i>&nbsp;        }</b>
<i>1778</i>&nbsp;        return descriptor;
<b class="nc"><i>1779</i>&nbsp;    }</b>
<i>1780</i>&nbsp;
<i>1781</i>&nbsp;    private boolean isCustomSubclass() {
<b class="nc"><i>1782</i>&nbsp;        // Return true if this class is a custom subclass of ObjectInputStream</b>
<i>1783</i>&nbsp;        return getClass().getClassLoader()
<b class="nc"><i>1784</i>&nbsp;                    != ObjectInputStream.class.getClassLoader();</b>
<b class="nc"><i>1785</i>&nbsp;    }</b>
<b class="nc"><i>1786</i>&nbsp;</b>
<i>1787</i>&nbsp;    /**
<i>1788</i>&nbsp;     * Reads in and returns class descriptor for a dynamic proxy class.  Sets
<i>1789</i>&nbsp;     * passHandle to proxy class descriptor&#39;s assigned handle.  If proxy class
<i>1790</i>&nbsp;     * descriptor cannot be resolved to a class in the local VM, a
<i>1791</i>&nbsp;     * ClassNotFoundException is associated with the descriptor&#39;s handle.
<i>1792</i>&nbsp;     */
<i>1793</i>&nbsp;    private ObjectStreamClass readProxyDesc(boolean unshared)
<i>1794</i>&nbsp;        throws IOException
<i>1795</i>&nbsp;    {
<i>1796</i>&nbsp;        if (bin.readByte() != TC_PROXYCLASSDESC) {
<i>1797</i>&nbsp;            throw new InternalError();
<b class="nc"><i>1798</i>&nbsp;        }</b>
<b class="nc"><i>1799</i>&nbsp;</b>
<i>1800</i>&nbsp;        ObjectStreamClass desc = new ObjectStreamClass();
<i>1801</i>&nbsp;        int descHandle = handles.assign(unshared ? unsharedMarker : desc);
<b class="nc"><i>1802</i>&nbsp;        passHandle = NULL_HANDLE;</b>
<b class="nc"><i>1803</i>&nbsp;</b>
<b class="nc"><i>1804</i>&nbsp;        int numIfaces = bin.readInt();</b>
<i>1805</i>&nbsp;        if (numIfaces &gt; 65535) {
<b class="nc"><i>1806</i>&nbsp;            throw new InvalidObjectException(&quot;interface limit exceeded: &quot;</b>
<i>1807</i>&nbsp;                    + numIfaces);
<b class="nc"><i>1808</i>&nbsp;        }</b>
<b class="nc"><i>1809</i>&nbsp;        String[] ifaces = new String[numIfaces];</b>
<b class="nc"><i>1810</i>&nbsp;        for (int i = 0; i &lt; numIfaces; i++) {</b>
<b class="nc"><i>1811</i>&nbsp;            ifaces[i] = bin.readUTF();</b>
<b class="nc"><i>1812</i>&nbsp;        }</b>
<i>1813</i>&nbsp;
<b class="nc"><i>1814</i>&nbsp;        Class&lt;?&gt; cl = null;</b>
<b class="nc"><i>1815</i>&nbsp;        ClassNotFoundException resolveEx = null;</b>
<b class="nc"><i>1816</i>&nbsp;        bin.setBlockDataMode(true);</b>
<b class="nc"><i>1817</i>&nbsp;        try {</b>
<i>1818</i>&nbsp;            if ((cl = resolveProxyClass(ifaces)) == null) {
<b class="nc"><i>1819</i>&nbsp;                resolveEx = new ClassNotFoundException(&quot;null class&quot;);</b>
<b class="nc"><i>1820</i>&nbsp;            } else if (!Proxy.isProxyClass(cl)) {</b>
<b class="nc"><i>1821</i>&nbsp;                throw new InvalidClassException(&quot;Not a proxy&quot;);</b>
<b class="nc"><i>1822</i>&nbsp;            } else {</b>
<i>1823</i>&nbsp;                // ReflectUtil.checkProxyPackageAccess makes a test
<b class="nc"><i>1824</i>&nbsp;                // equivalent to isCustomSubclass so there&#39;s no need</b>
<b class="nc"><i>1825</i>&nbsp;                // to condition this call to isCustomSubclass == true here.</b>
<b class="nc"><i>1826</i>&nbsp;                ReflectUtil.checkProxyPackageAccess(</b>
<b class="nc"><i>1827</i>&nbsp;                        getClass().getClassLoader(),</b>
<i>1828</i>&nbsp;                        cl.getInterfaces());
<b class="nc"><i>1829</i>&nbsp;                // Filter the interfaces</b>
<i>1830</i>&nbsp;                for (Class&lt;?&gt; clazz : cl.getInterfaces()) {
<i>1831</i>&nbsp;                    filterCheck(clazz, -1);
<b class="nc"><i>1832</i>&nbsp;                }</b>
<i>1833</i>&nbsp;            }
<b class="nc"><i>1834</i>&nbsp;        } catch (ClassNotFoundException ex) {</b>
<b class="nc"><i>1835</i>&nbsp;            resolveEx = ex;</b>
<i>1836</i>&nbsp;        }
<b class="nc"><i>1837</i>&nbsp;</b>
<i>1838</i>&nbsp;        // Call filterCheck on the class before reading anything else
<i>1839</i>&nbsp;        filterCheck(cl, -1);
<i>1840</i>&nbsp;
<i>1841</i>&nbsp;        skipCustomData();
<i>1842</i>&nbsp;
<i>1843</i>&nbsp;        try {
<i>1844</i>&nbsp;            totalObjectRefs++;
<i>1845</i>&nbsp;            depth++;
<b class="nc"><i>1846</i>&nbsp;            desc.initProxy(cl, resolveEx, readClassDesc(false));</b>
<b class="nc"><i>1847</i>&nbsp;        } finally {</b>
<i>1848</i>&nbsp;            depth--;
<b class="nc"><i>1849</i>&nbsp;        }</b>
<b class="nc"><i>1850</i>&nbsp;</b>
<i>1851</i>&nbsp;        handles.finish(descHandle);
<i>1852</i>&nbsp;        passHandle = descHandle;
<b class="nc"><i>1853</i>&nbsp;        return desc;</b>
<b class="nc"><i>1854</i>&nbsp;    }</b>
<i>1855</i>&nbsp;
<i>1856</i>&nbsp;    /**
<b class="nc"><i>1857</i>&nbsp;     * Reads in and returns class descriptor for a class that is not a dynamic</b>
<b class="nc"><i>1858</i>&nbsp;     * proxy class.  Sets passHandle to class descriptor&#39;s assigned handle.  If</b>
<i>1859</i>&nbsp;     * class descriptor cannot be resolved to a class in the local VM, a
<b class="nc"><i>1860</i>&nbsp;     * ClassNotFoundException is associated with the descriptor&#39;s handle.</b>
<b class="nc"><i>1861</i>&nbsp;     */</b>
<b class="nc"><i>1862</i>&nbsp;    private ObjectStreamClass readNonProxyDesc(boolean unshared)</b>
<i>1863</i>&nbsp;        throws IOException
<i>1864</i>&nbsp;    {
<i>1865</i>&nbsp;        if (bin.readByte() != TC_CLASSDESC) {
<i>1866</i>&nbsp;            throw new InternalError();
<i>1867</i>&nbsp;        }
<i>1868</i>&nbsp;
<i>1869</i>&nbsp;        ObjectStreamClass desc = new ObjectStreamClass();
<b class="nc"><i>1870</i>&nbsp;        int descHandle = handles.assign(unshared ? unsharedMarker : desc);</b>
<b class="nc"><i>1871</i>&nbsp;        passHandle = NULL_HANDLE;</b>
<i>1872</i>&nbsp;
<i>1873</i>&nbsp;        ObjectStreamClass readDesc;
<b class="nc"><i>1874</i>&nbsp;        try {</b>
<b class="nc"><i>1875</i>&nbsp;            readDesc = readClassDescriptor();</b>
<i>1876</i>&nbsp;        } catch (ClassNotFoundException ex) {
<b class="nc"><i>1877</i>&nbsp;            throw (IOException) new InvalidClassException(</b>
<i>1878</i>&nbsp;                &quot;failed to read class descriptor&quot;).initCause(ex);
<b class="nc"><i>1879</i>&nbsp;        }</b>
<b class="nc"><i>1880</i>&nbsp;</b>
<b class="nc"><i>1881</i>&nbsp;        Class&lt;?&gt; cl = null;</b>
<b class="nc"><i>1882</i>&nbsp;        ClassNotFoundException resolveEx = null;</b>
<b class="nc"><i>1883</i>&nbsp;        bin.setBlockDataMode(true);</b>
<i>1884</i>&nbsp;        final boolean checksRequired = isCustomSubclass();
<i>1885</i>&nbsp;        try {
<b class="nc"><i>1886</i>&nbsp;            if ((cl = resolveClass(readDesc)) == null) {</b>
<b class="nc"><i>1887</i>&nbsp;                resolveEx = new ClassNotFoundException(&quot;null class&quot;);</b>
<b class="nc"><i>1888</i>&nbsp;            } else if (checksRequired) {</b>
<b class="nc"><i>1889</i>&nbsp;                ReflectUtil.checkPackageAccess(cl);</b>
<i>1890</i>&nbsp;            }
<i>1891</i>&nbsp;        } catch (ClassNotFoundException ex) {
<b class="nc"><i>1892</i>&nbsp;            resolveEx = ex;</b>
<b class="nc"><i>1893</i>&nbsp;        }</b>
<b class="nc"><i>1894</i>&nbsp;</b>
<i>1895</i>&nbsp;        // Call filterCheck on the class before reading anything else
<b class="nc"><i>1896</i>&nbsp;        filterCheck(cl, -1);</b>
<b class="nc"><i>1897</i>&nbsp;</b>
<b class="nc"><i>1898</i>&nbsp;        skipCustomData();</b>
<b class="nc"><i>1899</i>&nbsp;</b>
<b class="nc"><i>1900</i>&nbsp;        try {</b>
<b class="nc"><i>1901</i>&nbsp;            totalObjectRefs++;</b>
<b class="nc"><i>1902</i>&nbsp;            depth++;</b>
<b class="nc"><i>1903</i>&nbsp;            desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(false));</b>
<b class="nc"><i>1904</i>&nbsp;        } finally {</b>
<b class="nc"><i>1905</i>&nbsp;            depth--;</b>
<b class="nc"><i>1906</i>&nbsp;        }</b>
<b class="nc"><i>1907</i>&nbsp;</b>
<b class="nc"><i>1908</i>&nbsp;        handles.finish(descHandle);</b>
<b class="nc"><i>1909</i>&nbsp;        passHandle = descHandle;</b>
<b class="nc"><i>1910</i>&nbsp;</b>
<b class="nc"><i>1911</i>&nbsp;        return desc;</b>
<b class="nc"><i>1912</i>&nbsp;    }</b>
<i>1913</i>&nbsp;
<b class="nc"><i>1914</i>&nbsp;    /**</b>
<i>1915</i>&nbsp;     * Reads in and returns new string.  Sets passHandle to new string&#39;s
<i>1916</i>&nbsp;     * assigned handle.
<b class="nc"><i>1917</i>&nbsp;     */</b>
<b class="nc"><i>1918</i>&nbsp;    private String readString(boolean unshared) throws IOException {</b>
<b class="nc"><i>1919</i>&nbsp;        String str;</b>
<b class="nc"><i>1920</i>&nbsp;        byte tc = bin.readByte();</b>
<i>1921</i>&nbsp;        switch (tc) {
<i>1922</i>&nbsp;            case TC_STRING:
<i>1923</i>&nbsp;                str = bin.readUTF();
<b class="nc"><i>1924</i>&nbsp;                break;</b>
<b class="nc"><i>1925</i>&nbsp;</b>
<b class="nc"><i>1926</i>&nbsp;            case TC_LONGSTRING:</b>
<i>1927</i>&nbsp;                str = bin.readLongUTF();
<i>1928</i>&nbsp;                break;
<i>1929</i>&nbsp;
<i>1930</i>&nbsp;            default:
<i>1931</i>&nbsp;                throw new StreamCorruptedException(
<i>1932</i>&nbsp;                    String.format(&quot;invalid type code: %02X&quot;, tc));
<i>1933</i>&nbsp;        }
<b class="nc"><i>1934</i>&nbsp;        passHandle = handles.assign(unshared ? unsharedMarker : str);</b>
<b class="nc"><i>1935</i>&nbsp;        handles.finish(passHandle);</b>
<i>1936</i>&nbsp;        return str;
<i>1937</i>&nbsp;    }
<b class="nc"><i>1938</i>&nbsp;</b>
<b class="nc"><i>1939</i>&nbsp;    /**</b>
<b class="nc"><i>1940</i>&nbsp;     * Reads in and returns array object, or null if array class is</b>
<i>1941</i>&nbsp;     * unresolvable.  Sets passHandle to array&#39;s assigned handle.
<i>1942</i>&nbsp;     */
<b class="nc"><i>1943</i>&nbsp;    private Object readArray(boolean unshared) throws IOException {</b>
<b class="nc"><i>1944</i>&nbsp;        if (bin.readByte() != TC_ARRAY) {</b>
<b class="nc"><i>1945</i>&nbsp;            throw new InternalError();</b>
<b class="nc"><i>1946</i>&nbsp;        }</b>
<i>1947</i>&nbsp;
<i>1948</i>&nbsp;        ObjectStreamClass desc = readClassDesc(false);
<b class="nc"><i>1949</i>&nbsp;        int len = bin.readInt();</b>
<b class="nc"><i>1950</i>&nbsp;</b>
<b class="nc"><i>1951</i>&nbsp;        filterCheck(desc.forClass(), len);</b>
<b class="nc"><i>1952</i>&nbsp;</b>
<i>1953</i>&nbsp;        Object array = null;
<i>1954</i>&nbsp;        Class&lt;?&gt; cl, ccl = null;
<b class="nc"><i>1955</i>&nbsp;        if ((cl = desc.forClass()) != null) {</b>
<b class="nc"><i>1956</i>&nbsp;            ccl = cl.getComponentType();</b>
<b class="nc"><i>1957</i>&nbsp;            array = Array.newInstance(ccl, len);</b>
<b class="nc"><i>1958</i>&nbsp;        }</b>
<i>1959</i>&nbsp;
<b class="nc"><i>1960</i>&nbsp;        int arrayHandle = handles.assign(unshared ? unsharedMarker : array);</b>
<b class="nc"><i>1961</i>&nbsp;        ClassNotFoundException resolveEx = desc.getResolveException();</b>
<b class="nc"><i>1962</i>&nbsp;        if (resolveEx != null) {</b>
<b class="nc"><i>1963</i>&nbsp;            handles.markException(arrayHandle, resolveEx);</b>
<i>1964</i>&nbsp;        }
<i>1965</i>&nbsp;
<i>1966</i>&nbsp;        if (ccl == null) {
<b class="nc"><i>1967</i>&nbsp;            for (int i = 0; i &lt; len; i++) {</b>
<b class="nc"><i>1968</i>&nbsp;                readObject0(false);</b>
<b class="nc"><i>1969</i>&nbsp;            }</b>
<i>1970</i>&nbsp;        } else if (ccl.isPrimitive()) {
<i>1971</i>&nbsp;            if (ccl == Integer.TYPE) {
<i>1972</i>&nbsp;                bin.readInts((int[]) array, 0, len);
<i>1973</i>&nbsp;            } else if (ccl == Byte.TYPE) {
<i>1974</i>&nbsp;                bin.readFully((byte[]) array, 0, len, true);
<i>1975</i>&nbsp;            } else if (ccl == Long.TYPE) {
<i>1976</i>&nbsp;                bin.readLongs((long[]) array, 0, len);
<i>1977</i>&nbsp;            } else if (ccl == Float.TYPE) {
<i>1978</i>&nbsp;                bin.readFloats((float[]) array, 0, len);
<i>1979</i>&nbsp;            } else if (ccl == Double.TYPE) {
<i>1980</i>&nbsp;                bin.readDoubles((double[]) array, 0, len);
<i>1981</i>&nbsp;            } else if (ccl == Short.TYPE) {
<b class="nc"><i>1982</i>&nbsp;                bin.readShorts((short[]) array, 0, len);</b>
<b class="nc"><i>1983</i>&nbsp;            } else if (ccl == Character.TYPE) {</b>
<i>1984</i>&nbsp;                bin.readChars((char[]) array, 0, len);
<i>1985</i>&nbsp;            } else if (ccl == Boolean.TYPE) {
<b class="nc"><i>1986</i>&nbsp;                bin.readBooleans((boolean[]) array, 0, len);</b>
<b class="nc"><i>1987</i>&nbsp;            } else {</b>
<i>1988</i>&nbsp;                throw new InternalError();
<b class="nc"><i>1989</i>&nbsp;            }</b>
<b class="nc"><i>1990</i>&nbsp;        } else {</b>
<i>1991</i>&nbsp;            Object[] oa = (Object[]) array;
<b class="nc"><i>1992</i>&nbsp;            for (int i = 0; i &lt; len; i++) {</b>
<i>1993</i>&nbsp;                oa[i] = readObject0(false);
<i>1994</i>&nbsp;                handles.markDependency(arrayHandle, passHandle);
<i>1995</i>&nbsp;            }
<i>1996</i>&nbsp;        }
<b class="nc"><i>1997</i>&nbsp;</b>
<b class="nc"><i>1998</i>&nbsp;        handles.finish(arrayHandle);</b>
<b class="nc"><i>1999</i>&nbsp;        passHandle = arrayHandle;</b>
<b class="nc"><i>2000</i>&nbsp;        return array;</b>
<b class="nc"><i>2001</i>&nbsp;    }</b>
<b class="nc"><i>2002</i>&nbsp;</b>
<i>2003</i>&nbsp;    /**
<b class="nc"><i>2004</i>&nbsp;     * Reads in and returns enum constant, or null if enum type is</b>
<b class="nc"><i>2005</i>&nbsp;     * unresolvable.  Sets passHandle to enum constant&#39;s assigned handle.</b>
<b class="nc"><i>2006</i>&nbsp;     */</b>
<b class="nc"><i>2007</i>&nbsp;    private Enum&lt;?&gt; readEnum(boolean unshared) throws IOException {</b>
<i>2008</i>&nbsp;        if (bin.readByte() != TC_ENUM) {
<i>2009</i>&nbsp;            throw new InternalError();
<b class="nc"><i>2010</i>&nbsp;        }</b>
<b class="nc"><i>2011</i>&nbsp;</b>
<i>2012</i>&nbsp;        ObjectStreamClass desc = readClassDesc(false);
<b class="nc"><i>2013</i>&nbsp;        if (!desc.isEnum()) {</b>
<i>2014</i>&nbsp;            throw new InvalidClassException(&quot;non-enum class: &quot; + desc);
<i>2015</i>&nbsp;        }
<b class="nc"><i>2016</i>&nbsp;</b>
<i>2017</i>&nbsp;        int enumHandle = handles.assign(unshared ? unsharedMarker : null);
<b class="nc"><i>2018</i>&nbsp;        ClassNotFoundException resolveEx = desc.getResolveException();</b>
<b class="nc"><i>2019</i>&nbsp;        if (resolveEx != null) {</b>
<b class="nc"><i>2020</i>&nbsp;            handles.markException(enumHandle, resolveEx);</b>
<i>2021</i>&nbsp;        }
<b class="nc"><i>2022</i>&nbsp;</b>
<b class="nc"><i>2023</i>&nbsp;        String name = readString(false);</b>
<b class="nc"><i>2024</i>&nbsp;        Enum&lt;?&gt; result = null;</b>
<i>2025</i>&nbsp;        Class&lt;?&gt; cl = desc.forClass();
<b class="nc"><i>2026</i>&nbsp;        if (cl != null) {</b>
<i>2027</i>&nbsp;            try {
<b class="nc"><i>2028</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>2029</i>&nbsp;                Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);</b>
<b class="nc"><i>2030</i>&nbsp;                result = en;</b>
<i>2031</i>&nbsp;            } catch (IllegalArgumentException ex) {
<b class="nc"><i>2032</i>&nbsp;                throw (IOException) new InvalidObjectException(</b>
<i>2033</i>&nbsp;                    &quot;enum constant &quot; + name + &quot; does not exist in &quot; +
<i>2034</i>&nbsp;                    cl).initCause(ex);
<b class="nc"><i>2035</i>&nbsp;            }</b>
<i>2036</i>&nbsp;            if (!unshared) {
<i>2037</i>&nbsp;                handles.setObject(enumHandle, result);
<i>2038</i>&nbsp;            }
<b class="nc"><i>2039</i>&nbsp;        }</b>
<i>2040</i>&nbsp;
<i>2041</i>&nbsp;        handles.finish(enumHandle);
<i>2042</i>&nbsp;        passHandle = enumHandle;
<i>2043</i>&nbsp;        return result;
<i>2044</i>&nbsp;    }
<i>2045</i>&nbsp;
<i>2046</i>&nbsp;    /**
<i>2047</i>&nbsp;     * Reads and returns &quot;ordinary&quot; (i.e., not a String, Class,
<i>2048</i>&nbsp;     * ObjectStreamClass, array, or enum constant) object, or null if object&#39;s
<i>2049</i>&nbsp;     * class is unresolvable (in which case a ClassNotFoundException will be
<i>2050</i>&nbsp;     * associated with object&#39;s handle).  Sets passHandle to object&#39;s assigned
<b class="nc"><i>2051</i>&nbsp;     * handle.</b>
<b class="nc"><i>2052</i>&nbsp;     */</b>
<b class="nc"><i>2053</i>&nbsp;    private Object readOrdinaryObject(boolean unshared)</b>
<b class="nc"><i>2054</i>&nbsp;        throws IOException</b>
<i>2055</i>&nbsp;    {
<b class="nc"><i>2056</i>&nbsp;        if (bin.readByte() != TC_OBJECT) {</b>
<b class="nc"><i>2057</i>&nbsp;            throw new InternalError();</b>
<b class="nc"><i>2058</i>&nbsp;        }</b>
<i>2059</i>&nbsp;
<b class="nc"><i>2060</i>&nbsp;        ObjectStreamClass desc = readClassDesc(false);</b>
<i>2061</i>&nbsp;        desc.checkDeserialize();
<b class="nc"><i>2062</i>&nbsp;</b>
<b class="nc"><i>2063</i>&nbsp;        Class&lt;?&gt; cl = desc.forClass();</b>
<i>2064</i>&nbsp;        if (cl == String.class || cl == Class.class
<i>2065</i>&nbsp;                || cl == ObjectStreamClass.class) {
<i>2066</i>&nbsp;            throw new InvalidClassException(&quot;invalid class descriptor&quot;);
<i>2067</i>&nbsp;        }
<i>2068</i>&nbsp;
<i>2069</i>&nbsp;        Object obj;
<i>2070</i>&nbsp;        try {
<b class="nc"><i>2071</i>&nbsp;            obj = desc.isInstantiable() ? desc.newInstance() : null;</b>
<b class="nc"><i>2072</i>&nbsp;        } catch (Exception ex) {</b>
<i>2073</i>&nbsp;            throw (IOException) new InvalidClassException(
<b class="nc"><i>2074</i>&nbsp;                desc.forClass().getName(),</b>
<b class="nc"><i>2075</i>&nbsp;                &quot;unable to create instance&quot;).initCause(ex);</b>
<i>2076</i>&nbsp;        }
<i>2077</i>&nbsp;
<b class="nc"><i>2078</i>&nbsp;        passHandle = handles.assign(unshared ? unsharedMarker : obj);</b>
<b class="nc"><i>2079</i>&nbsp;        ClassNotFoundException resolveEx = desc.getResolveException();</b>
<b class="nc"><i>2080</i>&nbsp;        if (resolveEx != null) {</b>
<b class="nc"><i>2081</i>&nbsp;            handles.markException(passHandle, resolveEx);</b>
<i>2082</i>&nbsp;        }
<i>2083</i>&nbsp;
<i>2084</i>&nbsp;        if (desc.isExternalizable()) {
<i>2085</i>&nbsp;            readExternalData((Externalizable) obj, desc);
<i>2086</i>&nbsp;        } else {
<i>2087</i>&nbsp;            readSerialData(obj, desc);
<i>2088</i>&nbsp;        }
<i>2089</i>&nbsp;
<i>2090</i>&nbsp;        handles.finish(passHandle);
<i>2091</i>&nbsp;
<i>2092</i>&nbsp;        if (obj != null &amp;&amp;
<i>2093</i>&nbsp;            handles.lookupException(passHandle) == null &amp;&amp;
<i>2094</i>&nbsp;            desc.hasReadResolveMethod())
<i>2095</i>&nbsp;        {
<i>2096</i>&nbsp;            Object rep = desc.invokeReadResolve(obj);
<i>2097</i>&nbsp;            if (unshared &amp;&amp; rep.getClass().isArray()) {
<i>2098</i>&nbsp;                rep = cloneArray(rep);
<i>2099</i>&nbsp;            }
<i>2100</i>&nbsp;            if (rep != obj) {
<i>2101</i>&nbsp;                // Filter the replacement object
<i>2102</i>&nbsp;                if (rep != null) {
<i>2103</i>&nbsp;                    if (rep.getClass().isArray()) {
<i>2104</i>&nbsp;                        filterCheck(rep.getClass(), Array.getLength(rep));
<b class="nc"><i>2105</i>&nbsp;                    } else {</b>
<b class="nc"><i>2106</i>&nbsp;                        filterCheck(rep.getClass(), -1);</b>
<b class="nc"><i>2107</i>&nbsp;                    }</b>
<i>2108</i>&nbsp;                }
<b class="nc"><i>2109</i>&nbsp;                handles.setObject(passHandle, obj = rep);</b>
<b class="nc"><i>2110</i>&nbsp;            }</b>
<b class="nc"><i>2111</i>&nbsp;        }</b>
<b class="nc"><i>2112</i>&nbsp;</b>
<b class="nc"><i>2113</i>&nbsp;        return obj;</b>
<b class="nc"><i>2114</i>&nbsp;    }</b>
<b class="nc"><i>2115</i>&nbsp;</b>
<b class="nc"><i>2116</i>&nbsp;    /**</b>
<b class="nc"><i>2117</i>&nbsp;     * If obj is non-null, reads externalizable data by invoking readExternal()</b>
<i>2118</i>&nbsp;     * method of obj; otherwise, attempts to skip over externalizable data.
<b class="nc"><i>2119</i>&nbsp;     * Expects that passHandle is set to obj&#39;s handle before this method is</b>
<i>2120</i>&nbsp;     * called.
<b class="nc"><i>2121</i>&nbsp;     */</b>
<b class="nc"><i>2122</i>&nbsp;    private void readExternalData(Externalizable obj, ObjectStreamClass desc)</b>
<b class="nc"><i>2123</i>&nbsp;        throws IOException</b>
<i>2124</i>&nbsp;    {
<i>2125</i>&nbsp;        SerialCallbackContext oldContext = curContext;
<i>2126</i>&nbsp;        if (oldContext != null)
<i>2127</i>&nbsp;            oldContext.check();
<i>2128</i>&nbsp;        curContext = null;
<i>2129</i>&nbsp;        try {
<i>2130</i>&nbsp;            boolean blocked = desc.hasBlockExternalData();
<b class="nc"><i>2131</i>&nbsp;            if (blocked) {</b>
<i>2132</i>&nbsp;                bin.setBlockDataMode(true);
<b class="nc"><i>2133</i>&nbsp;            }</b>
<i>2134</i>&nbsp;            if (obj != null) {
<b class="nc"><i>2135</i>&nbsp;                try {</b>
<b class="nc"><i>2136</i>&nbsp;                    obj.readExternal(this);</b>
<b class="nc"><i>2137</i>&nbsp;                } catch (ClassNotFoundException ex) {</b>
<b class="nc"><i>2138</i>&nbsp;                    /*</b>
<b class="nc"><i>2139</i>&nbsp;                     * In most cases, the handle table has already propagated</b>
<b class="nc"><i>2140</i>&nbsp;                     * a CNFException to passHandle at this point; this mark</b>
<b class="nc"><i>2141</i>&nbsp;                     * call is included to address cases where the readExternal</b>
<b class="nc"><i>2142</i>&nbsp;                     * method has cons&#39;ed and thrown a new CNFException of its</b>
<b class="nc"><i>2143</i>&nbsp;                     * own.</b>
<b class="nc"><i>2144</i>&nbsp;                     */</b>
<b class="nc"><i>2145</i>&nbsp;                     handles.markException(passHandle, ex);</b>
<i>2146</i>&nbsp;                }
<i>2147</i>&nbsp;            }
<i>2148</i>&nbsp;            if (blocked) {
<i>2149</i>&nbsp;                skipCustomData();
<i>2150</i>&nbsp;            }
<i>2151</i>&nbsp;        } finally {
<i>2152</i>&nbsp;            if (oldContext != null)
<b class="nc"><i>2153</i>&nbsp;                oldContext.check();</b>
<b class="nc"><i>2154</i>&nbsp;            curContext = oldContext;</b>
<b class="nc"><i>2155</i>&nbsp;        }</b>
<i>2156</i>&nbsp;        /*
<i>2157</i>&nbsp;         * At this point, if the externalizable data was not written in
<b class="nc"><i>2158</i>&nbsp;         * block-data form and either the externalizable class doesn&#39;t exist</b>
<b class="nc"><i>2159</i>&nbsp;         * locally (i.e., obj == null) or readExternal() just threw a</b>
<i>2160</i>&nbsp;         * CNFException, then the stream is probably in an inconsistent state,
<b class="nc"><i>2161</i>&nbsp;         * since some (or all) of the externalizable data may not have been</b>
<i>2162</i>&nbsp;         * consumed.  Since there&#39;s no &quot;correct&quot; action to take in this case,
<i>2163</i>&nbsp;         * we mimic the behavior of past serialization implementations and
<b class="nc"><i>2164</i>&nbsp;         * blindly hope that the stream is in sync; if it isn&#39;t and additional</b>
<b class="nc"><i>2165</i>&nbsp;         * externalizable data remains in the stream, a subsequent read will</b>
<b class="nc"><i>2166</i>&nbsp;         * most likely throw a StreamCorruptedException.</b>
<i>2167</i>&nbsp;         */
<b class="nc"><i>2168</i>&nbsp;    }</b>
<i>2169</i>&nbsp;
<i>2170</i>&nbsp;    /**
<i>2171</i>&nbsp;     * Reads (or attempts to skip, if obj is null or is tagged with a
<i>2172</i>&nbsp;     * ClassNotFoundException) instance data for each serializable class of
<i>2173</i>&nbsp;     * object in stream, from superclass to subclass.  Expects that passHandle
<i>2174</i>&nbsp;     * is set to obj&#39;s handle before this method is called.
<i>2175</i>&nbsp;     */
<i>2176</i>&nbsp;    private void readSerialData(Object obj, ObjectStreamClass desc)
<i>2177</i>&nbsp;        throws IOException
<i>2178</i>&nbsp;    {
<b class="nc"><i>2179</i>&nbsp;        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</b>
<i>2180</i>&nbsp;        // Best effort Failure Atomicity; slotValues will be non-null if field
<b class="nc"><i>2181</i>&nbsp;        // values can be set after reading all field data in the hierarchy.</b>
<b class="nc"><i>2182</i>&nbsp;        // Field values can only be set after reading all data if there are no</b>
<b class="nc"><i>2183</i>&nbsp;        // user observable methods in the hierarchy, readObject(NoData). The</b>
<i>2184</i>&nbsp;        // top most Serializable class in the hierarchy can be skipped.
<b class="nc"><i>2185</i>&nbsp;        FieldValues[] slotValues = null;</b>
<i>2186</i>&nbsp;
<i>2187</i>&nbsp;        boolean hasSpecialReadMethod = false;
<b class="nc"><i>2188</i>&nbsp;        for (int i = 1; i &lt; slots.length; i++) {</b>
<b class="nc"><i>2189</i>&nbsp;            ObjectStreamClass slotDesc = slots[i].desc;</b>
<i>2190</i>&nbsp;            if (slotDesc.hasReadObjectMethod()
<i>2191</i>&nbsp;                  || slotDesc.hasReadObjectNoDataMethod()) {
<b class="nc"><i>2192</i>&nbsp;                hasSpecialReadMethod = true;</b>
<b class="nc"><i>2193</i>&nbsp;                break;</b>
<i>2194</i>&nbsp;            }
<i>2195</i>&nbsp;        }
<i>2196</i>&nbsp;        // No special read methods, can store values and defer setting.
<b class="nc"><i>2197</i>&nbsp;        if (!hasSpecialReadMethod)</b>
<b class="nc"><i>2198</i>&nbsp;            slotValues = new FieldValues[slots.length];</b>
<i>2199</i>&nbsp;
<i>2200</i>&nbsp;        for (int i = 0; i &lt; slots.length; i++) {
<i>2201</i>&nbsp;            ObjectStreamClass slotDesc = slots[i].desc;
<i>2202</i>&nbsp;
<i>2203</i>&nbsp;            if (slots[i].hasData) {
<i>2204</i>&nbsp;                if (obj == null || handles.lookupException(passHandle) != null) {
<i>2205</i>&nbsp;                    defaultReadFields(null, slotDesc); // skip field values
<i>2206</i>&nbsp;                } else if (slotDesc.hasReadObjectMethod()) {
<i>2207</i>&nbsp;                    ThreadDeath t = null;
<i>2208</i>&nbsp;                    boolean reset = false;
<i>2209</i>&nbsp;                    SerialCallbackContext oldContext = curContext;
<i>2210</i>&nbsp;                    if (oldContext != null)
<b class="nc"><i>2211</i>&nbsp;                        oldContext.check();</b>
<b class="nc"><i>2212</i>&nbsp;                    try {</b>
<b class="nc"><i>2213</i>&nbsp;                        curContext = new SerialCallbackContext(obj, slotDesc);</b>
<i>2214</i>&nbsp;
<i>2215</i>&nbsp;                        bin.setBlockDataMode(true);
<b class="nc"><i>2216</i>&nbsp;                        slotDesc.invokeReadObject(obj, this);</b>
<b class="nc"><i>2217</i>&nbsp;                    } catch (ClassNotFoundException ex) {</b>
<b class="nc"><i>2218</i>&nbsp;                        /*</b>
<i>2219</i>&nbsp;                         * In most cases, the handle table has already
<b class="nc"><i>2220</i>&nbsp;                         * propagated a CNFException to passHandle at this</b>
<b class="nc"><i>2221</i>&nbsp;                         * point; this mark call is included to address cases</b>
<b class="nc"><i>2222</i>&nbsp;                         * where the custom readObject method has cons&#39;ed and</b>
<i>2223</i>&nbsp;                         * thrown a new CNFException of its own.
<i>2224</i>&nbsp;                         */
<b class="nc"><i>2225</i>&nbsp;                        handles.markException(passHandle, ex);</b>
<b class="nc"><i>2226</i>&nbsp;                    } finally {</b>
<b class="nc"><i>2227</i>&nbsp;                        do {</b>
<b class="nc"><i>2228</i>&nbsp;                            try {</b>
<b class="nc"><i>2229</i>&nbsp;                                curContext.setUsed();</b>
<b class="nc"><i>2230</i>&nbsp;                                if (oldContext!= null)</b>
<b class="nc"><i>2231</i>&nbsp;                                    oldContext.check();</b>
<b class="nc"><i>2232</i>&nbsp;                                curContext = oldContext;</b>
<b class="nc"><i>2233</i>&nbsp;                                reset = true;</b>
<i>2234</i>&nbsp;                            } catch (ThreadDeath x) {
<i>2235</i>&nbsp;                                t = x;  // defer until reset is true
<b class="nc"><i>2236</i>&nbsp;                            }</b>
<b class="nc"><i>2237</i>&nbsp;                        } while (!reset);</b>
<i>2238</i>&nbsp;                        if (t != null)
<b class="nc"><i>2239</i>&nbsp;                            throw t;</b>
<i>2240</i>&nbsp;                    }
<i>2241</i>&nbsp;
<i>2242</i>&nbsp;                    /*
<i>2243</i>&nbsp;                     * defaultDataEnd may have been set indirectly by custom
<i>2244</i>&nbsp;                     * readObject() method when calling defaultReadObject() or
<i>2245</i>&nbsp;                     * readFields(); clear it to restore normal read behavior.
<i>2246</i>&nbsp;                     */
<i>2247</i>&nbsp;                    defaultDataEnd = false;
<b class="nc"><i>2248</i>&nbsp;                } else {</b>
<b class="nc"><i>2249</i>&nbsp;                    FieldValues vals = defaultReadFields(obj, slotDesc);</b>
<i>2250</i>&nbsp;                    if (slotValues != null) {
<b class="nc"><i>2251</i>&nbsp;                        slotValues[i] = vals;</b>
<b class="nc"><i>2252</i>&nbsp;                    } else if (obj != null) {</b>
<i>2253</i>&nbsp;                        defaultCheckFieldValues(obj, slotDesc, vals);
<i>2254</i>&nbsp;                        defaultSetFieldValues(obj, slotDesc, vals);
<i>2255</i>&nbsp;                    }
<i>2256</i>&nbsp;                }
<i>2257</i>&nbsp;
<i>2258</i>&nbsp;                if (slotDesc.hasWriteObjectData()) {
<i>2259</i>&nbsp;                    skipCustomData();
<i>2260</i>&nbsp;                } else {
<b class="nc"><i>2261</i>&nbsp;                    bin.setBlockDataMode(false);</b>
<b class="nc"><i>2262</i>&nbsp;                }</b>
<i>2263</i>&nbsp;            } else {
<i>2264</i>&nbsp;                if (obj != null &amp;&amp;
<b class="nc"><i>2265</i>&nbsp;                    slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</b>
<i>2266</i>&nbsp;                    handles.lookupException(passHandle) == null)
<i>2267</i>&nbsp;                {
<i>2268</i>&nbsp;                    slotDesc.invokeReadObjectNoData(obj);
<i>2269</i>&nbsp;                }
<i>2270</i>&nbsp;            }
<i>2271</i>&nbsp;        }
<i>2272</i>&nbsp;
<i>2273</i>&nbsp;        if (obj != null &amp;&amp; slotValues != null) {
<i>2274</i>&nbsp;            // Check that the non-primitive types are assignable for all slots
<i>2275</i>&nbsp;            // before assigning.
<i>2276</i>&nbsp;            for (int i = 0; i &lt; slots.length; i++) {
<i>2277</i>&nbsp;                if (slotValues[i] != null)
<i>2278</i>&nbsp;                    defaultCheckFieldValues(obj, slots[i].desc, slotValues[i]);
<i>2279</i>&nbsp;            }
<i>2280</i>&nbsp;            for (int i = 0; i &lt; slots.length; i++) {
<i>2281</i>&nbsp;                if (slotValues[i] != null)
<i>2282</i>&nbsp;                    defaultSetFieldValues(obj, slots[i].desc, slotValues[i]);
<i>2283</i>&nbsp;            }
<i>2284</i>&nbsp;        }
<i>2285</i>&nbsp;    }
<i>2286</i>&nbsp;
<i>2287</i>&nbsp;    /**
<i>2288</i>&nbsp;     * Skips over all block data and objects until TC_ENDBLOCKDATA is
<i>2289</i>&nbsp;     * encountered.
<i>2290</i>&nbsp;     */
<i>2291</i>&nbsp;    private void skipCustomData() throws IOException {
<i>2292</i>&nbsp;        int oldHandle = passHandle;
<i>2293</i>&nbsp;        for (;;) {
<i>2294</i>&nbsp;            if (bin.getBlockDataMode()) {
<i>2295</i>&nbsp;                bin.skipBlockData();
<b class="nc"><i>2296</i>&nbsp;                bin.setBlockDataMode(false);</b>
<i>2297</i>&nbsp;            }
<i>2298</i>&nbsp;            switch (bin.peekByte()) {
<i>2299</i>&nbsp;                case TC_BLOCKDATA:
<i>2300</i>&nbsp;                case TC_BLOCKDATALONG:
<i>2301</i>&nbsp;                    bin.setBlockDataMode(true);
<i>2302</i>&nbsp;                    break;
<i>2303</i>&nbsp;
<i>2304</i>&nbsp;                case TC_ENDBLOCKDATA:
<i>2305</i>&nbsp;                    bin.readByte();
<i>2306</i>&nbsp;                    passHandle = oldHandle;
<i>2307</i>&nbsp;                    return;
<i>2308</i>&nbsp;
<i>2309</i>&nbsp;                default:
<i>2310</i>&nbsp;                    readObject0(false);
<i>2311</i>&nbsp;                    break;
<i>2312</i>&nbsp;            }
<i>2313</i>&nbsp;        }
<i>2314</i>&nbsp;    }
<i>2315</i>&nbsp;
<i>2316</i>&nbsp;    private class FieldValues {
<b class="nc"><i>2317</i>&nbsp;        final byte[] primValues;</b>
<b class="nc"><i>2318</i>&nbsp;        final Object[] objValues;</b>
<b class="nc"><i>2319</i>&nbsp;</b>
<b class="nc"><i>2320</i>&nbsp;        FieldValues(byte[] primValues, Object[] objValues) {</b>
<b class="nc"><i>2321</i>&nbsp;            this.primValues = primValues;</b>
<i>2322</i>&nbsp;            this.objValues = objValues;
<i>2323</i>&nbsp;        }
<i>2324</i>&nbsp;    }
<b class="nc"><i>2325</i>&nbsp;</b>
<i>2326</i>&nbsp;    /**
<i>2327</i>&nbsp;     * Reads in values of serializable fields declared by given class
<i>2328</i>&nbsp;     * descriptor. Expects that passHandle is set to obj&#39;s handle before this
<b class="nc"><i>2329</i>&nbsp;     * method is called.</b>
<i>2330</i>&nbsp;     */
<i>2331</i>&nbsp;    private FieldValues defaultReadFields(Object obj, ObjectStreamClass desc)
<i>2332</i>&nbsp;        throws IOException
<b class="nc"><i>2333</i>&nbsp;    {</b>
<b class="nc"><i>2334</i>&nbsp;        Class&lt;?&gt; cl = desc.forClass();</b>
<i>2335</i>&nbsp;        if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) {
<i>2336</i>&nbsp;            throw new ClassCastException();
<i>2337</i>&nbsp;        }
<b class="nc"><i>2338</i>&nbsp;</b>
<b class="nc"><i>2339</i>&nbsp;        byte[] primVals = null;</b>
<i>2340</i>&nbsp;        int primDataSize = desc.getPrimDataSize();
<i>2341</i>&nbsp;        if (primDataSize &gt; 0) {
<i>2342</i>&nbsp;            primVals = new byte[primDataSize];
<b class="nc"><i>2343</i>&nbsp;            bin.readFully(primVals, 0, primDataSize, false);</b>
<b class="nc"><i>2344</i>&nbsp;        }</b>
<i>2345</i>&nbsp;
<i>2346</i>&nbsp;        Object[] objVals = null;
<i>2347</i>&nbsp;        int numObjFields = desc.getNumObjFields();
<b class="nc"><i>2348</i>&nbsp;        if (numObjFields &gt; 0) {</b>
<b class="nc"><i>2349</i>&nbsp;            int objHandle = passHandle;</b>
<i>2350</i>&nbsp;            ObjectStreamField[] fields = desc.getFields(false);
<i>2351</i>&nbsp;            objVals = new Object[numObjFields];
<i>2352</i>&nbsp;            int numPrimFields = fields.length - objVals.length;
<b class="nc"><i>2353</i>&nbsp;            for (int i = 0; i &lt; objVals.length; i++) {</b>
<b class="nc"><i>2354</i>&nbsp;                ObjectStreamField f = fields[numPrimFields + i];</b>
<i>2355</i>&nbsp;                objVals[i] = readObject0(f.isUnshared());
<i>2356</i>&nbsp;                if (f.getField() != null) {
<i>2357</i>&nbsp;                    handles.markDependency(objHandle, passHandle);
<b class="nc"><i>2358</i>&nbsp;                }</b>
<b class="nc"><i>2359</i>&nbsp;            }</b>
<i>2360</i>&nbsp;            passHandle = objHandle;
<i>2361</i>&nbsp;        }
<i>2362</i>&nbsp;
<b class="nc"><i>2363</i>&nbsp;        return new FieldValues(primVals, objVals);</b>
<b class="nc"><i>2364</i>&nbsp;    }</b>
<i>2365</i>&nbsp;
<i>2366</i>&nbsp;    /** Throws ClassCastException if any value is not assignable. */
<i>2367</i>&nbsp;    private void defaultCheckFieldValues(Object obj, ObjectStreamClass desc,
<b class="nc"><i>2368</i>&nbsp;                                         FieldValues values) {</b>
<b class="nc"><i>2369</i>&nbsp;        Object[] objectValues = values.objValues;</b>
<i>2370</i>&nbsp;        if (objectValues != null)
<i>2371</i>&nbsp;            desc.checkObjFieldValueTypes(obj, objectValues);
<i>2372</i>&nbsp;    }
<b class="nc"><i>2373</i>&nbsp;</b>
<b class="nc"><i>2374</i>&nbsp;    /** Sets field values in obj. */</b>
<b class="nc"><i>2375</i>&nbsp;    private void defaultSetFieldValues(Object obj, ObjectStreamClass desc,</b>
<b class="nc"><i>2376</i>&nbsp;                                       FieldValues values) {</b>
<b class="nc"><i>2377</i>&nbsp;        byte[] primValues = values.primValues;</b>
<i>2378</i>&nbsp;        Object[] objectValues = values.objValues;
<i>2379</i>&nbsp;
<b class="nc"><i>2380</i>&nbsp;        if (primValues != null)</b>
<i>2381</i>&nbsp;            desc.setPrimFieldValues(obj, primValues);
<i>2382</i>&nbsp;        if (objectValues != null)
<i>2383</i>&nbsp;            desc.setObjFieldValues(obj, objectValues);
<i>2384</i>&nbsp;    }
<i>2385</i>&nbsp;
<i>2386</i>&nbsp;    /**
<i>2387</i>&nbsp;     * Reads in and returns IOException that caused serialization to abort.
<b class="nc"><i>2388</i>&nbsp;     * All stream state is discarded prior to reading in fatal exception.  Sets</b>
<i>2389</i>&nbsp;     * passHandle to fatal exception&#39;s handle.
<b class="nc"><i>2390</i>&nbsp;     */</b>
<b class="nc"><i>2391</i>&nbsp;    private IOException readFatalException() throws IOException {</b>
<b class="nc"><i>2392</i>&nbsp;        if (bin.readByte() != TC_EXCEPTION) {</b>
<b class="nc"><i>2393</i>&nbsp;            throw new InternalError();</b>
<b class="nc"><i>2394</i>&nbsp;        }</b>
<b class="nc"><i>2395</i>&nbsp;        clear();</b>
<b class="nc"><i>2396</i>&nbsp;        return (IOException) readObject0(false);</b>
<i>2397</i>&nbsp;    }
<b class="nc"><i>2398</i>&nbsp;</b>
<i>2399</i>&nbsp;    /**
<i>2400</i>&nbsp;     * If recursion depth is 0, clears internal data structures; otherwise,
<i>2401</i>&nbsp;     * throws a StreamCorruptedException.  This method is called when a
<i>2402</i>&nbsp;     * TC_RESET typecode is encountered.
<i>2403</i>&nbsp;     */
<i>2404</i>&nbsp;    private void handleReset() throws StreamCorruptedException {
<i>2405</i>&nbsp;        if (depth &gt; 0) {
<i>2406</i>&nbsp;            throw new StreamCorruptedException(
<i>2407</i>&nbsp;                &quot;unexpected reset; recursion depth: &quot; + depth);
<i>2408</i>&nbsp;        }
<i>2409</i>&nbsp;        clear();
<i>2410</i>&nbsp;    }
<b class="nc"><i>2411</i>&nbsp;</b>
<b class="nc"><i>2412</i>&nbsp;    /**</b>
<b class="nc"><i>2413</i>&nbsp;     * Converts specified span of bytes into float values.</b>
<b class="nc"><i>2414</i>&nbsp;     */</b>
<b class="nc"><i>2415</i>&nbsp;    // REMIND: remove once hotspot inlines Float.intBitsToFloat</b>
<i>2416</i>&nbsp;    private static native void bytesToFloats(byte[] src, int srcpos,
<b class="nc"><i>2417</i>&nbsp;                                             float[] dst, int dstpos,</b>
<i>2418</i>&nbsp;                                             int nfloats);
<i>2419</i>&nbsp;
<i>2420</i>&nbsp;    /**
<i>2421</i>&nbsp;     * Converts specified span of bytes into double values.
<i>2422</i>&nbsp;     */
<i>2423</i>&nbsp;    // REMIND: remove once hotspot inlines Double.longBitsToDouble
<i>2424</i>&nbsp;    private static native void bytesToDoubles(byte[] src, int srcpos,
<i>2425</i>&nbsp;                                              double[] dst, int dstpos,
<i>2426</i>&nbsp;                                              int ndoubles);
<b class="nc"><i>2427</i>&nbsp;</b>
<i>2428</i>&nbsp;    /**
<i>2429</i>&nbsp;     * Returns the first non-null and non-platform class loader (not counting
<i>2430</i>&nbsp;     * class loaders of generated reflection implementation classes) up the
<i>2431</i>&nbsp;     * execution stack, or the platform class loader if only code from the
<i>2432</i>&nbsp;     * bootstrap and platform class loader is on the stack.
<i>2433</i>&nbsp;     */
<i>2434</i>&nbsp;    private static ClassLoader latestUserDefinedLoader() {
<i>2435</i>&nbsp;        return jdk.internal.misc.VM.latestUserDefinedLoader();
<i>2436</i>&nbsp;    }
<b class="nc"><i>2437</i>&nbsp;</b>
<b class="nc"><i>2438</i>&nbsp;    /**</b>
<b class="nc"><i>2439</i>&nbsp;     * Default GetField implementation.</b>
<b class="nc"><i>2440</i>&nbsp;     */</b>
<b class="nc"><i>2441</i>&nbsp;    private class GetFieldImpl extends GetField {</b>
<i>2442</i>&nbsp;
<i>2443</i>&nbsp;        /** class descriptor describing serializable fields */
<i>2444</i>&nbsp;        private final ObjectStreamClass desc;
<i>2445</i>&nbsp;        /** primitive field values */
<i>2446</i>&nbsp;        private final byte[] primVals;
<i>2447</i>&nbsp;        /** object field values */
<i>2448</i>&nbsp;        private final Object[] objVals;
<i>2449</i>&nbsp;        /** object field value handles */
<i>2450</i>&nbsp;        private final int[] objHandles;
<b class="nc"><i>2451</i>&nbsp;</b>
<i>2452</i>&nbsp;        /**
<i>2453</i>&nbsp;         * Creates GetFieldImpl object for reading fields defined in given
<i>2454</i>&nbsp;         * class descriptor.
<i>2455</i>&nbsp;         */
<i>2456</i>&nbsp;        GetFieldImpl(ObjectStreamClass desc) {
<i>2457</i>&nbsp;            this.desc = desc;
<i>2458</i>&nbsp;            primVals = new byte[desc.getPrimDataSize()];
<i>2459</i>&nbsp;            objVals = new Object[desc.getNumObjFields()];
<i>2460</i>&nbsp;            objHandles = new int[objVals.length];
<b class="nc"><i>2461</i>&nbsp;        }</b>
<b class="nc"><i>2462</i>&nbsp;</b>
<i>2463</i>&nbsp;        public ObjectStreamClass getObjectStreamClass() {
<i>2464</i>&nbsp;            return desc;
<b class="nc"><i>2465</i>&nbsp;        }</b>
<b class="nc"><i>2466</i>&nbsp;</b>
<b class="nc"><i>2467</i>&nbsp;        public boolean defaulted(String name) throws IOException {</b>
<b class="nc"><i>2468</i>&nbsp;            return (getFieldOffset(name, null) &lt; 0);</b>
<i>2469</i>&nbsp;        }
<b class="nc"><i>2470</i>&nbsp;</b>
<b class="nc"><i>2471</i>&nbsp;        public boolean get(String name, boolean val) throws IOException {</b>
<b class="nc"><i>2472</i>&nbsp;            int off = getFieldOffset(name, Boolean.TYPE);</b>
<i>2473</i>&nbsp;            return (off &gt;= 0) ? Bits.getBoolean(primVals, off) : val;
<b class="nc"><i>2474</i>&nbsp;        }</b>
<i>2475</i>&nbsp;
<i>2476</i>&nbsp;        public byte get(String name, byte val) throws IOException {
<i>2477</i>&nbsp;            int off = getFieldOffset(name, Byte.TYPE);
<i>2478</i>&nbsp;            return (off &gt;= 0) ? primVals[off] : val;
<i>2479</i>&nbsp;        }
<i>2480</i>&nbsp;
<i>2481</i>&nbsp;        public char get(String name, char val) throws IOException {
<i>2482</i>&nbsp;            int off = getFieldOffset(name, Character.TYPE);
<i>2483</i>&nbsp;            return (off &gt;= 0) ? Bits.getChar(primVals, off) : val;
<i>2484</i>&nbsp;        }
<i>2485</i>&nbsp;
<i>2486</i>&nbsp;        public short get(String name, short val) throws IOException {
<b class="nc"><i>2487</i>&nbsp;            int off = getFieldOffset(name, Short.TYPE);</b>
<b class="nc"><i>2488</i>&nbsp;            return (off &gt;= 0) ? Bits.getShort(primVals, off) : val;</b>
<i>2489</i>&nbsp;        }
<b class="nc"><i>2490</i>&nbsp;</b>
<i>2491</i>&nbsp;        public int get(String name, int val) throws IOException {
<b class="nc"><i>2492</i>&nbsp;            int off = getFieldOffset(name, Integer.TYPE);</b>
<b class="nc"><i>2493</i>&nbsp;            return (off &gt;= 0) ? Bits.getInt(primVals, off) : val;</b>
<i>2494</i>&nbsp;        }
<i>2495</i>&nbsp;
<b class="nc"><i>2496</i>&nbsp;        public float get(String name, float val) throws IOException {</b>
<i>2497</i>&nbsp;            int off = getFieldOffset(name, Float.TYPE);
<b class="nc"><i>2498</i>&nbsp;            return (off &gt;= 0) ? Bits.getFloat(primVals, off) : val;</b>
<b class="nc"><i>2499</i>&nbsp;        }</b>
<b class="nc"><i>2500</i>&nbsp;</b>
<b class="nc"><i>2501</i>&nbsp;        public long get(String name, long val) throws IOException {</b>
<i>2502</i>&nbsp;            int off = getFieldOffset(name, Long.TYPE);
<i>2503</i>&nbsp;            return (off &gt;= 0) ? Bits.getLong(primVals, off) : val;
<i>2504</i>&nbsp;        }
<i>2505</i>&nbsp;
<i>2506</i>&nbsp;        public double get(String name, double val) throws IOException {
<i>2507</i>&nbsp;            int off = getFieldOffset(name, Double.TYPE);
<b class="nc"><i>2508</i>&nbsp;            return (off &gt;= 0) ? Bits.getDouble(primVals, off) : val;</b>
<i>2509</i>&nbsp;        }
<i>2510</i>&nbsp;
<i>2511</i>&nbsp;        public Object get(String name, Object val) throws IOException {
<i>2512</i>&nbsp;            int off = getFieldOffset(name, Object.class);
<i>2513</i>&nbsp;            if (off &gt;= 0) {
<i>2514</i>&nbsp;                int objHandle = objHandles[off];
<i>2515</i>&nbsp;                handles.markDependency(passHandle, objHandle);
<i>2516</i>&nbsp;                return (handles.lookupException(objHandle) == null) ?
<i>2517</i>&nbsp;                    objVals[off] : null;
<i>2518</i>&nbsp;            } else {
<i>2519</i>&nbsp;                return val;
<i>2520</i>&nbsp;            }
<i>2521</i>&nbsp;        }
<i>2522</i>&nbsp;
<b class="nc"><i>2523</i>&nbsp;        /**</b>
<b class="nc"><i>2524</i>&nbsp;         * Reads primitive and object field values from stream.</b>
<b class="nc"><i>2525</i>&nbsp;         */</b>
<b class="nc"><i>2526</i>&nbsp;        void readFields() throws IOException {</b>
<b class="nc"><i>2527</i>&nbsp;            bin.readFully(primVals, 0, primVals.length, false);</b>
<b class="nc"><i>2528</i>&nbsp;</b>
<i>2529</i>&nbsp;            int oldHandle = passHandle;
<i>2530</i>&nbsp;            ObjectStreamField[] fields = desc.getFields(false);
<i>2531</i>&nbsp;            int numPrimFields = fields.length - objVals.length;
<i>2532</i>&nbsp;            for (int i = 0; i &lt; objVals.length; i++) {
<b class="nc"><i>2533</i>&nbsp;                objVals[i] =</b>
<i>2534</i>&nbsp;                    readObject0(fields[numPrimFields + i].isUnshared());
<i>2535</i>&nbsp;                objHandles[i] = passHandle;
<i>2536</i>&nbsp;            }
<i>2537</i>&nbsp;            passHandle = oldHandle;
<b class="nc"><i>2538</i>&nbsp;        }</b>
<i>2539</i>&nbsp;
<i>2540</i>&nbsp;        /**
<i>2541</i>&nbsp;         * Returns offset of field with given name and type.  A specified type
<i>2542</i>&nbsp;         * of null matches all types, Object.class matches all non-primitive
<b class="nc"><i>2543</i>&nbsp;         * types, and any other non-null type matches assignable types only.</b>
<i>2544</i>&nbsp;         * If no matching field is found in the (incoming) class
<i>2545</i>&nbsp;         * descriptor but a matching field is present in the associated local
<i>2546</i>&nbsp;         * class descriptor, returns -1.  Throws IllegalArgumentException if
<i>2547</i>&nbsp;         * neither incoming nor local class descriptor contains a match.
<b class="nc"><i>2548</i>&nbsp;         */</b>
<i>2549</i>&nbsp;        private int getFieldOffset(String name, Class&lt;?&gt; type) {
<i>2550</i>&nbsp;            ObjectStreamField field = desc.getField(name, type);
<i>2551</i>&nbsp;            if (field != null) {
<i>2552</i>&nbsp;                return field.getOffset();
<b class="nc"><i>2553</i>&nbsp;            } else if (desc.getLocalDesc().getField(name, type) != null) {</b>
<i>2554</i>&nbsp;                return -1;
<i>2555</i>&nbsp;            } else {
<i>2556</i>&nbsp;                throw new IllegalArgumentException(&quot;no such field &quot; + name +
<i>2557</i>&nbsp;                                                   &quot; with type &quot; + type);
<i>2558</i>&nbsp;            }
<i>2559</i>&nbsp;        }
<i>2560</i>&nbsp;    }
<i>2561</i>&nbsp;
<i>2562</i>&nbsp;    /**
<i>2563</i>&nbsp;     * Prioritized list of callbacks to be performed once object graph has been
<i>2564</i>&nbsp;     * completely deserialized.
<b class="nc"><i>2565</i>&nbsp;     */</b>
<i>2566</i>&nbsp;    private static class ValidationList {
<b class="nc"><i>2567</i>&nbsp;</b>
<i>2568</i>&nbsp;        private static class Callback {
<i>2569</i>&nbsp;            final ObjectInputValidation obj;
<i>2570</i>&nbsp;            final int priority;
<i>2571</i>&nbsp;            Callback next;
<b class="nc"><i>2572</i>&nbsp;            final AccessControlContext acc;</b>
<b class="nc"><i>2573</i>&nbsp;</b>
<i>2574</i>&nbsp;            Callback(ObjectInputValidation obj, int priority, Callback next,
<i>2575</i>&nbsp;                AccessControlContext acc)
<i>2576</i>&nbsp;            {
<i>2577</i>&nbsp;                this.obj = obj;
<i>2578</i>&nbsp;                this.priority = priority;
<i>2579</i>&nbsp;                this.next = next;
<i>2580</i>&nbsp;                this.acc = acc;
<b class="nc"><i>2581</i>&nbsp;            }</b>
<b class="nc"><i>2582</i>&nbsp;        }</b>
<i>2583</i>&nbsp;
<b class="nc"><i>2584</i>&nbsp;        /** linked list of callbacks */</b>
<b class="nc"><i>2585</i>&nbsp;        private Callback list;</b>
<b class="nc"><i>2586</i>&nbsp;</b>
<i>2587</i>&nbsp;        /**
<i>2588</i>&nbsp;         * Creates new (empty) ValidationList.
<i>2589</i>&nbsp;         */
<b class="nc"><i>2590</i>&nbsp;        ValidationList() {</b>
<b class="nc"><i>2591</i>&nbsp;        }</b>
<b class="nc"><i>2592</i>&nbsp;</b>
<b class="nc"><i>2593</i>&nbsp;        /**</b>
<i>2594</i>&nbsp;         * Registers callback.  Throws InvalidObjectException if callback
<b class="nc"><i>2595</i>&nbsp;         * object is null.</b>
<b class="nc"><i>2596</i>&nbsp;         */</b>
<b class="nc"><i>2597</i>&nbsp;        void register(ObjectInputValidation obj, int priority)</b>
<i>2598</i>&nbsp;            throws InvalidObjectException
<i>2599</i>&nbsp;        {
<i>2600</i>&nbsp;            if (obj == null) {
<i>2601</i>&nbsp;                throw new InvalidObjectException(&quot;null callback&quot;);
<i>2602</i>&nbsp;            }
<b class="nc"><i>2603</i>&nbsp;</b>
<b class="nc"><i>2604</i>&nbsp;            Callback prev = null, cur = list;</b>
<b class="nc"><i>2605</i>&nbsp;            while (cur != null &amp;&amp; priority &lt; cur.priority) {</b>
<b class="nc"><i>2606</i>&nbsp;                prev = cur;</b>
<b class="nc"><i>2607</i>&nbsp;                cur = cur.next;</b>
<b class="nc"><i>2608</i>&nbsp;            }</b>
<i>2609</i>&nbsp;            AccessControlContext acc = AccessController.getContext();
<b class="nc"><i>2610</i>&nbsp;            if (prev != null) {</b>
<b class="nc"><i>2611</i>&nbsp;                prev.next = new Callback(obj, priority, cur, acc);</b>
<b class="nc"><i>2612</i>&nbsp;            } else {</b>
<b class="nc"><i>2613</i>&nbsp;                list = new Callback(obj, priority, list, acc);</b>
<b class="nc"><i>2614</i>&nbsp;            }</b>
<b class="nc"><i>2615</i>&nbsp;        }</b>
<i>2616</i>&nbsp;
<i>2617</i>&nbsp;        /**
<i>2618</i>&nbsp;         * Invokes all registered callbacks and clears the callback list.
<i>2619</i>&nbsp;         * Callbacks with higher priorities are called first; those with equal
<b class="nc"><i>2620</i>&nbsp;         * priorities may be called in any order.  If any of the callbacks</b>
<b class="nc"><i>2621</i>&nbsp;         * throws an InvalidObjectException, the callback process is terminated</b>
<b class="nc"><i>2622</i>&nbsp;         * and the exception propagated upwards.</b>
<b class="nc"><i>2623</i>&nbsp;         */</b>
<b class="nc"><i>2624</i>&nbsp;        void doCallbacks() throws InvalidObjectException {</b>
<i>2625</i>&nbsp;            try {
<b class="nc"><i>2626</i>&nbsp;                while (list != null) {</b>
<b class="nc"><i>2627</i>&nbsp;                    AccessController.doPrivileged(</b>
<i>2628</i>&nbsp;                        new PrivilegedExceptionAction&lt;Void&gt;()
<i>2629</i>&nbsp;                    {
<i>2630</i>&nbsp;                        public Void run() throws InvalidObjectException {
<b class="nc"><i>2631</i>&nbsp;                            list.obj.validateObject();</b>
<b class="nc"><i>2632</i>&nbsp;                            return null;</b>
<i>2633</i>&nbsp;                        }
<b class="nc"><i>2634</i>&nbsp;                    }, list.acc);</b>
<b class="nc"><i>2635</i>&nbsp;                    list = list.next;</b>
<b class="nc"><i>2636</i>&nbsp;                }</b>
<b class="nc"><i>2637</i>&nbsp;            } catch (PrivilegedActionException ex) {</b>
<b class="nc"><i>2638</i>&nbsp;                list = null;</b>
<i>2639</i>&nbsp;                throw (InvalidObjectException) ex.getException();
<b class="nc"><i>2640</i>&nbsp;            }</b>
<b class="nc"><i>2641</i>&nbsp;        }</b>
<b class="nc"><i>2642</i>&nbsp;</b>
<i>2643</i>&nbsp;        /**
<i>2644</i>&nbsp;         * Resets the callback list to its initial (empty) state.
<i>2645</i>&nbsp;         */
<b class="nc"><i>2646</i>&nbsp;        public void clear() {</b>
<i>2647</i>&nbsp;            list = null;
<i>2648</i>&nbsp;        }
<i>2649</i>&nbsp;    }
<b class="nc"><i>2650</i>&nbsp;</b>
<i>2651</i>&nbsp;    /**
<i>2652</i>&nbsp;     * Hold a snapshot of values to be passed to an ObjectInputFilter.
<i>2653</i>&nbsp;     */
<b class="nc"><i>2654</i>&nbsp;    static class FilterValues implements ObjectInputFilter.FilterInfo {</b>
<i>2655</i>&nbsp;        final Class&lt;?&gt; clazz;
<i>2656</i>&nbsp;        final long arrayLength;
<i>2657</i>&nbsp;        final long totalObjectRefs;
<i>2658</i>&nbsp;        final long depth;
<i>2659</i>&nbsp;        final long streamBytes;
<i>2660</i>&nbsp;
<i>2661</i>&nbsp;        public FilterValues(Class&lt;?&gt; clazz, long arrayLength, long totalObjectRefs,
<i>2662</i>&nbsp;                            long depth, long streamBytes) {
<i>2663</i>&nbsp;            this.clazz = clazz;
<i>2664</i>&nbsp;            this.arrayLength = arrayLength;
<i>2665</i>&nbsp;            this.totalObjectRefs = totalObjectRefs;
<i>2666</i>&nbsp;            this.depth = depth;
<i>2667</i>&nbsp;            this.streamBytes = streamBytes;
<i>2668</i>&nbsp;        }
<i>2669</i>&nbsp;
<i>2670</i>&nbsp;        @Override
<i>2671</i>&nbsp;        public Class&lt;?&gt; serialClass() {
<i>2672</i>&nbsp;            return clazz;
<i>2673</i>&nbsp;        }
<i>2674</i>&nbsp;
<i>2675</i>&nbsp;        @Override
<i>2676</i>&nbsp;        public long arrayLength() {
<i>2677</i>&nbsp;            return arrayLength;
<i>2678</i>&nbsp;        }
<b class="nc"><i>2679</i>&nbsp;</b>
<i>2680</i>&nbsp;        @Override
<b class="nc"><i>2681</i>&nbsp;        public long references() {</b>
<i>2682</i>&nbsp;            return totalObjectRefs;
<b class="nc"><i>2683</i>&nbsp;        }</b>
<i>2684</i>&nbsp;
<i>2685</i>&nbsp;        @Override
<b class="nc"><i>2686</i>&nbsp;        public long depth() {</b>
<i>2687</i>&nbsp;            return depth;
<i>2688</i>&nbsp;        }
<i>2689</i>&nbsp;
<b class="nc"><i>2690</i>&nbsp;        @Override</b>
<i>2691</i>&nbsp;        public long streamBytes() {
<b class="nc"><i>2692</i>&nbsp;            return streamBytes;</b>
<i>2693</i>&nbsp;        }
<b class="nc"><i>2694</i>&nbsp;    }</b>
<i>2695</i>&nbsp;
<i>2696</i>&nbsp;    /**
<i>2697</i>&nbsp;     * Input stream supporting single-byte peek operations.
<i>2698</i>&nbsp;     */
<i>2699</i>&nbsp;    private static class PeekInputStream extends InputStream {
<i>2700</i>&nbsp;
<i>2701</i>&nbsp;        /** underlying stream */
<i>2702</i>&nbsp;        private final InputStream in;
<i>2703</i>&nbsp;        /** peeked byte */
<i>2704</i>&nbsp;        private int peekb = -1;
<b class="nc"><i>2705</i>&nbsp;        /** total bytes read from the stream */</b>
<b class="nc"><i>2706</i>&nbsp;        private long totalBytesRead = 0;</b>
<b class="nc"><i>2707</i>&nbsp;</b>
<i>2708</i>&nbsp;        /**
<i>2709</i>&nbsp;         * Creates new PeekInputStream on top of given underlying stream.
<i>2710</i>&nbsp;         */
<i>2711</i>&nbsp;        PeekInputStream(InputStream in) {
<i>2712</i>&nbsp;            this.in = in;
<i>2713</i>&nbsp;        }
<i>2714</i>&nbsp;
<i>2715</i>&nbsp;        /**
<i>2716</i>&nbsp;         * Peeks at next byte value in stream.  Similar to read(), except
<i>2717</i>&nbsp;         * that it does not consume the read value.
<b class="nc"><i>2718</i>&nbsp;         */</b>
<b class="nc"><i>2719</i>&nbsp;        int peek() throws IOException {</b>
<i>2720</i>&nbsp;            if (peekb &gt;= 0) {
<b class="nc"><i>2721</i>&nbsp;                return peekb;</b>
<b class="nc"><i>2722</i>&nbsp;            }</b>
<b class="nc"><i>2723</i>&nbsp;            peekb = in.read();</b>
<b class="nc"><i>2724</i>&nbsp;            totalBytesRead += peekb &gt;= 0 ? 1 : 0;</b>
<b class="nc"><i>2725</i>&nbsp;            return peekb;</b>
<b class="nc"><i>2726</i>&nbsp;        }</b>
<i>2727</i>&nbsp;
<b class="nc"><i>2728</i>&nbsp;        public int read() throws IOException {</b>
<b class="nc"><i>2729</i>&nbsp;            if (peekb &gt;= 0) {</b>
<i>2730</i>&nbsp;                int v = peekb;
<i>2731</i>&nbsp;                peekb = -1;
<i>2732</i>&nbsp;                return v;
<i>2733</i>&nbsp;            } else {
<i>2734</i>&nbsp;                int nbytes = in.read();
<i>2735</i>&nbsp;                totalBytesRead += nbytes &gt;= 0 ? 1 : 0;
<i>2736</i>&nbsp;                return nbytes;
<b class="nc"><i>2737</i>&nbsp;            }</b>
<i>2738</i>&nbsp;        }
<i>2739</i>&nbsp;
<i>2740</i>&nbsp;        public int read(byte[] b, int off, int len) throws IOException {
<i>2741</i>&nbsp;            int nbytes;
<i>2742</i>&nbsp;            if (len == 0) {
<i>2743</i>&nbsp;                return 0;
<i>2744</i>&nbsp;            } else if (peekb &lt; 0) {
<i>2745</i>&nbsp;                nbytes = in.read(b, off, len);
<b class="nc"><i>2746</i>&nbsp;                totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;</b>
<b class="nc"><i>2747</i>&nbsp;                return nbytes;</b>
<i>2748</i>&nbsp;            } else {
<b class="nc"><i>2749</i>&nbsp;                b[off++] = (byte) peekb;</b>
<b class="nc"><i>2750</i>&nbsp;                len--;</b>
<i>2751</i>&nbsp;                peekb = -1;
<i>2752</i>&nbsp;                nbytes = in.read(b, off, len);
<i>2753</i>&nbsp;                totalBytesRead += nbytes &gt;= 0 ? nbytes : 0;
<i>2754</i>&nbsp;                return (nbytes &gt;= 0) ? (nbytes + 1) : 1;
<i>2755</i>&nbsp;            }
<i>2756</i>&nbsp;        }
<i>2757</i>&nbsp;
<i>2758</i>&nbsp;        void readFully(byte[] b, int off, int len) throws IOException {
<i>2759</i>&nbsp;            int n = 0;
<i>2760</i>&nbsp;            while (n &lt; len) {
<i>2761</i>&nbsp;                int count = read(b, off + n, len - n);
<b class="nc"><i>2762</i>&nbsp;                if (count &lt; 0) {</b>
<i>2763</i>&nbsp;                    throw new EOFException();
<i>2764</i>&nbsp;                }
<i>2765</i>&nbsp;                n += count;
<i>2766</i>&nbsp;            }
<i>2767</i>&nbsp;        }
<i>2768</i>&nbsp;
<b class="nc"><i>2769</i>&nbsp;        public long skip(long n) throws IOException {</b>
<i>2770</i>&nbsp;            if (n &lt;= 0) {
<i>2771</i>&nbsp;                return 0;
<i>2772</i>&nbsp;            }
<b class="nc"><i>2773</i>&nbsp;            int skipped = 0;</b>
<b class="nc"><i>2774</i>&nbsp;            if (peekb &gt;= 0) {</b>
<b class="nc"><i>2775</i>&nbsp;                peekb = -1;</b>
<i>2776</i>&nbsp;                skipped++;
<i>2777</i>&nbsp;                n--;
<b class="nc"><i>2778</i>&nbsp;            }</b>
<b class="nc"><i>2779</i>&nbsp;            n = skipped + in.skip(n);</b>
<i>2780</i>&nbsp;            totalBytesRead += n;
<b class="nc"><i>2781</i>&nbsp;            return n;</b>
<b class="nc"><i>2782</i>&nbsp;        }</b>
<i>2783</i>&nbsp;
<b class="nc"><i>2784</i>&nbsp;        public int available() throws IOException {</b>
<b class="nc"><i>2785</i>&nbsp;            return in.available() + ((peekb &gt;= 0) ? 1 : 0);</b>
<i>2786</i>&nbsp;        }
<i>2787</i>&nbsp;
<b class="nc"><i>2788</i>&nbsp;        public void close() throws IOException {</b>
<b class="nc"><i>2789</i>&nbsp;            in.close();</b>
<i>2790</i>&nbsp;        }
<b class="nc"><i>2791</i>&nbsp;</b>
<b class="nc"><i>2792</i>&nbsp;        public long getBytesRead() {</b>
<b class="nc"><i>2793</i>&nbsp;            return totalBytesRead;</b>
<b class="nc"><i>2794</i>&nbsp;        }</b>
<i>2795</i>&nbsp;    }
<i>2796</i>&nbsp;
<i>2797</i>&nbsp;    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
<b class="nc"><i>2798</i>&nbsp;</b>
<i>2799</i>&nbsp;    /**
<i>2800</i>&nbsp;     * Performs a &quot;freeze&quot; action, required to adhere to final field semantics.
<i>2801</i>&nbsp;     *
<i>2802</i>&nbsp;     * &lt;p&gt; This method can be called unconditionally before returning the graph,
<i>2803</i>&nbsp;     * from the topmost readObject call, since it is expected that the
<i>2804</i>&nbsp;     * additional cost of the freeze action is negligible compared to
<i>2805</i>&nbsp;     * reconstituting even the most simple graph.
<i>2806</i>&nbsp;     *
<b class="nc"><i>2807</i>&nbsp;     * &lt;p&gt; Nested calls to readObject do not issue freeze actions because the</b>
<b class="nc"><i>2808</i>&nbsp;     * sub-graph returned from a nested call is not guaranteed to be fully</b>
<b class="nc"><i>2809</i>&nbsp;     * initialized yet (possible cycles).</b>
<i>2810</i>&nbsp;     */
<i>2811</i>&nbsp;    private void freeze() {
<b class="nc"><i>2812</i>&nbsp;        // Issue a StoreStore|StoreLoad fence, which is at least sufficient</b>
<b class="nc"><i>2813</i>&nbsp;        // to provide final-freeze semantics.</b>
<b class="nc"><i>2814</i>&nbsp;        UNSAFE.storeFence();</b>
<b class="nc"><i>2815</i>&nbsp;    }</b>
<i>2816</i>&nbsp;
<b class="nc"><i>2817</i>&nbsp;    /**</b>
<i>2818</i>&nbsp;     * Input stream with two modes: in default mode, inputs data written in the
<b class="nc"><i>2819</i>&nbsp;     * same format as DataOutputStream; in &quot;block data&quot; mode, inputs data</b>
<b class="nc"><i>2820</i>&nbsp;     * bracketed by block data markers (see object serialization specification</b>
<b class="nc"><i>2821</i>&nbsp;     * for details).  Buffering depends on block data mode: when in default</b>
<i>2822</i>&nbsp;     * mode, no data is buffered in advance; when in block data mode, all data
<i>2823</i>&nbsp;     * for the current data block is read in at once (and buffered).
<i>2824</i>&nbsp;     */
<i>2825</i>&nbsp;    private class BlockDataInputStream
<i>2826</i>&nbsp;        extends InputStream implements DataInput
<i>2827</i>&nbsp;    {
<i>2828</i>&nbsp;        /** maximum data block length */
<i>2829</i>&nbsp;        private static final int MAX_BLOCK_SIZE = 1024;
<i>2830</i>&nbsp;        /** maximum data block header length */
<i>2831</i>&nbsp;        private static final int MAX_HEADER_SIZE = 5;
<i>2832</i>&nbsp;        /** (tunable) length of char buffer (for reading strings) */
<i>2833</i>&nbsp;        private static final int CHAR_BUF_SIZE = 256;
<i>2834</i>&nbsp;        /** readBlockHeader() return value indicating header read may block */
<i>2835</i>&nbsp;        private static final int HEADER_BLOCKED = -2;
<b class="nc"><i>2836</i>&nbsp;</b>
<b class="nc"><i>2837</i>&nbsp;        /** buffer for reading general/block data */</b>
<b class="nc"><i>2838</i>&nbsp;        private final byte[] buf = new byte[MAX_BLOCK_SIZE];</b>
<b class="nc"><i>2839</i>&nbsp;        /** buffer for reading block data headers */</b>
<b class="nc"><i>2840</i>&nbsp;        private final byte[] hbuf = new byte[MAX_HEADER_SIZE];</b>
<b class="nc"><i>2841</i>&nbsp;        /** char buffer for fast string reads */</b>
<b class="nc"><i>2842</i>&nbsp;        private final char[] cbuf = new char[CHAR_BUF_SIZE];</b>
<i>2843</i>&nbsp;
<b class="nc"><i>2844</i>&nbsp;        /** block data mode */</b>
<i>2845</i>&nbsp;        private boolean blkmode = false;
<i>2846</i>&nbsp;
<b class="nc"><i>2847</i>&nbsp;        // block data state fields; values meaningful only when blkmode true</b>
<b class="nc"><i>2848</i>&nbsp;        /** current offset into buf */</b>
<b class="nc"><i>2849</i>&nbsp;        private int pos = 0;</b>
<b class="nc"><i>2850</i>&nbsp;        /** end offset of valid data in buf, or -1 if no more block data */</b>
<b class="nc"><i>2851</i>&nbsp;        private int end = -1;</b>
<i>2852</i>&nbsp;        /** number of bytes in current block yet to be read from stream */
<b class="nc"><i>2853</i>&nbsp;        private int unread = 0;</b>
<b class="nc"><i>2854</i>&nbsp;</b>
<i>2855</i>&nbsp;        /** underlying stream (wrapped in peekable filter stream) */
<i>2856</i>&nbsp;        private final PeekInputStream in;
<b class="nc"><i>2857</i>&nbsp;        /** loopback stream (for data reads that span data blocks) */</b>
<b class="nc"><i>2858</i>&nbsp;        private final DataInputStream din;</b>
<b class="nc"><i>2859</i>&nbsp;</b>
<b class="nc"><i>2860</i>&nbsp;        /**</b>
<b class="nc"><i>2861</i>&nbsp;         * Creates new BlockDataInputStream on top of given underlying stream.</b>
<b class="nc"><i>2862</i>&nbsp;         * Block data mode is turned off by default.</b>
<b class="nc"><i>2863</i>&nbsp;         */</b>
<i>2864</i>&nbsp;        BlockDataInputStream(InputStream in) {
<i>2865</i>&nbsp;            this.in = new PeekInputStream(in);
<i>2866</i>&nbsp;            din = new DataInputStream(this);
<i>2867</i>&nbsp;        }
<i>2868</i>&nbsp;
<i>2869</i>&nbsp;        /**
<i>2870</i>&nbsp;         * Sets block data mode to the given mode (true == on, false == off)
<i>2871</i>&nbsp;         * and returns the previous mode value.  If the new mode is the same as
<b class="nc"><i>2872</i>&nbsp;         * the old mode, no action is taken.  Throws IllegalStateException if</b>
<b class="nc"><i>2873</i>&nbsp;         * block data mode is being switched from on to off while unconsumed</b>
<i>2874</i>&nbsp;         * block data is still present in the stream.
<b class="nc"><i>2875</i>&nbsp;         */</b>
<i>2876</i>&nbsp;        boolean setBlockDataMode(boolean newmode) throws IOException {
<i>2877</i>&nbsp;            if (blkmode == newmode) {
<i>2878</i>&nbsp;                return blkmode;
<i>2879</i>&nbsp;            }
<i>2880</i>&nbsp;            if (newmode) {
<i>2881</i>&nbsp;                pos = 0;
<i>2882</i>&nbsp;                end = 0;
<i>2883</i>&nbsp;                unread = 0;
<i>2884</i>&nbsp;            } else if (pos &lt; end) {
<b class="nc"><i>2885</i>&nbsp;                throw new IllegalStateException(&quot;unread block data&quot;);</b>
<b class="nc"><i>2886</i>&nbsp;            }</b>
<b class="nc"><i>2887</i>&nbsp;            blkmode = newmode;</b>
<i>2888</i>&nbsp;            return !blkmode;
<b class="nc"><i>2889</i>&nbsp;        }</b>
<i>2890</i>&nbsp;
<b class="nc"><i>2891</i>&nbsp;        /**</b>
<i>2892</i>&nbsp;         * Returns true if the stream is currently in block data mode, false
<i>2893</i>&nbsp;         * otherwise.
<i>2894</i>&nbsp;         */
<i>2895</i>&nbsp;        boolean getBlockDataMode() {
<i>2896</i>&nbsp;            return blkmode;
<i>2897</i>&nbsp;        }
<i>2898</i>&nbsp;
<i>2899</i>&nbsp;        /**
<i>2900</i>&nbsp;         * If in block data mode, skips to the end of the current group of data
<b class="nc"><i>2901</i>&nbsp;         * blocks (but does not unset block data mode).  If not in block data</b>
<b class="nc"><i>2902</i>&nbsp;         * mode, throws an IllegalStateException.</b>
<b class="nc"><i>2903</i>&nbsp;         */</b>
<i>2904</i>&nbsp;        void skipBlockData() throws IOException {
<b class="nc"><i>2905</i>&nbsp;            if (!blkmode) {</b>
<i>2906</i>&nbsp;                throw new IllegalStateException(&quot;not in block data mode&quot;);
<i>2907</i>&nbsp;            }
<i>2908</i>&nbsp;            while (end &gt;= 0) {
<i>2909</i>&nbsp;                refill();
<i>2910</i>&nbsp;            }
<i>2911</i>&nbsp;        }
<i>2912</i>&nbsp;
<i>2913</i>&nbsp;        /**
<i>2914</i>&nbsp;         * Attempts to read in the next block data header (if any).  If
<i>2915</i>&nbsp;         * canBlock is false and a full header cannot be read without possibly
<i>2916</i>&nbsp;         * blocking, returns HEADER_BLOCKED, else if the next element in the
<i>2917</i>&nbsp;         * stream is a block data header, returns the block data length
<b class="nc"><i>2918</i>&nbsp;         * specified by the header, else returns -1.</b>
<b class="nc"><i>2919</i>&nbsp;         */</b>
<b class="nc"><i>2920</i>&nbsp;        private int readBlockHeader(boolean canBlock) throws IOException {</b>
<i>2921</i>&nbsp;            if (defaultDataEnd) {
<b class="nc"><i>2922</i>&nbsp;                /*</b>
<i>2923</i>&nbsp;                 * Fix for 4360508: stream is currently at the end of a field
<b class="nc"><i>2924</i>&nbsp;                 * value block written via default serialization; since there</b>
<i>2925</i>&nbsp;                 * is no terminating TC_ENDBLOCKDATA tag, simulate
<i>2926</i>&nbsp;                 * end-of-custom-data behavior explicitly.
<i>2927</i>&nbsp;                 */
<i>2928</i>&nbsp;                return -1;
<b class="nc"><i>2929</i>&nbsp;            }</b>
<i>2930</i>&nbsp;            try {
<i>2931</i>&nbsp;                for (;;) {
<i>2932</i>&nbsp;                    int avail = canBlock ? Integer.MAX_VALUE : in.available();
<b class="nc"><i>2933</i>&nbsp;                    if (avail == 0) {</b>
<b class="nc"><i>2934</i>&nbsp;                        return HEADER_BLOCKED;</b>
<b class="nc"><i>2935</i>&nbsp;                    }</b>
<b class="nc"><i>2936</i>&nbsp;</b>
<b class="nc"><i>2937</i>&nbsp;                    int tc = in.peek();</b>
<i>2938</i>&nbsp;                    switch (tc) {
<b class="nc"><i>2939</i>&nbsp;                        case TC_BLOCKDATA:</b>
<b class="nc"><i>2940</i>&nbsp;                            if (avail &lt; 2) {</b>
<i>2941</i>&nbsp;                                return HEADER_BLOCKED;
<b class="nc"><i>2942</i>&nbsp;                            }</b>
<b class="nc"><i>2943</i>&nbsp;                            in.readFully(hbuf, 0, 2);</b>
<b class="nc"><i>2944</i>&nbsp;                            return hbuf[1] &amp; 0xFF;</b>
<b class="nc"><i>2945</i>&nbsp;</b>
<b class="nc"><i>2946</i>&nbsp;                        case TC_BLOCKDATALONG:</b>
<b class="nc"><i>2947</i>&nbsp;                            if (avail &lt; 5) {</b>
<b class="nc"><i>2948</i>&nbsp;                                return HEADER_BLOCKED;</b>
<i>2949</i>&nbsp;                            }
<b class="nc"><i>2950</i>&nbsp;                            in.readFully(hbuf, 0, 5);</b>
<b class="nc"><i>2951</i>&nbsp;                            int len = Bits.getInt(hbuf, 1);</b>
<i>2952</i>&nbsp;                            if (len &lt; 0) {
<b class="nc"><i>2953</i>&nbsp;                                throw new StreamCorruptedException(</b>
<i>2954</i>&nbsp;                                    &quot;illegal block data header length: &quot; +
<i>2955</i>&nbsp;                                    len);
<i>2956</i>&nbsp;                            }
<b class="nc"><i>2957</i>&nbsp;                            return len;</b>
<b class="nc"><i>2958</i>&nbsp;</b>
<i>2959</i>&nbsp;                        /*
<b class="nc"><i>2960</i>&nbsp;                         * TC_RESETs may occur in between data blocks.</b>
<b class="nc"><i>2961</i>&nbsp;                         * Unfortunately, this case must be parsed at a lower</b>
<i>2962</i>&nbsp;                         * level than other typecodes, since primitive data
<b class="nc"><i>2963</i>&nbsp;                         * reads may span data blocks separated by a TC_RESET.</b>
<i>2964</i>&nbsp;                         */
<i>2965</i>&nbsp;                        case TC_RESET:
<b class="nc"><i>2966</i>&nbsp;                            in.read();</b>
<b class="nc"><i>2967</i>&nbsp;                            handleReset();</b>
<b class="nc"><i>2968</i>&nbsp;                            break;</b>
<i>2969</i>&nbsp;
<i>2970</i>&nbsp;                        default:
<b class="nc"><i>2971</i>&nbsp;                            if (tc &gt;= 0 &amp;&amp; (tc &lt; TC_BASE || tc &gt; TC_MAX)) {</b>
<b class="nc"><i>2972</i>&nbsp;                                throw new StreamCorruptedException(</b>
<b class="nc"><i>2973</i>&nbsp;                                    String.format(&quot;invalid type code: %02X&quot;,</b>
<i>2974</i>&nbsp;                                    tc));
<i>2975</i>&nbsp;                            }
<i>2976</i>&nbsp;                            return -1;
<i>2977</i>&nbsp;                    }
<b class="nc"><i>2978</i>&nbsp;                }</b>
<b class="nc"><i>2979</i>&nbsp;            } catch (EOFException ex) {</b>
<b class="nc"><i>2980</i>&nbsp;                throw new StreamCorruptedException(</b>
<i>2981</i>&nbsp;                    &quot;unexpected EOF while reading block data header&quot;);
<b class="nc"><i>2982</i>&nbsp;            }</b>
<i>2983</i>&nbsp;        }
<i>2984</i>&nbsp;
<i>2985</i>&nbsp;        /**
<i>2986</i>&nbsp;         * Refills internal buffer buf with block data.  Any data in buf at the
<b class="nc"><i>2987</i>&nbsp;         * time of the call is considered consumed.  Sets the pos, end, and</b>
<b class="nc"><i>2988</i>&nbsp;         * unread fields to reflect the new amount of available block data; if</b>
<b class="nc"><i>2989</i>&nbsp;         * the next element in the stream is not a data block, sets pos and</b>
<b class="nc"><i>2990</i>&nbsp;         * unread to 0 and end to -1.</b>
<i>2991</i>&nbsp;         */
<b class="nc"><i>2992</i>&nbsp;        private void refill() throws IOException {</b>
<i>2993</i>&nbsp;            try {
<i>2994</i>&nbsp;                do {
<i>2995</i>&nbsp;                    pos = 0;
<i>2996</i>&nbsp;                    if (unread &gt; 0) {
<i>2997</i>&nbsp;                        int n =
<i>2998</i>&nbsp;                            in.read(buf, 0, Math.min(unread, MAX_BLOCK_SIZE));
<i>2999</i>&nbsp;                        if (n &gt;= 0) {
<i>3000</i>&nbsp;                            end = n;
<i>3001</i>&nbsp;                            unread -= n;
<i>3002</i>&nbsp;                        } else {
<b class="nc"><i>3003</i>&nbsp;                            throw new StreamCorruptedException(</b>
<b class="nc"><i>3004</i>&nbsp;                                &quot;unexpected EOF in middle of data block&quot;);</b>
<b class="nc"><i>3005</i>&nbsp;                        }</b>
<b class="nc"><i>3006</i>&nbsp;                    } else {</b>
<b class="nc"><i>3007</i>&nbsp;                        int n = readBlockHeader(true);</b>
<i>3008</i>&nbsp;                        if (n &gt;= 0) {
<b class="nc"><i>3009</i>&nbsp;                            end = 0;</b>
<b class="nc"><i>3010</i>&nbsp;                            unread = n;</b>
<i>3011</i>&nbsp;                        } else {
<b class="nc"><i>3012</i>&nbsp;                            end = -1;</b>
<b class="nc"><i>3013</i>&nbsp;                            unread = 0;</b>
<b class="nc"><i>3014</i>&nbsp;                        }</b>
<b class="nc"><i>3015</i>&nbsp;                    }</b>
<b class="nc"><i>3016</i>&nbsp;                } while (pos == end);</b>
<b class="nc"><i>3017</i>&nbsp;            } catch (IOException ex) {</b>
<b class="nc"><i>3018</i>&nbsp;                pos = 0;</b>
<b class="nc"><i>3019</i>&nbsp;                end = -1;</b>
<i>3020</i>&nbsp;                unread = 0;
<b class="nc"><i>3021</i>&nbsp;                throw ex;</b>
<i>3022</i>&nbsp;            }
<b class="nc"><i>3023</i>&nbsp;        }</b>
<i>3024</i>&nbsp;
<i>3025</i>&nbsp;        /**
<i>3026</i>&nbsp;         * If in block data mode, returns the number of unconsumed bytes
<i>3027</i>&nbsp;         * remaining in the current data block.  If not in block data mode,
<i>3028</i>&nbsp;         * throws an IllegalStateException.
<i>3029</i>&nbsp;         */
<i>3030</i>&nbsp;        int currentBlockRemaining() {
<i>3031</i>&nbsp;            if (blkmode) {
<i>3032</i>&nbsp;                return (end &gt;= 0) ? (end - pos) + unread : 0;
<i>3033</i>&nbsp;            } else {
<i>3034</i>&nbsp;                throw new IllegalStateException();
<i>3035</i>&nbsp;            }
<b class="nc"><i>3036</i>&nbsp;        }</b>
<i>3037</i>&nbsp;
<i>3038</i>&nbsp;        /**
<i>3039</i>&nbsp;         * Peeks at (but does not consume) and returns the next byte value in
<b class="nc"><i>3040</i>&nbsp;         * the stream, or -1 if the end of the stream/block data (if in block</b>
<i>3041</i>&nbsp;         * data mode) has been reached.
<i>3042</i>&nbsp;         */
<i>3043</i>&nbsp;        int peek() throws IOException {
<i>3044</i>&nbsp;            if (blkmode) {
<i>3045</i>&nbsp;                if (pos == end) {
<b class="nc"><i>3046</i>&nbsp;                    refill();</b>
<b class="nc"><i>3047</i>&nbsp;                }</b>
<b class="nc"><i>3048</i>&nbsp;                return (end &gt;= 0) ? (buf[pos] &amp; 0xFF) : -1;</b>
<b class="nc"><i>3049</i>&nbsp;            } else {</b>
<i>3050</i>&nbsp;                return in.peek();
<b class="nc"><i>3051</i>&nbsp;            }</b>
<b class="nc"><i>3052</i>&nbsp;        }</b>
<b class="nc"><i>3053</i>&nbsp;</b>
<i>3054</i>&nbsp;        /**
<i>3055</i>&nbsp;         * Peeks at (but does not consume) and returns the next byte value in
<i>3056</i>&nbsp;         * the stream, or throws EOFException if end of stream/block data has
<b class="nc"><i>3057</i>&nbsp;         * been reached.</b>
<i>3058</i>&nbsp;         */
<i>3059</i>&nbsp;        byte peekByte() throws IOException {
<i>3060</i>&nbsp;            int val = peek();
<b class="nc"><i>3061</i>&nbsp;            if (val &lt; 0) {</b>
<b class="nc"><i>3062</i>&nbsp;                throw new EOFException();</b>
<b class="nc"><i>3063</i>&nbsp;            }</b>
<i>3064</i>&nbsp;            return (byte) val;
<b class="nc"><i>3065</i>&nbsp;        }</b>
<i>3066</i>&nbsp;
<i>3067</i>&nbsp;
<i>3068</i>&nbsp;        /* ----------------- generic input stream methods ------------------ */
<b class="nc"><i>3069</i>&nbsp;        /*</b>
<b class="nc"><i>3070</i>&nbsp;         * The following methods are equivalent to their counterparts in</b>
<b class="nc"><i>3071</i>&nbsp;         * InputStream, except that they interpret data block boundaries and</b>
<i>3072</i>&nbsp;         * read the requested data from within data blocks when in block data
<b class="nc"><i>3073</i>&nbsp;         * mode.</b>
<i>3074</i>&nbsp;         */
<i>3075</i>&nbsp;
<i>3076</i>&nbsp;        public int read() throws IOException {
<b class="nc"><i>3077</i>&nbsp;            if (blkmode) {</b>
<b class="nc"><i>3078</i>&nbsp;                if (pos == end) {</b>
<b class="nc"><i>3079</i>&nbsp;                    refill();</b>
<i>3080</i>&nbsp;                }
<b class="nc"><i>3081</i>&nbsp;                return (end &gt;= 0) ? (buf[pos++] &amp; 0xFF) : -1;</b>
<i>3082</i>&nbsp;            } else {
<i>3083</i>&nbsp;                return in.read();
<i>3084</i>&nbsp;            }
<b class="nc"><i>3085</i>&nbsp;        }</b>
<b class="nc"><i>3086</i>&nbsp;</b>
<b class="nc"><i>3087</i>&nbsp;        public int read(byte[] b, int off, int len) throws IOException {</b>
<b class="nc"><i>3088</i>&nbsp;            return read(b, off, len, false);</b>
<b class="nc"><i>3089</i>&nbsp;        }</b>
<i>3090</i>&nbsp;
<b class="nc"><i>3091</i>&nbsp;        public long skip(long len) throws IOException {</b>
<b class="nc"><i>3092</i>&nbsp;            long remain = len;</b>
<b class="nc"><i>3093</i>&nbsp;            while (remain &gt; 0) {</b>
<i>3094</i>&nbsp;                if (blkmode) {
<i>3095</i>&nbsp;                    if (pos == end) {
<i>3096</i>&nbsp;                        refill();
<b class="nc"><i>3097</i>&nbsp;                    }</b>
<b class="nc"><i>3098</i>&nbsp;                    if (end &lt; 0) {</b>
<b class="nc"><i>3099</i>&nbsp;                        break;</b>
<b class="nc"><i>3100</i>&nbsp;                    }</b>
<b class="nc"><i>3101</i>&nbsp;                    int nread = (int) Math.min(remain, end - pos);</b>
<i>3102</i>&nbsp;                    remain -= nread;
<b class="nc"><i>3103</i>&nbsp;                    pos += nread;</b>
<b class="nc"><i>3104</i>&nbsp;                } else {</b>
<b class="nc"><i>3105</i>&nbsp;                    int nread = (int) Math.min(remain, MAX_BLOCK_SIZE);</b>
<i>3106</i>&nbsp;                    if ((nread = in.read(buf, 0, nread)) &lt; 0) {
<i>3107</i>&nbsp;                        break;
<i>3108</i>&nbsp;                    }
<b class="nc"><i>3109</i>&nbsp;                    remain -= nread;</b>
<b class="nc"><i>3110</i>&nbsp;                }</b>
<b class="nc"><i>3111</i>&nbsp;            }</b>
<b class="nc"><i>3112</i>&nbsp;            return len - remain;</b>
<b class="nc"><i>3113</i>&nbsp;        }</b>
<i>3114</i>&nbsp;
<b class="nc"><i>3115</i>&nbsp;        public int available() throws IOException {</b>
<b class="nc"><i>3116</i>&nbsp;            if (blkmode) {</b>
<b class="nc"><i>3117</i>&nbsp;                if ((pos == end) &amp;&amp; (unread == 0)) {</b>
<i>3118</i>&nbsp;                    int n;
<i>3119</i>&nbsp;                    while ((n = readBlockHeader(false)) == 0) ;
<i>3120</i>&nbsp;                    switch (n) {
<b class="nc"><i>3121</i>&nbsp;                        case HEADER_BLOCKED:</b>
<b class="nc"><i>3122</i>&nbsp;                            break;</b>
<b class="nc"><i>3123</i>&nbsp;</b>
<b class="nc"><i>3124</i>&nbsp;                        case -1:</b>
<b class="nc"><i>3125</i>&nbsp;                            pos = 0;</b>
<i>3126</i>&nbsp;                            end = -1;
<b class="nc"><i>3127</i>&nbsp;                            break;</b>
<b class="nc"><i>3128</i>&nbsp;</b>
<b class="nc"><i>3129</i>&nbsp;                        default:</b>
<i>3130</i>&nbsp;                            pos = 0;
<i>3131</i>&nbsp;                            end = 0;
<i>3132</i>&nbsp;                            unread = n;
<b class="nc"><i>3133</i>&nbsp;                            break;</b>
<b class="nc"><i>3134</i>&nbsp;                    }</b>
<b class="nc"><i>3135</i>&nbsp;                }</b>
<b class="nc"><i>3136</i>&nbsp;                // avoid unnecessary call to in.available() if possible</b>
<b class="nc"><i>3137</i>&nbsp;                int unreadAvail = (unread &gt; 0) ?</b>
<i>3138</i>&nbsp;                    Math.min(in.available(), unread) : 0;
<b class="nc"><i>3139</i>&nbsp;                return (end &gt;= 0) ? (end - pos) + unreadAvail : 0;</b>
<b class="nc"><i>3140</i>&nbsp;            } else {</b>
<b class="nc"><i>3141</i>&nbsp;                return in.available();</b>
<i>3142</i>&nbsp;            }
<i>3143</i>&nbsp;        }
<i>3144</i>&nbsp;
<b class="nc"><i>3145</i>&nbsp;        public void close() throws IOException {</b>
<b class="nc"><i>3146</i>&nbsp;            if (blkmode) {</b>
<b class="nc"><i>3147</i>&nbsp;                pos = 0;</b>
<b class="nc"><i>3148</i>&nbsp;                end = -1;</b>
<b class="nc"><i>3149</i>&nbsp;                unread = 0;</b>
<i>3150</i>&nbsp;            }
<b class="nc"><i>3151</i>&nbsp;            in.close();</b>
<b class="nc"><i>3152</i>&nbsp;        }</b>
<b class="nc"><i>3153</i>&nbsp;</b>
<i>3154</i>&nbsp;        /**
<i>3155</i>&nbsp;         * Attempts to read len bytes into byte array b at offset off.  Returns
<i>3156</i>&nbsp;         * the number of bytes read, or -1 if the end of stream/block data has
<b class="nc"><i>3157</i>&nbsp;         * been reached.  If copy is true, reads values into an intermediate</b>
<b class="nc"><i>3158</i>&nbsp;         * buffer before copying them to b (to avoid exposing a reference to</b>
<b class="nc"><i>3159</i>&nbsp;         * b).</b>
<b class="nc"><i>3160</i>&nbsp;         */</b>
<b class="nc"><i>3161</i>&nbsp;        int read(byte[] b, int off, int len, boolean copy) throws IOException {</b>
<i>3162</i>&nbsp;            if (len == 0) {
<b class="nc"><i>3163</i>&nbsp;                return 0;</b>
<b class="nc"><i>3164</i>&nbsp;            } else if (blkmode) {</b>
<b class="nc"><i>3165</i>&nbsp;                if (pos == end) {</b>
<i>3166</i>&nbsp;                    refill();
<i>3167</i>&nbsp;                }
<i>3168</i>&nbsp;                if (end &lt; 0) {
<b class="nc"><i>3169</i>&nbsp;                    return -1;</b>
<i>3170</i>&nbsp;                }
<i>3171</i>&nbsp;                int nread = Math.min(len, end - pos);
<i>3172</i>&nbsp;                System.arraycopy(buf, pos, b, off, nread);
<i>3173</i>&nbsp;                pos += nread;
<b class="nc"><i>3174</i>&nbsp;                return nread;</b>
<i>3175</i>&nbsp;            } else if (copy) {
<i>3176</i>&nbsp;                int nread = in.read(buf, 0, Math.min(len, MAX_BLOCK_SIZE));
<i>3177</i>&nbsp;                if (nread &gt; 0) {
<i>3178</i>&nbsp;                    System.arraycopy(buf, 0, b, off, nread);
<i>3179</i>&nbsp;                }
<i>3180</i>&nbsp;                return nread;
<i>3181</i>&nbsp;            } else {
<i>3182</i>&nbsp;                return in.read(b, off, len);
<i>3183</i>&nbsp;            }
<i>3184</i>&nbsp;        }
<i>3185</i>&nbsp;
<b class="nc"><i>3186</i>&nbsp;        /* ----------------- primitive data input methods ------------------ */</b>
<b class="nc"><i>3187</i>&nbsp;        /*</b>
<b class="nc"><i>3188</i>&nbsp;         * The following methods are equivalent to their counterparts in</b>
<b class="nc"><i>3189</i>&nbsp;         * DataInputStream, except that they interpret data block boundaries</b>
<b class="nc"><i>3190</i>&nbsp;         * and read the requested data from within data blocks when in block</b>
<b class="nc"><i>3191</i>&nbsp;         * data mode.</b>
<b class="nc"><i>3192</i>&nbsp;         */</b>
<b class="nc"><i>3193</i>&nbsp;</b>
<b class="nc"><i>3194</i>&nbsp;        public void readFully(byte[] b) throws IOException {</b>
<b class="nc"><i>3195</i>&nbsp;            readFully(b, 0, b.length, false);</b>
<i>3196</i>&nbsp;        }
<b class="nc"><i>3197</i>&nbsp;</b>
<i>3198</i>&nbsp;        public void readFully(byte[] b, int off, int len) throws IOException {
<i>3199</i>&nbsp;            readFully(b, off, len, false);
<b class="nc"><i>3200</i>&nbsp;        }</b>
<b class="nc"><i>3201</i>&nbsp;</b>
<i>3202</i>&nbsp;        public void readFully(byte[] b, int off, int len, boolean copy)
<i>3203</i>&nbsp;            throws IOException
<i>3204</i>&nbsp;        {
<i>3205</i>&nbsp;            while (len &gt; 0) {
<i>3206</i>&nbsp;                int n = read(b, off, len, copy);
<b class="nc"><i>3207</i>&nbsp;                if (n &lt; 0) {</b>
<b class="nc"><i>3208</i>&nbsp;                    throw new EOFException();</b>
<b class="nc"><i>3209</i>&nbsp;                }</b>
<b class="nc"><i>3210</i>&nbsp;                off += n;</b>
<b class="nc"><i>3211</i>&nbsp;                len -= n;</b>
<b class="nc"><i>3212</i>&nbsp;            }</b>
<b class="nc"><i>3213</i>&nbsp;        }</b>
<b class="nc"><i>3214</i>&nbsp;</b>
<b class="nc"><i>3215</i>&nbsp;        public int skipBytes(int n) throws IOException {</b>
<b class="nc"><i>3216</i>&nbsp;            return din.skipBytes(n);</b>
<i>3217</i>&nbsp;        }
<b class="nc"><i>3218</i>&nbsp;</b>
<i>3219</i>&nbsp;        public boolean readBoolean() throws IOException {
<i>3220</i>&nbsp;            int v = read();
<b class="nc"><i>3221</i>&nbsp;            if (v &lt; 0) {</b>
<b class="nc"><i>3222</i>&nbsp;                throw new EOFException();</b>
<b class="nc"><i>3223</i>&nbsp;            }</b>
<i>3224</i>&nbsp;            return (v != 0);
<i>3225</i>&nbsp;        }
<i>3226</i>&nbsp;
<i>3227</i>&nbsp;        public byte readByte() throws IOException {
<i>3228</i>&nbsp;            int v = read();
<b class="nc"><i>3229</i>&nbsp;            if (v &lt; 0) {</b>
<b class="nc"><i>3230</i>&nbsp;                throw new EOFException();</b>
<b class="nc"><i>3231</i>&nbsp;            }</b>
<b class="nc"><i>3232</i>&nbsp;            return (byte) v;</b>
<b class="nc"><i>3233</i>&nbsp;        }</b>
<b class="nc"><i>3234</i>&nbsp;</b>
<b class="nc"><i>3235</i>&nbsp;        public int readUnsignedByte() throws IOException {</b>
<b class="nc"><i>3236</i>&nbsp;            int v = read();</b>
<b class="nc"><i>3237</i>&nbsp;            if (v &lt; 0) {</b>
<b class="nc"><i>3238</i>&nbsp;                throw new EOFException();</b>
<i>3239</i>&nbsp;            }
<b class="nc"><i>3240</i>&nbsp;            return v;</b>
<i>3241</i>&nbsp;        }
<i>3242</i>&nbsp;
<b class="nc"><i>3243</i>&nbsp;        public char readChar() throws IOException {</b>
<b class="nc"><i>3244</i>&nbsp;            if (!blkmode) {</b>
<b class="nc"><i>3245</i>&nbsp;                pos = 0;</b>
<i>3246</i>&nbsp;                in.readFully(buf, 0, 2);
<i>3247</i>&nbsp;            } else if (end - pos &lt; 2) {
<i>3248</i>&nbsp;                return din.readChar();
<i>3249</i>&nbsp;            }
<i>3250</i>&nbsp;            char v = Bits.getChar(buf, pos);
<b class="nc"><i>3251</i>&nbsp;            pos += 2;</b>
<b class="nc"><i>3252</i>&nbsp;            return v;</b>
<b class="nc"><i>3253</i>&nbsp;        }</b>
<b class="nc"><i>3254</i>&nbsp;</b>
<b class="nc"><i>3255</i>&nbsp;        public short readShort() throws IOException {</b>
<b class="nc"><i>3256</i>&nbsp;            if (!blkmode) {</b>
<b class="nc"><i>3257</i>&nbsp;                pos = 0;</b>
<b class="nc"><i>3258</i>&nbsp;                in.readFully(buf, 0, 2);</b>
<b class="nc"><i>3259</i>&nbsp;            } else if (end - pos &lt; 2) {</b>
<b class="nc"><i>3260</i>&nbsp;                return din.readShort();</b>
<i>3261</i>&nbsp;            }
<b class="nc"><i>3262</i>&nbsp;            short v = Bits.getShort(buf, pos);</b>
<i>3263</i>&nbsp;            pos += 2;
<i>3264</i>&nbsp;            return v;
<b class="nc"><i>3265</i>&nbsp;        }</b>
<b class="nc"><i>3266</i>&nbsp;</b>
<b class="nc"><i>3267</i>&nbsp;        public int readUnsignedShort() throws IOException {</b>
<i>3268</i>&nbsp;            if (!blkmode) {
<i>3269</i>&nbsp;                pos = 0;
<i>3270</i>&nbsp;                in.readFully(buf, 0, 2);
<i>3271</i>&nbsp;            } else if (end - pos &lt; 2) {
<i>3272</i>&nbsp;                return din.readUnsignedShort();
<b class="nc"><i>3273</i>&nbsp;            }</b>
<b class="nc"><i>3274</i>&nbsp;            int v = Bits.getShort(buf, pos) &amp; 0xFFFF;</b>
<b class="nc"><i>3275</i>&nbsp;            pos += 2;</b>
<b class="nc"><i>3276</i>&nbsp;            return v;</b>
<b class="nc"><i>3277</i>&nbsp;        }</b>
<b class="nc"><i>3278</i>&nbsp;</b>
<b class="nc"><i>3279</i>&nbsp;        public int readInt() throws IOException {</b>
<b class="nc"><i>3280</i>&nbsp;            if (!blkmode) {</b>
<b class="nc"><i>3281</i>&nbsp;                pos = 0;</b>
<i>3282</i>&nbsp;                in.readFully(buf, 0, 4);
<b class="nc"><i>3283</i>&nbsp;            } else if (end - pos &lt; 4) {</b>
<i>3284</i>&nbsp;                return din.readInt();
<i>3285</i>&nbsp;            }
<b class="nc"><i>3286</i>&nbsp;            int v = Bits.getInt(buf, pos);</b>
<b class="nc"><i>3287</i>&nbsp;            pos += 4;</b>
<b class="nc"><i>3288</i>&nbsp;            return v;</b>
<i>3289</i>&nbsp;        }
<i>3290</i>&nbsp;
<i>3291</i>&nbsp;        public float readFloat() throws IOException {
<i>3292</i>&nbsp;            if (!blkmode) {
<b class="nc"><i>3293</i>&nbsp;                pos = 0;</b>
<b class="nc"><i>3294</i>&nbsp;                in.readFully(buf, 0, 4);</b>
<b class="nc"><i>3295</i>&nbsp;            } else if (end - pos &lt; 4) {</b>
<b class="nc"><i>3296</i>&nbsp;                return din.readFloat();</b>
<b class="nc"><i>3297</i>&nbsp;            }</b>
<b class="nc"><i>3298</i>&nbsp;            float v = Bits.getFloat(buf, pos);</b>
<b class="nc"><i>3299</i>&nbsp;            pos += 4;</b>
<b class="nc"><i>3300</i>&nbsp;            return v;</b>
<b class="nc"><i>3301</i>&nbsp;        }</b>
<b class="nc"><i>3302</i>&nbsp;</b>
<i>3303</i>&nbsp;        public long readLong() throws IOException {
<b class="nc"><i>3304</i>&nbsp;            if (!blkmode) {</b>
<i>3305</i>&nbsp;                pos = 0;
<i>3306</i>&nbsp;                in.readFully(buf, 0, 8);
<b class="nc"><i>3307</i>&nbsp;            } else if (end - pos &lt; 8) {</b>
<b class="nc"><i>3308</i>&nbsp;                return din.readLong();</b>
<b class="nc"><i>3309</i>&nbsp;            }</b>
<i>3310</i>&nbsp;            long v = Bits.getLong(buf, pos);
<i>3311</i>&nbsp;            pos += 8;
<i>3312</i>&nbsp;            return v;
<i>3313</i>&nbsp;        }
<i>3314</i>&nbsp;
<b class="nc"><i>3315</i>&nbsp;        public double readDouble() throws IOException {</b>
<b class="nc"><i>3316</i>&nbsp;            if (!blkmode) {</b>
<b class="nc"><i>3317</i>&nbsp;                pos = 0;</b>
<b class="nc"><i>3318</i>&nbsp;                in.readFully(buf, 0, 8);</b>
<b class="nc"><i>3319</i>&nbsp;            } else if (end - pos &lt; 8) {</b>
<b class="nc"><i>3320</i>&nbsp;                return din.readDouble();</b>
<b class="nc"><i>3321</i>&nbsp;            }</b>
<b class="nc"><i>3322</i>&nbsp;            double v = Bits.getDouble(buf, pos);</b>
<b class="nc"><i>3323</i>&nbsp;            pos += 8;</b>
<i>3324</i>&nbsp;            return v;
<b class="nc"><i>3325</i>&nbsp;        }</b>
<i>3326</i>&nbsp;
<i>3327</i>&nbsp;        public String readUTF() throws IOException {
<b class="nc"><i>3328</i>&nbsp;            return readUTFBody(readUnsignedShort());</b>
<b class="nc"><i>3329</i>&nbsp;        }</b>
<b class="nc"><i>3330</i>&nbsp;</b>
<i>3331</i>&nbsp;        @SuppressWarnings(&quot;deprecation&quot;)
<i>3332</i>&nbsp;        public String readLine() throws IOException {
<i>3333</i>&nbsp;            return din.readLine();      // deprecated, not worth optimizing
<i>3334</i>&nbsp;        }
<i>3335</i>&nbsp;
<i>3336</i>&nbsp;        /* -------------- primitive data array input methods --------------- */
<i>3337</i>&nbsp;        /*
<i>3338</i>&nbsp;         * The following methods read in spans of primitive data values.
<i>3339</i>&nbsp;         * Though equivalent to calling the corresponding primitive read
<b class="nc"><i>3340</i>&nbsp;         * methods repeatedly, these methods are optimized for reading groups</b>
<i>3341</i>&nbsp;         * of primitive data values more efficiently.
<i>3342</i>&nbsp;         */
<i>3343</i>&nbsp;
<i>3344</i>&nbsp;        void readBooleans(boolean[] v, int off, int len) throws IOException {
<i>3345</i>&nbsp;            int stop, endoff = off + len;
<i>3346</i>&nbsp;            while (off &lt; endoff) {
<i>3347</i>&nbsp;                if (!blkmode) {
<i>3348</i>&nbsp;                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE);
<b class="nc"><i>3349</i>&nbsp;                    in.readFully(buf, 0, span);</b>
<b class="nc"><i>3350</i>&nbsp;                    stop = off + span;</b>
<b class="nc"><i>3351</i>&nbsp;                    pos = 0;</b>
<i>3352</i>&nbsp;                } else if (end - pos &lt; 1) {
<i>3353</i>&nbsp;                    v[off++] = din.readBoolean();
<b class="nc"><i>3354</i>&nbsp;                    continue;</b>
<b class="nc"><i>3355</i>&nbsp;                } else {</b>
<b class="nc"><i>3356</i>&nbsp;                    stop = Math.min(endoff, off + end - pos);</b>
<b class="nc"><i>3357</i>&nbsp;                }</b>
<i>3358</i>&nbsp;
<b class="nc"><i>3359</i>&nbsp;                while (off &lt; stop) {</b>
<i>3360</i>&nbsp;                    v[off++] = Bits.getBoolean(buf, pos++);
<b class="nc"><i>3361</i>&nbsp;                }</b>
<i>3362</i>&nbsp;            }
<i>3363</i>&nbsp;        }
<b class="nc"><i>3364</i>&nbsp;</b>
<b class="nc"><i>3365</i>&nbsp;        void readChars(char[] v, int off, int len) throws IOException {</b>
<i>3366</i>&nbsp;            int stop, endoff = off + len;
<b class="nc"><i>3367</i>&nbsp;            while (off &lt; endoff) {</b>
<b class="nc"><i>3368</i>&nbsp;                if (!blkmode) {</b>
<b class="nc"><i>3369</i>&nbsp;                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);</b>
<i>3370</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 1);
<i>3371</i>&nbsp;                    stop = off + span;
<b class="nc"><i>3372</i>&nbsp;                    pos = 0;</b>
<i>3373</i>&nbsp;                } else if (end - pos &lt; 2) {
<b class="nc"><i>3374</i>&nbsp;                    v[off++] = din.readChar();</b>
<i>3375</i>&nbsp;                    continue;
<i>3376</i>&nbsp;                } else {
<i>3377</i>&nbsp;                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
<i>3378</i>&nbsp;                }
<i>3379</i>&nbsp;
<i>3380</i>&nbsp;                while (off &lt; stop) {
<i>3381</i>&nbsp;                    v[off++] = Bits.getChar(buf, pos);
<i>3382</i>&nbsp;                    pos += 2;
<i>3383</i>&nbsp;                }
<i>3384</i>&nbsp;            }
<i>3385</i>&nbsp;        }
<b class="nc"><i>3386</i>&nbsp;</b>
<b class="nc"><i>3387</i>&nbsp;        void readShorts(short[] v, int off, int len) throws IOException {</b>
<b class="nc"><i>3388</i>&nbsp;            int stop, endoff = off + len;</b>
<i>3389</i>&nbsp;            while (off &lt; endoff) {
<b class="nc"><i>3390</i>&nbsp;                if (!blkmode) {</b>
<b class="nc"><i>3391</i>&nbsp;                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 1);</b>
<i>3392</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 1);
<i>3393</i>&nbsp;                    stop = off + span;
<b class="nc"><i>3394</i>&nbsp;                    pos = 0;</b>
<i>3395</i>&nbsp;                } else if (end - pos &lt; 2) {
<b class="nc"><i>3396</i>&nbsp;                    v[off++] = din.readShort();</b>
<b class="nc"><i>3397</i>&nbsp;                    continue;</b>
<i>3398</i>&nbsp;                } else {
<i>3399</i>&nbsp;                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 1));
<i>3400</i>&nbsp;                }
<i>3401</i>&nbsp;
<i>3402</i>&nbsp;                while (off &lt; stop) {
<i>3403</i>&nbsp;                    v[off++] = Bits.getShort(buf, pos);
<i>3404</i>&nbsp;                    pos += 2;
<i>3405</i>&nbsp;                }
<b class="nc"><i>3406</i>&nbsp;            }</b>
<b class="nc"><i>3407</i>&nbsp;        }</b>
<i>3408</i>&nbsp;
<i>3409</i>&nbsp;        void readInts(int[] v, int off, int len) throws IOException {
<i>3410</i>&nbsp;            int stop, endoff = off + len;
<b class="nc"><i>3411</i>&nbsp;            while (off &lt; endoff) {</b>
<b class="nc"><i>3412</i>&nbsp;                if (!blkmode) {</b>
<b class="nc"><i>3413</i>&nbsp;                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</b>
<i>3414</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 2);
<b class="nc"><i>3415</i>&nbsp;                    stop = off + span;</b>
<i>3416</i>&nbsp;                    pos = 0;
<b class="nc"><i>3417</i>&nbsp;                } else if (end - pos &lt; 4) {</b>
<i>3418</i>&nbsp;                    v[off++] = din.readInt();
<i>3419</i>&nbsp;                    continue;
<b class="nc"><i>3420</i>&nbsp;                } else {</b>
<b class="nc"><i>3421</i>&nbsp;                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 2));</b>
<b class="nc"><i>3422</i>&nbsp;                }</b>
<b class="nc"><i>3423</i>&nbsp;</b>
<b class="nc"><i>3424</i>&nbsp;                while (off &lt; stop) {</b>
<i>3425</i>&nbsp;                    v[off++] = Bits.getInt(buf, pos);
<b class="nc"><i>3426</i>&nbsp;                    pos += 4;</b>
<i>3427</i>&nbsp;                }
<i>3428</i>&nbsp;            }
<b class="nc"><i>3429</i>&nbsp;        }</b>
<i>3430</i>&nbsp;
<i>3431</i>&nbsp;        void readFloats(float[] v, int off, int len) throws IOException {
<b class="nc"><i>3432</i>&nbsp;            int span, endoff = off + len;</b>
<i>3433</i>&nbsp;            while (off &lt; endoff) {
<b class="nc"><i>3434</i>&nbsp;                if (!blkmode) {</b>
<b class="nc"><i>3435</i>&nbsp;                    span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 2);</b>
<b class="nc"><i>3436</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 2);</b>
<i>3437</i>&nbsp;                    pos = 0;
<b class="nc"><i>3438</i>&nbsp;                } else if (end - pos &lt; 4) {</b>
<i>3439</i>&nbsp;                    v[off++] = din.readFloat();
<i>3440</i>&nbsp;                    continue;
<i>3441</i>&nbsp;                } else {
<i>3442</i>&nbsp;                    span = Math.min(endoff - off, ((end - pos) &gt;&gt; 2));
<i>3443</i>&nbsp;                }
<b class="nc"><i>3444</i>&nbsp;</b>
<b class="nc"><i>3445</i>&nbsp;                bytesToFloats(buf, pos, v, off, span);</b>
<i>3446</i>&nbsp;                off += span;
<i>3447</i>&nbsp;                pos += span &lt;&lt; 2;
<i>3448</i>&nbsp;            }
<b class="nc"><i>3449</i>&nbsp;        }</b>
<b class="nc"><i>3450</i>&nbsp;</b>
<i>3451</i>&nbsp;        void readLongs(long[] v, int off, int len) throws IOException {
<i>3452</i>&nbsp;            int stop, endoff = off + len;
<i>3453</i>&nbsp;            while (off &lt; endoff) {
<i>3454</i>&nbsp;                if (!blkmode) {
<i>3455</i>&nbsp;                    int span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
<i>3456</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 3);
<i>3457</i>&nbsp;                    stop = off + span;
<i>3458</i>&nbsp;                    pos = 0;
<i>3459</i>&nbsp;                } else if (end - pos &lt; 8) {
<i>3460</i>&nbsp;                    v[off++] = din.readLong();
<i>3461</i>&nbsp;                    continue;
<i>3462</i>&nbsp;                } else {
<i>3463</i>&nbsp;                    stop = Math.min(endoff, off + ((end - pos) &gt;&gt; 3));
<b class="nc"><i>3464</i>&nbsp;                }</b>
<b class="nc"><i>3465</i>&nbsp;</b>
<i>3466</i>&nbsp;                while (off &lt; stop) {
<i>3467</i>&nbsp;                    v[off++] = Bits.getLong(buf, pos);
<i>3468</i>&nbsp;                    pos += 8;
<i>3469</i>&nbsp;                }
<i>3470</i>&nbsp;            }
<i>3471</i>&nbsp;        }
<i>3472</i>&nbsp;
<i>3473</i>&nbsp;        void readDoubles(double[] v, int off, int len) throws IOException {
<b class="nc"><i>3474</i>&nbsp;            int span, endoff = off + len;</b>
<b class="nc"><i>3475</i>&nbsp;            while (off &lt; endoff) {</b>
<i>3476</i>&nbsp;                if (!blkmode) {
<i>3477</i>&nbsp;                    span = Math.min(endoff - off, MAX_BLOCK_SIZE &gt;&gt; 3);
<i>3478</i>&nbsp;                    in.readFully(buf, 0, span &lt;&lt; 3);
<b class="nc"><i>3479</i>&nbsp;                    pos = 0;</b>
<b class="nc"><i>3480</i>&nbsp;                } else if (end - pos &lt; 8) {</b>
<i>3481</i>&nbsp;                    v[off++] = din.readDouble();
<b class="nc"><i>3482</i>&nbsp;                    continue;</b>
<b class="nc"><i>3483</i>&nbsp;                } else {</b>
<b class="nc"><i>3484</i>&nbsp;                    span = Math.min(endoff - off, ((end - pos) &gt;&gt; 3));</b>
<i>3485</i>&nbsp;                }
<b class="nc"><i>3486</i>&nbsp;</b>
<i>3487</i>&nbsp;                bytesToDoubles(buf, pos, v, off, span);
<b class="nc"><i>3488</i>&nbsp;                off += span;</b>
<i>3489</i>&nbsp;                pos += span &lt;&lt; 3;
<i>3490</i>&nbsp;            }
<b class="nc"><i>3491</i>&nbsp;        }</b>
<b class="nc"><i>3492</i>&nbsp;</b>
<b class="nc"><i>3493</i>&nbsp;        /**</b>
<i>3494</i>&nbsp;         * Reads in string written in &quot;long&quot; UTF format.  &quot;Long&quot; UTF format is
<b class="nc"><i>3495</i>&nbsp;         * identical to standard UTF, except that it uses an 8 byte header</b>
<i>3496</i>&nbsp;         * (instead of the standard 2 bytes) to convey the UTF encoding length.
<b class="nc"><i>3497</i>&nbsp;         */</b>
<b class="nc"><i>3498</i>&nbsp;        String readLongUTF() throws IOException {</b>
<b class="nc"><i>3499</i>&nbsp;            return readUTFBody(readLong());</b>
<b class="nc"><i>3500</i>&nbsp;        }</b>
<i>3501</i>&nbsp;
<b class="nc"><i>3502</i>&nbsp;        /**</b>
<i>3503</i>&nbsp;         * Reads in the &quot;body&quot; (i.e., the UTF representation minus the 2-byte
<i>3504</i>&nbsp;         * or 8-byte length header) of a UTF encoding, which occupies the next
<b class="nc"><i>3505</i>&nbsp;         * utflen bytes.</b>
<i>3506</i>&nbsp;         */
<i>3507</i>&nbsp;        private String readUTFBody(long utflen) throws IOException {
<b class="nc"><i>3508</i>&nbsp;            StringBuilder sbuf;</b>
<i>3509</i>&nbsp;            if (utflen &gt; 0 &amp;&amp; utflen &lt; Integer.MAX_VALUE) {
<i>3510</i>&nbsp;                // a reasonable initial capacity based on the UTF length
<i>3511</i>&nbsp;                int initialCapacity = Math.min((int)utflen, 0xFFFF);
<i>3512</i>&nbsp;                sbuf = new StringBuilder(initialCapacity);
<i>3513</i>&nbsp;            } else {
<i>3514</i>&nbsp;                sbuf = new StringBuilder();
<i>3515</i>&nbsp;            }
<i>3516</i>&nbsp;
<b class="nc"><i>3517</i>&nbsp;            if (!blkmode) {</b>
<i>3518</i>&nbsp;                end = pos = 0;
<i>3519</i>&nbsp;            }
<i>3520</i>&nbsp;
<i>3521</i>&nbsp;            while (utflen &gt; 0) {
<i>3522</i>&nbsp;                int avail = end - pos;
<i>3523</i>&nbsp;                if (avail &gt;= 3 || (long) avail == utflen) {
<i>3524</i>&nbsp;                    utflen -= readUTFSpan(sbuf, utflen);
<i>3525</i>&nbsp;                } else {
<i>3526</i>&nbsp;                    if (blkmode) {
<i>3527</i>&nbsp;                        // near block boundary, read one byte at a time
<i>3528</i>&nbsp;                        utflen -= readUTFChar(sbuf, utflen);
<i>3529</i>&nbsp;                    } else {
<i>3530</i>&nbsp;                        // shift and refill buffer manually
<i>3531</i>&nbsp;                        if (avail &gt; 0) {
<i>3532</i>&nbsp;                            System.arraycopy(buf, pos, buf, 0, avail);
<i>3533</i>&nbsp;                        }
<i>3534</i>&nbsp;                        pos = 0;
<i>3535</i>&nbsp;                        end = (int) Math.min(MAX_BLOCK_SIZE, utflen);
<i>3536</i>&nbsp;                        in.readFully(buf, avail, end - avail);
<i>3537</i>&nbsp;                    }
<i>3538</i>&nbsp;                }
<i>3539</i>&nbsp;            }
<i>3540</i>&nbsp;
<i>3541</i>&nbsp;            return sbuf.toString();
<i>3542</i>&nbsp;        }
<i>3543</i>&nbsp;
<i>3544</i>&nbsp;        /**
<i>3545</i>&nbsp;         * Reads span of UTF-encoded characters out of internal buffer
<i>3546</i>&nbsp;         * (starting at offset pos and ending at or before offset end),
<i>3547</i>&nbsp;         * consuming no more than utflen bytes.  Appends read characters to
<i>3548</i>&nbsp;         * sbuf.  Returns the number of bytes consumed.
<i>3549</i>&nbsp;         */
<i>3550</i>&nbsp;        private long readUTFSpan(StringBuilder sbuf, long utflen)
<i>3551</i>&nbsp;            throws IOException
<i>3552</i>&nbsp;        {
<i>3553</i>&nbsp;            int cpos = 0;
<i>3554</i>&nbsp;            int start = pos;
<i>3555</i>&nbsp;            int avail = Math.min(end - pos, CHAR_BUF_SIZE);
<i>3556</i>&nbsp;            // stop short of last char unless all of utf bytes in buffer
<i>3557</i>&nbsp;            int stop = pos + ((utflen &gt; avail) ? avail - 2 : (int) utflen);
<i>3558</i>&nbsp;            boolean outOfBounds = false;
<i>3559</i>&nbsp;
<i>3560</i>&nbsp;            try {
<i>3561</i>&nbsp;                while (pos &lt; stop) {
<i>3562</i>&nbsp;                    int b1, b2, b3;
<i>3563</i>&nbsp;                    b1 = buf[pos++] &amp; 0xFF;
<b class="nc"><i>3564</i>&nbsp;                    switch (b1 &gt;&gt; 4) {</b>
<i>3565</i>&nbsp;                        case 0:
<b class="nc"><i>3566</i>&nbsp;                        case 1:</b>
<i>3567</i>&nbsp;                        case 2:
<i>3568</i>&nbsp;                        case 3:
<i>3569</i>&nbsp;                        case 4:
<i>3570</i>&nbsp;                        case 5:
<b class="nc"><i>3571</i>&nbsp;                        case 6:</b>
<b class="nc"><i>3572</i>&nbsp;                        case 7:   // 1 byte format: 0xxxxxxx</b>
<b class="nc"><i>3573</i>&nbsp;                            cbuf[cpos++] = (char) b1;</b>
<b class="nc"><i>3574</i>&nbsp;                            break;</b>
<i>3575</i>&nbsp;
<i>3576</i>&nbsp;                        case 12:
<i>3577</i>&nbsp;                        case 13:  // 2 byte format: 110xxxxx 10xxxxxx
<i>3578</i>&nbsp;                            b2 = buf[pos++];
<i>3579</i>&nbsp;                            if ((b2 &amp; 0xC0) != 0x80) {
<i>3580</i>&nbsp;                                throw new UTFDataFormatException();
<i>3581</i>&nbsp;                            }
<i>3582</i>&nbsp;                            cbuf[cpos++] = (char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
<i>3583</i>&nbsp;                                                   ((b2 &amp; 0x3F) &lt;&lt; 0));
<b class="nc"><i>3584</i>&nbsp;                            break;</b>
<b class="nc"><i>3585</i>&nbsp;</b>
<i>3586</i>&nbsp;                        case 14:  // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx
<b class="nc"><i>3587</i>&nbsp;                            b3 = buf[pos + 1];</b>
<b class="nc"><i>3588</i>&nbsp;                            b2 = buf[pos + 0];</b>
<b class="nc"><i>3589</i>&nbsp;                            pos += 2;</b>
<i>3590</i>&nbsp;                            if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {
<i>3591</i>&nbsp;                                throw new UTFDataFormatException();
<i>3592</i>&nbsp;                            }
<i>3593</i>&nbsp;                            cbuf[cpos++] = (char) (((b1 &amp; 0x0F) &lt;&lt; 12) |
<i>3594</i>&nbsp;                                                   ((b2 &amp; 0x3F) &lt;&lt; 6) |
<i>3595</i>&nbsp;                                                   ((b3 &amp; 0x3F) &lt;&lt; 0));
<i>3596</i>&nbsp;                            break;
<i>3597</i>&nbsp;
<i>3598</i>&nbsp;                        default:  // 10xx xxxx, 1111 xxxx
<b class="nc"><i>3599</i>&nbsp;                            throw new UTFDataFormatException();</b>
<i>3600</i>&nbsp;                    }
<i>3601</i>&nbsp;                }
<b class="nc"><i>3602</i>&nbsp;            } catch (ArrayIndexOutOfBoundsException ex) {</b>
<i>3603</i>&nbsp;                outOfBounds = true;
<i>3604</i>&nbsp;            } finally {
<b class="nc"><i>3605</i>&nbsp;                if (outOfBounds || (pos - start) &gt; utflen) {</b>
<i>3606</i>&nbsp;                    /*
<i>3607</i>&nbsp;                     * Fix for 4450867: if a malformed utf char causes the
<b class="nc"><i>3608</i>&nbsp;                     * conversion loop to scan past the expected end of the utf</b>
<i>3609</i>&nbsp;                     * string, only consume the expected number of utf bytes.
<i>3610</i>&nbsp;                     */
<i>3611</i>&nbsp;                    pos = start + (int) utflen;
<b class="nc"><i>3612</i>&nbsp;                    throw new UTFDataFormatException();</b>
<i>3613</i>&nbsp;                }
<b class="nc"><i>3614</i>&nbsp;            }</b>
<i>3615</i>&nbsp;
<i>3616</i>&nbsp;            sbuf.append(cbuf, 0, cpos);
<i>3617</i>&nbsp;            return pos - start;
<b class="nc"><i>3618</i>&nbsp;        }</b>
<b class="nc"><i>3619</i>&nbsp;</b>
<i>3620</i>&nbsp;        /**
<b class="nc"><i>3621</i>&nbsp;         * Reads in single UTF-encoded character one byte at a time, appends</b>
<i>3622</i>&nbsp;         * the character to sbuf, and returns the number of bytes consumed.
<i>3623</i>&nbsp;         * This method is used when reading in UTF strings written in block
<b class="nc"><i>3624</i>&nbsp;         * data mode to handle UTF-encoded characters which (potentially)</b>
<b class="nc"><i>3625</i>&nbsp;         * straddle block-data boundaries.</b>
<i>3626</i>&nbsp;         */
<i>3627</i>&nbsp;        private int readUTFChar(StringBuilder sbuf, long utflen)
<i>3628</i>&nbsp;            throws IOException
<i>3629</i>&nbsp;        {
<b class="nc"><i>3630</i>&nbsp;            int b1, b2, b3;</b>
<i>3631</i>&nbsp;            b1 = readByte() &amp; 0xFF;
<i>3632</i>&nbsp;            switch (b1 &gt;&gt; 4) {
<i>3633</i>&nbsp;                case 0:
<i>3634</i>&nbsp;                case 1:
<b class="nc"><i>3635</i>&nbsp;                case 2:</b>
<i>3636</i>&nbsp;                case 3:
<i>3637</i>&nbsp;                case 4:
<b class="nc"><i>3638</i>&nbsp;                case 5:</b>
<i>3639</i>&nbsp;                case 6:
<i>3640</i>&nbsp;                case 7:     // 1 byte format: 0xxxxxxx
<i>3641</i>&nbsp;                    sbuf.append((char) b1);
<i>3642</i>&nbsp;                    return 1;
<i>3643</i>&nbsp;
<i>3644</i>&nbsp;                case 12:
<i>3645</i>&nbsp;                case 13:    // 2 byte format: 110xxxxx 10xxxxxx
<i>3646</i>&nbsp;                    if (utflen &lt; 2) {
<i>3647</i>&nbsp;                        throw new UTFDataFormatException();
<i>3648</i>&nbsp;                    }
<b class="nc"><i>3649</i>&nbsp;                    b2 = readByte();</b>
<i>3650</i>&nbsp;                    if ((b2 &amp; 0xC0) != 0x80) {
<b class="nc"><i>3651</i>&nbsp;                        throw new UTFDataFormatException();</b>
<b class="nc"><i>3652</i>&nbsp;                    }</b>
<i>3653</i>&nbsp;                    sbuf.append((char) (((b1 &amp; 0x1F) &lt;&lt; 6) |
<i>3654</i>&nbsp;                                        ((b2 &amp; 0x3F) &lt;&lt; 0)));
<b class="nc"><i>3655</i>&nbsp;                    return 2;</b>
<b class="nc"><i>3656</i>&nbsp;</b>
<b class="nc"><i>3657</i>&nbsp;                case 14:    // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx</b>
<b class="nc"><i>3658</i>&nbsp;                    if (utflen &lt; 3) {</b>
<b class="nc"><i>3659</i>&nbsp;                        if (utflen == 2) {</b>
<i>3660</i>&nbsp;                            readByte();         // consume remaining byte
<b class="nc"><i>3661</i>&nbsp;                        }</b>
<b class="nc"><i>3662</i>&nbsp;                        throw new UTFDataFormatException();</b>
<i>3663</i>&nbsp;                    }
<i>3664</i>&nbsp;                    b2 = readByte();
<i>3665</i>&nbsp;                    b3 = readByte();
<b class="nc"><i>3666</i>&nbsp;                    if ((b2 &amp; 0xC0) != 0x80 || (b3 &amp; 0xC0) != 0x80) {</b>
<i>3667</i>&nbsp;                        throw new UTFDataFormatException();
<i>3668</i>&nbsp;                    }
<b class="nc"><i>3669</i>&nbsp;                    sbuf.append((char) (((b1 &amp; 0x0F) &lt;&lt; 12) |</b>
<i>3670</i>&nbsp;                                        ((b2 &amp; 0x3F) &lt;&lt; 6) |
<i>3671</i>&nbsp;                                        ((b3 &amp; 0x3F) &lt;&lt; 0)));
<i>3672</i>&nbsp;                    return 3;
<i>3673</i>&nbsp;
<i>3674</i>&nbsp;                default:   // 10xx xxxx, 1111 xxxx
<i>3675</i>&nbsp;                    throw new UTFDataFormatException();
<i>3676</i>&nbsp;            }
<i>3677</i>&nbsp;        }
<i>3678</i>&nbsp;
<i>3679</i>&nbsp;        /**
<b class="nc"><i>3680</i>&nbsp;         * Returns the number of bytes read from the input stream.</b>
<i>3681</i>&nbsp;         * @return the number of bytes read from the input stream
<b class="nc"><i>3682</i>&nbsp;         */</b>
<b class="nc"><i>3683</i>&nbsp;        long getBytesRead() {</b>
<i>3684</i>&nbsp;            return in.getBytesRead();
<b class="nc"><i>3685</i>&nbsp;        }</b>
<b class="nc"><i>3686</i>&nbsp;    }</b>
<i>3687</i>&nbsp;
<i>3688</i>&nbsp;    /**
<i>3689</i>&nbsp;     * Unsynchronized table which tracks wire handle to object mappings, as
<i>3690</i>&nbsp;     * well as ClassNotFoundExceptions associated with deserialized objects.
<i>3691</i>&nbsp;     * This class implements an exception-propagation algorithm for
<i>3692</i>&nbsp;     * determining which objects should have ClassNotFoundExceptions associated
<b class="nc"><i>3693</i>&nbsp;     * with them, taking into account cycles and discontinuities (e.g., skipped</b>
<b class="nc"><i>3694</i>&nbsp;     * fields) in the object graph.</b>
<i>3695</i>&nbsp;     *
<b class="nc"><i>3696</i>&nbsp;     * &lt;p&gt;General use of the table is as follows: during deserialization, a</b>
<b class="nc"><i>3697</i>&nbsp;     * given object is first assigned a handle by calling the assign method.</b>
<b class="nc"><i>3698</i>&nbsp;     * This method leaves the assigned handle in an &quot;open&quot; state, wherein</b>
<i>3699</i>&nbsp;     * dependencies on the exception status of other handles can be registered
<i>3700</i>&nbsp;     * by calling the markDependency method, or an exception can be directly
<i>3701</i>&nbsp;     * associated with the handle by calling markException.  When a handle is
<b class="nc"><i>3702</i>&nbsp;     * tagged with an exception, the HandleTable assumes responsibility for</b>
<i>3703</i>&nbsp;     * propagating the exception to any other objects which depend
<i>3704</i>&nbsp;     * (transitively) on the exception-tagged object.
<b class="nc"><i>3705</i>&nbsp;     *</b>
<i>3706</i>&nbsp;     * &lt;p&gt;Once all exception information/dependencies for the handle have been
<i>3707</i>&nbsp;     * registered, the handle should be &quot;closed&quot; by calling the finish method
<i>3708</i>&nbsp;     * on it.  The act of finishing a handle allows the exception propagation
<i>3709</i>&nbsp;     * algorithm to aggressively prune dependency links, lessening the
<i>3710</i>&nbsp;     * performance/memory impact of exception tracking.
<i>3711</i>&nbsp;     *
<i>3712</i>&nbsp;     * &lt;p&gt;Note that the exception propagation algorithm used depends on handles
<i>3713</i>&nbsp;     * being assigned/finished in LIFO order; however, for simplicity as well
<i>3714</i>&nbsp;     * as memory conservation, it does not enforce this constraint.
<i>3715</i>&nbsp;     */
<i>3716</i>&nbsp;    // REMIND: add full description of exception propagation algorithm?
<b class="nc"><i>3717</i>&nbsp;    private static class HandleTable {</b>
<i>3718</i>&nbsp;
<i>3719</i>&nbsp;        /* status codes indicating whether object has associated exception */
<b class="nc"><i>3720</i>&nbsp;        private static final byte STATUS_OK = 1;</b>
<b class="nc"><i>3721</i>&nbsp;        private static final byte STATUS_UNKNOWN = 2;</b>
<i>3722</i>&nbsp;        private static final byte STATUS_EXCEPTION = 3;
<i>3723</i>&nbsp;
<b class="nc"><i>3724</i>&nbsp;        /** array mapping handle -&gt; object status */</b>
<i>3725</i>&nbsp;        byte[] status;
<i>3726</i>&nbsp;        /** array mapping handle -&gt; object/exception (depending on status) */
<b class="nc"><i>3727</i>&nbsp;        Object[] entries;</b>
<i>3728</i>&nbsp;        /** array mapping handle -&gt; list of dependent handles (if any) */
<i>3729</i>&nbsp;        HandleList[] deps;
<i>3730</i>&nbsp;        /** lowest unresolved dependency */
<i>3731</i>&nbsp;        int lowDep = -1;
<i>3732</i>&nbsp;        /** number of handles in table */
<i>3733</i>&nbsp;        int size = 0;
<i>3734</i>&nbsp;
<i>3735</i>&nbsp;        /**
<i>3736</i>&nbsp;         * Creates handle table with the given initial capacity.
<b class="nc"><i>3737</i>&nbsp;         */</b>
<i>3738</i>&nbsp;        HandleTable(int initialCapacity) {
<i>3739</i>&nbsp;            status = new byte[initialCapacity];
<i>3740</i>&nbsp;            entries = new Object[initialCapacity];
<i>3741</i>&nbsp;            deps = new HandleList[initialCapacity];
<i>3742</i>&nbsp;        }
<i>3743</i>&nbsp;
<i>3744</i>&nbsp;        /**
<i>3745</i>&nbsp;         * Assigns next available handle to given object, and returns assigned
<i>3746</i>&nbsp;         * handle.  Once object has been completely deserialized (and all
<i>3747</i>&nbsp;         * dependencies on other objects identified), the handle should be
<b class="nc"><i>3748</i>&nbsp;         * &quot;closed&quot; by passing it to finish().</b>
<i>3749</i>&nbsp;         */
<i>3750</i>&nbsp;        int assign(Object obj) {
<i>3751</i>&nbsp;            if (size &gt;= entries.length) {
<i>3752</i>&nbsp;                grow();
<i>3753</i>&nbsp;            }
<i>3754</i>&nbsp;            status[size] = STATUS_UNKNOWN;
<i>3755</i>&nbsp;            entries[size] = obj;
<i>3756</i>&nbsp;            return size++;
<b class="nc"><i>3757</i>&nbsp;        }</b>
<b class="nc"><i>3758</i>&nbsp;</b>
<b class="nc"><i>3759</i>&nbsp;        /**</b>
<b class="nc"><i>3760</i>&nbsp;         * Registers a dependency (in exception status) of one handle on</b>
<b class="nc"><i>3761</i>&nbsp;         * another.  The dependent handle must be &quot;open&quot; (i.e., assigned, but</b>
<i>3762</i>&nbsp;         * not finished yet).  No action is taken if either dependent or target
<i>3763</i>&nbsp;         * handle is NULL_HANDLE. Additionally, no action is taken if the
<i>3764</i>&nbsp;         * dependent and target are the same.
<i>3765</i>&nbsp;         */
<i>3766</i>&nbsp;        void markDependency(int dependent, int target) {
<i>3767</i>&nbsp;            if (dependent == target || dependent == NULL_HANDLE || target == NULL_HANDLE) {
<b class="nc"><i>3768</i>&nbsp;                return;</b>
<i>3769</i>&nbsp;            }
<i>3770</i>&nbsp;            switch (status[dependent]) {
<i>3771</i>&nbsp;
<i>3772</i>&nbsp;                case STATUS_UNKNOWN:
<i>3773</i>&nbsp;                    switch (status[target]) {
<i>3774</i>&nbsp;                        case STATUS_OK:
<b class="nc"><i>3775</i>&nbsp;                            // ignore dependencies on objs with no exception</b>
<i>3776</i>&nbsp;                            break;
<b class="nc"><i>3777</i>&nbsp;</b>
<b class="nc"><i>3778</i>&nbsp;                        case STATUS_EXCEPTION:</b>
<b class="nc"><i>3779</i>&nbsp;                            // eagerly propagate exception</b>
<i>3780</i>&nbsp;                            markException(dependent,
<b class="nc"><i>3781</i>&nbsp;                                (ClassNotFoundException) entries[target]);</b>
<b class="nc"><i>3782</i>&nbsp;                            break;</b>
<b class="nc"><i>3783</i>&nbsp;</b>
<i>3784</i>&nbsp;                        case STATUS_UNKNOWN:
<b class="nc"><i>3785</i>&nbsp;                            // add to dependency list of target</b>
<b class="nc"><i>3786</i>&nbsp;                            if (deps[target] == null) {</b>
<b class="nc"><i>3787</i>&nbsp;                                deps[target] = new HandleList();</b>
<i>3788</i>&nbsp;                            }
<i>3789</i>&nbsp;                            deps[target].add(dependent);
<i>3790</i>&nbsp;
<i>3791</i>&nbsp;                            // remember lowest unresolved target seen
<i>3792</i>&nbsp;                            if (lowDep &lt; 0 || lowDep &gt; target) {
<i>3793</i>&nbsp;                                lowDep = target;
<b class="nc"><i>3794</i>&nbsp;                            }</b>
<b class="nc"><i>3795</i>&nbsp;                            break;</b>
<i>3796</i>&nbsp;
<b class="nc"><i>3797</i>&nbsp;                        default:</b>
<i>3798</i>&nbsp;                            throw new InternalError();
<i>3799</i>&nbsp;                    }
<i>3800</i>&nbsp;                    break;
<b class="nc"><i>3801</i>&nbsp;</b>
<b class="nc"><i>3802</i>&nbsp;                case STATUS_EXCEPTION:</b>
<b class="nc"><i>3803</i>&nbsp;                    break;</b>
<b class="nc"><i>3804</i>&nbsp;</b>
<i>3805</i>&nbsp;                default:
<b class="nc"><i>3806</i>&nbsp;                    throw new InternalError();</b>
<i>3807</i>&nbsp;            }
<i>3808</i>&nbsp;        }
<i>3809</i>&nbsp;
<b class="nc"><i>3810</i>&nbsp;        /**</b>
<b class="nc"><i>3811</i>&nbsp;         * Associates a ClassNotFoundException (if one not already associated)</b>
<i>3812</i>&nbsp;         * with the currently active handle and propagates it to other
<b class="nc"><i>3813</i>&nbsp;         * referencing objects as appropriate.  The specified handle must be</b>
<i>3814</i>&nbsp;         * &quot;open&quot; (i.e., assigned, but not finished yet).
<i>3815</i>&nbsp;         */
<i>3816</i>&nbsp;        void markException(int handle, ClassNotFoundException ex) {
<b class="nc"><i>3817</i>&nbsp;            switch (status[handle]) {</b>
<i>3818</i>&nbsp;                case STATUS_UNKNOWN:
<i>3819</i>&nbsp;                    status[handle] = STATUS_EXCEPTION;
<i>3820</i>&nbsp;                    entries[handle] = ex;
<i>3821</i>&nbsp;
<i>3822</i>&nbsp;                    // propagate exception to dependents
<i>3823</i>&nbsp;                    HandleList dlist = deps[handle];
<i>3824</i>&nbsp;                    if (dlist != null) {
<i>3825</i>&nbsp;                        int ndeps = dlist.size();
<b class="nc"><i>3826</i>&nbsp;                        for (int i = 0; i &lt; ndeps; i++) {</b>
<b class="nc"><i>3827</i>&nbsp;                            markException(dlist.get(i), ex);</b>
<b class="nc"><i>3828</i>&nbsp;                        }</b>
<b class="nc"><i>3829</i>&nbsp;                        deps[handle] = null;</b>
<b class="nc"><i>3830</i>&nbsp;                    }</b>
<b class="nc"><i>3831</i>&nbsp;                    break;</b>
<b class="nc"><i>3832</i>&nbsp;</b>
<b class="nc"><i>3833</i>&nbsp;                case STATUS_EXCEPTION:</b>
<b class="nc"><i>3834</i>&nbsp;                    break;</b>
<b class="nc"><i>3835</i>&nbsp;</b>
<b class="nc"><i>3836</i>&nbsp;                default:</b>
<b class="nc"><i>3837</i>&nbsp;                    throw new InternalError();</b>
<b class="nc"><i>3838</i>&nbsp;            }</b>
<b class="nc"><i>3839</i>&nbsp;        }</b>
<b class="nc"><i>3840</i>&nbsp;</b>
<b class="nc"><i>3841</i>&nbsp;        /**</b>
<b class="nc"><i>3842</i>&nbsp;         * Marks given handle as finished, meaning that no new dependencies</b>
<b class="nc"><i>3843</i>&nbsp;         * will be marked for handle.  Calls to the assign and finish methods</b>
<i>3844</i>&nbsp;         * must occur in LIFO order.
<b class="nc"><i>3845</i>&nbsp;         */</b>
<i>3846</i>&nbsp;        void finish(int handle) {
<i>3847</i>&nbsp;            int end;
<i>3848</i>&nbsp;            if (lowDep &lt; 0) {
<i>3849</i>&nbsp;                // no pending unknowns, only resolve current handle
<b class="nc"><i>3850</i>&nbsp;                end = handle + 1;</b>
<b class="nc"><i>3851</i>&nbsp;            } else if (lowDep &gt;= handle) {</b>
<b class="nc"><i>3852</i>&nbsp;                // pending unknowns now clearable, resolve all upward handles</b>
<i>3853</i>&nbsp;                end = size;
<i>3854</i>&nbsp;                lowDep = -1;
<i>3855</i>&nbsp;            } else {
<i>3856</i>&nbsp;                // unresolved backrefs present, can&#39;t resolve anything yet
<i>3857</i>&nbsp;                return;
<i>3858</i>&nbsp;            }
<i>3859</i>&nbsp;
<b class="nc"><i>3860</i>&nbsp;            // change STATUS_UNKNOWN -&gt; STATUS_OK in selected span of handles</b>
<i>3861</i>&nbsp;            for (int i = handle; i &lt; end; i++) {
<i>3862</i>&nbsp;                switch (status[i]) {
<b class="nc"><i>3863</i>&nbsp;                    case STATUS_UNKNOWN:</b>
<i>3864</i>&nbsp;                        status[i] = STATUS_OK;
<i>3865</i>&nbsp;                        deps[i] = null;
<i>3866</i>&nbsp;                        break;
<i>3867</i>&nbsp;
<i>3868</i>&nbsp;                    case STATUS_OK:
<i>3869</i>&nbsp;                    case STATUS_EXCEPTION:
<i>3870</i>&nbsp;                        break;
<i>3871</i>&nbsp;
<i>3872</i>&nbsp;                    default:
<i>3873</i>&nbsp;                        throw new InternalError();
<i>3874</i>&nbsp;                }
<i>3875</i>&nbsp;            }
<i>3876</i>&nbsp;        }
<i>3877</i>&nbsp;
<i>3878</i>&nbsp;        /**
<i>3879</i>&nbsp;         * Assigns a new object to the given handle.  The object previously
<i>3880</i>&nbsp;         * associated with the handle is forgotten.  This method has no effect
<i>3881</i>&nbsp;         * if the given handle already has an exception associated with it.
<i>3882</i>&nbsp;         * This method may be called at any time after the handle is assigned.
<i>3883</i>&nbsp;         */
<i>3884</i>&nbsp;        void setObject(int handle, Object obj) {
<i>3885</i>&nbsp;            switch (status[handle]) {
<i>3886</i>&nbsp;                case STATUS_UNKNOWN:
<i>3887</i>&nbsp;                case STATUS_OK:
<i>3888</i>&nbsp;                    entries[handle] = obj;
<i>3889</i>&nbsp;                    break;
<i>3890</i>&nbsp;
<i>3891</i>&nbsp;                case STATUS_EXCEPTION:
<i>3892</i>&nbsp;                    break;
<i>3893</i>&nbsp;
<i>3894</i>&nbsp;                default:
<i>3895</i>&nbsp;                    throw new InternalError();
<i>3896</i>&nbsp;            }
<i>3897</i>&nbsp;        }
<i>3898</i>&nbsp;
<i>3899</i>&nbsp;        /**
<i>3900</i>&nbsp;         * Looks up and returns object associated with the given handle.
<i>3901</i>&nbsp;         * Returns null if the given handle is NULL_HANDLE, or if it has an
<i>3902</i>&nbsp;         * associated ClassNotFoundException.
<i>3903</i>&nbsp;         */
<i>3904</i>&nbsp;        Object lookupObject(int handle) {
<i>3905</i>&nbsp;            return (handle != NULL_HANDLE &amp;&amp;
<i>3906</i>&nbsp;                    status[handle] != STATUS_EXCEPTION) ?
<i>3907</i>&nbsp;                entries[handle] : null;
<i>3908</i>&nbsp;        }
<i>3909</i>&nbsp;
<i>3910</i>&nbsp;        /**
<i>3911</i>&nbsp;         * Looks up and returns ClassNotFoundException associated with the
<i>3912</i>&nbsp;         * given handle.  Returns null if the given handle is NULL_HANDLE, or
<i>3913</i>&nbsp;         * if there is no ClassNotFoundException associated with the handle.
<i>3914</i>&nbsp;         */
<i>3915</i>&nbsp;        ClassNotFoundException lookupException(int handle) {
<i>3916</i>&nbsp;            return (handle != NULL_HANDLE &amp;&amp;
<i>3917</i>&nbsp;                    status[handle] == STATUS_EXCEPTION) ?
<i>3918</i>&nbsp;                (ClassNotFoundException) entries[handle] : null;
<i>3919</i>&nbsp;        }
<i>3920</i>&nbsp;
<i>3921</i>&nbsp;        /**
<i>3922</i>&nbsp;         * Resets table to its initial state.
<i>3923</i>&nbsp;         */
<i>3924</i>&nbsp;        void clear() {
<i>3925</i>&nbsp;            Arrays.fill(status, 0, size, (byte) 0);
<i>3926</i>&nbsp;            Arrays.fill(entries, 0, size, null);
<i>3927</i>&nbsp;            Arrays.fill(deps, 0, size, null);
<i>3928</i>&nbsp;            lowDep = -1;
<i>3929</i>&nbsp;            size = 0;
<i>3930</i>&nbsp;        }
<i>3931</i>&nbsp;
<i>3932</i>&nbsp;        /**
<i>3933</i>&nbsp;         * Returns number of handles registered in table.
<i>3934</i>&nbsp;         */
<i>3935</i>&nbsp;        int size() {
<i>3936</i>&nbsp;            return size;
<i>3937</i>&nbsp;        }
<i>3938</i>&nbsp;
<i>3939</i>&nbsp;        /**
<i>3940</i>&nbsp;         * Expands capacity of internal arrays.
<i>3941</i>&nbsp;         */
<i>3942</i>&nbsp;        private void grow() {
<i>3943</i>&nbsp;            int newCapacity = (entries.length &lt;&lt; 1) + 1;
<i>3944</i>&nbsp;
<i>3945</i>&nbsp;            byte[] newStatus = new byte[newCapacity];
<i>3946</i>&nbsp;            Object[] newEntries = new Object[newCapacity];
<i>3947</i>&nbsp;            HandleList[] newDeps = new HandleList[newCapacity];
<i>3948</i>&nbsp;
<i>3949</i>&nbsp;            System.arraycopy(status, 0, newStatus, 0, size);
<i>3950</i>&nbsp;            System.arraycopy(entries, 0, newEntries, 0, size);
<i>3951</i>&nbsp;            System.arraycopy(deps, 0, newDeps, 0, size);
<i>3952</i>&nbsp;
<i>3953</i>&nbsp;            status = newStatus;
<i>3954</i>&nbsp;            entries = newEntries;
<i>3955</i>&nbsp;            deps = newDeps;
<i>3956</i>&nbsp;        }
<i>3957</i>&nbsp;
<i>3958</i>&nbsp;        /**
<i>3959</i>&nbsp;         * Simple growable list of (integer) handles.
<i>3960</i>&nbsp;         */
<i>3961</i>&nbsp;        private static class HandleList {
<i>3962</i>&nbsp;            private int[] list = new int[4];
<i>3963</i>&nbsp;            private int size = 0;
<i>3964</i>&nbsp;
<i>3965</i>&nbsp;            public HandleList() {
<i>3966</i>&nbsp;            }
<i>3967</i>&nbsp;
<i>3968</i>&nbsp;            public void add(int handle) {
<i>3969</i>&nbsp;                if (size &gt;= list.length) {
<i>3970</i>&nbsp;                    int[] newList = new int[list.length &lt;&lt; 1];
<i>3971</i>&nbsp;                    System.arraycopy(list, 0, newList, 0, list.length);
<i>3972</i>&nbsp;                    list = newList;
<i>3973</i>&nbsp;                }
<i>3974</i>&nbsp;                list[size++] = handle;
<i>3975</i>&nbsp;            }
<i>3976</i>&nbsp;
<i>3977</i>&nbsp;            public int get(int index) {
<i>3978</i>&nbsp;                if (index &gt;= size) {
<i>3979</i>&nbsp;                    throw new ArrayIndexOutOfBoundsException();
<i>3980</i>&nbsp;                }
<i>3981</i>&nbsp;                return list[index];
<i>3982</i>&nbsp;            }
<i>3983</i>&nbsp;
<i>3984</i>&nbsp;            public int size() {
<i>3985</i>&nbsp;                return size;
<i>3986</i>&nbsp;            }
<i>3987</i>&nbsp;        }
<i>3988</i>&nbsp;    }
<i>3989</i>&nbsp;
<i>3990</i>&nbsp;    /**
<i>3991</i>&nbsp;     * Method for cloning arrays in case of using unsharing reading
<i>3992</i>&nbsp;     */
<i>3993</i>&nbsp;    private static Object cloneArray(Object array) {
<i>3994</i>&nbsp;        if (array instanceof Object[]) {
<i>3995</i>&nbsp;            return ((Object[]) array).clone();
<i>3996</i>&nbsp;        } else if (array instanceof boolean[]) {
<i>3997</i>&nbsp;            return ((boolean[]) array).clone();
<i>3998</i>&nbsp;        } else if (array instanceof byte[]) {
<i>3999</i>&nbsp;            return ((byte[]) array).clone();
<i>4000</i>&nbsp;        } else if (array instanceof char[]) {
<i>4001</i>&nbsp;            return ((char[]) array).clone();
<i>4002</i>&nbsp;        } else if (array instanceof double[]) {
<i>4003</i>&nbsp;            return ((double[]) array).clone();
<i>4004</i>&nbsp;        } else if (array instanceof float[]) {
<i>4005</i>&nbsp;            return ((float[]) array).clone();
<i>4006</i>&nbsp;        } else if (array instanceof int[]) {
<i>4007</i>&nbsp;            return ((int[]) array).clone();
<i>4008</i>&nbsp;        } else if (array instanceof long[]) {
<i>4009</i>&nbsp;            return ((long[]) array).clone();
<i>4010</i>&nbsp;        } else if (array instanceof short[]) {
<i>4011</i>&nbsp;            return ((short[]) array).clone();
<i>4012</i>&nbsp;        } else {
<i>4013</i>&nbsp;            throw new AssertionError();
<i>4014</i>&nbsp;        }
<i>4015</i>&nbsp;    }
<i>4016</i>&nbsp;
<i>4017</i>&nbsp;    static {
<i>4018</i>&nbsp;        SharedSecrets.setJavaObjectInputStreamAccess(ObjectInputStream::checkArray);
<i>4019</i>&nbsp;    }
<i>4020</i>&nbsp;
<i>4021</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:16</div>
</div>
</body>
</html>
