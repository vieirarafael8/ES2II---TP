


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: BasicSplitPaneUI</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.plaf.basic</a> ]
</div>

<h1>Coverage Summary for Class: BasicSplitPaneUI (javax.swing.plaf.basic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BasicSplitPaneUI</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 55)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 275)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BasicSplitPaneUI$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$Actions</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$BasicHorizontalLayoutManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 296)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$BasicVerticalLayoutManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$FocusHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$Handler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$KeyboardDownRightHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$KeyboardEndHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$KeyboardHomeHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$KeyboardResizeToggleHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$KeyboardUpLeftHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BasicSplitPaneUI$PropertyHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 114)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 720)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;
<i>27</i>&nbsp;package javax.swing.plaf.basic;
<i>28</i>&nbsp;
<i>29</i>&nbsp;
<i>30</i>&nbsp;import sun.awt.AWTAccessor;
<i>31</i>&nbsp;import sun.awt.AWTAccessor.ComponentAccessor;
<i>32</i>&nbsp;import sun.swing.DefaultLookup;
<i>33</i>&nbsp;import sun.swing.UIAction;
<i>34</i>&nbsp;import javax.swing.*;
<i>35</i>&nbsp;import javax.swing.border.Border;
<i>36</i>&nbsp;import java.awt.*;
<i>37</i>&nbsp;import java.awt.event.*;
<i>38</i>&nbsp;import java.awt.peer.ComponentPeer;
<i>39</i>&nbsp;import java.awt.peer.LightweightPeer;
<i>40</i>&nbsp;import java.beans.*;
<i>41</i>&nbsp;import java.util.*;
<i>42</i>&nbsp;import javax.swing.plaf.SplitPaneUI;
<i>43</i>&nbsp;import javax.swing.plaf.ComponentUI;
<i>44</i>&nbsp;import javax.swing.plaf.UIResource;
<i>45</i>&nbsp;import sun.swing.SwingUtilities2;
<i>46</i>&nbsp;
<i>47</i>&nbsp;
<i>48</i>&nbsp;/**
<i>49</i>&nbsp; * A Basic L&amp;amp;F implementation of the SplitPaneUI.
<i>50</i>&nbsp; *
<i>51</i>&nbsp; * @author Scott Violet
<i>52</i>&nbsp; * @author Steve Wilson
<b class="nc"><i>53</i>&nbsp; * @author Ralph Kar</b>
<i>54</i>&nbsp; */
<i>55</i>&nbsp;public class BasicSplitPaneUI extends SplitPaneUI
<i>56</i>&nbsp;{
<i>57</i>&nbsp;    /**
<i>58</i>&nbsp;     * The divider used for non-continuous layout is added to the split pane
<i>59</i>&nbsp;     * with this object.
<i>60</i>&nbsp;     */
<i>61</i>&nbsp;    protected static final String NON_CONTINUOUS_DIVIDER =
<i>62</i>&nbsp;        &quot;nonContinuousDivider&quot;;
<i>63</i>&nbsp;
<i>64</i>&nbsp;
<i>65</i>&nbsp;    /**
<i>66</i>&nbsp;     * How far (relative) the divider does move when it is moved around by
<b class="nc"><i>67</i>&nbsp;     * the cursor keys on the keyboard.</b>
<i>68</i>&nbsp;     */
<i>69</i>&nbsp;    protected static int KEYBOARD_DIVIDER_MOVE_OFFSET = 3;
<i>70</i>&nbsp;
<i>71</i>&nbsp;
<i>72</i>&nbsp;    /**
<i>73</i>&nbsp;     * JSplitPane instance this instance is providing
<i>74</i>&nbsp;     * the look and feel for.
<i>75</i>&nbsp;     */
<i>76</i>&nbsp;    protected JSplitPane splitPane;
<i>77</i>&nbsp;
<i>78</i>&nbsp;
<i>79</i>&nbsp;    /**
<i>80</i>&nbsp;     * LayoutManager that is created and placed into the split pane.
<i>81</i>&nbsp;     */
<i>82</i>&nbsp;    protected BasicHorizontalLayoutManager layoutManager;
<i>83</i>&nbsp;
<i>84</i>&nbsp;
<i>85</i>&nbsp;    /**
<i>86</i>&nbsp;     * Instance of the divider for this JSplitPane.
<i>87</i>&nbsp;     */
<i>88</i>&nbsp;    protected BasicSplitPaneDivider divider;
<i>89</i>&nbsp;
<i>90</i>&nbsp;
<i>91</i>&nbsp;    /**
<i>92</i>&nbsp;     * Instance of the PropertyChangeListener for this JSplitPane.
<i>93</i>&nbsp;     */
<i>94</i>&nbsp;    protected PropertyChangeListener propertyChangeListener;
<i>95</i>&nbsp;
<i>96</i>&nbsp;
<i>97</i>&nbsp;    /**
<i>98</i>&nbsp;     * Instance of the FocusListener for this JSplitPane.
<i>99</i>&nbsp;     */
<i>100</i>&nbsp;    protected FocusListener focusListener;
<i>101</i>&nbsp;
<i>102</i>&nbsp;    private Handler handler;
<i>103</i>&nbsp;
<i>104</i>&nbsp;
<i>105</i>&nbsp;    /**
<i>106</i>&nbsp;     * Keys to use for forward focus traversal when the JComponent is
<i>107</i>&nbsp;     * managing focus.
<i>108</i>&nbsp;     */
<i>109</i>&nbsp;    private Set&lt;KeyStroke&gt; managingFocusForwardTraversalKeys;
<i>110</i>&nbsp;
<i>111</i>&nbsp;    /**
<i>112</i>&nbsp;     * Keys to use for backward focus traversal when the JComponent is
<i>113</i>&nbsp;     * managing focus.
<i>114</i>&nbsp;     */
<i>115</i>&nbsp;    private Set&lt;KeyStroke&gt; managingFocusBackwardTraversalKeys;
<i>116</i>&nbsp;
<i>117</i>&nbsp;
<i>118</i>&nbsp;    /**
<i>119</i>&nbsp;     * The size of the divider while the dragging session is valid.
<i>120</i>&nbsp;     */
<i>121</i>&nbsp;    protected int dividerSize;
<i>122</i>&nbsp;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    /**
<i>125</i>&nbsp;     * Instance for the shadow of the divider when non continuous layout
<i>126</i>&nbsp;     * is being used.
<i>127</i>&nbsp;     */
<i>128</i>&nbsp;    protected Component nonContinuousLayoutDivider;
<i>129</i>&nbsp;
<i>130</i>&nbsp;
<i>131</i>&nbsp;    /**
<i>132</i>&nbsp;     * Set to true in startDragging if any of the children
<i>133</i>&nbsp;     * (not including the nonContinuousLayoutDivider) are heavy weights.
<i>134</i>&nbsp;     */
<i>135</i>&nbsp;    protected boolean draggingHW;
<i>136</i>&nbsp;
<i>137</i>&nbsp;
<i>138</i>&nbsp;    /**
<i>139</i>&nbsp;     * Location of the divider when the dragging session began.
<i>140</i>&nbsp;     */
<i>141</i>&nbsp;    protected int beginDragDividerLocation;
<i>142</i>&nbsp;
<i>143</i>&nbsp;
<i>144</i>&nbsp;    /**
<i>145</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>146</i>&nbsp;     * longer used.
<i>147</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>148</i>&nbsp;     * the key bindings specification for further details.
<i>149</i>&nbsp;     *
<i>150</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>151</i>&nbsp;     */
<i>152</i>&nbsp;    @Deprecated
<i>153</i>&nbsp;    protected KeyStroke upKey;
<i>154</i>&nbsp;    /**
<i>155</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>156</i>&nbsp;     * longer used.
<i>157</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>158</i>&nbsp;     * the key bindings specification for further details.
<i>159</i>&nbsp;     *
<i>160</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>161</i>&nbsp;     */
<i>162</i>&nbsp;    @Deprecated
<i>163</i>&nbsp;    protected KeyStroke downKey;
<i>164</i>&nbsp;    /**
<i>165</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>166</i>&nbsp;     * longer used.
<i>167</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>168</i>&nbsp;     * the key bindings specification for further details.
<i>169</i>&nbsp;     *
<i>170</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    @Deprecated
<i>173</i>&nbsp;    protected KeyStroke leftKey;
<i>174</i>&nbsp;    /**
<i>175</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>176</i>&nbsp;     * longer used.
<i>177</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>178</i>&nbsp;     * the key bindings specification for further details.
<i>179</i>&nbsp;     *
<i>180</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>181</i>&nbsp;     */
<i>182</i>&nbsp;    @Deprecated
<i>183</i>&nbsp;    protected KeyStroke rightKey;
<i>184</i>&nbsp;    /**
<i>185</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>186</i>&nbsp;     * longer used.
<i>187</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>188</i>&nbsp;     * the key bindings specification for further details.
<i>189</i>&nbsp;     *
<i>190</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    @Deprecated
<i>193</i>&nbsp;    protected KeyStroke homeKey;
<i>194</i>&nbsp;    /**
<i>195</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>196</i>&nbsp;     * longer used.
<i>197</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>198</i>&nbsp;     * the key bindings specification for further details.
<i>199</i>&nbsp;     *
<i>200</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>201</i>&nbsp;     */
<i>202</i>&nbsp;    @Deprecated
<i>203</i>&nbsp;    protected KeyStroke endKey;
<i>204</i>&nbsp;    /**
<i>205</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>206</i>&nbsp;     * longer used.
<i>207</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>208</i>&nbsp;     * the key bindings specification for further details.
<i>209</i>&nbsp;     *
<i>210</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>211</i>&nbsp;     */
<i>212</i>&nbsp;    @Deprecated
<i>213</i>&nbsp;    protected KeyStroke dividerResizeToggleKey;
<i>214</i>&nbsp;
<i>215</i>&nbsp;    /**
<i>216</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>217</i>&nbsp;     * longer used.
<i>218</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>219</i>&nbsp;     * the key bindings specification for further details.
<i>220</i>&nbsp;     *
<i>221</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>222</i>&nbsp;     */
<i>223</i>&nbsp;    @Deprecated
<i>224</i>&nbsp;    protected ActionListener keyboardUpLeftListener;
<i>225</i>&nbsp;    /**
<i>226</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>227</i>&nbsp;     * longer used.
<i>228</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>229</i>&nbsp;     * the key bindings specification for further details.
<i>230</i>&nbsp;     *
<i>231</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>232</i>&nbsp;     */
<i>233</i>&nbsp;    @Deprecated
<i>234</i>&nbsp;    protected ActionListener keyboardDownRightListener;
<i>235</i>&nbsp;    /**
<i>236</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>237</i>&nbsp;     * longer used.
<i>238</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>239</i>&nbsp;     * the key bindings specification for further details.
<i>240</i>&nbsp;     *
<i>241</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>242</i>&nbsp;     */
<i>243</i>&nbsp;    @Deprecated
<i>244</i>&nbsp;    protected ActionListener keyboardHomeListener;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>247</i>&nbsp;     * longer used.
<i>248</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>249</i>&nbsp;     * the key bindings specification for further details.
<i>250</i>&nbsp;     *
<i>251</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>252</i>&nbsp;     */
<i>253</i>&nbsp;    @Deprecated
<i>254</i>&nbsp;    protected ActionListener keyboardEndListener;
<i>255</i>&nbsp;    /**
<i>256</i>&nbsp;     * As of Java 2 platform v1.3 this previously undocumented field is no
<i>257</i>&nbsp;     * longer used.
<i>258</i>&nbsp;     * Key bindings are now defined by the LookAndFeel, please refer to
<i>259</i>&nbsp;     * the key bindings specification for further details.
<i>260</i>&nbsp;     *
<i>261</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>262</i>&nbsp;     */
<i>263</i>&nbsp;    @Deprecated
<i>264</i>&nbsp;    protected ActionListener keyboardResizeToggleListener;
<i>265</i>&nbsp;
<i>266</i>&nbsp;
<i>267</i>&nbsp;    // Private data of the instance
<i>268</i>&nbsp;    private int         orientation;
<i>269</i>&nbsp;    private int         lastDragLocation;
<i>270</i>&nbsp;    private boolean     continuousLayout;
<i>271</i>&nbsp;    private boolean     dividerKeyboardResize;
<i>272</i>&nbsp;    private boolean     dividerLocationIsSet;  // needed for tracking
<i>273</i>&nbsp;                                               // the first occurrence of
<i>274</i>&nbsp;                                               // setDividerLocation()
<i>275</i>&nbsp;    private Color dividerDraggingColor;
<i>276</i>&nbsp;    private boolean rememberPaneSizes;
<b class="nc"><i>277</i>&nbsp;</b>
<i>278</i>&nbsp;    // Indicates whether the one of splitpane sides is expanded
<i>279</i>&nbsp;    private boolean keepHidden = false;
<i>280</i>&nbsp;
<i>281</i>&nbsp;    /** Indicates that we have painted once. */
<i>282</i>&nbsp;    // This is used by the LayoutManager to determine when it should use
<i>283</i>&nbsp;    // the divider location provided by the JSplitPane. This is used as there
<i>284</i>&nbsp;    // is no way to determine when the layout process has completed.
<i>285</i>&nbsp;    boolean             painted;
<i>286</i>&nbsp;    /** If true, setDividerLocation does nothing. */
<i>287</i>&nbsp;    boolean             ignoreDividerLocationChange;
<i>288</i>&nbsp;
<i>289</i>&nbsp;
<i>290</i>&nbsp;    /**
<i>291</i>&nbsp;     * Creates a new instance of {@code BasicSplitPaneUI}.
<b class="nc"><i>292</i>&nbsp;     *</b>
<i>293</i>&nbsp;     * @param x a component
<i>294</i>&nbsp;     * @return a new instance of {@code BasicSplitPaneUI}
<i>295</i>&nbsp;     */
<b class="nc"><i>296</i>&nbsp;    public static ComponentUI createUI(JComponent x) {</b>
<b class="nc"><i>297</i>&nbsp;        return new BasicSplitPaneUI();</b>
<b class="nc"><i>298</i>&nbsp;    }</b>
<b class="nc"><i>299</i>&nbsp;</b>
<b class="nc"><i>300</i>&nbsp;    static void loadActionMap(LazyActionMap map) {</b>
<b class="nc"><i>301</i>&nbsp;        map.put(new Actions(Actions.NEGATIVE_INCREMENT));</b>
<b class="nc"><i>302</i>&nbsp;        map.put(new Actions(Actions.POSITIVE_INCREMENT));</b>
<b class="nc"><i>303</i>&nbsp;        map.put(new Actions(Actions.SELECT_MIN));</b>
<i>304</i>&nbsp;        map.put(new Actions(Actions.SELECT_MAX));
<i>305</i>&nbsp;        map.put(new Actions(Actions.START_RESIZE));
<i>306</i>&nbsp;        map.put(new Actions(Actions.TOGGLE_FOCUS));
<i>307</i>&nbsp;        map.put(new Actions(Actions.FOCUS_OUT_FORWARD));
<i>308</i>&nbsp;        map.put(new Actions(Actions.FOCUS_OUT_BACKWARD));
<i>309</i>&nbsp;    }
<i>310</i>&nbsp;
<i>311</i>&nbsp;
<b class="nc"><i>312</i>&nbsp;</b>
<b class="nc"><i>313</i>&nbsp;    /**</b>
<b class="nc"><i>314</i>&nbsp;     * Installs the UI.</b>
<b class="nc"><i>315</i>&nbsp;     */</b>
<b class="nc"><i>316</i>&nbsp;    public void installUI(JComponent c) {</b>
<b class="nc"><i>317</i>&nbsp;        splitPane = (JSplitPane) c;</b>
<b class="nc"><i>318</i>&nbsp;        dividerLocationIsSet = false;</b>
<b class="nc"><i>319</i>&nbsp;        dividerKeyboardResize = false;</b>
<i>320</i>&nbsp;        keepHidden = false;
<i>321</i>&nbsp;        installDefaults();
<i>322</i>&nbsp;        installListeners();
<i>323</i>&nbsp;        installKeyboardActions();
<i>324</i>&nbsp;        setLastDragLocation(-1);
<i>325</i>&nbsp;    }
<i>326</i>&nbsp;
<b class="nc"><i>327</i>&nbsp;</b>
<b class="nc"><i>328</i>&nbsp;    /**</b>
<i>329</i>&nbsp;     * Installs the UI defaults.
<b class="nc"><i>330</i>&nbsp;     */</b>
<i>331</i>&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
<b class="nc"><i>332</i>&nbsp;    protected void installDefaults(){</b>
<b class="nc"><i>333</i>&nbsp;        LookAndFeel.installBorder(splitPane, &quot;SplitPane.border&quot;);</b>
<i>334</i>&nbsp;        LookAndFeel.installColors(splitPane, &quot;SplitPane.background&quot;,
<b class="nc"><i>335</i>&nbsp;                                  &quot;SplitPane.foreground&quot;);</b>
<i>336</i>&nbsp;        LookAndFeel.installProperty(splitPane, &quot;opaque&quot;, Boolean.TRUE);
<b class="nc"><i>337</i>&nbsp;</b>
<b class="nc"><i>338</i>&nbsp;        if (divider == null) divider = createDefaultDivider();</b>
<i>339</i>&nbsp;        divider.setBasicSplitPaneUI(this);
<i>340</i>&nbsp;
<b class="nc"><i>341</i>&nbsp;        Border    b = divider.getBorder();</b>
<i>342</i>&nbsp;
<b class="nc"><i>343</i>&nbsp;        if (b == null || !(b instanceof UIResource)) {</b>
<i>344</i>&nbsp;            divider.setBorder(UIManager.getBorder(&quot;SplitPaneDivider.border&quot;));
<i>345</i>&nbsp;        }
<i>346</i>&nbsp;
<b class="nc"><i>347</i>&nbsp;        dividerDraggingColor = UIManager.getColor(&quot;SplitPaneDivider.draggingColor&quot;);</b>
<b class="nc"><i>348</i>&nbsp;</b>
<i>349</i>&nbsp;        setOrientation(splitPane.getOrientation());
<b class="nc"><i>350</i>&nbsp;</b>
<b class="nc"><i>351</i>&nbsp;        // note: don&#39;t rename this temp variable to dividerSize</b>
<b class="nc"><i>352</i>&nbsp;        // since it will conflict with &quot;this.dividerSize&quot; field</b>
<i>353</i>&nbsp;        Integer temp = (Integer)UIManager.get(&quot;SplitPane.dividerSize&quot;);
<b class="nc"><i>354</i>&nbsp;        LookAndFeel.installProperty(splitPane, &quot;dividerSize&quot;, temp == null? 10: temp);</b>
<i>355</i>&nbsp;
<b class="nc"><i>356</i>&nbsp;        divider.setDividerSize(splitPane.getDividerSize());</b>
<i>357</i>&nbsp;        dividerSize = divider.getDividerSize();
<i>358</i>&nbsp;        splitPane.add(divider, JSplitPane.DIVIDER);
<i>359</i>&nbsp;
<b class="nc"><i>360</i>&nbsp;        setContinuousLayout(splitPane.isContinuousLayout());</b>
<b class="nc"><i>361</i>&nbsp;</b>
<b class="nc"><i>362</i>&nbsp;        resetLayoutManager();</b>
<i>363</i>&nbsp;
<i>364</i>&nbsp;        /* Install the nonContinuousLayoutDivider here to avoid having to
<b class="nc"><i>365</i>&nbsp;        add/remove everything later. */</b>
<i>366</i>&nbsp;        if(nonContinuousLayoutDivider == null) {
<i>367</i>&nbsp;            setNonContinuousLayoutDivider(
<i>368</i>&nbsp;                                createDefaultNonContinuousLayoutDivider(),
<b class="nc"><i>369</i>&nbsp;                                true);</b>
<b class="nc"><i>370</i>&nbsp;        } else {</b>
<b class="nc"><i>371</i>&nbsp;            setNonContinuousLayoutDivider(nonContinuousLayoutDivider, true);</b>
<b class="nc"><i>372</i>&nbsp;        }</b>
<i>373</i>&nbsp;
<b class="nc"><i>374</i>&nbsp;        // focus forward traversal key</b>
<i>375</i>&nbsp;        if (managingFocusForwardTraversalKeys==null) {
<i>376</i>&nbsp;            managingFocusForwardTraversalKeys = new HashSet&lt;KeyStroke&gt;();
<b class="nc"><i>377</i>&nbsp;            managingFocusForwardTraversalKeys.add(</b>
<b class="nc"><i>378</i>&nbsp;                KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0));</b>
<b class="nc"><i>379</i>&nbsp;        }</b>
<b class="nc"><i>380</i>&nbsp;        splitPane.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,</b>
<i>381</i>&nbsp;                                        managingFocusForwardTraversalKeys);
<b class="nc"><i>382</i>&nbsp;        // focus backward traversal key</b>
<i>383</i>&nbsp;        if (managingFocusBackwardTraversalKeys==null) {
<i>384</i>&nbsp;            managingFocusBackwardTraversalKeys = new HashSet&lt;KeyStroke&gt;();
<i>385</i>&nbsp;            managingFocusBackwardTraversalKeys.add(
<i>386</i>&nbsp;                KeyStroke.getKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_MASK));
<i>387</i>&nbsp;        }
<i>388</i>&nbsp;        splitPane.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
<i>389</i>&nbsp;                                        managingFocusBackwardTraversalKeys);
<i>390</i>&nbsp;    }
<b class="nc"><i>391</i>&nbsp;</b>
<i>392</i>&nbsp;
<b class="nc"><i>393</i>&nbsp;    /**</b>
<i>394</i>&nbsp;     * Installs the event listeners for the UI.
<i>395</i>&nbsp;     */
<b class="nc"><i>396</i>&nbsp;    protected void installListeners() {</b>
<b class="nc"><i>397</i>&nbsp;        if ((propertyChangeListener = createPropertyChangeListener()) !=</b>
<i>398</i>&nbsp;            null) {
<i>399</i>&nbsp;            splitPane.addPropertyChangeListener(propertyChangeListener);
<i>400</i>&nbsp;        }
<i>401</i>&nbsp;
<i>402</i>&nbsp;        if ((focusListener = createFocusListener()) != null) {
<i>403</i>&nbsp;            splitPane.addFocusListener(focusListener);
<i>404</i>&nbsp;        }
<i>405</i>&nbsp;    }
<b class="nc"><i>406</i>&nbsp;</b>
<i>407</i>&nbsp;
<i>408</i>&nbsp;    /**
<b class="nc"><i>409</i>&nbsp;     * Installs the keyboard actions for the UI.</b>
<i>410</i>&nbsp;     */
<i>411</i>&nbsp;    protected void installKeyboardActions() {
<b class="nc"><i>412</i>&nbsp;        InputMap km = getInputMap(JComponent.</b>
<i>413</i>&nbsp;                                  WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
<i>414</i>&nbsp;
<i>415</i>&nbsp;        SwingUtilities.replaceUIInputMap(splitPane, JComponent.
<i>416</i>&nbsp;                                       WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
<b class="nc"><i>417</i>&nbsp;                                       km);</b>
<b class="nc"><i>418</i>&nbsp;        LazyActionMap.installLazyActionMap(splitPane, BasicSplitPaneUI.class,</b>
<i>419</i>&nbsp;                                           &quot;SplitPane.actionMap&quot;);
<i>420</i>&nbsp;    }
<b class="nc"><i>421</i>&nbsp;</b>
<i>422</i>&nbsp;    InputMap getInputMap(int condition) {
<i>423</i>&nbsp;        if (condition == JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT) {
<i>424</i>&nbsp;            return (InputMap)DefaultLookup.get(splitPane, this,
<i>425</i>&nbsp;                                               &quot;SplitPane.ancestorInputMap&quot;);
<i>426</i>&nbsp;        }
<i>427</i>&nbsp;        return null;
<b class="nc"><i>428</i>&nbsp;    }</b>
<b class="nc"><i>429</i>&nbsp;</b>
<b class="nc"><i>430</i>&nbsp;    /**</b>
<b class="nc"><i>431</i>&nbsp;     * Uninstalls the UI.</b>
<b class="nc"><i>432</i>&nbsp;     */</b>
<b class="nc"><i>433</i>&nbsp;    public void uninstallUI(JComponent c) {</b>
<i>434</i>&nbsp;        uninstallKeyboardActions();
<i>435</i>&nbsp;        uninstallListeners();
<i>436</i>&nbsp;        uninstallDefaults();
<i>437</i>&nbsp;        dividerLocationIsSet = false;
<i>438</i>&nbsp;        dividerKeyboardResize = false;
<i>439</i>&nbsp;        splitPane = null;
<i>440</i>&nbsp;    }
<b class="nc"><i>441</i>&nbsp;</b>
<b class="nc"><i>442</i>&nbsp;</b>
<i>443</i>&nbsp;    /**
<i>444</i>&nbsp;     * Uninstalls the UI defaults.
<b class="nc"><i>445</i>&nbsp;     */</b>
<b class="nc"><i>446</i>&nbsp;    protected void uninstallDefaults() {</b>
<i>447</i>&nbsp;        if(splitPane.getLayout() == layoutManager) {
<i>448</i>&nbsp;            splitPane.setLayout(null);
<b class="nc"><i>449</i>&nbsp;        }</b>
<i>450</i>&nbsp;
<b class="nc"><i>451</i>&nbsp;        if(nonContinuousLayoutDivider != null) {</b>
<i>452</i>&nbsp;            splitPane.remove(nonContinuousLayoutDivider);
<b class="nc"><i>453</i>&nbsp;        }</b>
<b class="nc"><i>454</i>&nbsp;</b>
<i>455</i>&nbsp;        LookAndFeel.uninstallBorder(splitPane);
<i>456</i>&nbsp;
<b class="nc"><i>457</i>&nbsp;        Border    b = divider.getBorder();</b>
<b class="nc"><i>458</i>&nbsp;</b>
<b class="nc"><i>459</i>&nbsp;        if (b instanceof UIResource) {</b>
<b class="nc"><i>460</i>&nbsp;            divider.setBorder(null);</b>
<b class="nc"><i>461</i>&nbsp;        }</b>
<i>462</i>&nbsp;
<b class="nc"><i>463</i>&nbsp;        splitPane.remove(divider);</b>
<i>464</i>&nbsp;        divider.setBasicSplitPaneUI(null);
<i>465</i>&nbsp;        layoutManager = null;
<i>466</i>&nbsp;        divider = null;
<b class="nc"><i>467</i>&nbsp;        nonContinuousLayoutDivider = null;</b>
<b class="nc"><i>468</i>&nbsp;</b>
<i>469</i>&nbsp;        setNonContinuousLayoutDivider(null);
<i>470</i>&nbsp;
<i>471</i>&nbsp;        // sets the focus forward and backward traversal keys to null
<i>472</i>&nbsp;        // to restore the defaults
<i>473</i>&nbsp;        splitPane.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, null);
<i>474</i>&nbsp;        splitPane.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, null);
<i>475</i>&nbsp;    }
<b class="nc"><i>476</i>&nbsp;</b>
<b class="nc"><i>477</i>&nbsp;</b>
<b class="nc"><i>478</i>&nbsp;    /**</b>
<i>479</i>&nbsp;     * Uninstalls the event listeners for the UI.
<b class="nc"><i>480</i>&nbsp;     */</b>
<b class="nc"><i>481</i>&nbsp;    protected void uninstallListeners() {</b>
<b class="nc"><i>482</i>&nbsp;        if (propertyChangeListener != null) {</b>
<i>483</i>&nbsp;            splitPane.removePropertyChangeListener(propertyChangeListener);
<i>484</i>&nbsp;            propertyChangeListener = null;
<b class="nc"><i>485</i>&nbsp;        }</b>
<b class="nc"><i>486</i>&nbsp;        if (focusListener != null) {</b>
<b class="nc"><i>487</i>&nbsp;            splitPane.removeFocusListener(focusListener);</b>
<b class="nc"><i>488</i>&nbsp;            focusListener = null;</b>
<b class="nc"><i>489</i>&nbsp;        }</b>
<b class="nc"><i>490</i>&nbsp;</b>
<i>491</i>&nbsp;        keyboardUpLeftListener = null;
<i>492</i>&nbsp;        keyboardDownRightListener = null;
<i>493</i>&nbsp;        keyboardHomeListener = null;
<i>494</i>&nbsp;        keyboardEndListener = null;
<i>495</i>&nbsp;        keyboardResizeToggleListener = null;
<i>496</i>&nbsp;        handler = null;
<i>497</i>&nbsp;    }
<b class="nc"><i>498</i>&nbsp;</b>
<b class="nc"><i>499</i>&nbsp;</b>
<i>500</i>&nbsp;    /**
<i>501</i>&nbsp;     * Uninstalls the keyboard actions for the UI.
<i>502</i>&nbsp;     */
<i>503</i>&nbsp;    protected void uninstallKeyboardActions() {
<i>504</i>&nbsp;        SwingUtilities.replaceUIActionMap(splitPane, null);
<i>505</i>&nbsp;        SwingUtilities.replaceUIInputMap(splitPane, JComponent.
<i>506</i>&nbsp;                                      WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
<i>507</i>&nbsp;                                      null);
<i>508</i>&nbsp;    }
<b class="nc"><i>509</i>&nbsp;</b>
<i>510</i>&nbsp;
<i>511</i>&nbsp;    /**
<i>512</i>&nbsp;     * Creates a {@code PropertyChangeListener} for the {@code JSplitPane} UI.
<b class="nc"><i>513</i>&nbsp;     *</b>
<b class="nc"><i>514</i>&nbsp;     * @return an instance of {@code PropertyChangeListener}</b>
<i>515</i>&nbsp;     */
<b class="nc"><i>516</i>&nbsp;    protected PropertyChangeListener createPropertyChangeListener() {</b>
<i>517</i>&nbsp;        return getHandler();
<i>518</i>&nbsp;    }
<i>519</i>&nbsp;
<i>520</i>&nbsp;    private Handler getHandler() {
<i>521</i>&nbsp;        if (handler == null) {
<i>522</i>&nbsp;            handler = new Handler();
<i>523</i>&nbsp;        }
<b class="nc"><i>524</i>&nbsp;        return handler;</b>
<i>525</i>&nbsp;    }
<i>526</i>&nbsp;
<i>527</i>&nbsp;
<i>528</i>&nbsp;    /**
<i>529</i>&nbsp;     * Creates a {@code FocusListener} for the {@code JSplitPane} UI.
<i>530</i>&nbsp;     *
<i>531</i>&nbsp;     * @return an instance of {@code FocusListener}
<i>532</i>&nbsp;     */
<i>533</i>&nbsp;    protected FocusListener createFocusListener() {
<i>534</i>&nbsp;        return getHandler();
<i>535</i>&nbsp;    }
<i>536</i>&nbsp;
<i>537</i>&nbsp;
<i>538</i>&nbsp;    /**
<i>539</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used.
<i>540</i>&nbsp;     * Subclassers previously using this method should instead create
<i>541</i>&nbsp;     * an {@code Action} wrapping the {@code ActionListener}, and register
<i>542</i>&nbsp;     * that {@code Action} by overriding {@code installKeyboardActions}
<b class="nc"><i>543</i>&nbsp;     * and placing the {@code Action} in the {@code SplitPane&#39;s ActionMap}.</b>
<i>544</i>&nbsp;     * Please refer to the key bindings specification for further details.
<i>545</i>&nbsp;     * &lt;p&gt;
<i>546</i>&nbsp;     * Creates an {@code ActionListener} for the {@code JSplitPane} UI that
<i>547</i>&nbsp;     * listens for specific key presses.
<i>548</i>&nbsp;     *
<i>549</i>&nbsp;     * @return an instance of {@code ActionListener}
<i>550</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>551</i>&nbsp;     */
<i>552</i>&nbsp;    @Deprecated
<i>553</i>&nbsp;    protected ActionListener createKeyboardUpLeftListener() {
<i>554</i>&nbsp;        return new KeyboardUpLeftHandler();
<i>555</i>&nbsp;    }
<i>556</i>&nbsp;
<i>557</i>&nbsp;
<i>558</i>&nbsp;    /**
<i>559</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used.
<i>560</i>&nbsp;     * Subclassers previously using this method should instead create
<i>561</i>&nbsp;     * an {@code Action} wrapping the {@code ActionListener}, and register
<b class="nc"><i>562</i>&nbsp;     * that {@code Action} by overriding {@code installKeyboardActions}</b>
<i>563</i>&nbsp;     * and placing the {@code Action} in the {@code SplitPane&#39;s ActionMap}.
<i>564</i>&nbsp;     * Please refer to the key bindings specification for further details.
<i>565</i>&nbsp;     * &lt;p&gt;
<i>566</i>&nbsp;     * Creates an {@code ActionListener} for the {@code JSplitPane} UI that
<i>567</i>&nbsp;     * listens for specific key presses.
<i>568</i>&nbsp;     *
<i>569</i>&nbsp;     * @return an instance of {@code ActionListener}
<i>570</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>571</i>&nbsp;     */
<i>572</i>&nbsp;    @Deprecated
<i>573</i>&nbsp;    protected ActionListener createKeyboardDownRightListener() {
<i>574</i>&nbsp;        return new KeyboardDownRightHandler();
<i>575</i>&nbsp;    }
<i>576</i>&nbsp;
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used.
<i>580</i>&nbsp;     * Subclassers previously using this method should instead create
<b class="nc"><i>581</i>&nbsp;     * an {@code Action} wrapping the {@code ActionListener}, and register</b>
<i>582</i>&nbsp;     * that {@code Action} by overriding {@code installKeyboardActions}
<i>583</i>&nbsp;     * and placing the {@code Action} in the {@code SplitPane&#39;s ActionMap}.
<i>584</i>&nbsp;     * Please refer to the key bindings specification for further details.
<i>585</i>&nbsp;     * &lt;p&gt;
<i>586</i>&nbsp;     * Creates an {@code ActionListener} for the {@code JSplitPane} UI that
<i>587</i>&nbsp;     * listens for specific key presses.
<i>588</i>&nbsp;     *
<i>589</i>&nbsp;     * @return an instance of {@code ActionListener}
<i>590</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>591</i>&nbsp;     */
<i>592</i>&nbsp;    @Deprecated
<i>593</i>&nbsp;    protected ActionListener createKeyboardHomeListener() {
<i>594</i>&nbsp;        return new KeyboardHomeHandler();
<i>595</i>&nbsp;    }
<i>596</i>&nbsp;
<i>597</i>&nbsp;
<i>598</i>&nbsp;    /**
<i>599</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used.
<b class="nc"><i>600</i>&nbsp;     * Subclassers previously using this method should instead create</b>
<i>601</i>&nbsp;     * an {@code Action} wrapping the {@code ActionListener}, and register
<i>602</i>&nbsp;     * that {@code Action} by overriding {@code installKeyboardActions}
<i>603</i>&nbsp;     * and placing the {@code Action} in the {@code SplitPane&#39;s ActionMap}.
<i>604</i>&nbsp;     * Please refer to the key bindings specification for further details.
<i>605</i>&nbsp;     * &lt;p&gt;
<i>606</i>&nbsp;     * Creates an {@code ActionListener} for the {@code JSplitPane} UI that
<i>607</i>&nbsp;     * listens for specific key presses.
<i>608</i>&nbsp;     *
<i>609</i>&nbsp;     * @return an instance of {@code ActionListener}
<i>610</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>611</i>&nbsp;     */
<i>612</i>&nbsp;    @Deprecated
<i>613</i>&nbsp;    protected ActionListener createKeyboardEndListener() {
<i>614</i>&nbsp;        return new KeyboardEndHandler();
<i>615</i>&nbsp;    }
<i>616</i>&nbsp;
<i>617</i>&nbsp;
<i>618</i>&nbsp;    /**
<b class="nc"><i>619</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used.</b>
<i>620</i>&nbsp;     * Subclassers previously using this method should instead create
<i>621</i>&nbsp;     * an {@code Action} wrapping the {@code ActionListener}, and register
<i>622</i>&nbsp;     * that {@code Action} by overriding {@code installKeyboardActions}
<i>623</i>&nbsp;     * and placing the {@code Action} in the {@code SplitPane&#39;s ActionMap}.
<i>624</i>&nbsp;     * Please refer to the key bindings specification for further details.
<i>625</i>&nbsp;     * &lt;p&gt;
<i>626</i>&nbsp;     * Creates an {@code ActionListener} for the {@code JSplitPane} UI that
<b class="nc"><i>627</i>&nbsp;     * listens for specific key presses.</b>
<i>628</i>&nbsp;     *
<i>629</i>&nbsp;     * @return an instance of {@code ActionListener}
<i>630</i>&nbsp;     * @deprecated As of Java 2 platform v1.3.
<i>631</i>&nbsp;     */
<i>632</i>&nbsp;    @Deprecated
<i>633</i>&nbsp;    protected ActionListener createKeyboardResizeToggleListener() {
<i>634</i>&nbsp;        return new KeyboardResizeToggleHandler();
<b class="nc"><i>635</i>&nbsp;    }</b>
<i>636</i>&nbsp;
<i>637</i>&nbsp;
<i>638</i>&nbsp;    /**
<i>639</i>&nbsp;     * Returns the orientation for the {@code JSplitPane}.
<i>640</i>&nbsp;     *
<i>641</i>&nbsp;     * @return the orientation
<i>642</i>&nbsp;     */
<b class="nc"><i>643</i>&nbsp;    public int getOrientation() {</b>
<i>644</i>&nbsp;        return orientation;
<i>645</i>&nbsp;    }
<i>646</i>&nbsp;
<i>647</i>&nbsp;
<i>648</i>&nbsp;    /**
<i>649</i>&nbsp;     * Set the orientation for the {@code JSplitPane}.
<i>650</i>&nbsp;     *
<b class="nc"><i>651</i>&nbsp;     * @param orientation the orientation</b>
<i>652</i>&nbsp;     */
<i>653</i>&nbsp;    public void setOrientation(int orientation) {
<i>654</i>&nbsp;        this.orientation = orientation;
<i>655</i>&nbsp;    }
<i>656</i>&nbsp;
<i>657</i>&nbsp;
<i>658</i>&nbsp;    /**
<b class="nc"><i>659</i>&nbsp;     * Determines whether the {@code JSplitPane} is set to use a continuous layout.</b>
<i>660</i>&nbsp;     *
<i>661</i>&nbsp;     * @return {@code true} if a continuous layout is set
<i>662</i>&nbsp;     */
<i>663</i>&nbsp;    public boolean isContinuousLayout() {
<i>664</i>&nbsp;        return continuousLayout;
<i>665</i>&nbsp;    }
<i>666</i>&nbsp;
<b class="nc"><i>667</i>&nbsp;</b>
<i>668</i>&nbsp;    /**
<i>669</i>&nbsp;     * Turn continuous layout on/off.
<i>670</i>&nbsp;     *
<i>671</i>&nbsp;     * @param b if {@code true} the continuous layout turns on
<i>672</i>&nbsp;     */
<i>673</i>&nbsp;    public void setContinuousLayout(boolean b) {
<b class="nc"><i>674</i>&nbsp;        continuousLayout = b;</b>
<i>675</i>&nbsp;    }
<i>676</i>&nbsp;
<i>677</i>&nbsp;
<i>678</i>&nbsp;    /**
<i>679</i>&nbsp;     * Returns the last drag location of the {@code JSplitPane}.
<i>680</i>&nbsp;     *
<i>681</i>&nbsp;     * @return the last drag location
<i>682</i>&nbsp;     */
<i>683</i>&nbsp;    public int getLastDragLocation() {
<b class="nc"><i>684</i>&nbsp;        return lastDragLocation;</b>
<i>685</i>&nbsp;    }
<i>686</i>&nbsp;
<i>687</i>&nbsp;
<i>688</i>&nbsp;    /**
<i>689</i>&nbsp;     * Set the last drag location of the {@code JSplitPane}.
<i>690</i>&nbsp;     *
<i>691</i>&nbsp;     * @param l the drag location
<i>692</i>&nbsp;     */
<i>693</i>&nbsp;    public void setLastDragLocation(int l) {
<i>694</i>&nbsp;        lastDragLocation = l;
<i>695</i>&nbsp;    }
<i>696</i>&nbsp;
<b class="nc"><i>697</i>&nbsp;    /**</b>
<i>698</i>&nbsp;     * @return increment via keyboard methods.
<i>699</i>&nbsp;     */
<i>700</i>&nbsp;    int getKeyboardMoveIncrement() {
<i>701</i>&nbsp;        return 3;
<i>702</i>&nbsp;    }
<i>703</i>&nbsp;
<i>704</i>&nbsp;    /**
<i>705</i>&nbsp;     * Implementation of the PropertyChangeListener
<i>706</i>&nbsp;     * that the JSplitPane UI uses.
<i>707</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>708</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.</b>
<i>709</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.
<i>710</i>&nbsp;     */
<i>711</i>&nbsp;    public class PropertyHandler implements PropertyChangeListener
<i>712</i>&nbsp;    {
<i>713</i>&nbsp;        // NOTE: This class exists only for backward compatibility. All
<i>714</i>&nbsp;        // its functionality has been moved into Handler. If you need to add
<b class="nc"><i>715</i>&nbsp;        // new functionality add it to the Handler, but make sure this</b>
<i>716</i>&nbsp;        // class calls into the Handler.
<i>717</i>&nbsp;
<i>718</i>&nbsp;        /**
<b class="nc"><i>719</i>&nbsp;         * Messaged from the &lt;code&gt;JSplitPane&lt;/code&gt; the receiver is</b>
<i>720</i>&nbsp;         * contained in.  May potentially reset the layout manager and cause a
<i>721</i>&nbsp;         * &lt;code&gt;validate&lt;/code&gt; to be sent.
<i>722</i>&nbsp;         */
<i>723</i>&nbsp;        public void propertyChange(PropertyChangeEvent e) {
<i>724</i>&nbsp;            getHandler().propertyChange(e);
<i>725</i>&nbsp;        }
<i>726</i>&nbsp;    }
<i>727</i>&nbsp;
<i>728</i>&nbsp;
<i>729</i>&nbsp;    /**
<i>730</i>&nbsp;     * Implementation of the FocusListener that the JSplitPane UI uses.
<b class="nc"><i>731</i>&nbsp;     * &lt;p&gt;</b>
<i>732</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
<i>733</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.
<b class="nc"><i>734</i>&nbsp;     */</b>
<b class="nc"><i>735</i>&nbsp;    public class FocusHandler extends FocusAdapter</b>
<b class="nc"><i>736</i>&nbsp;    {</b>
<i>737</i>&nbsp;        // NOTE: This class exists only for backward compatibility. All
<i>738</i>&nbsp;        // its functionality has been moved into Handler. If you need to add
<i>739</i>&nbsp;        // new functionality add it to the Handler, but make sure this
<i>740</i>&nbsp;        // class calls into the Handler.
<i>741</i>&nbsp;        public void focusGained(FocusEvent ev) {
<i>742</i>&nbsp;            getHandler().focusGained(ev);
<i>743</i>&nbsp;        }
<i>744</i>&nbsp;
<i>745</i>&nbsp;        public void focusLost(FocusEvent ev) {
<i>746</i>&nbsp;            getHandler().focusLost(ev);
<i>747</i>&nbsp;        }
<b class="nc"><i>748</i>&nbsp;    }</b>
<i>749</i>&nbsp;
<i>750</i>&nbsp;
<b class="nc"><i>751</i>&nbsp;    /**</b>
<b class="nc"><i>752</i>&nbsp;     * Implementation of an ActionListener that the JSplitPane UI uses for</b>
<b class="nc"><i>753</i>&nbsp;     * handling specific key presses.</b>
<i>754</i>&nbsp;     * &lt;p&gt;
<i>755</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
<i>756</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.
<i>757</i>&nbsp;     */
<i>758</i>&nbsp;    public class KeyboardUpLeftHandler implements ActionListener
<i>759</i>&nbsp;    {
<i>760</i>&nbsp;        public void actionPerformed(ActionEvent ev) {
<i>761</i>&nbsp;            if (dividerKeyboardResize) {
<i>762</i>&nbsp;                splitPane.setDividerLocation(Math.max(0,getDividerLocation
<i>763</i>&nbsp;                                  (splitPane) - getKeyboardMoveIncrement()));
<i>764</i>&nbsp;            }
<i>765</i>&nbsp;        }
<b class="nc"><i>766</i>&nbsp;    }</b>
<i>767</i>&nbsp;
<i>768</i>&nbsp;    /**
<b class="nc"><i>769</i>&nbsp;     * Implementation of an ActionListener that the JSplitPane UI uses for</b>
<b class="nc"><i>770</i>&nbsp;     * handling specific key presses.</b>
<i>771</i>&nbsp;     * &lt;p&gt;
<i>772</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
<i>773</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.
<i>774</i>&nbsp;     */
<i>775</i>&nbsp;    public class KeyboardDownRightHandler implements ActionListener
<i>776</i>&nbsp;    {
<i>777</i>&nbsp;        public void actionPerformed(ActionEvent ev) {
<i>778</i>&nbsp;            if (dividerKeyboardResize) {
<i>779</i>&nbsp;                splitPane.setDividerLocation(getDividerLocation(splitPane) +
<i>780</i>&nbsp;                                             getKeyboardMoveIncrement());
<i>781</i>&nbsp;            }
<i>782</i>&nbsp;        }
<b class="nc"><i>783</i>&nbsp;    }</b>
<i>784</i>&nbsp;
<i>785</i>&nbsp;
<b class="nc"><i>786</i>&nbsp;    /**</b>
<b class="nc"><i>787</i>&nbsp;     * Implementation of an ActionListener that the JSplitPane UI uses for</b>
<b class="nc"><i>788</i>&nbsp;     * handling specific key presses.</b>
<b class="nc"><i>789</i>&nbsp;     * &lt;p&gt;</b>
<i>790</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
<b class="nc"><i>791</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.</b>
<b class="nc"><i>792</i>&nbsp;     */</b>
<i>793</i>&nbsp;    public class KeyboardHomeHandler implements ActionListener
<i>794</i>&nbsp;    {
<i>795</i>&nbsp;        public void actionPerformed(ActionEvent ev) {
<b class="nc"><i>796</i>&nbsp;            if (dividerKeyboardResize) {</b>
<i>797</i>&nbsp;                splitPane.setDividerLocation(0);
<i>798</i>&nbsp;            }
<i>799</i>&nbsp;        }
<i>800</i>&nbsp;    }
<i>801</i>&nbsp;
<i>802</i>&nbsp;
<i>803</i>&nbsp;    /**
<i>804</i>&nbsp;     * Implementation of an ActionListener that the JSplitPane UI uses for
<i>805</i>&nbsp;     * handling specific key presses.
<i>806</i>&nbsp;     * &lt;p&gt;
<i>807</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.
<i>808</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.
<i>809</i>&nbsp;     */
<i>810</i>&nbsp;    public class KeyboardEndHandler implements ActionListener
<b class="nc"><i>811</i>&nbsp;    {</b>
<i>812</i>&nbsp;        public void actionPerformed(ActionEvent ev) {
<i>813</i>&nbsp;            if (dividerKeyboardResize) {
<b class="nc"><i>814</i>&nbsp;                Insets   insets = splitPane.getInsets();</b>
<b class="nc"><i>815</i>&nbsp;                int      bottomI = (insets != null) ? insets.bottom : 0;</b>
<i>816</i>&nbsp;                int      rightI = (insets != null) ? insets.right : 0;
<i>817</i>&nbsp;
<i>818</i>&nbsp;                if (orientation == JSplitPane.VERTICAL_SPLIT) {
<i>819</i>&nbsp;                    splitPane.setDividerLocation(splitPane.getHeight() -
<i>820</i>&nbsp;                                       bottomI);
<i>821</i>&nbsp;                }
<i>822</i>&nbsp;                else {
<i>823</i>&nbsp;                    splitPane.setDividerLocation(splitPane.getWidth() -
<b class="nc"><i>824</i>&nbsp;                                                 rightI);</b>
<i>825</i>&nbsp;                }
<i>826</i>&nbsp;            }
<i>827</i>&nbsp;        }
<i>828</i>&nbsp;    }
<i>829</i>&nbsp;
<i>830</i>&nbsp;
<i>831</i>&nbsp;    /**
<i>832</i>&nbsp;     * Implementation of an ActionListener that the JSplitPane UI uses for
<b class="nc"><i>833</i>&nbsp;     * handling specific key presses.</b>
<i>834</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>835</i>&nbsp;     * This class should be treated as a &amp;quot;protected&amp;quot; inner class.</b>
<b class="nc"><i>836</i>&nbsp;     * Instantiate it only within subclasses of BasicSplitPaneUI.</b>
<i>837</i>&nbsp;     */
<b class="nc"><i>838</i>&nbsp;    public class KeyboardResizeToggleHandler implements ActionListener</b>
<b class="nc"><i>839</i>&nbsp;    {</b>
<b class="nc"><i>840</i>&nbsp;        public void actionPerformed(ActionEvent ev) {</b>
<i>841</i>&nbsp;            if (!dividerKeyboardResize) {
<b class="nc"><i>842</i>&nbsp;                splitPane.requestFocus();</b>
<i>843</i>&nbsp;            }
<i>844</i>&nbsp;        }
<i>845</i>&nbsp;    }
<i>846</i>&nbsp;
<i>847</i>&nbsp;    /**
<i>848</i>&nbsp;     * Returns the divider between the top Components.
<i>849</i>&nbsp;     *
<i>850</i>&nbsp;     * @return the divider between the top Components
<i>851</i>&nbsp;     */
<i>852</i>&nbsp;    public BasicSplitPaneDivider getDivider() {
<i>853</i>&nbsp;        return divider;
<i>854</i>&nbsp;    }
<i>855</i>&nbsp;
<i>856</i>&nbsp;
<b class="nc"><i>857</i>&nbsp;    /**</b>
<i>858</i>&nbsp;     * Returns the default non continuous layout divider, which is an
<i>859</i>&nbsp;     * instance of {@code Canvas} that fills in the background with dark gray.
<i>860</i>&nbsp;     *
<i>861</i>&nbsp;     * @return the default non continuous layout divider
<i>862</i>&nbsp;     */
<i>863</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;) // anonymous class
<i>864</i>&nbsp;    protected Component createDefaultNonContinuousLayoutDivider() {
<i>865</i>&nbsp;        return new Canvas() {
<b class="nc"><i>866</i>&nbsp;            public void paint(Graphics g) {</b>
<b class="nc"><i>867</i>&nbsp;                if(!isContinuousLayout() &amp;&amp; getLastDragLocation() != -1) {</b>
<b class="nc"><i>868</i>&nbsp;                    Dimension      size = splitPane.getSize();</b>
<i>869</i>&nbsp;
<b class="nc"><i>870</i>&nbsp;                    g.setColor(dividerDraggingColor);</b>
<i>871</i>&nbsp;                    if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<i>872</i>&nbsp;                        g.fillRect(0, 0, dividerSize - 1, size.height - 1);
<i>873</i>&nbsp;                    } else {
<b class="nc"><i>874</i>&nbsp;                        g.fillRect(0, 0, size.width - 1, dividerSize - 1);</b>
<i>875</i>&nbsp;                    }
<i>876</i>&nbsp;                }
<i>877</i>&nbsp;            }
<i>878</i>&nbsp;        };
<i>879</i>&nbsp;    }
<b class="nc"><i>880</i>&nbsp;</b>
<b class="nc"><i>881</i>&nbsp;</b>
<b class="nc"><i>882</i>&nbsp;    /**</b>
<b class="nc"><i>883</i>&nbsp;     * Sets the divider to use when the {@code JSplitPane} is configured to</b>
<i>884</i>&nbsp;     * not continuously layout. This divider will only be used during a
<b class="nc"><i>885</i>&nbsp;     * dragging session. It is recommended that the passed in component</b>
<b class="nc"><i>886</i>&nbsp;     * be a heavy weight.</b>
<b class="nc"><i>887</i>&nbsp;     *</b>
<b class="nc"><i>888</i>&nbsp;     * @param newDivider the new divider</b>
<b class="nc"><i>889</i>&nbsp;     */</b>
<b class="nc"><i>890</i>&nbsp;    protected void setNonContinuousLayoutDivider(Component newDivider) {</b>
<i>891</i>&nbsp;        setNonContinuousLayoutDivider(newDivider, true);
<b class="nc"><i>892</i>&nbsp;    }</b>
<b class="nc"><i>893</i>&nbsp;</b>
<b class="nc"><i>894</i>&nbsp;</b>
<b class="nc"><i>895</i>&nbsp;    /**</b>
<b class="nc"><i>896</i>&nbsp;     * Sets the divider to use.</b>
<b class="nc"><i>897</i>&nbsp;     *</b>
<i>898</i>&nbsp;     * @param newDivider the new divider
<i>899</i>&nbsp;     * @param rememberSizes if {@code true} the pane size is remembered
<i>900</i>&nbsp;     */
<i>901</i>&nbsp;    protected void setNonContinuousLayoutDivider(Component newDivider,
<i>902</i>&nbsp;        boolean rememberSizes) {
<i>903</i>&nbsp;        rememberPaneSizes = rememberSizes;
<i>904</i>&nbsp;        if(nonContinuousLayoutDivider != null &amp;&amp; splitPane != null) {
<i>905</i>&nbsp;            splitPane.remove(nonContinuousLayoutDivider);
<i>906</i>&nbsp;        }
<i>907</i>&nbsp;        nonContinuousLayoutDivider = newDivider;
<i>908</i>&nbsp;    }
<i>909</i>&nbsp;
<b class="nc"><i>910</i>&nbsp;    private void addHeavyweightDivider() {</b>
<i>911</i>&nbsp;        if(nonContinuousLayoutDivider != null &amp;&amp; splitPane != null) {
<i>912</i>&nbsp;
<i>913</i>&nbsp;            /* Needs to remove all the components and re-add them! YECK! */
<i>914</i>&nbsp;            // This is all done so that the nonContinuousLayoutDivider will
<i>915</i>&nbsp;            // be drawn on top of the other components, without this, one
<i>916</i>&nbsp;            // of the heavyweights will draw over the divider!
<i>917</i>&nbsp;            Component             leftC = splitPane.getLeftComponent();
<i>918</i>&nbsp;            Component             rightC = splitPane.getRightComponent();
<b class="nc"><i>919</i>&nbsp;            int                   lastLocation = splitPane.</b>
<i>920</i>&nbsp;                                              getDividerLocation();
<i>921</i>&nbsp;
<i>922</i>&nbsp;            if(leftC != null)
<i>923</i>&nbsp;                splitPane.setLeftComponent(null);
<i>924</i>&nbsp;            if(rightC != null)
<i>925</i>&nbsp;                splitPane.setRightComponent(null);
<i>926</i>&nbsp;            splitPane.remove(divider);
<b class="nc"><i>927</i>&nbsp;            splitPane.add(nonContinuousLayoutDivider, BasicSplitPaneUI.</b>
<i>928</i>&nbsp;                          NON_CONTINUOUS_DIVIDER,
<i>929</i>&nbsp;                          splitPane.getComponentCount());
<i>930</i>&nbsp;            splitPane.setLeftComponent(leftC);
<i>931</i>&nbsp;            splitPane.setRightComponent(rightC);
<i>932</i>&nbsp;            splitPane.add(divider, JSplitPane.DIVIDER);
<i>933</i>&nbsp;            if(rememberPaneSizes) {
<i>934</i>&nbsp;                splitPane.setDividerLocation(lastLocation);
<b class="nc"><i>935</i>&nbsp;            }</b>
<b class="nc"><i>936</i>&nbsp;        }</b>
<b class="nc"><i>937</i>&nbsp;</b>
<b class="nc"><i>938</i>&nbsp;    }</b>
<i>939</i>&nbsp;
<i>940</i>&nbsp;
<i>941</i>&nbsp;    /**
<i>942</i>&nbsp;     * Returns the divider to use when the {@code JSplitPane} is configured to
<i>943</i>&nbsp;     * not continuously layout. This divider will only be used during a
<i>944</i>&nbsp;     * dragging session.
<i>945</i>&nbsp;     *
<i>946</i>&nbsp;     * @return the divider
<b class="nc"><i>947</i>&nbsp;     */</b>
<b class="nc"><i>948</i>&nbsp;    public Component getNonContinuousLayoutDivider() {</b>
<b class="nc"><i>949</i>&nbsp;        return nonContinuousLayoutDivider;</b>
<b class="nc"><i>950</i>&nbsp;    }</b>
<i>951</i>&nbsp;
<b class="nc"><i>952</i>&nbsp;</b>
<b class="nc"><i>953</i>&nbsp;    /**</b>
<b class="nc"><i>954</i>&nbsp;     * Returns the {@code JSplitPane} this instance is currently contained</b>
<b class="nc"><i>955</i>&nbsp;     * in.</b>
<i>956</i>&nbsp;     *
<b class="nc"><i>957</i>&nbsp;     * @return the instance of {@code JSplitPane}</b>
<i>958</i>&nbsp;     */
<i>959</i>&nbsp;    public JSplitPane getSplitPane() {
<b class="nc"><i>960</i>&nbsp;        return splitPane;</b>
<b class="nc"><i>961</i>&nbsp;    }</b>
<i>962</i>&nbsp;
<b class="nc"><i>963</i>&nbsp;</b>
<i>964</i>&nbsp;    /**
<i>965</i>&nbsp;     * Creates the default divider.
<b class="nc"><i>966</i>&nbsp;     *</b>
<i>967</i>&nbsp;     * @return the default divider
<i>968</i>&nbsp;     */
<i>969</i>&nbsp;    public BasicSplitPaneDivider createDefaultDivider() {
<i>970</i>&nbsp;        return new BasicSplitPaneDivider(this);
<i>971</i>&nbsp;    }
<i>972</i>&nbsp;
<i>973</i>&nbsp;
<i>974</i>&nbsp;    /**
<i>975</i>&nbsp;     * Messaged to reset the preferred sizes.
<b class="nc"><i>976</i>&nbsp;     */</b>
<b class="nc"><i>977</i>&nbsp;    public void resetToPreferredSizes(JSplitPane jc) {</b>
<b class="nc"><i>978</i>&nbsp;        if(splitPane != null) {</b>
<i>979</i>&nbsp;            layoutManager.resetToPreferredSizes();
<i>980</i>&nbsp;            splitPane.revalidate();
<i>981</i>&nbsp;            splitPane.repaint();
<i>982</i>&nbsp;        }
<i>983</i>&nbsp;    }
<i>984</i>&nbsp;
<i>985</i>&nbsp;
<b class="nc"><i>986</i>&nbsp;    /**</b>
<b class="nc"><i>987</i>&nbsp;     * Sets the location of the divider to location.</b>
<i>988</i>&nbsp;     */
<b class="nc"><i>989</i>&nbsp;    public void setDividerLocation(JSplitPane jc, int location) {</b>
<b class="nc"><i>990</i>&nbsp;        if (!ignoreDividerLocationChange) {</b>
<b class="nc"><i>991</i>&nbsp;            dividerLocationIsSet = true;</b>
<b class="nc"><i>992</i>&nbsp;            splitPane.revalidate();</b>
<b class="nc"><i>993</i>&nbsp;            splitPane.repaint();</b>
<i>994</i>&nbsp;
<b class="nc"><i>995</i>&nbsp;            if (keepHidden) {</b>
<i>996</i>&nbsp;                Insets insets = splitPane.getInsets();
<b class="nc"><i>997</i>&nbsp;                int orientation = splitPane.getOrientation();</b>
<b class="nc"><i>998</i>&nbsp;                if ((orientation == JSplitPane.VERTICAL_SPLIT &amp;&amp;</b>
<b class="nc"><i>999</i>&nbsp;                     location != insets.top &amp;&amp;</b>
<i>1000</i>&nbsp;                     location != splitPane.getHeight()-divider.getHeight()-insets.top) ||
<b class="nc"><i>1001</i>&nbsp;                    (orientation == JSplitPane.HORIZONTAL_SPLIT &amp;&amp;</b>
<i>1002</i>&nbsp;                     location != insets.left &amp;&amp;
<i>1003</i>&nbsp;                     location != splitPane.getWidth()-divider.getWidth()-insets.left)) {
<i>1004</i>&nbsp;                    setKeepHidden(false);
<b class="nc"><i>1005</i>&nbsp;                }</b>
<i>1006</i>&nbsp;            }
<i>1007</i>&nbsp;        }
<i>1008</i>&nbsp;        else {
<i>1009</i>&nbsp;            ignoreDividerLocationChange = false;
<i>1010</i>&nbsp;        }
<i>1011</i>&nbsp;    }
<i>1012</i>&nbsp;
<b class="nc"><i>1013</i>&nbsp;</b>
<b class="nc"><i>1014</i>&nbsp;    /**</b>
<b class="nc"><i>1015</i>&nbsp;     * Returns the location of the divider, which may differ from what</b>
<i>1016</i>&nbsp;     * the splitpane thinks the location of the divider is.
<b class="nc"><i>1017</i>&nbsp;     */</b>
<b class="nc"><i>1018</i>&nbsp;    public int getDividerLocation(JSplitPane jc) {</b>
<b class="nc"><i>1019</i>&nbsp;        if(orientation == JSplitPane.HORIZONTAL_SPLIT)</b>
<b class="nc"><i>1020</i>&nbsp;            return divider.getLocation().x;</b>
<b class="nc"><i>1021</i>&nbsp;        return divider.getLocation().y;</b>
<i>1022</i>&nbsp;    }
<b class="nc"><i>1023</i>&nbsp;</b>
<b class="nc"><i>1024</i>&nbsp;</b>
<i>1025</i>&nbsp;    /**
<b class="nc"><i>1026</i>&nbsp;     * Gets the minimum location of the divider.</b>
<i>1027</i>&nbsp;     */
<b class="nc"><i>1028</i>&nbsp;    public int getMinimumDividerLocation(JSplitPane jc) {</b>
<b class="nc"><i>1029</i>&nbsp;        int       minLoc = 0;</b>
<b class="nc"><i>1030</i>&nbsp;        Component leftC = splitPane.getLeftComponent();</b>
<b class="nc"><i>1031</i>&nbsp;</b>
<i>1032</i>&nbsp;        if ((leftC != null) &amp;&amp; (leftC.isVisible())) {
<b class="nc"><i>1033</i>&nbsp;            Insets    insets = splitPane.getInsets();</b>
<i>1034</i>&nbsp;            Dimension minSize = leftC.getMinimumSize();
<i>1035</i>&nbsp;            if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<i>1036</i>&nbsp;                minLoc = minSize.width;
<b class="nc"><i>1037</i>&nbsp;            } else {</b>
<i>1038</i>&nbsp;                minLoc = minSize.height;
<i>1039</i>&nbsp;            }
<i>1040</i>&nbsp;            if(insets != null) {
<i>1041</i>&nbsp;                if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<i>1042</i>&nbsp;                    minLoc += insets.left;
<i>1043</i>&nbsp;                } else {
<i>1044</i>&nbsp;                    minLoc += insets.top;
<i>1045</i>&nbsp;                }
<b class="nc"><i>1046</i>&nbsp;            }</b>
<b class="nc"><i>1047</i>&nbsp;        }</b>
<b class="nc"><i>1048</i>&nbsp;        return minLoc;</b>
<i>1049</i>&nbsp;    }
<b class="nc"><i>1050</i>&nbsp;</b>
<b class="nc"><i>1051</i>&nbsp;</b>
<b class="nc"><i>1052</i>&nbsp;    /**</b>
<i>1053</i>&nbsp;     * Gets the maximum location of the divider.
<i>1054</i>&nbsp;     */
<b class="nc"><i>1055</i>&nbsp;    public int getMaximumDividerLocation(JSplitPane jc) {</b>
<i>1056</i>&nbsp;        Dimension splitPaneSize = splitPane.getSize();
<i>1057</i>&nbsp;        int       maxLoc = 0;
<i>1058</i>&nbsp;        Component rightC = splitPane.getRightComponent();
<i>1059</i>&nbsp;
<i>1060</i>&nbsp;        if (rightC != null) {
<i>1061</i>&nbsp;            Insets    insets = splitPane.getInsets();
<i>1062</i>&nbsp;            Dimension minSize = new Dimension(0, 0);
<i>1063</i>&nbsp;            if (rightC.isVisible()) {
<i>1064</i>&nbsp;                minSize = rightC.getMinimumSize();
<i>1065</i>&nbsp;            }
<b class="nc"><i>1066</i>&nbsp;            if(orientation == JSplitPane.HORIZONTAL_SPLIT) {</b>
<b class="nc"><i>1067</i>&nbsp;                maxLoc = splitPaneSize.width - minSize.width;</b>
<b class="nc"><i>1068</i>&nbsp;            } else {</b>
<i>1069</i>&nbsp;                maxLoc = splitPaneSize.height - minSize.height;
<b class="nc"><i>1070</i>&nbsp;            }</b>
<i>1071</i>&nbsp;            maxLoc -= dividerSize;
<i>1072</i>&nbsp;            if(insets != null) {
<i>1073</i>&nbsp;                if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<i>1074</i>&nbsp;                    maxLoc -= insets.right;
<i>1075</i>&nbsp;                } else {
<i>1076</i>&nbsp;                    maxLoc -= insets.top;
<i>1077</i>&nbsp;                }
<i>1078</i>&nbsp;            }
<b class="nc"><i>1079</i>&nbsp;        }</b>
<b class="nc"><i>1080</i>&nbsp;        return Math.max(getMinimumDividerLocation(splitPane), maxLoc);</b>
<b class="nc"><i>1081</i>&nbsp;    }</b>
<i>1082</i>&nbsp;
<i>1083</i>&nbsp;
<i>1084</i>&nbsp;    /**
<i>1085</i>&nbsp;     * Called when the specified split pane has finished painting
<i>1086</i>&nbsp;     * its children.
<i>1087</i>&nbsp;     */
<i>1088</i>&nbsp;    public void finishedPaintingChildren(JSplitPane sp, Graphics g) {
<i>1089</i>&nbsp;        if(sp == splitPane &amp;&amp; getLastDragLocation() != -1 &amp;&amp;
<b class="nc"><i>1090</i>&nbsp;           !isContinuousLayout() &amp;&amp; !draggingHW) {</b>
<b class="nc"><i>1091</i>&nbsp;            Dimension      size = splitPane.getSize();</b>
<b class="nc"><i>1092</i>&nbsp;</b>
<i>1093</i>&nbsp;            g.setColor(dividerDraggingColor);
<i>1094</i>&nbsp;            if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<i>1095</i>&nbsp;                g.fillRect(getLastDragLocation(), 0, dividerSize - 1,
<i>1096</i>&nbsp;                           size.height - 1);
<i>1097</i>&nbsp;            } else {
<i>1098</i>&nbsp;                g.fillRect(0, lastDragLocation, size.width - 1,
<i>1099</i>&nbsp;                           dividerSize - 1);
<i>1100</i>&nbsp;            }
<b class="nc"><i>1101</i>&nbsp;        }</b>
<b class="nc"><i>1102</i>&nbsp;    }</b>
<b class="nc"><i>1103</i>&nbsp;</b>
<i>1104</i>&nbsp;
<i>1105</i>&nbsp;    /**
<i>1106</i>&nbsp;     * {@inheritDoc}
<i>1107</i>&nbsp;     */
<i>1108</i>&nbsp;    public void paint(Graphics g, JComponent jc) {
<i>1109</i>&nbsp;        if (!painted &amp;&amp; splitPane.getDividerLocation()&lt;0) {
<i>1110</i>&nbsp;            ignoreDividerLocationChange = true;
<i>1111</i>&nbsp;            splitPane.setDividerLocation(getDividerLocation(splitPane));
<b class="nc"><i>1112</i>&nbsp;        }</b>
<i>1113</i>&nbsp;        painted = true;
<i>1114</i>&nbsp;    }
<i>1115</i>&nbsp;
<i>1116</i>&nbsp;
<i>1117</i>&nbsp;    /**
<i>1118</i>&nbsp;     * Returns the preferred size for the passed in component,
<i>1119</i>&nbsp;     * This is passed off to the current layout manager.
<i>1120</i>&nbsp;     */
<b class="nc"><i>1121</i>&nbsp;    public Dimension getPreferredSize(JComponent jc) {</b>
<b class="nc"><i>1122</i>&nbsp;        if(splitPane != null)</b>
<i>1123</i>&nbsp;            return layoutManager.preferredLayoutSize(splitPane);
<b class="nc"><i>1124</i>&nbsp;        return new Dimension(0, 0);</b>
<i>1125</i>&nbsp;    }
<b class="nc"><i>1126</i>&nbsp;</b>
<b class="nc"><i>1127</i>&nbsp;</b>
<b class="nc"><i>1128</i>&nbsp;    /**</b>
<b class="nc"><i>1129</i>&nbsp;     * Returns the minimum size for the passed in component,</b>
<i>1130</i>&nbsp;     * This is passed off to the current layout manager.
<i>1131</i>&nbsp;     */
<i>1132</i>&nbsp;    public Dimension getMinimumSize(JComponent jc) {
<i>1133</i>&nbsp;        if(splitPane != null)
<i>1134</i>&nbsp;            return layoutManager.minimumLayoutSize(splitPane);
<i>1135</i>&nbsp;        return new Dimension(0, 0);
<b class="nc"><i>1136</i>&nbsp;    }</b>
<i>1137</i>&nbsp;
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;    /**
<i>1140</i>&nbsp;     * Returns the maximum size for the passed in component,
<i>1141</i>&nbsp;     * This is passed off to the current layout manager.
<i>1142</i>&nbsp;     */
<i>1143</i>&nbsp;    public Dimension getMaximumSize(JComponent jc) {
<b class="nc"><i>1144</i>&nbsp;        if(splitPane != null)</b>
<i>1145</i>&nbsp;            return layoutManager.maximumLayoutSize(splitPane);
<i>1146</i>&nbsp;        return new Dimension(0, 0);
<i>1147</i>&nbsp;    }
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;    /**
<i>1151</i>&nbsp;     * Returns the insets. The insets are returned from the border insets
<b class="nc"><i>1152</i>&nbsp;     * of the current border.</b>
<b class="nc"><i>1153</i>&nbsp;     *</b>
<i>1154</i>&nbsp;     * @param jc a component
<i>1155</i>&nbsp;     * @return the insets
<b class="nc"><i>1156</i>&nbsp;     */</b>
<b class="nc"><i>1157</i>&nbsp;    public Insets getInsets(JComponent jc) {</b>
<b class="nc"><i>1158</i>&nbsp;        return null;</b>
<i>1159</i>&nbsp;    }
<b class="nc"><i>1160</i>&nbsp;</b>
<b class="nc"><i>1161</i>&nbsp;</b>
<i>1162</i>&nbsp;    /**
<b class="nc"><i>1163</i>&nbsp;     * Resets the layout manager based on orientation and messages it</b>
<i>1164</i>&nbsp;     * with invalidateLayout to pull in appropriate Components.
<b class="nc"><i>1165</i>&nbsp;     */</b>
<b class="nc"><i>1166</i>&nbsp;    protected void resetLayoutManager() {</b>
<b class="nc"><i>1167</i>&nbsp;        if(orientation == JSplitPane.HORIZONTAL_SPLIT) {</b>
<b class="nc"><i>1168</i>&nbsp;            layoutManager = new BasicHorizontalLayoutManager(0);</b>
<b class="nc"><i>1169</i>&nbsp;        } else {</b>
<b class="nc"><i>1170</i>&nbsp;            layoutManager = new BasicHorizontalLayoutManager(1);</b>
<b class="nc"><i>1171</i>&nbsp;        }</b>
<b class="nc"><i>1172</i>&nbsp;        splitPane.setLayout(layoutManager);</b>
<i>1173</i>&nbsp;        layoutManager.updateComponents();
<i>1174</i>&nbsp;        splitPane.revalidate();
<b class="nc"><i>1175</i>&nbsp;        splitPane.repaint();</b>
<b class="nc"><i>1176</i>&nbsp;    }</b>
<b class="nc"><i>1177</i>&nbsp;</b>
<b class="nc"><i>1178</i>&nbsp;    /**</b>
<b class="nc"><i>1179</i>&nbsp;     * Set the value to indicate if one of the splitpane sides is expanded.</b>
<i>1180</i>&nbsp;     */
<b class="nc"><i>1181</i>&nbsp;    void setKeepHidden(boolean keepHidden) {</b>
<i>1182</i>&nbsp;        this.keepHidden = keepHidden;
<i>1183</i>&nbsp;    }
<i>1184</i>&nbsp;
<i>1185</i>&nbsp;    /**
<i>1186</i>&nbsp;     * The value returned indicates if one of the splitpane sides is expanded.
<i>1187</i>&nbsp;     * @return true if one of the splitpane sides is expanded, false otherwise.
<i>1188</i>&nbsp;     */
<i>1189</i>&nbsp;    private boolean getKeepHidden() {
<i>1190</i>&nbsp;        return keepHidden;
<i>1191</i>&nbsp;    }
<i>1192</i>&nbsp;
<b class="nc"><i>1193</i>&nbsp;    /**</b>
<b class="nc"><i>1194</i>&nbsp;     * Should be messaged before the dragging session starts, resets</b>
<b class="nc"><i>1195</i>&nbsp;     * lastDragLocation and dividerSize.</b>
<b class="nc"><i>1196</i>&nbsp;     */</b>
<i>1197</i>&nbsp;    protected void startDragging() {
<b class="nc"><i>1198</i>&nbsp;        Component       leftC = splitPane.getLeftComponent();</b>
<i>1199</i>&nbsp;        Component       rightC = splitPane.getRightComponent();
<b class="nc"><i>1200</i>&nbsp;        ComponentPeer   cPeer;</b>
<b class="nc"><i>1201</i>&nbsp;</b>
<b class="nc"><i>1202</i>&nbsp;        beginDragDividerLocation = getDividerLocation(splitPane);</b>
<b class="nc"><i>1203</i>&nbsp;        draggingHW = false;</b>
<b class="nc"><i>1204</i>&nbsp;        final ComponentAccessor acc = AWTAccessor.getComponentAccessor();</b>
<i>1205</i>&nbsp;        if(leftC != null &amp;&amp; (cPeer = acc.getPeer(leftC)) != null &amp;&amp;
<b class="nc"><i>1206</i>&nbsp;           !(cPeer instanceof LightweightPeer)) {</b>
<b class="nc"><i>1207</i>&nbsp;            draggingHW = true;</b>
<i>1208</i>&nbsp;        } else if(rightC != null &amp;&amp; (cPeer = acc.getPeer(rightC)) != null
<b class="nc"><i>1209</i>&nbsp;                  &amp;&amp; !(cPeer instanceof LightweightPeer)) {</b>
<i>1210</i>&nbsp;            draggingHW = true;
<b class="nc"><i>1211</i>&nbsp;        }</b>
<i>1212</i>&nbsp;        if(orientation == JSplitPane.HORIZONTAL_SPLIT) {
<b class="nc"><i>1213</i>&nbsp;            setLastDragLocation(divider.getBounds().x);</b>
<b class="nc"><i>1214</i>&nbsp;            dividerSize = divider.getSize().width;</b>
<b class="nc"><i>1215</i>&nbsp;            if(!isContinuousLayout() &amp;&amp; draggingHW) {</b>
<i>1216</i>&nbsp;                nonContinuousLayoutDivider.setBounds
<b class="nc"><i>1217</i>&nbsp;                        (getLastDragLocation(), 0, dividerSize,</b>
<i>1218</i>&nbsp;                         splitPane.getHeight());
<b class="nc"><i>1219</i>&nbsp;                      addHeavyweightDivider();</b>
<i>1220</i>&nbsp;            }
<b class="nc"><i>1221</i>&nbsp;        } else {</b>
<i>1222</i>&nbsp;            setLastDragLocation(divider.getBounds().y);
<i>1223</i>&nbsp;            dividerSize = divider.getSize().height;
<i>1224</i>&nbsp;            if(!isContinuousLayout() &amp;&amp; draggingHW) {
<i>1225</i>&nbsp;                nonContinuousLayoutDivider.setBounds
<i>1226</i>&nbsp;                        (0, getLastDragLocation(), splitPane.getWidth(),
<i>1227</i>&nbsp;                         dividerSize);
<i>1228</i>&nbsp;                      addHeavyweightDivider();
<i>1229</i>&nbsp;            }
<i>1230</i>&nbsp;        }
<i>1231</i>&nbsp;    }
<i>1232</i>&nbsp;
<i>1233</i>&nbsp;
<i>1234</i>&nbsp;    /**
<b class="nc"><i>1235</i>&nbsp;     * Messaged during a dragging session to move the divider to the</b>
<b class="nc"><i>1236</i>&nbsp;     * passed in {@code location}. If {@code continuousLayout} is {@code true}</b>
<b class="nc"><i>1237</i>&nbsp;     * the location is reset and the splitPane validated.</b>
<b class="nc"><i>1238</i>&nbsp;     *</b>
<b class="nc"><i>1239</i>&nbsp;     * @param location the location of divider</b>
<i>1240</i>&nbsp;     */
<b class="nc"><i>1241</i>&nbsp;    protected void dragDividerTo(int location) {</b>
<b class="nc"><i>1242</i>&nbsp;        if(getLastDragLocation() != location) {</b>
<b class="nc"><i>1243</i>&nbsp;            if(isContinuousLayout()) {</b>
<i>1244</i>&nbsp;                splitPane.setDividerLocation(location);
<i>1245</i>&nbsp;                setLastDragLocation(location);
<b class="nc"><i>1246</i>&nbsp;            } else {</b>
<i>1247</i>&nbsp;                int lastLoc = getLastDragLocation();
<b class="nc"><i>1248</i>&nbsp;</b>
<i>1249</i>&nbsp;                setLastDragLocation(location);
<b class="nc"><i>1250</i>&nbsp;                if(orientation == JSplitPane.HORIZONTAL_SPLIT) {</b>
<i>1251</i>&nbsp;                    if(draggingHW) {
<i>1252</i>&nbsp;                        nonContinuousLayoutDivider.setLocation(
<i>1253</i>&nbsp;                            getLastDragLocation(), 0);
<i>1254</i>&nbsp;                    } else {
<i>1255</i>&nbsp;                        int   splitHeight = splitPane.getHeight();
<i>1256</i>&nbsp;                        splitPane.repaint(lastLoc, 0, dividerSize,
<i>1257</i>&nbsp;                                          splitHeight);
<i>1258</i>&nbsp;                        splitPane.repaint(location, 0, dividerSize,
<i>1259</i>&nbsp;                                          splitHeight);
<i>1260</i>&nbsp;                    }
<i>1261</i>&nbsp;                } else {
<i>1262</i>&nbsp;                    if(draggingHW) {
<i>1263</i>&nbsp;                        nonContinuousLayoutDivider.setLocation(0,
<i>1264</i>&nbsp;                            getLastDragLocation());
<i>1265</i>&nbsp;                    } else {
<b class="nc"><i>1266</i>&nbsp;                        int    splitWidth = splitPane.getWidth();</b>
<i>1267</i>&nbsp;
<i>1268</i>&nbsp;                        splitPane.repaint(0, lastLoc, splitWidth,
<i>1269</i>&nbsp;                                          dividerSize);
<i>1270</i>&nbsp;                        splitPane.repaint(0, location, splitWidth,
<i>1271</i>&nbsp;                                          dividerSize);
<i>1272</i>&nbsp;                    }
<i>1273</i>&nbsp;                }
<i>1274</i>&nbsp;            }
<i>1275</i>&nbsp;        }
<i>1276</i>&nbsp;    }
<i>1277</i>&nbsp;
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;    /**
<i>1280</i>&nbsp;     * Messaged to finish the dragging session. If not continuous display
<i>1281</i>&nbsp;     * the dividers {@code location} will be reset.
<i>1282</i>&nbsp;     *
<i>1283</i>&nbsp;     * @param location the location of divider
<i>1284</i>&nbsp;     */
<i>1285</i>&nbsp;    protected void finishDraggingTo(int location) {
<i>1286</i>&nbsp;        dragDividerTo(location);
<i>1287</i>&nbsp;        setLastDragLocation(-1);
<b class="nc"><i>1288</i>&nbsp;        if(!isContinuousLayout()) {</b>
<i>1289</i>&nbsp;            Component   leftC = splitPane.getLeftComponent();
<i>1290</i>&nbsp;            Rectangle   leftBounds = leftC.getBounds();
<b class="nc"><i>1291</i>&nbsp;</b>
<b class="nc"><i>1292</i>&nbsp;            if (draggingHW) {</b>
<b class="nc"><i>1293</i>&nbsp;                if(orientation == JSplitPane.HORIZONTAL_SPLIT) {</b>
<b class="nc"><i>1294</i>&nbsp;                    nonContinuousLayoutDivider.setLocation(-dividerSize, 0);</b>
<b class="nc"><i>1295</i>&nbsp;                }</b>
<i>1296</i>&nbsp;                else {
<i>1297</i>&nbsp;                    nonContinuousLayoutDivider.setLocation(0, -dividerSize);
<i>1298</i>&nbsp;                }
<i>1299</i>&nbsp;                splitPane.remove(nonContinuousLayoutDivider);
<i>1300</i>&nbsp;            }
<i>1301</i>&nbsp;            splitPane.setDividerLocation(location);
<i>1302</i>&nbsp;        }
<i>1303</i>&nbsp;    }
<i>1304</i>&nbsp;
<i>1305</i>&nbsp;
<b class="nc"><i>1306</i>&nbsp;    /**</b>
<i>1307</i>&nbsp;     * As of Java 2 platform v1.3 this method is no longer used. Instead
<i>1308</i>&nbsp;     * you should set the border on the divider.
<i>1309</i>&nbsp;     * &lt;p&gt;
<i>1310</i>&nbsp;     * Returns the width of one side of the divider border.
<b class="nc"><i>1311</i>&nbsp;     *</b>
<b class="nc"><i>1312</i>&nbsp;     * @return the width of one side of the divider border</b>
<i>1313</i>&nbsp;     * @deprecated As of Java 2 platform v1.3, instead set the border on the
<i>1314</i>&nbsp;     * divider.
<i>1315</i>&nbsp;     */
<b class="nc"><i>1316</i>&nbsp;    @Deprecated</b>
<b class="nc"><i>1317</i>&nbsp;    protected int getDividerBorderSize() {</b>
<b class="nc"><i>1318</i>&nbsp;        return 1;</b>
<i>1319</i>&nbsp;    }
<b class="nc"><i>1320</i>&nbsp;</b>
<b class="nc"><i>1321</i>&nbsp;</b>
<b class="nc"><i>1322</i>&nbsp;    /**</b>
<b class="nc"><i>1323</i>&nbsp;     * LayoutManager for JSplitPanes that have an orientation of</b>
<b class="nc"><i>1324</i>&nbsp;     * HORIZONTAL_SPLIT.</b>
<i>1325</i>&nbsp;     */
<b class="nc"><i>1326</i>&nbsp;    public class BasicHorizontalLayoutManager implements LayoutManager2</b>
<b class="nc"><i>1327</i>&nbsp;    {</b>
<i>1328</i>&nbsp;        /* left, right, divider. (in this exact order) */
<b class="nc"><i>1329</i>&nbsp;        /**</b>
<i>1330</i>&nbsp;         * The size of components.
<i>1331</i>&nbsp;         */
<b class="nc"><i>1332</i>&nbsp;        protected int[]         sizes;</b>
<b class="nc"><i>1333</i>&nbsp;        /**</b>
<b class="nc"><i>1334</i>&nbsp;         * The components.</b>
<i>1335</i>&nbsp;         */
<i>1336</i>&nbsp;        protected Component[]   components;
<b class="nc"><i>1337</i>&nbsp;        /** Size of the splitpane the last time laid out. */</b>
<i>1338</i>&nbsp;        private int             lastSplitPaneSize;
<b class="nc"><i>1339</i>&nbsp;        /** True if resetToPreferredSizes has been invoked. */</b>
<b class="nc"><i>1340</i>&nbsp;        private boolean         doReset;</b>
<i>1341</i>&nbsp;        /** Axis, 0 for horizontal, or 1 for veritcal. */
<b class="nc"><i>1342</i>&nbsp;        private int             axis;</b>
<b class="nc"><i>1343</i>&nbsp;</b>
<b class="nc"><i>1344</i>&nbsp;</b>
<i>1345</i>&nbsp;        BasicHorizontalLayoutManager() {
<b class="nc"><i>1346</i>&nbsp;            this(0);</b>
<b class="nc"><i>1347</i>&nbsp;        }</b>
<b class="nc"><i>1348</i>&nbsp;</b>
<i>1349</i>&nbsp;        BasicHorizontalLayoutManager(int axis) {
<i>1350</i>&nbsp;            this.axis = axis;
<b class="nc"><i>1351</i>&nbsp;            components = new Component[3];</b>
<b class="nc"><i>1352</i>&nbsp;            components[0] = components[1] = components[2] = null;</b>
<i>1353</i>&nbsp;            sizes = new int[3];
<b class="nc"><i>1354</i>&nbsp;        }</b>
<b class="nc"><i>1355</i>&nbsp;</b>
<b class="nc"><i>1356</i>&nbsp;        //</b>
<b class="nc"><i>1357</i>&nbsp;        // LayoutManager</b>
<i>1358</i>&nbsp;        //
<b class="nc"><i>1359</i>&nbsp;</b>
<i>1360</i>&nbsp;        /**
<b class="nc"><i>1361</i>&nbsp;         * Does the actual layout.</b>
<i>1362</i>&nbsp;         */
<b class="nc"><i>1363</i>&nbsp;        public void layoutContainer(Container container) {</b>
<b class="nc"><i>1364</i>&nbsp;            Dimension   containerSize = container.getSize();</b>
<i>1365</i>&nbsp;
<b class="nc"><i>1366</i>&nbsp;            // If the splitpane has a zero size then no op out of here.</b>
<b class="nc"><i>1367</i>&nbsp;            // If we execute this function now, we&#39;re going to cause ourselves</b>
<i>1368</i>&nbsp;            // much grief.
<b class="nc"><i>1369</i>&nbsp;            if (containerSize.height &lt;= 0 || containerSize.width &lt;= 0 ) {</b>
<b class="nc"><i>1370</i>&nbsp;                lastSplitPaneSize = 0;</b>
<i>1371</i>&nbsp;                return;
<i>1372</i>&nbsp;            }
<b class="nc"><i>1373</i>&nbsp;</b>
<i>1374</i>&nbsp;            int         spDividerLocation = splitPane.getDividerLocation();
<i>1375</i>&nbsp;            Insets      insets = splitPane.getInsets();
<i>1376</i>&nbsp;            int         availableSize = getAvailableSize(containerSize,
<i>1377</i>&nbsp;                                                         insets);
<b class="nc"><i>1378</i>&nbsp;            int         newSize = getSizeForPrimaryAxis(containerSize);</b>
<i>1379</i>&nbsp;            int         beginLocation = getDividerLocation(splitPane);
<b class="nc"><i>1380</i>&nbsp;            int         dOffset = getSizeForPrimaryAxis(insets, true);</b>
<b class="nc"><i>1381</i>&nbsp;            Dimension   dSize = (components[2] == null) ? null :</b>
<i>1382</i>&nbsp;                                 components[2].getPreferredSize();
<b class="nc"><i>1383</i>&nbsp;</b>
<i>1384</i>&nbsp;            if ((doReset &amp;&amp; !dividerLocationIsSet) || spDividerLocation &lt; 0) {
<b class="nc"><i>1385</i>&nbsp;                resetToPreferredSizes(availableSize);</b>
<i>1386</i>&nbsp;            }
<i>1387</i>&nbsp;            else if (lastSplitPaneSize &lt;= 0 ||
<i>1388</i>&nbsp;                     availableSize == lastSplitPaneSize || !painted ||
<i>1389</i>&nbsp;                     (dSize != null &amp;&amp;
<i>1390</i>&nbsp;                      getSizeForPrimaryAxis(dSize) != sizes[2])) {
<i>1391</i>&nbsp;                if (dSize != null) {
<i>1392</i>&nbsp;                    sizes[2] = getSizeForPrimaryAxis(dSize);
<i>1393</i>&nbsp;                }
<b class="nc"><i>1394</i>&nbsp;                else {</b>
<i>1395</i>&nbsp;                    sizes[2] = 0;
<b class="nc"><i>1396</i>&nbsp;                }</b>
<b class="nc"><i>1397</i>&nbsp;                setDividerLocation(spDividerLocation - dOffset, availableSize);</b>
<i>1398</i>&nbsp;                dividerLocationIsSet = false;
<i>1399</i>&nbsp;            }
<i>1400</i>&nbsp;            else if (availableSize != lastSplitPaneSize) {
<i>1401</i>&nbsp;                distributeSpace(availableSize - lastSplitPaneSize,
<i>1402</i>&nbsp;                                getKeepHidden());
<i>1403</i>&nbsp;            }
<i>1404</i>&nbsp;            doReset = false;
<i>1405</i>&nbsp;            dividerLocationIsSet = false;
<i>1406</i>&nbsp;            lastSplitPaneSize = availableSize;
<i>1407</i>&nbsp;
<i>1408</i>&nbsp;            // Reset the bounds of each component
<b class="nc"><i>1409</i>&nbsp;            int nextLocation = getInitialLocation(insets);</b>
<i>1410</i>&nbsp;            int counter = 0;
<b class="nc"><i>1411</i>&nbsp;</b>
<b class="nc"><i>1412</i>&nbsp;            while (counter &lt; 3) {</b>
<i>1413</i>&nbsp;                if (components[counter] != null &amp;&amp;
<b class="nc"><i>1414</i>&nbsp;                    components[counter].isVisible()) {</b>
<b class="nc"><i>1415</i>&nbsp;                    setComponentToSize(components[counter], sizes[counter],</b>
<b class="nc"><i>1416</i>&nbsp;                                       nextLocation, insets, containerSize);</b>
<b class="nc"><i>1417</i>&nbsp;                    nextLocation += sizes[counter];</b>
<b class="nc"><i>1418</i>&nbsp;                }</b>
<b class="nc"><i>1419</i>&nbsp;                switch (counter) {</b>
<b class="nc"><i>1420</i>&nbsp;                case 0:</b>
<b class="nc"><i>1421</i>&nbsp;                    counter = 2;</b>
<b class="nc"><i>1422</i>&nbsp;                    break;</b>
<b class="nc"><i>1423</i>&nbsp;                case 2:</b>
<b class="nc"><i>1424</i>&nbsp;                    counter = 1;</b>
<b class="nc"><i>1425</i>&nbsp;                    break;</b>
<i>1426</i>&nbsp;                case 1:
<b class="nc"><i>1427</i>&nbsp;                    counter = 3;</b>
<i>1428</i>&nbsp;                    break;
<b class="nc"><i>1429</i>&nbsp;                }</b>
<i>1430</i>&nbsp;            }
<b class="nc"><i>1431</i>&nbsp;            if (painted) {</b>
<b class="nc"><i>1432</i>&nbsp;                // This is tricky, there is never a good time for us</b>
<i>1433</i>&nbsp;                // to push the value to the splitpane, painted appears to
<i>1434</i>&nbsp;                // the best time to do it. What is really needed is
<b class="nc"><i>1435</i>&nbsp;                // notification that layout has completed.</b>
<i>1436</i>&nbsp;                int      newLocation = getDividerLocation(splitPane);
<i>1437</i>&nbsp;
<i>1438</i>&nbsp;                if (newLocation != (spDividerLocation - dOffset)) {
<i>1439</i>&nbsp;                    int  lastLocation = splitPane.getLastDividerLocation();
<i>1440</i>&nbsp;
<i>1441</i>&nbsp;                    ignoreDividerLocationChange = true;
<i>1442</i>&nbsp;                    try {
<i>1443</i>&nbsp;                        splitPane.setDividerLocation(newLocation);
<i>1444</i>&nbsp;                        // This is not always needed, but is rather tricky
<b class="nc"><i>1445</i>&nbsp;                        // to determine when... The case this is needed for</b>
<b class="nc"><i>1446</i>&nbsp;                        // is if the user sets the divider location to some</b>
<b class="nc"><i>1447</i>&nbsp;                        // bogus value, say 0, and the actual value is 1, the</b>
<i>1448</i>&nbsp;                        // call to setDividerLocation(1) will preserve the
<b class="nc"><i>1449</i>&nbsp;                        // old value of 0, when we really want the divider</b>
<b class="nc"><i>1450</i>&nbsp;                        // location value  before the call. This is needed for</b>
<b class="nc"><i>1451</i>&nbsp;                        // the one touch buttons.</b>
<b class="nc"><i>1452</i>&nbsp;                        splitPane.setLastDividerLocation(lastLocation);</b>
<i>1453</i>&nbsp;                    } finally {
<b class="nc"><i>1454</i>&nbsp;                        ignoreDividerLocationChange = false;</b>
<b class="nc"><i>1455</i>&nbsp;                    }</b>
<b class="nc"><i>1456</i>&nbsp;                }</b>
<i>1457</i>&nbsp;            }
<i>1458</i>&nbsp;        }
<b class="nc"><i>1459</i>&nbsp;</b>
<b class="nc"><i>1460</i>&nbsp;</b>
<b class="nc"><i>1461</i>&nbsp;        /**</b>
<b class="nc"><i>1462</i>&nbsp;         * Adds the component at place.  Place must be one of</b>
<b class="nc"><i>1463</i>&nbsp;         * JSplitPane.LEFT, RIGHT, TOP, BOTTOM, or null (for the</b>
<i>1464</i>&nbsp;         * divider).
<b class="nc"><i>1465</i>&nbsp;         */</b>
<b class="nc"><i>1466</i>&nbsp;        public void addLayoutComponent(String place, Component component) {</b>
<i>1467</i>&nbsp;            boolean isValid = true;
<b class="nc"><i>1468</i>&nbsp;</b>
<i>1469</i>&nbsp;            if(place != null) {
<i>1470</i>&nbsp;                if(place.equals(JSplitPane.DIVIDER)) {
<i>1471</i>&nbsp;                    /* Divider. */
<i>1472</i>&nbsp;                    components[2] = component;
<i>1473</i>&nbsp;                    sizes[2] = getSizeForPrimaryAxis(component.
<i>1474</i>&nbsp;                                                     getPreferredSize());
<i>1475</i>&nbsp;                } else if(place.equals(JSplitPane.LEFT) ||
<i>1476</i>&nbsp;                          place.equals(JSplitPane.TOP)) {
<i>1477</i>&nbsp;                    components[0] = component;
<b class="nc"><i>1478</i>&nbsp;                    sizes[0] = 0;</b>
<b class="nc"><i>1479</i>&nbsp;                } else if(place.equals(JSplitPane.RIGHT) ||</b>
<b class="nc"><i>1480</i>&nbsp;                          place.equals(JSplitPane.BOTTOM)) {</b>
<i>1481</i>&nbsp;                    components[1] = component;
<b class="nc"><i>1482</i>&nbsp;                    sizes[1] = 0;</b>
<b class="nc"><i>1483</i>&nbsp;                } else if(!place.equals(</b>
<b class="nc"><i>1484</i>&nbsp;                                    BasicSplitPaneUI.NON_CONTINUOUS_DIVIDER))</b>
<b class="nc"><i>1485</i>&nbsp;                    isValid = false;</b>
<b class="nc"><i>1486</i>&nbsp;            } else {</b>
<i>1487</i>&nbsp;                isValid = false;
<b class="nc"><i>1488</i>&nbsp;            }</b>
<b class="nc"><i>1489</i>&nbsp;            if(!isValid)</b>
<b class="nc"><i>1490</i>&nbsp;                throw new IllegalArgumentException(&quot;cannot add to layout: &quot; +</b>
<i>1491</i>&nbsp;                    &quot;unknown constraint: &quot; +
<i>1492</i>&nbsp;                    place);
<b class="nc"><i>1493</i>&nbsp;            doReset = true;</b>
<b class="nc"><i>1494</i>&nbsp;        }</b>
<b class="nc"><i>1495</i>&nbsp;</b>
<b class="nc"><i>1496</i>&nbsp;</b>
<b class="nc"><i>1497</i>&nbsp;        /**</b>
<i>1498</i>&nbsp;         * Returns the minimum size needed to contain the children.
<b class="nc"><i>1499</i>&nbsp;         * The width is the sum of all the children&#39;s min widths and</b>
<b class="nc"><i>1500</i>&nbsp;         * the height is the largest of the children&#39;s minimum heights.</b>
<i>1501</i>&nbsp;         */
<b class="nc"><i>1502</i>&nbsp;        public Dimension minimumLayoutSize(Container container) {</b>
<i>1503</i>&nbsp;            int         minPrimary = 0;
<i>1504</i>&nbsp;            int         minSecondary = 0;
<i>1505</i>&nbsp;            Insets      insets = splitPane.getInsets();
<i>1506</i>&nbsp;
<i>1507</i>&nbsp;            for (int counter=0; counter&lt;3; counter++) {
<i>1508</i>&nbsp;                if(components[counter] != null) {
<i>1509</i>&nbsp;                    Dimension   minSize = components[counter].getMinimumSize();
<b class="nc"><i>1510</i>&nbsp;                    int         secSize = getSizeForSecondaryAxis(minSize);</b>
<b class="nc"><i>1511</i>&nbsp;</b>
<b class="nc"><i>1512</i>&nbsp;                    minPrimary += getSizeForPrimaryAxis(minSize);</b>
<b class="nc"><i>1513</i>&nbsp;                    if(secSize &gt; minSecondary)</b>
<b class="nc"><i>1514</i>&nbsp;                        minSecondary = secSize;</b>
<i>1515</i>&nbsp;                }
<i>1516</i>&nbsp;            }
<i>1517</i>&nbsp;            if(insets != null) {
<i>1518</i>&nbsp;                minPrimary += getSizeForPrimaryAxis(insets, true) +
<i>1519</i>&nbsp;                              getSizeForPrimaryAxis(insets, false);
<i>1520</i>&nbsp;                minSecondary += getSizeForSecondaryAxis(insets, true) +
<i>1521</i>&nbsp;                              getSizeForSecondaryAxis(insets, false);
<i>1522</i>&nbsp;            }
<i>1523</i>&nbsp;            if (axis == 0) {
<i>1524</i>&nbsp;                return new Dimension(minPrimary, minSecondary);
<i>1525</i>&nbsp;            }
<i>1526</i>&nbsp;            return new Dimension(minSecondary, minPrimary);
<i>1527</i>&nbsp;        }
<i>1528</i>&nbsp;
<i>1529</i>&nbsp;
<i>1530</i>&nbsp;        /**
<i>1531</i>&nbsp;         * Returns the preferred size needed to contain the children.
<b class="nc"><i>1532</i>&nbsp;         * The width is the sum of all the preferred widths of the children and</b>
<b class="nc"><i>1533</i>&nbsp;         * the height is the largest preferred height of the children.</b>
<i>1534</i>&nbsp;         */
<b class="nc"><i>1535</i>&nbsp;        public Dimension preferredLayoutSize(Container container) {</b>
<i>1536</i>&nbsp;            int         prePrimary = 0;
<i>1537</i>&nbsp;            int         preSecondary = 0;
<i>1538</i>&nbsp;            Insets      insets = splitPane.getInsets();
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;            for(int counter = 0; counter &lt; 3; counter++) {
<i>1541</i>&nbsp;                if(components[counter] != null) {
<i>1542</i>&nbsp;                    Dimension   preSize = components[counter].
<i>1543</i>&nbsp;                                          getPreferredSize();
<i>1544</i>&nbsp;                    int         secSize = getSizeForSecondaryAxis(preSize);
<i>1545</i>&nbsp;
<i>1546</i>&nbsp;                    prePrimary += getSizeForPrimaryAxis(preSize);
<i>1547</i>&nbsp;                    if(secSize &gt; preSecondary)
<i>1548</i>&nbsp;                        preSecondary = secSize;
<i>1549</i>&nbsp;                }
<b class="nc"><i>1550</i>&nbsp;            }</b>
<i>1551</i>&nbsp;            if(insets != null) {
<i>1552</i>&nbsp;                prePrimary += getSizeForPrimaryAxis(insets, true) +
<i>1553</i>&nbsp;                              getSizeForPrimaryAxis(insets, false);
<i>1554</i>&nbsp;                preSecondary += getSizeForSecondaryAxis(insets, true) +
<i>1555</i>&nbsp;                              getSizeForSecondaryAxis(insets, false);
<i>1556</i>&nbsp;            }
<i>1557</i>&nbsp;            if (axis == 0) {
<i>1558</i>&nbsp;                return new Dimension(prePrimary, preSecondary);
<i>1559</i>&nbsp;            }
<i>1560</i>&nbsp;            return new Dimension(preSecondary, prePrimary);
<i>1561</i>&nbsp;        }
<b class="nc"><i>1562</i>&nbsp;</b>
<i>1563</i>&nbsp;
<i>1564</i>&nbsp;        /**
<i>1565</i>&nbsp;         * Removes the specified component from our knowledge.
<i>1566</i>&nbsp;         */
<i>1567</i>&nbsp;        public void removeLayoutComponent(Component component) {
<i>1568</i>&nbsp;            for(int counter = 0; counter &lt; 3; counter++) {
<i>1569</i>&nbsp;                if(components[counter] == component) {
<i>1570</i>&nbsp;                    components[counter] = null;
<i>1571</i>&nbsp;                    sizes[counter] = 0;
<i>1572</i>&nbsp;                    doReset = true;
<i>1573</i>&nbsp;                }
<i>1574</i>&nbsp;            }
<i>1575</i>&nbsp;        }
<i>1576</i>&nbsp;
<i>1577</i>&nbsp;
<i>1578</i>&nbsp;        //
<i>1579</i>&nbsp;        // LayoutManager2
<b class="nc"><i>1580</i>&nbsp;        //</b>
<i>1581</i>&nbsp;
<i>1582</i>&nbsp;
<i>1583</i>&nbsp;        /**
<i>1584</i>&nbsp;         * Adds the specified component to the layout, using the specified
<i>1585</i>&nbsp;         * constraint object.
<i>1586</i>&nbsp;         * @param comp the component to be added
<i>1587</i>&nbsp;         * @param constraints  where/how the component is added to the layout.
<i>1588</i>&nbsp;         */
<i>1589</i>&nbsp;        public void addLayoutComponent(Component comp, Object constraints) {
<i>1590</i>&nbsp;            if ((constraints == null) || (constraints instanceof String)) {
<i>1591</i>&nbsp;                addLayoutComponent((String)constraints, comp);
<i>1592</i>&nbsp;            } else {
<b class="nc"><i>1593</i>&nbsp;                throw new IllegalArgumentException(&quot;cannot add to layout: &quot; +</b>
<i>1594</i>&nbsp;                                                   &quot;constraint must be a &quot; +
<i>1595</i>&nbsp;                                                   &quot;string (or null)&quot;);
<i>1596</i>&nbsp;            }
<i>1597</i>&nbsp;        }
<i>1598</i>&nbsp;
<i>1599</i>&nbsp;
<b class="nc"><i>1600</i>&nbsp;        /**</b>
<b class="nc"><i>1601</i>&nbsp;         * Returns the alignment along the x axis.  This specifies how</b>
<i>1602</i>&nbsp;         * the component would like to be aligned relative to other
<i>1603</i>&nbsp;         * components.  The value should be a number between 0 and 1
<i>1604</i>&nbsp;         * where 0 represents alignment along the origin, 1 is aligned
<i>1605</i>&nbsp;         * the furthest away from the origin, 0.5 is centered, etc.
<i>1606</i>&nbsp;         */
<i>1607</i>&nbsp;        public float getLayoutAlignmentX(Container target) {
<i>1608</i>&nbsp;            return 0.0f;
<b class="nc"><i>1609</i>&nbsp;        }</b>
<i>1610</i>&nbsp;
<i>1611</i>&nbsp;
<i>1612</i>&nbsp;        /**
<i>1613</i>&nbsp;         * Returns the alignment along the y axis.  This specifies how
<i>1614</i>&nbsp;         * the component would like to be aligned relative to other
<i>1615</i>&nbsp;         * components.  The value should be a number between 0 and 1
<i>1616</i>&nbsp;         * where 0 represents alignment along the origin, 1 is aligned
<b class="nc"><i>1617</i>&nbsp;         * the furthest away from the origin, 0.5 is centered, etc.</b>
<i>1618</i>&nbsp;         */
<b class="nc"><i>1619</i>&nbsp;        public float getLayoutAlignmentY(Container target) {</b>
<b class="nc"><i>1620</i>&nbsp;            return 0.0f;</b>
<i>1621</i>&nbsp;        }
<i>1622</i>&nbsp;
<i>1623</i>&nbsp;
<i>1624</i>&nbsp;        /**
<i>1625</i>&nbsp;         * Does nothing. If the developer really wants to change the
<i>1626</i>&nbsp;         * size of one of the views JSplitPane.resetToPreferredSizes should
<i>1627</i>&nbsp;         * be messaged.
<b class="nc"><i>1628</i>&nbsp;         */</b>
<i>1629</i>&nbsp;        public void invalidateLayout(Container c) {
<i>1630</i>&nbsp;        }
<i>1631</i>&nbsp;
<i>1632</i>&nbsp;
<i>1633</i>&nbsp;        /**
<i>1634</i>&nbsp;         * Returns the maximum layout size, which is Integer.MAX_VALUE
<i>1635</i>&nbsp;         * in both directions.
<b class="nc"><i>1636</i>&nbsp;         */</b>
<i>1637</i>&nbsp;        public Dimension maximumLayoutSize(Container target) {
<i>1638</i>&nbsp;            return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);
<i>1639</i>&nbsp;        }
<i>1640</i>&nbsp;
<i>1641</i>&nbsp;
<i>1642</i>&nbsp;        //
<i>1643</i>&nbsp;        // New methods.
<b class="nc"><i>1644</i>&nbsp;        //</b>
<i>1645</i>&nbsp;
<i>1646</i>&nbsp;        /**
<i>1647</i>&nbsp;         * Marks the receiver so that the next time this instance is
<i>1648</i>&nbsp;         * laid out it&#39;ll ask for the preferred sizes.
<i>1649</i>&nbsp;         */
<i>1650</i>&nbsp;        public void resetToPreferredSizes() {
<i>1651</i>&nbsp;            doReset = true;
<i>1652</i>&nbsp;        }
<i>1653</i>&nbsp;
<b class="nc"><i>1654</i>&nbsp;        /**</b>
<b class="nc"><i>1655</i>&nbsp;         * Resets the size of the Component at the passed in location.</b>
<b class="nc"><i>1656</i>&nbsp;         *</b>
<b class="nc"><i>1657</i>&nbsp;         * @param index the index of a component</b>
<b class="nc"><i>1658</i>&nbsp;         */</b>
<i>1659</i>&nbsp;        protected void resetSizeAt(int index) {
<i>1660</i>&nbsp;            sizes[index] = 0;
<i>1661</i>&nbsp;            doReset = true;
<i>1662</i>&nbsp;        }
<i>1663</i>&nbsp;
<i>1664</i>&nbsp;
<i>1665</i>&nbsp;        /**
<i>1666</i>&nbsp;         * Sets the sizes to {@code newSizes}.
<b class="nc"><i>1667</i>&nbsp;         *</b>
<b class="nc"><i>1668</i>&nbsp;         * @param newSizes the new sizes</b>
<b class="nc"><i>1669</i>&nbsp;         */</b>
<i>1670</i>&nbsp;        protected void setSizes(int[] newSizes) {
<i>1671</i>&nbsp;            System.arraycopy(newSizes, 0, sizes, 0, 3);
<i>1672</i>&nbsp;        }
<i>1673</i>&nbsp;
<i>1674</i>&nbsp;
<i>1675</i>&nbsp;        /**
<i>1676</i>&nbsp;         * Returns the sizes of the components.
<i>1677</i>&nbsp;         *
<i>1678</i>&nbsp;         * @return the sizes of the components
<i>1679</i>&nbsp;         */
<i>1680</i>&nbsp;        protected int[] getSizes() {
<b class="nc"><i>1681</i>&nbsp;            int[]         retSizes = new int[3];</b>
<b class="nc"><i>1682</i>&nbsp;</b>
<b class="nc"><i>1683</i>&nbsp;            System.arraycopy(sizes, 0, retSizes, 0, 3);</b>
<i>1684</i>&nbsp;            return retSizes;
<i>1685</i>&nbsp;        }
<i>1686</i>&nbsp;
<i>1687</i>&nbsp;
<b class="nc"><i>1688</i>&nbsp;        /**</b>
<i>1689</i>&nbsp;         * Returns the width of the passed in Components preferred size.
<i>1690</i>&nbsp;         *
<i>1691</i>&nbsp;         * @param c a component
<i>1692</i>&nbsp;         * @return the preferred width of the component
<b class="nc"><i>1693</i>&nbsp;         */</b>
<b class="nc"><i>1694</i>&nbsp;        protected int getPreferredSizeOfComponent(Component c) {</b>
<i>1695</i>&nbsp;            return getSizeForPrimaryAxis(c.getPreferredSize());
<i>1696</i>&nbsp;        }
<b class="nc"><i>1697</i>&nbsp;</b>
<i>1698</i>&nbsp;
<i>1699</i>&nbsp;        /**
<i>1700</i>&nbsp;         * Returns the width of the passed in Components minimum size.
<i>1701</i>&nbsp;         *
<i>1702</i>&nbsp;         * @param c a component
<i>1703</i>&nbsp;         * @return the minimum width of the component
<i>1704</i>&nbsp;         */
<i>1705</i>&nbsp;        int getMinimumSizeOfComponent(Component c) {
<b class="nc"><i>1706</i>&nbsp;            return getSizeForPrimaryAxis(c.getMinimumSize());</b>
<b class="nc"><i>1707</i>&nbsp;        }</b>
<i>1708</i>&nbsp;
<b class="nc"><i>1709</i>&nbsp;</b>
<i>1710</i>&nbsp;        /**
<i>1711</i>&nbsp;         * Returns the width of the passed in component.
<i>1712</i>&nbsp;         *
<i>1713</i>&nbsp;         * @param c a component
<i>1714</i>&nbsp;         * @return the width of the component
<i>1715</i>&nbsp;         */
<b class="nc"><i>1716</i>&nbsp;        protected int getSizeOfComponent(Component c) {</b>
<b class="nc"><i>1717</i>&nbsp;            return getSizeForPrimaryAxis(c.getSize());</b>
<i>1718</i>&nbsp;        }
<b class="nc"><i>1719</i>&nbsp;</b>
<i>1720</i>&nbsp;
<i>1721</i>&nbsp;        /**
<i>1722</i>&nbsp;         * Returns the available width based on the container size and
<i>1723</i>&nbsp;         * {@code Insets}.
<i>1724</i>&nbsp;         *
<i>1725</i>&nbsp;         * @param containerSize a container size
<i>1726</i>&nbsp;         * @param insets an insets
<i>1727</i>&nbsp;         * @return the available width
<i>1728</i>&nbsp;         */
<i>1729</i>&nbsp;        protected int getAvailableSize(Dimension containerSize,
<i>1730</i>&nbsp;                                       Insets insets) {
<i>1731</i>&nbsp;            if(insets == null)
<b class="nc"><i>1732</i>&nbsp;                return getSizeForPrimaryAxis(containerSize);</b>
<b class="nc"><i>1733</i>&nbsp;            return (getSizeForPrimaryAxis(containerSize) -</b>
<b class="nc"><i>1734</i>&nbsp;                    (getSizeForPrimaryAxis(insets, true) +</b>
<i>1735</i>&nbsp;                     getSizeForPrimaryAxis(insets, false)));
<b class="nc"><i>1736</i>&nbsp;        }</b>
<i>1737</i>&nbsp;
<b class="nc"><i>1738</i>&nbsp;</b>
<b class="nc"><i>1739</i>&nbsp;        /**</b>
<i>1740</i>&nbsp;         * Returns the left inset, unless the {@code Insets} are null in which case
<b class="nc"><i>1741</i>&nbsp;         * 0 is returned.</b>
<i>1742</i>&nbsp;         *
<i>1743</i>&nbsp;         * @param insets the insets
<i>1744</i>&nbsp;         * @return the left inset
<i>1745</i>&nbsp;         */
<i>1746</i>&nbsp;        protected int getInitialLocation(Insets insets) {
<i>1747</i>&nbsp;            if(insets != null)
<i>1748</i>&nbsp;                return getSizeForPrimaryAxis(insets, true);
<i>1749</i>&nbsp;            return 0;
<i>1750</i>&nbsp;        }
<i>1751</i>&nbsp;
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;        /**
<b class="nc"><i>1754</i>&nbsp;         * Sets the width of the component {@code c} to be {@code size}, placing its</b>
<b class="nc"><i>1755</i>&nbsp;         * x location at {@code location}, y to the {@code insets.top} and height</b>
<b class="nc"><i>1756</i>&nbsp;         * to the {@code containerSize.height} less the top and bottom insets.</b>
<i>1757</i>&nbsp;         *
<b class="nc"><i>1758</i>&nbsp;         * @param c a component</b>
<i>1759</i>&nbsp;         * @param size a new width
<b class="nc"><i>1760</i>&nbsp;         * @param location a new X coordinate</b>
<b class="nc"><i>1761</i>&nbsp;         * @param insets an insets</b>
<i>1762</i>&nbsp;         * @param containerSize a container size
<b class="nc"><i>1763</i>&nbsp;         */</b>
<i>1764</i>&nbsp;        protected void setComponentToSize(Component c, int size,
<i>1765</i>&nbsp;                                          int location, Insets insets,
<i>1766</i>&nbsp;                                          Dimension containerSize) {
<i>1767</i>&nbsp;            if(insets != null) {
<i>1768</i>&nbsp;                if (axis == 0) {
<i>1769</i>&nbsp;                    c.setBounds(location, insets.top, size,
<i>1770</i>&nbsp;                                containerSize.height -
<i>1771</i>&nbsp;                                (insets.top + insets.bottom));
<i>1772</i>&nbsp;                }
<i>1773</i>&nbsp;                else {
<b class="nc"><i>1774</i>&nbsp;                    c.setBounds(insets.left, location, containerSize.width -</b>
<b class="nc"><i>1775</i>&nbsp;                                (insets.left + insets.right), size);</b>
<b class="nc"><i>1776</i>&nbsp;                }</b>
<b class="nc"><i>1777</i>&nbsp;            }</b>
<b class="nc"><i>1778</i>&nbsp;            else {</b>
<i>1779</i>&nbsp;                if (axis == 0) {
<b class="nc"><i>1780</i>&nbsp;                    c.setBounds(location, 0, size, containerSize.height);</b>
<i>1781</i>&nbsp;                }
<i>1782</i>&nbsp;                else {
<i>1783</i>&nbsp;                    c.setBounds(0, location, containerSize.width, size);
<b class="nc"><i>1784</i>&nbsp;                }</b>
<b class="nc"><i>1785</i>&nbsp;            }</b>
<b class="nc"><i>1786</i>&nbsp;        }</b>
<b class="nc"><i>1787</i>&nbsp;</b>
<b class="nc"><i>1788</i>&nbsp;        /**</b>
<i>1789</i>&nbsp;         * If the axis == 0, the width is returned, otherwise the height.
<b class="nc"><i>1790</i>&nbsp;         */</b>
<i>1791</i>&nbsp;        int getSizeForPrimaryAxis(Dimension size) {
<i>1792</i>&nbsp;            if (axis == 0) {
<i>1793</i>&nbsp;                return size.width;
<i>1794</i>&nbsp;            }
<b class="nc"><i>1795</i>&nbsp;            return size.height;</b>
<b class="nc"><i>1796</i>&nbsp;        }</b>
<i>1797</i>&nbsp;
<b class="nc"><i>1798</i>&nbsp;        /**</b>
<b class="nc"><i>1799</i>&nbsp;         * If the axis == 0, the width is returned, otherwise the height.</b>
<b class="nc"><i>1800</i>&nbsp;         */</b>
<i>1801</i>&nbsp;        int getSizeForSecondaryAxis(Dimension size) {
<i>1802</i>&nbsp;            if (axis == 0) {
<b class="nc"><i>1803</i>&nbsp;                return size.height;</b>
<b class="nc"><i>1804</i>&nbsp;            }</b>
<i>1805</i>&nbsp;            return size.width;
<b class="nc"><i>1806</i>&nbsp;        }</b>
<i>1807</i>&nbsp;
<b class="nc"><i>1808</i>&nbsp;        /**</b>
<i>1809</i>&nbsp;         * Returns a particular value of the inset identified by the
<i>1810</i>&nbsp;         * axis and &lt;code&gt;isTop&lt;/code&gt;&lt;p&gt;
<b class="nc"><i>1811</i>&nbsp;         *   axis isTop</b>
<b class="nc"><i>1812</i>&nbsp;         *    0    true    - left</b>
<i>1813</i>&nbsp;         *    0    false   - right
<i>1814</i>&nbsp;         *    1    true    - top
<b class="nc"><i>1815</i>&nbsp;         *    1    false   - bottom</b>
<i>1816</i>&nbsp;         */
<i>1817</i>&nbsp;        int getSizeForPrimaryAxis(Insets insets, boolean isTop) {
<i>1818</i>&nbsp;            if (axis == 0) {
<i>1819</i>&nbsp;                if (isTop) {
<i>1820</i>&nbsp;                    return insets.left;
<i>1821</i>&nbsp;                }
<i>1822</i>&nbsp;                return insets.right;
<i>1823</i>&nbsp;            }
<b class="nc"><i>1824</i>&nbsp;            if (isTop) {</b>
<b class="nc"><i>1825</i>&nbsp;                return insets.top;</b>
<b class="nc"><i>1826</i>&nbsp;            }</b>
<b class="nc"><i>1827</i>&nbsp;            return insets.bottom;</b>
<b class="nc"><i>1828</i>&nbsp;        }</b>
<b class="nc"><i>1829</i>&nbsp;</b>
<b class="nc"><i>1830</i>&nbsp;        /**</b>
<i>1831</i>&nbsp;         * Returns a particular value of the inset identified by the
<b class="nc"><i>1832</i>&nbsp;         * axis and &lt;code&gt;isTop&lt;/code&gt;&lt;p&gt;</b>
<b class="nc"><i>1833</i>&nbsp;         *   axis isTop</b>
<i>1834</i>&nbsp;         *    0    true    - left
<b class="nc"><i>1835</i>&nbsp;         *    0    false   - right</b>
<b class="nc"><i>1836</i>&nbsp;         *    1    true    - top</b>
<b class="nc"><i>1837</i>&nbsp;         *    1    false   - bottom</b>
<b class="nc"><i>1838</i>&nbsp;         */</b>
<b class="nc"><i>1839</i>&nbsp;        int getSizeForSecondaryAxis(Insets insets, boolean isTop) {</b>
<i>1840</i>&nbsp;            if (axis == 0) {
<i>1841</i>&nbsp;                if (isTop) {
<b class="nc"><i>1842</i>&nbsp;                    return insets.top;</b>
<b class="nc"><i>1843</i>&nbsp;                }</b>
<i>1844</i>&nbsp;                return insets.bottom;
<i>1845</i>&nbsp;            }
<b class="nc"><i>1846</i>&nbsp;            if (isTop) {</b>
<b class="nc"><i>1847</i>&nbsp;                return insets.left;</b>
<b class="nc"><i>1848</i>&nbsp;            }</b>
<i>1849</i>&nbsp;            return insets.right;
<i>1850</i>&nbsp;        }
<i>1851</i>&nbsp;
<i>1852</i>&nbsp;        /**
<i>1853</i>&nbsp;         * Determines the components. This should be called whenever
<i>1854</i>&nbsp;         * a new instance of this is installed into an existing
<i>1855</i>&nbsp;         * SplitPane.
<b class="nc"><i>1856</i>&nbsp;         */</b>
<i>1857</i>&nbsp;        protected void updateComponents() {
<b class="nc"><i>1858</i>&nbsp;            Component comp;</b>
<b class="nc"><i>1859</i>&nbsp;</b>
<b class="nc"><i>1860</i>&nbsp;            comp = splitPane.getLeftComponent();</b>
<b class="nc"><i>1861</i>&nbsp;            if(components[0] != comp) {</b>
<b class="nc"><i>1862</i>&nbsp;                components[0] = comp;</b>
<i>1863</i>&nbsp;                if(comp == null) {
<i>1864</i>&nbsp;                    sizes[0] = 0;
<b class="nc"><i>1865</i>&nbsp;                } else {</b>
<i>1866</i>&nbsp;                    sizes[0] = -1;
<i>1867</i>&nbsp;                }
<b class="nc"><i>1868</i>&nbsp;            }</b>
<i>1869</i>&nbsp;
<i>1870</i>&nbsp;            comp = splitPane.getRightComponent();
<i>1871</i>&nbsp;            if(components[1] != comp) {
<i>1872</i>&nbsp;                components[1] = comp;
<i>1873</i>&nbsp;                if(comp == null) {
<i>1874</i>&nbsp;                    sizes[1] = 0;
<b class="nc"><i>1875</i>&nbsp;                } else {</b>
<i>1876</i>&nbsp;                    sizes[1] = -1;
<b class="nc"><i>1877</i>&nbsp;                }</b>
<b class="nc"><i>1878</i>&nbsp;            }</b>
<b class="nc"><i>1879</i>&nbsp;</b>
<b class="nc"><i>1880</i>&nbsp;            /* Find the divider. */</b>
<b class="nc"><i>1881</i>&nbsp;            Component[] children = splitPane.getComponents();</b>
<i>1882</i>&nbsp;            Component   oldDivider = components[2];
<i>1883</i>&nbsp;
<b class="nc"><i>1884</i>&nbsp;            components[2] = null;</b>
<i>1885</i>&nbsp;            for(int counter = children.length - 1; counter &gt;= 0; counter--) {
<i>1886</i>&nbsp;                if(children[counter] != components[0] &amp;&amp;
<b class="nc"><i>1887</i>&nbsp;                   children[counter] != components[1] &amp;&amp;</b>
<b class="nc"><i>1888</i>&nbsp;                   children[counter] != nonContinuousLayoutDivider) {</b>
<b class="nc"><i>1889</i>&nbsp;                    if(oldDivider != children[counter]) {</b>
<i>1890</i>&nbsp;                        components[2] = children[counter];
<i>1891</i>&nbsp;                    } else {
<i>1892</i>&nbsp;                        components[2] = oldDivider;
<i>1893</i>&nbsp;                    }
<i>1894</i>&nbsp;                    break;
<i>1895</i>&nbsp;                }
<i>1896</i>&nbsp;            }
<i>1897</i>&nbsp;            if(components[2] == null) {
<b class="nc"><i>1898</i>&nbsp;                sizes[2] = 0;</b>
<b class="nc"><i>1899</i>&nbsp;            }</b>
<i>1900</i>&nbsp;            else {
<b class="nc"><i>1901</i>&nbsp;                sizes[2] = getSizeForPrimaryAxis(components[2].getPreferredSize());</b>
<b class="nc"><i>1902</i>&nbsp;            }</b>
<b class="nc"><i>1903</i>&nbsp;        }</b>
<i>1904</i>&nbsp;
<i>1905</i>&nbsp;        /**
<b class="nc"><i>1906</i>&nbsp;         * Resets the size of the first component to &lt;code&gt;leftSize&lt;/code&gt;,</b>
<b class="nc"><i>1907</i>&nbsp;         * and the right component to the remainder of the space.</b>
<i>1908</i>&nbsp;         */
<b class="nc"><i>1909</i>&nbsp;        void setDividerLocation(int leftSize, int availableSize) {</b>
<b class="nc"><i>1910</i>&nbsp;            boolean          lValid = (components[0] != null &amp;&amp;</b>
<b class="nc"><i>1911</i>&nbsp;                                       components[0].isVisible());</b>
<b class="nc"><i>1912</i>&nbsp;            boolean          rValid = (components[1] != null &amp;&amp;</b>
<i>1913</i>&nbsp;                                       components[1].isVisible());
<i>1914</i>&nbsp;            boolean          dValid = (components[2] != null &amp;&amp;
<i>1915</i>&nbsp;                                       components[2].isVisible());
<b class="nc"><i>1916</i>&nbsp;            int              max = availableSize;</b>
<b class="nc"><i>1917</i>&nbsp;</b>
<i>1918</i>&nbsp;            if (dValid) {
<i>1919</i>&nbsp;                max -= sizes[2];
<i>1920</i>&nbsp;            }
<i>1921</i>&nbsp;            leftSize = Math.max(0, Math.min(leftSize, max));
<i>1922</i>&nbsp;            if (lValid) {
<i>1923</i>&nbsp;                if (rValid) {
<i>1924</i>&nbsp;                    sizes[0] = leftSize;
<i>1925</i>&nbsp;                    sizes[1] = max - leftSize;
<i>1926</i>&nbsp;                }
<i>1927</i>&nbsp;                else {
<i>1928</i>&nbsp;                    sizes[0] = max;
<b class="nc"><i>1929</i>&nbsp;                    sizes[1] = 0;</b>
<b class="nc"><i>1930</i>&nbsp;                }</b>
<b class="nc"><i>1931</i>&nbsp;            }</b>
<b class="nc"><i>1932</i>&nbsp;            else if (rValid) {</b>
<i>1933</i>&nbsp;                sizes[1] = max;
<b class="nc"><i>1934</i>&nbsp;                sizes[0] = 0;</b>
<b class="nc"><i>1935</i>&nbsp;            }</b>
<b class="nc"><i>1936</i>&nbsp;        }</b>
<b class="nc"><i>1937</i>&nbsp;</b>
<b class="nc"><i>1938</i>&nbsp;        /**</b>
<b class="nc"><i>1939</i>&nbsp;         * Returns an array of the minimum sizes of the components.</b>
<i>1940</i>&nbsp;         */
<b class="nc"><i>1941</i>&nbsp;        int[] getPreferredSizes() {</b>
<i>1942</i>&nbsp;            int[]         retValue = new int[3];
<i>1943</i>&nbsp;
<b class="nc"><i>1944</i>&nbsp;            for (int counter = 0; counter &lt; 3; counter++) {</b>
<b class="nc"><i>1945</i>&nbsp;                if (components[counter] != null &amp;&amp;</b>
<b class="nc"><i>1946</i>&nbsp;                    components[counter].isVisible()) {</b>
<i>1947</i>&nbsp;                    retValue[counter] = getPreferredSizeOfComponent
<i>1948</i>&nbsp;                                        (components[counter]);
<b class="nc"><i>1949</i>&nbsp;                }</b>
<b class="nc"><i>1950</i>&nbsp;                else {</b>
<b class="nc"><i>1951</i>&nbsp;                    retValue[counter] = -1;</b>
<b class="nc"><i>1952</i>&nbsp;                }</b>
<i>1953</i>&nbsp;            }
<b class="nc"><i>1954</i>&nbsp;            return retValue;</b>
<b class="nc"><i>1955</i>&nbsp;        }</b>
<i>1956</i>&nbsp;
<b class="nc"><i>1957</i>&nbsp;        /**</b>
<b class="nc"><i>1958</i>&nbsp;         * Returns an array of the minimum sizes of the components.</b>
<b class="nc"><i>1959</i>&nbsp;         */</b>
<b class="nc"><i>1960</i>&nbsp;        int[] getMinimumSizes() {</b>
<i>1961</i>&nbsp;            int[]         retValue = new int[3];
<b class="nc"><i>1962</i>&nbsp;</b>
<b class="nc"><i>1963</i>&nbsp;            for (int counter = 0; counter &lt; 2; counter++) {</b>
<b class="nc"><i>1964</i>&nbsp;                if (components[counter] != null &amp;&amp;</b>
<b class="nc"><i>1965</i>&nbsp;                    components[counter].isVisible()) {</b>
<i>1966</i>&nbsp;                    retValue[counter] = getMinimumSizeOfComponent
<b class="nc"><i>1967</i>&nbsp;                                        (components[counter]);</b>
<b class="nc"><i>1968</i>&nbsp;                }</b>
<b class="nc"><i>1969</i>&nbsp;                else {</b>
<i>1970</i>&nbsp;                    retValue[counter] = -1;
<i>1971</i>&nbsp;                }
<b class="nc"><i>1972</i>&nbsp;            }</b>
<b class="nc"><i>1973</i>&nbsp;            retValue[2] = (components[2] != null) ?</b>
<i>1974</i>&nbsp;                getMinimumSizeOfComponent(components[2]) : -1;
<b class="nc"><i>1975</i>&nbsp;            return retValue;</b>
<b class="nc"><i>1976</i>&nbsp;        }</b>
<b class="nc"><i>1977</i>&nbsp;</b>
<i>1978</i>&nbsp;        /**
<i>1979</i>&nbsp;         * Resets the components to their preferred sizes.
<i>1980</i>&nbsp;         */
<b class="nc"><i>1981</i>&nbsp;        void resetToPreferredSizes(int availableSize) {</b>
<b class="nc"><i>1982</i>&nbsp;            // Set the sizes to the preferred sizes (if fits), otherwise</b>
<i>1983</i>&nbsp;            // set to min sizes and distribute any extra space.
<i>1984</i>&nbsp;            int[]       testSizes = getPreferredSizes();
<b class="nc"><i>1985</i>&nbsp;            int         totalSize = 0;</b>
<b class="nc"><i>1986</i>&nbsp;</b>
<i>1987</i>&nbsp;            for (int counter = 0; counter &lt; 3; counter++) {
<b class="nc"><i>1988</i>&nbsp;                if (testSizes[counter] != -1) {</b>
<b class="nc"><i>1989</i>&nbsp;                    totalSize += testSizes[counter];</b>
<b class="nc"><i>1990</i>&nbsp;                }</b>
<i>1991</i>&nbsp;            }
<i>1992</i>&nbsp;            if (totalSize &gt; availableSize) {
<i>1993</i>&nbsp;                testSizes = getMinimumSizes();
<b class="nc"><i>1994</i>&nbsp;</b>
<b class="nc"><i>1995</i>&nbsp;                totalSize = 0;</b>
<i>1996</i>&nbsp;                for (int counter = 0; counter &lt; 3; counter++) {
<i>1997</i>&nbsp;                    if (testSizes[counter] != -1) {
<b class="nc"><i>1998</i>&nbsp;                        totalSize += testSizes[counter];</b>
<b class="nc"><i>1999</i>&nbsp;                    }</b>
<i>2000</i>&nbsp;                }
<b class="nc"><i>2001</i>&nbsp;            }</b>
<b class="nc"><i>2002</i>&nbsp;            setSizes(testSizes);</b>
<i>2003</i>&nbsp;            distributeSpace(availableSize - totalSize, false);
<b class="nc"><i>2004</i>&nbsp;        }</b>
<b class="nc"><i>2005</i>&nbsp;</b>
<b class="nc"><i>2006</i>&nbsp;        /**</b>
<i>2007</i>&nbsp;         * Distributes &lt;code&gt;space&lt;/code&gt; between the two components
<b class="nc"><i>2008</i>&nbsp;         * (divider won&#39;t get any extra space) based on the weighting. This</b>
<b class="nc"><i>2009</i>&nbsp;         * attempts to honor the min size of the components.</b>
<i>2010</i>&nbsp;         *
<i>2011</i>&nbsp;         * @param keepHidden if true and one of the components is 0x0
<i>2012</i>&nbsp;         *                   it gets none of the extra space
<i>2013</i>&nbsp;         */
<i>2014</i>&nbsp;        void distributeSpace(int space, boolean keepHidden) {
<i>2015</i>&nbsp;            boolean          lValid = (components[0] != null &amp;&amp;
<i>2016</i>&nbsp;                                       components[0].isVisible());
<i>2017</i>&nbsp;            boolean          rValid = (components[1] != null &amp;&amp;
<i>2018</i>&nbsp;                                       components[1].isVisible());
<i>2019</i>&nbsp;
<i>2020</i>&nbsp;            if (keepHidden) {
<i>2021</i>&nbsp;                if (lValid &amp;&amp; getSizeForPrimaryAxis(
<i>2022</i>&nbsp;                                 components[0].getSize()) == 0) {
<b class="nc"><i>2023</i>&nbsp;                    lValid = false;</b>
<b class="nc"><i>2024</i>&nbsp;                    if (rValid &amp;&amp; getSizeForPrimaryAxis(</b>
<i>2025</i>&nbsp;                                     components[1].getSize()) == 0) {
<i>2026</i>&nbsp;                        // Both aren&#39;t valid, force them both to be valid
<i>2027</i>&nbsp;                        lValid = true;
<i>2028</i>&nbsp;                    }
<b class="nc"><i>2029</i>&nbsp;                }</b>
<i>2030</i>&nbsp;                else if (rValid &amp;&amp; getSizeForPrimaryAxis(
<i>2031</i>&nbsp;                                   components[1].getSize()) == 0) {
<i>2032</i>&nbsp;                    rValid = false;
<i>2033</i>&nbsp;                }
<i>2034</i>&nbsp;            }
<i>2035</i>&nbsp;            if (lValid &amp;&amp; rValid) {
<i>2036</i>&nbsp;                double        weight = splitPane.getResizeWeight();
<i>2037</i>&nbsp;                int           lExtra = (int)(weight * (double)space);
<i>2038</i>&nbsp;                int           rExtra = (space - lExtra);
<b class="nc"><i>2039</i>&nbsp;</b>
<b class="nc"><i>2040</i>&nbsp;                sizes[0] += lExtra;</b>
<i>2041</i>&nbsp;                sizes[1] += rExtra;
<b class="nc"><i>2042</i>&nbsp;</b>
<b class="nc"><i>2043</i>&nbsp;                int           lMin = getMinimumSizeOfComponent(components[0]);</b>
<b class="nc"><i>2044</i>&nbsp;                int           rMin = getMinimumSizeOfComponent(components[1]);</b>
<b class="nc"><i>2045</i>&nbsp;                boolean       lMinValid = (sizes[0] &gt;= lMin);</b>
<b class="nc"><i>2046</i>&nbsp;                boolean       rMinValid = (sizes[1] &gt;= rMin);</b>
<b class="nc"><i>2047</i>&nbsp;</b>
<b class="nc"><i>2048</i>&nbsp;                if (!lMinValid &amp;&amp; !rMinValid) {</b>
<b class="nc"><i>2049</i>&nbsp;                    if (sizes[0] &lt; 0) {</b>
<b class="nc"><i>2050</i>&nbsp;                        sizes[1] += sizes[0];</b>
<i>2051</i>&nbsp;                        sizes[0] = 0;
<b class="nc"><i>2052</i>&nbsp;                    }</b>
<i>2053</i>&nbsp;                    else if (sizes[1] &lt; 0) {
<b class="nc"><i>2054</i>&nbsp;                        sizes[0] += sizes[1];</b>
<i>2055</i>&nbsp;                        sizes[1] = 0;
<i>2056</i>&nbsp;                    }
<i>2057</i>&nbsp;                }
<i>2058</i>&nbsp;                else if (!lMinValid) {
<b class="nc"><i>2059</i>&nbsp;                    if (sizes[1] - (lMin - sizes[0]) &lt; rMin) {</b>
<b class="nc"><i>2060</i>&nbsp;                        // both below min, just make sure &gt; 0</b>
<b class="nc"><i>2061</i>&nbsp;                        if (sizes[0] &lt; 0) {</b>
<b class="nc"><i>2062</i>&nbsp;                            sizes[1] += sizes[0];</b>
<b class="nc"><i>2063</i>&nbsp;                            sizes[0] = 0;</b>
<i>2064</i>&nbsp;                        }
<i>2065</i>&nbsp;                    }
<i>2066</i>&nbsp;                    else {
<i>2067</i>&nbsp;                        sizes[1] -= (lMin - sizes[0]);
<i>2068</i>&nbsp;                        sizes[0] = lMin;
<i>2069</i>&nbsp;                    }
<i>2070</i>&nbsp;                }
<i>2071</i>&nbsp;                else if (!rMinValid) {
<b class="nc"><i>2072</i>&nbsp;                    if (sizes[0] - (rMin - sizes[1]) &lt; lMin) {</b>
<b class="nc"><i>2073</i>&nbsp;                        // both below min, just make sure &gt; 0</b>
<i>2074</i>&nbsp;                        if (sizes[1] &lt; 0) {
<i>2075</i>&nbsp;                            sizes[0] += sizes[1];
<i>2076</i>&nbsp;                            sizes[1] = 0;
<b class="nc"><i>2077</i>&nbsp;                        }</b>
<b class="nc"><i>2078</i>&nbsp;                    }</b>
<i>2079</i>&nbsp;                    else {
<i>2080</i>&nbsp;                        sizes[0] -= (rMin - sizes[1]);
<i>2081</i>&nbsp;                        sizes[1] = rMin;
<i>2082</i>&nbsp;                    }
<i>2083</i>&nbsp;                }
<i>2084</i>&nbsp;                if (sizes[0] &lt; 0) {
<i>2085</i>&nbsp;                    sizes[0] = 0;
<i>2086</i>&nbsp;                }
<i>2087</i>&nbsp;                if (sizes[1] &lt; 0) {
<i>2088</i>&nbsp;                    sizes[1] = 0;
<i>2089</i>&nbsp;                }
<i>2090</i>&nbsp;            }
<i>2091</i>&nbsp;            else if (lValid) {
<i>2092</i>&nbsp;                sizes[0] = Math.max(0, sizes[0] + space);
<i>2093</i>&nbsp;            }
<b class="nc"><i>2094</i>&nbsp;            else if (rValid) {</b>
<i>2095</i>&nbsp;                sizes[1] = Math.max(0, sizes[1] + space);
<i>2096</i>&nbsp;            }
<i>2097</i>&nbsp;        }
<b class="nc"><i>2098</i>&nbsp;    }</b>
<b class="nc"><i>2099</i>&nbsp;</b>
<b class="nc"><i>2100</i>&nbsp;</b>
<i>2101</i>&nbsp;    /**
<b class="nc"><i>2102</i>&nbsp;     * LayoutManager used for JSplitPanes with an orientation of</b>
<i>2103</i>&nbsp;     * VERTICAL_SPLIT.
<i>2104</i>&nbsp;     *
<b class="nc"><i>2105</i>&nbsp;     */</b>
<b class="nc"><i>2106</i>&nbsp;    public class BasicVerticalLayoutManager extends</b>
<b class="nc"><i>2107</i>&nbsp;            BasicHorizontalLayoutManager</b>
<b class="nc"><i>2108</i>&nbsp;    {</b>
<i>2109</i>&nbsp;        /**
<b class="nc"><i>2110</i>&nbsp;         * Constructs a new instance of {@code BasicVerticalLayoutManager}.</b>
<i>2111</i>&nbsp;         */
<i>2112</i>&nbsp;        public BasicVerticalLayoutManager() {
<b class="nc"><i>2113</i>&nbsp;            super(1);</b>
<b class="nc"><i>2114</i>&nbsp;        }</b>
<b class="nc"><i>2115</i>&nbsp;    }</b>
<b class="nc"><i>2116</i>&nbsp;</b>
<b class="nc"><i>2117</i>&nbsp;</b>
<i>2118</i>&nbsp;    private class Handler implements FocusListener, PropertyChangeListener {
<i>2119</i>&nbsp;        //
<b class="nc"><i>2120</i>&nbsp;        // PropertyChangeListener</b>
<b class="nc"><i>2121</i>&nbsp;        //</b>
<b class="nc"><i>2122</i>&nbsp;        /**</b>
<i>2123</i>&nbsp;         * Messaged from the &lt;code&gt;JSplitPane&lt;/code&gt; the receiver is
<i>2124</i>&nbsp;         * contained in.  May potentially reset the layout manager and cause a
<b class="nc"><i>2125</i>&nbsp;         * &lt;code&gt;validate&lt;/code&gt; to be sent.</b>
<b class="nc"><i>2126</i>&nbsp;         */</b>
<b class="nc"><i>2127</i>&nbsp;        public void propertyChange(PropertyChangeEvent e) {</b>
<b class="nc"><i>2128</i>&nbsp;            if(e.getSource() == splitPane) {</b>
<b class="nc"><i>2129</i>&nbsp;                String changeName = e.getPropertyName();</b>
<i>2130</i>&nbsp;
<b class="nc"><i>2131</i>&nbsp;                if(changeName == JSplitPane.ORIENTATION_PROPERTY) {</b>
<b class="nc"><i>2132</i>&nbsp;                    orientation = splitPane.getOrientation();</b>
<i>2133</i>&nbsp;                    resetLayoutManager();
<i>2134</i>&nbsp;                } else if(changeName == JSplitPane.CONTINUOUS_LAYOUT_PROPERTY){
<i>2135</i>&nbsp;                    setContinuousLayout(splitPane.isContinuousLayout());
<b class="nc"><i>2136</i>&nbsp;                    if(!isContinuousLayout()) {</b>
<i>2137</i>&nbsp;                        if(nonContinuousLayoutDivider == null) {
<i>2138</i>&nbsp;                            setNonContinuousLayoutDivider(
<b class="nc"><i>2139</i>&nbsp;                                createDefaultNonContinuousLayoutDivider(),</b>
<i>2140</i>&nbsp;                                true);
<b class="nc"><i>2141</i>&nbsp;                        } else if(nonContinuousLayoutDivider.getParent() ==</b>
<b class="nc"><i>2142</i>&nbsp;                                  null) {</b>
<b class="nc"><i>2143</i>&nbsp;                            setNonContinuousLayoutDivider(</b>
<i>2144</i>&nbsp;                                nonContinuousLayoutDivider,
<b class="nc"><i>2145</i>&nbsp;                                true);</b>
<b class="nc"><i>2146</i>&nbsp;                        }</b>
<i>2147</i>&nbsp;                    }
<b class="nc"><i>2148</i>&nbsp;                } else if(changeName == JSplitPane.DIVIDER_SIZE_PROPERTY){</b>
<b class="nc"><i>2149</i>&nbsp;                    divider.setDividerSize(splitPane.getDividerSize());</b>
<i>2150</i>&nbsp;                    dividerSize = divider.getDividerSize();
<b class="nc"><i>2151</i>&nbsp;                    splitPane.revalidate();</b>
<i>2152</i>&nbsp;                    splitPane.repaint();
<b class="nc"><i>2153</i>&nbsp;                }</b>
<b class="nc"><i>2154</i>&nbsp;            }</b>
<i>2155</i>&nbsp;        }
<b class="nc"><i>2156</i>&nbsp;</b>
<b class="nc"><i>2157</i>&nbsp;        //</b>
<i>2158</i>&nbsp;        // FocusListener
<b class="nc"><i>2159</i>&nbsp;        //</b>
<b class="nc"><i>2160</i>&nbsp;        public void focusGained(FocusEvent ev) {</b>
<i>2161</i>&nbsp;            dividerKeyboardResize = true;
<i>2162</i>&nbsp;            splitPane.repaint();
<i>2163</i>&nbsp;        }
<i>2164</i>&nbsp;
<b class="nc"><i>2165</i>&nbsp;        public void focusLost(FocusEvent ev) {</b>
<b class="nc"><i>2166</i>&nbsp;            dividerKeyboardResize = false;</b>
<b class="nc"><i>2167</i>&nbsp;            splitPane.repaint();</b>
<b class="nc"><i>2168</i>&nbsp;        }</b>
<b class="nc"><i>2169</i>&nbsp;    }</b>
<b class="nc"><i>2170</i>&nbsp;</b>
<b class="nc"><i>2171</i>&nbsp;</b>
<i>2172</i>&nbsp;    private static class Actions extends UIAction {
<b class="nc"><i>2173</i>&nbsp;        private static final String NEGATIVE_INCREMENT = &quot;negativeIncrement&quot;;</b>
<b class="nc"><i>2174</i>&nbsp;        private static final String POSITIVE_INCREMENT = &quot;positiveIncrement&quot;;</b>
<b class="nc"><i>2175</i>&nbsp;        private static final String SELECT_MIN = &quot;selectMin&quot;;</b>
<b class="nc"><i>2176</i>&nbsp;        private static final String SELECT_MAX = &quot;selectMax&quot;;</b>
<b class="nc"><i>2177</i>&nbsp;        private static final String START_RESIZE = &quot;startResize&quot;;</b>
<b class="nc"><i>2178</i>&nbsp;        private static final String TOGGLE_FOCUS = &quot;toggleFocus&quot;;</b>
<b class="nc"><i>2179</i>&nbsp;        private static final String FOCUS_OUT_FORWARD = &quot;focusOutForward&quot;;</b>
<b class="nc"><i>2180</i>&nbsp;        private static final String FOCUS_OUT_BACKWARD = &quot;focusOutBackward&quot;;</b>
<i>2181</i>&nbsp;
<b class="nc"><i>2182</i>&nbsp;        Actions(String key) {</b>
<b class="nc"><i>2183</i>&nbsp;            super(key);</b>
<i>2184</i>&nbsp;        }
<i>2185</i>&nbsp;
<i>2186</i>&nbsp;        public void actionPerformed(ActionEvent ev) {
<i>2187</i>&nbsp;            JSplitPane splitPane = (JSplitPane)ev.getSource();
<b class="nc"><i>2188</i>&nbsp;            BasicSplitPaneUI ui = (BasicSplitPaneUI)BasicLookAndFeel.</b>
<b class="nc"><i>2189</i>&nbsp;                      getUIOfType(splitPane.getUI(), BasicSplitPaneUI.class);</b>
<i>2190</i>&nbsp;
<i>2191</i>&nbsp;            if (ui == null) {
<b class="nc"><i>2192</i>&nbsp;                return;</b>
<b class="nc"><i>2193</i>&nbsp;            }</b>
<b class="nc"><i>2194</i>&nbsp;            String key = getName();</b>
<b class="nc"><i>2195</i>&nbsp;            if (key == NEGATIVE_INCREMENT) {</b>
<i>2196</i>&nbsp;                if (ui.dividerKeyboardResize) {
<i>2197</i>&nbsp;                    splitPane.setDividerLocation(Math.max(
<b class="nc"><i>2198</i>&nbsp;                              0, ui.getDividerLocation</b>
<b class="nc"><i>2199</i>&nbsp;                              (splitPane) - ui.getKeyboardMoveIncrement()));</b>
<b class="nc"><i>2200</i>&nbsp;                }</b>
<b class="nc"><i>2201</i>&nbsp;            }</b>
<b class="nc"><i>2202</i>&nbsp;            else if (key == POSITIVE_INCREMENT) {</b>
<i>2203</i>&nbsp;                if (ui.dividerKeyboardResize) {
<i>2204</i>&nbsp;                    splitPane.setDividerLocation(
<b class="nc"><i>2205</i>&nbsp;                        ui.getDividerLocation(splitPane) +</b>
<i>2206</i>&nbsp;                        ui.getKeyboardMoveIncrement());
<i>2207</i>&nbsp;                }
<i>2208</i>&nbsp;            }
<i>2209</i>&nbsp;            else if (key == SELECT_MIN) {
<b class="nc"><i>2210</i>&nbsp;                if (ui.dividerKeyboardResize) {</b>
<b class="nc"><i>2211</i>&nbsp;                    splitPane.setDividerLocation(0);</b>
<i>2212</i>&nbsp;                }
<b class="nc"><i>2213</i>&nbsp;            }</b>
<i>2214</i>&nbsp;            else if (key == SELECT_MAX) {
<b class="nc"><i>2215</i>&nbsp;                if (ui.dividerKeyboardResize) {</b>
<b class="nc"><i>2216</i>&nbsp;                    Insets   insets = splitPane.getInsets();</b>
<b class="nc"><i>2217</i>&nbsp;                    int      bottomI = (insets != null) ? insets.bottom : 0;</b>
<i>2218</i>&nbsp;                    int      rightI = (insets != null) ? insets.right : 0;
<i>2219</i>&nbsp;
<b class="nc"><i>2220</i>&nbsp;                    if (ui.orientation == JSplitPane.VERTICAL_SPLIT) {</b>
<b class="nc"><i>2221</i>&nbsp;                        splitPane.setDividerLocation(splitPane.getHeight() -</b>
<i>2222</i>&nbsp;                                                     bottomI);
<b class="nc"><i>2223</i>&nbsp;                    }</b>
<i>2224</i>&nbsp;                    else {
<b class="nc"><i>2225</i>&nbsp;                        splitPane.setDividerLocation(splitPane.getWidth() -</b>
<b class="nc"><i>2226</i>&nbsp;                                                     rightI);</b>
<b class="nc"><i>2227</i>&nbsp;                    }</b>
<i>2228</i>&nbsp;                }
<i>2229</i>&nbsp;            }
<b class="nc"><i>2230</i>&nbsp;            else if (key == START_RESIZE) {</b>
<i>2231</i>&nbsp;                if (!ui.dividerKeyboardResize) {
<i>2232</i>&nbsp;                    splitPane.requestFocus();
<i>2233</i>&nbsp;                } else {
<b class="nc"><i>2234</i>&nbsp;                    JSplitPane parentSplitPane =</b>
<b class="nc"><i>2235</i>&nbsp;                        (JSplitPane)SwingUtilities.getAncestorOfClass(</b>
<b class="nc"><i>2236</i>&nbsp;                                         JSplitPane.class, splitPane);</b>
<b class="nc"><i>2237</i>&nbsp;                    if (parentSplitPane!=null) {</b>
<b class="nc"><i>2238</i>&nbsp;                        parentSplitPane.requestFocus();</b>
<i>2239</i>&nbsp;                    }
<b class="nc"><i>2240</i>&nbsp;                }</b>
<i>2241</i>&nbsp;            }
<i>2242</i>&nbsp;            else if (key == TOGGLE_FOCUS) {
<b class="nc"><i>2243</i>&nbsp;                toggleFocus(splitPane);</b>
<i>2244</i>&nbsp;            }
<i>2245</i>&nbsp;            else if (key == FOCUS_OUT_FORWARD) {
<i>2246</i>&nbsp;                moveFocus(splitPane, 1);
<i>2247</i>&nbsp;            }
<i>2248</i>&nbsp;            else if (key == FOCUS_OUT_BACKWARD) {
<i>2249</i>&nbsp;                moveFocus(splitPane, -1);
<i>2250</i>&nbsp;            }
<i>2251</i>&nbsp;        }
<i>2252</i>&nbsp;
<i>2253</i>&nbsp;        private void moveFocus(JSplitPane splitPane, int direction) {
<i>2254</i>&nbsp;            Container rootAncestor = splitPane.getFocusCycleRootAncestor();
<i>2255</i>&nbsp;            FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();
<i>2256</i>&nbsp;            Component focusOn = (direction &gt; 0) ?
<i>2257</i>&nbsp;                policy.getComponentAfter(rootAncestor, splitPane) :
<i>2258</i>&nbsp;                policy.getComponentBefore(rootAncestor, splitPane);
<i>2259</i>&nbsp;            HashSet&lt;Component&gt; focusFrom = new HashSet&lt;Component&gt;();
<i>2260</i>&nbsp;            if (splitPane.isAncestorOf(focusOn)) {
<i>2261</i>&nbsp;                do {
<i>2262</i>&nbsp;                    focusFrom.add(focusOn);
<i>2263</i>&nbsp;                    rootAncestor = focusOn.getFocusCycleRootAncestor();
<i>2264</i>&nbsp;                    policy = rootAncestor.getFocusTraversalPolicy();
<i>2265</i>&nbsp;                    focusOn = (direction &gt; 0) ?
<i>2266</i>&nbsp;                        policy.getComponentAfter(rootAncestor, focusOn) :
<i>2267</i>&nbsp;                        policy.getComponentBefore(rootAncestor, focusOn);
<i>2268</i>&nbsp;                } while (splitPane.isAncestorOf(focusOn) &amp;&amp;
<i>2269</i>&nbsp;                         !focusFrom.contains(focusOn));
<i>2270</i>&nbsp;            }
<i>2271</i>&nbsp;            if ( focusOn!=null &amp;&amp; !splitPane.isAncestorOf(focusOn) ) {
<i>2272</i>&nbsp;                focusOn.requestFocus();
<i>2273</i>&nbsp;            }
<i>2274</i>&nbsp;        }
<i>2275</i>&nbsp;
<i>2276</i>&nbsp;        private void toggleFocus(JSplitPane splitPane) {
<i>2277</i>&nbsp;            Component left = splitPane.getLeftComponent();
<i>2278</i>&nbsp;            Component right = splitPane.getRightComponent();
<i>2279</i>&nbsp;
<i>2280</i>&nbsp;            KeyboardFocusManager manager =
<i>2281</i>&nbsp;                KeyboardFocusManager.getCurrentKeyboardFocusManager();
<i>2282</i>&nbsp;            Component focus = manager.getFocusOwner();
<i>2283</i>&nbsp;            Component focusOn = getNextSide(splitPane, focus);
<i>2284</i>&nbsp;            if (focusOn != null) {
<i>2285</i>&nbsp;                // don&#39;t change the focus if the new focused component belongs
<i>2286</i>&nbsp;                // to the same splitpane and the same side
<i>2287</i>&nbsp;                if ( focus!=null &amp;&amp;
<i>2288</i>&nbsp;                     ( (SwingUtilities.isDescendingFrom(focus, left) &amp;&amp;
<i>2289</i>&nbsp;                        SwingUtilities.isDescendingFrom(focusOn, left)) ||
<i>2290</i>&nbsp;                       (SwingUtilities.isDescendingFrom(focus, right) &amp;&amp;
<i>2291</i>&nbsp;                        SwingUtilities.isDescendingFrom(focusOn, right)) ) ) {
<i>2292</i>&nbsp;                    return;
<i>2293</i>&nbsp;                }
<i>2294</i>&nbsp;                SwingUtilities2.compositeRequestFocus(focusOn);
<i>2295</i>&nbsp;            }
<i>2296</i>&nbsp;        }
<i>2297</i>&nbsp;
<i>2298</i>&nbsp;        private Component getNextSide(JSplitPane splitPane, Component focus) {
<i>2299</i>&nbsp;            Component left = splitPane.getLeftComponent();
<i>2300</i>&nbsp;            Component right = splitPane.getRightComponent();
<i>2301</i>&nbsp;            Component next;
<i>2302</i>&nbsp;            if (focus!=null &amp;&amp; SwingUtilities.isDescendingFrom(focus, left) &amp;&amp;
<i>2303</i>&nbsp;                right!=null) {
<i>2304</i>&nbsp;                next = getFirstAvailableComponent(right);
<i>2305</i>&nbsp;                if (next != null) {
<i>2306</i>&nbsp;                    return next;
<i>2307</i>&nbsp;                }
<i>2308</i>&nbsp;            }
<i>2309</i>&nbsp;            JSplitPane parentSplitPane = (JSplitPane)SwingUtilities.getAncestorOfClass(JSplitPane.class, splitPane);
<i>2310</i>&nbsp;            if (parentSplitPane!=null) {
<i>2311</i>&nbsp;                // focus next side of the parent split pane
<i>2312</i>&nbsp;                next = getNextSide(parentSplitPane, focus);
<i>2313</i>&nbsp;            } else {
<i>2314</i>&nbsp;                next = getFirstAvailableComponent(left);
<i>2315</i>&nbsp;                if (next == null) {
<i>2316</i>&nbsp;                    next = getFirstAvailableComponent(right);
<i>2317</i>&nbsp;                }
<i>2318</i>&nbsp;            }
<i>2319</i>&nbsp;            return next;
<i>2320</i>&nbsp;        }
<i>2321</i>&nbsp;
<i>2322</i>&nbsp;        private Component getFirstAvailableComponent(Component c) {
<i>2323</i>&nbsp;            if (c!=null &amp;&amp; c instanceof JSplitPane) {
<i>2324</i>&nbsp;                JSplitPane sp = (JSplitPane)c;
<i>2325</i>&nbsp;                Component left = getFirstAvailableComponent(sp.getLeftComponent());
<i>2326</i>&nbsp;                if (left != null) {
<i>2327</i>&nbsp;                    c = left;
<i>2328</i>&nbsp;                } else {
<i>2329</i>&nbsp;                    c = getFirstAvailableComponent(sp.getRightComponent());
<i>2330</i>&nbsp;                }
<i>2331</i>&nbsp;            }
<i>2332</i>&nbsp;            return c;
<i>2333</i>&nbsp;        }
<i>2334</i>&nbsp;    }
<i>2335</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
