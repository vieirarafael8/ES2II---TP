


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ConstantPool</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.java.util.jar.pack</a> ]
</div>

<h1>Coverage Summary for Class: ConstantPool (com.sun.java.util.jar.pack)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ConstantPool</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 292)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ConstantPool$BootstrapMethodEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$ClassEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$DescriptorEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$Entry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$Index</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 83)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$IndexGroup</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 119)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$InvokeDynamicEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$LiteralEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$MemberEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$MethodHandleEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$MethodTypeEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$NumberEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$SignatureEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 66)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$StringEntry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConstantPool$Utf8Entry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 173)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 820)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.java.util.jar.pack;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.AbstractList;
<i>29</i>&nbsp;import java.util.ArrayList;
<i>30</i>&nbsp;import java.util.Arrays;
<i>31</i>&nbsp;import java.util.Collection;
<i>32</i>&nbsp;import java.util.List;
<i>33</i>&nbsp;import java.util.ListIterator;
<i>34</i>&nbsp;import java.util.Map;
<i>35</i>&nbsp;import java.util.Set;
<i>36</i>&nbsp;import static com.sun.java.util.jar.pack.Constants.*;
<i>37</i>&nbsp;
<i>38</i>&nbsp;/**
<i>39</i>&nbsp; * Representation of constant pool entries and indexes.
<i>40</i>&nbsp; * @author John Rose
<i>41</i>&nbsp; */
<b class="nc"><i>42</i>&nbsp;abstract</b>
<i>43</i>&nbsp;class ConstantPool {
<b class="nc"><i>44</i>&nbsp;    private ConstantPool() {}  // do not instantiate</b>
<i>45</i>&nbsp;
<i>46</i>&nbsp;    static int verbose() {
<b class="nc"><i>47</i>&nbsp;        return Utils.currentPropMap().getInteger(Utils.DEBUG_VERBOSE);</b>
<i>48</i>&nbsp;    }
<i>49</i>&nbsp;
<i>50</i>&nbsp;    /** Factory for Utf8 string constants.
<i>51</i>&nbsp;     *  Used for well-known strings like &quot;SourceFile&quot;, &quot;&lt;init&gt;&quot;, etc.
<i>52</i>&nbsp;     *  Also used to back up more complex constant pool entries, like Class.
<i>53</i>&nbsp;     */
<i>54</i>&nbsp;    public static synchronized Utf8Entry getUtf8Entry(String value) {
<b class="nc"><i>55</i>&nbsp;        Map&lt;String, Utf8Entry&gt; utf8Entries  = Utils.getTLGlobals().getUtf8Entries();</b>
<b class="nc"><i>56</i>&nbsp;        Utf8Entry e = utf8Entries.get(value);</b>
<b class="nc"><i>57</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>58</i>&nbsp;            e = new Utf8Entry(value);</b>
<b class="nc"><i>59</i>&nbsp;            utf8Entries.put(e.stringValue(), e);</b>
<i>60</i>&nbsp;        }
<b class="nc"><i>61</i>&nbsp;        return e;</b>
<i>62</i>&nbsp;    }
<i>63</i>&nbsp;    /** Factory for Class constants. */
<i>64</i>&nbsp;    public static ClassEntry getClassEntry(String name) {
<b class="nc"><i>65</i>&nbsp;        Map&lt;String, ClassEntry&gt; classEntries = Utils.getTLGlobals().getClassEntries();</b>
<b class="nc"><i>66</i>&nbsp;        ClassEntry e = classEntries.get(name);</b>
<b class="nc"><i>67</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>68</i>&nbsp;            e = new ClassEntry(getUtf8Entry(name));</b>
<b class="nc"><i>69</i>&nbsp;            assert(name.equals(e.stringValue()));</b>
<b class="nc"><i>70</i>&nbsp;            classEntries.put(e.stringValue(), e);</b>
<i>71</i>&nbsp;        }
<b class="nc"><i>72</i>&nbsp;        return e;</b>
<i>73</i>&nbsp;    }
<i>74</i>&nbsp;    /** Factory for literal constants (String, Integer, etc.). */
<i>75</i>&nbsp;    public static LiteralEntry getLiteralEntry(Comparable&lt;?&gt; value) {
<b class="nc"><i>76</i>&nbsp;        Map&lt;Object, LiteralEntry&gt; literalEntries = Utils.getTLGlobals().getLiteralEntries();</b>
<b class="nc"><i>77</i>&nbsp;        LiteralEntry e = literalEntries.get(value);</b>
<b class="nc"><i>78</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>79</i>&nbsp;            if (value instanceof String)</b>
<b class="nc"><i>80</i>&nbsp;                e = new StringEntry(getUtf8Entry((String)value));</b>
<i>81</i>&nbsp;            else
<b class="nc"><i>82</i>&nbsp;                e = new NumberEntry((Number)value);</b>
<b class="nc"><i>83</i>&nbsp;            literalEntries.put(value, e);</b>
<i>84</i>&nbsp;        }
<b class="nc"><i>85</i>&nbsp;        return e;</b>
<i>86</i>&nbsp;    }
<i>87</i>&nbsp;    /** Factory for literal constants (String, Integer, etc.). */
<i>88</i>&nbsp;    public static StringEntry getStringEntry(String value) {
<b class="nc"><i>89</i>&nbsp;        return (StringEntry) getLiteralEntry(value);</b>
<i>90</i>&nbsp;    }
<i>91</i>&nbsp;
<i>92</i>&nbsp;    /** Factory for signature (type) constants. */
<i>93</i>&nbsp;    public static SignatureEntry getSignatureEntry(String type) {
<b class="nc"><i>94</i>&nbsp;        Map&lt;String, SignatureEntry&gt; signatureEntries = Utils.getTLGlobals().getSignatureEntries();</b>
<b class="nc"><i>95</i>&nbsp;        SignatureEntry e = signatureEntries.get(type);</b>
<b class="nc"><i>96</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>97</i>&nbsp;            e = new SignatureEntry(type);</b>
<b class="nc"><i>98</i>&nbsp;            assert(e.stringValue().equals(type));</b>
<b class="nc"><i>99</i>&nbsp;            signatureEntries.put(type, e);</b>
<i>100</i>&nbsp;        }
<b class="nc"><i>101</i>&nbsp;        return e;</b>
<i>102</i>&nbsp;    }
<i>103</i>&nbsp;    // Convenience overloading.
<i>104</i>&nbsp;    public static SignatureEntry getSignatureEntry(Utf8Entry formRef, ClassEntry[] classRefs) {
<b class="nc"><i>105</i>&nbsp;        return getSignatureEntry(SignatureEntry.stringValueOf(formRef, classRefs));</b>
<i>106</i>&nbsp;    }
<i>107</i>&nbsp;
<i>108</i>&nbsp;    /** Factory for descriptor (name-and-type) constants. */
<i>109</i>&nbsp;    public static DescriptorEntry getDescriptorEntry(Utf8Entry nameRef, SignatureEntry typeRef) {
<b class="nc"><i>110</i>&nbsp;        Map&lt;String, DescriptorEntry&gt; descriptorEntries = Utils.getTLGlobals().getDescriptorEntries();</b>
<b class="nc"><i>111</i>&nbsp;        String key = DescriptorEntry.stringValueOf(nameRef, typeRef);</b>
<b class="nc"><i>112</i>&nbsp;        DescriptorEntry e = descriptorEntries.get(key);</b>
<b class="nc"><i>113</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>114</i>&nbsp;            e = new DescriptorEntry(nameRef, typeRef);</b>
<b class="nc"><i>115</i>&nbsp;            assert(e.stringValue().equals(key))</b>
<b class="nc"><i>116</i>&nbsp;                : (e.stringValue()+&quot; != &quot;+(key));</b>
<b class="nc"><i>117</i>&nbsp;            descriptorEntries.put(key, e);</b>
<i>118</i>&nbsp;        }
<b class="nc"><i>119</i>&nbsp;        return e;</b>
<i>120</i>&nbsp;    }
<i>121</i>&nbsp;    // Convenience overloading.
<i>122</i>&nbsp;    public static DescriptorEntry getDescriptorEntry(Utf8Entry nameRef, Utf8Entry typeRef) {
<b class="nc"><i>123</i>&nbsp;        return getDescriptorEntry(nameRef, getSignatureEntry(typeRef.stringValue()));</b>
<i>124</i>&nbsp;    }
<i>125</i>&nbsp;
<i>126</i>&nbsp;    /** Factory for member reference constants. */
<i>127</i>&nbsp;    public static MemberEntry getMemberEntry(byte tag, ClassEntry classRef, DescriptorEntry descRef) {
<b class="nc"><i>128</i>&nbsp;        Map&lt;String, MemberEntry&gt; memberEntries = Utils.getTLGlobals().getMemberEntries();</b>
<b class="nc"><i>129</i>&nbsp;        String key = MemberEntry.stringValueOf(tag, classRef, descRef);</b>
<b class="nc"><i>130</i>&nbsp;        MemberEntry e = memberEntries.get(key);</b>
<b class="nc"><i>131</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>132</i>&nbsp;            e = new MemberEntry(tag, classRef, descRef);</b>
<b class="nc"><i>133</i>&nbsp;            assert(e.stringValue().equals(key))</b>
<b class="nc"><i>134</i>&nbsp;                : (e.stringValue()+&quot; != &quot;+(key));</b>
<b class="nc"><i>135</i>&nbsp;            memberEntries.put(key, e);</b>
<i>136</i>&nbsp;        }
<b class="nc"><i>137</i>&nbsp;        return e;</b>
<i>138</i>&nbsp;    }
<i>139</i>&nbsp;
<i>140</i>&nbsp;    /** Factory for MethodHandle constants. */
<i>141</i>&nbsp;    public static MethodHandleEntry getMethodHandleEntry(byte refKind, MemberEntry memRef) {
<b class="nc"><i>142</i>&nbsp;        Map&lt;String, MethodHandleEntry&gt; methodHandleEntries = Utils.getTLGlobals().getMethodHandleEntries();</b>
<b class="nc"><i>143</i>&nbsp;        String key = MethodHandleEntry.stringValueOf(refKind, memRef);</b>
<b class="nc"><i>144</i>&nbsp;        MethodHandleEntry e = methodHandleEntries.get(key);</b>
<b class="nc"><i>145</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>146</i>&nbsp;            e = new MethodHandleEntry(refKind, memRef);</b>
<b class="nc"><i>147</i>&nbsp;            assert(e.stringValue().equals(key));</b>
<b class="nc"><i>148</i>&nbsp;            methodHandleEntries.put(key, e);</b>
<i>149</i>&nbsp;        }
<b class="nc"><i>150</i>&nbsp;        return e;</b>
<i>151</i>&nbsp;    }
<i>152</i>&nbsp;
<i>153</i>&nbsp;    /** Factory for MethodType constants. */
<i>154</i>&nbsp;    public static MethodTypeEntry getMethodTypeEntry(SignatureEntry sigRef) {
<b class="nc"><i>155</i>&nbsp;        Map&lt;String, MethodTypeEntry&gt; methodTypeEntries = Utils.getTLGlobals().getMethodTypeEntries();</b>
<b class="nc"><i>156</i>&nbsp;        String key = sigRef.stringValue();</b>
<b class="nc"><i>157</i>&nbsp;        MethodTypeEntry e = methodTypeEntries.get(key);</b>
<b class="nc"><i>158</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>159</i>&nbsp;            e = new MethodTypeEntry(sigRef);</b>
<b class="nc"><i>160</i>&nbsp;            assert(e.stringValue().equals(key));</b>
<b class="nc"><i>161</i>&nbsp;            methodTypeEntries.put(key, e);</b>
<i>162</i>&nbsp;        }
<b class="nc"><i>163</i>&nbsp;        return e;</b>
<i>164</i>&nbsp;    }
<i>165</i>&nbsp;    public static MethodTypeEntry getMethodTypeEntry(Utf8Entry typeRef) {
<b class="nc"><i>166</i>&nbsp;        return getMethodTypeEntry(getSignatureEntry(typeRef.stringValue()));</b>
<i>167</i>&nbsp;    }
<i>168</i>&nbsp;
<i>169</i>&nbsp;    /** Factory for InvokeDynamic constants. */
<i>170</i>&nbsp;    public static InvokeDynamicEntry getInvokeDynamicEntry(BootstrapMethodEntry bssRef, DescriptorEntry descRef) {
<b class="nc"><i>171</i>&nbsp;        Map&lt;String, InvokeDynamicEntry&gt; invokeDynamicEntries = Utils.getTLGlobals().getInvokeDynamicEntries();</b>
<b class="nc"><i>172</i>&nbsp;        String key = InvokeDynamicEntry.stringValueOf(bssRef, descRef);</b>
<b class="nc"><i>173</i>&nbsp;        InvokeDynamicEntry e = invokeDynamicEntries.get(key);</b>
<b class="nc"><i>174</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>175</i>&nbsp;            e = new InvokeDynamicEntry(bssRef, descRef);</b>
<b class="nc"><i>176</i>&nbsp;            assert(e.stringValue().equals(key));</b>
<b class="nc"><i>177</i>&nbsp;            invokeDynamicEntries.put(key, e);</b>
<i>178</i>&nbsp;        }
<b class="nc"><i>179</i>&nbsp;        return e;</b>
<i>180</i>&nbsp;    }
<i>181</i>&nbsp;
<i>182</i>&nbsp;    /** Factory for BootstrapMethod pseudo-constants. */
<i>183</i>&nbsp;    public static BootstrapMethodEntry getBootstrapMethodEntry(MethodHandleEntry bsmRef, Entry[] argRefs) {
<b class="nc"><i>184</i>&nbsp;        Map&lt;String, BootstrapMethodEntry&gt; bootstrapMethodEntries = Utils.getTLGlobals().getBootstrapMethodEntries();</b>
<b class="nc"><i>185</i>&nbsp;        String key = BootstrapMethodEntry.stringValueOf(bsmRef, argRefs);</b>
<b class="nc"><i>186</i>&nbsp;        BootstrapMethodEntry e = bootstrapMethodEntries.get(key);</b>
<b class="nc"><i>187</i>&nbsp;        if (e == null) {</b>
<b class="nc"><i>188</i>&nbsp;            e = new BootstrapMethodEntry(bsmRef, argRefs);</b>
<b class="nc"><i>189</i>&nbsp;            assert(e.stringValue().equals(key));</b>
<b class="nc"><i>190</i>&nbsp;            bootstrapMethodEntries.put(key, e);</b>
<i>191</i>&nbsp;        }
<b class="nc"><i>192</i>&nbsp;        return e;</b>
<i>193</i>&nbsp;    }
<i>194</i>&nbsp;
<i>195</i>&nbsp;
<i>196</i>&nbsp;    /** Entries in the constant pool. */
<b class="nc"><i>197</i>&nbsp;    public abstract static</b>
<i>198</i>&nbsp;    class Entry implements Comparable&lt;Object&gt; {
<i>199</i>&nbsp;        protected final byte tag;       // a CONSTANT_foo code
<i>200</i>&nbsp;        protected int valueHash;        // cached hashCode
<i>201</i>&nbsp;
<b class="nc"><i>202</i>&nbsp;        protected Entry(byte tag) {</b>
<b class="nc"><i>203</i>&nbsp;            this.tag = tag;</b>
<i>204</i>&nbsp;        }
<i>205</i>&nbsp;
<i>206</i>&nbsp;        public final byte getTag() {
<b class="nc"><i>207</i>&nbsp;            return tag;</b>
<i>208</i>&nbsp;        }
<i>209</i>&nbsp;
<i>210</i>&nbsp;        public final boolean tagEquals(int tag) {
<b class="nc"><i>211</i>&nbsp;            return getTag() == tag;</b>
<i>212</i>&nbsp;        }
<i>213</i>&nbsp;
<i>214</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>215</i>&nbsp;            return null;</b>
<i>216</i>&nbsp;        }
<i>217</i>&nbsp;
<i>218</i>&nbsp;        public boolean eq(Entry that) {  // same reference
<b class="nc"><i>219</i>&nbsp;            assert(that != null);</b>
<b class="nc"><i>220</i>&nbsp;            return this == that || this.equals(that);</b>
<i>221</i>&nbsp;        }
<i>222</i>&nbsp;
<i>223</i>&nbsp;        // Equality of Entries is value-based.
<i>224</i>&nbsp;        public abstract boolean equals(Object o);
<i>225</i>&nbsp;        public final int hashCode() {
<b class="nc"><i>226</i>&nbsp;            if (valueHash == 0) {</b>
<b class="nc"><i>227</i>&nbsp;                valueHash = computeValueHash();</b>
<b class="nc"><i>228</i>&nbsp;                if (valueHash == 0)  valueHash = 1;</b>
<i>229</i>&nbsp;            }
<b class="nc"><i>230</i>&nbsp;            return valueHash;</b>
<i>231</i>&nbsp;        }
<i>232</i>&nbsp;        protected abstract int computeValueHash();
<i>233</i>&nbsp;
<i>234</i>&nbsp;        public abstract int compareTo(Object o);
<i>235</i>&nbsp;
<i>236</i>&nbsp;        protected int superCompareTo(Object o) {
<b class="nc"><i>237</i>&nbsp;            Entry that = (Entry) o;</b>
<i>238</i>&nbsp;
<b class="nc"><i>239</i>&nbsp;            if (this.tag != that.tag) {</b>
<b class="nc"><i>240</i>&nbsp;                return TAG_ORDER[this.tag] - TAG_ORDER[that.tag];</b>
<i>241</i>&nbsp;            }
<i>242</i>&nbsp;
<b class="nc"><i>243</i>&nbsp;            return 0;  // subclasses must refine this</b>
<i>244</i>&nbsp;        }
<i>245</i>&nbsp;
<i>246</i>&nbsp;        public final boolean isDoubleWord() {
<b class="nc"><i>247</i>&nbsp;            return tag == CONSTANT_Double || tag == CONSTANT_Long;</b>
<i>248</i>&nbsp;        }
<i>249</i>&nbsp;
<i>250</i>&nbsp;        public final boolean tagMatches(int matchTag) {
<b class="nc"><i>251</i>&nbsp;            if (tag == matchTag)</b>
<b class="nc"><i>252</i>&nbsp;                return true;</b>
<i>253</i>&nbsp;            byte[] allowedTags;
<b class="nc"><i>254</i>&nbsp;            switch (matchTag) {</b>
<i>255</i>&nbsp;                case CONSTANT_All:
<b class="nc"><i>256</i>&nbsp;                    return true;</b>
<i>257</i>&nbsp;                case CONSTANT_Signature:
<b class="nc"><i>258</i>&nbsp;                    return tag == CONSTANT_Utf8;  // format check also?</b>
<i>259</i>&nbsp;                case CONSTANT_LoadableValue:
<b class="nc"><i>260</i>&nbsp;                    allowedTags = LOADABLE_VALUE_TAGS;</b>
<b class="nc"><i>261</i>&nbsp;                    break;</b>
<i>262</i>&nbsp;                case CONSTANT_AnyMember:
<b class="nc"><i>263</i>&nbsp;                    allowedTags = ANY_MEMBER_TAGS;</b>
<b class="nc"><i>264</i>&nbsp;                    break;</b>
<i>265</i>&nbsp;                case CONSTANT_FieldSpecific:
<b class="nc"><i>266</i>&nbsp;                    allowedTags = FIELD_SPECIFIC_TAGS;</b>
<b class="nc"><i>267</i>&nbsp;                    break;</b>
<i>268</i>&nbsp;                default:
<b class="nc"><i>269</i>&nbsp;                    return false;</b>
<i>270</i>&nbsp;            }
<b class="nc"><i>271</i>&nbsp;            for (byte b : allowedTags) {</b>
<b class="nc"><i>272</i>&nbsp;                if (b == tag)</b>
<b class="nc"><i>273</i>&nbsp;                    return true;</b>
<i>274</i>&nbsp;            }
<b class="nc"><i>275</i>&nbsp;            return false;</b>
<i>276</i>&nbsp;        }
<i>277</i>&nbsp;
<i>278</i>&nbsp;        public String toString() {
<b class="nc"><i>279</i>&nbsp;            String valuePrint = stringValue();</b>
<b class="nc"><i>280</i>&nbsp;            if (verbose() &gt; 4) {</b>
<b class="nc"><i>281</i>&nbsp;                if (valueHash != 0)</b>
<b class="nc"><i>282</i>&nbsp;                    valuePrint += &quot; hash=&quot;+valueHash;</b>
<b class="nc"><i>283</i>&nbsp;                valuePrint += &quot; id=&quot;+System.identityHashCode(this);</b>
<i>284</i>&nbsp;            }
<b class="nc"><i>285</i>&nbsp;            return tagName(tag)+&quot;=&quot;+valuePrint;</b>
<i>286</i>&nbsp;        }
<i>287</i>&nbsp;        public abstract String stringValue();
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;    public static
<i>291</i>&nbsp;    class Utf8Entry extends Entry {
<i>292</i>&nbsp;        final String value;
<i>293</i>&nbsp;
<i>294</i>&nbsp;        Utf8Entry(String value) {
<b class="nc"><i>295</i>&nbsp;            super(CONSTANT_Utf8);</b>
<b class="nc"><i>296</i>&nbsp;            this.value = value.intern();</b>
<b class="nc"><i>297</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>298</i>&nbsp;        }
<i>299</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>300</i>&nbsp;            return value.hashCode();</b>
<i>301</i>&nbsp;        }
<i>302</i>&nbsp;        public boolean equals(Object o) {
<i>303</i>&nbsp;            // Use reference equality of interned strings:
<b class="nc"><i>304</i>&nbsp;            return (o != null &amp;&amp; o.getClass() == Utf8Entry.class</b>
<b class="nc"><i>305</i>&nbsp;                    &amp;&amp; ((Utf8Entry) o).value.equals(value));</b>
<i>306</i>&nbsp;        }
<i>307</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>308</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>309</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>310</i>&nbsp;                x = value.compareTo(((Utf8Entry)o).value);</b>
<i>311</i>&nbsp;            }
<b class="nc"><i>312</i>&nbsp;            return x;</b>
<i>313</i>&nbsp;        }
<i>314</i>&nbsp;        public String stringValue() {
<b class="nc"><i>315</i>&nbsp;            return value;</b>
<i>316</i>&nbsp;        }
<i>317</i>&nbsp;    }
<i>318</i>&nbsp;
<i>319</i>&nbsp;    static boolean isMemberTag(byte tag) {
<b class="nc"><i>320</i>&nbsp;        switch (tag) {</b>
<i>321</i>&nbsp;        case CONSTANT_Fieldref:
<i>322</i>&nbsp;        case CONSTANT_Methodref:
<i>323</i>&nbsp;        case CONSTANT_InterfaceMethodref:
<b class="nc"><i>324</i>&nbsp;            return true;</b>
<i>325</i>&nbsp;        }
<b class="nc"><i>326</i>&nbsp;        return false;</b>
<i>327</i>&nbsp;    }
<i>328</i>&nbsp;
<i>329</i>&nbsp;    static byte numberTagOf(Number value) {
<b class="nc"><i>330</i>&nbsp;        if (value instanceof Integer)  return CONSTANT_Integer;</b>
<b class="nc"><i>331</i>&nbsp;        if (value instanceof Float)    return CONSTANT_Float;</b>
<b class="nc"><i>332</i>&nbsp;        if (value instanceof Long)     return CONSTANT_Long;</b>
<b class="nc"><i>333</i>&nbsp;        if (value instanceof Double)   return CONSTANT_Double;</b>
<b class="nc"><i>334</i>&nbsp;        throw new RuntimeException(&quot;bad literal value &quot;+value);</b>
<i>335</i>&nbsp;    }
<i>336</i>&nbsp;
<i>337</i>&nbsp;    static boolean isRefKind(byte refKind) {
<b class="nc"><i>338</i>&nbsp;        return (REF_getField &lt;= refKind &amp;&amp; refKind &lt;= REF_invokeInterface);</b>
<i>339</i>&nbsp;    }
<i>340</i>&nbsp;
<i>341</i>&nbsp;    public abstract static
<i>342</i>&nbsp;    class LiteralEntry extends Entry {
<i>343</i>&nbsp;        protected LiteralEntry(byte tag) {
<b class="nc"><i>344</i>&nbsp;            super(tag);</b>
<i>345</i>&nbsp;        }
<i>346</i>&nbsp;
<i>347</i>&nbsp;        public abstract Comparable&lt;?&gt; literalValue();
<i>348</i>&nbsp;    }
<i>349</i>&nbsp;
<i>350</i>&nbsp;    public static
<i>351</i>&nbsp;    class NumberEntry extends LiteralEntry {
<i>352</i>&nbsp;        final Number value;
<i>353</i>&nbsp;        NumberEntry(Number value) {
<b class="nc"><i>354</i>&nbsp;            super(numberTagOf(value));</b>
<b class="nc"><i>355</i>&nbsp;            this.value = value;</b>
<b class="nc"><i>356</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>357</i>&nbsp;        }
<i>358</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>359</i>&nbsp;            return value.hashCode();</b>
<i>360</i>&nbsp;        }
<i>361</i>&nbsp;
<i>362</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>363</i>&nbsp;            return (o != null &amp;&amp; o.getClass() == NumberEntry.class</b>
<b class="nc"><i>364</i>&nbsp;                    &amp;&amp; ((NumberEntry) o).value.equals(value));</b>
<i>365</i>&nbsp;
<i>366</i>&nbsp;        }
<i>367</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>368</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>369</i>&nbsp;            if (x == 0) {</b>
<i>370</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>371</i>&nbsp;                Comparable&lt;Number&gt; compValue = (Comparable&lt;Number&gt;)value;</b>
<b class="nc"><i>372</i>&nbsp;                x = compValue.compareTo(((NumberEntry)o).value);</b>
<i>373</i>&nbsp;            }
<b class="nc"><i>374</i>&nbsp;            return x;</b>
<i>375</i>&nbsp;        }
<i>376</i>&nbsp;        public Number numberValue() {
<b class="nc"><i>377</i>&nbsp;            return value;</b>
<i>378</i>&nbsp;        }
<i>379</i>&nbsp;        public Comparable&lt;?&gt; literalValue() {
<b class="nc"><i>380</i>&nbsp;            return (Comparable&lt;?&gt;) value;</b>
<i>381</i>&nbsp;        }
<i>382</i>&nbsp;        public String stringValue() {
<b class="nc"><i>383</i>&nbsp;            return value.toString();</b>
<i>384</i>&nbsp;        }
<i>385</i>&nbsp;    }
<i>386</i>&nbsp;
<i>387</i>&nbsp;    public static
<i>388</i>&nbsp;    class StringEntry extends LiteralEntry {
<i>389</i>&nbsp;        final Utf8Entry ref;
<b class="nc"><i>390</i>&nbsp;        public Entry getRef(int i) { return i == 0 ? ref : null; }</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;        StringEntry(Entry ref) {
<b class="nc"><i>393</i>&nbsp;            super(CONSTANT_String);</b>
<b class="nc"><i>394</i>&nbsp;            this.ref = (Utf8Entry) ref;</b>
<b class="nc"><i>395</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>396</i>&nbsp;        }
<i>397</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>398</i>&nbsp;            return ref.hashCode() + tag;</b>
<i>399</i>&nbsp;        }
<i>400</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>401</i>&nbsp;            return (o != null &amp;&amp; o.getClass() == StringEntry.class &amp;&amp;</b>
<b class="nc"><i>402</i>&nbsp;                    ((StringEntry)o).ref.eq(ref));</b>
<i>403</i>&nbsp;        }
<i>404</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>405</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>406</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>407</i>&nbsp;                x = ref.compareTo(((StringEntry)o).ref);</b>
<i>408</i>&nbsp;            }
<b class="nc"><i>409</i>&nbsp;            return x;</b>
<i>410</i>&nbsp;        }
<i>411</i>&nbsp;        public Comparable&lt;?&gt; literalValue() {
<b class="nc"><i>412</i>&nbsp;            return ref.stringValue();</b>
<i>413</i>&nbsp;        }
<i>414</i>&nbsp;        public String stringValue() {
<b class="nc"><i>415</i>&nbsp;            return ref.stringValue();</b>
<i>416</i>&nbsp;        }
<i>417</i>&nbsp;    }
<i>418</i>&nbsp;
<i>419</i>&nbsp;    public static
<i>420</i>&nbsp;    class ClassEntry extends Entry {
<i>421</i>&nbsp;        final Utf8Entry ref;
<b class="nc"><i>422</i>&nbsp;        public Entry getRef(int i) { return i == 0 ? ref : null; }</b>
<i>423</i>&nbsp;
<i>424</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>425</i>&nbsp;            return ref.hashCode() + tag;</b>
<i>426</i>&nbsp;        }
<i>427</i>&nbsp;        ClassEntry(Entry ref) {
<b class="nc"><i>428</i>&nbsp;            super(CONSTANT_Class);</b>
<b class="nc"><i>429</i>&nbsp;            this.ref = (Utf8Entry) ref;</b>
<b class="nc"><i>430</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>431</i>&nbsp;        }
<i>432</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>433</i>&nbsp;            return (o != null &amp;&amp; o.getClass() == ClassEntry.class</b>
<b class="nc"><i>434</i>&nbsp;                    &amp;&amp; ((ClassEntry) o).ref.eq(ref));</b>
<i>435</i>&nbsp;        }
<i>436</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>437</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>438</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>439</i>&nbsp;                x = ref.compareTo(((ClassEntry)o).ref);</b>
<i>440</i>&nbsp;            }
<b class="nc"><i>441</i>&nbsp;            return x;</b>
<i>442</i>&nbsp;        }
<i>443</i>&nbsp;        public String stringValue() {
<b class="nc"><i>444</i>&nbsp;            return ref.stringValue();</b>
<i>445</i>&nbsp;        }
<i>446</i>&nbsp;    }
<i>447</i>&nbsp;
<i>448</i>&nbsp;    public static
<i>449</i>&nbsp;    class DescriptorEntry extends Entry {
<i>450</i>&nbsp;        final Utf8Entry      nameRef;
<i>451</i>&nbsp;        final SignatureEntry typeRef;
<i>452</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>453</i>&nbsp;            if (i == 0)  return nameRef;</b>
<b class="nc"><i>454</i>&nbsp;            if (i == 1)  return typeRef;</b>
<b class="nc"><i>455</i>&nbsp;            return null;</b>
<i>456</i>&nbsp;        }
<i>457</i>&nbsp;        DescriptorEntry(Entry nameRef, Entry typeRef) {
<b class="nc"><i>458</i>&nbsp;            super(CONSTANT_NameandType);</b>
<b class="nc"><i>459</i>&nbsp;            if (typeRef instanceof Utf8Entry) {</b>
<b class="nc"><i>460</i>&nbsp;                typeRef = getSignatureEntry(typeRef.stringValue());</b>
<i>461</i>&nbsp;            }
<b class="nc"><i>462</i>&nbsp;            this.nameRef = (Utf8Entry) nameRef;</b>
<b class="nc"><i>463</i>&nbsp;            this.typeRef = (SignatureEntry) typeRef;</b>
<b class="nc"><i>464</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>465</i>&nbsp;        }
<i>466</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>467</i>&nbsp;            int hc2 = typeRef.hashCode();</b>
<b class="nc"><i>468</i>&nbsp;            return (nameRef.hashCode() + (hc2 &lt;&lt; 8)) ^ hc2;</b>
<i>469</i>&nbsp;        }
<i>470</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>471</i>&nbsp;            if (o == null || o.getClass() != DescriptorEntry.class) {</b>
<b class="nc"><i>472</i>&nbsp;                return false;</b>
<i>473</i>&nbsp;            }
<b class="nc"><i>474</i>&nbsp;            DescriptorEntry that = (DescriptorEntry)o;</b>
<b class="nc"><i>475</i>&nbsp;            return this.nameRef.eq(that.nameRef)</b>
<b class="nc"><i>476</i>&nbsp;                &amp;&amp; this.typeRef.eq(that.typeRef);</b>
<i>477</i>&nbsp;        }
<i>478</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>479</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>480</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>481</i>&nbsp;                DescriptorEntry that = (DescriptorEntry)o;</b>
<i>482</i>&nbsp;                // Primary key is typeRef, not nameRef.
<b class="nc"><i>483</i>&nbsp;                x = this.typeRef.compareTo(that.typeRef);</b>
<b class="nc"><i>484</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>485</i>&nbsp;                    x = this.nameRef.compareTo(that.nameRef);</b>
<i>486</i>&nbsp;            }
<b class="nc"><i>487</i>&nbsp;            return x;</b>
<i>488</i>&nbsp;        }
<i>489</i>&nbsp;        public String stringValue() {
<b class="nc"><i>490</i>&nbsp;            return stringValueOf(nameRef, typeRef);</b>
<i>491</i>&nbsp;        }
<i>492</i>&nbsp;        static
<i>493</i>&nbsp;        String stringValueOf(Entry nameRef, Entry typeRef) {
<b class="nc"><i>494</i>&nbsp;            return qualifiedStringValue(typeRef, nameRef);</b>
<i>495</i>&nbsp;        }
<i>496</i>&nbsp;
<i>497</i>&nbsp;        public String prettyString() {
<b class="nc"><i>498</i>&nbsp;            return nameRef.stringValue()+typeRef.prettyString();</b>
<i>499</i>&nbsp;        }
<i>500</i>&nbsp;
<i>501</i>&nbsp;        public boolean isMethod() {
<b class="nc"><i>502</i>&nbsp;            return typeRef.isMethod();</b>
<i>503</i>&nbsp;        }
<i>504</i>&nbsp;
<i>505</i>&nbsp;        public byte getLiteralTag() {
<b class="nc"><i>506</i>&nbsp;            return typeRef.getLiteralTag();</b>
<i>507</i>&nbsp;        }
<i>508</i>&nbsp;    }
<i>509</i>&nbsp;
<i>510</i>&nbsp;    static String qualifiedStringValue(Entry e1, Entry e2) {
<b class="nc"><i>511</i>&nbsp;        return qualifiedStringValue(e1.stringValue(), e2.stringValue());</b>
<i>512</i>&nbsp;    }
<i>513</i>&nbsp;    static String qualifiedStringValue(String s1, String s234) {
<i>514</i>&nbsp;        // Qualification by dot must decompose uniquely.  Second string might already be qualified.
<b class="nc"><i>515</i>&nbsp;        assert(s1.indexOf(&#39;.&#39;) &lt; 0);</b>
<b class="nc"><i>516</i>&nbsp;        return s1+&quot;.&quot;+s234;</b>
<i>517</i>&nbsp;    }
<i>518</i>&nbsp;
<b class="nc"><i>519</i>&nbsp;    public static</b>
<i>520</i>&nbsp;    class MemberEntry extends Entry {
<i>521</i>&nbsp;        final ClassEntry classRef;
<i>522</i>&nbsp;        final DescriptorEntry descRef;
<i>523</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>524</i>&nbsp;            if (i == 0)  return classRef;</b>
<b class="nc"><i>525</i>&nbsp;            if (i == 1)  return descRef;</b>
<b class="nc"><i>526</i>&nbsp;            return null;</b>
<i>527</i>&nbsp;        }
<i>528</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>529</i>&nbsp;            int hc2 = descRef.hashCode();</b>
<b class="nc"><i>530</i>&nbsp;            return (classRef.hashCode() + (hc2 &lt;&lt; 8)) ^ hc2;</b>
<i>531</i>&nbsp;        }
<i>532</i>&nbsp;
<i>533</i>&nbsp;        MemberEntry(byte tag, ClassEntry classRef, DescriptorEntry descRef) {
<b class="nc"><i>534</i>&nbsp;            super(tag);</b>
<b class="nc"><i>535</i>&nbsp;            assert(isMemberTag(tag));</b>
<b class="nc"><i>536</i>&nbsp;            this.classRef = classRef;</b>
<b class="nc"><i>537</i>&nbsp;            this.descRef  = descRef;</b>
<b class="nc"><i>538</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>539</i>&nbsp;        }
<i>540</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>541</i>&nbsp;            if (o == null || o.getClass() != MemberEntry.class) {</b>
<b class="nc"><i>542</i>&nbsp;                return false;</b>
<i>543</i>&nbsp;            }
<b class="nc"><i>544</i>&nbsp;            MemberEntry that = (MemberEntry)o;</b>
<b class="nc"><i>545</i>&nbsp;            return this.classRef.eq(that.classRef)</b>
<b class="nc"><i>546</i>&nbsp;                &amp;&amp; this.descRef.eq(that.descRef);</b>
<i>547</i>&nbsp;        }
<i>548</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>549</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>550</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>551</i>&nbsp;                MemberEntry that = (MemberEntry)o;</b>
<b class="nc"><i>552</i>&nbsp;                if (Utils.SORT_MEMBERS_DESCR_MAJOR)</b>
<i>553</i>&nbsp;                    // descRef is transmitted as UDELTA5; sort it first?
<b class="nc"><i>554</i>&nbsp;                    x = this.descRef.compareTo(that.descRef);</b>
<i>555</i>&nbsp;                // Primary key is classRef.
<b class="nc"><i>556</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>557</i>&nbsp;                    x = this.classRef.compareTo(that.classRef);</b>
<b class="nc"><i>558</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>559</i>&nbsp;                    x = this.descRef.compareTo(that.descRef);</b>
<i>560</i>&nbsp;            }
<b class="nc"><i>561</i>&nbsp;            return x;</b>
<i>562</i>&nbsp;        }
<i>563</i>&nbsp;        public String stringValue() {
<b class="nc"><i>564</i>&nbsp;            return stringValueOf(tag, classRef, descRef);</b>
<i>565</i>&nbsp;        }
<i>566</i>&nbsp;        static
<i>567</i>&nbsp;        String stringValueOf(byte tag, ClassEntry classRef, DescriptorEntry descRef) {
<b class="nc"><i>568</i>&nbsp;            assert(isMemberTag(tag));</b>
<i>569</i>&nbsp;            String pfx;
<b class="nc"><i>570</i>&nbsp;            switch (tag) {</b>
<b class="nc"><i>571</i>&nbsp;            case CONSTANT_Fieldref:            pfx = &quot;Field:&quot;;   break;</b>
<b class="nc"><i>572</i>&nbsp;            case CONSTANT_Methodref:           pfx = &quot;Method:&quot;;  break;</b>
<b class="nc"><i>573</i>&nbsp;            case CONSTANT_InterfaceMethodref:  pfx = &quot;IMethod:&quot;; break;</b>
<b class="nc"><i>574</i>&nbsp;            default:                           pfx = tag+&quot;???&quot;;  break;</b>
<i>575</i>&nbsp;            }
<b class="nc"><i>576</i>&nbsp;            return pfx+qualifiedStringValue(classRef, descRef);</b>
<i>577</i>&nbsp;        }
<i>578</i>&nbsp;
<i>579</i>&nbsp;        public boolean isMethod() {
<b class="nc"><i>580</i>&nbsp;            return descRef.isMethod();</b>
<i>581</i>&nbsp;        }
<i>582</i>&nbsp;    }
<i>583</i>&nbsp;
<b class="nc"><i>584</i>&nbsp;    public static</b>
<i>585</i>&nbsp;    class SignatureEntry extends Entry {
<i>586</i>&nbsp;        final Utf8Entry    formRef;
<i>587</i>&nbsp;        final ClassEntry[] classRefs;
<i>588</i>&nbsp;        String             value;
<i>589</i>&nbsp;        Utf8Entry          asUtf8Entry;
<i>590</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>591</i>&nbsp;            if (i == 0)  return formRef;</b>
<b class="nc"><i>592</i>&nbsp;            return i-1 &lt; classRefs.length ? classRefs[i-1] : null;</b>
<i>593</i>&nbsp;        }
<i>594</i>&nbsp;        SignatureEntry(String value) {
<b class="nc"><i>595</i>&nbsp;            super(CONSTANT_Signature);</b>
<b class="nc"><i>596</i>&nbsp;            value = value.intern();  // always do this</b>
<b class="nc"><i>597</i>&nbsp;            this.value = value;</b>
<b class="nc"><i>598</i>&nbsp;            String[] parts = structureSignature(value);</b>
<b class="nc"><i>599</i>&nbsp;            formRef = getUtf8Entry(parts[0]);</b>
<b class="nc"><i>600</i>&nbsp;            classRefs = new ClassEntry[parts.length-1];</b>
<b class="nc"><i>601</i>&nbsp;            for (int i = 1; i &lt; parts.length; i++) {</b>
<b class="nc"><i>602</i>&nbsp;                classRefs[i - 1] = getClassEntry(parts[i]);</b>
<i>603</i>&nbsp;            }
<b class="nc"><i>604</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>605</i>&nbsp;        }
<i>606</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>607</i>&nbsp;            stringValue();  // force computation of value</b>
<b class="nc"><i>608</i>&nbsp;            return value.hashCode() + tag;</b>
<i>609</i>&nbsp;        }
<i>610</i>&nbsp;
<i>611</i>&nbsp;        public Utf8Entry asUtf8Entry() {
<b class="nc"><i>612</i>&nbsp;            if (asUtf8Entry == null) {</b>
<b class="nc"><i>613</i>&nbsp;                asUtf8Entry = getUtf8Entry(stringValue());</b>
<i>614</i>&nbsp;            }
<b class="nc"><i>615</i>&nbsp;            return asUtf8Entry;</b>
<i>616</i>&nbsp;        }
<i>617</i>&nbsp;
<i>618</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>619</i>&nbsp;            return (o != null &amp;&amp; o.getClass() == SignatureEntry.class &amp;&amp;</b>
<b class="nc"><i>620</i>&nbsp;                    ((SignatureEntry)o).value.equals(value));</b>
<i>621</i>&nbsp;        }
<i>622</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>623</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>624</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>625</i>&nbsp;                SignatureEntry that = (SignatureEntry)o;</b>
<b class="nc"><i>626</i>&nbsp;                x = compareSignatures(this.value, that.value);</b>
<i>627</i>&nbsp;            }
<b class="nc"><i>628</i>&nbsp;            return x;</b>
<i>629</i>&nbsp;        }
<i>630</i>&nbsp;        public String stringValue() {
<b class="nc"><i>631</i>&nbsp;            if (value == null) {</b>
<b class="nc"><i>632</i>&nbsp;                value = stringValueOf(formRef, classRefs);</b>
<i>633</i>&nbsp;            }
<b class="nc"><i>634</i>&nbsp;            return value;</b>
<i>635</i>&nbsp;        }
<i>636</i>&nbsp;        static
<i>637</i>&nbsp;        String stringValueOf(Utf8Entry formRef, ClassEntry[] classRefs) {
<b class="nc"><i>638</i>&nbsp;            String[] parts = new String[1+classRefs.length];</b>
<b class="nc"><i>639</i>&nbsp;            parts[0] = formRef.stringValue();</b>
<b class="nc"><i>640</i>&nbsp;            for (int i = 1; i &lt; parts.length; i++) {</b>
<b class="nc"><i>641</i>&nbsp;                parts[i] = classRefs[i - 1].stringValue();</b>
<i>642</i>&nbsp;            }
<b class="nc"><i>643</i>&nbsp;            return flattenSignature(parts).intern();</b>
<i>644</i>&nbsp;        }
<i>645</i>&nbsp;
<i>646</i>&nbsp;        public int computeSize(boolean countDoublesTwice) {
<b class="nc"><i>647</i>&nbsp;            String form = formRef.stringValue();</b>
<b class="nc"><i>648</i>&nbsp;            int min = 0;</b>
<b class="nc"><i>649</i>&nbsp;            int max = 1;</b>
<b class="nc"><i>650</i>&nbsp;            if (isMethod()) {</b>
<b class="nc"><i>651</i>&nbsp;                min = 1;</b>
<b class="nc"><i>652</i>&nbsp;                max = form.indexOf(&#39;)&#39;);</b>
<i>653</i>&nbsp;            }
<b class="nc"><i>654</i>&nbsp;            int size = 0;</b>
<b class="nc"><i>655</i>&nbsp;            for (int i = min; i &lt; max; i++) {</b>
<b class="nc"><i>656</i>&nbsp;                switch (form.charAt(i)) {</b>
<i>657</i>&nbsp;                    case &#39;D&#39;:
<i>658</i>&nbsp;                    case &#39;J&#39;:
<b class="nc"><i>659</i>&nbsp;                        if (countDoublesTwice) {</b>
<b class="nc"><i>660</i>&nbsp;                            size++;</b>
<i>661</i>&nbsp;                        }
<i>662</i>&nbsp;                        break;
<i>663</i>&nbsp;                    case &#39;[&#39;:
<i>664</i>&nbsp;                        // Skip rest of array info.
<b class="nc"><i>665</i>&nbsp;                        while (form.charAt(i) == &#39;[&#39;) {</b>
<b class="nc"><i>666</i>&nbsp;                            ++i;</b>
<i>667</i>&nbsp;                        }
<i>668</i>&nbsp;                        break;
<i>669</i>&nbsp;                    case &#39;;&#39;:
<b class="nc"><i>670</i>&nbsp;                        continue;</b>
<i>671</i>&nbsp;                    default:
<b class="nc"><i>672</i>&nbsp;                        assert (0 &lt;= JAVA_SIGNATURE_CHARS.indexOf(form.charAt(i)));</b>
<i>673</i>&nbsp;                        break;
<i>674</i>&nbsp;                }
<b class="nc"><i>675</i>&nbsp;                size++;</b>
<i>676</i>&nbsp;            }
<b class="nc"><i>677</i>&nbsp;            return size;</b>
<i>678</i>&nbsp;        }
<i>679</i>&nbsp;        public boolean isMethod() {
<b class="nc"><i>680</i>&nbsp;            return formRef.stringValue().charAt(0) == &#39;(&#39;;</b>
<i>681</i>&nbsp;        }
<i>682</i>&nbsp;        public byte getLiteralTag() {
<b class="nc"><i>683</i>&nbsp;            switch (formRef.stringValue().charAt(0)) {</b>
<b class="nc"><i>684</i>&nbsp;            case &#39;I&#39;: return CONSTANT_Integer;</b>
<b class="nc"><i>685</i>&nbsp;            case &#39;J&#39;: return CONSTANT_Long;</b>
<b class="nc"><i>686</i>&nbsp;            case &#39;F&#39;: return CONSTANT_Float;</b>
<b class="nc"><i>687</i>&nbsp;            case &#39;D&#39;: return CONSTANT_Double;</b>
<i>688</i>&nbsp;            case &#39;B&#39;: case &#39;S&#39;: case &#39;C&#39;: case &#39;Z&#39;:
<b class="nc"><i>689</i>&nbsp;                return CONSTANT_Integer;</b>
<i>690</i>&nbsp;            case &#39;L&#39;:
<i>691</i>&nbsp;                /*
<i>692</i>&nbsp;                switch (classRefs[0].stringValue()) {
<i>693</i>&nbsp;                case &quot;java/lang/String&quot;:
<i>694</i>&nbsp;                    return CONSTANT_String;
<i>695</i>&nbsp;                case &quot;java/lang/invoke/MethodHandle&quot;:
<i>696</i>&nbsp;                    return CONSTANT_MethodHandle;
<i>697</i>&nbsp;                case &quot;java/lang/invoke/MethodType&quot;:
<i>698</i>&nbsp;                    return CONSTANT_MethodType;
<i>699</i>&nbsp;                default:  // java/lang/Object, etc.
<i>700</i>&nbsp;                    return CONSTANT_LoadableValue;
<i>701</i>&nbsp;                }
<i>702</i>&nbsp;                */
<b class="nc"><i>703</i>&nbsp;                return CONSTANT_String;  // JDK 7 ConstantValue limited to String</b>
<i>704</i>&nbsp;            }
<b class="nc"><i>705</i>&nbsp;            assert(false);</b>
<b class="nc"><i>706</i>&nbsp;            return CONSTANT_None;</b>
<i>707</i>&nbsp;        }
<i>708</i>&nbsp;        public String prettyString() {
<i>709</i>&nbsp;            String s;
<b class="nc"><i>710</i>&nbsp;            if (isMethod()) {</b>
<b class="nc"><i>711</i>&nbsp;                s = formRef.stringValue();</b>
<b class="nc"><i>712</i>&nbsp;                s = s.substring(0, 1+s.indexOf(&#39;)&#39;));</b>
<i>713</i>&nbsp;            } else {
<b class="nc"><i>714</i>&nbsp;                s = &quot;/&quot; + formRef.stringValue();</b>
<i>715</i>&nbsp;            }
<i>716</i>&nbsp;            int i;
<b class="nc"><i>717</i>&nbsp;            while ((i = s.indexOf(&#39;;&#39;)) &gt;= 0) {</b>
<b class="nc"><i>718</i>&nbsp;                s = s.substring(0, i) + s.substring(i + 1);</b>
<i>719</i>&nbsp;            }
<b class="nc"><i>720</i>&nbsp;            return s;</b>
<i>721</i>&nbsp;        }
<i>722</i>&nbsp;    }
<i>723</i>&nbsp;
<i>724</i>&nbsp;    static int compareSignatures(String s1, String s2) {
<b class="nc"><i>725</i>&nbsp;        return compareSignatures(s1, s2, null, null);</b>
<i>726</i>&nbsp;    }
<i>727</i>&nbsp;    static int compareSignatures(String s1, String s2, String[] p1, String[] p2) {
<i>728</i>&nbsp;        final int S1_COMES_FIRST = -1;
<i>729</i>&nbsp;        final int S2_COMES_FIRST = +1;
<b class="nc"><i>730</i>&nbsp;        char c1 = s1.charAt(0);</b>
<b class="nc"><i>731</i>&nbsp;        char c2 = s2.charAt(0);</b>
<i>732</i>&nbsp;        // fields before methods (because there are fewer of them)
<b class="nc"><i>733</i>&nbsp;        if (c1 != &#39;(&#39; &amp;&amp; c2 == &#39;(&#39;)  return S1_COMES_FIRST;</b>
<b class="nc"><i>734</i>&nbsp;        if (c2 != &#39;(&#39; &amp;&amp; c1 == &#39;(&#39;)  return S2_COMES_FIRST;</b>
<b class="nc"><i>735</i>&nbsp;        if (p1 == null)  p1 = structureSignature(s1);</b>
<b class="nc"><i>736</i>&nbsp;        if (p2 == null)  p2 = structureSignature(s2);</b>
<i>737</i>&nbsp;        /*
<i>738</i>&nbsp;         // non-classes before classes (because there are fewer of them)
<i>739</i>&nbsp;         if (p1.length == 1 &amp;&amp; p2.length &gt; 1)  return S1_COMES_FIRST;
<i>740</i>&nbsp;         if (p2.length == 1 &amp;&amp; p1.length &gt; 1)  return S2_COMES_FIRST;
<i>741</i>&nbsp;         // all else being equal, use the same comparison as for Utf8 strings
<i>742</i>&nbsp;         return s1.compareTo(s2);
<i>743</i>&nbsp;         */
<b class="nc"><i>744</i>&nbsp;        if (p1.length != p2.length)  return p1.length - p2.length;</b>
<b class="nc"><i>745</i>&nbsp;        int length = p1.length;</b>
<b class="nc"><i>746</i>&nbsp;        for (int i = length; --i &gt;= 0; ) {</b>
<b class="nc"><i>747</i>&nbsp;            int res = p1[i].compareTo(p2[i]);</b>
<b class="nc"><i>748</i>&nbsp;            if (res != 0)  return res;</b>
<b class="nc"><i>749</i>&nbsp;        }</b>
<b class="nc"><i>750</i>&nbsp;        assert(s1.equals(s2));</b>
<b class="nc"><i>751</i>&nbsp;        return 0;</b>
<i>752</i>&nbsp;    }
<i>753</i>&nbsp;
<i>754</i>&nbsp;    static int countClassParts(Utf8Entry formRef) {
<b class="nc"><i>755</i>&nbsp;        int num = 0;</b>
<b class="nc"><i>756</i>&nbsp;        String s = formRef.stringValue();</b>
<b class="nc"><i>757</i>&nbsp;        for (int i = 0; i &lt; s.length(); i++) {</b>
<b class="nc"><i>758</i>&nbsp;            if (s.charAt(i) == &#39;L&#39;)  ++num;</b>
<i>759</i>&nbsp;        }
<b class="nc"><i>760</i>&nbsp;        return num;</b>
<i>761</i>&nbsp;    }
<i>762</i>&nbsp;
<i>763</i>&nbsp;    static String flattenSignature(String[] parts) {
<b class="nc"><i>764</i>&nbsp;        String form = parts[0];</b>
<b class="nc"><i>765</i>&nbsp;        if (parts.length == 1)  return form;</b>
<b class="nc"><i>766</i>&nbsp;        int len = form.length();</b>
<b class="nc"><i>767</i>&nbsp;        for (int i = 1; i &lt; parts.length; i++) {</b>
<b class="nc"><i>768</i>&nbsp;            len += parts[i].length();</b>
<i>769</i>&nbsp;        }
<b class="nc"><i>770</i>&nbsp;        char[] sig = new char[len];</b>
<b class="nc"><i>771</i>&nbsp;        int j = 0;</b>
<b class="nc"><i>772</i>&nbsp;        int k = 1;</b>
<b class="nc"><i>773</i>&nbsp;        for (int i = 0; i &lt; form.length(); i++) {</b>
<b class="nc"><i>774</i>&nbsp;            char ch = form.charAt(i);</b>
<b class="nc"><i>775</i>&nbsp;            sig[j++] = ch;</b>
<b class="nc"><i>776</i>&nbsp;            if (ch == &#39;L&#39;) {</b>
<b class="nc"><i>777</i>&nbsp;                String cls = parts[k++];</b>
<b class="nc"><i>778</i>&nbsp;                cls.getChars(0, cls.length(), sig, j);</b>
<b class="nc"><i>779</i>&nbsp;                j += cls.length();</b>
<i>780</i>&nbsp;                //sig[j++] = &#39;;&#39;;
<i>781</i>&nbsp;            }
<i>782</i>&nbsp;        }
<b class="nc"><i>783</i>&nbsp;        assert(j == len);</b>
<b class="nc"><i>784</i>&nbsp;        assert(k == parts.length);</b>
<b class="nc"><i>785</i>&nbsp;        return new String(sig);</b>
<i>786</i>&nbsp;    }
<i>787</i>&nbsp;
<i>788</i>&nbsp;    private static int skipTo(char semi, String sig, int i) {
<b class="nc"><i>789</i>&nbsp;        i = sig.indexOf(semi, i);</b>
<b class="nc"><i>790</i>&nbsp;        return (i &gt;= 0) ? i : sig.length();</b>
<i>791</i>&nbsp;    }
<i>792</i>&nbsp;
<i>793</i>&nbsp;    static String[] structureSignature(String sig) {
<b class="nc"><i>794</i>&nbsp;        int firstl = sig.indexOf(&#39;L&#39;);</b>
<b class="nc"><i>795</i>&nbsp;        if (firstl &lt; 0) {</b>
<b class="nc"><i>796</i>&nbsp;            String[] parts = { sig };</b>
<b class="nc"><i>797</i>&nbsp;            return parts;</b>
<i>798</i>&nbsp;        }
<i>799</i>&nbsp;        // Segment the string like sig.split(&quot;L\\([^;&lt;]*\\)&quot;).
<i>800</i>&nbsp;        // N.B.: Previous version of this code did a more complex match,
<i>801</i>&nbsp;        // to next ch &lt; &#39; &#39; or ch in [&#39;;&#39;..&#39;@&#39;].  The only important
<i>802</i>&nbsp;        // characters are &#39;;&#39; and &#39;&lt;&#39;, since they are part of the
<i>803</i>&nbsp;        // signature syntax.
<i>804</i>&nbsp;        // Examples:
<i>805</i>&nbsp;        //   &quot;(Ljava/lang/Object;IJLLoo;)V&quot; =&gt; {&quot;(L;IJL;)V&quot;, &quot;java/lang/Object&quot;, &quot;Loo&quot;}
<i>806</i>&nbsp;        //   &quot;Ljava/util/List&lt;Ljava/lang/String;&gt;;&quot; =&gt; {&quot;L&lt;L;&gt;;&quot;, &quot;java/util/List&quot;, &quot;java/lang/String&quot;}
<b class="nc"><i>807</i>&nbsp;        char[] form = null;</b>
<b class="nc"><i>808</i>&nbsp;        String[] parts = null;</b>
<b class="nc"><i>809</i>&nbsp;        for (int pass = 0; pass &lt;= 1; pass++) {</b>
<i>810</i>&nbsp;            // pass 0 is a sizing pass, pass 1 packs the arrays
<b class="nc"><i>811</i>&nbsp;            int formPtr = 0;</b>
<b class="nc"><i>812</i>&nbsp;            int partPtr = 1;</b>
<b class="nc"><i>813</i>&nbsp;            int nextsemi = 0, nextangl = 0;  // next &#39;;&#39; or &#39;&lt;&#39;, or zero, or sigLen</b>
<b class="nc"><i>814</i>&nbsp;            int lastj = 0;</b>
<b class="nc"><i>815</i>&nbsp;            for (int i = firstl + 1, j; i &gt; 0; i = sig.indexOf(&#39;L&#39;, j) + 1) {</b>
<i>816</i>&nbsp;                // sig[i-1] is &#39;L&#39;, while sig[j] will be the first &#39;;&#39; or &#39;&lt;&#39; after it
<i>817</i>&nbsp;                // each part is in sig[i .. j-1]
<b class="nc"><i>818</i>&nbsp;                if (nextsemi &lt; i)  nextsemi = skipTo(&#39;;&#39;, sig, i);</b>
<b class="nc"><i>819</i>&nbsp;                if (nextangl &lt; i)  nextangl = skipTo(&#39;&lt;&#39;, sig, i);</b>
<b class="nc"><i>820</i>&nbsp;                j = (nextsemi &lt; nextangl ? nextsemi : nextangl);</b>
<b class="nc"><i>821</i>&nbsp;                if (pass != 0) {</b>
<b class="nc"><i>822</i>&nbsp;                    sig.getChars(lastj, i, form, formPtr);</b>
<b class="nc"><i>823</i>&nbsp;                    parts[partPtr] = sig.substring(i, j);</b>
<i>824</i>&nbsp;                }
<b class="nc"><i>825</i>&nbsp;                formPtr += (i - lastj);</b>
<b class="nc"><i>826</i>&nbsp;                partPtr += 1;</b>
<b class="nc"><i>827</i>&nbsp;                lastj = j;</b>
<i>828</i>&nbsp;            }
<b class="nc"><i>829</i>&nbsp;            if (pass != 0) {</b>
<b class="nc"><i>830</i>&nbsp;                sig.getChars(lastj, sig.length(), form, formPtr);</b>
<b class="nc"><i>831</i>&nbsp;                break;</b>
<i>832</i>&nbsp;            }
<b class="nc"><i>833</i>&nbsp;            formPtr += (sig.length() - lastj);</b>
<b class="nc"><i>834</i>&nbsp;            form = new char[formPtr];</b>
<b class="nc"><i>835</i>&nbsp;            parts = new String[partPtr];</b>
<i>836</i>&nbsp;        }
<b class="nc"><i>837</i>&nbsp;        parts[0] = new String(form);</b>
<i>838</i>&nbsp;        //assert(flattenSignature(parts).equals(sig));
<b class="nc"><i>839</i>&nbsp;        return parts;</b>
<i>840</i>&nbsp;    }
<i>841</i>&nbsp;
<i>842</i>&nbsp;    /** @since 1.7, JSR 292 */
<b class="nc"><i>843</i>&nbsp;    public static</b>
<i>844</i>&nbsp;    class MethodHandleEntry extends Entry {
<i>845</i>&nbsp;        final int refKind;
<i>846</i>&nbsp;        final MemberEntry memRef;
<b class="nc"><i>847</i>&nbsp;        public Entry getRef(int i) { return i == 0 ? memRef : null; }</b>
<i>848</i>&nbsp;
<i>849</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>850</i>&nbsp;            int hc2 = refKind;</b>
<b class="nc"><i>851</i>&nbsp;            return (memRef.hashCode() + (hc2 &lt;&lt; 8)) ^ hc2;</b>
<i>852</i>&nbsp;        }
<i>853</i>&nbsp;
<i>854</i>&nbsp;        MethodHandleEntry(byte refKind, MemberEntry memRef) {
<b class="nc"><i>855</i>&nbsp;            super(CONSTANT_MethodHandle);</b>
<b class="nc"><i>856</i>&nbsp;            assert(isRefKind(refKind));</b>
<b class="nc"><i>857</i>&nbsp;            this.refKind = refKind;</b>
<b class="nc"><i>858</i>&nbsp;            this.memRef  = memRef;</b>
<b class="nc"><i>859</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>860</i>&nbsp;        }
<i>861</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>862</i>&nbsp;            if (o == null || o.getClass() != MethodHandleEntry.class) {</b>
<b class="nc"><i>863</i>&nbsp;                return false;</b>
<i>864</i>&nbsp;            }
<b class="nc"><i>865</i>&nbsp;            MethodHandleEntry that = (MethodHandleEntry)o;</b>
<b class="nc"><i>866</i>&nbsp;            return this.refKind == that.refKind</b>
<b class="nc"><i>867</i>&nbsp;                &amp;&amp; this.memRef.eq(that.memRef);</b>
<i>868</i>&nbsp;        }
<i>869</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>870</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>871</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>872</i>&nbsp;                MethodHandleEntry that = (MethodHandleEntry)o;</b>
<b class="nc"><i>873</i>&nbsp;                if (Utils.SORT_HANDLES_KIND_MAJOR)</b>
<i>874</i>&nbsp;                    // Primary key could be refKind.
<b class="nc"><i>875</i>&nbsp;                    x = this.refKind - that.refKind;</b>
<i>876</i>&nbsp;                // Primary key is memRef, which is transmitted as UDELTA5.
<b class="nc"><i>877</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>878</i>&nbsp;                    x = this.memRef.compareTo(that.memRef);</b>
<b class="nc"><i>879</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>880</i>&nbsp;                    x = this.refKind - that.refKind;</b>
<i>881</i>&nbsp;            }
<b class="nc"><i>882</i>&nbsp;            return x;</b>
<i>883</i>&nbsp;        }
<i>884</i>&nbsp;        public static String stringValueOf(int refKind, MemberEntry memRef) {
<b class="nc"><i>885</i>&nbsp;            return refKindName(refKind)+&quot;:&quot;+memRef.stringValue();</b>
<i>886</i>&nbsp;        }
<i>887</i>&nbsp;        public String stringValue() {
<b class="nc"><i>888</i>&nbsp;            return stringValueOf(refKind, memRef);</b>
<i>889</i>&nbsp;        }
<i>890</i>&nbsp;    }
<i>891</i>&nbsp;
<i>892</i>&nbsp;    /** @since 1.7, JSR 292 */
<i>893</i>&nbsp;    public static
<i>894</i>&nbsp;    class MethodTypeEntry extends Entry {
<i>895</i>&nbsp;        final SignatureEntry typeRef;
<b class="nc"><i>896</i>&nbsp;        public Entry getRef(int i) { return i == 0 ? typeRef : null; }</b>
<i>897</i>&nbsp;
<i>898</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>899</i>&nbsp;            return typeRef.hashCode() + tag;</b>
<i>900</i>&nbsp;        }
<i>901</i>&nbsp;
<i>902</i>&nbsp;        MethodTypeEntry(SignatureEntry typeRef) {
<b class="nc"><i>903</i>&nbsp;            super(CONSTANT_MethodType);</b>
<b class="nc"><i>904</i>&nbsp;            this.typeRef  = typeRef;</b>
<b class="nc"><i>905</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>906</i>&nbsp;        }
<i>907</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>908</i>&nbsp;            if (o == null || o.getClass() != MethodTypeEntry.class) {</b>
<b class="nc"><i>909</i>&nbsp;                return false;</b>
<i>910</i>&nbsp;            }
<b class="nc"><i>911</i>&nbsp;            MethodTypeEntry that = (MethodTypeEntry)o;</b>
<b class="nc"><i>912</i>&nbsp;            return this.typeRef.eq(that.typeRef);</b>
<i>913</i>&nbsp;        }
<i>914</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>915</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>916</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>917</i>&nbsp;                MethodTypeEntry that = (MethodTypeEntry)o;</b>
<b class="nc"><i>918</i>&nbsp;                x = this.typeRef.compareTo(that.typeRef);</b>
<i>919</i>&nbsp;            }
<b class="nc"><i>920</i>&nbsp;            return x;</b>
<i>921</i>&nbsp;        }
<i>922</i>&nbsp;        public String stringValue() {
<b class="nc"><i>923</i>&nbsp;            return typeRef.stringValue();</b>
<i>924</i>&nbsp;        }
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<i>927</i>&nbsp;    /** @since 1.7, JSR 292 */
<i>928</i>&nbsp;    public static
<i>929</i>&nbsp;    class InvokeDynamicEntry extends Entry {
<i>930</i>&nbsp;        final BootstrapMethodEntry bssRef;
<i>931</i>&nbsp;        final DescriptorEntry descRef;
<i>932</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>933</i>&nbsp;            if (i == 0)  return bssRef;</b>
<b class="nc"><i>934</i>&nbsp;            if (i == 1)  return descRef;</b>
<b class="nc"><i>935</i>&nbsp;            return null;</b>
<i>936</i>&nbsp;        }
<i>937</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>938</i>&nbsp;            int hc2 = descRef.hashCode();</b>
<b class="nc"><i>939</i>&nbsp;            return (bssRef.hashCode() + (hc2 &lt;&lt; 8)) ^ hc2;</b>
<i>940</i>&nbsp;        }
<i>941</i>&nbsp;
<i>942</i>&nbsp;        InvokeDynamicEntry(BootstrapMethodEntry bssRef, DescriptorEntry descRef) {
<b class="nc"><i>943</i>&nbsp;            super(CONSTANT_InvokeDynamic);</b>
<b class="nc"><i>944</i>&nbsp;            this.bssRef  = bssRef;</b>
<b class="nc"><i>945</i>&nbsp;            this.descRef = descRef;</b>
<b class="nc"><i>946</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>947</i>&nbsp;        }
<i>948</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>949</i>&nbsp;            if (o == null || o.getClass() != InvokeDynamicEntry.class) {</b>
<b class="nc"><i>950</i>&nbsp;                return false;</b>
<i>951</i>&nbsp;            }
<b class="nc"><i>952</i>&nbsp;            InvokeDynamicEntry that = (InvokeDynamicEntry)o;</b>
<b class="nc"><i>953</i>&nbsp;            return this.bssRef.eq(that.bssRef)</b>
<b class="nc"><i>954</i>&nbsp;                &amp;&amp; this.descRef.eq(that.descRef);</b>
<i>955</i>&nbsp;        }
<i>956</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>957</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>958</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>959</i>&nbsp;                InvokeDynamicEntry that = (InvokeDynamicEntry)o;</b>
<b class="nc"><i>960</i>&nbsp;                if (Utils.SORT_INDY_BSS_MAJOR)</b>
<i>961</i>&nbsp;                    // Primary key could be bsmRef.
<b class="nc"><i>962</i>&nbsp;                    x = this.bssRef.compareTo(that.bssRef);</b>
<i>963</i>&nbsp;                // Primary key is descriptor, which is transmitted as UDELTA5.
<b class="nc"><i>964</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>965</i>&nbsp;                    x = this.descRef.compareTo(that.descRef);</b>
<b class="nc"><i>966</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>967</i>&nbsp;                    x = this.bssRef.compareTo(that.bssRef);</b>
<i>968</i>&nbsp;            }
<b class="nc"><i>969</i>&nbsp;            return x;</b>
<i>970</i>&nbsp;        }
<i>971</i>&nbsp;        public String stringValue() {
<b class="nc"><i>972</i>&nbsp;            return stringValueOf(bssRef, descRef);</b>
<i>973</i>&nbsp;        }
<i>974</i>&nbsp;        static
<i>975</i>&nbsp;        String stringValueOf(BootstrapMethodEntry bssRef, DescriptorEntry descRef) {
<b class="nc"><i>976</i>&nbsp;            return &quot;Indy:&quot;+bssRef.stringValue()+&quot;.&quot;+descRef.stringValue();</b>
<i>977</i>&nbsp;        }
<i>978</i>&nbsp;    }
<i>979</i>&nbsp;
<i>980</i>&nbsp;    /** @since 1.7, JSR 292 */
<i>981</i>&nbsp;    public static
<i>982</i>&nbsp;    class BootstrapMethodEntry extends Entry {
<i>983</i>&nbsp;        final MethodHandleEntry bsmRef;
<i>984</i>&nbsp;        final Entry[] argRefs;
<i>985</i>&nbsp;        public Entry getRef(int i) {
<b class="nc"><i>986</i>&nbsp;            if (i == 0)  return bsmRef;</b>
<b class="nc"><i>987</i>&nbsp;            if (i-1 &lt; argRefs.length)  return argRefs[i-1];</b>
<b class="nc"><i>988</i>&nbsp;            return null;</b>
<i>989</i>&nbsp;        }
<i>990</i>&nbsp;        protected int computeValueHash() {
<b class="nc"><i>991</i>&nbsp;            int hc2 = bsmRef.hashCode();</b>
<b class="nc"><i>992</i>&nbsp;            return (Arrays.hashCode(argRefs) + (hc2 &lt;&lt; 8)) ^ hc2;</b>
<i>993</i>&nbsp;        }
<i>994</i>&nbsp;
<i>995</i>&nbsp;        BootstrapMethodEntry(MethodHandleEntry bsmRef, Entry[] argRefs) {
<b class="nc"><i>996</i>&nbsp;            super(CONSTANT_BootstrapMethod);</b>
<b class="nc"><i>997</i>&nbsp;            this.bsmRef  = bsmRef;</b>
<b class="nc"><i>998</i>&nbsp;            this.argRefs = argRefs.clone();</b>
<b class="nc"><i>999</i>&nbsp;            hashCode();  // force computation of valueHash</b>
<i>1000</i>&nbsp;        }
<i>1001</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>1002</i>&nbsp;            if (o == null || o.getClass() != BootstrapMethodEntry.class) {</b>
<b class="nc"><i>1003</i>&nbsp;                return false;</b>
<i>1004</i>&nbsp;            }
<b class="nc"><i>1005</i>&nbsp;            BootstrapMethodEntry that = (BootstrapMethodEntry)o;</b>
<b class="nc"><i>1006</i>&nbsp;            return this.bsmRef.eq(that.bsmRef)</b>
<b class="nc"><i>1007</i>&nbsp;                &amp;&amp; Arrays.equals(this.argRefs, that.argRefs);</b>
<i>1008</i>&nbsp;        }
<i>1009</i>&nbsp;        public int compareTo(Object o) {
<b class="nc"><i>1010</i>&nbsp;            int x = superCompareTo(o);</b>
<b class="nc"><i>1011</i>&nbsp;            if (x == 0) {</b>
<b class="nc"><i>1012</i>&nbsp;                BootstrapMethodEntry that = (BootstrapMethodEntry)o;</b>
<b class="nc"><i>1013</i>&nbsp;                if (Utils.SORT_BSS_BSM_MAJOR)</b>
<i>1014</i>&nbsp;                    // Primary key is bsmRef.
<b class="nc"><i>1015</i>&nbsp;                    x = this.bsmRef.compareTo(that.bsmRef);</b>
<i>1016</i>&nbsp;                // Primary key is args array length, which is transmitted as UDELTA5.
<b class="nc"><i>1017</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>1018</i>&nbsp;                    x = compareArgArrays(this.argRefs, that.argRefs);</b>
<b class="nc"><i>1019</i>&nbsp;                if (x == 0)</b>
<b class="nc"><i>1020</i>&nbsp;                    x = this.bsmRef.compareTo(that.bsmRef);</b>
<i>1021</i>&nbsp;            }
<b class="nc"><i>1022</i>&nbsp;            return x;</b>
<i>1023</i>&nbsp;        }
<i>1024</i>&nbsp;        public String stringValue() {
<b class="nc"><i>1025</i>&nbsp;            return stringValueOf(bsmRef, argRefs);</b>
<i>1026</i>&nbsp;        }
<i>1027</i>&nbsp;        static
<i>1028</i>&nbsp;        String stringValueOf(MethodHandleEntry bsmRef, Entry[] argRefs) {
<b class="nc"><i>1029</i>&nbsp;            StringBuilder sb = new StringBuilder(bsmRef.stringValue());</b>
<i>1030</i>&nbsp;            // Arguments are formatted as &quot;&lt;foo;bar;baz&gt;&quot; instead of &quot;[foo,bar,baz]&quot;.
<i>1031</i>&nbsp;            // This ensures there will be no confusion if &quot;[,]&quot; appear inside of names.
<b class="nc"><i>1032</i>&nbsp;            char nextSep = &#39;&lt;&#39;;</b>
<b class="nc"><i>1033</i>&nbsp;            boolean didOne = false;</b>
<b class="nc"><i>1034</i>&nbsp;            for (Entry argRef : argRefs) {</b>
<b class="nc"><i>1035</i>&nbsp;                sb.append(nextSep).append(argRef.stringValue());</b>
<b class="nc"><i>1036</i>&nbsp;                nextSep = &#39;;&#39;;</b>
<i>1037</i>&nbsp;            }
<b class="nc"><i>1038</i>&nbsp;            if (nextSep == &#39;&lt;&#39;)  sb.append(nextSep);</b>
<b class="nc"><i>1039</i>&nbsp;            sb.append(&#39;&gt;&#39;);</b>
<b class="nc"><i>1040</i>&nbsp;            return sb.toString();</b>
<i>1041</i>&nbsp;        }
<i>1042</i>&nbsp;        static
<i>1043</i>&nbsp;        int compareArgArrays(Entry[] a1, Entry[] a2) {
<b class="nc"><i>1044</i>&nbsp;            int x = a1.length - a2.length;</b>
<b class="nc"><i>1045</i>&nbsp;            if (x != 0)  return x;</b>
<b class="nc"><i>1046</i>&nbsp;            for (int i = 0; i &lt; a1.length; i++) {</b>
<b class="nc"><i>1047</i>&nbsp;                x = a1[i].compareTo(a2[i]);</b>
<b class="nc"><i>1048</i>&nbsp;                if (x != 0)  break;</b>
<i>1049</i>&nbsp;            }
<b class="nc"><i>1050</i>&nbsp;            return x;</b>
<i>1051</i>&nbsp;        }
<i>1052</i>&nbsp;    }
<i>1053</i>&nbsp;
<i>1054</i>&nbsp;    // Handy constants:
<b class="nc"><i>1055</i>&nbsp;    protected static final Entry[] noRefs = {};</b>
<b class="nc"><i>1056</i>&nbsp;    protected static final ClassEntry[] noClassRefs = {};</b>
<i>1057</i>&nbsp;
<i>1058</i>&nbsp;    /** An Index is a mapping between CP entries and small integers. */
<b class="nc"><i>1059</i>&nbsp;    public static final</b>
<b class="nc"><i>1060</i>&nbsp;    class Index extends AbstractList&lt;Entry&gt; {</b>
<i>1061</i>&nbsp;        protected String debugName;
<i>1062</i>&nbsp;        protected Entry[] cpMap;
<i>1063</i>&nbsp;        protected boolean flattenSigs;
<i>1064</i>&nbsp;        protected Entry[] getMap() {
<b class="nc"><i>1065</i>&nbsp;            return cpMap;</b>
<i>1066</i>&nbsp;        }
<b class="nc"><i>1067</i>&nbsp;        protected Index(String debugName) {</b>
<b class="nc"><i>1068</i>&nbsp;            this.debugName = debugName;</b>
<i>1069</i>&nbsp;        }
<i>1070</i>&nbsp;        protected Index(String debugName, Entry[] cpMap) {
<b class="nc"><i>1071</i>&nbsp;            this(debugName);</b>
<b class="nc"><i>1072</i>&nbsp;            setMap(cpMap);</b>
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;        protected void setMap(Entry[] cpMap) {
<b class="nc"><i>1075</i>&nbsp;            clearIndex();</b>
<b class="nc"><i>1076</i>&nbsp;            this.cpMap = cpMap;</b>
<i>1077</i>&nbsp;        }
<i>1078</i>&nbsp;        protected Index(String debugName, Collection&lt;Entry&gt; cpMapList) {
<b class="nc"><i>1079</i>&nbsp;            this(debugName);</b>
<b class="nc"><i>1080</i>&nbsp;            setMap(cpMapList);</b>
<i>1081</i>&nbsp;        }
<i>1082</i>&nbsp;        protected void setMap(Collection&lt;Entry&gt; cpMapList) {
<b class="nc"><i>1083</i>&nbsp;            cpMap = new Entry[cpMapList.size()];</b>
<b class="nc"><i>1084</i>&nbsp;            cpMapList.toArray(cpMap);</b>
<b class="nc"><i>1085</i>&nbsp;            setMap(cpMap);</b>
<i>1086</i>&nbsp;        }
<i>1087</i>&nbsp;        public int size() {
<b class="nc"><i>1088</i>&nbsp;            return cpMap.length;</b>
<i>1089</i>&nbsp;        }
<i>1090</i>&nbsp;        public Entry get(int i) {
<b class="nc"><i>1091</i>&nbsp;            return cpMap[i];</b>
<i>1092</i>&nbsp;        }
<i>1093</i>&nbsp;        public Entry getEntry(int i) {
<i>1094</i>&nbsp;            // same as get(), with covariant return type
<b class="nc"><i>1095</i>&nbsp;            return cpMap[i];</b>
<i>1096</i>&nbsp;        }
<i>1097</i>&nbsp;
<i>1098</i>&nbsp;        // Find index of e in cpMap, or return -1 if none.
<i>1099</i>&nbsp;        //
<i>1100</i>&nbsp;        // As a special hack, if flattenSigs, signatures are
<i>1101</i>&nbsp;        // treated as equivalent entries of cpMap.  This is wrong
<i>1102</i>&nbsp;        // from a Collection point of view, because contains()
<i>1103</i>&nbsp;        // reports true for signatures, but the iterator()
<i>1104</i>&nbsp;        // never produces them!
<i>1105</i>&nbsp;        private int findIndexOf(Entry e) {
<b class="nc"><i>1106</i>&nbsp;            if (indexKey == null) {</b>
<b class="nc"><i>1107</i>&nbsp;                initializeIndex();</b>
<i>1108</i>&nbsp;            }
<b class="nc"><i>1109</i>&nbsp;            int probe = findIndexLocation(e);</b>
<b class="nc"><i>1110</i>&nbsp;            if (indexKey[probe] != e) {</b>
<b class="nc"><i>1111</i>&nbsp;                if (flattenSigs &amp;&amp; e.tag == CONSTANT_Signature) {</b>
<b class="nc"><i>1112</i>&nbsp;                    SignatureEntry se = (SignatureEntry) e;</b>
<b class="nc"><i>1113</i>&nbsp;                    return findIndexOf(se.asUtf8Entry());</b>
<i>1114</i>&nbsp;                }
<b class="nc"><i>1115</i>&nbsp;                return -1;</b>
<i>1116</i>&nbsp;            }
<b class="nc"><i>1117</i>&nbsp;            int index = indexValue[probe];</b>
<b class="nc"><i>1118</i>&nbsp;            assert(e.equals(cpMap[index]));</b>
<b class="nc"><i>1119</i>&nbsp;            return index;</b>
<i>1120</i>&nbsp;        }
<i>1121</i>&nbsp;        public boolean contains(Entry e) {
<b class="nc"><i>1122</i>&nbsp;            return findIndexOf(e) &gt;= 0;</b>
<i>1123</i>&nbsp;        }
<i>1124</i>&nbsp;        // Find index of e in cpMap.  Should not return -1.
<i>1125</i>&nbsp;        public int indexOf(Entry e) {
<b class="nc"><i>1126</i>&nbsp;            int index = findIndexOf(e);</b>
<b class="nc"><i>1127</i>&nbsp;            if (index &lt; 0 &amp;&amp; verbose() &gt; 0) {</b>
<b class="nc"><i>1128</i>&nbsp;                System.out.println(&quot;not found: &quot;+e);</b>
<b class="nc"><i>1129</i>&nbsp;                System.out.println(&quot;       in: &quot;+this.dumpString());</b>
<b class="nc"><i>1130</i>&nbsp;                Thread.dumpStack();</b>
<i>1131</i>&nbsp;            }
<b class="nc"><i>1132</i>&nbsp;            assert(index &gt;= 0);</b>
<b class="nc"><i>1133</i>&nbsp;            return index;</b>
<i>1134</i>&nbsp;        }
<i>1135</i>&nbsp;        public int lastIndexOf(Entry e) {
<b class="nc"><i>1136</i>&nbsp;            return indexOf(e);</b>
<i>1137</i>&nbsp;        }
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;        public boolean assertIsSorted() {
<b class="nc"><i>1140</i>&nbsp;            for (int i = 1; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>1141</i>&nbsp;                if (cpMap[i-1].compareTo(cpMap[i]) &gt; 0) {</b>
<b class="nc"><i>1142</i>&nbsp;                    System.out.println(&quot;Not sorted at &quot;+(i-1)+&quot;/&quot;+i+&quot;: &quot;+this.dumpString());</b>
<b class="nc"><i>1143</i>&nbsp;                    return false;</b>
<i>1144</i>&nbsp;                }
<i>1145</i>&nbsp;            }
<b class="nc"><i>1146</i>&nbsp;            return true;</b>
<i>1147</i>&nbsp;        }
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;        // internal hash table
<i>1150</i>&nbsp;        protected Entry[] indexKey;
<i>1151</i>&nbsp;        protected int[]   indexValue;
<i>1152</i>&nbsp;        protected void clearIndex() {
<b class="nc"><i>1153</i>&nbsp;            indexKey   = null;</b>
<b class="nc"><i>1154</i>&nbsp;            indexValue = null;</b>
<i>1155</i>&nbsp;        }
<i>1156</i>&nbsp;        private int findIndexLocation(Entry e) {
<b class="nc"><i>1157</i>&nbsp;            int size   = indexKey.length;</b>
<b class="nc"><i>1158</i>&nbsp;            int hash   = e.hashCode();</b>
<b class="nc"><i>1159</i>&nbsp;            int probe  = hash &amp; (size - 1);</b>
<b class="nc"><i>1160</i>&nbsp;            int stride = ((hash &gt;&gt;&gt; 8) | 1) &amp; (size - 1);</b>
<i>1161</i>&nbsp;            for (;;) {
<b class="nc"><i>1162</i>&nbsp;                Entry e1 = indexKey[probe];</b>
<b class="nc"><i>1163</i>&nbsp;                if (e1 == e || e1 == null)</b>
<b class="nc"><i>1164</i>&nbsp;                    return probe;</b>
<b class="nc"><i>1165</i>&nbsp;                probe += stride;</b>
<b class="nc"><i>1166</i>&nbsp;                if (probe &gt;= size)  probe -= size;</b>
<b class="nc"><i>1167</i>&nbsp;            }</b>
<i>1168</i>&nbsp;        }
<i>1169</i>&nbsp;        private void initializeIndex() {
<b class="nc"><i>1170</i>&nbsp;            if (verbose() &gt; 2)</b>
<b class="nc"><i>1171</i>&nbsp;                System.out.println(&quot;initialize Index &quot;+debugName+&quot; [&quot;+size()+&quot;]&quot;);</b>
<b class="nc"><i>1172</i>&nbsp;            int hsize0 = (int)((cpMap.length + 10) * 1.5);</b>
<b class="nc"><i>1173</i>&nbsp;            int hsize = 1;</b>
<b class="nc"><i>1174</i>&nbsp;            while (hsize &lt; hsize0) {</b>
<b class="nc"><i>1175</i>&nbsp;                hsize &lt;&lt;= 1;</b>
<i>1176</i>&nbsp;            }
<b class="nc"><i>1177</i>&nbsp;            indexKey   = new Entry[hsize];</b>
<b class="nc"><i>1178</i>&nbsp;            indexValue = new int[hsize];</b>
<b class="nc"><i>1179</i>&nbsp;            for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>1180</i>&nbsp;                Entry e = cpMap[i];</b>
<b class="nc"><i>1181</i>&nbsp;                if (e == null)  continue;</b>
<b class="nc"><i>1182</i>&nbsp;                int probe = findIndexLocation(e);</b>
<b class="nc"><i>1183</i>&nbsp;                assert(indexKey[probe] == null);  // e has unique index</b>
<b class="nc"><i>1184</i>&nbsp;                indexKey[probe] = e;</b>
<b class="nc"><i>1185</i>&nbsp;                indexValue[probe] = i;</b>
<i>1186</i>&nbsp;            }
<i>1187</i>&nbsp;        }
<i>1188</i>&nbsp;        public Entry[] toArray(Entry[] a) {
<b class="nc"><i>1189</i>&nbsp;            int sz = size();</b>
<b class="nc"><i>1190</i>&nbsp;            if (a.length &lt; sz)  return super.toArray(a);</b>
<b class="nc"><i>1191</i>&nbsp;            System.arraycopy(cpMap, 0, a, 0, sz);</b>
<b class="nc"><i>1192</i>&nbsp;            if (a.length &gt; sz)  a[sz] = null;</b>
<b class="nc"><i>1193</i>&nbsp;            return a;</b>
<i>1194</i>&nbsp;        }
<i>1195</i>&nbsp;        public Entry[] toArray() {
<b class="nc"><i>1196</i>&nbsp;            return toArray(new Entry[size()]);</b>
<i>1197</i>&nbsp;        }
<i>1198</i>&nbsp;        public Object clone() {
<b class="nc"><i>1199</i>&nbsp;            return new Index(debugName, cpMap.clone());</b>
<i>1200</i>&nbsp;        }
<i>1201</i>&nbsp;        public String toString() {
<b class="nc"><i>1202</i>&nbsp;            return &quot;Index &quot;+debugName+&quot; [&quot;+size()+&quot;]&quot;;</b>
<i>1203</i>&nbsp;        }
<i>1204</i>&nbsp;        public String dumpString() {
<b class="nc"><i>1205</i>&nbsp;            String s = toString();</b>
<b class="nc"><i>1206</i>&nbsp;            s += &quot; {\n&quot;;</b>
<b class="nc"><i>1207</i>&nbsp;            for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>1208</i>&nbsp;                s += &quot;    &quot;+i+&quot;: &quot;+cpMap[i]+&quot;\n&quot;;</b>
<i>1209</i>&nbsp;            }
<b class="nc"><i>1210</i>&nbsp;            s += &quot;}&quot;;</b>
<b class="nc"><i>1211</i>&nbsp;            return s;</b>
<i>1212</i>&nbsp;        }
<i>1213</i>&nbsp;    }
<i>1214</i>&nbsp;
<i>1215</i>&nbsp;    // Index methods.
<i>1216</i>&nbsp;
<i>1217</i>&nbsp;    public static
<i>1218</i>&nbsp;    Index makeIndex(String debugName, Entry[] cpMap) {
<b class="nc"><i>1219</i>&nbsp;        return new Index(debugName, cpMap);</b>
<i>1220</i>&nbsp;    }
<i>1221</i>&nbsp;
<i>1222</i>&nbsp;    public static
<i>1223</i>&nbsp;    Index makeIndex(String debugName, Collection&lt;Entry&gt; cpMapList) {
<b class="nc"><i>1224</i>&nbsp;        return new Index(debugName, cpMapList);</b>
<i>1225</i>&nbsp;    }
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;    /** Sort this index (destructively) into canonical order. */
<i>1228</i>&nbsp;    public static
<i>1229</i>&nbsp;    void sort(Index ix) {
<i>1230</i>&nbsp;        // %%% Should move this into class Index.
<b class="nc"><i>1231</i>&nbsp;        ix.clearIndex();</b>
<b class="nc"><i>1232</i>&nbsp;        Arrays.sort(ix.cpMap);</b>
<b class="nc"><i>1233</i>&nbsp;        if (verbose() &gt; 2)</b>
<b class="nc"><i>1234</i>&nbsp;            System.out.println(&quot;sorted &quot;+ix.dumpString());</b>
<i>1235</i>&nbsp;    }
<i>1236</i>&nbsp;
<i>1237</i>&nbsp;    /** Return a set of indexes partitioning these entries.
<i>1238</i>&nbsp;     *  The keys array must of length this.size(), and marks entries.
<i>1239</i>&nbsp;     *  The result array is as long as one plus the largest key value.
<i>1240</i>&nbsp;     *  Entries with a negative key are dropped from the partition.
<i>1241</i>&nbsp;     */
<i>1242</i>&nbsp;    public static
<i>1243</i>&nbsp;    Index[] partition(Index ix, int[] keys) {
<i>1244</i>&nbsp;        // %%% Should move this into class Index.
<b class="nc"><i>1245</i>&nbsp;        List&lt;List&lt;Entry&gt;&gt; parts = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>1246</i>&nbsp;        Entry[] cpMap = ix.cpMap;</b>
<b class="nc"><i>1247</i>&nbsp;        assert(keys.length == cpMap.length);</b>
<b class="nc"><i>1248</i>&nbsp;        for (int i = 0; i &lt; keys.length; i++) {</b>
<b class="nc"><i>1249</i>&nbsp;            int key = keys[i];</b>
<b class="nc"><i>1250</i>&nbsp;            if (key &lt; 0)  continue;</b>
<b class="nc"><i>1251</i>&nbsp;            while (key &gt;= parts.size()) {</b>
<b class="nc"><i>1252</i>&nbsp;                parts.add(null);</b>
<i>1253</i>&nbsp;            }
<b class="nc"><i>1254</i>&nbsp;            List&lt;Entry&gt; part = parts.get(key);</b>
<b class="nc"><i>1255</i>&nbsp;            if (part == null) {</b>
<b class="nc"><i>1256</i>&nbsp;                parts.set(key, part = new ArrayList&lt;&gt;());</b>
<i>1257</i>&nbsp;            }
<b class="nc"><i>1258</i>&nbsp;            part.add(cpMap[i]);</b>
<i>1259</i>&nbsp;        }
<b class="nc"><i>1260</i>&nbsp;        Index[] indexes = new Index[parts.size()];</b>
<b class="nc"><i>1261</i>&nbsp;        for (int key = 0; key &lt; indexes.length; key++) {</b>
<b class="nc"><i>1262</i>&nbsp;            List&lt;Entry&gt; part = parts.get(key);</b>
<b class="nc"><i>1263</i>&nbsp;            if (part == null)  continue;</b>
<b class="nc"><i>1264</i>&nbsp;            indexes[key] = new Index(ix.debugName+&quot;/part#&quot;+key, part);</b>
<b class="nc"><i>1265</i>&nbsp;            assert(indexes[key].indexOf(part.get(0)) == 0);</b>
<i>1266</i>&nbsp;        }
<b class="nc"><i>1267</i>&nbsp;        return indexes;</b>
<i>1268</i>&nbsp;    }
<i>1269</i>&nbsp;    public static
<i>1270</i>&nbsp;    Index[] partitionByTag(Index ix) {
<i>1271</i>&nbsp;        // Partition by tag.
<b class="nc"><i>1272</i>&nbsp;        Entry[] cpMap = ix.cpMap;</b>
<b class="nc"><i>1273</i>&nbsp;        int[] keys = new int[cpMap.length];</b>
<b class="nc"><i>1274</i>&nbsp;        for (int i = 0; i &lt; keys.length; i++) {</b>
<b class="nc"><i>1275</i>&nbsp;            Entry e = cpMap[i];</b>
<b class="nc"><i>1276</i>&nbsp;            keys[i] = (e == null)? -1: e.tag;</b>
<i>1277</i>&nbsp;        }
<b class="nc"><i>1278</i>&nbsp;        Index[] byTag = partition(ix, keys);</b>
<b class="nc"><i>1279</i>&nbsp;        for (int tag = 0; tag &lt; byTag.length; tag++) {</b>
<b class="nc"><i>1280</i>&nbsp;            if (byTag[tag] == null)  continue;</b>
<b class="nc"><i>1281</i>&nbsp;            byTag[tag].debugName = tagName(tag);</b>
<i>1282</i>&nbsp;        }
<b class="nc"><i>1283</i>&nbsp;        if (byTag.length &lt; CONSTANT_Limit) {</b>
<b class="nc"><i>1284</i>&nbsp;            Index[] longer = new Index[CONSTANT_Limit];</b>
<b class="nc"><i>1285</i>&nbsp;            System.arraycopy(byTag, 0, longer, 0, byTag.length);</b>
<b class="nc"><i>1286</i>&nbsp;            byTag = longer;</b>
<i>1287</i>&nbsp;        }
<b class="nc"><i>1288</i>&nbsp;        return byTag;</b>
<i>1289</i>&nbsp;    }
<i>1290</i>&nbsp;
<i>1291</i>&nbsp;    /** Coherent group of constant pool indexes. */
<b class="nc"><i>1292</i>&nbsp;    public static</b>
<b class="nc"><i>1293</i>&nbsp;    class IndexGroup {</b>
<b class="nc"><i>1294</i>&nbsp;        private Index[] indexByTag = new Index[CONSTANT_Limit];</b>
<i>1295</i>&nbsp;        private Index[] indexByTagGroup;
<i>1296</i>&nbsp;        private int[]   untypedFirstIndexByTag;
<i>1297</i>&nbsp;        private int     totalSizeQQ;
<i>1298</i>&nbsp;        private Index[][] indexByTagAndClass;
<i>1299</i>&nbsp;
<i>1300</i>&nbsp;        /** Index of all CP entries of all types, in definition order. */
<i>1301</i>&nbsp;        private Index makeTagGroupIndex(byte tagGroupTag, byte[] tagsInGroup) {
<b class="nc"><i>1302</i>&nbsp;            if (indexByTagGroup == null)</b>
<b class="nc"><i>1303</i>&nbsp;                indexByTagGroup = new Index[CONSTANT_GroupLimit - CONSTANT_GroupFirst];</b>
<b class="nc"><i>1304</i>&nbsp;            int which = tagGroupTag - CONSTANT_GroupFirst;</b>
<b class="nc"><i>1305</i>&nbsp;            assert(indexByTagGroup[which] == null);</b>
<b class="nc"><i>1306</i>&nbsp;            int fillp = 0;</b>
<b class="nc"><i>1307</i>&nbsp;            Entry[] cpMap = null;</b>
<b class="nc"><i>1308</i>&nbsp;            for (int pass = 1; pass &lt;= 2; pass++) {</b>
<b class="nc"><i>1309</i>&nbsp;                untypedIndexOf(null);  // warm up untypedFirstIndexByTag</b>
<b class="nc"><i>1310</i>&nbsp;                for (byte tag : tagsInGroup) {</b>
<b class="nc"><i>1311</i>&nbsp;                    Index ix = indexByTag[tag];</b>
<b class="nc"><i>1312</i>&nbsp;                    if (ix == null)  continue;</b>
<b class="nc"><i>1313</i>&nbsp;                    int ixLen = ix.cpMap.length;</b>
<b class="nc"><i>1314</i>&nbsp;                    if (ixLen == 0)  continue;</b>
<b class="nc"><i>1315</i>&nbsp;                    assert(tagGroupTag == CONSTANT_All</b>
<i>1316</i>&nbsp;                            ? fillp == untypedFirstIndexByTag[tag]
<i>1317</i>&nbsp;                            : fillp  &lt; untypedFirstIndexByTag[tag]);
<b class="nc"><i>1318</i>&nbsp;                    if (cpMap != null) {</b>
<b class="nc"><i>1319</i>&nbsp;                        assert(cpMap[fillp] == null);</b>
<b class="nc"><i>1320</i>&nbsp;                        assert(cpMap[fillp+ixLen-1] == null);</b>
<b class="nc"><i>1321</i>&nbsp;                        System.arraycopy(ix.cpMap, 0, cpMap, fillp, ixLen);</b>
<i>1322</i>&nbsp;                    }
<b class="nc"><i>1323</i>&nbsp;                    fillp += ixLen;</b>
<i>1324</i>&nbsp;                }
<b class="nc"><i>1325</i>&nbsp;                if (cpMap == null) {</b>
<b class="nc"><i>1326</i>&nbsp;                    assert(pass == 1);</b>
<i>1327</i>&nbsp;                    // get ready for pass 2
<b class="nc"><i>1328</i>&nbsp;                    cpMap = new Entry[fillp];</b>
<b class="nc"><i>1329</i>&nbsp;                    fillp = 0;</b>
<i>1330</i>&nbsp;                }
<i>1331</i>&nbsp;            }
<b class="nc"><i>1332</i>&nbsp;            indexByTagGroup[which] = new Index(tagName(tagGroupTag), cpMap);</b>
<b class="nc"><i>1333</i>&nbsp;            return indexByTagGroup[which];</b>
<i>1334</i>&nbsp;        }
<i>1335</i>&nbsp;
<i>1336</i>&nbsp;        public int untypedIndexOf(Entry e) {
<b class="nc"><i>1337</i>&nbsp;            if (untypedFirstIndexByTag == null) {</b>
<b class="nc"><i>1338</i>&nbsp;                untypedFirstIndexByTag = new int[CONSTANT_Limit+1];</b>
<b class="nc"><i>1339</i>&nbsp;                int fillp = 0;</b>
<b class="nc"><i>1340</i>&nbsp;                for (int i = 0; i &lt; TAGS_IN_ORDER.length; i++) {</b>
<b class="nc"><i>1341</i>&nbsp;                    byte tag = TAGS_IN_ORDER[i];</b>
<b class="nc"><i>1342</i>&nbsp;                    Index ix = indexByTag[tag];</b>
<b class="nc"><i>1343</i>&nbsp;                    if (ix == null)  continue;</b>
<b class="nc"><i>1344</i>&nbsp;                    int ixLen = ix.cpMap.length;</b>
<b class="nc"><i>1345</i>&nbsp;                    untypedFirstIndexByTag[tag] = fillp;</b>
<b class="nc"><i>1346</i>&nbsp;                    fillp += ixLen;</b>
<i>1347</i>&nbsp;                }
<b class="nc"><i>1348</i>&nbsp;                untypedFirstIndexByTag[CONSTANT_Limit] = fillp;</b>
<i>1349</i>&nbsp;            }
<b class="nc"><i>1350</i>&nbsp;            if (e == null)  return -1;</b>
<b class="nc"><i>1351</i>&nbsp;            int tag = e.tag;</b>
<b class="nc"><i>1352</i>&nbsp;            Index ix = indexByTag[tag];</b>
<b class="nc"><i>1353</i>&nbsp;            if (ix == null)  return -1;</b>
<b class="nc"><i>1354</i>&nbsp;            int idx = ix.findIndexOf(e);</b>
<b class="nc"><i>1355</i>&nbsp;            if (idx &gt;= 0)</b>
<b class="nc"><i>1356</i>&nbsp;                idx += untypedFirstIndexByTag[tag];</b>
<b class="nc"><i>1357</i>&nbsp;            return idx;</b>
<i>1358</i>&nbsp;        }
<i>1359</i>&nbsp;
<i>1360</i>&nbsp;        public void initIndexByTag(byte tag, Index ix) {
<b class="nc"><i>1361</i>&nbsp;            assert(indexByTag[tag] == null);  // do not init twice</b>
<b class="nc"><i>1362</i>&nbsp;            Entry[] cpMap = ix.cpMap;</b>
<b class="nc"><i>1363</i>&nbsp;            for (int i = 0; i &lt; cpMap.length; i++) {</b>
<i>1364</i>&nbsp;                // It must be a homogeneous Entry set.
<b class="nc"><i>1365</i>&nbsp;                assert(cpMap[i].tag == tag);</b>
<i>1366</i>&nbsp;            }
<b class="nc"><i>1367</i>&nbsp;            if (tag == CONSTANT_Utf8) {</b>
<i>1368</i>&nbsp;                // Special case:  First Utf8 must always be empty string.
<b class="nc"><i>1369</i>&nbsp;                assert(cpMap.length == 0 || cpMap[0].stringValue().equals(&quot;&quot;));</b>
<i>1370</i>&nbsp;            }
<b class="nc"><i>1371</i>&nbsp;            indexByTag[tag] = ix;</b>
<i>1372</i>&nbsp;            // decache indexes derived from this one:
<b class="nc"><i>1373</i>&nbsp;            untypedFirstIndexByTag = null;</b>
<b class="nc"><i>1374</i>&nbsp;            indexByTagGroup = null;</b>
<b class="nc"><i>1375</i>&nbsp;            if (indexByTagAndClass != null)</b>
<b class="nc"><i>1376</i>&nbsp;                indexByTagAndClass[tag] = null;</b>
<i>1377</i>&nbsp;        }
<i>1378</i>&nbsp;
<i>1379</i>&nbsp;        /** Index of all CP entries of a given tag. */
<i>1380</i>&nbsp;        public Index getIndexByTag(byte tag) {
<b class="nc"><i>1381</i>&nbsp;            if (tag &gt;= CONSTANT_GroupFirst)</b>
<b class="nc"><i>1382</i>&nbsp;                return getIndexByTagGroup(tag);</b>
<b class="nc"><i>1383</i>&nbsp;            Index ix = indexByTag[tag];</b>
<b class="nc"><i>1384</i>&nbsp;            if (ix == null) {</b>
<i>1385</i>&nbsp;                // Make an empty one by default.
<b class="nc"><i>1386</i>&nbsp;                ix = new Index(tagName(tag), new Entry[0]);</b>
<b class="nc"><i>1387</i>&nbsp;                indexByTag[tag] = ix;</b>
<i>1388</i>&nbsp;            }
<b class="nc"><i>1389</i>&nbsp;            return ix;</b>
<i>1390</i>&nbsp;        }
<i>1391</i>&nbsp;
<i>1392</i>&nbsp;        private Index getIndexByTagGroup(byte tag) {
<i>1393</i>&nbsp;            // pool groups:
<b class="nc"><i>1394</i>&nbsp;            if (indexByTagGroup != null) {</b>
<b class="nc"><i>1395</i>&nbsp;                Index ix = indexByTagGroup[tag - CONSTANT_GroupFirst];</b>
<b class="nc"><i>1396</i>&nbsp;                if (ix != null)  return ix;</b>
<i>1397</i>&nbsp;            }
<b class="nc"><i>1398</i>&nbsp;            switch (tag) {</b>
<i>1399</i>&nbsp;            case CONSTANT_All:
<b class="nc"><i>1400</i>&nbsp;                return makeTagGroupIndex(CONSTANT_All, TAGS_IN_ORDER);</b>
<i>1401</i>&nbsp;            case CONSTANT_LoadableValue:
<b class="nc"><i>1402</i>&nbsp;                    return makeTagGroupIndex(CONSTANT_LoadableValue, LOADABLE_VALUE_TAGS);</b>
<i>1403</i>&nbsp;            case CONSTANT_AnyMember:
<b class="nc"><i>1404</i>&nbsp;                return makeTagGroupIndex(CONSTANT_AnyMember, ANY_MEMBER_TAGS);</b>
<i>1405</i>&nbsp;            case CONSTANT_FieldSpecific:
<i>1406</i>&nbsp;                // This one does not have any fixed index, since it is context-specific.
<b class="nc"><i>1407</i>&nbsp;                return null;</b>
<i>1408</i>&nbsp;            }
<b class="nc"><i>1409</i>&nbsp;            throw new AssertionError(&quot;bad tag group &quot;+tag);</b>
<i>1410</i>&nbsp;        }
<i>1411</i>&nbsp;
<i>1412</i>&nbsp;        /** Index of all CP entries of a given tag and class. */
<i>1413</i>&nbsp;        public Index getMemberIndex(byte tag, ClassEntry classRef) {
<b class="nc"><i>1414</i>&nbsp;            if (classRef == null)</b>
<b class="nc"><i>1415</i>&nbsp;                throw new RuntimeException(&quot;missing class reference for &quot; + tagName(tag));</b>
<b class="nc"><i>1416</i>&nbsp;            if (indexByTagAndClass == null)</b>
<b class="nc"><i>1417</i>&nbsp;                indexByTagAndClass = new Index[CONSTANT_Limit][];</b>
<b class="nc"><i>1418</i>&nbsp;            Index allClasses =  getIndexByTag(CONSTANT_Class);</b>
<b class="nc"><i>1419</i>&nbsp;            Index[] perClassIndexes = indexByTagAndClass[tag];</b>
<b class="nc"><i>1420</i>&nbsp;            if (perClassIndexes == null) {</b>
<i>1421</i>&nbsp;                // Create the partition now.
<i>1422</i>&nbsp;                // Divide up all entries of the given tag according to their class.
<b class="nc"><i>1423</i>&nbsp;                Index allMembers = getIndexByTag(tag);</b>
<b class="nc"><i>1424</i>&nbsp;                int[] whichClasses = new int[allMembers.size()];</b>
<b class="nc"><i>1425</i>&nbsp;                for (int i = 0; i &lt; whichClasses.length; i++) {</b>
<b class="nc"><i>1426</i>&nbsp;                    MemberEntry e = (MemberEntry) allMembers.get(i);</b>
<b class="nc"><i>1427</i>&nbsp;                    int whichClass = allClasses.indexOf(e.classRef);</b>
<b class="nc"><i>1428</i>&nbsp;                    whichClasses[i] = whichClass;</b>
<i>1429</i>&nbsp;                }
<b class="nc"><i>1430</i>&nbsp;                perClassIndexes = partition(allMembers, whichClasses);</b>
<b class="nc"><i>1431</i>&nbsp;                for (int i = 0; i &lt; perClassIndexes.length; i++) {</b>
<b class="nc"><i>1432</i>&nbsp;                    assert (perClassIndexes[i] == null ||</b>
<b class="nc"><i>1433</i>&nbsp;                            perClassIndexes[i].assertIsSorted());</b>
<i>1434</i>&nbsp;                }
<b class="nc"><i>1435</i>&nbsp;                indexByTagAndClass[tag] = perClassIndexes;</b>
<i>1436</i>&nbsp;            }
<b class="nc"><i>1437</i>&nbsp;            int whichClass = allClasses.indexOf(classRef);</b>
<b class="nc"><i>1438</i>&nbsp;            return perClassIndexes[whichClass];</b>
<i>1439</i>&nbsp;        }
<i>1440</i>&nbsp;
<i>1441</i>&nbsp;        // Given the sequence of all methods of the given name and class,
<i>1442</i>&nbsp;        // produce the ordinal of this particular given overloading.
<i>1443</i>&nbsp;        public int getOverloadingIndex(MemberEntry methodRef) {
<b class="nc"><i>1444</i>&nbsp;            Index ix = getMemberIndex(methodRef.tag, methodRef.classRef);</b>
<b class="nc"><i>1445</i>&nbsp;            Utf8Entry nameRef = methodRef.descRef.nameRef;</b>
<b class="nc"><i>1446</i>&nbsp;            int ord = 0;</b>
<b class="nc"><i>1447</i>&nbsp;            for (int i = 0; i &lt; ix.cpMap.length; i++) {</b>
<b class="nc"><i>1448</i>&nbsp;                MemberEntry e = (MemberEntry) ix.cpMap[i];</b>
<b class="nc"><i>1449</i>&nbsp;                if (e.equals(methodRef))</b>
<b class="nc"><i>1450</i>&nbsp;                    return ord;</b>
<b class="nc"><i>1451</i>&nbsp;                if (e.descRef.nameRef.equals(nameRef))</b>
<i>1452</i>&nbsp;                    // Found a different overloading.  Increment the ordinal.
<b class="nc"><i>1453</i>&nbsp;                    ord++;</b>
<i>1454</i>&nbsp;            }
<b class="nc"><i>1455</i>&nbsp;            throw new RuntimeException(&quot;should not reach here&quot;);</b>
<i>1456</i>&nbsp;        }
<i>1457</i>&nbsp;
<i>1458</i>&nbsp;        // Inverse of getOverloadingIndex
<i>1459</i>&nbsp;        public MemberEntry getOverloadingForIndex(byte tag, ClassEntry classRef, String name, int which) {
<b class="nc"><i>1460</i>&nbsp;            assert(name.equals(name.intern()));</b>
<b class="nc"><i>1461</i>&nbsp;            Index ix = getMemberIndex(tag, classRef);</b>
<b class="nc"><i>1462</i>&nbsp;            int ord = 0;</b>
<b class="nc"><i>1463</i>&nbsp;            for (int i = 0; i &lt; ix.cpMap.length; i++) {</b>
<b class="nc"><i>1464</i>&nbsp;                MemberEntry e = (MemberEntry) ix.cpMap[i];</b>
<b class="nc"><i>1465</i>&nbsp;                if (e.descRef.nameRef.stringValue().equals(name)) {</b>
<b class="nc"><i>1466</i>&nbsp;                    if (ord == which)  return e;</b>
<b class="nc"><i>1467</i>&nbsp;                    ord++;</b>
<i>1468</i>&nbsp;                }
<i>1469</i>&nbsp;            }
<b class="nc"><i>1470</i>&nbsp;            throw new RuntimeException(&quot;should not reach here&quot;);</b>
<i>1471</i>&nbsp;        }
<i>1472</i>&nbsp;
<i>1473</i>&nbsp;        public boolean haveNumbers() {
<b class="nc"><i>1474</i>&nbsp;            for (byte tag : NUMBER_TAGS) {</b>
<b class="nc"><i>1475</i>&nbsp;                if (getIndexByTag(tag).size() &gt; 0)  return true;</b>
<i>1476</i>&nbsp;            }
<b class="nc"><i>1477</i>&nbsp;            return false;</b>
<i>1478</i>&nbsp;        }
<i>1479</i>&nbsp;
<i>1480</i>&nbsp;        public boolean haveExtraTags() {
<b class="nc"><i>1481</i>&nbsp;            for (byte tag : EXTRA_TAGS) {</b>
<b class="nc"><i>1482</i>&nbsp;                if (getIndexByTag(tag).size() &gt; 0)  return true;</b>
<i>1483</i>&nbsp;            }
<b class="nc"><i>1484</i>&nbsp;            return false;</b>
<i>1485</i>&nbsp;        }
<i>1486</i>&nbsp;
<i>1487</i>&nbsp;    }
<i>1488</i>&nbsp;
<i>1489</i>&nbsp;    /** Close the set cpRefs under the getRef(*) relation.
<i>1490</i>&nbsp;     *  Also, if flattenSigs, replace all signatures in cpRefs
<i>1491</i>&nbsp;     *  by their equivalent Utf8s.
<i>1492</i>&nbsp;     *  Also, discard null from cpRefs.
<i>1493</i>&nbsp;     */
<i>1494</i>&nbsp;    public static void completeReferencesIn(Set&lt;Entry&gt; cpRefs, boolean flattenSigs) {
<b class="nc"><i>1495</i>&nbsp;         completeReferencesIn(cpRefs, flattenSigs, null);</b>
<i>1496</i>&nbsp;    }
<i>1497</i>&nbsp;
<i>1498</i>&nbsp;    public static
<i>1499</i>&nbsp;    void completeReferencesIn(Set&lt;Entry&gt; cpRefs, boolean flattenSigs,
<i>1500</i>&nbsp;                              List&lt;BootstrapMethodEntry&gt;bsms) {
<b class="nc"><i>1501</i>&nbsp;        cpRefs.remove(null);</b>
<b class="nc"><i>1502</i>&nbsp;        for (ListIterator&lt;Entry&gt; work =</b>
<b class="nc"><i>1503</i>&nbsp;                 new ArrayList&lt;&gt;(cpRefs).listIterator(cpRefs.size());</b>
<b class="nc"><i>1504</i>&nbsp;             work.hasPrevious(); ) {</b>
<b class="nc"><i>1505</i>&nbsp;            Entry e = work.previous();</b>
<b class="nc"><i>1506</i>&nbsp;            work.remove();          // pop stack</b>
<b class="nc"><i>1507</i>&nbsp;            assert(e != null);</b>
<b class="nc"><i>1508</i>&nbsp;            if (flattenSigs &amp;&amp; e.tag == CONSTANT_Signature) {</b>
<b class="nc"><i>1509</i>&nbsp;                SignatureEntry se = (SignatureEntry) e;</b>
<b class="nc"><i>1510</i>&nbsp;                Utf8Entry      ue = se.asUtf8Entry();</b>
<i>1511</i>&nbsp;                // Totally replace e by se.
<b class="nc"><i>1512</i>&nbsp;                cpRefs.remove(se);</b>
<b class="nc"><i>1513</i>&nbsp;                cpRefs.add(ue);</b>
<b class="nc"><i>1514</i>&nbsp;                e = ue;   // do not descend into the sig</b>
<i>1515</i>&nbsp;            }
<b class="nc"><i>1516</i>&nbsp;            if (bsms != null &amp;&amp; e.tag == CONSTANT_BootstrapMethod) {</b>
<b class="nc"><i>1517</i>&nbsp;                BootstrapMethodEntry bsm = (BootstrapMethodEntry)e;</b>
<b class="nc"><i>1518</i>&nbsp;                cpRefs.remove(bsm);</b>
<i>1519</i>&nbsp;                // move it away to the side table where it belongs
<b class="nc"><i>1520</i>&nbsp;                if (!bsms.contains(bsm))</b>
<b class="nc"><i>1521</i>&nbsp;                    bsms.add(bsm);</b>
<i>1522</i>&nbsp;                // fall through to recursively add refs for this entry
<i>1523</i>&nbsp;            }
<i>1524</i>&nbsp;            // Recursively add the refs of e to cpRefs:
<b class="nc"><i>1525</i>&nbsp;            for (int i = 0; ; i++) {</b>
<b class="nc"><i>1526</i>&nbsp;                Entry re = e.getRef(i);</b>
<b class="nc"><i>1527</i>&nbsp;                if (re == null)</b>
<b class="nc"><i>1528</i>&nbsp;                    break;          // no more refs in e</b>
<b class="nc"><i>1529</i>&nbsp;                if (cpRefs.add(re)) // output the ref</b>
<b class="nc"><i>1530</i>&nbsp;                    work.add(re);   // push stack, if a new ref</b>
<i>1531</i>&nbsp;            }
<b class="nc"><i>1532</i>&nbsp;        }</b>
<i>1533</i>&nbsp;    }
<i>1534</i>&nbsp;
<i>1535</i>&nbsp;    static double percent(int num, int den) {
<b class="nc"><i>1536</i>&nbsp;        return (int)((10000.0*num)/den + 0.5) / 100.0;</b>
<i>1537</i>&nbsp;    }
<i>1538</i>&nbsp;
<i>1539</i>&nbsp;    public static String tagName(int tag) {
<b class="nc"><i>1540</i>&nbsp;        switch (tag) {</b>
<b class="nc"><i>1541</i>&nbsp;            case CONSTANT_Utf8:                 return &quot;Utf8&quot;;</b>
<b class="nc"><i>1542</i>&nbsp;            case CONSTANT_Integer:              return &quot;Integer&quot;;</b>
<b class="nc"><i>1543</i>&nbsp;            case CONSTANT_Float:                return &quot;Float&quot;;</b>
<b class="nc"><i>1544</i>&nbsp;            case CONSTANT_Long:                 return &quot;Long&quot;;</b>
<b class="nc"><i>1545</i>&nbsp;            case CONSTANT_Double:               return &quot;Double&quot;;</b>
<b class="nc"><i>1546</i>&nbsp;            case CONSTANT_Class:                return &quot;Class&quot;;</b>
<b class="nc"><i>1547</i>&nbsp;            case CONSTANT_String:               return &quot;String&quot;;</b>
<b class="nc"><i>1548</i>&nbsp;            case CONSTANT_Fieldref:             return &quot;Fieldref&quot;;</b>
<b class="nc"><i>1549</i>&nbsp;            case CONSTANT_Methodref:            return &quot;Methodref&quot;;</b>
<b class="nc"><i>1550</i>&nbsp;            case CONSTANT_InterfaceMethodref:   return &quot;InterfaceMethodref&quot;;</b>
<b class="nc"><i>1551</i>&nbsp;            case CONSTANT_NameandType:          return &quot;NameandType&quot;;</b>
<b class="nc"><i>1552</i>&nbsp;            case CONSTANT_MethodHandle:         return &quot;MethodHandle&quot;;</b>
<b class="nc"><i>1553</i>&nbsp;            case CONSTANT_MethodType:           return &quot;MethodType&quot;;</b>
<b class="nc"><i>1554</i>&nbsp;            case CONSTANT_InvokeDynamic:        return &quot;InvokeDynamic&quot;;</b>
<i>1555</i>&nbsp;
<i>1556</i>&nbsp;                // pseudo-tags:
<b class="nc"><i>1557</i>&nbsp;            case CONSTANT_All:                  return &quot;**All&quot;;</b>
<b class="nc"><i>1558</i>&nbsp;            case CONSTANT_None:                 return &quot;**None&quot;;</b>
<b class="nc"><i>1559</i>&nbsp;            case CONSTANT_LoadableValue:        return &quot;**LoadableValue&quot;;</b>
<b class="nc"><i>1560</i>&nbsp;            case CONSTANT_AnyMember:            return &quot;**AnyMember&quot;;</b>
<b class="nc"><i>1561</i>&nbsp;            case CONSTANT_FieldSpecific:        return &quot;*FieldSpecific&quot;;</b>
<b class="nc"><i>1562</i>&nbsp;            case CONSTANT_Signature:            return &quot;*Signature&quot;;</b>
<b class="nc"><i>1563</i>&nbsp;            case CONSTANT_BootstrapMethod:      return &quot;*BootstrapMethod&quot;;</b>
<i>1564</i>&nbsp;        }
<b class="nc"><i>1565</i>&nbsp;        return &quot;tag#&quot;+tag;</b>
<i>1566</i>&nbsp;    }
<i>1567</i>&nbsp;
<i>1568</i>&nbsp;    public static String refKindName(int refKind) {
<b class="nc"><i>1569</i>&nbsp;        switch (refKind) {</b>
<b class="nc"><i>1570</i>&nbsp;            case REF_getField:                  return &quot;getField&quot;;</b>
<b class="nc"><i>1571</i>&nbsp;            case REF_getStatic:                 return &quot;getStatic&quot;;</b>
<b class="nc"><i>1572</i>&nbsp;            case REF_putField:                  return &quot;putField&quot;;</b>
<b class="nc"><i>1573</i>&nbsp;            case REF_putStatic:                 return &quot;putStatic&quot;;</b>
<b class="nc"><i>1574</i>&nbsp;            case REF_invokeVirtual:             return &quot;invokeVirtual&quot;;</b>
<b class="nc"><i>1575</i>&nbsp;            case REF_invokeStatic:              return &quot;invokeStatic&quot;;</b>
<b class="nc"><i>1576</i>&nbsp;            case REF_invokeSpecial:             return &quot;invokeSpecial&quot;;</b>
<b class="nc"><i>1577</i>&nbsp;            case REF_newInvokeSpecial:          return &quot;newInvokeSpecial&quot;;</b>
<b class="nc"><i>1578</i>&nbsp;            case REF_invokeInterface:           return &quot;invokeInterface&quot;;</b>
<i>1579</i>&nbsp;        }
<b class="nc"><i>1580</i>&nbsp;        return &quot;refKind#&quot;+refKind;</b>
<i>1581</i>&nbsp;    }
<i>1582</i>&nbsp;
<i>1583</i>&nbsp;    // archive constant pool definition order
<b class="nc"><i>1584</i>&nbsp;    static final byte TAGS_IN_ORDER[] = {</b>
<i>1585</i>&nbsp;        CONSTANT_Utf8,
<i>1586</i>&nbsp;        CONSTANT_Integer,           // cp_Int
<i>1587</i>&nbsp;        CONSTANT_Float,
<i>1588</i>&nbsp;        CONSTANT_Long,
<i>1589</i>&nbsp;        CONSTANT_Double,
<i>1590</i>&nbsp;        CONSTANT_String,            // note that String=8 precedes Class=7
<i>1591</i>&nbsp;        CONSTANT_Class,
<i>1592</i>&nbsp;        CONSTANT_Signature,
<i>1593</i>&nbsp;        CONSTANT_NameandType,       // cp_Descr
<i>1594</i>&nbsp;        CONSTANT_Fieldref,          // cp_Field
<i>1595</i>&nbsp;        CONSTANT_Methodref,         // cp_Method
<i>1596</i>&nbsp;        CONSTANT_InterfaceMethodref, // cp_Imethod
<i>1597</i>&nbsp;
<i>1598</i>&nbsp;        // Constants defined in JDK 7 and later:
<i>1599</i>&nbsp;        CONSTANT_MethodHandle,
<i>1600</i>&nbsp;        CONSTANT_MethodType,
<i>1601</i>&nbsp;        CONSTANT_BootstrapMethod,  // pseudo-tag, really stored in a class attribute
<i>1602</i>&nbsp;        CONSTANT_InvokeDynamic
<i>1603</i>&nbsp;    };
<i>1604</i>&nbsp;    static final byte TAG_ORDER[];
<i>1605</i>&nbsp;    static {
<b class="nc"><i>1606</i>&nbsp;        TAG_ORDER = new byte[CONSTANT_Limit];</b>
<b class="nc"><i>1607</i>&nbsp;        for (int i = 0; i &lt; TAGS_IN_ORDER.length; i++) {</b>
<b class="nc"><i>1608</i>&nbsp;            TAG_ORDER[TAGS_IN_ORDER[i]] = (byte)(i+1);</b>
<i>1609</i>&nbsp;        }
<i>1610</i>&nbsp;        /*
<i>1611</i>&nbsp;        System.out.println(&quot;TAG_ORDER[] = {&quot;);
<i>1612</i>&nbsp;        for (int i = 0; i &lt; TAG_ORDER.length; i++)
<i>1613</i>&nbsp;            System.out.println(&quot;  &quot;+TAG_ORDER[i]+&quot;,&quot;);
<i>1614</i>&nbsp;        System.out.println(&quot;};&quot;);
<i>1615</i>&nbsp;        */
<i>1616</i>&nbsp;    }
<b class="nc"><i>1617</i>&nbsp;    static final byte[] NUMBER_TAGS = {</b>
<i>1618</i>&nbsp;        CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long, CONSTANT_Double
<i>1619</i>&nbsp;    };
<b class="nc"><i>1620</i>&nbsp;    static final byte[] EXTRA_TAGS = {</b>
<i>1621</i>&nbsp;        CONSTANT_MethodHandle, CONSTANT_MethodType,
<i>1622</i>&nbsp;        CONSTANT_BootstrapMethod, // pseudo-tag
<i>1623</i>&nbsp;        CONSTANT_InvokeDynamic
<i>1624</i>&nbsp;    };
<b class="nc"><i>1625</i>&nbsp;    static final byte[] LOADABLE_VALUE_TAGS = { // for CONSTANT_LoadableValue</b>
<i>1626</i>&nbsp;        CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long, CONSTANT_Double,
<i>1627</i>&nbsp;        CONSTANT_String, CONSTANT_Class,
<i>1628</i>&nbsp;        CONSTANT_MethodHandle, CONSTANT_MethodType
<i>1629</i>&nbsp;    };
<b class="nc"><i>1630</i>&nbsp;    static final byte[] ANY_MEMBER_TAGS = { // for CONSTANT_AnyMember</b>
<i>1631</i>&nbsp;        CONSTANT_Fieldref, CONSTANT_Methodref, CONSTANT_InterfaceMethodref
<i>1632</i>&nbsp;    };
<b class="nc"><i>1633</i>&nbsp;    static final byte[] FIELD_SPECIFIC_TAGS = { // for CONSTANT_FieldSpecific</b>
<i>1634</i>&nbsp;        CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long, CONSTANT_Double,
<i>1635</i>&nbsp;        CONSTANT_String
<i>1636</i>&nbsp;    };
<i>1637</i>&nbsp;    static {
<b class="nc"><i>1638</i>&nbsp;        assert(</b>
<b class="nc"><i>1639</i>&nbsp;            verifyTagOrder(TAGS_IN_ORDER) &amp;&amp;</b>
<b class="nc"><i>1640</i>&nbsp;            verifyTagOrder(NUMBER_TAGS) &amp;&amp;</b>
<b class="nc"><i>1641</i>&nbsp;            verifyTagOrder(EXTRA_TAGS) &amp;&amp;</b>
<b class="nc"><i>1642</i>&nbsp;            verifyTagOrder(LOADABLE_VALUE_TAGS) &amp;&amp;</b>
<b class="nc"><i>1643</i>&nbsp;            verifyTagOrder(ANY_MEMBER_TAGS) &amp;&amp;</b>
<b class="nc"><i>1644</i>&nbsp;            verifyTagOrder(FIELD_SPECIFIC_TAGS)</b>
<i>1645</i>&nbsp;        );
<i>1646</i>&nbsp;    }
<i>1647</i>&nbsp;    private static boolean verifyTagOrder(byte[] tags) {
<b class="nc"><i>1648</i>&nbsp;        int prev = -1;</b>
<b class="nc"><i>1649</i>&nbsp;        for (byte tag : tags) {</b>
<b class="nc"><i>1650</i>&nbsp;            int next = TAG_ORDER[tag];</b>
<b class="nc"><i>1651</i>&nbsp;            assert(next &gt; 0) : &quot;tag not found: &quot;+tag;</b>
<b class="nc"><i>1652</i>&nbsp;            assert(TAGS_IN_ORDER[next-1] == tag) : &quot;tag repeated: &quot;+tag+&quot; =&gt; &quot;+next+&quot; =&gt; &quot;+TAGS_IN_ORDER[next-1];</b>
<b class="nc"><i>1653</i>&nbsp;            assert(prev &lt; next) : &quot;tags not in order: &quot;+Arrays.toString(tags)+&quot; at &quot;+tag;</b>
<b class="nc"><i>1654</i>&nbsp;            prev = next;</b>
<i>1655</i>&nbsp;        }
<b class="nc"><i>1656</i>&nbsp;        return true;</b>
<i>1657</i>&nbsp;    }
<i>1658</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
