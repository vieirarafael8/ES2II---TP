


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PackageWriter</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.java.util.jar.pack</a> ]
</div>

<h1>Coverage Summary for Class: PackageWriter (com.sun.java.util.jar.pack)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PackageWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1001)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PackageWriter$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageWriter$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageWriter$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1020)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.java.util.jar.pack;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.java.util.jar.pack.ConstantPool.*;
<i>29</i>&nbsp;import com.sun.java.util.jar.pack.Package.Class;
<i>30</i>&nbsp;import com.sun.java.util.jar.pack.Package.File;
<i>31</i>&nbsp;import com.sun.java.util.jar.pack.Package.InnerClass;
<i>32</i>&nbsp;import java.io.IOException;
<i>33</i>&nbsp;import java.io.OutputStream;
<i>34</i>&nbsp;import java.io.PrintStream;
<i>35</i>&nbsp;import java.util.ArrayList;
<i>36</i>&nbsp;import java.util.Arrays;
<i>37</i>&nbsp;import java.util.Comparator;
<i>38</i>&nbsp;import java.util.HashMap;
<i>39</i>&nbsp;import java.util.HashSet;
<i>40</i>&nbsp;import java.util.List;
<i>41</i>&nbsp;import java.util.Map;
<i>42</i>&nbsp;import java.util.Set;
<i>43</i>&nbsp;import static com.sun.java.util.jar.pack.Constants.*;
<i>44</i>&nbsp;
<i>45</i>&nbsp;/**
<i>46</i>&nbsp; * Writer for a package file.
<i>47</i>&nbsp; * @author John Rose
<i>48</i>&nbsp; */
<b class="nc"><i>49</i>&nbsp;class PackageWriter extends BandStructure {</b>
<i>50</i>&nbsp;    Package pkg;
<i>51</i>&nbsp;    OutputStream finalOut;
<i>52</i>&nbsp;    Package.Version packageVersion;
<i>53</i>&nbsp;
<b class="nc"><i>54</i>&nbsp;    PackageWriter(Package pkg, OutputStream out) throws IOException {</b>
<b class="nc"><i>55</i>&nbsp;        this.pkg = pkg;</b>
<b class="nc"><i>56</i>&nbsp;        this.finalOut = out;</b>
<i>57</i>&nbsp;        // Caller has specified maximum class file version in the package:
<b class="nc"><i>58</i>&nbsp;        initHighestClassVersion(pkg.getHighestClassVersion());</b>
<i>59</i>&nbsp;    }
<i>60</i>&nbsp;
<i>61</i>&nbsp;    void write() throws IOException {
<b class="nc"><i>62</i>&nbsp;        boolean ok = false;</b>
<i>63</i>&nbsp;        try {
<b class="nc"><i>64</i>&nbsp;            if (verbose &gt; 0) {</b>
<b class="nc"><i>65</i>&nbsp;                Utils.log.info(&quot;Setting up constant pool...&quot;);</b>
<i>66</i>&nbsp;            }
<b class="nc"><i>67</i>&nbsp;            setup();</b>
<i>68</i>&nbsp;
<b class="nc"><i>69</i>&nbsp;            if (verbose &gt; 0) {</b>
<b class="nc"><i>70</i>&nbsp;                Utils.log.info(&quot;Packing...&quot;);</b>
<i>71</i>&nbsp;            }
<i>72</i>&nbsp;
<i>73</i>&nbsp;            // writeFileHeader() is done last, since it has ultimate counts
<i>74</i>&nbsp;            // writeBandHeaders() is called after all other bands are done
<b class="nc"><i>75</i>&nbsp;            writeConstantPool();</b>
<b class="nc"><i>76</i>&nbsp;            writeFiles();</b>
<b class="nc"><i>77</i>&nbsp;            writeAttrDefs();</b>
<b class="nc"><i>78</i>&nbsp;            writeInnerClasses();</b>
<b class="nc"><i>79</i>&nbsp;            writeClassesAndByteCodes();</b>
<b class="nc"><i>80</i>&nbsp;            writeAttrCounts();</b>
<i>81</i>&nbsp;
<b class="nc"><i>82</i>&nbsp;            if (verbose &gt; 1)  printCodeHist();</b>
<i>83</i>&nbsp;
<i>84</i>&nbsp;            // choose codings (fill band_headers if needed)
<b class="nc"><i>85</i>&nbsp;            if (verbose &gt; 0) {</b>
<b class="nc"><i>86</i>&nbsp;                Utils.log.info(&quot;Coding...&quot;);</b>
<i>87</i>&nbsp;            }
<b class="nc"><i>88</i>&nbsp;            all_bands.chooseBandCodings();</b>
<i>89</i>&nbsp;
<i>90</i>&nbsp;            // now we can write the headers:
<b class="nc"><i>91</i>&nbsp;            writeFileHeader();</b>
<i>92</i>&nbsp;
<b class="nc"><i>93</i>&nbsp;            writeAllBandsTo(finalOut);</b>
<i>94</i>&nbsp;
<b class="nc"><i>95</i>&nbsp;            ok = true;</b>
<b class="nc"><i>96</i>&nbsp;        } catch (Exception ee) {</b>
<b class="nc"><i>97</i>&nbsp;            Utils.log.warning(&quot;Error on output: &quot;+ee, ee);</b>
<i>98</i>&nbsp;            //if (verbose &gt; 0)  ee.printStackTrace();
<i>99</i>&nbsp;            // Write partial output only if we are verbose.
<b class="nc"><i>100</i>&nbsp;            if (verbose &gt; 0)  finalOut.close();</b>
<b class="nc"><i>101</i>&nbsp;            if (ee instanceof IOException)  throw (IOException)ee;</b>
<b class="nc"><i>102</i>&nbsp;            if (ee instanceof RuntimeException)  throw (RuntimeException)ee;</b>
<b class="nc"><i>103</i>&nbsp;            throw new Error(&quot;error packing&quot;, ee);</b>
<b class="nc"><i>104</i>&nbsp;        }</b>
<i>105</i>&nbsp;    }
<i>106</i>&nbsp;
<i>107</i>&nbsp;    Set&lt;Entry&gt;                       requiredEntries;  // for the CP
<i>108</i>&nbsp;    Map&lt;Attribute.Layout, int[]&gt;     backCountTable;   // for layout callables
<i>109</i>&nbsp;    int[][]     attrCounts;       // count attr. occurrences
<i>110</i>&nbsp;
<i>111</i>&nbsp;    void setup() {
<b class="nc"><i>112</i>&nbsp;        requiredEntries = new HashSet&lt;&gt;();</b>
<b class="nc"><i>113</i>&nbsp;        setArchiveOptions();</b>
<b class="nc"><i>114</i>&nbsp;        trimClassAttributes();</b>
<b class="nc"><i>115</i>&nbsp;        collectAttributeLayouts();</b>
<b class="nc"><i>116</i>&nbsp;        pkg.buildGlobalConstantPool(requiredEntries);</b>
<b class="nc"><i>117</i>&nbsp;        setBandIndexes();</b>
<b class="nc"><i>118</i>&nbsp;        makeNewAttributeBands();</b>
<b class="nc"><i>119</i>&nbsp;        collectInnerClasses();</b>
<i>120</i>&nbsp;    }
<i>121</i>&nbsp;
<i>122</i>&nbsp;    /*
<i>123</i>&nbsp;     * Convenience function to choose an archive version based
<i>124</i>&nbsp;     * on the class file versions observed within the archive
<i>125</i>&nbsp;     * or set the user defined version preset via properties.
<i>126</i>&nbsp;     */
<i>127</i>&nbsp;    void chooseDefaultPackageVersion() throws IOException {
<b class="nc"><i>128</i>&nbsp;        if (pkg.packageVersion != null) {</b>
<b class="nc"><i>129</i>&nbsp;            packageVersion = pkg.packageVersion;</b>
<b class="nc"><i>130</i>&nbsp;            if (verbose &gt; 0) {</b>
<b class="nc"><i>131</i>&nbsp;                Utils.log.info(&quot;package version overridden with: &quot;</b>
<i>132</i>&nbsp;                                + packageVersion);
<i>133</i>&nbsp;            }
<i>134</i>&nbsp;            return;
<i>135</i>&nbsp;        }
<i>136</i>&nbsp;
<b class="nc"><i>137</i>&nbsp;        Package.Version highV = getHighestClassVersion();</b>
<i>138</i>&nbsp;        // set the package version now
<b class="nc"><i>139</i>&nbsp;        if (highV.lessThan(JAVA6_MAX_CLASS_VERSION)) {</b>
<i>140</i>&nbsp;            // There are only old classfiles in this segment or resources
<b class="nc"><i>141</i>&nbsp;            packageVersion = JAVA5_PACKAGE_VERSION;</b>
<b class="nc"><i>142</i>&nbsp;        } else if (highV.equals(JAVA6_MAX_CLASS_VERSION) ||</b>
<b class="nc"><i>143</i>&nbsp;                (highV.equals(JAVA7_MAX_CLASS_VERSION) &amp;&amp; !pkg.cp.haveExtraTags())) {</b>
<i>144</i>&nbsp;            // force down the package version if we have jdk7 classes without
<i>145</i>&nbsp;            // any Indy references, this is because jdk7 class file (51.0) without
<i>146</i>&nbsp;            // Indy is identical to jdk6 class file (50.0).
<b class="nc"><i>147</i>&nbsp;            packageVersion = JAVA6_PACKAGE_VERSION;</b>
<b class="nc"><i>148</i>&nbsp;        } else if (highV.equals(JAVA7_MAX_CLASS_VERSION)) {</b>
<b class="nc"><i>149</i>&nbsp;            packageVersion = JAVA7_PACKAGE_VERSION;</b>
<i>150</i>&nbsp;        } else {
<i>151</i>&nbsp;            // Normal case.  Use the newest archive format, when available
<b class="nc"><i>152</i>&nbsp;            packageVersion = JAVA8_PACKAGE_VERSION;</b>
<i>153</i>&nbsp;        }
<i>154</i>&nbsp;
<b class="nc"><i>155</i>&nbsp;        if (verbose &gt; 0) {</b>
<b class="nc"><i>156</i>&nbsp;            Utils.log.info(&quot;Highest version class file: &quot; + highV</b>
<i>157</i>&nbsp;                    + &quot; package version: &quot; + packageVersion);
<i>158</i>&nbsp;        }
<i>159</i>&nbsp;    }
<i>160</i>&nbsp;
<i>161</i>&nbsp;    void checkVersion() throws IOException {
<b class="nc"><i>162</i>&nbsp;        assert(packageVersion != null);</b>
<i>163</i>&nbsp;
<b class="nc"><i>164</i>&nbsp;        if (packageVersion.lessThan(JAVA7_PACKAGE_VERSION)) {</b>
<i>165</i>&nbsp;            // this bit was reserved for future use in previous versions
<b class="nc"><i>166</i>&nbsp;            if (testBit(archiveOptions, AO_HAVE_CP_EXTRAS)) {</b>
<b class="nc"><i>167</i>&nbsp;                throw new IOException(&quot;Format bits for Java 7 must be zero in previous releases&quot;);</b>
<i>168</i>&nbsp;            }
<i>169</i>&nbsp;        }
<b class="nc"><i>170</i>&nbsp;        if (testBit(archiveOptions, AO_UNUSED_MBZ)) {</b>
<b class="nc"><i>171</i>&nbsp;            throw new IOException(&quot;High archive option bits are reserved and must be zero: &quot; + Integer.toHexString(archiveOptions));</b>
<i>172</i>&nbsp;        }
<i>173</i>&nbsp;    }
<i>174</i>&nbsp;
<i>175</i>&nbsp;    void setArchiveOptions() {
<i>176</i>&nbsp;        // Decide on some archive options early.
<i>177</i>&nbsp;        // Does not decide on: AO_HAVE_SPECIAL_FORMATS,
<i>178</i>&nbsp;        // AO_HAVE_CP_NUMBERS, AO_HAVE_FILE_HEADERS.
<i>179</i>&nbsp;        // Also, AO_HAVE_FILE_OPTIONS may be forced on later.
<b class="nc"><i>180</i>&nbsp;        int minModtime = pkg.default_modtime;</b>
<b class="nc"><i>181</i>&nbsp;        int maxModtime = pkg.default_modtime;</b>
<b class="nc"><i>182</i>&nbsp;        int minOptions = -1;</b>
<b class="nc"><i>183</i>&nbsp;        int maxOptions = 0;</b>
<i>184</i>&nbsp;
<i>185</i>&nbsp;        // Import defaults from package (deflate hint, etc.).
<b class="nc"><i>186</i>&nbsp;        archiveOptions |= pkg.default_options;</b>
<i>187</i>&nbsp;
<b class="nc"><i>188</i>&nbsp;        for (File file : pkg.files) {</b>
<b class="nc"><i>189</i>&nbsp;            int modtime = file.modtime;</b>
<b class="nc"><i>190</i>&nbsp;            int options = file.options;</b>
<i>191</i>&nbsp;
<b class="nc"><i>192</i>&nbsp;            if (minModtime == NO_MODTIME) {</b>
<b class="nc"><i>193</i>&nbsp;                minModtime = maxModtime = modtime;</b>
<i>194</i>&nbsp;            } else {
<b class="nc"><i>195</i>&nbsp;                if (minModtime &gt; modtime)  minModtime = modtime;</b>
<b class="nc"><i>196</i>&nbsp;                if (maxModtime &lt; modtime)  maxModtime = modtime;</b>
<i>197</i>&nbsp;            }
<b class="nc"><i>198</i>&nbsp;            minOptions &amp;= options;</b>
<b class="nc"><i>199</i>&nbsp;            maxOptions |= options;</b>
<b class="nc"><i>200</i>&nbsp;        }</b>
<b class="nc"><i>201</i>&nbsp;        if (pkg.default_modtime == NO_MODTIME) {</b>
<i>202</i>&nbsp;            // Make everything else be a positive offset from here.
<b class="nc"><i>203</i>&nbsp;            pkg.default_modtime = minModtime;</b>
<i>204</i>&nbsp;        }
<b class="nc"><i>205</i>&nbsp;        if (minModtime != NO_MODTIME &amp;&amp; minModtime != maxModtime) {</b>
<i>206</i>&nbsp;            // Put them into a band.
<b class="nc"><i>207</i>&nbsp;            archiveOptions |= AO_HAVE_FILE_MODTIME;</b>
<i>208</i>&nbsp;        }
<i>209</i>&nbsp;        // If the archive deflation is set do not bother with each file.
<b class="nc"><i>210</i>&nbsp;        if (!testBit(archiveOptions,AO_DEFLATE_HINT) &amp;&amp; minOptions != -1) {</b>
<b class="nc"><i>211</i>&nbsp;            if (testBit(minOptions, FO_DEFLATE_HINT)) {</b>
<i>212</i>&nbsp;                // Every file has the deflate_hint set.
<i>213</i>&nbsp;                // Set it for the whole archive, and omit options.
<b class="nc"><i>214</i>&nbsp;                archiveOptions |= AO_DEFLATE_HINT;</b>
<b class="nc"><i>215</i>&nbsp;                minOptions -= FO_DEFLATE_HINT;</b>
<b class="nc"><i>216</i>&nbsp;                maxOptions -= FO_DEFLATE_HINT;</b>
<i>217</i>&nbsp;            }
<b class="nc"><i>218</i>&nbsp;            pkg.default_options |= minOptions;</b>
<b class="nc"><i>219</i>&nbsp;            if (minOptions != maxOptions</b>
<i>220</i>&nbsp;                || minOptions != pkg.default_options) {
<b class="nc"><i>221</i>&nbsp;                archiveOptions |= AO_HAVE_FILE_OPTIONS;</b>
<i>222</i>&nbsp;            }
<i>223</i>&nbsp;        }
<i>224</i>&nbsp;        // Decide on default version number (majority rule).
<b class="nc"><i>225</i>&nbsp;        Map&lt;Package.Version, int[]&gt; verCounts = new HashMap&lt;&gt;();</b>
<b class="nc"><i>226</i>&nbsp;        int bestCount = 0;</b>
<b class="nc"><i>227</i>&nbsp;        Package.Version bestVersion = null;</b>
<b class="nc"><i>228</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>229</i>&nbsp;            Package.Version version = cls.getVersion();</b>
<b class="nc"><i>230</i>&nbsp;            int[] var = verCounts.get(version);</b>
<b class="nc"><i>231</i>&nbsp;            if (var == null) {</b>
<b class="nc"><i>232</i>&nbsp;                var = new int[1];</b>
<b class="nc"><i>233</i>&nbsp;                verCounts.put(version, var);</b>
<i>234</i>&nbsp;            }
<b class="nc"><i>235</i>&nbsp;            int count = (var[0] += 1);</b>
<i>236</i>&nbsp;            //System.out.println(&quot;version=&quot;+version+&quot; count=&quot;+count);
<b class="nc"><i>237</i>&nbsp;            if (bestCount &lt; count) {</b>
<b class="nc"><i>238</i>&nbsp;                bestCount = count;</b>
<b class="nc"><i>239</i>&nbsp;                bestVersion = version;</b>
<i>240</i>&nbsp;            }
<b class="nc"><i>241</i>&nbsp;        }</b>
<b class="nc"><i>242</i>&nbsp;        verCounts.clear();</b>
<b class="nc"><i>243</i>&nbsp;        if (bestVersion == null)  bestVersion = JAVA_MIN_CLASS_VERSION;  // degenerate case</b>
<b class="nc"><i>244</i>&nbsp;        pkg.defaultClassVersion = bestVersion;</b>
<b class="nc"><i>245</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>246</i>&nbsp;           Utils.log.info(&quot;Consensus version number in segment is &quot; + bestVersion);</b>
<b class="nc"><i>247</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>248</i>&nbsp;            Utils.log.info(&quot;Highest version number in segment is &quot;</b>
<b class="nc"><i>249</i>&nbsp;                            + pkg.getHighestClassVersion());</b>
<i>250</i>&nbsp;
<i>251</i>&nbsp;        // Now add explicit pseudo-attrs. to classes with odd versions.
<b class="nc"><i>252</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>253</i>&nbsp;            if (!cls.getVersion().equals(bestVersion)) {</b>
<b class="nc"><i>254</i>&nbsp;                Attribute a = makeClassFileVersionAttr(cls.getVersion());</b>
<b class="nc"><i>255</i>&nbsp;                if (verbose &gt; 1) {</b>
<b class="nc"><i>256</i>&nbsp;                    Utils.log.fine(&quot;Version &quot;+cls.getVersion() + &quot; of &quot; + cls</b>
<i>257</i>&nbsp;                                     + &quot; doesn&#39;t match package version &quot;
<i>258</i>&nbsp;                                     + bestVersion);
<i>259</i>&nbsp;                }
<i>260</i>&nbsp;                // Note:  Does not add in &quot;natural&quot; order.  (Who cares?)
<b class="nc"><i>261</i>&nbsp;                cls.addAttribute(a);</b>
<i>262</i>&nbsp;            }
<b class="nc"><i>263</i>&nbsp;        }</b>
<i>264</i>&nbsp;
<i>265</i>&nbsp;        // Decide if we are transmitting a huge resource file:
<b class="nc"><i>266</i>&nbsp;        for (File file : pkg.files) {</b>
<b class="nc"><i>267</i>&nbsp;            long len = file.getFileLength();</b>
<b class="nc"><i>268</i>&nbsp;            if (len != (int)len) {</b>
<b class="nc"><i>269</i>&nbsp;                archiveOptions |= AO_HAVE_FILE_SIZE_HI;</b>
<b class="nc"><i>270</i>&nbsp;                if (verbose &gt; 0)</b>
<b class="nc"><i>271</i>&nbsp;                   Utils.log.info(&quot;Note: Huge resource file &quot;+file.getFileName()+&quot; forces 64-bit sizing&quot;);</b>
<i>272</i>&nbsp;                break;
<i>273</i>&nbsp;            }
<b class="nc"><i>274</i>&nbsp;        }</b>
<i>275</i>&nbsp;
<i>276</i>&nbsp;        // Decide if code attributes typically have sub-attributes.
<i>277</i>&nbsp;        // In that case, to preserve compact 1-byte code headers,
<i>278</i>&nbsp;        // we must declare unconditional presence of code flags.
<b class="nc"><i>279</i>&nbsp;        int cost0 = 0;</b>
<b class="nc"><i>280</i>&nbsp;        int cost1 = 0;</b>
<b class="nc"><i>281</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>282</i>&nbsp;            for (Class.Method m : cls.getMethods()) {</b>
<b class="nc"><i>283</i>&nbsp;                if (m.code != null) {</b>
<b class="nc"><i>284</i>&nbsp;                    if (m.code.attributeSize() == 0) {</b>
<i>285</i>&nbsp;                        // cost of a useless unconditional flags byte
<b class="nc"><i>286</i>&nbsp;                        cost1 += 1;</b>
<b class="nc"><i>287</i>&nbsp;                    } else if (shortCodeHeader(m.code) != LONG_CODE_HEADER) {</b>
<i>288</i>&nbsp;                        // cost of inflating a short header
<b class="nc"><i>289</i>&nbsp;                        cost0 += 3;</b>
<i>290</i>&nbsp;                    }
<i>291</i>&nbsp;                }
<b class="nc"><i>292</i>&nbsp;            }</b>
<b class="nc"><i>293</i>&nbsp;        }</b>
<b class="nc"><i>294</i>&nbsp;        if (cost0 &gt; cost1) {</b>
<b class="nc"><i>295</i>&nbsp;            archiveOptions |= AO_HAVE_ALL_CODE_FLAGS;</b>
<i>296</i>&nbsp;        }
<b class="nc"><i>297</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>298</i>&nbsp;            Utils.log.info(&quot;archiveOptions = &quot;</b>
<b class="nc"><i>299</i>&nbsp;                             +&quot;0b&quot;+Integer.toBinaryString(archiveOptions));</b>
<i>300</i>&nbsp;    }
<i>301</i>&nbsp;
<i>302</i>&nbsp;    void writeFileHeader() throws IOException {
<b class="nc"><i>303</i>&nbsp;        chooseDefaultPackageVersion();</b>
<b class="nc"><i>304</i>&nbsp;        writeArchiveMagic();</b>
<b class="nc"><i>305</i>&nbsp;        writeArchiveHeader();</b>
<i>306</i>&nbsp;    }
<i>307</i>&nbsp;
<i>308</i>&nbsp;    // Local routine used to format fixed-format scalars
<i>309</i>&nbsp;    // in the file_header:
<i>310</i>&nbsp;    private void putMagicInt32(int val) throws IOException {
<b class="nc"><i>311</i>&nbsp;        int res = val;</b>
<b class="nc"><i>312</i>&nbsp;        for (int i = 0; i &lt; 4; i++) {</b>
<b class="nc"><i>313</i>&nbsp;            archive_magic.putByte(0xFF &amp; (res &gt;&gt;&gt; 24));</b>
<b class="nc"><i>314</i>&nbsp;            res &lt;&lt;= 8;</b>
<i>315</i>&nbsp;        }
<i>316</i>&nbsp;    }
<i>317</i>&nbsp;
<i>318</i>&nbsp;    void writeArchiveMagic() throws IOException {
<b class="nc"><i>319</i>&nbsp;        putMagicInt32(pkg.magic);</b>
<i>320</i>&nbsp;    }
<i>321</i>&nbsp;
<i>322</i>&nbsp;    void writeArchiveHeader() throws IOException {
<i>323</i>&nbsp;        // for debug only:  number of words optimized away
<b class="nc"><i>324</i>&nbsp;        int headerSizeForDebug = AH_LENGTH_MIN;</b>
<i>325</i>&nbsp;
<i>326</i>&nbsp;        // AO_HAVE_SPECIAL_FORMATS is set if non-default
<i>327</i>&nbsp;        // coding techniques are used, or if there are
<i>328</i>&nbsp;        // compressor-defined attributes transmitted.
<b class="nc"><i>329</i>&nbsp;        boolean haveSpecial = testBit(archiveOptions, AO_HAVE_SPECIAL_FORMATS);</b>
<b class="nc"><i>330</i>&nbsp;        if (!haveSpecial) {</b>
<b class="nc"><i>331</i>&nbsp;            haveSpecial |= (band_headers.length() != 0);</b>
<b class="nc"><i>332</i>&nbsp;            haveSpecial |= (attrDefsWritten.length != 0);</b>
<b class="nc"><i>333</i>&nbsp;            if (haveSpecial)</b>
<b class="nc"><i>334</i>&nbsp;                archiveOptions |= AO_HAVE_SPECIAL_FORMATS;</b>
<i>335</i>&nbsp;        }
<b class="nc"><i>336</i>&nbsp;        if (haveSpecial)</b>
<b class="nc"><i>337</i>&nbsp;            headerSizeForDebug += AH_SPECIAL_FORMAT_LEN;</b>
<i>338</i>&nbsp;
<i>339</i>&nbsp;        // AO_HAVE_FILE_HEADERS is set if there is any
<i>340</i>&nbsp;        // file or segment envelope information present.
<b class="nc"><i>341</i>&nbsp;        boolean haveFiles = testBit(archiveOptions, AO_HAVE_FILE_HEADERS);</b>
<b class="nc"><i>342</i>&nbsp;        if (!haveFiles) {</b>
<b class="nc"><i>343</i>&nbsp;            haveFiles |= (archiveNextCount &gt; 0);</b>
<b class="nc"><i>344</i>&nbsp;            haveFiles |= (pkg.default_modtime != NO_MODTIME);</b>
<b class="nc"><i>345</i>&nbsp;            if (haveFiles)</b>
<b class="nc"><i>346</i>&nbsp;                archiveOptions |= AO_HAVE_FILE_HEADERS;</b>
<i>347</i>&nbsp;        }
<b class="nc"><i>348</i>&nbsp;        if (haveFiles)</b>
<b class="nc"><i>349</i>&nbsp;            headerSizeForDebug += AH_FILE_HEADER_LEN;</b>
<i>350</i>&nbsp;
<i>351</i>&nbsp;        // AO_HAVE_CP_NUMBERS is set if there are any numbers
<i>352</i>&nbsp;        // in the global constant pool.  (Numbers are in 15% of classes.)
<b class="nc"><i>353</i>&nbsp;        boolean haveNumbers = testBit(archiveOptions, AO_HAVE_CP_NUMBERS);</b>
<b class="nc"><i>354</i>&nbsp;        if (!haveNumbers) {</b>
<b class="nc"><i>355</i>&nbsp;            haveNumbers |= pkg.cp.haveNumbers();</b>
<b class="nc"><i>356</i>&nbsp;            if (haveNumbers)</b>
<b class="nc"><i>357</i>&nbsp;                archiveOptions |= AO_HAVE_CP_NUMBERS;</b>
<i>358</i>&nbsp;        }
<b class="nc"><i>359</i>&nbsp;        if (haveNumbers)</b>
<b class="nc"><i>360</i>&nbsp;            headerSizeForDebug += AH_CP_NUMBER_LEN;</b>
<i>361</i>&nbsp;
<i>362</i>&nbsp;        // AO_HAVE_CP_EXTRAS is set if there are constant pool entries
<i>363</i>&nbsp;        // beyond the Java 6 version of the class file format.
<b class="nc"><i>364</i>&nbsp;        boolean haveCPExtra = testBit(archiveOptions, AO_HAVE_CP_EXTRAS);</b>
<b class="nc"><i>365</i>&nbsp;        if (!haveCPExtra) {</b>
<b class="nc"><i>366</i>&nbsp;            haveCPExtra |= pkg.cp.haveExtraTags();</b>
<b class="nc"><i>367</i>&nbsp;            if (haveCPExtra)</b>
<b class="nc"><i>368</i>&nbsp;                archiveOptions |= AO_HAVE_CP_EXTRAS;</b>
<i>369</i>&nbsp;        }
<b class="nc"><i>370</i>&nbsp;        if (haveCPExtra)</b>
<b class="nc"><i>371</i>&nbsp;            headerSizeForDebug += AH_CP_EXTRA_LEN;</b>
<i>372</i>&nbsp;
<i>373</i>&nbsp;        // the archiveOptions are all initialized, sanity check now!.
<b class="nc"><i>374</i>&nbsp;        checkVersion();</b>
<i>375</i>&nbsp;
<b class="nc"><i>376</i>&nbsp;        archive_header_0.putInt(packageVersion.minor);</b>
<b class="nc"><i>377</i>&nbsp;        archive_header_0.putInt(packageVersion.major);</b>
<b class="nc"><i>378</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>379</i>&nbsp;            Utils.log.info(&quot;Package Version for this segment:&quot; + packageVersion);</b>
<b class="nc"><i>380</i>&nbsp;        archive_header_0.putInt(archiveOptions); // controls header format</b>
<b class="nc"><i>381</i>&nbsp;        assert(archive_header_0.length() == AH_LENGTH_0);</b>
<i>382</i>&nbsp;
<i>383</i>&nbsp;        final int DUMMY = 0;
<b class="nc"><i>384</i>&nbsp;        if (haveFiles) {</b>
<b class="nc"><i>385</i>&nbsp;            assert(archive_header_S.length() == AH_ARCHIVE_SIZE_HI);</b>
<b class="nc"><i>386</i>&nbsp;            archive_header_S.putInt(DUMMY); // (archiveSize1 &gt;&gt;&gt; 32)</b>
<b class="nc"><i>387</i>&nbsp;            assert(archive_header_S.length() == AH_ARCHIVE_SIZE_LO);</b>
<b class="nc"><i>388</i>&nbsp;            archive_header_S.putInt(DUMMY); // (archiveSize1 &gt;&gt;&gt; 0)</b>
<b class="nc"><i>389</i>&nbsp;            assert(archive_header_S.length() == AH_LENGTH_S);</b>
<i>390</i>&nbsp;        }
<i>391</i>&nbsp;
<i>392</i>&nbsp;        // Done with unsized part of header....
<i>393</i>&nbsp;
<b class="nc"><i>394</i>&nbsp;        if (haveFiles) {</b>
<b class="nc"><i>395</i>&nbsp;            archive_header_1.putInt(archiveNextCount);  // usually zero</b>
<b class="nc"><i>396</i>&nbsp;            archive_header_1.putInt(pkg.default_modtime);</b>
<b class="nc"><i>397</i>&nbsp;            archive_header_1.putInt(pkg.files.size());</b>
<i>398</i>&nbsp;        } else {
<b class="nc"><i>399</i>&nbsp;            assert(pkg.files.isEmpty());</b>
<i>400</i>&nbsp;        }
<i>401</i>&nbsp;
<b class="nc"><i>402</i>&nbsp;        if (haveSpecial) {</b>
<b class="nc"><i>403</i>&nbsp;            archive_header_1.putInt(band_headers.length());</b>
<b class="nc"><i>404</i>&nbsp;            archive_header_1.putInt(attrDefsWritten.length);</b>
<i>405</i>&nbsp;        } else {
<b class="nc"><i>406</i>&nbsp;            assert(band_headers.length() == 0);</b>
<b class="nc"><i>407</i>&nbsp;            assert(attrDefsWritten.length == 0);</b>
<i>408</i>&nbsp;        }
<i>409</i>&nbsp;
<b class="nc"><i>410</i>&nbsp;        writeConstantPoolCounts(haveNumbers, haveCPExtra);</b>
<i>411</i>&nbsp;
<b class="nc"><i>412</i>&nbsp;        archive_header_1.putInt(pkg.getAllInnerClasses().size());</b>
<b class="nc"><i>413</i>&nbsp;        archive_header_1.putInt(pkg.defaultClassVersion.minor);</b>
<b class="nc"><i>414</i>&nbsp;        archive_header_1.putInt(pkg.defaultClassVersion.major);</b>
<b class="nc"><i>415</i>&nbsp;        archive_header_1.putInt(pkg.classes.size());</b>
<i>416</i>&nbsp;
<i>417</i>&nbsp;        // Sanity:  Make sure we came out to 29 (less optional fields):
<b class="nc"><i>418</i>&nbsp;        assert(archive_header_0.length() +</b>
<b class="nc"><i>419</i>&nbsp;               archive_header_S.length() +</b>
<b class="nc"><i>420</i>&nbsp;               archive_header_1.length()</b>
<i>421</i>&nbsp;               == headerSizeForDebug);
<i>422</i>&nbsp;
<i>423</i>&nbsp;        // Figure out all the sizes now, first cut:
<b class="nc"><i>424</i>&nbsp;        archiveSize0 = 0;</b>
<b class="nc"><i>425</i>&nbsp;        archiveSize1 = all_bands.outputSize();</b>
<i>426</i>&nbsp;        // Second cut:
<b class="nc"><i>427</i>&nbsp;        archiveSize0 += archive_magic.outputSize();</b>
<b class="nc"><i>428</i>&nbsp;        archiveSize0 += archive_header_0.outputSize();</b>
<b class="nc"><i>429</i>&nbsp;        archiveSize0 += archive_header_S.outputSize();</b>
<i>430</i>&nbsp;        // Make the adjustments:
<b class="nc"><i>431</i>&nbsp;        archiveSize1 -= archiveSize0;</b>
<i>432</i>&nbsp;
<i>433</i>&nbsp;        // Patch the header:
<b class="nc"><i>434</i>&nbsp;        if (haveFiles) {</b>
<b class="nc"><i>435</i>&nbsp;            int archiveSizeHi = (int)(archiveSize1 &gt;&gt;&gt; 32);</b>
<b class="nc"><i>436</i>&nbsp;            int archiveSizeLo = (int)(archiveSize1 &gt;&gt;&gt; 0);</b>
<b class="nc"><i>437</i>&nbsp;            archive_header_S.patchValue(AH_ARCHIVE_SIZE_HI, archiveSizeHi);</b>
<b class="nc"><i>438</i>&nbsp;            archive_header_S.patchValue(AH_ARCHIVE_SIZE_LO, archiveSizeLo);</b>
<b class="nc"><i>439</i>&nbsp;            int zeroLen = UNSIGNED5.getLength(DUMMY);</b>
<b class="nc"><i>440</i>&nbsp;            archiveSize0 += UNSIGNED5.getLength(archiveSizeHi) - zeroLen;</b>
<b class="nc"><i>441</i>&nbsp;            archiveSize0 += UNSIGNED5.getLength(archiveSizeLo) - zeroLen;</b>
<i>442</i>&nbsp;        }
<b class="nc"><i>443</i>&nbsp;        if (verbose &gt; 1)</b>
<b class="nc"><i>444</i>&nbsp;            Utils.log.fine(&quot;archive sizes: &quot;+</b>
<i>445</i>&nbsp;                             archiveSize0+&quot;+&quot;+archiveSize1);
<b class="nc"><i>446</i>&nbsp;        assert(all_bands.outputSize() == archiveSize0+archiveSize1);</b>
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;    void writeConstantPoolCounts(boolean haveNumbers, boolean haveCPExtra) throws IOException {
<b class="nc"><i>450</i>&nbsp;        for (byte tag : ConstantPool.TAGS_IN_ORDER) {</b>
<b class="nc"><i>451</i>&nbsp;            int count = pkg.cp.getIndexByTag(tag).size();</b>
<b class="nc"><i>452</i>&nbsp;            switch (tag) {</b>
<i>453</i>&nbsp;            case CONSTANT_Utf8:
<i>454</i>&nbsp;                // The null string is always first.
<b class="nc"><i>455</i>&nbsp;                if (count &gt; 0)</b>
<b class="nc"><i>456</i>&nbsp;                    assert(pkg.cp.getIndexByTag(tag).get(0)</b>
<b class="nc"><i>457</i>&nbsp;                           == ConstantPool.getUtf8Entry(&quot;&quot;));</b>
<i>458</i>&nbsp;                break;
<i>459</i>&nbsp;
<i>460</i>&nbsp;            case CONSTANT_Integer:
<i>461</i>&nbsp;            case CONSTANT_Float:
<i>462</i>&nbsp;            case CONSTANT_Long:
<i>463</i>&nbsp;            case CONSTANT_Double:
<i>464</i>&nbsp;                // Omit counts for numbers if possible.
<b class="nc"><i>465</i>&nbsp;                if (!haveNumbers) {</b>
<b class="nc"><i>466</i>&nbsp;                    assert(count == 0);</b>
<i>467</i>&nbsp;                    continue;
<i>468</i>&nbsp;                }
<i>469</i>&nbsp;                break;
<i>470</i>&nbsp;
<i>471</i>&nbsp;            case CONSTANT_MethodHandle:
<i>472</i>&nbsp;            case CONSTANT_MethodType:
<i>473</i>&nbsp;            case CONSTANT_InvokeDynamic:
<i>474</i>&nbsp;            case CONSTANT_BootstrapMethod:
<i>475</i>&nbsp;                // Omit counts for newer entities if possible.
<b class="nc"><i>476</i>&nbsp;                if (!haveCPExtra) {</b>
<b class="nc"><i>477</i>&nbsp;                    assert(count == 0);</b>
<i>478</i>&nbsp;                    continue;
<i>479</i>&nbsp;                }
<i>480</i>&nbsp;                break;
<i>481</i>&nbsp;            }
<b class="nc"><i>482</i>&nbsp;            archive_header_1.putInt(count);</b>
<i>483</i>&nbsp;        }
<i>484</i>&nbsp;    }
<i>485</i>&nbsp;
<i>486</i>&nbsp;    protected Index getCPIndex(byte tag) {
<b class="nc"><i>487</i>&nbsp;        return pkg.cp.getIndexByTag(tag);</b>
<i>488</i>&nbsp;    }
<i>489</i>&nbsp;
<i>490</i>&nbsp;// (The following observations are out of date; they apply only to
<i>491</i>&nbsp;// &quot;banding&quot; the constant pool itself.  Later revisions of this algorithm
<i>492</i>&nbsp;// applied the banding technique to every part of the package file,
<i>493</i>&nbsp;// applying the benefits more broadly.)
<i>494</i>&nbsp;
<i>495</i>&nbsp;// Note:  Keeping the data separate in passes (or &quot;bands&quot;) allows the
<i>496</i>&nbsp;// compressor to issue significantly shorter indexes for repeated data.
<i>497</i>&nbsp;// The difference in zipped size is 4%, which is remarkable since the
<i>498</i>&nbsp;// unzipped sizes are the same (only the byte order differs).
<i>499</i>&nbsp;
<i>500</i>&nbsp;// After moving similar data into bands, it becomes natural to delta-encode
<i>501</i>&nbsp;// each band.  (This is especially useful if we sort the constant pool first.)
<i>502</i>&nbsp;// Delta encoding saves an extra 5% in the output size (13% of the CP itself).
<i>503</i>&nbsp;// Because a typical delta usees much less data than a byte, the savings after
<i>504</i>&nbsp;// zipping is even better:  A zipped delta-encoded package is 8% smaller than
<i>505</i>&nbsp;// a zipped non-delta-encoded package.  Thus, in the zipped file, a banded,
<i>506</i>&nbsp;// delta-encoded constant pool saves over 11% (of the total file size) compared
<i>507</i>&nbsp;// with a zipped unbanded file.
<i>508</i>&nbsp;
<i>509</i>&nbsp;    void writeConstantPool() throws IOException {
<b class="nc"><i>510</i>&nbsp;        IndexGroup cp = pkg.cp;</b>
<i>511</i>&nbsp;
<b class="nc"><i>512</i>&nbsp;        if (verbose &gt; 0)  Utils.log.info(&quot;Writing CP&quot;);</b>
<i>513</i>&nbsp;
<b class="nc"><i>514</i>&nbsp;        for (byte tag : ConstantPool.TAGS_IN_ORDER) {</b>
<b class="nc"><i>515</i>&nbsp;            Index index = cp.getIndexByTag(tag);</b>
<i>516</i>&nbsp;
<b class="nc"><i>517</i>&nbsp;            Entry[] cpMap = index.cpMap;</b>
<b class="nc"><i>518</i>&nbsp;            if (verbose &gt; 0)</b>
<b class="nc"><i>519</i>&nbsp;                Utils.log.info(&quot;Writing &quot;+cpMap.length+&quot; &quot;+ConstantPool.tagName(tag)+&quot; entries...&quot;);</b>
<i>520</i>&nbsp;
<b class="nc"><i>521</i>&nbsp;            if (optDumpBands) {</b>
<b class="nc"><i>522</i>&nbsp;                try (PrintStream ps = new PrintStream(getDumpStream(index, &quot;.idx&quot;))) {</b>
<b class="nc"><i>523</i>&nbsp;                    printArrayTo(ps, cpMap, 0, cpMap.length);</b>
<b class="nc"><i>524</i>&nbsp;                }</b>
<i>525</i>&nbsp;            }
<i>526</i>&nbsp;
<b class="nc"><i>527</i>&nbsp;            switch (tag) {</b>
<i>528</i>&nbsp;            case CONSTANT_Utf8:
<b class="nc"><i>529</i>&nbsp;                writeUtf8Bands(cpMap);</b>
<b class="nc"><i>530</i>&nbsp;                break;</b>
<i>531</i>&nbsp;            case CONSTANT_Integer:
<b class="nc"><i>532</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>533</i>&nbsp;                    NumberEntry e = (NumberEntry) cpMap[i];</b>
<b class="nc"><i>534</i>&nbsp;                    int x = ((Integer)e.numberValue()).intValue();</b>
<b class="nc"><i>535</i>&nbsp;                    cp_Int.putInt(x);</b>
<i>536</i>&nbsp;                }
<b class="nc"><i>537</i>&nbsp;                break;</b>
<i>538</i>&nbsp;            case CONSTANT_Float:
<b class="nc"><i>539</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>540</i>&nbsp;                    NumberEntry e = (NumberEntry) cpMap[i];</b>
<b class="nc"><i>541</i>&nbsp;                    float fx = ((Float)e.numberValue()).floatValue();</b>
<b class="nc"><i>542</i>&nbsp;                    int x = Float.floatToIntBits(fx);</b>
<b class="nc"><i>543</i>&nbsp;                    cp_Float.putInt(x);</b>
<i>544</i>&nbsp;                }
<b class="nc"><i>545</i>&nbsp;                break;</b>
<i>546</i>&nbsp;            case CONSTANT_Long:
<b class="nc"><i>547</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>548</i>&nbsp;                    NumberEntry e = (NumberEntry) cpMap[i];</b>
<b class="nc"><i>549</i>&nbsp;                    long x = ((Long)e.numberValue()).longValue();</b>
<b class="nc"><i>550</i>&nbsp;                    cp_Long_hi.putInt((int)(x &gt;&gt;&gt; 32));</b>
<b class="nc"><i>551</i>&nbsp;                    cp_Long_lo.putInt((int)(x &gt;&gt;&gt; 0));</b>
<i>552</i>&nbsp;                }
<b class="nc"><i>553</i>&nbsp;                break;</b>
<i>554</i>&nbsp;            case CONSTANT_Double:
<b class="nc"><i>555</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>556</i>&nbsp;                    NumberEntry e = (NumberEntry) cpMap[i];</b>
<b class="nc"><i>557</i>&nbsp;                    double dx = ((Double)e.numberValue()).doubleValue();</b>
<b class="nc"><i>558</i>&nbsp;                    long x = Double.doubleToLongBits(dx);</b>
<b class="nc"><i>559</i>&nbsp;                    cp_Double_hi.putInt((int)(x &gt;&gt;&gt; 32));</b>
<b class="nc"><i>560</i>&nbsp;                    cp_Double_lo.putInt((int)(x &gt;&gt;&gt; 0));</b>
<i>561</i>&nbsp;                }
<b class="nc"><i>562</i>&nbsp;                break;</b>
<i>563</i>&nbsp;            case CONSTANT_String:
<b class="nc"><i>564</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>565</i>&nbsp;                    StringEntry e = (StringEntry) cpMap[i];</b>
<b class="nc"><i>566</i>&nbsp;                    cp_String.putRef(e.ref);</b>
<i>567</i>&nbsp;                }
<b class="nc"><i>568</i>&nbsp;                break;</b>
<i>569</i>&nbsp;            case CONSTANT_Class:
<b class="nc"><i>570</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>571</i>&nbsp;                    ClassEntry e = (ClassEntry) cpMap[i];</b>
<b class="nc"><i>572</i>&nbsp;                    cp_Class.putRef(e.ref);</b>
<i>573</i>&nbsp;                }
<b class="nc"><i>574</i>&nbsp;                break;</b>
<i>575</i>&nbsp;            case CONSTANT_Signature:
<b class="nc"><i>576</i>&nbsp;                writeSignatureBands(cpMap);</b>
<b class="nc"><i>577</i>&nbsp;                break;</b>
<i>578</i>&nbsp;            case CONSTANT_NameandType:
<b class="nc"><i>579</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>580</i>&nbsp;                    DescriptorEntry e = (DescriptorEntry) cpMap[i];</b>
<b class="nc"><i>581</i>&nbsp;                    cp_Descr_name.putRef(e.nameRef);</b>
<b class="nc"><i>582</i>&nbsp;                    cp_Descr_type.putRef(e.typeRef);</b>
<i>583</i>&nbsp;                }
<b class="nc"><i>584</i>&nbsp;                break;</b>
<i>585</i>&nbsp;            case CONSTANT_Fieldref:
<b class="nc"><i>586</i>&nbsp;                writeMemberRefs(tag, cpMap, cp_Field_class, cp_Field_desc);</b>
<b class="nc"><i>587</i>&nbsp;                break;</b>
<i>588</i>&nbsp;            case CONSTANT_Methodref:
<b class="nc"><i>589</i>&nbsp;                writeMemberRefs(tag, cpMap, cp_Method_class, cp_Method_desc);</b>
<b class="nc"><i>590</i>&nbsp;                break;</b>
<i>591</i>&nbsp;            case CONSTANT_InterfaceMethodref:
<b class="nc"><i>592</i>&nbsp;                writeMemberRefs(tag, cpMap, cp_Imethod_class, cp_Imethod_desc);</b>
<b class="nc"><i>593</i>&nbsp;                break;</b>
<i>594</i>&nbsp;            case CONSTANT_MethodHandle:
<b class="nc"><i>595</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>596</i>&nbsp;                    MethodHandleEntry e = (MethodHandleEntry) cpMap[i];</b>
<b class="nc"><i>597</i>&nbsp;                    cp_MethodHandle_refkind.putInt(e.refKind);</b>
<b class="nc"><i>598</i>&nbsp;                    cp_MethodHandle_member.putRef(e.memRef);</b>
<i>599</i>&nbsp;                }
<b class="nc"><i>600</i>&nbsp;                break;</b>
<i>601</i>&nbsp;            case CONSTANT_MethodType:
<b class="nc"><i>602</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>603</i>&nbsp;                    MethodTypeEntry e = (MethodTypeEntry) cpMap[i];</b>
<b class="nc"><i>604</i>&nbsp;                    cp_MethodType.putRef(e.typeRef);</b>
<i>605</i>&nbsp;                }
<b class="nc"><i>606</i>&nbsp;                break;</b>
<i>607</i>&nbsp;            case CONSTANT_InvokeDynamic:
<b class="nc"><i>608</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>609</i>&nbsp;                    InvokeDynamicEntry e = (InvokeDynamicEntry) cpMap[i];</b>
<b class="nc"><i>610</i>&nbsp;                    cp_InvokeDynamic_spec.putRef(e.bssRef);</b>
<b class="nc"><i>611</i>&nbsp;                    cp_InvokeDynamic_desc.putRef(e.descRef);</b>
<i>612</i>&nbsp;                }
<b class="nc"><i>613</i>&nbsp;                break;</b>
<i>614</i>&nbsp;            case CONSTANT_BootstrapMethod:
<b class="nc"><i>615</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>616</i>&nbsp;                    BootstrapMethodEntry e = (BootstrapMethodEntry) cpMap[i];</b>
<b class="nc"><i>617</i>&nbsp;                    cp_BootstrapMethod_ref.putRef(e.bsmRef);</b>
<b class="nc"><i>618</i>&nbsp;                    cp_BootstrapMethod_arg_count.putInt(e.argRefs.length);</b>
<b class="nc"><i>619</i>&nbsp;                    for (Entry argRef : e.argRefs) {</b>
<b class="nc"><i>620</i>&nbsp;                        cp_BootstrapMethod_arg.putRef(argRef);</b>
<i>621</i>&nbsp;                    }
<i>622</i>&nbsp;                }
<b class="nc"><i>623</i>&nbsp;                break;</b>
<i>624</i>&nbsp;            default:
<b class="nc"><i>625</i>&nbsp;                throw new AssertionError(&quot;unexpected CP tag in package&quot;);</b>
<i>626</i>&nbsp;            }
<i>627</i>&nbsp;        }
<b class="nc"><i>628</i>&nbsp;        if (optDumpBands || verbose &gt; 1) {</b>
<b class="nc"><i>629</i>&nbsp;            for (byte tag = CONSTANT_GroupFirst; tag &lt; CONSTANT_GroupLimit; tag++) {</b>
<b class="nc"><i>630</i>&nbsp;                Index index = cp.getIndexByTag(tag);</b>
<b class="nc"><i>631</i>&nbsp;                if (index == null || index.isEmpty())  continue;</b>
<b class="nc"><i>632</i>&nbsp;                Entry[] cpMap = index.cpMap;</b>
<b class="nc"><i>633</i>&nbsp;                if (verbose &gt; 1)</b>
<b class="nc"><i>634</i>&nbsp;                    Utils.log.info(&quot;Index group &quot;+ConstantPool.tagName(tag)+&quot; contains &quot;+cpMap.length+&quot; entries.&quot;);</b>
<b class="nc"><i>635</i>&nbsp;                if (optDumpBands) {</b>
<b class="nc"><i>636</i>&nbsp;                    try (PrintStream ps = new PrintStream(getDumpStream(index.debugName, tag, &quot;.gidx&quot;, index))) {</b>
<b class="nc"><i>637</i>&nbsp;                        printArrayTo(ps, cpMap, 0, cpMap.length, true);</b>
<b class="nc"><i>638</i>&nbsp;                    }</b>
<i>639</i>&nbsp;                }
<i>640</i>&nbsp;            }
<i>641</i>&nbsp;        }
<i>642</i>&nbsp;    }
<i>643</i>&nbsp;
<i>644</i>&nbsp;    void writeUtf8Bands(Entry[] cpMap) throws IOException {
<b class="nc"><i>645</i>&nbsp;        if (cpMap.length == 0)</b>
<i>646</i>&nbsp;            return;  // nothing to write
<i>647</i>&nbsp;
<i>648</i>&nbsp;        // The first element must always be the empty string.
<b class="nc"><i>649</i>&nbsp;        assert(cpMap[0].stringValue().equals(&quot;&quot;));</b>
<i>650</i>&nbsp;        final int SUFFIX_SKIP_1 = 1;
<i>651</i>&nbsp;        final int PREFIX_SKIP_2 = 2;
<i>652</i>&nbsp;
<i>653</i>&nbsp;        // Fetch the char arrays, first of all.
<b class="nc"><i>654</i>&nbsp;        char[][] chars = new char[cpMap.length][];</b>
<b class="nc"><i>655</i>&nbsp;        for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="nc"><i>656</i>&nbsp;            chars[i] = cpMap[i].stringValue().toCharArray();</b>
<i>657</i>&nbsp;        }
<i>658</i>&nbsp;
<i>659</i>&nbsp;        // First band:  Write lengths of shared prefixes.
<b class="nc"><i>660</i>&nbsp;        int[] prefixes = new int[cpMap.length];  // includes 2 skipped zeroes</b>
<b class="nc"><i>661</i>&nbsp;        char[] prevChars = {};</b>
<b class="nc"><i>662</i>&nbsp;        for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="nc"><i>663</i>&nbsp;            int prefix = 0;</b>
<b class="nc"><i>664</i>&nbsp;            char[] curChars = chars[i];</b>
<b class="nc"><i>665</i>&nbsp;            int limit = Math.min(curChars.length, prevChars.length);</b>
<b class="nc"><i>666</i>&nbsp;            while (prefix &lt; limit &amp;&amp; curChars[prefix] == prevChars[prefix])</b>
<b class="nc"><i>667</i>&nbsp;                prefix++;</b>
<b class="nc"><i>668</i>&nbsp;            prefixes[i] = prefix;</b>
<b class="nc"><i>669</i>&nbsp;            if (i &gt;= PREFIX_SKIP_2)</b>
<b class="nc"><i>670</i>&nbsp;                cp_Utf8_prefix.putInt(prefix);</b>
<i>671</i>&nbsp;            else
<b class="nc"><i>672</i>&nbsp;                assert(prefix == 0);</b>
<b class="nc"><i>673</i>&nbsp;            prevChars = curChars;</b>
<i>674</i>&nbsp;        }
<i>675</i>&nbsp;
<i>676</i>&nbsp;        // Second band:  Write lengths of unshared suffixes.
<i>677</i>&nbsp;        // Third band:  Write the char values in the unshared suffixes.
<b class="nc"><i>678</i>&nbsp;        for (int i = 0; i &lt; chars.length; i++) {</b>
<b class="nc"><i>679</i>&nbsp;            char[] str = chars[i];</b>
<b class="nc"><i>680</i>&nbsp;            int prefix = prefixes[i];</b>
<b class="nc"><i>681</i>&nbsp;            int suffix = str.length - prefixes[i];</b>
<b class="nc"><i>682</i>&nbsp;            boolean isPacked = false;</b>
<b class="nc"><i>683</i>&nbsp;            if (suffix == 0) {</b>
<i>684</i>&nbsp;                // Zero suffix length is special flag to indicate
<i>685</i>&nbsp;                // separate treatment in cp_Utf8_big bands.
<i>686</i>&nbsp;                // This suffix length never occurs naturally,
<i>687</i>&nbsp;                // except in the one case of a zero-length string.
<i>688</i>&nbsp;                // (If it occurs, it is the first, due to sorting.)
<i>689</i>&nbsp;                // The zero length string must, paradoxically, be
<i>690</i>&nbsp;                // encoded as a zero-length cp_Utf8_big band.
<i>691</i>&nbsp;                // This wastes exactly (&amp; tolerably) one null byte.
<b class="nc"><i>692</i>&nbsp;                isPacked = (i &gt;= SUFFIX_SKIP_1);</b>
<i>693</i>&nbsp;                // Do not bother to add an empty &quot;(Utf8_big_0)&quot; band.
<i>694</i>&nbsp;                // Also, the initial empty string does not require a band.
<b class="nc"><i>695</i>&nbsp;            } else if (optBigStrings &amp;&amp; effort &gt; 1 &amp;&amp; suffix &gt; 100) {</b>
<b class="nc"><i>696</i>&nbsp;                int numWide = 0;</b>
<b class="nc"><i>697</i>&nbsp;                for (int n = 0; n &lt; suffix; n++) {</b>
<b class="nc"><i>698</i>&nbsp;                    if (str[prefix+n] &gt; 127) {</b>
<b class="nc"><i>699</i>&nbsp;                        numWide++;</b>
<i>700</i>&nbsp;                    }
<i>701</i>&nbsp;                }
<b class="nc"><i>702</i>&nbsp;                if (numWide &gt; 100) {</b>
<i>703</i>&nbsp;                    // Try packing the chars with an alternate encoding.
<b class="nc"><i>704</i>&nbsp;                    isPacked = tryAlternateEncoding(i, numWide, str, prefix);</b>
<i>705</i>&nbsp;                }
<i>706</i>&nbsp;            }
<b class="nc"><i>707</i>&nbsp;            if (i &lt; SUFFIX_SKIP_1) {</b>
<i>708</i>&nbsp;                // No output.
<b class="nc"><i>709</i>&nbsp;                assert(!isPacked);</b>
<b class="nc"><i>710</i>&nbsp;                assert(suffix == 0);</b>
<b class="nc"><i>711</i>&nbsp;            } else if (isPacked) {</b>
<i>712</i>&nbsp;                // Mark packed string with zero-length suffix count.
<i>713</i>&nbsp;                // This tells the unpacker to go elsewhere for the suffix bits.
<i>714</i>&nbsp;                // Fourth band:  Write unshared suffix with alternate coding.
<b class="nc"><i>715</i>&nbsp;                cp_Utf8_suffix.putInt(0);</b>
<b class="nc"><i>716</i>&nbsp;                cp_Utf8_big_suffix.putInt(suffix);</b>
<i>717</i>&nbsp;            } else {
<b class="nc"><i>718</i>&nbsp;                assert(suffix != 0);  // would be ambiguous</b>
<i>719</i>&nbsp;                // Normal string.  Save suffix in third and fourth bands.
<b class="nc"><i>720</i>&nbsp;                cp_Utf8_suffix.putInt(suffix);</b>
<b class="nc"><i>721</i>&nbsp;                for (int n = 0; n &lt; suffix; n++) {</b>
<b class="nc"><i>722</i>&nbsp;                    int ch = str[prefix+n];</b>
<b class="nc"><i>723</i>&nbsp;                    cp_Utf8_chars.putInt(ch);</b>
<i>724</i>&nbsp;                }
<i>725</i>&nbsp;            }
<i>726</i>&nbsp;        }
<b class="nc"><i>727</i>&nbsp;        if (verbose &gt; 0) {</b>
<b class="nc"><i>728</i>&nbsp;            int normCharCount = cp_Utf8_chars.length();</b>
<b class="nc"><i>729</i>&nbsp;            int packCharCount = cp_Utf8_big_chars.length();</b>
<b class="nc"><i>730</i>&nbsp;            int charCount = normCharCount + packCharCount;</b>
<b class="nc"><i>731</i>&nbsp;            Utils.log.info(&quot;Utf8string #CHARS=&quot;+charCount+&quot; #PACKEDCHARS=&quot;+packCharCount);</b>
<i>732</i>&nbsp;        }
<i>733</i>&nbsp;    }
<i>734</i>&nbsp;
<i>735</i>&nbsp;    private boolean tryAlternateEncoding(int i, int numWide,
<i>736</i>&nbsp;                                         char[] str, int prefix) {
<b class="nc"><i>737</i>&nbsp;        int suffix = str.length - prefix;</b>
<b class="nc"><i>738</i>&nbsp;        int[] cvals = new int[suffix];</b>
<b class="nc"><i>739</i>&nbsp;        for (int n = 0; n &lt; suffix; n++) {</b>
<b class="nc"><i>740</i>&nbsp;            cvals[n] = str[prefix+n];</b>
<i>741</i>&nbsp;        }
<b class="nc"><i>742</i>&nbsp;        CodingChooser cc = getCodingChooser();</b>
<b class="nc"><i>743</i>&nbsp;        Coding bigRegular = cp_Utf8_big_chars.regularCoding;</b>
<b class="nc"><i>744</i>&nbsp;        String bandName = &quot;(Utf8_big_&quot;+i+&quot;)&quot;;</b>
<b class="nc"><i>745</i>&nbsp;        int[] sizes = { 0, 0 };</b>
<i>746</i>&nbsp;        final int BYTE_SIZE = CodingChooser.BYTE_SIZE;
<i>747</i>&nbsp;        final int ZIP_SIZE = CodingChooser.ZIP_SIZE;
<b class="nc"><i>748</i>&nbsp;        if (verbose &gt; 1 || cc.verbose &gt; 1) {</b>
<b class="nc"><i>749</i>&nbsp;            Utils.log.fine(&quot;--- chooseCoding &quot;+bandName);</b>
<i>750</i>&nbsp;        }
<b class="nc"><i>751</i>&nbsp;        CodingMethod special = cc.choose(cvals, bigRegular, sizes);</b>
<b class="nc"><i>752</i>&nbsp;        Coding charRegular = cp_Utf8_chars.regularCoding;</b>
<b class="nc"><i>753</i>&nbsp;        if (verbose &gt; 1)</b>
<b class="nc"><i>754</i>&nbsp;            Utils.log.fine(&quot;big string[&quot;+i+&quot;] len=&quot;+suffix+&quot; #wide=&quot;+numWide+&quot; size=&quot;+sizes[BYTE_SIZE]+&quot;/z=&quot;+sizes[ZIP_SIZE]+&quot; coding &quot;+special);</b>
<b class="nc"><i>755</i>&nbsp;        if (special != charRegular) {</b>
<b class="nc"><i>756</i>&nbsp;            int specialZipSize = sizes[ZIP_SIZE];</b>
<b class="nc"><i>757</i>&nbsp;            int[] normalSizes = cc.computeSize(charRegular, cvals);</b>
<b class="nc"><i>758</i>&nbsp;            int normalZipSize = normalSizes[ZIP_SIZE];</b>
<b class="nc"><i>759</i>&nbsp;            int minWin = Math.max(5, normalZipSize/1000);</b>
<b class="nc"><i>760</i>&nbsp;            if (verbose &gt; 1)</b>
<b class="nc"><i>761</i>&nbsp;                Utils.log.fine(&quot;big string[&quot;+i+&quot;] normalSize=&quot;+normalSizes[BYTE_SIZE]+&quot;/z=&quot;+normalSizes[ZIP_SIZE]+&quot; win=&quot;+(specialZipSize&lt;normalZipSize-minWin));</b>
<b class="nc"><i>762</i>&nbsp;            if (specialZipSize &lt; normalZipSize-minWin) {</b>
<b class="nc"><i>763</i>&nbsp;                IntBand big = cp_Utf8_big_chars.newIntBand(bandName);</b>
<b class="nc"><i>764</i>&nbsp;                big.initializeValues(cvals);</b>
<b class="nc"><i>765</i>&nbsp;                return true;</b>
<i>766</i>&nbsp;            }
<i>767</i>&nbsp;        }
<b class="nc"><i>768</i>&nbsp;        return false;</b>
<i>769</i>&nbsp;    }
<i>770</i>&nbsp;
<i>771</i>&nbsp;    void writeSignatureBands(Entry[] cpMap) throws IOException {
<b class="nc"><i>772</i>&nbsp;        for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>773</i>&nbsp;            SignatureEntry e = (SignatureEntry) cpMap[i];</b>
<b class="nc"><i>774</i>&nbsp;            cp_Signature_form.putRef(e.formRef);</b>
<b class="nc"><i>775</i>&nbsp;            for (int j = 0; j &lt; e.classRefs.length; j++) {</b>
<b class="nc"><i>776</i>&nbsp;                cp_Signature_classes.putRef(e.classRefs[j]);</b>
<i>777</i>&nbsp;            }
<i>778</i>&nbsp;        }
<i>779</i>&nbsp;    }
<i>780</i>&nbsp;
<i>781</i>&nbsp;    void writeMemberRefs(byte tag, Entry[] cpMap, CPRefBand cp_class, CPRefBand cp_desc) throws IOException {
<b class="nc"><i>782</i>&nbsp;        for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>783</i>&nbsp;            MemberEntry e = (MemberEntry) cpMap[i];</b>
<b class="nc"><i>784</i>&nbsp;            cp_class.putRef(e.classRef);</b>
<b class="nc"><i>785</i>&nbsp;            cp_desc.putRef(e.descRef);</b>
<i>786</i>&nbsp;        }
<i>787</i>&nbsp;    }
<i>788</i>&nbsp;
<i>789</i>&nbsp;    void writeFiles() throws IOException {
<b class="nc"><i>790</i>&nbsp;        int numFiles = pkg.files.size();</b>
<b class="nc"><i>791</i>&nbsp;        if (numFiles == 0)  return;</b>
<b class="nc"><i>792</i>&nbsp;        int options = archiveOptions;</b>
<b class="nc"><i>793</i>&nbsp;        boolean haveSizeHi  = testBit(options, AO_HAVE_FILE_SIZE_HI);</b>
<b class="nc"><i>794</i>&nbsp;        boolean haveModtime = testBit(options, AO_HAVE_FILE_MODTIME);</b>
<b class="nc"><i>795</i>&nbsp;        boolean haveOptions = testBit(options, AO_HAVE_FILE_OPTIONS);</b>
<b class="nc"><i>796</i>&nbsp;        if (!haveOptions) {</b>
<b class="nc"><i>797</i>&nbsp;            for (File file : pkg.files) {</b>
<b class="nc"><i>798</i>&nbsp;                if (file.isClassStub()) {</b>
<b class="nc"><i>799</i>&nbsp;                    haveOptions = true;</b>
<b class="nc"><i>800</i>&nbsp;                    options |= AO_HAVE_FILE_OPTIONS;</b>
<b class="nc"><i>801</i>&nbsp;                    archiveOptions = options;</b>
<b class="nc"><i>802</i>&nbsp;                    break;</b>
<i>803</i>&nbsp;                }
<b class="nc"><i>804</i>&nbsp;            }</b>
<i>805</i>&nbsp;        }
<b class="nc"><i>806</i>&nbsp;        if (haveSizeHi || haveModtime || haveOptions || !pkg.files.isEmpty()) {</b>
<b class="nc"><i>807</i>&nbsp;            options |= AO_HAVE_FILE_HEADERS;</b>
<b class="nc"><i>808</i>&nbsp;            archiveOptions = options;</b>
<i>809</i>&nbsp;        }
<b class="nc"><i>810</i>&nbsp;        for (File file : pkg.files) {</b>
<b class="nc"><i>811</i>&nbsp;            file_name.putRef(file.name);</b>
<b class="nc"><i>812</i>&nbsp;            long len = file.getFileLength();</b>
<b class="nc"><i>813</i>&nbsp;            file_size_lo.putInt((int)len);</b>
<b class="nc"><i>814</i>&nbsp;            if (haveSizeHi)</b>
<b class="nc"><i>815</i>&nbsp;                file_size_hi.putInt((int)(len &gt;&gt;&gt; 32));</b>
<b class="nc"><i>816</i>&nbsp;            if (haveModtime)</b>
<b class="nc"><i>817</i>&nbsp;                file_modtime.putInt(file.modtime - pkg.default_modtime);</b>
<b class="nc"><i>818</i>&nbsp;            if (haveOptions)</b>
<b class="nc"><i>819</i>&nbsp;                file_options.putInt(file.options);</b>
<b class="nc"><i>820</i>&nbsp;            file.writeTo(file_bits.collectorStream());</b>
<b class="nc"><i>821</i>&nbsp;            if (verbose &gt; 1)</b>
<b class="nc"><i>822</i>&nbsp;                Utils.log.fine(&quot;Wrote &quot;+len+&quot; bytes of &quot;+file.name.stringValue());</b>
<b class="nc"><i>823</i>&nbsp;        }</b>
<b class="nc"><i>824</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>825</i>&nbsp;            Utils.log.info(&quot;Wrote &quot;+numFiles+&quot; resource files&quot;);</b>
<i>826</i>&nbsp;    }
<i>827</i>&nbsp;
<i>828</i>&nbsp;    void collectAttributeLayouts() {
<b class="nc"><i>829</i>&nbsp;        maxFlags = new int[ATTR_CONTEXT_LIMIT];</b>
<b class="nc"><i>830</i>&nbsp;        allLayouts = new FixedList&lt;&gt;(ATTR_CONTEXT_LIMIT);</b>
<b class="nc"><i>831</i>&nbsp;        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</b>
<b class="nc"><i>832</i>&nbsp;            allLayouts.set(i, new HashMap&lt;&gt;());</b>
<i>833</i>&nbsp;        }
<i>834</i>&nbsp;        // Collect maxFlags and allLayouts.
<b class="nc"><i>835</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>836</i>&nbsp;            visitAttributeLayoutsIn(ATTR_CONTEXT_CLASS, cls);</b>
<b class="nc"><i>837</i>&nbsp;            for (Class.Field f : cls.getFields()) {</b>
<b class="nc"><i>838</i>&nbsp;                visitAttributeLayoutsIn(ATTR_CONTEXT_FIELD, f);</b>
<b class="nc"><i>839</i>&nbsp;            }</b>
<b class="nc"><i>840</i>&nbsp;            for (Class.Method m : cls.getMethods()) {</b>
<b class="nc"><i>841</i>&nbsp;                visitAttributeLayoutsIn(ATTR_CONTEXT_METHOD, m);</b>
<b class="nc"><i>842</i>&nbsp;                if (m.code != null) {</b>
<b class="nc"><i>843</i>&nbsp;                    visitAttributeLayoutsIn(ATTR_CONTEXT_CODE, m.code);</b>
<i>844</i>&nbsp;                }
<b class="nc"><i>845</i>&nbsp;            }</b>
<b class="nc"><i>846</i>&nbsp;        }</b>
<i>847</i>&nbsp;        // If there are many species of attributes, use 63-bit flags.
<b class="nc"><i>848</i>&nbsp;        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</b>
<b class="nc"><i>849</i>&nbsp;            int nl = allLayouts.get(i).size();</b>
<b class="nc"><i>850</i>&nbsp;            boolean haveLongFlags = haveFlagsHi(i);</b>
<i>851</i>&nbsp;            final int TOO_MANY_ATTRS = 32 /*int flag size*/
<i>852</i>&nbsp;                - 12 /*typical flag bits in use*/
<i>853</i>&nbsp;                + 4  /*typical number of OK overflows*/;
<b class="nc"><i>854</i>&nbsp;            if (nl &gt;= TOO_MANY_ATTRS) {  // heuristic</b>
<b class="nc"><i>855</i>&nbsp;                int mask = 1&lt;&lt;(LG_AO_HAVE_XXX_FLAGS_HI+i);</b>
<b class="nc"><i>856</i>&nbsp;                archiveOptions |= mask;</b>
<b class="nc"><i>857</i>&nbsp;                haveLongFlags = true;</b>
<b class="nc"><i>858</i>&nbsp;                if (verbose &gt; 0)</b>
<b class="nc"><i>859</i>&nbsp;                   Utils.log.info(&quot;Note: Many &quot;+Attribute.contextName(i)+&quot; attributes forces 63-bit flags&quot;);</b>
<i>860</i>&nbsp;            }
<b class="nc"><i>861</i>&nbsp;            if (verbose &gt; 1) {</b>
<b class="nc"><i>862</i>&nbsp;                Utils.log.fine(Attribute.contextName(i)+&quot;.maxFlags = 0x&quot;+Integer.toHexString(maxFlags[i]));</b>
<b class="nc"><i>863</i>&nbsp;                Utils.log.fine(Attribute.contextName(i)+&quot;.#layouts = &quot;+nl);</b>
<i>864</i>&nbsp;            }
<b class="nc"><i>865</i>&nbsp;            assert(haveFlagsHi(i) == haveLongFlags);</b>
<i>866</i>&nbsp;        }
<b class="nc"><i>867</i>&nbsp;        initAttrIndexLimit();</b>
<i>868</i>&nbsp;
<i>869</i>&nbsp;        // Standard indexes can never conflict with flag bits.  Assert it.
<b class="nc"><i>870</i>&nbsp;        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</b>
<b class="nc"><i>871</i>&nbsp;            assert((attrFlagMask[i] &amp; maxFlags[i]) == 0);</b>
<i>872</i>&nbsp;        }
<i>873</i>&nbsp;        // Collect counts for both predefs. and custom defs.
<i>874</i>&nbsp;        // Decide on custom, local attribute definitions.
<b class="nc"><i>875</i>&nbsp;        backCountTable = new HashMap&lt;&gt;();</b>
<b class="nc"><i>876</i>&nbsp;        attrCounts = new int[ATTR_CONTEXT_LIMIT][];</b>
<b class="nc"><i>877</i>&nbsp;        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</b>
<i>878</i>&nbsp;            // Now the remaining defs in allLayouts[i] need attr. indexes.
<i>879</i>&nbsp;            // Fill up unused flag bits with new defs.
<i>880</i>&nbsp;            // Unused bits are those which are not used by predefined attrs,
<i>881</i>&nbsp;            // and which are always clear in the classfiles.
<b class="nc"><i>882</i>&nbsp;            long avHiBits = ~(maxFlags[i] | attrFlagMask[i]);</b>
<b class="nc"><i>883</i>&nbsp;            assert(attrIndexLimit[i] &gt; 0);</b>
<b class="nc"><i>884</i>&nbsp;            assert(attrIndexLimit[i] &lt; 64);  // all bits fit into a Java long</b>
<b class="nc"><i>885</i>&nbsp;            avHiBits &amp;= (1L&lt;&lt;attrIndexLimit[i])-1;</b>
<b class="nc"><i>886</i>&nbsp;            int nextLoBit = 0;</b>
<b class="nc"><i>887</i>&nbsp;            Map&lt;Attribute.Layout, int[]&gt; defMap = allLayouts.get(i);</b>
<i>888</i>&nbsp;            @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<b class="nc"><i>889</i>&nbsp;            Map.Entry&lt;Attribute.Layout, int[]&gt;[] layoutsAndCounts =</b>
<b class="nc"><i>890</i>&nbsp;                    new Map.Entry[defMap.size()];</b>
<b class="nc"><i>891</i>&nbsp;            defMap.entrySet().toArray(layoutsAndCounts);</b>
<i>892</i>&nbsp;            // Sort by count, most frequent first.
<i>893</i>&nbsp;            // Predefs. participate in this sort, though it does not matter.
<b class="nc"><i>894</i>&nbsp;            Arrays.sort(layoutsAndCounts,</b>
<b class="nc"><i>895</i>&nbsp;                        new Comparator&lt;&gt;() {</b>
<i>896</i>&nbsp;                public int compare(Map.Entry&lt;Attribute.Layout, int[]&gt; e0,
<i>897</i>&nbsp;                                   Map.Entry&lt;Attribute.Layout, int[]&gt; e1) {
<i>898</i>&nbsp;                    // Primary sort key is count, reversed.
<b class="nc"><i>899</i>&nbsp;                    int r = -(e0.getValue()[0] - e1.getValue()[0]);</b>
<b class="nc"><i>900</i>&nbsp;                    if (r != 0)  return r;</b>
<b class="nc"><i>901</i>&nbsp;                    return e0.getKey().compareTo(e1.getKey());</b>
<i>902</i>&nbsp;                }
<i>903</i>&nbsp;            });
<b class="nc"><i>904</i>&nbsp;            attrCounts[i] = new int[attrIndexLimit[i]+layoutsAndCounts.length];</b>
<b class="nc"><i>905</i>&nbsp;            for (int j = 0; j &lt; layoutsAndCounts.length; j++) {</b>
<b class="nc"><i>906</i>&nbsp;                Map.Entry&lt;Attribute.Layout, int[]&gt; e = layoutsAndCounts[j];</b>
<b class="nc"><i>907</i>&nbsp;                Attribute.Layout def = e.getKey();</b>
<b class="nc"><i>908</i>&nbsp;                int count = e.getValue()[0];</b>
<i>909</i>&nbsp;                int index;
<b class="nc"><i>910</i>&nbsp;                Integer predefIndex = attrIndexTable.get(def);</b>
<b class="nc"><i>911</i>&nbsp;                if (predefIndex != null) {</b>
<i>912</i>&nbsp;                    // The index is already set.
<b class="nc"><i>913</i>&nbsp;                    index = predefIndex.intValue();</b>
<b class="nc"><i>914</i>&nbsp;                } else if (avHiBits != 0) {</b>
<b class="nc"><i>915</i>&nbsp;                    while ((avHiBits &amp; 1) == 0) {</b>
<b class="nc"><i>916</i>&nbsp;                        avHiBits &gt;&gt;&gt;= 1;</b>
<b class="nc"><i>917</i>&nbsp;                        nextLoBit += 1;</b>
<i>918</i>&nbsp;                    }
<b class="nc"><i>919</i>&nbsp;                    avHiBits -= 1;  // clear low bit; we are using it now</b>
<i>920</i>&nbsp;                    // Update attrIndexTable:
<b class="nc"><i>921</i>&nbsp;                    index = setAttributeLayoutIndex(def, nextLoBit);</b>
<i>922</i>&nbsp;                } else {
<i>923</i>&nbsp;                    // Update attrIndexTable:
<b class="nc"><i>924</i>&nbsp;                    index = setAttributeLayoutIndex(def, ATTR_INDEX_OVERFLOW);</b>
<i>925</i>&nbsp;                }
<i>926</i>&nbsp;
<i>927</i>&nbsp;                // Now that we know the index, record the count of this def.
<b class="nc"><i>928</i>&nbsp;                attrCounts[i][index] = count;</b>
<i>929</i>&nbsp;
<i>930</i>&nbsp;                // For all callables in the def, keep a tally of back-calls.
<b class="nc"><i>931</i>&nbsp;                Attribute.Layout.Element[] cbles = def.getCallables();</b>
<b class="nc"><i>932</i>&nbsp;                final int[] bc = new int[cbles.length];</b>
<b class="nc"><i>933</i>&nbsp;                for (int k = 0; k &lt; cbles.length; k++) {</b>
<b class="nc"><i>934</i>&nbsp;                    assert(cbles[k].kind == Attribute.EK_CBLE);</b>
<b class="nc"><i>935</i>&nbsp;                    if (!cbles[k].flagTest(Attribute.EF_BACK)) {</b>
<b class="nc"><i>936</i>&nbsp;                        bc[k] = -1;  // no count to accumulate here</b>
<i>937</i>&nbsp;                    }
<i>938</i>&nbsp;                }
<b class="nc"><i>939</i>&nbsp;                backCountTable.put(def, bc);</b>
<i>940</i>&nbsp;
<b class="nc"><i>941</i>&nbsp;                if (predefIndex == null) {</b>
<i>942</i>&nbsp;                    // Make sure the package CP can name the local attribute.
<b class="nc"><i>943</i>&nbsp;                    Entry ne = ConstantPool.getUtf8Entry(def.name());</b>
<b class="nc"><i>944</i>&nbsp;                    String layout = def.layoutForClassVersion(getHighestClassVersion());</b>
<b class="nc"><i>945</i>&nbsp;                    Entry le = ConstantPool.getUtf8Entry(layout);</b>
<b class="nc"><i>946</i>&nbsp;                    requiredEntries.add(ne);</b>
<b class="nc"><i>947</i>&nbsp;                    requiredEntries.add(le);</b>
<b class="nc"><i>948</i>&nbsp;                    if (verbose &gt; 0) {</b>
<b class="nc"><i>949</i>&nbsp;                        if (index &lt; attrIndexLimit[i])</b>
<b class="nc"><i>950</i>&nbsp;                           Utils.log.info(&quot;Using free flag bit 1&lt;&lt;&quot;+index+&quot; for &quot;+count+&quot; occurrences of &quot;+def);</b>
<i>951</i>&nbsp;                        else
<b class="nc"><i>952</i>&nbsp;                            Utils.log.info(&quot;Using overflow index &quot;+index+&quot; for &quot;+count+&quot; occurrences of &quot;+def);</b>
<i>953</i>&nbsp;                    }
<i>954</i>&nbsp;                }
<i>955</i>&nbsp;            }
<i>956</i>&nbsp;        }
<i>957</i>&nbsp;        // Later, when emitting attr_definition_bands, we will look at
<i>958</i>&nbsp;        // attrDefSeen and attrDefs at position 32/63 and beyond.
<i>959</i>&nbsp;        // The attrIndexTable will provide elements of xxx_attr_indexes bands.
<i>960</i>&nbsp;
<i>961</i>&nbsp;        // Done with scratch variables:
<b class="nc"><i>962</i>&nbsp;        maxFlags = null;</b>
<b class="nc"><i>963</i>&nbsp;        allLayouts = null;</b>
<i>964</i>&nbsp;    }
<i>965</i>&nbsp;
<i>966</i>&nbsp;    // Scratch variables for processing attributes and flags.
<i>967</i>&nbsp;    int[] maxFlags;
<i>968</i>&nbsp;    List&lt;Map&lt;Attribute.Layout, int[]&gt;&gt; allLayouts;
<i>969</i>&nbsp;
<i>970</i>&nbsp;    void visitAttributeLayoutsIn(int ctype, Attribute.Holder h) {
<i>971</i>&nbsp;        // Make note of which flags appear in the class file.
<i>972</i>&nbsp;        // Set them in maxFlags.
<b class="nc"><i>973</i>&nbsp;        maxFlags[ctype] |= h.flags;</b>
<b class="nc"><i>974</i>&nbsp;        for (Attribute a : h.getAttributes()) {</b>
<b class="nc"><i>975</i>&nbsp;            Attribute.Layout def = a.layout();</b>
<b class="nc"><i>976</i>&nbsp;            Map&lt;Attribute.Layout, int[]&gt; defMap = allLayouts.get(ctype);</b>
<b class="nc"><i>977</i>&nbsp;            int[] count = defMap.get(def);</b>
<b class="nc"><i>978</i>&nbsp;            if (count == null) {</b>
<b class="nc"><i>979</i>&nbsp;                defMap.put(def, count = new int[1]);</b>
<i>980</i>&nbsp;            }
<b class="nc"><i>981</i>&nbsp;            if (count[0] &lt; Integer.MAX_VALUE) {</b>
<b class="nc"><i>982</i>&nbsp;                count[0] += 1;</b>
<i>983</i>&nbsp;            }
<b class="nc"><i>984</i>&nbsp;        }</b>
<i>985</i>&nbsp;    }
<i>986</i>&nbsp;
<i>987</i>&nbsp;    Attribute.Layout[] attrDefsWritten;
<i>988</i>&nbsp;
<i>989</i>&nbsp;    void writeAttrDefs() throws IOException {
<b class="nc"><i>990</i>&nbsp;        List&lt;Object[]&gt; defList = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>991</i>&nbsp;        for (int i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {</b>
<b class="nc"><i>992</i>&nbsp;            int limit = attrDefs.get(i).size();</b>
<b class="nc"><i>993</i>&nbsp;            for (int j = 0; j &lt; limit; j++) {</b>
<b class="nc"><i>994</i>&nbsp;                int header = i;  // ctype</b>
<b class="nc"><i>995</i>&nbsp;                if (j &lt; attrIndexLimit[i]) {</b>
<b class="nc"><i>996</i>&nbsp;                    header |= ((j + ADH_BIT_IS_LSB) &lt;&lt; ADH_BIT_SHIFT);</b>
<b class="nc"><i>997</i>&nbsp;                    assert(header &lt; 0x100);  // must fit into a byte</b>
<i>998</i>&nbsp;                    // (...else header is simply ctype, with zero high bits.)
<b class="nc"><i>999</i>&nbsp;                    if (!testBit(attrDefSeen[i], 1L&lt;&lt;j)) {</b>
<i>1000</i>&nbsp;                        // either undefined or predefined; nothing to write
<b class="nc"><i>1001</i>&nbsp;                        continue;</b>
<i>1002</i>&nbsp;                    }
<i>1003</i>&nbsp;                }
<b class="nc"><i>1004</i>&nbsp;                Attribute.Layout def = attrDefs.get(i).get(j);</b>
<b class="nc"><i>1005</i>&nbsp;                defList.add(new Object[]{ Integer.valueOf(header), def });</b>
<b class="nc"><i>1006</i>&nbsp;                assert(Integer.valueOf(j).equals(attrIndexTable.get(def)));</b>
<i>1007</i>&nbsp;            }
<i>1008</i>&nbsp;        }
<i>1009</i>&nbsp;        // Sort the new attr defs into some &quot;natural&quot; order.
<b class="nc"><i>1010</i>&nbsp;        int numAttrDefs = defList.size();</b>
<b class="nc"><i>1011</i>&nbsp;        Object[][] defs = new Object[numAttrDefs][];</b>
<b class="nc"><i>1012</i>&nbsp;        defList.toArray(defs);</b>
<b class="nc"><i>1013</i>&nbsp;        Arrays.sort(defs, new Comparator&lt;&gt;() {</b>
<i>1014</i>&nbsp;            public int compare(Object[] a0, Object[] a1) {
<i>1015</i>&nbsp;                // Primary sort key is attr def header.
<i>1016</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>1017</i>&nbsp;                int r = ((Comparable)a0[0]).compareTo(a1[0]);</b>
<b class="nc"><i>1018</i>&nbsp;                if (r != 0)  return r;</b>
<b class="nc"><i>1019</i>&nbsp;                Integer ind0 = attrIndexTable.get(a0[1]);</b>
<b class="nc"><i>1020</i>&nbsp;                Integer ind1 = attrIndexTable.get(a1[1]);</b>
<i>1021</i>&nbsp;                // Secondary sort key is attribute index.
<i>1022</i>&nbsp;                // (This must be so, in order to keep overflow attr order.)
<b class="nc"><i>1023</i>&nbsp;                assert(ind0 != null);</b>
<b class="nc"><i>1024</i>&nbsp;                assert(ind1 != null);</b>
<b class="nc"><i>1025</i>&nbsp;                return ind0.compareTo(ind1);</b>
<i>1026</i>&nbsp;            }
<i>1027</i>&nbsp;        });
<b class="nc"><i>1028</i>&nbsp;        attrDefsWritten = new Attribute.Layout[numAttrDefs];</b>
<b class="nc"><i>1029</i>&nbsp;        try (PrintStream dump = !optDumpBands ? null</b>
<b class="nc"><i>1030</i>&nbsp;                 : new PrintStream(getDumpStream(attr_definition_headers, &quot;.def&quot;)))</b>
<i>1031</i>&nbsp;        {
<b class="nc"><i>1032</i>&nbsp;            int[] indexForDebug = Arrays.copyOf(attrIndexLimit, ATTR_CONTEXT_LIMIT);</b>
<b class="nc"><i>1033</i>&nbsp;            for (int i = 0; i &lt; defs.length; i++) {</b>
<b class="nc"><i>1034</i>&nbsp;                int header = ((Integer)defs[i][0]).intValue();</b>
<b class="nc"><i>1035</i>&nbsp;                Attribute.Layout def = (Attribute.Layout) defs[i][1];</b>
<b class="nc"><i>1036</i>&nbsp;                attrDefsWritten[i] = def;</b>
<b class="nc"><i>1037</i>&nbsp;                assert((header &amp; ADH_CONTEXT_MASK) == def.ctype());</b>
<b class="nc"><i>1038</i>&nbsp;                attr_definition_headers.putByte(header);</b>
<b class="nc"><i>1039</i>&nbsp;                attr_definition_name.putRef(ConstantPool.getUtf8Entry(def.name()));</b>
<b class="nc"><i>1040</i>&nbsp;                String layout = def.layoutForClassVersion(getHighestClassVersion());</b>
<b class="nc"><i>1041</i>&nbsp;                attr_definition_layout.putRef(ConstantPool.getUtf8Entry(layout));</b>
<i>1042</i>&nbsp;                // Check that we are transmitting that correct attribute index:
<b class="nc"><i>1043</i>&nbsp;                boolean debug = false;</b>
<b class="nc"><i>1044</i>&nbsp;                assert(debug = true);</b>
<b class="nc"><i>1045</i>&nbsp;                if (debug) {</b>
<b class="nc"><i>1046</i>&nbsp;                    int hdrIndex = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</b>
<b class="nc"><i>1047</i>&nbsp;                    if (hdrIndex &lt; 0)  hdrIndex = indexForDebug[def.ctype()]++;</b>
<b class="nc"><i>1048</i>&nbsp;                    int realIndex = (attrIndexTable.get(def)).intValue();</b>
<b class="nc"><i>1049</i>&nbsp;                    assert(hdrIndex == realIndex);</b>
<i>1050</i>&nbsp;                }
<b class="nc"><i>1051</i>&nbsp;                if (dump != null) {</b>
<b class="nc"><i>1052</i>&nbsp;                    int index = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</b>
<b class="nc"><i>1053</i>&nbsp;                    dump.println(index+&quot; &quot;+def);</b>
<i>1054</i>&nbsp;                }
<i>1055</i>&nbsp;            }
<b class="nc"><i>1056</i>&nbsp;        }</b>
<i>1057</i>&nbsp;    }
<i>1058</i>&nbsp;
<i>1059</i>&nbsp;    void writeAttrCounts() throws IOException {
<i>1060</i>&nbsp;        // Write the four xxx_attr_calls bands.
<b class="nc"><i>1061</i>&nbsp;        for (int ctype = 0; ctype &lt; ATTR_CONTEXT_LIMIT; ctype++) {</b>
<b class="nc"><i>1062</i>&nbsp;            MultiBand xxx_attr_bands = attrBands[ctype];</b>
<b class="nc"><i>1063</i>&nbsp;            IntBand xxx_attr_calls = getAttrBand(xxx_attr_bands, AB_ATTR_CALLS);</b>
<b class="nc"><i>1064</i>&nbsp;            Attribute.Layout[] defs = new Attribute.Layout[attrDefs.get(ctype).size()];</b>
<b class="nc"><i>1065</i>&nbsp;            attrDefs.get(ctype).toArray(defs);</b>
<b class="nc"><i>1066</i>&nbsp;            for (boolean predef = true; ; predef = false) {</b>
<b class="nc"><i>1067</i>&nbsp;                for (int ai = 0; ai &lt; defs.length; ai++) {</b>
<b class="nc"><i>1068</i>&nbsp;                    Attribute.Layout def = defs[ai];</b>
<b class="nc"><i>1069</i>&nbsp;                    if (def == null)  continue;  // unused index</b>
<b class="nc"><i>1070</i>&nbsp;                    if (predef != isPredefinedAttr(ctype, ai))</b>
<b class="nc"><i>1071</i>&nbsp;                        continue;  // wrong pass</b>
<b class="nc"><i>1072</i>&nbsp;                    int totalCount = attrCounts[ctype][ai];</b>
<b class="nc"><i>1073</i>&nbsp;                    if (totalCount == 0)</b>
<b class="nc"><i>1074</i>&nbsp;                        continue;  // irrelevant</b>
<b class="nc"><i>1075</i>&nbsp;                    int[] bc = backCountTable.get(def);</b>
<b class="nc"><i>1076</i>&nbsp;                    for (int j = 0; j &lt; bc.length; j++) {</b>
<b class="nc"><i>1077</i>&nbsp;                        if (bc[j] &gt;= 0) {</b>
<b class="nc"><i>1078</i>&nbsp;                            int backCount = bc[j];</b>
<b class="nc"><i>1079</i>&nbsp;                            bc[j] = -1;  // close out; do not collect further counts</b>
<b class="nc"><i>1080</i>&nbsp;                            xxx_attr_calls.putInt(backCount);</b>
<b class="nc"><i>1081</i>&nbsp;                            assert(def.getCallables()[j].flagTest(Attribute.EF_BACK));</b>
<b class="nc"><i>1082</i>&nbsp;                        } else {</b>
<b class="nc"><i>1083</i>&nbsp;                            assert(!def.getCallables()[j].flagTest(Attribute.EF_BACK));</b>
<i>1084</i>&nbsp;                        }
<i>1085</i>&nbsp;                    }
<i>1086</i>&nbsp;                }
<b class="nc"><i>1087</i>&nbsp;                if (!predef)  break;</b>
<i>1088</i>&nbsp;            }
<i>1089</i>&nbsp;        }
<i>1090</i>&nbsp;    }
<i>1091</i>&nbsp;
<i>1092</i>&nbsp;    void trimClassAttributes() {
<b class="nc"><i>1093</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<i>1094</i>&nbsp;            // Replace &quot;obvious&quot; SourceFile attrs by null.
<b class="nc"><i>1095</i>&nbsp;            cls.minimizeSourceFile();</b>
<i>1096</i>&nbsp;            // BootstrapMethods should never have been inserted.
<b class="nc"><i>1097</i>&nbsp;            assert(cls.getAttribute(Package.attrBootstrapMethodsEmpty) == null);</b>
<b class="nc"><i>1098</i>&nbsp;        }</b>
<i>1099</i>&nbsp;    }
<i>1100</i>&nbsp;
<i>1101</i>&nbsp;    void collectInnerClasses() {
<i>1102</i>&nbsp;        // Capture inner classes, removing them from individual classes.
<i>1103</i>&nbsp;        // Irregular inner classes must stay local, though.
<b class="nc"><i>1104</i>&nbsp;        Map&lt;ClassEntry, InnerClass&gt; allICMap = new HashMap&lt;&gt;();</b>
<i>1105</i>&nbsp;        // First, collect a consistent global set.
<b class="nc"><i>1106</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>1107</i>&nbsp;            if (!cls.hasInnerClasses())  continue;</b>
<b class="nc"><i>1108</i>&nbsp;            for (InnerClass ic : cls.getInnerClasses()) {</b>
<b class="nc"><i>1109</i>&nbsp;                InnerClass pic = allICMap.put(ic.thisClass, ic);</b>
<b class="nc"><i>1110</i>&nbsp;                if (pic != null &amp;&amp; !pic.equals(ic) &amp;&amp; pic.predictable) {</b>
<i>1111</i>&nbsp;                    // Different ICs.  Choose the better to make global.
<b class="nc"><i>1112</i>&nbsp;                    allICMap.put(pic.thisClass, pic);</b>
<i>1113</i>&nbsp;                }
<b class="nc"><i>1114</i>&nbsp;            }</b>
<b class="nc"><i>1115</i>&nbsp;        }</b>
<i>1116</i>&nbsp;
<b class="nc"><i>1117</i>&nbsp;        InnerClass[] allICs = new InnerClass[allICMap.size()];</b>
<b class="nc"><i>1118</i>&nbsp;        allICMap.values().toArray(allICs);</b>
<b class="nc"><i>1119</i>&nbsp;        allICMap = null;  // done with it</b>
<i>1120</i>&nbsp;
<i>1121</i>&nbsp;        // Note: The InnerClasses attribute must be in a valid order,
<i>1122</i>&nbsp;        // so that A$B always occurs earlier than A$B$C.  This is an
<i>1123</i>&nbsp;        // important side-effect of sorting lexically by class name.
<b class="nc"><i>1124</i>&nbsp;        Arrays.sort(allICs);  // put in canonical order</b>
<b class="nc"><i>1125</i>&nbsp;        pkg.setAllInnerClasses(Arrays.asList(allICs));</b>
<i>1126</i>&nbsp;
<i>1127</i>&nbsp;        // Next, empty out of every local set the consistent entries.
<i>1128</i>&nbsp;        // Calculate whether there is any remaining need to have a local
<i>1129</i>&nbsp;        // set, and whether it needs to be locked.
<b class="nc"><i>1130</i>&nbsp;        for (Class cls : pkg.classes) {</b>
<b class="nc"><i>1131</i>&nbsp;            cls.minimizeLocalICs();</b>
<b class="nc"><i>1132</i>&nbsp;        }</b>
<i>1133</i>&nbsp;    }
<i>1134</i>&nbsp;
<i>1135</i>&nbsp;    void writeInnerClasses() throws IOException {
<b class="nc"><i>1136</i>&nbsp;        for (InnerClass ic : pkg.getAllInnerClasses()) {</b>
<b class="nc"><i>1137</i>&nbsp;            int flags = ic.flags;</b>
<b class="nc"><i>1138</i>&nbsp;            assert((flags &amp; ACC_IC_LONG_FORM) == 0);</b>
<b class="nc"><i>1139</i>&nbsp;            if (!ic.predictable) {</b>
<b class="nc"><i>1140</i>&nbsp;                flags |= ACC_IC_LONG_FORM;</b>
<i>1141</i>&nbsp;            }
<b class="nc"><i>1142</i>&nbsp;            ic_this_class.putRef(ic.thisClass);</b>
<b class="nc"><i>1143</i>&nbsp;            ic_flags.putInt(flags);</b>
<b class="nc"><i>1144</i>&nbsp;            if (!ic.predictable) {</b>
<b class="nc"><i>1145</i>&nbsp;                ic_outer_class.putRef(ic.outerClass);</b>
<b class="nc"><i>1146</i>&nbsp;                ic_name.putRef(ic.name);</b>
<i>1147</i>&nbsp;            }
<b class="nc"><i>1148</i>&nbsp;        }</b>
<i>1149</i>&nbsp;    }
<i>1150</i>&nbsp;
<i>1151</i>&nbsp;    /** If there are any extra InnerClasses entries to write which are
<i>1152</i>&nbsp;     *  not already implied by the global table, put them into a
<i>1153</i>&nbsp;     *  local attribute.  This is expected to be rare.
<i>1154</i>&nbsp;     */
<i>1155</i>&nbsp;    void writeLocalInnerClasses(Class cls) throws IOException {
<b class="nc"><i>1156</i>&nbsp;        List&lt;InnerClass&gt; localICs = cls.getInnerClasses();</b>
<b class="nc"><i>1157</i>&nbsp;        class_InnerClasses_N.putInt(localICs.size());</b>
<b class="nc"><i>1158</i>&nbsp;        for(InnerClass ic : localICs) {</b>
<b class="nc"><i>1159</i>&nbsp;            class_InnerClasses_RC.putRef(ic.thisClass);</b>
<i>1160</i>&nbsp;            // Is it redundant with the global version?
<b class="nc"><i>1161</i>&nbsp;            if (ic.equals(pkg.getGlobalInnerClass(ic.thisClass))) {</b>
<i>1162</i>&nbsp;                // A zero flag means copy a global IC here.
<b class="nc"><i>1163</i>&nbsp;                class_InnerClasses_F.putInt(0);</b>
<i>1164</i>&nbsp;            } else {
<b class="nc"><i>1165</i>&nbsp;                int flags = ic.flags;</b>
<b class="nc"><i>1166</i>&nbsp;                if (flags == 0)</b>
<b class="nc"><i>1167</i>&nbsp;                    flags = ACC_IC_LONG_FORM;  // force it to be non-zero</b>
<b class="nc"><i>1168</i>&nbsp;                class_InnerClasses_F.putInt(flags);</b>
<b class="nc"><i>1169</i>&nbsp;                class_InnerClasses_outer_RCN.putRef(ic.outerClass);</b>
<b class="nc"><i>1170</i>&nbsp;                class_InnerClasses_name_RUN.putRef(ic.name);</b>
<i>1171</i>&nbsp;            }
<b class="nc"><i>1172</i>&nbsp;        }</b>
<i>1173</i>&nbsp;    }
<i>1174</i>&nbsp;
<i>1175</i>&nbsp;    void writeClassesAndByteCodes() throws IOException {
<b class="nc"><i>1176</i>&nbsp;        Class[] classes = new Class[pkg.classes.size()];</b>
<b class="nc"><i>1177</i>&nbsp;        pkg.classes.toArray(classes);</b>
<i>1178</i>&nbsp;        // Note:  This code respects the order in which caller put classes.
<b class="nc"><i>1179</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>1180</i>&nbsp;            Utils.log.info(&quot;  ...scanning &quot;+classes.length+&quot; classes...&quot;);</b>
<i>1181</i>&nbsp;
<b class="nc"><i>1182</i>&nbsp;        int nwritten = 0;</b>
<b class="nc"><i>1183</i>&nbsp;        for (int i = 0; i &lt; classes.length; i++) {</b>
<i>1184</i>&nbsp;            // Collect the class body, sans bytecodes.
<b class="nc"><i>1185</i>&nbsp;            Class cls = classes[i];</b>
<b class="nc"><i>1186</i>&nbsp;            if (verbose &gt; 1)</b>
<b class="nc"><i>1187</i>&nbsp;                Utils.log.fine(&quot;Scanning &quot;+cls);</b>
<i>1188</i>&nbsp;
<b class="nc"><i>1189</i>&nbsp;            ClassEntry   thisClass  = cls.thisClass;</b>
<b class="nc"><i>1190</i>&nbsp;            ClassEntry   superClass = cls.superClass;</b>
<b class="nc"><i>1191</i>&nbsp;            ClassEntry[] interfaces = cls.interfaces;</b>
<i>1192</i>&nbsp;            // Encode rare case of null superClass as thisClass:
<b class="nc"><i>1193</i>&nbsp;            assert(superClass != thisClass);  // bad class file!?</b>
<b class="nc"><i>1194</i>&nbsp;            if (superClass == null)  superClass = thisClass;</b>
<b class="nc"><i>1195</i>&nbsp;            class_this.putRef(thisClass);</b>
<b class="nc"><i>1196</i>&nbsp;            class_super.putRef(superClass);</b>
<b class="nc"><i>1197</i>&nbsp;            class_interface_count.putInt(cls.interfaces.length);</b>
<b class="nc"><i>1198</i>&nbsp;            for (int j = 0; j &lt; interfaces.length; j++) {</b>
<b class="nc"><i>1199</i>&nbsp;                class_interface.putRef(interfaces[j]);</b>
<i>1200</i>&nbsp;            }
<i>1201</i>&nbsp;
<b class="nc"><i>1202</i>&nbsp;            writeMembers(cls);</b>
<b class="nc"><i>1203</i>&nbsp;            writeAttrs(ATTR_CONTEXT_CLASS, cls, cls);</b>
<i>1204</i>&nbsp;
<b class="nc"><i>1205</i>&nbsp;            nwritten++;</b>
<b class="nc"><i>1206</i>&nbsp;            if (verbose &gt; 0 &amp;&amp; (nwritten % 1000) == 0)</b>
<b class="nc"><i>1207</i>&nbsp;                Utils.log.info(&quot;Have scanned &quot;+nwritten+&quot; classes...&quot;);</b>
<i>1208</i>&nbsp;        }
<i>1209</i>&nbsp;    }
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;    void writeMembers(Class cls) throws IOException {
<b class="nc"><i>1212</i>&nbsp;        List&lt;Class.Field&gt; fields = cls.getFields();</b>
<b class="nc"><i>1213</i>&nbsp;        class_field_count.putInt(fields.size());</b>
<b class="nc"><i>1214</i>&nbsp;        for (Class.Field f : fields) {</b>
<b class="nc"><i>1215</i>&nbsp;            field_descr.putRef(f.getDescriptor());</b>
<b class="nc"><i>1216</i>&nbsp;            writeAttrs(ATTR_CONTEXT_FIELD, f, cls);</b>
<b class="nc"><i>1217</i>&nbsp;        }</b>
<i>1218</i>&nbsp;
<b class="nc"><i>1219</i>&nbsp;        List&lt;Class.Method&gt; methods = cls.getMethods();</b>
<b class="nc"><i>1220</i>&nbsp;        class_method_count.putInt(methods.size());</b>
<b class="nc"><i>1221</i>&nbsp;        for (Class.Method m : methods) {</b>
<b class="nc"><i>1222</i>&nbsp;            method_descr.putRef(m.getDescriptor());</b>
<b class="nc"><i>1223</i>&nbsp;            writeAttrs(ATTR_CONTEXT_METHOD, m, cls);</b>
<b class="nc"><i>1224</i>&nbsp;            assert((m.code != null) == (m.getAttribute(attrCodeEmpty) != null));</b>
<b class="nc"><i>1225</i>&nbsp;            if (m.code != null) {</b>
<b class="nc"><i>1226</i>&nbsp;                writeCodeHeader(m.code);</b>
<b class="nc"><i>1227</i>&nbsp;                writeByteCodes(m.code);</b>
<i>1228</i>&nbsp;            }
<b class="nc"><i>1229</i>&nbsp;        }</b>
<i>1230</i>&nbsp;    }
<i>1231</i>&nbsp;
<i>1232</i>&nbsp;    void writeCodeHeader(Code c) throws IOException {
<b class="nc"><i>1233</i>&nbsp;        boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);</b>
<b class="nc"><i>1234</i>&nbsp;        int na = c.attributeSize();</b>
<b class="nc"><i>1235</i>&nbsp;        int sc = shortCodeHeader(c);</b>
<b class="nc"><i>1236</i>&nbsp;        if (!attrsOK &amp;&amp; na &gt; 0)</b>
<i>1237</i>&nbsp;            // We must write flags, and can only do so for long headers.
<b class="nc"><i>1238</i>&nbsp;            sc = LONG_CODE_HEADER;</b>
<b class="nc"><i>1239</i>&nbsp;        if (verbose &gt; 2) {</b>
<b class="nc"><i>1240</i>&nbsp;            int siglen = c.getMethod().getArgumentSize();</b>
<b class="nc"><i>1241</i>&nbsp;            Utils.log.fine(&quot;Code sizes info &quot;+c.max_stack+&quot; &quot;+c.max_locals+&quot; &quot;+c.getHandlerCount()+&quot; &quot;+siglen+&quot; &quot;+na+(sc &gt; 0 ? &quot; SHORT=&quot;+sc : &quot;&quot;));</b>
<i>1242</i>&nbsp;        }
<b class="nc"><i>1243</i>&nbsp;        code_headers.putByte(sc);</b>
<b class="nc"><i>1244</i>&nbsp;        if (sc == LONG_CODE_HEADER) {</b>
<b class="nc"><i>1245</i>&nbsp;            code_max_stack.putInt(c.getMaxStack());</b>
<b class="nc"><i>1246</i>&nbsp;            code_max_na_locals.putInt(c.getMaxNALocals());</b>
<b class="nc"><i>1247</i>&nbsp;            code_handler_count.putInt(c.getHandlerCount());</b>
<i>1248</i>&nbsp;        } else {
<b class="nc"><i>1249</i>&nbsp;            assert(attrsOK || na == 0);</b>
<b class="nc"><i>1250</i>&nbsp;            assert(c.getHandlerCount() &lt; shortCodeHeader_h_limit);</b>
<i>1251</i>&nbsp;        }
<b class="nc"><i>1252</i>&nbsp;        writeCodeHandlers(c);</b>
<b class="nc"><i>1253</i>&nbsp;        if (sc == LONG_CODE_HEADER || attrsOK)</b>
<b class="nc"><i>1254</i>&nbsp;            writeAttrs(ATTR_CONTEXT_CODE, c, c.thisClass());</b>
<i>1255</i>&nbsp;    }
<i>1256</i>&nbsp;
<i>1257</i>&nbsp;    void writeCodeHandlers(Code c) throws IOException {
<i>1258</i>&nbsp;        int sum, del;
<b class="nc"><i>1259</i>&nbsp;        for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {</b>
<b class="nc"><i>1260</i>&nbsp;            code_handler_class_RCN.putRef(c.handler_class[j]); // null OK</b>
<i>1261</i>&nbsp;            // Encode end as offset from start, and catch as offset from end,
<i>1262</i>&nbsp;            // because they are strongly correlated.
<b class="nc"><i>1263</i>&nbsp;            sum = c.encodeBCI(c.handler_start[j]);</b>
<b class="nc"><i>1264</i>&nbsp;            code_handler_start_P.putInt(sum);</b>
<b class="nc"><i>1265</i>&nbsp;            del = c.encodeBCI(c.handler_end[j]) - sum;</b>
<b class="nc"><i>1266</i>&nbsp;            code_handler_end_PO.putInt(del);</b>
<b class="nc"><i>1267</i>&nbsp;            sum += del;</b>
<b class="nc"><i>1268</i>&nbsp;            del = c.encodeBCI(c.handler_catch[j]) - sum;</b>
<b class="nc"><i>1269</i>&nbsp;            code_handler_catch_PO.putInt(del);</b>
<i>1270</i>&nbsp;        }
<i>1271</i>&nbsp;    }
<i>1272</i>&nbsp;
<i>1273</i>&nbsp;    // Generic routines for writing attributes and flags of
<i>1274</i>&nbsp;    // classes, fields, methods, and codes.
<i>1275</i>&nbsp;    void writeAttrs(int ctype,
<i>1276</i>&nbsp;                    final Attribute.Holder h,
<i>1277</i>&nbsp;                    Class cls) throws IOException {
<b class="nc"><i>1278</i>&nbsp;        MultiBand xxx_attr_bands = attrBands[ctype];</b>
<b class="nc"><i>1279</i>&nbsp;        IntBand xxx_flags_hi = getAttrBand(xxx_attr_bands, AB_FLAGS_HI);</b>
<b class="nc"><i>1280</i>&nbsp;        IntBand xxx_flags_lo = getAttrBand(xxx_attr_bands, AB_FLAGS_LO);</b>
<b class="nc"><i>1281</i>&nbsp;        boolean haveLongFlags = haveFlagsHi(ctype);</b>
<b class="nc"><i>1282</i>&nbsp;        assert(attrIndexLimit[ctype] == (haveLongFlags? 63: 32));</b>
<b class="nc"><i>1283</i>&nbsp;        if (h.attributes == null) {</b>
<b class="nc"><i>1284</i>&nbsp;            xxx_flags_lo.putInt(h.flags);  // no extra bits to set here</b>
<b class="nc"><i>1285</i>&nbsp;            if (haveLongFlags)</b>
<b class="nc"><i>1286</i>&nbsp;                xxx_flags_hi.putInt(0);</b>
<i>1287</i>&nbsp;            return;
<i>1288</i>&nbsp;        }
<b class="nc"><i>1289</i>&nbsp;        if (verbose &gt; 3)</b>
<b class="nc"><i>1290</i>&nbsp;            Utils.log.fine(&quot;Transmitting attrs for &quot;+h+&quot; flags=&quot;+Integer.toHexString(h.flags));</b>
<i>1291</i>&nbsp;
<b class="nc"><i>1292</i>&nbsp;        long flagMask = attrFlagMask[ctype];  // which flags are attr bits?</b>
<b class="nc"><i>1293</i>&nbsp;        long flagsToAdd = 0;</b>
<b class="nc"><i>1294</i>&nbsp;        int overflowCount = 0;</b>
<b class="nc"><i>1295</i>&nbsp;        for (Attribute a : h.attributes) {</b>
<b class="nc"><i>1296</i>&nbsp;            Attribute.Layout def = a.layout();</b>
<b class="nc"><i>1297</i>&nbsp;            int index = (attrIndexTable.get(def)).intValue();</b>
<b class="nc"><i>1298</i>&nbsp;            assert(attrDefs.get(ctype).get(index) == def);</b>
<b class="nc"><i>1299</i>&nbsp;            if (verbose &gt; 3)</b>
<b class="nc"><i>1300</i>&nbsp;                Utils.log.fine(&quot;add attr @&quot;+index+&quot; &quot;+a+&quot; in &quot;+h);</b>
<b class="nc"><i>1301</i>&nbsp;            if (index &lt; attrIndexLimit[ctype] &amp;&amp; testBit(flagMask, 1L&lt;&lt;index)) {</b>
<b class="nc"><i>1302</i>&nbsp;                if (verbose &gt; 3)</b>
<b class="nc"><i>1303</i>&nbsp;                    Utils.log.fine(&quot;Adding flag bit 1&lt;&lt;&quot;+index+&quot; in &quot;+Long.toHexString(flagMask));</b>
<b class="nc"><i>1304</i>&nbsp;                assert(!testBit(h.flags, 1L&lt;&lt;index));</b>
<b class="nc"><i>1305</i>&nbsp;                flagsToAdd |= (1L&lt;&lt;index);</b>
<b class="nc"><i>1306</i>&nbsp;                flagMask -= (1L&lt;&lt;index);  // do not use this bit twice here</b>
<i>1307</i>&nbsp;            } else {
<i>1308</i>&nbsp;                // an overflow attr.
<b class="nc"><i>1309</i>&nbsp;                flagsToAdd |= (1L&lt;&lt;X_ATTR_OVERFLOW);</b>
<b class="nc"><i>1310</i>&nbsp;                overflowCount += 1;</b>
<b class="nc"><i>1311</i>&nbsp;                if (verbose &gt; 3)</b>
<b class="nc"><i>1312</i>&nbsp;                    Utils.log.fine(&quot;Adding overflow attr #&quot;+overflowCount);</b>
<b class="nc"><i>1313</i>&nbsp;                IntBand xxx_attr_indexes = getAttrBand(xxx_attr_bands, AB_ATTR_INDEXES);</b>
<b class="nc"><i>1314</i>&nbsp;                xxx_attr_indexes.putInt(index);</b>
<i>1315</i>&nbsp;                // System.out.println(&quot;overflow @&quot;+index);
<i>1316</i>&nbsp;            }
<b class="nc"><i>1317</i>&nbsp;            if (def.bandCount == 0) {</b>
<b class="nc"><i>1318</i>&nbsp;                if (def == attrInnerClassesEmpty) {</b>
<i>1319</i>&nbsp;                    // Special logic to write this attr.
<b class="nc"><i>1320</i>&nbsp;                    writeLocalInnerClasses((Class) h);</b>
<b class="nc"><i>1321</i>&nbsp;                    continue;</b>
<i>1322</i>&nbsp;                }
<i>1323</i>&nbsp;                // Empty attr; nothing more to write here.
<i>1324</i>&nbsp;                continue;
<i>1325</i>&nbsp;            }
<b class="nc"><i>1326</i>&nbsp;            assert(a.fixups == null);</b>
<b class="nc"><i>1327</i>&nbsp;            final Band[] ab = attrBandTable.get(def);</b>
<b class="nc"><i>1328</i>&nbsp;            assert(ab != null);</b>
<b class="nc"><i>1329</i>&nbsp;            assert(ab.length == def.bandCount);</b>
<b class="nc"><i>1330</i>&nbsp;            final int[] bc = backCountTable.get(def);</b>
<b class="nc"><i>1331</i>&nbsp;            assert(bc != null);</b>
<b class="nc"><i>1332</i>&nbsp;            assert(bc.length == def.getCallables().length);</b>
<i>1333</i>&nbsp;            // Write one attribute of type def into ab.
<b class="nc"><i>1334</i>&nbsp;            if (verbose &gt; 2)  Utils.log.fine(&quot;writing &quot;+a+&quot; in &quot;+h);</b>
<b class="nc"><i>1335</i>&nbsp;            boolean isCV = (ctype == ATTR_CONTEXT_FIELD &amp;&amp; def == attrConstantValue);</b>
<b class="nc"><i>1336</i>&nbsp;            if (isCV)  setConstantValueIndex((Class.Field)h);</b>
<b class="nc"><i>1337</i>&nbsp;            a.parse(cls, a.bytes(), 0, a.size(),</b>
<b class="nc"><i>1338</i>&nbsp;                      new Attribute.ValueStream() {</b>
<i>1339</i>&nbsp;                public void putInt(int bandIndex, int value) {
<b class="nc"><i>1340</i>&nbsp;                    ((IntBand) ab[bandIndex]).putInt(value);</b>
<i>1341</i>&nbsp;                }
<i>1342</i>&nbsp;                public void putRef(int bandIndex, Entry ref) {
<b class="nc"><i>1343</i>&nbsp;                    ((CPRefBand) ab[bandIndex]).putRef(ref);</b>
<i>1344</i>&nbsp;                }
<i>1345</i>&nbsp;                public int encodeBCI(int bci) {
<b class="nc"><i>1346</i>&nbsp;                    Code code = (Code) h;</b>
<b class="nc"><i>1347</i>&nbsp;                    return code.encodeBCI(bci);</b>
<i>1348</i>&nbsp;                }
<i>1349</i>&nbsp;                public void noteBackCall(int whichCallable) {
<b class="nc"><i>1350</i>&nbsp;                    assert(bc[whichCallable] &gt;= 0);</b>
<b class="nc"><i>1351</i>&nbsp;                    bc[whichCallable] += 1;</b>
<i>1352</i>&nbsp;                }
<i>1353</i>&nbsp;            });
<b class="nc"><i>1354</i>&nbsp;            if (isCV)  setConstantValueIndex(null);  // clean up</b>
<b class="nc"><i>1355</i>&nbsp;        }</b>
<i>1356</i>&nbsp;
<b class="nc"><i>1357</i>&nbsp;        if (overflowCount &gt; 0) {</b>
<b class="nc"><i>1358</i>&nbsp;            IntBand xxx_attr_count = getAttrBand(xxx_attr_bands, AB_ATTR_COUNT);</b>
<b class="nc"><i>1359</i>&nbsp;            xxx_attr_count.putInt(overflowCount);</b>
<i>1360</i>&nbsp;        }
<i>1361</i>&nbsp;
<b class="nc"><i>1362</i>&nbsp;        xxx_flags_lo.putInt(h.flags | (int)flagsToAdd);</b>
<b class="nc"><i>1363</i>&nbsp;        if (haveLongFlags)</b>
<b class="nc"><i>1364</i>&nbsp;            xxx_flags_hi.putInt((int)(flagsToAdd &gt;&gt;&gt; 32));</b>
<i>1365</i>&nbsp;        else
<b class="nc"><i>1366</i>&nbsp;            assert((flagsToAdd &gt;&gt;&gt; 32) == 0);</b>
<b class="nc"><i>1367</i>&nbsp;        assert((h.flags &amp; flagsToAdd) == 0)</b>
<i>1368</i>&nbsp;            : (h+&quot;.flags=&quot;
<b class="nc"><i>1369</i>&nbsp;                +Integer.toHexString(h.flags)+&quot;^&quot;</b>
<b class="nc"><i>1370</i>&nbsp;                +Long.toHexString(flagsToAdd));</b>
<i>1371</i>&nbsp;    }
<i>1372</i>&nbsp;
<i>1373</i>&nbsp;    // temporary scratch variables for processing code blocks
<i>1374</i>&nbsp;    private Code                 curCode;
<i>1375</i>&nbsp;    private Class                curClass;
<i>1376</i>&nbsp;    private Entry[] curCPMap;
<i>1377</i>&nbsp;    private void beginCode(Code c) {
<b class="nc"><i>1378</i>&nbsp;        assert(curCode == null);</b>
<b class="nc"><i>1379</i>&nbsp;        curCode = c;</b>
<b class="nc"><i>1380</i>&nbsp;        curClass = c.m.thisClass();</b>
<b class="nc"><i>1381</i>&nbsp;        curCPMap = c.getCPMap();</b>
<i>1382</i>&nbsp;    }
<i>1383</i>&nbsp;    private void endCode() {
<b class="nc"><i>1384</i>&nbsp;        curCode = null;</b>
<b class="nc"><i>1385</i>&nbsp;        curClass = null;</b>
<b class="nc"><i>1386</i>&nbsp;        curCPMap = null;</b>
<i>1387</i>&nbsp;    }
<i>1388</i>&nbsp;
<i>1389</i>&nbsp;    // Return an _invokeinit_op variant, if the instruction matches one,
<i>1390</i>&nbsp;    // else -1.
<i>1391</i>&nbsp;    private int initOpVariant(Instruction i, Entry newClass) {
<b class="nc"><i>1392</i>&nbsp;        if (i.getBC() != _invokespecial)  return -1;</b>
<b class="nc"><i>1393</i>&nbsp;        MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</b>
<b class="nc"><i>1394</i>&nbsp;        if (&quot;&lt;init&gt;&quot;.equals(ref.descRef.nameRef.stringValue()) == false)</b>
<b class="nc"><i>1395</i>&nbsp;            return -1;</b>
<b class="nc"><i>1396</i>&nbsp;        ClassEntry refClass = ref.classRef;</b>
<b class="nc"><i>1397</i>&nbsp;        if (refClass == curClass.thisClass)</b>
<b class="nc"><i>1398</i>&nbsp;            return _invokeinit_op+_invokeinit_self_option;</b>
<b class="nc"><i>1399</i>&nbsp;        if (refClass == curClass.superClass)</b>
<b class="nc"><i>1400</i>&nbsp;            return _invokeinit_op+_invokeinit_super_option;</b>
<b class="nc"><i>1401</i>&nbsp;        if (refClass == newClass)</b>
<b class="nc"><i>1402</i>&nbsp;            return _invokeinit_op+_invokeinit_new_option;</b>
<b class="nc"><i>1403</i>&nbsp;        return -1;</b>
<i>1404</i>&nbsp;    }
<i>1405</i>&nbsp;
<i>1406</i>&nbsp;    // Return a _self_linker_op variant, if the instruction matches one,
<i>1407</i>&nbsp;    // else -1.
<i>1408</i>&nbsp;    private int selfOpVariant(Instruction i) {
<b class="nc"><i>1409</i>&nbsp;        int bc = i.getBC();</b>
<b class="nc"><i>1410</i>&nbsp;        if (!(bc &gt;= _first_linker_op &amp;&amp; bc &lt;= _last_linker_op))  return -1;</b>
<b class="nc"><i>1411</i>&nbsp;        MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</b>
<i>1412</i>&nbsp;        // do not optimize this case, simply fall back to regular coding
<b class="nc"><i>1413</i>&nbsp;        if ((bc == _invokespecial || bc == _invokestatic) &amp;&amp;</b>
<b class="nc"><i>1414</i>&nbsp;                ref.tagEquals(CONSTANT_InterfaceMethodref))</b>
<b class="nc"><i>1415</i>&nbsp;            return -1;</b>
<b class="nc"><i>1416</i>&nbsp;        ClassEntry refClass = ref.classRef;</b>
<b class="nc"><i>1417</i>&nbsp;        int self_bc = _self_linker_op + (bc - _first_linker_op);</b>
<b class="nc"><i>1418</i>&nbsp;        if (refClass == curClass.thisClass)</b>
<b class="nc"><i>1419</i>&nbsp;            return self_bc;</b>
<b class="nc"><i>1420</i>&nbsp;        if (refClass == curClass.superClass)</b>
<b class="nc"><i>1421</i>&nbsp;            return self_bc + _self_linker_super_flag;</b>
<b class="nc"><i>1422</i>&nbsp;        return -1;</b>
<i>1423</i>&nbsp;    }
<i>1424</i>&nbsp;
<i>1425</i>&nbsp;    void writeByteCodes(Code code) throws IOException {
<b class="nc"><i>1426</i>&nbsp;        beginCode(code);</b>
<b class="nc"><i>1427</i>&nbsp;        IndexGroup cp = pkg.cp;</b>
<i>1428</i>&nbsp;
<i>1429</i>&nbsp;        // true if the previous instruction is an aload to absorb
<b class="nc"><i>1430</i>&nbsp;        boolean prevAload = false;</b>
<i>1431</i>&nbsp;
<i>1432</i>&nbsp;        // class of most recent new; helps compress &lt;init&gt; calls
<b class="nc"><i>1433</i>&nbsp;        Entry newClass = null;</b>
<i>1434</i>&nbsp;
<b class="nc"><i>1435</i>&nbsp;        for (Instruction i = code.instructionAt(0); i != null; i = i.next()) {</b>
<i>1436</i>&nbsp;            // %%% Add a stress mode which issues _ref/_byte_escape.
<b class="nc"><i>1437</i>&nbsp;            if (verbose &gt; 3)  Utils.log.fine(i.toString());</b>
<i>1438</i>&nbsp;
<b class="nc"><i>1439</i>&nbsp;            if (i.isNonstandard()) {</b>
<i>1440</i>&nbsp;                // Crash and burn with a complaint if there are funny
<i>1441</i>&nbsp;                // bytecodes in this class file.
<b class="nc"><i>1442</i>&nbsp;                String complaint = code.getMethod()</b>
<i>1443</i>&nbsp;                    +&quot; contains an unrecognized bytecode &quot;+i
<i>1444</i>&nbsp;                    +&quot;; please use the pass-file option on this class.&quot;;
<b class="nc"><i>1445</i>&nbsp;                Utils.log.warning(complaint);</b>
<b class="nc"><i>1446</i>&nbsp;                throw new IOException(complaint);</b>
<i>1447</i>&nbsp;            }
<i>1448</i>&nbsp;
<b class="nc"><i>1449</i>&nbsp;            if (i.isWide()) {</b>
<b class="nc"><i>1450</i>&nbsp;                if (verbose &gt; 1) {</b>
<b class="nc"><i>1451</i>&nbsp;                    Utils.log.fine(&quot;_wide opcode in &quot;+code);</b>
<b class="nc"><i>1452</i>&nbsp;                    Utils.log.fine(i.toString());</b>
<i>1453</i>&nbsp;                }
<b class="nc"><i>1454</i>&nbsp;                bc_codes.putByte(_wide);</b>
<b class="nc"><i>1455</i>&nbsp;                codeHist[_wide]++;</b>
<i>1456</i>&nbsp;            }
<i>1457</i>&nbsp;
<b class="nc"><i>1458</i>&nbsp;            int bc = i.getBC();</b>
<i>1459</i>&nbsp;
<i>1460</i>&nbsp;            // Begin &quot;bc_linker&quot; compression.
<b class="nc"><i>1461</i>&nbsp;            if (bc == _aload_0) {</b>
<i>1462</i>&nbsp;                // Try to group aload_0 with a following operation.
<b class="nc"><i>1463</i>&nbsp;                Instruction ni = code.instructionAt(i.getNextPC());</b>
<b class="nc"><i>1464</i>&nbsp;                if (selfOpVariant(ni) &gt;= 0) {</b>
<b class="nc"><i>1465</i>&nbsp;                    prevAload = true;</b>
<b class="nc"><i>1466</i>&nbsp;                    continue;</b>
<i>1467</i>&nbsp;                }
<i>1468</i>&nbsp;            }
<i>1469</i>&nbsp;
<i>1470</i>&nbsp;            // Test for &lt;init&gt; invocations:
<b class="nc"><i>1471</i>&nbsp;            int init_bc = initOpVariant(i, newClass);</b>
<b class="nc"><i>1472</i>&nbsp;            if (init_bc &gt;= 0) {</b>
<b class="nc"><i>1473</i>&nbsp;                if (prevAload) {</b>
<i>1474</i>&nbsp;                    // get rid of it
<b class="nc"><i>1475</i>&nbsp;                    bc_codes.putByte(_aload_0);</b>
<b class="nc"><i>1476</i>&nbsp;                    codeHist[_aload_0]++;</b>
<b class="nc"><i>1477</i>&nbsp;                    prevAload = false;  //used up</b>
<i>1478</i>&nbsp;                }
<i>1479</i>&nbsp;                // Write special bytecode.
<b class="nc"><i>1480</i>&nbsp;                bc_codes.putByte(init_bc);</b>
<b class="nc"><i>1481</i>&nbsp;                codeHist[init_bc]++;</b>
<b class="nc"><i>1482</i>&nbsp;                MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</b>
<i>1483</i>&nbsp;                // Write operand to a separate band.
<b class="nc"><i>1484</i>&nbsp;                int coding = cp.getOverloadingIndex(ref);</b>
<b class="nc"><i>1485</i>&nbsp;                bc_initref.putInt(coding);</b>
<b class="nc"><i>1486</i>&nbsp;                continue;</b>
<i>1487</i>&nbsp;            }
<i>1488</i>&nbsp;
<b class="nc"><i>1489</i>&nbsp;            int self_bc = selfOpVariant(i);</b>
<b class="nc"><i>1490</i>&nbsp;            if (self_bc &gt;= 0) {</b>
<b class="nc"><i>1491</i>&nbsp;                boolean isField = Instruction.isFieldOp(bc);</b>
<b class="nc"><i>1492</i>&nbsp;                boolean isSuper = (self_bc &gt;= _self_linker_op+_self_linker_super_flag);</b>
<b class="nc"><i>1493</i>&nbsp;                boolean isAload = prevAload;</b>
<b class="nc"><i>1494</i>&nbsp;                prevAload = false;  //used up</b>
<b class="nc"><i>1495</i>&nbsp;                if (isAload)</b>
<b class="nc"><i>1496</i>&nbsp;                    self_bc += _self_linker_aload_flag;</b>
<i>1497</i>&nbsp;                // Write special bytecode.
<b class="nc"><i>1498</i>&nbsp;                bc_codes.putByte(self_bc);</b>
<b class="nc"><i>1499</i>&nbsp;                codeHist[self_bc]++;</b>
<i>1500</i>&nbsp;                // Write field or method ref to a separate band.
<b class="nc"><i>1501</i>&nbsp;                MemberEntry ref = (MemberEntry) i.getCPRef(curCPMap);</b>
<b class="nc"><i>1502</i>&nbsp;                CPRefBand bc_which = selfOpRefBand(self_bc);</b>
<b class="nc"><i>1503</i>&nbsp;                Index which_ix = cp.getMemberIndex(ref.tag, ref.classRef);</b>
<b class="nc"><i>1504</i>&nbsp;                bc_which.putRef(ref, which_ix);</b>
<b class="nc"><i>1505</i>&nbsp;                continue;</b>
<i>1506</i>&nbsp;            }
<b class="nc"><i>1507</i>&nbsp;            assert(!prevAload);</b>
<i>1508</i>&nbsp;            // End &quot;bc_linker&quot; compression.
<i>1509</i>&nbsp;
<i>1510</i>&nbsp;            // Normal bytecode.
<b class="nc"><i>1511</i>&nbsp;            codeHist[bc]++;</b>
<b class="nc"><i>1512</i>&nbsp;            switch (bc) {</b>
<i>1513</i>&nbsp;            case _tableswitch: // apc:  (df, lo, hi, (hi-lo+1)*(label))
<i>1514</i>&nbsp;            case _lookupswitch: // apc:  (df, nc, nc*(case, label))
<b class="nc"><i>1515</i>&nbsp;                bc_codes.putByte(bc);</b>
<b class="nc"><i>1516</i>&nbsp;                Instruction.Switch isw = (Instruction.Switch) i;</b>
<i>1517</i>&nbsp;                // Note that we do not write the alignment bytes.
<b class="nc"><i>1518</i>&nbsp;                int apc = isw.getAlignedPC();</b>
<b class="nc"><i>1519</i>&nbsp;                int npc = isw.getNextPC();</b>
<i>1520</i>&nbsp;                // write a length specification into the bytecode stream
<b class="nc"><i>1521</i>&nbsp;                int caseCount = isw.getCaseCount();</b>
<b class="nc"><i>1522</i>&nbsp;                bc_case_count.putInt(caseCount);</b>
<b class="nc"><i>1523</i>&nbsp;                putLabel(bc_label, code, i.getPC(), isw.getDefaultLabel());</b>
<b class="nc"><i>1524</i>&nbsp;                for (int j = 0; j &lt; caseCount; j++) {</b>
<b class="nc"><i>1525</i>&nbsp;                    putLabel(bc_label, code, i.getPC(), isw.getCaseLabel(j));</b>
<i>1526</i>&nbsp;                }
<i>1527</i>&nbsp;                // Transmit case values in their own band.
<b class="nc"><i>1528</i>&nbsp;                if (bc == _tableswitch) {</b>
<b class="nc"><i>1529</i>&nbsp;                    bc_case_value.putInt(isw.getCaseValue(0));</b>
<i>1530</i>&nbsp;                } else {
<b class="nc"><i>1531</i>&nbsp;                    for (int j = 0; j &lt; caseCount; j++) {</b>
<b class="nc"><i>1532</i>&nbsp;                        bc_case_value.putInt(isw.getCaseValue(j));</b>
<i>1533</i>&nbsp;                    }
<i>1534</i>&nbsp;                }
<i>1535</i>&nbsp;                // Done with the switch.
<b class="nc"><i>1536</i>&nbsp;                continue;</b>
<i>1537</i>&nbsp;            }
<i>1538</i>&nbsp;
<b class="nc"><i>1539</i>&nbsp;            int branch = i.getBranchLabel();</b>
<b class="nc"><i>1540</i>&nbsp;            if (branch &gt;= 0) {</b>
<b class="nc"><i>1541</i>&nbsp;                bc_codes.putByte(bc);</b>
<b class="nc"><i>1542</i>&nbsp;                putLabel(bc_label, code, i.getPC(), branch);</b>
<b class="nc"><i>1543</i>&nbsp;                continue;</b>
<i>1544</i>&nbsp;            }
<b class="nc"><i>1545</i>&nbsp;            Entry ref = i.getCPRef(curCPMap);</b>
<b class="nc"><i>1546</i>&nbsp;            if (ref != null) {</b>
<b class="nc"><i>1547</i>&nbsp;                if (bc == _new)  newClass = ref;</b>
<b class="nc"><i>1548</i>&nbsp;                if (bc == _ldc)  ldcHist[ref.tag]++;</b>
<i>1549</i>&nbsp;                CPRefBand bc_which;
<b class="nc"><i>1550</i>&nbsp;                int vbc = bc;</b>
<b class="nc"><i>1551</i>&nbsp;                switch (i.getCPTag()) {</b>
<i>1552</i>&nbsp;                case CONSTANT_LoadableValue:
<b class="nc"><i>1553</i>&nbsp;                    switch (ref.tag) {</b>
<i>1554</i>&nbsp;                    case CONSTANT_Integer:
<b class="nc"><i>1555</i>&nbsp;                        bc_which = bc_intref;</b>
<b class="nc"><i>1556</i>&nbsp;                        switch (bc) {</b>
<b class="nc"><i>1557</i>&nbsp;                        case _ldc:    vbc = _ildc; break;</b>
<b class="nc"><i>1558</i>&nbsp;                        case _ldc_w:  vbc = _ildc_w; break;</b>
<b class="nc"><i>1559</i>&nbsp;                        default:      assert(false);</b>
<i>1560</i>&nbsp;                        }
<i>1561</i>&nbsp;                        break;
<i>1562</i>&nbsp;                    case CONSTANT_Float:
<b class="nc"><i>1563</i>&nbsp;                        bc_which = bc_floatref;</b>
<b class="nc"><i>1564</i>&nbsp;                        switch (bc) {</b>
<b class="nc"><i>1565</i>&nbsp;                        case _ldc:    vbc = _fldc; break;</b>
<b class="nc"><i>1566</i>&nbsp;                        case _ldc_w:  vbc = _fldc_w; break;</b>
<b class="nc"><i>1567</i>&nbsp;                        default:      assert(false);</b>
<i>1568</i>&nbsp;                        }
<i>1569</i>&nbsp;                        break;
<i>1570</i>&nbsp;                    case CONSTANT_Long:
<b class="nc"><i>1571</i>&nbsp;                        bc_which = bc_longref;</b>
<b class="nc"><i>1572</i>&nbsp;                        assert(bc == _ldc2_w);</b>
<b class="nc"><i>1573</i>&nbsp;                        vbc = _lldc2_w;</b>
<b class="nc"><i>1574</i>&nbsp;                        break;</b>
<i>1575</i>&nbsp;                    case CONSTANT_Double:
<b class="nc"><i>1576</i>&nbsp;                        bc_which = bc_doubleref;</b>
<b class="nc"><i>1577</i>&nbsp;                        assert(bc == _ldc2_w);</b>
<b class="nc"><i>1578</i>&nbsp;                        vbc = _dldc2_w;</b>
<b class="nc"><i>1579</i>&nbsp;                        break;</b>
<i>1580</i>&nbsp;                    case CONSTANT_String:
<b class="nc"><i>1581</i>&nbsp;                        bc_which = bc_stringref;</b>
<b class="nc"><i>1582</i>&nbsp;                        switch (bc) {</b>
<b class="nc"><i>1583</i>&nbsp;                        case _ldc:    vbc = _sldc; break;</b>
<b class="nc"><i>1584</i>&nbsp;                        case _ldc_w:  vbc = _sldc_w; break;</b>
<b class="nc"><i>1585</i>&nbsp;                        default:      assert(false);</b>
<i>1586</i>&nbsp;                        }
<i>1587</i>&nbsp;                        break;
<i>1588</i>&nbsp;                    case CONSTANT_Class:
<b class="nc"><i>1589</i>&nbsp;                        bc_which = bc_classref;</b>
<b class="nc"><i>1590</i>&nbsp;                        switch (bc) {</b>
<b class="nc"><i>1591</i>&nbsp;                        case _ldc:    vbc = _cldc; break;</b>
<b class="nc"><i>1592</i>&nbsp;                        case _ldc_w:  vbc = _cldc_w; break;</b>
<b class="nc"><i>1593</i>&nbsp;                        default:      assert(false);</b>
<i>1594</i>&nbsp;                        }
<i>1595</i>&nbsp;                        break;
<i>1596</i>&nbsp;                    default:
<i>1597</i>&nbsp;                        // CONSTANT_MethodHandle, etc.
<b class="nc"><i>1598</i>&nbsp;                        if (getHighestClassVersion().lessThan(JAVA7_MAX_CLASS_VERSION)) {</b>
<b class="nc"><i>1599</i>&nbsp;                            throw new IOException(&quot;bad class file major version for Java 7 ldc&quot;);</b>
<i>1600</i>&nbsp;                        }
<b class="nc"><i>1601</i>&nbsp;                        bc_which = bc_loadablevalueref;</b>
<b class="nc"><i>1602</i>&nbsp;                        switch (bc) {</b>
<b class="nc"><i>1603</i>&nbsp;                        case _ldc:    vbc = _qldc; break;</b>
<b class="nc"><i>1604</i>&nbsp;                        case _ldc_w:  vbc = _qldc_w; break;</b>
<b class="nc"><i>1605</i>&nbsp;                        default:      assert(false);</b>
<i>1606</i>&nbsp;                        }
<i>1607</i>&nbsp;                    }
<i>1608</i>&nbsp;                    break;
<i>1609</i>&nbsp;                case CONSTANT_Class:
<i>1610</i>&nbsp;                    // Use a special shorthand for the current class:
<b class="nc"><i>1611</i>&nbsp;                    if (ref == curClass.thisClass)  ref = null;</b>
<b class="nc"><i>1612</i>&nbsp;                    bc_which = bc_classref; break;</b>
<i>1613</i>&nbsp;                case CONSTANT_Fieldref:
<b class="nc"><i>1614</i>&nbsp;                    bc_which = bc_fieldref; break;</b>
<i>1615</i>&nbsp;                case CONSTANT_Methodref:
<b class="nc"><i>1616</i>&nbsp;                    if (ref.tagEquals(CONSTANT_InterfaceMethodref)) {</b>
<b class="nc"><i>1617</i>&nbsp;                        if (bc == _invokespecial)</b>
<b class="nc"><i>1618</i>&nbsp;                            vbc = _invokespecial_int;</b>
<b class="nc"><i>1619</i>&nbsp;                        if (bc == _invokestatic)</b>
<b class="nc"><i>1620</i>&nbsp;                            vbc = _invokestatic_int;</b>
<b class="nc"><i>1621</i>&nbsp;                        bc_which = bc_imethodref;</b>
<i>1622</i>&nbsp;                    } else {
<b class="nc"><i>1623</i>&nbsp;                        bc_which = bc_methodref;</b>
<i>1624</i>&nbsp;                    }
<b class="nc"><i>1625</i>&nbsp;                    break;</b>
<i>1626</i>&nbsp;                case CONSTANT_InterfaceMethodref:
<b class="nc"><i>1627</i>&nbsp;                    bc_which = bc_imethodref; break;</b>
<i>1628</i>&nbsp;                case CONSTANT_InvokeDynamic:
<b class="nc"><i>1629</i>&nbsp;                    bc_which = bc_indyref; break;</b>
<i>1630</i>&nbsp;                default:
<b class="nc"><i>1631</i>&nbsp;                    bc_which = null;</b>
<b class="nc"><i>1632</i>&nbsp;                    assert(false);</b>
<i>1633</i>&nbsp;                }
<b class="nc"><i>1634</i>&nbsp;                if (ref != null &amp;&amp; bc_which.index != null &amp;&amp; !bc_which.index.contains(ref)) {</b>
<i>1635</i>&nbsp;                    // Crash and burn with a complaint if there are funny
<i>1636</i>&nbsp;                    // references for this bytecode instruction.
<i>1637</i>&nbsp;                    // Example:  invokestatic of a CONSTANT_InterfaceMethodref.
<b class="nc"><i>1638</i>&nbsp;                    String complaint = code.getMethod() +</b>
<i>1639</i>&nbsp;                        &quot; contains a bytecode &quot; + i +
<i>1640</i>&nbsp;                        &quot; with an unsupported constant reference; please use the pass-file option on this class.&quot;;
<b class="nc"><i>1641</i>&nbsp;                    Utils.log.warning(complaint);</b>
<b class="nc"><i>1642</i>&nbsp;                    throw new IOException(complaint);</b>
<i>1643</i>&nbsp;                }
<b class="nc"><i>1644</i>&nbsp;                bc_codes.putByte(vbc);</b>
<b class="nc"><i>1645</i>&nbsp;                bc_which.putRef(ref);</b>
<i>1646</i>&nbsp;                // handle trailing junk
<b class="nc"><i>1647</i>&nbsp;                if (bc == _multianewarray) {</b>
<b class="nc"><i>1648</i>&nbsp;                    assert(i.getConstant() == code.getByte(i.getPC()+3));</b>
<i>1649</i>&nbsp;                    // Just dump the byte into the bipush pile
<b class="nc"><i>1650</i>&nbsp;                    bc_byte.putByte(0xFF &amp; i.getConstant());</b>
<b class="nc"><i>1651</i>&nbsp;                } else if (bc == _invokeinterface) {</b>
<b class="nc"><i>1652</i>&nbsp;                    assert(i.getLength() == 5);</b>
<i>1653</i>&nbsp;                    // Make sure the discarded bytes are sane:
<b class="nc"><i>1654</i>&nbsp;                    assert(i.getConstant() == (1+((MemberEntry)ref).descRef.typeRef.computeSize(true)) &lt;&lt; 8);</b>
<b class="nc"><i>1655</i>&nbsp;                } else if (bc == _invokedynamic) {</b>
<b class="nc"><i>1656</i>&nbsp;                    if (getHighestClassVersion().lessThan(JAVA7_MAX_CLASS_VERSION)) {</b>
<b class="nc"><i>1657</i>&nbsp;                        throw new IOException(&quot;bad class major version for Java 7 invokedynamic&quot;);</b>
<i>1658</i>&nbsp;                    }
<b class="nc"><i>1659</i>&nbsp;                    assert(i.getLength() == 5);</b>
<b class="nc"><i>1660</i>&nbsp;                    assert(i.getConstant() == 0);  // last 2 bytes MBZ</b>
<i>1661</i>&nbsp;                } else {
<i>1662</i>&nbsp;                    // Make sure there is nothing else to write.
<b class="nc"><i>1663</i>&nbsp;                    assert(i.getLength() == ((bc == _ldc)?2:3));</b>
<i>1664</i>&nbsp;                }
<i>1665</i>&nbsp;                continue;
<i>1666</i>&nbsp;            }
<b class="nc"><i>1667</i>&nbsp;            int slot = i.getLocalSlot();</b>
<b class="nc"><i>1668</i>&nbsp;            if (slot &gt;= 0) {</b>
<b class="nc"><i>1669</i>&nbsp;                bc_codes.putByte(bc);</b>
<b class="nc"><i>1670</i>&nbsp;                bc_local.putInt(slot);</b>
<b class="nc"><i>1671</i>&nbsp;                int con = i.getConstant();</b>
<b class="nc"><i>1672</i>&nbsp;                if (bc == _iinc) {</b>
<b class="nc"><i>1673</i>&nbsp;                    if (!i.isWide()) {</b>
<b class="nc"><i>1674</i>&nbsp;                        bc_byte.putByte(0xFF &amp; con);</b>
<i>1675</i>&nbsp;                    } else {
<b class="nc"><i>1676</i>&nbsp;                        bc_short.putInt(0xFFFF &amp; con);</b>
<i>1677</i>&nbsp;                    }
<i>1678</i>&nbsp;                } else {
<b class="nc"><i>1679</i>&nbsp;                    assert(con == 0);</b>
<i>1680</i>&nbsp;                }
<i>1681</i>&nbsp;                continue;
<i>1682</i>&nbsp;            }
<i>1683</i>&nbsp;            // Generic instruction.  Copy the body.
<b class="nc"><i>1684</i>&nbsp;            bc_codes.putByte(bc);</b>
<b class="nc"><i>1685</i>&nbsp;            int pc = i.getPC()+1;</b>
<b class="nc"><i>1686</i>&nbsp;            int npc = i.getNextPC();</b>
<b class="nc"><i>1687</i>&nbsp;            if (pc &lt; npc) {</b>
<i>1688</i>&nbsp;                // Do a few remaining multi-byte instructions.
<b class="nc"><i>1689</i>&nbsp;                switch (bc) {</b>
<i>1690</i>&nbsp;                case _sipush:
<b class="nc"><i>1691</i>&nbsp;                    bc_short.putInt(0xFFFF &amp; i.getConstant());</b>
<b class="nc"><i>1692</i>&nbsp;                    break;</b>
<i>1693</i>&nbsp;                case _bipush:
<b class="nc"><i>1694</i>&nbsp;                    bc_byte.putByte(0xFF &amp; i.getConstant());</b>
<b class="nc"><i>1695</i>&nbsp;                    break;</b>
<i>1696</i>&nbsp;                case _newarray:
<b class="nc"><i>1697</i>&nbsp;                    bc_byte.putByte(0xFF &amp; i.getConstant());</b>
<b class="nc"><i>1698</i>&nbsp;                    break;</b>
<i>1699</i>&nbsp;                default:
<b class="nc"><i>1700</i>&nbsp;                    assert(false);  // that&#39;s it</b>
<i>1701</i>&nbsp;                }
<i>1702</i>&nbsp;            }
<i>1703</i>&nbsp;        }
<b class="nc"><i>1704</i>&nbsp;        bc_codes.putByte(_end_marker);</b>
<b class="nc"><i>1705</i>&nbsp;        bc_codes.elementCountForDebug++;</b>
<b class="nc"><i>1706</i>&nbsp;        codeHist[_end_marker]++;</b>
<b class="nc"><i>1707</i>&nbsp;        endCode();</b>
<i>1708</i>&nbsp;    }
<i>1709</i>&nbsp;
<b class="nc"><i>1710</i>&nbsp;    int[] codeHist = new int[1&lt;&lt;8];</b>
<b class="nc"><i>1711</i>&nbsp;    int[] ldcHist  = new int[20];</b>
<i>1712</i>&nbsp;    void printCodeHist() {
<b class="nc"><i>1713</i>&nbsp;        assert(verbose &gt; 0);</b>
<b class="nc"><i>1714</i>&nbsp;        String[] hist = new String[codeHist.length];</b>
<b class="nc"><i>1715</i>&nbsp;        int totalBytes = 0;</b>
<b class="nc"><i>1716</i>&nbsp;        for (int bc = 0; bc &lt; codeHist.length; bc++) {</b>
<b class="nc"><i>1717</i>&nbsp;            totalBytes += codeHist[bc];</b>
<i>1718</i>&nbsp;        }
<b class="nc"><i>1719</i>&nbsp;        for (int bc = 0; bc &lt; codeHist.length; bc++) {</b>
<b class="nc"><i>1720</i>&nbsp;            if (codeHist[bc] == 0) { hist[bc] = &quot;&quot;; continue; }</b>
<b class="nc"><i>1721</i>&nbsp;            String iname = Instruction.byteName(bc);</b>
<b class="nc"><i>1722</i>&nbsp;            String count = &quot;&quot; + codeHist[bc];</b>
<b class="nc"><i>1723</i>&nbsp;            count = &quot;         &quot;.substring(count.length()) + count;</b>
<b class="nc"><i>1724</i>&nbsp;            String pct = &quot;&quot; + (codeHist[bc] * 10000 / totalBytes);</b>
<b class="nc"><i>1725</i>&nbsp;            while (pct.length() &lt; 4) {</b>
<b class="nc"><i>1726</i>&nbsp;                pct = &quot;0&quot; + pct;</b>
<i>1727</i>&nbsp;            }
<b class="nc"><i>1728</i>&nbsp;            pct = pct.substring(0, pct.length()-2) + &quot;.&quot; + pct.substring(pct.length()-2);</b>
<b class="nc"><i>1729</i>&nbsp;            hist[bc] = count + &quot;  &quot; + pct + &quot;%  &quot; + iname;</b>
<i>1730</i>&nbsp;        }
<b class="nc"><i>1731</i>&nbsp;        Arrays.sort(hist);</b>
<b class="nc"><i>1732</i>&nbsp;        System.out.println(&quot;Bytecode histogram [&quot;+totalBytes+&quot;]&quot;);</b>
<b class="nc"><i>1733</i>&nbsp;        for (int i = hist.length; --i &gt;= 0; ) {</b>
<b class="nc"><i>1734</i>&nbsp;            if (&quot;&quot;.equals(hist[i]))  continue;</b>
<b class="nc"><i>1735</i>&nbsp;            System.out.println(hist[i]);</b>
<i>1736</i>&nbsp;        }
<b class="nc"><i>1737</i>&nbsp;        for (int tag = 0; tag &lt; ldcHist.length; tag++) {</b>
<b class="nc"><i>1738</i>&nbsp;            int count = ldcHist[tag];</b>
<b class="nc"><i>1739</i>&nbsp;            if (count == 0)  continue;</b>
<b class="nc"><i>1740</i>&nbsp;            System.out.println(&quot;ldc &quot;+ConstantPool.tagName(tag)+&quot; &quot;+count);</b>
<i>1741</i>&nbsp;        }
<i>1742</i>&nbsp;    }
<i>1743</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
