


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Instruction</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.java.util.jar.pack</a> ]
</div>

<h1>Coverage Summary for Class: Instruction (com.sun.java.util.jar.pack)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Instruction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 313)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Instruction$FormatException</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instruction$LookupSwitch</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instruction$Switch</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Instruction$TableSwitch</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 356)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.java.util.jar.pack;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.IOException;
<i>29</i>&nbsp;import java.util.Arrays;
<i>30</i>&nbsp;import static com.sun.java.util.jar.pack.Constants.*;
<i>31</i>&nbsp;
<i>32</i>&nbsp;/**
<i>33</i>&nbsp; * A parsed bytecode instruction.
<i>34</i>&nbsp; * Provides accessors to various relevant bits.
<i>35</i>&nbsp; * @author John Rose
<i>36</i>&nbsp; */
<b class="nc"><i>37</i>&nbsp;class Instruction  {</b>
<i>38</i>&nbsp;    protected byte[] bytes;  // bytecodes
<i>39</i>&nbsp;    protected int pc;        // location of this instruction
<i>40</i>&nbsp;    protected int bc;        // opcode of this instruction
<i>41</i>&nbsp;    protected int w;         // 0 if normal, 1 if a _wide prefix at pc
<i>42</i>&nbsp;    protected int length;    // bytes in this instruction
<i>43</i>&nbsp;
<i>44</i>&nbsp;    protected boolean special;
<i>45</i>&nbsp;
<b class="nc"><i>46</i>&nbsp;    protected Instruction(byte[] bytes, int pc, int bc, int w, int length) {</b>
<b class="nc"><i>47</i>&nbsp;        reset(bytes, pc, bc, w, length);</b>
<i>48</i>&nbsp;    }
<i>49</i>&nbsp;    private void reset(byte[] bytes, int pc, int bc, int w, int length) {
<b class="nc"><i>50</i>&nbsp;        this.bytes = bytes;</b>
<b class="nc"><i>51</i>&nbsp;        this.pc = pc;</b>
<b class="nc"><i>52</i>&nbsp;        this.bc = bc;</b>
<b class="nc"><i>53</i>&nbsp;        this.w = w;</b>
<b class="nc"><i>54</i>&nbsp;        this.length = length;</b>
<i>55</i>&nbsp;    }
<i>56</i>&nbsp;
<i>57</i>&nbsp;    public int getBC() {
<b class="nc"><i>58</i>&nbsp;        return bc;</b>
<i>59</i>&nbsp;    }
<i>60</i>&nbsp;    public boolean isWide() {
<b class="nc"><i>61</i>&nbsp;        return w != 0;</b>
<i>62</i>&nbsp;    }
<i>63</i>&nbsp;    public byte[] getBytes() {
<b class="nc"><i>64</i>&nbsp;        return bytes;</b>
<i>65</i>&nbsp;    }
<i>66</i>&nbsp;    public int getPC() {
<b class="nc"><i>67</i>&nbsp;        return pc;</b>
<i>68</i>&nbsp;    }
<i>69</i>&nbsp;    public int getLength() {
<b class="nc"><i>70</i>&nbsp;        return length;</b>
<i>71</i>&nbsp;    }
<i>72</i>&nbsp;    public int getNextPC() {
<b class="nc"><i>73</i>&nbsp;        return pc + length;</b>
<i>74</i>&nbsp;    }
<i>75</i>&nbsp;
<i>76</i>&nbsp;    public Instruction next() {
<b class="nc"><i>77</i>&nbsp;        int npc = pc + length;</b>
<b class="nc"><i>78</i>&nbsp;        if (npc == bytes.length)</b>
<b class="nc"><i>79</i>&nbsp;            return null;</b>
<i>80</i>&nbsp;        else
<b class="nc"><i>81</i>&nbsp;            return Instruction.at(bytes, npc, this);</b>
<i>82</i>&nbsp;    }
<i>83</i>&nbsp;
<i>84</i>&nbsp;    public boolean isNonstandard() {
<b class="nc"><i>85</i>&nbsp;        return isNonstandard(bc);</b>
<i>86</i>&nbsp;    }
<i>87</i>&nbsp;
<i>88</i>&nbsp;    public void setNonstandardLength(int length) {
<b class="nc"><i>89</i>&nbsp;        assert(isNonstandard());</b>
<b class="nc"><i>90</i>&nbsp;        this.length = length;</b>
<i>91</i>&nbsp;    }
<i>92</i>&nbsp;
<i>93</i>&nbsp;
<i>94</i>&nbsp;    /** A fake instruction at this pc whose next() will be at nextpc. */
<i>95</i>&nbsp;    public Instruction forceNextPC(int nextpc) {
<b class="nc"><i>96</i>&nbsp;        int llength = nextpc - pc;</b>
<b class="nc"><i>97</i>&nbsp;        return new Instruction(bytes, pc, -1, -1, llength);</b>
<i>98</i>&nbsp;    }
<i>99</i>&nbsp;
<i>100</i>&nbsp;    public static Instruction at(byte[] bytes, int pc) {
<b class="nc"><i>101</i>&nbsp;        return Instruction.at(bytes, pc, null);</b>
<i>102</i>&nbsp;    }
<i>103</i>&nbsp;
<i>104</i>&nbsp;    public static Instruction at(byte[] bytes, int pc, Instruction reuse) {
<b class="nc"><i>105</i>&nbsp;        int bc = getByte(bytes, pc);</b>
<b class="nc"><i>106</i>&nbsp;        int prefix = -1;</b>
<b class="nc"><i>107</i>&nbsp;        int w = 0;</b>
<b class="nc"><i>108</i>&nbsp;        int length = BC_LENGTH[w][bc];</b>
<b class="nc"><i>109</i>&nbsp;        if (length == 0) {</b>
<i>110</i>&nbsp;            // Hard cases:
<b class="nc"><i>111</i>&nbsp;            switch (bc) {</b>
<i>112</i>&nbsp;            case _wide:
<b class="nc"><i>113</i>&nbsp;                bc = getByte(bytes, pc+1);</b>
<b class="nc"><i>114</i>&nbsp;                w = 1;</b>
<b class="nc"><i>115</i>&nbsp;                length = BC_LENGTH[w][bc];</b>
<b class="nc"><i>116</i>&nbsp;                if (length == 0) {</b>
<i>117</i>&nbsp;                    // unknown instruction; treat as one byte
<b class="nc"><i>118</i>&nbsp;                    length = 1;</b>
<i>119</i>&nbsp;                }
<i>120</i>&nbsp;                break;
<i>121</i>&nbsp;            case _tableswitch:
<b class="nc"><i>122</i>&nbsp;                return new TableSwitch(bytes, pc);</b>
<i>123</i>&nbsp;            case _lookupswitch:
<b class="nc"><i>124</i>&nbsp;                return new LookupSwitch(bytes, pc);</b>
<i>125</i>&nbsp;            default:
<i>126</i>&nbsp;                // unknown instruction; treat as one byte
<b class="nc"><i>127</i>&nbsp;                length = 1;</b>
<i>128</i>&nbsp;                break;
<i>129</i>&nbsp;            }
<i>130</i>&nbsp;        }
<b class="nc"><i>131</i>&nbsp;        assert(length &gt; 0);</b>
<b class="nc"><i>132</i>&nbsp;        assert(pc+length &lt;= bytes.length);</b>
<i>133</i>&nbsp;        // Speed hack:  Instruction.next reuses self if possible.
<b class="nc"><i>134</i>&nbsp;        if (reuse != null &amp;&amp; !reuse.special) {</b>
<b class="nc"><i>135</i>&nbsp;            reuse.reset(bytes, pc, bc, w, length);</b>
<b class="nc"><i>136</i>&nbsp;            return reuse;</b>
<i>137</i>&nbsp;        }
<b class="nc"><i>138</i>&nbsp;        return new Instruction(bytes, pc, bc, w, length);</b>
<i>139</i>&nbsp;    }
<i>140</i>&nbsp;
<i>141</i>&nbsp;    // Return the constant pool reference type, or 0 if none.
<i>142</i>&nbsp;    public byte getCPTag() {
<b class="nc"><i>143</i>&nbsp;        return BC_TAG[w][bc];</b>
<i>144</i>&nbsp;    }
<i>145</i>&nbsp;
<i>146</i>&nbsp;    // Return the constant pool index, or -1 if none.
<i>147</i>&nbsp;    public int getCPIndex() {
<b class="nc"><i>148</i>&nbsp;        int indexLoc = BC_INDEX[w][bc];</b>
<b class="nc"><i>149</i>&nbsp;        if (indexLoc == 0)  return -1;</b>
<b class="nc"><i>150</i>&nbsp;        assert(w == 0);</b>
<b class="nc"><i>151</i>&nbsp;        if (length == 2)</b>
<b class="nc"><i>152</i>&nbsp;            return getByte(bytes, pc+indexLoc);  // _ldc opcode only</b>
<i>153</i>&nbsp;        else
<b class="nc"><i>154</i>&nbsp;            return getShort(bytes, pc+indexLoc);</b>
<i>155</i>&nbsp;    }
<i>156</i>&nbsp;
<i>157</i>&nbsp;    public void setCPIndex(int cpi) {
<b class="nc"><i>158</i>&nbsp;        int indexLoc = BC_INDEX[w][bc];</b>
<b class="nc"><i>159</i>&nbsp;        assert(indexLoc != 0);</b>
<b class="nc"><i>160</i>&nbsp;        if (length == 2)</b>
<b class="nc"><i>161</i>&nbsp;            setByte(bytes, pc+indexLoc, cpi);  // _ldc opcode only</b>
<i>162</i>&nbsp;        else
<b class="nc"><i>163</i>&nbsp;            setShort(bytes, pc+indexLoc, cpi);</b>
<b class="nc"><i>164</i>&nbsp;        assert(getCPIndex() == cpi);</b>
<i>165</i>&nbsp;    }
<i>166</i>&nbsp;
<i>167</i>&nbsp;    public ConstantPool.Entry getCPRef(ConstantPool.Entry[] cpMap) {
<b class="nc"><i>168</i>&nbsp;        int index = getCPIndex();</b>
<b class="nc"><i>169</i>&nbsp;        return (index &lt; 0) ? null : cpMap[index];</b>
<i>170</i>&nbsp;    }
<i>171</i>&nbsp;
<i>172</i>&nbsp;    // Return the slot of the affected local, or -1 if none.
<i>173</i>&nbsp;    public int getLocalSlot() {
<b class="nc"><i>174</i>&nbsp;        int slotLoc = BC_SLOT[w][bc];</b>
<b class="nc"><i>175</i>&nbsp;        if (slotLoc == 0)  return -1;</b>
<b class="nc"><i>176</i>&nbsp;        if (w == 0)</b>
<b class="nc"><i>177</i>&nbsp;            return getByte(bytes, pc+slotLoc);</b>
<i>178</i>&nbsp;        else
<b class="nc"><i>179</i>&nbsp;            return getShort(bytes, pc+slotLoc);</b>
<i>180</i>&nbsp;    }
<i>181</i>&nbsp;
<i>182</i>&nbsp;    // Return the target of the branch, or -1 if none.
<i>183</i>&nbsp;    public int getBranchLabel() {
<b class="nc"><i>184</i>&nbsp;        int branchLoc = BC_BRANCH[w][bc];</b>
<b class="nc"><i>185</i>&nbsp;        if (branchLoc == 0)  return -1;</b>
<b class="nc"><i>186</i>&nbsp;        assert(w == 0);</b>
<b class="nc"><i>187</i>&nbsp;        assert(length == 3 || length == 5);</b>
<i>188</i>&nbsp;        int offset;
<b class="nc"><i>189</i>&nbsp;        if (length == 3)</b>
<b class="nc"><i>190</i>&nbsp;            offset = (short)getShort(bytes, pc+branchLoc);</b>
<i>191</i>&nbsp;        else
<b class="nc"><i>192</i>&nbsp;            offset = getInt(bytes, pc+branchLoc);</b>
<b class="nc"><i>193</i>&nbsp;        assert(offset+pc &gt;= 0);</b>
<b class="nc"><i>194</i>&nbsp;        assert(offset+pc &lt;= bytes.length);</b>
<b class="nc"><i>195</i>&nbsp;        return offset+pc;</b>
<i>196</i>&nbsp;    }
<i>197</i>&nbsp;
<i>198</i>&nbsp;    public void setBranchLabel(int targetPC) {
<b class="nc"><i>199</i>&nbsp;        int branchLoc = BC_BRANCH[w][bc];</b>
<b class="nc"><i>200</i>&nbsp;        assert(branchLoc != 0);</b>
<b class="nc"><i>201</i>&nbsp;        if (length == 3)</b>
<b class="nc"><i>202</i>&nbsp;            setShort(bytes, pc+branchLoc, targetPC-pc);</b>
<i>203</i>&nbsp;        else
<b class="nc"><i>204</i>&nbsp;            setInt(bytes, pc+branchLoc, targetPC-pc);</b>
<b class="nc"><i>205</i>&nbsp;        assert(targetPC == getBranchLabel());</b>
<i>206</i>&nbsp;    }
<i>207</i>&nbsp;
<i>208</i>&nbsp;    // Return the trailing constant in the instruction (as a signed value).
<i>209</i>&nbsp;    // Return 0 if there is none.
<i>210</i>&nbsp;    public int getConstant() {
<b class="nc"><i>211</i>&nbsp;        int conLoc = BC_CON[w][bc];</b>
<b class="nc"><i>212</i>&nbsp;        if (conLoc == 0)  return 0;</b>
<b class="nc"><i>213</i>&nbsp;        switch (length - conLoc) {</b>
<b class="nc"><i>214</i>&nbsp;        case 1: return (byte) getByte(bytes, pc+conLoc);</b>
<b class="nc"><i>215</i>&nbsp;        case 2: return (short) getShort(bytes, pc+conLoc);</b>
<i>216</i>&nbsp;        }
<b class="nc"><i>217</i>&nbsp;        assert(false);</b>
<b class="nc"><i>218</i>&nbsp;        return 0;</b>
<i>219</i>&nbsp;    }
<i>220</i>&nbsp;
<i>221</i>&nbsp;    public void setConstant(int con) {
<b class="nc"><i>222</i>&nbsp;        int conLoc = BC_CON[w][bc];</b>
<b class="nc"><i>223</i>&nbsp;        assert(conLoc != 0);</b>
<b class="nc"><i>224</i>&nbsp;        switch (length - conLoc) {</b>
<b class="nc"><i>225</i>&nbsp;        case 1: setByte(bytes, pc+conLoc, con); break;</b>
<b class="nc"><i>226</i>&nbsp;        case 2: setShort(bytes, pc+conLoc, con); break;</b>
<i>227</i>&nbsp;        }
<b class="nc"><i>228</i>&nbsp;        assert(con == getConstant());</b>
<i>229</i>&nbsp;    }
<i>230</i>&nbsp;
<i>231</i>&nbsp;    public abstract static class Switch extends Instruction {
<i>232</i>&nbsp;        // Each case is a (value, label) pair, indexed 0 &lt;= n &lt; caseCount
<i>233</i>&nbsp;        public abstract int  getCaseCount();
<i>234</i>&nbsp;        public abstract int  getCaseValue(int n);
<i>235</i>&nbsp;        public abstract int  getCaseLabel(int n);
<i>236</i>&nbsp;        public abstract void setCaseCount(int caseCount);
<i>237</i>&nbsp;        public abstract void setCaseValue(int n, int value);
<i>238</i>&nbsp;        public abstract void setCaseLabel(int n, int targetPC);
<i>239</i>&nbsp;        protected abstract int getLength(int caseCount);
<i>240</i>&nbsp;
<b class="nc"><i>241</i>&nbsp;        public int  getDefaultLabel()             { return intAt(0)+pc; }</b>
<b class="nc"><i>242</i>&nbsp;        public void setDefaultLabel(int targetPC) { setIntAt(0, targetPC-pc); }</b>
<i>243</i>&nbsp;
<i>244</i>&nbsp;        protected int apc;        // aligned pc (table base)
<b class="nc"><i>245</i>&nbsp;        protected int intAt(int n) { return getInt(bytes, apc + n*4); }</b>
<b class="nc"><i>246</i>&nbsp;        protected void setIntAt(int n, int x) { setInt(bytes, apc + n*4, x); }</b>
<i>247</i>&nbsp;        protected Switch(byte[] bytes, int pc, int bc) {
<b class="nc"><i>248</i>&nbsp;            super(bytes, pc, bc, /*w*/0, /*length*/0);</b>
<b class="nc"><i>249</i>&nbsp;            this.apc = alignPC(pc+1);</b>
<b class="nc"><i>250</i>&nbsp;            this.special = true;</b>
<b class="nc"><i>251</i>&nbsp;            length = getLength(getCaseCount());</b>
<i>252</i>&nbsp;        }
<b class="nc"><i>253</i>&nbsp;        public int getAlignedPC() { return apc; }</b>
<i>254</i>&nbsp;        public String toString() {
<b class="nc"><i>255</i>&nbsp;            String s = super.toString();</b>
<b class="nc"><i>256</i>&nbsp;            s += &quot; Default:&quot;+labstr(getDefaultLabel());</b>
<b class="nc"><i>257</i>&nbsp;            int caseCount = getCaseCount();</b>
<b class="nc"><i>258</i>&nbsp;            for (int i = 0; i &lt; caseCount; i++) {</b>
<b class="nc"><i>259</i>&nbsp;                s += &quot;\n\tCase &quot;+getCaseValue(i)+&quot;:&quot;+labstr(getCaseLabel(i));</b>
<i>260</i>&nbsp;            }
<b class="nc"><i>261</i>&nbsp;            return s;</b>
<i>262</i>&nbsp;        }
<i>263</i>&nbsp;        public static int alignPC(int apc) {
<b class="nc"><i>264</i>&nbsp;            while (apc % 4 != 0)  ++apc;</b>
<b class="nc"><i>265</i>&nbsp;            return apc;</b>
<i>266</i>&nbsp;        }
<i>267</i>&nbsp;    }
<i>268</i>&nbsp;
<i>269</i>&nbsp;    public static class TableSwitch extends Switch {
<i>270</i>&nbsp;        // apc:  (df, lo, hi, (hi-lo+1)*(label))
<b class="nc"><i>271</i>&nbsp;        public int getLowCase()        { return intAt(1); }</b>
<b class="nc"><i>272</i>&nbsp;        public int getHighCase()       { return intAt(2); }</b>
<b class="nc"><i>273</i>&nbsp;        public int getCaseCount()      { return intAt(2)-intAt(1)+1; }</b>
<b class="nc"><i>274</i>&nbsp;        public int getCaseValue(int n) { return getLowCase()+n; }</b>
<b class="nc"><i>275</i>&nbsp;        public int getCaseLabel(int n) { return intAt(3+n)+pc; }</b>
<i>276</i>&nbsp;
<b class="nc"><i>277</i>&nbsp;        public void setLowCase(int val)  { setIntAt(1, val); }</b>
<b class="nc"><i>278</i>&nbsp;        public void setHighCase(int val) { setIntAt(2, val); }</b>
<b class="nc"><i>279</i>&nbsp;        public void setCaseLabel(int n, int tpc) { setIntAt(3+n, tpc-pc); }</b>
<i>280</i>&nbsp;        public void setCaseCount(int caseCount) {
<b class="nc"><i>281</i>&nbsp;            setHighCase(getLowCase() + caseCount - 1);</b>
<b class="nc"><i>282</i>&nbsp;            length = getLength(caseCount);</b>
<i>283</i>&nbsp;        }
<i>284</i>&nbsp;        public void setCaseValue(int n, int val) {
<b class="nc"><i>285</i>&nbsp;            if (n != 0)  throw new UnsupportedOperationException();</b>
<b class="nc"><i>286</i>&nbsp;            int caseCount = getCaseCount();</b>
<b class="nc"><i>287</i>&nbsp;            setLowCase(val);</b>
<b class="nc"><i>288</i>&nbsp;            setCaseCount(caseCount);  // keep invariant</b>
<i>289</i>&nbsp;        }
<i>290</i>&nbsp;
<i>291</i>&nbsp;        TableSwitch(byte[] bytes, int pc) {
<b class="nc"><i>292</i>&nbsp;            super(bytes, pc, _tableswitch);</b>
<i>293</i>&nbsp;        }
<i>294</i>&nbsp;        protected int getLength(int caseCount) {
<b class="nc"><i>295</i>&nbsp;            return (apc-pc) + (3 + caseCount) * 4;</b>
<i>296</i>&nbsp;        }
<i>297</i>&nbsp;    }
<i>298</i>&nbsp;
<i>299</i>&nbsp;    public static class LookupSwitch extends Switch {
<i>300</i>&nbsp;        // apc:  (df, nc, nc*(case, label))
<b class="nc"><i>301</i>&nbsp;        public int getCaseCount()      { return intAt(1); }</b>
<b class="nc"><i>302</i>&nbsp;        public int getCaseValue(int n) { return intAt(2+n*2+0); }</b>
<b class="nc"><i>303</i>&nbsp;        public int getCaseLabel(int n) { return intAt(2+n*2+1)+pc; }</b>
<i>304</i>&nbsp;
<i>305</i>&nbsp;        public void setCaseCount(int caseCount)  {
<b class="nc"><i>306</i>&nbsp;            setIntAt(1, caseCount);</b>
<b class="nc"><i>307</i>&nbsp;            length = getLength(caseCount);</b>
<i>308</i>&nbsp;        }
<b class="nc"><i>309</i>&nbsp;        public void setCaseValue(int n, int val) { setIntAt(2+n*2+0, val); }</b>
<b class="nc"><i>310</i>&nbsp;        public void setCaseLabel(int n, int tpc) { setIntAt(2+n*2+1, tpc-pc); }</b>
<i>311</i>&nbsp;
<i>312</i>&nbsp;        LookupSwitch(byte[] bytes, int pc) {
<b class="nc"><i>313</i>&nbsp;            super(bytes, pc, _lookupswitch);</b>
<i>314</i>&nbsp;        }
<i>315</i>&nbsp;        protected int getLength(int caseCount) {
<b class="nc"><i>316</i>&nbsp;            return (apc-pc) + (2 + caseCount*2) * 4;</b>
<i>317</i>&nbsp;        }
<i>318</i>&nbsp;    }
<i>319</i>&nbsp;
<i>320</i>&nbsp;    /** Two instructions are equal if they have the same bytes. */
<i>321</i>&nbsp;    public boolean equals(Object o) {
<b class="nc"><i>322</i>&nbsp;        return (o != null) &amp;&amp; (o.getClass() == Instruction.class)</b>
<b class="nc"><i>323</i>&nbsp;                &amp;&amp; equals((Instruction) o);</b>
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;
<i>326</i>&nbsp;    public int hashCode() {
<b class="nc"><i>327</i>&nbsp;        int hash = 3;</b>
<b class="nc"><i>328</i>&nbsp;        hash = 11 * hash + Arrays.hashCode(this.bytes);</b>
<b class="nc"><i>329</i>&nbsp;        hash = 11 * hash + this.pc;</b>
<b class="nc"><i>330</i>&nbsp;        hash = 11 * hash + this.bc;</b>
<b class="nc"><i>331</i>&nbsp;        hash = 11 * hash + this.w;</b>
<b class="nc"><i>332</i>&nbsp;        hash = 11 * hash + this.length;</b>
<b class="nc"><i>333</i>&nbsp;        return hash;</b>
<i>334</i>&nbsp;    }
<i>335</i>&nbsp;
<i>336</i>&nbsp;    public boolean equals(Instruction that) {
<b class="nc"><i>337</i>&nbsp;        if (this.pc != that.pc)            return false;</b>
<b class="nc"><i>338</i>&nbsp;        if (this.bc != that.bc)            return false;</b>
<b class="nc"><i>339</i>&nbsp;        if (this.w  != that.w)             return false;</b>
<b class="nc"><i>340</i>&nbsp;        if (this.length  != that.length)   return false;</b>
<b class="nc"><i>341</i>&nbsp;        for (int i = 1; i &lt; length; i++) {</b>
<b class="nc"><i>342</i>&nbsp;            if (this.bytes[this.pc+i] != that.bytes[that.pc+i])</b>
<b class="nc"><i>343</i>&nbsp;                return false;</b>
<i>344</i>&nbsp;        }
<b class="nc"><i>345</i>&nbsp;        return true;</b>
<i>346</i>&nbsp;    }
<i>347</i>&nbsp;
<i>348</i>&nbsp;    static String labstr(int pc) {
<b class="nc"><i>349</i>&nbsp;        if (pc &gt;= 0 &amp;&amp; pc &lt; 100000)</b>
<b class="nc"><i>350</i>&nbsp;            return ((100000+pc)+&quot;&quot;).substring(1);</b>
<b class="nc"><i>351</i>&nbsp;        return pc+&quot;&quot;;</b>
<i>352</i>&nbsp;    }
<i>353</i>&nbsp;    public String toString() {
<b class="nc"><i>354</i>&nbsp;        return toString(null);</b>
<i>355</i>&nbsp;    }
<i>356</i>&nbsp;    public String toString(ConstantPool.Entry[] cpMap) {
<b class="nc"><i>357</i>&nbsp;        String s = labstr(pc) + &quot;: &quot;;</b>
<b class="nc"><i>358</i>&nbsp;        if (bc &gt;= _bytecode_limit) {</b>
<b class="nc"><i>359</i>&nbsp;            s += Integer.toHexString(bc);</b>
<b class="nc"><i>360</i>&nbsp;            return s;</b>
<i>361</i>&nbsp;        }
<b class="nc"><i>362</i>&nbsp;        if (w == 1)  s += &quot;wide &quot;;</b>
<b class="nc"><i>363</i>&nbsp;        String bcname = (bc &lt; BC_NAME.length)? BC_NAME[bc]: null;</b>
<b class="nc"><i>364</i>&nbsp;        if (bcname == null) {</b>
<b class="nc"><i>365</i>&nbsp;            return s+&quot;opcode#&quot;+bc;</b>
<i>366</i>&nbsp;        }
<b class="nc"><i>367</i>&nbsp;        s += bcname;</b>
<b class="nc"><i>368</i>&nbsp;        int tag = getCPTag();</b>
<b class="nc"><i>369</i>&nbsp;        if (tag != 0)  s += &quot; &quot;+ConstantPool.tagName(tag)+&quot;:&quot;;</b>
<b class="nc"><i>370</i>&nbsp;        int idx = getCPIndex();</b>
<b class="nc"><i>371</i>&nbsp;        if (idx &gt;= 0)  s += (cpMap == null) ? &quot;&quot;+idx : &quot;=&quot;+cpMap[idx].stringValue();</b>
<b class="nc"><i>372</i>&nbsp;        int slt = getLocalSlot();</b>
<b class="nc"><i>373</i>&nbsp;        if (slt &gt;= 0)  s += &quot; Local:&quot;+slt;</b>
<b class="nc"><i>374</i>&nbsp;        int lab = getBranchLabel();</b>
<b class="nc"><i>375</i>&nbsp;        if (lab &gt;= 0)  s += &quot; To:&quot;+labstr(lab);</b>
<b class="nc"><i>376</i>&nbsp;        int con = getConstant();</b>
<b class="nc"><i>377</i>&nbsp;        if (con != 0)  s += &quot; Con:&quot;+con;</b>
<b class="nc"><i>378</i>&nbsp;        return s;</b>
<i>379</i>&nbsp;    }
<i>380</i>&nbsp;
<i>381</i>&nbsp;
<i>382</i>&nbsp;    //public static byte constantPoolTagFor(int bc) { return BC_TAG[0][bc]; }
<i>383</i>&nbsp;
<i>384</i>&nbsp;    /// Fetching values from byte arrays:
<i>385</i>&nbsp;
<i>386</i>&nbsp;    public int getIntAt(int off) {
<b class="nc"><i>387</i>&nbsp;        return getInt(bytes, pc+off);</b>
<i>388</i>&nbsp;    }
<i>389</i>&nbsp;    public int getShortAt(int off) {
<b class="nc"><i>390</i>&nbsp;        return getShort(bytes, pc+off);</b>
<i>391</i>&nbsp;    }
<i>392</i>&nbsp;    public int getByteAt(int off) {
<b class="nc"><i>393</i>&nbsp;        return getByte(bytes, pc+off);</b>
<i>394</i>&nbsp;    }
<i>395</i>&nbsp;
<i>396</i>&nbsp;
<i>397</i>&nbsp;    public static int getInt(byte[] bytes, int pc) {
<b class="nc"><i>398</i>&nbsp;        return (getShort(bytes, pc+0) &lt;&lt; 16) + (getShort(bytes, pc+2) &lt;&lt; 0);</b>
<i>399</i>&nbsp;    }
<i>400</i>&nbsp;    public static int getShort(byte[] bytes, int pc) {
<b class="nc"><i>401</i>&nbsp;        return (getByte(bytes, pc+0) &lt;&lt; 8) + (getByte(bytes, pc+1) &lt;&lt; 0);</b>
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;    public static int getByte(byte[] bytes, int pc) {
<b class="nc"><i>404</i>&nbsp;        return bytes[pc] &amp; 0xFF;</b>
<i>405</i>&nbsp;    }
<i>406</i>&nbsp;
<i>407</i>&nbsp;
<i>408</i>&nbsp;    public static void setInt(byte[] bytes, int pc, int x) {
<b class="nc"><i>409</i>&nbsp;        setShort(bytes, pc+0, x &gt;&gt; 16);</b>
<b class="nc"><i>410</i>&nbsp;        setShort(bytes, pc+2, x &gt;&gt; 0);</b>
<i>411</i>&nbsp;    }
<i>412</i>&nbsp;    public static void setShort(byte[] bytes, int pc, int x) {
<b class="nc"><i>413</i>&nbsp;        setByte(bytes, pc+0, x &gt;&gt; 8);</b>
<b class="nc"><i>414</i>&nbsp;        setByte(bytes, pc+1, x &gt;&gt; 0);</b>
<i>415</i>&nbsp;    }
<i>416</i>&nbsp;    public static void setByte(byte[] bytes, int pc, int x) {
<b class="nc"><i>417</i>&nbsp;        bytes[pc] = (byte)x;</b>
<i>418</i>&nbsp;    }
<i>419</i>&nbsp;
<i>420</i>&nbsp;    // some bytecode classifiers
<i>421</i>&nbsp;
<i>422</i>&nbsp;
<i>423</i>&nbsp;    public static boolean isNonstandard(int bc) {
<b class="nc"><i>424</i>&nbsp;        return BC_LENGTH[0][bc] &lt; 0;</b>
<i>425</i>&nbsp;    }
<i>426</i>&nbsp;
<i>427</i>&nbsp;    public static int opLength(int bc) {
<b class="nc"><i>428</i>&nbsp;        int l = BC_LENGTH[0][bc];</b>
<b class="nc"><i>429</i>&nbsp;        assert(l &gt; 0);</b>
<b class="nc"><i>430</i>&nbsp;        return l;</b>
<i>431</i>&nbsp;    }
<i>432</i>&nbsp;    public static int opWideLength(int bc) {
<b class="nc"><i>433</i>&nbsp;        int l = BC_LENGTH[1][bc];</b>
<b class="nc"><i>434</i>&nbsp;        assert(l &gt; 0);</b>
<b class="nc"><i>435</i>&nbsp;        return l;</b>
<i>436</i>&nbsp;    }
<i>437</i>&nbsp;
<i>438</i>&nbsp;    public static boolean isLocalSlotOp(int bc) {
<b class="nc"><i>439</i>&nbsp;        return (bc &lt; BC_SLOT[0].length &amp;&amp; BC_SLOT[0][bc] &gt; 0);</b>
<i>440</i>&nbsp;    }
<i>441</i>&nbsp;
<i>442</i>&nbsp;    public static boolean isBranchOp(int bc) {
<b class="nc"><i>443</i>&nbsp;        return (bc &lt; BC_BRANCH[0].length &amp;&amp; BC_BRANCH[0][bc] &gt; 0);</b>
<i>444</i>&nbsp;    }
<i>445</i>&nbsp;
<i>446</i>&nbsp;    public static boolean isCPRefOp(int bc) {
<b class="nc"><i>447</i>&nbsp;        if (bc &lt; BC_INDEX[0].length &amp;&amp; BC_INDEX[0][bc] &gt; 0)  return true;</b>
<b class="nc"><i>448</i>&nbsp;        if (bc &gt;= _xldc_op &amp;&amp; bc &lt; _xldc_limit)  return true;</b>
<b class="nc"><i>449</i>&nbsp;        if (bc == _invokespecial_int || bc == _invokestatic_int) return true;</b>
<b class="nc"><i>450</i>&nbsp;        return false;</b>
<i>451</i>&nbsp;    }
<i>452</i>&nbsp;
<i>453</i>&nbsp;    public static byte getCPRefOpTag(int bc) {
<b class="nc"><i>454</i>&nbsp;        if (bc &lt; BC_INDEX[0].length &amp;&amp; BC_INDEX[0][bc] &gt; 0)  return BC_TAG[0][bc];</b>
<b class="nc"><i>455</i>&nbsp;        if (bc &gt;= _xldc_op &amp;&amp; bc &lt; _xldc_limit)  return CONSTANT_LoadableValue;</b>
<b class="nc"><i>456</i>&nbsp;        if (bc == _invokestatic_int || bc == _invokespecial_int) return CONSTANT_InterfaceMethodref;</b>
<b class="nc"><i>457</i>&nbsp;        return CONSTANT_None;</b>
<i>458</i>&nbsp;    }
<i>459</i>&nbsp;
<i>460</i>&nbsp;    public static boolean isFieldOp(int bc) {
<b class="nc"><i>461</i>&nbsp;        return (bc &gt;= _getstatic &amp;&amp; bc &lt;= _putfield);</b>
<i>462</i>&nbsp;    }
<i>463</i>&nbsp;
<i>464</i>&nbsp;    public static boolean isInvokeInitOp(int bc) {
<b class="nc"><i>465</i>&nbsp;        return (bc &gt;= _invokeinit_op &amp;&amp; bc &lt; _invokeinit_limit);</b>
<i>466</i>&nbsp;    }
<i>467</i>&nbsp;
<i>468</i>&nbsp;    public static boolean isSelfLinkerOp(int bc) {
<b class="nc"><i>469</i>&nbsp;        return (bc &gt;= _self_linker_op &amp;&amp; bc &lt; _self_linker_limit);</b>
<i>470</i>&nbsp;    }
<i>471</i>&nbsp;
<i>472</i>&nbsp;    /// Format definitions.
<i>473</i>&nbsp;
<b class="nc"><i>474</i>&nbsp;    private static final byte[][] BC_LENGTH  = new byte[2][0x100];</b>
<b class="nc"><i>475</i>&nbsp;    private static final byte[][] BC_INDEX   = new byte[2][0x100];</b>
<b class="nc"><i>476</i>&nbsp;    private static final byte[][] BC_TAG     = new byte[2][0x100];</b>
<b class="nc"><i>477</i>&nbsp;    private static final byte[][] BC_BRANCH  = new byte[2][0x100];</b>
<b class="nc"><i>478</i>&nbsp;    private static final byte[][] BC_SLOT    = new byte[2][0x100];</b>
<b class="nc"><i>479</i>&nbsp;    private static final byte[][] BC_CON     = new byte[2][0x100];</b>
<b class="nc"><i>480</i>&nbsp;    private static final String[] BC_NAME    = new String[0x100]; // debug only</b>
<b class="nc"><i>481</i>&nbsp;    private static final String[][] BC_FORMAT  = new String[2][_bytecode_limit]; // debug only</b>
<i>482</i>&nbsp;    static {
<b class="nc"><i>483</i>&nbsp;        for (int i = 0; i &lt; _bytecode_limit; i++) {</b>
<b class="nc"><i>484</i>&nbsp;            BC_LENGTH[0][i] = -1;</b>
<b class="nc"><i>485</i>&nbsp;            BC_LENGTH[1][i] = -1;</b>
<i>486</i>&nbsp;        }
<b class="nc"><i>487</i>&nbsp;        def(&quot;b&quot;, _nop, _dconst_1);</b>
<b class="nc"><i>488</i>&nbsp;        def(&quot;bx&quot;, _bipush);</b>
<b class="nc"><i>489</i>&nbsp;        def(&quot;bxx&quot;, _sipush);</b>
<b class="nc"><i>490</i>&nbsp;        def(&quot;bk&quot;, _ldc);                                // do not pack</b>
<b class="nc"><i>491</i>&nbsp;        def(&quot;bkk&quot;, _ldc_w, _ldc2_w);            // do not pack</b>
<b class="nc"><i>492</i>&nbsp;        def(&quot;blwbll&quot;, _iload, _aload);</b>
<b class="nc"><i>493</i>&nbsp;        def(&quot;b&quot;, _iload_0, _saload);</b>
<b class="nc"><i>494</i>&nbsp;        def(&quot;blwbll&quot;, _istore, _astore);</b>
<b class="nc"><i>495</i>&nbsp;        def(&quot;b&quot;, _istore_0, _lxor);</b>
<b class="nc"><i>496</i>&nbsp;        def(&quot;blxwbllxx&quot;, _iinc);</b>
<b class="nc"><i>497</i>&nbsp;        def(&quot;b&quot;, _i2l, _dcmpg);</b>
<b class="nc"><i>498</i>&nbsp;        def(&quot;boo&quot;, _ifeq, _jsr);                        // pack oo</b>
<b class="nc"><i>499</i>&nbsp;        def(&quot;blwbll&quot;, _ret);</b>
<b class="nc"><i>500</i>&nbsp;        def(&quot;&quot;, _tableswitch, _lookupswitch);   // pack all ints, omit padding</b>
<b class="nc"><i>501</i>&nbsp;        def(&quot;b&quot;, _ireturn, _return);</b>
<b class="nc"><i>502</i>&nbsp;        def(&quot;bkf&quot;, _getstatic, _putfield);              // pack kf (base=Field)</b>
<b class="nc"><i>503</i>&nbsp;        def(&quot;bkm&quot;, _invokevirtual, _invokestatic);      // pack kn (base=Method)</b>
<b class="nc"><i>504</i>&nbsp;        def(&quot;bkixx&quot;, _invokeinterface);         // pack ki (base=IMethod), omit xx</b>
<b class="nc"><i>505</i>&nbsp;        def(&quot;bkyxx&quot;, _invokedynamic);           // pack ky (base=Any), omit xx</b>
<b class="nc"><i>506</i>&nbsp;        def(&quot;bkc&quot;, _new);                               // pack kc</b>
<b class="nc"><i>507</i>&nbsp;        def(&quot;bx&quot;, _newarray);</b>
<b class="nc"><i>508</i>&nbsp;        def(&quot;bkc&quot;, _anewarray);                 // pack kc</b>
<b class="nc"><i>509</i>&nbsp;        def(&quot;b&quot;, _arraylength, _athrow);</b>
<b class="nc"><i>510</i>&nbsp;        def(&quot;bkc&quot;, _checkcast, _instanceof);    // pack kc</b>
<b class="nc"><i>511</i>&nbsp;        def(&quot;b&quot;, _monitorenter, _monitorexit);</b>
<b class="nc"><i>512</i>&nbsp;        def(&quot;&quot;, _wide);</b>
<b class="nc"><i>513</i>&nbsp;        def(&quot;bkcx&quot;, _multianewarray);           // pack kc</b>
<b class="nc"><i>514</i>&nbsp;        def(&quot;boo&quot;, _ifnull, _ifnonnull);                // pack oo</b>
<b class="nc"><i>515</i>&nbsp;        def(&quot;boooo&quot;, _goto_w, _jsr_w);          // pack oooo</b>
<b class="nc"><i>516</i>&nbsp;        for (int i = 0; i &lt; _bytecode_limit; i++) {</b>
<i>517</i>&nbsp;            //System.out.println(i+&quot;: l=&quot;+BC_LENGTH[0][i]+&quot; i=&quot;+BC_INDEX[0][i]);
<i>518</i>&nbsp;            //assert(BC_LENGTH[0][i] != -1);
<b class="nc"><i>519</i>&nbsp;            if (BC_LENGTH[0][i] == -1) {</b>
<b class="nc"><i>520</i>&nbsp;                continue;  // unknown opcode</b>
<i>521</i>&nbsp;            }
<i>522</i>&nbsp;
<i>523</i>&nbsp;            // Have a complete mapping, to support spurious _wide prefixes.
<b class="nc"><i>524</i>&nbsp;            if (BC_LENGTH[1][i] == -1)</b>
<b class="nc"><i>525</i>&nbsp;                BC_LENGTH[1][i] = (byte)(1+BC_LENGTH[0][i]);</b>
<i>526</i>&nbsp;        }
<i>527</i>&nbsp;
<b class="nc"><i>528</i>&nbsp;        String names =</b>
<i>529</i>&nbsp;  &quot;nop aconst_null iconst_m1 iconst_0 iconst_1 iconst_2 iconst_3 iconst_4 &quot;+
<i>530</i>&nbsp;  &quot;iconst_5 lconst_0 lconst_1 fconst_0 fconst_1 fconst_2 dconst_0 dconst_1 &quot;+
<i>531</i>&nbsp;  &quot;bipush sipush ldc ldc_w ldc2_w iload lload fload dload aload iload_0 &quot;+
<i>532</i>&nbsp;  &quot;iload_1 iload_2 iload_3 lload_0 lload_1 lload_2 lload_3 fload_0 fload_1 &quot;+
<i>533</i>&nbsp;  &quot;fload_2 fload_3 dload_0 dload_1 dload_2 dload_3 aload_0 aload_1 aload_2 &quot;+
<i>534</i>&nbsp;  &quot;aload_3 iaload laload faload daload aaload baload caload saload istore &quot;+
<i>535</i>&nbsp;  &quot;lstore fstore dstore astore istore_0 istore_1 istore_2 istore_3 lstore_0 &quot;+
<i>536</i>&nbsp;  &quot;lstore_1 lstore_2 lstore_3 fstore_0 fstore_1 fstore_2 fstore_3 dstore_0 &quot;+
<i>537</i>&nbsp;  &quot;dstore_1 dstore_2 dstore_3 astore_0 astore_1 astore_2 astore_3 iastore &quot;+
<i>538</i>&nbsp;  &quot;lastore fastore dastore aastore bastore castore sastore pop pop2 dup &quot;+
<i>539</i>&nbsp;  &quot;dup_x1 dup_x2 dup2 dup2_x1 dup2_x2 swap iadd ladd fadd dadd isub lsub &quot;+
<i>540</i>&nbsp;  &quot;fsub dsub imul lmul fmul dmul idiv ldiv fdiv ddiv irem lrem frem drem &quot;+
<i>541</i>&nbsp;  &quot;ineg lneg fneg dneg ishl lshl ishr lshr iushr lushr iand land ior lor &quot;+
<i>542</i>&nbsp;  &quot;ixor lxor iinc i2l i2f i2d l2i l2f l2d f2i f2l f2d d2i d2l d2f i2b i2c &quot;+
<i>543</i>&nbsp;  &quot;i2s lcmp fcmpl fcmpg dcmpl dcmpg ifeq ifne iflt ifge ifgt ifle if_icmpeq &quot;+
<i>544</i>&nbsp;  &quot;if_icmpne if_icmplt if_icmpge if_icmpgt if_icmple if_acmpeq if_acmpne &quot;+
<i>545</i>&nbsp;  &quot;goto jsr ret tableswitch lookupswitch ireturn lreturn freturn dreturn &quot;+
<i>546</i>&nbsp;  &quot;areturn return getstatic putstatic getfield putfield invokevirtual &quot;+
<i>547</i>&nbsp;  &quot;invokespecial invokestatic invokeinterface invokedynamic new newarray &quot;+
<i>548</i>&nbsp;  &quot;anewarray arraylength athrow checkcast instanceof monitorenter &quot;+
<i>549</i>&nbsp;  &quot;monitorexit wide multianewarray ifnull ifnonnull goto_w jsr_w &quot;;
<b class="nc"><i>550</i>&nbsp;        for (int bc = 0; names.length() &gt; 0; bc++) {</b>
<b class="nc"><i>551</i>&nbsp;            int sp = names.indexOf(&#39; &#39;);</b>
<b class="nc"><i>552</i>&nbsp;            BC_NAME[bc] = names.substring(0, sp);</b>
<b class="nc"><i>553</i>&nbsp;            names = names.substring(sp+1);</b>
<i>554</i>&nbsp;        }
<i>555</i>&nbsp;    }
<i>556</i>&nbsp;    public static String byteName(int bc) {
<i>557</i>&nbsp;        String iname;
<b class="nc"><i>558</i>&nbsp;        if (bc &lt; BC_NAME.length &amp;&amp; BC_NAME[bc] != null) {</b>
<b class="nc"><i>559</i>&nbsp;            iname = BC_NAME[bc];</b>
<b class="nc"><i>560</i>&nbsp;        } else if (isSelfLinkerOp(bc)) {</b>
<b class="nc"><i>561</i>&nbsp;            int idx = (bc - _self_linker_op);</b>
<b class="nc"><i>562</i>&nbsp;            boolean isSuper = (idx &gt;= _self_linker_super_flag);</b>
<b class="nc"><i>563</i>&nbsp;            if (isSuper)  idx -= _self_linker_super_flag;</b>
<b class="nc"><i>564</i>&nbsp;            boolean isAload = (idx &gt;= _self_linker_aload_flag);</b>
<b class="nc"><i>565</i>&nbsp;            if (isAload)  idx -= _self_linker_aload_flag;</b>
<b class="nc"><i>566</i>&nbsp;            int origBC = _first_linker_op + idx;</b>
<b class="nc"><i>567</i>&nbsp;            assert(origBC &gt;= _first_linker_op &amp;&amp; origBC &lt;= _last_linker_op);</b>
<b class="nc"><i>568</i>&nbsp;            iname = BC_NAME[origBC];</b>
<b class="nc"><i>569</i>&nbsp;            iname += (isSuper ? &quot;_super&quot; : &quot;_this&quot;);</b>
<b class="nc"><i>570</i>&nbsp;            if (isAload)  iname = &quot;aload_0&amp;&quot; + iname;</b>
<b class="nc"><i>571</i>&nbsp;            iname = &quot;*&quot;+iname;</b>
<b class="nc"><i>572</i>&nbsp;        } else if (isInvokeInitOp(bc)) {</b>
<b class="nc"><i>573</i>&nbsp;            int idx = (bc - _invokeinit_op);</b>
<b class="nc"><i>574</i>&nbsp;            switch (idx) {</b>
<i>575</i>&nbsp;            case _invokeinit_self_option:
<b class="nc"><i>576</i>&nbsp;                iname = &quot;*invokespecial_init_this&quot;; break;</b>
<i>577</i>&nbsp;            case _invokeinit_super_option:
<b class="nc"><i>578</i>&nbsp;                iname = &quot;*invokespecial_init_super&quot;; break;</b>
<i>579</i>&nbsp;            default:
<b class="nc"><i>580</i>&nbsp;                assert(idx == _invokeinit_new_option);</b>
<b class="nc"><i>581</i>&nbsp;                iname = &quot;*invokespecial_init_new&quot;; break;</b>
<i>582</i>&nbsp;            }
<b class="nc"><i>583</i>&nbsp;        } else {</b>
<b class="nc"><i>584</i>&nbsp;            switch (bc) {</b>
<b class="nc"><i>585</i>&nbsp;            case _ildc:  iname = &quot;*ildc&quot;; break;</b>
<b class="nc"><i>586</i>&nbsp;            case _fldc:  iname = &quot;*fldc&quot;; break;</b>
<b class="nc"><i>587</i>&nbsp;            case _ildc_w:  iname = &quot;*ildc_w&quot;; break;</b>
<b class="nc"><i>588</i>&nbsp;            case _fldc_w:  iname = &quot;*fldc_w&quot;; break;</b>
<b class="nc"><i>589</i>&nbsp;            case _dldc2_w:  iname = &quot;*dldc2_w&quot;; break;</b>
<b class="nc"><i>590</i>&nbsp;            case _cldc:  iname = &quot;*cldc&quot;; break;</b>
<b class="nc"><i>591</i>&nbsp;            case _cldc_w:  iname = &quot;*cldc_w&quot;; break;</b>
<b class="nc"><i>592</i>&nbsp;            case _qldc:  iname = &quot;*qldc&quot;; break;</b>
<b class="nc"><i>593</i>&nbsp;            case _qldc_w:  iname = &quot;*qldc_w&quot;; break;</b>
<b class="nc"><i>594</i>&nbsp;            case _byte_escape:  iname = &quot;*byte_escape&quot;; break;</b>
<b class="nc"><i>595</i>&nbsp;            case _ref_escape:  iname = &quot;*ref_escape&quot;; break;</b>
<b class="nc"><i>596</i>&nbsp;            case _end_marker:  iname = &quot;*end&quot;; break;</b>
<b class="nc"><i>597</i>&nbsp;            default:  iname = &quot;*bc#&quot;+bc; break;</b>
<i>598</i>&nbsp;            }
<i>599</i>&nbsp;        }
<b class="nc"><i>600</i>&nbsp;        return iname;</b>
<i>601</i>&nbsp;    }
<b class="nc"><i>602</i>&nbsp;    private static int BW = 4;  // width of classification field</b>
<i>603</i>&nbsp;    private static void def(String fmt, int bc) {
<b class="nc"><i>604</i>&nbsp;        def(fmt, bc, bc);</b>
<i>605</i>&nbsp;    }
<i>606</i>&nbsp;    private static void def(String fmt, int from_bc, int to_bc) {
<b class="nc"><i>607</i>&nbsp;        String[] fmts = { fmt, null };</b>
<b class="nc"><i>608</i>&nbsp;        if (fmt.indexOf(&#39;w&#39;) &gt; 0) {</b>
<b class="nc"><i>609</i>&nbsp;            fmts[1] = fmt.substring(fmt.indexOf(&#39;w&#39;));</b>
<b class="nc"><i>610</i>&nbsp;            fmts[0] = fmt.substring(0, fmt.indexOf(&#39;w&#39;));</b>
<i>611</i>&nbsp;        }
<b class="nc"><i>612</i>&nbsp;        for (int w = 0; w &lt;= 1; w++) {</b>
<b class="nc"><i>613</i>&nbsp;            fmt = fmts[w];</b>
<b class="nc"><i>614</i>&nbsp;            if (fmt == null)  continue;</b>
<b class="nc"><i>615</i>&nbsp;            int length = fmt.length();</b>
<b class="nc"><i>616</i>&nbsp;            int index  = Math.max(0, fmt.indexOf(&#39;k&#39;));</b>
<b class="nc"><i>617</i>&nbsp;            int tag    = CONSTANT_None;</b>
<b class="nc"><i>618</i>&nbsp;            int branch = Math.max(0, fmt.indexOf(&#39;o&#39;));</b>
<b class="nc"><i>619</i>&nbsp;            int slot   = Math.max(0, fmt.indexOf(&#39;l&#39;));</b>
<b class="nc"><i>620</i>&nbsp;            int con    = Math.max(0, fmt.indexOf(&#39;x&#39;));</b>
<b class="nc"><i>621</i>&nbsp;            if (index &gt; 0 &amp;&amp; index+1 &lt; length) {</b>
<b class="nc"><i>622</i>&nbsp;                switch (fmt.charAt(index+1)) {</b>
<b class="nc"><i>623</i>&nbsp;                    case &#39;c&#39;: tag = CONSTANT_Class; break;</b>
<b class="nc"><i>624</i>&nbsp;                    case &#39;k&#39;: tag = CONSTANT_LoadableValue; break;</b>
<b class="nc"><i>625</i>&nbsp;                    case &#39;f&#39;: tag = CONSTANT_Fieldref; break;</b>
<b class="nc"><i>626</i>&nbsp;                    case &#39;m&#39;: tag = CONSTANT_Methodref; break;</b>
<b class="nc"><i>627</i>&nbsp;                    case &#39;i&#39;: tag = CONSTANT_InterfaceMethodref; break;</b>
<b class="nc"><i>628</i>&nbsp;                    case &#39;y&#39;: tag = CONSTANT_InvokeDynamic; break;</b>
<i>629</i>&nbsp;                }
<b class="nc"><i>630</i>&nbsp;                assert(tag != CONSTANT_None);</b>
<b class="nc"><i>631</i>&nbsp;            } else if (index &gt; 0 &amp;&amp; length == 2) {</b>
<b class="nc"><i>632</i>&nbsp;                assert(from_bc == _ldc);</b>
<b class="nc"><i>633</i>&nbsp;                tag = CONSTANT_LoadableValue;  // _ldc opcode only</b>
<i>634</i>&nbsp;            }
<b class="nc"><i>635</i>&nbsp;            for (int bc = from_bc; bc &lt;= to_bc; bc++) {</b>
<b class="nc"><i>636</i>&nbsp;                BC_FORMAT[w][bc] = fmt;</b>
<b class="nc"><i>637</i>&nbsp;                assert(BC_LENGTH[w][bc] == -1);</b>
<b class="nc"><i>638</i>&nbsp;                BC_LENGTH[w][bc] = (byte) length;</b>
<b class="nc"><i>639</i>&nbsp;                BC_INDEX[w][bc]  = (byte) index;</b>
<b class="nc"><i>640</i>&nbsp;                BC_TAG[w][bc]    = (byte) tag;</b>
<b class="nc"><i>641</i>&nbsp;                assert(!(index == 0 &amp;&amp; tag != CONSTANT_None));</b>
<b class="nc"><i>642</i>&nbsp;                BC_BRANCH[w][bc] = (byte) branch;</b>
<b class="nc"><i>643</i>&nbsp;                BC_SLOT[w][bc]   = (byte) slot;</b>
<b class="nc"><i>644</i>&nbsp;                assert(branch == 0 || slot == 0);   // not both branch &amp; local</b>
<b class="nc"><i>645</i>&nbsp;                assert(branch == 0 || index == 0);  // not both branch &amp; cp</b>
<b class="nc"><i>646</i>&nbsp;                assert(slot == 0   || index == 0);  // not both local &amp; cp</b>
<b class="nc"><i>647</i>&nbsp;                BC_CON[w][bc]    = (byte) con;</b>
<i>648</i>&nbsp;            }
<i>649</i>&nbsp;        }
<i>650</i>&nbsp;    }
<i>651</i>&nbsp;
<i>652</i>&nbsp;    public static void opcodeChecker(byte[] code, ConstantPool.Entry[] cpMap,
<i>653</i>&nbsp;            Package.Version clsVersion) throws FormatException {
<b class="nc"><i>654</i>&nbsp;        Instruction i = at(code, 0);</b>
<b class="nc"><i>655</i>&nbsp;        while (i != null) {</b>
<b class="nc"><i>656</i>&nbsp;            int opcode = i.getBC();</b>
<b class="nc"><i>657</i>&nbsp;            if (opcode &lt; _nop || opcode &gt; _jsr_w) {</b>
<b class="nc"><i>658</i>&nbsp;                String message = &quot;illegal opcode: &quot; + opcode + &quot; &quot; + i;</b>
<b class="nc"><i>659</i>&nbsp;                throw new FormatException(message);</b>
<i>660</i>&nbsp;            }
<b class="nc"><i>661</i>&nbsp;            ConstantPool.Entry e = i.getCPRef(cpMap);</b>
<b class="nc"><i>662</i>&nbsp;            if (e != null) {</b>
<b class="nc"><i>663</i>&nbsp;                byte tag = i.getCPTag();</b>
<b class="nc"><i>664</i>&nbsp;                boolean match = e.tagMatches(tag);</b>
<b class="nc"><i>665</i>&nbsp;                if (!match &amp;&amp;</b>
<i>666</i>&nbsp;                        (i.bc == _invokespecial || i.bc == _invokestatic) &amp;&amp;
<b class="nc"><i>667</i>&nbsp;                        e.tagMatches(CONSTANT_InterfaceMethodref) &amp;&amp;</b>
<b class="nc"><i>668</i>&nbsp;                        clsVersion.greaterThan(Constants.JAVA7_MAX_CLASS_VERSION)) {</b>
<b class="nc"><i>669</i>&nbsp;                    match = true;</b>
<i>670</i>&nbsp;                }
<b class="nc"><i>671</i>&nbsp;                if (!match) {</b>
<b class="nc"><i>672</i>&nbsp;                    String message = &quot;illegal reference, expected type=&quot;</b>
<b class="nc"><i>673</i>&nbsp;                            + ConstantPool.tagName(tag) + &quot;: &quot;</b>
<b class="nc"><i>674</i>&nbsp;                            + i.toString(cpMap);</b>
<b class="nc"><i>675</i>&nbsp;                    throw new FormatException(message);</b>
<i>676</i>&nbsp;                }
<i>677</i>&nbsp;            }
<b class="nc"><i>678</i>&nbsp;            i = i.next();</b>
<b class="nc"><i>679</i>&nbsp;        }</b>
<i>680</i>&nbsp;    }
<i>681</i>&nbsp;    static class FormatException extends IOException {
<i>682</i>&nbsp;        private static final long serialVersionUID = 3175572275651367015L;
<i>683</i>&nbsp;
<i>684</i>&nbsp;        FormatException(String message) {
<b class="nc"><i>685</i>&nbsp;            super(message);</b>
<i>686</i>&nbsp;        }
<i>687</i>&nbsp;    }
<i>688</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
