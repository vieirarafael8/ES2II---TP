


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: PackageReader</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.java.util.jar.pack</a> ]
</div>

<h1>Coverage Summary for Class: PackageReader (com.sun.java.util.jar.pack)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PackageReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1279)
  </span>
</td>
</tr>
  <tr>
    <td class="name">PackageReader$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageReader$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageReader$LimitedBuffer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageReader$LimitedBuffer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1334)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.java.util.jar.pack;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.java.util.jar.pack.ConstantPool.*;
<i>29</i>&nbsp;import com.sun.java.util.jar.pack.Package.Class;
<i>30</i>&nbsp;import com.sun.java.util.jar.pack.Package.File;
<i>31</i>&nbsp;import com.sun.java.util.jar.pack.Package.InnerClass;
<i>32</i>&nbsp;import java.io.ByteArrayOutputStream;
<i>33</i>&nbsp;import java.io.EOFException;
<i>34</i>&nbsp;import java.io.PrintStream;
<i>35</i>&nbsp;import java.io.FilterInputStream;
<i>36</i>&nbsp;import java.io.BufferedInputStream;
<i>37</i>&nbsp;import java.io.InputStream;
<i>38</i>&nbsp;import java.io.IOException;
<i>39</i>&nbsp;import java.util.ArrayList;
<i>40</i>&nbsp;import java.util.Map;
<i>41</i>&nbsp;import java.util.Arrays;
<i>42</i>&nbsp;import java.util.Collection;
<i>43</i>&nbsp;import java.util.Collections;
<i>44</i>&nbsp;import java.util.Comparator;
<i>45</i>&nbsp;import java.util.HashSet;
<i>46</i>&nbsp;import java.util.HashMap;
<i>47</i>&nbsp;import java.util.Iterator;
<i>48</i>&nbsp;import java.util.List;
<i>49</i>&nbsp;import java.util.ListIterator;
<i>50</i>&nbsp;import java.util.Set;
<i>51</i>&nbsp;import static com.sun.java.util.jar.pack.Constants.*;
<i>52</i>&nbsp;
<i>53</i>&nbsp;/**
<i>54</i>&nbsp; * Reader for a package file.
<i>55</i>&nbsp; *
<i>56</i>&nbsp; * @see PackageWriter
<i>57</i>&nbsp; * @author John Rose
<i>58</i>&nbsp; */
<b class="nc"><i>59</i>&nbsp;class PackageReader extends BandStructure {</b>
<i>60</i>&nbsp;    Package pkg;
<i>61</i>&nbsp;    byte[] bytes;
<i>62</i>&nbsp;    LimitedBuffer in;
<i>63</i>&nbsp;    Package.Version packageVersion;
<i>64</i>&nbsp;
<b class="nc"><i>65</i>&nbsp;    PackageReader(Package pkg, InputStream in) throws IOException {</b>
<b class="nc"><i>66</i>&nbsp;        this.pkg = pkg;</b>
<b class="nc"><i>67</i>&nbsp;        this.in = new LimitedBuffer(in);</b>
<i>68</i>&nbsp;    }
<i>69</i>&nbsp;
<i>70</i>&nbsp;    /** A buffered input stream which is careful not to
<i>71</i>&nbsp;     *  read its underlying stream ahead of a given mark,
<i>72</i>&nbsp;     *  called the &#39;readLimit&#39;.  This property declares
<i>73</i>&nbsp;     *  the maximum number of characters that future reads
<i>74</i>&nbsp;     *  can consume from the underlying stream.
<i>75</i>&nbsp;     */
<b class="nc"><i>76</i>&nbsp;    static</b>
<i>77</i>&nbsp;    class LimitedBuffer extends BufferedInputStream {
<i>78</i>&nbsp;        long served;     // total number of charburgers served
<i>79</i>&nbsp;        int  servedPos;  // ...as of this value of super.pos
<i>80</i>&nbsp;        long limit;      // current declared limit
<i>81</i>&nbsp;        long buffered;
<i>82</i>&nbsp;        public boolean atLimit() {
<b class="nc"><i>83</i>&nbsp;            boolean z = (getBytesServed() == limit);</b>
<b class="nc"><i>84</i>&nbsp;            assert(!z || limit == buffered);</b>
<b class="nc"><i>85</i>&nbsp;            return z;</b>
<i>86</i>&nbsp;        }
<i>87</i>&nbsp;        public long getBytesServed() {
<b class="nc"><i>88</i>&nbsp;            return served + (pos - servedPos);</b>
<i>89</i>&nbsp;        }
<i>90</i>&nbsp;        public void setReadLimit(long newLimit) {
<b class="nc"><i>91</i>&nbsp;            if (newLimit == -1)</b>
<b class="nc"><i>92</i>&nbsp;                limit = -1;</b>
<i>93</i>&nbsp;            else
<b class="nc"><i>94</i>&nbsp;                limit = getBytesServed() + newLimit;</b>
<i>95</i>&nbsp;        }
<i>96</i>&nbsp;        public long getReadLimit() {
<b class="nc"><i>97</i>&nbsp;            if (limit == -1)</b>
<b class="nc"><i>98</i>&nbsp;                return limit;</b>
<i>99</i>&nbsp;            else
<b class="nc"><i>100</i>&nbsp;                return limit - getBytesServed();</b>
<i>101</i>&nbsp;        }
<i>102</i>&nbsp;        public int read() throws IOException {
<b class="nc"><i>103</i>&nbsp;            if (pos &lt; count) {</b>
<i>104</i>&nbsp;                // fast path
<b class="nc"><i>105</i>&nbsp;                return buf[pos++] &amp; 0xFF;</b>
<i>106</i>&nbsp;            }
<b class="nc"><i>107</i>&nbsp;            served += (pos - servedPos);</b>
<b class="nc"><i>108</i>&nbsp;            int ch = super.read();</b>
<b class="nc"><i>109</i>&nbsp;            servedPos = pos;</b>
<b class="nc"><i>110</i>&nbsp;            if (ch &gt;= 0)  served += 1;</b>
<b class="nc"><i>111</i>&nbsp;            assert(served &lt;= limit || limit == -1);</b>
<b class="nc"><i>112</i>&nbsp;            return ch;</b>
<i>113</i>&nbsp;        }
<i>114</i>&nbsp;        public int read(byte b[], int off, int len) throws IOException {
<b class="nc"><i>115</i>&nbsp;            served += (pos - servedPos);</b>
<b class="nc"><i>116</i>&nbsp;            int nr = super.read(b, off, len);</b>
<b class="nc"><i>117</i>&nbsp;            servedPos = pos;</b>
<b class="nc"><i>118</i>&nbsp;            if (nr &gt;= 0)  served += nr;</b>
<i>119</i>&nbsp;            //assert(served &lt;= limit || limit == -1);
<b class="nc"><i>120</i>&nbsp;            return nr;</b>
<i>121</i>&nbsp;        }
<i>122</i>&nbsp;        public long skip(long n) throws IOException {
<b class="nc"><i>123</i>&nbsp;            throw new RuntimeException(&quot;no skipping&quot;);</b>
<i>124</i>&nbsp;        }
<i>125</i>&nbsp;        LimitedBuffer(InputStream originalIn) {
<b class="nc"><i>126</i>&nbsp;            super(null, 1&lt;&lt;14);</b>
<b class="nc"><i>127</i>&nbsp;            servedPos = pos;</b>
<b class="nc"><i>128</i>&nbsp;            super.in = new FilterInputStream(originalIn) {</b>
<i>129</i>&nbsp;                public int read() throws IOException {
<b class="nc"><i>130</i>&nbsp;                    if (buffered == limit)</b>
<b class="nc"><i>131</i>&nbsp;                        return -1;</b>
<b class="nc"><i>132</i>&nbsp;                    ++buffered;</b>
<b class="nc"><i>133</i>&nbsp;                    return super.read();</b>
<i>134</i>&nbsp;                }
<i>135</i>&nbsp;                public int read(byte b[], int off, int len) throws IOException {
<b class="nc"><i>136</i>&nbsp;                    if (buffered == limit)</b>
<b class="nc"><i>137</i>&nbsp;                        return -1;</b>
<b class="nc"><i>138</i>&nbsp;                    if (limit != -1) {</b>
<b class="nc"><i>139</i>&nbsp;                        long remaining = limit - buffered;</b>
<b class="nc"><i>140</i>&nbsp;                        if (len &gt; remaining)</b>
<b class="nc"><i>141</i>&nbsp;                            len = (int)remaining;</b>
<i>142</i>&nbsp;                    }
<b class="nc"><i>143</i>&nbsp;                    int nr = super.read(b, off, len);</b>
<b class="nc"><i>144</i>&nbsp;                    if (nr &gt;= 0)  buffered += nr;</b>
<b class="nc"><i>145</i>&nbsp;                    return nr;</b>
<i>146</i>&nbsp;                }
<i>147</i>&nbsp;            };
<i>148</i>&nbsp;        }
<i>149</i>&nbsp;    }
<i>150</i>&nbsp;
<i>151</i>&nbsp;    void read() throws IOException {
<b class="nc"><i>152</i>&nbsp;        boolean ok = false;</b>
<i>153</i>&nbsp;        try {
<i>154</i>&nbsp;            //  pack200_archive:
<i>155</i>&nbsp;            //        file_header
<i>156</i>&nbsp;            //        *band_headers :BYTE1
<i>157</i>&nbsp;            //        cp_bands
<i>158</i>&nbsp;            //        attr_definition_bands
<i>159</i>&nbsp;            //        ic_bands
<i>160</i>&nbsp;            //        class_bands
<i>161</i>&nbsp;            //        bc_bands
<i>162</i>&nbsp;            //        file_bands
<b class="nc"><i>163</i>&nbsp;            readFileHeader();</b>
<b class="nc"><i>164</i>&nbsp;            readBandHeaders();</b>
<b class="nc"><i>165</i>&nbsp;            readConstantPool();  // cp_bands</b>
<b class="nc"><i>166</i>&nbsp;            readAttrDefs();</b>
<b class="nc"><i>167</i>&nbsp;            readInnerClasses();</b>
<b class="nc"><i>168</i>&nbsp;            Class[] classes = readClasses();</b>
<b class="nc"><i>169</i>&nbsp;            readByteCodes();</b>
<b class="nc"><i>170</i>&nbsp;            readFiles();     // file_bands</b>
<b class="nc"><i>171</i>&nbsp;            assert(archiveSize1 == 0 || in.atLimit());</b>
<b class="nc"><i>172</i>&nbsp;            assert(archiveSize1 == 0 ||</b>
<b class="nc"><i>173</i>&nbsp;                   in.getBytesServed() == archiveSize0+archiveSize1);</b>
<b class="nc"><i>174</i>&nbsp;            all_bands.doneDisbursing();</b>
<i>175</i>&nbsp;
<i>176</i>&nbsp;            // As a post-pass, build constant pools and inner classes.
<b class="nc"><i>177</i>&nbsp;            for (int i = 0; i &lt; classes.length; i++) {</b>
<b class="nc"><i>178</i>&nbsp;                reconstructClass(classes[i]);</b>
<i>179</i>&nbsp;            }
<i>180</i>&nbsp;
<b class="nc"><i>181</i>&nbsp;            ok = true;</b>
<b class="nc"><i>182</i>&nbsp;        } catch (Exception ee) {</b>
<b class="nc"><i>183</i>&nbsp;            Utils.log.warning(&quot;Error on input: &quot;+ee, ee);</b>
<b class="nc"><i>184</i>&nbsp;            if (verbose &gt; 0)</b>
<b class="nc"><i>185</i>&nbsp;                Utils.log.info(&quot;Stream offsets:&quot;+</b>
<b class="nc"><i>186</i>&nbsp;                                 &quot; served=&quot;+in.getBytesServed()+</b>
<i>187</i>&nbsp;                                 &quot; buffered=&quot;+in.buffered+
<i>188</i>&nbsp;                                 &quot; limit=&quot;+in.limit);
<i>189</i>&nbsp;            //if (verbose &gt; 0)  ee.printStackTrace();
<b class="nc"><i>190</i>&nbsp;            if (ee instanceof IOException)  throw (IOException)ee;</b>
<b class="nc"><i>191</i>&nbsp;            if (ee instanceof RuntimeException)  throw (RuntimeException)ee;</b>
<b class="nc"><i>192</i>&nbsp;            throw new Error(&quot;error unpacking&quot;, ee);</b>
<b class="nc"><i>193</i>&nbsp;        }</b>
<i>194</i>&nbsp;    }
<i>195</i>&nbsp;
<i>196</i>&nbsp;    // Temporary count values, until band decoding gets rolling.
<b class="nc"><i>197</i>&nbsp;    int[] tagCount = new int[CONSTANT_Limit];</b>
<i>198</i>&nbsp;    int numFiles;
<i>199</i>&nbsp;    int numAttrDefs;
<i>200</i>&nbsp;    int numInnerClasses;
<i>201</i>&nbsp;    int numClasses;
<i>202</i>&nbsp;
<i>203</i>&nbsp;    void readFileHeader() throws IOException {
<i>204</i>&nbsp;        //  file_header:
<i>205</i>&nbsp;        //        archive_magic archive_header
<b class="nc"><i>206</i>&nbsp;        readArchiveMagic();</b>
<b class="nc"><i>207</i>&nbsp;        readArchiveHeader();</b>
<i>208</i>&nbsp;    }
<i>209</i>&nbsp;
<i>210</i>&nbsp;    // Local routine used to parse fixed-format scalars
<i>211</i>&nbsp;    // in the file_header:
<i>212</i>&nbsp;    private int getMagicInt32() throws IOException {
<b class="nc"><i>213</i>&nbsp;        int res = 0;</b>
<b class="nc"><i>214</i>&nbsp;        for (int i = 0; i &lt; 4; i++) {</b>
<b class="nc"><i>215</i>&nbsp;            res &lt;&lt;= 8;</b>
<b class="nc"><i>216</i>&nbsp;            res |= (archive_magic.getByte() &amp; 0xFF);</b>
<i>217</i>&nbsp;        }
<b class="nc"><i>218</i>&nbsp;        return res;</b>
<i>219</i>&nbsp;    }
<i>220</i>&nbsp;
<i>221</i>&nbsp;    static final int MAGIC_BYTES = 4;
<i>222</i>&nbsp;
<i>223</i>&nbsp;    void readArchiveMagic() throws IOException {
<i>224</i>&nbsp;        // Read a minimum of bytes in the first gulp.
<b class="nc"><i>225</i>&nbsp;        in.setReadLimit(MAGIC_BYTES + AH_LENGTH_MIN);</b>
<i>226</i>&nbsp;
<i>227</i>&nbsp;        //  archive_magic:
<i>228</i>&nbsp;        //        #archive_magic_word :BYTE1[4]
<b class="nc"><i>229</i>&nbsp;        archive_magic.expectLength(MAGIC_BYTES);</b>
<b class="nc"><i>230</i>&nbsp;        archive_magic.readFrom(in);</b>
<i>231</i>&nbsp;
<i>232</i>&nbsp;        // read and check magic numbers:
<b class="nc"><i>233</i>&nbsp;        int magic = getMagicInt32();</b>
<b class="nc"><i>234</i>&nbsp;        if (pkg.magic != magic) {</b>
<b class="nc"><i>235</i>&nbsp;            throw new IOException(&quot;Unexpected package magic number: got &quot;</b>
<i>236</i>&nbsp;                    + magic + &quot;; expected &quot; + pkg.magic);
<i>237</i>&nbsp;        }
<b class="nc"><i>238</i>&nbsp;        archive_magic.doneDisbursing();</b>
<i>239</i>&nbsp;    }
<i>240</i>&nbsp;
<i>241</i>&nbsp;     // Fixed 6211177, converted to throw IOException
<i>242</i>&nbsp;    void checkArchiveVersion() throws IOException {
<b class="nc"><i>243</i>&nbsp;        Package.Version versionFound = null;</b>
<b class="nc"><i>244</i>&nbsp;        for (Package.Version v : new Package.Version[] {</b>
<i>245</i>&nbsp;                JAVA8_PACKAGE_VERSION,
<i>246</i>&nbsp;                JAVA7_PACKAGE_VERSION,
<i>247</i>&nbsp;                JAVA6_PACKAGE_VERSION,
<i>248</i>&nbsp;                JAVA5_PACKAGE_VERSION
<i>249</i>&nbsp;            }) {
<b class="nc"><i>250</i>&nbsp;            if (packageVersion.equals(v)) {</b>
<b class="nc"><i>251</i>&nbsp;                versionFound = v;</b>
<b class="nc"><i>252</i>&nbsp;                break;</b>
<i>253</i>&nbsp;            }
<i>254</i>&nbsp;        }
<b class="nc"><i>255</i>&nbsp;        if (versionFound == null) {</b>
<b class="nc"><i>256</i>&nbsp;            String expVer =   JAVA8_PACKAGE_VERSION.toString()</b>
<i>257</i>&nbsp;                            + &quot;OR&quot;
<b class="nc"><i>258</i>&nbsp;                            + JAVA7_PACKAGE_VERSION.toString()</b>
<i>259</i>&nbsp;                            + &quot; OR &quot;
<b class="nc"><i>260</i>&nbsp;                            + JAVA6_PACKAGE_VERSION.toString()</b>
<i>261</i>&nbsp;                            + &quot; OR &quot;
<b class="nc"><i>262</i>&nbsp;                            + JAVA5_PACKAGE_VERSION.toString();</b>
<b class="nc"><i>263</i>&nbsp;            throw new IOException(&quot;Unexpected package minor version: got &quot;</b>
<b class="nc"><i>264</i>&nbsp;                    +  packageVersion.toString() + &quot;; expected &quot; + expVer);</b>
<i>265</i>&nbsp;        }
<i>266</i>&nbsp;    }
<i>267</i>&nbsp;
<i>268</i>&nbsp;    void readArchiveHeader() throws IOException {
<i>269</i>&nbsp;        //  archive_header:
<i>270</i>&nbsp;        //        #archive_minver :UNSIGNED5[1]
<i>271</i>&nbsp;        //        #archive_majver :UNSIGNED5[1]
<i>272</i>&nbsp;        //        #archive_options :UNSIGNED5[1]
<i>273</i>&nbsp;        //        (archive_file_counts) ** (#have_file_headers)
<i>274</i>&nbsp;        //        (archive_special_counts) ** (#have_special_formats)
<i>275</i>&nbsp;        //        cp_counts
<i>276</i>&nbsp;        //        class_counts
<i>277</i>&nbsp;        //
<i>278</i>&nbsp;        //  archive_file_counts:
<i>279</i>&nbsp;        //        #archive_size_hi :UNSIGNED5[1]
<i>280</i>&nbsp;        //        #archive_size_lo :UNSIGNED5[1]
<i>281</i>&nbsp;        //        #archive_next_count :UNSIGNED5[1]
<i>282</i>&nbsp;        //        #archive_modtime :UNSIGNED5[1]
<i>283</i>&nbsp;        //        #file_count :UNSIGNED5[1]
<i>284</i>&nbsp;        //
<i>285</i>&nbsp;        //  class_counts:
<i>286</i>&nbsp;        //        #ic_count :UNSIGNED5[1]
<i>287</i>&nbsp;        //        #default_class_minver :UNSIGNED5[1]
<i>288</i>&nbsp;        //        #default_class_majver :UNSIGNED5[1]
<i>289</i>&nbsp;        //        #class_count :UNSIGNED5[1]
<i>290</i>&nbsp;        //
<i>291</i>&nbsp;        //  archive_special_counts:
<i>292</i>&nbsp;        //        #band_headers_size :UNSIGNED5[1]
<i>293</i>&nbsp;        //        #attr_definition_count :UNSIGNED5[1]
<i>294</i>&nbsp;        //
<b class="nc"><i>295</i>&nbsp;        archive_header_0.expectLength(AH_LENGTH_0);</b>
<b class="nc"><i>296</i>&nbsp;        archive_header_0.readFrom(in);</b>
<i>297</i>&nbsp;
<b class="nc"><i>298</i>&nbsp;        int minver = archive_header_0.getInt();</b>
<b class="nc"><i>299</i>&nbsp;        int majver = archive_header_0.getInt();</b>
<b class="nc"><i>300</i>&nbsp;        packageVersion = Package.Version.of(majver, minver);</b>
<b class="nc"><i>301</i>&nbsp;        checkArchiveVersion();</b>
<b class="nc"><i>302</i>&nbsp;        this.initHighestClassVersion(JAVA7_MAX_CLASS_VERSION);</b>
<i>303</i>&nbsp;
<b class="nc"><i>304</i>&nbsp;        archiveOptions = archive_header_0.getInt();</b>
<b class="nc"><i>305</i>&nbsp;        archive_header_0.doneDisbursing();</b>
<i>306</i>&nbsp;
<i>307</i>&nbsp;        // detect archive optional fields in archive header
<b class="nc"><i>308</i>&nbsp;        boolean haveSpecial = testBit(archiveOptions, AO_HAVE_SPECIAL_FORMATS);</b>
<b class="nc"><i>309</i>&nbsp;        boolean haveFiles   = testBit(archiveOptions, AO_HAVE_FILE_HEADERS);</b>
<b class="nc"><i>310</i>&nbsp;        boolean haveNumbers = testBit(archiveOptions, AO_HAVE_CP_NUMBERS);</b>
<b class="nc"><i>311</i>&nbsp;        boolean haveCPExtra = testBit(archiveOptions, AO_HAVE_CP_EXTRAS);</b>
<b class="nc"><i>312</i>&nbsp;        initAttrIndexLimit();</b>
<i>313</i>&nbsp;
<i>314</i>&nbsp;        // now we are ready to use the data:
<b class="nc"><i>315</i>&nbsp;        archive_header_S.expectLength(haveFiles? AH_LENGTH_S: 0);</b>
<b class="nc"><i>316</i>&nbsp;        archive_header_S.readFrom(in);</b>
<b class="nc"><i>317</i>&nbsp;        if (haveFiles) {</b>
<b class="nc"><i>318</i>&nbsp;            long sizeHi = archive_header_S.getInt();</b>
<b class="nc"><i>319</i>&nbsp;            long sizeLo = archive_header_S.getInt();</b>
<b class="nc"><i>320</i>&nbsp;            archiveSize1 = (sizeHi &lt;&lt; 32) + ((sizeLo &lt;&lt; 32) &gt;&gt;&gt; 32);</b>
<i>321</i>&nbsp;            // Set the limit, now, up to the file_bits.
<b class="nc"><i>322</i>&nbsp;            in.setReadLimit(archiveSize1);  // for debug only</b>
<b class="nc"><i>323</i>&nbsp;        } else {</b>
<b class="nc"><i>324</i>&nbsp;            archiveSize1 = 0;</b>
<b class="nc"><i>325</i>&nbsp;            in.setReadLimit(-1);  // remove limitation</b>
<i>326</i>&nbsp;        }
<b class="nc"><i>327</i>&nbsp;        archive_header_S.doneDisbursing();</b>
<b class="nc"><i>328</i>&nbsp;        archiveSize0 = in.getBytesServed();</b>
<i>329</i>&nbsp;
<b class="nc"><i>330</i>&nbsp;        int remainingHeaders = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;</b>
<b class="nc"><i>331</i>&nbsp;        if (haveFiles)    remainingHeaders += AH_FILE_HEADER_LEN;</b>
<b class="nc"><i>332</i>&nbsp;        if (haveSpecial)  remainingHeaders += AH_SPECIAL_FORMAT_LEN;</b>
<b class="nc"><i>333</i>&nbsp;        if (haveNumbers)  remainingHeaders += AH_CP_NUMBER_LEN;</b>
<b class="nc"><i>334</i>&nbsp;        if (haveCPExtra)  remainingHeaders += AH_CP_EXTRA_LEN;</b>
<b class="nc"><i>335</i>&nbsp;        archive_header_1.expectLength(remainingHeaders);</b>
<b class="nc"><i>336</i>&nbsp;        archive_header_1.readFrom(in);</b>
<i>337</i>&nbsp;
<b class="nc"><i>338</i>&nbsp;        if (haveFiles) {</b>
<b class="nc"><i>339</i>&nbsp;            archiveNextCount = archive_header_1.getInt();</b>
<b class="nc"><i>340</i>&nbsp;            pkg.default_modtime = archive_header_1.getInt();</b>
<b class="nc"><i>341</i>&nbsp;            numFiles = archive_header_1.getInt();</b>
<i>342</i>&nbsp;        } else {
<b class="nc"><i>343</i>&nbsp;            archiveNextCount = 0;</b>
<b class="nc"><i>344</i>&nbsp;            numFiles = 0;</b>
<i>345</i>&nbsp;        }
<i>346</i>&nbsp;
<b class="nc"><i>347</i>&nbsp;        if (haveSpecial) {</b>
<b class="nc"><i>348</i>&nbsp;            band_headers.expectLength(archive_header_1.getInt());</b>
<b class="nc"><i>349</i>&nbsp;            numAttrDefs = archive_header_1.getInt();</b>
<i>350</i>&nbsp;        } else {
<b class="nc"><i>351</i>&nbsp;            band_headers.expectLength(0);</b>
<b class="nc"><i>352</i>&nbsp;            numAttrDefs = 0;</b>
<i>353</i>&nbsp;        }
<i>354</i>&nbsp;
<b class="nc"><i>355</i>&nbsp;        readConstantPoolCounts(haveNumbers, haveCPExtra);</b>
<i>356</i>&nbsp;
<b class="nc"><i>357</i>&nbsp;        numInnerClasses = archive_header_1.getInt();</b>
<i>358</i>&nbsp;
<b class="nc"><i>359</i>&nbsp;        minver = (short) archive_header_1.getInt();</b>
<b class="nc"><i>360</i>&nbsp;        majver = (short) archive_header_1.getInt();</b>
<b class="nc"><i>361</i>&nbsp;        pkg.defaultClassVersion = Package.Version.of(majver, minver);</b>
<b class="nc"><i>362</i>&nbsp;        numClasses = archive_header_1.getInt();</b>
<i>363</i>&nbsp;
<b class="nc"><i>364</i>&nbsp;        archive_header_1.doneDisbursing();</b>
<i>365</i>&nbsp;
<i>366</i>&nbsp;        // set some derived archive bits
<b class="nc"><i>367</i>&nbsp;        if (testBit(archiveOptions, AO_DEFLATE_HINT)) {</b>
<b class="nc"><i>368</i>&nbsp;            pkg.default_options |= FO_DEFLATE_HINT;</b>
<i>369</i>&nbsp;        }
<i>370</i>&nbsp;    }
<i>371</i>&nbsp;
<i>372</i>&nbsp;    void readBandHeaders() throws IOException {
<b class="nc"><i>373</i>&nbsp;        band_headers.readFrom(in);</b>
<b class="nc"><i>374</i>&nbsp;        bandHeaderBytePos = 1;  // Leave room to pushback the initial XB byte.</b>
<b class="nc"><i>375</i>&nbsp;        bandHeaderBytes = new byte[bandHeaderBytePos + band_headers.length()];</b>
<b class="nc"><i>376</i>&nbsp;        for (int i = bandHeaderBytePos; i &lt; bandHeaderBytes.length; i++) {</b>
<b class="nc"><i>377</i>&nbsp;            bandHeaderBytes[i] = (byte) band_headers.getByte();</b>
<i>378</i>&nbsp;        }
<b class="nc"><i>379</i>&nbsp;        band_headers.doneDisbursing();</b>
<i>380</i>&nbsp;    }
<i>381</i>&nbsp;
<i>382</i>&nbsp;    void readConstantPoolCounts(boolean haveNumbers, boolean haveCPExtra) throws IOException {
<i>383</i>&nbsp;        // size the constant pools:
<b class="nc"><i>384</i>&nbsp;        for (int k = 0; k &lt; ConstantPool.TAGS_IN_ORDER.length; k++) {</b>
<i>385</i>&nbsp;            //  cp_counts:
<i>386</i>&nbsp;            //        #cp_Utf8_count :UNSIGNED5[1]
<i>387</i>&nbsp;            //        (cp_number_counts) ** (#have_cp_numbers)
<i>388</i>&nbsp;            //        #cp_String_count :UNSIGNED5[1]
<i>389</i>&nbsp;            //        #cp_Class_count :UNSIGNED5[1]
<i>390</i>&nbsp;            //        #cp_Signature_count :UNSIGNED5[1]
<i>391</i>&nbsp;            //        #cp_Descr_count :UNSIGNED5[1]
<i>392</i>&nbsp;            //        #cp_Field_count :UNSIGNED5[1]
<i>393</i>&nbsp;            //        #cp_Method_count :UNSIGNED5[1]
<i>394</i>&nbsp;            //        #cp_Imethod_count :UNSIGNED5[1]
<i>395</i>&nbsp;            //        (cp_attr_counts) ** (#have_cp_attr_counts)
<i>396</i>&nbsp;            //
<i>397</i>&nbsp;            //  cp_number_counts:
<i>398</i>&nbsp;            //        #cp_Int_count :UNSIGNED5[1]
<i>399</i>&nbsp;            //        #cp_Float_count :UNSIGNED5[1]
<i>400</i>&nbsp;            //        #cp_Long_count :UNSIGNED5[1]
<i>401</i>&nbsp;            //        #cp_Double_count :UNSIGNED5[1]
<i>402</i>&nbsp;            //
<i>403</i>&nbsp;            //  cp_extra_counts:
<i>404</i>&nbsp;            //        #cp_MethodHandle_count :UNSIGNED5[1]
<i>405</i>&nbsp;            //        #cp_MethodType_count :UNSIGNED5[1]
<i>406</i>&nbsp;            //        #cp_InvokeDynamic_count :UNSIGNED5[1]
<i>407</i>&nbsp;            //        #cp_BootstrapMethod_count :UNSIGNED5[1]
<i>408</i>&nbsp;            //
<b class="nc"><i>409</i>&nbsp;            byte tag = ConstantPool.TAGS_IN_ORDER[k];</b>
<b class="nc"><i>410</i>&nbsp;            if (!haveNumbers) {</b>
<i>411</i>&nbsp;                // These four counts are optional.
<b class="nc"><i>412</i>&nbsp;                switch (tag) {</b>
<i>413</i>&nbsp;                case CONSTANT_Integer:
<i>414</i>&nbsp;                case CONSTANT_Float:
<i>415</i>&nbsp;                case CONSTANT_Long:
<i>416</i>&nbsp;                case CONSTANT_Double:
<b class="nc"><i>417</i>&nbsp;                    continue;</b>
<i>418</i>&nbsp;                }
<i>419</i>&nbsp;            }
<b class="nc"><i>420</i>&nbsp;            if (!haveCPExtra) {</b>
<i>421</i>&nbsp;                // These four counts are optional.
<b class="nc"><i>422</i>&nbsp;                switch (tag) {</b>
<i>423</i>&nbsp;                case CONSTANT_MethodHandle:
<i>424</i>&nbsp;                case CONSTANT_MethodType:
<i>425</i>&nbsp;                case CONSTANT_InvokeDynamic:
<i>426</i>&nbsp;                case CONSTANT_BootstrapMethod:
<b class="nc"><i>427</i>&nbsp;                    continue;</b>
<i>428</i>&nbsp;                }
<i>429</i>&nbsp;            }
<b class="nc"><i>430</i>&nbsp;            tagCount[tag] = archive_header_1.getInt();</b>
<i>431</i>&nbsp;        }
<i>432</i>&nbsp;    }
<i>433</i>&nbsp;
<i>434</i>&nbsp;    protected Index getCPIndex(byte tag) {
<b class="nc"><i>435</i>&nbsp;        return pkg.cp.getIndexByTag(tag);</b>
<i>436</i>&nbsp;    }
<i>437</i>&nbsp;    Index initCPIndex(byte tag, Entry[] cpMap) {
<b class="nc"><i>438</i>&nbsp;        if (verbose &gt; 3) {</b>
<b class="nc"><i>439</i>&nbsp;            for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>440</i>&nbsp;                Utils.log.fine(&quot;cp.add &quot;+cpMap[i]);</b>
<i>441</i>&nbsp;            }
<i>442</i>&nbsp;        }
<b class="nc"><i>443</i>&nbsp;        Index index = ConstantPool.makeIndex(ConstantPool.tagName(tag), cpMap);</b>
<b class="nc"><i>444</i>&nbsp;        if (verbose &gt; 1)  Utils.log.fine(&quot;Read &quot;+index);</b>
<b class="nc"><i>445</i>&nbsp;        pkg.cp.initIndexByTag(tag, index);</b>
<b class="nc"><i>446</i>&nbsp;        return index;</b>
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;    void checkLegacy(String bandname) {
<b class="nc"><i>450</i>&nbsp;        if (packageVersion.lessThan(JAVA7_PACKAGE_VERSION)) {</b>
<b class="nc"><i>451</i>&nbsp;            throw new RuntimeException(&quot;unexpected band &quot; + bandname);</b>
<i>452</i>&nbsp;        }
<i>453</i>&nbsp;    }
<i>454</i>&nbsp;    void readConstantPool() throws IOException {
<i>455</i>&nbsp;        //  cp_bands:
<i>456</i>&nbsp;        //        cp_Utf8
<i>457</i>&nbsp;        //        *cp_Int :UDELTA5
<i>458</i>&nbsp;        //        *cp_Float :UDELTA5
<i>459</i>&nbsp;        //        cp_Long
<i>460</i>&nbsp;        //        cp_Double
<i>461</i>&nbsp;        //        *cp_String :UDELTA5  (cp_Utf8)
<i>462</i>&nbsp;        //        *cp_Class :UDELTA5  (cp_Utf8)
<i>463</i>&nbsp;        //        cp_Signature
<i>464</i>&nbsp;        //        cp_Descr
<i>465</i>&nbsp;        //        cp_Field
<i>466</i>&nbsp;        //        cp_Method
<i>467</i>&nbsp;        //        cp_Imethod
<i>468</i>&nbsp;
<b class="nc"><i>469</i>&nbsp;        if (verbose &gt; 0)  Utils.log.info(&quot;Reading CP&quot;);</b>
<i>470</i>&nbsp;
<b class="nc"><i>471</i>&nbsp;        for (int k = 0; k &lt; ConstantPool.TAGS_IN_ORDER.length; k++) {</b>
<b class="nc"><i>472</i>&nbsp;            byte tag = ConstantPool.TAGS_IN_ORDER[k];</b>
<b class="nc"><i>473</i>&nbsp;            int  len = tagCount[tag];</b>
<i>474</i>&nbsp;
<b class="nc"><i>475</i>&nbsp;            Entry[] cpMap = new Entry[len];</b>
<b class="nc"><i>476</i>&nbsp;            if (verbose &gt; 0)</b>
<b class="nc"><i>477</i>&nbsp;                Utils.log.info(&quot;Reading &quot;+cpMap.length+&quot; &quot;+ConstantPool.tagName(tag)+&quot; entries...&quot;);</b>
<i>478</i>&nbsp;
<b class="nc"><i>479</i>&nbsp;            switch (tag) {</b>
<i>480</i>&nbsp;            case CONSTANT_Utf8:
<b class="nc"><i>481</i>&nbsp;                readUtf8Bands(cpMap);</b>
<b class="nc"><i>482</i>&nbsp;                break;</b>
<i>483</i>&nbsp;            case CONSTANT_Integer:
<b class="nc"><i>484</i>&nbsp;                cp_Int.expectLength(cpMap.length);</b>
<b class="nc"><i>485</i>&nbsp;                cp_Int.readFrom(in);</b>
<b class="nc"><i>486</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>487</i>&nbsp;                    int x = cp_Int.getInt();  // coding handles signs OK</b>
<b class="nc"><i>488</i>&nbsp;                    cpMap[i] = ConstantPool.getLiteralEntry(x);</b>
<i>489</i>&nbsp;                }
<b class="nc"><i>490</i>&nbsp;                cp_Int.doneDisbursing();</b>
<b class="nc"><i>491</i>&nbsp;                break;</b>
<i>492</i>&nbsp;            case CONSTANT_Float:
<b class="nc"><i>493</i>&nbsp;                cp_Float.expectLength(cpMap.length);</b>
<b class="nc"><i>494</i>&nbsp;                cp_Float.readFrom(in);</b>
<b class="nc"><i>495</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>496</i>&nbsp;                    int x = cp_Float.getInt();</b>
<b class="nc"><i>497</i>&nbsp;                    float fx = Float.intBitsToFloat(x);</b>
<b class="nc"><i>498</i>&nbsp;                    cpMap[i] = ConstantPool.getLiteralEntry(fx);</b>
<i>499</i>&nbsp;                }
<b class="nc"><i>500</i>&nbsp;                cp_Float.doneDisbursing();</b>
<b class="nc"><i>501</i>&nbsp;                break;</b>
<i>502</i>&nbsp;            case CONSTANT_Long:
<i>503</i>&nbsp;                //  cp_Long:
<i>504</i>&nbsp;                //        *cp_Long_hi :UDELTA5
<i>505</i>&nbsp;                //        *cp_Long_lo :DELTA5
<b class="nc"><i>506</i>&nbsp;                cp_Long_hi.expectLength(cpMap.length);</b>
<b class="nc"><i>507</i>&nbsp;                cp_Long_hi.readFrom(in);</b>
<b class="nc"><i>508</i>&nbsp;                cp_Long_lo.expectLength(cpMap.length);</b>
<b class="nc"><i>509</i>&nbsp;                cp_Long_lo.readFrom(in);</b>
<b class="nc"><i>510</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>511</i>&nbsp;                    long hi = cp_Long_hi.getInt();</b>
<b class="nc"><i>512</i>&nbsp;                    long lo = cp_Long_lo.getInt();</b>
<b class="nc"><i>513</i>&nbsp;                    long x = (hi &lt;&lt; 32) + ((lo &lt;&lt; 32) &gt;&gt;&gt; 32);</b>
<b class="nc"><i>514</i>&nbsp;                    cpMap[i] = ConstantPool.getLiteralEntry(x);</b>
<i>515</i>&nbsp;                }
<b class="nc"><i>516</i>&nbsp;                cp_Long_hi.doneDisbursing();</b>
<b class="nc"><i>517</i>&nbsp;                cp_Long_lo.doneDisbursing();</b>
<b class="nc"><i>518</i>&nbsp;                break;</b>
<i>519</i>&nbsp;            case CONSTANT_Double:
<i>520</i>&nbsp;                //  cp_Double:
<i>521</i>&nbsp;                //        *cp_Double_hi :UDELTA5
<i>522</i>&nbsp;                //        *cp_Double_lo :DELTA5
<b class="nc"><i>523</i>&nbsp;                cp_Double_hi.expectLength(cpMap.length);</b>
<b class="nc"><i>524</i>&nbsp;                cp_Double_hi.readFrom(in);</b>
<b class="nc"><i>525</i>&nbsp;                cp_Double_lo.expectLength(cpMap.length);</b>
<b class="nc"><i>526</i>&nbsp;                cp_Double_lo.readFrom(in);</b>
<b class="nc"><i>527</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>528</i>&nbsp;                    long hi = cp_Double_hi.getInt();</b>
<b class="nc"><i>529</i>&nbsp;                    long lo = cp_Double_lo.getInt();</b>
<b class="nc"><i>530</i>&nbsp;                    long x = (hi &lt;&lt; 32) + ((lo &lt;&lt; 32) &gt;&gt;&gt; 32);</b>
<b class="nc"><i>531</i>&nbsp;                    double dx = Double.longBitsToDouble(x);</b>
<b class="nc"><i>532</i>&nbsp;                    cpMap[i] = ConstantPool.getLiteralEntry(dx);</b>
<i>533</i>&nbsp;                }
<b class="nc"><i>534</i>&nbsp;                cp_Double_hi.doneDisbursing();</b>
<b class="nc"><i>535</i>&nbsp;                cp_Double_lo.doneDisbursing();</b>
<b class="nc"><i>536</i>&nbsp;                break;</b>
<i>537</i>&nbsp;            case CONSTANT_String:
<b class="nc"><i>538</i>&nbsp;                cp_String.expectLength(cpMap.length);</b>
<b class="nc"><i>539</i>&nbsp;                cp_String.readFrom(in);</b>
<b class="nc"><i>540</i>&nbsp;                cp_String.setIndex(getCPIndex(CONSTANT_Utf8));</b>
<b class="nc"><i>541</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>542</i>&nbsp;                    cpMap[i] = ConstantPool.getLiteralEntry(cp_String.getRef().stringValue());</b>
<i>543</i>&nbsp;                }
<b class="nc"><i>544</i>&nbsp;                cp_String.doneDisbursing();</b>
<b class="nc"><i>545</i>&nbsp;                break;</b>
<i>546</i>&nbsp;            case CONSTANT_Class:
<b class="nc"><i>547</i>&nbsp;                cp_Class.expectLength(cpMap.length);</b>
<b class="nc"><i>548</i>&nbsp;                cp_Class.readFrom(in);</b>
<b class="nc"><i>549</i>&nbsp;                cp_Class.setIndex(getCPIndex(CONSTANT_Utf8));</b>
<b class="nc"><i>550</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>551</i>&nbsp;                    cpMap[i] = ConstantPool.getClassEntry(cp_Class.getRef().stringValue());</b>
<i>552</i>&nbsp;                }
<b class="nc"><i>553</i>&nbsp;                cp_Class.doneDisbursing();</b>
<b class="nc"><i>554</i>&nbsp;                break;</b>
<i>555</i>&nbsp;            case CONSTANT_Signature:
<b class="nc"><i>556</i>&nbsp;                readSignatureBands(cpMap);</b>
<b class="nc"><i>557</i>&nbsp;                break;</b>
<i>558</i>&nbsp;            case CONSTANT_NameandType:
<i>559</i>&nbsp;                //  cp_Descr:
<i>560</i>&nbsp;                //        *cp_Descr_type :DELTA5  (cp_Signature)
<i>561</i>&nbsp;                //        *cp_Descr_name :UDELTA5  (cp_Utf8)
<b class="nc"><i>562</i>&nbsp;                cp_Descr_name.expectLength(cpMap.length);</b>
<b class="nc"><i>563</i>&nbsp;                cp_Descr_name.readFrom(in);</b>
<b class="nc"><i>564</i>&nbsp;                cp_Descr_name.setIndex(getCPIndex(CONSTANT_Utf8));</b>
<b class="nc"><i>565</i>&nbsp;                cp_Descr_type.expectLength(cpMap.length);</b>
<b class="nc"><i>566</i>&nbsp;                cp_Descr_type.readFrom(in);</b>
<b class="nc"><i>567</i>&nbsp;                cp_Descr_type.setIndex(getCPIndex(CONSTANT_Signature));</b>
<b class="nc"><i>568</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>569</i>&nbsp;                    Entry ref  = cp_Descr_name.getRef();</b>
<b class="nc"><i>570</i>&nbsp;                    Entry ref2 = cp_Descr_type.getRef();</b>
<b class="nc"><i>571</i>&nbsp;                    cpMap[i] = ConstantPool.getDescriptorEntry((Utf8Entry)ref,</b>
<i>572</i>&nbsp;                                                        (SignatureEntry)ref2);
<i>573</i>&nbsp;                }
<b class="nc"><i>574</i>&nbsp;                cp_Descr_name.doneDisbursing();</b>
<b class="nc"><i>575</i>&nbsp;                cp_Descr_type.doneDisbursing();</b>
<b class="nc"><i>576</i>&nbsp;                break;</b>
<i>577</i>&nbsp;            case CONSTANT_Fieldref:
<b class="nc"><i>578</i>&nbsp;                readMemberRefs(tag, cpMap, cp_Field_class, cp_Field_desc);</b>
<b class="nc"><i>579</i>&nbsp;                break;</b>
<i>580</i>&nbsp;            case CONSTANT_Methodref:
<b class="nc"><i>581</i>&nbsp;                readMemberRefs(tag, cpMap, cp_Method_class, cp_Method_desc);</b>
<b class="nc"><i>582</i>&nbsp;                break;</b>
<i>583</i>&nbsp;            case CONSTANT_InterfaceMethodref:
<b class="nc"><i>584</i>&nbsp;                readMemberRefs(tag, cpMap, cp_Imethod_class, cp_Imethod_desc);</b>
<b class="nc"><i>585</i>&nbsp;                break;</b>
<i>586</i>&nbsp;            case CONSTANT_MethodHandle:
<b class="nc"><i>587</i>&nbsp;                if (cpMap.length &gt; 0) {</b>
<b class="nc"><i>588</i>&nbsp;                    checkLegacy(cp_MethodHandle_refkind.name());</b>
<i>589</i>&nbsp;                }
<b class="nc"><i>590</i>&nbsp;                cp_MethodHandle_refkind.expectLength(cpMap.length);</b>
<b class="nc"><i>591</i>&nbsp;                cp_MethodHandle_refkind.readFrom(in);</b>
<b class="nc"><i>592</i>&nbsp;                cp_MethodHandle_member.expectLength(cpMap.length);</b>
<b class="nc"><i>593</i>&nbsp;                cp_MethodHandle_member.readFrom(in);</b>
<b class="nc"><i>594</i>&nbsp;                cp_MethodHandle_member.setIndex(getCPIndex(CONSTANT_AnyMember));</b>
<b class="nc"><i>595</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>596</i>&nbsp;                    byte        refKind = (byte)        cp_MethodHandle_refkind.getInt();</b>
<b class="nc"><i>597</i>&nbsp;                    MemberEntry memRef  = (MemberEntry) cp_MethodHandle_member.getRef();</b>
<b class="nc"><i>598</i>&nbsp;                    cpMap[i] = ConstantPool.getMethodHandleEntry(refKind, memRef);</b>
<i>599</i>&nbsp;                }
<b class="nc"><i>600</i>&nbsp;                cp_MethodHandle_refkind.doneDisbursing();</b>
<b class="nc"><i>601</i>&nbsp;                cp_MethodHandle_member.doneDisbursing();</b>
<b class="nc"><i>602</i>&nbsp;                break;</b>
<i>603</i>&nbsp;            case CONSTANT_MethodType:
<b class="nc"><i>604</i>&nbsp;                if (cpMap.length &gt; 0) {</b>
<b class="nc"><i>605</i>&nbsp;                    checkLegacy(cp_MethodType.name());</b>
<i>606</i>&nbsp;                }
<b class="nc"><i>607</i>&nbsp;                cp_MethodType.expectLength(cpMap.length);</b>
<b class="nc"><i>608</i>&nbsp;                cp_MethodType.readFrom(in);</b>
<b class="nc"><i>609</i>&nbsp;                cp_MethodType.setIndex(getCPIndex(CONSTANT_Signature));</b>
<b class="nc"><i>610</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>611</i>&nbsp;                    SignatureEntry typeRef  = (SignatureEntry) cp_MethodType.getRef();</b>
<b class="nc"><i>612</i>&nbsp;                    cpMap[i] = ConstantPool.getMethodTypeEntry(typeRef);</b>
<i>613</i>&nbsp;                }
<b class="nc"><i>614</i>&nbsp;                cp_MethodType.doneDisbursing();</b>
<b class="nc"><i>615</i>&nbsp;                break;</b>
<i>616</i>&nbsp;            case CONSTANT_InvokeDynamic:
<b class="nc"><i>617</i>&nbsp;                if (cpMap.length &gt; 0) {</b>
<b class="nc"><i>618</i>&nbsp;                    checkLegacy(cp_InvokeDynamic_spec.name());</b>
<i>619</i>&nbsp;                }
<b class="nc"><i>620</i>&nbsp;                cp_InvokeDynamic_spec.expectLength(cpMap.length);</b>
<b class="nc"><i>621</i>&nbsp;                cp_InvokeDynamic_spec.readFrom(in);</b>
<b class="nc"><i>622</i>&nbsp;                cp_InvokeDynamic_spec.setIndex(getCPIndex(CONSTANT_BootstrapMethod));</b>
<b class="nc"><i>623</i>&nbsp;                cp_InvokeDynamic_desc.expectLength(cpMap.length);</b>
<b class="nc"><i>624</i>&nbsp;                cp_InvokeDynamic_desc.readFrom(in);</b>
<b class="nc"><i>625</i>&nbsp;                cp_InvokeDynamic_desc.setIndex(getCPIndex(CONSTANT_NameandType));</b>
<b class="nc"><i>626</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>627</i>&nbsp;                    BootstrapMethodEntry bss   = (BootstrapMethodEntry) cp_InvokeDynamic_spec.getRef();</b>
<b class="nc"><i>628</i>&nbsp;                    DescriptorEntry      descr = (DescriptorEntry)      cp_InvokeDynamic_desc.getRef();</b>
<b class="nc"><i>629</i>&nbsp;                    cpMap[i] = ConstantPool.getInvokeDynamicEntry(bss, descr);</b>
<i>630</i>&nbsp;                }
<b class="nc"><i>631</i>&nbsp;                cp_InvokeDynamic_spec.doneDisbursing();</b>
<b class="nc"><i>632</i>&nbsp;                cp_InvokeDynamic_desc.doneDisbursing();</b>
<b class="nc"><i>633</i>&nbsp;                break;</b>
<i>634</i>&nbsp;            case CONSTANT_BootstrapMethod:
<b class="nc"><i>635</i>&nbsp;                if (cpMap.length &gt; 0) {</b>
<b class="nc"><i>636</i>&nbsp;                    checkLegacy(cp_BootstrapMethod_ref.name());</b>
<i>637</i>&nbsp;                }
<b class="nc"><i>638</i>&nbsp;                cp_BootstrapMethod_ref.expectLength(cpMap.length);</b>
<b class="nc"><i>639</i>&nbsp;                cp_BootstrapMethod_ref.readFrom(in);</b>
<b class="nc"><i>640</i>&nbsp;                cp_BootstrapMethod_ref.setIndex(getCPIndex(CONSTANT_MethodHandle));</b>
<b class="nc"><i>641</i>&nbsp;                cp_BootstrapMethod_arg_count.expectLength(cpMap.length);</b>
<b class="nc"><i>642</i>&nbsp;                cp_BootstrapMethod_arg_count.readFrom(in);</b>
<b class="nc"><i>643</i>&nbsp;                int totalArgCount = cp_BootstrapMethod_arg_count.getIntTotal();</b>
<b class="nc"><i>644</i>&nbsp;                cp_BootstrapMethod_arg.expectLength(totalArgCount);</b>
<b class="nc"><i>645</i>&nbsp;                cp_BootstrapMethod_arg.readFrom(in);</b>
<b class="nc"><i>646</i>&nbsp;                cp_BootstrapMethod_arg.setIndex(getCPIndex(CONSTANT_LoadableValue));</b>
<b class="nc"><i>647</i>&nbsp;                for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>648</i>&nbsp;                    MethodHandleEntry bsm = (MethodHandleEntry) cp_BootstrapMethod_ref.getRef();</b>
<b class="nc"><i>649</i>&nbsp;                    int argc = cp_BootstrapMethod_arg_count.getInt();</b>
<b class="nc"><i>650</i>&nbsp;                    Entry[] argRefs = new Entry[argc];</b>
<b class="nc"><i>651</i>&nbsp;                    for (int j = 0; j &lt; argc; j++) {</b>
<b class="nc"><i>652</i>&nbsp;                        argRefs[j] = cp_BootstrapMethod_arg.getRef();</b>
<i>653</i>&nbsp;                    }
<b class="nc"><i>654</i>&nbsp;                    cpMap[i] = ConstantPool.getBootstrapMethodEntry(bsm, argRefs);</b>
<i>655</i>&nbsp;                }
<b class="nc"><i>656</i>&nbsp;                cp_BootstrapMethod_ref.doneDisbursing();</b>
<b class="nc"><i>657</i>&nbsp;                cp_BootstrapMethod_arg_count.doneDisbursing();</b>
<b class="nc"><i>658</i>&nbsp;                cp_BootstrapMethod_arg.doneDisbursing();</b>
<b class="nc"><i>659</i>&nbsp;                break;</b>
<i>660</i>&nbsp;            default:
<b class="nc"><i>661</i>&nbsp;                throw new AssertionError(&quot;unexpected CP tag in package&quot;);</b>
<i>662</i>&nbsp;            }
<i>663</i>&nbsp;
<b class="nc"><i>664</i>&nbsp;            Index index = initCPIndex(tag, cpMap);</b>
<i>665</i>&nbsp;
<b class="nc"><i>666</i>&nbsp;            if (optDumpBands) {</b>
<b class="nc"><i>667</i>&nbsp;                try (PrintStream ps = new PrintStream(getDumpStream(index, &quot;.idx&quot;))) {</b>
<b class="nc"><i>668</i>&nbsp;                    printArrayTo(ps, index.cpMap, 0, index.cpMap.length);</b>
<b class="nc"><i>669</i>&nbsp;                }</b>
<i>670</i>&nbsp;            }
<i>671</i>&nbsp;        }
<i>672</i>&nbsp;
<b class="nc"><i>673</i>&nbsp;        cp_bands.doneDisbursing();</b>
<i>674</i>&nbsp;
<b class="nc"><i>675</i>&nbsp;        if (optDumpBands || verbose &gt; 1) {</b>
<b class="nc"><i>676</i>&nbsp;            for (byte tag = CONSTANT_GroupFirst; tag &lt; CONSTANT_GroupLimit; tag++) {</b>
<b class="nc"><i>677</i>&nbsp;                Index index = pkg.cp.getIndexByTag(tag);</b>
<b class="nc"><i>678</i>&nbsp;                if (index == null || index.isEmpty())  continue;</b>
<b class="nc"><i>679</i>&nbsp;                Entry[] cpMap = index.cpMap;</b>
<b class="nc"><i>680</i>&nbsp;                if (verbose &gt; 1)</b>
<b class="nc"><i>681</i>&nbsp;                    Utils.log.info(&quot;Index group &quot;+ConstantPool.tagName(tag)+&quot; contains &quot;+cpMap.length+&quot; entries.&quot;);</b>
<b class="nc"><i>682</i>&nbsp;                if (optDumpBands) {</b>
<b class="nc"><i>683</i>&nbsp;                    try (PrintStream ps = new PrintStream(getDumpStream(index.debugName, tag, &quot;.gidx&quot;, index))) {</b>
<b class="nc"><i>684</i>&nbsp;                        printArrayTo(ps, cpMap, 0, cpMap.length, true);</b>
<b class="nc"><i>685</i>&nbsp;                    }</b>
<i>686</i>&nbsp;                }
<i>687</i>&nbsp;            }
<i>688</i>&nbsp;        }
<i>689</i>&nbsp;
<b class="nc"><i>690</i>&nbsp;        setBandIndexes();</b>
<i>691</i>&nbsp;    }
<i>692</i>&nbsp;
<i>693</i>&nbsp;    void readUtf8Bands(Entry[] cpMap) throws IOException {
<i>694</i>&nbsp;        //  cp_Utf8:
<i>695</i>&nbsp;        //        *cp_Utf8_prefix :DELTA5
<i>696</i>&nbsp;        //        *cp_Utf8_suffix :UNSIGNED5
<i>697</i>&nbsp;        //        *cp_Utf8_chars :CHAR3
<i>698</i>&nbsp;        //        *cp_Utf8_big_suffix :DELTA5
<i>699</i>&nbsp;        //        (*cp_Utf8_big_chars :DELTA5)
<i>700</i>&nbsp;        //          ** length(cp_Utf8_big_suffix)
<b class="nc"><i>701</i>&nbsp;        int len = cpMap.length;</b>
<b class="nc"><i>702</i>&nbsp;        if (len == 0)</b>
<i>703</i>&nbsp;            return;  // nothing to read
<i>704</i>&nbsp;
<i>705</i>&nbsp;        // Bands have implicit leading zeroes, for the empty string:
<i>706</i>&nbsp;        final int SUFFIX_SKIP_1 = 1;
<i>707</i>&nbsp;        final int PREFIX_SKIP_2 = 2;
<i>708</i>&nbsp;
<i>709</i>&nbsp;        // First band:  Read lengths of shared prefixes.
<b class="nc"><i>710</i>&nbsp;        cp_Utf8_prefix.expectLength(Math.max(0, len - PREFIX_SKIP_2));</b>
<b class="nc"><i>711</i>&nbsp;        cp_Utf8_prefix.readFrom(in);</b>
<i>712</i>&nbsp;
<i>713</i>&nbsp;        // Second band:  Read lengths of unshared suffixes:
<b class="nc"><i>714</i>&nbsp;        cp_Utf8_suffix.expectLength(Math.max(0, len - SUFFIX_SKIP_1));</b>
<b class="nc"><i>715</i>&nbsp;        cp_Utf8_suffix.readFrom(in);</b>
<i>716</i>&nbsp;
<b class="nc"><i>717</i>&nbsp;        char[][] suffixChars = new char[len][];</b>
<b class="nc"><i>718</i>&nbsp;        int bigSuffixCount = 0;</b>
<i>719</i>&nbsp;
<i>720</i>&nbsp;        // Third band:  Read the char values in the unshared suffixes:
<b class="nc"><i>721</i>&nbsp;        cp_Utf8_chars.expectLength(cp_Utf8_suffix.getIntTotal());</b>
<b class="nc"><i>722</i>&nbsp;        cp_Utf8_chars.readFrom(in);</b>
<b class="nc"><i>723</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="nc"><i>724</i>&nbsp;            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</b>
<b class="nc"><i>725</i>&nbsp;            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {</b>
<i>726</i>&nbsp;                // chars are packed in cp_Utf8_big_chars
<b class="nc"><i>727</i>&nbsp;                bigSuffixCount += 1;</b>
<b class="nc"><i>728</i>&nbsp;                continue;</b>
<i>729</i>&nbsp;            }
<b class="nc"><i>730</i>&nbsp;            suffixChars[i] = new char[suffix];</b>
<b class="nc"><i>731</i>&nbsp;            for (int j = 0; j &lt; suffix; j++) {</b>
<b class="nc"><i>732</i>&nbsp;                int ch = cp_Utf8_chars.getInt();</b>
<b class="nc"><i>733</i>&nbsp;                assert(ch == (char)ch);</b>
<b class="nc"><i>734</i>&nbsp;                suffixChars[i][j] = (char)ch;</b>
<i>735</i>&nbsp;            }
<i>736</i>&nbsp;        }
<b class="nc"><i>737</i>&nbsp;        cp_Utf8_chars.doneDisbursing();</b>
<i>738</i>&nbsp;
<i>739</i>&nbsp;        // Fourth band:  Go back and size the specially packed strings.
<b class="nc"><i>740</i>&nbsp;        int maxChars = 0;</b>
<b class="nc"><i>741</i>&nbsp;        cp_Utf8_big_suffix.expectLength(bigSuffixCount);</b>
<b class="nc"><i>742</i>&nbsp;        cp_Utf8_big_suffix.readFrom(in);</b>
<b class="nc"><i>743</i>&nbsp;        cp_Utf8_suffix.resetForSecondPass();</b>
<b class="nc"><i>744</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="nc"><i>745</i>&nbsp;            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</b>
<b class="nc"><i>746</i>&nbsp;            int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();</b>
<b class="nc"><i>747</i>&nbsp;            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {</b>
<b class="nc"><i>748</i>&nbsp;                assert(suffixChars[i] == null);</b>
<b class="nc"><i>749</i>&nbsp;                suffix = cp_Utf8_big_suffix.getInt();</b>
<i>750</i>&nbsp;            } else {
<b class="nc"><i>751</i>&nbsp;                assert(suffixChars[i] != null);</b>
<i>752</i>&nbsp;            }
<b class="nc"><i>753</i>&nbsp;            if (maxChars &lt; prefix + suffix)</b>
<b class="nc"><i>754</i>&nbsp;                maxChars = prefix + suffix;</b>
<i>755</i>&nbsp;        }
<b class="nc"><i>756</i>&nbsp;        char[] buf = new char[maxChars];</b>
<i>757</i>&nbsp;
<i>758</i>&nbsp;        // Fifth band(s):  Get the specially packed characters.
<b class="nc"><i>759</i>&nbsp;        cp_Utf8_suffix.resetForSecondPass();</b>
<b class="nc"><i>760</i>&nbsp;        cp_Utf8_big_suffix.resetForSecondPass();</b>
<b class="nc"><i>761</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="nc"><i>762</i>&nbsp;            if (i &lt; SUFFIX_SKIP_1)  continue;</b>
<b class="nc"><i>763</i>&nbsp;            int suffix = cp_Utf8_suffix.getInt();</b>
<b class="nc"><i>764</i>&nbsp;            if (suffix != 0)  continue;  // already input</b>
<b class="nc"><i>765</i>&nbsp;            suffix = cp_Utf8_big_suffix.getInt();</b>
<b class="nc"><i>766</i>&nbsp;            suffixChars[i] = new char[suffix];</b>
<b class="nc"><i>767</i>&nbsp;            if (suffix == 0) {</b>
<i>768</i>&nbsp;                // Do not bother to add an empty &quot;(Utf8_big_0)&quot; band.
<b class="nc"><i>769</i>&nbsp;                continue;</b>
<i>770</i>&nbsp;            }
<b class="nc"><i>771</i>&nbsp;            IntBand packed = cp_Utf8_big_chars.newIntBand(&quot;(Utf8_big_&quot;+i+&quot;)&quot;);</b>
<b class="nc"><i>772</i>&nbsp;            packed.expectLength(suffix);</b>
<b class="nc"><i>773</i>&nbsp;            packed.readFrom(in);</b>
<b class="nc"><i>774</i>&nbsp;            for (int j = 0; j &lt; suffix; j++) {</b>
<b class="nc"><i>775</i>&nbsp;                int ch = packed.getInt();</b>
<b class="nc"><i>776</i>&nbsp;                assert(ch == (char)ch);</b>
<b class="nc"><i>777</i>&nbsp;                suffixChars[i][j] = (char)ch;</b>
<i>778</i>&nbsp;            }
<b class="nc"><i>779</i>&nbsp;            packed.doneDisbursing();</b>
<i>780</i>&nbsp;        }
<b class="nc"><i>781</i>&nbsp;        cp_Utf8_big_chars.doneDisbursing();</b>
<i>782</i>&nbsp;
<i>783</i>&nbsp;        // Finally, sew together all the prefixes and suffixes.
<b class="nc"><i>784</i>&nbsp;        cp_Utf8_prefix.resetForSecondPass();</b>
<b class="nc"><i>785</i>&nbsp;        cp_Utf8_suffix.resetForSecondPass();</b>
<b class="nc"><i>786</i>&nbsp;        cp_Utf8_big_suffix.resetForSecondPass();</b>
<b class="nc"><i>787</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<b class="nc"><i>788</i>&nbsp;            int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();</b>
<b class="nc"><i>789</i>&nbsp;            int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();</b>
<b class="nc"><i>790</i>&nbsp;            if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1)</b>
<b class="nc"><i>791</i>&nbsp;                suffix = cp_Utf8_big_suffix.getInt();</b>
<i>792</i>&nbsp;
<i>793</i>&nbsp;            // by induction, the buffer is already filled with the prefix
<b class="nc"><i>794</i>&nbsp;            System.arraycopy(suffixChars[i], 0, buf, prefix, suffix);</b>
<i>795</i>&nbsp;
<b class="nc"><i>796</i>&nbsp;            cpMap[i] = ConstantPool.getUtf8Entry(new String(buf, 0, prefix+suffix));</b>
<i>797</i>&nbsp;        }
<i>798</i>&nbsp;
<b class="nc"><i>799</i>&nbsp;        cp_Utf8_prefix.doneDisbursing();</b>
<b class="nc"><i>800</i>&nbsp;        cp_Utf8_suffix.doneDisbursing();</b>
<b class="nc"><i>801</i>&nbsp;        cp_Utf8_big_suffix.doneDisbursing();</b>
<i>802</i>&nbsp;    }
<i>803</i>&nbsp;
<i>804</i>&nbsp;    Map&lt;Utf8Entry, SignatureEntry&gt; utf8Signatures;
<i>805</i>&nbsp;
<i>806</i>&nbsp;    void readSignatureBands(Entry[] cpMap) throws IOException {
<i>807</i>&nbsp;        //  cp_Signature:
<i>808</i>&nbsp;        //        *cp_Signature_form :DELTA5  (cp_Utf8)
<i>809</i>&nbsp;        //        *cp_Signature_classes :UDELTA5  (cp_Class)
<b class="nc"><i>810</i>&nbsp;        cp_Signature_form.expectLength(cpMap.length);</b>
<b class="nc"><i>811</i>&nbsp;        cp_Signature_form.readFrom(in);</b>
<b class="nc"><i>812</i>&nbsp;        cp_Signature_form.setIndex(getCPIndex(CONSTANT_Utf8));</b>
<b class="nc"><i>813</i>&nbsp;        int[] numSigClasses = new int[cpMap.length];</b>
<b class="nc"><i>814</i>&nbsp;        for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>815</i>&nbsp;            Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();</b>
<b class="nc"><i>816</i>&nbsp;            numSigClasses[i] = ConstantPool.countClassParts(formRef);</b>
<i>817</i>&nbsp;        }
<b class="nc"><i>818</i>&nbsp;        cp_Signature_form.resetForSecondPass();</b>
<b class="nc"><i>819</i>&nbsp;        cp_Signature_classes.expectLength(getIntTotal(numSigClasses));</b>
<b class="nc"><i>820</i>&nbsp;        cp_Signature_classes.readFrom(in);</b>
<b class="nc"><i>821</i>&nbsp;        cp_Signature_classes.setIndex(getCPIndex(CONSTANT_Class));</b>
<b class="nc"><i>822</i>&nbsp;        utf8Signatures = new HashMap&lt;&gt;();</b>
<b class="nc"><i>823</i>&nbsp;        for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>824</i>&nbsp;            Utf8Entry formRef = (Utf8Entry) cp_Signature_form.getRef();</b>
<b class="nc"><i>825</i>&nbsp;            ClassEntry[] classRefs = new ClassEntry[numSigClasses[i]];</b>
<b class="nc"><i>826</i>&nbsp;            for (int j = 0; j &lt; classRefs.length; j++) {</b>
<b class="nc"><i>827</i>&nbsp;                classRefs[j] = (ClassEntry) cp_Signature_classes.getRef();</b>
<i>828</i>&nbsp;            }
<b class="nc"><i>829</i>&nbsp;            SignatureEntry se = ConstantPool.getSignatureEntry(formRef, classRefs);</b>
<b class="nc"><i>830</i>&nbsp;            cpMap[i] = se;</b>
<b class="nc"><i>831</i>&nbsp;            utf8Signatures.put(se.asUtf8Entry(), se);</b>
<i>832</i>&nbsp;        }
<b class="nc"><i>833</i>&nbsp;        cp_Signature_form.doneDisbursing();</b>
<b class="nc"><i>834</i>&nbsp;        cp_Signature_classes.doneDisbursing();</b>
<i>835</i>&nbsp;    }
<i>836</i>&nbsp;
<i>837</i>&nbsp;    void readMemberRefs(byte tag, Entry[] cpMap, CPRefBand cp_class, CPRefBand cp_desc) throws IOException {
<i>838</i>&nbsp;        //  cp_Field:
<i>839</i>&nbsp;        //        *cp_Field_class :DELTA5  (cp_Class)
<i>840</i>&nbsp;        //        *cp_Field_desc :UDELTA5  (cp_Descr)
<i>841</i>&nbsp;        //  cp_Method:
<i>842</i>&nbsp;        //        *cp_Method_class :DELTA5  (cp_Class)
<i>843</i>&nbsp;        //        *cp_Method_desc :UDELTA5  (cp_Descr)
<i>844</i>&nbsp;        //  cp_Imethod:
<i>845</i>&nbsp;        //        *cp_Imethod_class :DELTA5  (cp_Class)
<i>846</i>&nbsp;        //        *cp_Imethod_desc :UDELTA5  (cp_Descr)
<b class="nc"><i>847</i>&nbsp;        cp_class.expectLength(cpMap.length);</b>
<b class="nc"><i>848</i>&nbsp;        cp_class.readFrom(in);</b>
<b class="nc"><i>849</i>&nbsp;        cp_class.setIndex(getCPIndex(CONSTANT_Class));</b>
<b class="nc"><i>850</i>&nbsp;        cp_desc.expectLength(cpMap.length);</b>
<b class="nc"><i>851</i>&nbsp;        cp_desc.readFrom(in);</b>
<b class="nc"><i>852</i>&nbsp;        cp_desc.setIndex(getCPIndex(CONSTANT_NameandType));</b>
<b class="nc"><i>853</i>&nbsp;        for (int i = 0; i &lt; cpMap.length; i++) {</b>
<b class="nc"><i>854</i>&nbsp;            ClassEntry      mclass = (ClassEntry     ) cp_class.getRef();</b>
<b class="nc"><i>855</i>&nbsp;            DescriptorEntry mdescr = (DescriptorEntry) cp_desc.getRef();</b>
<b class="nc"><i>856</i>&nbsp;            cpMap[i] = ConstantPool.getMemberEntry(tag, mclass, mdescr);</b>
<i>857</i>&nbsp;        }
<b class="nc"><i>858</i>&nbsp;        cp_class.doneDisbursing();</b>
<b class="nc"><i>859</i>&nbsp;        cp_desc.doneDisbursing();</b>
<i>860</i>&nbsp;    }
<i>861</i>&nbsp;
<i>862</i>&nbsp;    void readFiles() throws IOException {
<i>863</i>&nbsp;        //  file_bands:
<i>864</i>&nbsp;        //        *file_name :UNSIGNED5  (cp_Utf8)
<i>865</i>&nbsp;        //        *file_size_hi :UNSIGNED5
<i>866</i>&nbsp;        //        *file_size_lo :UNSIGNED5
<i>867</i>&nbsp;        //        *file_modtime :DELTA5
<i>868</i>&nbsp;        //        *file_options :UNSIGNED5
<i>869</i>&nbsp;        //        *file_bits :BYTE1
<b class="nc"><i>870</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>871</i>&nbsp;            Utils.log.info(&quot;  ...building &quot;+numFiles+&quot; files...&quot;);</b>
<b class="nc"><i>872</i>&nbsp;        file_name.expectLength(numFiles);</b>
<b class="nc"><i>873</i>&nbsp;        file_size_lo.expectLength(numFiles);</b>
<b class="nc"><i>874</i>&nbsp;        int options = archiveOptions;</b>
<b class="nc"><i>875</i>&nbsp;        boolean haveSizeHi  = testBit(options, AO_HAVE_FILE_SIZE_HI);</b>
<b class="nc"><i>876</i>&nbsp;        boolean haveModtime = testBit(options, AO_HAVE_FILE_MODTIME);</b>
<b class="nc"><i>877</i>&nbsp;        boolean haveOptions = testBit(options, AO_HAVE_FILE_OPTIONS);</b>
<b class="nc"><i>878</i>&nbsp;        if (haveSizeHi)</b>
<b class="nc"><i>879</i>&nbsp;            file_size_hi.expectLength(numFiles);</b>
<b class="nc"><i>880</i>&nbsp;        if (haveModtime)</b>
<b class="nc"><i>881</i>&nbsp;            file_modtime.expectLength(numFiles);</b>
<b class="nc"><i>882</i>&nbsp;        if (haveOptions)</b>
<b class="nc"><i>883</i>&nbsp;            file_options.expectLength(numFiles);</b>
<i>884</i>&nbsp;
<b class="nc"><i>885</i>&nbsp;        file_name.readFrom(in);</b>
<b class="nc"><i>886</i>&nbsp;        file_size_hi.readFrom(in);</b>
<b class="nc"><i>887</i>&nbsp;        file_size_lo.readFrom(in);</b>
<b class="nc"><i>888</i>&nbsp;        file_modtime.readFrom(in);</b>
<b class="nc"><i>889</i>&nbsp;        file_options.readFrom(in);</b>
<b class="nc"><i>890</i>&nbsp;        file_bits.setInputStreamFrom(in);</b>
<i>891</i>&nbsp;
<b class="nc"><i>892</i>&nbsp;        Iterator&lt;Class&gt; nextClass = pkg.getClasses().iterator();</b>
<i>893</i>&nbsp;
<i>894</i>&nbsp;        // Compute file lengths before reading any file bits.
<b class="nc"><i>895</i>&nbsp;        long totalFileLength = 0;</b>
<b class="nc"><i>896</i>&nbsp;        long[] fileLengths = new long[numFiles];</b>
<b class="nc"><i>897</i>&nbsp;        for (int i = 0; i &lt; numFiles; i++) {</b>
<b class="nc"><i>898</i>&nbsp;            long size = ((long)file_size_lo.getInt() &lt;&lt; 32) &gt;&gt;&gt; 32;</b>
<b class="nc"><i>899</i>&nbsp;            if (haveSizeHi)</b>
<b class="nc"><i>900</i>&nbsp;                size += (long)file_size_hi.getInt() &lt;&lt; 32;</b>
<b class="nc"><i>901</i>&nbsp;            fileLengths[i] = size;</b>
<b class="nc"><i>902</i>&nbsp;            totalFileLength += size;</b>
<i>903</i>&nbsp;        }
<b class="nc"><i>904</i>&nbsp;        assert(in.getReadLimit() == -1 || in.getReadLimit() == totalFileLength);</b>
<i>905</i>&nbsp;
<b class="nc"><i>906</i>&nbsp;        byte[] buf = new byte[1&lt;&lt;16];</b>
<b class="nc"><i>907</i>&nbsp;        for (int i = 0; i &lt; numFiles; i++) {</b>
<i>908</i>&nbsp;            // %%% Use a big temp file for file bits?
<b class="nc"><i>909</i>&nbsp;            Utf8Entry name = (Utf8Entry) file_name.getRef();</b>
<b class="nc"><i>910</i>&nbsp;            long size = fileLengths[i];</b>
<b class="nc"><i>911</i>&nbsp;            File file = pkg.new File(name);</b>
<b class="nc"><i>912</i>&nbsp;            file.modtime = pkg.default_modtime;</b>
<b class="nc"><i>913</i>&nbsp;            file.options = pkg.default_options;</b>
<b class="nc"><i>914</i>&nbsp;            if (haveModtime)</b>
<b class="nc"><i>915</i>&nbsp;                file.modtime += file_modtime.getInt();</b>
<b class="nc"><i>916</i>&nbsp;            if (haveOptions)</b>
<b class="nc"><i>917</i>&nbsp;                file.options |= file_options.getInt();</b>
<b class="nc"><i>918</i>&nbsp;            if (verbose &gt; 1)</b>
<b class="nc"><i>919</i>&nbsp;                Utils.log.fine(&quot;Reading &quot;+size+&quot; bytes of &quot;+name.stringValue());</b>
<b class="nc"><i>920</i>&nbsp;            long toRead = size;</b>
<b class="nc"><i>921</i>&nbsp;            while (toRead &gt; 0) {</b>
<b class="nc"><i>922</i>&nbsp;                int nr = buf.length;</b>
<b class="nc"><i>923</i>&nbsp;                if (nr &gt; toRead)  nr = (int) toRead;</b>
<b class="nc"><i>924</i>&nbsp;                nr = file_bits.getInputStream().read(buf, 0, nr);</b>
<b class="nc"><i>925</i>&nbsp;                if (nr &lt; 0)  throw new EOFException();</b>
<b class="nc"><i>926</i>&nbsp;                file.addBytes(buf, 0, nr);</b>
<b class="nc"><i>927</i>&nbsp;                toRead -= nr;</b>
<b class="nc"><i>928</i>&nbsp;            }</b>
<b class="nc"><i>929</i>&nbsp;            pkg.addFile(file);</b>
<b class="nc"><i>930</i>&nbsp;            if (file.isClassStub()) {</b>
<b class="nc"><i>931</i>&nbsp;                assert(file.getFileLength() == 0);</b>
<b class="nc"><i>932</i>&nbsp;                Class cls = nextClass.next();</b>
<b class="nc"><i>933</i>&nbsp;                cls.initFile(file);</b>
<i>934</i>&nbsp;            }
<i>935</i>&nbsp;        }
<i>936</i>&nbsp;
<i>937</i>&nbsp;        // Do the rest of the classes.
<b class="nc"><i>938</i>&nbsp;        while (nextClass.hasNext()) {</b>
<b class="nc"><i>939</i>&nbsp;            Class cls = nextClass.next();</b>
<b class="nc"><i>940</i>&nbsp;            cls.initFile(null);  // implicitly initialize to a trivial one</b>
<b class="nc"><i>941</i>&nbsp;            cls.file.modtime = pkg.default_modtime;</b>
<b class="nc"><i>942</i>&nbsp;        }</b>
<i>943</i>&nbsp;
<b class="nc"><i>944</i>&nbsp;        file_name.doneDisbursing();</b>
<b class="nc"><i>945</i>&nbsp;        file_size_hi.doneDisbursing();</b>
<b class="nc"><i>946</i>&nbsp;        file_size_lo.doneDisbursing();</b>
<b class="nc"><i>947</i>&nbsp;        file_modtime.doneDisbursing();</b>
<b class="nc"><i>948</i>&nbsp;        file_options.doneDisbursing();</b>
<b class="nc"><i>949</i>&nbsp;        file_bits.doneDisbursing();</b>
<b class="nc"><i>950</i>&nbsp;        file_bands.doneDisbursing();</b>
<i>951</i>&nbsp;
<b class="nc"><i>952</i>&nbsp;        if (archiveSize1 != 0 &amp;&amp; !in.atLimit()) {</b>
<b class="nc"><i>953</i>&nbsp;            throw new RuntimeException(&quot;Predicted archive_size &quot;+</b>
<i>954</i>&nbsp;                                       archiveSize1+&quot; != &quot;+
<b class="nc"><i>955</i>&nbsp;                                       (in.getBytesServed()-archiveSize0));</b>
<i>956</i>&nbsp;        }
<i>957</i>&nbsp;    }
<i>958</i>&nbsp;
<i>959</i>&nbsp;    void readAttrDefs() throws IOException {
<i>960</i>&nbsp;        //  attr_definition_bands:
<i>961</i>&nbsp;        //        *attr_definition_headers :BYTE1
<i>962</i>&nbsp;        //        *attr_definition_name :UNSIGNED5  (cp_Utf8)
<i>963</i>&nbsp;        //        *attr_definition_layout :UNSIGNED5  (cp_Utf8)
<b class="nc"><i>964</i>&nbsp;        attr_definition_headers.expectLength(numAttrDefs);</b>
<b class="nc"><i>965</i>&nbsp;        attr_definition_name.expectLength(numAttrDefs);</b>
<b class="nc"><i>966</i>&nbsp;        attr_definition_layout.expectLength(numAttrDefs);</b>
<b class="nc"><i>967</i>&nbsp;        attr_definition_headers.readFrom(in);</b>
<b class="nc"><i>968</i>&nbsp;        attr_definition_name.readFrom(in);</b>
<b class="nc"><i>969</i>&nbsp;        attr_definition_layout.readFrom(in);</b>
<b class="nc"><i>970</i>&nbsp;        try (PrintStream dump = !optDumpBands ? null</b>
<b class="nc"><i>971</i>&nbsp;                 : new PrintStream(getDumpStream(attr_definition_headers, &quot;.def&quot;)))</b>
<i>972</i>&nbsp;        {
<b class="nc"><i>973</i>&nbsp;            for (int i = 0; i &lt; numAttrDefs; i++) {</b>
<b class="nc"><i>974</i>&nbsp;                int       header = attr_definition_headers.getByte();</b>
<b class="nc"><i>975</i>&nbsp;                Utf8Entry name   = (Utf8Entry) attr_definition_name.getRef();</b>
<b class="nc"><i>976</i>&nbsp;                Utf8Entry layout = (Utf8Entry) attr_definition_layout.getRef();</b>
<b class="nc"><i>977</i>&nbsp;                int       ctype  = (header &amp;  ADH_CONTEXT_MASK);</b>
<b class="nc"><i>978</i>&nbsp;                int       index  = (header &gt;&gt; ADH_BIT_SHIFT) - ADH_BIT_IS_LSB;</b>
<b class="nc"><i>979</i>&nbsp;                Attribute.Layout def = new Attribute.Layout(ctype,</b>
<b class="nc"><i>980</i>&nbsp;                                                            name.stringValue(),</b>
<b class="nc"><i>981</i>&nbsp;                                                            layout.stringValue());</b>
<i>982</i>&nbsp;                // Check layout string for Java 6 extensions.
<b class="nc"><i>983</i>&nbsp;                String pvLayout = def.layoutForClassVersion(getHighestClassVersion());</b>
<b class="nc"><i>984</i>&nbsp;                if (!pvLayout.equals(def.layout())) {</b>
<b class="nc"><i>985</i>&nbsp;                    throw new IOException(&quot;Bad attribute layout in archive: &quot;+def.layout());</b>
<i>986</i>&nbsp;                }
<b class="nc"><i>987</i>&nbsp;                this.setAttributeLayoutIndex(def, index);</b>
<b class="nc"><i>988</i>&nbsp;                if (dump != null)  dump.println(index+&quot; &quot;+def);</b>
<i>989</i>&nbsp;            }
<b class="nc"><i>990</i>&nbsp;        }</b>
<b class="nc"><i>991</i>&nbsp;        attr_definition_headers.doneDisbursing();</b>
<b class="nc"><i>992</i>&nbsp;        attr_definition_name.doneDisbursing();</b>
<b class="nc"><i>993</i>&nbsp;        attr_definition_layout.doneDisbursing();</b>
<i>994</i>&nbsp;        // Attribute layouts define bands, one per layout element.
<i>995</i>&nbsp;        // Create them now, all at once.
<b class="nc"><i>996</i>&nbsp;        makeNewAttributeBands();</b>
<b class="nc"><i>997</i>&nbsp;        attr_definition_bands.doneDisbursing();</b>
<i>998</i>&nbsp;    }
<i>999</i>&nbsp;
<i>1000</i>&nbsp;    void readInnerClasses() throws IOException {
<i>1001</i>&nbsp;        //  ic_bands:
<i>1002</i>&nbsp;        //        *ic_this_class :UDELTA5  (cp_Class)
<i>1003</i>&nbsp;        //        *ic_flags :UNSIGNED5
<i>1004</i>&nbsp;        //        *ic_outer_class :DELTA5  (null or cp_Class)
<i>1005</i>&nbsp;        //        *ic_name :DELTA5  (null or cp_Utf8)
<b class="nc"><i>1006</i>&nbsp;        ic_this_class.expectLength(numInnerClasses);</b>
<b class="nc"><i>1007</i>&nbsp;        ic_this_class.readFrom(in);</b>
<b class="nc"><i>1008</i>&nbsp;        ic_flags.expectLength(numInnerClasses);</b>
<b class="nc"><i>1009</i>&nbsp;        ic_flags.readFrom(in);</b>
<b class="nc"><i>1010</i>&nbsp;        int longICCount = 0;</b>
<b class="nc"><i>1011</i>&nbsp;        for (int i = 0; i &lt; numInnerClasses; i++) {</b>
<b class="nc"><i>1012</i>&nbsp;            int flags = ic_flags.getInt();</b>
<b class="nc"><i>1013</i>&nbsp;            boolean longForm = (flags &amp; ACC_IC_LONG_FORM) != 0;</b>
<b class="nc"><i>1014</i>&nbsp;            if (longForm) {</b>
<b class="nc"><i>1015</i>&nbsp;                longICCount += 1;</b>
<i>1016</i>&nbsp;            }
<i>1017</i>&nbsp;        }
<b class="nc"><i>1018</i>&nbsp;        ic_outer_class.expectLength(longICCount);</b>
<b class="nc"><i>1019</i>&nbsp;        ic_outer_class.readFrom(in);</b>
<b class="nc"><i>1020</i>&nbsp;        ic_name.expectLength(longICCount);</b>
<b class="nc"><i>1021</i>&nbsp;        ic_name.readFrom(in);</b>
<b class="nc"><i>1022</i>&nbsp;        ic_flags.resetForSecondPass();</b>
<b class="nc"><i>1023</i>&nbsp;        List&lt;InnerClass&gt; icList = new ArrayList&lt;&gt;(numInnerClasses);</b>
<b class="nc"><i>1024</i>&nbsp;        for (int i = 0; i &lt; numInnerClasses; i++) {</b>
<b class="nc"><i>1025</i>&nbsp;            int flags = ic_flags.getInt();</b>
<b class="nc"><i>1026</i>&nbsp;            boolean longForm = (flags &amp; ACC_IC_LONG_FORM) != 0;</b>
<b class="nc"><i>1027</i>&nbsp;            flags &amp;= ~ACC_IC_LONG_FORM;</b>
<b class="nc"><i>1028</i>&nbsp;            ClassEntry thisClass = (ClassEntry) ic_this_class.getRef();</b>
<i>1029</i>&nbsp;            ClassEntry outerClass;
<i>1030</i>&nbsp;            Utf8Entry  thisName;
<b class="nc"><i>1031</i>&nbsp;            if (longForm) {</b>
<b class="nc"><i>1032</i>&nbsp;                outerClass = (ClassEntry) ic_outer_class.getRef();</b>
<b class="nc"><i>1033</i>&nbsp;                thisName   = (Utf8Entry)  ic_name.getRef();</b>
<i>1034</i>&nbsp;            } else {
<b class="nc"><i>1035</i>&nbsp;                String n = thisClass.stringValue();</b>
<b class="nc"><i>1036</i>&nbsp;                String[] parse = Package.parseInnerClassName(n);</b>
<b class="nc"><i>1037</i>&nbsp;                assert(parse != null);</b>
<b class="nc"><i>1038</i>&nbsp;                String pkgOuter = parse[0];</b>
<i>1039</i>&nbsp;                //String number = parse[1];
<b class="nc"><i>1040</i>&nbsp;                String name     = parse[2];</b>
<b class="nc"><i>1041</i>&nbsp;                if (pkgOuter == null)</b>
<b class="nc"><i>1042</i>&nbsp;                    outerClass = null;</b>
<i>1043</i>&nbsp;                else
<b class="nc"><i>1044</i>&nbsp;                    outerClass = ConstantPool.getClassEntry(pkgOuter);</b>
<b class="nc"><i>1045</i>&nbsp;                if (name == null)</b>
<b class="nc"><i>1046</i>&nbsp;                    thisName   = null;</b>
<i>1047</i>&nbsp;                else
<b class="nc"><i>1048</i>&nbsp;                    thisName   = ConstantPool.getUtf8Entry(name);</b>
<i>1049</i>&nbsp;            }
<b class="nc"><i>1050</i>&nbsp;            InnerClass ic =</b>
<i>1051</i>&nbsp;                new InnerClass(thisClass, outerClass, thisName, flags);
<b class="nc"><i>1052</i>&nbsp;            assert(longForm || ic.predictable);</b>
<b class="nc"><i>1053</i>&nbsp;            icList.add(ic);</b>
<i>1054</i>&nbsp;        }
<b class="nc"><i>1055</i>&nbsp;        ic_flags.doneDisbursing();</b>
<b class="nc"><i>1056</i>&nbsp;        ic_this_class.doneDisbursing();</b>
<b class="nc"><i>1057</i>&nbsp;        ic_outer_class.doneDisbursing();</b>
<b class="nc"><i>1058</i>&nbsp;        ic_name.doneDisbursing();</b>
<b class="nc"><i>1059</i>&nbsp;        pkg.setAllInnerClasses(icList);</b>
<b class="nc"><i>1060</i>&nbsp;        ic_bands.doneDisbursing();</b>
<i>1061</i>&nbsp;    }
<i>1062</i>&nbsp;
<i>1063</i>&nbsp;    void readLocalInnerClasses(Class cls) throws IOException {
<b class="nc"><i>1064</i>&nbsp;        int nc = class_InnerClasses_N.getInt();</b>
<b class="nc"><i>1065</i>&nbsp;        List&lt;InnerClass&gt; localICs = new ArrayList&lt;&gt;(nc);</b>
<b class="nc"><i>1066</i>&nbsp;        for (int i = 0; i &lt; nc; i++) {</b>
<b class="nc"><i>1067</i>&nbsp;            ClassEntry thisClass = (ClassEntry) class_InnerClasses_RC.getRef();</b>
<b class="nc"><i>1068</i>&nbsp;            int        flags     =              class_InnerClasses_F.getInt();</b>
<b class="nc"><i>1069</i>&nbsp;            if (flags == 0) {</b>
<i>1070</i>&nbsp;                // A zero flag means copy a global IC here.
<b class="nc"><i>1071</i>&nbsp;                InnerClass ic = pkg.getGlobalInnerClass(thisClass);</b>
<b class="nc"><i>1072</i>&nbsp;                assert(ic != null);  // must be a valid global IC reference</b>
<b class="nc"><i>1073</i>&nbsp;                localICs.add(ic);</b>
<b class="nc"><i>1074</i>&nbsp;            } else {</b>
<b class="nc"><i>1075</i>&nbsp;                if (flags == ACC_IC_LONG_FORM)</b>
<b class="nc"><i>1076</i>&nbsp;                    flags = 0;  // clear the marker bit</b>
<b class="nc"><i>1077</i>&nbsp;                ClassEntry outer = (ClassEntry) class_InnerClasses_outer_RCN.getRef();</b>
<b class="nc"><i>1078</i>&nbsp;                Utf8Entry name   = (Utf8Entry)  class_InnerClasses_name_RUN.getRef();</b>
<b class="nc"><i>1079</i>&nbsp;                localICs.add(new InnerClass(thisClass, outer, name, flags));</b>
<i>1080</i>&nbsp;            }
<i>1081</i>&nbsp;        }
<b class="nc"><i>1082</i>&nbsp;        cls.setInnerClasses(localICs);</b>
<i>1083</i>&nbsp;        // cls.expandLocalICs may add more tuples to ics also,
<i>1084</i>&nbsp;        // or may even delete tuples.
<i>1085</i>&nbsp;        // We cannot do that now, because we do not know the
<i>1086</i>&nbsp;        // full contents of the local constant pool yet.
<i>1087</i>&nbsp;    }
<i>1088</i>&nbsp;
<i>1089</i>&nbsp;    static final int NO_FLAGS_YET = 0;  // placeholder for later flag read-in
<i>1090</i>&nbsp;
<i>1091</i>&nbsp;    Class[] readClasses() throws IOException {
<i>1092</i>&nbsp;        //  class_bands:
<i>1093</i>&nbsp;        //        *class_this :DELTA5  (cp_Class)
<i>1094</i>&nbsp;        //        *class_super :DELTA5  (cp_Class)
<i>1095</i>&nbsp;        //        *class_interface_count :DELTA5
<i>1096</i>&nbsp;        //        *class_interface :DELTA5  (cp_Class)
<i>1097</i>&nbsp;        //        ...(member bands)...
<i>1098</i>&nbsp;        //        class_attr_bands
<i>1099</i>&nbsp;        //        code_bands
<b class="nc"><i>1100</i>&nbsp;        Class[] classes = new Class[numClasses];</b>
<b class="nc"><i>1101</i>&nbsp;        if (verbose &gt; 0)</b>
<b class="nc"><i>1102</i>&nbsp;            Utils.log.info(&quot;  ...building &quot;+classes.length+&quot; classes...&quot;);</b>
<i>1103</i>&nbsp;
<b class="nc"><i>1104</i>&nbsp;        class_this.expectLength(numClasses);</b>
<b class="nc"><i>1105</i>&nbsp;        class_super.expectLength(numClasses);</b>
<b class="nc"><i>1106</i>&nbsp;        class_interface_count.expectLength(numClasses);</b>
<i>1107</i>&nbsp;
<b class="nc"><i>1108</i>&nbsp;        class_this.readFrom(in);</b>
<b class="nc"><i>1109</i>&nbsp;        class_super.readFrom(in);</b>
<b class="nc"><i>1110</i>&nbsp;        class_interface_count.readFrom(in);</b>
<b class="nc"><i>1111</i>&nbsp;        class_interface.expectLength(class_interface_count.getIntTotal());</b>
<b class="nc"><i>1112</i>&nbsp;        class_interface.readFrom(in);</b>
<b class="nc"><i>1113</i>&nbsp;        for (int i = 0; i &lt; classes.length; i++) {</b>
<b class="nc"><i>1114</i>&nbsp;            ClassEntry   thisClass  = (ClassEntry) class_this.getRef();</b>
<b class="nc"><i>1115</i>&nbsp;            ClassEntry   superClass = (ClassEntry) class_super.getRef();</b>
<b class="nc"><i>1116</i>&nbsp;            ClassEntry[] interfaces = new ClassEntry[class_interface_count.getInt()];</b>
<b class="nc"><i>1117</i>&nbsp;            for (int j = 0; j &lt; interfaces.length; j++) {</b>
<b class="nc"><i>1118</i>&nbsp;                interfaces[j] = (ClassEntry) class_interface.getRef();</b>
<i>1119</i>&nbsp;            }
<i>1120</i>&nbsp;            // Packer encoded rare case of null superClass as thisClass:
<b class="nc"><i>1121</i>&nbsp;            if (superClass == thisClass)  superClass = null;</b>
<b class="nc"><i>1122</i>&nbsp;            Class cls = pkg.new Class(NO_FLAGS_YET,</b>
<i>1123</i>&nbsp;                                      thisClass, superClass, interfaces);
<b class="nc"><i>1124</i>&nbsp;            classes[i] = cls;</b>
<i>1125</i>&nbsp;        }
<b class="nc"><i>1126</i>&nbsp;        class_this.doneDisbursing();</b>
<b class="nc"><i>1127</i>&nbsp;        class_super.doneDisbursing();</b>
<b class="nc"><i>1128</i>&nbsp;        class_interface_count.doneDisbursing();</b>
<b class="nc"><i>1129</i>&nbsp;        class_interface.doneDisbursing();</b>
<b class="nc"><i>1130</i>&nbsp;        readMembers(classes);</b>
<b class="nc"><i>1131</i>&nbsp;        countAndReadAttrs(ATTR_CONTEXT_CLASS, Arrays.asList(classes));</b>
<b class="nc"><i>1132</i>&nbsp;        pkg.trimToSize();</b>
<b class="nc"><i>1133</i>&nbsp;        readCodeHeaders();</b>
<i>1134</i>&nbsp;        //code_bands.doneDisbursing(); // still need to read code attrs
<i>1135</i>&nbsp;        //class_bands.doneDisbursing(); // still need to read code attrs
<b class="nc"><i>1136</i>&nbsp;        return classes;</b>
<i>1137</i>&nbsp;    }
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;    private int getOutputIndex(Entry e) {
<i>1140</i>&nbsp;        // Output CPs do not contain signatures.
<b class="nc"><i>1141</i>&nbsp;        assert(e.tag != CONSTANT_Signature);</b>
<b class="nc"><i>1142</i>&nbsp;        int k = pkg.cp.untypedIndexOf(e);</b>
<i>1143</i>&nbsp;        // In the output ordering, input signatures can serve
<i>1144</i>&nbsp;        // in place of Utf8s.
<b class="nc"><i>1145</i>&nbsp;        if (k &gt;= 0)</b>
<b class="nc"><i>1146</i>&nbsp;            return k;</b>
<b class="nc"><i>1147</i>&nbsp;        if (e.tag == CONSTANT_Utf8) {</b>
<b class="nc"><i>1148</i>&nbsp;            Entry se = utf8Signatures.get(e);</b>
<b class="nc"><i>1149</i>&nbsp;            return pkg.cp.untypedIndexOf(se);</b>
<i>1150</i>&nbsp;        }
<b class="nc"><i>1151</i>&nbsp;        return -1;</b>
<i>1152</i>&nbsp;    }
<i>1153</i>&nbsp;
<b class="nc"><i>1154</i>&nbsp;    Comparator&lt;Entry&gt; entryOutputOrder = new Comparator&lt;&gt;() {</b>
<i>1155</i>&nbsp;        public int compare(Entry e0, Entry e1) {
<b class="nc"><i>1156</i>&nbsp;            int k0 = getOutputIndex(e0);</b>
<b class="nc"><i>1157</i>&nbsp;            int k1 = getOutputIndex(e1);</b>
<b class="nc"><i>1158</i>&nbsp;            if (k0 &gt;= 0 &amp;&amp; k1 &gt;= 0)</b>
<i>1159</i>&nbsp;                // If both have keys, use the keys.
<b class="nc"><i>1160</i>&nbsp;                return k0 - k1;</b>
<b class="nc"><i>1161</i>&nbsp;            if (k0 == k1)</b>
<i>1162</i>&nbsp;                // If neither have keys, use their native tags &amp; spellings.
<b class="nc"><i>1163</i>&nbsp;                return e0.compareTo(e1);</b>
<i>1164</i>&nbsp;            // Otherwise, the guy with the key comes first.
<b class="nc"><i>1165</i>&nbsp;            return (k0 &gt;= 0)? 0-1: 1-0;</b>
<i>1166</i>&nbsp;        }
<i>1167</i>&nbsp;    };
<i>1168</i>&nbsp;
<i>1169</i>&nbsp;    void reconstructClass(Class cls) {
<b class="nc"><i>1170</i>&nbsp;        if (verbose &gt; 1)  Utils.log.fine(&quot;reconstruct &quot;+cls);</b>
<i>1171</i>&nbsp;
<i>1172</i>&nbsp;        // check for local .ClassFile.version
<b class="nc"><i>1173</i>&nbsp;        Attribute retroVersion = cls.getAttribute(attrClassFileVersion);</b>
<b class="nc"><i>1174</i>&nbsp;        if (retroVersion != null) {</b>
<b class="nc"><i>1175</i>&nbsp;            cls.removeAttribute(retroVersion);</b>
<b class="nc"><i>1176</i>&nbsp;            cls.version = parseClassFileVersionAttr(retroVersion);</b>
<i>1177</i>&nbsp;        } else {
<b class="nc"><i>1178</i>&nbsp;            cls.version = pkg.defaultClassVersion;</b>
<i>1179</i>&nbsp;        }
<i>1180</i>&nbsp;
<i>1181</i>&nbsp;        // Replace null SourceFile by &quot;obvious&quot; string.
<b class="nc"><i>1182</i>&nbsp;        cls.expandSourceFile();</b>
<i>1183</i>&nbsp;
<i>1184</i>&nbsp;        // record the local cp:
<b class="nc"><i>1185</i>&nbsp;        cls.setCPMap(reconstructLocalCPMap(cls));</b>
<i>1186</i>&nbsp;    }
<i>1187</i>&nbsp;
<i>1188</i>&nbsp;    Entry[] reconstructLocalCPMap(Class cls) {
<b class="nc"><i>1189</i>&nbsp;        Set&lt;Entry&gt; ldcRefs = ldcRefMap.get(cls);</b>
<b class="nc"><i>1190</i>&nbsp;        Set&lt;Entry&gt; cpRefs = new HashSet&lt;&gt;();</b>
<i>1191</i>&nbsp;
<i>1192</i>&nbsp;        // look for constant pool entries:
<b class="nc"><i>1193</i>&nbsp;        cls.visitRefs(VRM_CLASSIC, cpRefs);</b>
<i>1194</i>&nbsp;
<b class="nc"><i>1195</i>&nbsp;        ArrayList&lt;BootstrapMethodEntry&gt; bsms = new ArrayList&lt;&gt;();</b>
<i>1196</i>&nbsp;        // flesh out the local constant pool
<i>1197</i>&nbsp;        ConstantPool.completeReferencesIn(cpRefs, true, bsms);
<i>1198</i>&nbsp;
<i>1199</i>&nbsp;        // add the bsm and references as required
<i>1200</i>&nbsp;        if (!bsms.isEmpty()) {
<b class="nc"><i>1201</i>&nbsp;            cls.addAttribute(Package.attrBootstrapMethodsEmpty.canonicalInstance());</b>
<i>1202</i>&nbsp;            cpRefs.add(Package.getRefString(&quot;BootstrapMethods&quot;));
<i>1203</i>&nbsp;            Collections.sort(bsms);
<b class="nc"><i>1204</i>&nbsp;            cls.setBootstrapMethods(bsms);</b>
<i>1205</i>&nbsp;        }
<i>1206</i>&nbsp;
<i>1207</i>&nbsp;        // Now that we know all our local class references,
<b class="nc"><i>1208</i>&nbsp;        // compute the InnerClasses attribute.</b>
<i>1209</i>&nbsp;        // An InnerClasses attribute usually gets added here,
<b class="nc"><i>1210</i>&nbsp;        // although it might already have been present.</b>
<b class="nc"><i>1211</i>&nbsp;        int changed = cls.expandLocalICs();</b>
<i>1212</i>&nbsp;
<b class="nc"><i>1213</i>&nbsp;        if (changed != 0) {</b>
<i>1214</i>&nbsp;            if (changed &gt; 0) {
<i>1215</i>&nbsp;                // Just visit the expanded InnerClasses attr.
<b class="nc"><i>1216</i>&nbsp;                cls.visitInnerClassRefs(VRM_CLASSIC, cpRefs);</b>
<b class="nc"><i>1217</i>&nbsp;            } else {</b>
<i>1218</i>&nbsp;                // Have to recompute from scratch, because of deletions.
<i>1219</i>&nbsp;                cpRefs.clear();
<i>1220</i>&nbsp;                cls.visitRefs(VRM_CLASSIC, cpRefs);
<b class="nc"><i>1221</i>&nbsp;            }</b>
<i>1222</i>&nbsp;
<i>1223</i>&nbsp;            // flesh out the local constant pool, again
<i>1224</i>&nbsp;            ConstantPool.completeReferencesIn(cpRefs, true, bsms);
<i>1225</i>&nbsp;        }
<b class="nc"><i>1226</i>&nbsp;</b>
<b class="nc"><i>1227</i>&nbsp;        // construct a local constant pool</b>
<i>1228</i>&nbsp;        int numDoubles = 0;
<b class="nc"><i>1229</i>&nbsp;        for (Entry e : cpRefs) {</b>
<b class="nc"><i>1230</i>&nbsp;            if (e.isDoubleWord())  numDoubles++;</b>
<b class="nc"><i>1231</i>&nbsp;        }</b>
<i>1232</i>&nbsp;        Entry[] cpMap = new Entry[1+numDoubles+cpRefs.size()];
<i>1233</i>&nbsp;        int fillp = 1;
<i>1234</i>&nbsp;
<b class="nc"><i>1235</i>&nbsp;        // Add all ldc operands first.</b>
<b class="nc"><i>1236</i>&nbsp;        if (ldcRefs != null) {</b>
<b class="nc"><i>1237</i>&nbsp;            assert(cpRefs.containsAll(ldcRefs));</b>
<b class="nc"><i>1238</i>&nbsp;            for (Entry e : ldcRefs) {</b>
<b class="nc"><i>1239</i>&nbsp;                cpMap[fillp++] = e;</b>
<b class="nc"><i>1240</i>&nbsp;            }</b>
<i>1241</i>&nbsp;            assert(fillp == 1+ldcRefs.size());
<i>1242</i>&nbsp;            cpRefs.removeAll(ldcRefs);
<b class="nc"><i>1243</i>&nbsp;            ldcRefs = null;  // done with it</b>
<b class="nc"><i>1244</i>&nbsp;        }</b>
<b class="nc"><i>1245</i>&nbsp;</b>
<b class="nc"><i>1246</i>&nbsp;        // Next add all the two-byte references.</b>
<b class="nc"><i>1247</i>&nbsp;        Set&lt;Entry&gt; wideRefs = cpRefs;</b>
<b class="nc"><i>1248</i>&nbsp;        cpRefs = null;  // do not use!</b>
<b class="nc"><i>1249</i>&nbsp;        int narrowLimit = fillp;</b>
<b class="nc"><i>1250</i>&nbsp;        for (Entry e : wideRefs) {</b>
<i>1251</i>&nbsp;            cpMap[fillp++] = e;
<i>1252</i>&nbsp;        }
<i>1253</i>&nbsp;        assert(fillp == narrowLimit+wideRefs.size());
<b class="nc"><i>1254</i>&nbsp;        Arrays.sort(cpMap, 1, narrowLimit, entryOutputOrder);</b>
<b class="nc"><i>1255</i>&nbsp;        Arrays.sort(cpMap, narrowLimit, fillp, entryOutputOrder);</b>
<b class="nc"><i>1256</i>&nbsp;</b>
<b class="nc"><i>1257</i>&nbsp;        if (verbose &gt; 3) {</b>
<b class="nc"><i>1258</i>&nbsp;            Utils.log.fine(&quot;CP of &quot;+this+&quot; {&quot;);</b>
<b class="nc"><i>1259</i>&nbsp;            for (int i = 0; i &lt; fillp; i++) {</b>
<b class="nc"><i>1260</i>&nbsp;                Entry e = cpMap[i];</b>
<b class="nc"><i>1261</i>&nbsp;                Utils.log.fine(&quot;  &quot;+((e==null)?-1:getOutputIndex(e))</b>
<b class="nc"><i>1262</i>&nbsp;                                   +&quot; : &quot;+e);</b>
<i>1263</i>&nbsp;            }
<b class="nc"><i>1264</i>&nbsp;            Utils.log.fine(&quot;}&quot;);</b>
<b class="nc"><i>1265</i>&nbsp;        }</b>
<b class="nc"><i>1266</i>&nbsp;</b>
<b class="nc"><i>1267</i>&nbsp;        // Now repack backwards, introducing null elements.</b>
<b class="nc"><i>1268</i>&nbsp;        int revp = cpMap.length;</b>
<i>1269</i>&nbsp;        for (int i = fillp; --i &gt;= 1; ) {
<i>1270</i>&nbsp;            Entry e = cpMap[i];
<b class="nc"><i>1271</i>&nbsp;            if (e.isDoubleWord())</b>
<i>1272</i>&nbsp;                cpMap[--revp] = null;
<i>1273</i>&nbsp;            cpMap[--revp] = e;
<i>1274</i>&nbsp;        }
<b class="nc"><i>1275</i>&nbsp;        assert(revp == 1);  // do not process the initial null</b>
<b class="nc"><i>1276</i>&nbsp;</b>
<b class="nc"><i>1277</i>&nbsp;        return cpMap;</b>
<b class="nc"><i>1278</i>&nbsp;    }</b>
<b class="nc"><i>1279</i>&nbsp;</b>
<b class="nc"><i>1280</i>&nbsp;    void readMembers(Class[] classes) throws IOException {</b>
<b class="nc"><i>1281</i>&nbsp;        //  class_bands:</b>
<b class="nc"><i>1282</i>&nbsp;        //        ...</b>
<i>1283</i>&nbsp;        //        *class_field_count :DELTA5
<b class="nc"><i>1284</i>&nbsp;        //        *class_method_count :DELTA5</b>
<i>1285</i>&nbsp;        //
<i>1286</i>&nbsp;        //        *field_descr :DELTA5  (cp_Descr)
<i>1287</i>&nbsp;        //        field_attr_bands
<i>1288</i>&nbsp;        //
<i>1289</i>&nbsp;        //        *method_descr :MDELTA5  (cp_Descr)
<i>1290</i>&nbsp;        //        method_attr_bands
<i>1291</i>&nbsp;        //        ...
<i>1292</i>&nbsp;        assert(classes.length == numClasses);
<i>1293</i>&nbsp;        class_field_count.expectLength(numClasses);
<i>1294</i>&nbsp;        class_method_count.expectLength(numClasses);
<i>1295</i>&nbsp;        class_field_count.readFrom(in);
<i>1296</i>&nbsp;        class_method_count.readFrom(in);
<i>1297</i>&nbsp;
<i>1298</i>&nbsp;        // Make a pre-pass over field and method counts to size the descrs:
<b class="nc"><i>1299</i>&nbsp;        int totalNF = class_field_count.getIntTotal();</b>
<b class="nc"><i>1300</i>&nbsp;        int totalNM = class_method_count.getIntTotal();</b>
<b class="nc"><i>1301</i>&nbsp;        field_descr.expectLength(totalNF);</b>
<b class="nc"><i>1302</i>&nbsp;        method_descr.expectLength(totalNM);</b>
<b class="nc"><i>1303</i>&nbsp;        if (verbose &gt; 1)  Utils.log.fine(&quot;expecting #fields=&quot;+totalNF+</b>
<i>1304</i>&nbsp;                &quot; and #methods=&quot;+totalNM+&quot; in #classes=&quot;+numClasses);
<i>1305</i>&nbsp;
<b class="nc"><i>1306</i>&nbsp;        List&lt;Class.Field&gt; fields = new ArrayList&lt;&gt;(totalNF);</b>
<b class="nc"><i>1307</i>&nbsp;        field_descr.readFrom(in);</b>
<b class="nc"><i>1308</i>&nbsp;        for (int i = 0; i &lt; classes.length; i++) {</b>
<b class="nc"><i>1309</i>&nbsp;            Class c = classes[i];</b>
<b class="nc"><i>1310</i>&nbsp;            int nf = class_field_count.getInt();</b>
<i>1311</i>&nbsp;            for (int j = 0; j &lt; nf; j++) {
<i>1312</i>&nbsp;                Class.Field f = c.new Field(NO_FLAGS_YET, (DescriptorEntry)
<b class="nc"><i>1313</i>&nbsp;                                            field_descr.getRef());</b>
<b class="nc"><i>1314</i>&nbsp;                fields.add(f);</b>
<b class="nc"><i>1315</i>&nbsp;            }</b>
<b class="nc"><i>1316</i>&nbsp;        }</b>
<b class="nc"><i>1317</i>&nbsp;        class_field_count.doneDisbursing();</b>
<b class="nc"><i>1318</i>&nbsp;        field_descr.doneDisbursing();</b>
<b class="nc"><i>1319</i>&nbsp;        countAndReadAttrs(ATTR_CONTEXT_FIELD, fields);</b>
<b class="nc"><i>1320</i>&nbsp;        fields = null;  // release to GC</b>
<b class="nc"><i>1321</i>&nbsp;</b>
<i>1322</i>&nbsp;        List&lt;Class.Method&gt; methods = new ArrayList&lt;&gt;(totalNM);
<i>1323</i>&nbsp;        method_descr.readFrom(in);
<b class="nc"><i>1324</i>&nbsp;        for (int i = 0; i &lt; classes.length; i++) {</b>
<b class="nc"><i>1325</i>&nbsp;            Class c = classes[i];</b>
<b class="nc"><i>1326</i>&nbsp;            int nm = class_method_count.getInt();</b>
<b class="nc"><i>1327</i>&nbsp;            for (int j = 0; j &lt; nm; j++) {</b>
<i>1328</i>&nbsp;                Class.Method m = c.new Method(NO_FLAGS_YET, (DescriptorEntry)
<b class="nc"><i>1329</i>&nbsp;                                              method_descr.getRef());</b>
<b class="nc"><i>1330</i>&nbsp;                methods.add(m);</b>
<b class="nc"><i>1331</i>&nbsp;            }</b>
<b class="nc"><i>1332</i>&nbsp;        }</b>
<b class="nc"><i>1333</i>&nbsp;        class_method_count.doneDisbursing();</b>
<b class="nc"><i>1334</i>&nbsp;        method_descr.doneDisbursing();</b>
<b class="nc"><i>1335</i>&nbsp;        countAndReadAttrs(ATTR_CONTEXT_METHOD, methods);</b>
<b class="nc"><i>1336</i>&nbsp;</b>
<b class="nc"><i>1337</i>&nbsp;        // Up to this point, Code attributes look like empty attributes.</b>
<i>1338</i>&nbsp;        // Now we start to special-case them.  The empty canonical Code
<i>1339</i>&nbsp;        // attributes stay in the method attribute lists, however.
<b class="nc"><i>1340</i>&nbsp;        allCodes = buildCodeAttrs(methods);</b>
<b class="nc"><i>1341</i>&nbsp;    }</b>
<b class="nc"><i>1342</i>&nbsp;</b>
<i>1343</i>&nbsp;    Code[] allCodes;
<i>1344</i>&nbsp;    List&lt;Code&gt; codesWithFlags;
<i>1345</i>&nbsp;    Map&lt;Class, Set&lt;Entry&gt;&gt; ldcRefMap = new HashMap&lt;&gt;();
<i>1346</i>&nbsp;
<b class="nc"><i>1347</i>&nbsp;    Code[] buildCodeAttrs(List&lt;Class.Method&gt; methods) {</b>
<i>1348</i>&nbsp;        List&lt;Code&gt; codes = new ArrayList&lt;&gt;(methods.size());
<i>1349</i>&nbsp;        for (Class.Method m : methods) {
<i>1350</i>&nbsp;            if (m.getAttribute(attrCodeEmpty) != null) {
<i>1351</i>&nbsp;                m.code = new Code(m);
<b class="nc"><i>1352</i>&nbsp;                codes.add(m.code);</b>
<i>1353</i>&nbsp;            }
<i>1354</i>&nbsp;        }
<b class="nc"><i>1355</i>&nbsp;        Code[] a = new Code[codes.size()];</b>
<b class="nc"><i>1356</i>&nbsp;        codes.toArray(a);</b>
<b class="nc"><i>1357</i>&nbsp;        return a;</b>
<b class="nc"><i>1358</i>&nbsp;    }</b>
<b class="nc"><i>1359</i>&nbsp;</b>
<i>1360</i>&nbsp;    void readCodeHeaders() throws IOException {
<b class="nc"><i>1361</i>&nbsp;        //  code_bands:</b>
<b class="nc"><i>1362</i>&nbsp;        //        *code_headers :BYTE1</b>
<b class="nc"><i>1363</i>&nbsp;        //</b>
<b class="nc"><i>1364</i>&nbsp;        //        *code_max_stack :UNSIGNED5</b>
<i>1365</i>&nbsp;        //        *code_max_na_locals :UNSIGNED5
<i>1366</i>&nbsp;        //        *code_handler_count :UNSIGNED5
<i>1367</i>&nbsp;        //        ...
<i>1368</i>&nbsp;        //        code_attr_bands
<i>1369</i>&nbsp;        boolean attrsOK = testBit(archiveOptions, AO_HAVE_ALL_CODE_FLAGS);
<i>1370</i>&nbsp;        code_headers.expectLength(allCodes.length);
<i>1371</i>&nbsp;        code_headers.readFrom(in);
<i>1372</i>&nbsp;        List&lt;Code&gt; longCodes = new ArrayList&lt;&gt;(allCodes.length / 10);
<i>1373</i>&nbsp;        for (int i = 0; i &lt; allCodes.length; i++) {
<i>1374</i>&nbsp;            Code c = allCodes[i];
<i>1375</i>&nbsp;            int sc = code_headers.getByte();
<b class="nc"><i>1376</i>&nbsp;            assert(sc == (sc &amp; 0xFF));</b>
<b class="nc"><i>1377</i>&nbsp;            if (verbose &gt; 2)</b>
<b class="nc"><i>1378</i>&nbsp;                Utils.log.fine(&quot;codeHeader &quot;+c+&quot; = &quot;+sc);</b>
<b class="nc"><i>1379</i>&nbsp;            if (sc == LONG_CODE_HEADER) {</b>
<b class="nc"><i>1380</i>&nbsp;                // We will read ms/ml/nh/flags from bands shortly.</b>
<b class="nc"><i>1381</i>&nbsp;                longCodes.add(c);</b>
<b class="nc"><i>1382</i>&nbsp;                continue;</b>
<b class="nc"><i>1383</i>&nbsp;            }</b>
<b class="nc"><i>1384</i>&nbsp;            // Short code header is the usual case:</b>
<b class="nc"><i>1385</i>&nbsp;            c.setMaxStack(     shortCodeHeader_max_stack(sc) );</b>
<b class="nc"><i>1386</i>&nbsp;            c.setMaxNALocals(  shortCodeHeader_max_na_locals(sc) );</b>
<i>1387</i>&nbsp;            c.setHandlerCount( shortCodeHeader_handler_count(sc) );
<b class="nc"><i>1388</i>&nbsp;            assert(shortCodeHeader(c) == sc);</b>
<b class="nc"><i>1389</i>&nbsp;        }</b>
<i>1390</i>&nbsp;        code_headers.doneDisbursing();
<i>1391</i>&nbsp;        code_max_stack.expectLength(longCodes.size());
<b class="nc"><i>1392</i>&nbsp;        code_max_na_locals.expectLength(longCodes.size());</b>
<b class="nc"><i>1393</i>&nbsp;        code_handler_count.expectLength(longCodes.size());</b>
<b class="nc"><i>1394</i>&nbsp;</b>
<b class="nc"><i>1395</i>&nbsp;        // Do the long headers now.</b>
<i>1396</i>&nbsp;        code_max_stack.readFrom(in);
<b class="nc"><i>1397</i>&nbsp;        code_max_na_locals.readFrom(in);</b>
<b class="nc"><i>1398</i>&nbsp;        code_handler_count.readFrom(in);</b>
<b class="nc"><i>1399</i>&nbsp;        for (Code c : longCodes) {</b>
<b class="nc"><i>1400</i>&nbsp;            c.setMaxStack(     code_max_stack.getInt() );</b>
<i>1401</i>&nbsp;            c.setMaxNALocals(  code_max_na_locals.getInt() );
<i>1402</i>&nbsp;            c.setHandlerCount( code_handler_count.getInt() );
<b class="nc"><i>1403</i>&nbsp;        }</b>
<b class="nc"><i>1404</i>&nbsp;        code_max_stack.doneDisbursing();</b>
<b class="nc"><i>1405</i>&nbsp;        code_max_na_locals.doneDisbursing();</b>
<b class="nc"><i>1406</i>&nbsp;        code_handler_count.doneDisbursing();</b>
<b class="nc"><i>1407</i>&nbsp;</b>
<b class="nc"><i>1408</i>&nbsp;        readCodeHandlers();</b>
<b class="nc"><i>1409</i>&nbsp;</b>
<b class="nc"><i>1410</i>&nbsp;        if (attrsOK) {</b>
<b class="nc"><i>1411</i>&nbsp;            // Code attributes are common (debug info not stripped).</b>
<b class="nc"><i>1412</i>&nbsp;            codesWithFlags = Arrays.asList(allCodes);</b>
<b class="nc"><i>1413</i>&nbsp;        } else {</b>
<i>1414</i>&nbsp;            // Code attributes are very sparse (debug info is stripped).
<b class="nc"><i>1415</i>&nbsp;            codesWithFlags = longCodes;</b>
<i>1416</i>&nbsp;        }
<b class="nc"><i>1417</i>&nbsp;        countAttrs(ATTR_CONTEXT_CODE, codesWithFlags);</b>
<i>1418</i>&nbsp;        // do readAttrs later, after BCs are scanned
<b class="nc"><i>1419</i>&nbsp;    }</b>
<i>1420</i>&nbsp;
<i>1421</i>&nbsp;    void readCodeHandlers() throws IOException {
<b class="nc"><i>1422</i>&nbsp;        //  code_bands:</b>
<i>1423</i>&nbsp;        //        ...
<b class="nc"><i>1424</i>&nbsp;        //        *code_handler_start_P :BCI5</b>
<i>1425</i>&nbsp;        //        *code_handler_end_PO :BRANCH5
<i>1426</i>&nbsp;        //        *code_handler_catch_PO :BRANCH5
<i>1427</i>&nbsp;        //        *code_handler_class_RCN :UNSIGNED5  (null or cp_Class)
<i>1428</i>&nbsp;        //        ...
<i>1429</i>&nbsp;        int nh = 0;
<i>1430</i>&nbsp;        for (int i = 0; i &lt; allCodes.length; i++) {
<i>1431</i>&nbsp;            Code c = allCodes[i];
<i>1432</i>&nbsp;            nh += c.getHandlerCount();
<i>1433</i>&nbsp;        }
<i>1434</i>&nbsp;
<i>1435</i>&nbsp;        ValueBand[] code_handler_bands = {
<b class="nc"><i>1436</i>&nbsp;            code_handler_start_P,</b>
<b class="nc"><i>1437</i>&nbsp;            code_handler_end_PO,</b>
<b class="nc"><i>1438</i>&nbsp;            code_handler_catch_PO,</b>
<b class="nc"><i>1439</i>&nbsp;            code_handler_class_RCN</b>
<i>1440</i>&nbsp;        };
<i>1441</i>&nbsp;
<b class="nc"><i>1442</i>&nbsp;        for (int i = 0; i &lt; code_handler_bands.length; i++) {</b>
<i>1443</i>&nbsp;            code_handler_bands[i].expectLength(nh);
<i>1444</i>&nbsp;            code_handler_bands[i].readFrom(in);
<i>1445</i>&nbsp;        }
<i>1446</i>&nbsp;
<i>1447</i>&nbsp;        for (int i = 0; i &lt; allCodes.length; i++) {
<i>1448</i>&nbsp;            Code c = allCodes[i];
<b class="nc"><i>1449</i>&nbsp;            for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {</b>
<b class="nc"><i>1450</i>&nbsp;                c.handler_class[j] = code_handler_class_RCN.getRef();</b>
<b class="nc"><i>1451</i>&nbsp;                // For now, just record the raw BCI codes.</b>
<i>1452</i>&nbsp;                // We must wait until we have instruction boundaries.
<i>1453</i>&nbsp;                c.handler_start[j] = code_handler_start_P.getInt();
<b class="nc"><i>1454</i>&nbsp;                c.handler_end[j]   = code_handler_end_PO.getInt();</b>
<b class="nc"><i>1455</i>&nbsp;                c.handler_catch[j] = code_handler_catch_PO.getInt();</b>
<b class="nc"><i>1456</i>&nbsp;            }</b>
<b class="nc"><i>1457</i>&nbsp;        }</b>
<i>1458</i>&nbsp;        for (int i = 0; i &lt; code_handler_bands.length; i++) {
<i>1459</i>&nbsp;            code_handler_bands[i].doneDisbursing();
<b class="nc"><i>1460</i>&nbsp;        }</b>
<b class="nc"><i>1461</i>&nbsp;    }</b>
<b class="nc"><i>1462</i>&nbsp;</b>
<i>1463</i>&nbsp;    void fixupCodeHandlers() {
<i>1464</i>&nbsp;        // Actually decode (renumber) the BCIs now.
<b class="nc"><i>1465</i>&nbsp;        for (int i = 0; i &lt; allCodes.length; i++) {</b>
<b class="nc"><i>1466</i>&nbsp;            Code c = allCodes[i];</b>
<i>1467</i>&nbsp;            for (int j = 0, jmax = c.getHandlerCount(); j &lt; jmax; j++) {
<i>1468</i>&nbsp;                int sum = c.handler_start[j];
<i>1469</i>&nbsp;                c.handler_start[j] = c.decodeBCI(sum);
<i>1470</i>&nbsp;                sum += c.handler_end[j];
<i>1471</i>&nbsp;                c.handler_end[j]   = c.decodeBCI(sum);
<b class="nc"><i>1472</i>&nbsp;                sum += c.handler_catch[j];</b>
<b class="nc"><i>1473</i>&nbsp;                c.handler_catch[j] = c.decodeBCI(sum);</b>
<b class="nc"><i>1474</i>&nbsp;            }</b>
<b class="nc"><i>1475</i>&nbsp;        }</b>
<b class="nc"><i>1476</i>&nbsp;    }</b>
<b class="nc"><i>1477</i>&nbsp;</b>
<b class="nc"><i>1478</i>&nbsp;    // Generic routines for reading attributes of</b>
<b class="nc"><i>1479</i>&nbsp;    // classes, fields, methods, and codes.</b>
<b class="nc"><i>1480</i>&nbsp;    // The holders is a global list, already collected,</b>
<i>1481</i>&nbsp;    // of attribute &quot;customers&quot;.
<i>1482</i>&nbsp;    void countAndReadAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
<i>1483</i>&nbsp;            throws IOException {
<i>1484</i>&nbsp;        //  class_attr_bands:
<i>1485</i>&nbsp;        //        *class_flags :UNSIGNED5
<i>1486</i>&nbsp;        //        *class_attr_count :UNSIGNED5
<i>1487</i>&nbsp;        //        *class_attr_indexes :UNSIGNED5
<i>1488</i>&nbsp;        //        *class_attr_calls :UNSIGNED5
<i>1489</i>&nbsp;        //        *class_Signature_RS :UNSIGNED5 (cp_Signature)
<i>1490</i>&nbsp;        //        class_metadata_bands
<i>1491</i>&nbsp;        //        *class_SourceFile_RU :UNSIGNED5 (cp_Utf8)
<i>1492</i>&nbsp;        //        *class_EnclosingMethod_RM :UNSIGNED5 (cp_Method)
<i>1493</i>&nbsp;        //        ic_local_bands
<i>1494</i>&nbsp;        //        *class_ClassFile_version_minor_H :UNSIGNED5
<i>1495</i>&nbsp;        //        *class_ClassFile_version_major_H :UNSIGNED5
<i>1496</i>&nbsp;        //        class_type_metadata_bands
<i>1497</i>&nbsp;        //
<i>1498</i>&nbsp;        //  field_attr_bands:
<i>1499</i>&nbsp;        //        *field_flags :UNSIGNED5
<i>1500</i>&nbsp;        //        *field_attr_count :UNSIGNED5
<i>1501</i>&nbsp;        //        *field_attr_indexes :UNSIGNED5
<i>1502</i>&nbsp;        //        *field_attr_calls :UNSIGNED5
<i>1503</i>&nbsp;        //        *field_Signature_RS :UNSIGNED5 (cp_Signature)
<i>1504</i>&nbsp;        //        field_metadata_bands
<i>1505</i>&nbsp;        //        *field_ConstantValue_KQ :UNSIGNED5 (cp_Int, etc.; see note)
<i>1506</i>&nbsp;        //        field_type_metadata_bands
<i>1507</i>&nbsp;        //
<i>1508</i>&nbsp;        //  method_attr_bands:
<i>1509</i>&nbsp;        //        *method_flags :UNSIGNED5
<i>1510</i>&nbsp;        //        *method_attr_count :UNSIGNED5
<i>1511</i>&nbsp;        //        *method_attr_indexes :UNSIGNED5
<i>1512</i>&nbsp;        //        *method_attr_calls :UNSIGNED5
<i>1513</i>&nbsp;        //        *method_Signature_RS :UNSIGNED5 (cp_Signature)
<i>1514</i>&nbsp;        //        method_metadata_bands
<i>1515</i>&nbsp;        //        *method_Exceptions_N :UNSIGNED5
<i>1516</i>&nbsp;        //        *method_Exceptions_RC :UNSIGNED5  (cp_Class)
<i>1517</i>&nbsp;        //        *method_MethodParameters_NB: BYTE1
<i>1518</i>&nbsp;        //        *method_MethodParameters_RUN: UNSIGNED5 (cp_Utf8)
<i>1519</i>&nbsp;        //        *method_MethodParameters_FH:  UNSIGNED5 (flag)
<i>1520</i>&nbsp;        //        method_type_metadata_bands
<i>1521</i>&nbsp;        //
<i>1522</i>&nbsp;        //  code_attr_bands:
<i>1523</i>&nbsp;        //        *code_flags :UNSIGNED5
<i>1524</i>&nbsp;        //        *code_attr_count :UNSIGNED5
<i>1525</i>&nbsp;        //        *code_attr_indexes :UNSIGNED5
<i>1526</i>&nbsp;        //        *code_attr_calls :UNSIGNED5
<i>1527</i>&nbsp;        //        *code_LineNumberTable_N :UNSIGNED5
<i>1528</i>&nbsp;        //        *code_LineNumberTable_bci_P :BCI5
<i>1529</i>&nbsp;        //        *code_LineNumberTable_line :UNSIGNED5
<i>1530</i>&nbsp;        //        *code_LocalVariableTable_N :UNSIGNED5
<i>1531</i>&nbsp;        //        *code_LocalVariableTable_bci_P :BCI5
<i>1532</i>&nbsp;        //        *code_LocalVariableTable_span_O :BRANCH5
<i>1533</i>&nbsp;        //        *code_LocalVariableTable_name_RU :UNSIGNED5 (cp_Utf8)
<i>1534</i>&nbsp;        //        *code_LocalVariableTable_type_RS :UNSIGNED5 (cp_Signature)
<i>1535</i>&nbsp;        //        *code_LocalVariableTable_slot :UNSIGNED5
<i>1536</i>&nbsp;        //        code_type_metadata_bands
<i>1537</i>&nbsp;
<i>1538</i>&nbsp;        countAttrs(ctype, holders);
<i>1539</i>&nbsp;        readAttrs(ctype, holders);
<i>1540</i>&nbsp;    }
<i>1541</i>&nbsp;
<i>1542</i>&nbsp;    // Read flags and count the attributes that are to be placed
<i>1543</i>&nbsp;    // on the given holders.
<i>1544</i>&nbsp;    void countAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
<b class="nc"><i>1545</i>&nbsp;            throws IOException {</b>
<b class="nc"><i>1546</i>&nbsp;        // Here, xxx stands for one of class, field, method, code.</b>
<i>1547</i>&nbsp;        MultiBand xxx_attr_bands = attrBands[ctype];
<i>1548</i>&nbsp;        long flagMask = attrFlagMask[ctype];
<i>1549</i>&nbsp;        if (verbose &gt; 1) {
<i>1550</i>&nbsp;            Utils.log.fine(&quot;scanning flags and attrs for &quot;+
<i>1551</i>&nbsp;                    Attribute.contextName(ctype)+&quot;[&quot;+holders.size()+&quot;]&quot;);
<i>1552</i>&nbsp;        }
<i>1553</i>&nbsp;
<b class="nc"><i>1554</i>&nbsp;        // Fetch the attribute layout definitions which govern the bands</b>
<b class="nc"><i>1555</i>&nbsp;        // we are about to read.</b>
<b class="nc"><i>1556</i>&nbsp;        List&lt;Attribute.Layout&gt; defList = attrDefs.get(ctype);</b>
<b class="nc"><i>1557</i>&nbsp;        Attribute.Layout[] defs = new Attribute.Layout[defList.size()];</b>
<b class="nc"><i>1558</i>&nbsp;        defList.toArray(defs);</b>
<i>1559</i>&nbsp;        IntBand xxx_flags_hi = getAttrBand(xxx_attr_bands, AB_FLAGS_HI);
<i>1560</i>&nbsp;        IntBand xxx_flags_lo = getAttrBand(xxx_attr_bands, AB_FLAGS_LO);
<i>1561</i>&nbsp;        IntBand xxx_attr_count = getAttrBand(xxx_attr_bands, AB_ATTR_COUNT);
<i>1562</i>&nbsp;        IntBand xxx_attr_indexes = getAttrBand(xxx_attr_bands, AB_ATTR_INDEXES);
<b class="nc"><i>1563</i>&nbsp;        IntBand xxx_attr_calls = getAttrBand(xxx_attr_bands, AB_ATTR_CALLS);</b>
<b class="nc"><i>1564</i>&nbsp;</b>
<b class="nc"><i>1565</i>&nbsp;        // Count up the number of holders which have overflow attrs.</b>
<b class="nc"><i>1566</i>&nbsp;        int overflowMask = attrOverflowMask[ctype];</b>
<b class="nc"><i>1567</i>&nbsp;        int overflowHolderCount = 0;</b>
<b class="nc"><i>1568</i>&nbsp;        boolean haveLongFlags = haveFlagsHi(ctype);</b>
<b class="nc"><i>1569</i>&nbsp;        xxx_flags_hi.expectLength(haveLongFlags? holders.size(): 0);</b>
<b class="nc"><i>1570</i>&nbsp;        xxx_flags_hi.readFrom(in);</b>
<i>1571</i>&nbsp;        xxx_flags_lo.expectLength(holders.size());
<i>1572</i>&nbsp;        xxx_flags_lo.readFrom(in);
<b class="nc"><i>1573</i>&nbsp;        assert((flagMask &amp; overflowMask) == overflowMask);</b>
<b class="nc"><i>1574</i>&nbsp;        for (Attribute.Holder h : holders) {</b>
<b class="nc"><i>1575</i>&nbsp;            int flags = xxx_flags_lo.getInt();</b>
<b class="nc"><i>1576</i>&nbsp;            h.flags = flags;</b>
<b class="nc"><i>1577</i>&nbsp;            if ((flags &amp; overflowMask) != 0)</b>
<b class="nc"><i>1578</i>&nbsp;                overflowHolderCount += 1;</b>
<b class="nc"><i>1579</i>&nbsp;        }</b>
<b class="nc"><i>1580</i>&nbsp;</b>
<b class="nc"><i>1581</i>&nbsp;        // For each holder with overflow attrs, read a count.</b>
<b class="nc"><i>1582</i>&nbsp;        xxx_attr_count.expectLength(overflowHolderCount);</b>
<b class="nc"><i>1583</i>&nbsp;        xxx_attr_count.readFrom(in);</b>
<b class="nc"><i>1584</i>&nbsp;        xxx_attr_indexes.expectLength(xxx_attr_count.getIntTotal());</b>
<b class="nc"><i>1585</i>&nbsp;        xxx_attr_indexes.readFrom(in);</b>
<b class="nc"><i>1586</i>&nbsp;</b>
<i>1587</i>&nbsp;        // Now it&#39;s time to check flag bits that indicate attributes.
<i>1588</i>&nbsp;        // We accumulate (a) a list of attribute types for each holder
<b class="nc"><i>1589</i>&nbsp;        // (class/field/method/code), and also we accumulate (b) a total</b>
<b class="nc"><i>1590</i>&nbsp;        // count for each attribute type.</b>
<b class="nc"><i>1591</i>&nbsp;        int[] totalCounts = new int[defs.length];</b>
<b class="nc"><i>1592</i>&nbsp;        for (Attribute.Holder h : holders) {</b>
<i>1593</i>&nbsp;            assert(h.attributes == null);
<i>1594</i>&nbsp;            // System.out.println(&quot;flags=&quot;+h.flags+&quot; using fm=&quot;+flagMask);
<i>1595</i>&nbsp;            long attrBits = ((h.flags &amp; flagMask) &lt;&lt; 32) &gt;&gt;&gt; 32;
<i>1596</i>&nbsp;            // Clean up the flags now.
<i>1597</i>&nbsp;            h.flags -= (int)attrBits;   // strip attr bits
<b class="nc"><i>1598</i>&nbsp;            assert(h.flags == (char)h.flags);  // 16 bits only now</b>
<b class="nc"><i>1599</i>&nbsp;            assert((ctype != ATTR_CONTEXT_CODE) || h.flags == 0);</b>
<b class="nc"><i>1600</i>&nbsp;            if (haveLongFlags)</b>
<i>1601</i>&nbsp;                attrBits += (long)xxx_flags_hi.getInt() &lt;&lt; 32;
<b class="nc"><i>1602</i>&nbsp;            if (attrBits == 0)  continue;  // no attrs on this guy</b>
<i>1603</i>&nbsp;
<b class="nc"><i>1604</i>&nbsp;            int noa = 0;  // number of overflow attrs</b>
<b class="nc"><i>1605</i>&nbsp;            long overflowBit = (attrBits &amp; overflowMask);</b>
<b class="nc"><i>1606</i>&nbsp;            assert(overflowBit &gt;= 0);</b>
<b class="nc"><i>1607</i>&nbsp;            attrBits -= overflowBit;</b>
<b class="nc"><i>1608</i>&nbsp;            if (overflowBit != 0) {</b>
<b class="nc"><i>1609</i>&nbsp;                noa = xxx_attr_count.getInt();</b>
<i>1610</i>&nbsp;            }
<b class="nc"><i>1611</i>&nbsp;</b>
<b class="nc"><i>1612</i>&nbsp;            int nfa = 0;  // number of flag attrs</b>
<b class="nc"><i>1613</i>&nbsp;            long bits = attrBits;</b>
<b class="nc"><i>1614</i>&nbsp;            for (int ai = 0; bits != 0; ai++) {</b>
<b class="nc"><i>1615</i>&nbsp;                if ((bits &amp; (1L&lt;&lt;ai)) == 0)  continue;</b>
<b class="nc"><i>1616</i>&nbsp;                bits -= (1L&lt;&lt;ai);</b>
<i>1617</i>&nbsp;                nfa += 1;
<i>1618</i>&nbsp;            }
<b class="nc"><i>1619</i>&nbsp;            List&lt;Attribute&gt; ha = new ArrayList&lt;&gt;(nfa + noa);</b>
<b class="nc"><i>1620</i>&nbsp;            h.attributes = ha;</b>
<b class="nc"><i>1621</i>&nbsp;            bits = attrBits;  // iterate again</b>
<b class="nc"><i>1622</i>&nbsp;            for (int ai = 0; bits != 0; ai++) {</b>
<b class="nc"><i>1623</i>&nbsp;                if ((bits &amp; (1L&lt;&lt;ai)) == 0)  continue;</b>
<b class="nc"><i>1624</i>&nbsp;                bits -= (1L&lt;&lt;ai);</b>
<i>1625</i>&nbsp;                totalCounts[ai] += 1;
<b class="nc"><i>1626</i>&nbsp;                // This definition index is live in this holder.</b>
<b class="nc"><i>1627</i>&nbsp;                if (defs[ai] == null)  badAttrIndex(ai, ctype);</b>
<b class="nc"><i>1628</i>&nbsp;                Attribute canonical = defs[ai].canonicalInstance();</b>
<b class="nc"><i>1629</i>&nbsp;                ha.add(canonical);</b>
<b class="nc"><i>1630</i>&nbsp;                nfa -= 1;</b>
<b class="nc"><i>1631</i>&nbsp;            }</b>
<b class="nc"><i>1632</i>&nbsp;            assert(nfa == 0);</b>
<i>1633</i>&nbsp;            for (; noa &gt; 0; noa--) {
<b class="nc"><i>1634</i>&nbsp;                int ai = xxx_attr_indexes.getInt();</b>
<b class="nc"><i>1635</i>&nbsp;                totalCounts[ai] += 1;</b>
<b class="nc"><i>1636</i>&nbsp;                // This definition index is live in this holder.</b>
<b class="nc"><i>1637</i>&nbsp;                if (defs[ai] == null)  badAttrIndex(ai, ctype);</b>
<i>1638</i>&nbsp;                Attribute canonical = defs[ai].canonicalInstance();
<b class="nc"><i>1639</i>&nbsp;                ha.add(canonical);</b>
<b class="nc"><i>1640</i>&nbsp;            }</b>
<b class="nc"><i>1641</i>&nbsp;        }</b>
<b class="nc"><i>1642</i>&nbsp;</b>
<i>1643</i>&nbsp;        xxx_flags_hi.doneDisbursing();
<b class="nc"><i>1644</i>&nbsp;        xxx_flags_lo.doneDisbursing();</b>
<b class="nc"><i>1645</i>&nbsp;        xxx_attr_count.doneDisbursing();</b>
<b class="nc"><i>1646</i>&nbsp;        xxx_attr_indexes.doneDisbursing();</b>
<i>1647</i>&nbsp;
<b class="nc"><i>1648</i>&nbsp;        // Now each holder has a list of canonical attribute instances.</b>
<i>1649</i>&nbsp;        // For layouts with no elements, we are done.  However, for
<b class="nc"><i>1650</i>&nbsp;        // layouts with bands, we must replace each canonical (empty)</b>
<b class="nc"><i>1651</i>&nbsp;        // instance with a value-bearing one, initialized from the</b>
<b class="nc"><i>1652</i>&nbsp;        // appropriate bands.</b>
<b class="nc"><i>1653</i>&nbsp;</b>
<i>1654</i>&nbsp;        // Make a small pass to detect and read backward call counts.
<i>1655</i>&nbsp;        int callCounts = 0;
<i>1656</i>&nbsp;        for (boolean predef = true; ; predef = false) {
<i>1657</i>&nbsp;            for (int ai = 0; ai &lt; defs.length; ai++) {
<i>1658</i>&nbsp;                Attribute.Layout def = defs[ai];
<i>1659</i>&nbsp;                if (def == null)  continue;  // unused index
<i>1660</i>&nbsp;                if (predef != isPredefinedAttr(ctype, ai))
<i>1661</i>&nbsp;                    continue;  // wrong pass
<b class="nc"><i>1662</i>&nbsp;                int totalCount = totalCounts[ai];</b>
<b class="nc"><i>1663</i>&nbsp;                if (totalCount == 0)</b>
<b class="nc"><i>1664</i>&nbsp;                    continue;  // irrelevant</b>
<b class="nc"><i>1665</i>&nbsp;                Attribute.Layout.Element[] cbles = def.getCallables();</b>
<b class="nc"><i>1666</i>&nbsp;                for (int j = 0; j &lt; cbles.length; j++) {</b>
<b class="nc"><i>1667</i>&nbsp;                    assert(cbles[j].kind == Attribute.EK_CBLE);</b>
<b class="nc"><i>1668</i>&nbsp;                    if (cbles[j].flagTest(Attribute.EF_BACK))</b>
<b class="nc"><i>1669</i>&nbsp;                        callCounts += 1;</b>
<b class="nc"><i>1670</i>&nbsp;                }</b>
<b class="nc"><i>1671</i>&nbsp;            }</b>
<b class="nc"><i>1672</i>&nbsp;            if (!predef)  break;</b>
<b class="nc"><i>1673</i>&nbsp;        }</b>
<b class="nc"><i>1674</i>&nbsp;        xxx_attr_calls.expectLength(callCounts);</b>
<b class="nc"><i>1675</i>&nbsp;        xxx_attr_calls.readFrom(in);</b>
<b class="nc"><i>1676</i>&nbsp;</b>
<i>1677</i>&nbsp;        // Finally, size all the attribute bands.
<i>1678</i>&nbsp;        for (boolean predef = true; ; predef = false) {
<b class="nc"><i>1679</i>&nbsp;            for (int ai = 0; ai &lt; defs.length; ai++) {</b>
<i>1680</i>&nbsp;                Attribute.Layout def = defs[ai];
<b class="nc"><i>1681</i>&nbsp;                if (def == null)  continue;  // unused index</b>
<b class="nc"><i>1682</i>&nbsp;                if (predef != isPredefinedAttr(ctype, ai))</b>
<i>1683</i>&nbsp;                    continue;  // wrong pass
<i>1684</i>&nbsp;                int totalCount = totalCounts[ai];
<b class="nc"><i>1685</i>&nbsp;                Band[] ab = attrBandTable.get(def);</b>
<b class="nc"><i>1686</i>&nbsp;                if (def == attrInnerClassesEmpty) {</b>
<b class="nc"><i>1687</i>&nbsp;                    // Special case.</b>
<b class="nc"><i>1688</i>&nbsp;                    // Size the bands as if using the following layout:</b>
<b class="nc"><i>1689</i>&nbsp;                    //    [RCH TI[ (0)[] ()[RCNH RUNH] ]].</b>
<b class="nc"><i>1690</i>&nbsp;                    class_InnerClasses_N.expectLength(totalCount);</b>
<b class="nc"><i>1691</i>&nbsp;                    class_InnerClasses_N.readFrom(in);</b>
<b class="nc"><i>1692</i>&nbsp;                    int tupleCount = class_InnerClasses_N.getIntTotal();</b>
<b class="nc"><i>1693</i>&nbsp;                    class_InnerClasses_RC.expectLength(tupleCount);</b>
<i>1694</i>&nbsp;                    class_InnerClasses_RC.readFrom(in);
<i>1695</i>&nbsp;                    class_InnerClasses_F.expectLength(tupleCount);
<i>1696</i>&nbsp;                    class_InnerClasses_F.readFrom(in);
<b class="nc"><i>1697</i>&nbsp;                    // Drop remaining columns wherever flags are zero:</b>
<b class="nc"><i>1698</i>&nbsp;                    tupleCount -= class_InnerClasses_F.getIntCount(0);</b>
<b class="nc"><i>1699</i>&nbsp;                    class_InnerClasses_outer_RCN.expectLength(tupleCount);</b>
<b class="nc"><i>1700</i>&nbsp;                    class_InnerClasses_outer_RCN.readFrom(in);</b>
<b class="nc"><i>1701</i>&nbsp;                    class_InnerClasses_name_RUN.expectLength(tupleCount);</b>
<b class="nc"><i>1702</i>&nbsp;                    class_InnerClasses_name_RUN.readFrom(in);</b>
<b class="nc"><i>1703</i>&nbsp;                } else if (!optDebugBands &amp;&amp; totalCount == 0) {</b>
<i>1704</i>&nbsp;                    // Expect no elements at all.  Skip quickly. however if we
<b class="nc"><i>1705</i>&nbsp;                    // are debugging bands, read all bands regardless</b>
<b class="nc"><i>1706</i>&nbsp;                    for (int j = 0; j &lt; ab.length; j++) {</b>
<b class="nc"><i>1707</i>&nbsp;                        ab[j].doneWithUnusedBand();</b>
<b class="nc"><i>1708</i>&nbsp;                    }</b>
<b class="nc"><i>1709</i>&nbsp;                } else {</b>
<b class="nc"><i>1710</i>&nbsp;                    // Read these bands in sequence.</b>
<i>1711</i>&nbsp;                    boolean hasCallables = def.hasCallables();
<i>1712</i>&nbsp;                    if (!hasCallables) {
<b class="nc"><i>1713</i>&nbsp;                        readAttrBands(def.elems, totalCount, new int[0], ab);</b>
<b class="nc"><i>1714</i>&nbsp;                    } else {</b>
<i>1715</i>&nbsp;                        Attribute.Layout.Element[] cbles = def.getCallables();
<i>1716</i>&nbsp;                        // At first, record initial calls.
<i>1717</i>&nbsp;                        // Later, forward calls may also accumulate here:
<b class="nc"><i>1718</i>&nbsp;                        int[] forwardCounts = new int[cbles.length];</b>
<b class="nc"><i>1719</i>&nbsp;                        forwardCounts[0] = totalCount;</b>
<b class="nc"><i>1720</i>&nbsp;                        for (int j = 0; j &lt; cbles.length; j++) {</b>
<i>1721</i>&nbsp;                            assert(cbles[j].kind == Attribute.EK_CBLE);
<b class="nc"><i>1722</i>&nbsp;                            int entryCount = forwardCounts[j];</b>
<i>1723</i>&nbsp;                            forwardCounts[j] = -1;  // No more, please!
<i>1724</i>&nbsp;                            if (totalCount &gt; 0 &amp;&amp; cbles[j].flagTest(Attribute.EF_BACK))
<b class="nc"><i>1725</i>&nbsp;                                entryCount += xxx_attr_calls.getInt();</b>
<b class="nc"><i>1726</i>&nbsp;                            readAttrBands(cbles[j].body, entryCount, forwardCounts, ab);</b>
<b class="nc"><i>1727</i>&nbsp;                        }</b>
<b class="nc"><i>1728</i>&nbsp;                    }</b>
<b class="nc"><i>1729</i>&nbsp;                    // mark them read,  to satisfy asserts</b>
<b class="nc"><i>1730</i>&nbsp;                    if (optDebugBands &amp;&amp; totalCount == 0) {</b>
<b class="nc"><i>1731</i>&nbsp;                        for (int j = 0; j &lt; ab.length; j++) {</b>
<b class="nc"><i>1732</i>&nbsp;                            ab[j].doneDisbursing();</b>
<b class="nc"><i>1733</i>&nbsp;                        }</b>
<i>1734</i>&nbsp;                    }
<i>1735</i>&nbsp;                }
<i>1736</i>&nbsp;            }
<b class="nc"><i>1737</i>&nbsp;            if (!predef)  break;</b>
<b class="nc"><i>1738</i>&nbsp;        }</b>
<b class="nc"><i>1739</i>&nbsp;        xxx_attr_calls.doneDisbursing();</b>
<i>1740</i>&nbsp;    }
<i>1741</i>&nbsp;
<i>1742</i>&nbsp;    void badAttrIndex(int ai, int ctype) throws IOException {
<i>1743</i>&nbsp;        throw new IOException(&quot;Unknown attribute index &quot;+ai+&quot; for &quot;+
<b class="nc"><i>1744</i>&nbsp;                                   ATTR_CONTEXT_NAME[ctype]+&quot; attribute&quot;);</b>
<i>1745</i>&nbsp;    }
<b class="nc"><i>1746</i>&nbsp;</b>
<i>1747</i>&nbsp;    void readAttrs(int ctype, Collection&lt;? extends Attribute.Holder&gt; holders)
<i>1748</i>&nbsp;            throws IOException {
<i>1749</i>&nbsp;        // Decode band values into attributes.
<b class="nc"><i>1750</i>&nbsp;        Set&lt;Attribute.Layout&gt; sawDefs = new HashSet&lt;&gt;();</b>
<i>1751</i>&nbsp;        ByteArrayOutputStream buf = new ByteArrayOutputStream();
<i>1752</i>&nbsp;        for (final Attribute.Holder h : holders) {
<i>1753</i>&nbsp;            if (h.attributes == null)  continue;
<i>1754</i>&nbsp;            for (ListIterator&lt;Attribute&gt; j = h.attributes.listIterator(); j.hasNext(); ) {
<i>1755</i>&nbsp;                Attribute a = j.next();
<i>1756</i>&nbsp;                Attribute.Layout def = a.layout();
<b class="nc"><i>1757</i>&nbsp;                if (def.bandCount == 0) {</b>
<b class="nc"><i>1758</i>&nbsp;                    if (def == attrInnerClassesEmpty) {</b>
<b class="nc"><i>1759</i>&nbsp;                        // Special logic to read this attr.</b>
<b class="nc"><i>1760</i>&nbsp;                        readLocalInnerClasses((Class) h);</b>
<b class="nc"><i>1761</i>&nbsp;                        continue;</b>
<b class="nc"><i>1762</i>&nbsp;                    }</b>
<b class="nc"><i>1763</i>&nbsp;                    // Canonical empty attr works fine (e.g., Synthetic).</b>
<b class="nc"><i>1764</i>&nbsp;                    continue;</b>
<b class="nc"><i>1765</i>&nbsp;                }</b>
<i>1766</i>&nbsp;                sawDefs.add(def);
<b class="nc"><i>1767</i>&nbsp;                boolean isCV = (ctype == ATTR_CONTEXT_FIELD &amp;&amp; def == attrConstantValue);</b>
<b class="nc"><i>1768</i>&nbsp;                if (isCV)  setConstantValueIndex((Class.Field)h);</b>
<i>1769</i>&nbsp;                if (verbose &gt; 2)
<i>1770</i>&nbsp;                    Utils.log.fine(&quot;read &quot;+a+&quot; in &quot;+h);
<i>1771</i>&nbsp;                final Band[] ab = attrBandTable.get(def);
<i>1772</i>&nbsp;                // Read one attribute of type def from ab into a byte array.
<b class="nc"><i>1773</i>&nbsp;                buf.reset();</b>
<b class="nc"><i>1774</i>&nbsp;                Object fixups = a.unparse(new Attribute.ValueStream() {</b>
<b class="nc"><i>1775</i>&nbsp;                    public int getInt(int bandIndex) {</b>
<b class="nc"><i>1776</i>&nbsp;                        return ((IntBand) ab[bandIndex]).getInt();</b>
<b class="nc"><i>1777</i>&nbsp;                    }</b>
<b class="nc"><i>1778</i>&nbsp;                    public Entry getRef(int bandIndex) {</b>
<i>1779</i>&nbsp;                        return ((CPRefBand) ab[bandIndex]).getRef();
<b class="nc"><i>1780</i>&nbsp;                    }</b>
<b class="nc"><i>1781</i>&nbsp;                    public int decodeBCI(int bciCode) {</b>
<i>1782</i>&nbsp;                        Code code = (Code) h;
<b class="nc"><i>1783</i>&nbsp;                        return code.decodeBCI(bciCode);</b>
<i>1784</i>&nbsp;                    }
<i>1785</i>&nbsp;                }, buf);
<b class="nc"><i>1786</i>&nbsp;                // Replace the canonical attr with the one just read.</b>
<i>1787</i>&nbsp;                j.set(a.addContent(buf.toByteArray(), fixups));
<i>1788</i>&nbsp;                if (isCV)  setConstantValueIndex(null);  // clean up
<b class="nc"><i>1789</i>&nbsp;            }</b>
<b class="nc"><i>1790</i>&nbsp;        }</b>
<i>1791</i>&nbsp;
<i>1792</i>&nbsp;        // Mark the bands we just used as done disbursing.
<i>1793</i>&nbsp;        for (Attribute.Layout def : sawDefs) {
<b class="nc"><i>1794</i>&nbsp;            if (def == null)  continue;  // unused index</b>
<b class="nc"><i>1795</i>&nbsp;            Band[] ab = attrBandTable.get(def);</b>
<b class="nc"><i>1796</i>&nbsp;            for (int j = 0; j &lt; ab.length; j++) {</b>
<b class="nc"><i>1797</i>&nbsp;                ab[j].doneDisbursing();</b>
<i>1798</i>&nbsp;            }
<i>1799</i>&nbsp;        }
<b class="nc"><i>1800</i>&nbsp;</b>
<b class="nc"><i>1801</i>&nbsp;        if (ctype == ATTR_CONTEXT_CLASS) {</b>
<b class="nc"><i>1802</i>&nbsp;            class_InnerClasses_N.doneDisbursing();</b>
<b class="nc"><i>1803</i>&nbsp;            class_InnerClasses_RC.doneDisbursing();</b>
<b class="nc"><i>1804</i>&nbsp;            class_InnerClasses_F.doneDisbursing();</b>
<i>1805</i>&nbsp;            class_InnerClasses_outer_RCN.doneDisbursing();
<b class="nc"><i>1806</i>&nbsp;            class_InnerClasses_name_RUN.doneDisbursing();</b>
<i>1807</i>&nbsp;        }
<b class="nc"><i>1808</i>&nbsp;</b>
<b class="nc"><i>1809</i>&nbsp;        MultiBand xxx_attr_bands = attrBands[ctype];</b>
<b class="nc"><i>1810</i>&nbsp;        for (int i = 0; i &lt; xxx_attr_bands.size(); i++) {</b>
<b class="nc"><i>1811</i>&nbsp;            Band b = xxx_attr_bands.get(i);</b>
<b class="nc"><i>1812</i>&nbsp;            if (b instanceof MultiBand)</b>
<b class="nc"><i>1813</i>&nbsp;                b.doneDisbursing();</b>
<i>1814</i>&nbsp;        }
<i>1815</i>&nbsp;        xxx_attr_bands.doneDisbursing();
<b class="nc"><i>1816</i>&nbsp;    }</b>
<b class="nc"><i>1817</i>&nbsp;</b>
<b class="nc"><i>1818</i>&nbsp;    private</b>
<b class="nc"><i>1819</i>&nbsp;    void readAttrBands(Attribute.Layout.Element[] elems,</b>
<b class="nc"><i>1820</i>&nbsp;                       int count, int[] forwardCounts,</b>
<i>1821</i>&nbsp;                       Band[] ab)
<b class="nc"><i>1822</i>&nbsp;            throws IOException {</b>
<i>1823</i>&nbsp;        for (int i = 0; i &lt; elems.length; i++) {
<i>1824</i>&nbsp;            Attribute.Layout.Element e = elems[i];
<i>1825</i>&nbsp;            Band eBand = null;
<i>1826</i>&nbsp;            if (e.hasBand()) {
<i>1827</i>&nbsp;                eBand = ab[e.bandIndex];
<i>1828</i>&nbsp;                eBand.expectLength(count);
<i>1829</i>&nbsp;                eBand.readFrom(in);
<b class="nc"><i>1830</i>&nbsp;            }</b>
<b class="nc"><i>1831</i>&nbsp;            switch (e.kind) {</b>
<b class="nc"><i>1832</i>&nbsp;            case Attribute.EK_REPL:</b>
<b class="nc"><i>1833</i>&nbsp;                // Recursive call.</b>
<b class="nc"><i>1834</i>&nbsp;                int repCount = ((IntBand)eBand).getIntTotal();</b>
<b class="nc"><i>1835</i>&nbsp;                // Note:  getIntTotal makes an extra pass over this band.</b>
<b class="nc"><i>1836</i>&nbsp;                readAttrBands(e.body, repCount, forwardCounts, ab);</b>
<i>1837</i>&nbsp;                break;
<b class="nc"><i>1838</i>&nbsp;            case Attribute.EK_UN:</b>
<i>1839</i>&nbsp;                int remainingCount = count;
<i>1840</i>&nbsp;                for (int j = 0; j &lt; e.body.length; j++) {
<b class="nc"><i>1841</i>&nbsp;                    int caseCount;</b>
<i>1842</i>&nbsp;                    if (j == e.body.length-1) {
<b class="nc"><i>1843</i>&nbsp;                        caseCount = remainingCount;</b>
<b class="nc"><i>1844</i>&nbsp;                    } else {</b>
<i>1845</i>&nbsp;                        caseCount = 0;
<b class="nc"><i>1846</i>&nbsp;                        for (int j0 = j;</b>
<b class="nc"><i>1847</i>&nbsp;                             (j == j0)</b>
<i>1848</i>&nbsp;                             || (j &lt; e.body.length
<b class="nc"><i>1849</i>&nbsp;                                 &amp;&amp; e.body[j].flagTest(Attribute.EF_BACK));</b>
<b class="nc"><i>1850</i>&nbsp;                             j++) {</b>
<i>1851</i>&nbsp;                            caseCount += ((IntBand)eBand).getIntCount(e.body[j].value);
<b class="nc"><i>1852</i>&nbsp;                        }</b>
<b class="nc"><i>1853</i>&nbsp;                        --j;  // back up to last occurrence of this body</b>
<i>1854</i>&nbsp;                    }
<b class="nc"><i>1855</i>&nbsp;                    remainingCount -= caseCount;</b>
<b class="nc"><i>1856</i>&nbsp;                    readAttrBands(e.body[j].body, caseCount, forwardCounts, ab);</b>
<b class="nc"><i>1857</i>&nbsp;                }</b>
<b class="nc"><i>1858</i>&nbsp;                assert(remainingCount == 0);</b>
<i>1859</i>&nbsp;                break;
<b class="nc"><i>1860</i>&nbsp;            case Attribute.EK_CALL:</b>
<i>1861</i>&nbsp;                assert(e.body.length == 1);
<b class="nc"><i>1862</i>&nbsp;                assert(e.body[0].kind == Attribute.EK_CBLE);</b>
<b class="nc"><i>1863</i>&nbsp;                if (!e.flagTest(Attribute.EF_BACK)) {</b>
<i>1864</i>&nbsp;                    // Backward calls are pre-counted, but forwards are not.
<b class="nc"><i>1865</i>&nbsp;                    // Push the present count forward.</b>
<i>1866</i>&nbsp;                    assert(forwardCounts[e.value] &gt;= 0);
<i>1867</i>&nbsp;                    forwardCounts[e.value] += count;
<b class="nc"><i>1868</i>&nbsp;                }</b>
<b class="nc"><i>1869</i>&nbsp;                break;</b>
<b class="nc"><i>1870</i>&nbsp;            case Attribute.EK_CBLE:</b>
<i>1871</i>&nbsp;                assert(false);
<i>1872</i>&nbsp;                break;
<b class="nc"><i>1873</i>&nbsp;            }</b>
<b class="nc"><i>1874</i>&nbsp;        }</b>
<i>1875</i>&nbsp;    }
<i>1876</i>&nbsp;
<i>1877</i>&nbsp;    void readByteCodes() throws IOException {
<b class="nc"><i>1878</i>&nbsp;        //  bc_bands:</b>
<i>1879</i>&nbsp;        //        *bc_codes :BYTE1
<i>1880</i>&nbsp;        //        *bc_case_count :UNSIGNED5
<i>1881</i>&nbsp;        //        *bc_case_value :DELTA5
<i>1882</i>&nbsp;        //        *bc_byte :BYTE1
<i>1883</i>&nbsp;        //        *bc_short :DELTA5
<i>1884</i>&nbsp;        //        *bc_local :UNSIGNED5
<i>1885</i>&nbsp;        //        *bc_label :BRANCH5
<i>1886</i>&nbsp;        //        *bc_intref :DELTA5  (cp_Int)
<i>1887</i>&nbsp;        //        *bc_floatref :DELTA5  (cp_Float)
<i>1888</i>&nbsp;        //        *bc_longref :DELTA5  (cp_Long)
<i>1889</i>&nbsp;        //        *bc_doubleref :DELTA5  (cp_Double)
<i>1890</i>&nbsp;        //        *bc_stringref :DELTA5  (cp_String)
<i>1891</i>&nbsp;        //        *bc_classref :UNSIGNED5  (current class or cp_Class)
<i>1892</i>&nbsp;        //        *bc_fieldref :DELTA5  (cp_Field)
<i>1893</i>&nbsp;        //        *bc_methodref :UNSIGNED5  (cp_Method)
<i>1894</i>&nbsp;        //        *bc_imethodref :DELTA5  (cp_Imethod)
<i>1895</i>&nbsp;        //        *bc_thisfield :UNSIGNED5 (cp_Field, only for current class)
<i>1896</i>&nbsp;        //        *bc_superfield :UNSIGNED5 (cp_Field, only for current super)
<i>1897</i>&nbsp;        //        *bc_thismethod :UNSIGNED5 (cp_Method, only for current class)
<i>1898</i>&nbsp;        //        *bc_supermethod :UNSIGNED5 (cp_Method, only for current super)
<i>1899</i>&nbsp;        //        *bc_initref :UNSIGNED5 (cp_Field, only for most recent new)
<i>1900</i>&nbsp;        //        *bc_escref :UNSIGNED5 (cp_All)
<i>1901</i>&nbsp;        //        *bc_escrefsize :UNSIGNED5
<i>1902</i>&nbsp;        //        *bc_escsize :UNSIGNED5
<i>1903</i>&nbsp;        //        *bc_escbyte :BYTE1
<i>1904</i>&nbsp;        bc_codes.elementCountForDebug = allCodes.length;
<i>1905</i>&nbsp;        bc_codes.setInputStreamFrom(in);
<i>1906</i>&nbsp;        readByteCodeOps();  // reads from bc_codes and bc_case_count
<i>1907</i>&nbsp;        bc_codes.doneDisbursing();
<i>1908</i>&nbsp;
<i>1909</i>&nbsp;        // All the operand bands have now been sized.  Read them all in turn.
<i>1910</i>&nbsp;        Band[] operand_bands = {
<b class="nc"><i>1911</i>&nbsp;            bc_case_value,</b>
<b class="nc"><i>1912</i>&nbsp;            bc_byte, bc_short,</b>
<b class="nc"><i>1913</i>&nbsp;            bc_local, bc_label,</b>
<b class="nc"><i>1914</i>&nbsp;            bc_intref, bc_floatref,</b>
<i>1915</i>&nbsp;            bc_longref, bc_doubleref, bc_stringref,
<i>1916</i>&nbsp;            bc_loadablevalueref,
<b class="nc"><i>1917</i>&nbsp;            bc_classref, bc_fieldref,</b>
<i>1918</i>&nbsp;            bc_methodref, bc_imethodref,
<i>1919</i>&nbsp;            bc_indyref,
<i>1920</i>&nbsp;            bc_thisfield, bc_superfield,
<i>1921</i>&nbsp;            bc_thismethod, bc_supermethod,
<i>1922</i>&nbsp;            bc_initref,
<i>1923</i>&nbsp;            bc_escref, bc_escrefsize, bc_escsize
<i>1924</i>&nbsp;        };
<i>1925</i>&nbsp;        for (int i = 0; i &lt; operand_bands.length; i++) {
<i>1926</i>&nbsp;            operand_bands[i].readFrom(in);
<i>1927</i>&nbsp;        }
<i>1928</i>&nbsp;        bc_escbyte.expectLength(bc_escsize.getIntTotal());
<i>1929</i>&nbsp;        bc_escbyte.readFrom(in);
<i>1930</i>&nbsp;
<i>1931</i>&nbsp;        expandByteCodeOps();
<b class="nc"><i>1932</i>&nbsp;</b>
<b class="nc"><i>1933</i>&nbsp;        // Done fetching values from operand bands:</b>
<i>1934</i>&nbsp;        bc_case_count.doneDisbursing();
<b class="nc"><i>1935</i>&nbsp;        for (int i = 0; i &lt; operand_bands.length; i++) {</b>
<b class="nc"><i>1936</i>&nbsp;            operand_bands[i].doneDisbursing();</b>
<i>1937</i>&nbsp;        }
<b class="nc"><i>1938</i>&nbsp;        bc_escbyte.doneDisbursing();</b>
<i>1939</i>&nbsp;        bc_bands.doneDisbursing();
<i>1940</i>&nbsp;
<b class="nc"><i>1941</i>&nbsp;        // We must delay the parsing of Code attributes until we</b>
<b class="nc"><i>1942</i>&nbsp;        // have a complete model of bytecodes, for BCI encodings.</b>
<b class="nc"><i>1943</i>&nbsp;        readAttrs(ATTR_CONTEXT_CODE, codesWithFlags);</b>
<i>1944</i>&nbsp;        // Ditto for exception handlers in codes.
<b class="nc"><i>1945</i>&nbsp;        fixupCodeHandlers();</b>
<b class="nc"><i>1946</i>&nbsp;        // Now we can finish with class_bands; cf. readClasses().</b>
<i>1947</i>&nbsp;        code_bands.doneDisbursing();
<i>1948</i>&nbsp;        class_bands.doneDisbursing();
<i>1949</i>&nbsp;    }
<b class="nc"><i>1950</i>&nbsp;</b>
<i>1951</i>&nbsp;    private void readByteCodeOps() throws IOException {
<b class="nc"><i>1952</i>&nbsp;        // scratch buffer for collecting code::</b>
<i>1953</i>&nbsp;        byte[] buf = new byte[1&lt;&lt;12];
<b class="nc"><i>1954</i>&nbsp;        // record of all switch opcodes (these are variable-length)</b>
<b class="nc"><i>1955</i>&nbsp;        List&lt;Integer&gt; allSwitchOps = new ArrayList&lt;&gt;();</b>
<i>1956</i>&nbsp;        for (int k = 0; k &lt; allCodes.length; k++) {
<i>1957</i>&nbsp;            Code c = allCodes[k];
<i>1958</i>&nbsp;        scanOneMethod:
<i>1959</i>&nbsp;            for (int i = 0; ; i++) {
<b class="nc"><i>1960</i>&nbsp;                int bc = bc_codes.getByte();</b>
<i>1961</i>&nbsp;                if (i + 10 &gt; buf.length)  buf = realloc(buf);
<b class="nc"><i>1962</i>&nbsp;                buf[i] = (byte)bc;</b>
<b class="nc"><i>1963</i>&nbsp;                boolean isWide = false;</b>
<b class="nc"><i>1964</i>&nbsp;                if (bc == _wide) {</b>
<i>1965</i>&nbsp;                    bc = bc_codes.getByte();
<b class="nc"><i>1966</i>&nbsp;                    buf[++i] = (byte)bc;</b>
<b class="nc"><i>1967</i>&nbsp;                    isWide = true;</b>
<b class="nc"><i>1968</i>&nbsp;                }</b>
<b class="nc"><i>1969</i>&nbsp;                assert(bc == (0xFF &amp; bc));</b>
<b class="nc"><i>1970</i>&nbsp;                // Adjust expectations of various band sizes.</b>
<b class="nc"><i>1971</i>&nbsp;                switch (bc) {</b>
<b class="nc"><i>1972</i>&nbsp;                case _tableswitch:</b>
<b class="nc"><i>1973</i>&nbsp;                case _lookupswitch:</b>
<b class="nc"><i>1974</i>&nbsp;                    bc_case_count.expectMoreLength(1);</b>
<i>1975</i>&nbsp;                    allSwitchOps.add(bc);
<b class="nc"><i>1976</i>&nbsp;                    break;</b>
<i>1977</i>&nbsp;                case _iinc:
<b class="nc"><i>1978</i>&nbsp;                    bc_local.expectMoreLength(1);</b>
<i>1979</i>&nbsp;                    if (isWide)
<i>1980</i>&nbsp;                        bc_short.expectMoreLength(1);
<b class="nc"><i>1981</i>&nbsp;                    else</b>
<b class="nc"><i>1982</i>&nbsp;                        bc_byte.expectMoreLength(1);</b>
<b class="nc"><i>1983</i>&nbsp;                    break;</b>
<i>1984</i>&nbsp;                case _sipush:
<b class="nc"><i>1985</i>&nbsp;                    bc_short.expectMoreLength(1);</b>
<b class="nc"><i>1986</i>&nbsp;                    break;</b>
<b class="nc"><i>1987</i>&nbsp;                case _bipush:</b>
<i>1988</i>&nbsp;                    bc_byte.expectMoreLength(1);
<b class="nc"><i>1989</i>&nbsp;                    break;</b>
<b class="nc"><i>1990</i>&nbsp;                case _newarray:</b>
<i>1991</i>&nbsp;                    bc_byte.expectMoreLength(1);
<b class="nc"><i>1992</i>&nbsp;                    break;</b>
<b class="nc"><i>1993</i>&nbsp;                case _multianewarray:</b>
<i>1994</i>&nbsp;                    assert(getCPRefOpBand(bc) == bc_classref);
<b class="nc"><i>1995</i>&nbsp;                    bc_classref.expectMoreLength(1);</b>
<b class="nc"><i>1996</i>&nbsp;                    bc_byte.expectMoreLength(1);</b>
<i>1997</i>&nbsp;                    break;
<b class="nc"><i>1998</i>&nbsp;                case _ref_escape:</b>
<b class="nc"><i>1999</i>&nbsp;                    bc_escrefsize.expectMoreLength(1);</b>
<i>2000</i>&nbsp;                    bc_escref.expectMoreLength(1);
<b class="nc"><i>2001</i>&nbsp;                    break;</b>
<b class="nc"><i>2002</i>&nbsp;                case _byte_escape:</b>
<b class="nc"><i>2003</i>&nbsp;                    bc_escsize.expectMoreLength(1);</b>
<b class="nc"><i>2004</i>&nbsp;                    // bc_escbyte will have to be counted too</b>
<i>2005</i>&nbsp;                    break;
<b class="nc"><i>2006</i>&nbsp;                default:</b>
<b class="nc"><i>2007</i>&nbsp;                    if (Instruction.isInvokeInitOp(bc)) {</b>
<b class="nc"><i>2008</i>&nbsp;                        bc_initref.expectMoreLength(1);</b>
<i>2009</i>&nbsp;                        break;
<b class="nc"><i>2010</i>&nbsp;                    }</b>
<i>2011</i>&nbsp;                    if (Instruction.isSelfLinkerOp(bc)) {
<b class="nc"><i>2012</i>&nbsp;                        CPRefBand bc_which = selfOpRefBand(bc);</b>
<i>2013</i>&nbsp;                        bc_which.expectMoreLength(1);
<b class="nc"><i>2014</i>&nbsp;                        break;</b>
<b class="nc"><i>2015</i>&nbsp;                    }</b>
<b class="nc"><i>2016</i>&nbsp;                    if (Instruction.isBranchOp(bc)) {</b>
<i>2017</i>&nbsp;                        bc_label.expectMoreLength(1);
<b class="nc"><i>2018</i>&nbsp;                        break;</b>
<b class="nc"><i>2019</i>&nbsp;                    }</b>
<b class="nc"><i>2020</i>&nbsp;                    if (Instruction.isCPRefOp(bc)) {</b>
<b class="nc"><i>2021</i>&nbsp;                        CPRefBand bc_which = getCPRefOpBand(bc);</b>
<i>2022</i>&nbsp;                        bc_which.expectMoreLength(1);
<b class="nc"><i>2023</i>&nbsp;                        assert(bc != _multianewarray);  // handled elsewhere</b>
<b class="nc"><i>2024</i>&nbsp;                        break;</b>
<b class="nc"><i>2025</i>&nbsp;                    }</b>
<i>2026</i>&nbsp;                    if (Instruction.isLocalSlotOp(bc)) {
<b class="nc"><i>2027</i>&nbsp;                        bc_local.expectMoreLength(1);</b>
<b class="nc"><i>2028</i>&nbsp;                        break;</b>
<b class="nc"><i>2029</i>&nbsp;                    }</b>
<b class="nc"><i>2030</i>&nbsp;                    break;</b>
<i>2031</i>&nbsp;                case _end_marker:
<i>2032</i>&nbsp;                    {
<b class="nc"><i>2033</i>&nbsp;                        // Transfer from buf to a more permanent place:</b>
<b class="nc"><i>2034</i>&nbsp;                        c.bytes = realloc(buf, i);</b>
<b class="nc"><i>2035</i>&nbsp;                        break scanOneMethod;</b>
<i>2036</i>&nbsp;                    }
<i>2037</i>&nbsp;                }
<i>2038</i>&nbsp;            }
<i>2039</i>&nbsp;        }
<i>2040</i>&nbsp;
<b class="nc"><i>2041</i>&nbsp;        // To size instruction bands correctly, we need info on switches:</b>
<b class="nc"><i>2042</i>&nbsp;        bc_case_count.readFrom(in);</b>
<i>2043</i>&nbsp;        for (Integer i : allSwitchOps) {
<i>2044</i>&nbsp;            int bc = i.intValue();
<i>2045</i>&nbsp;            int caseCount = bc_case_count.getInt();
<i>2046</i>&nbsp;            bc_label.expectMoreLength(1+caseCount); // default label + cases
<i>2047</i>&nbsp;            bc_case_value.expectMoreLength(bc == _tableswitch ? 1 : caseCount);
<i>2048</i>&nbsp;        }
<b class="nc"><i>2049</i>&nbsp;        bc_case_count.resetForSecondPass();</b>
<b class="nc"><i>2050</i>&nbsp;    }</b>
<b class="nc"><i>2051</i>&nbsp;</b>
<b class="nc"><i>2052</i>&nbsp;    private void expandByteCodeOps() throws IOException {</b>
<b class="nc"><i>2053</i>&nbsp;        // scratch buffer for collecting code:</b>
<b class="nc"><i>2054</i>&nbsp;        byte[] buf = new byte[1&lt;&lt;12];</b>
<b class="nc"><i>2055</i>&nbsp;        // scratch buffer for collecting instruction boundaries:</b>
<b class="nc"><i>2056</i>&nbsp;        int[] insnMap = new int[1&lt;&lt;12];</b>
<i>2057</i>&nbsp;        // list of label carriers, for label decoding post-pass:
<i>2058</i>&nbsp;        int[] labels = new int[1&lt;&lt;10];
<i>2059</i>&nbsp;        // scratch buffer for registering CP refs:
<i>2060</i>&nbsp;        Fixups fixupBuf = new Fixups();
<b class="nc"><i>2061</i>&nbsp;</b>
<i>2062</i>&nbsp;        for (int k = 0; k &lt; allCodes.length; k++) {
<b class="nc"><i>2063</i>&nbsp;            Code code = allCodes[k];</b>
<i>2064</i>&nbsp;            byte[] codeOps = code.bytes;
<b class="nc"><i>2065</i>&nbsp;            code.bytes = null;  // just for now, while we accumulate bits</b>
<i>2066</i>&nbsp;
<b class="nc"><i>2067</i>&nbsp;            Class curClass = code.thisClass();</b>
<i>2068</i>&nbsp;
<b class="nc"><i>2069</i>&nbsp;            Set&lt;Entry&gt; ldcRefSet = ldcRefMap.get(curClass);</b>
<b class="nc"><i>2070</i>&nbsp;            if (ldcRefSet == null)</b>
<b class="nc"><i>2071</i>&nbsp;                ldcRefMap.put(curClass, ldcRefSet = new HashSet&lt;&gt;());</b>
<b class="nc"><i>2072</i>&nbsp;</b>
<i>2073</i>&nbsp;            ClassEntry thisClass  = curClass.thisClass;
<b class="nc"><i>2074</i>&nbsp;            ClassEntry superClass = curClass.superClass;</b>
<i>2075</i>&nbsp;            ClassEntry newClass   = null;  // class of last _new opcode
<b class="nc"><i>2076</i>&nbsp;</b>
<b class="nc"><i>2077</i>&nbsp;            int pc = 0;  // fill pointer in buf; actual bytecode PC</b>
<b class="nc"><i>2078</i>&nbsp;            int numInsns = 0;</b>
<i>2079</i>&nbsp;            int numLabels = 0;
<b class="nc"><i>2080</i>&nbsp;            boolean hasEscs = false;</b>
<b class="nc"><i>2081</i>&nbsp;            fixupBuf.clear();</b>
<b class="nc"><i>2082</i>&nbsp;            for (int i = 0; i &lt; codeOps.length; i++) {</b>
<i>2083</i>&nbsp;                int bc = Instruction.getByte(codeOps, i);
<b class="nc"><i>2084</i>&nbsp;                int curPC = pc;</b>
<b class="nc"><i>2085</i>&nbsp;                insnMap[numInsns++] = curPC;</b>
<b class="nc"><i>2086</i>&nbsp;                if (pc + 10 &gt; buf.length)  buf = realloc(buf);</b>
<b class="nc"><i>2087</i>&nbsp;                if (numInsns+10 &gt; insnMap.length)  insnMap = realloc(insnMap);</b>
<b class="nc"><i>2088</i>&nbsp;                if (numLabels+10 &gt; labels.length)  labels = realloc(labels);</b>
<b class="nc"><i>2089</i>&nbsp;                boolean isWide = false;</b>
<b class="nc"><i>2090</i>&nbsp;                if (bc == _wide) {</b>
<b class="nc"><i>2091</i>&nbsp;                    buf[pc++] = (byte) bc;</b>
<b class="nc"><i>2092</i>&nbsp;                    bc = Instruction.getByte(codeOps, ++i);</b>
<b class="nc"><i>2093</i>&nbsp;                    isWide = true;</b>
<b class="nc"><i>2094</i>&nbsp;                }</b>
<b class="nc"><i>2095</i>&nbsp;                switch (bc) {</b>
<b class="nc"><i>2096</i>&nbsp;                case _tableswitch: // apc:  (df, lo, hi, (hi-lo+1)*(label))</b>
<b class="nc"><i>2097</i>&nbsp;                case _lookupswitch: // apc:  (df, nc, nc*(case, label))</b>
<b class="nc"><i>2098</i>&nbsp;                    {</b>
<b class="nc"><i>2099</i>&nbsp;                        int caseCount = bc_case_count.getInt();</b>
<b class="nc"><i>2100</i>&nbsp;                        while ((pc + 30 + caseCount*8) &gt; buf.length)</b>
<i>2101</i>&nbsp;                            buf = realloc(buf);
<b class="nc"><i>2102</i>&nbsp;                        buf[pc++] = (byte) bc;</b>
<i>2103</i>&nbsp;                        //initialize apc, df, lo, hi bytes to reasonable bits:
<i>2104</i>&nbsp;                        Arrays.fill(buf, pc, pc+30, (byte)0);
<i>2105</i>&nbsp;                        Instruction.Switch isw = (Instruction.Switch)
<b class="nc"><i>2106</i>&nbsp;                            Instruction.at(buf, curPC);</b>
<b class="nc"><i>2107</i>&nbsp;                        //isw.setDefaultLabel(getLabel(bc_label, code, curPC));</b>
<b class="nc"><i>2108</i>&nbsp;                        isw.setCaseCount(caseCount);</b>
<b class="nc"><i>2109</i>&nbsp;                        if (bc == _tableswitch) {</b>
<i>2110</i>&nbsp;                            isw.setCaseValue(0, bc_case_value.getInt());
<b class="nc"><i>2111</i>&nbsp;                        } else {</b>
<b class="nc"><i>2112</i>&nbsp;                            for (int j = 0; j &lt; caseCount; j++) {</b>
<b class="nc"><i>2113</i>&nbsp;                                isw.setCaseValue(j, bc_case_value.getInt());</b>
<i>2114</i>&nbsp;                            }
<b class="nc"><i>2115</i>&nbsp;                        }</b>
<b class="nc"><i>2116</i>&nbsp;                        // Make our getLabel calls later.</b>
<b class="nc"><i>2117</i>&nbsp;                        labels[numLabels++] = curPC;</b>
<i>2118</i>&nbsp;                        pc = isw.getNextPC();
<b class="nc"><i>2119</i>&nbsp;                        continue;</b>
<b class="nc"><i>2120</i>&nbsp;                    }</b>
<i>2121</i>&nbsp;                case _iinc:
<i>2122</i>&nbsp;                    {
<i>2123</i>&nbsp;                        buf[pc++] = (byte) bc;
<b class="nc"><i>2124</i>&nbsp;                        int local = bc_local.getInt();</b>
<b class="nc"><i>2125</i>&nbsp;                        int delta;</b>
<b class="nc"><i>2126</i>&nbsp;                        if (isWide) {</b>
<i>2127</i>&nbsp;                            delta = bc_short.getInt();
<i>2128</i>&nbsp;                            Instruction.setShort(buf, pc, local); pc += 2;
<i>2129</i>&nbsp;                            Instruction.setShort(buf, pc, delta); pc += 2;
<b class="nc"><i>2130</i>&nbsp;                        } else {</b>
<b class="nc"><i>2131</i>&nbsp;                            delta = (byte) bc_byte.getByte();</b>
<i>2132</i>&nbsp;                            buf[pc++] = (byte)local;
<b class="nc"><i>2133</i>&nbsp;                            buf[pc++] = (byte)delta;</b>
<b class="nc"><i>2134</i>&nbsp;                        }</b>
<b class="nc"><i>2135</i>&nbsp;                        continue;</b>
<b class="nc"><i>2136</i>&nbsp;                    }</b>
<i>2137</i>&nbsp;                case _sipush:
<b class="nc"><i>2138</i>&nbsp;                    {</b>
<b class="nc"><i>2139</i>&nbsp;                        int val = bc_short.getInt();</b>
<b class="nc"><i>2140</i>&nbsp;                        buf[pc++] = (byte) bc;</b>
<i>2141</i>&nbsp;                        Instruction.setShort(buf, pc, val); pc += 2;
<b class="nc"><i>2142</i>&nbsp;                        continue;</b>
<i>2143</i>&nbsp;                    }
<i>2144</i>&nbsp;                case _bipush:
<i>2145</i>&nbsp;                case _newarray:
<b class="nc"><i>2146</i>&nbsp;                    {</b>
<b class="nc"><i>2147</i>&nbsp;                        int val = bc_byte.getByte();</b>
<b class="nc"><i>2148</i>&nbsp;                        buf[pc++] = (byte) bc;</b>
<b class="nc"><i>2149</i>&nbsp;                        buf[pc++] = (byte) val;</b>
<i>2150</i>&nbsp;                        continue;
<i>2151</i>&nbsp;                    }
<i>2152</i>&nbsp;                case _ref_escape:
<i>2153</i>&nbsp;                    {
<b class="nc"><i>2154</i>&nbsp;                        // Note that insnMap has one entry for this.</b>
<b class="nc"><i>2155</i>&nbsp;                        hasEscs = true;</b>
<b class="nc"><i>2156</i>&nbsp;                        int size = bc_escrefsize.getInt();</b>
<b class="nc"><i>2157</i>&nbsp;                        Entry ref = bc_escref.getRef();</b>
<i>2158</i>&nbsp;                        if (size == 1)  ldcRefSet.add(ref);
<i>2159</i>&nbsp;                        int fmt;
<i>2160</i>&nbsp;                        switch (size) {
<i>2161</i>&nbsp;                        case 1: fixupBuf.addU1(pc, ref); break;
<b class="nc"><i>2162</i>&nbsp;                        case 2: fixupBuf.addU2(pc, ref); break;</b>
<b class="nc"><i>2163</i>&nbsp;                        default: assert(false); fmt = 0;</b>
<b class="nc"><i>2164</i>&nbsp;                        }</b>
<b class="nc"><i>2165</i>&nbsp;                        buf[pc+0] = buf[pc+1] = 0;</b>
<i>2166</i>&nbsp;                        pc += size;
<b class="nc"><i>2167</i>&nbsp;                    }</b>
<b class="nc"><i>2168</i>&nbsp;                    continue;</b>
<b class="nc"><i>2169</i>&nbsp;                case _byte_escape:</b>
<b class="nc"><i>2170</i>&nbsp;                    {</b>
<i>2171</i>&nbsp;                        // Note that insnMap has one entry for all these bytes.
<b class="nc"><i>2172</i>&nbsp;                        hasEscs = true;</b>
<b class="nc"><i>2173</i>&nbsp;                        int size = bc_escsize.getInt();</b>
<i>2174</i>&nbsp;                        while ((pc + size) &gt; buf.length)
<b class="nc"><i>2175</i>&nbsp;                            buf = realloc(buf);</b>
<i>2176</i>&nbsp;                        while (size-- &gt; 0) {
<i>2177</i>&nbsp;                            buf[pc++] = (byte) bc_escbyte.getByte();
<i>2178</i>&nbsp;                        }
<b class="nc"><i>2179</i>&nbsp;                    }</b>
<b class="nc"><i>2180</i>&nbsp;                    continue;</b>
<b class="nc"><i>2181</i>&nbsp;                default:</b>
<b class="nc"><i>2182</i>&nbsp;                    if (Instruction.isInvokeInitOp(bc)) {</b>
<b class="nc"><i>2183</i>&nbsp;                        int idx = (bc - _invokeinit_op);</b>
<b class="nc"><i>2184</i>&nbsp;                        int origBC = _invokespecial;</b>
<i>2185</i>&nbsp;                        ClassEntry classRef;
<i>2186</i>&nbsp;                        switch (idx) {
<b class="nc"><i>2187</i>&nbsp;                        case _invokeinit_self_option:</b>
<i>2188</i>&nbsp;                            classRef = thisClass; break;
<b class="nc"><i>2189</i>&nbsp;                        case _invokeinit_super_option:</b>
<b class="nc"><i>2190</i>&nbsp;                            classRef = superClass; break;</b>
<b class="nc"><i>2191</i>&nbsp;                        default:</b>
<i>2192</i>&nbsp;                            assert(idx == _invokeinit_new_option);
<b class="nc"><i>2193</i>&nbsp;                            classRef = newClass; break;</b>
<i>2194</i>&nbsp;                        }
<b class="nc"><i>2195</i>&nbsp;                        buf[pc++] = (byte) origBC;</b>
<i>2196</i>&nbsp;                        int coding = bc_initref.getInt();
<b class="nc"><i>2197</i>&nbsp;                        // Find the nth overloading of &lt;init&gt; in classRef.</b>
<i>2198</i>&nbsp;                        MemberEntry ref = pkg.cp.getOverloadingForIndex(CONSTANT_Methodref, classRef, &quot;&lt;init&gt;&quot;, coding);
<b class="nc"><i>2199</i>&nbsp;                        fixupBuf.addU2(pc, ref);</b>
<b class="nc"><i>2200</i>&nbsp;                        buf[pc+0] = buf[pc+1] = 0;</b>
<i>2201</i>&nbsp;                        pc += 2;
<b class="nc"><i>2202</i>&nbsp;                        assert(Instruction.opLength(origBC) == (pc - curPC));</b>
<b class="nc"><i>2203</i>&nbsp;                        continue;</b>
<i>2204</i>&nbsp;                    }
<b class="nc"><i>2205</i>&nbsp;                    if (Instruction.isSelfLinkerOp(bc)) {</b>
<b class="nc"><i>2206</i>&nbsp;                        int idx = (bc - _self_linker_op);</b>
<b class="nc"><i>2207</i>&nbsp;                        boolean isSuper = (idx &gt;= _self_linker_super_flag);</b>
<b class="nc"><i>2208</i>&nbsp;                        if (isSuper)  idx -= _self_linker_super_flag;</b>
<b class="nc"><i>2209</i>&nbsp;                        boolean isAload = (idx &gt;= _self_linker_aload_flag);</b>
<i>2210</i>&nbsp;                        if (isAload)  idx -= _self_linker_aload_flag;
<i>2211</i>&nbsp;                        int origBC = _first_linker_op + idx;
<b class="nc"><i>2212</i>&nbsp;                        boolean isField = Instruction.isFieldOp(origBC);</b>
<b class="nc"><i>2213</i>&nbsp;                        CPRefBand bc_which;</b>
<b class="nc"><i>2214</i>&nbsp;                        ClassEntry which_cls  = isSuper ? superClass : thisClass;</b>
<b class="nc"><i>2215</i>&nbsp;                        Index which_ix;</b>
<b class="nc"><i>2216</i>&nbsp;                        if (isField) {</b>
<b class="nc"><i>2217</i>&nbsp;                            bc_which = isSuper ? bc_superfield  : bc_thisfield;</b>
<b class="nc"><i>2218</i>&nbsp;                            which_ix = pkg.cp.getMemberIndex(CONSTANT_Fieldref, which_cls);</b>
<b class="nc"><i>2219</i>&nbsp;                        } else {</b>
<i>2220</i>&nbsp;                            bc_which = isSuper ? bc_supermethod : bc_thismethod;
<b class="nc"><i>2221</i>&nbsp;                            which_ix = pkg.cp.getMemberIndex(CONSTANT_Methodref, which_cls);</b>
<i>2222</i>&nbsp;                        }
<b class="nc"><i>2223</i>&nbsp;                        assert(bc_which == selfOpRefBand(bc));</b>
<b class="nc"><i>2224</i>&nbsp;                        MemberEntry ref = (MemberEntry) bc_which.getRef(which_ix);</b>
<b class="nc"><i>2225</i>&nbsp;                        if (isAload) {</b>
<i>2226</i>&nbsp;                            buf[pc++] = (byte) _aload_0;
<b class="nc"><i>2227</i>&nbsp;                            curPC = pc;</b>
<b class="nc"><i>2228</i>&nbsp;                            // Note: insnMap keeps the _aload_0 separate.</b>
<i>2229</i>&nbsp;                            insnMap[numInsns++] = curPC;
<b class="nc"><i>2230</i>&nbsp;                        }</b>
<b class="nc"><i>2231</i>&nbsp;                        buf[pc++] = (byte) origBC;</b>
<b class="nc"><i>2232</i>&nbsp;                        fixupBuf.addU2(pc, ref);</b>
<b class="nc"><i>2233</i>&nbsp;                        buf[pc+0] = buf[pc+1] = 0;</b>
<b class="nc"><i>2234</i>&nbsp;                        pc += 2;</b>
<i>2235</i>&nbsp;                        assert(Instruction.opLength(origBC) == (pc - curPC));
<b class="nc"><i>2236</i>&nbsp;                        continue;</b>
<i>2237</i>&nbsp;                    }
<b class="nc"><i>2238</i>&nbsp;                    if (Instruction.isBranchOp(bc)) {</b>
<b class="nc"><i>2239</i>&nbsp;                        buf[pc++] = (byte) bc;</b>
<b class="nc"><i>2240</i>&nbsp;                        assert(!isWide);  // no wide prefix for branches</b>
<b class="nc"><i>2241</i>&nbsp;                        int nextPC = curPC + Instruction.opLength(bc);</b>
<b class="nc"><i>2242</i>&nbsp;                        // Make our getLabel calls later.</b>
<i>2243</i>&nbsp;                        labels[numLabels++] = curPC;
<i>2244</i>&nbsp;                        //Instruction.at(buf, curPC).setBranchLabel(getLabel(bc_label, code, curPC));
<b class="nc"><i>2245</i>&nbsp;                        while (pc &lt; nextPC)  buf[pc++] = 0;</b>
<b class="nc"><i>2246</i>&nbsp;                        continue;</b>
<b class="nc"><i>2247</i>&nbsp;                    }</b>
<b class="nc"><i>2248</i>&nbsp;                    if (Instruction.isCPRefOp(bc)) {</b>
<i>2249</i>&nbsp;                        CPRefBand bc_which = getCPRefOpBand(bc);
<b class="nc"><i>2250</i>&nbsp;                        Entry ref = bc_which.getRef();</b>
<i>2251</i>&nbsp;                        if (ref == null) {
<b class="nc"><i>2252</i>&nbsp;                            if (bc_which == bc_classref) {</b>
<i>2253</i>&nbsp;                                // Shorthand for class self-references.
<i>2254</i>&nbsp;                                ref = thisClass;
<b class="nc"><i>2255</i>&nbsp;                            } else {</b>
<b class="nc"><i>2256</i>&nbsp;                                assert(false);</b>
<b class="nc"><i>2257</i>&nbsp;                            }</b>
<b class="nc"><i>2258</i>&nbsp;                        }</b>
<b class="nc"><i>2259</i>&nbsp;                        int origBC = bc;</b>
<i>2260</i>&nbsp;                        int size = 2;
<b class="nc"><i>2261</i>&nbsp;                        switch (bc) {</b>
<i>2262</i>&nbsp;                        case _invokestatic_int:
<b class="nc"><i>2263</i>&nbsp;                            origBC = _invokestatic;</b>
<i>2264</i>&nbsp;                            break;
<i>2265</i>&nbsp;                        case _invokespecial_int:
<b class="nc"><i>2266</i>&nbsp;                            origBC = _invokespecial;</b>
<b class="nc"><i>2267</i>&nbsp;                            break;</b>
<b class="nc"><i>2268</i>&nbsp;                        case _ildc:</b>
<i>2269</i>&nbsp;                        case _cldc:
<b class="nc"><i>2270</i>&nbsp;                        case _fldc:</b>
<b class="nc"><i>2271</i>&nbsp;                        case _sldc:</b>
<i>2272</i>&nbsp;                        case _qldc:
<b class="nc"><i>2273</i>&nbsp;                            origBC = _ldc;</b>
<b class="nc"><i>2274</i>&nbsp;                            size = 1;</b>
<i>2275</i>&nbsp;                            ldcRefSet.add(ref);
<i>2276</i>&nbsp;                            break;
<i>2277</i>&nbsp;                        case _ildc_w:
<i>2278</i>&nbsp;                        case _cldc_w:
<i>2279</i>&nbsp;                        case _fldc_w:
<b class="nc"><i>2280</i>&nbsp;                        case _sldc_w:</b>
<b class="nc"><i>2281</i>&nbsp;                        case _qldc_w:</b>
<b class="nc"><i>2282</i>&nbsp;                            origBC = _ldc_w;</b>
<b class="nc"><i>2283</i>&nbsp;                            break;</b>
<i>2284</i>&nbsp;                        case _lldc2_w:
<i>2285</i>&nbsp;                        case _dldc2_w:
<i>2286</i>&nbsp;                            origBC = _ldc2_w;
<i>2287</i>&nbsp;                            break;
<i>2288</i>&nbsp;                        case _new:
<b class="nc"><i>2289</i>&nbsp;                            newClass = (ClassEntry) ref;</b>
<b class="nc"><i>2290</i>&nbsp;                            break;</b>
<i>2291</i>&nbsp;                        }
<i>2292</i>&nbsp;                        buf[pc++] = (byte) origBC;
<b class="nc"><i>2293</i>&nbsp;                        int fmt;</b>
<b class="nc"><i>2294</i>&nbsp;                        switch (size) {</b>
<i>2295</i>&nbsp;                        case 1: fixupBuf.addU1(pc, ref); break;
<b class="nc"><i>2296</i>&nbsp;                        case 2: fixupBuf.addU2(pc, ref); break;</b>
<i>2297</i>&nbsp;                        default: assert(false); fmt = 0;
<i>2298</i>&nbsp;                        }
<b class="nc"><i>2299</i>&nbsp;                        buf[pc+0] = buf[pc+1] = 0;</b>
<i>2300</i>&nbsp;                        pc += size;
<b class="nc"><i>2301</i>&nbsp;                        if (origBC == _multianewarray) {</b>
<b class="nc"><i>2302</i>&nbsp;                            // Copy the trailing byte also.</b>
<b class="nc"><i>2303</i>&nbsp;                            int val = bc_byte.getByte();</b>
<b class="nc"><i>2304</i>&nbsp;                            buf[pc++] = (byte) val;</b>
<i>2305</i>&nbsp;                        } else if (origBC == _invokeinterface) {
<b class="nc"><i>2306</i>&nbsp;                            int argSize = ((MemberEntry)ref).descRef.typeRef.computeSize(true);</b>
<b class="nc"><i>2307</i>&nbsp;                            buf[pc++] = (byte)( 1 + argSize );</b>
<b class="nc"><i>2308</i>&nbsp;                            buf[pc++] = 0;</b>
<i>2309</i>&nbsp;                        } else if (origBC == _invokedynamic) {
<b class="nc"><i>2310</i>&nbsp;                            buf[pc++] = 0;</b>
<b class="nc"><i>2311</i>&nbsp;                            buf[pc++] = 0;</b>
<b class="nc"><i>2312</i>&nbsp;                        }</b>
<b class="nc"><i>2313</i>&nbsp;                        assert(Instruction.opLength(origBC) == (pc - curPC));</b>
<b class="nc"><i>2314</i>&nbsp;                        continue;</b>
<b class="nc"><i>2315</i>&nbsp;                    }</b>
<b class="nc"><i>2316</i>&nbsp;                    if (Instruction.isLocalSlotOp(bc)) {</b>
<b class="nc"><i>2317</i>&nbsp;                        buf[pc++] = (byte) bc;</b>
<b class="nc"><i>2318</i>&nbsp;                        int local = bc_local.getInt();</b>
<i>2319</i>&nbsp;                        if (isWide) {
<b class="nc"><i>2320</i>&nbsp;                            Instruction.setShort(buf, pc, local);</b>
<i>2321</i>&nbsp;                            pc += 2;
<i>2322</i>&nbsp;                            if (bc == _iinc) {
<b class="nc"><i>2323</i>&nbsp;                                int iVal = bc_short.getInt();</b>
<b class="nc"><i>2324</i>&nbsp;                                Instruction.setShort(buf, pc, iVal);</b>
<b class="nc"><i>2325</i>&nbsp;                                pc += 2;</b>
<b class="nc"><i>2326</i>&nbsp;                            }</b>
<b class="nc"><i>2327</i>&nbsp;                        } else {</b>
<b class="nc"><i>2328</i>&nbsp;                            Instruction.setByte(buf, pc, local);</b>
<b class="nc"><i>2329</i>&nbsp;                            pc += 1;</b>
<b class="nc"><i>2330</i>&nbsp;                            if (bc == _iinc) {</b>
<b class="nc"><i>2331</i>&nbsp;                                int iVal = bc_byte.getByte();</b>
<b class="nc"><i>2332</i>&nbsp;                                Instruction.setByte(buf, pc, iVal);</b>
<b class="nc"><i>2333</i>&nbsp;                                pc += 1;</b>
<i>2334</i>&nbsp;                            }
<b class="nc"><i>2335</i>&nbsp;                        }</b>
<b class="nc"><i>2336</i>&nbsp;                        assert(Instruction.opLength(bc) == (pc - curPC));</b>
<b class="nc"><i>2337</i>&nbsp;                        continue;</b>
<b class="nc"><i>2338</i>&nbsp;                    }</b>
<b class="nc"><i>2339</i>&nbsp;                    // Random bytecode.  Just copy it.</b>
<b class="nc"><i>2340</i>&nbsp;                    if (bc &gt;= _bytecode_limit)</b>
<i>2341</i>&nbsp;                        Utils.log.warning(&quot;unrecognized bytescode &quot;+bc
<i>2342</i>&nbsp;                                            +&quot; &quot;+Instruction.byteName(bc));
<b class="nc"><i>2343</i>&nbsp;                    assert(bc &lt; _bytecode_limit);</b>
<i>2344</i>&nbsp;                    buf[pc++] = (byte) bc;
<i>2345</i>&nbsp;                    assert(Instruction.opLength(bc) == (pc - curPC));
<i>2346</i>&nbsp;                    continue;
<b class="nc"><i>2347</i>&nbsp;                }</b>
<b class="nc"><i>2348</i>&nbsp;            }</b>
<b class="nc"><i>2349</i>&nbsp;            // now make a permanent copy of the bytecodes</b>
<b class="nc"><i>2350</i>&nbsp;            code.setBytes(realloc(buf, pc));</b>
<b class="nc"><i>2351</i>&nbsp;            code.setInstructionMap(insnMap, numInsns);</b>
<b class="nc"><i>2352</i>&nbsp;            // fix up labels, now that code has its insnMap</b>
<i>2353</i>&nbsp;            Instruction ibr = null;  // temporary branch instruction
<i>2354</i>&nbsp;            for (int i = 0; i &lt; numLabels; i++) {
<i>2355</i>&nbsp;                int curPC = labels[i];
<i>2356</i>&nbsp;                // (Note:  Passing ibr in allows reuse, a speed hack.)
<b class="nc"><i>2357</i>&nbsp;                ibr = Instruction.at(code.bytes, curPC, ibr);</b>
<b class="nc"><i>2358</i>&nbsp;                if (ibr instanceof Instruction.Switch) {</b>
<i>2359</i>&nbsp;                    Instruction.Switch isw = (Instruction.Switch) ibr;
<b class="nc"><i>2360</i>&nbsp;                    isw.setDefaultLabel(getLabel(bc_label, code, curPC));</b>
<b class="nc"><i>2361</i>&nbsp;                    int caseCount = isw.getCaseCount();</b>
<b class="nc"><i>2362</i>&nbsp;                    for (int j = 0; j &lt; caseCount; j++) {</b>
<i>2363</i>&nbsp;                        isw.setCaseLabel(j, getLabel(bc_label, code, curPC));
<b class="nc"><i>2364</i>&nbsp;                    }</b>
<b class="nc"><i>2365</i>&nbsp;                } else {</b>
<b class="nc"><i>2366</i>&nbsp;                    ibr.setBranchLabel(getLabel(bc_label, code, curPC));</b>
<b class="nc"><i>2367</i>&nbsp;                }</b>
<b class="nc"><i>2368</i>&nbsp;            }</b>
<b class="nc"><i>2369</i>&nbsp;            if (fixupBuf.size() &gt; 0) {</b>
<b class="nc"><i>2370</i>&nbsp;                if (verbose &gt; 2)</b>
<i>2371</i>&nbsp;                    Utils.log.fine(&quot;Fixups in code: &quot;+fixupBuf);
<b class="nc"><i>2372</i>&nbsp;                code.addFixups(fixupBuf);</b>
<b class="nc"><i>2373</i>&nbsp;            }</b>
<i>2374</i>&nbsp;        }
<i>2375</i>&nbsp;    }
<b class="nc"><i>2376</i>&nbsp;}</b>
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:11</div>
</div>
</body>
</html>
