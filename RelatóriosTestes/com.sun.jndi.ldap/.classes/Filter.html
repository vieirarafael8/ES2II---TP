


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Filter</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.jndi.ldap</a> ]
</div>

<h1>Coverage Summary for Class: Filter (com.sun.jndi.ldap)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Filter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 294)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.jndi.ldap;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import javax.naming.NamingException;
<i>29</i>&nbsp;import javax.naming.directory.InvalidSearchFilterException;
<i>30</i>&nbsp;
<i>31</i>&nbsp;import java.io.IOException;
<i>32</i>&nbsp;
<i>33</i>&nbsp;/**
<i>34</i>&nbsp; * LDAP (RFC-1960) and LDAPv3 (RFC-2254) search filters.
<i>35</i>&nbsp; *
<i>36</i>&nbsp; * @author Xuelei Fan
<i>37</i>&nbsp; * @author Vincent Ryan
<i>38</i>&nbsp; * @author Jagane Sundar
<i>39</i>&nbsp; * @author Rosanna Lee
<i>40</i>&nbsp; */
<i>41</i>&nbsp;
<b class="nc"><i>42</i>&nbsp;final class Filter {</b>
<i>43</i>&nbsp;
<i>44</i>&nbsp;    /**
<i>45</i>&nbsp;     * First convert filter string into byte[].
<i>46</i>&nbsp;     * For LDAP v3, the conversion uses Unicode -&gt; UTF8
<i>47</i>&nbsp;     * For LDAP v2, the conversion uses Unicode -&gt; ISO 8859 (Latin-1)
<i>48</i>&nbsp;     *
<i>49</i>&nbsp;     * Then parse the byte[] as a filter, converting \hh to
<i>50</i>&nbsp;     * a single byte, and encoding the resulting filter
<i>51</i>&nbsp;     * into the supplied BER buffer
<i>52</i>&nbsp;     */
<i>53</i>&nbsp;    static void encodeFilterString(BerEncoder ber, String filterStr,
<i>54</i>&nbsp;        boolean isLdapv3) throws IOException, NamingException {
<i>55</i>&nbsp;
<b class="nc"><i>56</i>&nbsp;        if ((filterStr == null) || (filterStr.equals(&quot;&quot;))) {</b>
<b class="nc"><i>57</i>&nbsp;            throw new InvalidSearchFilterException(&quot;Empty filter&quot;);</b>
<i>58</i>&nbsp;        }
<i>59</i>&nbsp;        byte[] filter;
<i>60</i>&nbsp;        int filterLen;
<b class="nc"><i>61</i>&nbsp;        if (isLdapv3) {</b>
<b class="nc"><i>62</i>&nbsp;            filter = filterStr.getBytes(&quot;UTF8&quot;);</b>
<i>63</i>&nbsp;        } else {
<b class="nc"><i>64</i>&nbsp;            filter = filterStr.getBytes(&quot;8859_1&quot;);</b>
<i>65</i>&nbsp;        }
<b class="nc"><i>66</i>&nbsp;        filterLen = filter.length;</b>
<i>67</i>&nbsp;        if (dbg) {
<i>68</i>&nbsp;            dbgIndent = 0;
<i>69</i>&nbsp;            System.err.println(&quot;String filter: &quot; + filterStr);
<i>70</i>&nbsp;            System.err.println(&quot;size: &quot; + filterLen);
<i>71</i>&nbsp;            dprint(&quot;original: &quot;, filter, 0, filterLen);
<i>72</i>&nbsp;        }
<i>73</i>&nbsp;
<b class="nc"><i>74</i>&nbsp;        encodeFilter(ber, filter, 0, filterLen);</b>
<i>75</i>&nbsp;    }
<i>76</i>&nbsp;
<i>77</i>&nbsp;    private static void encodeFilter(BerEncoder ber, byte[] filter,
<i>78</i>&nbsp;        int filterStart, int filterEnd) throws IOException, NamingException {
<i>79</i>&nbsp;
<i>80</i>&nbsp;        if (dbg) {
<i>81</i>&nbsp;            dprint(&quot;encFilter: &quot;,  filter, filterStart, filterEnd);
<i>82</i>&nbsp;            dbgIndent++;
<i>83</i>&nbsp;        }
<i>84</i>&nbsp;
<b class="nc"><i>85</i>&nbsp;        if ((filterEnd - filterStart) &lt;= 0) {</b>
<b class="nc"><i>86</i>&nbsp;            throw new InvalidSearchFilterException(&quot;Empty filter&quot;);</b>
<i>87</i>&nbsp;        }
<i>88</i>&nbsp;
<i>89</i>&nbsp;        int nextOffset;
<i>90</i>&nbsp;        int parens, balance;
<i>91</i>&nbsp;        boolean escape;
<i>92</i>&nbsp;
<b class="nc"><i>93</i>&nbsp;        parens = 0;</b>
<i>94</i>&nbsp;
<b class="nc"><i>95</i>&nbsp;        int filtOffset[] = new int[1];</b>
<i>96</i>&nbsp;
<b class="nc"><i>97</i>&nbsp;        for (filtOffset[0] = filterStart; filtOffset[0] &lt; filterEnd;) {</b>
<b class="nc"><i>98</i>&nbsp;            switch (filter[filtOffset[0]]) {</b>
<i>99</i>&nbsp;            case &#39;(&#39;:
<b class="nc"><i>100</i>&nbsp;                filtOffset[0]++;</b>
<b class="nc"><i>101</i>&nbsp;                parens++;</b>
<b class="nc"><i>102</i>&nbsp;                switch (filter[filtOffset[0]]) {</b>
<i>103</i>&nbsp;                case &#39;&amp;&#39;:
<b class="nc"><i>104</i>&nbsp;                    encodeComplexFilter(ber, filter,</b>
<i>105</i>&nbsp;                        LDAP_FILTER_AND, filtOffset, filterEnd);
<i>106</i>&nbsp;                    // filtOffset[0] has pointed to char after right paren
<b class="nc"><i>107</i>&nbsp;                    parens--;</b>
<b class="nc"><i>108</i>&nbsp;                    break;</b>
<i>109</i>&nbsp;
<i>110</i>&nbsp;                case &#39;|&#39;:
<b class="nc"><i>111</i>&nbsp;                    encodeComplexFilter(ber, filter,</b>
<i>112</i>&nbsp;                        LDAP_FILTER_OR, filtOffset, filterEnd);
<i>113</i>&nbsp;                    // filtOffset[0] has pointed to char after right paren
<b class="nc"><i>114</i>&nbsp;                    parens--;</b>
<b class="nc"><i>115</i>&nbsp;                    break;</b>
<i>116</i>&nbsp;
<i>117</i>&nbsp;                case &#39;!&#39;:
<b class="nc"><i>118</i>&nbsp;                    encodeComplexFilter(ber, filter,</b>
<i>119</i>&nbsp;                        LDAP_FILTER_NOT, filtOffset, filterEnd);
<i>120</i>&nbsp;                    // filtOffset[0] has pointed to char after right paren
<b class="nc"><i>121</i>&nbsp;                    parens--;</b>
<b class="nc"><i>122</i>&nbsp;                    break;</b>
<i>123</i>&nbsp;
<i>124</i>&nbsp;                default:
<b class="nc"><i>125</i>&nbsp;                    balance = 1;</b>
<b class="nc"><i>126</i>&nbsp;                    escape = false;</b>
<b class="nc"><i>127</i>&nbsp;                    nextOffset = filtOffset[0];</b>
<b class="nc"><i>128</i>&nbsp;                    while (nextOffset &lt; filterEnd &amp;&amp; balance &gt; 0) {</b>
<b class="nc"><i>129</i>&nbsp;                        if (!escape) {</b>
<b class="nc"><i>130</i>&nbsp;                            if (filter[nextOffset] == &#39;(&#39;)</b>
<b class="nc"><i>131</i>&nbsp;                                balance++;</b>
<b class="nc"><i>132</i>&nbsp;                            else if (filter[nextOffset] == &#39;)&#39;)</b>
<b class="nc"><i>133</i>&nbsp;                                balance--;</b>
<i>134</i>&nbsp;                        }
<b class="nc"><i>135</i>&nbsp;                        if (filter[nextOffset] == &#39;\\&#39; &amp;&amp; !escape)</b>
<b class="nc"><i>136</i>&nbsp;                            escape = true;</b>
<i>137</i>&nbsp;                        else
<b class="nc"><i>138</i>&nbsp;                            escape = false;</b>
<b class="nc"><i>139</i>&nbsp;                        if (balance &gt; 0)</b>
<b class="nc"><i>140</i>&nbsp;                            nextOffset++;</b>
<i>141</i>&nbsp;                    }
<b class="nc"><i>142</i>&nbsp;                    if (balance != 0)</b>
<b class="nc"><i>143</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>144</i>&nbsp;                                  &quot;Unbalanced parenthesis&quot;);
<i>145</i>&nbsp;
<b class="nc"><i>146</i>&nbsp;                    encodeSimpleFilter(ber, filter, filtOffset[0], nextOffset);</b>
<i>147</i>&nbsp;
<i>148</i>&nbsp;                    // points to the char after right paren.
<b class="nc"><i>149</i>&nbsp;                    filtOffset[0] = nextOffset + 1;</b>
<i>150</i>&nbsp;
<b class="nc"><i>151</i>&nbsp;                    parens--;</b>
<b class="nc"><i>152</i>&nbsp;                    break;</b>
<i>153</i>&nbsp;
<i>154</i>&nbsp;                }
<i>155</i>&nbsp;                break;
<i>156</i>&nbsp;
<i>157</i>&nbsp;            case &#39;)&#39;:
<i>158</i>&nbsp;                //
<i>159</i>&nbsp;                // End of sequence
<i>160</i>&nbsp;                //
<b class="nc"><i>161</i>&nbsp;                ber.endSeq();</b>
<b class="nc"><i>162</i>&nbsp;                filtOffset[0]++;</b>
<b class="nc"><i>163</i>&nbsp;                parens--;</b>
<b class="nc"><i>164</i>&nbsp;                break;</b>
<i>165</i>&nbsp;
<i>166</i>&nbsp;            case &#39; &#39;:
<b class="nc"><i>167</i>&nbsp;                filtOffset[0]++;</b>
<b class="nc"><i>168</i>&nbsp;                break;</b>
<i>169</i>&nbsp;
<i>170</i>&nbsp;            default:    // assume simple type=value filter
<b class="nc"><i>171</i>&nbsp;                encodeSimpleFilter(ber, filter, filtOffset[0], filterEnd);</b>
<b class="nc"><i>172</i>&nbsp;                filtOffset[0] = filterEnd; // force break from outer</b>
<i>173</i>&nbsp;                break;
<i>174</i>&nbsp;            }
<i>175</i>&nbsp;
<b class="nc"><i>176</i>&nbsp;            if (parens &lt; 0) {</b>
<b class="nc"><i>177</i>&nbsp;                throw new InvalidSearchFilterException(</b>
<i>178</i>&nbsp;                                                &quot;Unbalanced parenthesis&quot;);
<i>179</i>&nbsp;            }
<i>180</i>&nbsp;        }
<i>181</i>&nbsp;
<b class="nc"><i>182</i>&nbsp;        if (parens != 0) {</b>
<b class="nc"><i>183</i>&nbsp;            throw new InvalidSearchFilterException(&quot;Unbalanced parenthesis&quot;);</b>
<i>184</i>&nbsp;        }
<i>185</i>&nbsp;
<i>186</i>&nbsp;        if (dbg) {
<i>187</i>&nbsp;            dbgIndent--;
<i>188</i>&nbsp;        }
<i>189</i>&nbsp;
<i>190</i>&nbsp;    }
<i>191</i>&nbsp;
<i>192</i>&nbsp;    /**
<i>193</i>&nbsp;     * convert character &#39;c&#39; that represents a hexadecimal digit to an integer.
<i>194</i>&nbsp;     * if &#39;c&#39; is not a hexadecimal digit [0-9A-Fa-f], -1 is returned.
<i>195</i>&nbsp;     * otherwise the converted value is returned.
<i>196</i>&nbsp;     */
<i>197</i>&nbsp;    private static int hexchar2int( byte c ) {
<b class="nc"><i>198</i>&nbsp;        if ( c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; ) {</b>
<b class="nc"><i>199</i>&nbsp;            return( c - &#39;0&#39; );</b>
<i>200</i>&nbsp;        }
<b class="nc"><i>201</i>&nbsp;        if ( c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39; ) {</b>
<b class="nc"><i>202</i>&nbsp;            return( c - &#39;A&#39; + 10 );</b>
<i>203</i>&nbsp;        }
<b class="nc"><i>204</i>&nbsp;        if ( c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39; ) {</b>
<b class="nc"><i>205</i>&nbsp;            return( c - &#39;a&#39; + 10 );</b>
<i>206</i>&nbsp;        }
<b class="nc"><i>207</i>&nbsp;        return( -1 );</b>
<i>208</i>&nbsp;    }
<i>209</i>&nbsp;
<i>210</i>&nbsp;    // called by the LdapClient.compare method
<i>211</i>&nbsp;    static byte[] unescapeFilterValue(byte[] orig, int start, int end)
<i>212</i>&nbsp;        throws NamingException {
<b class="nc"><i>213</i>&nbsp;        boolean escape = false, escStart = false;</b>
<i>214</i>&nbsp;        int ival;
<i>215</i>&nbsp;        byte ch;
<i>216</i>&nbsp;
<i>217</i>&nbsp;        if (dbg) {
<i>218</i>&nbsp;            dprint(&quot;unescape: &quot; , orig, start, end);
<i>219</i>&nbsp;        }
<i>220</i>&nbsp;
<b class="nc"><i>221</i>&nbsp;        int len = end - start;</b>
<b class="nc"><i>222</i>&nbsp;        byte tbuf[] = new byte[len];</b>
<b class="nc"><i>223</i>&nbsp;        int j = 0;</b>
<b class="nc"><i>224</i>&nbsp;        for (int i = start; i &lt; end; i++) {</b>
<b class="nc"><i>225</i>&nbsp;            ch = orig[i];</b>
<b class="nc"><i>226</i>&nbsp;            if (escape) {</b>
<i>227</i>&nbsp;                // Try LDAP V3 escape (\xx)
<b class="nc"><i>228</i>&nbsp;                if ((ival = hexchar2int(ch)) &lt; 0) {</b>
<i>229</i>&nbsp;
<i>230</i>&nbsp;                    /**
<i>231</i>&nbsp;                     * If there is no hex char following a &#39;\&#39; when
<i>232</i>&nbsp;                     * parsing a LDAP v3 filter (illegal by v3 way)
<i>233</i>&nbsp;                     * we fallback to the way we unescape in v2.
<i>234</i>&nbsp;                     */
<b class="nc"><i>235</i>&nbsp;                    if (escStart) {</b>
<i>236</i>&nbsp;                        // V2: \* \( \)
<b class="nc"><i>237</i>&nbsp;                        escape = false;</b>
<b class="nc"><i>238</i>&nbsp;                        tbuf[j++] = ch;</b>
<i>239</i>&nbsp;                    } else {
<i>240</i>&nbsp;                        // escaping already started but we can&#39;t find 2nd hex
<b class="nc"><i>241</i>&nbsp;                        throw new InvalidSearchFilterException(&quot;invalid escape sequence: &quot; + orig);</b>
<i>242</i>&nbsp;                    }
<i>243</i>&nbsp;                } else {
<b class="nc"><i>244</i>&nbsp;                    if (escStart) {</b>
<b class="nc"><i>245</i>&nbsp;                        tbuf[j] = (byte)(ival&lt;&lt;4);</b>
<b class="nc"><i>246</i>&nbsp;                        escStart = false;</b>
<i>247</i>&nbsp;                    } else {
<b class="nc"><i>248</i>&nbsp;                        tbuf[j++] |= (byte)ival;</b>
<b class="nc"><i>249</i>&nbsp;                        escape = false;</b>
<i>250</i>&nbsp;                    }
<i>251</i>&nbsp;                }
<b class="nc"><i>252</i>&nbsp;            } else if (ch != &#39;\\&#39;) {</b>
<b class="nc"><i>253</i>&nbsp;                tbuf[j++] = ch;</b>
<b class="nc"><i>254</i>&nbsp;                escape = false;</b>
<i>255</i>&nbsp;            } else {
<b class="nc"><i>256</i>&nbsp;                escStart = escape = true;</b>
<i>257</i>&nbsp;            }
<i>258</i>&nbsp;        }
<b class="nc"><i>259</i>&nbsp;        byte[] answer = new byte[j];</b>
<b class="nc"><i>260</i>&nbsp;        System.arraycopy(tbuf, 0, answer, 0, j);</b>
<i>261</i>&nbsp;        if (dbg) {
<i>262</i>&nbsp;            Ber.dumpBER(System.err, &quot;&quot;, answer, 0, j);
<i>263</i>&nbsp;        }
<b class="nc"><i>264</i>&nbsp;        return answer;</b>
<i>265</i>&nbsp;    }
<i>266</i>&nbsp;
<i>267</i>&nbsp;    private static int indexOf(byte[] str, char ch, int start, int end) {
<b class="nc"><i>268</i>&nbsp;        for (int i = start; i &lt; end; i++) {</b>
<b class="nc"><i>269</i>&nbsp;            if (str[i] == ch)</b>
<b class="nc"><i>270</i>&nbsp;                return i;</b>
<i>271</i>&nbsp;        }
<b class="nc"><i>272</i>&nbsp;        return -1;</b>
<i>273</i>&nbsp;    }
<i>274</i>&nbsp;
<i>275</i>&nbsp;    private static int indexOf(byte[] str, String target, int start, int end) {
<b class="nc"><i>276</i>&nbsp;        int where = indexOf(str, target.charAt(0), start, end);</b>
<b class="nc"><i>277</i>&nbsp;        if (where &gt;= 0) {</b>
<b class="nc"><i>278</i>&nbsp;            for (int i = 1; i &lt; target.length(); i++) {</b>
<b class="nc"><i>279</i>&nbsp;                if (str[where+i] != target.charAt(i)) {</b>
<b class="nc"><i>280</i>&nbsp;                    return -1;</b>
<i>281</i>&nbsp;                }
<i>282</i>&nbsp;            }
<i>283</i>&nbsp;        }
<b class="nc"><i>284</i>&nbsp;        return where;</b>
<i>285</i>&nbsp;    }
<i>286</i>&nbsp;
<i>287</i>&nbsp;    private static int findUnescaped(byte[] str, char ch, int start, int end) {
<b class="nc"><i>288</i>&nbsp;        while (start &lt; end) {</b>
<b class="nc"><i>289</i>&nbsp;            int where = indexOf(str, ch, start, end);</b>
<i>290</i>&nbsp;
<i>291</i>&nbsp;            /*
<i>292</i>&nbsp;             * Count the immediate preceding &#39;\&#39; to find out if
<i>293</i>&nbsp;             * this is an escaped &#39;*&#39;. This is a made-up way for
<i>294</i>&nbsp;             * parsing an escaped &#39;*&#39; in v2. This is how the other leading
<i>295</i>&nbsp;             * SDK vendors interpret v2.
<i>296</i>&nbsp;             * For v3 we fallback to the way we parse &quot;\*&quot; in v2.
<i>297</i>&nbsp;             * It&#39;s not legal in v3 to use &quot;\*&quot; to escape &#39;*&#39;; the right
<i>298</i>&nbsp;             * way is to use &quot;\2a&quot; instead.
<i>299</i>&nbsp;             */
<i>300</i>&nbsp;            int backSlashPos;
<b class="nc"><i>301</i>&nbsp;            int backSlashCnt = 0;</b>
<b class="nc"><i>302</i>&nbsp;            for (backSlashPos = where - 1;</b>
<b class="nc"><i>303</i>&nbsp;                    ((backSlashPos &gt;= start) &amp;&amp; (str[backSlashPos] == &#39;\\&#39;));</b>
<b class="nc"><i>304</i>&nbsp;                    backSlashPos--, backSlashCnt++);</b>
<i>305</i>&nbsp;
<i>306</i>&nbsp;            // if at start of string, or not there at all, or if not escaped
<b class="nc"><i>307</i>&nbsp;            if (where == start || where == -1 || ((backSlashCnt % 2) == 0))</b>
<b class="nc"><i>308</i>&nbsp;                return where;</b>
<i>309</i>&nbsp;
<i>310</i>&nbsp;            // start search after escaped star
<b class="nc"><i>311</i>&nbsp;            start = where + 1;</b>
<b class="nc"><i>312</i>&nbsp;        }</b>
<b class="nc"><i>313</i>&nbsp;        return -1;</b>
<i>314</i>&nbsp;    }
<i>315</i>&nbsp;
<i>316</i>&nbsp;
<i>317</i>&nbsp;    private static void encodeSimpleFilter(BerEncoder ber, byte[] filter,
<i>318</i>&nbsp;        int filtStart, int filtEnd) throws IOException, NamingException {
<i>319</i>&nbsp;
<i>320</i>&nbsp;        if (dbg) {
<i>321</i>&nbsp;            dprint(&quot;encSimpleFilter: &quot;, filter, filtStart, filtEnd);
<i>322</i>&nbsp;            dbgIndent++;
<i>323</i>&nbsp;        }
<i>324</i>&nbsp;
<i>325</i>&nbsp;        String type, value;
<i>326</i>&nbsp;        int valueStart, valueEnd, typeStart, typeEnd;
<i>327</i>&nbsp;
<i>328</i>&nbsp;        int eq;
<b class="nc"><i>329</i>&nbsp;        if ((eq = indexOf(filter, &#39;=&#39;, filtStart, filtEnd)) == -1) {</b>
<b class="nc"><i>330</i>&nbsp;            throw new InvalidSearchFilterException(&quot;Missing &#39;equals&#39;&quot;);</b>
<i>331</i>&nbsp;        }
<i>332</i>&nbsp;
<i>333</i>&nbsp;
<b class="nc"><i>334</i>&nbsp;        valueStart = eq + 1;        // value starts after equal sign</b>
<b class="nc"><i>335</i>&nbsp;        valueEnd = filtEnd;</b>
<b class="nc"><i>336</i>&nbsp;        typeStart = filtStart;      // beginning of string</b>
<i>337</i>&nbsp;
<i>338</i>&nbsp;        int ftype;
<i>339</i>&nbsp;
<b class="nc"><i>340</i>&nbsp;        switch (filter[eq - 1]) {</b>
<i>341</i>&nbsp;        case &#39;&lt;&#39;:
<b class="nc"><i>342</i>&nbsp;            ftype = LDAP_FILTER_LE;</b>
<b class="nc"><i>343</i>&nbsp;            typeEnd = eq - 1;</b>
<b class="nc"><i>344</i>&nbsp;            break;</b>
<i>345</i>&nbsp;        case &#39;&gt;&#39;:
<b class="nc"><i>346</i>&nbsp;            ftype = LDAP_FILTER_GE;</b>
<b class="nc"><i>347</i>&nbsp;            typeEnd = eq - 1;</b>
<b class="nc"><i>348</i>&nbsp;            break;</b>
<i>349</i>&nbsp;        case &#39;~&#39;:
<b class="nc"><i>350</i>&nbsp;            ftype = LDAP_FILTER_APPROX;</b>
<b class="nc"><i>351</i>&nbsp;            typeEnd = eq - 1;</b>
<b class="nc"><i>352</i>&nbsp;            break;</b>
<i>353</i>&nbsp;        case &#39;:&#39;:
<b class="nc"><i>354</i>&nbsp;            ftype = LDAP_FILTER_EXT;</b>
<b class="nc"><i>355</i>&nbsp;            typeEnd = eq - 1;</b>
<b class="nc"><i>356</i>&nbsp;            break;</b>
<i>357</i>&nbsp;        default:
<b class="nc"><i>358</i>&nbsp;            typeEnd = eq;</b>
<i>359</i>&nbsp;            //initializing ftype to make the compiler happy
<b class="nc"><i>360</i>&nbsp;            ftype = 0x00;</b>
<i>361</i>&nbsp;            break;
<i>362</i>&nbsp;        }
<i>363</i>&nbsp;
<i>364</i>&nbsp;        if (dbg) {
<i>365</i>&nbsp;            System.err.println(&quot;type: &quot; + typeStart + &quot;, &quot; + typeEnd);
<i>366</i>&nbsp;            System.err.println(&quot;value: &quot; + valueStart + &quot;, &quot; + valueEnd);
<i>367</i>&nbsp;        }
<i>368</i>&nbsp;
<i>369</i>&nbsp;        // check validity of type
<i>370</i>&nbsp;        //
<i>371</i>&nbsp;        // RFC4512 defines the type as the following ABNF:
<i>372</i>&nbsp;        //     attr = attributedescription
<i>373</i>&nbsp;        //     attributedescription = attributetype options
<i>374</i>&nbsp;        //     attributetype = oid
<i>375</i>&nbsp;        //     oid = descr / numericoid
<i>376</i>&nbsp;        //     descr = keystring
<i>377</i>&nbsp;        //     keystring = leadkeychar *keychar
<i>378</i>&nbsp;        //     leadkeychar = ALPHA
<i>379</i>&nbsp;        //     keychar = ALPHA / DIGIT / HYPHEN
<i>380</i>&nbsp;        //     numericoid = number 1*( DOT number )
<i>381</i>&nbsp;        //     number  = DIGIT / ( LDIGIT 1*DIGIT )
<i>382</i>&nbsp;        //     options = *( SEMI option )
<i>383</i>&nbsp;        //     option = 1*keychar
<i>384</i>&nbsp;        //
<i>385</i>&nbsp;        // And RFC4515 defines the extensible type as the following ABNF:
<i>386</i>&nbsp;        //     attr [dnattrs] [matchingrule] / [dnattrs] matchingrule
<b class="nc"><i>387</i>&nbsp;        int optionsStart = -1;</b>
<b class="nc"><i>388</i>&nbsp;        int extensibleStart = -1;</b>
<b class="nc"><i>389</i>&nbsp;        if ((filter[typeStart] &gt;= &#39;0&#39; &amp;&amp; filter[typeStart] &lt;= &#39;9&#39;) ||</b>
<i>390</i>&nbsp;            (filter[typeStart] &gt;= &#39;A&#39; &amp;&amp; filter[typeStart] &lt;= &#39;Z&#39;) ||
<i>391</i>&nbsp;            (filter[typeStart] &gt;= &#39;a&#39; &amp;&amp; filter[typeStart] &lt;= &#39;z&#39;)) {
<i>392</i>&nbsp;
<b class="nc"><i>393</i>&nbsp;            boolean isNumericOid =</b>
<i>394</i>&nbsp;                filter[typeStart] &gt;= &#39;0&#39; &amp;&amp; filter[typeStart] &lt;= &#39;9&#39;;
<b class="nc"><i>395</i>&nbsp;            for (int i = typeStart + 1; i &lt; typeEnd; i++) {</b>
<i>396</i>&nbsp;                // &#39;;&#39; is an indicator of attribute options
<b class="nc"><i>397</i>&nbsp;                if (filter[i] == &#39;;&#39;) {</b>
<b class="nc"><i>398</i>&nbsp;                    if (isNumericOid &amp;&amp; filter[i - 1] == &#39;.&#39;) {</b>
<b class="nc"><i>399</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>400</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>401</i>&nbsp;                    }
<i>402</i>&nbsp;
<i>403</i>&nbsp;                    // attribute options
<b class="nc"><i>404</i>&nbsp;                    optionsStart = i;</b>
<b class="nc"><i>405</i>&nbsp;                    break;</b>
<i>406</i>&nbsp;                }
<i>407</i>&nbsp;
<i>408</i>&nbsp;                // &#39;:&#39; is an indicator of extensible rules
<b class="nc"><i>409</i>&nbsp;                if (filter[i] == &#39;:&#39; &amp;&amp; ftype == LDAP_FILTER_EXT) {</b>
<b class="nc"><i>410</i>&nbsp;                    if (isNumericOid &amp;&amp; filter[i - 1] == &#39;.&#39;) {</b>
<b class="nc"><i>411</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>412</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>413</i>&nbsp;                    }
<i>414</i>&nbsp;
<i>415</i>&nbsp;                    // extensible matching
<b class="nc"><i>416</i>&nbsp;                    extensibleStart = i;</b>
<b class="nc"><i>417</i>&nbsp;                    break;</b>
<i>418</i>&nbsp;                }
<i>419</i>&nbsp;
<b class="nc"><i>420</i>&nbsp;                if (isNumericOid) {</b>
<i>421</i>&nbsp;                    // numeric object identifier
<b class="nc"><i>422</i>&nbsp;                    if ((filter[i] == &#39;.&#39; &amp;&amp; filter[i - 1] == &#39;.&#39;) ||</b>
<i>423</i>&nbsp;                        (filter[i] != &#39;.&#39; &amp;&amp;
<i>424</i>&nbsp;                            !(filter[i] &gt;= &#39;0&#39; &amp;&amp; filter[i] &lt;= &#39;9&#39;))) {
<b class="nc"><i>425</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>426</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>427</i>&nbsp;                    }
<i>428</i>&nbsp;                } else {
<i>429</i>&nbsp;                    // descriptor
<i>430</i>&nbsp;                    // The underscore (&quot;_&quot;) character is not allowed by
<i>431</i>&nbsp;                    // the LDAP specification. We allow it here to
<i>432</i>&nbsp;                    // tolerate the incorrect use in practice.
<b class="nc"><i>433</i>&nbsp;                    if (filter[i] != &#39;-&#39; &amp;&amp; filter[i] != &#39;_&#39; &amp;&amp;</b>
<i>434</i>&nbsp;                        !(filter[i] &gt;= &#39;0&#39; &amp;&amp; filter[i] &lt;= &#39;9&#39;) &amp;&amp;
<i>435</i>&nbsp;                        !(filter[i] &gt;= &#39;A&#39; &amp;&amp; filter[i] &lt;= &#39;Z&#39;) &amp;&amp;
<i>436</i>&nbsp;                        !(filter[i] &gt;= &#39;a&#39; &amp;&amp; filter[i] &lt;= &#39;z&#39;)) {
<b class="nc"><i>437</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>438</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>439</i>&nbsp;                    }
<i>440</i>&nbsp;                }
<i>441</i>&nbsp;            }
<b class="nc"><i>442</i>&nbsp;        } else if (ftype == LDAP_FILTER_EXT &amp;&amp; filter[typeStart] == &#39;:&#39;) {</b>
<i>443</i>&nbsp;            // extensible matching
<b class="nc"><i>444</i>&nbsp;            extensibleStart = typeStart;</b>
<i>445</i>&nbsp;        } else {
<b class="nc"><i>446</i>&nbsp;            throw new InvalidSearchFilterException(</b>
<i>447</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>448</i>&nbsp;        }
<i>449</i>&nbsp;
<i>450</i>&nbsp;        // check attribute options
<b class="nc"><i>451</i>&nbsp;        if (optionsStart &gt; 0) {</b>
<b class="nc"><i>452</i>&nbsp;            for (int i = optionsStart + 1; i &lt; typeEnd; i++) {</b>
<b class="nc"><i>453</i>&nbsp;                if (filter[i] == &#39;;&#39;) {</b>
<b class="nc"><i>454</i>&nbsp;                    if (filter[i - 1] == &#39;;&#39;) {</b>
<b class="nc"><i>455</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>456</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>457</i>&nbsp;                    }
<i>458</i>&nbsp;                    continue;
<i>459</i>&nbsp;                }
<i>460</i>&nbsp;
<i>461</i>&nbsp;                // &#39;:&#39; is an indicator of extensible rules
<b class="nc"><i>462</i>&nbsp;                if (filter[i] == &#39;:&#39; &amp;&amp; ftype == LDAP_FILTER_EXT) {</b>
<b class="nc"><i>463</i>&nbsp;                    if (filter[i - 1] == &#39;;&#39;) {</b>
<b class="nc"><i>464</i>&nbsp;                        throw new InvalidSearchFilterException(</b>
<i>465</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>466</i>&nbsp;                    }
<i>467</i>&nbsp;
<i>468</i>&nbsp;                    // extensible matching
<b class="nc"><i>469</i>&nbsp;                    extensibleStart = i;</b>
<b class="nc"><i>470</i>&nbsp;                    break;</b>
<i>471</i>&nbsp;                }
<i>472</i>&nbsp;
<i>473</i>&nbsp;                // The underscore (&quot;_&quot;) character is not allowed by
<i>474</i>&nbsp;                // the LDAP specification. We allow it here to
<i>475</i>&nbsp;                // tolerate the incorrect use in practice.
<b class="nc"><i>476</i>&nbsp;                if (filter[i] != &#39;-&#39; &amp;&amp; filter[i] != &#39;_&#39; &amp;&amp;</b>
<i>477</i>&nbsp;                        !(filter[i] &gt;= &#39;0&#39; &amp;&amp; filter[i] &lt;= &#39;9&#39;) &amp;&amp;
<i>478</i>&nbsp;                        !(filter[i] &gt;= &#39;A&#39; &amp;&amp; filter[i] &lt;= &#39;Z&#39;) &amp;&amp;
<i>479</i>&nbsp;                        !(filter[i] &gt;= &#39;a&#39; &amp;&amp; filter[i] &lt;= &#39;z&#39;)) {
<b class="nc"><i>480</i>&nbsp;                    throw new InvalidSearchFilterException(</b>
<i>481</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>482</i>&nbsp;                }
<i>483</i>&nbsp;            }
<i>484</i>&nbsp;        }
<i>485</i>&nbsp;
<i>486</i>&nbsp;        // check extensible matching
<b class="nc"><i>487</i>&nbsp;        if (extensibleStart &gt; 0) {</b>
<b class="nc"><i>488</i>&nbsp;            boolean isMatchingRule = false;</b>
<b class="nc"><i>489</i>&nbsp;            for (int i = extensibleStart + 1; i &lt; typeEnd; i++) {</b>
<b class="nc"><i>490</i>&nbsp;                if (filter[i] == &#39;:&#39;) {</b>
<b class="nc"><i>491</i>&nbsp;                    throw new InvalidSearchFilterException(</b>
<i>492</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<b class="nc"><i>493</i>&nbsp;                } else if ((filter[i] &gt;= &#39;0&#39; &amp;&amp; filter[i] &lt;= &#39;9&#39;) ||</b>
<i>494</i>&nbsp;                           (filter[i] &gt;= &#39;A&#39; &amp;&amp; filter[i] &lt;= &#39;Z&#39;) ||
<i>495</i>&nbsp;                           (filter[i] &gt;= &#39;a&#39; &amp;&amp; filter[i] &lt;= &#39;z&#39;)) {
<b class="nc"><i>496</i>&nbsp;                    boolean isNumericOid = filter[i] &gt;= &#39;0&#39; &amp;&amp; filter[i] &lt;= &#39;9&#39;;</b>
<b class="nc"><i>497</i>&nbsp;                    i++;</b>
<b class="nc"><i>498</i>&nbsp;                    for (int j = i; j &lt; typeEnd; j++, i++) {</b>
<i>499</i>&nbsp;                        // allows no more than two extensible rules
<b class="nc"><i>500</i>&nbsp;                        if (filter[j] == &#39;:&#39;) {</b>
<b class="nc"><i>501</i>&nbsp;                            if (isMatchingRule) {</b>
<b class="nc"><i>502</i>&nbsp;                                throw new InvalidSearchFilterException(</b>
<i>503</i>&nbsp;                                            &quot;invalid attribute description&quot;);
<i>504</i>&nbsp;                            }
<b class="nc"><i>505</i>&nbsp;                            if (isNumericOid &amp;&amp; filter[j - 1] == &#39;.&#39;) {</b>
<b class="nc"><i>506</i>&nbsp;                                throw new InvalidSearchFilterException(</b>
<i>507</i>&nbsp;                                            &quot;invalid attribute description&quot;);
<i>508</i>&nbsp;                            }
<i>509</i>&nbsp;
<b class="nc"><i>510</i>&nbsp;                            isMatchingRule = true;</b>
<b class="nc"><i>511</i>&nbsp;                            break;</b>
<i>512</i>&nbsp;                        }
<i>513</i>&nbsp;
<b class="nc"><i>514</i>&nbsp;                        if (isNumericOid) {</b>
<i>515</i>&nbsp;                            // numeric object identifier
<b class="nc"><i>516</i>&nbsp;                            if ((filter[j] == &#39;.&#39; &amp;&amp; filter[j - 1] == &#39;.&#39;) ||</b>
<i>517</i>&nbsp;                                (filter[j] != &#39;.&#39; &amp;&amp;
<i>518</i>&nbsp;                                    !(filter[j] &gt;= &#39;0&#39; &amp;&amp; filter[j] &lt;= &#39;9&#39;))) {
<b class="nc"><i>519</i>&nbsp;                                throw new InvalidSearchFilterException(</b>
<i>520</i>&nbsp;                                            &quot;invalid attribute description&quot;);
<i>521</i>&nbsp;                            }
<i>522</i>&nbsp;                        } else {
<i>523</i>&nbsp;                            // descriptor
<i>524</i>&nbsp;                            // The underscore (&quot;_&quot;) character is not allowed by
<i>525</i>&nbsp;                            // the LDAP specification. We allow it here to
<i>526</i>&nbsp;                            // tolerate the incorrect use in practice.
<b class="nc"><i>527</i>&nbsp;                            if (filter[j] != &#39;-&#39; &amp;&amp; filter[j] != &#39;_&#39; &amp;&amp;</b>
<i>528</i>&nbsp;                                !(filter[j] &gt;= &#39;0&#39; &amp;&amp; filter[j] &lt;= &#39;9&#39;) &amp;&amp;
<i>529</i>&nbsp;                                !(filter[j] &gt;= &#39;A&#39; &amp;&amp; filter[j] &lt;= &#39;Z&#39;) &amp;&amp;
<i>530</i>&nbsp;                                !(filter[j] &gt;= &#39;a&#39; &amp;&amp; filter[j] &lt;= &#39;z&#39;)) {
<b class="nc"><i>531</i>&nbsp;                                throw new InvalidSearchFilterException(</b>
<i>532</i>&nbsp;                                            &quot;invalid attribute description&quot;);
<i>533</i>&nbsp;                            }
<i>534</i>&nbsp;                        }
<i>535</i>&nbsp;                    }
<b class="nc"><i>536</i>&nbsp;                } else {</b>
<b class="nc"><i>537</i>&nbsp;                    throw new InvalidSearchFilterException(</b>
<i>538</i>&nbsp;                                    &quot;invalid attribute description&quot;);
<i>539</i>&nbsp;                }
<i>540</i>&nbsp;            }
<i>541</i>&nbsp;        }
<i>542</i>&nbsp;
<i>543</i>&nbsp;        // ensure the latest byte is not isolated
<b class="nc"><i>544</i>&nbsp;        if (filter[typeEnd - 1] == &#39;.&#39; || filter[typeEnd - 1] == &#39;;&#39; ||</b>
<i>545</i>&nbsp;                                          filter[typeEnd - 1] == &#39;:&#39;) {
<b class="nc"><i>546</i>&nbsp;            throw new InvalidSearchFilterException(</b>
<i>547</i>&nbsp;                &quot;invalid attribute description&quot;);
<i>548</i>&nbsp;        }
<i>549</i>&nbsp;
<b class="nc"><i>550</i>&nbsp;        if (typeEnd == eq) { // filter type is of &quot;equal&quot;</b>
<b class="nc"><i>551</i>&nbsp;            if (findUnescaped(filter, &#39;*&#39;, valueStart, valueEnd) == -1) {</b>
<b class="nc"><i>552</i>&nbsp;                ftype = LDAP_FILTER_EQUALITY;</b>
<b class="nc"><i>553</i>&nbsp;            } else if (filter[valueStart] == &#39;*&#39; &amp;&amp;</b>
<i>554</i>&nbsp;                            valueStart == (valueEnd - 1)) {
<b class="nc"><i>555</i>&nbsp;                ftype = LDAP_FILTER_PRESENT;</b>
<i>556</i>&nbsp;            } else {
<b class="nc"><i>557</i>&nbsp;                encodeSubstringFilter(ber, filter,</b>
<i>558</i>&nbsp;                    typeStart, typeEnd, valueStart, valueEnd);
<i>559</i>&nbsp;                return;
<i>560</i>&nbsp;            }
<i>561</i>&nbsp;        }
<i>562</i>&nbsp;
<b class="nc"><i>563</i>&nbsp;        if (ftype == LDAP_FILTER_PRESENT) {</b>
<b class="nc"><i>564</i>&nbsp;            ber.encodeOctetString(filter, ftype, typeStart, typeEnd-typeStart);</b>
<b class="nc"><i>565</i>&nbsp;        } else if (ftype == LDAP_FILTER_EXT) {</b>
<b class="nc"><i>566</i>&nbsp;            encodeExtensibleMatch(ber, filter,</b>
<i>567</i>&nbsp;                typeStart, typeEnd, valueStart, valueEnd);
<i>568</i>&nbsp;        } else {
<b class="nc"><i>569</i>&nbsp;            ber.beginSeq(ftype);</b>
<b class="nc"><i>570</i>&nbsp;                ber.encodeOctetString(filter, Ber.ASN_OCTET_STR,</b>
<i>571</i>&nbsp;                    typeStart, typeEnd - typeStart);
<b class="nc"><i>572</i>&nbsp;                ber.encodeOctetString(</b>
<b class="nc"><i>573</i>&nbsp;                    unescapeFilterValue(filter, valueStart, valueEnd),</b>
<i>574</i>&nbsp;                    Ber.ASN_OCTET_STR);
<b class="nc"><i>575</i>&nbsp;            ber.endSeq();</b>
<i>576</i>&nbsp;        }
<i>577</i>&nbsp;
<i>578</i>&nbsp;        if (dbg) {
<i>579</i>&nbsp;            dbgIndent--;
<i>580</i>&nbsp;        }
<i>581</i>&nbsp;    }
<i>582</i>&nbsp;
<i>583</i>&nbsp;    private static void encodeSubstringFilter(BerEncoder ber, byte[] filter,
<i>584</i>&nbsp;        int typeStart, int typeEnd, int valueStart, int valueEnd)
<i>585</i>&nbsp;        throws IOException, NamingException {
<i>586</i>&nbsp;
<i>587</i>&nbsp;        if (dbg) {
<i>588</i>&nbsp;            dprint(&quot;encSubstringFilter: type &quot;, filter, typeStart, typeEnd);
<i>589</i>&nbsp;            dprint(&quot;, val : &quot;, filter, valueStart, valueEnd);
<i>590</i>&nbsp;            dbgIndent++;
<i>591</i>&nbsp;        }
<i>592</i>&nbsp;
<b class="nc"><i>593</i>&nbsp;        ber.beginSeq(LDAP_FILTER_SUBSTRINGS);</b>
<b class="nc"><i>594</i>&nbsp;            ber.encodeOctetString(filter, Ber.ASN_OCTET_STR,</b>
<i>595</i>&nbsp;                    typeStart, typeEnd-typeStart);
<b class="nc"><i>596</i>&nbsp;            ber.beginSeq(LdapClient.LBER_SEQUENCE);</b>
<i>597</i>&nbsp;                int index;
<b class="nc"><i>598</i>&nbsp;                int previndex = valueStart;</b>
<b class="nc"><i>599</i>&nbsp;                while ((index = findUnescaped(filter, &#39;*&#39;, previndex, valueEnd)) != -1) {</b>
<b class="nc"><i>600</i>&nbsp;                    if (previndex == valueStart) {</b>
<b class="nc"><i>601</i>&nbsp;                      if (previndex &lt; index) {</b>
<i>602</i>&nbsp;                          if (dbg)
<i>603</i>&nbsp;                              System.err.println(
<i>604</i>&nbsp;                                  &quot;initial: &quot; + previndex + &quot;,&quot; + index);
<b class="nc"><i>605</i>&nbsp;                        ber.encodeOctetString(</b>
<b class="nc"><i>606</i>&nbsp;                            unescapeFilterValue(filter, previndex, index),</b>
<i>607</i>&nbsp;                            LDAP_SUBSTRING_INITIAL);
<i>608</i>&nbsp;                      }
<i>609</i>&nbsp;                    } else {
<b class="nc"><i>610</i>&nbsp;                      if (previndex &lt; index) {</b>
<i>611</i>&nbsp;                          if (dbg)
<i>612</i>&nbsp;                              System.err.println(&quot;any: &quot; + previndex + &quot;,&quot; + index);
<b class="nc"><i>613</i>&nbsp;                        ber.encodeOctetString(</b>
<b class="nc"><i>614</i>&nbsp;                            unescapeFilterValue(filter, previndex, index),</b>
<i>615</i>&nbsp;                            LDAP_SUBSTRING_ANY);
<i>616</i>&nbsp;                      }
<i>617</i>&nbsp;                    }
<b class="nc"><i>618</i>&nbsp;                    previndex = index + 1;</b>
<i>619</i>&nbsp;                }
<b class="nc"><i>620</i>&nbsp;                if (previndex &lt; valueEnd) {</b>
<i>621</i>&nbsp;                    if (dbg)
<i>622</i>&nbsp;                        System.err.println(&quot;final: &quot; + previndex + &quot;,&quot; + valueEnd);
<b class="nc"><i>623</i>&nbsp;                  ber.encodeOctetString(</b>
<b class="nc"><i>624</i>&nbsp;                      unescapeFilterValue(filter, previndex, valueEnd),</b>
<i>625</i>&nbsp;                      LDAP_SUBSTRING_FINAL);
<i>626</i>&nbsp;                }
<b class="nc"><i>627</i>&nbsp;            ber.endSeq();</b>
<b class="nc"><i>628</i>&nbsp;        ber.endSeq();</b>
<i>629</i>&nbsp;
<i>630</i>&nbsp;        if (dbg) {
<i>631</i>&nbsp;            dbgIndent--;
<i>632</i>&nbsp;        }
<i>633</i>&nbsp;    }
<i>634</i>&nbsp;
<i>635</i>&nbsp;    // The complex filter types look like:
<i>636</i>&nbsp;    //     &quot;&amp;(type=val)(type=val)&quot;
<i>637</i>&nbsp;    //     &quot;|(type=val)(type=val)&quot;
<i>638</i>&nbsp;    //     &quot;!(type=val)&quot;
<i>639</i>&nbsp;    //
<i>640</i>&nbsp;    // The filtOffset[0] pointing to the &#39;&amp;&#39;, &#39;|&#39;, or &#39;!&#39;.
<i>641</i>&nbsp;    //
<i>642</i>&nbsp;    private static void encodeComplexFilter(BerEncoder ber, byte[] filter,
<i>643</i>&nbsp;        int filterType, int filtOffset[], int filtEnd)
<i>644</i>&nbsp;        throws IOException, NamingException {
<i>645</i>&nbsp;
<i>646</i>&nbsp;        if (dbg) {
<i>647</i>&nbsp;            dprint(&quot;encComplexFilter: &quot;, filter, filtOffset[0], filtEnd);
<i>648</i>&nbsp;            dprint(&quot;, type: &quot; + Integer.toString(filterType, 16));
<i>649</i>&nbsp;            dbgIndent++;
<i>650</i>&nbsp;        }
<i>651</i>&nbsp;
<b class="nc"><i>652</i>&nbsp;        filtOffset[0]++;</b>
<i>653</i>&nbsp;
<b class="nc"><i>654</i>&nbsp;        ber.beginSeq(filterType);</b>
<i>655</i>&nbsp;
<b class="nc"><i>656</i>&nbsp;            int[] parens = findRightParen(filter, filtOffset, filtEnd);</b>
<b class="nc"><i>657</i>&nbsp;            encodeFilterList(ber, filter, filterType, parens[0], parens[1]);</b>
<i>658</i>&nbsp;
<b class="nc"><i>659</i>&nbsp;        ber.endSeq();</b>
<i>660</i>&nbsp;
<i>661</i>&nbsp;        if (dbg) {
<i>662</i>&nbsp;            dbgIndent--;
<i>663</i>&nbsp;        }
<i>664</i>&nbsp;
<i>665</i>&nbsp;    }
<i>666</i>&nbsp;
<i>667</i>&nbsp;    //
<i>668</i>&nbsp;    // filter at filtOffset[0] - 1 points to a (. Find ) that matches it
<i>669</i>&nbsp;    // and return substring between the parens. Adjust filtOffset[0] to
<i>670</i>&nbsp;    // point to char after right paren
<i>671</i>&nbsp;    //
<i>672</i>&nbsp;    private static int[] findRightParen(byte[] filter, int filtOffset[], int end)
<i>673</i>&nbsp;    throws IOException, NamingException {
<i>674</i>&nbsp;
<b class="nc"><i>675</i>&nbsp;        int balance = 1;</b>
<b class="nc"><i>676</i>&nbsp;        boolean escape = false;</b>
<b class="nc"><i>677</i>&nbsp;        int nextOffset = filtOffset[0];</b>
<i>678</i>&nbsp;
<b class="nc"><i>679</i>&nbsp;        while (nextOffset &lt; end &amp;&amp; balance &gt; 0) {</b>
<b class="nc"><i>680</i>&nbsp;            if (!escape) {</b>
<b class="nc"><i>681</i>&nbsp;                if (filter[nextOffset] == &#39;(&#39;)</b>
<b class="nc"><i>682</i>&nbsp;                    balance++;</b>
<b class="nc"><i>683</i>&nbsp;                else if (filter[nextOffset] == &#39;)&#39;)</b>
<b class="nc"><i>684</i>&nbsp;                    balance--;</b>
<i>685</i>&nbsp;            }
<b class="nc"><i>686</i>&nbsp;            if (filter[nextOffset] == &#39;\\&#39; &amp;&amp; !escape)</b>
<b class="nc"><i>687</i>&nbsp;                escape = true;</b>
<i>688</i>&nbsp;            else
<b class="nc"><i>689</i>&nbsp;                escape = false;</b>
<b class="nc"><i>690</i>&nbsp;            if (balance &gt; 0)</b>
<b class="nc"><i>691</i>&nbsp;                nextOffset++;</b>
<i>692</i>&nbsp;        }
<b class="nc"><i>693</i>&nbsp;        if (balance != 0) {</b>
<b class="nc"><i>694</i>&nbsp;            throw new InvalidSearchFilterException(&quot;Unbalanced parenthesis&quot;);</b>
<i>695</i>&nbsp;        }
<i>696</i>&nbsp;
<i>697</i>&nbsp;        // String tmp = filter.substring(filtOffset[0], nextOffset);
<i>698</i>&nbsp;
<b class="nc"><i>699</i>&nbsp;        int[] tmp = new int[] {filtOffset[0], nextOffset};</b>
<i>700</i>&nbsp;
<b class="nc"><i>701</i>&nbsp;        filtOffset[0] = nextOffset + 1;</b>
<i>702</i>&nbsp;
<b class="nc"><i>703</i>&nbsp;        return tmp;</b>
<i>704</i>&nbsp;
<i>705</i>&nbsp;    }
<i>706</i>&nbsp;
<i>707</i>&nbsp;    //
<i>708</i>&nbsp;    // Encode filter list of type &quot;(filter1)(filter2)...&quot;
<i>709</i>&nbsp;    //
<i>710</i>&nbsp;    private static void encodeFilterList(BerEncoder ber, byte[] filter,
<i>711</i>&nbsp;        int filterType, int start, int end) throws IOException, NamingException {
<i>712</i>&nbsp;
<i>713</i>&nbsp;        if (dbg) {
<i>714</i>&nbsp;            dprint(&quot;encFilterList: &quot;, filter, start, end);
<i>715</i>&nbsp;            dbgIndent++;
<i>716</i>&nbsp;        }
<i>717</i>&nbsp;
<b class="nc"><i>718</i>&nbsp;        int filtOffset[] = new int[1];</b>
<b class="nc"><i>719</i>&nbsp;        int listNumber = 0;</b>
<b class="nc"><i>720</i>&nbsp;        for (filtOffset[0] = start; filtOffset[0] &lt; end; filtOffset[0]++) {</b>
<b class="nc"><i>721</i>&nbsp;            if (Character.isSpaceChar((char)filter[filtOffset[0]]))</b>
<b class="nc"><i>722</i>&nbsp;                continue;</b>
<i>723</i>&nbsp;
<b class="nc"><i>724</i>&nbsp;            if ((filterType == LDAP_FILTER_NOT) &amp;&amp; (listNumber &gt; 0)) {</b>
<b class="nc"><i>725</i>&nbsp;                throw new InvalidSearchFilterException(</b>
<i>726</i>&nbsp;                    &quot;Filter (!) cannot be followed by more than one filters&quot;);
<i>727</i>&nbsp;            }
<i>728</i>&nbsp;
<b class="nc"><i>729</i>&nbsp;            if (filter[filtOffset[0]] == &#39;(&#39;) {</b>
<b class="nc"><i>730</i>&nbsp;                continue;</b>
<i>731</i>&nbsp;            }
<i>732</i>&nbsp;
<b class="nc"><i>733</i>&nbsp;            int[] parens = findRightParen(filter, filtOffset, end);</b>
<i>734</i>&nbsp;
<i>735</i>&nbsp;            // add enclosing parens
<b class="nc"><i>736</i>&nbsp;            int len = parens[1]-parens[0];</b>
<b class="nc"><i>737</i>&nbsp;            byte[] newfilter = new byte[len+2];</b>
<b class="nc"><i>738</i>&nbsp;            System.arraycopy(filter, parens[0], newfilter, 1, len);</b>
<b class="nc"><i>739</i>&nbsp;            newfilter[0] = (byte)&#39;(&#39;;</b>
<b class="nc"><i>740</i>&nbsp;            newfilter[len+1] = (byte)&#39;)&#39;;</b>
<b class="nc"><i>741</i>&nbsp;            encodeFilter(ber, newfilter, 0, newfilter.length);</b>
<i>742</i>&nbsp;
<b class="nc"><i>743</i>&nbsp;            listNumber++;</b>
<i>744</i>&nbsp;        }
<i>745</i>&nbsp;
<i>746</i>&nbsp;        if (dbg) {
<i>747</i>&nbsp;            dbgIndent--;
<i>748</i>&nbsp;        }
<i>749</i>&nbsp;
<i>750</i>&nbsp;    }
<i>751</i>&nbsp;
<i>752</i>&nbsp;    //
<i>753</i>&nbsp;    // Encode extensible match
<i>754</i>&nbsp;    //
<i>755</i>&nbsp;    private static void encodeExtensibleMatch(BerEncoder ber, byte[] filter,
<i>756</i>&nbsp;        int matchStart, int matchEnd, int valueStart, int valueEnd)
<i>757</i>&nbsp;        throws IOException, NamingException {
<i>758</i>&nbsp;
<b class="nc"><i>759</i>&nbsp;        boolean matchDN = false;</b>
<i>760</i>&nbsp;        int colon;
<i>761</i>&nbsp;        int colon2;
<i>762</i>&nbsp;        int i;
<i>763</i>&nbsp;
<b class="nc"><i>764</i>&nbsp;        ber.beginSeq(LDAP_FILTER_EXT);</b>
<i>765</i>&nbsp;
<i>766</i>&nbsp;            // test for colon separator
<b class="nc"><i>767</i>&nbsp;            if ((colon = indexOf(filter, &#39;:&#39;, matchStart, matchEnd)) &gt;= 0) {</b>
<i>768</i>&nbsp;
<i>769</i>&nbsp;                // test for match DN
<b class="nc"><i>770</i>&nbsp;                if ((i = indexOf(filter, &quot;:dn&quot;, colon, matchEnd)) &gt;= 0) {</b>
<b class="nc"><i>771</i>&nbsp;                    matchDN = true;</b>
<i>772</i>&nbsp;                }
<i>773</i>&nbsp;
<i>774</i>&nbsp;                // test for matching rule
<b class="nc"><i>775</i>&nbsp;                if (((colon2 = indexOf(filter, &#39;:&#39;, colon + 1, matchEnd)) &gt;= 0)</b>
<i>776</i>&nbsp;                    || (i == -1)) {
<i>777</i>&nbsp;
<b class="nc"><i>778</i>&nbsp;                    if (i == colon) {</b>
<b class="nc"><i>779</i>&nbsp;                        ber.encodeOctetString(filter, LDAP_FILTER_EXT_RULE,</b>
<i>780</i>&nbsp;                            colon2 + 1, matchEnd - (colon2 + 1));
<i>781</i>&nbsp;
<b class="nc"><i>782</i>&nbsp;                    } else if ((i == colon2) &amp;&amp; (i &gt;= 0)) {</b>
<b class="nc"><i>783</i>&nbsp;                        ber.encodeOctetString(filter, LDAP_FILTER_EXT_RULE,</b>
<i>784</i>&nbsp;                            colon + 1, colon2 - (colon + 1));
<i>785</i>&nbsp;
<i>786</i>&nbsp;                    } else {
<b class="nc"><i>787</i>&nbsp;                        ber.encodeOctetString(filter, LDAP_FILTER_EXT_RULE,</b>
<i>788</i>&nbsp;                            colon + 1, matchEnd - (colon + 1));
<i>789</i>&nbsp;                    }
<i>790</i>&nbsp;                }
<i>791</i>&nbsp;
<i>792</i>&nbsp;                // test for attribute type
<b class="nc"><i>793</i>&nbsp;                if (colon &gt; matchStart) {</b>
<b class="nc"><i>794</i>&nbsp;                    ber.encodeOctetString(filter,</b>
<i>795</i>&nbsp;                        LDAP_FILTER_EXT_TYPE, matchStart, colon - matchStart);
<i>796</i>&nbsp;                }
<i>797</i>&nbsp;            } else {
<b class="nc"><i>798</i>&nbsp;                ber.encodeOctetString(filter, LDAP_FILTER_EXT_TYPE, matchStart,</b>
<i>799</i>&nbsp;                    matchEnd - matchStart);
<i>800</i>&nbsp;            }
<i>801</i>&nbsp;
<b class="nc"><i>802</i>&nbsp;            ber.encodeOctetString(</b>
<b class="nc"><i>803</i>&nbsp;                unescapeFilterValue(filter, valueStart, valueEnd),</b>
<i>804</i>&nbsp;                LDAP_FILTER_EXT_VAL);
<i>805</i>&nbsp;
<i>806</i>&nbsp;            /*
<i>807</i>&nbsp;             * This element is defined in RFC-2251 with an ASN.1 DEFAULT tag.
<i>808</i>&nbsp;             * However, for Active Directory interoperability it is transmitted
<i>809</i>&nbsp;             * even when FALSE.
<i>810</i>&nbsp;             */
<b class="nc"><i>811</i>&nbsp;            ber.encodeBoolean(matchDN, LDAP_FILTER_EXT_DN);</b>
<i>812</i>&nbsp;
<b class="nc"><i>813</i>&nbsp;        ber.endSeq();</b>
<i>814</i>&nbsp;    }
<i>815</i>&nbsp;
<i>816</i>&nbsp;    ////////////////////////////////////////////////////////////////////////////
<i>817</i>&nbsp;    //
<i>818</i>&nbsp;    // some debug print code that does indenting. Useful for debugging
<i>819</i>&nbsp;    // the filter generation code
<i>820</i>&nbsp;    //
<i>821</i>&nbsp;    ////////////////////////////////////////////////////////////////////////////
<i>822</i>&nbsp;
<i>823</i>&nbsp;    private static final boolean dbg = false;
<b class="nc"><i>824</i>&nbsp;    private static int dbgIndent = 0;</b>
<i>825</i>&nbsp;
<i>826</i>&nbsp;    private static void dprint(String msg) {
<b class="nc"><i>827</i>&nbsp;        dprint(msg, new byte[0], 0, 0);</b>
<i>828</i>&nbsp;    }
<i>829</i>&nbsp;
<i>830</i>&nbsp;    private static void dprint(String msg, byte[] str) {
<b class="nc"><i>831</i>&nbsp;        dprint(msg, str, 0, str.length);</b>
<i>832</i>&nbsp;    }
<i>833</i>&nbsp;
<i>834</i>&nbsp;    private static void dprint(String msg, byte[] str, int start, int end) {
<b class="nc"><i>835</i>&nbsp;        String dstr = &quot;  &quot;;</b>
<b class="nc"><i>836</i>&nbsp;        int i = dbgIndent;</b>
<b class="nc"><i>837</i>&nbsp;        while (i-- &gt; 0) {</b>
<b class="nc"><i>838</i>&nbsp;            dstr += &quot;  &quot;;</b>
<i>839</i>&nbsp;        }
<b class="nc"><i>840</i>&nbsp;        dstr += msg;</b>
<i>841</i>&nbsp;
<b class="nc"><i>842</i>&nbsp;        System.err.print(dstr);</b>
<b class="nc"><i>843</i>&nbsp;        for (int j = start; j &lt; end; j++) {</b>
<b class="nc"><i>844</i>&nbsp;            System.err.print((char)str[j]);</b>
<i>845</i>&nbsp;        }
<b class="nc"><i>846</i>&nbsp;        System.err.println();</b>
<i>847</i>&nbsp;    }
<i>848</i>&nbsp;
<i>849</i>&nbsp;    /////////////// Constants used for encoding filter //////////////
<i>850</i>&nbsp;
<i>851</i>&nbsp;    static final int LDAP_FILTER_AND = 0xa0;
<i>852</i>&nbsp;    static final int LDAP_FILTER_OR = 0xa1;
<i>853</i>&nbsp;    static final int LDAP_FILTER_NOT = 0xa2;
<i>854</i>&nbsp;    static final int LDAP_FILTER_EQUALITY = 0xa3;
<i>855</i>&nbsp;    static final int LDAP_FILTER_SUBSTRINGS = 0xa4;
<i>856</i>&nbsp;    static final int LDAP_FILTER_GE = 0xa5;
<i>857</i>&nbsp;    static final int LDAP_FILTER_LE = 0xa6;
<i>858</i>&nbsp;    static final int LDAP_FILTER_PRESENT = 0x87;
<i>859</i>&nbsp;    static final int LDAP_FILTER_APPROX = 0xa8;
<i>860</i>&nbsp;    static final int LDAP_FILTER_EXT = 0xa9;            // LDAPv3
<i>861</i>&nbsp;
<i>862</i>&nbsp;    static final int LDAP_FILTER_EXT_RULE = 0x81;       // LDAPv3
<i>863</i>&nbsp;    static final int LDAP_FILTER_EXT_TYPE = 0x82;       // LDAPv3
<i>864</i>&nbsp;    static final int LDAP_FILTER_EXT_VAL = 0x83;        // LDAPv3
<i>865</i>&nbsp;    static final int LDAP_FILTER_EXT_DN = 0x84;         // LDAPv3
<i>866</i>&nbsp;
<i>867</i>&nbsp;    static final int LDAP_SUBSTRING_INITIAL = 0x80;
<i>868</i>&nbsp;    static final int LDAP_SUBSTRING_ANY = 0x81;
<i>869</i>&nbsp;    static final int LDAP_SUBSTRING_FINAL = 0x82;
<i>870</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
