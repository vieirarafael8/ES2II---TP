


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Win32ShellFolder2</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.awt.shell</a> ]
</div>

<h1>Coverage Summary for Class: Win32ShellFolder2 (sun.awt.shell)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Win32ShellFolder2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 170)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Win32ShellFolder2$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$ColumnComparator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$ColumnComparator$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$FolderDisposer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$FolderDisposer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Win32ShellFolder2$SystemIcon</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 97)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 368)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.awt.shell;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.awt.Image;
<i>29</i>&nbsp;import java.awt.Toolkit;
<i>30</i>&nbsp;import java.awt.image.AbstractMultiResolutionImage;
<i>31</i>&nbsp;import java.awt.image.BufferedImage;
<i>32</i>&nbsp;import java.awt.image.ImageObserver;
<i>33</i>&nbsp;import java.io.File;
<i>34</i>&nbsp;import java.io.FileNotFoundException;
<i>35</i>&nbsp;import java.io.IOException;
<i>36</i>&nbsp;import java.util.*;
<i>37</i>&nbsp;import java.util.concurrent.*;
<i>38</i>&nbsp;import javax.swing.SwingConstants;
<i>39</i>&nbsp;
<i>40</i>&nbsp;// NOTE: This class supersedes Win32ShellFolder, which was removed from
<i>41</i>&nbsp;//       distribution after version 1.4.2.
<i>42</i>&nbsp;
<i>43</i>&nbsp;/**
<i>44</i>&nbsp; * Win32 Shell Folders
<i>45</i>&nbsp; * &lt;P&gt;
<i>46</i>&nbsp; * &lt;BR&gt;
<i>47</i>&nbsp; * There are two fundamental types of shell folders : file system folders
<i>48</i>&nbsp; * and non-file system folders.  File system folders are relatively easy
<i>49</i>&nbsp; * to deal with.  Non-file system folders are items such as My Computer,
<i>50</i>&nbsp; * Network Neighborhood, and the desktop.  Some of these non-file system
<i>51</i>&nbsp; * folders have special values and properties.
<i>52</i>&nbsp; * &lt;P&gt;
<i>53</i>&nbsp; * &lt;BR&gt;
<i>54</i>&nbsp; * Win32 keeps two basic data structures for shell folders.  The first
<i>55</i>&nbsp; * of these is called an ITEMIDLIST.  Usually a pointer, called an
<i>56</i>&nbsp; * LPITEMIDLIST, or more frequently just &quot;PIDL&quot;.  This structure holds
<i>57</i>&nbsp; * a series of identifiers and can be either relative to the desktop
<i>58</i>&nbsp; * (an absolute PIDL), or relative to the shell folder that contains them.
<i>59</i>&nbsp; * Some Win32 functions can take absolute or relative PIDL values, and
<i>60</i>&nbsp; * others can only accept relative values.
<i>61</i>&nbsp; * &lt;BR&gt;
<i>62</i>&nbsp; * The second data structure is an IShellFolder COM interface.  Using
<i>63</i>&nbsp; * this interface, one can enumerate the relative PIDLs in a shell
<i>64</i>&nbsp; * folder, get attributes, etc.
<i>65</i>&nbsp; * &lt;BR&gt;
<i>66</i>&nbsp; * All Win32ShellFolder2 objects which are folder types (even non-file
<i>67</i>&nbsp; * system folders) contain an IShellFolder object. Files are named in
<i>68</i>&nbsp; * directories via relative PIDLs.
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * @author Michael Martak
<i>71</i>&nbsp; * @author Leif Samuelsson
<b class="nc"><i>72</i>&nbsp; * @author Kenneth Russell</b>
<i>73</i>&nbsp; * @since 1.4 */
<i>74</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // JDK-implementation class
<i>75</i>&nbsp;final class Win32ShellFolder2 extends ShellFolder {
<i>76</i>&nbsp;
<b class="nc"><i>77</i>&nbsp;    private static native void initIDs();</b>
<i>78</i>&nbsp;
<i>79</i>&nbsp;    static {
<i>80</i>&nbsp;        initIDs();
<i>81</i>&nbsp;    }
<i>82</i>&nbsp;
<i>83</i>&nbsp;    // Win32 Shell Folder Constants
<i>84</i>&nbsp;    public static final int DESKTOP = 0x0000;
<i>85</i>&nbsp;    public static final int INTERNET = 0x0001;
<i>86</i>&nbsp;    public static final int PROGRAMS = 0x0002;
<i>87</i>&nbsp;    public static final int CONTROLS = 0x0003;
<i>88</i>&nbsp;    public static final int PRINTERS = 0x0004;
<i>89</i>&nbsp;    public static final int PERSONAL = 0x0005;
<i>90</i>&nbsp;    public static final int FAVORITES = 0x0006;
<i>91</i>&nbsp;    public static final int STARTUP = 0x0007;
<i>92</i>&nbsp;    public static final int RECENT = 0x0008;
<i>93</i>&nbsp;    public static final int SENDTO = 0x0009;
<i>94</i>&nbsp;    public static final int BITBUCKET = 0x000a;
<i>95</i>&nbsp;    public static final int STARTMENU = 0x000b;
<i>96</i>&nbsp;    public static final int DESKTOPDIRECTORY = 0x0010;
<i>97</i>&nbsp;    public static final int DRIVES = 0x0011;
<i>98</i>&nbsp;    public static final int NETWORK = 0x0012;
<i>99</i>&nbsp;    public static final int NETHOOD = 0x0013;
<i>100</i>&nbsp;    public static final int FONTS = 0x0014;
<i>101</i>&nbsp;    public static final int TEMPLATES = 0x0015;
<i>102</i>&nbsp;    public static final int COMMON_STARTMENU = 0x0016;
<i>103</i>&nbsp;    public static final int COMMON_PROGRAMS = 0X0017;
<i>104</i>&nbsp;    public static final int COMMON_STARTUP = 0x0018;
<i>105</i>&nbsp;    public static final int COMMON_DESKTOPDIRECTORY = 0x0019;
<i>106</i>&nbsp;    public static final int APPDATA = 0x001a;
<i>107</i>&nbsp;    public static final int PRINTHOOD = 0x001b;
<i>108</i>&nbsp;    public static final int ALTSTARTUP = 0x001d;
<i>109</i>&nbsp;    public static final int COMMON_ALTSTARTUP = 0x001e;
<i>110</i>&nbsp;    public static final int COMMON_FAVORITES = 0x001f;
<i>111</i>&nbsp;    public static final int INTERNET_CACHE = 0x0020;
<i>112</i>&nbsp;    public static final int COOKIES = 0x0021;
<i>113</i>&nbsp;    public static final int HISTORY = 0x0022;
<i>114</i>&nbsp;
<i>115</i>&nbsp;    // Win32 shell folder attributes
<i>116</i>&nbsp;    public static final int ATTRIB_CANCOPY          = 0x00000001;
<i>117</i>&nbsp;    public static final int ATTRIB_CANMOVE          = 0x00000002;
<i>118</i>&nbsp;    public static final int ATTRIB_CANLINK          = 0x00000004;
<i>119</i>&nbsp;    public static final int ATTRIB_CANRENAME        = 0x00000010;
<i>120</i>&nbsp;    public static final int ATTRIB_CANDELETE        = 0x00000020;
<i>121</i>&nbsp;    public static final int ATTRIB_HASPROPSHEET     = 0x00000040;
<i>122</i>&nbsp;    public static final int ATTRIB_DROPTARGET       = 0x00000100;
<i>123</i>&nbsp;    public static final int ATTRIB_LINK             = 0x00010000;
<i>124</i>&nbsp;    public static final int ATTRIB_SHARE            = 0x00020000;
<i>125</i>&nbsp;    public static final int ATTRIB_READONLY         = 0x00040000;
<i>126</i>&nbsp;    public static final int ATTRIB_GHOSTED          = 0x00080000;
<i>127</i>&nbsp;    public static final int ATTRIB_HIDDEN           = 0x00080000;
<i>128</i>&nbsp;    public static final int ATTRIB_FILESYSANCESTOR  = 0x10000000;
<i>129</i>&nbsp;    public static final int ATTRIB_FOLDER           = 0x20000000;
<i>130</i>&nbsp;    public static final int ATTRIB_FILESYSTEM       = 0x40000000;
<i>131</i>&nbsp;    public static final int ATTRIB_HASSUBFOLDER     = 0x80000000;
<i>132</i>&nbsp;    public static final int ATTRIB_VALIDATE         = 0x01000000;
<i>133</i>&nbsp;    public static final int ATTRIB_REMOVABLE        = 0x02000000;
<i>134</i>&nbsp;    public static final int ATTRIB_COMPRESSED       = 0x04000000;
<i>135</i>&nbsp;    public static final int ATTRIB_BROWSABLE        = 0x08000000;
<i>136</i>&nbsp;    public static final int ATTRIB_NONENUMERATED    = 0x00100000;
<i>137</i>&nbsp;    public static final int ATTRIB_NEWCONTENT       = 0x00200000;
<i>138</i>&nbsp;
<i>139</i>&nbsp;    // IShellFolder::GetDisplayNameOf constants
<i>140</i>&nbsp;    public static final int SHGDN_NORMAL            = 0;
<i>141</i>&nbsp;    public static final int SHGDN_INFOLDER          = 1;
<i>142</i>&nbsp;    public static final int SHGDN_INCLUDE_NONFILESYS= 0x2000;
<i>143</i>&nbsp;    public static final int SHGDN_FORADDRESSBAR     = 0x4000;
<b class="nc"><i>144</i>&nbsp;    public static final int SHGDN_FORPARSING        = 0x8000;</b>
<b class="nc"><i>145</i>&nbsp;</b>
<b class="nc"><i>146</i>&nbsp;    /** The referent to be registered with the Disposer. */</b>
<b class="nc"><i>147</i>&nbsp;    private Object disposerReferent = new Object();</b>
<b class="nc"><i>148</i>&nbsp;</b>
<b class="nc"><i>149</i>&nbsp;    // Values for system call LoadIcon()</b>
<b class="nc"><i>150</i>&nbsp;    public enum SystemIcon {</b>
<b class="nc"><i>151</i>&nbsp;        IDI_APPLICATION(32512),</b>
<b class="nc"><i>152</i>&nbsp;        IDI_HAND(32513),</b>
<b class="nc"><i>153</i>&nbsp;        IDI_ERROR(32513),</b>
<i>154</i>&nbsp;        IDI_QUESTION(32514),
<i>155</i>&nbsp;        IDI_EXCLAMATION(32515),
<i>156</i>&nbsp;        IDI_WARNING(32515),
<b class="nc"><i>157</i>&nbsp;        IDI_ASTERISK(32516),</b>
<b class="nc"><i>158</i>&nbsp;        IDI_INFORMATION(32516),</b>
<i>159</i>&nbsp;        IDI_WINLOGO(32517);
<i>160</i>&nbsp;
<i>161</i>&nbsp;        private final int iconID;
<b class="nc"><i>162</i>&nbsp;</b>
<i>163</i>&nbsp;        SystemIcon(int iconID) {
<i>164</i>&nbsp;            this.iconID = iconID;
<i>165</i>&nbsp;        }
<b class="nc"><i>166</i>&nbsp;</b>
<i>167</i>&nbsp;        public int getIconID() {
<i>168</i>&nbsp;            return iconID;
<i>169</i>&nbsp;        }
<i>170</i>&nbsp;    }
<i>171</i>&nbsp;
<i>172</i>&nbsp;    // Known Folder data
<i>173</i>&nbsp;    static final class KnownFolderDefinition {
<i>174</i>&nbsp;        String guid;
<i>175</i>&nbsp;        int category;
<i>176</i>&nbsp;        String name;
<i>177</i>&nbsp;        String description;
<i>178</i>&nbsp;        String parent;
<i>179</i>&nbsp;        String relativePath;
<i>180</i>&nbsp;        String parsingName;
<b class="nc"><i>181</i>&nbsp;        String tooltip;</b>
<b class="nc"><i>182</i>&nbsp;        String localizedName;</b>
<i>183</i>&nbsp;        String icon;
<b class="nc"><i>184</i>&nbsp;        String security;</b>
<b class="nc"><i>185</i>&nbsp;        long attributes;</b>
<i>186</i>&nbsp;        int defenitionFlags;
<b class="nc"><i>187</i>&nbsp;        String ftidType;</b>
<b class="nc"><i>188</i>&nbsp;        String path;</b>
<i>189</i>&nbsp;        String saveLocation;
<b class="nc"><i>190</i>&nbsp;    }</b>
<b class="nc"><i>191</i>&nbsp;</b>
<i>192</i>&nbsp;    static final class KnownLibraries {
<b class="nc"><i>193</i>&nbsp;        static final List&lt;KnownFolderDefinition&gt; INSTANCE = getLibraries();</b>
<i>194</i>&nbsp;    }
<i>195</i>&nbsp;
<b class="nc"><i>196</i>&nbsp;    static class FolderDisposer implements sun.java2d.DisposerRecord {</b>
<i>197</i>&nbsp;        /*
<i>198</i>&nbsp;         * This is cached as a concession to getFolderType(), which needs
<b class="nc"><i>199</i>&nbsp;         * an absolute PIDL.</b>
<i>200</i>&nbsp;         */
<b class="nc"><i>201</i>&nbsp;        long absolutePIDL;</b>
<i>202</i>&nbsp;        /*
<i>203</i>&nbsp;         * We keep track of shell folders through the IShellFolder
<b class="nc"><i>204</i>&nbsp;         * interface of their parents plus their relative PIDL.</b>
<i>205</i>&nbsp;         */
<i>206</i>&nbsp;        long pIShellFolder;
<i>207</i>&nbsp;        long relativePIDL;
<i>208</i>&nbsp;
<b class="nc"><i>209</i>&nbsp;        boolean disposed;</b>
<b class="nc"><i>210</i>&nbsp;        public void dispose() {</b>
<b class="nc"><i>211</i>&nbsp;            if (disposed) return;</b>
<b class="nc"><i>212</i>&nbsp;            invoke(new Callable&lt;Void&gt;() {</b>
<b class="nc"><i>213</i>&nbsp;                public Void call() {</b>
<b class="nc"><i>214</i>&nbsp;                    if (relativePIDL != 0) {</b>
<i>215</i>&nbsp;                        releasePIDL(relativePIDL);
<i>216</i>&nbsp;                    }
<i>217</i>&nbsp;                    if (absolutePIDL != 0) {
<i>218</i>&nbsp;                        releasePIDL(absolutePIDL);
<i>219</i>&nbsp;                    }
<i>220</i>&nbsp;                    if (pIShellFolder != 0) {
<i>221</i>&nbsp;                        releaseIShellFolder(pIShellFolder);
<b class="nc"><i>222</i>&nbsp;                    }</b>
<b class="nc"><i>223</i>&nbsp;                    return null;</b>
<b class="nc"><i>224</i>&nbsp;                }</b>
<i>225</i>&nbsp;            });
<i>226</i>&nbsp;            disposed = true;
<i>227</i>&nbsp;        }
<i>228</i>&nbsp;    }
<i>229</i>&nbsp;    FolderDisposer disposer = new FolderDisposer();
<i>230</i>&nbsp;    private void setIShellFolder(long pIShellFolder) {
<i>231</i>&nbsp;        disposer.pIShellFolder = pIShellFolder;
<i>232</i>&nbsp;    }
<i>233</i>&nbsp;    private void setRelativePIDL(long relativePIDL) {
<i>234</i>&nbsp;        disposer.relativePIDL = relativePIDL;
<b class="nc"><i>235</i>&nbsp;    }</b>
<i>236</i>&nbsp;    /*
<b class="nc"><i>237</i>&nbsp;     * The following are for caching various shell folder properties.</b>
<i>238</i>&nbsp;     */
<b class="nc"><i>239</i>&nbsp;    private long pIShellIcon = -1L;</b>
<b class="nc"><i>240</i>&nbsp;    private String folderType = null;</b>
<i>241</i>&nbsp;    private String displayName = null;
<b class="nc"><i>242</i>&nbsp;    private Image smallIcon = null;</b>
<i>243</i>&nbsp;    private Image largeIcon = null;
<i>244</i>&nbsp;    private Boolean isDir = null;
<i>245</i>&nbsp;    private final boolean isLib;
<i>246</i>&nbsp;    private static final String FNAME = COLUMN_NAME;
<i>247</i>&nbsp;    private static final String FSIZE = COLUMN_SIZE;
<b class="nc"><i>248</i>&nbsp;    private static final String FTYPE = &quot;FileChooser.fileTypeHeaderText&quot;;</b>
<b class="nc"><i>249</i>&nbsp;    private static final String FDATE = COLUMN_DATE;</b>
<b class="nc"><i>250</i>&nbsp;</b>
<i>251</i>&nbsp;    /*
<b class="nc"><i>252</i>&nbsp;     * The following is to identify the My Documents folder as being special</b>
<b class="nc"><i>253</i>&nbsp;     */</b>
<i>254</i>&nbsp;    private boolean isPersonal;
<i>255</i>&nbsp;
<b class="nc"><i>256</i>&nbsp;    private static String composePathForCsidl(int csidl) throws IOException, InterruptedException {</b>
<b class="nc"><i>257</i>&nbsp;        String path = getFileSystemPath(csidl);</b>
<i>258</i>&nbsp;        return path == null
<i>259</i>&nbsp;                ? (&quot;ShellFolder: 0x&quot; + Integer.toHexString(csidl))
<i>260</i>&nbsp;                : path;
<b class="nc"><i>261</i>&nbsp;    }</b>
<i>262</i>&nbsp;
<i>263</i>&nbsp;    /**
<i>264</i>&nbsp;     * Create a system special shell folder, such as the
<b class="nc"><i>265</i>&nbsp;     * desktop or Network Neighborhood.</b>
<i>266</i>&nbsp;     */
<i>267</i>&nbsp;    Win32ShellFolder2(final int csidl) throws IOException, InterruptedException {
<i>268</i>&nbsp;        // Desktop is parent of DRIVES and NETWORK, not necessarily
<i>269</i>&nbsp;        // other special shell folders.
<b class="nc"><i>270</i>&nbsp;        super(null, composePathForCsidl(csidl));</b>
<i>271</i>&nbsp;        isLib = false;
<b class="nc"><i>272</i>&nbsp;</b>
<i>273</i>&nbsp;        invoke(new Callable&lt;Void&gt;() {
<i>274</i>&nbsp;            public Void call() throws InterruptedException {
<i>275</i>&nbsp;                if (csidl == DESKTOP) {
<b class="nc"><i>276</i>&nbsp;                    initDesktop();</b>
<i>277</i>&nbsp;                } else {
<i>278</i>&nbsp;                    initSpecial(getDesktop().getIShellFolder(), csidl);
<i>279</i>&nbsp;                    // At this point, the native method initSpecial() has set our relativePIDL
<i>280</i>&nbsp;                    // relative to the Desktop, which may not be our immediate parent. We need
<i>281</i>&nbsp;                    // to traverse this ID list and break it into a chain of shell folders from
<i>282</i>&nbsp;                    // the top, with each one having an immediate parent and a relativePIDL
<i>283</i>&nbsp;                    // relative to that parent.
<b class="nc"><i>284</i>&nbsp;                    long pIDL = disposer.relativePIDL;</b>
<b class="nc"><i>285</i>&nbsp;                    parent = getDesktop();</b>
<b class="nc"><i>286</i>&nbsp;                    while (pIDL != 0) {</b>
<b class="nc"><i>287</i>&nbsp;                        // Get a child pidl relative to &#39;parent&#39;</b>
<i>288</i>&nbsp;                        long childPIDL = copyFirstPIDLEntry(pIDL);
<i>289</i>&nbsp;                        if (childPIDL != 0) {
<i>290</i>&nbsp;                            // Get a handle to the rest of the ID list
<i>291</i>&nbsp;                            // i,e, parent&#39;s grandchilren and down
<i>292</i>&nbsp;                            pIDL = getNextPIDLEntry(pIDL);
<i>293</i>&nbsp;                            if (pIDL != 0) {
<i>294</i>&nbsp;                                // Now we know that parent isn&#39;t immediate to &#39;this&#39; because it
<b class="nc"><i>295</i>&nbsp;                                // has a continued ID list. Create a shell folder for this child</b>
<b class="nc"><i>296</i>&nbsp;                                // pidl and make it the new &#39;parent&#39;.</b>
<i>297</i>&nbsp;                                parent = createShellFolder((Win32ShellFolder2) parent, childPIDL);
<b class="nc"><i>298</i>&nbsp;                            } else {</b>
<i>299</i>&nbsp;                                // No grandchildren means we have arrived at the parent of &#39;this&#39;,
<i>300</i>&nbsp;                                // and childPIDL is directly relative to parent.
<i>301</i>&nbsp;                                disposer.relativePIDL = childPIDL;
<b class="nc"><i>302</i>&nbsp;                            }</b>
<b class="nc"><i>303</i>&nbsp;                        } else {</b>
<i>304</i>&nbsp;                            break;
<i>305</i>&nbsp;                        }
<i>306</i>&nbsp;                    }
<i>307</i>&nbsp;                }
<i>308</i>&nbsp;                return null;
<i>309</i>&nbsp;            }
<i>310</i>&nbsp;        }, InterruptedException.class);
<i>311</i>&nbsp;
<i>312</i>&nbsp;        sun.java2d.Disposer.addObjectRecord(disposerReferent, disposer);
<i>313</i>&nbsp;    }
<i>314</i>&nbsp;
<i>315</i>&nbsp;
<i>316</i>&nbsp;    /**
<b class="nc"><i>317</i>&nbsp;     * Create a system shell folder</b>
<i>318</i>&nbsp;     */
<i>319</i>&nbsp;    Win32ShellFolder2(Win32ShellFolder2 parent, long pIShellFolder, long relativePIDL, String path, boolean isLib) {
<i>320</i>&nbsp;        super(parent, (path != null) ? path : &quot;ShellFolder: &quot;);
<i>321</i>&nbsp;        this.isLib = isLib;
<i>322</i>&nbsp;        this.disposer.pIShellFolder = pIShellFolder;
<i>323</i>&nbsp;        this.disposer.relativePIDL = relativePIDL;
<i>324</i>&nbsp;        sun.java2d.Disposer.addObjectRecord(disposerReferent, disposer);
<i>325</i>&nbsp;    }
<i>326</i>&nbsp;
<i>327</i>&nbsp;
<i>328</i>&nbsp;    /**
<i>329</i>&nbsp;     * Creates a shell folder with a parent and relative PIDL
<i>330</i>&nbsp;     */
<i>331</i>&nbsp;    static Win32ShellFolder2 createShellFolder(Win32ShellFolder2 parent, long pIDL)
<b class="nc"><i>332</i>&nbsp;            throws InterruptedException {</b>
<i>333</i>&nbsp;        String path = invoke(new Callable&lt;String&gt;() {
<b class="nc"><i>334</i>&nbsp;            public String call() {</b>
<b class="nc"><i>335</i>&nbsp;                return getFileSystemPath(parent.getIShellFolder(), pIDL);</b>
<i>336</i>&nbsp;            }
<b class="nc"><i>337</i>&nbsp;        }, RuntimeException.class);</b>
<b class="nc"><i>338</i>&nbsp;        String libPath = resolveLibrary(path);</b>
<b class="nc"><i>339</i>&nbsp;        if (libPath == null) {</b>
<b class="nc"><i>340</i>&nbsp;            return new Win32ShellFolder2(parent, 0, pIDL, path, false);</b>
<b class="nc"><i>341</i>&nbsp;        } else {</b>
<b class="nc"><i>342</i>&nbsp;            return new Win32ShellFolder2(parent, 0, pIDL, libPath, true);</b>
<b class="nc"><i>343</i>&nbsp;        }</b>
<b class="nc"><i>344</i>&nbsp;    }</b>
<b class="nc"><i>345</i>&nbsp;</b>
<i>346</i>&nbsp;    // Initializes the desktop shell folder
<i>347</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>348</i>&nbsp;    private native void initDesktop();
<i>349</i>&nbsp;
<i>350</i>&nbsp;    // Initializes a special, non-file system shell folder
<i>351</i>&nbsp;    // from one of the above constants
<b class="nc"><i>352</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<i>353</i>&nbsp;    private native void initSpecial(long desktopIShellFolder, int csidl);
<i>354</i>&nbsp;
<i>355</i>&nbsp;    /** Marks this folder as being the My Documents (Personal) folder */
<i>356</i>&nbsp;    public void setIsPersonal() {
<i>357</i>&nbsp;        isPersonal = true;
<i>358</i>&nbsp;    }
<i>359</i>&nbsp;
<i>360</i>&nbsp;    /**
<i>361</i>&nbsp;     * This method is implemented to make sure that no instances
<i>362</i>&nbsp;     * of {@code ShellFolder} are ever serialized. If {@code isFileSystem()} returns
<b class="nc"><i>363</i>&nbsp;     * {@code true}, then the object is representable with an instance of</b>
<i>364</i>&nbsp;     * {@code java.io.File} instead. If not, then the object depends
<i>365</i>&nbsp;     * on native PIDL state and should not be serialized.
<i>366</i>&nbsp;     *
<i>367</i>&nbsp;     * @return a {@code java.io.File} replacement object. If the folder
<i>368</i>&nbsp;     * is a not a normal directory, then returns the first non-removable
<i>369</i>&nbsp;     * drive (normally &quot;C:\&quot;).
<i>370</i>&nbsp;     */
<i>371</i>&nbsp;    protected Object writeReplace() throws java.io.ObjectStreamException {
<i>372</i>&nbsp;        return invoke(new Callable&lt;File&gt;() {
<i>373</i>&nbsp;            public File call() {
<i>374</i>&nbsp;                if (isFileSystem()) {
<i>375</i>&nbsp;                    return new File(getPath());
<i>376</i>&nbsp;                } else {
<i>377</i>&nbsp;                    Win32ShellFolder2 drives = Win32ShellFolderManager2.getDrives();
<i>378</i>&nbsp;                    if (drives != null) {
<i>379</i>&nbsp;                        File[] driveRoots = drives.listFiles();
<i>380</i>&nbsp;                        if (driveRoots != null) {
<i>381</i>&nbsp;                            for (int i = 0; i &lt; driveRoots.length; i++) {
<i>382</i>&nbsp;                                if (driveRoots[i] instanceof Win32ShellFolder2) {
<i>383</i>&nbsp;                                    Win32ShellFolder2 sf = (Win32ShellFolder2) driveRoots[i];
<i>384</i>&nbsp;                                    if (sf.isFileSystem() &amp;&amp; !sf.hasAttribute(ATTRIB_REMOVABLE)) {
<i>385</i>&nbsp;                                        return new File(sf.getPath());
<i>386</i>&nbsp;                                    }
<i>387</i>&nbsp;                                }
<i>388</i>&nbsp;                            }
<i>389</i>&nbsp;                        }
<i>390</i>&nbsp;                    }
<i>391</i>&nbsp;                    // Ouch, we have no hard drives. Return something &quot;valid&quot; anyway.
<i>392</i>&nbsp;                    return new File(&quot;C:\\&quot;);
<i>393</i>&nbsp;                }
<i>394</i>&nbsp;            }
<i>395</i>&nbsp;        });
<b class="nc"><i>396</i>&nbsp;    }</b>
<i>397</i>&nbsp;
<b class="nc"><i>398</i>&nbsp;</b>
<i>399</i>&nbsp;    /**
<b class="nc"><i>400</i>&nbsp;     * Finalizer to clean up any COM objects or PIDLs used by this object.</b>
<b class="nc"><i>401</i>&nbsp;     */</b>
<b class="nc"><i>402</i>&nbsp;    protected void dispose() {</b>
<b class="nc"><i>403</i>&nbsp;        disposer.dispose();</b>
<b class="nc"><i>404</i>&nbsp;    }</b>
<b class="nc"><i>405</i>&nbsp;</b>
<i>406</i>&nbsp;
<i>407</i>&nbsp;    // Given a (possibly multi-level) relative PIDL (with respect to
<i>408</i>&nbsp;    // the desktop, at least in all of the usage cases in this code),
<i>409</i>&nbsp;    // return a pointer to the next entry. Does not mutate the PIDL in
<b class="nc"><i>410</i>&nbsp;    // any way. Returns 0 if the null terminator is reached.</b>
<i>411</i>&nbsp;    // Needs to be accessible to Win32ShellFolderManager2
<b class="nc"><i>412</i>&nbsp;    static native long getNextPIDLEntry(long pIDL);</b>
<b class="nc"><i>413</i>&nbsp;</b>
<b class="nc"><i>414</i>&nbsp;    // Given a (possibly multi-level) relative PIDL (with respect to</b>
<i>415</i>&nbsp;    // the desktop, at least in all of the usage cases in this code),
<b class="nc"><i>416</i>&nbsp;    // copy the first entry into a newly-allocated PIDL. Returns 0 if</b>
<i>417</i>&nbsp;    // the PIDL is at the end of the list.
<i>418</i>&nbsp;    // Needs to be accessible to Win32ShellFolderManager2
<b class="nc"><i>419</i>&nbsp;    static native long copyFirstPIDLEntry(long pIDL);</b>
<i>420</i>&nbsp;
<b class="nc"><i>421</i>&nbsp;    // Given a parent&#39;s absolute PIDL and our relative PIDL, build an absolute PIDL</b>
<i>422</i>&nbsp;    private static native long combinePIDLs(long ppIDL, long pIDL);
<b class="nc"><i>423</i>&nbsp;</b>
<i>424</i>&nbsp;    // Release a PIDL object
<i>425</i>&nbsp;    // Needs to be accessible to Win32ShellFolderManager2
<i>426</i>&nbsp;    static native void releasePIDL(long pIDL);
<i>427</i>&nbsp;
<i>428</i>&nbsp;    // Release an IShellFolder object
<i>429</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<b class="nc"><i>430</i>&nbsp;    private static native void releaseIShellFolder(long pIShellFolder);</b>
<b class="nc"><i>431</i>&nbsp;</b>
<i>432</i>&nbsp;    /**
<i>433</i>&nbsp;     * Accessor for IShellFolder
<b class="nc"><i>434</i>&nbsp;     */</b>
<i>435</i>&nbsp;    private long getIShellFolder() {
<b class="nc"><i>436</i>&nbsp;        if (disposer.pIShellFolder == 0) {</b>
<i>437</i>&nbsp;            try {
<i>438</i>&nbsp;                disposer.pIShellFolder = invoke(new Callable&lt;Long&gt;() {
<i>439</i>&nbsp;                    public Long call() {
<i>440</i>&nbsp;                        assert(isDirectory());
<i>441</i>&nbsp;                        assert(parent != null);
<i>442</i>&nbsp;                        long parentIShellFolder = getParentIShellFolder();
<b class="nc"><i>443</i>&nbsp;                        if (parentIShellFolder == 0) {</b>
<b class="nc"><i>444</i>&nbsp;                            throw new InternalError(&quot;Parent IShellFolder was null for &quot;</b>
<i>445</i>&nbsp;                                    + getAbsolutePath());
<b class="nc"><i>446</i>&nbsp;                        }</b>
<i>447</i>&nbsp;                        // We are a directory with a parent and a relative PIDL.
<i>448</i>&nbsp;                        // We want to bind to the parent so we get an
<i>449</i>&nbsp;                        // IShellFolder instance associated with us.
<b class="nc"><i>450</i>&nbsp;                        long pIShellFolder = bindToObject(parentIShellFolder,</b>
<i>451</i>&nbsp;                                disposer.relativePIDL);
<b class="nc"><i>452</i>&nbsp;                        if (pIShellFolder == 0) {</b>
<i>453</i>&nbsp;                            throw new InternalError(&quot;Unable to bind &quot;
<b class="nc"><i>454</i>&nbsp;                                    + getAbsolutePath() + &quot; to parent&quot;);</b>
<b class="nc"><i>455</i>&nbsp;                        }</b>
<i>456</i>&nbsp;                        return pIShellFolder;
<i>457</i>&nbsp;                    }
<b class="nc"><i>458</i>&nbsp;                }, RuntimeException.class);</b>
<i>459</i>&nbsp;            } catch (InterruptedException e) {
<i>460</i>&nbsp;                // Ignore error
<i>461</i>&nbsp;            }
<i>462</i>&nbsp;        }
<i>463</i>&nbsp;        return disposer.pIShellFolder;
<i>464</i>&nbsp;    }
<i>465</i>&nbsp;
<b class="nc"><i>466</i>&nbsp;    /**</b>
<i>467</i>&nbsp;     * Get the parent ShellFolder&#39;s IShellFolder interface
<i>468</i>&nbsp;     */
<i>469</i>&nbsp;    public long getParentIShellFolder() {
<i>470</i>&nbsp;        Win32ShellFolder2 parent = (Win32ShellFolder2)getParentFile();
<i>471</i>&nbsp;        if (parent == null) {
<i>472</i>&nbsp;            // Parent should only be null if this is the desktop, whose
<b class="nc"><i>473</i>&nbsp;            // relativePIDL is relative to its own IShellFolder.</b>
<i>474</i>&nbsp;            return getIShellFolder();
<i>475</i>&nbsp;        }
<i>476</i>&nbsp;        return parent.getIShellFolder();
<i>477</i>&nbsp;    }
<b class="nc"><i>478</i>&nbsp;</b>
<i>479</i>&nbsp;    /**
<i>480</i>&nbsp;     * Accessor for relative PIDL
<i>481</i>&nbsp;     */
<i>482</i>&nbsp;    public long getRelativePIDL() {
<i>483</i>&nbsp;        if (disposer.relativePIDL == 0) {
<i>484</i>&nbsp;            throw new InternalError(&quot;Should always have a relative PIDL&quot;);
<b class="nc"><i>485</i>&nbsp;        }</b>
<i>486</i>&nbsp;        return disposer.relativePIDL;
<b class="nc"><i>487</i>&nbsp;    }</b>
<b class="nc"><i>488</i>&nbsp;</b>
<i>489</i>&nbsp;    private long getAbsolutePIDL() {
<b class="nc"><i>490</i>&nbsp;        if (parent == null) {</b>
<i>491</i>&nbsp;            // This is the desktop
<b class="nc"><i>492</i>&nbsp;            return getRelativePIDL();</b>
<b class="nc"><i>493</i>&nbsp;        } else {</b>
<i>494</i>&nbsp;            if (disposer.absolutePIDL == 0) {
<b class="nc"><i>495</i>&nbsp;                disposer.absolutePIDL = combinePIDLs(((Win32ShellFolder2)parent).getAbsolutePIDL(), getRelativePIDL());</b>
<i>496</i>&nbsp;            }
<i>497</i>&nbsp;
<b class="nc"><i>498</i>&nbsp;            return disposer.absolutePIDL;</b>
<i>499</i>&nbsp;        }
<b class="nc"><i>500</i>&nbsp;    }</b>
<b class="nc"><i>501</i>&nbsp;</b>
<i>502</i>&nbsp;    /**
<i>503</i>&nbsp;     * Helper function to return the desktop
<b class="nc"><i>504</i>&nbsp;     */</b>
<i>505</i>&nbsp;    public Win32ShellFolder2 getDesktop() {
<b class="nc"><i>506</i>&nbsp;        return Win32ShellFolderManager2.getDesktop();</b>
<b class="nc"><i>507</i>&nbsp;    }</b>
<b class="nc"><i>508</i>&nbsp;</b>
<i>509</i>&nbsp;    /**
<i>510</i>&nbsp;     * Helper function to return the desktop IShellFolder interface
<i>511</i>&nbsp;     */
<b class="nc"><i>512</i>&nbsp;    public long getDesktopIShellFolder() {</b>
<i>513</i>&nbsp;        return getDesktop().getIShellFolder();
<i>514</i>&nbsp;    }
<i>515</i>&nbsp;
<i>516</i>&nbsp;    private static boolean pathsEqual(String path1, String path2) {
<b class="nc"><i>517</i>&nbsp;        // Same effective implementation as Win32FileSystem</b>
<i>518</i>&nbsp;        return path1.equalsIgnoreCase(path2);
<b class="nc"><i>519</i>&nbsp;    }</b>
<i>520</i>&nbsp;
<i>521</i>&nbsp;    /**
<i>522</i>&nbsp;     * Check to see if two ShellFolder objects are the same
<i>523</i>&nbsp;     */
<i>524</i>&nbsp;    public boolean equals(Object o) {
<i>525</i>&nbsp;        if (o == null || !(o instanceof Win32ShellFolder2)) {
<i>526</i>&nbsp;            // Short-circuit circuitous delegation path
<i>527</i>&nbsp;            if (!(o instanceof File)) {
<i>528</i>&nbsp;                return super.equals(o);
<i>529</i>&nbsp;            }
<i>530</i>&nbsp;            return pathsEqual(getPath(), ((File) o).getPath());
<i>531</i>&nbsp;        }
<i>532</i>&nbsp;        Win32ShellFolder2 rhs = (Win32ShellFolder2) o;
<b class="nc"><i>533</i>&nbsp;        if ((parent == null &amp;&amp; rhs.parent != null) ||</b>
<b class="nc"><i>534</i>&nbsp;            (parent != null &amp;&amp; rhs.parent == null)) {</b>
<i>535</i>&nbsp;            return false;
<i>536</i>&nbsp;        }
<b class="nc"><i>537</i>&nbsp;</b>
<i>538</i>&nbsp;        if (isFileSystem() &amp;&amp; rhs.isFileSystem()) {
<i>539</i>&nbsp;            // Only folders with identical parents can be equal
<i>540</i>&nbsp;            return (pathsEqual(getPath(), rhs.getPath()) &amp;&amp;
<i>541</i>&nbsp;                    (parent == rhs.parent || parent.equals(rhs.parent)));
<i>542</i>&nbsp;        }
<i>543</i>&nbsp;
<b class="nc"><i>544</i>&nbsp;        if (parent == rhs.parent || parent.equals(rhs.parent)) {</b>
<i>545</i>&nbsp;            try {
<i>546</i>&nbsp;                return pidlsEqual(getParentIShellFolder(), disposer.relativePIDL, rhs.disposer.relativePIDL);
<b class="nc"><i>547</i>&nbsp;            } catch (InterruptedException e) {</b>
<b class="nc"><i>548</i>&nbsp;                return false;</b>
<i>549</i>&nbsp;            }
<i>550</i>&nbsp;        }
<i>551</i>&nbsp;
<i>552</i>&nbsp;        return false;
<b class="nc"><i>553</i>&nbsp;    }</b>
<i>554</i>&nbsp;
<i>555</i>&nbsp;    private static boolean pidlsEqual(final long pIShellFolder, final long pidl1, final long pidl2)
<i>556</i>&nbsp;            throws InterruptedException {
<i>557</i>&nbsp;        return invoke(new Callable&lt;Boolean&gt;() {
<i>558</i>&nbsp;            public Boolean call() {
<i>559</i>&nbsp;                return compareIDs(pIShellFolder, pidl1, pidl2) == 0;
<i>560</i>&nbsp;            }
<i>561</i>&nbsp;        }, RuntimeException.class);
<i>562</i>&nbsp;    }
<i>563</i>&nbsp;
<i>564</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>565</i>&nbsp;    private static native int compareIDs(long pParentIShellFolder, long pidl1, long pidl2);
<i>566</i>&nbsp;
<i>567</i>&nbsp;    private volatile Boolean cachedIsFileSystem;
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /**
<b class="nc"><i>570</i>&nbsp;     * @return Whether this is a file system shell folder</b>
<b class="nc"><i>571</i>&nbsp;     */</b>
<b class="nc"><i>572</i>&nbsp;    public boolean isFileSystem() {</b>
<i>573</i>&nbsp;        if (cachedIsFileSystem == null) {
<i>574</i>&nbsp;            cachedIsFileSystem = hasAttribute(ATTRIB_FILESYSTEM);
<b class="nc"><i>575</i>&nbsp;        }</b>
<b class="nc"><i>576</i>&nbsp;</b>
<b class="nc"><i>577</i>&nbsp;        return cachedIsFileSystem;</b>
<b class="nc"><i>578</i>&nbsp;    }</b>
<i>579</i>&nbsp;
<i>580</i>&nbsp;    /**
<b class="nc"><i>581</i>&nbsp;     * Return whether the given attribute flag is set for this object</b>
<i>582</i>&nbsp;     */
<i>583</i>&nbsp;    public boolean hasAttribute(final int attribute) {
<i>584</i>&nbsp;        Boolean result = invoke(new Callable&lt;Boolean&gt;() {
<i>585</i>&nbsp;            public Boolean call() {
<b class="nc"><i>586</i>&nbsp;                // Caching at this point doesn&#39;t seem to be cost efficient</b>
<i>587</i>&nbsp;                return (getAttributes0(getParentIShellFolder(),
<b class="nc"><i>588</i>&nbsp;                    getRelativePIDL(), attribute)</b>
<i>589</i>&nbsp;                    &amp; attribute) != 0;
<i>590</i>&nbsp;            }
<b class="nc"><i>591</i>&nbsp;        });</b>
<b class="nc"><i>592</i>&nbsp;</b>
<b class="nc"><i>593</i>&nbsp;        return result != null &amp;&amp; result;</b>
<b class="nc"><i>594</i>&nbsp;    }</b>
<i>595</i>&nbsp;
<i>596</i>&nbsp;    /**
<b class="nc"><i>597</i>&nbsp;     * Returns the queried attributes specified in attrsMask.</b>
<i>598</i>&nbsp;     *
<i>599</i>&nbsp;     * Could plausibly be used for attribute caching but have to be
<i>600</i>&nbsp;     * very careful not to touch network drives and file system roots
<i>601</i>&nbsp;     * with a full attrsMask
<i>602</i>&nbsp;     * NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>603</i>&nbsp;     */
<i>604</i>&nbsp;
<i>605</i>&nbsp;    private static native int getAttributes0(long pParentIShellFolder, long pIDL, int attrsMask);
<b class="nc"><i>606</i>&nbsp;</b>
<i>607</i>&nbsp;    // Return the path to the underlying file system object
<i>608</i>&nbsp;    // Should be called from the COM thread
<i>609</i>&nbsp;    private static String getFileSystemPath(final long parentIShellFolder, final long relativePIDL) {
<i>610</i>&nbsp;        int linkedFolder = ATTRIB_LINK | ATTRIB_FOLDER;
<i>611</i>&nbsp;        if (parentIShellFolder == Win32ShellFolderManager2.getNetwork().getIShellFolder() &amp;&amp;
<i>612</i>&nbsp;                getAttributes0(parentIShellFolder, relativePIDL, linkedFolder) == linkedFolder) {
<i>613</i>&nbsp;
<b class="nc"><i>614</i>&nbsp;            String s =</b>
<i>615</i>&nbsp;                    getFileSystemPath(Win32ShellFolderManager2.getDesktop().getIShellFolder(),
<i>616</i>&nbsp;                            getLinkLocation(parentIShellFolder, relativePIDL, false));
<i>617</i>&nbsp;            if (s != null &amp;&amp; s.startsWith(&quot;\\\\&quot;)) {
<b class="nc"><i>618</i>&nbsp;                return s;</b>
<i>619</i>&nbsp;            }
<i>620</i>&nbsp;        }
<b class="nc"><i>621</i>&nbsp;        String path = getDisplayNameOf(parentIShellFolder, relativePIDL,</b>
<b class="nc"><i>622</i>&nbsp;                        SHGDN_FORPARSING);</b>
<b class="nc"><i>623</i>&nbsp;        return path;</b>
<b class="nc"><i>624</i>&nbsp;    }</b>
<b class="nc"><i>625</i>&nbsp;</b>
<b class="nc"><i>626</i>&nbsp;    private static String resolveLibrary(String path) {</b>
<b class="nc"><i>627</i>&nbsp;        // if this is a library its default save location is taken as a path</b>
<i>628</i>&nbsp;        // this is a temp fix until java.io starts support Libraries
<i>629</i>&nbsp;        if( path != null &amp;&amp; path.startsWith(&quot;::{&quot;) &amp;&amp;
<b class="nc"><i>630</i>&nbsp;                path.toLowerCase().endsWith(&quot;.library-ms&quot;)) {</b>
<i>631</i>&nbsp;            for (KnownFolderDefinition kf : KnownLibraries.INSTANCE) {
<i>632</i>&nbsp;                if (path.toLowerCase().endsWith(
<i>633</i>&nbsp;                        &quot;\\&quot; + kf.relativePath.toLowerCase()) &amp;&amp;
<i>634</i>&nbsp;                        path.toUpperCase().startsWith(
<i>635</i>&nbsp;                        kf.parsingName.substring(0, 40).toUpperCase())) {
<i>636</i>&nbsp;                    return kf.saveLocation;
<i>637</i>&nbsp;                }
<i>638</i>&nbsp;            }
<b class="nc"><i>639</i>&nbsp;        }</b>
<i>640</i>&nbsp;        return null;
<b class="nc"><i>641</i>&nbsp;    }</b>
<i>642</i>&nbsp;
<b class="nc"><i>643</i>&nbsp;    // Needs to be accessible to Win32ShellFolderManager2</b>
<i>644</i>&nbsp;    static String getFileSystemPath(final int csidl) throws IOException, InterruptedException {
<i>645</i>&nbsp;        String path = invoke(new Callable&lt;String&gt;() {
<i>646</i>&nbsp;            public String call() throws IOException {
<i>647</i>&nbsp;                return getFileSystemPath0(csidl);
<i>648</i>&nbsp;            }
<i>649</i>&nbsp;        }, IOException.class);
<i>650</i>&nbsp;        if (path != null) {
<i>651</i>&nbsp;            SecurityManager security = System.getSecurityManager();
<i>652</i>&nbsp;            if (security != null) {
<i>653</i>&nbsp;                security.checkRead(path);
<i>654</i>&nbsp;            }
<i>655</i>&nbsp;        }
<i>656</i>&nbsp;        return path;
<i>657</i>&nbsp;    }
<i>658</i>&nbsp;
<i>659</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>660</i>&nbsp;    private static native String getFileSystemPath0(int csidl) throws IOException;
<i>661</i>&nbsp;
<i>662</i>&nbsp;    // Return whether the path is a network root.
<i>663</i>&nbsp;    // Path is assumed to be non-null
<i>664</i>&nbsp;    private static boolean isNetworkRoot(String path) {
<i>665</i>&nbsp;        return (path.equals(&quot;\\\\&quot;) || path.equals(&quot;\\&quot;) || path.equals(&quot;//&quot;) || path.equals(&quot;/&quot;));
<i>666</i>&nbsp;    }
<i>667</i>&nbsp;
<i>668</i>&nbsp;    /**
<i>669</i>&nbsp;     * @return The parent shell folder of this shell folder, null if
<i>670</i>&nbsp;     * there is no parent
<i>671</i>&nbsp;     */
<i>672</i>&nbsp;    public File getParentFile() {
<i>673</i>&nbsp;        return parent;
<b class="nc"><i>674</i>&nbsp;    }</b>
<b class="nc"><i>675</i>&nbsp;</b>
<b class="nc"><i>676</i>&nbsp;    public boolean isDirectory() {</b>
<i>677</i>&nbsp;        if (isDir == null) {
<i>678</i>&nbsp;            // Folders with SFGAO_BROWSABLE have &quot;shell extension&quot; handlers and are
<i>679</i>&nbsp;            // not traversable in JFileChooser.
<b class="nc"><i>680</i>&nbsp;            if (hasAttribute(ATTRIB_FOLDER) &amp;&amp; !hasAttribute(ATTRIB_BROWSABLE)) {</b>
<i>681</i>&nbsp;                isDir = Boolean.TRUE;
<b class="nc"><i>682</i>&nbsp;            } else if (isLink()) {</b>
<b class="nc"><i>683</i>&nbsp;                ShellFolder linkLocation = getLinkLocation(false);</b>
<i>684</i>&nbsp;                isDir = Boolean.valueOf(linkLocation != null &amp;&amp; linkLocation.isDirectory());
<i>685</i>&nbsp;            } else {
<i>686</i>&nbsp;                isDir = Boolean.FALSE;
<i>687</i>&nbsp;            }
<b class="nc"><i>688</i>&nbsp;        }</b>
<b class="nc"><i>689</i>&nbsp;        return isDir.booleanValue();</b>
<i>690</i>&nbsp;    }
<i>691</i>&nbsp;
<b class="nc"><i>692</i>&nbsp;    /*</b>
<b class="nc"><i>693</i>&nbsp;     * Functions for enumerating an IShellFolder&#39;s children</b>
<i>694</i>&nbsp;     */
<i>695</i>&nbsp;    // Returns an IEnumIDList interface for an IShellFolder.  The value
<i>696</i>&nbsp;    // returned must be released using releaseEnumObjects().
<i>697</i>&nbsp;    private long getEnumObjects(final boolean includeHiddenFiles) throws InterruptedException {
<b class="nc"><i>698</i>&nbsp;        return invoke(new Callable&lt;Long&gt;() {</b>
<i>699</i>&nbsp;            public Long call() {
<b class="nc"><i>700</i>&nbsp;                boolean isDesktop = disposer.pIShellFolder == getDesktopIShellFolder();</b>
<b class="nc"><i>701</i>&nbsp;</b>
<b class="nc"><i>702</i>&nbsp;                return getEnumObjects(disposer.pIShellFolder, isDesktop, includeHiddenFiles);</b>
<i>703</i>&nbsp;            }
<i>704</i>&nbsp;        }, RuntimeException.class);
<b class="nc"><i>705</i>&nbsp;    }</b>
<i>706</i>&nbsp;
<b class="nc"><i>707</i>&nbsp;    // Returns an IEnumIDList interface for an IShellFolder.  The value</b>
<b class="nc"><i>708</i>&nbsp;    // returned must be released using releaseEnumObjects().</b>
<b class="nc"><i>709</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<b class="nc"><i>710</i>&nbsp;    private native long getEnumObjects(long pIShellFolder, boolean isDesktop,</b>
<i>711</i>&nbsp;                                       boolean includeHiddenFiles);
<b class="nc"><i>712</i>&nbsp;    // Returns the next sequential child as a relative PIDL</b>
<i>713</i>&nbsp;    // from an IEnumIDList interface.  The value returned must
<b class="nc"><i>714</i>&nbsp;    // be released using releasePIDL().</b>
<b class="nc"><i>715</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<i>716</i>&nbsp;    private native long getNextChild(long pEnumObjects);
<b class="nc"><i>717</i>&nbsp;    // Releases the IEnumIDList interface</b>
<b class="nc"><i>718</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<i>719</i>&nbsp;    private native void releaseEnumObjects(long pEnumObjects);
<b class="nc"><i>720</i>&nbsp;</b>
<i>721</i>&nbsp;    // Returns the IShellFolder of a child from a parent IShellFolder
<b class="nc"><i>722</i>&nbsp;    // and a relative PIDL.  The value returned must be released</b>
<b class="nc"><i>723</i>&nbsp;    // using releaseIShellFolder().</b>
<i>724</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<b class="nc"><i>725</i>&nbsp;    private static native long bindToObject(long parentIShellFolder, long pIDL);</b>
<i>726</i>&nbsp;
<b class="nc"><i>727</i>&nbsp;    /**</b>
<b class="nc"><i>728</i>&nbsp;     * @return An array of shell folders that are children of this shell folder</b>
<i>729</i>&nbsp;     *         object. The array will be empty if the folder is empty.  Returns
<b class="nc"><i>730</i>&nbsp;     *         {@code null} if this shellfolder does not denote a directory.</b>
<i>731</i>&nbsp;     */
<b class="nc"><i>732</i>&nbsp;    public File[] listFiles(final boolean includeHiddenFiles) {</b>
<i>733</i>&nbsp;        SecurityManager security = System.getSecurityManager();
<i>734</i>&nbsp;        if (security != null) {
<b class="nc"><i>735</i>&nbsp;            security.checkRead(getPath());</b>
<b class="nc"><i>736</i>&nbsp;        }</b>
<i>737</i>&nbsp;
<i>738</i>&nbsp;        try {
<i>739</i>&nbsp;            File[] files = invoke(new Callable&lt;File[]&gt;() {
<i>740</i>&nbsp;                public File[] call() throws InterruptedException {
<i>741</i>&nbsp;                    if (!isDirectory()) {
<i>742</i>&nbsp;                        return null;
<i>743</i>&nbsp;                    }
<i>744</i>&nbsp;                    // Links to directories are not directories and cannot be parents.
<i>745</i>&nbsp;                    // This does not apply to folders in My Network Places (NetHood)
<i>746</i>&nbsp;                    // because they are both links and real directories!
<b class="nc"><i>747</i>&nbsp;                    if (isLink() &amp;&amp; !hasAttribute(ATTRIB_FOLDER)) {</b>
<i>748</i>&nbsp;                        return new File[0];
<b class="nc"><i>749</i>&nbsp;                    }</b>
<b class="nc"><i>750</i>&nbsp;</b>
<b class="nc"><i>751</i>&nbsp;                    Win32ShellFolder2 desktop = Win32ShellFolderManager2.getDesktop();</b>
<i>752</i>&nbsp;                    Win32ShellFolder2 personal = Win32ShellFolderManager2.getPersonal();
<i>753</i>&nbsp;
<b class="nc"><i>754</i>&nbsp;                    // If we are a directory, we have a parent and (at least) a</b>
<b class="nc"><i>755</i>&nbsp;                    // relative PIDL. We must first ensure we are bound to the</b>
<b class="nc"><i>756</i>&nbsp;                    // parent so we have an IShellFolder to query.</b>
<b class="nc"><i>757</i>&nbsp;                    long pIShellFolder = getIShellFolder();</b>
<b class="nc"><i>758</i>&nbsp;                    // Now we can enumerate the objects in this folder.</b>
<b class="nc"><i>759</i>&nbsp;                    ArrayList&lt;Win32ShellFolder2&gt; list = new ArrayList&lt;Win32ShellFolder2&gt;();</b>
<i>760</i>&nbsp;                    long pEnumObjects = getEnumObjects(includeHiddenFiles);
<b class="nc"><i>761</i>&nbsp;                    if (pEnumObjects != 0) {</b>
<i>762</i>&nbsp;                        try {
<i>763</i>&nbsp;                            long childPIDL;
<b class="nc"><i>764</i>&nbsp;                            int testedAttrs = ATTRIB_FILESYSTEM | ATTRIB_FILESYSANCESTOR;</b>
<i>765</i>&nbsp;                            do {
<b class="nc"><i>766</i>&nbsp;                                childPIDL = getNextChild(pEnumObjects);</b>
<b class="nc"><i>767</i>&nbsp;                                boolean releasePIDL = true;</b>
<i>768</i>&nbsp;                                if (childPIDL != 0 &amp;&amp;
<i>769</i>&nbsp;                                        (getAttributes0(pIShellFolder, childPIDL, testedAttrs) &amp; testedAttrs) != 0) {
<i>770</i>&nbsp;                                    Win32ShellFolder2 childFolder;
<i>771</i>&nbsp;                                    if (Win32ShellFolder2.this.equals(desktop)
<i>772</i>&nbsp;                                            &amp;&amp; personal != null
<i>773</i>&nbsp;                                            &amp;&amp; pidlsEqual(pIShellFolder, childPIDL, personal.disposer.relativePIDL)) {
<i>774</i>&nbsp;                                        childFolder = personal;
<i>775</i>&nbsp;                                    } else {
<i>776</i>&nbsp;                                        childFolder = createShellFolder(Win32ShellFolder2.this, childPIDL);
<i>777</i>&nbsp;                                        releasePIDL = false;
<b class="nc"><i>778</i>&nbsp;                                    }</b>
<b class="nc"><i>779</i>&nbsp;                                    list.add(childFolder);</b>
<i>780</i>&nbsp;                                }
<i>781</i>&nbsp;                                if (releasePIDL) {
<b class="nc"><i>782</i>&nbsp;                                    releasePIDL(childPIDL);</b>
<i>783</i>&nbsp;                                }
<i>784</i>&nbsp;                            } while (childPIDL != 0 &amp;&amp; !Thread.currentThread().isInterrupted());
<i>785</i>&nbsp;                        } finally {
<i>786</i>&nbsp;                            releaseEnumObjects(pEnumObjects);
<i>787</i>&nbsp;                        }
<i>788</i>&nbsp;                    }
<b class="nc"><i>789</i>&nbsp;                    return Thread.currentThread().isInterrupted()</b>
<i>790</i>&nbsp;                        ? new File[0]
<i>791</i>&nbsp;                        : list.toArray(new ShellFolder[list.size()]);
<i>792</i>&nbsp;                }
<i>793</i>&nbsp;            }, InterruptedException.class);
<i>794</i>&nbsp;
<i>795</i>&nbsp;            return Win32ShellFolderManager2.checkFiles(files);
<i>796</i>&nbsp;        } catch (InterruptedException e) {
<i>797</i>&nbsp;            return new File[0];
<i>798</i>&nbsp;        }
<i>799</i>&nbsp;    }
<i>800</i>&nbsp;
<i>801</i>&nbsp;
<i>802</i>&nbsp;    /**
<b class="nc"><i>803</i>&nbsp;     * Look for (possibly special) child folder by it&#39;s path</b>
<i>804</i>&nbsp;     *
<i>805</i>&nbsp;     * @return The child shellfolder, or null if not found.
<i>806</i>&nbsp;     */
<b class="nc"><i>807</i>&nbsp;    Win32ShellFolder2 getChildByPath(final String filePath) throws InterruptedException {</b>
<i>808</i>&nbsp;        return invoke(new Callable&lt;Win32ShellFolder2&gt;() {
<b class="nc"><i>809</i>&nbsp;            public Win32ShellFolder2 call() throws InterruptedException {</b>
<b class="nc"><i>810</i>&nbsp;                long pIShellFolder = getIShellFolder();</b>
<i>811</i>&nbsp;                long pEnumObjects = getEnumObjects(true);
<i>812</i>&nbsp;                Win32ShellFolder2 child = null;
<b class="nc"><i>813</i>&nbsp;                long childPIDL;</b>
<b class="nc"><i>814</i>&nbsp;</b>
<b class="nc"><i>815</i>&nbsp;                while ((childPIDL = getNextChild(pEnumObjects)) != 0) {</b>
<b class="nc"><i>816</i>&nbsp;                    if (getAttributes0(pIShellFolder, childPIDL, ATTRIB_FILESYSTEM) != 0) {</b>
<i>817</i>&nbsp;                        String path = getFileSystemPath(pIShellFolder, childPIDL);
<b class="nc"><i>818</i>&nbsp;                        if(isLib) path = resolveLibrary( path );</b>
<b class="nc"><i>819</i>&nbsp;                        if (path != null &amp;&amp; path.equalsIgnoreCase(filePath)) {</b>
<i>820</i>&nbsp;                            long childIShellFolder = bindToObject(pIShellFolder, childPIDL);
<b class="nc"><i>821</i>&nbsp;                            child = new Win32ShellFolder2(Win32ShellFolder2.this,</b>
<i>822</i>&nbsp;                                    childIShellFolder, childPIDL, path, isLib);
<b class="nc"><i>823</i>&nbsp;                            break;</b>
<i>824</i>&nbsp;                        }
<i>825</i>&nbsp;                    }
<b class="nc"><i>826</i>&nbsp;                    releasePIDL(childPIDL);</b>
<i>827</i>&nbsp;                }
<b class="nc"><i>828</i>&nbsp;                releaseEnumObjects(pEnumObjects);</b>
<i>829</i>&nbsp;                return child;
<i>830</i>&nbsp;            }
<i>831</i>&nbsp;        }, InterruptedException.class);
<i>832</i>&nbsp;    }
<i>833</i>&nbsp;
<i>834</i>&nbsp;    private volatile Boolean cachedIsLink;
<b class="nc"><i>835</i>&nbsp;</b>
<i>836</i>&nbsp;    /**
<b class="nc"><i>837</i>&nbsp;     * @return Whether this shell folder is a link</b>
<i>838</i>&nbsp;     */
<i>839</i>&nbsp;    public boolean isLink() {
<i>840</i>&nbsp;        if (cachedIsLink == null) {
<i>841</i>&nbsp;            cachedIsLink = hasAttribute(ATTRIB_LINK);
<i>842</i>&nbsp;        }
<i>843</i>&nbsp;
<i>844</i>&nbsp;        return cachedIsLink;
<i>845</i>&nbsp;    }
<i>846</i>&nbsp;
<i>847</i>&nbsp;    /**
<i>848</i>&nbsp;     * @return Whether this shell folder is marked as hidden
<i>849</i>&nbsp;     */
<i>850</i>&nbsp;    public boolean isHidden() {
<i>851</i>&nbsp;        return hasAttribute(ATTRIB_HIDDEN);
<i>852</i>&nbsp;    }
<i>853</i>&nbsp;
<i>854</i>&nbsp;
<b class="nc"><i>855</i>&nbsp;    // Return the link location of a shell folder</b>
<b class="nc"><i>856</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<b class="nc"><i>857</i>&nbsp;    private static native long getLinkLocation(long parentIShellFolder,</b>
<i>858</i>&nbsp;                                        long relativePIDL, boolean resolve);
<b class="nc"><i>859</i>&nbsp;</b>
<b class="nc"><i>860</i>&nbsp;    /**</b>
<i>861</i>&nbsp;     * @return The shell folder linked to by this shell folder, or null
<i>862</i>&nbsp;     * if this shell folder is not a link or is a broken or invalid link
<i>863</i>&nbsp;     */
<b class="nc"><i>864</i>&nbsp;    public ShellFolder getLinkLocation()  {</b>
<i>865</i>&nbsp;        return getLinkLocation(true);
<i>866</i>&nbsp;    }
<i>867</i>&nbsp;
<i>868</i>&nbsp;    private Win32ShellFolder2 getLinkLocation(final boolean resolve) {
<i>869</i>&nbsp;        return invoke(new Callable&lt;Win32ShellFolder2&gt;() {
<i>870</i>&nbsp;            public Win32ShellFolder2 call() {
<i>871</i>&nbsp;                if (!isLink()) {
<i>872</i>&nbsp;                    return null;
<i>873</i>&nbsp;                }
<i>874</i>&nbsp;
<b class="nc"><i>875</i>&nbsp;                Win32ShellFolder2 location = null;</b>
<b class="nc"><i>876</i>&nbsp;                long linkLocationPIDL = getLinkLocation(getParentIShellFolder(),</b>
<b class="nc"><i>877</i>&nbsp;                        getRelativePIDL(), resolve);</b>
<b class="nc"><i>878</i>&nbsp;                if (linkLocationPIDL != 0) {</b>
<i>879</i>&nbsp;                    try {
<b class="nc"><i>880</i>&nbsp;                        location =</b>
<i>881</i>&nbsp;                                Win32ShellFolderManager2.createShellFolderFromRelativePIDL(getDesktop(),
<i>882</i>&nbsp;                                        linkLocationPIDL);
<i>883</i>&nbsp;                    } catch (InterruptedException e) {
<b class="nc"><i>884</i>&nbsp;                        // Return null</b>
<i>885</i>&nbsp;                    } catch (InternalError e) {
<i>886</i>&nbsp;                        // Could be a link to a non-bindable object, such as a network connection
<i>887</i>&nbsp;                        // TODO: getIShellFolder() should throw FileNotFoundException instead
<i>888</i>&nbsp;                    }
<i>889</i>&nbsp;                }
<i>890</i>&nbsp;                return location;
<i>891</i>&nbsp;            }
<i>892</i>&nbsp;        });
<i>893</i>&nbsp;    }
<b class="nc"><i>894</i>&nbsp;</b>
<b class="nc"><i>895</i>&nbsp;    // Parse a display name into a PIDL relative to the current IShellFolder.</b>
<i>896</i>&nbsp;    long parseDisplayName(final String name) throws IOException, InterruptedException {
<b class="nc"><i>897</i>&nbsp;        return invoke(new Callable&lt;Long&gt;() {</b>
<i>898</i>&nbsp;            public Long call() throws IOException {
<i>899</i>&nbsp;                return parseDisplayName0(getIShellFolder(), name);
<i>900</i>&nbsp;            }
<i>901</i>&nbsp;        }, IOException.class);
<i>902</i>&nbsp;    }
<i>903</i>&nbsp;
<b class="nc"><i>904</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details</b>
<b class="nc"><i>905</i>&nbsp;    private static native long parseDisplayName0(long pIShellFolder, String name) throws IOException;</b>
<b class="nc"><i>906</i>&nbsp;</b>
<b class="nc"><i>907</i>&nbsp;    // Return the display name of a shell folder</b>
<i>908</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>909</i>&nbsp;    private static native String getDisplayNameOf(long parentIShellFolder,
<i>910</i>&nbsp;                                                  long relativePIDL,
<i>911</i>&nbsp;                                                  int attrs);
<i>912</i>&nbsp;
<i>913</i>&nbsp;    // Returns data of all Known Folders registered in the system
<i>914</i>&nbsp;    private static native KnownFolderDefinition[] loadKnownFolders();
<i>915</i>&nbsp;
<i>916</i>&nbsp;    /**
<i>917</i>&nbsp;     * @return The name used to display this shell folder
<i>918</i>&nbsp;     */
<i>919</i>&nbsp;    public String getDisplayName() {
<i>920</i>&nbsp;        if (displayName == null) {
<i>921</i>&nbsp;            displayName =
<i>922</i>&nbsp;                invoke(new Callable&lt;String&gt;() {
<i>923</i>&nbsp;                    public String call() {
<i>924</i>&nbsp;                        return getDisplayNameOf(getParentIShellFolder(),
<i>925</i>&nbsp;                                getRelativePIDL(), SHGDN_NORMAL);
<i>926</i>&nbsp;                    }
<i>927</i>&nbsp;                });
<i>928</i>&nbsp;        }
<i>929</i>&nbsp;        return displayName;
<i>930</i>&nbsp;    }
<i>931</i>&nbsp;
<i>932</i>&nbsp;    // Return the folder type of a shell folder
<i>933</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>934</i>&nbsp;    private static native String getFolderType(long pIDL);
<i>935</i>&nbsp;
<i>936</i>&nbsp;    /**
<i>937</i>&nbsp;     * @return The type of shell folder as a string
<i>938</i>&nbsp;     */
<b class="nc"><i>939</i>&nbsp;    public String getFolderType() {</b>
<b class="nc"><i>940</i>&nbsp;        if (folderType == null) {</b>
<i>941</i>&nbsp;            final long absolutePIDL = getAbsolutePIDL();
<i>942</i>&nbsp;            folderType =
<b class="nc"><i>943</i>&nbsp;                invoke(new Callable&lt;String&gt;() {</b>
<i>944</i>&nbsp;                    public String call() {
<i>945</i>&nbsp;                        return getFolderType(absolutePIDL);
<i>946</i>&nbsp;                    }
<b class="nc"><i>947</i>&nbsp;                });</b>
<i>948</i>&nbsp;        }
<b class="nc"><i>949</i>&nbsp;        return folderType;</b>
<b class="nc"><i>950</i>&nbsp;    }</b>
<b class="nc"><i>951</i>&nbsp;</b>
<b class="nc"><i>952</i>&nbsp;    // Return the executable type of a file system shell folder</b>
<b class="nc"><i>953</i>&nbsp;    private native String getExecutableType(String path);</b>
<b class="nc"><i>954</i>&nbsp;</b>
<i>955</i>&nbsp;    /**
<i>956</i>&nbsp;     * @return The executable type as a string
<b class="nc"><i>957</i>&nbsp;     */</b>
<i>958</i>&nbsp;    public String getExecutableType() {
<i>959</i>&nbsp;        if (!isFileSystem()) {
<i>960</i>&nbsp;            return null;
<i>961</i>&nbsp;        }
<i>962</i>&nbsp;        return getExecutableType(getAbsolutePath());
<i>963</i>&nbsp;    }
<i>964</i>&nbsp;
<b class="nc"><i>965</i>&nbsp;</b>
<b class="nc"><i>966</i>&nbsp;</b>
<b class="nc"><i>967</i>&nbsp;    // Icons</b>
<b class="nc"><i>968</i>&nbsp;</b>
<i>969</i>&nbsp;    private static Map&lt;Integer, Image&gt; smallSystemImages = new HashMap&lt;&gt;();
<b class="nc"><i>970</i>&nbsp;    private static Map&lt;Integer, Image&gt; largeSystemImages = new HashMap&lt;&gt;();</b>
<b class="nc"><i>971</i>&nbsp;    private static Map&lt;Integer, Image&gt; smallLinkedSystemImages = new HashMap&lt;&gt;();</b>
<b class="nc"><i>972</i>&nbsp;    private static Map&lt;Integer, Image&gt; largeLinkedSystemImages = new HashMap&lt;&gt;();</b>
<b class="nc"><i>973</i>&nbsp;</b>
<i>974</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<b class="nc"><i>975</i>&nbsp;    private static native long getIShellIcon(long pIShellFolder);</b>
<i>976</i>&nbsp;
<i>977</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<b class="nc"><i>978</i>&nbsp;    private static native int getIconIndex(long parentIShellIcon, long relativePIDL);</b>
<b class="nc"><i>979</i>&nbsp;</b>
<i>980</i>&nbsp;    // Return the icon of a file system shell folder in the form of an HICON
<b class="nc"><i>981</i>&nbsp;    private static native long getIcon(String absolutePath, boolean getLargeIcon);</b>
<b class="nc"><i>982</i>&nbsp;</b>
<i>983</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<b class="nc"><i>984</i>&nbsp;    private static native long extractIcon(long parentIShellFolder, long relativePIDL,</b>
<i>985</i>&nbsp;                                           boolean getLargeIcon, boolean getDefaultIcon);
<b class="nc"><i>986</i>&nbsp;</b>
<b class="nc"><i>987</i>&nbsp;    // Returns an icon from the Windows system icon list in the form of an HICON</b>
<b class="nc"><i>988</i>&nbsp;    private static native long getSystemIcon(int iconID);</b>
<b class="nc"><i>989</i>&nbsp;    private static native long getIconResource(String libName, int iconID,</b>
<b class="nc"><i>990</i>&nbsp;                                               int cxDesired, int cyDesired,</b>
<b class="nc"><i>991</i>&nbsp;                                               boolean useVGAColors);</b>
<b class="nc"><i>992</i>&nbsp;                                               // Note: useVGAColors is ignored on XP and later</b>
<i>993</i>&nbsp;
<i>994</i>&nbsp;    // Return the bits from an HICON.  This has a side effect of setting
<i>995</i>&nbsp;    // the imageHash variable for efficient caching / comparing.
<i>996</i>&nbsp;    private static native int[] getIconBits(long hIcon);
<i>997</i>&nbsp;    // Dispose the HICON
<b class="nc"><i>998</i>&nbsp;    private static native void disposeIcon(long hIcon);</b>
<i>999</i>&nbsp;
<b class="nc"><i>1000</i>&nbsp;    // Get buttons from native toolbar implementation.</b>
<b class="nc"><i>1001</i>&nbsp;    static native int[] getStandardViewButton0(int iconIndex, boolean small);</b>
<b class="nc"><i>1002</i>&nbsp;</b>
<b class="nc"><i>1003</i>&nbsp;    // Should be called from the COM thread</b>
<i>1004</i>&nbsp;    private long getIShellIcon() {
<i>1005</i>&nbsp;        if (pIShellIcon == -1L) {
<b class="nc"><i>1006</i>&nbsp;            pIShellIcon = getIShellIcon(getIShellFolder());</b>
<b class="nc"><i>1007</i>&nbsp;        }</b>
<i>1008</i>&nbsp;
<b class="nc"><i>1009</i>&nbsp;        return pIShellIcon;</b>
<i>1010</i>&nbsp;    }
<i>1011</i>&nbsp;
<b class="nc"><i>1012</i>&nbsp;    private static Image makeIcon(long hIcon, boolean getLargeIcon) {</b>
<b class="nc"><i>1013</i>&nbsp;        if (hIcon != 0L &amp;&amp; hIcon != -1L) {</b>
<i>1014</i>&nbsp;            // Get the bits.  This has the side effect of setting the imageHash value for this object.
<b class="nc"><i>1015</i>&nbsp;            final int[] iconBits = getIconBits(hIcon);</b>
<i>1016</i>&nbsp;            if (iconBits != null) {
<i>1017</i>&nbsp;                // icons are always square
<b class="nc"><i>1018</i>&nbsp;                final int size = (int) Math.sqrt(iconBits.length);</b>
<i>1019</i>&nbsp;                final int baseSize = getLargeIcon ? 32 : 16;
<i>1020</i>&nbsp;                final BufferedImage img =
<i>1021</i>&nbsp;                        new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
<i>1022</i>&nbsp;                img.setRGB(0, 0, size, size, iconBits, 0, size);
<i>1023</i>&nbsp;                return size == baseSize
<i>1024</i>&nbsp;                        ? img
<b class="nc"><i>1025</i>&nbsp;                        : new MultiResolutionIconImage(baseSize, img);</b>
<b class="nc"><i>1026</i>&nbsp;            }</b>
<b class="nc"><i>1027</i>&nbsp;        }</b>
<b class="nc"><i>1028</i>&nbsp;        return null;</b>
<i>1029</i>&nbsp;    }
<i>1030</i>&nbsp;
<i>1031</i>&nbsp;
<i>1032</i>&nbsp;    /**
<i>1033</i>&nbsp;     * @return The icon image used to display this shell folder
<i>1034</i>&nbsp;     */
<b class="nc"><i>1035</i>&nbsp;    public Image getIcon(final boolean getLargeIcon) {</b>
<i>1036</i>&nbsp;        Image icon = getLargeIcon ? largeIcon : smallIcon;
<b class="nc"><i>1037</i>&nbsp;        if (icon == null) {</b>
<i>1038</i>&nbsp;            icon =
<b class="nc"><i>1039</i>&nbsp;                invoke(new Callable&lt;Image&gt;() {</b>
<b class="nc"><i>1040</i>&nbsp;                    public Image call() {</b>
<b class="nc"><i>1041</i>&nbsp;                        Image newIcon = null;</b>
<b class="nc"><i>1042</i>&nbsp;                        if (isLink()) {</b>
<i>1043</i>&nbsp;                            Win32ShellFolder2 folder = getLinkLocation(false);
<i>1044</i>&nbsp;                            if (folder != null &amp;&amp; folder.isLibrary()) {
<b class="nc"><i>1045</i>&nbsp;                                return folder.getIcon(getLargeIcon);</b>
<b class="nc"><i>1046</i>&nbsp;                            }</b>
<b class="nc"><i>1047</i>&nbsp;                        }</b>
<b class="nc"><i>1048</i>&nbsp;                        if (isFileSystem() || isLibrary()) {</b>
<b class="nc"><i>1049</i>&nbsp;                            long parentIShellIcon = (parent != null)</b>
<i>1050</i>&nbsp;                                ? ((Win32ShellFolder2) parent).getIShellIcon()
<b class="nc"><i>1051</i>&nbsp;                                : 0L;</b>
<i>1052</i>&nbsp;                            long relativePIDL = getRelativePIDL();
<i>1053</i>&nbsp;
<i>1054</i>&nbsp;                            // These are cached per type (using the index in the system image list)
<i>1055</i>&nbsp;                            int index = getIconIndex(parentIShellIcon, relativePIDL);
<i>1056</i>&nbsp;                            if (index &gt; 0) {
<i>1057</i>&nbsp;                                Map&lt;Integer, Image&gt; imageCache;
<i>1058</i>&nbsp;                                if (isLink()) {
<i>1059</i>&nbsp;                                    imageCache = getLargeIcon ? largeLinkedSystemImages : smallLinkedSystemImages;
<i>1060</i>&nbsp;                                } else {
<b class="nc"><i>1061</i>&nbsp;                                    imageCache = getLargeIcon ? largeSystemImages : smallSystemImages;</b>
<i>1062</i>&nbsp;                                }
<i>1063</i>&nbsp;                                newIcon = imageCache.get(Integer.valueOf(index));
<i>1064</i>&nbsp;                                if (newIcon == null) {
<i>1065</i>&nbsp;                                    long hIcon = getIcon(getAbsolutePath(), getLargeIcon);
<i>1066</i>&nbsp;                                    newIcon = makeIcon(hIcon, getLargeIcon);
<i>1067</i>&nbsp;                                    disposeIcon(hIcon);
<b class="nc"><i>1068</i>&nbsp;                                    if (newIcon != null) {</b>
<i>1069</i>&nbsp;                                        imageCache.put(Integer.valueOf(index), newIcon);
<i>1070</i>&nbsp;                                    }
<i>1071</i>&nbsp;                                }
<i>1072</i>&nbsp;                            }
<i>1073</i>&nbsp;                        }
<i>1074</i>&nbsp;
<i>1075</i>&nbsp;                        if (newIcon == null) {
<i>1076</i>&nbsp;                            // These are only cached per object
<b class="nc"><i>1077</i>&nbsp;                            long hIcon = extractIcon(getParentIShellFolder(),</b>
<b class="nc"><i>1078</i>&nbsp;                                    getRelativePIDL(), getLargeIcon, false);</b>
<b class="nc"><i>1079</i>&nbsp;                            // E_PENDING: loading can take time so get the default</b>
<i>1080</i>&nbsp;                            if(hIcon &lt;= 0) {
<b class="nc"><i>1081</i>&nbsp;                                hIcon = extractIcon(getParentIShellFolder(),</b>
<i>1082</i>&nbsp;                                         getRelativePIDL(), getLargeIcon, true);
<i>1083</i>&nbsp;                                if(hIcon &lt;= 0) {
<b class="nc"><i>1084</i>&nbsp;                                    if (isDirectory()) {</b>
<i>1085</i>&nbsp;                                        return getShell32Icon(4, getLargeIcon);
<i>1086</i>&nbsp;                                    } else {
<i>1087</i>&nbsp;                                        return getShell32Icon(1, getLargeIcon);
<i>1088</i>&nbsp;                                    }
<i>1089</i>&nbsp;                                }
<i>1090</i>&nbsp;                            }
<i>1091</i>&nbsp;                            newIcon = makeIcon(hIcon, getLargeIcon);
<i>1092</i>&nbsp;                            disposeIcon(hIcon);
<b class="nc"><i>1093</i>&nbsp;                        }</b>
<i>1094</i>&nbsp;
<b class="nc"><i>1095</i>&nbsp;                        if (newIcon == null) {</b>
<i>1096</i>&nbsp;                            newIcon = Win32ShellFolder2.super.getIcon(getLargeIcon);
<b class="nc"><i>1097</i>&nbsp;                        }</b>
<b class="nc"><i>1098</i>&nbsp;                        return newIcon;</b>
<i>1099</i>&nbsp;                    }
<b class="nc"><i>1100</i>&nbsp;                });</b>
<b class="nc"><i>1101</i>&nbsp;            if (getLargeIcon) {</b>
<b class="nc"><i>1102</i>&nbsp;                largeIcon = icon;</b>
<b class="nc"><i>1103</i>&nbsp;            } else {</b>
<i>1104</i>&nbsp;                smallIcon = icon;
<b class="nc"><i>1105</i>&nbsp;            }</b>
<i>1106</i>&nbsp;        }
<i>1107</i>&nbsp;        return icon;
<i>1108</i>&nbsp;    }
<b class="nc"><i>1109</i>&nbsp;</b>
<i>1110</i>&nbsp;    /**
<b class="nc"><i>1111</i>&nbsp;     * Gets an icon from the Windows system icon list as an {@code Image}</b>
<i>1112</i>&nbsp;     */
<i>1113</i>&nbsp;    static Image getSystemIcon(SystemIcon iconType) {
<b class="nc"><i>1114</i>&nbsp;        long hIcon = getSystemIcon(iconType.getIconID());</b>
<b class="nc"><i>1115</i>&nbsp;        Image icon = makeIcon(hIcon, true);</b>
<i>1116</i>&nbsp;        disposeIcon(hIcon);
<b class="nc"><i>1117</i>&nbsp;        return icon;</b>
<i>1118</i>&nbsp;    }
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;    /**
<i>1121</i>&nbsp;     * Gets an icon from the Windows system icon list as an {@code Image}
<i>1122</i>&nbsp;     */
<b class="nc"><i>1123</i>&nbsp;    static Image getShell32Icon(int iconID, boolean getLargeIcon) {</b>
<i>1124</i>&nbsp;        boolean useVGAColors = true; // Will be ignored on XP and later
<b class="nc"><i>1125</i>&nbsp;</b>
<i>1126</i>&nbsp;        int size = getLargeIcon ? 32 : 16;
<i>1127</i>&nbsp;
<i>1128</i>&nbsp;        Toolkit toolkit = Toolkit.getDefaultToolkit();
<i>1129</i>&nbsp;        String shellIconBPP = (String)toolkit.getDesktopProperty(&quot;win.icon.shellIconBPP&quot;);
<i>1130</i>&nbsp;        if (shellIconBPP != null) {
<i>1131</i>&nbsp;            useVGAColors = shellIconBPP.equals(&quot;4&quot;);
<i>1132</i>&nbsp;        }
<i>1133</i>&nbsp;
<i>1134</i>&nbsp;        long hIcon = getIconResource(&quot;shell32.dll&quot;, iconID, size, size, useVGAColors);
<i>1135</i>&nbsp;        if (hIcon != 0) {
<i>1136</i>&nbsp;            Image icon = makeIcon(hIcon, getLargeIcon);
<i>1137</i>&nbsp;            disposeIcon(hIcon);
<i>1138</i>&nbsp;            return icon;
<i>1139</i>&nbsp;        }
<i>1140</i>&nbsp;        return null;
<i>1141</i>&nbsp;    }
<i>1142</i>&nbsp;
<b class="nc"><i>1143</i>&nbsp;    /**</b>
<i>1144</i>&nbsp;     * Returns the canonical form of this abstract pathname.  Equivalent to
<b class="nc"><i>1145</i>&nbsp;     * &lt;code&gt;new&amp;nbsp;Win32ShellFolder2(getParentFile(), this.{@link java.io.File#getCanonicalPath}())&lt;/code&gt;.</b>
<i>1146</i>&nbsp;     *
<b class="nc"><i>1147</i>&nbsp;     * @see java.io.File#getCanonicalFile</b>
<i>1148</i>&nbsp;     */
<i>1149</i>&nbsp;    public File getCanonicalFile() throws IOException {
<i>1150</i>&nbsp;        return this;
<i>1151</i>&nbsp;    }
<b class="nc"><i>1152</i>&nbsp;</b>
<i>1153</i>&nbsp;    /*
<i>1154</i>&nbsp;     * Indicates whether this is a special folder (includes My Documents)
<i>1155</i>&nbsp;     */
<i>1156</i>&nbsp;    public boolean isSpecial() {
<b class="nc"><i>1157</i>&nbsp;        return isPersonal || !isFileSystem() || (this == getDesktop());</b>
<b class="nc"><i>1158</i>&nbsp;    }</b>
<b class="nc"><i>1159</i>&nbsp;</b>
<i>1160</i>&nbsp;    /**
<i>1161</i>&nbsp;     * Compares this object with the specified object for order.
<i>1162</i>&nbsp;     *
<i>1163</i>&nbsp;     * @see sun.awt.shell.ShellFolder#compareTo(File)
<b class="nc"><i>1164</i>&nbsp;     */</b>
<i>1165</i>&nbsp;    public int compareTo(File file2) {
<b class="nc"><i>1166</i>&nbsp;        if (!(file2 instanceof Win32ShellFolder2)) {</b>
<i>1167</i>&nbsp;            if (isFileSystem() &amp;&amp; !isSpecial()) {
<i>1168</i>&nbsp;                return super.compareTo(file2);
<b class="nc"><i>1169</i>&nbsp;            } else {</b>
<b class="nc"><i>1170</i>&nbsp;                return -1; // Non-file shellfolders sort before files</b>
<b class="nc"><i>1171</i>&nbsp;            }</b>
<b class="nc"><i>1172</i>&nbsp;        }</b>
<i>1173</i>&nbsp;        return Win32ShellFolderManager2.compareShellFolders(this, (Win32ShellFolder2) file2);
<b class="nc"><i>1174</i>&nbsp;    }</b>
<i>1175</i>&nbsp;
<i>1176</i>&nbsp;    // native constants from commctrl.h
<i>1177</i>&nbsp;    private static final int LVCFMT_LEFT = 0;
<b class="nc"><i>1178</i>&nbsp;    private static final int LVCFMT_RIGHT = 1;</b>
<i>1179</i>&nbsp;    private static final int LVCFMT_CENTER = 2;
<i>1180</i>&nbsp;
<i>1181</i>&nbsp;    public ShellFolderColumnInfo[] getFolderColumns() {
<i>1182</i>&nbsp;        ShellFolder library = resolveLibrary();
<i>1183</i>&nbsp;        if (library != null) return library.getFolderColumns();
<i>1184</i>&nbsp;        return invoke(new Callable&lt;ShellFolderColumnInfo[]&gt;() {
<i>1185</i>&nbsp;            public ShellFolderColumnInfo[] call() {
<i>1186</i>&nbsp;                ShellFolderColumnInfo[] columns = doGetColumnInfo(getIShellFolder());
<i>1187</i>&nbsp;
<i>1188</i>&nbsp;                if (columns != null) {
<i>1189</i>&nbsp;                    List&lt;ShellFolderColumnInfo&gt; notNullColumns =
<i>1190</i>&nbsp;                            new ArrayList&lt;ShellFolderColumnInfo&gt;();
<i>1191</i>&nbsp;                    for (int i = 0; i &lt; columns.length; i++) {
<i>1192</i>&nbsp;                        ShellFolderColumnInfo column = columns[i];
<i>1193</i>&nbsp;                        if (column != null) {
<i>1194</i>&nbsp;                            column.setAlignment(column.getAlignment() == LVCFMT_RIGHT
<i>1195</i>&nbsp;                                    ? SwingConstants.RIGHT
<i>1196</i>&nbsp;                                    : column.getAlignment() == LVCFMT_CENTER
<i>1197</i>&nbsp;                                    ? SwingConstants.CENTER
<i>1198</i>&nbsp;                                    : SwingConstants.LEADING);
<i>1199</i>&nbsp;
<i>1200</i>&nbsp;                            column.setComparator(new ColumnComparator(Win32ShellFolder2.this, i));
<i>1201</i>&nbsp;
<i>1202</i>&nbsp;                            notNullColumns.add(column);
<i>1203</i>&nbsp;                        }
<i>1204</i>&nbsp;                    }
<i>1205</i>&nbsp;                    columns = new ShellFolderColumnInfo[notNullColumns.size()];
<i>1206</i>&nbsp;                    notNullColumns.toArray(columns);
<i>1207</i>&nbsp;                }
<i>1208</i>&nbsp;                return columns;
<i>1209</i>&nbsp;            }
<i>1210</i>&nbsp;        });
<i>1211</i>&nbsp;    }
<i>1212</i>&nbsp;
<i>1213</i>&nbsp;    public Object getFolderColumnValue(final int column) {
<i>1214</i>&nbsp;        if(!isLibrary()) {
<i>1215</i>&nbsp;            ShellFolder library = resolveLibrary();
<i>1216</i>&nbsp;            if (library != null) return library.getFolderColumnValue(column);
<i>1217</i>&nbsp;        }
<i>1218</i>&nbsp;        return invoke(new Callable&lt;Object&gt;() {
<i>1219</i>&nbsp;            public Object call() {
<i>1220</i>&nbsp;                return doGetColumnValue(getParentIShellFolder(), getRelativePIDL(), column);
<i>1221</i>&nbsp;            }
<i>1222</i>&nbsp;        });
<i>1223</i>&nbsp;    }
<i>1224</i>&nbsp;
<i>1225</i>&nbsp;    boolean isLibrary() {
<i>1226</i>&nbsp;        return isLib;
<i>1227</i>&nbsp;    }
<i>1228</i>&nbsp;
<i>1229</i>&nbsp;    private ShellFolder resolveLibrary() {
<i>1230</i>&nbsp;        for (ShellFolder f = this; f != null; f = f.parent) {
<i>1231</i>&nbsp;            if (!f.isFileSystem()) {
<i>1232</i>&nbsp;                if (f instanceof Win32ShellFolder2 &amp;&amp;
<i>1233</i>&nbsp;                                           ((Win32ShellFolder2)f).isLibrary()) {
<i>1234</i>&nbsp;                    try {
<i>1235</i>&nbsp;                        return getShellFolder(new File(getPath()));
<i>1236</i>&nbsp;                    } catch (FileNotFoundException e) {
<i>1237</i>&nbsp;                    }
<i>1238</i>&nbsp;                }
<i>1239</i>&nbsp;                break;
<i>1240</i>&nbsp;            }
<i>1241</i>&nbsp;        }
<i>1242</i>&nbsp;        return null;
<i>1243</i>&nbsp;    }
<i>1244</i>&nbsp;
<i>1245</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>1246</i>&nbsp;    private native ShellFolderColumnInfo[] doGetColumnInfo(long iShellFolder2);
<i>1247</i>&nbsp;
<i>1248</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>1249</i>&nbsp;    private native Object doGetColumnValue(long parentIShellFolder2, long childPIDL, int columnIdx);
<i>1250</i>&nbsp;
<i>1251</i>&nbsp;    // NOTE: this method uses COM and must be called on the &#39;COM thread&#39;. See ComInvoker for the details
<i>1252</i>&nbsp;    private static native int compareIDsByColumn(long pParentIShellFolder, long pidl1, long pidl2, int columnIdx);
<i>1253</i>&nbsp;
<i>1254</i>&nbsp;
<i>1255</i>&nbsp;    public void sortChildren(final List&lt;? extends File&gt; files) {
<i>1256</i>&nbsp;        // To avoid loads of synchronizations with Invoker and improve performance we
<i>1257</i>&nbsp;        // synchronize the whole code of the sort method once
<i>1258</i>&nbsp;        invoke(new Callable&lt;Void&gt;() {
<i>1259</i>&nbsp;            public Void call() {
<i>1260</i>&nbsp;                Collections.sort(files, new ColumnComparator(Win32ShellFolder2.this, 0));
<i>1261</i>&nbsp;
<i>1262</i>&nbsp;                return null;
<i>1263</i>&nbsp;            }
<i>1264</i>&nbsp;        });
<i>1265</i>&nbsp;    }
<i>1266</i>&nbsp;
<i>1267</i>&nbsp;    private static class ColumnComparator implements Comparator&lt;File&gt; {
<i>1268</i>&nbsp;        private final Win32ShellFolder2 shellFolder;
<i>1269</i>&nbsp;
<i>1270</i>&nbsp;        private final int columnIdx;
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;        public ColumnComparator(Win32ShellFolder2 shellFolder, int columnIdx) {
<i>1273</i>&nbsp;            this.shellFolder = shellFolder;
<i>1274</i>&nbsp;            this.columnIdx = columnIdx;
<i>1275</i>&nbsp;        }
<i>1276</i>&nbsp;
<i>1277</i>&nbsp;        // compares 2 objects within this folder by the specified column
<i>1278</i>&nbsp;        public int compare(final File o, final File o1) {
<i>1279</i>&nbsp;            Integer result = invoke(new Callable&lt;Integer&gt;() {
<i>1280</i>&nbsp;                public Integer call() {
<i>1281</i>&nbsp;                    if (o instanceof Win32ShellFolder2
<i>1282</i>&nbsp;                        &amp;&amp; o1 instanceof Win32ShellFolder2) {
<i>1283</i>&nbsp;                        // delegates comparison to native method
<i>1284</i>&nbsp;                        return compareIDsByColumn(shellFolder.getIShellFolder(),
<i>1285</i>&nbsp;                            ((Win32ShellFolder2) o).getRelativePIDL(),
<i>1286</i>&nbsp;                            ((Win32ShellFolder2) o1).getRelativePIDL(),
<i>1287</i>&nbsp;                            columnIdx);
<i>1288</i>&nbsp;                    }
<i>1289</i>&nbsp;                    return 0;
<i>1290</i>&nbsp;                }
<i>1291</i>&nbsp;            });
<i>1292</i>&nbsp;
<i>1293</i>&nbsp;            return result == null ? 0 : result;
<i>1294</i>&nbsp;        }
<i>1295</i>&nbsp;    }
<i>1296</i>&nbsp;
<i>1297</i>&nbsp;    // Extracts libraries and their default save locations from Known Folders list
<i>1298</i>&nbsp;    private static List&lt;KnownFolderDefinition&gt; getLibraries() {
<i>1299</i>&nbsp;        return invoke(new Callable&lt;List&lt;KnownFolderDefinition&gt;&gt;() {
<i>1300</i>&nbsp;            @Override
<i>1301</i>&nbsp;            public List&lt;KnownFolderDefinition&gt; call() throws Exception {
<i>1302</i>&nbsp;                KnownFolderDefinition[] all = loadKnownFolders();
<i>1303</i>&nbsp;                List&lt;KnownFolderDefinition&gt; folders = new ArrayList&lt;&gt;();
<i>1304</i>&nbsp;                if (all != null) {
<i>1305</i>&nbsp;                    for (KnownFolderDefinition kf : all) {
<i>1306</i>&nbsp;                        if (kf.relativePath == null || kf.parsingName == null ||
<i>1307</i>&nbsp;                                kf.saveLocation == null) {
<i>1308</i>&nbsp;                            continue;
<i>1309</i>&nbsp;                        }
<i>1310</i>&nbsp;                        folders.add(kf);
<i>1311</i>&nbsp;                    }
<i>1312</i>&nbsp;                }
<i>1313</i>&nbsp;                return folders;
<i>1314</i>&nbsp;            }
<i>1315</i>&nbsp;        });
<i>1316</i>&nbsp;    }
<i>1317</i>&nbsp;
<i>1318</i>&nbsp;    static class MultiResolutionIconImage extends AbstractMultiResolutionImage {
<i>1319</i>&nbsp;
<i>1320</i>&nbsp;        final int baseSize;
<i>1321</i>&nbsp;        final Image resolutionVariant;
<i>1322</i>&nbsp;
<i>1323</i>&nbsp;        public MultiResolutionIconImage(int baseSize, Image resolutionVariant) {
<i>1324</i>&nbsp;            this.baseSize = baseSize;
<i>1325</i>&nbsp;            this.resolutionVariant = resolutionVariant;
<i>1326</i>&nbsp;        }
<i>1327</i>&nbsp;
<i>1328</i>&nbsp;        @Override
<i>1329</i>&nbsp;        public int getWidth(ImageObserver observer) {
<i>1330</i>&nbsp;            return baseSize;
<i>1331</i>&nbsp;        }
<i>1332</i>&nbsp;
<i>1333</i>&nbsp;        @Override
<i>1334</i>&nbsp;        public int getHeight(ImageObserver observer) {
<i>1335</i>&nbsp;            return baseSize;
<i>1336</i>&nbsp;        }
<i>1337</i>&nbsp;
<i>1338</i>&nbsp;        @Override
<i>1339</i>&nbsp;        protected Image getBaseImage() {
<i>1340</i>&nbsp;            return resolutionVariant;
<i>1341</i>&nbsp;        }
<i>1342</i>&nbsp;
<i>1343</i>&nbsp;        @Override
<i>1344</i>&nbsp;        public Image getResolutionVariant(double width, double height) {
<i>1345</i>&nbsp;            return resolutionVariant;
<i>1346</i>&nbsp;        }
<i>1347</i>&nbsp;
<i>1348</i>&nbsp;        @Override
<i>1349</i>&nbsp;        public List&lt;Image&gt; getResolutionVariants() {
<i>1350</i>&nbsp;            return Arrays.asList(resolutionVariant);
<i>1351</i>&nbsp;        }
<i>1352</i>&nbsp;    }
<i>1353</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:15</div>
</div>
</body>
</html>
