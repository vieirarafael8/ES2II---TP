


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Main</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.tools.jar</a> ]
</div>

<h1>Coverage Summary for Class: Main (sun.tools.jar)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Main</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 49)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 660)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Main$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Main$CRC32OutputStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 55)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 671)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.tools.jar;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.*;
<i>29</i>&nbsp;import java.lang.module.Configuration;
<i>30</i>&nbsp;import java.lang.module.FindException;
<i>31</i>&nbsp;import java.lang.module.InvalidModuleDescriptorException;
<i>32</i>&nbsp;import java.lang.module.ModuleDescriptor;
<i>33</i>&nbsp;import java.lang.module.ModuleDescriptor.Exports;
<i>34</i>&nbsp;import java.lang.module.ModuleDescriptor.Opens;
<i>35</i>&nbsp;import java.lang.module.ModuleDescriptor.Provides;
<i>36</i>&nbsp;import java.lang.module.ModuleDescriptor.Version;
<i>37</i>&nbsp;import java.lang.module.ModuleFinder;
<i>38</i>&nbsp;import java.lang.module.ModuleReader;
<i>39</i>&nbsp;import java.lang.module.ModuleReference;
<i>40</i>&nbsp;import java.lang.module.ResolvedModule;
<i>41</i>&nbsp;import java.net.URI;
<i>42</i>&nbsp;import java.nio.ByteBuffer;
<i>43</i>&nbsp;import java.nio.file.Files;
<i>44</i>&nbsp;import java.nio.file.Path;
<i>45</i>&nbsp;import java.nio.file.Paths;
<i>46</i>&nbsp;import java.nio.file.StandardCopyOption;
<b class="nc"><i>47</i>&nbsp;import java.text.MessageFormat;</b>
<b class="nc"><i>48</i>&nbsp;import java.util.*;</b>
<i>49</i>&nbsp;import java.util.function.Consumer;
<i>50</i>&nbsp;import java.util.jar.Attributes;
<i>51</i>&nbsp;import java.util.jar.JarFile;
<b class="nc"><i>52</i>&nbsp;import java.util.jar.JarOutputStream;</b>
<i>53</i>&nbsp;import java.util.jar.Manifest;
<b class="nc"><i>54</i>&nbsp;import java.util.regex.Pattern;</b>
<i>55</i>&nbsp;import java.util.stream.Collectors;
<i>56</i>&nbsp;import java.util.stream.Stream;
<i>57</i>&nbsp;import java.util.zip.CRC32;
<i>58</i>&nbsp;import java.util.zip.ZipEntry;
<b class="nc"><i>59</i>&nbsp;import java.util.zip.ZipFile;</b>
<i>60</i>&nbsp;import java.util.zip.ZipInputStream;
<i>61</i>&nbsp;import java.util.zip.ZipOutputStream;
<b class="nc"><i>62</i>&nbsp;import jdk.internal.module.Checks;</b>
<i>63</i>&nbsp;import jdk.internal.module.ModuleHashes;
<i>64</i>&nbsp;import jdk.internal.module.ModuleHashesBuilder;
<b class="nc"><i>65</i>&nbsp;import jdk.internal.module.ModuleInfo;</b>
<i>66</i>&nbsp;import jdk.internal.module.ModuleInfoExtender;
<i>67</i>&nbsp;import jdk.internal.module.ModuleResolution;
<i>68</i>&nbsp;import jdk.internal.module.ModuleTarget;
<i>69</i>&nbsp;import jdk.internal.util.jar.JarIndex;
<i>70</i>&nbsp;
<i>71</i>&nbsp;import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
<i>72</i>&nbsp;import static java.util.jar.JarFile.MANIFEST_NAME;
<i>73</i>&nbsp;import static java.util.stream.Collectors.joining;
<i>74</i>&nbsp;import static jdk.internal.util.jar.JarIndex.INDEX_NAME;
<i>75</i>&nbsp;
<i>76</i>&nbsp;/**
<i>77</i>&nbsp; * This class implements a simple utility for creating files in the JAR
<i>78</i>&nbsp; * (Java Archive) file format. The JAR format is based on the ZIP file
<i>79</i>&nbsp; * format, with optional meta-information stored in a MANIFEST entry.
<i>80</i>&nbsp; */
<i>81</i>&nbsp;public class Main {
<i>82</i>&nbsp;    String program;
<i>83</i>&nbsp;    PrintWriter out, err;
<i>84</i>&nbsp;    String fname, mname, ename;
<i>85</i>&nbsp;    String zname = &quot;&quot;;
<i>86</i>&nbsp;    String rootjar = null;
<i>87</i>&nbsp;
<i>88</i>&nbsp;    private static final int BASE_VERSION = 0;
<i>89</i>&nbsp;
<i>90</i>&nbsp;    private static class Entry {
<i>91</i>&nbsp;        final String name;
<b class="nc"><i>92</i>&nbsp;        final File file;</b>
<b class="nc"><i>93</i>&nbsp;        final boolean isDir;</b>
<i>94</i>&nbsp;
<i>95</i>&nbsp;        Entry(File file, String name, boolean isDir) {
<i>96</i>&nbsp;            this.file = file;
<i>97</i>&nbsp;            this.isDir = isDir;
<i>98</i>&nbsp;            this.name = name;
<i>99</i>&nbsp;        }
<b class="nc"><i>100</i>&nbsp;</b>
<b class="nc"><i>101</i>&nbsp;        @Override</b>
<b class="nc"><i>102</i>&nbsp;        public boolean equals(Object o) {</b>
<b class="nc"><i>103</i>&nbsp;            if (this == o) return true;</b>
<i>104</i>&nbsp;            if (!(o instanceof Entry)) return false;
<i>105</i>&nbsp;            return this.file.equals(((Entry)o).file);
<i>106</i>&nbsp;        }
<i>107</i>&nbsp;
<b class="nc"><i>108</i>&nbsp;        @Override</b>
<b class="nc"><i>109</i>&nbsp;        public int hashCode() {</b>
<b class="nc"><i>110</i>&nbsp;            return file.hashCode();</b>
<i>111</i>&nbsp;        }
<i>112</i>&nbsp;    }
<i>113</i>&nbsp;
<i>114</i>&nbsp;    // An entryName(path)-&gt;Entry map generated during &quot;expand&quot;, it helps to
<b class="nc"><i>115</i>&nbsp;    // decide whether or not an existing entry in a jar file needs to be</b>
<b class="nc"><i>116</i>&nbsp;    // replaced, during the &quot;update&quot; operation.</b>
<b class="nc"><i>117</i>&nbsp;    Map&lt;String, Entry&gt; entryMap = new HashMap&lt;&gt;();</b>
<b class="nc"><i>118</i>&nbsp;</b>
<i>119</i>&nbsp;    // All entries need to be added/updated.
<i>120</i>&nbsp;    Set&lt;Entry&gt; entries = new LinkedHashSet&lt;&gt;();
<i>121</i>&nbsp;
<b class="nc"><i>122</i>&nbsp;    // module-info.class entries need to be added/updated.</b>
<b class="nc"><i>123</i>&nbsp;    Map&lt;String,byte[]&gt; moduleInfos = new HashMap&lt;&gt;();</b>
<b class="nc"><i>124</i>&nbsp;</b>
<b class="nc"><i>125</i>&nbsp;    // A paths Set for each version, where each Set contains directories</b>
<b class="nc"><i>126</i>&nbsp;    // specified by the &quot;-C&quot; operation.</b>
<i>127</i>&nbsp;    Map&lt;Integer,Set&lt;String&gt;&gt; pathsMap = new HashMap&lt;&gt;();
<i>128</i>&nbsp;
<b class="nc"><i>129</i>&nbsp;    // There&#39;s also a files array per version</b>
<b class="nc"><i>130</i>&nbsp;    Map&lt;Integer,String[]&gt; filesMap = new HashMap&lt;&gt;();</b>
<b class="nc"><i>131</i>&nbsp;</b>
<b class="nc"><i>132</i>&nbsp;    // Do we think this is a multi-release jar?  Set to true</b>
<i>133</i>&nbsp;    // if --release option found followed by at least file
<i>134</i>&nbsp;    boolean isMultiRelease;
<i>135</i>&nbsp;
<i>136</i>&nbsp;    // The last parsed --release value, if any. Used in conjunction with
<i>137</i>&nbsp;    // &quot;-d,--describe-module&quot; to select the operative module descriptor.
<i>138</i>&nbsp;    int releaseValue = -1;
<i>139</i>&nbsp;
<i>140</i>&nbsp;    /*
<b class="nc"><i>141</i>&nbsp;     * cflag: create</b>
<b class="nc"><i>142</i>&nbsp;     * uflag: update</b>
<b class="nc"><i>143</i>&nbsp;     * xflag: xtract</b>
<b class="nc"><i>144</i>&nbsp;     * tflag: table</b>
<i>145</i>&nbsp;     * vflag: verbose
<i>146</i>&nbsp;     * flag0: no zip compression (store only)
<i>147</i>&nbsp;     * Mflag: DO NOT generate a manifest file (just ZIP)
<i>148</i>&nbsp;     * iflag: generate jar index
<i>149</i>&nbsp;     * nflag: Perform jar normalization at the end
<i>150</i>&nbsp;     * pflag: preserve/don&#39;t strip leading slash and .. component from file name
<i>151</i>&nbsp;     * dflag: print module descriptor
<i>152</i>&nbsp;     */
<b class="nc"><i>153</i>&nbsp;    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, nflag, pflag, dflag;</b>
<b class="nc"><i>154</i>&nbsp;</b>
<b class="nc"><i>155</i>&nbsp;    boolean suppressDeprecateMsg = false;</b>
<i>156</i>&nbsp;
<i>157</i>&nbsp;    /* To support additional GNU Style informational options */
<b class="nc"><i>158</i>&nbsp;    Consumer&lt;PrintWriter&gt; info;</b>
<b class="nc"><i>159</i>&nbsp;</b>
<i>160</i>&nbsp;    /* Modular jar related options */
<i>161</i>&nbsp;    Version moduleVersion;
<i>162</i>&nbsp;    Pattern modulesToHash;
<b class="nc"><i>163</i>&nbsp;    ModuleResolution moduleResolution = ModuleResolution.empty();</b>
<b class="nc"><i>164</i>&nbsp;    ModuleFinder moduleFinder = ModuleFinder.of();</b>
<b class="nc"><i>165</i>&nbsp;</b>
<i>166</i>&nbsp;    static final String MODULE_INFO = &quot;module-info.class&quot;;
<i>167</i>&nbsp;    static final String MANIFEST_DIR = &quot;META-INF/&quot;;
<i>168</i>&nbsp;    static final String VERSIONS_DIR = MANIFEST_DIR + &quot;versions/&quot;;
<b class="nc"><i>169</i>&nbsp;    static final String VERSION = &quot;1.0&quot;;</b>
<b class="nc"><i>170</i>&nbsp;    static final int VERSIONS_DIR_LENGTH = VERSIONS_DIR.length();</b>
<b class="nc"><i>171</i>&nbsp;    private static ResourceBundle rsrc;</b>
<i>172</i>&nbsp;
<b class="nc"><i>173</i>&nbsp;    /**</b>
<b class="nc"><i>174</i>&nbsp;     * If true, maintain compatibility with JDK releases prior to 6.0 by</b>
<b class="nc"><i>175</i>&nbsp;     * timestamping extracted files with the time at which they are extracted.</b>
<b class="nc"><i>176</i>&nbsp;     * Default is to use the time given in the archive.</b>
<i>177</i>&nbsp;     */
<b class="nc"><i>178</i>&nbsp;    private static final boolean useExtractionTime =</b>
<i>179</i>&nbsp;        Boolean.getBoolean(&quot;sun.tools.jar.useExtractionTime&quot;);
<b class="nc"><i>180</i>&nbsp;</b>
<b class="nc"><i>181</i>&nbsp;    /**</b>
<b class="nc"><i>182</i>&nbsp;     * Initialize ResourceBundle</b>
<b class="nc"><i>183</i>&nbsp;     */</b>
<b class="nc"><i>184</i>&nbsp;    static {</b>
<i>185</i>&nbsp;        try {
<b class="nc"><i>186</i>&nbsp;            rsrc = ResourceBundle.getBundle(&quot;sun.tools.jar.resources.jar&quot;);</b>
<i>187</i>&nbsp;        } catch (MissingResourceException e) {
<b class="nc"><i>188</i>&nbsp;            throw new Error(&quot;Fatal: Resource for jar is missing&quot;);</b>
<b class="nc"><i>189</i>&nbsp;        }</b>
<i>190</i>&nbsp;    }
<i>191</i>&nbsp;
<b class="nc"><i>192</i>&nbsp;    static String getMsg(String key) {</b>
<i>193</i>&nbsp;        try {
<b class="nc"><i>194</i>&nbsp;            return (rsrc.getString(key));</b>
<b class="nc"><i>195</i>&nbsp;        } catch (MissingResourceException e) {</b>
<i>196</i>&nbsp;            throw new Error(&quot;Error in message file&quot;);
<b class="nc"><i>197</i>&nbsp;        }</b>
<b class="nc"><i>198</i>&nbsp;    }</b>
<i>199</i>&nbsp;
<i>200</i>&nbsp;    static String formatMsg(String key, String arg) {
<i>201</i>&nbsp;        String msg = getMsg(key);
<b class="nc"><i>202</i>&nbsp;        String[] args = new String[1];</b>
<i>203</i>&nbsp;        args[0] = arg;
<i>204</i>&nbsp;        return MessageFormat.format(msg, (Object[]) args);
<b class="nc"><i>205</i>&nbsp;    }</b>
<b class="nc"><i>206</i>&nbsp;</b>
<b class="nc"><i>207</i>&nbsp;    static String formatMsg2(String key, String arg, String arg1) {</b>
<i>208</i>&nbsp;        String msg = getMsg(key);
<b class="nc"><i>209</i>&nbsp;        String[] args = new String[2];</b>
<b class="nc"><i>210</i>&nbsp;        args[0] = arg;</b>
<b class="nc"><i>211</i>&nbsp;        args[1] = arg1;</b>
<b class="nc"><i>212</i>&nbsp;        return MessageFormat.format(msg, (Object[]) args);</b>
<i>213</i>&nbsp;    }
<b class="nc"><i>214</i>&nbsp;</b>
<b class="nc"><i>215</i>&nbsp;    public Main(PrintStream out, PrintStream err, String program) {</b>
<b class="nc"><i>216</i>&nbsp;        this.out = new PrintWriter(out, true);</b>
<i>217</i>&nbsp;        this.err = new PrintWriter(err, true);
<b class="nc"><i>218</i>&nbsp;        this.program = program;</b>
<b class="nc"><i>219</i>&nbsp;    }</b>
<b class="nc"><i>220</i>&nbsp;</b>
<b class="nc"><i>221</i>&nbsp;    public Main(PrintWriter out, PrintWriter err, String program) {</b>
<b class="nc"><i>222</i>&nbsp;        this.out = out;</b>
<i>223</i>&nbsp;        this.err = err;
<b class="nc"><i>224</i>&nbsp;        this.program = program;</b>
<b class="nc"><i>225</i>&nbsp;    }</b>
<b class="nc"><i>226</i>&nbsp;</b>
<b class="nc"><i>227</i>&nbsp;    /**</b>
<b class="nc"><i>228</i>&nbsp;     * Creates a new empty temporary file in the same directory as the</b>
<b class="nc"><i>229</i>&nbsp;     * specified file.  A variant of File.createTempFile.</b>
<b class="nc"><i>230</i>&nbsp;     */</b>
<b class="nc"><i>231</i>&nbsp;    private static File createTempFileInSameDirectoryAs(File file)</b>
<b class="nc"><i>232</i>&nbsp;        throws IOException {</b>
<b class="nc"><i>233</i>&nbsp;        File dir = file.getParentFile();</b>
<b class="nc"><i>234</i>&nbsp;        if (dir == null)</b>
<b class="nc"><i>235</i>&nbsp;            dir = new File(&quot;.&quot;);</b>
<i>236</i>&nbsp;        return File.createTempFile(&quot;jartmp&quot;, null, dir);
<b class="nc"><i>237</i>&nbsp;    }</b>
<b class="nc"><i>238</i>&nbsp;</b>
<i>239</i>&nbsp;    private boolean ok;
<b class="nc"><i>240</i>&nbsp;</b>
<b class="nc"><i>241</i>&nbsp;    /**</b>
<i>242</i>&nbsp;     * Starts main program with the specified arguments.
<b class="nc"><i>243</i>&nbsp;     */</b>
<b class="nc"><i>244</i>&nbsp;    @SuppressWarnings({&quot;removal&quot;})</b>
<i>245</i>&nbsp;    public synchronized boolean run(String args[]) {
<b class="nc"><i>246</i>&nbsp;        ok = true;</b>
<b class="nc"><i>247</i>&nbsp;        if (!parseArgs(args)) {</b>
<i>248</i>&nbsp;            return false;
<b class="nc"><i>249</i>&nbsp;        }</b>
<b class="nc"><i>250</i>&nbsp;        File tmpFile = null;</b>
<i>251</i>&nbsp;        try {
<i>252</i>&nbsp;            if (cflag || uflag) {
<i>253</i>&nbsp;                if (fname != null) {
<b class="nc"><i>254</i>&nbsp;                    // The name of the zip file as it would appear as its own</b>
<b class="nc"><i>255</i>&nbsp;                    // zip file entry. We use this to make sure that we don&#39;t</b>
<i>256</i>&nbsp;                    // add the zip file to itself.
<i>257</i>&nbsp;                    zname = fname.replace(File.separatorChar, &#39;/&#39;);
<b class="nc"><i>258</i>&nbsp;                    if (zname.startsWith(&quot;./&quot;)) {</b>
<b class="nc"><i>259</i>&nbsp;                        zname = zname.substring(2);</b>
<b class="nc"><i>260</i>&nbsp;                    }</b>
<b class="nc"><i>261</i>&nbsp;                }</b>
<b class="nc"><i>262</i>&nbsp;            }</b>
<i>263</i>&nbsp;            if (cflag) {
<b class="nc"><i>264</i>&nbsp;                Manifest manifest = null;</b>
<b class="nc"><i>265</i>&nbsp;                if (!Mflag) {</b>
<b class="nc"><i>266</i>&nbsp;                    if (mname != null) {</b>
<i>267</i>&nbsp;                        try (InputStream in = new FileInputStream(mname)) {
<b class="nc"><i>268</i>&nbsp;                            manifest = new Manifest(new BufferedInputStream(in));</b>
<i>269</i>&nbsp;                        }
<b class="nc"><i>270</i>&nbsp;                    } else {</b>
<b class="nc"><i>271</i>&nbsp;                        manifest = new Manifest();</b>
<i>272</i>&nbsp;                    }
<b class="nc"><i>273</i>&nbsp;                    addVersion(manifest);</b>
<b class="nc"><i>274</i>&nbsp;                    addCreatedBy(manifest);</b>
<i>275</i>&nbsp;                    if (isAmbiguousMainClass(manifest)) {
<b class="nc"><i>276</i>&nbsp;                        return false;</b>
<b class="nc"><i>277</i>&nbsp;                    }</b>
<b class="nc"><i>278</i>&nbsp;                    if (ename != null) {</b>
<b class="nc"><i>279</i>&nbsp;                        addMainClass(manifest, ename);</b>
<i>280</i>&nbsp;                    }
<b class="nc"><i>281</i>&nbsp;                    if (isMultiRelease) {</b>
<i>282</i>&nbsp;                        addMultiRelease(manifest);
<b class="nc"><i>283</i>&nbsp;                    }</b>
<b class="nc"><i>284</i>&nbsp;                }</b>
<b class="nc"><i>285</i>&nbsp;                expand();</b>
<b class="nc"><i>286</i>&nbsp;                if (!moduleInfos.isEmpty()) {</b>
<i>287</i>&nbsp;                    // All actual file entries (excl manifest and module-info.class)
<b class="nc"><i>288</i>&nbsp;                    Set&lt;String&gt; jentries = new HashSet&lt;&gt;();</b>
<i>289</i>&nbsp;                    // all packages if it&#39;s a class or resource
<b class="nc"><i>290</i>&nbsp;                    Set&lt;String&gt; packages = new HashSet&lt;&gt;();</b>
<b class="nc"><i>291</i>&nbsp;                    entries.stream()</b>
<b class="nc"><i>292</i>&nbsp;                           .filter(e -&gt; !e.isDir)</b>
<b class="nc"><i>293</i>&nbsp;                           .forEach( e -&gt; {</b>
<i>294</i>&nbsp;                               addPackageIfNamed(packages, e.name);
<b class="nc"><i>295</i>&nbsp;                               jentries.add(e.name);</b>
<i>296</i>&nbsp;                    });
<b class="nc"><i>297</i>&nbsp;                    addExtendedModuleAttributes(moduleInfos, packages);</b>
<i>298</i>&nbsp;
<b class="nc"><i>299</i>&nbsp;                    // Basic consistency checks for modular jars.</b>
<b class="nc"><i>300</i>&nbsp;                    if (!checkModuleInfo(moduleInfos.get(MODULE_INFO), jentries))</b>
<b class="nc"><i>301</i>&nbsp;                        return false;</b>
<b class="nc"><i>302</i>&nbsp;</b>
<b class="nc"><i>303</i>&nbsp;                } else if (moduleVersion != null || modulesToHash != null) {</b>
<b class="nc"><i>304</i>&nbsp;                    error(getMsg(&quot;error.module.options.without.info&quot;));</b>
<b class="nc"><i>305</i>&nbsp;                    return false;</b>
<i>306</i>&nbsp;                }
<b class="nc"><i>307</i>&nbsp;                if (vflag &amp;&amp; fname == null) {</b>
<i>308</i>&nbsp;                    // Disable verbose output so that it does not appear
<i>309</i>&nbsp;                    // on stdout along with file data
<i>310</i>&nbsp;                    // error(&quot;Warning: -v option ignored&quot;);
<b class="nc"><i>311</i>&nbsp;                    vflag = false;</b>
<i>312</i>&nbsp;                }
<b class="nc"><i>313</i>&nbsp;                final String tmpbase = (fname == null)</b>
<b class="nc"><i>314</i>&nbsp;                        ? &quot;tmpjar&quot;</b>
<b class="nc"><i>315</i>&nbsp;                        : fname.substring(fname.indexOf(File.separatorChar) + 1);</b>
<b class="nc"><i>316</i>&nbsp;</b>
<b class="nc"><i>317</i>&nbsp;                tmpFile = createTemporaryFile(tmpbase, &quot;.jar&quot;);</b>
<i>318</i>&nbsp;                try (OutputStream out = new FileOutputStream(tmpFile)) {
<b class="nc"><i>319</i>&nbsp;                    create(new BufferedOutputStream(out, 4096), manifest);</b>
<b class="nc"><i>320</i>&nbsp;                }</b>
<b class="nc"><i>321</i>&nbsp;                if (nflag) {</b>
<b class="nc"><i>322</i>&nbsp;                    if (!suppressDeprecateMsg) {</b>
<b class="nc"><i>323</i>&nbsp;                        warn(formatMsg(&quot;warn.flag.is.deprecated&quot;, &quot;-n&quot;));</b>
<b class="nc"><i>324</i>&nbsp;                    }</b>
<b class="nc"><i>325</i>&nbsp;                    File packFile = createTemporaryFile(tmpbase, &quot;.pack&quot;);</b>
<b class="nc"><i>326</i>&nbsp;                    try {</b>
<b class="nc"><i>327</i>&nbsp;                        java.util.jar.Pack200.Packer packer = java.util.jar.Pack200.newPacker();</b>
<b class="nc"><i>328</i>&nbsp;                        Map&lt;String, String&gt; p = packer.properties();</b>
<b class="nc"><i>329</i>&nbsp;                        p.put(java.util.jar.Pack200.Packer.EFFORT, &quot;1&quot;); // Minimal effort to conserve CPU</b>
<b class="nc"><i>330</i>&nbsp;                        try (JarFile jarFile = new JarFile(tmpFile.getCanonicalPath());</b>
<b class="nc"><i>331</i>&nbsp;                             OutputStream pack = new FileOutputStream(packFile))</b>
<i>332</i>&nbsp;                        {
<i>333</i>&nbsp;                            packer.pack(jarFile, pack);
<i>334</i>&nbsp;                        }
<i>335</i>&nbsp;                        if (tmpFile.exists()) {
<i>336</i>&nbsp;                            tmpFile.delete();
<i>337</i>&nbsp;                        }
<i>338</i>&nbsp;                        tmpFile = createTemporaryFile(tmpbase, &quot;.jar&quot;);
<i>339</i>&nbsp;                        try (OutputStream out = new FileOutputStream(tmpFile);
<b class="nc"><i>340</i>&nbsp;                             JarOutputStream jos = new JarOutputStream(out))</b>
<b class="nc"><i>341</i>&nbsp;                        {</b>
<b class="nc"><i>342</i>&nbsp;                            java.util.jar.Pack200.Unpacker unpacker = java.util.jar.Pack200.newUnpacker();</b>
<b class="nc"><i>343</i>&nbsp;                            unpacker.unpack(packFile, jos);</b>
<b class="nc"><i>344</i>&nbsp;                        }</b>
<b class="nc"><i>345</i>&nbsp;                    } finally {</b>
<b class="nc"><i>346</i>&nbsp;                        Files.deleteIfExists(packFile.toPath());</b>
<b class="nc"><i>347</i>&nbsp;                    }</b>
<i>348</i>&nbsp;                }
<b class="nc"><i>349</i>&nbsp;                validateAndClose(tmpFile);</b>
<i>350</i>&nbsp;            } else if (uflag) {
<b class="nc"><i>351</i>&nbsp;                File inputFile = null;</b>
<b class="nc"><i>352</i>&nbsp;                if (fname != null) {</b>
<b class="nc"><i>353</i>&nbsp;                    inputFile = new File(fname);</b>
<i>354</i>&nbsp;                    tmpFile = createTempFileInSameDirectoryAs(inputFile);
<b class="nc"><i>355</i>&nbsp;                } else {</b>
<b class="nc"><i>356</i>&nbsp;                    vflag = false;</b>
<i>357</i>&nbsp;                    tmpFile = createTemporaryFile(&quot;tmpjar&quot;, &quot;.jar&quot;);
<b class="nc"><i>358</i>&nbsp;                }</b>
<b class="nc"><i>359</i>&nbsp;                expand();</b>
<b class="nc"><i>360</i>&nbsp;                try (FileInputStream in = (fname != null) ? new FileInputStream(inputFile)</b>
<i>361</i>&nbsp;                        : new FileInputStream(FileDescriptor.in);
<b class="nc"><i>362</i>&nbsp;                     FileOutputStream out = new FileOutputStream(tmpFile);</b>
<b class="nc"><i>363</i>&nbsp;                     InputStream manifest = (!Mflag &amp;&amp; (mname != null)) ?</b>
<i>364</i>&nbsp;                            (new FileInputStream(mname)) : null;
<b class="nc"><i>365</i>&nbsp;                ) {</b>
<b class="nc"><i>366</i>&nbsp;                    boolean updateOk = update(in, new BufferedOutputStream(out),</b>
<b class="nc"><i>367</i>&nbsp;                        manifest, moduleInfos, null);</b>
<i>368</i>&nbsp;                    if (ok) {
<b class="nc"><i>369</i>&nbsp;                        ok = updateOk;</b>
<b class="nc"><i>370</i>&nbsp;                    }</b>
<i>371</i>&nbsp;                }
<b class="nc"><i>372</i>&nbsp;                validateAndClose(tmpFile);</b>
<b class="nc"><i>373</i>&nbsp;            } else if (tflag) {</b>
<b class="nc"><i>374</i>&nbsp;                replaceFSC(filesMap);</b>
<i>375</i>&nbsp;                // For the &quot;list table contents&quot; action, access using the
<b class="nc"><i>376</i>&nbsp;                // ZipFile class is always most efficient since only a</b>
<b class="nc"><i>377</i>&nbsp;                // &quot;one-finger&quot; scan through the central directory is required.</b>
<i>378</i>&nbsp;                String[] files = filesMapToFiles(filesMap);
<b class="nc"><i>379</i>&nbsp;                if (fname != null) {</b>
<b class="nc"><i>380</i>&nbsp;                    list(fname, files);</b>
<b class="nc"><i>381</i>&nbsp;                } else {</b>
<i>382</i>&nbsp;                    InputStream in = new FileInputStream(FileDescriptor.in);
<b class="nc"><i>383</i>&nbsp;                    try {</b>
<b class="nc"><i>384</i>&nbsp;                        list(new BufferedInputStream(in), files);</b>
<i>385</i>&nbsp;                    } finally {
<b class="nc"><i>386</i>&nbsp;                        in.close();</b>
<b class="nc"><i>387</i>&nbsp;                    }</b>
<i>388</i>&nbsp;                }
<b class="nc"><i>389</i>&nbsp;            } else if (xflag) {</b>
<b class="nc"><i>390</i>&nbsp;                replaceFSC(filesMap);</b>
<i>391</i>&nbsp;                // For the extract action, when extracting all the entries,
<b class="nc"><i>392</i>&nbsp;                // access using the ZipInputStream class is most efficient,</b>
<b class="nc"><i>393</i>&nbsp;                // since only a single sequential scan through the zip file is</b>
<i>394</i>&nbsp;                // required.  When using the ZipFile class, a &quot;two-finger&quot; scan
<b class="nc"><i>395</i>&nbsp;                // is required, but this is likely to be more efficient when a</b>
<b class="nc"><i>396</i>&nbsp;                // partial extract is requested.  In case the zip file has</b>
<i>397</i>&nbsp;                // &quot;leading garbage&quot;, we fall back from the ZipInputStream
<b class="nc"><i>398</i>&nbsp;                // implementation to the ZipFile implementation, since only the</b>
<b class="nc"><i>399</i>&nbsp;                // latter can handle it.</b>
<i>400</i>&nbsp;
<b class="nc"><i>401</i>&nbsp;                String[] files = filesMapToFiles(filesMap);</b>
<b class="nc"><i>402</i>&nbsp;                if (fname != null &amp;&amp; files != null) {</b>
<b class="nc"><i>403</i>&nbsp;                    extract(fname, files);</b>
<i>404</i>&nbsp;                } else {
<i>405</i>&nbsp;                    InputStream in = (fname == null)
<b class="nc"><i>406</i>&nbsp;                        ? new FileInputStream(FileDescriptor.in)</b>
<b class="nc"><i>407</i>&nbsp;                        : new FileInputStream(fname);</b>
<b class="nc"><i>408</i>&nbsp;                    try {</b>
<i>409</i>&nbsp;                        if (!extract(new BufferedInputStream(in), files) &amp;&amp; fname != null) {
<b class="nc"><i>410</i>&nbsp;                            extract(fname, files);</b>
<b class="nc"><i>411</i>&nbsp;                        }</b>
<i>412</i>&nbsp;                    } finally {
<b class="nc"><i>413</i>&nbsp;                        in.close();</b>
<b class="nc"><i>414</i>&nbsp;                    }</b>
<i>415</i>&nbsp;                }
<b class="nc"><i>416</i>&nbsp;            } else if (iflag) {</b>
<b class="nc"><i>417</i>&nbsp;                String[] files = filesMap.get(BASE_VERSION);  // base entries only, can be null</b>
<i>418</i>&nbsp;                genIndex(rootjar, files);
<b class="nc"><i>419</i>&nbsp;            } else if (dflag) {</b>
<b class="nc"><i>420</i>&nbsp;                boolean found;</b>
<b class="nc"><i>421</i>&nbsp;                if (fname != null) {</b>
<b class="nc"><i>422</i>&nbsp;                    try (ZipFile zf = new ZipFile(fname)) {</b>
<i>423</i>&nbsp;                        found = describeModule(zf);
<i>424</i>&nbsp;                    }
<b class="nc"><i>425</i>&nbsp;                } else {</b>
<b class="nc"><i>426</i>&nbsp;                    try (FileInputStream fin = new FileInputStream(FileDescriptor.in)) {</b>
<b class="nc"><i>427</i>&nbsp;                        found = describeModuleFromStream(fin);</b>
<b class="nc"><i>428</i>&nbsp;                    }</b>
<b class="nc"><i>429</i>&nbsp;                }</b>
<b class="nc"><i>430</i>&nbsp;                if (!found)</b>
<b class="nc"><i>431</i>&nbsp;                    error(getMsg(&quot;error.module.descriptor.not.found&quot;));</b>
<b class="nc"><i>432</i>&nbsp;            }</b>
<i>433</i>&nbsp;        } catch (IOException e) {
<i>434</i>&nbsp;            fatalError(e);
<b class="nc"><i>435</i>&nbsp;            ok = false;</b>
<b class="nc"><i>436</i>&nbsp;        } catch (Error ee) {</b>
<b class="nc"><i>437</i>&nbsp;            ee.printStackTrace();</b>
<b class="nc"><i>438</i>&nbsp;            ok = false;</b>
<i>439</i>&nbsp;        } catch (Throwable t) {
<b class="nc"><i>440</i>&nbsp;            t.printStackTrace();</b>
<b class="nc"><i>441</i>&nbsp;            ok = false;</b>
<i>442</i>&nbsp;        } finally {
<b class="nc"><i>443</i>&nbsp;            if (tmpFile != null &amp;&amp; tmpFile.exists())</b>
<b class="nc"><i>444</i>&nbsp;                tmpFile.delete();</b>
<i>445</i>&nbsp;        }
<b class="nc"><i>446</i>&nbsp;        out.flush();</b>
<b class="nc"><i>447</i>&nbsp;        err.flush();</b>
<b class="nc"><i>448</i>&nbsp;        return ok;</b>
<i>449</i>&nbsp;    }
<b class="nc"><i>450</i>&nbsp;</b>
<b class="nc"><i>451</i>&nbsp;    private void validateAndClose(File tmpfile) throws IOException {</b>
<b class="nc"><i>452</i>&nbsp;        if (ok &amp;&amp; isMultiRelease) {</b>
<b class="nc"><i>453</i>&nbsp;            try (ZipFile zf = new ZipFile(tmpfile)) {</b>
<i>454</i>&nbsp;                ok = Validator.validate(this, zf);
<i>455</i>&nbsp;                if (!ok) {
<b class="nc"><i>456</i>&nbsp;                    error(formatMsg(&quot;error.validator.jarfile.invalid&quot;, fname));</b>
<b class="nc"><i>457</i>&nbsp;                }</b>
<b class="nc"><i>458</i>&nbsp;            } catch (IOException e) {</b>
<b class="nc"><i>459</i>&nbsp;                error(formatMsg2(&quot;error.validator.jarfile.exception&quot;, fname, e.getMessage()));</b>
<b class="nc"><i>460</i>&nbsp;            }</b>
<b class="nc"><i>461</i>&nbsp;        }</b>
<b class="nc"><i>462</i>&nbsp;        Path path = tmpfile.toPath();</b>
<b class="nc"><i>463</i>&nbsp;        try {</b>
<b class="nc"><i>464</i>&nbsp;            if (ok) {</b>
<b class="nc"><i>465</i>&nbsp;                if (fname != null) {</b>
<b class="nc"><i>466</i>&nbsp;                    Files.move(path, Paths.get(fname), StandardCopyOption.REPLACE_EXISTING);</b>
<b class="nc"><i>467</i>&nbsp;                } else {</b>
<i>468</i>&nbsp;                    Files.copy(path, new FileOutputStream(FileDescriptor.out));
<b class="nc"><i>469</i>&nbsp;                }</b>
<i>470</i>&nbsp;            }
<b class="nc"><i>471</i>&nbsp;        } finally {</b>
<b class="nc"><i>472</i>&nbsp;            Files.deleteIfExists(path);</b>
<b class="nc"><i>473</i>&nbsp;        }</b>
<i>474</i>&nbsp;    }
<i>475</i>&nbsp;
<b class="nc"><i>476</i>&nbsp;    private String[] filesMapToFiles(Map&lt;Integer,String[]&gt; filesMap) {</b>
<i>477</i>&nbsp;        if (filesMap.isEmpty()) return null;
<i>478</i>&nbsp;        return filesMap.entrySet()
<i>479</i>&nbsp;                .stream()
<i>480</i>&nbsp;                .flatMap(this::filesToEntryNames)
<i>481</i>&nbsp;                .toArray(String[]::new);
<i>482</i>&nbsp;    }
<i>483</i>&nbsp;
<b class="nc"><i>484</i>&nbsp;    Stream&lt;String&gt; filesToEntryNames(Map.Entry&lt;Integer,String[]&gt; fileEntries) {</b>
<i>485</i>&nbsp;        int version = fileEntries.getKey();
<i>486</i>&nbsp;        Set&lt;String&gt; cpaths = pathsMap.get(version);
<b class="nc"><i>487</i>&nbsp;        return Stream.of(fileEntries.getValue())</b>
<i>488</i>&nbsp;            .map(f -&gt; toVersionedName(toEntryName(f, cpaths, false), version));
<b class="nc"><i>489</i>&nbsp;    }</b>
<b class="nc"><i>490</i>&nbsp;</b>
<i>491</i>&nbsp;    /**
<b class="nc"><i>492</i>&nbsp;     * Parses command line arguments.</b>
<i>493</i>&nbsp;     */
<b class="nc"><i>494</i>&nbsp;    boolean parseArgs(String args[]) {</b>
<b class="nc"><i>495</i>&nbsp;        /* Preprocess and expand @file arguments */</b>
<b class="nc"><i>496</i>&nbsp;        try {</b>
<b class="nc"><i>497</i>&nbsp;            args = CommandLine.parse(args);</b>
<i>498</i>&nbsp;        } catch (FileNotFoundException e) {
<b class="nc"><i>499</i>&nbsp;            fatalError(formatMsg(&quot;error.cant.open&quot;, e.getMessage()));</b>
<b class="nc"><i>500</i>&nbsp;            return false;</b>
<b class="nc"><i>501</i>&nbsp;        } catch (IOException e) {</b>
<b class="nc"><i>502</i>&nbsp;            fatalError(e);</b>
<b class="nc"><i>503</i>&nbsp;            return false;</b>
<i>504</i>&nbsp;        }
<b class="nc"><i>505</i>&nbsp;        /* parse flags */</b>
<i>506</i>&nbsp;        int count = 1;
<b class="nc"><i>507</i>&nbsp;        try {</b>
<i>508</i>&nbsp;            String flags = args[0];
<i>509</i>&nbsp;
<b class="nc"><i>510</i>&nbsp;            // Note: flags.length == 2 can be treated as the short version of</b>
<b class="nc"><i>511</i>&nbsp;            // the GNU option since the there cannot be any other options,</b>
<i>512</i>&nbsp;            // excluding -C, as per the old way.
<i>513</i>&nbsp;            if (flags.startsWith(&quot;--&quot;) ||
<i>514</i>&nbsp;                (flags.startsWith(&quot;-&quot;) &amp;&amp; flags.length() == 2)) {
<i>515</i>&nbsp;                try {
<i>516</i>&nbsp;                    count = GNUStyleOptions.parseOptions(this, args);
<i>517</i>&nbsp;                } catch (GNUStyleOptions.BadArgs x) {
<i>518</i>&nbsp;                    if (info == null) {
<i>519</i>&nbsp;                        if (x.showUsage) {
<i>520</i>&nbsp;                            usageError(x.getMessage());
<i>521</i>&nbsp;                        } else {
<b class="nc"><i>522</i>&nbsp;                            error(x.getMessage());</b>
<b class="nc"><i>523</i>&nbsp;                        }</b>
<b class="nc"><i>524</i>&nbsp;                        return false;</b>
<i>525</i>&nbsp;                    }
<b class="nc"><i>526</i>&nbsp;                }</b>
<b class="nc"><i>527</i>&nbsp;                if (info != null) {</b>
<b class="nc"><i>528</i>&nbsp;                    info.accept(out);</b>
<i>529</i>&nbsp;                    return true;
<b class="nc"><i>530</i>&nbsp;                }</b>
<b class="nc"><i>531</i>&nbsp;            } else {</b>
<b class="nc"><i>532</i>&nbsp;                // Legacy/compatibility options</b>
<b class="nc"><i>533</i>&nbsp;                if (flags.startsWith(&quot;-&quot;)) {</b>
<b class="nc"><i>534</i>&nbsp;                    flags = flags.substring(1);</b>
<b class="nc"><i>535</i>&nbsp;                }</b>
<b class="nc"><i>536</i>&nbsp;                for (int i = 0; i &lt; flags.length(); i++) {</b>
<b class="nc"><i>537</i>&nbsp;                    switch (flags.charAt(i)) {</b>
<b class="nc"><i>538</i>&nbsp;                        case &#39;c&#39;:</b>
<i>539</i>&nbsp;                            if (xflag || tflag || uflag || iflag) {
<b class="nc"><i>540</i>&nbsp;                                usageError(getMsg(&quot;error.multiple.main.operations&quot;));</b>
<b class="nc"><i>541</i>&nbsp;                                return false;</b>
<b class="nc"><i>542</i>&nbsp;                            }</b>
<i>543</i>&nbsp;                            cflag = true;
<b class="nc"><i>544</i>&nbsp;                            break;</b>
<b class="nc"><i>545</i>&nbsp;                        case &#39;u&#39;:</b>
<b class="nc"><i>546</i>&nbsp;                            if (cflag || xflag || tflag || iflag) {</b>
<b class="nc"><i>547</i>&nbsp;                                usageError(getMsg(&quot;error.multiple.main.operations&quot;));</b>
<i>548</i>&nbsp;                                return false;
<i>549</i>&nbsp;                            }
<i>550</i>&nbsp;                            uflag = true;
<b class="nc"><i>551</i>&nbsp;                            break;</b>
<i>552</i>&nbsp;                        case &#39;x&#39;:
<i>553</i>&nbsp;                            if (cflag || uflag || tflag || iflag) {
<i>554</i>&nbsp;                                usageError(getMsg(&quot;error.multiple.main.operations&quot;));
<i>555</i>&nbsp;                                return false;
<i>556</i>&nbsp;                            }
<i>557</i>&nbsp;                            xflag = true;
<i>558</i>&nbsp;                            break;
<i>559</i>&nbsp;                        case &#39;t&#39;:
<i>560</i>&nbsp;                            if (cflag || uflag || xflag || iflag) {
<b class="nc"><i>561</i>&nbsp;                                usageError(getMsg(&quot;error.multiple.main.operations&quot;));</b>
<i>562</i>&nbsp;                                return false;
<b class="nc"><i>563</i>&nbsp;                            }</b>
<b class="nc"><i>564</i>&nbsp;                            tflag = true;</b>
<b class="nc"><i>565</i>&nbsp;                            break;</b>
<b class="nc"><i>566</i>&nbsp;                        case &#39;M&#39;:</b>
<b class="nc"><i>567</i>&nbsp;                            Mflag = true;</b>
<b class="nc"><i>568</i>&nbsp;                            break;</b>
<b class="nc"><i>569</i>&nbsp;                        case &#39;v&#39;:</b>
<i>570</i>&nbsp;                            vflag = true;
<b class="nc"><i>571</i>&nbsp;                            break;</b>
<i>572</i>&nbsp;                        case &#39;f&#39;:
<i>573</i>&nbsp;                            fname = args[count++];
<i>574</i>&nbsp;                            break;
<i>575</i>&nbsp;                        case &#39;m&#39;:
<i>576</i>&nbsp;                            mname = args[count++];
<i>577</i>&nbsp;                            break;
<i>578</i>&nbsp;                        case &#39;0&#39;:
<i>579</i>&nbsp;                            flag0 = true;
<i>580</i>&nbsp;                            break;
<b class="nc"><i>581</i>&nbsp;                        case &#39;i&#39;:</b>
<b class="nc"><i>582</i>&nbsp;                            if (cflag || uflag || xflag || tflag) {</b>
<b class="nc"><i>583</i>&nbsp;                                usageError(getMsg(&quot;error.multiple.main.operations&quot;));</b>
<b class="nc"><i>584</i>&nbsp;                                return false;</b>
<b class="nc"><i>585</i>&nbsp;                            }</b>
<i>586</i>&nbsp;                            // do not increase the counter, files will contain rootjar
<b class="nc"><i>587</i>&nbsp;                            rootjar = args[count++];</b>
<b class="nc"><i>588</i>&nbsp;                            iflag = true;</b>
<i>589</i>&nbsp;                            break;
<i>590</i>&nbsp;                        case &#39;n&#39;:
<i>591</i>&nbsp;                            nflag = true;
<b class="nc"><i>592</i>&nbsp;                            break;</b>
<b class="nc"><i>593</i>&nbsp;                        case &#39;e&#39;:</b>
<i>594</i>&nbsp;                            ename = args[count++];
<b class="nc"><i>595</i>&nbsp;                            break;</b>
<i>596</i>&nbsp;                        case &#39;P&#39;:
<b class="nc"><i>597</i>&nbsp;                            pflag = true;</b>
<i>598</i>&nbsp;                            break;
<b class="nc"><i>599</i>&nbsp;                        default:</b>
<b class="nc"><i>600</i>&nbsp;                            usageError(formatMsg(&quot;error.illegal.option&quot;,</b>
<i>601</i>&nbsp;                                       String.valueOf(flags.charAt(i))));
<b class="nc"><i>602</i>&nbsp;                            return false;</b>
<b class="nc"><i>603</i>&nbsp;                    }</b>
<i>604</i>&nbsp;                }
<i>605</i>&nbsp;            }
<i>606</i>&nbsp;        } catch (ArrayIndexOutOfBoundsException e) {
<b class="nc"><i>607</i>&nbsp;            usageError(getMsg(&quot;main.usage.summary&quot;));</b>
<b class="nc"><i>608</i>&nbsp;            return false;</b>
<b class="nc"><i>609</i>&nbsp;        }</b>
<b class="nc"><i>610</i>&nbsp;        if (!cflag &amp;&amp; !tflag &amp;&amp; !xflag &amp;&amp; !uflag &amp;&amp; !iflag &amp;&amp; !dflag) {</b>
<b class="nc"><i>611</i>&nbsp;            usageError(getMsg(&quot;error.bad.option&quot;));</b>
<i>612</i>&nbsp;            return false;
<i>613</i>&nbsp;        }
<i>614</i>&nbsp;
<i>615</i>&nbsp;        /* parse file arguments */
<b class="nc"><i>616</i>&nbsp;        int n = args.length - count;</b>
<b class="nc"><i>617</i>&nbsp;        if (n &gt; 0) {</b>
<b class="nc"><i>618</i>&nbsp;            int version = BASE_VERSION;</b>
<i>619</i>&nbsp;            int k = 0;
<b class="nc"><i>620</i>&nbsp;            String[] nameBuf = new String[n];</b>
<b class="nc"><i>621</i>&nbsp;            pathsMap.put(version, new HashSet&lt;&gt;());</b>
<i>622</i>&nbsp;            try {
<b class="nc"><i>623</i>&nbsp;                for (int i = count; i &lt; args.length; i++) {</b>
<b class="nc"><i>624</i>&nbsp;                    if (args[i].equals(&quot;-C&quot;)) {</b>
<i>625</i>&nbsp;                        if (dflag) {
<b class="nc"><i>626</i>&nbsp;                            // &quot;--describe-module/-d&quot; does not require file argument(s),</b>
<b class="nc"><i>627</i>&nbsp;                            // but does accept --release</b>
<b class="nc"><i>628</i>&nbsp;                            usageError(getMsg(&quot;error.bad.dflag&quot;));</b>
<b class="nc"><i>629</i>&nbsp;                            return false;</b>
<b class="nc"><i>630</i>&nbsp;                        }</b>
<b class="nc"><i>631</i>&nbsp;                        /* change the directory */</b>
<b class="nc"><i>632</i>&nbsp;                        String dir = args[++i];</b>
<b class="nc"><i>633</i>&nbsp;                        dir = (dir.endsWith(File.separator) ?</b>
<i>634</i>&nbsp;                               dir : (dir + File.separator));
<b class="nc"><i>635</i>&nbsp;                        dir = dir.replace(File.separatorChar, &#39;/&#39;);</b>
<b class="nc"><i>636</i>&nbsp;                        while (dir.indexOf(&quot;//&quot;) &gt; -1) {</b>
<b class="nc"><i>637</i>&nbsp;                            dir = dir.replace(&quot;//&quot;, &quot;/&quot;);</b>
<b class="nc"><i>638</i>&nbsp;                        }</b>
<b class="nc"><i>639</i>&nbsp;                        pathsMap.get(version).add(dir.replace(File.separatorChar, &#39;/&#39;));</b>
<b class="nc"><i>640</i>&nbsp;                        nameBuf[k++] = dir + args[++i];</b>
<b class="nc"><i>641</i>&nbsp;                    } else if (args[i].startsWith(&quot;--release&quot;)) {</b>
<i>642</i>&nbsp;                        int v = BASE_VERSION;
<i>643</i>&nbsp;                        try {
<b class="nc"><i>644</i>&nbsp;                            v = Integer.valueOf(args[++i]);</b>
<i>645</i>&nbsp;                        } catch (NumberFormatException x) {
<i>646</i>&nbsp;                            error(formatMsg(&quot;error.release.value.notnumber&quot;, args[i]));
<b class="nc"><i>647</i>&nbsp;                            // this will fall into the next error, thus returning false</b>
<b class="nc"><i>648</i>&nbsp;                        }</b>
<b class="nc"><i>649</i>&nbsp;                        if (v &lt; 9) {</b>
<b class="nc"><i>650</i>&nbsp;                            usageError(formatMsg(&quot;error.release.value.toosmall&quot;, String.valueOf(v)));</b>
<b class="nc"><i>651</i>&nbsp;                            return false;</b>
<b class="nc"><i>652</i>&nbsp;                        }</b>
<b class="nc"><i>653</i>&nbsp;                        // associate the files, if any, with the previous version number</b>
<b class="nc"><i>654</i>&nbsp;                        if (k &gt; 0) {</b>
<b class="nc"><i>655</i>&nbsp;                            String[] files = new String[k];</b>
<b class="nc"><i>656</i>&nbsp;                            System.arraycopy(nameBuf, 0, files, 0, k);</b>
<i>657</i>&nbsp;                            filesMap.put(version, files);
<i>658</i>&nbsp;                            isMultiRelease = version &gt; BASE_VERSION;
<b class="nc"><i>659</i>&nbsp;                        }</b>
<b class="nc"><i>660</i>&nbsp;                        // reset the counters and start with the new version number</b>
<b class="nc"><i>661</i>&nbsp;                        k = 0;</b>
<i>662</i>&nbsp;                        nameBuf = new String[n];
<i>663</i>&nbsp;                        version = v;
<i>664</i>&nbsp;                        releaseValue = version;
<b class="nc"><i>665</i>&nbsp;                        pathsMap.put(version, new HashSet&lt;&gt;());</b>
<b class="nc"><i>666</i>&nbsp;                    } else {</b>
<b class="nc"><i>667</i>&nbsp;                        if (dflag) {</b>
<i>668</i>&nbsp;                            // &quot;--describe-module/-d&quot; does not require file argument(s),
<i>669</i>&nbsp;                            // but does accept --release
<i>670</i>&nbsp;                            usageError(getMsg(&quot;error.bad.dflag&quot;));
<i>671</i>&nbsp;                            return false;
<i>672</i>&nbsp;                        }
<b class="nc"><i>673</i>&nbsp;                        nameBuf[k++] = args[i];</b>
<b class="nc"><i>674</i>&nbsp;                    }</b>
<b class="nc"><i>675</i>&nbsp;                }</b>
<b class="nc"><i>676</i>&nbsp;            } catch (ArrayIndexOutOfBoundsException e) {</b>
<b class="nc"><i>677</i>&nbsp;                usageError(getMsg(&quot;error.bad.file.arg&quot;));</b>
<b class="nc"><i>678</i>&nbsp;                return false;</b>
<i>679</i>&nbsp;            }
<b class="nc"><i>680</i>&nbsp;            // associate remaining files, if any, with a version</b>
<b class="nc"><i>681</i>&nbsp;            if (k &gt; 0) {</b>
<b class="nc"><i>682</i>&nbsp;                String[] files = new String[k];</b>
<i>683</i>&nbsp;                System.arraycopy(nameBuf, 0, files, 0, k);
<i>684</i>&nbsp;                filesMap.put(version, files);
<i>685</i>&nbsp;                isMultiRelease = version &gt; BASE_VERSION;
<i>686</i>&nbsp;            }
<i>687</i>&nbsp;        } else if (cflag &amp;&amp; (mname == null)) {
<b class="nc"><i>688</i>&nbsp;            usageError(getMsg(&quot;error.bad.cflag&quot;));</b>
<b class="nc"><i>689</i>&nbsp;            return false;</b>
<b class="nc"><i>690</i>&nbsp;        } else if (uflag) {</b>
<b class="nc"><i>691</i>&nbsp;            if ((mname != null) || (ename != null)) {</b>
<i>692</i>&nbsp;                /* just want to update the manifest */
<b class="nc"><i>693</i>&nbsp;                return true;</b>
<b class="nc"><i>694</i>&nbsp;            } else {</b>
<b class="nc"><i>695</i>&nbsp;                usageError(getMsg(&quot;error.bad.uflag&quot;));</b>
<b class="nc"><i>696</i>&nbsp;                return false;</b>
<i>697</i>&nbsp;            }
<b class="nc"><i>698</i>&nbsp;        }</b>
<b class="nc"><i>699</i>&nbsp;        return true;</b>
<b class="nc"><i>700</i>&nbsp;    }</b>
<b class="nc"><i>701</i>&nbsp;</b>
<i>702</i>&nbsp;    /*
<b class="nc"><i>703</i>&nbsp;     * Add the package of the given resource name if it&#39;s a .class</b>
<i>704</i>&nbsp;     * or a resource in a named package.
<i>705</i>&nbsp;     */
<i>706</i>&nbsp;    void addPackageIfNamed(Set&lt;String&gt; packages, String name) {
<b class="nc"><i>707</i>&nbsp;        if (name.startsWith(VERSIONS_DIR)) {</b>
<i>708</i>&nbsp;            // trim the version dir prefix
<i>709</i>&nbsp;            int i0 = VERSIONS_DIR_LENGTH;
<i>710</i>&nbsp;            int i = name.indexOf(&#39;/&#39;, i0);
<b class="nc"><i>711</i>&nbsp;            if (i &lt;= 0) {</b>
<b class="nc"><i>712</i>&nbsp;                warn(formatMsg(&quot;warn.release.unexpected.versioned.entry&quot;, name));</b>
<b class="nc"><i>713</i>&nbsp;                return;</b>
<b class="nc"><i>714</i>&nbsp;            }</b>
<b class="nc"><i>715</i>&nbsp;            while (i0 &lt; i) {</b>
<i>716</i>&nbsp;                char c = name.charAt(i0);
<b class="nc"><i>717</i>&nbsp;                if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {</b>
<i>718</i>&nbsp;                    warn(formatMsg(&quot;warn.release.unexpected.versioned.entry&quot;, name));
<b class="nc"><i>719</i>&nbsp;                    return;</b>
<i>720</i>&nbsp;                }
<i>721</i>&nbsp;                i0++;
<b class="nc"><i>722</i>&nbsp;            }</b>
<b class="nc"><i>723</i>&nbsp;            name = name.substring(i + 1, name.length());</b>
<b class="nc"><i>724</i>&nbsp;        }</b>
<b class="nc"><i>725</i>&nbsp;        String pn = toPackageName(name);</b>
<b class="nc"><i>726</i>&nbsp;        // add if this is a class or resource in a package</b>
<b class="nc"><i>727</i>&nbsp;        if (Checks.isPackageName(pn)) {</b>
<i>728</i>&nbsp;            packages.add(pn);
<b class="nc"><i>729</i>&nbsp;        }</b>
<b class="nc"><i>730</i>&nbsp;    }</b>
<i>731</i>&nbsp;
<b class="nc"><i>732</i>&nbsp;    private String toEntryName(String name, Set&lt;String&gt; cpaths, boolean isDir) {</b>
<b class="nc"><i>733</i>&nbsp;        name = name.replace(File.separatorChar, &#39;/&#39;);</b>
<i>734</i>&nbsp;        if (isDir) {
<b class="nc"><i>735</i>&nbsp;            name = name.endsWith(&quot;/&quot;) ? name : name + &quot;/&quot;;</b>
<i>736</i>&nbsp;        }
<b class="nc"><i>737</i>&nbsp;        String matchPath = &quot;&quot;;</b>
<b class="nc"><i>738</i>&nbsp;        for (String path : cpaths) {</b>
<i>739</i>&nbsp;            if (name.startsWith(path) &amp;&amp; path.length() &gt; matchPath.length()) {
<i>740</i>&nbsp;                matchPath = path;
<b class="nc"><i>741</i>&nbsp;            }</b>
<b class="nc"><i>742</i>&nbsp;        }</b>
<i>743</i>&nbsp;        name = safeName(name.substring(matchPath.length()));
<i>744</i>&nbsp;        // the old implementaton doesn&#39;t remove
<b class="nc"><i>745</i>&nbsp;        // &quot;./&quot; if it was led by &quot;/&quot; (?)</b>
<i>746</i>&nbsp;        if (name.startsWith(&quot;./&quot;)) {
<i>747</i>&nbsp;            name = name.substring(2);
<i>748</i>&nbsp;        }
<b class="nc"><i>749</i>&nbsp;        return name;</b>
<b class="nc"><i>750</i>&nbsp;    }</b>
<b class="nc"><i>751</i>&nbsp;</b>
<b class="nc"><i>752</i>&nbsp;    private static String toVersionedName(String name, int version) {</b>
<b class="nc"><i>753</i>&nbsp;        return version &gt; BASE_VERSION</b>
<b class="nc"><i>754</i>&nbsp;                ? VERSIONS_DIR + version + &quot;/&quot; + name : name;</b>
<i>755</i>&nbsp;    }
<b class="nc"><i>756</i>&nbsp;</b>
<b class="nc"><i>757</i>&nbsp;    private static String toPackageName(String path) {</b>
<b class="nc"><i>758</i>&nbsp;        int index = path.lastIndexOf(&#39;/&#39;);</b>
<i>759</i>&nbsp;        if (index != -1) {
<i>760</i>&nbsp;            return path.substring(0, index).replace(&#39;/&#39;, &#39;.&#39;);
<b class="nc"><i>761</i>&nbsp;        } else {</b>
<b class="nc"><i>762</i>&nbsp;            return &quot;&quot;;</b>
<i>763</i>&nbsp;        }
<b class="nc"><i>764</i>&nbsp;    }</b>
<i>765</i>&nbsp;
<i>766</i>&nbsp;    private void expand() throws IOException {
<i>767</i>&nbsp;        for (int version : filesMap.keySet()) {
<b class="nc"><i>768</i>&nbsp;            String[] files = filesMap.get(version);</b>
<b class="nc"><i>769</i>&nbsp;            expand(null, files, pathsMap.get(version), version);</b>
<b class="nc"><i>770</i>&nbsp;        }</b>
<i>771</i>&nbsp;    }
<i>772</i>&nbsp;
<i>773</i>&nbsp;    /**
<i>774</i>&nbsp;     * Expands list of files to process into full list of all files that
<b class="nc"><i>775</i>&nbsp;     * can be found by recursively descending directories.</b>
<b class="nc"><i>776</i>&nbsp;     *</b>
<b class="nc"><i>777</i>&nbsp;     * @param dir    parent directory</b>
<b class="nc"><i>778</i>&nbsp;     * @param files  list of files to expand</b>
<b class="nc"><i>779</i>&nbsp;     * @param cpaths set of directories specified by -C option for the files</b>
<i>780</i>&nbsp;     * @throws IOException if an I/O error occurs
<i>781</i>&nbsp;     */
<i>782</i>&nbsp;    private void expand(File dir, String[] files, Set&lt;String&gt; cpaths, int version)
<i>783</i>&nbsp;        throws IOException
<i>784</i>&nbsp;    {
<b class="nc"><i>785</i>&nbsp;        if (files == null)</b>
<i>786</i>&nbsp;            return;
<i>787</i>&nbsp;
<b class="nc"><i>788</i>&nbsp;        for (int i = 0; i &lt; files.length; i++) {</b>
<i>789</i>&nbsp;            File f;
<i>790</i>&nbsp;            if (dir == null)
<i>791</i>&nbsp;                f = new File(files[i]);
<b class="nc"><i>792</i>&nbsp;            else</b>
<b class="nc"><i>793</i>&nbsp;                f = new File(dir, files[i]);</b>
<b class="nc"><i>794</i>&nbsp;</b>
<b class="nc"><i>795</i>&nbsp;            boolean isDir = f.isDirectory();</b>
<b class="nc"><i>796</i>&nbsp;            String name = toEntryName(f.getPath(), cpaths, isDir);</b>
<b class="nc"><i>797</i>&nbsp;</b>
<i>798</i>&nbsp;            if (version != BASE_VERSION) {
<i>799</i>&nbsp;                if (name.startsWith(VERSIONS_DIR)) {
<b class="nc"><i>800</i>&nbsp;                    // the entry starts with VERSIONS_DIR and version != BASE_VERSION,</b>
<i>801</i>&nbsp;                    // which means the &quot;[dirs|files]&quot; in --release v [dirs|files]
<i>802</i>&nbsp;                    // includes VERSIONS_DIR-ed entries --&gt; warning and skip (?)
<i>803</i>&nbsp;                    error(formatMsg2(&quot;error.release.unexpected.versioned.entry&quot;,
<i>804</i>&nbsp;                                     name, String.valueOf(version)));
<i>805</i>&nbsp;                    ok = false;
<i>806</i>&nbsp;                    return;
<b class="nc"><i>807</i>&nbsp;                }</b>
<b class="nc"><i>808</i>&nbsp;                name = toVersionedName(name, version);</b>
<b class="nc"><i>809</i>&nbsp;            }</b>
<b class="nc"><i>810</i>&nbsp;</b>
<i>811</i>&nbsp;            if (f.isFile()) {
<i>812</i>&nbsp;                Entry e = new Entry(f, name, false);
<b class="nc"><i>813</i>&nbsp;                if (isModuleInfoEntry(name)) {</b>
<i>814</i>&nbsp;                    moduleInfos.putIfAbsent(name, Files.readAllBytes(f.toPath()));
<b class="nc"><i>815</i>&nbsp;                    if (uflag)</b>
<i>816</i>&nbsp;                        entryMap.put(name, e);
<b class="nc"><i>817</i>&nbsp;                } else if (entries.add(e)) {</b>
<i>818</i>&nbsp;                    if (uflag)
<b class="nc"><i>819</i>&nbsp;                        entryMap.put(name, e);</b>
<b class="nc"><i>820</i>&nbsp;                }</b>
<i>821</i>&nbsp;            } else if (isDir) {
<i>822</i>&nbsp;                Entry e = new Entry(f, name, true);
<i>823</i>&nbsp;                if (entries.add(e)) {
<i>824</i>&nbsp;                    // utilize entryMap for the duplicate dir check even in
<b class="nc"><i>825</i>&nbsp;                    // case of cflag == true.</b>
<i>826</i>&nbsp;                    // dir name confilict/duplicate could happen with -C option.
<b class="nc"><i>827</i>&nbsp;                    // just remove the last &quot;e&quot; from the &quot;entries&quot; (zos will fail</b>
<b class="nc"><i>828</i>&nbsp;                    // with &quot;duplicated&quot; entries), but continue expanding the</b>
<i>829</i>&nbsp;                    // sub tree
<b class="nc"><i>830</i>&nbsp;                    if (entryMap.containsKey(name)) {</b>
<b class="nc"><i>831</i>&nbsp;                        entries.remove(e);</b>
<b class="nc"><i>832</i>&nbsp;                    } else {</b>
<b class="nc"><i>833</i>&nbsp;                        entryMap.put(name, e);</b>
<b class="nc"><i>834</i>&nbsp;                    }</b>
<b class="nc"><i>835</i>&nbsp;                    expand(f, f.list(), cpaths, version);</b>
<b class="nc"><i>836</i>&nbsp;                }</b>
<b class="nc"><i>837</i>&nbsp;            } else {</b>
<i>838</i>&nbsp;                error(formatMsg(&quot;error.nosuch.fileordir&quot;, String.valueOf(f)));
<b class="nc"><i>839</i>&nbsp;                ok = false;</b>
<b class="nc"><i>840</i>&nbsp;            }</b>
<b class="nc"><i>841</i>&nbsp;        }</b>
<i>842</i>&nbsp;    }
<b class="nc"><i>843</i>&nbsp;</b>
<i>844</i>&nbsp;    /**
<b class="nc"><i>845</i>&nbsp;     * Creates a new JAR file.</b>
<b class="nc"><i>846</i>&nbsp;     */</b>
<b class="nc"><i>847</i>&nbsp;    void create(OutputStream out, Manifest manifest) throws IOException</b>
<b class="nc"><i>848</i>&nbsp;    {</b>
<b class="nc"><i>849</i>&nbsp;        try (ZipOutputStream zos = new JarOutputStream(out)) {</b>
<b class="nc"><i>850</i>&nbsp;            if (flag0) {</b>
<b class="nc"><i>851</i>&nbsp;                zos.setMethod(ZipOutputStream.STORED);</b>
<b class="nc"><i>852</i>&nbsp;            }</b>
<b class="nc"><i>853</i>&nbsp;            // TODO: check module-info attributes against manifest ??</b>
<i>854</i>&nbsp;            if (manifest != null) {
<b class="nc"><i>855</i>&nbsp;                if (vflag) {</b>
<b class="nc"><i>856</i>&nbsp;                    output(getMsg(&quot;out.added.manifest&quot;));</b>
<b class="nc"><i>857</i>&nbsp;                }</b>
<i>858</i>&nbsp;                ZipEntry e = new ZipEntry(MANIFEST_DIR);
<i>859</i>&nbsp;                e.setTime(System.currentTimeMillis());
<i>860</i>&nbsp;                e.setSize(0);
<i>861</i>&nbsp;                e.setCrc(0);
<i>862</i>&nbsp;                zos.putNextEntry(e);
<i>863</i>&nbsp;                e = new ZipEntry(MANIFEST_NAME);
<i>864</i>&nbsp;                e.setTime(System.currentTimeMillis());
<i>865</i>&nbsp;                if (flag0) {
<i>866</i>&nbsp;                    crc32Manifest(e, manifest);
<b class="nc"><i>867</i>&nbsp;                }</b>
<i>868</i>&nbsp;                zos.putNextEntry(e);
<i>869</i>&nbsp;                manifest.write(zos);
<i>870</i>&nbsp;                zos.closeEntry();
<i>871</i>&nbsp;            }
<i>872</i>&nbsp;            updateModuleInfo(moduleInfos, zos);
<i>873</i>&nbsp;            for (Entry entry : entries) {
<i>874</i>&nbsp;                addFile(zos, entry);
<i>875</i>&nbsp;            }
<i>876</i>&nbsp;        }
<i>877</i>&nbsp;    }
<i>878</i>&nbsp;
<b class="nc"><i>879</i>&nbsp;    private char toUpperCaseASCII(char c) {</b>
<b class="nc"><i>880</i>&nbsp;        return (c &lt; &#39;a&#39; || c &gt; &#39;z&#39;) ? c : (char) (c + &#39;A&#39; - &#39;a&#39;);</b>
<i>881</i>&nbsp;    }
<i>882</i>&nbsp;
<i>883</i>&nbsp;    /**
<i>884</i>&nbsp;     * Compares two strings for equality, ignoring case.  The second
<i>885</i>&nbsp;     * argument must contain only upper-case ASCII characters.
<i>886</i>&nbsp;     * We don&#39;t want case comparison to be locale-dependent (else we
<i>887</i>&nbsp;     * have the notorious &quot;turkish i bug&quot;).
<i>888</i>&nbsp;     */
<i>889</i>&nbsp;    private boolean equalsIgnoreCase(String s, String upper) {
<i>890</i>&nbsp;        assert upper.toUpperCase(java.util.Locale.ENGLISH).equals(upper);
<i>891</i>&nbsp;        int len;
<b class="nc"><i>892</i>&nbsp;        if ((len = s.length()) != upper.length())</b>
<i>893</i>&nbsp;            return false;
<b class="nc"><i>894</i>&nbsp;        for (int i = 0; i &lt; len; i++) {</b>
<i>895</i>&nbsp;            char c1 = s.charAt(i);
<b class="nc"><i>896</i>&nbsp;            char c2 = upper.charAt(i);</b>
<b class="nc"><i>897</i>&nbsp;            if (c1 != c2 &amp;&amp; toUpperCaseASCII(c1) != c2)</b>
<i>898</i>&nbsp;                return false;
<i>899</i>&nbsp;        }
<i>900</i>&nbsp;        return true;
<i>901</i>&nbsp;    }
<i>902</i>&nbsp;
<i>903</i>&nbsp;    /**
<i>904</i>&nbsp;     * Updates an existing jar file.
<i>905</i>&nbsp;     */
<i>906</i>&nbsp;    boolean update(InputStream in, OutputStream out,
<i>907</i>&nbsp;                   InputStream newManifest,
<i>908</i>&nbsp;                   Map&lt;String,byte[]&gt; moduleInfos,
<b class="nc"><i>909</i>&nbsp;                   JarIndex jarIndex) throws IOException</b>
<i>910</i>&nbsp;    {
<b class="nc"><i>911</i>&nbsp;        ZipInputStream zis = new ZipInputStream(in);</b>
<i>912</i>&nbsp;        ZipOutputStream zos = new JarOutputStream(out);
<b class="nc"><i>913</i>&nbsp;        ZipEntry e = null;</b>
<b class="nc"><i>914</i>&nbsp;        boolean foundManifest = false;</b>
<i>915</i>&nbsp;        boolean updateOk = true;
<i>916</i>&nbsp;
<i>917</i>&nbsp;        // All actual entries added/updated/existing, in the jar file (excl manifest
<i>918</i>&nbsp;        // and module-info.class ).
<i>919</i>&nbsp;        Set&lt;String&gt; jentries = new HashSet&lt;&gt;();
<i>920</i>&nbsp;
<i>921</i>&nbsp;        if (jarIndex != null) {
<b class="nc"><i>922</i>&nbsp;            addIndex(jarIndex, zos);</b>
<b class="nc"><i>923</i>&nbsp;        }</b>
<b class="nc"><i>924</i>&nbsp;</b>
<i>925</i>&nbsp;        // put the old entries first, replace if necessary
<i>926</i>&nbsp;        while ((e = zis.getNextEntry()) != null) {
<i>927</i>&nbsp;            String name = e.getName();
<i>928</i>&nbsp;
<i>929</i>&nbsp;            boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);
<i>930</i>&nbsp;            boolean isModuleInfoEntry = isModuleInfoEntry(name);
<i>931</i>&nbsp;
<b class="nc"><i>932</i>&nbsp;            if ((jarIndex != null &amp;&amp; equalsIgnoreCase(name, INDEX_NAME))</b>
<b class="nc"><i>933</i>&nbsp;                || (Mflag &amp;&amp; isManifestEntry)) {</b>
<b class="nc"><i>934</i>&nbsp;                continue;</b>
<b class="nc"><i>935</i>&nbsp;            } else if (isManifestEntry &amp;&amp; ((newManifest != null) ||</b>
<b class="nc"><i>936</i>&nbsp;                        (ename != null) || isMultiRelease)) {</b>
<i>937</i>&nbsp;                foundManifest = true;
<b class="nc"><i>938</i>&nbsp;                if (newManifest != null) {</b>
<i>939</i>&nbsp;                    // Don&#39;t read from the newManifest InputStream, as we
<i>940</i>&nbsp;                    // might need it below, and we can&#39;t re-read the same data
<i>941</i>&nbsp;                    // twice.
<b class="nc"><i>942</i>&nbsp;                    FileInputStream fis = new FileInputStream(mname);</b>
<b class="nc"><i>943</i>&nbsp;                    boolean ambiguous = isAmbiguousMainClass(new Manifest(fis));</b>
<b class="nc"><i>944</i>&nbsp;                    fis.close();</b>
<i>945</i>&nbsp;                    if (ambiguous) {
<i>946</i>&nbsp;                        return false;
<i>947</i>&nbsp;                    }
<i>948</i>&nbsp;                }
<i>949</i>&nbsp;                // Update the manifest.
<i>950</i>&nbsp;                Manifest old = new Manifest(zis);
<b class="nc"><i>951</i>&nbsp;                if (newManifest != null) {</b>
<i>952</i>&nbsp;                    old.read(newManifest);
<b class="nc"><i>953</i>&nbsp;                }</b>
<i>954</i>&nbsp;                if (!updateManifest(old, zos)) {
<i>955</i>&nbsp;                    return false;
<i>956</i>&nbsp;                }
<i>957</i>&nbsp;            } else if (moduleInfos != null &amp;&amp; isModuleInfoEntry) {
<b class="nc"><i>958</i>&nbsp;                moduleInfos.putIfAbsent(name, zis.readAllBytes());</b>
<b class="nc"><i>959</i>&nbsp;            } else {</b>
<b class="nc"><i>960</i>&nbsp;                boolean isDir = e.isDirectory();</b>
<b class="nc"><i>961</i>&nbsp;                if (!entryMap.containsKey(name)) { // copy the old stuff</b>
<b class="nc"><i>962</i>&nbsp;                    // do our own compression</b>
<b class="nc"><i>963</i>&nbsp;                    ZipEntry e2 = new ZipEntry(name);</b>
<b class="nc"><i>964</i>&nbsp;                    e2.setMethod(e.getMethod());</b>
<i>965</i>&nbsp;                    e2.setTime(e.getTime());
<i>966</i>&nbsp;                    e2.setComment(e.getComment());
<b class="nc"><i>967</i>&nbsp;                    e2.setExtra(e.getExtra());</b>
<i>968</i>&nbsp;                    if (e.getMethod() == ZipEntry.STORED) {
<i>969</i>&nbsp;                        e2.setSize(e.getSize());
<i>970</i>&nbsp;                        e2.setCrc(e.getCrc());
<i>971</i>&nbsp;                    }
<i>972</i>&nbsp;                    zos.putNextEntry(e2);
<i>973</i>&nbsp;                    copy(zis, zos);
<b class="nc"><i>974</i>&nbsp;                } else { // replace with the new files</b>
<i>975</i>&nbsp;                    Entry ent = entryMap.get(name);
<i>976</i>&nbsp;                    addFile(zos, ent);
<i>977</i>&nbsp;                    entryMap.remove(name);
<b class="nc"><i>978</i>&nbsp;                    entries.remove(ent);</b>
<b class="nc"><i>979</i>&nbsp;                    isDir = ent.isDir;</b>
<b class="nc"><i>980</i>&nbsp;                }</b>
<b class="nc"><i>981</i>&nbsp;                if (!isDir) {</b>
<i>982</i>&nbsp;                    jentries.add(name);
<b class="nc"><i>983</i>&nbsp;                }</b>
<b class="nc"><i>984</i>&nbsp;            }</b>
<b class="nc"><i>985</i>&nbsp;        }</b>
<b class="nc"><i>986</i>&nbsp;</b>
<b class="nc"><i>987</i>&nbsp;        // add the remaining new files</b>
<i>988</i>&nbsp;        for (Entry entry : entries) {
<i>989</i>&nbsp;            addFile(zos, entry);
<b class="nc"><i>990</i>&nbsp;            if (!entry.isDir) {</b>
<i>991</i>&nbsp;                jentries.add(entry.name);
<i>992</i>&nbsp;            }
<i>993</i>&nbsp;        }
<i>994</i>&nbsp;        if (!foundManifest) {
<i>995</i>&nbsp;            if (newManifest != null) {
<i>996</i>&nbsp;                Manifest m = new Manifest(newManifest);
<b class="nc"><i>997</i>&nbsp;                updateOk = !isAmbiguousMainClass(m);</b>
<i>998</i>&nbsp;                if (updateOk) {
<i>999</i>&nbsp;                    if (!updateManifest(m, zos)) {
<i>1000</i>&nbsp;                        updateOk = false;
<i>1001</i>&nbsp;                    }
<i>1002</i>&nbsp;                }
<i>1003</i>&nbsp;            } else if (ename != null) {
<b class="nc"><i>1004</i>&nbsp;                if (!updateManifest(new Manifest(), zos)) {</b>
<b class="nc"><i>1005</i>&nbsp;                    updateOk = false;</b>
<b class="nc"><i>1006</i>&nbsp;                }</b>
<b class="nc"><i>1007</i>&nbsp;            }</b>
<b class="nc"><i>1008</i>&nbsp;        }</b>
<b class="nc"><i>1009</i>&nbsp;        if (updateOk) {</b>
<b class="nc"><i>1010</i>&nbsp;            if (moduleInfos != null &amp;&amp; !moduleInfos.isEmpty()) {</b>
<i>1011</i>&nbsp;                Set&lt;String&gt; pkgs = new HashSet&lt;&gt;();
<b class="nc"><i>1012</i>&nbsp;                jentries.forEach( je -&gt; addPackageIfNamed(pkgs, je));</b>
<b class="nc"><i>1013</i>&nbsp;                addExtendedModuleAttributes(moduleInfos, pkgs);</b>
<b class="nc"><i>1014</i>&nbsp;                updateOk = checkModuleInfo(moduleInfos.get(MODULE_INFO), jentries);</b>
<b class="nc"><i>1015</i>&nbsp;                updateModuleInfo(moduleInfos, zos);</b>
<b class="nc"><i>1016</i>&nbsp;                // TODO: check manifest main classes, etc</b>
<i>1017</i>&nbsp;            } else if (moduleVersion != null || modulesToHash != null) {
<i>1018</i>&nbsp;                error(getMsg(&quot;error.module.options.without.info&quot;));
<i>1019</i>&nbsp;                updateOk = false;
<b class="nc"><i>1020</i>&nbsp;            }</b>
<b class="nc"><i>1021</i>&nbsp;        }</b>
<b class="nc"><i>1022</i>&nbsp;        zis.close();</b>
<i>1023</i>&nbsp;        zos.close();
<i>1024</i>&nbsp;        return updateOk;
<i>1025</i>&nbsp;    }
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;    private void addIndex(JarIndex index, ZipOutputStream zos)
<i>1028</i>&nbsp;        throws IOException
<i>1029</i>&nbsp;    {
<i>1030</i>&nbsp;        ZipEntry e = new ZipEntry(INDEX_NAME);
<b class="nc"><i>1031</i>&nbsp;        e.setTime(System.currentTimeMillis());</b>
<i>1032</i>&nbsp;        if (flag0) {
<i>1033</i>&nbsp;            CRC32OutputStream os = new CRC32OutputStream();
<i>1034</i>&nbsp;            index.write(os);
<i>1035</i>&nbsp;            os.updateEntry(e);
<i>1036</i>&nbsp;        }
<b class="nc"><i>1037</i>&nbsp;        zos.putNextEntry(e);</b>
<b class="nc"><i>1038</i>&nbsp;        index.write(zos);</b>
<b class="nc"><i>1039</i>&nbsp;        zos.closeEntry();</b>
<i>1040</i>&nbsp;    }
<b class="nc"><i>1041</i>&nbsp;</b>
<b class="nc"><i>1042</i>&nbsp;    private void updateModuleInfo(Map&lt;String,byte[]&gt; moduleInfos, ZipOutputStream zos)</b>
<b class="nc"><i>1043</i>&nbsp;        throws IOException</b>
<b class="nc"><i>1044</i>&nbsp;    {</b>
<b class="nc"><i>1045</i>&nbsp;        String fmt = uflag ? &quot;out.update.module-info&quot;: &quot;out.added.module-info&quot;;</b>
<b class="nc"><i>1046</i>&nbsp;        for (Map.Entry&lt;String,byte[]&gt; mi : moduleInfos.entrySet()) {</b>
<i>1047</i>&nbsp;            String name = mi.getKey();
<i>1048</i>&nbsp;            byte[] bytes = mi.getValue();
<b class="nc"><i>1049</i>&nbsp;            ZipEntry e = new ZipEntry(name);</b>
<b class="nc"><i>1050</i>&nbsp;            e.setTime(System.currentTimeMillis());</b>
<b class="nc"><i>1051</i>&nbsp;            if (flag0) {</b>
<i>1052</i>&nbsp;                crc32ModuleInfo(e, bytes);
<b class="nc"><i>1053</i>&nbsp;            }</b>
<i>1054</i>&nbsp;            zos.putNextEntry(e);
<i>1055</i>&nbsp;            zos.write(bytes);
<i>1056</i>&nbsp;            zos.closeEntry();
<b class="nc"><i>1057</i>&nbsp;            if (vflag) {</b>
<b class="nc"><i>1058</i>&nbsp;                output(formatMsg(fmt, name));</b>
<i>1059</i>&nbsp;            }
<i>1060</i>&nbsp;        }
<b class="nc"><i>1061</i>&nbsp;    }</b>
<b class="nc"><i>1062</i>&nbsp;</b>
<b class="nc"><i>1063</i>&nbsp;    private boolean updateManifest(Manifest m, ZipOutputStream zos)</b>
<b class="nc"><i>1064</i>&nbsp;        throws IOException</b>
<b class="nc"><i>1065</i>&nbsp;    {</b>
<i>1066</i>&nbsp;        addVersion(m);
<i>1067</i>&nbsp;        addCreatedBy(m);
<i>1068</i>&nbsp;        if (ename != null) {
<b class="nc"><i>1069</i>&nbsp;            addMainClass(m, ename);</b>
<i>1070</i>&nbsp;        }
<b class="nc"><i>1071</i>&nbsp;        if (isMultiRelease) {</b>
<b class="nc"><i>1072</i>&nbsp;            addMultiRelease(m);</b>
<i>1073</i>&nbsp;        }
<b class="nc"><i>1074</i>&nbsp;        ZipEntry e = new ZipEntry(MANIFEST_NAME);</b>
<b class="nc"><i>1075</i>&nbsp;        e.setTime(System.currentTimeMillis());</b>
<b class="nc"><i>1076</i>&nbsp;        if (flag0) {</b>
<b class="nc"><i>1077</i>&nbsp;            crc32Manifest(e, m);</b>
<b class="nc"><i>1078</i>&nbsp;        }</b>
<i>1079</i>&nbsp;        zos.putNextEntry(e);
<b class="nc"><i>1080</i>&nbsp;        m.write(zos);</b>
<i>1081</i>&nbsp;        if (vflag) {
<i>1082</i>&nbsp;            output(getMsg(&quot;out.update.manifest&quot;));
<i>1083</i>&nbsp;        }
<b class="nc"><i>1084</i>&nbsp;        return true;</b>
<b class="nc"><i>1085</i>&nbsp;    }</b>
<b class="nc"><i>1086</i>&nbsp;</b>
<b class="nc"><i>1087</i>&nbsp;    private static final boolean isWinDriveLetter(char c) {</b>
<i>1088</i>&nbsp;        return ((c &gt;= &#39;a&#39;) &amp;&amp; (c &lt;= &#39;z&#39;)) || ((c &gt;= &#39;A&#39;) &amp;&amp; (c &lt;= &#39;Z&#39;));
<i>1089</i>&nbsp;    }
<b class="nc"><i>1090</i>&nbsp;</b>
<i>1091</i>&nbsp;    private String safeName(String name) {
<i>1092</i>&nbsp;        if (!pflag) {
<i>1093</i>&nbsp;            int len = name.length();
<i>1094</i>&nbsp;            int i = name.lastIndexOf(&quot;../&quot;);
<i>1095</i>&nbsp;            if (i == -1) {
<i>1096</i>&nbsp;                i = 0;
<b class="nc"><i>1097</i>&nbsp;            } else {</b>
<i>1098</i>&nbsp;                i += 3; // strip any dot-dot components
<b class="nc"><i>1099</i>&nbsp;            }</b>
<i>1100</i>&nbsp;            if (File.separatorChar == &#39;\\&#39;) {
<i>1101</i>&nbsp;                // the spec requests no drive letter. skip if
<i>1102</i>&nbsp;                // the entry name has one.
<i>1103</i>&nbsp;                while (i &lt; len) {
<i>1104</i>&nbsp;                    int off = i;
<i>1105</i>&nbsp;                    if (i + 1 &lt; len &amp;&amp;
<b class="nc"><i>1106</i>&nbsp;                        name.charAt(i + 1) == &#39;:&#39; &amp;&amp;</b>
<b class="nc"><i>1107</i>&nbsp;                        isWinDriveLetter(name.charAt(i))) {</b>
<i>1108</i>&nbsp;                        i += 2;
<i>1109</i>&nbsp;                    }
<i>1110</i>&nbsp;                    while (i &lt; len &amp;&amp; name.charAt(i) == &#39;/&#39;) {
<i>1111</i>&nbsp;                        i++;
<i>1112</i>&nbsp;                    }
<i>1113</i>&nbsp;                    if (i == off) {
<i>1114</i>&nbsp;                        break;
<b class="nc"><i>1115</i>&nbsp;                    }</b>
<b class="nc"><i>1116</i>&nbsp;                }</b>
<b class="nc"><i>1117</i>&nbsp;            } else {</b>
<b class="nc"><i>1118</i>&nbsp;                while (i &lt; len &amp;&amp; name.charAt(i) == &#39;/&#39;) {</b>
<i>1119</i>&nbsp;                    i++;
<b class="nc"><i>1120</i>&nbsp;                }</b>
<i>1121</i>&nbsp;            }
<i>1122</i>&nbsp;            if (i != 0) {
<i>1123</i>&nbsp;                name = name.substring(i);
<i>1124</i>&nbsp;            }
<i>1125</i>&nbsp;        }
<i>1126</i>&nbsp;        return name;
<i>1127</i>&nbsp;    }
<b class="nc"><i>1128</i>&nbsp;</b>
<b class="nc"><i>1129</i>&nbsp;    private void addVersion(Manifest m) {</b>
<b class="nc"><i>1130</i>&nbsp;        Attributes global = m.getMainAttributes();</b>
<i>1131</i>&nbsp;        if (global.getValue(Attributes.Name.MANIFEST_VERSION) == null) {
<b class="nc"><i>1132</i>&nbsp;            global.put(Attributes.Name.MANIFEST_VERSION, VERSION);</b>
<b class="nc"><i>1133</i>&nbsp;        }</b>
<i>1134</i>&nbsp;    }
<i>1135</i>&nbsp;
<b class="nc"><i>1136</i>&nbsp;    private void addCreatedBy(Manifest m) {</b>
<b class="nc"><i>1137</i>&nbsp;        Attributes global = m.getMainAttributes();</b>
<b class="nc"><i>1138</i>&nbsp;        if (global.getValue(new Attributes.Name(&quot;Created-By&quot;)) == null) {</b>
<b class="nc"><i>1139</i>&nbsp;            String javaVendor = System.getProperty(&quot;java.vendor&quot;);</b>
<i>1140</i>&nbsp;            String jdkVersion = System.getProperty(&quot;java.version&quot;);
<i>1141</i>&nbsp;            global.put(new Attributes.Name(&quot;Created-By&quot;), jdkVersion + &quot; (&quot; +
<b class="nc"><i>1142</i>&nbsp;                        javaVendor + &quot;)&quot;);</b>
<b class="nc"><i>1143</i>&nbsp;        }</b>
<i>1144</i>&nbsp;    }
<i>1145</i>&nbsp;
<b class="nc"><i>1146</i>&nbsp;    private void addMainClass(Manifest m, String mainApp) {</b>
<i>1147</i>&nbsp;        Attributes global = m.getMainAttributes();
<i>1148</i>&nbsp;
<i>1149</i>&nbsp;        // overrides any existing Main-Class attribute
<i>1150</i>&nbsp;        global.put(Attributes.Name.MAIN_CLASS, mainApp);
<i>1151</i>&nbsp;    }
<i>1152</i>&nbsp;
<b class="nc"><i>1153</i>&nbsp;    private void addMultiRelease(Manifest m) {</b>
<b class="nc"><i>1154</i>&nbsp;        Attributes global = m.getMainAttributes();</b>
<b class="nc"><i>1155</i>&nbsp;        global.put(Attributes.Name.MULTI_RELEASE, &quot;true&quot;);</b>
<i>1156</i>&nbsp;    }
<i>1157</i>&nbsp;
<b class="nc"><i>1158</i>&nbsp;    private boolean isAmbiguousMainClass(Manifest m) {</b>
<i>1159</i>&nbsp;        if (ename != null) {
<i>1160</i>&nbsp;            Attributes global = m.getMainAttributes();
<i>1161</i>&nbsp;            if ((global.get(Attributes.Name.MAIN_CLASS) != null)) {
<i>1162</i>&nbsp;                usageError(getMsg(&quot;error.bad.eflag&quot;));
<b class="nc"><i>1163</i>&nbsp;                return true;</b>
<i>1164</i>&nbsp;            }
<b class="nc"><i>1165</i>&nbsp;        }</b>
<b class="nc"><i>1166</i>&nbsp;        return false;</b>
<b class="nc"><i>1167</i>&nbsp;    }</b>
<b class="nc"><i>1168</i>&nbsp;</b>
<b class="nc"><i>1169</i>&nbsp;    /**</b>
<b class="nc"><i>1170</i>&nbsp;     * Adds a new file entry to the ZIP output stream.</b>
<b class="nc"><i>1171</i>&nbsp;     */</b>
<b class="nc"><i>1172</i>&nbsp;    void addFile(ZipOutputStream zos, Entry entry) throws IOException {</b>
<b class="nc"><i>1173</i>&nbsp;</b>
<b class="nc"><i>1174</i>&nbsp;        File file = entry.file;</b>
<b class="nc"><i>1175</i>&nbsp;        String name = entry.name;</b>
<b class="nc"><i>1176</i>&nbsp;        boolean isDir = entry.isDir;</b>
<i>1177</i>&nbsp;
<b class="nc"><i>1178</i>&nbsp;        if (name.equals(&quot;&quot;) || name.equals(&quot;.&quot;) || name.equals(zname)) {</b>
<b class="nc"><i>1179</i>&nbsp;            return;</b>
<i>1180</i>&nbsp;        } else if ((name.equals(MANIFEST_DIR) || name.equals(MANIFEST_NAME))
<i>1181</i>&nbsp;                   &amp;&amp; !Mflag) {
<b class="nc"><i>1182</i>&nbsp;            if (vflag) {</b>
<i>1183</i>&nbsp;                output(formatMsg(&quot;out.ignore.entry&quot;, name));
<i>1184</i>&nbsp;            }
<i>1185</i>&nbsp;            return;
<i>1186</i>&nbsp;        } else if (name.equals(MODULE_INFO)) {
<b class="nc"><i>1187</i>&nbsp;            throw new Error(&quot;Unexpected module info: &quot; + name);</b>
<b class="nc"><i>1188</i>&nbsp;        }</b>
<i>1189</i>&nbsp;
<i>1190</i>&nbsp;        long size = isDir ? 0 : file.length();
<i>1191</i>&nbsp;
<i>1192</i>&nbsp;        if (vflag) {
<i>1193</i>&nbsp;            out.print(formatMsg(&quot;out.adding&quot;, name));
<i>1194</i>&nbsp;        }
<b class="nc"><i>1195</i>&nbsp;        ZipEntry e = new ZipEntry(name);</b>
<b class="nc"><i>1196</i>&nbsp;        e.setTime(file.lastModified());</b>
<i>1197</i>&nbsp;        if (size == 0) {
<i>1198</i>&nbsp;            e.setMethod(ZipEntry.STORED);
<b class="nc"><i>1199</i>&nbsp;            e.setSize(0);</b>
<i>1200</i>&nbsp;            e.setCrc(0);
<i>1201</i>&nbsp;        } else if (flag0) {
<b class="nc"><i>1202</i>&nbsp;            crc32File(e, file);</b>
<b class="nc"><i>1203</i>&nbsp;        }</b>
<i>1204</i>&nbsp;        zos.putNextEntry(e);
<b class="nc"><i>1205</i>&nbsp;        if (!isDir) {</b>
<i>1206</i>&nbsp;            copy(file, zos);
<b class="nc"><i>1207</i>&nbsp;        }</b>
<b class="nc"><i>1208</i>&nbsp;        zos.closeEntry();</b>
<b class="nc"><i>1209</i>&nbsp;        /* report how much compression occurred. */</b>
<i>1210</i>&nbsp;        if (vflag) {
<i>1211</i>&nbsp;            size = e.getSize();
<i>1212</i>&nbsp;            long csize = e.getCompressedSize();
<i>1213</i>&nbsp;            out.print(formatMsg2(&quot;out.size&quot;, String.valueOf(size),
<i>1214</i>&nbsp;                        String.valueOf(csize)));
<i>1215</i>&nbsp;            if (e.getMethod() == ZipEntry.DEFLATED) {
<b class="nc"><i>1216</i>&nbsp;                long ratio = 0;</b>
<b class="nc"><i>1217</i>&nbsp;                if (size != 0) {</b>
<i>1218</i>&nbsp;                    ratio = ((size - csize) * 100) / size;
<b class="nc"><i>1219</i>&nbsp;                }</b>
<b class="nc"><i>1220</i>&nbsp;                output(formatMsg(&quot;out.deflated&quot;, String.valueOf(ratio)));</b>
<b class="nc"><i>1221</i>&nbsp;            } else {</b>
<b class="nc"><i>1222</i>&nbsp;                output(getMsg(&quot;out.stored&quot;));</b>
<i>1223</i>&nbsp;            }
<i>1224</i>&nbsp;        }
<i>1225</i>&nbsp;    }
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;    /**
<i>1228</i>&nbsp;     * A buffer for use only by copy(InputStream, OutputStream).
<i>1229</i>&nbsp;     * Not as clean as allocating a new buffer as needed by copy,
<i>1230</i>&nbsp;     * but significantly more efficient.
<i>1231</i>&nbsp;     */
<i>1232</i>&nbsp;    private byte[] copyBuf = new byte[8192];
<b class="nc"><i>1233</i>&nbsp;</b>
<b class="nc"><i>1234</i>&nbsp;    /**</b>
<b class="nc"><i>1235</i>&nbsp;     * Copies all bytes from the input stream to the output stream.</b>
<b class="nc"><i>1236</i>&nbsp;     * Does not close or flush either stream.</b>
<b class="nc"><i>1237</i>&nbsp;     *</b>
<i>1238</i>&nbsp;     * @param from the input stream to read from
<b class="nc"><i>1239</i>&nbsp;     * @param to the output stream to write to</b>
<b class="nc"><i>1240</i>&nbsp;     * @throws IOException if an I/O error occurs</b>
<b class="nc"><i>1241</i>&nbsp;     */</b>
<b class="nc"><i>1242</i>&nbsp;    private void copy(InputStream from, OutputStream to) throws IOException {</b>
<b class="nc"><i>1243</i>&nbsp;        int n;</b>
<i>1244</i>&nbsp;        while ((n = from.read(copyBuf)) != -1)
<i>1245</i>&nbsp;            to.write(copyBuf, 0, n);
<i>1246</i>&nbsp;    }
<i>1247</i>&nbsp;
<i>1248</i>&nbsp;    /**
<i>1249</i>&nbsp;     * Copies all bytes from the input file to the output stream.
<i>1250</i>&nbsp;     * Does not close or flush the output stream.
<b class="nc"><i>1251</i>&nbsp;     *</b>
<i>1252</i>&nbsp;     * @param from the input file to read from
<i>1253</i>&nbsp;     * @param to the output stream to write to
<i>1254</i>&nbsp;     * @throws IOException if an I/O error occurs
<i>1255</i>&nbsp;     */
<i>1256</i>&nbsp;    private void copy(File from, OutputStream to) throws IOException {
<i>1257</i>&nbsp;        try (InputStream in = new FileInputStream(from)) {
<b class="nc"><i>1258</i>&nbsp;            copy(in, to);</b>
<i>1259</i>&nbsp;        }
<i>1260</i>&nbsp;    }
<i>1261</i>&nbsp;
<i>1262</i>&nbsp;    /**
<i>1263</i>&nbsp;     * Copies all bytes from the input stream to the output file.
<i>1264</i>&nbsp;     * Does not close the input stream.
<i>1265</i>&nbsp;     *
<b class="nc"><i>1266</i>&nbsp;     * @param from the input stream to read from</b>
<i>1267</i>&nbsp;     * @param to the output file to write to
<i>1268</i>&nbsp;     * @throws IOException if an I/O error occurs
<i>1269</i>&nbsp;     */
<i>1270</i>&nbsp;    private void copy(InputStream from, File to) throws IOException {
<i>1271</i>&nbsp;        try (OutputStream out = new FileOutputStream(to)) {
<i>1272</i>&nbsp;            copy(from, out);
<b class="nc"><i>1273</i>&nbsp;        }</b>
<i>1274</i>&nbsp;    }
<i>1275</i>&nbsp;
<i>1276</i>&nbsp;    /**
<i>1277</i>&nbsp;     * Computes the crc32 of a module-info.class.  This is necessary when the
<i>1278</i>&nbsp;     * ZipOutputStream is in STORED mode.
<i>1279</i>&nbsp;     */
<b class="nc"><i>1280</i>&nbsp;    private void crc32ModuleInfo(ZipEntry e, byte[] bytes) throws IOException {</b>
<i>1281</i>&nbsp;        CRC32OutputStream os = new CRC32OutputStream();
<i>1282</i>&nbsp;        ByteArrayInputStream in = new ByteArrayInputStream(bytes);
<i>1283</i>&nbsp;        in.transferTo(os);
<i>1284</i>&nbsp;        os.updateEntry(e);
<i>1285</i>&nbsp;    }
<i>1286</i>&nbsp;
<b class="nc"><i>1287</i>&nbsp;    /**</b>
<b class="nc"><i>1288</i>&nbsp;     * Computes the crc32 of a Manifest.  This is necessary when the</b>
<i>1289</i>&nbsp;     * ZipOutputStream is in STORED mode.
<i>1290</i>&nbsp;     */
<i>1291</i>&nbsp;    private void crc32Manifest(ZipEntry e, Manifest m) throws IOException {
<i>1292</i>&nbsp;        CRC32OutputStream os = new CRC32OutputStream();
<i>1293</i>&nbsp;        m.write(os);
<i>1294</i>&nbsp;        os.updateEntry(e);
<i>1295</i>&nbsp;    }
<i>1296</i>&nbsp;
<b class="nc"><i>1297</i>&nbsp;    /**</b>
<b class="nc"><i>1298</i>&nbsp;     * Computes the crc32 of a File.  This is necessary when the</b>
<i>1299</i>&nbsp;     * ZipOutputStream is in STORED mode.
<i>1300</i>&nbsp;     */
<i>1301</i>&nbsp;    private void crc32File(ZipEntry e, File f) throws IOException {
<i>1302</i>&nbsp;        CRC32OutputStream os = new CRC32OutputStream();
<b class="nc"><i>1303</i>&nbsp;        copy(f, os);</b>
<b class="nc"><i>1304</i>&nbsp;        if (os.n != f.length()) {</b>
<i>1305</i>&nbsp;            throw new JarException(formatMsg(
<i>1306</i>&nbsp;                        &quot;error.incorrect.length&quot;, f.getPath()));
<i>1307</i>&nbsp;        }
<b class="nc"><i>1308</i>&nbsp;        os.updateEntry(e);</b>
<b class="nc"><i>1309</i>&nbsp;    }</b>
<i>1310</i>&nbsp;
<i>1311</i>&nbsp;    void replaceFSC(Map&lt;Integer, String []&gt; filesMap) {
<i>1312</i>&nbsp;        filesMap.keySet().forEach(version -&gt; {
<i>1313</i>&nbsp;            String[] files = filesMap.get(version);
<i>1314</i>&nbsp;            if (files != null) {
<i>1315</i>&nbsp;                for (int i = 0; i &lt; files.length; i++) {
<i>1316</i>&nbsp;                    files[i] = files[i].replace(File.separatorChar, &#39;/&#39;);
<b class="nc"><i>1317</i>&nbsp;                }</b>
<b class="nc"><i>1318</i>&nbsp;            }</b>
<b class="nc"><i>1319</i>&nbsp;        });</b>
<i>1320</i>&nbsp;    }
<i>1321</i>&nbsp;
<i>1322</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1323</i>&nbsp;    Set&lt;ZipEntry&gt; newDirSet() {
<i>1324</i>&nbsp;        return new HashSet&lt;ZipEntry&gt;() {
<i>1325</i>&nbsp;            public boolean add(ZipEntry e) {
<i>1326</i>&nbsp;                return ((e == null || useExtractionTime) ? false : super.add(e));
<i>1327</i>&nbsp;            }};
<b class="nc"><i>1328</i>&nbsp;    }</b>
<i>1329</i>&nbsp;
<i>1330</i>&nbsp;    void updateLastModifiedTime(Set&lt;ZipEntry&gt; zes) throws IOException {
<b class="nc"><i>1331</i>&nbsp;        for (ZipEntry ze : zes) {</b>
<b class="nc"><i>1332</i>&nbsp;            long lastModified = ze.getTime();</b>
<i>1333</i>&nbsp;            if (lastModified != -1) {
<b class="nc"><i>1334</i>&nbsp;                String name = safeName(ze.getName().replace(File.separatorChar, &#39;/&#39;));</b>
<b class="nc"><i>1335</i>&nbsp;                if (name.length() != 0) {</b>
<i>1336</i>&nbsp;                    File f = new File(name.replace(&#39;/&#39;, File.separatorChar));
<b class="nc"><i>1337</i>&nbsp;                    f.setLastModified(lastModified);</b>
<i>1338</i>&nbsp;                }
<b class="nc"><i>1339</i>&nbsp;            }</b>
<b class="nc"><i>1340</i>&nbsp;        }</b>
<b class="nc"><i>1341</i>&nbsp;    }</b>
<i>1342</i>&nbsp;
<b class="nc"><i>1343</i>&nbsp;    /**</b>
<b class="nc"><i>1344</i>&nbsp;     * Extracts specified entries from JAR file.</b>
<i>1345</i>&nbsp;     *
<i>1346</i>&nbsp;     * @return whether entries were found and successfully extracted
<b class="nc"><i>1347</i>&nbsp;     * (indicating this was a zip file without &quot;leading garbage&quot;)</b>
<i>1348</i>&nbsp;     */
<i>1349</i>&nbsp;    boolean extract(InputStream in, String files[]) throws IOException {
<b class="nc"><i>1350</i>&nbsp;        ZipInputStream zis = new ZipInputStream(in);</b>
<i>1351</i>&nbsp;        ZipEntry e;
<i>1352</i>&nbsp;        // Set of all directory entries specified in archive.  Disallows
<i>1353</i>&nbsp;        // null entries.  Disallows all entries if using pre-6.0 behavior.
<i>1354</i>&nbsp;        boolean entriesFound = false;
<i>1355</i>&nbsp;        Set&lt;ZipEntry&gt; dirs = newDirSet();
<i>1356</i>&nbsp;        while ((e = zis.getNextEntry()) != null) {
<i>1357</i>&nbsp;            entriesFound = true;
<i>1358</i>&nbsp;            if (files == null) {
<i>1359</i>&nbsp;                dirs.add(extractFile(zis, e));
<i>1360</i>&nbsp;            } else {
<i>1361</i>&nbsp;                String name = e.getName();
<i>1362</i>&nbsp;                for (String file : files) {
<i>1363</i>&nbsp;                    if (name.startsWith(file)) {
<i>1364</i>&nbsp;                        dirs.add(extractFile(zis, e));
<i>1365</i>&nbsp;                        break;
<i>1366</i>&nbsp;                    }
<i>1367</i>&nbsp;                }
<i>1368</i>&nbsp;            }
<i>1369</i>&nbsp;        }
<i>1370</i>&nbsp;
<i>1371</i>&nbsp;        // Update timestamps of directories specified in archive with their
<i>1372</i>&nbsp;        // timestamps as given in the archive.  We do this after extraction,
<i>1373</i>&nbsp;        // instead of during, because creating a file in a directory changes
<i>1374</i>&nbsp;        // that directory&#39;s timestamp.
<i>1375</i>&nbsp;        updateLastModifiedTime(dirs);
<i>1376</i>&nbsp;
<i>1377</i>&nbsp;        return entriesFound;
<i>1378</i>&nbsp;    }
<i>1379</i>&nbsp;
<i>1380</i>&nbsp;    /**
<i>1381</i>&nbsp;     * Extracts specified entries from JAR file, via ZipFile.
<i>1382</i>&nbsp;     */
<i>1383</i>&nbsp;    void extract(String fname, String files[]) throws IOException {
<i>1384</i>&nbsp;        ZipFile zf = new ZipFile(fname);
<i>1385</i>&nbsp;        Set&lt;ZipEntry&gt; dirs = newDirSet();
<i>1386</i>&nbsp;        Enumeration&lt;? extends ZipEntry&gt; zes = zf.entries();
<i>1387</i>&nbsp;        while (zes.hasMoreElements()) {
<i>1388</i>&nbsp;            ZipEntry e = zes.nextElement();
<i>1389</i>&nbsp;            if (files == null) {
<i>1390</i>&nbsp;                dirs.add(extractFile(zf.getInputStream(e), e));
<i>1391</i>&nbsp;            } else {
<i>1392</i>&nbsp;                String name = e.getName();
<i>1393</i>&nbsp;                for (String file : files) {
<i>1394</i>&nbsp;                    if (name.startsWith(file)) {
<i>1395</i>&nbsp;                        dirs.add(extractFile(zf.getInputStream(e), e));
<i>1396</i>&nbsp;                        break;
<i>1397</i>&nbsp;                    }
<i>1398</i>&nbsp;                }
<i>1399</i>&nbsp;            }
<i>1400</i>&nbsp;        }
<i>1401</i>&nbsp;        zf.close();
<i>1402</i>&nbsp;        updateLastModifiedTime(dirs);
<i>1403</i>&nbsp;    }
<i>1404</i>&nbsp;
<i>1405</i>&nbsp;    /**
<i>1406</i>&nbsp;     * Extracts next entry from JAR file, creating directories as needed.  If
<i>1407</i>&nbsp;     * the entry is for a directory which doesn&#39;t exist prior to this
<i>1408</i>&nbsp;     * invocation, returns that entry, otherwise returns null.
<i>1409</i>&nbsp;     */
<i>1410</i>&nbsp;    ZipEntry extractFile(InputStream is, ZipEntry e) throws IOException {
<i>1411</i>&nbsp;        ZipEntry rc = null;
<i>1412</i>&nbsp;        // The spec requres all slashes MUST be forward &#39;/&#39;, it is possible
<i>1413</i>&nbsp;        // an offending zip/jar entry may uses the backwards slash in its
<i>1414</i>&nbsp;        // name. It might cause problem on Windows platform as it skips
<i>1415</i>&nbsp;        // our &quot;safe&quot; check for leading slahs and dot-dot. So replace them
<i>1416</i>&nbsp;        // with &#39;/&#39;.
<i>1417</i>&nbsp;        String name = safeName(e.getName().replace(File.separatorChar, &#39;/&#39;));
<i>1418</i>&nbsp;        if (name.length() == 0) {
<i>1419</i>&nbsp;            return rc;    // leading &#39;/&#39; or &#39;dot-dot&#39; only path
<i>1420</i>&nbsp;        }
<i>1421</i>&nbsp;        File f = new File(name.replace(&#39;/&#39;, File.separatorChar));
<i>1422</i>&nbsp;        if (e.isDirectory()) {
<i>1423</i>&nbsp;            if (f.exists()) {
<i>1424</i>&nbsp;                if (!f.isDirectory()) {
<i>1425</i>&nbsp;                    throw new IOException(formatMsg(&quot;error.create.dir&quot;,
<i>1426</i>&nbsp;                        f.getPath()));
<i>1427</i>&nbsp;                }
<i>1428</i>&nbsp;            } else {
<i>1429</i>&nbsp;                if (!f.mkdirs()) {
<i>1430</i>&nbsp;                    throw new IOException(formatMsg(&quot;error.create.dir&quot;,
<i>1431</i>&nbsp;                        f.getPath()));
<i>1432</i>&nbsp;                } else {
<i>1433</i>&nbsp;                    rc = e;
<i>1434</i>&nbsp;                }
<i>1435</i>&nbsp;            }
<i>1436</i>&nbsp;
<i>1437</i>&nbsp;            if (vflag) {
<i>1438</i>&nbsp;                output(formatMsg(&quot;out.create&quot;, name));
<i>1439</i>&nbsp;            }
<i>1440</i>&nbsp;        } else {
<i>1441</i>&nbsp;            if (f.getParent() != null) {
<i>1442</i>&nbsp;                File d = new File(f.getParent());
<i>1443</i>&nbsp;                if (!d.exists() &amp;&amp; !d.mkdirs() || !d.isDirectory()) {
<i>1444</i>&nbsp;                    throw new IOException(formatMsg(
<i>1445</i>&nbsp;                        &quot;error.create.dir&quot;, d.getPath()));
<i>1446</i>&nbsp;                }
<i>1447</i>&nbsp;            }
<i>1448</i>&nbsp;            try {
<i>1449</i>&nbsp;                copy(is, f);
<i>1450</i>&nbsp;            } finally {
<i>1451</i>&nbsp;                if (is instanceof ZipInputStream)
<i>1452</i>&nbsp;                    ((ZipInputStream)is).closeEntry();
<i>1453</i>&nbsp;                else
<i>1454</i>&nbsp;                    is.close();
<i>1455</i>&nbsp;            }
<i>1456</i>&nbsp;            if (vflag) {
<i>1457</i>&nbsp;                if (e.getMethod() == ZipEntry.DEFLATED) {
<i>1458</i>&nbsp;                    output(formatMsg(&quot;out.inflated&quot;, name));
<i>1459</i>&nbsp;                } else {
<i>1460</i>&nbsp;                    output(formatMsg(&quot;out.extracted&quot;, name));
<i>1461</i>&nbsp;                }
<i>1462</i>&nbsp;            }
<i>1463</i>&nbsp;        }
<i>1464</i>&nbsp;        if (!useExtractionTime) {
<i>1465</i>&nbsp;            long lastModified = e.getTime();
<i>1466</i>&nbsp;            if (lastModified != -1) {
<i>1467</i>&nbsp;                f.setLastModified(lastModified);
<i>1468</i>&nbsp;            }
<i>1469</i>&nbsp;        }
<i>1470</i>&nbsp;        return rc;
<i>1471</i>&nbsp;    }
<i>1472</i>&nbsp;
<i>1473</i>&nbsp;    /**
<i>1474</i>&nbsp;     * Lists contents of JAR file.
<i>1475</i>&nbsp;     */
<i>1476</i>&nbsp;    void list(InputStream in, String files[]) throws IOException {
<i>1477</i>&nbsp;        ZipInputStream zis = new ZipInputStream(in);
<i>1478</i>&nbsp;        ZipEntry e;
<i>1479</i>&nbsp;        while ((e = zis.getNextEntry()) != null) {
<i>1480</i>&nbsp;            /*
<i>1481</i>&nbsp;             * In the case of a compressed (deflated) entry, the entry size
<i>1482</i>&nbsp;             * is stored immediately following the entry data and cannot be
<i>1483</i>&nbsp;             * determined until the entry is fully read. Therefore, we close
<i>1484</i>&nbsp;             * the entry first before printing out its attributes.
<i>1485</i>&nbsp;             */
<i>1486</i>&nbsp;            zis.closeEntry();
<i>1487</i>&nbsp;            printEntry(e, files);
<i>1488</i>&nbsp;        }
<i>1489</i>&nbsp;    }
<i>1490</i>&nbsp;
<i>1491</i>&nbsp;    /**
<i>1492</i>&nbsp;     * Lists contents of JAR file, via ZipFile.
<i>1493</i>&nbsp;     */
<i>1494</i>&nbsp;    void list(String fname, String files[]) throws IOException {
<i>1495</i>&nbsp;        ZipFile zf = new ZipFile(fname);
<i>1496</i>&nbsp;        Enumeration&lt;? extends ZipEntry&gt; zes = zf.entries();
<i>1497</i>&nbsp;        while (zes.hasMoreElements()) {
<i>1498</i>&nbsp;            printEntry(zes.nextElement(), files);
<i>1499</i>&nbsp;        }
<i>1500</i>&nbsp;        zf.close();
<i>1501</i>&nbsp;    }
<i>1502</i>&nbsp;
<i>1503</i>&nbsp;    /**
<i>1504</i>&nbsp;     * Outputs the class index table to the INDEX.LIST file of the
<i>1505</i>&nbsp;     * root jar file.
<i>1506</i>&nbsp;     */
<i>1507</i>&nbsp;    void dumpIndex(String rootjar, JarIndex index) throws IOException {
<i>1508</i>&nbsp;        File jarFile = new File(rootjar);
<i>1509</i>&nbsp;        Path jarPath = jarFile.toPath();
<i>1510</i>&nbsp;        Path tmpPath = createTempFileInSameDirectoryAs(jarFile).toPath();
<i>1511</i>&nbsp;        try {
<i>1512</i>&nbsp;            if (update(Files.newInputStream(jarPath),
<i>1513</i>&nbsp;                       Files.newOutputStream(tmpPath),
<i>1514</i>&nbsp;                       null, null, index)) {
<i>1515</i>&nbsp;                try {
<i>1516</i>&nbsp;                    Files.move(tmpPath, jarPath, REPLACE_EXISTING);
<i>1517</i>&nbsp;                } catch (IOException e) {
<i>1518</i>&nbsp;                    throw new IOException(getMsg(&quot;error.write.file&quot;), e);
<i>1519</i>&nbsp;                }
<i>1520</i>&nbsp;            }
<i>1521</i>&nbsp;        } finally {
<i>1522</i>&nbsp;            Files.deleteIfExists(tmpPath);
<i>1523</i>&nbsp;        }
<i>1524</i>&nbsp;    }
<i>1525</i>&nbsp;
<i>1526</i>&nbsp;    private HashSet&lt;String&gt; jarPaths = new HashSet&lt;String&gt;();
<i>1527</i>&nbsp;
<i>1528</i>&nbsp;    /**
<i>1529</i>&nbsp;     * Generates the transitive closure of the Class-Path attribute for
<i>1530</i>&nbsp;     * the specified jar file.
<i>1531</i>&nbsp;     */
<i>1532</i>&nbsp;    List&lt;String&gt; getJarPath(String jar) throws IOException {
<i>1533</i>&nbsp;        List&lt;String&gt; files = new ArrayList&lt;String&gt;();
<i>1534</i>&nbsp;        files.add(jar);
<i>1535</i>&nbsp;        jarPaths.add(jar);
<i>1536</i>&nbsp;
<i>1537</i>&nbsp;        // take out the current path
<i>1538</i>&nbsp;        String path = jar.substring(0, Math.max(0, jar.lastIndexOf(&#39;/&#39;) + 1));
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;        // class path attribute will give us jar file name with
<i>1541</i>&nbsp;        // &#39;/&#39; as separators, so we need to change them to the
<i>1542</i>&nbsp;        // appropriate one before we open the jar file.
<i>1543</i>&nbsp;        JarFile rf = new JarFile(jar.replace(&#39;/&#39;, File.separatorChar));
<i>1544</i>&nbsp;
<i>1545</i>&nbsp;        if (rf != null) {
<i>1546</i>&nbsp;            Manifest man = rf.getManifest();
<i>1547</i>&nbsp;            if (man != null) {
<i>1548</i>&nbsp;                Attributes attr = man.getMainAttributes();
<i>1549</i>&nbsp;                if (attr != null) {
<i>1550</i>&nbsp;                    String value = attr.getValue(Attributes.Name.CLASS_PATH);
<i>1551</i>&nbsp;                    if (value != null) {
<i>1552</i>&nbsp;                        StringTokenizer st = new StringTokenizer(value);
<i>1553</i>&nbsp;                        while (st.hasMoreTokens()) {
<i>1554</i>&nbsp;                            String ajar = st.nextToken();
<i>1555</i>&nbsp;                            if (!ajar.endsWith(&quot;/&quot;)) {  // it is a jar file
<i>1556</i>&nbsp;                                ajar = path.concat(ajar);
<i>1557</i>&nbsp;                                /* check on cyclic dependency */
<i>1558</i>&nbsp;                                if (! jarPaths.contains(ajar)) {
<i>1559</i>&nbsp;                                    files.addAll(getJarPath(ajar));
<i>1560</i>&nbsp;                                }
<i>1561</i>&nbsp;                            }
<i>1562</i>&nbsp;                        }
<i>1563</i>&nbsp;                    }
<i>1564</i>&nbsp;                }
<i>1565</i>&nbsp;            }
<i>1566</i>&nbsp;        }
<i>1567</i>&nbsp;        rf.close();
<i>1568</i>&nbsp;        return files;
<i>1569</i>&nbsp;    }
<i>1570</i>&nbsp;
<i>1571</i>&nbsp;    /**
<i>1572</i>&nbsp;     * Generates class index file for the specified root jar file.
<i>1573</i>&nbsp;     */
<i>1574</i>&nbsp;    void genIndex(String rootjar, String[] files) throws IOException {
<i>1575</i>&nbsp;        List&lt;String&gt; jars = getJarPath(rootjar);
<i>1576</i>&nbsp;        int njars = jars.size();
<i>1577</i>&nbsp;        String[] jarfiles;
<i>1578</i>&nbsp;
<i>1579</i>&nbsp;        if (njars == 1 &amp;&amp; files != null) {
<i>1580</i>&nbsp;            // no class-path attribute defined in rootjar, will
<i>1581</i>&nbsp;            // use command line specified list of jars
<i>1582</i>&nbsp;            for (int i = 0; i &lt; files.length; i++) {
<i>1583</i>&nbsp;                jars.addAll(getJarPath(files[i]));
<i>1584</i>&nbsp;            }
<i>1585</i>&nbsp;            njars = jars.size();
<i>1586</i>&nbsp;        }
<i>1587</i>&nbsp;        jarfiles = jars.toArray(new String[njars]);
<i>1588</i>&nbsp;        JarIndex index = new JarIndex(jarfiles);
<i>1589</i>&nbsp;        dumpIndex(rootjar, index);
<i>1590</i>&nbsp;    }
<i>1591</i>&nbsp;
<i>1592</i>&nbsp;    /**
<i>1593</i>&nbsp;     * Prints entry information, if requested.
<i>1594</i>&nbsp;     */
<i>1595</i>&nbsp;    void printEntry(ZipEntry e, String[] files) throws IOException {
<i>1596</i>&nbsp;        if (files == null) {
<i>1597</i>&nbsp;            printEntry(e);
<i>1598</i>&nbsp;        } else {
<i>1599</i>&nbsp;            String name = e.getName();
<i>1600</i>&nbsp;            for (String file : files) {
<i>1601</i>&nbsp;                if (name.startsWith(file)) {
<i>1602</i>&nbsp;                    printEntry(e);
<i>1603</i>&nbsp;                    return;
<i>1604</i>&nbsp;                }
<i>1605</i>&nbsp;            }
<i>1606</i>&nbsp;        }
<i>1607</i>&nbsp;    }
<i>1608</i>&nbsp;
<i>1609</i>&nbsp;    /**
<i>1610</i>&nbsp;     * Prints entry information.
<i>1611</i>&nbsp;     */
<i>1612</i>&nbsp;    void printEntry(ZipEntry e) throws IOException {
<i>1613</i>&nbsp;        if (vflag) {
<i>1614</i>&nbsp;            StringBuilder sb = new StringBuilder();
<i>1615</i>&nbsp;            String s = Long.toString(e.getSize());
<i>1616</i>&nbsp;            for (int i = 6 - s.length(); i &gt; 0; --i) {
<i>1617</i>&nbsp;                sb.append(&#39; &#39;);
<i>1618</i>&nbsp;            }
<i>1619</i>&nbsp;            sb.append(s).append(&#39; &#39;).append(new Date(e.getTime()).toString());
<i>1620</i>&nbsp;            sb.append(&#39; &#39;).append(e.getName());
<i>1621</i>&nbsp;            output(sb.toString());
<i>1622</i>&nbsp;        } else {
<i>1623</i>&nbsp;            output(e.getName());
<i>1624</i>&nbsp;        }
<i>1625</i>&nbsp;    }
<i>1626</i>&nbsp;
<i>1627</i>&nbsp;    /**
<i>1628</i>&nbsp;     * Prints usage message.
<i>1629</i>&nbsp;     */
<i>1630</i>&nbsp;    void usageError(String s) {
<i>1631</i>&nbsp;        err.println(s);
<i>1632</i>&nbsp;        err.println(getMsg(&quot;main.usage.summary.try&quot;));
<i>1633</i>&nbsp;    }
<i>1634</i>&nbsp;
<i>1635</i>&nbsp;    /**
<i>1636</i>&nbsp;     * A fatal exception has been caught.  No recovery possible
<i>1637</i>&nbsp;     */
<i>1638</i>&nbsp;    void fatalError(Exception e) {
<i>1639</i>&nbsp;        e.printStackTrace();
<i>1640</i>&nbsp;    }
<i>1641</i>&nbsp;
<i>1642</i>&nbsp;    /**
<i>1643</i>&nbsp;     * A fatal condition has been detected; message is &quot;s&quot;.
<i>1644</i>&nbsp;     * No recovery possible
<i>1645</i>&nbsp;     */
<i>1646</i>&nbsp;    void fatalError(String s) {
<i>1647</i>&nbsp;        error(program + &quot;: &quot; + s);
<i>1648</i>&nbsp;    }
<i>1649</i>&nbsp;
<i>1650</i>&nbsp;    /**
<i>1651</i>&nbsp;     * Print an output message; like verbose output and the like
<i>1652</i>&nbsp;     */
<i>1653</i>&nbsp;    protected void output(String s) {
<i>1654</i>&nbsp;        out.println(s);
<i>1655</i>&nbsp;    }
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;    /**
<i>1658</i>&nbsp;     * Print an error message; like something is broken
<i>1659</i>&nbsp;     */
<i>1660</i>&nbsp;    void error(String s) {
<i>1661</i>&nbsp;        err.println(s);
<i>1662</i>&nbsp;    }
<i>1663</i>&nbsp;
<i>1664</i>&nbsp;    /**
<i>1665</i>&nbsp;     * Print a warning message
<i>1666</i>&nbsp;     */
<i>1667</i>&nbsp;    void warn(String s) {
<i>1668</i>&nbsp;        err.println(s);
<i>1669</i>&nbsp;    }
<i>1670</i>&nbsp;
<i>1671</i>&nbsp;    /**
<i>1672</i>&nbsp;     * Main routine to start program.
<i>1673</i>&nbsp;     */
<i>1674</i>&nbsp;    public static void main(String args[]) {
<i>1675</i>&nbsp;        Main jartool = new Main(System.out, System.err, &quot;jar&quot;);
<i>1676</i>&nbsp;        System.exit(jartool.run(args) ? 0 : 1);
<i>1677</i>&nbsp;    }
<i>1678</i>&nbsp;
<i>1679</i>&nbsp;    /**
<i>1680</i>&nbsp;     * An OutputStream that doesn&#39;t send its output anywhere, (but could).
<i>1681</i>&nbsp;     * It&#39;s here to find the CRC32 of an input file, necessary for STORED
<i>1682</i>&nbsp;     * mode in ZIP.
<i>1683</i>&nbsp;     */
<i>1684</i>&nbsp;    private static class CRC32OutputStream extends java.io.OutputStream {
<i>1685</i>&nbsp;        final CRC32 crc = new CRC32();
<i>1686</i>&nbsp;        long n = 0;
<i>1687</i>&nbsp;
<i>1688</i>&nbsp;        CRC32OutputStream() {}
<i>1689</i>&nbsp;
<i>1690</i>&nbsp;        public void write(int r) throws IOException {
<i>1691</i>&nbsp;            crc.update(r);
<i>1692</i>&nbsp;            n++;
<i>1693</i>&nbsp;        }
<i>1694</i>&nbsp;
<i>1695</i>&nbsp;        public void write(byte[] b, int off, int len) throws IOException {
<i>1696</i>&nbsp;            crc.update(b, off, len);
<i>1697</i>&nbsp;            n += len;
<i>1698</i>&nbsp;        }
<i>1699</i>&nbsp;
<i>1700</i>&nbsp;        /**
<i>1701</i>&nbsp;         * Updates a ZipEntry which describes the data read by this
<i>1702</i>&nbsp;         * output stream, in STORED mode.
<i>1703</i>&nbsp;         */
<i>1704</i>&nbsp;        public void updateEntry(ZipEntry e) {
<i>1705</i>&nbsp;            e.setMethod(ZipEntry.STORED);
<i>1706</i>&nbsp;            e.setSize(n);
<i>1707</i>&nbsp;            e.setCrc(crc.getValue());
<i>1708</i>&nbsp;        }
<i>1709</i>&nbsp;    }
<i>1710</i>&nbsp;
<i>1711</i>&nbsp;    /**
<i>1712</i>&nbsp;     * Attempt to create temporary file in the system-provided temporary folder, if failed attempts
<i>1713</i>&nbsp;     * to create it in the same folder as the file in parameter (if any)
<i>1714</i>&nbsp;     */
<i>1715</i>&nbsp;    private File createTemporaryFile(String tmpbase, String suffix) {
<i>1716</i>&nbsp;        File tmpfile = null;
<i>1717</i>&nbsp;
<i>1718</i>&nbsp;        try {
<i>1719</i>&nbsp;            tmpfile = File.createTempFile(tmpbase, suffix);
<i>1720</i>&nbsp;        } catch (IOException | SecurityException e) {
<i>1721</i>&nbsp;            // Unable to create file due to permission violation or security exception
<i>1722</i>&nbsp;        }
<i>1723</i>&nbsp;        if (tmpfile == null) {
<i>1724</i>&nbsp;            // Were unable to create temporary file, fall back to temporary file in the same folder
<i>1725</i>&nbsp;            if (fname != null) {
<i>1726</i>&nbsp;                try {
<i>1727</i>&nbsp;                    File tmpfolder = new File(fname).getAbsoluteFile().getParentFile();
<i>1728</i>&nbsp;                    tmpfile = File.createTempFile(fname, &quot;.tmp&quot; + suffix, tmpfolder);
<i>1729</i>&nbsp;                } catch (IOException ioe) {
<i>1730</i>&nbsp;                    // Last option failed - fall gracefully
<i>1731</i>&nbsp;                    fatalError(ioe);
<i>1732</i>&nbsp;                }
<i>1733</i>&nbsp;            } else {
<i>1734</i>&nbsp;                // No options left - we can not compress to stdout without access to the temporary folder
<i>1735</i>&nbsp;                fatalError(new IOException(getMsg(&quot;error.create.tempfile&quot;)));
<i>1736</i>&nbsp;            }
<i>1737</i>&nbsp;        }
<i>1738</i>&nbsp;        return tmpfile;
<i>1739</i>&nbsp;    }
<i>1740</i>&nbsp;
<i>1741</i>&nbsp;    // Modular jar support
<i>1742</i>&nbsp;
<i>1743</i>&nbsp;    /**
<i>1744</i>&nbsp;     * Associates a module descriptor&#39;s zip entry name along with its
<i>1745</i>&nbsp;     * bytes and an optional URI. Used when describing modules.
<i>1746</i>&nbsp;     */
<i>1747</i>&nbsp;    interface ModuleInfoEntry {
<i>1748</i>&nbsp;       String name();
<i>1749</i>&nbsp;       Optional&lt;String&gt; uriString();
<i>1750</i>&nbsp;       InputStream bytes() throws IOException;
<i>1751</i>&nbsp;    }
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;    static class ZipFileModuleInfoEntry implements ModuleInfoEntry {
<i>1754</i>&nbsp;        private final ZipFile zipFile;
<i>1755</i>&nbsp;        private final ZipEntry entry;
<i>1756</i>&nbsp;        ZipFileModuleInfoEntry(ZipFile zipFile, ZipEntry entry) {
<i>1757</i>&nbsp;            this.zipFile = zipFile;
<i>1758</i>&nbsp;            this.entry = entry;
<i>1759</i>&nbsp;        }
<i>1760</i>&nbsp;        @Override public String name() { return entry.getName(); }
<i>1761</i>&nbsp;        @Override public InputStream bytes() throws IOException {
<i>1762</i>&nbsp;            return zipFile.getInputStream(entry);
<i>1763</i>&nbsp;        }
<i>1764</i>&nbsp;        /** Returns an optional containing the effective URI. */
<i>1765</i>&nbsp;        @Override public Optional&lt;String&gt; uriString() {
<i>1766</i>&nbsp;            String uri = (Paths.get(zipFile.getName())).toUri().toString();
<i>1767</i>&nbsp;            uri = &quot;jar:&quot; + uri + &quot;/!&quot; + entry.getName();
<i>1768</i>&nbsp;            return Optional.of(uri);
<i>1769</i>&nbsp;        }
<i>1770</i>&nbsp;    }
<i>1771</i>&nbsp;
<i>1772</i>&nbsp;    static class StreamedModuleInfoEntry implements ModuleInfoEntry {
<i>1773</i>&nbsp;        private final String name;
<i>1774</i>&nbsp;        private final byte[] bytes;
<i>1775</i>&nbsp;        StreamedModuleInfoEntry(String name, byte[] bytes) {
<i>1776</i>&nbsp;            this.name = name;
<i>1777</i>&nbsp;            this.bytes = bytes;
<i>1778</i>&nbsp;        }
<i>1779</i>&nbsp;        @Override public String name() { return name; }
<i>1780</i>&nbsp;        @Override public InputStream bytes() throws IOException {
<i>1781</i>&nbsp;            return new ByteArrayInputStream(bytes);
<i>1782</i>&nbsp;        }
<i>1783</i>&nbsp;        /** Returns an empty optional. */
<i>1784</i>&nbsp;        @Override public Optional&lt;String&gt; uriString() {
<i>1785</i>&nbsp;            return Optional.empty();  // no URI can be derived
<i>1786</i>&nbsp;        }
<i>1787</i>&nbsp;    }
<i>1788</i>&nbsp;
<i>1789</i>&nbsp;    /** Describes a module from a given zip file. */
<i>1790</i>&nbsp;    private boolean describeModule(ZipFile zipFile) throws IOException {
<i>1791</i>&nbsp;        ZipFileModuleInfoEntry[] infos = zipFile.stream()
<i>1792</i>&nbsp;                .filter(e -&gt; isModuleInfoEntry(e.getName()))
<i>1793</i>&nbsp;                .sorted(ENTRY_COMPARATOR)
<i>1794</i>&nbsp;                .map(e -&gt; new ZipFileModuleInfoEntry(zipFile, e))
<i>1795</i>&nbsp;                .toArray(ZipFileModuleInfoEntry[]::new);
<i>1796</i>&nbsp;
<i>1797</i>&nbsp;        if (infos.length == 0) {
<i>1798</i>&nbsp;            // No module descriptor found, derive and describe the automatic module
<i>1799</i>&nbsp;            String fn = zipFile.getName();
<i>1800</i>&nbsp;            ModuleFinder mf = ModuleFinder.of(Paths.get(fn));
<i>1801</i>&nbsp;            try {
<i>1802</i>&nbsp;                Set&lt;ModuleReference&gt; mref = mf.findAll();
<i>1803</i>&nbsp;                if (mref.isEmpty()) {
<i>1804</i>&nbsp;                    output(formatMsg(&quot;error.unable.derive.automodule&quot;, fn));
<i>1805</i>&nbsp;                    return true;
<i>1806</i>&nbsp;                }
<i>1807</i>&nbsp;                ModuleDescriptor md = mref.iterator().next().descriptor();
<i>1808</i>&nbsp;                output(getMsg(&quot;out.automodule&quot;) + &quot;\n&quot;);
<i>1809</i>&nbsp;                describeModule(md, null, null, &quot;&quot;);
<i>1810</i>&nbsp;            } catch (FindException e) {
<i>1811</i>&nbsp;                String msg = formatMsg(&quot;error.unable.derive.automodule&quot;, fn);
<i>1812</i>&nbsp;                Throwable t = e.getCause();
<i>1813</i>&nbsp;                if (t != null)
<i>1814</i>&nbsp;                    msg = msg + &quot;\n&quot; + t.getMessage();
<i>1815</i>&nbsp;                output(msg);
<i>1816</i>&nbsp;            }
<i>1817</i>&nbsp;        } else {
<i>1818</i>&nbsp;            return describeModuleFromEntries(infos);
<i>1819</i>&nbsp;        }
<i>1820</i>&nbsp;        return true;
<i>1821</i>&nbsp;    }
<i>1822</i>&nbsp;
<i>1823</i>&nbsp;    private boolean describeModuleFromStream(FileInputStream fis)
<i>1824</i>&nbsp;        throws IOException
<i>1825</i>&nbsp;    {
<i>1826</i>&nbsp;        List&lt;ModuleInfoEntry&gt; infos = new LinkedList&lt;&gt;();
<i>1827</i>&nbsp;
<i>1828</i>&nbsp;        try (BufferedInputStream bis = new BufferedInputStream(fis);
<i>1829</i>&nbsp;             ZipInputStream zis = new ZipInputStream(bis)) {
<i>1830</i>&nbsp;            ZipEntry e;
<i>1831</i>&nbsp;            while ((e = zis.getNextEntry()) != null) {
<i>1832</i>&nbsp;                String ename = e.getName();
<i>1833</i>&nbsp;                if (isModuleInfoEntry(ename)) {
<i>1834</i>&nbsp;                    infos.add(new StreamedModuleInfoEntry(ename, zis.readAllBytes()));
<i>1835</i>&nbsp;                }
<i>1836</i>&nbsp;            }
<i>1837</i>&nbsp;        }
<i>1838</i>&nbsp;
<i>1839</i>&nbsp;        if (infos.size() == 0)
<i>1840</i>&nbsp;            return false;
<i>1841</i>&nbsp;
<i>1842</i>&nbsp;        ModuleInfoEntry[] sorted = infos.stream()
<i>1843</i>&nbsp;                .sorted(Comparator.comparing(ModuleInfoEntry::name, ENTRYNAME_COMPARATOR))
<i>1844</i>&nbsp;                .toArray(ModuleInfoEntry[]::new);
<i>1845</i>&nbsp;
<i>1846</i>&nbsp;        return describeModuleFromEntries(sorted);
<i>1847</i>&nbsp;    }
<i>1848</i>&nbsp;
<i>1849</i>&nbsp;    private boolean lessThanEqualReleaseValue(ModuleInfoEntry entry) {
<i>1850</i>&nbsp;        return intVersionFromEntry(entry) &lt;= releaseValue ? true : false;
<i>1851</i>&nbsp;    }
<i>1852</i>&nbsp;
<i>1853</i>&nbsp;    private static String versionFromEntryName(String name) {
<i>1854</i>&nbsp;        String s = name.substring(VERSIONS_DIR_LENGTH);
<i>1855</i>&nbsp;        return s.substring(0, s.indexOf(&quot;/&quot;));
<i>1856</i>&nbsp;    }
<i>1857</i>&nbsp;
<i>1858</i>&nbsp;    private static int intVersionFromEntry(ModuleInfoEntry entry) {
<i>1859</i>&nbsp;        String name = entry.name();
<i>1860</i>&nbsp;        if (!name.startsWith(VERSIONS_DIR))
<i>1861</i>&nbsp;            return BASE_VERSION;
<i>1862</i>&nbsp;
<i>1863</i>&nbsp;        String s = name.substring(VERSIONS_DIR_LENGTH);
<i>1864</i>&nbsp;        s = s.substring(0, s.indexOf(&#39;/&#39;));
<i>1865</i>&nbsp;        return Integer.valueOf(s);
<i>1866</i>&nbsp;    }
<i>1867</i>&nbsp;
<i>1868</i>&nbsp;    /**
<i>1869</i>&nbsp;     * Describes a single module descriptor, determined by the specified
<i>1870</i>&nbsp;     * --release, if any, from the given ordered entries.
<i>1871</i>&nbsp;     * The given infos must be ordered as per ENTRY_COMPARATOR.
<i>1872</i>&nbsp;     */
<i>1873</i>&nbsp;    private boolean describeModuleFromEntries(ModuleInfoEntry[] infos)
<i>1874</i>&nbsp;        throws IOException
<i>1875</i>&nbsp;    {
<i>1876</i>&nbsp;        assert infos.length &gt; 0;
<i>1877</i>&nbsp;
<i>1878</i>&nbsp;        // Informative: output all non-root descriptors, if any
<i>1879</i>&nbsp;        String releases = Arrays.stream(infos)
<i>1880</i>&nbsp;                .filter(e -&gt; !e.name().equals(MODULE_INFO))
<i>1881</i>&nbsp;                .map(ModuleInfoEntry::name)
<i>1882</i>&nbsp;                .map(Main::versionFromEntryName)
<i>1883</i>&nbsp;                .collect(joining(&quot; &quot;));
<i>1884</i>&nbsp;        if (!releases.equals(&quot;&quot;))
<i>1885</i>&nbsp;            output(&quot;releases: &quot; + releases + &quot;\n&quot;);
<i>1886</i>&nbsp;
<i>1887</i>&nbsp;        // Describe the operative descriptor for the specified --release, if any
<i>1888</i>&nbsp;        if (releaseValue != -1) {
<i>1889</i>&nbsp;            ModuleInfoEntry entry = null;
<i>1890</i>&nbsp;            int i = 0;
<i>1891</i>&nbsp;            while (i &lt; infos.length &amp;&amp; lessThanEqualReleaseValue(infos[i])) {
<i>1892</i>&nbsp;                entry = infos[i];
<i>1893</i>&nbsp;                i++;
<i>1894</i>&nbsp;            }
<i>1895</i>&nbsp;
<i>1896</i>&nbsp;            if (entry == null) {
<i>1897</i>&nbsp;                output(formatMsg(&quot;error.no.operative.descriptor&quot;,
<i>1898</i>&nbsp;                                 String.valueOf(releaseValue)));
<i>1899</i>&nbsp;                return false;
<i>1900</i>&nbsp;            }
<i>1901</i>&nbsp;
<i>1902</i>&nbsp;            String uriString = entry.uriString().orElse(&quot;&quot;);
<i>1903</i>&nbsp;            try (InputStream is = entry.bytes()) {
<i>1904</i>&nbsp;                describeModule(is, uriString);
<i>1905</i>&nbsp;            }
<i>1906</i>&nbsp;        } else {
<i>1907</i>&nbsp;            // no specific --release specified, output the root, if any
<i>1908</i>&nbsp;            if (infos[0].name().equals(MODULE_INFO)) {
<i>1909</i>&nbsp;                String uriString = infos[0].uriString().orElse(&quot;&quot;);
<i>1910</i>&nbsp;                try (InputStream is = infos[0].bytes()) {
<i>1911</i>&nbsp;                    describeModule(is, uriString);
<i>1912</i>&nbsp;                }
<i>1913</i>&nbsp;            } else {
<i>1914</i>&nbsp;                // no root, output message to specify --release
<i>1915</i>&nbsp;                output(getMsg(&quot;error.no.root.descriptor&quot;));
<i>1916</i>&nbsp;            }
<i>1917</i>&nbsp;        }
<i>1918</i>&nbsp;        return true;
<i>1919</i>&nbsp;    }
<i>1920</i>&nbsp;
<i>1921</i>&nbsp;    static &lt;T&gt; String toLowerCaseString(Collection&lt;T&gt; set) {
<i>1922</i>&nbsp;        if (set.isEmpty()) { return &quot;&quot;; }
<i>1923</i>&nbsp;        return &quot; &quot; + set.stream().map(e -&gt; e.toString().toLowerCase(Locale.ROOT))
<i>1924</i>&nbsp;                  .sorted().collect(joining(&quot; &quot;));
<i>1925</i>&nbsp;    }
<i>1926</i>&nbsp;
<i>1927</i>&nbsp;    static &lt;T&gt; String toString(Collection&lt;T&gt; set) {
<i>1928</i>&nbsp;        if (set.isEmpty()) { return &quot;&quot;; }
<i>1929</i>&nbsp;        return &quot; &quot; + set.stream().map(e -&gt; e.toString()).sorted().collect(joining(&quot; &quot;));
<i>1930</i>&nbsp;    }
<i>1931</i>&nbsp;
<i>1932</i>&nbsp;    private void describeModule(InputStream entryInputStream, String uriString)
<i>1933</i>&nbsp;        throws IOException
<i>1934</i>&nbsp;    {
<i>1935</i>&nbsp;        ModuleInfo.Attributes attrs = ModuleInfo.read(entryInputStream, null);
<i>1936</i>&nbsp;        ModuleDescriptor md = attrs.descriptor();
<i>1937</i>&nbsp;        ModuleTarget target = attrs.target();
<i>1938</i>&nbsp;        ModuleHashes hashes = attrs.recordedHashes();
<i>1939</i>&nbsp;
<i>1940</i>&nbsp;        describeModule(md, target, hashes, uriString);
<i>1941</i>&nbsp;    }
<i>1942</i>&nbsp;
<i>1943</i>&nbsp;    private void describeModule(ModuleDescriptor md,
<i>1944</i>&nbsp;                                ModuleTarget target,
<i>1945</i>&nbsp;                                ModuleHashes hashes,
<i>1946</i>&nbsp;                                String uriString)
<i>1947</i>&nbsp;        throws IOException
<i>1948</i>&nbsp;    {
<i>1949</i>&nbsp;        StringBuilder sb = new StringBuilder();
<i>1950</i>&nbsp;
<i>1951</i>&nbsp;        sb.append(md.toNameAndVersion());
<i>1952</i>&nbsp;
<i>1953</i>&nbsp;        if (!uriString.equals(&quot;&quot;))
<i>1954</i>&nbsp;            sb.append(&quot; &quot;).append(uriString);
<i>1955</i>&nbsp;        if (md.isOpen())
<i>1956</i>&nbsp;            sb.append(&quot; open&quot;);
<i>1957</i>&nbsp;        if (md.isAutomatic())
<i>1958</i>&nbsp;            sb.append(&quot; automatic&quot;);
<i>1959</i>&nbsp;        sb.append(&quot;\n&quot;);
<i>1960</i>&nbsp;
<i>1961</i>&nbsp;        // unqualified exports (sorted by package)
<i>1962</i>&nbsp;        md.exports().stream()
<i>1963</i>&nbsp;                .sorted(Comparator.comparing(Exports::source))
<i>1964</i>&nbsp;                .filter(e -&gt; !e.isQualified())
<i>1965</i>&nbsp;                .forEach(e -&gt; sb.append(&quot;exports &quot;).append(e.source())
<i>1966</i>&nbsp;                                .append(toLowerCaseString(e.modifiers()))
<i>1967</i>&nbsp;                                .append(&quot;\n&quot;));
<i>1968</i>&nbsp;
<i>1969</i>&nbsp;        // dependences
<i>1970</i>&nbsp;        md.requires().stream().sorted()
<i>1971</i>&nbsp;                .forEach(r -&gt; sb.append(&quot;requires &quot;).append(r.name())
<i>1972</i>&nbsp;                                .append(toLowerCaseString(r.modifiers()))
<i>1973</i>&nbsp;                                .append(&quot;\n&quot;));
<i>1974</i>&nbsp;
<i>1975</i>&nbsp;        // service use and provides
<i>1976</i>&nbsp;        md.uses().stream().sorted()
<i>1977</i>&nbsp;                .forEach(s -&gt; sb.append(&quot;uses &quot;).append(s).append(&quot;\n&quot;));
<i>1978</i>&nbsp;
<i>1979</i>&nbsp;        md.provides().stream()
<i>1980</i>&nbsp;                .sorted(Comparator.comparing(Provides::service))
<i>1981</i>&nbsp;                .forEach(p -&gt; sb.append(&quot;provides &quot;).append(p.service())
<i>1982</i>&nbsp;                                .append(&quot; with&quot;)
<i>1983</i>&nbsp;                                .append(toString(p.providers()))
<i>1984</i>&nbsp;                                .append(&quot;\n&quot;));
<i>1985</i>&nbsp;
<i>1986</i>&nbsp;        // qualified exports
<i>1987</i>&nbsp;        md.exports().stream()
<i>1988</i>&nbsp;                .sorted(Comparator.comparing(Exports::source))
<i>1989</i>&nbsp;                .filter(Exports::isQualified)
<i>1990</i>&nbsp;                .forEach(e -&gt; sb.append(&quot;qualified exports &quot;).append(e.source())
<i>1991</i>&nbsp;                                .append(&quot; to&quot;).append(toLowerCaseString(e.targets()))
<i>1992</i>&nbsp;                                .append(&quot;\n&quot;));
<i>1993</i>&nbsp;
<i>1994</i>&nbsp;        // open packages
<i>1995</i>&nbsp;        md.opens().stream()
<i>1996</i>&nbsp;                .sorted(Comparator.comparing(Opens::source))
<i>1997</i>&nbsp;                .filter(o -&gt; !o.isQualified())
<i>1998</i>&nbsp;                .forEach(o -&gt; sb.append(&quot;opens &quot;).append(o.source())
<i>1999</i>&nbsp;                                 .append(toLowerCaseString(o.modifiers()))
<i>2000</i>&nbsp;                                 .append(&quot;\n&quot;));
<i>2001</i>&nbsp;
<i>2002</i>&nbsp;        md.opens().stream()
<i>2003</i>&nbsp;                .sorted(Comparator.comparing(Opens::source))
<i>2004</i>&nbsp;                .filter(Opens::isQualified)
<i>2005</i>&nbsp;                .forEach(o -&gt; sb.append(&quot;qualified opens &quot;).append(o.source())
<i>2006</i>&nbsp;                                 .append(toLowerCaseString(o.modifiers()))
<i>2007</i>&nbsp;                                 .append(&quot; to&quot;).append(toLowerCaseString(o.targets()))
<i>2008</i>&nbsp;                                 .append(&quot;\n&quot;));
<i>2009</i>&nbsp;
<i>2010</i>&nbsp;        // non-exported/non-open packages
<i>2011</i>&nbsp;        Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
<i>2012</i>&nbsp;        md.exports().stream().map(Exports::source).forEach(concealed::remove);
<i>2013</i>&nbsp;        md.opens().stream().map(Opens::source).forEach(concealed::remove);
<i>2014</i>&nbsp;        concealed.forEach(p -&gt; sb.append(&quot;contains &quot;).append(p).append(&quot;\n&quot;));
<i>2015</i>&nbsp;
<i>2016</i>&nbsp;        md.mainClass().ifPresent(v -&gt; sb.append(&quot;main-class &quot;).append(v).append(&quot;\n&quot;));
<i>2017</i>&nbsp;
<i>2018</i>&nbsp;        if (target != null) {
<i>2019</i>&nbsp;            String targetPlatform = target.targetPlatform();
<i>2020</i>&nbsp;            if (!targetPlatform.isEmpty())
<i>2021</i>&nbsp;                sb.append(&quot;platform &quot;).append(targetPlatform).append(&quot;\n&quot;);
<i>2022</i>&nbsp;       }
<i>2023</i>&nbsp;
<i>2024</i>&nbsp;       if (hashes != null) {
<i>2025</i>&nbsp;           hashes.names().stream().sorted().forEach(
<i>2026</i>&nbsp;                   mod -&gt; sb.append(&quot;hashes &quot;).append(mod).append(&quot; &quot;)
<i>2027</i>&nbsp;                            .append(hashes.algorithm()).append(&quot; &quot;)
<i>2028</i>&nbsp;                            .append(toHex(hashes.hashFor(mod)))
<i>2029</i>&nbsp;                            .append(&quot;\n&quot;));
<i>2030</i>&nbsp;        }
<i>2031</i>&nbsp;
<i>2032</i>&nbsp;        output(sb.toString());
<i>2033</i>&nbsp;    }
<i>2034</i>&nbsp;
<i>2035</i>&nbsp;    private static String toHex(byte[] ba) {
<i>2036</i>&nbsp;        StringBuilder sb = new StringBuilder(ba.length &lt;&lt; 1);
<i>2037</i>&nbsp;        for (byte b: ba) {
<i>2038</i>&nbsp;            sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
<i>2039</i>&nbsp;        }
<i>2040</i>&nbsp;        return sb.toString();
<i>2041</i>&nbsp;    }
<i>2042</i>&nbsp;
<i>2043</i>&nbsp;    static String toBinaryName(String classname) {
<i>2044</i>&nbsp;        return (classname.replace(&#39;.&#39;, &#39;/&#39;)) + &quot;.class&quot;;
<i>2045</i>&nbsp;    }
<i>2046</i>&nbsp;
<i>2047</i>&nbsp;    private boolean checkModuleInfo(byte[] moduleInfoBytes, Set&lt;String&gt; entries)
<i>2048</i>&nbsp;        throws IOException
<i>2049</i>&nbsp;    {
<i>2050</i>&nbsp;        boolean ok = true;
<i>2051</i>&nbsp;        if (moduleInfoBytes != null) {  // no root module-info.class if null
<i>2052</i>&nbsp;            try {
<i>2053</i>&nbsp;                // ModuleDescriptor.read() checks open/exported pkgs vs packages
<i>2054</i>&nbsp;                ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes));
<i>2055</i>&nbsp;                // A module must have the implementation class of the services it &#39;provides&#39;.
<i>2056</i>&nbsp;                if (md.provides().stream().map(Provides::providers).flatMap(List::stream)
<i>2057</i>&nbsp;                      .filter(p -&gt; !entries.contains(toBinaryName(p)))
<i>2058</i>&nbsp;                      .peek(p -&gt; fatalError(formatMsg(&quot;error.missing.provider&quot;, p)))
<i>2059</i>&nbsp;                      .count() != 0) {
<i>2060</i>&nbsp;                    ok = false;
<i>2061</i>&nbsp;                }
<i>2062</i>&nbsp;            } catch (InvalidModuleDescriptorException x) {
<i>2063</i>&nbsp;                fatalError(x.getMessage());
<i>2064</i>&nbsp;                ok = false;
<i>2065</i>&nbsp;            }
<i>2066</i>&nbsp;        }
<i>2067</i>&nbsp;        return ok;
<i>2068</i>&nbsp;    }
<i>2069</i>&nbsp;
<i>2070</i>&nbsp;    /**
<i>2071</i>&nbsp;     * Adds extended modules attributes to the given module-info&#39;s.  The given
<i>2072</i>&nbsp;     * Map values are updated in-place. Returns false if an error occurs.
<i>2073</i>&nbsp;     */
<i>2074</i>&nbsp;    private void addExtendedModuleAttributes(Map&lt;String,byte[]&gt; moduleInfos,
<i>2075</i>&nbsp;                                                Set&lt;String&gt; packages)
<i>2076</i>&nbsp;        throws IOException
<i>2077</i>&nbsp;    {
<i>2078</i>&nbsp;        for (Map.Entry&lt;String,byte[]&gt; e: moduleInfos.entrySet()) {
<i>2079</i>&nbsp;            ModuleDescriptor md = ModuleDescriptor.read(ByteBuffer.wrap(e.getValue()));
<i>2080</i>&nbsp;            e.setValue(extendedInfoBytes(md, e.getValue(), packages));
<i>2081</i>&nbsp;        }
<i>2082</i>&nbsp;    }
<i>2083</i>&nbsp;
<i>2084</i>&nbsp;    static boolean isModuleInfoEntry(String name) {
<i>2085</i>&nbsp;        // root or versioned module-info.class
<i>2086</i>&nbsp;        if (name.endsWith(MODULE_INFO)) {
<i>2087</i>&nbsp;            int end = name.length() - MODULE_INFO.length();
<i>2088</i>&nbsp;            if (end == 0)
<i>2089</i>&nbsp;                return true;
<i>2090</i>&nbsp;            if (name.startsWith(VERSIONS_DIR)) {
<i>2091</i>&nbsp;                int off = VERSIONS_DIR_LENGTH;
<i>2092</i>&nbsp;                if (off == end)      // meta-inf/versions/module-info.class
<i>2093</i>&nbsp;                    return false;
<i>2094</i>&nbsp;                while (off &lt; end - 1) {
<i>2095</i>&nbsp;                    char c = name.charAt(off++);
<i>2096</i>&nbsp;                    if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
<i>2097</i>&nbsp;                        return false;
<i>2098</i>&nbsp;                }
<i>2099</i>&nbsp;                return name.charAt(off) == &#39;/&#39;;
<i>2100</i>&nbsp;            }
<i>2101</i>&nbsp;        }
<i>2102</i>&nbsp;        return false;
<i>2103</i>&nbsp;    }
<i>2104</i>&nbsp;
<i>2105</i>&nbsp;    /**
<i>2106</i>&nbsp;     * Returns a byte array containing the given module-info.class plus any
<i>2107</i>&nbsp;     * extended attributes.
<i>2108</i>&nbsp;     *
<i>2109</i>&nbsp;     * If --module-version, --main-class, or other options were provided
<i>2110</i>&nbsp;     * then the corresponding class file attributes are added to the
<i>2111</i>&nbsp;     * module-info here.
<i>2112</i>&nbsp;     */
<i>2113</i>&nbsp;    private byte[] extendedInfoBytes(ModuleDescriptor md,
<i>2114</i>&nbsp;                                     byte[] miBytes,
<i>2115</i>&nbsp;                                     Set&lt;String&gt; packages)
<i>2116</i>&nbsp;        throws IOException
<i>2117</i>&nbsp;    {
<i>2118</i>&nbsp;        ByteArrayOutputStream baos = new ByteArrayOutputStream();
<i>2119</i>&nbsp;        InputStream is = new ByteArrayInputStream(miBytes);
<i>2120</i>&nbsp;        ModuleInfoExtender extender = ModuleInfoExtender.newExtender(is);
<i>2121</i>&nbsp;
<i>2122</i>&nbsp;        // Add (or replace) the Packages attribute
<i>2123</i>&nbsp;        extender.packages(packages);
<i>2124</i>&nbsp;
<i>2125</i>&nbsp;        // --main-class
<i>2126</i>&nbsp;        if (ename != null)
<i>2127</i>&nbsp;            extender.mainClass(ename);
<i>2128</i>&nbsp;
<i>2129</i>&nbsp;        // --module-version
<i>2130</i>&nbsp;        if (moduleVersion != null)
<i>2131</i>&nbsp;            extender.version(moduleVersion);
<i>2132</i>&nbsp;
<i>2133</i>&nbsp;        // --hash-modules
<i>2134</i>&nbsp;        if (modulesToHash != null) {
<i>2135</i>&nbsp;            String mn = md.name();
<i>2136</i>&nbsp;            Hasher hasher = new Hasher(md, fname);
<i>2137</i>&nbsp;            ModuleHashes moduleHashes = hasher.computeHashes(mn);
<i>2138</i>&nbsp;            if (moduleHashes != null) {
<i>2139</i>&nbsp;                extender.hashes(moduleHashes);
<i>2140</i>&nbsp;            } else {
<i>2141</i>&nbsp;                warn(&quot;warning: no module is recorded in hash in &quot; + mn);
<i>2142</i>&nbsp;            }
<i>2143</i>&nbsp;        }
<i>2144</i>&nbsp;
<i>2145</i>&nbsp;        if (moduleResolution.value() != 0) {
<i>2146</i>&nbsp;            extender.moduleResolution(moduleResolution);
<i>2147</i>&nbsp;        }
<i>2148</i>&nbsp;
<i>2149</i>&nbsp;        extender.write(baos);
<i>2150</i>&nbsp;        return baos.toByteArray();
<i>2151</i>&nbsp;    }
<i>2152</i>&nbsp;
<i>2153</i>&nbsp;    /**
<i>2154</i>&nbsp;     * Compute and record hashes
<i>2155</i>&nbsp;     */
<i>2156</i>&nbsp;    private class Hasher {
<i>2157</i>&nbsp;        final ModuleHashesBuilder hashesBuilder;
<i>2158</i>&nbsp;        final ModuleFinder finder;
<i>2159</i>&nbsp;        final Set&lt;String&gt; modules;
<i>2160</i>&nbsp;        Hasher(ModuleDescriptor descriptor, String fname) throws IOException {
<i>2161</i>&nbsp;            // Create a module finder that finds the modular JAR
<i>2162</i>&nbsp;            // being created/updated
<i>2163</i>&nbsp;            URI uri = Paths.get(fname).toUri();
<i>2164</i>&nbsp;            ModuleReference mref = new ModuleReference(descriptor, uri) {
<i>2165</i>&nbsp;                @Override
<i>2166</i>&nbsp;                public ModuleReader open() {
<i>2167</i>&nbsp;                    throw new UnsupportedOperationException(&quot;should not reach here&quot;);
<i>2168</i>&nbsp;                }
<i>2169</i>&nbsp;            };
<i>2170</i>&nbsp;
<i>2171</i>&nbsp;            // Compose a module finder with the module path and
<i>2172</i>&nbsp;            // the modular JAR being created or updated
<i>2173</i>&nbsp;            this.finder = ModuleFinder.compose(moduleFinder,
<i>2174</i>&nbsp;                new ModuleFinder() {
<i>2175</i>&nbsp;                    @Override
<i>2176</i>&nbsp;                    public Optional&lt;ModuleReference&gt; find(String name) {
<i>2177</i>&nbsp;                        if (descriptor.name().equals(name))
<i>2178</i>&nbsp;                            return Optional.of(mref);
<i>2179</i>&nbsp;                        else
<i>2180</i>&nbsp;                            return Optional.empty();
<i>2181</i>&nbsp;                    }
<i>2182</i>&nbsp;
<i>2183</i>&nbsp;                    @Override
<i>2184</i>&nbsp;                    public Set&lt;ModuleReference&gt; findAll() {
<i>2185</i>&nbsp;                        return Collections.singleton(mref);
<i>2186</i>&nbsp;                    }
<i>2187</i>&nbsp;                });
<i>2188</i>&nbsp;
<i>2189</i>&nbsp;            // Determine the modules that matches the pattern {@code modulesToHash}
<i>2190</i>&nbsp;            Set&lt;String&gt; roots = finder.findAll().stream()
<i>2191</i>&nbsp;                .map(ref -&gt; ref.descriptor().name())
<i>2192</i>&nbsp;                .filter(mn -&gt; modulesToHash.matcher(mn).find())
<i>2193</i>&nbsp;                .collect(Collectors.toSet());
<i>2194</i>&nbsp;
<i>2195</i>&nbsp;            // use system module path unless it creates a modular JAR for
<i>2196</i>&nbsp;            // a module that is present in the system image e.g. upgradeable
<i>2197</i>&nbsp;            // module
<i>2198</i>&nbsp;            ModuleFinder system;
<i>2199</i>&nbsp;            String name = descriptor.name();
<i>2200</i>&nbsp;            if (name != null &amp;&amp; ModuleFinder.ofSystem().find(name).isPresent()) {
<i>2201</i>&nbsp;                system = ModuleFinder.of();
<i>2202</i>&nbsp;            } else {
<i>2203</i>&nbsp;                system = ModuleFinder.ofSystem();
<i>2204</i>&nbsp;            }
<i>2205</i>&nbsp;            // get a resolved module graph
<i>2206</i>&nbsp;            Configuration config =
<i>2207</i>&nbsp;                Configuration.empty().resolve(system, finder, roots);
<i>2208</i>&nbsp;
<i>2209</i>&nbsp;            // filter modules resolved from the system module finder
<i>2210</i>&nbsp;            this.modules = config.modules().stream()
<i>2211</i>&nbsp;                .map(ResolvedModule::name)
<i>2212</i>&nbsp;                .filter(mn -&gt; roots.contains(mn) &amp;&amp; !system.find(mn).isPresent())
<i>2213</i>&nbsp;                .collect(Collectors.toSet());
<i>2214</i>&nbsp;
<i>2215</i>&nbsp;            this.hashesBuilder = new ModuleHashesBuilder(config, modules);
<i>2216</i>&nbsp;        }
<i>2217</i>&nbsp;
<i>2218</i>&nbsp;        /**
<i>2219</i>&nbsp;         * Compute hashes of the specified module.
<i>2220</i>&nbsp;         *
<i>2221</i>&nbsp;         * It records the hashing modules that depend upon the specified
<i>2222</i>&nbsp;         * module directly or indirectly.
<i>2223</i>&nbsp;         */
<i>2224</i>&nbsp;        ModuleHashes computeHashes(String name) {
<i>2225</i>&nbsp;            if (hashesBuilder == null)
<i>2226</i>&nbsp;                return null;
<i>2227</i>&nbsp;
<i>2228</i>&nbsp;            return hashesBuilder.computeHashes(Set.of(name)).get(name);
<i>2229</i>&nbsp;        }
<i>2230</i>&nbsp;    }
<i>2231</i>&nbsp;
<i>2232</i>&nbsp;    // sort base entries before versioned entries, and sort entry classes with
<i>2233</i>&nbsp;    // nested classes so that the outter class appears before the associated
<i>2234</i>&nbsp;    // nested class
<i>2235</i>&nbsp;    static Comparator&lt;String&gt; ENTRYNAME_COMPARATOR = (s1, s2) -&gt;  {
<i>2236</i>&nbsp;
<i>2237</i>&nbsp;        if (s1.equals(s2)) return 0;
<i>2238</i>&nbsp;        boolean b1 = s1.startsWith(VERSIONS_DIR);
<i>2239</i>&nbsp;        boolean b2 = s2.startsWith(VERSIONS_DIR);
<i>2240</i>&nbsp;        if (b1 &amp;&amp; !b2) return 1;
<i>2241</i>&nbsp;        if (!b1 &amp;&amp; b2) return -1;
<i>2242</i>&nbsp;        int n = 0; // starting char for String compare
<i>2243</i>&nbsp;        if (b1 &amp;&amp; b2) {
<i>2244</i>&nbsp;            // normally strings would be sorted so &quot;10&quot; goes before &quot;9&quot;, but
<i>2245</i>&nbsp;            // version number strings need to be sorted numerically
<i>2246</i>&nbsp;            n = VERSIONS_DIR.length();   // skip the common prefix
<i>2247</i>&nbsp;            int i1 = s1.indexOf(&#39;/&#39;, n);
<i>2248</i>&nbsp;            int i2 = s2.indexOf(&#39;/&#39;, n);
<i>2249</i>&nbsp;            if (i1 == -1) throw new Validator.InvalidJarException(s1);
<i>2250</i>&nbsp;            if (i2 == -1) throw new Validator.InvalidJarException(s2);
<i>2251</i>&nbsp;            // shorter version numbers go first
<i>2252</i>&nbsp;            if (i1 != i2) return i1 - i2;
<i>2253</i>&nbsp;            // otherwise, handle equal length numbers below
<i>2254</i>&nbsp;        }
<i>2255</i>&nbsp;        int l1 = s1.length();
<i>2256</i>&nbsp;        int l2 = s2.length();
<i>2257</i>&nbsp;        int lim = Math.min(l1, l2);
<i>2258</i>&nbsp;        for (int k = n; k &lt; lim; k++) {
<i>2259</i>&nbsp;            char c1 = s1.charAt(k);
<i>2260</i>&nbsp;            char c2 = s2.charAt(k);
<i>2261</i>&nbsp;            if (c1 != c2) {
<i>2262</i>&nbsp;                // change natural ordering so &#39;.&#39; comes before &#39;$&#39;
<i>2263</i>&nbsp;                // i.e. outer classes come before nested classes
<i>2264</i>&nbsp;                if (c1 == &#39;$&#39; &amp;&amp; c2 == &#39;.&#39;) return 1;
<i>2265</i>&nbsp;                if (c1 == &#39;.&#39; &amp;&amp; c2 == &#39;$&#39;) return -1;
<i>2266</i>&nbsp;                return c1 - c2;
<i>2267</i>&nbsp;            }
<i>2268</i>&nbsp;        }
<i>2269</i>&nbsp;        return l1 - l2;
<i>2270</i>&nbsp;    };
<i>2271</i>&nbsp;
<i>2272</i>&nbsp;    static Comparator&lt;ZipEntry&gt; ENTRY_COMPARATOR =
<i>2273</i>&nbsp;        Comparator.comparing(ZipEntry::getName, ENTRYNAME_COMPARATOR);
<i>2274</i>&nbsp;
<i>2275</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
