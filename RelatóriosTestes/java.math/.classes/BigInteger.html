


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: BigInteger</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.math</a> ]
</div>

<h1>Coverage Summary for Class: BigInteger (java.math)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BigInteger</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 144)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1665)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BigInteger$UnsafeHolder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 148)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1676)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * Portions Copyright (c) 1995  Colin Plumb.  All rights reserved.
<i>28</i>&nbsp; */
<i>29</i>&nbsp;
<i>30</i>&nbsp;package java.math;
<i>31</i>&nbsp;
<i>32</i>&nbsp;import java.io.IOException;
<i>33</i>&nbsp;import java.io.ObjectInputStream;
<i>34</i>&nbsp;import java.io.ObjectOutputStream;
<i>35</i>&nbsp;import java.io.ObjectStreamField;
<i>36</i>&nbsp;import java.util.Arrays;
<i>37</i>&nbsp;import java.util.Objects;
<i>38</i>&nbsp;import java.util.Random;
<i>39</i>&nbsp;import java.util.concurrent.ThreadLocalRandom;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import jdk.internal.math.DoubleConsts;
<i>42</i>&nbsp;import jdk.internal.math.FloatConsts;
<i>43</i>&nbsp;import jdk.internal.HotSpotIntrinsicCandidate;
<i>44</i>&nbsp;
<i>45</i>&nbsp;/**
<i>46</i>&nbsp; * Immutable arbitrary-precision integers.  All operations behave as if
<i>47</i>&nbsp; * BigIntegers were represented in two&#39;s-complement notation (like Java&#39;s
<i>48</i>&nbsp; * primitive integer types).  BigInteger provides analogues to all of Java&#39;s
<i>49</i>&nbsp; * primitive integer operators, and all relevant methods from java.lang.Math.
<i>50</i>&nbsp; * Additionally, BigInteger provides operations for modular arithmetic, GCD
<i>51</i>&nbsp; * calculation, primality testing, prime generation, bit manipulation,
<i>52</i>&nbsp; * and a few other miscellaneous operations.
<i>53</i>&nbsp; *
<i>54</i>&nbsp; * &lt;p&gt;Semantics of arithmetic operations exactly mimic those of Java&#39;s integer
<i>55</i>&nbsp; * arithmetic operators, as defined in &lt;i&gt;The Java&amp;trade; Language Specification&lt;/i&gt;.
<i>56</i>&nbsp; * For example, division by zero throws an {@code ArithmeticException}, and
<i>57</i>&nbsp; * division of a negative by a positive yields a negative (or zero) remainder.
<i>58</i>&nbsp; *
<i>59</i>&nbsp; * &lt;p&gt;Semantics of shift operations extend those of Java&#39;s shift operators
<i>60</i>&nbsp; * to allow for negative shift distances.  A right-shift with a negative
<i>61</i>&nbsp; * shift distance results in a left shift, and vice-versa.  The unsigned
<i>62</i>&nbsp; * right shift operator ({@code &gt;&gt;&gt;}) is omitted since this operation
<i>63</i>&nbsp; * only makes sense for a fixed sized word and not for a
<i>64</i>&nbsp; * representation conceptually having an infinite number of leading
<i>65</i>&nbsp; * virtual sign bits.
<i>66</i>&nbsp; *
<i>67</i>&nbsp; * &lt;p&gt;Semantics of bitwise logical operations exactly mimic those of Java&#39;s
<i>68</i>&nbsp; * bitwise integer operators.  The binary operators ({@code and},
<i>69</i>&nbsp; * {@code or}, {@code xor}) implicitly perform sign extension on the shorter
<i>70</i>&nbsp; * of the two operands prior to performing the operation.
<i>71</i>&nbsp; *
<i>72</i>&nbsp; * &lt;p&gt;Comparison operations perform signed integer comparisons, analogous to
<i>73</i>&nbsp; * those performed by Java&#39;s relational and equality operators.
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * &lt;p&gt;Modular arithmetic operations are provided to compute residues, perform
<i>76</i>&nbsp; * exponentiation, and compute multiplicative inverses.  These methods always
<i>77</i>&nbsp; * return a non-negative result, between {@code 0} and {@code (modulus - 1)},
<i>78</i>&nbsp; * inclusive.
<i>79</i>&nbsp; *
<i>80</i>&nbsp; * &lt;p&gt;Bit operations operate on a single bit of the two&#39;s-complement
<i>81</i>&nbsp; * representation of their operand.  If necessary, the operand is sign-
<i>82</i>&nbsp; * extended so that it contains the designated bit.  None of the single-bit
<i>83</i>&nbsp; * operations can produce a BigInteger with a different sign from the
<i>84</i>&nbsp; * BigInteger being operated on, as they affect only a single bit, and the
<i>85</i>&nbsp; * arbitrarily large abstraction provided by this class ensures that conceptually
<i>86</i>&nbsp; * there are infinitely many &quot;virtual sign bits&quot; preceding each BigInteger.
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used throughout the
<i>89</i>&nbsp; * descriptions of BigInteger methods.  The pseudo-code expression
<i>90</i>&nbsp; * {@code (i + j)} is shorthand for &quot;a BigInteger whose value is
<i>91</i>&nbsp; * that of the BigInteger {@code i} plus that of the BigInteger {@code j}.&quot;
<i>92</i>&nbsp; * The pseudo-code expression {@code (i == j)} is shorthand for
<i>93</i>&nbsp; * &quot;{@code true} if and only if the BigInteger {@code i} represents the same
<i>94</i>&nbsp; * value as the BigInteger {@code j}.&quot;  Other pseudo-code expressions are
<i>95</i>&nbsp; * interpreted similarly.
<i>96</i>&nbsp; *
<i>97</i>&nbsp; * &lt;p&gt;All methods and constructors in this class throw
<i>98</i>&nbsp; * {@code NullPointerException} when passed
<i>99</i>&nbsp; * a null object reference for any input parameter.
<i>100</i>&nbsp; *
<i>101</i>&nbsp; * BigInteger must support values in the range
<i>102</i>&nbsp; * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
<i>103</i>&nbsp; * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive)
<i>104</i>&nbsp; * and may support values outside of that range.
<i>105</i>&nbsp; *
<i>106</i>&nbsp; * An {@code ArithmeticException} is thrown when a BigInteger
<i>107</i>&nbsp; * constructor or method would generate a value outside of the
<i>108</i>&nbsp; * supported range.
<i>109</i>&nbsp; *
<i>110</i>&nbsp; * The range of probable prime values is limited and may be less than
<i>111</i>&nbsp; * the full supported positive range of {@code BigInteger}.
<i>112</i>&nbsp; * The range must be at least 1 to 2&lt;sup&gt;500000000&lt;/sup&gt;.
<i>113</i>&nbsp; *
<i>114</i>&nbsp; * @implNote
<i>115</i>&nbsp; * In the reference implementation, BigInteger constructors and
<i>116</i>&nbsp; * operations throw {@code ArithmeticException} when the result is out
<i>117</i>&nbsp; * of the supported range of
<i>118</i>&nbsp; * -2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive) to
<i>119</i>&nbsp; * +2&lt;sup&gt;{@code Integer.MAX_VALUE}&lt;/sup&gt; (exclusive).
<i>120</i>&nbsp; *
<i>121</i>&nbsp; * @see     BigDecimal
<i>122</i>&nbsp; * @jls     4.2.2 Integer Operations
<b class="nc"><i>123</i>&nbsp; * @author  Josh Bloch</b>
<i>124</i>&nbsp; * @author  Michael McCloskey
<i>125</i>&nbsp; * @author  Alan Eliasen
<i>126</i>&nbsp; * @author  Timothy Buktu
<i>127</i>&nbsp; * @since 1.1
<i>128</i>&nbsp; */
<i>129</i>&nbsp;
<i>130</i>&nbsp;public class BigInteger extends Number implements Comparable&lt;BigInteger&gt; {
<i>131</i>&nbsp;    /**
<i>132</i>&nbsp;     * The signum of this BigInteger: -1 for negative, 0 for zero, or
<i>133</i>&nbsp;     * 1 for positive.  Note that the BigInteger zero &lt;em&gt;must&lt;/em&gt; have
<i>134</i>&nbsp;     * a signum of 0.  This is necessary to ensures that there is exactly one
<i>135</i>&nbsp;     * representation for each BigInteger value.
<i>136</i>&nbsp;     */
<i>137</i>&nbsp;    final int signum;
<i>138</i>&nbsp;
<i>139</i>&nbsp;    /**
<i>140</i>&nbsp;     * The magnitude of this BigInteger, in &lt;i&gt;big-endian&lt;/i&gt; order: the
<i>141</i>&nbsp;     * zeroth element of this array is the most-significant int of the
<i>142</i>&nbsp;     * magnitude.  The magnitude must be &quot;minimal&quot; in that the most-significant
<i>143</i>&nbsp;     * int ({@code mag[0]}) must be non-zero.  This is necessary to
<i>144</i>&nbsp;     * ensure that there is exactly one representation for each BigInteger
<i>145</i>&nbsp;     * value.  Note that this implies that the BigInteger zero has a
<i>146</i>&nbsp;     * zero-length mag array.
<i>147</i>&nbsp;     */
<i>148</i>&nbsp;    final int[] mag;
<i>149</i>&nbsp;
<i>150</i>&nbsp;    // The following fields are stable variables. A stable variable&#39;s value
<i>151</i>&nbsp;    // changes at most once from the default zero value to a non-zero stable
<i>152</i>&nbsp;    // value. A stable value is calculated lazily on demand.
<i>153</i>&nbsp;
<i>154</i>&nbsp;    /**
<i>155</i>&nbsp;     * One plus the bitCount of this BigInteger. This is a stable variable.
<i>156</i>&nbsp;     *
<i>157</i>&nbsp;     * @see #bitCount
<i>158</i>&nbsp;     */
<i>159</i>&nbsp;    private int bitCountPlusOne;
<i>160</i>&nbsp;
<i>161</i>&nbsp;    /**
<i>162</i>&nbsp;     * One plus the bitLength of this BigInteger. This is a stable variable.
<i>163</i>&nbsp;     * (either value is acceptable).
<i>164</i>&nbsp;     *
<i>165</i>&nbsp;     * @see #bitLength()
<i>166</i>&nbsp;     */
<i>167</i>&nbsp;    private int bitLengthPlusOne;
<i>168</i>&nbsp;
<i>169</i>&nbsp;    /**
<i>170</i>&nbsp;     * Two plus the lowest set bit of this BigInteger. This is a stable variable.
<i>171</i>&nbsp;     *
<i>172</i>&nbsp;     * @see #getLowestSetBit
<i>173</i>&nbsp;     */
<i>174</i>&nbsp;    private int lowestSetBitPlusTwo;
<i>175</i>&nbsp;
<i>176</i>&nbsp;    /**
<i>177</i>&nbsp;     * Two plus the index of the lowest-order int in the magnitude of this
<i>178</i>&nbsp;     * BigInteger that contains a nonzero int. This is a stable variable. The
<i>179</i>&nbsp;     * least significant int has int-number 0, the next int in order of
<i>180</i>&nbsp;     * increasing significance has int-number 1, and so forth.
<i>181</i>&nbsp;     *
<i>182</i>&nbsp;     * &lt;p&gt;Note: never used for a BigInteger with a magnitude of zero.
<i>183</i>&nbsp;     *
<i>184</i>&nbsp;     * @see #firstNonzeroIntNum()
<i>185</i>&nbsp;     */
<i>186</i>&nbsp;    private int firstNonzeroIntNumPlusTwo;
<i>187</i>&nbsp;
<i>188</i>&nbsp;    /**
<i>189</i>&nbsp;     * This mask is used to obtain the value of an int as if it were unsigned.
<i>190</i>&nbsp;     */
<i>191</i>&nbsp;    static final long LONG_MASK = 0xffffffffL;
<i>192</i>&nbsp;
<i>193</i>&nbsp;    /**
<i>194</i>&nbsp;     * This constant limits {@code mag.length} of BigIntegers to the supported
<i>195</i>&nbsp;     * range.
<i>196</i>&nbsp;     */
<i>197</i>&nbsp;    private static final int MAX_MAG_LENGTH = Integer.MAX_VALUE / Integer.SIZE + 1; // (1 &lt;&lt; 26)
<i>198</i>&nbsp;
<i>199</i>&nbsp;    /**
<i>200</i>&nbsp;     * Bit lengths larger than this constant can cause overflow in searchLen
<i>201</i>&nbsp;     * calculation and in BitSieve.singleSearch method.
<i>202</i>&nbsp;     */
<i>203</i>&nbsp;    private static final  int PRIME_SEARCH_BIT_LENGTH_LIMIT = 500000000;
<i>204</i>&nbsp;
<i>205</i>&nbsp;    /**
<i>206</i>&nbsp;     * The threshold value for using Karatsuba multiplication.  If the number
<i>207</i>&nbsp;     * of ints in both mag arrays are greater than this number, then
<i>208</i>&nbsp;     * Karatsuba multiplication will be used.   This value is found
<i>209</i>&nbsp;     * experimentally to work well.
<i>210</i>&nbsp;     */
<i>211</i>&nbsp;    private static final int KARATSUBA_THRESHOLD = 80;
<i>212</i>&nbsp;
<i>213</i>&nbsp;    /**
<i>214</i>&nbsp;     * The threshold value for using 3-way Toom-Cook multiplication.
<i>215</i>&nbsp;     * If the number of ints in each mag array is greater than the
<i>216</i>&nbsp;     * Karatsuba threshold, and the number of ints in at least one of
<i>217</i>&nbsp;     * the mag arrays is greater than this threshold, then Toom-Cook
<i>218</i>&nbsp;     * multiplication will be used.
<i>219</i>&nbsp;     */
<i>220</i>&nbsp;    private static final int TOOM_COOK_THRESHOLD = 240;
<i>221</i>&nbsp;
<i>222</i>&nbsp;    /**
<i>223</i>&nbsp;     * The threshold value for using Karatsuba squaring.  If the number
<i>224</i>&nbsp;     * of ints in the number are larger than this value,
<i>225</i>&nbsp;     * Karatsuba squaring will be used.   This value is found
<i>226</i>&nbsp;     * experimentally to work well.
<i>227</i>&nbsp;     */
<i>228</i>&nbsp;    private static final int KARATSUBA_SQUARE_THRESHOLD = 128;
<i>229</i>&nbsp;
<i>230</i>&nbsp;    /**
<i>231</i>&nbsp;     * The threshold value for using Toom-Cook squaring.  If the number
<i>232</i>&nbsp;     * of ints in the number are larger than this value,
<i>233</i>&nbsp;     * Toom-Cook squaring will be used.   This value is found
<i>234</i>&nbsp;     * experimentally to work well.
<i>235</i>&nbsp;     */
<i>236</i>&nbsp;    private static final int TOOM_COOK_SQUARE_THRESHOLD = 216;
<i>237</i>&nbsp;
<i>238</i>&nbsp;    /**
<i>239</i>&nbsp;     * The threshold value for using Burnikel-Ziegler division.  If the number
<i>240</i>&nbsp;     * of ints in the divisor are larger than this value, Burnikel-Ziegler
<i>241</i>&nbsp;     * division may be used.  This value is found experimentally to work well.
<i>242</i>&nbsp;     */
<i>243</i>&nbsp;    static final int BURNIKEL_ZIEGLER_THRESHOLD = 80;
<i>244</i>&nbsp;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * The offset value for using Burnikel-Ziegler division.  If the number
<i>247</i>&nbsp;     * of ints in the divisor exceeds the Burnikel-Ziegler threshold, and the
<i>248</i>&nbsp;     * number of ints in the dividend is greater than the number of ints in the
<i>249</i>&nbsp;     * divisor plus this value, Burnikel-Ziegler division will be used.  This
<i>250</i>&nbsp;     * value is found experimentally to work well.
<i>251</i>&nbsp;     */
<i>252</i>&nbsp;    static final int BURNIKEL_ZIEGLER_OFFSET = 40;
<i>253</i>&nbsp;
<i>254</i>&nbsp;    /**
<i>255</i>&nbsp;     * The threshold value for using Schoenhage recursive base conversion. If
<i>256</i>&nbsp;     * the number of ints in the number are larger than this value,
<i>257</i>&nbsp;     * the Schoenhage algorithm will be used.  In practice, it appears that the
<i>258</i>&nbsp;     * Schoenhage routine is faster for any threshold down to 2, and is
<i>259</i>&nbsp;     * relatively flat for thresholds between 2-25, so this choice may be
<i>260</i>&nbsp;     * varied within this range for very small effect.
<i>261</i>&nbsp;     */
<i>262</i>&nbsp;    private static final int SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20;
<i>263</i>&nbsp;
<i>264</i>&nbsp;    /**
<i>265</i>&nbsp;     * The threshold value for using squaring code to perform multiplication
<i>266</i>&nbsp;     * of a {@code BigInteger} instance by itself.  If the number of ints in
<i>267</i>&nbsp;     * the number are larger than this value, {@code multiply(this)} will
<i>268</i>&nbsp;     * return {@code square()}.
<i>269</i>&nbsp;     */
<i>270</i>&nbsp;    private static final int MULTIPLY_SQUARE_THRESHOLD = 20;
<i>271</i>&nbsp;
<i>272</i>&nbsp;    /**
<i>273</i>&nbsp;     * The threshold for using an intrinsic version of
<i>274</i>&nbsp;     * implMontgomeryXXX to perform Montgomery multiplication.  If the
<i>275</i>&nbsp;     * number of ints in the number is more than this value we do not
<i>276</i>&nbsp;     * use the intrinsic.
<i>277</i>&nbsp;     */
<i>278</i>&nbsp;    private static final int MONTGOMERY_INTRINSIC_THRESHOLD = 512;
<i>279</i>&nbsp;
<i>280</i>&nbsp;
<i>281</i>&nbsp;    // Constructors
<i>282</i>&nbsp;
<i>283</i>&nbsp;    /**
<i>284</i>&nbsp;     * Translates a byte sub-array containing the two&#39;s-complement binary
<i>285</i>&nbsp;     * representation of a BigInteger into a BigInteger.  The sub-array is
<i>286</i>&nbsp;     * specified via an offset into the array and a length.  The sub-array is
<i>287</i>&nbsp;     * assumed to be in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant
<i>288</i>&nbsp;     * byte is the element at index {@code off}.  The {@code val} array is
<i>289</i>&nbsp;     * assumed to be unchanged for the duration of the constructor call.
<i>290</i>&nbsp;     *
<i>291</i>&nbsp;     * An {@code IndexOutOfBoundsException} is thrown if the length of the array
<i>292</i>&nbsp;     * {@code val} is non-zero and either {@code off} is negative, {@code len}
<i>293</i>&nbsp;     * is negative, or {@code off+len} is greater than the length of
<i>294</i>&nbsp;     * {@code val}.
<i>295</i>&nbsp;     *
<i>296</i>&nbsp;     * @param  val byte array containing a sub-array which is the big-endian
<i>297</i>&nbsp;     *         two&#39;s-complement binary representation of a BigInteger.
<i>298</i>&nbsp;     * @param  off the start offset of the binary representation.
<i>299</i>&nbsp;     * @param  len the number of bytes to use.
<b class="nc"><i>300</i>&nbsp;     * @throws NumberFormatException {@code val} is zero bytes long.</b>
<b class="nc"><i>301</i>&nbsp;     * @throws IndexOutOfBoundsException if the provided array offset and</b>
<b class="nc"><i>302</i>&nbsp;     *         length would cause an index into the byte array to be</b>
<i>303</i>&nbsp;     *         negative or greater than or equal to the array length.
<b class="nc"><i>304</i>&nbsp;     * @since 9</b>
<b class="nc"><i>305</i>&nbsp;     */</b>
<b class="nc"><i>306</i>&nbsp;    public BigInteger(byte[] val, int off, int len) {</b>
<i>307</i>&nbsp;        if (val.length == 0) {
<b class="nc"><i>308</i>&nbsp;            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</b>
<b class="nc"><i>309</i>&nbsp;        } else if ((off &lt; 0) || (off &gt;= val.length) || (len &lt; 0) ||</b>
<i>310</i>&nbsp;                   (len &gt; val.length - off)) { // 0 &lt;= off &lt; val.length
<b class="nc"><i>311</i>&nbsp;            throw new IndexOutOfBoundsException();</b>
<b class="nc"><i>312</i>&nbsp;        }</b>
<i>313</i>&nbsp;
<i>314</i>&nbsp;        if (val[off] &lt; 0) {
<i>315</i>&nbsp;            mag = makePositive(val, off, len);
<i>316</i>&nbsp;            signum = -1;
<i>317</i>&nbsp;        } else {
<i>318</i>&nbsp;            mag = stripLeadingZeroBytes(val, off, len);
<i>319</i>&nbsp;            signum = (mag.length == 0 ? 0 : 1);
<i>320</i>&nbsp;        }
<i>321</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<b class="nc"><i>322</i>&nbsp;            checkRange();</b>
<b class="nc"><i>323</i>&nbsp;        }</b>
<b class="nc"><i>324</i>&nbsp;    }</b>
<i>325</i>&nbsp;
<b class="nc"><i>326</i>&nbsp;    /**</b>
<b class="nc"><i>327</i>&nbsp;     * Translates a byte array containing the two&#39;s-complement binary</b>
<b class="nc"><i>328</i>&nbsp;     * representation of a BigInteger into a BigInteger.  The input array is</b>
<i>329</i>&nbsp;     * assumed to be in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant
<b class="nc"><i>330</i>&nbsp;     * byte is in the zeroth element.  The {@code val} array is assumed to be</b>
<b class="nc"><i>331</i>&nbsp;     * unchanged for the duration of the constructor call.</b>
<i>332</i>&nbsp;     *
<b class="nc"><i>333</i>&nbsp;     * @param  val big-endian two&#39;s-complement binary representation of a</b>
<b class="nc"><i>334</i>&nbsp;     *         BigInteger.</b>
<i>335</i>&nbsp;     * @throws NumberFormatException {@code val} is zero bytes long.
<i>336</i>&nbsp;     */
<i>337</i>&nbsp;    public BigInteger(byte[] val) {
<i>338</i>&nbsp;        this(val, 0, val.length);
<i>339</i>&nbsp;    }
<i>340</i>&nbsp;
<i>341</i>&nbsp;    /**
<i>342</i>&nbsp;     * This private constructor translates an int array containing the
<i>343</i>&nbsp;     * two&#39;s-complement binary representation of a BigInteger into a
<i>344</i>&nbsp;     * BigInteger. The input array is assumed to be in &lt;i&gt;big-endian&lt;/i&gt;
<i>345</i>&nbsp;     * int-order: the most significant int is in the zeroth element.  The
<i>346</i>&nbsp;     * {@code val} array is assumed to be unchanged for the duration of
<i>347</i>&nbsp;     * the constructor call.
<i>348</i>&nbsp;     */
<i>349</i>&nbsp;    private BigInteger(int[] val) {
<i>350</i>&nbsp;        if (val.length == 0)
<i>351</i>&nbsp;            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
<i>352</i>&nbsp;
<i>353</i>&nbsp;        if (val[0] &lt; 0) {
<b class="nc"><i>354</i>&nbsp;            mag = makePositive(val);</b>
<b class="nc"><i>355</i>&nbsp;            signum = -1;</b>
<i>356</i>&nbsp;        } else {
<b class="nc"><i>357</i>&nbsp;            mag = trustedStripLeadingZeroInts(val);</b>
<b class="nc"><i>358</i>&nbsp;            signum = (mag.length == 0 ? 0 : 1);</b>
<i>359</i>&nbsp;        }
<b class="nc"><i>360</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {</b>
<b class="nc"><i>361</i>&nbsp;            checkRange();</b>
<i>362</i>&nbsp;        }
<b class="nc"><i>363</i>&nbsp;    }</b>
<b class="nc"><i>364</i>&nbsp;</b>
<b class="nc"><i>365</i>&nbsp;    /**</b>
<i>366</i>&nbsp;     * Translates the sign-magnitude representation of a BigInteger into a
<b class="nc"><i>367</i>&nbsp;     * BigInteger.  The sign is represented as an integer signum value: -1 for</b>
<b class="nc"><i>368</i>&nbsp;     * negative, 0 for zero, or 1 for positive.  The magnitude is a sub-array of</b>
<i>369</i>&nbsp;     * a byte array in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte
<i>370</i>&nbsp;     * is the element at index {@code off}.  A zero value of the length
<i>371</i>&nbsp;     * {@code len} is permissible, and will result in a BigInteger value of 0,
<i>372</i>&nbsp;     * whether signum is -1, 0 or 1.  The {@code magnitude} array is assumed to
<i>373</i>&nbsp;     * be unchanged for the duration of the constructor call.
<i>374</i>&nbsp;     *
<i>375</i>&nbsp;     * An {@code IndexOutOfBoundsException} is thrown if the length of the array
<i>376</i>&nbsp;     * {@code magnitude} is non-zero and either {@code off} is negative,
<i>377</i>&nbsp;     * {@code len} is negative, or {@code off+len} is greater than the length of
<b class="nc"><i>378</i>&nbsp;     * {@code magnitude}.</b>
<b class="nc"><i>379</i>&nbsp;     *</b>
<i>380</i>&nbsp;     * @param  signum signum of the number (-1 for negative, 0 for zero, 1
<b class="nc"><i>381</i>&nbsp;     *         for positive).</b>
<b class="nc"><i>382</i>&nbsp;     * @param  magnitude big-endian binary representation of the magnitude of</b>
<i>383</i>&nbsp;     *         the number.
<b class="nc"><i>384</i>&nbsp;     * @param  off the start offset of the binary representation.</b>
<b class="nc"><i>385</i>&nbsp;     * @param  len the number of bytes to use.</b>
<i>386</i>&nbsp;     * @throws NumberFormatException {@code signum} is not one of the three
<b class="nc"><i>387</i>&nbsp;     *         legal values (-1, 0, and 1), or {@code signum} is 0 and</b>
<b class="nc"><i>388</i>&nbsp;     *         {@code magnitude} contains one or more non-zero bytes.</b>
<b class="nc"><i>389</i>&nbsp;     * @throws IndexOutOfBoundsException if the provided array offset and</b>
<i>390</i>&nbsp;     *         length would cause an index into the byte array to be
<b class="nc"><i>391</i>&nbsp;     *         negative or greater than or equal to the array length.</b>
<b class="nc"><i>392</i>&nbsp;     * @since 9</b>
<i>393</i>&nbsp;     */
<i>394</i>&nbsp;    public BigInteger(int signum, byte[] magnitude, int off, int len) {
<i>395</i>&nbsp;        if (signum &lt; -1 || signum &gt; 1) {
<i>396</i>&nbsp;            throw(new NumberFormatException(&quot;Invalid signum value&quot;));
<i>397</i>&nbsp;        } else if ((off &lt; 0) || (len &lt; 0) ||
<i>398</i>&nbsp;            (len &gt; 0 &amp;&amp;
<i>399</i>&nbsp;                ((off &gt;= magnitude.length) ||
<i>400</i>&nbsp;                 (len &gt; magnitude.length - off)))) { // 0 &lt;= off &lt; magnitude.length
<i>401</i>&nbsp;            throw new IndexOutOfBoundsException();
<i>402</i>&nbsp;        }
<i>403</i>&nbsp;
<i>404</i>&nbsp;        // stripLeadingZeroBytes() returns a zero length array if len == 0
<i>405</i>&nbsp;        this.mag = stripLeadingZeroBytes(magnitude, off, len);
<i>406</i>&nbsp;
<i>407</i>&nbsp;        if (this.mag.length == 0) {
<i>408</i>&nbsp;            this.signum = 0;
<i>409</i>&nbsp;        } else {
<i>410</i>&nbsp;            if (signum == 0)
<i>411</i>&nbsp;                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));
<i>412</i>&nbsp;            this.signum = signum;
<b class="nc"><i>413</i>&nbsp;        }</b>
<b class="nc"><i>414</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {</b>
<b class="nc"><i>415</i>&nbsp;            checkRange();</b>
<i>416</i>&nbsp;        }
<b class="nc"><i>417</i>&nbsp;    }</b>
<b class="nc"><i>418</i>&nbsp;</b>
<b class="nc"><i>419</i>&nbsp;    /**</b>
<b class="nc"><i>420</i>&nbsp;     * Translates the sign-magnitude representation of a BigInteger into a</b>
<i>421</i>&nbsp;     * BigInteger.  The sign is represented as an integer signum value: -1 for
<i>422</i>&nbsp;     * negative, 0 for zero, or 1 for positive.  The magnitude is a byte array
<b class="nc"><i>423</i>&nbsp;     * in &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is the</b>
<b class="nc"><i>424</i>&nbsp;     * zeroth element.  A zero-length magnitude array is permissible, and will</b>
<b class="nc"><i>425</i>&nbsp;     * result in a BigInteger value of 0, whether signum is -1, 0 or 1.  The</b>
<b class="nc"><i>426</i>&nbsp;     * {@code magnitude} array is assumed to be unchanged for the duration of</b>
<b class="nc"><i>427</i>&nbsp;     * the constructor call.</b>
<b class="nc"><i>428</i>&nbsp;     *</b>
<i>429</i>&nbsp;     * @param  signum signum of the number (-1 for negative, 0 for zero, 1
<b class="nc"><i>430</i>&nbsp;     *         for positive).</b>
<b class="nc"><i>431</i>&nbsp;     * @param  magnitude big-endian binary representation of the magnitude of</b>
<b class="nc"><i>432</i>&nbsp;     *         the number.</b>
<b class="nc"><i>433</i>&nbsp;     * @throws NumberFormatException {@code signum} is not one of the three</b>
<b class="nc"><i>434</i>&nbsp;     *         legal values (-1, 0, and 1), or {@code signum} is 0 and</b>
<i>435</i>&nbsp;     *         {@code magnitude} contains one or more non-zero bytes.
<b class="nc"><i>436</i>&nbsp;     */</b>
<i>437</i>&nbsp;    public BigInteger(int signum, byte[] magnitude) {
<b class="nc"><i>438</i>&nbsp;         this(signum, magnitude, 0, magnitude.length);</b>
<b class="nc"><i>439</i>&nbsp;    }</b>
<i>440</i>&nbsp;
<i>441</i>&nbsp;    /**
<b class="nc"><i>442</i>&nbsp;     * A constructor for internal use that translates the sign-magnitude</b>
<b class="nc"><i>443</i>&nbsp;     * representation of a BigInteger into a BigInteger. It checks the</b>
<b class="nc"><i>444</i>&nbsp;     * arguments and copies the magnitude so this constructor would be</b>
<i>445</i>&nbsp;     * safe for external use.  The {@code magnitude} array is assumed to be
<i>446</i>&nbsp;     * unchanged for the duration of the constructor call.
<b class="nc"><i>447</i>&nbsp;     */</b>
<b class="nc"><i>448</i>&nbsp;    private BigInteger(int signum, int[] magnitude) {</b>
<b class="nc"><i>449</i>&nbsp;        this.mag = stripLeadingZeroInts(magnitude);</b>
<i>450</i>&nbsp;
<i>451</i>&nbsp;        if (signum &lt; -1 || signum &gt; 1)
<i>452</i>&nbsp;            throw(new NumberFormatException(&quot;Invalid signum value&quot;));
<b class="nc"><i>453</i>&nbsp;</b>
<b class="nc"><i>454</i>&nbsp;        if (this.mag.length == 0) {</b>
<i>455</i>&nbsp;            this.signum = 0;
<i>456</i>&nbsp;        } else {
<i>457</i>&nbsp;            if (signum == 0)
<b class="nc"><i>458</i>&nbsp;                throw(new NumberFormatException(&quot;signum-magnitude mismatch&quot;));</b>
<b class="nc"><i>459</i>&nbsp;            this.signum = signum;</b>
<b class="nc"><i>460</i>&nbsp;        }</b>
<i>461</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<b class="nc"><i>462</i>&nbsp;            checkRange();</b>
<b class="nc"><i>463</i>&nbsp;        }</b>
<i>464</i>&nbsp;    }
<i>465</i>&nbsp;
<b class="nc"><i>466</i>&nbsp;    /**</b>
<b class="nc"><i>467</i>&nbsp;     * Translates the String representation of a BigInteger in the</b>
<b class="nc"><i>468</i>&nbsp;     * specified radix into a BigInteger.  The String representation</b>
<b class="nc"><i>469</i>&nbsp;     * consists of an optional minus or plus sign followed by a</b>
<b class="nc"><i>470</i>&nbsp;     * sequence of one or more digits in the specified radix.  The</b>
<b class="nc"><i>471</i>&nbsp;     * character-to-digit mapping is provided by {@code</b>
<b class="nc"><i>472</i>&nbsp;     * Character.digit}.  The String may not contain any extraneous</b>
<i>473</i>&nbsp;     * characters (whitespace, for example).
<i>474</i>&nbsp;     *
<b class="nc"><i>475</i>&nbsp;     * @param val String representation of BigInteger.</b>
<b class="nc"><i>476</i>&nbsp;     * @param radix radix to be used in interpreting {@code val}.</b>
<b class="nc"><i>477</i>&nbsp;     * @throws NumberFormatException {@code val} is not a valid representation</b>
<b class="nc"><i>478</i>&nbsp;     *         of a BigInteger in the specified radix, or {@code radix} is</b>
<b class="nc"><i>479</i>&nbsp;     *         outside the range from {@link Character#MIN_RADIX} to</b>
<b class="nc"><i>480</i>&nbsp;     *         {@link Character#MAX_RADIX}, inclusive.</b>
<b class="nc"><i>481</i>&nbsp;     * @see    Character#digit</b>
<b class="nc"><i>482</i>&nbsp;     */</b>
<i>483</i>&nbsp;    public BigInteger(String val, int radix) {
<i>484</i>&nbsp;        int cursor = 0, numDigits;
<b class="nc"><i>485</i>&nbsp;        final int len = val.length();</b>
<b class="nc"><i>486</i>&nbsp;</b>
<b class="nc"><i>487</i>&nbsp;        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</b>
<i>488</i>&nbsp;            throw new NumberFormatException(&quot;Radix out of range&quot;);
<i>489</i>&nbsp;        if (len == 0)
<i>490</i>&nbsp;            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);
<i>491</i>&nbsp;
<i>492</i>&nbsp;        // Check for at most one leading sign
<i>493</i>&nbsp;        int sign = 1;
<i>494</i>&nbsp;        int index1 = val.lastIndexOf(&#39;-&#39;);
<b class="nc"><i>495</i>&nbsp;        int index2 = val.lastIndexOf(&#39;+&#39;);</b>
<b class="nc"><i>496</i>&nbsp;        if (index1 &gt;= 0) {</b>
<i>497</i>&nbsp;            if (index1 != 0 || index2 &gt;= 0) {
<i>498</i>&nbsp;                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);
<b class="nc"><i>499</i>&nbsp;            }</b>
<b class="nc"><i>500</i>&nbsp;            sign = -1;</b>
<i>501</i>&nbsp;            cursor = 1;
<b class="nc"><i>502</i>&nbsp;        } else if (index2 &gt;= 0) {</b>
<b class="nc"><i>503</i>&nbsp;            if (index2 != 0) {</b>
<b class="nc"><i>504</i>&nbsp;                throw new NumberFormatException(&quot;Illegal embedded sign character&quot;);</b>
<i>505</i>&nbsp;            }
<i>506</i>&nbsp;            cursor = 1;
<i>507</i>&nbsp;        }
<b class="nc"><i>508</i>&nbsp;        if (cursor == len)</b>
<b class="nc"><i>509</i>&nbsp;            throw new NumberFormatException(&quot;Zero length BigInteger&quot;);</b>
<i>510</i>&nbsp;
<i>511</i>&nbsp;        // Skip leading zeros and compute number of digits in magnitude
<b class="nc"><i>512</i>&nbsp;        while (cursor &lt; len &amp;&amp;</b>
<b class="nc"><i>513</i>&nbsp;               Character.digit(val.charAt(cursor), radix) == 0) {</b>
<i>514</i>&nbsp;            cursor++;
<b class="nc"><i>515</i>&nbsp;        }</b>
<b class="nc"><i>516</i>&nbsp;</b>
<b class="nc"><i>517</i>&nbsp;        if (cursor == len) {</b>
<i>518</i>&nbsp;            signum = 0;
<b class="nc"><i>519</i>&nbsp;            mag = ZERO.mag;</b>
<i>520</i>&nbsp;            return;
<b class="nc"><i>521</i>&nbsp;        }</b>
<i>522</i>&nbsp;
<i>523</i>&nbsp;        numDigits = len - cursor;
<b class="nc"><i>524</i>&nbsp;        signum = sign;</b>
<b class="nc"><i>525</i>&nbsp;</b>
<b class="nc"><i>526</i>&nbsp;        // Pre-allocate array of expected size. May be too large but can</b>
<b class="nc"><i>527</i>&nbsp;        // never be too small. Typically exact.</b>
<i>528</i>&nbsp;        long numBits = ((numDigits * bitsPerDigit[radix]) &gt;&gt;&gt; 10) + 1;
<i>529</i>&nbsp;        if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {
<b class="nc"><i>530</i>&nbsp;            reportOverflow();</b>
<b class="nc"><i>531</i>&nbsp;        }</b>
<b class="nc"><i>532</i>&nbsp;        int numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;</b>
<b class="nc"><i>533</i>&nbsp;        int[] magnitude = new int[numWords];</b>
<b class="nc"><i>534</i>&nbsp;</b>
<b class="nc"><i>535</i>&nbsp;        // Process first (potentially short) digit group</b>
<b class="nc"><i>536</i>&nbsp;        int firstGroupLen = numDigits % digitsPerInt[radix];</b>
<i>537</i>&nbsp;        if (firstGroupLen == 0)
<i>538</i>&nbsp;            firstGroupLen = digitsPerInt[radix];
<i>539</i>&nbsp;        String group = val.substring(cursor, cursor += firstGroupLen);
<i>540</i>&nbsp;        magnitude[numWords - 1] = Integer.parseInt(group, radix);
<i>541</i>&nbsp;        if (magnitude[numWords - 1] &lt; 0)
<i>542</i>&nbsp;            throw new NumberFormatException(&quot;Illegal digit&quot;);
<i>543</i>&nbsp;
<b class="nc"><i>544</i>&nbsp;        // Process remaining digit groups</b>
<b class="nc"><i>545</i>&nbsp;        int superRadix = intRadix[radix];</b>
<b class="nc"><i>546</i>&nbsp;        int groupVal = 0;</b>
<i>547</i>&nbsp;        while (cursor &lt; len) {
<b class="nc"><i>548</i>&nbsp;            group = val.substring(cursor, cursor += digitsPerInt[radix]);</b>
<b class="nc"><i>549</i>&nbsp;            groupVal = Integer.parseInt(group, radix);</b>
<b class="nc"><i>550</i>&nbsp;            if (groupVal &lt; 0)</b>
<b class="nc"><i>551</i>&nbsp;                throw new NumberFormatException(&quot;Illegal digit&quot;);</b>
<b class="nc"><i>552</i>&nbsp;            destructiveMulAdd(magnitude, superRadix, groupVal);</b>
<i>553</i>&nbsp;        }
<i>554</i>&nbsp;        // Required for cases where the array was overallocated.
<b class="nc"><i>555</i>&nbsp;        mag = trustedStripLeadingZeroInts(magnitude);</b>
<i>556</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<i>557</i>&nbsp;            checkRange();
<i>558</i>&nbsp;        }
<i>559</i>&nbsp;    }
<b class="nc"><i>560</i>&nbsp;</b>
<i>561</i>&nbsp;    /*
<i>562</i>&nbsp;     * Constructs a new BigInteger using a char array with radix=10.
<i>563</i>&nbsp;     * Sign is precalculated outside and not allowed in the val. The {@code val}
<i>564</i>&nbsp;     * array is assumed to be unchanged for the duration of the constructor
<i>565</i>&nbsp;     * call.
<i>566</i>&nbsp;     */
<i>567</i>&nbsp;    BigInteger(char[] val, int sign, int len) {
<i>568</i>&nbsp;        int cursor = 0, numDigits;
<b class="nc"><i>569</i>&nbsp;</b>
<b class="nc"><i>570</i>&nbsp;        // Skip leading zeros and compute number of digits in magnitude</b>
<b class="nc"><i>571</i>&nbsp;        while (cursor &lt; len &amp;&amp; Character.digit(val[cursor], 10) == 0) {</b>
<i>572</i>&nbsp;            cursor++;
<b class="nc"><i>573</i>&nbsp;        }</b>
<b class="nc"><i>574</i>&nbsp;        if (cursor == len) {</b>
<b class="nc"><i>575</i>&nbsp;            signum = 0;</b>
<b class="nc"><i>576</i>&nbsp;            mag = ZERO.mag;</b>
<b class="nc"><i>577</i>&nbsp;            return;</b>
<b class="nc"><i>578</i>&nbsp;        }</b>
<i>579</i>&nbsp;
<i>580</i>&nbsp;        numDigits = len - cursor;
<i>581</i>&nbsp;        signum = sign;
<b class="nc"><i>582</i>&nbsp;        // Pre-allocate array of expected size</b>
<b class="nc"><i>583</i>&nbsp;        int numWords;</b>
<b class="nc"><i>584</i>&nbsp;        if (len &lt; 10) {</b>
<b class="nc"><i>585</i>&nbsp;            numWords = 1;</b>
<b class="nc"><i>586</i>&nbsp;        } else {</b>
<b class="nc"><i>587</i>&nbsp;            long numBits = ((numDigits * bitsPerDigit[10]) &gt;&gt;&gt; 10) + 1;</b>
<b class="nc"><i>588</i>&nbsp;            if (numBits + 31 &gt;= (1L &lt;&lt; 32)) {</b>
<i>589</i>&nbsp;                reportOverflow();
<i>590</i>&nbsp;            }
<i>591</i>&nbsp;            numWords = (int) (numBits + 31) &gt;&gt;&gt; 5;
<i>592</i>&nbsp;        }
<i>593</i>&nbsp;        int[] magnitude = new int[numWords];
<i>594</i>&nbsp;
<i>595</i>&nbsp;        // Process first (potentially short) digit group
<i>596</i>&nbsp;        int firstGroupLen = numDigits % digitsPerInt[10];
<i>597</i>&nbsp;        if (firstGroupLen == 0)
<i>598</i>&nbsp;            firstGroupLen = digitsPerInt[10];
<i>599</i>&nbsp;        magnitude[numWords - 1] = parseInt(val, cursor,  cursor += firstGroupLen);
<i>600</i>&nbsp;
<i>601</i>&nbsp;        // Process remaining digit groups
<i>602</i>&nbsp;        while (cursor &lt; len) {
<i>603</i>&nbsp;            int groupVal = parseInt(val, cursor, cursor += digitsPerInt[10]);
<i>604</i>&nbsp;            destructiveMulAdd(magnitude, intRadix[10], groupVal);
<i>605</i>&nbsp;        }
<b class="nc"><i>606</i>&nbsp;        mag = trustedStripLeadingZeroInts(magnitude);</b>
<i>607</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<i>608</i>&nbsp;            checkRange();
<i>609</i>&nbsp;        }
<i>610</i>&nbsp;    }
<i>611</i>&nbsp;
<i>612</i>&nbsp;    // Create an integer with the digits between the two indexes
<i>613</i>&nbsp;    // Assumes start &lt; end. The result may be negative, but it
<i>614</i>&nbsp;    // is to be treated as an unsigned value.
<i>615</i>&nbsp;    private int parseInt(char[] source, int start, int end) {
<i>616</i>&nbsp;        int result = Character.digit(source[start++], 10);
<i>617</i>&nbsp;        if (result == -1)
<i>618</i>&nbsp;            throw new NumberFormatException(new String(source));
<i>619</i>&nbsp;
<i>620</i>&nbsp;        for (int index = start; index &lt; end; index++) {
<i>621</i>&nbsp;            int nextVal = Character.digit(source[index], 10);
<i>622</i>&nbsp;            if (nextVal == -1)
<b class="nc"><i>623</i>&nbsp;                throw new NumberFormatException(new String(source));</b>
<i>624</i>&nbsp;            result = 10*result + nextVal;
<i>625</i>&nbsp;        }
<i>626</i>&nbsp;
<b class="nc"><i>627</i>&nbsp;        return result;</b>
<b class="nc"><i>628</i>&nbsp;    }</b>
<b class="nc"><i>629</i>&nbsp;</b>
<b class="nc"><i>630</i>&nbsp;    // bitsPerDigit in the given radix times 1024</b>
<i>631</i>&nbsp;    // Rounded up to avoid underallocation.
<i>632</i>&nbsp;    private static long bitsPerDigit[] = { 0, 0,
<b class="nc"><i>633</i>&nbsp;        1024, 1624, 2048, 2378, 2648, 2875, 3072, 3247, 3402, 3543, 3672,</b>
<b class="nc"><i>634</i>&nbsp;        3790, 3899, 4001, 4096, 4186, 4271, 4350, 4426, 4498, 4567, 4633,</b>
<b class="nc"><i>635</i>&nbsp;        4696, 4756, 4814, 4870, 4923, 4975, 5025, 5074, 5120, 5166, 5210,</b>
<b class="nc"><i>636</i>&nbsp;                                           5253, 5295};</b>
<i>637</i>&nbsp;
<b class="nc"><i>638</i>&nbsp;    // Multiply x array times word y in place, and add word z</b>
<i>639</i>&nbsp;    private static void destructiveMulAdd(int[] x, int y, int z) {
<i>640</i>&nbsp;        // Perform the multiplication word by word
<i>641</i>&nbsp;        long ylong = y &amp; LONG_MASK;
<i>642</i>&nbsp;        long zlong = z &amp; LONG_MASK;
<i>643</i>&nbsp;        int len = x.length;
<i>644</i>&nbsp;
<i>645</i>&nbsp;        long product = 0;
<i>646</i>&nbsp;        long carry = 0;
<i>647</i>&nbsp;        for (int i = len-1; i &gt;= 0; i--) {
<i>648</i>&nbsp;            product = ylong * (x[i] &amp; LONG_MASK) + carry;
<i>649</i>&nbsp;            x[i] = (int)product;
<i>650</i>&nbsp;            carry = product &gt;&gt;&gt; 32;
<i>651</i>&nbsp;        }
<i>652</i>&nbsp;
<i>653</i>&nbsp;        // Perform the addition
<i>654</i>&nbsp;        long sum = (x[len-1] &amp; LONG_MASK) + zlong;
<i>655</i>&nbsp;        x[len-1] = (int)sum;
<i>656</i>&nbsp;        carry = sum &gt;&gt;&gt; 32;
<i>657</i>&nbsp;        for (int i = len-2; i &gt;= 0; i--) {
<i>658</i>&nbsp;            sum = (x[i] &amp; LONG_MASK) + carry;
<i>659</i>&nbsp;            x[i] = (int)sum;
<b class="nc"><i>660</i>&nbsp;            carry = sum &gt;&gt;&gt; 32;</b>
<i>661</i>&nbsp;        }
<i>662</i>&nbsp;    }
<b class="nc"><i>663</i>&nbsp;</b>
<b class="nc"><i>664</i>&nbsp;    /**</b>
<b class="nc"><i>665</i>&nbsp;     * Translates the decimal String representation of a BigInteger into a</b>
<b class="nc"><i>666</i>&nbsp;     * BigInteger.  The String representation consists of an optional minus</b>
<b class="nc"><i>667</i>&nbsp;     * sign followed by a sequence of one or more decimal digits.  The</b>
<b class="nc"><i>668</i>&nbsp;     * character-to-digit mapping is provided by {@code Character.digit}.</b>
<b class="nc"><i>669</i>&nbsp;     * The String may not contain any extraneous characters (whitespace, for</b>
<i>670</i>&nbsp;     * example).
<i>671</i>&nbsp;     *
<i>672</i>&nbsp;     * @param val decimal String representation of BigInteger.
<i>673</i>&nbsp;     * @throws NumberFormatException {@code val} is not a valid representation
<i>674</i>&nbsp;     *         of a BigInteger.
<i>675</i>&nbsp;     * @see    Character#digit
<i>676</i>&nbsp;     */
<i>677</i>&nbsp;    public BigInteger(String val) {
<i>678</i>&nbsp;        this(val, 10);
<i>679</i>&nbsp;    }
<i>680</i>&nbsp;
<i>681</i>&nbsp;    /**
<i>682</i>&nbsp;     * Constructs a randomly generated BigInteger, uniformly distributed over
<i>683</i>&nbsp;     * the range 0 to (2&lt;sup&gt;{@code numBits}&lt;/sup&gt; - 1), inclusive.
<i>684</i>&nbsp;     * The uniformity of the distribution assumes that a fair source of random
<i>685</i>&nbsp;     * bits is provided in {@code rnd}.  Note that this constructor always
<i>686</i>&nbsp;     * constructs a non-negative BigInteger.
<i>687</i>&nbsp;     *
<i>688</i>&nbsp;     * @param  numBits maximum bitLength of the new BigInteger.
<i>689</i>&nbsp;     * @param  rnd source of randomness to be used in computing the new
<i>690</i>&nbsp;     *         BigInteger.
<i>691</i>&nbsp;     * @throws IllegalArgumentException {@code numBits} is negative.
<i>692</i>&nbsp;     * @see #bitLength()
<i>693</i>&nbsp;     */
<b class="nc"><i>694</i>&nbsp;    public BigInteger(int numBits, Random rnd) {</b>
<b class="nc"><i>695</i>&nbsp;        this(1, randomBits(numBits, rnd));</b>
<i>696</i>&nbsp;    }
<b class="nc"><i>697</i>&nbsp;</b>
<b class="nc"><i>698</i>&nbsp;    private static byte[] randomBits(int numBits, Random rnd) {</b>
<b class="nc"><i>699</i>&nbsp;        if (numBits &lt; 0)</b>
<i>700</i>&nbsp;            throw new IllegalArgumentException(&quot;numBits must be non-negative&quot;);
<i>701</i>&nbsp;        int numBytes = (int)(((long)numBits+7)/8); // avoid overflow
<i>702</i>&nbsp;        byte[] randomBits = new byte[numBytes];
<i>703</i>&nbsp;
<i>704</i>&nbsp;        // Generate random bytes and mask out any excess bits
<i>705</i>&nbsp;        if (numBytes &gt; 0) {
<i>706</i>&nbsp;            rnd.nextBytes(randomBits);
<i>707</i>&nbsp;            int excessBits = 8*numBytes - numBits;
<i>708</i>&nbsp;            randomBits[0] &amp;= (1 &lt;&lt; (8-excessBits)) - 1;
<i>709</i>&nbsp;        }
<b class="nc"><i>710</i>&nbsp;        return randomBits;</b>
<b class="nc"><i>711</i>&nbsp;    }</b>
<b class="nc"><i>712</i>&nbsp;</b>
<b class="nc"><i>713</i>&nbsp;    /**</b>
<i>714</i>&nbsp;     * Constructs a randomly generated positive BigInteger that is probably
<i>715</i>&nbsp;     * prime, with the specified bitLength.
<i>716</i>&nbsp;     *
<b class="nc"><i>717</i>&nbsp;     * @apiNote It is recommended that the {@link #probablePrime probablePrime}</b>
<b class="nc"><i>718</i>&nbsp;     * method be used in preference to this constructor unless there</b>
<b class="nc"><i>719</i>&nbsp;     * is a compelling need to specify a certainty.</b>
<b class="nc"><i>720</i>&nbsp;     *</b>
<b class="nc"><i>721</i>&nbsp;     * @param  bitLength bitLength of the returned BigInteger.</b>
<i>722</i>&nbsp;     * @param  certainty a measure of the uncertainty that the caller is
<b class="nc"><i>723</i>&nbsp;     *         willing to tolerate.  The probability that the new BigInteger</b>
<i>724</i>&nbsp;     *         represents a prime number will exceed
<i>725</i>&nbsp;     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of
<b class="nc"><i>726</i>&nbsp;     *         this constructor is proportional to the value of this parameter.</b>
<b class="nc"><i>727</i>&nbsp;     * @param  rnd source of random bits used to select candidates to be</b>
<b class="nc"><i>728</i>&nbsp;     *         tested for primality.</b>
<i>729</i>&nbsp;     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.
<i>730</i>&nbsp;     * @see    #bitLength()
<b class="nc"><i>731</i>&nbsp;     */</b>
<i>732</i>&nbsp;    public BigInteger(int bitLength, int certainty, Random rnd) {
<i>733</i>&nbsp;        BigInteger prime;
<i>734</i>&nbsp;
<b class="nc"><i>735</i>&nbsp;        if (bitLength &lt; 2)</b>
<b class="nc"><i>736</i>&nbsp;            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</b>
<i>737</i>&nbsp;        prime = (bitLength &lt; SMALL_PRIME_THRESHOLD
<i>738</i>&nbsp;                                ? smallPrime(bitLength, certainty, rnd)
<b class="nc"><i>739</i>&nbsp;                                : largePrime(bitLength, certainty, rnd));</b>
<b class="nc"><i>740</i>&nbsp;        signum = 1;</b>
<b class="nc"><i>741</i>&nbsp;        mag = prime.mag;</b>
<i>742</i>&nbsp;    }
<i>743</i>&nbsp;
<b class="nc"><i>744</i>&nbsp;    // Minimum size in bits that the requested prime number has</b>
<b class="nc"><i>745</i>&nbsp;    // before we use the large prime number generating algorithms.</b>
<i>746</i>&nbsp;    // The cutoff of 95 was chosen empirically for best performance.
<i>747</i>&nbsp;    private static final int SMALL_PRIME_THRESHOLD = 95;
<i>748</i>&nbsp;
<i>749</i>&nbsp;    // Certainty required to meet the spec of probablePrime
<i>750</i>&nbsp;    private static final int DEFAULT_PRIME_CERTAINTY = 100;
<i>751</i>&nbsp;
<i>752</i>&nbsp;    /**
<i>753</i>&nbsp;     * Returns a positive BigInteger that is probably prime, with the
<i>754</i>&nbsp;     * specified bitLength. The probability that a BigInteger returned
<b class="nc"><i>755</i>&nbsp;     * by this method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;.</b>
<b class="nc"><i>756</i>&nbsp;     *</b>
<i>757</i>&nbsp;     * @param  bitLength bitLength of the returned BigInteger.
<i>758</i>&nbsp;     * @param  rnd source of random bits used to select candidates to be
<b class="nc"><i>759</i>&nbsp;     *         tested for primality.</b>
<b class="nc"><i>760</i>&nbsp;     * @return a BigInteger of {@code bitLength} bits that is probably prime</b>
<b class="nc"><i>761</i>&nbsp;     * @throws ArithmeticException {@code bitLength &lt; 2} or {@code bitLength} is too large.</b>
<i>762</i>&nbsp;     * @see    #bitLength()
<b class="nc"><i>763</i>&nbsp;     * @since 1.4</b>
<b class="nc"><i>764</i>&nbsp;     */</b>
<b class="nc"><i>765</i>&nbsp;    public static BigInteger probablePrime(int bitLength, Random rnd) {</b>
<b class="nc"><i>766</i>&nbsp;        if (bitLength &lt; 2)</b>
<b class="nc"><i>767</i>&nbsp;            throw new ArithmeticException(&quot;bitLength &lt; 2&quot;);</b>
<b class="nc"><i>768</i>&nbsp;</b>
<b class="nc"><i>769</i>&nbsp;        return (bitLength &lt; SMALL_PRIME_THRESHOLD ?</b>
<i>770</i>&nbsp;                smallPrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd) :
<b class="nc"><i>771</i>&nbsp;                largePrime(bitLength, DEFAULT_PRIME_CERTAINTY, rnd));</b>
<i>772</i>&nbsp;    }
<i>773</i>&nbsp;
<i>774</i>&nbsp;    /**
<i>775</i>&nbsp;     * Find a random number of the specified bitLength that is probably prime.
<i>776</i>&nbsp;     * This method is used for smaller primes, its performance degrades on
<i>777</i>&nbsp;     * larger bitlengths.
<i>778</i>&nbsp;     *
<i>779</i>&nbsp;     * This method assumes bitLength &gt; 1.
<i>780</i>&nbsp;     */
<i>781</i>&nbsp;    private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {
<i>782</i>&nbsp;        int magLen = (bitLength + 31) &gt;&gt;&gt; 5;
<i>783</i>&nbsp;        int temp[] = new int[magLen];
<i>784</i>&nbsp;        int highBit = 1 &lt;&lt; ((bitLength+31) &amp; 0x1f);  // High bit of high int
<i>785</i>&nbsp;        int highMask = (highBit &lt;&lt; 1) - 1;  // Bits to keep in high int
<i>786</i>&nbsp;
<b class="nc"><i>787</i>&nbsp;        while (true) {</b>
<b class="nc"><i>788</i>&nbsp;            // Construct a candidate</b>
<i>789</i>&nbsp;            for (int i=0; i &lt; magLen; i++)
<i>790</i>&nbsp;                temp[i] = rnd.nextInt();
<b class="nc"><i>791</i>&nbsp;            temp[0] = (temp[0] &amp; highMask) | highBit;  // Ensure exact length</b>
<b class="nc"><i>792</i>&nbsp;            if (bitLength &gt; 2)</b>
<i>793</i>&nbsp;                temp[magLen-1] |= 1;  // Make odd if bitlen &gt; 2
<b class="nc"><i>794</i>&nbsp;</b>
<i>795</i>&nbsp;            BigInteger p = new BigInteger(temp, 1);
<i>796</i>&nbsp;
<b class="nc"><i>797</i>&nbsp;            // Do cheap &quot;pre-test&quot; if applicable</b>
<i>798</i>&nbsp;            if (bitLength &gt; 6) {
<i>799</i>&nbsp;                long r = p.remainder(SMALL_PRIME_PRODUCT).longValue();
<b class="nc"><i>800</i>&nbsp;                if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</b>
<b class="nc"><i>801</i>&nbsp;                    (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||</b>
<i>802</i>&nbsp;                    (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0))
<i>803</i>&nbsp;                    continue; // Candidate is composite; try another
<i>804</i>&nbsp;            }
<b class="nc"><i>805</i>&nbsp;</b>
<b class="nc"><i>806</i>&nbsp;            // All candidates of bitLength 2 and 3 are prime by this point</b>
<b class="nc"><i>807</i>&nbsp;            if (bitLength &lt; 4)</b>
<i>808</i>&nbsp;                return p;
<i>809</i>&nbsp;
<b class="nc"><i>810</i>&nbsp;            // Do expensive test if we survive pre-test (or it&#39;s inapplicable)</b>
<b class="nc"><i>811</i>&nbsp;            if (p.primeToCertainty(certainty, rnd))</b>
<i>812</i>&nbsp;                return p;
<i>813</i>&nbsp;        }
<i>814</i>&nbsp;    }
<i>815</i>&nbsp;
<b class="nc"><i>816</i>&nbsp;    private static final BigInteger SMALL_PRIME_PRODUCT</b>
<b class="nc"><i>817</i>&nbsp;                       = valueOf(3L*5*7*11*13*17*19*23*29*31*37*41);</b>
<i>818</i>&nbsp;
<i>819</i>&nbsp;    /**
<b class="nc"><i>820</i>&nbsp;     * Find a random number of the specified bitLength that is probably prime.</b>
<b class="nc"><i>821</i>&nbsp;     * This method is more appropriate for larger bitlengths since it uses</b>
<i>822</i>&nbsp;     * a sieve to eliminate most composites before using a more expensive
<b class="nc"><i>823</i>&nbsp;     * test.</b>
<i>824</i>&nbsp;     */
<i>825</i>&nbsp;    private static BigInteger largePrime(int bitLength, int certainty, Random rnd) {
<i>826</i>&nbsp;        BigInteger p;
<i>827</i>&nbsp;        p = new BigInteger(bitLength, rnd).setBit(bitLength-1);
<b class="nc"><i>828</i>&nbsp;        p.mag[p.mag.length-1] &amp;= 0xfffffffe;</b>
<b class="nc"><i>829</i>&nbsp;</b>
<i>830</i>&nbsp;        // Use a sieve length likely to contain the next prime number
<i>831</i>&nbsp;        int searchLen = getPrimeSearchLen(bitLength);
<b class="nc"><i>832</i>&nbsp;        BitSieve searchSieve = new BitSieve(p, searchLen);</b>
<i>833</i>&nbsp;        BigInteger candidate = searchSieve.retrieve(p, certainty, rnd);
<i>834</i>&nbsp;
<b class="nc"><i>835</i>&nbsp;        while ((candidate == null) || (candidate.bitLength() != bitLength)) {</b>
<b class="nc"><i>836</i>&nbsp;            p = p.add(BigInteger.valueOf(2*searchLen));</b>
<i>837</i>&nbsp;            if (p.bitLength() != bitLength)
<b class="nc"><i>838</i>&nbsp;                p = new BigInteger(bitLength, rnd).setBit(bitLength-1);</b>
<b class="nc"><i>839</i>&nbsp;            p.mag[p.mag.length-1] &amp;= 0xfffffffe;</b>
<b class="nc"><i>840</i>&nbsp;            searchSieve = new BitSieve(p, searchLen);</b>
<b class="nc"><i>841</i>&nbsp;            candidate = searchSieve.retrieve(p, certainty, rnd);</b>
<i>842</i>&nbsp;        }
<i>843</i>&nbsp;        return candidate;
<i>844</i>&nbsp;    }
<b class="nc"><i>845</i>&nbsp;</b>
<b class="nc"><i>846</i>&nbsp;   /**</b>
<i>847</i>&nbsp;    * Returns the first integer greater than this {@code BigInteger} that
<b class="nc"><i>848</i>&nbsp;    * is probably prime.  The probability that the number returned by this</b>
<i>849</i>&nbsp;    * method is composite does not exceed 2&lt;sup&gt;-100&lt;/sup&gt;. This method will
<i>850</i>&nbsp;    * never skip over a prime when searching: if it returns {@code p}, there
<i>851</i>&nbsp;    * is no prime {@code q} such that {@code this &lt; q &lt; p}.
<i>852</i>&nbsp;    *
<i>853</i>&nbsp;    * @return the first integer greater than this {@code BigInteger} that
<i>854</i>&nbsp;    *         is probably prime.
<i>855</i>&nbsp;    * @throws ArithmeticException {@code this &lt; 0} or {@code this} is too large.
<i>856</i>&nbsp;    * @since 1.5
<i>857</i>&nbsp;    */
<i>858</i>&nbsp;    public BigInteger nextProbablePrime() {
<i>859</i>&nbsp;        if (this.signum &lt; 0)
<i>860</i>&nbsp;            throw new ArithmeticException(&quot;start &lt; 0: &quot; + this);
<i>861</i>&nbsp;
<i>862</i>&nbsp;        // Handle trivial cases
<i>863</i>&nbsp;        if ((this.signum == 0) || this.equals(ONE))
<i>864</i>&nbsp;            return TWO;
<i>865</i>&nbsp;
<b class="nc"><i>866</i>&nbsp;        BigInteger result = this.add(ONE);</b>
<b class="nc"><i>867</i>&nbsp;</b>
<i>868</i>&nbsp;        // Fastpath for small numbers
<i>869</i>&nbsp;        if (result.bitLength() &lt; SMALL_PRIME_THRESHOLD) {
<i>870</i>&nbsp;
<i>871</i>&nbsp;            // Ensure an odd number
<b class="nc"><i>872</i>&nbsp;            if (!result.testBit(0))</b>
<b class="nc"><i>873</i>&nbsp;                result = result.add(ONE);</b>
<b class="nc"><i>874</i>&nbsp;</b>
<b class="nc"><i>875</i>&nbsp;            while (true) {</b>
<b class="nc"><i>876</i>&nbsp;                // Do cheap &quot;pre-test&quot; if applicable</b>
<i>877</i>&nbsp;                if (result.bitLength() &gt; 6) {
<i>878</i>&nbsp;                    long r = result.remainder(SMALL_PRIME_PRODUCT).longValue();
<b class="nc"><i>879</i>&nbsp;                    if ((r%3==0)  || (r%5==0)  || (r%7==0)  || (r%11==0) ||</b>
<b class="nc"><i>880</i>&nbsp;                        (r%13==0) || (r%17==0) || (r%19==0) || (r%23==0) ||</b>
<b class="nc"><i>881</i>&nbsp;                        (r%29==0) || (r%31==0) || (r%37==0) || (r%41==0)) {</b>
<b class="nc"><i>882</i>&nbsp;                        result = result.add(TWO);</b>
<b class="nc"><i>883</i>&nbsp;                        continue; // Candidate is composite; try another</b>
<b class="nc"><i>884</i>&nbsp;                    }</b>
<b class="nc"><i>885</i>&nbsp;                }</b>
<b class="nc"><i>886</i>&nbsp;</b>
<i>887</i>&nbsp;                // All candidates of bitLength 2 and 3 are prime by this point
<b class="nc"><i>888</i>&nbsp;                if (result.bitLength() &lt; 4)</b>
<i>889</i>&nbsp;                    return result;
<b class="nc"><i>890</i>&nbsp;</b>
<i>891</i>&nbsp;                // The expensive test
<b class="nc"><i>892</i>&nbsp;                if (result.primeToCertainty(DEFAULT_PRIME_CERTAINTY, null))</b>
<i>893</i>&nbsp;                    return result;
<i>894</i>&nbsp;
<i>895</i>&nbsp;                result = result.add(TWO);
<i>896</i>&nbsp;            }
<i>897</i>&nbsp;        }
<i>898</i>&nbsp;
<i>899</i>&nbsp;        // Start at previous even number
<i>900</i>&nbsp;        if (result.testBit(0))
<i>901</i>&nbsp;            result = result.subtract(ONE);
<b class="nc"><i>902</i>&nbsp;</b>
<i>903</i>&nbsp;        // Looking for the next large prime
<i>904</i>&nbsp;        int searchLen = getPrimeSearchLen(result.bitLength());
<b class="nc"><i>905</i>&nbsp;</b>
<b class="nc"><i>906</i>&nbsp;        while (true) {</b>
<i>907</i>&nbsp;           BitSieve searchSieve = new BitSieve(result, searchLen);
<b class="nc"><i>908</i>&nbsp;           BigInteger candidate = searchSieve.retrieve(result,</b>
<i>909</i>&nbsp;                                                 DEFAULT_PRIME_CERTAINTY, null);
<i>910</i>&nbsp;           if (candidate != null)
<i>911</i>&nbsp;               return candidate;
<b class="nc"><i>912</i>&nbsp;           result = result.add(BigInteger.valueOf(2 * searchLen));</b>
<i>913</i>&nbsp;        }
<i>914</i>&nbsp;    }
<b class="nc"><i>915</i>&nbsp;</b>
<i>916</i>&nbsp;    private static int getPrimeSearchLen(int bitLength) {
<i>917</i>&nbsp;        if (bitLength &gt; PRIME_SEARCH_BIT_LENGTH_LIMIT + 1) {
<i>918</i>&nbsp;            throw new ArithmeticException(&quot;Prime search implementation restriction on bitLength&quot;);
<i>919</i>&nbsp;        }
<i>920</i>&nbsp;        return bitLength / 20 * 64;
<i>921</i>&nbsp;    }
<i>922</i>&nbsp;
<b class="nc"><i>923</i>&nbsp;    /**</b>
<b class="nc"><i>924</i>&nbsp;     * Returns {@code true} if this BigInteger is probably prime,</b>
<i>925</i>&nbsp;     * {@code false} if it&#39;s definitely composite.
<i>926</i>&nbsp;     *
<b class="nc"><i>927</i>&nbsp;     * This method assumes bitLength &gt; 2.</b>
<b class="nc"><i>928</i>&nbsp;     *</b>
<i>929</i>&nbsp;     * @param  certainty a measure of the uncertainty that the caller is
<i>930</i>&nbsp;     *         willing to tolerate: if the call returns {@code true}
<b class="nc"><i>931</i>&nbsp;     *         the probability that this BigInteger is prime exceeds</b>
<b class="nc"><i>932</i>&nbsp;     *         {@code (1 - 1/2&lt;sup&gt;certainty&lt;/sup&gt;)}.  The execution time of</b>
<b class="nc"><i>933</i>&nbsp;     *         this method is proportional to the value of this parameter.</b>
<b class="nc"><i>934</i>&nbsp;     * @return {@code true} if this BigInteger is probably prime,</b>
<b class="nc"><i>935</i>&nbsp;     *         {@code false} if it&#39;s definitely composite.</b>
<i>936</i>&nbsp;     */
<i>937</i>&nbsp;    boolean primeToCertainty(int certainty, Random random) {
<i>938</i>&nbsp;        int rounds = 0;
<b class="nc"><i>939</i>&nbsp;        int n = (Math.min(certainty, Integer.MAX_VALUE-1)+1)/2;</b>
<b class="nc"><i>940</i>&nbsp;</b>
<b class="nc"><i>941</i>&nbsp;        // The relationship between the certainty and the number of rounds</b>
<b class="nc"><i>942</i>&nbsp;        // we perform is given in the draft standard ANSI X9.80, &quot;PRIME</b>
<b class="nc"><i>943</i>&nbsp;        // NUMBER GENERATION, PRIMALITY TESTING, AND PRIMALITY CERTIFICATES&quot;.</b>
<b class="nc"><i>944</i>&nbsp;        int sizeInBits = this.bitLength();</b>
<i>945</i>&nbsp;        if (sizeInBits &lt; 100) {
<b class="nc"><i>946</i>&nbsp;            rounds = 50;</b>
<b class="nc"><i>947</i>&nbsp;            rounds = n &lt; rounds ? n : rounds;</b>
<i>948</i>&nbsp;            return passesMillerRabin(rounds, random);
<b class="nc"><i>949</i>&nbsp;        }</b>
<b class="nc"><i>950</i>&nbsp;</b>
<i>951</i>&nbsp;        if (sizeInBits &lt; 256) {
<b class="nc"><i>952</i>&nbsp;            rounds = 27;</b>
<i>953</i>&nbsp;        } else if (sizeInBits &lt; 512) {
<i>954</i>&nbsp;            rounds = 15;
<b class="nc"><i>955</i>&nbsp;        } else if (sizeInBits &lt; 768) {</b>
<b class="nc"><i>956</i>&nbsp;            rounds = 8;</b>
<b class="nc"><i>957</i>&nbsp;        } else if (sizeInBits &lt; 1024) {</b>
<b class="nc"><i>958</i>&nbsp;            rounds = 4;</b>
<b class="nc"><i>959</i>&nbsp;        } else {</b>
<b class="nc"><i>960</i>&nbsp;            rounds = 2;</b>
<b class="nc"><i>961</i>&nbsp;        }</b>
<i>962</i>&nbsp;        rounds = n &lt; rounds ? n : rounds;
<b class="nc"><i>963</i>&nbsp;</b>
<b class="nc"><i>964</i>&nbsp;        return passesMillerRabin(rounds, random) &amp;&amp; passesLucasLehmer();</b>
<i>965</i>&nbsp;    }
<b class="nc"><i>966</i>&nbsp;</b>
<b class="nc"><i>967</i>&nbsp;    /**</b>
<b class="nc"><i>968</i>&nbsp;     * Returns true iff this BigInteger is a Lucas-Lehmer probable prime.</b>
<b class="nc"><i>969</i>&nbsp;     *</b>
<i>970</i>&nbsp;     * The following assumptions are made:
<b class="nc"><i>971</i>&nbsp;     * This BigInteger is a positive, odd number.</b>
<b class="nc"><i>972</i>&nbsp;     */</b>
<b class="nc"><i>973</i>&nbsp;    private boolean passesLucasLehmer() {</b>
<i>974</i>&nbsp;        BigInteger thisPlusOne = this.add(ONE);
<i>975</i>&nbsp;
<i>976</i>&nbsp;        // Step 1
<b class="nc"><i>977</i>&nbsp;        int d = 5;</b>
<b class="nc"><i>978</i>&nbsp;        while (jacobiSymbol(d, this) != -1) {</b>
<b class="nc"><i>979</i>&nbsp;            // 5, -7, 9, -11, ...</b>
<i>980</i>&nbsp;            d = (d &lt; 0) ? Math.abs(d)+2 : -(d+2);
<b class="nc"><i>981</i>&nbsp;        }</b>
<b class="nc"><i>982</i>&nbsp;</b>
<i>983</i>&nbsp;        // Step 2
<b class="nc"><i>984</i>&nbsp;        BigInteger u = lucasLehmerSequence(d, thisPlusOne, this);</b>
<b class="nc"><i>985</i>&nbsp;</b>
<b class="nc"><i>986</i>&nbsp;        // Step 3</b>
<i>987</i>&nbsp;        return u.mod(this).equals(ZERO);
<b class="nc"><i>988</i>&nbsp;    }</b>
<i>989</i>&nbsp;
<b class="nc"><i>990</i>&nbsp;    /**</b>
<b class="nc"><i>991</i>&nbsp;     * Computes Jacobi(p,n).</b>
<b class="nc"><i>992</i>&nbsp;     * Assumes n positive, odd, n&gt;=3.</b>
<b class="nc"><i>993</i>&nbsp;     */</b>
<b class="nc"><i>994</i>&nbsp;    private static int jacobiSymbol(int p, BigInteger n) {</b>
<i>995</i>&nbsp;        if (p == 0)
<b class="nc"><i>996</i>&nbsp;            return 0;</b>
<b class="nc"><i>997</i>&nbsp;</b>
<b class="nc"><i>998</i>&nbsp;        // Algorithm and comments adapted from Colin Plumb&#39;s C library.</b>
<b class="nc"><i>999</i>&nbsp;        int j = 1;</b>
<b class="nc"><i>1000</i>&nbsp;        int u = n.mag[n.mag.length-1];</b>
<i>1001</i>&nbsp;
<b class="nc"><i>1002</i>&nbsp;        // Make p positive</b>
<i>1003</i>&nbsp;        if (p &lt; 0) {
<i>1004</i>&nbsp;            p = -p;
<b class="nc"><i>1005</i>&nbsp;            int n8 = u &amp; 7;</b>
<i>1006</i>&nbsp;            if ((n8 == 3) || (n8 == 7))
<i>1007</i>&nbsp;                j = -j; // 3 (011) or 7 (111) mod 8
<i>1008</i>&nbsp;        }
<i>1009</i>&nbsp;
<i>1010</i>&nbsp;        // Get rid of factors of 2 in p
<i>1011</i>&nbsp;        while ((p &amp; 3) == 0)
<i>1012</i>&nbsp;            p &gt;&gt;= 2;
<i>1013</i>&nbsp;        if ((p &amp; 1) == 0) {
<i>1014</i>&nbsp;            p &gt;&gt;= 1;
<i>1015</i>&nbsp;            if (((u ^ (u&gt;&gt;1)) &amp; 2) != 0)
<i>1016</i>&nbsp;                j = -j; // 3 (011) or 5 (101) mod 8
<i>1017</i>&nbsp;        }
<i>1018</i>&nbsp;        if (p == 1)
<b class="nc"><i>1019</i>&nbsp;            return j;</b>
<b class="nc"><i>1020</i>&nbsp;        // Then, apply quadratic reciprocity</b>
<b class="nc"><i>1021</i>&nbsp;        if ((p &amp; u &amp; 2) != 0)   // p = u = 3 (mod 4)?</b>
<b class="nc"><i>1022</i>&nbsp;            j = -j;</b>
<i>1023</i>&nbsp;        // And reduce u mod p
<i>1024</i>&nbsp;        u = n.mod(BigInteger.valueOf(p)).intValue();
<b class="nc"><i>1025</i>&nbsp;</b>
<b class="nc"><i>1026</i>&nbsp;        // Now compute Jacobi(u,p), u &lt; p</b>
<i>1027</i>&nbsp;        while (u != 0) {
<b class="nc"><i>1028</i>&nbsp;            while ((u &amp; 3) == 0)</b>
<i>1029</i>&nbsp;                u &gt;&gt;= 2;
<i>1030</i>&nbsp;            if ((u &amp; 1) == 0) {
<i>1031</i>&nbsp;                u &gt;&gt;= 1;
<b class="nc"><i>1032</i>&nbsp;                if (((p ^ (p&gt;&gt;1)) &amp; 2) != 0)</b>
<b class="nc"><i>1033</i>&nbsp;                    j = -j;     // 3 (011) or 5 (101) mod 8</b>
<i>1034</i>&nbsp;            }
<b class="nc"><i>1035</i>&nbsp;            if (u == 1)</b>
<b class="nc"><i>1036</i>&nbsp;                return j;</b>
<b class="nc"><i>1037</i>&nbsp;            // Now both u and p are odd, so use quadratic reciprocity</b>
<b class="nc"><i>1038</i>&nbsp;            assert (u &lt; p);</b>
<b class="nc"><i>1039</i>&nbsp;            int t = u; u = p; p = t;</b>
<b class="nc"><i>1040</i>&nbsp;            if ((u &amp; p &amp; 2) != 0) // u = p = 3 (mod 4)?</b>
<i>1041</i>&nbsp;                j = -j;
<i>1042</i>&nbsp;            // Now u &gt;= p, so it can be reduced
<b class="nc"><i>1043</i>&nbsp;            u %= p;</b>
<i>1044</i>&nbsp;        }
<i>1045</i>&nbsp;        return 0;
<i>1046</i>&nbsp;    }
<i>1047</i>&nbsp;
<i>1048</i>&nbsp;    private static BigInteger lucasLehmerSequence(int z, BigInteger k, BigInteger n) {
<i>1049</i>&nbsp;        BigInteger d = BigInteger.valueOf(z);
<i>1050</i>&nbsp;        BigInteger u = ONE; BigInteger u2;
<b class="nc"><i>1051</i>&nbsp;        BigInteger v = ONE; BigInteger v2;</b>
<b class="nc"><i>1052</i>&nbsp;</b>
<b class="nc"><i>1053</i>&nbsp;        for (int i=k.bitLength()-2; i &gt;= 0; i--) {</b>
<b class="nc"><i>1054</i>&nbsp;            u2 = u.multiply(v).mod(n);</b>
<b class="nc"><i>1055</i>&nbsp;</b>
<i>1056</i>&nbsp;            v2 = v.square().add(d.multiply(u.square())).mod(n);
<i>1057</i>&nbsp;            if (v2.testBit(0))
<i>1058</i>&nbsp;                v2 = v2.subtract(n);
<i>1059</i>&nbsp;
<i>1060</i>&nbsp;            v2 = v2.shiftRight(1);
<i>1061</i>&nbsp;
<i>1062</i>&nbsp;            u = u2; v = v2;
<b class="nc"><i>1063</i>&nbsp;            if (k.testBit(i)) {</b>
<b class="nc"><i>1064</i>&nbsp;                u2 = u.add(v).mod(n);</b>
<b class="nc"><i>1065</i>&nbsp;                if (u2.testBit(0))</b>
<b class="nc"><i>1066</i>&nbsp;                    u2 = u2.subtract(n);</b>
<b class="nc"><i>1067</i>&nbsp;</b>
<i>1068</i>&nbsp;                u2 = u2.shiftRight(1);
<i>1069</i>&nbsp;                v2 = v.add(d.multiply(u)).mod(n);
<i>1070</i>&nbsp;                if (v2.testBit(0))
<i>1071</i>&nbsp;                    v2 = v2.subtract(n);
<i>1072</i>&nbsp;                v2 = v2.shiftRight(1);
<i>1073</i>&nbsp;
<i>1074</i>&nbsp;                u = u2; v = v2;
<i>1075</i>&nbsp;            }
<i>1076</i>&nbsp;        }
<i>1077</i>&nbsp;        return u;
<b class="nc"><i>1078</i>&nbsp;    }</b>
<b class="nc"><i>1079</i>&nbsp;</b>
<i>1080</i>&nbsp;    /**
<i>1081</i>&nbsp;     * Returns true iff this BigInteger passes the specified number of
<i>1082</i>&nbsp;     * Miller-Rabin tests. This test is taken from the DSA spec (NIST FIPS
<i>1083</i>&nbsp;     * 186-2).
<b class="nc"><i>1084</i>&nbsp;     *</b>
<i>1085</i>&nbsp;     * The following assumptions are made:
<i>1086</i>&nbsp;     * This BigInteger is a positive, odd number greater than 2.
<i>1087</i>&nbsp;     * iterations&lt;=50.
<i>1088</i>&nbsp;     */
<i>1089</i>&nbsp;    private boolean passesMillerRabin(int iterations, Random rnd) {
<i>1090</i>&nbsp;        // Find a and m such that m is odd and this == 1 + 2**a * m
<i>1091</i>&nbsp;        BigInteger thisMinusOne = this.subtract(ONE);
<i>1092</i>&nbsp;        BigInteger m = thisMinusOne;
<i>1093</i>&nbsp;        int a = m.getLowestSetBit();
<i>1094</i>&nbsp;        m = m.shiftRight(a);
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;        // Do the tests
<i>1097</i>&nbsp;        if (rnd == null) {
<i>1098</i>&nbsp;            rnd = ThreadLocalRandom.current();
<i>1099</i>&nbsp;        }
<b class="nc"><i>1100</i>&nbsp;        for (int i=0; i &lt; iterations; i++) {</b>
<b class="nc"><i>1101</i>&nbsp;            // Generate a uniform random on (1, this)</b>
<b class="nc"><i>1102</i>&nbsp;            BigInteger b;</b>
<b class="nc"><i>1103</i>&nbsp;            do {</b>
<b class="nc"><i>1104</i>&nbsp;                b = new BigInteger(this.bitLength(), rnd);</b>
<b class="nc"><i>1105</i>&nbsp;            } while (b.compareTo(ONE) &lt;= 0 || b.compareTo(this) &gt;= 0);</b>
<i>1106</i>&nbsp;
<b class="nc"><i>1107</i>&nbsp;            int j = 0;</b>
<i>1108</i>&nbsp;            BigInteger z = b.modPow(m, this);
<i>1109</i>&nbsp;            while (!((j == 0 &amp;&amp; z.equals(ONE)) || z.equals(thisMinusOne))) {
<i>1110</i>&nbsp;                if (j &gt; 0 &amp;&amp; z.equals(ONE) || ++j == a)
<i>1111</i>&nbsp;                    return false;
<i>1112</i>&nbsp;                z = z.modPow(TWO, this);
<b class="nc"><i>1113</i>&nbsp;            }</b>
<b class="nc"><i>1114</i>&nbsp;        }</b>
<b class="nc"><i>1115</i>&nbsp;        return true;</b>
<b class="nc"><i>1116</i>&nbsp;    }</b>
<i>1117</i>&nbsp;
<b class="nc"><i>1118</i>&nbsp;    /**</b>
<i>1119</i>&nbsp;     * This internal constructor differs from its public cousin
<i>1120</i>&nbsp;     * with the arguments reversed in two ways: it assumes that its
<b class="nc"><i>1121</i>&nbsp;     * arguments are correct, and it doesn&#39;t copy the magnitude array.</b>
<b class="nc"><i>1122</i>&nbsp;     */</b>
<b class="nc"><i>1123</i>&nbsp;    BigInteger(int[] magnitude, int signum) {</b>
<b class="nc"><i>1124</i>&nbsp;        this.signum = (magnitude.length == 0 ? 0 : signum);</b>
<i>1125</i>&nbsp;        this.mag = magnitude;
<b class="nc"><i>1126</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {</b>
<b class="nc"><i>1127</i>&nbsp;            checkRange();</b>
<b class="nc"><i>1128</i>&nbsp;        }</b>
<i>1129</i>&nbsp;    }
<i>1130</i>&nbsp;
<i>1131</i>&nbsp;    /**
<i>1132</i>&nbsp;     * This private constructor is for internal use and assumes that its
<i>1133</i>&nbsp;     * arguments are correct.  The {@code magnitude} array is assumed to be
<i>1134</i>&nbsp;     * unchanged for the duration of the constructor call.
<i>1135</i>&nbsp;     */
<i>1136</i>&nbsp;    private BigInteger(byte[] magnitude, int signum) {
<i>1137</i>&nbsp;        this.signum = (magnitude.length == 0 ? 0 : signum);
<b class="nc"><i>1138</i>&nbsp;        this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);</b>
<i>1139</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<i>1140</i>&nbsp;            checkRange();
<i>1141</i>&nbsp;        }
<i>1142</i>&nbsp;    }
<i>1143</i>&nbsp;
<i>1144</i>&nbsp;    /**
<i>1145</i>&nbsp;     * Throws an {@code ArithmeticException} if the {@code BigInteger} would be
<i>1146</i>&nbsp;     * out of the supported range.
<b class="nc"><i>1147</i>&nbsp;     *</b>
<b class="nc"><i>1148</i>&nbsp;     * @throws ArithmeticException if {@code this} exceeds the supported range.</b>
<i>1149</i>&nbsp;     */
<i>1150</i>&nbsp;    private void checkRange() {
<i>1151</i>&nbsp;        if (mag.length &gt; MAX_MAG_LENGTH || mag.length == MAX_MAG_LENGTH &amp;&amp; mag[0] &lt; 0) {
<i>1152</i>&nbsp;            reportOverflow();
<i>1153</i>&nbsp;        }
<i>1154</i>&nbsp;    }
<i>1155</i>&nbsp;
<i>1156</i>&nbsp;    private static void reportOverflow() {
<i>1157</i>&nbsp;        throw new ArithmeticException(&quot;BigInteger would overflow supported range&quot;);
<i>1158</i>&nbsp;    }
<i>1159</i>&nbsp;
<i>1160</i>&nbsp;    //Static Factory Methods
<b class="nc"><i>1161</i>&nbsp;</b>
<i>1162</i>&nbsp;    /**
<i>1163</i>&nbsp;     * Returns a BigInteger whose value is equal to that of the
<b class="nc"><i>1164</i>&nbsp;     * specified {@code long}.</b>
<b class="nc"><i>1165</i>&nbsp;     *</b>
<b class="nc"><i>1166</i>&nbsp;     * @apiNote This static factory method is provided in preference</b>
<b class="nc"><i>1167</i>&nbsp;     * to a ({@code long}) constructor because it allows for reuse of</b>
<b class="nc"><i>1168</i>&nbsp;     * frequently used BigIntegers.</b>
<i>1169</i>&nbsp;     *
<i>1170</i>&nbsp;     * @param  val value of the BigInteger to return.
<i>1171</i>&nbsp;     * @return a BigInteger with the specified value.
<i>1172</i>&nbsp;     */
<i>1173</i>&nbsp;    public static BigInteger valueOf(long val) {
<i>1174</i>&nbsp;        // If -MAX_CONSTANT &lt; val &lt; MAX_CONSTANT, return stashed constant
<i>1175</i>&nbsp;        if (val == 0)
<b class="nc"><i>1176</i>&nbsp;            return ZERO;</b>
<b class="nc"><i>1177</i>&nbsp;        if (val &gt; 0 &amp;&amp; val &lt;= MAX_CONSTANT)</b>
<i>1178</i>&nbsp;            return posConst[(int) val];
<b class="nc"><i>1179</i>&nbsp;        else if (val &lt; 0 &amp;&amp; val &gt;= -MAX_CONSTANT)</b>
<b class="nc"><i>1180</i>&nbsp;            return negConst[(int) -val];</b>
<b class="nc"><i>1181</i>&nbsp;</b>
<i>1182</i>&nbsp;        return new BigInteger(val);
<i>1183</i>&nbsp;    }
<i>1184</i>&nbsp;
<i>1185</i>&nbsp;    /**
<i>1186</i>&nbsp;     * Constructs a BigInteger with the specified value, which may not be zero.
<i>1187</i>&nbsp;     */
<i>1188</i>&nbsp;    private BigInteger(long val) {
<i>1189</i>&nbsp;        if (val &lt; 0) {
<b class="nc"><i>1190</i>&nbsp;            val = -val;</b>
<i>1191</i>&nbsp;            signum = -1;
<i>1192</i>&nbsp;        } else {
<i>1193</i>&nbsp;            signum = 1;
<i>1194</i>&nbsp;        }
<i>1195</i>&nbsp;
<i>1196</i>&nbsp;        int highWord = (int)(val &gt;&gt;&gt; 32);
<b class="nc"><i>1197</i>&nbsp;        if (highWord == 0) {</b>
<i>1198</i>&nbsp;            mag = new int[1];
<i>1199</i>&nbsp;            mag[0] = (int)val;
<i>1200</i>&nbsp;        } else {
<i>1201</i>&nbsp;            mag = new int[2];
<b class="nc"><i>1202</i>&nbsp;            mag[0] = highWord;</b>
<i>1203</i>&nbsp;            mag[1] = (int)val;
<i>1204</i>&nbsp;        }
<i>1205</i>&nbsp;    }
<i>1206</i>&nbsp;
<b class="nc"><i>1207</i>&nbsp;    /**</b>
<i>1208</i>&nbsp;     * Returns a BigInteger with the given two&#39;s complement representation.
<i>1209</i>&nbsp;     * Assumes that the input array will not be modified (the returned
<i>1210</i>&nbsp;     * BigInteger will reference the input array if feasible).
<i>1211</i>&nbsp;     */
<i>1212</i>&nbsp;    private static BigInteger valueOf(int val[]) {
<i>1213</i>&nbsp;        return (val[0] &gt; 0 ? new BigInteger(val, 1) : new BigInteger(val));
<b class="nc"><i>1214</i>&nbsp;    }</b>
<i>1215</i>&nbsp;
<i>1216</i>&nbsp;    // Constants
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;    /**
<i>1219</i>&nbsp;     * Initialize static constant array when class is loaded.
<i>1220</i>&nbsp;     */
<i>1221</i>&nbsp;    private static final int MAX_CONSTANT = 16;
<i>1222</i>&nbsp;    private static BigInteger posConst[] = new BigInteger[MAX_CONSTANT+1];
<i>1223</i>&nbsp;    private static BigInteger negConst[] = new BigInteger[MAX_CONSTANT+1];
<i>1224</i>&nbsp;
<b class="nc"><i>1225</i>&nbsp;    /**</b>
<b class="nc"><i>1226</i>&nbsp;     * The cache of powers of each radix.  This allows us to not have to</b>
<b class="nc"><i>1227</i>&nbsp;     * recalculate powers of radix^(2^n) more than once.  This speeds</b>
<b class="nc"><i>1228</i>&nbsp;     * Schoenhage recursive base conversion significantly.</b>
<b class="nc"><i>1229</i>&nbsp;     */</b>
<b class="nc"><i>1230</i>&nbsp;    private static volatile BigInteger[][] powerCache;</b>
<i>1231</i>&nbsp;
<b class="nc"><i>1232</i>&nbsp;    /** The cache of logarithms of radices for base conversion. */</b>
<b class="nc"><i>1233</i>&nbsp;    private static final double[] logCache;</b>
<b class="nc"><i>1234</i>&nbsp;</b>
<b class="nc"><i>1235</i>&nbsp;    /** The natural log of 2.  This is used in computing cache indices. */</b>
<b class="nc"><i>1236</i>&nbsp;    private static final double LOG_TWO = Math.log(2.0);</b>
<b class="nc"><i>1237</i>&nbsp;</b>
<i>1238</i>&nbsp;    static {
<b class="nc"><i>1239</i>&nbsp;        for (int i = 1; i &lt;= MAX_CONSTANT; i++) {</b>
<i>1240</i>&nbsp;            int[] magnitude = new int[1];
<i>1241</i>&nbsp;            magnitude[0] = i;
<i>1242</i>&nbsp;            posConst[i] = new BigInteger(magnitude,  1);
<i>1243</i>&nbsp;            negConst[i] = new BigInteger(magnitude, -1);
<i>1244</i>&nbsp;        }
<i>1245</i>&nbsp;
<i>1246</i>&nbsp;        /*
<b class="nc"><i>1247</i>&nbsp;         * Initialize the cache of radix^(2^x) values used for base conversion</b>
<b class="nc"><i>1248</i>&nbsp;         * with just the very first value.  Additional values will be created</b>
<b class="nc"><i>1249</i>&nbsp;         * on demand.</b>
<b class="nc"><i>1250</i>&nbsp;         */</b>
<b class="nc"><i>1251</i>&nbsp;        powerCache = new BigInteger[Character.MAX_RADIX+1][];</b>
<b class="nc"><i>1252</i>&nbsp;        logCache = new double[Character.MAX_RADIX+1];</b>
<b class="nc"><i>1253</i>&nbsp;</b>
<b class="nc"><i>1254</i>&nbsp;        for (int i=Character.MIN_RADIX; i &lt;= Character.MAX_RADIX; i++) {</b>
<b class="nc"><i>1255</i>&nbsp;            powerCache[i] = new BigInteger[] { BigInteger.valueOf(i) };</b>
<b class="nc"><i>1256</i>&nbsp;            logCache[i] = Math.log(i);</b>
<b class="nc"><i>1257</i>&nbsp;        }</b>
<b class="nc"><i>1258</i>&nbsp;    }</b>
<i>1259</i>&nbsp;
<i>1260</i>&nbsp;    /**
<i>1261</i>&nbsp;     * The BigInteger constant zero.
<i>1262</i>&nbsp;     *
<i>1263</i>&nbsp;     * @since   1.2
<i>1264</i>&nbsp;     */
<i>1265</i>&nbsp;    public static final BigInteger ZERO = new BigInteger(new int[0], 0);
<i>1266</i>&nbsp;
<i>1267</i>&nbsp;    /**
<i>1268</i>&nbsp;     * The BigInteger constant one.
<b class="nc"><i>1269</i>&nbsp;     *</b>
<b class="nc"><i>1270</i>&nbsp;     * @since   1.2</b>
<i>1271</i>&nbsp;     */
<b class="nc"><i>1272</i>&nbsp;    public static final BigInteger ONE = valueOf(1);</b>
<b class="nc"><i>1273</i>&nbsp;</b>
<b class="nc"><i>1274</i>&nbsp;    /**</b>
<b class="nc"><i>1275</i>&nbsp;     * The BigInteger constant two.</b>
<b class="nc"><i>1276</i>&nbsp;     *</b>
<i>1277</i>&nbsp;     * @since   9
<b class="nc"><i>1278</i>&nbsp;     */</b>
<b class="nc"><i>1279</i>&nbsp;    public static final BigInteger TWO = valueOf(2);</b>
<b class="nc"><i>1280</i>&nbsp;</b>
<b class="nc"><i>1281</i>&nbsp;    /**</b>
<b class="nc"><i>1282</i>&nbsp;     * The BigInteger constant -1.  (Not exported.)</b>
<b class="nc"><i>1283</i>&nbsp;     */</b>
<i>1284</i>&nbsp;    private static final BigInteger NEGATIVE_ONE = valueOf(-1);
<b class="nc"><i>1285</i>&nbsp;</b>
<b class="nc"><i>1286</i>&nbsp;    /**</b>
<b class="nc"><i>1287</i>&nbsp;     * The BigInteger constant ten.</b>
<b class="nc"><i>1288</i>&nbsp;     *</b>
<b class="nc"><i>1289</i>&nbsp;     * @since   1.5</b>
<i>1290</i>&nbsp;     */
<i>1291</i>&nbsp;    public static final BigInteger TEN = valueOf(10);
<i>1292</i>&nbsp;
<b class="nc"><i>1293</i>&nbsp;    // Arithmetic Operations</b>
<b class="nc"><i>1294</i>&nbsp;</b>
<b class="nc"><i>1295</i>&nbsp;    /**</b>
<i>1296</i>&nbsp;     * Returns a BigInteger whose value is {@code (this + val)}.
<b class="nc"><i>1297</i>&nbsp;     *</b>
<b class="nc"><i>1298</i>&nbsp;     * @param  val value to be added to this BigInteger.</b>
<i>1299</i>&nbsp;     * @return {@code this + val}
<b class="nc"><i>1300</i>&nbsp;     */</b>
<b class="nc"><i>1301</i>&nbsp;    public BigInteger add(BigInteger val) {</b>
<b class="nc"><i>1302</i>&nbsp;        if (val.signum == 0)</b>
<b class="nc"><i>1303</i>&nbsp;            return this;</b>
<b class="nc"><i>1304</i>&nbsp;        if (signum == 0)</b>
<i>1305</i>&nbsp;            return val;
<b class="nc"><i>1306</i>&nbsp;        if (val.signum == signum)</b>
<i>1307</i>&nbsp;            return new BigInteger(add(mag, val.mag), signum);
<i>1308</i>&nbsp;
<i>1309</i>&nbsp;        int cmp = compareMagnitude(val);
<i>1310</i>&nbsp;        if (cmp == 0)
<i>1311</i>&nbsp;            return ZERO;
<i>1312</i>&nbsp;        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)
<i>1313</i>&nbsp;                           : subtract(val.mag, mag));
<i>1314</i>&nbsp;        resultMag = trustedStripLeadingZeroInts(resultMag);
<i>1315</i>&nbsp;
<b class="nc"><i>1316</i>&nbsp;        return new BigInteger(resultMag, cmp == signum ? 1 : -1);</b>
<b class="nc"><i>1317</i>&nbsp;    }</b>
<b class="nc"><i>1318</i>&nbsp;</b>
<b class="nc"><i>1319</i>&nbsp;    /**</b>
<i>1320</i>&nbsp;     * Package private methods used by BigDecimal code to add a BigInteger
<i>1321</i>&nbsp;     * with a long. Assumes val is not equal to INFLATED.
<b class="nc"><i>1322</i>&nbsp;     */</b>
<b class="nc"><i>1323</i>&nbsp;    BigInteger add(long val) {</b>
<b class="nc"><i>1324</i>&nbsp;        if (val == 0)</b>
<b class="nc"><i>1325</i>&nbsp;            return this;</b>
<b class="nc"><i>1326</i>&nbsp;        if (signum == 0)</b>
<b class="nc"><i>1327</i>&nbsp;            return valueOf(val);</b>
<b class="nc"><i>1328</i>&nbsp;        if (Long.signum(val) == signum)</b>
<i>1329</i>&nbsp;            return new BigInteger(add(mag, Math.abs(val)), signum);
<i>1330</i>&nbsp;        int cmp = compareMagnitude(val);
<b class="nc"><i>1331</i>&nbsp;        if (cmp == 0)</b>
<b class="nc"><i>1332</i>&nbsp;            return ZERO;</b>
<i>1333</i>&nbsp;        int[] resultMag = (cmp &gt; 0 ? subtract(mag, Math.abs(val)) : subtract(Math.abs(val), mag));
<b class="nc"><i>1334</i>&nbsp;        resultMag = trustedStripLeadingZeroInts(resultMag);</b>
<i>1335</i>&nbsp;        return new BigInteger(resultMag, cmp == signum ? 1 : -1);
<i>1336</i>&nbsp;    }
<i>1337</i>&nbsp;
<b class="nc"><i>1338</i>&nbsp;    /**</b>
<b class="nc"><i>1339</i>&nbsp;     * Adds the contents of the int array x and long value val. This</b>
<b class="nc"><i>1340</i>&nbsp;     * method allocates a new int array to hold the answer and returns</b>
<i>1341</i>&nbsp;     * a reference to that array.  Assumes x.length &amp;gt; 0 and val is
<i>1342</i>&nbsp;     * non-negative
<b class="nc"><i>1343</i>&nbsp;     */</b>
<b class="nc"><i>1344</i>&nbsp;    private static int[] add(int[] x, long val) {</b>
<i>1345</i>&nbsp;        int[] y;
<i>1346</i>&nbsp;        long sum = 0;
<b class="nc"><i>1347</i>&nbsp;        int xIndex = x.length;</b>
<b class="nc"><i>1348</i>&nbsp;        int[] result;</b>
<b class="nc"><i>1349</i>&nbsp;        int highWord = (int)(val &gt;&gt;&gt; 32);</b>
<b class="nc"><i>1350</i>&nbsp;        if (highWord == 0) {</b>
<b class="nc"><i>1351</i>&nbsp;            result = new int[xIndex];</b>
<i>1352</i>&nbsp;            sum = (x[--xIndex] &amp; LONG_MASK) + val;
<b class="nc"><i>1353</i>&nbsp;            result[xIndex] = (int)sum;</b>
<i>1354</i>&nbsp;        } else {
<i>1355</i>&nbsp;            if (xIndex == 1) {
<i>1356</i>&nbsp;                result = new int[2];
<b class="nc"><i>1357</i>&nbsp;                sum = val  + (x[0] &amp; LONG_MASK);</b>
<b class="nc"><i>1358</i>&nbsp;                result[1] = (int)sum;</b>
<b class="nc"><i>1359</i>&nbsp;                result[0] = (int)(sum &gt;&gt;&gt; 32);</b>
<b class="nc"><i>1360</i>&nbsp;                return result;</b>
<b class="nc"><i>1361</i>&nbsp;            } else {</b>
<i>1362</i>&nbsp;                result = new int[xIndex];
<b class="nc"><i>1363</i>&nbsp;                sum = (x[--xIndex] &amp; LONG_MASK) + (val &amp; LONG_MASK);</b>
<b class="nc"><i>1364</i>&nbsp;                result[xIndex] = (int)sum;</b>
<b class="nc"><i>1365</i>&nbsp;                sum = (x[--xIndex] &amp; LONG_MASK) + (highWord &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);</b>
<b class="nc"><i>1366</i>&nbsp;                result[xIndex] = (int)sum;</b>
<i>1367</i>&nbsp;            }
<b class="nc"><i>1368</i>&nbsp;        }</b>
<b class="nc"><i>1369</i>&nbsp;        // Copy remainder of longer number while carry propagation is required</b>
<b class="nc"><i>1370</i>&nbsp;        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</b>
<i>1371</i>&nbsp;        while (xIndex &gt; 0 &amp;&amp; carry)
<b class="nc"><i>1372</i>&nbsp;            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</b>
<i>1373</i>&nbsp;        // Copy remainder of longer number
<b class="nc"><i>1374</i>&nbsp;        while (xIndex &gt; 0)</b>
<i>1375</i>&nbsp;            result[--xIndex] = x[xIndex];
<b class="nc"><i>1376</i>&nbsp;        // Grow result if necessary</b>
<b class="nc"><i>1377</i>&nbsp;        if (carry) {</b>
<b class="nc"><i>1378</i>&nbsp;            int bigger[] = new int[result.length + 1];</b>
<b class="nc"><i>1379</i>&nbsp;            System.arraycopy(result, 0, bigger, 1, result.length);</b>
<b class="nc"><i>1380</i>&nbsp;            bigger[0] = 0x01;</b>
<i>1381</i>&nbsp;            return bigger;
<i>1382</i>&nbsp;        }
<i>1383</i>&nbsp;        return result;
<i>1384</i>&nbsp;    }
<i>1385</i>&nbsp;
<i>1386</i>&nbsp;    /**
<i>1387</i>&nbsp;     * Adds the contents of the int arrays x and y. This method allocates
<i>1388</i>&nbsp;     * a new int array to hold the answer and returns a reference to that
<i>1389</i>&nbsp;     * array.
<i>1390</i>&nbsp;     */
<i>1391</i>&nbsp;    private static int[] add(int[] x, int[] y) {
<i>1392</i>&nbsp;        // If x is shorter, swap the two arrays
<b class="nc"><i>1393</i>&nbsp;        if (x.length &lt; y.length) {</b>
<b class="nc"><i>1394</i>&nbsp;            int[] tmp = x;</b>
<b class="nc"><i>1395</i>&nbsp;            x = y;</b>
<b class="nc"><i>1396</i>&nbsp;            y = tmp;</b>
<i>1397</i>&nbsp;        }
<b class="nc"><i>1398</i>&nbsp;</b>
<b class="nc"><i>1399</i>&nbsp;        int xIndex = x.length;</b>
<b class="nc"><i>1400</i>&nbsp;        int yIndex = y.length;</b>
<i>1401</i>&nbsp;        int result[] = new int[xIndex];
<b class="nc"><i>1402</i>&nbsp;        long sum = 0;</b>
<b class="nc"><i>1403</i>&nbsp;        if (yIndex == 1) {</b>
<b class="nc"><i>1404</i>&nbsp;            sum = (x[--xIndex] &amp; LONG_MASK) + (y[0] &amp; LONG_MASK) ;</b>
<b class="nc"><i>1405</i>&nbsp;            result[xIndex] = (int)sum;</b>
<i>1406</i>&nbsp;        } else {
<i>1407</i>&nbsp;            // Add common parts of both numbers
<i>1408</i>&nbsp;            while (yIndex &gt; 0) {
<b class="nc"><i>1409</i>&nbsp;                sum = (x[--xIndex] &amp; LONG_MASK) +</b>
<b class="nc"><i>1410</i>&nbsp;                      (y[--yIndex] &amp; LONG_MASK) + (sum &gt;&gt;&gt; 32);</b>
<b class="nc"><i>1411</i>&nbsp;                result[xIndex] = (int)sum;</b>
<i>1412</i>&nbsp;            }
<i>1413</i>&nbsp;        }
<b class="nc"><i>1414</i>&nbsp;        // Copy remainder of longer number while carry propagation is required</b>
<b class="nc"><i>1415</i>&nbsp;        boolean carry = (sum &gt;&gt;&gt; 32 != 0);</b>
<i>1416</i>&nbsp;        while (xIndex &gt; 0 &amp;&amp; carry)
<b class="nc"><i>1417</i>&nbsp;            carry = ((result[--xIndex] = x[xIndex] + 1) == 0);</b>
<i>1418</i>&nbsp;
<i>1419</i>&nbsp;        // Copy remainder of longer number
<i>1420</i>&nbsp;        while (xIndex &gt; 0)
<i>1421</i>&nbsp;            result[--xIndex] = x[xIndex];
<i>1422</i>&nbsp;
<i>1423</i>&nbsp;        // Grow result if necessary
<i>1424</i>&nbsp;        if (carry) {
<i>1425</i>&nbsp;            int bigger[] = new int[result.length + 1];
<i>1426</i>&nbsp;            System.arraycopy(result, 0, bigger, 1, result.length);
<b class="nc"><i>1427</i>&nbsp;            bigger[0] = 0x01;</b>
<b class="nc"><i>1428</i>&nbsp;            return bigger;</b>
<b class="nc"><i>1429</i>&nbsp;        }</b>
<b class="nc"><i>1430</i>&nbsp;        return result;</b>
<b class="nc"><i>1431</i>&nbsp;    }</b>
<b class="nc"><i>1432</i>&nbsp;</b>
<i>1433</i>&nbsp;    private static int[] subtract(long val, int[] little) {
<b class="nc"><i>1434</i>&nbsp;        int highWord = (int)(val &gt;&gt;&gt; 32);</b>
<b class="nc"><i>1435</i>&nbsp;        if (highWord == 0) {</b>
<b class="nc"><i>1436</i>&nbsp;            int result[] = new int[1];</b>
<b class="nc"><i>1437</i>&nbsp;            result[0] = (int)(val - (little[0] &amp; LONG_MASK));</b>
<b class="nc"><i>1438</i>&nbsp;            return result;</b>
<b class="nc"><i>1439</i>&nbsp;        } else {</b>
<b class="nc"><i>1440</i>&nbsp;            int result[] = new int[2];</b>
<i>1441</i>&nbsp;            if (little.length == 1) {
<i>1442</i>&nbsp;                long difference = ((int)val &amp; LONG_MASK) - (little[0] &amp; LONG_MASK);
<i>1443</i>&nbsp;                result[1] = (int)difference;
<i>1444</i>&nbsp;                // Subtract remainder of longer number while borrow propagates
<i>1445</i>&nbsp;                boolean borrow = (difference &gt;&gt; 32 != 0);
<i>1446</i>&nbsp;                if (borrow) {
<i>1447</i>&nbsp;                    result[0] = highWord - 1;
<i>1448</i>&nbsp;                } else {        // Copy remainder of longer number
<i>1449</i>&nbsp;                    result[0] = highWord;
<b class="nc"><i>1450</i>&nbsp;                }</b>
<b class="nc"><i>1451</i>&nbsp;                return result;</b>
<b class="nc"><i>1452</i>&nbsp;            } else { // little.length == 2</b>
<b class="nc"><i>1453</i>&nbsp;                long difference = ((int)val &amp; LONG_MASK) - (little[1] &amp; LONG_MASK);</b>
<i>1454</i>&nbsp;                result[1] = (int)difference;
<i>1455</i>&nbsp;                difference = (highWord &amp; LONG_MASK) - (little[0] &amp; LONG_MASK) + (difference &gt;&gt; 32);
<b class="nc"><i>1456</i>&nbsp;                result[0] = (int)difference;</b>
<b class="nc"><i>1457</i>&nbsp;                return result;</b>
<i>1458</i>&nbsp;            }
<i>1459</i>&nbsp;        }
<b class="nc"><i>1460</i>&nbsp;    }</b>
<i>1461</i>&nbsp;
<i>1462</i>&nbsp;    /**
<i>1463</i>&nbsp;     * Subtracts the contents of the second argument (val) from the
<b class="nc"><i>1464</i>&nbsp;     * first (big).  The first int array (big) must represent a larger number</b>
<b class="nc"><i>1465</i>&nbsp;     * than the second.  This method allocates the space necessary to hold the</b>
<b class="nc"><i>1466</i>&nbsp;     * answer.</b>
<i>1467</i>&nbsp;     * assumes val &amp;gt;= 0
<i>1468</i>&nbsp;     */
<b class="nc"><i>1469</i>&nbsp;    private static int[] subtract(int[] big, long val) {</b>
<b class="nc"><i>1470</i>&nbsp;        int highWord = (int)(val &gt;&gt;&gt; 32);</b>
<i>1471</i>&nbsp;        int bigIndex = big.length;
<b class="nc"><i>1472</i>&nbsp;        int result[] = new int[bigIndex];</b>
<i>1473</i>&nbsp;        long difference = 0;
<i>1474</i>&nbsp;
<i>1475</i>&nbsp;        if (highWord == 0) {
<i>1476</i>&nbsp;            difference = (big[--bigIndex] &amp; LONG_MASK) - val;
<i>1477</i>&nbsp;            result[bigIndex] = (int)difference;
<i>1478</i>&nbsp;        } else {
<i>1479</i>&nbsp;            difference = (big[--bigIndex] &amp; LONG_MASK) - (val &amp; LONG_MASK);
<i>1480</i>&nbsp;            result[bigIndex] = (int)difference;
<i>1481</i>&nbsp;            difference = (big[--bigIndex] &amp; LONG_MASK) - (highWord &amp; LONG_MASK) + (difference &gt;&gt; 32);
<i>1482</i>&nbsp;            result[bigIndex] = (int)difference;
<i>1483</i>&nbsp;        }
<i>1484</i>&nbsp;
<b class="nc"><i>1485</i>&nbsp;        // Subtract remainder of longer number while borrow propagates</b>
<b class="nc"><i>1486</i>&nbsp;        boolean borrow = (difference &gt;&gt; 32 != 0);</b>
<i>1487</i>&nbsp;        while (bigIndex &gt; 0 &amp;&amp; borrow)
<b class="nc"><i>1488</i>&nbsp;            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);</b>
<i>1489</i>&nbsp;
<b class="nc"><i>1490</i>&nbsp;        // Copy remainder of longer number</b>
<b class="nc"><i>1491</i>&nbsp;        while (bigIndex &gt; 0)</b>
<i>1492</i>&nbsp;            result[--bigIndex] = big[bigIndex];
<i>1493</i>&nbsp;
<b class="nc"><i>1494</i>&nbsp;        return result;</b>
<i>1495</i>&nbsp;    }
<b class="nc"><i>1496</i>&nbsp;</b>
<b class="nc"><i>1497</i>&nbsp;    /**</b>
<b class="nc"><i>1498</i>&nbsp;     * Returns a BigInteger whose value is {@code (this - val)}.</b>
<b class="nc"><i>1499</i>&nbsp;     *</b>
<i>1500</i>&nbsp;     * @param  val value to be subtracted from this BigInteger.
<b class="nc"><i>1501</i>&nbsp;     * @return {@code this - val}</b>
<b class="nc"><i>1502</i>&nbsp;     */</b>
<i>1503</i>&nbsp;    public BigInteger subtract(BigInteger val) {
<b class="nc"><i>1504</i>&nbsp;        if (val.signum == 0)</b>
<i>1505</i>&nbsp;            return this;
<b class="nc"><i>1506</i>&nbsp;        if (signum == 0)</b>
<b class="nc"><i>1507</i>&nbsp;            return val.negate();</b>
<i>1508</i>&nbsp;        if (val.signum != signum)
<b class="nc"><i>1509</i>&nbsp;            return new BigInteger(add(mag, val.mag), signum);</b>
<b class="nc"><i>1510</i>&nbsp;</b>
<i>1511</i>&nbsp;        int cmp = compareMagnitude(val);
<b class="nc"><i>1512</i>&nbsp;        if (cmp == 0)</b>
<i>1513</i>&nbsp;            return ZERO;
<i>1514</i>&nbsp;        int[] resultMag = (cmp &gt; 0 ? subtract(mag, val.mag)
<i>1515</i>&nbsp;                           : subtract(val.mag, mag));
<i>1516</i>&nbsp;        resultMag = trustedStripLeadingZeroInts(resultMag);
<i>1517</i>&nbsp;        return new BigInteger(resultMag, cmp == signum ? 1 : -1);
<b class="nc"><i>1518</i>&nbsp;    }</b>
<b class="nc"><i>1519</i>&nbsp;</b>
<i>1520</i>&nbsp;    /**
<b class="nc"><i>1521</i>&nbsp;     * Subtracts the contents of the second int arrays (little) from the</b>
<b class="nc"><i>1522</i>&nbsp;     * first (big).  The first int array (big) must represent a larger number</b>
<b class="nc"><i>1523</i>&nbsp;     * than the second.  This method allocates the space necessary to hold the</b>
<b class="nc"><i>1524</i>&nbsp;     * answer.</b>
<b class="nc"><i>1525</i>&nbsp;     */</b>
<b class="nc"><i>1526</i>&nbsp;    private static int[] subtract(int[] big, int[] little) {</b>
<b class="nc"><i>1527</i>&nbsp;        int bigIndex = big.length;</b>
<b class="nc"><i>1528</i>&nbsp;        int result[] = new int[bigIndex];</b>
<b class="nc"><i>1529</i>&nbsp;        int littleIndex = little.length;</b>
<i>1530</i>&nbsp;        long difference = 0;
<b class="nc"><i>1531</i>&nbsp;</b>
<b class="nc"><i>1532</i>&nbsp;        // Subtract common parts of both numbers</b>
<i>1533</i>&nbsp;        while (littleIndex &gt; 0) {
<b class="nc"><i>1534</i>&nbsp;            difference = (big[--bigIndex] &amp; LONG_MASK) -</b>
<i>1535</i>&nbsp;                         (little[--littleIndex] &amp; LONG_MASK) +
<b class="nc"><i>1536</i>&nbsp;                         (difference &gt;&gt; 32);</b>
<i>1537</i>&nbsp;            result[bigIndex] = (int)difference;
<i>1538</i>&nbsp;        }
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;        // Subtract remainder of longer number while borrow propagates
<i>1541</i>&nbsp;        boolean borrow = (difference &gt;&gt; 32 != 0);
<i>1542</i>&nbsp;        while (bigIndex &gt; 0 &amp;&amp; borrow)
<i>1543</i>&nbsp;            borrow = ((result[--bigIndex] = big[bigIndex] - 1) == -1);
<b class="nc"><i>1544</i>&nbsp;</b>
<b class="nc"><i>1545</i>&nbsp;        // Copy remainder of longer number</b>
<b class="nc"><i>1546</i>&nbsp;        while (bigIndex &gt; 0)</b>
<b class="nc"><i>1547</i>&nbsp;            result[--bigIndex] = big[bigIndex];</b>
<b class="nc"><i>1548</i>&nbsp;</b>
<b class="nc"><i>1549</i>&nbsp;        return result;</b>
<b class="nc"><i>1550</i>&nbsp;    }</b>
<b class="nc"><i>1551</i>&nbsp;</b>
<b class="nc"><i>1552</i>&nbsp;    /**</b>
<i>1553</i>&nbsp;     * Returns a BigInteger whose value is {@code (this * val)}.
<b class="nc"><i>1554</i>&nbsp;     *</b>
<b class="nc"><i>1555</i>&nbsp;     * @implNote An implementation may offer better algorithmic</b>
<b class="nc"><i>1556</i>&nbsp;     * performance when {@code val == this}.</b>
<b class="nc"><i>1557</i>&nbsp;     *</b>
<b class="nc"><i>1558</i>&nbsp;     * @param  val value to be multiplied by this BigInteger.</b>
<b class="nc"><i>1559</i>&nbsp;     * @return {@code this * val}</b>
<b class="nc"><i>1560</i>&nbsp;     */</b>
<b class="nc"><i>1561</i>&nbsp;    public BigInteger multiply(BigInteger val) {</b>
<b class="nc"><i>1562</i>&nbsp;        if (val.signum == 0 || signum == 0)</b>
<i>1563</i>&nbsp;            return ZERO;
<b class="nc"><i>1564</i>&nbsp;</b>
<b class="nc"><i>1565</i>&nbsp;        int xlen = mag.length;</b>
<b class="nc"><i>1566</i>&nbsp;</b>
<b class="nc"><i>1567</i>&nbsp;        if (val == this &amp;&amp; xlen &gt; MULTIPLY_SQUARE_THRESHOLD) {</b>
<b class="nc"><i>1568</i>&nbsp;            return square();</b>
<b class="nc"><i>1569</i>&nbsp;        }</b>
<i>1570</i>&nbsp;
<b class="nc"><i>1571</i>&nbsp;        int ylen = val.mag.length;</b>
<b class="nc"><i>1572</i>&nbsp;</b>
<i>1573</i>&nbsp;        if ((xlen &lt; KARATSUBA_THRESHOLD) || (ylen &lt; KARATSUBA_THRESHOLD)) {
<b class="nc"><i>1574</i>&nbsp;            int resultSign = signum == val.signum ? 1 : -1;</b>
<i>1575</i>&nbsp;            if (val.mag.length == 1) {
<b class="nc"><i>1576</i>&nbsp;                return multiplyByInt(mag,val.mag[0], resultSign);</b>
<b class="nc"><i>1577</i>&nbsp;            }</b>
<b class="nc"><i>1578</i>&nbsp;            if (mag.length == 1) {</b>
<i>1579</i>&nbsp;                return multiplyByInt(val.mag,mag[0], resultSign);
<i>1580</i>&nbsp;            }
<i>1581</i>&nbsp;            int[] result = multiplyToLen(mag, xlen,
<i>1582</i>&nbsp;                                         val.mag, ylen, null);
<i>1583</i>&nbsp;            result = trustedStripLeadingZeroInts(result);
<i>1584</i>&nbsp;            return new BigInteger(result, resultSign);
<i>1585</i>&nbsp;        } else {
<b class="nc"><i>1586</i>&nbsp;            if ((xlen &lt; TOOM_COOK_THRESHOLD) &amp;&amp; (ylen &lt; TOOM_COOK_THRESHOLD)) {</b>
<b class="nc"><i>1587</i>&nbsp;                return multiplyKaratsuba(this, val);</b>
<i>1588</i>&nbsp;            } else {
<b class="nc"><i>1589</i>&nbsp;                return multiplyToomCook3(this, val);</b>
<b class="nc"><i>1590</i>&nbsp;            }</b>
<i>1591</i>&nbsp;        }
<b class="nc"><i>1592</i>&nbsp;    }</b>
<b class="nc"><i>1593</i>&nbsp;</b>
<b class="nc"><i>1594</i>&nbsp;    private static BigInteger multiplyByInt(int[] x, int y, int sign) {</b>
<i>1595</i>&nbsp;        if (Integer.bitCount(y) == 1) {
<b class="nc"><i>1596</i>&nbsp;            return new BigInteger(shiftLeft(x,Integer.numberOfTrailingZeros(y)), sign);</b>
<b class="nc"><i>1597</i>&nbsp;        }</b>
<i>1598</i>&nbsp;        int xlen = x.length;
<b class="nc"><i>1599</i>&nbsp;        int[] rmag =  new int[xlen + 1];</b>
<i>1600</i>&nbsp;        long carry = 0;
<b class="nc"><i>1601</i>&nbsp;        long yl = y &amp; LONG_MASK;</b>
<b class="nc"><i>1602</i>&nbsp;        int rstart = rmag.length - 1;</b>
<b class="nc"><i>1603</i>&nbsp;        for (int i = xlen - 1; i &gt;= 0; i--) {</b>
<b class="nc"><i>1604</i>&nbsp;            long product = (x[i] &amp; LONG_MASK) * yl + carry;</b>
<i>1605</i>&nbsp;            rmag[rstart--] = (int)product;
<i>1606</i>&nbsp;            carry = product &gt;&gt;&gt; 32;
<b class="nc"><i>1607</i>&nbsp;        }</b>
<b class="nc"><i>1608</i>&nbsp;        if (carry == 0L) {</b>
<i>1609</i>&nbsp;            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);
<b class="nc"><i>1610</i>&nbsp;        } else {</b>
<i>1611</i>&nbsp;            rmag[rstart] = (int)carry;
<b class="nc"><i>1612</i>&nbsp;        }</b>
<i>1613</i>&nbsp;        return new BigInteger(rmag, sign);
<i>1614</i>&nbsp;    }
<i>1615</i>&nbsp;
<i>1616</i>&nbsp;    /**
<i>1617</i>&nbsp;     * Package private methods used by BigDecimal code to multiply a BigInteger
<i>1618</i>&nbsp;     * with a long. Assumes v is not equal to INFLATED.
<i>1619</i>&nbsp;     */
<i>1620</i>&nbsp;    BigInteger multiply(long v) {
<i>1621</i>&nbsp;        if (v == 0 || signum == 0)
<i>1622</i>&nbsp;          return ZERO;
<i>1623</i>&nbsp;        if (v == BigDecimal.INFLATED)
<i>1624</i>&nbsp;            return multiply(BigInteger.valueOf(v));
<i>1625</i>&nbsp;        int rsign = (v &gt; 0 ? signum : -signum);
<i>1626</i>&nbsp;        if (v &lt; 0)
<i>1627</i>&nbsp;            v = -v;
<i>1628</i>&nbsp;        long dh = v &gt;&gt;&gt; 32;      // higher order bits
<i>1629</i>&nbsp;        long dl = v &amp; LONG_MASK; // lower order bits
<i>1630</i>&nbsp;
<b class="nc"><i>1631</i>&nbsp;        int xlen = mag.length;</b>
<b class="nc"><i>1632</i>&nbsp;        int[] value = mag;</b>
<i>1633</i>&nbsp;        int[] rmag = (dh == 0L) ? (new int[xlen + 1]) : (new int[xlen + 2]);
<i>1634</i>&nbsp;        long carry = 0;
<b class="nc"><i>1635</i>&nbsp;        int rstart = rmag.length - 1;</b>
<i>1636</i>&nbsp;        for (int i = xlen - 1; i &gt;= 0; i--) {
<i>1637</i>&nbsp;            long product = (value[i] &amp; LONG_MASK) * dl + carry;
<i>1638</i>&nbsp;            rmag[rstart--] = (int)product;
<b class="nc"><i>1639</i>&nbsp;            carry = product &gt;&gt;&gt; 32;</b>
<b class="nc"><i>1640</i>&nbsp;        }</b>
<b class="nc"><i>1641</i>&nbsp;        rmag[rstart] = (int)carry;</b>
<b class="nc"><i>1642</i>&nbsp;        if (dh != 0L) {</b>
<i>1643</i>&nbsp;            carry = 0;
<b class="nc"><i>1644</i>&nbsp;            rstart = rmag.length - 2;</b>
<b class="nc"><i>1645</i>&nbsp;            for (int i = xlen - 1; i &gt;= 0; i--) {</b>
<i>1646</i>&nbsp;                long product = (value[i] &amp; LONG_MASK) * dh +
<i>1647</i>&nbsp;                    (rmag[rstart] &amp; LONG_MASK) + carry;
<b class="nc"><i>1648</i>&nbsp;                rmag[rstart--] = (int)product;</b>
<i>1649</i>&nbsp;                carry = product &gt;&gt;&gt; 32;
<i>1650</i>&nbsp;            }
<b class="nc"><i>1651</i>&nbsp;            rmag[0] = (int)carry;</b>
<i>1652</i>&nbsp;        }
<b class="nc"><i>1653</i>&nbsp;        if (carry == 0L)</b>
<b class="nc"><i>1654</i>&nbsp;            rmag = java.util.Arrays.copyOfRange(rmag, 1, rmag.length);</b>
<i>1655</i>&nbsp;        return new BigInteger(rmag, rsign);
<b class="nc"><i>1656</i>&nbsp;    }</b>
<i>1657</i>&nbsp;
<i>1658</i>&nbsp;    /**
<i>1659</i>&nbsp;     * Multiplies int arrays x and y to the specified lengths and places
<i>1660</i>&nbsp;     * the result into z. There will be no leading zeros in the resultant array.
<i>1661</i>&nbsp;     */
<i>1662</i>&nbsp;    private static int[] multiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
<i>1663</i>&nbsp;        multiplyToLenCheck(x, xlen);
<i>1664</i>&nbsp;        multiplyToLenCheck(y, ylen);
<i>1665</i>&nbsp;        return implMultiplyToLen(x, xlen, y, ylen, z);
<i>1666</i>&nbsp;    }
<i>1667</i>&nbsp;
<i>1668</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>1669</i>&nbsp;    private static int[] implMultiplyToLen(int[] x, int xlen, int[] y, int ylen, int[] z) {
<i>1670</i>&nbsp;        int xstart = xlen - 1;
<i>1671</i>&nbsp;        int ystart = ylen - 1;
<i>1672</i>&nbsp;
<i>1673</i>&nbsp;        if (z == null || z.length &lt; (xlen+ ylen))
<i>1674</i>&nbsp;            z = new int[xlen+ylen];
<i>1675</i>&nbsp;
<i>1676</i>&nbsp;        long carry = 0;
<i>1677</i>&nbsp;        for (int j=ystart, k=ystart+1+xstart; j &gt;= 0; j--, k--) {
<i>1678</i>&nbsp;            long product = (y[j] &amp; LONG_MASK) *
<i>1679</i>&nbsp;                           (x[xstart] &amp; LONG_MASK) + carry;
<i>1680</i>&nbsp;            z[k] = (int)product;
<i>1681</i>&nbsp;            carry = product &gt;&gt;&gt; 32;
<i>1682</i>&nbsp;        }
<i>1683</i>&nbsp;        z[xstart] = (int)carry;
<i>1684</i>&nbsp;
<i>1685</i>&nbsp;        for (int i = xstart-1; i &gt;= 0; i--) {
<i>1686</i>&nbsp;            carry = 0;
<i>1687</i>&nbsp;            for (int j=ystart, k=ystart+1+i; j &gt;= 0; j--, k--) {
<i>1688</i>&nbsp;                long product = (y[j] &amp; LONG_MASK) *
<b class="nc"><i>1689</i>&nbsp;                               (x[i] &amp; LONG_MASK) +</b>
<b class="nc"><i>1690</i>&nbsp;                               (z[k] &amp; LONG_MASK) + carry;</b>
<i>1691</i>&nbsp;                z[k] = (int)product;
<b class="nc"><i>1692</i>&nbsp;                carry = product &gt;&gt;&gt; 32;</b>
<i>1693</i>&nbsp;            }
<i>1694</i>&nbsp;            z[i] = (int)carry;
<b class="nc"><i>1695</i>&nbsp;        }</b>
<i>1696</i>&nbsp;        return z;
<i>1697</i>&nbsp;    }
<b class="nc"><i>1698</i>&nbsp;</b>
<i>1699</i>&nbsp;    private static void multiplyToLenCheck(int[] array, int length) {
<i>1700</i>&nbsp;        if (length &lt;= 0) {
<i>1701</i>&nbsp;            return;  // not an error because multiplyToLen won&#39;t execute if len &lt;= 0
<i>1702</i>&nbsp;        }
<b class="nc"><i>1703</i>&nbsp;</b>
<b class="nc"><i>1704</i>&nbsp;        Objects.requireNonNull(array);</b>
<b class="nc"><i>1705</i>&nbsp;</b>
<b class="nc"><i>1706</i>&nbsp;        if (length &gt; array.length) {</b>
<b class="nc"><i>1707</i>&nbsp;            throw new ArrayIndexOutOfBoundsException(length - 1);</b>
<b class="nc"><i>1708</i>&nbsp;        }</b>
<i>1709</i>&nbsp;    }
<i>1710</i>&nbsp;
<i>1711</i>&nbsp;    /**
<b class="nc"><i>1712</i>&nbsp;     * Multiplies two BigIntegers using the Karatsuba multiplication</b>
<b class="nc"><i>1713</i>&nbsp;     * algorithm.  This is a recursive divide-and-conquer algorithm which is</b>
<b class="nc"><i>1714</i>&nbsp;     * more efficient for large numbers than what is commonly called the</b>
<b class="nc"><i>1715</i>&nbsp;     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be</b>
<b class="nc"><i>1716</i>&nbsp;     * multiplied have length n, the &quot;grade-school&quot; algorithm has an</b>
<b class="nc"><i>1717</i>&nbsp;     * asymptotic complexity of O(n^2).  In contrast, the Karatsuba algorithm</b>
<b class="nc"><i>1718</i>&nbsp;     * has complexity of O(n^(log2(3))), or O(n^1.585).  It achieves this</b>
<b class="nc"><i>1719</i>&nbsp;     * increased performance by doing 3 multiplies instead of 4 when</b>
<b class="nc"><i>1720</i>&nbsp;     * evaluating the product.  As it has some overhead, should be used when</b>
<b class="nc"><i>1721</i>&nbsp;     * both numbers are larger than a certain threshold (found</b>
<i>1722</i>&nbsp;     * experimentally).
<i>1723</i>&nbsp;     *
<i>1724</i>&nbsp;     * See:  http://en.wikipedia.org/wiki/Karatsuba_algorithm
<i>1725</i>&nbsp;     */
<i>1726</i>&nbsp;    private static BigInteger multiplyKaratsuba(BigInteger x, BigInteger y) {
<i>1727</i>&nbsp;        int xlen = x.mag.length;
<i>1728</i>&nbsp;        int ylen = y.mag.length;
<b class="nc"><i>1729</i>&nbsp;</b>
<b class="nc"><i>1730</i>&nbsp;        // The number of ints in each half of the number.</b>
<b class="nc"><i>1731</i>&nbsp;        int half = (Math.max(xlen, ylen)+1) / 2;</b>
<b class="nc"><i>1732</i>&nbsp;</b>
<b class="nc"><i>1733</i>&nbsp;        // xl and yl are the lower halves of x and y respectively,</b>
<b class="nc"><i>1734</i>&nbsp;        // xh and yh are the upper halves.</b>
<b class="nc"><i>1735</i>&nbsp;        BigInteger xl = x.getLower(half);</b>
<i>1736</i>&nbsp;        BigInteger xh = x.getUpper(half);
<i>1737</i>&nbsp;        BigInteger yl = y.getLower(half);
<b class="nc"><i>1738</i>&nbsp;        BigInteger yh = y.getUpper(half);</b>
<i>1739</i>&nbsp;
<b class="nc"><i>1740</i>&nbsp;        BigInteger p1 = xh.multiply(yh);  // p1 = xh*yh</b>
<i>1741</i>&nbsp;        BigInteger p2 = xl.multiply(yl);  // p2 = xl*yl
<b class="nc"><i>1742</i>&nbsp;</b>
<b class="nc"><i>1743</i>&nbsp;        // p3=(xh+xl)*(yh+yl)</b>
<i>1744</i>&nbsp;        BigInteger p3 = xh.add(xl).multiply(yh.add(yl));
<b class="nc"><i>1745</i>&nbsp;</b>
<i>1746</i>&nbsp;        // result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*half) + p2
<i>1747</i>&nbsp;        BigInteger result = p1.shiftLeft(32*half).add(p3.subtract(p1).subtract(p2)).shiftLeft(32*half).add(p2);
<i>1748</i>&nbsp;
<i>1749</i>&nbsp;        if (x.signum != y.signum) {
<i>1750</i>&nbsp;            return result.negate();
<i>1751</i>&nbsp;        } else {
<i>1752</i>&nbsp;            return result;
<i>1753</i>&nbsp;        }
<i>1754</i>&nbsp;    }
<i>1755</i>&nbsp;
<i>1756</i>&nbsp;    /**
<i>1757</i>&nbsp;     * Multiplies two BigIntegers using a 3-way Toom-Cook multiplication
<i>1758</i>&nbsp;     * algorithm.  This is a recursive divide-and-conquer algorithm which is
<i>1759</i>&nbsp;     * more efficient for large numbers than what is commonly called the
<i>1760</i>&nbsp;     * &quot;grade-school&quot; algorithm used in multiplyToLen.  If the numbers to be
<i>1761</i>&nbsp;     * multiplied have length n, the &quot;grade-school&quot; algorithm has an
<i>1762</i>&nbsp;     * asymptotic complexity of O(n^2).  In contrast, 3-way Toom-Cook has a
<i>1763</i>&nbsp;     * complexity of about O(n^1.465).  It achieves this increased asymptotic
<i>1764</i>&nbsp;     * performance by breaking each number into three parts and by doing 5
<i>1765</i>&nbsp;     * multiplies instead of 9 when evaluating the product.  Due to overhead
<i>1766</i>&nbsp;     * (additions, shifts, and one division) in the Toom-Cook algorithm, it
<b class="nc"><i>1767</i>&nbsp;     * should only be used when both numbers are larger than a certain</b>
<b class="nc"><i>1768</i>&nbsp;     * threshold (found experimentally).  This threshold is generally larger</b>
<i>1769</i>&nbsp;     * than that for Karatsuba multiplication, so this algorithm is generally
<b class="nc"><i>1770</i>&nbsp;     * only used when numbers become significantly larger.</b>
<b class="nc"><i>1771</i>&nbsp;     *</b>
<b class="nc"><i>1772</i>&nbsp;     * The algorithm used is the &quot;optimal&quot; 3-way Toom-Cook algorithm outlined</b>
<i>1773</i>&nbsp;     * by Marco Bodrato.
<b class="nc"><i>1774</i>&nbsp;     *</b>
<b class="nc"><i>1775</i>&nbsp;     *  See: http://bodrato.it/toom-cook/</b>
<i>1776</i>&nbsp;     *       http://bodrato.it/papers/#WAIFI2007
<i>1777</i>&nbsp;     *
<b class="nc"><i>1778</i>&nbsp;     * &quot;Towards Optimal Toom-Cook Multiplication for Univariate and</b>
<b class="nc"><i>1779</i>&nbsp;     * Multivariate Polynomials in Characteristic 2 and 0.&quot; by Marco BODRATO;</b>
<i>1780</i>&nbsp;     * In C.Carlet and B.Sunar, Eds., &quot;WAIFI&#39;07 proceedings&quot;, p. 116-133,
<b class="nc"><i>1781</i>&nbsp;     * LNCS #4547. Springer, Madrid, Spain, June 21-22, 2007.</b>
<b class="nc"><i>1782</i>&nbsp;     *</b>
<i>1783</i>&nbsp;     */
<i>1784</i>&nbsp;    private static BigInteger multiplyToomCook3(BigInteger a, BigInteger b) {
<b class="nc"><i>1785</i>&nbsp;        int alen = a.mag.length;</b>
<i>1786</i>&nbsp;        int blen = b.mag.length;
<b class="nc"><i>1787</i>&nbsp;</b>
<b class="nc"><i>1788</i>&nbsp;        int largest = Math.max(alen, blen);</b>
<i>1789</i>&nbsp;
<i>1790</i>&nbsp;        // k is the size (in ints) of the lower-order slices.
<i>1791</i>&nbsp;        int k = (largest+2)/3;   // Equal to ceil(largest/3)
<i>1792</i>&nbsp;
<b class="nc"><i>1793</i>&nbsp;        // r is the size (in ints) of the highest-order slice.</b>
<b class="nc"><i>1794</i>&nbsp;        int r = largest - 2*k;</b>
<i>1795</i>&nbsp;
<i>1796</i>&nbsp;        // Obtain slices of the numbers. a2 and b2 are the most significant
<b class="nc"><i>1797</i>&nbsp;        // bits of the numbers a and b, and a0 and b0 the least significant.</b>
<b class="nc"><i>1798</i>&nbsp;        BigInteger a0, a1, a2, b0, b1, b2;</b>
<i>1799</i>&nbsp;        a2 = a.getToomSlice(k, r, 0, largest);
<b class="nc"><i>1800</i>&nbsp;        a1 = a.getToomSlice(k, r, 1, largest);</b>
<i>1801</i>&nbsp;        a0 = a.getToomSlice(k, r, 2, largest);
<i>1802</i>&nbsp;        b2 = b.getToomSlice(k, r, 0, largest);
<i>1803</i>&nbsp;        b1 = b.getToomSlice(k, r, 1, largest);
<i>1804</i>&nbsp;        b0 = b.getToomSlice(k, r, 2, largest);
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1, db1;
<i>1807</i>&nbsp;
<i>1808</i>&nbsp;        v0 = a0.multiply(b0);
<i>1809</i>&nbsp;        da1 = a2.add(a0);
<i>1810</i>&nbsp;        db1 = b2.add(b0);
<i>1811</i>&nbsp;        vm1 = da1.subtract(a1).multiply(db1.subtract(b1));
<b class="nc"><i>1812</i>&nbsp;        da1 = da1.add(a1);</b>
<b class="nc"><i>1813</i>&nbsp;        db1 = db1.add(b1);</b>
<i>1814</i>&nbsp;        v1 = da1.multiply(db1);
<b class="nc"><i>1815</i>&nbsp;        v2 = da1.add(a2).shiftLeft(1).subtract(a0).multiply(</b>
<b class="nc"><i>1816</i>&nbsp;             db1.add(b2).shiftLeft(1).subtract(b0));</b>
<b class="nc"><i>1817</i>&nbsp;        vinf = a2.multiply(b2);</b>
<b class="nc"><i>1818</i>&nbsp;</b>
<b class="nc"><i>1819</i>&nbsp;        // The algorithm requires two divisions by 2 and one by 3.</b>
<b class="nc"><i>1820</i>&nbsp;        // All divisions are known to be exact, that is, they do not produce</b>
<i>1821</i>&nbsp;        // remainders, and all results are positive.  The divisions by 2 are
<b class="nc"><i>1822</i>&nbsp;        // implemented as right shifts which are relatively efficient, leaving</b>
<i>1823</i>&nbsp;        // only an exact division by 3, which is done by a specialized
<i>1824</i>&nbsp;        // linear-time algorithm.
<i>1825</i>&nbsp;        t2 = v2.subtract(vm1).exactDivideBy3();
<i>1826</i>&nbsp;        tm1 = v1.subtract(vm1).shiftRight(1);
<i>1827</i>&nbsp;        t1 = v1.subtract(v0);
<b class="nc"><i>1828</i>&nbsp;        t2 = t2.subtract(t1).shiftRight(1);</b>
<b class="nc"><i>1829</i>&nbsp;        t1 = t1.subtract(tm1).subtract(vinf);</b>
<i>1830</i>&nbsp;        t2 = t2.subtract(vinf.shiftLeft(1));
<i>1831</i>&nbsp;        tm1 = tm1.subtract(t2);
<i>1832</i>&nbsp;
<b class="nc"><i>1833</i>&nbsp;        // Number of bits to shift left.</b>
<b class="nc"><i>1834</i>&nbsp;        int ss = k*32;</b>
<b class="nc"><i>1835</i>&nbsp;</b>
<b class="nc"><i>1836</i>&nbsp;        BigInteger result = vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);</b>
<i>1837</i>&nbsp;
<i>1838</i>&nbsp;        if (a.signum != b.signum) {
<b class="nc"><i>1839</i>&nbsp;            return result.negate();</b>
<b class="nc"><i>1840</i>&nbsp;        } else {</b>
<i>1841</i>&nbsp;            return result;
<i>1842</i>&nbsp;        }
<i>1843</i>&nbsp;    }
<i>1844</i>&nbsp;
<i>1845</i>&nbsp;
<i>1846</i>&nbsp;    /**
<i>1847</i>&nbsp;     * Returns a slice of a BigInteger for use in Toom-Cook multiplication.
<b class="nc"><i>1848</i>&nbsp;     *</b>
<i>1849</i>&nbsp;     * @param lowerSize The size of the lower-order bit slices.
<b class="nc"><i>1850</i>&nbsp;     * @param upperSize The size of the higher-order bit slices.</b>
<b class="nc"><i>1851</i>&nbsp;     * @param slice The index of which slice is requested, which must be a</b>
<i>1852</i>&nbsp;     * number from 0 to size-1. Slice 0 is the highest-order bits, and slice
<i>1853</i>&nbsp;     * size-1 are the lowest-order bits. Slice 0 may be of different size than
<b class="nc"><i>1854</i>&nbsp;     * the other slices.</b>
<b class="nc"><i>1855</i>&nbsp;     * @param fullsize The size of the larger integer array, used to align</b>
<i>1856</i>&nbsp;     * slices to the appropriate position when multiplying different-sized
<b class="nc"><i>1857</i>&nbsp;     * numbers.</b>
<i>1858</i>&nbsp;     */
<i>1859</i>&nbsp;    private BigInteger getToomSlice(int lowerSize, int upperSize, int slice,
<i>1860</i>&nbsp;                                    int fullsize) {
<i>1861</i>&nbsp;        int start, end, sliceSize, len, offset;
<i>1862</i>&nbsp;
<i>1863</i>&nbsp;        len = mag.length;
<i>1864</i>&nbsp;        offset = fullsize - len;
<i>1865</i>&nbsp;
<b class="nc"><i>1866</i>&nbsp;        if (slice == 0) {</b>
<i>1867</i>&nbsp;            start = 0 - offset;
<b class="nc"><i>1868</i>&nbsp;            end = upperSize - 1 - offset;</b>
<b class="nc"><i>1869</i>&nbsp;        } else {</b>
<i>1870</i>&nbsp;            start = upperSize + (slice-1)*lowerSize - offset;
<i>1871</i>&nbsp;            end = start + lowerSize - 1;
<b class="nc"><i>1872</i>&nbsp;        }</b>
<b class="nc"><i>1873</i>&nbsp;</b>
<b class="nc"><i>1874</i>&nbsp;        if (start &lt; 0) {</b>
<i>1875</i>&nbsp;            start = 0;
<b class="nc"><i>1876</i>&nbsp;        }</b>
<i>1877</i>&nbsp;        if (end &lt; 0) {
<i>1878</i>&nbsp;           return ZERO;
<i>1879</i>&nbsp;        }
<i>1880</i>&nbsp;
<i>1881</i>&nbsp;        sliceSize = (end-start) + 1;
<i>1882</i>&nbsp;
<i>1883</i>&nbsp;        if (sliceSize &lt;= 0) {
<i>1884</i>&nbsp;            return ZERO;
<i>1885</i>&nbsp;        }
<i>1886</i>&nbsp;
<b class="nc"><i>1887</i>&nbsp;        // While performing Toom-Cook, all slices are positive and</b>
<b class="nc"><i>1888</i>&nbsp;        // the sign is adjusted when the final number is composed.</b>
<i>1889</i>&nbsp;        if (start == 0 &amp;&amp; sliceSize &gt;= len) {
<b class="nc"><i>1890</i>&nbsp;            return this.abs();</b>
<i>1891</i>&nbsp;        }
<b class="nc"><i>1892</i>&nbsp;</b>
<b class="nc"><i>1893</i>&nbsp;        int intSlice[] = new int[sliceSize];</b>
<b class="nc"><i>1894</i>&nbsp;        System.arraycopy(mag, start, intSlice, 0, sliceSize);</b>
<i>1895</i>&nbsp;
<b class="nc"><i>1896</i>&nbsp;        return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);</b>
<b class="nc"><i>1897</i>&nbsp;    }</b>
<i>1898</i>&nbsp;
<b class="nc"><i>1899</i>&nbsp;    /**</b>
<i>1900</i>&nbsp;     * Does an exact division (that is, the remainder is known to be zero)
<i>1901</i>&nbsp;     * of the specified number by 3.  This is used in Toom-Cook
<i>1902</i>&nbsp;     * multiplication.  This is an efficient algorithm that runs in linear
<i>1903</i>&nbsp;     * time.  If the argument is not exactly divisible by 3, results are
<i>1904</i>&nbsp;     * undefined.  Note that this is expected to be called with positive
<i>1905</i>&nbsp;     * arguments only.
<i>1906</i>&nbsp;     */
<i>1907</i>&nbsp;    private BigInteger exactDivideBy3() {
<i>1908</i>&nbsp;        int len = mag.length;
<b class="nc"><i>1909</i>&nbsp;        int[] result = new int[len];</b>
<b class="nc"><i>1910</i>&nbsp;        long x, w, q, borrow;</b>
<b class="nc"><i>1911</i>&nbsp;        borrow = 0L;</b>
<i>1912</i>&nbsp;        for (int i=len-1; i &gt;= 0; i--) {
<i>1913</i>&nbsp;            x = (mag[i] &amp; LONG_MASK);
<b class="nc"><i>1914</i>&nbsp;            w = x - borrow;</b>
<b class="nc"><i>1915</i>&nbsp;            if (borrow &gt; x) {      // Did we make the number go negative?</b>
<i>1916</i>&nbsp;                borrow = 1L;
<i>1917</i>&nbsp;            } else {
<i>1918</i>&nbsp;                borrow = 0L;
<i>1919</i>&nbsp;            }
<i>1920</i>&nbsp;
<i>1921</i>&nbsp;            // 0xAAAAAAAB is the modular inverse of 3 (mod 2^32).  Thus,
<b class="nc"><i>1922</i>&nbsp;            // the effect of this is to divide by 3 (mod 2^32).</b>
<b class="nc"><i>1923</i>&nbsp;            // This is much faster than division on most architectures.</b>
<i>1924</i>&nbsp;            q = (w * 0xAAAAAAABL) &amp; LONG_MASK;
<b class="nc"><i>1925</i>&nbsp;            result[i] = (int) q;</b>
<b class="nc"><i>1926</i>&nbsp;</b>
<i>1927</i>&nbsp;            // Now check the borrow. The second check can of course be
<i>1928</i>&nbsp;            // eliminated if the first fails.
<b class="nc"><i>1929</i>&nbsp;            if (q &gt;= 0x55555556L) {</b>
<b class="nc"><i>1930</i>&nbsp;                borrow++;</b>
<i>1931</i>&nbsp;                if (q &gt;= 0xAAAAAAABL)
<i>1932</i>&nbsp;                    borrow++;
<b class="nc"><i>1933</i>&nbsp;            }</b>
<b class="nc"><i>1934</i>&nbsp;        }</b>
<i>1935</i>&nbsp;        result = trustedStripLeadingZeroInts(result);
<b class="nc"><i>1936</i>&nbsp;        return new BigInteger(result, signum);</b>
<b class="nc"><i>1937</i>&nbsp;    }</b>
<i>1938</i>&nbsp;
<i>1939</i>&nbsp;    /**
<i>1940</i>&nbsp;     * Returns a new BigInteger representing n lower ints of the number.
<i>1941</i>&nbsp;     * This is used by Karatsuba multiplication and Karatsuba squaring.
<i>1942</i>&nbsp;     */
<i>1943</i>&nbsp;    private BigInteger getLower(int n) {
<i>1944</i>&nbsp;        int len = mag.length;
<i>1945</i>&nbsp;
<i>1946</i>&nbsp;        if (len &lt;= n) {
<i>1947</i>&nbsp;            return abs();
<i>1948</i>&nbsp;        }
<i>1949</i>&nbsp;
<i>1950</i>&nbsp;        int lowerInts[] = new int[n];
<i>1951</i>&nbsp;        System.arraycopy(mag, len-n, lowerInts, 0, n);
<i>1952</i>&nbsp;
<i>1953</i>&nbsp;        return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);
<i>1954</i>&nbsp;    }
<i>1955</i>&nbsp;
<i>1956</i>&nbsp;    /**
<i>1957</i>&nbsp;     * Returns a new BigInteger representing mag.length-n upper
<i>1958</i>&nbsp;     * ints of the number.  This is used by Karatsuba multiplication and
<i>1959</i>&nbsp;     * Karatsuba squaring.
<i>1960</i>&nbsp;     */
<i>1961</i>&nbsp;    private BigInteger getUpper(int n) {
<i>1962</i>&nbsp;        int len = mag.length;
<i>1963</i>&nbsp;
<i>1964</i>&nbsp;        if (len &lt;= n) {
<i>1965</i>&nbsp;            return ZERO;
<i>1966</i>&nbsp;        }
<i>1967</i>&nbsp;
<i>1968</i>&nbsp;        int upperLen = len - n;
<i>1969</i>&nbsp;        int upperInts[] = new int[upperLen];
<i>1970</i>&nbsp;        System.arraycopy(mag, 0, upperInts, 0, upperLen);
<i>1971</i>&nbsp;
<i>1972</i>&nbsp;        return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);
<i>1973</i>&nbsp;    }
<i>1974</i>&nbsp;
<i>1975</i>&nbsp;    // Squaring
<i>1976</i>&nbsp;
<i>1977</i>&nbsp;    /**
<i>1978</i>&nbsp;     * Returns a BigInteger whose value is {@code (this&lt;sup&gt;2&lt;/sup&gt;)}.
<i>1979</i>&nbsp;     *
<i>1980</i>&nbsp;     * @return {@code this&lt;sup&gt;2&lt;/sup&gt;}
<i>1981</i>&nbsp;     */
<b class="nc"><i>1982</i>&nbsp;    private BigInteger square() {</b>
<b class="nc"><i>1983</i>&nbsp;        if (signum == 0) {</b>
<b class="nc"><i>1984</i>&nbsp;            return ZERO;</b>
<b class="nc"><i>1985</i>&nbsp;        }</b>
<b class="nc"><i>1986</i>&nbsp;        int len = mag.length;</b>
<b class="nc"><i>1987</i>&nbsp;</b>
<b class="nc"><i>1988</i>&nbsp;        if (len &lt; KARATSUBA_SQUARE_THRESHOLD) {</b>
<i>1989</i>&nbsp;            int[] z = squareToLen(mag, len, null);
<i>1990</i>&nbsp;            return new BigInteger(trustedStripLeadingZeroInts(z), 1);
<i>1991</i>&nbsp;        } else {
<b class="nc"><i>1992</i>&nbsp;            if (len &lt; TOOM_COOK_SQUARE_THRESHOLD) {</b>
<b class="nc"><i>1993</i>&nbsp;                return squareKaratsuba();</b>
<b class="nc"><i>1994</i>&nbsp;            } else {</b>
<b class="nc"><i>1995</i>&nbsp;                return squareToomCook3();</b>
<i>1996</i>&nbsp;            }
<i>1997</i>&nbsp;        }
<i>1998</i>&nbsp;    }
<b class="nc"><i>1999</i>&nbsp;</b>
<b class="nc"><i>2000</i>&nbsp;    /**</b>
<i>2001</i>&nbsp;     * Squares the contents of the int array x. The result is placed into the
<b class="nc"><i>2002</i>&nbsp;     * int array z.  The contents of x are not changed.</b>
<i>2003</i>&nbsp;     */
<i>2004</i>&nbsp;    private static final int[] squareToLen(int[] x, int len, int[] z) {
<i>2005</i>&nbsp;         int zlen = len &lt;&lt; 1;
<i>2006</i>&nbsp;         if (z == null || z.length &lt; zlen)
<i>2007</i>&nbsp;             z = new int[zlen];
<i>2008</i>&nbsp;
<i>2009</i>&nbsp;         // Execute checks before calling intrinsified method.
<i>2010</i>&nbsp;         implSquareToLenChecks(x, len, z, zlen);
<i>2011</i>&nbsp;         return implSquareToLen(x, len, z, zlen);
<i>2012</i>&nbsp;     }
<b class="nc"><i>2013</i>&nbsp;</b>
<i>2014</i>&nbsp;     /**
<b class="nc"><i>2015</i>&nbsp;      * Parameters validation.</b>
<b class="nc"><i>2016</i>&nbsp;      */</b>
<i>2017</i>&nbsp;     private static void implSquareToLenChecks(int[] x, int len, int[] z, int zlen) throws RuntimeException {
<b class="nc"><i>2018</i>&nbsp;         if (len &lt; 1) {</b>
<b class="nc"><i>2019</i>&nbsp;             throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);</b>
<i>2020</i>&nbsp;         }
<i>2021</i>&nbsp;         if (len &gt; x.length) {
<b class="nc"><i>2022</i>&nbsp;             throw new IllegalArgumentException(&quot;input length out of bound: &quot; +</b>
<i>2023</i>&nbsp;                                        len + &quot; &gt; &quot; + x.length);
<i>2024</i>&nbsp;         }
<i>2025</i>&nbsp;         if (len * 2 &gt; z.length) {
<i>2026</i>&nbsp;             throw new IllegalArgumentException(&quot;input length out of bound: &quot; +
<i>2027</i>&nbsp;                                        (len * 2) + &quot; &gt; &quot; + z.length);
<i>2028</i>&nbsp;         }
<i>2029</i>&nbsp;         if (zlen &lt; 1) {
<i>2030</i>&nbsp;             throw new IllegalArgumentException(&quot;invalid input length: &quot; + zlen);
<i>2031</i>&nbsp;         }
<i>2032</i>&nbsp;         if (zlen &gt; z.length) {
<b class="nc"><i>2033</i>&nbsp;             throw new IllegalArgumentException(&quot;input length out of bound: &quot; +</b>
<i>2034</i>&nbsp;                                        len + &quot; &gt; &quot; + z.length);
<i>2035</i>&nbsp;         }
<b class="nc"><i>2036</i>&nbsp;     }</b>
<i>2037</i>&nbsp;
<i>2038</i>&nbsp;     /**
<b class="nc"><i>2039</i>&nbsp;      * Java Runtime may use intrinsic for this method.</b>
<i>2040</i>&nbsp;      */
<i>2041</i>&nbsp;     @HotSpotIntrinsicCandidate
<i>2042</i>&nbsp;     private static final int[] implSquareToLen(int[] x, int len, int[] z, int zlen) {
<i>2043</i>&nbsp;        /*
<b class="nc"><i>2044</i>&nbsp;         * The algorithm used here is adapted from Colin Plumb&#39;s C library.</b>
<b class="nc"><i>2045</i>&nbsp;         * Technique: Consider the partial products in the multiplication</b>
<b class="nc"><i>2046</i>&nbsp;         * of &quot;abcde&quot; by itself:</b>
<i>2047</i>&nbsp;         *
<i>2048</i>&nbsp;         *               a  b  c  d  e
<b class="nc"><i>2049</i>&nbsp;         *            *  a  b  c  d  e</b>
<b class="nc"><i>2050</i>&nbsp;         *          ==================</b>
<b class="nc"><i>2051</i>&nbsp;         *              ae be ce de ee</b>
<b class="nc"><i>2052</i>&nbsp;         *           ad bd cd dd de</b>
<b class="nc"><i>2053</i>&nbsp;         *        ac bc cc cd ce</b>
<b class="nc"><i>2054</i>&nbsp;         *     ab bb bc bd be</b>
<b class="nc"><i>2055</i>&nbsp;         *  aa ab ac ad ae</b>
<i>2056</i>&nbsp;         *
<i>2057</i>&nbsp;         * Note that everything above the main diagonal:
<i>2058</i>&nbsp;         *              ae be ce de = (abcd) * e
<i>2059</i>&nbsp;         *           ad bd cd       = (abc) * d
<i>2060</i>&nbsp;         *        ac bc             = (ab) * c
<i>2061</i>&nbsp;         *     ab                   = (a) * b
<i>2062</i>&nbsp;         *
<b class="nc"><i>2063</i>&nbsp;         * is a copy of everything below the main diagonal:</b>
<b class="nc"><i>2064</i>&nbsp;         *                       de</b>
<b class="nc"><i>2065</i>&nbsp;         *                 cd ce</b>
<b class="nc"><i>2066</i>&nbsp;         *           bc bd be</b>
<b class="nc"><i>2067</i>&nbsp;         *     ab ac ad ae</b>
<b class="nc"><i>2068</i>&nbsp;         *</b>
<b class="nc"><i>2069</i>&nbsp;         * Thus, the sum is 2 * (off the diagonal) + diagonal.</b>
<i>2070</i>&nbsp;         *
<i>2071</i>&nbsp;         * This is accumulated beginning with the diagonal (which
<b class="nc"><i>2072</i>&nbsp;         * consist of the squares of the digits of the input), which is then</b>
<i>2073</i>&nbsp;         * divided by two, the off-diagonal added, and multiplied by two
<b class="nc"><i>2074</i>&nbsp;         * again.  The low bit is simply a copy of the low bit of the</b>
<i>2075</i>&nbsp;         * input, so it doesn&#39;t need special care.
<i>2076</i>&nbsp;         */
<i>2077</i>&nbsp;
<i>2078</i>&nbsp;        // Store the squares, right shifted one bit (i.e., divided by 2)
<i>2079</i>&nbsp;        int lastProductLowWord = 0;
<i>2080</i>&nbsp;        for (int j=0, i=0; j &lt; len; j++) {
<i>2081</i>&nbsp;            long piece = (x[j] &amp; LONG_MASK);
<i>2082</i>&nbsp;            long product = piece * piece;
<i>2083</i>&nbsp;            z[i++] = (lastProductLowWord &lt;&lt; 31) | (int)(product &gt;&gt;&gt; 33);
<i>2084</i>&nbsp;            z[i++] = (int)(product &gt;&gt;&gt; 1);
<i>2085</i>&nbsp;            lastProductLowWord = (int)product;
<i>2086</i>&nbsp;        }
<b class="nc"><i>2087</i>&nbsp;</b>
<i>2088</i>&nbsp;        // Add in off-diagonal sums
<b class="nc"><i>2089</i>&nbsp;        for (int i=len, offset=1; i &gt; 0; i--, offset+=2) {</b>
<i>2090</i>&nbsp;            int t = x[i-1];
<b class="nc"><i>2091</i>&nbsp;            t = mulAdd(z, x, offset, i-1, t);</b>
<i>2092</i>&nbsp;            addOne(z, offset-1, i, t);
<i>2093</i>&nbsp;        }
<i>2094</i>&nbsp;
<i>2095</i>&nbsp;        // Shift back up and set low bit
<i>2096</i>&nbsp;        primitiveLeftShift(z, zlen, 1);
<i>2097</i>&nbsp;        z[zlen-1] |= x[len-1] &amp; 1;
<i>2098</i>&nbsp;
<i>2099</i>&nbsp;        return z;
<i>2100</i>&nbsp;    }
<i>2101</i>&nbsp;
<i>2102</i>&nbsp;    /**
<i>2103</i>&nbsp;     * Squares a BigInteger using the Karatsuba squaring algorithm.  It should
<b class="nc"><i>2104</i>&nbsp;     * be used when both numbers are larger than a certain threshold (found</b>
<b class="nc"><i>2105</i>&nbsp;     * experimentally).  It is a recursive divide-and-conquer algorithm that</b>
<b class="nc"><i>2106</i>&nbsp;     * has better asymptotic performance than the algorithm used in</b>
<i>2107</i>&nbsp;     * squareToLen.
<b class="nc"><i>2108</i>&nbsp;     */</b>
<b class="nc"><i>2109</i>&nbsp;    private BigInteger squareKaratsuba() {</b>
<i>2110</i>&nbsp;        int half = (mag.length+1) / 2;
<i>2111</i>&nbsp;
<i>2112</i>&nbsp;        BigInteger xl = getLower(half);
<i>2113</i>&nbsp;        BigInteger xh = getUpper(half);
<i>2114</i>&nbsp;
<i>2115</i>&nbsp;        BigInteger xhs = xh.square();  // xhs = xh^2
<i>2116</i>&nbsp;        BigInteger xls = xl.square();  // xls = xl^2
<i>2117</i>&nbsp;
<i>2118</i>&nbsp;        // xh^2 &lt;&lt; 64  +  (((xl+xh)^2 - (xh^2 + xl^2)) &lt;&lt; 32) + xl^2
<i>2119</i>&nbsp;        return xhs.shiftLeft(half*32).add(xl.add(xh).square().subtract(xhs.add(xls))).shiftLeft(half*32).add(xls);
<i>2120</i>&nbsp;    }
<i>2121</i>&nbsp;
<i>2122</i>&nbsp;    /**
<i>2123</i>&nbsp;     * Squares a BigInteger using the 3-way Toom-Cook squaring algorithm.  It
<b class="nc"><i>2124</i>&nbsp;     * should be used when both numbers are larger than a certain threshold</b>
<i>2125</i>&nbsp;     * (found experimentally).  It is a recursive divide-and-conquer algorithm
<b class="nc"><i>2126</i>&nbsp;     * that has better asymptotic performance than the algorithm used in</b>
<i>2127</i>&nbsp;     * squareToLen or squareKaratsuba.
<b class="nc"><i>2128</i>&nbsp;     */</b>
<i>2129</i>&nbsp;    private BigInteger squareToomCook3() {
<i>2130</i>&nbsp;        int len = mag.length;
<i>2131</i>&nbsp;
<i>2132</i>&nbsp;        // k is the size (in ints) of the lower-order slices.
<i>2133</i>&nbsp;        int k = (len+2)/3;   // Equal to ceil(largest/3)
<b class="nc"><i>2134</i>&nbsp;</b>
<b class="nc"><i>2135</i>&nbsp;        // r is the size (in ints) of the highest-order slice.</b>
<b class="nc"><i>2136</i>&nbsp;        int r = len - 2*k;</b>
<b class="nc"><i>2137</i>&nbsp;</b>
<b class="nc"><i>2138</i>&nbsp;        // Obtain slices of the numbers. a2 is the most significant</b>
<b class="nc"><i>2139</i>&nbsp;        // bits of the number, and a0 the least significant.</b>
<b class="nc"><i>2140</i>&nbsp;        BigInteger a0, a1, a2;</b>
<b class="nc"><i>2141</i>&nbsp;        a2 = getToomSlice(k, r, 0, len);</b>
<i>2142</i>&nbsp;        a1 = getToomSlice(k, r, 1, len);
<i>2143</i>&nbsp;        a0 = getToomSlice(k, r, 2, len);
<i>2144</i>&nbsp;        BigInteger v0, v1, v2, vm1, vinf, t1, t2, tm1, da1;
<i>2145</i>&nbsp;
<i>2146</i>&nbsp;        v0 = a0.square();
<i>2147</i>&nbsp;        da1 = a2.add(a0);
<i>2148</i>&nbsp;        vm1 = da1.subtract(a1).square();
<i>2149</i>&nbsp;        da1 = da1.add(a1);
<i>2150</i>&nbsp;        v1 = da1.square();
<i>2151</i>&nbsp;        vinf = a2.square();
<i>2152</i>&nbsp;        v2 = da1.add(a2).shiftLeft(1).subtract(a0).square();
<b class="nc"><i>2153</i>&nbsp;</b>
<i>2154</i>&nbsp;        // The algorithm requires two divisions by 2 and one by 3.
<b class="nc"><i>2155</i>&nbsp;        // All divisions are known to be exact, that is, they do not produce</b>
<i>2156</i>&nbsp;        // remainders, and all results are positive.  The divisions by 2 are
<b class="nc"><i>2157</i>&nbsp;        // implemented as right shifts which are relatively efficient, leaving</b>
<i>2158</i>&nbsp;        // only a division by 3.
<i>2159</i>&nbsp;        // The division by 3 is done by an optimized algorithm for this case.
<i>2160</i>&nbsp;        t2 = v2.subtract(vm1).exactDivideBy3();
<i>2161</i>&nbsp;        tm1 = v1.subtract(vm1).shiftRight(1);
<i>2162</i>&nbsp;        t1 = v1.subtract(v0);
<b class="nc"><i>2163</i>&nbsp;        t2 = t2.subtract(t1).shiftRight(1);</b>
<b class="nc"><i>2164</i>&nbsp;        t1 = t1.subtract(tm1).subtract(vinf);</b>
<b class="nc"><i>2165</i>&nbsp;        t2 = t2.subtract(vinf.shiftLeft(1));</b>
<i>2166</i>&nbsp;        tm1 = tm1.subtract(t2);
<b class="nc"><i>2167</i>&nbsp;</b>
<i>2168</i>&nbsp;        // Number of bits to shift left.
<i>2169</i>&nbsp;        int ss = k*32;
<i>2170</i>&nbsp;
<i>2171</i>&nbsp;        return vinf.shiftLeft(ss).add(t2).shiftLeft(ss).add(t1).shiftLeft(ss).add(tm1).shiftLeft(ss).add(v0);
<i>2172</i>&nbsp;    }
<i>2173</i>&nbsp;
<i>2174</i>&nbsp;    // Division
<i>2175</i>&nbsp;
<b class="nc"><i>2176</i>&nbsp;    /**</b>
<i>2177</i>&nbsp;     * Returns a BigInteger whose value is {@code (this / val)}.
<i>2178</i>&nbsp;     *
<i>2179</i>&nbsp;     * @param  val value by which this BigInteger is to be divided.
<i>2180</i>&nbsp;     * @return {@code this / val}
<i>2181</i>&nbsp;     * @throws ArithmeticException if {@code val} is zero.
<i>2182</i>&nbsp;     */
<i>2183</i>&nbsp;    public BigInteger divide(BigInteger val) {
<i>2184</i>&nbsp;        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||
<b class="nc"><i>2185</i>&nbsp;                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {</b>
<i>2186</i>&nbsp;            return divideKnuth(val);
<i>2187</i>&nbsp;        } else {
<i>2188</i>&nbsp;            return divideBurnikelZiegler(val);
<i>2189</i>&nbsp;        }
<i>2190</i>&nbsp;    }
<i>2191</i>&nbsp;
<i>2192</i>&nbsp;    /**
<i>2193</i>&nbsp;     * Returns a BigInteger whose value is {@code (this / val)} using an O(n^2) algorithm from Knuth.
<i>2194</i>&nbsp;     *
<b class="nc"><i>2195</i>&nbsp;     * @param  val value by which this BigInteger is to be divided.</b>
<b class="nc"><i>2196</i>&nbsp;     * @return {@code this / val}</b>
<b class="nc"><i>2197</i>&nbsp;     * @throws ArithmeticException if {@code val} is zero.</b>
<b class="nc"><i>2198</i>&nbsp;     * @see MutableBigInteger#divideKnuth(MutableBigInteger, MutableBigInteger, boolean)</b>
<b class="nc"><i>2199</i>&nbsp;     */</b>
<i>2200</i>&nbsp;    private BigInteger divideKnuth(BigInteger val) {
<i>2201</i>&nbsp;        MutableBigInteger q = new MutableBigInteger(),
<i>2202</i>&nbsp;                          a = new MutableBigInteger(this.mag),
<i>2203</i>&nbsp;                          b = new MutableBigInteger(val.mag);
<i>2204</i>&nbsp;
<i>2205</i>&nbsp;        a.divideKnuth(b, q, false);
<i>2206</i>&nbsp;        return q.toBigInteger(this.signum * val.signum);
<i>2207</i>&nbsp;    }
<i>2208</i>&nbsp;
<i>2209</i>&nbsp;    /**
<i>2210</i>&nbsp;     * Returns an array of two BigIntegers containing {@code (this / val)}
<i>2211</i>&nbsp;     * followed by {@code (this % val)}.
<b class="nc"><i>2212</i>&nbsp;     *</b>
<b class="nc"><i>2213</i>&nbsp;     * @param  val value by which this BigInteger is to be divided, and the</b>
<i>2214</i>&nbsp;     *         remainder computed.
<b class="nc"><i>2215</i>&nbsp;     * @return an array of two BigIntegers: the quotient {@code (this / val)}</b>
<b class="nc"><i>2216</i>&nbsp;     *         is the initial element, and the remainder {@code (this % val)}</b>
<i>2217</i>&nbsp;     *         is the final element.
<i>2218</i>&nbsp;     * @throws ArithmeticException if {@code val} is zero.
<b class="nc"><i>2219</i>&nbsp;     */</b>
<i>2220</i>&nbsp;    public BigInteger[] divideAndRemainder(BigInteger val) {
<i>2221</i>&nbsp;        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||
<i>2222</i>&nbsp;                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {
<i>2223</i>&nbsp;            return divideAndRemainderKnuth(val);
<i>2224</i>&nbsp;        } else {
<b class="nc"><i>2225</i>&nbsp;            return divideAndRemainderBurnikelZiegler(val);</b>
<b class="nc"><i>2226</i>&nbsp;        }</b>
<b class="nc"><i>2227</i>&nbsp;    }</b>
<b class="nc"><i>2228</i>&nbsp;</b>
<i>2229</i>&nbsp;    /** Long division */
<i>2230</i>&nbsp;    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {
<i>2231</i>&nbsp;        BigInteger[] result = new BigInteger[2];
<i>2232</i>&nbsp;        MutableBigInteger q = new MutableBigInteger(),
<i>2233</i>&nbsp;                          a = new MutableBigInteger(this.mag),
<b class="nc"><i>2234</i>&nbsp;                          b = new MutableBigInteger(val.mag);</b>
<b class="nc"><i>2235</i>&nbsp;        MutableBigInteger r = a.divideKnuth(b, q);</b>
<b class="nc"><i>2236</i>&nbsp;        result[0] = q.toBigInteger(this.signum == val.signum ? 1 : -1);</b>
<b class="nc"><i>2237</i>&nbsp;        result[1] = r.toBigInteger(this.signum);</b>
<b class="nc"><i>2238</i>&nbsp;        return result;</b>
<b class="nc"><i>2239</i>&nbsp;    }</b>
<i>2240</i>&nbsp;
<b class="nc"><i>2241</i>&nbsp;    /**</b>
<i>2242</i>&nbsp;     * Returns a BigInteger whose value is {@code (this % val)}.
<i>2243</i>&nbsp;     *
<i>2244</i>&nbsp;     * @param  val value by which this BigInteger is to be divided, and the
<b class="nc"><i>2245</i>&nbsp;     *         remainder computed.</b>
<b class="nc"><i>2246</i>&nbsp;     * @return {@code this % val}</b>
<b class="nc"><i>2247</i>&nbsp;     * @throws ArithmeticException if {@code val} is zero.</b>
<b class="nc"><i>2248</i>&nbsp;     */</b>
<i>2249</i>&nbsp;    public BigInteger remainder(BigInteger val) {
<b class="nc"><i>2250</i>&nbsp;        if (val.mag.length &lt; BURNIKEL_ZIEGLER_THRESHOLD ||</b>
<i>2251</i>&nbsp;                mag.length - val.mag.length &lt; BURNIKEL_ZIEGLER_OFFSET) {
<i>2252</i>&nbsp;            return remainderKnuth(val);
<i>2253</i>&nbsp;        } else {
<i>2254</i>&nbsp;            return remainderBurnikelZiegler(val);
<i>2255</i>&nbsp;        }
<i>2256</i>&nbsp;    }
<i>2257</i>&nbsp;
<b class="nc"><i>2258</i>&nbsp;    /** Long division */</b>
<i>2259</i>&nbsp;    private BigInteger remainderKnuth(BigInteger val) {
<i>2260</i>&nbsp;        MutableBigInteger q = new MutableBigInteger(),
<i>2261</i>&nbsp;                          a = new MutableBigInteger(this.mag),
<b class="nc"><i>2262</i>&nbsp;                          b = new MutableBigInteger(val.mag);</b>
<i>2263</i>&nbsp;
<b class="nc"><i>2264</i>&nbsp;        return a.divideKnuth(b, q).toBigInteger(this.signum);</b>
<b class="nc"><i>2265</i>&nbsp;    }</b>
<b class="nc"><i>2266</i>&nbsp;</b>
<i>2267</i>&nbsp;    /**
<b class="nc"><i>2268</i>&nbsp;     * Calculates {@code this / val} using the Burnikel-Ziegler algorithm.</b>
<i>2269</i>&nbsp;     * @param  val the divisor
<i>2270</i>&nbsp;     * @return {@code this / val}
<b class="nc"><i>2271</i>&nbsp;     */</b>
<b class="nc"><i>2272</i>&nbsp;    private BigInteger divideBurnikelZiegler(BigInteger val) {</b>
<b class="nc"><i>2273</i>&nbsp;        return divideAndRemainderBurnikelZiegler(val)[0];</b>
<i>2274</i>&nbsp;    }
<i>2275</i>&nbsp;
<b class="nc"><i>2276</i>&nbsp;    /**</b>
<b class="nc"><i>2277</i>&nbsp;     * Calculates {@code this % val} using the Burnikel-Ziegler algorithm.</b>
<i>2278</i>&nbsp;     * @param val the divisor
<i>2279</i>&nbsp;     * @return {@code this % val}
<i>2280</i>&nbsp;     */
<i>2281</i>&nbsp;    private BigInteger remainderBurnikelZiegler(BigInteger val) {
<b class="nc"><i>2282</i>&nbsp;        return divideAndRemainderBurnikelZiegler(val)[1];</b>
<b class="nc"><i>2283</i>&nbsp;    }</b>
<b class="nc"><i>2284</i>&nbsp;</b>
<i>2285</i>&nbsp;    /**
<b class="nc"><i>2286</i>&nbsp;     * Computes {@code this / val} and {@code this % val} using the</b>
<i>2287</i>&nbsp;     * Burnikel-Ziegler algorithm.
<i>2288</i>&nbsp;     * @param val the divisor
<i>2289</i>&nbsp;     * @return an array containing the quotient and remainder
<b class="nc"><i>2290</i>&nbsp;     */</b>
<i>2291</i>&nbsp;    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {
<i>2292</i>&nbsp;        MutableBigInteger q = new MutableBigInteger();
<i>2293</i>&nbsp;        MutableBigInteger r = new MutableBigInteger(this).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);
<i>2294</i>&nbsp;        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(signum*val.signum);
<i>2295</i>&nbsp;        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(signum);
<b class="nc"><i>2296</i>&nbsp;        return new BigInteger[] {qBigInt, rBigInt};</b>
<i>2297</i>&nbsp;    }
<b class="nc"><i>2298</i>&nbsp;</b>
<i>2299</i>&nbsp;    /**
<b class="nc"><i>2300</i>&nbsp;     * Returns a BigInteger whose value is &lt;code&gt;(this&lt;sup&gt;exponent&lt;/sup&gt;)&lt;/code&gt;.</b>
<b class="nc"><i>2301</i>&nbsp;     * Note that {@code exponent} is an integer rather than a BigInteger.</b>
<b class="nc"><i>2302</i>&nbsp;     *</b>
<i>2303</i>&nbsp;     * @param  exponent exponent to which this BigInteger is to be raised.
<i>2304</i>&nbsp;     * @return &lt;code&gt;this&lt;sup&gt;exponent&lt;/sup&gt;&lt;/code&gt;
<b class="nc"><i>2305</i>&nbsp;     * @throws ArithmeticException {@code exponent} is negative.  (This would</b>
<b class="nc"><i>2306</i>&nbsp;     *         cause the operation to yield a non-integer value.)</b>
<i>2307</i>&nbsp;     */
<i>2308</i>&nbsp;    public BigInteger pow(int exponent) {
<i>2309</i>&nbsp;        if (exponent &lt; 0) {
<i>2310</i>&nbsp;            throw new ArithmeticException(&quot;Negative exponent&quot;);
<b class="nc"><i>2311</i>&nbsp;        }</b>
<b class="nc"><i>2312</i>&nbsp;        if (signum == 0) {</b>
<i>2313</i>&nbsp;            return (exponent == 0 ? ONE : this);
<i>2314</i>&nbsp;        }
<b class="nc"><i>2315</i>&nbsp;</b>
<b class="nc"><i>2316</i>&nbsp;        BigInteger partToSquare = this.abs();</b>
<i>2317</i>&nbsp;
<b class="nc"><i>2318</i>&nbsp;        // Factor out powers of two from the base, as the exponentiation of</b>
<i>2319</i>&nbsp;        // these can be done by left shifts only.
<i>2320</i>&nbsp;        // The remaining part can then be exponentiated faster.  The
<i>2321</i>&nbsp;        // powers of two will be multiplied back at the end.
<i>2322</i>&nbsp;        int powersOfTwo = partToSquare.getLowestSetBit();
<i>2323</i>&nbsp;        long bitsToShift = (long)powersOfTwo * exponent;
<i>2324</i>&nbsp;        if (bitsToShift &gt; Integer.MAX_VALUE) {
<i>2325</i>&nbsp;            reportOverflow();
<i>2326</i>&nbsp;        }
<i>2327</i>&nbsp;
<i>2328</i>&nbsp;        int remainingBits;
<i>2329</i>&nbsp;
<i>2330</i>&nbsp;        // Factor the powers of two out quickly by shifting right, if needed.
<i>2331</i>&nbsp;        if (powersOfTwo &gt; 0) {
<b class="nc"><i>2332</i>&nbsp;            partToSquare = partToSquare.shiftRight(powersOfTwo);</b>
<b class="nc"><i>2333</i>&nbsp;            remainingBits = partToSquare.bitLength();</b>
<b class="nc"><i>2334</i>&nbsp;            if (remainingBits == 1) {  // Nothing left but +/- 1?</b>
<b class="nc"><i>2335</i>&nbsp;                if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</b>
<i>2336</i>&nbsp;                    return NEGATIVE_ONE.shiftLeft(powersOfTwo*exponent);
<b class="nc"><i>2337</i>&nbsp;                } else {</b>
<b class="nc"><i>2338</i>&nbsp;                    return ONE.shiftLeft(powersOfTwo*exponent);</b>
<i>2339</i>&nbsp;                }
<b class="nc"><i>2340</i>&nbsp;            }</b>
<i>2341</i>&nbsp;        } else {
<b class="nc"><i>2342</i>&nbsp;            remainingBits = partToSquare.bitLength();</b>
<i>2343</i>&nbsp;            if (remainingBits == 1) { // Nothing left but +/- 1?
<i>2344</i>&nbsp;                if (signum &lt; 0  &amp;&amp; (exponent&amp;1) == 1) {
<i>2345</i>&nbsp;                    return NEGATIVE_ONE;
<i>2346</i>&nbsp;                } else {
<i>2347</i>&nbsp;                    return ONE;
<i>2348</i>&nbsp;                }
<b class="nc"><i>2349</i>&nbsp;            }</b>
<i>2350</i>&nbsp;        }
<i>2351</i>&nbsp;
<i>2352</i>&nbsp;        // This is a quick way to approximate the size of the result,
<i>2353</i>&nbsp;        // similar to doing log2[n] * exponent.  This will give an upper bound
<i>2354</i>&nbsp;        // of how big the result can be, and which algorithm to use.
<i>2355</i>&nbsp;        long scaleFactor = (long)remainingBits * exponent;
<i>2356</i>&nbsp;
<b class="nc"><i>2357</i>&nbsp;        // Use slightly different algorithms for small and large operands.</b>
<b class="nc"><i>2358</i>&nbsp;        // See if the result will safely fit into a long. (Largest 2^63-1)</b>
<b class="nc"><i>2359</i>&nbsp;        if (partToSquare.mag.length == 1 &amp;&amp; scaleFactor &lt;= 62) {</b>
<i>2360</i>&nbsp;            // Small number algorithm.  Everything fits into a long.
<i>2361</i>&nbsp;            int newSign = (signum &lt;0  &amp;&amp; (exponent&amp;1) == 1 ? -1 : 1);
<b class="nc"><i>2362</i>&nbsp;            long result = 1;</b>
<b class="nc"><i>2363</i>&nbsp;            long baseToPow2 = partToSquare.mag[0] &amp; LONG_MASK;</b>
<b class="nc"><i>2364</i>&nbsp;</b>
<i>2365</i>&nbsp;            int workingExponent = exponent;
<b class="nc"><i>2366</i>&nbsp;</b>
<b class="nc"><i>2367</i>&nbsp;            // Perform exponentiation using repeated squaring trick</b>
<b class="nc"><i>2368</i>&nbsp;            while (workingExponent != 0) {</b>
<b class="nc"><i>2369</i>&nbsp;                if ((workingExponent &amp; 1) == 1) {</b>
<b class="nc"><i>2370</i>&nbsp;                    result = result * baseToPow2;</b>
<i>2371</i>&nbsp;                }
<b class="nc"><i>2372</i>&nbsp;</b>
<b class="nc"><i>2373</i>&nbsp;                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</b>
<b class="nc"><i>2374</i>&nbsp;                    baseToPow2 = baseToPow2 * baseToPow2;</b>
<b class="nc"><i>2375</i>&nbsp;                }</b>
<i>2376</i>&nbsp;            }
<i>2377</i>&nbsp;
<i>2378</i>&nbsp;            // Multiply back the powers of two (quickly, by shifting left)
<i>2379</i>&nbsp;            if (powersOfTwo &gt; 0) {
<i>2380</i>&nbsp;                if (bitsToShift + scaleFactor &lt;= 62) { // Fits in long?
<i>2381</i>&nbsp;                    return valueOf((result &lt;&lt; bitsToShift) * newSign);
<b class="nc"><i>2382</i>&nbsp;                } else {</b>
<b class="nc"><i>2383</i>&nbsp;                    return valueOf(result*newSign).shiftLeft((int) bitsToShift);</b>
<b class="nc"><i>2384</i>&nbsp;                }</b>
<b class="nc"><i>2385</i>&nbsp;            }</b>
<b class="nc"><i>2386</i>&nbsp;            else {</b>
<i>2387</i>&nbsp;                return valueOf(result*newSign);
<b class="nc"><i>2388</i>&nbsp;            }</b>
<i>2389</i>&nbsp;        } else {
<i>2390</i>&nbsp;            // Large number algorithm.  This is basically identical to
<i>2391</i>&nbsp;            // the algorithm above, but calls multiply() and square()
<i>2392</i>&nbsp;            // which may use more efficient algorithms for large numbers.
<b class="nc"><i>2393</i>&nbsp;            BigInteger answer = ONE;</b>
<i>2394</i>&nbsp;
<i>2395</i>&nbsp;            int workingExponent = exponent;
<b class="nc"><i>2396</i>&nbsp;            // Perform exponentiation using repeated squaring trick</b>
<b class="nc"><i>2397</i>&nbsp;            while (workingExponent != 0) {</b>
<b class="nc"><i>2398</i>&nbsp;                if ((workingExponent &amp; 1) == 1) {</b>
<b class="nc"><i>2399</i>&nbsp;                    answer = answer.multiply(partToSquare);</b>
<b class="nc"><i>2400</i>&nbsp;                }</b>
<i>2401</i>&nbsp;
<b class="nc"><i>2402</i>&nbsp;                if ((workingExponent &gt;&gt;&gt;= 1) != 0) {</b>
<i>2403</i>&nbsp;                    partToSquare = partToSquare.square();
<i>2404</i>&nbsp;                }
<i>2405</i>&nbsp;            }
<i>2406</i>&nbsp;            // Multiply back the (exponentiated) powers of two (quickly,
<i>2407</i>&nbsp;            // by shifting left)
<i>2408</i>&nbsp;            if (powersOfTwo &gt; 0) {
<i>2409</i>&nbsp;                answer = answer.shiftLeft(powersOfTwo*exponent);
<b class="nc"><i>2410</i>&nbsp;            }</b>
<b class="nc"><i>2411</i>&nbsp;</b>
<b class="nc"><i>2412</i>&nbsp;            if (signum &lt; 0 &amp;&amp; (exponent&amp;1) == 1) {</b>
<i>2413</i>&nbsp;                return answer.negate();
<i>2414</i>&nbsp;            } else {
<i>2415</i>&nbsp;                return answer;
<i>2416</i>&nbsp;            }
<i>2417</i>&nbsp;        }
<i>2418</i>&nbsp;    }
<i>2419</i>&nbsp;
<i>2420</i>&nbsp;    /**
<i>2421</i>&nbsp;     * Returns the integer square root of this BigInteger.  The integer square
<b class="nc"><i>2422</i>&nbsp;     * root of the corresponding mathematical integer {@code n} is the largest</b>
<i>2423</i>&nbsp;     * mathematical integer {@code s} such that {@code s*s &lt;= n}.  It is equal
<i>2424</i>&nbsp;     * to the value of {@code floor(sqrt(n))}, where {@code sqrt(n)} denotes the
<i>2425</i>&nbsp;     * real square root of {@code n} treated as a real.  Note that the integer
<i>2426</i>&nbsp;     * square root will be less than the real square root if the latter is not
<i>2427</i>&nbsp;     * representable as an integral value.
<i>2428</i>&nbsp;     *
<i>2429</i>&nbsp;     * @return the integer square root of {@code this}
<i>2430</i>&nbsp;     * @throws ArithmeticException if {@code this} is negative.  (The square
<b class="nc"><i>2431</i>&nbsp;     *         root of a negative integer {@code val} is</b>
<i>2432</i>&nbsp;     *         {@code (i * sqrt(-val))} where &lt;i&gt;i&lt;/i&gt; is the
<i>2433</i>&nbsp;     *         &lt;i&gt;imaginary unit&lt;/i&gt; and is equal to
<i>2434</i>&nbsp;     *         {@code sqrt(-1)}.)
<i>2435</i>&nbsp;     * @since  9
<i>2436</i>&nbsp;     */
<i>2437</i>&nbsp;    public BigInteger sqrt() {
<i>2438</i>&nbsp;        if (this.signum &lt; 0) {
<i>2439</i>&nbsp;            throw new ArithmeticException(&quot;Negative BigInteger&quot;);
<i>2440</i>&nbsp;        }
<b class="nc"><i>2441</i>&nbsp;</b>
<i>2442</i>&nbsp;        return new MutableBigInteger(this.mag).sqrt().toBigInteger();
<i>2443</i>&nbsp;    }
<i>2444</i>&nbsp;
<i>2445</i>&nbsp;    /**
<i>2446</i>&nbsp;     * Returns an array of two BigIntegers containing the integer square root
<i>2447</i>&nbsp;     * {@code s} of {@code this} and its remainder {@code this - s*s},
<i>2448</i>&nbsp;     * respectively.
<i>2449</i>&nbsp;     *
<i>2450</i>&nbsp;     * @return an array of two BigIntegers with the integer square root at
<i>2451</i>&nbsp;     *         offset 0 and the remainder at offset 1
<i>2452</i>&nbsp;     * @throws ArithmeticException if {@code this} is negative.  (The square
<i>2453</i>&nbsp;     *         root of a negative integer {@code val} is
<i>2454</i>&nbsp;     *         {@code (i * sqrt(-val))} where &lt;i&gt;i&lt;/i&gt; is the
<i>2455</i>&nbsp;     *         &lt;i&gt;imaginary unit&lt;/i&gt; and is equal to
<i>2456</i>&nbsp;     *         {@code sqrt(-1)}.)
<b class="nc"><i>2457</i>&nbsp;     * @see #sqrt()</b>
<b class="nc"><i>2458</i>&nbsp;     * @since  9</b>
<i>2459</i>&nbsp;     */
<b class="nc"><i>2460</i>&nbsp;    public BigInteger[] sqrtAndRemainder() {</b>
<b class="nc"><i>2461</i>&nbsp;        BigInteger s = sqrt();</b>
<i>2462</i>&nbsp;        BigInteger r = this.subtract(s.square());
<i>2463</i>&nbsp;        assert r.compareTo(BigInteger.ZERO) &gt;= 0;
<i>2464</i>&nbsp;        return new BigInteger[] {s, r};
<i>2465</i>&nbsp;    }
<i>2466</i>&nbsp;
<i>2467</i>&nbsp;    /**
<i>2468</i>&nbsp;     * Returns a BigInteger whose value is the greatest common divisor of
<i>2469</i>&nbsp;     * {@code abs(this)} and {@code abs(val)}.  Returns 0 if
<i>2470</i>&nbsp;     * {@code this == 0 &amp;&amp; val == 0}.
<i>2471</i>&nbsp;     *
<i>2472</i>&nbsp;     * @param  val value with which the GCD is to be computed.
<i>2473</i>&nbsp;     * @return {@code GCD(abs(this), abs(val))}
<i>2474</i>&nbsp;     */
<i>2475</i>&nbsp;    public BigInteger gcd(BigInteger val) {
<i>2476</i>&nbsp;        if (val.signum == 0)
<i>2477</i>&nbsp;            return this.abs();
<b class="nc"><i>2478</i>&nbsp;        else if (this.signum == 0)</b>
<b class="nc"><i>2479</i>&nbsp;            return val.abs();</b>
<i>2480</i>&nbsp;
<i>2481</i>&nbsp;        MutableBigInteger a = new MutableBigInteger(this);
<b class="nc"><i>2482</i>&nbsp;        MutableBigInteger b = new MutableBigInteger(val);</b>
<b class="nc"><i>2483</i>&nbsp;</b>
<i>2484</i>&nbsp;        MutableBigInteger result = a.hybridGCD(b);
<b class="nc"><i>2485</i>&nbsp;</b>
<b class="nc"><i>2486</i>&nbsp;        return result.toBigInteger(1);</b>
<i>2487</i>&nbsp;    }
<b class="nc"><i>2488</i>&nbsp;</b>
<b class="nc"><i>2489</i>&nbsp;    /**</b>
<i>2490</i>&nbsp;     * Package private method to return bit length for an integer.
<b class="nc"><i>2491</i>&nbsp;     */</b>
<b class="nc"><i>2492</i>&nbsp;    static int bitLengthForInt(int n) {</b>
<i>2493</i>&nbsp;        return 32 - Integer.numberOfLeadingZeros(n);
<i>2494</i>&nbsp;    }
<b class="nc"><i>2495</i>&nbsp;</b>
<b class="nc"><i>2496</i>&nbsp;    /**</b>
<i>2497</i>&nbsp;     * Left shift int array a up to len by n bits. Returns the array that
<b class="nc"><i>2498</i>&nbsp;     * results from the shift since space may have to be reallocated.</b>
<b class="nc"><i>2499</i>&nbsp;     */</b>
<i>2500</i>&nbsp;    private static int[] leftShift(int[] a, int len, int n) {
<b class="nc"><i>2501</i>&nbsp;        int nInts = n &gt;&gt;&gt; 5;</b>
<b class="nc"><i>2502</i>&nbsp;        int nBits = n&amp;0x1F;</b>
<i>2503</i>&nbsp;        int bitsInHighWord = bitLengthForInt(a[0]);
<i>2504</i>&nbsp;
<i>2505</i>&nbsp;        // If shift can be done without recopy, do so
<i>2506</i>&nbsp;        if (n &lt;= (32-bitsInHighWord)) {
<i>2507</i>&nbsp;            primitiveLeftShift(a, len, nBits);
<i>2508</i>&nbsp;            return a;
<i>2509</i>&nbsp;        } else { // Array must be resized
<i>2510</i>&nbsp;            if (nBits &lt;= (32-bitsInHighWord)) {
<b class="nc"><i>2511</i>&nbsp;                int result[] = new int[nInts+len];</b>
<i>2512</i>&nbsp;                System.arraycopy(a, 0, result, 0, len);
<b class="nc"><i>2513</i>&nbsp;                primitiveLeftShift(result, result.length, nBits);</b>
<b class="nc"><i>2514</i>&nbsp;                return result;</b>
<i>2515</i>&nbsp;            } else {
<i>2516</i>&nbsp;                int result[] = new int[nInts+len+1];
<b class="nc"><i>2517</i>&nbsp;                System.arraycopy(a, 0, result, 0, len);</b>
<b class="nc"><i>2518</i>&nbsp;                primitiveRightShift(result, result.length, 32 - nBits);</b>
<i>2519</i>&nbsp;                return result;
<i>2520</i>&nbsp;            }
<b class="nc"><i>2521</i>&nbsp;        }</b>
<b class="nc"><i>2522</i>&nbsp;    }</b>
<i>2523</i>&nbsp;
<i>2524</i>&nbsp;    // shifts a up to len right n bits assumes no leading zeros, 0&lt;n&lt;32
<b class="nc"><i>2525</i>&nbsp;    static void primitiveRightShift(int[] a, int len, int n) {</b>
<i>2526</i>&nbsp;        int n2 = 32 - n;
<i>2527</i>&nbsp;        for (int i=len-1, c=a[i]; i &gt; 0; i--) {
<b class="nc"><i>2528</i>&nbsp;            int b = c;</b>
<b class="nc"><i>2529</i>&nbsp;            c = a[i-1];</b>
<i>2530</i>&nbsp;            a[i] = (c &lt;&lt; n2) | (b &gt;&gt;&gt; n);
<b class="nc"><i>2531</i>&nbsp;        }</b>
<b class="nc"><i>2532</i>&nbsp;        a[0] &gt;&gt;&gt;= n;</b>
<i>2533</i>&nbsp;    }
<b class="nc"><i>2534</i>&nbsp;</b>
<b class="nc"><i>2535</i>&nbsp;    // shifts a up to len left n bits assumes no leading zeros, 0&lt;=n&lt;32</b>
<b class="nc"><i>2536</i>&nbsp;    static void primitiveLeftShift(int[] a, int len, int n) {</b>
<b class="nc"><i>2537</i>&nbsp;        if (len == 0 || n == 0)</b>
<b class="nc"><i>2538</i>&nbsp;            return;</b>
<b class="nc"><i>2539</i>&nbsp;</b>
<b class="nc"><i>2540</i>&nbsp;        int n2 = 32 - n;</b>
<i>2541</i>&nbsp;        for (int i=0, c=a[i], m=i+len-1; i &lt; m; i++) {
<i>2542</i>&nbsp;            int b = c;
<i>2543</i>&nbsp;            c = a[i+1];
<b class="nc"><i>2544</i>&nbsp;            a[i] = (b &lt;&lt; n) | (c &gt;&gt;&gt; n2);</b>
<i>2545</i>&nbsp;        }
<i>2546</i>&nbsp;        a[len-1] &lt;&lt;= n;
<i>2547</i>&nbsp;    }
<i>2548</i>&nbsp;
<i>2549</i>&nbsp;    /**
<i>2550</i>&nbsp;     * Calculate bitlength of contents of the first len elements an int array,
<i>2551</i>&nbsp;     * assuming there are no leading zero ints.
<i>2552</i>&nbsp;     */
<i>2553</i>&nbsp;    private static int bitLength(int[] val, int len) {
<b class="nc"><i>2554</i>&nbsp;        if (len == 0)</b>
<b class="nc"><i>2555</i>&nbsp;            return 0;</b>
<i>2556</i>&nbsp;        return ((len - 1) &lt;&lt; 5) + bitLengthForInt(val[0]);
<b class="nc"><i>2557</i>&nbsp;    }</b>
<b class="nc"><i>2558</i>&nbsp;</b>
<i>2559</i>&nbsp;    /**
<b class="nc"><i>2560</i>&nbsp;     * Returns a BigInteger whose value is the absolute value of this</b>
<i>2561</i>&nbsp;     * BigInteger.
<i>2562</i>&nbsp;     *
<i>2563</i>&nbsp;     * @return {@code abs(this)}
<i>2564</i>&nbsp;     */
<b class="nc"><i>2565</i>&nbsp;    public BigInteger abs() {</b>
<b class="nc"><i>2566</i>&nbsp;        return (signum &gt;= 0 ? this : this.negate());</b>
<i>2567</i>&nbsp;    }
<b class="nc"><i>2568</i>&nbsp;</b>
<b class="nc"><i>2569</i>&nbsp;    /**</b>
<i>2570</i>&nbsp;     * Returns a BigInteger whose value is {@code (-this)}.
<b class="nc"><i>2571</i>&nbsp;     *</b>
<i>2572</i>&nbsp;     * @return {@code -this}
<i>2573</i>&nbsp;     */
<i>2574</i>&nbsp;    public BigInteger negate() {
<i>2575</i>&nbsp;        return new BigInteger(this.mag, -this.signum);
<i>2576</i>&nbsp;    }
<i>2577</i>&nbsp;
<b class="nc"><i>2578</i>&nbsp;    /**</b>
<b class="nc"><i>2579</i>&nbsp;     * Returns the signum function of this BigInteger.</b>
<i>2580</i>&nbsp;     *
<i>2581</i>&nbsp;     * @return -1, 0 or 1 as the value of this BigInteger is negative, zero or
<b class="nc"><i>2582</i>&nbsp;     *         positive.</b>
<b class="nc"><i>2583</i>&nbsp;     */</b>
<i>2584</i>&nbsp;    public int signum() {
<i>2585</i>&nbsp;        return this.signum;
<b class="nc"><i>2586</i>&nbsp;    }</b>
<i>2587</i>&nbsp;
<i>2588</i>&nbsp;    // Modular Arithmetic Operations
<i>2589</i>&nbsp;
<b class="nc"><i>2590</i>&nbsp;    /**</b>
<i>2591</i>&nbsp;     * Returns a BigInteger whose value is {@code (this mod m}).  This method
<i>2592</i>&nbsp;     * differs from {@code remainder} in that it always returns a
<i>2593</i>&nbsp;     * &lt;i&gt;non-negative&lt;/i&gt; BigInteger.
<i>2594</i>&nbsp;     *
<i>2595</i>&nbsp;     * @param  m the modulus.
<i>2596</i>&nbsp;     * @return {@code this mod m}
<i>2597</i>&nbsp;     * @throws ArithmeticException {@code m} &amp;le; 0
<b class="nc"><i>2598</i>&nbsp;     * @see    #remainder</b>
<b class="nc"><i>2599</i>&nbsp;     */</b>
<b class="nc"><i>2600</i>&nbsp;    public BigInteger mod(BigInteger m) {</b>
<i>2601</i>&nbsp;        if (m.signum &lt;= 0)
<i>2602</i>&nbsp;            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
<i>2603</i>&nbsp;
<i>2604</i>&nbsp;        BigInteger result = this.remainder(m);
<i>2605</i>&nbsp;        return (result.signum &gt;= 0 ? result : result.add(m));
<i>2606</i>&nbsp;    }
<b class="nc"><i>2607</i>&nbsp;</b>
<b class="nc"><i>2608</i>&nbsp;    /**</b>
<i>2609</i>&nbsp;     * Returns a BigInteger whose value is
<i>2610</i>&nbsp;     * &lt;code&gt;(this&lt;sup&gt;exponent&lt;/sup&gt; mod m)&lt;/code&gt;.  (Unlike {@code pow}, this
<i>2611</i>&nbsp;     * method permits negative exponents.)
<b class="nc"><i>2612</i>&nbsp;     *</b>
<b class="nc"><i>2613</i>&nbsp;     * @param  exponent the exponent.</b>
<i>2614</i>&nbsp;     * @param  m the modulus.
<i>2615</i>&nbsp;     * @return &lt;code&gt;this&lt;sup&gt;exponent&lt;/sup&gt; mod m&lt;/code&gt;
<b class="nc"><i>2616</i>&nbsp;     * @throws ArithmeticException {@code m} &amp;le; 0 or the exponent is</b>
<i>2617</i>&nbsp;     *         negative and this BigInteger is not &lt;i&gt;relatively
<i>2618</i>&nbsp;     *         prime&lt;/i&gt; to {@code m}.
<i>2619</i>&nbsp;     * @see    #modInverse
<i>2620</i>&nbsp;     */
<i>2621</i>&nbsp;    public BigInteger modPow(BigInteger exponent, BigInteger m) {
<i>2622</i>&nbsp;        if (m.signum &lt;= 0)
<i>2623</i>&nbsp;            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);
<i>2624</i>&nbsp;
<i>2625</i>&nbsp;        // Trivial cases
<i>2626</i>&nbsp;        if (exponent.signum == 0)
<i>2627</i>&nbsp;            return (m.equals(ONE) ? ZERO : ONE);
<i>2628</i>&nbsp;
<i>2629</i>&nbsp;        if (this.equals(ONE))
<i>2630</i>&nbsp;            return (m.equals(ONE) ? ZERO : ONE);
<i>2631</i>&nbsp;
<i>2632</i>&nbsp;        if (this.equals(ZERO) &amp;&amp; exponent.signum &gt;= 0)
<i>2633</i>&nbsp;            return ZERO;
<i>2634</i>&nbsp;
<i>2635</i>&nbsp;        if (this.equals(negConst[1]) &amp;&amp; (!exponent.testBit(0)))
<i>2636</i>&nbsp;            return (m.equals(ONE) ? ZERO : ONE);
<i>2637</i>&nbsp;
<i>2638</i>&nbsp;        boolean invertResult;
<i>2639</i>&nbsp;        if ((invertResult = (exponent.signum &lt; 0)))
<i>2640</i>&nbsp;            exponent = exponent.negate();
<i>2641</i>&nbsp;
<i>2642</i>&nbsp;        BigInteger base = (this.signum &lt; 0 || this.compareTo(m) &gt;= 0
<i>2643</i>&nbsp;                           ? this.mod(m) : this);
<i>2644</i>&nbsp;        BigInteger result;
<i>2645</i>&nbsp;        if (m.testBit(0)) { // odd modulus
<i>2646</i>&nbsp;            result = base.oddModPow(exponent, m);
<i>2647</i>&nbsp;        } else {
<i>2648</i>&nbsp;            /*
<i>2649</i>&nbsp;             * Even modulus.  Tear it into an &quot;odd part&quot; (m1) and power of two
<i>2650</i>&nbsp;             * (m2), exponentiate mod m1, manually exponentiate mod m2, and
<i>2651</i>&nbsp;             * use Chinese Remainder Theorem to combine results.
<i>2652</i>&nbsp;             */
<i>2653</i>&nbsp;
<i>2654</i>&nbsp;            // Tear m apart into odd part (m1) and power of 2 (m2)
<i>2655</i>&nbsp;            int p = m.getLowestSetBit();   // Max pow of 2 that divides m
<i>2656</i>&nbsp;
<i>2657</i>&nbsp;            BigInteger m1 = m.shiftRight(p);  // m/2**p
<i>2658</i>&nbsp;            BigInteger m2 = ONE.shiftLeft(p); // 2**p
<i>2659</i>&nbsp;
<i>2660</i>&nbsp;            // Calculate new base from m1
<i>2661</i>&nbsp;            BigInteger base2 = (this.signum &lt; 0 || this.compareTo(m1) &gt;= 0
<i>2662</i>&nbsp;                                ? this.mod(m1) : this);
<i>2663</i>&nbsp;
<i>2664</i>&nbsp;            // Caculate (base ** exponent) mod m1.
<i>2665</i>&nbsp;            BigInteger a1 = (m1.equals(ONE) ? ZERO :
<i>2666</i>&nbsp;                             base2.oddModPow(exponent, m1));
<i>2667</i>&nbsp;
<i>2668</i>&nbsp;            // Calculate (this ** exponent) mod m2
<i>2669</i>&nbsp;            BigInteger a2 = base.modPow2(exponent, p);
<i>2670</i>&nbsp;
<i>2671</i>&nbsp;            // Combine results using Chinese Remainder Theorem
<i>2672</i>&nbsp;            BigInteger y1 = m2.modInverse(m1);
<i>2673</i>&nbsp;            BigInteger y2 = m1.modInverse(m2);
<i>2674</i>&nbsp;
<i>2675</i>&nbsp;            if (m.mag.length &lt; MAX_MAG_LENGTH / 2) {
<i>2676</i>&nbsp;                result = a1.multiply(m2).multiply(y1).add(a2.multiply(m1).multiply(y2)).mod(m);
<i>2677</i>&nbsp;            } else {
<i>2678</i>&nbsp;                MutableBigInteger t1 = new MutableBigInteger();
<i>2679</i>&nbsp;                new MutableBigInteger(a1.multiply(m2)).multiply(new MutableBigInteger(y1), t1);
<i>2680</i>&nbsp;                MutableBigInteger t2 = new MutableBigInteger();
<i>2681</i>&nbsp;                new MutableBigInteger(a2.multiply(m1)).multiply(new MutableBigInteger(y2), t2);
<b class="nc"><i>2682</i>&nbsp;                t1.add(t2);</b>
<b class="nc"><i>2683</i>&nbsp;                MutableBigInteger q = new MutableBigInteger();</b>
<i>2684</i>&nbsp;                result = t1.divide(new MutableBigInteger(m), q).toBigInteger();
<i>2685</i>&nbsp;            }
<b class="nc"><i>2686</i>&nbsp;        }</b>
<b class="nc"><i>2687</i>&nbsp;</b>
<i>2688</i>&nbsp;        return (invertResult ? result.modInverse(m) : result);
<b class="nc"><i>2689</i>&nbsp;    }</b>
<b class="nc"><i>2690</i>&nbsp;</b>
<b class="nc"><i>2691</i>&nbsp;    // Montgomery multiplication.  These are wrappers for</b>
<b class="nc"><i>2692</i>&nbsp;    // implMontgomeryXX routines which are expected to be replaced by</b>
<i>2693</i>&nbsp;    // virtual machine intrinsics.  We don&#39;t use the intrinsics for
<i>2694</i>&nbsp;    // very large operands: MONTGOMERY_INTRINSIC_THRESHOLD should be
<i>2695</i>&nbsp;    // larger than any reasonable crypto key.
<i>2696</i>&nbsp;    private static int[] montgomeryMultiply(int[] a, int[] b, int[] n, int len, long inv,
<i>2697</i>&nbsp;                                            int[] product) {
<b class="nc"><i>2698</i>&nbsp;        implMontgomeryMultiplyChecks(a, b, n, len, product);</b>
<b class="nc"><i>2699</i>&nbsp;        if (len &gt; MONTGOMERY_INTRINSIC_THRESHOLD) {</b>
<b class="nc"><i>2700</i>&nbsp;            // Very long argument: do not use an intrinsic</b>
<b class="nc"><i>2701</i>&nbsp;            product = multiplyToLen(a, len, b, len, product);</b>
<b class="nc"><i>2702</i>&nbsp;            return montReduce(product, n, len, (int)inv);</b>
<i>2703</i>&nbsp;        } else {
<i>2704</i>&nbsp;            return implMontgomeryMultiply(a, b, n, len, inv, materialize(product, len));
<i>2705</i>&nbsp;        }
<b class="nc"><i>2706</i>&nbsp;    }</b>
<b class="nc"><i>2707</i>&nbsp;    private static int[] montgomerySquare(int[] a, int[] n, int len, long inv,</b>
<i>2708</i>&nbsp;                                          int[] product) {
<b class="nc"><i>2709</i>&nbsp;        implMontgomeryMultiplyChecks(a, a, n, len, product);</b>
<b class="nc"><i>2710</i>&nbsp;        if (len &gt; MONTGOMERY_INTRINSIC_THRESHOLD) {</b>
<b class="nc"><i>2711</i>&nbsp;            // Very long argument: do not use an intrinsic</b>
<i>2712</i>&nbsp;            product = squareToLen(a, len, product);
<i>2713</i>&nbsp;            return montReduce(product, n, len, (int)inv);
<i>2714</i>&nbsp;        } else {
<i>2715</i>&nbsp;            return implMontgomerySquare(a, n, len, inv, materialize(product, len));
<b class="nc"><i>2716</i>&nbsp;        }</b>
<i>2717</i>&nbsp;    }
<i>2718</i>&nbsp;
<b class="nc"><i>2719</i>&nbsp;    // Range-check everything.</b>
<b class="nc"><i>2720</i>&nbsp;    private static void implMontgomeryMultiplyChecks</b>
<b class="nc"><i>2721</i>&nbsp;        (int[] a, int[] b, int[] n, int len, int[] product) throws RuntimeException {</b>
<i>2722</i>&nbsp;        if (len % 2 != 0) {
<i>2723</i>&nbsp;            throw new IllegalArgumentException(&quot;input array length must be even: &quot; + len);
<i>2724</i>&nbsp;        }
<b class="nc"><i>2725</i>&nbsp;</b>
<b class="nc"><i>2726</i>&nbsp;        if (len &lt; 1) {</b>
<i>2727</i>&nbsp;            throw new IllegalArgumentException(&quot;invalid input length: &quot; + len);
<i>2728</i>&nbsp;        }
<b class="nc"><i>2729</i>&nbsp;</b>
<i>2730</i>&nbsp;        if (len &gt; a.length ||
<b class="nc"><i>2731</i>&nbsp;            len &gt; b.length ||</b>
<b class="nc"><i>2732</i>&nbsp;            len &gt; n.length ||</b>
<b class="nc"><i>2733</i>&nbsp;            (product != null &amp;&amp; len &gt; product.length)) {</b>
<b class="nc"><i>2734</i>&nbsp;            throw new IllegalArgumentException(&quot;input array length out of bound: &quot; + len);</b>
<i>2735</i>&nbsp;        }
<i>2736</i>&nbsp;    }
<b class="nc"><i>2737</i>&nbsp;</b>
<b class="nc"><i>2738</i>&nbsp;    // Make sure that the int array z (which is expected to contain</b>
<i>2739</i>&nbsp;    // the result of a Montgomery multiplication) is present and
<i>2740</i>&nbsp;    // sufficiently large.
<b class="nc"><i>2741</i>&nbsp;    private static int[] materialize(int[] z, int len) {</b>
<b class="nc"><i>2742</i>&nbsp;         if (z == null || z.length &lt; len)</b>
<b class="nc"><i>2743</i>&nbsp;             z = new int[len];</b>
<b class="nc"><i>2744</i>&nbsp;         return z;</b>
<b class="nc"><i>2745</i>&nbsp;    }</b>
<i>2746</i>&nbsp;
<i>2747</i>&nbsp;    // These methods are intended to be replaced by virtual machine
<i>2748</i>&nbsp;    // intrinsics.
<b class="nc"><i>2749</i>&nbsp;    @HotSpotIntrinsicCandidate</b>
<i>2750</i>&nbsp;    private static int[] implMontgomeryMultiply(int[] a, int[] b, int[] n, int len,
<i>2751</i>&nbsp;                                         long inv, int[] product) {
<b class="nc"><i>2752</i>&nbsp;        product = multiplyToLen(a, len, b, len, product);</b>
<i>2753</i>&nbsp;        return montReduce(product, n, len, (int)inv);
<i>2754</i>&nbsp;    }
<b class="nc"><i>2755</i>&nbsp;    @HotSpotIntrinsicCandidate</b>
<b class="nc"><i>2756</i>&nbsp;    private static int[] implMontgomerySquare(int[] a, int[] n, int len,</b>
<i>2757</i>&nbsp;                                       long inv, int[] product) {
<i>2758</i>&nbsp;        product = squareToLen(a, len, product);
<i>2759</i>&nbsp;        return montReduce(product, n, len, (int)inv);
<b class="nc"><i>2760</i>&nbsp;    }</b>
<i>2761</i>&nbsp;
<b class="nc"><i>2762</i>&nbsp;    static int[] bnExpModThreshTable = {7, 25, 81, 241, 673, 1793,</b>
<b class="nc"><i>2763</i>&nbsp;                                                Integer.MAX_VALUE}; // Sentinel</b>
<b class="nc"><i>2764</i>&nbsp;</b>
<b class="nc"><i>2765</i>&nbsp;    /**</b>
<b class="nc"><i>2766</i>&nbsp;     * Returns a BigInteger whose value is x to the power of y mod z.</b>
<b class="nc"><i>2767</i>&nbsp;     * Assumes: z is odd &amp;&amp; x &lt; z.</b>
<b class="nc"><i>2768</i>&nbsp;     */</b>
<b class="nc"><i>2769</i>&nbsp;    private BigInteger oddModPow(BigInteger y, BigInteger z) {</b>
<b class="nc"><i>2770</i>&nbsp;    /*</b>
<b class="nc"><i>2771</i>&nbsp;     * The algorithm is adapted from Colin Plumb&#39;s C library.</b>
<i>2772</i>&nbsp;     *
<i>2773</i>&nbsp;     * The window algorithm:
<i>2774</i>&nbsp;     * The idea is to keep a running product of b1 = n^(high-order bits of exp)
<b class="nc"><i>2775</i>&nbsp;     * and then keep appending exponent bits to it.  The following patterns</b>
<i>2776</i>&nbsp;     * apply to a 3-bit window (k = 3):
<i>2777</i>&nbsp;     * To append   0: square
<b class="nc"><i>2778</i>&nbsp;     * To append   1: square, multiply by n^1</b>
<b class="nc"><i>2779</i>&nbsp;     * To append  10: square, multiply by n^1, square</b>
<i>2780</i>&nbsp;     * To append  11: square, square, multiply by n^3
<b class="nc"><i>2781</i>&nbsp;     * To append 100: square, multiply by n^1, square, square</b>
<b class="nc"><i>2782</i>&nbsp;     * To append 101: square, square, square, multiply by n^5</b>
<b class="nc"><i>2783</i>&nbsp;     * To append 110: square, square, multiply by n^3, square</b>
<b class="nc"><i>2784</i>&nbsp;     * To append 111: square, square, square, multiply by n^7</b>
<i>2785</i>&nbsp;     *
<i>2786</i>&nbsp;     * Since each pattern involves only one multiply, the longer the pattern
<b class="nc"><i>2787</i>&nbsp;     * the better, except that a 0 (no multiplies) can be appended directly.</b>
<i>2788</i>&nbsp;     * We precompute a table of odd powers of n, up to 2^k, and can then
<b class="nc"><i>2789</i>&nbsp;     * multiply k bits of exponent at a time.  Actually, assuming random</b>
<b class="nc"><i>2790</i>&nbsp;     * exponents, there is on average one zero bit between needs to</b>
<b class="nc"><i>2791</i>&nbsp;     * multiply (1/2 of the time there&#39;s none, 1/4 of the time there&#39;s 1,</b>
<i>2792</i>&nbsp;     * 1/8 of the time, there&#39;s 2, 1/32 of the time, there&#39;s 3, etc.), so
<i>2793</i>&nbsp;     * you have to do one multiply per k+1 bits of exponent.
<i>2794</i>&nbsp;     *
<b class="nc"><i>2795</i>&nbsp;     * The loop walks down the exponent, squaring the result buffer as</b>
<i>2796</i>&nbsp;     * it goes.  There is a wbits+1 bit lookahead buffer, buf, that is
<b class="nc"><i>2797</i>&nbsp;     * filled with the upcoming exponent bits.  (What is read after the</b>
<i>2798</i>&nbsp;     * end of the exponent is unimportant, but it is filled with zero here.)
<b class="nc"><i>2799</i>&nbsp;     * When the most-significant bit of this buffer becomes set, i.e.</b>
<b class="nc"><i>2800</i>&nbsp;     * (buf &amp; tblmask) != 0, we have to decide what pattern to multiply</b>
<b class="nc"><i>2801</i>&nbsp;     * by, and when to do it.  We decide, remember to do it in future</b>
<b class="nc"><i>2802</i>&nbsp;     * after a suitable number of squarings have passed (e.g. a pattern</b>
<b class="nc"><i>2803</i>&nbsp;     * of &quot;100&quot; in the buffer requires that we multiply by n^1 immediately;</b>
<b class="nc"><i>2804</i>&nbsp;     * a pattern of &quot;110&quot; calls for multiplying by n^3 after one more</b>
<b class="nc"><i>2805</i>&nbsp;     * squaring), clear the buffer, and continue.</b>
<i>2806</i>&nbsp;     *
<i>2807</i>&nbsp;     * When we start, there is one more optimization: the result buffer
<i>2808</i>&nbsp;     * is implcitly one, so squaring it or multiplying by it can be
<i>2809</i>&nbsp;     * optimized away.  Further, if we start with a pattern like &quot;100&quot;
<b class="nc"><i>2810</i>&nbsp;     * in the lookahead window, rather than placing n into the buffer</b>
<b class="nc"><i>2811</i>&nbsp;     * and then starting to square it, we have already computed n^2</b>
<b class="nc"><i>2812</i>&nbsp;     * to compute the odd-powers table, so we can place that into</b>
<b class="nc"><i>2813</i>&nbsp;     * the buffer and save a squaring.</b>
<b class="nc"><i>2814</i>&nbsp;     *</b>
<i>2815</i>&nbsp;     * This means that if you have a k-bit window, to compute n^z,
<b class="nc"><i>2816</i>&nbsp;     * where z is the high k bits of the exponent, 1/2 of the time</b>
<b class="nc"><i>2817</i>&nbsp;     * it requires no squarings.  1/4 of the time, it requires 1</b>
<i>2818</i>&nbsp;     * squaring, ... 1/2^(k-1) of the time, it reqires k-2 squarings.
<i>2819</i>&nbsp;     * And the remaining 1/2^(k-1) of the time, the top k bits are a
<i>2820</i>&nbsp;     * 1 followed by k-1 0 bits, so it again only requires k-2
<b class="nc"><i>2821</i>&nbsp;     * squarings, not k-1.  The average of these is 1.  Add that</b>
<b class="nc"><i>2822</i>&nbsp;     * to the one squaring we have to do to compute the table,</b>
<b class="nc"><i>2823</i>&nbsp;     * and you&#39;ll see that a k-bit window saves k-2 squarings</b>
<b class="nc"><i>2824</i>&nbsp;     * as well as reducing the multiplies.  (It actually doesn&#39;t</b>
<i>2825</i>&nbsp;     * hurt in the case k = 1, either.)
<b class="nc"><i>2826</i>&nbsp;     */</b>
<b class="nc"><i>2827</i>&nbsp;        // Special case for exponent of one</b>
<b class="nc"><i>2828</i>&nbsp;        if (y.equals(ONE))</b>
<i>2829</i>&nbsp;            return this;
<i>2830</i>&nbsp;
<i>2831</i>&nbsp;        // Special case for base of zero
<i>2832</i>&nbsp;        if (signum == 0)
<b class="nc"><i>2833</i>&nbsp;            return ZERO;</b>
<b class="nc"><i>2834</i>&nbsp;</b>
<i>2835</i>&nbsp;        int[] base = mag.clone();
<i>2836</i>&nbsp;        int[] exp = y.mag;
<b class="nc"><i>2837</i>&nbsp;        int[] mod = z.mag;</b>
<b class="nc"><i>2838</i>&nbsp;        int modLen = mod.length;</b>
<b class="nc"><i>2839</i>&nbsp;</b>
<b class="nc"><i>2840</i>&nbsp;        // Make modLen even. It is conventional to use a cryptographic</b>
<i>2841</i>&nbsp;        // modulus that is 512, 768, 1024, or 2048 bits, so this code
<i>2842</i>&nbsp;        // will not normally be executed. However, it is necessary for
<i>2843</i>&nbsp;        // the correct functioning of the HotSpot intrinsics.
<i>2844</i>&nbsp;        if ((modLen &amp; 1) != 0) {
<b class="nc"><i>2845</i>&nbsp;            int[] x = new int[modLen + 1];</b>
<b class="nc"><i>2846</i>&nbsp;            System.arraycopy(mod, 0, x, 1, modLen);</b>
<i>2847</i>&nbsp;            mod = x;
<b class="nc"><i>2848</i>&nbsp;            modLen++;</b>
<i>2849</i>&nbsp;        }
<b class="nc"><i>2850</i>&nbsp;</b>
<i>2851</i>&nbsp;        // Select an appropriate window size
<b class="nc"><i>2852</i>&nbsp;        int wbits = 0;</b>
<i>2853</i>&nbsp;        int ebits = bitLength(exp, exp.length);
<i>2854</i>&nbsp;        // if exponent is 65537 (0x10001), use minimum window size
<i>2855</i>&nbsp;        if ((ebits != 17) || (exp[0] != 65537)) {
<i>2856</i>&nbsp;            while (ebits &gt; bnExpModThreshTable[wbits]) {
<i>2857</i>&nbsp;                wbits++;
<i>2858</i>&nbsp;            }
<i>2859</i>&nbsp;        }
<b class="nc"><i>2860</i>&nbsp;</b>
<b class="nc"><i>2861</i>&nbsp;        // Calculate appropriate table size</b>
<b class="nc"><i>2862</i>&nbsp;        int tblmask = 1 &lt;&lt; wbits;</b>
<i>2863</i>&nbsp;
<i>2864</i>&nbsp;        // Allocate table for precomputed odd powers of base in Montgomery form
<b class="nc"><i>2865</i>&nbsp;        int[][] table = new int[tblmask][];</b>
<b class="nc"><i>2866</i>&nbsp;        for (int i=0; i &lt; tblmask; i++)</b>
<b class="nc"><i>2867</i>&nbsp;            table[i] = new int[modLen];</b>
<b class="nc"><i>2868</i>&nbsp;</b>
<b class="nc"><i>2869</i>&nbsp;        // Compute the modular inverse of the least significant 64-bit</b>
<i>2870</i>&nbsp;        // digit of the modulus
<b class="nc"><i>2871</i>&nbsp;        long n0 = (mod[modLen-1] &amp; LONG_MASK) + ((mod[modLen-2] &amp; LONG_MASK) &lt;&lt; 32);</b>
<b class="nc"><i>2872</i>&nbsp;        long inv = -MutableBigInteger.inverseMod64(n0);</b>
<i>2873</i>&nbsp;
<b class="nc"><i>2874</i>&nbsp;        // Convert base to Montgomery form</b>
<b class="nc"><i>2875</i>&nbsp;        int[] a = leftShift(base, base.length, modLen &lt;&lt; 5);</b>
<i>2876</i>&nbsp;
<b class="nc"><i>2877</i>&nbsp;        MutableBigInteger q = new MutableBigInteger(),</b>
<i>2878</i>&nbsp;                          a2 = new MutableBigInteger(a),
<i>2879</i>&nbsp;                          b2 = new MutableBigInteger(mod);
<i>2880</i>&nbsp;        b2.normalize(); // MutableBigInteger.divide() assumes that its
<i>2881</i>&nbsp;                        // divisor is in normal form.
<i>2882</i>&nbsp;
<i>2883</i>&nbsp;        MutableBigInteger r= a2.divide(b2, q);
<i>2884</i>&nbsp;        table[0] = r.toIntArray();
<i>2885</i>&nbsp;
<b class="nc"><i>2886</i>&nbsp;        // Pad table[0] with leading zeros so its length is at least modLen</b>
<b class="nc"><i>2887</i>&nbsp;        if (table[0].length &lt; modLen) {</b>
<b class="nc"><i>2888</i>&nbsp;           int offset = modLen - table[0].length;</b>
<b class="nc"><i>2889</i>&nbsp;           int[] t2 = new int[modLen];</b>
<b class="nc"><i>2890</i>&nbsp;           System.arraycopy(table[0], 0, t2, offset, table[0].length);</b>
<b class="nc"><i>2891</i>&nbsp;           table[0] = t2;</b>
<b class="nc"><i>2892</i>&nbsp;        }</b>
<i>2893</i>&nbsp;
<b class="nc"><i>2894</i>&nbsp;        // Set b to the square of the base</b>
<i>2895</i>&nbsp;        int[] b = montgomerySquare(table[0], mod, modLen, inv, null);
<i>2896</i>&nbsp;
<i>2897</i>&nbsp;        // Set t to high half of b
<i>2898</i>&nbsp;        int[] t = Arrays.copyOf(b, modLen);
<i>2899</i>&nbsp;
<i>2900</i>&nbsp;        // Fill in the table with odd powers of the base
<b class="nc"><i>2901</i>&nbsp;        for (int i=1; i &lt; tblmask; i++) {</b>
<i>2902</i>&nbsp;            table[i] = montgomeryMultiply(t, table[i-1], mod, modLen, inv, null);
<b class="nc"><i>2903</i>&nbsp;        }</b>
<b class="nc"><i>2904</i>&nbsp;</b>
<i>2905</i>&nbsp;        // Pre load the window that slides over the exponent
<b class="nc"><i>2906</i>&nbsp;        int bitpos = 1 &lt;&lt; ((ebits-1) &amp; (32-1));</b>
<i>2907</i>&nbsp;
<i>2908</i>&nbsp;        int buf = 0;
<b class="nc"><i>2909</i>&nbsp;        int elen = exp.length;</b>
<i>2910</i>&nbsp;        int eIndex = 0;
<i>2911</i>&nbsp;        for (int i = 0; i &lt;= wbits; i++) {
<i>2912</i>&nbsp;            buf = (buf &lt;&lt; 1) | (((exp[eIndex] &amp; bitpos) != 0)?1:0);
<i>2913</i>&nbsp;            bitpos &gt;&gt;&gt;= 1;
<i>2914</i>&nbsp;            if (bitpos == 0) {
<i>2915</i>&nbsp;                eIndex++;
<b class="nc"><i>2916</i>&nbsp;                bitpos = 1 &lt;&lt; (32-1);</b>
<b class="nc"><i>2917</i>&nbsp;                elen--;</b>
<i>2918</i>&nbsp;            }
<i>2919</i>&nbsp;        }
<i>2920</i>&nbsp;
<i>2921</i>&nbsp;        int multpos = ebits;
<i>2922</i>&nbsp;
<i>2923</i>&nbsp;        // The first iteration, which is hoisted out of the main loop
<b class="nc"><i>2924</i>&nbsp;        ebits--;</b>
<b class="nc"><i>2925</i>&nbsp;        boolean isone = true;</b>
<i>2926</i>&nbsp;
<b class="nc"><i>2927</i>&nbsp;        multpos = ebits - wbits;</b>
<b class="nc"><i>2928</i>&nbsp;        while ((buf &amp; 1) == 0) {</b>
<i>2929</i>&nbsp;            buf &gt;&gt;&gt;= 1;
<b class="nc"><i>2930</i>&nbsp;            multpos++;</b>
<b class="nc"><i>2931</i>&nbsp;        }</b>
<i>2932</i>&nbsp;
<b class="nc"><i>2933</i>&nbsp;        int[] mult = table[buf &gt;&gt;&gt; 1];</b>
<b class="nc"><i>2934</i>&nbsp;</b>
<i>2935</i>&nbsp;        buf = 0;
<i>2936</i>&nbsp;        if (multpos == ebits)
<i>2937</i>&nbsp;            isone = false;
<i>2938</i>&nbsp;
<i>2939</i>&nbsp;        // The main loop
<i>2940</i>&nbsp;        while (true) {
<i>2941</i>&nbsp;            ebits--;
<b class="nc"><i>2942</i>&nbsp;            // Advance the window</b>
<b class="nc"><i>2943</i>&nbsp;            buf &lt;&lt;= 1;</b>
<i>2944</i>&nbsp;
<b class="nc"><i>2945</i>&nbsp;            if (elen != 0) {</b>
<b class="nc"><i>2946</i>&nbsp;                buf |= ((exp[eIndex] &amp; bitpos) != 0) ? 1 : 0;</b>
<b class="nc"><i>2947</i>&nbsp;                bitpos &gt;&gt;&gt;= 1;</b>
<i>2948</i>&nbsp;                if (bitpos == 0) {
<b class="nc"><i>2949</i>&nbsp;                    eIndex++;</b>
<b class="nc"><i>2950</i>&nbsp;                    bitpos = 1 &lt;&lt; (32-1);</b>
<i>2951</i>&nbsp;                    elen--;
<b class="nc"><i>2952</i>&nbsp;                }</b>
<i>2953</i>&nbsp;            }
<i>2954</i>&nbsp;
<i>2955</i>&nbsp;            // Examine the window for pending multiplies
<i>2956</i>&nbsp;            if ((buf &amp; tblmask) != 0) {
<i>2957</i>&nbsp;                multpos = ebits - wbits;
<i>2958</i>&nbsp;                while ((buf &amp; 1) == 0) {
<i>2959</i>&nbsp;                    buf &gt;&gt;&gt;= 1;
<b class="nc"><i>2960</i>&nbsp;                    multpos++;</b>
<b class="nc"><i>2961</i>&nbsp;                }</b>
<i>2962</i>&nbsp;                mult = table[buf &gt;&gt;&gt; 1];
<b class="nc"><i>2963</i>&nbsp;                buf = 0;</b>
<b class="nc"><i>2964</i>&nbsp;            }</b>
<b class="nc"><i>2965</i>&nbsp;</b>
<b class="nc"><i>2966</i>&nbsp;            // Perform multiply</b>
<b class="nc"><i>2967</i>&nbsp;            if (ebits == multpos) {</b>
<b class="nc"><i>2968</i>&nbsp;                if (isone) {</b>
<i>2969</i>&nbsp;                    b = mult.clone();
<b class="nc"><i>2970</i>&nbsp;                    isone = false;</b>
<b class="nc"><i>2971</i>&nbsp;                } else {</b>
<b class="nc"><i>2972</i>&nbsp;                    t = b;</b>
<i>2973</i>&nbsp;                    a = montgomeryMultiply(t, mult, mod, modLen, inv, a);
<i>2974</i>&nbsp;                    t = a; a = b; b = t;
<b class="nc"><i>2975</i>&nbsp;                }</b>
<i>2976</i>&nbsp;            }
<i>2977</i>&nbsp;
<i>2978</i>&nbsp;            // Check if done
<i>2979</i>&nbsp;            if (ebits == 0)
<i>2980</i>&nbsp;                break;
<i>2981</i>&nbsp;
<i>2982</i>&nbsp;            // Square the input
<i>2983</i>&nbsp;            if (!isone) {
<i>2984</i>&nbsp;                t = b;
<i>2985</i>&nbsp;                a = montgomerySquare(t, mod, modLen, inv, a);
<b class="nc"><i>2986</i>&nbsp;                t = a; a = b; b = t;</b>
<b class="nc"><i>2987</i>&nbsp;            }</b>
<b class="nc"><i>2988</i>&nbsp;        }</b>
<i>2989</i>&nbsp;
<b class="nc"><i>2990</i>&nbsp;        // Convert result out of Montgomery form and return</b>
<i>2991</i>&nbsp;        int[] t2 = new int[2*modLen];
<b class="nc"><i>2992</i>&nbsp;        System.arraycopy(b, 0, t2, modLen, modLen);</b>
<b class="nc"><i>2993</i>&nbsp;</b>
<i>2994</i>&nbsp;        b = montReduce(t2, mod, modLen, (int)inv);
<b class="nc"><i>2995</i>&nbsp;</b>
<b class="nc"><i>2996</i>&nbsp;        t2 = Arrays.copyOf(b, modLen);</b>
<b class="nc"><i>2997</i>&nbsp;</b>
<b class="nc"><i>2998</i>&nbsp;        return new BigInteger(1, t2);</b>
<b class="nc"><i>2999</i>&nbsp;    }</b>
<b class="nc"><i>3000</i>&nbsp;</b>
<i>3001</i>&nbsp;    /**
<i>3002</i>&nbsp;     * Montgomery reduce n, modulo mod.  This reduces modulo mod and divides
<b class="nc"><i>3003</i>&nbsp;     * by 2^(32*mlen). Adapted from Colin Plumb&#39;s C library.</b>
<i>3004</i>&nbsp;     */
<i>3005</i>&nbsp;    private static int[] montReduce(int[] n, int[] mod, int mlen, int inv) {
<i>3006</i>&nbsp;        int c=0;
<i>3007</i>&nbsp;        int len = mlen;
<i>3008</i>&nbsp;        int offset=0;
<i>3009</i>&nbsp;
<i>3010</i>&nbsp;        do {
<b class="nc"><i>3011</i>&nbsp;            int nEnd = n[n.length-1-offset];</b>
<b class="nc"><i>3012</i>&nbsp;            int carry = mulAdd(n, mod, offset, mlen, inv * nEnd);</b>
<i>3013</i>&nbsp;            c += addOne(n, offset, mlen, carry);
<i>3014</i>&nbsp;            offset++;
<b class="nc"><i>3015</i>&nbsp;        } while (--len &gt; 0);</b>
<b class="nc"><i>3016</i>&nbsp;</b>
<b class="nc"><i>3017</i>&nbsp;        while (c &gt; 0)</b>
<i>3018</i>&nbsp;            c += subN(n, mod, mlen);
<i>3019</i>&nbsp;
<b class="nc"><i>3020</i>&nbsp;        while (intArrayCmpToLen(n, mod, mlen) &gt;= 0)</b>
<b class="nc"><i>3021</i>&nbsp;            subN(n, mod, mlen);</b>
<i>3022</i>&nbsp;
<b class="nc"><i>3023</i>&nbsp;        return n;</b>
<i>3024</i>&nbsp;    }
<i>3025</i>&nbsp;
<i>3026</i>&nbsp;
<i>3027</i>&nbsp;    /*
<i>3028</i>&nbsp;     * Returns -1, 0 or +1 as big-endian unsigned int array arg1 is less than,
<i>3029</i>&nbsp;     * equal to, or greater than arg2 up to length len.
<i>3030</i>&nbsp;     */
<i>3031</i>&nbsp;    private static int intArrayCmpToLen(int[] arg1, int[] arg2, int len) {
<i>3032</i>&nbsp;        for (int i=0; i &lt; len; i++) {
<i>3033</i>&nbsp;            long b1 = arg1[i] &amp; LONG_MASK;
<i>3034</i>&nbsp;            long b2 = arg2[i] &amp; LONG_MASK;
<i>3035</i>&nbsp;            if (b1 &lt; b2)
<b class="nc"><i>3036</i>&nbsp;                return -1;</b>
<b class="nc"><i>3037</i>&nbsp;            if (b1 &gt; b2)</b>
<i>3038</i>&nbsp;                return 1;
<b class="nc"><i>3039</i>&nbsp;        }</b>
<b class="nc"><i>3040</i>&nbsp;        return 0;</b>
<i>3041</i>&nbsp;    }
<i>3042</i>&nbsp;
<b class="nc"><i>3043</i>&nbsp;    /**</b>
<b class="nc"><i>3044</i>&nbsp;     * Subtracts two numbers of same length, returning borrow.</b>
<b class="nc"><i>3045</i>&nbsp;     */</b>
<i>3046</i>&nbsp;    private static int subN(int[] a, int[] b, int len) {
<b class="nc"><i>3047</i>&nbsp;        long sum = 0;</b>
<b class="nc"><i>3048</i>&nbsp;</b>
<i>3049</i>&nbsp;        while (--len &gt;= 0) {
<b class="nc"><i>3050</i>&nbsp;            sum = (a[len] &amp; LONG_MASK) -</b>
<b class="nc"><i>3051</i>&nbsp;                 (b[len] &amp; LONG_MASK) + (sum &gt;&gt; 32);</b>
<i>3052</i>&nbsp;            a[len] = (int)sum;
<b class="nc"><i>3053</i>&nbsp;        }</b>
<b class="nc"><i>3054</i>&nbsp;</b>
<i>3055</i>&nbsp;        return (int)(sum &gt;&gt; 32);
<i>3056</i>&nbsp;    }
<i>3057</i>&nbsp;
<i>3058</i>&nbsp;    /**
<i>3059</i>&nbsp;     * Multiply an array by one word k and add to result, return the carry
<i>3060</i>&nbsp;     */
<i>3061</i>&nbsp;    static int mulAdd(int[] out, int[] in, int offset, int len, int k) {
<i>3062</i>&nbsp;        implMulAddCheck(out, in, offset, len, k);
<i>3063</i>&nbsp;        return implMulAdd(out, in, offset, len, k);
<i>3064</i>&nbsp;    }
<i>3065</i>&nbsp;
<i>3066</i>&nbsp;    /**
<i>3067</i>&nbsp;     * Parameters validation.
<i>3068</i>&nbsp;     */
<i>3069</i>&nbsp;    private static void implMulAddCheck(int[] out, int[] in, int offset, int len, int k) {
<b class="nc"><i>3070</i>&nbsp;        if (len &gt; in.length) {</b>
<b class="nc"><i>3071</i>&nbsp;            throw new IllegalArgumentException(&quot;input length is out of bound: &quot; + len + &quot; &gt; &quot; + in.length);</b>
<b class="nc"><i>3072</i>&nbsp;        }</b>
<b class="nc"><i>3073</i>&nbsp;        if (offset &lt; 0) {</b>
<b class="nc"><i>3074</i>&nbsp;            throw new IllegalArgumentException(&quot;input offset is invalid: &quot; + offset);</b>
<b class="nc"><i>3075</i>&nbsp;        }</b>
<i>3076</i>&nbsp;        if (offset &gt; (out.length - 1)) {
<i>3077</i>&nbsp;            throw new IllegalArgumentException(&quot;input offset is out of bound: &quot; + offset + &quot; &gt; &quot; + (out.length - 1));
<i>3078</i>&nbsp;        }
<b class="nc"><i>3079</i>&nbsp;        if (len &gt; (out.length - offset)) {</b>
<i>3080</i>&nbsp;            throw new IllegalArgumentException(&quot;input len is out of bound: &quot; + len + &quot; &gt; &quot; + (out.length - offset));
<i>3081</i>&nbsp;        }
<i>3082</i>&nbsp;    }
<i>3083</i>&nbsp;
<i>3084</i>&nbsp;    /**
<i>3085</i>&nbsp;     * Java Runtime may use intrinsic for this method.
<i>3086</i>&nbsp;     */
<i>3087</i>&nbsp;    @HotSpotIntrinsicCandidate
<i>3088</i>&nbsp;    private static int implMulAdd(int[] out, int[] in, int offset, int len, int k) {
<i>3089</i>&nbsp;        long kLong = k &amp; LONG_MASK;
<i>3090</i>&nbsp;        long carry = 0;
<i>3091</i>&nbsp;
<i>3092</i>&nbsp;        offset = out.length-offset - 1;
<b class="nc"><i>3093</i>&nbsp;        for (int j=len-1; j &gt;= 0; j--) {</b>
<b class="nc"><i>3094</i>&nbsp;            long product = (in[j] &amp; LONG_MASK) * kLong +</b>
<b class="nc"><i>3095</i>&nbsp;                           (out[offset] &amp; LONG_MASK) + carry;</b>
<b class="nc"><i>3096</i>&nbsp;            out[offset--] = (int)product;</b>
<i>3097</i>&nbsp;            carry = product &gt;&gt;&gt; 32;
<b class="nc"><i>3098</i>&nbsp;        }</b>
<b class="nc"><i>3099</i>&nbsp;        return (int)carry;</b>
<b class="nc"><i>3100</i>&nbsp;    }</b>
<i>3101</i>&nbsp;
<b class="nc"><i>3102</i>&nbsp;    /**</b>
<b class="nc"><i>3103</i>&nbsp;     * Add one word to the number a mlen words into a. Return the resulting</b>
<b class="nc"><i>3104</i>&nbsp;     * carry.</b>
<b class="nc"><i>3105</i>&nbsp;     */</b>
<b class="nc"><i>3106</i>&nbsp;    static int addOne(int[] a, int offset, int mlen, int carry) {</b>
<b class="nc"><i>3107</i>&nbsp;        offset = a.length-1-mlen-offset;</b>
<i>3108</i>&nbsp;        long t = (a[offset] &amp; LONG_MASK) + (carry &amp; LONG_MASK);
<b class="nc"><i>3109</i>&nbsp;</b>
<i>3110</i>&nbsp;        a[offset] = (int)t;
<b class="nc"><i>3111</i>&nbsp;        if ((t &gt;&gt;&gt; 32) == 0)</b>
<b class="nc"><i>3112</i>&nbsp;            return 0;</b>
<b class="nc"><i>3113</i>&nbsp;        while (--mlen &gt;= 0) {</b>
<b class="nc"><i>3114</i>&nbsp;            if (--offset &lt; 0) { // Carry out of number</b>
<i>3115</i>&nbsp;                return 1;
<b class="nc"><i>3116</i>&nbsp;            } else {</b>
<i>3117</i>&nbsp;                a[offset]++;
<i>3118</i>&nbsp;                if (a[offset] != 0)
<i>3119</i>&nbsp;                    return 0;
<i>3120</i>&nbsp;            }
<i>3121</i>&nbsp;        }
<i>3122</i>&nbsp;        return 1;
<i>3123</i>&nbsp;    }
<i>3124</i>&nbsp;
<i>3125</i>&nbsp;    /**
<i>3126</i>&nbsp;     * Returns a BigInteger whose value is (this ** exponent) mod (2**p)
<i>3127</i>&nbsp;     */
<i>3128</i>&nbsp;    private BigInteger modPow2(BigInteger exponent, int p) {
<i>3129</i>&nbsp;        /*
<b class="nc"><i>3130</i>&nbsp;         * Perform exponentiation using repeated squaring trick, chopping off</b>
<b class="nc"><i>3131</i>&nbsp;         * high order bits as indicated by modulus.</b>
<b class="nc"><i>3132</i>&nbsp;         */</b>
<b class="nc"><i>3133</i>&nbsp;        BigInteger result = ONE;</b>
<b class="nc"><i>3134</i>&nbsp;        BigInteger baseToPow2 = this.mod2(p);</b>
<b class="nc"><i>3135</i>&nbsp;        int expOffset = 0;</b>
<i>3136</i>&nbsp;
<i>3137</i>&nbsp;        int limit = exponent.bitLength();
<i>3138</i>&nbsp;
<b class="nc"><i>3139</i>&nbsp;        if (this.testBit(0))</b>
<i>3140</i>&nbsp;           limit = (p-1) &lt; limit ? (p-1) : limit;
<i>3141</i>&nbsp;
<i>3142</i>&nbsp;        while (expOffset &lt; limit) {
<i>3143</i>&nbsp;            if (exponent.testBit(expOffset))
<i>3144</i>&nbsp;                result = result.multiply(baseToPow2).mod2(p);
<i>3145</i>&nbsp;            expOffset++;
<i>3146</i>&nbsp;            if (expOffset &lt; limit)
<i>3147</i>&nbsp;                baseToPow2 = baseToPow2.square().mod2(p);
<i>3148</i>&nbsp;        }
<i>3149</i>&nbsp;
<i>3150</i>&nbsp;        return result;
<i>3151</i>&nbsp;    }
<b class="nc"><i>3152</i>&nbsp;</b>
<b class="nc"><i>3153</i>&nbsp;    /**</b>
<b class="nc"><i>3154</i>&nbsp;     * Returns a BigInteger whose value is this mod(2**p).</b>
<b class="nc"><i>3155</i>&nbsp;     * Assumes that this {@code BigInteger &gt;= 0} and {@code p &gt; 0}.</b>
<i>3156</i>&nbsp;     */
<i>3157</i>&nbsp;    private BigInteger mod2(int p) {
<b class="nc"><i>3158</i>&nbsp;        if (bitLength() &lt;= p)</b>
<b class="nc"><i>3159</i>&nbsp;            return this;</b>
<i>3160</i>&nbsp;
<b class="nc"><i>3161</i>&nbsp;        // Copy remaining ints of mag</b>
<b class="nc"><i>3162</i>&nbsp;        int numInts = (p + 31) &gt;&gt;&gt; 5;</b>
<b class="nc"><i>3163</i>&nbsp;        int[] mag = new int[numInts];</b>
<b class="nc"><i>3164</i>&nbsp;        System.arraycopy(this.mag, (this.mag.length - numInts), mag, 0, numInts);</b>
<b class="nc"><i>3165</i>&nbsp;</b>
<b class="nc"><i>3166</i>&nbsp;        // Mask out any excess bits</b>
<b class="nc"><i>3167</i>&nbsp;        int excessBits = (numInts &lt;&lt; 5) - p;</b>
<b class="nc"><i>3168</i>&nbsp;        mag[0] &amp;= (1L &lt;&lt; (32-excessBits)) - 1;</b>
<b class="nc"><i>3169</i>&nbsp;</b>
<i>3170</i>&nbsp;        return (mag[0] == 0 ? new BigInteger(1, mag) : new BigInteger(mag, 1));
<b class="nc"><i>3171</i>&nbsp;    }</b>
<i>3172</i>&nbsp;
<i>3173</i>&nbsp;    /**
<b class="nc"><i>3174</i>&nbsp;     * Returns a BigInteger whose value is {@code (this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m)}.</b>
<b class="nc"><i>3175</i>&nbsp;     *</b>
<b class="nc"><i>3176</i>&nbsp;     * @param  m the modulus.</b>
<b class="nc"><i>3177</i>&nbsp;     * @return {@code this}&lt;sup&gt;-1&lt;/sup&gt; {@code mod m}.</b>
<i>3178</i>&nbsp;     * @throws ArithmeticException {@code  m} &amp;le; 0, or this BigInteger
<i>3179</i>&nbsp;     *         has no multiplicative inverse mod m (that is, this BigInteger
<b class="nc"><i>3180</i>&nbsp;     *         is not &lt;i&gt;relatively prime&lt;/i&gt; to m).</b>
<i>3181</i>&nbsp;     */
<b class="nc"><i>3182</i>&nbsp;    public BigInteger modInverse(BigInteger m) {</b>
<b class="nc"><i>3183</i>&nbsp;        if (m.signum != 1)</b>
<b class="nc"><i>3184</i>&nbsp;            throw new ArithmeticException(&quot;BigInteger: modulus not positive&quot;);</b>
<b class="nc"><i>3185</i>&nbsp;</b>
<b class="nc"><i>3186</i>&nbsp;        if (m.equals(ONE))</b>
<i>3187</i>&nbsp;            return ZERO;
<b class="nc"><i>3188</i>&nbsp;</b>
<b class="nc"><i>3189</i>&nbsp;        // Calculate (this mod m)</b>
<i>3190</i>&nbsp;        BigInteger modVal = this;
<i>3191</i>&nbsp;        if (signum &lt; 0 || (this.compareMagnitude(m) &gt;= 0))
<b class="nc"><i>3192</i>&nbsp;            modVal = this.mod(m);</b>
<i>3193</i>&nbsp;
<i>3194</i>&nbsp;        if (modVal.equals(ONE))
<i>3195</i>&nbsp;            return ONE;
<b class="nc"><i>3196</i>&nbsp;</b>
<b class="nc"><i>3197</i>&nbsp;        MutableBigInteger a = new MutableBigInteger(modVal);</b>
<b class="nc"><i>3198</i>&nbsp;        MutableBigInteger b = new MutableBigInteger(m);</b>
<b class="nc"><i>3199</i>&nbsp;</b>
<b class="nc"><i>3200</i>&nbsp;        MutableBigInteger result = a.mutableModInverse(b);</b>
<b class="nc"><i>3201</i>&nbsp;        return result.toBigInteger(1);</b>
<i>3202</i>&nbsp;    }
<b class="nc"><i>3203</i>&nbsp;</b>
<i>3204</i>&nbsp;    // Shift Operations
<i>3205</i>&nbsp;
<i>3206</i>&nbsp;    /**
<i>3207</i>&nbsp;     * Returns a BigInteger whose value is {@code (this &lt;&lt; n)}.
<i>3208</i>&nbsp;     * The shift distance, {@code n}, may be negative, in which case
<i>3209</i>&nbsp;     * this method performs a right shift.
<i>3210</i>&nbsp;     * (Computes &lt;code&gt;floor(this * 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.)
<i>3211</i>&nbsp;     *
<i>3212</i>&nbsp;     * @param  n shift distance, in bits.
<i>3213</i>&nbsp;     * @return {@code this &lt;&lt; n}
<i>3214</i>&nbsp;     * @see #shiftRight
<i>3215</i>&nbsp;     */
<i>3216</i>&nbsp;    public BigInteger shiftLeft(int n) {
<b class="nc"><i>3217</i>&nbsp;        if (signum == 0)</b>
<b class="nc"><i>3218</i>&nbsp;            return ZERO;</b>
<b class="nc"><i>3219</i>&nbsp;        if (n &gt; 0) {</b>
<b class="nc"><i>3220</i>&nbsp;            return new BigInteger(shiftLeft(mag, n), signum);</b>
<i>3221</i>&nbsp;        } else if (n == 0) {
<b class="nc"><i>3222</i>&nbsp;            return this;</b>
<i>3223</i>&nbsp;        } else {
<i>3224</i>&nbsp;            // Possible int overflow in (-n) is not a trouble,
<i>3225</i>&nbsp;            // because shiftRightImpl considers its argument unsigned
<i>3226</i>&nbsp;            return shiftRightImpl(-n);
<i>3227</i>&nbsp;        }
<i>3228</i>&nbsp;    }
<i>3229</i>&nbsp;
<i>3230</i>&nbsp;    /**
<i>3231</i>&nbsp;     * Returns a magnitude array whose value is {@code (mag &lt;&lt; n)}.
<i>3232</i>&nbsp;     * The shift distance, {@code n}, is considered unnsigned.
<i>3233</i>&nbsp;     * (Computes &lt;code&gt;this * 2&lt;sup&gt;n&lt;/sup&gt;&lt;/code&gt;.)
<b class="nc"><i>3234</i>&nbsp;     *</b>
<b class="nc"><i>3235</i>&nbsp;     * @param mag magnitude, the most-significant int ({@code mag[0]}) must be non-zero.</b>
<b class="nc"><i>3236</i>&nbsp;     * @param  n unsigned shift distance, in bits.</b>
<b class="nc"><i>3237</i>&nbsp;     * @return {@code mag &lt;&lt; n}</b>
<i>3238</i>&nbsp;     */
<b class="nc"><i>3239</i>&nbsp;    private static int[] shiftLeft(int[] mag, int n) {</b>
<i>3240</i>&nbsp;        int nInts = n &gt;&gt;&gt; 5;
<i>3241</i>&nbsp;        int nBits = n &amp; 0x1f;
<i>3242</i>&nbsp;        int magLen = mag.length;
<i>3243</i>&nbsp;        int newMag[] = null;
<i>3244</i>&nbsp;
<i>3245</i>&nbsp;        if (nBits == 0) {
<i>3246</i>&nbsp;            newMag = new int[magLen + nInts];
<i>3247</i>&nbsp;            System.arraycopy(mag, 0, newMag, 0, magLen);
<i>3248</i>&nbsp;        } else {
<i>3249</i>&nbsp;            int i = 0;
<i>3250</i>&nbsp;            int nBits2 = 32 - nBits;
<b class="nc"><i>3251</i>&nbsp;            int highBits = mag[0] &gt;&gt;&gt; nBits2;</b>
<b class="nc"><i>3252</i>&nbsp;            if (highBits != 0) {</b>
<b class="nc"><i>3253</i>&nbsp;                newMag = new int[magLen + nInts + 1];</b>
<b class="nc"><i>3254</i>&nbsp;                newMag[i++] = highBits;</b>
<i>3255</i>&nbsp;            } else {
<b class="nc"><i>3256</i>&nbsp;                newMag = new int[magLen + nInts];</b>
<i>3257</i>&nbsp;            }
<i>3258</i>&nbsp;            int j=0;
<i>3259</i>&nbsp;            while (j &lt; magLen-1)
<i>3260</i>&nbsp;                newMag[i++] = mag[j++] &lt;&lt; nBits | mag[j] &gt;&gt;&gt; nBits2;
<i>3261</i>&nbsp;            newMag[i] = mag[j] &lt;&lt; nBits;
<i>3262</i>&nbsp;        }
<i>3263</i>&nbsp;        return newMag;
<i>3264</i>&nbsp;    }
<i>3265</i>&nbsp;
<i>3266</i>&nbsp;    /**
<b class="nc"><i>3267</i>&nbsp;     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}.  Sign</b>
<b class="nc"><i>3268</i>&nbsp;     * extension is performed.  The shift distance, {@code n}, may be</b>
<b class="nc"><i>3269</i>&nbsp;     * negative, in which case this method performs a left shift.</b>
<i>3270</i>&nbsp;     * (Computes &lt;code&gt;floor(this / 2&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.)
<b class="nc"><i>3271</i>&nbsp;     *</b>
<i>3272</i>&nbsp;     * @param  n shift distance, in bits.
<i>3273</i>&nbsp;     * @return {@code this &gt;&gt; n}
<i>3274</i>&nbsp;     * @see #shiftLeft
<i>3275</i>&nbsp;     */
<i>3276</i>&nbsp;    public BigInteger shiftRight(int n) {
<i>3277</i>&nbsp;        if (signum == 0)
<i>3278</i>&nbsp;            return ZERO;
<i>3279</i>&nbsp;        if (n &gt; 0) {
<i>3280</i>&nbsp;            return shiftRightImpl(n);
<i>3281</i>&nbsp;        } else if (n == 0) {
<i>3282</i>&nbsp;            return this;
<i>3283</i>&nbsp;        } else {
<i>3284</i>&nbsp;            // Possible int overflow in {@code -n} is not a trouble,
<b class="nc"><i>3285</i>&nbsp;            // because shiftLeft considers its argument unsigned</b>
<b class="nc"><i>3286</i>&nbsp;            return new BigInteger(shiftLeft(mag, -n), signum);</b>
<b class="nc"><i>3287</i>&nbsp;        }</b>
<b class="nc"><i>3288</i>&nbsp;    }</b>
<i>3289</i>&nbsp;
<b class="nc"><i>3290</i>&nbsp;    /**</b>
<i>3291</i>&nbsp;     * Returns a BigInteger whose value is {@code (this &gt;&gt; n)}. The shift
<i>3292</i>&nbsp;     * distance, {@code n}, is considered unsigned.
<i>3293</i>&nbsp;     * (Computes &lt;code&gt;floor(this * 2&lt;sup&gt;-n&lt;/sup&gt;)&lt;/code&gt;.)
<i>3294</i>&nbsp;     *
<i>3295</i>&nbsp;     * @param  n unsigned shift distance, in bits.
<i>3296</i>&nbsp;     * @return {@code this &gt;&gt; n}
<i>3297</i>&nbsp;     */
<i>3298</i>&nbsp;    private BigInteger shiftRightImpl(int n) {
<i>3299</i>&nbsp;        int nInts = n &gt;&gt;&gt; 5;
<i>3300</i>&nbsp;        int nBits = n &amp; 0x1f;
<i>3301</i>&nbsp;        int magLen = mag.length;
<i>3302</i>&nbsp;        int newMag[] = null;
<i>3303</i>&nbsp;
<i>3304</i>&nbsp;        // Special case: entire contents shifted off the end
<b class="nc"><i>3305</i>&nbsp;        if (nInts &gt;= magLen)</b>
<b class="nc"><i>3306</i>&nbsp;            return (signum &gt;= 0 ? ZERO : negConst[1]);</b>
<i>3307</i>&nbsp;
<b class="nc"><i>3308</i>&nbsp;        if (nBits == 0) {</b>
<i>3309</i>&nbsp;            int newMagLen = magLen - nInts;
<i>3310</i>&nbsp;            newMag = Arrays.copyOf(mag, newMagLen);
<i>3311</i>&nbsp;        } else {
<i>3312</i>&nbsp;            int i = 0;
<i>3313</i>&nbsp;            int highBits = mag[0] &gt;&gt;&gt; nBits;
<i>3314</i>&nbsp;            if (highBits != 0) {
<i>3315</i>&nbsp;                newMag = new int[magLen - nInts];
<i>3316</i>&nbsp;                newMag[i++] = highBits;
<i>3317</i>&nbsp;            } else {
<i>3318</i>&nbsp;                newMag = new int[magLen - nInts -1];
<i>3319</i>&nbsp;            }
<b class="nc"><i>3320</i>&nbsp;</b>
<b class="nc"><i>3321</i>&nbsp;            int nBits2 = 32 - nBits;</b>
<i>3322</i>&nbsp;            int j=0;
<b class="nc"><i>3323</i>&nbsp;            while (j &lt; magLen - nInts - 1)</b>
<b class="nc"><i>3324</i>&nbsp;                newMag[i++] = (mag[j++] &lt;&lt; nBits2) | (mag[j] &gt;&gt;&gt; nBits);</b>
<i>3325</i>&nbsp;        }
<b class="nc"><i>3326</i>&nbsp;</b>
<b class="nc"><i>3327</i>&nbsp;        if (signum &lt; 0) {</b>
<i>3328</i>&nbsp;            // Find out whether any one-bits were shifted off the end.
<b class="nc"><i>3329</i>&nbsp;            boolean onesLost = false;</b>
<i>3330</i>&nbsp;            for (int i=magLen-1, j=magLen-nInts; i &gt;= j &amp;&amp; !onesLost; i--)
<b class="nc"><i>3331</i>&nbsp;                onesLost = (mag[i] != 0);</b>
<i>3332</i>&nbsp;            if (!onesLost &amp;&amp; nBits != 0)
<i>3333</i>&nbsp;                onesLost = (mag[magLen - nInts - 1] &lt;&lt; (32 - nBits) != 0);
<i>3334</i>&nbsp;
<i>3335</i>&nbsp;            if (onesLost)
<i>3336</i>&nbsp;                newMag = javaIncrement(newMag);
<i>3337</i>&nbsp;        }
<i>3338</i>&nbsp;
<i>3339</i>&nbsp;        return new BigInteger(newMag, signum);
<i>3340</i>&nbsp;    }
<i>3341</i>&nbsp;
<i>3342</i>&nbsp;    int[] javaIncrement(int[] val) {
<i>3343</i>&nbsp;        int lastSum = 0;
<b class="nc"><i>3344</i>&nbsp;        for (int i=val.length-1;  i &gt;= 0 &amp;&amp; lastSum == 0; i--)</b>
<b class="nc"><i>3345</i>&nbsp;            lastSum = (val[i] += 1);</b>
<i>3346</i>&nbsp;        if (lastSum == 0) {
<b class="nc"><i>3347</i>&nbsp;            val = new int[val.length+1];</b>
<b class="nc"><i>3348</i>&nbsp;            val[0] = 1;</b>
<i>3349</i>&nbsp;        }
<b class="nc"><i>3350</i>&nbsp;        return val;</b>
<b class="nc"><i>3351</i>&nbsp;    }</b>
<i>3352</i>&nbsp;
<b class="nc"><i>3353</i>&nbsp;    // Bitwise Operations</b>
<i>3354</i>&nbsp;
<b class="nc"><i>3355</i>&nbsp;    /**</b>
<i>3356</i>&nbsp;     * Returns a BigInteger whose value is {@code (this &amp; val)}.  (This
<i>3357</i>&nbsp;     * method returns a negative BigInteger if and only if this and val are
<i>3358</i>&nbsp;     * both negative.)
<i>3359</i>&nbsp;     *
<i>3360</i>&nbsp;     * @param val value to be AND&#39;ed with this BigInteger.
<i>3361</i>&nbsp;     * @return {@code this &amp; val}
<i>3362</i>&nbsp;     */
<i>3363</i>&nbsp;    public BigInteger and(BigInteger val) {
<i>3364</i>&nbsp;        int[] result = new int[Math.max(intLength(), val.intLength())];
<i>3365</i>&nbsp;        for (int i=0; i &lt; result.length; i++)
<i>3366</i>&nbsp;            result[i] = (getInt(result.length-i-1)
<i>3367</i>&nbsp;                         &amp; val.getInt(result.length-i-1));
<b class="nc"><i>3368</i>&nbsp;</b>
<b class="nc"><i>3369</i>&nbsp;        return valueOf(result);</b>
<i>3370</i>&nbsp;    }
<b class="nc"><i>3371</i>&nbsp;</b>
<b class="nc"><i>3372</i>&nbsp;    /**</b>
<i>3373</i>&nbsp;     * Returns a BigInteger whose value is {@code (this | val)}.  (This method
<b class="nc"><i>3374</i>&nbsp;     * returns a negative BigInteger if and only if either this or val is</b>
<b class="nc"><i>3375</i>&nbsp;     * negative.)</b>
<i>3376</i>&nbsp;     *
<b class="nc"><i>3377</i>&nbsp;     * @param val value to be OR&#39;ed with this BigInteger.</b>
<i>3378</i>&nbsp;     * @return {@code this | val}
<b class="nc"><i>3379</i>&nbsp;     */</b>
<i>3380</i>&nbsp;    public BigInteger or(BigInteger val) {
<i>3381</i>&nbsp;        int[] result = new int[Math.max(intLength(), val.intLength())];
<i>3382</i>&nbsp;        for (int i=0; i &lt; result.length; i++)
<i>3383</i>&nbsp;            result[i] = (getInt(result.length-i-1)
<i>3384</i>&nbsp;                         | val.getInt(result.length-i-1));
<i>3385</i>&nbsp;
<i>3386</i>&nbsp;        return valueOf(result);
<i>3387</i>&nbsp;    }
<i>3388</i>&nbsp;
<i>3389</i>&nbsp;    /**
<i>3390</i>&nbsp;     * Returns a BigInteger whose value is {@code (this ^ val)}.  (This method
<b class="nc"><i>3391</i>&nbsp;     * returns a negative BigInteger if and only if exactly one of this and</b>
<b class="nc"><i>3392</i>&nbsp;     * val are negative.)</b>
<b class="nc"><i>3393</i>&nbsp;     *</b>
<b class="nc"><i>3394</i>&nbsp;     * @param val value to be XOR&#39;ed with this BigInteger.</b>
<b class="nc"><i>3395</i>&nbsp;     * @return {@code this ^ val}</b>
<i>3396</i>&nbsp;     */
<i>3397</i>&nbsp;    public BigInteger xor(BigInteger val) {
<i>3398</i>&nbsp;        int[] result = new int[Math.max(intLength(), val.intLength())];
<b class="nc"><i>3399</i>&nbsp;        for (int i=0; i &lt; result.length; i++)</b>
<i>3400</i>&nbsp;            result[i] = (getInt(result.length-i-1)
<b class="nc"><i>3401</i>&nbsp;                         ^ val.getInt(result.length-i-1));</b>
<i>3402</i>&nbsp;
<b class="nc"><i>3403</i>&nbsp;        return valueOf(result);</b>
<i>3404</i>&nbsp;    }
<b class="nc"><i>3405</i>&nbsp;</b>
<i>3406</i>&nbsp;    /**
<i>3407</i>&nbsp;     * Returns a BigInteger whose value is {@code (~this)}.  (This method
<i>3408</i>&nbsp;     * returns a negative value if and only if this BigInteger is
<i>3409</i>&nbsp;     * non-negative.)
<i>3410</i>&nbsp;     *
<i>3411</i>&nbsp;     * @return {@code ~this}
<i>3412</i>&nbsp;     */
<i>3413</i>&nbsp;    public BigInteger not() {
<i>3414</i>&nbsp;        int[] result = new int[intLength()];
<i>3415</i>&nbsp;        for (int i=0; i &lt; result.length; i++)
<i>3416</i>&nbsp;            result[i] = ~getInt(result.length-i-1);
<i>3417</i>&nbsp;
<i>3418</i>&nbsp;        return valueOf(result);
<i>3419</i>&nbsp;    }
<i>3420</i>&nbsp;
<i>3421</i>&nbsp;    /**
<b class="nc"><i>3422</i>&nbsp;     * Returns a BigInteger whose value is {@code (this &amp; ~val)}.  This</b>
<b class="nc"><i>3423</i>&nbsp;     * method, which is equivalent to {@code and(val.not())}, is provided as</b>
<b class="nc"><i>3424</i>&nbsp;     * a convenience for masking operations.  (This method returns a negative</b>
<b class="nc"><i>3425</i>&nbsp;     * BigInteger if and only if {@code this} is negative and {@code val} is</b>
<b class="nc"><i>3426</i>&nbsp;     * positive.)</b>
<b class="nc"><i>3427</i>&nbsp;     *</b>
<i>3428</i>&nbsp;     * @param val value to be complemented and AND&#39;ed with this BigInteger.
<i>3429</i>&nbsp;     * @return {@code this &amp; ~val}
<b class="nc"><i>3430</i>&nbsp;     */</b>
<b class="nc"><i>3431</i>&nbsp;    public BigInteger andNot(BigInteger val) {</b>
<i>3432</i>&nbsp;        int[] result = new int[Math.max(intLength(), val.intLength())];
<b class="nc"><i>3433</i>&nbsp;        for (int i=0; i &lt; result.length; i++)</b>
<b class="nc"><i>3434</i>&nbsp;            result[i] = (getInt(result.length-i-1)</b>
<b class="nc"><i>3435</i>&nbsp;                         &amp; ~val.getInt(result.length-i-1));</b>
<i>3436</i>&nbsp;
<b class="nc"><i>3437</i>&nbsp;        return valueOf(result);</b>
<b class="nc"><i>3438</i>&nbsp;    }</b>
<b class="nc"><i>3439</i>&nbsp;</b>
<i>3440</i>&nbsp;
<i>3441</i>&nbsp;    // Single Bit Operations
<b class="nc"><i>3442</i>&nbsp;</b>
<i>3443</i>&nbsp;    /**
<b class="nc"><i>3444</i>&nbsp;     * Returns {@code true} if and only if the designated bit is set.</b>
<i>3445</i>&nbsp;     * (Computes {@code ((this &amp; (1&lt;&lt;n)) != 0)}.)
<i>3446</i>&nbsp;     *
<i>3447</i>&nbsp;     * @param  n index of bit to test.
<i>3448</i>&nbsp;     * @return {@code true} if and only if the designated bit is set.
<i>3449</i>&nbsp;     * @throws ArithmeticException {@code n} is negative.
<i>3450</i>&nbsp;     */
<i>3451</i>&nbsp;    public boolean testBit(int n) {
<i>3452</i>&nbsp;        if (n &lt; 0)
<i>3453</i>&nbsp;            throw new ArithmeticException(&quot;Negative bit address&quot;);
<i>3454</i>&nbsp;
<i>3455</i>&nbsp;        return (getInt(n &gt;&gt;&gt; 5) &amp; (1 &lt;&lt; (n &amp; 31))) != 0;
<b class="nc"><i>3456</i>&nbsp;    }</b>
<b class="nc"><i>3457</i>&nbsp;</b>
<b class="nc"><i>3458</i>&nbsp;    /**</b>
<i>3459</i>&nbsp;     * Returns a BigInteger whose value is equivalent to this BigInteger
<b class="nc"><i>3460</i>&nbsp;     * with the designated bit set.  (Computes {@code (this | (1&lt;&lt;n))}.)</b>
<b class="nc"><i>3461</i>&nbsp;     *</b>
<b class="nc"><i>3462</i>&nbsp;     * @param  n index of bit to set.</b>
<i>3463</i>&nbsp;     * @return {@code this | (1&lt;&lt;n)}
<b class="nc"><i>3464</i>&nbsp;     * @throws ArithmeticException {@code n} is negative.</b>
<b class="nc"><i>3465</i>&nbsp;     */</b>
<b class="nc"><i>3466</i>&nbsp;    public BigInteger setBit(int n) {</b>
<b class="nc"><i>3467</i>&nbsp;        if (n &lt; 0)</b>
<b class="nc"><i>3468</i>&nbsp;            throw new ArithmeticException(&quot;Negative bit address&quot;);</b>
<i>3469</i>&nbsp;
<b class="nc"><i>3470</i>&nbsp;        int intNum = n &gt;&gt;&gt; 5;</b>
<i>3471</i>&nbsp;        int[] result = new int[Math.max(intLength(), intNum+2)];
<b class="nc"><i>3472</i>&nbsp;</b>
<i>3473</i>&nbsp;        for (int i=0; i &lt; result.length; i++)
<i>3474</i>&nbsp;            result[result.length-i-1] = getInt(i);
<i>3475</i>&nbsp;
<i>3476</i>&nbsp;        result[result.length-intNum-1] |= (1 &lt;&lt; (n &amp; 31));
<i>3477</i>&nbsp;
<i>3478</i>&nbsp;        return valueOf(result);
<i>3479</i>&nbsp;    }
<i>3480</i>&nbsp;
<i>3481</i>&nbsp;    /**
<i>3482</i>&nbsp;     * Returns a BigInteger whose value is equivalent to this BigInteger
<i>3483</i>&nbsp;     * with the designated bit cleared.
<i>3484</i>&nbsp;     * (Computes {@code (this &amp; ~(1&lt;&lt;n))}.)
<i>3485</i>&nbsp;     *
<i>3486</i>&nbsp;     * @param  n index of bit to clear.
<i>3487</i>&nbsp;     * @return {@code this &amp; ~(1&lt;&lt;n)}
<i>3488</i>&nbsp;     * @throws ArithmeticException {@code n} is negative.
<i>3489</i>&nbsp;     */
<i>3490</i>&nbsp;    public BigInteger clearBit(int n) {
<i>3491</i>&nbsp;        if (n &lt; 0)
<b class="nc"><i>3492</i>&nbsp;            throw new ArithmeticException(&quot;Negative bit address&quot;);</b>
<b class="nc"><i>3493</i>&nbsp;</b>
<b class="nc"><i>3494</i>&nbsp;        int intNum = n &gt;&gt;&gt; 5;</b>
<b class="nc"><i>3495</i>&nbsp;        int[] result = new int[Math.max(intLength(), ((n + 1) &gt;&gt;&gt; 5) + 1)];</b>
<b class="nc"><i>3496</i>&nbsp;</b>
<b class="nc"><i>3497</i>&nbsp;        for (int i=0; i &lt; result.length; i++)</b>
<b class="nc"><i>3498</i>&nbsp;            result[result.length-i-1] = getInt(i);</b>
<i>3499</i>&nbsp;
<b class="nc"><i>3500</i>&nbsp;        result[result.length-intNum-1] &amp;= ~(1 &lt;&lt; (n &amp; 31));</b>
<i>3501</i>&nbsp;
<i>3502</i>&nbsp;        return valueOf(result);
<i>3503</i>&nbsp;    }
<i>3504</i>&nbsp;
<i>3505</i>&nbsp;    /**
<i>3506</i>&nbsp;     * Returns a BigInteger whose value is equivalent to this BigInteger
<i>3507</i>&nbsp;     * with the designated bit flipped.
<i>3508</i>&nbsp;     * (Computes {@code (this ^ (1&lt;&lt;n))}.)
<i>3509</i>&nbsp;     *
<i>3510</i>&nbsp;     * @param  n index of bit to flip.
<i>3511</i>&nbsp;     * @return {@code this ^ (1&lt;&lt;n)}
<i>3512</i>&nbsp;     * @throws ArithmeticException {@code n} is negative.
<i>3513</i>&nbsp;     */
<i>3514</i>&nbsp;    public BigInteger flipBit(int n) {
<i>3515</i>&nbsp;        if (n &lt; 0)
<i>3516</i>&nbsp;            throw new ArithmeticException(&quot;Negative bit address&quot;);
<i>3517</i>&nbsp;
<i>3518</i>&nbsp;        int intNum = n &gt;&gt;&gt; 5;
<b class="nc"><i>3519</i>&nbsp;        int[] result = new int[Math.max(intLength(), intNum+2)];</b>
<b class="nc"><i>3520</i>&nbsp;</b>
<i>3521</i>&nbsp;        for (int i=0; i &lt; result.length; i++)
<b class="nc"><i>3522</i>&nbsp;            result[result.length-i-1] = getInt(i);</b>
<i>3523</i>&nbsp;
<b class="nc"><i>3524</i>&nbsp;        result[result.length-intNum-1] ^= (1 &lt;&lt; (n &amp; 31));</b>
<i>3525</i>&nbsp;
<b class="nc"><i>3526</i>&nbsp;        return valueOf(result);</b>
<i>3527</i>&nbsp;    }
<i>3528</i>&nbsp;
<b class="nc"><i>3529</i>&nbsp;    /**</b>
<i>3530</i>&nbsp;     * Returns the index of the rightmost (lowest-order) one bit in this
<i>3531</i>&nbsp;     * BigInteger (the number of zero bits to the right of the rightmost
<i>3532</i>&nbsp;     * one bit).  Returns -1 if this BigInteger contains no one bits.
<i>3533</i>&nbsp;     * (Computes {@code (this == 0? -1 : log2(this &amp; -this))}.)
<i>3534</i>&nbsp;     *
<i>3535</i>&nbsp;     * @return index of the rightmost one bit in this BigInteger.
<i>3536</i>&nbsp;     */
<i>3537</i>&nbsp;    public int getLowestSetBit() {
<i>3538</i>&nbsp;        int lsb = lowestSetBitPlusTwo - 2;
<i>3539</i>&nbsp;        if (lsb == -2) {  // lowestSetBit not initialized yet
<i>3540</i>&nbsp;            lsb = 0;
<b class="nc"><i>3541</i>&nbsp;            if (signum == 0) {</b>
<b class="nc"><i>3542</i>&nbsp;                lsb -= 1;</b>
<b class="nc"><i>3543</i>&nbsp;            } else {</b>
<b class="nc"><i>3544</i>&nbsp;                // Search for lowest order nonzero int</b>
<b class="nc"><i>3545</i>&nbsp;                int i,b;</b>
<b class="nc"><i>3546</i>&nbsp;                for (i=0; (b = getInt(i)) == 0; i++)</b>
<b class="nc"><i>3547</i>&nbsp;                    ;</b>
<b class="nc"><i>3548</i>&nbsp;                lsb += (i &lt;&lt; 5) + Integer.numberOfTrailingZeros(b);</b>
<b class="nc"><i>3549</i>&nbsp;            }</b>
<b class="nc"><i>3550</i>&nbsp;            lowestSetBitPlusTwo = lsb + 2;</b>
<b class="nc"><i>3551</i>&nbsp;        }</b>
<b class="nc"><i>3552</i>&nbsp;        return lsb;</b>
<b class="nc"><i>3553</i>&nbsp;    }</b>
<i>3554</i>&nbsp;
<b class="nc"><i>3555</i>&nbsp;</b>
<i>3556</i>&nbsp;    // Miscellaneous Bit Operations
<i>3557</i>&nbsp;
<i>3558</i>&nbsp;    /**
<i>3559</i>&nbsp;     * Returns the number of bits in the minimal two&#39;s-complement
<i>3560</i>&nbsp;     * representation of this BigInteger, &lt;em&gt;excluding&lt;/em&gt; a sign bit.
<i>3561</i>&nbsp;     * For positive BigIntegers, this is equivalent to the number of bits in
<i>3562</i>&nbsp;     * the ordinary binary representation.  For zero this method returns
<b class="nc"><i>3563</i>&nbsp;     * {@code 0}.  (Computes {@code (ceil(log2(this &lt; 0 ? -this : this+1)))}.)</b>
<b class="nc"><i>3564</i>&nbsp;     *</b>
<b class="nc"><i>3565</i>&nbsp;     * @return number of bits in the minimal two&#39;s-complement</b>
<b class="nc"><i>3566</i>&nbsp;     *         representation of this BigInteger, &lt;em&gt;excluding&lt;/em&gt; a sign bit.</b>
<b class="nc"><i>3567</i>&nbsp;     */</b>
<i>3568</i>&nbsp;    public int bitLength() {
<b class="nc"><i>3569</i>&nbsp;        int n = bitLengthPlusOne - 1;</b>
<b class="nc"><i>3570</i>&nbsp;        if (n == -1) { // bitLength not initialized yet</b>
<i>3571</i>&nbsp;            int[] m = mag;
<b class="nc"><i>3572</i>&nbsp;            int len = m.length;</b>
<b class="nc"><i>3573</i>&nbsp;            if (len == 0) {</b>
<b class="nc"><i>3574</i>&nbsp;                n = 0; // offset by one to initialize</b>
<b class="nc"><i>3575</i>&nbsp;            }  else {</b>
<b class="nc"><i>3576</i>&nbsp;                // Calculate the bit length of the magnitude</b>
<b class="nc"><i>3577</i>&nbsp;                int magBitLength = ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]);</b>
<b class="nc"><i>3578</i>&nbsp;                 if (signum &lt; 0) {</b>
<b class="nc"><i>3579</i>&nbsp;                     // Check if magnitude is a power of two</b>
<b class="nc"><i>3580</i>&nbsp;                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);</b>
<b class="nc"><i>3581</i>&nbsp;                     for (int i=1; i&lt; len &amp;&amp; pow2; i++)</b>
<i>3582</i>&nbsp;                         pow2 = (mag[i] == 0);
<b class="nc"><i>3583</i>&nbsp;</b>
<i>3584</i>&nbsp;                     n = (pow2 ? magBitLength -1 : magBitLength);
<b class="nc"><i>3585</i>&nbsp;                 } else {</b>
<b class="nc"><i>3586</i>&nbsp;                     n = magBitLength;</b>
<b class="nc"><i>3587</i>&nbsp;                 }</b>
<b class="nc"><i>3588</i>&nbsp;            }</b>
<b class="nc"><i>3589</i>&nbsp;            bitLengthPlusOne = n + 1;</b>
<b class="nc"><i>3590</i>&nbsp;        }</b>
<i>3591</i>&nbsp;        return n;
<b class="nc"><i>3592</i>&nbsp;    }</b>
<b class="nc"><i>3593</i>&nbsp;</b>
<b class="nc"><i>3594</i>&nbsp;    /**</b>
<b class="nc"><i>3595</i>&nbsp;     * Returns the number of bits in the two&#39;s complement representation</b>
<i>3596</i>&nbsp;     * of this BigInteger that differ from its sign bit.  This method is
<b class="nc"><i>3597</i>&nbsp;     * useful when implementing bit-vector style sets atop BigIntegers.</b>
<i>3598</i>&nbsp;     *
<i>3599</i>&nbsp;     * @return number of bits in the two&#39;s complement representation
<i>3600</i>&nbsp;     *         of this BigInteger that differ from its sign bit.
<i>3601</i>&nbsp;     */
<i>3602</i>&nbsp;    public int bitCount() {
<i>3603</i>&nbsp;        int bc = bitCountPlusOne - 1;
<i>3604</i>&nbsp;        if (bc == -1) {  // bitCount not initialized yet
<i>3605</i>&nbsp;            bc = 0;      // offset by one to initialize
<i>3606</i>&nbsp;            // Count the bits in the magnitude
<i>3607</i>&nbsp;            for (int i=0; i &lt; mag.length; i++)
<i>3608</i>&nbsp;                bc += Integer.bitCount(mag[i]);
<i>3609</i>&nbsp;            if (signum &lt; 0) {
<b class="nc"><i>3610</i>&nbsp;                // Count the trailing zeros in the magnitude</b>
<b class="nc"><i>3611</i>&nbsp;                int magTrailingZeroCount = 0, j;</b>
<i>3612</i>&nbsp;                for (j=mag.length-1; mag[j] == 0; j--)
<b class="nc"><i>3613</i>&nbsp;                    magTrailingZeroCount += 32;</b>
<b class="nc"><i>3614</i>&nbsp;                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);</b>
<i>3615</i>&nbsp;                bc += magTrailingZeroCount - 1;
<b class="nc"><i>3616</i>&nbsp;            }</b>
<b class="nc"><i>3617</i>&nbsp;            bitCountPlusOne = bc + 1;</b>
<b class="nc"><i>3618</i>&nbsp;        }</b>
<i>3619</i>&nbsp;        return bc;
<b class="nc"><i>3620</i>&nbsp;    }</b>
<b class="nc"><i>3621</i>&nbsp;</b>
<b class="nc"><i>3622</i>&nbsp;    // Primality Testing</b>
<b class="nc"><i>3623</i>&nbsp;</b>
<b class="nc"><i>3624</i>&nbsp;    /**</b>
<i>3625</i>&nbsp;     * Returns {@code true} if this BigInteger is probably prime,
<b class="nc"><i>3626</i>&nbsp;     * {@code false} if it&#39;s definitely composite.  If</b>
<b class="nc"><i>3627</i>&nbsp;     * {@code certainty} is &amp;le; 0, {@code true} is</b>
<b class="nc"><i>3628</i>&nbsp;     * returned.</b>
<i>3629</i>&nbsp;     *
<b class="nc"><i>3630</i>&nbsp;     * @param  certainty a measure of the uncertainty that the caller is</b>
<i>3631</i>&nbsp;     *         willing to tolerate: if the call returns {@code true}
<i>3632</i>&nbsp;     *         the probability that this BigInteger is prime exceeds
<i>3633</i>&nbsp;     *         (1 - 1/2&lt;sup&gt;{@code certainty}&lt;/sup&gt;).  The execution time of
<i>3634</i>&nbsp;     *         this method is proportional to the value of this parameter.
<i>3635</i>&nbsp;     * @return {@code true} if this BigInteger is probably prime,
<i>3636</i>&nbsp;     *         {@code false} if it&#39;s definitely composite.
<i>3637</i>&nbsp;     */
<i>3638</i>&nbsp;    public boolean isProbablePrime(int certainty) {
<i>3639</i>&nbsp;        if (certainty &lt;= 0)
<i>3640</i>&nbsp;            return true;
<b class="nc"><i>3641</i>&nbsp;        BigInteger w = this.abs();</b>
<i>3642</i>&nbsp;        if (w.equals(TWO))
<i>3643</i>&nbsp;            return true;
<i>3644</i>&nbsp;        if (!w.testBit(0) || w.equals(ONE))
<i>3645</i>&nbsp;            return false;
<i>3646</i>&nbsp;
<i>3647</i>&nbsp;        return w.primeToCertainty(certainty, null);
<i>3648</i>&nbsp;    }
<i>3649</i>&nbsp;
<i>3650</i>&nbsp;    // Comparison Operations
<i>3651</i>&nbsp;
<b class="nc"><i>3652</i>&nbsp;    /**</b>
<i>3653</i>&nbsp;     * Compares this BigInteger with the specified BigInteger.  This
<i>3654</i>&nbsp;     * method is provided in preference to individual methods for each
<i>3655</i>&nbsp;     * of the six boolean comparison operators ({@literal &lt;}, ==,
<i>3656</i>&nbsp;     * {@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The suggested
<i>3657</i>&nbsp;     * idiom for performing these comparisons is: {@code
<i>3658</i>&nbsp;     * (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
<i>3659</i>&nbsp;     * &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.
<i>3660</i>&nbsp;     *
<i>3661</i>&nbsp;     * @param  val BigInteger to which this BigInteger is to be compared.
<i>3662</i>&nbsp;     * @return -1, 0 or 1 as this BigInteger is numerically less than, equal
<i>3663</i>&nbsp;     *         to, or greater than {@code val}.
<b class="nc"><i>3664</i>&nbsp;     */</b>
<i>3665</i>&nbsp;    public int compareTo(BigInteger val) {
<b class="nc"><i>3666</i>&nbsp;        if (signum == val.signum) {</b>
<b class="nc"><i>3667</i>&nbsp;            switch (signum) {</b>
<i>3668</i>&nbsp;            case 1:
<b class="nc"><i>3669</i>&nbsp;                return compareMagnitude(val);</b>
<i>3670</i>&nbsp;            case -1:
<i>3671</i>&nbsp;                return val.compareMagnitude(this);
<i>3672</i>&nbsp;            default:
<i>3673</i>&nbsp;                return 0;
<i>3674</i>&nbsp;            }
<i>3675</i>&nbsp;        }
<i>3676</i>&nbsp;        return signum &gt; val.signum ? 1 : -1;
<i>3677</i>&nbsp;    }
<i>3678</i>&nbsp;
<i>3679</i>&nbsp;    /**
<i>3680</i>&nbsp;     * Compares the magnitude array of this BigInteger with the specified
<i>3681</i>&nbsp;     * BigInteger&#39;s. This is the version of compareTo ignoring sign.
<i>3682</i>&nbsp;     *
<i>3683</i>&nbsp;     * @param val BigInteger whose magnitude array to be compared.
<i>3684</i>&nbsp;     * @return -1, 0 or 1 as this magnitude array is less than, equal to or
<i>3685</i>&nbsp;     *         greater than the magnitude aray for the specified BigInteger&#39;s.
<i>3686</i>&nbsp;     */
<i>3687</i>&nbsp;    final int compareMagnitude(BigInteger val) {
<i>3688</i>&nbsp;        int[] m1 = mag;
<i>3689</i>&nbsp;        int len1 = m1.length;
<b class="nc"><i>3690</i>&nbsp;        int[] m2 = val.mag;</b>
<b class="nc"><i>3691</i>&nbsp;        int len2 = m2.length;</b>
<b class="nc"><i>3692</i>&nbsp;        if (len1 &lt; len2)</b>
<b class="nc"><i>3693</i>&nbsp;            return -1;</b>
<i>3694</i>&nbsp;        if (len1 &gt; len2)
<i>3695</i>&nbsp;            return 1;
<b class="nc"><i>3696</i>&nbsp;        for (int i = 0; i &lt; len1; i++) {</b>
<b class="nc"><i>3697</i>&nbsp;            int a = m1[i];</b>
<i>3698</i>&nbsp;            int b = m2[i];
<i>3699</i>&nbsp;            if (a != b)
<i>3700</i>&nbsp;                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK)) ? -1 : 1;
<b class="nc"><i>3701</i>&nbsp;        }</b>
<b class="nc"><i>3702</i>&nbsp;        return 0;</b>
<b class="nc"><i>3703</i>&nbsp;    }</b>
<b class="nc"><i>3704</i>&nbsp;</b>
<i>3705</i>&nbsp;    /**
<i>3706</i>&nbsp;     * Version of compareMagnitude that compares magnitude with long value.
<b class="nc"><i>3707</i>&nbsp;     * val can&#39;t be Long.MIN_VALUE.</b>
<i>3708</i>&nbsp;     */
<b class="nc"><i>3709</i>&nbsp;    final int compareMagnitude(long val) {</b>
<i>3710</i>&nbsp;        assert val != Long.MIN_VALUE;
<i>3711</i>&nbsp;        int[] m1 = mag;
<i>3712</i>&nbsp;        int len = m1.length;
<i>3713</i>&nbsp;        if (len &gt; 2) {
<b class="nc"><i>3714</i>&nbsp;            return 1;</b>
<b class="nc"><i>3715</i>&nbsp;        }</b>
<i>3716</i>&nbsp;        if (val &lt; 0) {
<i>3717</i>&nbsp;            val = -val;
<i>3718</i>&nbsp;        }
<b class="nc"><i>3719</i>&nbsp;        int highWord = (int)(val &gt;&gt;&gt; 32);</b>
<b class="nc"><i>3720</i>&nbsp;        if (highWord == 0) {</b>
<i>3721</i>&nbsp;            if (len &lt; 1)
<i>3722</i>&nbsp;                return -1;
<b class="nc"><i>3723</i>&nbsp;            if (len &gt; 1)</b>
<b class="nc"><i>3724</i>&nbsp;                return 1;</b>
<b class="nc"><i>3725</i>&nbsp;            int a = m1[0];</b>
<b class="nc"><i>3726</i>&nbsp;            int b = (int)val;</b>
<i>3727</i>&nbsp;            if (a != b) {
<b class="nc"><i>3728</i>&nbsp;                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</b>
<b class="nc"><i>3729</i>&nbsp;            }</b>
<b class="nc"><i>3730</i>&nbsp;            return 0;</b>
<b class="nc"><i>3731</i>&nbsp;        } else {</b>
<b class="nc"><i>3732</i>&nbsp;            if (len &lt; 2)</b>
<b class="nc"><i>3733</i>&nbsp;                return -1;</b>
<i>3734</i>&nbsp;            int a = m1[0];
<b class="nc"><i>3735</i>&nbsp;            int b = highWord;</b>
<b class="nc"><i>3736</i>&nbsp;            if (a != b) {</b>
<b class="nc"><i>3737</i>&nbsp;                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</b>
<i>3738</i>&nbsp;            }
<i>3739</i>&nbsp;            a = m1[1];
<b class="nc"><i>3740</i>&nbsp;            b = (int)val;</b>
<b class="nc"><i>3741</i>&nbsp;            if (a != b) {</b>
<b class="nc"><i>3742</i>&nbsp;                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK))? -1 : 1;</b>
<i>3743</i>&nbsp;            }
<b class="nc"><i>3744</i>&nbsp;            return 0;</b>
<i>3745</i>&nbsp;        }
<i>3746</i>&nbsp;    }
<b class="nc"><i>3747</i>&nbsp;</b>
<i>3748</i>&nbsp;    /**
<b class="nc"><i>3749</i>&nbsp;     * Compares this BigInteger with the specified Object for equality.</b>
<b class="nc"><i>3750</i>&nbsp;     *</b>
<b class="nc"><i>3751</i>&nbsp;     * @param  x Object to which this BigInteger is to be compared.</b>
<i>3752</i>&nbsp;     * @return {@code true} if and only if the specified Object is a
<b class="nc"><i>3753</i>&nbsp;     *         BigInteger whose value is numerically equal to this BigInteger.</b>
<i>3754</i>&nbsp;     */
<b class="nc"><i>3755</i>&nbsp;    public boolean equals(Object x) {</b>
<i>3756</i>&nbsp;        // This test is just an optimization, which may or may not help
<i>3757</i>&nbsp;        if (x == this)
<i>3758</i>&nbsp;            return true;
<i>3759</i>&nbsp;
<i>3760</i>&nbsp;        if (!(x instanceof BigInteger))
<i>3761</i>&nbsp;            return false;
<i>3762</i>&nbsp;
<i>3763</i>&nbsp;        BigInteger xInt = (BigInteger) x;
<i>3764</i>&nbsp;        if (xInt.signum != signum)
<i>3765</i>&nbsp;            return false;
<i>3766</i>&nbsp;
<i>3767</i>&nbsp;        int[] m = mag;
<i>3768</i>&nbsp;        int len = m.length;
<i>3769</i>&nbsp;        int[] xm = xInt.mag;
<i>3770</i>&nbsp;        if (len != xm.length)
<i>3771</i>&nbsp;            return false;
<i>3772</i>&nbsp;
<i>3773</i>&nbsp;        for (int i = 0; i &lt; len; i++)
<i>3774</i>&nbsp;            if (xm[i] != m[i])
<b class="nc"><i>3775</i>&nbsp;                return false;</b>
<b class="nc"><i>3776</i>&nbsp;</b>
<i>3777</i>&nbsp;        return true;
<i>3778</i>&nbsp;    }
<i>3779</i>&nbsp;
<b class="nc"><i>3780</i>&nbsp;    /**</b>
<b class="nc"><i>3781</i>&nbsp;     * Returns the minimum of this BigInteger and {@code val}.</b>
<b class="nc"><i>3782</i>&nbsp;     *</b>
<i>3783</i>&nbsp;     * @param  val value with which the minimum is to be computed.
<i>3784</i>&nbsp;     * @return the BigInteger whose value is the lesser of this BigInteger and
<i>3785</i>&nbsp;     *         {@code val}.  If they are equal, either may be returned.
<b class="nc"><i>3786</i>&nbsp;     */</b>
<i>3787</i>&nbsp;    public BigInteger min(BigInteger val) {
<i>3788</i>&nbsp;        return (compareTo(val) &lt; 0 ? this : val);
<i>3789</i>&nbsp;    }
<i>3790</i>&nbsp;
<b class="nc"><i>3791</i>&nbsp;    /**</b>
<i>3792</i>&nbsp;     * Returns the maximum of this BigInteger and {@code val}.
<i>3793</i>&nbsp;     *
<i>3794</i>&nbsp;     * @param  val value with which the maximum is to be computed.
<i>3795</i>&nbsp;     * @return the BigInteger whose value is the greater of this and
<b class="nc"><i>3796</i>&nbsp;     *         {@code val}.  If they are equal, either may be returned.</b>
<b class="nc"><i>3797</i>&nbsp;     */</b>
<i>3798</i>&nbsp;    public BigInteger max(BigInteger val) {
<b class="nc"><i>3799</i>&nbsp;        return (compareTo(val) &gt; 0 ? this : val);</b>
<i>3800</i>&nbsp;    }
<b class="nc"><i>3801</i>&nbsp;</b>
<i>3802</i>&nbsp;
<i>3803</i>&nbsp;    // Hash Function
<b class="nc"><i>3804</i>&nbsp;</b>
<b class="nc"><i>3805</i>&nbsp;    /**</b>
<i>3806</i>&nbsp;     * Returns the hash code for this BigInteger.
<i>3807</i>&nbsp;     *
<i>3808</i>&nbsp;     * @return hash code for this BigInteger.
<i>3809</i>&nbsp;     */
<i>3810</i>&nbsp;    public int hashCode() {
<i>3811</i>&nbsp;        int hashCode = 0;
<i>3812</i>&nbsp;
<i>3813</i>&nbsp;        for (int i=0; i &lt; mag.length; i++)
<i>3814</i>&nbsp;            hashCode = (int)(31*hashCode + (mag[i] &amp; LONG_MASK));
<i>3815</i>&nbsp;
<b class="nc"><i>3816</i>&nbsp;        return hashCode * signum;</b>
<b class="nc"><i>3817</i>&nbsp;    }</b>
<b class="nc"><i>3818</i>&nbsp;</b>
<i>3819</i>&nbsp;    /**
<i>3820</i>&nbsp;     * Returns the String representation of this BigInteger in the
<b class="nc"><i>3821</i>&nbsp;     * given radix.  If the radix is outside the range from {@link</b>
<b class="nc"><i>3822</i>&nbsp;     * Character#MIN_RADIX} to {@link Character#MAX_RADIX} inclusive,</b>
<b class="nc"><i>3823</i>&nbsp;     * it will default to 10 (as is the case for</b>
<b class="nc"><i>3824</i>&nbsp;     * {@code Integer.toString}).  The digit-to-character mapping</b>
<i>3825</i>&nbsp;     * provided by {@code Character.forDigit} is used, and a minus
<i>3826</i>&nbsp;     * sign is prepended if appropriate.  (This representation is
<b class="nc"><i>3827</i>&nbsp;     * compatible with the {@link #BigInteger(String, int) (String,</b>
<b class="nc"><i>3828</i>&nbsp;     * int)} constructor.)</b>
<b class="nc"><i>3829</i>&nbsp;     *</b>
<b class="nc"><i>3830</i>&nbsp;     * @param  radix  radix of the String representation.</b>
<b class="nc"><i>3831</i>&nbsp;     * @return String representation of this BigInteger in the given radix.</b>
<i>3832</i>&nbsp;     * @see    Integer#toString
<b class="nc"><i>3833</i>&nbsp;     * @see    Character#forDigit</b>
<i>3834</i>&nbsp;     * @see    #BigInteger(java.lang.String, int)
<i>3835</i>&nbsp;     */
<i>3836</i>&nbsp;    public String toString(int radix) {
<b class="nc"><i>3837</i>&nbsp;        if (signum == 0)</b>
<i>3838</i>&nbsp;            return &quot;0&quot;;
<b class="nc"><i>3839</i>&nbsp;        if (radix &lt; Character.MIN_RADIX || radix &gt; Character.MAX_RADIX)</b>
<i>3840</i>&nbsp;            radix = 10;
<b class="nc"><i>3841</i>&nbsp;</b>
<b class="nc"><i>3842</i>&nbsp;        // If it&#39;s small enough, use smallToString.</b>
<i>3843</i>&nbsp;        if (mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)
<i>3844</i>&nbsp;           return smallToString(radix);
<i>3845</i>&nbsp;
<i>3846</i>&nbsp;        // Otherwise use recursive toString, which requires positive arguments.
<i>3847</i>&nbsp;        // The results will be concatenated into this StringBuilder
<i>3848</i>&nbsp;        StringBuilder sb = new StringBuilder();
<i>3849</i>&nbsp;        if (signum &lt; 0) {
<i>3850</i>&nbsp;            toString(this.negate(), sb, radix, 0);
<i>3851</i>&nbsp;            sb.insert(0, &#39;-&#39;);
<i>3852</i>&nbsp;        }
<i>3853</i>&nbsp;        else
<i>3854</i>&nbsp;            toString(this, sb, radix, 0);
<i>3855</i>&nbsp;
<i>3856</i>&nbsp;        return sb.toString();
<i>3857</i>&nbsp;    }
<b class="nc"><i>3858</i>&nbsp;</b>
<i>3859</i>&nbsp;    /** This method is used to perform toString when arguments are small. */
<i>3860</i>&nbsp;    private String smallToString(int radix) {
<i>3861</i>&nbsp;        if (signum == 0) {
<i>3862</i>&nbsp;            return &quot;0&quot;;
<i>3863</i>&nbsp;        }
<i>3864</i>&nbsp;
<i>3865</i>&nbsp;        // Compute upper bound on number of digit groups and allocate space
<i>3866</i>&nbsp;        int maxNumDigitGroups = (4*mag.length + 6)/7;
<i>3867</i>&nbsp;        String digitGroup[] = new String[maxNumDigitGroups];
<i>3868</i>&nbsp;
<i>3869</i>&nbsp;        // Translate number to string, a digit group at a time
<i>3870</i>&nbsp;        BigInteger tmp = this.abs();
<i>3871</i>&nbsp;        int numGroups = 0;
<i>3872</i>&nbsp;        while (tmp.signum != 0) {
<i>3873</i>&nbsp;            BigInteger d = longRadix[radix];
<i>3874</i>&nbsp;
<i>3875</i>&nbsp;            MutableBigInteger q = new MutableBigInteger(),
<b class="nc"><i>3876</i>&nbsp;                              a = new MutableBigInteger(tmp.mag),</b>
<b class="nc"><i>3877</i>&nbsp;                              b = new MutableBigInteger(d.mag);</b>
<i>3878</i>&nbsp;            MutableBigInteger r = a.divide(b, q);
<b class="nc"><i>3879</i>&nbsp;            BigInteger q2 = q.toBigInteger(tmp.signum * d.signum);</b>
<b class="nc"><i>3880</i>&nbsp;            BigInteger r2 = r.toBigInteger(tmp.signum * d.signum);</b>
<b class="nc"><i>3881</i>&nbsp;</b>
<b class="nc"><i>3882</i>&nbsp;            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);</b>
<i>3883</i>&nbsp;            tmp = q2;
<b class="nc"><i>3884</i>&nbsp;        }</b>
<b class="nc"><i>3885</i>&nbsp;</b>
<i>3886</i>&nbsp;        // Put sign (if any) and first digit group into result buffer
<b class="nc"><i>3887</i>&nbsp;        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);</b>
<i>3888</i>&nbsp;        if (signum &lt; 0) {
<b class="nc"><i>3889</i>&nbsp;            buf.append(&#39;-&#39;);</b>
<i>3890</i>&nbsp;        }
<i>3891</i>&nbsp;        buf.append(digitGroup[numGroups-1]);
<i>3892</i>&nbsp;
<i>3893</i>&nbsp;        // Append remaining digit groups padded with leading zeros
<i>3894</i>&nbsp;        for (int i=numGroups-2; i &gt;= 0; i--) {
<i>3895</i>&nbsp;            // Prepend (any) leading zeros for this digit group
<i>3896</i>&nbsp;            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();
<i>3897</i>&nbsp;            if (numLeadingZeros != 0) {
<i>3898</i>&nbsp;                buf.append(zeros[numLeadingZeros]);
<i>3899</i>&nbsp;            }
<i>3900</i>&nbsp;            buf.append(digitGroup[i]);
<i>3901</i>&nbsp;        }
<i>3902</i>&nbsp;        return buf.toString();
<i>3903</i>&nbsp;    }
<i>3904</i>&nbsp;
<i>3905</i>&nbsp;    /**
<i>3906</i>&nbsp;     * Converts the specified BigInteger to a string and appends to
<i>3907</i>&nbsp;     * {@code sb}.  This implements the recursive Schoenhage algorithm
<b class="nc"><i>3908</i>&nbsp;     * for base conversions.</b>
<b class="nc"><i>3909</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3910</i>&nbsp;     * See Knuth, Donald,  _The Art of Computer Programming_, Vol. 2,</b>
<i>3911</i>&nbsp;     * Answers to Exercises (4.4) Question 14.
<i>3912</i>&nbsp;     *
<i>3913</i>&nbsp;     * @param u      The number to convert to a string.
<i>3914</i>&nbsp;     * @param sb     The StringBuilder that will be appended to in place.
<i>3915</i>&nbsp;     * @param radix  The base to convert to.
<i>3916</i>&nbsp;     * @param digits The minimum number of digits to pad to.
<i>3917</i>&nbsp;     */
<i>3918</i>&nbsp;    private static void toString(BigInteger u, StringBuilder sb, int radix,
<i>3919</i>&nbsp;                                 int digits) {
<i>3920</i>&nbsp;        // If we&#39;re smaller than a certain threshold, use the smallToString
<i>3921</i>&nbsp;        // method, padding with leading zeroes when necessary.
<i>3922</i>&nbsp;        if (u.mag.length &lt;= SCHOENHAGE_BASE_CONVERSION_THRESHOLD) {
<i>3923</i>&nbsp;            String s = u.smallToString(radix);
<i>3924</i>&nbsp;
<i>3925</i>&nbsp;            // Pad with internal zeros if necessary.
<i>3926</i>&nbsp;            // Don&#39;t pad if we&#39;re at the beginning of the string.
<i>3927</i>&nbsp;            if ((s.length() &lt; digits) &amp;&amp; (sb.length() &gt; 0)) {
<i>3928</i>&nbsp;                for (int i=s.length(); i &lt; digits; i++) {
<b class="nc"><i>3929</i>&nbsp;                    sb.append(&#39;0&#39;);</b>
<i>3930</i>&nbsp;                }
<b class="nc"><i>3931</i>&nbsp;            }</b>
<b class="nc"><i>3932</i>&nbsp;</b>
<b class="nc"><i>3933</i>&nbsp;            sb.append(s);</b>
<i>3934</i>&nbsp;            return;
<i>3935</i>&nbsp;        }
<i>3936</i>&nbsp;
<i>3937</i>&nbsp;        int b, n;
<i>3938</i>&nbsp;        b = u.bitLength();
<i>3939</i>&nbsp;
<i>3940</i>&nbsp;        // Calculate a value for n in the equation radix^(2^n) = u
<i>3941</i>&nbsp;        // and subtract 1 from that value.  This is used to find the
<i>3942</i>&nbsp;        // cache index that contains the best value to divide u.
<i>3943</i>&nbsp;        n = (int) Math.round(Math.log(b * LOG_TWO / logCache[radix]) / LOG_TWO - 1.0);
<i>3944</i>&nbsp;        BigInteger v = getRadixConversionCache(radix, n);
<i>3945</i>&nbsp;        BigInteger[] results;
<i>3946</i>&nbsp;        results = u.divideAndRemainder(v);
<i>3947</i>&nbsp;
<i>3948</i>&nbsp;        int expectedDigits = 1 &lt;&lt; n;
<i>3949</i>&nbsp;
<i>3950</i>&nbsp;        // Now recursively build the two halves of each number.
<i>3951</i>&nbsp;        toString(results[0], sb, radix, digits-expectedDigits);
<b class="nc"><i>3952</i>&nbsp;        toString(results[1], sb, radix, expectedDigits);</b>
<b class="nc"><i>3953</i>&nbsp;    }</b>
<i>3954</i>&nbsp;
<i>3955</i>&nbsp;    /**
<b class="nc"><i>3956</i>&nbsp;     * Returns the value radix^(2^exponent) from the cache.</b>
<i>3957</i>&nbsp;     * If this value doesn&#39;t already exist in the cache, it is added.
<i>3958</i>&nbsp;     * &lt;p&gt;
<b class="nc"><i>3959</i>&nbsp;     * This could be changed to a more complicated caching method using</b>
<b class="nc"><i>3960</i>&nbsp;     * {@code Future}.</b>
<b class="nc"><i>3961</i>&nbsp;     */</b>
<b class="nc"><i>3962</i>&nbsp;    private static BigInteger getRadixConversionCache(int radix, int exponent) {</b>
<i>3963</i>&nbsp;        BigInteger[] cacheLine = powerCache[radix]; // volatile read
<i>3964</i>&nbsp;        if (exponent &lt; cacheLine.length) {
<i>3965</i>&nbsp;            return cacheLine[exponent];
<i>3966</i>&nbsp;        }
<i>3967</i>&nbsp;
<i>3968</i>&nbsp;        int oldLength = cacheLine.length;
<i>3969</i>&nbsp;        cacheLine = Arrays.copyOf(cacheLine, exponent + 1);
<i>3970</i>&nbsp;        for (int i = oldLength; i &lt;= exponent; i++) {
<i>3971</i>&nbsp;            cacheLine[i] = cacheLine[i - 1].pow(2);
<i>3972</i>&nbsp;        }
<i>3973</i>&nbsp;
<i>3974</i>&nbsp;        BigInteger[][] pc = powerCache; // volatile read again
<b class="nc"><i>3975</i>&nbsp;        if (exponent &gt;= pc[radix].length) {</b>
<i>3976</i>&nbsp;            pc = pc.clone();
<i>3977</i>&nbsp;            pc[radix] = cacheLine;
<i>3978</i>&nbsp;            powerCache = pc; // volatile write, publish
<i>3979</i>&nbsp;        }
<i>3980</i>&nbsp;        return cacheLine[exponent];
<b class="nc"><i>3981</i>&nbsp;    }</b>
<b class="nc"><i>3982</i>&nbsp;</b>
<i>3983</i>&nbsp;    /* zero[i] is a string of i consecutive zeros. */
<b class="nc"><i>3984</i>&nbsp;    private static String zeros[] = new String[64];</b>
<b class="nc"><i>3985</i>&nbsp;    static {</b>
<i>3986</i>&nbsp;        zeros[63] =
<b class="nc"><i>3987</i>&nbsp;            &quot;000000000000000000000000000000000000000000000000000000000000000&quot;;</b>
<b class="nc"><i>3988</i>&nbsp;        for (int i=0; i &lt; 63; i++)</b>
<b class="nc"><i>3989</i>&nbsp;            zeros[i] = zeros[63].substring(0, i);</b>
<i>3990</i>&nbsp;    }
<i>3991</i>&nbsp;
<i>3992</i>&nbsp;    /**
<b class="nc"><i>3993</i>&nbsp;     * Returns the decimal String representation of this BigInteger.</b>
<b class="nc"><i>3994</i>&nbsp;     * The digit-to-character mapping provided by</b>
<i>3995</i>&nbsp;     * {@code Character.forDigit} is used, and a minus sign is
<i>3996</i>&nbsp;     * prepended if appropriate.  (This representation is compatible
<i>3997</i>&nbsp;     * with the {@link #BigInteger(String) (String)} constructor, and
<i>3998</i>&nbsp;     * allows for String concatenation with Java&#39;s + operator.)
<i>3999</i>&nbsp;     *
<i>4000</i>&nbsp;     * @return decimal String representation of this BigInteger.
<i>4001</i>&nbsp;     * @see    Character#forDigit
<i>4002</i>&nbsp;     * @see    #BigInteger(java.lang.String)
<b class="nc"><i>4003</i>&nbsp;     */</b>
<b class="nc"><i>4004</i>&nbsp;    public String toString() {</b>
<b class="nc"><i>4005</i>&nbsp;        return toString(10);</b>
<b class="nc"><i>4006</i>&nbsp;    }</b>
<i>4007</i>&nbsp;
<b class="nc"><i>4008</i>&nbsp;    /**</b>
<i>4009</i>&nbsp;     * Returns a byte array containing the two&#39;s-complement
<i>4010</i>&nbsp;     * representation of this BigInteger.  The byte array will be in
<i>4011</i>&nbsp;     * &lt;i&gt;big-endian&lt;/i&gt; byte-order: the most significant byte is in
<i>4012</i>&nbsp;     * the zeroth element.  The array will contain the minimum number
<i>4013</i>&nbsp;     * of bytes required to represent this BigInteger, including at
<i>4014</i>&nbsp;     * least one sign bit, which is {@code (ceil((this.bitLength() +
<i>4015</i>&nbsp;     * 1)/8))}.  (This representation is compatible with the
<b class="nc"><i>4016</i>&nbsp;     * {@link #BigInteger(byte[]) (byte[])} constructor.)</b>
<b class="nc"><i>4017</i>&nbsp;     *</b>
<i>4018</i>&nbsp;     * @return a byte array containing the two&#39;s-complement representation of
<i>4019</i>&nbsp;     *         this BigInteger.
<i>4020</i>&nbsp;     * @see    #BigInteger(byte[])
<i>4021</i>&nbsp;     */
<i>4022</i>&nbsp;    public byte[] toByteArray() {
<i>4023</i>&nbsp;        int byteLen = bitLength()/8 + 1;
<i>4024</i>&nbsp;        byte[] byteArray = new byte[byteLen];
<i>4025</i>&nbsp;
<i>4026</i>&nbsp;        for (int i=byteLen-1, bytesCopied=4, nextInt=0, intIndex=0; i &gt;= 0; i--) {
<i>4027</i>&nbsp;            if (bytesCopied == 4) {
<i>4028</i>&nbsp;                nextInt = getInt(intIndex++);
<i>4029</i>&nbsp;                bytesCopied = 1;
<i>4030</i>&nbsp;            } else {
<i>4031</i>&nbsp;                nextInt &gt;&gt;&gt;= 8;
<i>4032</i>&nbsp;                bytesCopied++;
<i>4033</i>&nbsp;            }
<i>4034</i>&nbsp;            byteArray[i] = (byte)nextInt;
<i>4035</i>&nbsp;        }
<b class="nc"><i>4036</i>&nbsp;        return byteArray;</b>
<b class="nc"><i>4037</i>&nbsp;    }</b>
<i>4038</i>&nbsp;
<i>4039</i>&nbsp;    /**
<b class="nc"><i>4040</i>&nbsp;     * Converts this BigInteger to an {@code int}.  This</b>
<i>4041</i>&nbsp;     * conversion is analogous to a
<i>4042</i>&nbsp;     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to
<b class="nc"><i>4043</i>&nbsp;     * {@code int} as defined in</b>
<b class="nc"><i>4044</i>&nbsp;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</b>
<b class="nc"><i>4045</i>&nbsp;     * if this BigInteger is too big to fit in an</b>
<b class="nc"><i>4046</i>&nbsp;     * {@code int}, only the low-order 32 bits are returned.</b>
<i>4047</i>&nbsp;     * Note that this conversion can lose information about the
<i>4048</i>&nbsp;     * overall magnitude of the BigInteger value as well as return a
<i>4049</i>&nbsp;     * result with the opposite sign.
<i>4050</i>&nbsp;     *
<i>4051</i>&nbsp;     * @return this BigInteger converted to an {@code int}.
<i>4052</i>&nbsp;     * @see #intValueExact()
<i>4053</i>&nbsp;     * @jls 5.1.3 Narrowing Primitive Conversion
<i>4054</i>&nbsp;     */
<i>4055</i>&nbsp;    public int intValue() {
<i>4056</i>&nbsp;        int result = 0;
<i>4057</i>&nbsp;        result = getInt(0);
<i>4058</i>&nbsp;        return result;
<b class="nc"><i>4059</i>&nbsp;    }</b>
<i>4060</i>&nbsp;
<i>4061</i>&nbsp;    /**
<i>4062</i>&nbsp;     * Converts this BigInteger to a {@code long}.  This
<i>4063</i>&nbsp;     * conversion is analogous to a
<i>4064</i>&nbsp;     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code long} to
<b class="nc"><i>4065</i>&nbsp;     * {@code int} as defined in</b>
<b class="nc"><i>4066</i>&nbsp;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:</b>
<i>4067</i>&nbsp;     * if this BigInteger is too big to fit in a
<i>4068</i>&nbsp;     * {@code long}, only the low-order 64 bits are returned.
<i>4069</i>&nbsp;     * Note that this conversion can lose information about the
<b class="nc"><i>4070</i>&nbsp;     * overall magnitude of the BigInteger value as well as return a</b>
<b class="nc"><i>4071</i>&nbsp;     * result with the opposite sign.</b>
<b class="nc"><i>4072</i>&nbsp;     *</b>
<i>4073</i>&nbsp;     * @return this BigInteger converted to a {@code long}.
<b class="nc"><i>4074</i>&nbsp;     * @see #longValueExact()</b>
<b class="nc"><i>4075</i>&nbsp;     * @jls 5.1.3 Narrowing Primitive Conversion</b>
<b class="nc"><i>4076</i>&nbsp;     */</b>
<b class="nc"><i>4077</i>&nbsp;    public long longValue() {</b>
<b class="nc"><i>4078</i>&nbsp;        long result = 0;</b>
<i>4079</i>&nbsp;
<i>4080</i>&nbsp;        for (int i=1; i &gt;= 0; i--)
<i>4081</i>&nbsp;            result = (result &lt;&lt; 32) + (getInt(i) &amp; LONG_MASK);
<b class="nc"><i>4082</i>&nbsp;        return result;</b>
<i>4083</i>&nbsp;    }
<i>4084</i>&nbsp;
<b class="nc"><i>4085</i>&nbsp;    /**</b>
<b class="nc"><i>4086</i>&nbsp;     * Converts this BigInteger to a {@code float}.  This</b>
<i>4087</i>&nbsp;     * conversion is similar to the
<i>4088</i>&nbsp;     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
<i>4089</i>&nbsp;     * {@code float} as defined in
<i>4090</i>&nbsp;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
<i>4091</i>&nbsp;     * if this BigInteger has too great a magnitude
<i>4092</i>&nbsp;     * to represent as a {@code float}, it will be converted to
<i>4093</i>&nbsp;     * {@link Float#NEGATIVE_INFINITY} or {@link
<i>4094</i>&nbsp;     * Float#POSITIVE_INFINITY} as appropriate.  Note that even when
<b class="nc"><i>4095</i>&nbsp;     * the return value is finite, this conversion can lose</b>
<b class="nc"><i>4096</i>&nbsp;     * information about the precision of the BigInteger value.</b>
<b class="nc"><i>4097</i>&nbsp;     *</b>
<b class="nc"><i>4098</i>&nbsp;     * @return this BigInteger converted to a {@code float}.</b>
<i>4099</i>&nbsp;     * @jls 5.1.3 Narrowing Primitive Conversion
<b class="nc"><i>4100</i>&nbsp;     */</b>
<i>4101</i>&nbsp;    public float floatValue() {
<i>4102</i>&nbsp;        if (signum == 0) {
<i>4103</i>&nbsp;            return 0.0f;
<i>4104</i>&nbsp;        }
<i>4105</i>&nbsp;
<i>4106</i>&nbsp;        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;
<i>4107</i>&nbsp;
<b class="nc"><i>4108</i>&nbsp;        // exponent == floor(log2(abs(this)))</b>
<b class="nc"><i>4109</i>&nbsp;        if (exponent &lt; Long.SIZE - 1) {</b>
<i>4110</i>&nbsp;            return longValue();
<i>4111</i>&nbsp;        } else if (exponent &gt; Float.MAX_EXPONENT) {
<i>4112</i>&nbsp;            return signum &gt; 0 ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;
<i>4113</i>&nbsp;        }
<i>4114</i>&nbsp;
<i>4115</i>&nbsp;        /*
<b class="nc"><i>4116</i>&nbsp;         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;</b>
<i>4117</i>&nbsp;         * one bit. To make rounding easier, we pick out the top
<i>4118</i>&nbsp;         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or
<i>4119</i>&nbsp;         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1
<b class="nc"><i>4120</i>&nbsp;         * bits, and signifFloor the top SIGNIFICAND_WIDTH.</b>
<i>4121</i>&nbsp;         *
<b class="nc"><i>4122</i>&nbsp;         * It helps to consider the real number signif = abs(this) *</b>
<i>4123</i>&nbsp;         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).
<i>4124</i>&nbsp;         */
<i>4125</i>&nbsp;        int shift = exponent - FloatConsts.SIGNIFICAND_WIDTH;
<i>4126</i>&nbsp;
<i>4127</i>&nbsp;        int twiceSignifFloor;
<i>4128</i>&nbsp;        // twiceSignifFloor will be == abs().shiftRight(shift).intValue()
<i>4129</i>&nbsp;        // We do the shift into an int directly to improve performance.
<b class="nc"><i>4130</i>&nbsp;</b>
<i>4131</i>&nbsp;        int nBits = shift &amp; 0x1f;
<i>4132</i>&nbsp;        int nBits2 = 32 - nBits;
<i>4133</i>&nbsp;
<b class="nc"><i>4134</i>&nbsp;        if (nBits == 0) {</b>
<i>4135</i>&nbsp;            twiceSignifFloor = mag[0];
<b class="nc"><i>4136</i>&nbsp;        } else {</b>
<i>4137</i>&nbsp;            twiceSignifFloor = mag[0] &gt;&gt;&gt; nBits;
<i>4138</i>&nbsp;            if (twiceSignifFloor == 0) {
<i>4139</i>&nbsp;                twiceSignifFloor = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);
<i>4140</i>&nbsp;            }
<i>4141</i>&nbsp;        }
<i>4142</i>&nbsp;
<b class="nc"><i>4143</i>&nbsp;        int signifFloor = twiceSignifFloor &gt;&gt; 1;</b>
<i>4144</i>&nbsp;        signifFloor &amp;= FloatConsts.SIGNIF_BIT_MASK; // remove the implied bit
<i>4145</i>&nbsp;
<i>4146</i>&nbsp;        /*
<b class="nc"><i>4147</i>&nbsp;         * We round up if either the fractional part of signif is strictly</b>
<i>4148</i>&nbsp;         * greater than 0.5 (which is true if the 0.5 bit is set and any lower
<i>4149</i>&nbsp;         * bit is set), or if the fractional part of signif is &gt;= 0.5 and
<i>4150</i>&nbsp;         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit
<b class="nc"><i>4151</i>&nbsp;         * are set). This is equivalent to the desired HALF_EVEN rounding.</b>
<b class="nc"><i>4152</i>&nbsp;         */</b>
<b class="nc"><i>4153</i>&nbsp;        boolean increment = (twiceSignifFloor &amp; 1) != 0</b>
<b class="nc"><i>4154</i>&nbsp;                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);</b>
<b class="nc"><i>4155</i>&nbsp;        int signifRounded = increment ? signifFloor + 1 : signifFloor;</b>
<b class="nc"><i>4156</i>&nbsp;        int bits = ((exponent + FloatConsts.EXP_BIAS))</b>
<b class="nc"><i>4157</i>&nbsp;                &lt;&lt; (FloatConsts.SIGNIFICAND_WIDTH - 1);</b>
<b class="nc"><i>4158</i>&nbsp;        bits += signifRounded;</b>
<b class="nc"><i>4159</i>&nbsp;        /*</b>
<i>4160</i>&nbsp;         * If signifRounded == 2^24, we&#39;d need to set all of the significand
<b class="nc"><i>4161</i>&nbsp;         * bits to zero and add 1 to the exponent. This is exactly the behavior</b>
<i>4162</i>&nbsp;         * we get from just adding signifRounded to bits directly. If the
<i>4163</i>&nbsp;         * exponent is Float.MAX_EXPONENT, we round up (correctly) to
<i>4164</i>&nbsp;         * Float.POSITIVE_INFINITY.
<i>4165</i>&nbsp;         */
<i>4166</i>&nbsp;        bits |= signum &amp; FloatConsts.SIGN_BIT_MASK;
<i>4167</i>&nbsp;        return Float.intBitsToFloat(bits);
<i>4168</i>&nbsp;    }
<i>4169</i>&nbsp;
<b class="nc"><i>4170</i>&nbsp;    /**</b>
<i>4171</i>&nbsp;     * Converts this BigInteger to a {@code double}.  This
<i>4172</i>&nbsp;     * conversion is similar to the
<b class="nc"><i>4173</i>&nbsp;     * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to</b>
<i>4174</i>&nbsp;     * {@code float} as defined in
<i>4175</i>&nbsp;     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
<i>4176</i>&nbsp;     * if this BigInteger has too great a magnitude
<i>4177</i>&nbsp;     * to represent as a {@code double}, it will be converted to
<i>4178</i>&nbsp;     * {@link Double#NEGATIVE_INFINITY} or {@link
<b class="nc"><i>4179</i>&nbsp;     * Double#POSITIVE_INFINITY} as appropriate.  Note that even when</b>
<i>4180</i>&nbsp;     * the return value is finite, this conversion can lose
<i>4181</i>&nbsp;     * information about the precision of the BigInteger value.
<b class="nc"><i>4182</i>&nbsp;     *</b>
<b class="nc"><i>4183</i>&nbsp;     * @return this BigInteger converted to a {@code double}.</b>
<b class="nc"><i>4184</i>&nbsp;     * @jls 5.1.3 Narrowing Primitive Conversion</b>
<i>4185</i>&nbsp;     */
<i>4186</i>&nbsp;    public double doubleValue() {
<i>4187</i>&nbsp;        if (signum == 0) {
<b class="nc"><i>4188</i>&nbsp;            return 0.0;</b>
<b class="nc"><i>4189</i>&nbsp;        }</b>
<b class="nc"><i>4190</i>&nbsp;</b>
<b class="nc"><i>4191</i>&nbsp;        int exponent = ((mag.length - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]) - 1;</b>
<b class="nc"><i>4192</i>&nbsp;</b>
<b class="nc"><i>4193</i>&nbsp;        // exponent == floor(log2(abs(this))Double)</b>
<b class="nc"><i>4194</i>&nbsp;        if (exponent &lt; Long.SIZE - 1) {</b>
<b class="nc"><i>4195</i>&nbsp;            return longValue();</b>
<i>4196</i>&nbsp;        } else if (exponent &gt; Double.MAX_EXPONENT) {
<i>4197</i>&nbsp;            return signum &gt; 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;
<b class="nc"><i>4198</i>&nbsp;        }</b>
<b class="nc"><i>4199</i>&nbsp;</b>
<i>4200</i>&nbsp;        /*
<i>4201</i>&nbsp;         * We need the top SIGNIFICAND_WIDTH bits, including the &quot;implicit&quot;
<i>4202</i>&nbsp;         * one bit. To make rounding easier, we pick out the top
<b class="nc"><i>4203</i>&nbsp;         * SIGNIFICAND_WIDTH + 1 bits, so we have one to help us round up or</b>
<b class="nc"><i>4204</i>&nbsp;         * down. twiceSignifFloor will contain the top SIGNIFICAND_WIDTH + 1</b>
<b class="nc"><i>4205</i>&nbsp;         * bits, and signifFloor the top SIGNIFICAND_WIDTH.</b>
<b class="nc"><i>4206</i>&nbsp;         *</b>
<i>4207</i>&nbsp;         * It helps to consider the real number signif = abs(this) *
<i>4208</i>&nbsp;         * 2^(SIGNIFICAND_WIDTH - 1 - exponent).
<b class="nc"><i>4209</i>&nbsp;         */</b>
<i>4210</i>&nbsp;        int shift = exponent - DoubleConsts.SIGNIFICAND_WIDTH;
<i>4211</i>&nbsp;
<i>4212</i>&nbsp;        long twiceSignifFloor;
<i>4213</i>&nbsp;        // twiceSignifFloor will be == abs().shiftRight(shift).longValue()
<i>4214</i>&nbsp;        // We do the shift into a long directly to improve performance.
<i>4215</i>&nbsp;
<i>4216</i>&nbsp;        int nBits = shift &amp; 0x1f;
<i>4217</i>&nbsp;        int nBits2 = 32 - nBits;
<i>4218</i>&nbsp;
<i>4219</i>&nbsp;        int highBits;
<b class="nc"><i>4220</i>&nbsp;        int lowBits;</b>
<i>4221</i>&nbsp;        if (nBits == 0) {
<i>4222</i>&nbsp;            highBits = mag[0];
<i>4223</i>&nbsp;            lowBits = mag[1];
<i>4224</i>&nbsp;        } else {
<b class="nc"><i>4225</i>&nbsp;            highBits = mag[0] &gt;&gt;&gt; nBits;</b>
<i>4226</i>&nbsp;            lowBits = (mag[0] &lt;&lt; nBits2) | (mag[1] &gt;&gt;&gt; nBits);
<b class="nc"><i>4227</i>&nbsp;            if (highBits == 0) {</b>
<b class="nc"><i>4228</i>&nbsp;                highBits = lowBits;</b>
<i>4229</i>&nbsp;                lowBits = (mag[1] &lt;&lt; nBits2) | (mag[2] &gt;&gt;&gt; nBits);
<i>4230</i>&nbsp;            }
<i>4231</i>&nbsp;        }
<b class="nc"><i>4232</i>&nbsp;</b>
<b class="nc"><i>4233</i>&nbsp;        twiceSignifFloor = ((highBits &amp; LONG_MASK) &lt;&lt; 32)</b>
<i>4234</i>&nbsp;                | (lowBits &amp; LONG_MASK);
<i>4235</i>&nbsp;
<b class="nc"><i>4236</i>&nbsp;        long signifFloor = twiceSignifFloor &gt;&gt; 1;</b>
<i>4237</i>&nbsp;        signifFloor &amp;= DoubleConsts.SIGNIF_BIT_MASK; // remove the implied bit
<i>4238</i>&nbsp;
<b class="nc"><i>4239</i>&nbsp;        /*</b>
<i>4240</i>&nbsp;         * We round up if either the fractional part of signif is strictly
<i>4241</i>&nbsp;         * greater than 0.5 (which is true if the 0.5 bit is set and any lower
<i>4242</i>&nbsp;         * bit is set), or if the fractional part of signif is &gt;= 0.5 and
<i>4243</i>&nbsp;         * signifFloor is odd (which is true if both the 0.5 bit and the 1 bit
<i>4244</i>&nbsp;         * are set). This is equivalent to the desired HALF_EVEN rounding.
<i>4245</i>&nbsp;         */
<i>4246</i>&nbsp;        boolean increment = (twiceSignifFloor &amp; 1) != 0
<i>4247</i>&nbsp;                &amp;&amp; ((signifFloor &amp; 1) != 0 || abs().getLowestSetBit() &lt; shift);
<i>4248</i>&nbsp;        long signifRounded = increment ? signifFloor + 1 : signifFloor;
<i>4249</i>&nbsp;        long bits = (long) ((exponent + DoubleConsts.EXP_BIAS))
<i>4250</i>&nbsp;                &lt;&lt; (DoubleConsts.SIGNIFICAND_WIDTH - 1);
<i>4251</i>&nbsp;        bits += signifRounded;
<i>4252</i>&nbsp;        /*
<b class="nc"><i>4253</i>&nbsp;         * If signifRounded == 2^53, we&#39;d need to set all of the significand</b>
<i>4254</i>&nbsp;         * bits to zero and add 1 to the exponent. This is exactly the behavior
<i>4255</i>&nbsp;         * we get from just adding signifRounded to bits directly. If the
<i>4256</i>&nbsp;         * exponent is Double.MAX_EXPONENT, we round up (correctly) to
<b class="nc"><i>4257</i>&nbsp;         * Double.POSITIVE_INFINITY.</b>
<b class="nc"><i>4258</i>&nbsp;         */</b>
<b class="nc"><i>4259</i>&nbsp;        bits |= signum &amp; DoubleConsts.SIGN_BIT_MASK;</b>
<b class="nc"><i>4260</i>&nbsp;        return Double.longBitsToDouble(bits);</b>
<b class="nc"><i>4261</i>&nbsp;    }</b>
<b class="nc"><i>4262</i>&nbsp;</b>
<b class="nc"><i>4263</i>&nbsp;    /**</b>
<b class="nc"><i>4264</i>&nbsp;     * Returns a copy of the input array stripped of any leading zero bytes.</b>
<b class="nc"><i>4265</i>&nbsp;     */</b>
<b class="nc"><i>4266</i>&nbsp;    private static int[] stripLeadingZeroInts(int val[]) {</b>
<b class="nc"><i>4267</i>&nbsp;        int vlen = val.length;</b>
<b class="nc"><i>4268</i>&nbsp;        int keep;</b>
<b class="nc"><i>4269</i>&nbsp;</b>
<b class="nc"><i>4270</i>&nbsp;        // Find first nonzero byte</b>
<b class="nc"><i>4271</i>&nbsp;        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)</b>
<b class="nc"><i>4272</i>&nbsp;            ;</b>
<b class="nc"><i>4273</i>&nbsp;        return java.util.Arrays.copyOfRange(val, keep, vlen);</b>
<b class="nc"><i>4274</i>&nbsp;    }</b>
<b class="nc"><i>4275</i>&nbsp;</b>
<i>4276</i>&nbsp;    /**
<i>4277</i>&nbsp;     * Returns the input array stripped of any leading zero bytes.
<i>4278</i>&nbsp;     * Since the source is trusted the copying may be skipped.
<i>4279</i>&nbsp;     */
<b class="nc"><i>4280</i>&nbsp;    private static int[] trustedStripLeadingZeroInts(int val[]) {</b>
<i>4281</i>&nbsp;        int vlen = val.length;
<i>4282</i>&nbsp;        int keep;
<i>4283</i>&nbsp;
<b class="nc"><i>4284</i>&nbsp;        // Find first nonzero byte</b>
<i>4285</i>&nbsp;        for (keep = 0; keep &lt; vlen &amp;&amp; val[keep] == 0; keep++)
<i>4286</i>&nbsp;            ;
<i>4287</i>&nbsp;        return keep == 0 ? val : java.util.Arrays.copyOfRange(val, keep, vlen);
<i>4288</i>&nbsp;    }
<i>4289</i>&nbsp;
<i>4290</i>&nbsp;    /**
<i>4291</i>&nbsp;     * Returns a copy of the input array stripped of any leading zero bytes.
<i>4292</i>&nbsp;     */
<i>4293</i>&nbsp;    private static int[] stripLeadingZeroBytes(byte a[], int off, int len) {
<i>4294</i>&nbsp;        int indexBound = off + len;
<i>4295</i>&nbsp;        int keep;
<i>4296</i>&nbsp;
<i>4297</i>&nbsp;        // Find first nonzero byte
<i>4298</i>&nbsp;        for (keep = off; keep &lt; indexBound &amp;&amp; a[keep] == 0; keep++)
<i>4299</i>&nbsp;            ;
<i>4300</i>&nbsp;
<i>4301</i>&nbsp;        // Allocate new array and copy relevant part of input array
<i>4302</i>&nbsp;        int intLength = ((indexBound - keep) + 3) &gt;&gt;&gt; 2;
<i>4303</i>&nbsp;        int[] result = new int[intLength];
<b class="nc"><i>4304</i>&nbsp;        int b = indexBound - 1;</b>
<i>4305</i>&nbsp;        for (int i = intLength-1; i &gt;= 0; i--) {
<i>4306</i>&nbsp;            result[i] = a[b--] &amp; 0xff;
<i>4307</i>&nbsp;            int bytesRemaining = b - keep + 1;
<i>4308</i>&nbsp;            int bytesToTransfer = Math.min(3, bytesRemaining);
<b class="nc"><i>4309</i>&nbsp;            for (int j=8; j &lt;= (bytesToTransfer &lt;&lt; 3); j += 8)</b>
<i>4310</i>&nbsp;                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);
<i>4311</i>&nbsp;        }
<i>4312</i>&nbsp;        return result;
<i>4313</i>&nbsp;    }
<b class="nc"><i>4314</i>&nbsp;</b>
<i>4315</i>&nbsp;    /**
<i>4316</i>&nbsp;     * Takes an array a representing a negative 2&#39;s-complement number and
<i>4317</i>&nbsp;     * returns the minimal (no leading zero bytes) unsigned whose value is -a.
<i>4318</i>&nbsp;     */
<i>4319</i>&nbsp;    private static int[] makePositive(byte a[], int off, int len) {
<i>4320</i>&nbsp;        int keep, k;
<i>4321</i>&nbsp;        int indexBound = off + len;
<i>4322</i>&nbsp;
<i>4323</i>&nbsp;        // Find first non-sign (0xff) byte of input
<b class="nc"><i>4324</i>&nbsp;        for (keep=off; keep &lt; indexBound &amp;&amp; a[keep] == -1; keep++)</b>
<b class="nc"><i>4325</i>&nbsp;            ;</b>
<b class="nc"><i>4326</i>&nbsp;</b>
<b class="nc"><i>4327</i>&nbsp;</b>
<i>4328</i>&nbsp;        /* Allocate output array.  If all non-sign bytes are 0x00, we must
<b class="nc"><i>4329</i>&nbsp;         * allocate space for one extra output byte. */</b>
<i>4330</i>&nbsp;        for (k=keep; k &lt; indexBound &amp;&amp; a[k] == 0; k++)
<b class="nc"><i>4331</i>&nbsp;            ;</b>
<b class="nc"><i>4332</i>&nbsp;</b>
<i>4333</i>&nbsp;        int extraByte = (k == indexBound) ? 1 : 0;
<i>4334</i>&nbsp;        int intLength = ((indexBound - keep + extraByte) + 3) &gt;&gt;&gt; 2;
<i>4335</i>&nbsp;        int result[] = new int[intLength];
<i>4336</i>&nbsp;
<i>4337</i>&nbsp;        /* Copy one&#39;s complement of input into output, leaving extra
<i>4338</i>&nbsp;         * byte (if it exists) == 0x00 */
<i>4339</i>&nbsp;        int b = indexBound - 1;
<i>4340</i>&nbsp;        for (int i = intLength-1; i &gt;= 0; i--) {
<b class="nc"><i>4341</i>&nbsp;            result[i] = a[b--] &amp; 0xff;</b>
<b class="nc"><i>4342</i>&nbsp;            int numBytesToTransfer = Math.min(3, b-keep+1);</b>
<b class="nc"><i>4343</i>&nbsp;            if (numBytesToTransfer &lt; 0)</b>
<i>4344</i>&nbsp;                numBytesToTransfer = 0;
<i>4345</i>&nbsp;            for (int j=8; j &lt;= 8*numBytesToTransfer; j += 8)
<i>4346</i>&nbsp;                result[i] |= ((a[b--] &amp; 0xff) &lt;&lt; j);
<b class="nc"><i>4347</i>&nbsp;</b>
<b class="nc"><i>4348</i>&nbsp;            // Mask indicates which bits must be complemented</b>
<i>4349</i>&nbsp;            int mask = -1 &gt;&gt;&gt; (8*(3-numBytesToTransfer));
<b class="nc"><i>4350</i>&nbsp;            result[i] = ~result[i] &amp; mask;</b>
<b class="nc"><i>4351</i>&nbsp;        }</b>
<i>4352</i>&nbsp;
<b class="nc"><i>4353</i>&nbsp;        // Add one to one&#39;s complement to generate two&#39;s complement</b>
<i>4354</i>&nbsp;        for (int i=result.length-1; i &gt;= 0; i--) {
<i>4355</i>&nbsp;            result[i] = (int)((result[i] &amp; LONG_MASK) + 1);
<i>4356</i>&nbsp;            if (result[i] != 0)
<i>4357</i>&nbsp;                break;
<i>4358</i>&nbsp;        }
<i>4359</i>&nbsp;
<i>4360</i>&nbsp;        return result;
<i>4361</i>&nbsp;    }
<i>4362</i>&nbsp;
<i>4363</i>&nbsp;    /**
<i>4364</i>&nbsp;     * Takes an array a representing a negative 2&#39;s-complement number and
<i>4365</i>&nbsp;     * returns the minimal (no leading zero ints) unsigned whose value is -a.
<i>4366</i>&nbsp;     */
<i>4367</i>&nbsp;    private static int[] makePositive(int a[]) {
<i>4368</i>&nbsp;        int keep, j;
<i>4369</i>&nbsp;
<i>4370</i>&nbsp;        // Find first non-sign (0xffffffff) int of input
<i>4371</i>&nbsp;        for (keep=0; keep &lt; a.length &amp;&amp; a[keep] == -1; keep++)
<i>4372</i>&nbsp;            ;
<i>4373</i>&nbsp;
<b class="nc"><i>4374</i>&nbsp;        /* Allocate output array.  If all non-sign ints are 0x00, we must</b>
<i>4375</i>&nbsp;         * allocate space for one extra output int. */
<i>4376</i>&nbsp;        for (j=keep; j &lt; a.length &amp;&amp; a[j] == 0; j++)
<i>4377</i>&nbsp;            ;
<i>4378</i>&nbsp;        int extraInt = (j == a.length ? 1 : 0);
<i>4379</i>&nbsp;        int result[] = new int[a.length - keep + extraInt];
<i>4380</i>&nbsp;
<i>4381</i>&nbsp;        /* Copy one&#39;s complement of input into output, leaving extra
<i>4382</i>&nbsp;         * int (if it exists) == 0x00 */
<i>4383</i>&nbsp;        for (int i = keep; i &lt; a.length; i++)
<i>4384</i>&nbsp;            result[i - keep + extraInt] = ~a[i];
<i>4385</i>&nbsp;
<i>4386</i>&nbsp;        // Add one to one&#39;s complement to generate two&#39;s complement
<i>4387</i>&nbsp;        for (int i=result.length-1; ++result[i] == 0; i--)
<i>4388</i>&nbsp;            ;
<i>4389</i>&nbsp;
<i>4390</i>&nbsp;        return result;
<i>4391</i>&nbsp;    }
<i>4392</i>&nbsp;
<i>4393</i>&nbsp;    /*
<i>4394</i>&nbsp;     * The following two arrays are used for fast String conversions.  Both
<i>4395</i>&nbsp;     * are indexed by radix.  The first is the number of digits of the given
<i>4396</i>&nbsp;     * radix that can fit in a Java long without &quot;going negative&quot;, i.e., the
<i>4397</i>&nbsp;     * highest integer n such that radix**n &lt; 2**63.  The second is the
<i>4398</i>&nbsp;     * &quot;long radix&quot; that tears each number into &quot;long digits&quot;, each of which
<i>4399</i>&nbsp;     * consists of the number of digits in the corresponding element in
<i>4400</i>&nbsp;     * digitsPerLong (longRadix[i] = i**digitPerLong[i]).  Both arrays have
<i>4401</i>&nbsp;     * nonsense values in their 0 and 1 elements, as radixes 0 and 1 are not
<i>4402</i>&nbsp;     * used.
<i>4403</i>&nbsp;     */
<i>4404</i>&nbsp;    private static int digitsPerLong[] = {0, 0,
<i>4405</i>&nbsp;        62, 39, 31, 27, 24, 22, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14,
<b class="nc"><i>4406</i>&nbsp;        14, 14, 14, 13, 13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12};</b>
<i>4407</i>&nbsp;
<i>4408</i>&nbsp;    private static BigInteger longRadix[] = {null, null,
<b class="nc"><i>4409</i>&nbsp;        valueOf(0x4000000000000000L), valueOf(0x383d9170b85ff80bL),</b>
<b class="nc"><i>4410</i>&nbsp;        valueOf(0x4000000000000000L), valueOf(0x6765c793fa10079dL),</b>
<i>4411</i>&nbsp;        valueOf(0x41c21cb8e1000000L), valueOf(0x3642798750226111L),
<i>4412</i>&nbsp;        valueOf(0x1000000000000000L), valueOf(0x12bf307ae81ffd59L),
<b class="nc"><i>4413</i>&nbsp;        valueOf( 0xde0b6b3a7640000L), valueOf(0x4d28cb56c33fa539L),</b>
<b class="nc"><i>4414</i>&nbsp;        valueOf(0x1eca170c00000000L), valueOf(0x780c7372621bd74dL),</b>
<b class="nc"><i>4415</i>&nbsp;        valueOf(0x1e39a5057d810000L), valueOf(0x5b27ac993df97701L),</b>
<b class="nc"><i>4416</i>&nbsp;        valueOf(0x1000000000000000L), valueOf(0x27b95e997e21d9f1L),</b>
<b class="nc"><i>4417</i>&nbsp;        valueOf(0x5da0e1e53c5c8000L), valueOf( 0xb16a458ef403f19L),</b>
<i>4418</i>&nbsp;        valueOf(0x16bcc41e90000000L), valueOf(0x2d04b7fdd9c0ef49L),
<b class="nc"><i>4419</i>&nbsp;        valueOf(0x5658597bcaa24000L), valueOf( 0x6feb266931a75b7L),</b>
<b class="nc"><i>4420</i>&nbsp;        valueOf( 0xc29e98000000000L), valueOf(0x14adf4b7320334b9L),</b>
<b class="nc"><i>4421</i>&nbsp;        valueOf(0x226ed36478bfa000L), valueOf(0x383d9170b85ff80bL),</b>
<b class="nc"><i>4422</i>&nbsp;        valueOf(0x5a3c23e39c000000L), valueOf( 0x4e900abb53e6b71L),</b>
<b class="nc"><i>4423</i>&nbsp;        valueOf( 0x7600ec618141000L), valueOf( 0xaee5720ee830681L),</b>
<b class="nc"><i>4424</i>&nbsp;        valueOf(0x1000000000000000L), valueOf(0x172588ad4f5f0981L),</b>
<i>4425</i>&nbsp;        valueOf(0x211e44f7d02c1000L), valueOf(0x2ee56725f06e5c71L),
<i>4426</i>&nbsp;        valueOf(0x41c21cb8e1000000L)};
<i>4427</i>&nbsp;
<b class="nc"><i>4428</i>&nbsp;    /*</b>
<i>4429</i>&nbsp;     * These two arrays are the integer analogue of above.
<i>4430</i>&nbsp;     */
<b class="nc"><i>4431</i>&nbsp;    private static int digitsPerInt[] = {0, 0, 30, 19, 15, 13, 11,</b>
<b class="nc"><i>4432</i>&nbsp;        11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,</b>
<i>4433</i>&nbsp;        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5};
<b class="nc"><i>4434</i>&nbsp;</b>
<b class="nc"><i>4435</i>&nbsp;    private static int intRadix[] = {0, 0,</b>
<b class="nc"><i>4436</i>&nbsp;        0x40000000, 0x4546b3db, 0x40000000, 0x48c27395, 0x159fd800,</b>
<b class="nc"><i>4437</i>&nbsp;        0x75db9c97, 0x40000000, 0x17179149, 0x3b9aca00, 0xcc6db61,</b>
<i>4438</i>&nbsp;        0x19a10000, 0x309f1021, 0x57f6c100, 0xa2f1b6f,  0x10000000,
<i>4439</i>&nbsp;        0x18754571, 0x247dbc80, 0x3547667b, 0x4c4b4000, 0x6b5a6e1d,
<i>4440</i>&nbsp;        0x6c20a40,  0x8d2d931,  0xb640000,  0xe8d4a51,  0x1269ae40,
<i>4441</i>&nbsp;        0x17179149, 0x1cb91000, 0x23744899, 0x2b73a840, 0x34e63b41,
<b class="nc"><i>4442</i>&nbsp;        0x40000000, 0x4cfa3cc1, 0x5c13d840, 0x6d91b519, 0x39aa400</b>
<i>4443</i>&nbsp;    };
<i>4444</i>&nbsp;
<i>4445</i>&nbsp;    /**
<i>4446</i>&nbsp;     * These routines provide access to the two&#39;s complement representation
<i>4447</i>&nbsp;     * of BigIntegers.
<b class="nc"><i>4448</i>&nbsp;     */</b>
<b class="nc"><i>4449</i>&nbsp;</b>
<b class="nc"><i>4450</i>&nbsp;    /**</b>
<b class="nc"><i>4451</i>&nbsp;     * Returns the length of the two&#39;s complement representation in ints,</b>
<b class="nc"><i>4452</i>&nbsp;     * including space for at least one sign bit.</b>
<b class="nc"><i>4453</i>&nbsp;     */</b>
<b class="nc"><i>4454</i>&nbsp;    private int intLength() {</b>
<b class="nc"><i>4455</i>&nbsp;        return (bitLength() &gt;&gt;&gt; 5) + 1;</b>
<i>4456</i>&nbsp;    }
<i>4457</i>&nbsp;
<i>4458</i>&nbsp;    /* Returns sign bit */
<b class="nc"><i>4459</i>&nbsp;    private int signBit() {</b>
<i>4460</i>&nbsp;        return signum &lt; 0 ? 1 : 0;
<i>4461</i>&nbsp;    }
<i>4462</i>&nbsp;
<b class="nc"><i>4463</i>&nbsp;    /* Returns an int of sign bits */</b>
<i>4464</i>&nbsp;    private int signInt() {
<i>4465</i>&nbsp;        return signum &lt; 0 ? -1 : 0;
<i>4466</i>&nbsp;    }
<i>4467</i>&nbsp;
<i>4468</i>&nbsp;    /**
<i>4469</i>&nbsp;     * Returns the specified int of the little-endian two&#39;s complement
<i>4470</i>&nbsp;     * representation (int 0 is the least significant).  The int number can
<i>4471</i>&nbsp;     * be arbitrarily high (values are logically preceded by infinitely many
<i>4472</i>&nbsp;     * sign ints).
<i>4473</i>&nbsp;     */
<i>4474</i>&nbsp;    private int getInt(int n) {
<i>4475</i>&nbsp;        if (n &lt; 0)
<i>4476</i>&nbsp;            return 0;
<b class="nc"><i>4477</i>&nbsp;        if (n &gt;= mag.length)</b>
<b class="nc"><i>4478</i>&nbsp;            return signInt();</b>
<b class="nc"><i>4479</i>&nbsp;</b>
<i>4480</i>&nbsp;        int magInt = mag[mag.length-n-1];
<i>4481</i>&nbsp;
<b class="nc"><i>4482</i>&nbsp;        return (signum &gt;= 0 ? magInt :</b>
<b class="nc"><i>4483</i>&nbsp;                (n &lt;= firstNonzeroIntNum() ? -magInt : ~magInt));</b>
<b class="nc"><i>4484</i>&nbsp;    }</b>
<b class="nc"><i>4485</i>&nbsp;</b>
<i>4486</i>&nbsp;    /**
<i>4487</i>&nbsp;    * Returns the index of the int that contains the first nonzero int in the
<b class="nc"><i>4488</i>&nbsp;    * little-endian binary representation of the magnitude (int 0 is the</b>
<i>4489</i>&nbsp;    * least significant). If the magnitude is zero, return value is undefined.
<i>4490</i>&nbsp;    *
<i>4491</i>&nbsp;    * &lt;p&gt;Note: never used for a BigInteger with a magnitude of zero.
<i>4492</i>&nbsp;    * @see #getInt.
<i>4493</i>&nbsp;    */
<i>4494</i>&nbsp;    private int firstNonzeroIntNum() {
<b class="nc"><i>4495</i>&nbsp;        int fn = firstNonzeroIntNumPlusTwo - 2;</b>
<i>4496</i>&nbsp;        if (fn == -2) { // firstNonzeroIntNum not initialized yet
<b class="nc"><i>4497</i>&nbsp;            // Search for the first nonzero int</b>
<b class="nc"><i>4498</i>&nbsp;            int i;</b>
<b class="nc"><i>4499</i>&nbsp;            int mlen = mag.length;</b>
<i>4500</i>&nbsp;            for (i = mlen - 1; i &gt;= 0 &amp;&amp; mag[i] == 0; i--)
<b class="nc"><i>4501</i>&nbsp;                ;</b>
<b class="nc"><i>4502</i>&nbsp;            fn = mlen - i - 1;</b>
<b class="nc"><i>4503</i>&nbsp;            firstNonzeroIntNumPlusTwo = fn + 2; // offset by two to initialize</b>
<b class="nc"><i>4504</i>&nbsp;        }</b>
<b class="nc"><i>4505</i>&nbsp;        return fn;</b>
<i>4506</i>&nbsp;    }
<b class="nc"><i>4507</i>&nbsp;</b>
<b class="nc"><i>4508</i>&nbsp;    /** use serialVersionUID from JDK 1.1. for interoperability */</b>
<i>4509</i>&nbsp;    private static final long serialVersionUID = -8287574255936472291L;
<b class="nc"><i>4510</i>&nbsp;</b>
<i>4511</i>&nbsp;    /**
<b class="nc"><i>4512</i>&nbsp;     * Serializable fields for BigInteger.</b>
<i>4513</i>&nbsp;     *
<i>4514</i>&nbsp;     * @serialField signum  int
<i>4515</i>&nbsp;     *              signum of this BigInteger
<i>4516</i>&nbsp;     * @serialField magnitude byte[]
<i>4517</i>&nbsp;     *              magnitude array of this BigInteger
<i>4518</i>&nbsp;     * @serialField bitCount  int
<i>4519</i>&nbsp;     *              appears in the serialized form for backward compatibility
<i>4520</i>&nbsp;     * @serialField bitLength int
<i>4521</i>&nbsp;     *              appears in the serialized form for backward compatibility
<i>4522</i>&nbsp;     * @serialField firstNonzeroByteNum int
<i>4523</i>&nbsp;     *              appears in the serialized form for backward compatibility
<i>4524</i>&nbsp;     * @serialField lowestSetBit int
<i>4525</i>&nbsp;     *              appears in the serialized form for backward compatibility
<i>4526</i>&nbsp;     */
<i>4527</i>&nbsp;    private static final ObjectStreamField[] serialPersistentFields = {
<b class="nc"><i>4528</i>&nbsp;        new ObjectStreamField(&quot;signum&quot;, Integer.TYPE),</b>
<b class="nc"><i>4529</i>&nbsp;        new ObjectStreamField(&quot;magnitude&quot;, byte[].class),</b>
<i>4530</i>&nbsp;        new ObjectStreamField(&quot;bitCount&quot;, Integer.TYPE),
<b class="nc"><i>4531</i>&nbsp;        new ObjectStreamField(&quot;bitLength&quot;, Integer.TYPE),</b>
<i>4532</i>&nbsp;        new ObjectStreamField(&quot;firstNonzeroByteNum&quot;, Integer.TYPE),
<i>4533</i>&nbsp;        new ObjectStreamField(&quot;lowestSetBit&quot;, Integer.TYPE)
<i>4534</i>&nbsp;        };
<i>4535</i>&nbsp;
<i>4536</i>&nbsp;    /**
<i>4537</i>&nbsp;     * Reconstitute the {@code BigInteger} instance from a stream (that is,
<i>4538</i>&nbsp;     * deserialize it). The magnitude is read in as an array of bytes
<i>4539</i>&nbsp;     * for historical reasons, but it is converted to an array of ints
<i>4540</i>&nbsp;     * and the byte array is discarded.
<i>4541</i>&nbsp;     * Note:
<i>4542</i>&nbsp;     * The current convention is to initialize the cache fields, bitCountPlusOne,
<i>4543</i>&nbsp;     * bitLengthPlusOne and lowestSetBitPlusTwo, to 0 rather than some other
<i>4544</i>&nbsp;     * marker value. Therefore, no explicit action to set these fields needs to
<i>4545</i>&nbsp;     * be taken in readObject because those fields already have a 0 value by
<i>4546</i>&nbsp;     * default since defaultReadObject is not being used.
<b class="nc"><i>4547</i>&nbsp;     */</b>
<b class="nc"><i>4548</i>&nbsp;    private void readObject(java.io.ObjectInputStream s)</b>
<i>4549</i>&nbsp;        throws java.io.IOException, ClassNotFoundException {
<b class="nc"><i>4550</i>&nbsp;        // prepare to read the alternate persistent fields</b>
<i>4551</i>&nbsp;        ObjectInputStream.GetField fields = s.readFields();
<i>4552</i>&nbsp;
<i>4553</i>&nbsp;        // Read the alternate persistent fields that we care about
<i>4554</i>&nbsp;        int sign = fields.get(&quot;signum&quot;, -2);
<i>4555</i>&nbsp;        byte[] magnitude = (byte[])fields.get(&quot;magnitude&quot;, null);
<i>4556</i>&nbsp;
<i>4557</i>&nbsp;        // Validate signum
<i>4558</i>&nbsp;        if (sign &lt; -1 || sign &gt; 1) {
<i>4559</i>&nbsp;            String message = &quot;BigInteger: Invalid signum value&quot;;
<i>4560</i>&nbsp;            if (fields.defaulted(&quot;signum&quot;))
<i>4561</i>&nbsp;                message = &quot;BigInteger: Signum not present in stream&quot;;
<i>4562</i>&nbsp;            throw new java.io.StreamCorruptedException(message);
<i>4563</i>&nbsp;        }
<i>4564</i>&nbsp;        int[] mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);
<i>4565</i>&nbsp;        if ((mag.length == 0) != (sign == 0)) {
<b class="nc"><i>4566</i>&nbsp;            String message = &quot;BigInteger: signum-magnitude mismatch&quot;;</b>
<b class="nc"><i>4567</i>&nbsp;            if (fields.defaulted(&quot;magnitude&quot;))</b>
<b class="nc"><i>4568</i>&nbsp;                message = &quot;BigInteger: Magnitude not present in stream&quot;;</b>
<b class="nc"><i>4569</i>&nbsp;            throw new java.io.StreamCorruptedException(message);</b>
<i>4570</i>&nbsp;        }
<b class="nc"><i>4571</i>&nbsp;</b>
<i>4572</i>&nbsp;        // Commit final fields via Unsafe
<i>4573</i>&nbsp;        UnsafeHolder.putSign(this, sign);
<i>4574</i>&nbsp;
<i>4575</i>&nbsp;        // Calculate mag field from magnitude and discard magnitude
<i>4576</i>&nbsp;        UnsafeHolder.putMag(this, mag);
<i>4577</i>&nbsp;        if (mag.length &gt;= MAX_MAG_LENGTH) {
<i>4578</i>&nbsp;            try {
<i>4579</i>&nbsp;                checkRange();
<i>4580</i>&nbsp;            } catch (ArithmeticException e) {
<i>4581</i>&nbsp;                throw new java.io.StreamCorruptedException(&quot;BigInteger: Out of the supported range&quot;);
<i>4582</i>&nbsp;            }
<i>4583</i>&nbsp;        }
<i>4584</i>&nbsp;    }
<i>4585</i>&nbsp;
<i>4586</i>&nbsp;    // Support for resetting final fields while deserializing
<b class="nc"><i>4587</i>&nbsp;    private static class UnsafeHolder {</b>
<b class="nc"><i>4588</i>&nbsp;        private static final jdk.internal.misc.Unsafe unsafe</b>
<b class="nc"><i>4589</i>&nbsp;                = jdk.internal.misc.Unsafe.getUnsafe();</b>
<b class="nc"><i>4590</i>&nbsp;        private static final long signumOffset</b>
<i>4591</i>&nbsp;                = unsafe.objectFieldOffset(BigInteger.class, &quot;signum&quot;);
<b class="nc"><i>4592</i>&nbsp;        private static final long magOffset</b>
<i>4593</i>&nbsp;                = unsafe.objectFieldOffset(BigInteger.class, &quot;mag&quot;);
<i>4594</i>&nbsp;
<i>4595</i>&nbsp;        static void putSign(BigInteger bi, int sign) {
<i>4596</i>&nbsp;            unsafe.putInt(bi, signumOffset, sign);
<i>4597</i>&nbsp;        }
<i>4598</i>&nbsp;
<i>4599</i>&nbsp;        static void putMag(BigInteger bi, int[] magnitude) {
<i>4600</i>&nbsp;            unsafe.putObject(bi, magOffset, magnitude);
<i>4601</i>&nbsp;        }
<i>4602</i>&nbsp;    }
<i>4603</i>&nbsp;
<i>4604</i>&nbsp;    /**
<i>4605</i>&nbsp;     * Save the {@code BigInteger} instance to a stream.  The magnitude of a
<i>4606</i>&nbsp;     * {@code BigInteger} is serialized as a byte array for historical reasons.
<i>4607</i>&nbsp;     * To maintain compatibility with older implementations, the integers
<i>4608</i>&nbsp;     * -1, -1, -2, and -2 are written as the values of the obsolete fields
<i>4609</i>&nbsp;     * {@code bitCount}, {@code bitLength}, {@code lowestSetBit}, and
<i>4610</i>&nbsp;     * {@code firstNonzeroByteNum}, respectively.  These values are compatible
<i>4611</i>&nbsp;     * with older implementations, but will be ignored by current
<i>4612</i>&nbsp;     * implementations.
<i>4613</i>&nbsp;     */
<i>4614</i>&nbsp;    private void writeObject(ObjectOutputStream s) throws IOException {
<i>4615</i>&nbsp;        // set the values of the Serializable fields
<i>4616</i>&nbsp;        ObjectOutputStream.PutField fields = s.putFields();
<i>4617</i>&nbsp;        fields.put(&quot;signum&quot;, signum);
<i>4618</i>&nbsp;        fields.put(&quot;magnitude&quot;, magSerializedForm());
<i>4619</i>&nbsp;        // The values written for cached fields are compatible with older
<i>4620</i>&nbsp;        // versions, but are ignored in readObject so don&#39;t otherwise matter.
<i>4621</i>&nbsp;        fields.put(&quot;bitCount&quot;, -1);
<i>4622</i>&nbsp;        fields.put(&quot;bitLength&quot;, -1);
<i>4623</i>&nbsp;        fields.put(&quot;lowestSetBit&quot;, -2);
<i>4624</i>&nbsp;        fields.put(&quot;firstNonzeroByteNum&quot;, -2);
<i>4625</i>&nbsp;
<i>4626</i>&nbsp;        // save them
<i>4627</i>&nbsp;        s.writeFields();
<i>4628</i>&nbsp;    }
<i>4629</i>&nbsp;
<i>4630</i>&nbsp;    /**
<i>4631</i>&nbsp;     * Returns the mag array as an array of bytes.
<i>4632</i>&nbsp;     */
<i>4633</i>&nbsp;    private byte[] magSerializedForm() {
<i>4634</i>&nbsp;        int len = mag.length;
<i>4635</i>&nbsp;
<i>4636</i>&nbsp;        int bitLen = (len == 0 ? 0 : ((len - 1) &lt;&lt; 5) + bitLengthForInt(mag[0]));
<i>4637</i>&nbsp;        int byteLen = (bitLen + 7) &gt;&gt;&gt; 3;
<i>4638</i>&nbsp;        byte[] result = new byte[byteLen];
<i>4639</i>&nbsp;
<i>4640</i>&nbsp;        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;
<i>4641</i>&nbsp;             i &gt;= 0; i--) {
<i>4642</i>&nbsp;            if (bytesCopied == 4) {
<i>4643</i>&nbsp;                nextInt = mag[intIndex--];
<i>4644</i>&nbsp;                bytesCopied = 1;
<i>4645</i>&nbsp;            } else {
<i>4646</i>&nbsp;                nextInt &gt;&gt;&gt;= 8;
<i>4647</i>&nbsp;                bytesCopied++;
<i>4648</i>&nbsp;            }
<i>4649</i>&nbsp;            result[i] = (byte)nextInt;
<i>4650</i>&nbsp;        }
<i>4651</i>&nbsp;        return result;
<i>4652</i>&nbsp;    }
<i>4653</i>&nbsp;
<i>4654</i>&nbsp;    /**
<i>4655</i>&nbsp;     * Converts this {@code BigInteger} to a {@code long}, checking
<i>4656</i>&nbsp;     * for lost information.  If the value of this {@code BigInteger}
<i>4657</i>&nbsp;     * is out of the range of the {@code long} type, then an
<i>4658</i>&nbsp;     * {@code ArithmeticException} is thrown.
<i>4659</i>&nbsp;     *
<i>4660</i>&nbsp;     * @return this {@code BigInteger} converted to a {@code long}.
<i>4661</i>&nbsp;     * @throws ArithmeticException if the value of {@code this} will
<i>4662</i>&nbsp;     * not exactly fit in a {@code long}.
<i>4663</i>&nbsp;     * @see BigInteger#longValue
<i>4664</i>&nbsp;     * @since  1.8
<i>4665</i>&nbsp;     */
<i>4666</i>&nbsp;    public long longValueExact() {
<i>4667</i>&nbsp;        if (mag.length &lt;= 2 &amp;&amp; bitLength() &lt;= 63)
<i>4668</i>&nbsp;            return longValue();
<i>4669</i>&nbsp;        else
<i>4670</i>&nbsp;            throw new ArithmeticException(&quot;BigInteger out of long range&quot;);
<i>4671</i>&nbsp;    }
<i>4672</i>&nbsp;
<i>4673</i>&nbsp;    /**
<i>4674</i>&nbsp;     * Converts this {@code BigInteger} to an {@code int}, checking
<i>4675</i>&nbsp;     * for lost information.  If the value of this {@code BigInteger}
<i>4676</i>&nbsp;     * is out of the range of the {@code int} type, then an
<i>4677</i>&nbsp;     * {@code ArithmeticException} is thrown.
<i>4678</i>&nbsp;     *
<i>4679</i>&nbsp;     * @return this {@code BigInteger} converted to an {@code int}.
<i>4680</i>&nbsp;     * @throws ArithmeticException if the value of {@code this} will
<i>4681</i>&nbsp;     * not exactly fit in an {@code int}.
<i>4682</i>&nbsp;     * @see BigInteger#intValue
<i>4683</i>&nbsp;     * @since  1.8
<i>4684</i>&nbsp;     */
<i>4685</i>&nbsp;    public int intValueExact() {
<i>4686</i>&nbsp;        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31)
<i>4687</i>&nbsp;            return intValue();
<i>4688</i>&nbsp;        else
<i>4689</i>&nbsp;            throw new ArithmeticException(&quot;BigInteger out of int range&quot;);
<i>4690</i>&nbsp;    }
<i>4691</i>&nbsp;
<i>4692</i>&nbsp;    /**
<i>4693</i>&nbsp;     * Converts this {@code BigInteger} to a {@code short}, checking
<i>4694</i>&nbsp;     * for lost information.  If the value of this {@code BigInteger}
<i>4695</i>&nbsp;     * is out of the range of the {@code short} type, then an
<i>4696</i>&nbsp;     * {@code ArithmeticException} is thrown.
<i>4697</i>&nbsp;     *
<i>4698</i>&nbsp;     * @return this {@code BigInteger} converted to a {@code short}.
<i>4699</i>&nbsp;     * @throws ArithmeticException if the value of {@code this} will
<i>4700</i>&nbsp;     * not exactly fit in a {@code short}.
<i>4701</i>&nbsp;     * @see BigInteger#shortValue
<i>4702</i>&nbsp;     * @since  1.8
<i>4703</i>&nbsp;     */
<i>4704</i>&nbsp;    public short shortValueExact() {
<i>4705</i>&nbsp;        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {
<i>4706</i>&nbsp;            int value = intValue();
<i>4707</i>&nbsp;            if (value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE)
<i>4708</i>&nbsp;                return shortValue();
<i>4709</i>&nbsp;        }
<i>4710</i>&nbsp;        throw new ArithmeticException(&quot;BigInteger out of short range&quot;);
<i>4711</i>&nbsp;    }
<i>4712</i>&nbsp;
<i>4713</i>&nbsp;    /**
<i>4714</i>&nbsp;     * Converts this {@code BigInteger} to a {@code byte}, checking
<i>4715</i>&nbsp;     * for lost information.  If the value of this {@code BigInteger}
<i>4716</i>&nbsp;     * is out of the range of the {@code byte} type, then an
<i>4717</i>&nbsp;     * {@code ArithmeticException} is thrown.
<i>4718</i>&nbsp;     *
<i>4719</i>&nbsp;     * @return this {@code BigInteger} converted to a {@code byte}.
<i>4720</i>&nbsp;     * @throws ArithmeticException if the value of {@code this} will
<i>4721</i>&nbsp;     * not exactly fit in a {@code byte}.
<i>4722</i>&nbsp;     * @see BigInteger#byteValue
<i>4723</i>&nbsp;     * @since  1.8
<i>4724</i>&nbsp;     */
<i>4725</i>&nbsp;    public byte byteValueExact() {
<i>4726</i>&nbsp;        if (mag.length &lt;= 1 &amp;&amp; bitLength() &lt;= 31) {
<i>4727</i>&nbsp;            int value = intValue();
<i>4728</i>&nbsp;            if (value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE)
<i>4729</i>&nbsp;                return byteValue();
<i>4730</i>&nbsp;        }
<i>4731</i>&nbsp;        throw new ArithmeticException(&quot;BigInteger out of byte range&quot;);
<i>4732</i>&nbsp;    }
<i>4733</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:10</div>
</div>
</body>
</html>
