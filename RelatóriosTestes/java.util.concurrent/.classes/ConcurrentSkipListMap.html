


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ConcurrentSkipListMap</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util.concurrent</a> ]
</div>

<h1>Coverage Summary for Class: ConcurrentSkipListMap (java.util.concurrent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ConcurrentSkipListMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 81)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 642)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$CSLMSpliterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$EntryIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$EntrySet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$EntrySpliterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$HeadIndex</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$Index</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$Iter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$KeyIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$KeySet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$KeySpliterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$Node</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$SubMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 240)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$SubMap$SubMapEntryIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$SubMap$SubMapIter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 57)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$SubMap$SubMapKeyIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$SubMap$SubMapValueIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$ValueIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$Values</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentSkipListMap$ValueSpliterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 41)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 258)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1273)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>3</i>&nbsp; *
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; */
<i>24</i>&nbsp;
<i>25</i>&nbsp;/*
<i>26</i>&nbsp; *
<i>27</i>&nbsp; *
<i>28</i>&nbsp; *
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *
<i>31</i>&nbsp; * Written by Doug Lea with assistance from members of JCP JSR-166
<i>32</i>&nbsp; * Expert Group and released to the public domain, as explained at
<i>33</i>&nbsp; * http://creativecommons.org/publicdomain/zero/1.0/
<i>34</i>&nbsp; */
<i>35</i>&nbsp;
<i>36</i>&nbsp;package java.util.concurrent;
<i>37</i>&nbsp;
<i>38</i>&nbsp;import java.lang.invoke.MethodHandles;
<i>39</i>&nbsp;import java.lang.invoke.VarHandle;
<i>40</i>&nbsp;import java.io.Serializable;
<i>41</i>&nbsp;import java.util.AbstractCollection;
<i>42</i>&nbsp;import java.util.AbstractMap;
<i>43</i>&nbsp;import java.util.AbstractSet;
<i>44</i>&nbsp;import java.util.ArrayList;
<i>45</i>&nbsp;import java.util.Collection;
<i>46</i>&nbsp;import java.util.Collections;
<i>47</i>&nbsp;import java.util.Comparator;
<i>48</i>&nbsp;import java.util.Iterator;
<i>49</i>&nbsp;import java.util.List;
<i>50</i>&nbsp;import java.util.Map;
<i>51</i>&nbsp;import java.util.NavigableSet;
<i>52</i>&nbsp;import java.util.NoSuchElementException;
<i>53</i>&nbsp;import java.util.Set;
<i>54</i>&nbsp;import java.util.SortedMap;
<i>55</i>&nbsp;import java.util.Spliterator;
<i>56</i>&nbsp;import java.util.function.BiConsumer;
<i>57</i>&nbsp;import java.util.function.BiFunction;
<i>58</i>&nbsp;import java.util.function.Consumer;
<i>59</i>&nbsp;import java.util.function.Function;
<i>60</i>&nbsp;import java.util.function.Predicate;
<i>61</i>&nbsp;import java.util.concurrent.atomic.LongAdder;
<i>62</i>&nbsp;
<i>63</i>&nbsp;/**
<i>64</i>&nbsp; * A scalable concurrent {@link ConcurrentNavigableMap} implementation.
<i>65</i>&nbsp; * The map is sorted according to the {@linkplain Comparable natural
<i>66</i>&nbsp; * ordering} of its keys, or by a {@link Comparator} provided at map
<i>67</i>&nbsp; * creation time, depending on which constructor is used.
<i>68</i>&nbsp; *
<i>69</i>&nbsp; * &lt;p&gt;This class implements a concurrent variant of &lt;a
<i>70</i>&nbsp; * href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot; target=&quot;_top&quot;&gt;SkipLists&lt;/a&gt;
<i>71</i>&nbsp; * providing expected average &lt;i&gt;log(n)&lt;/i&gt; time cost for the
<i>72</i>&nbsp; * {@code containsKey}, {@code get}, {@code put} and
<i>73</i>&nbsp; * {@code remove} operations and their variants.  Insertion, removal,
<i>74</i>&nbsp; * update, and access operations safely execute concurrently by
<i>75</i>&nbsp; * multiple threads.
<i>76</i>&nbsp; *
<i>77</i>&nbsp; * &lt;p&gt;Iterators and spliterators are
<i>78</i>&nbsp; * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
<i>79</i>&nbsp; *
<i>80</i>&nbsp; * &lt;p&gt;Ascending key ordered views and their iterators are faster than
<i>81</i>&nbsp; * descending ones.
<i>82</i>&nbsp; *
<i>83</i>&nbsp; * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
<i>84</i>&nbsp; * and its views represent snapshots of mappings at the time they were
<i>85</i>&nbsp; * produced. They do &lt;em&gt;not&lt;/em&gt; support the {@code Entry.setValue}
<i>86</i>&nbsp; * method. (Note however that it is possible to change mappings in the
<i>87</i>&nbsp; * associated map using {@code put}, {@code putIfAbsent}, or
<i>88</i>&nbsp; * {@code replace}, depending on exactly which effect you need.)
<i>89</i>&nbsp; *
<i>90</i>&nbsp; * &lt;p&gt;Beware that bulk operations {@code putAll}, {@code equals},
<i>91</i>&nbsp; * {@code toArray}, {@code containsValue}, and {@code clear} are
<i>92</i>&nbsp; * &lt;em&gt;not&lt;/em&gt; guaranteed to be performed atomically. For example, an
<i>93</i>&nbsp; * iterator operating concurrently with a {@code putAll} operation
<i>94</i>&nbsp; * might view only some of the added elements.
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;p&gt;This class and its views and iterators implement all of the
<i>97</i>&nbsp; * &lt;em&gt;optional&lt;/em&gt; methods of the {@link Map} and {@link Iterator}
<i>98</i>&nbsp; * interfaces. Like most other concurrent collections, this class does
<i>99</i>&nbsp; * &lt;em&gt;not&lt;/em&gt; permit the use of {@code null} keys or values because some
<i>100</i>&nbsp; * null return values cannot be reliably distinguished from the absence of
<i>101</i>&nbsp; * elements.
<i>102</i>&nbsp; *
<i>103</i>&nbsp; * &lt;p&gt;This class is a member of the
<i>104</i>&nbsp; * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
<i>105</i>&nbsp; * Java Collections Framework&lt;/a&gt;.
<i>106</i>&nbsp; *
<i>107</i>&nbsp; * @author Doug Lea
<i>108</i>&nbsp; * @param &lt;K&gt; the type of keys maintained by this map
<i>109</i>&nbsp; * @param &lt;V&gt; the type of mapped values
<i>110</i>&nbsp; * @since 1.6
<i>111</i>&nbsp; */
<i>112</i>&nbsp;public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
<i>113</i>&nbsp;    implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable {
<i>114</i>&nbsp;    /*
<i>115</i>&nbsp;     * This class implements a tree-like two-dimensionally linked skip
<b class="nc"><i>116</i>&nbsp;     * list in which the index levels are represented in separate</b>
<i>117</i>&nbsp;     * nodes from the base nodes holding data.  There are two reasons
<i>118</i>&nbsp;     * for taking this approach instead of the usual array-based
<i>119</i>&nbsp;     * structure: 1) Array based implementations seem to encounter
<i>120</i>&nbsp;     * more complexity and overhead 2) We can use cheaper algorithms
<i>121</i>&nbsp;     * for the heavily-traversed index lists than can be used for the
<i>122</i>&nbsp;     * base lists.  Here&#39;s a picture of some of the basics for a
<i>123</i>&nbsp;     * possible list with 2 levels of index:
<i>124</i>&nbsp;     *
<i>125</i>&nbsp;     * Head nodes          Index nodes
<i>126</i>&nbsp;     * +-+    right        +-+                      +-+
<i>127</i>&nbsp;     * |2|----------------&gt;| |---------------------&gt;| |-&gt;null
<i>128</i>&nbsp;     * +-+                 +-+                      +-+
<i>129</i>&nbsp;     *  | down              |                        |
<i>130</i>&nbsp;     *  v                   v                        v
<i>131</i>&nbsp;     * +-+            +-+  +-+       +-+            +-+       +-+
<i>132</i>&nbsp;     * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null
<i>133</i>&nbsp;     * +-+            +-+  +-+       +-+            +-+       +-+
<i>134</i>&nbsp;     *  v              |    |         |              |         |
<i>135</i>&nbsp;     * Nodes  next     v    v         v              v         v
<i>136</i>&nbsp;     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
<i>137</i>&nbsp;     * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null
<i>138</i>&nbsp;     * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
<i>139</i>&nbsp;     *
<i>140</i>&nbsp;     * The base lists use a variant of the HM linked ordered set
<i>141</i>&nbsp;     * algorithm. See Tim Harris, &quot;A pragmatic implementation of
<i>142</i>&nbsp;     * non-blocking linked lists&quot;
<i>143</i>&nbsp;     * http://www.cl.cam.ac.uk/~tlh20/publications.html and Maged
<i>144</i>&nbsp;     * Michael &quot;High Performance Dynamic Lock-Free Hash Tables and
<i>145</i>&nbsp;     * List-Based Sets&quot;
<i>146</i>&nbsp;     * http://www.research.ibm.com/people/m/michael/pubs.htm.  The
<i>147</i>&nbsp;     * basic idea in these lists is to mark the &quot;next&quot; pointers of
<i>148</i>&nbsp;     * deleted nodes when deleting to avoid conflicts with concurrent
<i>149</i>&nbsp;     * insertions, and when traversing to keep track of triples
<i>150</i>&nbsp;     * (predecessor, node, successor) in order to detect when and how
<i>151</i>&nbsp;     * to unlink these deleted nodes.
<i>152</i>&nbsp;     *
<i>153</i>&nbsp;     * Rather than using mark-bits to mark list deletions (which can
<i>154</i>&nbsp;     * be slow and space-intensive using AtomicMarkedReference), nodes
<i>155</i>&nbsp;     * use direct CAS&#39;able next pointers.  On deletion, instead of
<i>156</i>&nbsp;     * marking a pointer, they splice in another node that can be
<i>157</i>&nbsp;     * thought of as standing for a marked pointer (see method
<i>158</i>&nbsp;     * unlinkNode).  Using plain nodes acts roughly like &quot;boxed&quot;
<i>159</i>&nbsp;     * implementations of marked pointers, but uses new nodes only
<i>160</i>&nbsp;     * when nodes are deleted, not for every link.  This requires less
<i>161</i>&nbsp;     * space and supports faster traversal. Even if marked references
<i>162</i>&nbsp;     * were better supported by JVMs, traversal using this technique
<i>163</i>&nbsp;     * might still be faster because any search need only read ahead
<i>164</i>&nbsp;     * one more node than otherwise required (to check for trailing
<i>165</i>&nbsp;     * marker) rather than unmasking mark bits or whatever on each
<i>166</i>&nbsp;     * read.
<i>167</i>&nbsp;     *
<i>168</i>&nbsp;     * This approach maintains the essential property needed in the HM
<i>169</i>&nbsp;     * algorithm of changing the next-pointer of a deleted node so
<i>170</i>&nbsp;     * that any other CAS of it will fail, but implements the idea by
<i>171</i>&nbsp;     * changing the pointer to point to a different node (with
<i>172</i>&nbsp;     * otherwise illegal null fields), not by marking it.  While it
<i>173</i>&nbsp;     * would be possible to further squeeze space by defining marker
<i>174</i>&nbsp;     * nodes not to have key/value fields, it isn&#39;t worth the extra
<i>175</i>&nbsp;     * type-testing overhead.  The deletion markers are rarely
<i>176</i>&nbsp;     * encountered during traversal, are easily detected via null
<i>177</i>&nbsp;     * checks that are needed anyway, and are normally quickly garbage
<i>178</i>&nbsp;     * collected. (Note that this technique would not work well in
<i>179</i>&nbsp;     * systems without garbage collection.)
<i>180</i>&nbsp;     *
<i>181</i>&nbsp;     * In addition to using deletion markers, the lists also use
<i>182</i>&nbsp;     * nullness of value fields to indicate deletion, in a style
<i>183</i>&nbsp;     * similar to typical lazy-deletion schemes.  If a node&#39;s value is
<i>184</i>&nbsp;     * null, then it is considered logically deleted and ignored even
<i>185</i>&nbsp;     * though it is still reachable.
<i>186</i>&nbsp;     *
<i>187</i>&nbsp;     * Here&#39;s the sequence of events for a deletion of node n with
<i>188</i>&nbsp;     * predecessor b and successor f, initially:
<i>189</i>&nbsp;     *
<i>190</i>&nbsp;     *        +------+       +------+      +------+
<i>191</i>&nbsp;     *   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...
<i>192</i>&nbsp;     *        +------+       +------+      +------+
<i>193</i>&nbsp;     *
<i>194</i>&nbsp;     * 1. CAS n&#39;s value field from non-null to null.
<i>195</i>&nbsp;     *    Traversals encountering a node with null value ignore it.
<i>196</i>&nbsp;     *    However, ongoing insertions and deletions might still modify
<i>197</i>&nbsp;     *    n&#39;s next pointer.
<i>198</i>&nbsp;     *
<i>199</i>&nbsp;     * 2. CAS n&#39;s next pointer to point to a new marker node.
<i>200</i>&nbsp;     *    From this point on, no other nodes can be appended to n.
<i>201</i>&nbsp;     *    which avoids deletion errors in CAS-based linked lists.
<i>202</i>&nbsp;     *
<i>203</i>&nbsp;     *        +------+       +------+      +------+       +------+
<i>204</i>&nbsp;     *   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...
<i>205</i>&nbsp;     *        +------+       +------+      +------+       +------+
<i>206</i>&nbsp;     *
<i>207</i>&nbsp;     * 3. CAS b&#39;s next pointer over both n and its marker.
<i>208</i>&nbsp;     *    From this point on, no new traversals will encounter n,
<i>209</i>&nbsp;     *    and it can eventually be GCed.
<i>210</i>&nbsp;     *        +------+                                    +------+
<i>211</i>&nbsp;     *   ...  |   b  |-----------------------------------&gt;|   f  | ...
<i>212</i>&nbsp;     *        +------+                                    +------+
<i>213</i>&nbsp;     *
<i>214</i>&nbsp;     * A failure at step 1 leads to simple retry due to a lost race
<i>215</i>&nbsp;     * with another operation. Steps 2-3 can fail because some other
<i>216</i>&nbsp;     * thread noticed during a traversal a node with null value and
<i>217</i>&nbsp;     * helped out by marking and/or unlinking.  This helping-out
<i>218</i>&nbsp;     * ensures that no thread can become stuck waiting for progress of
<i>219</i>&nbsp;     * the deleting thread.
<i>220</i>&nbsp;     *
<i>221</i>&nbsp;     * Skip lists add indexing to this scheme, so that the base-level
<i>222</i>&nbsp;     * traversals start close to the locations being found, inserted
<i>223</i>&nbsp;     * or deleted -- usually base level traversals only traverse a few
<i>224</i>&nbsp;     * nodes. This doesn&#39;t change the basic algorithm except for the
<i>225</i>&nbsp;     * need to make sure base traversals start at predecessors (here,
<i>226</i>&nbsp;     * b) that are not (structurally) deleted, otherwise retrying
<i>227</i>&nbsp;     * after processing the deletion.
<i>228</i>&nbsp;     *
<i>229</i>&nbsp;     * Index levels are maintained using CAS to link and unlink
<i>230</i>&nbsp;     * successors (&quot;right&quot; fields).  Races are allowed in index-list
<i>231</i>&nbsp;     * operations that can (rarely) fail to link in a new index node.
<i>232</i>&nbsp;     * (We can&#39;t do this of course for data nodes.)  However, even
<i>233</i>&nbsp;     * when this happens, the index lists correctly guide search.
<i>234</i>&nbsp;     * This can impact performance, but since skip lists are
<i>235</i>&nbsp;     * probabilistic anyway, the net result is that under contention,
<i>236</i>&nbsp;     * the effective &quot;p&quot; value may be lower than its nominal value.
<i>237</i>&nbsp;     *
<i>238</i>&nbsp;     * Index insertion and deletion sometimes require a separate
<i>239</i>&nbsp;     * traversal pass occurring after the base-level action, to add or
<i>240</i>&nbsp;     * remove index nodes.  This adds to single-threaded overhead, but
<i>241</i>&nbsp;     * improves contended multithreaded performance by narrowing
<i>242</i>&nbsp;     * interference windows, and allows deletion to ensure that all
<i>243</i>&nbsp;     * index nodes will be made unreachable upon return from a public
<i>244</i>&nbsp;     * remove operation, thus avoiding unwanted garbage retention.
<i>245</i>&nbsp;     *
<i>246</i>&nbsp;     * Indexing uses skip list parameters that maintain good search
<i>247</i>&nbsp;     * performance while using sparser-than-usual indices: The
<i>248</i>&nbsp;     * hardwired parameters k=1, p=0.5 (see method doPut) mean that
<i>249</i>&nbsp;     * about one-quarter of the nodes have indices. Of those that do,
<i>250</i>&nbsp;     * half have one level, a quarter have two, and so on (see Pugh&#39;s
<i>251</i>&nbsp;     * Skip List Cookbook, sec 3.4), up to a maximum of 62 levels
<i>252</i>&nbsp;     * (appropriate for up to 2^63 elements).  The expected total
<i>253</i>&nbsp;     * space requirement for a map is slightly less than for the
<i>254</i>&nbsp;     * current implementation of java.util.TreeMap.
<i>255</i>&nbsp;     *
<i>256</i>&nbsp;     * Changing the level of the index (i.e, the height of the
<i>257</i>&nbsp;     * tree-like structure) also uses CAS.  Creation of an index with
<i>258</i>&nbsp;     * height greater than the current level adds a level to the head
<i>259</i>&nbsp;     * index by CAS&#39;ing on a new top-most head. To maintain good
<i>260</i>&nbsp;     * performance after a lot of removals, deletion methods
<i>261</i>&nbsp;     * heuristically try to reduce the height if the topmost levels
<i>262</i>&nbsp;     * appear to be empty.  This may encounter races in which it is
<i>263</i>&nbsp;     * possible (but rare) to reduce and &quot;lose&quot; a level just as it is
<i>264</i>&nbsp;     * about to contain an index (that will then never be
<i>265</i>&nbsp;     * encountered). This does no structural harm, and in practice
<i>266</i>&nbsp;     * appears to be a better option than allowing unrestrained growth
<i>267</i>&nbsp;     * of levels.
<i>268</i>&nbsp;     *
<i>269</i>&nbsp;     * This class provides concurrent-reader-style memory consistency,
<i>270</i>&nbsp;     * ensuring that read-only methods report status and/or values no
<i>271</i>&nbsp;     * staler than those holding at method entry. This is done by
<i>272</i>&nbsp;     * performing all publication and structural updates using
<i>273</i>&nbsp;     * (volatile) CAS, placing an acquireFence in a few access
<i>274</i>&nbsp;     * methods, and ensuring that linked objects are transitively
<i>275</i>&nbsp;     * acquired via dependent reads (normally once) unless performing
<i>276</i>&nbsp;     * a volatile-mode CAS operation (that also acts as an acquire and
<i>277</i>&nbsp;     * release).  This form of fence-hoisting is similar to RCU and
<i>278</i>&nbsp;     * related techniques (see McKenney&#39;s online book
<i>279</i>&nbsp;     * https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)
<i>280</i>&nbsp;     * It minimizes overhead that may otherwise occur when using so
<i>281</i>&nbsp;     * many volatile-mode reads. Using explicit acquireFences is
<i>282</i>&nbsp;     * logistically easier than targeting particular fields to be read
<i>283</i>&nbsp;     * in acquire mode: fences are just hoisted up as far as possible,
<i>284</i>&nbsp;     * to the entry points or loop headers of a few methods. A
<i>285</i>&nbsp;     * potential disadvantage is that these few remaining fences are
<i>286</i>&nbsp;     * not easily optimized away by compilers under exclusively
<i>287</i>&nbsp;     * single-thread use.  It requires some care to avoid volatile
<i>288</i>&nbsp;     * mode reads of other fields. (Note that the memory semantics of
<i>289</i>&nbsp;     * a reference dependently read in plain mode exactly once are
<i>290</i>&nbsp;     * equivalent to those for atomic opaque mode.)  Iterators and
<i>291</i>&nbsp;     * other traversals encounter each node and value exactly once.
<i>292</i>&nbsp;     * Other operations locate an element (or position to insert an
<i>293</i>&nbsp;     * element) via a sequence of dereferences. This search is broken
<i>294</i>&nbsp;     * into two parts. Method findPredecessor (and its specialized
<i>295</i>&nbsp;     * embeddings) searches index nodes only, returning a base-level
<i>296</i>&nbsp;     * predecessor of the key. Callers carry out the base-level
<i>297</i>&nbsp;     * search, restarting if encountering a marker preventing link
<i>298</i>&nbsp;     * modification.  In some cases, it is possible to encounter a
<i>299</i>&nbsp;     * node multiple times while descending levels. For mutative
<i>300</i>&nbsp;     * operations, the reported value is validated using CAS (else
<i>301</i>&nbsp;     * retrying), preserving linearizability with respect to each
<i>302</i>&nbsp;     * other. Others may return any (non-null) value holding in the
<i>303</i>&nbsp;     * course of the method call.  (Search-based methods also include
<i>304</i>&nbsp;     * some useless-looking explicit null checks designed to allow
<i>305</i>&nbsp;     * more fields to be nulled out upon removal, to reduce floating
<i>306</i>&nbsp;     * garbage, but which is not currently done, pending discovery of
<i>307</i>&nbsp;     * a way to do this with less impact on other operations.)
<i>308</i>&nbsp;     *
<i>309</i>&nbsp;     * To produce random values without interference across threads,
<i>310</i>&nbsp;     * we use within-JDK thread local random support (via the
<i>311</i>&nbsp;     * &quot;secondary seed&quot;, to avoid interference with user-level
<i>312</i>&nbsp;     * ThreadLocalRandom.)
<i>313</i>&nbsp;     *
<i>314</i>&nbsp;     * For explanation of algorithms sharing at least a couple of
<i>315</i>&nbsp;     * features with this one, see Mikhail Fomitchev&#39;s thesis
<i>316</i>&nbsp;     * (http://www.cs.yorku.ca/~mikhail/), Keir Fraser&#39;s thesis
<i>317</i>&nbsp;     * (http://www.cl.cam.ac.uk/users/kaf24/), and Hakan Sundell&#39;s
<i>318</i>&nbsp;     * thesis (http://www.cs.chalmers.se/~phs/).
<i>319</i>&nbsp;     *
<i>320</i>&nbsp;     * Notation guide for local variables
<i>321</i>&nbsp;     * Node:         b, n, f, p for  predecessor, node, successor, aux
<i>322</i>&nbsp;     * Index:        q, r, d    for index node, right, down.
<i>323</i>&nbsp;     * Head:         h
<i>324</i>&nbsp;     * Keys:         k, key
<i>325</i>&nbsp;     * Values:       v, value
<i>326</i>&nbsp;     * Comparisons:  c
<i>327</i>&nbsp;     */
<i>328</i>&nbsp;
<i>329</i>&nbsp;    private static final long serialVersionUID = -8627078645895051609L;
<i>330</i>&nbsp;
<i>331</i>&nbsp;    /**
<i>332</i>&nbsp;     * The comparator used to maintain order in this map, or null if
<i>333</i>&nbsp;     * using natural ordering.  (Non-private to simplify access in
<i>334</i>&nbsp;     * nested classes.)
<i>335</i>&nbsp;     * @serial
<i>336</i>&nbsp;     */
<i>337</i>&nbsp;    final Comparator&lt;? super K&gt; comparator;
<i>338</i>&nbsp;
<i>339</i>&nbsp;    /** Lazily initialized topmost index of the skiplist. */
<i>340</i>&nbsp;    private transient Index&lt;K,V&gt; head;
<i>341</i>&nbsp;    /** Lazily initialized element count */
<i>342</i>&nbsp;    private transient LongAdder adder;
<i>343</i>&nbsp;    /** Lazily initialized key set */
<i>344</i>&nbsp;    private transient KeySet&lt;K,V&gt; keySet;
<i>345</i>&nbsp;    /** Lazily initialized values collection */
<i>346</i>&nbsp;    private transient Values&lt;K,V&gt; values;
<i>347</i>&nbsp;    /** Lazily initialized entry set */
<i>348</i>&nbsp;    private transient EntrySet&lt;K,V&gt; entrySet;
<i>349</i>&nbsp;    /** Lazily initialized descending map */
<i>350</i>&nbsp;    private transient SubMap&lt;K,V&gt; descendingMap;
<i>351</i>&nbsp;
<i>352</i>&nbsp;    /**
<i>353</i>&nbsp;     * Nodes hold keys and values, and are singly linked in sorted
<i>354</i>&nbsp;     * order, possibly with some intervening marker nodes. The list is
<i>355</i>&nbsp;     * headed by a header node accessible as head.node. Headers and
<i>356</i>&nbsp;     * marker nodes have null keys. The val field (but currently not
<i>357</i>&nbsp;     * the key field) is nulled out upon deletion.
<i>358</i>&nbsp;     */
<i>359</i>&nbsp;    static final class Node&lt;K,V&gt; {
<i>360</i>&nbsp;        final K key; // currently, never detached
<i>361</i>&nbsp;        V val;
<i>362</i>&nbsp;        Node&lt;K,V&gt; next;
<b class="nc"><i>363</i>&nbsp;        Node(K key, V value, Node&lt;K,V&gt; next) {</b>
<i>364</i>&nbsp;            this.key = key;
<i>365</i>&nbsp;            this.val = value;
<i>366</i>&nbsp;            this.next = next;
<i>367</i>&nbsp;        }
<i>368</i>&nbsp;    }
<i>369</i>&nbsp;
<i>370</i>&nbsp;    /**
<i>371</i>&nbsp;     * Index nodes represent the levels of the skip list.
<i>372</i>&nbsp;     */
<i>373</i>&nbsp;    static final class Index&lt;K,V&gt; {
<i>374</i>&nbsp;        final Node&lt;K,V&gt; node;  // currently, never detached
<i>375</i>&nbsp;        final Index&lt;K,V&gt; down;
<i>376</i>&nbsp;        Index&lt;K,V&gt; right;
<i>377</i>&nbsp;        Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) {
<i>378</i>&nbsp;            this.node = node;
<i>379</i>&nbsp;            this.down = down;
<i>380</i>&nbsp;            this.right = right;
<i>381</i>&nbsp;        }
<i>382</i>&nbsp;    }
<i>383</i>&nbsp;
<i>384</i>&nbsp;    /* ----------------  Utilities -------------- */
<i>385</i>&nbsp;
<i>386</i>&nbsp;    /**
<i>387</i>&nbsp;     * Compares using comparator or natural ordering if null.
<i>388</i>&nbsp;     * Called only by methods that have performed required type checks.
<i>389</i>&nbsp;     */
<i>390</i>&nbsp;    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
<i>391</i>&nbsp;    static int cpr(Comparator c, Object x, Object y) {
<i>392</i>&nbsp;        return (c != null) ? c.compare(x, y) : ((Comparable)x).compareTo(y);
<b class="nc"><i>393</i>&nbsp;    }</b>
<b class="nc"><i>394</i>&nbsp;</b>
<b class="nc"><i>395</i>&nbsp;    /**</b>
<b class="nc"><i>396</i>&nbsp;     * Returns the header for base node list, or null if uninitialized</b>
<b class="nc"><i>397</i>&nbsp;     */</b>
<i>398</i>&nbsp;    final Node&lt;K,V&gt; baseHead() {
<i>399</i>&nbsp;        Index&lt;K,V&gt; h;
<i>400</i>&nbsp;        VarHandle.acquireFence();
<i>401</i>&nbsp;        return ((h = head) == null) ? null : h.node;
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;
<i>404</i>&nbsp;    /**
<b class="nc"><i>405</i>&nbsp;     * Tries to unlink deleted node n from predecessor b (if both</b>
<i>406</i>&nbsp;     * exist), by first splicing in a marker if not already present.
<i>407</i>&nbsp;     * Upon return, node n is sure to be unlinked from b, possibly
<i>408</i>&nbsp;     * via the actions of some other thread.
<i>409</i>&nbsp;     *
<i>410</i>&nbsp;     * @param b if nonnull, predecessor
<i>411</i>&nbsp;     * @param n if nonnull, node known to be deleted
<i>412</i>&nbsp;     */
<i>413</i>&nbsp;    static &lt;K,V&gt; void unlinkNode(Node&lt;K,V&gt; b, Node&lt;K,V&gt; n) {
<i>414</i>&nbsp;        if (b != null &amp;&amp; n != null) {
<i>415</i>&nbsp;            Node&lt;K,V&gt; f, p;
<i>416</i>&nbsp;            for (;;) {
<i>417</i>&nbsp;                if ((f = n.next) != null &amp;&amp; f.key == null) {
<i>418</i>&nbsp;                    p = f.next;               // already marked
<i>419</i>&nbsp;                    break;
<i>420</i>&nbsp;                }
<i>421</i>&nbsp;                else if (NEXT.compareAndSet(n, f,
<i>422</i>&nbsp;                                            new Node&lt;K,V&gt;(null, null, f))) {
<i>423</i>&nbsp;                    p = f;                    // add marker
<i>424</i>&nbsp;                    break;
<b class="nc"><i>425</i>&nbsp;                }</b>
<b class="nc"><i>426</i>&nbsp;            }</b>
<b class="nc"><i>427</i>&nbsp;            NEXT.compareAndSet(b, n, p);</b>
<b class="nc"><i>428</i>&nbsp;        }</b>
<i>429</i>&nbsp;    }
<i>430</i>&nbsp;
<i>431</i>&nbsp;    /**
<i>432</i>&nbsp;     * Adds to element count, initializing adder if necessary
<i>433</i>&nbsp;     *
<i>434</i>&nbsp;     * @param c count to add
<i>435</i>&nbsp;     */
<i>436</i>&nbsp;    private void addCount(long c) {
<i>437</i>&nbsp;        LongAdder a;
<b class="nc"><i>438</i>&nbsp;        do {} while ((a = adder) == null &amp;&amp;</b>
<b class="nc"><i>439</i>&nbsp;                     !ADDER.compareAndSet(this, null, a = new LongAdder()));</b>
<b class="nc"><i>440</i>&nbsp;        a.add(c);</b>
<b class="nc"><i>441</i>&nbsp;    }</b>
<i>442</i>&nbsp;
<i>443</i>&nbsp;    /**
<i>444</i>&nbsp;     * Returns element count, initializing adder if necessary.
<i>445</i>&nbsp;     */
<i>446</i>&nbsp;    final long getAdderCount() {
<i>447</i>&nbsp;        LongAdder a; long c;
<b class="nc"><i>448</i>&nbsp;        do {} while ((a = adder) == null &amp;&amp;</b>
<i>449</i>&nbsp;                     !ADDER.compareAndSet(this, null, a = new LongAdder()));
<i>450</i>&nbsp;        return ((c = a.sum()) &lt;= 0L) ? 0L : c; // ignore transient negatives
<i>451</i>&nbsp;    }
<i>452</i>&nbsp;
<i>453</i>&nbsp;    /* ---------------- Traversal -------------- */
<i>454</i>&nbsp;
<b class="nc"><i>455</i>&nbsp;    /**</b>
<i>456</i>&nbsp;     * Returns an index node with key strictly less than given key.
<i>457</i>&nbsp;     * Also unlinks indexes to deleted nodes found along the way.
<i>458</i>&nbsp;     * Callers rely on this side-effect of clearing indices to deleted
<i>459</i>&nbsp;     * nodes.
<i>460</i>&nbsp;     *
<i>461</i>&nbsp;     * @param key if nonnull the key
<i>462</i>&nbsp;     * @return a predecessor node of key, or null if uninitialized or null key
<i>463</i>&nbsp;     */
<i>464</i>&nbsp;    private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) {
<i>465</i>&nbsp;        Index&lt;K,V&gt; q;
<i>466</i>&nbsp;        VarHandle.acquireFence();
<i>467</i>&nbsp;        if ((q = head) == null || key == null)
<b class="nc"><i>468</i>&nbsp;            return null;</b>
<i>469</i>&nbsp;        else {
<i>470</i>&nbsp;            for (Index&lt;K,V&gt; r, d;;) {
<i>471</i>&nbsp;                while ((r = q.right) != null) {
<i>472</i>&nbsp;                    Node&lt;K,V&gt; p; K k;
<i>473</i>&nbsp;                    if ((p = r.node) == null || (k = p.key) == null ||
<i>474</i>&nbsp;                        p.val == null)  // unlink index to deleted node
<i>475</i>&nbsp;                        RIGHT.compareAndSet(q, r, r.right);
<b class="nc"><i>476</i>&nbsp;                    else if (cpr(cmp, key, k) &gt; 0)</b>
<i>477</i>&nbsp;                        q = r;
<i>478</i>&nbsp;                    else
<i>479</i>&nbsp;                        break;
<i>480</i>&nbsp;                }
<i>481</i>&nbsp;                if ((d = q.down) != null)
<i>482</i>&nbsp;                    q = d;
<i>483</i>&nbsp;                else
<i>484</i>&nbsp;                    return q.node;
<b class="nc"><i>485</i>&nbsp;            }</b>
<i>486</i>&nbsp;        }
<i>487</i>&nbsp;    }
<i>488</i>&nbsp;
<i>489</i>&nbsp;    /**
<i>490</i>&nbsp;     * Returns node holding key or null if no such, clearing out any
<i>491</i>&nbsp;     * deleted nodes seen along the way.  Repeatedly traverses at
<i>492</i>&nbsp;     * base-level looking for key starting at predecessor returned
<i>493</i>&nbsp;     * from findPredecessor, processing base-level deletions as
<i>494</i>&nbsp;     * encountered. Restarts occur, at traversal step encountering
<i>495</i>&nbsp;     * node n, if n&#39;s key field is null, indicating it is a marker, so
<i>496</i>&nbsp;     * its predecessor is deleted before continuing, which we help do
<i>497</i>&nbsp;     * by re-finding a valid predecessor.  The traversal loops in
<i>498</i>&nbsp;     * doPut, doRemove, and findNear all include the same checks.
<i>499</i>&nbsp;     *
<i>500</i>&nbsp;     * @param key the key
<b class="nc"><i>501</i>&nbsp;     * @return node holding key, or null if no such</b>
<b class="nc"><i>502</i>&nbsp;     */</b>
<b class="nc"><i>503</i>&nbsp;    private Node&lt;K,V&gt; findNode(Object key) {</b>
<i>504</i>&nbsp;        if (key == null)
<b class="nc"><i>505</i>&nbsp;            throw new NullPointerException(); // don&#39;t postpone errors</b>
<i>506</i>&nbsp;        Comparator&lt;? super K&gt; cmp = comparator;
<i>507</i>&nbsp;        Node&lt;K,V&gt; b;
<i>508</i>&nbsp;        outer: while ((b = findPredecessor(key, cmp)) != null) {
<i>509</i>&nbsp;            for (;;) {
<i>510</i>&nbsp;                Node&lt;K,V&gt; n; K k; V v; int c;
<i>511</i>&nbsp;                if ((n = b.next) == null)
<i>512</i>&nbsp;                    break outer;               // empty
<i>513</i>&nbsp;                else if ((k = n.key) == null)
<i>514</i>&nbsp;                    break;                     // b is deleted
<i>515</i>&nbsp;                else if ((v = n.val) == null)
<b class="nc"><i>516</i>&nbsp;                    unlinkNode(b, n);          // n is deleted</b>
<b class="nc"><i>517</i>&nbsp;                else if ((c = cpr(cmp, key, k)) &gt; 0)</b>
<b class="nc"><i>518</i>&nbsp;                    b = n;</b>
<b class="nc"><i>519</i>&nbsp;                else if (c == 0)</b>
<b class="nc"><i>520</i>&nbsp;                    return n;</b>
<i>521</i>&nbsp;                else
<i>522</i>&nbsp;                    break outer;
<i>523</i>&nbsp;            }
<i>524</i>&nbsp;        }
<i>525</i>&nbsp;        return null;
<i>526</i>&nbsp;    }
<i>527</i>&nbsp;
<i>528</i>&nbsp;    /**
<b class="nc"><i>529</i>&nbsp;     * Gets value for key. Same idea as findNode, except skips over</b>
<b class="nc"><i>530</i>&nbsp;     * deletions and markers, and returns first encountered value to</b>
<b class="nc"><i>531</i>&nbsp;     * avoid possibly inconsistent rereads.</b>
<b class="nc"><i>532</i>&nbsp;     *</b>
<b class="nc"><i>533</i>&nbsp;     * @param key the key</b>
<i>534</i>&nbsp;     * @return the value, or null if absent
<i>535</i>&nbsp;     */
<i>536</i>&nbsp;    private V doGet(Object key) {
<i>537</i>&nbsp;        Index&lt;K,V&gt; q;
<i>538</i>&nbsp;        VarHandle.acquireFence();
<i>539</i>&nbsp;        if (key == null)
<i>540</i>&nbsp;            throw new NullPointerException();
<i>541</i>&nbsp;        Comparator&lt;? super K&gt; cmp = comparator;
<i>542</i>&nbsp;        V result = null;
<i>543</i>&nbsp;        if ((q = head) != null) {
<b class="nc"><i>544</i>&nbsp;            outer: for (Index&lt;K,V&gt; r, d;;) {</b>
<b class="nc"><i>545</i>&nbsp;                while ((r = q.right) != null) {</b>
<b class="nc"><i>546</i>&nbsp;                    Node&lt;K,V&gt; p; K k; V v; int c;</b>
<b class="nc"><i>547</i>&nbsp;                    if ((p = r.node) == null || (k = p.key) == null ||</b>
<b class="nc"><i>548</i>&nbsp;                        (v = p.val) == null)</b>
<b class="nc"><i>549</i>&nbsp;                        RIGHT.compareAndSet(q, r, r.right);</b>
<b class="nc"><i>550</i>&nbsp;                    else if ((c = cpr(cmp, key, k)) &gt; 0)</b>
<b class="nc"><i>551</i>&nbsp;                        q = r;</b>
<b class="nc"><i>552</i>&nbsp;                    else if (c == 0) {</b>
<i>553</i>&nbsp;                        result = v;
<i>554</i>&nbsp;                        break outer;
<i>555</i>&nbsp;                    }
<i>556</i>&nbsp;                    else
<i>557</i>&nbsp;                        break;
<i>558</i>&nbsp;                }
<i>559</i>&nbsp;                if ((d = q.down) != null)
<i>560</i>&nbsp;                    q = d;
<i>561</i>&nbsp;                else {
<i>562</i>&nbsp;                    Node&lt;K,V&gt; b, n;
<i>563</i>&nbsp;                    if ((b = q.node) != null) {
<i>564</i>&nbsp;                        while ((n = b.next) != null) {
<i>565</i>&nbsp;                            V v; int c;
<i>566</i>&nbsp;                            K k = n.key;
<i>567</i>&nbsp;                            if ((v = n.val) == null || k == null ||
<i>568</i>&nbsp;                                (c = cpr(cmp, key, k)) &gt; 0)
<i>569</i>&nbsp;                                b = n;
<i>570</i>&nbsp;                            else {
<i>571</i>&nbsp;                                if (c == 0)
<i>572</i>&nbsp;                                    result = v;
<b class="nc"><i>573</i>&nbsp;                                break;</b>
<b class="nc"><i>574</i>&nbsp;                            }</b>
<b class="nc"><i>575</i>&nbsp;                        }</b>
<b class="nc"><i>576</i>&nbsp;                    }</b>
<i>577</i>&nbsp;                    break;
<i>578</i>&nbsp;                }
<i>579</i>&nbsp;            }
<i>580</i>&nbsp;        }
<i>581</i>&nbsp;        return result;
<i>582</i>&nbsp;    }
<b class="nc"><i>583</i>&nbsp;</b>
<i>584</i>&nbsp;    /* ---------------- Insertion -------------- */
<i>585</i>&nbsp;
<i>586</i>&nbsp;    /**
<i>587</i>&nbsp;     * Main insertion method.  Adds element if not present, or
<i>588</i>&nbsp;     * replaces value if present and onlyIfAbsent is false.
<i>589</i>&nbsp;     *
<i>590</i>&nbsp;     * @param key the key
<b class="nc"><i>591</i>&nbsp;     * @param value the value that must be associated with key</b>
<i>592</i>&nbsp;     * @param onlyIfAbsent if should not insert if already present
<i>593</i>&nbsp;     * @return the old value, or null if newly inserted
<i>594</i>&nbsp;     */
<i>595</i>&nbsp;    private V doPut(K key, V value, boolean onlyIfAbsent) {
<i>596</i>&nbsp;        if (key == null)
<i>597</i>&nbsp;            throw new NullPointerException();
<i>598</i>&nbsp;        Comparator&lt;? super K&gt; cmp = comparator;
<i>599</i>&nbsp;        for (;;) {
<i>600</i>&nbsp;            Index&lt;K,V&gt; h; Node&lt;K,V&gt; b;
<i>601</i>&nbsp;            VarHandle.acquireFence();
<i>602</i>&nbsp;            int levels = 0;                    // number of levels descended
<b class="nc"><i>603</i>&nbsp;            if ((h = head) == null) {          // try to initialize</b>
<b class="nc"><i>604</i>&nbsp;                Node&lt;K,V&gt; base = new Node&lt;K,V&gt;(null, null, null);</b>
<b class="nc"><i>605</i>&nbsp;                h = new Index&lt;K,V&gt;(base, null, null);</b>
<i>606</i>&nbsp;                b = (HEAD.compareAndSet(this, null, h)) ? base : null;
<i>607</i>&nbsp;            }
<i>608</i>&nbsp;            else {
<i>609</i>&nbsp;                for (Index&lt;K,V&gt; q = h, r, d;;) { // count while descending
<i>610</i>&nbsp;                    while ((r = q.right) != null) {
<i>611</i>&nbsp;                        Node&lt;K,V&gt; p; K k;
<i>612</i>&nbsp;                        if ((p = r.node) == null || (k = p.key) == null ||
<i>613</i>&nbsp;                            p.val == null)
<i>614</i>&nbsp;                            RIGHT.compareAndSet(q, r, r.right);
<i>615</i>&nbsp;                        else if (cpr(cmp, key, k) &gt; 0)
<b class="nc"><i>616</i>&nbsp;                            q = r;</b>
<i>617</i>&nbsp;                        else
<i>618</i>&nbsp;                            break;
<i>619</i>&nbsp;                    }
<i>620</i>&nbsp;                    if ((d = q.down) != null) {
<i>621</i>&nbsp;                        ++levels;
<i>622</i>&nbsp;                        q = d;
<i>623</i>&nbsp;                    }
<b class="nc"><i>624</i>&nbsp;                    else {</b>
<b class="nc"><i>625</i>&nbsp;                        b = q.node;</b>
<b class="nc"><i>626</i>&nbsp;                        break;</b>
<b class="nc"><i>627</i>&nbsp;                    }</b>
<b class="nc"><i>628</i>&nbsp;                }</b>
<b class="nc"><i>629</i>&nbsp;            }</b>
<b class="nc"><i>630</i>&nbsp;            if (b != null) {</b>
<i>631</i>&nbsp;                Node&lt;K,V&gt; z = null;              // new node, if inserted
<i>632</i>&nbsp;                for (;;) {                       // find insertion point
<i>633</i>&nbsp;                    Node&lt;K,V&gt; n, p; K k; V v; int c;
<i>634</i>&nbsp;                    if ((n = b.next) == null) {
<i>635</i>&nbsp;                        if (b.key == null)       // if empty, type check key now
<i>636</i>&nbsp;                            cpr(cmp, key, key);
<i>637</i>&nbsp;                        c = -1;
<i>638</i>&nbsp;                    }
<i>639</i>&nbsp;                    else if ((k = n.key) == null)
<i>640</i>&nbsp;                        break;                   // can&#39;t append; restart
<i>641</i>&nbsp;                    else if ((v = n.val) == null) {
<b class="nc"><i>642</i>&nbsp;                        unlinkNode(b, n);</b>
<b class="nc"><i>643</i>&nbsp;                        c = 1;</b>
<i>644</i>&nbsp;                    }
<i>645</i>&nbsp;                    else if ((c = cpr(cmp, key, k)) &gt; 0)
<i>646</i>&nbsp;                        b = n;
<i>647</i>&nbsp;                    else if (c == 0 &amp;&amp;
<i>648</i>&nbsp;                             (onlyIfAbsent || VAL.compareAndSet(n, v, value)))
<i>649</i>&nbsp;                        return v;
<i>650</i>&nbsp;
<i>651</i>&nbsp;                    if (c &lt; 0 &amp;&amp;
<i>652</i>&nbsp;                        NEXT.compareAndSet(b, n,
<i>653</i>&nbsp;                                           p = new Node&lt;K,V&gt;(key, value, n))) {
<i>654</i>&nbsp;                        z = p;
<b class="nc"><i>655</i>&nbsp;                        break;</b>
<i>656</i>&nbsp;                    }
<i>657</i>&nbsp;                }
<i>658</i>&nbsp;
<i>659</i>&nbsp;                if (z != null) {
<i>660</i>&nbsp;                    int lr = ThreadLocalRandom.nextSecondarySeed();
<i>661</i>&nbsp;                    if ((lr &amp; 0x3) == 0) {       // add indices with 1/4 prob
<i>662</i>&nbsp;                        int hr = ThreadLocalRandom.nextSecondarySeed();
<i>663</i>&nbsp;                        long rnd = ((long)hr &lt;&lt; 32) | ((long)lr &amp; 0xffffffffL);
<i>664</i>&nbsp;                        int skips = levels;      // levels to descend before add
<i>665</i>&nbsp;                        Index&lt;K,V&gt; x = null;
<i>666</i>&nbsp;                        for (;;) {               // create at most 62 indices
<i>667</i>&nbsp;                            x = new Index&lt;K,V&gt;(z, x, null);
<i>668</i>&nbsp;                            if (rnd &gt;= 0L || --skips &lt; 0)
<b class="nc"><i>669</i>&nbsp;                                break;</b>
<b class="nc"><i>670</i>&nbsp;                            else</b>
<i>671</i>&nbsp;                                rnd &lt;&lt;= 1;
<b class="nc"><i>672</i>&nbsp;                        }</b>
<b class="nc"><i>673</i>&nbsp;                        if (addIndices(h, skips, x, cmp) &amp;&amp; skips &lt; 0 &amp;&amp;</b>
<b class="nc"><i>674</i>&nbsp;                            head == h) {         // try to add new level</b>
<b class="nc"><i>675</i>&nbsp;                            Index&lt;K,V&gt; hx = new Index&lt;K,V&gt;(z, x, null);</b>
<b class="nc"><i>676</i>&nbsp;                            Index&lt;K,V&gt; nh = new Index&lt;K,V&gt;(h.node, h, hx);</b>
<b class="nc"><i>677</i>&nbsp;                            HEAD.compareAndSet(this, h, nh);</b>
<b class="nc"><i>678</i>&nbsp;                        }</b>
<b class="nc"><i>679</i>&nbsp;                        if (z.val == null)       // deleted while adding indices</b>
<b class="nc"><i>680</i>&nbsp;                            findPredecessor(key, cmp); // clean</b>
<i>681</i>&nbsp;                    }
<b class="nc"><i>682</i>&nbsp;                    addCount(1L);</b>
<b class="nc"><i>683</i>&nbsp;                    return null;</b>
<b class="nc"><i>684</i>&nbsp;                }</b>
<b class="nc"><i>685</i>&nbsp;            }</b>
<i>686</i>&nbsp;        }
<i>687</i>&nbsp;    }
<b class="nc"><i>688</i>&nbsp;</b>
<b class="nc"><i>689</i>&nbsp;    /**</b>
<b class="nc"><i>690</i>&nbsp;     * Add indices after an insertion. Descends iteratively to the</b>
<b class="nc"><i>691</i>&nbsp;     * highest level of insertion, then recursively, to chain index</b>
<i>692</i>&nbsp;     * nodes to lower ones. Returns null on (staleness) failure,
<i>693</i>&nbsp;     * disabling higher-level insertions. Recursion depths are
<i>694</i>&nbsp;     * exponentially less probable.
<i>695</i>&nbsp;     *
<i>696</i>&nbsp;     * @param q starting index for current level
<i>697</i>&nbsp;     * @param skips levels to skip before inserting
<i>698</i>&nbsp;     * @param x index for this insertion
<i>699</i>&nbsp;     * @param cmp comparator
<i>700</i>&nbsp;     */
<i>701</i>&nbsp;    static &lt;K,V&gt; boolean addIndices(Index&lt;K,V&gt; q, int skips, Index&lt;K,V&gt; x,
<i>702</i>&nbsp;                                    Comparator&lt;? super K&gt; cmp) {
<i>703</i>&nbsp;        Node&lt;K,V&gt; z; K key;
<i>704</i>&nbsp;        if (x != null &amp;&amp; (z = x.node) != null &amp;&amp; (key = z.key) != null &amp;&amp;
<i>705</i>&nbsp;            q != null) {                            // hoist checks
<i>706</i>&nbsp;            boolean retrying = false;
<i>707</i>&nbsp;            for (;;) {                              // find splice point
<i>708</i>&nbsp;                Index&lt;K,V&gt; r, d; int c;
<i>709</i>&nbsp;                if ((r = q.right) != null) {
<i>710</i>&nbsp;                    Node&lt;K,V&gt; p; K k;
<i>711</i>&nbsp;                    if ((p = r.node) == null || (k = p.key) == null ||
<i>712</i>&nbsp;                        p.val == null) {
<i>713</i>&nbsp;                        RIGHT.compareAndSet(q, r, r.right);
<i>714</i>&nbsp;                        c = 0;
<i>715</i>&nbsp;                    }
<i>716</i>&nbsp;                    else if ((c = cpr(cmp, key, k)) &gt; 0)
<i>717</i>&nbsp;                        q = r;
<i>718</i>&nbsp;                    else if (c == 0)
<i>719</i>&nbsp;                        break;                      // stale
<i>720</i>&nbsp;                }
<i>721</i>&nbsp;                else
<i>722</i>&nbsp;                    c = -1;
<i>723</i>&nbsp;
<i>724</i>&nbsp;                if (c &lt; 0) {
<i>725</i>&nbsp;                    if ((d = q.down) != null &amp;&amp; skips &gt; 0) {
<i>726</i>&nbsp;                        --skips;
<i>727</i>&nbsp;                        q = d;
<i>728</i>&nbsp;                    }
<i>729</i>&nbsp;                    else if (d != null &amp;&amp; !retrying &amp;&amp;
<i>730</i>&nbsp;                             !addIndices(d, 0, x.down, cmp))
<i>731</i>&nbsp;                        break;
<i>732</i>&nbsp;                    else {
<i>733</i>&nbsp;                        x.right = r;
<i>734</i>&nbsp;                        if (RIGHT.compareAndSet(q, r, x))
<i>735</i>&nbsp;                            return true;
<i>736</i>&nbsp;                        else
<i>737</i>&nbsp;                            retrying = true;         // re-find splice point
<i>738</i>&nbsp;                    }
<i>739</i>&nbsp;                }
<i>740</i>&nbsp;            }
<b class="nc"><i>741</i>&nbsp;        }</b>
<b class="nc"><i>742</i>&nbsp;        return false;</b>
<b class="nc"><i>743</i>&nbsp;    }</b>
<i>744</i>&nbsp;
<b class="nc"><i>745</i>&nbsp;    /* ---------------- Deletion -------------- */</b>
<i>746</i>&nbsp;
<b class="nc"><i>747</i>&nbsp;    /**</b>
<b class="nc"><i>748</i>&nbsp;     * Main deletion method. Locates node, nulls value, appends a</b>
<b class="nc"><i>749</i>&nbsp;     * deletion marker, unlinks predecessor, removes associated index</b>
<b class="nc"><i>750</i>&nbsp;     * nodes, and possibly reduces head index level.</b>
<b class="nc"><i>751</i>&nbsp;     *</b>
<b class="nc"><i>752</i>&nbsp;     * @param key the key</b>
<b class="nc"><i>753</i>&nbsp;     * @param value if non-null, the value that must be</b>
<b class="nc"><i>754</i>&nbsp;     * associated with key</b>
<i>755</i>&nbsp;     * @return the node, or null if not found
<b class="nc"><i>756</i>&nbsp;     */</b>
<b class="nc"><i>757</i>&nbsp;    final V doRemove(Object key, Object value) {</b>
<b class="nc"><i>758</i>&nbsp;        if (key == null)</b>
<b class="nc"><i>759</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>760</i>&nbsp;        Comparator&lt;? super K&gt; cmp = comparator;</b>
<b class="nc"><i>761</i>&nbsp;        V result = null;</b>
<b class="nc"><i>762</i>&nbsp;        Node&lt;K,V&gt; b;</b>
<b class="nc"><i>763</i>&nbsp;        outer: while ((b = findPredecessor(key, cmp)) != null &amp;&amp;</b>
<b class="nc"><i>764</i>&nbsp;                      result == null) {</b>
<i>765</i>&nbsp;            for (;;) {
<b class="nc"><i>766</i>&nbsp;                Node&lt;K,V&gt; n; K k; V v; int c;</b>
<i>767</i>&nbsp;                if ((n = b.next) == null)
<i>768</i>&nbsp;                    break outer;
<i>769</i>&nbsp;                else if ((k = n.key) == null)
<i>770</i>&nbsp;                    break;
<i>771</i>&nbsp;                else if ((v = n.val) == null)
<i>772</i>&nbsp;                    unlinkNode(b, n);
<i>773</i>&nbsp;                else if ((c = cpr(cmp, key, k)) &gt; 0)
<i>774</i>&nbsp;                    b = n;
<i>775</i>&nbsp;                else if (c &lt; 0)
<i>776</i>&nbsp;                    break outer;
<b class="nc"><i>777</i>&nbsp;                else if (value != null &amp;&amp; !value.equals(v))</b>
<b class="nc"><i>778</i>&nbsp;                    break outer;</b>
<b class="nc"><i>779</i>&nbsp;                else if (VAL.compareAndSet(n, v, null)) {</b>
<i>780</i>&nbsp;                    result = v;
<b class="nc"><i>781</i>&nbsp;                    unlinkNode(b, n);</b>
<i>782</i>&nbsp;                    break; // loop to clean up
<b class="nc"><i>783</i>&nbsp;                }</b>
<b class="nc"><i>784</i>&nbsp;            }</b>
<b class="nc"><i>785</i>&nbsp;        }</b>
<b class="nc"><i>786</i>&nbsp;        if (result != null) {</b>
<b class="nc"><i>787</i>&nbsp;            tryReduceLevel();</b>
<b class="nc"><i>788</i>&nbsp;            addCount(-1L);</b>
<b class="nc"><i>789</i>&nbsp;        }</b>
<b class="nc"><i>790</i>&nbsp;        return result;</b>
<i>791</i>&nbsp;    }
<b class="nc"><i>792</i>&nbsp;</b>
<b class="nc"><i>793</i>&nbsp;    /**</b>
<b class="nc"><i>794</i>&nbsp;     * Possibly reduce head level if it has no nodes.  This method can</b>
<b class="nc"><i>795</i>&nbsp;     * (rarely) make mistakes, in which case levels can disappear even</b>
<b class="nc"><i>796</i>&nbsp;     * though they are about to contain index nodes. This impacts</b>
<i>797</i>&nbsp;     * performance, not correctness.  To minimize mistakes as well as
<b class="nc"><i>798</i>&nbsp;     * to reduce hysteresis, the level is reduced by one only if the</b>
<b class="nc"><i>799</i>&nbsp;     * topmost three levels look empty. Also, if the removed level</b>
<b class="nc"><i>800</i>&nbsp;     * looks non-empty after CAS, we try to change it back quick</b>
<b class="nc"><i>801</i>&nbsp;     * before anyone notices our mistake! (This trick works pretty</b>
<b class="nc"><i>802</i>&nbsp;     * well because this method will practically never make mistakes</b>
<i>803</i>&nbsp;     * unless current thread stalls immediately before first CAS, in
<b class="nc"><i>804</i>&nbsp;     * which case it is very unlikely to stall again immediately</b>
<i>805</i>&nbsp;     * afterwards, so will recover.)
<i>806</i>&nbsp;     *
<i>807</i>&nbsp;     * We put up with all this rather than just let levels grow
<i>808</i>&nbsp;     * because otherwise, even a small map that has undergone a large
<i>809</i>&nbsp;     * number of insertions and removals will have a lot of levels,
<i>810</i>&nbsp;     * slowing down access more than would an occasional unwanted
<i>811</i>&nbsp;     * reduction.
<i>812</i>&nbsp;     */
<i>813</i>&nbsp;    private void tryReduceLevel() {
<i>814</i>&nbsp;        Index&lt;K,V&gt; h, d, e;
<i>815</i>&nbsp;        if ((h = head) != null &amp;&amp; h.right == null &amp;&amp;
<i>816</i>&nbsp;            (d = h.down) != null &amp;&amp; d.right == null &amp;&amp;
<i>817</i>&nbsp;            (e = d.down) != null &amp;&amp; e.right == null &amp;&amp;
<i>818</i>&nbsp;            HEAD.compareAndSet(this, h, d) &amp;&amp;
<b class="nc"><i>819</i>&nbsp;            h.right != null)   // recheck</b>
<b class="nc"><i>820</i>&nbsp;            HEAD.compareAndSet(this, d, h);  // try to backout</b>
<b class="nc"><i>821</i>&nbsp;    }</b>
<i>822</i>&nbsp;
<b class="nc"><i>823</i>&nbsp;    /* ---------------- Finding and removing first element -------------- */</b>
<b class="nc"><i>824</i>&nbsp;</b>
<i>825</i>&nbsp;    /**
<b class="nc"><i>826</i>&nbsp;     * Gets first valid node, unlinking deleted nodes if encountered.</b>
<b class="nc"><i>827</i>&nbsp;     * @return first node or null if empty</b>
<b class="nc"><i>828</i>&nbsp;     */</b>
<b class="nc"><i>829</i>&nbsp;    final Node&lt;K,V&gt; findFirst() {</b>
<b class="nc"><i>830</i>&nbsp;        Node&lt;K,V&gt; b, n;</b>
<b class="nc"><i>831</i>&nbsp;        if ((b = baseHead()) != null) {</b>
<i>832</i>&nbsp;            while ((n = b.next) != null) {
<b class="nc"><i>833</i>&nbsp;                if (n.val == null)</b>
<b class="nc"><i>834</i>&nbsp;                    unlinkNode(b, n);</b>
<b class="nc"><i>835</i>&nbsp;                else</b>
<b class="nc"><i>836</i>&nbsp;                    return n;</b>
<b class="nc"><i>837</i>&nbsp;            }</b>
<b class="nc"><i>838</i>&nbsp;        }</b>
<i>839</i>&nbsp;        return null;
<b class="nc"><i>840</i>&nbsp;    }</b>
<b class="nc"><i>841</i>&nbsp;</b>
<b class="nc"><i>842</i>&nbsp;    /**</b>
<b class="nc"><i>843</i>&nbsp;     * Entry snapshot version of findFirst</b>
<i>844</i>&nbsp;     */
<i>845</i>&nbsp;    final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findFirstEntry() {
<i>846</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;
<i>847</i>&nbsp;        if ((b = baseHead()) != null) {
<i>848</i>&nbsp;            while ((n = b.next) != null) {
<i>849</i>&nbsp;                if ((v = n.val) == null)
<b class="nc"><i>850</i>&nbsp;                    unlinkNode(b, n);</b>
<b class="nc"><i>851</i>&nbsp;                else</b>
<b class="nc"><i>852</i>&nbsp;                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</b>
<i>853</i>&nbsp;            }
<i>854</i>&nbsp;        }
<i>855</i>&nbsp;        return null;
<i>856</i>&nbsp;    }
<b class="nc"><i>857</i>&nbsp;</b>
<b class="nc"><i>858</i>&nbsp;    /**</b>
<b class="nc"><i>859</i>&nbsp;     * Removes first entry; returns its snapshot.</b>
<b class="nc"><i>860</i>&nbsp;     * @return null if empty, else snapshot of first entry</b>
<b class="nc"><i>861</i>&nbsp;     */</b>
<b class="nc"><i>862</i>&nbsp;    private AbstractMap.SimpleImmutableEntry&lt;K,V&gt; doRemoveFirstEntry() {</b>
<b class="nc"><i>863</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;</b>
<b class="nc"><i>864</i>&nbsp;        if ((b = baseHead()) != null) {</b>
<b class="nc"><i>865</i>&nbsp;            while ((n = b.next) != null) {</b>
<b class="nc"><i>866</i>&nbsp;                if ((v = n.val) == null || VAL.compareAndSet(n, v, null)) {</b>
<i>867</i>&nbsp;                    K k = n.key;
<i>868</i>&nbsp;                    unlinkNode(b, n);
<b class="nc"><i>869</i>&nbsp;                    if (v != null) {</b>
<b class="nc"><i>870</i>&nbsp;                        tryReduceLevel();</b>
<i>871</i>&nbsp;                        findPredecessor(k, comparator); // clean index
<b class="nc"><i>872</i>&nbsp;                        addCount(-1L);</b>
<b class="nc"><i>873</i>&nbsp;                        return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</b>
<i>874</i>&nbsp;                    }
<b class="nc"><i>875</i>&nbsp;                }</b>
<b class="nc"><i>876</i>&nbsp;            }</b>
<b class="nc"><i>877</i>&nbsp;        }</b>
<b class="nc"><i>878</i>&nbsp;        return null;</b>
<b class="nc"><i>879</i>&nbsp;    }</b>
<b class="nc"><i>880</i>&nbsp;</b>
<b class="nc"><i>881</i>&nbsp;    /* ---------------- Finding and removing last element -------------- */</b>
<b class="nc"><i>882</i>&nbsp;</b>
<b class="nc"><i>883</i>&nbsp;    /**</b>
<b class="nc"><i>884</i>&nbsp;     * Specialized version of find to get last valid node.</b>
<b class="nc"><i>885</i>&nbsp;     * @return last node or null if empty</b>
<b class="nc"><i>886</i>&nbsp;     */</b>
<i>887</i>&nbsp;    final Node&lt;K,V&gt; findLast() {
<b class="nc"><i>888</i>&nbsp;        outer: for (;;) {</b>
<i>889</i>&nbsp;            Index&lt;K,V&gt; q; Node&lt;K,V&gt; b;
<i>890</i>&nbsp;            VarHandle.acquireFence();
<b class="nc"><i>891</i>&nbsp;            if ((q = head) == null)</b>
<b class="nc"><i>892</i>&nbsp;                break;</b>
<b class="nc"><i>893</i>&nbsp;            for (Index&lt;K,V&gt; r, d;;) {</b>
<b class="nc"><i>894</i>&nbsp;                while ((r = q.right) != null) {</b>
<b class="nc"><i>895</i>&nbsp;                    Node&lt;K,V&gt; p;</b>
<b class="nc"><i>896</i>&nbsp;                    if ((p = r.node) == null || p.val == null)</b>
<b class="nc"><i>897</i>&nbsp;                        RIGHT.compareAndSet(q, r, r.right);</b>
<i>898</i>&nbsp;                    else
<b class="nc"><i>899</i>&nbsp;                        q = r;</b>
<b class="nc"><i>900</i>&nbsp;                }</b>
<b class="nc"><i>901</i>&nbsp;                if ((d = q.down) != null)</b>
<b class="nc"><i>902</i>&nbsp;                    q = d;</b>
<b class="nc"><i>903</i>&nbsp;                else {</b>
<b class="nc"><i>904</i>&nbsp;                    b = q.node;</b>
<i>905</i>&nbsp;                    break;
<b class="nc"><i>906</i>&nbsp;                }</b>
<b class="nc"><i>907</i>&nbsp;            }</b>
<b class="nc"><i>908</i>&nbsp;            if (b != null) {</b>
<b class="nc"><i>909</i>&nbsp;                for (;;) {</b>
<i>910</i>&nbsp;                    Node&lt;K,V&gt; n;
<i>911</i>&nbsp;                    if ((n = b.next) == null) {
<i>912</i>&nbsp;                        if (b.key == null) // empty
<b class="nc"><i>913</i>&nbsp;                            break outer;</b>
<b class="nc"><i>914</i>&nbsp;                        else</b>
<b class="nc"><i>915</i>&nbsp;                            return b;</b>
<b class="nc"><i>916</i>&nbsp;                    }</b>
<b class="nc"><i>917</i>&nbsp;                    else if (n.key == null)</b>
<b class="nc"><i>918</i>&nbsp;                        break;</b>
<i>919</i>&nbsp;                    else if (n.val == null)
<b class="nc"><i>920</i>&nbsp;                        unlinkNode(b, n);</b>
<b class="nc"><i>921</i>&nbsp;                    else</b>
<i>922</i>&nbsp;                        b = n;
<i>923</i>&nbsp;                }
<b class="nc"><i>924</i>&nbsp;            }</b>
<b class="nc"><i>925</i>&nbsp;        }</b>
<b class="nc"><i>926</i>&nbsp;        return null;</b>
<b class="nc"><i>927</i>&nbsp;    }</b>
<i>928</i>&nbsp;
<b class="nc"><i>929</i>&nbsp;    /**</b>
<i>930</i>&nbsp;     * Entry version of findLast
<b class="nc"><i>931</i>&nbsp;     * @return Entry for last node or null if empty</b>
<i>932</i>&nbsp;     */
<i>933</i>&nbsp;    final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findLastEntry() {
<i>934</i>&nbsp;        for (;;) {
<i>935</i>&nbsp;            Node&lt;K,V&gt; n; V v;
<i>936</i>&nbsp;            if ((n = findLast()) == null)
<i>937</i>&nbsp;                return null;
<i>938</i>&nbsp;            if ((v = n.val) != null)
<i>939</i>&nbsp;                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
<i>940</i>&nbsp;        }
<i>941</i>&nbsp;    }
<i>942</i>&nbsp;
<i>943</i>&nbsp;    /**
<i>944</i>&nbsp;     * Removes last entry; returns its snapshot.
<i>945</i>&nbsp;     * Specialized variant of doRemove.
<i>946</i>&nbsp;     * @return null if empty, else snapshot of last entry
<i>947</i>&nbsp;     */
<i>948</i>&nbsp;    private Map.Entry&lt;K,V&gt; doRemoveLastEntry() {
<i>949</i>&nbsp;        outer: for (;;) {
<i>950</i>&nbsp;            Index&lt;K,V&gt; q; Node&lt;K,V&gt; b;
<i>951</i>&nbsp;            VarHandle.acquireFence();
<i>952</i>&nbsp;            if ((q = head) == null)
<i>953</i>&nbsp;                break;
<i>954</i>&nbsp;            for (;;) {
<i>955</i>&nbsp;                Index&lt;K,V&gt; d, r; Node&lt;K,V&gt; p;
<b class="nc"><i>956</i>&nbsp;                while ((r = q.right) != null) {</b>
<b class="nc"><i>957</i>&nbsp;                    if ((p = r.node) == null || p.val == null)</b>
<b class="nc"><i>958</i>&nbsp;                        RIGHT.compareAndSet(q, r, r.right);</b>
<i>959</i>&nbsp;                    else if (p.next != null)
<b class="nc"><i>960</i>&nbsp;                        q = r;  // continue only if a successor</b>
<i>961</i>&nbsp;                    else
<b class="nc"><i>962</i>&nbsp;                        break;</b>
<b class="nc"><i>963</i>&nbsp;                }</b>
<b class="nc"><i>964</i>&nbsp;                if ((d = q.down) != null)</b>
<b class="nc"><i>965</i>&nbsp;                    q = d;</b>
<b class="nc"><i>966</i>&nbsp;                else {</b>
<b class="nc"><i>967</i>&nbsp;                    b = q.node;</b>
<b class="nc"><i>968</i>&nbsp;                    break;</b>
<b class="nc"><i>969</i>&nbsp;                }</b>
<i>970</i>&nbsp;            }
<b class="nc"><i>971</i>&nbsp;            if (b != null) {</b>
<b class="nc"><i>972</i>&nbsp;                for (;;) {</b>
<b class="nc"><i>973</i>&nbsp;                    Node&lt;K,V&gt; n; K k; V v;</b>
<b class="nc"><i>974</i>&nbsp;                    if ((n = b.next) == null) {</b>
<b class="nc"><i>975</i>&nbsp;                        if (b.key == null) // empty</b>
<b class="nc"><i>976</i>&nbsp;                            break outer;</b>
<b class="nc"><i>977</i>&nbsp;                        else</b>
<b class="nc"><i>978</i>&nbsp;                            break; // retry</b>
<i>979</i>&nbsp;                    }
<b class="nc"><i>980</i>&nbsp;                    else if ((k = n.key) == null)</b>
<b class="nc"><i>981</i>&nbsp;                        break;</b>
<b class="nc"><i>982</i>&nbsp;                    else if ((v = n.val) == null)</b>
<b class="nc"><i>983</i>&nbsp;                        unlinkNode(b, n);</b>
<b class="nc"><i>984</i>&nbsp;                    else if (n.next != null)</b>
<b class="nc"><i>985</i>&nbsp;                        b = n;</b>
<i>986</i>&nbsp;                    else if (VAL.compareAndSet(n, v, null)) {
<b class="nc"><i>987</i>&nbsp;                        unlinkNode(b, n);</b>
<b class="nc"><i>988</i>&nbsp;                        tryReduceLevel();</b>
<b class="nc"><i>989</i>&nbsp;                        findPredecessor(k, comparator); // clean index</b>
<i>990</i>&nbsp;                        addCount(-1L);
<b class="nc"><i>991</i>&nbsp;                        return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</b>
<b class="nc"><i>992</i>&nbsp;                    }</b>
<i>993</i>&nbsp;                }
<i>994</i>&nbsp;            }
<b class="nc"><i>995</i>&nbsp;        }</b>
<i>996</i>&nbsp;        return null;
<i>997</i>&nbsp;    }
<i>998</i>&nbsp;
<i>999</i>&nbsp;    /* ---------------- Relational operations -------------- */
<i>1000</i>&nbsp;
<i>1001</i>&nbsp;    // Control values OR&#39;ed as arguments to findNear
<i>1002</i>&nbsp;
<i>1003</i>&nbsp;    private static final int EQ = 1;
<i>1004</i>&nbsp;    private static final int LT = 2;
<i>1005</i>&nbsp;    private static final int GT = 0; // Actually checked as !LT
<i>1006</i>&nbsp;
<i>1007</i>&nbsp;    /**
<i>1008</i>&nbsp;     * Utility for ceiling, floor, lower, higher methods.
<i>1009</i>&nbsp;     * @param key the key
<i>1010</i>&nbsp;     * @param rel the relation -- OR&#39;ed combination of EQ, LT, GT
<i>1011</i>&nbsp;     * @return nearest node fitting relation, or null if no such
<i>1012</i>&nbsp;     */
<i>1013</i>&nbsp;    final Node&lt;K,V&gt; findNear(K key, int rel, Comparator&lt;? super K&gt; cmp) {
<i>1014</i>&nbsp;        if (key == null)
<i>1015</i>&nbsp;            throw new NullPointerException();
<i>1016</i>&nbsp;        Node&lt;K,V&gt; result;
<i>1017</i>&nbsp;        outer: for (Node&lt;K,V&gt; b;;) {
<i>1018</i>&nbsp;            if ((b = findPredecessor(key, cmp)) == null) {
<b class="nc"><i>1019</i>&nbsp;                result = null;</b>
<i>1020</i>&nbsp;                break;                   // empty
<i>1021</i>&nbsp;            }
<b class="nc"><i>1022</i>&nbsp;            for (;;) {</b>
<i>1023</i>&nbsp;                Node&lt;K,V&gt; n; K k; int c;
<i>1024</i>&nbsp;                if ((n = b.next) == null) {
<i>1025</i>&nbsp;                    result = ((rel &amp; LT) != 0 &amp;&amp; b.key != null) ? b : null;
<i>1026</i>&nbsp;                    break outer;
<i>1027</i>&nbsp;                }
<b class="nc"><i>1028</i>&nbsp;                else if ((k = n.key) == null)</b>
<i>1029</i>&nbsp;                    break;
<b class="nc"><i>1030</i>&nbsp;                else if (n.val == null)</b>
<i>1031</i>&nbsp;                    unlinkNode(b, n);
<i>1032</i>&nbsp;                else if (((c = cpr(cmp, key, k)) == 0 &amp;&amp; (rel &amp; EQ) != 0) ||
<i>1033</i>&nbsp;                         (c &lt; 0 &amp;&amp; (rel &amp; LT) == 0)) {
<i>1034</i>&nbsp;                    result = n;
<i>1035</i>&nbsp;                    break outer;
<i>1036</i>&nbsp;                }
<i>1037</i>&nbsp;                else if (c &lt;= 0 &amp;&amp; (rel &amp; LT) != 0) {
<i>1038</i>&nbsp;                    result = (b.key != null) ? b : null;
<i>1039</i>&nbsp;                    break outer;
<i>1040</i>&nbsp;                }
<b class="nc"><i>1041</i>&nbsp;                else</b>
<b class="nc"><i>1042</i>&nbsp;                    b = n;</b>
<b class="nc"><i>1043</i>&nbsp;            }</b>
<b class="nc"><i>1044</i>&nbsp;        }</b>
<b class="nc"><i>1045</i>&nbsp;        return result;</b>
<i>1046</i>&nbsp;    }
<i>1047</i>&nbsp;
<i>1048</i>&nbsp;    /**
<i>1049</i>&nbsp;     * Variant of findNear returning SimpleImmutableEntry
<i>1050</i>&nbsp;     * @param key the key
<i>1051</i>&nbsp;     * @param rel the relation -- OR&#39;ed combination of EQ, LT, GT
<i>1052</i>&nbsp;     * @return Entry fitting relation, or null if no such
<i>1053</i>&nbsp;     */
<i>1054</i>&nbsp;    final AbstractMap.SimpleImmutableEntry&lt;K,V&gt; findNearEntry(K key, int rel,
<b class="nc"><i>1055</i>&nbsp;                                                              Comparator&lt;? super K&gt; cmp) {</b>
<b class="nc"><i>1056</i>&nbsp;        for (;;) {</b>
<b class="nc"><i>1057</i>&nbsp;            Node&lt;K,V&gt; n; V v;</b>
<b class="nc"><i>1058</i>&nbsp;            if ((n = findNear(key, rel, cmp)) == null)</b>
<b class="nc"><i>1059</i>&nbsp;                return null;</b>
<b class="nc"><i>1060</i>&nbsp;            if ((v = n.val) != null)</b>
<b class="nc"><i>1061</i>&nbsp;                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</b>
<b class="nc"><i>1062</i>&nbsp;        }</b>
<b class="nc"><i>1063</i>&nbsp;    }</b>
<i>1064</i>&nbsp;
<b class="nc"><i>1065</i>&nbsp;    /* ---------------- Constructors -------------- */</b>
<b class="nc"><i>1066</i>&nbsp;</b>
<b class="nc"><i>1067</i>&nbsp;    /**</b>
<b class="nc"><i>1068</i>&nbsp;     * Constructs a new, empty map, sorted according to the</b>
<b class="nc"><i>1069</i>&nbsp;     * {@linkplain Comparable natural ordering} of the keys.</b>
<b class="nc"><i>1070</i>&nbsp;     */</b>
<b class="nc"><i>1071</i>&nbsp;    public ConcurrentSkipListMap() {</b>
<i>1072</i>&nbsp;        this.comparator = null;
<i>1073</i>&nbsp;    }
<i>1074</i>&nbsp;
<i>1075</i>&nbsp;    /**
<i>1076</i>&nbsp;     * Constructs a new, empty map, sorted according to the specified
<i>1077</i>&nbsp;     * comparator.
<i>1078</i>&nbsp;     *
<i>1079</i>&nbsp;     * @param comparator the comparator that will be used to order this map.
<b class="nc"><i>1080</i>&nbsp;     *        If {@code null}, the {@linkplain Comparable natural</b>
<b class="nc"><i>1081</i>&nbsp;     *        ordering} of the keys will be used.</b>
<b class="nc"><i>1082</i>&nbsp;     */</b>
<b class="nc"><i>1083</i>&nbsp;    public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) {</b>
<b class="nc"><i>1084</i>&nbsp;        this.comparator = comparator;</b>
<b class="nc"><i>1085</i>&nbsp;    }</b>
<b class="nc"><i>1086</i>&nbsp;</b>
<i>1087</i>&nbsp;    /**
<i>1088</i>&nbsp;     * Constructs a new map containing the same mappings as the given map,
<b class="nc"><i>1089</i>&nbsp;     * sorted according to the {@linkplain Comparable natural ordering} of</b>
<i>1090</i>&nbsp;     * the keys.
<i>1091</i>&nbsp;     *
<i>1092</i>&nbsp;     * @param  m the map whose mappings are to be placed in this map
<i>1093</i>&nbsp;     * @throws ClassCastException if the keys in {@code m} are not
<i>1094</i>&nbsp;     *         {@link Comparable}, or are not mutually comparable
<i>1095</i>&nbsp;     * @throws NullPointerException if the specified map or any of its keys
<i>1096</i>&nbsp;     *         or values are null
<i>1097</i>&nbsp;     */
<i>1098</i>&nbsp;    public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) {
<i>1099</i>&nbsp;        this.comparator = null;
<b class="nc"><i>1100</i>&nbsp;        putAll(m);</b>
<b class="nc"><i>1101</i>&nbsp;    }</b>
<b class="nc"><i>1102</i>&nbsp;</b>
<b class="nc"><i>1103</i>&nbsp;    /**</b>
<b class="nc"><i>1104</i>&nbsp;     * Constructs a new map containing the same mappings and using the</b>
<i>1105</i>&nbsp;     * same ordering as the specified sorted map.
<i>1106</i>&nbsp;     *
<i>1107</i>&nbsp;     * @param m the sorted map whose mappings are to be placed in this
<i>1108</i>&nbsp;     *        map, and whose comparator is to be used to sort this map
<b class="nc"><i>1109</i>&nbsp;     * @throws NullPointerException if the specified sorted map or any of</b>
<b class="nc"><i>1110</i>&nbsp;     *         its keys or values are null</b>
<b class="nc"><i>1111</i>&nbsp;     */</b>
<b class="nc"><i>1112</i>&nbsp;    public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) {</b>
<b class="nc"><i>1113</i>&nbsp;        this.comparator = m.comparator();</b>
<b class="nc"><i>1114</i>&nbsp;        buildFromSorted(m); // initializes transients</b>
<b class="nc"><i>1115</i>&nbsp;    }</b>
<i>1116</i>&nbsp;
<b class="nc"><i>1117</i>&nbsp;    /**</b>
<b class="nc"><i>1118</i>&nbsp;     * Returns a shallow copy of this {@code ConcurrentSkipListMap}</b>
<b class="nc"><i>1119</i>&nbsp;     * instance. (The keys and values themselves are not cloned.)</b>
<b class="nc"><i>1120</i>&nbsp;     *</b>
<b class="nc"><i>1121</i>&nbsp;     * @return a shallow copy of this map</b>
<b class="nc"><i>1122</i>&nbsp;     */</b>
<i>1123</i>&nbsp;    public ConcurrentSkipListMap&lt;K,V&gt; clone() {
<b class="nc"><i>1124</i>&nbsp;        try {</b>
<b class="nc"><i>1125</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1126</i>&nbsp;            ConcurrentSkipListMap&lt;K,V&gt; clone =</b>
<b class="nc"><i>1127</i>&nbsp;                (ConcurrentSkipListMap&lt;K,V&gt;) super.clone();</b>
<b class="nc"><i>1128</i>&nbsp;            clone.keySet = null;</b>
<i>1129</i>&nbsp;            clone.entrySet = null;
<b class="nc"><i>1130</i>&nbsp;            clone.values = null;</b>
<b class="nc"><i>1131</i>&nbsp;            clone.descendingMap = null;</b>
<b class="nc"><i>1132</i>&nbsp;            clone.buildFromSorted(this);</b>
<i>1133</i>&nbsp;            return clone;
<b class="nc"><i>1134</i>&nbsp;        } catch (CloneNotSupportedException e) {</b>
<b class="nc"><i>1135</i>&nbsp;            throw new InternalError();</b>
<i>1136</i>&nbsp;        }
<b class="nc"><i>1137</i>&nbsp;    }</b>
<i>1138</i>&nbsp;
<i>1139</i>&nbsp;    /**
<i>1140</i>&nbsp;     * Streamlined bulk insertion to initialize from elements of
<i>1141</i>&nbsp;     * given sorted map.  Call only from constructor or clone
<i>1142</i>&nbsp;     * method.
<i>1143</i>&nbsp;     */
<i>1144</i>&nbsp;    private void buildFromSorted(SortedMap&lt;K, ? extends V&gt; map) {
<i>1145</i>&nbsp;        if (map == null)
<i>1146</i>&nbsp;            throw new NullPointerException();
<i>1147</i>&nbsp;        Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; it =
<i>1148</i>&nbsp;            map.entrySet().iterator();
<i>1149</i>&nbsp;
<i>1150</i>&nbsp;        /*
<i>1151</i>&nbsp;         * Add equally spaced indices at log intervals, using the bits
<b class="nc"><i>1152</i>&nbsp;         * of count during insertion. The maximum possible resulting</b>
<i>1153</i>&nbsp;         * level is less than the number of bits in a long (64). The
<i>1154</i>&nbsp;         * preds array tracks the current rightmost node at each
<b class="nc"><i>1155</i>&nbsp;         * level.</b>
<b class="nc"><i>1156</i>&nbsp;         */</b>
<b class="nc"><i>1157</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1158</i>&nbsp;        Index&lt;K,V&gt;[] preds = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[64];</b>
<i>1159</i>&nbsp;        Node&lt;K,V&gt; bp = new Node&lt;K,V&gt;(null, null, null);
<i>1160</i>&nbsp;        Index&lt;K,V&gt; h = preds[0] = new Index&lt;K,V&gt;(bp, null, null);
<b class="nc"><i>1161</i>&nbsp;        long count = 0;</b>
<b class="nc"><i>1162</i>&nbsp;</b>
<b class="nc"><i>1163</i>&nbsp;        while (it.hasNext()) {</b>
<i>1164</i>&nbsp;            Map.Entry&lt;? extends K, ? extends V&gt; e = it.next();
<b class="nc"><i>1165</i>&nbsp;            K k = e.getKey();</b>
<b class="nc"><i>1166</i>&nbsp;            V v = e.getValue();</b>
<b class="nc"><i>1167</i>&nbsp;            if (k == null || v == null)</b>
<b class="nc"><i>1168</i>&nbsp;                throw new NullPointerException();</b>
<b class="nc"><i>1169</i>&nbsp;            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);</b>
<b class="nc"><i>1170</i>&nbsp;            bp = bp.next = z;</b>
<b class="nc"><i>1171</i>&nbsp;            if ((++count &amp; 3L) == 0L) {</b>
<b class="nc"><i>1172</i>&nbsp;                long m = count &gt;&gt;&gt; 2;</b>
<b class="nc"><i>1173</i>&nbsp;                int i = 0;</b>
<b class="nc"><i>1174</i>&nbsp;                Index&lt;K,V&gt; idx = null, q;</b>
<i>1175</i>&nbsp;                do {
<b class="nc"><i>1176</i>&nbsp;                    idx = new Index&lt;K,V&gt;(z, idx, null);</b>
<b class="nc"><i>1177</i>&nbsp;                    if ((q = preds[i]) == null)</b>
<b class="nc"><i>1178</i>&nbsp;                        preds[i] = h = new Index&lt;K,V&gt;(h.node, h, idx);</b>
<b class="nc"><i>1179</i>&nbsp;                    else</b>
<b class="nc"><i>1180</i>&nbsp;                        preds[i] = q.right = idx;</b>
<b class="nc"><i>1181</i>&nbsp;                } while (++i &lt; preds.length &amp;&amp; ((m &gt;&gt;&gt;= 1) &amp; 1L) != 0L);</b>
<i>1182</i>&nbsp;            }
<b class="nc"><i>1183</i>&nbsp;        }</b>
<i>1184</i>&nbsp;        if (count != 0L) {
<i>1185</i>&nbsp;            VarHandle.releaseFence(); // emulate volatile stores
<i>1186</i>&nbsp;            addCount(count);
<i>1187</i>&nbsp;            head = h;
<i>1188</i>&nbsp;            VarHandle.fullFence();
<i>1189</i>&nbsp;        }
<i>1190</i>&nbsp;    }
<i>1191</i>&nbsp;
<i>1192</i>&nbsp;    /* ---------------- Serialization -------------- */
<i>1193</i>&nbsp;
<i>1194</i>&nbsp;    /**
<b class="nc"><i>1195</i>&nbsp;     * Saves this map to a stream (that is, serializes it).</b>
<i>1196</i>&nbsp;     *
<b class="nc"><i>1197</i>&nbsp;     * @param s the stream</b>
<b class="nc"><i>1198</i>&nbsp;     * @throws java.io.IOException if an I/O error occurs</b>
<b class="nc"><i>1199</i>&nbsp;     * @serialData The key (Object) and value (Object) for each</b>
<b class="nc"><i>1200</i>&nbsp;     * key-value mapping represented by the map, followed by</b>
<i>1201</i>&nbsp;     * {@code null}. The key-value mappings are emitted in key-order
<i>1202</i>&nbsp;     * (as determined by the Comparator, or by the keys&#39; natural
<b class="nc"><i>1203</i>&nbsp;     * ordering if no Comparator).</b>
<b class="nc"><i>1204</i>&nbsp;     */</b>
<b class="nc"><i>1205</i>&nbsp;    private void writeObject(java.io.ObjectOutputStream s)</b>
<i>1206</i>&nbsp;        throws java.io.IOException {
<i>1207</i>&nbsp;        // Write out the Comparator and any hidden stuff
<b class="nc"><i>1208</i>&nbsp;        s.defaultWriteObject();</b>
<b class="nc"><i>1209</i>&nbsp;</b>
<i>1210</i>&nbsp;        // Write out keys and values (alternating)
<b class="nc"><i>1211</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;</b>
<b class="nc"><i>1212</i>&nbsp;        if ((b = baseHead()) != null) {</b>
<i>1213</i>&nbsp;            while ((n = b.next) != null) {
<i>1214</i>&nbsp;                if ((v = n.val) != null) {
<i>1215</i>&nbsp;                    s.writeObject(n.key);
<i>1216</i>&nbsp;                    s.writeObject(v);
<i>1217</i>&nbsp;                }
<i>1218</i>&nbsp;                b = n;
<i>1219</i>&nbsp;            }
<i>1220</i>&nbsp;        }
<i>1221</i>&nbsp;        s.writeObject(null);
<i>1222</i>&nbsp;    }
<i>1223</i>&nbsp;
<i>1224</i>&nbsp;    /**
<i>1225</i>&nbsp;     * Reconstitutes this map from a stream (that is, deserializes it).
<i>1226</i>&nbsp;     * @param s the stream
<i>1227</i>&nbsp;     * @throws ClassNotFoundException if the class of a serialized object
<i>1228</i>&nbsp;     *         could not be found
<i>1229</i>&nbsp;     * @throws java.io.IOException if an I/O error occurs
<i>1230</i>&nbsp;     */
<b class="nc"><i>1231</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1232</i>&nbsp;    private void readObject(final java.io.ObjectInputStream s)</b>
<i>1233</i>&nbsp;        throws java.io.IOException, ClassNotFoundException {
<b class="nc"><i>1234</i>&nbsp;        // Read in the Comparator and any hidden stuff</b>
<i>1235</i>&nbsp;        s.defaultReadObject();
<b class="nc"><i>1236</i>&nbsp;</b>
<b class="nc"><i>1237</i>&nbsp;        // Same idea as buildFromSorted</b>
<b class="nc"><i>1238</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1239</i>&nbsp;        Index&lt;K,V&gt;[] preds = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[64];</b>
<b class="nc"><i>1240</i>&nbsp;        Node&lt;K,V&gt; bp = new Node&lt;K,V&gt;(null, null, null);</b>
<b class="nc"><i>1241</i>&nbsp;        Index&lt;K,V&gt; h = preds[0] = new Index&lt;K,V&gt;(bp, null, null);</b>
<b class="nc"><i>1242</i>&nbsp;        Comparator&lt;? super K&gt; cmp = comparator;</b>
<b class="nc"><i>1243</i>&nbsp;        K prevKey = null;</b>
<i>1244</i>&nbsp;        long count = 0;
<b class="nc"><i>1245</i>&nbsp;</b>
<b class="nc"><i>1246</i>&nbsp;        for (;;) {</b>
<b class="nc"><i>1247</i>&nbsp;            K k = (K)s.readObject();</b>
<b class="nc"><i>1248</i>&nbsp;            if (k == null)</b>
<i>1249</i>&nbsp;                break;
<b class="nc"><i>1250</i>&nbsp;            V v = (V)s.readObject();</b>
<b class="nc"><i>1251</i>&nbsp;            if (v == null)</b>
<b class="nc"><i>1252</i>&nbsp;                throw new NullPointerException();</b>
<b class="nc"><i>1253</i>&nbsp;            if (prevKey != null &amp;&amp; cpr(cmp, prevKey, k) &gt; 0)</b>
<b class="nc"><i>1254</i>&nbsp;                throw new IllegalStateException(&quot;out of order&quot;);</b>
<b class="nc"><i>1255</i>&nbsp;            prevKey = k;</b>
<i>1256</i>&nbsp;            Node&lt;K,V&gt; z = new Node&lt;K,V&gt;(k, v, null);
<i>1257</i>&nbsp;            bp = bp.next = z;
<i>1258</i>&nbsp;            if ((++count &amp; 3L) == 0L) {
<i>1259</i>&nbsp;                long m = count &gt;&gt;&gt; 2;
<i>1260</i>&nbsp;                int i = 0;
<i>1261</i>&nbsp;                Index&lt;K,V&gt; idx = null, q;
<i>1262</i>&nbsp;                do {
<i>1263</i>&nbsp;                    idx = new Index&lt;K,V&gt;(z, idx, null);
<i>1264</i>&nbsp;                    if ((q = preds[i]) == null)
<i>1265</i>&nbsp;                        preds[i] = h = new Index&lt;K,V&gt;(h.node, h, idx);
<b class="nc"><i>1266</i>&nbsp;                    else</b>
<i>1267</i>&nbsp;                        preds[i] = q.right = idx;
<b class="nc"><i>1268</i>&nbsp;                } while (++i &lt; preds.length &amp;&amp; ((m &gt;&gt;&gt;= 1) &amp; 1L) != 0L);</b>
<b class="nc"><i>1269</i>&nbsp;            }</b>
<b class="nc"><i>1270</i>&nbsp;        }</b>
<b class="nc"><i>1271</i>&nbsp;        if (count != 0L) {</b>
<b class="nc"><i>1272</i>&nbsp;            VarHandle.releaseFence();</b>
<b class="nc"><i>1273</i>&nbsp;            addCount(count);</b>
<b class="nc"><i>1274</i>&nbsp;            head = h;</b>
<i>1275</i>&nbsp;            VarHandle.fullFence();
<i>1276</i>&nbsp;        }
<i>1277</i>&nbsp;    }
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;    /* ------ Map API methods ------ */
<i>1280</i>&nbsp;
<i>1281</i>&nbsp;    /**
<i>1282</i>&nbsp;     * Returns {@code true} if this map contains a mapping for the specified
<b class="nc"><i>1283</i>&nbsp;     * key.</b>
<b class="nc"><i>1284</i>&nbsp;     *</b>
<b class="nc"><i>1285</i>&nbsp;     * @param key key whose presence in this map is to be tested</b>
<i>1286</i>&nbsp;     * @return {@code true} if this map contains a mapping for the specified key
<i>1287</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1288</i>&nbsp;     *         with the keys currently in the map
<i>1289</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1290</i>&nbsp;     */
<i>1291</i>&nbsp;    public boolean containsKey(Object key) {
<i>1292</i>&nbsp;        return doGet(key) != null;
<i>1293</i>&nbsp;    }
<i>1294</i>&nbsp;
<i>1295</i>&nbsp;    /**
<b class="nc"><i>1296</i>&nbsp;     * Returns the value to which the specified key is mapped,</b>
<b class="nc"><i>1297</i>&nbsp;     * or {@code null} if this map contains no mapping for the key.</b>
<b class="nc"><i>1298</i>&nbsp;     *</b>
<i>1299</i>&nbsp;     * &lt;p&gt;More formally, if this map contains a mapping from a key
<i>1300</i>&nbsp;     * {@code k} to a value {@code v} such that {@code key} compares
<i>1301</i>&nbsp;     * equal to {@code k} according to the map&#39;s ordering, then this
<i>1302</i>&nbsp;     * method returns {@code v}; otherwise it returns {@code null}.
<i>1303</i>&nbsp;     * (There can be at most one such mapping.)
<i>1304</i>&nbsp;     *
<i>1305</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1306</i>&nbsp;     *         with the keys currently in the map
<i>1307</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1308</i>&nbsp;     */
<i>1309</i>&nbsp;    public V get(Object key) {
<i>1310</i>&nbsp;        return doGet(key);
<i>1311</i>&nbsp;    }
<b class="nc"><i>1312</i>&nbsp;</b>
<b class="nc"><i>1313</i>&nbsp;    /**</b>
<b class="nc"><i>1314</i>&nbsp;     * Returns the value to which the specified key is mapped,</b>
<b class="nc"><i>1315</i>&nbsp;     * or the given defaultValue if this map contains no mapping for the key.</b>
<i>1316</i>&nbsp;     *
<i>1317</i>&nbsp;     * @param key the key
<i>1318</i>&nbsp;     * @param defaultValue the value to return if this map contains
<i>1319</i>&nbsp;     * no mapping for the given key
<i>1320</i>&nbsp;     * @return the mapping for the key, if present; else the defaultValue
<i>1321</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1322</i>&nbsp;     * @since 1.8
<i>1323</i>&nbsp;     */
<i>1324</i>&nbsp;    public V getOrDefault(Object key, V defaultValue) {
<i>1325</i>&nbsp;        V v;
<i>1326</i>&nbsp;        return (v = doGet(key)) == null ? defaultValue : v;
<b class="nc"><i>1327</i>&nbsp;    }</b>
<b class="nc"><i>1328</i>&nbsp;</b>
<b class="nc"><i>1329</i>&nbsp;    /**</b>
<b class="nc"><i>1330</i>&nbsp;     * Associates the specified value with the specified key in this map.</b>
<i>1331</i>&nbsp;     * If the map previously contained a mapping for the key, the old
<i>1332</i>&nbsp;     * value is replaced.
<i>1333</i>&nbsp;     *
<i>1334</i>&nbsp;     * @param key key with which the specified value is to be associated
<i>1335</i>&nbsp;     * @param value value to be associated with the specified key
<i>1336</i>&nbsp;     * @return the previous value associated with the specified key, or
<i>1337</i>&nbsp;     *         {@code null} if there was no mapping for the key
<i>1338</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1339</i>&nbsp;     *         with the keys currently in the map
<i>1340</i>&nbsp;     * @throws NullPointerException if the specified key or value is null
<i>1341</i>&nbsp;     */
<b class="nc"><i>1342</i>&nbsp;    public V put(K key, V value) {</b>
<b class="nc"><i>1343</i>&nbsp;        if (value == null)</b>
<b class="nc"><i>1344</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>1345</i>&nbsp;        return doPut(key, value, false);</b>
<b class="nc"><i>1346</i>&nbsp;    }</b>
<b class="nc"><i>1347</i>&nbsp;</b>
<b class="nc"><i>1348</i>&nbsp;    /**</b>
<i>1349</i>&nbsp;     * Removes the mapping for the specified key from this map if present.
<i>1350</i>&nbsp;     *
<i>1351</i>&nbsp;     * @param  key key for which mapping should be removed
<i>1352</i>&nbsp;     * @return the previous value associated with the specified key, or
<i>1353</i>&nbsp;     *         {@code null} if there was no mapping for the key
<i>1354</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1355</i>&nbsp;     *         with the keys currently in the map
<i>1356</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1357</i>&nbsp;     */
<b class="nc"><i>1358</i>&nbsp;    public V remove(Object key) {</b>
<b class="nc"><i>1359</i>&nbsp;        return doRemove(key, null);</b>
<i>1360</i>&nbsp;    }
<b class="nc"><i>1361</i>&nbsp;</b>
<b class="nc"><i>1362</i>&nbsp;    /**</b>
<i>1363</i>&nbsp;     * Returns {@code true} if this map maps one or more keys to the
<i>1364</i>&nbsp;     * specified value.  This operation requires time linear in the
<i>1365</i>&nbsp;     * map size. Additionally, it is possible for the map to change
<b class="nc"><i>1366</i>&nbsp;     * during execution of this method, in which case the returned</b>
<i>1367</i>&nbsp;     * result may be inaccurate.
<i>1368</i>&nbsp;     *
<b class="nc"><i>1369</i>&nbsp;     * @param value value whose presence in this map is to be tested</b>
<b class="nc"><i>1370</i>&nbsp;     * @return {@code true} if a mapping to {@code value} exists;</b>
<b class="nc"><i>1371</i>&nbsp;     *         {@code false} otherwise</b>
<b class="nc"><i>1372</i>&nbsp;     * @throws NullPointerException if the specified value is null</b>
<b class="nc"><i>1373</i>&nbsp;     */</b>
<b class="nc"><i>1374</i>&nbsp;    public boolean containsValue(Object value) {</b>
<i>1375</i>&nbsp;        if (value == null)
<i>1376</i>&nbsp;            throw new NullPointerException();
<b class="nc"><i>1377</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;</b>
<b class="nc"><i>1378</i>&nbsp;        if ((b = baseHead()) != null) {</b>
<b class="nc"><i>1379</i>&nbsp;            while ((n = b.next) != null) {</b>
<b class="nc"><i>1380</i>&nbsp;                if ((v = n.val) != null &amp;&amp; value.equals(v))</b>
<b class="nc"><i>1381</i>&nbsp;                    return true;</b>
<b class="nc"><i>1382</i>&nbsp;                else</b>
<b class="nc"><i>1383</i>&nbsp;                    b = n;</b>
<i>1384</i>&nbsp;            }
<b class="nc"><i>1385</i>&nbsp;        }</b>
<b class="nc"><i>1386</i>&nbsp;        return false;</b>
<b class="nc"><i>1387</i>&nbsp;    }</b>
<i>1388</i>&nbsp;
<b class="nc"><i>1389</i>&nbsp;    /**</b>
<b class="nc"><i>1390</i>&nbsp;     * {@inheritDoc}</b>
<b class="nc"><i>1391</i>&nbsp;     */</b>
<b class="nc"><i>1392</i>&nbsp;    public int size() {</b>
<b class="nc"><i>1393</i>&nbsp;        long c;</b>
<b class="nc"><i>1394</i>&nbsp;        return ((baseHead() == null) ? 0 :</b>
<b class="nc"><i>1395</i>&nbsp;                ((c = getAdderCount()) &gt;= Integer.MAX_VALUE) ?</b>
<b class="nc"><i>1396</i>&nbsp;                Integer.MAX_VALUE : (int) c);</b>
<b class="nc"><i>1397</i>&nbsp;    }</b>
<b class="nc"><i>1398</i>&nbsp;</b>
<b class="nc"><i>1399</i>&nbsp;    /**</b>
<b class="nc"><i>1400</i>&nbsp;     * {@inheritDoc}</b>
<b class="nc"><i>1401</i>&nbsp;     */</b>
<i>1402</i>&nbsp;    public boolean isEmpty() {
<b class="nc"><i>1403</i>&nbsp;        return findFirst() == null;</b>
<b class="nc"><i>1404</i>&nbsp;    }</b>
<b class="nc"><i>1405</i>&nbsp;</b>
<i>1406</i>&nbsp;    /**
<b class="nc"><i>1407</i>&nbsp;     * Removes all of the mappings from this map.</b>
<i>1408</i>&nbsp;     */
<i>1409</i>&nbsp;    public void clear() {
<b class="nc"><i>1410</i>&nbsp;        Index&lt;K,V&gt; h, r, d; Node&lt;K,V&gt; b;</b>
<b class="nc"><i>1411</i>&nbsp;        VarHandle.acquireFence();</b>
<i>1412</i>&nbsp;        while ((h = head) != null) {
<i>1413</i>&nbsp;            if ((r = h.right) != null)        // remove indices
<i>1414</i>&nbsp;                RIGHT.compareAndSet(h, r, null);
<i>1415</i>&nbsp;            else if ((d = h.down) != null)    // remove levels
<i>1416</i>&nbsp;                HEAD.compareAndSet(this, h, d);
<i>1417</i>&nbsp;            else {
<i>1418</i>&nbsp;                long count = 0L;
<i>1419</i>&nbsp;                if ((b = h.node) != null) {    // remove nodes
<i>1420</i>&nbsp;                    Node&lt;K,V&gt; n; V v;
<i>1421</i>&nbsp;                    while ((n = b.next) != null) {
<i>1422</i>&nbsp;                        if ((v = n.val) != null &amp;&amp;
<i>1423</i>&nbsp;                            VAL.compareAndSet(n, v, null)) {
<i>1424</i>&nbsp;                            --count;
<i>1425</i>&nbsp;                            v = null;
<i>1426</i>&nbsp;                        }
<i>1427</i>&nbsp;                        if (v == null)
<i>1428</i>&nbsp;                            unlinkNode(b, n);
<i>1429</i>&nbsp;                    }
<b class="nc"><i>1430</i>&nbsp;                }</b>
<i>1431</i>&nbsp;                if (count != 0L)
<i>1432</i>&nbsp;                    addCount(count);
<b class="nc"><i>1433</i>&nbsp;                else</b>
<b class="nc"><i>1434</i>&nbsp;                    break;</b>
<b class="nc"><i>1435</i>&nbsp;            }</b>
<b class="nc"><i>1436</i>&nbsp;        }</b>
<b class="nc"><i>1437</i>&nbsp;    }</b>
<i>1438</i>&nbsp;
<i>1439</i>&nbsp;    /**
<b class="nc"><i>1440</i>&nbsp;     * If the specified key is not already associated with a value,</b>
<i>1441</i>&nbsp;     * attempts to compute its value using the given mapping function
<i>1442</i>&nbsp;     * and enters it into this map unless {@code null}.  The function
<i>1443</i>&nbsp;     * is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only
<i>1444</i>&nbsp;     * if the value is not present.
<i>1445</i>&nbsp;     *
<i>1446</i>&nbsp;     * @param key key with which the specified value is to be associated
<i>1447</i>&nbsp;     * @param mappingFunction the function to compute a value
<i>1448</i>&nbsp;     * @return the current (existing or computed) value associated with
<i>1449</i>&nbsp;     *         the specified key, or null if the computed value is null
<i>1450</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1451</i>&nbsp;     *         or the mappingFunction is null
<i>1452</i>&nbsp;     * @since 1.8
<i>1453</i>&nbsp;     */
<b class="nc"><i>1454</i>&nbsp;    public V computeIfAbsent(K key,</b>
<i>1455</i>&nbsp;                             Function&lt;? super K, ? extends V&gt; mappingFunction) {
<b class="nc"><i>1456</i>&nbsp;        if (key == null || mappingFunction == null)</b>
<i>1457</i>&nbsp;            throw new NullPointerException();
<i>1458</i>&nbsp;        V v, p, r;
<i>1459</i>&nbsp;        if ((v = doGet(key)) == null &amp;&amp;
<i>1460</i>&nbsp;            (r = mappingFunction.apply(key)) != null)
<i>1461</i>&nbsp;            v = (p = doPut(key, r, true)) == null ? r : p;
<i>1462</i>&nbsp;        return v;
<i>1463</i>&nbsp;    }
<i>1464</i>&nbsp;
<i>1465</i>&nbsp;    /**
<b class="nc"><i>1466</i>&nbsp;     * If the value for the specified key is present, attempts to</b>
<b class="nc"><i>1467</i>&nbsp;     * compute a new mapping given the key and its current mapped</b>
<b class="nc"><i>1468</i>&nbsp;     * value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied</b>
<b class="nc"><i>1469</i>&nbsp;     * once atomically.</b>
<b class="nc"><i>1470</i>&nbsp;     *</b>
<b class="nc"><i>1471</i>&nbsp;     * @param key key with which a value may be associated</b>
<b class="nc"><i>1472</i>&nbsp;     * @param remappingFunction the function to compute a value</b>
<b class="nc"><i>1473</i>&nbsp;     * @return the new value associated with the specified key, or null if none</b>
<b class="nc"><i>1474</i>&nbsp;     * @throws NullPointerException if the specified key is null</b>
<i>1475</i>&nbsp;     *         or the remappingFunction is null
<i>1476</i>&nbsp;     * @since 1.8
<i>1477</i>&nbsp;     */
<b class="nc"><i>1478</i>&nbsp;    public V computeIfPresent(K key,</b>
<b class="nc"><i>1479</i>&nbsp;                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</b>
<b class="nc"><i>1480</i>&nbsp;        if (key == null || remappingFunction == null)</b>
<b class="nc"><i>1481</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>1482</i>&nbsp;        Node&lt;K,V&gt; n; V v;</b>
<b class="nc"><i>1483</i>&nbsp;        while ((n = findNode(key)) != null) {</b>
<b class="nc"><i>1484</i>&nbsp;            if ((v = n.val) != null) {</b>
<b class="nc"><i>1485</i>&nbsp;                V r = remappingFunction.apply(key, v);</b>
<b class="nc"><i>1486</i>&nbsp;                if (r != null) {</b>
<b class="nc"><i>1487</i>&nbsp;                    if (VAL.compareAndSet(n, v, r))</b>
<b class="nc"><i>1488</i>&nbsp;                        return r;</b>
<i>1489</i>&nbsp;                }
<b class="nc"><i>1490</i>&nbsp;                else if (doRemove(key, v) != null)</b>
<b class="nc"><i>1491</i>&nbsp;                    break;</b>
<b class="nc"><i>1492</i>&nbsp;            }</b>
<i>1493</i>&nbsp;        }
<b class="nc"><i>1494</i>&nbsp;        return null;</b>
<b class="nc"><i>1495</i>&nbsp;    }</b>
<b class="nc"><i>1496</i>&nbsp;</b>
<b class="nc"><i>1497</i>&nbsp;    /**</b>
<b class="nc"><i>1498</i>&nbsp;     * Attempts to compute a mapping for the specified key and its</b>
<b class="nc"><i>1499</i>&nbsp;     * current mapped value (or {@code null} if there is no current</b>
<b class="nc"><i>1500</i>&nbsp;     * mapping). The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied</b>
<b class="nc"><i>1501</i>&nbsp;     * once atomically.</b>
<b class="nc"><i>1502</i>&nbsp;     *</b>
<i>1503</i>&nbsp;     * @param key key with which the specified value is to be associated
<b class="nc"><i>1504</i>&nbsp;     * @param remappingFunction the function to compute a value</b>
<b class="nc"><i>1505</i>&nbsp;     * @return the new value associated with the specified key, or null if none</b>
<b class="nc"><i>1506</i>&nbsp;     * @throws NullPointerException if the specified key is null</b>
<i>1507</i>&nbsp;     *         or the remappingFunction is null
<b class="nc"><i>1508</i>&nbsp;     * @since 1.8</b>
<i>1509</i>&nbsp;     */
<i>1510</i>&nbsp;    public V compute(K key,
<b class="nc"><i>1511</i>&nbsp;                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</b>
<b class="nc"><i>1512</i>&nbsp;        if (key == null || remappingFunction == null)</b>
<i>1513</i>&nbsp;            throw new NullPointerException();
<i>1514</i>&nbsp;        for (;;) {
<i>1515</i>&nbsp;            Node&lt;K,V&gt; n; V v; V r;
<i>1516</i>&nbsp;            if ((n = findNode(key)) == null) {
<i>1517</i>&nbsp;                if ((r = remappingFunction.apply(key, null)) == null)
<i>1518</i>&nbsp;                    break;
<i>1519</i>&nbsp;                if (doPut(key, r, true) == null)
<i>1520</i>&nbsp;                    return r;
<i>1521</i>&nbsp;            }
<i>1522</i>&nbsp;            else if ((v = n.val) != null) {
<i>1523</i>&nbsp;                if ((r = remappingFunction.apply(key, v)) != null) {
<i>1524</i>&nbsp;                    if (VAL.compareAndSet(n, v, r))
<i>1525</i>&nbsp;                        return r;
<i>1526</i>&nbsp;                }
<i>1527</i>&nbsp;                else if (doRemove(key, v) != null)
<b class="nc"><i>1528</i>&nbsp;                    break;</b>
<i>1529</i>&nbsp;            }
<i>1530</i>&nbsp;        }
<i>1531</i>&nbsp;        return null;
<i>1532</i>&nbsp;    }
<i>1533</i>&nbsp;
<i>1534</i>&nbsp;    /**
<i>1535</i>&nbsp;     * If the specified key is not already associated with a value,
<i>1536</i>&nbsp;     * associates it with the given value.  Otherwise, replaces the
<i>1537</i>&nbsp;     * value with the results of the given remapping function, or
<i>1538</i>&nbsp;     * removes if {@code null}. The function is &lt;em&gt;NOT&lt;/em&gt;
<i>1539</i>&nbsp;     * guaranteed to be applied once atomically.
<i>1540</i>&nbsp;     *
<i>1541</i>&nbsp;     * @param key key with which the specified value is to be associated
<i>1542</i>&nbsp;     * @param value the value to use if absent
<i>1543</i>&nbsp;     * @param remappingFunction the function to recompute a value if present
<i>1544</i>&nbsp;     * @return the new value associated with the specified key, or null if none
<i>1545</i>&nbsp;     * @throws NullPointerException if the specified key or value is null
<b class="nc"><i>1546</i>&nbsp;     *         or the remappingFunction is null</b>
<i>1547</i>&nbsp;     * @since 1.8
<i>1548</i>&nbsp;     */
<i>1549</i>&nbsp;    public V merge(K key, V value,
<i>1550</i>&nbsp;                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
<i>1551</i>&nbsp;        if (key == null || value == null || remappingFunction == null)
<i>1552</i>&nbsp;            throw new NullPointerException();
<i>1553</i>&nbsp;        for (;;) {
<i>1554</i>&nbsp;            Node&lt;K,V&gt; n; V v; V r;
<i>1555</i>&nbsp;            if ((n = findNode(key)) == null) {
<i>1556</i>&nbsp;                if (doPut(key, value, true) == null)
<i>1557</i>&nbsp;                    return value;
<i>1558</i>&nbsp;            }
<i>1559</i>&nbsp;            else if ((v = n.val) != null) {
<i>1560</i>&nbsp;                if ((r = remappingFunction.apply(v, value)) != null) {
<i>1561</i>&nbsp;                    if (VAL.compareAndSet(n, v, r))
<b class="nc"><i>1562</i>&nbsp;                        return r;</b>
<i>1563</i>&nbsp;                }
<i>1564</i>&nbsp;                else if (doRemove(key, v) != null)
<i>1565</i>&nbsp;                    return null;
<i>1566</i>&nbsp;            }
<i>1567</i>&nbsp;        }
<i>1568</i>&nbsp;    }
<i>1569</i>&nbsp;
<i>1570</i>&nbsp;    /* ---------------- View methods -------------- */
<i>1571</i>&nbsp;
<i>1572</i>&nbsp;    /*
<i>1573</i>&nbsp;     * Note: Lazy initialization works for views because view classes
<i>1574</i>&nbsp;     * are stateless/immutable so it doesn&#39;t matter wrt correctness if
<i>1575</i>&nbsp;     * more than one is created (which will only rarely happen).  Even
<i>1576</i>&nbsp;     * so, the following idiom conservatively ensures that the method
<i>1577</i>&nbsp;     * returns the one it created if it does so, not one created by
<i>1578</i>&nbsp;     * another racing thread.
<b class="nc"><i>1579</i>&nbsp;     */</b>
<b class="nc"><i>1580</i>&nbsp;</b>
<b class="nc"><i>1581</i>&nbsp;    /**</b>
<i>1582</i>&nbsp;     * Returns a {@link NavigableSet} view of the keys contained in this map.
<i>1583</i>&nbsp;     *
<i>1584</i>&nbsp;     * &lt;p&gt;The set&#39;s iterator returns the keys in ascending order.
<i>1585</i>&nbsp;     * The set&#39;s spliterator additionally reports {@link Spliterator#CONCURRENT},
<i>1586</i>&nbsp;     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
<i>1587</i>&nbsp;     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
<i>1588</i>&nbsp;     * key order.
<i>1589</i>&nbsp;     *
<i>1590</i>&nbsp;     * &lt;p&gt;The {@linkplain Spliterator#getComparator() spliterator&#39;s comparator}
<i>1591</i>&nbsp;     * is {@code null} if the {@linkplain #comparator() map&#39;s comparator}
<i>1592</i>&nbsp;     * is {@code null}.
<i>1593</i>&nbsp;     * Otherwise, the spliterator&#39;s comparator is the same as or imposes the
<i>1594</i>&nbsp;     * same total ordering as the map&#39;s comparator.
<b class="nc"><i>1595</i>&nbsp;     *</b>
<i>1596</i>&nbsp;     * &lt;p&gt;The set is backed by the map, so changes to the map are
<i>1597</i>&nbsp;     * reflected in the set, and vice-versa.  The set supports element
<i>1598</i>&nbsp;     * removal, which removes the corresponding mapping from the map,
<i>1599</i>&nbsp;     * via the {@code Iterator.remove}, {@code Set.remove},
<i>1600</i>&nbsp;     * {@code removeAll}, {@code retainAll}, and {@code clear}
<i>1601</i>&nbsp;     * operations.  It does not support the {@code add} or {@code addAll}
<i>1602</i>&nbsp;     * operations.
<i>1603</i>&nbsp;     *
<i>1604</i>&nbsp;     * &lt;p&gt;The view&#39;s iterators and spliterators are
<i>1605</i>&nbsp;     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
<i>1606</i>&nbsp;     *
<i>1607</i>&nbsp;     * &lt;p&gt;This method is equivalent to method {@code navigableKeySet}.
<i>1608</i>&nbsp;     *
<i>1609</i>&nbsp;     * @return a navigable set view of the keys in this map
<i>1610</i>&nbsp;     */
<b class="nc"><i>1611</i>&nbsp;    public NavigableSet&lt;K&gt; keySet() {</b>
<b class="nc"><i>1612</i>&nbsp;        KeySet&lt;K,V&gt; ks;</b>
<b class="nc"><i>1613</i>&nbsp;        if ((ks = keySet) != null) return ks;</b>
<b class="nc"><i>1614</i>&nbsp;        return keySet = new KeySet&lt;&gt;(this);</b>
<b class="nc"><i>1615</i>&nbsp;    }</b>
<b class="nc"><i>1616</i>&nbsp;</b>
<i>1617</i>&nbsp;    public NavigableSet&lt;K&gt; navigableKeySet() {
<b class="nc"><i>1618</i>&nbsp;        KeySet&lt;K,V&gt; ks;</b>
<i>1619</i>&nbsp;        if ((ks = keySet) != null) return ks;
<i>1620</i>&nbsp;        return keySet = new KeySet&lt;&gt;(this);
<i>1621</i>&nbsp;    }
<i>1622</i>&nbsp;
<i>1623</i>&nbsp;    /**
<i>1624</i>&nbsp;     * Returns a {@link Collection} view of the values contained in this map.
<i>1625</i>&nbsp;     * &lt;p&gt;The collection&#39;s iterator returns the values in ascending order
<i>1626</i>&nbsp;     * of the corresponding keys. The collections&#39;s spliterator additionally
<i>1627</i>&nbsp;     * reports {@link Spliterator#CONCURRENT}, {@link Spliterator#NONNULL} and
<i>1628</i>&nbsp;     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
<i>1629</i>&nbsp;     * order of the corresponding keys.
<i>1630</i>&nbsp;     *
<i>1631</i>&nbsp;     * &lt;p&gt;The collection is backed by the map, so changes to the map are
<i>1632</i>&nbsp;     * reflected in the collection, and vice-versa.  The collection
<i>1633</i>&nbsp;     * supports element removal, which removes the corresponding
<i>1634</i>&nbsp;     * mapping from the map, via the {@code Iterator.remove},
<i>1635</i>&nbsp;     * {@code Collection.remove}, {@code removeAll},
<i>1636</i>&nbsp;     * {@code retainAll} and {@code clear} operations.  It does not
<i>1637</i>&nbsp;     * support the {@code add} or {@code addAll} operations.
<b class="nc"><i>1638</i>&nbsp;     *</b>
<b class="nc"><i>1639</i>&nbsp;     * &lt;p&gt;The view&#39;s iterators and spliterators are</b>
<b class="nc"><i>1640</i>&nbsp;     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.</b>
<b class="nc"><i>1641</i>&nbsp;     */</b>
<i>1642</i>&nbsp;    public Collection&lt;V&gt; values() {
<b class="nc"><i>1643</i>&nbsp;        Values&lt;K,V&gt; vs;</b>
<i>1644</i>&nbsp;        if ((vs = values) != null) return vs;
<i>1645</i>&nbsp;        return values = new Values&lt;&gt;(this);
<i>1646</i>&nbsp;    }
<i>1647</i>&nbsp;
<i>1648</i>&nbsp;    /**
<i>1649</i>&nbsp;     * Returns a {@link Set} view of the mappings contained in this map.
<i>1650</i>&nbsp;     *
<b class="nc"><i>1651</i>&nbsp;     * &lt;p&gt;The set&#39;s iterator returns the entries in ascending key order.  The</b>
<i>1652</i>&nbsp;     * set&#39;s spliterator additionally reports {@link Spliterator#CONCURRENT},
<i>1653</i>&nbsp;     * {@link Spliterator#NONNULL}, {@link Spliterator#SORTED} and
<i>1654</i>&nbsp;     * {@link Spliterator#ORDERED}, with an encounter order that is ascending
<i>1655</i>&nbsp;     * key order.
<i>1656</i>&nbsp;     *
<i>1657</i>&nbsp;     * &lt;p&gt;The set is backed by the map, so changes to the map are
<b class="nc"><i>1658</i>&nbsp;     * reflected in the set, and vice-versa.  The set supports element</b>
<i>1659</i>&nbsp;     * removal, which removes the corresponding mapping from the map,
<i>1660</i>&nbsp;     * via the {@code Iterator.remove}, {@code Set.remove},
<i>1661</i>&nbsp;     * {@code removeAll}, {@code retainAll} and {@code clear}
<i>1662</i>&nbsp;     * operations.  It does not support the {@code add} or
<i>1663</i>&nbsp;     * {@code addAll} operations.
<i>1664</i>&nbsp;     *
<i>1665</i>&nbsp;     * &lt;p&gt;The view&#39;s iterators and spliterators are
<i>1666</i>&nbsp;     * &lt;a href=&quot;package-summary.html#Weakly&quot;&gt;&lt;i&gt;weakly consistent&lt;/i&gt;&lt;/a&gt;.
<i>1667</i>&nbsp;     *
<i>1668</i>&nbsp;     * &lt;p&gt;The {@code Map.Entry} elements traversed by the {@code iterator}
<i>1669</i>&nbsp;     * or {@code spliterator} do &lt;em&gt;not&lt;/em&gt; support the {@code setValue}
<i>1670</i>&nbsp;     * operation.
<i>1671</i>&nbsp;     *
<i>1672</i>&nbsp;     * @return a set view of the mappings contained in this map,
<i>1673</i>&nbsp;     *         sorted in ascending key order
<i>1674</i>&nbsp;     */
<i>1675</i>&nbsp;    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
<i>1676</i>&nbsp;        EntrySet&lt;K,V&gt; es;
<i>1677</i>&nbsp;        if ((es = entrySet) != null) return es;
<b class="nc"><i>1678</i>&nbsp;        return entrySet = new EntrySet&lt;K,V&gt;(this);</b>
<b class="nc"><i>1679</i>&nbsp;    }</b>
<i>1680</i>&nbsp;
<b class="nc"><i>1681</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; descendingMap() {</b>
<b class="nc"><i>1682</i>&nbsp;        ConcurrentNavigableMap&lt;K,V&gt; dm;</b>
<b class="nc"><i>1683</i>&nbsp;        if ((dm = descendingMap) != null) return dm;</b>
<b class="nc"><i>1684</i>&nbsp;        return descendingMap =</b>
<i>1685</i>&nbsp;            new SubMap&lt;K,V&gt;(this, null, false, null, false, true);
<i>1686</i>&nbsp;    }
<i>1687</i>&nbsp;
<i>1688</i>&nbsp;    public NavigableSet&lt;K&gt; descendingKeySet() {
<i>1689</i>&nbsp;        return descendingMap().navigableKeySet();
<i>1690</i>&nbsp;    }
<i>1691</i>&nbsp;
<i>1692</i>&nbsp;    /* ---------------- AbstractMap Overrides -------------- */
<i>1693</i>&nbsp;
<i>1694</i>&nbsp;    /**
<i>1695</i>&nbsp;     * Compares the specified object with this map for equality.
<i>1696</i>&nbsp;     * Returns {@code true} if the given object is also a map and the
<i>1697</i>&nbsp;     * two maps represent the same mappings.  More formally, two maps
<i>1698</i>&nbsp;     * {@code m1} and {@code m2} represent the same mappings if
<i>1699</i>&nbsp;     * {@code m1.entrySet().equals(m2.entrySet())}.  This
<i>1700</i>&nbsp;     * operation may return misleading results if either map is
<i>1701</i>&nbsp;     * concurrently modified during execution of this method.
<b class="nc"><i>1702</i>&nbsp;     *</b>
<b class="nc"><i>1703</i>&nbsp;     * @param o object to be compared for equality with this map</b>
<i>1704</i>&nbsp;     * @return {@code true} if the specified object is equal to this map
<b class="nc"><i>1705</i>&nbsp;     */</b>
<b class="nc"><i>1706</i>&nbsp;    public boolean equals(Object o) {</b>
<b class="nc"><i>1707</i>&nbsp;        if (o == this)</b>
<b class="nc"><i>1708</i>&nbsp;            return true;</b>
<b class="nc"><i>1709</i>&nbsp;        if (!(o instanceof Map))</b>
<b class="nc"><i>1710</i>&nbsp;            return false;</b>
<b class="nc"><i>1711</i>&nbsp;        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</b>
<i>1712</i>&nbsp;        try {
<b class="nc"><i>1713</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<b class="nc"><i>1714</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>1715</i>&nbsp;            Iterator&lt;Map.Entry&lt;?,?&gt;&gt; it =</b>
<i>1716</i>&nbsp;                (Iterator&lt;Map.Entry&lt;?,?&gt;&gt;)m.entrySet().iterator();
<b class="nc"><i>1717</i>&nbsp;            if (m instanceof SortedMap &amp;&amp;</b>
<i>1718</i>&nbsp;                ((SortedMap&lt;?,?&gt;)m).comparator() == cmp) {
<i>1719</i>&nbsp;                Node&lt;K,V&gt; b, n;
<i>1720</i>&nbsp;                if ((b = baseHead()) != null) {
<i>1721</i>&nbsp;                    while ((n = b.next) != null) {
<i>1722</i>&nbsp;                        K k; V v;
<i>1723</i>&nbsp;                        if ((v = n.val) != null &amp;&amp; (k = n.key) != null) {
<i>1724</i>&nbsp;                            if (!it.hasNext())
<i>1725</i>&nbsp;                                return false;
<i>1726</i>&nbsp;                            Map.Entry&lt;?,?&gt; e = it.next();
<i>1727</i>&nbsp;                            Object mk = e.getKey();
<i>1728</i>&nbsp;                            Object mv = e.getValue();
<i>1729</i>&nbsp;                            if (mk == null || mv == null)
<i>1730</i>&nbsp;                                return false;
<i>1731</i>&nbsp;                            try {
<i>1732</i>&nbsp;                                if (cpr(cmp, k, mk) != 0)
<i>1733</i>&nbsp;                                    return false;
<i>1734</i>&nbsp;                            } catch (ClassCastException cce) {
<b class="nc"><i>1735</i>&nbsp;                                return false;</b>
<b class="nc"><i>1736</i>&nbsp;                            }</b>
<i>1737</i>&nbsp;                            if (!mv.equals(v))
<i>1738</i>&nbsp;                                return false;
<b class="nc"><i>1739</i>&nbsp;                        }</b>
<b class="nc"><i>1740</i>&nbsp;                        b = n;</b>
<b class="nc"><i>1741</i>&nbsp;                    }</b>
<b class="nc"><i>1742</i>&nbsp;                }</b>
<b class="nc"><i>1743</i>&nbsp;                return !it.hasNext();</b>
<i>1744</i>&nbsp;            }
<b class="nc"><i>1745</i>&nbsp;            else {</b>
<b class="nc"><i>1746</i>&nbsp;                while (it.hasNext()) {</b>
<b class="nc"><i>1747</i>&nbsp;                    V v;</b>
<b class="nc"><i>1748</i>&nbsp;                    Map.Entry&lt;?,?&gt; e = it.next();</b>
<b class="nc"><i>1749</i>&nbsp;                    Object mk = e.getKey();</b>
<i>1750</i>&nbsp;                    Object mv = e.getValue();
<b class="nc"><i>1751</i>&nbsp;                    if (mk == null || mv == null ||</b>
<b class="nc"><i>1752</i>&nbsp;                        (v = get(mk)) == null || !v.equals(mv))</b>
<i>1753</i>&nbsp;                        return false;
<b class="nc"><i>1754</i>&nbsp;                }</b>
<b class="nc"><i>1755</i>&nbsp;                Node&lt;K,V&gt; b, n;</b>
<i>1756</i>&nbsp;                if ((b = baseHead()) != null) {
<i>1757</i>&nbsp;                    K k; V v; Object mv;
<i>1758</i>&nbsp;                    while ((n = b.next) != null) {
<i>1759</i>&nbsp;                        if ((v = n.val) != null &amp;&amp; (k = n.key) != null &amp;&amp;
<i>1760</i>&nbsp;                            ((mv = m.get(k)) == null || !mv.equals(v)))
<i>1761</i>&nbsp;                            return false;
<i>1762</i>&nbsp;                        b = n;
<i>1763</i>&nbsp;                    }
<i>1764</i>&nbsp;                }
<i>1765</i>&nbsp;                return true;
<i>1766</i>&nbsp;            }
<i>1767</i>&nbsp;        } catch (ClassCastException | NullPointerException unused) {
<i>1768</i>&nbsp;            return false;
<i>1769</i>&nbsp;        }
<i>1770</i>&nbsp;    }
<i>1771</i>&nbsp;
<i>1772</i>&nbsp;    /* ------ ConcurrentMap API methods ------ */
<i>1773</i>&nbsp;
<i>1774</i>&nbsp;    /**
<b class="nc"><i>1775</i>&nbsp;     * {@inheritDoc}</b>
<b class="nc"><i>1776</i>&nbsp;     *</b>
<i>1777</i>&nbsp;     * @return the previous value associated with the specified key,
<i>1778</i>&nbsp;     *         or {@code null} if there was no mapping for the key
<b class="nc"><i>1779</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared</b>
<b class="nc"><i>1780</i>&nbsp;     *         with the keys currently in the map</b>
<b class="nc"><i>1781</i>&nbsp;     * @throws NullPointerException if the specified key or value is null</b>
<i>1782</i>&nbsp;     */
<b class="nc"><i>1783</i>&nbsp;    public V putIfAbsent(K key, V value) {</b>
<b class="nc"><i>1784</i>&nbsp;        if (value == null)</b>
<b class="nc"><i>1785</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>1786</i>&nbsp;        return doPut(key, value, true);</b>
<b class="nc"><i>1787</i>&nbsp;    }</b>
<i>1788</i>&nbsp;
<b class="nc"><i>1789</i>&nbsp;    /**</b>
<b class="nc"><i>1790</i>&nbsp;     * {@inheritDoc}</b>
<i>1791</i>&nbsp;     *
<b class="nc"><i>1792</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared</b>
<i>1793</i>&nbsp;     *         with the keys currently in the map
<i>1794</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1795</i>&nbsp;     */
<i>1796</i>&nbsp;    public boolean remove(Object key, Object value) {
<i>1797</i>&nbsp;        if (key == null)
<i>1798</i>&nbsp;            throw new NullPointerException();
<i>1799</i>&nbsp;        return value != null &amp;&amp; doRemove(key, value) != null;
<i>1800</i>&nbsp;    }
<i>1801</i>&nbsp;
<i>1802</i>&nbsp;    /**
<i>1803</i>&nbsp;     * {@inheritDoc}
<i>1804</i>&nbsp;     *
<i>1805</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1806</i>&nbsp;     *         with the keys currently in the map
<i>1807</i>&nbsp;     * @throws NullPointerException if any of the arguments are null
<i>1808</i>&nbsp;     */
<i>1809</i>&nbsp;    public boolean replace(K key, V oldValue, V newValue) {
<i>1810</i>&nbsp;        if (key == null || oldValue == null || newValue == null)
<i>1811</i>&nbsp;            throw new NullPointerException();
<i>1812</i>&nbsp;        for (;;) {
<i>1813</i>&nbsp;            Node&lt;K,V&gt; n; V v;
<i>1814</i>&nbsp;            if ((n = findNode(key)) == null)
<i>1815</i>&nbsp;                return false;
<i>1816</i>&nbsp;            if ((v = n.val) != null) {
<i>1817</i>&nbsp;                if (!oldValue.equals(v))
<i>1818</i>&nbsp;                    return false;
<i>1819</i>&nbsp;                if (VAL.compareAndSet(n, v, newValue))
<i>1820</i>&nbsp;                    return true;
<i>1821</i>&nbsp;            }
<i>1822</i>&nbsp;        }
<i>1823</i>&nbsp;    }
<i>1824</i>&nbsp;
<i>1825</i>&nbsp;    /**
<i>1826</i>&nbsp;     * {@inheritDoc}
<i>1827</i>&nbsp;     *
<i>1828</i>&nbsp;     * @return the previous value associated with the specified key,
<i>1829</i>&nbsp;     *         or {@code null} if there was no mapping for the key
<i>1830</i>&nbsp;     * @throws ClassCastException if the specified key cannot be compared
<i>1831</i>&nbsp;     *         with the keys currently in the map
<i>1832</i>&nbsp;     * @throws NullPointerException if the specified key or value is null
<i>1833</i>&nbsp;     */
<i>1834</i>&nbsp;    public V replace(K key, V value) {
<b class="nc"><i>1835</i>&nbsp;        if (key == null || value == null)</b>
<b class="nc"><i>1836</i>&nbsp;            throw new NullPointerException();</b>
<i>1837</i>&nbsp;        for (;;) {
<i>1838</i>&nbsp;            Node&lt;K,V&gt; n; V v;
<i>1839</i>&nbsp;            if ((n = findNode(key)) == null)
<b class="nc"><i>1840</i>&nbsp;                return null;</b>
<b class="nc"><i>1841</i>&nbsp;            if ((v = n.val) != null &amp;&amp; VAL.compareAndSet(n, v, value))</b>
<i>1842</i>&nbsp;                return v;
<i>1843</i>&nbsp;        }
<i>1844</i>&nbsp;    }
<i>1845</i>&nbsp;
<i>1846</i>&nbsp;    /* ------ SortedMap API methods ------ */
<i>1847</i>&nbsp;
<i>1848</i>&nbsp;    public Comparator&lt;? super K&gt; comparator() {
<i>1849</i>&nbsp;        return comparator;
<i>1850</i>&nbsp;    }
<i>1851</i>&nbsp;
<i>1852</i>&nbsp;    /**
<i>1853</i>&nbsp;     * @throws NoSuchElementException {@inheritDoc}
<i>1854</i>&nbsp;     */
<i>1855</i>&nbsp;    public K firstKey() {
<i>1856</i>&nbsp;        Node&lt;K,V&gt; n = findFirst();
<i>1857</i>&nbsp;        if (n == null)
<i>1858</i>&nbsp;            throw new NoSuchElementException();
<i>1859</i>&nbsp;        return n.key;
<i>1860</i>&nbsp;    }
<i>1861</i>&nbsp;
<i>1862</i>&nbsp;    /**
<i>1863</i>&nbsp;     * @throws NoSuchElementException {@inheritDoc}
<b class="nc"><i>1864</i>&nbsp;     */</b>
<b class="nc"><i>1865</i>&nbsp;    public K lastKey() {</b>
<i>1866</i>&nbsp;        Node&lt;K,V&gt; n = findLast();
<i>1867</i>&nbsp;        if (n == null)
<i>1868</i>&nbsp;            throw new NoSuchElementException();
<i>1869</i>&nbsp;        return n.key;
<i>1870</i>&nbsp;    }
<i>1871</i>&nbsp;
<i>1872</i>&nbsp;    /**
<i>1873</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1874</i>&nbsp;     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
<i>1875</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}
<i>1876</i>&nbsp;     */
<i>1877</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey,
<i>1878</i>&nbsp;                                              boolean fromInclusive,
<i>1879</i>&nbsp;                                              K toKey,
<i>1880</i>&nbsp;                                              boolean toInclusive) {
<i>1881</i>&nbsp;        if (fromKey == null || toKey == null)
<i>1882</i>&nbsp;            throw new NullPointerException();
<i>1883</i>&nbsp;        return new SubMap&lt;K,V&gt;
<i>1884</i>&nbsp;            (this, fromKey, fromInclusive, toKey, toInclusive, false);
<i>1885</i>&nbsp;    }
<i>1886</i>&nbsp;
<i>1887</i>&nbsp;    /**
<i>1888</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1889</i>&nbsp;     * @throws NullPointerException if {@code toKey} is null
<i>1890</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}
<i>1891</i>&nbsp;     */
<i>1892</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey,
<i>1893</i>&nbsp;                                               boolean inclusive) {
<i>1894</i>&nbsp;        if (toKey == null)
<i>1895</i>&nbsp;            throw new NullPointerException();
<b class="nc"><i>1896</i>&nbsp;        return new SubMap&lt;K,V&gt;</b>
<b class="nc"><i>1897</i>&nbsp;            (this, null, false, toKey, inclusive, false);</b>
<i>1898</i>&nbsp;    }
<i>1899</i>&nbsp;
<i>1900</i>&nbsp;    /**
<b class="nc"><i>1901</i>&nbsp;     * @throws ClassCastException {@inheritDoc}</b>
<b class="nc"><i>1902</i>&nbsp;     * @throws NullPointerException if {@code fromKey} is null</b>
<i>1903</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}
<i>1904</i>&nbsp;     */
<i>1905</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey,
<i>1906</i>&nbsp;                                               boolean inclusive) {
<b class="nc"><i>1907</i>&nbsp;        if (fromKey == null)</b>
<i>1908</i>&nbsp;            throw new NullPointerException();
<i>1909</i>&nbsp;        return new SubMap&lt;K,V&gt;
<i>1910</i>&nbsp;            (this, fromKey, inclusive, null, false, false);
<i>1911</i>&nbsp;    }
<i>1912</i>&nbsp;
<i>1913</i>&nbsp;    /**
<i>1914</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1915</i>&nbsp;     * @throws NullPointerException if {@code fromKey} or {@code toKey} is null
<i>1916</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}
<i>1917</i>&nbsp;     */
<i>1918</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
<i>1919</i>&nbsp;        return subMap(fromKey, true, toKey, false);
<i>1920</i>&nbsp;    }
<i>1921</i>&nbsp;
<i>1922</i>&nbsp;    /**
<i>1923</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1924</i>&nbsp;     * @throws NullPointerException if {@code toKey} is null
<b class="nc"><i>1925</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}</b>
<b class="nc"><i>1926</i>&nbsp;     */</b>
<b class="nc"><i>1927</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; headMap(K toKey) {</b>
<b class="nc"><i>1928</i>&nbsp;        return headMap(toKey, false);</b>
<b class="nc"><i>1929</i>&nbsp;    }</b>
<i>1930</i>&nbsp;
<b class="nc"><i>1931</i>&nbsp;    /**</b>
<b class="nc"><i>1932</i>&nbsp;     * @throws ClassCastException {@inheritDoc}</b>
<b class="nc"><i>1933</i>&nbsp;     * @throws NullPointerException if {@code fromKey} is null</b>
<b class="nc"><i>1934</i>&nbsp;     * @throws IllegalArgumentException {@inheritDoc}</b>
<b class="nc"><i>1935</i>&nbsp;     */</b>
<b class="nc"><i>1936</i>&nbsp;    public ConcurrentNavigableMap&lt;K,V&gt; tailMap(K fromKey) {</b>
<b class="nc"><i>1937</i>&nbsp;        return tailMap(fromKey, true);</b>
<b class="nc"><i>1938</i>&nbsp;    }</b>
<b class="nc"><i>1939</i>&nbsp;</b>
<b class="nc"><i>1940</i>&nbsp;    /* ---------------- Relational operations -------------- */</b>
<b class="nc"><i>1941</i>&nbsp;</b>
<b class="nc"><i>1942</i>&nbsp;    /**</b>
<b class="nc"><i>1943</i>&nbsp;     * Returns a key-value mapping associated with the greatest key</b>
<b class="nc"><i>1944</i>&nbsp;     * strictly less than the given key, or {@code null} if there is</b>
<i>1945</i>&nbsp;     * no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support the
<i>1946</i>&nbsp;     * {@code Entry.setValue} method.
<i>1947</i>&nbsp;     *
<i>1948</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1949</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1950</i>&nbsp;     */
<i>1951</i>&nbsp;    public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<i>1952</i>&nbsp;        return findNearEntry(key, LT, comparator);
<i>1953</i>&nbsp;    }
<i>1954</i>&nbsp;
<i>1955</i>&nbsp;    /**
<i>1956</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1957</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1958</i>&nbsp;     */
<i>1959</i>&nbsp;    public K lowerKey(K key) {
<b class="nc"><i>1960</i>&nbsp;        Node&lt;K,V&gt; n = findNear(key, LT, comparator);</b>
<b class="nc"><i>1961</i>&nbsp;        return (n == null) ? null : n.key;</b>
<b class="nc"><i>1962</i>&nbsp;    }</b>
<i>1963</i>&nbsp;
<i>1964</i>&nbsp;    /**
<i>1965</i>&nbsp;     * Returns a key-value mapping associated with the greatest key
<i>1966</i>&nbsp;     * less than or equal to the given key, or {@code null} if there
<i>1967</i>&nbsp;     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
<i>1968</i>&nbsp;     * the {@code Entry.setValue} method.
<i>1969</i>&nbsp;     *
<i>1970</i>&nbsp;     * @param key the key
<i>1971</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1972</i>&nbsp;     * @throws NullPointerException if the specified key is null
<b class="nc"><i>1973</i>&nbsp;     */</b>
<b class="nc"><i>1974</i>&nbsp;    public Map.Entry&lt;K,V&gt; floorEntry(K key) {</b>
<b class="nc"><i>1975</i>&nbsp;        return findNearEntry(key, LT|EQ, comparator);</b>
<i>1976</i>&nbsp;    }
<i>1977</i>&nbsp;
<i>1978</i>&nbsp;    /**
<i>1979</i>&nbsp;     * @param key the key
<i>1980</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>1981</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>1982</i>&nbsp;     */
<i>1983</i>&nbsp;    public K floorKey(K key) {
<i>1984</i>&nbsp;        Node&lt;K,V&gt; n = findNear(key, LT|EQ, comparator);
<i>1985</i>&nbsp;        return (n == null) ? null : n.key;
<b class="nc"><i>1986</i>&nbsp;    }</b>
<b class="nc"><i>1987</i>&nbsp;</b>
<i>1988</i>&nbsp;    /**
<i>1989</i>&nbsp;     * Returns a key-value mapping associated with the least key
<b class="nc"><i>1990</i>&nbsp;     * greater than or equal to the given key, or {@code null} if</b>
<b class="nc"><i>1991</i>&nbsp;     * there is no such entry. The returned entry does &lt;em&gt;not&lt;/em&gt;</b>
<b class="nc"><i>1992</i>&nbsp;     * support the {@code Entry.setValue} method.</b>
<b class="nc"><i>1993</i>&nbsp;     *</b>
<b class="nc"><i>1994</i>&nbsp;     * @throws ClassCastException {@inheritDoc}</b>
<b class="nc"><i>1995</i>&nbsp;     * @throws NullPointerException if the specified key is null</b>
<b class="nc"><i>1996</i>&nbsp;     */</b>
<i>1997</i>&nbsp;    public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<b class="nc"><i>1998</i>&nbsp;        return findNearEntry(key, GT|EQ, comparator);</b>
<i>1999</i>&nbsp;    }
<i>2000</i>&nbsp;
<i>2001</i>&nbsp;    /**
<i>2002</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<i>2003</i>&nbsp;     * @throws NullPointerException if the specified key is null
<i>2004</i>&nbsp;     */
<i>2005</i>&nbsp;    public K ceilingKey(K key) {
<i>2006</i>&nbsp;        Node&lt;K,V&gt; n = findNear(key, GT|EQ, comparator);
<i>2007</i>&nbsp;        return (n == null) ? null : n.key;
<i>2008</i>&nbsp;    }
<i>2009</i>&nbsp;
<i>2010</i>&nbsp;    /**
<b class="nc"><i>2011</i>&nbsp;     * Returns a key-value mapping associated with the least key</b>
<b class="nc"><i>2012</i>&nbsp;     * strictly greater than the given key, or {@code null} if there</b>
<i>2013</i>&nbsp;     * is no such key. The returned entry does &lt;em&gt;not&lt;/em&gt; support
<i>2014</i>&nbsp;     * the {@code Entry.setValue} method.
<b class="nc"><i>2015</i>&nbsp;     *</b>
<b class="nc"><i>2016</i>&nbsp;     * @param key the key</b>
<b class="nc"><i>2017</i>&nbsp;     * @throws ClassCastException {@inheritDoc}</b>
<b class="nc"><i>2018</i>&nbsp;     * @throws NullPointerException if the specified key is null</b>
<b class="nc"><i>2019</i>&nbsp;     */</b>
<i>2020</i>&nbsp;    public Map.Entry&lt;K,V&gt; higherEntry(K key) {
<b class="nc"><i>2021</i>&nbsp;        return findNearEntry(key, GT, comparator);</b>
<i>2022</i>&nbsp;    }
<i>2023</i>&nbsp;
<i>2024</i>&nbsp;    /**
<i>2025</i>&nbsp;     * @param key the key
<i>2026</i>&nbsp;     * @throws ClassCastException {@inheritDoc}
<b class="nc"><i>2027</i>&nbsp;     * @throws NullPointerException if the specified key is null</b>
<i>2028</i>&nbsp;     */
<i>2029</i>&nbsp;    public K higherKey(K key) {
<i>2030</i>&nbsp;        Node&lt;K,V&gt; n = findNear(key, GT, comparator);
<i>2031</i>&nbsp;        return (n == null) ? null : n.key;
<i>2032</i>&nbsp;    }
<i>2033</i>&nbsp;
<b class="nc"><i>2034</i>&nbsp;    /**</b>
<b class="nc"><i>2035</i>&nbsp;     * Returns a key-value mapping associated with the least</b>
<b class="nc"><i>2036</i>&nbsp;     * key in this map, or {@code null} if the map is empty.</b>
<b class="nc"><i>2037</i>&nbsp;     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</b>
<i>2038</i>&nbsp;     * the {@code Entry.setValue} method.
<i>2039</i>&nbsp;     */
<i>2040</i>&nbsp;    public Map.Entry&lt;K,V&gt; firstEntry() {
<i>2041</i>&nbsp;        return findFirstEntry();
<i>2042</i>&nbsp;    }
<i>2043</i>&nbsp;
<b class="nc"><i>2044</i>&nbsp;    /**</b>
<b class="nc"><i>2045</i>&nbsp;     * Returns a key-value mapping associated with the greatest</b>
<b class="nc"><i>2046</i>&nbsp;     * key in this map, or {@code null} if the map is empty.</b>
<b class="nc"><i>2047</i>&nbsp;     * The returned entry does &lt;em&gt;not&lt;/em&gt; support</b>
<i>2048</i>&nbsp;     * the {@code Entry.setValue} method.
<i>2049</i>&nbsp;     */
<i>2050</i>&nbsp;    public Map.Entry&lt;K,V&gt; lastEntry() {
<i>2051</i>&nbsp;        return findLastEntry();
<i>2052</i>&nbsp;    }
<i>2053</i>&nbsp;
<i>2054</i>&nbsp;    /**
<i>2055</i>&nbsp;     * Removes and returns a key-value mapping associated with
<i>2056</i>&nbsp;     * the least key in this map, or {@code null} if the map is empty.
<i>2057</i>&nbsp;     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
<i>2058</i>&nbsp;     * the {@code Entry.setValue} method.
<b class="nc"><i>2059</i>&nbsp;     */</b>
<b class="nc"><i>2060</i>&nbsp;    public Map.Entry&lt;K,V&gt; pollFirstEntry() {</b>
<b class="nc"><i>2061</i>&nbsp;        return doRemoveFirstEntry();</b>
<i>2062</i>&nbsp;    }
<i>2063</i>&nbsp;
<i>2064</i>&nbsp;    /**
<i>2065</i>&nbsp;     * Removes and returns a key-value mapping associated with
<i>2066</i>&nbsp;     * the greatest key in this map, or {@code null} if the map is empty.
<i>2067</i>&nbsp;     * The returned entry does &lt;em&gt;not&lt;/em&gt; support
<i>2068</i>&nbsp;     * the {@code Entry.setValue} method.
<i>2069</i>&nbsp;     */
<i>2070</i>&nbsp;    public Map.Entry&lt;K,V&gt; pollLastEntry() {
<i>2071</i>&nbsp;        return doRemoveLastEntry();
<b class="nc"><i>2072</i>&nbsp;    }</b>
<b class="nc"><i>2073</i>&nbsp;</b>
<b class="nc"><i>2074</i>&nbsp;    /* ---------------- Iterators -------------- */</b>
<i>2075</i>&nbsp;
<i>2076</i>&nbsp;    /**
<i>2077</i>&nbsp;     * Base of iterator classes
<i>2078</i>&nbsp;     */
<i>2079</i>&nbsp;    abstract class Iter&lt;T&gt; implements Iterator&lt;T&gt; {
<i>2080</i>&nbsp;        /** the last node returned by next() */
<i>2081</i>&nbsp;        Node&lt;K,V&gt; lastReturned;
<i>2082</i>&nbsp;        /** the next node to return from next(); */
<i>2083</i>&nbsp;        Node&lt;K,V&gt; next;
<i>2084</i>&nbsp;        /** Cache of next value field to maintain weak consistency */
<b class="nc"><i>2085</i>&nbsp;        V nextValue;</b>
<b class="nc"><i>2086</i>&nbsp;</b>
<b class="nc"><i>2087</i>&nbsp;        /** Initializes ascending iterator for entire range. */</b>
<i>2088</i>&nbsp;        Iter() {
<i>2089</i>&nbsp;            advance(baseHead());
<i>2090</i>&nbsp;        }
<i>2091</i>&nbsp;
<i>2092</i>&nbsp;        public final boolean hasNext() {
<i>2093</i>&nbsp;            return next != null;
<i>2094</i>&nbsp;        }
<i>2095</i>&nbsp;
<i>2096</i>&nbsp;        /** Advances next to higher entry. */
<b class="nc"><i>2097</i>&nbsp;        final void advance(Node&lt;K,V&gt; b) {</b>
<i>2098</i>&nbsp;            Node&lt;K,V&gt; n = null;
<i>2099</i>&nbsp;            V v = null;
<i>2100</i>&nbsp;            if ((lastReturned = b) != null) {
<i>2101</i>&nbsp;                while ((n = b.next) != null &amp;&amp; (v = n.val) == null)
<i>2102</i>&nbsp;                    b = n;
<i>2103</i>&nbsp;            }
<i>2104</i>&nbsp;            nextValue = v;
<i>2105</i>&nbsp;            next = n;
<b class="nc"><i>2106</i>&nbsp;        }</b>
<i>2107</i>&nbsp;
<i>2108</i>&nbsp;        public final void remove() {
<i>2109</i>&nbsp;            Node&lt;K,V&gt; n; K k;
<i>2110</i>&nbsp;            if ((n = lastReturned) == null || (k = n.key) == null)
<i>2111</i>&nbsp;                throw new IllegalStateException();
<i>2112</i>&nbsp;            // It would not be worth all of the overhead to directly
<i>2113</i>&nbsp;            // unlink from here. Using remove is fast enough.
<i>2114</i>&nbsp;            ConcurrentSkipListMap.this.remove(k);
<b class="nc"><i>2115</i>&nbsp;            lastReturned = null;</b>
<i>2116</i>&nbsp;        }
<i>2117</i>&nbsp;    }
<i>2118</i>&nbsp;
<i>2119</i>&nbsp;    final class ValueIterator extends Iter&lt;V&gt; {
<i>2120</i>&nbsp;        public V next() {
<i>2121</i>&nbsp;            V v;
<i>2122</i>&nbsp;            if ((v = nextValue) == null)
<i>2123</i>&nbsp;                throw new NoSuchElementException();
<i>2124</i>&nbsp;            advance(next);
<i>2125</i>&nbsp;            return v;
<i>2126</i>&nbsp;        }
<i>2127</i>&nbsp;    }
<i>2128</i>&nbsp;
<i>2129</i>&nbsp;    final class KeyIterator extends Iter&lt;K&gt; {
<b class="nc"><i>2130</i>&nbsp;        public K next() {</b>
<i>2131</i>&nbsp;            Node&lt;K,V&gt; n;
<i>2132</i>&nbsp;            if ((n = next) == null)
<i>2133</i>&nbsp;                throw new NoSuchElementException();
<i>2134</i>&nbsp;            K k = n.key;
<i>2135</i>&nbsp;            advance(n);
<i>2136</i>&nbsp;            return k;
<i>2137</i>&nbsp;        }
<b class="nc"><i>2138</i>&nbsp;    }</b>
<b class="nc"><i>2139</i>&nbsp;</b>
<i>2140</i>&nbsp;    final class EntryIterator extends Iter&lt;Map.Entry&lt;K,V&gt;&gt; {
<i>2141</i>&nbsp;        public Map.Entry&lt;K,V&gt; next() {
<i>2142</i>&nbsp;            Node&lt;K,V&gt; n;
<i>2143</i>&nbsp;            if ((n = next) == null)
<i>2144</i>&nbsp;                throw new NoSuchElementException();
<i>2145</i>&nbsp;            K k = n.key;
<i>2146</i>&nbsp;            V v = nextValue;
<i>2147</i>&nbsp;            advance(n);
<i>2148</i>&nbsp;            return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
<i>2149</i>&nbsp;        }
<i>2150</i>&nbsp;    }
<i>2151</i>&nbsp;
<i>2152</i>&nbsp;    /* ---------------- View Classes -------------- */
<b class="nc"><i>2153</i>&nbsp;</b>
<i>2154</i>&nbsp;    /*
<i>2155</i>&nbsp;     * View classes are static, delegating to a ConcurrentNavigableMap
<i>2156</i>&nbsp;     * to allow use by SubMaps, which outweighs the ugliness of
<i>2157</i>&nbsp;     * needing type-tests for Iterator methods.
<i>2158</i>&nbsp;     */
<i>2159</i>&nbsp;
<i>2160</i>&nbsp;    static final &lt;E&gt; List&lt;E&gt; toList(Collection&lt;E&gt; c) {
<i>2161</i>&nbsp;        // Using size() here would be a pessimization.
<b class="nc"><i>2162</i>&nbsp;        ArrayList&lt;E&gt; list = new ArrayList&lt;E&gt;();</b>
<b class="nc"><i>2163</i>&nbsp;        for (E e : c)</b>
<i>2164</i>&nbsp;            list.add(e);
<i>2165</i>&nbsp;        return list;
<i>2166</i>&nbsp;    }
<i>2167</i>&nbsp;
<i>2168</i>&nbsp;    static final class KeySet&lt;K,V&gt;
<i>2169</i>&nbsp;            extends AbstractSet&lt;K&gt; implements NavigableSet&lt;K&gt; {
<i>2170</i>&nbsp;        final ConcurrentNavigableMap&lt;K,V&gt; m;
<i>2171</i>&nbsp;        KeySet(ConcurrentNavigableMap&lt;K,V&gt; map) { m = map; }
<i>2172</i>&nbsp;        public int size() { return m.size(); }
<i>2173</i>&nbsp;        public boolean isEmpty() { return m.isEmpty(); }
<i>2174</i>&nbsp;        public boolean contains(Object o) { return m.containsKey(o); }
<i>2175</i>&nbsp;        public boolean remove(Object o) { return m.remove(o) != null; }
<b class="nc"><i>2176</i>&nbsp;        public void clear() { m.clear(); }</b>
<i>2177</i>&nbsp;        public K lower(K e) { return m.lowerKey(e); }
<i>2178</i>&nbsp;        public K floor(K e) { return m.floorKey(e); }
<i>2179</i>&nbsp;        public K ceiling(K e) { return m.ceilingKey(e); }
<i>2180</i>&nbsp;        public K higher(K e) { return m.higherKey(e); }
<i>2181</i>&nbsp;        public Comparator&lt;? super K&gt; comparator() { return m.comparator(); }
<i>2182</i>&nbsp;        public K first() { return m.firstKey(); }
<i>2183</i>&nbsp;        public K last() { return m.lastKey(); }
<b class="nc"><i>2184</i>&nbsp;        public K pollFirst() {</b>
<b class="nc"><i>2185</i>&nbsp;            Map.Entry&lt;K,V&gt; e = m.pollFirstEntry();</b>
<i>2186</i>&nbsp;            return (e == null) ? null : e.getKey();
<i>2187</i>&nbsp;        }
<i>2188</i>&nbsp;        public K pollLast() {
<i>2189</i>&nbsp;            Map.Entry&lt;K,V&gt; e = m.pollLastEntry();
<i>2190</i>&nbsp;            return (e == null) ? null : e.getKey();
<i>2191</i>&nbsp;        }
<i>2192</i>&nbsp;        public Iterator&lt;K&gt; iterator() {
<i>2193</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)
<i>2194</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new KeyIterator()
<i>2195</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapKeyIterator();
<i>2196</i>&nbsp;        }
<i>2197</i>&nbsp;        public boolean equals(Object o) {
<i>2198</i>&nbsp;            if (o == this)
<b class="nc"><i>2199</i>&nbsp;                return true;</b>
<i>2200</i>&nbsp;            if (!(o instanceof Set))
<i>2201</i>&nbsp;                return false;
<i>2202</i>&nbsp;            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;
<i>2203</i>&nbsp;            try {
<i>2204</i>&nbsp;                return containsAll(c) &amp;&amp; c.containsAll(this);
<i>2205</i>&nbsp;            } catch (ClassCastException | NullPointerException unused) {
<i>2206</i>&nbsp;                return false;
<i>2207</i>&nbsp;            }
<b class="nc"><i>2208</i>&nbsp;        }</b>
<b class="nc"><i>2209</i>&nbsp;        public Object[] toArray()     { return toList(this).toArray();  }</b>
<i>2210</i>&nbsp;        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }
<i>2211</i>&nbsp;        public Iterator&lt;K&gt; descendingIterator() {
<i>2212</i>&nbsp;            return descendingSet().iterator();
<i>2213</i>&nbsp;        }
<i>2214</i>&nbsp;        public NavigableSet&lt;K&gt; subSet(K fromElement,
<i>2215</i>&nbsp;                                      boolean fromInclusive,
<i>2216</i>&nbsp;                                      K toElement,
<i>2217</i>&nbsp;                                      boolean toInclusive) {
<i>2218</i>&nbsp;            return new KeySet&lt;&gt;(m.subMap(fromElement, fromInclusive,
<i>2219</i>&nbsp;                                         toElement,   toInclusive));
<b class="nc"><i>2220</i>&nbsp;        }</b>
<b class="nc"><i>2221</i>&nbsp;        public NavigableSet&lt;K&gt; headSet(K toElement, boolean inclusive) {</b>
<b class="nc"><i>2222</i>&nbsp;            return new KeySet&lt;&gt;(m.headMap(toElement, inclusive));</b>
<b class="nc"><i>2223</i>&nbsp;        }</b>
<b class="nc"><i>2224</i>&nbsp;        public NavigableSet&lt;K&gt; tailSet(K fromElement, boolean inclusive) {</b>
<b class="nc"><i>2225</i>&nbsp;            return new KeySet&lt;&gt;(m.tailMap(fromElement, inclusive));</b>
<b class="nc"><i>2226</i>&nbsp;        }</b>
<i>2227</i>&nbsp;        public NavigableSet&lt;K&gt; subSet(K fromElement, K toElement) {
<i>2228</i>&nbsp;            return subSet(fromElement, true, toElement, false);
<i>2229</i>&nbsp;        }
<i>2230</i>&nbsp;        public NavigableSet&lt;K&gt; headSet(K toElement) {
<i>2231</i>&nbsp;            return headSet(toElement, false);
<i>2232</i>&nbsp;        }
<i>2233</i>&nbsp;        public NavigableSet&lt;K&gt; tailSet(K fromElement) {
<i>2234</i>&nbsp;            return tailSet(fromElement, true);
<i>2235</i>&nbsp;        }
<i>2236</i>&nbsp;        public NavigableSet&lt;K&gt; descendingSet() {
<b class="nc"><i>2237</i>&nbsp;            return new KeySet&lt;&gt;(m.descendingMap());</b>
<b class="nc"><i>2238</i>&nbsp;        }</b>
<b class="nc"><i>2239</i>&nbsp;</b>
<b class="nc"><i>2240</i>&nbsp;        public Spliterator&lt;K&gt; spliterator() {</b>
<b class="nc"><i>2241</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)</b>
<b class="nc"><i>2242</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).keySpliterator()</b>
<b class="nc"><i>2243</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapKeyIterator();</b>
<i>2244</i>&nbsp;        }
<i>2245</i>&nbsp;    }
<i>2246</i>&nbsp;
<i>2247</i>&nbsp;    static final class Values&lt;K,V&gt; extends AbstractCollection&lt;V&gt; {
<i>2248</i>&nbsp;        final ConcurrentNavigableMap&lt;K,V&gt; m;
<i>2249</i>&nbsp;        Values(ConcurrentNavigableMap&lt;K,V&gt; map) {
<i>2250</i>&nbsp;            m = map;
<i>2251</i>&nbsp;        }
<i>2252</i>&nbsp;        public Iterator&lt;V&gt; iterator() {
<b class="nc"><i>2253</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)</b>
<i>2254</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new ValueIterator()
<i>2255</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapValueIterator();
<i>2256</i>&nbsp;        }
<i>2257</i>&nbsp;        public int size() { return m.size(); }
<i>2258</i>&nbsp;        public boolean isEmpty() { return m.isEmpty(); }
<i>2259</i>&nbsp;        public boolean contains(Object o) { return m.containsValue(o); }
<i>2260</i>&nbsp;        public void clear() { m.clear(); }
<i>2261</i>&nbsp;        public Object[] toArray()     { return toList(this).toArray();  }
<i>2262</i>&nbsp;        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }
<b class="nc"><i>2263</i>&nbsp;</b>
<i>2264</i>&nbsp;        public Spliterator&lt;V&gt; spliterator() {
<i>2265</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)
<i>2266</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).valueSpliterator()
<i>2267</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapValueIterator();
<i>2268</i>&nbsp;        }
<i>2269</i>&nbsp;
<i>2270</i>&nbsp;        public boolean removeIf(Predicate&lt;? super V&gt; filter) {
<i>2271</i>&nbsp;            if (filter == null) throw new NullPointerException();
<i>2272</i>&nbsp;            if (m instanceof ConcurrentSkipListMap)
<i>2273</i>&nbsp;                return ((ConcurrentSkipListMap&lt;K,V&gt;)m).removeValueIf(filter);
<i>2274</i>&nbsp;            // else use iterator
<i>2275</i>&nbsp;            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it =
<i>2276</i>&nbsp;                ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
<i>2277</i>&nbsp;            boolean removed = false;
<i>2278</i>&nbsp;            while (it.hasNext()) {
<i>2279</i>&nbsp;                Map.Entry&lt;K,V&gt; e = it.next();
<i>2280</i>&nbsp;                V v = e.getValue();
<b class="nc"><i>2281</i>&nbsp;                if (filter.test(v) &amp;&amp; m.remove(e.getKey(), v))</b>
<b class="nc"><i>2282</i>&nbsp;                    removed = true;</b>
<b class="nc"><i>2283</i>&nbsp;            }</b>
<b class="nc"><i>2284</i>&nbsp;            return removed;</b>
<b class="nc"><i>2285</i>&nbsp;        }</b>
<b class="nc"><i>2286</i>&nbsp;    }</b>
<b class="nc"><i>2287</i>&nbsp;</b>
<i>2288</i>&nbsp;    static final class EntrySet&lt;K,V&gt; extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
<b class="nc"><i>2289</i>&nbsp;        final ConcurrentNavigableMap&lt;K,V&gt; m;</b>
<i>2290</i>&nbsp;        EntrySet(ConcurrentNavigableMap&lt;K,V&gt; map) {
<i>2291</i>&nbsp;            m = map;
<i>2292</i>&nbsp;        }
<b class="nc"><i>2293</i>&nbsp;        public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</b>
<i>2294</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)
<i>2295</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).new EntryIterator()
<i>2296</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
<i>2297</i>&nbsp;        }
<b class="nc"><i>2298</i>&nbsp;</b>
<b class="nc"><i>2299</i>&nbsp;        public boolean contains(Object o) {</b>
<b class="nc"><i>2300</i>&nbsp;            if (!(o instanceof Map.Entry))</b>
<b class="nc"><i>2301</i>&nbsp;                return false;</b>
<b class="nc"><i>2302</i>&nbsp;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</b>
<b class="nc"><i>2303</i>&nbsp;            V v = m.get(e.getKey());</b>
<b class="nc"><i>2304</i>&nbsp;            return v != null &amp;&amp; v.equals(e.getValue());</b>
<b class="nc"><i>2305</i>&nbsp;        }</b>
<b class="nc"><i>2306</i>&nbsp;        public boolean remove(Object o) {</b>
<i>2307</i>&nbsp;            if (!(o instanceof Map.Entry))
<b class="nc"><i>2308</i>&nbsp;                return false;</b>
<i>2309</i>&nbsp;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
<i>2310</i>&nbsp;            return m.remove(e.getKey(),
<i>2311</i>&nbsp;                            e.getValue());
<b class="nc"><i>2312</i>&nbsp;        }</b>
<b class="nc"><i>2313</i>&nbsp;        public boolean isEmpty() {</b>
<b class="nc"><i>2314</i>&nbsp;            return m.isEmpty();</b>
<i>2315</i>&nbsp;        }
<i>2316</i>&nbsp;        public int size() {
<b class="nc"><i>2317</i>&nbsp;            return m.size();</b>
<b class="nc"><i>2318</i>&nbsp;        }</b>
<i>2319</i>&nbsp;        public void clear() {
<i>2320</i>&nbsp;            m.clear();
<i>2321</i>&nbsp;        }
<i>2322</i>&nbsp;        public boolean equals(Object o) {
<b class="nc"><i>2323</i>&nbsp;            if (o == this)</b>
<i>2324</i>&nbsp;                return true;
<b class="nc"><i>2325</i>&nbsp;            if (!(o instanceof Set))</b>
<b class="nc"><i>2326</i>&nbsp;                return false;</b>
<b class="nc"><i>2327</i>&nbsp;            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</b>
<i>2328</i>&nbsp;            try {
<i>2329</i>&nbsp;                return containsAll(c) &amp;&amp; c.containsAll(this);
<i>2330</i>&nbsp;            } catch (ClassCastException | NullPointerException unused) {
<b class="nc"><i>2331</i>&nbsp;                return false;</b>
<i>2332</i>&nbsp;            }
<b class="nc"><i>2333</i>&nbsp;        }</b>
<b class="nc"><i>2334</i>&nbsp;        public Object[] toArray()     { return toList(this).toArray();  }</b>
<b class="nc"><i>2335</i>&nbsp;        public &lt;T&gt; T[] toArray(T[] a) { return toList(this).toArray(a); }</b>
<i>2336</i>&nbsp;
<i>2337</i>&nbsp;        public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
<i>2338</i>&nbsp;            return (m instanceof ConcurrentSkipListMap)
<b class="nc"><i>2339</i>&nbsp;                ? ((ConcurrentSkipListMap&lt;K,V&gt;)m).entrySpliterator()</b>
<i>2340</i>&nbsp;                : ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
<b class="nc"><i>2341</i>&nbsp;        }</b>
<b class="nc"><i>2342</i>&nbsp;        public boolean removeIf(Predicate&lt;? super Entry&lt;K,V&gt;&gt; filter) {</b>
<b class="nc"><i>2343</i>&nbsp;            if (filter == null) throw new NullPointerException();</b>
<b class="nc"><i>2344</i>&nbsp;            if (m instanceof ConcurrentSkipListMap)</b>
<i>2345</i>&nbsp;                return ((ConcurrentSkipListMap&lt;K,V&gt;)m).removeEntryIf(filter);
<i>2346</i>&nbsp;            // else use iterator
<i>2347</i>&nbsp;            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it =
<i>2348</i>&nbsp;                ((SubMap&lt;K,V&gt;)m).new SubMapEntryIterator();
<i>2349</i>&nbsp;            boolean removed = false;
<i>2350</i>&nbsp;            while (it.hasNext()) {
<b class="nc"><i>2351</i>&nbsp;                Map.Entry&lt;K,V&gt; e = it.next();</b>
<i>2352</i>&nbsp;                if (filter.test(e) &amp;&amp; m.remove(e.getKey(), e.getValue()))
<i>2353</i>&nbsp;                    removed = true;
<i>2354</i>&nbsp;            }
<b class="nc"><i>2355</i>&nbsp;            return removed;</b>
<i>2356</i>&nbsp;        }
<i>2357</i>&nbsp;    }
<i>2358</i>&nbsp;
<b class="nc"><i>2359</i>&nbsp;    /**</b>
<i>2360</i>&nbsp;     * Submaps returned by {@link ConcurrentSkipListMap} submap operations
<i>2361</i>&nbsp;     * represent a subrange of mappings of their underlying maps.
<i>2362</i>&nbsp;     * Instances of this class support all methods of their underlying
<i>2363</i>&nbsp;     * maps, differing in that mappings outside their range are ignored,
<i>2364</i>&nbsp;     * and attempts to add mappings outside their ranges result in {@link
<i>2365</i>&nbsp;     * IllegalArgumentException}.  Instances of this class are constructed
<i>2366</i>&nbsp;     * only using the {@code subMap}, {@code headMap}, and {@code tailMap}
<i>2367</i>&nbsp;     * methods of their underlying maps.
<i>2368</i>&nbsp;     *
<i>2369</i>&nbsp;     * @serial include
<i>2370</i>&nbsp;     */
<i>2371</i>&nbsp;    static final class SubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
<b class="nc"><i>2372</i>&nbsp;        implements ConcurrentNavigableMap&lt;K,V&gt;, Serializable {</b>
<b class="nc"><i>2373</i>&nbsp;        private static final long serialVersionUID = -7647078645895051609L;</b>
<b class="nc"><i>2374</i>&nbsp;</b>
<b class="nc"><i>2375</i>&nbsp;        /** Underlying map */</b>
<i>2376</i>&nbsp;        final ConcurrentSkipListMap&lt;K,V&gt; m;
<i>2377</i>&nbsp;        /** lower bound key, or null if from start */
<i>2378</i>&nbsp;        private final K lo;
<i>2379</i>&nbsp;        /** upper bound key, or null if to end */
<i>2380</i>&nbsp;        private final K hi;
<b class="nc"><i>2381</i>&nbsp;        /** inclusion flag for lo */</b>
<b class="nc"><i>2382</i>&nbsp;        private final boolean loInclusive;</b>
<b class="nc"><i>2383</i>&nbsp;        /** inclusion flag for hi */</b>
<b class="nc"><i>2384</i>&nbsp;        private final boolean hiInclusive;</b>
<b class="nc"><i>2385</i>&nbsp;        /** direction */</b>
<b class="nc"><i>2386</i>&nbsp;        final boolean isDescending;</b>
<b class="nc"><i>2387</i>&nbsp;</b>
<b class="nc"><i>2388</i>&nbsp;        // Lazily initialized view holders</b>
<b class="nc"><i>2389</i>&nbsp;        private transient KeySet&lt;K,V&gt; keySetView;</b>
<b class="nc"><i>2390</i>&nbsp;        private transient Values&lt;K,V&gt; valuesView;</b>
<b class="nc"><i>2391</i>&nbsp;        private transient EntrySet&lt;K,V&gt; entrySetView;</b>
<b class="nc"><i>2392</i>&nbsp;</b>
<b class="nc"><i>2393</i>&nbsp;        /**</b>
<i>2394</i>&nbsp;         * Creates a new submap, initializing all fields.
<b class="nc"><i>2395</i>&nbsp;         */</b>
<b class="nc"><i>2396</i>&nbsp;        SubMap(ConcurrentSkipListMap&lt;K,V&gt; map,</b>
<i>2397</i>&nbsp;               K fromKey, boolean fromInclusive,
<i>2398</i>&nbsp;               K toKey, boolean toInclusive,
<b class="nc"><i>2399</i>&nbsp;               boolean isDescending) {</b>
<b class="nc"><i>2400</i>&nbsp;            Comparator&lt;? super K&gt; cmp = map.comparator;</b>
<i>2401</i>&nbsp;            if (fromKey != null &amp;&amp; toKey != null &amp;&amp;
<i>2402</i>&nbsp;                cpr(cmp, fromKey, toKey) &gt; 0)
<i>2403</i>&nbsp;                throw new IllegalArgumentException(&quot;inconsistent range&quot;);
<b class="nc"><i>2404</i>&nbsp;            this.m = map;</b>
<b class="nc"><i>2405</i>&nbsp;            this.lo = fromKey;</b>
<i>2406</i>&nbsp;            this.hi = toKey;
<b class="nc"><i>2407</i>&nbsp;            this.loInclusive = fromInclusive;</b>
<i>2408</i>&nbsp;            this.hiInclusive = toInclusive;
<i>2409</i>&nbsp;            this.isDescending = isDescending;
<b class="nc"><i>2410</i>&nbsp;        }</b>
<b class="nc"><i>2411</i>&nbsp;</b>
<b class="nc"><i>2412</i>&nbsp;        /* ----------------  Utilities -------------- */</b>
<b class="nc"><i>2413</i>&nbsp;</b>
<b class="nc"><i>2414</i>&nbsp;        boolean tooLow(Object key, Comparator&lt;? super K&gt; cmp) {</b>
<i>2415</i>&nbsp;            int c;
<b class="nc"><i>2416</i>&nbsp;            return (lo != null &amp;&amp; ((c = cpr(cmp, key, lo)) &lt; 0 ||</b>
<b class="nc"><i>2417</i>&nbsp;                                   (c == 0 &amp;&amp; !loInclusive)));</b>
<b class="nc"><i>2418</i>&nbsp;        }</b>
<b class="nc"><i>2419</i>&nbsp;</b>
<b class="nc"><i>2420</i>&nbsp;        boolean tooHigh(Object key, Comparator&lt;? super K&gt; cmp) {</b>
<i>2421</i>&nbsp;            int c;
<i>2422</i>&nbsp;            return (hi != null &amp;&amp; ((c = cpr(cmp, key, hi)) &gt; 0 ||
<b class="nc"><i>2423</i>&nbsp;                                   (c == 0 &amp;&amp; !hiInclusive)));</b>
<b class="nc"><i>2424</i>&nbsp;        }</b>
<i>2425</i>&nbsp;
<b class="nc"><i>2426</i>&nbsp;        boolean inBounds(Object key, Comparator&lt;? super K&gt; cmp) {</b>
<i>2427</i>&nbsp;            return !tooLow(key, cmp) &amp;&amp; !tooHigh(key, cmp);
<i>2428</i>&nbsp;        }
<i>2429</i>&nbsp;
<i>2430</i>&nbsp;        void checkKeyBounds(K key, Comparator&lt;? super K&gt; cmp) {
<i>2431</i>&nbsp;            if (key == null)
<b class="nc"><i>2432</i>&nbsp;                throw new NullPointerException();</b>
<i>2433</i>&nbsp;            if (!inBounds(key, cmp))
<i>2434</i>&nbsp;                throw new IllegalArgumentException(&quot;key out of range&quot;);
<i>2435</i>&nbsp;        }
<b class="nc"><i>2436</i>&nbsp;</b>
<i>2437</i>&nbsp;        /**
<i>2438</i>&nbsp;         * Returns true if node key is less than upper bound of range.
<b class="nc"><i>2439</i>&nbsp;         */</b>
<i>2440</i>&nbsp;        boolean isBeforeEnd(ConcurrentSkipListMap.Node&lt;K,V&gt; n,
<i>2441</i>&nbsp;                            Comparator&lt;? super K&gt; cmp) {
<b class="nc"><i>2442</i>&nbsp;            if (n == null)</b>
<i>2443</i>&nbsp;                return false;
<i>2444</i>&nbsp;            if (hi == null)
<b class="nc"><i>2445</i>&nbsp;                return true;</b>
<i>2446</i>&nbsp;            K k = n.key;
<i>2447</i>&nbsp;            if (k == null) // pass by markers and headers
<b class="nc"><i>2448</i>&nbsp;                return true;</b>
<i>2449</i>&nbsp;            int c = cpr(cmp, k, hi);
<i>2450</i>&nbsp;            return c &lt; 0 || (c == 0 &amp;&amp; hiInclusive);
<b class="nc"><i>2451</i>&nbsp;        }</b>
<i>2452</i>&nbsp;
<i>2453</i>&nbsp;        /**
<i>2454</i>&nbsp;         * Returns lowest node. This node might not be in range, so
<b class="nc"><i>2455</i>&nbsp;         * most usages need to check bounds.</b>
<b class="nc"><i>2456</i>&nbsp;         */</b>
<i>2457</i>&nbsp;        ConcurrentSkipListMap.Node&lt;K,V&gt; loNode(Comparator&lt;? super K&gt; cmp) {
<b class="nc"><i>2458</i>&nbsp;            if (lo == null)</b>
<i>2459</i>&nbsp;                return m.findFirst();
<i>2460</i>&nbsp;            else if (loInclusive)
<i>2461</i>&nbsp;                return m.findNear(lo, GT|EQ, cmp);
<i>2462</i>&nbsp;            else
<i>2463</i>&nbsp;                return m.findNear(lo, GT, cmp);
<b class="nc"><i>2464</i>&nbsp;        }</b>
<b class="nc"><i>2465</i>&nbsp;</b>
<i>2466</i>&nbsp;        /**
<i>2467</i>&nbsp;         * Returns highest node. This node might not be in range, so
<i>2468</i>&nbsp;         * most usages need to check bounds.
<b class="nc"><i>2469</i>&nbsp;         */</b>
<b class="nc"><i>2470</i>&nbsp;        ConcurrentSkipListMap.Node&lt;K,V&gt; hiNode(Comparator&lt;? super K&gt; cmp) {</b>
<i>2471</i>&nbsp;            if (hi == null)
<b class="nc"><i>2472</i>&nbsp;                return m.findLast();</b>
<i>2473</i>&nbsp;            else if (hiInclusive)
<i>2474</i>&nbsp;                return m.findNear(hi, LT|EQ, cmp);
<b class="nc"><i>2475</i>&nbsp;            else</b>
<i>2476</i>&nbsp;                return m.findNear(hi, LT, cmp);
<i>2477</i>&nbsp;        }
<b class="nc"><i>2478</i>&nbsp;</b>
<i>2479</i>&nbsp;        /**
<i>2480</i>&nbsp;         * Returns lowest absolute key (ignoring directionality).
<b class="nc"><i>2481</i>&nbsp;         */</b>
<i>2482</i>&nbsp;        K lowestKey() {
<i>2483</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<b class="nc"><i>2484</i>&nbsp;            ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);</b>
<i>2485</i>&nbsp;            if (isBeforeEnd(n, cmp))
<b class="nc"><i>2486</i>&nbsp;                return n.key;</b>
<b class="nc"><i>2487</i>&nbsp;            else</b>
<i>2488</i>&nbsp;                throw new NoSuchElementException();
<i>2489</i>&nbsp;        }
<b class="nc"><i>2490</i>&nbsp;</b>
<b class="nc"><i>2491</i>&nbsp;        /**</b>
<i>2492</i>&nbsp;         * Returns highest absolute key (ignoring directionality).
<b class="nc"><i>2493</i>&nbsp;         */</b>
<i>2494</i>&nbsp;        K highestKey() {
<i>2495</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2496</i>&nbsp;            ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);
<i>2497</i>&nbsp;            if (n != null) {
<i>2498</i>&nbsp;                K last = n.key;
<b class="nc"><i>2499</i>&nbsp;                if (inBounds(last, cmp))</b>
<b class="nc"><i>2500</i>&nbsp;                    return last;</b>
<i>2501</i>&nbsp;            }
<i>2502</i>&nbsp;            throw new NoSuchElementException();
<i>2503</i>&nbsp;        }
<b class="nc"><i>2504</i>&nbsp;</b>
<b class="nc"><i>2505</i>&nbsp;        Map.Entry&lt;K,V&gt; lowestEntry() {</b>
<i>2506</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<b class="nc"><i>2507</i>&nbsp;            for (;;) {</b>
<i>2508</i>&nbsp;                ConcurrentSkipListMap.Node&lt;K,V&gt; n; V v;
<i>2509</i>&nbsp;                if ((n = loNode(cmp)) == null || !isBeforeEnd(n, cmp))
<i>2510</i>&nbsp;                    return null;
<b class="nc"><i>2511</i>&nbsp;                else if ((v = n.val) != null)</b>
<b class="nc"><i>2512</i>&nbsp;                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</b>
<b class="nc"><i>2513</i>&nbsp;            }</b>
<b class="nc"><i>2514</i>&nbsp;        }</b>
<b class="nc"><i>2515</i>&nbsp;</b>
<i>2516</i>&nbsp;        Map.Entry&lt;K,V&gt; highestEntry() {
<i>2517</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<b class="nc"><i>2518</i>&nbsp;            for (;;) {</b>
<b class="nc"><i>2519</i>&nbsp;                ConcurrentSkipListMap.Node&lt;K,V&gt; n; V v;</b>
<b class="nc"><i>2520</i>&nbsp;                if ((n = hiNode(cmp)) == null || !inBounds(n.key, cmp))</b>
<b class="nc"><i>2521</i>&nbsp;                    return null;</b>
<b class="nc"><i>2522</i>&nbsp;                else if ((v = n.val) != null)</b>
<i>2523</i>&nbsp;                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);
<i>2524</i>&nbsp;            }
<b class="nc"><i>2525</i>&nbsp;        }</b>
<i>2526</i>&nbsp;
<i>2527</i>&nbsp;        Map.Entry&lt;K,V&gt; removeLowest() {
<b class="nc"><i>2528</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;</b>
<i>2529</i>&nbsp;            for (;;) {
<i>2530</i>&nbsp;                ConcurrentSkipListMap.Node&lt;K,V&gt; n; K k; V v;
<b class="nc"><i>2531</i>&nbsp;                if ((n = loNode(cmp)) == null)</b>
<i>2532</i>&nbsp;                    return null;
<i>2533</i>&nbsp;                else if (!inBounds((k = n.key), cmp))
<b class="nc"><i>2534</i>&nbsp;                    return null;</b>
<b class="nc"><i>2535</i>&nbsp;                else if ((v = m.doRemove(k, null)) != null)</b>
<b class="nc"><i>2536</i>&nbsp;                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);</b>
<b class="nc"><i>2537</i>&nbsp;            }</b>
<b class="nc"><i>2538</i>&nbsp;        }</b>
<i>2539</i>&nbsp;
<b class="nc"><i>2540</i>&nbsp;        Map.Entry&lt;K,V&gt; removeHighest() {</b>
<b class="nc"><i>2541</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;</b>
<b class="nc"><i>2542</i>&nbsp;            for (;;) {</b>
<b class="nc"><i>2543</i>&nbsp;                ConcurrentSkipListMap.Node&lt;K,V&gt; n; K k; V v;</b>
<b class="nc"><i>2544</i>&nbsp;                if ((n = hiNode(cmp)) == null)</b>
<i>2545</i>&nbsp;                    return null;
<i>2546</i>&nbsp;                else if (!inBounds((k = n.key), cmp))
<b class="nc"><i>2547</i>&nbsp;                    return null;</b>
<b class="nc"><i>2548</i>&nbsp;                else if ((v = m.doRemove(k, null)) != null)</b>
<i>2549</i>&nbsp;                    return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v);
<i>2550</i>&nbsp;            }
<b class="nc"><i>2551</i>&nbsp;        }</b>
<b class="nc"><i>2552</i>&nbsp;</b>
<i>2553</i>&nbsp;        /**
<b class="nc"><i>2554</i>&nbsp;         * Submap version of ConcurrentSkipListMap.findNearEntry.</b>
<b class="nc"><i>2555</i>&nbsp;         */</b>
<i>2556</i>&nbsp;        Map.Entry&lt;K,V&gt; getNearEntry(K key, int rel) {
<i>2557</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2558</i>&nbsp;            if (isDescending) { // adjust relation for direction
<i>2559</i>&nbsp;                if ((rel &amp; LT) == 0)
<i>2560</i>&nbsp;                    rel |= LT;
<i>2561</i>&nbsp;                else
<i>2562</i>&nbsp;                    rel &amp;= ~LT;
<i>2563</i>&nbsp;            }
<i>2564</i>&nbsp;            if (tooLow(key, cmp))
<i>2565</i>&nbsp;                return ((rel &amp; LT) != 0) ? null : lowestEntry();
<i>2566</i>&nbsp;            if (tooHigh(key, cmp))
<i>2567</i>&nbsp;                return ((rel &amp; LT) != 0) ? highestEntry() : null;
<i>2568</i>&nbsp;            AbstractMap.SimpleImmutableEntry&lt;K,V&gt; e =
<i>2569</i>&nbsp;                m.findNearEntry(key, rel, cmp);
<i>2570</i>&nbsp;            if (e == null || !inBounds(e.getKey(), cmp))
<b class="nc"><i>2571</i>&nbsp;                return null;</b>
<i>2572</i>&nbsp;            else
<i>2573</i>&nbsp;                return e;
<i>2574</i>&nbsp;        }
<i>2575</i>&nbsp;
<i>2576</i>&nbsp;        // Almost the same as getNearEntry, except for keys
<i>2577</i>&nbsp;        K getNearKey(K key, int rel) {
<i>2578</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2579</i>&nbsp;            if (isDescending) { // adjust relation for direction
<i>2580</i>&nbsp;                if ((rel &amp; LT) == 0)
<i>2581</i>&nbsp;                    rel |= LT;
<i>2582</i>&nbsp;                else
<i>2583</i>&nbsp;                    rel &amp;= ~LT;
<i>2584</i>&nbsp;            }
<i>2585</i>&nbsp;            if (tooLow(key, cmp)) {
<i>2586</i>&nbsp;                if ((rel &amp; LT) == 0) {
<i>2587</i>&nbsp;                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
<i>2588</i>&nbsp;                    if (isBeforeEnd(n, cmp))
<i>2589</i>&nbsp;                        return n.key;
<i>2590</i>&nbsp;                }
<i>2591</i>&nbsp;                return null;
<i>2592</i>&nbsp;            }
<i>2593</i>&nbsp;            if (tooHigh(key, cmp)) {
<i>2594</i>&nbsp;                if ((rel &amp; LT) != 0) {
<i>2595</i>&nbsp;                    ConcurrentSkipListMap.Node&lt;K,V&gt; n = hiNode(cmp);
<i>2596</i>&nbsp;                    if (n != null) {
<i>2597</i>&nbsp;                        K last = n.key;
<i>2598</i>&nbsp;                        if (inBounds(last, cmp))
<b class="nc"><i>2599</i>&nbsp;                            return last;</b>
<b class="nc"><i>2600</i>&nbsp;                    }</b>
<b class="nc"><i>2601</i>&nbsp;                }</b>
<b class="nc"><i>2602</i>&nbsp;                return null;</b>
<b class="nc"><i>2603</i>&nbsp;            }</b>
<b class="nc"><i>2604</i>&nbsp;            for (;;) {</b>
<b class="nc"><i>2605</i>&nbsp;                Node&lt;K,V&gt; n = m.findNear(key, rel, cmp);</b>
<b class="nc"><i>2606</i>&nbsp;                if (n == null || !inBounds(n.key, cmp))</b>
<b class="nc"><i>2607</i>&nbsp;                    return null;</b>
<b class="nc"><i>2608</i>&nbsp;                if (n.val != null)</b>
<b class="nc"><i>2609</i>&nbsp;                    return n.key;</b>
<i>2610</i>&nbsp;            }
<i>2611</i>&nbsp;        }
<i>2612</i>&nbsp;
<i>2613</i>&nbsp;        /* ----------------  Map API methods -------------- */
<i>2614</i>&nbsp;
<i>2615</i>&nbsp;        public boolean containsKey(Object key) {
<b class="nc"><i>2616</i>&nbsp;            if (key == null) throw new NullPointerException();</b>
<i>2617</i>&nbsp;            return inBounds(key, m.comparator) &amp;&amp; m.containsKey(key);
<i>2618</i>&nbsp;        }
<i>2619</i>&nbsp;
<i>2620</i>&nbsp;        public V get(Object key) {
<i>2621</i>&nbsp;            if (key == null) throw new NullPointerException();
<b class="nc"><i>2622</i>&nbsp;            return (!inBounds(key, m.comparator)) ? null : m.get(key);</b>
<i>2623</i>&nbsp;        }
<i>2624</i>&nbsp;
<i>2625</i>&nbsp;        public V put(K key, V value) {
<i>2626</i>&nbsp;            checkKeyBounds(key, m.comparator);
<b class="nc"><i>2627</i>&nbsp;            return m.put(key, value);</b>
<i>2628</i>&nbsp;        }
<i>2629</i>&nbsp;
<i>2630</i>&nbsp;        public V remove(Object key) {
<b class="nc"><i>2631</i>&nbsp;            return (!inBounds(key, m.comparator)) ? null : m.remove(key);</b>
<b class="nc"><i>2632</i>&nbsp;        }</b>
<b class="nc"><i>2633</i>&nbsp;</b>
<b class="nc"><i>2634</i>&nbsp;        public int size() {</b>
<i>2635</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2636</i>&nbsp;            long count = 0;
<i>2637</i>&nbsp;            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
<i>2638</i>&nbsp;                 isBeforeEnd(n, cmp);
<i>2639</i>&nbsp;                 n = n.next) {
<i>2640</i>&nbsp;                if (n.val != null)
<i>2641</i>&nbsp;                    ++count;
<b class="nc"><i>2642</i>&nbsp;            }</b>
<b class="nc"><i>2643</i>&nbsp;            return count &gt;= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)count;</b>
<b class="nc"><i>2644</i>&nbsp;        }</b>
<b class="nc"><i>2645</i>&nbsp;</b>
<b class="nc"><i>2646</i>&nbsp;        public boolean isEmpty() {</b>
<b class="nc"><i>2647</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;</b>
<b class="nc"><i>2648</i>&nbsp;            return !isBeforeEnd(loNode(cmp), cmp);</b>
<b class="nc"><i>2649</i>&nbsp;        }</b>
<b class="nc"><i>2650</i>&nbsp;</b>
<b class="nc"><i>2651</i>&nbsp;        public boolean containsValue(Object value) {</b>
<b class="nc"><i>2652</i>&nbsp;            if (value == null)</b>
<i>2653</i>&nbsp;                throw new NullPointerException();
<i>2654</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2655</i>&nbsp;            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
<i>2656</i>&nbsp;                 isBeforeEnd(n, cmp);
<i>2657</i>&nbsp;                 n = n.next) {
<i>2658</i>&nbsp;                V v = n.val;
<i>2659</i>&nbsp;                if (v != null &amp;&amp; value.equals(v))
<b class="nc"><i>2660</i>&nbsp;                    return true;</b>
<b class="nc"><i>2661</i>&nbsp;            }</b>
<b class="nc"><i>2662</i>&nbsp;            return false;</b>
<b class="nc"><i>2663</i>&nbsp;        }</b>
<i>2664</i>&nbsp;
<b class="nc"><i>2665</i>&nbsp;        public void clear() {</b>
<i>2666</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2667</i>&nbsp;            for (ConcurrentSkipListMap.Node&lt;K,V&gt; n = loNode(cmp);
<i>2668</i>&nbsp;                 isBeforeEnd(n, cmp);
<i>2669</i>&nbsp;                 n = n.next) {
<i>2670</i>&nbsp;                if (n.val != null)
<i>2671</i>&nbsp;                    m.remove(n.key);
<i>2672</i>&nbsp;            }
<b class="nc"><i>2673</i>&nbsp;        }</b>
<b class="nc"><i>2674</i>&nbsp;</b>
<b class="nc"><i>2675</i>&nbsp;        /* ----------------  ConcurrentMap API methods -------------- */</b>
<b class="nc"><i>2676</i>&nbsp;</b>
<i>2677</i>&nbsp;        public V putIfAbsent(K key, V value) {
<b class="nc"><i>2678</i>&nbsp;            checkKeyBounds(key, m.comparator);</b>
<i>2679</i>&nbsp;            return m.putIfAbsent(key, value);
<i>2680</i>&nbsp;        }
<i>2681</i>&nbsp;
<i>2682</i>&nbsp;        public boolean remove(Object key, Object value) {
<i>2683</i>&nbsp;            return inBounds(key, m.comparator) &amp;&amp; m.remove(key, value);
<i>2684</i>&nbsp;        }
<b class="nc"><i>2685</i>&nbsp;</b>
<b class="nc"><i>2686</i>&nbsp;        public boolean replace(K key, V oldValue, V newValue) {</b>
<b class="nc"><i>2687</i>&nbsp;            checkKeyBounds(key, m.comparator);</b>
<b class="nc"><i>2688</i>&nbsp;            return m.replace(key, oldValue, newValue);</b>
<i>2689</i>&nbsp;        }
<b class="nc"><i>2690</i>&nbsp;</b>
<i>2691</i>&nbsp;        public V replace(K key, V value) {
<i>2692</i>&nbsp;            checkKeyBounds(key, m.comparator);
<i>2693</i>&nbsp;            return m.replace(key, value);
<i>2694</i>&nbsp;        }
<i>2695</i>&nbsp;
<i>2696</i>&nbsp;        /* ----------------  SortedMap API methods -------------- */
<b class="nc"><i>2697</i>&nbsp;</b>
<b class="nc"><i>2698</i>&nbsp;        public Comparator&lt;? super K&gt; comparator() {</b>
<b class="nc"><i>2699</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator();</b>
<b class="nc"><i>2700</i>&nbsp;            if (isDescending)</b>
<b class="nc"><i>2701</i>&nbsp;                return Collections.reverseOrder(cmp);</b>
<b class="nc"><i>2702</i>&nbsp;            else</b>
<i>2703</i>&nbsp;                return cmp;
<b class="nc"><i>2704</i>&nbsp;        }</b>
<i>2705</i>&nbsp;
<i>2706</i>&nbsp;        /**
<i>2707</i>&nbsp;         * Utility to create submaps, where given bounds override
<b class="nc"><i>2708</i>&nbsp;         * unbounded(null) ones and/or are checked against bounded ones.</b>
<i>2709</i>&nbsp;         */
<b class="nc"><i>2710</i>&nbsp;        SubMap&lt;K,V&gt; newSubMap(K fromKey, boolean fromInclusive,</b>
<b class="nc"><i>2711</i>&nbsp;                              K toKey, boolean toInclusive) {</b>
<b class="nc"><i>2712</i>&nbsp;            Comparator&lt;? super K&gt; cmp = m.comparator;</b>
<b class="nc"><i>2713</i>&nbsp;            if (isDescending) { // flip senses</b>
<b class="nc"><i>2714</i>&nbsp;                K tk = fromKey;</b>
<b class="nc"><i>2715</i>&nbsp;                fromKey = toKey;</b>
<b class="nc"><i>2716</i>&nbsp;                toKey = tk;</b>
<i>2717</i>&nbsp;                boolean ti = fromInclusive;
<i>2718</i>&nbsp;                fromInclusive = toInclusive;
<i>2719</i>&nbsp;                toInclusive = ti;
<b class="nc"><i>2720</i>&nbsp;            }</b>
<i>2721</i>&nbsp;            if (lo != null) {
<b class="nc"><i>2722</i>&nbsp;                if (fromKey == null) {</b>
<b class="nc"><i>2723</i>&nbsp;                    fromKey = lo;</b>
<b class="nc"><i>2724</i>&nbsp;                    fromInclusive = loInclusive;</b>
<b class="nc"><i>2725</i>&nbsp;                }</b>
<b class="nc"><i>2726</i>&nbsp;                else {</b>
<b class="nc"><i>2727</i>&nbsp;                    int c = cpr(cmp, fromKey, lo);</b>
<b class="nc"><i>2728</i>&nbsp;                    if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive &amp;&amp; fromInclusive))</b>
<i>2729</i>&nbsp;                        throw new IllegalArgumentException(&quot;key out of range&quot;);
<i>2730</i>&nbsp;                }
<i>2731</i>&nbsp;            }
<b class="nc"><i>2732</i>&nbsp;            if (hi != null) {</b>
<i>2733</i>&nbsp;                if (toKey == null) {
<b class="nc"><i>2734</i>&nbsp;                    toKey = hi;</b>
<b class="nc"><i>2735</i>&nbsp;                    toInclusive = hiInclusive;</b>
<b class="nc"><i>2736</i>&nbsp;                }</b>
<b class="nc"><i>2737</i>&nbsp;                else {</b>
<b class="nc"><i>2738</i>&nbsp;                    int c = cpr(cmp, toKey, hi);</b>
<b class="nc"><i>2739</i>&nbsp;                    if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive &amp;&amp; toInclusive))</b>
<b class="nc"><i>2740</i>&nbsp;                        throw new IllegalArgumentException(&quot;key out of range&quot;);</b>
<b class="nc"><i>2741</i>&nbsp;                }</b>
<b class="nc"><i>2742</i>&nbsp;            }</b>
<b class="nc"><i>2743</i>&nbsp;            return new SubMap&lt;K,V&gt;(m, fromKey, fromInclusive,</b>
<i>2744</i>&nbsp;                                   toKey, toInclusive, isDescending);
<i>2745</i>&nbsp;        }
<i>2746</i>&nbsp;
<b class="nc"><i>2747</i>&nbsp;        public SubMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,</b>
<i>2748</i>&nbsp;                                  K toKey, boolean toInclusive) {
<b class="nc"><i>2749</i>&nbsp;            if (fromKey == null || toKey == null)</b>
<b class="nc"><i>2750</i>&nbsp;                throw new NullPointerException();</b>
<b class="nc"><i>2751</i>&nbsp;            return newSubMap(fromKey, fromInclusive, toKey, toInclusive);</b>
<b class="nc"><i>2752</i>&nbsp;        }</b>
<b class="nc"><i>2753</i>&nbsp;</b>
<b class="nc"><i>2754</i>&nbsp;        public SubMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {</b>
<b class="nc"><i>2755</i>&nbsp;            if (toKey == null)</b>
<b class="nc"><i>2756</i>&nbsp;                throw new NullPointerException();</b>
<b class="nc"><i>2757</i>&nbsp;            return newSubMap(null, false, toKey, inclusive);</b>
<b class="nc"><i>2758</i>&nbsp;        }</b>
<i>2759</i>&nbsp;
<i>2760</i>&nbsp;        public SubMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
<i>2761</i>&nbsp;            if (fromKey == null)
<i>2762</i>&nbsp;                throw new NullPointerException();
<i>2763</i>&nbsp;            return newSubMap(fromKey, inclusive, null, false);
<i>2764</i>&nbsp;        }
<b class="nc"><i>2765</i>&nbsp;</b>
<b class="nc"><i>2766</i>&nbsp;        public SubMap&lt;K,V&gt; subMap(K fromKey, K toKey) {</b>
<b class="nc"><i>2767</i>&nbsp;            return subMap(fromKey, true, toKey, false);</b>
<b class="nc"><i>2768</i>&nbsp;        }</b>
<i>2769</i>&nbsp;
<b class="nc"><i>2770</i>&nbsp;        public SubMap&lt;K,V&gt; headMap(K toKey) {</b>
<i>2771</i>&nbsp;            return headMap(toKey, false);
<b class="nc"><i>2772</i>&nbsp;        }</b>
<b class="nc"><i>2773</i>&nbsp;</b>
<b class="nc"><i>2774</i>&nbsp;        public SubMap&lt;K,V&gt; tailMap(K fromKey) {</b>
<b class="nc"><i>2775</i>&nbsp;            return tailMap(fromKey, true);</b>
<i>2776</i>&nbsp;        }
<b class="nc"><i>2777</i>&nbsp;</b>
<b class="nc"><i>2778</i>&nbsp;        public SubMap&lt;K,V&gt; descendingMap() {</b>
<b class="nc"><i>2779</i>&nbsp;            return new SubMap&lt;K,V&gt;(m, lo, loInclusive,</b>
<b class="nc"><i>2780</i>&nbsp;                                   hi, hiInclusive, !isDescending);</b>
<b class="nc"><i>2781</i>&nbsp;        }</b>
<b class="nc"><i>2782</i>&nbsp;</b>
<b class="nc"><i>2783</i>&nbsp;        /* ----------------  Relational methods -------------- */</b>
<b class="nc"><i>2784</i>&nbsp;</b>
<i>2785</i>&nbsp;        public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
<i>2786</i>&nbsp;            return getNearEntry(key, GT|EQ);
<i>2787</i>&nbsp;        }
<i>2788</i>&nbsp;
<b class="nc"><i>2789</i>&nbsp;        public K ceilingKey(K key) {</b>
<b class="nc"><i>2790</i>&nbsp;            return getNearKey(key, GT|EQ);</b>
<b class="nc"><i>2791</i>&nbsp;        }</b>
<b class="nc"><i>2792</i>&nbsp;</b>
<i>2793</i>&nbsp;        public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
<b class="nc"><i>2794</i>&nbsp;            return getNearEntry(key, LT);</b>
<i>2795</i>&nbsp;        }
<b class="nc"><i>2796</i>&nbsp;</b>
<b class="nc"><i>2797</i>&nbsp;        public K lowerKey(K key) {</b>
<b class="nc"><i>2798</i>&nbsp;            return getNearKey(key, LT);</b>
<b class="nc"><i>2799</i>&nbsp;        }</b>
<b class="nc"><i>2800</i>&nbsp;</b>
<i>2801</i>&nbsp;        public Map.Entry&lt;K,V&gt; floorEntry(K key) {
<b class="nc"><i>2802</i>&nbsp;            return getNearEntry(key, LT|EQ);</b>
<i>2803</i>&nbsp;        }
<b class="nc"><i>2804</i>&nbsp;</b>
<b class="nc"><i>2805</i>&nbsp;        public K floorKey(K key) {</b>
<b class="nc"><i>2806</i>&nbsp;            return getNearKey(key, LT|EQ);</b>
<b class="nc"><i>2807</i>&nbsp;        }</b>
<b class="nc"><i>2808</i>&nbsp;</b>
<b class="nc"><i>2809</i>&nbsp;        public Map.Entry&lt;K,V&gt; higherEntry(K key) {</b>
<b class="nc"><i>2810</i>&nbsp;            return getNearEntry(key, GT);</b>
<i>2811</i>&nbsp;        }
<i>2812</i>&nbsp;
<b class="nc"><i>2813</i>&nbsp;        public K higherKey(K key) {</b>
<i>2814</i>&nbsp;            return getNearKey(key, GT);
<i>2815</i>&nbsp;        }
<b class="nc"><i>2816</i>&nbsp;</b>
<b class="nc"><i>2817</i>&nbsp;        public K firstKey() {</b>
<b class="nc"><i>2818</i>&nbsp;            return isDescending ? highestKey() : lowestKey();</b>
<b class="nc"><i>2819</i>&nbsp;        }</b>
<b class="nc"><i>2820</i>&nbsp;</b>
<b class="nc"><i>2821</i>&nbsp;        public K lastKey() {</b>
<b class="nc"><i>2822</i>&nbsp;            return isDescending ? lowestKey() : highestKey();</b>
<b class="nc"><i>2823</i>&nbsp;        }</b>
<i>2824</i>&nbsp;
<i>2825</i>&nbsp;        public Map.Entry&lt;K,V&gt; firstEntry() {
<i>2826</i>&nbsp;            return isDescending ? highestEntry() : lowestEntry();
<i>2827</i>&nbsp;        }
<i>2828</i>&nbsp;
<b class="nc"><i>2829</i>&nbsp;        public Map.Entry&lt;K,V&gt; lastEntry() {</b>
<b class="nc"><i>2830</i>&nbsp;            return isDescending ? lowestEntry() : highestEntry();</b>
<i>2831</i>&nbsp;        }
<i>2832</i>&nbsp;
<i>2833</i>&nbsp;        public Map.Entry&lt;K,V&gt; pollFirstEntry() {
<b class="nc"><i>2834</i>&nbsp;            return isDescending ? removeHighest() : removeLowest();</b>
<b class="nc"><i>2835</i>&nbsp;        }</b>
<i>2836</i>&nbsp;
<i>2837</i>&nbsp;        public Map.Entry&lt;K,V&gt; pollLastEntry() {
<i>2838</i>&nbsp;            return isDescending ? removeLowest() : removeHighest();
<b class="nc"><i>2839</i>&nbsp;        }</b>
<b class="nc"><i>2840</i>&nbsp;</b>
<i>2841</i>&nbsp;        /* ---------------- Submap Views -------------- */
<i>2842</i>&nbsp;
<i>2843</i>&nbsp;        public NavigableSet&lt;K&gt; keySet() {
<b class="nc"><i>2844</i>&nbsp;            KeySet&lt;K,V&gt; ks;</b>
<i>2845</i>&nbsp;            if ((ks = keySetView) != null) return ks;
<i>2846</i>&nbsp;            return keySetView = new KeySet&lt;&gt;(this);
<i>2847</i>&nbsp;        }
<b class="nc"><i>2848</i>&nbsp;</b>
<b class="nc"><i>2849</i>&nbsp;        public NavigableSet&lt;K&gt; navigableKeySet() {</b>
<b class="nc"><i>2850</i>&nbsp;            KeySet&lt;K,V&gt; ks;</b>
<b class="nc"><i>2851</i>&nbsp;            if ((ks = keySetView) != null) return ks;</b>
<b class="nc"><i>2852</i>&nbsp;            return keySetView = new KeySet&lt;&gt;(this);</b>
<b class="nc"><i>2853</i>&nbsp;        }</b>
<b class="nc"><i>2854</i>&nbsp;</b>
<i>2855</i>&nbsp;        public Collection&lt;V&gt; values() {
<b class="nc"><i>2856</i>&nbsp;            Values&lt;K,V&gt; vs;</b>
<i>2857</i>&nbsp;            if ((vs = valuesView) != null) return vs;
<i>2858</i>&nbsp;            return valuesView = new Values&lt;&gt;(this);
<i>2859</i>&nbsp;        }
<b class="nc"><i>2860</i>&nbsp;</b>
<b class="nc"><i>2861</i>&nbsp;        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</b>
<i>2862</i>&nbsp;            EntrySet&lt;K,V&gt; es;
<i>2863</i>&nbsp;            if ((es = entrySetView) != null) return es;
<i>2864</i>&nbsp;            return entrySetView = new EntrySet&lt;K,V&gt;(this);
<b class="nc"><i>2865</i>&nbsp;        }</b>
<b class="nc"><i>2866</i>&nbsp;</b>
<b class="nc"><i>2867</i>&nbsp;        public NavigableSet&lt;K&gt; descendingKeySet() {</b>
<b class="nc"><i>2868</i>&nbsp;            return descendingMap().navigableKeySet();</b>
<b class="nc"><i>2869</i>&nbsp;        }</b>
<b class="nc"><i>2870</i>&nbsp;</b>
<b class="nc"><i>2871</i>&nbsp;        /**</b>
<b class="nc"><i>2872</i>&nbsp;         * Variant of main Iter class to traverse through submaps.</b>
<b class="nc"><i>2873</i>&nbsp;         * Also serves as back-up Spliterator for views.</b>
<i>2874</i>&nbsp;         */
<b class="nc"><i>2875</i>&nbsp;        abstract class SubMapIter&lt;T&gt; implements Iterator&lt;T&gt;, Spliterator&lt;T&gt; {</b>
<i>2876</i>&nbsp;            /** the last node returned by next() */
<i>2877</i>&nbsp;            Node&lt;K,V&gt; lastReturned;
<i>2878</i>&nbsp;            /** the next node to return from next(); */
<b class="nc"><i>2879</i>&nbsp;            Node&lt;K,V&gt; next;</b>
<b class="nc"><i>2880</i>&nbsp;            /** Cache of next value field to maintain weak consistency */</b>
<b class="nc"><i>2881</i>&nbsp;            V nextValue;</b>
<b class="nc"><i>2882</i>&nbsp;</b>
<b class="nc"><i>2883</i>&nbsp;            SubMapIter() {</b>
<b class="nc"><i>2884</i>&nbsp;                VarHandle.acquireFence();</b>
<i>2885</i>&nbsp;                Comparator&lt;? super K&gt; cmp = m.comparator;
<i>2886</i>&nbsp;                for (;;) {
<i>2887</i>&nbsp;                    next = isDescending ? hiNode(cmp) : loNode(cmp);
<i>2888</i>&nbsp;                    if (next == null)
<i>2889</i>&nbsp;                        break;
<i>2890</i>&nbsp;                    V x = next.val;
<b class="nc"><i>2891</i>&nbsp;                    if (x != null) {</b>
<b class="nc"><i>2892</i>&nbsp;                        if (! inBounds(next.key, cmp))</b>
<i>2893</i>&nbsp;                            next = null;
<i>2894</i>&nbsp;                        else
<i>2895</i>&nbsp;                            nextValue = x;
<b class="nc"><i>2896</i>&nbsp;                        break;</b>
<i>2897</i>&nbsp;                    }
<i>2898</i>&nbsp;                }
<i>2899</i>&nbsp;            }
<b class="nc"><i>2900</i>&nbsp;</b>
<b class="nc"><i>2901</i>&nbsp;            public final boolean hasNext() {</b>
<i>2902</i>&nbsp;                return next != null;
<i>2903</i>&nbsp;            }
<i>2904</i>&nbsp;
<b class="nc"><i>2905</i>&nbsp;            final void advance() {</b>
<b class="nc"><i>2906</i>&nbsp;                if (next == null)</b>
<i>2907</i>&nbsp;                    throw new NoSuchElementException();
<i>2908</i>&nbsp;                lastReturned = next;
<i>2909</i>&nbsp;                if (isDescending)
<i>2910</i>&nbsp;                    descend();
<i>2911</i>&nbsp;                else
<b class="nc"><i>2912</i>&nbsp;                    ascend();</b>
<b class="nc"><i>2913</i>&nbsp;            }</b>
<b class="nc"><i>2914</i>&nbsp;</b>
<i>2915</i>&nbsp;            private void ascend() {
<b class="nc"><i>2916</i>&nbsp;                Comparator&lt;? super K&gt; cmp = m.comparator;</b>
<i>2917</i>&nbsp;                for (;;) {
<i>2918</i>&nbsp;                    next = next.next;
<i>2919</i>&nbsp;                    if (next == null)
<i>2920</i>&nbsp;                        break;
<i>2921</i>&nbsp;                    V x = next.val;
<i>2922</i>&nbsp;                    if (x != null) {
<i>2923</i>&nbsp;                        if (tooHigh(next.key, cmp))
<i>2924</i>&nbsp;                            next = null;
<b class="nc"><i>2925</i>&nbsp;                        else</b>
<b class="nc"><i>2926</i>&nbsp;                            nextValue = x;</b>
<b class="nc"><i>2927</i>&nbsp;                        break;</b>
<b class="nc"><i>2928</i>&nbsp;                    }</b>
<b class="nc"><i>2929</i>&nbsp;                }</b>
<b class="nc"><i>2930</i>&nbsp;            }</b>
<b class="nc"><i>2931</i>&nbsp;</b>
<b class="nc"><i>2932</i>&nbsp;            private void descend() {</b>
<i>2933</i>&nbsp;                Comparator&lt;? super K&gt; cmp = m.comparator;
<b class="nc"><i>2934</i>&nbsp;                for (;;) {</b>
<b class="nc"><i>2935</i>&nbsp;                    next = m.findNear(lastReturned.key, LT, cmp);</b>
<b class="nc"><i>2936</i>&nbsp;                    if (next == null)</b>
<b class="nc"><i>2937</i>&nbsp;                        break;</b>
<i>2938</i>&nbsp;                    V x = next.val;
<i>2939</i>&nbsp;                    if (x != null) {
<b class="nc"><i>2940</i>&nbsp;                        if (tooLow(next.key, cmp))</b>
<b class="nc"><i>2941</i>&nbsp;                            next = null;</b>
<b class="nc"><i>2942</i>&nbsp;                        else</b>
<i>2943</i>&nbsp;                            nextValue = x;
<i>2944</i>&nbsp;                        break;
<b class="nc"><i>2945</i>&nbsp;                    }</b>
<b class="nc"><i>2946</i>&nbsp;                }</b>
<b class="nc"><i>2947</i>&nbsp;            }</b>
<b class="nc"><i>2948</i>&nbsp;</b>
<i>2949</i>&nbsp;            public void remove() {
<i>2950</i>&nbsp;                Node&lt;K,V&gt; l = lastReturned;
<b class="nc"><i>2951</i>&nbsp;                if (l == null)</b>
<b class="nc"><i>2952</i>&nbsp;                    throw new IllegalStateException();</b>
<b class="nc"><i>2953</i>&nbsp;                m.remove(l.key);</b>
<i>2954</i>&nbsp;                lastReturned = null;
<i>2955</i>&nbsp;            }
<b class="nc"><i>2956</i>&nbsp;</b>
<i>2957</i>&nbsp;            public Spliterator&lt;T&gt; trySplit() {
<i>2958</i>&nbsp;                return null;
<i>2959</i>&nbsp;            }
<i>2960</i>&nbsp;
<i>2961</i>&nbsp;            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<b class="nc"><i>2962</i>&nbsp;                if (hasNext()) {</b>
<b class="nc"><i>2963</i>&nbsp;                    action.accept(next());</b>
<b class="nc"><i>2964</i>&nbsp;                    return true;</b>
<i>2965</i>&nbsp;                }
<i>2966</i>&nbsp;                return false;
<i>2967</i>&nbsp;            }
<b class="nc"><i>2968</i>&nbsp;</b>
<b class="nc"><i>2969</i>&nbsp;            public void forEachRemaining(Consumer&lt;? super T&gt; action) {</b>
<b class="nc"><i>2970</i>&nbsp;                while (hasNext())</b>
<i>2971</i>&nbsp;                    action.accept(next());
<i>2972</i>&nbsp;            }
<i>2973</i>&nbsp;
<b class="nc"><i>2974</i>&nbsp;            public long estimateSize() {</b>
<b class="nc"><i>2975</i>&nbsp;                return Long.MAX_VALUE;</b>
<b class="nc"><i>2976</i>&nbsp;            }</b>
<i>2977</i>&nbsp;
<i>2978</i>&nbsp;        }
<i>2979</i>&nbsp;
<b class="nc"><i>2980</i>&nbsp;        final class SubMapValueIterator extends SubMapIter&lt;V&gt; {</b>
<i>2981</i>&nbsp;            public V next() {
<i>2982</i>&nbsp;                V v = nextValue;
<i>2983</i>&nbsp;                advance();
<b class="nc"><i>2984</i>&nbsp;                return v;</b>
<i>2985</i>&nbsp;            }
<i>2986</i>&nbsp;            public int characteristics() {
<i>2987</i>&nbsp;                return 0;
<b class="nc"><i>2988</i>&nbsp;            }</b>
<i>2989</i>&nbsp;        }
<i>2990</i>&nbsp;
<i>2991</i>&nbsp;        final class SubMapKeyIterator extends SubMapIter&lt;K&gt; {
<b class="nc"><i>2992</i>&nbsp;            public K next() {</b>
<i>2993</i>&nbsp;                Node&lt;K,V&gt; n = next;
<i>2994</i>&nbsp;                advance();
<i>2995</i>&nbsp;                return n.key;
<i>2996</i>&nbsp;            }
<i>2997</i>&nbsp;            public int characteristics() {
<i>2998</i>&nbsp;                return Spliterator.DISTINCT | Spliterator.ORDERED |
<b class="nc"><i>2999</i>&nbsp;                    Spliterator.SORTED;</b>
<i>3000</i>&nbsp;            }
<i>3001</i>&nbsp;            public final Comparator&lt;? super K&gt; getComparator() {
<i>3002</i>&nbsp;                return SubMap.this.comparator();
<b class="nc"><i>3003</i>&nbsp;            }</b>
<i>3004</i>&nbsp;        }
<i>3005</i>&nbsp;
<i>3006</i>&nbsp;        final class SubMapEntryIterator extends SubMapIter&lt;Map.Entry&lt;K,V&gt;&gt; {
<b class="nc"><i>3007</i>&nbsp;            public Map.Entry&lt;K,V&gt; next() {</b>
<i>3008</i>&nbsp;                Node&lt;K,V&gt; n = next;
<i>3009</i>&nbsp;                V v = nextValue;
<i>3010</i>&nbsp;                advance();
<b class="nc"><i>3011</i>&nbsp;                return new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(n.key, v);</b>
<i>3012</i>&nbsp;            }
<i>3013</i>&nbsp;            public int characteristics() {
<i>3014</i>&nbsp;                return Spliterator.DISTINCT;
<b class="nc"><i>3015</i>&nbsp;            }</b>
<i>3016</i>&nbsp;        }
<i>3017</i>&nbsp;    }
<i>3018</i>&nbsp;
<b class="nc"><i>3019</i>&nbsp;    // default Map method overrides</b>
<i>3020</i>&nbsp;
<i>3021</i>&nbsp;    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<i>3022</i>&nbsp;        if (action == null) throw new NullPointerException();
<b class="nc"><i>3023</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;</b>
<i>3024</i>&nbsp;        if ((b = baseHead()) != null) {
<i>3025</i>&nbsp;            while ((n = b.next) != null) {
<i>3026</i>&nbsp;                if ((v = n.val) != null)
<b class="nc"><i>3027</i>&nbsp;                    action.accept(n.key, v);</b>
<i>3028</i>&nbsp;                b = n;
<i>3029</i>&nbsp;            }
<i>3030</i>&nbsp;        }
<b class="nc"><i>3031</i>&nbsp;    }</b>
<i>3032</i>&nbsp;
<i>3033</i>&nbsp;    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
<i>3034</i>&nbsp;        if (function == null) throw new NullPointerException();
<b class="nc"><i>3035</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;</b>
<i>3036</i>&nbsp;        if ((b = baseHead()) != null) {
<i>3037</i>&nbsp;            while ((n = b.next) != null) {
<i>3038</i>&nbsp;                while ((v = n.val) != null) {
<b class="nc"><i>3039</i>&nbsp;                    V r = function.apply(n.key, v);</b>
<i>3040</i>&nbsp;                    if (r == null) throw new NullPointerException();
<i>3041</i>&nbsp;                    if (VAL.compareAndSet(n, v, r))
<i>3042</i>&nbsp;                        break;
<b class="nc"><i>3043</i>&nbsp;                }</b>
<i>3044</i>&nbsp;                b = n;
<i>3045</i>&nbsp;            }
<i>3046</i>&nbsp;        }
<b class="nc"><i>3047</i>&nbsp;    }</b>
<i>3048</i>&nbsp;
<i>3049</i>&nbsp;    /**
<i>3050</i>&nbsp;     * Helper method for EntrySet.removeIf.
<b class="nc"><i>3051</i>&nbsp;     */</b>
<i>3052</i>&nbsp;    boolean removeEntryIf(Predicate&lt;? super Entry&lt;K,V&gt;&gt; function) {
<i>3053</i>&nbsp;        if (function == null) throw new NullPointerException();
<i>3054</i>&nbsp;        boolean removed = false;
<i>3055</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;
<i>3056</i>&nbsp;        if ((b = baseHead()) != null) {
<b class="nc"><i>3057</i>&nbsp;            while ((n = b.next) != null) {</b>
<b class="nc"><i>3058</i>&nbsp;                if ((v = n.val) != null) {</b>
<i>3059</i>&nbsp;                    K k = n.key;
<i>3060</i>&nbsp;                    Map.Entry&lt;K,V&gt; e = new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v);
<i>3061</i>&nbsp;                    if (function.test(e) &amp;&amp; remove(k, v))
<b class="nc"><i>3062</i>&nbsp;                        removed = true;</b>
<b class="nc"><i>3063</i>&nbsp;                }</b>
<i>3064</i>&nbsp;                b = n;
<i>3065</i>&nbsp;            }
<i>3066</i>&nbsp;        }
<b class="nc"><i>3067</i>&nbsp;        return removed;</b>
<b class="nc"><i>3068</i>&nbsp;    }</b>
<i>3069</i>&nbsp;
<i>3070</i>&nbsp;    /**
<i>3071</i>&nbsp;     * Helper method for Values.removeIf.
<b class="nc"><i>3072</i>&nbsp;     */</b>
<b class="nc"><i>3073</i>&nbsp;    boolean removeValueIf(Predicate&lt;? super V&gt; function) {</b>
<i>3074</i>&nbsp;        if (function == null) throw new NullPointerException();
<i>3075</i>&nbsp;        boolean removed = false;
<i>3076</i>&nbsp;        Node&lt;K,V&gt; b, n; V v;
<b class="nc"><i>3077</i>&nbsp;        if ((b = baseHead()) != null) {</b>
<i>3078</i>&nbsp;            while ((n = b.next) != null) {
<i>3079</i>&nbsp;                if ((v = n.val) != null &amp;&amp; function.test(v) &amp;&amp; remove(n.key, v))
<i>3080</i>&nbsp;                    removed = true;
<b class="nc"><i>3081</i>&nbsp;                b = n;</b>
<i>3082</i>&nbsp;            }
<i>3083</i>&nbsp;        }
<i>3084</i>&nbsp;        return removed;
<b class="nc"><i>3085</i>&nbsp;    }</b>
<i>3086</i>&nbsp;
<i>3087</i>&nbsp;    /**
<i>3088</i>&nbsp;     * Base class providing common structure for Spliterators.
<b class="nc"><i>3089</i>&nbsp;     * (Although not all that much common functionality; as usual for</b>
<i>3090</i>&nbsp;     * view classes, details annoyingly vary in key, value, and entry
<i>3091</i>&nbsp;     * subclasses in ways that are not worth abstracting out for
<i>3092</i>&nbsp;     * internal classes.)
<i>3093</i>&nbsp;     *
<i>3094</i>&nbsp;     * The basic split strategy is to recursively descend from top
<i>3095</i>&nbsp;     * level, row by row, descending to next row when either split
<i>3096</i>&nbsp;     * off, or the end of row is encountered. Control of the number of
<i>3097</i>&nbsp;     * splits relies on some statistical estimation: The expected
<i>3098</i>&nbsp;     * remaining number of elements of a skip list when advancing
<i>3099</i>&nbsp;     * either across or down decreases by about 25%.
<i>3100</i>&nbsp;     */
<i>3101</i>&nbsp;    abstract static class CSLMSpliterator&lt;K,V&gt; {
<i>3102</i>&nbsp;        final Comparator&lt;? super K&gt; comparator;
<i>3103</i>&nbsp;        final K fence;     // exclusive upper bound for keys, or null if to end
<b class="nc"><i>3104</i>&nbsp;        Index&lt;K,V&gt; row;    // the level to split out</b>
<b class="nc"><i>3105</i>&nbsp;        Node&lt;K,V&gt; current; // current traversal node; initialize at origin</b>
<i>3106</i>&nbsp;        long est;          // size estimate
<b class="nc"><i>3107</i>&nbsp;        CSLMSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</b>
<b class="nc"><i>3108</i>&nbsp;                        Node&lt;K,V&gt; origin, K fence, long est) {</b>
<b class="nc"><i>3109</i>&nbsp;            this.comparator = comparator; this.row = row;</b>
<b class="nc"><i>3110</i>&nbsp;            this.current = origin; this.fence = fence; this.est = est;</b>
<b class="nc"><i>3111</i>&nbsp;        }</b>
<b class="nc"><i>3112</i>&nbsp;</b>
<b class="nc"><i>3113</i>&nbsp;        public final long estimateSize() { return est; }</b>
<i>3114</i>&nbsp;    }
<b class="nc"><i>3115</i>&nbsp;</b>
<b class="nc"><i>3116</i>&nbsp;    static final class KeySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;</b>
<i>3117</i>&nbsp;        implements Spliterator&lt;K&gt; {
<b class="nc"><i>3118</i>&nbsp;        KeySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</b>
<i>3119</i>&nbsp;                       Node&lt;K,V&gt; origin, K fence, long est) {
<b class="nc"><i>3120</i>&nbsp;            super(comparator, row, origin, fence, est);</b>
<i>3121</i>&nbsp;        }
<i>3122</i>&nbsp;
<i>3123</i>&nbsp;        public KeySpliterator&lt;K,V&gt; trySplit() {
<b class="nc"><i>3124</i>&nbsp;            Node&lt;K,V&gt; e; K ek;</b>
<i>3125</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;
<i>3126</i>&nbsp;            K f = fence;
<i>3127</i>&nbsp;            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {
<b class="nc"><i>3128</i>&nbsp;                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {</b>
<b class="nc"><i>3129</i>&nbsp;                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</b>
<b class="nc"><i>3130</i>&nbsp;                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</b>
<b class="nc"><i>3131</i>&nbsp;                        (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;</b>
<b class="nc"><i>3132</i>&nbsp;                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;</b>
<i>3133</i>&nbsp;                        (f == null || cpr(cmp, sk, f) &lt; 0)) {
<b class="nc"><i>3134</i>&nbsp;                        current = n;</b>
<i>3135</i>&nbsp;                        Index&lt;K,V&gt; r = q.down;
<i>3136</i>&nbsp;                        row = (s.right != null) ? s : s.down;
<i>3137</i>&nbsp;                        est -= est &gt;&gt;&gt; 2;
<b class="nc"><i>3138</i>&nbsp;                        return new KeySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</b>
<i>3139</i>&nbsp;                    }
<b class="nc"><i>3140</i>&nbsp;                }</b>
<b class="nc"><i>3141</i>&nbsp;            }</b>
<b class="nc"><i>3142</i>&nbsp;            return null;</b>
<b class="nc"><i>3143</i>&nbsp;        }</b>
<b class="nc"><i>3144</i>&nbsp;</b>
<b class="nc"><i>3145</i>&nbsp;        public void forEachRemaining(Consumer&lt;? super K&gt; action) {</b>
<b class="nc"><i>3146</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<i>3147</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;
<b class="nc"><i>3148</i>&nbsp;            K f = fence;</b>
<b class="nc"><i>3149</i>&nbsp;            Node&lt;K,V&gt; e = current;</b>
<i>3150</i>&nbsp;            current = null;
<b class="nc"><i>3151</i>&nbsp;            for (; e != null; e = e.next) {</b>
<i>3152</i>&nbsp;                K k;
<b class="nc"><i>3153</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)</b>
<i>3154</i>&nbsp;                    break;
<i>3155</i>&nbsp;                if (e.val != null)
<i>3156</i>&nbsp;                    action.accept(k);
<b class="nc"><i>3157</i>&nbsp;            }</b>
<i>3158</i>&nbsp;        }
<b class="nc"><i>3159</i>&nbsp;</b>
<b class="nc"><i>3160</i>&nbsp;        public boolean tryAdvance(Consumer&lt;? super K&gt; action) {</b>
<b class="nc"><i>3161</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<b class="nc"><i>3162</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<b class="nc"><i>3163</i>&nbsp;            K f = fence;</b>
<b class="nc"><i>3164</i>&nbsp;            Node&lt;K,V&gt; e = current;</b>
<b class="nc"><i>3165</i>&nbsp;            for (; e != null; e = e.next) {</b>
<i>3166</i>&nbsp;                K k;
<b class="nc"><i>3167</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</b>
<b class="nc"><i>3168</i>&nbsp;                    e = null;</b>
<i>3169</i>&nbsp;                    break;
<b class="nc"><i>3170</i>&nbsp;                }</b>
<i>3171</i>&nbsp;                if (e.val != null) {
<b class="nc"><i>3172</i>&nbsp;                    current = e.next;</b>
<i>3173</i>&nbsp;                    action.accept(k);
<i>3174</i>&nbsp;                    return true;
<i>3175</i>&nbsp;                }
<b class="nc"><i>3176</i>&nbsp;            }</b>
<b class="nc"><i>3177</i>&nbsp;            current = e;</b>
<b class="nc"><i>3178</i>&nbsp;            return false;</b>
<b class="nc"><i>3179</i>&nbsp;        }</b>
<b class="nc"><i>3180</i>&nbsp;</b>
<i>3181</i>&nbsp;        public int characteristics() {
<i>3182</i>&nbsp;            return Spliterator.DISTINCT | Spliterator.SORTED |
<i>3183</i>&nbsp;                Spliterator.ORDERED | Spliterator.CONCURRENT |
<b class="nc"><i>3184</i>&nbsp;                Spliterator.NONNULL;</b>
<i>3185</i>&nbsp;        }
<i>3186</i>&nbsp;
<i>3187</i>&nbsp;        public final Comparator&lt;? super K&gt; getComparator() {
<b class="nc"><i>3188</i>&nbsp;            return comparator;</b>
<b class="nc"><i>3189</i>&nbsp;        }</b>
<b class="nc"><i>3190</i>&nbsp;    }</b>
<i>3191</i>&nbsp;    // factory method for KeySpliterator
<b class="nc"><i>3192</i>&nbsp;    final KeySpliterator&lt;K,V&gt; keySpliterator() {</b>
<i>3193</i>&nbsp;        Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;
<i>3194</i>&nbsp;        VarHandle.acquireFence();
<i>3195</i>&nbsp;        if ((h = head) == null) {
<b class="nc"><i>3196</i>&nbsp;            n = null;</b>
<b class="nc"><i>3197</i>&nbsp;            est = 0L;</b>
<i>3198</i>&nbsp;        }
<i>3199</i>&nbsp;        else {
<i>3200</i>&nbsp;            n = h.node;
<b class="nc"><i>3201</i>&nbsp;            est = getAdderCount();</b>
<i>3202</i>&nbsp;        }
<i>3203</i>&nbsp;        return new KeySpliterator&lt;K,V&gt;(comparator, h, n, null, est);
<i>3204</i>&nbsp;    }
<i>3205</i>&nbsp;
<b class="nc"><i>3206</i>&nbsp;    static final class ValueSpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;</b>
<i>3207</i>&nbsp;        implements Spliterator&lt;V&gt; {
<b class="nc"><i>3208</i>&nbsp;        ValueSpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</b>
<b class="nc"><i>3209</i>&nbsp;                       Node&lt;K,V&gt; origin, K fence, long est) {</b>
<b class="nc"><i>3210</i>&nbsp;            super(comparator, row, origin, fence, est);</b>
<i>3211</i>&nbsp;        }
<i>3212</i>&nbsp;
<b class="nc"><i>3213</i>&nbsp;        public ValueSpliterator&lt;K,V&gt; trySplit() {</b>
<i>3214</i>&nbsp;            Node&lt;K,V&gt; e; K ek;
<i>3215</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;
<i>3216</i>&nbsp;            K f = fence;
<b class="nc"><i>3217</i>&nbsp;            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {</b>
<i>3218</i>&nbsp;                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {
<b class="nc"><i>3219</i>&nbsp;                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</b>
<b class="nc"><i>3220</i>&nbsp;                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;</b>
<b class="nc"><i>3221</i>&nbsp;                        (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;</b>
<i>3222</i>&nbsp;                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;
<i>3223</i>&nbsp;                        (f == null || cpr(cmp, sk, f) &lt; 0)) {
<b class="nc"><i>3224</i>&nbsp;                        current = n;</b>
<i>3225</i>&nbsp;                        Index&lt;K,V&gt; r = q.down;
<i>3226</i>&nbsp;                        row = (s.right != null) ? s : s.down;
<i>3227</i>&nbsp;                        est -= est &gt;&gt;&gt; 2;
<b class="nc"><i>3228</i>&nbsp;                        return new ValueSpliterator&lt;K,V&gt;(cmp, r, e, sk, est);</b>
<i>3229</i>&nbsp;                    }
<i>3230</i>&nbsp;                }
<i>3231</i>&nbsp;            }
<b class="nc"><i>3232</i>&nbsp;            return null;</b>
<i>3233</i>&nbsp;        }
<b class="nc"><i>3234</i>&nbsp;</b>
<b class="nc"><i>3235</i>&nbsp;        public void forEachRemaining(Consumer&lt;? super V&gt; action) {</b>
<b class="nc"><i>3236</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<b class="nc"><i>3237</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<i>3238</i>&nbsp;            K f = fence;
<i>3239</i>&nbsp;            Node&lt;K,V&gt; e = current;
<b class="nc"><i>3240</i>&nbsp;            current = null;</b>
<i>3241</i>&nbsp;            for (; e != null; e = e.next) {
<i>3242</i>&nbsp;                K k; V v;
<i>3243</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)
<i>3244</i>&nbsp;                    break;
<i>3245</i>&nbsp;                if ((v = e.val) != null)
<i>3246</i>&nbsp;                    action.accept(v);
<i>3247</i>&nbsp;            }
<b class="nc"><i>3248</i>&nbsp;        }</b>
<i>3249</i>&nbsp;
<b class="nc"><i>3250</i>&nbsp;        public boolean tryAdvance(Consumer&lt;? super V&gt; action) {</b>
<b class="nc"><i>3251</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<b class="nc"><i>3252</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<i>3253</i>&nbsp;            K f = fence;
<i>3254</i>&nbsp;            Node&lt;K,V&gt; e = current;
<i>3255</i>&nbsp;            for (; e != null; e = e.next) {
<i>3256</i>&nbsp;                K k; V v;
<b class="nc"><i>3257</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {</b>
<i>3258</i>&nbsp;                    e = null;
<b class="nc"><i>3259</i>&nbsp;                    break;</b>
<b class="nc"><i>3260</i>&nbsp;                }</b>
<b class="nc"><i>3261</i>&nbsp;                if ((v = e.val) != null) {</b>
<b class="nc"><i>3262</i>&nbsp;                    current = e.next;</b>
<b class="nc"><i>3263</i>&nbsp;                    action.accept(v);</b>
<b class="nc"><i>3264</i>&nbsp;                    return true;</b>
<b class="nc"><i>3265</i>&nbsp;                }</b>
<i>3266</i>&nbsp;            }
<i>3267</i>&nbsp;            current = e;
<i>3268</i>&nbsp;            return false;
<i>3269</i>&nbsp;        }
<i>3270</i>&nbsp;
<i>3271</i>&nbsp;        public int characteristics() {
<i>3272</i>&nbsp;            return Spliterator.CONCURRENT | Spliterator.ORDERED |
<i>3273</i>&nbsp;                Spliterator.NONNULL;
<i>3274</i>&nbsp;        }
<i>3275</i>&nbsp;    }
<i>3276</i>&nbsp;
<i>3277</i>&nbsp;    // Almost the same as keySpliterator()
<i>3278</i>&nbsp;    final ValueSpliterator&lt;K,V&gt; valueSpliterator() {
<i>3279</i>&nbsp;        Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;
<i>3280</i>&nbsp;        VarHandle.acquireFence();
<i>3281</i>&nbsp;        if ((h = head) == null) {
<i>3282</i>&nbsp;            n = null;
<i>3283</i>&nbsp;            est = 0L;
<i>3284</i>&nbsp;        }
<i>3285</i>&nbsp;        else {
<i>3286</i>&nbsp;            n = h.node;
<i>3287</i>&nbsp;            est = getAdderCount();
<i>3288</i>&nbsp;        }
<i>3289</i>&nbsp;        return new ValueSpliterator&lt;K,V&gt;(comparator, h, n, null, est);
<i>3290</i>&nbsp;    }
<i>3291</i>&nbsp;
<i>3292</i>&nbsp;    static final class EntrySpliterator&lt;K,V&gt; extends CSLMSpliterator&lt;K,V&gt;
<b class="nc"><i>3293</i>&nbsp;        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {</b>
<b class="nc"><i>3294</i>&nbsp;        EntrySpliterator(Comparator&lt;? super K&gt; comparator, Index&lt;K,V&gt; row,</b>
<b class="nc"><i>3295</i>&nbsp;                         Node&lt;K,V&gt; origin, K fence, long est) {</b>
<i>3296</i>&nbsp;            super(comparator, row, origin, fence, est);
<i>3297</i>&nbsp;        }
<b class="nc"><i>3298</i>&nbsp;</b>
<i>3299</i>&nbsp;        public EntrySpliterator&lt;K,V&gt; trySplit() {
<i>3300</i>&nbsp;            Node&lt;K,V&gt; e; K ek;
<i>3301</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;
<i>3302</i>&nbsp;            K f = fence;
<i>3303</i>&nbsp;            if ((e = current) != null &amp;&amp; (ek = e.key) != null) {
<i>3304</i>&nbsp;                for (Index&lt;K,V&gt; q = row; q != null; q = row = q.down) {
<b class="nc"><i>3305</i>&nbsp;                    Index&lt;K,V&gt; s; Node&lt;K,V&gt; b, n; K sk;</b>
<i>3306</i>&nbsp;                    if ((s = q.right) != null &amp;&amp; (b = s.node) != null &amp;&amp;
<i>3307</i>&nbsp;                        (n = b.next) != null &amp;&amp; n.val != null &amp;&amp;
<i>3308</i>&nbsp;                        (sk = n.key) != null &amp;&amp; cpr(cmp, sk, ek) &gt; 0 &amp;&amp;
<i>3309</i>&nbsp;                        (f == null || cpr(cmp, sk, f) &lt; 0)) {
<b class="nc"><i>3310</i>&nbsp;                        current = n;</b>
<b class="nc"><i>3311</i>&nbsp;                        Index&lt;K,V&gt; r = q.down;</b>
<b class="nc"><i>3312</i>&nbsp;                        row = (s.right != null) ? s : s.down;</b>
<b class="nc"><i>3313</i>&nbsp;                        est -= est &gt;&gt;&gt; 2;</b>
<i>3314</i>&nbsp;                        return new EntrySpliterator&lt;K,V&gt;(cmp, r, e, sk, est);
<b class="nc"><i>3315</i>&nbsp;                    }</b>
<i>3316</i>&nbsp;                }
<b class="nc"><i>3317</i>&nbsp;            }</b>
<b class="nc"><i>3318</i>&nbsp;            return null;</b>
<b class="nc"><i>3319</i>&nbsp;        }</b>
<b class="nc"><i>3320</i>&nbsp;</b>
<b class="nc"><i>3321</i>&nbsp;        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</b>
<b class="nc"><i>3322</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<b class="nc"><i>3323</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<i>3324</i>&nbsp;            K f = fence;
<i>3325</i>&nbsp;            Node&lt;K,V&gt; e = current;
<i>3326</i>&nbsp;            current = null;
<b class="nc"><i>3327</i>&nbsp;            for (; e != null; e = e.next) {</b>
<i>3328</i>&nbsp;                K k; V v;
<i>3329</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0)
<i>3330</i>&nbsp;                    break;
<b class="nc"><i>3331</i>&nbsp;                if ((v = e.val) != null) {</b>
<b class="nc"><i>3332</i>&nbsp;                    action.accept</b>
<b class="nc"><i>3333</i>&nbsp;                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));</b>
<b class="nc"><i>3334</i>&nbsp;                }</b>
<b class="nc"><i>3335</i>&nbsp;            }</b>
<b class="nc"><i>3336</i>&nbsp;        }</b>
<i>3337</i>&nbsp;
<b class="nc"><i>3338</i>&nbsp;        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {</b>
<b class="nc"><i>3339</i>&nbsp;            if (action == null) throw new NullPointerException();</b>
<b class="nc"><i>3340</i>&nbsp;            Comparator&lt;? super K&gt; cmp = comparator;</b>
<b class="nc"><i>3341</i>&nbsp;            K f = fence;</b>
<i>3342</i>&nbsp;            Node&lt;K,V&gt; e = current;
<i>3343</i>&nbsp;            for (; e != null; e = e.next) {
<i>3344</i>&nbsp;                K k; V v;
<i>3345</i>&nbsp;                if ((k = e.key) != null &amp;&amp; f != null &amp;&amp; cpr(cmp, f, k) &lt;= 0) {
<b class="nc"><i>3346</i>&nbsp;                    e = null;</b>
<b class="nc"><i>3347</i>&nbsp;                    break;</b>
<b class="nc"><i>3348</i>&nbsp;                }</b>
<b class="nc"><i>3349</i>&nbsp;                if ((v = e.val) != null) {</b>
<b class="nc"><i>3350</i>&nbsp;                    current = e.next;</b>
<i>3351</i>&nbsp;                    action.accept
<b class="nc"><i>3352</i>&nbsp;                        (new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(k, v));</b>
<b class="nc"><i>3353</i>&nbsp;                    return true;</b>
<b class="nc"><i>3354</i>&nbsp;                }</b>
<i>3355</i>&nbsp;            }
<b class="nc"><i>3356</i>&nbsp;            current = e;</b>
<b class="nc"><i>3357</i>&nbsp;            return false;</b>
<b class="nc"><i>3358</i>&nbsp;        }</b>
<b class="nc"><i>3359</i>&nbsp;</b>
<i>3360</i>&nbsp;        public int characteristics() {
<i>3361</i>&nbsp;            return Spliterator.DISTINCT | Spliterator.SORTED |
<b class="nc"><i>3362</i>&nbsp;                Spliterator.ORDERED | Spliterator.CONCURRENT |</b>
<b class="nc"><i>3363</i>&nbsp;                Spliterator.NONNULL;</b>
<i>3364</i>&nbsp;        }
<i>3365</i>&nbsp;
<i>3366</i>&nbsp;        public final Comparator&lt;Map.Entry&lt;K,V&gt;&gt; getComparator() {
<b class="nc"><i>3367</i>&nbsp;            // Adapt or create a key-based comparator</b>
<i>3368</i>&nbsp;            if (comparator != null) {
<i>3369</i>&nbsp;                return Map.Entry.comparingByKey(comparator);
<i>3370</i>&nbsp;            }
<i>3371</i>&nbsp;            else {
<i>3372</i>&nbsp;                return (Comparator&lt;Map.Entry&lt;K,V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {
<b class="nc"><i>3373</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)</b>
<i>3374</i>&nbsp;                    Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();
<i>3375</i>&nbsp;                    return k1.compareTo(e2.getKey());
<i>3376</i>&nbsp;                };
<i>3377</i>&nbsp;            }
<b class="nc"><i>3378</i>&nbsp;        }</b>
<i>3379</i>&nbsp;    }
<i>3380</i>&nbsp;
<b class="nc"><i>3381</i>&nbsp;    // Almost the same as keySpliterator()</b>
<b class="nc"><i>3382</i>&nbsp;    final EntrySpliterator&lt;K,V&gt; entrySpliterator() {</b>
<b class="nc"><i>3383</i>&nbsp;        Index&lt;K,V&gt; h; Node&lt;K,V&gt; n; long est;</b>
<i>3384</i>&nbsp;        VarHandle.acquireFence();
<b class="nc"><i>3385</i>&nbsp;        if ((h = head) == null) {</b>
<b class="nc"><i>3386</i>&nbsp;            n = null;</b>
<i>3387</i>&nbsp;            est = 0L;
<i>3388</i>&nbsp;        }
<i>3389</i>&nbsp;        else {
<i>3390</i>&nbsp;            n = h.node;
<i>3391</i>&nbsp;            est = getAdderCount();
<i>3392</i>&nbsp;        }
<b class="nc"><i>3393</i>&nbsp;        return new EntrySpliterator&lt;K,V&gt;(comparator, h, n, null, est);</b>
<i>3394</i>&nbsp;    }
<i>3395</i>&nbsp;
<i>3396</i>&nbsp;    // VarHandle mechanics
<i>3397</i>&nbsp;    private static final VarHandle HEAD;
<b class="nc"><i>3398</i>&nbsp;    private static final VarHandle ADDER;</b>
<b class="nc"><i>3399</i>&nbsp;    private static final VarHandle NEXT;</b>
<b class="nc"><i>3400</i>&nbsp;    private static final VarHandle VAL;</b>
<b class="nc"><i>3401</i>&nbsp;    private static final VarHandle RIGHT;</b>
<i>3402</i>&nbsp;    static {
<b class="nc"><i>3403</i>&nbsp;        try {</b>
<i>3404</i>&nbsp;            MethodHandles.Lookup l = MethodHandles.lookup();
<b class="nc"><i>3405</i>&nbsp;            HEAD = l.findVarHandle(ConcurrentSkipListMap.class, &quot;head&quot;,</b>
<b class="nc"><i>3406</i>&nbsp;                                   Index.class);</b>
<b class="nc"><i>3407</i>&nbsp;            ADDER = l.findVarHandle(ConcurrentSkipListMap.class, &quot;adder&quot;,</b>
<b class="nc"><i>3408</i>&nbsp;                                    LongAdder.class);</b>
<b class="nc"><i>3409</i>&nbsp;            NEXT = l.findVarHandle(Node.class, &quot;next&quot;, Node.class);</b>
<b class="nc"><i>3410</i>&nbsp;            VAL = l.findVarHandle(Node.class, &quot;val&quot;, Object.class);</b>
<b class="nc"><i>3411</i>&nbsp;            RIGHT = l.findVarHandle(Index.class, &quot;right&quot;, Index.class);</b>
<i>3412</i>&nbsp;        } catch (ReflectiveOperationException e) {
<i>3413</i>&nbsp;            throw new ExceptionInInitializerError(e);
<i>3414</i>&nbsp;        }
<b class="nc"><i>3415</i>&nbsp;    }</b>
<i>3416</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
