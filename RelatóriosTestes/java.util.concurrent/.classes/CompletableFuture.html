


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: CompletableFuture</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.util.concurrent</a> ]
</div>

<h1>Coverage Summary for Class: CompletableFuture (java.util.concurrent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CompletableFuture</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 122)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 645)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CompletableFuture$AltResult</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$AsyncRun</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$AsyncSupply</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$BiAccept</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$BiApply</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$BiCompletion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$BiRelay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$BiRun</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$CoCompletion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$Completion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$OrAccept</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$OrApply</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$OrRelay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$OrRun</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$Signaller</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$ThreadPerTaskExecutor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniAccept</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniApply</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniCompletion</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniCompose</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniExceptionally</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniRelay</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniRun</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CompletableFuture$UniWhenComplete</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 181)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 815)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>3</i>&nbsp; *
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; */
<i>24</i>&nbsp;
<i>25</i>&nbsp;/*
<i>26</i>&nbsp; *
<i>27</i>&nbsp; *
<i>28</i>&nbsp; *
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *
<i>31</i>&nbsp; * Written by Doug Lea with assistance from members of JCP JSR-166
<i>32</i>&nbsp; * Expert Group and released to the public domain, as explained at
<i>33</i>&nbsp; * http://creativecommons.org/publicdomain/zero/1.0/
<i>34</i>&nbsp; */
<i>35</i>&nbsp;
<i>36</i>&nbsp;package java.util.concurrent;
<i>37</i>&nbsp;
<i>38</i>&nbsp;import java.lang.invoke.MethodHandles;
<i>39</i>&nbsp;import java.lang.invoke.VarHandle;
<i>40</i>&nbsp;import java.util.concurrent.locks.LockSupport;
<i>41</i>&nbsp;import java.util.function.BiConsumer;
<i>42</i>&nbsp;import java.util.function.BiFunction;
<i>43</i>&nbsp;import java.util.function.Consumer;
<i>44</i>&nbsp;import java.util.function.Function;
<i>45</i>&nbsp;import java.util.function.Supplier;
<i>46</i>&nbsp;
<i>47</i>&nbsp;/**
<i>48</i>&nbsp; * A {@link Future} that may be explicitly completed (setting its
<i>49</i>&nbsp; * value and status), and may be used as a {@link CompletionStage},
<i>50</i>&nbsp; * supporting dependent functions and actions that trigger upon its
<i>51</i>&nbsp; * completion.
<i>52</i>&nbsp; *
<i>53</i>&nbsp; * &lt;p&gt;When two or more threads attempt to
<i>54</i>&nbsp; * {@link #complete complete},
<i>55</i>&nbsp; * {@link #completeExceptionally completeExceptionally}, or
<i>56</i>&nbsp; * {@link #cancel cancel}
<i>57</i>&nbsp; * a CompletableFuture, only one of them succeeds.
<i>58</i>&nbsp; *
<i>59</i>&nbsp; * &lt;p&gt;In addition to these and related methods for directly
<i>60</i>&nbsp; * manipulating status and results, CompletableFuture implements
<i>61</i>&nbsp; * interface {@link CompletionStage} with the following policies: &lt;ul&gt;
<i>62</i>&nbsp; *
<i>63</i>&nbsp; * &lt;li&gt;Actions supplied for dependent completions of
<i>64</i>&nbsp; * &lt;em&gt;non-async&lt;/em&gt; methods may be performed by the thread that
<i>65</i>&nbsp; * completes the current CompletableFuture, or by any other caller of
<i>66</i>&nbsp; * a completion method.
<i>67</i>&nbsp; *
<i>68</i>&nbsp; * &lt;li&gt;All &lt;em&gt;async&lt;/em&gt; methods without an explicit Executor
<i>69</i>&nbsp; * argument are performed using the {@link ForkJoinPool#commonPool()}
<i>70</i>&nbsp; * (unless it does not support a parallelism level of at least two, in
<i>71</i>&nbsp; * which case, a new Thread is created to run each task).  This may be
<i>72</i>&nbsp; * overridden for non-static methods in subclasses by defining method
<i>73</i>&nbsp; * {@link #defaultExecutor()}. To simplify monitoring, debugging,
<i>74</i>&nbsp; * and tracking, all generated asynchronous tasks are instances of the
<i>75</i>&nbsp; * marker interface {@link AsynchronousCompletionTask}.  Operations
<i>76</i>&nbsp; * with time-delays can use adapter methods defined in this class, for
<i>77</i>&nbsp; * example: {@code supplyAsync(supplier, delayedExecutor(timeout,
<i>78</i>&nbsp; * timeUnit))}.  To support methods with delays and timeouts, this
<i>79</i>&nbsp; * class maintains at most one daemon thread for triggering and
<i>80</i>&nbsp; * cancelling actions, not for running them.
<i>81</i>&nbsp; *
<i>82</i>&nbsp; * &lt;li&gt;All CompletionStage methods are implemented independently of
<i>83</i>&nbsp; * other public methods, so the behavior of one method is not impacted
<i>84</i>&nbsp; * by overrides of others in subclasses.
<i>85</i>&nbsp; *
<i>86</i>&nbsp; * &lt;li&gt;All CompletionStage methods return CompletableFutures.  To
<i>87</i>&nbsp; * restrict usages to only those methods defined in interface
<i>88</i>&nbsp; * CompletionStage, use method {@link #minimalCompletionStage}. Or to
<i>89</i>&nbsp; * ensure only that clients do not themselves modify a future, use
<i>90</i>&nbsp; * method {@link #copy}.
<i>91</i>&nbsp; * &lt;/ul&gt;
<i>92</i>&nbsp; *
<i>93</i>&nbsp; * &lt;p&gt;CompletableFuture also implements {@link Future} with the following
<i>94</i>&nbsp; * policies: &lt;ul&gt;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;li&gt;Since (unlike {@link FutureTask}) this class has no direct
<i>97</i>&nbsp; * control over the computation that causes it to be completed,
<i>98</i>&nbsp; * cancellation is treated as just another form of exceptional
<i>99</i>&nbsp; * completion.  Method {@link #cancel cancel} has the same effect as
<i>100</i>&nbsp; * {@code completeExceptionally(new CancellationException())}. Method
<i>101</i>&nbsp; * {@link #isCompletedExceptionally} can be used to determine if a
<i>102</i>&nbsp; * CompletableFuture completed in any exceptional fashion.
<i>103</i>&nbsp; *
<i>104</i>&nbsp; * &lt;li&gt;In case of exceptional completion with a CompletionException,
<i>105</i>&nbsp; * methods {@link #get()} and {@link #get(long, TimeUnit)} throw an
<i>106</i>&nbsp; * {@link ExecutionException} with the same cause as held in the
<i>107</i>&nbsp; * corresponding CompletionException.  To simplify usage in most
<i>108</i>&nbsp; * contexts, this class also defines methods {@link #join()} and
<i>109</i>&nbsp; * {@link #getNow} that instead throw the CompletionException directly
<i>110</i>&nbsp; * in these cases.
<i>111</i>&nbsp; * &lt;/ul&gt;
<i>112</i>&nbsp; *
<i>113</i>&nbsp; * &lt;p&gt;Arguments used to pass a completion result (that is, for
<i>114</i>&nbsp; * parameters of type {@code T}) for methods accepting them may be
<i>115</i>&nbsp; * null, but passing a null value for any other parameter will result
<i>116</i>&nbsp; * in a {@link NullPointerException} being thrown.
<i>117</i>&nbsp; *
<i>118</i>&nbsp; * &lt;p&gt;Subclasses of this class should normally override the &quot;virtual
<i>119</i>&nbsp; * constructor&quot; method {@link #newIncompleteFuture}, which establishes
<i>120</i>&nbsp; * the concrete type returned by CompletionStage methods. For example,
<i>121</i>&nbsp; * here is a class that substitutes a different default Executor and
<i>122</i>&nbsp; * disables the {@code obtrude} methods:
<i>123</i>&nbsp; *
<i>124</i>&nbsp; * &lt;pre&gt; {@code
<i>125</i>&nbsp; * class MyCompletableFuture&lt;T&gt; extends CompletableFuture&lt;T&gt; {
<i>126</i>&nbsp; *   static final Executor myExecutor = ...;
<i>127</i>&nbsp; *   public MyCompletableFuture() { }
<i>128</i>&nbsp; *   public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
<i>129</i>&nbsp; *     return new MyCompletableFuture&lt;U&gt;(); }
<i>130</i>&nbsp; *   public Executor defaultExecutor() {
<i>131</i>&nbsp; *     return myExecutor; }
<i>132</i>&nbsp; *   public void obtrudeValue(T value) {
<i>133</i>&nbsp; *     throw new UnsupportedOperationException(); }
<i>134</i>&nbsp; *   public void obtrudeException(Throwable ex) {
<i>135</i>&nbsp; *     throw new UnsupportedOperationException(); }
<i>136</i>&nbsp; * }}&lt;/pre&gt;
<i>137</i>&nbsp; *
<i>138</i>&nbsp; * @author Doug Lea
<i>139</i>&nbsp; * @param &lt;T&gt; The result type returned by this future&#39;s {@code join}
<i>140</i>&nbsp; * and {@code get} methods
<i>141</i>&nbsp; * @since 1.8
<i>142</i>&nbsp; */
<i>143</i>&nbsp;public class CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt; {
<i>144</i>&nbsp;
<i>145</i>&nbsp;    /*
<i>146</i>&nbsp;     * Overview:
<i>147</i>&nbsp;     *
<i>148</i>&nbsp;     * A CompletableFuture may have dependent completion actions,
<i>149</i>&nbsp;     * collected in a linked stack. It atomically completes by CASing
<i>150</i>&nbsp;     * a result field, and then pops off and runs those actions. This
<i>151</i>&nbsp;     * applies across normal vs exceptional outcomes, sync vs async
<i>152</i>&nbsp;     * actions, binary triggers, and various forms of completions.
<i>153</i>&nbsp;     *
<i>154</i>&nbsp;     * Non-nullness of volatile field &quot;result&quot; indicates done.  It may
<i>155</i>&nbsp;     * be set directly if known to be thread-confined, else via CAS.
<i>156</i>&nbsp;     * An AltResult is used to box null as a result, as well as to
<i>157</i>&nbsp;     * hold exceptions.  Using a single field makes completion simple
<i>158</i>&nbsp;     * to detect and trigger.  Result encoding and decoding is
<i>159</i>&nbsp;     * straightforward but tedious and adds to the sprawl of trapping
<i>160</i>&nbsp;     * and associating exceptions with targets.  Minor simplifications
<i>161</i>&nbsp;     * rely on (static) NIL (to box null results) being the only
<i>162</i>&nbsp;     * AltResult with a null exception field, so we don&#39;t usually need
<i>163</i>&nbsp;     * explicit comparisons.  Even though some of the generics casts
<i>164</i>&nbsp;     * are unchecked (see SuppressWarnings annotations), they are
<i>165</i>&nbsp;     * placed to be appropriate even if checked.
<i>166</i>&nbsp;     *
<i>167</i>&nbsp;     * Dependent actions are represented by Completion objects linked
<i>168</i>&nbsp;     * as Treiber stacks headed by field &quot;stack&quot;. There are Completion
<i>169</i>&nbsp;     * classes for each kind of action, grouped into:
<i>170</i>&nbsp;     * - single-input (UniCompletion),
<i>171</i>&nbsp;     * - two-input (BiCompletion),
<i>172</i>&nbsp;     * - projected (BiCompletions using exactly one of two inputs),
<i>173</i>&nbsp;     * - shared (CoCompletion, used by the second of two sources),
<i>174</i>&nbsp;     * - zero-input source actions,
<i>175</i>&nbsp;     * - Signallers that unblock waiters.
<i>176</i>&nbsp;     * Class Completion extends ForkJoinTask to enable async execution
<i>177</i>&nbsp;     * (adding no space overhead because we exploit its &quot;tag&quot; methods
<i>178</i>&nbsp;     * to maintain claims). It is also declared as Runnable to allow
<i>179</i>&nbsp;     * usage with arbitrary executors.
<i>180</i>&nbsp;     *
<i>181</i>&nbsp;     * Support for each kind of CompletionStage relies on a separate
<i>182</i>&nbsp;     * class, along with two CompletableFuture methods:
<i>183</i>&nbsp;     *
<i>184</i>&nbsp;     * * A Completion class with name X corresponding to function,
<i>185</i>&nbsp;     *   prefaced with &quot;Uni&quot;, &quot;Bi&quot;, or &quot;Or&quot;. Each class contains
<i>186</i>&nbsp;     *   fields for source(s), actions, and dependent. They are
<i>187</i>&nbsp;     *   boringly similar, differing from others only with respect to
<i>188</i>&nbsp;     *   underlying functional forms. We do this so that users don&#39;t
<i>189</i>&nbsp;     *   encounter layers of adapters in common usages.
<i>190</i>&nbsp;     *
<i>191</i>&nbsp;     * * Boolean CompletableFuture method x(...) (for example
<i>192</i>&nbsp;     *   biApply) takes all of the arguments needed to check that an
<i>193</i>&nbsp;     *   action is triggerable, and then either runs the action or
<i>194</i>&nbsp;     *   arranges its async execution by executing its Completion
<i>195</i>&nbsp;     *   argument, if present. The method returns true if known to be
<i>196</i>&nbsp;     *   complete.
<i>197</i>&nbsp;     *
<i>198</i>&nbsp;     * * Completion method tryFire(int mode) invokes the associated x
<i>199</i>&nbsp;     *   method with its held arguments, and on success cleans up.
<i>200</i>&nbsp;     *   The mode argument allows tryFire to be called twice (SYNC,
<i>201</i>&nbsp;     *   then ASYNC); the first to screen and trap exceptions while
<i>202</i>&nbsp;     *   arranging to execute, and the second when called from a task.
<i>203</i>&nbsp;     *   (A few classes are not used async so take slightly different
<i>204</i>&nbsp;     *   forms.)  The claim() callback suppresses function invocation
<i>205</i>&nbsp;     *   if already claimed by another thread.
<i>206</i>&nbsp;     *
<i>207</i>&nbsp;     * * Some classes (for example UniApply) have separate handling
<i>208</i>&nbsp;     *   code for when known to be thread-confined (&quot;now&quot; methods) and
<i>209</i>&nbsp;     *   for when shared (in tryFire), for efficiency.
<i>210</i>&nbsp;     *
<i>211</i>&nbsp;     * * CompletableFuture method xStage(...) is called from a public
<i>212</i>&nbsp;     *   stage method of CompletableFuture f. It screens user
<i>213</i>&nbsp;     *   arguments and invokes and/or creates the stage object.  If
<i>214</i>&nbsp;     *   not async and already triggerable, the action is run
<i>215</i>&nbsp;     *   immediately.  Otherwise a Completion c is created, and
<i>216</i>&nbsp;     *   submitted to the executor if triggerable, or pushed onto f&#39;s
<i>217</i>&nbsp;     *   stack if not.  Completion actions are started via c.tryFire.
<i>218</i>&nbsp;     *   We recheck after pushing to a source future&#39;s stack to cover
<i>219</i>&nbsp;     *   possible races if the source completes while pushing.
<i>220</i>&nbsp;     *   Classes with two inputs (for example BiApply) deal with races
<i>221</i>&nbsp;     *   across both while pushing actions.  The second completion is
<b class="nc"><i>222</i>&nbsp;     *   a CoCompletion pointing to the first, shared so that at most</b>
<i>223</i>&nbsp;     *   one performs the action.  The multiple-arity methods allOf
<i>224</i>&nbsp;     *   does this pairwise to form trees of completions.  Method
<i>225</i>&nbsp;     *   anyOf is handled differently from allOf because completion of
<b class="nc"><i>226</i>&nbsp;     *   any source should trigger a cleanStack of other sources.</b>
<i>227</i>&nbsp;     *   Each AnyOf completion can reach others via a shared array.
<i>228</i>&nbsp;     *
<i>229</i>&nbsp;     * Note that the generic type parameters of methods vary according
<i>230</i>&nbsp;     * to whether &quot;this&quot; is a source, dependent, or completion.
<b class="nc"><i>231</i>&nbsp;     *</b>
<b class="nc"><i>232</i>&nbsp;     * Method postComplete is called upon completion unless the target</b>
<b class="nc"><i>233</i>&nbsp;     * is guaranteed not to be observable (i.e., not yet returned or</b>
<i>234</i>&nbsp;     * linked). Multiple threads can call postComplete, which
<i>235</i>&nbsp;     * atomically pops each dependent action, and tries to trigger it
<i>236</i>&nbsp;     * via method tryFire, in NESTED mode.  Triggering can propagate
<i>237</i>&nbsp;     * recursively, so NESTED mode returns its completed dependent (if
<b class="nc"><i>238</i>&nbsp;     * one exists) for further processing by its caller (see method</b>
<i>239</i>&nbsp;     * postFire).
<i>240</i>&nbsp;     *
<i>241</i>&nbsp;     * Blocking methods get() and join() rely on Signaller Completions
<i>242</i>&nbsp;     * that wake up waiting threads.  The mechanics are similar to
<i>243</i>&nbsp;     * Treiber stack wait-nodes used in FutureTask, Phaser, and
<i>244</i>&nbsp;     * SynchronousQueue. See their internal documentation for
<b class="nc"><i>245</i>&nbsp;     * algorithmic details.</b>
<i>246</i>&nbsp;     *
<i>247</i>&nbsp;     * Without precautions, CompletableFutures would be prone to
<i>248</i>&nbsp;     * garbage accumulation as chains of Completions build up, each
<b class="nc"><i>249</i>&nbsp;     * pointing back to its sources. So we null out fields as soon as</b>
<i>250</i>&nbsp;     * possible.  The screening checks needed anyway harmlessly ignore
<i>251</i>&nbsp;     * null arguments that may have been obtained during races with
<i>252</i>&nbsp;     * threads nulling out fields.  We also try to unlink non-isLive
<b class="nc"><i>253</i>&nbsp;     * (fired or cancelled) Completions from stacks that might</b>
<i>254</i>&nbsp;     * otherwise never be popped: Method cleanStack always unlinks non
<i>255</i>&nbsp;     * isLive completions from the head of stack; others may
<i>256</i>&nbsp;     * occasionally remain if racing with other cancellations or
<i>257</i>&nbsp;     * removals.
<i>258</i>&nbsp;     *
<b class="nc"><i>259</i>&nbsp;     * Completion fields need not be declared as final or volatile</b>
<i>260</i>&nbsp;     * because they are only visible to other threads upon safe
<i>261</i>&nbsp;     * publication.
<i>262</i>&nbsp;     */
<i>263</i>&nbsp;
<b class="nc"><i>264</i>&nbsp;    volatile Object result;       // Either the result or boxed AltResult</b>
<i>265</i>&nbsp;    volatile Completion stack;    // Top of Treiber stack of dependent actions
<i>266</i>&nbsp;
<i>267</i>&nbsp;    final boolean internalComplete(Object r) { // CAS from null to r
<i>268</i>&nbsp;        return RESULT.compareAndSet(this, null, r);
<i>269</i>&nbsp;    }
<i>270</i>&nbsp;
<i>271</i>&nbsp;    /** Returns true if successfully pushed c onto stack. */
<i>272</i>&nbsp;    final boolean tryPushStack(Completion c) {
<b class="nc"><i>273</i>&nbsp;        Completion h = stack;</b>
<i>274</i>&nbsp;        NEXT.set(c, h);         // CAS piggyback
<i>275</i>&nbsp;        return STACK.compareAndSet(this, h, c);
<i>276</i>&nbsp;    }
<i>277</i>&nbsp;
<i>278</i>&nbsp;    /** Unconditionally pushes c onto stack, retrying if necessary. */
<b class="nc"><i>279</i>&nbsp;    final void pushStack(Completion c) {</b>
<b class="nc"><i>280</i>&nbsp;        do {} while (!tryPushStack(c));</b>
<i>281</i>&nbsp;    }
<i>282</i>&nbsp;
<i>283</i>&nbsp;    /* ------------- Encoding and decoding outcomes -------------- */
<i>284</i>&nbsp;
<i>285</i>&nbsp;    static final class AltResult { // See above
<i>286</i>&nbsp;        final Throwable ex;        // null only for NIL
<i>287</i>&nbsp;        AltResult(Throwable x) { this.ex = x; }
<i>288</i>&nbsp;    }
<i>289</i>&nbsp;
<i>290</i>&nbsp;    /** The encoding of the null value. */
<b class="nc"><i>291</i>&nbsp;    static final AltResult NIL = new AltResult(null);</b>
<b class="nc"><i>292</i>&nbsp;</b>
<b class="nc"><i>293</i>&nbsp;    /** Completes with the null value, unless already completed. */</b>
<b class="nc"><i>294</i>&nbsp;    final boolean completeNull() {</b>
<b class="nc"><i>295</i>&nbsp;        return RESULT.compareAndSet(this, null, NIL);</b>
<i>296</i>&nbsp;    }
<i>297</i>&nbsp;
<i>298</i>&nbsp;    /** Returns the encoding of the given non-exceptional value. */
<i>299</i>&nbsp;    final Object encodeValue(T t) {
<i>300</i>&nbsp;        return (t == null) ? NIL : t;
<i>301</i>&nbsp;    }
<i>302</i>&nbsp;
<i>303</i>&nbsp;    /** Completes with a non-exceptional result, unless already completed. */
<i>304</i>&nbsp;    final boolean completeValue(T t) {
<i>305</i>&nbsp;        return RESULT.compareAndSet(this, null, (t == null) ? NIL : t);
<i>306</i>&nbsp;    }
<b class="nc"><i>307</i>&nbsp;</b>
<b class="nc"><i>308</i>&nbsp;    /**</b>
<i>309</i>&nbsp;     * Returns the encoding of the given (non-null) exception as a
<i>310</i>&nbsp;     * wrapped CompletionException unless it is one already.
<i>311</i>&nbsp;     */
<i>312</i>&nbsp;    static AltResult encodeThrowable(Throwable x) {
<i>313</i>&nbsp;        return new AltResult((x instanceof CompletionException) ? x :
<i>314</i>&nbsp;                             new CompletionException(x));
<i>315</i>&nbsp;    }
<i>316</i>&nbsp;
<b class="nc"><i>317</i>&nbsp;    /** Completes with an exceptional result, unless already completed. */</b>
<i>318</i>&nbsp;    final boolean completeThrowable(Throwable x) {
<i>319</i>&nbsp;        return RESULT.compareAndSet(this, null, encodeThrowable(x));
<i>320</i>&nbsp;    }
<i>321</i>&nbsp;
<i>322</i>&nbsp;    /**
<i>323</i>&nbsp;     * Returns the encoding of the given (non-null) exception as a
<i>324</i>&nbsp;     * wrapped CompletionException unless it is one already.  May
<i>325</i>&nbsp;     * return the given Object r (which must have been the result of a
<b class="nc"><i>326</i>&nbsp;     * source future) if it is equivalent, i.e. if this is a simple</b>
<i>327</i>&nbsp;     * relay of an existing CompletionException.
<i>328</i>&nbsp;     */
<i>329</i>&nbsp;    static Object encodeThrowable(Throwable x, Object r) {
<i>330</i>&nbsp;        if (!(x instanceof CompletionException))
<i>331</i>&nbsp;            x = new CompletionException(x);
<i>332</i>&nbsp;        else if (r instanceof AltResult &amp;&amp; x == ((AltResult)r).ex)
<i>333</i>&nbsp;            return r;
<i>334</i>&nbsp;        return new AltResult(x);
<i>335</i>&nbsp;    }
<i>336</i>&nbsp;
<b class="nc"><i>337</i>&nbsp;    /**</b>
<b class="nc"><i>338</i>&nbsp;     * Completes with the given (non-null) exceptional result as a</b>
<i>339</i>&nbsp;     * wrapped CompletionException unless it is one already, unless
<i>340</i>&nbsp;     * already completed.  May complete with the given Object r
<i>341</i>&nbsp;     * (which must have been the result of a source future) if it is
<i>342</i>&nbsp;     * equivalent, i.e. if this is a simple propagation of an
<i>343</i>&nbsp;     * existing CompletionException.
<i>344</i>&nbsp;     */
<i>345</i>&nbsp;    final boolean completeThrowable(Throwable x, Object r) {
<b class="nc"><i>346</i>&nbsp;        return RESULT.compareAndSet(this, null, encodeThrowable(x, r));</b>
<b class="nc"><i>347</i>&nbsp;    }</b>
<b class="nc"><i>348</i>&nbsp;</b>
<i>349</i>&nbsp;    /**
<b class="nc"><i>350</i>&nbsp;     * Returns the encoding of the given arguments: if the exception</b>
<b class="nc"><i>351</i>&nbsp;     * is non-null, encodes as AltResult.  Otherwise uses the given</b>
<b class="nc"><i>352</i>&nbsp;     * value, boxed as NIL if null.</b>
<b class="nc"><i>353</i>&nbsp;     */</b>
<b class="nc"><i>354</i>&nbsp;    Object encodeOutcome(T t, Throwable x) {</b>
<b class="nc"><i>355</i>&nbsp;        return (x == null) ? (t == null) ? NIL : t : encodeThrowable(x);</b>
<b class="nc"><i>356</i>&nbsp;    }</b>
<b class="nc"><i>357</i>&nbsp;</b>
<i>358</i>&nbsp;    /**
<b class="nc"><i>359</i>&nbsp;     * Returns the encoding of a copied outcome; if exceptional,</b>
<b class="nc"><i>360</i>&nbsp;     * rewraps as a CompletionException, else returns argument.</b>
<i>361</i>&nbsp;     */
<i>362</i>&nbsp;    static Object encodeRelay(Object r) {
<i>363</i>&nbsp;        Throwable x;
<i>364</i>&nbsp;        if (r instanceof AltResult
<i>365</i>&nbsp;            &amp;&amp; (x = ((AltResult)r).ex) != null
<i>366</i>&nbsp;            &amp;&amp; !(x instanceof CompletionException))
<b class="nc"><i>367</i>&nbsp;            r = new AltResult(new CompletionException(x));</b>
<i>368</i>&nbsp;        return r;
<b class="nc"><i>369</i>&nbsp;    }</b>
<b class="nc"><i>370</i>&nbsp;</b>
<b class="nc"><i>371</i>&nbsp;    /**</b>
<b class="nc"><i>372</i>&nbsp;     * Completes with r or a copy of r, unless already completed.</b>
<b class="nc"><i>373</i>&nbsp;     * If exceptional, r is first coerced to a CompletionException.</b>
<b class="nc"><i>374</i>&nbsp;     */</b>
<b class="nc"><i>375</i>&nbsp;    final boolean completeRelay(Object r) {</b>
<i>376</i>&nbsp;        return RESULT.compareAndSet(this, null, encodeRelay(r));
<b class="nc"><i>377</i>&nbsp;    }</b>
<b class="nc"><i>378</i>&nbsp;</b>
<i>379</i>&nbsp;    /**
<i>380</i>&nbsp;     * Reports result using Future.get conventions.
<i>381</i>&nbsp;     */
<i>382</i>&nbsp;    private static Object reportGet(Object r)
<i>383</i>&nbsp;        throws InterruptedException, ExecutionException {
<i>384</i>&nbsp;        if (r == null) // by convention below, null means interrupted
<i>385</i>&nbsp;            throw new InterruptedException();
<i>386</i>&nbsp;        if (r instanceof AltResult) {
<i>387</i>&nbsp;            Throwable x, cause;
<i>388</i>&nbsp;            if ((x = ((AltResult)r).ex) == null)
<i>389</i>&nbsp;                return null;
<i>390</i>&nbsp;            if (x instanceof CancellationException)
<i>391</i>&nbsp;                throw (CancellationException)x;
<i>392</i>&nbsp;            if ((x instanceof CompletionException) &amp;&amp;
<i>393</i>&nbsp;                (cause = x.getCause()) != null)
<b class="nc"><i>394</i>&nbsp;                x = cause;</b>
<i>395</i>&nbsp;            throw new ExecutionException(x);
<i>396</i>&nbsp;        }
<i>397</i>&nbsp;        return r;
<i>398</i>&nbsp;    }
<i>399</i>&nbsp;
<b class="nc"><i>400</i>&nbsp;    /**</b>
<b class="nc"><i>401</i>&nbsp;     * Decodes outcome to return result or throw unchecked exception.</b>
<i>402</i>&nbsp;     */
<i>403</i>&nbsp;    private static Object reportJoin(Object r) {
<b class="nc"><i>404</i>&nbsp;        if (r instanceof AltResult) {</b>
<b class="nc"><i>405</i>&nbsp;            Throwable x;</b>
<i>406</i>&nbsp;            if ((x = ((AltResult)r).ex) == null)
<i>407</i>&nbsp;                return null;
<i>408</i>&nbsp;            if (x instanceof CancellationException)
<i>409</i>&nbsp;                throw (CancellationException)x;
<i>410</i>&nbsp;            if (x instanceof CompletionException)
<i>411</i>&nbsp;                throw (CompletionException)x;
<i>412</i>&nbsp;            throw new CompletionException(x);
<b class="nc"><i>413</i>&nbsp;        }</b>
<b class="nc"><i>414</i>&nbsp;        return r;</b>
<b class="nc"><i>415</i>&nbsp;    }</b>
<b class="nc"><i>416</i>&nbsp;</b>
<i>417</i>&nbsp;    /* ------------- Async task preliminaries -------------- */
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /**
<i>420</i>&nbsp;     * A marker interface identifying asynchronous tasks produced by
<i>421</i>&nbsp;     * {@code async} methods. This may be useful for monitoring,
<i>422</i>&nbsp;     * debugging, and tracking asynchronous activities.
<i>423</i>&nbsp;     *
<i>424</i>&nbsp;     * @since 1.8
<i>425</i>&nbsp;     */
<i>426</i>&nbsp;    public static interface AsynchronousCompletionTask {
<b class="nc"><i>427</i>&nbsp;    }</b>
<i>428</i>&nbsp;
<i>429</i>&nbsp;    private static final boolean USE_COMMON_POOL =
<i>430</i>&nbsp;        (ForkJoinPool.getCommonPoolParallelism() &gt; 1);
<i>431</i>&nbsp;
<i>432</i>&nbsp;    /**
<i>433</i>&nbsp;     * Default executor -- ForkJoinPool.commonPool() unless it cannot
<i>434</i>&nbsp;     * support parallelism.
<i>435</i>&nbsp;     */
<i>436</i>&nbsp;    private static final Executor ASYNC_POOL = USE_COMMON_POOL ?
<i>437</i>&nbsp;        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();
<i>438</i>&nbsp;
<i>439</i>&nbsp;    /** Fallback if ForkJoinPool.commonPool() cannot support parallelism */
<i>440</i>&nbsp;    static final class ThreadPerTaskExecutor implements Executor {
<i>441</i>&nbsp;        public void execute(Runnable r) { new Thread(r).start(); }
<b class="nc"><i>442</i>&nbsp;    }</b>
<b class="nc"><i>443</i>&nbsp;</b>
<b class="nc"><i>444</i>&nbsp;    /**</b>
<i>445</i>&nbsp;     * Null-checks user executor argument, and translates uses of
<i>446</i>&nbsp;     * commonPool to ASYNC_POOL in case parallelism disabled.
<i>447</i>&nbsp;     */
<i>448</i>&nbsp;    static Executor screenExecutor(Executor e) {
<b class="nc"><i>449</i>&nbsp;        if (!USE_COMMON_POOL &amp;&amp; e == ForkJoinPool.commonPool())</b>
<i>450</i>&nbsp;            return ASYNC_POOL;
<i>451</i>&nbsp;        if (e == null) throw new NullPointerException();
<i>452</i>&nbsp;        return e;
<i>453</i>&nbsp;    }
<i>454</i>&nbsp;
<i>455</i>&nbsp;    // Modes for Completion.tryFire. Signedness matters.
<i>456</i>&nbsp;    static final int SYNC   =  0;
<i>457</i>&nbsp;    static final int ASYNC  =  1;
<i>458</i>&nbsp;    static final int NESTED = -1;
<i>459</i>&nbsp;
<i>460</i>&nbsp;    /* ------------- Base Completion classes and operations -------------- */
<i>461</i>&nbsp;
<b class="nc"><i>462</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>463</i>&nbsp;    abstract static class Completion extends ForkJoinTask&lt;Void&gt;</b>
<i>464</i>&nbsp;        implements Runnable, AsynchronousCompletionTask {
<i>465</i>&nbsp;        volatile Completion next;      // Treiber stack link
<b class="nc"><i>466</i>&nbsp;</b>
<b class="nc"><i>467</i>&nbsp;        /**</b>
<b class="nc"><i>468</i>&nbsp;         * Performs completion action if triggered, returning a</b>
<b class="nc"><i>469</i>&nbsp;         * dependent that may need propagation, if one exists.</b>
<b class="nc"><i>470</i>&nbsp;         *</b>
<i>471</i>&nbsp;         * @param mode SYNC, ASYNC, or NESTED
<b class="nc"><i>472</i>&nbsp;         */</b>
<i>473</i>&nbsp;        abstract CompletableFuture&lt;?&gt; tryFire(int mode);
<b class="nc"><i>474</i>&nbsp;</b>
<i>475</i>&nbsp;        /** Returns true if possibly still triggerable. Used by cleanStack. */
<b class="nc"><i>476</i>&nbsp;        abstract boolean isLive();</b>
<i>477</i>&nbsp;
<i>478</i>&nbsp;        public final void run()                { tryFire(ASYNC); }
<i>479</i>&nbsp;        public final boolean exec()            { tryFire(ASYNC); return false; }
<i>480</i>&nbsp;        public final Void getRawResult()       { return null; }
<b class="nc"><i>481</i>&nbsp;        public final void setRawResult(Void v) {}</b>
<b class="nc"><i>482</i>&nbsp;    }</b>
<b class="nc"><i>483</i>&nbsp;</b>
<b class="nc"><i>484</i>&nbsp;    /**</b>
<b class="nc"><i>485</i>&nbsp;     * Pops and tries to trigger all reachable dependents.  Call only</b>
<i>486</i>&nbsp;     * when known to be done.
<b class="nc"><i>487</i>&nbsp;     */</b>
<b class="nc"><i>488</i>&nbsp;    final void postComplete() {</b>
<b class="nc"><i>489</i>&nbsp;        /*</b>
<i>490</i>&nbsp;         * On each step, variable f holds current dependents to pop
<i>491</i>&nbsp;         * and run.  It is extended along only one path at a time,
<b class="nc"><i>492</i>&nbsp;         * pushing others to avoid unbounded recursion.</b>
<b class="nc"><i>493</i>&nbsp;         */</b>
<b class="nc"><i>494</i>&nbsp;        CompletableFuture&lt;?&gt; f = this; Completion h;</b>
<i>495</i>&nbsp;        while ((h = f.stack) != null ||
<b class="nc"><i>496</i>&nbsp;               (f != this &amp;&amp; (h = (f = this).stack) != null)) {</b>
<b class="nc"><i>497</i>&nbsp;            CompletableFuture&lt;?&gt; d; Completion t;</b>
<i>498</i>&nbsp;            if (STACK.compareAndSet(f, h, t = h.next)) {
<i>499</i>&nbsp;                if (t != null) {
<b class="nc"><i>500</i>&nbsp;                    if (f != this) {</b>
<i>501</i>&nbsp;                        pushStack(h);
<i>502</i>&nbsp;                        continue;
<i>503</i>&nbsp;                    }
<i>504</i>&nbsp;                    NEXT.compareAndSet(h, t, null); // try to detach
<i>505</i>&nbsp;                }
<i>506</i>&nbsp;                f = (d = h.tryFire(NESTED)) == null ? this : d;
<i>507</i>&nbsp;            }
<i>508</i>&nbsp;        }
<i>509</i>&nbsp;    }
<i>510</i>&nbsp;
<i>511</i>&nbsp;    /** Traverses stack and unlinks one or more dead Completions, if found. */
<i>512</i>&nbsp;    final void cleanStack() {
<b class="nc"><i>513</i>&nbsp;        Completion p = stack;</b>
<b class="nc"><i>514</i>&nbsp;        // ensure head of stack live</b>
<i>515</i>&nbsp;        for (boolean unlinked = false;;) {
<i>516</i>&nbsp;            if (p == null)
<i>517</i>&nbsp;                return;
<i>518</i>&nbsp;            else if (p.isLive()) {
<i>519</i>&nbsp;                if (unlinked)
<i>520</i>&nbsp;                    return;
<i>521</i>&nbsp;                else
<i>522</i>&nbsp;                    break;
<i>523</i>&nbsp;            }
<b class="nc"><i>524</i>&nbsp;            else if (STACK.weakCompareAndSet(this, p, (p = p.next)))</b>
<b class="nc"><i>525</i>&nbsp;                unlinked = true;</b>
<b class="nc"><i>526</i>&nbsp;            else</b>
<b class="nc"><i>527</i>&nbsp;                p = stack;</b>
<b class="nc"><i>528</i>&nbsp;        }</b>
<b class="nc"><i>529</i>&nbsp;        // try to unlink first non-live</b>
<i>530</i>&nbsp;        for (Completion q = p.next; q != null;) {
<b class="nc"><i>531</i>&nbsp;            Completion s = q.next;</b>
<i>532</i>&nbsp;            if (q.isLive()) {
<i>533</i>&nbsp;                p = q;
<b class="nc"><i>534</i>&nbsp;                q = s;</b>
<i>535</i>&nbsp;            } else if (NEXT.weakCompareAndSet(p, q, s))
<i>536</i>&nbsp;                break;
<i>537</i>&nbsp;            else
<i>538</i>&nbsp;                q = p.next;
<b class="nc"><i>539</i>&nbsp;        }</b>
<b class="nc"><i>540</i>&nbsp;    }</b>
<b class="nc"><i>541</i>&nbsp;</b>
<i>542</i>&nbsp;    /* ------------- One-input Completions -------------- */
<i>543</i>&nbsp;
<i>544</i>&nbsp;    /** A Completion with a source, dependent, and executor. */
<i>545</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>546</i>&nbsp;    abstract static class UniCompletion&lt;T,V&gt; extends Completion {
<i>547</i>&nbsp;        Executor executor;                 // executor to use (null if none)
<i>548</i>&nbsp;        CompletableFuture&lt;V&gt; dep;          // the dependent to complete
<i>549</i>&nbsp;        CompletableFuture&lt;T&gt; src;          // source for action
<i>550</i>&nbsp;
<b class="nc"><i>551</i>&nbsp;        UniCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,</b>
<b class="nc"><i>552</i>&nbsp;                      CompletableFuture&lt;T&gt; src) {</b>
<b class="nc"><i>553</i>&nbsp;            this.executor = executor; this.dep = dep; this.src = src;</b>
<i>554</i>&nbsp;        }
<b class="nc"><i>555</i>&nbsp;</b>
<i>556</i>&nbsp;        /**
<b class="nc"><i>557</i>&nbsp;         * Returns true if action can be run. Call only when known to</b>
<b class="nc"><i>558</i>&nbsp;         * be triggerable. Uses FJ tag bit to ensure that only one</b>
<b class="nc"><i>559</i>&nbsp;         * thread claims ownership.  If async, starts as task -- a</b>
<i>560</i>&nbsp;         * later call to tryFire will run action.
<b class="nc"><i>561</i>&nbsp;         */</b>
<i>562</i>&nbsp;        final boolean claim() {
<b class="nc"><i>563</i>&nbsp;            Executor e = executor;</b>
<i>564</i>&nbsp;            if (compareAndSetForkJoinTaskTag((short)0, (short)1)) {
<i>565</i>&nbsp;                if (e == null)
<i>566</i>&nbsp;                    return true;
<i>567</i>&nbsp;                executor = null; // disable
<i>568</i>&nbsp;                e.execute(this);
<i>569</i>&nbsp;            }
<i>570</i>&nbsp;            return false;
<i>571</i>&nbsp;        }
<b class="nc"><i>572</i>&nbsp;</b>
<i>573</i>&nbsp;        final boolean isLive() { return dep != null; }
<i>574</i>&nbsp;    }
<i>575</i>&nbsp;
<b class="nc"><i>576</i>&nbsp;    /**</b>
<b class="nc"><i>577</i>&nbsp;     * Pushes the given completion unless it completes while trying.</b>
<b class="nc"><i>578</i>&nbsp;     * Caller should first check that result is null.</b>
<b class="nc"><i>579</i>&nbsp;     */</b>
<b class="nc"><i>580</i>&nbsp;    final void unipush(Completion c) {</b>
<i>581</i>&nbsp;        if (c != null) {
<i>582</i>&nbsp;            while (!tryPushStack(c)) {
<i>583</i>&nbsp;                if (result != null) {
<i>584</i>&nbsp;                    NEXT.set(c, null);
<i>585</i>&nbsp;                    break;
<i>586</i>&nbsp;                }
<i>587</i>&nbsp;            }
<b class="nc"><i>588</i>&nbsp;            if (result != null)</b>
<b class="nc"><i>589</i>&nbsp;                c.tryFire(SYNC);</b>
<b class="nc"><i>590</i>&nbsp;        }</b>
<b class="nc"><i>591</i>&nbsp;    }</b>
<b class="nc"><i>592</i>&nbsp;</b>
<b class="nc"><i>593</i>&nbsp;    /**</b>
<b class="nc"><i>594</i>&nbsp;     * Post-processing by dependent after successful UniCompletion tryFire.</b>
<i>595</i>&nbsp;     * Tries to clean stack of source a, and then either runs postComplete
<b class="nc"><i>596</i>&nbsp;     * or returns this to caller, depending on mode.</b>
<i>597</i>&nbsp;     */
<i>598</i>&nbsp;    final CompletableFuture&lt;T&gt; postFire(CompletableFuture&lt;?&gt; a, int mode) {
<b class="nc"><i>599</i>&nbsp;        if (a != null &amp;&amp; a.stack != null) {</b>
<b class="nc"><i>600</i>&nbsp;            Object r;</b>
<b class="nc"><i>601</i>&nbsp;            if ((r = a.result) == null)</b>
<b class="nc"><i>602</i>&nbsp;                a.cleanStack();</b>
<b class="nc"><i>603</i>&nbsp;            if (mode &gt;= 0 &amp;&amp; (r != null || a.result != null))</b>
<b class="nc"><i>604</i>&nbsp;                a.postComplete();</b>
<b class="nc"><i>605</i>&nbsp;        }</b>
<i>606</i>&nbsp;        if (result != null &amp;&amp; stack != null) {
<b class="nc"><i>607</i>&nbsp;            if (mode &lt; 0)</b>
<i>608</i>&nbsp;                return this;
<i>609</i>&nbsp;            else
<i>610</i>&nbsp;                postComplete();
<i>611</i>&nbsp;        }
<b class="nc"><i>612</i>&nbsp;        return null;</b>
<b class="nc"><i>613</i>&nbsp;    }</b>
<b class="nc"><i>614</i>&nbsp;</b>
<b class="nc"><i>615</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>616</i>&nbsp;    static final class UniApply&lt;T,V&gt; extends UniCompletion&lt;T,V&gt; {</b>
<b class="nc"><i>617</i>&nbsp;        Function&lt;? super T,? extends V&gt; fn;</b>
<i>618</i>&nbsp;        UniApply(Executor executor, CompletableFuture&lt;V&gt; dep,
<b class="nc"><i>619</i>&nbsp;                 CompletableFuture&lt;T&gt; src,</b>
<i>620</i>&nbsp;                 Function&lt;? super T,? extends V&gt; fn) {
<i>621</i>&nbsp;            super(executor, dep, src); this.fn = fn;
<i>622</i>&nbsp;        }
<i>623</i>&nbsp;        final CompletableFuture&lt;V&gt; tryFire(int mode) {
<i>624</i>&nbsp;            CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;
<i>625</i>&nbsp;            Object r; Throwable x; Function&lt;? super T,? extends V&gt; f;
<i>626</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<b class="nc"><i>627</i>&nbsp;                || (a = src) == null || (r = a.result) == null)</b>
<i>628</i>&nbsp;                return null;
<i>629</i>&nbsp;            tryComplete: if (d.result == null) {
<i>630</i>&nbsp;                if (r instanceof AltResult) {
<b class="nc"><i>631</i>&nbsp;                    if ((x = ((AltResult)r).ex) != null) {</b>
<b class="nc"><i>632</i>&nbsp;                        d.completeThrowable(x, r);</b>
<b class="nc"><i>633</i>&nbsp;                        break tryComplete;</b>
<b class="nc"><i>634</i>&nbsp;                    }</b>
<b class="nc"><i>635</i>&nbsp;                    r = null;</b>
<i>636</i>&nbsp;                }
<i>637</i>&nbsp;                try {
<i>638</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())
<i>639</i>&nbsp;                        return null;
<i>640</i>&nbsp;                    else {
<i>641</i>&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;
<b class="nc"><i>642</i>&nbsp;                        d.completeValue(f.apply(t));</b>
<b class="nc"><i>643</i>&nbsp;                    }</b>
<b class="nc"><i>644</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>645</i>&nbsp;                    d.completeThrowable(ex);</b>
<b class="nc"><i>646</i>&nbsp;                }</b>
<b class="nc"><i>647</i>&nbsp;            }</b>
<b class="nc"><i>648</i>&nbsp;            dep = null; src = null; fn = null;</b>
<i>649</i>&nbsp;            return d.postFire(a, mode);
<b class="nc"><i>650</i>&nbsp;        }</b>
<i>651</i>&nbsp;    }
<i>652</i>&nbsp;
<b class="nc"><i>653</i>&nbsp;    private &lt;V&gt; CompletableFuture&lt;V&gt; uniApplyStage(</b>
<b class="nc"><i>654</i>&nbsp;        Executor e, Function&lt;? super T,? extends V&gt; f) {</b>
<b class="nc"><i>655</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<b class="nc"><i>656</i>&nbsp;        Object r;</b>
<b class="nc"><i>657</i>&nbsp;        if ((r = result) != null)</b>
<b class="nc"><i>658</i>&nbsp;            return uniApplyNow(r, e, f);</b>
<b class="nc"><i>659</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>660</i>&nbsp;        unipush(new UniApply&lt;T,V&gt;(e, d, this, f));</b>
<i>661</i>&nbsp;        return d;
<b class="nc"><i>662</i>&nbsp;    }</b>
<i>663</i>&nbsp;
<i>664</i>&nbsp;    private &lt;V&gt; CompletableFuture&lt;V&gt; uniApplyNow(
<i>665</i>&nbsp;        Object r, Executor e, Function&lt;? super T,? extends V&gt; f) {
<i>666</i>&nbsp;        Throwable x;
<b class="nc"><i>667</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>668</i>&nbsp;        if (r instanceof AltResult) {</b>
<b class="nc"><i>669</i>&nbsp;            if ((x = ((AltResult)r).ex) != null) {</b>
<b class="nc"><i>670</i>&nbsp;                d.result = encodeThrowable(x, r);</b>
<b class="nc"><i>671</i>&nbsp;                return d;</b>
<b class="nc"><i>672</i>&nbsp;            }</b>
<i>673</i>&nbsp;            r = null;
<b class="nc"><i>674</i>&nbsp;        }</b>
<i>675</i>&nbsp;        try {
<i>676</i>&nbsp;            if (e != null) {
<i>677</i>&nbsp;                e.execute(new UniApply&lt;T,V&gt;(null, d, this, f));
<i>678</i>&nbsp;            } else {
<i>679</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;
<i>680</i>&nbsp;                d.result = d.encodeValue(f.apply(t));
<i>681</i>&nbsp;            }
<b class="nc"><i>682</i>&nbsp;        } catch (Throwable ex) {</b>
<i>683</i>&nbsp;            d.result = encodeThrowable(ex);
<i>684</i>&nbsp;        }
<i>685</i>&nbsp;        return d;
<b class="nc"><i>686</i>&nbsp;    }</b>
<b class="nc"><i>687</i>&nbsp;</b>
<b class="nc"><i>688</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>689</i>&nbsp;    static final class UniAccept&lt;T&gt; extends UniCompletion&lt;T,Void&gt; {</b>
<b class="nc"><i>690</i>&nbsp;        Consumer&lt;? super T&gt; fn;</b>
<i>691</i>&nbsp;        UniAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,
<i>692</i>&nbsp;                  CompletableFuture&lt;T&gt; src, Consumer&lt;? super T&gt; fn) {
<i>693</i>&nbsp;            super(executor, dep, src); this.fn = fn;
<i>694</i>&nbsp;        }
<i>695</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {
<b class="nc"><i>696</i>&nbsp;            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</b>
<b class="nc"><i>697</i>&nbsp;            Object r; Throwable x; Consumer&lt;? super T&gt; f;</b>
<b class="nc"><i>698</i>&nbsp;            if ((d = dep) == null || (f = fn) == null</b>
<b class="nc"><i>699</i>&nbsp;                || (a = src) == null || (r = a.result) == null)</b>
<b class="nc"><i>700</i>&nbsp;                return null;</b>
<i>701</i>&nbsp;            tryComplete: if (d.result == null) {
<i>702</i>&nbsp;                if (r instanceof AltResult) {
<b class="nc"><i>703</i>&nbsp;                    if ((x = ((AltResult)r).ex) != null) {</b>
<b class="nc"><i>704</i>&nbsp;                        d.completeThrowable(x, r);</b>
<b class="nc"><i>705</i>&nbsp;                        break tryComplete;</b>
<b class="nc"><i>706</i>&nbsp;                    }</b>
<b class="nc"><i>707</i>&nbsp;                    r = null;</b>
<b class="nc"><i>708</i>&nbsp;                }</b>
<b class="nc"><i>709</i>&nbsp;                try {</b>
<i>710</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())
<b class="nc"><i>711</i>&nbsp;                        return null;</b>
<i>712</i>&nbsp;                    else {
<i>713</i>&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;
<i>714</i>&nbsp;                        f.accept(t);
<b class="nc"><i>715</i>&nbsp;                        d.completeNull();</b>
<b class="nc"><i>716</i>&nbsp;                    }</b>
<b class="nc"><i>717</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>718</i>&nbsp;                    d.completeThrowable(ex);</b>
<b class="nc"><i>719</i>&nbsp;                }</b>
<b class="nc"><i>720</i>&nbsp;            }</b>
<i>721</i>&nbsp;            dep = null; src = null; fn = null;
<b class="nc"><i>722</i>&nbsp;            return d.postFire(a, mode);</b>
<i>723</i>&nbsp;        }
<i>724</i>&nbsp;    }
<i>725</i>&nbsp;
<i>726</i>&nbsp;    private CompletableFuture&lt;Void&gt; uniAcceptStage(Executor e,
<i>727</i>&nbsp;                                                   Consumer&lt;? super T&gt; f) {
<i>728</i>&nbsp;        if (f == null) throw new NullPointerException();
<i>729</i>&nbsp;        Object r;
<i>730</i>&nbsp;        if ((r = result) != null)
<b class="nc"><i>731</i>&nbsp;            return uniAcceptNow(r, e, f);</b>
<i>732</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();
<i>733</i>&nbsp;        unipush(new UniAccept&lt;T&gt;(e, d, this, f));
<i>734</i>&nbsp;        return d;
<b class="nc"><i>735</i>&nbsp;    }</b>
<b class="nc"><i>736</i>&nbsp;</b>
<b class="nc"><i>737</i>&nbsp;    private CompletableFuture&lt;Void&gt; uniAcceptNow(</b>
<b class="nc"><i>738</i>&nbsp;        Object r, Executor e, Consumer&lt;? super T&gt; f) {</b>
<b class="nc"><i>739</i>&nbsp;        Throwable x;</b>
<i>740</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();
<i>741</i>&nbsp;        if (r instanceof AltResult) {
<i>742</i>&nbsp;            if ((x = ((AltResult)r).ex) != null) {
<i>743</i>&nbsp;                d.result = encodeThrowable(x, r);
<i>744</i>&nbsp;                return d;
<i>745</i>&nbsp;            }
<b class="nc"><i>746</i>&nbsp;            r = null;</b>
<b class="nc"><i>747</i>&nbsp;        }</b>
<b class="nc"><i>748</i>&nbsp;        try {</b>
<b class="nc"><i>749</i>&nbsp;            if (e != null) {</b>
<i>750</i>&nbsp;                e.execute(new UniAccept&lt;T&gt;(null, d, this, f));
<b class="nc"><i>751</i>&nbsp;            } else {</b>
<b class="nc"><i>752</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;</b>
<b class="nc"><i>753</i>&nbsp;                f.accept(t);</b>
<b class="nc"><i>754</i>&nbsp;                d.result = NIL;</b>
<b class="nc"><i>755</i>&nbsp;            }</b>
<i>756</i>&nbsp;        } catch (Throwable ex) {
<b class="nc"><i>757</i>&nbsp;            d.result = encodeThrowable(ex);</b>
<b class="nc"><i>758</i>&nbsp;        }</b>
<i>759</i>&nbsp;        return d;
<b class="nc"><i>760</i>&nbsp;    }</b>
<b class="nc"><i>761</i>&nbsp;</b>
<b class="nc"><i>762</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>763</i>&nbsp;    static final class UniRun&lt;T&gt; extends UniCompletion&lt;T,Void&gt; {</b>
<i>764</i>&nbsp;        Runnable fn;
<b class="nc"><i>765</i>&nbsp;        UniRun(Executor executor, CompletableFuture&lt;Void&gt; dep,</b>
<b class="nc"><i>766</i>&nbsp;               CompletableFuture&lt;T&gt; src, Runnable fn) {</b>
<b class="nc"><i>767</i>&nbsp;            super(executor, dep, src); this.fn = fn;</b>
<b class="nc"><i>768</i>&nbsp;        }</b>
<b class="nc"><i>769</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {</b>
<i>770</i>&nbsp;            CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;
<b class="nc"><i>771</i>&nbsp;            Object r; Throwable x; Runnable f;</b>
<i>772</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>773</i>&nbsp;                || (a = src) == null || (r = a.result) == null)
<i>774</i>&nbsp;                return null;
<i>775</i>&nbsp;            if (d.result == null) {
<b class="nc"><i>776</i>&nbsp;                if (r instanceof AltResult &amp;&amp; (x = ((AltResult)r).ex) != null)</b>
<b class="nc"><i>777</i>&nbsp;                    d.completeThrowable(x, r);</b>
<b class="nc"><i>778</i>&nbsp;                else</b>
<b class="nc"><i>779</i>&nbsp;                    try {</b>
<b class="nc"><i>780</i>&nbsp;                        if (mode &lt;= 0 &amp;&amp; !claim())</b>
<b class="nc"><i>781</i>&nbsp;                            return null;</b>
<i>782</i>&nbsp;                        else {
<b class="nc"><i>783</i>&nbsp;                            f.run();</b>
<i>784</i>&nbsp;                            d.completeNull();
<i>785</i>&nbsp;                        }
<i>786</i>&nbsp;                    } catch (Throwable ex) {
<i>787</i>&nbsp;                        d.completeThrowable(ex);
<i>788</i>&nbsp;                    }
<i>789</i>&nbsp;            }
<i>790</i>&nbsp;            dep = null; src = null; fn = null;
<i>791</i>&nbsp;            return d.postFire(a, mode);
<b class="nc"><i>792</i>&nbsp;        }</b>
<i>793</i>&nbsp;    }
<i>794</i>&nbsp;
<i>795</i>&nbsp;    private CompletableFuture&lt;Void&gt; uniRunStage(Executor e, Runnable f) {
<b class="nc"><i>796</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<b class="nc"><i>797</i>&nbsp;        Object r;</b>
<b class="nc"><i>798</i>&nbsp;        if ((r = result) != null)</b>
<b class="nc"><i>799</i>&nbsp;            return uniRunNow(r, e, f);</b>
<b class="nc"><i>800</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();</b>
<i>801</i>&nbsp;        unipush(new UniRun&lt;T&gt;(e, d, this, f));
<i>802</i>&nbsp;        return d;
<i>803</i>&nbsp;    }
<i>804</i>&nbsp;
<i>805</i>&nbsp;    private CompletableFuture&lt;Void&gt; uniRunNow(Object r, Executor e, Runnable f) {
<i>806</i>&nbsp;        Throwable x;
<i>807</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();
<b class="nc"><i>808</i>&nbsp;        if (r instanceof AltResult &amp;&amp; (x = ((AltResult)r).ex) != null)</b>
<b class="nc"><i>809</i>&nbsp;            d.result = encodeThrowable(x, r);</b>
<b class="nc"><i>810</i>&nbsp;        else</b>
<i>811</i>&nbsp;            try {
<b class="nc"><i>812</i>&nbsp;                if (e != null) {</b>
<b class="nc"><i>813</i>&nbsp;                    e.execute(new UniRun&lt;T&gt;(null, d, this, f));</b>
<b class="nc"><i>814</i>&nbsp;                } else {</b>
<b class="nc"><i>815</i>&nbsp;                    f.run();</b>
<b class="nc"><i>816</i>&nbsp;                    d.result = NIL;</b>
<i>817</i>&nbsp;                }
<b class="nc"><i>818</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>819</i>&nbsp;                d.result = encodeThrowable(ex);</b>
<b class="nc"><i>820</i>&nbsp;            }</b>
<i>821</i>&nbsp;        return d;
<b class="nc"><i>822</i>&nbsp;    }</b>
<b class="nc"><i>823</i>&nbsp;</b>
<b class="nc"><i>824</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>825</i>&nbsp;    static final class UniWhenComplete&lt;T&gt; extends UniCompletion&lt;T,T&gt; {</b>
<i>826</i>&nbsp;        BiConsumer&lt;? super T, ? super Throwable&gt; fn;
<b class="nc"><i>827</i>&nbsp;        UniWhenComplete(Executor executor, CompletableFuture&lt;T&gt; dep,</b>
<i>828</i>&nbsp;                        CompletableFuture&lt;T&gt; src,
<i>829</i>&nbsp;                        BiConsumer&lt;? super T, ? super Throwable&gt; fn) {
<i>830</i>&nbsp;            super(executor, dep, src); this.fn = fn;
<i>831</i>&nbsp;        }
<b class="nc"><i>832</i>&nbsp;        final CompletableFuture&lt;T&gt; tryFire(int mode) {</b>
<b class="nc"><i>833</i>&nbsp;            CompletableFuture&lt;T&gt; d; CompletableFuture&lt;T&gt; a;</b>
<b class="nc"><i>834</i>&nbsp;            Object r; BiConsumer&lt;? super T, ? super Throwable&gt; f;</b>
<b class="nc"><i>835</i>&nbsp;            if ((d = dep) == null || (f = fn) == null</b>
<b class="nc"><i>836</i>&nbsp;                || (a = src) == null || (r = a.result) == null</b>
<b class="nc"><i>837</i>&nbsp;                || !d.uniWhenComplete(r, f, mode &gt; 0 ? null : this))</b>
<i>838</i>&nbsp;                return null;
<b class="nc"><i>839</i>&nbsp;            dep = null; src = null; fn = null;</b>
<i>840</i>&nbsp;            return d.postFire(a, mode);
<i>841</i>&nbsp;        }
<i>842</i>&nbsp;    }
<i>843</i>&nbsp;
<i>844</i>&nbsp;    final boolean uniWhenComplete(Object r,
<i>845</i>&nbsp;                                  BiConsumer&lt;? super T,? super Throwable&gt; f,
<i>846</i>&nbsp;                                  UniWhenComplete&lt;T&gt; c) {
<b class="nc"><i>847</i>&nbsp;        T t; Throwable x = null;</b>
<i>848</i>&nbsp;        if (result == null) {
<i>849</i>&nbsp;            try {
<i>850</i>&nbsp;                if (c != null &amp;&amp; !c.claim())
<i>851</i>&nbsp;                    return false;
<b class="nc"><i>852</i>&nbsp;                if (r instanceof AltResult) {</b>
<b class="nc"><i>853</i>&nbsp;                    x = ((AltResult)r).ex;</b>
<b class="nc"><i>854</i>&nbsp;                    t = null;</b>
<b class="nc"><i>855</i>&nbsp;                } else {</b>
<i>856</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) T tr = (T) r;
<i>857</i>&nbsp;                    t = tr;
<i>858</i>&nbsp;                }
<i>859</i>&nbsp;                f.accept(t, x);
<i>860</i>&nbsp;                if (x == null) {
<i>861</i>&nbsp;                    internalComplete(r);
<i>862</i>&nbsp;                    return true;
<b class="nc"><i>863</i>&nbsp;                }</b>
<b class="nc"><i>864</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>865</i>&nbsp;                if (x == null)</b>
<i>866</i>&nbsp;                    x = ex;
<b class="nc"><i>867</i>&nbsp;                else if (x != ex)</b>
<b class="nc"><i>868</i>&nbsp;                    x.addSuppressed(ex);</b>
<b class="nc"><i>869</i>&nbsp;            }</b>
<b class="nc"><i>870</i>&nbsp;            completeThrowable(x, r);</b>
<i>871</i>&nbsp;        }
<b class="nc"><i>872</i>&nbsp;        return true;</b>
<b class="nc"><i>873</i>&nbsp;    }</b>
<b class="nc"><i>874</i>&nbsp;</b>
<b class="nc"><i>875</i>&nbsp;    private CompletableFuture&lt;T&gt; uniWhenCompleteStage(</b>
<i>876</i>&nbsp;        Executor e, BiConsumer&lt;? super T, ? super Throwable&gt; f) {
<b class="nc"><i>877</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<i>878</i>&nbsp;        CompletableFuture&lt;T&gt; d = newIncompleteFuture();
<i>879</i>&nbsp;        Object r;
<i>880</i>&nbsp;        if ((r = result) == null)
<i>881</i>&nbsp;            unipush(new UniWhenComplete&lt;T&gt;(e, d, this, f));
<b class="nc"><i>882</i>&nbsp;        else if (e == null)</b>
<b class="nc"><i>883</i>&nbsp;            d.uniWhenComplete(r, f, null);</b>
<b class="nc"><i>884</i>&nbsp;        else {</b>
<b class="nc"><i>885</i>&nbsp;            try {</b>
<b class="nc"><i>886</i>&nbsp;                e.execute(new UniWhenComplete&lt;T&gt;(null, d, this, f));</b>
<b class="nc"><i>887</i>&nbsp;            } catch (Throwable ex) {</b>
<i>888</i>&nbsp;                d.result = encodeThrowable(ex);
<b class="nc"><i>889</i>&nbsp;            }</b>
<i>890</i>&nbsp;        }
<i>891</i>&nbsp;        return d;
<i>892</i>&nbsp;    }
<i>893</i>&nbsp;
<i>894</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<b class="nc"><i>895</i>&nbsp;    static final class UniHandle&lt;T,V&gt; extends UniCompletion&lt;T,V&gt; {</b>
<i>896</i>&nbsp;        BiFunction&lt;? super T, Throwable, ? extends V&gt; fn;
<i>897</i>&nbsp;        UniHandle(Executor executor, CompletableFuture&lt;V&gt; dep,
<i>898</i>&nbsp;                  CompletableFuture&lt;T&gt; src,
<b class="nc"><i>899</i>&nbsp;                  BiFunction&lt;? super T, Throwable, ? extends V&gt; fn) {</b>
<b class="nc"><i>900</i>&nbsp;            super(executor, dep, src); this.fn = fn;</b>
<b class="nc"><i>901</i>&nbsp;        }</b>
<b class="nc"><i>902</i>&nbsp;        final CompletableFuture&lt;V&gt; tryFire(int mode) {</b>
<i>903</i>&nbsp;            CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;
<i>904</i>&nbsp;            Object r; BiFunction&lt;? super T, Throwable, ? extends V&gt; f;
<i>905</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>906</i>&nbsp;                || (a = src) == null || (r = a.result) == null
<i>907</i>&nbsp;                || !d.uniHandle(r, f, mode &gt; 0 ? null : this))
<b class="nc"><i>908</i>&nbsp;                return null;</b>
<b class="nc"><i>909</i>&nbsp;            dep = null; src = null; fn = null;</b>
<b class="nc"><i>910</i>&nbsp;            return d.postFire(a, mode);</b>
<b class="nc"><i>911</i>&nbsp;        }</b>
<b class="nc"><i>912</i>&nbsp;    }</b>
<i>913</i>&nbsp;
<i>914</i>&nbsp;    final &lt;S&gt; boolean uniHandle(Object r,
<i>915</i>&nbsp;                                BiFunction&lt;? super S, Throwable, ? extends T&gt; f,
<i>916</i>&nbsp;                                UniHandle&lt;S,T&gt; c) {
<i>917</i>&nbsp;        S s; Throwable x;
<i>918</i>&nbsp;        if (result == null) {
<i>919</i>&nbsp;            try {
<i>920</i>&nbsp;                if (c != null &amp;&amp; !c.claim())
<b class="nc"><i>921</i>&nbsp;                    return false;</b>
<i>922</i>&nbsp;                if (r instanceof AltResult) {
<i>923</i>&nbsp;                    x = ((AltResult)r).ex;
<i>924</i>&nbsp;                    s = null;
<b class="nc"><i>925</i>&nbsp;                } else {</b>
<b class="nc"><i>926</i>&nbsp;                    x = null;</b>
<b class="nc"><i>927</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) S ss = (S) r;</b>
<b class="nc"><i>928</i>&nbsp;                    s = ss;</b>
<b class="nc"><i>929</i>&nbsp;                }</b>
<i>930</i>&nbsp;                completeValue(f.apply(s, x));
<i>931</i>&nbsp;            } catch (Throwable ex) {
<i>932</i>&nbsp;                completeThrowable(ex);
<i>933</i>&nbsp;            }
<i>934</i>&nbsp;        }
<i>935</i>&nbsp;        return true;
<i>936</i>&nbsp;    }
<i>937</i>&nbsp;
<b class="nc"><i>938</i>&nbsp;    private &lt;V&gt; CompletableFuture&lt;V&gt; uniHandleStage(</b>
<b class="nc"><i>939</i>&nbsp;        Executor e, BiFunction&lt;? super T, Throwable, ? extends V&gt; f) {</b>
<b class="nc"><i>940</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<b class="nc"><i>941</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>942</i>&nbsp;        Object r;</b>
<b class="nc"><i>943</i>&nbsp;        if ((r = result) == null)</b>
<b class="nc"><i>944</i>&nbsp;            unipush(new UniHandle&lt;T,V&gt;(e, d, this, f));</b>
<i>945</i>&nbsp;        else if (e == null)
<b class="nc"><i>946</i>&nbsp;            d.uniHandle(r, f, null);</b>
<i>947</i>&nbsp;        else {
<i>948</i>&nbsp;            try {
<b class="nc"><i>949</i>&nbsp;                e.execute(new UniHandle&lt;T,V&gt;(null, d, this, f));</b>
<b class="nc"><i>950</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>951</i>&nbsp;                d.result = encodeThrowable(ex);</b>
<b class="nc"><i>952</i>&nbsp;            }</b>
<b class="nc"><i>953</i>&nbsp;        }</b>
<b class="nc"><i>954</i>&nbsp;        return d;</b>
<b class="nc"><i>955</i>&nbsp;    }</b>
<b class="nc"><i>956</i>&nbsp;</b>
<b class="nc"><i>957</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>958</i>&nbsp;    static final class UniExceptionally&lt;T&gt; extends UniCompletion&lt;T,T&gt; {</b>
<i>959</i>&nbsp;        Function&lt;? super Throwable, ? extends T&gt; fn;
<b class="nc"><i>960</i>&nbsp;        UniExceptionally(CompletableFuture&lt;T&gt; dep, CompletableFuture&lt;T&gt; src,</b>
<b class="nc"><i>961</i>&nbsp;                         Function&lt;? super Throwable, ? extends T&gt; fn) {</b>
<b class="nc"><i>962</i>&nbsp;            super(null, dep, src); this.fn = fn;</b>
<i>963</i>&nbsp;        }
<b class="nc"><i>964</i>&nbsp;        final CompletableFuture&lt;T&gt; tryFire(int mode) { // never ASYNC</b>
<i>965</i>&nbsp;            // assert mode != ASYNC;
<i>966</i>&nbsp;            CompletableFuture&lt;T&gt; d; CompletableFuture&lt;T&gt; a;
<i>967</i>&nbsp;            Object r; Function&lt;? super Throwable, ? extends T&gt; f;
<i>968</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<b class="nc"><i>969</i>&nbsp;                || (a = src) == null || (r = a.result) == null</b>
<i>970</i>&nbsp;                || !d.uniExceptionally(r, f, this))
<b class="nc"><i>971</i>&nbsp;                return null;</b>
<i>972</i>&nbsp;            dep = null; src = null; fn = null;
<b class="nc"><i>973</i>&nbsp;            return d.postFire(a, mode);</b>
<b class="nc"><i>974</i>&nbsp;        }</b>
<b class="nc"><i>975</i>&nbsp;    }</b>
<i>976</i>&nbsp;
<b class="nc"><i>977</i>&nbsp;    final boolean uniExceptionally(Object r,</b>
<i>978</i>&nbsp;                                   Function&lt;? super Throwable, ? extends T&gt; f,
<i>979</i>&nbsp;                                   UniExceptionally&lt;T&gt; c) {
<b class="nc"><i>980</i>&nbsp;        Throwable x;</b>
<b class="nc"><i>981</i>&nbsp;        if (result == null) {</b>
<b class="nc"><i>982</i>&nbsp;            try {</b>
<b class="nc"><i>983</i>&nbsp;                if (r instanceof AltResult &amp;&amp; (x = ((AltResult)r).ex) != null) {</b>
<b class="nc"><i>984</i>&nbsp;                    if (c != null &amp;&amp; !c.claim())</b>
<b class="nc"><i>985</i>&nbsp;                        return false;</b>
<b class="nc"><i>986</i>&nbsp;                    completeValue(f.apply(x));</b>
<b class="nc"><i>987</i>&nbsp;                } else</b>
<b class="nc"><i>988</i>&nbsp;                    internalComplete(r);</b>
<b class="nc"><i>989</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>990</i>&nbsp;                completeThrowable(ex);</b>
<b class="nc"><i>991</i>&nbsp;            }</b>
<i>992</i>&nbsp;        }
<i>993</i>&nbsp;        return true;
<b class="nc"><i>994</i>&nbsp;    }</b>
<b class="nc"><i>995</i>&nbsp;</b>
<b class="nc"><i>996</i>&nbsp;    private CompletableFuture&lt;T&gt; uniExceptionallyStage(</b>
<b class="nc"><i>997</i>&nbsp;        Function&lt;Throwable, ? extends T&gt; f) {</b>
<b class="nc"><i>998</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<i>999</i>&nbsp;        CompletableFuture&lt;T&gt; d = newIncompleteFuture();
<i>1000</i>&nbsp;        Object r;
<i>1001</i>&nbsp;        if ((r = result) == null)
<i>1002</i>&nbsp;            unipush(new UniExceptionally&lt;T&gt;(d, this, f));
<i>1003</i>&nbsp;        else
<i>1004</i>&nbsp;            d.uniExceptionally(r, f, null);
<i>1005</i>&nbsp;        return d;
<i>1006</i>&nbsp;    }
<i>1007</i>&nbsp;
<i>1008</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<b class="nc"><i>1009</i>&nbsp;    static final class UniRelay&lt;U, T extends U&gt; extends UniCompletion&lt;T,U&gt; {</b>
<i>1010</i>&nbsp;        UniRelay(CompletableFuture&lt;U&gt; dep, CompletableFuture&lt;T&gt; src) {
<i>1011</i>&nbsp;            super(null, dep, src);
<i>1012</i>&nbsp;        }
<i>1013</i>&nbsp;        final CompletableFuture&lt;U&gt; tryFire(int mode) {
<i>1014</i>&nbsp;            CompletableFuture&lt;U&gt; d; CompletableFuture&lt;T&gt; a; Object r;
<i>1015</i>&nbsp;            if ((d = dep) == null
<i>1016</i>&nbsp;                || (a = src) == null || (r = a.result) == null)
<b class="nc"><i>1017</i>&nbsp;                return null;</b>
<i>1018</i>&nbsp;            if (d.result == null)
<i>1019</i>&nbsp;                d.completeRelay(r);
<b class="nc"><i>1020</i>&nbsp;            src = null; dep = null;</b>
<b class="nc"><i>1021</i>&nbsp;            return d.postFire(a, mode);</b>
<b class="nc"><i>1022</i>&nbsp;        }</b>
<b class="nc"><i>1023</i>&nbsp;    }</b>
<i>1024</i>&nbsp;
<i>1025</i>&nbsp;    private static &lt;U, T extends U&gt; CompletableFuture&lt;U&gt; uniCopyStage(
<i>1026</i>&nbsp;        CompletableFuture&lt;T&gt; src) {
<b class="nc"><i>1027</i>&nbsp;        Object r;</b>
<i>1028</i>&nbsp;        CompletableFuture&lt;U&gt; d = src.newIncompleteFuture();
<i>1029</i>&nbsp;        if ((r = src.result) != null)
<i>1030</i>&nbsp;            d.result = encodeRelay(r);
<i>1031</i>&nbsp;        else
<i>1032</i>&nbsp;            src.unipush(new UniRelay&lt;U,T&gt;(d, src));
<b class="nc"><i>1033</i>&nbsp;        return d;</b>
<i>1034</i>&nbsp;    }
<b class="nc"><i>1035</i>&nbsp;</b>
<b class="nc"><i>1036</i>&nbsp;    private MinimalStage&lt;T&gt; uniAsMinimalStage() {</b>
<b class="nc"><i>1037</i>&nbsp;        Object r;</b>
<b class="nc"><i>1038</i>&nbsp;        if ((r = result) != null)</b>
<b class="nc"><i>1039</i>&nbsp;            return new MinimalStage&lt;T&gt;(encodeRelay(r));</b>
<b class="nc"><i>1040</i>&nbsp;        MinimalStage&lt;T&gt; d = new MinimalStage&lt;T&gt;();</b>
<i>1041</i>&nbsp;        unipush(new UniRelay&lt;T,T&gt;(d, this));
<i>1042</i>&nbsp;        return d;
<i>1043</i>&nbsp;    }
<i>1044</i>&nbsp;
<i>1045</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1046</i>&nbsp;    static final class UniCompose&lt;T,V&gt; extends UniCompletion&lt;T,V&gt; {
<i>1047</i>&nbsp;        Function&lt;? super T, ? extends CompletionStage&lt;V&gt;&gt; fn;
<b class="nc"><i>1048</i>&nbsp;        UniCompose(Executor executor, CompletableFuture&lt;V&gt; dep,</b>
<b class="nc"><i>1049</i>&nbsp;                   CompletableFuture&lt;T&gt; src,</b>
<b class="nc"><i>1050</i>&nbsp;                   Function&lt;? super T, ? extends CompletionStage&lt;V&gt;&gt; fn) {</b>
<i>1051</i>&nbsp;            super(executor, dep, src); this.fn = fn;
<b class="nc"><i>1052</i>&nbsp;        }</b>
<i>1053</i>&nbsp;        final CompletableFuture&lt;V&gt; tryFire(int mode) {
<b class="nc"><i>1054</i>&nbsp;            CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;</b>
<i>1055</i>&nbsp;            Function&lt;? super T, ? extends CompletionStage&lt;V&gt;&gt; f;
<i>1056</i>&nbsp;            Object r; Throwable x;
<i>1057</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>1058</i>&nbsp;                || (a = src) == null || (r = a.result) == null)
<i>1059</i>&nbsp;                return null;
<i>1060</i>&nbsp;            tryComplete: if (d.result == null) {
<i>1061</i>&nbsp;                if (r instanceof AltResult) {
<i>1062</i>&nbsp;                    if ((x = ((AltResult)r).ex) != null) {
<b class="nc"><i>1063</i>&nbsp;                        d.completeThrowable(x, r);</b>
<i>1064</i>&nbsp;                        break tryComplete;
<i>1065</i>&nbsp;                    }
<i>1066</i>&nbsp;                    r = null;
<i>1067</i>&nbsp;                }
<i>1068</i>&nbsp;                try {
<b class="nc"><i>1069</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())</b>
<b class="nc"><i>1070</i>&nbsp;                        return null;</b>
<b class="nc"><i>1071</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;</b>
<b class="nc"><i>1072</i>&nbsp;                    CompletableFuture&lt;V&gt; g = f.apply(t).toCompletableFuture();</b>
<b class="nc"><i>1073</i>&nbsp;                    if ((r = g.result) != null)</b>
<i>1074</i>&nbsp;                        d.completeRelay(r);
<i>1075</i>&nbsp;                    else {
<i>1076</i>&nbsp;                        g.unipush(new UniRelay&lt;V,V&gt;(d, g));
<i>1077</i>&nbsp;                        if (d.result == null)
<i>1078</i>&nbsp;                            return null;
<i>1079</i>&nbsp;                    }
<i>1080</i>&nbsp;                } catch (Throwable ex) {
<i>1081</i>&nbsp;                    d.completeThrowable(ex);
<b class="nc"><i>1082</i>&nbsp;                }</b>
<i>1083</i>&nbsp;            }
<b class="nc"><i>1084</i>&nbsp;            dep = null; src = null; fn = null;</b>
<b class="nc"><i>1085</i>&nbsp;            return d.postFire(a, mode);</b>
<b class="nc"><i>1086</i>&nbsp;        }</b>
<b class="nc"><i>1087</i>&nbsp;    }</b>
<b class="nc"><i>1088</i>&nbsp;</b>
<b class="nc"><i>1089</i>&nbsp;    private &lt;V&gt; CompletableFuture&lt;V&gt; uniComposeStage(</b>
<i>1090</i>&nbsp;        Executor e, Function&lt;? super T, ? extends CompletionStage&lt;V&gt;&gt; f) {
<b class="nc"><i>1091</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<i>1092</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();
<b class="nc"><i>1093</i>&nbsp;        Object r, s; Throwable x;</b>
<b class="nc"><i>1094</i>&nbsp;        if ((r = result) == null)</b>
<b class="nc"><i>1095</i>&nbsp;            unipush(new UniCompose&lt;T,V&gt;(e, d, this, f));</b>
<b class="nc"><i>1096</i>&nbsp;        else if (e == null) {</b>
<i>1097</i>&nbsp;            if (r instanceof AltResult) {
<b class="nc"><i>1098</i>&nbsp;                if ((x = ((AltResult)r).ex) != null) {</b>
<i>1099</i>&nbsp;                    d.result = encodeThrowable(x, r);
<i>1100</i>&nbsp;                    return d;
<b class="nc"><i>1101</i>&nbsp;                }</b>
<b class="nc"><i>1102</i>&nbsp;                r = null;</b>
<b class="nc"><i>1103</i>&nbsp;            }</b>
<b class="nc"><i>1104</i>&nbsp;            try {</b>
<b class="nc"><i>1105</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;</b>
<b class="nc"><i>1106</i>&nbsp;                CompletableFuture&lt;V&gt; g = f.apply(t).toCompletableFuture();</b>
<b class="nc"><i>1107</i>&nbsp;                if ((s = g.result) != null)</b>
<b class="nc"><i>1108</i>&nbsp;                    d.result = encodeRelay(s);</b>
<i>1109</i>&nbsp;                else {
<b class="nc"><i>1110</i>&nbsp;                    g.unipush(new UniRelay&lt;V,V&gt;(d, g));</b>
<i>1111</i>&nbsp;                }
<i>1112</i>&nbsp;            } catch (Throwable ex) {
<i>1113</i>&nbsp;                d.result = encodeThrowable(ex);
<i>1114</i>&nbsp;            }
<i>1115</i>&nbsp;        }
<i>1116</i>&nbsp;        else
<b class="nc"><i>1117</i>&nbsp;            try {</b>
<b class="nc"><i>1118</i>&nbsp;                e.execute(new UniCompose&lt;T,V&gt;(null, d, this, f));</b>
<b class="nc"><i>1119</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>1120</i>&nbsp;                d.result = encodeThrowable(ex);</b>
<b class="nc"><i>1121</i>&nbsp;            }</b>
<b class="nc"><i>1122</i>&nbsp;        return d;</b>
<b class="nc"><i>1123</i>&nbsp;    }</b>
<i>1124</i>&nbsp;
<b class="nc"><i>1125</i>&nbsp;    /* ------------- Two-input Completions -------------- */</b>
<i>1126</i>&nbsp;
<i>1127</i>&nbsp;    /** A Completion for an action with two sources */
<i>1128</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1129</i>&nbsp;    abstract static class BiCompletion&lt;T,U,V&gt; extends UniCompletion&lt;T,V&gt; {
<i>1130</i>&nbsp;        CompletableFuture&lt;U&gt; snd; // second source for action
<i>1131</i>&nbsp;        BiCompletion(Executor executor, CompletableFuture&lt;V&gt; dep,
<i>1132</i>&nbsp;                     CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd) {
<i>1133</i>&nbsp;            super(executor, dep, src); this.snd = snd;
<b class="nc"><i>1134</i>&nbsp;        }</b>
<i>1135</i>&nbsp;    }
<i>1136</i>&nbsp;
<i>1137</i>&nbsp;    /** A Completion delegating to a BiCompletion */
<i>1138</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1139</i>&nbsp;    static final class CoCompletion extends Completion {
<b class="nc"><i>1140</i>&nbsp;        BiCompletion&lt;?,?,?&gt; base;</b>
<b class="nc"><i>1141</i>&nbsp;        CoCompletion(BiCompletion&lt;?,?,?&gt; base) { this.base = base; }</b>
<b class="nc"><i>1142</i>&nbsp;        final CompletableFuture&lt;?&gt; tryFire(int mode) {</b>
<b class="nc"><i>1143</i>&nbsp;            BiCompletion&lt;?,?,?&gt; c; CompletableFuture&lt;?&gt; d;</b>
<b class="nc"><i>1144</i>&nbsp;            if ((c = base) == null || (d = c.tryFire(mode)) == null)</b>
<i>1145</i>&nbsp;                return null;
<i>1146</i>&nbsp;            base = null; // detach
<i>1147</i>&nbsp;            return d;
<i>1148</i>&nbsp;        }
<i>1149</i>&nbsp;        final boolean isLive() {
<i>1150</i>&nbsp;            BiCompletion&lt;?,?,?&gt; c;
<i>1151</i>&nbsp;            return (c = base) != null
<i>1152</i>&nbsp;                // &amp;&amp; c.isLive()
<b class="nc"><i>1153</i>&nbsp;                &amp;&amp; c.dep != null;</b>
<i>1154</i>&nbsp;        }
<b class="nc"><i>1155</i>&nbsp;    }</b>
<b class="nc"><i>1156</i>&nbsp;</b>
<b class="nc"><i>1157</i>&nbsp;    /**</b>
<b class="nc"><i>1158</i>&nbsp;     * Pushes completion to this and b unless both done.</b>
<b class="nc"><i>1159</i>&nbsp;     * Caller should first check that either result or b.result is null.</b>
<b class="nc"><i>1160</i>&nbsp;     */</b>
<i>1161</i>&nbsp;    final void bipush(CompletableFuture&lt;?&gt; b, BiCompletion&lt;?,?,?&gt; c) {
<b class="nc"><i>1162</i>&nbsp;        if (c != null) {</b>
<i>1163</i>&nbsp;            while (result == null) {
<b class="nc"><i>1164</i>&nbsp;                if (tryPushStack(c)) {</b>
<b class="nc"><i>1165</i>&nbsp;                    if (b.result == null)</b>
<b class="nc"><i>1166</i>&nbsp;                        b.unipush(new CoCompletion(c));</b>
<b class="nc"><i>1167</i>&nbsp;                    else if (result != null)</b>
<i>1168</i>&nbsp;                        c.tryFire(SYNC);
<b class="nc"><i>1169</i>&nbsp;                    return;</b>
<i>1170</i>&nbsp;                }
<i>1171</i>&nbsp;            }
<b class="nc"><i>1172</i>&nbsp;            b.unipush(c);</b>
<b class="nc"><i>1173</i>&nbsp;        }</b>
<b class="nc"><i>1174</i>&nbsp;    }</b>
<b class="nc"><i>1175</i>&nbsp;</b>
<b class="nc"><i>1176</i>&nbsp;    /** Post-processing after successful BiCompletion tryFire. */</b>
<b class="nc"><i>1177</i>&nbsp;    final CompletableFuture&lt;T&gt; postFire(CompletableFuture&lt;?&gt; a,</b>
<b class="nc"><i>1178</i>&nbsp;                                        CompletableFuture&lt;?&gt; b, int mode) {</b>
<b class="nc"><i>1179</i>&nbsp;        if (b != null &amp;&amp; b.stack != null) { // clean second source</b>
<b class="nc"><i>1180</i>&nbsp;            Object r;</b>
<i>1181</i>&nbsp;            if ((r = b.result) == null)
<b class="nc"><i>1182</i>&nbsp;                b.cleanStack();</b>
<i>1183</i>&nbsp;            if (mode &gt;= 0 &amp;&amp; (r != null || b.result != null))
<i>1184</i>&nbsp;                b.postComplete();
<i>1185</i>&nbsp;        }
<i>1186</i>&nbsp;        return postFire(a, mode);
<i>1187</i>&nbsp;    }
<i>1188</i>&nbsp;
<b class="nc"><i>1189</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>1190</i>&nbsp;    static final class BiApply&lt;T,U,V&gt; extends BiCompletion&lt;T,U,V&gt; {</b>
<b class="nc"><i>1191</i>&nbsp;        BiFunction&lt;? super T,? super U,? extends V&gt; fn;</b>
<b class="nc"><i>1192</i>&nbsp;        BiApply(Executor executor, CompletableFuture&lt;V&gt; dep,</b>
<b class="nc"><i>1193</i>&nbsp;                CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,</b>
<b class="nc"><i>1194</i>&nbsp;                BiFunction&lt;? super T,? super U,? extends V&gt; fn) {</b>
<b class="nc"><i>1195</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;</b>
<i>1196</i>&nbsp;        }
<b class="nc"><i>1197</i>&nbsp;        final CompletableFuture&lt;V&gt; tryFire(int mode) {</b>
<i>1198</i>&nbsp;            CompletableFuture&lt;V&gt; d;
<i>1199</i>&nbsp;            CompletableFuture&lt;T&gt; a;
<i>1200</i>&nbsp;            CompletableFuture&lt;U&gt; b;
<i>1201</i>&nbsp;            Object r, s; BiFunction&lt;? super T,? super U,? extends V&gt; f;
<i>1202</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>1203</i>&nbsp;                || (a = src) == null || (r = a.result) == null
<i>1204</i>&nbsp;                || (b = snd) == null || (s = b.result) == null
<i>1205</i>&nbsp;                || !d.biApply(r, s, f, mode &gt; 0 ? null : this))
<i>1206</i>&nbsp;                return null;
<b class="nc"><i>1207</i>&nbsp;            dep = null; src = null; snd = null; fn = null;</b>
<i>1208</i>&nbsp;            return d.postFire(a, b, mode);
<i>1209</i>&nbsp;        }
<i>1210</i>&nbsp;    }
<i>1211</i>&nbsp;
<i>1212</i>&nbsp;    final &lt;R,S&gt; boolean biApply(Object r, Object s,
<b class="nc"><i>1213</i>&nbsp;                                BiFunction&lt;? super R,? super S,? extends T&gt; f,</b>
<b class="nc"><i>1214</i>&nbsp;                                BiApply&lt;R,S,T&gt; c) {</b>
<b class="nc"><i>1215</i>&nbsp;        Throwable x;</b>
<b class="nc"><i>1216</i>&nbsp;        tryComplete: if (result == null) {</b>
<b class="nc"><i>1217</i>&nbsp;            if (r instanceof AltResult) {</b>
<i>1218</i>&nbsp;                if ((x = ((AltResult)r).ex) != null) {
<i>1219</i>&nbsp;                    completeThrowable(x, r);
<i>1220</i>&nbsp;                    break tryComplete;
<i>1221</i>&nbsp;                }
<i>1222</i>&nbsp;                r = null;
<i>1223</i>&nbsp;            }
<b class="nc"><i>1224</i>&nbsp;            if (s instanceof AltResult) {</b>
<i>1225</i>&nbsp;                if ((x = ((AltResult)s).ex) != null) {
<b class="nc"><i>1226</i>&nbsp;                    completeThrowable(x, s);</b>
<b class="nc"><i>1227</i>&nbsp;                    break tryComplete;</b>
<b class="nc"><i>1228</i>&nbsp;                }</b>
<b class="nc"><i>1229</i>&nbsp;                s = null;</b>
<b class="nc"><i>1230</i>&nbsp;            }</b>
<b class="nc"><i>1231</i>&nbsp;            try {</b>
<i>1232</i>&nbsp;                if (c != null &amp;&amp; !c.claim())
<i>1233</i>&nbsp;                    return false;
<b class="nc"><i>1234</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) R rr = (R) r;</b>
<b class="nc"><i>1235</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) S ss = (S) s;</b>
<b class="nc"><i>1236</i>&nbsp;                completeValue(f.apply(rr, ss));</b>
<b class="nc"><i>1237</i>&nbsp;            } catch (Throwable ex) {</b>
<b class="nc"><i>1238</i>&nbsp;                completeThrowable(ex);</b>
<b class="nc"><i>1239</i>&nbsp;            }</b>
<b class="nc"><i>1240</i>&nbsp;        }</b>
<i>1241</i>&nbsp;        return true;
<b class="nc"><i>1242</i>&nbsp;    }</b>
<i>1243</i>&nbsp;
<i>1244</i>&nbsp;    private &lt;U,V&gt; CompletableFuture&lt;V&gt; biApplyStage(
<i>1245</i>&nbsp;        Executor e, CompletionStage&lt;U&gt; o,
<i>1246</i>&nbsp;        BiFunction&lt;? super T,? super U,? extends V&gt; f) {
<i>1247</i>&nbsp;        CompletableFuture&lt;U&gt; b; Object r, s;
<b class="nc"><i>1248</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)</b>
<b class="nc"><i>1249</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>1250</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>1251</i>&nbsp;        if ((r = result) == null || (s = b.result) == null)</b>
<b class="nc"><i>1252</i>&nbsp;            bipush(b, new BiApply&lt;T,U,V&gt;(e, d, this, b, f));</b>
<b class="nc"><i>1253</i>&nbsp;        else if (e == null)</b>
<b class="nc"><i>1254</i>&nbsp;            d.biApply(r, s, f, null);</b>
<i>1255</i>&nbsp;        else
<b class="nc"><i>1256</i>&nbsp;            try {</b>
<i>1257</i>&nbsp;                e.execute(new BiApply&lt;T,U,V&gt;(null, d, this, b, f));
<i>1258</i>&nbsp;            } catch (Throwable ex) {
<i>1259</i>&nbsp;                d.result = encodeThrowable(ex);
<i>1260</i>&nbsp;            }
<i>1261</i>&nbsp;        return d;
<i>1262</i>&nbsp;    }
<i>1263</i>&nbsp;
<b class="nc"><i>1264</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<i>1265</i>&nbsp;    static final class BiAccept&lt;T,U&gt; extends BiCompletion&lt;T,U,Void&gt; {
<i>1266</i>&nbsp;        BiConsumer&lt;? super T,? super U&gt; fn;
<i>1267</i>&nbsp;        BiAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,
<i>1268</i>&nbsp;                 CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,
<i>1269</i>&nbsp;                 BiConsumer&lt;? super T,? super U&gt; fn) {
<b class="nc"><i>1270</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;</b>
<b class="nc"><i>1271</i>&nbsp;        }</b>
<b class="nc"><i>1272</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {</b>
<b class="nc"><i>1273</i>&nbsp;            CompletableFuture&lt;Void&gt; d;</b>
<i>1274</i>&nbsp;            CompletableFuture&lt;T&gt; a;
<i>1275</i>&nbsp;            CompletableFuture&lt;U&gt; b;
<i>1276</i>&nbsp;            Object r, s; BiConsumer&lt;? super T,? super U&gt; f;
<i>1277</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>1278</i>&nbsp;                || (a = src) == null || (r = a.result) == null
<b class="nc"><i>1279</i>&nbsp;                || (b = snd) == null || (s = b.result) == null</b>
<i>1280</i>&nbsp;                || !d.biAccept(r, s, f, mode &gt; 0 ? null : this))
<b class="nc"><i>1281</i>&nbsp;                return null;</b>
<b class="nc"><i>1282</i>&nbsp;            dep = null; src = null; snd = null; fn = null;</b>
<b class="nc"><i>1283</i>&nbsp;            return d.postFire(a, b, mode);</b>
<b class="nc"><i>1284</i>&nbsp;        }</b>
<b class="nc"><i>1285</i>&nbsp;    }</b>
<b class="nc"><i>1286</i>&nbsp;</b>
<i>1287</i>&nbsp;    final &lt;R,S&gt; boolean biAccept(Object r, Object s,
<b class="nc"><i>1288</i>&nbsp;                                 BiConsumer&lt;? super R,? super S&gt; f,</b>
<i>1289</i>&nbsp;                                 BiAccept&lt;R,S&gt; c) {
<b class="nc"><i>1290</i>&nbsp;        Throwable x;</b>
<i>1291</i>&nbsp;        tryComplete: if (result == null) {
<i>1292</i>&nbsp;            if (r instanceof AltResult) {
<i>1293</i>&nbsp;                if ((x = ((AltResult)r).ex) != null) {
<i>1294</i>&nbsp;                    completeThrowable(x, r);
<i>1295</i>&nbsp;                    break tryComplete;
<b class="nc"><i>1296</i>&nbsp;                }</b>
<b class="nc"><i>1297</i>&nbsp;                r = null;</b>
<b class="nc"><i>1298</i>&nbsp;            }</b>
<i>1299</i>&nbsp;            if (s instanceof AltResult) {
<i>1300</i>&nbsp;                if ((x = ((AltResult)s).ex) != null) {
<b class="nc"><i>1301</i>&nbsp;                    completeThrowable(x, s);</b>
<b class="nc"><i>1302</i>&nbsp;                    break tryComplete;</b>
<b class="nc"><i>1303</i>&nbsp;                }</b>
<i>1304</i>&nbsp;                s = null;
<b class="nc"><i>1305</i>&nbsp;            }</b>
<b class="nc"><i>1306</i>&nbsp;            try {</b>
<b class="nc"><i>1307</i>&nbsp;                if (c != null &amp;&amp; !c.claim())</b>
<b class="nc"><i>1308</i>&nbsp;                    return false;</b>
<b class="nc"><i>1309</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) R rr = (R) r;</b>
<b class="nc"><i>1310</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) S ss = (S) s;</b>
<i>1311</i>&nbsp;                f.accept(rr, ss);
<i>1312</i>&nbsp;                completeNull();
<b class="nc"><i>1313</i>&nbsp;            } catch (Throwable ex) {</b>
<i>1314</i>&nbsp;                completeThrowable(ex);
<i>1315</i>&nbsp;            }
<i>1316</i>&nbsp;        }
<i>1317</i>&nbsp;        return true;
<i>1318</i>&nbsp;    }
<i>1319</i>&nbsp;
<b class="nc"><i>1320</i>&nbsp;    private &lt;U&gt; CompletableFuture&lt;Void&gt; biAcceptStage(</b>
<b class="nc"><i>1321</i>&nbsp;        Executor e, CompletionStage&lt;U&gt; o,</b>
<b class="nc"><i>1322</i>&nbsp;        BiConsumer&lt;? super T,? super U&gt; f) {</b>
<b class="nc"><i>1323</i>&nbsp;        CompletableFuture&lt;U&gt; b; Object r, s;</b>
<b class="nc"><i>1324</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)</b>
<b class="nc"><i>1325</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>1326</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>1327</i>&nbsp;        if ((r = result) == null || (s = b.result) == null)</b>
<b class="nc"><i>1328</i>&nbsp;            bipush(b, new BiAccept&lt;T,U&gt;(e, d, this, b, f));</b>
<i>1329</i>&nbsp;        else if (e == null)
<i>1330</i>&nbsp;            d.biAccept(r, s, f, null);
<b class="nc"><i>1331</i>&nbsp;        else</b>
<i>1332</i>&nbsp;            try {
<i>1333</i>&nbsp;                e.execute(new BiAccept&lt;T,U&gt;(null, d, this, b, f));
<i>1334</i>&nbsp;            } catch (Throwable ex) {
<i>1335</i>&nbsp;                d.result = encodeThrowable(ex);
<i>1336</i>&nbsp;            }
<i>1337</i>&nbsp;        return d;
<i>1338</i>&nbsp;    }
<i>1339</i>&nbsp;
<i>1340</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1341</i>&nbsp;    static final class BiRun&lt;T,U&gt; extends BiCompletion&lt;T,U,Void&gt; {
<i>1342</i>&nbsp;        Runnable fn;
<b class="nc"><i>1343</i>&nbsp;        BiRun(Executor executor, CompletableFuture&lt;Void&gt; dep,</b>
<i>1344</i>&nbsp;              CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,
<i>1345</i>&nbsp;              Runnable fn) {
<i>1346</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;
<i>1347</i>&nbsp;        }
<i>1348</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {
<b class="nc"><i>1349</i>&nbsp;            CompletableFuture&lt;Void&gt; d;</b>
<b class="nc"><i>1350</i>&nbsp;            CompletableFuture&lt;T&gt; a;</b>
<b class="nc"><i>1351</i>&nbsp;            CompletableFuture&lt;U&gt; b;</b>
<b class="nc"><i>1352</i>&nbsp;            Object r, s; Runnable f;</b>
<b class="nc"><i>1353</i>&nbsp;            if ((d = dep) == null || (f = fn) == null</b>
<i>1354</i>&nbsp;                || (a = src) == null || (r = a.result) == null
<i>1355</i>&nbsp;                || (b = snd) == null || (s = b.result) == null
<i>1356</i>&nbsp;                || !d.biRun(r, s, f, mode &gt; 0 ? null : this))
<i>1357</i>&nbsp;                return null;
<i>1358</i>&nbsp;            dep = null; src = null; snd = null; fn = null;
<i>1359</i>&nbsp;            return d.postFire(a, b, mode);
<i>1360</i>&nbsp;        }
<i>1361</i>&nbsp;    }
<b class="nc"><i>1362</i>&nbsp;</b>
<i>1363</i>&nbsp;    final boolean biRun(Object r, Object s, Runnable f, BiRun&lt;?,?&gt; c) {
<b class="nc"><i>1364</i>&nbsp;        Throwable x; Object z;</b>
<b class="nc"><i>1365</i>&nbsp;        if (result == null) {</b>
<i>1366</i>&nbsp;            if ((r instanceof AltResult
<b class="nc"><i>1367</i>&nbsp;                 &amp;&amp; (x = ((AltResult)(z = r)).ex) != null) ||</b>
<b class="nc"><i>1368</i>&nbsp;                (s instanceof AltResult</b>
<b class="nc"><i>1369</i>&nbsp;                 &amp;&amp; (x = ((AltResult)(z = s)).ex) != null))</b>
<b class="nc"><i>1370</i>&nbsp;                completeThrowable(x, z);</b>
<b class="nc"><i>1371</i>&nbsp;            else</b>
<b class="nc"><i>1372</i>&nbsp;                try {</b>
<i>1373</i>&nbsp;                    if (c != null &amp;&amp; !c.claim())
<b class="nc"><i>1374</i>&nbsp;                        return false;</b>
<i>1375</i>&nbsp;                    f.run();
<b class="nc"><i>1376</i>&nbsp;                    completeNull();</b>
<b class="nc"><i>1377</i>&nbsp;                } catch (Throwable ex) {</b>
<b class="nc"><i>1378</i>&nbsp;                    completeThrowable(ex);</b>
<b class="nc"><i>1379</i>&nbsp;                }</b>
<b class="nc"><i>1380</i>&nbsp;        }</b>
<i>1381</i>&nbsp;        return true;
<b class="nc"><i>1382</i>&nbsp;    }</b>
<i>1383</i>&nbsp;
<i>1384</i>&nbsp;    private CompletableFuture&lt;Void&gt; biRunStage(Executor e, CompletionStage&lt;?&gt; o,
<i>1385</i>&nbsp;                                               Runnable f) {
<i>1386</i>&nbsp;        CompletableFuture&lt;?&gt; b; Object r, s;
<i>1387</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)
<i>1388</i>&nbsp;            throw new NullPointerException();
<b class="nc"><i>1389</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>1390</i>&nbsp;        if ((r = result) == null || (s = b.result) == null)</b>
<b class="nc"><i>1391</i>&nbsp;            bipush(b, new BiRun&lt;&gt;(e, d, this, b, f));</b>
<b class="nc"><i>1392</i>&nbsp;        else if (e == null)</b>
<b class="nc"><i>1393</i>&nbsp;            d.biRun(r, s, f, null);</b>
<b class="nc"><i>1394</i>&nbsp;        else</b>
<b class="nc"><i>1395</i>&nbsp;            try {</b>
<i>1396</i>&nbsp;                e.execute(new BiRun&lt;&gt;(null, d, this, b, f));
<b class="nc"><i>1397</i>&nbsp;            } catch (Throwable ex) {</b>
<i>1398</i>&nbsp;                d.result = encodeThrowable(ex);
<i>1399</i>&nbsp;            }
<i>1400</i>&nbsp;        return d;
<i>1401</i>&nbsp;    }
<i>1402</i>&nbsp;
<i>1403</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1404</i>&nbsp;    static final class BiRelay&lt;T,U&gt; extends BiCompletion&lt;T,U,Void&gt; { // for And
<i>1405</i>&nbsp;        BiRelay(CompletableFuture&lt;Void&gt; dep,
<i>1406</i>&nbsp;                CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd) {
<b class="nc"><i>1407</i>&nbsp;            super(null, dep, src, snd);</b>
<i>1408</i>&nbsp;        }
<i>1409</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {
<i>1410</i>&nbsp;            CompletableFuture&lt;Void&gt; d;
<i>1411</i>&nbsp;            CompletableFuture&lt;T&gt; a;
<i>1412</i>&nbsp;            CompletableFuture&lt;U&gt; b;
<b class="nc"><i>1413</i>&nbsp;            Object r, s, z; Throwable x;</b>
<b class="nc"><i>1414</i>&nbsp;            if ((d = dep) == null</b>
<b class="nc"><i>1415</i>&nbsp;                || (a = src) == null || (r = a.result) == null</b>
<b class="nc"><i>1416</i>&nbsp;                || (b = snd) == null || (s = b.result) == null)</b>
<b class="nc"><i>1417</i>&nbsp;                return null;</b>
<i>1418</i>&nbsp;            if (d.result == null) {
<i>1419</i>&nbsp;                if ((r instanceof AltResult
<i>1420</i>&nbsp;                     &amp;&amp; (x = ((AltResult)(z = r)).ex) != null) ||
<i>1421</i>&nbsp;                    (s instanceof AltResult
<i>1422</i>&nbsp;                     &amp;&amp; (x = ((AltResult)(z = s)).ex) != null))
<i>1423</i>&nbsp;                    d.completeThrowable(x, z);
<i>1424</i>&nbsp;                else
<i>1425</i>&nbsp;                    d.completeNull();
<b class="nc"><i>1426</i>&nbsp;            }</b>
<i>1427</i>&nbsp;            src = null; snd = null; dep = null;
<b class="nc"><i>1428</i>&nbsp;            return d.postFire(a, b, mode);</b>
<b class="nc"><i>1429</i>&nbsp;        }</b>
<i>1430</i>&nbsp;    }
<b class="nc"><i>1431</i>&nbsp;</b>
<b class="nc"><i>1432</i>&nbsp;    /** Recursively constructs a tree of completions. */</b>
<b class="nc"><i>1433</i>&nbsp;    static CompletableFuture&lt;Void&gt; andTree(CompletableFuture&lt;?&gt;[] cfs,</b>
<b class="nc"><i>1434</i>&nbsp;                                           int lo, int hi) {</b>
<b class="nc"><i>1435</i>&nbsp;        CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();</b>
<b class="nc"><i>1436</i>&nbsp;        if (lo &gt; hi) // empty</b>
<i>1437</i>&nbsp;            d.result = NIL;
<b class="nc"><i>1438</i>&nbsp;        else {</b>
<i>1439</i>&nbsp;            CompletableFuture&lt;?&gt; a, b; Object r, s, z; Throwable x;
<b class="nc"><i>1440</i>&nbsp;            int mid = (lo + hi) &gt;&gt;&gt; 1;</b>
<b class="nc"><i>1441</i>&nbsp;            if ((a = (lo == mid ? cfs[lo] :</b>
<b class="nc"><i>1442</i>&nbsp;                      andTree(cfs, lo, mid))) == null ||</b>
<b class="nc"><i>1443</i>&nbsp;                (b = (lo == hi ? a : (hi == mid+1) ? cfs[hi] :</b>
<b class="nc"><i>1444</i>&nbsp;                      andTree(cfs, mid+1, hi))) == null)</b>
<b class="nc"><i>1445</i>&nbsp;                throw new NullPointerException();</b>
<i>1446</i>&nbsp;            if ((r = a.result) == null || (s = b.result) == null)
<b class="nc"><i>1447</i>&nbsp;                a.bipush(b, new BiRelay&lt;&gt;(d, a, b));</b>
<i>1448</i>&nbsp;            else if ((r instanceof AltResult
<i>1449</i>&nbsp;                      &amp;&amp; (x = ((AltResult)(z = r)).ex) != null) ||
<i>1450</i>&nbsp;                     (s instanceof AltResult
<i>1451</i>&nbsp;                      &amp;&amp; (x = ((AltResult)(z = s)).ex) != null))
<i>1452</i>&nbsp;                d.result = encodeThrowable(x, z);
<b class="nc"><i>1453</i>&nbsp;            else</b>
<b class="nc"><i>1454</i>&nbsp;                d.result = NIL;</b>
<b class="nc"><i>1455</i>&nbsp;        }</b>
<b class="nc"><i>1456</i>&nbsp;        return d;</b>
<b class="nc"><i>1457</i>&nbsp;    }</b>
<b class="nc"><i>1458</i>&nbsp;</b>
<b class="nc"><i>1459</i>&nbsp;    /* ------------- Projected (Ored) BiCompletions -------------- */</b>
<i>1460</i>&nbsp;
<b class="nc"><i>1461</i>&nbsp;    /**</b>
<i>1462</i>&nbsp;     * Pushes completion to this and b unless either done.
<i>1463</i>&nbsp;     * Caller should first check that result and b.result are both null.
<i>1464</i>&nbsp;     */
<i>1465</i>&nbsp;    final void orpush(CompletableFuture&lt;?&gt; b, BiCompletion&lt;?,?,?&gt; c) {
<i>1466</i>&nbsp;        if (c != null) {
<i>1467</i>&nbsp;            while (!tryPushStack(c)) {
<i>1468</i>&nbsp;                if (result != null) {
<i>1469</i>&nbsp;                    NEXT.set(c, null);
<i>1470</i>&nbsp;                    break;
<b class="nc"><i>1471</i>&nbsp;                }</b>
<i>1472</i>&nbsp;            }
<i>1473</i>&nbsp;            if (result != null)
<i>1474</i>&nbsp;                c.tryFire(SYNC);
<i>1475</i>&nbsp;            else
<i>1476</i>&nbsp;                b.unipush(new CoCompletion(c));
<b class="nc"><i>1477</i>&nbsp;        }</b>
<b class="nc"><i>1478</i>&nbsp;    }</b>
<b class="nc"><i>1479</i>&nbsp;</b>
<b class="nc"><i>1480</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>1481</i>&nbsp;    static final class OrApply&lt;T,U extends T,V&gt; extends BiCompletion&lt;T,U,V&gt; {</b>
<i>1482</i>&nbsp;        Function&lt;? super T,? extends V&gt; fn;
<i>1483</i>&nbsp;        OrApply(Executor executor, CompletableFuture&lt;V&gt; dep,
<i>1484</i>&nbsp;                CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,
<i>1485</i>&nbsp;                Function&lt;? super T,? extends V&gt; fn) {
<i>1486</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;
<i>1487</i>&nbsp;        }
<b class="nc"><i>1488</i>&nbsp;        final CompletableFuture&lt;V&gt; tryFire(int mode) {</b>
<i>1489</i>&nbsp;            CompletableFuture&lt;V&gt; d;
<b class="nc"><i>1490</i>&nbsp;            CompletableFuture&lt;T&gt; a;</b>
<b class="nc"><i>1491</i>&nbsp;            CompletableFuture&lt;U&gt; b;</b>
<i>1492</i>&nbsp;            Object r; Throwable x; Function&lt;? super T,? extends V&gt; f;
<b class="nc"><i>1493</i>&nbsp;            if ((d = dep) == null || (f = fn) == null</b>
<b class="nc"><i>1494</i>&nbsp;                || (a = src) == null || (b = snd) == null</b>
<b class="nc"><i>1495</i>&nbsp;                || ((r = a.result) == null &amp;&amp; (r = b.result) == null))</b>
<b class="nc"><i>1496</i>&nbsp;                return null;</b>
<i>1497</i>&nbsp;            tryComplete: if (d.result == null) {
<b class="nc"><i>1498</i>&nbsp;                try {</b>
<b class="nc"><i>1499</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())</b>
<i>1500</i>&nbsp;                        return null;
<b class="nc"><i>1501</i>&nbsp;                    if (r instanceof AltResult) {</b>
<b class="nc"><i>1502</i>&nbsp;                        if ((x = ((AltResult)r).ex) != null) {</b>
<b class="nc"><i>1503</i>&nbsp;                            d.completeThrowable(x, r);</b>
<i>1504</i>&nbsp;                            break tryComplete;
<b class="nc"><i>1505</i>&nbsp;                        }</b>
<i>1506</i>&nbsp;                        r = null;
<i>1507</i>&nbsp;                    }
<i>1508</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;
<i>1509</i>&nbsp;                    d.completeValue(f.apply(t));
<i>1510</i>&nbsp;                } catch (Throwable ex) {
<b class="nc"><i>1511</i>&nbsp;                    d.completeThrowable(ex);</b>
<b class="nc"><i>1512</i>&nbsp;                }</b>
<b class="nc"><i>1513</i>&nbsp;            }</b>
<b class="nc"><i>1514</i>&nbsp;            dep = null; src = null; snd = null; fn = null;</b>
<b class="nc"><i>1515</i>&nbsp;            return d.postFire(a, b, mode);</b>
<b class="nc"><i>1516</i>&nbsp;        }</b>
<b class="nc"><i>1517</i>&nbsp;    }</b>
<i>1518</i>&nbsp;
<b class="nc"><i>1519</i>&nbsp;    private &lt;U extends T,V&gt; CompletableFuture&lt;V&gt; orApplyStage(</b>
<i>1520</i>&nbsp;        Executor e, CompletionStage&lt;U&gt; o, Function&lt;? super T, ? extends V&gt; f) {
<i>1521</i>&nbsp;        CompletableFuture&lt;U&gt; b;
<i>1522</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)
<i>1523</i>&nbsp;            throw new NullPointerException();
<i>1524</i>&nbsp;
<i>1525</i>&nbsp;        Object r; CompletableFuture&lt;? extends T&gt; z;
<b class="nc"><i>1526</i>&nbsp;        if ((r = (z = this).result) != null ||</b>
<i>1527</i>&nbsp;            (r = (z = b).result) != null)
<i>1528</i>&nbsp;            return z.uniApplyNow(r, e, f);
<i>1529</i>&nbsp;
<i>1530</i>&nbsp;        CompletableFuture&lt;V&gt; d = newIncompleteFuture();
<i>1531</i>&nbsp;        orpush(b, new OrApply&lt;T,U,V&gt;(e, d, this, b, f));
<b class="nc"><i>1532</i>&nbsp;        return d;</b>
<b class="nc"><i>1533</i>&nbsp;    }</b>
<b class="nc"><i>1534</i>&nbsp;</b>
<b class="nc"><i>1535</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<i>1536</i>&nbsp;    static final class OrAccept&lt;T,U extends T&gt; extends BiCompletion&lt;T,U,Void&gt; {
<i>1537</i>&nbsp;        Consumer&lt;? super T&gt; fn;
<i>1538</i>&nbsp;        OrAccept(Executor executor, CompletableFuture&lt;Void&gt; dep,
<i>1539</i>&nbsp;                 CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,
<i>1540</i>&nbsp;                 Consumer&lt;? super T&gt; fn) {
<b class="nc"><i>1541</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;</b>
<i>1542</i>&nbsp;        }
<b class="nc"><i>1543</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {</b>
<b class="nc"><i>1544</i>&nbsp;            CompletableFuture&lt;Void&gt; d;</b>
<b class="nc"><i>1545</i>&nbsp;            CompletableFuture&lt;T&gt; a;</b>
<b class="nc"><i>1546</i>&nbsp;            CompletableFuture&lt;U&gt; b;</b>
<i>1547</i>&nbsp;            Object r; Throwable x; Consumer&lt;? super T&gt; f;
<i>1548</i>&nbsp;            if ((d = dep) == null || (f = fn) == null
<i>1549</i>&nbsp;                || (a = src) == null || (b = snd) == null
<i>1550</i>&nbsp;                || ((r = a.result) == null &amp;&amp; (r = b.result) == null))
<i>1551</i>&nbsp;                return null;
<b class="nc"><i>1552</i>&nbsp;            tryComplete: if (d.result == null) {</b>
<b class="nc"><i>1553</i>&nbsp;                try {</b>
<i>1554</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())
<b class="nc"><i>1555</i>&nbsp;                        return null;</b>
<b class="nc"><i>1556</i>&nbsp;                    if (r instanceof AltResult) {</b>
<b class="nc"><i>1557</i>&nbsp;                        if ((x = ((AltResult)r).ex) != null) {</b>
<i>1558</i>&nbsp;                            d.completeThrowable(x, r);
<b class="nc"><i>1559</i>&nbsp;                            break tryComplete;</b>
<b class="nc"><i>1560</i>&nbsp;                        }</b>
<b class="nc"><i>1561</i>&nbsp;                        r = null;</b>
<b class="nc"><i>1562</i>&nbsp;                    }</b>
<b class="nc"><i>1563</i>&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) T t = (T) r;</b>
<b class="nc"><i>1564</i>&nbsp;                    f.accept(t);</b>
<i>1565</i>&nbsp;                    d.completeNull();
<i>1566</i>&nbsp;                } catch (Throwable ex) {
<b class="nc"><i>1567</i>&nbsp;                    d.completeThrowable(ex);</b>
<i>1568</i>&nbsp;                }
<i>1569</i>&nbsp;            }
<i>1570</i>&nbsp;            dep = null; src = null; snd = null; fn = null;
<i>1571</i>&nbsp;            return d.postFire(a, b, mode);
<i>1572</i>&nbsp;        }
<i>1573</i>&nbsp;    }
<i>1574</i>&nbsp;
<i>1575</i>&nbsp;    private &lt;U extends T&gt; CompletableFuture&lt;Void&gt; orAcceptStage(
<b class="nc"><i>1576</i>&nbsp;        Executor e, CompletionStage&lt;U&gt; o, Consumer&lt;? super T&gt; f) {</b>
<b class="nc"><i>1577</i>&nbsp;        CompletableFuture&lt;U&gt; b;</b>
<i>1578</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)
<i>1579</i>&nbsp;            throw new NullPointerException();
<b class="nc"><i>1580</i>&nbsp;</b>
<i>1581</i>&nbsp;        Object r; CompletableFuture&lt;? extends T&gt; z;
<b class="nc"><i>1582</i>&nbsp;        if ((r = (z = this).result) != null ||</b>
<i>1583</i>&nbsp;            (r = (z = b).result) != null)
<i>1584</i>&nbsp;            return z.uniAcceptNow(r, e, f);
<i>1585</i>&nbsp;
<b class="nc"><i>1586</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>1587</i>&nbsp;        orpush(b, new OrAccept&lt;T,U&gt;(e, d, this, b, f));</b>
<b class="nc"><i>1588</i>&nbsp;        return d;</b>
<i>1589</i>&nbsp;    }
<b class="nc"><i>1590</i>&nbsp;</b>
<b class="nc"><i>1591</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>1592</i>&nbsp;    static final class OrRun&lt;T,U&gt; extends BiCompletion&lt;T,U,Void&gt; {</b>
<b class="nc"><i>1593</i>&nbsp;        Runnable fn;</b>
<i>1594</i>&nbsp;        OrRun(Executor executor, CompletableFuture&lt;Void&gt; dep,
<b class="nc"><i>1595</i>&nbsp;              CompletableFuture&lt;T&gt; src, CompletableFuture&lt;U&gt; snd,</b>
<i>1596</i>&nbsp;              Runnable fn) {
<i>1597</i>&nbsp;            super(executor, dep, src, snd); this.fn = fn;
<i>1598</i>&nbsp;        }
<i>1599</i>&nbsp;        final CompletableFuture&lt;Void&gt; tryFire(int mode) {
<i>1600</i>&nbsp;            CompletableFuture&lt;Void&gt; d;
<i>1601</i>&nbsp;            CompletableFuture&lt;T&gt; a;
<b class="nc"><i>1602</i>&nbsp;            CompletableFuture&lt;U&gt; b;</b>
<b class="nc"><i>1603</i>&nbsp;            Object r; Throwable x; Runnable f;</b>
<b class="nc"><i>1604</i>&nbsp;            if ((d = dep) == null || (f = fn) == null</b>
<b class="nc"><i>1605</i>&nbsp;                || (a = src) == null || (b = snd) == null</b>
<i>1606</i>&nbsp;                || ((r = a.result) == null &amp;&amp; (r = b.result) == null))
<i>1607</i>&nbsp;                return null;
<i>1608</i>&nbsp;            if (d.result == null) {
<i>1609</i>&nbsp;                try {
<i>1610</i>&nbsp;                    if (mode &lt;= 0 &amp;&amp; !claim())
<i>1611</i>&nbsp;                        return null;
<b class="nc"><i>1612</i>&nbsp;                    else if (r instanceof AltResult</b>
<b class="nc"><i>1613</i>&nbsp;                        &amp;&amp; (x = ((AltResult)r).ex) != null)</b>
<i>1614</i>&nbsp;                        d.completeThrowable(x, r);
<i>1615</i>&nbsp;                    else {
<b class="nc"><i>1616</i>&nbsp;                        f.run();</b>
<i>1617</i>&nbsp;                        d.completeNull();
<b class="nc"><i>1618</i>&nbsp;                    }</b>
<i>1619</i>&nbsp;                } catch (Throwable ex) {
<i>1620</i>&nbsp;                    d.completeThrowable(ex);
<i>1621</i>&nbsp;                }
<b class="nc"><i>1622</i>&nbsp;            }</b>
<b class="nc"><i>1623</i>&nbsp;            dep = null; src = null; snd = null; fn = null;</b>
<b class="nc"><i>1624</i>&nbsp;            return d.postFire(a, b, mode);</b>
<i>1625</i>&nbsp;        }
<b class="nc"><i>1626</i>&nbsp;    }</b>
<b class="nc"><i>1627</i>&nbsp;</b>
<b class="nc"><i>1628</i>&nbsp;    private CompletableFuture&lt;Void&gt; orRunStage(Executor e, CompletionStage&lt;?&gt; o,</b>
<b class="nc"><i>1629</i>&nbsp;                                               Runnable f) {</b>
<b class="nc"><i>1630</i>&nbsp;        CompletableFuture&lt;?&gt; b;</b>
<i>1631</i>&nbsp;        if (f == null || (b = o.toCompletableFuture()) == null)
<b class="nc"><i>1632</i>&nbsp;            throw new NullPointerException();</b>
<i>1633</i>&nbsp;
<i>1634</i>&nbsp;        Object r; CompletableFuture&lt;?&gt; z;
<i>1635</i>&nbsp;        if ((r = (z = this).result) != null ||
<i>1636</i>&nbsp;            (r = (z = b).result) != null)
<i>1637</i>&nbsp;            return z.uniRunNow(r, e, f);
<b class="nc"><i>1638</i>&nbsp;</b>
<b class="nc"><i>1639</i>&nbsp;        CompletableFuture&lt;Void&gt; d = newIncompleteFuture();</b>
<b class="nc"><i>1640</i>&nbsp;        orpush(b, new OrRun&lt;&gt;(e, d, this, b, f));</b>
<b class="nc"><i>1641</i>&nbsp;        return d;</b>
<i>1642</i>&nbsp;    }
<i>1643</i>&nbsp;
<i>1644</i>&nbsp;    /** Completion for an anyOf input future. */
<i>1645</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1646</i>&nbsp;    static class AnyOf extends Completion {
<i>1647</i>&nbsp;        CompletableFuture&lt;Object&gt; dep; CompletableFuture&lt;?&gt; src;
<i>1648</i>&nbsp;        CompletableFuture&lt;?&gt;[] srcs;
<i>1649</i>&nbsp;        AnyOf(CompletableFuture&lt;Object&gt; dep, CompletableFuture&lt;?&gt; src,
<i>1650</i>&nbsp;              CompletableFuture&lt;?&gt;[] srcs) {
<i>1651</i>&nbsp;            this.dep = dep; this.src = src; this.srcs = srcs;
<i>1652</i>&nbsp;        }
<i>1653</i>&nbsp;        final CompletableFuture&lt;Object&gt; tryFire(int mode) {
<i>1654</i>&nbsp;            // assert mode != ASYNC;
<i>1655</i>&nbsp;            CompletableFuture&lt;Object&gt; d; CompletableFuture&lt;?&gt; a;
<i>1656</i>&nbsp;            CompletableFuture&lt;?&gt;[] as;
<i>1657</i>&nbsp;            Object r;
<i>1658</i>&nbsp;            if ((d = dep) == null
<b class="nc"><i>1659</i>&nbsp;                || (a = src) == null || (r = a.result) == null</b>
<b class="nc"><i>1660</i>&nbsp;                || (as = srcs) == null)</b>
<b class="nc"><i>1661</i>&nbsp;                return null;</b>
<b class="nc"><i>1662</i>&nbsp;            dep = null; src = null; srcs = null;</b>
<b class="nc"><i>1663</i>&nbsp;            if (d.completeRelay(r)) {</b>
<i>1664</i>&nbsp;                for (CompletableFuture&lt;?&gt; b : as)
<i>1665</i>&nbsp;                    if (b != a)
<i>1666</i>&nbsp;                        b.cleanStack();
<b class="nc"><i>1667</i>&nbsp;                if (mode &lt; 0)</b>
<b class="nc"><i>1668</i>&nbsp;                    return d;</b>
<b class="nc"><i>1669</i>&nbsp;                else</b>
<i>1670</i>&nbsp;                    d.postComplete();
<b class="nc"><i>1671</i>&nbsp;            }</b>
<i>1672</i>&nbsp;            return null;
<i>1673</i>&nbsp;        }
<b class="nc"><i>1674</i>&nbsp;        final boolean isLive() {</b>
<b class="nc"><i>1675</i>&nbsp;            CompletableFuture&lt;Object&gt; d;</b>
<b class="nc"><i>1676</i>&nbsp;            return (d = dep) != null &amp;&amp; d.result == null;</b>
<b class="nc"><i>1677</i>&nbsp;        }</b>
<b class="nc"><i>1678</i>&nbsp;    }</b>
<b class="nc"><i>1679</i>&nbsp;</b>
<b class="nc"><i>1680</i>&nbsp;    /* ------------- Zero-input Async forms -------------- */</b>
<i>1681</i>&nbsp;
<b class="nc"><i>1682</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>1683</i>&nbsp;    static final class AsyncSupply&lt;T&gt; extends ForkJoinTask&lt;Void&gt;</b>
<b class="nc"><i>1684</i>&nbsp;        implements Runnable, AsynchronousCompletionTask {</b>
<b class="nc"><i>1685</i>&nbsp;        CompletableFuture&lt;T&gt; dep; Supplier&lt;? extends T&gt; fn;</b>
<i>1686</i>&nbsp;        AsyncSupply(CompletableFuture&lt;T&gt; dep, Supplier&lt;? extends T&gt; fn) {
<b class="nc"><i>1687</i>&nbsp;            this.dep = dep; this.fn = fn;</b>
<i>1688</i>&nbsp;        }
<i>1689</i>&nbsp;
<b class="nc"><i>1690</i>&nbsp;        public final Void getRawResult() { return null; }</b>
<b class="nc"><i>1691</i>&nbsp;        public final void setRawResult(Void v) {}</b>
<b class="nc"><i>1692</i>&nbsp;        public final boolean exec() { run(); return false; }</b>
<b class="nc"><i>1693</i>&nbsp;</b>
<b class="nc"><i>1694</i>&nbsp;        public void run() {</b>
<b class="nc"><i>1695</i>&nbsp;            CompletableFuture&lt;T&gt; d; Supplier&lt;? extends T&gt; f;</b>
<b class="nc"><i>1696</i>&nbsp;            if ((d = dep) != null &amp;&amp; (f = fn) != null) {</b>
<i>1697</i>&nbsp;                dep = null; fn = null;
<b class="nc"><i>1698</i>&nbsp;                if (d.result == null) {</b>
<i>1699</i>&nbsp;                    try {
<i>1700</i>&nbsp;                        d.completeValue(f.get());
<i>1701</i>&nbsp;                    } catch (Throwable ex) {
<i>1702</i>&nbsp;                        d.completeThrowable(ex);
<i>1703</i>&nbsp;                    }
<i>1704</i>&nbsp;                }
<i>1705</i>&nbsp;                d.postComplete();
<b class="nc"><i>1706</i>&nbsp;            }</b>
<b class="nc"><i>1707</i>&nbsp;        }</b>
<b class="nc"><i>1708</i>&nbsp;    }</b>
<i>1709</i>&nbsp;
<b class="nc"><i>1710</i>&nbsp;    static &lt;U&gt; CompletableFuture&lt;U&gt; asyncSupplyStage(Executor e,</b>
<b class="nc"><i>1711</i>&nbsp;                                                     Supplier&lt;U&gt; f) {</b>
<b class="nc"><i>1712</i>&nbsp;        if (f == null) throw new NullPointerException();</b>
<i>1713</i>&nbsp;        CompletableFuture&lt;U&gt; d = new CompletableFuture&lt;U&gt;();
<b class="nc"><i>1714</i>&nbsp;        e.execute(new AsyncSupply&lt;U&gt;(d, f));</b>
<b class="nc"><i>1715</i>&nbsp;        return d;</b>
<b class="nc"><i>1716</i>&nbsp;    }</b>
<i>1717</i>&nbsp;
<b class="nc"><i>1718</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)</b>
<b class="nc"><i>1719</i>&nbsp;    static final class AsyncRun extends ForkJoinTask&lt;Void&gt;</b>
<b class="nc"><i>1720</i>&nbsp;        implements Runnable, AsynchronousCompletionTask {</b>
<b class="nc"><i>1721</i>&nbsp;        CompletableFuture&lt;Void&gt; dep; Runnable fn;</b>
<b class="nc"><i>1722</i>&nbsp;        AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) {</b>
<b class="nc"><i>1723</i>&nbsp;            this.dep = dep; this.fn = fn;</b>
<b class="nc"><i>1724</i>&nbsp;        }</b>
<b class="nc"><i>1725</i>&nbsp;</b>
<i>1726</i>&nbsp;        public final Void getRawResult() { return null; }
<b class="nc"><i>1727</i>&nbsp;        public final void setRawResult(Void v) {}</b>
<i>1728</i>&nbsp;        public final boolean exec() { run(); return false; }
<b class="nc"><i>1729</i>&nbsp;</b>
<b class="nc"><i>1730</i>&nbsp;        public void run() {</b>
<b class="nc"><i>1731</i>&nbsp;            CompletableFuture&lt;Void&gt; d; Runnable f;</b>
<b class="nc"><i>1732</i>&nbsp;            if ((d = dep) != null &amp;&amp; (f = fn) != null) {</b>
<i>1733</i>&nbsp;                dep = null; fn = null;
<i>1734</i>&nbsp;                if (d.result == null) {
<b class="nc"><i>1735</i>&nbsp;                    try {</b>
<b class="nc"><i>1736</i>&nbsp;                        f.run();</b>
<b class="nc"><i>1737</i>&nbsp;                        d.completeNull();</b>
<b class="nc"><i>1738</i>&nbsp;                    } catch (Throwable ex) {</b>
<b class="nc"><i>1739</i>&nbsp;                        d.completeThrowable(ex);</b>
<i>1740</i>&nbsp;                    }
<b class="nc"><i>1741</i>&nbsp;                }</b>
<i>1742</i>&nbsp;                d.postComplete();
<i>1743</i>&nbsp;            }
<b class="nc"><i>1744</i>&nbsp;        }</b>
<b class="nc"><i>1745</i>&nbsp;    }</b>
<i>1746</i>&nbsp;
<i>1747</i>&nbsp;    static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) {
<i>1748</i>&nbsp;        if (f == null) throw new NullPointerException();
<i>1749</i>&nbsp;        CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;();
<i>1750</i>&nbsp;        e.execute(new AsyncRun(d, f));
<i>1751</i>&nbsp;        return d;
<i>1752</i>&nbsp;    }
<b class="nc"><i>1753</i>&nbsp;</b>
<b class="nc"><i>1754</i>&nbsp;    /* ------------- Signallers -------------- */</b>
<b class="nc"><i>1755</i>&nbsp;</b>
<b class="nc"><i>1756</i>&nbsp;    /**</b>
<b class="nc"><i>1757</i>&nbsp;     * Completion for recording and releasing a waiting thread.  This</b>
<b class="nc"><i>1758</i>&nbsp;     * class implements ManagedBlocker to avoid starvation when</b>
<b class="nc"><i>1759</i>&nbsp;     * blocking actions pile up in ForkJoinPools.</b>
<i>1760</i>&nbsp;     */
<i>1761</i>&nbsp;    @SuppressWarnings(&quot;serial&quot;)
<i>1762</i>&nbsp;    static final class Signaller extends Completion
<b class="nc"><i>1763</i>&nbsp;        implements ForkJoinPool.ManagedBlocker {</b>
<b class="nc"><i>1764</i>&nbsp;        long nanos;                    // remaining wait time if timed</b>
<b class="nc"><i>1765</i>&nbsp;        final long deadline;           // non-zero if timed</b>
<b class="nc"><i>1766</i>&nbsp;        final boolean interruptible;</b>
<b class="nc"><i>1767</i>&nbsp;        boolean interrupted;</b>
<b class="nc"><i>1768</i>&nbsp;        volatile Thread thread;</b>
<b class="nc"><i>1769</i>&nbsp;</b>
<b class="nc"><i>1770</i>&nbsp;        Signaller(boolean interruptible, long nanos, long deadline) {</b>
<b class="nc"><i>1771</i>&nbsp;            this.thread = Thread.currentThread();</b>
<i>1772</i>&nbsp;            this.interruptible = interruptible;
<b class="nc"><i>1773</i>&nbsp;            this.nanos = nanos;</b>
<i>1774</i>&nbsp;            this.deadline = deadline;
<b class="nc"><i>1775</i>&nbsp;        }</b>
<b class="nc"><i>1776</i>&nbsp;        final CompletableFuture&lt;?&gt; tryFire(int ignore) {</b>
<b class="nc"><i>1777</i>&nbsp;            Thread w; // no need to atomically claim</b>
<b class="nc"><i>1778</i>&nbsp;            if ((w = thread) != null) {</b>
<i>1779</i>&nbsp;                thread = null;
<i>1780</i>&nbsp;                LockSupport.unpark(w);
<b class="nc"><i>1781</i>&nbsp;            }</b>
<b class="nc"><i>1782</i>&nbsp;            return null;</b>
<b class="nc"><i>1783</i>&nbsp;        }</b>
<b class="nc"><i>1784</i>&nbsp;        public boolean isReleasable() {</b>
<b class="nc"><i>1785</i>&nbsp;            if (Thread.interrupted())</b>
<i>1786</i>&nbsp;                interrupted = true;
<i>1787</i>&nbsp;            return ((interrupted &amp;&amp; interruptible) ||
<i>1788</i>&nbsp;                    (deadline != 0L &amp;&amp;
<i>1789</i>&nbsp;                     (nanos &lt;= 0L ||
<i>1790</i>&nbsp;                      (nanos = deadline - System.nanoTime()) &lt;= 0L)) ||
<i>1791</i>&nbsp;                    thread == null);
<i>1792</i>&nbsp;        }
<b class="nc"><i>1793</i>&nbsp;        public boolean block() {</b>
<i>1794</i>&nbsp;            while (!isReleasable()) {
<i>1795</i>&nbsp;                if (deadline == 0L)
<i>1796</i>&nbsp;                    LockSupport.park(this);
<i>1797</i>&nbsp;                else
<i>1798</i>&nbsp;                    LockSupport.parkNanos(this, nanos);
<b class="nc"><i>1799</i>&nbsp;            }</b>
<b class="nc"><i>1800</i>&nbsp;            return true;</b>
<i>1801</i>&nbsp;        }
<i>1802</i>&nbsp;        final boolean isLive() { return thread != null; }
<i>1803</i>&nbsp;    }
<i>1804</i>&nbsp;
<i>1805</i>&nbsp;    /**
<i>1806</i>&nbsp;     * Returns raw result after waiting, or null if interruptible and
<i>1807</i>&nbsp;     * interrupted.
<i>1808</i>&nbsp;     */
<i>1809</i>&nbsp;    private Object waitingGet(boolean interruptible) {
<i>1810</i>&nbsp;        Signaller q = null;
<i>1811</i>&nbsp;        boolean queued = false;
<i>1812</i>&nbsp;        Object r;
<i>1813</i>&nbsp;        while ((r = result) == null) {
<b class="nc"><i>1814</i>&nbsp;            if (q == null) {</b>
<i>1815</i>&nbsp;                q = new Signaller(interruptible, 0L, 0L);
<i>1816</i>&nbsp;                if (Thread.currentThread() instanceof ForkJoinWorkerThread)
<i>1817</i>&nbsp;                    ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);
<i>1818</i>&nbsp;            }
<i>1819</i>&nbsp;            else if (!queued)
<i>1820</i>&nbsp;                queued = tryPushStack(q);
<i>1821</i>&nbsp;            else {
<i>1822</i>&nbsp;                try {
<i>1823</i>&nbsp;                    ForkJoinPool.managedBlock(q);
<i>1824</i>&nbsp;                } catch (InterruptedException ie) { // currently cannot happen
<i>1825</i>&nbsp;                    q.interrupted = true;
<i>1826</i>&nbsp;                }
<i>1827</i>&nbsp;                if (q.interrupted &amp;&amp; interruptible)
<i>1828</i>&nbsp;                    break;
<i>1829</i>&nbsp;            }
<b class="nc"><i>1830</i>&nbsp;        }</b>
<i>1831</i>&nbsp;        if (q != null &amp;&amp; queued) {
<i>1832</i>&nbsp;            q.thread = null;
<i>1833</i>&nbsp;            if (!interruptible &amp;&amp; q.interrupted)
<i>1834</i>&nbsp;                Thread.currentThread().interrupt();
<i>1835</i>&nbsp;            if (r == null)
<i>1836</i>&nbsp;                cleanStack();
<i>1837</i>&nbsp;        }
<i>1838</i>&nbsp;        if (r != null || (r = result) != null)
<i>1839</i>&nbsp;            postComplete();
<i>1840</i>&nbsp;        return r;
<i>1841</i>&nbsp;    }
<i>1842</i>&nbsp;
<b class="nc"><i>1843</i>&nbsp;    /**</b>
<i>1844</i>&nbsp;     * Returns raw result after waiting, or null if interrupted, or
<i>1845</i>&nbsp;     * throws TimeoutException on timeout.
<i>1846</i>&nbsp;     */
<i>1847</i>&nbsp;    private Object timedGet(long nanos) throws TimeoutException {
<i>1848</i>&nbsp;        if (Thread.interrupted())
<i>1849</i>&nbsp;            return null;
<i>1850</i>&nbsp;        if (nanos &gt; 0L) {
<i>1851</i>&nbsp;            long d = System.nanoTime() + nanos;
<i>1852</i>&nbsp;            long deadline = (d == 0L) ? 1L : d; // avoid 0
<i>1853</i>&nbsp;            Signaller q = null;
<i>1854</i>&nbsp;            boolean queued = false;
<i>1855</i>&nbsp;            Object r;
<i>1856</i>&nbsp;            while ((r = result) == null) { // similar to untimed
<i>1857</i>&nbsp;                if (q == null) {
<b class="nc"><i>1858</i>&nbsp;                    q = new Signaller(true, nanos, deadline);</b>
<i>1859</i>&nbsp;                    if (Thread.currentThread() instanceof ForkJoinWorkerThread)
<i>1860</i>&nbsp;                        ForkJoinPool.helpAsyncBlocker(defaultExecutor(), q);
<i>1861</i>&nbsp;                }
<i>1862</i>&nbsp;                else if (!queued)
<i>1863</i>&nbsp;                    queued = tryPushStack(q);
<i>1864</i>&nbsp;                else if (q.nanos &lt;= 0L)
<i>1865</i>&nbsp;                    break;
<i>1866</i>&nbsp;                else {
<i>1867</i>&nbsp;                    try {
<i>1868</i>&nbsp;                        ForkJoinPool.managedBlock(q);
<i>1869</i>&nbsp;                    } catch (InterruptedException ie) {
<b class="nc"><i>1870</i>&nbsp;                        q.interrupted = true;</b>
<i>1871</i>&nbsp;                    }
<i>1872</i>&nbsp;                    if (q.interrupted)
<i>1873</i>&nbsp;                        break;
<i>1874</i>&nbsp;                }
<i>1875</i>&nbsp;            }
<i>1876</i>&nbsp;            if (q != null &amp;&amp; queued) {
<i>1877</i>&nbsp;                q.thread = null;
<i>1878</i>&nbsp;                if (r == null)
<i>1879</i>&nbsp;                    cleanStack();
<b class="nc"><i>1880</i>&nbsp;            }</b>
<i>1881</i>&nbsp;            if (r != null || (r = result) != null)
<i>1882</i>&nbsp;                postComplete();
<i>1883</i>&nbsp;            if (r != null || (q != null &amp;&amp; q.interrupted))
<i>1884</i>&nbsp;                return r;
<i>1885</i>&nbsp;        }
<i>1886</i>&nbsp;        throw new TimeoutException();
<i>1887</i>&nbsp;    }
<i>1888</i>&nbsp;
<i>1889</i>&nbsp;    /* ------------- public methods -------------- */
<i>1890</i>&nbsp;
<i>1891</i>&nbsp;    /**
<i>1892</i>&nbsp;     * Creates a new incomplete CompletableFuture.
<i>1893</i>&nbsp;     */
<i>1894</i>&nbsp;    public CompletableFuture() {
<b class="nc"><i>1895</i>&nbsp;    }</b>
<i>1896</i>&nbsp;
<i>1897</i>&nbsp;    /**
<i>1898</i>&nbsp;     * Creates a new complete CompletableFuture with given encoded result.
<i>1899</i>&nbsp;     */
<i>1900</i>&nbsp;    CompletableFuture(Object r) {
<i>1901</i>&nbsp;        this.result = r;
<i>1902</i>&nbsp;    }
<i>1903</i>&nbsp;
<i>1904</i>&nbsp;    /**
<i>1905</i>&nbsp;     * Returns a new CompletableFuture that is asynchronously completed
<i>1906</i>&nbsp;     * by a task running in the {@link ForkJoinPool#commonPool()} with
<i>1907</i>&nbsp;     * the value obtained by calling the given Supplier.
<i>1908</i>&nbsp;     *
<i>1909</i>&nbsp;     * @param supplier a function returning the value to be used
<i>1910</i>&nbsp;     * to complete the returned CompletableFuture
<i>1911</i>&nbsp;     * @param &lt;U&gt; the function&#39;s return type
<i>1912</i>&nbsp;     * @return the new CompletableFuture
<i>1913</i>&nbsp;     */
<b class="nc"><i>1914</i>&nbsp;    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {</b>
<b class="nc"><i>1915</i>&nbsp;        return asyncSupplyStage(ASYNC_POOL, supplier);</b>
<i>1916</i>&nbsp;    }
<i>1917</i>&nbsp;
<i>1918</i>&nbsp;    /**
<i>1919</i>&nbsp;     * Returns a new CompletableFuture that is asynchronously completed
<i>1920</i>&nbsp;     * by a task running in the given executor with the value obtained
<i>1921</i>&nbsp;     * by calling the given Supplier.
<i>1922</i>&nbsp;     *
<i>1923</i>&nbsp;     * @param supplier a function returning the value to be used
<i>1924</i>&nbsp;     * to complete the returned CompletableFuture
<i>1925</i>&nbsp;     * @param executor the executor to use for asynchronous execution
<i>1926</i>&nbsp;     * @param &lt;U&gt; the function&#39;s return type
<i>1927</i>&nbsp;     * @return the new CompletableFuture
<i>1928</i>&nbsp;     */
<i>1929</i>&nbsp;    public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,
<i>1930</i>&nbsp;                                                       Executor executor) {
<i>1931</i>&nbsp;        return asyncSupplyStage(screenExecutor(executor), supplier);
<i>1932</i>&nbsp;    }
<i>1933</i>&nbsp;
<b class="nc"><i>1934</i>&nbsp;    /**</b>
<i>1935</i>&nbsp;     * Returns a new CompletableFuture that is asynchronously completed
<i>1936</i>&nbsp;     * by a task running in the {@link ForkJoinPool#commonPool()} after
<i>1937</i>&nbsp;     * it runs the given action.
<i>1938</i>&nbsp;     *
<i>1939</i>&nbsp;     * @param runnable the action to run before completing the
<i>1940</i>&nbsp;     * returned CompletableFuture
<i>1941</i>&nbsp;     * @return the new CompletableFuture
<i>1942</i>&nbsp;     */
<i>1943</i>&nbsp;    public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {
<i>1944</i>&nbsp;        return asyncRunStage(ASYNC_POOL, runnable);
<i>1945</i>&nbsp;    }
<i>1946</i>&nbsp;
<i>1947</i>&nbsp;    /**
<i>1948</i>&nbsp;     * Returns a new CompletableFuture that is asynchronously completed
<b class="nc"><i>1949</i>&nbsp;     * by a task running in the given executor after it runs the given</b>
<i>1950</i>&nbsp;     * action.
<i>1951</i>&nbsp;     *
<i>1952</i>&nbsp;     * @param runnable the action to run before completing the
<i>1953</i>&nbsp;     * returned CompletableFuture
<i>1954</i>&nbsp;     * @param executor the executor to use for asynchronous execution
<i>1955</i>&nbsp;     * @return the new CompletableFuture
<i>1956</i>&nbsp;     */
<i>1957</i>&nbsp;    public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,
<i>1958</i>&nbsp;                                                   Executor executor) {
<i>1959</i>&nbsp;        return asyncRunStage(screenExecutor(executor), runnable);
<i>1960</i>&nbsp;    }
<b class="nc"><i>1961</i>&nbsp;</b>
<b class="nc"><i>1962</i>&nbsp;    /**</b>
<b class="nc"><i>1963</i>&nbsp;     * Returns a new CompletableFuture that is already completed with</b>
<i>1964</i>&nbsp;     * the given value.
<i>1965</i>&nbsp;     *
<i>1966</i>&nbsp;     * @param value the value
<i>1967</i>&nbsp;     * @param &lt;U&gt; the type of the value
<i>1968</i>&nbsp;     * @return the completed CompletableFuture
<i>1969</i>&nbsp;     */
<i>1970</i>&nbsp;    public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value) {
<i>1971</i>&nbsp;        return new CompletableFuture&lt;U&gt;((value == null) ? NIL : value);
<i>1972</i>&nbsp;    }
<i>1973</i>&nbsp;
<i>1974</i>&nbsp;    /**
<b class="nc"><i>1975</i>&nbsp;     * Returns {@code true} if completed in any fashion: normally,</b>
<b class="nc"><i>1976</i>&nbsp;     * exceptionally, or via cancellation.</b>
<b class="nc"><i>1977</i>&nbsp;     *</b>
<b class="nc"><i>1978</i>&nbsp;     * @return {@code true} if completed</b>
<i>1979</i>&nbsp;     */
<i>1980</i>&nbsp;    public boolean isDone() {
<i>1981</i>&nbsp;        return result != null;
<i>1982</i>&nbsp;    }
<b class="nc"><i>1983</i>&nbsp;</b>
<i>1984</i>&nbsp;    /**
<i>1985</i>&nbsp;     * Waits if necessary for this future to complete, and then
<i>1986</i>&nbsp;     * returns its result.
<i>1987</i>&nbsp;     *
<b class="nc"><i>1988</i>&nbsp;     * @return the result value</b>
<i>1989</i>&nbsp;     * @throws CancellationException if this future was cancelled
<i>1990</i>&nbsp;     * @throws ExecutionException if this future completed exceptionally
<i>1991</i>&nbsp;     * @throws InterruptedException if the current thread was interrupted
<i>1992</i>&nbsp;     * while waiting
<b class="nc"><i>1993</i>&nbsp;     */</b>
<i>1994</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>1995</i>&nbsp;    public T get() throws InterruptedException, ExecutionException {
<i>1996</i>&nbsp;        Object r;
<b class="nc"><i>1997</i>&nbsp;        if ((r = result) == null)</b>
<i>1998</i>&nbsp;            r = waitingGet(true);
<i>1999</i>&nbsp;        return (T) reportGet(r);
<i>2000</i>&nbsp;    }
<b class="nc"><i>2001</i>&nbsp;</b>
<i>2002</i>&nbsp;    /**
<i>2003</i>&nbsp;     * Waits if necessary for at most the given time for this future
<i>2004</i>&nbsp;     * to complete, and then returns its result, if available.
<i>2005</i>&nbsp;     *
<b class="nc"><i>2006</i>&nbsp;     * @param timeout the maximum time to wait</b>
<i>2007</i>&nbsp;     * @param unit the time unit of the timeout argument
<i>2008</i>&nbsp;     * @return the result value
<i>2009</i>&nbsp;     * @throws CancellationException if this future was cancelled
<b class="nc"><i>2010</i>&nbsp;     * @throws ExecutionException if this future completed exceptionally</b>
<i>2011</i>&nbsp;     * @throws InterruptedException if the current thread was interrupted
<i>2012</i>&nbsp;     * while waiting
<i>2013</i>&nbsp;     * @throws TimeoutException if the wait timed out
<b class="nc"><i>2014</i>&nbsp;     */</b>
<i>2015</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>2016</i>&nbsp;    public T get(long timeout, TimeUnit unit)
<i>2017</i>&nbsp;        throws InterruptedException, ExecutionException, TimeoutException {
<i>2018</i>&nbsp;        long nanos = unit.toNanos(timeout);
<b class="nc"><i>2019</i>&nbsp;        Object r;</b>
<i>2020</i>&nbsp;        if ((r = result) == null)
<i>2021</i>&nbsp;            r = timedGet(nanos);
<i>2022</i>&nbsp;        return (T) reportGet(r);
<i>2023</i>&nbsp;    }
<i>2024</i>&nbsp;
<b class="nc"><i>2025</i>&nbsp;    /**</b>
<i>2026</i>&nbsp;     * Returns the result value when complete, or throws an
<i>2027</i>&nbsp;     * (unchecked) exception if completed exceptionally. To better
<i>2028</i>&nbsp;     * conform with the use of common functional forms, if a
<i>2029</i>&nbsp;     * computation involved in the completion of this
<i>2030</i>&nbsp;     * CompletableFuture threw an exception, this method throws an
<b class="nc"><i>2031</i>&nbsp;     * (unchecked) {@link CompletionException} with the underlying</b>
<i>2032</i>&nbsp;     * exception as its cause.
<i>2033</i>&nbsp;     *
<i>2034</i>&nbsp;     * @return the result value
<i>2035</i>&nbsp;     * @throws CancellationException if the computation was cancelled
<i>2036</i>&nbsp;     * @throws CompletionException if this future completed
<b class="nc"><i>2037</i>&nbsp;     * exceptionally or a completion computation threw an exception</b>
<i>2038</i>&nbsp;     */
<i>2039</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>2040</i>&nbsp;    public T join() {
<i>2041</i>&nbsp;        Object r;
<i>2042</i>&nbsp;        if ((r = result) == null)
<b class="nc"><i>2043</i>&nbsp;            r = waitingGet(false);</b>
<i>2044</i>&nbsp;        return (T) reportJoin(r);
<i>2045</i>&nbsp;    }
<i>2046</i>&nbsp;
<i>2047</i>&nbsp;    /**
<i>2048</i>&nbsp;     * Returns the result value (or throws any encountered exception)
<b class="nc"><i>2049</i>&nbsp;     * if completed, else returns the given valueIfAbsent.</b>
<i>2050</i>&nbsp;     *
<i>2051</i>&nbsp;     * @param valueIfAbsent the value to return if not completed
<i>2052</i>&nbsp;     * @return the result value, if completed, else the given valueIfAbsent
<i>2053</i>&nbsp;     * @throws CancellationException if the computation was cancelled
<i>2054</i>&nbsp;     * @throws CompletionException if this future completed
<b class="nc"><i>2055</i>&nbsp;     * exceptionally or a completion computation threw an exception</b>
<i>2056</i>&nbsp;     */
<i>2057</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>2058</i>&nbsp;    public T getNow(T valueIfAbsent) {
<i>2059</i>&nbsp;        Object r;
<b class="nc"><i>2060</i>&nbsp;        return ((r = result) == null) ? valueIfAbsent : (T) reportJoin(r);</b>
<i>2061</i>&nbsp;    }
<i>2062</i>&nbsp;
<i>2063</i>&nbsp;    /**
<i>2064</i>&nbsp;     * If not already completed, sets the value returned by {@link
<b class="nc"><i>2065</i>&nbsp;     * #get()} and related methods to the given value.</b>
<i>2066</i>&nbsp;     *
<i>2067</i>&nbsp;     * @param value the result value
<i>2068</i>&nbsp;     * @return {@code true} if this invocation caused this CompletableFuture
<i>2069</i>&nbsp;     * to transition to a completed state, else {@code false}
<i>2070</i>&nbsp;     */
<b class="nc"><i>2071</i>&nbsp;    public boolean complete(T value) {</b>
<i>2072</i>&nbsp;        boolean triggered = completeValue(value);
<i>2073</i>&nbsp;        postComplete();
<i>2074</i>&nbsp;        return triggered;
<i>2075</i>&nbsp;    }
<b class="nc"><i>2076</i>&nbsp;</b>
<i>2077</i>&nbsp;    /**
<i>2078</i>&nbsp;     * If not already completed, causes invocations of {@link #get()}
<i>2079</i>&nbsp;     * and related methods to throw the given exception.
<i>2080</i>&nbsp;     *
<b class="nc"><i>2081</i>&nbsp;     * @param ex the exception</b>
<i>2082</i>&nbsp;     * @return {@code true} if this invocation caused this CompletableFuture
<i>2083</i>&nbsp;     * to transition to a completed state, else {@code false}
<i>2084</i>&nbsp;     */
<i>2085</i>&nbsp;    public boolean completeExceptionally(Throwable ex) {
<i>2086</i>&nbsp;        if (ex == null) throw new NullPointerException();
<b class="nc"><i>2087</i>&nbsp;        boolean triggered = internalComplete(new AltResult(ex));</b>
<i>2088</i>&nbsp;        postComplete();
<i>2089</i>&nbsp;        return triggered;
<i>2090</i>&nbsp;    }
<i>2091</i>&nbsp;
<b class="nc"><i>2092</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(</b>
<i>2093</i>&nbsp;        Function&lt;? super T,? extends U&gt; fn) {
<i>2094</i>&nbsp;        return uniApplyStage(null, fn);
<i>2095</i>&nbsp;    }
<i>2096</i>&nbsp;
<b class="nc"><i>2097</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(</b>
<i>2098</i>&nbsp;        Function&lt;? super T,? extends U&gt; fn) {
<i>2099</i>&nbsp;        return uniApplyStage(defaultExecutor(), fn);
<i>2100</i>&nbsp;    }
<i>2101</i>&nbsp;
<i>2102</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(
<b class="nc"><i>2103</i>&nbsp;        Function&lt;? super T,? extends U&gt; fn, Executor executor) {</b>
<i>2104</i>&nbsp;        return uniApplyStage(screenExecutor(executor), fn);
<i>2105</i>&nbsp;    }
<i>2106</i>&nbsp;
<i>2107</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action) {
<b class="nc"><i>2108</i>&nbsp;        return uniAcceptStage(null, action);</b>
<i>2109</i>&nbsp;    }
<i>2110</i>&nbsp;
<i>2111</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action) {
<i>2112</i>&nbsp;        return uniAcceptStage(defaultExecutor(), action);
<b class="nc"><i>2113</i>&nbsp;    }</b>
<i>2114</i>&nbsp;
<i>2115</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action,
<i>2116</i>&nbsp;                                                   Executor executor) {
<i>2117</i>&nbsp;        return uniAcceptStage(screenExecutor(executor), action);
<i>2118</i>&nbsp;    }
<b class="nc"><i>2119</i>&nbsp;</b>
<i>2120</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenRun(Runnable action) {
<i>2121</i>&nbsp;        return uniRunStage(null, action);
<i>2122</i>&nbsp;    }
<i>2123</i>&nbsp;
<b class="nc"><i>2124</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action) {</b>
<i>2125</i>&nbsp;        return uniRunStage(defaultExecutor(), action);
<i>2126</i>&nbsp;    }
<i>2127</i>&nbsp;
<i>2128</i>&nbsp;    public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action,
<b class="nc"><i>2129</i>&nbsp;                                                Executor executor) {</b>
<i>2130</i>&nbsp;        return uniRunStage(screenExecutor(executor), action);
<i>2131</i>&nbsp;    }
<i>2132</i>&nbsp;
<i>2133</i>&nbsp;    public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(
<i>2134</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,
<b class="nc"><i>2135</i>&nbsp;        BiFunction&lt;? super T,? super U,? extends V&gt; fn) {</b>
<i>2136</i>&nbsp;        return biApplyStage(null, other, fn);
<i>2137</i>&nbsp;    }
<i>2138</i>&nbsp;
<i>2139</i>&nbsp;    public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(
<b class="nc"><i>2140</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,</b>
<i>2141</i>&nbsp;        BiFunction&lt;? super T,? super U,? extends V&gt; fn) {
<i>2142</i>&nbsp;        return biApplyStage(defaultExecutor(), other, fn);
<i>2143</i>&nbsp;    }
<i>2144</i>&nbsp;
<b class="nc"><i>2145</i>&nbsp;    public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(</b>
<i>2146</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,
<i>2147</i>&nbsp;        BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor) {
<i>2148</i>&nbsp;        return biApplyStage(screenExecutor(executor), other, fn);
<i>2149</i>&nbsp;    }
<b class="nc"><i>2150</i>&nbsp;</b>
<i>2151</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(
<i>2152</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,
<i>2153</i>&nbsp;        BiConsumer&lt;? super T, ? super U&gt; action) {
<i>2154</i>&nbsp;        return biAcceptStage(null, other, action);
<b class="nc"><i>2155</i>&nbsp;    }</b>
<i>2156</i>&nbsp;
<i>2157</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(
<i>2158</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,
<i>2159</i>&nbsp;        BiConsumer&lt;? super T, ? super U&gt; action) {
<b class="nc"><i>2160</i>&nbsp;        return biAcceptStage(defaultExecutor(), other, action);</b>
<i>2161</i>&nbsp;    }
<i>2162</i>&nbsp;
<i>2163</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(
<i>2164</i>&nbsp;        CompletionStage&lt;? extends U&gt; other,
<b class="nc"><i>2165</i>&nbsp;        BiConsumer&lt;? super T, ? super U&gt; action, Executor executor) {</b>
<i>2166</i>&nbsp;        return biAcceptStage(screenExecutor(executor), other, action);
<i>2167</i>&nbsp;    }
<i>2168</i>&nbsp;
<i>2169</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,
<i>2170</i>&nbsp;                                                Runnable action) {
<i>2171</i>&nbsp;        return biRunStage(null, other, action);
<i>2172</i>&nbsp;    }
<i>2173</i>&nbsp;
<b class="nc"><i>2174</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,</b>
<i>2175</i>&nbsp;                                                     Runnable action) {
<i>2176</i>&nbsp;        return biRunStage(defaultExecutor(), other, action);
<i>2177</i>&nbsp;    }
<i>2178</i>&nbsp;
<i>2179</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,
<i>2180</i>&nbsp;                                                     Runnable action,
<i>2181</i>&nbsp;                                                     Executor executor) {
<i>2182</i>&nbsp;        return biRunStage(screenExecutor(executor), other, action);
<i>2183</i>&nbsp;    }
<i>2184</i>&nbsp;
<i>2185</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(
<i>2186</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) {
<i>2187</i>&nbsp;        return orApplyStage(null, other, fn);
<i>2188</i>&nbsp;    }
<i>2189</i>&nbsp;
<i>2190</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(
<i>2191</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) {
<i>2192</i>&nbsp;        return orApplyStage(defaultExecutor(), other, fn);
<i>2193</i>&nbsp;    }
<i>2194</i>&nbsp;
<i>2195</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(
<b class="nc"><i>2196</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn,</b>
<i>2197</i>&nbsp;        Executor executor) {
<i>2198</i>&nbsp;        return orApplyStage(screenExecutor(executor), other, fn);
<i>2199</i>&nbsp;    }
<i>2200</i>&nbsp;
<i>2201</i>&nbsp;    public CompletableFuture&lt;Void&gt; acceptEither(
<i>2202</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action) {
<i>2203</i>&nbsp;        return orAcceptStage(null, other, action);
<i>2204</i>&nbsp;    }
<i>2205</i>&nbsp;
<i>2206</i>&nbsp;    public CompletableFuture&lt;Void&gt; acceptEitherAsync(
<i>2207</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action) {
<i>2208</i>&nbsp;        return orAcceptStage(defaultExecutor(), other, action);
<i>2209</i>&nbsp;    }
<i>2210</i>&nbsp;
<i>2211</i>&nbsp;    public CompletableFuture&lt;Void&gt; acceptEitherAsync(
<i>2212</i>&nbsp;        CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action,
<i>2213</i>&nbsp;        Executor executor) {
<i>2214</i>&nbsp;        return orAcceptStage(screenExecutor(executor), other, action);
<i>2215</i>&nbsp;    }
<i>2216</i>&nbsp;
<i>2217</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other,
<i>2218</i>&nbsp;                                                  Runnable action) {
<i>2219</i>&nbsp;        return orRunStage(null, other, action);
<i>2220</i>&nbsp;    }
<i>2221</i>&nbsp;
<i>2222</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,
<i>2223</i>&nbsp;                                                       Runnable action) {
<i>2224</i>&nbsp;        return orRunStage(defaultExecutor(), other, action);
<b class="nc"><i>2225</i>&nbsp;    }</b>
<i>2226</i>&nbsp;
<i>2227</i>&nbsp;    public CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,
<i>2228</i>&nbsp;                                                       Runnable action,
<i>2229</i>&nbsp;                                                       Executor executor) {
<i>2230</i>&nbsp;        return orRunStage(screenExecutor(executor), other, action);
<i>2231</i>&nbsp;    }
<i>2232</i>&nbsp;
<i>2233</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(
<i>2234</i>&nbsp;        Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) {
<i>2235</i>&nbsp;        return uniComposeStage(null, fn);
<i>2236</i>&nbsp;    }
<i>2237</i>&nbsp;
<i>2238</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(
<i>2239</i>&nbsp;        Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn) {
<i>2240</i>&nbsp;        return uniComposeStage(defaultExecutor(), fn);
<i>2241</i>&nbsp;    }
<i>2242</i>&nbsp;
<i>2243</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(
<b class="nc"><i>2244</i>&nbsp;        Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn,</b>
<i>2245</i>&nbsp;        Executor executor) {
<i>2246</i>&nbsp;        return uniComposeStage(screenExecutor(executor), fn);
<i>2247</i>&nbsp;    }
<i>2248</i>&nbsp;
<i>2249</i>&nbsp;    public CompletableFuture&lt;T&gt; whenComplete(
<i>2250</i>&nbsp;        BiConsumer&lt;? super T, ? super Throwable&gt; action) {
<i>2251</i>&nbsp;        return uniWhenCompleteStage(null, action);
<i>2252</i>&nbsp;    }
<i>2253</i>&nbsp;
<i>2254</i>&nbsp;    public CompletableFuture&lt;T&gt; whenCompleteAsync(
<i>2255</i>&nbsp;        BiConsumer&lt;? super T, ? super Throwable&gt; action) {
<i>2256</i>&nbsp;        return uniWhenCompleteStage(defaultExecutor(), action);
<i>2257</i>&nbsp;    }
<i>2258</i>&nbsp;
<i>2259</i>&nbsp;    public CompletableFuture&lt;T&gt; whenCompleteAsync(
<i>2260</i>&nbsp;        BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor) {
<i>2261</i>&nbsp;        return uniWhenCompleteStage(screenExecutor(executor), action);
<i>2262</i>&nbsp;    }
<b class="nc"><i>2263</i>&nbsp;</b>
<b class="nc"><i>2264</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; handle(</b>
<b class="nc"><i>2265</i>&nbsp;        BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) {</b>
<b class="nc"><i>2266</i>&nbsp;        return uniHandleStage(null, fn);</b>
<i>2267</i>&nbsp;    }
<i>2268</i>&nbsp;
<i>2269</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(
<i>2270</i>&nbsp;        BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) {
<i>2271</i>&nbsp;        return uniHandleStage(defaultExecutor(), fn);
<i>2272</i>&nbsp;    }
<i>2273</i>&nbsp;
<i>2274</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(
<i>2275</i>&nbsp;        BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor) {
<i>2276</i>&nbsp;        return uniHandleStage(screenExecutor(executor), fn);
<i>2277</i>&nbsp;    }
<b class="nc"><i>2278</i>&nbsp;</b>
<i>2279</i>&nbsp;    /**
<i>2280</i>&nbsp;     * Returns this CompletableFuture.
<i>2281</i>&nbsp;     *
<i>2282</i>&nbsp;     * @return this CompletableFuture
<i>2283</i>&nbsp;     */
<i>2284</i>&nbsp;    public CompletableFuture&lt;T&gt; toCompletableFuture() {
<i>2285</i>&nbsp;        return this;
<i>2286</i>&nbsp;    }
<i>2287</i>&nbsp;
<i>2288</i>&nbsp;    // not in interface CompletionStage
<i>2289</i>&nbsp;
<i>2290</i>&nbsp;    /**
<i>2291</i>&nbsp;     * Returns a new CompletableFuture that is completed when this
<i>2292</i>&nbsp;     * CompletableFuture completes, with the result of the given
<i>2293</i>&nbsp;     * function of the exception triggering this CompletableFuture&#39;s
<b class="nc"><i>2294</i>&nbsp;     * completion when it completes exceptionally; otherwise, if this</b>
<i>2295</i>&nbsp;     * CompletableFuture completes normally, then the returned
<i>2296</i>&nbsp;     * CompletableFuture also completes normally with the same value.
<i>2297</i>&nbsp;     * Note: More flexible versions of this functionality are
<i>2298</i>&nbsp;     * available using methods {@code whenComplete} and {@code handle}.
<i>2299</i>&nbsp;     *
<i>2300</i>&nbsp;     * @param fn the function to use to compute the value of the
<i>2301</i>&nbsp;     * returned CompletableFuture if this CompletableFuture completed
<i>2302</i>&nbsp;     * exceptionally
<i>2303</i>&nbsp;     * @return the new CompletableFuture
<i>2304</i>&nbsp;     */
<i>2305</i>&nbsp;    public CompletableFuture&lt;T&gt; exceptionally(
<i>2306</i>&nbsp;        Function&lt;Throwable, ? extends T&gt; fn) {
<i>2307</i>&nbsp;        return uniExceptionallyStage(fn);
<b class="nc"><i>2308</i>&nbsp;    }</b>
<b class="nc"><i>2309</i>&nbsp;</b>
<i>2310</i>&nbsp;
<i>2311</i>&nbsp;    /* ------------- Arbitrary-arity constructions -------------- */
<i>2312</i>&nbsp;
<i>2313</i>&nbsp;    /**
<i>2314</i>&nbsp;     * Returns a new CompletableFuture that is completed when all of
<i>2315</i>&nbsp;     * the given CompletableFutures complete.  If any of the given
<i>2316</i>&nbsp;     * CompletableFutures complete exceptionally, then the returned
<i>2317</i>&nbsp;     * CompletableFuture also does so, with a CompletionException
<i>2318</i>&nbsp;     * holding this exception as its cause.  Otherwise, the results,
<i>2319</i>&nbsp;     * if any, of the given CompletableFutures are not reflected in
<i>2320</i>&nbsp;     * the returned CompletableFuture, but may be obtained by
<i>2321</i>&nbsp;     * inspecting them individually. If no CompletableFutures are
<i>2322</i>&nbsp;     * provided, returns a CompletableFuture completed with the value
<i>2323</i>&nbsp;     * {@code null}.
<b class="nc"><i>2324</i>&nbsp;     *</b>
<b class="nc"><i>2325</i>&nbsp;     * &lt;p&gt;Among the applications of this method is to await completion</b>
<b class="nc"><i>2326</i>&nbsp;     * of a set of independent CompletableFutures before continuing a</b>
<i>2327</i>&nbsp;     * program, as in: {@code CompletableFuture.allOf(c1, c2,
<i>2328</i>&nbsp;     * c3).join();}.
<i>2329</i>&nbsp;     *
<i>2330</i>&nbsp;     * @param cfs the CompletableFutures
<i>2331</i>&nbsp;     * @return a new CompletableFuture that is completed when all of the
<i>2332</i>&nbsp;     * given CompletableFutures complete
<i>2333</i>&nbsp;     * @throws NullPointerException if the array or any of its elements are
<i>2334</i>&nbsp;     * {@code null}
<i>2335</i>&nbsp;     */
<i>2336</i>&nbsp;    public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs) {
<i>2337</i>&nbsp;        return andTree(cfs, 0, cfs.length - 1);
<b class="nc"><i>2338</i>&nbsp;    }</b>
<b class="nc"><i>2339</i>&nbsp;</b>
<b class="nc"><i>2340</i>&nbsp;    /**</b>
<b class="nc"><i>2341</i>&nbsp;     * Returns a new CompletableFuture that is completed when any of</b>
<i>2342</i>&nbsp;     * the given CompletableFutures complete, with the same result.
<i>2343</i>&nbsp;     * Otherwise, if it completed exceptionally, the returned
<i>2344</i>&nbsp;     * CompletableFuture also does so, with a CompletionException
<i>2345</i>&nbsp;     * holding this exception as its cause.  If no CompletableFutures
<i>2346</i>&nbsp;     * are provided, returns an incomplete CompletableFuture.
<i>2347</i>&nbsp;     *
<i>2348</i>&nbsp;     * @param cfs the CompletableFutures
<i>2349</i>&nbsp;     * @return a new CompletableFuture that is completed with the
<i>2350</i>&nbsp;     * result or exception of any of the given CompletableFutures when
<i>2351</i>&nbsp;     * one completes
<i>2352</i>&nbsp;     * @throws NullPointerException if the array or any of its elements are
<i>2353</i>&nbsp;     * {@code null}
<i>2354</i>&nbsp;     */
<b class="nc"><i>2355</i>&nbsp;    public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs) {</b>
<i>2356</i>&nbsp;        int n; Object r;
<b class="nc"><i>2357</i>&nbsp;        if ((n = cfs.length) &lt;= 1)</b>
<i>2358</i>&nbsp;            return (n == 0)
<b class="nc"><i>2359</i>&nbsp;                ? new CompletableFuture&lt;Object&gt;()</b>
<i>2360</i>&nbsp;                : uniCopyStage(cfs[0]);
<i>2361</i>&nbsp;        for (CompletableFuture&lt;?&gt; cf : cfs)
<i>2362</i>&nbsp;            if ((r = cf.result) != null)
<i>2363</i>&nbsp;                return new CompletableFuture&lt;Object&gt;(encodeRelay(r));
<i>2364</i>&nbsp;        cfs = cfs.clone();
<i>2365</i>&nbsp;        CompletableFuture&lt;Object&gt; d = new CompletableFuture&lt;&gt;();
<i>2366</i>&nbsp;        for (CompletableFuture&lt;?&gt; cf : cfs)
<i>2367</i>&nbsp;            cf.unipush(new AnyOf(d, cf, cfs));
<i>2368</i>&nbsp;        // If d was completed while we were adding completions, we should
<i>2369</i>&nbsp;        // clean the stack of any sources that may have had completions
<i>2370</i>&nbsp;        // pushed on their stack after d was completed.
<i>2371</i>&nbsp;        if (d.result != null)
<i>2372</i>&nbsp;            for (int i = 0, len = cfs.length; i &lt; len; i++)
<i>2373</i>&nbsp;                if (cfs[i].result != null)
<i>2374</i>&nbsp;                    for (i++; i &lt; len; i++)
<b class="nc"><i>2375</i>&nbsp;                        if (cfs[i].result == null)</b>
<b class="nc"><i>2376</i>&nbsp;                            cfs[i].cleanStack();</b>
<b class="nc"><i>2377</i>&nbsp;        return d;</b>
<b class="nc"><i>2378</i>&nbsp;    }</b>
<b class="nc"><i>2379</i>&nbsp;</b>
<b class="nc"><i>2380</i>&nbsp;    /* ------------- Control and status methods -------------- */</b>
<b class="nc"><i>2381</i>&nbsp;</b>
<b class="nc"><i>2382</i>&nbsp;    /**</b>
<b class="nc"><i>2383</i>&nbsp;     * If not already completed, completes this CompletableFuture with</b>
<i>2384</i>&nbsp;     * a {@link CancellationException}. Dependent CompletableFutures
<i>2385</i>&nbsp;     * that have not already completed will also complete
<i>2386</i>&nbsp;     * exceptionally, with a {@link CompletionException} caused by
<i>2387</i>&nbsp;     * this {@code CancellationException}.
<i>2388</i>&nbsp;     *
<i>2389</i>&nbsp;     * @param mayInterruptIfRunning this value has no effect in this
<i>2390</i>&nbsp;     * implementation because interrupts are not used to control
<i>2391</i>&nbsp;     * processing.
<i>2392</i>&nbsp;     *
<i>2393</i>&nbsp;     * @return {@code true} if this task is now cancelled
<i>2394</i>&nbsp;     */
<i>2395</i>&nbsp;    public boolean cancel(boolean mayInterruptIfRunning) {
<i>2396</i>&nbsp;        boolean cancelled = (result == null) &amp;&amp;
<i>2397</i>&nbsp;            internalComplete(new AltResult(new CancellationException()));
<i>2398</i>&nbsp;        postComplete();
<i>2399</i>&nbsp;        return cancelled || isCancelled();
<i>2400</i>&nbsp;    }
<i>2401</i>&nbsp;
<i>2402</i>&nbsp;    /**
<i>2403</i>&nbsp;     * Returns {@code true} if this CompletableFuture was cancelled
<i>2404</i>&nbsp;     * before it completed normally.
<i>2405</i>&nbsp;     *
<i>2406</i>&nbsp;     * @return {@code true} if this CompletableFuture was cancelled
<i>2407</i>&nbsp;     * before it completed normally
<i>2408</i>&nbsp;     */
<i>2409</i>&nbsp;    public boolean isCancelled() {
<i>2410</i>&nbsp;        Object r;
<i>2411</i>&nbsp;        return ((r = result) instanceof AltResult) &amp;&amp;
<i>2412</i>&nbsp;            (((AltResult)r).ex instanceof CancellationException);
<i>2413</i>&nbsp;    }
<i>2414</i>&nbsp;
<i>2415</i>&nbsp;    /**
<i>2416</i>&nbsp;     * Returns {@code true} if this CompletableFuture completed
<i>2417</i>&nbsp;     * exceptionally, in any way. Possible causes include
<i>2418</i>&nbsp;     * cancellation, explicit invocation of {@code
<i>2419</i>&nbsp;     * completeExceptionally}, and abrupt termination of a
<i>2420</i>&nbsp;     * CompletionStage action.
<i>2421</i>&nbsp;     *
<i>2422</i>&nbsp;     * @return {@code true} if this CompletableFuture completed
<i>2423</i>&nbsp;     * exceptionally
<i>2424</i>&nbsp;     */
<i>2425</i>&nbsp;    public boolean isCompletedExceptionally() {
<i>2426</i>&nbsp;        Object r;
<i>2427</i>&nbsp;        return ((r = result) instanceof AltResult) &amp;&amp; r != NIL;
<i>2428</i>&nbsp;    }
<i>2429</i>&nbsp;
<i>2430</i>&nbsp;    /**
<i>2431</i>&nbsp;     * Forcibly sets or resets the value subsequently returned by
<i>2432</i>&nbsp;     * method {@link #get()} and related methods, whether or not
<i>2433</i>&nbsp;     * already completed. This method is designed for use only in
<i>2434</i>&nbsp;     * error recovery actions, and even in such situations may result
<i>2435</i>&nbsp;     * in ongoing dependent completions using established versus
<i>2436</i>&nbsp;     * overwritten outcomes.
<i>2437</i>&nbsp;     *
<i>2438</i>&nbsp;     * @param value the completion value
<i>2439</i>&nbsp;     */
<i>2440</i>&nbsp;    public void obtrudeValue(T value) {
<i>2441</i>&nbsp;        result = (value == null) ? NIL : value;
<i>2442</i>&nbsp;        postComplete();
<i>2443</i>&nbsp;    }
<i>2444</i>&nbsp;
<i>2445</i>&nbsp;    /**
<i>2446</i>&nbsp;     * Forcibly causes subsequent invocations of method {@link #get()}
<i>2447</i>&nbsp;     * and related methods to throw the given exception, whether or
<i>2448</i>&nbsp;     * not already completed. This method is designed for use only in
<i>2449</i>&nbsp;     * error recovery actions, and even in such situations may result
<i>2450</i>&nbsp;     * in ongoing dependent completions using established versus
<i>2451</i>&nbsp;     * overwritten outcomes.
<i>2452</i>&nbsp;     *
<i>2453</i>&nbsp;     * @param ex the exception
<i>2454</i>&nbsp;     * @throws NullPointerException if the exception is null
<i>2455</i>&nbsp;     */
<i>2456</i>&nbsp;    public void obtrudeException(Throwable ex) {
<i>2457</i>&nbsp;        if (ex == null) throw new NullPointerException();
<i>2458</i>&nbsp;        result = new AltResult(ex);
<i>2459</i>&nbsp;        postComplete();
<i>2460</i>&nbsp;    }
<i>2461</i>&nbsp;
<i>2462</i>&nbsp;    /**
<i>2463</i>&nbsp;     * Returns the estimated number of CompletableFutures whose
<i>2464</i>&nbsp;     * completions are awaiting completion of this CompletableFuture.
<i>2465</i>&nbsp;     * This method is designed for use in monitoring system state, not
<i>2466</i>&nbsp;     * for synchronization control.
<i>2467</i>&nbsp;     *
<i>2468</i>&nbsp;     * @return the number of dependent CompletableFutures
<i>2469</i>&nbsp;     */
<i>2470</i>&nbsp;    public int getNumberOfDependents() {
<i>2471</i>&nbsp;        int count = 0;
<i>2472</i>&nbsp;        for (Completion p = stack; p != null; p = p.next)
<i>2473</i>&nbsp;            ++count;
<i>2474</i>&nbsp;        return count;
<i>2475</i>&nbsp;    }
<i>2476</i>&nbsp;
<i>2477</i>&nbsp;    /**
<i>2478</i>&nbsp;     * Returns a string identifying this CompletableFuture, as well as
<i>2479</i>&nbsp;     * its completion state.  The state, in brackets, contains the
<i>2480</i>&nbsp;     * String {@code &quot;Completed Normally&quot;} or the String {@code
<i>2481</i>&nbsp;     * &quot;Completed Exceptionally&quot;}, or the String {@code &quot;Not
<i>2482</i>&nbsp;     * completed&quot;} followed by the number of CompletableFutures
<i>2483</i>&nbsp;     * dependent upon its completion, if any.
<i>2484</i>&nbsp;     *
<i>2485</i>&nbsp;     * @return a string identifying this CompletableFuture, as well as its state
<i>2486</i>&nbsp;     */
<i>2487</i>&nbsp;    public String toString() {
<i>2488</i>&nbsp;        Object r = result;
<i>2489</i>&nbsp;        int count = 0; // avoid call to getNumberOfDependents in case disabled
<i>2490</i>&nbsp;        for (Completion p = stack; p != null; p = p.next)
<i>2491</i>&nbsp;            ++count;
<i>2492</i>&nbsp;        return super.toString() +
<i>2493</i>&nbsp;            ((r == null)
<i>2494</i>&nbsp;             ? ((count == 0)
<i>2495</i>&nbsp;                ? &quot;[Not completed]&quot;
<i>2496</i>&nbsp;                : &quot;[Not completed, &quot; + count + &quot; dependents]&quot;)
<i>2497</i>&nbsp;             : (((r instanceof AltResult) &amp;&amp; ((AltResult)r).ex != null)
<i>2498</i>&nbsp;                ? &quot;[Completed exceptionally: &quot; + ((AltResult)r).ex + &quot;]&quot;
<i>2499</i>&nbsp;                : &quot;[Completed normally]&quot;));
<i>2500</i>&nbsp;    }
<i>2501</i>&nbsp;
<i>2502</i>&nbsp;    // jdk9 additions
<i>2503</i>&nbsp;
<i>2504</i>&nbsp;    /**
<i>2505</i>&nbsp;     * Returns a new incomplete CompletableFuture of the type to be
<i>2506</i>&nbsp;     * returned by a CompletionStage method. Subclasses should
<i>2507</i>&nbsp;     * normally override this method to return an instance of the same
<i>2508</i>&nbsp;     * class as this CompletableFuture. The default implementation
<i>2509</i>&nbsp;     * returns an instance of class CompletableFuture.
<i>2510</i>&nbsp;     *
<i>2511</i>&nbsp;     * @param &lt;U&gt; the type of the value
<i>2512</i>&nbsp;     * @return a new CompletableFuture
<i>2513</i>&nbsp;     * @since 9
<i>2514</i>&nbsp;     */
<i>2515</i>&nbsp;    public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
<i>2516</i>&nbsp;        return new CompletableFuture&lt;U&gt;();
<i>2517</i>&nbsp;    }
<i>2518</i>&nbsp;
<i>2519</i>&nbsp;    /**
<i>2520</i>&nbsp;     * Returns the default Executor used for async methods that do not
<i>2521</i>&nbsp;     * specify an Executor. This class uses the {@link
<i>2522</i>&nbsp;     * ForkJoinPool#commonPool()} if it supports more than one
<i>2523</i>&nbsp;     * parallel thread, or else an Executor using one thread per async
<i>2524</i>&nbsp;     * task.  This method may be overridden in subclasses to return
<i>2525</i>&nbsp;     * an Executor that provides at least one independent thread.
<i>2526</i>&nbsp;     *
<i>2527</i>&nbsp;     * @return the executor
<i>2528</i>&nbsp;     * @since 9
<i>2529</i>&nbsp;     */
<i>2530</i>&nbsp;    public Executor defaultExecutor() {
<i>2531</i>&nbsp;        return ASYNC_POOL;
<i>2532</i>&nbsp;    }
<i>2533</i>&nbsp;
<i>2534</i>&nbsp;    /**
<i>2535</i>&nbsp;     * Returns a new CompletableFuture that is completed normally with
<i>2536</i>&nbsp;     * the same value as this CompletableFuture when it completes
<i>2537</i>&nbsp;     * normally. If this CompletableFuture completes exceptionally,
<i>2538</i>&nbsp;     * then the returned CompletableFuture completes exceptionally
<i>2539</i>&nbsp;     * with a CompletionException with this exception as cause. The
<i>2540</i>&nbsp;     * behavior is equivalent to {@code thenApply(x -&gt; x)}. This
<i>2541</i>&nbsp;     * method may be useful as a form of &quot;defensive copying&quot;, to
<i>2542</i>&nbsp;     * prevent clients from completing, while still being able to
<i>2543</i>&nbsp;     * arrange dependent actions.
<i>2544</i>&nbsp;     *
<i>2545</i>&nbsp;     * @return the new CompletableFuture
<i>2546</i>&nbsp;     * @since 9
<i>2547</i>&nbsp;     */
<i>2548</i>&nbsp;    public CompletableFuture&lt;T&gt; copy() {
<i>2549</i>&nbsp;        return uniCopyStage(this);
<i>2550</i>&nbsp;    }
<i>2551</i>&nbsp;
<i>2552</i>&nbsp;    /**
<i>2553</i>&nbsp;     * Returns a new CompletionStage that is completed normally with
<i>2554</i>&nbsp;     * the same value as this CompletableFuture when it completes
<i>2555</i>&nbsp;     * normally, and cannot be independently completed or otherwise
<i>2556</i>&nbsp;     * used in ways not defined by the methods of interface {@link
<i>2557</i>&nbsp;     * CompletionStage}.  If this CompletableFuture completes
<i>2558</i>&nbsp;     * exceptionally, then the returned CompletionStage completes
<i>2559</i>&nbsp;     * exceptionally with a CompletionException with this exception as
<i>2560</i>&nbsp;     * cause.
<i>2561</i>&nbsp;     *
<i>2562</i>&nbsp;     * &lt;p&gt;Unless overridden by a subclass, a new non-minimal
<i>2563</i>&nbsp;     * CompletableFuture with all methods available can be obtained from
<i>2564</i>&nbsp;     * a minimal CompletionStage via {@link #toCompletableFuture()}.
<i>2565</i>&nbsp;     * For example, completion of a minimal stage can be awaited by
<i>2566</i>&nbsp;     *
<i>2567</i>&nbsp;     * &lt;pre&gt; {@code minimalStage.toCompletableFuture().join(); }&lt;/pre&gt;
<i>2568</i>&nbsp;     *
<i>2569</i>&nbsp;     * @return the new CompletionStage
<i>2570</i>&nbsp;     * @since 9
<i>2571</i>&nbsp;     */
<i>2572</i>&nbsp;    public CompletionStage&lt;T&gt; minimalCompletionStage() {
<i>2573</i>&nbsp;        return uniAsMinimalStage();
<i>2574</i>&nbsp;    }
<i>2575</i>&nbsp;
<i>2576</i>&nbsp;    /**
<i>2577</i>&nbsp;     * Completes this CompletableFuture with the result of
<i>2578</i>&nbsp;     * the given Supplier function invoked from an asynchronous
<i>2579</i>&nbsp;     * task using the given executor.
<i>2580</i>&nbsp;     *
<i>2581</i>&nbsp;     * @param supplier a function returning the value to be used
<i>2582</i>&nbsp;     * to complete this CompletableFuture
<i>2583</i>&nbsp;     * @param executor the executor to use for asynchronous execution
<i>2584</i>&nbsp;     * @return this CompletableFuture
<i>2585</i>&nbsp;     * @since 9
<i>2586</i>&nbsp;     */
<i>2587</i>&nbsp;    public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier,
<i>2588</i>&nbsp;                                              Executor executor) {
<i>2589</i>&nbsp;        if (supplier == null || executor == null)
<i>2590</i>&nbsp;            throw new NullPointerException();
<i>2591</i>&nbsp;        executor.execute(new AsyncSupply&lt;T&gt;(this, supplier));
<i>2592</i>&nbsp;        return this;
<i>2593</i>&nbsp;    }
<i>2594</i>&nbsp;
<i>2595</i>&nbsp;    /**
<i>2596</i>&nbsp;     * Completes this CompletableFuture with the result of the given
<i>2597</i>&nbsp;     * Supplier function invoked from an asynchronous task using the
<i>2598</i>&nbsp;     * default executor.
<i>2599</i>&nbsp;     *
<i>2600</i>&nbsp;     * @param supplier a function returning the value to be used
<i>2601</i>&nbsp;     * to complete this CompletableFuture
<i>2602</i>&nbsp;     * @return this CompletableFuture
<i>2603</i>&nbsp;     * @since 9
<i>2604</i>&nbsp;     */
<i>2605</i>&nbsp;    public CompletableFuture&lt;T&gt; completeAsync(Supplier&lt;? extends T&gt; supplier) {
<i>2606</i>&nbsp;        return completeAsync(supplier, defaultExecutor());
<i>2607</i>&nbsp;    }
<i>2608</i>&nbsp;
<i>2609</i>&nbsp;    /**
<i>2610</i>&nbsp;     * Exceptionally completes this CompletableFuture with
<i>2611</i>&nbsp;     * a {@link TimeoutException} if not otherwise completed
<i>2612</i>&nbsp;     * before the given timeout.
<i>2613</i>&nbsp;     *
<i>2614</i>&nbsp;     * @param timeout how long to wait before completing exceptionally
<i>2615</i>&nbsp;     *        with a TimeoutException, in units of {@code unit}
<i>2616</i>&nbsp;     * @param unit a {@code TimeUnit} determining how to interpret the
<i>2617</i>&nbsp;     *        {@code timeout} parameter
<i>2618</i>&nbsp;     * @return this CompletableFuture
<i>2619</i>&nbsp;     * @since 9
<i>2620</i>&nbsp;     */
<i>2621</i>&nbsp;    public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit) {
<i>2622</i>&nbsp;        if (unit == null)
<i>2623</i>&nbsp;            throw new NullPointerException();
<i>2624</i>&nbsp;        if (result == null)
<i>2625</i>&nbsp;            whenComplete(new Canceller(Delayer.delay(new Timeout(this),
<i>2626</i>&nbsp;                                                     timeout, unit)));
<i>2627</i>&nbsp;        return this;
<i>2628</i>&nbsp;    }
<i>2629</i>&nbsp;
<i>2630</i>&nbsp;    /**
<i>2631</i>&nbsp;     * Completes this CompletableFuture with the given value if not
<i>2632</i>&nbsp;     * otherwise completed before the given timeout.
<i>2633</i>&nbsp;     *
<i>2634</i>&nbsp;     * @param value the value to use upon timeout
<i>2635</i>&nbsp;     * @param timeout how long to wait before completing normally
<i>2636</i>&nbsp;     *        with the given value, in units of {@code unit}
<i>2637</i>&nbsp;     * @param unit a {@code TimeUnit} determining how to interpret the
<i>2638</i>&nbsp;     *        {@code timeout} parameter
<i>2639</i>&nbsp;     * @return this CompletableFuture
<i>2640</i>&nbsp;     * @since 9
<i>2641</i>&nbsp;     */
<i>2642</i>&nbsp;    public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout,
<i>2643</i>&nbsp;                                                  TimeUnit unit) {
<i>2644</i>&nbsp;        if (unit == null)
<i>2645</i>&nbsp;            throw new NullPointerException();
<i>2646</i>&nbsp;        if (result == null)
<i>2647</i>&nbsp;            whenComplete(new Canceller(Delayer.delay(
<i>2648</i>&nbsp;                                           new DelayedCompleter&lt;T&gt;(this, value),
<i>2649</i>&nbsp;                                           timeout, unit)));
<i>2650</i>&nbsp;        return this;
<i>2651</i>&nbsp;    }
<i>2652</i>&nbsp;
<i>2653</i>&nbsp;    /**
<i>2654</i>&nbsp;     * Returns a new Executor that submits a task to the given base
<i>2655</i>&nbsp;     * executor after the given delay (or no delay if non-positive).
<i>2656</i>&nbsp;     * Each delay commences upon invocation of the returned executor&#39;s
<i>2657</i>&nbsp;     * {@code execute} method.
<i>2658</i>&nbsp;     *
<i>2659</i>&nbsp;     * @param delay how long to delay, in units of {@code unit}
<i>2660</i>&nbsp;     * @param unit a {@code TimeUnit} determining how to interpret the
<i>2661</i>&nbsp;     *        {@code delay} parameter
<i>2662</i>&nbsp;     * @param executor the base executor
<i>2663</i>&nbsp;     * @return the new delayed executor
<i>2664</i>&nbsp;     * @since 9
<i>2665</i>&nbsp;     */
<i>2666</i>&nbsp;    public static Executor delayedExecutor(long delay, TimeUnit unit,
<i>2667</i>&nbsp;                                           Executor executor) {
<i>2668</i>&nbsp;        if (unit == null || executor == null)
<i>2669</i>&nbsp;            throw new NullPointerException();
<i>2670</i>&nbsp;        return new DelayedExecutor(delay, unit, executor);
<i>2671</i>&nbsp;    }
<i>2672</i>&nbsp;
<i>2673</i>&nbsp;    /**
<i>2674</i>&nbsp;     * Returns a new Executor that submits a task to the default
<i>2675</i>&nbsp;     * executor after the given delay (or no delay if non-positive).
<i>2676</i>&nbsp;     * Each delay commences upon invocation of the returned executor&#39;s
<i>2677</i>&nbsp;     * {@code execute} method.
<i>2678</i>&nbsp;     *
<i>2679</i>&nbsp;     * @param delay how long to delay, in units of {@code unit}
<i>2680</i>&nbsp;     * @param unit a {@code TimeUnit} determining how to interpret the
<i>2681</i>&nbsp;     *        {@code delay} parameter
<i>2682</i>&nbsp;     * @return the new delayed executor
<i>2683</i>&nbsp;     * @since 9
<i>2684</i>&nbsp;     */
<i>2685</i>&nbsp;    public static Executor delayedExecutor(long delay, TimeUnit unit) {
<i>2686</i>&nbsp;        if (unit == null)
<i>2687</i>&nbsp;            throw new NullPointerException();
<i>2688</i>&nbsp;        return new DelayedExecutor(delay, unit, ASYNC_POOL);
<i>2689</i>&nbsp;    }
<i>2690</i>&nbsp;
<i>2691</i>&nbsp;    /**
<i>2692</i>&nbsp;     * Returns a new CompletionStage that is already completed with
<i>2693</i>&nbsp;     * the given value and supports only those methods in
<i>2694</i>&nbsp;     * interface {@link CompletionStage}.
<i>2695</i>&nbsp;     *
<i>2696</i>&nbsp;     * @param value the value
<i>2697</i>&nbsp;     * @param &lt;U&gt; the type of the value
<i>2698</i>&nbsp;     * @return the completed CompletionStage
<i>2699</i>&nbsp;     * @since 9
<i>2700</i>&nbsp;     */
<i>2701</i>&nbsp;    public static &lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value) {
<i>2702</i>&nbsp;        return new MinimalStage&lt;U&gt;((value == null) ? NIL : value);
<i>2703</i>&nbsp;    }
<i>2704</i>&nbsp;
<i>2705</i>&nbsp;    /**
<i>2706</i>&nbsp;     * Returns a new CompletableFuture that is already completed
<i>2707</i>&nbsp;     * exceptionally with the given exception.
<i>2708</i>&nbsp;     *
<i>2709</i>&nbsp;     * @param ex the exception
<i>2710</i>&nbsp;     * @param &lt;U&gt; the type of the value
<i>2711</i>&nbsp;     * @return the exceptionally completed CompletableFuture
<i>2712</i>&nbsp;     * @since 9
<i>2713</i>&nbsp;     */
<i>2714</i>&nbsp;    public static &lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex) {
<i>2715</i>&nbsp;        if (ex == null) throw new NullPointerException();
<i>2716</i>&nbsp;        return new CompletableFuture&lt;U&gt;(new AltResult(ex));
<i>2717</i>&nbsp;    }
<i>2718</i>&nbsp;
<i>2719</i>&nbsp;    /**
<i>2720</i>&nbsp;     * Returns a new CompletionStage that is already completed
<i>2721</i>&nbsp;     * exceptionally with the given exception and supports only those
<i>2722</i>&nbsp;     * methods in interface {@link CompletionStage}.
<i>2723</i>&nbsp;     *
<i>2724</i>&nbsp;     * @param ex the exception
<i>2725</i>&nbsp;     * @param &lt;U&gt; the type of the value
<i>2726</i>&nbsp;     * @return the exceptionally completed CompletionStage
<i>2727</i>&nbsp;     * @since 9
<i>2728</i>&nbsp;     */
<i>2729</i>&nbsp;    public static &lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex) {
<i>2730</i>&nbsp;        if (ex == null) throw new NullPointerException();
<i>2731</i>&nbsp;        return new MinimalStage&lt;U&gt;(new AltResult(ex));
<i>2732</i>&nbsp;    }
<i>2733</i>&nbsp;
<i>2734</i>&nbsp;    /**
<i>2735</i>&nbsp;     * Singleton delay scheduler, used only for starting and
<i>2736</i>&nbsp;     * cancelling tasks.
<i>2737</i>&nbsp;     */
<i>2738</i>&nbsp;    static final class Delayer {
<i>2739</i>&nbsp;        static ScheduledFuture&lt;?&gt; delay(Runnable command, long delay,
<i>2740</i>&nbsp;                                        TimeUnit unit) {
<i>2741</i>&nbsp;            return delayer.schedule(command, delay, unit);
<i>2742</i>&nbsp;        }
<i>2743</i>&nbsp;
<i>2744</i>&nbsp;        static final class DaemonThreadFactory implements ThreadFactory {
<i>2745</i>&nbsp;            public Thread newThread(Runnable r) {
<i>2746</i>&nbsp;                Thread t = new Thread(r);
<i>2747</i>&nbsp;                t.setDaemon(true);
<i>2748</i>&nbsp;                t.setName(&quot;CompletableFutureDelayScheduler&quot;);
<i>2749</i>&nbsp;                return t;
<i>2750</i>&nbsp;            }
<i>2751</i>&nbsp;        }
<i>2752</i>&nbsp;
<i>2753</i>&nbsp;        static final ScheduledThreadPoolExecutor delayer;
<i>2754</i>&nbsp;        static {
<i>2755</i>&nbsp;            (delayer = new ScheduledThreadPoolExecutor(
<i>2756</i>&nbsp;                1, new DaemonThreadFactory())).
<i>2757</i>&nbsp;                setRemoveOnCancelPolicy(true);
<i>2758</i>&nbsp;        }
<i>2759</i>&nbsp;    }
<i>2760</i>&nbsp;
<i>2761</i>&nbsp;    // Little class-ified lambdas to better support monitoring
<i>2762</i>&nbsp;
<i>2763</i>&nbsp;    static final class DelayedExecutor implements Executor {
<i>2764</i>&nbsp;        final long delay;
<i>2765</i>&nbsp;        final TimeUnit unit;
<i>2766</i>&nbsp;        final Executor executor;
<i>2767</i>&nbsp;        DelayedExecutor(long delay, TimeUnit unit, Executor executor) {
<i>2768</i>&nbsp;            this.delay = delay; this.unit = unit; this.executor = executor;
<i>2769</i>&nbsp;        }
<i>2770</i>&nbsp;        public void execute(Runnable r) {
<i>2771</i>&nbsp;            Delayer.delay(new TaskSubmitter(executor, r), delay, unit);
<i>2772</i>&nbsp;        }
<i>2773</i>&nbsp;    }
<i>2774</i>&nbsp;
<i>2775</i>&nbsp;    /** Action to submit user task */
<i>2776</i>&nbsp;    static final class TaskSubmitter implements Runnable {
<i>2777</i>&nbsp;        final Executor executor;
<i>2778</i>&nbsp;        final Runnable action;
<i>2779</i>&nbsp;        TaskSubmitter(Executor executor, Runnable action) {
<i>2780</i>&nbsp;            this.executor = executor;
<i>2781</i>&nbsp;            this.action = action;
<i>2782</i>&nbsp;        }
<i>2783</i>&nbsp;        public void run() { executor.execute(action); }
<i>2784</i>&nbsp;    }
<i>2785</i>&nbsp;
<i>2786</i>&nbsp;    /** Action to completeExceptionally on timeout */
<i>2787</i>&nbsp;    static final class Timeout implements Runnable {
<i>2788</i>&nbsp;        final CompletableFuture&lt;?&gt; f;
<i>2789</i>&nbsp;        Timeout(CompletableFuture&lt;?&gt; f) { this.f = f; }
<i>2790</i>&nbsp;        public void run() {
<i>2791</i>&nbsp;            if (f != null &amp;&amp; !f.isDone())
<i>2792</i>&nbsp;                f.completeExceptionally(new TimeoutException());
<i>2793</i>&nbsp;        }
<i>2794</i>&nbsp;    }
<i>2795</i>&nbsp;
<i>2796</i>&nbsp;    /** Action to complete on timeout */
<i>2797</i>&nbsp;    static final class DelayedCompleter&lt;U&gt; implements Runnable {
<i>2798</i>&nbsp;        final CompletableFuture&lt;U&gt; f;
<i>2799</i>&nbsp;        final U u;
<i>2800</i>&nbsp;        DelayedCompleter(CompletableFuture&lt;U&gt; f, U u) { this.f = f; this.u = u; }
<i>2801</i>&nbsp;        public void run() {
<i>2802</i>&nbsp;            if (f != null)
<i>2803</i>&nbsp;                f.complete(u);
<i>2804</i>&nbsp;        }
<i>2805</i>&nbsp;    }
<i>2806</i>&nbsp;
<i>2807</i>&nbsp;    /** Action to cancel unneeded timeouts */
<i>2808</i>&nbsp;    static final class Canceller implements BiConsumer&lt;Object, Throwable&gt; {
<i>2809</i>&nbsp;        final Future&lt;?&gt; f;
<i>2810</i>&nbsp;        Canceller(Future&lt;?&gt; f) { this.f = f; }
<i>2811</i>&nbsp;        public void accept(Object ignore, Throwable ex) {
<i>2812</i>&nbsp;            if (ex == null &amp;&amp; f != null &amp;&amp; !f.isDone())
<i>2813</i>&nbsp;                f.cancel(false);
<i>2814</i>&nbsp;        }
<i>2815</i>&nbsp;    }
<i>2816</i>&nbsp;
<i>2817</i>&nbsp;    /**
<i>2818</i>&nbsp;     * A subclass that just throws UOE for most non-CompletionStage methods.
<i>2819</i>&nbsp;     */
<i>2820</i>&nbsp;    static final class MinimalStage&lt;T&gt; extends CompletableFuture&lt;T&gt; {
<i>2821</i>&nbsp;        MinimalStage() { }
<i>2822</i>&nbsp;        MinimalStage(Object r) { super(r); }
<i>2823</i>&nbsp;        @Override public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture() {
<i>2824</i>&nbsp;            return new MinimalStage&lt;U&gt;(); }
<i>2825</i>&nbsp;        @Override public T get() {
<i>2826</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2827</i>&nbsp;        @Override public T get(long timeout, TimeUnit unit) {
<i>2828</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2829</i>&nbsp;        @Override public T getNow(T valueIfAbsent) {
<i>2830</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2831</i>&nbsp;        @Override public T join() {
<i>2832</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2833</i>&nbsp;        @Override public boolean complete(T value) {
<i>2834</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2835</i>&nbsp;        @Override public boolean completeExceptionally(Throwable ex) {
<i>2836</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2837</i>&nbsp;        @Override public boolean cancel(boolean mayInterruptIfRunning) {
<i>2838</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2839</i>&nbsp;        @Override public void obtrudeValue(T value) {
<i>2840</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2841</i>&nbsp;        @Override public void obtrudeException(Throwable ex) {
<i>2842</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2843</i>&nbsp;        @Override public boolean isDone() {
<i>2844</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2845</i>&nbsp;        @Override public boolean isCancelled() {
<i>2846</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2847</i>&nbsp;        @Override public boolean isCompletedExceptionally() {
<i>2848</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2849</i>&nbsp;        @Override public int getNumberOfDependents() {
<i>2850</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2851</i>&nbsp;        @Override public CompletableFuture&lt;T&gt; completeAsync
<i>2852</i>&nbsp;            (Supplier&lt;? extends T&gt; supplier, Executor executor) {
<i>2853</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2854</i>&nbsp;        @Override public CompletableFuture&lt;T&gt; completeAsync
<i>2855</i>&nbsp;            (Supplier&lt;? extends T&gt; supplier) {
<i>2856</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2857</i>&nbsp;        @Override public CompletableFuture&lt;T&gt; orTimeout
<i>2858</i>&nbsp;            (long timeout, TimeUnit unit) {
<i>2859</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2860</i>&nbsp;        @Override public CompletableFuture&lt;T&gt; completeOnTimeout
<i>2861</i>&nbsp;            (T value, long timeout, TimeUnit unit) {
<i>2862</i>&nbsp;            throw new UnsupportedOperationException(); }
<i>2863</i>&nbsp;        @Override public CompletableFuture&lt;T&gt; toCompletableFuture() {
<i>2864</i>&nbsp;            Object r;
<i>2865</i>&nbsp;            if ((r = result) != null)
<i>2866</i>&nbsp;                return new CompletableFuture&lt;T&gt;(encodeRelay(r));
<i>2867</i>&nbsp;            else {
<i>2868</i>&nbsp;                CompletableFuture&lt;T&gt; d = new CompletableFuture&lt;&gt;();
<i>2869</i>&nbsp;                unipush(new UniRelay&lt;T,T&gt;(d, this));
<i>2870</i>&nbsp;                return d;
<i>2871</i>&nbsp;            }
<i>2872</i>&nbsp;        }
<i>2873</i>&nbsp;    }
<i>2874</i>&nbsp;
<i>2875</i>&nbsp;    // VarHandle mechanics
<i>2876</i>&nbsp;    private static final VarHandle RESULT;
<i>2877</i>&nbsp;    private static final VarHandle STACK;
<i>2878</i>&nbsp;    private static final VarHandle NEXT;
<i>2879</i>&nbsp;    static {
<i>2880</i>&nbsp;        try {
<i>2881</i>&nbsp;            MethodHandles.Lookup l = MethodHandles.lookup();
<i>2882</i>&nbsp;            RESULT = l.findVarHandle(CompletableFuture.class, &quot;result&quot;, Object.class);
<i>2883</i>&nbsp;            STACK = l.findVarHandle(CompletableFuture.class, &quot;stack&quot;, Completion.class);
<i>2884</i>&nbsp;            NEXT = l.findVarHandle(Completion.class, &quot;next&quot;, Completion.class);
<i>2885</i>&nbsp;        } catch (ReflectiveOperationException e) {
<i>2886</i>&nbsp;            throw new ExceptionInInitializerError(e);
<i>2887</i>&nbsp;        }
<i>2888</i>&nbsp;
<i>2889</i>&nbsp;        // Reduce the risk of rare disastrous classloading in first call to
<i>2890</i>&nbsp;        // LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773
<i>2891</i>&nbsp;        Class&lt;?&gt; ensureLoaded = LockSupport.class;
<i>2892</i>&nbsp;    }
<i>2893</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
