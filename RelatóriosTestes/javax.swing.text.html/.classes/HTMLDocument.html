


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: HTMLDocument</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.swing.text.html</a> ]
</div>

<h1>Coverage Summary for Class: HTMLDocument (javax.swing.text.html)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HTMLDocument</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 357)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HTMLDocument$BlockElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$FixedLengthDocument</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 532)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$AnchorAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$AreaAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$BaseAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$BlockAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$CharacterAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$ConvertAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$FormAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 81)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$FormTagAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$HeadAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$HiddenAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$IsindexAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$LinkAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$MapAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$MetaAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$ObjectAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$ParagraphAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$PreAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$SpecialAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$StyleAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$TagAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$HTMLReader$TitleAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$Iterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$LeafIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$RunElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HTMLDocument$TaggedAttributeSet</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 175)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1258)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;package javax.swing.text.html;
<i>26</i>&nbsp;
<i>27</i>&nbsp;import java.awt.font.TextAttribute;
<i>28</i>&nbsp;import java.util.*;
<i>29</i>&nbsp;import java.net.URL;
<i>30</i>&nbsp;import java.net.MalformedURLException;
<i>31</i>&nbsp;import java.io.*;
<i>32</i>&nbsp;import javax.swing.*;
<i>33</i>&nbsp;import javax.swing.event.*;
<i>34</i>&nbsp;import javax.swing.text.*;
<i>35</i>&nbsp;import javax.swing.undo.*;
<i>36</i>&nbsp;import sun.swing.SwingUtilities2;
<i>37</i>&nbsp;import static sun.swing.SwingUtilities2.IMPLIED_CR;
<i>38</i>&nbsp;
<i>39</i>&nbsp;/**
<i>40</i>&nbsp; * A document that models HTML.  The purpose of this model is to
<i>41</i>&nbsp; * support both browsing and editing.  As a result, the structure
<i>42</i>&nbsp; * described by an HTML document is not exactly replicated by default.
<i>43</i>&nbsp; * The element structure that is modeled by default, is built by the
<i>44</i>&nbsp; * class &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;, which implements the
<i>45</i>&nbsp; * &lt;code&gt;HTMLEditorKit.ParserCallback&lt;/code&gt; protocol that the parser
<i>46</i>&nbsp; * expects.  To change the structure one can subclass
<i>47</i>&nbsp; * &lt;code&gt;HTMLReader&lt;/code&gt;, and reimplement the method {@link
<i>48</i>&nbsp; * #getReader(int)} to return the new reader implementation.  The
<i>49</i>&nbsp; * documentation for &lt;code&gt;HTMLReader&lt;/code&gt; should be consulted for
<i>50</i>&nbsp; * the details of the default structure created.  The intent is that
<i>51</i>&nbsp; * the document be non-lossy (although reproducing the HTML format may
<i>52</i>&nbsp; * result in a different format).
<i>53</i>&nbsp; *
<i>54</i>&nbsp; * &lt;p&gt;The document models only HTML, and makes no attempt to store
<i>55</i>&nbsp; * view attributes in it.  The elements are identified by the
<i>56</i>&nbsp; * &lt;code&gt;StyleContext.NameAttribute&lt;/code&gt; attribute, which should
<i>57</i>&nbsp; * always have a value of type &lt;code&gt;HTML.Tag&lt;/code&gt; that identifies
<i>58</i>&nbsp; * the kind of element.  Some of the elements (such as comments) are
<i>59</i>&nbsp; * synthesized.  The &lt;code&gt;HTMLFactory&lt;/code&gt; uses this attribute to
<i>60</i>&nbsp; * determine what kind of view to build.&lt;/p&gt;
<i>61</i>&nbsp; *
<i>62</i>&nbsp; * &lt;p&gt;This document supports incremental loading.  The
<i>63</i>&nbsp; * &lt;code&gt;TokenThreshold&lt;/code&gt; property controls how much of the parse
<i>64</i>&nbsp; * is buffered before trying to update the element structure of the
<i>65</i>&nbsp; * document.  This property is set by the &lt;code&gt;EditorKit&lt;/code&gt; so
<i>66</i>&nbsp; * that subclasses can disable it.&lt;/p&gt;
<i>67</i>&nbsp; *
<i>68</i>&nbsp; * &lt;p&gt;The &lt;code&gt;Base&lt;/code&gt; property determines the URL against which
<i>69</i>&nbsp; * relative URLs are resolved.  By default, this will be the
<i>70</i>&nbsp; * &lt;code&gt;Document.StreamDescriptionProperty&lt;/code&gt; if the value of the
<i>71</i>&nbsp; * property is a URL.  If a &amp;lt;BASE&amp;gt; tag is encountered, the base
<i>72</i>&nbsp; * will become the URL specified by that tag.  Because the base URL is
<i>73</i>&nbsp; * a property, it can of course be set directly.&lt;/p&gt;
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * &lt;p&gt;The default content storage mechanism for this document is a gap
<i>76</i>&nbsp; * buffer (&lt;code&gt;GapContent&lt;/code&gt;).  Alternatives can be supplied by
<i>77</i>&nbsp; * using the constructor that takes a &lt;code&gt;Content&lt;/code&gt;
<i>78</i>&nbsp; * implementation.&lt;/p&gt;
<i>79</i>&nbsp; *
<i>80</i>&nbsp; * &lt;h2&gt;Modifying HTMLDocument&lt;/h2&gt;
<i>81</i>&nbsp; *
<i>82</i>&nbsp; * &lt;p&gt;In addition to the methods provided by Document and
<i>83</i>&nbsp; * StyledDocument for mutating an HTMLDocument, HTMLDocument provides
<i>84</i>&nbsp; * a number of convenience methods.  The following methods can be used
<i>85</i>&nbsp; * to insert HTML content into an existing document.&lt;/p&gt;
<i>86</i>&nbsp; *
<i>87</i>&nbsp; * &lt;ul&gt;
<i>88</i>&nbsp; *   &lt;li&gt;{@link #setInnerHTML(Element, String)}&lt;/li&gt;
<i>89</i>&nbsp; *   &lt;li&gt;{@link #setOuterHTML(Element, String)}&lt;/li&gt;
<i>90</i>&nbsp; *   &lt;li&gt;{@link #insertBeforeStart(Element, String)}&lt;/li&gt;
<i>91</i>&nbsp; *   &lt;li&gt;{@link #insertAfterStart(Element, String)}&lt;/li&gt;
<i>92</i>&nbsp; *   &lt;li&gt;{@link #insertBeforeEnd(Element, String)}&lt;/li&gt;
<i>93</i>&nbsp; *   &lt;li&gt;{@link #insertAfterEnd(Element, String)}&lt;/li&gt;
<i>94</i>&nbsp; * &lt;/ul&gt;
<i>95</i>&nbsp; *
<i>96</i>&nbsp; * &lt;p&gt;The following examples illustrate using these methods.  Each
<i>97</i>&nbsp; * example assumes the HTML document is initialized in the following
<i>98</i>&nbsp; * way:&lt;/p&gt;
<i>99</i>&nbsp; *
<i>100</i>&nbsp; * &lt;pre&gt;
<i>101</i>&nbsp; * JEditorPane p = new JEditorPane();
<i>102</i>&nbsp; * p.setContentType(&quot;text/html&quot;);
<i>103</i>&nbsp; * p.setText(&quot;...&quot;); // Document text is provided below.
<i>104</i>&nbsp; * HTMLDocument d = (HTMLDocument) p.getDocument();
<i>105</i>&nbsp; * &lt;/pre&gt;
<i>106</i>&nbsp; *
<i>107</i>&nbsp; * &lt;p&gt;With the following HTML content:&lt;/p&gt;
<i>108</i>&nbsp; *
<i>109</i>&nbsp; * &lt;pre&gt;
<i>110</i>&nbsp; * &amp;lt;html&amp;gt;
<i>111</i>&nbsp; *   &amp;lt;head&amp;gt;
<i>112</i>&nbsp; *     &amp;lt;title&amp;gt;An example HTMLDocument&amp;lt;/title&amp;gt;
<i>113</i>&nbsp; *     &amp;lt;style type=&quot;text/css&quot;&amp;gt;
<i>114</i>&nbsp; *       div { background-color: silver; }
<i>115</i>&nbsp; *       ul { color: blue; }
<i>116</i>&nbsp; *     &amp;lt;/style&amp;gt;
<i>117</i>&nbsp; *   &amp;lt;/head&amp;gt;
<i>118</i>&nbsp; *   &amp;lt;body&amp;gt;
<i>119</i>&nbsp; *     &amp;lt;div id=&quot;BOX&quot;&amp;gt;
<i>120</i>&nbsp; *       &amp;lt;p&amp;gt;Paragraph 1&amp;lt;/p&amp;gt;
<i>121</i>&nbsp; *       &amp;lt;p&amp;gt;Paragraph 2&amp;lt;/p&amp;gt;
<i>122</i>&nbsp; *     &amp;lt;/div&amp;gt;
<i>123</i>&nbsp; *   &amp;lt;/body&amp;gt;
<i>124</i>&nbsp; * &amp;lt;/html&amp;gt;
<i>125</i>&nbsp; * &lt;/pre&gt;
<i>126</i>&nbsp; *
<i>127</i>&nbsp; * &lt;p&gt;All the methods for modifying an HTML document require an {@link
<i>128</i>&nbsp; * Element}.  Elements can be obtained from an HTML document by using
<i>129</i>&nbsp; * the method {@link #getElement(Element e, Object attribute, Object
<i>130</i>&nbsp; * value)}.  It returns the first descendant element that contains the
<i>131</i>&nbsp; * specified attribute with the given value, in depth-first order.
<i>132</i>&nbsp; * For example, &lt;code&gt;d.getElement(d.getDefaultRootElement(),
<i>133</i>&nbsp; * StyleConstants.NameAttribute, HTML.Tag.P)&lt;/code&gt; returns the first
<i>134</i>&nbsp; * paragraph element.&lt;/p&gt;
<i>135</i>&nbsp; *
<i>136</i>&nbsp; * &lt;p&gt;A convenient shortcut for locating elements is the method {@link
<i>137</i>&nbsp; * #getElement(String)}; returns an element whose &lt;code&gt;ID&lt;/code&gt;
<i>138</i>&nbsp; * attribute matches the specified value.  For example,
<i>139</i>&nbsp; * &lt;code&gt;d.getElement(&quot;BOX&quot;)&lt;/code&gt; returns the &lt;code&gt;DIV&lt;/code&gt;
<i>140</i>&nbsp; * element.&lt;/p&gt;
<i>141</i>&nbsp; *
<i>142</i>&nbsp; * &lt;p&gt;The {@link #getIterator(HTML.Tag t)} method can also be used for
<i>143</i>&nbsp; * finding all occurrences of the specified HTML tag in the
<i>144</i>&nbsp; * document.&lt;/p&gt;
<i>145</i>&nbsp; *
<i>146</i>&nbsp; * &lt;h3&gt;Inserting elements&lt;/h3&gt;
<i>147</i>&nbsp; *
<i>148</i>&nbsp; * &lt;p&gt;Elements can be inserted before or after the existing children
<i>149</i>&nbsp; * of any non-leaf element by using the methods
<i>150</i>&nbsp; * &lt;code&gt;insertAfterStart&lt;/code&gt; and &lt;code&gt;insertBeforeEnd&lt;/code&gt;.
<i>151</i>&nbsp; * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
<i>152</i>&nbsp; * &lt;code&gt;d.insertAfterStart(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
<i>153</i>&nbsp; * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list before the first
<i>154</i>&nbsp; * paragraph, and &lt;code&gt;d.insertBeforeEnd(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
<i>155</i>&nbsp; * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list after the last
<i>156</i>&nbsp; * paragraph.  The &lt;code&gt;DIV&lt;/code&gt; block becomes the parent of the
<i>157</i>&nbsp; * newly inserted elements.&lt;/p&gt;
<i>158</i>&nbsp; *
<i>159</i>&nbsp; * &lt;p&gt;Sibling elements can be inserted before or after any element by
<i>160</i>&nbsp; * using the methods &lt;code&gt;insertBeforeStart&lt;/code&gt; and
<i>161</i>&nbsp; * &lt;code&gt;insertAfterEnd&lt;/code&gt;.  For example, if &lt;code&gt;e&lt;/code&gt; is the
<i>162</i>&nbsp; * &lt;code&gt;DIV&lt;/code&gt; element, &lt;code&gt;d.insertBeforeStart(e,
<i>163</i>&nbsp; * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
<i>164</i>&nbsp; * before the &lt;code&gt;DIV&lt;/code&gt; element, and &lt;code&gt;d.insertAfterEnd(e,
<i>165</i>&nbsp; * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; inserts the list
<i>166</i>&nbsp; * after the &lt;code&gt;DIV&lt;/code&gt; element.  The newly inserted elements
<i>167</i>&nbsp; * become siblings of the &lt;code&gt;DIV&lt;/code&gt; element.&lt;/p&gt;
<i>168</i>&nbsp; *
<i>169</i>&nbsp; * &lt;h3&gt;Replacing elements&lt;/h3&gt;
<i>170</i>&nbsp; *
<i>171</i>&nbsp; * &lt;p&gt;Elements and all their descendants can be replaced by using the
<i>172</i>&nbsp; * methods &lt;code&gt;setInnerHTML&lt;/code&gt; and &lt;code&gt;setOuterHTML&lt;/code&gt;.
<i>173</i>&nbsp; * For example, if &lt;code&gt;e&lt;/code&gt; is the &lt;code&gt;DIV&lt;/code&gt; element,
<i>174</i>&nbsp; * &lt;code&gt;d.setInnerHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
<i>175</i>&nbsp; * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces all children paragraphs with
<i>176</i>&nbsp; * the list, and &lt;code&gt;d.setOuterHTML(e, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;List
<i>177</i>&nbsp; * Item&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;)&lt;/code&gt; replaces the &lt;code&gt;DIV&lt;/code&gt; element
<i>178</i>&nbsp; * itself.  In latter case the parent of the list is the
<i>179</i>&nbsp; * &lt;code&gt;BODY&lt;/code&gt; element.
<i>180</i>&nbsp; *
<i>181</i>&nbsp; * &lt;h3&gt;Summary&lt;/h3&gt;
<i>182</i>&nbsp; *
<i>183</i>&nbsp; * &lt;p&gt;The following table shows the example document and the results
<i>184</i>&nbsp; * of various methods described above.&lt;/p&gt;
<i>185</i>&nbsp; *
<i>186</i>&nbsp; * &lt;table class=&quot;plain&quot;&gt;
<i>187</i>&nbsp; * &lt;caption&gt;HTML Content of example above&lt;/caption&gt;
<i>188</i>&nbsp; *   &lt;tr&gt;
<i>189</i>&nbsp; *     &lt;th&gt;Example&lt;/th&gt;
<i>190</i>&nbsp; *     &lt;th&gt;&lt;code&gt;insertAfterStart&lt;/code&gt;&lt;/th&gt;
<i>191</i>&nbsp; *     &lt;th&gt;&lt;code&gt;insertBeforeEnd&lt;/code&gt;&lt;/th&gt;
<i>192</i>&nbsp; *     &lt;th&gt;&lt;code&gt;insertBeforeStart&lt;/code&gt;&lt;/th&gt;
<i>193</i>&nbsp; *     &lt;th&gt;&lt;code&gt;insertAfterEnd&lt;/code&gt;&lt;/th&gt;
<i>194</i>&nbsp; *     &lt;th&gt;&lt;code&gt;setInnerHTML&lt;/code&gt;&lt;/th&gt;
<i>195</i>&nbsp; *     &lt;th&gt;&lt;code&gt;setOuterHTML&lt;/code&gt;&lt;/th&gt;
<i>196</i>&nbsp; *   &lt;/tr&gt;
<i>197</i>&nbsp; *   &lt;tr valign=&quot;top&quot;&gt;
<i>198</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>199</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>200</i>&nbsp; *         &lt;p&gt;Paragraph 1&lt;/p&gt;
<i>201</i>&nbsp; *         &lt;p&gt;Paragraph 2&lt;/p&gt;
<i>202</i>&nbsp; *       &lt;/div&gt;
<i>203</i>&nbsp; *     &lt;/td&gt;
<i>204</i>&nbsp; * &lt;!--insertAfterStart--&gt;
<i>205</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>206</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>207</i>&nbsp; *         &lt;ul style=&quot;color: blue;&quot;&gt;
<i>208</i>&nbsp; *           &lt;li&gt;List Item&lt;/li&gt;
<i>209</i>&nbsp; *         &lt;/ul&gt;
<i>210</i>&nbsp; *         &lt;p&gt;Paragraph 1&lt;/p&gt;
<i>211</i>&nbsp; *         &lt;p&gt;Paragraph 2&lt;/p&gt;
<i>212</i>&nbsp; *       &lt;/div&gt;
<i>213</i>&nbsp; *     &lt;/td&gt;
<i>214</i>&nbsp; * &lt;!--insertBeforeEnd--&gt;
<i>215</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>216</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>217</i>&nbsp; *         &lt;p&gt;Paragraph 1&lt;/p&gt;
<i>218</i>&nbsp; *         &lt;p&gt;Paragraph 2&lt;/p&gt;
<i>219</i>&nbsp; *         &lt;ul style=&quot;color: blue;&quot;&gt;
<i>220</i>&nbsp; *           &lt;li&gt;List Item&lt;/li&gt;
<i>221</i>&nbsp; *         &lt;/ul&gt;
<i>222</i>&nbsp; *       &lt;/div&gt;
<i>223</i>&nbsp; *     &lt;/td&gt;
<i>224</i>&nbsp; * &lt;!--insertBeforeStart--&gt;
<i>225</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>226</i>&nbsp; *       &lt;ul style=&quot;color: blue;&quot;&gt;
<i>227</i>&nbsp; *         &lt;li&gt;List Item&lt;/li&gt;
<i>228</i>&nbsp; *       &lt;/ul&gt;
<i>229</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>230</i>&nbsp; *         &lt;p&gt;Paragraph 1&lt;/p&gt;
<i>231</i>&nbsp; *         &lt;p&gt;Paragraph 2&lt;/p&gt;
<i>232</i>&nbsp; *       &lt;/div&gt;
<i>233</i>&nbsp; *     &lt;/td&gt;
<i>234</i>&nbsp; * &lt;!--insertAfterEnd--&gt;
<i>235</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>236</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>237</i>&nbsp; *         &lt;p&gt;Paragraph 1&lt;/p&gt;
<i>238</i>&nbsp; *         &lt;p&gt;Paragraph 2&lt;/p&gt;
<i>239</i>&nbsp; *       &lt;/div&gt;
<i>240</i>&nbsp; *       &lt;ul style=&quot;color: blue;&quot;&gt;
<i>241</i>&nbsp; *         &lt;li&gt;List Item&lt;/li&gt;
<i>242</i>&nbsp; *       &lt;/ul&gt;
<i>243</i>&nbsp; *     &lt;/td&gt;
<i>244</i>&nbsp; * &lt;!--setInnerHTML--&gt;
<i>245</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>246</i>&nbsp; *       &lt;div style=&quot;background-color: silver;&quot;&gt;
<i>247</i>&nbsp; *         &lt;ul style=&quot;color: blue;&quot;&gt;
<i>248</i>&nbsp; *           &lt;li&gt;List Item&lt;/li&gt;
<i>249</i>&nbsp; *         &lt;/ul&gt;
<i>250</i>&nbsp; *       &lt;/div&gt;
<i>251</i>&nbsp; *     &lt;/td&gt;
<i>252</i>&nbsp; * &lt;!--setOuterHTML--&gt;
<i>253</i>&nbsp; *     &lt;td style=&quot;white-space:nowrap&quot;&gt;
<i>254</i>&nbsp; *       &lt;ul style=&quot;color: blue;&quot;&gt;
<i>255</i>&nbsp; *         &lt;li&gt;List Item&lt;/li&gt;
<i>256</i>&nbsp; *       &lt;/ul&gt;
<i>257</i>&nbsp; *     &lt;/td&gt;
<i>258</i>&nbsp; *   &lt;/tr&gt;
<i>259</i>&nbsp; * &lt;/table&gt;
<i>260</i>&nbsp; *
<i>261</i>&nbsp; * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; Serialized objects of this class will
<i>262</i>&nbsp; * not be compatible with future Swing releases. The current
<i>263</i>&nbsp; * serialization support is appropriate for short term storage or RMI
<i>264</i>&nbsp; * between applications running the same version of Swing.  As of 1.4,
<i>265</i>&nbsp; * support for long term storage of all JavaBeans&amp;trade;
<i>266</i>&nbsp; * has been added to the
<i>267</i>&nbsp; * &lt;code&gt;java.beans&lt;/code&gt; package.  Please see {@link
<i>268</i>&nbsp; * java.beans.XMLEncoder}.&lt;/p&gt;
<i>269</i>&nbsp; *
<i>270</i>&nbsp; * @author  Timothy Prinzing
<i>271</i>&nbsp; * @author  Scott Violet
<i>272</i>&nbsp; * @author  Sunita Mani
<b class="nc"><i>273</i>&nbsp; */</b>
<i>274</i>&nbsp;@SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
<i>275</i>&nbsp;public class HTMLDocument extends DefaultStyledDocument {
<i>276</i>&nbsp;    /**
<i>277</i>&nbsp;     * Constructs an HTML document using the default buffer size
<i>278</i>&nbsp;     * and a default &lt;code&gt;StyleSheet&lt;/code&gt;.  This is a convenience
<i>279</i>&nbsp;     * method for the constructor
<i>280</i>&nbsp;     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
<b class="nc"><i>281</i>&nbsp;     */</b>
<i>282</i>&nbsp;    public HTMLDocument() {
<i>283</i>&nbsp;        this(new GapContent(BUFFER_SIZE_DEFAULT), new StyleSheet());
<i>284</i>&nbsp;    }
<i>285</i>&nbsp;
<i>286</i>&nbsp;    /**
<i>287</i>&nbsp;     * Constructs an HTML document with the default content
<i>288</i>&nbsp;     * storage implementation and the specified style/attribute
<i>289</i>&nbsp;     * storage mechanism.  This is a convenience method for the
<i>290</i>&nbsp;     * constructor
<i>291</i>&nbsp;     * &lt;code&gt;HTMLDocument(Content, StyleSheet)&lt;/code&gt;.
<i>292</i>&nbsp;     *
<i>293</i>&nbsp;     * @param styles  the styles
<b class="nc"><i>294</i>&nbsp;     */</b>
<i>295</i>&nbsp;    public HTMLDocument(StyleSheet styles) {
<i>296</i>&nbsp;        this(new GapContent(BUFFER_SIZE_DEFAULT), styles);
<i>297</i>&nbsp;    }
<i>298</i>&nbsp;
<i>299</i>&nbsp;    /**
<i>300</i>&nbsp;     * Constructs an HTML document with the given content
<i>301</i>&nbsp;     * storage implementation and the given style/attribute
<i>302</i>&nbsp;     * storage mechanism.
<i>303</i>&nbsp;     *
<i>304</i>&nbsp;     * @param c  the container for the content
<i>305</i>&nbsp;     * @param styles the styles
<b class="nc"><i>306</i>&nbsp;     */</b>
<i>307</i>&nbsp;    public HTMLDocument(Content c, StyleSheet styles) {
<i>308</i>&nbsp;        super(c, styles);
<i>309</i>&nbsp;    }
<i>310</i>&nbsp;
<i>311</i>&nbsp;    /**
<i>312</i>&nbsp;     * Fetches the reader for the parser to use when loading the document
<i>313</i>&nbsp;     * with HTML.  This is implemented to return an instance of
<i>314</i>&nbsp;     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
<i>315</i>&nbsp;     * Subclasses can reimplement this
<i>316</i>&nbsp;     * method to change how the document gets structured if desired.
<i>317</i>&nbsp;     * (For example, to handle custom tags, or structurally represent character
<i>318</i>&nbsp;     * style elements.)
<i>319</i>&nbsp;     *
<i>320</i>&nbsp;     * @param pos the starting position
<i>321</i>&nbsp;     * @return the reader used by the parser to load the document
<b class="nc"><i>322</i>&nbsp;     */</b>
<b class="nc"><i>323</i>&nbsp;    public HTMLEditorKit.ParserCallback getReader(int pos) {</b>
<b class="nc"><i>324</i>&nbsp;        Object desc = getProperty(Document.StreamDescriptionProperty);</b>
<i>325</i>&nbsp;        if (desc instanceof URL) {
<b class="nc"><i>326</i>&nbsp;            setBase((URL)desc);</b>
<b class="nc"><i>327</i>&nbsp;        }</b>
<i>328</i>&nbsp;        HTMLReader reader = new HTMLReader(pos);
<i>329</i>&nbsp;        return reader;
<i>330</i>&nbsp;    }
<i>331</i>&nbsp;
<i>332</i>&nbsp;    /**
<i>333</i>&nbsp;     * Returns the reader for the parser to use to load the document
<i>334</i>&nbsp;     * with HTML.  This is implemented to return an instance of
<i>335</i>&nbsp;     * &lt;code&gt;HTMLDocument.HTMLReader&lt;/code&gt;.
<i>336</i>&nbsp;     * Subclasses can reimplement this
<i>337</i>&nbsp;     * method to change how the document gets structured if desired.
<i>338</i>&nbsp;     * (For example, to handle custom tags, or structurally represent character
<i>339</i>&nbsp;     * style elements.)
<i>340</i>&nbsp;     * &lt;p&gt;This is a convenience method for
<i>341</i>&nbsp;     * &lt;code&gt;getReader(int, int, int, HTML.Tag, TRUE)&lt;/code&gt;.
<i>342</i>&nbsp;     *
<i>343</i>&nbsp;     * @param pos the starting position
<i>344</i>&nbsp;     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
<i>345</i>&nbsp;     *          to generate before inserting
<i>346</i>&nbsp;     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
<i>347</i>&nbsp;     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
<i>348</i>&nbsp;     *          that should be generated before inserting,
<i>349</i>&nbsp;     *          but after the end tags have been generated
<i>350</i>&nbsp;     * @param insertTag  the first tag to start inserting into document
<i>351</i>&nbsp;     * @return the reader used by the parser to load the document
<i>352</i>&nbsp;     */
<b class="nc"><i>353</i>&nbsp;    public HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,</b>
<i>354</i>&nbsp;                                                  int pushDepth,
<i>355</i>&nbsp;                                                  HTML.Tag insertTag) {
<i>356</i>&nbsp;        return getReader(pos, popDepth, pushDepth, insertTag, true);
<i>357</i>&nbsp;    }
<i>358</i>&nbsp;
<i>359</i>&nbsp;    /**
<i>360</i>&nbsp;     * Fetches the reader for the parser to use to load the document
<i>361</i>&nbsp;     * with HTML.  This is implemented to return an instance of
<i>362</i>&nbsp;     * HTMLDocument.HTMLReader.  Subclasses can reimplement this
<i>363</i>&nbsp;     * method to change how the document get structured if desired
<i>364</i>&nbsp;     * (e.g. to handle custom tags, structurally represent character
<i>365</i>&nbsp;     * style elements, etc.).
<i>366</i>&nbsp;     *
<i>367</i>&nbsp;     * @param popDepth   the number of &lt;code&gt;ElementSpec.EndTagTypes&lt;/code&gt;
<i>368</i>&nbsp;     *          to generate before inserting
<i>369</i>&nbsp;     * @param pushDepth  the number of &lt;code&gt;ElementSpec.StartTagTypes&lt;/code&gt;
<i>370</i>&nbsp;     *          with a direction of &lt;code&gt;ElementSpec.JoinNextDirection&lt;/code&gt;
<i>371</i>&nbsp;     *          that should be generated before inserting,
<i>372</i>&nbsp;     *          but after the end tags have been generated
<i>373</i>&nbsp;     * @param insertTag  the first tag to start inserting into document
<i>374</i>&nbsp;     * @param insertInsertTag  false if all the Elements after insertTag should
<i>375</i>&nbsp;     *        be inserted; otherwise insertTag will be inserted
<i>376</i>&nbsp;     * @return the reader used by the parser to load the document
<i>377</i>&nbsp;     */
<i>378</i>&nbsp;    HTMLEditorKit.ParserCallback getReader(int pos, int popDepth,
<b class="nc"><i>379</i>&nbsp;                                           int pushDepth,</b>
<b class="nc"><i>380</i>&nbsp;                                           HTML.Tag insertTag,</b>
<b class="nc"><i>381</i>&nbsp;                                           boolean insertInsertTag) {</b>
<i>382</i>&nbsp;        Object desc = getProperty(Document.StreamDescriptionProperty);
<b class="nc"><i>383</i>&nbsp;        if (desc instanceof URL) {</b>
<i>384</i>&nbsp;            setBase((URL)desc);
<i>385</i>&nbsp;        }
<b class="nc"><i>386</i>&nbsp;        HTMLReader reader = new HTMLReader(pos, popDepth, pushDepth,</b>
<i>387</i>&nbsp;                                           insertTag, insertInsertTag, false,
<i>388</i>&nbsp;                                           true);
<i>389</i>&nbsp;        return reader;
<i>390</i>&nbsp;    }
<i>391</i>&nbsp;
<i>392</i>&nbsp;    /**
<i>393</i>&nbsp;     * Returns the location to resolve relative URLs against.  By
<i>394</i>&nbsp;     * default this will be the document&#39;s URL if the document
<i>395</i>&nbsp;     * was loaded from a URL.  If a base tag is found and
<i>396</i>&nbsp;     * can be parsed, it will be used as the base location.
<i>397</i>&nbsp;     *
<b class="nc"><i>398</i>&nbsp;     * @return the base location</b>
<i>399</i>&nbsp;     */
<i>400</i>&nbsp;    public URL getBase() {
<i>401</i>&nbsp;        return base;
<i>402</i>&nbsp;    }
<i>403</i>&nbsp;
<i>404</i>&nbsp;    /**
<i>405</i>&nbsp;     * Sets the location to resolve relative URLs against.  By
<i>406</i>&nbsp;     * default this will be the document&#39;s URL if the document
<i>407</i>&nbsp;     * was loaded from a URL.  If a base tag is found and
<i>408</i>&nbsp;     * can be parsed, it will be used as the base location.
<i>409</i>&nbsp;     * &lt;p&gt;This also sets the base of the &lt;code&gt;StyleSheet&lt;/code&gt;
<i>410</i>&nbsp;     * to be &lt;code&gt;u&lt;/code&gt; as well as the base of the document.
<i>411</i>&nbsp;     *
<b class="nc"><i>412</i>&nbsp;     * @param u  the desired base URL</b>
<b class="nc"><i>413</i>&nbsp;     */</b>
<i>414</i>&nbsp;    public void setBase(URL u) {
<i>415</i>&nbsp;        base = u;
<i>416</i>&nbsp;        getStyleSheet().setBase(u);
<i>417</i>&nbsp;    }
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /**
<i>420</i>&nbsp;     * Inserts new elements in bulk.  This is how elements get created
<i>421</i>&nbsp;     * in the document.  The parsing determines what structure is needed
<i>422</i>&nbsp;     * and creates the specification as a set of tokens that describe the
<i>423</i>&nbsp;     * edit while leaving the document free of a write-lock.  This method
<i>424</i>&nbsp;     * can then be called in bursts by the reader to acquire a write-lock
<i>425</i>&nbsp;     * for a shorter duration (i.e. while the document is actually being
<i>426</i>&nbsp;     * altered).
<i>427</i>&nbsp;     *
<i>428</i>&nbsp;     * @param offset the starting offset
<i>429</i>&nbsp;     * @param data the element data
<i>430</i>&nbsp;     * @exception BadLocationException  if the given position does not
<b class="nc"><i>431</i>&nbsp;     *   represent a valid location in the associated document.</b>
<i>432</i>&nbsp;     */
<i>433</i>&nbsp;    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {
<i>434</i>&nbsp;        super.insert(offset, data);
<i>435</i>&nbsp;    }
<i>436</i>&nbsp;
<i>437</i>&nbsp;    /**
<i>438</i>&nbsp;     * Updates document structure as a result of text insertion.  This
<i>439</i>&nbsp;     * will happen within a write lock.  This implementation simply
<i>440</i>&nbsp;     * parses the inserted content for line breaks and builds up a set
<i>441</i>&nbsp;     * of instructions for the element buffer.
<i>442</i>&nbsp;     *
<i>443</i>&nbsp;     * @param chng a description of the document change
<b class="nc"><i>444</i>&nbsp;     * @param attr the attributes</b>
<b class="nc"><i>445</i>&nbsp;     */</b>
<i>446</i>&nbsp;    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {
<i>447</i>&nbsp;        if(attr == null) {
<i>448</i>&nbsp;            attr = contentAttributeSet;
<b class="nc"><i>449</i>&nbsp;        }</b>
<b class="nc"><i>450</i>&nbsp;</b>
<i>451</i>&nbsp;        // If this is the composed text element, merge the content attribute to it
<i>452</i>&nbsp;        else if (attr.isDefined(StyleConstants.ComposedTextAttribute)) {
<b class="nc"><i>453</i>&nbsp;            ((MutableAttributeSet)attr).addAttributes(contentAttributeSet);</b>
<b class="nc"><i>454</i>&nbsp;        }</b>
<i>455</i>&nbsp;
<i>456</i>&nbsp;        if (attr.isDefined(IMPLIED_CR)) {
<b class="nc"><i>457</i>&nbsp;            ((MutableAttributeSet)attr).removeAttribute(IMPLIED_CR);</b>
<i>458</i>&nbsp;        }
<i>459</i>&nbsp;
<i>460</i>&nbsp;        super.insertUpdate(chng, attr);
<i>461</i>&nbsp;    }
<i>462</i>&nbsp;
<i>463</i>&nbsp;    /**
<i>464</i>&nbsp;     * Replaces the contents of the document with the given
<i>465</i>&nbsp;     * element specifications.  This is called before insert if
<i>466</i>&nbsp;     * the loading is done in bursts.  This is the only method called
<i>467</i>&nbsp;     * if loading the document entirely in one burst.
<i>468</i>&nbsp;     *
<b class="nc"><i>469</i>&nbsp;     * @param data  the new contents of the document</b>
<i>470</i>&nbsp;     */
<i>471</i>&nbsp;    protected void create(ElementSpec[] data) {
<i>472</i>&nbsp;        super.create(data);
<i>473</i>&nbsp;    }
<i>474</i>&nbsp;
<i>475</i>&nbsp;    /**
<i>476</i>&nbsp;     * Sets attributes for a paragraph.
<i>477</i>&nbsp;     * &lt;p&gt;
<i>478</i>&nbsp;     * This method is thread safe, although most Swing methods
<i>479</i>&nbsp;     * are not. Please see
<i>480</i>&nbsp;     * &lt;A HREF=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;Concurrency
<i>481</i>&nbsp;     * in Swing&lt;/A&gt; for more information.
<i>482</i>&nbsp;     *
<i>483</i>&nbsp;     * @param offset the offset into the paragraph (must be at least 0)
<i>484</i>&nbsp;     * @param length the number of characters affected (must be at least 0)
<i>485</i>&nbsp;     * @param s the attributes
<i>486</i>&nbsp;     * @param replace whether to replace existing attributes, or merge them
<i>487</i>&nbsp;     */
<b class="nc"><i>488</i>&nbsp;    public void setParagraphAttributes(int offset, int length, AttributeSet s,</b>
<i>489</i>&nbsp;                                       boolean replace) {
<b class="nc"><i>490</i>&nbsp;        try {</b>
<b class="nc"><i>491</i>&nbsp;            writeLock();</b>
<b class="nc"><i>492</i>&nbsp;            // Make sure we send out a change for the length of the paragraph.</b>
<b class="nc"><i>493</i>&nbsp;            int end = Math.min(offset + length, getLength());</b>
<b class="nc"><i>494</i>&nbsp;            Element e = getParagraphElement(offset);</b>
<b class="nc"><i>495</i>&nbsp;            offset = e.getStartOffset();</b>
<i>496</i>&nbsp;            e = getParagraphElement(end);
<i>497</i>&nbsp;            length = Math.max(0, e.getEndOffset() - offset);
<b class="nc"><i>498</i>&nbsp;            DefaultDocumentEvent changes =</b>
<b class="nc"><i>499</i>&nbsp;                new DefaultDocumentEvent(offset, length,</b>
<b class="nc"><i>500</i>&nbsp;                                         DocumentEvent.EventType.CHANGE);</b>
<b class="nc"><i>501</i>&nbsp;            AttributeSet sCopy = s.copyAttributes();</b>
<b class="nc"><i>502</i>&nbsp;            int lastEnd = Integer.MAX_VALUE;</b>
<b class="nc"><i>503</i>&nbsp;            for (int pos = offset; pos &lt;= end; pos = lastEnd) {</b>
<i>504</i>&nbsp;                Element paragraph = getParagraphElement(pos);
<i>505</i>&nbsp;                if (lastEnd == paragraph.getEndOffset()) {
<b class="nc"><i>506</i>&nbsp;                    lastEnd++;</b>
<i>507</i>&nbsp;                }
<b class="nc"><i>508</i>&nbsp;                else {</b>
<b class="nc"><i>509</i>&nbsp;                    lastEnd = paragraph.getEndOffset();</b>
<b class="nc"><i>510</i>&nbsp;                }</b>
<b class="nc"><i>511</i>&nbsp;                MutableAttributeSet attr =</b>
<b class="nc"><i>512</i>&nbsp;                    (MutableAttributeSet) paragraph.getAttributes();</b>
<i>513</i>&nbsp;                changes.addEdit(new AttributeUndoableEdit(paragraph, sCopy, replace));
<b class="nc"><i>514</i>&nbsp;                if (replace) {</b>
<i>515</i>&nbsp;                    attr.removeAttributes(attr);
<b class="nc"><i>516</i>&nbsp;                }</b>
<b class="nc"><i>517</i>&nbsp;                attr.addAttributes(s);</b>
<b class="nc"><i>518</i>&nbsp;            }</b>
<i>519</i>&nbsp;            changes.end();
<b class="nc"><i>520</i>&nbsp;            fireChangedUpdate(changes);</b>
<b class="nc"><i>521</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</b>
<i>522</i>&nbsp;        } finally {
<i>523</i>&nbsp;            writeUnlock();
<i>524</i>&nbsp;        }
<i>525</i>&nbsp;    }
<i>526</i>&nbsp;
<i>527</i>&nbsp;    /**
<i>528</i>&nbsp;     * Fetches the &lt;code&gt;StyleSheet&lt;/code&gt; with the document-specific display
<i>529</i>&nbsp;     * rules (CSS) that were specified in the HTML document itself.
<i>530</i>&nbsp;     *
<b class="nc"><i>531</i>&nbsp;     * @return the &lt;code&gt;StyleSheet&lt;/code&gt;</b>
<i>532</i>&nbsp;     */
<i>533</i>&nbsp;    public StyleSheet getStyleSheet() {
<i>534</i>&nbsp;        return (StyleSheet) getAttributeContext();
<i>535</i>&nbsp;    }
<i>536</i>&nbsp;
<i>537</i>&nbsp;    /**
<i>538</i>&nbsp;     * Fetches an iterator for the specified HTML tag.
<i>539</i>&nbsp;     * This can be used for things like iterating over the
<i>540</i>&nbsp;     * set of anchors contained, or iterating over the input
<i>541</i>&nbsp;     * elements.
<i>542</i>&nbsp;     *
<i>543</i>&nbsp;     * @param t the requested &lt;code&gt;HTML.Tag&lt;/code&gt;
<i>544</i>&nbsp;     * @return the &lt;code&gt;Iterator&lt;/code&gt; for the given HTML tag
<b class="nc"><i>545</i>&nbsp;     * @see javax.swing.text.html.HTML.Tag</b>
<i>546</i>&nbsp;     */
<b class="nc"><i>547</i>&nbsp;    public Iterator getIterator(HTML.Tag t) {</b>
<i>548</i>&nbsp;        if (t.isBlock()) {
<b class="nc"><i>549</i>&nbsp;            // TBD</b>
<i>550</i>&nbsp;            return null;
<i>551</i>&nbsp;        }
<i>552</i>&nbsp;        return new LeafIterator(t, this);
<i>553</i>&nbsp;    }
<i>554</i>&nbsp;
<i>555</i>&nbsp;    /**
<i>556</i>&nbsp;     * Creates a document leaf element that directly represents
<i>557</i>&nbsp;     * text (doesn&#39;t have any children).  This is implemented
<i>558</i>&nbsp;     * to return an element of type
<i>559</i>&nbsp;     * &lt;code&gt;HTMLDocument.RunElement&lt;/code&gt;.
<i>560</i>&nbsp;     *
<i>561</i>&nbsp;     * @param parent the parent element
<i>562</i>&nbsp;     * @param a the attributes for the element
<i>563</i>&nbsp;     * @param p0 the beginning of the range (must be at least 0)
<i>564</i>&nbsp;     * @param p1 the end of the range (must be at least p0)
<b class="nc"><i>565</i>&nbsp;     * @return the new element</b>
<i>566</i>&nbsp;     */
<i>567</i>&nbsp;    protected Element createLeafElement(Element parent, AttributeSet a, int p0, int p1) {
<i>568</i>&nbsp;        return new RunElement(parent, a, p0, p1);
<i>569</i>&nbsp;    }
<i>570</i>&nbsp;
<i>571</i>&nbsp;    /**
<i>572</i>&nbsp;     * Creates a document branch element, that can contain other elements.
<i>573</i>&nbsp;     * This is implemented to return an element of type
<i>574</i>&nbsp;     * &lt;code&gt;HTMLDocument.BlockElement&lt;/code&gt;.
<i>575</i>&nbsp;     *
<i>576</i>&nbsp;     * @param parent the parent element
<i>577</i>&nbsp;     * @param a the attributes
<b class="nc"><i>578</i>&nbsp;     * @return the element</b>
<i>579</i>&nbsp;     */
<i>580</i>&nbsp;    protected Element createBranchElement(Element parent, AttributeSet a) {
<i>581</i>&nbsp;        return new BlockElement(parent, a);
<i>582</i>&nbsp;    }
<i>583</i>&nbsp;
<i>584</i>&nbsp;    /**
<i>585</i>&nbsp;     * Creates the root element to be used to represent the
<i>586</i>&nbsp;     * default document structure.
<i>587</i>&nbsp;     *
<i>588</i>&nbsp;     * @return the element base
<i>589</i>&nbsp;     */
<i>590</i>&nbsp;    protected AbstractElement createDefaultRoot() {
<i>591</i>&nbsp;        // grabs a write-lock for this initialization and
<b class="nc"><i>592</i>&nbsp;        // abandon it during initialization so in normal</b>
<b class="nc"><i>593</i>&nbsp;        // operation we can detect an illegitimate attempt</b>
<b class="nc"><i>594</i>&nbsp;        // to mutate attributes.</b>
<b class="nc"><i>595</i>&nbsp;        writeLock();</b>
<b class="nc"><i>596</i>&nbsp;        MutableAttributeSet a = new SimpleAttributeSet();</b>
<b class="nc"><i>597</i>&nbsp;        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.HTML);</b>
<b class="nc"><i>598</i>&nbsp;        BlockElement html = new BlockElement(null, a.copyAttributes());</b>
<b class="nc"><i>599</i>&nbsp;        a.removeAttributes(a);</b>
<b class="nc"><i>600</i>&nbsp;        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.BODY);</b>
<b class="nc"><i>601</i>&nbsp;        BlockElement body = new BlockElement(html, a.copyAttributes());</b>
<b class="nc"><i>602</i>&nbsp;        a.removeAttributes(a);</b>
<b class="nc"><i>603</i>&nbsp;        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.P);</b>
<b class="nc"><i>604</i>&nbsp;        getStyleSheet().addCSSAttributeFromHTML(a, CSS.Attribute.MARGIN_TOP, &quot;0&quot;);</b>
<b class="nc"><i>605</i>&nbsp;        BlockElement paragraph = new BlockElement(body, a.copyAttributes());</b>
<b class="nc"><i>606</i>&nbsp;        a.removeAttributes(a);</b>
<b class="nc"><i>607</i>&nbsp;        a.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);</b>
<b class="nc"><i>608</i>&nbsp;        RunElement brk = new RunElement(paragraph, a, 0, 1);</b>
<b class="nc"><i>609</i>&nbsp;        Element[] buff = new Element[1];</b>
<b class="nc"><i>610</i>&nbsp;        buff[0] = brk;</b>
<b class="nc"><i>611</i>&nbsp;        paragraph.replace(0, 0, buff);</b>
<b class="nc"><i>612</i>&nbsp;        buff[0] = paragraph;</b>
<b class="nc"><i>613</i>&nbsp;        body.replace(0, 0, buff);</b>
<b class="nc"><i>614</i>&nbsp;        buff[0] = body;</b>
<i>615</i>&nbsp;        html.replace(0, 0, buff);
<i>616</i>&nbsp;        writeUnlock();
<i>617</i>&nbsp;        return html;
<i>618</i>&nbsp;    }
<i>619</i>&nbsp;
<i>620</i>&nbsp;    /**
<i>621</i>&nbsp;     * Sets the number of tokens to buffer before trying to update
<i>622</i>&nbsp;     * the documents element structure.
<i>623</i>&nbsp;     *
<b class="nc"><i>624</i>&nbsp;     * @param n  the number of tokens to buffer</b>
<i>625</i>&nbsp;     */
<i>626</i>&nbsp;    public void setTokenThreshold(int n) {
<i>627</i>&nbsp;        putProperty(TokenThreshold, n);
<i>628</i>&nbsp;    }
<i>629</i>&nbsp;
<i>630</i>&nbsp;    /**
<i>631</i>&nbsp;     * Gets the number of tokens to buffer before trying to update
<i>632</i>&nbsp;     * the documents element structure.  The default value is
<i>633</i>&nbsp;     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
<i>634</i>&nbsp;     *
<b class="nc"><i>635</i>&nbsp;     * @return the number of tokens to buffer</b>
<b class="nc"><i>636</i>&nbsp;     */</b>
<b class="nc"><i>637</i>&nbsp;    public int getTokenThreshold() {</b>
<i>638</i>&nbsp;        Integer i = (Integer) getProperty(TokenThreshold);
<b class="nc"><i>639</i>&nbsp;        if (i != null) {</b>
<i>640</i>&nbsp;            return i.intValue();
<i>641</i>&nbsp;        }
<i>642</i>&nbsp;        return Integer.MAX_VALUE;
<i>643</i>&nbsp;    }
<i>644</i>&nbsp;
<i>645</i>&nbsp;    /**
<i>646</i>&nbsp;     * Determines how unknown tags are handled by the parser.
<i>647</i>&nbsp;     * If set to true, unknown
<i>648</i>&nbsp;     * tags are put in the model, otherwise they are dropped.
<i>649</i>&nbsp;     *
<i>650</i>&nbsp;     * @param preservesTags  true if unknown tags should be
<i>651</i>&nbsp;     *          saved in the model, otherwise tags are dropped
<b class="nc"><i>652</i>&nbsp;     * @see javax.swing.text.html.HTML.Tag</b>
<i>653</i>&nbsp;     */
<i>654</i>&nbsp;    public void setPreservesUnknownTags(boolean preservesTags) {
<i>655</i>&nbsp;        preservesUnknownTags = preservesTags;
<i>656</i>&nbsp;    }
<i>657</i>&nbsp;
<i>658</i>&nbsp;    /**
<i>659</i>&nbsp;     * Returns the behavior the parser observes when encountering
<i>660</i>&nbsp;     * unknown tags.
<i>661</i>&nbsp;     *
<i>662</i>&nbsp;     * @see javax.swing.text.html.HTML.Tag
<b class="nc"><i>663</i>&nbsp;     * @return true if unknown tags are to be preserved when parsing</b>
<i>664</i>&nbsp;     */
<i>665</i>&nbsp;    public boolean getPreservesUnknownTags() {
<i>666</i>&nbsp;        return preservesUnknownTags;
<i>667</i>&nbsp;    }
<i>668</i>&nbsp;
<i>669</i>&nbsp;    /**
<i>670</i>&nbsp;     * Processes &lt;code&gt;HyperlinkEvents&lt;/code&gt; that
<i>671</i>&nbsp;     * are generated by documents in an HTML frame.
<i>672</i>&nbsp;     * The &lt;code&gt;HyperlinkEvent&lt;/code&gt; type, as the parameter suggests,
<i>673</i>&nbsp;     * is &lt;code&gt;HTMLFrameHyperlinkEvent&lt;/code&gt;.
<i>674</i>&nbsp;     * In addition to the typical information contained in a
<i>675</i>&nbsp;     * &lt;code&gt;HyperlinkEvent&lt;/code&gt;,
<i>676</i>&nbsp;     * this event contains the element that corresponds to the frame in
<i>677</i>&nbsp;     * which the click happened (the source element) and the
<i>678</i>&nbsp;     * target name.  The target name has 4 possible values:
<i>679</i>&nbsp;     * &lt;ul&gt;
<i>680</i>&nbsp;     * &lt;li&gt;  _self
<i>681</i>&nbsp;     * &lt;li&gt;  _parent
<i>682</i>&nbsp;     * &lt;li&gt;  _top
<i>683</i>&nbsp;     * &lt;li&gt;  a named frame
<i>684</i>&nbsp;     * &lt;/ul&gt;
<i>685</i>&nbsp;     *
<i>686</i>&nbsp;     * If target is _self, the action is to change the value of the
<i>687</i>&nbsp;     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute and fires a
<i>688</i>&nbsp;     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
<i>689</i>&nbsp;     *&lt;p&gt;
<i>690</i>&nbsp;     * If the target is _parent, then it deletes the parent element,
<i>691</i>&nbsp;     * which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt;
<i>692</i>&nbsp;     * element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute
<i>693</i>&nbsp;     * to have a value equal to the destination URL and fire a
<i>694</i>&nbsp;     * &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.
<i>695</i>&nbsp;     *&lt;p&gt;
<i>696</i>&nbsp;     * If the target is _top, this method does nothing. In the implementation
<i>697</i>&nbsp;     * of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;,
<i>698</i>&nbsp;     * the processing of _top is handled.  Given that _top implies
<i>699</i>&nbsp;     * replacing the entire document, it made sense to handle this outside
<i>700</i>&nbsp;     * of the document that it will replace.
<i>701</i>&nbsp;     *&lt;p&gt;
<i>702</i>&nbsp;     * If the target is a named frame, then the element hierarchy is searched
<i>703</i>&nbsp;     * for an element with a name equal to the target, its
<i>704</i>&nbsp;     * &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a
<i>705</i>&nbsp;     * &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.
<i>706</i>&nbsp;     *
<b class="nc"><i>707</i>&nbsp;     * @param e the event</b>
<b class="nc"><i>708</i>&nbsp;     */</b>
<b class="nc"><i>709</i>&nbsp;    public void processHTMLFrameHyperlinkEvent(HTMLFrameHyperlinkEvent e) {</b>
<i>710</i>&nbsp;        String frameName = e.getTarget();
<b class="nc"><i>711</i>&nbsp;        Element element = e.getSourceElement();</b>
<i>712</i>&nbsp;        String urlStr = e.getURL().toString();
<i>713</i>&nbsp;
<i>714</i>&nbsp;        if (frameName.equals(&quot;_self&quot;)) {
<i>715</i>&nbsp;            /*
<b class="nc"><i>716</i>&nbsp;              The source and destination elements</b>
<b class="nc"><i>717</i>&nbsp;              are the same.</b>
<i>718</i>&nbsp;            */
<i>719</i>&nbsp;            updateFrame(element, urlStr);
<i>720</i>&nbsp;        } else if (frameName.equals(&quot;_parent&quot;)) {
<b class="nc"><i>721</i>&nbsp;            /*</b>
<i>722</i>&nbsp;              The destination is the parent of the frame.
<i>723</i>&nbsp;            */
<i>724</i>&nbsp;            updateFrameSet(element.getParentElement(), urlStr);
<i>725</i>&nbsp;        } else {
<b class="nc"><i>726</i>&nbsp;            /*</b>
<b class="nc"><i>727</i>&nbsp;              locate a named frame</b>
<b class="nc"><i>728</i>&nbsp;            */</b>
<i>729</i>&nbsp;            Element targetElement = findFrame(frameName);
<i>730</i>&nbsp;            if (targetElement != null) {
<i>731</i>&nbsp;                updateFrame(targetElement, urlStr);
<i>732</i>&nbsp;            }
<i>733</i>&nbsp;        }
<i>734</i>&nbsp;    }
<i>735</i>&nbsp;
<i>736</i>&nbsp;
<i>737</i>&nbsp;    /**
<i>738</i>&nbsp;     * Searches the element hierarchy for an FRAME element
<i>739</i>&nbsp;     * that has its name attribute equal to the &lt;code&gt;frameName&lt;/code&gt;.
<i>740</i>&nbsp;     *
<i>741</i>&nbsp;     * @param frameName
<i>742</i>&nbsp;     * @return the element whose NAME attribute has a value of
<i>743</i>&nbsp;     *          &lt;code&gt;frameName&lt;/code&gt;; returns &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>744</i>&nbsp;     *          if not found</b>
<i>745</i>&nbsp;     */
<i>746</i>&nbsp;    private Element findFrame(String frameName) {
<b class="nc"><i>747</i>&nbsp;        ElementIterator it = new ElementIterator(this);</b>
<b class="nc"><i>748</i>&nbsp;        Element next;</b>
<b class="nc"><i>749</i>&nbsp;</b>
<b class="nc"><i>750</i>&nbsp;        while ((next = it.next()) != null) {</b>
<b class="nc"><i>751</i>&nbsp;            AttributeSet attr = next.getAttributes();</b>
<b class="nc"><i>752</i>&nbsp;            if (matchNameAttribute(attr, HTML.Tag.FRAME)) {</b>
<i>753</i>&nbsp;                String frameTarget = (String)attr.getAttribute(HTML.Attribute.NAME);
<i>754</i>&nbsp;                if (frameTarget != null &amp;&amp; frameTarget.equals(frameName)) {
<b class="nc"><i>755</i>&nbsp;                    break;</b>
<b class="nc"><i>756</i>&nbsp;                }</b>
<i>757</i>&nbsp;            }
<i>758</i>&nbsp;        }
<i>759</i>&nbsp;        return next;
<i>760</i>&nbsp;    }
<i>761</i>&nbsp;
<i>762</i>&nbsp;    /**
<i>763</i>&nbsp;     * Returns true if &lt;code&gt;StyleConstants.NameAttribute&lt;/code&gt; is
<i>764</i>&nbsp;     * equal to the tag that is passed in as a parameter.
<i>765</i>&nbsp;     *
<i>766</i>&nbsp;     * @param attr the attributes to be matched
<i>767</i>&nbsp;     * @param tag the value to be matched
<i>768</i>&nbsp;     * @return true if there is a match, false otherwise
<b class="nc"><i>769</i>&nbsp;     * @see javax.swing.text.html.HTML.Attribute</b>
<b class="nc"><i>770</i>&nbsp;     */</b>
<b class="nc"><i>771</i>&nbsp;    static boolean matchNameAttribute(AttributeSet attr, HTML.Tag tag) {</b>
<b class="nc"><i>772</i>&nbsp;        Object o = attr.getAttribute(StyleConstants.NameAttribute);</b>
<b class="nc"><i>773</i>&nbsp;        if (o instanceof HTML.Tag) {</b>
<i>774</i>&nbsp;            HTML.Tag name = (HTML.Tag) o;
<i>775</i>&nbsp;            if (name == tag) {
<b class="nc"><i>776</i>&nbsp;                return true;</b>
<i>777</i>&nbsp;            }
<i>778</i>&nbsp;        }
<i>779</i>&nbsp;        return false;
<i>780</i>&nbsp;    }
<i>781</i>&nbsp;
<i>782</i>&nbsp;    /**
<i>783</i>&nbsp;     * Replaces a frameset branch Element with a frame leaf element.
<i>784</i>&nbsp;     *
<i>785</i>&nbsp;     * @param element the frameset element to remove
<i>786</i>&nbsp;     * @param url     the value for the SRC attribute for the
<i>787</i>&nbsp;     *                new frame that will replace the frameset
<b class="nc"><i>788</i>&nbsp;     */</b>
<b class="nc"><i>789</i>&nbsp;    private void updateFrameSet(Element element, String url) {</b>
<b class="nc"><i>790</i>&nbsp;        try {</b>
<b class="nc"><i>791</i>&nbsp;            int startOffset = element.getStartOffset();</b>
<b class="nc"><i>792</i>&nbsp;            int endOffset = Math.min(getLength(), element.getEndOffset());</b>
<i>793</i>&nbsp;            String html = &quot;&lt;frame&quot;;
<b class="nc"><i>794</i>&nbsp;            if (url != null) {</b>
<b class="nc"><i>795</i>&nbsp;                html += &quot; src=\&quot;&quot; + url + &quot;\&quot;&quot;;</b>
<b class="nc"><i>796</i>&nbsp;            }</b>
<b class="nc"><i>797</i>&nbsp;            html += &quot;&gt;&quot;;</b>
<i>798</i>&nbsp;            installParserIfNecessary();
<b class="nc"><i>799</i>&nbsp;            setOuterHTML(element, html);</b>
<i>800</i>&nbsp;        } catch (BadLocationException e1) {
<b class="nc"><i>801</i>&nbsp;            // Should handle this better</b>
<i>802</i>&nbsp;        } catch (IOException ioe) {
<i>803</i>&nbsp;            // Should handle this better
<i>804</i>&nbsp;        }
<i>805</i>&nbsp;    }
<i>806</i>&nbsp;
<i>807</i>&nbsp;
<i>808</i>&nbsp;    /**
<i>809</i>&nbsp;     * Updates the Frame elements &lt;code&gt;HTML.Attribute.SRC attribute&lt;/code&gt;
<i>810</i>&nbsp;     * and fires a &lt;code&gt;ChangedUpdate&lt;/code&gt; event.
<i>811</i>&nbsp;     *
<i>812</i>&nbsp;     * @param element a FRAME element whose SRC attribute will be updated
<i>813</i>&nbsp;     * @param url     a string specifying the new value for the SRC attribute
<i>814</i>&nbsp;     */
<b class="nc"><i>815</i>&nbsp;    private void updateFrame(Element element, String url) {</b>
<b class="nc"><i>816</i>&nbsp;</b>
<i>817</i>&nbsp;        try {
<i>818</i>&nbsp;            writeLock();
<b class="nc"><i>819</i>&nbsp;            DefaultDocumentEvent changes = new DefaultDocumentEvent(element.getStartOffset(),</b>
<b class="nc"><i>820</i>&nbsp;                                                                    1,</b>
<b class="nc"><i>821</i>&nbsp;                                                                    DocumentEvent.EventType.CHANGE);</b>
<b class="nc"><i>822</i>&nbsp;            AttributeSet sCopy = element.getAttributes().copyAttributes();</b>
<b class="nc"><i>823</i>&nbsp;            MutableAttributeSet attr = (MutableAttributeSet) element.getAttributes();</b>
<b class="nc"><i>824</i>&nbsp;            changes.addEdit(new AttributeUndoableEdit(element, sCopy, false));</b>
<b class="nc"><i>825</i>&nbsp;            attr.removeAttribute(HTML.Attribute.SRC);</b>
<b class="nc"><i>826</i>&nbsp;            attr.addAttribute(HTML.Attribute.SRC, url);</b>
<i>827</i>&nbsp;            changes.end();
<b class="nc"><i>828</i>&nbsp;            fireChangedUpdate(changes);</b>
<b class="nc"><i>829</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, changes));</b>
<i>830</i>&nbsp;        } finally {
<i>831</i>&nbsp;            writeUnlock();
<i>832</i>&nbsp;        }
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;
<i>836</i>&nbsp;    /**
<i>837</i>&nbsp;     * Returns true if the document will be viewed in a frame.
<b class="nc"><i>838</i>&nbsp;     * @return true if document will be viewed in a frame, otherwise false</b>
<i>839</i>&nbsp;     */
<i>840</i>&nbsp;    boolean isFrameDocument() {
<i>841</i>&nbsp;        return frameDocument;
<i>842</i>&nbsp;    }
<i>843</i>&nbsp;
<i>844</i>&nbsp;    /**
<i>845</i>&nbsp;     * Sets a boolean state about whether the document will be
<i>846</i>&nbsp;     * viewed in a frame.
<i>847</i>&nbsp;     * @param frameDoc  true if the document will be viewed in a frame,
<b class="nc"><i>848</i>&nbsp;     *          otherwise false</b>
<i>849</i>&nbsp;     */
<i>850</i>&nbsp;    void setFrameDocumentState(boolean frameDoc) {
<i>851</i>&nbsp;        this.frameDocument = frameDoc;
<i>852</i>&nbsp;    }
<i>853</i>&nbsp;
<i>854</i>&nbsp;    /**
<i>855</i>&nbsp;     * Adds the specified map, this will remove a Map that has been
<i>856</i>&nbsp;     * previously registered with the same name.
<i>857</i>&nbsp;     *
<b class="nc"><i>858</i>&nbsp;     * @param map  the &lt;code&gt;Map&lt;/code&gt; to be registered</b>
<i>859</i>&nbsp;     */
<b class="nc"><i>860</i>&nbsp;    void addMap(Map map) {</b>
<b class="nc"><i>861</i>&nbsp;        String     name = map.getName();</b>
<i>862</i>&nbsp;
<b class="nc"><i>863</i>&nbsp;        if (name != null) {</b>
<b class="nc"><i>864</i>&nbsp;            Object     maps = getProperty(MAP_PROPERTY);</b>
<b class="nc"><i>865</i>&nbsp;</b>
<i>866</i>&nbsp;            if (maps == null) {
<b class="nc"><i>867</i>&nbsp;                maps = new Hashtable&lt;&gt;(11);</b>
<b class="nc"><i>868</i>&nbsp;                putProperty(MAP_PROPERTY, maps);</b>
<i>869</i>&nbsp;            }
<i>870</i>&nbsp;            if (maps instanceof Hashtable) {
<i>871</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>872</i>&nbsp;                Hashtable&lt;Object, Object&gt; tmp = (Hashtable)maps;
<i>873</i>&nbsp;                tmp.put(&quot;#&quot; + name, map);
<i>874</i>&nbsp;            }
<i>875</i>&nbsp;        }
<i>876</i>&nbsp;    }
<i>877</i>&nbsp;
<b class="nc"><i>878</i>&nbsp;    /**</b>
<i>879</i>&nbsp;     * Removes a previously registered map.
<b class="nc"><i>880</i>&nbsp;     * @param map the &lt;code&gt;Map&lt;/code&gt; to be removed</b>
<b class="nc"><i>881</i>&nbsp;     */</b>
<i>882</i>&nbsp;    void removeMap(Map map) {
<b class="nc"><i>883</i>&nbsp;        String     name = map.getName();</b>
<b class="nc"><i>884</i>&nbsp;</b>
<i>885</i>&nbsp;        if (name != null) {
<i>886</i>&nbsp;            Object     maps = getProperty(MAP_PROPERTY);
<i>887</i>&nbsp;
<i>888</i>&nbsp;            if (maps instanceof Hashtable) {
<i>889</i>&nbsp;                ((Hashtable)maps).remove(&quot;#&quot; + name);
<i>890</i>&nbsp;            }
<i>891</i>&nbsp;        }
<i>892</i>&nbsp;    }
<i>893</i>&nbsp;
<i>894</i>&nbsp;    /**
<i>895</i>&nbsp;     * Returns the Map associated with the given name.
<b class="nc"><i>896</i>&nbsp;     * @param name the name of the desired &lt;code&gt;Map&lt;/code&gt;</b>
<b class="nc"><i>897</i>&nbsp;     * @return the &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if it can&#39;t</b>
<i>898</i>&nbsp;     *          be found, or if &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>899</i>&nbsp;     */</b>
<b class="nc"><i>900</i>&nbsp;    Map getMap(String name) {</b>
<i>901</i>&nbsp;        if (name != null) {
<i>902</i>&nbsp;            Object     maps = getProperty(MAP_PROPERTY);
<b class="nc"><i>903</i>&nbsp;</b>
<i>904</i>&nbsp;            if (maps != null &amp;&amp; (maps instanceof Hashtable)) {
<i>905</i>&nbsp;                return (Map)((Hashtable)maps).get(name);
<i>906</i>&nbsp;            }
<i>907</i>&nbsp;        }
<i>908</i>&nbsp;        return null;
<i>909</i>&nbsp;    }
<i>910</i>&nbsp;
<i>911</i>&nbsp;    /**
<b class="nc"><i>912</i>&nbsp;     * Returns an &lt;code&gt;Enumeration&lt;/code&gt; of the possible Maps.</b>
<i>913</i>&nbsp;     * @return the enumerated list of maps, or &lt;code&gt;null&lt;/code&gt;
<b class="nc"><i>914</i>&nbsp;     *          if the maps are not an instance of &lt;code&gt;Hashtable&lt;/code&gt;</b>
<b class="nc"><i>915</i>&nbsp;     */</b>
<i>916</i>&nbsp;    Enumeration&lt;Object&gt; getMaps() {
<b class="nc"><i>917</i>&nbsp;        Object     maps = getProperty(MAP_PROPERTY);</b>
<i>918</i>&nbsp;
<i>919</i>&nbsp;        if (maps instanceof Hashtable) {
<i>920</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<i>921</i>&nbsp;            Hashtable&lt;Object, Object&gt; tmp = (Hashtable) maps;
<i>922</i>&nbsp;            return tmp.elements();
<i>923</i>&nbsp;        }
<i>924</i>&nbsp;        return null;
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<b class="nc"><i>927</i>&nbsp;    /**</b>
<i>928</i>&nbsp;     * Sets the content type language used for style sheets that do not
<i>929</i>&nbsp;     * explicitly specify the type. The default is text/css.
<i>930</i>&nbsp;     * @param contentType  the content type language for the style sheets
<i>931</i>&nbsp;     */
<i>932</i>&nbsp;    /* public */
<i>933</i>&nbsp;    void setDefaultStyleSheetType(String contentType) {
<i>934</i>&nbsp;        putProperty(StyleType, contentType);
<i>935</i>&nbsp;    }
<i>936</i>&nbsp;
<b class="nc"><i>937</i>&nbsp;    /**</b>
<b class="nc"><i>938</i>&nbsp;     * Returns the content type language used for style sheets. The default</b>
<b class="nc"><i>939</i>&nbsp;     * is text/css.</b>
<i>940</i>&nbsp;     * @return the content type language used for the style sheets
<b class="nc"><i>941</i>&nbsp;     */</b>
<i>942</i>&nbsp;    /* public */
<i>943</i>&nbsp;    String getDefaultStyleSheetType() {
<i>944</i>&nbsp;        String retValue = (String)getProperty(StyleType);
<i>945</i>&nbsp;        if (retValue == null) {
<i>946</i>&nbsp;            return &quot;text/css&quot;;
<i>947</i>&nbsp;        }
<i>948</i>&nbsp;        return retValue;
<i>949</i>&nbsp;    }
<i>950</i>&nbsp;
<i>951</i>&nbsp;    /**
<i>952</i>&nbsp;     * Sets the parser that is used by the methods that insert html
<i>953</i>&nbsp;     * into the existing document, such as &lt;code&gt;setInnerHTML&lt;/code&gt;,
<i>954</i>&nbsp;     * and &lt;code&gt;setOuterHTML&lt;/code&gt;.
<i>955</i>&nbsp;     * &lt;p&gt;
<i>956</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.createDefaultDocument&lt;/code&gt; will set the parser
<b class="nc"><i>957</i>&nbsp;     * for you. If you create an &lt;code&gt;HTMLDocument&lt;/code&gt; by hand,</b>
<b class="nc"><i>958</i>&nbsp;     * be sure and set the parser accordingly.</b>
<i>959</i>&nbsp;     * @param parser the parser to be used for text insertion
<i>960</i>&nbsp;     *
<i>961</i>&nbsp;     * @since 1.3
<i>962</i>&nbsp;     */
<i>963</i>&nbsp;    public void setParser(HTMLEditorKit.Parser parser) {
<i>964</i>&nbsp;        this.parser = parser;
<i>965</i>&nbsp;        putProperty(&quot;__PARSER__&quot;, null);
<i>966</i>&nbsp;    }
<i>967</i>&nbsp;
<i>968</i>&nbsp;    /**
<b class="nc"><i>969</i>&nbsp;     * Returns the parser that is used when inserting HTML into the existing</b>
<i>970</i>&nbsp;     * document.
<b class="nc"><i>971</i>&nbsp;     * @return the parser used for text insertion</b>
<b class="nc"><i>972</i>&nbsp;     *</b>
<i>973</i>&nbsp;     * @since 1.3
<b class="nc"><i>974</i>&nbsp;     */</b>
<i>975</i>&nbsp;    public HTMLEditorKit.Parser getParser() {
<i>976</i>&nbsp;        Object p = getProperty(&quot;__PARSER__&quot;);
<i>977</i>&nbsp;
<i>978</i>&nbsp;        if (p instanceof HTMLEditorKit.Parser) {
<i>979</i>&nbsp;            return (HTMLEditorKit.Parser)p;
<i>980</i>&nbsp;        }
<i>981</i>&nbsp;        return parser;
<i>982</i>&nbsp;    }
<i>983</i>&nbsp;
<i>984</i>&nbsp;    /**
<i>985</i>&nbsp;     * Replaces the children of the given element with the contents
<i>986</i>&nbsp;     * specified as an HTML string.
<i>987</i>&nbsp;     *
<i>988</i>&nbsp;     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
<i>989</i>&nbsp;     * a remove.&lt;/p&gt;
<i>990</i>&nbsp;     *
<i>991</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>992</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>993</i>&nbsp;     *
<i>994</i>&nbsp;     * &lt;pre&gt;
<i>995</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>996</i>&nbsp;     *       |
<i>997</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>998</i>&nbsp;     *      /  \
<i>999</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1000</i>&nbsp;     * &lt;/pre&gt;
<i>1001</i>&nbsp;     *
<i>1002</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;setInnerHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
<i>1003</i>&nbsp;     * results in the following structure (new elements are &lt;span
<i>1004</i>&nbsp;     * style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1005</i>&nbsp;     *
<i>1006</i>&nbsp;     * &lt;pre&gt;
<i>1007</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1008</i>&nbsp;     *       |
<i>1009</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1010</i>&nbsp;     *         \
<i>1011</i>&nbsp;     *         &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
<i>1012</i>&nbsp;     *           \
<i>1013</i>&nbsp;     *           &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
<i>1014</i>&nbsp;     * &lt;/pre&gt;
<i>1015</i>&nbsp;     *
<i>1016</i>&nbsp;     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
<i>1017</i>&nbsp;     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
<i>1018</i>&nbsp;     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
<i>1019</i>&nbsp;     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
<i>1020</i>&nbsp;     *
<i>1021</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an
<i>1022</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
<i>1023</i>&nbsp;     * if the document was created from an HTMLEditorKit via the
<i>1024</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
<i>1025</i>&nbsp;     *
<i>1026</i>&nbsp;     * @param elem the branch element whose children will be replaced
<i>1027</i>&nbsp;     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
<b class="nc"><i>1028</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf</b>
<b class="nc"><i>1029</i>&nbsp;     * @throws IllegalStateException if an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt;</b>
<b class="nc"><i>1030</i>&nbsp;     *         has not been defined</b>
<i>1031</i>&nbsp;     * @throws BadLocationException if replacement is impossible because of
<i>1032</i>&nbsp;     *         a structural issue
<b class="nc"><i>1033</i>&nbsp;     * @throws IOException if an I/O exception occurs</b>
<b class="nc"><i>1034</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>1035</i>&nbsp;     */</b>
<b class="nc"><i>1036</i>&nbsp;    public void setInnerHTML(Element elem, String htmlText) throws</b>
<b class="nc"><i>1037</i>&nbsp;                             BadLocationException, IOException {</b>
<i>1038</i>&nbsp;        verifyParser();
<b class="nc"><i>1039</i>&nbsp;        if (elem != null &amp;&amp; elem.isLeaf()) {</b>
<i>1040</i>&nbsp;            throw new IllegalArgumentException
<i>1041</i>&nbsp;                (&quot;Can not set inner HTML of a leaf&quot;);
<i>1042</i>&nbsp;        }
<i>1043</i>&nbsp;        if (elem != null &amp;&amp; htmlText != null) {
<i>1044</i>&nbsp;            int oldCount = elem.getElementCount();
<i>1045</i>&nbsp;            int insertPosition = elem.getStartOffset();
<i>1046</i>&nbsp;            insertHTML(elem, elem.getStartOffset(), htmlText, true);
<i>1047</i>&nbsp;            if (elem.getElementCount() &gt; oldCount) {
<i>1048</i>&nbsp;                // Elements were inserted, do the cleanup.
<i>1049</i>&nbsp;                removeElements(elem, elem.getElementCount() - oldCount,
<i>1050</i>&nbsp;                               oldCount);
<i>1051</i>&nbsp;            }
<i>1052</i>&nbsp;        }
<i>1053</i>&nbsp;    }
<i>1054</i>&nbsp;
<i>1055</i>&nbsp;    /**
<i>1056</i>&nbsp;     * Replaces the given element in the parent with the contents
<i>1057</i>&nbsp;     * specified as an HTML string.
<i>1058</i>&nbsp;     *
<i>1059</i>&nbsp;     * &lt;p&gt;This will be seen as at least two events, n inserts followed by
<i>1060</i>&nbsp;     * a remove.&lt;/p&gt;
<i>1061</i>&nbsp;     *
<i>1062</i>&nbsp;     * &lt;p&gt;When replacing a leaf this will attempt to make sure there is
<i>1063</i>&nbsp;     * a newline present if one is needed. This may result in an additional
<i>1064</i>&nbsp;     * element being inserted. Consider, if you were to replace a character
<i>1065</i>&nbsp;     * element that contained a newline with &amp;lt;img&amp;gt; this would create
<i>1066</i>&nbsp;     * two elements, one for the image, and one for the newline.&lt;/p&gt;
<i>1067</i>&nbsp;     *
<i>1068</i>&nbsp;     * &lt;p&gt;If you try to replace the element at length you will most
<i>1069</i>&nbsp;     * likely end up with two elements, eg
<i>1070</i>&nbsp;     * &lt;code&gt;setOuterHTML(getCharacterElement (getLength()),
<i>1071</i>&nbsp;     * &quot;blah&quot;)&lt;/code&gt; will result in two leaf elements at the end, one
<i>1072</i>&nbsp;     * representing &#39;blah&#39;, and the other representing the end
<i>1073</i>&nbsp;     * element.&lt;/p&gt;
<i>1074</i>&nbsp;     *
<i>1075</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>1076</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>1077</i>&nbsp;     *
<i>1078</i>&nbsp;     * &lt;pre&gt;
<i>1079</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1080</i>&nbsp;     *       |
<i>1081</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1082</i>&nbsp;     *      /  \
<i>1083</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1084</i>&nbsp;     * &lt;/pre&gt;
<i>1085</i>&nbsp;     *
<i>1086</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;setOuterHTML(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
<i>1087</i>&nbsp;     * results in the following structure (new elements are &lt;span
<i>1088</i>&nbsp;     * style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1089</i>&nbsp;     *
<i>1090</i>&nbsp;     * &lt;pre&gt;
<i>1091</i>&nbsp;     *    &amp;lt;body&amp;gt;
<i>1092</i>&nbsp;     *      |
<i>1093</i>&nbsp;     *     &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
<i>1094</i>&nbsp;     *       \
<i>1095</i>&nbsp;     *       &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
<i>1096</i>&nbsp;     * &lt;/pre&gt;
<i>1097</i>&nbsp;     *
<i>1098</i>&nbsp;     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
<i>1099</i>&nbsp;     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
<i>1100</i>&nbsp;     * document.&lt;/p&gt;
<i>1101</i>&nbsp;     *
<i>1102</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an
<i>1103</i>&nbsp;     * HTMLEditorKit.Parser set. This will be the case if the document
<i>1104</i>&nbsp;     * was created from an HTMLEditorKit via the
<b class="nc"><i>1105</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;</b>
<b class="nc"><i>1106</i>&nbsp;     *</b>
<i>1107</i>&nbsp;     * @param elem the element to replace
<b class="nc"><i>1108</i>&nbsp;     * @param htmlText the string to be parsed and inserted in place of &lt;code&gt;elem&lt;/code&gt;</b>
<b class="nc"><i>1109</i>&nbsp;     * @throws IllegalStateException if an HTMLEditorKit.Parser has not</b>
<b class="nc"><i>1110</i>&nbsp;     *         been set</b>
<i>1111</i>&nbsp;     * @throws BadLocationException if replacement is impossible because of
<i>1112</i>&nbsp;     *         a structural issue
<b class="nc"><i>1113</i>&nbsp;     * @throws IOException if an I/O exception occurs</b>
<b class="nc"><i>1114</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>1115</i>&nbsp;     */</b>
<b class="nc"><i>1116</i>&nbsp;    public void setOuterHTML(Element elem, String htmlText) throws</b>
<i>1117</i>&nbsp;                            BadLocationException, IOException {
<b class="nc"><i>1118</i>&nbsp;        verifyParser();</b>
<b class="nc"><i>1119</i>&nbsp;        if (elem != null &amp;&amp; elem.getParentElement() != null &amp;&amp;</b>
<b class="nc"><i>1120</i>&nbsp;            htmlText != null) {</b>
<i>1121</i>&nbsp;            int start = elem.getStartOffset();
<b class="nc"><i>1122</i>&nbsp;            int end = elem.getEndOffset();</b>
<b class="nc"><i>1123</i>&nbsp;            int startLength = getLength();</b>
<b class="nc"><i>1124</i>&nbsp;            // We don&#39;t want a newline if elem is a leaf, and doesn&#39;t contain</b>
<i>1125</i>&nbsp;            // a newline.
<b class="nc"><i>1126</i>&nbsp;            boolean wantsNewline = !elem.isLeaf();</b>
<i>1127</i>&nbsp;            if (!wantsNewline &amp;&amp; (end &gt; startLength ||
<i>1128</i>&nbsp;                                 getText(end - 1, 1).charAt(0) == NEWLINE[0])){
<i>1129</i>&nbsp;                wantsNewline = true;
<i>1130</i>&nbsp;            }
<i>1131</i>&nbsp;            Element parent = elem.getParentElement();
<i>1132</i>&nbsp;            int oldCount = parent.getElementCount();
<i>1133</i>&nbsp;            insertHTML(parent, start, htmlText, wantsNewline);
<i>1134</i>&nbsp;            // Remove old.
<i>1135</i>&nbsp;            int newLength = getLength();
<i>1136</i>&nbsp;            if (oldCount != parent.getElementCount()) {
<i>1137</i>&nbsp;                int removeIndex = parent.getElementIndex(start + newLength -
<i>1138</i>&nbsp;                                                         startLength);
<i>1139</i>&nbsp;                removeElements(parent, removeIndex, 1);
<i>1140</i>&nbsp;            }
<i>1141</i>&nbsp;        }
<i>1142</i>&nbsp;    }
<i>1143</i>&nbsp;
<i>1144</i>&nbsp;    /**
<i>1145</i>&nbsp;     * Inserts the HTML specified as a string at the start
<i>1146</i>&nbsp;     * of the element.
<i>1147</i>&nbsp;     *
<i>1148</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>1149</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>1150</i>&nbsp;     *
<i>1151</i>&nbsp;     * &lt;pre&gt;
<i>1152</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1153</i>&nbsp;     *       |
<i>1154</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1155</i>&nbsp;     *      /  \
<i>1156</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1157</i>&nbsp;     * &lt;/pre&gt;
<i>1158</i>&nbsp;     *
<i>1159</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;insertAfterStart(elem,
<i>1160</i>&nbsp;     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
<i>1161</i>&nbsp;     * (new elements are &lt;span style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1162</i>&nbsp;     *
<i>1163</i>&nbsp;     * &lt;pre&gt;
<i>1164</i>&nbsp;     *        &amp;lt;body&amp;gt;
<i>1165</i>&nbsp;     *          |
<i>1166</i>&nbsp;     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1167</i>&nbsp;     *       /  |  \
<i>1168</i>&nbsp;     *    &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt; &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;
<i>1169</i>&nbsp;     *     /
<i>1170</i>&nbsp;     *  &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
<i>1171</i>&nbsp;     * &lt;/pre&gt;
<i>1172</i>&nbsp;     *
<i>1173</i>&nbsp;     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeStart&lt;/code&gt; method, new
<i>1174</i>&nbsp;     *  elements become &lt;em&gt;children&lt;/em&gt; of the specified element,
<i>1175</i>&nbsp;     *  not siblings.&lt;/p&gt;
<i>1176</i>&nbsp;     *
<i>1177</i>&nbsp;     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
<i>1178</i>&nbsp;     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
<i>1179</i>&nbsp;     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
<i>1180</i>&nbsp;     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;
<i>1181</i>&nbsp;     *
<i>1182</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an
<b class="nc"><i>1183</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case</b>
<i>1184</i>&nbsp;     * if the document was created from an HTMLEditorKit via the
<b class="nc"><i>1185</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;</b>
<i>1186</i>&nbsp;     *
<i>1187</i>&nbsp;     * @param elem the branch element to be the root for the new text
<i>1188</i>&nbsp;     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;
<b class="nc"><i>1189</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf</b>
<b class="nc"><i>1190</i>&nbsp;     * @throws IllegalStateException if an HTMLEditorKit.Parser has not</b>
<i>1191</i>&nbsp;     *         been set on the document
<i>1192</i>&nbsp;     * @throws BadLocationException if insertion is impossible because of
<b class="nc"><i>1193</i>&nbsp;     *         a structural issue</b>
<i>1194</i>&nbsp;     * @throws IOException if an I/O exception occurs
<i>1195</i>&nbsp;     * @since 1.3
<i>1196</i>&nbsp;     */
<i>1197</i>&nbsp;    public void insertAfterStart(Element elem, String htmlText) throws
<i>1198</i>&nbsp;                                 BadLocationException, IOException {
<i>1199</i>&nbsp;        verifyParser();
<i>1200</i>&nbsp;
<i>1201</i>&nbsp;        if (elem == null || htmlText == null) {
<i>1202</i>&nbsp;            return;
<i>1203</i>&nbsp;        }
<i>1204</i>&nbsp;
<i>1205</i>&nbsp;        if (elem.isLeaf()) {
<i>1206</i>&nbsp;            throw new IllegalArgumentException
<i>1207</i>&nbsp;                (&quot;Can not insert HTML after start of a leaf&quot;);
<i>1208</i>&nbsp;        }
<i>1209</i>&nbsp;        insertHTML(elem, elem.getStartOffset(), htmlText, false);
<i>1210</i>&nbsp;    }
<i>1211</i>&nbsp;
<i>1212</i>&nbsp;    /**
<i>1213</i>&nbsp;     * Inserts the HTML specified as a string at the end of
<i>1214</i>&nbsp;     * the element.
<i>1215</i>&nbsp;     *
<i>1216</i>&nbsp;     * &lt;p&gt; If &lt;code&gt;elem&lt;/code&gt;&#39;s children are leaves, and the
<i>1217</i>&nbsp;     * character at a &lt;code&gt;elem.getEndOffset() - 1&lt;/code&gt; is a newline,
<i>1218</i>&nbsp;     * this will insert before the newline so that there isn&#39;t text after
<i>1219</i>&nbsp;     * the newline.&lt;/p&gt;
<i>1220</i>&nbsp;     *
<i>1221</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>1222</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>1223</i>&nbsp;     *
<i>1224</i>&nbsp;     * &lt;pre&gt;
<i>1225</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1226</i>&nbsp;     *       |
<i>1227</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1228</i>&nbsp;     *      /  \
<i>1229</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1230</i>&nbsp;     * &lt;/pre&gt;
<i>1231</i>&nbsp;     *
<i>1232</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
<i>1233</i>&nbsp;     * results in the following structure (new elements are &lt;span
<i>1234</i>&nbsp;     * style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1235</i>&nbsp;     *
<i>1236</i>&nbsp;     * &lt;pre&gt;
<i>1237</i>&nbsp;     *        &amp;lt;body&amp;gt;
<i>1238</i>&nbsp;     *          |
<i>1239</i>&nbsp;     *        &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1240</i>&nbsp;     *       /  |  \
<i>1241</i>&nbsp;     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt; &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
<i>1242</i>&nbsp;     *               \
<i>1243</i>&nbsp;     *               &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
<i>1244</i>&nbsp;     * &lt;/pre&gt;
<i>1245</i>&nbsp;     *
<i>1246</i>&nbsp;     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterEnd&lt;/code&gt; method, new elements
<i>1247</i>&nbsp;     * become &lt;em&gt;children&lt;/em&gt; of the specified element, not
<i>1248</i>&nbsp;     * siblings.&lt;/p&gt;
<i>1249</i>&nbsp;     *
<i>1250</i>&nbsp;     * &lt;p&gt;Parameter &lt;code&gt;elem&lt;/code&gt; must not be a leaf element,
<i>1251</i>&nbsp;     * otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
<i>1252</i>&nbsp;     * If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt; parameter
<b class="nc"><i>1253</i>&nbsp;     * is &lt;code&gt;null&lt;/code&gt;, no changes are made to the document.&lt;/p&gt;</b>
<b class="nc"><i>1254</i>&nbsp;     *</b>
<b class="nc"><i>1255</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an</b>
<i>1256</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
<i>1257</i>&nbsp;     * if the document was created from an HTMLEditorKit via the
<b class="nc"><i>1258</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;</b>
<b class="nc"><i>1259</i>&nbsp;     *</b>
<b class="nc"><i>1260</i>&nbsp;     * @param elem the element to be the root for the new text</b>
<b class="nc"><i>1261</i>&nbsp;     * @param htmlText the string to be parsed and assigned to &lt;code&gt;elem&lt;/code&gt;</b>
<b class="nc"><i>1262</i>&nbsp;     * @throws IllegalArgumentException if &lt;code&gt;elem&lt;/code&gt; is a leaf</b>
<i>1263</i>&nbsp;     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
<b class="nc"><i>1264</i>&nbsp;     *         been set on the document</b>
<i>1265</i>&nbsp;     * @throws BadLocationException if insertion is impossible because of
<i>1266</i>&nbsp;     *         a structural issue
<i>1267</i>&nbsp;     * @throws IOException if an I/O exception occurs
<i>1268</i>&nbsp;     * @since 1.3
<i>1269</i>&nbsp;     */
<i>1270</i>&nbsp;    public void insertBeforeEnd(Element elem, String htmlText) throws
<i>1271</i>&nbsp;                                BadLocationException, IOException {
<i>1272</i>&nbsp;        verifyParser();
<i>1273</i>&nbsp;        if (elem != null &amp;&amp; elem.isLeaf()) {
<i>1274</i>&nbsp;            throw new IllegalArgumentException
<i>1275</i>&nbsp;                (&quot;Can not set inner HTML before end of leaf&quot;);
<i>1276</i>&nbsp;        }
<i>1277</i>&nbsp;        if (elem != null) {
<i>1278</i>&nbsp;            int offset = elem.getEndOffset();
<i>1279</i>&nbsp;            if (elem.getElement(elem.getElementIndex(offset - 1)).isLeaf() &amp;&amp;
<i>1280</i>&nbsp;                getText(offset - 1, 1).charAt(0) == NEWLINE[0]) {
<i>1281</i>&nbsp;                offset--;
<i>1282</i>&nbsp;            }
<i>1283</i>&nbsp;            insertHTML(elem, offset, htmlText, false);
<i>1284</i>&nbsp;        }
<i>1285</i>&nbsp;    }
<i>1286</i>&nbsp;
<i>1287</i>&nbsp;    /**
<i>1288</i>&nbsp;     * Inserts the HTML specified as a string before the start of
<i>1289</i>&nbsp;     * the given element.
<i>1290</i>&nbsp;     *
<i>1291</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>1292</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>1293</i>&nbsp;     *
<i>1294</i>&nbsp;     * &lt;pre&gt;
<i>1295</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1296</i>&nbsp;     *       |
<i>1297</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1298</i>&nbsp;     *      /  \
<i>1299</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1300</i>&nbsp;     * &lt;/pre&gt;
<i>1301</i>&nbsp;     *
<i>1302</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;insertBeforeStart(elem,
<i>1303</i>&nbsp;     * &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt; results in the following structure
<i>1304</i>&nbsp;     * (new elements are &lt;span style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1305</i>&nbsp;     *
<i>1306</i>&nbsp;     * &lt;pre&gt;
<i>1307</i>&nbsp;     *        &amp;lt;body&amp;gt;
<i>1308</i>&nbsp;     *         /  \
<i>1309</i>&nbsp;     *      &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt; &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1310</i>&nbsp;     *       /    /  \
<i>1311</i>&nbsp;     *     &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt; &amp;lt;p&amp;gt;  &amp;lt;p&amp;gt;
<i>1312</i>&nbsp;     * &lt;/pre&gt;
<i>1313</i>&nbsp;     *
<i>1314</i>&nbsp;     * &lt;p&gt;Unlike the &lt;code&gt;insertAfterStart&lt;/code&gt; method, new
<i>1315</i>&nbsp;     * elements become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not
<b class="nc"><i>1316</i>&nbsp;     * children.&lt;/p&gt;</b>
<b class="nc"><i>1317</i>&nbsp;     *</b>
<b class="nc"><i>1318</i>&nbsp;     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;</b>
<i>1319</i>&nbsp;     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
<b class="nc"><i>1320</i>&nbsp;     * document.&lt;/p&gt;</b>
<b class="nc"><i>1321</i>&nbsp;     *</b>
<i>1322</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an
<i>1323</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case
<i>1324</i>&nbsp;     * if the document was created from an HTMLEditorKit via the
<i>1325</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;
<i>1326</i>&nbsp;     *
<i>1327</i>&nbsp;     * @param elem the element the content is inserted before
<i>1328</i>&nbsp;     * @param htmlText the string to be parsed and inserted before &lt;code&gt;elem&lt;/code&gt;
<i>1329</i>&nbsp;     * @throws IllegalStateException if an HTMLEditorKit.Parser has not
<i>1330</i>&nbsp;     *         been set on the document
<i>1331</i>&nbsp;     * @throws BadLocationException if insertion is impossible because of
<i>1332</i>&nbsp;     *         a structural issue
<i>1333</i>&nbsp;     * @throws IOException if an I/O exception occurs
<i>1334</i>&nbsp;     * @since 1.3
<i>1335</i>&nbsp;     */
<i>1336</i>&nbsp;    public void insertBeforeStart(Element elem, String htmlText) throws
<i>1337</i>&nbsp;                                  BadLocationException, IOException {
<i>1338</i>&nbsp;        verifyParser();
<i>1339</i>&nbsp;        if (elem != null) {
<i>1340</i>&nbsp;            Element parent = elem.getParentElement();
<i>1341</i>&nbsp;
<i>1342</i>&nbsp;            if (parent != null) {
<i>1343</i>&nbsp;                insertHTML(parent, elem.getStartOffset(), htmlText, false);
<i>1344</i>&nbsp;            }
<i>1345</i>&nbsp;        }
<i>1346</i>&nbsp;    }
<i>1347</i>&nbsp;
<i>1348</i>&nbsp;    /**
<i>1349</i>&nbsp;     * Inserts the HTML specified as a string after the end of the
<i>1350</i>&nbsp;     * given element.
<i>1351</i>&nbsp;     *
<i>1352</i>&nbsp;     * &lt;p&gt;Consider the following structure (the &lt;code&gt;elem&lt;/code&gt;
<i>1353</i>&nbsp;     * parameter is &lt;b&gt;in bold&lt;/b&gt;).&lt;/p&gt;
<i>1354</i>&nbsp;     *
<i>1355</i>&nbsp;     * &lt;pre&gt;
<i>1356</i>&nbsp;     *     &amp;lt;body&amp;gt;
<i>1357</i>&nbsp;     *       |
<i>1358</i>&nbsp;     *     &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt;
<i>1359</i>&nbsp;     *      /  \
<i>1360</i>&nbsp;     *    &amp;lt;p&amp;gt;   &amp;lt;p&amp;gt;
<i>1361</i>&nbsp;     * &lt;/pre&gt;
<i>1362</i>&nbsp;     *
<i>1363</i>&nbsp;     * &lt;p&gt;Invoking &lt;code&gt;insertAfterEnd(elem, &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot;)&lt;/code&gt;
<i>1364</i>&nbsp;     * results in the following structure (new elements are &lt;span
<i>1365</i>&nbsp;     * style=&quot;color: blue;&quot;&gt;in blue&lt;/span&gt;).&lt;/p&gt;
<i>1366</i>&nbsp;     *
<i>1367</i>&nbsp;     * &lt;pre&gt;
<i>1368</i>&nbsp;     *        &amp;lt;body&amp;gt;
<i>1369</i>&nbsp;     *         /  \
<i>1370</i>&nbsp;     *      &lt;b&gt;&amp;lt;div&amp;gt;&lt;/b&gt; &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
<i>1371</i>&nbsp;     *       / \    \
<i>1372</i>&nbsp;     *     &amp;lt;p&amp;gt; &amp;lt;p&amp;gt;  &lt;span style=&quot;color: blue;&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;
<i>1373</i>&nbsp;     * &lt;/pre&gt;
<b class="nc"><i>1374</i>&nbsp;     *</b>
<b class="nc"><i>1375</i>&nbsp;     * &lt;p&gt;Unlike the &lt;code&gt;insertBeforeEnd&lt;/code&gt; method, new elements</b>
<b class="nc"><i>1376</i>&nbsp;     * become &lt;em&gt;siblings&lt;/em&gt; of the specified element, not</b>
<i>1377</i>&nbsp;     * children.&lt;/p&gt;
<b class="nc"><i>1378</i>&nbsp;     *</b>
<i>1379</i>&nbsp;     * &lt;p&gt;If either &lt;code&gt;elem&lt;/code&gt; or &lt;code&gt;htmlText&lt;/code&gt;
<i>1380</i>&nbsp;     * parameter is &lt;code&gt;null&lt;/code&gt;, no changes are made to the
<b class="nc"><i>1381</i>&nbsp;     * document.&lt;/p&gt;</b>
<b class="nc"><i>1382</i>&nbsp;     *</b>
<i>1383</i>&nbsp;     * &lt;p&gt;For this to work correctly, the document must have an
<b class="nc"><i>1384</i>&nbsp;     * &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set. This will be the case</b>
<b class="nc"><i>1385</i>&nbsp;     * if the document was created from an HTMLEditorKit via the</b>
<b class="nc"><i>1386</i>&nbsp;     * &lt;code&gt;createDefaultDocument&lt;/code&gt; method.&lt;/p&gt;</b>
<i>1387</i>&nbsp;     *
<b class="nc"><i>1388</i>&nbsp;     * @param elem the element the content is inserted after</b>
<b class="nc"><i>1389</i>&nbsp;     * @param htmlText the string to be parsed and inserted after &lt;code&gt;elem&lt;/code&gt;</b>
<b class="nc"><i>1390</i>&nbsp;     * @throws IllegalStateException if an HTMLEditorKit.Parser has not</b>
<i>1391</i>&nbsp;     *         been set on the document
<b class="nc"><i>1392</i>&nbsp;     * @throws BadLocationException if insertion is impossible because of</b>
<i>1393</i>&nbsp;     *         a structural issue
<b class="nc"><i>1394</i>&nbsp;     * @throws IOException if an I/O exception occurs</b>
<b class="nc"><i>1395</i>&nbsp;     * @since 1.3</b>
<i>1396</i>&nbsp;     */
<i>1397</i>&nbsp;    public void insertAfterEnd(Element elem, String htmlText) throws
<i>1398</i>&nbsp;                               BadLocationException, IOException {
<i>1399</i>&nbsp;        verifyParser();
<i>1400</i>&nbsp;        if (elem != null) {
<i>1401</i>&nbsp;            Element parent = elem.getParentElement();
<i>1402</i>&nbsp;
<i>1403</i>&nbsp;            if (parent != null) {
<i>1404</i>&nbsp;                // If we are going to insert the string into the body
<i>1405</i>&nbsp;                // section, it is necessary to set the corrsponding flag.
<i>1406</i>&nbsp;                if (HTML.Tag.BODY.name.equals(parent.getName())) {
<i>1407</i>&nbsp;                    insertInBody = true;
<i>1408</i>&nbsp;                }
<i>1409</i>&nbsp;                int offset = elem.getEndOffset();
<i>1410</i>&nbsp;                if (offset &gt; (getLength() + 1)) {
<i>1411</i>&nbsp;                    offset--;
<i>1412</i>&nbsp;                }
<i>1413</i>&nbsp;                else if (elem.isLeaf() &amp;&amp; getText(offset - 1, 1).
<i>1414</i>&nbsp;                    charAt(0) == NEWLINE[0]) {
<i>1415</i>&nbsp;                    offset--;
<i>1416</i>&nbsp;                }
<i>1417</i>&nbsp;                insertHTML(parent, offset, htmlText, false);
<i>1418</i>&nbsp;                // Cleanup the flag, if any.
<i>1419</i>&nbsp;                if (insertInBody) {
<b class="nc"><i>1420</i>&nbsp;                    insertInBody = false;</b>
<b class="nc"><i>1421</i>&nbsp;                }</b>
<i>1422</i>&nbsp;            }
<b class="nc"><i>1423</i>&nbsp;        }</b>
<i>1424</i>&nbsp;    }
<i>1425</i>&nbsp;
<i>1426</i>&nbsp;    /**
<i>1427</i>&nbsp;     * Returns the element that has the given id &lt;code&gt;Attribute&lt;/code&gt;.
<i>1428</i>&nbsp;     * If the element can&#39;t be found, &lt;code&gt;null&lt;/code&gt; is returned.
<i>1429</i>&nbsp;     * Note that this method works on an &lt;code&gt;Attribute&lt;/code&gt;,
<i>1430</i>&nbsp;     * &lt;i&gt;not&lt;/i&gt; a character tag.  In the following HTML snippet:
<i>1431</i>&nbsp;     * &lt;code&gt;&amp;lt;a id=&quot;HelloThere&quot;&amp;gt;&lt;/code&gt; the attribute is
<i>1432</i>&nbsp;     * &#39;id&#39; and the character tag is &#39;a&#39;.
<i>1433</i>&nbsp;     * This is a convenience method for
<i>1434</i>&nbsp;     * &lt;code&gt;getElement(RootElement, HTML.Attribute.id, id)&lt;/code&gt;.
<i>1435</i>&nbsp;     * This is not thread-safe.
<i>1436</i>&nbsp;     *
<i>1437</i>&nbsp;     * @param id  the string representing the desired &lt;code&gt;Attribute&lt;/code&gt;
<i>1438</i>&nbsp;     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
<i>1439</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if it can&#39;t be found,
<i>1440</i>&nbsp;     *          or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;id&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
<i>1441</i>&nbsp;     * @see javax.swing.text.html.HTML.Attribute
<b class="nc"><i>1442</i>&nbsp;     * @since 1.3</b>
<i>1443</i>&nbsp;     */
<i>1444</i>&nbsp;    public Element getElement(String id) {
<i>1445</i>&nbsp;        if (id == null) {
<i>1446</i>&nbsp;            return null;
<i>1447</i>&nbsp;        }
<i>1448</i>&nbsp;        return getElement(getDefaultRootElement(), HTML.Attribute.ID, id,
<i>1449</i>&nbsp;                          true);
<i>1450</i>&nbsp;    }
<i>1451</i>&nbsp;
<i>1452</i>&nbsp;    /**
<i>1453</i>&nbsp;     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the
<i>1454</i>&nbsp;     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or
<i>1455</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; if one isn&#39;t found. This is not thread-safe.
<i>1456</i>&nbsp;     *
<i>1457</i>&nbsp;     * @param e the root element where the search begins
<i>1458</i>&nbsp;     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
<i>1459</i>&nbsp;     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
<i>1460</i>&nbsp;     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;
<i>1461</i>&nbsp;     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
<i>1462</i>&nbsp;     *          if it can&#39;t be found
<i>1463</i>&nbsp;     * @see javax.swing.text.html.HTML.Attribute
<b class="nc"><i>1464</i>&nbsp;     * @since 1.3</b>
<i>1465</i>&nbsp;     */
<b class="nc"><i>1466</i>&nbsp;    public Element getElement(Element e, Object attribute, Object value) {</b>
<b class="nc"><i>1467</i>&nbsp;        return getElement(e, attribute, value, true);</b>
<b class="nc"><i>1468</i>&nbsp;    }</b>
<i>1469</i>&nbsp;
<i>1470</i>&nbsp;    /**
<b class="nc"><i>1471</i>&nbsp;     * Returns the child element of &lt;code&gt;e&lt;/code&gt; that contains the</b>
<b class="nc"><i>1472</i>&nbsp;     * attribute, &lt;code&gt;attribute&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, or</b>
<b class="nc"><i>1473</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; if one isn&#39;t found. This is not thread-safe.</b>
<b class="nc"><i>1474</i>&nbsp;     * &lt;p&gt;</b>
<i>1475</i>&nbsp;     * If &lt;code&gt;searchLeafAttributes&lt;/code&gt; is true, and &lt;code&gt;e&lt;/code&gt; is
<i>1476</i>&nbsp;     * a leaf, any attributes that are instances of &lt;code&gt;HTML.Tag&lt;/code&gt;
<b class="nc"><i>1477</i>&nbsp;     * with a value that is an &lt;code&gt;AttributeSet&lt;/code&gt; will also be checked.</b>
<b class="nc"><i>1478</i>&nbsp;     *</b>
<i>1479</i>&nbsp;     * @param e the root element where the search begins
<i>1480</i>&nbsp;     * @param attribute the desired &lt;code&gt;Attribute&lt;/code&gt;
<i>1481</i>&nbsp;     * @param value the values for the specified &lt;code&gt;Attribute&lt;/code&gt;
<b class="nc"><i>1482</i>&nbsp;     * @return the element with the specified &lt;code&gt;Attribute&lt;/code&gt;</b>
<i>1483</i>&nbsp;     *          and the specified &lt;code&gt;value&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
<i>1484</i>&nbsp;     *          if it can&#39;t be found
<b class="nc"><i>1485</i>&nbsp;     * @see javax.swing.text.html.HTML.Attribute</b>
<b class="nc"><i>1486</i>&nbsp;     */</b>
<b class="nc"><i>1487</i>&nbsp;    private Element getElement(Element e, Object attribute, Object value,</b>
<b class="nc"><i>1488</i>&nbsp;                               boolean searchLeafAttributes) {</b>
<b class="nc"><i>1489</i>&nbsp;        AttributeSet attr = e.getAttributes();</b>
<b class="nc"><i>1490</i>&nbsp;</b>
<i>1491</i>&nbsp;        if (attr != null &amp;&amp; attr.isDefined(attribute)) {
<b class="nc"><i>1492</i>&nbsp;            if (value.equals(attr.getAttribute(attribute))) {</b>
<b class="nc"><i>1493</i>&nbsp;                return e;</b>
<b class="nc"><i>1494</i>&nbsp;            }</b>
<b class="nc"><i>1495</i>&nbsp;        }</b>
<b class="nc"><i>1496</i>&nbsp;        if (!e.isLeaf()) {</b>
<i>1497</i>&nbsp;            for (int counter = 0, maxCounter = e.getElementCount();
<i>1498</i>&nbsp;                 counter &lt; maxCounter; counter++) {
<b class="nc"><i>1499</i>&nbsp;                Element retValue = getElement(e.getElement(counter), attribute,</b>
<i>1500</i>&nbsp;                                              value, searchLeafAttributes);
<i>1501</i>&nbsp;
<b class="nc"><i>1502</i>&nbsp;                if (retValue != null) {</b>
<i>1503</i>&nbsp;                    return retValue;
<i>1504</i>&nbsp;                }
<i>1505</i>&nbsp;            }
<i>1506</i>&nbsp;        }
<i>1507</i>&nbsp;        else if (searchLeafAttributes &amp;&amp; attr != null) {
<i>1508</i>&nbsp;            // For some leaf elements we store the actual attributes inside
<i>1509</i>&nbsp;            // the AttributeSet of the Element (such as anchors).
<i>1510</i>&nbsp;            Enumeration&lt;?&gt; names = attr.getAttributeNames();
<i>1511</i>&nbsp;            if (names != null) {
<i>1512</i>&nbsp;                while (names.hasMoreElements()) {
<b class="nc"><i>1513</i>&nbsp;                    Object name = names.nextElement();</b>
<b class="nc"><i>1514</i>&nbsp;                    if ((name instanceof HTML.Tag) &amp;&amp;</b>
<i>1515</i>&nbsp;                        (attr.getAttribute(name) instanceof AttributeSet)) {
<i>1516</i>&nbsp;
<i>1517</i>&nbsp;                        AttributeSet check = (AttributeSet)attr.
<i>1518</i>&nbsp;                                             getAttribute(name);
<i>1519</i>&nbsp;                        if (check.isDefined(attribute) &amp;&amp;
<i>1520</i>&nbsp;                            value.equals(check.getAttribute(attribute))) {
<i>1521</i>&nbsp;                            return e;
<b class="nc"><i>1522</i>&nbsp;                        }</b>
<b class="nc"><i>1523</i>&nbsp;                    }</b>
<i>1524</i>&nbsp;                }
<i>1525</i>&nbsp;            }
<i>1526</i>&nbsp;        }
<i>1527</i>&nbsp;        return null;
<i>1528</i>&nbsp;    }
<i>1529</i>&nbsp;
<i>1530</i>&nbsp;    /**
<i>1531</i>&nbsp;     * Verifies the document has an &lt;code&gt;HTMLEditorKit.Parser&lt;/code&gt; set.
<i>1532</i>&nbsp;     * If &lt;code&gt;getParser&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, this will throw an
<i>1533</i>&nbsp;     * IllegalStateException.
<i>1534</i>&nbsp;     *
<i>1535</i>&nbsp;     * @throws IllegalStateException if the document does not have a Parser
<b class="nc"><i>1536</i>&nbsp;     */</b>
<b class="nc"><i>1537</i>&nbsp;    private void verifyParser() {</b>
<b class="nc"><i>1538</i>&nbsp;        if (getParser() == null) {</b>
<b class="nc"><i>1539</i>&nbsp;            throw new IllegalStateException(&quot;No HTMLEditorKit.Parser&quot;);</b>
<b class="nc"><i>1540</i>&nbsp;        }</b>
<b class="nc"><i>1541</i>&nbsp;    }</b>
<b class="nc"><i>1542</i>&nbsp;</b>
<b class="nc"><i>1543</i>&nbsp;    /**</b>
<i>1544</i>&nbsp;     * Installs a default Parser if one has not been installed yet.
<b class="nc"><i>1545</i>&nbsp;     */</b>
<b class="nc"><i>1546</i>&nbsp;    private void installParserIfNecessary() {</b>
<b class="nc"><i>1547</i>&nbsp;        if (getParser() == null) {</b>
<b class="nc"><i>1548</i>&nbsp;            setParser(new HTMLEditorKit().getParser());</b>
<b class="nc"><i>1549</i>&nbsp;        }</b>
<i>1550</i>&nbsp;    }
<b class="nc"><i>1551</i>&nbsp;</b>
<b class="nc"><i>1552</i>&nbsp;    /**</b>
<i>1553</i>&nbsp;     * Inserts a string of HTML into the document at the given position.
<i>1554</i>&nbsp;     * &lt;code&gt;parent&lt;/code&gt; is used to identify the location to insert the
<i>1555</i>&nbsp;     * &lt;code&gt;html&lt;/code&gt;. If &lt;code&gt;parent&lt;/code&gt; is a leaf this can have
<b class="nc"><i>1556</i>&nbsp;     * unexpected results.</b>
<b class="nc"><i>1557</i>&nbsp;     */</b>
<b class="nc"><i>1558</i>&nbsp;    private void insertHTML(Element parent, int offset, String html,</b>
<i>1559</i>&nbsp;                            boolean wantsTrailingNewline)
<b class="nc"><i>1560</i>&nbsp;                 throws BadLocationException, IOException {</b>
<i>1561</i>&nbsp;        if (parent != null &amp;&amp; html != null) {
<b class="nc"><i>1562</i>&nbsp;            HTMLEditorKit.Parser parser = getParser();</b>
<i>1563</i>&nbsp;            if (parser != null) {
<i>1564</i>&nbsp;                int lastOffset = Math.max(0, offset - 1);
<i>1565</i>&nbsp;                Element charElement = getCharacterElement(lastOffset);
<b class="nc"><i>1566</i>&nbsp;                Element commonParent = parent;</b>
<b class="nc"><i>1567</i>&nbsp;                int pop = 0;</b>
<i>1568</i>&nbsp;                int push = 0;
<i>1569</i>&nbsp;
<i>1570</i>&nbsp;                if (parent.getStartOffset() &gt; lastOffset) {
<i>1571</i>&nbsp;                    while (commonParent != null &amp;&amp;
<i>1572</i>&nbsp;                           commonParent.getStartOffset() &gt; lastOffset) {
<i>1573</i>&nbsp;                        commonParent = commonParent.getParentElement();
<i>1574</i>&nbsp;                        push++;
<i>1575</i>&nbsp;                    }
<i>1576</i>&nbsp;                    if (commonParent == null) {
<i>1577</i>&nbsp;                        throw new BadLocationException(&quot;No common parent&quot;,
<i>1578</i>&nbsp;                                                       offset);
<i>1579</i>&nbsp;                    }
<i>1580</i>&nbsp;                }
<i>1581</i>&nbsp;                while (charElement != null &amp;&amp; charElement != commonParent) {
<i>1582</i>&nbsp;                    pop++;
<b class="nc"><i>1583</i>&nbsp;                    charElement = charElement.getParentElement();</b>
<i>1584</i>&nbsp;                }
<b class="nc"><i>1585</i>&nbsp;                if (charElement != null) {</b>
<b class="nc"><i>1586</i>&nbsp;                    // Found it, do the insert.</b>
<b class="nc"><i>1587</i>&nbsp;                    HTMLReader reader = new HTMLReader(offset, pop - 1, push,</b>
<b class="nc"><i>1588</i>&nbsp;                                                       null, false, true,</b>
<i>1589</i>&nbsp;                                                       wantsTrailingNewline);
<i>1590</i>&nbsp;
<b class="nc"><i>1591</i>&nbsp;                    parser.parse(new StringReader(html), reader, true);</b>
<i>1592</i>&nbsp;                    reader.flush();
<i>1593</i>&nbsp;                }
<b class="nc"><i>1594</i>&nbsp;            }</b>
<b class="nc"><i>1595</i>&nbsp;        }</b>
<i>1596</i>&nbsp;    }
<i>1597</i>&nbsp;
<i>1598</i>&nbsp;    /**
<i>1599</i>&nbsp;     * Removes child Elements of the passed in Element &lt;code&gt;e&lt;/code&gt;. This
<i>1600</i>&nbsp;     * will do the necessary cleanup to ensure the element representing the
<i>1601</i>&nbsp;     * end character is correctly created.
<i>1602</i>&nbsp;     * &lt;p&gt;This is not a general purpose method, it assumes that &lt;code&gt;e&lt;/code&gt;
<i>1603</i>&nbsp;     * will still have at least one child after the remove, and it assumes
<i>1604</i>&nbsp;     * the character at &lt;code&gt;e.getStartOffset() - 1&lt;/code&gt; is a newline and
<i>1605</i>&nbsp;     * is of length 1.
<i>1606</i>&nbsp;     */
<i>1607</i>&nbsp;    private void removeElements(Element e, int index, int count) throws BadLocationException {
<i>1608</i>&nbsp;        writeLock();
<i>1609</i>&nbsp;        try {
<i>1610</i>&nbsp;            int start = e.getElement(index).getStartOffset();
<b class="nc"><i>1611</i>&nbsp;            int end = e.getElement(index + count - 1).getEndOffset();</b>
<b class="nc"><i>1612</i>&nbsp;            if (end &gt; getLength()) {</b>
<i>1613</i>&nbsp;                removeElementsAtEnd(e, index, count, start, end);
<i>1614</i>&nbsp;            }
<i>1615</i>&nbsp;            else {
<b class="nc"><i>1616</i>&nbsp;                removeElements(e, index, count, start, end);</b>
<b class="nc"><i>1617</i>&nbsp;            }</b>
<i>1618</i>&nbsp;        } finally {
<b class="nc"><i>1619</i>&nbsp;            writeUnlock();</b>
<b class="nc"><i>1620</i>&nbsp;        }</b>
<i>1621</i>&nbsp;    }
<i>1622</i>&nbsp;
<b class="nc"><i>1623</i>&nbsp;    /**</b>
<i>1624</i>&nbsp;     * Called to remove child elements of &lt;code&gt;e&lt;/code&gt; when one of the
<i>1625</i>&nbsp;     * elements to remove is representing the end character.
<i>1626</i>&nbsp;     * &lt;p&gt;Since the Content will not allow a removal to the end character
<i>1627</i>&nbsp;     * this will do a remove from &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;.
<i>1628</i>&nbsp;     * The end Element(s) will be removed, and the element representing
<i>1629</i>&nbsp;     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; will be recreated. This
<b class="nc"><i>1630</i>&nbsp;     * Element has to be recreated as after the content removal its offsets</b>
<i>1631</i>&nbsp;     * become &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;start - 1&lt;/code&gt;.
<b class="nc"><i>1632</i>&nbsp;     */</b>
<i>1633</i>&nbsp;    private void removeElementsAtEnd(Element e, int index, int count,
<i>1634</i>&nbsp;                         int start, int end) throws BadLocationException {
<i>1635</i>&nbsp;        // index must be &gt; 0 otherwise no insert would have happened.
<b class="nc"><i>1636</i>&nbsp;        boolean isLeaf = (e.getElement(index - 1).isLeaf());</b>
<b class="nc"><i>1637</i>&nbsp;        DefaultDocumentEvent dde = new DefaultDocumentEvent(</b>
<b class="nc"><i>1638</i>&nbsp;                       start - 1, end - start + 1, DocumentEvent.</b>
<i>1639</i>&nbsp;                       EventType.REMOVE);
<b class="nc"><i>1640</i>&nbsp;</b>
<b class="nc"><i>1641</i>&nbsp;        if (isLeaf) {</b>
<b class="nc"><i>1642</i>&nbsp;            Element endE = getCharacterElement(getLength());</b>
<i>1643</i>&nbsp;            // e.getElement(index - 1) should represent the newline.
<i>1644</i>&nbsp;            index--;
<b class="nc"><i>1645</i>&nbsp;            if (endE.getParentElement() != e) {</b>
<b class="nc"><i>1646</i>&nbsp;                // The hiearchies don&#39;t match, we&#39;ll have to manually</b>
<b class="nc"><i>1647</i>&nbsp;                // recreate the leaf at e.getElement(index - 1)</b>
<b class="nc"><i>1648</i>&nbsp;                replace(dde, e, index, ++count, start, end, true, true);</b>
<i>1649</i>&nbsp;            }
<i>1650</i>&nbsp;            else {
<i>1651</i>&nbsp;                // The hierarchies for the end Element and
<i>1652</i>&nbsp;                // e.getElement(index - 1), match, we can safely remove
<i>1653</i>&nbsp;                // the Elements and the end content will be aligned
<i>1654</i>&nbsp;                // appropriately.
<i>1655</i>&nbsp;                replace(dde, e, index, count, start, end, true, false);
<i>1656</i>&nbsp;            }
<i>1657</i>&nbsp;        }
<i>1658</i>&nbsp;        else {
<i>1659</i>&nbsp;            // Not a leaf, descend until we find the leaf representing
<i>1660</i>&nbsp;            // start - 1 and remove it.
<i>1661</i>&nbsp;            Element newLineE = e.getElement(index - 1);
<b class="nc"><i>1662</i>&nbsp;            while (!newLineE.isLeaf()) {</b>
<b class="nc"><i>1663</i>&nbsp;                newLineE = newLineE.getElement(newLineE.getElementCount() - 1);</b>
<i>1664</i>&nbsp;            }
<b class="nc"><i>1665</i>&nbsp;            newLineE = newLineE.getParentElement();</b>
<b class="nc"><i>1666</i>&nbsp;            replace(dde, e, index, count, start, end, false, false);</b>
<i>1667</i>&nbsp;            replace(dde, newLineE, newLineE.getElementCount() - 1, 1, start,
<b class="nc"><i>1668</i>&nbsp;                    end, true, true);</b>
<b class="nc"><i>1669</i>&nbsp;        }</b>
<b class="nc"><i>1670</i>&nbsp;        postRemoveUpdate(dde);</b>
<b class="nc"><i>1671</i>&nbsp;        dde.end();</b>
<i>1672</i>&nbsp;        fireRemoveUpdate(dde);
<i>1673</i>&nbsp;        fireUndoableEditUpdate(new UndoableEditEvent(this, dde));
<b class="nc"><i>1674</i>&nbsp;    }</b>
<b class="nc"><i>1675</i>&nbsp;</b>
<b class="nc"><i>1676</i>&nbsp;    /**</b>
<i>1677</i>&nbsp;     * This is used by &lt;code&gt;removeElementsAtEnd&lt;/code&gt;, it removes
<i>1678</i>&nbsp;     * &lt;code&gt;count&lt;/code&gt; elements starting at &lt;code&gt;start&lt;/code&gt; from
<b class="nc"><i>1679</i>&nbsp;     * &lt;code&gt;e&lt;/code&gt;.  If &lt;code&gt;remove&lt;/code&gt; is true text of length</b>
<i>1680</i>&nbsp;     * &lt;code&gt;start - 1&lt;/code&gt; to &lt;code&gt;end - 1&lt;/code&gt; is removed.  If
<b class="nc"><i>1681</i>&nbsp;     * &lt;code&gt;create&lt;/code&gt; is true a new leaf is created of length 1.</b>
<b class="nc"><i>1682</i>&nbsp;     */</b>
<i>1683</i>&nbsp;    private void replace(DefaultDocumentEvent dde, Element e, int index,
<i>1684</i>&nbsp;                         int count, int start, int end, boolean remove,
<i>1685</i>&nbsp;                         boolean create) throws BadLocationException {
<i>1686</i>&nbsp;        Element[] added;
<i>1687</i>&nbsp;        AttributeSet attrs = e.getElement(index).getAttributes();
<i>1688</i>&nbsp;        Element[] removed = new Element[count];
<i>1689</i>&nbsp;
<i>1690</i>&nbsp;        for (int counter = 0; counter &lt; count; counter++) {
<b class="nc"><i>1691</i>&nbsp;            removed[counter] = e.getElement(counter + index);</b>
<b class="nc"><i>1692</i>&nbsp;        }</b>
<b class="nc"><i>1693</i>&nbsp;        if (remove) {</b>
<b class="nc"><i>1694</i>&nbsp;            UndoableEdit u = getContent().remove(start - 1, end - start);</b>
<i>1695</i>&nbsp;            if (u != null) {
<b class="nc"><i>1696</i>&nbsp;                dde.addEdit(u);</b>
<i>1697</i>&nbsp;            }
<b class="nc"><i>1698</i>&nbsp;        }</b>
<i>1699</i>&nbsp;        if (create) {
<b class="nc"><i>1700</i>&nbsp;            added = new Element[1];</b>
<b class="nc"><i>1701</i>&nbsp;            added[0] = createLeafElement(e, attrs, start - 1, start);</b>
<b class="nc"><i>1702</i>&nbsp;        }</b>
<b class="nc"><i>1703</i>&nbsp;        else {</b>
<i>1704</i>&nbsp;            added = new Element[0];
<b class="nc"><i>1705</i>&nbsp;        }</b>
<b class="nc"><i>1706</i>&nbsp;        dde.addEdit(new ElementEdit(e, index, removed, added));</b>
<b class="nc"><i>1707</i>&nbsp;        ((AbstractDocument.BranchElement)e).replace(</b>
<b class="nc"><i>1708</i>&nbsp;                                             index, removed.length, added);</b>
<b class="nc"><i>1709</i>&nbsp;    }</b>
<i>1710</i>&nbsp;
<i>1711</i>&nbsp;    /**
<i>1712</i>&nbsp;     * Called to remove child Elements when the end is not touched.
<i>1713</i>&nbsp;     */
<i>1714</i>&nbsp;    private void removeElements(Element e, int index, int count,
<i>1715</i>&nbsp;                             int start, int end) throws BadLocationException {
<i>1716</i>&nbsp;        Element[] removed = new Element[count];
<b class="nc"><i>1717</i>&nbsp;        Element[] added = new Element[0];</b>
<i>1718</i>&nbsp;        for (int counter = 0; counter &lt; count; counter++) {
<i>1719</i>&nbsp;            removed[counter] = e.getElement(counter + index);
<i>1720</i>&nbsp;        }
<b class="nc"><i>1721</i>&nbsp;        DefaultDocumentEvent dde = new DefaultDocumentEvent</b>
<i>1722</i>&nbsp;                (start, end - start, DocumentEvent.EventType.REMOVE);
<i>1723</i>&nbsp;        ((AbstractDocument.BranchElement)e).replace(index, removed.length,
<i>1724</i>&nbsp;                                                    added);
<i>1725</i>&nbsp;        dde.addEdit(new ElementEdit(e, index, removed, added));
<i>1726</i>&nbsp;        UndoableEdit u = getContent().remove(start, end - start);
<i>1727</i>&nbsp;        if (u != null) {
<i>1728</i>&nbsp;            dde.addEdit(u);
<i>1729</i>&nbsp;        }
<i>1730</i>&nbsp;        postRemoveUpdate(dde);
<i>1731</i>&nbsp;        dde.end();
<i>1732</i>&nbsp;        fireRemoveUpdate(dde);
<i>1733</i>&nbsp;        if (u != null) {
<i>1734</i>&nbsp;            fireUndoableEditUpdate(new UndoableEditEvent(this, dde));
<i>1735</i>&nbsp;        }
<i>1736</i>&nbsp;    }
<i>1737</i>&nbsp;
<b class="nc"><i>1738</i>&nbsp;</b>
<i>1739</i>&nbsp;    // These two are provided for inner class access. The are named different
<i>1740</i>&nbsp;    // than the super class as the super class implementations are final.
<i>1741</i>&nbsp;    void obtainLock() {
<i>1742</i>&nbsp;        writeLock();
<i>1743</i>&nbsp;    }
<i>1744</i>&nbsp;
<i>1745</i>&nbsp;    void releaseLock() {
<i>1746</i>&nbsp;        writeUnlock();
<i>1747</i>&nbsp;    }
<i>1748</i>&nbsp;
<i>1749</i>&nbsp;    //
<i>1750</i>&nbsp;    // Provided for inner class access.
<b class="nc"><i>1751</i>&nbsp;    //</b>
<i>1752</i>&nbsp;
<i>1753</i>&nbsp;    /**
<i>1754</i>&nbsp;     * Notifies all listeners that have registered interest for
<b class="nc"><i>1755</i>&nbsp;     * notification on this event type.  The event instance</b>
<i>1756</i>&nbsp;     * is lazily created using the parameters passed into
<i>1757</i>&nbsp;     * the fire method.
<i>1758</i>&nbsp;     *
<b class="nc"><i>1759</i>&nbsp;     * @param e the event</b>
<i>1760</i>&nbsp;     * @see EventListenerList
<i>1761</i>&nbsp;     */
<i>1762</i>&nbsp;    protected void fireChangedUpdate(DocumentEvent e) {
<i>1763</i>&nbsp;        super.fireChangedUpdate(e);
<i>1764</i>&nbsp;    }
<i>1765</i>&nbsp;
<b class="nc"><i>1766</i>&nbsp;    /**</b>
<b class="nc"><i>1767</i>&nbsp;     * Notifies all listeners that have registered interest for</b>
<i>1768</i>&nbsp;     * notification on this event type.  The event instance
<i>1769</i>&nbsp;     * is lazily created using the parameters passed into
<i>1770</i>&nbsp;     * the fire method.
<i>1771</i>&nbsp;     *
<i>1772</i>&nbsp;     * @param e the event
<i>1773</i>&nbsp;     * @see EventListenerList
<i>1774</i>&nbsp;     */
<i>1775</i>&nbsp;    protected void fireUndoableEditUpdate(UndoableEditEvent e) {
<i>1776</i>&nbsp;        super.fireUndoableEditUpdate(e);
<i>1777</i>&nbsp;    }
<i>1778</i>&nbsp;
<i>1779</i>&nbsp;    boolean hasBaseTag() {
<i>1780</i>&nbsp;        return hasBaseTag;
<i>1781</i>&nbsp;    }
<i>1782</i>&nbsp;
<i>1783</i>&nbsp;    String getBaseTarget() {
<i>1784</i>&nbsp;        return baseTarget;
<i>1785</i>&nbsp;    }
<i>1786</i>&nbsp;
<i>1787</i>&nbsp;    /*
<i>1788</i>&nbsp;     * state defines whether the document is a frame document
<i>1789</i>&nbsp;     * or not.
<i>1790</i>&nbsp;     */
<i>1791</i>&nbsp;    private boolean frameDocument = false;
<i>1792</i>&nbsp;    private boolean preservesUnknownTags = true;
<i>1793</i>&nbsp;
<i>1794</i>&nbsp;    /*
<i>1795</i>&nbsp;     * Used to store button groups for radio buttons in
<i>1796</i>&nbsp;     * a form.
<i>1797</i>&nbsp;     */
<i>1798</i>&nbsp;    private HashMap&lt;String, ButtonGroup&gt; radioButtonGroupsMap;
<i>1799</i>&nbsp;
<i>1800</i>&nbsp;    /**
<i>1801</i>&nbsp;     * Document property for the number of tokens to buffer
<i>1802</i>&nbsp;     * before building an element subtree to represent them.
<i>1803</i>&nbsp;     */
<i>1804</i>&nbsp;    static final String TokenThreshold = &quot;token threshold&quot;;
<i>1805</i>&nbsp;
<i>1806</i>&nbsp;    private static final int MaxThreshold = 10000;
<i>1807</i>&nbsp;
<i>1808</i>&nbsp;    private static final int StepThreshold = 5;
<b class="nc"><i>1809</i>&nbsp;</b>
<i>1810</i>&nbsp;
<i>1811</i>&nbsp;    /**
<i>1812</i>&nbsp;     * Document property key value. The value for the key will be a Vector
<i>1813</i>&nbsp;     * of Strings that are comments not found in the body.
<b class="nc"><i>1814</i>&nbsp;     */</b>
<i>1815</i>&nbsp;    public static final String AdditionalComments = &quot;AdditionalComments&quot;;
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;    /**
<i>1818</i>&nbsp;     * Document property key value. The value for the key will be a
<i>1819</i>&nbsp;     * String indicating the default type of stylesheet links.
<i>1820</i>&nbsp;     */
<i>1821</i>&nbsp;    /* public */ static final String StyleType = &quot;StyleType&quot;;
<i>1822</i>&nbsp;
<i>1823</i>&nbsp;    /**
<i>1824</i>&nbsp;     * The location to resolve relative URLs against.  By
<i>1825</i>&nbsp;     * default this will be the document&#39;s URL if the document
<i>1826</i>&nbsp;     * was loaded from a URL.  If a base tag is found and
<i>1827</i>&nbsp;     * can be parsed, it will be used as the base location.
<i>1828</i>&nbsp;     */
<i>1829</i>&nbsp;    URL base;
<b class="nc"><i>1830</i>&nbsp;</b>
<i>1831</i>&nbsp;    /**
<i>1832</i>&nbsp;     * does the document have base tag
<i>1833</i>&nbsp;     */
<i>1834</i>&nbsp;    boolean hasBaseTag = false;
<i>1835</i>&nbsp;
<i>1836</i>&nbsp;    /**
<b class="nc"><i>1837</i>&nbsp;     * BASE tag&#39;s TARGET attribute value</b>
<i>1838</i>&nbsp;     */
<i>1839</i>&nbsp;    private String baseTarget = null;
<i>1840</i>&nbsp;
<i>1841</i>&nbsp;    /**
<i>1842</i>&nbsp;     * The parser that is used when inserting html into the existing
<i>1843</i>&nbsp;     * document.
<i>1844</i>&nbsp;     */
<i>1845</i>&nbsp;    private HTMLEditorKit.Parser parser;
<i>1846</i>&nbsp;
<b class="nc"><i>1847</i>&nbsp;    /**</b>
<b class="nc"><i>1848</i>&nbsp;     * Used for inserts when a null AttributeSet is supplied.</b>
<b class="nc"><i>1849</i>&nbsp;     */</b>
<i>1850</i>&nbsp;    private static AttributeSet contentAttributeSet;
<b class="nc"><i>1851</i>&nbsp;</b>
<b class="nc"><i>1852</i>&nbsp;    /**</b>
<i>1853</i>&nbsp;     * Property Maps are registered under, will be a Hashtable.
<i>1854</i>&nbsp;     */
<i>1855</i>&nbsp;    static String MAP_PROPERTY = &quot;__MAP__&quot;;
<i>1856</i>&nbsp;
<i>1857</i>&nbsp;    private static char[] NEWLINE;
<i>1858</i>&nbsp;
<i>1859</i>&nbsp;    /**
<i>1860</i>&nbsp;     * Indicates that direct insertion to body section takes place.
<i>1861</i>&nbsp;     */
<i>1862</i>&nbsp;    private boolean insertInBody = false;
<i>1863</i>&nbsp;
<b class="nc"><i>1864</i>&nbsp;    /**</b>
<i>1865</i>&nbsp;     * I18N property key.
<i>1866</i>&nbsp;     *
<i>1867</i>&nbsp;     * @see AbstractDocument#I18NProperty
<i>1868</i>&nbsp;     */
<i>1869</i>&nbsp;    private static final String I18NProperty = &quot;i18n&quot;;
<i>1870</i>&nbsp;
<i>1871</i>&nbsp;    static {
<i>1872</i>&nbsp;        contentAttributeSet = new SimpleAttributeSet();
<i>1873</i>&nbsp;        ((MutableAttributeSet)contentAttributeSet).
<i>1874</i>&nbsp;                        addAttribute(StyleConstants.NameAttribute,
<i>1875</i>&nbsp;                                     HTML.Tag.CONTENT);
<i>1876</i>&nbsp;        NEWLINE = new char[1];
<i>1877</i>&nbsp;        NEWLINE[0] = &#39;\n&#39;;
<i>1878</i>&nbsp;    }
<i>1879</i>&nbsp;
<i>1880</i>&nbsp;
<i>1881</i>&nbsp;    /**
<i>1882</i>&nbsp;     * An iterator to iterate over a particular type of
<i>1883</i>&nbsp;     * tag.  The iterator is not thread safe.  If reliable
<i>1884</i>&nbsp;     * access to the document is not already ensured by
<i>1885</i>&nbsp;     * the context under which the iterator is being used,
<i>1886</i>&nbsp;     * its use should be performed under the protection of
<i>1887</i>&nbsp;     * Document.render.
<i>1888</i>&nbsp;     */
<i>1889</i>&nbsp;    public abstract static class Iterator {
<i>1890</i>&nbsp;
<i>1891</i>&nbsp;        /**
<i>1892</i>&nbsp;         * Return the attributes for this tag.
<i>1893</i>&nbsp;         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag, or
<i>1894</i>&nbsp;         *      &lt;code&gt;null&lt;/code&gt; if none can be found
<i>1895</i>&nbsp;         */
<i>1896</i>&nbsp;        public abstract AttributeSet getAttributes();
<i>1897</i>&nbsp;
<i>1898</i>&nbsp;        /**
<i>1899</i>&nbsp;         * Returns the start of the range for which the current occurrence of
<i>1900</i>&nbsp;         * the tag is defined and has the same attributes.
<i>1901</i>&nbsp;         *
<i>1902</i>&nbsp;         * @return the start of the range, or -1 if it can&#39;t be found
<i>1903</i>&nbsp;         */
<i>1904</i>&nbsp;        public abstract int getStartOffset();
<i>1905</i>&nbsp;
<i>1906</i>&nbsp;        /**
<i>1907</i>&nbsp;         * Returns the end of the range for which the current occurrence of
<i>1908</i>&nbsp;         * the tag is defined and has the same attributes.
<i>1909</i>&nbsp;         *
<i>1910</i>&nbsp;         * @return the end of the range
<i>1911</i>&nbsp;         */
<i>1912</i>&nbsp;        public abstract int getEndOffset();
<i>1913</i>&nbsp;
<i>1914</i>&nbsp;        /**
<b class="nc"><i>1915</i>&nbsp;         * Move the iterator forward to the next occurrence</b>
<b class="nc"><i>1916</i>&nbsp;         * of the tag it represents.</b>
<b class="nc"><i>1917</i>&nbsp;         */</b>
<b class="nc"><i>1918</i>&nbsp;        public abstract void next();</b>
<b class="nc"><i>1919</i>&nbsp;</b>
<i>1920</i>&nbsp;        /**
<i>1921</i>&nbsp;         * Indicates if the iterator is currently
<i>1922</i>&nbsp;         * representing an occurrence of a tag.  If
<i>1923</i>&nbsp;         * false there are no more tags for this iterator.
<i>1924</i>&nbsp;         * @return true if the iterator is currently representing an
<i>1925</i>&nbsp;         *              occurrence of a tag, otherwise returns false
<i>1926</i>&nbsp;         */
<i>1927</i>&nbsp;        public abstract boolean isValid();
<b class="nc"><i>1928</i>&nbsp;</b>
<b class="nc"><i>1929</i>&nbsp;        /**</b>
<b class="nc"><i>1930</i>&nbsp;         * Type of tag this iterator represents.</b>
<b class="nc"><i>1931</i>&nbsp;         * @return the tag</b>
<b class="nc"><i>1932</i>&nbsp;         */</b>
<b class="nc"><i>1933</i>&nbsp;        public abstract HTML.Tag getTag();</b>
<i>1934</i>&nbsp;    }
<b class="nc"><i>1935</i>&nbsp;</b>
<i>1936</i>&nbsp;    /**
<b class="nc"><i>1937</i>&nbsp;     * An iterator to iterate over a particular type of tag.</b>
<i>1938</i>&nbsp;     */
<i>1939</i>&nbsp;    static class LeafIterator extends Iterator {
<i>1940</i>&nbsp;
<i>1941</i>&nbsp;        LeafIterator(HTML.Tag t, Document doc) {
<i>1942</i>&nbsp;            tag = t;
<i>1943</i>&nbsp;            pos = new ElementIterator(doc);
<i>1944</i>&nbsp;            endOffset = 0;
<i>1945</i>&nbsp;            next();
<i>1946</i>&nbsp;        }
<b class="nc"><i>1947</i>&nbsp;</b>
<b class="nc"><i>1948</i>&nbsp;        /**</b>
<b class="nc"><i>1949</i>&nbsp;         * Returns the attributes for this tag.</b>
<i>1950</i>&nbsp;         * @return the &lt;code&gt;AttributeSet&lt;/code&gt; for this tag,
<b class="nc"><i>1951</i>&nbsp;         *              or &lt;code&gt;null&lt;/code&gt; if none can be found</b>
<i>1952</i>&nbsp;         */
<i>1953</i>&nbsp;        public AttributeSet getAttributes() {
<i>1954</i>&nbsp;            Element elem = pos.current();
<i>1955</i>&nbsp;            if (elem != null) {
<i>1956</i>&nbsp;                AttributeSet a = (AttributeSet)
<i>1957</i>&nbsp;                    elem.getAttributes().getAttribute(tag);
<i>1958</i>&nbsp;                if (a == null) {
<i>1959</i>&nbsp;                    a = elem.getAttributes();
<i>1960</i>&nbsp;                }
<b class="nc"><i>1961</i>&nbsp;                return a;</b>
<i>1962</i>&nbsp;            }
<i>1963</i>&nbsp;            return null;
<i>1964</i>&nbsp;        }
<i>1965</i>&nbsp;
<i>1966</i>&nbsp;        /**
<i>1967</i>&nbsp;         * Returns the start of the range for which the current occurrence of
<i>1968</i>&nbsp;         * the tag is defined and has the same attributes.
<b class="nc"><i>1969</i>&nbsp;         *</b>
<b class="nc"><i>1970</i>&nbsp;         * @return the start of the range, or -1 if it can&#39;t be found</b>
<b class="nc"><i>1971</i>&nbsp;         */</b>
<b class="nc"><i>1972</i>&nbsp;        public int getStartOffset() {</b>
<i>1973</i>&nbsp;            Element elem = pos.current();
<b class="nc"><i>1974</i>&nbsp;            if (elem != null) {</b>
<b class="nc"><i>1975</i>&nbsp;                return elem.getStartOffset();</b>
<i>1976</i>&nbsp;            }
<i>1977</i>&nbsp;            return -1;
<b class="nc"><i>1978</i>&nbsp;        }</b>
<b class="nc"><i>1979</i>&nbsp;</b>
<i>1980</i>&nbsp;        /**
<i>1981</i>&nbsp;         * Returns the end of the range for which the current occurrence of
<i>1982</i>&nbsp;         * the tag is defined and has the same attributes.
<i>1983</i>&nbsp;         *
<i>1984</i>&nbsp;         * @return the end of the range
<i>1985</i>&nbsp;         */
<i>1986</i>&nbsp;        public int getEndOffset() {
<i>1987</i>&nbsp;            return endOffset;
<i>1988</i>&nbsp;        }
<i>1989</i>&nbsp;
<i>1990</i>&nbsp;        /**
<i>1991</i>&nbsp;         * Moves the iterator forward to the next occurrence
<b class="nc"><i>1992</i>&nbsp;         * of the tag it represents.</b>
<i>1993</i>&nbsp;         */
<i>1994</i>&nbsp;        public void next() {
<i>1995</i>&nbsp;            for (nextLeaf(pos); isValid(); nextLeaf(pos)) {
<i>1996</i>&nbsp;                Element elem = pos.current();
<i>1997</i>&nbsp;                if (elem.getStartOffset() &gt;= endOffset) {
<i>1998</i>&nbsp;                    AttributeSet a = pos.current().getAttributes();
<i>1999</i>&nbsp;
<i>2000</i>&nbsp;                    if (a.isDefined(tag) ||
<b class="nc"><i>2001</i>&nbsp;                        a.getAttribute(StyleConstants.NameAttribute) == tag) {</b>
<i>2002</i>&nbsp;
<i>2003</i>&nbsp;                        // we found the next one
<i>2004</i>&nbsp;                        setEndOffset();
<i>2005</i>&nbsp;                        break;
<i>2006</i>&nbsp;                    }
<i>2007</i>&nbsp;                }
<i>2008</i>&nbsp;            }
<b class="nc"><i>2009</i>&nbsp;        }</b>
<b class="nc"><i>2010</i>&nbsp;</b>
<b class="nc"><i>2011</i>&nbsp;        /**</b>
<b class="nc"><i>2012</i>&nbsp;         * Returns the type of tag this iterator represents.</b>
<i>2013</i>&nbsp;         *
<i>2014</i>&nbsp;         * @return the &lt;code&gt;HTML.Tag&lt;/code&gt; that this iterator represents.
<i>2015</i>&nbsp;         * @see javax.swing.text.html.HTML.Tag
<i>2016</i>&nbsp;         */
<i>2017</i>&nbsp;        public HTML.Tag getTag() {
<i>2018</i>&nbsp;            return tag;
<i>2019</i>&nbsp;        }
<i>2020</i>&nbsp;
<i>2021</i>&nbsp;        /**
<b class="nc"><i>2022</i>&nbsp;         * Returns true if the current position is not &lt;code&gt;null&lt;/code&gt;.</b>
<b class="nc"><i>2023</i>&nbsp;         * @return true if current position is not &lt;code&gt;null&lt;/code&gt;,</b>
<b class="nc"><i>2024</i>&nbsp;         *              otherwise returns false</b>
<b class="nc"><i>2025</i>&nbsp;         */</b>
<b class="nc"><i>2026</i>&nbsp;        public boolean isValid() {</b>
<b class="nc"><i>2027</i>&nbsp;            return (pos.current() != null);</b>
<b class="nc"><i>2028</i>&nbsp;        }</b>
<b class="nc"><i>2029</i>&nbsp;</b>
<i>2030</i>&nbsp;        /**
<b class="nc"><i>2031</i>&nbsp;         * Moves the given iterator to the next leaf element.</b>
<i>2032</i>&nbsp;         * @param iter  the iterator to be scanned
<i>2033</i>&nbsp;         */
<i>2034</i>&nbsp;        void nextLeaf(ElementIterator iter) {
<i>2035</i>&nbsp;            for (iter.next(); iter.current() != null; iter.next()) {
<i>2036</i>&nbsp;                Element e = iter.current();
<i>2037</i>&nbsp;                if (e.isLeaf()) {
<i>2038</i>&nbsp;                    break;
<i>2039</i>&nbsp;                }
<i>2040</i>&nbsp;            }
<i>2041</i>&nbsp;        }
<i>2042</i>&nbsp;
<i>2043</i>&nbsp;        /**
<i>2044</i>&nbsp;         * Marches a cloned iterator forward to locate the end
<i>2045</i>&nbsp;         * of the run.  This sets the value of &lt;code&gt;endOffset&lt;/code&gt;.
<i>2046</i>&nbsp;         */
<i>2047</i>&nbsp;        void setEndOffset() {
<i>2048</i>&nbsp;            AttributeSet a0 = getAttributes();
<i>2049</i>&nbsp;            endOffset = pos.current().getEndOffset();
<i>2050</i>&nbsp;            ElementIterator fwd = (ElementIterator) pos.clone();
<i>2051</i>&nbsp;            for (nextLeaf(fwd); fwd.current() != null; nextLeaf(fwd)) {
<i>2052</i>&nbsp;                Element e = fwd.current();
<i>2053</i>&nbsp;                AttributeSet a1 = (AttributeSet) e.getAttributes().getAttribute(tag);
<i>2054</i>&nbsp;                if ((a1 == null) || (! a1.equals(a0))) {
<i>2055</i>&nbsp;                    break;
<i>2056</i>&nbsp;                }
<i>2057</i>&nbsp;                endOffset = e.getEndOffset();
<i>2058</i>&nbsp;            }
<i>2059</i>&nbsp;        }
<i>2060</i>&nbsp;
<i>2061</i>&nbsp;        private int endOffset;
<i>2062</i>&nbsp;        private HTML.Tag tag;
<i>2063</i>&nbsp;        private ElementIterator pos;
<i>2064</i>&nbsp;
<i>2065</i>&nbsp;    }
<i>2066</i>&nbsp;
<i>2067</i>&nbsp;    /**
<i>2068</i>&nbsp;     * An HTML reader to load an HTML document with an HTML
<i>2069</i>&nbsp;     * element structure.  This is a set of callbacks from
<i>2070</i>&nbsp;     * the parser, implemented to create a set of elements
<i>2071</i>&nbsp;     * tagged with attributes.  The parse builds up tokens
<i>2072</i>&nbsp;     * (ElementSpec) that describe the element subtree desired,
<i>2073</i>&nbsp;     * and burst it into the document under the protection of
<i>2074</i>&nbsp;     * a write lock using the insert method on the document
<i>2075</i>&nbsp;     * outer class.
<i>2076</i>&nbsp;     * &lt;p&gt;
<i>2077</i>&nbsp;     * The reader can be configured by registering actions
<i>2078</i>&nbsp;     * (of type &lt;code&gt;HTMLDocument.HTMLReader.TagAction&lt;/code&gt;)
<i>2079</i>&nbsp;     * that describe how to handle the action.  The idea behind
<i>2080</i>&nbsp;     * the actions provided is that the most natural text editing
<i>2081</i>&nbsp;     * operations can be provided if the element structure boils
<i>2082</i>&nbsp;     * down to paragraphs with runs of some kind of style
<i>2083</i>&nbsp;     * in them.  Some things are more naturally specified
<i>2084</i>&nbsp;     * structurally, so arbitrary structure should be allowed
<i>2085</i>&nbsp;     * above the paragraphs, but will need to be edited with structural
<i>2086</i>&nbsp;     * actions.  The implication of this is that some of the
<i>2087</i>&nbsp;     * HTML elements specified in the stream being parsed will
<i>2088</i>&nbsp;     * be collapsed into attributes, and in some cases paragraphs
<i>2089</i>&nbsp;     * will be synthesized.  When HTML elements have been
<i>2090</i>&nbsp;     * converted to attributes, the attribute key will be of
<i>2091</i>&nbsp;     * type HTML.Tag, and the value will be of type AttributeSet
<i>2092</i>&nbsp;     * so that no information is lost.  This enables many of the
<i>2093</i>&nbsp;     * existing actions to work so that the user can type input,
<i>2094</i>&nbsp;     * hit the return key, backspace, delete, etc and have a
<i>2095</i>&nbsp;     * reasonable result.  Selections can be created, and attributes
<i>2096</i>&nbsp;     * applied or removed, etc.  With this in mind, the work done
<i>2097</i>&nbsp;     * by the reader can be categorized into the following kinds
<i>2098</i>&nbsp;     * of tasks:
<i>2099</i>&nbsp;     * &lt;dl&gt;
<i>2100</i>&nbsp;     * &lt;dt&gt;Block
<i>2101</i>&nbsp;     * &lt;dd&gt;Build the structure like it&#39;s specified in the stream.
<i>2102</i>&nbsp;     * This produces elements that contain other elements.
<i>2103</i>&nbsp;     * &lt;dt&gt;Paragraph
<i>2104</i>&nbsp;     * &lt;dd&gt;Like block except that it&#39;s expected that the element
<i>2105</i>&nbsp;     * will be used with a paragraph view so a paragraph element
<i>2106</i>&nbsp;     * won&#39;t need to be synthesized.
<i>2107</i>&nbsp;     * &lt;dt&gt;Character
<i>2108</i>&nbsp;     * &lt;dd&gt;Contribute the element as an attribute that will start
<i>2109</i>&nbsp;     * and stop at arbitrary text locations.  This will ultimately
<i>2110</i>&nbsp;     * be mixed into a run of text, with all of the currently
<i>2111</i>&nbsp;     * flattened HTML character elements.
<i>2112</i>&nbsp;     * &lt;dt&gt;Special
<i>2113</i>&nbsp;     * &lt;dd&gt;Produce an embedded graphical element.
<i>2114</i>&nbsp;     * &lt;dt&gt;Form
<i>2115</i>&nbsp;     * &lt;dd&gt;Produce an element that is like the embedded graphical
<i>2116</i>&nbsp;     * element, except that it also has a component model associated
<i>2117</i>&nbsp;     * with it.
<i>2118</i>&nbsp;     * &lt;dt&gt;Hidden
<i>2119</i>&nbsp;     * &lt;dd&gt;Create an element that is hidden from view when the
<i>2120</i>&nbsp;     * document is being viewed read-only, and visible when the
<i>2121</i>&nbsp;     * document is being edited.  This is useful to keep the
<i>2122</i>&nbsp;     * model from losing information, and used to store things
<i>2123</i>&nbsp;     * like comments and unrecognized tags.
<i>2124</i>&nbsp;     *
<i>2125</i>&nbsp;     * &lt;/dl&gt;
<i>2126</i>&nbsp;     * &lt;p&gt;
<i>2127</i>&nbsp;     * Currently, &amp;lt;APPLET&amp;gt;, &amp;lt;PARAM&amp;gt;, &amp;lt;MAP&amp;gt;, &amp;lt;AREA&amp;gt;, &amp;lt;LINK&amp;gt;,
<i>2128</i>&nbsp;     * &amp;lt;SCRIPT&amp;gt; and &amp;lt;STYLE&amp;gt; are unsupported.
<i>2129</i>&nbsp;     *
<i>2130</i>&nbsp;     * &lt;p&gt;
<i>2131</i>&nbsp;     * The assignment of the actions described is shown in the
<i>2132</i>&nbsp;     * following table for the tags defined in &lt;code&gt;HTML.Tag&lt;/code&gt;.
<i>2133</i>&nbsp;     *
<i>2134</i>&nbsp;     * &lt;table class=&quot;striped&quot;&gt;
<i>2135</i>&nbsp;     * &lt;caption&gt;HTML tags and assigned actions&lt;/caption&gt;
<i>2136</i>&nbsp;     * &lt;thead&gt;
<i>2137</i>&nbsp;     *   &lt;tr&gt;
<i>2138</i>&nbsp;     *     &lt;th scope=&quot;col&quot;&gt;Tag
<i>2139</i>&nbsp;     *     &lt;th scope=&quot;col&quot;&gt;Action
<i>2140</i>&nbsp;     * &lt;/thead&gt;
<i>2141</i>&nbsp;     * &lt;tbody&gt;
<i>2142</i>&nbsp;     *   &lt;tr&gt;
<i>2143</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.A}
<i>2144</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2145</i>&nbsp;     *   &lt;tr&gt;
<i>2146</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.ADDRESS}
<i>2147</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2148</i>&nbsp;     *   &lt;tr&gt;
<i>2149</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.APPLET}
<i>2150</i>&nbsp;     *     &lt;td&gt;HiddenAction
<i>2151</i>&nbsp;     *   &lt;tr&gt;
<i>2152</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.AREA}
<i>2153</i>&nbsp;     *     &lt;td&gt;AreaAction
<i>2154</i>&nbsp;     *   &lt;tr&gt;
<i>2155</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.B}
<i>2156</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2157</i>&nbsp;     *   &lt;tr&gt;
<i>2158</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BASE}
<i>2159</i>&nbsp;     *     &lt;td&gt;BaseAction
<i>2160</i>&nbsp;     *   &lt;tr&gt;
<i>2161</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BASEFONT}
<i>2162</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2163</i>&nbsp;     *   &lt;tr&gt;
<i>2164</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BIG}
<i>2165</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2166</i>&nbsp;     *   &lt;tr&gt;
<i>2167</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BLOCKQUOTE}
<i>2168</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2169</i>&nbsp;     *   &lt;tr&gt;
<i>2170</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BODY}
<i>2171</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2172</i>&nbsp;     *   &lt;tr&gt;
<i>2173</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.BR}
<i>2174</i>&nbsp;     *     &lt;td&gt;SpecialAction
<i>2175</i>&nbsp;     *   &lt;tr&gt;
<i>2176</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.CAPTION}
<i>2177</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2178</i>&nbsp;     *   &lt;tr&gt;
<i>2179</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.CENTER}
<i>2180</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2181</i>&nbsp;     *   &lt;tr&gt;
<i>2182</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.CITE}
<i>2183</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2184</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2185</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.CODE}</b>
<i>2186</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2187</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2188</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DD}</b>
<i>2189</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2190</i>&nbsp;     *   &lt;tr&gt;
<i>2191</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DFN}
<i>2192</i>&nbsp;     *     &lt;td&gt;CharacterAction
<b class="nc"><i>2193</i>&nbsp;     *   &lt;tr&gt;</b>
<i>2194</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DIR}
<i>2195</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2196</i>&nbsp;     *   &lt;tr&gt;
<i>2197</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DIV}
<i>2198</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2199</i>&nbsp;     *   &lt;tr&gt;
<i>2200</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DL}
<i>2201</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2202</i>&nbsp;     *   &lt;tr&gt;
<i>2203</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.DT}
<i>2204</i>&nbsp;     *     &lt;td&gt;ParagraphAction
<i>2205</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2206</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.EM}</b>
<b class="nc"><i>2207</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2208</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2209</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.FONT}</b>
<b class="nc"><i>2210</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2211</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2212</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.FORM}</b>
<b class="nc"><i>2213</i>&nbsp;     *     &lt;td&gt;As of 1.4 a BlockAction</b>
<b class="nc"><i>2214</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2215</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.FRAME}</b>
<b class="nc"><i>2216</i>&nbsp;     *     &lt;td&gt;SpecialAction</b>
<b class="nc"><i>2217</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2218</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.FRAMESET}</b>
<b class="nc"><i>2219</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<i>2220</i>&nbsp;     *   &lt;tr&gt;
<i>2221</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H1}
<b class="nc"><i>2222</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2223</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2224</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H2}</b>
<b class="nc"><i>2225</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2226</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2227</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H3}</b>
<b class="nc"><i>2228</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2229</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2230</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H4}</b>
<b class="nc"><i>2231</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2232</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2233</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H5}</b>
<b class="nc"><i>2234</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2235</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2236</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.H6}</b>
<b class="nc"><i>2237</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2238</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2239</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.HEAD}</b>
<b class="nc"><i>2240</i>&nbsp;     *     &lt;td&gt;HeadAction</b>
<b class="nc"><i>2241</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2242</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.HR}</b>
<b class="nc"><i>2243</i>&nbsp;     *     &lt;td&gt;SpecialAction</b>
<b class="nc"><i>2244</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2245</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.HTML}</b>
<b class="nc"><i>2246</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2247</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2248</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.I}</b>
<b class="nc"><i>2249</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2250</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2251</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.IMG}</b>
<b class="nc"><i>2252</i>&nbsp;     *     &lt;td&gt;SpecialAction</b>
<b class="nc"><i>2253</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2254</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.INPUT}</b>
<b class="nc"><i>2255</i>&nbsp;     *     &lt;td&gt;FormAction</b>
<b class="nc"><i>2256</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2257</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.ISINDEX}</b>
<b class="nc"><i>2258</i>&nbsp;     *     &lt;td&gt;IsndexAction</b>
<b class="nc"><i>2259</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2260</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.KBD}</b>
<b class="nc"><i>2261</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2262</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2263</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.LI}</b>
<b class="nc"><i>2264</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2265</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2266</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.LINK}</b>
<b class="nc"><i>2267</i>&nbsp;     *     &lt;td&gt;LinkAction</b>
<b class="nc"><i>2268</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2269</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.MAP}</b>
<b class="nc"><i>2270</i>&nbsp;     *     &lt;td&gt;MapAction</b>
<b class="nc"><i>2271</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2272</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.MENU}</b>
<b class="nc"><i>2273</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2274</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2275</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.META}</b>
<b class="nc"><i>2276</i>&nbsp;     *     &lt;td&gt;MetaAction</b>
<b class="nc"><i>2277</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2278</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.NOFRAMES}</b>
<b class="nc"><i>2279</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2280</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2281</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.OBJECT}</b>
<b class="nc"><i>2282</i>&nbsp;     *     &lt;td&gt;SpecialAction</b>
<b class="nc"><i>2283</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2284</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.OL}</b>
<b class="nc"><i>2285</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2286</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2287</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.OPTION}</b>
<b class="nc"><i>2288</i>&nbsp;     *     &lt;td&gt;FormAction</b>
<b class="nc"><i>2289</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2290</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.P}</b>
<b class="nc"><i>2291</i>&nbsp;     *     &lt;td&gt;ParagraphAction</b>
<b class="nc"><i>2292</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2293</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.PARAM}</b>
<b class="nc"><i>2294</i>&nbsp;     *     &lt;td&gt;HiddenAction</b>
<b class="nc"><i>2295</i>&nbsp;     *   &lt;tr&gt;</b>
<i>2296</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.PRE}
<b class="nc"><i>2297</i>&nbsp;     *     &lt;td&gt;PreAction</b>
<b class="nc"><i>2298</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2299</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SAMP}</b>
<b class="nc"><i>2300</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2301</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2302</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SCRIPT}</b>
<i>2303</i>&nbsp;     *     &lt;td&gt;HiddenAction
<i>2304</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2305</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SELECT}</b>
<i>2306</i>&nbsp;     *     &lt;td&gt;FormAction
<b class="nc"><i>2307</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2308</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SMALL}</b>
<b class="nc"><i>2309</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2310</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2311</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.STRIKE}</b>
<b class="nc"><i>2312</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2313</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2314</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.S}</b>
<i>2315</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2316</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2317</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.STRONG}</b>
<b class="nc"><i>2318</i>&nbsp;     *     &lt;td&gt;CharacterAction</b>
<b class="nc"><i>2319</i>&nbsp;     *   &lt;tr&gt;</b>
<i>2320</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.STYLE}
<i>2321</i>&nbsp;     *     &lt;td&gt;StyleAction
<i>2322</i>&nbsp;     *   &lt;tr&gt;
<i>2323</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SUB}
<i>2324</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2325</i>&nbsp;     *   &lt;tr&gt;
<i>2326</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.SUP}
<i>2327</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2328</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2329</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TABLE}</b>
<b class="nc"><i>2330</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2331</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2332</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TD}</b>
<i>2333</i>&nbsp;     *     &lt;td&gt;BlockAction
<b class="nc"><i>2334</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2335</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TEXTAREA}</b>
<i>2336</i>&nbsp;     *     &lt;td&gt;FormAction
<i>2337</i>&nbsp;     *   &lt;tr&gt;
<b class="nc"><i>2338</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TH}</b>
<b class="nc"><i>2339</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2340</i>&nbsp;     *   &lt;tr&gt;</b>
<i>2341</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TITLE}
<b class="nc"><i>2342</i>&nbsp;     *     &lt;td&gt;TitleAction</b>
<b class="nc"><i>2343</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2344</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TR}</b>
<b class="nc"><i>2345</i>&nbsp;     *     &lt;td&gt;BlockAction</b>
<b class="nc"><i>2346</i>&nbsp;     *   &lt;tr&gt;</b>
<b class="nc"><i>2347</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.TT}</b>
<i>2348</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2349</i>&nbsp;     *   &lt;tr&gt;
<i>2350</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.U}
<i>2351</i>&nbsp;     *     &lt;td&gt;CharacterAction
<i>2352</i>&nbsp;     *   &lt;tr&gt;
<i>2353</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.UL}
<i>2354</i>&nbsp;     *     &lt;td&gt;BlockAction
<i>2355</i>&nbsp;     *   &lt;tr&gt;
<i>2356</i>&nbsp;     *     &lt;th scope=&quot;row&quot;&gt;{@code HTML.Tag.VAR}
<i>2357</i>&nbsp;     *     &lt;td&gt;CharacterAction
<b class="nc"><i>2358</i>&nbsp;     * &lt;/tbody&gt;</b>
<b class="nc"><i>2359</i>&nbsp;     * &lt;/table&gt;</b>
<b class="nc"><i>2360</i>&nbsp;     * &lt;p&gt;</b>
<i>2361</i>&nbsp;     * Once &amp;lt;/html&amp;gt; is encountered, the Actions are no longer notified.
<b class="nc"><i>2362</i>&nbsp;     */</b>
<b class="nc"><i>2363</i>&nbsp;    public class HTMLReader extends HTMLEditorKit.ParserCallback {</b>
<b class="nc"><i>2364</i>&nbsp;</b>
<i>2365</i>&nbsp;        /**
<i>2366</i>&nbsp;         * Constructs an HTMLReader using default pop and push depth and no tag to insert.
<b class="nc"><i>2367</i>&nbsp;         *</b>
<b class="nc"><i>2368</i>&nbsp;         * @param offset the starting offset</b>
<i>2369</i>&nbsp;         */
<i>2370</i>&nbsp;        public HTMLReader(int offset) {
<b class="nc"><i>2371</i>&nbsp;            this(offset, 0, 0, null);</b>
<b class="nc"><i>2372</i>&nbsp;        }</b>
<i>2373</i>&nbsp;
<b class="nc"><i>2374</i>&nbsp;        /**</b>
<i>2375</i>&nbsp;         * Constructs an HTMLReader.
<i>2376</i>&nbsp;         *
<b class="nc"><i>2377</i>&nbsp;         * @param offset the starting offset</b>
<b class="nc"><i>2378</i>&nbsp;         * @param popDepth how many parents to ascend before insert new element</b>
<b class="nc"><i>2379</i>&nbsp;         * @param pushDepth how many parents to descend (relative to popDepth) before</b>
<b class="nc"><i>2380</i>&nbsp;         *                  inserting</b>
<i>2381</i>&nbsp;         * @param insertTag a tag to insert (may be null)
<b class="nc"><i>2382</i>&nbsp;         */</b>
<b class="nc"><i>2383</i>&nbsp;        public HTMLReader(int offset, int popDepth, int pushDepth,</b>
<b class="nc"><i>2384</i>&nbsp;                          HTML.Tag insertTag) {</b>
<i>2385</i>&nbsp;            this(offset, popDepth, pushDepth, insertTag, true, false, true);
<i>2386</i>&nbsp;        }
<b class="nc"><i>2387</i>&nbsp;</b>
<b class="nc"><i>2388</i>&nbsp;        /**</b>
<b class="nc"><i>2389</i>&nbsp;         * Generates a RuntimeException (will eventually generate</b>
<i>2390</i>&nbsp;         * a BadLocationException when API changes are alloced) if inserting
<i>2391</i>&nbsp;         * into non empty document, &lt;code&gt;insertTag&lt;/code&gt; is
<b class="nc"><i>2392</i>&nbsp;         * non-&lt;code&gt;null&lt;/code&gt;, and &lt;code&gt;offset&lt;/code&gt; is not in the body.</b>
<b class="nc"><i>2393</i>&nbsp;         */</b>
<i>2394</i>&nbsp;        // PENDING(sky): Add throws BadLocationException and remove
<i>2395</i>&nbsp;        // RuntimeException
<b class="nc"><i>2396</i>&nbsp;        HTMLReader(int offset, int popDepth, int pushDepth,</b>
<b class="nc"><i>2397</i>&nbsp;                   HTML.Tag insertTag, boolean insertInsertTag,</b>
<i>2398</i>&nbsp;                   boolean insertAfterImplied, boolean wantsTrailingNewline) {
<i>2399</i>&nbsp;            emptyDocument = (getLength() == 0);
<i>2400</i>&nbsp;            isStyleCSS = &quot;text/css&quot;.equals(getDefaultStyleSheetType());
<i>2401</i>&nbsp;            this.offset = offset;
<i>2402</i>&nbsp;            threshold = HTMLDocument.this.getTokenThreshold();
<i>2403</i>&nbsp;            tagMap = new Hashtable&lt;HTML.Tag, TagAction&gt;(57);
<i>2404</i>&nbsp;            TagAction na = new TagAction();
<i>2405</i>&nbsp;            TagAction ba = new BlockAction();
<i>2406</i>&nbsp;            TagAction pa = new ParagraphAction();
<i>2407</i>&nbsp;            TagAction ca = new CharacterAction();
<b class="nc"><i>2408</i>&nbsp;            TagAction sa = new SpecialAction();</b>
<b class="nc"><i>2409</i>&nbsp;            TagAction fa = new FormAction();</b>
<i>2410</i>&nbsp;            TagAction ha = new HiddenAction();
<b class="nc"><i>2411</i>&nbsp;            TagAction conv = new ConvertAction();</b>
<b class="nc"><i>2412</i>&nbsp;</b>
<b class="nc"><i>2413</i>&nbsp;            // register handlers for the well known tags</b>
<i>2414</i>&nbsp;            tagMap.put(HTML.Tag.A, new AnchorAction());
<b class="nc"><i>2415</i>&nbsp;            tagMap.put(HTML.Tag.ADDRESS, ca);</b>
<i>2416</i>&nbsp;            tagMap.put(HTML.Tag.APPLET, ha);
<i>2417</i>&nbsp;            tagMap.put(HTML.Tag.AREA, new AreaAction());
<i>2418</i>&nbsp;            tagMap.put(HTML.Tag.B, conv);
<i>2419</i>&nbsp;            tagMap.put(HTML.Tag.BASE, new BaseAction());
<i>2420</i>&nbsp;            tagMap.put(HTML.Tag.BASEFONT, ca);
<i>2421</i>&nbsp;            tagMap.put(HTML.Tag.BIG, ca);
<i>2422</i>&nbsp;            tagMap.put(HTML.Tag.BLOCKQUOTE, ba);
<i>2423</i>&nbsp;            tagMap.put(HTML.Tag.BODY, ba);
<i>2424</i>&nbsp;            tagMap.put(HTML.Tag.BR, sa);
<b class="nc"><i>2425</i>&nbsp;            tagMap.put(HTML.Tag.CAPTION, ba);</b>
<b class="nc"><i>2426</i>&nbsp;            tagMap.put(HTML.Tag.CENTER, ba);</b>
<i>2427</i>&nbsp;            tagMap.put(HTML.Tag.CITE, ca);
<b class="nc"><i>2428</i>&nbsp;            tagMap.put(HTML.Tag.CODE, ca);</b>
<b class="nc"><i>2429</i>&nbsp;            tagMap.put(HTML.Tag.DD, ba);</b>
<b class="nc"><i>2430</i>&nbsp;            tagMap.put(HTML.Tag.DFN, ca);</b>
<b class="nc"><i>2431</i>&nbsp;            tagMap.put(HTML.Tag.DIR, ba);</b>
<i>2432</i>&nbsp;            tagMap.put(HTML.Tag.DIV, ba);
<b class="nc"><i>2433</i>&nbsp;            tagMap.put(HTML.Tag.DL, ba);</b>
<i>2434</i>&nbsp;            tagMap.put(HTML.Tag.DT, pa);
<i>2435</i>&nbsp;            tagMap.put(HTML.Tag.EM, ca);
<i>2436</i>&nbsp;            tagMap.put(HTML.Tag.FONT, conv);
<i>2437</i>&nbsp;            tagMap.put(HTML.Tag.FORM, new FormTagAction());
<i>2438</i>&nbsp;            tagMap.put(HTML.Tag.FRAME, sa);
<i>2439</i>&nbsp;            tagMap.put(HTML.Tag.FRAMESET, ba);
<i>2440</i>&nbsp;            tagMap.put(HTML.Tag.H1, pa);
<b class="nc"><i>2441</i>&nbsp;            tagMap.put(HTML.Tag.H2, pa);</b>
<b class="nc"><i>2442</i>&nbsp;            tagMap.put(HTML.Tag.H3, pa);</b>
<i>2443</i>&nbsp;            tagMap.put(HTML.Tag.H4, pa);
<i>2444</i>&nbsp;            tagMap.put(HTML.Tag.H5, pa);
<b class="nc"><i>2445</i>&nbsp;            tagMap.put(HTML.Tag.H6, pa);</b>
<i>2446</i>&nbsp;            tagMap.put(HTML.Tag.HEAD, new HeadAction());
<b class="nc"><i>2447</i>&nbsp;            tagMap.put(HTML.Tag.HR, sa);</b>
<b class="nc"><i>2448</i>&nbsp;            tagMap.put(HTML.Tag.HTML, ba);</b>
<b class="nc"><i>2449</i>&nbsp;            tagMap.put(HTML.Tag.I, conv);</b>
<b class="nc"><i>2450</i>&nbsp;            tagMap.put(HTML.Tag.IMG, sa);</b>
<b class="nc"><i>2451</i>&nbsp;            tagMap.put(HTML.Tag.INPUT, fa);</b>
<b class="nc"><i>2452</i>&nbsp;            tagMap.put(HTML.Tag.ISINDEX, new IsindexAction());</b>
<i>2453</i>&nbsp;            tagMap.put(HTML.Tag.KBD, ca);
<i>2454</i>&nbsp;            tagMap.put(HTML.Tag.LI, ba);
<i>2455</i>&nbsp;            tagMap.put(HTML.Tag.LINK, new LinkAction());
<i>2456</i>&nbsp;            tagMap.put(HTML.Tag.MAP, new MapAction());
<i>2457</i>&nbsp;            tagMap.put(HTML.Tag.MENU, ba);
<b class="nc"><i>2458</i>&nbsp;            tagMap.put(HTML.Tag.META, new MetaAction());</b>
<b class="nc"><i>2459</i>&nbsp;            tagMap.put(HTML.Tag.NOBR, ca);</b>
<b class="nc"><i>2460</i>&nbsp;            tagMap.put(HTML.Tag.NOFRAMES, ba);</b>
<b class="nc"><i>2461</i>&nbsp;            tagMap.put(HTML.Tag.OBJECT, sa);</b>
<b class="nc"><i>2462</i>&nbsp;            tagMap.put(HTML.Tag.OL, ba);</b>
<b class="nc"><i>2463</i>&nbsp;            tagMap.put(HTML.Tag.OPTION, fa);</b>
<i>2464</i>&nbsp;            tagMap.put(HTML.Tag.P, pa);
<i>2465</i>&nbsp;            tagMap.put(HTML.Tag.PARAM, new ObjectAction());
<i>2466</i>&nbsp;            tagMap.put(HTML.Tag.PRE, new PreAction());
<i>2467</i>&nbsp;            tagMap.put(HTML.Tag.SAMP, ca);
<b class="nc"><i>2468</i>&nbsp;            tagMap.put(HTML.Tag.SCRIPT, ha);</b>
<b class="nc"><i>2469</i>&nbsp;            tagMap.put(HTML.Tag.SELECT, fa);</b>
<i>2470</i>&nbsp;            tagMap.put(HTML.Tag.SMALL, ca);
<b class="nc"><i>2471</i>&nbsp;            tagMap.put(HTML.Tag.SPAN, ca);</b>
<b class="nc"><i>2472</i>&nbsp;            tagMap.put(HTML.Tag.STRIKE, conv);</b>
<b class="nc"><i>2473</i>&nbsp;            tagMap.put(HTML.Tag.S, ca);</b>
<i>2474</i>&nbsp;            tagMap.put(HTML.Tag.STRONG, ca);
<b class="nc"><i>2475</i>&nbsp;            tagMap.put(HTML.Tag.STYLE, new StyleAction());</b>
<b class="nc"><i>2476</i>&nbsp;            tagMap.put(HTML.Tag.SUB, conv);</b>
<i>2477</i>&nbsp;            tagMap.put(HTML.Tag.SUP, conv);
<b class="nc"><i>2478</i>&nbsp;            tagMap.put(HTML.Tag.TABLE, ba);</b>
<i>2479</i>&nbsp;            tagMap.put(HTML.Tag.TD, ba);
<b class="nc"><i>2480</i>&nbsp;            tagMap.put(HTML.Tag.TEXTAREA, fa);</b>
<i>2481</i>&nbsp;            tagMap.put(HTML.Tag.TH, ba);
<b class="nc"><i>2482</i>&nbsp;            tagMap.put(HTML.Tag.TITLE, new TitleAction());</b>
<b class="nc"><i>2483</i>&nbsp;            tagMap.put(HTML.Tag.TR, ba);</b>
<b class="nc"><i>2484</i>&nbsp;            tagMap.put(HTML.Tag.TT, ca);</b>
<b class="nc"><i>2485</i>&nbsp;            tagMap.put(HTML.Tag.U, conv);</b>
<i>2486</i>&nbsp;            tagMap.put(HTML.Tag.UL, ba);
<b class="nc"><i>2487</i>&nbsp;            tagMap.put(HTML.Tag.VAR, ca);</b>
<i>2488</i>&nbsp;
<i>2489</i>&nbsp;            if (insertTag != null) {
<b class="nc"><i>2490</i>&nbsp;                this.insertTag = insertTag;</b>
<i>2491</i>&nbsp;                this.popDepth = popDepth;
<b class="nc"><i>2492</i>&nbsp;                this.pushDepth = pushDepth;</b>
<b class="nc"><i>2493</i>&nbsp;                this.insertInsertTag = insertInsertTag;</b>
<b class="nc"><i>2494</i>&nbsp;                foundInsertTag = false;</b>
<b class="nc"><i>2495</i>&nbsp;            }</b>
<i>2496</i>&nbsp;            else {
<b class="nc"><i>2497</i>&nbsp;                foundInsertTag = true;</b>
<i>2498</i>&nbsp;            }
<b class="nc"><i>2499</i>&nbsp;            if (insertAfterImplied) {</b>
<b class="nc"><i>2500</i>&nbsp;                this.popDepth = popDepth;</b>
<b class="nc"><i>2501</i>&nbsp;                this.pushDepth = pushDepth;</b>
<i>2502</i>&nbsp;                this.insertAfterImplied = true;
<i>2503</i>&nbsp;                foundInsertTag = false;
<i>2504</i>&nbsp;                midInsert = false;
<i>2505</i>&nbsp;                this.insertInsertTag = true;
<b class="nc"><i>2506</i>&nbsp;                this.wantsTrailingNewline = wantsTrailingNewline;</b>
<i>2507</i>&nbsp;            }
<i>2508</i>&nbsp;            else {
<b class="nc"><i>2509</i>&nbsp;                midInsert = (!emptyDocument &amp;&amp; insertTag == null);</b>
<b class="nc"><i>2510</i>&nbsp;                if (midInsert) {</b>
<i>2511</i>&nbsp;                    generateEndsSpecsForMidInsert();
<i>2512</i>&nbsp;                }
<i>2513</i>&nbsp;            }
<b class="nc"><i>2514</i>&nbsp;</b>
<b class="nc"><i>2515</i>&nbsp;            /**</b>
<i>2516</i>&nbsp;             * This block initializes the &lt;code&gt;inParagraph&lt;/code&gt; flag.
<b class="nc"><i>2517</i>&nbsp;             * It is left in &lt;code&gt;false&lt;/code&gt; value automatically</b>
<b class="nc"><i>2518</i>&nbsp;             * if the target document is empty or future inserts</b>
<b class="nc"><i>2519</i>&nbsp;             * were positioned into the &#39;body&#39; tag.</b>
<i>2520</i>&nbsp;             */
<b class="nc"><i>2521</i>&nbsp;            if (!emptyDocument &amp;&amp; !midInsert) {</b>
<b class="nc"><i>2522</i>&nbsp;                int targetOffset = Math.max(this.offset - 1, 0);</b>
<b class="nc"><i>2523</i>&nbsp;                Element elem =</b>
<i>2524</i>&nbsp;                        HTMLDocument.this.getCharacterElement(targetOffset);
<i>2525</i>&nbsp;                /* Going up by the left document structure path */
<i>2526</i>&nbsp;                for (int i = 0; i &lt;= this.popDepth; i++) {
<i>2527</i>&nbsp;                    elem = elem.getParentElement();
<i>2528</i>&nbsp;                }
<i>2529</i>&nbsp;                /* Going down by the right document structure path */
<i>2530</i>&nbsp;                for (int i = 0; i &lt; this.pushDepth; i++) {
<i>2531</i>&nbsp;                    int index = elem.getElementIndex(this.offset);
<i>2532</i>&nbsp;                    elem = elem.getElement(index);
<i>2533</i>&nbsp;                }
<i>2534</i>&nbsp;                AttributeSet attrs = elem.getAttributes();
<b class="nc"><i>2535</i>&nbsp;                if (attrs != null) {</b>
<b class="nc"><i>2536</i>&nbsp;                    HTML.Tag tagToInsertInto =</b>
<b class="nc"><i>2537</i>&nbsp;                            (HTML.Tag) attrs.getAttribute(StyleConstants.NameAttribute);</b>
<b class="nc"><i>2538</i>&nbsp;                    if (tagToInsertInto != null) {</b>
<b class="nc"><i>2539</i>&nbsp;                        this.inParagraph = tagToInsertInto.isParagraph();</b>
<i>2540</i>&nbsp;                    }
<i>2541</i>&nbsp;                }
<i>2542</i>&nbsp;            }
<i>2543</i>&nbsp;        }
<b class="nc"><i>2544</i>&nbsp;</b>
<i>2545</i>&nbsp;        /**
<i>2546</i>&nbsp;         * Generates an initial batch of end &lt;code&gt;ElementSpecs&lt;/code&gt;
<i>2547</i>&nbsp;         * in parseBuffer to position future inserts into the body.
<i>2548</i>&nbsp;         */
<i>2549</i>&nbsp;        private void generateEndsSpecsForMidInsert() {
<i>2550</i>&nbsp;            int           count = heightToElementWithName(HTML.Tag.BODY,
<i>2551</i>&nbsp;                                                   Math.max(0, offset - 1));
<i>2552</i>&nbsp;            boolean       joinNext = false;
<b class="nc"><i>2553</i>&nbsp;</b>
<i>2554</i>&nbsp;            if (count == -1 &amp;&amp; offset &gt; 0) {
<i>2555</i>&nbsp;                count = heightToElementWithName(HTML.Tag.BODY, offset);
<i>2556</i>&nbsp;                if (count != -1) {
<i>2557</i>&nbsp;                    // Previous isn&#39;t in body, but current is. Have to
<b class="nc"><i>2558</i>&nbsp;                    // do some end specs, followed by join next.</b>
<i>2559</i>&nbsp;                    count = depthTo(offset - 1) - 1;
<i>2560</i>&nbsp;                    joinNext = true;
<b class="nc"><i>2561</i>&nbsp;                }</b>
<b class="nc"><i>2562</i>&nbsp;            }</b>
<b class="nc"><i>2563</i>&nbsp;            if (count == -1) {</b>
<i>2564</i>&nbsp;                throw new RuntimeException(&quot;Must insert new content into body element-&quot;);
<b class="nc"><i>2565</i>&nbsp;            }</b>
<b class="nc"><i>2566</i>&nbsp;            if (count != -1) {</b>
<i>2567</i>&nbsp;                // Insert a newline, if necessary.
<i>2568</i>&nbsp;                try {
<i>2569</i>&nbsp;                    if (!joinNext &amp;&amp; offset &gt; 0 &amp;&amp;
<i>2570</i>&nbsp;                        !getText(offset - 1, 1).equals(&quot;\n&quot;)) {
<b class="nc"><i>2571</i>&nbsp;                        SimpleAttributeSet newAttrs = new SimpleAttributeSet();</b>
<b class="nc"><i>2572</i>&nbsp;                        newAttrs.addAttribute(StyleConstants.NameAttribute,</b>
<b class="nc"><i>2573</i>&nbsp;                                              HTML.Tag.CONTENT);</b>
<b class="nc"><i>2574</i>&nbsp;                        ElementSpec spec = new ElementSpec(newAttrs,</b>
<b class="nc"><i>2575</i>&nbsp;                                    ElementSpec.ContentType, NEWLINE, 0, 1);</b>
<b class="nc"><i>2576</i>&nbsp;                        parseBuffer.addElement(spec);</b>
<b class="nc"><i>2577</i>&nbsp;                    }</b>
<b class="nc"><i>2578</i>&nbsp;                    // Should never throw, but will catch anyway.</b>
<b class="nc"><i>2579</i>&nbsp;                } catch (BadLocationException ble) {}</b>
<b class="nc"><i>2580</i>&nbsp;                while (count-- &gt; 0) {</b>
<b class="nc"><i>2581</i>&nbsp;                    parseBuffer.addElement(new ElementSpec</b>
<i>2582</i>&nbsp;                                           (null, ElementSpec.EndTagType));
<b class="nc"><i>2583</i>&nbsp;                }</b>
<b class="nc"><i>2584</i>&nbsp;                if (joinNext) {</b>
<i>2585</i>&nbsp;                    ElementSpec spec = new ElementSpec(null, ElementSpec.
<b class="nc"><i>2586</i>&nbsp;                                                       StartTagType);</b>
<b class="nc"><i>2587</i>&nbsp;</b>
<i>2588</i>&nbsp;                    spec.setDirection(ElementSpec.JoinNextDirection);
<i>2589</i>&nbsp;                    parseBuffer.addElement(spec);
<b class="nc"><i>2590</i>&nbsp;                }</b>
<i>2591</i>&nbsp;            }
<b class="nc"><i>2592</i>&nbsp;            // We should probably throw an exception if (count == -1)</b>
<b class="nc"><i>2593</i>&nbsp;            // Or look for the body and reset the offset.</b>
<i>2594</i>&nbsp;        }
<i>2595</i>&nbsp;
<i>2596</i>&nbsp;        /**
<i>2597</i>&nbsp;         * @return number of parents to reach the child at offset.
<i>2598</i>&nbsp;         */
<i>2599</i>&nbsp;        private int depthTo(int offset) {
<i>2600</i>&nbsp;            Element       e = getDefaultRootElement();
<i>2601</i>&nbsp;            int           count = 0;
<i>2602</i>&nbsp;
<b class="nc"><i>2603</i>&nbsp;            while (!e.isLeaf()) {</b>
<i>2604</i>&nbsp;                count++;
<i>2605</i>&nbsp;                e = e.getElement(e.getElementIndex(offset));
<b class="nc"><i>2606</i>&nbsp;            }</b>
<b class="nc"><i>2607</i>&nbsp;            return count;</b>
<b class="nc"><i>2608</i>&nbsp;        }</b>
<i>2609</i>&nbsp;
<i>2610</i>&nbsp;        /**
<i>2611</i>&nbsp;         * @return number of parents of the leaf at &lt;code&gt;offset&lt;/code&gt;
<i>2612</i>&nbsp;         *         until a parent with name, &lt;code&gt;name&lt;/code&gt; has been
<b class="nc"><i>2613</i>&nbsp;         *         found. -1 indicates no matching parent with</b>
<i>2614</i>&nbsp;         *         &lt;code&gt;name&lt;/code&gt;.
<i>2615</i>&nbsp;         */
<i>2616</i>&nbsp;        private int heightToElementWithName(Object name, int offset) {
<b class="nc"><i>2617</i>&nbsp;            Element       e = getCharacterElement(offset).getParentElement();</b>
<b class="nc"><i>2618</i>&nbsp;            int           count = 0;</b>
<i>2619</i>&nbsp;
<b class="nc"><i>2620</i>&nbsp;            while (e != null &amp;&amp; e.getAttributes().getAttribute</b>
<i>2621</i>&nbsp;                   (StyleConstants.NameAttribute) != name) {
<b class="nc"><i>2622</i>&nbsp;                count++;</b>
<b class="nc"><i>2623</i>&nbsp;                e = e.getParentElement();</b>
<b class="nc"><i>2624</i>&nbsp;            }</b>
<b class="nc"><i>2625</i>&nbsp;            return (e == null) ? -1 : count;</b>
<b class="nc"><i>2626</i>&nbsp;        }</b>
<i>2627</i>&nbsp;
<b class="nc"><i>2628</i>&nbsp;        /**</b>
<i>2629</i>&nbsp;         * This will make sure there aren&#39;t two BODYs (the second is
<b class="nc"><i>2630</i>&nbsp;         * typically created when you do a remove all, and then an insert).</b>
<i>2631</i>&nbsp;         */
<b class="nc"><i>2632</i>&nbsp;        private void adjustEndElement() {</b>
<b class="nc"><i>2633</i>&nbsp;            int length = getLength();</b>
<i>2634</i>&nbsp;            if (length == 0) {
<i>2635</i>&nbsp;                return;
<i>2636</i>&nbsp;            }
<i>2637</i>&nbsp;            obtainLock();
<b class="nc"><i>2638</i>&nbsp;            try {</b>
<b class="nc"><i>2639</i>&nbsp;                Element[] pPath = getPathTo(length - 1);</b>
<i>2640</i>&nbsp;                int pLength = pPath.length;
<i>2641</i>&nbsp;                if (pLength &gt; 1 &amp;&amp; pPath[1].getAttributes().getAttribute
<b class="nc"><i>2642</i>&nbsp;                         (StyleConstants.NameAttribute) == HTML.Tag.BODY &amp;&amp;</b>
<b class="nc"><i>2643</i>&nbsp;                         pPath[1].getEndOffset() == length) {</b>
<b class="nc"><i>2644</i>&nbsp;                    String lastText = getText(length - 1, 1);</b>
<i>2645</i>&nbsp;                    DefaultDocumentEvent event;
<i>2646</i>&nbsp;                    Element[] added;
<b class="nc"><i>2647</i>&nbsp;                    Element[] removed;</b>
<b class="nc"><i>2648</i>&nbsp;                    int index;</b>
<i>2649</i>&nbsp;                    // Remove the fake second body.
<i>2650</i>&nbsp;                    added = new Element[0];
<i>2651</i>&nbsp;                    removed = new Element[1];
<b class="nc"><i>2652</i>&nbsp;                    index = pPath[0].getElementIndex(length);</b>
<i>2653</i>&nbsp;                    removed[0] = pPath[0].getElement(index);
<i>2654</i>&nbsp;                    ((BranchElement)pPath[0]).replace(index, 1, added);
<b class="nc"><i>2655</i>&nbsp;                    ElementEdit firstEdit = new ElementEdit(pPath[0], index,</b>
<b class="nc"><i>2656</i>&nbsp;                                                            removed, added);</b>
<b class="nc"><i>2657</i>&nbsp;</b>
<i>2658</i>&nbsp;                    // Insert a new element to represent the end that the
<i>2659</i>&nbsp;                    // second body was representing.
<b class="nc"><i>2660</i>&nbsp;                    SimpleAttributeSet sas = new SimpleAttributeSet();</b>
<b class="nc"><i>2661</i>&nbsp;                    sas.addAttribute(StyleConstants.NameAttribute,</b>
<b class="nc"><i>2662</i>&nbsp;                                         HTML.Tag.CONTENT);</b>
<b class="nc"><i>2663</i>&nbsp;                    sas.addAttribute(IMPLIED_CR, Boolean.TRUE);</b>
<i>2664</i>&nbsp;                    added = new Element[1];
<i>2665</i>&nbsp;                    added[0] = createLeafElement(pPath[pLength - 1],
<i>2666</i>&nbsp;                                                     sas, length, length + 1);
<i>2667</i>&nbsp;                    index = pPath[pLength - 1].getElementCount();
<i>2668</i>&nbsp;                    ((BranchElement)pPath[pLength - 1]).replace(index, 0,
<i>2669</i>&nbsp;                                                                added);
<i>2670</i>&nbsp;                    event = new DefaultDocumentEvent(length, 1,
<i>2671</i>&nbsp;                                            DocumentEvent.EventType.CHANGE);
<b class="nc"><i>2672</i>&nbsp;                    event.addEdit(new ElementEdit(pPath[pLength - 1],</b>
<b class="nc"><i>2673</i>&nbsp;                                         index, new Element[0], added));</b>
<i>2674</i>&nbsp;                    event.addEdit(firstEdit);
<i>2675</i>&nbsp;                    event.end();
<i>2676</i>&nbsp;                    fireChangedUpdate(event);
<b class="nc"><i>2677</i>&nbsp;                    fireUndoableEditUpdate(new UndoableEditEvent(this, event));</b>
<b class="nc"><i>2678</i>&nbsp;</b>
<b class="nc"><i>2679</i>&nbsp;                    if (lastText.equals(&quot;\n&quot;)) {</b>
<i>2680</i>&nbsp;                        // We now have two \n&#39;s, one part of the Document.
<b class="nc"><i>2681</i>&nbsp;                        // We need to remove one</b>
<i>2682</i>&nbsp;                        event = new DefaultDocumentEvent(length - 1, 1,
<i>2683</i>&nbsp;                                           DocumentEvent.EventType.REMOVE);
<i>2684</i>&nbsp;                        removeUpdate(event);
<i>2685</i>&nbsp;                        UndoableEdit u = getContent().remove(length - 1, 1);
<i>2686</i>&nbsp;                        if (u != null) {
<i>2687</i>&nbsp;                            event.addEdit(u);
<i>2688</i>&nbsp;                        }
<b class="nc"><i>2689</i>&nbsp;                        postRemoveUpdate(event);</b>
<i>2690</i>&nbsp;                        // Mark the edit as done.
<i>2691</i>&nbsp;                        event.end();
<b class="nc"><i>2692</i>&nbsp;                        fireRemoveUpdate(event);</b>
<b class="nc"><i>2693</i>&nbsp;                        fireUndoableEditUpdate(new UndoableEditEvent(</b>
<i>2694</i>&nbsp;                                               this, event));
<b class="nc"><i>2695</i>&nbsp;                    }</b>
<b class="nc"><i>2696</i>&nbsp;                }</b>
<b class="nc"><i>2697</i>&nbsp;            }</b>
<b class="nc"><i>2698</i>&nbsp;            catch (BadLocationException ble) {</b>
<i>2699</i>&nbsp;            }
<i>2700</i>&nbsp;            finally {
<b class="nc"><i>2701</i>&nbsp;                releaseLock();</b>
<b class="nc"><i>2702</i>&nbsp;            }</b>
<b class="nc"><i>2703</i>&nbsp;        }</b>
<i>2704</i>&nbsp;
<i>2705</i>&nbsp;        private Element[] getPathTo(int offset) {
<i>2706</i>&nbsp;            Stack&lt;Element&gt; elements = new Stack&lt;Element&gt;();
<i>2707</i>&nbsp;            Element e = getDefaultRootElement();
<i>2708</i>&nbsp;            int index;
<i>2709</i>&nbsp;            while (!e.isLeaf()) {
<i>2710</i>&nbsp;                elements.push(e);
<i>2711</i>&nbsp;                e = e.getElement(e.getElementIndex(offset));
<b class="nc"><i>2712</i>&nbsp;            }</b>
<i>2713</i>&nbsp;            Element[] retValue = new Element[elements.size()];
<i>2714</i>&nbsp;            elements.copyInto(retValue);
<i>2715</i>&nbsp;            return retValue;
<b class="nc"><i>2716</i>&nbsp;        }</b>
<i>2717</i>&nbsp;
<b class="nc"><i>2718</i>&nbsp;        // -- HTMLEditorKit.ParserCallback methods --------------------</b>
<b class="nc"><i>2719</i>&nbsp;</b>
<b class="nc"><i>2720</i>&nbsp;        /**</b>
<b class="nc"><i>2721</i>&nbsp;         * The last method called on the reader.  It allows</b>
<b class="nc"><i>2722</i>&nbsp;         * any pending changes to be flushed into the document.</b>
<i>2723</i>&nbsp;         * Since this is currently loading synchronously, the entire
<b class="nc"><i>2724</i>&nbsp;         * set of changes are pushed in at this point.</b>
<i>2725</i>&nbsp;         */
<i>2726</i>&nbsp;        public void flush() throws BadLocationException {
<b class="nc"><i>2727</i>&nbsp;            if (emptyDocument &amp;&amp; !insertAfterImplied) {</b>
<b class="nc"><i>2728</i>&nbsp;                if (HTMLDocument.this.getLength() &gt; 0 ||</b>
<b class="nc"><i>2729</i>&nbsp;                                      parseBuffer.size() &gt; 0) {</b>
<b class="nc"><i>2730</i>&nbsp;                    flushBuffer(true);</b>
<i>2731</i>&nbsp;                    adjustEndElement();
<b class="nc"><i>2732</i>&nbsp;                }</b>
<i>2733</i>&nbsp;                // We won&#39;t insert when
<b class="nc"><i>2734</i>&nbsp;            }</b>
<i>2735</i>&nbsp;            else {
<i>2736</i>&nbsp;                flushBuffer(true);
<i>2737</i>&nbsp;            }
<i>2738</i>&nbsp;        }
<i>2739</i>&nbsp;
<i>2740</i>&nbsp;        /**
<i>2741</i>&nbsp;         * Called by the parser to indicate a block of text was
<i>2742</i>&nbsp;         * encountered.
<i>2743</i>&nbsp;         */
<i>2744</i>&nbsp;        public void handleText(char[] data, int pos) {
<i>2745</i>&nbsp;            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {
<i>2746</i>&nbsp;                return;
<b class="nc"><i>2747</i>&nbsp;            }</b>
<b class="nc"><i>2748</i>&nbsp;</b>
<i>2749</i>&nbsp;            // see if complex glyph layout support is needed
<i>2750</i>&nbsp;            if(HTMLDocument.this.getProperty(I18NProperty).equals( Boolean.FALSE ) ) {
<i>2751</i>&nbsp;                // if a default direction of right-to-left has been specified,
<i>2752</i>&nbsp;                // we want complex layout even if the text is all left to right.
<i>2753</i>&nbsp;                Object d = getProperty(TextAttribute.RUN_DIRECTION);
<i>2754</i>&nbsp;                if ((d != null) &amp;&amp; (d.equals(TextAttribute.RUN_DIRECTION_RTL))) {
<i>2755</i>&nbsp;                    HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);
<i>2756</i>&nbsp;                } else {
<i>2757</i>&nbsp;                    if (SwingUtilities2.isComplexLayout(data, 0, data.length)) {
<i>2758</i>&nbsp;                        HTMLDocument.this.putProperty( I18NProperty, Boolean.TRUE);
<i>2759</i>&nbsp;                    }
<i>2760</i>&nbsp;                }
<i>2761</i>&nbsp;            }
<b class="nc"><i>2762</i>&nbsp;</b>
<i>2763</i>&nbsp;            if (inTextArea) {
<i>2764</i>&nbsp;                textAreaContent(data);
<i>2765</i>&nbsp;            } else if (inPre) {
<i>2766</i>&nbsp;                preContent(data);
<i>2767</i>&nbsp;            } else if (inTitle) {
<i>2768</i>&nbsp;                putProperty(Document.TitleProperty, new String(data));
<i>2769</i>&nbsp;            } else if (option != null) {
<i>2770</i>&nbsp;                option.setLabel(new String(data));
<b class="nc"><i>2771</i>&nbsp;            } else if (inStyle) {</b>
<i>2772</i>&nbsp;                if (styles != null) {
<i>2773</i>&nbsp;                    styles.addElement(new String(data));
<i>2774</i>&nbsp;                }
<i>2775</i>&nbsp;            } else if (inBlock &gt; 0) {
<i>2776</i>&nbsp;                if (!foundInsertTag &amp;&amp; insertAfterImplied) {
<i>2777</i>&nbsp;                    // Assume content should be added.
<i>2778</i>&nbsp;                    foundInsertTag(false);
<i>2779</i>&nbsp;                    foundInsertTag = true;
<i>2780</i>&nbsp;                    // If content is added directly to the body, it should
<i>2781</i>&nbsp;                    // be wrapped by p-implied.
<i>2782</i>&nbsp;                    inParagraph = impliedP = !insertInBody;
<i>2783</i>&nbsp;                }
<i>2784</i>&nbsp;                if (data.length &gt;= 1) {
<i>2785</i>&nbsp;                    addContent(data, 0, data.length);
<i>2786</i>&nbsp;                }
<i>2787</i>&nbsp;            }
<i>2788</i>&nbsp;        }
<i>2789</i>&nbsp;
<i>2790</i>&nbsp;        /**
<i>2791</i>&nbsp;         * Callback from the parser.  Route to the appropriate
<i>2792</i>&nbsp;         * handler for the tag.
<i>2793</i>&nbsp;         */
<i>2794</i>&nbsp;        public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) {
<i>2795</i>&nbsp;            if (receivedEndHTML) {
<i>2796</i>&nbsp;                return;
<b class="nc"><i>2797</i>&nbsp;            }</b>
<i>2798</i>&nbsp;            if (midInsert &amp;&amp; !inBody) {
<i>2799</i>&nbsp;                if (t == HTML.Tag.BODY) {
<b class="nc"><i>2800</i>&nbsp;                    inBody = true;</b>
<i>2801</i>&nbsp;                    // Increment inBlock since we know we are in the body,
<i>2802</i>&nbsp;                    // this is needed incase an implied-p is needed. If
<i>2803</i>&nbsp;                    // inBlock isn&#39;t incremented, and an implied-p is
<b class="nc"><i>2804</i>&nbsp;                    // encountered, addContent won&#39;t be called!</b>
<i>2805</i>&nbsp;                    inBlock++;
<i>2806</i>&nbsp;                }
<i>2807</i>&nbsp;                return;
<i>2808</i>&nbsp;            }
<i>2809</i>&nbsp;            if (!inBody &amp;&amp; t == HTML.Tag.BODY) {
<i>2810</i>&nbsp;                inBody = true;
<i>2811</i>&nbsp;            }
<i>2812</i>&nbsp;            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {
<b class="nc"><i>2813</i>&nbsp;                // Map the style attributes.</b>
<i>2814</i>&nbsp;                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);
<b class="nc"><i>2815</i>&nbsp;                a.removeAttribute(HTML.Attribute.STYLE);</b>
<i>2816</i>&nbsp;                styleAttributes = getStyleSheet().getDeclaration(decl);
<i>2817</i>&nbsp;                a.addAttributes(styleAttributes);
<i>2818</i>&nbsp;            }
<i>2819</i>&nbsp;            else {
<i>2820</i>&nbsp;                styleAttributes = null;
<i>2821</i>&nbsp;            }
<b class="nc"><i>2822</i>&nbsp;            TagAction action = tagMap.get(t);</b>
<i>2823</i>&nbsp;
<i>2824</i>&nbsp;            if (action != null) {
<i>2825</i>&nbsp;                action.start(t, a);
<b class="nc"><i>2826</i>&nbsp;            }</b>
<i>2827</i>&nbsp;        }
<i>2828</i>&nbsp;
<b class="nc"><i>2829</i>&nbsp;        public void handleComment(char[] data, int pos) {</b>
<i>2830</i>&nbsp;            if (receivedEndHTML) {
<i>2831</i>&nbsp;                addExternalComment(new String(data));
<i>2832</i>&nbsp;                return;
<i>2833</i>&nbsp;            }
<b class="nc"><i>2834</i>&nbsp;            if (inStyle) {</b>
<i>2835</i>&nbsp;                if (styles != null) {
<i>2836</i>&nbsp;                    styles.addElement(new String(data));
<b class="nc"><i>2837</i>&nbsp;                }</b>
<b class="nc"><i>2838</i>&nbsp;            }</b>
<i>2839</i>&nbsp;            else if (getPreservesUnknownTags()) {
<i>2840</i>&nbsp;                if (inBlock == 0 &amp;&amp; (foundInsertTag ||
<i>2841</i>&nbsp;                                     insertTag != HTML.Tag.COMMENT)) {
<b class="nc"><i>2842</i>&nbsp;                    // Comment outside of body, will not be able to show it,</b>
<b class="nc"><i>2843</i>&nbsp;                    // but can add it as a property on the Document.</b>
<i>2844</i>&nbsp;                    addExternalComment(new String(data));
<i>2845</i>&nbsp;                    return;
<i>2846</i>&nbsp;                }
<b class="nc"><i>2847</i>&nbsp;                SimpleAttributeSet sas = new SimpleAttributeSet();</b>
<i>2848</i>&nbsp;                sas.addAttribute(HTML.Attribute.COMMENT, new String(data));
<i>2849</i>&nbsp;                addSpecialElement(HTML.Tag.COMMENT, sas);
<b class="nc"><i>2850</i>&nbsp;            }</b>
<i>2851</i>&nbsp;
<i>2852</i>&nbsp;            TagAction action = tagMap.get(HTML.Tag.COMMENT);
<i>2853</i>&nbsp;            if (action != null) {
<i>2854</i>&nbsp;                action.start(HTML.Tag.COMMENT, new SimpleAttributeSet());
<b class="nc"><i>2855</i>&nbsp;                action.end(HTML.Tag.COMMENT);</b>
<i>2856</i>&nbsp;            }
<i>2857</i>&nbsp;        }
<b class="nc"><i>2858</i>&nbsp;</b>
<b class="nc"><i>2859</i>&nbsp;        /**</b>
<b class="nc"><i>2860</i>&nbsp;         * Adds the comment &lt;code&gt;comment&lt;/code&gt; to the set of comments</b>
<i>2861</i>&nbsp;         * maintained outside of the scope of elements.
<i>2862</i>&nbsp;         */
<i>2863</i>&nbsp;        private void addExternalComment(String comment) {
<i>2864</i>&nbsp;            Object comments = getProperty(AdditionalComments);
<i>2865</i>&nbsp;            if (comments != null &amp;&amp; !(comments instanceof Vector)) {
<b class="nc"><i>2866</i>&nbsp;                // No place to put comment.</b>
<i>2867</i>&nbsp;                return;
<i>2868</i>&nbsp;            }
<b class="nc"><i>2869</i>&nbsp;            if (comments == null) {</b>
<i>2870</i>&nbsp;                comments = new Vector&lt;&gt;();
<i>2871</i>&nbsp;                putProperty(AdditionalComments, comments);
<i>2872</i>&nbsp;            }
<b class="nc"><i>2873</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)</b>
<b class="nc"><i>2874</i>&nbsp;            Vector&lt;Object&gt; v = (Vector&lt;Object&gt;)comments;</b>
<b class="nc"><i>2875</i>&nbsp;            v.addElement(comment);</b>
<b class="nc"><i>2876</i>&nbsp;        }</b>
<i>2877</i>&nbsp;
<i>2878</i>&nbsp;        /**
<i>2879</i>&nbsp;         * Callback from the parser.  Route to the appropriate
<i>2880</i>&nbsp;         * handler for the tag.
<b class="nc"><i>2881</i>&nbsp;         */</b>
<i>2882</i>&nbsp;        public void handleEndTag(HTML.Tag t, int pos) {
<b class="nc"><i>2883</i>&nbsp;            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {</b>
<i>2884</i>&nbsp;                return;
<b class="nc"><i>2885</i>&nbsp;            }</b>
<i>2886</i>&nbsp;            if (t == HTML.Tag.HTML) {
<i>2887</i>&nbsp;                receivedEndHTML = true;
<i>2888</i>&nbsp;            }
<i>2889</i>&nbsp;            if (t == HTML.Tag.BODY) {
<i>2890</i>&nbsp;                inBody = false;
<i>2891</i>&nbsp;                if (midInsert) {
<i>2892</i>&nbsp;                    inBlock--;
<i>2893</i>&nbsp;                }
<b class="nc"><i>2894</i>&nbsp;            }</b>
<i>2895</i>&nbsp;            TagAction action = tagMap.get(t);
<i>2896</i>&nbsp;            if (action != null) {
<b class="nc"><i>2897</i>&nbsp;                action.end(t);</b>
<b class="nc"><i>2898</i>&nbsp;            }</b>
<b class="nc"><i>2899</i>&nbsp;        }</b>
<b class="nc"><i>2900</i>&nbsp;</b>
<b class="nc"><i>2901</i>&nbsp;        /**</b>
<b class="nc"><i>2902</i>&nbsp;         * Callback from the parser.  Route to the appropriate</b>
<b class="nc"><i>2903</i>&nbsp;         * handler for the tag.</b>
<b class="nc"><i>2904</i>&nbsp;         */</b>
<b class="nc"><i>2905</i>&nbsp;        public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos) {</b>
<b class="nc"><i>2906</i>&nbsp;            if (receivedEndHTML || (midInsert &amp;&amp; !inBody)) {</b>
<b class="nc"><i>2907</i>&nbsp;                return;</b>
<b class="nc"><i>2908</i>&nbsp;            }</b>
<b class="nc"><i>2909</i>&nbsp;</b>
<i>2910</i>&nbsp;            if (isStyleCSS &amp;&amp; a.isDefined(HTML.Attribute.STYLE)) {
<i>2911</i>&nbsp;                // Map the style attributes.
<b class="nc"><i>2912</i>&nbsp;                String decl = (String)a.getAttribute(HTML.Attribute.STYLE);</b>
<i>2913</i>&nbsp;                a.removeAttribute(HTML.Attribute.STYLE);
<i>2914</i>&nbsp;                styleAttributes = getStyleSheet().getDeclaration(decl);
<i>2915</i>&nbsp;                a.addAttributes(styleAttributes);
<b class="nc"><i>2916</i>&nbsp;            }</b>
<i>2917</i>&nbsp;            else {
<i>2918</i>&nbsp;                styleAttributes = null;
<i>2919</i>&nbsp;            }
<i>2920</i>&nbsp;
<i>2921</i>&nbsp;            TagAction action = tagMap.get(t);
<i>2922</i>&nbsp;            if (action != null) {
<i>2923</i>&nbsp;                action.start(t, a);
<i>2924</i>&nbsp;                action.end(t);
<i>2925</i>&nbsp;            }
<i>2926</i>&nbsp;            else if (getPreservesUnknownTags()) {
<b class="nc"><i>2927</i>&nbsp;                // unknown tag, only add if should preserve it.</b>
<i>2928</i>&nbsp;                addSpecialElement(t, a);
<i>2929</i>&nbsp;            }
<b class="nc"><i>2930</i>&nbsp;        }</b>
<i>2931</i>&nbsp;
<i>2932</i>&nbsp;        /**
<i>2933</i>&nbsp;         * This is invoked after the stream has been parsed, but before
<b class="nc"><i>2934</i>&nbsp;         * &lt;code&gt;flush&lt;/code&gt;. &lt;code&gt;eol&lt;/code&gt; will be one of \n, \r</b>
<i>2935</i>&nbsp;         * or \r\n, which ever is encountered the most in parsing the
<b class="nc"><i>2936</i>&nbsp;         * stream.</b>
<b class="nc"><i>2937</i>&nbsp;         *</b>
<b class="nc"><i>2938</i>&nbsp;         * @since 1.3</b>
<i>2939</i>&nbsp;         */
<i>2940</i>&nbsp;        public void handleEndOfLineString(String eol) {
<i>2941</i>&nbsp;            if (emptyDocument &amp;&amp; eol != null) {
<i>2942</i>&nbsp;                putProperty(DefaultEditorKit.EndOfLineStringProperty,
<b class="nc"><i>2943</i>&nbsp;                            eol);</b>
<i>2944</i>&nbsp;            }
<b class="nc"><i>2945</i>&nbsp;        }</b>
<b class="nc"><i>2946</i>&nbsp;</b>
<b class="nc"><i>2947</i>&nbsp;        // ---- tag handling support ------------------------------</b>
<b class="nc"><i>2948</i>&nbsp;</b>
<b class="nc"><i>2949</i>&nbsp;        /**</b>
<b class="nc"><i>2950</i>&nbsp;         * Registers a handler for the given tag.  By default</b>
<b class="nc"><i>2951</i>&nbsp;         * all of the well-known tags will have been registered.</b>
<b class="nc"><i>2952</i>&nbsp;         * This can be used to change the handling of a particular</b>
<b class="nc"><i>2953</i>&nbsp;         * tag or to add support for custom tags.</b>
<i>2954</i>&nbsp;         *
<i>2955</i>&nbsp;         * @param t an HTML tag
<i>2956</i>&nbsp;         * @param a tag action handler
<i>2957</i>&nbsp;         */
<b class="nc"><i>2958</i>&nbsp;        protected void registerTag(HTML.Tag t, TagAction a) {</b>
<b class="nc"><i>2959</i>&nbsp;            tagMap.put(t, a);</b>
<b class="nc"><i>2960</i>&nbsp;        }</b>
<b class="nc"><i>2961</i>&nbsp;</b>
<b class="nc"><i>2962</i>&nbsp;        /**</b>
<i>2963</i>&nbsp;         * An action to be performed in response
<b class="nc"><i>2964</i>&nbsp;         * to parsing a tag.  This allows customization</b>
<b class="nc"><i>2965</i>&nbsp;         * of how each tag is handled and avoids a large</b>
<b class="nc"><i>2966</i>&nbsp;         * switch statement.</b>
<i>2967</i>&nbsp;         */
<i>2968</i>&nbsp;        public class TagAction {
<i>2969</i>&nbsp;
<b class="nc"><i>2970</i>&nbsp;            /**</b>
<i>2971</i>&nbsp;             * Called when a start tag is seen for the
<b class="nc"><i>2972</i>&nbsp;             * type of tag this action was registered</b>
<i>2973</i>&nbsp;             * to.  The tag argument indicates the actual
<b class="nc"><i>2974</i>&nbsp;             * tag for those actions that are shared across</b>
<b class="nc"><i>2975</i>&nbsp;             * many tags.  By default this does nothing and</b>
<i>2976</i>&nbsp;             * completely ignores the tag.
<i>2977</i>&nbsp;             *
<i>2978</i>&nbsp;             * @param t the HTML tag
<i>2979</i>&nbsp;             * @param a the attributes
<b class="nc"><i>2980</i>&nbsp;             */</b>
<i>2981</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>2982</i>&nbsp;            }
<i>2983</i>&nbsp;
<i>2984</i>&nbsp;            /**
<b class="nc"><i>2985</i>&nbsp;             * Called when an end tag is seen for the</b>
<b class="nc"><i>2986</i>&nbsp;             * type of tag this action was registered</b>
<b class="nc"><i>2987</i>&nbsp;             * to.  The tag argument indicates the actual</b>
<i>2988</i>&nbsp;             * tag for those actions that are shared across
<i>2989</i>&nbsp;             * many tags.  By default this does nothing and
<i>2990</i>&nbsp;             * completely ignores the tag.
<i>2991</i>&nbsp;             *
<i>2992</i>&nbsp;             * @param t the HTML tag
<b class="nc"><i>2993</i>&nbsp;             */</b>
<b class="nc"><i>2994</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>2995</i>&nbsp;            }</b>
<b class="nc"><i>2996</i>&nbsp;</b>
<b class="nc"><i>2997</i>&nbsp;        }</b>
<b class="nc"><i>2998</i>&nbsp;</b>
<b class="nc"><i>2999</i>&nbsp;        /**</b>
<b class="nc"><i>3000</i>&nbsp;         * Action assigned by default to handle the Block task of the reader.</b>
<i>3001</i>&nbsp;         */
<i>3002</i>&nbsp;        public class BlockAction extends TagAction {
<b class="nc"><i>3003</i>&nbsp;</b>
<i>3004</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<b class="nc"><i>3005</i>&nbsp;                blockOpen(t, attr);</b>
<b class="nc"><i>3006</i>&nbsp;            }</b>
<b class="nc"><i>3007</i>&nbsp;</b>
<b class="nc"><i>3008</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>3009</i>&nbsp;                blockClose(t);</b>
<b class="nc"><i>3010</i>&nbsp;            }</b>
<b class="nc"><i>3011</i>&nbsp;        }</b>
<b class="nc"><i>3012</i>&nbsp;</b>
<b class="nc"><i>3013</i>&nbsp;</b>
<i>3014</i>&nbsp;        /**
<i>3015</i>&nbsp;         * Action used for the actual element form tag. This is named such
<i>3016</i>&nbsp;         * as there was already a public class named FormAction.
<i>3017</i>&nbsp;         */
<i>3018</i>&nbsp;        private class FormTagAction extends BlockAction {
<i>3019</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<i>3020</i>&nbsp;                super.start(t, attr);
<i>3021</i>&nbsp;                // initialize a ButtonGroupsMap when
<i>3022</i>&nbsp;                // FORM tag is encountered.  This will
<i>3023</i>&nbsp;                // be used for any radio buttons that
<i>3024</i>&nbsp;                // might be defined in the FORM.
<i>3025</i>&nbsp;                // for new group new ButtonGroup will be created (fix for 4529702)
<b class="nc"><i>3026</i>&nbsp;                // group name is a key in radioButtonGroupsMap</b>
<i>3027</i>&nbsp;                radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();
<i>3028</i>&nbsp;            }
<b class="nc"><i>3029</i>&nbsp;</b>
<b class="nc"><i>3030</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>3031</i>&nbsp;                super.end(t);</b>
<b class="nc"><i>3032</i>&nbsp;                // reset the button group to null since</b>
<b class="nc"><i>3033</i>&nbsp;                // the form has ended.</b>
<b class="nc"><i>3034</i>&nbsp;                radioButtonGroupsMap = null;</b>
<b class="nc"><i>3035</i>&nbsp;            }</b>
<i>3036</i>&nbsp;        }
<b class="nc"><i>3037</i>&nbsp;</b>
<b class="nc"><i>3038</i>&nbsp;</b>
<i>3039</i>&nbsp;        /**
<i>3040</i>&nbsp;         * Action assigned by default to handle the Paragraph task of the reader.
<b class="nc"><i>3041</i>&nbsp;         */</b>
<i>3042</i>&nbsp;        public class ParagraphAction extends BlockAction {
<i>3043</i>&nbsp;
<i>3044</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<b class="nc"><i>3045</i>&nbsp;                super.start(t, a);</b>
<i>3046</i>&nbsp;                inParagraph = true;
<i>3047</i>&nbsp;            }
<b class="nc"><i>3048</i>&nbsp;</b>
<b class="nc"><i>3049</i>&nbsp;            public void end(HTML.Tag t) {</b>
<i>3050</i>&nbsp;                super.end(t);
<i>3051</i>&nbsp;                inParagraph = false;
<i>3052</i>&nbsp;            }
<i>3053</i>&nbsp;        }
<i>3054</i>&nbsp;
<i>3055</i>&nbsp;        /**
<i>3056</i>&nbsp;         * Action assigned by default to handle the Special task of the reader.
<b class="nc"><i>3057</i>&nbsp;         */</b>
<i>3058</i>&nbsp;        public class SpecialAction extends TagAction {
<i>3059</i>&nbsp;
<b class="nc"><i>3060</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {</b>
<b class="nc"><i>3061</i>&nbsp;                addSpecialElement(t, a);</b>
<i>3062</i>&nbsp;            }
<i>3063</i>&nbsp;
<i>3064</i>&nbsp;        }
<i>3065</i>&nbsp;
<i>3066</i>&nbsp;        /**
<i>3067</i>&nbsp;         * Action assigned by default to handle the Isindex task of the reader.
<i>3068</i>&nbsp;         */
<i>3069</i>&nbsp;        public class IsindexAction extends TagAction {
<b class="nc"><i>3070</i>&nbsp;</b>
<i>3071</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>3072</i>&nbsp;                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
<b class="nc"><i>3073</i>&nbsp;                addSpecialElement(t, a);</b>
<b class="nc"><i>3074</i>&nbsp;                blockClose(HTML.Tag.IMPLIED);</b>
<b class="nc"><i>3075</i>&nbsp;            }</b>
<i>3076</i>&nbsp;
<b class="nc"><i>3077</i>&nbsp;        }</b>
<b class="nc"><i>3078</i>&nbsp;</b>
<b class="nc"><i>3079</i>&nbsp;</b>
<i>3080</i>&nbsp;        /**
<i>3081</i>&nbsp;         * Action assigned by default to handle the Hidden task of the reader.
<i>3082</i>&nbsp;         */
<i>3083</i>&nbsp;        public class HiddenAction extends TagAction {
<b class="nc"><i>3084</i>&nbsp;</b>
<i>3085</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>3086</i>&nbsp;                addSpecialElement(t, a);
<i>3087</i>&nbsp;            }
<b class="nc"><i>3088</i>&nbsp;</b>
<i>3089</i>&nbsp;            public void end(HTML.Tag t) {
<i>3090</i>&nbsp;                if (!isEmpty(t)) {
<i>3091</i>&nbsp;                    MutableAttributeSet a = new SimpleAttributeSet();
<i>3092</i>&nbsp;                    a.addAttribute(HTML.Attribute.ENDTAG, &quot;true&quot;);
<b class="nc"><i>3093</i>&nbsp;                    addSpecialElement(t, a);</b>
<i>3094</i>&nbsp;                }
<i>3095</i>&nbsp;            }
<b class="nc"><i>3096</i>&nbsp;</b>
<b class="nc"><i>3097</i>&nbsp;            boolean isEmpty(HTML.Tag t) {</b>
<b class="nc"><i>3098</i>&nbsp;                if (t == HTML.Tag.APPLET ||</b>
<b class="nc"><i>3099</i>&nbsp;                    t == HTML.Tag.SCRIPT) {</b>
<i>3100</i>&nbsp;                    return false;
<i>3101</i>&nbsp;                }
<i>3102</i>&nbsp;                return true;
<b class="nc"><i>3103</i>&nbsp;            }</b>
<i>3104</i>&nbsp;        }
<i>3105</i>&nbsp;
<b class="nc"><i>3106</i>&nbsp;</b>
<b class="nc"><i>3107</i>&nbsp;        /**</b>
<i>3108</i>&nbsp;         * Subclass of HiddenAction to set the content type for style sheets,
<i>3109</i>&nbsp;         * and to set the name of the default style sheet.
<i>3110</i>&nbsp;         */
<b class="nc"><i>3111</i>&nbsp;        class MetaAction extends HiddenAction {</b>
<i>3112</i>&nbsp;
<i>3113</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<b class="nc"><i>3114</i>&nbsp;                Object equiv = a.getAttribute(HTML.Attribute.HTTPEQUIV);</b>
<b class="nc"><i>3115</i>&nbsp;                if (equiv != null) {</b>
<i>3116</i>&nbsp;                    equiv = ((String)equiv).toLowerCase();
<i>3117</i>&nbsp;                    if (equiv.equals(&quot;content-style-type&quot;)) {
<i>3118</i>&nbsp;                        String value = (String)a.getAttribute
<i>3119</i>&nbsp;                                       (HTML.Attribute.CONTENT);
<b class="nc"><i>3120</i>&nbsp;                        setDefaultStyleSheetType(value);</b>
<b class="nc"><i>3121</i>&nbsp;                        isStyleCSS = &quot;text/css&quot;.equals</b>
<b class="nc"><i>3122</i>&nbsp;                                      (getDefaultStyleSheetType());</b>
<b class="nc"><i>3123</i>&nbsp;                    }</b>
<i>3124</i>&nbsp;                    else if (equiv.equals(&quot;default-style&quot;)) {
<i>3125</i>&nbsp;                        defaultStyle = (String)a.getAttribute
<b class="nc"><i>3126</i>&nbsp;                                       (HTML.Attribute.CONTENT);</b>
<i>3127</i>&nbsp;                    }
<i>3128</i>&nbsp;                }
<i>3129</i>&nbsp;                super.start(t, a);
<b class="nc"><i>3130</i>&nbsp;            }</b>
<b class="nc"><i>3131</i>&nbsp;</b>
<i>3132</i>&nbsp;            boolean isEmpty(HTML.Tag t) {
<b class="nc"><i>3133</i>&nbsp;                return true;</b>
<b class="nc"><i>3134</i>&nbsp;            }</b>
<b class="nc"><i>3135</i>&nbsp;        }</b>
<i>3136</i>&nbsp;
<i>3137</i>&nbsp;
<i>3138</i>&nbsp;        /**
<i>3139</i>&nbsp;         * End if overridden to create the necessary stylesheets that
<b class="nc"><i>3140</i>&nbsp;         * are referenced via the link tag. It is done in this manner</b>
<i>3141</i>&nbsp;         * as the meta tag can be used to specify an alternate style sheet,
<i>3142</i>&nbsp;         * and is not guaranteed to come before the link tags.
<i>3143</i>&nbsp;         */
<i>3144</i>&nbsp;        class HeadAction extends BlockAction {
<i>3145</i>&nbsp;
<i>3146</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>3147</i>&nbsp;                inHead = true;
<i>3148</i>&nbsp;                // This check of the insertTag is put in to avoid considering
<b class="nc"><i>3149</i>&nbsp;                // the implied-p that is generated for the head. This allows</b>
<i>3150</i>&nbsp;                // inserts for HR to work correctly.
<i>3151</i>&nbsp;                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||
<b class="nc"><i>3152</i>&nbsp;                    (insertTag == HTML.Tag.HEAD) ||</b>
<b class="nc"><i>3153</i>&nbsp;                    (insertAfterImplied &amp;&amp;</b>
<i>3154</i>&nbsp;                     (foundInsertTag || !a.isDefined(IMPLIED)))) {
<i>3155</i>&nbsp;                    super.start(t, a);
<i>3156</i>&nbsp;                }
<i>3157</i>&nbsp;            }
<b class="nc"><i>3158</i>&nbsp;</b>
<b class="nc"><i>3159</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>3160</i>&nbsp;                inHead = inStyle = false;</b>
<b class="nc"><i>3161</i>&nbsp;                // See if there is a StyleSheet to link to.</b>
<i>3162</i>&nbsp;                if (styles != null) {
<i>3163</i>&nbsp;                    boolean isDefaultCSS = isStyleCSS;
<b class="nc"><i>3164</i>&nbsp;                    for (int counter = 0, maxCounter = styles.size();</b>
<i>3165</i>&nbsp;                         counter &lt; maxCounter;) {
<i>3166</i>&nbsp;                        Object value = styles.elementAt(counter);
<i>3167</i>&nbsp;                        if (value == HTML.Tag.LINK) {
<b class="nc"><i>3168</i>&nbsp;                            handleLink((AttributeSet)styles.</b>
<b class="nc"><i>3169</i>&nbsp;                                       elementAt(++counter));</b>
<i>3170</i>&nbsp;                            counter++;
<b class="nc"><i>3171</i>&nbsp;                        }</b>
<b class="nc"><i>3172</i>&nbsp;                        else {</b>
<i>3173</i>&nbsp;                            // Rule.
<i>3174</i>&nbsp;                            // First element gives type.
<i>3175</i>&nbsp;                            String type = (String)styles.elementAt(++counter);
<i>3176</i>&nbsp;                            boolean isCSS = (type == null) ? isDefaultCSS :
<b class="nc"><i>3177</i>&nbsp;                                            type.equals(&quot;text/css&quot;);</b>
<b class="nc"><i>3178</i>&nbsp;                            while (++counter &lt; maxCounter &amp;&amp;</b>
<b class="nc"><i>3179</i>&nbsp;                                   (styles.elementAt(counter)</b>
<b class="nc"><i>3180</i>&nbsp;                                    instanceof String)) {</b>
<b class="nc"><i>3181</i>&nbsp;                                if (isCSS) {</b>
<b class="nc"><i>3182</i>&nbsp;                                    addCSSRules((String)styles.elementAt</b>
<b class="nc"><i>3183</i>&nbsp;                                                (counter));</b>
<b class="nc"><i>3184</i>&nbsp;                                }</b>
<b class="nc"><i>3185</i>&nbsp;                            }</b>
<b class="nc"><i>3186</i>&nbsp;                        }</b>
<b class="nc"><i>3187</i>&nbsp;                    }</b>
<b class="nc"><i>3188</i>&nbsp;                }</b>
<b class="nc"><i>3189</i>&nbsp;                if ((insertTag == null &amp;&amp; !insertAfterImplied) ||</b>
<b class="nc"><i>3190</i>&nbsp;                    insertTag == HTML.Tag.HEAD ||</b>
<b class="nc"><i>3191</i>&nbsp;                    (insertAfterImplied &amp;&amp; foundInsertTag)) {</b>
<b class="nc"><i>3192</i>&nbsp;                    super.end(t);</b>
<b class="nc"><i>3193</i>&nbsp;                }</b>
<b class="nc"><i>3194</i>&nbsp;            }</b>
<b class="nc"><i>3195</i>&nbsp;</b>
<b class="nc"><i>3196</i>&nbsp;            boolean isEmpty(HTML.Tag t) {</b>
<b class="nc"><i>3197</i>&nbsp;                return false;</b>
<b class="nc"><i>3198</i>&nbsp;            }</b>
<b class="nc"><i>3199</i>&nbsp;</b>
<b class="nc"><i>3200</i>&nbsp;            private void handleLink(AttributeSet attr) {</b>
<b class="nc"><i>3201</i>&nbsp;                // Link.</b>
<b class="nc"><i>3202</i>&nbsp;                String type = (String)attr.getAttribute(HTML.Attribute.TYPE);</b>
<b class="nc"><i>3203</i>&nbsp;                if (type == null) {</b>
<b class="nc"><i>3204</i>&nbsp;                    type = getDefaultStyleSheetType();</b>
<b class="nc"><i>3205</i>&nbsp;                }</b>
<b class="nc"><i>3206</i>&nbsp;                // Only choose if type==text/css</b>
<i>3207</i>&nbsp;                // Select link if rel==stylesheet.
<b class="nc"><i>3208</i>&nbsp;                // Otherwise if rel==alternate stylesheet and</b>
<b class="nc"><i>3209</i>&nbsp;                //   title matches default style.</b>
<b class="nc"><i>3210</i>&nbsp;                if (type.equals(&quot;text/css&quot;)) {</b>
<i>3211</i>&nbsp;                    String rel = (String)attr.getAttribute(HTML.Attribute.REL);
<b class="nc"><i>3212</i>&nbsp;                    String title = (String)attr.getAttribute</b>
<b class="nc"><i>3213</i>&nbsp;                                               (HTML.Attribute.TITLE);</b>
<b class="nc"><i>3214</i>&nbsp;                    String media = (String)attr.getAttribute</b>
<i>3215</i>&nbsp;                                                   (HTML.Attribute.MEDIA);
<i>3216</i>&nbsp;                    if (media == null) {
<i>3217</i>&nbsp;                        media = &quot;all&quot;;
<i>3218</i>&nbsp;                    }
<i>3219</i>&nbsp;                    else {
<b class="nc"><i>3220</i>&nbsp;                        media = media.toLowerCase();</b>
<i>3221</i>&nbsp;                    }
<i>3222</i>&nbsp;                    if (rel != null) {
<i>3223</i>&nbsp;                        rel = rel.toLowerCase();
<i>3224</i>&nbsp;                        if ((media.indexOf(&quot;all&quot;) != -1 ||
<b class="nc"><i>3225</i>&nbsp;                             media.indexOf(&quot;screen&quot;) != -1) &amp;&amp;</b>
<i>3226</i>&nbsp;                            (rel.equals(&quot;stylesheet&quot;) ||
<i>3227</i>&nbsp;                             (rel.equals(&quot;alternate stylesheet&quot;) &amp;&amp;
<i>3228</i>&nbsp;                              title.equals(defaultStyle)))) {
<b class="nc"><i>3229</i>&nbsp;                            linkCSSStyleSheet((String)attr.getAttribute</b>
<b class="nc"><i>3230</i>&nbsp;                                              (HTML.Attribute.HREF));</b>
<i>3231</i>&nbsp;                        }
<i>3232</i>&nbsp;                    }
<i>3233</i>&nbsp;                }
<b class="nc"><i>3234</i>&nbsp;            }</b>
<i>3235</i>&nbsp;        }
<i>3236</i>&nbsp;
<i>3237</i>&nbsp;
<b class="nc"><i>3238</i>&nbsp;        /**</b>
<b class="nc"><i>3239</i>&nbsp;         * A subclass to add the AttributeSet to styles if the</b>
<b class="nc"><i>3240</i>&nbsp;         * attributes contains an attribute for &#39;rel&#39; with value</b>
<i>3241</i>&nbsp;         * &#39;stylesheet&#39; or &#39;alternate stylesheet&#39;.
<b class="nc"><i>3242</i>&nbsp;         */</b>
<i>3243</i>&nbsp;        class LinkAction extends HiddenAction {
<i>3244</i>&nbsp;
<i>3245</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<b class="nc"><i>3246</i>&nbsp;                String rel = (String)a.getAttribute(HTML.Attribute.REL);</b>
<i>3247</i>&nbsp;                if (rel != null) {
<i>3248</i>&nbsp;                    rel = rel.toLowerCase();
<b class="nc"><i>3249</i>&nbsp;                    if (rel.equals(&quot;stylesheet&quot;) ||</b>
<b class="nc"><i>3250</i>&nbsp;                        rel.equals(&quot;alternate stylesheet&quot;)) {</b>
<i>3251</i>&nbsp;                        if (styles == null) {
<i>3252</i>&nbsp;                            styles = new Vector&lt;Object&gt;(3);
<i>3253</i>&nbsp;                        }
<b class="nc"><i>3254</i>&nbsp;                        styles.addElement(t);</b>
<b class="nc"><i>3255</i>&nbsp;                        styles.addElement(a.copyAttributes());</b>
<i>3256</i>&nbsp;                    }
<i>3257</i>&nbsp;                }
<i>3258</i>&nbsp;                super.start(t, a);
<b class="nc"><i>3259</i>&nbsp;            }</b>
<i>3260</i>&nbsp;        }
<i>3261</i>&nbsp;
<i>3262</i>&nbsp;        class MapAction extends TagAction {
<i>3263</i>&nbsp;
<b class="nc"><i>3264</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {</b>
<i>3265</i>&nbsp;                lastMap = new Map((String)a.getAttribute(HTML.Attribute.NAME));
<i>3266</i>&nbsp;                addMap(lastMap);
<b class="nc"><i>3267</i>&nbsp;            }</b>
<b class="nc"><i>3268</i>&nbsp;</b>
<i>3269</i>&nbsp;            public void end(HTML.Tag t) {
<b class="nc"><i>3270</i>&nbsp;            }</b>
<b class="nc"><i>3271</i>&nbsp;        }</b>
<b class="nc"><i>3272</i>&nbsp;</b>
<b class="nc"><i>3273</i>&nbsp;</b>
<b class="nc"><i>3274</i>&nbsp;        class AreaAction extends TagAction {</b>
<i>3275</i>&nbsp;
<b class="nc"><i>3276</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {</b>
<i>3277</i>&nbsp;                if (lastMap != null) {
<i>3278</i>&nbsp;                    lastMap.addArea(a.copyAttributes());
<i>3279</i>&nbsp;                }
<b class="nc"><i>3280</i>&nbsp;            }</b>
<i>3281</i>&nbsp;
<i>3282</i>&nbsp;            public void end(HTML.Tag t) {
<b class="nc"><i>3283</i>&nbsp;            }</b>
<b class="nc"><i>3284</i>&nbsp;        }</b>
<i>3285</i>&nbsp;
<b class="nc"><i>3286</i>&nbsp;</b>
<i>3287</i>&nbsp;        class StyleAction extends TagAction {
<i>3288</i>&nbsp;
<i>3289</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>3290</i>&nbsp;                if (inHead) {
<b class="nc"><i>3291</i>&nbsp;                    if (styles == null) {</b>
<b class="nc"><i>3292</i>&nbsp;                        styles = new Vector&lt;Object&gt;(3);</b>
<i>3293</i>&nbsp;                    }
<i>3294</i>&nbsp;                    styles.addElement(t);
<i>3295</i>&nbsp;                    styles.addElement(a.getAttribute(HTML.Attribute.TYPE));
<i>3296</i>&nbsp;                    inStyle = true;
<b class="nc"><i>3297</i>&nbsp;                }</b>
<b class="nc"><i>3298</i>&nbsp;            }</b>
<b class="nc"><i>3299</i>&nbsp;</b>
<b class="nc"><i>3300</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>3301</i>&nbsp;                inStyle = false;</b>
<b class="nc"><i>3302</i>&nbsp;            }</b>
<i>3303</i>&nbsp;
<i>3304</i>&nbsp;            boolean isEmpty(HTML.Tag t) {
<i>3305</i>&nbsp;                return false;
<i>3306</i>&nbsp;            }
<i>3307</i>&nbsp;        }
<i>3308</i>&nbsp;
<i>3309</i>&nbsp;        /**
<i>3310</i>&nbsp;         * Action assigned by default to handle the Pre block task of the reader.
<i>3311</i>&nbsp;         */
<i>3312</i>&nbsp;        public class PreAction extends BlockAction {
<i>3313</i>&nbsp;
<i>3314</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<i>3315</i>&nbsp;                inPre = true;
<i>3316</i>&nbsp;                blockOpen(t, attr);
<i>3317</i>&nbsp;                attr.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);
<i>3318</i>&nbsp;                blockOpen(HTML.Tag.IMPLIED, attr);
<i>3319</i>&nbsp;            }
<i>3320</i>&nbsp;
<i>3321</i>&nbsp;            public void end(HTML.Tag t) {
<i>3322</i>&nbsp;                blockClose(HTML.Tag.IMPLIED);
<i>3323</i>&nbsp;                // set inPre to false after closing, so that if a newline
<i>3324</i>&nbsp;                // is added it won&#39;t generate a blockOpen.
<i>3325</i>&nbsp;                inPre = false;
<i>3326</i>&nbsp;                blockClose(t);
<i>3327</i>&nbsp;            }
<i>3328</i>&nbsp;        }
<i>3329</i>&nbsp;
<i>3330</i>&nbsp;        /**
<i>3331</i>&nbsp;         * Action assigned by default to handle the Character task of the reader.
<i>3332</i>&nbsp;         */
<i>3333</i>&nbsp;        public class CharacterAction extends TagAction {
<i>3334</i>&nbsp;
<i>3335</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<i>3336</i>&nbsp;                pushCharacterStyle();
<i>3337</i>&nbsp;                if (!foundInsertTag) {
<i>3338</i>&nbsp;                    // Note that the third argument should really be based off
<i>3339</i>&nbsp;                    // inParagraph and impliedP. If we&#39;re wrong (that is
<i>3340</i>&nbsp;                    // insertTagDepthDelta shouldn&#39;t be changed), we&#39;ll end up
<i>3341</i>&nbsp;                    // removing an extra EndSpec, which won&#39;t matter anyway.
<i>3342</i>&nbsp;                    boolean insert = canInsertTag(t, attr, false);
<i>3343</i>&nbsp;                    if (foundInsertTag) {
<i>3344</i>&nbsp;                        if (!inParagraph) {
<i>3345</i>&nbsp;                            inParagraph = impliedP = true;
<i>3346</i>&nbsp;                        }
<i>3347</i>&nbsp;                    }
<i>3348</i>&nbsp;                    if (!insert) {
<i>3349</i>&nbsp;                        return;
<i>3350</i>&nbsp;                    }
<i>3351</i>&nbsp;                }
<i>3352</i>&nbsp;                if (attr.isDefined(IMPLIED)) {
<i>3353</i>&nbsp;                    attr.removeAttribute(IMPLIED);
<i>3354</i>&nbsp;                }
<i>3355</i>&nbsp;                charAttr.addAttribute(t, attr.copyAttributes());
<b class="nc"><i>3356</i>&nbsp;                if (styleAttributes != null) {</b>
<i>3357</i>&nbsp;                    charAttr.addAttributes(styleAttributes);
<i>3358</i>&nbsp;                }
<b class="nc"><i>3359</i>&nbsp;            }</b>
<b class="nc"><i>3360</i>&nbsp;</b>
<b class="nc"><i>3361</i>&nbsp;            public void end(HTML.Tag t) {</b>
<i>3362</i>&nbsp;                popCharacterStyle();
<i>3363</i>&nbsp;            }
<i>3364</i>&nbsp;        }
<i>3365</i>&nbsp;
<b class="nc"><i>3366</i>&nbsp;        /**</b>
<b class="nc"><i>3367</i>&nbsp;         * Provides conversion of HTML tag/attribute</b>
<b class="nc"><i>3368</i>&nbsp;         * mappings that have a corresponding StyleConstants</b>
<i>3369</i>&nbsp;         * and CSS mapping.  The conversion is to CSS attributes.
<b class="nc"><i>3370</i>&nbsp;         */</b>
<b class="nc"><i>3371</i>&nbsp;        class ConvertAction extends TagAction {</b>
<b class="nc"><i>3372</i>&nbsp;</b>
<b class="nc"><i>3373</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {</b>
<b class="nc"><i>3374</i>&nbsp;                pushCharacterStyle();</b>
<i>3375</i>&nbsp;                if (!foundInsertTag) {
<b class="nc"><i>3376</i>&nbsp;                    // Note that the third argument should really be based off</b>
<b class="nc"><i>3377</i>&nbsp;                    // inParagraph and impliedP. If we&#39;re wrong (that is</b>
<i>3378</i>&nbsp;                    // insertTagDepthDelta shouldn&#39;t be changed), we&#39;ll end up
<i>3379</i>&nbsp;                    // removing an extra EndSpec, which won&#39;t matter anyway.
<b class="nc"><i>3380</i>&nbsp;                    boolean insert = canInsertTag(t, attr, false);</b>
<b class="nc"><i>3381</i>&nbsp;                    if (foundInsertTag) {</b>
<b class="nc"><i>3382</i>&nbsp;                        if (!inParagraph) {</b>
<b class="nc"><i>3383</i>&nbsp;                            inParagraph = impliedP = true;</b>
<b class="nc"><i>3384</i>&nbsp;                        }</b>
<i>3385</i>&nbsp;                    }
<b class="nc"><i>3386</i>&nbsp;                    if (!insert) {</b>
<b class="nc"><i>3387</i>&nbsp;                        return;</b>
<b class="nc"><i>3388</i>&nbsp;                    }</b>
<i>3389</i>&nbsp;                }
<b class="nc"><i>3390</i>&nbsp;                if (attr.isDefined(IMPLIED)) {</b>
<i>3391</i>&nbsp;                    attr.removeAttribute(IMPLIED);
<i>3392</i>&nbsp;                }
<i>3393</i>&nbsp;                if (styleAttributes != null) {
<i>3394</i>&nbsp;                    charAttr.addAttributes(styleAttributes);
<i>3395</i>&nbsp;                }
<b class="nc"><i>3396</i>&nbsp;                // We also need to add attr, otherwise we lose custom</b>
<b class="nc"><i>3397</i>&nbsp;                // attributes, including class/id for style lookups, and</b>
<i>3398</i>&nbsp;                // further confuse style lookup (doesn&#39;t have tag).
<b class="nc"><i>3399</i>&nbsp;                charAttr.addAttribute(t, attr.copyAttributes());</b>
<b class="nc"><i>3400</i>&nbsp;                StyleSheet sheet = getStyleSheet();</b>
<b class="nc"><i>3401</i>&nbsp;                if (t == HTML.Tag.B) {</b>
<b class="nc"><i>3402</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_WEIGHT, &quot;bold&quot;);</b>
<b class="nc"><i>3403</i>&nbsp;                } else if (t == HTML.Tag.I) {</b>
<b class="nc"><i>3404</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_STYLE, &quot;italic&quot;);</b>
<i>3405</i>&nbsp;                } else if (t == HTML.Tag.U) {
<b class="nc"><i>3406</i>&nbsp;                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);</b>
<b class="nc"><i>3407</i>&nbsp;                    String value = &quot;underline&quot;;</b>
<b class="nc"><i>3408</i>&nbsp;                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;</b>
<b class="nc"><i>3409</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);</b>
<b class="nc"><i>3410</i>&nbsp;                } else if (t == HTML.Tag.STRIKE) {</b>
<b class="nc"><i>3411</i>&nbsp;                    Object v = charAttr.getAttribute(CSS.Attribute.TEXT_DECORATION);</b>
<i>3412</i>&nbsp;                    String value = &quot;line-through&quot;;
<i>3413</i>&nbsp;                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
<b class="nc"><i>3414</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.TEXT_DECORATION, value);</b>
<i>3415</i>&nbsp;                } else if (t == HTML.Tag.SUP) {
<b class="nc"><i>3416</i>&nbsp;                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);</b>
<i>3417</i>&nbsp;                    String value = &quot;sup&quot;;
<i>3418</i>&nbsp;                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
<i>3419</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);
<i>3420</i>&nbsp;                } else if (t == HTML.Tag.SUB) {
<b class="nc"><i>3421</i>&nbsp;                    Object v = charAttr.getAttribute(CSS.Attribute.VERTICAL_ALIGN);</b>
<b class="nc"><i>3422</i>&nbsp;                    String value = &quot;sub&quot;;</b>
<i>3423</i>&nbsp;                    value = (v != null) ? value + &quot;,&quot; + v.toString() : value;
<b class="nc"><i>3424</i>&nbsp;                    sheet.addCSSAttribute(charAttr, CSS.Attribute.VERTICAL_ALIGN, value);</b>
<b class="nc"><i>3425</i>&nbsp;                } else if (t == HTML.Tag.FONT) {</b>
<b class="nc"><i>3426</i>&nbsp;                    String color = (String) attr.getAttribute(HTML.Attribute.COLOR);</b>
<b class="nc"><i>3427</i>&nbsp;                    if (color != null) {</b>
<b class="nc"><i>3428</i>&nbsp;                        sheet.addCSSAttribute(charAttr, CSS.Attribute.COLOR, color);</b>
<i>3429</i>&nbsp;                    }
<i>3430</i>&nbsp;                    String face = (String) attr.getAttribute(HTML.Attribute.FACE);
<i>3431</i>&nbsp;                    if (face != null) {
<i>3432</i>&nbsp;                        sheet.addCSSAttribute(charAttr, CSS.Attribute.FONT_FAMILY, face);
<i>3433</i>&nbsp;                    }
<i>3434</i>&nbsp;                    String size = (String) attr.getAttribute(HTML.Attribute.SIZE);
<i>3435</i>&nbsp;                    if (size != null) {
<b class="nc"><i>3436</i>&nbsp;                        sheet.addCSSAttributeFromHTML(charAttr, CSS.Attribute.FONT_SIZE, size);</b>
<i>3437</i>&nbsp;                    }
<b class="nc"><i>3438</i>&nbsp;                }</b>
<i>3439</i>&nbsp;            }
<i>3440</i>&nbsp;
<i>3441</i>&nbsp;            public void end(HTML.Tag t) {
<i>3442</i>&nbsp;                popCharacterStyle();
<b class="nc"><i>3443</i>&nbsp;            }</b>
<b class="nc"><i>3444</i>&nbsp;</b>
<b class="nc"><i>3445</i>&nbsp;        }</b>
<i>3446</i>&nbsp;
<i>3447</i>&nbsp;        class AnchorAction extends CharacterAction {
<b class="nc"><i>3448</i>&nbsp;</b>
<i>3449</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<b class="nc"><i>3450</i>&nbsp;                // set flag to catch empty anchors</b>
<b class="nc"><i>3451</i>&nbsp;                emptyAnchor = true;</b>
<i>3452</i>&nbsp;                super.start(t, attr);
<b class="nc"><i>3453</i>&nbsp;            }</b>
<i>3454</i>&nbsp;
<i>3455</i>&nbsp;            public void end(HTML.Tag t) {
<i>3456</i>&nbsp;                if (emptyAnchor) {
<b class="nc"><i>3457</i>&nbsp;                    // if the anchor was empty it was probably a</b>
<b class="nc"><i>3458</i>&nbsp;                    // named anchor point and we don&#39;t want to throw</b>
<i>3459</i>&nbsp;                    // it away.
<i>3460</i>&nbsp;                    char[] one = new char[1];
<b class="nc"><i>3461</i>&nbsp;                    one[0] = &#39;\n&#39;;</b>
<i>3462</i>&nbsp;                    addContent(one, 0, 1);
<b class="nc"><i>3463</i>&nbsp;                }</b>
<b class="nc"><i>3464</i>&nbsp;                super.end(t);</b>
<i>3465</i>&nbsp;            }
<b class="nc"><i>3466</i>&nbsp;        }</b>
<b class="nc"><i>3467</i>&nbsp;</b>
<b class="nc"><i>3468</i>&nbsp;        class TitleAction extends HiddenAction {</b>
<b class="nc"><i>3469</i>&nbsp;</b>
<b class="nc"><i>3470</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {</b>
<i>3471</i>&nbsp;                inTitle = true;
<b class="nc"><i>3472</i>&nbsp;                super.start(t, attr);</b>
<i>3473</i>&nbsp;            }
<b class="nc"><i>3474</i>&nbsp;</b>
<b class="nc"><i>3475</i>&nbsp;            public void end(HTML.Tag t) {</b>
<b class="nc"><i>3476</i>&nbsp;                inTitle = false;</b>
<b class="nc"><i>3477</i>&nbsp;                super.end(t);</b>
<b class="nc"><i>3478</i>&nbsp;            }</b>
<b class="nc"><i>3479</i>&nbsp;</b>
<b class="nc"><i>3480</i>&nbsp;            boolean isEmpty(HTML.Tag t) {</b>
<i>3481</i>&nbsp;                return false;
<b class="nc"><i>3482</i>&nbsp;            }</b>
<b class="nc"><i>3483</i>&nbsp;        }</b>
<b class="nc"><i>3484</i>&nbsp;</b>
<b class="nc"><i>3485</i>&nbsp;</b>
<i>3486</i>&nbsp;        class BaseAction extends TagAction {
<b class="nc"><i>3487</i>&nbsp;</b>
<i>3488</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<b class="nc"><i>3489</i>&nbsp;                String href = (String) attr.getAttribute(HTML.Attribute.HREF);</b>
<b class="nc"><i>3490</i>&nbsp;                if (href != null) {</b>
<b class="nc"><i>3491</i>&nbsp;                    try {</b>
<i>3492</i>&nbsp;                        URL newBase = new URL(base, href);
<i>3493</i>&nbsp;                        setBase(newBase);
<i>3494</i>&nbsp;                        hasBaseTag = true;
<i>3495</i>&nbsp;                    } catch (MalformedURLException ex) {
<i>3496</i>&nbsp;                    }
<i>3497</i>&nbsp;                }
<i>3498</i>&nbsp;                baseTarget = (String) attr.getAttribute(HTML.Attribute.TARGET);
<i>3499</i>&nbsp;            }
<i>3500</i>&nbsp;        }
<i>3501</i>&nbsp;
<i>3502</i>&nbsp;        class ObjectAction extends SpecialAction {
<i>3503</i>&nbsp;
<i>3504</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet a) {
<i>3505</i>&nbsp;                if (t == HTML.Tag.PARAM) {
<i>3506</i>&nbsp;                    addParameter(a);
<i>3507</i>&nbsp;                } else {
<i>3508</i>&nbsp;                    super.start(t, a);
<i>3509</i>&nbsp;                }
<i>3510</i>&nbsp;            }
<i>3511</i>&nbsp;
<i>3512</i>&nbsp;            public void end(HTML.Tag t) {
<b class="nc"><i>3513</i>&nbsp;                if (t != HTML.Tag.PARAM) {</b>
<i>3514</i>&nbsp;                    super.end(t);
<i>3515</i>&nbsp;                }
<i>3516</i>&nbsp;            }
<i>3517</i>&nbsp;
<i>3518</i>&nbsp;            void addParameter(AttributeSet a) {
<i>3519</i>&nbsp;                String name = (String) a.getAttribute(HTML.Attribute.NAME);
<i>3520</i>&nbsp;                String value = (String) a.getAttribute(HTML.Attribute.VALUE);
<b class="nc"><i>3521</i>&nbsp;                if ((name != null) &amp;&amp; (value != null)) {</b>
<b class="nc"><i>3522</i>&nbsp;                    ElementSpec objSpec = parseBuffer.lastElement();</b>
<b class="nc"><i>3523</i>&nbsp;                    MutableAttributeSet objAttr = (MutableAttributeSet) objSpec.getAttributes();</b>
<i>3524</i>&nbsp;                    objAttr.addAttribute(name, value);
<i>3525</i>&nbsp;                }
<i>3526</i>&nbsp;            }
<i>3527</i>&nbsp;        }
<i>3528</i>&nbsp;
<i>3529</i>&nbsp;        /**
<i>3530</i>&nbsp;         * Action to support forms by building all of the elements
<i>3531</i>&nbsp;         * used to represent form controls.  This will process
<i>3532</i>&nbsp;         * the &amp;lt;INPUT&amp;gt;, &amp;lt;TEXTAREA&amp;gt;, &amp;lt;SELECT&amp;gt;,
<i>3533</i>&nbsp;         * and &amp;lt;OPTION&amp;gt; tags.  The element created by
<i>3534</i>&nbsp;         * this action is expected to have the attribute
<i>3535</i>&nbsp;         * &lt;code&gt;StyleConstants.ModelAttribute&lt;/code&gt; set to
<b class="nc"><i>3536</i>&nbsp;         * the model that holds the state for the form control.</b>
<b class="nc"><i>3537</i>&nbsp;         * This enables multiple views, and allows document to</b>
<i>3538</i>&nbsp;         * be iterated over picking up the data of the form.
<b class="nc"><i>3539</i>&nbsp;         * The following are the model assignments for the</b>
<i>3540</i>&nbsp;         * various type of form elements.
<i>3541</i>&nbsp;         *
<i>3542</i>&nbsp;         * &lt;table class=&quot;striped&quot;&gt;
<i>3543</i>&nbsp;         * &lt;caption&gt;Model assignments for the various types of form elements
<i>3544</i>&nbsp;         * &lt;/caption&gt;
<i>3545</i>&nbsp;         * &lt;thead&gt;
<i>3546</i>&nbsp;         *   &lt;tr&gt;
<i>3547</i>&nbsp;         *     &lt;th scope=&quot;col&quot;&gt;Element Type
<i>3548</i>&nbsp;         *     &lt;th scope=&quot;col&quot;&gt;Model Type
<b class="nc"><i>3549</i>&nbsp;         * &lt;/thead&gt;</b>
<b class="nc"><i>3550</i>&nbsp;         * &lt;tbody&gt;</b>
<b class="nc"><i>3551</i>&nbsp;         *   &lt;tr&gt;</b>
<b class="nc"><i>3552</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type button</b>
<b class="nc"><i>3553</i>&nbsp;         *     &lt;td&gt;{@link DefaultButtonModel}</b>
<b class="nc"><i>3554</i>&nbsp;         *   &lt;tr&gt;</b>
<b class="nc"><i>3555</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type checkbox</b>
<b class="nc"><i>3556</i>&nbsp;         *     &lt;td&gt;{@link JToggleButton.ToggleButtonModel}</b>
<b class="nc"><i>3557</i>&nbsp;         *   &lt;tr&gt;</b>
<i>3558</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type image
<i>3559</i>&nbsp;         *     &lt;td&gt;{@link DefaultButtonModel}
<b class="nc"><i>3560</i>&nbsp;         *   &lt;tr&gt;</b>
<b class="nc"><i>3561</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type password</b>
<i>3562</i>&nbsp;         *     &lt;td&gt;{@link PlainDocument}
<i>3563</i>&nbsp;         *   &lt;tr&gt;
<i>3564</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type radio
<i>3565</i>&nbsp;         *     &lt;td&gt;{@link JToggleButton.ToggleButtonModel}
<i>3566</i>&nbsp;         *   &lt;tr&gt;
<i>3567</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type reset
<i>3568</i>&nbsp;         *     &lt;td&gt;{@link DefaultButtonModel}
<i>3569</i>&nbsp;         *   &lt;tr&gt;
<b class="nc"><i>3570</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type submit</b>
<b class="nc"><i>3571</i>&nbsp;         *     &lt;td&gt;{@link DefaultButtonModel}</b>
<i>3572</i>&nbsp;         *   &lt;tr&gt;
<i>3573</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;input, type text or type is null.
<b class="nc"><i>3574</i>&nbsp;         *     &lt;td&gt;{@link PlainDocument}</b>
<i>3575</i>&nbsp;         *   &lt;tr&gt;
<b class="nc"><i>3576</i>&nbsp;         *     &lt;th scope=&quot;row&quot;&gt;select</b>
<i>3577</i>&nbsp;         *     &lt;td&gt;{@link DefaultComboBoxModel} or an {@link DefaultListModel},
<i>3578</i>&nbsp;         *     with an item type of Option
<b class="nc"><i>3579</i>&nbsp;         *   &lt;tr&gt;</b>
<b class="nc"><i>3580</i>&nbsp;         *     &lt;td&gt;textarea</b>
<i>3581</i>&nbsp;         *     &lt;td&gt;{@link PlainDocument}
<b class="nc"><i>3582</i>&nbsp;         * &lt;/tbody&gt;</b>
<b class="nc"><i>3583</i>&nbsp;         * &lt;/table&gt;</b>
<b class="nc"><i>3584</i>&nbsp;         */</b>
<b class="nc"><i>3585</i>&nbsp;        public class FormAction extends SpecialAction {</b>
<b class="nc"><i>3586</i>&nbsp;</b>
<i>3587</i>&nbsp;            public void start(HTML.Tag t, MutableAttributeSet attr) {
<i>3588</i>&nbsp;                if (t == HTML.Tag.INPUT) {
<i>3589</i>&nbsp;                    String type = (String)
<i>3590</i>&nbsp;                        attr.getAttribute(HTML.Attribute.TYPE);
<i>3591</i>&nbsp;                    /*
<i>3592</i>&nbsp;                     * if type is not defined the default is
<i>3593</i>&nbsp;                     * assumed to be text.
<b class="nc"><i>3594</i>&nbsp;                     */</b>
<i>3595</i>&nbsp;                    if (type == null) {
<b class="nc"><i>3596</i>&nbsp;                        type = &quot;text&quot;;</b>
<i>3597</i>&nbsp;                        attr.addAttribute(HTML.Attribute.TYPE, &quot;text&quot;);
<i>3598</i>&nbsp;                    }
<i>3599</i>&nbsp;                    setModel(type, attr);
<i>3600</i>&nbsp;                } else if (t == HTML.Tag.TEXTAREA) {
<i>3601</i>&nbsp;                    inTextArea = true;
<i>3602</i>&nbsp;                    textAreaDocument = new TextAreaDocument();
<i>3603</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute,
<i>3604</i>&nbsp;                                      textAreaDocument);
<i>3605</i>&nbsp;                } else if (t == HTML.Tag.SELECT) {
<b class="nc"><i>3606</i>&nbsp;                    int size = HTML.getIntegerAttributeValue(attr,</b>
<b class="nc"><i>3607</i>&nbsp;                                                             HTML.Attribute.SIZE,</b>
<b class="nc"><i>3608</i>&nbsp;                                                             1);</b>
<b class="nc"><i>3609</i>&nbsp;                    boolean multiple = attr.getAttribute(HTML.Attribute.MULTIPLE) != null;</b>
<b class="nc"><i>3610</i>&nbsp;                    if ((size &gt; 1) || multiple) {</b>
<b class="nc"><i>3611</i>&nbsp;                        OptionListModel&lt;Option&gt; m = new OptionListModel&lt;Option&gt;();</b>
<i>3612</i>&nbsp;                        if (multiple) {
<i>3613</i>&nbsp;                            m.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
<b class="nc"><i>3614</i>&nbsp;                        }</b>
<b class="nc"><i>3615</i>&nbsp;                        selectModel = m;</b>
<b class="nc"><i>3616</i>&nbsp;                    } else {</b>
<b class="nc"><i>3617</i>&nbsp;                        selectModel = new OptionComboBoxModel&lt;Option&gt;();</b>
<b class="nc"><i>3618</i>&nbsp;                    }</b>
<i>3619</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute,
<i>3620</i>&nbsp;                                      selectModel);
<i>3621</i>&nbsp;
<i>3622</i>&nbsp;                }
<b class="nc"><i>3623</i>&nbsp;</b>
<b class="nc"><i>3624</i>&nbsp;                // build the element, unless this is an option.</b>
<b class="nc"><i>3625</i>&nbsp;                if (t == HTML.Tag.OPTION) {</b>
<b class="nc"><i>3626</i>&nbsp;                    option = new Option(attr);</b>
<b class="nc"><i>3627</i>&nbsp;</b>
<b class="nc"><i>3628</i>&nbsp;                    if (selectModel instanceof OptionListModel) {</b>
<i>3629</i>&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>3630</i>&nbsp;                        OptionListModel&lt;Option&gt; m = (OptionListModel&lt;Option&gt;) selectModel;</b>
<i>3631</i>&nbsp;                        m.addElement(option);
<b class="nc"><i>3632</i>&nbsp;                        if (option.isSelected()) {</b>
<i>3633</i>&nbsp;                            m.addSelectionInterval(optionCount, optionCount);
<i>3634</i>&nbsp;                            m.setInitialSelection(optionCount);
<i>3635</i>&nbsp;                        }
<i>3636</i>&nbsp;                    } else if (selectModel instanceof OptionComboBoxModel) {
<i>3637</i>&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
<i>3638</i>&nbsp;                        OptionComboBoxModel&lt;Option&gt; m = (OptionComboBoxModel&lt;Option&gt;) selectModel;
<i>3639</i>&nbsp;                        m.addElement(option);
<i>3640</i>&nbsp;                        if (option.isSelected()) {
<i>3641</i>&nbsp;                            m.setSelectedItem(option);
<i>3642</i>&nbsp;                            m.setInitialSelection(option);
<b class="nc"><i>3643</i>&nbsp;                        }</b>
<i>3644</i>&nbsp;                    }
<i>3645</i>&nbsp;                    optionCount++;
<i>3646</i>&nbsp;                } else {
<i>3647</i>&nbsp;                    super.start(t, attr);
<i>3648</i>&nbsp;                }
<i>3649</i>&nbsp;            }
<i>3650</i>&nbsp;
<i>3651</i>&nbsp;            public void end(HTML.Tag t) {
<i>3652</i>&nbsp;                if (t == HTML.Tag.OPTION) {
<i>3653</i>&nbsp;                    option = null;
<i>3654</i>&nbsp;                } else {
<i>3655</i>&nbsp;                    if (t == HTML.Tag.SELECT) {
<i>3656</i>&nbsp;                        selectModel = null;
<b class="nc"><i>3657</i>&nbsp;                        optionCount = 0;</b>
<i>3658</i>&nbsp;                    } else if (t == HTML.Tag.TEXTAREA) {
<i>3659</i>&nbsp;                        inTextArea = false;
<i>3660</i>&nbsp;
<b class="nc"><i>3661</i>&nbsp;                        /* Now that the textarea has ended,</b>
<b class="nc"><i>3662</i>&nbsp;                         * store the entire initial text</b>
<b class="nc"><i>3663</i>&nbsp;                         * of the text area.  This will</b>
<b class="nc"><i>3664</i>&nbsp;                         * enable us to restore the initial</b>
<i>3665</i>&nbsp;                         * state if a reset is requested.
<b class="nc"><i>3666</i>&nbsp;                         */</b>
<b class="nc"><i>3667</i>&nbsp;                        textAreaDocument.storeInitialText();</b>
<b class="nc"><i>3668</i>&nbsp;                    }</b>
<b class="nc"><i>3669</i>&nbsp;                    super.end(t);</b>
<i>3670</i>&nbsp;                }
<b class="nc"><i>3671</i>&nbsp;            }</b>
<i>3672</i>&nbsp;
<b class="nc"><i>3673</i>&nbsp;            void setModel(String type, MutableAttributeSet attr) {</b>
<b class="nc"><i>3674</i>&nbsp;                if (type.equals(&quot;submit&quot;) ||</b>
<b class="nc"><i>3675</i>&nbsp;                    type.equals(&quot;reset&quot;) ||</b>
<i>3676</i>&nbsp;                    type.equals(&quot;image&quot;)) {
<i>3677</i>&nbsp;
<b class="nc"><i>3678</i>&nbsp;                    // button model</b>
<b class="nc"><i>3679</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute,</b>
<b class="nc"><i>3680</i>&nbsp;                                      new DefaultButtonModel());</b>
<i>3681</i>&nbsp;                } else if (type.equals(&quot;text&quot;) ||
<b class="nc"><i>3682</i>&nbsp;                           type.equals(&quot;password&quot;)) {</b>
<b class="nc"><i>3683</i>&nbsp;                    // plain text model</b>
<i>3684</i>&nbsp;                    int maxLength = HTML.getIntegerAttributeValue(
<i>3685</i>&nbsp;                                       attr, HTML.Attribute.MAXLENGTH, -1);
<i>3686</i>&nbsp;                    Document doc;
<i>3687</i>&nbsp;
<i>3688</i>&nbsp;                    if (maxLength &gt; 0) {
<i>3689</i>&nbsp;                        doc = new FixedLengthDocument(maxLength);
<i>3690</i>&nbsp;                    }
<i>3691</i>&nbsp;                    else {
<b class="nc"><i>3692</i>&nbsp;                        doc = new PlainDocument();</b>
<b class="nc"><i>3693</i>&nbsp;                    }</b>
<b class="nc"><i>3694</i>&nbsp;                    String value = (String)</b>
<b class="nc"><i>3695</i>&nbsp;                        attr.getAttribute(HTML.Attribute.VALUE);</b>
<b class="nc"><i>3696</i>&nbsp;                    try {</b>
<b class="nc"><i>3697</i>&nbsp;                        doc.insertString(0, value, null);</b>
<i>3698</i>&nbsp;                    } catch (BadLocationException e) {
<b class="nc"><i>3699</i>&nbsp;                    }</b>
<i>3700</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute, doc);
<i>3701</i>&nbsp;                } else if (type.equals(&quot;file&quot;)) {
<b class="nc"><i>3702</i>&nbsp;                    // plain text model</b>
<b class="nc"><i>3703</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute,</b>
<i>3704</i>&nbsp;                                      new PlainDocument());
<b class="nc"><i>3705</i>&nbsp;                } else if (type.equals(&quot;checkbox&quot;) ||</b>
<b class="nc"><i>3706</i>&nbsp;                           type.equals(&quot;radio&quot;)) {</b>
<b class="nc"><i>3707</i>&nbsp;                    JToggleButton.ToggleButtonModel model = new JToggleButton.ToggleButtonModel();</b>
<b class="nc"><i>3708</i>&nbsp;                    if (type.equals(&quot;radio&quot;)) {</b>
<b class="nc"><i>3709</i>&nbsp;                        String name = (String) attr.getAttribute(HTML.Attribute.NAME);</b>
<b class="nc"><i>3710</i>&nbsp;                        if ( radioButtonGroupsMap == null ) { //fix for 4772743</b>
<b class="nc"><i>3711</i>&nbsp;                           radioButtonGroupsMap = new HashMap&lt;String, ButtonGroup&gt;();</b>
<b class="nc"><i>3712</i>&nbsp;                        }</b>
<i>3713</i>&nbsp;                        ButtonGroup radioButtonGroup = radioButtonGroupsMap.get(name);
<i>3714</i>&nbsp;                        if (radioButtonGroup == null) {
<b class="nc"><i>3715</i>&nbsp;                            radioButtonGroup = new ButtonGroup();</b>
<b class="nc"><i>3716</i>&nbsp;                            radioButtonGroupsMap.put(name,radioButtonGroup);</b>
<i>3717</i>&nbsp;                        }
<i>3718</i>&nbsp;                        model.setGroup(radioButtonGroup);
<i>3719</i>&nbsp;                    }
<i>3720</i>&nbsp;                    boolean checked = (attr.getAttribute(HTML.Attribute.CHECKED) != null);
<i>3721</i>&nbsp;                    model.setSelected(checked);
<i>3722</i>&nbsp;                    attr.addAttribute(StyleConstants.ModelAttribute, model);
<i>3723</i>&nbsp;                }
<i>3724</i>&nbsp;            }
<b class="nc"><i>3725</i>&nbsp;</b>
<b class="nc"><i>3726</i>&nbsp;            /**</b>
<b class="nc"><i>3727</i>&nbsp;             * If a &amp;lt;SELECT&amp;gt; tag is being processed, this</b>
<i>3728</i>&nbsp;             * model will be a reference to the model being filled
<b class="nc"><i>3729</i>&nbsp;             * with the &amp;lt;OPTION&amp;gt; elements (which produce</b>
<b class="nc"><i>3730</i>&nbsp;             * objects of type &lt;code&gt;Option&lt;/code&gt;.</b>
<i>3731</i>&nbsp;             */
<b class="nc"><i>3732</i>&nbsp;            Object selectModel;</b>
<b class="nc"><i>3733</i>&nbsp;            int optionCount;</b>
<i>3734</i>&nbsp;        }
<b class="nc"><i>3735</i>&nbsp;</b>
<b class="nc"><i>3736</i>&nbsp;</b>
<i>3737</i>&nbsp;        // --- utility methods used by the reader ------------------
<b class="nc"><i>3738</i>&nbsp;</b>
<i>3739</i>&nbsp;        /**
<b class="nc"><i>3740</i>&nbsp;         * Pushes the current character style on a stack in preparation</b>
<b class="nc"><i>3741</i>&nbsp;         * for forming a new nested character style.</b>
<b class="nc"><i>3742</i>&nbsp;         */</b>
<i>3743</i>&nbsp;        protected void pushCharacterStyle() {
<i>3744</i>&nbsp;            charAttrStack.push(charAttr.copyAttributes());
<i>3745</i>&nbsp;        }
<i>3746</i>&nbsp;
<i>3747</i>&nbsp;        /**
<i>3748</i>&nbsp;         * Pops a previously pushed character style off the stack
<i>3749</i>&nbsp;         * to return to a previous style.
<b class="nc"><i>3750</i>&nbsp;         */</b>
<b class="nc"><i>3751</i>&nbsp;        protected void popCharacterStyle() {</b>
<i>3752</i>&nbsp;            if (!charAttrStack.empty()) {
<i>3753</i>&nbsp;                charAttr = (MutableAttributeSet) charAttrStack.peek();
<i>3754</i>&nbsp;                charAttrStack.pop();
<b class="nc"><i>3755</i>&nbsp;            }</b>
<b class="nc"><i>3756</i>&nbsp;        }</b>
<b class="nc"><i>3757</i>&nbsp;</b>
<b class="nc"><i>3758</i>&nbsp;        /**</b>
<b class="nc"><i>3759</i>&nbsp;         * Adds the given content to the textarea document.</b>
<b class="nc"><i>3760</i>&nbsp;         * This method gets called when we are in a textarea</b>
<i>3761</i>&nbsp;         * context.  Therefore all text that is seen belongs
<i>3762</i>&nbsp;         * to the text area and is hence added to the
<b class="nc"><i>3763</i>&nbsp;         * TextAreaDocument associated with the text area.</b>
<i>3764</i>&nbsp;         *
<i>3765</i>&nbsp;         * @param data the given content
<i>3766</i>&nbsp;         */
<i>3767</i>&nbsp;        protected void textAreaContent(char[] data) {
<i>3768</i>&nbsp;            try {
<b class="nc"><i>3769</i>&nbsp;                textAreaDocument.insertString(textAreaDocument.getLength(), new String(data), null);</b>
<b class="nc"><i>3770</i>&nbsp;            } catch (BadLocationException e) {</b>
<b class="nc"><i>3771</i>&nbsp;                // Should do something reasonable</b>
<i>3772</i>&nbsp;            }
<b class="nc"><i>3773</i>&nbsp;        }</b>
<i>3774</i>&nbsp;
<i>3775</i>&nbsp;        /**
<b class="nc"><i>3776</i>&nbsp;         * Adds the given content that was encountered in a</b>
<b class="nc"><i>3777</i>&nbsp;         * PRE element.  This synthesizes lines to hold the</b>
<b class="nc"><i>3778</i>&nbsp;         * runs of text, and makes calls to addContent to</b>
<b class="nc"><i>3779</i>&nbsp;         * actually add the text.</b>
<b class="nc"><i>3780</i>&nbsp;         *</b>
<b class="nc"><i>3781</i>&nbsp;         * @param data the given content</b>
<b class="nc"><i>3782</i>&nbsp;         */</b>
<i>3783</i>&nbsp;        protected void preContent(char[] data) {
<b class="nc"><i>3784</i>&nbsp;            int last = 0;</b>
<b class="nc"><i>3785</i>&nbsp;            for (int i = 0; i &lt; data.length; i++) {</b>
<b class="nc"><i>3786</i>&nbsp;                if (data[i] == &#39;\n&#39;) {</b>
<b class="nc"><i>3787</i>&nbsp;                    addContent(data, last, i - last + 1);</b>
<i>3788</i>&nbsp;                    blockClose(HTML.Tag.IMPLIED);
<b class="nc"><i>3789</i>&nbsp;                    MutableAttributeSet a = new SimpleAttributeSet();</b>
<b class="nc"><i>3790</i>&nbsp;                    a.addAttribute(CSS.Attribute.WHITE_SPACE, &quot;pre&quot;);</b>
<b class="nc"><i>3791</i>&nbsp;                    blockOpen(HTML.Tag.IMPLIED, a);</b>
<b class="nc"><i>3792</i>&nbsp;                    last = i + 1;</b>
<b class="nc"><i>3793</i>&nbsp;                }</b>
<b class="nc"><i>3794</i>&nbsp;            }</b>
<b class="nc"><i>3795</i>&nbsp;            if (last &lt; data.length) {</b>
<i>3796</i>&nbsp;                addContent(data, last, data.length - last);
<i>3797</i>&nbsp;            }
<i>3798</i>&nbsp;        }
<i>3799</i>&nbsp;
<i>3800</i>&nbsp;        /**
<b class="nc"><i>3801</i>&nbsp;         * Adds an instruction to the parse buffer to create a</b>
<i>3802</i>&nbsp;         * block element with the given attributes.
<b class="nc"><i>3803</i>&nbsp;         *</b>
<b class="nc"><i>3804</i>&nbsp;         * @param t an HTML tag</b>
<b class="nc"><i>3805</i>&nbsp;         * @param attr the attribute set</b>
<b class="nc"><i>3806</i>&nbsp;         */</b>
<b class="nc"><i>3807</i>&nbsp;        protected void blockOpen(HTML.Tag t, MutableAttributeSet attr) {</b>
<b class="nc"><i>3808</i>&nbsp;            if (impliedP) {</b>
<i>3809</i>&nbsp;                blockClose(HTML.Tag.IMPLIED);
<b class="nc"><i>3810</i>&nbsp;            }</b>
<i>3811</i>&nbsp;
<b class="nc"><i>3812</i>&nbsp;            inBlock++;</b>
<i>3813</i>&nbsp;
<b class="nc"><i>3814</i>&nbsp;            if (!canInsertTag(t, attr, true)) {</b>
<i>3815</i>&nbsp;                return;
<b class="nc"><i>3816</i>&nbsp;            }</b>
<i>3817</i>&nbsp;            if (attr.isDefined(IMPLIED)) {
<i>3818</i>&nbsp;                attr.removeAttribute(IMPLIED);
<i>3819</i>&nbsp;            }
<i>3820</i>&nbsp;            lastWasNewline = false;
<i>3821</i>&nbsp;            attr.addAttribute(StyleConstants.NameAttribute, t);
<i>3822</i>&nbsp;            ElementSpec es = new ElementSpec(
<i>3823</i>&nbsp;                attr.copyAttributes(), ElementSpec.StartTagType);
<i>3824</i>&nbsp;            parseBuffer.addElement(es);
<i>3825</i>&nbsp;        }
<i>3826</i>&nbsp;
<b class="nc"><i>3827</i>&nbsp;        /**</b>
<b class="nc"><i>3828</i>&nbsp;         * Adds an instruction to the parse buffer to close out</b>
<i>3829</i>&nbsp;         * a block element of the given type.
<i>3830</i>&nbsp;         *
<i>3831</i>&nbsp;         * @param t the HTML tag
<i>3832</i>&nbsp;         */
<i>3833</i>&nbsp;        protected void blockClose(HTML.Tag t) {
<i>3834</i>&nbsp;            inBlock--;
<i>3835</i>&nbsp;
<i>3836</i>&nbsp;            if (!foundInsertTag) {
<i>3837</i>&nbsp;                return;
<b class="nc"><i>3838</i>&nbsp;            }</b>
<b class="nc"><i>3839</i>&nbsp;</b>
<i>3840</i>&nbsp;            // Add a new line, if the last character wasn&#39;t one. This is
<b class="nc"><i>3841</i>&nbsp;            // needed for proper positioning of the cursor. addContent</b>
<b class="nc"><i>3842</i>&nbsp;            // with true will force an implied paragraph to be generated if</b>
<b class="nc"><i>3843</i>&nbsp;            // there isn&#39;t one. This may result in a rather bogus structure</b>
<b class="nc"><i>3844</i>&nbsp;            // (perhaps a table with a child pargraph), but the paragraph</b>
<b class="nc"><i>3845</i>&nbsp;            // is needed for proper positioning and display.</b>
<b class="nc"><i>3846</i>&nbsp;            if(!lastWasNewline) {</b>
<b class="nc"><i>3847</i>&nbsp;                pushCharacterStyle();</b>
<i>3848</i>&nbsp;                charAttr.addAttribute(IMPLIED_CR, Boolean.TRUE);
<i>3849</i>&nbsp;                addContent(NEWLINE, 0, 1, true);
<i>3850</i>&nbsp;                popCharacterStyle();
<i>3851</i>&nbsp;                lastWasNewline = true;
<i>3852</i>&nbsp;            }
<i>3853</i>&nbsp;
<i>3854</i>&nbsp;            if (impliedP) {
<i>3855</i>&nbsp;                impliedP = false;
<i>3856</i>&nbsp;                inParagraph = false;
<i>3857</i>&nbsp;                if (t != HTML.Tag.IMPLIED) {
<b class="nc"><i>3858</i>&nbsp;                    blockClose(HTML.Tag.IMPLIED);</b>
<b class="nc"><i>3859</i>&nbsp;                }</b>
<i>3860</i>&nbsp;            }
<i>3861</i>&nbsp;            // an open/close with no content will be removed, so we
<b class="nc"><i>3862</i>&nbsp;            // add a space of content to keep the element being formed.</b>
<i>3863</i>&nbsp;            ElementSpec prev = (parseBuffer.size() &gt; 0) ?
<i>3864</i>&nbsp;                parseBuffer.lastElement() : null;
<i>3865</i>&nbsp;            if (prev != null &amp;&amp; prev.getType() == ElementSpec.StartTagType) {
<i>3866</i>&nbsp;                char[] one = new char[1];
<i>3867</i>&nbsp;                one[0] = &#39; &#39;;
<b class="nc"><i>3868</i>&nbsp;                addContent(one, 0, 1);</b>
<b class="nc"><i>3869</i>&nbsp;            }</b>
<b class="nc"><i>3870</i>&nbsp;            ElementSpec es = new ElementSpec(</b>
<b class="nc"><i>3871</i>&nbsp;                null, ElementSpec.EndTagType);</b>
<b class="nc"><i>3872</i>&nbsp;            parseBuffer.addElement(es);</b>
<i>3873</i>&nbsp;        }
<b class="nc"><i>3874</i>&nbsp;</b>
<i>3875</i>&nbsp;        /**
<i>3876</i>&nbsp;         * Adds some text with the current character attributes.
<i>3877</i>&nbsp;         *
<b class="nc"><i>3878</i>&nbsp;         * @param data the content to add</b>
<i>3879</i>&nbsp;         * @param offs the initial offset
<i>3880</i>&nbsp;         * @param length the length
<b class="nc"><i>3881</i>&nbsp;         */</b>
<i>3882</i>&nbsp;        protected void addContent(char[] data, int offs, int length) {
<i>3883</i>&nbsp;            addContent(data, offs, length, true);
<i>3884</i>&nbsp;        }
<i>3885</i>&nbsp;
<b class="nc"><i>3886</i>&nbsp;        /**</b>
<i>3887</i>&nbsp;         * Adds some text with the current character attributes.
<i>3888</i>&nbsp;         *
<i>3889</i>&nbsp;         * @param data the content to add
<i>3890</i>&nbsp;         * @param offs the initial offset
<b class="nc"><i>3891</i>&nbsp;         * @param length the length</b>
<b class="nc"><i>3892</i>&nbsp;         * @param generateImpliedPIfNecessary whether to generate implied</b>
<b class="nc"><i>3893</i>&nbsp;         * paragraphs</b>
<i>3894</i>&nbsp;         */
<i>3895</i>&nbsp;        protected void addContent(char[] data, int offs, int length,
<b class="nc"><i>3896</i>&nbsp;                                  boolean generateImpliedPIfNecessary) {</b>
<i>3897</i>&nbsp;            if (!foundInsertTag) {
<i>3898</i>&nbsp;                return;
<i>3899</i>&nbsp;            }
<b class="nc"><i>3900</i>&nbsp;</b>
<i>3901</i>&nbsp;            if (generateImpliedPIfNecessary &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {
<i>3902</i>&nbsp;                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
<i>3903</i>&nbsp;                inParagraph = true;
<b class="nc"><i>3904</i>&nbsp;                impliedP = true;</b>
<b class="nc"><i>3905</i>&nbsp;            }</b>
<i>3906</i>&nbsp;            emptyAnchor = false;
<b class="nc"><i>3907</i>&nbsp;            charAttr.addAttribute(StyleConstants.NameAttribute, HTML.Tag.CONTENT);</b>
<i>3908</i>&nbsp;            AttributeSet a = charAttr.copyAttributes();
<b class="nc"><i>3909</i>&nbsp;            ElementSpec es = new ElementSpec(</b>
<b class="nc"><i>3910</i>&nbsp;                a, ElementSpec.ContentType, data, offs, length);</b>
<i>3911</i>&nbsp;            parseBuffer.addElement(es);
<b class="nc"><i>3912</i>&nbsp;</b>
<i>3913</i>&nbsp;            if (parseBuffer.size() &gt; threshold) {
<i>3914</i>&nbsp;                if ( threshold &lt;= MaxThreshold ) {
<i>3915</i>&nbsp;                    threshold *= StepThreshold;
<b class="nc"><i>3916</i>&nbsp;                }</b>
<b class="nc"><i>3917</i>&nbsp;                try {</b>
<b class="nc"><i>3918</i>&nbsp;                    flushBuffer(false);</b>
<i>3919</i>&nbsp;                } catch (BadLocationException ble) {
<b class="nc"><i>3920</i>&nbsp;                }</b>
<i>3921</i>&nbsp;            }
<b class="nc"><i>3922</i>&nbsp;            if(length &gt; 0) {</b>
<i>3923</i>&nbsp;                lastWasNewline = (data[offs + length - 1] == &#39;\n&#39;);
<i>3924</i>&nbsp;            }
<b class="nc"><i>3925</i>&nbsp;        }</b>
<b class="nc"><i>3926</i>&nbsp;</b>
<b class="nc"><i>3927</i>&nbsp;        /**</b>
<b class="nc"><i>3928</i>&nbsp;         * Adds content that is basically specified entirely</b>
<b class="nc"><i>3929</i>&nbsp;         * in the attribute set.</b>
<i>3930</i>&nbsp;         *
<i>3931</i>&nbsp;         * @param t an HTML tag
<i>3932</i>&nbsp;         * @param a the attribute set
<b class="nc"><i>3933</i>&nbsp;         */</b>
<i>3934</i>&nbsp;        protected void addSpecialElement(HTML.Tag t, MutableAttributeSet a) {
<i>3935</i>&nbsp;            if ((t != HTML.Tag.FRAME) &amp;&amp; (! inParagraph) &amp;&amp; (! inPre)) {
<i>3936</i>&nbsp;                nextTagAfterPImplied = t;
<i>3937</i>&nbsp;                blockOpen(HTML.Tag.IMPLIED, new SimpleAttributeSet());
<b class="nc"><i>3938</i>&nbsp;                nextTagAfterPImplied = null;</b>
<i>3939</i>&nbsp;                inParagraph = true;
<i>3940</i>&nbsp;                impliedP = true;
<i>3941</i>&nbsp;            }
<b class="nc"><i>3942</i>&nbsp;            if (!canInsertTag(t, a, t.isBlock())) {</b>
<b class="nc"><i>3943</i>&nbsp;                return;</b>
<b class="nc"><i>3944</i>&nbsp;            }</b>
<i>3945</i>&nbsp;            if (a.isDefined(IMPLIED)) {
<i>3946</i>&nbsp;                a.removeAttribute(IMPLIED);
<b class="nc"><i>3947</i>&nbsp;            }</b>
<b class="nc"><i>3948</i>&nbsp;            emptyAnchor = false;</b>
<b class="nc"><i>3949</i>&nbsp;            a.addAttributes(charAttr);</b>
<b class="nc"><i>3950</i>&nbsp;            a.addAttribute(StyleConstants.NameAttribute, t);</b>
<b class="nc"><i>3951</i>&nbsp;            char[] one = new char[1];</b>
<i>3952</i>&nbsp;            one[0] = &#39; &#39;;
<i>3953</i>&nbsp;            ElementSpec es = new ElementSpec(
<b class="nc"><i>3954</i>&nbsp;                a.copyAttributes(), ElementSpec.ContentType, one, 0, 1);</b>
<i>3955</i>&nbsp;            parseBuffer.addElement(es);
<b class="nc"><i>3956</i>&nbsp;            // Set this to avoid generating a newline for frames, frames</b>
<i>3957</i>&nbsp;            // shouldn&#39;t have any content, and shouldn&#39;t need a newline.
<i>3958</i>&nbsp;            if (t == HTML.Tag.FRAME) {
<b class="nc"><i>3959</i>&nbsp;                lastWasNewline = true;</b>
<b class="nc"><i>3960</i>&nbsp;            }</b>
<i>3961</i>&nbsp;        }
<i>3962</i>&nbsp;
<i>3963</i>&nbsp;        /**
<b class="nc"><i>3964</i>&nbsp;         * Flushes the current parse buffer into the document.</b>
<b class="nc"><i>3965</i>&nbsp;         * @param endOfStream true if there is no more content to parser</b>
<i>3966</i>&nbsp;         */
<b class="nc"><i>3967</i>&nbsp;        void flushBuffer(boolean endOfStream) throws BadLocationException {</b>
<b class="nc"><i>3968</i>&nbsp;            int oldLength = HTMLDocument.this.getLength();</b>
<i>3969</i>&nbsp;            int size = parseBuffer.size();
<b class="nc"><i>3970</i>&nbsp;            if (endOfStream &amp;&amp; (insertTag != null || insertAfterImplied) &amp;&amp;</b>
<i>3971</i>&nbsp;                size &gt; 0) {
<b class="nc"><i>3972</i>&nbsp;                adjustEndSpecsForPartialInsert();</b>
<i>3973</i>&nbsp;                size = parseBuffer.size();
<i>3974</i>&nbsp;            }
<b class="nc"><i>3975</i>&nbsp;            ElementSpec[] spec = new ElementSpec[size];</b>
<i>3976</i>&nbsp;            parseBuffer.copyInto(spec);
<i>3977</i>&nbsp;
<i>3978</i>&nbsp;            if (oldLength == 0 &amp;&amp; (insertTag == null &amp;&amp; !insertAfterImplied)) {
<i>3979</i>&nbsp;                create(spec);
<b class="nc"><i>3980</i>&nbsp;            } else {</b>
<b class="nc"><i>3981</i>&nbsp;                insert(offset, spec);</b>
<b class="nc"><i>3982</i>&nbsp;            }</b>
<i>3983</i>&nbsp;            parseBuffer.removeAllElements();
<i>3984</i>&nbsp;            offset += HTMLDocument.this.getLength() - oldLength;
<i>3985</i>&nbsp;            flushCount++;
<i>3986</i>&nbsp;        }
<i>3987</i>&nbsp;
<i>3988</i>&nbsp;        /**
<i>3989</i>&nbsp;         * This will be invoked for the last flush, if &lt;code&gt;insertTag&lt;/code&gt;
<i>3990</i>&nbsp;         * is non null.
<i>3991</i>&nbsp;         */
<i>3992</i>&nbsp;        private void adjustEndSpecsForPartialInsert() {
<i>3993</i>&nbsp;            int size = parseBuffer.size();
<i>3994</i>&nbsp;            if (insertTagDepthDelta &lt; 0) {
<i>3995</i>&nbsp;                // When inserting via an insertTag, the depths (of the tree
<i>3996</i>&nbsp;                // being read in, and existing hierarchy) may not match up.
<i>3997</i>&nbsp;                // This attemps to clean it up.
<i>3998</i>&nbsp;                int removeCounter = insertTagDepthDelta;
<i>3999</i>&nbsp;                while (removeCounter &lt; 0 &amp;&amp; size &gt;= 0 &amp;&amp;
<i>4000</i>&nbsp;                        parseBuffer.elementAt(size - 1).
<b class="nc"><i>4001</i>&nbsp;                       getType() == ElementSpec.EndTagType) {</b>
<b class="nc"><i>4002</i>&nbsp;                    parseBuffer.removeElementAt(--size);</b>
<b class="nc"><i>4003</i>&nbsp;                    removeCounter++;</b>
<b class="nc"><i>4004</i>&nbsp;                }</b>
<b class="nc"><i>4005</i>&nbsp;            }</b>
<b class="nc"><i>4006</i>&nbsp;            if (flushCount == 0 &amp;&amp; (!insertAfterImplied ||</b>
<b class="nc"><i>4007</i>&nbsp;                                    !wantsTrailingNewline)) {</b>
<i>4008</i>&nbsp;                // If this starts with content (or popDepth &gt; 0 &amp;&amp;
<i>4009</i>&nbsp;                // pushDepth &gt; 0) and ends with EndTagTypes, make sure
<i>4010</i>&nbsp;                // the last content isn&#39;t a \n, otherwise will end up with
<i>4011</i>&nbsp;                // an extra \n in the middle of content.
<i>4012</i>&nbsp;                int index = 0;
<i>4013</i>&nbsp;                if (pushDepth &gt; 0) {
<i>4014</i>&nbsp;                    if (parseBuffer.elementAt(0).getType() ==
<i>4015</i>&nbsp;                        ElementSpec.ContentType) {
<i>4016</i>&nbsp;                        index++;
<i>4017</i>&nbsp;                    }
<i>4018</i>&nbsp;                }
<i>4019</i>&nbsp;                index += (popDepth + pushDepth);
<i>4020</i>&nbsp;                int cCount = 0;
<i>4021</i>&nbsp;                int cStart = index;
<i>4022</i>&nbsp;                while (index &lt; size &amp;&amp; parseBuffer.elementAt
<i>4023</i>&nbsp;                        (index).getType() == ElementSpec.ContentType) {
<i>4024</i>&nbsp;                    index++;
<i>4025</i>&nbsp;                    cCount++;
<i>4026</i>&nbsp;                }
<i>4027</i>&nbsp;                if (cCount &gt; 1) {
<i>4028</i>&nbsp;                    while (index &lt; size &amp;&amp; parseBuffer.elementAt
<i>4029</i>&nbsp;                            (index).getType() == ElementSpec.EndTagType) {
<i>4030</i>&nbsp;                        index++;
<i>4031</i>&nbsp;                    }
<i>4032</i>&nbsp;                    if (index == size) {
<i>4033</i>&nbsp;                        char[] lastText = parseBuffer.elementAt
<i>4034</i>&nbsp;                                (cStart + cCount - 1).getArray();
<i>4035</i>&nbsp;                        if (lastText.length == 1 &amp;&amp; lastText[0] == NEWLINE[0]){
<i>4036</i>&nbsp;                            index = cStart + cCount - 1;
<i>4037</i>&nbsp;                            while (size &gt; index) {
<i>4038</i>&nbsp;                                parseBuffer.removeElementAt(--size);
<i>4039</i>&nbsp;                            }
<b class="nc"><i>4040</i>&nbsp;                        }</b>
<i>4041</i>&nbsp;                    }
<i>4042</i>&nbsp;                }
<i>4043</i>&nbsp;            }
<i>4044</i>&nbsp;            if (wantsTrailingNewline) {
<i>4045</i>&nbsp;                // Make sure there is in fact a newline
<i>4046</i>&nbsp;                for (int counter = parseBuffer.size() - 1; counter &gt;= 0;
<i>4047</i>&nbsp;                                   counter--) {
<i>4048</i>&nbsp;                    ElementSpec spec = parseBuffer.elementAt(counter);
<i>4049</i>&nbsp;                    if (spec.getType() == ElementSpec.ContentType) {
<i>4050</i>&nbsp;                        if (spec.getArray()[spec.getLength() - 1] != &#39;\n&#39;) {
<i>4051</i>&nbsp;                            SimpleAttributeSet attrs =new SimpleAttributeSet();
<b class="nc"><i>4052</i>&nbsp;</b>
<i>4053</i>&nbsp;                            attrs.addAttribute(StyleConstants.NameAttribute,
<i>4054</i>&nbsp;                                               HTML.Tag.CONTENT);
<i>4055</i>&nbsp;                            parseBuffer.insertElementAt(new ElementSpec(
<i>4056</i>&nbsp;                                    attrs,
<i>4057</i>&nbsp;                                    ElementSpec.ContentType, NEWLINE, 0, 1),
<i>4058</i>&nbsp;                                    counter + 1);
<i>4059</i>&nbsp;                        }
<i>4060</i>&nbsp;                        break;
<i>4061</i>&nbsp;                    }
<i>4062</i>&nbsp;                }
<i>4063</i>&nbsp;            }
<i>4064</i>&nbsp;        }
<i>4065</i>&nbsp;
<i>4066</i>&nbsp;        /**
<b class="nc"><i>4067</i>&nbsp;         * Adds the CSS rules in &lt;code&gt;rules&lt;/code&gt;.</b>
<b class="nc"><i>4068</i>&nbsp;         */</b>
<b class="nc"><i>4069</i>&nbsp;        void addCSSRules(String rules) {</b>
<i>4070</i>&nbsp;            StyleSheet ss = getStyleSheet();
<b class="nc"><i>4071</i>&nbsp;            ss.addRule(rules);</b>
<i>4072</i>&nbsp;        }
<i>4073</i>&nbsp;
<i>4074</i>&nbsp;        /**
<i>4075</i>&nbsp;         * Adds the CSS stylesheet at &lt;code&gt;href&lt;/code&gt; to the known list
<i>4076</i>&nbsp;         * of stylesheets.
<i>4077</i>&nbsp;         */
<b class="nc"><i>4078</i>&nbsp;        void linkCSSStyleSheet(String href) {</b>
<i>4079</i>&nbsp;            URL url;
<i>4080</i>&nbsp;            try {
<i>4081</i>&nbsp;                url = new URL(base, href);
<i>4082</i>&nbsp;            } catch (MalformedURLException mfe) {
<i>4083</i>&nbsp;                try {
<i>4084</i>&nbsp;                    url = new URL(href);
<i>4085</i>&nbsp;                } catch (MalformedURLException mfe2) {
<i>4086</i>&nbsp;                    url = null;
<i>4087</i>&nbsp;                }
<b class="nc"><i>4088</i>&nbsp;            }</b>
<i>4089</i>&nbsp;            if (url != null) {
<i>4090</i>&nbsp;                getStyleSheet().importStyleSheet(url);
<i>4091</i>&nbsp;            }
<i>4092</i>&nbsp;        }
<i>4093</i>&nbsp;
<i>4094</i>&nbsp;        /**
<i>4095</i>&nbsp;         * Returns true if can insert starting at &lt;code&gt;t&lt;/code&gt;. This
<i>4096</i>&nbsp;         * will return false if the insert tag is set, and hasn&#39;t been found
<i>4097</i>&nbsp;         * yet.
<i>4098</i>&nbsp;         */
<i>4099</i>&nbsp;        private boolean canInsertTag(HTML.Tag t, AttributeSet attr,
<i>4100</i>&nbsp;                                     boolean isBlockTag) {
<i>4101</i>&nbsp;            if (!foundInsertTag) {
<i>4102</i>&nbsp;                boolean needPImplied = ((t == HTML.Tag.IMPLIED)
<i>4103</i>&nbsp;                                                          &amp;&amp; (!inParagraph)
<i>4104</i>&nbsp;                                                          &amp;&amp; (!inPre));
<i>4105</i>&nbsp;                if (needPImplied &amp;&amp; (nextTagAfterPImplied != null)) {
<i>4106</i>&nbsp;
<i>4107</i>&nbsp;                    /*
<i>4108</i>&nbsp;                     * If insertTag == null then just proceed to
<i>4109</i>&nbsp;                     * foundInsertTag() call below and return true.
<b class="nc"><i>4110</i>&nbsp;                     */</b>
<b class="nc"><i>4111</i>&nbsp;                    if (insertTag != null) {</b>
<i>4112</i>&nbsp;                        boolean nextTagIsInsertTag =
<i>4113</i>&nbsp;                                isInsertTag(nextTagAfterPImplied);
<i>4114</i>&nbsp;                        if ( (! nextTagIsInsertTag) || (! insertInsertTag) ) {
<i>4115</i>&nbsp;                            return false;
<i>4116</i>&nbsp;                        }
<i>4117</i>&nbsp;                    }
<i>4118</i>&nbsp;                    /*
<i>4119</i>&nbsp;                     *  Proceed to foundInsertTag() call...
<b class="nc"><i>4120</i>&nbsp;                     */</b>
<b class="nc"><i>4121</i>&nbsp;                 } else if ((insertTag != null &amp;&amp; !isInsertTag(t))</b>
<b class="nc"><i>4122</i>&nbsp;                               || (insertAfterImplied</b>
<i>4123</i>&nbsp;                                    &amp;&amp; (attr == null
<b class="nc"><i>4124</i>&nbsp;                                        || attr.isDefined(IMPLIED)</b>
<i>4125</i>&nbsp;                                        || t == HTML.Tag.IMPLIED
<i>4126</i>&nbsp;                                       )
<i>4127</i>&nbsp;                                   )
<i>4128</i>&nbsp;                           ) {
<i>4129</i>&nbsp;                    return false;
<i>4130</i>&nbsp;                }
<i>4131</i>&nbsp;
<i>4132</i>&nbsp;                // Allow the insert if t matches the insert tag, or
<i>4133</i>&nbsp;                // insertAfterImplied is true and the element is implied.
<i>4134</i>&nbsp;                foundInsertTag(isBlockTag);
<b class="nc"><i>4135</i>&nbsp;                if (!insertInsertTag) {</b>
<i>4136</i>&nbsp;                    return false;
<i>4137</i>&nbsp;                }
<i>4138</i>&nbsp;            }
<i>4139</i>&nbsp;            return true;
<i>4140</i>&nbsp;        }
<i>4141</i>&nbsp;
<i>4142</i>&nbsp;        private boolean isInsertTag(HTML.Tag tag) {
<i>4143</i>&nbsp;            return (insertTag == tag);
<i>4144</i>&nbsp;        }
<i>4145</i>&nbsp;
<i>4146</i>&nbsp;        private void foundInsertTag(boolean isBlockTag) {
<i>4147</i>&nbsp;            foundInsertTag = true;
<i>4148</i>&nbsp;            if (!insertAfterImplied &amp;&amp; (popDepth &gt; 0 || pushDepth &gt; 0)) {
<i>4149</i>&nbsp;                try {
<i>4150</i>&nbsp;                    if (offset == 0 || !getText(offset - 1, 1).equals(&quot;\n&quot;)) {
<i>4151</i>&nbsp;                        // Need to insert a newline.
<i>4152</i>&nbsp;                        AttributeSet newAttrs = null;
<b class="nc"><i>4153</i>&nbsp;                        boolean joinP = true;</b>
<b class="nc"><i>4154</i>&nbsp;</b>
<i>4155</i>&nbsp;                        if (offset != 0) {
<i>4156</i>&nbsp;                            // Determine if we can use JoinPrevious, we can&#39;t
<i>4157</i>&nbsp;                            // if the Element has some attributes that are
<i>4158</i>&nbsp;                            // not meant to be duplicated.
<i>4159</i>&nbsp;                            Element charElement = getCharacterElement
<i>4160</i>&nbsp;                                                    (offset - 1);
<i>4161</i>&nbsp;                            AttributeSet attrs = charElement.getAttributes();
<i>4162</i>&nbsp;
<b class="nc"><i>4163</i>&nbsp;                            if (attrs.isDefined(StyleConstants.</b>
<b class="nc"><i>4164</i>&nbsp;                                                ComposedTextAttribute)) {</b>
<b class="nc"><i>4165</i>&nbsp;                                joinP = false;</b>
<i>4166</i>&nbsp;                            }
<b class="nc"><i>4167</i>&nbsp;                            else {</b>
<i>4168</i>&nbsp;                                Object name = attrs.getAttribute
<i>4169</i>&nbsp;                                              (StyleConstants.NameAttribute);
<i>4170</i>&nbsp;                                if (name instanceof HTML.Tag) {
<i>4171</i>&nbsp;                                    HTML.Tag tag = (HTML.Tag)name;
<i>4172</i>&nbsp;                                    if (tag == HTML.Tag.IMG ||
<i>4173</i>&nbsp;                                        tag == HTML.Tag.HR ||
<i>4174</i>&nbsp;                                        tag == HTML.Tag.COMMENT ||
<i>4175</i>&nbsp;                                        (tag instanceof HTML.UnknownTag)) {
<i>4176</i>&nbsp;                                        joinP = false;
<i>4177</i>&nbsp;                                    }
<b class="nc"><i>4178</i>&nbsp;                                }</b>
<i>4179</i>&nbsp;                            }
<i>4180</i>&nbsp;                        }
<i>4181</i>&nbsp;                        if (!joinP) {
<i>4182</i>&nbsp;                            // If not joining with the previous element, be
<i>4183</i>&nbsp;                            // sure and set the name (otherwise it will be
<i>4184</i>&nbsp;                            // inherited).
<i>4185</i>&nbsp;                            newAttrs = new SimpleAttributeSet();
<i>4186</i>&nbsp;                            ((SimpleAttributeSet)newAttrs).addAttribute
<i>4187</i>&nbsp;                                              (StyleConstants.NameAttribute,
<i>4188</i>&nbsp;                                               HTML.Tag.CONTENT);
<i>4189</i>&nbsp;                        }
<b class="nc"><i>4190</i>&nbsp;                        ElementSpec es = new ElementSpec(newAttrs,</b>
<b class="nc"><i>4191</i>&nbsp;                                     ElementSpec.ContentType, NEWLINE, 0,</b>
<i>4192</i>&nbsp;                                     NEWLINE.length);
<i>4193</i>&nbsp;                        if (joinP) {
<i>4194</i>&nbsp;                            es.setDirection(ElementSpec.
<i>4195</i>&nbsp;                                            JoinPreviousDirection);
<b class="nc"><i>4196</i>&nbsp;                        }</b>
<b class="nc"><i>4197</i>&nbsp;                        parseBuffer.addElement(es);</b>
<i>4198</i>&nbsp;                    }
<i>4199</i>&nbsp;                } catch (BadLocationException ble) {}
<i>4200</i>&nbsp;            }
<i>4201</i>&nbsp;            // pops
<i>4202</i>&nbsp;            for (int counter = 0; counter &lt; popDepth; counter++) {
<i>4203</i>&nbsp;                parseBuffer.addElement(new ElementSpec(null, ElementSpec.
<i>4204</i>&nbsp;                                                       EndTagType));
<i>4205</i>&nbsp;            }
<i>4206</i>&nbsp;            // pushes
<i>4207</i>&nbsp;            for (int counter = 0; counter &lt; pushDepth; counter++) {
<i>4208</i>&nbsp;                ElementSpec es = new ElementSpec(null, ElementSpec.
<i>4209</i>&nbsp;                                                 StartTagType);
<i>4210</i>&nbsp;                es.setDirection(ElementSpec.JoinNextDirection);
<i>4211</i>&nbsp;                parseBuffer.addElement(es);
<i>4212</i>&nbsp;            }
<i>4213</i>&nbsp;            insertTagDepthDelta = depthTo(Math.max(0, offset - 1)) -
<i>4214</i>&nbsp;                                  popDepth + pushDepth - inBlock;
<i>4215</i>&nbsp;            if (isBlockTag) {
<i>4216</i>&nbsp;                // A start spec will be added (for this tag), so we account
<i>4217</i>&nbsp;                // for it here.
<i>4218</i>&nbsp;                insertTagDepthDelta++;
<i>4219</i>&nbsp;            }
<i>4220</i>&nbsp;            else {
<i>4221</i>&nbsp;                // An implied paragraph close (end spec) is going to be added,
<i>4222</i>&nbsp;                // so we account for it here.
<i>4223</i>&nbsp;                insertTagDepthDelta--;
<i>4224</i>&nbsp;                inParagraph = true;
<i>4225</i>&nbsp;                lastWasNewline = false;
<i>4226</i>&nbsp;            }
<i>4227</i>&nbsp;        }
<i>4228</i>&nbsp;
<i>4229</i>&nbsp;        /**
<i>4230</i>&nbsp;         * This is set to true when and end is invoked for {@literal &lt;html&gt;}.
<i>4231</i>&nbsp;         */
<i>4232</i>&nbsp;        private boolean receivedEndHTML;
<i>4233</i>&nbsp;        /** Number of times &lt;code&gt;flushBuffer&lt;/code&gt; has been invoked. */
<i>4234</i>&nbsp;        private int flushCount;
<i>4235</i>&nbsp;        /** If true, behavior is similar to insertTag, but instead of
<i>4236</i>&nbsp;         * waiting for insertTag will wait for first Element without
<i>4237</i>&nbsp;         * an &#39;implied&#39; attribute and begin inserting then. */
<i>4238</i>&nbsp;        private boolean insertAfterImplied;
<i>4239</i>&nbsp;        /** This is only used if insertAfterImplied is true. If false, only
<i>4240</i>&nbsp;         * inserting content, and there is a trailing newline it is removed. */
<i>4241</i>&nbsp;        private boolean wantsTrailingNewline;
<i>4242</i>&nbsp;        int threshold;
<i>4243</i>&nbsp;        int offset;
<i>4244</i>&nbsp;        boolean inParagraph = false;
<i>4245</i>&nbsp;        boolean impliedP = false;
<i>4246</i>&nbsp;        boolean inPre = false;
<i>4247</i>&nbsp;        boolean inTextArea = false;
<i>4248</i>&nbsp;        TextAreaDocument textAreaDocument = null;
<i>4249</i>&nbsp;        boolean inTitle = false;
<i>4250</i>&nbsp;        boolean lastWasNewline = true;
<i>4251</i>&nbsp;        boolean emptyAnchor;
<i>4252</i>&nbsp;        /** True if (!emptyDocument &amp;amp;&amp;amp; insertTag == null), this is used so
<i>4253</i>&nbsp;         * much it is cached. */
<i>4254</i>&nbsp;        boolean midInsert;
<i>4255</i>&nbsp;        /** True when the body has been encountered. */
<i>4256</i>&nbsp;        boolean inBody;
<i>4257</i>&nbsp;        /** If non null, gives parent Tag that insert is to happen at. */
<i>4258</i>&nbsp;        HTML.Tag insertTag;
<i>4259</i>&nbsp;        /** If true, the insertTag is inserted, otherwise elements after
<i>4260</i>&nbsp;         * the insertTag is found are inserted. */
<i>4261</i>&nbsp;        boolean insertInsertTag;
<i>4262</i>&nbsp;        /** Set to true when insertTag has been found. */
<i>4263</i>&nbsp;        boolean foundInsertTag;
<i>4264</i>&nbsp;        /** When foundInsertTag is set to true, this will be updated to
<i>4265</i>&nbsp;         * reflect the delta between the two structures. That is, it
<i>4266</i>&nbsp;         * will be the depth the inserts are happening at minus the
<i>4267</i>&nbsp;         * depth of the tags being passed in. A value of 0 (the common
<i>4268</i>&nbsp;         * case) indicates the structures match, a value greater than 0 indicates
<i>4269</i>&nbsp;         * the insert is happening at a deeper depth than the stream is
<i>4270</i>&nbsp;         * parsing, and a value less than 0 indicates the insert is happening earlier
<i>4271</i>&nbsp;         * in the tree that the parser thinks and that we will need to remove
<i>4272</i>&nbsp;         * EndTagType specs in the flushBuffer method.
<i>4273</i>&nbsp;         */
<i>4274</i>&nbsp;        int insertTagDepthDelta;
<i>4275</i>&nbsp;        /** How many parents to ascend before insert new elements. */
<i>4276</i>&nbsp;        int popDepth;
<i>4277</i>&nbsp;        /** How many parents to descend (relative to popDepth) before
<i>4278</i>&nbsp;         * inserting. */
<i>4279</i>&nbsp;        int pushDepth;
<i>4280</i>&nbsp;        /** Last Map that was encountered. */
<i>4281</i>&nbsp;        Map lastMap;
<i>4282</i>&nbsp;        /** Set to true when a style element is encountered. */
<i>4283</i>&nbsp;        boolean inStyle = false;
<i>4284</i>&nbsp;        /** Name of style to use. Obtained from Meta tag. */
<i>4285</i>&nbsp;        String defaultStyle;
<i>4286</i>&nbsp;        /** Vector describing styles that should be include. Will consist
<i>4287</i>&nbsp;         * of a bunch of HTML.Tags, which will either be:
<i>4288</i>&nbsp;         * &lt;p&gt;LINK: in which case it is followed by an AttributeSet
<i>4289</i>&nbsp;         * &lt;p&gt;STYLE: in which case the following element is a String
<i>4290</i>&nbsp;         * indicating the type (may be null), and the elements following
<i>4291</i>&nbsp;         * it until the next HTML.Tag are the rules as Strings.
<i>4292</i>&nbsp;         */
<i>4293</i>&nbsp;        Vector&lt;Object&gt; styles;
<i>4294</i>&nbsp;        /** True if inside the head tag. */
<i>4295</i>&nbsp;        boolean inHead = false;
<i>4296</i>&nbsp;        /** Set to true if the style language is text/css. Since this is
<i>4297</i>&nbsp;         * used alot, it is cached. */
<i>4298</i>&nbsp;        boolean isStyleCSS;
<i>4299</i>&nbsp;        /** True if inserting into an empty document. */
<i>4300</i>&nbsp;        boolean emptyDocument;
<i>4301</i>&nbsp;        /** Attributes from a style Attribute. */
<i>4302</i>&nbsp;        AttributeSet styleAttributes;
<i>4303</i>&nbsp;
<i>4304</i>&nbsp;        /**
<i>4305</i>&nbsp;         * Current option, if in an option element (needed to
<i>4306</i>&nbsp;         * load the label.
<i>4307</i>&nbsp;         */
<i>4308</i>&nbsp;        Option option;
<i>4309</i>&nbsp;
<i>4310</i>&nbsp;        /**
<i>4311</i>&nbsp;         * Buffer to keep building elements.
<i>4312</i>&nbsp;         */
<i>4313</i>&nbsp;        protected Vector&lt;ElementSpec&gt; parseBuffer = new Vector&lt;ElementSpec&gt;();
<i>4314</i>&nbsp;        /**
<i>4315</i>&nbsp;         * Current character attribute set.
<i>4316</i>&nbsp;         */
<i>4317</i>&nbsp;        protected MutableAttributeSet charAttr = new TaggedAttributeSet();
<i>4318</i>&nbsp;        Stack&lt;AttributeSet&gt; charAttrStack = new Stack&lt;AttributeSet&gt;();
<i>4319</i>&nbsp;        Hashtable&lt;HTML.Tag, TagAction&gt; tagMap;
<i>4320</i>&nbsp;        int inBlock = 0;
<i>4321</i>&nbsp;
<i>4322</i>&nbsp;        /**
<i>4323</i>&nbsp;         * This attribute is sometimes used to refer to next tag
<i>4324</i>&nbsp;         * to be handled after p-implied when the latter is
<i>4325</i>&nbsp;         * the current tag which is being handled.
<i>4326</i>&nbsp;         */
<i>4327</i>&nbsp;        private HTML.Tag nextTagAfterPImplied = null;
<i>4328</i>&nbsp;    }
<i>4329</i>&nbsp;
<i>4330</i>&nbsp;
<i>4331</i>&nbsp;    /**
<i>4332</i>&nbsp;     * Used by StyleSheet to determine when to avoid removing HTML.Tags
<i>4333</i>&nbsp;     * matching StyleConstants.
<i>4334</i>&nbsp;     */
<i>4335</i>&nbsp;    static class TaggedAttributeSet extends SimpleAttributeSet {
<i>4336</i>&nbsp;        TaggedAttributeSet() {
<i>4337</i>&nbsp;            super();
<i>4338</i>&nbsp;        }
<i>4339</i>&nbsp;    }
<i>4340</i>&nbsp;
<i>4341</i>&nbsp;
<i>4342</i>&nbsp;    /**
<i>4343</i>&nbsp;     * An element that represents a chunk of text that has
<i>4344</i>&nbsp;     * a set of HTML character level attributes assigned to
<i>4345</i>&nbsp;     * it.
<i>4346</i>&nbsp;     */
<i>4347</i>&nbsp;    public class RunElement extends LeafElement {
<i>4348</i>&nbsp;
<i>4349</i>&nbsp;        /**
<i>4350</i>&nbsp;         * Constructs an element that represents content within the
<i>4351</i>&nbsp;         * document (has no children).
<i>4352</i>&nbsp;         *
<i>4353</i>&nbsp;         * @param parent  the parent element
<i>4354</i>&nbsp;         * @param a       the element attributes
<i>4355</i>&nbsp;         * @param offs0   the start offset (must be at least 0)
<i>4356</i>&nbsp;         * @param offs1   the end offset (must be at least offs0)
<i>4357</i>&nbsp;         * @since 1.4
<i>4358</i>&nbsp;         */
<i>4359</i>&nbsp;        public RunElement(Element parent, AttributeSet a, int offs0, int offs1) {
<i>4360</i>&nbsp;            super(parent, a, offs0, offs1);
<i>4361</i>&nbsp;        }
<i>4362</i>&nbsp;
<i>4363</i>&nbsp;        /**
<i>4364</i>&nbsp;         * Gets the name of the element.
<i>4365</i>&nbsp;         *
<i>4366</i>&nbsp;         * @return the name, null if none
<i>4367</i>&nbsp;         */
<i>4368</i>&nbsp;        public String getName() {
<i>4369</i>&nbsp;            Object o = getAttribute(StyleConstants.NameAttribute);
<i>4370</i>&nbsp;            if (o != null) {
<i>4371</i>&nbsp;                return o.toString();
<i>4372</i>&nbsp;            }
<i>4373</i>&nbsp;            return super.getName();
<i>4374</i>&nbsp;        }
<i>4375</i>&nbsp;
<i>4376</i>&nbsp;        /**
<i>4377</i>&nbsp;         * Gets the resolving parent.  HTML attributes are not inherited
<i>4378</i>&nbsp;         * at the model level so we override this to return null.
<i>4379</i>&nbsp;         *
<i>4380</i>&nbsp;         * @return null, there are none
<i>4381</i>&nbsp;         * @see AttributeSet#getResolveParent
<i>4382</i>&nbsp;         */
<i>4383</i>&nbsp;        public AttributeSet getResolveParent() {
<i>4384</i>&nbsp;            return null;
<i>4385</i>&nbsp;        }
<i>4386</i>&nbsp;    }
<i>4387</i>&nbsp;
<i>4388</i>&nbsp;    /**
<i>4389</i>&nbsp;     * An element that represents a structural &lt;em&gt;block&lt;/em&gt; of
<i>4390</i>&nbsp;     * HTML.
<i>4391</i>&nbsp;     */
<i>4392</i>&nbsp;    public class BlockElement extends BranchElement {
<i>4393</i>&nbsp;
<i>4394</i>&nbsp;        /**
<i>4395</i>&nbsp;         * Constructs a composite element that initially contains
<i>4396</i>&nbsp;         * no children.
<i>4397</i>&nbsp;         *
<i>4398</i>&nbsp;         * @param parent  the parent element
<i>4399</i>&nbsp;         * @param a       the attributes for the element
<i>4400</i>&nbsp;         * @since 1.4
<i>4401</i>&nbsp;         */
<i>4402</i>&nbsp;        public BlockElement(Element parent, AttributeSet a) {
<i>4403</i>&nbsp;            super(parent, a);
<i>4404</i>&nbsp;        }
<i>4405</i>&nbsp;
<i>4406</i>&nbsp;        /**
<i>4407</i>&nbsp;         * Gets the name of the element.
<i>4408</i>&nbsp;         *
<i>4409</i>&nbsp;         * @return the name, null if none
<i>4410</i>&nbsp;         */
<i>4411</i>&nbsp;        public String getName() {
<i>4412</i>&nbsp;            Object o = getAttribute(StyleConstants.NameAttribute);
<i>4413</i>&nbsp;            if (o != null) {
<i>4414</i>&nbsp;                return o.toString();
<i>4415</i>&nbsp;            }
<i>4416</i>&nbsp;            return super.getName();
<i>4417</i>&nbsp;        }
<i>4418</i>&nbsp;
<i>4419</i>&nbsp;        /**
<i>4420</i>&nbsp;         * Gets the resolving parent.  HTML attributes are not inherited
<i>4421</i>&nbsp;         * at the model level so we override this to return null.
<i>4422</i>&nbsp;         *
<i>4423</i>&nbsp;         * @return null, there are none
<i>4424</i>&nbsp;         * @see AttributeSet#getResolveParent
<i>4425</i>&nbsp;         */
<i>4426</i>&nbsp;        public AttributeSet getResolveParent() {
<i>4427</i>&nbsp;            return null;
<i>4428</i>&nbsp;        }
<i>4429</i>&nbsp;
<i>4430</i>&nbsp;    }
<i>4431</i>&nbsp;
<i>4432</i>&nbsp;
<i>4433</i>&nbsp;    /**
<i>4434</i>&nbsp;     * Document that allows you to set the maximum length of the text.
<i>4435</i>&nbsp;     */
<i>4436</i>&nbsp;    private static class FixedLengthDocument extends PlainDocument {
<i>4437</i>&nbsp;        private int maxLength;
<i>4438</i>&nbsp;
<i>4439</i>&nbsp;        public FixedLengthDocument(int maxLength) {
<i>4440</i>&nbsp;            this.maxLength = maxLength;
<i>4441</i>&nbsp;        }
<i>4442</i>&nbsp;
<i>4443</i>&nbsp;        public void insertString(int offset, String str, AttributeSet a)
<i>4444</i>&nbsp;            throws BadLocationException {
<i>4445</i>&nbsp;            if (str != null &amp;&amp; str.length() + getLength() &lt;= maxLength) {
<i>4446</i>&nbsp;                super.insertString(offset, str, a);
<i>4447</i>&nbsp;            }
<i>4448</i>&nbsp;        }
<i>4449</i>&nbsp;    }
<i>4450</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
