


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: ClassValue</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang</a> ]
</div>

<h1>Coverage Summary for Class: ClassValue (java.lang)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 46)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ClassValue$ClassValueMap</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 150)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassValue$Entry</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassValue$Identity</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassValue$Version</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 223)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.util.WeakHashMap;
<i>29</i>&nbsp;import java.lang.ref.WeakReference;
<i>30</i>&nbsp;import java.util.concurrent.atomic.AtomicInteger;
<i>31</i>&nbsp;
<i>32</i>&nbsp;import static java.lang.ClassValue.ClassValueMap.probeHomeLocation;
<i>33</i>&nbsp;import static java.lang.ClassValue.ClassValueMap.probeBackupLocations;
<i>34</i>&nbsp;
<i>35</i>&nbsp;/**
<i>36</i>&nbsp; * Lazily associate a computed value with (potentially) every type.
<i>37</i>&nbsp; * For example, if a dynamic language needs to construct a message dispatch
<i>38</i>&nbsp; * table for each class encountered at a message send call site,
<i>39</i>&nbsp; * it can use a {@code ClassValue} to cache information needed to
<i>40</i>&nbsp; * perform the message send quickly, for each class encountered.
<i>41</i>&nbsp; * @author John Rose, JSR 292 EG
<i>42</i>&nbsp; * @since 1.7
<i>43</i>&nbsp; */
<i>44</i>&nbsp;public abstract class ClassValue&lt;T&gt; {
<i>45</i>&nbsp;    /**
<i>46</i>&nbsp;     * Sole constructor.  (For invocation by subclass constructors, typically
<i>47</i>&nbsp;     * implicit.)
<i>48</i>&nbsp;     */
<i>49</i>&nbsp;    protected ClassValue() {
<b class="nc"><i>50</i>&nbsp;    }</b>
<i>51</i>&nbsp;
<i>52</i>&nbsp;    /**
<i>53</i>&nbsp;     * Computes the given class&#39;s derived value for this {@code ClassValue}.
<i>54</i>&nbsp;     * &lt;p&gt;
<i>55</i>&nbsp;     * This method will be invoked within the first thread that accesses
<i>56</i>&nbsp;     * the value with the {@link #get get} method.
<i>57</i>&nbsp;     * &lt;p&gt;
<i>58</i>&nbsp;     * Normally, this method is invoked at most once per class,
<i>59</i>&nbsp;     * but it may be invoked again if there has been a call to
<i>60</i>&nbsp;     * {@link #remove remove}.
<i>61</i>&nbsp;     * &lt;p&gt;
<i>62</i>&nbsp;     * If this method throws an exception, the corresponding call to {@code get}
<i>63</i>&nbsp;     * will terminate abnormally with that exception, and no class value will be recorded.
<i>64</i>&nbsp;     *
<i>65</i>&nbsp;     * @param type the type whose class value must be computed
<i>66</i>&nbsp;     * @return the newly computed value associated with this {@code ClassValue}, for the given class or interface
<i>67</i>&nbsp;     * @see #get
<i>68</i>&nbsp;     * @see #remove
<i>69</i>&nbsp;     */
<i>70</i>&nbsp;    protected abstract T computeValue(Class&lt;?&gt; type);
<i>71</i>&nbsp;
<i>72</i>&nbsp;    /**
<i>73</i>&nbsp;     * Returns the value for the given class.
<i>74</i>&nbsp;     * If no value has yet been computed, it is obtained by
<i>75</i>&nbsp;     * an invocation of the {@link #computeValue computeValue} method.
<i>76</i>&nbsp;     * &lt;p&gt;
<i>77</i>&nbsp;     * The actual installation of the value on the class
<i>78</i>&nbsp;     * is performed atomically.
<i>79</i>&nbsp;     * At that point, if several racing threads have
<i>80</i>&nbsp;     * computed values, one is chosen, and returned to
<i>81</i>&nbsp;     * all the racing threads.
<i>82</i>&nbsp;     * &lt;p&gt;
<i>83</i>&nbsp;     * The {@code type} parameter is typically a class, but it may be any type,
<i>84</i>&nbsp;     * such as an interface, a primitive type (like {@code int.class}), or {@code void.class}.
<i>85</i>&nbsp;     * &lt;p&gt;
<i>86</i>&nbsp;     * In the absence of {@code remove} calls, a class value has a simple
<i>87</i>&nbsp;     * state diagram:  uninitialized and initialized.
<i>88</i>&nbsp;     * When {@code remove} calls are made,
<i>89</i>&nbsp;     * the rules for value observation are more complex.
<i>90</i>&nbsp;     * See the documentation for {@link #remove remove} for more information.
<i>91</i>&nbsp;     *
<i>92</i>&nbsp;     * @param type the type whose class value must be computed or retrieved
<i>93</i>&nbsp;     * @return the current value associated with this {@code ClassValue}, for the given class or interface
<i>94</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>95</i>&nbsp;     * @see #remove
<i>96</i>&nbsp;     * @see #computeValue
<i>97</i>&nbsp;     */
<i>98</i>&nbsp;    public T get(Class&lt;?&gt; type) {
<i>99</i>&nbsp;        // non-racing this.hashCodeForCache : final int
<i>100</i>&nbsp;        Entry&lt;?&gt;[] cache;
<i>101</i>&nbsp;        Entry&lt;T&gt; e = probeHomeLocation(cache = getCacheCarefully(type), this);
<b class="nc"><i>102</i>&nbsp;        // racing e : current value &lt;=&gt; stale value from current cache or from stale cache</b>
<i>103</i>&nbsp;        // invariant:  e is null or an Entry with readable Entry.version and Entry.value
<i>104</i>&nbsp;        if (match(e))
<b class="nc"><i>105</i>&nbsp;            // invariant:  No false positive matches.  False negatives are OK if rare.</b>
<i>106</i>&nbsp;            // The key fact that makes this work: if this.version == e.version,
<i>107</i>&nbsp;            // then this thread has a right to observe (final) e.value.
<i>108</i>&nbsp;            return e.value();
<b class="nc"><i>109</i>&nbsp;        // The fast path can fail for any of these reasons:</b>
<i>110</i>&nbsp;        // 1. no entry has been computed yet
<i>111</i>&nbsp;        // 2. hash code collision (before or after reduction mod cache.length)
<i>112</i>&nbsp;        // 3. an entry has been removed (either on this type or another)
<i>113</i>&nbsp;        // 4. the GC has somehow managed to delete e.version and clear the reference
<i>114</i>&nbsp;        return getFromBackup(cache, type);
<b class="nc"><i>115</i>&nbsp;    }</b>
<i>116</i>&nbsp;
<i>117</i>&nbsp;    /**
<i>118</i>&nbsp;     * Removes the associated value for the given class.
<i>119</i>&nbsp;     * If this value is subsequently {@linkplain #get read} for the same class,
<i>120</i>&nbsp;     * its value will be reinitialized by invoking its {@link #computeValue computeValue} method.
<i>121</i>&nbsp;     * This may result in an additional invocation of the
<i>122</i>&nbsp;     * {@code computeValue} method for the given class.
<i>123</i>&nbsp;     * &lt;p&gt;
<i>124</i>&nbsp;     * In order to explain the interaction between {@code get} and {@code remove} calls,
<i>125</i>&nbsp;     * we must model the state transitions of a class value to take into account
<i>126</i>&nbsp;     * the alternation between uninitialized and initialized states.
<i>127</i>&nbsp;     * To do this, number these states sequentially from zero, and note that
<i>128</i>&nbsp;     * uninitialized (or removed) states are numbered with even numbers,
<i>129</i>&nbsp;     * while initialized (or re-initialized) states have odd numbers.
<i>130</i>&nbsp;     * &lt;p&gt;
<i>131</i>&nbsp;     * When a thread {@code T} removes a class value in state {@code 2N},
<i>132</i>&nbsp;     * nothing happens, since the class value is already uninitialized.
<i>133</i>&nbsp;     * Otherwise, the state is advanced atomically to {@code 2N+1}.
<i>134</i>&nbsp;     * &lt;p&gt;
<i>135</i>&nbsp;     * When a thread {@code T} queries a class value in state {@code 2N},
<i>136</i>&nbsp;     * the thread first attempts to initialize the class value to state {@code 2N+1}
<i>137</i>&nbsp;     * by invoking {@code computeValue} and installing the resulting value.
<i>138</i>&nbsp;     * &lt;p&gt;
<i>139</i>&nbsp;     * When {@code T} attempts to install the newly computed value,
<i>140</i>&nbsp;     * if the state is still at {@code 2N}, the class value will be initialized
<i>141</i>&nbsp;     * with the computed value, advancing it to state {@code 2N+1}.
<i>142</i>&nbsp;     * &lt;p&gt;
<i>143</i>&nbsp;     * Otherwise, whether the new state is even or odd,
<i>144</i>&nbsp;     * {@code T} will discard the newly computed value
<i>145</i>&nbsp;     * and retry the {@code get} operation.
<i>146</i>&nbsp;     * &lt;p&gt;
<i>147</i>&nbsp;     * Discarding and retrying is an important proviso,
<i>148</i>&nbsp;     * since otherwise {@code T} could potentially install
<i>149</i>&nbsp;     * a disastrously stale value.  For example:
<i>150</i>&nbsp;     * &lt;ul&gt;
<i>151</i>&nbsp;     * &lt;li&gt;{@code T} calls {@code CV.get(C)} and sees state {@code 2N}
<i>152</i>&nbsp;     * &lt;li&gt;{@code T} quickly computes a time-dependent value {@code V0} and gets ready to install it
<i>153</i>&nbsp;     * &lt;li&gt;{@code T} is hit by an unlucky paging or scheduling event, and goes to sleep for a long time
<i>154</i>&nbsp;     * &lt;li&gt;...meanwhile, {@code T2} also calls {@code CV.get(C)} and sees state {@code 2N}
<i>155</i>&nbsp;     * &lt;li&gt;{@code T2} quickly computes a similar time-dependent value {@code V1} and installs it on {@code CV.get(C)}
<i>156</i>&nbsp;     * &lt;li&gt;{@code T2} (or a third thread) then calls {@code CV.remove(C)}, undoing {@code T2}&#39;s work
<i>157</i>&nbsp;     * &lt;li&gt; the previous actions of {@code T2} are repeated several times
<i>158</i>&nbsp;     * &lt;li&gt; also, the relevant computed values change over time: {@code V1}, {@code V2}, ...
<i>159</i>&nbsp;     * &lt;li&gt;...meanwhile, {@code T} wakes up and attempts to install {@code V0}; &lt;em&gt;this must fail&lt;/em&gt;
<i>160</i>&nbsp;     * &lt;/ul&gt;
<i>161</i>&nbsp;     * We can assume in the above scenario that {@code CV.computeValue} uses locks to properly
<i>162</i>&nbsp;     * observe the time-dependent states as it computes {@code V1}, etc.
<i>163</i>&nbsp;     * This does not remove the threat of a stale value, since there is a window of time
<i>164</i>&nbsp;     * between the return of {@code computeValue} in {@code T} and the installation
<i>165</i>&nbsp;     * of the new value.  No user synchronization is possible during this time.
<i>166</i>&nbsp;     *
<i>167</i>&nbsp;     * @param type the type whose class value must be removed
<i>168</i>&nbsp;     * @throws NullPointerException if the argument is null
<i>169</i>&nbsp;     */
<i>170</i>&nbsp;    public void remove(Class&lt;?&gt; type) {
<i>171</i>&nbsp;        ClassValueMap map = getMap(type);
<b class="nc"><i>172</i>&nbsp;        map.removeEntry(this);</b>
<b class="nc"><i>173</i>&nbsp;    }</b>
<i>174</i>&nbsp;
<i>175</i>&nbsp;    // Possible functionality for JSR 292 MR 1
<i>176</i>&nbsp;    /*public*/ void put(Class&lt;?&gt; type, T value) {
<i>177</i>&nbsp;        ClassValueMap map = getMap(type);
<b class="nc"><i>178</i>&nbsp;        map.changeEntry(this, value);</b>
<b class="nc"><i>179</i>&nbsp;    }</b>
<i>180</i>&nbsp;
<i>181</i>&nbsp;    /// --------
<i>182</i>&nbsp;    /// Implementation...
<i>183</i>&nbsp;    /// --------
<i>184</i>&nbsp;
<i>185</i>&nbsp;    /** Return the cache, if it exists, else a dummy empty cache. */
<i>186</i>&nbsp;    private static Entry&lt;?&gt;[] getCacheCarefully(Class&lt;?&gt; type) {
<i>187</i>&nbsp;        // racing type.classValueMap{.cacheArray} : null =&gt; new Entry[X] &lt;=&gt; new Entry[Y]
<i>188</i>&nbsp;        ClassValueMap map = type.classValueMap;
<b class="nc"><i>189</i>&nbsp;        if (map == null)  return EMPTY_CACHE;</b>
<b class="nc"><i>190</i>&nbsp;        Entry&lt;?&gt;[] cache = map.getCache();</b>
<b class="nc"><i>191</i>&nbsp;        return cache;</b>
<b class="nc"><i>192</i>&nbsp;        // invariant:  returned value is safe to dereference and check for an Entry</b>
<i>193</i>&nbsp;    }
<i>194</i>&nbsp;
<i>195</i>&nbsp;    /** Initial, one-element, empty cache used by all Class instances.  Must never be filled. */
<i>196</i>&nbsp;    private static final Entry&lt;?&gt;[] EMPTY_CACHE = { null };
<b class="nc"><i>197</i>&nbsp;</b>
<i>198</i>&nbsp;    /**
<i>199</i>&nbsp;     * Slow tail of ClassValue.get to retry at nearby locations in the cache,
<i>200</i>&nbsp;     * or take a slow lock and check the hash table.
<i>201</i>&nbsp;     * Called only if the first probe was empty or a collision.
<i>202</i>&nbsp;     * This is a separate method, so compilers can process it independently.
<i>203</i>&nbsp;     */
<i>204</i>&nbsp;    private T getFromBackup(Entry&lt;?&gt;[] cache, Class&lt;?&gt; type) {
<i>205</i>&nbsp;        Entry&lt;T&gt; e = probeBackupLocations(cache, this);
<b class="nc"><i>206</i>&nbsp;        if (e != null)</b>
<b class="nc"><i>207</i>&nbsp;            return e.value();</b>
<b class="nc"><i>208</i>&nbsp;        return getFromHashMap(type);</b>
<b class="nc"><i>209</i>&nbsp;    }</b>
<i>210</i>&nbsp;
<i>211</i>&nbsp;    // Hack to suppress warnings on the (T) cast, which is a no-op.
<i>212</i>&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
<i>213</i>&nbsp;    Entry&lt;T&gt; castEntry(Entry&lt;?&gt; e) { return (Entry&lt;T&gt;) e; }
<b class="nc"><i>214</i>&nbsp;</b>
<i>215</i>&nbsp;    /** Called when the fast path of get fails, and cache reprobe also fails.
<i>216</i>&nbsp;     */
<i>217</i>&nbsp;    private T getFromHashMap(Class&lt;?&gt; type) {
<i>218</i>&nbsp;        // The fail-safe recovery is to fall back to the underlying classValueMap.
<i>219</i>&nbsp;        ClassValueMap map = getMap(type);
<b class="nc"><i>220</i>&nbsp;        for (;;) {</b>
<i>221</i>&nbsp;            Entry&lt;T&gt; e = map.startEntry(this);
<b class="nc"><i>222</i>&nbsp;            if (!e.isPromise())</b>
<b class="nc"><i>223</i>&nbsp;                return e.value();</b>
<b class="nc"><i>224</i>&nbsp;            try {</b>
<i>225</i>&nbsp;                // Try to make a real entry for the promised version.
<i>226</i>&nbsp;                e = makeEntry(e.version(), computeValue(type));
<b class="nc"><i>227</i>&nbsp;            } finally {</b>
<i>228</i>&nbsp;                // Whether computeValue throws or returns normally,
<i>229</i>&nbsp;                // be sure to remove the empty entry.
<i>230</i>&nbsp;                e = map.finishEntry(this, e);
<b class="nc"><i>231</i>&nbsp;            }</b>
<b class="nc"><i>232</i>&nbsp;            if (e != null)</b>
<b class="nc"><i>233</i>&nbsp;                return e.value();</b>
<b class="nc"><i>234</i>&nbsp;            // else try again, in case a racing thread called remove (so e == null)</b>
<i>235</i>&nbsp;        }
<b class="nc"><i>236</i>&nbsp;    }</b>
<i>237</i>&nbsp;
<i>238</i>&nbsp;    /** Check that e is non-null, matches this ClassValue, and is live. */
<i>239</i>&nbsp;    boolean match(Entry&lt;?&gt; e) {
<i>240</i>&nbsp;        // racing e.version : null (blank) =&gt; unique Version token =&gt; null (GC-ed version)
<i>241</i>&nbsp;        // non-racing this.version : v1 =&gt; v2 =&gt; ... (updates are read faithfully from volatile)
<i>242</i>&nbsp;        return (e != null &amp;&amp; e.get() == this.version);
<b class="nc"><i>243</i>&nbsp;        // invariant:  No false positives on version match.  Null is OK for false negative.</b>
<i>244</i>&nbsp;        // invariant:  If version matches, then e.value is readable (final set in Entry.&lt;init&gt;)
<i>245</i>&nbsp;    }
<i>246</i>&nbsp;
<i>247</i>&nbsp;    /** Internal hash code for accessing Class.classValueMap.cacheArray. */
<i>248</i>&nbsp;    final int hashCodeForCache = nextHashCode.getAndAdd(HASH_INCREMENT) &amp; HASH_MASK;
<b class="nc"><i>249</i>&nbsp;</b>
<i>250</i>&nbsp;    /** Value stream for hashCodeForCache.  See similar structure in ThreadLocal. */
<i>251</i>&nbsp;    private static final AtomicInteger nextHashCode = new AtomicInteger();
<b class="nc"><i>252</i>&nbsp;</b>
<i>253</i>&nbsp;    /** Good for power-of-two tables.  See similar structure in ThreadLocal. */
<i>254</i>&nbsp;    private static final int HASH_INCREMENT = 0x61c88647;
<i>255</i>&nbsp;
<i>256</i>&nbsp;    /** Mask a hash code to be positive but not too large, to prevent wraparound. */
<i>257</i>&nbsp;    static final int HASH_MASK = (-1 &gt;&gt;&gt; 2);
<i>258</i>&nbsp;
<i>259</i>&nbsp;    /**
<i>260</i>&nbsp;     * Private key for retrieval of this object from ClassValueMap.
<i>261</i>&nbsp;     */
<i>262</i>&nbsp;    static class Identity {
<b class="nc"><i>263</i>&nbsp;    }</b>
<i>264</i>&nbsp;    /**
<i>265</i>&nbsp;     * This ClassValue&#39;s identity, expressed as an opaque object.
<i>266</i>&nbsp;     * The main object {@code ClassValue.this} is incorrect since
<i>267</i>&nbsp;     * subclasses may override {@code ClassValue.equals}, which
<i>268</i>&nbsp;     * could confuse keys in the ClassValueMap.
<i>269</i>&nbsp;     */
<i>270</i>&nbsp;    final Identity identity = new Identity();
<b class="nc"><i>271</i>&nbsp;</b>
<i>272</i>&nbsp;    /**
<i>273</i>&nbsp;     * Current version for retrieving this class value from the cache.
<i>274</i>&nbsp;     * Any number of computeValue calls can be cached in association with one version.
<i>275</i>&nbsp;     * But the version changes when a remove (on any type) is executed.
<i>276</i>&nbsp;     * A version change invalidates all cache entries for the affected ClassValue,
<i>277</i>&nbsp;     * by marking them as stale.  Stale cache entries do not force another call
<i>278</i>&nbsp;     * to computeValue, but they do require a synchronized visit to a backing map.
<i>279</i>&nbsp;     * &lt;p&gt;
<i>280</i>&nbsp;     * All user-visible state changes on the ClassValue take place under
<i>281</i>&nbsp;     * a lock inside the synchronized methods of ClassValueMap.
<i>282</i>&nbsp;     * Readers (of ClassValue.get) are notified of such state changes
<i>283</i>&nbsp;     * when this.version is bumped to a new token.
<i>284</i>&nbsp;     * This variable must be volatile so that an unsynchronized reader
<i>285</i>&nbsp;     * will receive the notification without delay.
<i>286</i>&nbsp;     * &lt;p&gt;
<i>287</i>&nbsp;     * If version were not volatile, one thread T1 could persistently hold onto
<i>288</i>&nbsp;     * a stale value this.value == V1, while another thread T2 advances
<i>289</i>&nbsp;     * (under a lock) to this.value == V2.  This will typically be harmless,
<i>290</i>&nbsp;     * but if T1 and T2 interact causally via some other channel, such that
<i>291</i>&nbsp;     * T1&#39;s further actions are constrained (in the JMM) to happen after
<i>292</i>&nbsp;     * the V2 event, then T1&#39;s observation of V1 will be an error.
<i>293</i>&nbsp;     * &lt;p&gt;
<i>294</i>&nbsp;     * The practical effect of making this.version be volatile is that it cannot
<i>295</i>&nbsp;     * be hoisted out of a loop (by an optimizing JIT) or otherwise cached.
<i>296</i>&nbsp;     * Some machines may also require a barrier instruction to execute
<i>297</i>&nbsp;     * before this.version.
<i>298</i>&nbsp;     */
<i>299</i>&nbsp;    private volatile Version&lt;T&gt; version = new Version&lt;&gt;(this);
<b class="nc"><i>300</i>&nbsp;    Version&lt;T&gt; version() { return version; }</b>
<b class="nc"><i>301</i>&nbsp;    void bumpVersion() { version = new Version&lt;&gt;(this); }</b>
<b class="nc"><i>302</i>&nbsp;    static class Version&lt;T&gt; {</b>
<i>303</i>&nbsp;        private final ClassValue&lt;T&gt; classValue;
<i>304</i>&nbsp;        private final Entry&lt;T&gt; promise = new Entry&lt;&gt;(this);
<b class="nc"><i>305</i>&nbsp;        Version(ClassValue&lt;T&gt; classValue) { this.classValue = classValue; }</b>
<b class="nc"><i>306</i>&nbsp;        ClassValue&lt;T&gt; classValue() { return classValue; }</b>
<b class="nc"><i>307</i>&nbsp;        Entry&lt;T&gt; promise() { return promise; }</b>
<b class="nc"><i>308</i>&nbsp;        boolean isLive() { return classValue.version() == this; }</b>
<b class="nc"><i>309</i>&nbsp;    }</b>
<i>310</i>&nbsp;
<i>311</i>&nbsp;    /** One binding of a value to a class via a ClassValue.
<i>312</i>&nbsp;     *  States are:&lt;ul&gt;
<i>313</i>&nbsp;     *  &lt;li&gt; promise if value == Entry.this
<i>314</i>&nbsp;     *  &lt;li&gt; else dead if version == null
<i>315</i>&nbsp;     *  &lt;li&gt; else stale if version != classValue.version
<i>316</i>&nbsp;     *  &lt;li&gt; else live &lt;/ul&gt;
<i>317</i>&nbsp;     *  Promises are never put into the cache; they only live in the
<i>318</i>&nbsp;     *  backing map while a computeValue call is in flight.
<i>319</i>&nbsp;     *  Once an entry goes stale, it can be reset at any time
<i>320</i>&nbsp;     *  into the dead state.
<i>321</i>&nbsp;     */
<i>322</i>&nbsp;    static class Entry&lt;T&gt; extends WeakReference&lt;Version&lt;T&gt;&gt; {
<b class="nc"><i>323</i>&nbsp;        final Object value;  // usually of type T, but sometimes (Entry)this</b>
<i>324</i>&nbsp;        Entry(Version&lt;T&gt; version, T value) {
<i>325</i>&nbsp;            super(version);
<b class="nc"><i>326</i>&nbsp;            this.value = value;  // for a regular entry, value is of type T</b>
<b class="nc"><i>327</i>&nbsp;        }</b>
<i>328</i>&nbsp;        private void assertNotPromise() { assert(!isPromise()); }
<b class="nc"><i>329</i>&nbsp;        /** For creating a promise. */</b>
<i>330</i>&nbsp;        Entry(Version&lt;T&gt; version) {
<i>331</i>&nbsp;            super(version);
<b class="nc"><i>332</i>&nbsp;            this.value = this;  // for a promise, value is not of type T, but Entry!</b>
<b class="nc"><i>333</i>&nbsp;        }</b>
<i>334</i>&nbsp;        /** Fetch the value.  This entry must not be a promise. */
<i>335</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)  // if !isPromise, type is T
<i>336</i>&nbsp;        T value() { assertNotPromise(); return (T) value; }
<b class="nc"><i>337</i>&nbsp;        boolean isPromise() { return value == this; }</b>
<b class="nc"><i>338</i>&nbsp;        Version&lt;T&gt; version() { return get(); }</b>
<b class="nc"><i>339</i>&nbsp;        ClassValue&lt;T&gt; classValueOrNull() {</b>
<i>340</i>&nbsp;            Version&lt;T&gt; v = version();
<b class="nc"><i>341</i>&nbsp;            return (v == null) ? null : v.classValue();</b>
<b class="nc"><i>342</i>&nbsp;        }</b>
<i>343</i>&nbsp;        boolean isLive() {
<i>344</i>&nbsp;            Version&lt;T&gt; v = version();
<b class="nc"><i>345</i>&nbsp;            if (v == null)  return false;</b>
<b class="nc"><i>346</i>&nbsp;            if (v.isLive())  return true;</b>
<b class="nc"><i>347</i>&nbsp;            clear();</b>
<b class="nc"><i>348</i>&nbsp;            return false;</b>
<b class="nc"><i>349</i>&nbsp;        }</b>
<i>350</i>&nbsp;        Entry&lt;T&gt; refreshVersion(Version&lt;T&gt; v2) {
<i>351</i>&nbsp;            assertNotPromise();
<b class="nc"><i>352</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)  // if !isPromise, type is T</b>
<i>353</i>&nbsp;            Entry&lt;T&gt; e2 = new Entry&lt;&gt;(v2, (T) value);
<b class="nc"><i>354</i>&nbsp;            clear();</b>
<b class="nc"><i>355</i>&nbsp;            // value = null -- caller must drop</b>
<i>356</i>&nbsp;            return e2;
<b class="nc"><i>357</i>&nbsp;        }</b>
<i>358</i>&nbsp;        static final Entry&lt;?&gt; DEAD_ENTRY = new Entry&lt;&gt;(null, null);
<b class="nc"><i>359</i>&nbsp;    }</b>
<i>360</i>&nbsp;
<i>361</i>&nbsp;    /** Return the backing map associated with this type. */
<i>362</i>&nbsp;    private static ClassValueMap getMap(Class&lt;?&gt; type) {
<i>363</i>&nbsp;        // racing type.classValueMap : null (blank) =&gt; unique ClassValueMap
<i>364</i>&nbsp;        // if a null is observed, a map is created (lazily, synchronously, uniquely)
<i>365</i>&nbsp;        // all further access to that map is synchronized
<i>366</i>&nbsp;        ClassValueMap map = type.classValueMap;
<b class="nc"><i>367</i>&nbsp;        if (map != null)  return map;</b>
<b class="nc"><i>368</i>&nbsp;        return initializeMap(type);</b>
<b class="nc"><i>369</i>&nbsp;    }</b>
<i>370</i>&nbsp;
<i>371</i>&nbsp;    private static final Object CRITICAL_SECTION = new Object();
<b class="nc"><i>372</i>&nbsp;    private static ClassValueMap initializeMap(Class&lt;?&gt; type) {</b>
<i>373</i>&nbsp;        ClassValueMap map;
<i>374</i>&nbsp;        synchronized (CRITICAL_SECTION) {  // private object to avoid deadlocks
<b class="nc"><i>375</i>&nbsp;            // happens about once per type</b>
<i>376</i>&nbsp;            if ((map = type.classValueMap) == null)
<b class="nc"><i>377</i>&nbsp;                type.classValueMap = map = new ClassValueMap();</b>
<b class="nc"><i>378</i>&nbsp;        }</b>
<b class="nc"><i>379</i>&nbsp;        return map;</b>
<b class="nc"><i>380</i>&nbsp;    }</b>
<i>381</i>&nbsp;
<i>382</i>&nbsp;    static &lt;T&gt; Entry&lt;T&gt; makeEntry(Version&lt;T&gt; explicitVersion, T value) {
<i>383</i>&nbsp;        // Note that explicitVersion might be different from this.version.
<i>384</i>&nbsp;        return new Entry&lt;&gt;(explicitVersion, value);
<b class="nc"><i>385</i>&nbsp;</b>
<i>386</i>&nbsp;        // As soon as the Entry is put into the cache, the value will be
<i>387</i>&nbsp;        // reachable via a data race (as defined by the Java Memory Model).
<i>388</i>&nbsp;        // This race is benign, assuming the value object itself can be
<i>389</i>&nbsp;        // read safely by multiple threads.  This is up to the user.
<i>390</i>&nbsp;        //
<i>391</i>&nbsp;        // The entry and version fields themselves can be safely read via
<i>392</i>&nbsp;        // a race because they are either final or have controlled states.
<i>393</i>&nbsp;        // If the pointer from the entry to the version is still null,
<i>394</i>&nbsp;        // or if the version goes immediately dead and is nulled out,
<i>395</i>&nbsp;        // the reader will take the slow path and retry under a lock.
<i>396</i>&nbsp;    }
<i>397</i>&nbsp;
<i>398</i>&nbsp;    // The following class could also be top level and non-public:
<i>399</i>&nbsp;
<i>400</i>&nbsp;    /** A backing map for all ClassValues.
<i>401</i>&nbsp;     *  Gives a fully serialized &quot;true state&quot; for each pair (ClassValue cv, Class type).
<i>402</i>&nbsp;     *  Also manages an unserialized fast-path cache.
<i>403</i>&nbsp;     */
<i>404</i>&nbsp;    static class ClassValueMap extends WeakHashMap&lt;ClassValue.Identity, Entry&lt;?&gt;&gt; {
<b class="nc"><i>405</i>&nbsp;        private Entry&lt;?&gt;[] cacheArray;</b>
<i>406</i>&nbsp;        private int cacheLoad, cacheLoadLimit;
<i>407</i>&nbsp;
<i>408</i>&nbsp;        /** Number of entries initially allocated to each type when first used with any ClassValue.
<i>409</i>&nbsp;         *  It would be pointless to make this much smaller than the Class and ClassValueMap objects themselves.
<i>410</i>&nbsp;         *  Must be a power of 2.
<i>411</i>&nbsp;         */
<i>412</i>&nbsp;        private static final int INITIAL_ENTRIES = 32;
<i>413</i>&nbsp;
<i>414</i>&nbsp;        /** Build a backing map for ClassValues.
<i>415</i>&nbsp;         *  Also, create an empty cache array and install it on the class.
<i>416</i>&nbsp;         */
<i>417</i>&nbsp;        ClassValueMap() {
<i>418</i>&nbsp;            sizeCache(INITIAL_ENTRIES);
<b class="nc"><i>419</i>&nbsp;        }</b>
<b class="nc"><i>420</i>&nbsp;</b>
<b class="nc"><i>421</i>&nbsp;        Entry&lt;?&gt;[] getCache() { return cacheArray; }</b>
<i>422</i>&nbsp;
<i>423</i>&nbsp;        /** Initiate a query.  Store a promise (placeholder) if there is no value yet. */
<b class="nc"><i>424</i>&nbsp;        synchronized</b>
<i>425</i>&nbsp;        &lt;T&gt; Entry&lt;T&gt; startEntry(ClassValue&lt;T&gt; classValue) {
<i>426</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)  // one map has entries for all value types &lt;T&gt;
<i>427</i>&nbsp;            Entry&lt;T&gt; e = (Entry&lt;T&gt;) get(classValue.identity);
<i>428</i>&nbsp;            Version&lt;T&gt; v = classValue.version();
<i>429</i>&nbsp;            if (e == null) {
<b class="nc"><i>430</i>&nbsp;                e = v.promise();</b>
<b class="nc"><i>431</i>&nbsp;                // The presence of a promise means that a value is pending for v.</b>
<b class="nc"><i>432</i>&nbsp;                // Eventually, finishEntry will overwrite the promise.</b>
<b class="nc"><i>433</i>&nbsp;                put(classValue.identity, e);</b>
<i>434</i>&nbsp;                // Note that the promise is never entered into the cache!
<i>435</i>&nbsp;                return e;
<b class="nc"><i>436</i>&nbsp;            } else if (e.isPromise()) {</b>
<i>437</i>&nbsp;                // Somebody else has asked the same question.
<b class="nc"><i>438</i>&nbsp;                // Let the races begin!</b>
<b class="nc"><i>439</i>&nbsp;                if (e.version() != v) {</b>
<i>440</i>&nbsp;                    e = v.promise();
<i>441</i>&nbsp;                    put(classValue.identity, e);
<b class="nc"><i>442</i>&nbsp;                }</b>
<b class="nc"><i>443</i>&nbsp;                return e;</b>
<b class="nc"><i>444</i>&nbsp;            } else {</b>
<i>445</i>&nbsp;                // there is already a completed entry here; report it
<b class="nc"><i>446</i>&nbsp;                if (e.version() != v) {</b>
<i>447</i>&nbsp;                    // There is a stale but valid entry here; make it fresh again.
<i>448</i>&nbsp;                    // Once an entry is in the hash table, we don&#39;t care what its version is.
<b class="nc"><i>449</i>&nbsp;                    e = e.refreshVersion(v);</b>
<i>450</i>&nbsp;                    put(classValue.identity, e);
<i>451</i>&nbsp;                }
<b class="nc"><i>452</i>&nbsp;                // Add to the cache, to enable the fast path, next time.</b>
<b class="nc"><i>453</i>&nbsp;                checkCacheLoad();</b>
<i>454</i>&nbsp;                addToCache(classValue, e);
<i>455</i>&nbsp;                return e;
<b class="nc"><i>456</i>&nbsp;            }</b>
<b class="nc"><i>457</i>&nbsp;        }</b>
<b class="nc"><i>458</i>&nbsp;</b>
<i>459</i>&nbsp;        /** Finish a query.  Overwrite a matching placeholder.  Drop stale incoming values. */
<i>460</i>&nbsp;        synchronized
<i>461</i>&nbsp;        &lt;T&gt; Entry&lt;T&gt; finishEntry(ClassValue&lt;T&gt; classValue, Entry&lt;T&gt; e) {
<i>462</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)  // one map has entries for all value types &lt;T&gt;
<i>463</i>&nbsp;            Entry&lt;T&gt; e0 = (Entry&lt;T&gt;) get(classValue.identity);
<i>464</i>&nbsp;            if (e == e0) {
<i>465</i>&nbsp;                // We can get here during exception processing, unwinding from computeValue.
<b class="nc"><i>466</i>&nbsp;                assert(e.isPromise());</b>
<b class="nc"><i>467</i>&nbsp;                remove(classValue.identity);</b>
<i>468</i>&nbsp;                return null;
<b class="nc"><i>469</i>&nbsp;            } else if (e0 != null &amp;&amp; e0.isPromise() &amp;&amp; e0.version() == e.version()) {</b>
<b class="nc"><i>470</i>&nbsp;                // If e0 matches the intended entry, there has not been a remove call</b>
<b class="nc"><i>471</i>&nbsp;                // between the previous startEntry and now.  So now overwrite e0.</b>
<b class="nc"><i>472</i>&nbsp;                Version&lt;T&gt; v = classValue.version();</b>
<i>473</i>&nbsp;                if (e.version() != v)
<i>474</i>&nbsp;                    e = e.refreshVersion(v);
<b class="nc"><i>475</i>&nbsp;                put(classValue.identity, e);</b>
<b class="nc"><i>476</i>&nbsp;                // Add to the cache, to enable the fast path, next time.</b>
<b class="nc"><i>477</i>&nbsp;                checkCacheLoad();</b>
<b class="nc"><i>478</i>&nbsp;                addToCache(classValue, e);</b>
<i>479</i>&nbsp;                return e;
<b class="nc"><i>480</i>&nbsp;            } else {</b>
<b class="nc"><i>481</i>&nbsp;                // Some sort of mismatch; caller must try again.</b>
<b class="nc"><i>482</i>&nbsp;                return null;</b>
<i>483</i>&nbsp;            }
<i>484</i>&nbsp;        }
<b class="nc"><i>485</i>&nbsp;</b>
<i>486</i>&nbsp;        /** Remove an entry. */
<i>487</i>&nbsp;        synchronized
<i>488</i>&nbsp;        void removeEntry(ClassValue&lt;?&gt; classValue) {
<i>489</i>&nbsp;            Entry&lt;?&gt; e = remove(classValue.identity);
<i>490</i>&nbsp;            if (e == null) {
<i>491</i>&nbsp;                // Uninitialized, and no pending calls to computeValue.  No change.
<b class="nc"><i>492</i>&nbsp;            } else if (e.isPromise()) {</b>
<b class="nc"><i>493</i>&nbsp;                // State is uninitialized, with a pending call to finishEntry.</b>
<i>494</i>&nbsp;                // Since remove is a no-op in such a state, keep the promise
<b class="nc"><i>495</i>&nbsp;                // by putting it back into the map.</b>
<i>496</i>&nbsp;                put(classValue.identity, e);
<i>497</i>&nbsp;            } else {
<i>498</i>&nbsp;                // In an initialized state.  Bump forward, and de-initialize.
<b class="nc"><i>499</i>&nbsp;                classValue.bumpVersion();</b>
<i>500</i>&nbsp;                // Make all cache elements for this guy go stale.
<i>501</i>&nbsp;                removeStaleEntries(classValue);
<b class="nc"><i>502</i>&nbsp;            }</b>
<i>503</i>&nbsp;        }
<b class="nc"><i>504</i>&nbsp;</b>
<i>505</i>&nbsp;        /** Change the value for an entry. */
<i>506</i>&nbsp;        synchronized
<i>507</i>&nbsp;        &lt;T&gt; void changeEntry(ClassValue&lt;T&gt; classValue, T value) {
<i>508</i>&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)  // one map has entries for all value types &lt;T&gt;
<i>509</i>&nbsp;            Entry&lt;T&gt; e0 = (Entry&lt;T&gt;) get(classValue.identity);
<i>510</i>&nbsp;            Version&lt;T&gt; version = classValue.version();
<i>511</i>&nbsp;            if (e0 != null) {
<b class="nc"><i>512</i>&nbsp;                if (e0.version() == version &amp;&amp; e0.value() == value)</b>
<b class="nc"><i>513</i>&nbsp;                    // no value change =&gt; no version change needed</b>
<b class="nc"><i>514</i>&nbsp;                    return;</b>
<b class="nc"><i>515</i>&nbsp;                classValue.bumpVersion();</b>
<i>516</i>&nbsp;                removeStaleEntries(classValue);
<i>517</i>&nbsp;            }
<b class="nc"><i>518</i>&nbsp;            Entry&lt;T&gt; e = makeEntry(version, value);</b>
<b class="nc"><i>519</i>&nbsp;            put(classValue.identity, e);</b>
<i>520</i>&nbsp;            // Add to the cache, to enable the fast path, next time.
<b class="nc"><i>521</i>&nbsp;            checkCacheLoad();</b>
<b class="nc"><i>522</i>&nbsp;            addToCache(classValue, e);</b>
<i>523</i>&nbsp;        }
<b class="nc"><i>524</i>&nbsp;</b>
<b class="nc"><i>525</i>&nbsp;        /// --------</b>
<i>526</i>&nbsp;        /// Cache management.
<i>527</i>&nbsp;        /// --------
<i>528</i>&nbsp;
<i>529</i>&nbsp;        // Statics do not need synchronization.
<i>530</i>&nbsp;
<i>531</i>&nbsp;        /** Load the cache entry at the given (hashed) location. */
<i>532</i>&nbsp;        static Entry&lt;?&gt; loadFromCache(Entry&lt;?&gt;[] cache, int i) {
<i>533</i>&nbsp;            // non-racing cache.length : constant
<i>534</i>&nbsp;            // racing cache[i &amp; (mask)] : null &lt;=&gt; Entry
<i>535</i>&nbsp;            return cache[i &amp; (cache.length-1)];
<i>536</i>&nbsp;            // invariant:  returned value is null or well-constructed (ready to match)
<i>537</i>&nbsp;        }
<b class="nc"><i>538</i>&nbsp;</b>
<i>539</i>&nbsp;        /** Look in the cache, at the home location for the given ClassValue. */
<i>540</i>&nbsp;        static &lt;T&gt; Entry&lt;T&gt; probeHomeLocation(Entry&lt;?&gt;[] cache, ClassValue&lt;T&gt; classValue) {
<i>541</i>&nbsp;            return classValue.castEntry(loadFromCache(cache, classValue.hashCodeForCache));
<i>542</i>&nbsp;        }
<i>543</i>&nbsp;
<b class="nc"><i>544</i>&nbsp;        /** Given that first probe was a collision, retry at nearby locations. */</b>
<i>545</i>&nbsp;        static &lt;T&gt; Entry&lt;T&gt; probeBackupLocations(Entry&lt;?&gt;[] cache, ClassValue&lt;T&gt; classValue) {
<i>546</i>&nbsp;            if (PROBE_LIMIT &lt;= 0)  return null;
<i>547</i>&nbsp;            // Probe the cache carefully, in a range of slots.
<i>548</i>&nbsp;            int mask = (cache.length-1);
<i>549</i>&nbsp;            int home = (classValue.hashCodeForCache &amp; mask);
<i>550</i>&nbsp;            Entry&lt;?&gt; e2 = cache[home];  // victim, if we find the real guy
<b class="nc"><i>551</i>&nbsp;            if (e2 == null) {</b>
<b class="nc"><i>552</i>&nbsp;                return null;   // if nobody is at home, no need to search nearby</b>
<b class="nc"><i>553</i>&nbsp;            }</b>
<b class="nc"><i>554</i>&nbsp;            // assume !classValue.match(e2), but do not assert, because of races</b>
<b class="nc"><i>555</i>&nbsp;            int pos2 = -1;</b>
<i>556</i>&nbsp;            for (int i = home + 1; i &lt; home + PROBE_LIMIT; i++) {
<i>557</i>&nbsp;                Entry&lt;?&gt; e = cache[i &amp; mask];
<b class="nc"><i>558</i>&nbsp;                if (e == null) {</b>
<b class="nc"><i>559</i>&nbsp;                    break;   // only search within non-null runs</b>
<b class="nc"><i>560</i>&nbsp;                }</b>
<b class="nc"><i>561</i>&nbsp;                if (classValue.match(e)) {</b>
<b class="nc"><i>562</i>&nbsp;                    // relocate colliding entry e2 (from cache[home]) to first empty slot</b>
<i>563</i>&nbsp;                    cache[home] = e;
<b class="nc"><i>564</i>&nbsp;                    if (pos2 &gt;= 0) {</b>
<i>565</i>&nbsp;                        cache[i &amp; mask] = Entry.DEAD_ENTRY;
<b class="nc"><i>566</i>&nbsp;                    } else {</b>
<b class="nc"><i>567</i>&nbsp;                        pos2 = i;</b>
<b class="nc"><i>568</i>&nbsp;                    }</b>
<i>569</i>&nbsp;                    cache[pos2 &amp; mask] = ((entryDislocation(cache, pos2, e2) &lt; PROBE_LIMIT)
<b class="nc"><i>570</i>&nbsp;                                          ? e2                  // put e2 here if it fits</b>
<i>571</i>&nbsp;                                          : Entry.DEAD_ENTRY);
<b class="nc"><i>572</i>&nbsp;                    return classValue.castEntry(e);</b>
<i>573</i>&nbsp;                }
<i>574</i>&nbsp;                // Remember first empty slot, if any:
<b class="nc"><i>575</i>&nbsp;                if (!e.isLive() &amp;&amp; pos2 &lt; 0)  pos2 = i;</b>
<i>576</i>&nbsp;            }
<i>577</i>&nbsp;            return null;
<b class="nc"><i>578</i>&nbsp;        }</b>
<i>579</i>&nbsp;
<b class="nc"><i>580</i>&nbsp;        /** How far out of place is e? */</b>
<i>581</i>&nbsp;        private static int entryDislocation(Entry&lt;?&gt;[] cache, int pos, Entry&lt;?&gt; e) {
<i>582</i>&nbsp;            ClassValue&lt;?&gt; cv = e.classValueOrNull();
<i>583</i>&nbsp;            if (cv == null)  return 0;  // entry is not live!
<i>584</i>&nbsp;            int mask = (cache.length-1);
<b class="nc"><i>585</i>&nbsp;            return (pos - cv.hashCodeForCache) &amp; mask;</b>
<b class="nc"><i>586</i>&nbsp;        }</b>
<b class="nc"><i>587</i>&nbsp;</b>
<b class="nc"><i>588</i>&nbsp;        /// --------</b>
<i>589</i>&nbsp;        /// Below this line all functions are private, and assume synchronized access.
<i>590</i>&nbsp;        /// --------
<i>591</i>&nbsp;
<i>592</i>&nbsp;        private void sizeCache(int length) {
<i>593</i>&nbsp;            assert((length &amp; (length-1)) == 0);  // must be power of 2
<i>594</i>&nbsp;            cacheLoad = 0;
<i>595</i>&nbsp;            cacheLoadLimit = (int) ((double) length * CACHE_LOAD_LIMIT / 100);
<b class="nc"><i>596</i>&nbsp;            cacheArray = new Entry&lt;?&gt;[length];</b>
<b class="nc"><i>597</i>&nbsp;        }</b>
<b class="nc"><i>598</i>&nbsp;</b>
<b class="nc"><i>599</i>&nbsp;        /** Make sure the cache load stays below its limit, if possible. */</b>
<i>600</i>&nbsp;        private void checkCacheLoad() {
<i>601</i>&nbsp;            if (cacheLoad &gt;= cacheLoadLimit) {
<i>602</i>&nbsp;                reduceCacheLoad();
<i>603</i>&nbsp;            }
<b class="nc"><i>604</i>&nbsp;        }</b>
<b class="nc"><i>605</i>&nbsp;        private void reduceCacheLoad() {</b>
<i>606</i>&nbsp;            removeStaleEntries();
<i>607</i>&nbsp;            if (cacheLoad &lt; cacheLoadLimit)
<i>608</i>&nbsp;                return;  // win
<b class="nc"><i>609</i>&nbsp;            Entry&lt;?&gt;[] oldCache = getCache();</b>
<b class="nc"><i>610</i>&nbsp;            if (oldCache.length &gt; HASH_MASK)</b>
<i>611</i>&nbsp;                return;  // lose
<b class="nc"><i>612</i>&nbsp;            sizeCache(oldCache.length * 2);</b>
<b class="nc"><i>613</i>&nbsp;            for (Entry&lt;?&gt; e : oldCache) {</b>
<i>614</i>&nbsp;                if (e != null &amp;&amp; e.isLive()) {
<b class="nc"><i>615</i>&nbsp;                    addToCache(e);</b>
<b class="nc"><i>616</i>&nbsp;                }</b>
<b class="nc"><i>617</i>&nbsp;            }</b>
<b class="nc"><i>618</i>&nbsp;        }</b>
<i>619</i>&nbsp;
<i>620</i>&nbsp;        /** Remove stale entries in the given range.
<i>621</i>&nbsp;         *  Should be executed under a Map lock.
<i>622</i>&nbsp;         */
<i>623</i>&nbsp;        private void removeStaleEntries(Entry&lt;?&gt;[] cache, int begin, int count) {
<i>624</i>&nbsp;            if (PROBE_LIMIT &lt;= 0)  return;
<i>625</i>&nbsp;            int mask = (cache.length-1);
<i>626</i>&nbsp;            int removed = 0;
<i>627</i>&nbsp;            for (int i = begin; i &lt; begin + count; i++) {
<b class="nc"><i>628</i>&nbsp;                Entry&lt;?&gt; e = cache[i &amp; mask];</b>
<b class="nc"><i>629</i>&nbsp;                if (e == null || e.isLive())</b>
<b class="nc"><i>630</i>&nbsp;                    continue;  // skip null and live entries</b>
<b class="nc"><i>631</i>&nbsp;                Entry&lt;?&gt; replacement = null;</b>
<b class="nc"><i>632</i>&nbsp;                if (PROBE_LIMIT &gt; 1) {</b>
<b class="nc"><i>633</i>&nbsp;                    // avoid breaking up a non-null run</b>
<b class="nc"><i>634</i>&nbsp;                    replacement = findReplacement(cache, i);</b>
<i>635</i>&nbsp;                }
<i>636</i>&nbsp;                cache[i &amp; mask] = replacement;
<b class="nc"><i>637</i>&nbsp;                if (replacement == null)  removed += 1;</b>
<i>638</i>&nbsp;            }
<b class="nc"><i>639</i>&nbsp;            cacheLoad = Math.max(0, cacheLoad - removed);</b>
<b class="nc"><i>640</i>&nbsp;        }</b>
<i>641</i>&nbsp;
<b class="nc"><i>642</i>&nbsp;        /** Clearing a cache slot risks disconnecting following entries</b>
<i>643</i>&nbsp;         *  from the head of a non-null run, which would allow them
<i>644</i>&nbsp;         *  to be found via reprobes.  Find an entry after cache[begin]
<i>645</i>&nbsp;         *  to plug into the hole, or return null if none is needed.
<i>646</i>&nbsp;         */
<i>647</i>&nbsp;        private Entry&lt;?&gt; findReplacement(Entry&lt;?&gt;[] cache, int home1) {
<i>648</i>&nbsp;            Entry&lt;?&gt; replacement = null;
<i>649</i>&nbsp;            int haveReplacement = -1, replacementPos = 0;
<i>650</i>&nbsp;            int mask = (cache.length-1);
<b class="nc"><i>651</i>&nbsp;            for (int i2 = home1 + 1; i2 &lt; home1 + PROBE_LIMIT; i2++) {</b>
<b class="nc"><i>652</i>&nbsp;                Entry&lt;?&gt; e2 = cache[i2 &amp; mask];</b>
<b class="nc"><i>653</i>&nbsp;                if (e2 == null)  break;  // End of non-null run.</b>
<b class="nc"><i>654</i>&nbsp;                if (!e2.isLive())  continue;  // Doomed anyway.</b>
<b class="nc"><i>655</i>&nbsp;                int dis2 = entryDislocation(cache, i2, e2);</b>
<b class="nc"><i>656</i>&nbsp;                if (dis2 == 0)  continue;  // e2 already optimally placed</b>
<b class="nc"><i>657</i>&nbsp;                int home2 = i2 - dis2;</b>
<b class="nc"><i>658</i>&nbsp;                if (home2 &lt;= home1) {</b>
<b class="nc"><i>659</i>&nbsp;                    // e2 can replace entry at cache[home1]</b>
<b class="nc"><i>660</i>&nbsp;                    if (home2 == home1) {</b>
<b class="nc"><i>661</i>&nbsp;                        // Put e2 exactly where he belongs.</b>
<i>662</i>&nbsp;                        haveReplacement = 1;
<b class="nc"><i>663</i>&nbsp;                        replacementPos = i2;</b>
<i>664</i>&nbsp;                        replacement = e2;
<b class="nc"><i>665</i>&nbsp;                    } else if (haveReplacement &lt;= 0) {</b>
<b class="nc"><i>666</i>&nbsp;                        haveReplacement = 0;</b>
<b class="nc"><i>667</i>&nbsp;                        replacementPos = i2;</b>
<b class="nc"><i>668</i>&nbsp;                        replacement = e2;</b>
<b class="nc"><i>669</i>&nbsp;                    }</b>
<b class="nc"><i>670</i>&nbsp;                    // And keep going, so we can favor larger dislocations.</b>
<b class="nc"><i>671</i>&nbsp;                }</b>
<i>672</i>&nbsp;            }
<i>673</i>&nbsp;            if (haveReplacement &gt;= 0) {
<i>674</i>&nbsp;                if (cache[(replacementPos+1) &amp; mask] != null) {
<i>675</i>&nbsp;                    // Be conservative, to avoid breaking up a non-null run.
<b class="nc"><i>676</i>&nbsp;                    cache[replacementPos &amp; mask] = (Entry&lt;?&gt;) Entry.DEAD_ENTRY;</b>
<b class="nc"><i>677</i>&nbsp;                } else {</b>
<i>678</i>&nbsp;                    cache[replacementPos &amp; mask] = null;
<b class="nc"><i>679</i>&nbsp;                    cacheLoad -= 1;</b>
<i>680</i>&nbsp;                }
<b class="nc"><i>681</i>&nbsp;            }</b>
<b class="nc"><i>682</i>&nbsp;            return replacement;</b>
<i>683</i>&nbsp;        }
<i>684</i>&nbsp;
<b class="nc"><i>685</i>&nbsp;        /** Remove stale entries in the range near classValue. */</b>
<i>686</i>&nbsp;        private void removeStaleEntries(ClassValue&lt;?&gt; classValue) {
<i>687</i>&nbsp;            removeStaleEntries(getCache(), classValue.hashCodeForCache, PROBE_LIMIT);
<i>688</i>&nbsp;        }
<i>689</i>&nbsp;
<b class="nc"><i>690</i>&nbsp;        /** Remove all stale entries, everywhere. */</b>
<i>691</i>&nbsp;        private void removeStaleEntries() {
<i>692</i>&nbsp;            Entry&lt;?&gt;[] cache = getCache();
<i>693</i>&nbsp;            removeStaleEntries(cache, 0, cache.length + PROBE_LIMIT - 1);
<i>694</i>&nbsp;        }
<b class="nc"><i>695</i>&nbsp;</b>
<b class="nc"><i>696</i>&nbsp;        /** Add the given entry to the cache, in its home location, unless it is out of date. */</b>
<i>697</i>&nbsp;        private &lt;T&gt; void addToCache(Entry&lt;T&gt; e) {
<i>698</i>&nbsp;            ClassValue&lt;T&gt; classValue = e.classValueOrNull();
<i>699</i>&nbsp;            if (classValue != null)
<i>700</i>&nbsp;                addToCache(classValue, e);
<b class="nc"><i>701</i>&nbsp;        }</b>
<b class="nc"><i>702</i>&nbsp;</b>
<b class="nc"><i>703</i>&nbsp;        /** Add the given entry to the cache, in its home location. */</b>
<i>704</i>&nbsp;        private &lt;T&gt; void addToCache(ClassValue&lt;T&gt; classValue, Entry&lt;T&gt; e) {
<i>705</i>&nbsp;            if (PROBE_LIMIT &lt;= 0)  return;  // do not fill cache
<i>706</i>&nbsp;            // Add e to the cache.
<i>707</i>&nbsp;            Entry&lt;?&gt;[] cache = getCache();
<i>708</i>&nbsp;            int mask = (cache.length-1);
<i>709</i>&nbsp;            int home = classValue.hashCodeForCache &amp; mask;
<b class="nc"><i>710</i>&nbsp;            Entry&lt;?&gt; e2 = placeInCache(cache, home, e, false);</b>
<b class="nc"><i>711</i>&nbsp;            if (e2 == null)  return;  // done</b>
<b class="nc"><i>712</i>&nbsp;            if (PROBE_LIMIT &gt; 1) {</b>
<b class="nc"><i>713</i>&nbsp;                // try to move e2 somewhere else in his probe range</b>
<b class="nc"><i>714</i>&nbsp;                int dis2 = entryDislocation(cache, home, e2);</b>
<i>715</i>&nbsp;                int home2 = home - dis2;
<i>716</i>&nbsp;                for (int i2 = home2; i2 &lt; home2 + PROBE_LIMIT; i2++) {
<b class="nc"><i>717</i>&nbsp;                    if (placeInCache(cache, i2 &amp; mask, e2, true) == null) {</b>
<b class="nc"><i>718</i>&nbsp;                        return;</b>
<b class="nc"><i>719</i>&nbsp;                    }</b>
<b class="nc"><i>720</i>&nbsp;                }</b>
<i>721</i>&nbsp;            }
<i>722</i>&nbsp;            // Note:  At this point, e2 is just dropped from the cache.
<i>723</i>&nbsp;        }
<i>724</i>&nbsp;
<i>725</i>&nbsp;        /** Store the given entry.  Update cacheLoad, and return any live victim.
<i>726</i>&nbsp;         *  &#39;Gently&#39; means return self rather than dislocating a live victim.
<i>727</i>&nbsp;         */
<i>728</i>&nbsp;        private Entry&lt;?&gt; placeInCache(Entry&lt;?&gt;[] cache, int pos, Entry&lt;?&gt; e, boolean gently) {
<i>729</i>&nbsp;            Entry&lt;?&gt; e2 = overwrittenEntry(cache[pos]);
<i>730</i>&nbsp;            if (gently &amp;&amp; e2 != null) {
<i>731</i>&nbsp;                // do not overwrite a live entry
<b class="nc"><i>732</i>&nbsp;                return e;</b>
<b class="nc"><i>733</i>&nbsp;            } else {</b>
<i>734</i>&nbsp;                cache[pos] = e;
<b class="nc"><i>735</i>&nbsp;                return e2;</b>
<i>736</i>&nbsp;            }
<b class="nc"><i>737</i>&nbsp;        }</b>
<b class="nc"><i>738</i>&nbsp;</b>
<i>739</i>&nbsp;        /** Note an entry that is about to be overwritten.
<i>740</i>&nbsp;         *  If it is not live, quietly replace it by null.
<i>741</i>&nbsp;         *  If it is an actual null, increment cacheLoad,
<i>742</i>&nbsp;         *  because the caller is going to store something
<i>743</i>&nbsp;         *  in its place.
<i>744</i>&nbsp;         */
<i>745</i>&nbsp;        private &lt;T&gt; Entry&lt;T&gt; overwrittenEntry(Entry&lt;T&gt; e2) {
<i>746</i>&nbsp;            if (e2 == null)  cacheLoad += 1;
<i>747</i>&nbsp;            else if (e2.isLive())  return e2;
<i>748</i>&nbsp;            return null;
<b class="nc"><i>749</i>&nbsp;        }</b>
<b class="nc"><i>750</i>&nbsp;</b>
<b class="nc"><i>751</i>&nbsp;        /** Percent loading of cache before resize. */</b>
<i>752</i>&nbsp;        private static final int CACHE_LOAD_LIMIT = 67;  // 0..100
<i>753</i>&nbsp;        /** Maximum number of probes to attempt. */
<i>754</i>&nbsp;        private static final int PROBE_LIMIT      =  6;       // 1..
<i>755</i>&nbsp;        // N.B.  Set PROBE_LIMIT=0 to disable all fast paths.
<i>756</i>&nbsp;    }
<i>757</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
