


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Throwable</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang</a> ]
</div>

<h1>Coverage Summary for Class: Throwable (java.lang)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Throwable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 143)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Throwable$PrintStreamOrWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Throwable$SentinelHolder</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Throwable$WrappedPrintStream</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Throwable$WrappedPrintWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 155)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1994, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import  java.io.*;
<i>29</i>&nbsp;import  java.util.*;
<i>30</i>&nbsp;
<i>31</i>&nbsp;/**
<i>32</i>&nbsp; * The {@code Throwable} class is the superclass of all errors and
<i>33</i>&nbsp; * exceptions in the Java language. Only objects that are instances of this
<i>34</i>&nbsp; * class (or one of its subclasses) are thrown by the Java Virtual Machine or
<i>35</i>&nbsp; * can be thrown by the Java {@code throw} statement. Similarly, only
<i>36</i>&nbsp; * this class or one of its subclasses can be the argument type in a
<i>37</i>&nbsp; * {@code catch} clause.
<i>38</i>&nbsp; *
<i>39</i>&nbsp; * For the purposes of compile-time checking of exceptions, {@code
<i>40</i>&nbsp; * Throwable} and any subclass of {@code Throwable} that is not also a
<i>41</i>&nbsp; * subclass of either {@link RuntimeException} or {@link Error} are
<i>42</i>&nbsp; * regarded as checked exceptions.
<i>43</i>&nbsp; *
<i>44</i>&nbsp; * &lt;p&gt;Instances of two subclasses, {@link java.lang.Error} and
<i>45</i>&nbsp; * {@link java.lang.Exception}, are conventionally used to indicate
<i>46</i>&nbsp; * that exceptional situations have occurred. Typically, these instances
<i>47</i>&nbsp; * are freshly created in the context of the exceptional situation so
<i>48</i>&nbsp; * as to include relevant information (such as stack trace data).
<i>49</i>&nbsp; *
<i>50</i>&nbsp; * &lt;p&gt;A throwable contains a snapshot of the execution stack of its
<i>51</i>&nbsp; * thread at the time it was created. It can also contain a message
<i>52</i>&nbsp; * string that gives more information about the error. Over time, a
<i>53</i>&nbsp; * throwable can {@linkplain Throwable#addSuppressed suppress} other
<i>54</i>&nbsp; * throwables from being propagated.  Finally, the throwable can also
<i>55</i>&nbsp; * contain a &lt;i&gt;cause&lt;/i&gt;: another throwable that caused this
<i>56</i>&nbsp; * throwable to be constructed.  The recording of this causal information
<i>57</i>&nbsp; * is referred to as the &lt;i&gt;chained exception&lt;/i&gt; facility, as the
<i>58</i>&nbsp; * cause can, itself, have a cause, and so on, leading to a &quot;chain&quot; of
<i>59</i>&nbsp; * exceptions, each caused by another.
<i>60</i>&nbsp; *
<i>61</i>&nbsp; * &lt;p&gt;One reason that a throwable may have a cause is that the class that
<i>62</i>&nbsp; * throws it is built atop a lower layered abstraction, and an operation on
<i>63</i>&nbsp; * the upper layer fails due to a failure in the lower layer.  It would be bad
<i>64</i>&nbsp; * design to let the throwable thrown by the lower layer propagate outward, as
<i>65</i>&nbsp; * it is generally unrelated to the abstraction provided by the upper layer.
<i>66</i>&nbsp; * Further, doing so would tie the API of the upper layer to the details of
<i>67</i>&nbsp; * its implementation, assuming the lower layer&#39;s exception was a checked
<i>68</i>&nbsp; * exception.  Throwing a &quot;wrapped exception&quot; (i.e., an exception containing a
<i>69</i>&nbsp; * cause) allows the upper layer to communicate the details of the failure to
<i>70</i>&nbsp; * its caller without incurring either of these shortcomings.  It preserves
<i>71</i>&nbsp; * the flexibility to change the implementation of the upper layer without
<i>72</i>&nbsp; * changing its API (in particular, the set of exceptions thrown by its
<i>73</i>&nbsp; * methods).
<i>74</i>&nbsp; *
<i>75</i>&nbsp; * &lt;p&gt;A second reason that a throwable may have a cause is that the method
<i>76</i>&nbsp; * that throws it must conform to a general-purpose interface that does not
<i>77</i>&nbsp; * permit the method to throw the cause directly.  For example, suppose
<i>78</i>&nbsp; * a persistent collection conforms to the {@link java.util.Collection
<i>79</i>&nbsp; * Collection} interface, and that its persistence is implemented atop
<i>80</i>&nbsp; * {@code java.io}.  Suppose the internals of the {@code add} method
<i>81</i>&nbsp; * can throw an {@link java.io.IOException IOException}.  The implementation
<i>82</i>&nbsp; * can communicate the details of the {@code IOException} to its caller
<i>83</i>&nbsp; * while conforming to the {@code Collection} interface by wrapping the
<i>84</i>&nbsp; * {@code IOException} in an appropriate unchecked exception.  (The
<i>85</i>&nbsp; * specification for the persistent collection should indicate that it is
<i>86</i>&nbsp; * capable of throwing such exceptions.)
<i>87</i>&nbsp; *
<i>88</i>&nbsp; * &lt;p&gt;A cause can be associated with a throwable in two ways: via a
<i>89</i>&nbsp; * constructor that takes the cause as an argument, or via the
<i>90</i>&nbsp; * {@link #initCause(Throwable)} method.  New throwable classes that
<i>91</i>&nbsp; * wish to allow causes to be associated with them should provide constructors
<i>92</i>&nbsp; * that take a cause and delegate (perhaps indirectly) to one of the
<i>93</i>&nbsp; * {@code Throwable} constructors that takes a cause.
<i>94</i>&nbsp; *
<i>95</i>&nbsp; * Because the {@code initCause} method is public, it allows a cause to be
<i>96</i>&nbsp; * associated with any throwable, even a &quot;legacy throwable&quot; whose
<i>97</i>&nbsp; * implementation predates the addition of the exception chaining mechanism to
<i>98</i>&nbsp; * {@code Throwable}.
<i>99</i>&nbsp; *
<i>100</i>&nbsp; * &lt;p&gt;By convention, class {@code Throwable} and its subclasses have two
<i>101</i>&nbsp; * constructors, one that takes no arguments and one that takes a
<i>102</i>&nbsp; * {@code String} argument that can be used to produce a detail message.
<i>103</i>&nbsp; * Further, those subclasses that might likely have a cause associated with
<i>104</i>&nbsp; * them should have two more constructors, one that takes a
<i>105</i>&nbsp; * {@code Throwable} (the cause), and one that takes a
<i>106</i>&nbsp; * {@code String} (the detail message) and a {@code Throwable} (the
<i>107</i>&nbsp; * cause).
<i>108</i>&nbsp; *
<i>109</i>&nbsp; * @author  unascribed
<i>110</i>&nbsp; * @author  Josh Bloch (Added exception chaining and programmatic access to
<i>111</i>&nbsp; *          stack trace in 1.4.)
<i>112</i>&nbsp; * @jls 11.2 Compile-Time Checking of Exceptions
<i>113</i>&nbsp; * @since 1.0
<b class="nc"><i>114</i>&nbsp; */</b>
<i>115</i>&nbsp;public class Throwable implements Serializable {
<i>116</i>&nbsp;    /** use serialVersionUID from JDK 1.0.2 for interoperability */
<i>117</i>&nbsp;    private static final long serialVersionUID = -3042686055658047285L;
<i>118</i>&nbsp;
<i>119</i>&nbsp;    /**
<i>120</i>&nbsp;     * The JVM saves some indication of the stack backtrace in this slot.
<i>121</i>&nbsp;     */
<i>122</i>&nbsp;    private transient Object backtrace;
<i>123</i>&nbsp;
<i>124</i>&nbsp;    /**
<i>125</i>&nbsp;     * Specific details about the Throwable.  For example, for
<i>126</i>&nbsp;     * {@code FileNotFoundException}, this contains the name of
<i>127</i>&nbsp;     * the file that could not be found.
<i>128</i>&nbsp;     *
<i>129</i>&nbsp;     * @serial
<i>130</i>&nbsp;     */
<i>131</i>&nbsp;    private String detailMessage;
<i>132</i>&nbsp;
<i>133</i>&nbsp;
<i>134</i>&nbsp;    /**
<i>135</i>&nbsp;     * Holder class to defer initializing sentinel objects only used
<i>136</i>&nbsp;     * for serialization.
<b class="nc"><i>137</i>&nbsp;     */</b>
<i>138</i>&nbsp;    private static class SentinelHolder {
<i>139</i>&nbsp;        /**
<i>140</i>&nbsp;         * {@linkplain #setStackTrace(StackTraceElement[]) Setting the
<i>141</i>&nbsp;         * stack trace} to a one-element array containing this sentinel
<i>142</i>&nbsp;         * value indicates future attempts to set the stack trace will be
<i>143</i>&nbsp;         * ignored.  The sentinel is equal to the result of calling:&lt;br&gt;
<i>144</i>&nbsp;         * {@code new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}
<b class="nc"><i>145</i>&nbsp;         */</b>
<i>146</i>&nbsp;        public static final StackTraceElement STACK_TRACE_ELEMENT_SENTINEL =
<i>147</i>&nbsp;            new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE);
<i>148</i>&nbsp;
<i>149</i>&nbsp;        /**
<i>150</i>&nbsp;         * Sentinel value used in the serial form to indicate an immutable
<i>151</i>&nbsp;         * stack trace.
<b class="nc"><i>152</i>&nbsp;         */</b>
<i>153</i>&nbsp;        public static final StackTraceElement[] STACK_TRACE_SENTINEL =
<i>154</i>&nbsp;            new StackTraceElement[] {STACK_TRACE_ELEMENT_SENTINEL};
<i>155</i>&nbsp;    }
<i>156</i>&nbsp;
<i>157</i>&nbsp;    /**
<i>158</i>&nbsp;     * A shared value for an empty stack.
<b class="nc"><i>159</i>&nbsp;     */</b>
<i>160</i>&nbsp;    private static final StackTraceElement[] UNASSIGNED_STACK = new StackTraceElement[0];
<i>161</i>&nbsp;
<i>162</i>&nbsp;    /*
<i>163</i>&nbsp;     * To allow Throwable objects to be made immutable and safely
<i>164</i>&nbsp;     * reused by the JVM, such as OutOfMemoryErrors, fields of
<i>165</i>&nbsp;     * Throwable that are writable in response to user actions, cause,
<i>166</i>&nbsp;     * stackTrace, and suppressedExceptions obey the following
<i>167</i>&nbsp;     * protocol:
<i>168</i>&nbsp;     *
<i>169</i>&nbsp;     * 1) The fields are initialized to a non-null sentinel value
<i>170</i>&nbsp;     * which indicates the value has logically not been set.
<i>171</i>&nbsp;     *
<i>172</i>&nbsp;     * 2) Writing a null to the field indicates further writes
<i>173</i>&nbsp;     * are forbidden
<i>174</i>&nbsp;     *
<i>175</i>&nbsp;     * 3) The sentinel value may be replaced with another non-null
<i>176</i>&nbsp;     * value.
<i>177</i>&nbsp;     *
<i>178</i>&nbsp;     * For example, implementations of the HotSpot JVM have
<i>179</i>&nbsp;     * preallocated OutOfMemoryError objects to provide for better
<i>180</i>&nbsp;     * diagnosability of that situation.  These objects are created
<i>181</i>&nbsp;     * without calling the constructor for that class and the fields
<i>182</i>&nbsp;     * in question are initialized to null.  To support this
<i>183</i>&nbsp;     * capability, any new fields added to Throwable that require
<i>184</i>&nbsp;     * being initialized to a non-null value require a coordinated JVM
<i>185</i>&nbsp;     * change.
<i>186</i>&nbsp;     */
<i>187</i>&nbsp;
<i>188</i>&nbsp;    /**
<i>189</i>&nbsp;     * The throwable that caused this throwable to get thrown, or null if this
<i>190</i>&nbsp;     * throwable was not caused by another throwable, or if the causative
<i>191</i>&nbsp;     * throwable is unknown.  If this field is equal to this throwable itself,
<i>192</i>&nbsp;     * it indicates that the cause of this throwable has not yet been
<i>193</i>&nbsp;     * initialized.
<i>194</i>&nbsp;     *
<i>195</i>&nbsp;     * @serial
<i>196</i>&nbsp;     * @since 1.4
<b class="nc"><i>197</i>&nbsp;     */</b>
<i>198</i>&nbsp;    private Throwable cause = this;
<i>199</i>&nbsp;
<i>200</i>&nbsp;    /**
<i>201</i>&nbsp;     * The stack trace, as returned by {@link #getStackTrace()}.
<i>202</i>&nbsp;     *
<i>203</i>&nbsp;     * The field is initialized to a zero-length array.  A {@code
<i>204</i>&nbsp;     * null} value of this field indicates subsequent calls to {@link
<i>205</i>&nbsp;     * #setStackTrace(StackTraceElement[])} and {@link
<i>206</i>&nbsp;     * #fillInStackTrace()} will be no-ops.
<i>207</i>&nbsp;     *
<i>208</i>&nbsp;     * @serial
<i>209</i>&nbsp;     * @since 1.4
<b class="nc"><i>210</i>&nbsp;     */</b>
<i>211</i>&nbsp;    private StackTraceElement[] stackTrace = UNASSIGNED_STACK;
<i>212</i>&nbsp;
<i>213</i>&nbsp;    /**
<b class="nc"><i>214</i>&nbsp;     * The JVM code sets the depth of the backtrace for later retrieval</b>
<b class="nc"><i>215</i>&nbsp;     */</b>
<i>216</i>&nbsp;    private transient int depth;
<i>217</i>&nbsp;
<i>218</i>&nbsp;    // Setting this static field introduces an acceptable
<i>219</i>&nbsp;    // initialization dependency on a few java.util classes.
<i>220</i>&nbsp;    private static final List&lt;Throwable&gt; SUPPRESSED_SENTINEL = Collections.emptyList();
<i>221</i>&nbsp;
<i>222</i>&nbsp;    /**
<i>223</i>&nbsp;     * The list of suppressed exceptions, as returned by {@link
<i>224</i>&nbsp;     * #getSuppressed()}.  The list is initialized to a zero-element
<i>225</i>&nbsp;     * unmodifiable sentinel list.  When a serialized Throwable is
<i>226</i>&nbsp;     * read in, if the {@code suppressedExceptions} field points to a
<b class="nc"><i>227</i>&nbsp;     * zero-element list, the field is reset to the sentinel value.</b>
<i>228</i>&nbsp;     *
<i>229</i>&nbsp;     * @serial
<i>230</i>&nbsp;     * @since 1.7
<i>231</i>&nbsp;     */
<i>232</i>&nbsp;    private List&lt;Throwable&gt; suppressedExceptions = SUPPRESSED_SENTINEL;
<i>233</i>&nbsp;
<i>234</i>&nbsp;    /** Message for trying to suppress a null exception. */
<i>235</i>&nbsp;    private static final String NULL_CAUSE_MESSAGE = &quot;Cannot suppress a null exception.&quot;;
<i>236</i>&nbsp;
<i>237</i>&nbsp;    /** Message for trying to suppress oneself. */
<i>238</i>&nbsp;    private static final String SELF_SUPPRESSION_MESSAGE = &quot;Self-suppression not permitted&quot;;
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /** Caption  for labeling causative exception stack traces */
<i>241</i>&nbsp;    private static final String CAUSE_CAPTION = &quot;Caused by: &quot;;
<i>242</i>&nbsp;
<i>243</i>&nbsp;    /** Caption for labeling suppressed exception stack traces */
<i>244</i>&nbsp;    private static final String SUPPRESSED_CAPTION = &quot;Suppressed: &quot;;
<i>245</i>&nbsp;
<i>246</i>&nbsp;    /**
<i>247</i>&nbsp;     * Constructs a new throwable with {@code null} as its detail message.
<i>248</i>&nbsp;     * The cause is not initialized, and may subsequently be initialized by a
<b class="nc"><i>249</i>&nbsp;     * call to {@link #initCause}.</b>
<b class="nc"><i>250</i>&nbsp;     *</b>
<i>251</i>&nbsp;     * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
<i>252</i>&nbsp;     * the stack trace data in the newly created throwable.
<i>253</i>&nbsp;     */
<i>254</i>&nbsp;    public Throwable() {
<i>255</i>&nbsp;        fillInStackTrace();
<i>256</i>&nbsp;    }
<i>257</i>&nbsp;
<i>258</i>&nbsp;    /**
<i>259</i>&nbsp;     * Constructs a new throwable with the specified detail message.  The
<i>260</i>&nbsp;     * cause is not initialized, and may subsequently be initialized by
<i>261</i>&nbsp;     * a call to {@link #initCause}.
<i>262</i>&nbsp;     *
<i>263</i>&nbsp;     * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
<b class="nc"><i>264</i>&nbsp;     * the stack trace data in the newly created throwable.</b>
<b class="nc"><i>265</i>&nbsp;     *</b>
<b class="nc"><i>266</i>&nbsp;     * @param   message   the detail message. The detail message is saved for</b>
<i>267</i>&nbsp;     *          later retrieval by the {@link #getMessage()} method.
<i>268</i>&nbsp;     */
<i>269</i>&nbsp;    public Throwable(String message) {
<i>270</i>&nbsp;        fillInStackTrace();
<i>271</i>&nbsp;        detailMessage = message;
<i>272</i>&nbsp;    }
<i>273</i>&nbsp;
<i>274</i>&nbsp;    /**
<i>275</i>&nbsp;     * Constructs a new throwable with the specified detail message and
<i>276</i>&nbsp;     * cause.  &lt;p&gt;Note that the detail message associated with
<i>277</i>&nbsp;     * {@code cause} is &lt;i&gt;not&lt;/i&gt; automatically incorporated in
<i>278</i>&nbsp;     * this throwable&#39;s detail message.
<i>279</i>&nbsp;     *
<i>280</i>&nbsp;     * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
<i>281</i>&nbsp;     * the stack trace data in the newly created throwable.
<i>282</i>&nbsp;     *
<i>283</i>&nbsp;     * @param  message the detail message (which is saved for later retrieval
<i>284</i>&nbsp;     *         by the {@link #getMessage()} method).
<i>285</i>&nbsp;     * @param  cause the cause (which is saved for later retrieval by the
<b class="nc"><i>286</i>&nbsp;     *         {@link #getCause()} method).  (A {@code null} value is</b>
<b class="nc"><i>287</i>&nbsp;     *         permitted, and indicates that the cause is nonexistent or</b>
<b class="nc"><i>288</i>&nbsp;     *         unknown.)</b>
<b class="nc"><i>289</i>&nbsp;     * @since  1.4</b>
<i>290</i>&nbsp;     */
<i>291</i>&nbsp;    public Throwable(String message, Throwable cause) {
<i>292</i>&nbsp;        fillInStackTrace();
<i>293</i>&nbsp;        detailMessage = message;
<i>294</i>&nbsp;        this.cause = cause;
<i>295</i>&nbsp;    }
<i>296</i>&nbsp;
<i>297</i>&nbsp;    /**
<i>298</i>&nbsp;     * Constructs a new throwable with the specified cause and a detail
<i>299</i>&nbsp;     * message of {@code (cause==null ? null : cause.toString())} (which
<i>300</i>&nbsp;     * typically contains the class and detail message of {@code cause}).
<i>301</i>&nbsp;     * This constructor is useful for throwables that are little more than
<i>302</i>&nbsp;     * wrappers for other throwables (for example, {@link
<i>303</i>&nbsp;     * java.security.PrivilegedActionException}).
<i>304</i>&nbsp;     *
<i>305</i>&nbsp;     * &lt;p&gt;The {@link #fillInStackTrace()} method is called to initialize
<i>306</i>&nbsp;     * the stack trace data in the newly created throwable.
<i>307</i>&nbsp;     *
<i>308</i>&nbsp;     * @param  cause the cause (which is saved for later retrieval by the
<b class="nc"><i>309</i>&nbsp;     *         {@link #getCause()} method).  (A {@code null} value is</b>
<b class="nc"><i>310</i>&nbsp;     *         permitted, and indicates that the cause is nonexistent or</b>
<b class="nc"><i>311</i>&nbsp;     *         unknown.)</b>
<b class="nc"><i>312</i>&nbsp;     * @since  1.4</b>
<i>313</i>&nbsp;     */
<i>314</i>&nbsp;    public Throwable(Throwable cause) {
<i>315</i>&nbsp;        fillInStackTrace();
<i>316</i>&nbsp;        detailMessage = (cause==null ? null : cause.toString());
<i>317</i>&nbsp;        this.cause = cause;
<i>318</i>&nbsp;    }
<i>319</i>&nbsp;
<i>320</i>&nbsp;    /**
<i>321</i>&nbsp;     * Constructs a new throwable with the specified detail message,
<i>322</i>&nbsp;     * cause, {@linkplain #addSuppressed suppression} enabled or
<i>323</i>&nbsp;     * disabled, and writable stack trace enabled or disabled.  If
<i>324</i>&nbsp;     * suppression is disabled, {@link #getSuppressed} for this object
<i>325</i>&nbsp;     * will return a zero-length array and calls to {@link
<i>326</i>&nbsp;     * #addSuppressed} that would otherwise append an exception to the
<i>327</i>&nbsp;     * suppressed list will have no effect.  If the writable stack
<i>328</i>&nbsp;     * trace is false, this constructor will not call {@link
<i>329</i>&nbsp;     * #fillInStackTrace()}, a {@code null} will be written to the
<i>330</i>&nbsp;     * {@code stackTrace} field, and subsequent calls to {@code
<i>331</i>&nbsp;     * fillInStackTrace} and {@link
<i>332</i>&nbsp;     * #setStackTrace(StackTraceElement[])} will not set the stack
<i>333</i>&nbsp;     * trace.  If the writable stack trace is false, {@link
<i>334</i>&nbsp;     * #getStackTrace} will return a zero length array.
<i>335</i>&nbsp;     *
<i>336</i>&nbsp;     * &lt;p&gt;Note that the other constructors of {@code Throwable} treat
<i>337</i>&nbsp;     * suppression as being enabled and the stack trace as being
<i>338</i>&nbsp;     * writable.  Subclasses of {@code Throwable} should document any
<i>339</i>&nbsp;     * conditions under which suppression is disabled and document
<i>340</i>&nbsp;     * conditions under which the stack trace is not writable.
<i>341</i>&nbsp;     * Disabling of suppression should only occur in exceptional
<i>342</i>&nbsp;     * circumstances where special requirements exist, such as a
<i>343</i>&nbsp;     * virtual machine reusing exception objects under low-memory
<i>344</i>&nbsp;     * situations.  Circumstances where a given exception object is
<i>345</i>&nbsp;     * repeatedly caught and rethrown, such as to implement control
<i>346</i>&nbsp;     * flow between two sub-systems, is another situation where
<i>347</i>&nbsp;     * immutable throwable objects would be appropriate.
<i>348</i>&nbsp;     *
<i>349</i>&nbsp;     * @param  message the detail message.
<i>350</i>&nbsp;     * @param cause the cause.  (A {@code null} value is permitted,
<i>351</i>&nbsp;     * and indicates that the cause is nonexistent or unknown.)
<i>352</i>&nbsp;     * @param enableSuppression whether or not suppression is enabled or disabled
<i>353</i>&nbsp;     * @param writableStackTrace whether or not the stack trace should be
<i>354</i>&nbsp;     *                           writable
<i>355</i>&nbsp;     *
<i>356</i>&nbsp;     * @see OutOfMemoryError
<i>357</i>&nbsp;     * @see NullPointerException
<b class="nc"><i>358</i>&nbsp;     * @see ArithmeticException</b>
<b class="nc"><i>359</i>&nbsp;     * @since 1.7</b>
<b class="nc"><i>360</i>&nbsp;     */</b>
<i>361</i>&nbsp;    protected Throwable(String message, Throwable cause,
<b class="nc"><i>362</i>&nbsp;                        boolean enableSuppression,</b>
<i>363</i>&nbsp;                        boolean writableStackTrace) {
<b class="nc"><i>364</i>&nbsp;        if (writableStackTrace) {</b>
<b class="nc"><i>365</i>&nbsp;            fillInStackTrace();</b>
<b class="nc"><i>366</i>&nbsp;        } else {</b>
<b class="nc"><i>367</i>&nbsp;            stackTrace = null;</b>
<i>368</i>&nbsp;        }
<i>369</i>&nbsp;        detailMessage = message;
<i>370</i>&nbsp;        this.cause = cause;
<i>371</i>&nbsp;        if (!enableSuppression)
<i>372</i>&nbsp;            suppressedExceptions = null;
<i>373</i>&nbsp;    }
<i>374</i>&nbsp;
<i>375</i>&nbsp;    /**
<i>376</i>&nbsp;     * Returns the detail message string of this throwable.
<b class="nc"><i>377</i>&nbsp;     *</b>
<i>378</i>&nbsp;     * @return  the detail message string of this {@code Throwable} instance
<i>379</i>&nbsp;     *          (which may be {@code null}).
<i>380</i>&nbsp;     */
<i>381</i>&nbsp;    public String getMessage() {
<i>382</i>&nbsp;        return detailMessage;
<i>383</i>&nbsp;    }
<i>384</i>&nbsp;
<i>385</i>&nbsp;    /**
<i>386</i>&nbsp;     * Creates a localized description of this throwable.
<i>387</i>&nbsp;     * Subclasses may override this method in order to produce a
<i>388</i>&nbsp;     * locale-specific message.  For subclasses that do not override this
<i>389</i>&nbsp;     * method, the default implementation returns the same result as
<i>390</i>&nbsp;     * {@code getMessage()}.
<b class="nc"><i>391</i>&nbsp;     *</b>
<i>392</i>&nbsp;     * @return  The localized description of this throwable.
<i>393</i>&nbsp;     * @since   1.1
<i>394</i>&nbsp;     */
<i>395</i>&nbsp;    public String getLocalizedMessage() {
<i>396</i>&nbsp;        return getMessage();
<i>397</i>&nbsp;    }
<i>398</i>&nbsp;
<i>399</i>&nbsp;    /**
<i>400</i>&nbsp;     * Returns the cause of this throwable or {@code null} if the
<i>401</i>&nbsp;     * cause is nonexistent or unknown.  (The cause is the throwable that
<i>402</i>&nbsp;     * caused this throwable to get thrown.)
<i>403</i>&nbsp;     *
<i>404</i>&nbsp;     * &lt;p&gt;This implementation returns the cause that was supplied via one of
<i>405</i>&nbsp;     * the constructors requiring a {@code Throwable}, or that was set after
<i>406</i>&nbsp;     * creation with the {@link #initCause(Throwable)} method.  While it is
<i>407</i>&nbsp;     * typically unnecessary to override this method, a subclass can override
<i>408</i>&nbsp;     * it to return a cause set by some other means.  This is appropriate for
<i>409</i>&nbsp;     * a &quot;legacy chained throwable&quot; that predates the addition of chained
<i>410</i>&nbsp;     * exceptions to {@code Throwable}.  Note that it is &lt;i&gt;not&lt;/i&gt;
<i>411</i>&nbsp;     * necessary to override any of the {@code PrintStackTrace} methods,
<i>412</i>&nbsp;     * all of which invoke the {@code getCause} method to determine the
<i>413</i>&nbsp;     * cause of a throwable.
<i>414</i>&nbsp;     *
<b class="nc"><i>415</i>&nbsp;     * @return  the cause of this throwable or {@code null} if the</b>
<i>416</i>&nbsp;     *          cause is nonexistent or unknown.
<i>417</i>&nbsp;     * @since 1.4
<i>418</i>&nbsp;     */
<i>419</i>&nbsp;    public synchronized Throwable getCause() {
<i>420</i>&nbsp;        return (cause==this ? null : cause);
<i>421</i>&nbsp;    }
<i>422</i>&nbsp;
<i>423</i>&nbsp;    /**
<i>424</i>&nbsp;     * Initializes the &lt;i&gt;cause&lt;/i&gt; of this throwable to the specified value.
<i>425</i>&nbsp;     * (The cause is the throwable that caused this throwable to get thrown.)
<i>426</i>&nbsp;     *
<i>427</i>&nbsp;     * &lt;p&gt;This method can be called at most once.  It is generally called from
<i>428</i>&nbsp;     * within the constructor, or immediately after creating the
<i>429</i>&nbsp;     * throwable.  If this throwable was created
<i>430</i>&nbsp;     * with {@link #Throwable(Throwable)} or
<i>431</i>&nbsp;     * {@link #Throwable(String,Throwable)}, this method cannot be called
<i>432</i>&nbsp;     * even once.
<i>433</i>&nbsp;     *
<i>434</i>&nbsp;     * &lt;p&gt;An example of using this method on a legacy throwable type
<i>435</i>&nbsp;     * without other support for setting the cause is:
<i>436</i>&nbsp;     *
<i>437</i>&nbsp;     * &lt;pre&gt;
<i>438</i>&nbsp;     * try {
<i>439</i>&nbsp;     *     lowLevelOp();
<i>440</i>&nbsp;     * } catch (LowLevelException le) {
<i>441</i>&nbsp;     *     throw (HighLevelException)
<i>442</i>&nbsp;     *           new HighLevelException().initCause(le); // Legacy constructor
<i>443</i>&nbsp;     * }
<i>444</i>&nbsp;     * &lt;/pre&gt;
<i>445</i>&nbsp;     *
<i>446</i>&nbsp;     * @param  cause the cause (which is saved for later retrieval by the
<i>447</i>&nbsp;     *         {@link #getCause()} method).  (A {@code null} value is
<i>448</i>&nbsp;     *         permitted, and indicates that the cause is nonexistent or
<i>449</i>&nbsp;     *         unknown.)
<i>450</i>&nbsp;     * @return  a reference to this {@code Throwable} instance.
<i>451</i>&nbsp;     * @throws IllegalArgumentException if {@code cause} is this
<i>452</i>&nbsp;     *         throwable.  (A throwable cannot be its own cause.)
<i>453</i>&nbsp;     * @throws IllegalStateException if this throwable was
<i>454</i>&nbsp;     *         created with {@link #Throwable(Throwable)} or
<b class="nc"><i>455</i>&nbsp;     *         {@link #Throwable(String,Throwable)}, or this method has already</b>
<b class="nc"><i>456</i>&nbsp;     *         been called on this throwable.</b>
<b class="nc"><i>457</i>&nbsp;     * @since  1.4</b>
<b class="nc"><i>458</i>&nbsp;     */</b>
<b class="nc"><i>459</i>&nbsp;    public synchronized Throwable initCause(Throwable cause) {</b>
<b class="nc"><i>460</i>&nbsp;        if (this.cause != this)</b>
<b class="nc"><i>461</i>&nbsp;            throw new IllegalStateException(&quot;Can&#39;t overwrite cause with &quot; +</b>
<i>462</i>&nbsp;                                            Objects.toString(cause, &quot;a null&quot;), this);
<i>463</i>&nbsp;        if (cause == this)
<i>464</i>&nbsp;            throw new IllegalArgumentException(&quot;Self-causation not permitted&quot;, this);
<i>465</i>&nbsp;        this.cause = cause;
<i>466</i>&nbsp;        return this;
<i>467</i>&nbsp;    }
<i>468</i>&nbsp;
<i>469</i>&nbsp;    /**
<i>470</i>&nbsp;     * Returns a short description of this throwable.
<i>471</i>&nbsp;     * The result is the concatenation of:
<i>472</i>&nbsp;     * &lt;ul&gt;
<i>473</i>&nbsp;     * &lt;li&gt; the {@linkplain Class#getName() name} of the class of this object
<i>474</i>&nbsp;     * &lt;li&gt; &quot;: &quot; (a colon and a space)
<i>475</i>&nbsp;     * &lt;li&gt; the result of invoking this object&#39;s {@link #getLocalizedMessage}
<i>476</i>&nbsp;     *      method
<i>477</i>&nbsp;     * &lt;/ul&gt;
<i>478</i>&nbsp;     * If {@code getLocalizedMessage} returns {@code null}, then just
<b class="nc"><i>479</i>&nbsp;     * the class name is returned.</b>
<b class="nc"><i>480</i>&nbsp;     *</b>
<b class="nc"><i>481</i>&nbsp;     * @return a string representation of this throwable.</b>
<i>482</i>&nbsp;     */
<i>483</i>&nbsp;    public String toString() {
<i>484</i>&nbsp;        String s = getClass().getName();
<i>485</i>&nbsp;        String message = getLocalizedMessage();
<i>486</i>&nbsp;        return (message != null) ? (s + &quot;: &quot; + message) : s;
<i>487</i>&nbsp;    }
<i>488</i>&nbsp;
<i>489</i>&nbsp;    /**
<i>490</i>&nbsp;     * Prints this throwable and its backtrace to the
<i>491</i>&nbsp;     * standard error stream. This method prints a stack trace for this
<i>492</i>&nbsp;     * {@code Throwable} object on the error output stream that is
<i>493</i>&nbsp;     * the value of the field {@code System.err}. The first line of
<i>494</i>&nbsp;     * output contains the result of the {@link #toString()} method for
<i>495</i>&nbsp;     * this object.  Remaining lines represent data previously recorded by
<i>496</i>&nbsp;     * the method {@link #fillInStackTrace()}. The format of this
<i>497</i>&nbsp;     * information depends on the implementation, but the following
<i>498</i>&nbsp;     * example may be regarded as typical:
<i>499</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>500</i>&nbsp;     * java.lang.NullPointerException
<i>501</i>&nbsp;     *         at MyClass.mash(MyClass.java:9)
<i>502</i>&nbsp;     *         at MyClass.crunch(MyClass.java:6)
<i>503</i>&nbsp;     *         at MyClass.main(MyClass.java:3)
<i>504</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>505</i>&nbsp;     * This example was produced by running the program:
<i>506</i>&nbsp;     * &lt;pre&gt;
<i>507</i>&nbsp;     * class MyClass {
<i>508</i>&nbsp;     *     public static void main(String[] args) {
<i>509</i>&nbsp;     *         crunch(null);
<i>510</i>&nbsp;     *     }
<i>511</i>&nbsp;     *     static void crunch(int[] a) {
<i>512</i>&nbsp;     *         mash(a);
<i>513</i>&nbsp;     *     }
<i>514</i>&nbsp;     *     static void mash(int[] b) {
<i>515</i>&nbsp;     *         System.out.println(b[0]);
<i>516</i>&nbsp;     *     }
<i>517</i>&nbsp;     * }
<i>518</i>&nbsp;     * &lt;/pre&gt;
<i>519</i>&nbsp;     * The backtrace for a throwable with an initialized, non-null cause
<i>520</i>&nbsp;     * should generally include the backtrace for the cause.  The format
<i>521</i>&nbsp;     * of this information depends on the implementation, but the following
<i>522</i>&nbsp;     * example may be regarded as typical:
<i>523</i>&nbsp;     * &lt;pre&gt;
<i>524</i>&nbsp;     * HighLevelException: MidLevelException: LowLevelException
<i>525</i>&nbsp;     *         at Junk.a(Junk.java:13)
<i>526</i>&nbsp;     *         at Junk.main(Junk.java:4)
<i>527</i>&nbsp;     * Caused by: MidLevelException: LowLevelException
<i>528</i>&nbsp;     *         at Junk.c(Junk.java:23)
<i>529</i>&nbsp;     *         at Junk.b(Junk.java:17)
<i>530</i>&nbsp;     *         at Junk.a(Junk.java:11)
<i>531</i>&nbsp;     *         ... 1 more
<i>532</i>&nbsp;     * Caused by: LowLevelException
<i>533</i>&nbsp;     *         at Junk.e(Junk.java:30)
<i>534</i>&nbsp;     *         at Junk.d(Junk.java:27)
<i>535</i>&nbsp;     *         at Junk.c(Junk.java:21)
<i>536</i>&nbsp;     *         ... 3 more
<i>537</i>&nbsp;     * &lt;/pre&gt;
<i>538</i>&nbsp;     * Note the presence of lines containing the characters {@code &quot;...&quot;}.
<i>539</i>&nbsp;     * These lines indicate that the remainder of the stack trace for this
<i>540</i>&nbsp;     * exception matches the indicated number of frames from the bottom of the
<i>541</i>&nbsp;     * stack trace of the exception that was caused by this exception (the
<i>542</i>&nbsp;     * &quot;enclosing&quot; exception).  This shorthand can greatly reduce the length
<i>543</i>&nbsp;     * of the output in the common case where a wrapped exception is thrown
<i>544</i>&nbsp;     * from same method as the &quot;causative exception&quot; is caught.  The above
<i>545</i>&nbsp;     * example was produced by running the program:
<i>546</i>&nbsp;     * &lt;pre&gt;
<i>547</i>&nbsp;     * public class Junk {
<i>548</i>&nbsp;     *     public static void main(String args[]) {
<i>549</i>&nbsp;     *         try {
<i>550</i>&nbsp;     *             a();
<i>551</i>&nbsp;     *         } catch(HighLevelException e) {
<i>552</i>&nbsp;     *             e.printStackTrace();
<i>553</i>&nbsp;     *         }
<i>554</i>&nbsp;     *     }
<i>555</i>&nbsp;     *     static void a() throws HighLevelException {
<i>556</i>&nbsp;     *         try {
<i>557</i>&nbsp;     *             b();
<i>558</i>&nbsp;     *         } catch(MidLevelException e) {
<i>559</i>&nbsp;     *             throw new HighLevelException(e);
<i>560</i>&nbsp;     *         }
<i>561</i>&nbsp;     *     }
<i>562</i>&nbsp;     *     static void b() throws MidLevelException {
<i>563</i>&nbsp;     *         c();
<i>564</i>&nbsp;     *     }
<i>565</i>&nbsp;     *     static void c() throws MidLevelException {
<i>566</i>&nbsp;     *         try {
<i>567</i>&nbsp;     *             d();
<i>568</i>&nbsp;     *         } catch(LowLevelException e) {
<i>569</i>&nbsp;     *             throw new MidLevelException(e);
<i>570</i>&nbsp;     *         }
<i>571</i>&nbsp;     *     }
<i>572</i>&nbsp;     *     static void d() throws LowLevelException {
<i>573</i>&nbsp;     *        e();
<i>574</i>&nbsp;     *     }
<i>575</i>&nbsp;     *     static void e() throws LowLevelException {
<i>576</i>&nbsp;     *         throw new LowLevelException();
<i>577</i>&nbsp;     *     }
<i>578</i>&nbsp;     * }
<i>579</i>&nbsp;     *
<i>580</i>&nbsp;     * class HighLevelException extends Exception {
<i>581</i>&nbsp;     *     HighLevelException(Throwable cause) { super(cause); }
<i>582</i>&nbsp;     * }
<i>583</i>&nbsp;     *
<i>584</i>&nbsp;     * class MidLevelException extends Exception {
<i>585</i>&nbsp;     *     MidLevelException(Throwable cause)  { super(cause); }
<i>586</i>&nbsp;     * }
<i>587</i>&nbsp;     *
<i>588</i>&nbsp;     * class LowLevelException extends Exception {
<i>589</i>&nbsp;     * }
<i>590</i>&nbsp;     * &lt;/pre&gt;
<i>591</i>&nbsp;     * As of release 7, the platform supports the notion of
<i>592</i>&nbsp;     * &lt;i&gt;suppressed exceptions&lt;/i&gt; (in conjunction with the {@code
<i>593</i>&nbsp;     * try}-with-resources statement). Any exceptions that were
<i>594</i>&nbsp;     * suppressed in order to deliver an exception are printed out
<i>595</i>&nbsp;     * beneath the stack trace.  The format of this information
<i>596</i>&nbsp;     * depends on the implementation, but the following example may be
<i>597</i>&nbsp;     * regarded as typical:
<i>598</i>&nbsp;     *
<i>599</i>&nbsp;     * &lt;pre&gt;
<i>600</i>&nbsp;     * Exception in thread &quot;main&quot; java.lang.Exception: Something happened
<i>601</i>&nbsp;     *  at Foo.bar(Foo.java:10)
<i>602</i>&nbsp;     *  at Foo.main(Foo.java:5)
<i>603</i>&nbsp;     *  Suppressed: Resource$CloseFailException: Resource ID = 0
<i>604</i>&nbsp;     *          at Resource.close(Resource.java:26)
<i>605</i>&nbsp;     *          at Foo.bar(Foo.java:9)
<i>606</i>&nbsp;     *          ... 1 more
<i>607</i>&nbsp;     * &lt;/pre&gt;
<i>608</i>&nbsp;     * Note that the &quot;... n more&quot; notation is used on suppressed exceptions
<i>609</i>&nbsp;     * just at it is used on causes. Unlike causes, suppressed exceptions are
<i>610</i>&nbsp;     * indented beyond their &quot;containing exceptions.&quot;
<i>611</i>&nbsp;     *
<i>612</i>&nbsp;     * &lt;p&gt;An exception can have both a cause and one or more suppressed
<i>613</i>&nbsp;     * exceptions:
<i>614</i>&nbsp;     * &lt;pre&gt;
<i>615</i>&nbsp;     * Exception in thread &quot;main&quot; java.lang.Exception: Main block
<i>616</i>&nbsp;     *  at Foo3.main(Foo3.java:7)
<i>617</i>&nbsp;     *  Suppressed: Resource$CloseFailException: Resource ID = 2
<i>618</i>&nbsp;     *          at Resource.close(Resource.java:26)
<i>619</i>&nbsp;     *          at Foo3.main(Foo3.java:5)
<i>620</i>&nbsp;     *  Suppressed: Resource$CloseFailException: Resource ID = 1
<i>621</i>&nbsp;     *          at Resource.close(Resource.java:26)
<i>622</i>&nbsp;     *          at Foo3.main(Foo3.java:5)
<i>623</i>&nbsp;     * Caused by: java.lang.Exception: I did it
<i>624</i>&nbsp;     *  at Foo3.main(Foo3.java:8)
<i>625</i>&nbsp;     * &lt;/pre&gt;
<i>626</i>&nbsp;     * Likewise, a suppressed exception can have a cause:
<i>627</i>&nbsp;     * &lt;pre&gt;
<i>628</i>&nbsp;     * Exception in thread &quot;main&quot; java.lang.Exception: Main block
<i>629</i>&nbsp;     *  at Foo4.main(Foo4.java:6)
<i>630</i>&nbsp;     *  Suppressed: Resource2$CloseFailException: Resource ID = 1
<i>631</i>&nbsp;     *          at Resource2.close(Resource2.java:20)
<i>632</i>&nbsp;     *          at Foo4.main(Foo4.java:5)
<i>633</i>&nbsp;     *  Caused by: java.lang.Exception: Rats, you caught me
<b class="nc"><i>634</i>&nbsp;     *          at Resource2$CloseFailException.&amp;lt;init&amp;gt;(Resource2.java:45)</b>
<i>635</i>&nbsp;     *          ... 2 more
<i>636</i>&nbsp;     * &lt;/pre&gt;
<i>637</i>&nbsp;     */
<i>638</i>&nbsp;    public void printStackTrace() {
<i>639</i>&nbsp;        printStackTrace(System.err);
<i>640</i>&nbsp;    }
<i>641</i>&nbsp;
<i>642</i>&nbsp;    /**
<b class="nc"><i>643</i>&nbsp;     * Prints this throwable and its backtrace to the specified print stream.</b>
<i>644</i>&nbsp;     *
<i>645</i>&nbsp;     * @param s {@code PrintStream} to use for output
<i>646</i>&nbsp;     */
<i>647</i>&nbsp;    public void printStackTrace(PrintStream s) {
<i>648</i>&nbsp;        printStackTrace(new WrappedPrintStream(s));
<b class="nc"><i>649</i>&nbsp;    }</b>
<b class="nc"><i>650</i>&nbsp;</b>
<b class="nc"><i>651</i>&nbsp;    private void printStackTrace(PrintStreamOrWriter s) {</b>
<i>652</i>&nbsp;        // Guard against malicious overrides of Throwable.equals by
<b class="nc"><i>653</i>&nbsp;        // using a Set with identity equality semantics.</b>
<i>654</i>&nbsp;        Set&lt;Throwable&gt; dejaVu = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;());
<b class="nc"><i>655</i>&nbsp;        dejaVu.add(this);</b>
<b class="nc"><i>656</i>&nbsp;</b>
<b class="nc"><i>657</i>&nbsp;        synchronized (s.lock()) {</b>
<b class="nc"><i>658</i>&nbsp;            // Print our stack trace</b>
<i>659</i>&nbsp;            s.println(this);
<i>660</i>&nbsp;            StackTraceElement[] trace = getOurStackTrace();
<b class="nc"><i>661</i>&nbsp;            for (StackTraceElement traceElement : trace)</b>
<b class="nc"><i>662</i>&nbsp;                s.println(&quot;\tat &quot; + traceElement);</b>
<i>663</i>&nbsp;
<i>664</i>&nbsp;            // Print suppressed exceptions, if any
<b class="nc"><i>665</i>&nbsp;            for (Throwable se : getSuppressed())</b>
<b class="nc"><i>666</i>&nbsp;                se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);</b>
<b class="nc"><i>667</i>&nbsp;</b>
<b class="nc"><i>668</i>&nbsp;            // Print cause, if any</b>
<i>669</i>&nbsp;            Throwable ourCause = getCause();
<i>670</i>&nbsp;            if (ourCause != null)
<i>671</i>&nbsp;                ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);
<i>672</i>&nbsp;        }
<i>673</i>&nbsp;    }
<i>674</i>&nbsp;
<i>675</i>&nbsp;    /**
<i>676</i>&nbsp;     * Print our stack trace as an enclosed exception for the specified
<i>677</i>&nbsp;     * stack trace.
<i>678</i>&nbsp;     */
<i>679</i>&nbsp;    private void printEnclosedStackTrace(PrintStreamOrWriter s,
<b class="nc"><i>680</i>&nbsp;                                         StackTraceElement[] enclosingTrace,</b>
<b class="nc"><i>681</i>&nbsp;                                         String caption,</b>
<b class="nc"><i>682</i>&nbsp;                                         String prefix,</b>
<i>683</i>&nbsp;                                         Set&lt;Throwable&gt; dejaVu) {
<b class="nc"><i>684</i>&nbsp;        assert Thread.holdsLock(s.lock());</b>
<i>685</i>&nbsp;        if (dejaVu.contains(this)) {
<b class="nc"><i>686</i>&nbsp;            s.println(&quot;\t[CIRCULAR REFERENCE:&quot; + this + &quot;]&quot;);</b>
<b class="nc"><i>687</i>&nbsp;        } else {</b>
<b class="nc"><i>688</i>&nbsp;            dejaVu.add(this);</b>
<b class="nc"><i>689</i>&nbsp;            // Compute number of frames in common between this and enclosing trace</b>
<b class="nc"><i>690</i>&nbsp;            StackTraceElement[] trace = getOurStackTrace();</b>
<i>691</i>&nbsp;            int m = trace.length - 1;
<b class="nc"><i>692</i>&nbsp;            int n = enclosingTrace.length - 1;</b>
<i>693</i>&nbsp;            while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(enclosingTrace[n])) {
<i>694</i>&nbsp;                m--; n--;
<b class="nc"><i>695</i>&nbsp;            }</b>
<b class="nc"><i>696</i>&nbsp;            int framesInCommon = trace.length - 1 - m;</b>
<b class="nc"><i>697</i>&nbsp;</b>
<b class="nc"><i>698</i>&nbsp;            // Print our stack trace</b>
<b class="nc"><i>699</i>&nbsp;            s.println(prefix + caption + this);</b>
<i>700</i>&nbsp;            for (int i = 0; i &lt;= m; i++)
<i>701</i>&nbsp;                s.println(prefix + &quot;\tat &quot; + trace[i]);
<b class="nc"><i>702</i>&nbsp;            if (framesInCommon != 0)</b>
<b class="nc"><i>703</i>&nbsp;                s.println(prefix + &quot;\t... &quot; + framesInCommon + &quot; more&quot;);</b>
<i>704</i>&nbsp;
<i>705</i>&nbsp;            // Print suppressed exceptions, if any
<i>706</i>&nbsp;            for (Throwable se : getSuppressed())
<b class="nc"><i>707</i>&nbsp;                se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION,</b>
<b class="nc"><i>708</i>&nbsp;                                           prefix +&quot;\t&quot;, dejaVu);</b>
<b class="nc"><i>709</i>&nbsp;</b>
<i>710</i>&nbsp;            // Print cause, if any
<i>711</i>&nbsp;            Throwable ourCause = getCause();
<i>712</i>&nbsp;            if (ourCause != null)
<i>713</i>&nbsp;                ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, prefix, dejaVu);
<i>714</i>&nbsp;        }
<i>715</i>&nbsp;    }
<i>716</i>&nbsp;
<i>717</i>&nbsp;    /**
<i>718</i>&nbsp;     * Prints this throwable and its backtrace to the specified
<i>719</i>&nbsp;     * print writer.
<i>720</i>&nbsp;     *
<b class="nc"><i>721</i>&nbsp;     * @param s {@code PrintWriter} to use for output</b>
<i>722</i>&nbsp;     * @since   1.1
<i>723</i>&nbsp;     */
<i>724</i>&nbsp;    public void printStackTrace(PrintWriter s) {
<i>725</i>&nbsp;        printStackTrace(new WrappedPrintWriter(s));
<i>726</i>&nbsp;    }
<i>727</i>&nbsp;
<b class="nc"><i>728</i>&nbsp;    /**</b>
<i>729</i>&nbsp;     * Wrapper class for PrintStream and PrintWriter to enable a single
<i>730</i>&nbsp;     * implementation of printStackTrace.
<i>731</i>&nbsp;     */
<i>732</i>&nbsp;    private abstract static class PrintStreamOrWriter {
<i>733</i>&nbsp;        /** Returns the object to be locked when using this StreamOrWriter */
<i>734</i>&nbsp;        abstract Object lock();
<i>735</i>&nbsp;
<i>736</i>&nbsp;        /** Prints the specified string as a line on this StreamOrWriter */
<i>737</i>&nbsp;        abstract void println(Object o);
<i>738</i>&nbsp;    }
<b class="nc"><i>739</i>&nbsp;</b>
<b class="nc"><i>740</i>&nbsp;    private static class WrappedPrintStream extends PrintStreamOrWriter {</b>
<i>741</i>&nbsp;        private final PrintStream printStream;
<i>742</i>&nbsp;
<i>743</i>&nbsp;        WrappedPrintStream(PrintStream printStream) {
<b class="nc"><i>744</i>&nbsp;            this.printStream = printStream;</b>
<i>745</i>&nbsp;        }
<i>746</i>&nbsp;
<i>747</i>&nbsp;        Object lock() {
<b class="nc"><i>748</i>&nbsp;            return printStream;</b>
<i>749</i>&nbsp;        }
<i>750</i>&nbsp;
<i>751</i>&nbsp;        void println(Object o) {
<i>752</i>&nbsp;            printStream.println(o);
<i>753</i>&nbsp;        }
<i>754</i>&nbsp;    }
<b class="nc"><i>755</i>&nbsp;</b>
<b class="nc"><i>756</i>&nbsp;    private static class WrappedPrintWriter extends PrintStreamOrWriter {</b>
<i>757</i>&nbsp;        private final PrintWriter printWriter;
<i>758</i>&nbsp;
<i>759</i>&nbsp;        WrappedPrintWriter(PrintWriter printWriter) {
<b class="nc"><i>760</i>&nbsp;            this.printWriter = printWriter;</b>
<i>761</i>&nbsp;        }
<i>762</i>&nbsp;
<i>763</i>&nbsp;        Object lock() {
<b class="nc"><i>764</i>&nbsp;            return printWriter;</b>
<i>765</i>&nbsp;        }
<i>766</i>&nbsp;
<i>767</i>&nbsp;        void println(Object o) {
<i>768</i>&nbsp;            printWriter.println(o);
<i>769</i>&nbsp;        }
<i>770</i>&nbsp;    }
<i>771</i>&nbsp;
<i>772</i>&nbsp;    /**
<i>773</i>&nbsp;     * Fills in the execution stack trace. This method records within this
<i>774</i>&nbsp;     * {@code Throwable} object information about the current state of
<i>775</i>&nbsp;     * the stack frames for the current thread.
<i>776</i>&nbsp;     *
<i>777</i>&nbsp;     * &lt;p&gt;If the stack trace of this {@code Throwable} {@linkplain
<i>778</i>&nbsp;     * Throwable#Throwable(String, Throwable, boolean, boolean) is not
<i>779</i>&nbsp;     * writable}, calling this method has no effect.
<i>780</i>&nbsp;     *
<b class="nc"><i>781</i>&nbsp;     * @return  a reference to this {@code Throwable} instance.</b>
<i>782</i>&nbsp;     * @see     java.lang.Throwable#printStackTrace()
<b class="nc"><i>783</i>&nbsp;     */</b>
<b class="nc"><i>784</i>&nbsp;    public synchronized Throwable fillInStackTrace() {</b>
<i>785</i>&nbsp;        if (stackTrace != null ||
<b class="nc"><i>786</i>&nbsp;            backtrace != null /* Out of protocol state */ ) {</b>
<i>787</i>&nbsp;            fillInStackTrace(0);
<i>788</i>&nbsp;            stackTrace = UNASSIGNED_STACK;
<i>789</i>&nbsp;        }
<i>790</i>&nbsp;        return this;
<i>791</i>&nbsp;    }
<i>792</i>&nbsp;
<i>793</i>&nbsp;    private native Throwable fillInStackTrace(int dummy);
<i>794</i>&nbsp;
<i>795</i>&nbsp;    /**
<i>796</i>&nbsp;     * Provides programmatic access to the stack trace information printed by
<i>797</i>&nbsp;     * {@link #printStackTrace()}.  Returns an array of stack trace elements,
<i>798</i>&nbsp;     * each representing one stack frame.  The zeroth element of the array
<i>799</i>&nbsp;     * (assuming the array&#39;s length is non-zero) represents the top of the
<i>800</i>&nbsp;     * stack, which is the last method invocation in the sequence.  Typically,
<i>801</i>&nbsp;     * this is the point at which this throwable was created and thrown.
<i>802</i>&nbsp;     * The last element of the array (assuming the array&#39;s length is non-zero)
<i>803</i>&nbsp;     * represents the bottom of the stack, which is the first method invocation
<i>804</i>&nbsp;     * in the sequence.
<i>805</i>&nbsp;     *
<i>806</i>&nbsp;     * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
<i>807</i>&nbsp;     * or more stack frames from the stack trace.  In the extreme case,
<i>808</i>&nbsp;     * a virtual machine that has no stack trace information concerning
<i>809</i>&nbsp;     * this throwable is permitted to return a zero-length array from this
<i>810</i>&nbsp;     * method.  Generally speaking, the array returned by this method will
<i>811</i>&nbsp;     * contain one element for every frame that would be printed by
<i>812</i>&nbsp;     * {@code printStackTrace}.  Writes to the returned array do not
<i>813</i>&nbsp;     * affect future calls to this method.
<i>814</i>&nbsp;     *
<i>815</i>&nbsp;     * @return an array of stack trace elements representing the stack trace
<b class="nc"><i>816</i>&nbsp;     *         pertaining to this throwable.</b>
<i>817</i>&nbsp;     * @since  1.4
<i>818</i>&nbsp;     */
<i>819</i>&nbsp;    public StackTraceElement[] getStackTrace() {
<i>820</i>&nbsp;        return getOurStackTrace().clone();
<i>821</i>&nbsp;    }
<b class="nc"><i>822</i>&nbsp;</b>
<i>823</i>&nbsp;    private synchronized StackTraceElement[] getOurStackTrace() {
<b class="nc"><i>824</i>&nbsp;        // Initialize stack trace field with information from</b>
<b class="nc"><i>825</i>&nbsp;        // backtrace if this is the first call to this method</b>
<b class="nc"><i>826</i>&nbsp;        if (stackTrace == UNASSIGNED_STACK ||</b>
<b class="nc"><i>827</i>&nbsp;            (stackTrace == null &amp;&amp; backtrace != null) /* Out of protocol state */) {</b>
<b class="nc"><i>828</i>&nbsp;            stackTrace = StackTraceElement.of(this, depth);</b>
<b class="nc"><i>829</i>&nbsp;        } else if (stackTrace == null) {</b>
<i>830</i>&nbsp;            return UNASSIGNED_STACK;
<b class="nc"><i>831</i>&nbsp;        }</b>
<i>832</i>&nbsp;        return stackTrace;
<i>833</i>&nbsp;    }
<i>834</i>&nbsp;
<i>835</i>&nbsp;    /**
<i>836</i>&nbsp;     * Sets the stack trace elements that will be returned by
<i>837</i>&nbsp;     * {@link #getStackTrace()} and printed by {@link #printStackTrace()}
<i>838</i>&nbsp;     * and related methods.
<i>839</i>&nbsp;     *
<i>840</i>&nbsp;     * This method, which is designed for use by RPC frameworks and other
<i>841</i>&nbsp;     * advanced systems, allows the client to override the default
<i>842</i>&nbsp;     * stack trace that is either generated by {@link #fillInStackTrace()}
<i>843</i>&nbsp;     * when a throwable is constructed or deserialized when a throwable is
<i>844</i>&nbsp;     * read from a serialization stream.
<i>845</i>&nbsp;     *
<i>846</i>&nbsp;     * &lt;p&gt;If the stack trace of this {@code Throwable} {@linkplain
<i>847</i>&nbsp;     * Throwable#Throwable(String, Throwable, boolean, boolean) is not
<i>848</i>&nbsp;     * writable}, calling this method has no effect other than
<i>849</i>&nbsp;     * validating its argument.
<i>850</i>&nbsp;     *
<i>851</i>&nbsp;     * @param   stackTrace the stack trace elements to be associated with
<i>852</i>&nbsp;     * this {@code Throwable}.  The specified array is copied by this
<i>853</i>&nbsp;     * call; changes in the specified array after the method invocation
<i>854</i>&nbsp;     * returns will have no affect on this {@code Throwable}&#39;s stack
<i>855</i>&nbsp;     * trace.
<i>856</i>&nbsp;     *
<i>857</i>&nbsp;     * @throws NullPointerException if {@code stackTrace} is
<i>858</i>&nbsp;     *         {@code null} or if any of the elements of
<i>859</i>&nbsp;     *         {@code stackTrace} are {@code null}
<i>860</i>&nbsp;     *
<i>861</i>&nbsp;     * @since  1.4
<i>862</i>&nbsp;     */
<i>863</i>&nbsp;    public void setStackTrace(StackTraceElement[] stackTrace) {
<b class="nc"><i>864</i>&nbsp;        // Validate argument</b>
<b class="nc"><i>865</i>&nbsp;        StackTraceElement[] defensiveCopy = stackTrace.clone();</b>
<b class="nc"><i>866</i>&nbsp;        for (int i = 0; i &lt; defensiveCopy.length; i++) {</b>
<b class="nc"><i>867</i>&nbsp;            if (defensiveCopy[i] == null)</b>
<i>868</i>&nbsp;                throw new NullPointerException(&quot;stackTrace[&quot; + i + &quot;]&quot;);
<i>869</i>&nbsp;        }
<b class="nc"><i>870</i>&nbsp;</b>
<b class="nc"><i>871</i>&nbsp;        synchronized (this) {</b>
<i>872</i>&nbsp;            if (this.stackTrace == null &amp;&amp; // Immutable stack
<b class="nc"><i>873</i>&nbsp;                backtrace == null) // Test for out of protocol state</b>
<b class="nc"><i>874</i>&nbsp;                return;</b>
<b class="nc"><i>875</i>&nbsp;            this.stackTrace = defensiveCopy;</b>
<i>876</i>&nbsp;        }
<i>877</i>&nbsp;    }
<i>878</i>&nbsp;
<i>879</i>&nbsp;    /**
<i>880</i>&nbsp;     * Reads a {@code Throwable} from a stream, enforcing
<i>881</i>&nbsp;     * well-formedness constraints on fields.  Null entries and
<i>882</i>&nbsp;     * self-pointers are not allowed in the list of {@code
<i>883</i>&nbsp;     * suppressedExceptions}.  Null entries are not allowed for stack
<i>884</i>&nbsp;     * trace elements.  A null stack trace in the serial form results
<i>885</i>&nbsp;     * in a zero-length stack element array. A single-element stack
<i>886</i>&nbsp;     * trace whose entry is equal to {@code new StackTraceElement(&quot;&quot;,
<i>887</i>&nbsp;     * &quot;&quot;, null, Integer.MIN_VALUE)} results in a {@code null} {@code
<i>888</i>&nbsp;     * stackTrace} field.
<i>889</i>&nbsp;     *
<i>890</i>&nbsp;     * Note that there are no constraints on the value the {@code
<i>891</i>&nbsp;     * cause} field can hold; both {@code null} and {@code this} are
<i>892</i>&nbsp;     * valid values for the field.
<i>893</i>&nbsp;     */
<i>894</i>&nbsp;    private void readObject(ObjectInputStream s)
<i>895</i>&nbsp;        throws IOException, ClassNotFoundException {
<i>896</i>&nbsp;        s.defaultReadObject();     // read in all fields
<i>897</i>&nbsp;        if (suppressedExceptions != null) {
<i>898</i>&nbsp;            List&lt;Throwable&gt; suppressed = null;
<i>899</i>&nbsp;            if (suppressedExceptions.isEmpty()) {
<i>900</i>&nbsp;                // Use the sentinel for a zero-length list
<i>901</i>&nbsp;                suppressed = SUPPRESSED_SENTINEL;
<i>902</i>&nbsp;            } else { // Copy Throwables to new list
<i>903</i>&nbsp;                suppressed = new ArrayList&lt;&gt;(1);
<i>904</i>&nbsp;                for (Throwable t : suppressedExceptions) {
<i>905</i>&nbsp;                    // Enforce constraints on suppressed exceptions in
<i>906</i>&nbsp;                    // case of corrupt or malicious stream.
<i>907</i>&nbsp;                    if (t == null)
<i>908</i>&nbsp;                        throw new NullPointerException(NULL_CAUSE_MESSAGE);
<i>909</i>&nbsp;                    if (t == this)
<i>910</i>&nbsp;                        throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE);
<i>911</i>&nbsp;                    suppressed.add(t);
<i>912</i>&nbsp;                }
<i>913</i>&nbsp;            }
<b class="nc"><i>914</i>&nbsp;            suppressedExceptions = suppressed;</b>
<b class="nc"><i>915</i>&nbsp;        } // else a null suppressedExceptions field remains null</b>
<b class="nc"><i>916</i>&nbsp;</b>
<b class="nc"><i>917</i>&nbsp;        /*</b>
<i>918</i>&nbsp;         * For zero-length stack traces, use a clone of
<b class="nc"><i>919</i>&nbsp;         * UNASSIGNED_STACK rather than UNASSIGNED_STACK itself to</b>
<i>920</i>&nbsp;         * allow identity comparison against UNASSIGNED_STACK in
<b class="nc"><i>921</i>&nbsp;         * getOurStackTrace.  The identity of UNASSIGNED_STACK in</b>
<b class="nc"><i>922</i>&nbsp;         * stackTrace indicates to the getOurStackTrace method that</b>
<i>923</i>&nbsp;         * the stackTrace needs to be constructed from the information
<i>924</i>&nbsp;         * in backtrace.
<b class="nc"><i>925</i>&nbsp;         */</b>
<b class="nc"><i>926</i>&nbsp;        if (stackTrace != null) {</b>
<b class="nc"><i>927</i>&nbsp;            if (stackTrace.length == 0) {</b>
<b class="nc"><i>928</i>&nbsp;                stackTrace = UNASSIGNED_STACK.clone();</b>
<b class="nc"><i>929</i>&nbsp;            }  else if (stackTrace.length == 1 &amp;&amp;</b>
<b class="nc"><i>930</i>&nbsp;                        // Check for the marker of an immutable stack trace</b>
<i>931</i>&nbsp;                        SentinelHolder.STACK_TRACE_ELEMENT_SENTINEL.equals(stackTrace[0])) {
<b class="nc"><i>932</i>&nbsp;                stackTrace = null;</b>
<i>933</i>&nbsp;            } else { // Verify stack trace elements are non-null.
<i>934</i>&nbsp;                for(StackTraceElement ste : stackTrace) {
<i>935</i>&nbsp;                    if (ste == null)
<i>936</i>&nbsp;                        throw new NullPointerException(&quot;null StackTraceElement in serial stream. &quot;);
<i>937</i>&nbsp;                }
<i>938</i>&nbsp;            }
<i>939</i>&nbsp;        } else {
<i>940</i>&nbsp;            // A null stackTrace field in the serial form can result
<i>941</i>&nbsp;            // from an exception serialized without that field in
<i>942</i>&nbsp;            // older JDK releases; treat such exceptions as having
<i>943</i>&nbsp;            // empty stack traces.
<b class="nc"><i>944</i>&nbsp;            stackTrace = UNASSIGNED_STACK.clone();</b>
<b class="nc"><i>945</i>&nbsp;        }</b>
<b class="nc"><i>946</i>&nbsp;    }</b>
<b class="nc"><i>947</i>&nbsp;</b>
<i>948</i>&nbsp;    /**
<b class="nc"><i>949</i>&nbsp;     * Write a {@code Throwable} object to a stream.</b>
<b class="nc"><i>950</i>&nbsp;     *</b>
<i>951</i>&nbsp;     * A {@code null} stack trace field is represented in the serial
<b class="nc"><i>952</i>&nbsp;     * form as a one-element array whose element is equal to {@code</b>
<b class="nc"><i>953</i>&nbsp;     * new StackTraceElement(&quot;&quot;, &quot;&quot;, null, Integer.MIN_VALUE)}.</b>
<b class="nc"><i>954</i>&nbsp;     */</b>
<i>955</i>&nbsp;    private synchronized void writeObject(ObjectOutputStream s)
<i>956</i>&nbsp;        throws IOException {
<i>957</i>&nbsp;        // Ensure that the stackTrace field is initialized to a
<i>958</i>&nbsp;        // non-null value, if appropriate.  As of JDK 7, a null stack
<i>959</i>&nbsp;        // trace field is a valid value indicating the stack trace
<i>960</i>&nbsp;        // should not be set.
<i>961</i>&nbsp;        getOurStackTrace();
<b class="nc"><i>962</i>&nbsp;</b>
<i>963</i>&nbsp;        StackTraceElement[] oldStackTrace = stackTrace;
<i>964</i>&nbsp;        try {
<i>965</i>&nbsp;            if (stackTrace == null)
<i>966</i>&nbsp;                stackTrace = SentinelHolder.STACK_TRACE_SENTINEL;
<i>967</i>&nbsp;            s.defaultWriteObject();
<i>968</i>&nbsp;        } finally {
<i>969</i>&nbsp;            stackTrace = oldStackTrace;
<i>970</i>&nbsp;        }
<i>971</i>&nbsp;    }
<i>972</i>&nbsp;
<i>973</i>&nbsp;    /**
<i>974</i>&nbsp;     * Appends the specified exception to the exceptions that were
<i>975</i>&nbsp;     * suppressed in order to deliver this exception. This method is
<i>976</i>&nbsp;     * thread-safe and typically called (automatically and implicitly)
<i>977</i>&nbsp;     * by the {@code try}-with-resources statement.
<i>978</i>&nbsp;     *
<b class="nc"><i>979</i>&nbsp;     * &lt;p&gt;The suppression behavior is enabled &lt;em&gt;unless&lt;/em&gt; disabled</b>
<i>980</i>&nbsp;     * {@linkplain #Throwable(String, Throwable, boolean, boolean) via
<b class="nc"><i>981</i>&nbsp;     * a constructor}.  When suppression is disabled, this method does</b>
<i>982</i>&nbsp;     * nothing other than to validate its argument.
<b class="nc"><i>983</i>&nbsp;     *</b>
<b class="nc"><i>984</i>&nbsp;     * &lt;p&gt;Note that when one exception {@linkplain</b>
<b class="nc"><i>985</i>&nbsp;     * #initCause(Throwable) causes} another exception, the first</b>
<i>986</i>&nbsp;     * exception is usually caught and then the second exception is
<b class="nc"><i>987</i>&nbsp;     * thrown in response.  In other words, there is a causal</b>
<b class="nc"><i>988</i>&nbsp;     * connection between the two exceptions.</b>
<i>989</i>&nbsp;     *
<i>990</i>&nbsp;     * In contrast, there are situations where two independent
<i>991</i>&nbsp;     * exceptions can be thrown in sibling code blocks, in particular
<i>992</i>&nbsp;     * in the {@code try} block of a {@code try}-with-resources
<i>993</i>&nbsp;     * statement and the compiler-generated {@code finally} block
<i>994</i>&nbsp;     * which closes the resource.
<i>995</i>&nbsp;     *
<i>996</i>&nbsp;     * In these situations, only one of the thrown exceptions can be
<i>997</i>&nbsp;     * propagated.  In the {@code try}-with-resources statement, when
<i>998</i>&nbsp;     * there are two such exceptions, the exception originating from
<i>999</i>&nbsp;     * the {@code try} block is propagated and the exception from the
<i>1000</i>&nbsp;     * {@code finally} block is added to the list of exceptions
<i>1001</i>&nbsp;     * suppressed by the exception from the {@code try} block.  As an
<i>1002</i>&nbsp;     * exception unwinds the stack, it can accumulate multiple
<i>1003</i>&nbsp;     * suppressed exceptions.
<i>1004</i>&nbsp;     *
<i>1005</i>&nbsp;     * &lt;p&gt;An exception may have suppressed exceptions while also being
<i>1006</i>&nbsp;     * caused by another exception.  Whether or not an exception has a
<i>1007</i>&nbsp;     * cause is semantically known at the time of its creation, unlike
<i>1008</i>&nbsp;     * whether or not an exception will suppress other exceptions
<i>1009</i>&nbsp;     * which is typically only determined after an exception is
<i>1010</i>&nbsp;     * thrown.
<i>1011</i>&nbsp;     *
<i>1012</i>&nbsp;     * &lt;p&gt;Note that programmer written code is also able to take
<i>1013</i>&nbsp;     * advantage of calling this method in situations where there are
<i>1014</i>&nbsp;     * multiple sibling exceptions and only one can be propagated.
<i>1015</i>&nbsp;     *
<i>1016</i>&nbsp;     * @param exception the exception to be added to the list of
<i>1017</i>&nbsp;     *        suppressed exceptions
<i>1018</i>&nbsp;     * @throws IllegalArgumentException if {@code exception} is this
<i>1019</i>&nbsp;     *         throwable; a throwable cannot suppress itself.
<i>1020</i>&nbsp;     * @throws NullPointerException if {@code exception} is {@code null}
<i>1021</i>&nbsp;     * @since 1.7
<i>1022</i>&nbsp;     */
<i>1023</i>&nbsp;    public final synchronized void addSuppressed(Throwable exception) {
<i>1024</i>&nbsp;        if (exception == this)
<i>1025</i>&nbsp;            throw new IllegalArgumentException(SELF_SUPPRESSION_MESSAGE, exception);
<i>1026</i>&nbsp;
<i>1027</i>&nbsp;        if (exception == null)
<i>1028</i>&nbsp;            throw new NullPointerException(NULL_CAUSE_MESSAGE);
<i>1029</i>&nbsp;
<i>1030</i>&nbsp;        if (suppressedExceptions == null) // Suppressed exceptions not recorded
<i>1031</i>&nbsp;            return;
<i>1032</i>&nbsp;
<i>1033</i>&nbsp;        if (suppressedExceptions == SUPPRESSED_SENTINEL)
<i>1034</i>&nbsp;            suppressedExceptions = new ArrayList&lt;&gt;(1);
<i>1035</i>&nbsp;
<i>1036</i>&nbsp;        suppressedExceptions.add(exception);
<i>1037</i>&nbsp;    }
<i>1038</i>&nbsp;
<i>1039</i>&nbsp;    private static final Throwable[] EMPTY_THROWABLE_ARRAY = new Throwable[0];
<i>1040</i>&nbsp;
<i>1041</i>&nbsp;    /**
<b class="nc"><i>1042</i>&nbsp;     * Returns an array containing all of the exceptions that were</b>
<b class="nc"><i>1043</i>&nbsp;     * suppressed, typically by the {@code try}-with-resources</b>
<i>1044</i>&nbsp;     * statement, in order to deliver this exception.
<b class="nc"><i>1045</i>&nbsp;     *</b>
<b class="nc"><i>1046</i>&nbsp;     * If no exceptions were suppressed or {@linkplain</b>
<i>1047</i>&nbsp;     * #Throwable(String, Throwable, boolean, boolean) suppression is
<b class="nc"><i>1048</i>&nbsp;     * disabled}, an empty array is returned.  This method is</b>
<i>1049</i>&nbsp;     * thread-safe.  Writes to the returned array do not affect future
<i>1050</i>&nbsp;     * calls to this method.
<b class="nc"><i>1051</i>&nbsp;     *</b>
<b class="nc"><i>1052</i>&nbsp;     * @return an array containing all of the exceptions that were</b>
<i>1053</i>&nbsp;     *         suppressed to deliver this exception.
<b class="nc"><i>1054</i>&nbsp;     * @since 1.7</b>
<i>1055</i>&nbsp;     */
<i>1056</i>&nbsp;    public final synchronized Throwable[] getSuppressed() {
<b class="nc"><i>1057</i>&nbsp;        if (suppressedExceptions == SUPPRESSED_SENTINEL ||</b>
<i>1058</i>&nbsp;            suppressedExceptions == null)
<i>1059</i>&nbsp;            return EMPTY_THROWABLE_ARRAY;
<i>1060</i>&nbsp;        else
<i>1061</i>&nbsp;            return suppressedExceptions.toArray(EMPTY_THROWABLE_ARRAY);
<i>1062</i>&nbsp;    }
<i>1063</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
