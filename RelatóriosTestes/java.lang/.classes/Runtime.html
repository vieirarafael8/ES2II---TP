


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Runtime</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.lang</a> ]
</div>

<h1>Coverage Summary for Class: Runtime (java.lang)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Runtime</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 58)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package java.lang;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.*;
<i>29</i>&nbsp;import java.math.BigInteger;
<i>30</i>&nbsp;import java.util.ArrayList;
<i>31</i>&nbsp;import java.util.regex.Matcher;
<i>32</i>&nbsp;import java.util.regex.Pattern;
<i>33</i>&nbsp;import java.util.stream.Collectors;
<i>34</i>&nbsp;import java.util.Collections;
<i>35</i>&nbsp;import java.util.List;
<i>36</i>&nbsp;import java.util.Optional;
<i>37</i>&nbsp;import java.util.StringTokenizer;
<i>38</i>&nbsp;
<i>39</i>&nbsp;import jdk.internal.misc.SharedSecrets;
<i>40</i>&nbsp;import jdk.internal.reflect.CallerSensitive;
<i>41</i>&nbsp;import jdk.internal.reflect.Reflection;
<i>42</i>&nbsp;
<i>43</i>&nbsp;/**
<i>44</i>&nbsp; * Every Java application has a single instance of class
<i>45</i>&nbsp; * {@code Runtime} that allows the application to interface with
<i>46</i>&nbsp; * the environment in which the application is running. The current
<b class="nc"><i>47</i>&nbsp; * runtime can be obtained from the {@code getRuntime} method.</b>
<i>48</i>&nbsp; * &lt;p&gt;
<i>49</i>&nbsp; * An application cannot create its own instance of this class.
<i>50</i>&nbsp; *
<i>51</i>&nbsp; * @author  unascribed
<i>52</i>&nbsp; * @see     java.lang.Runtime#getRuntime()
<i>53</i>&nbsp; * @since   1.0
<i>54</i>&nbsp; */
<i>55</i>&nbsp;
<i>56</i>&nbsp;public class Runtime {
<i>57</i>&nbsp;    private static final Runtime currentRuntime = new Runtime();
<b class="nc"><i>58</i>&nbsp;</b>
<i>59</i>&nbsp;    private static Version version;
<i>60</i>&nbsp;
<i>61</i>&nbsp;    /**
<b class="nc"><i>62</i>&nbsp;     * Returns the runtime object associated with the current Java application.</b>
<i>63</i>&nbsp;     * Most of the methods of class {@code Runtime} are instance
<i>64</i>&nbsp;     * methods and must be invoked with respect to the current runtime object.
<i>65</i>&nbsp;     *
<i>66</i>&nbsp;     * @return  the {@code Runtime} object associated with the current
<i>67</i>&nbsp;     *          Java application.
<i>68</i>&nbsp;     */
<i>69</i>&nbsp;    public static Runtime getRuntime() {
<i>70</i>&nbsp;        return currentRuntime;
<i>71</i>&nbsp;    }
<i>72</i>&nbsp;
<i>73</i>&nbsp;    /** Don&#39;t let anyone else instantiate this class */
<i>74</i>&nbsp;    private Runtime() {}
<i>75</i>&nbsp;
<i>76</i>&nbsp;    /**
<i>77</i>&nbsp;     * Terminates the currently running Java virtual machine by initiating its
<i>78</i>&nbsp;     * shutdown sequence.  This method never returns normally.  The argument
<i>79</i>&nbsp;     * serves as a status code; by convention, a nonzero status code indicates
<i>80</i>&nbsp;     * abnormal termination.
<i>81</i>&nbsp;     *
<i>82</i>&nbsp;     * &lt;p&gt; All registered {@linkplain #addShutdownHook shutdown hooks}, if any,
<i>83</i>&nbsp;     * are started in some unspecified order and allowed to run concurrently
<i>84</i>&nbsp;     * until they finish.  Once this is done the virtual machine
<i>85</i>&nbsp;     * {@linkplain #halt halts}.
<i>86</i>&nbsp;     *
<i>87</i>&nbsp;     * &lt;p&gt; If this method is invoked after all shutdown hooks have already
<i>88</i>&nbsp;     * been run and the status is nonzero then this method halts the
<i>89</i>&nbsp;     * virtual machine with the given status code. Otherwise, this method
<i>90</i>&nbsp;     * blocks indefinitely.
<i>91</i>&nbsp;     *
<i>92</i>&nbsp;     * &lt;p&gt; The {@link System#exit(int) System.exit} method is the
<i>93</i>&nbsp;     * conventional and convenient means of invoking this method.
<i>94</i>&nbsp;     *
<i>95</i>&nbsp;     * @param  status
<i>96</i>&nbsp;     *         Termination status.  By convention, a nonzero status code
<i>97</i>&nbsp;     *         indicates abnormal termination.
<i>98</i>&nbsp;     *
<i>99</i>&nbsp;     * @throws SecurityException
<i>100</i>&nbsp;     *         If a security manager is present and its
<i>101</i>&nbsp;     *         {@link SecurityManager#checkExit checkExit} method does not permit
<i>102</i>&nbsp;     *         exiting with the specified status
<i>103</i>&nbsp;     *
<i>104</i>&nbsp;     * @see java.lang.SecurityException
<b class="nc"><i>105</i>&nbsp;     * @see java.lang.SecurityManager#checkExit(int)</b>
<b class="nc"><i>106</i>&nbsp;     * @see #addShutdownHook</b>
<b class="nc"><i>107</i>&nbsp;     * @see #removeShutdownHook</b>
<i>108</i>&nbsp;     * @see #halt(int)
<b class="nc"><i>109</i>&nbsp;     */</b>
<i>110</i>&nbsp;    public void exit(int status) {
<i>111</i>&nbsp;        SecurityManager security = System.getSecurityManager();
<i>112</i>&nbsp;        if (security != null) {
<i>113</i>&nbsp;            security.checkExit(status);
<i>114</i>&nbsp;        }
<i>115</i>&nbsp;        Shutdown.exit(status);
<i>116</i>&nbsp;    }
<i>117</i>&nbsp;
<i>118</i>&nbsp;    /**
<i>119</i>&nbsp;     * Registers a new virtual-machine shutdown hook.
<i>120</i>&nbsp;     *
<i>121</i>&nbsp;     * &lt;p&gt; The Java virtual machine &lt;i&gt;shuts down&lt;/i&gt; in response to two kinds
<i>122</i>&nbsp;     * of events:
<i>123</i>&nbsp;     *
<i>124</i>&nbsp;     *   &lt;ul&gt;
<i>125</i>&nbsp;     *
<i>126</i>&nbsp;     *   &lt;li&gt; The program &lt;i&gt;exits&lt;/i&gt; normally, when the last non-daemon
<i>127</i>&nbsp;     *   thread exits or when the {@link #exit exit} (equivalently,
<i>128</i>&nbsp;     *   {@link System#exit(int) System.exit}) method is invoked, or
<i>129</i>&nbsp;     *
<i>130</i>&nbsp;     *   &lt;li&gt; The virtual machine is &lt;i&gt;terminated&lt;/i&gt; in response to a
<i>131</i>&nbsp;     *   user interrupt, such as typing {@code ^C}, or a system-wide event,
<i>132</i>&nbsp;     *   such as user logoff or system shutdown.
<i>133</i>&nbsp;     *
<i>134</i>&nbsp;     *   &lt;/ul&gt;
<i>135</i>&nbsp;     *
<i>136</i>&nbsp;     * &lt;p&gt; A &lt;i&gt;shutdown hook&lt;/i&gt; is simply an initialized but unstarted
<i>137</i>&nbsp;     * thread.  When the virtual machine begins its shutdown sequence it will
<i>138</i>&nbsp;     * start all registered shutdown hooks in some unspecified order and let
<i>139</i>&nbsp;     * them run concurrently.  When all the hooks have finished it will then
<i>140</i>&nbsp;     * halt. Note that daemon threads will continue to run during the shutdown
<i>141</i>&nbsp;     * sequence, as will non-daemon threads if shutdown was initiated by
<i>142</i>&nbsp;     * invoking the {@link #exit exit} method.
<i>143</i>&nbsp;     *
<i>144</i>&nbsp;     * &lt;p&gt; Once the shutdown sequence has begun it can be stopped only by
<i>145</i>&nbsp;     * invoking the {@link #halt halt} method, which forcibly
<i>146</i>&nbsp;     * terminates the virtual machine.
<i>147</i>&nbsp;     *
<i>148</i>&nbsp;     * &lt;p&gt; Once the shutdown sequence has begun it is impossible to register a
<i>149</i>&nbsp;     * new shutdown hook or de-register a previously-registered hook.
<i>150</i>&nbsp;     * Attempting either of these operations will cause an
<i>151</i>&nbsp;     * {@link IllegalStateException} to be thrown.
<i>152</i>&nbsp;     *
<i>153</i>&nbsp;     * &lt;p&gt; Shutdown hooks run at a delicate time in the life cycle of a virtual
<i>154</i>&nbsp;     * machine and should therefore be coded defensively.  They should, in
<i>155</i>&nbsp;     * particular, be written to be thread-safe and to avoid deadlocks insofar
<i>156</i>&nbsp;     * as possible.  They should also not rely blindly upon services that may
<i>157</i>&nbsp;     * have registered their own shutdown hooks and therefore may themselves in
<i>158</i>&nbsp;     * the process of shutting down.  Attempts to use other thread-based
<i>159</i>&nbsp;     * services such as the AWT event-dispatch thread, for example, may lead to
<i>160</i>&nbsp;     * deadlocks.
<i>161</i>&nbsp;     *
<i>162</i>&nbsp;     * &lt;p&gt; Shutdown hooks should also finish their work quickly.  When a
<i>163</i>&nbsp;     * program invokes {@link #exit exit} the expectation is
<i>164</i>&nbsp;     * that the virtual machine will promptly shut down and exit.  When the
<i>165</i>&nbsp;     * virtual machine is terminated due to user logoff or system shutdown the
<i>166</i>&nbsp;     * underlying operating system may only allow a fixed amount of time in
<i>167</i>&nbsp;     * which to shut down and exit.  It is therefore inadvisable to attempt any
<i>168</i>&nbsp;     * user interaction or to perform a long-running computation in a shutdown
<i>169</i>&nbsp;     * hook.
<i>170</i>&nbsp;     *
<i>171</i>&nbsp;     * &lt;p&gt; Uncaught exceptions are handled in shutdown hooks just as in any
<i>172</i>&nbsp;     * other thread, by invoking the
<i>173</i>&nbsp;     * {@link ThreadGroup#uncaughtException uncaughtException} method of the
<i>174</i>&nbsp;     * thread&#39;s {@link ThreadGroup} object. The default implementation of this
<i>175</i>&nbsp;     * method prints the exception&#39;s stack trace to {@link System#err} and
<i>176</i>&nbsp;     * terminates the thread; it does not cause the virtual machine to exit or
<i>177</i>&nbsp;     * halt.
<i>178</i>&nbsp;     *
<i>179</i>&nbsp;     * &lt;p&gt; In rare circumstances the virtual machine may &lt;i&gt;abort&lt;/i&gt;, that is,
<i>180</i>&nbsp;     * stop running without shutting down cleanly.  This occurs when the
<i>181</i>&nbsp;     * virtual machine is terminated externally, for example with the
<i>182</i>&nbsp;     * {@code SIGKILL} signal on Unix or the {@code TerminateProcess} call on
<i>183</i>&nbsp;     * Microsoft Windows.  The virtual machine may also abort if a native
<i>184</i>&nbsp;     * method goes awry by, for example, corrupting internal data structures or
<i>185</i>&nbsp;     * attempting to access nonexistent memory.  If the virtual machine aborts
<i>186</i>&nbsp;     * then no guarantee can be made about whether or not any shutdown hooks
<i>187</i>&nbsp;     * will be run.
<i>188</i>&nbsp;     *
<i>189</i>&nbsp;     * @param   hook
<i>190</i>&nbsp;     *          An initialized but unstarted {@link Thread} object
<i>191</i>&nbsp;     *
<i>192</i>&nbsp;     * @throws  IllegalArgumentException
<i>193</i>&nbsp;     *          If the specified hook has already been registered,
<i>194</i>&nbsp;     *          or if it can be determined that the hook is already running or
<i>195</i>&nbsp;     *          has already been run
<i>196</i>&nbsp;     *
<i>197</i>&nbsp;     * @throws  IllegalStateException
<i>198</i>&nbsp;     *          If the virtual machine is already in the process
<i>199</i>&nbsp;     *          of shutting down
<i>200</i>&nbsp;     *
<i>201</i>&nbsp;     * @throws  SecurityException
<i>202</i>&nbsp;     *          If a security manager is present and it denies
<i>203</i>&nbsp;     *          {@link RuntimePermission}(&quot;shutdownHooks&quot;)
<i>204</i>&nbsp;     *
<i>205</i>&nbsp;     * @see #removeShutdownHook
<i>206</i>&nbsp;     * @see #halt(int)
<b class="nc"><i>207</i>&nbsp;     * @see #exit(int)</b>
<b class="nc"><i>208</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>209</i>&nbsp;     */</b>
<i>210</i>&nbsp;    public void addShutdownHook(Thread hook) {
<b class="nc"><i>211</i>&nbsp;        SecurityManager sm = System.getSecurityManager();</b>
<i>212</i>&nbsp;        if (sm != null) {
<i>213</i>&nbsp;            sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));
<i>214</i>&nbsp;        }
<i>215</i>&nbsp;        ApplicationShutdownHooks.add(hook);
<i>216</i>&nbsp;    }
<i>217</i>&nbsp;
<i>218</i>&nbsp;    /**
<i>219</i>&nbsp;     * De-registers a previously-registered virtual-machine shutdown hook.
<i>220</i>&nbsp;     *
<i>221</i>&nbsp;     * @param hook the hook to remove
<i>222</i>&nbsp;     * @return {@code true} if the specified hook had previously been
<i>223</i>&nbsp;     * registered and was successfully de-registered, {@code false}
<i>224</i>&nbsp;     * otherwise.
<i>225</i>&nbsp;     *
<i>226</i>&nbsp;     * @throws  IllegalStateException
<i>227</i>&nbsp;     *          If the virtual machine is already in the process of shutting
<i>228</i>&nbsp;     *          down
<i>229</i>&nbsp;     *
<i>230</i>&nbsp;     * @throws  SecurityException
<i>231</i>&nbsp;     *          If a security manager is present and it denies
<i>232</i>&nbsp;     *          {@link RuntimePermission}(&quot;shutdownHooks&quot;)
<i>233</i>&nbsp;     *
<i>234</i>&nbsp;     * @see #addShutdownHook
<b class="nc"><i>235</i>&nbsp;     * @see #exit(int)</b>
<b class="nc"><i>236</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>237</i>&nbsp;     */</b>
<i>238</i>&nbsp;    public boolean removeShutdownHook(Thread hook) {
<b class="nc"><i>239</i>&nbsp;        SecurityManager sm = System.getSecurityManager();</b>
<i>240</i>&nbsp;        if (sm != null) {
<i>241</i>&nbsp;            sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));
<i>242</i>&nbsp;        }
<i>243</i>&nbsp;        return ApplicationShutdownHooks.remove(hook);
<i>244</i>&nbsp;    }
<i>245</i>&nbsp;
<i>246</i>&nbsp;    /**
<i>247</i>&nbsp;     * Forcibly terminates the currently running Java virtual machine.  This
<i>248</i>&nbsp;     * method never returns normally.
<i>249</i>&nbsp;     *
<i>250</i>&nbsp;     * &lt;p&gt; This method should be used with extreme caution.  Unlike the
<i>251</i>&nbsp;     * {@link #exit exit} method, this method does not cause shutdown
<i>252</i>&nbsp;     * hooks to be started.  If the shutdown sequence has already been
<i>253</i>&nbsp;     * initiated then this method does not wait for any running
<i>254</i>&nbsp;     * shutdown hooks to finish their work.
<i>255</i>&nbsp;     *
<i>256</i>&nbsp;     * @param  status
<i>257</i>&nbsp;     *         Termination status. By convention, a nonzero status code
<i>258</i>&nbsp;     *         indicates abnormal termination. If the {@link Runtime#exit exit}
<i>259</i>&nbsp;     *         (equivalently, {@link System#exit(int) System.exit}) method
<i>260</i>&nbsp;     *         has already been invoked then this status code
<i>261</i>&nbsp;     *         will override the status code passed to that method.
<i>262</i>&nbsp;     *
<i>263</i>&nbsp;     * @throws SecurityException
<i>264</i>&nbsp;     *         If a security manager is present and its
<i>265</i>&nbsp;     *         {@link SecurityManager#checkExit checkExit} method
<i>266</i>&nbsp;     *         does not permit an exit with the specified status
<i>267</i>&nbsp;     *
<i>268</i>&nbsp;     * @see #exit
<i>269</i>&nbsp;     * @see #addShutdownHook
<i>270</i>&nbsp;     * @see #removeShutdownHook
<b class="nc"><i>271</i>&nbsp;     * @since 1.3</b>
<b class="nc"><i>272</i>&nbsp;     */</b>
<b class="nc"><i>273</i>&nbsp;    public void halt(int status) {</b>
<i>274</i>&nbsp;        SecurityManager sm = System.getSecurityManager();
<b class="nc"><i>275</i>&nbsp;        if (sm != null) {</b>
<i>276</i>&nbsp;            sm.checkExit(status);
<i>277</i>&nbsp;        }
<i>278</i>&nbsp;        Shutdown.beforeHalt();
<i>279</i>&nbsp;        Shutdown.halt(status);
<i>280</i>&nbsp;    }
<i>281</i>&nbsp;
<i>282</i>&nbsp;    /**
<i>283</i>&nbsp;     * Executes the specified string command in a separate process.
<i>284</i>&nbsp;     *
<i>285</i>&nbsp;     * &lt;p&gt;This is a convenience method.  An invocation of the form
<i>286</i>&nbsp;     * {@code exec(command)}
<i>287</i>&nbsp;     * behaves in exactly the same way as the invocation
<i>288</i>&nbsp;     * {@link #exec(String, String[], File) exec}{@code (command, null, null)}.
<i>289</i>&nbsp;     *
<i>290</i>&nbsp;     * @param   command   a specified system command.
<i>291</i>&nbsp;     *
<i>292</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>293</i>&nbsp;     *
<i>294</i>&nbsp;     * @throws  SecurityException
<i>295</i>&nbsp;     *          If a security manager exists and its
<i>296</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>297</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>298</i>&nbsp;     *
<i>299</i>&nbsp;     * @throws  IOException
<i>300</i>&nbsp;     *          If an I/O error occurs
<i>301</i>&nbsp;     *
<i>302</i>&nbsp;     * @throws  NullPointerException
<i>303</i>&nbsp;     *          If {@code command} is {@code null}
<i>304</i>&nbsp;     *
<i>305</i>&nbsp;     * @throws  IllegalArgumentException
<b class="nc"><i>306</i>&nbsp;     *          If {@code command} is empty</b>
<b class="nc"><i>307</i>&nbsp;     *</b>
<i>308</i>&nbsp;     * @see     #exec(String[], String[], File)
<b class="nc"><i>309</i>&nbsp;     * @see     ProcessBuilder</b>
<b class="nc"><i>310</i>&nbsp;     */</b>
<b class="nc"><i>311</i>&nbsp;    public Process exec(String command) throws IOException {</b>
<b class="nc"><i>312</i>&nbsp;        return exec(command, null, null);</b>
<i>313</i>&nbsp;    }
<b class="nc"><i>314</i>&nbsp;</b>
<i>315</i>&nbsp;    /**
<i>316</i>&nbsp;     * Executes the specified string command in a separate process with the
<i>317</i>&nbsp;     * specified environment.
<i>318</i>&nbsp;     *
<i>319</i>&nbsp;     * &lt;p&gt;This is a convenience method.  An invocation of the form
<i>320</i>&nbsp;     * {@code exec(command, envp)}
<i>321</i>&nbsp;     * behaves in exactly the same way as the invocation
<i>322</i>&nbsp;     * {@link #exec(String, String[], File) exec}{@code (command, envp, null)}.
<i>323</i>&nbsp;     *
<i>324</i>&nbsp;     * @param   command   a specified system command.
<i>325</i>&nbsp;     *
<i>326</i>&nbsp;     * @param   envp      array of strings, each element of which
<i>327</i>&nbsp;     *                    has environment variable settings in the format
<i>328</i>&nbsp;     *                    &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or
<i>329</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>330</i>&nbsp;     *                    the environment of the current process.
<i>331</i>&nbsp;     *
<i>332</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>333</i>&nbsp;     *
<i>334</i>&nbsp;     * @throws  SecurityException
<i>335</i>&nbsp;     *          If a security manager exists and its
<i>336</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>337</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>338</i>&nbsp;     *
<i>339</i>&nbsp;     * @throws  IOException
<i>340</i>&nbsp;     *          If an I/O error occurs
<i>341</i>&nbsp;     *
<i>342</i>&nbsp;     * @throws  NullPointerException
<i>343</i>&nbsp;     *          If {@code command} is {@code null},
<i>344</i>&nbsp;     *          or one of the elements of {@code envp} is {@code null}
<i>345</i>&nbsp;     *
<i>346</i>&nbsp;     * @throws  IllegalArgumentException
<b class="nc"><i>347</i>&nbsp;     *          If {@code command} is empty</b>
<i>348</i>&nbsp;     *
<i>349</i>&nbsp;     * @see     #exec(String[], String[], File)
<i>350</i>&nbsp;     * @see     ProcessBuilder
<i>351</i>&nbsp;     */
<i>352</i>&nbsp;    public Process exec(String command, String[] envp) throws IOException {
<i>353</i>&nbsp;        return exec(command, envp, null);
<i>354</i>&nbsp;    }
<i>355</i>&nbsp;
<i>356</i>&nbsp;    /**
<i>357</i>&nbsp;     * Executes the specified string command in a separate process with the
<i>358</i>&nbsp;     * specified environment and working directory.
<i>359</i>&nbsp;     *
<i>360</i>&nbsp;     * &lt;p&gt;This is a convenience method.  An invocation of the form
<i>361</i>&nbsp;     * {@code exec(command, envp, dir)}
<i>362</i>&nbsp;     * behaves in exactly the same way as the invocation
<i>363</i>&nbsp;     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, envp, dir)},
<i>364</i>&nbsp;     * where {@code cmdarray} is an array of all the tokens in
<i>365</i>&nbsp;     * {@code command}.
<i>366</i>&nbsp;     *
<i>367</i>&nbsp;     * &lt;p&gt;More precisely, the {@code command} string is broken
<i>368</i>&nbsp;     * into tokens using a {@link StringTokenizer} created by the call
<i>369</i>&nbsp;     * {@code new {@link StringTokenizer}(command)} with no
<i>370</i>&nbsp;     * further modification of the character categories.  The tokens
<i>371</i>&nbsp;     * produced by the tokenizer are then placed in the new string
<i>372</i>&nbsp;     * array {@code cmdarray}, in the same order.
<i>373</i>&nbsp;     *
<i>374</i>&nbsp;     * @param   command   a specified system command.
<i>375</i>&nbsp;     *
<i>376</i>&nbsp;     * @param   envp      array of strings, each element of which
<i>377</i>&nbsp;     *                    has environment variable settings in the format
<i>378</i>&nbsp;     *                    &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or
<i>379</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>380</i>&nbsp;     *                    the environment of the current process.
<i>381</i>&nbsp;     *
<i>382</i>&nbsp;     * @param   dir       the working directory of the subprocess, or
<i>383</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>384</i>&nbsp;     *                    the working directory of the current process.
<i>385</i>&nbsp;     *
<i>386</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>387</i>&nbsp;     *
<b class="nc"><i>388</i>&nbsp;     * @throws  SecurityException</b>
<i>389</i>&nbsp;     *          If a security manager exists and its
<i>390</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>391</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>392</i>&nbsp;     *
<i>393</i>&nbsp;     * @throws  IOException
<i>394</i>&nbsp;     *          If an I/O error occurs
<i>395</i>&nbsp;     *
<i>396</i>&nbsp;     * @throws  NullPointerException
<i>397</i>&nbsp;     *          If {@code command} is {@code null},
<i>398</i>&nbsp;     *          or one of the elements of {@code envp} is {@code null}
<i>399</i>&nbsp;     *
<i>400</i>&nbsp;     * @throws  IllegalArgumentException
<i>401</i>&nbsp;     *          If {@code command} is empty
<i>402</i>&nbsp;     *
<i>403</i>&nbsp;     * @see     ProcessBuilder
<i>404</i>&nbsp;     * @since 1.3
<i>405</i>&nbsp;     */
<i>406</i>&nbsp;    public Process exec(String command, String[] envp, File dir)
<i>407</i>&nbsp;        throws IOException {
<i>408</i>&nbsp;        if (command.length() == 0)
<i>409</i>&nbsp;            throw new IllegalArgumentException(&quot;Empty command&quot;);
<i>410</i>&nbsp;
<i>411</i>&nbsp;        StringTokenizer st = new StringTokenizer(command);
<i>412</i>&nbsp;        String[] cmdarray = new String[st.countTokens()];
<i>413</i>&nbsp;        for (int i = 0; st.hasMoreTokens(); i++)
<i>414</i>&nbsp;            cmdarray[i] = st.nextToken();
<i>415</i>&nbsp;        return exec(cmdarray, envp, dir);
<i>416</i>&nbsp;    }
<i>417</i>&nbsp;
<i>418</i>&nbsp;    /**
<i>419</i>&nbsp;     * Executes the specified command and arguments in a separate process.
<i>420</i>&nbsp;     *
<i>421</i>&nbsp;     * &lt;p&gt;This is a convenience method.  An invocation of the form
<i>422</i>&nbsp;     * {@code exec(cmdarray)}
<i>423</i>&nbsp;     * behaves in exactly the same way as the invocation
<i>424</i>&nbsp;     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, null, null)}.
<i>425</i>&nbsp;     *
<i>426</i>&nbsp;     * @param   cmdarray  array containing the command to call and
<i>427</i>&nbsp;     *                    its arguments.
<i>428</i>&nbsp;     *
<i>429</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>430</i>&nbsp;     *
<i>431</i>&nbsp;     * @throws  SecurityException
<i>432</i>&nbsp;     *          If a security manager exists and its
<i>433</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>434</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>435</i>&nbsp;     *
<i>436</i>&nbsp;     * @throws  IOException
<i>437</i>&nbsp;     *          If an I/O error occurs
<i>438</i>&nbsp;     *
<i>439</i>&nbsp;     * @throws  NullPointerException
<i>440</i>&nbsp;     *          If {@code cmdarray} is {@code null},
<i>441</i>&nbsp;     *          or one of the elements of {@code cmdarray} is {@code null}
<i>442</i>&nbsp;     *
<b class="nc"><i>443</i>&nbsp;     * @throws  IndexOutOfBoundsException</b>
<b class="nc"><i>444</i>&nbsp;     *          If {@code cmdarray} is an empty array</b>
<i>445</i>&nbsp;     *          (has length {@code 0})
<b class="nc"><i>446</i>&nbsp;     *</b>
<b class="nc"><i>447</i>&nbsp;     * @see     ProcessBuilder</b>
<b class="nc"><i>448</i>&nbsp;     */</b>
<b class="nc"><i>449</i>&nbsp;    public Process exec(String cmdarray[]) throws IOException {</b>
<b class="nc"><i>450</i>&nbsp;        return exec(cmdarray, null, null);</b>
<i>451</i>&nbsp;    }
<i>452</i>&nbsp;
<i>453</i>&nbsp;    /**
<i>454</i>&nbsp;     * Executes the specified command and arguments in a separate process
<i>455</i>&nbsp;     * with the specified environment.
<i>456</i>&nbsp;     *
<i>457</i>&nbsp;     * &lt;p&gt;This is a convenience method.  An invocation of the form
<i>458</i>&nbsp;     * {@code exec(cmdarray, envp)}
<i>459</i>&nbsp;     * behaves in exactly the same way as the invocation
<i>460</i>&nbsp;     * {@link #exec(String[], String[], File) exec}{@code (cmdarray, envp, null)}.
<i>461</i>&nbsp;     *
<i>462</i>&nbsp;     * @param   cmdarray  array containing the command to call and
<i>463</i>&nbsp;     *                    its arguments.
<i>464</i>&nbsp;     *
<i>465</i>&nbsp;     * @param   envp      array of strings, each element of which
<i>466</i>&nbsp;     *                    has environment variable settings in the format
<i>467</i>&nbsp;     *                    &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or
<i>468</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>469</i>&nbsp;     *                    the environment of the current process.
<i>470</i>&nbsp;     *
<i>471</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>472</i>&nbsp;     *
<i>473</i>&nbsp;     * @throws  SecurityException
<i>474</i>&nbsp;     *          If a security manager exists and its
<i>475</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>476</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>477</i>&nbsp;     *
<i>478</i>&nbsp;     * @throws  IOException
<i>479</i>&nbsp;     *          If an I/O error occurs
<i>480</i>&nbsp;     *
<i>481</i>&nbsp;     * @throws  NullPointerException
<i>482</i>&nbsp;     *          If {@code cmdarray} is {@code null},
<i>483</i>&nbsp;     *          or one of the elements of {@code cmdarray} is {@code null},
<i>484</i>&nbsp;     *          or one of the elements of {@code envp} is {@code null}
<b class="nc"><i>485</i>&nbsp;     *</b>
<i>486</i>&nbsp;     * @throws  IndexOutOfBoundsException
<i>487</i>&nbsp;     *          If {@code cmdarray} is an empty array
<i>488</i>&nbsp;     *          (has length {@code 0})
<i>489</i>&nbsp;     *
<i>490</i>&nbsp;     * @see     ProcessBuilder
<i>491</i>&nbsp;     */
<i>492</i>&nbsp;    public Process exec(String[] cmdarray, String[] envp) throws IOException {
<i>493</i>&nbsp;        return exec(cmdarray, envp, null);
<i>494</i>&nbsp;    }
<i>495</i>&nbsp;
<i>496</i>&nbsp;
<i>497</i>&nbsp;    /**
<i>498</i>&nbsp;     * Executes the specified command and arguments in a separate process with
<i>499</i>&nbsp;     * the specified environment and working directory.
<i>500</i>&nbsp;     *
<i>501</i>&nbsp;     * &lt;p&gt;Given an array of strings {@code cmdarray}, representing the
<i>502</i>&nbsp;     * tokens of a command line, and an array of strings {@code envp},
<i>503</i>&nbsp;     * representing &quot;environment&quot; variable settings, this method creates
<i>504</i>&nbsp;     * a new process in which to execute the specified command.
<i>505</i>&nbsp;     *
<i>506</i>&nbsp;     * &lt;p&gt;This method checks that {@code cmdarray} is a valid operating
<i>507</i>&nbsp;     * system command.  Which commands are valid is system-dependent,
<i>508</i>&nbsp;     * but at the very least the command must be a non-empty list of
<i>509</i>&nbsp;     * non-null strings.
<i>510</i>&nbsp;     *
<i>511</i>&nbsp;     * &lt;p&gt;If {@code envp} is {@code null}, the subprocess inherits the
<i>512</i>&nbsp;     * environment settings of the current process.
<i>513</i>&nbsp;     *
<i>514</i>&nbsp;     * &lt;p&gt;A minimal set of system dependent environment variables may
<i>515</i>&nbsp;     * be required to start a process on some operating systems.
<i>516</i>&nbsp;     * As a result, the subprocess may inherit additional environment variable
<i>517</i>&nbsp;     * settings beyond those in the specified environment.
<i>518</i>&nbsp;     *
<i>519</i>&nbsp;     * &lt;p&gt;{@link ProcessBuilder#start()} is now the preferred way to
<i>520</i>&nbsp;     * start a process with a modified environment.
<i>521</i>&nbsp;     *
<i>522</i>&nbsp;     * &lt;p&gt;The working directory of the new subprocess is specified by {@code dir}.
<i>523</i>&nbsp;     * If {@code dir} is {@code null}, the subprocess inherits the
<i>524</i>&nbsp;     * current working directory of the current process.
<i>525</i>&nbsp;     *
<i>526</i>&nbsp;     * &lt;p&gt;If a security manager exists, its
<i>527</i>&nbsp;     * {@link SecurityManager#checkExec checkExec}
<b class="nc"><i>528</i>&nbsp;     * method is invoked with the first component of the array</b>
<i>529</i>&nbsp;     * {@code cmdarray} as its argument. This may result in a
<i>530</i>&nbsp;     * {@link SecurityException} being thrown.
<i>531</i>&nbsp;     *
<i>532</i>&nbsp;     * &lt;p&gt;Starting an operating system process is highly system-dependent.
<i>533</i>&nbsp;     * Among the many things that can go wrong are:
<i>534</i>&nbsp;     * &lt;ul&gt;
<i>535</i>&nbsp;     * &lt;li&gt;The operating system program file was not found.
<i>536</i>&nbsp;     * &lt;li&gt;Access to the program file was denied.
<i>537</i>&nbsp;     * &lt;li&gt;The working directory does not exist.
<i>538</i>&nbsp;     * &lt;/ul&gt;
<i>539</i>&nbsp;     *
<i>540</i>&nbsp;     * &lt;p&gt;In such cases an exception will be thrown.  The exact nature
<i>541</i>&nbsp;     * of the exception is system-dependent, but it will always be a
<i>542</i>&nbsp;     * subclass of {@link IOException}.
<i>543</i>&nbsp;     *
<i>544</i>&nbsp;     * &lt;p&gt;If the operating system does not support the creation of
<i>545</i>&nbsp;     * processes, an {@link UnsupportedOperationException} will be thrown.
<i>546</i>&nbsp;     *
<i>547</i>&nbsp;     *
<i>548</i>&nbsp;     * @param   cmdarray  array containing the command to call and
<i>549</i>&nbsp;     *                    its arguments.
<i>550</i>&nbsp;     *
<i>551</i>&nbsp;     * @param   envp      array of strings, each element of which
<i>552</i>&nbsp;     *                    has environment variable settings in the format
<i>553</i>&nbsp;     *                    &lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;, or
<i>554</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>555</i>&nbsp;     *                    the environment of the current process.
<i>556</i>&nbsp;     *
<i>557</i>&nbsp;     * @param   dir       the working directory of the subprocess, or
<i>558</i>&nbsp;     *                    {@code null} if the subprocess should inherit
<i>559</i>&nbsp;     *                    the working directory of the current process.
<i>560</i>&nbsp;     *
<i>561</i>&nbsp;     * @return  A new {@link Process} object for managing the subprocess
<i>562</i>&nbsp;     *
<i>563</i>&nbsp;     * @throws  SecurityException
<i>564</i>&nbsp;     *          If a security manager exists and its
<i>565</i>&nbsp;     *          {@link SecurityManager#checkExec checkExec}
<i>566</i>&nbsp;     *          method doesn&#39;t allow creation of the subprocess
<i>567</i>&nbsp;     *
<i>568</i>&nbsp;     * @throws  UnsupportedOperationException
<i>569</i>&nbsp;     *          If the operating system does not support the creation of processes.
<i>570</i>&nbsp;     *
<i>571</i>&nbsp;     * @throws  IOException
<i>572</i>&nbsp;     *          If an I/O error occurs
<i>573</i>&nbsp;     *
<i>574</i>&nbsp;     * @throws  NullPointerException
<i>575</i>&nbsp;     *          If {@code cmdarray} is {@code null},
<i>576</i>&nbsp;     *          or one of the elements of {@code cmdarray} is {@code null},
<i>577</i>&nbsp;     *          or one of the elements of {@code envp} is {@code null}
<i>578</i>&nbsp;     *
<i>579</i>&nbsp;     * @throws  IndexOutOfBoundsException
<i>580</i>&nbsp;     *          If {@code cmdarray} is an empty array
<i>581</i>&nbsp;     *          (has length {@code 0})
<i>582</i>&nbsp;     *
<i>583</i>&nbsp;     * @see     ProcessBuilder
<i>584</i>&nbsp;     * @since 1.3
<i>585</i>&nbsp;     */
<i>586</i>&nbsp;    public Process exec(String[] cmdarray, String[] envp, File dir)
<i>587</i>&nbsp;        throws IOException {
<i>588</i>&nbsp;        return new ProcessBuilder(cmdarray)
<i>589</i>&nbsp;            .environment(envp)
<i>590</i>&nbsp;            .directory(dir)
<i>591</i>&nbsp;            .start();
<i>592</i>&nbsp;    }
<i>593</i>&nbsp;
<i>594</i>&nbsp;    /**
<i>595</i>&nbsp;     * Returns the number of processors available to the Java virtual machine.
<i>596</i>&nbsp;     *
<i>597</i>&nbsp;     * &lt;p&gt; This value may change during a particular invocation of the virtual
<i>598</i>&nbsp;     * machine.  Applications that are sensitive to the number of available
<i>599</i>&nbsp;     * processors should therefore occasionally poll this property and adjust
<i>600</i>&nbsp;     * their resource usage appropriately. &lt;/p&gt;
<i>601</i>&nbsp;     *
<i>602</i>&nbsp;     * @return  the maximum number of processors available to the virtual
<i>603</i>&nbsp;     *          machine; never smaller than one
<i>604</i>&nbsp;     * @since 1.4
<i>605</i>&nbsp;     */
<i>606</i>&nbsp;    public native int availableProcessors();
<i>607</i>&nbsp;
<i>608</i>&nbsp;    /**
<i>609</i>&nbsp;     * Returns the amount of free memory in the Java Virtual Machine.
<i>610</i>&nbsp;     * Calling the
<i>611</i>&nbsp;     * {@code gc} method may result in increasing the value returned
<i>612</i>&nbsp;     * by {@code freeMemory.}
<i>613</i>&nbsp;     *
<i>614</i>&nbsp;     * @return  an approximation to the total amount of memory currently
<i>615</i>&nbsp;     *          available for future allocated objects, measured in bytes.
<i>616</i>&nbsp;     */
<b class="nc"><i>617</i>&nbsp;    public native long freeMemory();</b>
<b class="nc"><i>618</i>&nbsp;</b>
<b class="nc"><i>619</i>&nbsp;    /**</b>
<b class="nc"><i>620</i>&nbsp;     * Returns the total amount of memory in the Java virtual machine.</b>
<i>621</i>&nbsp;     * The value returned by this method may vary over time, depending on
<i>622</i>&nbsp;     * the host environment.
<i>623</i>&nbsp;     * &lt;p&gt;
<i>624</i>&nbsp;     * Note that the amount of memory required to hold an object of any
<i>625</i>&nbsp;     * given type may be implementation-dependent.
<i>626</i>&nbsp;     *
<i>627</i>&nbsp;     * @return  the total amount of memory currently available for current
<i>628</i>&nbsp;     *          and future objects, measured in bytes.
<i>629</i>&nbsp;     */
<i>630</i>&nbsp;    public native long totalMemory();
<i>631</i>&nbsp;
<i>632</i>&nbsp;    /**
<i>633</i>&nbsp;     * Returns the maximum amount of memory that the Java virtual machine
<i>634</i>&nbsp;     * will attempt to use.  If there is no inherent limit then the value
<i>635</i>&nbsp;     * {@link java.lang.Long#MAX_VALUE} will be returned.
<i>636</i>&nbsp;     *
<i>637</i>&nbsp;     * @return  the maximum amount of memory that the virtual machine will
<i>638</i>&nbsp;     *          attempt to use, measured in bytes
<i>639</i>&nbsp;     * @since 1.4
<i>640</i>&nbsp;     */
<i>641</i>&nbsp;    public native long maxMemory();
<i>642</i>&nbsp;
<i>643</i>&nbsp;    /**
<i>644</i>&nbsp;     * Runs the garbage collector.
<i>645</i>&nbsp;     * Calling this method suggests that the Java virtual machine expend
<i>646</i>&nbsp;     * effort toward recycling unused objects in order to make the memory
<i>647</i>&nbsp;     * they currently occupy available for quick reuse. When control
<i>648</i>&nbsp;     * returns from the method call, the virtual machine has made
<i>649</i>&nbsp;     * its best effort to recycle all discarded objects.
<i>650</i>&nbsp;     * &lt;p&gt;
<i>651</i>&nbsp;     * The name {@code gc} stands for &quot;garbage
<i>652</i>&nbsp;     * collector&quot;. The virtual machine performs this recycling
<i>653</i>&nbsp;     * process automatically as needed, in a separate thread, even if the
<i>654</i>&nbsp;     * {@code gc} method is not invoked explicitly.
<i>655</i>&nbsp;     * &lt;p&gt;
<i>656</i>&nbsp;     * The method {@link System#gc()} is the conventional and convenient
<i>657</i>&nbsp;     * means of invoking this method.
<i>658</i>&nbsp;     */
<i>659</i>&nbsp;    public native void gc();
<i>660</i>&nbsp;
<i>661</i>&nbsp;    /**
<i>662</i>&nbsp;     * Runs the finalization methods of any objects pending finalization.
<i>663</i>&nbsp;     * Calling this method suggests that the Java virtual machine expend
<i>664</i>&nbsp;     * effort toward running the {@code finalize} methods of objects
<i>665</i>&nbsp;     * that have been found to be discarded but whose {@code finalize}
<i>666</i>&nbsp;     * methods have not yet been run. When control returns from the
<i>667</i>&nbsp;     * method call, the virtual machine has made a best effort to
<i>668</i>&nbsp;     * complete all outstanding finalizations.
<i>669</i>&nbsp;     * &lt;p&gt;
<i>670</i>&nbsp;     * The virtual machine performs the finalization process
<i>671</i>&nbsp;     * automatically as needed, in a separate thread, if the
<i>672</i>&nbsp;     * {@code runFinalization} method is not invoked explicitly.
<i>673</i>&nbsp;     * &lt;p&gt;
<i>674</i>&nbsp;     * The method {@link System#runFinalization()} is the conventional
<i>675</i>&nbsp;     * and convenient means of invoking this method.
<i>676</i>&nbsp;     *
<i>677</i>&nbsp;     * @see     java.lang.Object#finalize()
<i>678</i>&nbsp;     */
<i>679</i>&nbsp;    public void runFinalization() {
<i>680</i>&nbsp;        SharedSecrets.getJavaLangRefAccess().runFinalization();
<i>681</i>&nbsp;    }
<i>682</i>&nbsp;
<i>683</i>&nbsp;    /**
<i>684</i>&nbsp;     * Not implemented, does nothing.
<i>685</i>&nbsp;     *
<i>686</i>&nbsp;     * @deprecated
<i>687</i>&nbsp;     * This method was intended to control instruction tracing.
<i>688</i>&nbsp;     * It has been superseded by JVM-specific tracing mechanisms.
<i>689</i>&nbsp;     * This method is subject to removal in a future version of Java SE.
<i>690</i>&nbsp;     *
<i>691</i>&nbsp;     * @param on ignored
<i>692</i>&nbsp;     */
<i>693</i>&nbsp;    @Deprecated(since=&quot;9&quot;, forRemoval=true)
<i>694</i>&nbsp;    public void traceInstructions(boolean on) { }
<i>695</i>&nbsp;
<i>696</i>&nbsp;    /**
<i>697</i>&nbsp;     * Not implemented, does nothing.
<i>698</i>&nbsp;     *
<i>699</i>&nbsp;     * @deprecated
<i>700</i>&nbsp;     * This method was intended to control method call tracing.
<i>701</i>&nbsp;     * It has been superseded by JVM-specific tracing mechanisms.
<i>702</i>&nbsp;     * This method is subject to removal in a future version of Java SE.
<i>703</i>&nbsp;     *
<i>704</i>&nbsp;     * @param on ignored
<i>705</i>&nbsp;     */
<i>706</i>&nbsp;    @Deprecated(since=&quot;9&quot;, forRemoval=true)
<i>707</i>&nbsp;    public void traceMethodCalls(boolean on) { }
<i>708</i>&nbsp;
<i>709</i>&nbsp;    /**
<i>710</i>&nbsp;     * Loads the native library specified by the filename argument.  The filename
<i>711</i>&nbsp;     * argument must be an absolute path name.
<b class="nc"><i>712</i>&nbsp;     * (for example</b>
<i>713</i>&nbsp;     * {@code Runtime.getRuntime().load(&quot;/home/avh/lib/libX11.so&quot;);}).
<i>714</i>&nbsp;     *
<i>715</i>&nbsp;     * If the filename argument, when stripped of any platform-specific library
<i>716</i>&nbsp;     * prefix, path, and file extension, indicates a library whose name is,
<i>717</i>&nbsp;     * for example, L, and a native library called L is statically linked
<i>718</i>&nbsp;     * with the VM, then the JNI_OnLoad_L function exported by the library
<i>719</i>&nbsp;     * is invoked rather than attempting to load a dynamic library.
<i>720</i>&nbsp;     * A filename matching the argument does not have to exist in the file
<i>721</i>&nbsp;     * system.
<i>722</i>&nbsp;     * See the &lt;a href=&quot;{@docRoot}/../specs/jni/index.html&quot;&gt; JNI Specification&lt;/a&gt;
<i>723</i>&nbsp;     * for more details.
<i>724</i>&nbsp;     *
<i>725</i>&nbsp;     * Otherwise, the filename argument is mapped to a native library image in
<i>726</i>&nbsp;     * an implementation-dependent manner.
<i>727</i>&nbsp;     * &lt;p&gt;
<i>728</i>&nbsp;     * First, if there is a security manager, its {@code checkLink}
<i>729</i>&nbsp;     * method is called with the {@code filename} as its argument.
<i>730</i>&nbsp;     * This may result in a security exception.
<i>731</i>&nbsp;     * &lt;p&gt;
<i>732</i>&nbsp;     * This is similar to the method {@link #loadLibrary(String)}, but it
<i>733</i>&nbsp;     * accepts a general file name as an argument rather than just a library
<i>734</i>&nbsp;     * name, allowing any file of native code to be loaded.
<i>735</i>&nbsp;     * &lt;p&gt;
<i>736</i>&nbsp;     * The method {@link System#load(String)} is the conventional and
<i>737</i>&nbsp;     * convenient means of invoking this method.
<i>738</i>&nbsp;     *
<i>739</i>&nbsp;     * @param      filename   the file to load.
<i>740</i>&nbsp;     * @throws     SecurityException  if a security manager exists and its
<i>741</i>&nbsp;     *             {@code checkLink} method doesn&#39;t allow
<i>742</i>&nbsp;     *             loading of the specified dynamic library
<i>743</i>&nbsp;     * @throws     UnsatisfiedLinkError  if either the filename is not an
<i>744</i>&nbsp;     *             absolute path name, the native library is not statically
<i>745</i>&nbsp;     *             linked with the VM, or the library cannot be mapped to
<i>746</i>&nbsp;     *             a native library image by the host system.
<i>747</i>&nbsp;     * @throws     NullPointerException if {@code filename} is
<i>748</i>&nbsp;     *             {@code null}
<i>749</i>&nbsp;     * @see        java.lang.Runtime#getRuntime()
<i>750</i>&nbsp;     * @see        java.lang.SecurityException
<i>751</i>&nbsp;     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
<i>752</i>&nbsp;     */
<i>753</i>&nbsp;    @CallerSensitive
<i>754</i>&nbsp;    public void load(String filename) {
<i>755</i>&nbsp;        load0(Reflection.getCallerClass(), filename);
<i>756</i>&nbsp;    }
<i>757</i>&nbsp;
<i>758</i>&nbsp;    synchronized void load0(Class&lt;?&gt; fromClass, String filename) {
<i>759</i>&nbsp;        SecurityManager security = System.getSecurityManager();
<i>760</i>&nbsp;        if (security != null) {
<i>761</i>&nbsp;            security.checkLink(filename);
<i>762</i>&nbsp;        }
<i>763</i>&nbsp;        if (!(new File(filename).isAbsolute())) {
<i>764</i>&nbsp;            throw new UnsatisfiedLinkError(
<i>765</i>&nbsp;                &quot;Expecting an absolute path of the library: &quot; + filename);
<i>766</i>&nbsp;        }
<i>767</i>&nbsp;        ClassLoader.loadLibrary(fromClass, filename, true);
<i>768</i>&nbsp;    }
<i>769</i>&nbsp;
<i>770</i>&nbsp;    /**
<i>771</i>&nbsp;     * Loads the native library specified by the {@code libname}
<i>772</i>&nbsp;     * argument.  The {@code libname} argument must not contain any platform
<i>773</i>&nbsp;     * specific prefix, file extension or path. If a native library
<i>774</i>&nbsp;     * called {@code libname} is statically linked with the VM, then the
<i>775</i>&nbsp;     * JNI_OnLoad_{@code libname} function exported by the library is invoked.
<i>776</i>&nbsp;     * See the &lt;a href=&quot;{@docRoot}/../specs/jni/index.html&quot;&gt; JNI Specification&lt;/a&gt;
<i>777</i>&nbsp;     * for more details.
<i>778</i>&nbsp;     *
<i>779</i>&nbsp;     * Otherwise, the libname argument is loaded from a system library
<i>780</i>&nbsp;     * location and mapped to a native library image in an implementation-
<i>781</i>&nbsp;     * dependent manner.
<i>782</i>&nbsp;     * &lt;p&gt;
<i>783</i>&nbsp;     * First, if there is a security manager, its {@code checkLink}
<i>784</i>&nbsp;     * method is called with the {@code libname} as its argument.
<i>785</i>&nbsp;     * This may result in a security exception.
<i>786</i>&nbsp;     * &lt;p&gt;
<i>787</i>&nbsp;     * The method {@link System#loadLibrary(String)} is the conventional
<i>788</i>&nbsp;     * and convenient means of invoking this method. If native
<i>789</i>&nbsp;     * methods are to be used in the implementation of a class, a standard
<i>790</i>&nbsp;     * strategy is to put the native code in a library file (call it
<i>791</i>&nbsp;     * {@code LibFile}) and then to put a static initializer:
<i>792</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>793</i>&nbsp;     * static { System.loadLibrary(&quot;LibFile&quot;); }
<i>794</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>795</i>&nbsp;     * within the class declaration. When the class is loaded and
<i>796</i>&nbsp;     * initialized, the necessary native code implementation for the native
<b class="nc"><i>797</i>&nbsp;     * methods will then be loaded as well.</b>
<i>798</i>&nbsp;     * &lt;p&gt;
<i>799</i>&nbsp;     * If this method is called more than once with the same library
<i>800</i>&nbsp;     * name, the second and subsequent calls are ignored.
<b class="nc"><i>801</i>&nbsp;     *</b>
<b class="nc"><i>802</i>&nbsp;     * @param      libname   the name of the library.</b>
<b class="nc"><i>803</i>&nbsp;     * @throws     SecurityException  if a security manager exists and its</b>
<i>804</i>&nbsp;     *             {@code checkLink} method doesn&#39;t allow
<b class="nc"><i>805</i>&nbsp;     *             loading of the specified dynamic library</b>
<b class="nc"><i>806</i>&nbsp;     * @throws     UnsatisfiedLinkError if either the libname argument</b>
<i>807</i>&nbsp;     *             contains a file path, the native library is not statically
<i>808</i>&nbsp;     *             linked with the VM,  or the library cannot be mapped to a
<b class="nc"><i>809</i>&nbsp;     *             native library image by the host system.</b>
<i>810</i>&nbsp;     * @throws     NullPointerException if {@code libname} is
<i>811</i>&nbsp;     *             {@code null}
<i>812</i>&nbsp;     * @see        java.lang.SecurityException
<i>813</i>&nbsp;     * @see        java.lang.SecurityManager#checkLink(java.lang.String)
<i>814</i>&nbsp;     */
<i>815</i>&nbsp;    @CallerSensitive
<i>816</i>&nbsp;    public void loadLibrary(String libname) {
<i>817</i>&nbsp;        loadLibrary0(Reflection.getCallerClass(), libname);
<i>818</i>&nbsp;    }
<i>819</i>&nbsp;
<i>820</i>&nbsp;    synchronized void loadLibrary0(Class&lt;?&gt; fromClass, String libname) {
<i>821</i>&nbsp;        SecurityManager security = System.getSecurityManager();
<i>822</i>&nbsp;        if (security != null) {
<i>823</i>&nbsp;            security.checkLink(libname);
<i>824</i>&nbsp;        }
<i>825</i>&nbsp;        if (libname.indexOf((int)File.separatorChar) != -1) {
<i>826</i>&nbsp;            throw new UnsatisfiedLinkError(
<i>827</i>&nbsp;    &quot;Directory separator should not appear in library name: &quot; + libname);
<i>828</i>&nbsp;        }
<i>829</i>&nbsp;        ClassLoader.loadLibrary(fromClass, libname, false);
<i>830</i>&nbsp;    }
<i>831</i>&nbsp;
<i>832</i>&nbsp;    /**
<i>833</i>&nbsp;     * Returns the version of the Java Runtime Environment as a {@link Version}.
<i>834</i>&nbsp;     *
<i>835</i>&nbsp;     * @return  the {@link Version} of the Java Runtime Environment
<i>836</i>&nbsp;     *
<i>837</i>&nbsp;     * @since  9
<i>838</i>&nbsp;     */
<i>839</i>&nbsp;    public static Version version() {
<i>840</i>&nbsp;        if (version == null) {
<i>841</i>&nbsp;            version = new Version(VersionProps.versionNumbers(),
<i>842</i>&nbsp;                    VersionProps.pre(), VersionProps.build(),
<i>843</i>&nbsp;                    VersionProps.optional());
<i>844</i>&nbsp;        }
<i>845</i>&nbsp;        return version;
<i>846</i>&nbsp;    }
<i>847</i>&nbsp;
<i>848</i>&nbsp;    /**
<i>849</i>&nbsp;     * A representation of a version string for an implementation of the
<i>850</i>&nbsp;     * Java&amp;nbsp;SE Platform.  A version string consists of a version number
<i>851</i>&nbsp;     * optionally followed by pre-release and build information.
<i>852</i>&nbsp;     *
<i>853</i>&nbsp;     * &lt;h2&gt;&lt;a id=&quot;verNum&quot;&gt;Version numbers&lt;/a&gt;&lt;/h2&gt;
<i>854</i>&nbsp;     *
<i>855</i>&nbsp;     * &lt;p&gt; A &lt;em&gt;version number&lt;/em&gt;, {@code $VNUM}, is a non-empty sequence of
<i>856</i>&nbsp;     * elements separated by period characters (U+002E).  An element is either
<i>857</i>&nbsp;     * zero, or an unsigned integer numeral without leading zeros.  The final
<b class="nc"><i>858</i>&nbsp;     * element in a version number must not be zero.  When an element is</b>
<i>859</i>&nbsp;     * incremented, all subsequent elements are removed.  The format is: &lt;/p&gt;
<i>860</i>&nbsp;     *
<i>861</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<b class="nc"><i>862</i>&nbsp;     * [1-9][0-9]*((\.0)*\.[1-9][0-9]*)*</b>
<b class="nc"><i>863</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>864</i>&nbsp;     *</b>
<i>865</i>&nbsp;     * &lt;p&gt; The sequence may be of arbitrary length but the first four elements
<b class="nc"><i>866</i>&nbsp;     * are assigned specific meanings, as follows:&lt;/p&gt;</b>
<b class="nc"><i>867</i>&nbsp;     *</b>
<i>868</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>869</i>&nbsp;     * $FEATURE.$INTERIM.$UPDATE.$PATCH
<b class="nc"><i>870</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;</b>
<i>871</i>&nbsp;     *
<i>872</i>&nbsp;     * &lt;ul&gt;
<i>873</i>&nbsp;     *
<i>874</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;FEATURE&quot;&gt;{@code $FEATURE}&lt;/a&gt; &amp;#x2014; The
<i>875</i>&nbsp;     * feature-release counter, incremented for every feature release
<i>876</i>&nbsp;     * regardless of release content.  Features may be added in a feature
<i>877</i>&nbsp;     * release; they may also be removed, if advance notice was given at least
<i>878</i>&nbsp;     * one feature release ahead of time.  Incompatible changes may be made
<i>879</i>&nbsp;     * when justified. &lt;/p&gt;&lt;/li&gt;
<i>880</i>&nbsp;     *
<i>881</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;INTERIM&quot;&gt;{@code $INTERIM}&lt;/a&gt; &amp;#x2014; The
<i>882</i>&nbsp;     * interim-release counter, incremented for non-feature releases that
<i>883</i>&nbsp;     * contain compatible bug fixes and enhancements but no incompatible
<i>884</i>&nbsp;     * changes, no feature removals, and no changes to standard APIs.
<i>885</i>&nbsp;     * &lt;/p&gt;&lt;/li&gt;
<i>886</i>&nbsp;     *
<i>887</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;UPDATE&quot;&gt;{@code $UPDATE}&lt;/a&gt; &amp;#x2014; The update-release
<i>888</i>&nbsp;     * counter, incremented for compatible update releases that fix security
<i>889</i>&nbsp;     * issues, regressions, and bugs in newer features. &lt;/p&gt;&lt;/li&gt;
<i>890</i>&nbsp;     *
<i>891</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;PATCH&quot;&gt;{@code $PATCH}&lt;/a&gt; &amp;#x2014; The emergency
<i>892</i>&nbsp;     * patch-release counter, incremented only when it&#39;s necessary to produce
<i>893</i>&nbsp;     * an emergency release to fix a critical issue. &lt;/p&gt;&lt;/li&gt;
<i>894</i>&nbsp;     *
<i>895</i>&nbsp;     * &lt;/ul&gt;
<b class="nc"><i>896</i>&nbsp;     *</b>
<i>897</i>&nbsp;     * &lt;p&gt; The fifth and later elements of a version number are free for use by
<i>898</i>&nbsp;     * platform implementors, to identify implementor-specific patch
<i>899</i>&nbsp;     * releases. &lt;/p&gt;
<i>900</i>&nbsp;     *
<i>901</i>&nbsp;     * &lt;p&gt; A version number never has trailing zero elements.  If an element
<i>902</i>&nbsp;     * and all those that follow it logically have the value zero then all of
<i>903</i>&nbsp;     * them are omitted. &lt;/p&gt;
<i>904</i>&nbsp;     *
<i>905</i>&nbsp;     * &lt;p&gt; The sequence of numerals in a version number is compared to another
<i>906</i>&nbsp;     * such sequence in numerical, pointwise fashion; &lt;em&gt;e.g.&lt;/em&gt;, {@code
<i>907</i>&nbsp;     * 10.0.4} is less than {@code 10.1.2}.  If one sequence is shorter than
<i>908</i>&nbsp;     * another then the missing elements of the shorter sequence are considered
<i>909</i>&nbsp;     * to be less than the corresponding elements of the longer sequence;
<i>910</i>&nbsp;     * &lt;em&gt;e.g.&lt;/em&gt;, {@code 10.0.2} is less than {@code 10.0.2.1}. &lt;/p&gt;
<i>911</i>&nbsp;     *
<i>912</i>&nbsp;     * &lt;h2&gt;&lt;a id=&quot;verStr&quot;&gt;Version strings&lt;/a&gt;&lt;/h2&gt;
<i>913</i>&nbsp;     *
<i>914</i>&nbsp;     * &lt;p&gt; A &lt;em&gt;version string&lt;/em&gt;, {@code $VSTR}, is a version number {@code
<i>915</i>&nbsp;     * $VNUM}, as described above, optionally followed by pre-release and build
<i>916</i>&nbsp;     * information, in one of the following formats: &lt;/p&gt;
<i>917</i>&nbsp;     *
<i>918</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>919</i>&nbsp;     *     $VNUM(-$PRE)?\+$BUILD(-$OPT)?
<i>920</i>&nbsp;     *     $VNUM-$PRE(-$OPT)?
<i>921</i>&nbsp;     *     $VNUM(+-$OPT)?
<i>922</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>923</i>&nbsp;     *
<b class="nc"><i>924</i>&nbsp;     * &lt;p&gt; where: &lt;/p&gt;</b>
<i>925</i>&nbsp;     *
<i>926</i>&nbsp;     * &lt;ul&gt;
<i>927</i>&nbsp;     *
<i>928</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;pre&quot;&gt;{@code $PRE}&lt;/a&gt;, matching {@code ([a-zA-Z0-9]+)}
<i>929</i>&nbsp;     * &amp;#x2014; A pre-release identifier.  Typically {@code ea}, for a
<i>930</i>&nbsp;     * potentially unstable early-access release under active development, or
<i>931</i>&nbsp;     * {@code internal}, for an internal developer build. &lt;/p&gt;&lt;/li&gt;
<i>932</i>&nbsp;     *
<i>933</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;build&quot;&gt;{@code $BUILD}&lt;/a&gt;, matching {@code
<i>934</i>&nbsp;     * (0|[1-9][0-9]*)} &amp;#x2014; The build number, incremented for each promoted
<i>935</i>&nbsp;     * build.  {@code $BUILD} is reset to {@code 1} when any portion of {@code
<i>936</i>&nbsp;     * $VNUM} is incremented. &lt;/p&gt;&lt;/li&gt;
<i>937</i>&nbsp;     *
<i>938</i>&nbsp;     * &lt;li&gt;&lt;p&gt; &lt;a id=&quot;opt&quot;&gt;{@code $OPT}&lt;/a&gt;, matching {@code ([-a-zA-Z0-9.]+)}
<i>939</i>&nbsp;     * &amp;#x2014; Additional build information, if desired.  In the case of an
<i>940</i>&nbsp;     * {@code internal} build this will often contain the date and time of the
<i>941</i>&nbsp;     * build. &lt;/p&gt;&lt;/li&gt;
<i>942</i>&nbsp;     *
<i>943</i>&nbsp;     * &lt;/ul&gt;
<i>944</i>&nbsp;     *
<i>945</i>&nbsp;     * &lt;p&gt; A version string {@code 10-ea} matches {@code $VNUM = &quot;10&quot;} and
<i>946</i>&nbsp;     * {@code $PRE = &quot;ea&quot;}.  The version string {@code 10+-ea} matches
<i>947</i>&nbsp;     * {@code $VNUM = &quot;10&quot;} and {@code $OPT = &quot;ea&quot;}. &lt;/p&gt;
<i>948</i>&nbsp;     *
<i>949</i>&nbsp;     * &lt;p&gt; When comparing two version strings, the value of {@code $OPT}, if
<i>950</i>&nbsp;     * present, may or may not be significant depending on the chosen
<i>951</i>&nbsp;     * comparison method.  The comparison methods {@link #compareTo(Version)
<i>952</i>&nbsp;     * compareTo()} and {@link #compareToIgnoreOptional(Version)
<i>953</i>&nbsp;     * compareToIgnoreOptional()} should be used consistently with the
<i>954</i>&nbsp;     * corresponding methods {@link #equals(Object) equals()} and {@link
<i>955</i>&nbsp;     * #equalsIgnoreOptional(Object) equalsIgnoreOptional()}.  &lt;/p&gt;
<i>956</i>&nbsp;     *
<i>957</i>&nbsp;     * &lt;p&gt; A &lt;em&gt;short version string&lt;/em&gt;, {@code $SVSTR}, often useful in
<i>958</i>&nbsp;     * less formal contexts, is a version number optionally followed by a
<i>959</i>&nbsp;     * pre-release identifier:&lt;/p&gt;
<i>960</i>&nbsp;     *
<i>961</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;
<i>962</i>&nbsp;     *     $VNUM(-$PRE)?
<i>963</i>&nbsp;     * &lt;/pre&gt;&lt;/blockquote&gt;
<i>964</i>&nbsp;     *
<i>965</i>&nbsp;     * &lt;p&gt;This is a &lt;a href=&quot;./doc-files/ValueBased.html&quot;&gt;value-based&lt;/a&gt;
<i>966</i>&nbsp;     * class; use of identity-sensitive operations (including reference equality
<i>967</i>&nbsp;     * ({@code ==}), identity hash code, or synchronization) on instances of
<i>968</i>&nbsp;     * {@code Version} may have unpredictable results and should be avoided.
<i>969</i>&nbsp;     * &lt;/p&gt;
<i>970</i>&nbsp;     *
<i>971</i>&nbsp;     * @since  9
<i>972</i>&nbsp;     */
<i>973</i>&nbsp;    public static final class Version
<i>974</i>&nbsp;        implements Comparable&lt;Version&gt;
<i>975</i>&nbsp;    {
<i>976</i>&nbsp;        private final List&lt;Integer&gt;     version;
<i>977</i>&nbsp;        private final Optional&lt;String&gt;  pre;
<i>978</i>&nbsp;        private final Optional&lt;Integer&gt; build;
<i>979</i>&nbsp;        private final Optional&lt;String&gt;  optional;
<i>980</i>&nbsp;
<i>981</i>&nbsp;        /*
<i>982</i>&nbsp;         * List of version number components passed to this constructor MUST
<i>983</i>&nbsp;         * be at least unmodifiable (ideally immutable). In the case on an
<i>984</i>&nbsp;         * unmodifiable list, the caller MUST hand the list over to this
<i>985</i>&nbsp;         * constructor and never change the underlying list.
<i>986</i>&nbsp;         */
<i>987</i>&nbsp;        private Version(List&lt;Integer&gt; unmodifiableListOfVersions,
<i>988</i>&nbsp;                        Optional&lt;String&gt; pre,
<i>989</i>&nbsp;                        Optional&lt;Integer&gt; build,
<i>990</i>&nbsp;                        Optional&lt;String&gt; optional)
<i>991</i>&nbsp;        {
<i>992</i>&nbsp;            this.version = unmodifiableListOfVersions;
<i>993</i>&nbsp;            this.pre = pre;
<i>994</i>&nbsp;            this.build = build;
<i>995</i>&nbsp;            this.optional = optional;
<i>996</i>&nbsp;        }
<i>997</i>&nbsp;
<i>998</i>&nbsp;        /**
<i>999</i>&nbsp;         * Parses the given string as a valid
<i>1000</i>&nbsp;         * &lt;a href=&quot;#verStr&quot;&gt;version string&lt;/a&gt; containing a
<i>1001</i>&nbsp;         * &lt;a href=&quot;#verNum&quot;&gt;version number&lt;/a&gt; followed by pre-release and
<i>1002</i>&nbsp;         * build information.
<i>1003</i>&nbsp;         *
<i>1004</i>&nbsp;         * @param  s
<i>1005</i>&nbsp;         *         A string to interpret as a version
<i>1006</i>&nbsp;         *
<i>1007</i>&nbsp;         * @throws  IllegalArgumentException
<i>1008</i>&nbsp;         *          If the given string cannot be interpreted as a valid
<i>1009</i>&nbsp;         *          version
<i>1010</i>&nbsp;         *
<i>1011</i>&nbsp;         * @throws  NullPointerException
<i>1012</i>&nbsp;         *          If the given string is {@code null}
<i>1013</i>&nbsp;         *
<i>1014</i>&nbsp;         * @throws  NumberFormatException
<i>1015</i>&nbsp;         *          If an element of the version number or the build number
<i>1016</i>&nbsp;         *          cannot be represented as an {@link Integer}
<i>1017</i>&nbsp;         *
<i>1018</i>&nbsp;         * @return  The Version of the given string
<i>1019</i>&nbsp;         */
<i>1020</i>&nbsp;        public static Version parse(String s) {
<i>1021</i>&nbsp;            if (s == null)
<i>1022</i>&nbsp;                throw new NullPointerException();
<i>1023</i>&nbsp;
<i>1024</i>&nbsp;            // Shortcut to avoid initializing VersionPattern when creating
<i>1025</i>&nbsp;            // feature-version constants during startup
<i>1026</i>&nbsp;            if (isSimpleNumber(s)) {
<i>1027</i>&nbsp;                return new Version(List.of(Integer.parseInt(s)),
<i>1028</i>&nbsp;                        Optional.empty(), Optional.empty(), Optional.empty());
<i>1029</i>&nbsp;            }
<i>1030</i>&nbsp;            Matcher m = VersionPattern.VSTR_PATTERN.matcher(s);
<i>1031</i>&nbsp;            if (!m.matches())
<i>1032</i>&nbsp;                throw new IllegalArgumentException(&quot;Invalid version string: &#39;&quot;
<i>1033</i>&nbsp;                                                   + s + &quot;&#39;&quot;);
<i>1034</i>&nbsp;
<i>1035</i>&nbsp;            // $VNUM is a dot-separated list of integers of arbitrary length
<i>1036</i>&nbsp;            String[] split = m.group(VersionPattern.VNUM_GROUP).split(&quot;\\.&quot;);
<i>1037</i>&nbsp;            Integer[] version = new Integer[split.length];
<i>1038</i>&nbsp;            for (int i = 0; i &lt; split.length; i++) {
<i>1039</i>&nbsp;                version[i] = Integer.parseInt(split[i]);
<i>1040</i>&nbsp;            }
<i>1041</i>&nbsp;
<i>1042</i>&nbsp;            Optional&lt;String&gt; pre = Optional.ofNullable(
<i>1043</i>&nbsp;                    m.group(VersionPattern.PRE_GROUP));
<i>1044</i>&nbsp;
<i>1045</i>&nbsp;            String b = m.group(VersionPattern.BUILD_GROUP);
<i>1046</i>&nbsp;            // $BUILD is an integer
<i>1047</i>&nbsp;            Optional&lt;Integer&gt; build = (b == null)
<i>1048</i>&nbsp;                ? Optional.empty()
<i>1049</i>&nbsp;                : Optional.of(Integer.parseInt(b));
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;            Optional&lt;String&gt; optional = Optional.ofNullable(
<i>1052</i>&nbsp;                    m.group(VersionPattern.OPT_GROUP));
<i>1053</i>&nbsp;
<i>1054</i>&nbsp;            // empty &#39;+&#39;
<i>1055</i>&nbsp;            if (!build.isPresent()) {
<i>1056</i>&nbsp;                if (m.group(VersionPattern.PLUS_GROUP) != null) {
<i>1057</i>&nbsp;                    if (optional.isPresent()) {
<i>1058</i>&nbsp;                        if (pre.isPresent())
<i>1059</i>&nbsp;                            throw new IllegalArgumentException(&quot;&#39;+&#39; found with&quot;
<i>1060</i>&nbsp;                                + &quot; pre-release and optional components:&#39;&quot; + s
<i>1061</i>&nbsp;                                + &quot;&#39;&quot;);
<i>1062</i>&nbsp;                    } else {
<i>1063</i>&nbsp;                        throw new IllegalArgumentException(&quot;&#39;+&#39; found with neither&quot;
<i>1064</i>&nbsp;                            + &quot; build or optional components: &#39;&quot; + s + &quot;&#39;&quot;);
<i>1065</i>&nbsp;                    }
<i>1066</i>&nbsp;                } else {
<i>1067</i>&nbsp;                    if (optional.isPresent() &amp;&amp; !pre.isPresent()) {
<i>1068</i>&nbsp;                        throw new IllegalArgumentException(&quot;optional component&quot;
<i>1069</i>&nbsp;                            + &quot; must be preceeded by a pre-release component&quot;
<i>1070</i>&nbsp;                            + &quot; or &#39;+&#39;: &#39;&quot; + s + &quot;&#39;&quot;);
<i>1071</i>&nbsp;                    }
<i>1072</i>&nbsp;                }
<i>1073</i>&nbsp;            }
<i>1074</i>&nbsp;            return new Version(List.of(version), pre, build, optional);
<i>1075</i>&nbsp;        }
<i>1076</i>&nbsp;
<i>1077</i>&nbsp;        private static boolean isSimpleNumber(String s) {
<i>1078</i>&nbsp;            for (int i = 0; i &lt; s.length(); i++) {
<i>1079</i>&nbsp;                char c = s.charAt(i);
<i>1080</i>&nbsp;                char lowerBound = (i &gt; 0) ? &#39;0&#39; : &#39;1&#39;;
<i>1081</i>&nbsp;                if (c &lt; lowerBound || c &gt; &#39;9&#39;) {
<i>1082</i>&nbsp;                    return false;
<i>1083</i>&nbsp;                }
<i>1084</i>&nbsp;            }
<i>1085</i>&nbsp;            return true;
<i>1086</i>&nbsp;        }
<i>1087</i>&nbsp;
<i>1088</i>&nbsp;        /**
<i>1089</i>&nbsp;         * Returns the value of the &lt;a href=&quot;#FEATURE&quot;&gt;feature&lt;/a&gt; element of
<i>1090</i>&nbsp;         * the version number.
<i>1091</i>&nbsp;         *
<i>1092</i>&nbsp;         * @return The value of the feature element
<i>1093</i>&nbsp;         *
<i>1094</i>&nbsp;         * @since 10
<i>1095</i>&nbsp;         */
<i>1096</i>&nbsp;        public int feature() {
<i>1097</i>&nbsp;            return version.get(0);
<i>1098</i>&nbsp;        }
<i>1099</i>&nbsp;
<i>1100</i>&nbsp;        /**
<i>1101</i>&nbsp;         * Returns the value of the &lt;a href=&quot;#INTERIM&quot;&gt;interim&lt;/a&gt; element of
<i>1102</i>&nbsp;         * the version number, or zero if it is absent.
<i>1103</i>&nbsp;         *
<i>1104</i>&nbsp;         * @return The value of the interim element, or zero
<i>1105</i>&nbsp;         *
<i>1106</i>&nbsp;         * @since 10
<i>1107</i>&nbsp;         */
<i>1108</i>&nbsp;        public int interim() {
<i>1109</i>&nbsp;            return (version.size() &gt; 1 ? version.get(1) : 0);
<i>1110</i>&nbsp;        }
<i>1111</i>&nbsp;
<i>1112</i>&nbsp;        /**
<i>1113</i>&nbsp;         * Returns the value of the &lt;a href=&quot;#UPDATE&quot;&gt;update&lt;/a&gt; element of the
<i>1114</i>&nbsp;         * version number, or zero if it is absent.
<i>1115</i>&nbsp;         *
<i>1116</i>&nbsp;         * @return The value of the update element, or zero
<i>1117</i>&nbsp;         *
<i>1118</i>&nbsp;         * @since 10
<i>1119</i>&nbsp;         */
<i>1120</i>&nbsp;        public int update() {
<i>1121</i>&nbsp;            return (version.size() &gt; 2 ? version.get(2) : 0);
<i>1122</i>&nbsp;        }
<i>1123</i>&nbsp;
<i>1124</i>&nbsp;        /**
<i>1125</i>&nbsp;         * Returns the value of the &lt;a href=&quot;#PATCH&quot;&gt;patch&lt;/a&gt; element of the
<i>1126</i>&nbsp;         * version number, or zero if it is absent.
<i>1127</i>&nbsp;         *
<i>1128</i>&nbsp;         * @return The value of the patch element, or zero
<i>1129</i>&nbsp;         *
<i>1130</i>&nbsp;         * @since 10
<i>1131</i>&nbsp;         */
<i>1132</i>&nbsp;        public int patch() {
<i>1133</i>&nbsp;            return (version.size() &gt; 3 ? version.get(3) : 0);
<i>1134</i>&nbsp;        }
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;        /**
<i>1137</i>&nbsp;         * Returns the value of the major element of the version number.
<i>1138</i>&nbsp;         *
<i>1139</i>&nbsp;         * @deprecated As of Java&amp;nbsp;SE 10, the first element of a version
<i>1140</i>&nbsp;         * number is not the major-release number but the feature-release
<i>1141</i>&nbsp;         * counter, incremented for every time-based release.  Use the {@link
<i>1142</i>&nbsp;         * #feature()} method in preference to this method.  For compatibility,
<i>1143</i>&nbsp;         * this method returns the value of the &lt;a href=&quot;#FEATURE&quot;&gt;feature&lt;/a&gt;
<i>1144</i>&nbsp;         * element.
<i>1145</i>&nbsp;         *
<i>1146</i>&nbsp;         * @return The value of the feature element
<i>1147</i>&nbsp;         */
<i>1148</i>&nbsp;        @Deprecated(since = &quot;10&quot;)
<i>1149</i>&nbsp;        public int major() {
<i>1150</i>&nbsp;            return feature();
<i>1151</i>&nbsp;        }
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;        /**
<i>1154</i>&nbsp;         * Returns the value of the minor element of the version number, or
<i>1155</i>&nbsp;         * zero if it is absent.
<i>1156</i>&nbsp;         *
<i>1157</i>&nbsp;         * @deprecated As of Java&amp;nbsp;SE 10, the second element of a version
<i>1158</i>&nbsp;         * number is not the minor-release number but the interim-release
<i>1159</i>&nbsp;         * counter, incremented for every interim release.  Use the {@link
<i>1160</i>&nbsp;         * #interim()} method in preference to this method.  For compatibility,
<i>1161</i>&nbsp;         * this method returns the value of the &lt;a href=&quot;#INTERIM&quot;&gt;interim&lt;/a&gt;
<i>1162</i>&nbsp;         * element, or zero if it is absent.
<i>1163</i>&nbsp;         *
<i>1164</i>&nbsp;         * @return The value of the interim element, or zero
<i>1165</i>&nbsp;         */
<i>1166</i>&nbsp;        @Deprecated(since = &quot;10&quot;)
<i>1167</i>&nbsp;        public int minor() {
<i>1168</i>&nbsp;            return interim();
<i>1169</i>&nbsp;        }
<i>1170</i>&nbsp;
<i>1171</i>&nbsp;        /**
<i>1172</i>&nbsp;         * Returns the value of the security element of the version number, or
<i>1173</i>&nbsp;         * zero if it is absent.
<i>1174</i>&nbsp;         *
<i>1175</i>&nbsp;         * @deprecated As of Java&amp;nbsp;SE 10, the third element of a version
<i>1176</i>&nbsp;         * number is not the security level but the update-release counter,
<i>1177</i>&nbsp;         * incremented for every update release.  Use the {@link #update()}
<i>1178</i>&nbsp;         * method in preference to this method.  For compatibility, this method
<i>1179</i>&nbsp;         * returns the value of the &lt;a href=&quot;#UPDATE&quot;&gt;update&lt;/a&gt; element, or
<i>1180</i>&nbsp;         * zero if it is absent.
<i>1181</i>&nbsp;         *
<i>1182</i>&nbsp;         * @return  The value of the update element, or zero
<i>1183</i>&nbsp;         */
<i>1184</i>&nbsp;        @Deprecated(since = &quot;10&quot;)
<i>1185</i>&nbsp;        public int security() {
<i>1186</i>&nbsp;            return update();
<i>1187</i>&nbsp;        }
<i>1188</i>&nbsp;
<i>1189</i>&nbsp;        /**
<i>1190</i>&nbsp;         * Returns an unmodifiable {@link java.util.List List} of the integers
<i>1191</i>&nbsp;         * represented in the &lt;a href=&quot;#verNum&quot;&gt;version number&lt;/a&gt;.
<i>1192</i>&nbsp;         * The {@code List} always contains at least one element corresponding to
<i>1193</i>&nbsp;         * the &lt;a href=&quot;#FEATURE&quot;&gt;feature version number&lt;/a&gt;.
<i>1194</i>&nbsp;         *
<i>1195</i>&nbsp;         * @return  An unmodifiable list of the integers
<i>1196</i>&nbsp;         *          represented in the version number
<i>1197</i>&nbsp;         */
<i>1198</i>&nbsp;        public List&lt;Integer&gt; version() {
<i>1199</i>&nbsp;            return version;
<i>1200</i>&nbsp;        }
<i>1201</i>&nbsp;
<i>1202</i>&nbsp;        /**
<i>1203</i>&nbsp;         * Returns the optional &lt;a href=&quot;#pre&quot;&gt;pre-release&lt;/a&gt; information.
<i>1204</i>&nbsp;         *
<i>1205</i>&nbsp;         * @return  The optional pre-release information as a String
<i>1206</i>&nbsp;         */
<i>1207</i>&nbsp;        public Optional&lt;String&gt; pre() {
<i>1208</i>&nbsp;            return pre;
<i>1209</i>&nbsp;        }
<i>1210</i>&nbsp;
<i>1211</i>&nbsp;        /**
<i>1212</i>&nbsp;         * Returns the &lt;a href=&quot;#build&quot;&gt;build number&lt;/a&gt;.
<i>1213</i>&nbsp;         *
<i>1214</i>&nbsp;         * @return  The optional build number.
<i>1215</i>&nbsp;         */
<i>1216</i>&nbsp;        public Optional&lt;Integer&gt; build() {
<i>1217</i>&nbsp;            return build;
<i>1218</i>&nbsp;        }
<i>1219</i>&nbsp;
<i>1220</i>&nbsp;        /**
<i>1221</i>&nbsp;         * Returns &lt;a href=&quot;#opt&quot;&gt;optional&lt;/a&gt; additional identifying build
<i>1222</i>&nbsp;         * information.
<i>1223</i>&nbsp;         *
<i>1224</i>&nbsp;         * @return  Additional build information as a String
<i>1225</i>&nbsp;         */
<i>1226</i>&nbsp;        public Optional&lt;String&gt; optional() {
<i>1227</i>&nbsp;            return optional;
<i>1228</i>&nbsp;        }
<i>1229</i>&nbsp;
<i>1230</i>&nbsp;        /**
<i>1231</i>&nbsp;         * Compares this version to another.
<i>1232</i>&nbsp;         *
<i>1233</i>&nbsp;         * &lt;p&gt; Each of the components in the &lt;a href=&quot;#verStr&quot;&gt;version&lt;/a&gt; is
<i>1234</i>&nbsp;         * compared in the following order of precedence: version numbers,
<i>1235</i>&nbsp;         * pre-release identifiers, build numbers, optional build information.
<i>1236</i>&nbsp;         * &lt;/p&gt;
<i>1237</i>&nbsp;         *
<i>1238</i>&nbsp;         * &lt;p&gt; Comparison begins by examining the sequence of version numbers.
<i>1239</i>&nbsp;         * If one sequence is shorter than another, then the missing elements
<i>1240</i>&nbsp;         * of the shorter sequence are considered to be less than the
<i>1241</i>&nbsp;         * corresponding elements of the longer sequence. &lt;/p&gt;
<i>1242</i>&nbsp;         *
<i>1243</i>&nbsp;         * &lt;p&gt; A version with a pre-release identifier is always considered to
<i>1244</i>&nbsp;         * be less than a version without one.  Pre-release identifiers are
<i>1245</i>&nbsp;         * compared numerically when they consist only of digits, and
<i>1246</i>&nbsp;         * lexicographically otherwise.  Numeric identifiers are considered to
<i>1247</i>&nbsp;         * be less than non-numeric identifiers.  &lt;/p&gt;
<i>1248</i>&nbsp;         *
<i>1249</i>&nbsp;         * &lt;p&gt; A version without a build number is always less than one with a
<i>1250</i>&nbsp;         * build number; otherwise build numbers are compared numerically. &lt;/p&gt;
<i>1251</i>&nbsp;         *
<i>1252</i>&nbsp;         * &lt;p&gt; The optional build information is compared lexicographically.
<i>1253</i>&nbsp;         * During this comparison, a version with optional build information is
<i>1254</i>&nbsp;         * considered to be greater than a version without one. &lt;/p&gt;
<i>1255</i>&nbsp;         *
<i>1256</i>&nbsp;         * @param  obj
<i>1257</i>&nbsp;         *         The object to be compared
<i>1258</i>&nbsp;         *
<i>1259</i>&nbsp;         * @return  A negative integer, zero, or a positive integer if this
<i>1260</i>&nbsp;         *          {@code Version} is less than, equal to, or greater than the
<i>1261</i>&nbsp;         *          given {@code Version}
<i>1262</i>&nbsp;         *
<i>1263</i>&nbsp;         * @throws  NullPointerException
<i>1264</i>&nbsp;         *          If the given object is {@code null}
<i>1265</i>&nbsp;         */
<i>1266</i>&nbsp;        @Override
<i>1267</i>&nbsp;        public int compareTo(Version obj) {
<i>1268</i>&nbsp;            return compare(obj, false);
<i>1269</i>&nbsp;        }
<i>1270</i>&nbsp;
<i>1271</i>&nbsp;        /**
<i>1272</i>&nbsp;         * Compares this version to another disregarding optional build
<i>1273</i>&nbsp;         * information.
<i>1274</i>&nbsp;         *
<i>1275</i>&nbsp;         * &lt;p&gt; Two versions are compared by examining the version string as
<i>1276</i>&nbsp;         * described in {@link #compareTo(Version)} with the exception that the
<i>1277</i>&nbsp;         * optional build information is always ignored. &lt;/p&gt;
<i>1278</i>&nbsp;         *
<i>1279</i>&nbsp;         * &lt;p&gt; This method provides ordering which is consistent with
<i>1280</i>&nbsp;         * {@code equalsIgnoreOptional()}. &lt;/p&gt;
<i>1281</i>&nbsp;         *
<i>1282</i>&nbsp;         * @param  obj
<i>1283</i>&nbsp;         *         The object to be compared
<i>1284</i>&nbsp;         *
<i>1285</i>&nbsp;         * @return  A negative integer, zero, or a positive integer if this
<i>1286</i>&nbsp;         *          {@code Version} is less than, equal to, or greater than the
<i>1287</i>&nbsp;         *          given {@code Version}
<i>1288</i>&nbsp;         *
<i>1289</i>&nbsp;         * @throws  NullPointerException
<i>1290</i>&nbsp;         *          If the given object is {@code null}
<i>1291</i>&nbsp;         */
<i>1292</i>&nbsp;        public int compareToIgnoreOptional(Version obj) {
<i>1293</i>&nbsp;            return compare(obj, true);
<i>1294</i>&nbsp;        }
<i>1295</i>&nbsp;
<i>1296</i>&nbsp;        private int compare(Version obj, boolean ignoreOpt) {
<i>1297</i>&nbsp;            if (obj == null)
<i>1298</i>&nbsp;                throw new NullPointerException();
<i>1299</i>&nbsp;
<i>1300</i>&nbsp;            int ret = compareVersion(obj);
<i>1301</i>&nbsp;            if (ret != 0)
<i>1302</i>&nbsp;                return ret;
<i>1303</i>&nbsp;
<i>1304</i>&nbsp;            ret = comparePre(obj);
<i>1305</i>&nbsp;            if (ret != 0)
<i>1306</i>&nbsp;                return ret;
<i>1307</i>&nbsp;
<i>1308</i>&nbsp;            ret = compareBuild(obj);
<i>1309</i>&nbsp;            if (ret != 0)
<i>1310</i>&nbsp;                return ret;
<i>1311</i>&nbsp;
<i>1312</i>&nbsp;            if (!ignoreOpt)
<i>1313</i>&nbsp;                return compareOptional(obj);
<i>1314</i>&nbsp;
<i>1315</i>&nbsp;            return 0;
<i>1316</i>&nbsp;        }
<i>1317</i>&nbsp;
<i>1318</i>&nbsp;        private int compareVersion(Version obj) {
<i>1319</i>&nbsp;            int size = version.size();
<i>1320</i>&nbsp;            int oSize = obj.version().size();
<i>1321</i>&nbsp;            int min = Math.min(size, oSize);
<i>1322</i>&nbsp;            for (int i = 0; i &lt; min; i++) {
<i>1323</i>&nbsp;                int val = version.get(i);
<i>1324</i>&nbsp;                int oVal = obj.version().get(i);
<i>1325</i>&nbsp;                if (val != oVal)
<i>1326</i>&nbsp;                    return val - oVal;
<i>1327</i>&nbsp;            }
<i>1328</i>&nbsp;            return size - oSize;
<i>1329</i>&nbsp;        }
<i>1330</i>&nbsp;
<i>1331</i>&nbsp;        private int comparePre(Version obj) {
<i>1332</i>&nbsp;            Optional&lt;String&gt; oPre = obj.pre();
<i>1333</i>&nbsp;            if (!pre.isPresent()) {
<i>1334</i>&nbsp;                if (oPre.isPresent())
<i>1335</i>&nbsp;                    return 1;
<i>1336</i>&nbsp;            } else {
<i>1337</i>&nbsp;                if (!oPre.isPresent())
<i>1338</i>&nbsp;                    return -1;
<i>1339</i>&nbsp;                String val = pre.get();
<i>1340</i>&nbsp;                String oVal = oPre.get();
<i>1341</i>&nbsp;                if (val.matches(&quot;\\d+&quot;)) {
<i>1342</i>&nbsp;                    return (oVal.matches(&quot;\\d+&quot;)
<i>1343</i>&nbsp;                        ? (new BigInteger(val)).compareTo(new BigInteger(oVal))
<i>1344</i>&nbsp;                        : -1);
<i>1345</i>&nbsp;                } else {
<i>1346</i>&nbsp;                    return (oVal.matches(&quot;\\d+&quot;)
<i>1347</i>&nbsp;                        ? 1
<i>1348</i>&nbsp;                        : val.compareTo(oVal));
<i>1349</i>&nbsp;                }
<i>1350</i>&nbsp;            }
<i>1351</i>&nbsp;            return 0;
<i>1352</i>&nbsp;        }
<i>1353</i>&nbsp;
<i>1354</i>&nbsp;        private int compareBuild(Version obj) {
<i>1355</i>&nbsp;            Optional&lt;Integer&gt; oBuild = obj.build();
<i>1356</i>&nbsp;            if (oBuild.isPresent()) {
<i>1357</i>&nbsp;                return (build.isPresent()
<i>1358</i>&nbsp;                        ? build.get().compareTo(oBuild.get())
<i>1359</i>&nbsp;                        : -1);
<i>1360</i>&nbsp;            } else if (build.isPresent()) {
<i>1361</i>&nbsp;                return 1;
<i>1362</i>&nbsp;            }
<i>1363</i>&nbsp;            return 0;
<i>1364</i>&nbsp;        }
<i>1365</i>&nbsp;
<i>1366</i>&nbsp;        private int compareOptional(Version obj) {
<i>1367</i>&nbsp;            Optional&lt;String&gt; oOpt = obj.optional();
<i>1368</i>&nbsp;            if (!optional.isPresent()) {
<i>1369</i>&nbsp;                if (oOpt.isPresent())
<i>1370</i>&nbsp;                    return -1;
<i>1371</i>&nbsp;            } else {
<i>1372</i>&nbsp;                if (!oOpt.isPresent())
<i>1373</i>&nbsp;                    return 1;
<i>1374</i>&nbsp;                return optional.get().compareTo(oOpt.get());
<i>1375</i>&nbsp;            }
<i>1376</i>&nbsp;            return 0;
<i>1377</i>&nbsp;        }
<i>1378</i>&nbsp;
<i>1379</i>&nbsp;        /**
<i>1380</i>&nbsp;         * Returns a string representation of this version.
<i>1381</i>&nbsp;         *
<i>1382</i>&nbsp;         * @return  The version string
<i>1383</i>&nbsp;         */
<i>1384</i>&nbsp;        @Override
<i>1385</i>&nbsp;        public String toString() {
<i>1386</i>&nbsp;            StringBuilder sb
<i>1387</i>&nbsp;                = new StringBuilder(version.stream()
<i>1388</i>&nbsp;                    .map(Object::toString)
<i>1389</i>&nbsp;                    .collect(Collectors.joining(&quot;.&quot;)));
<i>1390</i>&nbsp;
<i>1391</i>&nbsp;            pre.ifPresent(v -&gt; sb.append(&quot;-&quot;).append(v));
<i>1392</i>&nbsp;
<i>1393</i>&nbsp;            if (build.isPresent()) {
<i>1394</i>&nbsp;                sb.append(&quot;+&quot;).append(build.get());
<i>1395</i>&nbsp;                if (optional.isPresent())
<i>1396</i>&nbsp;                    sb.append(&quot;-&quot;).append(optional.get());
<i>1397</i>&nbsp;            } else {
<i>1398</i>&nbsp;                if (optional.isPresent()) {
<i>1399</i>&nbsp;                    sb.append(pre.isPresent() ? &quot;-&quot; : &quot;+-&quot;);
<i>1400</i>&nbsp;                    sb.append(optional.get());
<i>1401</i>&nbsp;                }
<i>1402</i>&nbsp;            }
<i>1403</i>&nbsp;
<i>1404</i>&nbsp;            return sb.toString();
<i>1405</i>&nbsp;        }
<i>1406</i>&nbsp;
<i>1407</i>&nbsp;        /**
<i>1408</i>&nbsp;         * Determines whether this {@code Version} is equal to another object.
<i>1409</i>&nbsp;         *
<i>1410</i>&nbsp;         * &lt;p&gt; Two {@code Version}s are equal if and only if they represent the
<i>1411</i>&nbsp;         * same version string.
<i>1412</i>&nbsp;         *
<i>1413</i>&nbsp;         * @param  obj
<i>1414</i>&nbsp;         *         The object to which this {@code Version} is to be compared
<i>1415</i>&nbsp;         *
<i>1416</i>&nbsp;         * @return  {@code true} if, and only if, the given object is a {@code
<i>1417</i>&nbsp;         *          Version} that is identical to this {@code Version}
<i>1418</i>&nbsp;         *
<i>1419</i>&nbsp;         */
<i>1420</i>&nbsp;        @Override
<i>1421</i>&nbsp;        public boolean equals(Object obj) {
<i>1422</i>&nbsp;            boolean ret = equalsIgnoreOptional(obj);
<i>1423</i>&nbsp;            if (!ret)
<i>1424</i>&nbsp;                return false;
<i>1425</i>&nbsp;
<i>1426</i>&nbsp;            Version that = (Version)obj;
<i>1427</i>&nbsp;            return (this.optional().equals(that.optional()));
<i>1428</i>&nbsp;        }
<i>1429</i>&nbsp;
<i>1430</i>&nbsp;        /**
<i>1431</i>&nbsp;         * Determines whether this {@code Version} is equal to another
<i>1432</i>&nbsp;         * disregarding optional build information.
<i>1433</i>&nbsp;         *
<i>1434</i>&nbsp;         * &lt;p&gt; Two {@code Version}s are equal if and only if they represent the
<i>1435</i>&nbsp;         * same version string disregarding the optional build information.
<i>1436</i>&nbsp;         *
<i>1437</i>&nbsp;         * @param  obj
<i>1438</i>&nbsp;         *         The object to which this {@code Version} is to be compared
<i>1439</i>&nbsp;         *
<i>1440</i>&nbsp;         * @return  {@code true} if, and only if, the given object is a {@code
<i>1441</i>&nbsp;         *          Version} that is identical to this {@code Version}
<i>1442</i>&nbsp;         *          ignoring the optional build information
<i>1443</i>&nbsp;         *
<i>1444</i>&nbsp;         */
<i>1445</i>&nbsp;        public boolean equalsIgnoreOptional(Object obj) {
<i>1446</i>&nbsp;            if (this == obj)
<i>1447</i>&nbsp;                return true;
<i>1448</i>&nbsp;            if (!(obj instanceof Version))
<i>1449</i>&nbsp;                return false;
<i>1450</i>&nbsp;
<i>1451</i>&nbsp;            Version that = (Version)obj;
<i>1452</i>&nbsp;            return (this.version().equals(that.version())
<i>1453</i>&nbsp;                &amp;&amp; this.pre().equals(that.pre())
<i>1454</i>&nbsp;                &amp;&amp; this.build().equals(that.build()));
<i>1455</i>&nbsp;        }
<i>1456</i>&nbsp;
<i>1457</i>&nbsp;        /**
<i>1458</i>&nbsp;         * Returns the hash code of this version.
<i>1459</i>&nbsp;         *
<i>1460</i>&nbsp;         * @return  The hashcode of this version
<i>1461</i>&nbsp;         */
<i>1462</i>&nbsp;        @Override
<i>1463</i>&nbsp;        public int hashCode() {
<i>1464</i>&nbsp;            int h = 1;
<i>1465</i>&nbsp;            int p = 17;
<i>1466</i>&nbsp;
<i>1467</i>&nbsp;            h = p * h + version.hashCode();
<i>1468</i>&nbsp;            h = p * h + pre.hashCode();
<i>1469</i>&nbsp;            h = p * h + build.hashCode();
<i>1470</i>&nbsp;            h = p * h + optional.hashCode();
<i>1471</i>&nbsp;
<i>1472</i>&nbsp;            return h;
<i>1473</i>&nbsp;        }
<i>1474</i>&nbsp;    }
<i>1475</i>&nbsp;
<i>1476</i>&nbsp;    private static class VersionPattern {
<i>1477</i>&nbsp;        // $VNUM(-$PRE)?(\+($BUILD)?(\-$OPT)?)?
<i>1478</i>&nbsp;        // RE limits the format of version strings
<i>1479</i>&nbsp;        // ([1-9][0-9]*(?:(?:\.0)*\.[1-9][0-9]*)*)(?:-([a-zA-Z0-9]+))?(?:(\+)(0|[1-9][0-9]*)?)?(?:-([-a-zA-Z0-9.]+))?
<i>1480</i>&nbsp;
<i>1481</i>&nbsp;        private static final String VNUM
<i>1482</i>&nbsp;            = &quot;(?&lt;VNUM&gt;[1-9][0-9]*(?:(?:\\.0)*\\.[1-9][0-9]*)*)&quot;;
<i>1483</i>&nbsp;        private static final String PRE      = &quot;(?:-(?&lt;PRE&gt;[a-zA-Z0-9]+))?&quot;;
<i>1484</i>&nbsp;        private static final String BUILD
<i>1485</i>&nbsp;            = &quot;(?:(?&lt;PLUS&gt;\\+)(?&lt;BUILD&gt;0|[1-9][0-9]*)?)?&quot;;
<i>1486</i>&nbsp;        private static final String OPT      = &quot;(?:-(?&lt;OPT&gt;[-a-zA-Z0-9.]+))?&quot;;
<i>1487</i>&nbsp;        private static final String VSTR_FORMAT = VNUM + PRE + BUILD + OPT;
<i>1488</i>&nbsp;
<i>1489</i>&nbsp;        static final Pattern VSTR_PATTERN = Pattern.compile(VSTR_FORMAT);
<i>1490</i>&nbsp;
<i>1491</i>&nbsp;        static final String VNUM_GROUP  = &quot;VNUM&quot;;
<i>1492</i>&nbsp;        static final String PRE_GROUP   = &quot;PRE&quot;;
<i>1493</i>&nbsp;        static final String PLUS_GROUP  = &quot;PLUS&quot;;
<i>1494</i>&nbsp;        static final String BUILD_GROUP = &quot;BUILD&quot;;
<i>1495</i>&nbsp;        static final String OPT_GROUP   = &quot;OPT&quot;;
<i>1496</i>&nbsp;    }
<i>1497</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:13</div>
</div>
</body>
</html>
