


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Sequencer</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">javax.sound.midi</a> ]
</div>

<h1>Coverage Summary for Class: Sequencer (javax.sound.midi)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Sequencer$SyncMode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 9)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package javax.sound.midi;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.IOException;
<i>29</i>&nbsp;import java.io.InputStream;
<i>30</i>&nbsp;
<i>31</i>&nbsp;/**
<i>32</i>&nbsp; * A hardware or software device that plays back a MIDI
<i>33</i>&nbsp; * {@link Sequence sequence} is known as a &lt;em&gt;sequencer&lt;/em&gt;. A MIDI sequence
<i>34</i>&nbsp; * contains lists of time-stamped MIDI data, such as might be read from a
<i>35</i>&nbsp; * standard MIDI file. Most sequencers also provide functions for creating and
<i>36</i>&nbsp; * editing sequences.
<i>37</i>&nbsp; * &lt;p&gt;
<i>38</i>&nbsp; * The {@code Sequencer} interface includes methods for the following basic MIDI
<i>39</i>&nbsp; * sequencer operations:
<i>40</i>&nbsp; * &lt;ul&gt;
<i>41</i>&nbsp; *   &lt;li&gt;obtaining a sequence from MIDI file data
<i>42</i>&nbsp; *   &lt;li&gt;starting and stopping playback
<i>43</i>&nbsp; *   &lt;li&gt;moving to an arbitrary position in the sequence
<i>44</i>&nbsp; *   &lt;li&gt;changing the tempo (speed) of playback
<i>45</i>&nbsp; *   &lt;li&gt;synchronizing playback to an internal clock or to received MIDI
<i>46</i>&nbsp; *   messages
<i>47</i>&nbsp; *   &lt;li&gt;controlling the timing of another device
<i>48</i>&nbsp; * &lt;/ul&gt;
<i>49</i>&nbsp; * In addition, the following operations are supported, either directly, or
<i>50</i>&nbsp; * indirectly through objects that the {@code Sequencer} has access to:
<i>51</i>&nbsp; * &lt;ul&gt;
<i>52</i>&nbsp; *   &lt;li&gt;editing the data by adding or deleting individual MIDI events or entire
<i>53</i>&nbsp; *   tracks
<i>54</i>&nbsp; *   &lt;li&gt;muting or soloing individual tracks in the sequence
<i>55</i>&nbsp; *   &lt;li&gt;notifying listener objects about any meta-events or control-change
<i>56</i>&nbsp; *   events encountered while playing back the sequence
<i>57</i>&nbsp; * &lt;/ul&gt;
<i>58</i>&nbsp; *
<i>59</i>&nbsp; * @author Kara Kytle
<i>60</i>&nbsp; * @author Florian Bomers
<i>61</i>&nbsp; * @see SyncMode
<i>62</i>&nbsp; * @see #addMetaEventListener
<i>63</i>&nbsp; * @see ControllerEventListener
<i>64</i>&nbsp; * @see Receiver
<i>65</i>&nbsp; * @see Transmitter
<i>66</i>&nbsp; * @see MidiDevice
<i>67</i>&nbsp; */
<i>68</i>&nbsp;public interface Sequencer extends MidiDevice {
<i>69</i>&nbsp;
<i>70</i>&nbsp;    /**
<i>71</i>&nbsp;     * A value indicating that looping should continue indefinitely rather than
<i>72</i>&nbsp;     * complete after a specific number of loops.
<i>73</i>&nbsp;     *
<i>74</i>&nbsp;     * @see #setLoopCount
<i>75</i>&nbsp;     * @since 1.5
<i>76</i>&nbsp;     */
<i>77</i>&nbsp;    int LOOP_CONTINUOUSLY = -1;
<i>78</i>&nbsp;
<i>79</i>&nbsp;    /**
<i>80</i>&nbsp;     * Sets the current sequence on which the sequencer operates.
<i>81</i>&nbsp;     * &lt;p&gt;
<i>82</i>&nbsp;     * This method can be called even if the {@code Sequencer} is closed.
<i>83</i>&nbsp;     *
<i>84</i>&nbsp;     * @param  sequence the sequence to be loaded
<i>85</i>&nbsp;     * @throws InvalidMidiDataException if the sequence contains invalid MIDI
<i>86</i>&nbsp;     *         data, or is not supported
<i>87</i>&nbsp;     */
<i>88</i>&nbsp;    void setSequence(Sequence sequence) throws InvalidMidiDataException;
<i>89</i>&nbsp;
<i>90</i>&nbsp;    /**
<i>91</i>&nbsp;     * Sets the current sequence on which the sequencer operates. The stream
<i>92</i>&nbsp;     * must point to MIDI file data.
<i>93</i>&nbsp;     * &lt;p&gt;
<i>94</i>&nbsp;     * This method can be called even if the {@code Sequencer} is closed.
<i>95</i>&nbsp;     *
<i>96</i>&nbsp;     * @param  stream stream containing MIDI file data
<i>97</i>&nbsp;     * @throws IOException if an I/O exception occurs during reading of the
<i>98</i>&nbsp;     *         stream
<i>99</i>&nbsp;     * @throws InvalidMidiDataException if invalid data is encountered in the
<i>100</i>&nbsp;     *         stream, or the stream is not supported
<i>101</i>&nbsp;     */
<i>102</i>&nbsp;    void setSequence(InputStream stream)
<i>103</i>&nbsp;            throws IOException, InvalidMidiDataException;
<i>104</i>&nbsp;
<i>105</i>&nbsp;    /**
<i>106</i>&nbsp;     * Obtains the sequence on which the Sequencer is currently operating.
<i>107</i>&nbsp;     * &lt;p&gt;
<i>108</i>&nbsp;     * This method can be called even if the {@code Sequencer} is closed.
<i>109</i>&nbsp;     *
<i>110</i>&nbsp;     * @return the current sequence, or {@code null} if no sequence is currently
<i>111</i>&nbsp;     *         set
<i>112</i>&nbsp;     */
<i>113</i>&nbsp;    Sequence getSequence();
<i>114</i>&nbsp;
<i>115</i>&nbsp;    /**
<i>116</i>&nbsp;     * Starts playback of the MIDI data in the currently loaded sequence.
<i>117</i>&nbsp;     * Playback will begin from the current position. If the playback position
<i>118</i>&nbsp;     * reaches the loop end point, and the loop count is greater than 0,
<i>119</i>&nbsp;     * playback will resume at the loop start point for the number of
<i>120</i>&nbsp;     * repetitions set with {@code setLoopCount}. After that, or if the loop
<i>121</i>&nbsp;     * count is 0, playback will continue to play to the end of the sequence.
<i>122</i>&nbsp;     * &lt;p&gt;
<i>123</i>&nbsp;     * The implementation ensures that the synthesizer is brought to a
<i>124</i>&nbsp;     * consistent state when jumping to the loop start point by sending
<i>125</i>&nbsp;     * appropriate controllers, pitch bend, and program change events.
<i>126</i>&nbsp;     *
<i>127</i>&nbsp;     * @throws IllegalStateException if the {@code Sequencer} is closed
<i>128</i>&nbsp;     * @see #setLoopStartPoint
<i>129</i>&nbsp;     * @see #setLoopEndPoint
<i>130</i>&nbsp;     * @see #setLoopCount
<i>131</i>&nbsp;     * @see #stop
<i>132</i>&nbsp;     */
<i>133</i>&nbsp;    void start();
<i>134</i>&nbsp;
<i>135</i>&nbsp;    /**
<i>136</i>&nbsp;     * Stops recording, if active, and playback of the currently loaded
<i>137</i>&nbsp;     * sequence, if any.
<i>138</i>&nbsp;     *
<i>139</i>&nbsp;     * @throws IllegalStateException if the {@code Sequencer} is closed
<i>140</i>&nbsp;     * @see #start
<i>141</i>&nbsp;     * @see #isRunning
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    void stop();
<i>144</i>&nbsp;
<i>145</i>&nbsp;    /**
<i>146</i>&nbsp;     * Indicates whether the Sequencer is currently running. The default is
<i>147</i>&nbsp;     * {@code false}. The Sequencer starts running when either{@link #start} or
<i>148</i>&nbsp;     * {@link #startRecording} is called. {@code isRunning} then returns
<i>149</i>&nbsp;     * {@code true} until playback of the sequence completes or {@link #stop} is
<i>150</i>&nbsp;     * called.
<i>151</i>&nbsp;     *
<i>152</i>&nbsp;     * @return {@code true} if the Sequencer is running, otherwise {@code false}
<i>153</i>&nbsp;     */
<i>154</i>&nbsp;    boolean isRunning();
<i>155</i>&nbsp;
<i>156</i>&nbsp;    /**
<i>157</i>&nbsp;     * Starts recording and playback of MIDI data. Data is recorded to all
<i>158</i>&nbsp;     * enabled tracks, on the channel(s) for which they were enabled. Recording
<i>159</i>&nbsp;     * begins at the current position of the sequencer. Any events already in
<i>160</i>&nbsp;     * the track are overwritten for the duration of the recording session.
<i>161</i>&nbsp;     * Events from the currently loaded sequence, if any, are delivered to the
<i>162</i>&nbsp;     * sequencer&#39;s transmitter(s) along with messages received during recording.
<i>163</i>&nbsp;     * &lt;p&gt;
<i>164</i>&nbsp;     * Note that tracks are not by default enabled for recording. In order to
<i>165</i>&nbsp;     * record MIDI data, at least one track must be specifically enabled for
<i>166</i>&nbsp;     * recording.
<i>167</i>&nbsp;     *
<i>168</i>&nbsp;     * @throws IllegalStateException if the {@code Sequencer} is closed
<i>169</i>&nbsp;     * @see #recordEnable
<i>170</i>&nbsp;     * @see #recordDisable
<i>171</i>&nbsp;     */
<i>172</i>&nbsp;    void startRecording();
<i>173</i>&nbsp;
<i>174</i>&nbsp;    /**
<i>175</i>&nbsp;     * Stops recording, if active. Playback of the current sequence continues.
<i>176</i>&nbsp;     *
<i>177</i>&nbsp;     * @throws IllegalStateException if the {@code Sequencer} is closed
<i>178</i>&nbsp;     * @see #startRecording
<i>179</i>&nbsp;     * @see #isRecording
<i>180</i>&nbsp;     */
<i>181</i>&nbsp;    void stopRecording();
<i>182</i>&nbsp;
<i>183</i>&nbsp;    /**
<i>184</i>&nbsp;     * Indicates whether the Sequencer is currently recording. The default is
<i>185</i>&nbsp;     * {@code false}. The Sequencer begins recording when
<i>186</i>&nbsp;     * {@link #startRecording} is called, and then returns {@code true} until
<i>187</i>&nbsp;     * {@link #stop} or {@link #stopRecording} is called.
<i>188</i>&nbsp;     *
<i>189</i>&nbsp;     * @return {@code true} if the Sequencer is recording, otherwise
<i>190</i>&nbsp;     *         {@code false}
<i>191</i>&nbsp;     */
<i>192</i>&nbsp;    boolean isRecording();
<i>193</i>&nbsp;
<i>194</i>&nbsp;    /**
<i>195</i>&nbsp;     * Prepares the specified track for recording events received on a
<i>196</i>&nbsp;     * particular channel. Once enabled, a track will receive events when
<i>197</i>&nbsp;     * recording is active.
<i>198</i>&nbsp;     *
<i>199</i>&nbsp;     * @param  track the track to which events will be recorded
<i>200</i>&nbsp;     * @param  channel the channel on which events will be received. If -1 is
<i>201</i>&nbsp;     *         specified for the channel value, the track will receive data from
<i>202</i>&nbsp;     *         all channels.
<i>203</i>&nbsp;     * @throws IllegalArgumentException thrown if the track is not part of the
<i>204</i>&nbsp;     *         current sequence
<i>205</i>&nbsp;     */
<i>206</i>&nbsp;    void recordEnable(Track track, int channel);
<i>207</i>&nbsp;
<i>208</i>&nbsp;    /**
<i>209</i>&nbsp;     * Disables recording to the specified track. Events will no longer be
<i>210</i>&nbsp;     * recorded into this track.
<i>211</i>&nbsp;     *
<i>212</i>&nbsp;     * @param  track the track to disable for recording, or {@code null} to
<i>213</i>&nbsp;     *         disable recording for all tracks
<i>214</i>&nbsp;     */
<i>215</i>&nbsp;    void recordDisable(Track track);
<i>216</i>&nbsp;
<i>217</i>&nbsp;    /**
<i>218</i>&nbsp;     * Obtains the current tempo, expressed in beats per minute. The actual
<i>219</i>&nbsp;     * tempo of playback is the product of the returned value and the tempo
<i>220</i>&nbsp;     * factor.
<i>221</i>&nbsp;     *
<i>222</i>&nbsp;     * @return the current tempo in beats per minute
<i>223</i>&nbsp;     * @see #getTempoFactor
<i>224</i>&nbsp;     * @see #setTempoInBPM(float)
<i>225</i>&nbsp;     * @see #getTempoInMPQ
<i>226</i>&nbsp;     */
<i>227</i>&nbsp;    float getTempoInBPM();
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Sets the tempo in beats per minute. The actual tempo of playback is the
<i>231</i>&nbsp;     * product of the specified value and the tempo factor.
<i>232</i>&nbsp;     *
<i>233</i>&nbsp;     * @param  bpm desired new tempo in beats per minute
<i>234</i>&nbsp;     * @see #getTempoFactor
<i>235</i>&nbsp;     * @see #setTempoInMPQ(float)
<i>236</i>&nbsp;     * @see #getTempoInBPM
<i>237</i>&nbsp;     */
<i>238</i>&nbsp;    void setTempoInBPM(float bpm);
<i>239</i>&nbsp;
<i>240</i>&nbsp;    /**
<i>241</i>&nbsp;     * Obtains the current tempo, expressed in microseconds per quarter note.
<i>242</i>&nbsp;     * The actual tempo of playback is the product of the returned value and the
<i>243</i>&nbsp;     * tempo factor.
<i>244</i>&nbsp;     *
<i>245</i>&nbsp;     * @return the current tempo in microseconds per quarter note
<i>246</i>&nbsp;     * @see #getTempoFactor
<i>247</i>&nbsp;     * @see #setTempoInMPQ(float)
<i>248</i>&nbsp;     * @see #getTempoInBPM
<i>249</i>&nbsp;     */
<i>250</i>&nbsp;    float getTempoInMPQ();
<i>251</i>&nbsp;
<i>252</i>&nbsp;    /**
<i>253</i>&nbsp;     * Sets the tempo in microseconds per quarter note. The actual tempo of
<i>254</i>&nbsp;     * playback is the product of the specified value and the tempo factor.
<i>255</i>&nbsp;     *
<i>256</i>&nbsp;     * @param  mpq desired new tempo in microseconds per quarter note
<i>257</i>&nbsp;     * @see #getTempoFactor
<i>258</i>&nbsp;     * @see #setTempoInBPM(float)
<i>259</i>&nbsp;     * @see #getTempoInMPQ
<i>260</i>&nbsp;     */
<i>261</i>&nbsp;    void setTempoInMPQ(float mpq);
<i>262</i>&nbsp;
<i>263</i>&nbsp;    /**
<i>264</i>&nbsp;     * Scales the sequencer&#39;s actual playback tempo by the factor provided. The
<i>265</i>&nbsp;     * default is 1.0. A value of 1.0 represents the natural rate (the tempo
<i>266</i>&nbsp;     * specified in the sequence), 2.0 means twice as fast, etc. The tempo
<i>267</i>&nbsp;     * factor does not affect the values returned by {@link #getTempoInMPQ} and
<i>268</i>&nbsp;     * {@link #getTempoInBPM}. Those values indicate the tempo prior to scaling.
<i>269</i>&nbsp;     * &lt;p&gt;
<i>270</i>&nbsp;     * Note that the tempo factor cannot be adjusted when external
<i>271</i>&nbsp;     * synchronization is used. In that situation, {@code setTempoFactor} always
<i>272</i>&nbsp;     * sets the tempo factor to 1.0.
<i>273</i>&nbsp;     *
<i>274</i>&nbsp;     * @param  factor the requested tempo scalar
<i>275</i>&nbsp;     * @see #getTempoFactor
<i>276</i>&nbsp;     */
<i>277</i>&nbsp;    void setTempoFactor(float factor);
<i>278</i>&nbsp;
<i>279</i>&nbsp;    /**
<i>280</i>&nbsp;     * Returns the current tempo factor for the sequencer. The default is 1.0.
<i>281</i>&nbsp;     *
<i>282</i>&nbsp;     * @return tempo factor
<i>283</i>&nbsp;     * @see #setTempoFactor(float)
<i>284</i>&nbsp;     */
<i>285</i>&nbsp;    float getTempoFactor();
<i>286</i>&nbsp;
<i>287</i>&nbsp;    /**
<i>288</i>&nbsp;     * Obtains the length of the current sequence, expressed in MIDI ticks, or 0
<i>289</i>&nbsp;     * if no sequence is set.
<i>290</i>&nbsp;     *
<i>291</i>&nbsp;     * @return length of the sequence in ticks
<i>292</i>&nbsp;     */
<i>293</i>&nbsp;    long getTickLength();
<i>294</i>&nbsp;
<i>295</i>&nbsp;    /**
<i>296</i>&nbsp;     * Obtains the current position in the sequence, expressed in MIDI ticks.
<i>297</i>&nbsp;     * (The duration of a tick in seconds is determined both by the tempo and by
<i>298</i>&nbsp;     * the timing resolution stored in the {@link Sequence}.)
<i>299</i>&nbsp;     *
<i>300</i>&nbsp;     * @return current tick
<i>301</i>&nbsp;     * @see #setTickPosition
<i>302</i>&nbsp;     */
<i>303</i>&nbsp;    long getTickPosition();
<i>304</i>&nbsp;
<i>305</i>&nbsp;    /**
<i>306</i>&nbsp;     * Sets the current sequencer position in MIDI ticks.
<i>307</i>&nbsp;     *
<i>308</i>&nbsp;     * @param  tick the desired tick position
<i>309</i>&nbsp;     * @see #getTickPosition
<i>310</i>&nbsp;     */
<i>311</i>&nbsp;    void setTickPosition(long tick);
<i>312</i>&nbsp;
<i>313</i>&nbsp;    /**
<i>314</i>&nbsp;     * Obtains the length of the current sequence, expressed in microseconds, or
<i>315</i>&nbsp;     * 0 if no sequence is set.
<i>316</i>&nbsp;     *
<i>317</i>&nbsp;     * @return length of the sequence in microseconds
<i>318</i>&nbsp;     */
<i>319</i>&nbsp;    long getMicrosecondLength();
<i>320</i>&nbsp;
<i>321</i>&nbsp;    /**
<i>322</i>&nbsp;     * Obtains the current position in the sequence, expressed in microseconds.
<i>323</i>&nbsp;     *
<i>324</i>&nbsp;     * @return the current position in microseconds
<i>325</i>&nbsp;     * @see #setMicrosecondPosition
<i>326</i>&nbsp;     */
<i>327</i>&nbsp;    @Override
<i>328</i>&nbsp;    long getMicrosecondPosition();
<i>329</i>&nbsp;
<i>330</i>&nbsp;    /**
<i>331</i>&nbsp;     * Sets the current position in the sequence, expressed in microseconds.
<i>332</i>&nbsp;     *
<i>333</i>&nbsp;     * @param  microseconds desired position in microseconds
<i>334</i>&nbsp;     * @see #getMicrosecondPosition
<i>335</i>&nbsp;     */
<i>336</i>&nbsp;    void setMicrosecondPosition(long microseconds);
<i>337</i>&nbsp;
<i>338</i>&nbsp;    /**
<i>339</i>&nbsp;     * Sets the source of timing information used by this sequencer. The
<i>340</i>&nbsp;     * sequencer synchronizes to the master, which is the internal clock, MIDI
<i>341</i>&nbsp;     * clock, or MIDI time code, depending on the value of {@code sync}. The
<i>342</i>&nbsp;     * {@code sync} argument must be one of the supported modes, as returned by
<i>343</i>&nbsp;     * {@link #getMasterSyncModes}.
<i>344</i>&nbsp;     *
<i>345</i>&nbsp;     * @param  sync the desired master synchronization mode
<i>346</i>&nbsp;     * @see SyncMode#INTERNAL_CLOCK
<i>347</i>&nbsp;     * @see SyncMode#MIDI_SYNC
<i>348</i>&nbsp;     * @see SyncMode#MIDI_TIME_CODE
<i>349</i>&nbsp;     * @see #getMasterSyncMode
<i>350</i>&nbsp;     */
<i>351</i>&nbsp;    void setMasterSyncMode(SyncMode sync);
<i>352</i>&nbsp;
<i>353</i>&nbsp;    /**
<i>354</i>&nbsp;     * Obtains the current master synchronization mode for this sequencer.
<i>355</i>&nbsp;     *
<i>356</i>&nbsp;     * @return the current master synchronization mode
<i>357</i>&nbsp;     * @see #setMasterSyncMode(SyncMode)
<i>358</i>&nbsp;     * @see #getMasterSyncModes
<i>359</i>&nbsp;     */
<i>360</i>&nbsp;    SyncMode getMasterSyncMode();
<i>361</i>&nbsp;
<i>362</i>&nbsp;    /**
<i>363</i>&nbsp;     * Obtains the set of master synchronization modes supported by this
<i>364</i>&nbsp;     * sequencer.
<i>365</i>&nbsp;     *
<i>366</i>&nbsp;     * @return the available master synchronization modes
<i>367</i>&nbsp;     * @see SyncMode#INTERNAL_CLOCK
<i>368</i>&nbsp;     * @see SyncMode#MIDI_SYNC
<i>369</i>&nbsp;     * @see SyncMode#MIDI_TIME_CODE
<i>370</i>&nbsp;     * @see #getMasterSyncMode
<i>371</i>&nbsp;     * @see #setMasterSyncMode(SyncMode)
<i>372</i>&nbsp;     */
<i>373</i>&nbsp;    SyncMode[] getMasterSyncModes();
<i>374</i>&nbsp;
<i>375</i>&nbsp;    /**
<i>376</i>&nbsp;     * Sets the slave synchronization mode for the sequencer. This indicates the
<i>377</i>&nbsp;     * type of timing information sent by the sequencer to its receiver. The
<i>378</i>&nbsp;     * {@code sync} argument must be one of the supported modes, as returned by
<i>379</i>&nbsp;     * {@link #getSlaveSyncModes}.
<i>380</i>&nbsp;     *
<i>381</i>&nbsp;     * @param  sync the desired slave synchronization mode
<i>382</i>&nbsp;     * @see SyncMode#MIDI_SYNC
<i>383</i>&nbsp;     * @see SyncMode#MIDI_TIME_CODE
<i>384</i>&nbsp;     * @see SyncMode#NO_SYNC
<i>385</i>&nbsp;     * @see #getSlaveSyncModes
<i>386</i>&nbsp;     */
<i>387</i>&nbsp;    void setSlaveSyncMode(SyncMode sync);
<i>388</i>&nbsp;
<i>389</i>&nbsp;    /**
<i>390</i>&nbsp;     * Obtains the current slave synchronization mode for this sequencer.
<i>391</i>&nbsp;     *
<i>392</i>&nbsp;     * @return the current slave synchronization mode
<i>393</i>&nbsp;     * @see #setSlaveSyncMode(SyncMode)
<i>394</i>&nbsp;     * @see #getSlaveSyncModes
<i>395</i>&nbsp;     */
<i>396</i>&nbsp;    SyncMode getSlaveSyncMode();
<i>397</i>&nbsp;
<i>398</i>&nbsp;    /**
<i>399</i>&nbsp;     * Obtains the set of slave synchronization modes supported by the
<i>400</i>&nbsp;     * sequencer.
<i>401</i>&nbsp;     *
<i>402</i>&nbsp;     * @return the available slave synchronization modes
<i>403</i>&nbsp;     * @see SyncMode#MIDI_SYNC
<i>404</i>&nbsp;     * @see SyncMode#MIDI_TIME_CODE
<i>405</i>&nbsp;     * @see SyncMode#NO_SYNC
<i>406</i>&nbsp;     */
<i>407</i>&nbsp;    SyncMode[] getSlaveSyncModes();
<i>408</i>&nbsp;
<i>409</i>&nbsp;    /**
<i>410</i>&nbsp;     * Sets the mute state for a track. This method may fail for a number of
<i>411</i>&nbsp;     * reasons. For example, the track number specified may not be valid for the
<i>412</i>&nbsp;     * current sequence, or the sequencer may not support this functionality. An
<i>413</i>&nbsp;     * application which needs to verify whether this operation succeeded should
<i>414</i>&nbsp;     * follow this call with a call to {@link #getTrackMute}.
<i>415</i>&nbsp;     *
<i>416</i>&nbsp;     * @param  track the track number. Tracks in the current sequence are
<i>417</i>&nbsp;     *         numbered from 0 to the number of tracks in the sequence minus 1.
<i>418</i>&nbsp;     * @param  mute the new mute state for the track. {@code true} implies the
<i>419</i>&nbsp;     *         track should be muted, {@code false} implies the track should be
<i>420</i>&nbsp;     *         unmuted.
<i>421</i>&nbsp;     * @see #getSequence
<i>422</i>&nbsp;     */
<i>423</i>&nbsp;    void setTrackMute(int track, boolean mute);
<i>424</i>&nbsp;
<i>425</i>&nbsp;    /**
<i>426</i>&nbsp;     * Obtains the current mute state for a track. The default mute state for
<i>427</i>&nbsp;     * all tracks which have not been muted is false. In any case where the
<i>428</i>&nbsp;     * specified track has not been muted, this method should return false. This
<i>429</i>&nbsp;     * applies if the sequencer does not support muting of tracks, and if the
<i>430</i>&nbsp;     * specified track index is not valid.
<i>431</i>&nbsp;     *
<i>432</i>&nbsp;     * @param  track the track number. Tracks in the current sequence are
<i>433</i>&nbsp;     *         numbered from 0 to the number of tracks in the sequence minus 1.
<i>434</i>&nbsp;     * @return {@code true} if muted, {@code false} if not
<i>435</i>&nbsp;     */
<i>436</i>&nbsp;    boolean getTrackMute(int track);
<i>437</i>&nbsp;
<i>438</i>&nbsp;    /**
<i>439</i>&nbsp;     * Sets the solo state for a track. If {@code solo} is {@code true} only
<i>440</i>&nbsp;     * this track and other solo&#39;d tracks will sound. If {@code solo} is
<i>441</i>&nbsp;     * {@code false} then only other solo&#39;d tracks will sound, unless no tracks
<i>442</i>&nbsp;     * are solo&#39;d in which case all un-muted tracks will sound.
<i>443</i>&nbsp;     * &lt;p&gt;
<i>444</i>&nbsp;     * This method may fail for a number of reasons. For example, the track
<i>445</i>&nbsp;     * number specified may not be valid for the current sequence, or the
<i>446</i>&nbsp;     * sequencer may not support this functionality. An application which needs
<i>447</i>&nbsp;     * to verify whether this operation succeeded should follow this call with a
<i>448</i>&nbsp;     * call to {@link #getTrackSolo}.
<i>449</i>&nbsp;     *
<i>450</i>&nbsp;     * @param  track the track number. Tracks in the current sequence are
<i>451</i>&nbsp;     *         numbered from 0 to the number of tracks in the sequence minus 1.
<i>452</i>&nbsp;     * @param  solo the new solo state for the track. {@code true} implies the
<i>453</i>&nbsp;     *         track should be solo&#39;d, {@code false} implies the track should
<i>454</i>&nbsp;     *         not be solo&#39;d.
<i>455</i>&nbsp;     * @see #getSequence
<i>456</i>&nbsp;     */
<i>457</i>&nbsp;    void setTrackSolo(int track, boolean solo);
<i>458</i>&nbsp;
<i>459</i>&nbsp;    /**
<i>460</i>&nbsp;     * Obtains the current solo state for a track. The default mute state for
<i>461</i>&nbsp;     * all tracks which have not been solo&#39;d is false. In any case where the
<i>462</i>&nbsp;     * specified track has not been solo&#39;d, this method should return false.
<i>463</i>&nbsp;     * This applies if the sequencer does not support soloing of tracks, and if
<i>464</i>&nbsp;     * the specified track index is not valid.
<i>465</i>&nbsp;     *
<i>466</i>&nbsp;     * @param  track the track number. Tracks in the current sequence are
<i>467</i>&nbsp;     *         numbered from 0 to the number of tracks in the sequence minus 1.
<i>468</i>&nbsp;     * @return {@code true} if solo&#39;d, {@code false} if not
<i>469</i>&nbsp;     */
<i>470</i>&nbsp;    boolean getTrackSolo(int track);
<i>471</i>&nbsp;
<i>472</i>&nbsp;    /**
<i>473</i>&nbsp;     * Registers a meta-event listener to receive notification whenever a
<i>474</i>&nbsp;     * meta-event is encountered in the sequence and processed by the sequencer.
<i>475</i>&nbsp;     * This method can fail if, for instance,this class of sequencer does not
<i>476</i>&nbsp;     * support meta-event notification.
<i>477</i>&nbsp;     *
<i>478</i>&nbsp;     * @param  listener listener to add
<i>479</i>&nbsp;     * @return {@code true} if the listener was successfully added, otherwise
<i>480</i>&nbsp;     *         {@code false}
<i>481</i>&nbsp;     * @see #removeMetaEventListener
<i>482</i>&nbsp;     * @see MetaEventListener
<i>483</i>&nbsp;     * @see MetaMessage
<i>484</i>&nbsp;     */
<i>485</i>&nbsp;    boolean addMetaEventListener(MetaEventListener listener);
<i>486</i>&nbsp;
<i>487</i>&nbsp;    /**
<i>488</i>&nbsp;     * Removes the specified meta-event listener from this sequencer&#39;s list of
<i>489</i>&nbsp;     * registered listeners, if in fact the listener is registered.
<i>490</i>&nbsp;     *
<i>491</i>&nbsp;     * @param  listener the meta-event listener to remove
<i>492</i>&nbsp;     * @see #addMetaEventListener
<i>493</i>&nbsp;     */
<i>494</i>&nbsp;    void removeMetaEventListener(MetaEventListener listener);
<i>495</i>&nbsp;
<i>496</i>&nbsp;    /**
<i>497</i>&nbsp;     * Registers a controller event listener to receive notification whenever
<i>498</i>&nbsp;     * the sequencer processes a control-change event of the requested type or
<i>499</i>&nbsp;     * types. The types are specified by the {@code controllers} argument, which
<i>500</i>&nbsp;     * should contain an array of MIDI controller numbers. (Each number should
<i>501</i>&nbsp;     * be between 0 and 127, inclusive. See the MIDI 1.0 Specification for the
<i>502</i>&nbsp;     * numbers that correspond to various types of controllers.)
<i>503</i>&nbsp;     * &lt;p&gt;
<i>504</i>&nbsp;     * The returned array contains the MIDI controller numbers for which the
<i>505</i>&nbsp;     * listener will now receive events. Some sequencers might not support
<i>506</i>&nbsp;     * controller event notification, in which case the array has a length of 0.
<i>507</i>&nbsp;     * Other sequencers might support notification for some controllers but not
<i>508</i>&nbsp;     * all. This method may be invoked repeatedly. Each time, the returned array
<i>509</i>&nbsp;     * indicates all the controllers that the listener will be notified about,
<i>510</i>&nbsp;     * not only the controllers requested in that particular invocation.
<i>511</i>&nbsp;     *
<i>512</i>&nbsp;     * @param  listener the controller event listener to add to the list of
<i>513</i>&nbsp;     *         registered listeners
<i>514</i>&nbsp;     * @param  controllers the MIDI controller numbers for which change
<i>515</i>&nbsp;     *         notification is requested
<i>516</i>&nbsp;     * @return the numbers of all the MIDI controllers whose changes will now be
<i>517</i>&nbsp;     *         reported to the specified listener
<i>518</i>&nbsp;     * @see #removeControllerEventListener
<i>519</i>&nbsp;     * @see ControllerEventListener
<i>520</i>&nbsp;     */
<i>521</i>&nbsp;    int[] addControllerEventListener(ControllerEventListener listener,
<i>522</i>&nbsp;                                     int[] controllers);
<i>523</i>&nbsp;
<i>524</i>&nbsp;    /**
<i>525</i>&nbsp;     * Removes a controller event listener&#39;s interest in one or more types of
<i>526</i>&nbsp;     * controller event. The {@code controllers} argument is an array of MIDI
<i>527</i>&nbsp;     * numbers corresponding to the controllers for which the listener should no
<i>528</i>&nbsp;     * longer receive change notifications. To completely remove this listener
<i>529</i>&nbsp;     * from the list of registered listeners, pass in {@code null} for
<i>530</i>&nbsp;     * {@code controllers}. The returned array contains the MIDI controller
<i>531</i>&nbsp;     * numbers for which the listener will now receive events. The array has a
<i>532</i>&nbsp;     * length of 0 if the listener will not receive change notifications for any
<i>533</i>&nbsp;     * controllers.
<i>534</i>&nbsp;     *
<i>535</i>&nbsp;     * @param  listener old listener
<i>536</i>&nbsp;     * @param  controllers the MIDI controller numbers for which change
<i>537</i>&nbsp;     *         notification should be cancelled, or {@code null} to cancel for
<i>538</i>&nbsp;     *         all controllers
<i>539</i>&nbsp;     * @return the numbers of all the MIDI controllers whose changes will now be
<i>540</i>&nbsp;     *         reported to the specified listener
<i>541</i>&nbsp;     * @see #addControllerEventListener
<i>542</i>&nbsp;     */
<i>543</i>&nbsp;    int[] removeControllerEventListener(ControllerEventListener listener,
<i>544</i>&nbsp;                                        int[] controllers);
<i>545</i>&nbsp;
<i>546</i>&nbsp;    /**
<i>547</i>&nbsp;     * Sets the first MIDI tick that will be played in the loop. If the loop
<i>548</i>&nbsp;     * count is greater than 0, playback will jump to this point when reaching
<i>549</i>&nbsp;     * the loop end point.
<i>550</i>&nbsp;     * &lt;p&gt;
<i>551</i>&nbsp;     * A value of 0 for the starting point means the beginning of the loaded
<i>552</i>&nbsp;     * sequence. The starting point must be lower than or equal to the ending
<i>553</i>&nbsp;     * point, and it must fall within the size of the loaded sequence.
<i>554</i>&nbsp;     * &lt;p&gt;
<i>555</i>&nbsp;     * A sequencer&#39;s loop start point defaults to start of the sequence.
<i>556</i>&nbsp;     *
<i>557</i>&nbsp;     * @param  tick the loop&#39;s starting position, in MIDI ticks (zero-based)
<i>558</i>&nbsp;     * @throws IllegalArgumentException if the requested loop start point cannot
<i>559</i>&nbsp;     *         be set, usually because it falls outside the sequence&#39;s duration
<i>560</i>&nbsp;     *         or because the start point is after the end point
<i>561</i>&nbsp;     * @see #setLoopEndPoint
<i>562</i>&nbsp;     * @see #setLoopCount
<i>563</i>&nbsp;     * @see #getLoopStartPoint
<i>564</i>&nbsp;     * @see #start
<i>565</i>&nbsp;     * @since 1.5
<i>566</i>&nbsp;     */
<i>567</i>&nbsp;    void setLoopStartPoint(long tick);
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /**
<i>570</i>&nbsp;     * Obtains the start position of the loop, in MIDI ticks.
<i>571</i>&nbsp;     *
<i>572</i>&nbsp;     * @return the start position of the loop, in MIDI ticks (zero-based)
<i>573</i>&nbsp;     * @see #setLoopStartPoint
<i>574</i>&nbsp;     * @since 1.5
<i>575</i>&nbsp;     */
<i>576</i>&nbsp;    long getLoopStartPoint();
<i>577</i>&nbsp;
<i>578</i>&nbsp;    /**
<i>579</i>&nbsp;     * Sets the last MIDI tick that will be played in the loop. If the loop
<i>580</i>&nbsp;     * count is 0, the loop end point has no effect and playback continues to
<i>581</i>&nbsp;     * play when reaching the loop end point.
<i>582</i>&nbsp;     * &lt;p&gt;
<i>583</i>&nbsp;     * A value of -1 for the ending point indicates the last tick of the
<i>584</i>&nbsp;     * sequence. Otherwise, the ending point must be greater than or equal to
<i>585</i>&nbsp;     * the starting point, and it must fall within the size of the loaded
<i>586</i>&nbsp;     * sequence.
<i>587</i>&nbsp;     * &lt;p&gt;
<i>588</i>&nbsp;     * A sequencer&#39;s loop end point defaults to -1, meaning the end of the
<i>589</i>&nbsp;     * sequence.
<i>590</i>&nbsp;     *
<i>591</i>&nbsp;     * @param  tick the loop&#39;s ending position, in MIDI ticks (zero-based), or
<i>592</i>&nbsp;     *         -1 to indicate the final tick
<i>593</i>&nbsp;     * @throws IllegalArgumentException if the requested loop point cannot be
<i>594</i>&nbsp;     *         set, usually because it falls outside the sequence&#39;s duration or
<i>595</i>&nbsp;     *         because the ending point is before the starting point
<i>596</i>&nbsp;     * @see #setLoopStartPoint
<i>597</i>&nbsp;     * @see #setLoopCount
<i>598</i>&nbsp;     * @see #getLoopEndPoint
<i>599</i>&nbsp;     * @see #start
<i>600</i>&nbsp;     * @since 1.5
<i>601</i>&nbsp;     */
<i>602</i>&nbsp;    void setLoopEndPoint(long tick);
<i>603</i>&nbsp;
<i>604</i>&nbsp;    /**
<i>605</i>&nbsp;     * Obtains the end position of the loop, in MIDI ticks.
<i>606</i>&nbsp;     *
<i>607</i>&nbsp;     * @return the end position of the loop, in MIDI ticks (zero-based), or -1
<i>608</i>&nbsp;     *         to indicate the end of the sequence
<i>609</i>&nbsp;     * @see #setLoopEndPoint
<i>610</i>&nbsp;     * @since 1.5
<i>611</i>&nbsp;     */
<i>612</i>&nbsp;    long getLoopEndPoint();
<i>613</i>&nbsp;
<i>614</i>&nbsp;    /**
<i>615</i>&nbsp;     * Sets the number of repetitions of the loop for playback. When the
<i>616</i>&nbsp;     * playback position reaches the loop end point, it will loop back to the
<i>617</i>&nbsp;     * loop start point {@code count} times, after which playback will continue
<i>618</i>&nbsp;     * to play to the end of the sequence.
<i>619</i>&nbsp;     * &lt;p&gt;
<i>620</i>&nbsp;     * If the current position when this method is invoked is greater than the
<i>621</i>&nbsp;     * loop end point, playback continues to the end of the sequence without
<i>622</i>&nbsp;     * looping, unless the loop end point is changed subsequently.
<i>623</i>&nbsp;     * &lt;p&gt;
<i>624</i>&nbsp;     * A {@code count} value of 0 disables looping: playback will continue at
<i>625</i>&nbsp;     * the loop end point, and it will not loop back to the loop start point.
<i>626</i>&nbsp;     * This is a sequencer&#39;s default.
<i>627</i>&nbsp;     * &lt;p&gt;
<i>628</i>&nbsp;     * If playback is stopped during looping, the current loop status is
<i>629</i>&nbsp;     * cleared; subsequent start requests are not affected by an interrupted
<i>630</i>&nbsp;     * loop operation.
<i>631</i>&nbsp;     *
<i>632</i>&nbsp;     * @param  count the number of times playback should loop back from the
<i>633</i>&nbsp;     *         loop&#39;s end position to the loop&#39;s start position, or
<i>634</i>&nbsp;     *         {@link #LOOP_CONTINUOUSLY} to indicate that looping should
<i>635</i>&nbsp;     *         continue until interrupted
<i>636</i>&nbsp;     * @throws IllegalArgumentException if {@code count} is negative and not
<i>637</i>&nbsp;     *         equal to {@link #LOOP_CONTINUOUSLY}
<i>638</i>&nbsp;     * @see #setLoopStartPoint
<i>639</i>&nbsp;     * @see #setLoopEndPoint
<i>640</i>&nbsp;     * @see #getLoopCount
<i>641</i>&nbsp;     * @see #start
<i>642</i>&nbsp;     * @since 1.5
<i>643</i>&nbsp;     */
<i>644</i>&nbsp;    void setLoopCount(int count);
<i>645</i>&nbsp;
<i>646</i>&nbsp;    /**
<i>647</i>&nbsp;     * Obtains the number of repetitions for playback.
<i>648</i>&nbsp;     *
<i>649</i>&nbsp;     * @return the number of loops after which playback plays to the end of the
<i>650</i>&nbsp;     *         sequence
<i>651</i>&nbsp;     * @see #setLoopCount
<i>652</i>&nbsp;     * @see #start
<i>653</i>&nbsp;     * @since 1.5
<i>654</i>&nbsp;     */
<i>655</i>&nbsp;    int getLoopCount();
<i>656</i>&nbsp;
<i>657</i>&nbsp;    /**
<i>658</i>&nbsp;     * A {@code SyncMode} object represents one of the ways in which a MIDI
<i>659</i>&nbsp;     * sequencer&#39;s notion of time can be synchronized with a master or slave
<i>660</i>&nbsp;     * device. If the sequencer is being synchronized to a master, the sequencer
<i>661</i>&nbsp;     * revises its current time in response to messages from the master. If the
<i>662</i>&nbsp;     * sequencer has a slave, the sequencer similarly sends messages to control
<i>663</i>&nbsp;     * the slave&#39;s timing.
<i>664</i>&nbsp;     * &lt;p&gt;
<i>665</i>&nbsp;     * There are three predefined modes that specify possible masters for a
<i>666</i>&nbsp;     * sequencer: {@code INTERNAL_CLOCK}, {@code MIDI_SYNC}, and
<i>667</i>&nbsp;     * {@code MIDI_TIME_CODE}. The latter two work if the sequencer receives
<i>668</i>&nbsp;     * MIDI messages from another device. In these two modes, the sequencer&#39;s
<i>669</i>&nbsp;     * time gets reset based on system real-time timing clock messages or MIDI
<i>670</i>&nbsp;     * time code (MTC) messages, respectively. These two modes can also be used
<i>671</i>&nbsp;     * as slave modes, in which case the sequencer sends the corresponding types
<i>672</i>&nbsp;     * of MIDI messages to its receiver (whether or not the sequencer is also
<i>673</i>&nbsp;     * receiving them from a master). A fourth mode, {@code NO_SYNC}, is used to
<i>674</i>&nbsp;     * indicate that the sequencer should not control its receiver&#39;s timing.
<i>675</i>&nbsp;     *
<i>676</i>&nbsp;     * @see Sequencer#setMasterSyncMode(SyncMode)
<i>677</i>&nbsp;     * @see Sequencer#setSlaveSyncMode(SyncMode)
<i>678</i>&nbsp;     */
<i>679</i>&nbsp;    class SyncMode {
<i>680</i>&nbsp;
<i>681</i>&nbsp;        /**
<i>682</i>&nbsp;         * Synchronization mode name.
<i>683</i>&nbsp;         */
<i>684</i>&nbsp;        private final String name;
<i>685</i>&nbsp;
<i>686</i>&nbsp;        /**
<i>687</i>&nbsp;         * Constructs a synchronization mode.
<i>688</i>&nbsp;         *
<i>689</i>&nbsp;         * @param  name name of the synchronization mode
<i>690</i>&nbsp;         */
<i>691</i>&nbsp;        protected SyncMode(String name) {
<i>692</i>&nbsp;
<i>693</i>&nbsp;            this.name = name;
<i>694</i>&nbsp;        }
<i>695</i>&nbsp;
<i>696</i>&nbsp;        /**
<i>697</i>&nbsp;         * Indicates whether the specified object is equal to this
<i>698</i>&nbsp;         * synchronization mode, returning {@code true} if the objects are the
<i>699</i>&nbsp;         * same.
<i>700</i>&nbsp;         *
<i>701</i>&nbsp;         * @param  obj the reference object with which to compare
<i>702</i>&nbsp;         * @return {@code true} if the specified object is equal to this
<i>703</i>&nbsp;         *         synchronization mode; {@code false} otherwise
<i>704</i>&nbsp;         */
<i>705</i>&nbsp;        @Override
<i>706</i>&nbsp;        public final boolean equals(Object obj) {
<i>707</i>&nbsp;
<i>708</i>&nbsp;            return super.equals(obj);
<i>709</i>&nbsp;        }
<i>710</i>&nbsp;
<i>711</i>&nbsp;        /**
<i>712</i>&nbsp;         * Returns a hash code value for this synchronization mode.
<i>713</i>&nbsp;         *
<i>714</i>&nbsp;         * @return a hash code value for this synchronization mode
<i>715</i>&nbsp;         */
<i>716</i>&nbsp;        @Override
<i>717</i>&nbsp;        public final int hashCode() {
<i>718</i>&nbsp;
<i>719</i>&nbsp;            return super.hashCode();
<i>720</i>&nbsp;        }
<i>721</i>&nbsp;
<i>722</i>&nbsp;        /**
<i>723</i>&nbsp;         * Provides this synchronization mode&#39;s name as the string
<i>724</i>&nbsp;         * representation of the mode.
<i>725</i>&nbsp;         *
<i>726</i>&nbsp;         * @return the name of this synchronization mode
<i>727</i>&nbsp;         */
<i>728</i>&nbsp;        @Override
<i>729</i>&nbsp;        public final String toString() {
<i>730</i>&nbsp;
<i>731</i>&nbsp;            return name;
<i>732</i>&nbsp;        }
<i>733</i>&nbsp;
<i>734</i>&nbsp;        /**
<i>735</i>&nbsp;         * A master synchronization mode that makes the sequencer get its timing
<i>736</i>&nbsp;         * information from its internal clock. This is not a legal slave sync
<i>737</i>&nbsp;         * mode.
<i>738</i>&nbsp;         */
<i>739</i>&nbsp;        public static final SyncMode INTERNAL_CLOCK = new SyncMode(&quot;Internal Clock&quot;);
<i>740</i>&nbsp;
<i>741</i>&nbsp;        /**
<i>742</i>&nbsp;         * A master or slave synchronization mode that specifies the use of MIDI
<i>743</i>&nbsp;         * clock messages. If this mode is used as the master sync mode, the
<i>744</i>&nbsp;         * sequencer gets its timing information from system real-time MIDI
<i>745</i>&nbsp;         * clock messages. This mode only applies as the master sync mode for
<i>746</i>&nbsp;         * sequencers that are also MIDI receivers. If this is the slave sync
<i>747</i>&nbsp;         * mode, the sequencer sends system real-time MIDI clock messages to its
<i>748</i>&nbsp;         * receiver. MIDI clock messages are sent at a rate of 24 per quarter
<i>749</i>&nbsp;         * note.
<i>750</i>&nbsp;         */
<i>751</i>&nbsp;        public static final SyncMode MIDI_SYNC = new SyncMode(&quot;MIDI Sync&quot;);
<i>752</i>&nbsp;
<i>753</i>&nbsp;        /**
<i>754</i>&nbsp;         * A master or slave synchronization mode that specifies the use of MIDI
<i>755</i>&nbsp;         * Time Code. If this mode is used as the master sync mode, the
<i>756</i>&nbsp;         * sequencer gets its timing information from MIDI Time Code messages.
<i>757</i>&nbsp;         * This mode only applies as the master sync mode to sequencers that are
<i>758</i>&nbsp;         * also MIDI receivers. If this mode is used as the slave sync mode, the
<i>759</i>&nbsp;         * sequencer sends MIDI Time Code messages to its receiver. (See the
<i>760</i>&nbsp;         * MIDI 1.0 Detailed Specification for a description of MIDI Time Code.)
<i>761</i>&nbsp;         */
<i>762</i>&nbsp;        public static final SyncMode MIDI_TIME_CODE = new SyncMode(&quot;MIDI Time Code&quot;);
<i>763</i>&nbsp;
<i>764</i>&nbsp;        /**
<i>765</i>&nbsp;         * A slave synchronization mode indicating that no timing information
<i>766</i>&nbsp;         * should be sent to the receiver. This is not a legal master sync mode.
<i>767</i>&nbsp;         */
<i>768</i>&nbsp;        public static final SyncMode NO_SYNC = new SyncMode(&quot;No Timing&quot;);
<i>769</i>&nbsp;
<i>770</i>&nbsp;    }
<i>771</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
