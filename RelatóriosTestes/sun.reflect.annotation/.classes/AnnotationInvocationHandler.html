


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: AnnotationInvocationHandler</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">sun.reflect.annotation</a> ]
</div>

<h1>Coverage Summary for Class: AnnotationInvocationHandler (sun.reflect.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationInvocationHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 216)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationInvocationHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationInvocationHandler$UnsafeAccessor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 232)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2003, 2016, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package sun.reflect.annotation;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import java.io.ObjectInputStream;
<i>29</i>&nbsp;import java.lang.annotation.*;
<i>30</i>&nbsp;import java.lang.reflect.*;
<i>31</i>&nbsp;import java.io.Serializable;
<i>32</i>&nbsp;import java.util.*;
<i>33</i>&nbsp;import java.util.stream.*;
<i>34</i>&nbsp;import java.security.AccessController;
<i>35</i>&nbsp;import java.security.PrivilegedAction;
<i>36</i>&nbsp;
<i>37</i>&nbsp;/**
<i>38</i>&nbsp; * InvocationHandler for dynamic proxy implementation of Annotation.
<i>39</i>&nbsp; *
<i>40</i>&nbsp; * @author  Josh Bloch
<i>41</i>&nbsp; * @since   1.5
<b class="nc"><i>42</i>&nbsp; */</b>
<i>43</i>&nbsp;class AnnotationInvocationHandler implements InvocationHandler, Serializable {
<i>44</i>&nbsp;    private static final long serialVersionUID = 6182022883658399397L;
<i>45</i>&nbsp;    private final Class&lt;? extends Annotation&gt; type;
<i>46</i>&nbsp;    private final Map&lt;String, Object&gt; memberValues;
<b class="nc"><i>47</i>&nbsp;</b>
<b class="nc"><i>48</i>&nbsp;    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) {</b>
<b class="nc"><i>49</i>&nbsp;        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</b>
<i>50</i>&nbsp;        if (!type.isAnnotation() ||
<i>51</i>&nbsp;            superInterfaces.length != 1 ||
<b class="nc"><i>52</i>&nbsp;            superInterfaces[0] != java.lang.annotation.Annotation.class)</b>
<b class="nc"><i>53</i>&nbsp;            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</b>
<b class="nc"><i>54</i>&nbsp;        this.type = type;</b>
<i>55</i>&nbsp;        this.memberValues = memberValues;
<i>56</i>&nbsp;    }
<i>57</i>&nbsp;
<b class="nc"><i>58</i>&nbsp;    public Object invoke(Object proxy, Method method, Object[] args) {</b>
<b class="nc"><i>59</i>&nbsp;        String member = method.getName();</b>
<i>60</i>&nbsp;        int parameterCount = method.getParameterCount();
<i>61</i>&nbsp;
<b class="nc"><i>62</i>&nbsp;        // Handle Object and Annotation methods</b>
<i>63</i>&nbsp;        if (parameterCount == 1 &amp;&amp; member == &quot;equals&quot; &amp;&amp;
<b class="nc"><i>64</i>&nbsp;                method.getParameterTypes()[0] == Object.class) {</b>
<b class="nc"><i>65</i>&nbsp;            return equalsImpl(proxy, args[0]);</b>
<b class="nc"><i>66</i>&nbsp;        }</b>
<i>67</i>&nbsp;        if (parameterCount != 0) {
<b class="nc"><i>68</i>&nbsp;            throw new AssertionError(&quot;Too many parameters for an annotation method&quot;);</b>
<i>69</i>&nbsp;        }
<b class="nc"><i>70</i>&nbsp;</b>
<i>71</i>&nbsp;        if (member == &quot;toString&quot;) {
<b class="nc"><i>72</i>&nbsp;            return toStringImpl();</b>
<i>73</i>&nbsp;        } else if (member == &quot;hashCode&quot;) {
<b class="nc"><i>74</i>&nbsp;            return hashCodeImpl();</b>
<i>75</i>&nbsp;        } else if (member == &quot;annotationType&quot;) {
<i>76</i>&nbsp;            return type;
<i>77</i>&nbsp;        }
<b class="nc"><i>78</i>&nbsp;</b>
<i>79</i>&nbsp;        // Handle annotation member accessors
<b class="nc"><i>80</i>&nbsp;        Object result = memberValues.get(member);</b>
<b class="nc"><i>81</i>&nbsp;</b>
<i>82</i>&nbsp;        if (result == null)
<b class="nc"><i>83</i>&nbsp;            throw new IncompleteAnnotationException(type, member);</b>
<b class="nc"><i>84</i>&nbsp;</b>
<i>85</i>&nbsp;        if (result instanceof ExceptionProxy)
<b class="nc"><i>86</i>&nbsp;            throw ((ExceptionProxy) result).generateException();</b>
<b class="nc"><i>87</i>&nbsp;</b>
<i>88</i>&nbsp;        if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0)
<b class="nc"><i>89</i>&nbsp;            result = cloneArray(result);</b>
<i>90</i>&nbsp;
<i>91</i>&nbsp;        return result;
<i>92</i>&nbsp;    }
<i>93</i>&nbsp;
<i>94</i>&nbsp;    /**
<i>95</i>&nbsp;     * This method, which clones its array argument, would not be necessary
<i>96</i>&nbsp;     * if Cloneable had a public clone method.
<b class="nc"><i>97</i>&nbsp;     */</b>
<i>98</i>&nbsp;    private Object cloneArray(Object array) {
<b class="nc"><i>99</i>&nbsp;        Class&lt;?&gt; type = array.getClass();</b>
<b class="nc"><i>100</i>&nbsp;</b>
<b class="nc"><i>101</i>&nbsp;        if (type == byte[].class) {</b>
<i>102</i>&nbsp;            byte[] byteArray = (byte[])array;
<b class="nc"><i>103</i>&nbsp;            return byteArray.clone();</b>
<b class="nc"><i>104</i>&nbsp;        }</b>
<b class="nc"><i>105</i>&nbsp;        if (type == char[].class) {</b>
<i>106</i>&nbsp;            char[] charArray = (char[])array;
<b class="nc"><i>107</i>&nbsp;            return charArray.clone();</b>
<b class="nc"><i>108</i>&nbsp;        }</b>
<b class="nc"><i>109</i>&nbsp;        if (type == double[].class) {</b>
<i>110</i>&nbsp;            double[] doubleArray = (double[])array;
<b class="nc"><i>111</i>&nbsp;            return doubleArray.clone();</b>
<b class="nc"><i>112</i>&nbsp;        }</b>
<b class="nc"><i>113</i>&nbsp;        if (type == float[].class) {</b>
<i>114</i>&nbsp;            float[] floatArray = (float[])array;
<b class="nc"><i>115</i>&nbsp;            return floatArray.clone();</b>
<b class="nc"><i>116</i>&nbsp;        }</b>
<b class="nc"><i>117</i>&nbsp;        if (type == int[].class) {</b>
<i>118</i>&nbsp;            int[] intArray = (int[])array;
<b class="nc"><i>119</i>&nbsp;            return intArray.clone();</b>
<b class="nc"><i>120</i>&nbsp;        }</b>
<b class="nc"><i>121</i>&nbsp;        if (type == long[].class) {</b>
<i>122</i>&nbsp;            long[] longArray = (long[])array;
<b class="nc"><i>123</i>&nbsp;            return longArray.clone();</b>
<b class="nc"><i>124</i>&nbsp;        }</b>
<b class="nc"><i>125</i>&nbsp;        if (type == short[].class) {</b>
<i>126</i>&nbsp;            short[] shortArray = (short[])array;
<b class="nc"><i>127</i>&nbsp;            return shortArray.clone();</b>
<b class="nc"><i>128</i>&nbsp;        }</b>
<b class="nc"><i>129</i>&nbsp;        if (type == boolean[].class) {</b>
<i>130</i>&nbsp;            boolean[] booleanArray = (boolean[])array;
<i>131</i>&nbsp;            return booleanArray.clone();
<b class="nc"><i>132</i>&nbsp;        }</b>
<b class="nc"><i>133</i>&nbsp;</b>
<i>134</i>&nbsp;        Object[] objectArray = (Object[])array;
<i>135</i>&nbsp;        return objectArray.clone();
<i>136</i>&nbsp;    }
<i>137</i>&nbsp;
<i>138</i>&nbsp;
<i>139</i>&nbsp;    /**
<i>140</i>&nbsp;     * Implementation of dynamicProxy.toString()
<b class="nc"><i>141</i>&nbsp;     */</b>
<b class="nc"><i>142</i>&nbsp;    private String toStringImpl() {</b>
<b class="nc"><i>143</i>&nbsp;        StringBuilder result = new StringBuilder(128);</b>
<b class="nc"><i>144</i>&nbsp;        result.append(&#39;@&#39;);</b>
<b class="nc"><i>145</i>&nbsp;        result.append(type.getName());</b>
<b class="nc"><i>146</i>&nbsp;        result.append(&#39;(&#39;);</b>
<b class="nc"><i>147</i>&nbsp;        boolean firstMember = true;</b>
<b class="nc"><i>148</i>&nbsp;        for (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) {</b>
<i>149</i>&nbsp;            if (firstMember)
<b class="nc"><i>150</i>&nbsp;                firstMember = false;</b>
<i>151</i>&nbsp;            else
<b class="nc"><i>152</i>&nbsp;                result.append(&quot;, &quot;);</b>
<b class="nc"><i>153</i>&nbsp;</b>
<b class="nc"><i>154</i>&nbsp;            result.append(e.getKey());</b>
<b class="nc"><i>155</i>&nbsp;            result.append(&#39;=&#39;);</b>
<b class="nc"><i>156</i>&nbsp;            result.append(memberValueToString(e.getValue()));</b>
<b class="nc"><i>157</i>&nbsp;        }</b>
<i>158</i>&nbsp;        result.append(&#39;)&#39;);
<i>159</i>&nbsp;        return result.toString();
<i>160</i>&nbsp;    }
<i>161</i>&nbsp;
<i>162</i>&nbsp;    /**
<i>163</i>&nbsp;     * Translates a member value (in &quot;dynamic proxy return form&quot;) into a string.
<b class="nc"><i>164</i>&nbsp;     */</b>
<b class="nc"><i>165</i>&nbsp;    private static String memberValueToString(Object value) {</b>
<i>166</i>&nbsp;        Class&lt;?&gt; type = value.getClass();
<b class="nc"><i>167</i>&nbsp;        if (!type.isArray()) {</b>
<i>168</i>&nbsp;            // primitive value, string, class, enum const, or annotation
<b class="nc"><i>169</i>&nbsp;            if (type == Class.class)</b>
<b class="nc"><i>170</i>&nbsp;                return toSourceString((Class&lt;?&gt;) value);</b>
<b class="nc"><i>171</i>&nbsp;            else if (type == String.class)</b>
<b class="nc"><i>172</i>&nbsp;                return  toSourceString((String) value);</b>
<b class="nc"><i>173</i>&nbsp;            if (type == Character.class)</b>
<b class="nc"><i>174</i>&nbsp;                return toSourceString((char) value);</b>
<b class="nc"><i>175</i>&nbsp;            else if (type == Double.class)</b>
<b class="nc"><i>176</i>&nbsp;                return  toSourceString((double) value);</b>
<b class="nc"><i>177</i>&nbsp;            else if (type == Float.class)</b>
<b class="nc"><i>178</i>&nbsp;                return  toSourceString((float) value);</b>
<b class="nc"><i>179</i>&nbsp;            else if (type == Long.class)</b>
<b class="nc"><i>180</i>&nbsp;                return  toSourceString((long) value);</b>
<b class="nc"><i>181</i>&nbsp;            else</b>
<b class="nc"><i>182</i>&nbsp;                return value.toString();</b>
<b class="nc"><i>183</i>&nbsp;        } else {</b>
<b class="nc"><i>184</i>&nbsp;            Stream&lt;String&gt; stringStream;</b>
<b class="nc"><i>185</i>&nbsp;            if (type == byte[].class)</b>
<i>186</i>&nbsp;                stringStream = convert((byte[]) value);
<i>187</i>&nbsp;            else if (type == char[].class)
<i>188</i>&nbsp;                stringStream = convert((char[]) value);
<i>189</i>&nbsp;            else if (type == double[].class)
<i>190</i>&nbsp;                stringStream = DoubleStream.of((double[]) value)
<i>191</i>&nbsp;                    .mapToObj(AnnotationInvocationHandler::toSourceString);
<b class="nc"><i>192</i>&nbsp;            else if (type == float[].class)</b>
<b class="nc"><i>193</i>&nbsp;                stringStream = convert((float[]) value);</b>
<i>194</i>&nbsp;            else if (type == int[].class)
<b class="nc"><i>195</i>&nbsp;                stringStream = IntStream.of((int[]) value).mapToObj(String::valueOf);</b>
<b class="nc"><i>196</i>&nbsp;            else if (type == long[].class) {</b>
<b class="nc"><i>197</i>&nbsp;                stringStream = LongStream.of((long[]) value)</b>
<b class="nc"><i>198</i>&nbsp;                    .mapToObj(AnnotationInvocationHandler::toSourceString);</b>
<b class="nc"><i>199</i>&nbsp;            } else if (type == short[].class)</b>
<b class="nc"><i>200</i>&nbsp;                stringStream = convert((short[]) value);</b>
<b class="nc"><i>201</i>&nbsp;            else if (type == boolean[].class)</b>
<b class="nc"><i>202</i>&nbsp;                stringStream = convert((boolean[]) value);</b>
<b class="nc"><i>203</i>&nbsp;            else if (type == Class[].class)</b>
<i>204</i>&nbsp;                stringStream =
<i>205</i>&nbsp;                    Arrays.stream((Class&lt;?&gt;[]) value).
<b class="nc"><i>206</i>&nbsp;                    map(AnnotationInvocationHandler::toSourceString);</b>
<b class="nc"><i>207</i>&nbsp;            else if (type == String[].class)</b>
<b class="nc"><i>208</i>&nbsp;                stringStream =</b>
<b class="nc"><i>209</i>&nbsp;                    Arrays.stream((String[])value).</b>
<b class="nc"><i>210</i>&nbsp;                    map(AnnotationInvocationHandler::toSourceString);</b>
<b class="nc"><i>211</i>&nbsp;            else</b>
<i>212</i>&nbsp;                stringStream = Arrays.stream((Object[])value).map(Objects::toString);
<b class="nc"><i>213</i>&nbsp;</b>
<b class="nc"><i>214</i>&nbsp;            return stringStreamToString(stringStream);</b>
<i>215</i>&nbsp;        }
<b class="nc"><i>216</i>&nbsp;    }</b>
<i>217</i>&nbsp;
<i>218</i>&nbsp;    /**
<i>219</i>&nbsp;     * Translates a Class value to a form suitable for use in the
<i>220</i>&nbsp;     * string representation of an annotation.
<i>221</i>&nbsp;     */
<i>222</i>&nbsp;    private static String toSourceString(Class&lt;?&gt; clazz) {
<i>223</i>&nbsp;        Class&lt;?&gt; finalComponent = clazz;
<i>224</i>&nbsp;        StringBuilder arrayBackets = new StringBuilder();
<b class="nc"><i>225</i>&nbsp;</b>
<b class="nc"><i>226</i>&nbsp;        while(finalComponent.isArray()) {</b>
<b class="nc"><i>227</i>&nbsp;            finalComponent = finalComponent.getComponentType();</b>
<b class="nc"><i>228</i>&nbsp;            arrayBackets.append(&quot;[]&quot;);</b>
<i>229</i>&nbsp;        }
<b class="nc"><i>230</i>&nbsp;</b>
<i>231</i>&nbsp;        return finalComponent.getName() + arrayBackets.toString() + &quot;.class&quot; ;
<i>232</i>&nbsp;    }
<i>233</i>&nbsp;
<i>234</i>&nbsp;    private static String toSourceString(float f) {
<i>235</i>&nbsp;        if (Float.isFinite(f))
<i>236</i>&nbsp;            return Float.toString(f) + &quot;f&quot; ;
<i>237</i>&nbsp;        else {
<i>238</i>&nbsp;            if (Float.isInfinite(f)) {
<i>239</i>&nbsp;                return (f &lt; 0.0f) ? &quot;-1.0f/0.0f&quot;: &quot;1.0f/0.0f&quot;;
<i>240</i>&nbsp;            } else
<i>241</i>&nbsp;                return &quot;0.0f/0.0f&quot;;
<b class="nc"><i>242</i>&nbsp;        }</b>
<i>243</i>&nbsp;    }
<i>244</i>&nbsp;
<i>245</i>&nbsp;    private static String toSourceString(double d) {
<b class="nc"><i>246</i>&nbsp;        if (Double.isFinite(d))</b>
<b class="nc"><i>247</i>&nbsp;            return Double.toString(d);</b>
<i>248</i>&nbsp;        else {
<i>249</i>&nbsp;            if (Double.isInfinite(d)) {
<i>250</i>&nbsp;                return (d &lt; 0.0f) ? &quot;-1.0/0.0&quot;: &quot;1.0/0.0&quot;;
<b class="nc"><i>251</i>&nbsp;            } else</b>
<b class="nc"><i>252</i>&nbsp;                return &quot;0.0/0.0&quot;;</b>
<i>253</i>&nbsp;        }
<i>254</i>&nbsp;    }
<b class="nc"><i>255</i>&nbsp;</b>
<b class="nc"><i>256</i>&nbsp;    private static String toSourceString(char c) {</b>
<i>257</i>&nbsp;        StringBuilder sb = new StringBuilder(4);
<i>258</i>&nbsp;        sb.append(&#39;\&#39;&#39;);
<b class="nc"><i>259</i>&nbsp;        if (c == &#39;\&#39;&#39;)</b>
<b class="nc"><i>260</i>&nbsp;            sb.append(&quot;\\&#39;&quot;);</b>
<b class="nc"><i>261</i>&nbsp;        else</b>
<b class="nc"><i>262</i>&nbsp;            sb.append(c);</b>
<b class="nc"><i>263</i>&nbsp;        return sb.append(&#39;\&#39;&#39;)</b>
<b class="nc"><i>264</i>&nbsp;                .toString();</b>
<b class="nc"><i>265</i>&nbsp;    }</b>
<b class="nc"><i>266</i>&nbsp;</b>
<b class="nc"><i>267</i>&nbsp;    private static String toSourceString(long ell) {</b>
<b class="nc"><i>268</i>&nbsp;        String str = String.valueOf(ell);</b>
<b class="nc"><i>269</i>&nbsp;        return (ell &lt; Integer.MIN_VALUE || ell &gt; Integer.MAX_VALUE)</b>
<b class="nc"><i>270</i>&nbsp;                ? (str + &#39;L&#39;) : str;</b>
<b class="nc"><i>271</i>&nbsp;    }</b>
<b class="nc"><i>272</i>&nbsp;</b>
<b class="nc"><i>273</i>&nbsp;    /**</b>
<b class="nc"><i>274</i>&nbsp;     * Return a string suitable for use in the string representation</b>
<i>275</i>&nbsp;     * of an annotation.
<i>276</i>&nbsp;     */
<i>277</i>&nbsp;    private static String toSourceString(String s) {
<i>278</i>&nbsp;        StringBuilder sb = new StringBuilder();
<i>279</i>&nbsp;        sb.append(&#39;&quot;&#39;);
<i>280</i>&nbsp;        // Escape embedded quote characters, if present, but don&#39;t do
<i>281</i>&nbsp;        // anything more heroic.
<i>282</i>&nbsp;        sb.append(s.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;));
<i>283</i>&nbsp;        sb.append(&#39;&quot;&#39;);
<b class="nc"><i>284</i>&nbsp;        return sb.toString();</b>
<b class="nc"><i>285</i>&nbsp;    }</b>
<b class="nc"><i>286</i>&nbsp;</b>
<i>287</i>&nbsp;    private static Stream&lt;String&gt; convert(byte[] values) {
<b class="nc"><i>288</i>&nbsp;        List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);</b>
<b class="nc"><i>289</i>&nbsp;        for (byte b : values)</b>
<b class="nc"><i>290</i>&nbsp;            list.add(Byte.toString(b));</b>
<b class="nc"><i>291</i>&nbsp;        return list.stream();</b>
<i>292</i>&nbsp;    }
<i>293</i>&nbsp;
<i>294</i>&nbsp;    private static Stream&lt;String&gt; convert(char[] values) {
<b class="nc"><i>295</i>&nbsp;        List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);</b>
<i>296</i>&nbsp;        for (char c : values)
<b class="nc"><i>297</i>&nbsp;            list.add(toSourceString(c));</b>
<i>298</i>&nbsp;        return list.stream();
<i>299</i>&nbsp;    }
<i>300</i>&nbsp;
<i>301</i>&nbsp;    private static Stream&lt;String&gt; convert(float[] values) {
<i>302</i>&nbsp;        List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
<i>303</i>&nbsp;        for (float f : values) {
<i>304</i>&nbsp;            list.add(toSourceString(f));
<i>305</i>&nbsp;        }
<i>306</i>&nbsp;        return list.stream();
<i>307</i>&nbsp;    }
<i>308</i>&nbsp;
<i>309</i>&nbsp;    private static Stream&lt;String&gt; convert(short[] values) {
<i>310</i>&nbsp;        List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
<b class="nc"><i>311</i>&nbsp;        for (short s : values)</b>
<b class="nc"><i>312</i>&nbsp;            list.add(Short.toString(s));</b>
<i>313</i>&nbsp;        return list.stream();
<i>314</i>&nbsp;    }
<i>315</i>&nbsp;
<i>316</i>&nbsp;    private static Stream&lt;String&gt; convert(boolean[] values) {
<i>317</i>&nbsp;        List&lt;String&gt; list = new ArrayList&lt;&gt;(values.length);
<i>318</i>&nbsp;        for (boolean b : values)
<i>319</i>&nbsp;            list.add(Boolean.toString(b));
<i>320</i>&nbsp;        return list.stream();
<i>321</i>&nbsp;    }
<i>322</i>&nbsp;
<b class="nc"><i>323</i>&nbsp;    private static String stringStreamToString(Stream&lt;String&gt; stream) {</b>
<b class="nc"><i>324</i>&nbsp;        return stream.collect(Collectors.joining(&quot;, &quot;, &quot;{&quot;, &quot;}&quot;));</b>
<b class="nc"><i>325</i>&nbsp;    }</b>
<b class="nc"><i>326</i>&nbsp;</b>
<b class="nc"><i>327</i>&nbsp;    /**</b>
<b class="nc"><i>328</i>&nbsp;     * Implementation of dynamicProxy.equals(Object o)</b>
<i>329</i>&nbsp;     */
<i>330</i>&nbsp;    private Boolean equalsImpl(Object proxy, Object o) {
<i>331</i>&nbsp;        if (o == proxy)
<i>332</i>&nbsp;            return true;
<i>333</i>&nbsp;
<i>334</i>&nbsp;        if (!type.isInstance(o))
<i>335</i>&nbsp;            return false;
<i>336</i>&nbsp;        for (Method memberMethod : getMemberMethods()) {
<i>337</i>&nbsp;            String member = memberMethod.getName();
<i>338</i>&nbsp;            Object ourValue = memberValues.get(member);
<i>339</i>&nbsp;            Object hisValue = null;
<b class="nc"><i>340</i>&nbsp;            AnnotationInvocationHandler hisHandler = asOneOfUs(o);</b>
<b class="nc"><i>341</i>&nbsp;            if (hisHandler != null) {</b>
<b class="nc"><i>342</i>&nbsp;                hisValue = hisHandler.memberValues.get(member);</b>
<b class="nc"><i>343</i>&nbsp;            } else {</b>
<b class="nc"><i>344</i>&nbsp;                try {</b>
<b class="nc"><i>345</i>&nbsp;                    hisValue = memberMethod.invoke(o);</b>
<i>346</i>&nbsp;                } catch (InvocationTargetException e) {
<i>347</i>&nbsp;                    return false;
<i>348</i>&nbsp;                } catch (IllegalAccessException e) {
<b class="nc"><i>349</i>&nbsp;                    throw new AssertionError(e);</b>
<i>350</i>&nbsp;                }
<i>351</i>&nbsp;            }
<b class="nc"><i>352</i>&nbsp;            if (!memberValueEquals(ourValue, hisValue))</b>
<b class="nc"><i>353</i>&nbsp;                return false;</b>
<b class="nc"><i>354</i>&nbsp;        }</b>
<b class="nc"><i>355</i>&nbsp;        return true;</b>
<i>356</i>&nbsp;    }
<i>357</i>&nbsp;
<i>358</i>&nbsp;    /**
<i>359</i>&nbsp;     * Returns an object&#39;s invocation handler if that object is a dynamic
<i>360</i>&nbsp;     * proxy with a handler of type AnnotationInvocationHandler.
<i>361</i>&nbsp;     * Returns null otherwise.
<i>362</i>&nbsp;     */
<i>363</i>&nbsp;    private AnnotationInvocationHandler asOneOfUs(Object o) {
<i>364</i>&nbsp;        if (Proxy.isProxyClass(o.getClass())) {
<i>365</i>&nbsp;            InvocationHandler handler = Proxy.getInvocationHandler(o);
<i>366</i>&nbsp;            if (handler instanceof AnnotationInvocationHandler)
<i>367</i>&nbsp;                return (AnnotationInvocationHandler) handler;
<i>368</i>&nbsp;        }
<i>369</i>&nbsp;        return null;
<i>370</i>&nbsp;    }
<i>371</i>&nbsp;
<i>372</i>&nbsp;    /**
<b class="nc"><i>373</i>&nbsp;     * Returns true iff the two member values in &quot;dynamic proxy return form&quot;</b>
<b class="nc"><i>374</i>&nbsp;     * are equal using the appropriate equality function depending on the</b>
<b class="nc"><i>375</i>&nbsp;     * member type.  The two values will be of the same type unless one of</b>
<b class="nc"><i>376</i>&nbsp;     * the containing annotations is ill-formed.  If one of the containing</b>
<b class="nc"><i>377</i>&nbsp;     * annotations is ill-formed, this method will return false unless the</b>
<b class="nc"><i>378</i>&nbsp;     * two members are identical object references.</b>
<i>379</i>&nbsp;     */
<i>380</i>&nbsp;    private static boolean memberValueEquals(Object v1, Object v2) {
<b class="nc"><i>381</i>&nbsp;        Class&lt;?&gt; type = v1.getClass();</b>
<i>382</i>&nbsp;
<i>383</i>&nbsp;        // Check for primitive, string, class, enum const, annotation,
<b class="nc"><i>384</i>&nbsp;        // or ExceptionProxy</b>
<i>385</i>&nbsp;        if (!type.isArray())
<i>386</i>&nbsp;            return v1.equals(v2);
<i>387</i>&nbsp;
<i>388</i>&nbsp;        // Check for array of string, class, enum const, annotation,
<i>389</i>&nbsp;        // or ExceptionProxy
<i>390</i>&nbsp;        if (v1 instanceof Object[] &amp;&amp; v2 instanceof Object[])
<b class="nc"><i>391</i>&nbsp;            return Arrays.equals((Object[]) v1, (Object[]) v2);</b>
<b class="nc"><i>392</i>&nbsp;</b>
<b class="nc"><i>393</i>&nbsp;        // Check for ill formed annotation(s)</b>
<b class="nc"><i>394</i>&nbsp;        if (v2.getClass() != type)</b>
<b class="nc"><i>395</i>&nbsp;            return false;</b>
<b class="nc"><i>396</i>&nbsp;</b>
<i>397</i>&nbsp;        // Deal with array of primitives
<i>398</i>&nbsp;        if (type == byte[].class)
<i>399</i>&nbsp;            return Arrays.equals((byte[]) v1, (byte[]) v2);
<i>400</i>&nbsp;        if (type == char[].class)
<i>401</i>&nbsp;            return Arrays.equals((char[]) v1, (char[]) v2);
<i>402</i>&nbsp;        if (type == double[].class)
<b class="nc"><i>403</i>&nbsp;            return Arrays.equals((double[]) v1, (double[]) v2);</b>
<b class="nc"><i>404</i>&nbsp;        if (type == float[].class)</b>
<i>405</i>&nbsp;            return Arrays.equals((float[]) v1, (float[]) v2);
<b class="nc"><i>406</i>&nbsp;        if (type == int[].class)</b>
<i>407</i>&nbsp;            return Arrays.equals((int[]) v1, (int[]) v2);
<b class="nc"><i>408</i>&nbsp;        if (type == long[].class)</b>
<b class="nc"><i>409</i>&nbsp;            return Arrays.equals((long[]) v1, (long[]) v2);</b>
<b class="nc"><i>410</i>&nbsp;        if (type == short[].class)</b>
<b class="nc"><i>411</i>&nbsp;            return Arrays.equals((short[]) v1, (short[]) v2);</b>
<b class="nc"><i>412</i>&nbsp;        assert type == boolean[].class;</b>
<b class="nc"><i>413</i>&nbsp;        return Arrays.equals((boolean[]) v1, (boolean[]) v2);</b>
<b class="nc"><i>414</i>&nbsp;    }</b>
<b class="nc"><i>415</i>&nbsp;</b>
<b class="nc"><i>416</i>&nbsp;    /**</b>
<b class="nc"><i>417</i>&nbsp;     * Returns the member methods for our annotation type.  These are</b>
<b class="nc"><i>418</i>&nbsp;     * obtained lazily and cached, as they&#39;re expensive to obtain</b>
<b class="nc"><i>419</i>&nbsp;     * and we only need them if our equals method is invoked (which should</b>
<b class="nc"><i>420</i>&nbsp;     * be rare).</b>
<b class="nc"><i>421</i>&nbsp;     */</b>
<b class="nc"><i>422</i>&nbsp;    private Method[] getMemberMethods() {</b>
<b class="nc"><i>423</i>&nbsp;        Method[] value = memberMethods;</b>
<b class="nc"><i>424</i>&nbsp;        if (value == null) {</b>
<i>425</i>&nbsp;            value = computeMemberMethods();
<i>426</i>&nbsp;            memberMethods = value;
<i>427</i>&nbsp;        }
<i>428</i>&nbsp;        return value;
<b class="nc"><i>429</i>&nbsp;    }</b>
<i>430</i>&nbsp;
<i>431</i>&nbsp;    private Method[] computeMemberMethods() {
<b class="nc"><i>432</i>&nbsp;        return AccessController.doPrivileged(</b>
<i>433</i>&nbsp;            new PrivilegedAction&lt;Method[]&gt;() {
<b class="nc"><i>434</i>&nbsp;                public Method[] run() {</b>
<i>435</i>&nbsp;                    final Method[] methods = type.getDeclaredMethods();
<i>436</i>&nbsp;                    validateAnnotationMethods(methods);
<i>437</i>&nbsp;                    AccessibleObject.setAccessible(methods, true);
<b class="nc"><i>438</i>&nbsp;                    return methods;</b>
<i>439</i>&nbsp;                }});
<b class="nc"><i>440</i>&nbsp;    }</b>
<b class="nc"><i>441</i>&nbsp;</b>
<i>442</i>&nbsp;    private transient volatile Method[] memberMethods;
<b class="nc"><i>443</i>&nbsp;</b>
<b class="nc"><i>444</i>&nbsp;    /**</b>
<i>445</i>&nbsp;     * Validates that a method is structurally appropriate for an
<b class="nc"><i>446</i>&nbsp;     * annotation type. As of Java SE 8, annotation types cannot</b>
<i>447</i>&nbsp;     * contain static methods and the declared methods of an
<b class="nc"><i>448</i>&nbsp;     * annotation type must take zero arguments and there are</b>
<i>449</i>&nbsp;     * restrictions on the return type.
<i>450</i>&nbsp;     */
<i>451</i>&nbsp;    private void validateAnnotationMethods(Method[] memberMethods) {
<b class="nc"><i>452</i>&nbsp;        /*</b>
<b class="nc"><i>453</i>&nbsp;         * Specification citations below are from JLS</b>
<b class="nc"><i>454</i>&nbsp;         * 9.6.1. Annotation Type Elements</b>
<b class="nc"><i>455</i>&nbsp;         */</b>
<b class="nc"><i>456</i>&nbsp;        boolean valid = true;</b>
<b class="nc"><i>457</i>&nbsp;        for(Method method : memberMethods) {</b>
<b class="nc"><i>458</i>&nbsp;            /*</b>
<i>459</i>&nbsp;             * &quot;By virtue of the AnnotationTypeElementDeclaration
<b class="nc"><i>460</i>&nbsp;             * production, a method declaration in an annotation type</b>
<b class="nc"><i>461</i>&nbsp;             * declaration cannot have formal parameters, type</b>
<b class="nc"><i>462</i>&nbsp;             * parameters, or a throws clause.</b>
<i>463</i>&nbsp;             *
<i>464</i>&nbsp;             * &quot;By virtue of the AnnotationTypeElementModifier
<b class="nc"><i>465</i>&nbsp;             * production, a method declaration in an annotation type</b>
<b class="nc"><i>466</i>&nbsp;             * declaration cannot be default or static.&quot;</b>
<i>467</i>&nbsp;             */
<b class="nc"><i>468</i>&nbsp;            if (method.getModifiers() != (Modifier.PUBLIC | Modifier.ABSTRACT) ||</b>
<b class="nc"><i>469</i>&nbsp;                method.isDefault() ||</b>
<i>470</i>&nbsp;                method.getParameterCount() != 0 ||
<i>471</i>&nbsp;                method.getExceptionTypes().length != 0) {
<b class="nc"><i>472</i>&nbsp;                valid = false;</b>
<i>473</i>&nbsp;                break;
<i>474</i>&nbsp;            }
<i>475</i>&nbsp;
<i>476</i>&nbsp;            /*
<i>477</i>&nbsp;             * &quot;It is a compile-time error if the return type of a
<b class="nc"><i>478</i>&nbsp;             * method declared in an annotation type is not one of the</b>
<b class="nc"><i>479</i>&nbsp;             * following: a primitive type, String, Class, any</b>
<b class="nc"><i>480</i>&nbsp;             * parameterized invocation of Class, an enum type</b>
<b class="nc"><i>481</i>&nbsp;             * (section 8.9), an annotation type, or an array type</b>
<b class="nc"><i>482</i>&nbsp;             * (chapter 10) whose element type is one of the preceding</b>
<b class="nc"><i>483</i>&nbsp;             * types.&quot;</b>
<b class="nc"><i>484</i>&nbsp;             */</b>
<b class="nc"><i>485</i>&nbsp;            Class&lt;?&gt; returnType = method.getReturnType();</b>
<i>486</i>&nbsp;            if (returnType.isArray()) {
<i>487</i>&nbsp;                returnType = returnType.getComponentType();
<i>488</i>&nbsp;                if (returnType.isArray()) { // Only single dimensional arrays
<b class="nc"><i>489</i>&nbsp;                    valid = false;</b>
<i>490</i>&nbsp;                    break;
<i>491</i>&nbsp;                }
<i>492</i>&nbsp;            }
<i>493</i>&nbsp;
<b class="nc"><i>494</i>&nbsp;            if (!((returnType.isPrimitive() &amp;&amp; returnType != void.class) ||</b>
<i>495</i>&nbsp;                  returnType == java.lang.String.class ||
<i>496</i>&nbsp;                  returnType == java.lang.Class.class ||
<i>497</i>&nbsp;                  returnType.isEnum() ||
<i>498</i>&nbsp;                  returnType.isAnnotation())) {
<i>499</i>&nbsp;                valid = false;
<i>500</i>&nbsp;                break;
<i>501</i>&nbsp;            }
<i>502</i>&nbsp;
<i>503</i>&nbsp;            /*
<i>504</i>&nbsp;             * &quot;It is a compile-time error if any method declared in an
<i>505</i>&nbsp;             * annotation type has a signature that is
<i>506</i>&nbsp;             * override-equivalent to that of any public or protected
<i>507</i>&nbsp;             * method declared in class Object or in the interface
<i>508</i>&nbsp;             * java.lang.annotation.Annotation.&quot;
<i>509</i>&nbsp;             *
<i>510</i>&nbsp;             * The methods in Object or Annotation meeting the other
<i>511</i>&nbsp;             * criteria (no arguments, contrained return type, etc.)
<i>512</i>&nbsp;             * above are:
<i>513</i>&nbsp;             *
<i>514</i>&nbsp;             * String toString()
<i>515</i>&nbsp;             * int hashCode()
<i>516</i>&nbsp;             * Class&lt;? extends Annotation&gt; annotationType()
<i>517</i>&nbsp;             */
<i>518</i>&nbsp;            String methodName = method.getName();
<i>519</i>&nbsp;            if ((methodName.equals(&quot;toString&quot;) &amp;&amp; returnType == java.lang.String.class) ||
<i>520</i>&nbsp;                (methodName.equals(&quot;hashCode&quot;) &amp;&amp; returnType == int.class) ||
<i>521</i>&nbsp;                (methodName.equals(&quot;annotationType&quot;) &amp;&amp; returnType == java.lang.Class.class)) {
<i>522</i>&nbsp;                valid = false;
<i>523</i>&nbsp;                break;
<i>524</i>&nbsp;            }
<i>525</i>&nbsp;        }
<i>526</i>&nbsp;        if (valid)
<i>527</i>&nbsp;            return;
<i>528</i>&nbsp;        else
<i>529</i>&nbsp;            throw new AnnotationFormatError(&quot;Malformed method on an annotation type&quot;);
<i>530</i>&nbsp;    }
<i>531</i>&nbsp;
<i>532</i>&nbsp;    /**
<i>533</i>&nbsp;     * Implementation of dynamicProxy.hashCode()
<i>534</i>&nbsp;     */
<i>535</i>&nbsp;    private int hashCodeImpl() {
<i>536</i>&nbsp;        int result = 0;
<i>537</i>&nbsp;        for (Map.Entry&lt;String, Object&gt; e : memberValues.entrySet()) {
<i>538</i>&nbsp;            result += (127 * e.getKey().hashCode()) ^
<i>539</i>&nbsp;                memberValueHashCode(e.getValue());
<i>540</i>&nbsp;        }
<i>541</i>&nbsp;        return result;
<i>542</i>&nbsp;    }
<i>543</i>&nbsp;
<i>544</i>&nbsp;    /**
<i>545</i>&nbsp;     * Computes hashCode of a member value (in &quot;dynamic proxy return form&quot;)
<i>546</i>&nbsp;     */
<i>547</i>&nbsp;    private static int memberValueHashCode(Object value) {
<i>548</i>&nbsp;        Class&lt;?&gt; type = value.getClass();
<i>549</i>&nbsp;        if (!type.isArray())    // primitive, string, class, enum const,
<i>550</i>&nbsp;                                // or annotation
<i>551</i>&nbsp;            return value.hashCode();
<i>552</i>&nbsp;
<i>553</i>&nbsp;        if (type == byte[].class)
<i>554</i>&nbsp;            return Arrays.hashCode((byte[]) value);
<i>555</i>&nbsp;        if (type == char[].class)
<i>556</i>&nbsp;            return Arrays.hashCode((char[]) value);
<i>557</i>&nbsp;        if (type == double[].class)
<i>558</i>&nbsp;            return Arrays.hashCode((double[]) value);
<i>559</i>&nbsp;        if (type == float[].class)
<i>560</i>&nbsp;            return Arrays.hashCode((float[]) value);
<i>561</i>&nbsp;        if (type == int[].class)
<i>562</i>&nbsp;            return Arrays.hashCode((int[]) value);
<i>563</i>&nbsp;        if (type == long[].class)
<i>564</i>&nbsp;            return Arrays.hashCode((long[]) value);
<i>565</i>&nbsp;        if (type == short[].class)
<i>566</i>&nbsp;            return Arrays.hashCode((short[]) value);
<i>567</i>&nbsp;        if (type == boolean[].class)
<i>568</i>&nbsp;            return Arrays.hashCode((boolean[]) value);
<i>569</i>&nbsp;        return Arrays.hashCode((Object[]) value);
<i>570</i>&nbsp;    }
<i>571</i>&nbsp;
<i>572</i>&nbsp;    private void readObject(java.io.ObjectInputStream s)
<i>573</i>&nbsp;        throws java.io.IOException, ClassNotFoundException {
<i>574</i>&nbsp;        ObjectInputStream.GetField fields = s.readFields();
<i>575</i>&nbsp;
<i>576</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>577</i>&nbsp;        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);
<i>578</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<i>579</i>&nbsp;        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);
<i>580</i>&nbsp;
<i>581</i>&nbsp;        // Check to make sure that types have not evolved incompatibly
<i>582</i>&nbsp;
<i>583</i>&nbsp;        AnnotationType annotationType = null;
<i>584</i>&nbsp;        try {
<i>585</i>&nbsp;            annotationType = AnnotationType.getInstance(t);
<i>586</i>&nbsp;        } catch(IllegalArgumentException e) {
<i>587</i>&nbsp;            // Class is no longer an annotation type; time to punch out
<i>588</i>&nbsp;            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
<i>589</i>&nbsp;        }
<i>590</i>&nbsp;
<i>591</i>&nbsp;        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();
<i>592</i>&nbsp;        // consistent with runtime Map type
<i>593</i>&nbsp;        Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();
<i>594</i>&nbsp;
<i>595</i>&nbsp;        // If there are annotation members without values, that
<i>596</i>&nbsp;        // situation is handled by the invoke method.
<i>597</i>&nbsp;        for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) {
<i>598</i>&nbsp;            String name = memberValue.getKey();
<i>599</i>&nbsp;            Object value = null;
<i>600</i>&nbsp;            Class&lt;?&gt; memberType = memberTypes.get(name);
<i>601</i>&nbsp;            if (memberType != null) {  // i.e. member still exists
<i>602</i>&nbsp;                value = memberValue.getValue();
<i>603</i>&nbsp;                if (!(memberType.isInstance(value) ||
<i>604</i>&nbsp;                      value instanceof ExceptionProxy)) {
<i>605</i>&nbsp;                    value = new AnnotationTypeMismatchExceptionProxy(
<i>606</i>&nbsp;                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(
<i>607</i>&nbsp;                                annotationType.members().get(name));
<i>608</i>&nbsp;                }
<i>609</i>&nbsp;            }
<i>610</i>&nbsp;            mv.put(name, value);
<i>611</i>&nbsp;        }
<i>612</i>&nbsp;
<i>613</i>&nbsp;        UnsafeAccessor.setType(this, t);
<i>614</i>&nbsp;        UnsafeAccessor.setMemberValues(this, mv);
<i>615</i>&nbsp;    }
<i>616</i>&nbsp;
<i>617</i>&nbsp;    private static class UnsafeAccessor {
<i>618</i>&nbsp;        private static final jdk.internal.misc.Unsafe unsafe
<i>619</i>&nbsp;                = jdk.internal.misc.Unsafe.getUnsafe();
<i>620</i>&nbsp;        private static final long typeOffset = unsafe.objectFieldOffset
<i>621</i>&nbsp;                (AnnotationInvocationHandler.class, &quot;type&quot;);
<i>622</i>&nbsp;        private static final long memberValuesOffset = unsafe.objectFieldOffset
<i>623</i>&nbsp;                (AnnotationInvocationHandler.class, &quot;memberValues&quot;);
<i>624</i>&nbsp;
<i>625</i>&nbsp;        static void setType(AnnotationInvocationHandler o,
<i>626</i>&nbsp;                            Class&lt;? extends Annotation&gt; type) {
<i>627</i>&nbsp;            unsafe.putObject(o, typeOffset, type);
<i>628</i>&nbsp;        }
<i>629</i>&nbsp;
<i>630</i>&nbsp;        static void setMemberValues(AnnotationInvocationHandler o,
<i>631</i>&nbsp;                                    Map&lt;String, Object&gt; memberValues) {
<i>632</i>&nbsp;            unsafe.putObject(o, memberValuesOffset, memberValues);
<i>633</i>&nbsp;        }
<i>634</i>&nbsp;    }
<i>635</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
