


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: XPathParser</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">com.sun.org.apache.xalan.internal.xsltc.compiler</a> ]
</div>

<h1>Coverage Summary for Class: XPathParser (com.sun.org.apache.xalan.internal.xsltc.compiler)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">XPathParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 98)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;package com.sun.org.apache.xalan.internal.xsltc.compiler;
<i>27</i>&nbsp;
<i>28</i>&nbsp;import com.sun.java_cup.internal.runtime.*;
<i>29</i>&nbsp;import com.sun.org.apache.xalan.internal.xsltc.DOM;
<b class="nc"><i>30</i>&nbsp;import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;</b>
<b class="nc"><i>31</i>&nbsp;import com.sun.org.apache.xalan.internal.xsltc.runtime.Operators;</b>
<i>32</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.Axis;
<i>33</i>&nbsp;import com.sun.org.apache.xml.internal.dtm.DTM;
<i>34</i>&nbsp;import java.util.ArrayList;
<i>35</i>&nbsp;import java.util.List;
<i>36</i>&nbsp;import java.util.Stack;
<i>37</i>&nbsp;
<i>38</i>&nbsp;/**
<i>39</i>&nbsp; * CUP v0.10j generated parser.
<i>40</i>&nbsp; * This class was generated by CUP v0.10j on Thu Oct 06 10:09:26 PDT 2005.
<i>41</i>&nbsp; */
<i>42</i>&nbsp;public class XPathParser extends lr_parser {
<i>43</i>&nbsp;
<i>44</i>&nbsp;  /** Default constructor. */
<i>45</i>&nbsp;  public XPathParser() {super();}
<i>46</i>&nbsp;
<i>47</i>&nbsp;  /** Constructor which sets the default scanner. */
<i>48</i>&nbsp;  public XPathParser(Scanner s) {super(s);}
<i>49</i>&nbsp;
<i>50</i>&nbsp;  /** Production table. */
<i>51</i>&nbsp;  protected static final short _production_table[][] =
<i>52</i>&nbsp;    unpackFromStrings(new String[] {
<i>53</i>&nbsp;    &quot;\000\215\000\002\002\004\000\002\003\004\000\002\003&quot; +
<i>54</i>&nbsp;    &quot;\004\000\002\036\003\000\002\036\005\000\002\037\003&quot; +
<i>55</i>&nbsp;    &quot;\000\002\037\004\000\002\037\003\000\002\037\005\000&quot; +
<i>56</i>&nbsp;    &quot;\002\037\005\000\002\037\004\000\002\037\003\000\002&quot; +
<i>57</i>&nbsp;    &quot;\035\006\000\002\035\010\000\002\040\006\000\002\041&quot; +
<i>58</i>&nbsp;    &quot;\003\000\002\041\005\000\002\041\005\000\002\042\003&quot; +
<i>59</i>&nbsp;    &quot;\000\002\042\004\000\002\042\003\000\002\042\004\000&quot; +
<i>60</i>&nbsp;    &quot;\002\042\004\000\002\042\005\000\002\042\004\000\002&quot; +
<i>61</i>&nbsp;    &quot;\042\005\000\002\043\003\000\002\043\003\000\002\043&quot; +
<i>62</i>&nbsp;    &quot;\003\000\002\043\003\000\002\043\003\000\002\044\003&quot; +
<i>63</i>&nbsp;    &quot;\000\002\044\003\000\002\054\003\000\002\054\004\000&quot; +
<i>64</i>&nbsp;    &quot;\002\054\004\000\002\045\003\000\002\045\004\000\002&quot; +
<i>65</i>&nbsp;    &quot;\007\005\000\002\004\003\000\002\012\003\000\002\012&quot; +
<i>66</i>&nbsp;    &quot;\005\000\002\013\003\000\002\013\005\000\002\014\003&quot; +
<i>67</i>&nbsp;    &quot;\000\002\014\005\000\002\014\005\000\002\015\003\000&quot; +
<i>68</i>&nbsp;    &quot;\002\015\005\000\002\015\005\000\002\015\005\000\002&quot; +
<i>69</i>&nbsp;    &quot;\015\005\000\002\016\003\000\002\016\005\000\002\016&quot; +
<i>70</i>&nbsp;    &quot;\005\000\002\017\003\000\002\017\005\000\002\017\005&quot; +
<i>71</i>&nbsp;    &quot;\000\002\017\005\000\002\020\003\000\002\020\004\000&quot; +
<i>72</i>&nbsp;    &quot;\002\024\003\000\002\024\005\000\002\025\003\000\002&quot; +
<i>73</i>&nbsp;    &quot;\025\003\000\002\025\005\000\002\025\005\000\002\006&quot; +
<i>74</i>&nbsp;    &quot;\003\000\002\006\003\000\002\027\003\000\002\027\005&quot; +
<i>75</i>&nbsp;    &quot;\000\002\027\003\000\002\031\003\000\002\031\004\000&quot; +
<i>76</i>&nbsp;    &quot;\002\031\003\000\002\030\005\000\002\032\004\000\002&quot; +
<i>77</i>&nbsp;    &quot;\011\003\000\002\011\004\000\002\011\005\000\002\011&quot; +
<b class="nc"><i>78</i>&nbsp;    &quot;\004\000\002\011\003\000\002\053\004\000\002\053\003&quot; +</b>
<i>79</i>&nbsp;    &quot;\000\002\052\003\000\002\052\003\000\002\052\003\000&quot; +
<i>80</i>&nbsp;    &quot;\002\052\003\000\002\052\003\000\002\052\003\000\002&quot; +
<b class="nc"><i>81</i>&nbsp;    &quot;\052\003\000\002\052\003\000\002\052\003\000\002\052&quot; +</b>
<b class="nc"><i>82</i>&nbsp;    &quot;\003\000\002\052\003\000\002\052\003\000\002\052\003&quot; +</b>
<i>83</i>&nbsp;    &quot;\000\002\026\003\000\002\026\003\000\002\010\003\000&quot; +
<i>84</i>&nbsp;    &quot;\002\010\004\000\002\023\003\000\002\023\005\000\002&quot; +
<i>85</i>&nbsp;    &quot;\023\003\000\002\023\003\000\002\023\003\000\002\023&quot; +
<i>86</i>&nbsp;    &quot;\003\000\002\021\004\000\002\022\005\000\002\022\006&quot; +
<i>87</i>&nbsp;    &quot;\000\002\046\003\000\002\046\005\000\002\050\003\000&quot; +
<i>88</i>&nbsp;    &quot;\002\051\003\000\002\005\003\000\002\033\003\000\002&quot; +
<i>89</i>&nbsp;    &quot;\033\003\000\002\033\003\000\002\033\003\000\002\033&quot; +
<i>90</i>&nbsp;    &quot;\006\000\002\033\003\000\002\034\003\000\002\034\003&quot; +
<i>91</i>&nbsp;    &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot; +
<i>92</i>&nbsp;    &quot;\002\047\003\000\002\047\003\000\002\047\003\000\002&quot; +
<i>93</i>&nbsp;    &quot;\047\003\000\002\047\003\000\002\047\003\000\002\047&quot; +
<i>94</i>&nbsp;    &quot;\003\000\002\047\003\000\002\047\003\000\002\047\003&quot; +
<i>95</i>&nbsp;    &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot; +
<i>96</i>&nbsp;    &quot;\002\047\003\000\002\047\003&quot; });
<i>97</i>&nbsp;
<i>98</i>&nbsp;  /** Access to production table. */
<i>99</i>&nbsp;  public short[][] production_table() {return _production_table;}
<i>100</i>&nbsp;
<i>101</i>&nbsp;  /** Parse-action table. */
<i>102</i>&nbsp;  protected static final short[][] _action_table =
<i>103</i>&nbsp;    unpackFromStrings(new String[] {
<i>104</i>&nbsp;    &quot;\000\307\000\006\066\006\067\005\001\002\000\004\002&quot; +
<i>105</i>&nbsp;    &quot;\311\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
<i>106</i>&nbsp;    &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
<i>107</i>&nbsp;    &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
<i>108</i>&nbsp;    &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
<i>109</i>&nbsp;    &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
<i>110</i>&nbsp;    &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
<i>111</i>&nbsp;    &quot;\070\004\013\013\027\016\020\021\023\032\031\033\040&quot; +
<i>112</i>&nbsp;    &quot;\035\034\036\033\037\046\040\047\041\051\044\015\045&quot; +
<i>113</i>&nbsp;    &quot;\014\046\016\047\036\050\037\051\044\052\025\053\050&quot; +
<i>114</i>&nbsp;    &quot;\054\043\055\041\056\035\057\030\060\045\061\021\062&quot; +
<i>115</i>&nbsp;    &quot;\012\063\042\001\002\000\006\002\ufffe\010\306\001\002&quot; +
<i>116</i>&nbsp;    &quot;\000\004\002\000\001\002\000\014\002\uffe7\004\uffe7\006&quot; +
<i>117</i>&nbsp;    &quot;\uffe7\010\uffe7\021\uffe7\001\002\000\054\002\uff7a\004\uff7a&quot; +
<i>118</i>&nbsp;    &quot;\006\uff7a\007\uff7a\010\uff7a\012\uff7a\013\uff7a\014\uff7a\021&quot; +
<i>119</i>&nbsp;    &quot;\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027\uff7a&quot; +
<i>120</i>&nbsp;    &quot;\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a\001&quot; +
<i>121</i>&nbsp;    &quot;\002\000\070\002\ufffc\010\ufffc\013\027\016\020\032\031&quot; +
<i>122</i>&nbsp;    &quot;\033\040\035\034\036\113\037\141\040\047\041\051\044&quot; +
<i>123</i>&nbsp;    &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot; +
<i>124</i>&nbsp;    &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot; +
<i>125</i>&nbsp;    &quot;\021\062\012\063\042\001\002\000\014\002\uffe3\004\uffe3&quot; +
<i>126</i>&nbsp;    &quot;\006\uffe3\010\uffe3\021\uffe3\001\002\000\014\002\uffe4\004&quot; +
<i>127</i>&nbsp;    &quot;\uffe4\006\uffe4\010\uffe4\021\uffe4\001\002\000\004\011\302&quot; +
<i>128</i>&nbsp;    &quot;\001\002\000\012\002\ufffa\004\277\010\ufffa\021\276\001&quot; +
<i>129</i>&nbsp;    &quot;\002\000\062\013\uffe0\032\uffe0\033\uffe0\035\uffe0\036\uffe0&quot; +
<i>130</i>&nbsp;    &quot;\037\uffe0\040\uffe0\041\uffe0\044\uffe0\045\uffe0\046\uffe0\047&quot; +
<i>131</i>&nbsp;    &quot;\uffe0\050\uffe0\051\uffe0\052\uffe0\053\uffe0\054\uffe0\055\uffe0&quot; +
<i>132</i>&nbsp;    &quot;\056\uffe0\057\uffe0\060\uffe0\061\uffe0\062\uffe0\063\uffe0\001&quot; +
<i>133</i>&nbsp;    &quot;\002\000\054\002\uff7b\004\uff7b\006\uff7b\007\uff7b\010\uff7b&quot; +
<i>134</i>&nbsp;    &quot;\012\uff7b\013\uff7b\014\uff7b\021\uff7b\022\uff7b\023\uff7b\024&quot; +
<i>135</i>&nbsp;    &quot;\uff7b\025\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b&quot; +
<i>136</i>&nbsp;    &quot;\033\uff7b\042\uff7b\043\uff7b\001\002\000\062\013\027\032&quot; +
<i>137</i>&nbsp;    &quot;\031\033\040\035\034\036\113\037\141\040\047\041\051&quot; +
<i>138</i>&nbsp;    &quot;\044\015\045\014\046\016\047\036\050\037\051\044\052&quot; +
<i>139</i>&nbsp;    &quot;\170\053\166\054\043\055\041\056\035\057\030\060\045&quot; +
<i>140</i>&nbsp;    &quot;\061\021\062\012\063\042\001\002\000\064\013\027\016&quot; +
<i>141</i>&nbsp;    &quot;\020\032\031\033\040\035\034\036\113\037\141\040\047&quot; +
<i>142</i>&nbsp;    &quot;\041\051\044\015\045\014\046\016\047\036\050\037\051&quot; +
<i>143</i>&nbsp;    &quot;\044\052\025\053\050\054\043\055\041\056\035\057\030&quot; +
<i>144</i>&nbsp;    &quot;\060\045\061\021\062\012\063\042\001\002\000\012\002&quot; +
<i>145</i>&nbsp;    &quot;\ufff2\004\266\010\ufff2\021\265\001\002\000\016\002\uff7f&quot; +
<i>146</i>&nbsp;    &quot;\004\uff7f\006\uff7f\010\uff7f\020\264\021\uff7f\001\002\000&quot; +
<i>147</i>&nbsp;    &quot;\006\002\ufff6\010\ufff6\001\002\000\014\002\uffe2\004\uffe2&quot; +
<i>148</i>&nbsp;    &quot;\006\uffe2\010\uffe2\021\uffe2\001\002\000\054\002\uff7d\004&quot; +
<i>149</i>&nbsp;    &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\012\uff7d\013\uff7d\014\uff7d&quot; +
<i>150</i>&nbsp;    &quot;\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025\uff7d\026\uff7d\027&quot; +
<i>151</i>&nbsp;    &quot;\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d\042\uff7d\043\uff7d&quot; +
<i>152</i>&nbsp;    &quot;\001\002\000\056\002\uff85\004\uff85\006\uff85\007\uff85\010&quot; +
<i>153</i>&nbsp;    &quot;\uff85\011\uff85\012\uff85\013\uff85\014\uff85\021\uff85\022\uff85&quot; +
<i>154</i>&nbsp;    &quot;\023\uff85\024\uff85\025\uff85\026\uff85\027\uff85\030\uff85\031&quot; +
<i>155</i>&nbsp;    &quot;\uff85\032\uff85\033\uff85\042\uff85\043\uff85\001\002\000\014&quot; +
<i>156</i>&nbsp;    &quot;\002\uffed\004\uffed\006\055\010\uffed\021\uffed\001\002\000&quot; +
<i>157</i>&nbsp;    &quot;\016\002\uff75\004\uff75\006\uff75\010\uff75\011\260\021\uff75&quot; +
<i>158</i>&nbsp;    &quot;\001\002\000\056\002\uff86\004\uff86\006\uff86\007\uff86\010&quot; +
<i>159</i>&nbsp;    &quot;\uff86\011\uff86\012\uff86\013\uff86\014\uff86\021\uff86\022\uff86&quot; +
<i>160</i>&nbsp;    &quot;\023\uff86\024\uff86\025\uff86\026\uff86\027\uff86\030\uff86\031&quot; +
<i>161</i>&nbsp;    &quot;\uff86\032\uff86\033\uff86\042\uff86\043\uff86\001\002\000\054&quot; +
<i>162</i>&nbsp;    &quot;\002\uff7e\004\uff7e\006\uff7e\007\uff7e\010\uff7e\012\uff7e\013&quot; +
<i>163</i>&nbsp;    &quot;\uff7e\014\uff7e\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e&quot; +
<i>164</i>&nbsp;    &quot;\026\uff7e\027\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042&quot; +
<i>165</i>&nbsp;    &quot;\uff7e\043\uff7e\001\002\000\054\002\uff77\004\uff77\006\uff77&quot; +
<i>166</i>&nbsp;    &quot;\007\uff77\010\uff77\012\uff77\013\uff77\014\uff77\021\uff77\022&quot; +
<i>167</i>&nbsp;    &quot;\uff77\023\uff77\024\uff77\025\uff77\026\uff77\027\uff77\030\uff77&quot; +
<i>168</i>&nbsp;    &quot;\031\uff77\032\uff77\033\uff77\042\uff77\043\uff77\001\002\000&quot; +
<i>169</i>&nbsp;    &quot;\054\002\uff76\004\uff76\006\uff76\007\uff76\010\uff76\012\uff76&quot; +
<i>170</i>&nbsp;    &quot;\013\uff76\014\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025&quot; +
<i>171</i>&nbsp;    &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot; +
<i>172</i>&nbsp;    &quot;\042\uff76\043\uff76\001\002\000\056\002\uff84\004\uff84\006&quot; +
<i>173</i>&nbsp;    &quot;\uff84\007\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84&quot; +
<i>174</i>&nbsp;    &quot;\021\uff84\022\uff84\023\uff84\024\uff84\025\uff84\026\uff84\027&quot; +
<i>175</i>&nbsp;    &quot;\uff84\030\uff84\031\uff84\032\uff84\033\uff84\042\uff84\043\uff84&quot; +
<i>176</i>&nbsp;    &quot;\001\002\000\054\002\uff81\004\uff81\006\uff81\007\uff81\010&quot; +
<i>177</i>&nbsp;    &quot;\uff81\012\uff81\013\uff81\014\uff81\021\uff81\022\uff81\023\uff81&quot; +
<i>178</i>&nbsp;    &quot;\024\uff81\025\uff81\026\uff81\027\uff81\030\uff81\031\uff81\032&quot; +
<i>179</i>&nbsp;    &quot;\uff81\033\uff81\042\uff81\043\uff81\001\002\000\054\002\uff78&quot; +
<i>180</i>&nbsp;    &quot;\004\uff78\006\uff78\007\uff78\010\uff78\012\uff78\013\uff78\014&quot; +
<i>181</i>&nbsp;    &quot;\uff78\021\uff78\022\uff78\023\uff78\024\uff78\025\uff78\026\uff78&quot; +
<i>182</i>&nbsp;    &quot;\027\uff78\030\uff78\031\uff78\032\uff78\033\uff78\042\uff78\043&quot; +
<i>183</i>&nbsp;    &quot;\uff78\001\002\000\054\002\uff82\004\uff82\006\uff82\007\uff82&quot; +
<i>184</i>&nbsp;    &quot;\010\uff82\012\uff82\013\uff82\014\uff82\021\uff82\022\uff82\023&quot; +
<i>185</i>&nbsp;    &quot;\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030\uff82\031\uff82&quot; +
<i>186</i>&nbsp;    &quot;\032\uff82\033\uff82\042\uff82\043\uff82\001\002\000\054\002&quot; +
<i>187</i>&nbsp;    &quot;\uff79\004\uff79\006\uff79\007\uff79\010\uff79\012\uff79\013\uff79&quot; +
<i>188</i>&nbsp;    &quot;\014\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot; +
<i>189</i>&nbsp;    &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot; +
<i>190</i>&nbsp;    &quot;\043\uff79\001\002\000\054\002\uff7c\004\uff7c\006\uff7c\007&quot; +
<i>191</i>&nbsp;    &quot;\uff7c\010\uff7c\012\uff7c\013\uff7c\014\uff7c\021\uff7c\022\uff7c&quot; +
<i>192</i>&nbsp;    &quot;\023\uff7c\024\uff7c\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031&quot; +
<i>193</i>&nbsp;    &quot;\uff7c\032\uff7c\033\uff7c\042\uff7c\043\uff7c\001\002\000\016&quot; +
<i>194</i>&nbsp;    &quot;\002\uff83\004\uff83\006\uff83\010\uff83\011\253\021\uff83\001&quot; +
<i>195</i>&nbsp;    &quot;\002\000\014\002\uffe5\004\uffe5\006\uffe5\010\uffe5\021\uffe5&quot; +
<i>196</i>&nbsp;    &quot;\001\002\000\016\002\uff80\004\uff80\006\uff80\010\uff80\020&quot; +
<i>197</i>&nbsp;    &quot;\252\021\uff80\001\002\000\014\002\uffe6\004\uffe6\006\uffe6&quot; +
<i>198</i>&nbsp;    &quot;\010\uffe6\021\uffe6\001\002\000\014\002\uffe1\004\uffe1\006&quot; +
<i>199</i>&nbsp;    &quot;\uffe1\010\uffe1\021\uffe1\001\002\000\014\002\uffef\004\uffef&quot; +
<i>200</i>&nbsp;    &quot;\006\055\010\uffef\021\uffef\001\002\000\054\002\uffdd\004&quot; +
<i>201</i>&nbsp;    &quot;\uffdd\006\055\007\uffdd\010\uffdd\012\uffdd\013\uffdd\014\uffdd&quot; +
<i>202</i>&nbsp;    &quot;\021\uffdd\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027&quot; +
<i>203</i>&nbsp;    &quot;\uffdd\030\uffdd\031\uffdd\032\uffdd\033\uffdd\042\uffdd\043\uffdd&quot; +
<i>204</i>&nbsp;    &quot;\001\002\000\110\004\061\005\111\011\071\013\103\015&quot; +
<i>205</i>&nbsp;    &quot;\134\016\066\017\106\021\070\031\075\032\031\033\040&quot; +
<i>206</i>&nbsp;    &quot;\034\057\035\034\036\113\037\141\040\142\041\145\044&quot; +
<i>207</i>&nbsp;    &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot; +
<i>208</i>&nbsp;    &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot; +
<i>209</i>&nbsp;    &quot;\067\062\060\063\127\064\132\065\072\001\002\000\012&quot; +
<i>210</i>&nbsp;    &quot;\002\uffee\004\uffee\010\uffee\021\uffee\001\002\000\054\002&quot; +
<i>211</i>&nbsp;    &quot;\uff9a\004\uff9a\006\uff9a\007\uff9a\010\uff9a\012\uff9a\013\uff9a&quot; +
<i>212</i>&nbsp;    &quot;\014\uff9a\021\uff9a\022\uff9a\023\uff9a\024\uff9a\025\uff9a\026&quot; +
<i>213</i>&nbsp;    &quot;\uff9a\027\uff9a\030\uff9a\031\uff9a\032\uff9a\033\uff9a\042\uff9a&quot; +
<i>214</i>&nbsp;    &quot;\043\uff9a\001\002\000\060\002\uff7a\004\uff7a\006\uff7a\007&quot; +
<i>215</i>&nbsp;    &quot;\uff7a\010\uff7a\011\uff7a\012\uff7a\013\uff7a\014\uff7a\020\uffa5&quot; +
<i>216</i>&nbsp;    &quot;\021\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027&quot; +
<i>217</i>&nbsp;    &quot;\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a&quot; +
<i>218</i>&nbsp;    &quot;\001\002\000\126\002\uffb9\005\111\007\uffb9\010\uffb9\012&quot; +
<i>219</i>&nbsp;    &quot;\uffb9\013\103\014\uffb9\016\066\017\106\022\uffb9\023\uffb9&quot; +
<i>220</i>&nbsp;    &quot;\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9\032&quot; +
<i>221</i>&nbsp;    &quot;\031\033\040\035\034\036\113\037\141\040\142\041\145&quot; +
<i>222</i>&nbsp;    &quot;\042\uffb9\043\uffb9\044\063\045\062\046\065\047\115\050&quot; +
<i>223</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>224</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot; +
<i>225</i>&nbsp;    &quot;\054\002\uff89\004\uff89\006\uff89\007\uff89\010\uff89\012\uff89&quot; +
<i>226</i>&nbsp;    &quot;\013\uff89\014\uff89\021\uff89\022\uff89\023\uff89\024\uff89\025&quot; +
<i>227</i>&nbsp;    &quot;\uff89\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89\033\uff89&quot; +
<i>228</i>&nbsp;    &quot;\042\uff89\043\uff89\001\002\000\054\002\uff8b\004\uff8b\006&quot; +
<i>229</i>&nbsp;    &quot;\uff8b\007\uff8b\010\uff8b\012\uff8b\013\uff8b\014\uff8b\021\uff8b&quot; +
<i>230</i>&nbsp;    &quot;\022\uff8b\023\uff8b\024\uff8b\025\uff8b\026\uff8b\027\uff8b\030&quot; +
<i>231</i>&nbsp;    &quot;\uff8b\031\uff8b\032\uff8b\033\uff8b\042\uff8b\043\uff8b\001\002&quot; +
<i>232</i>&nbsp;    &quot;\000\032\002\uffd5\007\uffd5\012\uffd5\014\uffd5\022\uffd5\023&quot; +
<i>233</i>&nbsp;    &quot;\uffd5\024\221\025\222\026\223\027\224\042\uffd5\043\uffd5&quot; +
<i>234</i>&nbsp;    &quot;\001\002\000\004\011\245\001\002\000\062\013\uffae\032&quot; +
<i>235</i>&nbsp;    &quot;\uffae\033\uffae\035\uffae\036\uffae\037\uffae\040\uffae\041\uffae&quot; +
<i>236</i>&nbsp;    &quot;\044\uffae\045\uffae\046\uffae\047\uffae\050\uffae\051\uffae\052&quot; +
<i>237</i>&nbsp;    &quot;\uffae\053\uffae\054\uffae\055\uffae\056\uffae\057\uffae\060\uffae&quot; +
<i>238</i>&nbsp;    &quot;\061\uffae\062\uffae\063\uffae\001\002\000\060\002\uff7b\004&quot; +
<i>239</i>&nbsp;    &quot;\uff7b\006\uff7b\007\uff7b\010\uff7b\011\uff7b\012\uff7b\013\uff7b&quot; +
<i>240</i>&nbsp;    &quot;\014\uff7b\020\uffa6\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025&quot; +
<i>241</i>&nbsp;    &quot;\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b&quot; +
<i>242</i>&nbsp;    &quot;\042\uff7b\043\uff7b\001\002\000\070\005\111\013\103\016&quot; +
<i>243</i>&nbsp;    &quot;\066\017\106\032\031\033\040\035\034\036\113\037\141&quot; +
<i>244</i>&nbsp;    &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
<i>245</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>246</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot; +
<i>247</i>&nbsp;    &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot; +
<i>248</i>&nbsp;    &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot; +
<i>249</i>&nbsp;    &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
<i>250</i>&nbsp;    &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
<i>251</i>&nbsp;    &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
<i>252</i>&nbsp;    &quot;\063\127\064\132\065\072\001\002\000\054\002\uff99\004&quot; +
<i>253</i>&nbsp;    &quot;\uff99\006\uff99\007\uff99\010\uff99\012\uff99\013\uff99\014\uff99&quot; +
<i>254</i>&nbsp;    &quot;\021\uff99\022\uff99\023\uff99\024\uff99\025\uff99\026\uff99\027&quot; +
<i>255</i>&nbsp;    &quot;\uff99\030\uff99\031\uff99\032\uff99\033\uff99\042\uff99\043\uff99&quot; +
<i>256</i>&nbsp;    &quot;\001\002\000\046\002\uffb7\007\uffb7\010\uffb7\012\uffb7\013&quot; +
<i>257</i>&nbsp;    &quot;\uffb7\014\uffb7\022\uffb7\023\uffb7\024\uffb7\025\uffb7\026\uffb7&quot; +
<i>258</i>&nbsp;    &quot;\027\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\042\uffb7\043&quot; +
<i>259</i>&nbsp;    &quot;\uffb7\001\002\000\054\002\uff97\004\uff97\006\uff97\007\uff97&quot; +
<i>260</i>&nbsp;    &quot;\010\uff97\012\uff97\013\uff97\014\uff97\021\uff97\022\uff97\023&quot; +
<i>261</i>&nbsp;    &quot;\uff97\024\uff97\025\uff97\026\uff97\027\uff97\030\uff97\031\uff97&quot; +
<i>262</i>&nbsp;    &quot;\032\uff97\033\uff97\042\uff97\043\uff97\001\002\000\110\004&quot; +
<i>263</i>&nbsp;    &quot;\061\005\111\011\071\013\103\015\134\016\066\017\106&quot; +
<i>264</i>&nbsp;    &quot;\021\070\031\075\032\031\033\040\034\057\035\034\036&quot; +
<i>265</i>&nbsp;    &quot;\113\037\141\040\142\041\145\044\063\045\062\046\065&quot; +
<i>266</i>&nbsp;    &quot;\047\115\050\123\051\136\052\077\053\143\054\131\055&quot; +
<i>267</i>&nbsp;    &quot;\125\056\116\057\104\060\140\061\067\062\060\063\127&quot; +
<i>268</i>&nbsp;    &quot;\064\132\065\072\001\002\000\016\002\uffd9\007\uffd9\012&quot; +
<i>269</i>&nbsp;    &quot;\uffd9\014\uffd9\042\uffd9\043\234\001\002\000\060\002\uff7f&quot; +
<i>270</i>&nbsp;    &quot;\004\uff7f\006\uff7f\007\uff7f\010\uff7f\011\uff7f\012\uff7f\013&quot; +
<i>271</i>&nbsp;    &quot;\uff7f\014\uff7f\020\uffaa\021\uff7f\022\uff7f\023\uff7f\024\uff7f&quot; +
<i>272</i>&nbsp;    &quot;\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031\uff7f\032\uff7f\033&quot; +
<i>273</i>&nbsp;    &quot;\uff7f\042\uff7f\043\uff7f\001\002\000\062\013\103\032\031&quot; +
<i>274</i>&nbsp;    &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot; +
<i>275</i>&nbsp;    &quot;\063\045\062\046\065\047\036\050\037\051\044\052\170&quot; +
<i>276</i>&nbsp;    &quot;\053\166\054\043\055\041\056\035\057\030\060\045\061&quot; +
<i>277</i>&nbsp;    &quot;\021\062\012\063\042\001\002\000\004\020\236\001\002&quot; +
<i>278</i>&nbsp;    &quot;\000\014\002\uffda\007\uffda\012\uffda\014\uffda\042\232\001&quot; +
<i>279</i>&nbsp;    &quot;\002\000\054\002\uff88\004\uff88\006\uff88\007\uff88\010\uff88&quot; +
<i>280</i>&nbsp;    &quot;\012\uff88\013\uff88\014\uff88\021\uff88\022\uff88\023\uff88\024&quot; +
<i>281</i>&nbsp;    &quot;\uff88\025\uff88\026\uff88\027\uff88\030\uff88\031\uff88\032\uff88&quot; +
<i>282</i>&nbsp;    &quot;\033\uff88\042\uff88\043\uff88\001\002\000\060\002\uff7d\004&quot; +
<i>283</i>&nbsp;    &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\011\uff7d\012\uff7d\013\uff7d&quot; +
<i>284</i>&nbsp;    &quot;\014\uff7d\020\uffa8\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025&quot; +
<i>285</i>&nbsp;    &quot;\uff7d\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d&quot; +
<i>286</i>&nbsp;    &quot;\042\uff7d\043\uff7d\001\002\000\022\002\uffd7\007\uffd7\012&quot; +
<i>287</i>&nbsp;    &quot;\uffd7\014\uffd7\022\216\023\217\042\uffd7\043\uffd7\001\002&quot; +
<i>288</i>&nbsp;    &quot;\000\052\002\uff9f\004\uff9f\007\uff9f\010\uff9f\012\uff9f\013&quot; +
<i>289</i>&nbsp;    &quot;\uff9f\014\uff9f\021\uff9f\022\uff9f\023\uff9f\024\uff9f\025\uff9f&quot; +
<i>290</i>&nbsp;    &quot;\026\uff9f\027\uff9f\030\uff9f\031\uff9f\032\uff9f\033\uff9f\042&quot; +
<i>291</i>&nbsp;    &quot;\uff9f\043\uff9f\001\002\000\054\002\uffb4\004\uffb4\006\055&quot; +
<i>292</i>&nbsp;    &quot;\007\uffb4\010\uffb4\012\uffb4\013\uffb4\014\uffb4\021\uffb4\022&quot; +
<i>293</i>&nbsp;    &quot;\uffb4\023\uffb4\024\uffb4\025\uffb4\026\uffb4\027\uffb4\030\uffb4&quot; +
<i>294</i>&nbsp;    &quot;\031\uffb4\032\uffb4\033\uffb4\042\uffb4\043\uffb4\001\002\000&quot; +
<i>295</i>&nbsp;    &quot;\046\002\uffbd\007\uffbd\010\uffbd\012\uffbd\013\uffbd\014\uffbd&quot; +
<i>296</i>&nbsp;    &quot;\022\uffbd\023\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030&quot; +
<i>297</i>&nbsp;    &quot;\uffbd\031\uffbd\032\uffbd\033\uffbd\042\uffbd\043\uffbd\001\002&quot; +
<i>298</i>&nbsp;    &quot;\000\052\002\uffa0\004\uffa0\007\uffa0\010\uffa0\012\uffa0\013&quot; +
<i>299</i>&nbsp;    &quot;\uffa0\014\uffa0\021\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0&quot; +
<i>300</i>&nbsp;    &quot;\026\uffa0\027\uffa0\030\uffa0\031\uffa0\032\uffa0\033\uffa0\042&quot; +
<i>301</i>&nbsp;    &quot;\uffa0\043\uffa0\001\002\000\036\002\uffd2\007\uffd2\012\uffd2&quot; +
<i>302</i>&nbsp;    &quot;\014\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\026\uffd2\027&quot; +
<i>303</i>&nbsp;    &quot;\uffd2\030\211\031\212\042\uffd2\043\uffd2\001\002\000\056&quot; +
<i>304</i>&nbsp;    &quot;\002\uff75\004\uff75\006\uff75\007\uff75\010\uff75\011\uff75\012&quot; +
<i>305</i>&nbsp;    &quot;\uff75\013\uff75\014\uff75\021\uff75\022\uff75\023\uff75\024\uff75&quot; +
<i>306</i>&nbsp;    &quot;\025\uff75\026\uff75\027\uff75\030\uff75\031\uff75\032\uff75\033&quot; +
<i>307</i>&nbsp;    &quot;\uff75\042\uff75\043\uff75\001\002\000\044\002\uffca\007\uffca&quot; +
<i>308</i>&nbsp;    &quot;\012\uffca\013\uffca\014\uffca\022\uffca\023\uffca\024\uffca\025&quot; +
<i>309</i>&nbsp;    &quot;\uffca\026\uffca\027\uffca\030\uffca\031\uffca\032\uffca\033\uffca&quot; +
<i>310</i>&nbsp;    &quot;\042\uffca\043\uffca\001\002\000\060\002\uff77\004\uff77\006&quot; +
<i>311</i>&nbsp;    &quot;\uff77\007\uff77\010\uff77\011\uff77\012\uff77\013\uff77\014\uff77&quot; +
<i>312</i>&nbsp;    &quot;\020\uffa2\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\026&quot; +
<i>313</i>&nbsp;    &quot;\uff77\027\uff77\030\uff77\031\uff77\032\uff77\033\uff77\042\uff77&quot; +
<i>314</i>&nbsp;    &quot;\043\uff77\001\002\000\060\002\uff7e\004\uff7e\006\uff7e\007&quot; +
<i>315</i>&nbsp;    &quot;\uff7e\010\uff7e\011\uff7e\012\uff7e\013\uff7e\014\uff7e\020\uffa9&quot; +
<i>316</i>&nbsp;    &quot;\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e\026\uff7e\027&quot; +
<i>317</i>&nbsp;    &quot;\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042\uff7e\043\uff7e&quot; +
<i>318</i>&nbsp;    &quot;\001\002\000\004\011\201\001\002\000\052\002\uffbc\004&quot; +
<i>319</i>&nbsp;    &quot;\uffbc\007\uffbc\010\uffbc\012\uffbc\013\uffbc\014\uffbc\021\uffbc&quot; +
<i>320</i>&nbsp;    &quot;\022\uffbc\023\uffbc\024\uffbc\025\uffbc\026\uffbc\027\uffbc\030&quot; +
<i>321</i>&nbsp;    &quot;\uffbc\031\uffbc\032\uffbc\033\uffbc\042\uffbc\043\uffbc\001\002&quot; +
<i>322</i>&nbsp;    &quot;\000\046\002\uffc2\007\uffc2\010\uffc2\012\uffc2\013\uffc2\014&quot; +
<i>323</i>&nbsp;    &quot;\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\026\uffc2\027\uffc2&quot; +
<i>324</i>&nbsp;    &quot;\030\uffc2\031\uffc2\032\uffc2\033\uffc2\042\uffc2\043\uffc2\001&quot; +
<i>325</i>&nbsp;    &quot;\002\000\054\002\uff9e\004\uff9e\006\055\007\uff9e\010\uff9e&quot; +
<i>326</i>&nbsp;    &quot;\012\uff9e\013\uff9e\014\uff9e\021\uff9e\022\uff9e\023\uff9e\024&quot; +
<i>327</i>&nbsp;    &quot;\uff9e\025\uff9e\026\uff9e\027\uff9e\030\uff9e\031\uff9e\032\uff9e&quot; +
<i>328</i>&nbsp;    &quot;\033\uff9e\042\uff9e\043\uff9e\001\002\000\060\002\uff76\004&quot; +
<i>329</i>&nbsp;    &quot;\uff76\006\uff76\007\uff76\010\uff76\011\uff76\012\uff76\013\uff76&quot; +
<i>330</i>&nbsp;    &quot;\014\uff76\020\uffa1\021\uff76\022\uff76\023\uff76\024\uff76\025&quot; +
<i>331</i>&nbsp;    &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot; +
<i>332</i>&nbsp;    &quot;\042\uff76\043\uff76\001\002\000\046\002\uffc4\007\uffc4\010&quot; +
<i>333</i>&nbsp;    &quot;\176\012\uffc4\013\uffc4\014\uffc4\022\uffc4\023\uffc4\024\uffc4&quot; +
<i>334</i>&nbsp;    &quot;\025\uffc4\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033&quot; +
<i>335</i>&nbsp;    &quot;\uffc4\042\uffc4\043\uffc4\001\002\000\060\002\uff81\004\uff81&quot; +
<i>336</i>&nbsp;    &quot;\006\uff81\007\uff81\010\uff81\011\uff81\012\uff81\013\uff81\014&quot; +
<i>337</i>&nbsp;    &quot;\uff81\020\uffac\021\uff81\022\uff81\023\uff81\024\uff81\025\uff81&quot; +
<i>338</i>&nbsp;    &quot;\026\uff81\027\uff81\030\uff81\031\uff81\032\uff81\033\uff81\042&quot; +
<i>339</i>&nbsp;    &quot;\uff81\043\uff81\001\002\000\054\002\uff9c\004\uff9c\006\uff9c&quot; +
<i>340</i>&nbsp;    &quot;\007\uff9c\010\uff9c\012\uff9c\013\uff9c\014\uff9c\021\uff9c\022&quot; +
<i>341</i>&nbsp;    &quot;\uff9c\023\uff9c\024\uff9c\025\uff9c\026\uff9c\027\uff9c\030\uff9c&quot; +
<i>342</i>&nbsp;    &quot;\031\uff9c\032\uff9c\033\uff9c\042\uff9c\043\uff9c\001\002\000&quot; +
<i>343</i>&nbsp;    &quot;\060\002\uff78\004\uff78\006\uff78\007\uff78\010\uff78\011\uff78&quot; +
<i>344</i>&nbsp;    &quot;\012\uff78\013\uff78\014\uff78\020\uffa3\021\uff78\022\uff78\023&quot; +
<i>345</i>&nbsp;    &quot;\uff78\024\uff78\025\uff78\026\uff78\027\uff78\030\uff78\031\uff78&quot; +
<i>346</i>&nbsp;    &quot;\032\uff78\033\uff78\042\uff78\043\uff78\001\002\000\052\002&quot; +
<i>347</i>&nbsp;    &quot;\uffc1\004\173\007\uffc1\010\uffc1\012\uffc1\013\uffc1\014\uffc1&quot; +
<i>348</i>&nbsp;    &quot;\021\172\022\uffc1\023\uffc1\024\uffc1\025\uffc1\026\uffc1\027&quot; +
<i>349</i>&nbsp;    &quot;\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1\042\uffc1\043\uffc1&quot; +
<i>350</i>&nbsp;    &quot;\001\002\000\060\002\uff82\004\uff82\006\uff82\007\uff82\010&quot; +
<i>351</i>&nbsp;    &quot;\uff82\011\uff82\012\uff82\013\uff82\014\uff82\020\uffad\021\uff82&quot; +
<i>352</i>&nbsp;    &quot;\022\uff82\023\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030&quot; +
<i>353</i>&nbsp;    &quot;\uff82\031\uff82\032\uff82\033\uff82\042\uff82\043\uff82\001\002&quot; +
<i>354</i>&nbsp;    &quot;\000\054\002\uff98\004\uff98\006\uff98\007\uff98\010\uff98\012&quot; +
<i>355</i>&nbsp;    &quot;\uff98\013\uff98\014\uff98\021\uff98\022\uff98\023\uff98\024\uff98&quot; +
<i>356</i>&nbsp;    &quot;\025\uff98\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033&quot; +
<i>357</i>&nbsp;    &quot;\uff98\042\uff98\043\uff98\001\002\000\004\007\171\001\002&quot; +
<i>358</i>&nbsp;    &quot;\000\046\032\031\033\040\035\034\036\113\037\141\047&quot; +
<i>359</i>&nbsp;    &quot;\036\050\037\051\044\052\170\053\166\054\043\055\041&quot; +
<i>360</i>&nbsp;    &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +
<i>361</i>&nbsp;    &quot;\002\000\052\002\uffba\004\uffba\007\uffba\010\uffba\012\uffba&quot; +
<i>362</i>&nbsp;    &quot;\013\uffba\014\uffba\021\uffba\022\uffba\023\uffba\024\uffba\025&quot; +
<i>363</i>&nbsp;    &quot;\uffba\026\uffba\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba&quot; +
<i>364</i>&nbsp;    &quot;\042\uffba\043\uffba\001\002\000\060\002\uff79\004\uff79\006&quot; +
<i>365</i>&nbsp;    &quot;\uff79\007\uff79\010\uff79\011\uff79\012\uff79\013\uff79\014\uff79&quot; +
<i>366</i>&nbsp;    &quot;\020\uffa4\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot; +
<i>367</i>&nbsp;    &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot; +
<i>368</i>&nbsp;    &quot;\043\uff79\001\002\000\052\002\uffb0\004\uffb0\007\uffb0\010&quot; +
<i>369</i>&nbsp;    &quot;\uffb0\012\uffb0\013\uffb0\014\uffb0\021\uffb0\022\uffb0\023\uffb0&quot; +
<i>370</i>&nbsp;    &quot;\024\uffb0\025\uffb0\026\uffb0\027\uffb0\030\uffb0\031\uffb0\032&quot; +
<i>371</i>&nbsp;    &quot;\uffb0\033\uffb0\042\uffb0\043\uffb0\001\002\000\060\002\uff7c&quot; +
<i>372</i>&nbsp;    &quot;\004\uff7c\006\uff7c\007\uff7c\010\uff7c\011\uff7c\012\uff7c\013&quot; +
<i>373</i>&nbsp;    &quot;\uff7c\014\uff7c\020\uffa7\021\uff7c\022\uff7c\023\uff7c\024\uff7c&quot; +
<i>374</i>&nbsp;    &quot;\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031\uff7c\032\uff7c\033&quot; +
<i>375</i>&nbsp;    &quot;\uff7c\042\uff7c\043\uff7c\001\002\000\056\002\uff83\004\uff83&quot; +
<i>376</i>&nbsp;    &quot;\006\uff83\007\uff83\010\uff83\011\uff83\012\uff83\013\uff83\014&quot; +
<i>377</i>&nbsp;    &quot;\uff83\021\uff83\022\uff83\023\uff83\024\uff83\025\uff83\026\uff83&quot; +
<i>378</i>&nbsp;    &quot;\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\042\uff83\043&quot; +
<i>379</i>&nbsp;    &quot;\uff83\001\002\000\054\002\uff8c\004\uff8c\006\uff8c\007\uff8c&quot; +
<i>380</i>&nbsp;    &quot;\010\uff8c\012\uff8c\013\uff8c\014\uff8c\021\uff8c\022\uff8c\023&quot; +
<i>381</i>&nbsp;    &quot;\uff8c\024\uff8c\025\uff8c\026\uff8c\027\uff8c\030\uff8c\031\uff8c&quot; +
<i>382</i>&nbsp;    &quot;\032\uff8c\033\uff8c\042\uff8c\043\uff8c\001\002\000\060\002&quot; +
<i>383</i>&nbsp;    &quot;\uff80\004\uff80\006\uff80\007\uff80\010\uff80\011\uff80\012\uff80&quot; +
<i>384</i>&nbsp;    &quot;\013\uff80\014\uff80\020\uffab\021\uff80\022\uff80\023\uff80\024&quot; +
<i>385</i>&nbsp;    &quot;\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80\032\uff80&quot; +
<i>386</i>&nbsp;    &quot;\033\uff80\042\uff80\043\uff80\001\002\000\044\002\uffc6\007&quot; +
<i>387</i>&nbsp;    &quot;\uffc6\012\uffc6\013\uffc6\014\uffc6\022\uffc6\023\uffc6\024\uffc6&quot; +
<i>388</i>&nbsp;    &quot;\025\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6\033&quot; +
<i>389</i>&nbsp;    &quot;\uffc6\042\uffc6\043\uffc6\001\002\000\054\002\uff8d\004\uff8d&quot; +
<i>390</i>&nbsp;    &quot;\006\uff8d\007\uff8d\010\uff8d\012\uff8d\013\uff8d\014\uff8d\021&quot; +
<i>391</i>&nbsp;    &quot;\uff8d\022\uff8d\023\uff8d\024\uff8d\025\uff8d\026\uff8d\027\uff8d&quot; +
<i>392</i>&nbsp;    &quot;\030\uff8d\031\uff8d\032\uff8d\033\uff8d\042\uff8d\043\uff8d\001&quot; +
<i>393</i>&nbsp;    &quot;\002\000\044\002\uffcd\007\uffcd\012\uffcd\013\160\014\uffcd&quot; +
<i>394</i>&nbsp;    &quot;\022\uffcd\023\uffcd\024\uffcd\025\uffcd\026\uffcd\027\uffcd\030&quot; +
<i>395</i>&nbsp;    &quot;\uffcd\031\uffcd\032\161\033\157\042\uffcd\043\uffcd\001\002&quot; +
<i>396</i>&nbsp;    &quot;\000\052\002\uffbe\004\153\007\uffbe\010\uffbe\012\uffbe\013&quot; +
<i>397</i>&nbsp;    &quot;\uffbe\014\uffbe\021\152\022\uffbe\023\uffbe\024\uffbe\025\uffbe&quot; +
<i>398</i>&nbsp;    &quot;\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\042&quot; +
<i>399</i>&nbsp;    &quot;\uffbe\043\uffbe\001\002\000\054\002\uff8e\004\uff8e\006\uff8e&quot; +
<i>400</i>&nbsp;    &quot;\007\uff8e\010\uff8e\012\uff8e\013\uff8e\014\uff8e\021\uff8e\022&quot; +
<i>401</i>&nbsp;    &quot;\uff8e\023\uff8e\024\uff8e\025\uff8e\026\uff8e\027\uff8e\030\uff8e&quot; +
<i>402</i>&nbsp;    &quot;\031\uff8e\032\uff8e\033\uff8e\042\uff8e\043\uff8e\001\002\000&quot; +
<i>403</i>&nbsp;    &quot;\056\002\uff87\004\uff87\006\uff87\007\uff87\010\uff87\011\uff91&quot; +
<i>404</i>&nbsp;    &quot;\012\uff87\013\uff87\014\uff87\021\uff87\022\uff87\023\uff87\024&quot; +
<i>405</i>&nbsp;    &quot;\uff87\025\uff87\026\uff87\027\uff87\030\uff87\031\uff87\032\uff87&quot; +
<i>406</i>&nbsp;    &quot;\033\uff87\042\uff87\043\uff87\001\002\000\070\005\111\013&quot; +
<i>407</i>&nbsp;    &quot;\103\016\066\017\106\032\031\033\040\035\034\036\113&quot; +
<i>408</i>&nbsp;    &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot; +
<i>409</i>&nbsp;    &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot; +
<i>410</i>&nbsp;    &quot;\056\116\057\104\060\140\061\067\062\060\063\127\001&quot; +
<i>411</i>&nbsp;    &quot;\002\000\070\005\111\013\103\016\066\017\106\032\031&quot; +
<i>412</i>&nbsp;    &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot; +
<i>413</i>&nbsp;    &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot; +
<i>414</i>&nbsp;    &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot; +
<i>415</i>&nbsp;    &quot;\067\062\060\063\127\001\002\000\054\002\uff87\004\uff87&quot; +
<i>416</i>&nbsp;    &quot;\006\uff87\007\uff87\010\uff87\012\uff87\013\uff87\014\uff87\021&quot; +
<i>417</i>&nbsp;    &quot;\uff87\022\uff87\023\uff87\024\uff87\025\uff87\026\uff87\027\uff87&quot; +
<i>418</i>&nbsp;    &quot;\030\uff87\031\uff87\032\uff87\033\uff87\042\uff87\043\uff87\001&quot; +
<i>419</i>&nbsp;    &quot;\002\000\052\002\uffbb\004\uffbb\007\uffbb\010\uffbb\012\uffbb&quot; +
<i>420</i>&nbsp;    &quot;\013\uffbb\014\uffbb\021\uffbb\022\uffbb\023\uffbb\024\uffbb\025&quot; +
<i>421</i>&nbsp;    &quot;\uffbb\026\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb\033\uffbb&quot; +
<i>422</i>&nbsp;    &quot;\042\uffbb\043\uffbb\001\002\000\052\002\uffb6\004\uffb6\007&quot; +
<i>423</i>&nbsp;    &quot;\uffb6\010\uffb6\012\uffb6\013\uffb6\014\uffb6\021\uffb6\022\uffb6&quot; +
<i>424</i>&nbsp;    &quot;\023\uffb6\024\uffb6\025\uffb6\026\uffb6\027\uffb6\030\uffb6\031&quot; +
<i>425</i>&nbsp;    &quot;\uffb6\032\uffb6\033\uffb6\042\uffb6\043\uffb6\001\002\000\110&quot; +
<i>426</i>&nbsp;    &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot; +
<i>427</i>&nbsp;    &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot; +
<i>428</i>&nbsp;    &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot; +
<i>429</i>&nbsp;    &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot; +
<i>430</i>&nbsp;    &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot; +
<i>431</i>&nbsp;    &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot; +
<i>432</i>&nbsp;    &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
<i>433</i>&nbsp;    &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
<i>434</i>&nbsp;    &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
<i>435</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>436</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
<i>437</i>&nbsp;    &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
<i>438</i>&nbsp;    &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
<i>439</i>&nbsp;    &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
<i>440</i>&nbsp;    &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
<i>441</i>&nbsp;    &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
<i>442</i>&nbsp;    &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
<i>443</i>&nbsp;    &quot;\044\002\uffc8\007\uffc8\012\uffc8\013\uffc8\014\uffc8\022\uffc8&quot; +
<i>444</i>&nbsp;    &quot;\023\uffc8\024\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031&quot; +
<i>445</i>&nbsp;    &quot;\uffc8\032\uffc8\033\uffc8\042\uffc8\043\uffc8\001\002\000\044&quot; +
<i>446</i>&nbsp;    &quot;\002\uffc9\007\uffc9\012\uffc9\013\uffc9\014\uffc9\022\uffc9\023&quot; +
<i>447</i>&nbsp;    &quot;\uffc9\024\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\031\uffc9&quot; +
<i>448</i>&nbsp;    &quot;\032\uffc9\033\uffc9\042\uffc9\043\uffc9\001\002\000\044\002&quot; +
<i>449</i>&nbsp;    &quot;\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\022\uffc7\023\uffc7&quot; +
<i>450</i>&nbsp;    &quot;\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\031\uffc7\032&quot; +
<i>451</i>&nbsp;    &quot;\uffc7\033\uffc7\042\uffc7\043\uffc7\001\002\000\054\002\uff90&quot; +
<i>452</i>&nbsp;    &quot;\004\uff90\006\uff90\007\uff90\010\uff90\012\uff90\013\uff90\014&quot; +
<i>453</i>&nbsp;    &quot;\uff90\021\uff90\022\uff90\023\uff90\024\uff90\025\uff90\026\uff90&quot; +
<i>454</i>&nbsp;    &quot;\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\042\uff90\043&quot; +
<i>455</i>&nbsp;    &quot;\uff90\001\002\000\054\002\uff80\004\uff80\006\uff80\007\uff80&quot; +
<i>456</i>&nbsp;    &quot;\010\uff80\012\uff80\013\uff80\014\uff80\021\uff80\022\uff80\023&quot; +
<i>457</i>&nbsp;    &quot;\uff80\024\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80&quot; +
<i>458</i>&nbsp;    &quot;\032\uff80\033\uff80\042\uff80\043\uff80\001\002\000\054\002&quot; +
<i>459</i>&nbsp;    &quot;\uff96\004\uff96\006\uff96\007\uff96\010\uff96\012\uff96\013\uff96&quot; +
<i>460</i>&nbsp;    &quot;\014\uff96\021\uff96\022\uff96\023\uff96\024\uff96\025\uff96\026&quot; +
<i>461</i>&nbsp;    &quot;\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033\uff96\042\uff96&quot; +
<i>462</i>&nbsp;    &quot;\043\uff96\001\002\000\054\002\uff7f\004\uff7f\006\uff7f\007&quot; +
<i>463</i>&nbsp;    &quot;\uff7f\010\uff7f\012\uff7f\013\uff7f\014\uff7f\021\uff7f\022\uff7f&quot; +
<i>464</i>&nbsp;    &quot;\023\uff7f\024\uff7f\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031&quot; +
<i>465</i>&nbsp;    &quot;\uff7f\032\uff7f\033\uff7f\042\uff7f\043\uff7f\001\002\000\054&quot; +
<i>466</i>&nbsp;    &quot;\002\uffdb\004\uffdb\006\uffdb\007\uffdb\010\uffdb\012\uffdb\013&quot; +
<i>467</i>&nbsp;    &quot;\uffdb\014\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb\025\uffdb&quot; +
<i>468</i>&nbsp;    &quot;\026\uffdb\027\uffdb\030\uffdb\031\uffdb\032\uffdb\033\uffdb\042&quot; +
<i>469</i>&nbsp;    &quot;\uffdb\043\uffdb\001\002\000\070\005\111\013\103\016\066&quot; +
<i>470</i>&nbsp;    &quot;\017\106\032\031\033\040\035\034\036\113\037\141\040&quot; +
<i>471</i>&nbsp;    &quot;\142\041\145\044\063\045\062\046\065\047\115\050\123&quot; +
<i>472</i>&nbsp;    &quot;\051\136\052\077\053\143\054\131\055\125\056\116\057&quot; +
<i>473</i>&nbsp;    &quot;\104\060\140\061\067\062\060\063\127\001\002\000\070&quot; +
<i>474</i>&nbsp;    &quot;\005\111\013\103\016\066\017\106\032\031\033\040\035&quot; +
<i>475</i>&nbsp;    &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
<i>476</i>&nbsp;    &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
<i>477</i>&nbsp;    &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
<i>478</i>&nbsp;    &quot;\063\127\001\002\000\052\002\uffc0\004\153\007\uffc0\010&quot; +
<i>479</i>&nbsp;    &quot;\uffc0\012\uffc0\013\uffc0\014\uffc0\021\152\022\uffc0\023\uffc0&quot; +
<i>480</i>&nbsp;    &quot;\024\uffc0\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032&quot; +
<i>481</i>&nbsp;    &quot;\uffc0\033\uffc0\042\uffc0\043\uffc0\001\002\000\052\002\uffbf&quot; +
<i>482</i>&nbsp;    &quot;\004\153\007\uffbf\010\uffbf\012\uffbf\013\uffbf\014\uffbf\021&quot; +
<i>483</i>&nbsp;    &quot;\152\022\uffbf\023\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf&quot; +
<i>484</i>&nbsp;    &quot;\030\uffbf\031\uffbf\032\uffbf\033\uffbf\042\uffbf\043\uffbf\001&quot; +
<i>485</i>&nbsp;    &quot;\002\000\106\004\061\005\111\011\071\013\103\015\134&quot; +
<i>486</i>&nbsp;    &quot;\016\066\017\106\021\070\032\031\033\040\034\057\035&quot; +
<i>487</i>&nbsp;    &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
<i>488</i>&nbsp;    &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
<i>489</i>&nbsp;    &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
<i>490</i>&nbsp;    &quot;\063\127\064\132\065\072\001\002\000\044\002\uffc3\007&quot; +
<i>491</i>&nbsp;    &quot;\uffc3\012\uffc3\013\uffc3\014\uffc3\022\uffc3\023\uffc3\024\uffc3&quot; +
<i>492</i>&nbsp;    &quot;\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\032\uffc3\033&quot; +
<i>493</i>&nbsp;    &quot;\uffc3\042\uffc3\043\uffc3\001\002\000\052\002\uff9d\004\uff9d&quot; +
<i>494</i>&nbsp;    &quot;\007\uff9d\010\uff9d\012\uff9d\013\uff9d\014\uff9d\021\uff9d\022&quot; +
<i>495</i>&nbsp;    &quot;\uff9d\023\uff9d\024\uff9d\025\uff9d\026\uff9d\027\uff9d\030\uff9d&quot; +
<i>496</i>&nbsp;    &quot;\031\uff9d\032\uff9d\033\uff9d\042\uff9d\043\uff9d\001\002\000&quot; +
<i>497</i>&nbsp;    &quot;\112\004\061\005\111\011\071\012\202\013\103\015\134&quot; +
<i>498</i>&nbsp;    &quot;\016\066\017\106\021\070\031\075\032\031\033\040\034&quot; +
<i>499</i>&nbsp;    &quot;\057\035\034\036\113\037\141\040\142\041\145\044\063&quot; +
<i>500</i>&nbsp;    &quot;\045\062\046\065\047\115\050\123\051\136\052\077\053&quot; +
<i>501</i>&nbsp;    &quot;\143\054\131\055\125\056\116\057\104\060\140\061\067&quot; +
<i>502</i>&nbsp;    &quot;\062\060\063\127\064\132\065\072\001\002\000\054\002&quot; +
<i>503</i>&nbsp;    &quot;\uff95\004\uff95\006\uff95\007\uff95\010\uff95\012\uff95\013\uff95&quot; +
<i>504</i>&nbsp;    &quot;\014\uff95\021\uff95\022\uff95\023\uff95\024\uff95\025\uff95\026&quot; +
<i>505</i>&nbsp;    &quot;\uff95\027\uff95\030\uff95\031\uff95\032\uff95\033\uff95\042\uff95&quot; +
<i>506</i>&nbsp;    &quot;\043\uff95\001\002\000\006\012\uff93\014\207\001\002\000&quot; +
<i>507</i>&nbsp;    &quot;\006\012\uff8f\014\uff8f\001\002\000\004\012\206\001\002&quot; +
<i>508</i>&nbsp;    &quot;\000\054\002\uff94\004\uff94\006\uff94\007\uff94\010\uff94\012&quot; +
<i>509</i>&nbsp;    &quot;\uff94\013\uff94\014\uff94\021\uff94\022\uff94\023\uff94\024\uff94&quot; +
<i>510</i>&nbsp;    &quot;\025\uff94\026\uff94\027\uff94\030\uff94\031\uff94\032\uff94\033&quot; +
<i>511</i>&nbsp;    &quot;\uff94\042\uff94\043\uff94\001\002\000\110\004\061\005\111&quot; +
<i>512</i>&nbsp;    &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
<i>513</i>&nbsp;    &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
<i>514</i>&nbsp;    &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
<i>515</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>516</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
<i>517</i>&nbsp;    &quot;\072\001\002\000\004\012\uff92\001\002\000\110\004\061&quot; +
<i>518</i>&nbsp;    &quot;\005\111\011\071\013\103\015\134\016\066\017\106\021&quot; +
<i>519</i>&nbsp;    &quot;\070\031\075\032\031\033\040\034\057\035\034\036\113&quot; +
<i>520</i>&nbsp;    &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot; +
<i>521</i>&nbsp;    &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot; +
<i>522</i>&nbsp;    &quot;\056\116\057\104\060\140\061\067\062\060\063\127\064&quot; +
<i>523</i>&nbsp;    &quot;\132\065\072\001\002\000\110\004\061\005\111\011\071&quot; +
<i>524</i>&nbsp;    &quot;\013\103\015\134\016\066\017\106\021\070\031\075\032&quot; +
<i>525</i>&nbsp;    &quot;\031\033\040\034\057\035\034\036\113\037\141\040\142&quot; +
<i>526</i>&nbsp;    &quot;\041\145\044\063\045\062\046\065\047\115\050\123\051&quot; +
<i>527</i>&nbsp;    &quot;\136\052\077\053\143\054\131\055\125\056\116\057\104&quot; +
<i>528</i>&nbsp;    &quot;\060\140\061\067\062\060\063\127\064\132\065\072\001&quot; +
<i>529</i>&nbsp;    &quot;\002\000\044\002\uffcb\007\uffcb\012\uffcb\013\160\014\uffcb&quot; +
<i>530</i>&nbsp;    &quot;\022\uffcb\023\uffcb\024\uffcb\025\uffcb\026\uffcb\027\uffcb\030&quot; +
<i>531</i>&nbsp;    &quot;\uffcb\031\uffcb\032\161\033\157\042\uffcb\043\uffcb\001\002&quot; +
<i>532</i>&nbsp;    &quot;\000\044\002\uffcc\007\uffcc\012\uffcc\013\160\014\uffcc\022&quot; +
<i>533</i>&nbsp;    &quot;\uffcc\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027\uffcc\030\uffcc&quot; +
<i>534</i>&nbsp;    &quot;\031\uffcc\032\161\033\157\042\uffcc\043\uffcc\001\002\000&quot; +
<i>535</i>&nbsp;    &quot;\052\002\uffb3\004\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3&quot; +
<i>536</i>&nbsp;    &quot;\014\uffb3\021\uffb3\022\uffb3\023\uffb3\024\uffb3\025\uffb3\026&quot; +
<i>537</i>&nbsp;    &quot;\uffb3\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\042\uffb3&quot; +
<i>538</i>&nbsp;    &quot;\043\uffb3\001\002\000\110\004\061\005\111\011\071\013&quot; +
<i>539</i>&nbsp;    &quot;\103\015\134\016\066\017\106\021\070\031\075\032\031&quot; +
<i>540</i>&nbsp;    &quot;\033\040\034\057\035\034\036\113\037\141\040\142\041&quot; +
<i>541</i>&nbsp;    &quot;\145\044\063\045\062\046\065\047\115\050\123\051\136&quot; +
<i>542</i>&nbsp;    &quot;\052\077\053\143\054\131\055\125\056\116\057\104\060&quot; +
<i>543</i>&nbsp;    &quot;\140\061\067\062\060\063\127\064\132\065\072\001\002&quot; +
<i>544</i>&nbsp;    &quot;\000\110\004\061\005\111\011\071\013\103\015\134\016&quot; +
<i>545</i>&nbsp;    &quot;\066\017\106\021\070\031\075\032\031\033\040\034\057&quot; +
<i>546</i>&nbsp;    &quot;\035\034\036\113\037\141\040\142\041\145\044\063\045&quot; +
<i>547</i>&nbsp;    &quot;\062\046\065\047\115\050\123\051\136\052\077\053\143&quot; +
<i>548</i>&nbsp;    &quot;\054\131\055\125\056\116\057\104\060\140\061\067\062&quot; +
<i>549</i>&nbsp;    &quot;\060\063\127\064\132\065\072\001\002\000\032\002\uffd3&quot; +
<i>550</i>&nbsp;    &quot;\007\uffd3\012\uffd3\014\uffd3\022\uffd3\023\uffd3\024\221\025&quot; +
<i>551</i>&nbsp;    &quot;\222\026\223\027\224\042\uffd3\043\uffd3\001\002\000\110&quot; +
<i>552</i>&nbsp;    &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot; +
<i>553</i>&nbsp;    &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot; +
<i>554</i>&nbsp;    &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot; +
<i>555</i>&nbsp;    &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot; +
<i>556</i>&nbsp;    &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot; +
<i>557</i>&nbsp;    &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot; +
<i>558</i>&nbsp;    &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
<i>559</i>&nbsp;    &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
<i>560</i>&nbsp;    &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
<i>561</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>562</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
<i>563</i>&nbsp;    &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
<i>564</i>&nbsp;    &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
<i>565</i>&nbsp;    &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
<i>566</i>&nbsp;    &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
<i>567</i>&nbsp;    &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
<i>568</i>&nbsp;    &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
<i>569</i>&nbsp;    &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot; +
<i>570</i>&nbsp;    &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot; +
<i>571</i>&nbsp;    &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
<i>572</i>&nbsp;    &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
<i>573</i>&nbsp;    &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
<i>574</i>&nbsp;    &quot;\063\127\064\132\065\072\001\002\000\036\002\uffce\007&quot; +
<i>575</i>&nbsp;    &quot;\uffce\012\uffce\014\uffce\022\uffce\023\uffce\024\uffce\025\uffce&quot; +
<i>576</i>&nbsp;    &quot;\026\uffce\027\uffce\030\211\031\212\042\uffce\043\uffce\001&quot; +
<i>577</i>&nbsp;    &quot;\002\000\036\002\uffcf\007\uffcf\012\uffcf\014\uffcf\022\uffcf&quot; +
<i>578</i>&nbsp;    &quot;\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030\211\031&quot; +
<i>579</i>&nbsp;    &quot;\212\042\uffcf\043\uffcf\001\002\000\036\002\uffd0\007\uffd0&quot; +
<i>580</i>&nbsp;    &quot;\012\uffd0\014\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026&quot; +
<i>581</i>&nbsp;    &quot;\uffd0\027\uffd0\030\211\031\212\042\uffd0\043\uffd0\001\002&quot; +
<i>582</i>&nbsp;    &quot;\000\036\002\uffd1\007\uffd1\012\uffd1\014\uffd1\022\uffd1\023&quot; +
<i>583</i>&nbsp;    &quot;\uffd1\024\uffd1\025\uffd1\026\uffd1\027\uffd1\030\211\031\212&quot; +
<i>584</i>&nbsp;    &quot;\042\uffd1\043\uffd1\001\002\000\032\002\uffd4\007\uffd4\012&quot; +
<i>585</i>&nbsp;    &quot;\uffd4\014\uffd4\022\uffd4\023\uffd4\024\221\025\222\026\223&quot; +
<i>586</i>&nbsp;    &quot;\027\224\042\uffd4\043\uffd4\001\002\000\110\004\061\005&quot; +
<i>587</i>&nbsp;    &quot;\111\011\071\013\103\015\134\016\066\017\106\021\070&quot; +
<i>588</i>&nbsp;    &quot;\031\075\032\031\033\040\034\057\035\034\036\113\037&quot; +
<i>589</i>&nbsp;    &quot;\141\040\142\041\145\044\063\045\062\046\065\047\115&quot; +
<i>590</i>&nbsp;    &quot;\050\123\051\136\052\077\053\143\054\131\055\125\056&quot; +
<i>591</i>&nbsp;    &quot;\116\057\104\060\140\061\067\062\060\063\127\064\132&quot; +
<i>592</i>&nbsp;    &quot;\065\072\001\002\000\016\002\uffd8\007\uffd8\012\uffd8\014&quot; +
<i>593</i>&nbsp;    &quot;\uffd8\042\uffd8\043\234\001\002\000\110\004\061\005\111&quot; +
<i>594</i>&nbsp;    &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
<i>595</i>&nbsp;    &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
<i>596</i>&nbsp;    &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
<i>597</i>&nbsp;    &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
<i>598</i>&nbsp;    &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
<i>599</i>&nbsp;    &quot;\072\001\002\000\022\002\uffd6\007\uffd6\012\uffd6\014\uffd6&quot; +
<i>600</i>&nbsp;    &quot;\022\216\023\217\042\uffd6\043\uffd6\001\002\000\062\013&quot; +
<i>601</i>&nbsp;    &quot;\uffaf\032\uffaf\033\uffaf\035\uffaf\036\uffaf\037\uffaf\040\uffaf&quot; +
<i>602</i>&nbsp;    &quot;\041\uffaf\044\uffaf\045\uffaf\046\uffaf\047\uffaf\050\uffaf\051&quot; +
<i>603</i>&nbsp;    &quot;\uffaf\052\uffaf\053\uffaf\054\uffaf\055\uffaf\056\uffaf\057\uffaf&quot; +
<i>604</i>&nbsp;    &quot;\060\uffaf\061\uffaf\062\uffaf\063\uffaf\001\002\000\054\002&quot; +
<i>605</i>&nbsp;    &quot;\uffb1\004\uffb1\006\055\007\uffb1\010\uffb1\012\uffb1\013\uffb1&quot; +
<i>606</i>&nbsp;    &quot;\014\uffb1\021\uffb1\022\uffb1\023\uffb1\024\uffb1\025\uffb1\026&quot; +
<i>607</i>&nbsp;    &quot;\uffb1\027\uffb1\030\uffb1\031\uffb1\032\uffb1\033\uffb1\042\uffb1&quot; +
<i>608</i>&nbsp;    &quot;\043\uffb1\001\002\000\052\002\uffb2\004\uffb2\007\uffb2\010&quot; +
<i>609</i>&nbsp;    &quot;\uffb2\012\uffb2\013\uffb2\014\uffb2\021\uffb2\022\uffb2\023\uffb2&quot; +
<i>610</i>&nbsp;    &quot;\024\uffb2\025\uffb2\026\uffb2\027\uffb2\030\uffb2\031\uffb2\032&quot; +
<i>611</i>&nbsp;    &quot;\uffb2\033\uffb2\042\uffb2\043\uffb2\001\002\000\044\002\uffc5&quot; +
<i>612</i>&nbsp;    &quot;\007\uffc5\012\uffc5\013\uffc5\014\uffc5\022\uffc5\023\uffc5\024&quot; +
<i>613</i>&nbsp;    &quot;\uffc5\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031\uffc5\032\uffc5&quot; +
<i>614</i>&nbsp;    &quot;\033\uffc5\042\uffc5\043\uffc5\001\002\000\004\012\243\001&quot; +
<i>615</i>&nbsp;    &quot;\002\000\054\002\uff9b\004\uff9b\006\uff9b\007\uff9b\010\uff9b&quot; +
<i>616</i>&nbsp;    &quot;\012\uff9b\013\uff9b\014\uff9b\021\uff9b\022\uff9b\023\uff9b\024&quot; +
<i>617</i>&nbsp;    &quot;\uff9b\025\uff9b\026\uff9b\027\uff9b\030\uff9b\031\uff9b\032\uff9b&quot; +
<i>618</i>&nbsp;    &quot;\033\uff9b\042\uff9b\043\uff9b\001\002\000\052\002\uffb5\004&quot; +
<i>619</i>&nbsp;    &quot;\153\007\uffb5\010\uffb5\012\uffb5\013\uffb5\014\uffb5\021\152&quot; +
<i>620</i>&nbsp;    &quot;\022\uffb5\023\uffb5\024\uffb5\025\uffb5\026\uffb5\027\uffb5\030&quot; +
<i>621</i>&nbsp;    &quot;\uffb5\031\uffb5\032\uffb5\033\uffb5\042\uffb5\043\uffb5\001\002&quot; +
<i>622</i>&nbsp;    &quot;\000\004\034\246\001\002\000\004\012\247\001\002\000&quot; +
<i>623</i>&nbsp;    &quot;\054\002\uff8a\004\uff8a\006\uff8a\007\uff8a\010\uff8a\012\uff8a&quot; +
<i>624</i>&nbsp;    &quot;\013\uff8a\014\uff8a\021\uff8a\022\uff8a\023\uff8a\024\uff8a\025&quot; +
<i>625</i>&nbsp;    &quot;\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\032\uff8a\033\uff8a&quot; +
<i>626</i>&nbsp;    &quot;\042\uff8a\043\uff8a\001\002\000\052\002\uffb8\004\153\007&quot; +
<i>627</i>&nbsp;    &quot;\uffb8\010\uffb8\012\uffb8\013\uffb8\014\uffb8\021\152\022\uffb8&quot; +
<i>628</i>&nbsp;    &quot;\023\uffb8\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8\031&quot; +
<i>629</i>&nbsp;    &quot;\uffb8\032\uffb8\033\uffb8\042\uffb8\043\uffb8\001\002\000\052&quot; +
<i>630</i>&nbsp;    &quot;\002\uffdc\004\uffdc\007\uffdc\010\uffdc\012\uffdc\013\uffdc\014&quot; +
<i>631</i>&nbsp;    &quot;\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc&quot; +
<i>632</i>&nbsp;    &quot;\027\uffdc\030\uffdc\031\uffdc\032\uffdc\033\uffdc\042\uffdc\043&quot; +
<i>633</i>&nbsp;    &quot;\uffdc\001\002\000\062\013\uffde\032\uffde\033\uffde\035\uffde&quot; +
<i>634</i>&nbsp;    &quot;\036\uffde\037\uffde\040\uffde\041\uffde\044\uffde\045\uffde\046&quot; +
<i>635</i>&nbsp;    &quot;\uffde\047\uffde\050\uffde\051\uffde\052\uffde\053\uffde\054\uffde&quot; +
<i>636</i>&nbsp;    &quot;\055\uffde\056\uffde\057\uffde\060\uffde\061\uffde\062\uffde\063&quot; +
<i>637</i>&nbsp;    &quot;\uffde\001\002\000\004\034\254\001\002\000\004\014\255&quot; +
<i>638</i>&nbsp;    &quot;\001\002\000\004\034\256\001\002\000\004\012\257\001&quot; +
<i>639</i>&nbsp;    &quot;\002\000\012\002\ufff4\004\ufff4\010\ufff4\021\ufff4\001\002&quot; +
<i>640</i>&nbsp;    &quot;\000\004\034\261\001\002\000\004\012\262\001\002\000&quot; +
<i>641</i>&nbsp;    &quot;\012\002\ufff5\004\ufff5\010\ufff5\021\ufff5\001\002\000\012&quot; +
<i>642</i>&nbsp;    &quot;\002\uffec\004\uffec\010\uffec\021\uffec\001\002\000\062\013&quot; +
<i>643</i>&nbsp;    &quot;\uffdf\032\uffdf\033\uffdf\035\uffdf\036\uffdf\037\uffdf\040\uffdf&quot; +
<i>644</i>&nbsp;    &quot;\041\uffdf\044\uffdf\045\uffdf\046\uffdf\047\uffdf\050\uffdf\051&quot; +
<i>645</i>&nbsp;    &quot;\uffdf\052\uffdf\053\uffdf\054\uffdf\055\uffdf\056\uffdf\057\uffdf&quot; +
<i>646</i>&nbsp;    &quot;\060\uffdf\061\uffdf\062\uffdf\063\uffdf\001\002\000\064\013&quot; +
<i>647</i>&nbsp;    &quot;\027\016\020\032\031\033\040\035\034\036\113\037\141&quot; +
<i>648</i>&nbsp;    &quot;\040\047\041\051\044\015\045\014\046\016\047\036\050&quot; +
<i>649</i>&nbsp;    &quot;\037\051\044\052\025\053\050\054\043\055\041\056\035&quot; +
<i>650</i>&nbsp;    &quot;\057\030\060\045\061\021\062\012\063\042\001\002\000&quot; +
<i>651</i>&nbsp;    &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot; +
<i>652</i>&nbsp;    &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot; +
<i>653</i>&nbsp;    &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot; +
<i>654</i>&nbsp;    &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +
<i>655</i>&nbsp;    &quot;\002\000\006\002\ufff1\010\ufff1\001\002\000\006\002\ufff0&quot; +
<i>656</i>&nbsp;    &quot;\010\ufff0\001\002\000\006\002\ufff7\010\ufff7\001\002\000&quot; +
<i>657</i>&nbsp;    &quot;\014\002\uffe9\004\uffe9\006\055\010\uffe9\021\uffe9\001\002&quot; +
<i>658</i>&nbsp;    &quot;\000\014\002\uffeb\004\uffeb\006\055\010\uffeb\021\uffeb\001&quot; +
<i>659</i>&nbsp;    &quot;\002\000\012\002\uffea\004\uffea\010\uffea\021\uffea\001\002&quot; +
<b class="nc"><i>660</i>&nbsp;    &quot;\000\012\002\uffe8\004\uffe8\010\uffe8\021\uffe8\001\002\000&quot; +</b>
<i>661</i>&nbsp;    &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot; +
<i>662</i>&nbsp;    &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot; +
<b class="nc"><i>663</i>&nbsp;    &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot; +</b>
<b class="nc"><i>664</i>&nbsp;    &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +</b>
<i>665</i>&nbsp;    &quot;\002\000\064\013\027\016\020\032\031\033\040\035\034&quot; +
<i>666</i>&nbsp;    &quot;\036\113\037\141\040\047\041\051\044\015\045\014\046&quot; +
<i>667</i>&nbsp;    &quot;\016\047\036\050\037\051\044\052\025\053\050\054\043&quot; +
<i>668</i>&nbsp;    &quot;\055\041\056\035\057\030\060\045\061\021\062\012\063&quot; +
<i>669</i>&nbsp;    &quot;\042\001\002\000\006\002\ufff9\010\ufff9\001\002\000\006&quot; +
<i>670</i>&nbsp;    &quot;\002\ufff8\010\ufff8\001\002\000\004\034\303\001\002\000&quot; +
<i>671</i>&nbsp;    &quot;\004\012\304\001\002\000\014\002\ufff3\004\ufff3\006\ufff3&quot; +
<i>672</i>&nbsp;    &quot;\010\ufff3\021\ufff3\001\002\000\006\002\ufffb\010\ufffb\001&quot; +
<i>673</i>&nbsp;    &quot;\002\000\070\004\013\013\027\016\020\021\023\032\031&quot; +
<i>674</i>&nbsp;    &quot;\033\040\035\034\036\033\037\046\040\047\041\051\044&quot; +
<i>675</i>&nbsp;    &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot; +
<i>676</i>&nbsp;    &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot; +
<i>677</i>&nbsp;    &quot;\021\062\012\063\042\001\002\000\004\002\ufffd\001\002&quot; +
<i>678</i>&nbsp;    &quot;\000\004\002\uffff\001\002\000\004\002\001\001\002&quot; });
<i>679</i>&nbsp;
<i>680</i>&nbsp;  /** Access to parse-action table. */
<i>681</i>&nbsp;  public short[][] action_table() {return _action_table;}
<i>682</i>&nbsp;
<i>683</i>&nbsp;  /** &lt;code&gt;reduce_goto&lt;/code&gt; table. */
<i>684</i>&nbsp;  protected static final short[][] _reduce_table =
<i>685</i>&nbsp;    unpackFromStrings(new String[] {
<i>686</i>&nbsp;    &quot;\000\307\000\004\003\003\001\001\000\002\001\001\000&quot; +
<i>687</i>&nbsp;    &quot;\070\004\307\006\120\010\127\011\117\012\101\013\075&quot; +
<i>688</i>&nbsp;    &quot;\014\104\015\063\016\111\017\145\020\113\021\125\022&quot; +
<i>689</i>&nbsp;    &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot; +
<i>690</i>&nbsp;    &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot; +
<i>691</i>&nbsp;    &quot;\100\053\077\001\001\000\026\035\016\036\007\037\006&quot; +
<i>692</i>&nbsp;    &quot;\040\031\041\025\042\023\043\052\044\010\047\051\054&quot; +
<i>693</i>&nbsp;    &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>694</i>&nbsp;    &quot;\001\001\000\002\001\001\000\020\040\031\041\304\042&quot; +
<i>695</i>&nbsp;    &quot;\023\043\052\044\010\047\051\054\021\001\001\000\002&quot; +
<i>696</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>697</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\012\040\271&quot; +
<i>698</i>&nbsp;    &quot;\043\272\044\010\047\051\001\001\000\020\040\031\041&quot; +
<i>699</i>&nbsp;    &quot;\270\042\023\043\052\044\010\047\051\054\021\001\001&quot; +
<i>700</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>701</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\002\001\001\000\006&quot; +
<i>702</i>&nbsp;    &quot;\007\053\045\262\001\001\000\002\001\001\000\002\001&quot; +
<i>703</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>704</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>705</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>706</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>707</i>&nbsp;    &quot;\001\000\002\001\001\000\006\007\053\045\055\001\001&quot; +
<i>708</i>&nbsp;    &quot;\000\006\007\053\045\250\001\001\000\070\004\132\006&quot; +
<i>709</i>&nbsp;    &quot;\120\010\127\011\117\012\101\013\075\014\104\015\063&quot; +
<i>710</i>&nbsp;    &quot;\016\111\017\145\020\113\021\125\022\073\023\121\024&quot; +
<i>711</i>&nbsp;    &quot;\143\025\123\026\136\027\146\030\134\031\107\032\072&quot; +
<i>712</i>&nbsp;    &quot;\033\106\034\147\047\150\050\116\052\100\053\077\001&quot; +
<i>713</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>714</i>&nbsp;    &quot;\000\024\011\117\026\136\027\247\030\134\033\106\034&quot; +
<i>715</i>&nbsp;    &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot; +
<i>716</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>717</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\024\011\117\026\136&quot; +
<i>718</i>&nbsp;    &quot;\027\243\030\134\033\106\034\147\047\153\052\100\053&quot; +
<i>719</i>&nbsp;    &quot;\077\001\001\000\070\004\241\006\120\010\127\011\117&quot; +
<i>720</i>&nbsp;    &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot; +
<i>721</i>&nbsp;    &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot; +
<i>722</i>&nbsp;    &quot;\027\146\030\134\031\107\032\072\033\106\034\147\047&quot; +
<i>723</i>&nbsp;    &quot;\150\050\116\052\100\053\077\001\001\000\002\001\001&quot; +
<i>724</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot; +
<i>725</i>&nbsp;    &quot;\127\011\117\020\240\021\125\022\073\023\121\024\143&quot; +
<i>726</i>&nbsp;    &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
<i>727</i>&nbsp;    &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
<i>728</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\010\033\236\034&quot; +
<i>729</i>&nbsp;    &quot;\147\047\153\001\001\000\002\001\001\000\002\001\001&quot; +
<i>730</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>731</i>&nbsp;    &quot;\002\001\001\000\006\007\053\045\214\001\001\000\002&quot; +
<i>732</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>733</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>734</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>735</i>&nbsp;    &quot;\006\007\053\045\177\001\001\000\002\001\001\000\002&quot; +
<i>736</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>737</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>738</i>&nbsp;    &quot;\000\002\001\001\000\006\047\164\051\166\001\001\000&quot; +
<i>739</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>740</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>741</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>742</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>743</i>&nbsp;    &quot;\020\011\155\026\136\033\106\034\147\047\153\052\100&quot; +
<i>744</i>&nbsp;    &quot;\053\077\001\001\000\020\011\154\026\136\033\106\034&quot; +
<i>745</i>&nbsp;    &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot; +
<i>746</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot; +
<i>747</i>&nbsp;    &quot;\127\011\117\020\163\021\125\022\073\023\121\024\143&quot; +
<i>748</i>&nbsp;    &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
<i>749</i>&nbsp;    &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
<i>750</i>&nbsp;    &quot;\000\052\006\120\010\127\011\117\020\162\021\125\022&quot; +
<i>751</i>&nbsp;    &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot; +
<i>752</i>&nbsp;    &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot; +
<i>753</i>&nbsp;    &quot;\100\053\077\001\001\000\052\006\120\010\127\011\117&quot; +
<i>754</i>&nbsp;    &quot;\020\161\021\125\022\073\023\121\024\143\025\123\026&quot; +
<i>755</i>&nbsp;    &quot;\136\027\146\030\134\031\107\032\072\033\106\034\147&quot; +
<i>756</i>&nbsp;    &quot;\047\150\050\116\052\100\053\077\001\001\000\002\001&quot; +
<i>757</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>758</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>759</i>&nbsp;    &quot;\002\001\001\000\024\011\117\026\136\027\174\030\134&quot; +
<i>760</i>&nbsp;    &quot;\033\106\034\147\047\153\052\100\053\077\001\001\000&quot; +
<i>761</i>&nbsp;    &quot;\024\011\117\026\136\027\173\030\134\033\106\034\147&quot; +
<i>762</i>&nbsp;    &quot;\047\153\052\100\053\077\001\001\000\002\001\001\000&quot; +
<i>763</i>&nbsp;    &quot;\002\001\001\000\050\006\120\010\127\011\117\021\125&quot; +
<i>764</i>&nbsp;    &quot;\022\073\023\121\024\176\025\123\026\136\027\146\030&quot; +
<i>765</i>&nbsp;    &quot;\134\031\107\032\072\033\106\034\147\047\150\050\116&quot; +
<i>766</i>&nbsp;    &quot;\052\100\053\077\001\001\000\002\001\001\000\002\001&quot; +
<i>767</i>&nbsp;    &quot;\001\000\074\004\203\005\202\006\120\010\127\011\117&quot; +
<i>768</i>&nbsp;    &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot; +
<i>769</i>&nbsp;    &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot; +
<i>770</i>&nbsp;    &quot;\027\146\030\134\031\107\032\072\033\106\034\147\046&quot; +
<i>771</i>&nbsp;    &quot;\204\047\150\050\116\052\100\053\077\001\001\000\002&quot; +
<i>772</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>773</i>&nbsp;    &quot;\001\000\002\001\001\000\074\004\203\005\202\006\120&quot; +
<i>774</i>&nbsp;    &quot;\010\127\011\117\012\101\013\075\014\104\015\063\016&quot; +
<i>775</i>&nbsp;    &quot;\111\017\145\020\113\021\125\022\073\023\121\024\143&quot; +
<i>776</i>&nbsp;    &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
<i>777</i>&nbsp;    &quot;\106\034\147\046\207\047\150\050\116\052\100\053\077&quot; +
<i>778</i>&nbsp;    &quot;\001\001\000\002\001\001\000\054\006\120\010\127\011&quot; +
<i>779</i>&nbsp;    &quot;\117\017\213\020\113\021\125\022\073\023\121\024\143&quot; +
<i>780</i>&nbsp;    &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
<i>781</i>&nbsp;    &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
<i>782</i>&nbsp;    &quot;\000\054\006\120\010\127\011\117\017\212\020\113\021&quot; +
<i>783</i>&nbsp;    &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot; +
<i>784</i>&nbsp;    &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot; +
<i>785</i>&nbsp;    &quot;\116\052\100\053\077\001\001\000\002\001\001\000\002&quot; +
<i>786</i>&nbsp;    &quot;\001\001\000\002\001\001\000\060\006\120\010\127\011&quot; +
<i>787</i>&nbsp;    &quot;\117\015\230\016\111\017\145\020\113\021\125\022\073&quot; +
<i>788</i>&nbsp;    &quot;\023\121\024\143\025\123\026\136\027\146\030\134\031&quot; +
<i>789</i>&nbsp;    &quot;\107\032\072\033\106\034\147\047\150\050\116\052\100&quot; +
<i>790</i>&nbsp;    &quot;\053\077\001\001\000\060\006\120\010\127\011\117\015&quot; +
<i>791</i>&nbsp;    &quot;\217\016\111\017\145\020\113\021\125\022\073\023\121&quot; +
<i>792</i>&nbsp;    &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot; +
<i>793</i>&nbsp;    &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot; +
<i>794</i>&nbsp;    &quot;\001\001\000\002\001\001\000\056\006\120\010\127\011&quot; +
<i>795</i>&nbsp;    &quot;\117\016\227\017\145\020\113\021\125\022\073\023\121&quot; +
<i>796</i>&nbsp;    &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot; +
<i>797</i>&nbsp;    &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot; +
<i>798</i>&nbsp;    &quot;\001\001\000\056\006\120\010\127\011\117\016\226\017&quot; +
<i>799</i>&nbsp;    &quot;\145\020\113\021\125\022\073\023\121\024\143\025\123&quot; +
<i>800</i>&nbsp;    &quot;\026\136\027\146\030\134\031\107\032\072\033\106\034&quot; +
<i>801</i>&nbsp;    &quot;\147\047\150\050\116\052\100\053\077\001\001\000\056&quot; +
<i>802</i>&nbsp;    &quot;\006\120\010\127\011\117\016\225\017\145\020\113\021&quot; +
<i>803</i>&nbsp;    &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot; +
<i>804</i>&nbsp;    &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot; +
<i>805</i>&nbsp;    &quot;\116\052\100\053\077\001\001\000\056\006\120\010\127&quot; +
<i>806</i>&nbsp;    &quot;\011\117\016\224\017\145\020\113\021\125\022\073\023&quot; +
<i>807</i>&nbsp;    &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot; +
<i>808</i>&nbsp;    &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot; +
<i>809</i>&nbsp;    &quot;\077\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>810</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\064\006&quot; +
<i>811</i>&nbsp;    &quot;\120\010\127\011\117\013\232\014\104\015\063\016\111&quot; +
<i>812</i>&nbsp;    &quot;\017\145\020\113\021\125\022\073\023\121\024\143\025&quot; +
<i>813</i>&nbsp;    &quot;\123\026\136\027\146\030\134\031\107\032\072\033\106&quot; +
<i>814</i>&nbsp;    &quot;\034\147\047\150\050\116\052\100\053\077\001\001\000&quot; +
<i>815</i>&nbsp;    &quot;\002\001\001\000\062\006\120\010\127\011\117\014\234&quot; +
<i>816</i>&nbsp;    &quot;\015\063\016\111\017\145\020\113\021\125\022\073\023&quot; +
<i>817</i>&nbsp;    &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot; +
<i>818</i>&nbsp;    &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot; +
<i>819</i>&nbsp;    &quot;\077\001\001\000\002\001\001\000\002\001\001\000\006&quot; +
<i>820</i>&nbsp;    &quot;\007\053\045\237\001\001\000\002\001\001\000\002\001&quot; +
<b class="nc"><i>821</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +</b>
<i>822</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>823</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>824</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>825</i>&nbsp;    &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
<i>826</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
<i>827</i>&nbsp;    &quot;\020\040\031\041\267\042\023\043\052\044\010\047\051&quot; +
<i>828</i>&nbsp;    &quot;\054\021\001\001\000\020\040\031\041\266\042\023\043&quot; +
<b class="nc"><i>829</i>&nbsp;    &quot;\052\044\010\047\051\054\021\001\001\000\002\001\001&quot; +</b>
<i>830</i>&nbsp;    &quot;\000\002\001\001\000\002\001\001\000\006\007\053\045&quot; +
<i>831</i>&nbsp;    &quot;\274\001\001\000\006\007\053\045\273\001\001\000\002&quot; +
<i>832</i>&nbsp;    &quot;\001\001\000\002\001\001\000\020\040\031\041\300\042&quot; +
<i>833</i>&nbsp;    &quot;\023\043\052\044\010\047\051\054\021\001\001\000\020&quot; +
<i>834</i>&nbsp;    &quot;\040\031\041\277\042\023\043\052\044\010\047\051\054&quot; +
<i>835</i>&nbsp;    &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
<i>836</i>&nbsp;    &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
<i>837</i>&nbsp;    &quot;\001\000\026\035\016\036\306\037\006\040\031\041\025&quot; +
<i>838</i>&nbsp;    &quot;\042\023\043\052\044\010\047\051\054\021\001\001\000&quot; +
<i>839</i>&nbsp;    &quot;\002\001\001\000\002\001\001\000\002\001\001&quot; });
<i>840</i>&nbsp;
<b class="nc"><i>841</i>&nbsp;  /** Access to &lt;code&gt;reduce_goto&lt;/code&gt; table. */</b>
<i>842</i>&nbsp;  public short[][] reduce_table() {return _reduce_table;}
<i>843</i>&nbsp;
<i>844</i>&nbsp;  /** Instance of action encapsulation class. */
<b class="nc"><i>845</i>&nbsp;  protected parser_actions action_obj;</b>
<i>846</i>&nbsp;
<b class="nc"><i>847</i>&nbsp;  /** Action encapsulation object initializer. */</b>
<i>848</i>&nbsp;  protected void init_actions()
<i>849</i>&nbsp;    {
<b class="nc"><i>850</i>&nbsp;      action_obj = new parser_actions(this);</b>
<i>851</i>&nbsp;    }
<i>852</i>&nbsp;
<b class="nc"><i>853</i>&nbsp;  /** Invoke a user supplied parse action. */</b>
<i>854</i>&nbsp;  public Symbol do_action(
<i>855</i>&nbsp;    int                        act_num,
<i>856</i>&nbsp;    lr_parser parser,
<i>857</i>&nbsp;    Stack&lt;Symbol&gt;            stack,
<i>858</i>&nbsp;    int                        top)
<i>859</i>&nbsp;    throws java.lang.Exception
<b class="nc"><i>860</i>&nbsp;  {</b>
<i>861</i>&nbsp;    /* call code in generated class */
<i>862</i>&nbsp;    return action_obj.parser_do_action(act_num, parser, stack, top);
<i>863</i>&nbsp;  }
<i>864</i>&nbsp;
<b class="nc"><i>865</i>&nbsp;  /** Indicates start state. */</b>
<i>866</i>&nbsp;  public int start_state() {return 0;}
<i>867</i>&nbsp;  /** Indicates start production. */
<i>868</i>&nbsp;  public int start_production() {return 0;}
<i>869</i>&nbsp;
<i>870</i>&nbsp;  /** &lt;code&gt;EOF&lt;/code&gt; Symbol index. */
<i>871</i>&nbsp;  public int EOF_sym() {return 0;}
<i>872</i>&nbsp;
<i>873</i>&nbsp;  /** &lt;code&gt;error&lt;/code&gt; Symbol index. */
<i>874</i>&nbsp;  public int error_sym() {return 1;}
<i>875</i>&nbsp;
<i>876</i>&nbsp;
<i>877</i>&nbsp;
<i>878</i>&nbsp;    /**
<i>879</i>&nbsp;     * Used by function calls with no args.
<i>880</i>&nbsp;     */
<b class="nc"><i>881</i>&nbsp;    static public final List&lt;Expression&gt; EmptyArgs = new ArrayList&lt;&gt;(0);</b>
<i>882</i>&nbsp;
<i>883</i>&nbsp;    /**
<i>884</i>&nbsp;     * Reference to non-existing variable.
<i>885</i>&nbsp;     */
<i>886</i>&nbsp;    static public final VariableRef DummyVarRef = null;
<i>887</i>&nbsp;
<b class="nc"><i>888</i>&nbsp;    /**</b>
<b class="nc"><i>889</i>&nbsp;     * Reference to the Parser class.</b>
<b class="nc"><i>890</i>&nbsp;     */</b>
<b class="nc"><i>891</i>&nbsp;    private Parser _parser;</b>
<i>892</i>&nbsp;    private XSLTC  _xsltc;
<i>893</i>&nbsp;
<i>894</i>&nbsp;    /**
<b class="nc"><i>895</i>&nbsp;     * String representation of the expression being parsed.</b>
<i>896</i>&nbsp;     */
<i>897</i>&nbsp;    private String _expression;
<i>898</i>&nbsp;
<b class="nc"><i>899</i>&nbsp;    /**</b>
<i>900</i>&nbsp;     * Line number where this expression/pattern was declared.
<i>901</i>&nbsp;     */
<i>902</i>&nbsp;    private int _lineNumber = 0;
<b class="nc"><i>903</i>&nbsp;</b>
<i>904</i>&nbsp;    /**
<i>905</i>&nbsp;     * Reference to the symbol table.
<i>906</i>&nbsp;     */
<b class="nc"><i>907</i>&nbsp;    public SymbolTable _symbolTable;</b>
<i>908</i>&nbsp;
<i>909</i>&nbsp;    public XPathParser(Parser parser) {
<i>910</i>&nbsp;        _parser = parser;
<b class="nc"><i>911</i>&nbsp;        _xsltc = parser.getXSLTC();</b>
<i>912</i>&nbsp;        _symbolTable = parser.getSymbolTable();
<i>913</i>&nbsp;    }
<i>914</i>&nbsp;
<b class="nc"><i>915</i>&nbsp;    public int getLineNumber() {</b>
<i>916</i>&nbsp;        return _lineNumber;
<i>917</i>&nbsp;    }
<i>918</i>&nbsp;
<i>919</i>&nbsp;    public QName getQNameIgnoreDefaultNs(String name) {
<i>920</i>&nbsp;          return _parser.getQNameIgnoreDefaultNs(name);
<i>921</i>&nbsp;    }
<i>922</i>&nbsp;
<i>923</i>&nbsp;    public QName getQName(String namespace, String prefix, String localname) {
<i>924</i>&nbsp;        return _parser.getQName(namespace, prefix, localname);
<i>925</i>&nbsp;    }
<i>926</i>&nbsp;
<i>927</i>&nbsp;    public void setMultiDocument(boolean flag) {
<i>928</i>&nbsp;          _xsltc.setMultiDocument(flag);
<i>929</i>&nbsp;    }
<i>930</i>&nbsp;
<i>931</i>&nbsp;    public void setCallsNodeset(boolean flag) {
<b class="nc"><i>932</i>&nbsp;          _xsltc.setCallsNodeset(flag);</b>
<b class="nc"><i>933</i>&nbsp;    }</b>
<i>934</i>&nbsp;
<i>935</i>&nbsp;    public void setHasIdCall(boolean flag) {
<b class="nc"><i>936</i>&nbsp;          _xsltc.setHasIdCall(flag);</b>
<i>937</i>&nbsp;    }
<b class="nc"><i>938</i>&nbsp;</b>
<b class="nc"><i>939</i>&nbsp;</b>
<i>940</i>&nbsp;    /**
<b class="nc"><i>941</i>&nbsp;     * This method is similar to findNodeType(int, Object) except that it</b>
<i>942</i>&nbsp;     * creates a StepPattern instead of just returning a node type. It also
<i>943</i>&nbsp;     * differs in the way it handles &quot;{uri}:*&quot; and &quot;{uri}:@*&quot;. The last two
<b class="nc"><i>944</i>&nbsp;     * patterns are expanded as &quot;*[namespace-uri() = &#39;uri&#39;]&quot; and</b>
<b class="nc"><i>945</i>&nbsp;     * &quot;@*[namespace-uri() = &#39;uri&#39;]&quot;, respectively. This expansion considerably</b>
<i>946</i>&nbsp;     * simplifies the grouping of patterns in the Mode class. For this
<b class="nc"><i>947</i>&nbsp;     * expansion to be correct, the priority of the pattern/template must be</b>
<b class="nc"><i>948</i>&nbsp;     * set to -0.25 (when no other predicates are present).</b>
<b class="nc"><i>949</i>&nbsp;     */</b>
<i>950</i>&nbsp;    public StepPattern createStepPattern(int axis, Object test, List&lt;Predicate&gt; predicates) {
<i>951</i>&nbsp;        int nodeType;
<b class="nc"><i>952</i>&nbsp;</b>
<b class="nc"><i>953</i>&nbsp;        if (test == null) {  // &quot;*&quot;</b>
<b class="nc"><i>954</i>&nbsp;            nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE :</b>
<b class="nc"><i>955</i>&nbsp;                (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;</b>
<i>956</i>&nbsp;
<i>957</i>&nbsp;            return new StepPattern(axis, nodeType, predicates);
<b class="nc"><i>958</i>&nbsp;        }</b>
<b class="nc"><i>959</i>&nbsp;        else if (test instanceof Integer) {</b>
<b class="nc"><i>960</i>&nbsp;            nodeType = ((Integer) test).intValue();</b>
<i>961</i>&nbsp;
<i>962</i>&nbsp;            return new StepPattern(axis, nodeType, predicates);
<i>963</i>&nbsp;        }
<b class="nc"><i>964</i>&nbsp;        else {</b>
<i>965</i>&nbsp;            QName name = (QName)test;
<b class="nc"><i>966</i>&nbsp;            boolean setPriority = false;</b>
<i>967</i>&nbsp;
<i>968</i>&nbsp;            if (axis == Axis.NAMESPACE) {
<i>969</i>&nbsp;                nodeType = (name.toString().equals(&quot;*&quot;)) ? -1
<i>970</i>&nbsp;                                : _xsltc.registerNamespacePrefix(name);;
<i>971</i>&nbsp;            }
<i>972</i>&nbsp;            else {
<b class="nc"><i>973</i>&nbsp;                final String uri = name.getNamespace();</b>
<b class="nc"><i>974</i>&nbsp;                final String local = name.getLocalPart();</b>
<i>975</i>&nbsp;                final QName namespace_uri =
<i>976</i>&nbsp;                    _parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;);
<b class="nc"><i>977</i>&nbsp;</b>
<b class="nc"><i>978</i>&nbsp;                // Expand {uri}:* to *[namespace-uri() = &#39;uri&#39;] - same for @*</b>
<i>979</i>&nbsp;                if (uri != null &amp;&amp; (local.equals(&quot;*&quot;) || local.equals(&quot;@*&quot;))) {
<i>980</i>&nbsp;                    if (predicates == null) {
<b class="nc"><i>981</i>&nbsp;                        predicates = new ArrayList&lt;&gt;(2);</b>
<b class="nc"><i>982</i>&nbsp;                    }</b>
<i>983</i>&nbsp;
<i>984</i>&nbsp;                    // Priority is set by hand if no other predicates exist
<i>985</i>&nbsp;                    setPriority = (predicates.size() == 0);
<b class="nc"><i>986</i>&nbsp;</b>
<i>987</i>&nbsp;                    predicates.add(
<i>988</i>&nbsp;                        new Predicate(
<b class="nc"><i>989</i>&nbsp;                            new EqualityExpr(Operators.EQ,</b>
<b class="nc"><i>990</i>&nbsp;                                new NamespaceUriCall(namespace_uri),</b>
<i>991</i>&nbsp;                                new LiteralExpr(uri))));
<i>992</i>&nbsp;                }
<b class="nc"><i>993</i>&nbsp;</b>
<i>994</i>&nbsp;                if (local.equals(&quot;*&quot;)) {
<i>995</i>&nbsp;                    nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
<i>996</i>&nbsp;                        : NodeTest.ELEMENT;
<i>997</i>&nbsp;                }
<b class="nc"><i>998</i>&nbsp;                else if (local.equals(&quot;@*&quot;)) {</b>
<b class="nc"><i>999</i>&nbsp;                    nodeType = NodeTest.ATTRIBUTE;</b>
<i>1000</i>&nbsp;                }
<i>1001</i>&nbsp;                else {
<i>1002</i>&nbsp;                    nodeType = (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
<b class="nc"><i>1003</i>&nbsp;                        : _xsltc.registerElement(name);</b>
<b class="nc"><i>1004</i>&nbsp;                }</b>
<i>1005</i>&nbsp;            }
<i>1006</i>&nbsp;
<b class="nc"><i>1007</i>&nbsp;            final StepPattern result = new StepPattern(axis, nodeType, predicates);</b>
<i>1008</i>&nbsp;
<b class="nc"><i>1009</i>&nbsp;            // Set priority for case prefix:* and prefix:@* (no predicates)</b>
<b class="nc"><i>1010</i>&nbsp;            if (setPriority) {</b>
<b class="nc"><i>1011</i>&nbsp;                result.setPriority(-0.25);</b>
<i>1012</i>&nbsp;            }
<i>1013</i>&nbsp;
<b class="nc"><i>1014</i>&nbsp;            return result;</b>
<b class="nc"><i>1015</i>&nbsp;        }</b>
<i>1016</i>&nbsp;    }
<b class="nc"><i>1017</i>&nbsp;</b>
<b class="nc"><i>1018</i>&nbsp;    public int findNodeType(int axis, Object test) {</b>
<i>1019</i>&nbsp;        if (test == null) {  // *
<i>1020</i>&nbsp;            return (axis == Axis.ATTRIBUTE) ?
<b class="nc"><i>1021</i>&nbsp;                NodeTest.ATTRIBUTE :</b>
<b class="nc"><i>1022</i>&nbsp;                (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;</b>
<i>1023</i>&nbsp;        }
<i>1024</i>&nbsp;        else if (test instanceof Integer) {
<i>1025</i>&nbsp;            return ((Integer)test).intValue();
<b class="nc"><i>1026</i>&nbsp;        }</b>
<b class="nc"><i>1027</i>&nbsp;        else {</b>
<i>1028</i>&nbsp;            QName name = (QName)test;
<i>1029</i>&nbsp;
<i>1030</i>&nbsp;            if (axis == Axis.NAMESPACE) {
<i>1031</i>&nbsp;                return (name.toString().equals(&quot;*&quot;)) ? -1
<i>1032</i>&nbsp;                    : _xsltc.registerNamespacePrefix(name);
<i>1033</i>&nbsp;            }
<i>1034</i>&nbsp;
<i>1035</i>&nbsp;            if (name.getNamespace() == null) {
<i>1036</i>&nbsp;                final String local = name.getLocalPart();
<i>1037</i>&nbsp;
<i>1038</i>&nbsp;                if (local.equals(&quot;*&quot;)) {
<i>1039</i>&nbsp;                    return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
<i>1040</i>&nbsp;                        : NodeTest.ELEMENT;
<i>1041</i>&nbsp;                }
<i>1042</i>&nbsp;                else if (local.equals(&quot;@*&quot;)) {
<i>1043</i>&nbsp;                    return NodeTest.ATTRIBUTE;
<b class="nc"><i>1044</i>&nbsp;                }</b>
<b class="nc"><i>1045</i>&nbsp;            }</b>
<b class="nc"><i>1046</i>&nbsp;</b>
<i>1047</i>&nbsp;            return (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
<b class="nc"><i>1048</i>&nbsp;                : _xsltc.registerElement(name);</b>
<b class="nc"><i>1049</i>&nbsp;        }</b>
<b class="nc"><i>1050</i>&nbsp;    }</b>
<b class="nc"><i>1051</i>&nbsp;</b>
<i>1052</i>&nbsp;    /**
<b class="nc"><i>1053</i>&nbsp;     * Parse the expression passed to the current scanner. If this</b>
<i>1054</i>&nbsp;     * expression contains references to local variables and it will be
<i>1055</i>&nbsp;     * compiled in an external module (not in the main class) request
<i>1056</i>&nbsp;     * the current template to create a new variable stack frame.
<i>1057</i>&nbsp;     *
<i>1058</i>&nbsp;     * @param lineNumber Line where the current expression is defined.
<i>1059</i>&nbsp;     * @param external   Set to &lt;tt&gt;true&lt;/tt&gt; if this expression is
<i>1060</i>&nbsp;     *                   compiled in a separate module.
<i>1061</i>&nbsp;     *
<i>1062</i>&nbsp;     */
<b class="nc"><i>1063</i>&nbsp;    public Symbol parse(String expression, int lineNumber) throws Exception {</b>
<b class="nc"><i>1064</i>&nbsp;        try {</b>
<b class="nc"><i>1065</i>&nbsp;            _expression = expression;</b>
<i>1066</i>&nbsp;            _lineNumber = lineNumber;
<b class="nc"><i>1067</i>&nbsp;            return super.parse();</b>
<i>1068</i>&nbsp;        }
<i>1069</i>&nbsp;        catch (IllegalCharException e) {
<i>1070</i>&nbsp;            ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_CHAR_ERR,
<b class="nc"><i>1071</i>&nbsp;                                        lineNumber, e.getMessage());</b>
<i>1072</i>&nbsp;            _parser.reportError(Constants.FATAL, err);
<i>1073</i>&nbsp;        }
<i>1074</i>&nbsp;        return null;
<b class="nc"><i>1075</i>&nbsp;    }</b>
<i>1076</i>&nbsp;
<b class="nc"><i>1077</i>&nbsp;    /**</b>
<i>1078</i>&nbsp;     * Lookup a variable or parameter in the symbol table given its name.
<i>1079</i>&nbsp;     *
<i>1080</i>&nbsp;     * @param name Name of the symbol being looked up.
<i>1081</i>&nbsp;     */
<i>1082</i>&nbsp;    final SyntaxTreeNode lookupName(QName name) {
<i>1083</i>&nbsp;        // Is it a local var or param ?
<i>1084</i>&nbsp;        final SyntaxTreeNode result = _parser.lookupVariable(name);
<b class="nc"><i>1085</i>&nbsp;        if (result != null)</b>
<b class="nc"><i>1086</i>&nbsp;            return(result);</b>
<i>1087</i>&nbsp;        else
<b class="nc"><i>1088</i>&nbsp;            return(_symbolTable.lookupName(name));</b>
<b class="nc"><i>1089</i>&nbsp;    }</b>
<b class="nc"><i>1090</i>&nbsp;</b>
<b class="nc"><i>1091</i>&nbsp;    public final void addError(ErrorMsg error) {</b>
<i>1092</i>&nbsp;        _parser.reportError(Constants.ERROR, error);
<i>1093</i>&nbsp;    }
<b class="nc"><i>1094</i>&nbsp;</b>
<b class="nc"><i>1095</i>&nbsp;    public void report_error(String message, Object info) {</b>
<i>1096</i>&nbsp;        final ErrorMsg err = new ErrorMsg(ErrorMsg.SYNTAX_ERR, _lineNumber,
<i>1097</i>&nbsp;            _expression);
<i>1098</i>&nbsp;        _parser.reportError(Constants.FATAL, err);
<i>1099</i>&nbsp;    }
<i>1100</i>&nbsp;
<i>1101</i>&nbsp;    public void report_fatal_error(String message, Object info) {
<i>1102</i>&nbsp;        // empty
<i>1103</i>&nbsp;    }
<i>1104</i>&nbsp;
<b class="nc"><i>1105</i>&nbsp;    public RelativeLocationPath insertStep(Step step, RelativeLocationPath rlp) {</b>
<i>1106</i>&nbsp;        if (rlp instanceof Step) {
<i>1107</i>&nbsp;            return new ParentLocationPath(step, (Step) rlp);
<i>1108</i>&nbsp;        }
<i>1109</i>&nbsp;        else if (rlp instanceof ParentLocationPath) {
<i>1110</i>&nbsp;            final ParentLocationPath plp = (ParentLocationPath) rlp;
<i>1111</i>&nbsp;            final RelativeLocationPath newrlp = insertStep(step, plp.getPath());
<i>1112</i>&nbsp;            return new ParentLocationPath(newrlp, plp.getStep());
<i>1113</i>&nbsp;        }
<i>1114</i>&nbsp;        else {
<i>1115</i>&nbsp;            addError(new ErrorMsg(ErrorMsg.INTERNAL_ERR, &quot;XPathParser.insertStep&quot;));
<i>1116</i>&nbsp;            return rlp;
<i>1117</i>&nbsp;        }
<i>1118</i>&nbsp;    }
<i>1119</i>&nbsp;
<i>1120</i>&nbsp;    /**
<i>1121</i>&nbsp;     * Returns true if the axis applies to elements only. The axes
<i>1122</i>&nbsp;     * child, attribute, namespace, descendant result in non-empty
<i>1123</i>&nbsp;     * nodesets only if the context node is of type element.
<i>1124</i>&nbsp;     */
<i>1125</i>&nbsp;    public boolean isElementAxis(int axis) {
<i>1126</i>&nbsp;        return (axis == Axis.CHILD || axis == Axis.ATTRIBUTE ||
<i>1127</i>&nbsp;                axis == Axis.NAMESPACE || axis == Axis.DESCENDANT);
<i>1128</i>&nbsp;    }
<i>1129</i>&nbsp;
<i>1130</i>&nbsp;}
<i>1131</i>&nbsp;
<i>1132</i>&nbsp;/** Cup generated class to encapsulate user supplied action code.*/
<i>1133</i>&nbsp;class parser_actions {
<i>1134</i>&nbsp;  private final XPathParser parser;
<i>1135</i>&nbsp;
<i>1136</i>&nbsp;  /** Constructor */
<i>1137</i>&nbsp;  parser_actions(XPathParser parser) {
<i>1138</i>&nbsp;    this.parser = parser;
<i>1139</i>&nbsp;  }
<i>1140</i>&nbsp;
<i>1141</i>&nbsp;  /** Method with the actual generated action code. */
<i>1142</i>&nbsp;  public final Symbol parser_do_action(
<i>1143</i>&nbsp;    int                        parser_act_num,
<i>1144</i>&nbsp;    lr_parser parser_parser,
<i>1145</i>&nbsp;    Stack&lt;Symbol&gt;            parser_stack,
<i>1146</i>&nbsp;    int                        parser_top)
<i>1147</i>&nbsp;    throws java.lang.Exception
<i>1148</i>&nbsp;    {
<i>1149</i>&nbsp;      /* Symbol object for return from actions */
<i>1150</i>&nbsp;      Symbol parser_result;
<i>1151</i>&nbsp;
<i>1152</i>&nbsp;      /* select the action based on the action number */
<i>1153</i>&nbsp;      switch (parser_act_num)
<i>1154</i>&nbsp;        {
<i>1155</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1156</i>&nbsp;          case 140: // QName ::= ID
<i>1157</i>&nbsp;            {
<i>1158</i>&nbsp;              QName RESULT = null;
<i>1159</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;id&quot;);
<i>1160</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1161</i>&nbsp;            }
<i>1162</i>&nbsp;          return parser_result;
<i>1163</i>&nbsp;
<i>1164</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1165</i>&nbsp;          case 139: // QName ::= SELF
<i>1166</i>&nbsp;            {
<i>1167</i>&nbsp;              QName RESULT = null;
<i>1168</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;self&quot;);
<i>1169</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1170</i>&nbsp;            }
<i>1171</i>&nbsp;          return parser_result;
<i>1172</i>&nbsp;
<i>1173</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1174</i>&nbsp;          case 138: // QName ::= PRECEDINGSIBLING
<i>1175</i>&nbsp;            {
<i>1176</i>&nbsp;              QName RESULT = null;
<i>1177</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;preceding-sibling&quot;);
<i>1178</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1179</i>&nbsp;            }
<i>1180</i>&nbsp;          return parser_result;
<i>1181</i>&nbsp;
<i>1182</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1183</i>&nbsp;          case 137: // QName ::= PRECEDING
<i>1184</i>&nbsp;            {
<i>1185</i>&nbsp;              QName RESULT = null;
<i>1186</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;preceding&quot;);
<i>1187</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1188</i>&nbsp;            }
<i>1189</i>&nbsp;          return parser_result;
<i>1190</i>&nbsp;
<i>1191</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1192</i>&nbsp;          case 136: // QName ::= PARENT
<i>1193</i>&nbsp;            {
<i>1194</i>&nbsp;              QName RESULT = null;
<i>1195</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;parent&quot;);
<i>1196</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1197</i>&nbsp;            }
<i>1198</i>&nbsp;          return parser_result;
<i>1199</i>&nbsp;
<i>1200</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1201</i>&nbsp;          case 135: // QName ::= NAMESPACE
<i>1202</i>&nbsp;            {
<i>1203</i>&nbsp;              QName RESULT = null;
<i>1204</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;namespace&quot;);
<i>1205</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1206</i>&nbsp;            }
<i>1207</i>&nbsp;          return parser_result;
<i>1208</i>&nbsp;
<i>1209</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1210</i>&nbsp;          case 134: // QName ::= FOLLOWINGSIBLING
<i>1211</i>&nbsp;            {
<i>1212</i>&nbsp;              QName RESULT = null;
<i>1213</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;following-sibling&quot;);
<i>1214</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1215</i>&nbsp;            }
<i>1216</i>&nbsp;          return parser_result;
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1219</i>&nbsp;          case 133: // QName ::= FOLLOWING
<i>1220</i>&nbsp;            {
<i>1221</i>&nbsp;              QName RESULT = null;
<i>1222</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;following&quot;);
<i>1223</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1224</i>&nbsp;            }
<i>1225</i>&nbsp;          return parser_result;
<i>1226</i>&nbsp;
<i>1227</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1228</i>&nbsp;          case 132: // QName ::= DESCENDANTORSELF
<i>1229</i>&nbsp;            {
<i>1230</i>&nbsp;              QName RESULT = null;
<i>1231</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;decendant-or-self&quot;);
<i>1232</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1233</i>&nbsp;            }
<i>1234</i>&nbsp;          return parser_result;
<i>1235</i>&nbsp;
<i>1236</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1237</i>&nbsp;          case 131: // QName ::= DESCENDANT
<i>1238</i>&nbsp;            {
<i>1239</i>&nbsp;              QName RESULT = null;
<i>1240</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;decendant&quot;);
<i>1241</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1242</i>&nbsp;            }
<i>1243</i>&nbsp;          return parser_result;
<i>1244</i>&nbsp;
<i>1245</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1246</i>&nbsp;          case 130: // QName ::= CHILD
<i>1247</i>&nbsp;            {
<i>1248</i>&nbsp;              QName RESULT = null;
<i>1249</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
<i>1250</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1251</i>&nbsp;            }
<i>1252</i>&nbsp;          return parser_result;
<i>1253</i>&nbsp;
<i>1254</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1255</i>&nbsp;          case 129: // QName ::= ATTRIBUTE
<i>1256</i>&nbsp;            {
<i>1257</i>&nbsp;              QName RESULT = null;
<i>1258</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;attribute&quot;);
<i>1259</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1260</i>&nbsp;            }
<i>1261</i>&nbsp;          return parser_result;
<i>1262</i>&nbsp;
<i>1263</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1264</i>&nbsp;          case 128: // QName ::= ANCESTORORSELF
<i>1265</i>&nbsp;            {
<i>1266</i>&nbsp;              QName RESULT = null;
<i>1267</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;ancestor-or-self&quot;);
<i>1268</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1269</i>&nbsp;            }
<i>1270</i>&nbsp;          return parser_result;
<i>1271</i>&nbsp;
<i>1272</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1273</i>&nbsp;          case 127: // QName ::= ANCESTOR
<i>1274</i>&nbsp;            {
<i>1275</i>&nbsp;              QName RESULT = null;
<i>1276</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
<i>1277</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1278</i>&nbsp;            }
<i>1279</i>&nbsp;          return parser_result;
<i>1280</i>&nbsp;
<i>1281</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1282</i>&nbsp;          case 126: // QName ::= KEY
<i>1283</i>&nbsp;            {
<i>1284</i>&nbsp;              QName RESULT = null;
<i>1285</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;key&quot;);
<i>1286</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1287</i>&nbsp;            }
<i>1288</i>&nbsp;          return parser_result;
<i>1289</i>&nbsp;
<i>1290</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1291</i>&nbsp;          case 125: // QName ::= MOD
<i>1292</i>&nbsp;            {
<i>1293</i>&nbsp;              QName RESULT = null;
<i>1294</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;mod&quot;);
<i>1295</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1296</i>&nbsp;            }
<i>1297</i>&nbsp;          return parser_result;
<i>1298</i>&nbsp;
<i>1299</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1300</i>&nbsp;          case 124: // QName ::= DIV
<i>1301</i>&nbsp;            {
<i>1302</i>&nbsp;              QName RESULT = null;
<i>1303</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(&quot;div&quot;);
<i>1304</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1305</i>&nbsp;            }
<i>1306</i>&nbsp;          return parser_result;
<i>1307</i>&nbsp;
<i>1308</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1309</i>&nbsp;          case 123: // QName ::= QNAME
<i>1310</i>&nbsp;            {
<i>1311</i>&nbsp;              QName RESULT = null;
<i>1312</i>&nbsp;                int qnameleft = (parser_stack.get(parser_top-0)).left;
<i>1313</i>&nbsp;                int qnameright = (parser_stack.get(parser_top-0)).right;
<i>1314</i>&nbsp;                String qname = (String)(parser_stack.get(parser_top-0)).value;
<i>1315</i>&nbsp;                 RESULT = parser.getQNameIgnoreDefaultNs(qname);
<i>1316</i>&nbsp;              parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1317</i>&nbsp;            }
<i>1318</i>&nbsp;          return parser_result;
<i>1319</i>&nbsp;
<i>1320</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1321</i>&nbsp;          case 122: // NameTest ::= QName
<i>1322</i>&nbsp;            {
<i>1323</i>&nbsp;              Object RESULT = null;
<i>1324</i>&nbsp;                int qnleft = (parser_stack.get(parser_top-0)).left;
<i>1325</i>&nbsp;                int qnright = (parser_stack.get(parser_top-0)).right;
<i>1326</i>&nbsp;                QName qn = (QName)(parser_stack.get(parser_top-0)).value;
<i>1327</i>&nbsp;                 RESULT = qn;
<i>1328</i>&nbsp;              parser_result = new Symbol(26/*NameTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1329</i>&nbsp;            }
<i>1330</i>&nbsp;          return parser_result;
<i>1331</i>&nbsp;
<i>1332</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1333</i>&nbsp;          case 121: // NameTest ::= STAR
<i>1334</i>&nbsp;            {
<i>1335</i>&nbsp;              Object RESULT = null;
<i>1336</i>&nbsp;                 RESULT = null;
<i>1337</i>&nbsp;              parser_result = new Symbol(26/*NameTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1338</i>&nbsp;            }
<i>1339</i>&nbsp;          return parser_result;
<i>1340</i>&nbsp;
<i>1341</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1342</i>&nbsp;          case 120: // NodeTest ::= PI
<i>1343</i>&nbsp;            {
<i>1344</i>&nbsp;              Object RESULT = null;
<i>1345</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.PI);
<i>1346</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1347</i>&nbsp;            }
<i>1348</i>&nbsp;          return parser_result;
<i>1349</i>&nbsp;
<i>1350</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1351</i>&nbsp;          case 119: // NodeTest ::= PIPARAM LPAREN Literal RPAREN
<i>1352</i>&nbsp;            {
<i>1353</i>&nbsp;              Object RESULT = null;
<i>1354</i>&nbsp;                int lleft = (parser_stack.get(parser_top-1)).left;
<i>1355</i>&nbsp;                int lright = (parser_stack.get(parser_top-1)).right;
<i>1356</i>&nbsp;                String l = (String)(parser_stack.get(parser_top-1)).value;
<i>1357</i>&nbsp;
<i>1358</i>&nbsp;           QName name = parser.getQNameIgnoreDefaultNs(&quot;name&quot;);
<i>1359</i>&nbsp;           Expression exp = new EqualityExpr(Operators.EQ,
<i>1360</i>&nbsp;                                             new NameCall(name),
<i>1361</i>&nbsp;                                             new LiteralExpr(l));
<i>1362</i>&nbsp;           List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
<i>1363</i>&nbsp;           predicates.add(new Predicate(exp));
<i>1364</i>&nbsp;           RESULT = new Step(Axis.CHILD, NodeTest.PI, predicates);
<i>1365</i>&nbsp;
<i>1366</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1367</i>&nbsp;            }
<i>1368</i>&nbsp;          return parser_result;
<i>1369</i>&nbsp;
<i>1370</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1371</i>&nbsp;          case 118: // NodeTest ::= COMMENT
<i>1372</i>&nbsp;            {
<i>1373</i>&nbsp;              Object RESULT = null;
<i>1374</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.COMMENT);
<i>1375</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1376</i>&nbsp;            }
<i>1377</i>&nbsp;          return parser_result;
<i>1378</i>&nbsp;
<i>1379</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1380</i>&nbsp;          case 117: // NodeTest ::= TEXT
<i>1381</i>&nbsp;            {
<i>1382</i>&nbsp;              Object RESULT = null;
<i>1383</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.TEXT);
<i>1384</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1385</i>&nbsp;            }
<i>1386</i>&nbsp;          return parser_result;
<i>1387</i>&nbsp;
<i>1388</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1389</i>&nbsp;          case 116: // NodeTest ::= NODE
<i>1390</i>&nbsp;            {
<i>1391</i>&nbsp;              Object RESULT = null;
<i>1392</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.ANODE);
<i>1393</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1394</i>&nbsp;            }
<i>1395</i>&nbsp;          return parser_result;
<i>1396</i>&nbsp;
<i>1397</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1398</i>&nbsp;          case 115: // NodeTest ::= NameTest
<i>1399</i>&nbsp;            {
<i>1400</i>&nbsp;              Object RESULT = null;
<i>1401</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-0)).left;
<i>1402</i>&nbsp;                int ntright = (parser_stack.get(parser_top-0)).right;
<i>1403</i>&nbsp;                Object nt = parser_stack.get(parser_top-0).value;
<i>1404</i>&nbsp;                 RESULT = nt;
<i>1405</i>&nbsp;              parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1406</i>&nbsp;            }
<i>1407</i>&nbsp;          return parser_result;
<i>1408</i>&nbsp;
<i>1409</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1410</i>&nbsp;          case 114: // Argument ::= Expr
<i>1411</i>&nbsp;            {
<i>1412</i>&nbsp;              Expression RESULT = null;
<i>1413</i>&nbsp;                int exleft = (parser_stack.get(parser_top-0)).left;
<i>1414</i>&nbsp;                int exright = (parser_stack.get(parser_top-0)).right;
<i>1415</i>&nbsp;                Expression ex = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1416</i>&nbsp;                 RESULT = ex;
<i>1417</i>&nbsp;              parser_result = new Symbol(3/*Argument*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1418</i>&nbsp;            }
<i>1419</i>&nbsp;          return parser_result;
<i>1420</i>&nbsp;
<i>1421</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1422</i>&nbsp;          case 113: // VariableName ::= QName
<i>1423</i>&nbsp;            {
<i>1424</i>&nbsp;              QName RESULT = null;
<i>1425</i>&nbsp;                int vnameleft = (parser_stack.get(parser_top-0)).left;
<i>1426</i>&nbsp;                int vnameright = (parser_stack.get(parser_top-0)).right;
<i>1427</i>&nbsp;                QName vname = (QName)(parser_stack.get(parser_top-0)).value;
<i>1428</i>&nbsp;
<i>1429</i>&nbsp;            RESULT = vname;
<i>1430</i>&nbsp;
<i>1431</i>&nbsp;              parser_result = new Symbol(39/*VariableName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1432</i>&nbsp;            }
<i>1433</i>&nbsp;          return parser_result;
<i>1434</i>&nbsp;
<i>1435</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1436</i>&nbsp;          case 112: // FunctionName ::= QName
<i>1437</i>&nbsp;            {
<i>1438</i>&nbsp;              QName RESULT = null;
<i>1439</i>&nbsp;                int fnameleft = (parser_stack.get(parser_top-0)).left;
<i>1440</i>&nbsp;                int fnameright = (parser_stack.get(parser_top-0)).right;
<i>1441</i>&nbsp;                QName fname = (QName)(parser_stack.get(parser_top-0)).value;
<i>1442</i>&nbsp;
<i>1443</i>&nbsp;            RESULT = fname;
<i>1444</i>&nbsp;
<i>1445</i>&nbsp;              parser_result = new Symbol(38/*FunctionName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1446</i>&nbsp;            }
<i>1447</i>&nbsp;          return parser_result;
<i>1448</i>&nbsp;
<i>1449</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1450</i>&nbsp;          case 111: // NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
<i>1451</i>&nbsp;            {
<i>1452</i>&nbsp;                List&lt;Expression&gt; RESULT = null;
<i>1453</i>&nbsp;                int argleft = (parser_stack.get(parser_top-2)).left;
<i>1454</i>&nbsp;                int argright = (parser_stack.get(parser_top-2)).right;
<i>1455</i>&nbsp;                Expression arg = (Expression)(parser_stack.get(parser_top-2)).value;
<i>1456</i>&nbsp;                int arglleft = (parser_stack.get(parser_top-0)).left;
<i>1457</i>&nbsp;                int arglright = (parser_stack.get(parser_top-0)).right;
<i>1458</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>1459</i>&nbsp;                List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
<i>1460</i>&nbsp;                argl.add(0, arg);
<i>1461</i>&nbsp;                RESULT = argl;
<i>1462</i>&nbsp;              parser_result = new Symbol(36/*NonemptyArgumentList*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1463</i>&nbsp;            }
<i>1464</i>&nbsp;          return parser_result;
<i>1465</i>&nbsp;
<i>1466</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1467</i>&nbsp;          case 110: // NonemptyArgumentList ::= Argument
<i>1468</i>&nbsp;            {
<i>1469</i>&nbsp;              List&lt;Expression&gt; RESULT = null;
<i>1470</i>&nbsp;                int argleft = (parser_stack.get(parser_top-0)).left;
<i>1471</i>&nbsp;                int argright = (parser_stack.get(parser_top-0)).right;
<i>1472</i>&nbsp;                Expression arg = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1473</i>&nbsp;
<i>1474</i>&nbsp;            List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
<i>1475</i>&nbsp;            temp.add(arg);
<i>1476</i>&nbsp;            RESULT = temp;
<i>1477</i>&nbsp;
<i>1478</i>&nbsp;              parser_result = new Symbol(36/*NonemptyArgumentList*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1479</i>&nbsp;            }
<i>1480</i>&nbsp;          return parser_result;
<i>1481</i>&nbsp;
<i>1482</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1483</i>&nbsp;          case 109: // FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
<i>1484</i>&nbsp;            {
<i>1485</i>&nbsp;                Expression RESULT = null;
<i>1486</i>&nbsp;                int fnameleft = (parser_stack.get(parser_top-3)).left;
<i>1487</i>&nbsp;                int fnameright = (parser_stack.get(parser_top-3)).right;
<i>1488</i>&nbsp;                QName fname = (QName)(parser_stack.get(parser_top-3)).value;
<i>1489</i>&nbsp;                int arglleft = (parser_stack.get(parser_top-1)).left;
<i>1490</i>&nbsp;                int arglright = (parser_stack.get(parser_top-1)).right;
<i>1491</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>1492</i>&nbsp;                List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-1)).value;
<i>1493</i>&nbsp;
<i>1494</i>&nbsp;          if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
<i>1495</i>&nbsp;            RESULT = new ConcatCall(fname, argl);
<i>1496</i>&nbsp;          }
<i>1497</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
<i>1498</i>&nbsp;            RESULT = new NumberCall(fname, argl);
<i>1499</i>&nbsp;          }
<i>1500</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;document&quot;)) {
<i>1501</i>&nbsp;            parser.setMultiDocument(true);
<i>1502</i>&nbsp;            RESULT = new DocumentCall(fname, argl);
<i>1503</i>&nbsp;          }
<i>1504</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
<i>1505</i>&nbsp;            RESULT = new StringCall(fname, argl);
<i>1506</i>&nbsp;          }
<i>1507</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;boolean&quot;)) {
<i>1508</i>&nbsp;            RESULT = new BooleanCall(fname, argl);
<i>1509</i>&nbsp;          }
<i>1510</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
<i>1511</i>&nbsp;            RESULT = new NameCall(fname, argl);
<i>1512</i>&nbsp;          }
<i>1513</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
<i>1514</i>&nbsp;            RESULT = new GenerateIdCall(fname, argl);
<i>1515</i>&nbsp;          }
<i>1516</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;not&quot;)) {
<i>1517</i>&nbsp;            RESULT = new NotCall(fname, argl);
<i>1518</i>&nbsp;          }
<i>1519</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;format-number&quot;)) {
<i>1520</i>&nbsp;            RESULT = new FormatNumberCall(fname, argl);
<i>1521</i>&nbsp;          }
<i>1522</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;unparsed-entity-uri&quot;)) {
<i>1523</i>&nbsp;            RESULT = new UnparsedEntityUriCall(fname, argl);
<i>1524</i>&nbsp;          }
<i>1525</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;key&quot;)) {
<i>1526</i>&nbsp;            RESULT = new KeyCall(fname, argl);
<i>1527</i>&nbsp;          }
<i>1528</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;id&quot;)) {
<i>1529</i>&nbsp;            RESULT = new KeyCall(fname, argl);
<i>1530</i>&nbsp;            parser.setHasIdCall(true);
<i>1531</i>&nbsp;          }
<i>1532</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;ceiling&quot;)) {
<i>1533</i>&nbsp;            RESULT = new CeilingCall(fname, argl);
<i>1534</i>&nbsp;          }
<i>1535</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;round&quot;)) {
<i>1536</i>&nbsp;            RESULT = new RoundCall(fname, argl);
<i>1537</i>&nbsp;          }
<i>1538</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;floor&quot;)) {
<i>1539</i>&nbsp;            RESULT = new FloorCall(fname, argl);
<i>1540</i>&nbsp;          }
<i>1541</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;contains&quot;)) {
<i>1542</i>&nbsp;            RESULT = new ContainsCall(fname, argl);
<i>1543</i>&nbsp;          }
<i>1544</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
<i>1545</i>&nbsp;            RESULT = new StringLengthCall(fname, argl);
<i>1546</i>&nbsp;          }
<i>1547</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;starts-with&quot;)) {
<i>1548</i>&nbsp;            RESULT = new StartsWithCall(fname, argl);
<i>1549</i>&nbsp;          }
<i>1550</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;function-available&quot;)) {
<i>1551</i>&nbsp;            RESULT = new FunctionAvailableCall(fname, argl);
<i>1552</i>&nbsp;          }
<i>1553</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;element-available&quot;)) {
<i>1554</i>&nbsp;            RESULT = new ElementAvailableCall(fname, argl);
<i>1555</i>&nbsp;          }
<i>1556</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
<i>1557</i>&nbsp;            RESULT = new LocalNameCall(fname, argl);
<i>1558</i>&nbsp;          }
<i>1559</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;lang&quot;)) {
<i>1560</i>&nbsp;            RESULT = new LangCall(fname, argl);
<i>1561</i>&nbsp;          }
<i>1562</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
<i>1563</i>&nbsp;            RESULT = new NamespaceUriCall(fname, argl);
<i>1564</i>&nbsp;          }
<i>1565</i>&nbsp;          else if (fname == parser.getQName(Constants.TRANSLET_URI, &quot;xsltc&quot;, &quot;cast&quot;)) {
<i>1566</i>&nbsp;            RESULT = new CastCall(fname, argl);
<i>1567</i>&nbsp;          }
<i>1568</i>&nbsp;          // Special case for extension function nodeset()
<i>1569</i>&nbsp;          else if (fname.getLocalPart().equals(&quot;nodeset&quot;) || fname.getLocalPart().equals(&quot;node-set&quot;)) {
<i>1570</i>&nbsp;            parser.setCallsNodeset(true);  // implies MultiDOM
<i>1571</i>&nbsp;            RESULT = new FunctionCall(fname, argl);
<i>1572</i>&nbsp;          }
<i>1573</i>&nbsp;          else {
<i>1574</i>&nbsp;            RESULT = new FunctionCall(fname, argl);
<i>1575</i>&nbsp;          }
<i>1576</i>&nbsp;
<i>1577</i>&nbsp;              parser_result = new Symbol(16/*FunctionCall*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1578</i>&nbsp;            }
<i>1579</i>&nbsp;          return parser_result;
<i>1580</i>&nbsp;
<i>1581</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1582</i>&nbsp;          case 108: // FunctionCall ::= FunctionName LPAREN RPAREN
<i>1583</i>&nbsp;            {
<i>1584</i>&nbsp;              Expression RESULT = null;
<i>1585</i>&nbsp;                int fnameleft = (parser_stack.get(parser_top-2)).left;
<i>1586</i>&nbsp;                int fnameright = (parser_stack.get(parser_top-2)).right;
<i>1587</i>&nbsp;                QName fname = (QName)(parser_stack.get(parser_top-2)).value;
<i>1588</i>&nbsp;
<i>1589</i>&nbsp;
<i>1590</i>&nbsp;          if (fname == parser.getQNameIgnoreDefaultNs(&quot;current&quot;)) {
<i>1591</i>&nbsp;            RESULT = new CurrentCall(fname);
<i>1592</i>&nbsp;          }
<i>1593</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
<i>1594</i>&nbsp;            RESULT = new NumberCall(fname, XPathParser.EmptyArgs);
<i>1595</i>&nbsp;          }
<i>1596</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
<i>1597</i>&nbsp;            RESULT = new StringCall(fname, XPathParser.EmptyArgs);
<i>1598</i>&nbsp;          }
<i>1599</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
<i>1600</i>&nbsp;            RESULT = new ConcatCall(fname, XPathParser.EmptyArgs);
<i>1601</i>&nbsp;          }
<i>1602</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;true&quot;)) {
<i>1603</i>&nbsp;            RESULT = new BooleanExpr(true);
<i>1604</i>&nbsp;          }
<i>1605</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;false&quot;)) {
<i>1606</i>&nbsp;            RESULT = new BooleanExpr(false);
<i>1607</i>&nbsp;          }
<i>1608</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
<i>1609</i>&nbsp;            RESULT = new NameCall(fname);
<i>1610</i>&nbsp;          }
<i>1611</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
<i>1612</i>&nbsp;            RESULT = new GenerateIdCall(fname, XPathParser.EmptyArgs);
<i>1613</i>&nbsp;          }
<i>1614</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
<i>1615</i>&nbsp;            RESULT = new StringLengthCall(fname, XPathParser.EmptyArgs);
<i>1616</i>&nbsp;          }
<i>1617</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;position&quot;)) {
<i>1618</i>&nbsp;            RESULT = new PositionCall(fname);
<i>1619</i>&nbsp;          }
<i>1620</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;last&quot;)) {
<i>1621</i>&nbsp;            RESULT = new LastCall(fname);
<i>1622</i>&nbsp;          }
<i>1623</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
<i>1624</i>&nbsp;            RESULT = new LocalNameCall(fname);
<i>1625</i>&nbsp;          }
<i>1626</i>&nbsp;          else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
<i>1627</i>&nbsp;            RESULT = new NamespaceUriCall(fname);
<i>1628</i>&nbsp;          }
<i>1629</i>&nbsp;          else {
<i>1630</i>&nbsp;            RESULT = new FunctionCall(fname, XPathParser.EmptyArgs);
<i>1631</i>&nbsp;          }
<i>1632</i>&nbsp;
<i>1633</i>&nbsp;              parser_result = new Symbol(16/*FunctionCall*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1634</i>&nbsp;            }
<i>1635</i>&nbsp;          return parser_result;
<i>1636</i>&nbsp;
<i>1637</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1638</i>&nbsp;          case 107: // VariableReference ::= DOLLAR VariableName
<i>1639</i>&nbsp;            {
<i>1640</i>&nbsp;              Expression RESULT = null;
<i>1641</i>&nbsp;                int varNameleft = (parser_stack.get(parser_top-0)).left;
<i>1642</i>&nbsp;                int varNameright = (parser_stack.get(parser_top-0)).right;
<i>1643</i>&nbsp;                QName varName = (QName)(parser_stack.get(parser_top-0)).value;
<i>1644</i>&nbsp;
<i>1645</i>&nbsp;            // An empty qname prefix for a variable or parameter reference
<i>1646</i>&nbsp;            // should map to the null namespace and not the default URI.
<i>1647</i>&nbsp;            SyntaxTreeNode node = parser.lookupName(varName);
<i>1648</i>&nbsp;
<i>1649</i>&nbsp;            if (node != null) {
<i>1650</i>&nbsp;                if (node instanceof Variable) {
<i>1651</i>&nbsp;                    RESULT = new VariableRef((Variable)node);
<i>1652</i>&nbsp;                }
<i>1653</i>&nbsp;                else if (node instanceof Param) {
<i>1654</i>&nbsp;                    RESULT = new ParameterRef((Param)node);
<i>1655</i>&nbsp;                }
<i>1656</i>&nbsp;                else {
<i>1657</i>&nbsp;                    RESULT = new UnresolvedRef(varName);
<i>1658</i>&nbsp;                }
<i>1659</i>&nbsp;            }
<i>1660</i>&nbsp;
<i>1661</i>&nbsp;            if (node == null) {
<i>1662</i>&nbsp;                RESULT = new UnresolvedRef(varName);
<i>1663</i>&nbsp;            }
<i>1664</i>&nbsp;
<i>1665</i>&nbsp;              parser_result = new Symbol(15/*VariableReference*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1666</i>&nbsp;            }
<i>1667</i>&nbsp;          return parser_result;
<i>1668</i>&nbsp;
<i>1669</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1670</i>&nbsp;          case 106: // PrimaryExpr ::= FunctionCall
<i>1671</i>&nbsp;            {
<i>1672</i>&nbsp;              Expression RESULT = null;
<i>1673</i>&nbsp;                int fcleft = (parser_stack.get(parser_top-0)).left;
<i>1674</i>&nbsp;                int fcright = (parser_stack.get(parser_top-0)).right;
<i>1675</i>&nbsp;                Expression fc = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1676</i>&nbsp;                 RESULT = fc;
<i>1677</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1678</i>&nbsp;            }
<i>1679</i>&nbsp;          return parser_result;
<i>1680</i>&nbsp;
<i>1681</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1682</i>&nbsp;          case 105: // PrimaryExpr ::= REAL
<i>1683</i>&nbsp;            {
<i>1684</i>&nbsp;              Expression RESULT = null;
<i>1685</i>&nbsp;                int numleft = (parser_stack.get(parser_top-0)).left;
<i>1686</i>&nbsp;                int numright = (parser_stack.get(parser_top-0)).right;
<i>1687</i>&nbsp;                Double num = (Double)(parser_stack.get(parser_top-0)).value;
<i>1688</i>&nbsp;                 RESULT = new RealExpr(num.doubleValue());
<i>1689</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1690</i>&nbsp;            }
<i>1691</i>&nbsp;          return parser_result;
<i>1692</i>&nbsp;
<i>1693</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1694</i>&nbsp;          case 104: // PrimaryExpr ::= INT
<i>1695</i>&nbsp;            {
<i>1696</i>&nbsp;              Expression RESULT = null;
<i>1697</i>&nbsp;                int numleft = (parser_stack.get(parser_top-0)).left;
<i>1698</i>&nbsp;                int numright = (parser_stack.get(parser_top-0)).right;
<i>1699</i>&nbsp;                Long num = (Long)(parser_stack.get(parser_top-0)).value;
<i>1700</i>&nbsp;
<i>1701</i>&nbsp;           long value = num.longValue();
<i>1702</i>&nbsp;           if (value &lt; Integer.MIN_VALUE || value &gt; Integer.MAX_VALUE) {
<i>1703</i>&nbsp;                RESULT = new RealExpr(value);
<i>1704</i>&nbsp;           }
<i>1705</i>&nbsp;           else {
<i>1706</i>&nbsp;               if (num.doubleValue() == -0)
<i>1707</i>&nbsp;                   RESULT = new RealExpr(num.doubleValue());
<i>1708</i>&nbsp;               else if (num.intValue() == 0)
<i>1709</i>&nbsp;                   RESULT = new IntExpr(num.intValue());
<i>1710</i>&nbsp;               else if (num.doubleValue() == 0.0)
<i>1711</i>&nbsp;                   RESULT = new RealExpr(num.doubleValue());
<i>1712</i>&nbsp;               else
<i>1713</i>&nbsp;                   RESULT = new IntExpr(num.intValue());
<i>1714</i>&nbsp;           }
<i>1715</i>&nbsp;
<i>1716</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1717</i>&nbsp;            }
<i>1718</i>&nbsp;          return parser_result;
<i>1719</i>&nbsp;
<i>1720</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1721</i>&nbsp;          case 103: // PrimaryExpr ::= Literal
<i>1722</i>&nbsp;            {
<i>1723</i>&nbsp;              Expression RESULT = null;
<i>1724</i>&nbsp;                int stringleft = (parser_stack.get(parser_top-0)).left;
<i>1725</i>&nbsp;                int stringright = (parser_stack.get(parser_top-0)).right;
<i>1726</i>&nbsp;                String string = (String)(parser_stack.get(parser_top-0)).value;
<i>1727</i>&nbsp;
<i>1728</i>&nbsp;        /*
<i>1729</i>&nbsp;        * If the string appears to have the syntax of a QName, store
<i>1730</i>&nbsp;        * namespace info in the literal expression. This is used for
<i>1731</i>&nbsp;        * element-available and function-available functions, among
<i>1732</i>&nbsp;        * others. Also, the default namespace must be ignored.
<i>1733</i>&nbsp;        */
<i>1734</i>&nbsp;        String namespace = null;
<i>1735</i>&nbsp;        final int index = string.lastIndexOf(&#39;:&#39;);
<i>1736</i>&nbsp;
<i>1737</i>&nbsp;        if (index &gt; 0) {
<i>1738</i>&nbsp;            final String prefix = string.substring(0, index);
<i>1739</i>&nbsp;            namespace = parser._symbolTable.lookupNamespace(prefix);
<i>1740</i>&nbsp;        }
<i>1741</i>&nbsp;        RESULT = (namespace == null) ? new LiteralExpr(string)
<i>1742</i>&nbsp;                     : new LiteralExpr(string, namespace);
<i>1743</i>&nbsp;
<i>1744</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1745</i>&nbsp;            }
<i>1746</i>&nbsp;          return parser_result;
<i>1747</i>&nbsp;
<i>1748</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1749</i>&nbsp;          case 102: // PrimaryExpr ::= LPAREN Expr RPAREN
<i>1750</i>&nbsp;            {
<i>1751</i>&nbsp;              Expression RESULT = null;
<i>1752</i>&nbsp;                int exleft = (parser_stack.get(parser_top-1)).left;
<i>1753</i>&nbsp;                int exright = (parser_stack.get(parser_top-1)).right;
<i>1754</i>&nbsp;                Expression ex = (Expression)(parser_stack.get(parser_top-1)).value;
<i>1755</i>&nbsp;                 RESULT = ex;
<i>1756</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1757</i>&nbsp;            }
<i>1758</i>&nbsp;          return parser_result;
<i>1759</i>&nbsp;
<i>1760</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1761</i>&nbsp;          case 101: // PrimaryExpr ::= VariableReference
<i>1762</i>&nbsp;            {
<i>1763</i>&nbsp;              Expression RESULT = null;
<i>1764</i>&nbsp;                int vrleft = (parser_stack.get(parser_top-0)).left;
<i>1765</i>&nbsp;                int vrright = (parser_stack.get(parser_top-0)).right;
<i>1766</i>&nbsp;                Expression vr = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1767</i>&nbsp;                 RESULT = vr;
<i>1768</i>&nbsp;              parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1769</i>&nbsp;            }
<i>1770</i>&nbsp;          return parser_result;
<i>1771</i>&nbsp;
<i>1772</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1773</i>&nbsp;          case 100: // FilterExpr ::= PrimaryExpr Predicates
<i>1774</i>&nbsp;            {
<i>1775</i>&nbsp;              Expression RESULT = null;
<i>1776</i>&nbsp;                int primaryleft = (parser_stack.get(parser_top-1)).left;
<i>1777</i>&nbsp;                int primaryright = (parser_stack.get(parser_top-1)).right;
<i>1778</i>&nbsp;                Expression primary = (Expression)(parser_stack.get(parser_top-1)).value;
<i>1779</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>1780</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>1781</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>1782</i>&nbsp;                List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
<i>1783</i>&nbsp;                 RESULT = new FilterExpr(primary, pp);
<i>1784</i>&nbsp;              parser_result = new Symbol(6/*FilterExpr*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1785</i>&nbsp;            }
<i>1786</i>&nbsp;          return parser_result;
<i>1787</i>&nbsp;
<i>1788</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1789</i>&nbsp;          case 99: // FilterExpr ::= PrimaryExpr
<i>1790</i>&nbsp;            {
<i>1791</i>&nbsp;              Expression RESULT = null;
<i>1792</i>&nbsp;                int primaryleft = (parser_stack.get(parser_top-0)).left;
<i>1793</i>&nbsp;                int primaryright = (parser_stack.get(parser_top-0)).right;
<i>1794</i>&nbsp;                Expression primary = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1795</i>&nbsp;                 RESULT = primary;
<i>1796</i>&nbsp;              parser_result = new Symbol(6/*FilterExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1797</i>&nbsp;            }
<i>1798</i>&nbsp;          return parser_result;
<i>1799</i>&nbsp;
<i>1800</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1801</i>&nbsp;          case 98: // AbbreviatedStep ::= DDOT
<i>1802</i>&nbsp;            {
<i>1803</i>&nbsp;              Expression RESULT = null;
<i>1804</i>&nbsp;                 RESULT = new Step(Axis.PARENT, NodeTest.ANODE, null);
<i>1805</i>&nbsp;              parser_result = new Symbol(20/*AbbreviatedStep*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1806</i>&nbsp;            }
<i>1807</i>&nbsp;          return parser_result;
<i>1808</i>&nbsp;
<i>1809</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1810</i>&nbsp;          case 97: // AbbreviatedStep ::= DOT
<i>1811</i>&nbsp;            {
<i>1812</i>&nbsp;              Expression RESULT = null;
<i>1813</i>&nbsp;                 RESULT = new Step(Axis.SELF, NodeTest.ANODE, null);
<i>1814</i>&nbsp;              parser_result = new Symbol(20/*AbbreviatedStep*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1815</i>&nbsp;            }
<i>1816</i>&nbsp;          return parser_result;
<i>1817</i>&nbsp;
<i>1818</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1819</i>&nbsp;          case 96: // AxisName ::= SELF
<i>1820</i>&nbsp;            {
<i>1821</i>&nbsp;              Integer RESULT = null;
<i>1822</i>&nbsp;                 RESULT = Integer.valueOf(Axis.SELF);
<i>1823</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1824</i>&nbsp;            }
<i>1825</i>&nbsp;          return parser_result;
<i>1826</i>&nbsp;
<i>1827</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1828</i>&nbsp;          case 95: // AxisName ::= PRECEDINGSIBLING
<i>1829</i>&nbsp;            {
<i>1830</i>&nbsp;              Integer RESULT = null;
<i>1831</i>&nbsp;                 RESULT = Integer.valueOf(Axis.PRECEDINGSIBLING);
<i>1832</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1833</i>&nbsp;            }
<i>1834</i>&nbsp;          return parser_result;
<i>1835</i>&nbsp;
<i>1836</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1837</i>&nbsp;          case 94: // AxisName ::= PRECEDING
<i>1838</i>&nbsp;            {
<i>1839</i>&nbsp;              Integer RESULT = null;
<i>1840</i>&nbsp;                 RESULT = Integer.valueOf(Axis.PRECEDING);
<i>1841</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1842</i>&nbsp;            }
<i>1843</i>&nbsp;          return parser_result;
<i>1844</i>&nbsp;
<i>1845</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1846</i>&nbsp;          case 93: // AxisName ::= PARENT
<i>1847</i>&nbsp;            {
<i>1848</i>&nbsp;              Integer RESULT = null;
<i>1849</i>&nbsp;                 RESULT = Integer.valueOf(Axis.PARENT);
<i>1850</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1851</i>&nbsp;            }
<i>1852</i>&nbsp;          return parser_result;
<i>1853</i>&nbsp;
<i>1854</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1855</i>&nbsp;          case 92: // AxisName ::= NAMESPACE
<i>1856</i>&nbsp;            {
<i>1857</i>&nbsp;              Integer RESULT = null;
<i>1858</i>&nbsp;                 RESULT = Integer.valueOf(Axis.NAMESPACE);
<i>1859</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1860</i>&nbsp;            }
<i>1861</i>&nbsp;          return parser_result;
<i>1862</i>&nbsp;
<i>1863</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1864</i>&nbsp;          case 91: // AxisName ::= FOLLOWINGSIBLING
<i>1865</i>&nbsp;            {
<i>1866</i>&nbsp;              Integer RESULT = null;
<i>1867</i>&nbsp;                 RESULT = Integer.valueOf(Axis.FOLLOWINGSIBLING);
<i>1868</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1869</i>&nbsp;            }
<i>1870</i>&nbsp;          return parser_result;
<i>1871</i>&nbsp;
<i>1872</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1873</i>&nbsp;          case 90: // AxisName ::= FOLLOWING
<i>1874</i>&nbsp;            {
<i>1875</i>&nbsp;              Integer RESULT = null;
<i>1876</i>&nbsp;                 RESULT = Integer.valueOf(Axis.FOLLOWING);
<i>1877</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1878</i>&nbsp;            }
<i>1879</i>&nbsp;          return parser_result;
<i>1880</i>&nbsp;
<i>1881</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1882</i>&nbsp;          case 89: // AxisName ::= DESCENDANTORSELF
<i>1883</i>&nbsp;            {
<i>1884</i>&nbsp;              Integer RESULT = null;
<i>1885</i>&nbsp;                 RESULT = Integer.valueOf(Axis.DESCENDANTORSELF);
<i>1886</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1887</i>&nbsp;            }
<i>1888</i>&nbsp;          return parser_result;
<i>1889</i>&nbsp;
<i>1890</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1891</i>&nbsp;          case 88: // AxisName ::= DESCENDANT
<i>1892</i>&nbsp;            {
<i>1893</i>&nbsp;              Integer RESULT = null;
<i>1894</i>&nbsp;                 RESULT = Integer.valueOf(Axis.DESCENDANT);
<i>1895</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1896</i>&nbsp;            }
<i>1897</i>&nbsp;          return parser_result;
<i>1898</i>&nbsp;
<i>1899</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1900</i>&nbsp;          case 87: // AxisName ::= CHILD
<i>1901</i>&nbsp;            {
<i>1902</i>&nbsp;              Integer RESULT = null;
<i>1903</i>&nbsp;                 RESULT = Integer.valueOf(Axis.CHILD);
<i>1904</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1905</i>&nbsp;            }
<i>1906</i>&nbsp;          return parser_result;
<i>1907</i>&nbsp;
<i>1908</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1909</i>&nbsp;          case 86: // AxisName ::= ATTRIBUTE
<i>1910</i>&nbsp;            {
<i>1911</i>&nbsp;              Integer RESULT = null;
<i>1912</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ATTRIBUTE);
<i>1913</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1914</i>&nbsp;            }
<i>1915</i>&nbsp;          return parser_result;
<i>1916</i>&nbsp;
<i>1917</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1918</i>&nbsp;          case 85: // AxisName ::= ANCESTORORSELF
<i>1919</i>&nbsp;            {
<i>1920</i>&nbsp;              Integer RESULT = null;
<i>1921</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ANCESTORORSELF);
<i>1922</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1923</i>&nbsp;            }
<i>1924</i>&nbsp;          return parser_result;
<i>1925</i>&nbsp;
<i>1926</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1927</i>&nbsp;          case 84: // AxisName ::= ANCESTOR
<i>1928</i>&nbsp;            {
<i>1929</i>&nbsp;              Integer RESULT = null;
<i>1930</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ANCESTOR);
<i>1931</i>&nbsp;              parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1932</i>&nbsp;            }
<i>1933</i>&nbsp;          return parser_result;
<i>1934</i>&nbsp;
<i>1935</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1936</i>&nbsp;          case 83: // AxisSpecifier ::= ATSIGN
<i>1937</i>&nbsp;            {
<i>1938</i>&nbsp;              Integer RESULT = null;
<i>1939</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ATTRIBUTE);
<i>1940</i>&nbsp;              parser_result = new Symbol(41/*AxisSpecifier*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1941</i>&nbsp;            }
<i>1942</i>&nbsp;          return parser_result;
<i>1943</i>&nbsp;
<i>1944</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1945</i>&nbsp;          case 82: // AxisSpecifier ::= AxisName DCOLON
<i>1946</i>&nbsp;            {
<i>1947</i>&nbsp;              Integer RESULT = null;
<i>1948</i>&nbsp;                int anleft = (parser_stack.get(parser_top-1)).left;
<i>1949</i>&nbsp;                int anright = (parser_stack.get(parser_top-1)).right;
<i>1950</i>&nbsp;                Integer an = (Integer)(parser_stack.get(parser_top-1)).value;
<i>1951</i>&nbsp;                 RESULT = an;
<i>1952</i>&nbsp;              parser_result = new Symbol(41/*AxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1953</i>&nbsp;            }
<i>1954</i>&nbsp;          return parser_result;
<i>1955</i>&nbsp;
<i>1956</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1957</i>&nbsp;          case 81: // Step ::= AbbreviatedStep
<i>1958</i>&nbsp;            {
<i>1959</i>&nbsp;              Expression RESULT = null;
<i>1960</i>&nbsp;                int abbrevleft = (parser_stack.get(parser_top-0)).left;
<i>1961</i>&nbsp;                int abbrevright = (parser_stack.get(parser_top-0)).right;
<i>1962</i>&nbsp;                Expression abbrev = (Expression)(parser_stack.get(parser_top-0)).value;
<i>1963</i>&nbsp;                 RESULT = abbrev;
<i>1964</i>&nbsp;              parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1965</i>&nbsp;            }
<i>1966</i>&nbsp;          return parser_result;
<i>1967</i>&nbsp;
<i>1968</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1969</i>&nbsp;          case 80: // Step ::= AxisSpecifier NodeTest
<i>1970</i>&nbsp;            {
<i>1971</i>&nbsp;              Expression RESULT = null;
<i>1972</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-1)).left;
<i>1973</i>&nbsp;                int axisright = (parser_stack.get(parser_top-1)).right;
<i>1974</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
<i>1975</i>&nbsp;                int ntestleft = (parser_stack.get(parser_top-0)).left;
<i>1976</i>&nbsp;                int ntestright = (parser_stack.get(parser_top-0)).right;
<i>1977</i>&nbsp;                Object ntest = parser_stack.get(parser_top-0).value;
<i>1978</i>&nbsp;                 RESULT = new Step(axis.intValue(),
<i>1979</i>&nbsp;                             parser.findNodeType(axis.intValue(), ntest),
<i>1980</i>&nbsp;                             null);
<i>1981</i>&nbsp;
<i>1982</i>&nbsp;              parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>1983</i>&nbsp;            }
<i>1984</i>&nbsp;          return parser_result;
<i>1985</i>&nbsp;
<i>1986</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>1987</i>&nbsp;          case 79: // Step ::= AxisSpecifier NodeTest Predicates
<i>1988</i>&nbsp;            {
<i>1989</i>&nbsp;              Expression RESULT = null;
<i>1990</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-2)).left;
<i>1991</i>&nbsp;                int axisright = (parser_stack.get(parser_top-2)).right;
<i>1992</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
<i>1993</i>&nbsp;                int ntestleft = (parser_stack.get(parser_top-1)).left;
<i>1994</i>&nbsp;                int ntestright = (parser_stack.get(parser_top-1)).right;
<i>1995</i>&nbsp;                Object ntest = parser_stack.get(parser_top-1).value;
<i>1996</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>1997</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>1998</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>1999</i>&nbsp;                List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2000</i>&nbsp;                 RESULT = new Step(axis.intValue(),
<i>2001</i>&nbsp;                             parser.findNodeType(axis.intValue(), ntest),
<i>2002</i>&nbsp;                             pp);
<i>2003</i>&nbsp;
<i>2004</i>&nbsp;              parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2005</i>&nbsp;            }
<i>2006</i>&nbsp;          return parser_result;
<i>2007</i>&nbsp;
<i>2008</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2009</i>&nbsp;          case 78: // Step ::= NodeTest Predicates
<i>2010</i>&nbsp;            {
<i>2011</i>&nbsp;              Expression RESULT = null;
<i>2012</i>&nbsp;                int ntestleft = (parser_stack.get(parser_top-1)).left;
<i>2013</i>&nbsp;                int ntestright = (parser_stack.get(parser_top-1)).right;
<i>2014</i>&nbsp;                Object ntest = parser_stack.get(parser_top-1).value;
<i>2015</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2016</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2017</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2018</i>&nbsp;                List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2019</i>&nbsp;
<i>2020</i>&nbsp;            if (ntest instanceof Step) {
<i>2021</i>&nbsp;                Step step = (Step)ntest;
<i>2022</i>&nbsp;                step.addPredicates(pp);
<i>2023</i>&nbsp;                RESULT = (Step)ntest;
<i>2024</i>&nbsp;            }
<i>2025</i>&nbsp;            else {
<i>2026</i>&nbsp;                RESULT = new Step(Axis.CHILD,
<i>2027</i>&nbsp;                             parser.findNodeType(Axis.CHILD, ntest), pp);
<i>2028</i>&nbsp;            }
<i>2029</i>&nbsp;
<i>2030</i>&nbsp;              parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2031</i>&nbsp;            }
<i>2032</i>&nbsp;          return parser_result;
<i>2033</i>&nbsp;
<i>2034</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2035</i>&nbsp;          case 77: // Step ::= NodeTest
<i>2036</i>&nbsp;            {
<i>2037</i>&nbsp;              Expression RESULT = null;
<i>2038</i>&nbsp;                int ntestleft = (parser_stack.get(parser_top-0)).left;
<i>2039</i>&nbsp;                int ntestright = (parser_stack.get(parser_top-0)).right;
<i>2040</i>&nbsp;                Object ntest = parser_stack.get(parser_top-0).value;
<i>2041</i>&nbsp;
<i>2042</i>&nbsp;            if (ntest instanceof Step) {
<i>2043</i>&nbsp;                RESULT = (Step)ntest;
<i>2044</i>&nbsp;            }
<i>2045</i>&nbsp;            else {
<i>2046</i>&nbsp;                RESULT = new Step(Axis.CHILD,
<i>2047</i>&nbsp;                             parser.findNodeType(Axis.CHILD, ntest),
<i>2048</i>&nbsp;                             null);
<i>2049</i>&nbsp;            }
<i>2050</i>&nbsp;
<i>2051</i>&nbsp;              parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2052</i>&nbsp;            }
<i>2053</i>&nbsp;          return parser_result;
<i>2054</i>&nbsp;
<i>2055</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2056</i>&nbsp;          case 76: // AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
<i>2057</i>&nbsp;            {
<i>2058</i>&nbsp;              Expression RESULT = null;
<i>2059</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-0)).left;
<i>2060</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-0)).right;
<i>2061</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2062</i>&nbsp;
<i>2063</i>&nbsp;           //
<i>2064</i>&nbsp;           // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
<i>2065</i>&nbsp;           // into /descendant-or-self::*/
<i>2066</i>&nbsp;           //
<i>2067</i>&nbsp;           int nodeType = DOM.NO_TYPE;
<i>2068</i>&nbsp;           if (rlp instanceof Step &amp;&amp;
<i>2069</i>&nbsp;               parser.isElementAxis(((Step) rlp).getAxis()))
<i>2070</i>&nbsp;           {
<i>2071</i>&nbsp;               nodeType = DTM.ELEMENT_NODE;
<i>2072</i>&nbsp;           }
<i>2073</i>&nbsp;           final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
<i>2074</i>&nbsp;           RESULT = new AbsoluteLocationPath(parser.insertStep(step,
<i>2075</i>&nbsp;                                (RelativeLocationPath) rlp));
<i>2076</i>&nbsp;
<i>2077</i>&nbsp;              parser_result = new Symbol(24/*AbbreviatedAbsoluteLocationPath*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2078</i>&nbsp;            }
<i>2079</i>&nbsp;          return parser_result;
<i>2080</i>&nbsp;
<i>2081</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2082</i>&nbsp;          case 75: // AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
<i>2083</i>&nbsp;            {
<i>2084</i>&nbsp;              Expression RESULT = null;
<i>2085</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-2)).left;
<i>2086</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-2)).right;
<i>2087</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2088</i>&nbsp;                int stepleft = (parser_stack.get(parser_top-0)).left;
<i>2089</i>&nbsp;                int stepright = (parser_stack.get(parser_top-0)).right;
<i>2090</i>&nbsp;                Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2091</i>&nbsp;
<i>2092</i>&nbsp;           final Step right  = (Step)step;
<i>2093</i>&nbsp;           final int  axis   = right.getAxis();
<i>2094</i>&nbsp;           final int  type   = right.getNodeType();
<i>2095</i>&nbsp;           final List&lt;Predicate&gt; predicates = right.getPredicates();
<i>2096</i>&nbsp;
<i>2097</i>&nbsp;           if ((axis == Axis.CHILD) &amp;&amp; (type != NodeTest.ATTRIBUTE)) {
<i>2098</i>&nbsp;               // Compress &#39;.//child:E&#39; into &#39;descendant::E&#39; - if possible
<i>2099</i>&nbsp;               if (predicates == null) {
<i>2100</i>&nbsp;                   right.setAxis(Axis.DESCENDANT);
<i>2101</i>&nbsp;                   if (rlp instanceof Step &amp;&amp; ((Step)rlp).isAbbreviatedDot()) {
<i>2102</i>&nbsp;                       RESULT = right;
<i>2103</i>&nbsp;                   }
<i>2104</i>&nbsp;                   else {
<i>2105</i>&nbsp;                       // Expand &#39;rlp//child::E&#39; into &#39;rlp/descendant::E&#39;
<i>2106</i>&nbsp;                       RelativeLocationPath left = (RelativeLocationPath)rlp;
<i>2107</i>&nbsp;                       RESULT = new ParentLocationPath(left, right);
<i>2108</i>&nbsp;                   }
<i>2109</i>&nbsp;               }
<i>2110</i>&nbsp;               else {
<i>2111</i>&nbsp;                   // Expand &#39;.//step&#39; -&gt; &#39;descendant-or-self::*/step&#39;
<i>2112</i>&nbsp;                   if (rlp instanceof Step &amp;&amp; ((Step)rlp).isAbbreviatedDot()) {
<i>2113</i>&nbsp;                       Step left = new Step(Axis.DESCENDANTORSELF,
<i>2114</i>&nbsp;                            DTM.ELEMENT_NODE, null);
<i>2115</i>&nbsp;                       RESULT = new ParentLocationPath(left, right);
<i>2116</i>&nbsp;                   }
<i>2117</i>&nbsp;                   else {
<i>2118</i>&nbsp;                       // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
<i>2119</i>&nbsp;                       RelativeLocationPath left = (RelativeLocationPath)rlp;
<i>2120</i>&nbsp;                       Step mid = new Step(Axis.DESCENDANTORSELF,
<i>2121</i>&nbsp;                            DTM.ELEMENT_NODE, null);
<i>2122</i>&nbsp;                       ParentLocationPath ppl = new ParentLocationPath(mid, right);
<i>2123</i>&nbsp;                       RESULT = new ParentLocationPath(left, ppl);
<i>2124</i>&nbsp;                   }
<i>2125</i>&nbsp;               }
<i>2126</i>&nbsp;           }
<i>2127</i>&nbsp;           else if ((axis == Axis.ATTRIBUTE) || (type == NodeTest.ATTRIBUTE)) {
<i>2128</i>&nbsp;               // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
<i>2129</i>&nbsp;               RelativeLocationPath left = (RelativeLocationPath)rlp;
<i>2130</i>&nbsp;               Step middle = new Step(Axis.DESCENDANTORSELF,
<i>2131</i>&nbsp;                    DTM.ELEMENT_NODE, null);
<i>2132</i>&nbsp;               ParentLocationPath ppl = new ParentLocationPath(middle, right);
<i>2133</i>&nbsp;               RESULT = new ParentLocationPath(left, ppl);
<i>2134</i>&nbsp;           }
<i>2135</i>&nbsp;           else {
<i>2136</i>&nbsp;               // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::node()/step&#39;
<i>2137</i>&nbsp;               RelativeLocationPath left = (RelativeLocationPath)rlp;
<i>2138</i>&nbsp;               Step middle = new Step(Axis.DESCENDANTORSELF,
<i>2139</i>&nbsp;                    DOM.NO_TYPE, null);
<i>2140</i>&nbsp;               ParentLocationPath ppl = new ParentLocationPath(middle, right);
<i>2141</i>&nbsp;               RESULT = new ParentLocationPath(left, ppl);
<i>2142</i>&nbsp;           }
<i>2143</i>&nbsp;
<i>2144</i>&nbsp;              parser_result = new Symbol(22/*AbbreviatedRelativeLocationPath*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2145</i>&nbsp;            }
<i>2146</i>&nbsp;          return parser_result;
<i>2147</i>&nbsp;
<i>2148</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2149</i>&nbsp;          case 74: // AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
<i>2150</i>&nbsp;            {
<i>2151</i>&nbsp;              Expression RESULT = null;
<i>2152</i>&nbsp;                int aalpleft = (parser_stack.get(parser_top-0)).left;
<i>2153</i>&nbsp;                int aalpright = (parser_stack.get(parser_top-0)).right;
<i>2154</i>&nbsp;                Expression aalp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2155</i>&nbsp;                 RESULT = aalp;
<i>2156</i>&nbsp;              parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2157</i>&nbsp;            }
<i>2158</i>&nbsp;          return parser_result;
<i>2159</i>&nbsp;
<i>2160</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2161</i>&nbsp;          case 73: // AbsoluteLocationPath ::= SLASH RelativeLocationPath
<i>2162</i>&nbsp;            {
<i>2163</i>&nbsp;              Expression RESULT = null;
<i>2164</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-0)).left;
<i>2165</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-0)).right;
<i>2166</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2167</i>&nbsp;                 RESULT = new AbsoluteLocationPath(rlp);
<i>2168</i>&nbsp;              parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2169</i>&nbsp;            }
<i>2170</i>&nbsp;          return parser_result;
<i>2171</i>&nbsp;
<i>2172</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2173</i>&nbsp;          case 72: // AbsoluteLocationPath ::= SLASH
<i>2174</i>&nbsp;            {
<i>2175</i>&nbsp;              Expression RESULT = null;
<i>2176</i>&nbsp;                 RESULT = new AbsoluteLocationPath();
<i>2177</i>&nbsp;              parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2178</i>&nbsp;            }
<i>2179</i>&nbsp;          return parser_result;
<i>2180</i>&nbsp;
<i>2181</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2182</i>&nbsp;          case 71: // RelativeLocationPath ::= AbbreviatedRelativeLocationPath
<i>2183</i>&nbsp;            {
<i>2184</i>&nbsp;              Expression RESULT = null;
<i>2185</i>&nbsp;                int arlpleft = (parser_stack.get(parser_top-0)).left;
<i>2186</i>&nbsp;                int arlpright = (parser_stack.get(parser_top-0)).right;
<i>2187</i>&nbsp;                Expression arlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2188</i>&nbsp;                 RESULT = arlp;
<i>2189</i>&nbsp;              parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2190</i>&nbsp;            }
<i>2191</i>&nbsp;          return parser_result;
<i>2192</i>&nbsp;
<i>2193</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2194</i>&nbsp;          case 70: // RelativeLocationPath ::= RelativeLocationPath SLASH Step
<i>2195</i>&nbsp;            {
<i>2196</i>&nbsp;              Expression RESULT = null;
<i>2197</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-2)).left;
<i>2198</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-2)).right;
<i>2199</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2200</i>&nbsp;                int stepleft = (parser_stack.get(parser_top-0)).left;
<i>2201</i>&nbsp;                int stepright = (parser_stack.get(parser_top-0)).right;
<i>2202</i>&nbsp;                Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2203</i>&nbsp;
<i>2204</i>&nbsp;        if (rlp instanceof Step &amp;&amp; ((Step) rlp).isAbbreviatedDot()) {
<i>2205</i>&nbsp;              RESULT = step;       // Remove &#39;./&#39; from the middle
<i>2206</i>&nbsp;        }
<i>2207</i>&nbsp;        else if (((Step) step).isAbbreviatedDot()) {
<i>2208</i>&nbsp;              RESULT = rlp;        // Remove &#39;/.&#39; from the end
<i>2209</i>&nbsp;        }
<i>2210</i>&nbsp;        else {
<i>2211</i>&nbsp;             RESULT =
<i>2212</i>&nbsp;                new ParentLocationPath((RelativeLocationPath) rlp, step);
<i>2213</i>&nbsp;           }
<i>2214</i>&nbsp;
<i>2215</i>&nbsp;              parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2216</i>&nbsp;            }
<i>2217</i>&nbsp;          return parser_result;
<i>2218</i>&nbsp;
<i>2219</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2220</i>&nbsp;          case 69: // RelativeLocationPath ::= Step
<i>2221</i>&nbsp;            {
<i>2222</i>&nbsp;              Expression RESULT = null;
<i>2223</i>&nbsp;                int stepleft = (parser_stack.get(parser_top-0)).left;
<i>2224</i>&nbsp;                int stepright = (parser_stack.get(parser_top-0)).right;
<i>2225</i>&nbsp;                Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2226</i>&nbsp;                 RESULT = step;
<i>2227</i>&nbsp;              parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2228</i>&nbsp;            }
<i>2229</i>&nbsp;          return parser_result;
<i>2230</i>&nbsp;
<i>2231</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2232</i>&nbsp;          case 68: // LocationPath ::= AbsoluteLocationPath
<i>2233</i>&nbsp;            {
<i>2234</i>&nbsp;              Expression RESULT = null;
<i>2235</i>&nbsp;                int alpleft = (parser_stack.get(parser_top-0)).left;
<i>2236</i>&nbsp;                int alpright = (parser_stack.get(parser_top-0)).right;
<i>2237</i>&nbsp;                Expression alp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2238</i>&nbsp;                 RESULT = alp;
<i>2239</i>&nbsp;              parser_result = new Symbol(4/*LocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2240</i>&nbsp;            }
<i>2241</i>&nbsp;          return parser_result;
<i>2242</i>&nbsp;
<i>2243</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2244</i>&nbsp;          case 67: // LocationPath ::= RelativeLocationPath
<i>2245</i>&nbsp;            {
<i>2246</i>&nbsp;              Expression RESULT = null;
<i>2247</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-0)).left;
<i>2248</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-0)).right;
<i>2249</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2250</i>&nbsp;                 RESULT = rlp;
<i>2251</i>&nbsp;              parser_result = new Symbol(4/*LocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2252</i>&nbsp;            }
<i>2253</i>&nbsp;          return parser_result;
<i>2254</i>&nbsp;
<i>2255</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2256</i>&nbsp;          case 66: // PathExpr ::= FilterExpr DSLASH RelativeLocationPath
<i>2257</i>&nbsp;            {
<i>2258</i>&nbsp;              Expression RESULT = null;
<i>2259</i>&nbsp;                int fexpleft = (parser_stack.get(parser_top-2)).left;
<i>2260</i>&nbsp;                int fexpright = (parser_stack.get(parser_top-2)).right;
<i>2261</i>&nbsp;                Expression fexp = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2262</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-0)).left;
<i>2263</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-0)).right;
<i>2264</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2265</i>&nbsp;
<i>2266</i>&nbsp;           //
<i>2267</i>&nbsp;           // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
<i>2268</i>&nbsp;           // into /descendant-or-self::*/
<i>2269</i>&nbsp;           //
<i>2270</i>&nbsp;           int nodeType = DOM.NO_TYPE;
<i>2271</i>&nbsp;           if (rlp instanceof Step &amp;&amp;
<i>2272</i>&nbsp;               parser.isElementAxis(((Step) rlp).getAxis()))
<i>2273</i>&nbsp;           {
<i>2274</i>&nbsp;               nodeType = DTM.ELEMENT_NODE;
<i>2275</i>&nbsp;           }
<i>2276</i>&nbsp;           final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
<i>2277</i>&nbsp;           FilterParentPath fpp = new FilterParentPath(fexp, step);
<i>2278</i>&nbsp;           fpp = new FilterParentPath(fpp, rlp);
<i>2279</i>&nbsp;           if (fexp instanceof KeyCall == false) {
<i>2280</i>&nbsp;               fpp.setDescendantAxis();
<i>2281</i>&nbsp;           }
<i>2282</i>&nbsp;           RESULT = fpp;
<i>2283</i>&nbsp;
<i>2284</i>&nbsp;              parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2285</i>&nbsp;            }
<i>2286</i>&nbsp;          return parser_result;
<i>2287</i>&nbsp;
<i>2288</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2289</i>&nbsp;          case 65: // PathExpr ::= FilterExpr SLASH RelativeLocationPath
<i>2290</i>&nbsp;            {
<i>2291</i>&nbsp;              Expression RESULT = null;
<i>2292</i>&nbsp;                int fexpleft = (parser_stack.get(parser_top-2)).left;
<i>2293</i>&nbsp;                int fexpright = (parser_stack.get(parser_top-2)).right;
<i>2294</i>&nbsp;                Expression fexp = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2295</i>&nbsp;                int rlpleft = (parser_stack.get(parser_top-0)).left;
<i>2296</i>&nbsp;                int rlpright = (parser_stack.get(parser_top-0)).right;
<i>2297</i>&nbsp;                Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2298</i>&nbsp;                 RESULT = new FilterParentPath(fexp, rlp);
<i>2299</i>&nbsp;              parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2300</i>&nbsp;            }
<i>2301</i>&nbsp;          return parser_result;
<i>2302</i>&nbsp;
<i>2303</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2304</i>&nbsp;          case 64: // PathExpr ::= FilterExpr
<i>2305</i>&nbsp;            {
<i>2306</i>&nbsp;              Expression RESULT = null;
<i>2307</i>&nbsp;                int fexpleft = (parser_stack.get(parser_top-0)).left;
<i>2308</i>&nbsp;                int fexpright = (parser_stack.get(parser_top-0)).right;
<i>2309</i>&nbsp;                Expression fexp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2310</i>&nbsp;                 RESULT = fexp;
<i>2311</i>&nbsp;              parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2312</i>&nbsp;            }
<i>2313</i>&nbsp;          return parser_result;
<i>2314</i>&nbsp;
<i>2315</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2316</i>&nbsp;          case 63: // PathExpr ::= LocationPath
<i>2317</i>&nbsp;            {
<i>2318</i>&nbsp;              Expression RESULT = null;
<i>2319</i>&nbsp;                int lpleft = (parser_stack.get(parser_top-0)).left;
<i>2320</i>&nbsp;                int lpright = (parser_stack.get(parser_top-0)).right;
<i>2321</i>&nbsp;                Expression lp = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2322</i>&nbsp;                 RESULT = lp;
<i>2323</i>&nbsp;              parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2324</i>&nbsp;            }
<i>2325</i>&nbsp;          return parser_result;
<i>2326</i>&nbsp;
<i>2327</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2328</i>&nbsp;          case 62: // UnionExpr ::= PathExpr VBAR UnionExpr
<i>2329</i>&nbsp;            {
<i>2330</i>&nbsp;              Expression RESULT = null;
<i>2331</i>&nbsp;                int peleft = (parser_stack.get(parser_top-2)).left;
<i>2332</i>&nbsp;                int peright = (parser_stack.get(parser_top-2)).right;
<i>2333</i>&nbsp;                Expression pe = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2334</i>&nbsp;                int restleft = (parser_stack.get(parser_top-0)).left;
<i>2335</i>&nbsp;                int restright = (parser_stack.get(parser_top-0)).right;
<i>2336</i>&nbsp;                Expression rest = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2337</i>&nbsp;                 RESULT = new UnionPathExpr(pe, rest);
<i>2338</i>&nbsp;              parser_result = new Symbol(18/*UnionExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2339</i>&nbsp;            }
<i>2340</i>&nbsp;          return parser_result;
<i>2341</i>&nbsp;
<i>2342</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2343</i>&nbsp;          case 61: // UnionExpr ::= PathExpr
<i>2344</i>&nbsp;            {
<i>2345</i>&nbsp;              Expression RESULT = null;
<i>2346</i>&nbsp;                int peleft = (parser_stack.get(parser_top-0)).left;
<i>2347</i>&nbsp;                int peright = (parser_stack.get(parser_top-0)).right;
<i>2348</i>&nbsp;                Expression pe = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2349</i>&nbsp;                 RESULT = pe;
<i>2350</i>&nbsp;              parser_result = new Symbol(18/*UnionExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2351</i>&nbsp;            }
<i>2352</i>&nbsp;          return parser_result;
<i>2353</i>&nbsp;
<i>2354</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2355</i>&nbsp;          case 60: // UnaryExpr ::= MINUS UnaryExpr
<i>2356</i>&nbsp;            {
<i>2357</i>&nbsp;              Expression RESULT = null;
<i>2358</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2359</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2360</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2361</i>&nbsp;                 RESULT = new UnaryOpExpr(ue);
<i>2362</i>&nbsp;              parser_result = new Symbol(14/*UnaryExpr*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2363</i>&nbsp;            }
<i>2364</i>&nbsp;          return parser_result;
<i>2365</i>&nbsp;
<i>2366</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2367</i>&nbsp;          case 59: // UnaryExpr ::= UnionExpr
<i>2368</i>&nbsp;            {
<i>2369</i>&nbsp;              Expression RESULT = null;
<i>2370</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2371</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2372</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2373</i>&nbsp;                 RESULT = ue;
<i>2374</i>&nbsp;              parser_result = new Symbol(14/*UnaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2375</i>&nbsp;            }
<i>2376</i>&nbsp;          return parser_result;
<i>2377</i>&nbsp;
<i>2378</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2379</i>&nbsp;          case 58: // MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
<i>2380</i>&nbsp;            {
<i>2381</i>&nbsp;              Expression RESULT = null;
<i>2382</i>&nbsp;                int meleft = (parser_stack.get(parser_top-2)).left;
<i>2383</i>&nbsp;                int meright = (parser_stack.get(parser_top-2)).right;
<i>2384</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2385</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2386</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2387</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2388</i>&nbsp;                 RESULT = new BinOpExpr(BinOpExpr.MOD, me, ue);
<i>2389</i>&nbsp;              parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2390</i>&nbsp;            }
<i>2391</i>&nbsp;          return parser_result;
<i>2392</i>&nbsp;
<i>2393</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2394</i>&nbsp;          case 57: // MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
<i>2395</i>&nbsp;            {
<i>2396</i>&nbsp;              Expression RESULT = null;
<i>2397</i>&nbsp;                int meleft = (parser_stack.get(parser_top-2)).left;
<i>2398</i>&nbsp;                int meright = (parser_stack.get(parser_top-2)).right;
<i>2399</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2400</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2401</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2402</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2403</i>&nbsp;                 RESULT = new BinOpExpr(BinOpExpr.DIV, me, ue);
<i>2404</i>&nbsp;              parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2405</i>&nbsp;            }
<i>2406</i>&nbsp;          return parser_result;
<i>2407</i>&nbsp;
<i>2408</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2409</i>&nbsp;          case 56: // MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr
<i>2410</i>&nbsp;            {
<i>2411</i>&nbsp;              Expression RESULT = null;
<i>2412</i>&nbsp;                int meleft = (parser_stack.get(parser_top-2)).left;
<i>2413</i>&nbsp;                int meright = (parser_stack.get(parser_top-2)).right;
<i>2414</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2415</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2416</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2417</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2418</i>&nbsp;                 RESULT = new BinOpExpr(BinOpExpr.TIMES, me, ue);
<i>2419</i>&nbsp;              parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2420</i>&nbsp;            }
<i>2421</i>&nbsp;          return parser_result;
<i>2422</i>&nbsp;
<i>2423</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2424</i>&nbsp;          case 55: // MultiplicativeExpr ::= UnaryExpr
<i>2425</i>&nbsp;            {
<i>2426</i>&nbsp;              Expression RESULT = null;
<i>2427</i>&nbsp;                int ueleft = (parser_stack.get(parser_top-0)).left;
<i>2428</i>&nbsp;                int ueright = (parser_stack.get(parser_top-0)).right;
<i>2429</i>&nbsp;                Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2430</i>&nbsp;                 RESULT = ue;
<i>2431</i>&nbsp;              parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2432</i>&nbsp;            }
<i>2433</i>&nbsp;          return parser_result;
<i>2434</i>&nbsp;
<i>2435</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2436</i>&nbsp;          case 54: // AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
<i>2437</i>&nbsp;            {
<i>2438</i>&nbsp;              Expression RESULT = null;
<i>2439</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-2)).left;
<i>2440</i>&nbsp;                int aeright = (parser_stack.get(parser_top-2)).right;
<i>2441</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2442</i>&nbsp;                int meleft = (parser_stack.get(parser_top-0)).left;
<i>2443</i>&nbsp;                int meright = (parser_stack.get(parser_top-0)).right;
<i>2444</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2445</i>&nbsp;                 RESULT = new BinOpExpr(BinOpExpr.MINUS, ae, me);
<i>2446</i>&nbsp;              parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2447</i>&nbsp;            }
<i>2448</i>&nbsp;          return parser_result;
<i>2449</i>&nbsp;
<i>2450</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2451</i>&nbsp;          case 53: // AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
<i>2452</i>&nbsp;            {
<i>2453</i>&nbsp;              Expression RESULT = null;
<i>2454</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-2)).left;
<i>2455</i>&nbsp;                int aeright = (parser_stack.get(parser_top-2)).right;
<i>2456</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2457</i>&nbsp;                int meleft = (parser_stack.get(parser_top-0)).left;
<i>2458</i>&nbsp;                int meright = (parser_stack.get(parser_top-0)).right;
<i>2459</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2460</i>&nbsp;                 RESULT = new BinOpExpr(BinOpExpr.PLUS, ae, me);
<i>2461</i>&nbsp;              parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2462</i>&nbsp;            }
<i>2463</i>&nbsp;          return parser_result;
<i>2464</i>&nbsp;
<i>2465</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2466</i>&nbsp;          case 52: // AdditiveExpr ::= MultiplicativeExpr
<i>2467</i>&nbsp;            {
<i>2468</i>&nbsp;              Expression RESULT = null;
<i>2469</i>&nbsp;                int meleft = (parser_stack.get(parser_top-0)).left;
<i>2470</i>&nbsp;                int meright = (parser_stack.get(parser_top-0)).right;
<i>2471</i>&nbsp;                Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2472</i>&nbsp;                 RESULT = me;
<i>2473</i>&nbsp;              parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2474</i>&nbsp;            }
<i>2475</i>&nbsp;          return parser_result;
<i>2476</i>&nbsp;
<i>2477</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2478</i>&nbsp;          case 51: // RelationalExpr ::= RelationalExpr GE AdditiveExpr
<i>2479</i>&nbsp;            {
<i>2480</i>&nbsp;              Expression RESULT = null;
<i>2481</i>&nbsp;                int releft = (parser_stack.get(parser_top-2)).left;
<i>2482</i>&nbsp;                int reright = (parser_stack.get(parser_top-2)).right;
<i>2483</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2484</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2485</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2486</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2487</i>&nbsp;                 RESULT = new RelationalExpr(Operators.GE, re, ae);
<i>2488</i>&nbsp;              parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2489</i>&nbsp;            }
<i>2490</i>&nbsp;          return parser_result;
<i>2491</i>&nbsp;
<i>2492</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2493</i>&nbsp;          case 50: // RelationalExpr ::= RelationalExpr LE AdditiveExpr
<i>2494</i>&nbsp;            {
<i>2495</i>&nbsp;              Expression RESULT = null;
<i>2496</i>&nbsp;                int releft = (parser_stack.get(parser_top-2)).left;
<i>2497</i>&nbsp;                int reright = (parser_stack.get(parser_top-2)).right;
<i>2498</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2499</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2500</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2501</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2502</i>&nbsp;                 RESULT = new RelationalExpr(Operators.LE, re, ae);
<i>2503</i>&nbsp;              parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2504</i>&nbsp;            }
<i>2505</i>&nbsp;          return parser_result;
<i>2506</i>&nbsp;
<i>2507</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2508</i>&nbsp;          case 49: // RelationalExpr ::= RelationalExpr GT AdditiveExpr
<i>2509</i>&nbsp;            {
<i>2510</i>&nbsp;              Expression RESULT = null;
<i>2511</i>&nbsp;                int releft = (parser_stack.get(parser_top-2)).left;
<i>2512</i>&nbsp;                int reright = (parser_stack.get(parser_top-2)).right;
<i>2513</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2514</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2515</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2516</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2517</i>&nbsp;                 RESULT = new RelationalExpr(Operators.GT, re, ae);
<i>2518</i>&nbsp;              parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2519</i>&nbsp;            }
<i>2520</i>&nbsp;          return parser_result;
<i>2521</i>&nbsp;
<i>2522</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2523</i>&nbsp;          case 48: // RelationalExpr ::= RelationalExpr LT AdditiveExpr
<i>2524</i>&nbsp;            {
<i>2525</i>&nbsp;              Expression RESULT = null;
<i>2526</i>&nbsp;                int releft = (parser_stack.get(parser_top-2)).left;
<i>2527</i>&nbsp;                int reright = (parser_stack.get(parser_top-2)).right;
<i>2528</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2529</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2530</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2531</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2532</i>&nbsp;                 RESULT = new RelationalExpr(Operators.LT, re, ae);
<i>2533</i>&nbsp;              parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2534</i>&nbsp;            }
<i>2535</i>&nbsp;          return parser_result;
<i>2536</i>&nbsp;
<i>2537</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2538</i>&nbsp;          case 47: // RelationalExpr ::= AdditiveExpr
<i>2539</i>&nbsp;            {
<i>2540</i>&nbsp;              Expression RESULT = null;
<i>2541</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2542</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2543</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2544</i>&nbsp;                 RESULT = ae;
<i>2545</i>&nbsp;              parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2546</i>&nbsp;            }
<i>2547</i>&nbsp;          return parser_result;
<i>2548</i>&nbsp;
<i>2549</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2550</i>&nbsp;          case 46: // EqualityExpr ::= EqualityExpr NE RelationalExpr
<i>2551</i>&nbsp;            {
<i>2552</i>&nbsp;              Expression RESULT = null;
<i>2553</i>&nbsp;                int eeleft = (parser_stack.get(parser_top-2)).left;
<i>2554</i>&nbsp;                int eeright = (parser_stack.get(parser_top-2)).right;
<i>2555</i>&nbsp;                Expression ee = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2556</i>&nbsp;                int releft = (parser_stack.get(parser_top-0)).left;
<i>2557</i>&nbsp;                int reright = (parser_stack.get(parser_top-0)).right;
<i>2558</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2559</i>&nbsp;                 RESULT = new EqualityExpr(Operators.NE, ee, re);
<i>2560</i>&nbsp;              parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2561</i>&nbsp;            }
<i>2562</i>&nbsp;          return parser_result;
<i>2563</i>&nbsp;
<i>2564</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2565</i>&nbsp;          case 45: // EqualityExpr ::= EqualityExpr EQ RelationalExpr
<i>2566</i>&nbsp;            {
<i>2567</i>&nbsp;              Expression RESULT = null;
<i>2568</i>&nbsp;                int eeleft = (parser_stack.get(parser_top-2)).left;
<i>2569</i>&nbsp;                int eeright = (parser_stack.get(parser_top-2)).right;
<i>2570</i>&nbsp;                Expression ee = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2571</i>&nbsp;                int releft = (parser_stack.get(parser_top-0)).left;
<i>2572</i>&nbsp;                int reright = (parser_stack.get(parser_top-0)).right;
<i>2573</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2574</i>&nbsp;                 RESULT = new EqualityExpr(Operators.EQ, ee, re);
<i>2575</i>&nbsp;              parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2576</i>&nbsp;            }
<i>2577</i>&nbsp;          return parser_result;
<i>2578</i>&nbsp;
<i>2579</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2580</i>&nbsp;          case 44: // EqualityExpr ::= RelationalExpr
<i>2581</i>&nbsp;            {
<i>2582</i>&nbsp;              Expression RESULT = null;
<i>2583</i>&nbsp;                int releft = (parser_stack.get(parser_top-0)).left;
<i>2584</i>&nbsp;                int reright = (parser_stack.get(parser_top-0)).right;
<i>2585</i>&nbsp;                Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2586</i>&nbsp;                 RESULT = re;
<i>2587</i>&nbsp;              parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2588</i>&nbsp;            }
<i>2589</i>&nbsp;          return parser_result;
<i>2590</i>&nbsp;
<i>2591</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2592</i>&nbsp;          case 43: // AndExpr ::= AndExpr AND EqualityExpr
<i>2593</i>&nbsp;            {
<i>2594</i>&nbsp;              Expression RESULT = null;
<i>2595</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-2)).left;
<i>2596</i>&nbsp;                int aeright = (parser_stack.get(parser_top-2)).right;
<i>2597</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2598</i>&nbsp;                int eeleft = (parser_stack.get(parser_top-0)).left;
<i>2599</i>&nbsp;                int eeright = (parser_stack.get(parser_top-0)).right;
<i>2600</i>&nbsp;                Expression ee = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2601</i>&nbsp;                 RESULT = new LogicalExpr(LogicalExpr.AND, ae, ee);
<i>2602</i>&nbsp;              parser_result = new Symbol(9/*AndExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2603</i>&nbsp;            }
<i>2604</i>&nbsp;          return parser_result;
<i>2605</i>&nbsp;
<i>2606</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2607</i>&nbsp;          case 42: // AndExpr ::= EqualityExpr
<i>2608</i>&nbsp;            {
<i>2609</i>&nbsp;              Expression RESULT = null;
<i>2610</i>&nbsp;                int eleft = (parser_stack.get(parser_top-0)).left;
<i>2611</i>&nbsp;                int eright = (parser_stack.get(parser_top-0)).right;
<i>2612</i>&nbsp;                Expression e = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2613</i>&nbsp;                 RESULT = e;
<i>2614</i>&nbsp;              parser_result = new Symbol(9/*AndExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2615</i>&nbsp;            }
<i>2616</i>&nbsp;          return parser_result;
<i>2617</i>&nbsp;
<i>2618</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2619</i>&nbsp;          case 41: // OrExpr ::= OrExpr OR AndExpr
<i>2620</i>&nbsp;            {
<i>2621</i>&nbsp;              Expression RESULT = null;
<i>2622</i>&nbsp;                int oeleft = (parser_stack.get(parser_top-2)).left;
<i>2623</i>&nbsp;                int oeright = (parser_stack.get(parser_top-2)).right;
<i>2624</i>&nbsp;                Expression oe = (Expression)(parser_stack.get(parser_top-2)).value;
<i>2625</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2626</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2627</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2628</i>&nbsp;                 RESULT = new LogicalExpr(LogicalExpr.OR, oe, ae);
<i>2629</i>&nbsp;              parser_result = new Symbol(8/*OrExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2630</i>&nbsp;            }
<i>2631</i>&nbsp;          return parser_result;
<i>2632</i>&nbsp;
<i>2633</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2634</i>&nbsp;          case 40: // OrExpr ::= AndExpr
<i>2635</i>&nbsp;            {
<i>2636</i>&nbsp;              Expression RESULT = null;
<i>2637</i>&nbsp;                int aeleft = (parser_stack.get(parser_top-0)).left;
<i>2638</i>&nbsp;                int aeright = (parser_stack.get(parser_top-0)).right;
<i>2639</i>&nbsp;                Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2640</i>&nbsp;                 RESULT = ae;
<i>2641</i>&nbsp;              parser_result = new Symbol(8/*OrExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2642</i>&nbsp;            }
<i>2643</i>&nbsp;          return parser_result;
<i>2644</i>&nbsp;
<i>2645</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2646</i>&nbsp;          case 39: // Expr ::= OrExpr
<i>2647</i>&nbsp;            {
<i>2648</i>&nbsp;              Expression RESULT = null;
<i>2649</i>&nbsp;                int exleft = (parser_stack.get(parser_top-0)).left;
<i>2650</i>&nbsp;                int exright = (parser_stack.get(parser_top-0)).right;
<i>2651</i>&nbsp;                Expression ex = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2652</i>&nbsp;                 RESULT = ex;
<i>2653</i>&nbsp;              parser_result = new Symbol(2/*Expr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2654</i>&nbsp;            }
<i>2655</i>&nbsp;          return parser_result;
<i>2656</i>&nbsp;
<i>2657</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2658</i>&nbsp;          case 38: // Predicate ::= LBRACK Expr RBRACK
<i>2659</i>&nbsp;            {
<i>2660</i>&nbsp;              Expression RESULT = null;
<i>2661</i>&nbsp;                int eleft = (parser_stack.get(parser_top-1)).left;
<i>2662</i>&nbsp;                int eright = (parser_stack.get(parser_top-1)).right;
<i>2663</i>&nbsp;                Expression e = (Expression)(parser_stack.get(parser_top-1)).value;
<i>2664</i>&nbsp;
<i>2665</i>&nbsp;                RESULT = new Predicate(e);
<i>2666</i>&nbsp;
<i>2667</i>&nbsp;              parser_result = new Symbol(5/*Predicate*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2668</i>&nbsp;            }
<i>2669</i>&nbsp;          return parser_result;
<i>2670</i>&nbsp;
<i>2671</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2672</i>&nbsp;          case 37: // Predicates ::= Predicate Predicates
<i>2673</i>&nbsp;            {
<i>2674</i>&nbsp;                List&lt;Expression&gt; RESULT = null;
<i>2675</i>&nbsp;                int pleft = (parser_stack.get(parser_top-1)).left;
<i>2676</i>&nbsp;                int pright = (parser_stack.get(parser_top-1)).right;
<i>2677</i>&nbsp;                Expression p = (Expression)(parser_stack.get(parser_top-1)).value;
<i>2678</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2679</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2680</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2681</i>&nbsp;                List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
<i>2682</i>&nbsp;                pp.add(0, p); RESULT = pp;
<i>2683</i>&nbsp;              parser_result = new Symbol(35/*Predicates*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2684</i>&nbsp;            }
<i>2685</i>&nbsp;          return parser_result;
<i>2686</i>&nbsp;
<i>2687</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2688</i>&nbsp;          case 36: // Predicates ::= Predicate
<i>2689</i>&nbsp;            {
<i>2690</i>&nbsp;                List&lt;Expression&gt; RESULT = null;
<i>2691</i>&nbsp;                int pleft = (parser_stack.get(parser_top-0)).left;
<i>2692</i>&nbsp;                int pright = (parser_stack.get(parser_top-0)).right;
<i>2693</i>&nbsp;                Expression p = (Expression)(parser_stack.get(parser_top-0)).value;
<i>2694</i>&nbsp;
<i>2695</i>&nbsp;                List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
<i>2696</i>&nbsp;                temp.add(p);
<i>2697</i>&nbsp;                RESULT = temp;
<i>2698</i>&nbsp;
<i>2699</i>&nbsp;              parser_result = new Symbol(35/*Predicates*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2700</i>&nbsp;            }
<i>2701</i>&nbsp;          return parser_result;
<i>2702</i>&nbsp;
<i>2703</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2704</i>&nbsp;          case 35: // ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
<i>2705</i>&nbsp;            {
<i>2706</i>&nbsp;              Integer RESULT = null;
<i>2707</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ATTRIBUTE);
<i>2708</i>&nbsp;              parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2709</i>&nbsp;            }
<i>2710</i>&nbsp;          return parser_result;
<i>2711</i>&nbsp;
<i>2712</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2713</i>&nbsp;          case 34: // ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
<i>2714</i>&nbsp;            {
<i>2715</i>&nbsp;              Integer RESULT = null;
<i>2716</i>&nbsp;                 RESULT = Integer.valueOf(Axis.CHILD);
<i>2717</i>&nbsp;              parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2718</i>&nbsp;            }
<i>2719</i>&nbsp;          return parser_result;
<i>2720</i>&nbsp;
<i>2721</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2722</i>&nbsp;          case 33: // ChildOrAttributeAxisSpecifier ::= ATSIGN
<i>2723</i>&nbsp;            {
<i>2724</i>&nbsp;              Integer RESULT = null;
<i>2725</i>&nbsp;                 RESULT = Integer.valueOf(Axis.ATTRIBUTE);
<i>2726</i>&nbsp;              parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2727</i>&nbsp;            }
<i>2728</i>&nbsp;          return parser_result;
<i>2729</i>&nbsp;
<i>2730</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2731</i>&nbsp;          case 32: // NameTestPattern ::= QName
<i>2732</i>&nbsp;            {
<i>2733</i>&nbsp;              Object RESULT = null;
<i>2734</i>&nbsp;                int qnleft = (parser_stack.get(parser_top-0)).left;
<i>2735</i>&nbsp;                int qnright = (parser_stack.get(parser_top-0)).right;
<i>2736</i>&nbsp;                QName qn = (QName)(parser_stack.get(parser_top-0)).value;
<i>2737</i>&nbsp;                 RESULT = qn;
<i>2738</i>&nbsp;              parser_result = new Symbol(34/*NameTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2739</i>&nbsp;            }
<i>2740</i>&nbsp;          return parser_result;
<i>2741</i>&nbsp;
<i>2742</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2743</i>&nbsp;          case 31: // NameTestPattern ::= STAR
<i>2744</i>&nbsp;            {
<i>2745</i>&nbsp;              Object RESULT = null;
<i>2746</i>&nbsp;                 RESULT = null;
<i>2747</i>&nbsp;              parser_result = new Symbol(34/*NameTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2748</i>&nbsp;            }
<i>2749</i>&nbsp;          return parser_result;
<i>2750</i>&nbsp;
<i>2751</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2752</i>&nbsp;          case 30: // NodeTestPattern ::= PI
<i>2753</i>&nbsp;            {
<i>2754</i>&nbsp;              Object RESULT = null;
<i>2755</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.PI);
<i>2756</i>&nbsp;              parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2757</i>&nbsp;            }
<i>2758</i>&nbsp;          return parser_result;
<i>2759</i>&nbsp;
<i>2760</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2761</i>&nbsp;          case 29: // NodeTestPattern ::= COMMENT
<i>2762</i>&nbsp;            {
<i>2763</i>&nbsp;              Object RESULT = null;
<i>2764</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.COMMENT);
<i>2765</i>&nbsp;              parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2766</i>&nbsp;            }
<i>2767</i>&nbsp;          return parser_result;
<i>2768</i>&nbsp;
<i>2769</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2770</i>&nbsp;          case 28: // NodeTestPattern ::= TEXT
<i>2771</i>&nbsp;            {
<i>2772</i>&nbsp;              Object RESULT = null;
<i>2773</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.TEXT);
<i>2774</i>&nbsp;              parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2775</i>&nbsp;            }
<i>2776</i>&nbsp;          return parser_result;
<i>2777</i>&nbsp;
<i>2778</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2779</i>&nbsp;          case 27: // NodeTestPattern ::= NODE
<i>2780</i>&nbsp;            {
<i>2781</i>&nbsp;              Object RESULT = null;
<i>2782</i>&nbsp;                 RESULT = Integer.valueOf(NodeTest.ANODE);
<i>2783</i>&nbsp;              parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2784</i>&nbsp;            }
<i>2785</i>&nbsp;          return parser_result;
<i>2786</i>&nbsp;
<i>2787</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2788</i>&nbsp;          case 26: // NodeTestPattern ::= NameTestPattern
<i>2789</i>&nbsp;            {
<i>2790</i>&nbsp;              Object RESULT = null;
<i>2791</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-0)).left;
<i>2792</i>&nbsp;                int ntright = (parser_stack.get(parser_top-0)).right;
<i>2793</i>&nbsp;                Object nt = parser_stack.get(parser_top-0).value;
<i>2794</i>&nbsp;                 RESULT = nt;
<i>2795</i>&nbsp;              parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2796</i>&nbsp;            }
<i>2797</i>&nbsp;          return parser_result;
<i>2798</i>&nbsp;
<i>2799</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2800</i>&nbsp;          case 25: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
<i>2801</i>&nbsp;            {
<i>2802</i>&nbsp;              StepPattern RESULT = null;
<i>2803</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-2)).left;
<i>2804</i>&nbsp;                int axisright = (parser_stack.get(parser_top-2)).right;
<i>2805</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
<i>2806</i>&nbsp;                int pipleft = (parser_stack.get(parser_top-1)).left;
<i>2807</i>&nbsp;                int pipright = (parser_stack.get(parser_top-1)).right;
<i>2808</i>&nbsp;                StepPattern pip = (StepPattern)(parser_stack.get(parser_top-1)).value;
<i>2809</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2810</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2811</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2812</i>&nbsp;                List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2813</i>&nbsp;
<i>2814</i>&nbsp;               // TODO: report error if axis is attribute
<i>2815</i>&nbsp;               RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);
<i>2816</i>&nbsp;
<i>2817</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2818</i>&nbsp;            }
<i>2819</i>&nbsp;          return parser_result;
<i>2820</i>&nbsp;
<i>2821</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2822</i>&nbsp;          case 24: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
<i>2823</i>&nbsp;            {
<i>2824</i>&nbsp;              StepPattern RESULT = null;
<i>2825</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-1)).left;
<i>2826</i>&nbsp;                int axisright = (parser_stack.get(parser_top-1)).right;
<i>2827</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
<i>2828</i>&nbsp;                int pipleft = (parser_stack.get(parser_top-0)).left;
<i>2829</i>&nbsp;                int pipright = (parser_stack.get(parser_top-0)).right;
<i>2830</i>&nbsp;                StepPattern pip = (StepPattern)(parser_stack.get(parser_top-0)).value;
<i>2831</i>&nbsp;
<i>2832</i>&nbsp;               RESULT = pip;    // TODO: report error if axis is attribute
<i>2833</i>&nbsp;
<i>2834</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2835</i>&nbsp;            }
<i>2836</i>&nbsp;          return parser_result;
<i>2837</i>&nbsp;
<i>2838</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2839</i>&nbsp;          case 23: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
<i>2840</i>&nbsp;            {
<i>2841</i>&nbsp;              StepPattern RESULT = null;
<i>2842</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-2)).left;
<i>2843</i>&nbsp;                int axisright = (parser_stack.get(parser_top-2)).right;
<i>2844</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
<i>2845</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-1)).left;
<i>2846</i>&nbsp;                int ntright = (parser_stack.get(parser_top-1)).right;
<i>2847</i>&nbsp;                Object nt = parser_stack.get(parser_top-1).value;
<i>2848</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2849</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2850</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2851</i>&nbsp;               List&lt;Predicate&gt;pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2852</i>&nbsp;
<i>2853</i>&nbsp;               RESULT = parser.createStepPattern(axis.intValue(), nt, pp);
<i>2854</i>&nbsp;
<i>2855</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2856</i>&nbsp;            }
<i>2857</i>&nbsp;          return parser_result;
<i>2858</i>&nbsp;
<i>2859</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2860</i>&nbsp;          case 22: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
<i>2861</i>&nbsp;            {
<i>2862</i>&nbsp;              StepPattern RESULT = null;
<i>2863</i>&nbsp;                int axisleft = (parser_stack.get(parser_top-1)).left;
<i>2864</i>&nbsp;                int axisright = (parser_stack.get(parser_top-1)).right;
<i>2865</i>&nbsp;                Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
<i>2866</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-0)).left;
<i>2867</i>&nbsp;                int ntright = (parser_stack.get(parser_top-0)).right;
<i>2868</i>&nbsp;                Object nt = parser_stack.get(parser_top-0).value;
<i>2869</i>&nbsp;
<i>2870</i>&nbsp;               RESULT = parser.createStepPattern(axis.intValue(), nt, null);
<i>2871</i>&nbsp;
<i>2872</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2873</i>&nbsp;            }
<i>2874</i>&nbsp;          return parser_result;
<i>2875</i>&nbsp;
<i>2876</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2877</i>&nbsp;          case 21: // StepPattern ::= ProcessingInstructionPattern Predicates
<i>2878</i>&nbsp;            {
<i>2879</i>&nbsp;              StepPattern RESULT = null;
<i>2880</i>&nbsp;                int pipleft = (parser_stack.get(parser_top-1)).left;
<i>2881</i>&nbsp;                int pipright = (parser_stack.get(parser_top-1)).right;
<i>2882</i>&nbsp;                StepPattern pip = (StepPattern)(parser_stack.get(parser_top-1)).value;
<i>2883</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2884</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2885</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2886</i>&nbsp;                List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2887</i>&nbsp;                 RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);
<i>2888</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2889</i>&nbsp;            }
<i>2890</i>&nbsp;          return parser_result;
<i>2891</i>&nbsp;
<i>2892</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2893</i>&nbsp;          case 20: // StepPattern ::= ProcessingInstructionPattern
<i>2894</i>&nbsp;            {
<i>2895</i>&nbsp;              StepPattern RESULT = null;
<i>2896</i>&nbsp;                int pipleft = (parser_stack.get(parser_top-0)).left;
<i>2897</i>&nbsp;                int pipright = (parser_stack.get(parser_top-0)).right;
<i>2898</i>&nbsp;                StepPattern pip = (StepPattern)(parser_stack.get(parser_top-0)).value;
<i>2899</i>&nbsp;                 RESULT = pip;
<i>2900</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2901</i>&nbsp;            }
<i>2902</i>&nbsp;          return parser_result;
<i>2903</i>&nbsp;
<i>2904</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2905</i>&nbsp;          case 19: // StepPattern ::= NodeTestPattern Predicates
<i>2906</i>&nbsp;            {
<i>2907</i>&nbsp;              StepPattern RESULT = null;
<i>2908</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-1)).left;
<i>2909</i>&nbsp;                int ntright = (parser_stack.get(parser_top-1)).right;
<i>2910</i>&nbsp;                Object nt = parser_stack.get(parser_top-1).value;
<i>2911</i>&nbsp;                int ppleft = (parser_stack.get(parser_top-0)).left;
<i>2912</i>&nbsp;                int ppright = (parser_stack.get(parser_top-0)).right;
<i>2913</i>&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<i>2914</i>&nbsp;                List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
<i>2915</i>&nbsp;
<i>2916</i>&nbsp;                RESULT = parser.createStepPattern(Axis.CHILD, nt, pp);
<i>2917</i>&nbsp;
<i>2918</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2919</i>&nbsp;            }
<i>2920</i>&nbsp;          return parser_result;
<i>2921</i>&nbsp;
<i>2922</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2923</i>&nbsp;          case 18: // StepPattern ::= NodeTestPattern
<i>2924</i>&nbsp;            {
<i>2925</i>&nbsp;              StepPattern RESULT = null;
<i>2926</i>&nbsp;                int ntleft = (parser_stack.get(parser_top-0)).left;
<i>2927</i>&nbsp;                int ntright = (parser_stack.get(parser_top-0)).right;
<i>2928</i>&nbsp;                Object nt = parser_stack.get(parser_top-0).value;
<i>2929</i>&nbsp;
<i>2930</i>&nbsp;                RESULT = parser.createStepPattern(Axis.CHILD, nt, null);
<i>2931</i>&nbsp;
<i>2932</i>&nbsp;              parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2933</i>&nbsp;            }
<i>2934</i>&nbsp;          return parser_result;
<i>2935</i>&nbsp;
<i>2936</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2937</i>&nbsp;          case 17: // RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
<i>2938</i>&nbsp;            {
<i>2939</i>&nbsp;              RelativePathPattern RESULT = null;
<i>2940</i>&nbsp;                int spleft = (parser_stack.get(parser_top-2)).left;
<i>2941</i>&nbsp;                int spright = (parser_stack.get(parser_top-2)).right;
<i>2942</i>&nbsp;                StepPattern sp = (StepPattern)(parser_stack.get(parser_top-2)).value;
<i>2943</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>2944</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>2945</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>2946</i>&nbsp;                 RESULT = new AncestorPattern(sp, rpp);
<i>2947</i>&nbsp;              parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2948</i>&nbsp;            }
<i>2949</i>&nbsp;          return parser_result;
<i>2950</i>&nbsp;
<i>2951</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2952</i>&nbsp;          case 16: // RelativePathPattern ::= StepPattern SLASH RelativePathPattern
<i>2953</i>&nbsp;            {
<i>2954</i>&nbsp;              RelativePathPattern RESULT = null;
<i>2955</i>&nbsp;                int spleft = (parser_stack.get(parser_top-2)).left;
<i>2956</i>&nbsp;                int spright = (parser_stack.get(parser_top-2)).right;
<i>2957</i>&nbsp;                StepPattern sp = (StepPattern)(parser_stack.get(parser_top-2)).value;
<i>2958</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>2959</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>2960</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>2961</i>&nbsp;                 RESULT = new ParentPattern(sp, rpp);
<i>2962</i>&nbsp;              parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2963</i>&nbsp;            }
<i>2964</i>&nbsp;          return parser_result;
<i>2965</i>&nbsp;
<i>2966</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2967</i>&nbsp;          case 15: // RelativePathPattern ::= StepPattern
<i>2968</i>&nbsp;            {
<i>2969</i>&nbsp;              RelativePathPattern RESULT = null;
<i>2970</i>&nbsp;                int spleft = (parser_stack.get(parser_top-0)).left;
<i>2971</i>&nbsp;                int spright = (parser_stack.get(parser_top-0)).right;
<i>2972</i>&nbsp;                StepPattern sp = (StepPattern)(parser_stack.get(parser_top-0)).value;
<i>2973</i>&nbsp;                 RESULT = sp;
<i>2974</i>&nbsp;              parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2975</i>&nbsp;            }
<i>2976</i>&nbsp;          return parser_result;
<i>2977</i>&nbsp;
<i>2978</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2979</i>&nbsp;          case 14: // ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
<i>2980</i>&nbsp;            {
<i>2981</i>&nbsp;              StepPattern RESULT = null;
<i>2982</i>&nbsp;                int lleft = (parser_stack.get(parser_top-1)).left;
<i>2983</i>&nbsp;                int lright = (parser_stack.get(parser_top-1)).right;
<i>2984</i>&nbsp;                String l = (String)(parser_stack.get(parser_top-1)).value;
<i>2985</i>&nbsp;                 RESULT = new ProcessingInstructionPattern(l);
<i>2986</i>&nbsp;              parser_result = new Symbol(30/*ProcessingInstructionPattern*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>2987</i>&nbsp;            }
<i>2988</i>&nbsp;          return parser_result;
<i>2989</i>&nbsp;
<i>2990</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>2991</i>&nbsp;          case 13: // IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
<i>2992</i>&nbsp;            {
<i>2993</i>&nbsp;              IdKeyPattern RESULT = null;
<i>2994</i>&nbsp;                int l1left = (parser_stack.get(parser_top-3)).left;
<i>2995</i>&nbsp;                int l1right = (parser_stack.get(parser_top-3)).right;
<i>2996</i>&nbsp;                String l1 = (String)(parser_stack.get(parser_top-3)).value;
<i>2997</i>&nbsp;                int l2left = (parser_stack.get(parser_top-1)).left;
<i>2998</i>&nbsp;                int l2right = (parser_stack.get(parser_top-1)).right;
<i>2999</i>&nbsp;                String l2 = (String)(parser_stack.get(parser_top-1)).value;
<i>3000</i>&nbsp;                 RESULT = new KeyPattern(l1, l2);
<i>3001</i>&nbsp;              parser_result = new Symbol(27/*IdKeyPattern*/, (parser_stack.get(parser_top-5)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3002</i>&nbsp;            }
<i>3003</i>&nbsp;          return parser_result;
<i>3004</i>&nbsp;
<i>3005</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3006</i>&nbsp;          case 12: // IdKeyPattern ::= ID LPAREN Literal RPAREN
<i>3007</i>&nbsp;            {
<i>3008</i>&nbsp;              IdKeyPattern RESULT = null;
<i>3009</i>&nbsp;                int lleft = (parser_stack.get(parser_top-1)).left;
<i>3010</i>&nbsp;                int lright = (parser_stack.get(parser_top-1)).right;
<i>3011</i>&nbsp;                String l = (String)(parser_stack.get(parser_top-1)).value;
<i>3012</i>&nbsp;                 RESULT = new IdPattern(l);
<i>3013</i>&nbsp;               parser.setHasIdCall(true);
<i>3014</i>&nbsp;
<i>3015</i>&nbsp;              parser_result = new Symbol(27/*IdKeyPattern*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3016</i>&nbsp;            }
<i>3017</i>&nbsp;          return parser_result;
<i>3018</i>&nbsp;
<i>3019</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3020</i>&nbsp;          case 11: // LocationPathPattern ::= RelativePathPattern
<i>3021</i>&nbsp;            {
<i>3022</i>&nbsp;              Pattern RESULT = null;
<i>3023</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>3024</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>3025</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>3026</i>&nbsp;                 RESULT = rpp;
<i>3027</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3028</i>&nbsp;            }
<i>3029</i>&nbsp;          return parser_result;
<i>3030</i>&nbsp;
<i>3031</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3032</i>&nbsp;          case 10: // LocationPathPattern ::= DSLASH RelativePathPattern
<i>3033</i>&nbsp;            {
<i>3034</i>&nbsp;              Pattern RESULT = null;
<i>3035</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>3036</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>3037</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>3038</i>&nbsp;                 RESULT = new AncestorPattern(rpp);
<i>3039</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3040</i>&nbsp;            }
<i>3041</i>&nbsp;          return parser_result;
<i>3042</i>&nbsp;
<i>3043</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3044</i>&nbsp;          case 9: // LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
<i>3045</i>&nbsp;            {
<i>3046</i>&nbsp;              Pattern RESULT = null;
<i>3047</i>&nbsp;                int ikpleft = (parser_stack.get(parser_top-2)).left;
<i>3048</i>&nbsp;                int ikpright = (parser_stack.get(parser_top-2)).right;
<i>3049</i>&nbsp;                IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-2)).value;
<i>3050</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>3051</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>3052</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>3053</i>&nbsp;                 RESULT = new AncestorPattern(ikp, rpp);
<i>3054</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3055</i>&nbsp;            }
<i>3056</i>&nbsp;          return parser_result;
<i>3057</i>&nbsp;
<i>3058</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3059</i>&nbsp;          case 8: // LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
<i>3060</i>&nbsp;            {
<i>3061</i>&nbsp;              Pattern RESULT = null;
<i>3062</i>&nbsp;                int ikpleft = (parser_stack.get(parser_top-2)).left;
<i>3063</i>&nbsp;                int ikpright = (parser_stack.get(parser_top-2)).right;
<i>3064</i>&nbsp;                IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-2)).value;
<i>3065</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>3066</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>3067</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>3068</i>&nbsp;                 RESULT = new ParentPattern(ikp, rpp);
<i>3069</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3070</i>&nbsp;            }
<i>3071</i>&nbsp;          return parser_result;
<i>3072</i>&nbsp;
<i>3073</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3074</i>&nbsp;          case 7: // LocationPathPattern ::= IdKeyPattern
<i>3075</i>&nbsp;            {
<i>3076</i>&nbsp;              Pattern RESULT = null;
<i>3077</i>&nbsp;                int ikpleft = (parser_stack.get(parser_top-0)).left;
<i>3078</i>&nbsp;                int ikpright = (parser_stack.get(parser_top-0)).right;
<i>3079</i>&nbsp;                IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-0)).value;
<i>3080</i>&nbsp;                 RESULT = ikp;
<i>3081</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3082</i>&nbsp;            }
<i>3083</i>&nbsp;          return parser_result;
<i>3084</i>&nbsp;
<i>3085</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3086</i>&nbsp;          case 6: // LocationPathPattern ::= SLASH RelativePathPattern
<i>3087</i>&nbsp;            {
<i>3088</i>&nbsp;              Pattern RESULT = null;
<i>3089</i>&nbsp;                int rppleft = (parser_stack.get(parser_top-0)).left;
<i>3090</i>&nbsp;                int rppright = (parser_stack.get(parser_top-0)).right;
<i>3091</i>&nbsp;                RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
<i>3092</i>&nbsp;                 RESULT = new AbsolutePathPattern(rpp);
<i>3093</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3094</i>&nbsp;            }
<i>3095</i>&nbsp;          return parser_result;
<i>3096</i>&nbsp;
<i>3097</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3098</i>&nbsp;          case 5: // LocationPathPattern ::= SLASH
<i>3099</i>&nbsp;            {
<i>3100</i>&nbsp;              Pattern RESULT = null;
<i>3101</i>&nbsp;                 RESULT = new AbsolutePathPattern(null);
<i>3102</i>&nbsp;              parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3103</i>&nbsp;            }
<i>3104</i>&nbsp;          return parser_result;
<i>3105</i>&nbsp;
<i>3106</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3107</i>&nbsp;          case 4: // Pattern ::= LocationPathPattern VBAR Pattern
<i>3108</i>&nbsp;            {
<i>3109</i>&nbsp;              Pattern RESULT = null;
<i>3110</i>&nbsp;                int lppleft = (parser_stack.get(parser_top-2)).left;
<i>3111</i>&nbsp;                int lppright = (parser_stack.get(parser_top-2)).right;
<i>3112</i>&nbsp;                Pattern lpp = (Pattern)(parser_stack.get(parser_top-2)).value;
<i>3113</i>&nbsp;                int pleft = (parser_stack.get(parser_top-0)).left;
<i>3114</i>&nbsp;                int pright = (parser_stack.get(parser_top-0)).right;
<i>3115</i>&nbsp;                Pattern p = (Pattern)(parser_stack.get(parser_top-0)).value;
<i>3116</i>&nbsp;                 RESULT = new AlternativePattern(lpp, p);
<i>3117</i>&nbsp;              parser_result = new Symbol(28/*Pattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3118</i>&nbsp;            }
<i>3119</i>&nbsp;          return parser_result;
<i>3120</i>&nbsp;
<i>3121</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3122</i>&nbsp;          case 3: // Pattern ::= LocationPathPattern
<i>3123</i>&nbsp;            {
<i>3124</i>&nbsp;              Pattern RESULT = null;
<i>3125</i>&nbsp;                int lppleft = (parser_stack.get(parser_top-0)).left;
<i>3126</i>&nbsp;                int lppright = (parser_stack.get(parser_top-0)).right;
<i>3127</i>&nbsp;                Pattern lpp = (Pattern)(parser_stack.get(parser_top-0)).value;
<i>3128</i>&nbsp;                 RESULT = lpp;
<i>3129</i>&nbsp;              parser_result = new Symbol(28/*Pattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3130</i>&nbsp;            }
<i>3131</i>&nbsp;          return parser_result;
<i>3132</i>&nbsp;
<i>3133</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3134</i>&nbsp;          case 2: // TopLevel ::= EXPRESSION Expr
<i>3135</i>&nbsp;            {
<i>3136</i>&nbsp;              SyntaxTreeNode RESULT = null;
<i>3137</i>&nbsp;                int exprleft = (parser_stack.get(parser_top-0)).left;
<i>3138</i>&nbsp;                int exprright = (parser_stack.get(parser_top-0)).right;
<i>3139</i>&nbsp;                Expression expr = (Expression)(parser_stack.get(parser_top-0)).value;
<i>3140</i>&nbsp;                 RESULT = expr;
<i>3141</i>&nbsp;              parser_result = new Symbol(1/*TopLevel*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3142</i>&nbsp;            }
<i>3143</i>&nbsp;          return parser_result;
<i>3144</i>&nbsp;
<i>3145</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3146</i>&nbsp;          case 1: // TopLevel ::= PATTERN Pattern
<i>3147</i>&nbsp;            {
<i>3148</i>&nbsp;              SyntaxTreeNode RESULT = null;
<i>3149</i>&nbsp;                int patternleft = (parser_stack.get(parser_top-0)).left;
<i>3150</i>&nbsp;                int patternright = (parser_stack.get(parser_top-0)).right;
<i>3151</i>&nbsp;                Pattern pattern = (Pattern)(parser_stack.get(parser_top-0)).value;
<i>3152</i>&nbsp;                 RESULT = pattern;
<i>3153</i>&nbsp;              parser_result = new Symbol(1/*TopLevel*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3154</i>&nbsp;            }
<i>3155</i>&nbsp;          return parser_result;
<i>3156</i>&nbsp;
<i>3157</i>&nbsp;          /*. . . . . . . . . . . . . . . . . . . .*/
<i>3158</i>&nbsp;          case 0: // $START ::= TopLevel EOF
<i>3159</i>&nbsp;            {
<i>3160</i>&nbsp;              Object RESULT = null;
<i>3161</i>&nbsp;                int start_valleft = (parser_stack.get(parser_top-1)).left;
<i>3162</i>&nbsp;                int start_valright = (parser_stack.get(parser_top-1)).right;
<i>3163</i>&nbsp;                SyntaxTreeNode start_val = (SyntaxTreeNode)(parser_stack.get(parser_top-1)).value;
<i>3164</i>&nbsp;                RESULT = start_val;
<i>3165</i>&nbsp;              parser_result = new Symbol(0/*$START*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
<i>3166</i>&nbsp;            }
<i>3167</i>&nbsp;          /* ACCEPT */
<i>3168</i>&nbsp;          parser_parser.done_parsing();
<i>3169</i>&nbsp;          return parser_result;
<i>3170</i>&nbsp;
<i>3171</i>&nbsp;          /* . . . . . .*/
<i>3172</i>&nbsp;          default:
<i>3173</i>&nbsp;            throw new Exception(
<i>3174</i>&nbsp;               &quot;Invalid action number found in internal parse table&quot;);
<i>3175</i>&nbsp;
<i>3176</i>&nbsp;        }
<i>3177</i>&nbsp;    }
<i>3178</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:14</div>
</div>
</body>
</html>
