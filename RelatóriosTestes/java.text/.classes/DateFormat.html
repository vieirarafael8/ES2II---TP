


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DateFormat</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.text</a> ]
</div>

<h1>Coverage Summary for Class: DateFormat (java.text)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DateFormat</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 69)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DateFormat$Field</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 36)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 105)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
<i>28</i>&nbsp; * (C) Copyright IBM Corp. 1996 - All Rights Reserved
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *   The original version of this source code and documentation is copyrighted
<i>31</i>&nbsp; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
<i>32</i>&nbsp; * materials are provided under terms of a License Agreement between Taligent
<i>33</i>&nbsp; * and Sun. This technology is protected by multiple US and International
<i>34</i>&nbsp; * patents. This notice and attribution to Taligent may not be removed.
<i>35</i>&nbsp; *   Taligent is a registered trademark of Taligent, Inc.
<i>36</i>&nbsp; *
<i>37</i>&nbsp; */
<i>38</i>&nbsp;
<i>39</i>&nbsp;package java.text;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import java.io.InvalidObjectException;
<i>42</i>&nbsp;import java.text.spi.DateFormatProvider;
<i>43</i>&nbsp;import java.util.Calendar;
<i>44</i>&nbsp;import java.util.Date;
<i>45</i>&nbsp;import java.util.GregorianCalendar;
<i>46</i>&nbsp;import java.util.HashMap;
<i>47</i>&nbsp;import java.util.Locale;
<i>48</i>&nbsp;import java.util.Map;
<i>49</i>&nbsp;import java.util.MissingResourceException;
<i>50</i>&nbsp;import java.util.ResourceBundle;
<i>51</i>&nbsp;import java.util.TimeZone;
<i>52</i>&nbsp;import java.util.spi.LocaleServiceProvider;
<i>53</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>54</i>&nbsp;import sun.util.locale.provider.LocaleServiceProviderPool;
<i>55</i>&nbsp;
<i>56</i>&nbsp;/**
<i>57</i>&nbsp; * {@code DateFormat} is an abstract class for date/time formatting subclasses which
<i>58</i>&nbsp; * formats and parses dates or time in a language-independent manner.
<i>59</i>&nbsp; * The date/time formatting subclass, such as {@link SimpleDateFormat}, allows for
<i>60</i>&nbsp; * formatting (i.e., date &amp;rarr; text), parsing (text &amp;rarr; date), and
<i>61</i>&nbsp; * normalization.  The date is represented as a &lt;code&gt;Date&lt;/code&gt; object or
<i>62</i>&nbsp; * as the milliseconds since January 1, 1970, 00:00:00 GMT.
<i>63</i>&nbsp; *
<i>64</i>&nbsp; * &lt;p&gt;{@code DateFormat} provides many class methods for obtaining default date/time
<i>65</i>&nbsp; * formatters based on the default or a given locale and a number of formatting
<i>66</i>&nbsp; * styles. The formatting styles include {@link #FULL}, {@link #LONG}, {@link #MEDIUM}, and {@link #SHORT}. More
<i>67</i>&nbsp; * detail and examples of using these styles are provided in the method
<i>68</i>&nbsp; * descriptions.
<i>69</i>&nbsp; *
<i>70</i>&nbsp; * &lt;p&gt;{@code DateFormat} helps you to format and parse dates for any locale.
<i>71</i>&nbsp; * Your code can be completely independent of the locale conventions for
<i>72</i>&nbsp; * months, days of the week, or even the calendar format: lunar vs. solar.
<i>73</i>&nbsp; *
<i>74</i>&nbsp; * &lt;p&gt;To format a date for the current Locale, use one of the
<i>75</i>&nbsp; * static factory methods:
<i>76</i>&nbsp; * &lt;blockquote&gt;
<i>77</i>&nbsp; * &lt;pre&gt;{@code
<i>78</i>&nbsp; * myString = DateFormat.getDateInstance().format(myDate);
<i>79</i>&nbsp; * }&lt;/pre&gt;
<i>80</i>&nbsp; * &lt;/blockquote&gt;
<i>81</i>&nbsp; * &lt;p&gt;If you are formatting multiple dates, it is
<i>82</i>&nbsp; * more efficient to get the format and use it multiple times so that
<i>83</i>&nbsp; * the system doesn&#39;t have to fetch the information about the local
<i>84</i>&nbsp; * language and country conventions multiple times.
<i>85</i>&nbsp; * &lt;blockquote&gt;
<i>86</i>&nbsp; * &lt;pre&gt;{@code
<i>87</i>&nbsp; * DateFormat df = DateFormat.getDateInstance();
<i>88</i>&nbsp; * for (int i = 0; i &lt; myDate.length; ++i) {
<i>89</i>&nbsp; *     output.println(df.format(myDate[i]) + &quot;; &quot;);
<i>90</i>&nbsp; * }
<i>91</i>&nbsp; * }&lt;/pre&gt;
<i>92</i>&nbsp; * &lt;/blockquote&gt;
<i>93</i>&nbsp; * &lt;p&gt;To format a date for a different Locale, specify it in the
<i>94</i>&nbsp; * call to {@link #getDateInstance(int, Locale) getDateInstance()}.
<i>95</i>&nbsp; * &lt;blockquote&gt;
<i>96</i>&nbsp; * &lt;pre&gt;{@code
<i>97</i>&nbsp; * DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE);
<i>98</i>&nbsp; * }&lt;/pre&gt;
<i>99</i>&nbsp; * &lt;/blockquote&gt;
<i>100</i>&nbsp; *
<i>101</i>&nbsp; * &lt;p&gt;If the specified locale contains &quot;ca&quot; (calendar), &quot;rg&quot; (region override),
<i>102</i>&nbsp; * and/or &quot;tz&quot; (timezone) &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode
<i>103</i>&nbsp; * extensions&lt;/a&gt;, the calendar, the country and/or the time zone for formatting
<i>104</i>&nbsp; * are overridden. If both &quot;ca&quot; and &quot;rg&quot; are specified, the calendar from the &quot;ca&quot;
<i>105</i>&nbsp; * extension supersedes the implicit one from the &quot;rg&quot; extension.
<i>106</i>&nbsp; *
<i>107</i>&nbsp; * &lt;p&gt;You can use a DateFormat to parse also.
<i>108</i>&nbsp; * &lt;blockquote&gt;
<i>109</i>&nbsp; * &lt;pre&gt;{@code
<i>110</i>&nbsp; * myDate = df.parse(myString);
<i>111</i>&nbsp; * }&lt;/pre&gt;
<i>112</i>&nbsp; * &lt;/blockquote&gt;
<i>113</i>&nbsp; * &lt;p&gt;Use {@code getDateInstance} to get the normal date format for that country.
<i>114</i>&nbsp; * There are other static factory methods available.
<i>115</i>&nbsp; * Use {@code getTimeInstance} to get the time format for that country.
<i>116</i>&nbsp; * Use {@code getDateTimeInstance} to get a date and time format. You can pass in
<i>117</i>&nbsp; * different options to these factory methods to control the length of the
<i>118</i>&nbsp; * result; from {@link #SHORT} to {@link #MEDIUM} to {@link #LONG} to {@link #FULL}. The exact result depends
<i>119</i>&nbsp; * on the locale, but generally:
<i>120</i>&nbsp; * &lt;ul&gt;&lt;li&gt;{@link #SHORT} is completely numeric, such as {@code 12.13.52} or {@code 3:30pm}
<i>121</i>&nbsp; * &lt;li&gt;{@link #MEDIUM} is longer, such as {@code Jan 12, 1952}
<i>122</i>&nbsp; * &lt;li&gt;{@link #LONG} is longer, such as {@code January 12, 1952} or {@code 3:30:32pm}
<i>123</i>&nbsp; * &lt;li&gt;{@link #FULL} is pretty completely specified, such as
<i>124</i>&nbsp; * {@code Tuesday, April 12, 1952 AD or 3:30:42pm PST}.
<i>125</i>&nbsp; * &lt;/ul&gt;
<i>126</i>&nbsp; *
<i>127</i>&nbsp; * &lt;p&gt;You can also set the time zone on the format if you wish.
<i>128</i>&nbsp; * If you want even more control over the format or parsing,
<i>129</i>&nbsp; * (or want to give your users more control),
<i>130</i>&nbsp; * you can try casting the {@code DateFormat} you get from the factory methods
<i>131</i>&nbsp; * to a {@link SimpleDateFormat}. This will work for the majority
<i>132</i>&nbsp; * of countries; just remember to put it in a {@code try} block in case you
<i>133</i>&nbsp; * encounter an unusual one.
<i>134</i>&nbsp; *
<i>135</i>&nbsp; * &lt;p&gt;You can also use forms of the parse and format methods with
<i>136</i>&nbsp; * {@link ParsePosition} and {@link FieldPosition} to
<i>137</i>&nbsp; * allow you to
<i>138</i>&nbsp; * &lt;ul&gt;&lt;li&gt;progressively parse through pieces of a string.
<i>139</i>&nbsp; * &lt;li&gt;align any particular field, or find out where it is for selection
<i>140</i>&nbsp; * on the screen.
<i>141</i>&nbsp; * &lt;/ul&gt;
<i>142</i>&nbsp; *
<i>143</i>&nbsp; * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
<i>144</i>&nbsp; *
<i>145</i>&nbsp; * &lt;p&gt;
<i>146</i>&nbsp; * Date formats are not synchronized.
<i>147</i>&nbsp; * It is recommended to create separate format instances for each thread.
<i>148</i>&nbsp; * If multiple threads access a format concurrently, it must be synchronized
<i>149</i>&nbsp; * externally.
<i>150</i>&nbsp; *
<i>151</i>&nbsp; * @implSpec
<i>152</i>&nbsp; * &lt;ul&gt;&lt;li&gt;The {@link #format(Date, StringBuffer, FieldPosition)} and
<i>153</i>&nbsp; * {@link #parse(String, ParsePosition)} methods may throw
<i>154</i>&nbsp; * {@code NullPointerException}, if any of their parameter is {@code null}.
<i>155</i>&nbsp; * The subclass may provide its own implementation and specification about
<i>156</i>&nbsp; * {@code NullPointerException}.&lt;/li&gt;
<i>157</i>&nbsp; * &lt;li&gt;The {@link #setCalendar(Calendar)}, {@link
<i>158</i>&nbsp; * #setNumberFormat(NumberFormat)} and {@link #setTimeZone(TimeZone)} methods
<i>159</i>&nbsp; * do not throw {@code NullPointerException} when their parameter is
<i>160</i>&nbsp; * {@code null}, but any subsequent operations on the same instance may throw
<i>161</i>&nbsp; * {@code NullPointerException}.&lt;/li&gt;
<i>162</i>&nbsp; * &lt;li&gt;The {@link #getCalendar()}, {@link #getNumberFormat()} and
<i>163</i>&nbsp; * {@link getTimeZone()} methods may return {@code null}, if the respective
<i>164</i>&nbsp; * values of this instance is set to {@code null} through the corresponding
<i>165</i>&nbsp; * setter methods. For Example: {@link #getTimeZone()} may return {@code null},
<i>166</i>&nbsp; * if the {@code TimeZone} value of this instance is set as
<i>167</i>&nbsp; * {@link #setTimeZone(java.util.TimeZone) setTimeZone(null)}.&lt;/li&gt;
<i>168</i>&nbsp; * &lt;/ul&gt;
<i>169</i>&nbsp; *
<i>170</i>&nbsp; * @see          Format
<i>171</i>&nbsp; * @see          NumberFormat
<i>172</i>&nbsp; * @see          SimpleDateFormat
<i>173</i>&nbsp; * @see          java.util.Calendar
<i>174</i>&nbsp; * @see          java.util.GregorianCalendar
<i>175</i>&nbsp; * @see          java.util.TimeZone
<i>176</i>&nbsp; * @author       Mark Davis, Chen-Lieh Huang, Alan Liu
<i>177</i>&nbsp; * @since 1.1
<i>178</i>&nbsp; */
<i>179</i>&nbsp;public abstract class DateFormat extends Format {
<i>180</i>&nbsp;
<i>181</i>&nbsp;    /**
<i>182</i>&nbsp;     * The {@link Calendar} instance used for calculating the date-time fields
<i>183</i>&nbsp;     * and the instant of time. This field is used for both formatting and
<i>184</i>&nbsp;     * parsing.
<i>185</i>&nbsp;     *
<i>186</i>&nbsp;     * &lt;p&gt;Subclasses should initialize this field to a {@link Calendar}
<i>187</i>&nbsp;     * appropriate for the {@link Locale} associated with this
<i>188</i>&nbsp;     * &lt;code&gt;DateFormat&lt;/code&gt;.
<i>189</i>&nbsp;     * @serial
<i>190</i>&nbsp;     */
<i>191</i>&nbsp;    protected Calendar calendar;
<i>192</i>&nbsp;
<i>193</i>&nbsp;    /**
<i>194</i>&nbsp;     * The number formatter that &lt;code&gt;DateFormat&lt;/code&gt; uses to format numbers
<i>195</i>&nbsp;     * in dates and times.  Subclasses should initialize this to a number format
<i>196</i>&nbsp;     * appropriate for the locale associated with this &lt;code&gt;DateFormat&lt;/code&gt;.
<i>197</i>&nbsp;     * @serial
<i>198</i>&nbsp;     */
<i>199</i>&nbsp;    protected NumberFormat numberFormat;
<i>200</i>&nbsp;
<i>201</i>&nbsp;    /**
<i>202</i>&nbsp;     * Useful constant for ERA field alignment.
<i>203</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>204</i>&nbsp;     */
<i>205</i>&nbsp;    public static final int ERA_FIELD = 0;
<i>206</i>&nbsp;    /**
<i>207</i>&nbsp;     * Useful constant for YEAR field alignment.
<i>208</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>209</i>&nbsp;     */
<i>210</i>&nbsp;    public static final int YEAR_FIELD = 1;
<i>211</i>&nbsp;    /**
<i>212</i>&nbsp;     * Useful constant for MONTH field alignment.
<i>213</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>214</i>&nbsp;     */
<i>215</i>&nbsp;    public static final int MONTH_FIELD = 2;
<i>216</i>&nbsp;    /**
<i>217</i>&nbsp;     * Useful constant for DATE field alignment.
<i>218</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>219</i>&nbsp;     */
<i>220</i>&nbsp;    public static final int DATE_FIELD = 3;
<i>221</i>&nbsp;    /**
<i>222</i>&nbsp;     * Useful constant for one-based HOUR_OF_DAY field alignment.
<i>223</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>224</i>&nbsp;     * HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.
<i>225</i>&nbsp;     * For example, 23:59 + 01:00 results in 24:59.
<i>226</i>&nbsp;     */
<i>227</i>&nbsp;    public static final int HOUR_OF_DAY1_FIELD = 4;
<i>228</i>&nbsp;    /**
<i>229</i>&nbsp;     * Useful constant for zero-based HOUR_OF_DAY field alignment.
<i>230</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>231</i>&nbsp;     * HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.
<i>232</i>&nbsp;     * For example, 23:59 + 01:00 results in 00:59.
<i>233</i>&nbsp;     */
<i>234</i>&nbsp;    public static final int HOUR_OF_DAY0_FIELD = 5;
<i>235</i>&nbsp;    /**
<i>236</i>&nbsp;     * Useful constant for MINUTE field alignment.
<i>237</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>238</i>&nbsp;     */
<i>239</i>&nbsp;    public static final int MINUTE_FIELD = 6;
<i>240</i>&nbsp;    /**
<i>241</i>&nbsp;     * Useful constant for SECOND field alignment.
<i>242</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>243</i>&nbsp;     */
<i>244</i>&nbsp;    public static final int SECOND_FIELD = 7;
<i>245</i>&nbsp;    /**
<i>246</i>&nbsp;     * Useful constant for MILLISECOND field alignment.
<i>247</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>248</i>&nbsp;     */
<i>249</i>&nbsp;    public static final int MILLISECOND_FIELD = 8;
<i>250</i>&nbsp;    /**
<i>251</i>&nbsp;     * Useful constant for DAY_OF_WEEK field alignment.
<i>252</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>253</i>&nbsp;     */
<i>254</i>&nbsp;    public static final int DAY_OF_WEEK_FIELD = 9;
<i>255</i>&nbsp;    /**
<i>256</i>&nbsp;     * Useful constant for DAY_OF_YEAR field alignment.
<i>257</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>258</i>&nbsp;     */
<i>259</i>&nbsp;    public static final int DAY_OF_YEAR_FIELD = 10;
<i>260</i>&nbsp;    /**
<i>261</i>&nbsp;     * Useful constant for DAY_OF_WEEK_IN_MONTH field alignment.
<i>262</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>263</i>&nbsp;     */
<i>264</i>&nbsp;    public static final int DAY_OF_WEEK_IN_MONTH_FIELD = 11;
<i>265</i>&nbsp;    /**
<i>266</i>&nbsp;     * Useful constant for WEEK_OF_YEAR field alignment.
<i>267</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>268</i>&nbsp;     */
<i>269</i>&nbsp;    public static final int WEEK_OF_YEAR_FIELD = 12;
<i>270</i>&nbsp;    /**
<i>271</i>&nbsp;     * Useful constant for WEEK_OF_MONTH field alignment.
<i>272</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>273</i>&nbsp;     */
<i>274</i>&nbsp;    public static final int WEEK_OF_MONTH_FIELD = 13;
<i>275</i>&nbsp;    /**
<i>276</i>&nbsp;     * Useful constant for AM_PM field alignment.
<i>277</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>278</i>&nbsp;     */
<i>279</i>&nbsp;    public static final int AM_PM_FIELD = 14;
<i>280</i>&nbsp;    /**
<i>281</i>&nbsp;     * Useful constant for one-based HOUR field alignment.
<i>282</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>283</i>&nbsp;     * HOUR1_FIELD is used for the one-based 12-hour clock.
<i>284</i>&nbsp;     * For example, 11:30 PM + 1 hour results in 12:30 AM.
<i>285</i>&nbsp;     */
<i>286</i>&nbsp;    public static final int HOUR1_FIELD = 15;
<i>287</i>&nbsp;    /**
<i>288</i>&nbsp;     * Useful constant for zero-based HOUR field alignment.
<i>289</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>290</i>&nbsp;     * HOUR0_FIELD is used for the zero-based 12-hour clock.
<i>291</i>&nbsp;     * For example, 11:30 PM + 1 hour results in 00:30 AM.
<i>292</i>&nbsp;     */
<i>293</i>&nbsp;    public static final int HOUR0_FIELD = 16;
<i>294</i>&nbsp;    /**
<i>295</i>&nbsp;     * Useful constant for TIMEZONE field alignment.
<i>296</i>&nbsp;     * Used in FieldPosition of date/time formatting.
<i>297</i>&nbsp;     */
<i>298</i>&nbsp;    public static final int TIMEZONE_FIELD = 17;
<i>299</i>&nbsp;
<i>300</i>&nbsp;    // Proclaim serial compatibility with 1.1 FCS
<i>301</i>&nbsp;    private static final long serialVersionUID = 7218322306649953788L;
<i>302</i>&nbsp;
<i>303</i>&nbsp;    /**
<b class="nc"><i>304</i>&nbsp;     * Formats the given {@code Object} into a date-time string. The formatted</b>
<b class="nc"><i>305</i>&nbsp;     * string is appended to the given {@code StringBuffer}.</b>
<b class="nc"><i>306</i>&nbsp;     *</b>
<b class="nc"><i>307</i>&nbsp;     * @param obj Must be a {@code Date} or a {@code Number} representing a</b>
<i>308</i>&nbsp;     * millisecond offset from the &lt;a href=&quot;../util/Calendar.html#Epoch&quot;&gt;Epoch&lt;/a&gt;.
<i>309</i>&nbsp;     * @param toAppendTo The string buffer for the returning date-time string.
<b class="nc"><i>310</i>&nbsp;     * @param fieldPosition keeps track on the position of the field within</b>
<i>311</i>&nbsp;     * the returned string. For example, given a date-time text
<i>312</i>&nbsp;     * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
<i>313</i>&nbsp;     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
<i>314</i>&nbsp;     * {@code fieldPosition} will be set to 0 and 4, respectively.
<i>315</i>&nbsp;     * Notice that if the same date-time field appears more than once in a
<i>316</i>&nbsp;     * pattern, the {@code fieldPosition} will be set for the first occurrence
<i>317</i>&nbsp;     * of that date-time field. For instance, formatting a {@code Date} to the
<i>318</i>&nbsp;     * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
<i>319</i>&nbsp;     * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
<i>320</i>&nbsp;     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
<i>321</i>&nbsp;     * {@code fieldPosition} will be set to 5 and 8, respectively, for the
<i>322</i>&nbsp;     * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
<i>323</i>&nbsp;     * @return the string buffer passed in as {@code toAppendTo},
<i>324</i>&nbsp;     *         with formatted text appended.
<i>325</i>&nbsp;     * @exception IllegalArgumentException if the {@code Format} cannot format
<i>326</i>&nbsp;     *            the given {@code obj}.
<i>327</i>&nbsp;     * @see java.text.Format
<i>328</i>&nbsp;     */
<i>329</i>&nbsp;    public final StringBuffer format(Object obj, StringBuffer toAppendTo,
<i>330</i>&nbsp;                                     FieldPosition fieldPosition)
<i>331</i>&nbsp;    {
<i>332</i>&nbsp;        if (obj instanceof Date)
<i>333</i>&nbsp;            return format( (Date)obj, toAppendTo, fieldPosition );
<i>334</i>&nbsp;        else if (obj instanceof Number)
<i>335</i>&nbsp;            return format( new Date(((Number)obj).longValue()),
<i>336</i>&nbsp;                          toAppendTo, fieldPosition );
<i>337</i>&nbsp;        else
<i>338</i>&nbsp;            throw new IllegalArgumentException(&quot;Cannot format given Object as a Date&quot;);
<i>339</i>&nbsp;    }
<i>340</i>&nbsp;
<i>341</i>&nbsp;    /**
<i>342</i>&nbsp;     * Formats a {@link Date} into a date-time string. The formatted
<i>343</i>&nbsp;     * string is appended to the given {@code StringBuffer}.
<i>344</i>&nbsp;     *
<b class="nc"><i>345</i>&nbsp;     * @param date a Date to be formatted into a date-time string.</b>
<b class="nc"><i>346</i>&nbsp;     * @param toAppendTo the string buffer for the returning date-time string.</b>
<i>347</i>&nbsp;     * @param fieldPosition keeps track on the position of the field within
<i>348</i>&nbsp;     * the returned string. For example, given a date-time text
<i>349</i>&nbsp;     * {@code &quot;1996.07.10 AD at 15:08:56 PDT&quot;}, if the given {@code fieldPosition}
<i>350</i>&nbsp;     * is {@link DateFormat#YEAR_FIELD}, the begin index and end index of
<i>351</i>&nbsp;     * {@code fieldPosition} will be set to 0 and 4, respectively.
<i>352</i>&nbsp;     * Notice that if the same date-time field appears more than once in a
<i>353</i>&nbsp;     * pattern, the {@code fieldPosition} will be set for the first occurrence
<i>354</i>&nbsp;     * of that date-time field. For instance, formatting a {@code Date} to the
<i>355</i>&nbsp;     * date-time string {@code &quot;1 PM PDT (Pacific Daylight Time)&quot;} using the
<i>356</i>&nbsp;     * pattern {@code &quot;h a z (zzzz)&quot;} and the alignment field
<i>357</i>&nbsp;     * {@link DateFormat#TIMEZONE_FIELD}, the begin index and end index of
<i>358</i>&nbsp;     * {@code fieldPosition} will be set to 5 and 8, respectively, for the
<i>359</i>&nbsp;     * first occurrence of the timezone pattern character {@code &#39;z&#39;}.
<i>360</i>&nbsp;     * @return the string buffer passed in as {@code toAppendTo}, with formatted
<i>361</i>&nbsp;     * text appended.
<i>362</i>&nbsp;     */
<b class="nc"><i>363</i>&nbsp;    public abstract StringBuffer format(Date date, StringBuffer toAppendTo,</b>
<b class="nc"><i>364</i>&nbsp;                                        FieldPosition fieldPosition);</b>
<b class="nc"><i>365</i>&nbsp;</b>
<b class="nc"><i>366</i>&nbsp;    /**</b>
<i>367</i>&nbsp;      * Formats a {@link Date} into a date-time string.
<b class="nc"><i>368</i>&nbsp;      *</b>
<i>369</i>&nbsp;      * @param date the time value to be formatted into a date-time string.
<i>370</i>&nbsp;      * @return the formatted date-time string.
<i>371</i>&nbsp;     */
<i>372</i>&nbsp;    public final String format(Date date)
<i>373</i>&nbsp;    {
<i>374</i>&nbsp;        return format(date, new StringBuffer(),
<i>375</i>&nbsp;                      DontCareFieldPosition.INSTANCE).toString();
<i>376</i>&nbsp;    }
<i>377</i>&nbsp;
<i>378</i>&nbsp;    /**
<i>379</i>&nbsp;     * Parses text from the beginning of the given string to produce a date.
<i>380</i>&nbsp;     * The method may not use the entire text of the given string.
<i>381</i>&nbsp;     * &lt;p&gt;
<i>382</i>&nbsp;     * See the {@link #parse(String, ParsePosition)} method for more information
<i>383</i>&nbsp;     * on date parsing.
<i>384</i>&nbsp;     *
<i>385</i>&nbsp;     * @param source A &lt;code&gt;String&lt;/code&gt; whose beginning should be parsed.
<i>386</i>&nbsp;     * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string.
<i>387</i>&nbsp;     * @exception ParseException if the beginning of the specified string
<i>388</i>&nbsp;     *            cannot be parsed.
<i>389</i>&nbsp;     */
<i>390</i>&nbsp;    public Date parse(String source) throws ParseException
<i>391</i>&nbsp;    {
<i>392</i>&nbsp;        ParsePosition pos = new ParsePosition(0);
<i>393</i>&nbsp;        Date result = parse(source, pos);
<i>394</i>&nbsp;        if (pos.index == 0)
<i>395</i>&nbsp;            throw new ParseException(&quot;Unparseable date: \&quot;&quot; + source + &quot;\&quot;&quot; ,
<i>396</i>&nbsp;                pos.errorIndex);
<i>397</i>&nbsp;        return result;
<i>398</i>&nbsp;    }
<i>399</i>&nbsp;
<i>400</i>&nbsp;    /**
<i>401</i>&nbsp;     * Parse a date/time string according to the given parse position.  For
<i>402</i>&nbsp;     * example, a time text {@code &quot;07/10/96 4:5 PM, PDT&quot;} will be parsed into a {@code Date}
<i>403</i>&nbsp;     * that is equivalent to {@code Date(837039900000L)}.
<i>404</i>&nbsp;     *
<i>405</i>&nbsp;     * &lt;p&gt; By default, parsing is lenient: If the input is not in the form used
<i>406</i>&nbsp;     * by this object&#39;s format method but can still be parsed as a date, then
<i>407</i>&nbsp;     * the parse succeeds.  Clients may insist on strict adherence to the
<i>408</i>&nbsp;     * format by calling {@link #setLenient(boolean) setLenient(false)}.
<i>409</i>&nbsp;     *
<i>410</i>&nbsp;     * &lt;p&gt;This parsing operation uses the {@link #calendar} to produce
<i>411</i>&nbsp;     * a {@code Date}. As a result, the {@code calendar}&#39;s date-time
<i>412</i>&nbsp;     * fields and the {@code TimeZone} value may have been
<i>413</i>&nbsp;     * overwritten, depending on subclass implementations. Any {@code
<i>414</i>&nbsp;     * TimeZone} value that has previously been set by a call to
<i>415</i>&nbsp;     * {@link #setTimeZone(java.util.TimeZone) setTimeZone} may need
<i>416</i>&nbsp;     * to be restored for further operations.
<i>417</i>&nbsp;     *
<i>418</i>&nbsp;     * @param source  The date/time string to be parsed
<i>419</i>&nbsp;     *
<i>420</i>&nbsp;     * @param pos   On input, the position at which to start parsing; on
<i>421</i>&nbsp;     *              output, the position at which parsing terminated, or the
<i>422</i>&nbsp;     *              start position if the parse failed.
<i>423</i>&nbsp;     *
<b class="nc"><i>424</i>&nbsp;     * @return      A {@code Date}, or {@code null} if the input could not be parsed</b>
<i>425</i>&nbsp;     */
<i>426</i>&nbsp;    public abstract Date parse(String source, ParsePosition pos);
<i>427</i>&nbsp;
<i>428</i>&nbsp;    /**
<i>429</i>&nbsp;     * Parses text from a string to produce a &lt;code&gt;Date&lt;/code&gt;.
<i>430</i>&nbsp;     * &lt;p&gt;
<i>431</i>&nbsp;     * The method attempts to parse text starting at the index given by
<i>432</i>&nbsp;     * &lt;code&gt;pos&lt;/code&gt;.
<i>433</i>&nbsp;     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
<i>434</i>&nbsp;     * to the index after the last character used (parsing does not necessarily
<i>435</i>&nbsp;     * use all characters up to the end of the string), and the parsed
<i>436</i>&nbsp;     * date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to
<i>437</i>&nbsp;     * indicate the starting point for the next call to this method.
<i>438</i>&nbsp;     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not
<i>439</i>&nbsp;     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
<i>440</i>&nbsp;     * the character where the error occurred, and null is returned.
<i>441</i>&nbsp;     * &lt;p&gt;
<i>442</i>&nbsp;     * See the {@link #parse(String, ParsePosition)} method for more information
<i>443</i>&nbsp;     * on date parsing.
<i>444</i>&nbsp;     *
<i>445</i>&nbsp;     * @param source A &lt;code&gt;String&lt;/code&gt;, part of which should be parsed.
<i>446</i>&nbsp;     * @param pos A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
<i>447</i>&nbsp;     *            index information as described above.
<i>448</i>&nbsp;     * @return A &lt;code&gt;Date&lt;/code&gt; parsed from the string. In case of
<i>449</i>&nbsp;     *         error, returns null.
<i>450</i>&nbsp;     * @throws NullPointerException if {@code source} or {@code pos} is null.
<i>451</i>&nbsp;     */
<i>452</i>&nbsp;    public Object parseObject(String source, ParsePosition pos) {
<i>453</i>&nbsp;        return parse(source, pos);
<i>454</i>&nbsp;    }
<i>455</i>&nbsp;
<i>456</i>&nbsp;    /**
<i>457</i>&nbsp;     * Constant for full style pattern.
<i>458</i>&nbsp;     */
<i>459</i>&nbsp;    public static final int FULL = 0;
<b class="nc"><i>460</i>&nbsp;    /**</b>
<i>461</i>&nbsp;     * Constant for long style pattern.
<i>462</i>&nbsp;     */
<i>463</i>&nbsp;    public static final int LONG = 1;
<i>464</i>&nbsp;    /**
<i>465</i>&nbsp;     * Constant for medium style pattern.
<i>466</i>&nbsp;     */
<i>467</i>&nbsp;    public static final int MEDIUM = 2;
<i>468</i>&nbsp;    /**
<i>469</i>&nbsp;     * Constant for short style pattern.
<i>470</i>&nbsp;     */
<i>471</i>&nbsp;    public static final int SHORT = 3;
<i>472</i>&nbsp;    /**
<i>473</i>&nbsp;     * Constant for default style pattern.  Its value is MEDIUM.
<i>474</i>&nbsp;     */
<i>475</i>&nbsp;    public static final int DEFAULT = MEDIUM;
<i>476</i>&nbsp;
<b class="nc"><i>477</i>&nbsp;    /**</b>
<i>478</i>&nbsp;     * Gets the time formatter with the default formatting style
<i>479</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>480</i>&nbsp;     * &lt;p&gt;This is equivalent to calling
<i>481</i>&nbsp;     * {@link #getTimeInstance(int, Locale) getTimeInstance(DEFAULT,
<i>482</i>&nbsp;     *     Locale.getDefault(Locale.Category.FORMAT))}.
<i>483</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>484</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>485</i>&nbsp;     * @return a time formatter.
<i>486</i>&nbsp;     */
<i>487</i>&nbsp;    public static final DateFormat getTimeInstance()
<i>488</i>&nbsp;    {
<i>489</i>&nbsp;        return get(DEFAULT, 0, 1, Locale.getDefault(Locale.Category.FORMAT));
<i>490</i>&nbsp;    }
<b class="nc"><i>491</i>&nbsp;</b>
<i>492</i>&nbsp;    /**
<i>493</i>&nbsp;     * Gets the time formatter with the given formatting style
<i>494</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>495</i>&nbsp;     * &lt;p&gt;This is equivalent to calling
<i>496</i>&nbsp;     * {@link #getTimeInstance(int, Locale) getTimeInstance(style,
<i>497</i>&nbsp;     *     Locale.getDefault(Locale.Category.FORMAT))}.
<i>498</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>499</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>500</i>&nbsp;     * @param style the given formatting style. For example,
<i>501</i>&nbsp;     * SHORT for &quot;h:mm a&quot; in the US locale.
<i>502</i>&nbsp;     * @return a time formatter.
<i>503</i>&nbsp;     */
<i>504</i>&nbsp;    public static final DateFormat getTimeInstance(int style)
<i>505</i>&nbsp;    {
<b class="nc"><i>506</i>&nbsp;        return get(style, 0, 1, Locale.getDefault(Locale.Category.FORMAT));</b>
<i>507</i>&nbsp;    }
<i>508</i>&nbsp;
<i>509</i>&nbsp;    /**
<i>510</i>&nbsp;     * Gets the time formatter with the given formatting style
<i>511</i>&nbsp;     * for the given locale.
<i>512</i>&nbsp;     * @param style the given formatting style. For example,
<i>513</i>&nbsp;     * SHORT for &quot;h:mm a&quot; in the US locale.
<i>514</i>&nbsp;     * @param aLocale the given locale.
<i>515</i>&nbsp;     * @return a time formatter.
<i>516</i>&nbsp;     */
<i>517</i>&nbsp;    public static final DateFormat getTimeInstance(int style,
<i>518</i>&nbsp;                                                 Locale aLocale)
<i>519</i>&nbsp;    {
<i>520</i>&nbsp;        return get(style, 0, 1, aLocale);
<i>521</i>&nbsp;    }
<i>522</i>&nbsp;
<b class="nc"><i>523</i>&nbsp;    /**</b>
<i>524</i>&nbsp;     * Gets the date formatter with the default formatting style
<i>525</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>526</i>&nbsp;     * &lt;p&gt;This is equivalent to calling
<i>527</i>&nbsp;     * {@link #getDateInstance(int, Locale) getDateInstance(DEFAULT,
<i>528</i>&nbsp;     *     Locale.getDefault(Locale.Category.FORMAT))}.
<i>529</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>530</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>531</i>&nbsp;     * @return a date formatter.
<i>532</i>&nbsp;     */
<i>533</i>&nbsp;    public static final DateFormat getDateInstance()
<i>534</i>&nbsp;    {
<i>535</i>&nbsp;        return get(0, DEFAULT, 2, Locale.getDefault(Locale.Category.FORMAT));
<i>536</i>&nbsp;    }
<b class="nc"><i>537</i>&nbsp;</b>
<i>538</i>&nbsp;    /**
<i>539</i>&nbsp;     * Gets the date formatter with the given formatting style
<i>540</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>541</i>&nbsp;     * &lt;p&gt;This is equivalent to calling
<i>542</i>&nbsp;     * {@link #getDateInstance(int, Locale) getDateInstance(style,
<i>543</i>&nbsp;     *     Locale.getDefault(Locale.Category.FORMAT))}.
<i>544</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>545</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>546</i>&nbsp;     * @param style the given formatting style. For example,
<i>547</i>&nbsp;     * SHORT for &quot;M/d/yy&quot; in the US locale.
<i>548</i>&nbsp;     * @return a date formatter.
<i>549</i>&nbsp;     */
<i>550</i>&nbsp;    public static final DateFormat getDateInstance(int style)
<i>551</i>&nbsp;    {
<b class="nc"><i>552</i>&nbsp;        return get(0, style, 2, Locale.getDefault(Locale.Category.FORMAT));</b>
<i>553</i>&nbsp;    }
<i>554</i>&nbsp;
<i>555</i>&nbsp;    /**
<i>556</i>&nbsp;     * Gets the date formatter with the given formatting style
<i>557</i>&nbsp;     * for the given locale.
<i>558</i>&nbsp;     * @param style the given formatting style. For example,
<i>559</i>&nbsp;     * SHORT for &quot;M/d/yy&quot; in the US locale.
<i>560</i>&nbsp;     * @param aLocale the given locale.
<i>561</i>&nbsp;     * @return a date formatter.
<i>562</i>&nbsp;     */
<i>563</i>&nbsp;    public static final DateFormat getDateInstance(int style,
<i>564</i>&nbsp;                                                 Locale aLocale)
<i>565</i>&nbsp;    {
<i>566</i>&nbsp;        return get(0, style, 2, aLocale);
<i>567</i>&nbsp;    }
<i>568</i>&nbsp;
<i>569</i>&nbsp;    /**
<i>570</i>&nbsp;     * Gets the date/time formatter with the default formatting style
<i>571</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<b class="nc"><i>572</i>&nbsp;     * &lt;p&gt;This is equivalent to calling</b>
<i>573</i>&nbsp;     * {@link #getDateTimeInstance(int, int, Locale) getDateTimeInstance(DEFAULT,
<i>574</i>&nbsp;     *     DEFAULT, Locale.getDefault(Locale.Category.FORMAT))}.
<i>575</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>576</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>577</i>&nbsp;     * @return a date/time formatter.
<i>578</i>&nbsp;     */
<i>579</i>&nbsp;    public static final DateFormat getDateTimeInstance()
<i>580</i>&nbsp;    {
<i>581</i>&nbsp;        return get(DEFAULT, DEFAULT, 3, Locale.getDefault(Locale.Category.FORMAT));
<i>582</i>&nbsp;    }
<i>583</i>&nbsp;
<i>584</i>&nbsp;    /**
<i>585</i>&nbsp;     * Gets the date/time formatter with the given date and time
<b class="nc"><i>586</i>&nbsp;     * formatting styles for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.</b>
<i>587</i>&nbsp;     * &lt;p&gt;This is equivalent to calling
<i>588</i>&nbsp;     * {@link #getDateTimeInstance(int, int, Locale) getDateTimeInstance(dateStyle,
<i>589</i>&nbsp;     *     timeStyle, Locale.getDefault(Locale.Category.FORMAT))}.
<i>590</i>&nbsp;     * @see java.util.Locale#getDefault(java.util.Locale.Category)
<i>591</i>&nbsp;     * @see java.util.Locale.Category#FORMAT
<i>592</i>&nbsp;     * @param dateStyle the given date formatting style. For example,
<i>593</i>&nbsp;     * SHORT for &quot;M/d/yy&quot; in the US locale.
<i>594</i>&nbsp;     * @param timeStyle the given time formatting style. For example,
<i>595</i>&nbsp;     * SHORT for &quot;h:mm a&quot; in the US locale.
<b class="nc"><i>596</i>&nbsp;     * @return a date/time formatter.</b>
<i>597</i>&nbsp;     */
<i>598</i>&nbsp;    public static final DateFormat getDateTimeInstance(int dateStyle,
<i>599</i>&nbsp;                                                       int timeStyle)
<i>600</i>&nbsp;    {
<i>601</i>&nbsp;        return get(timeStyle, dateStyle, 3, Locale.getDefault(Locale.Category.FORMAT));
<i>602</i>&nbsp;    }
<i>603</i>&nbsp;
<i>604</i>&nbsp;    /**
<i>605</i>&nbsp;     * Gets the date/time formatter with the given formatting styles
<i>606</i>&nbsp;     * for the given locale.
<i>607</i>&nbsp;     * @param dateStyle the given date formatting style.
<i>608</i>&nbsp;     * @param timeStyle the given time formatting style.
<i>609</i>&nbsp;     * @param aLocale the given locale.
<i>610</i>&nbsp;     * @return a date/time formatter.
<i>611</i>&nbsp;     */
<i>612</i>&nbsp;    public static final DateFormat
<i>613</i>&nbsp;        getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale)
<b class="nc"><i>614</i>&nbsp;    {</b>
<b class="nc"><i>615</i>&nbsp;        return get(timeStyle, dateStyle, 3, aLocale);</b>
<b class="nc"><i>616</i>&nbsp;    }</b>
<i>617</i>&nbsp;
<i>618</i>&nbsp;    /**
<i>619</i>&nbsp;     * Get a default date/time formatter that uses the SHORT style for both the
<i>620</i>&nbsp;     * date and the time.
<i>621</i>&nbsp;     *
<i>622</i>&nbsp;     * @return a date/time formatter
<i>623</i>&nbsp;     */
<i>624</i>&nbsp;    public static final DateFormat getInstance() {
<i>625</i>&nbsp;        return getDateTimeInstance(SHORT, SHORT);
<i>626</i>&nbsp;    }
<i>627</i>&nbsp;
<i>628</i>&nbsp;    /**
<i>629</i>&nbsp;     * Returns an array of all locales for which the
<i>630</i>&nbsp;     * &lt;code&gt;get*Instance&lt;/code&gt; methods of this class can return
<b class="nc"><i>631</i>&nbsp;     * localized instances.</b>
<i>632</i>&nbsp;     * The returned array represents the union of locales supported by the Java
<i>633</i>&nbsp;     * runtime and by installed
<i>634</i>&nbsp;     * {@link java.text.spi.DateFormatProvider DateFormatProvider} implementations.
<i>635</i>&nbsp;     * It must contain at least a &lt;code&gt;Locale&lt;/code&gt; instance equal to
<i>636</i>&nbsp;     * {@link java.util.Locale#US Locale.US}.
<i>637</i>&nbsp;     *
<i>638</i>&nbsp;     * @return An array of locales for which localized
<i>639</i>&nbsp;     *         &lt;code&gt;DateFormat&lt;/code&gt; instances are available.
<i>640</i>&nbsp;     */
<b class="nc"><i>641</i>&nbsp;    public static Locale[] getAvailableLocales()</b>
<i>642</i>&nbsp;    {
<i>643</i>&nbsp;        LocaleServiceProviderPool pool =
<i>644</i>&nbsp;            LocaleServiceProviderPool.getPool(DateFormatProvider.class);
<i>645</i>&nbsp;        return pool.getAvailableLocales();
<i>646</i>&nbsp;    }
<i>647</i>&nbsp;
<i>648</i>&nbsp;    /**
<i>649</i>&nbsp;     * Set the calendar to be used by this date format.  Initially, the default
<b class="nc"><i>650</i>&nbsp;     * calendar for the specified or default locale is used.</b>
<i>651</i>&nbsp;     *
<i>652</i>&nbsp;     * &lt;p&gt;Any {@link java.util.TimeZone TimeZone} and {@linkplain
<i>653</i>&nbsp;     * #isLenient() leniency} values that have previously been set are
<i>654</i>&nbsp;     * overwritten by {@code newCalendar}&#39;s values.
<i>655</i>&nbsp;     *
<i>656</i>&nbsp;     * @param newCalendar the new {@code Calendar} to be used by the date format
<i>657</i>&nbsp;     */
<i>658</i>&nbsp;    public void setCalendar(Calendar newCalendar)
<i>659</i>&nbsp;    {
<b class="nc"><i>660</i>&nbsp;        this.calendar = newCalendar;</b>
<i>661</i>&nbsp;    }
<i>662</i>&nbsp;
<i>663</i>&nbsp;    /**
<i>664</i>&nbsp;     * Gets the calendar associated with this date/time formatter.
<i>665</i>&nbsp;     *
<i>666</i>&nbsp;     * @return the calendar associated with this date/time formatter.
<i>667</i>&nbsp;     */
<i>668</i>&nbsp;    public Calendar getCalendar()
<i>669</i>&nbsp;    {
<i>670</i>&nbsp;        return calendar;
<i>671</i>&nbsp;    }
<i>672</i>&nbsp;
<i>673</i>&nbsp;    /**
<i>674</i>&nbsp;     * Allows you to set the number formatter.
<i>675</i>&nbsp;     * @param newNumberFormat the given new NumberFormat.
<i>676</i>&nbsp;     */
<i>677</i>&nbsp;    public void setNumberFormat(NumberFormat newNumberFormat)
<i>678</i>&nbsp;    {
<i>679</i>&nbsp;        this.numberFormat = newNumberFormat;
<b class="nc"><i>680</i>&nbsp;    }</b>
<i>681</i>&nbsp;
<i>682</i>&nbsp;    /**
<i>683</i>&nbsp;     * Gets the number formatter which this date/time formatter uses to
<i>684</i>&nbsp;     * format and parse a time.
<i>685</i>&nbsp;     * @return the number formatter which this date/time formatter uses.
<i>686</i>&nbsp;     */
<i>687</i>&nbsp;    public NumberFormat getNumberFormat()
<i>688</i>&nbsp;    {
<i>689</i>&nbsp;        return numberFormat;
<i>690</i>&nbsp;    }
<i>691</i>&nbsp;
<i>692</i>&nbsp;    /**
<i>693</i>&nbsp;     * Sets the time zone for the calendar of this {@code DateFormat} object.
<b class="nc"><i>694</i>&nbsp;     * This method is equivalent to the following call.</b>
<i>695</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>696</i>&nbsp;     * getCalendar().setTimeZone(zone)
<i>697</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>698</i>&nbsp;     *
<i>699</i>&nbsp;     * &lt;p&gt;The {@code TimeZone} set by this method is overwritten by a
<i>700</i>&nbsp;     * {@link #setCalendar(java.util.Calendar) setCalendar} call.
<i>701</i>&nbsp;     *
<i>702</i>&nbsp;     * &lt;p&gt;The {@code TimeZone} set by this method may be overwritten as
<i>703</i>&nbsp;     * a result of a call to the parse method.
<i>704</i>&nbsp;     *
<i>705</i>&nbsp;     * @param zone the given new time zone.
<i>706</i>&nbsp;     */
<i>707</i>&nbsp;    public void setTimeZone(TimeZone zone)
<i>708</i>&nbsp;    {
<i>709</i>&nbsp;        calendar.setTimeZone(zone);
<i>710</i>&nbsp;    }
<i>711</i>&nbsp;
<i>712</i>&nbsp;    /**
<i>713</i>&nbsp;     * Gets the time zone.
<i>714</i>&nbsp;     * This method is equivalent to the following call.
<i>715</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<b class="nc"><i>716</i>&nbsp;     * getCalendar().getTimeZone()</b>
<i>717</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>718</i>&nbsp;     *
<i>719</i>&nbsp;     * @return the time zone associated with the calendar of DateFormat.
<i>720</i>&nbsp;     */
<i>721</i>&nbsp;    public TimeZone getTimeZone()
<i>722</i>&nbsp;    {
<i>723</i>&nbsp;        return calendar.getTimeZone();
<i>724</i>&nbsp;    }
<i>725</i>&nbsp;
<i>726</i>&nbsp;    /**
<i>727</i>&nbsp;     * Specify whether or not date/time parsing is to be lenient.  With
<i>728</i>&nbsp;     * lenient parsing, the parser may use heuristics to interpret inputs that
<i>729</i>&nbsp;     * do not precisely match this object&#39;s format.  With strict parsing,
<i>730</i>&nbsp;     * inputs must match this object&#39;s format.
<i>731</i>&nbsp;     *
<b class="nc"><i>732</i>&nbsp;     * &lt;p&gt;This method is equivalent to the following call.</b>
<i>733</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>734</i>&nbsp;     * getCalendar().setLenient(lenient)
<i>735</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>736</i>&nbsp;     *
<i>737</i>&nbsp;     * &lt;p&gt;This leniency value is overwritten by a call to {@link
<i>738</i>&nbsp;     * #setCalendar(java.util.Calendar) setCalendar()}.
<b class="nc"><i>739</i>&nbsp;     *</b>
<i>740</i>&nbsp;     * @param lenient when {@code true}, parsing is lenient
<i>741</i>&nbsp;     * @see java.util.Calendar#setLenient(boolean)
<i>742</i>&nbsp;     */
<i>743</i>&nbsp;    public void setLenient(boolean lenient)
<i>744</i>&nbsp;    {
<i>745</i>&nbsp;        calendar.setLenient(lenient);
<i>746</i>&nbsp;    }
<b class="nc"><i>747</i>&nbsp;</b>
<b class="nc"><i>748</i>&nbsp;    /**</b>
<b class="nc"><i>749</i>&nbsp;     * Tell whether date/time parsing is to be lenient.</b>
<b class="nc"><i>750</i>&nbsp;     * This method is equivalent to the following call.</b>
<b class="nc"><i>751</i>&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code</b>
<b class="nc"><i>752</i>&nbsp;     * getCalendar().isLenient()</b>
<b class="nc"><i>753</i>&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;</b>
<b class="nc"><i>754</i>&nbsp;     *</b>
<b class="nc"><i>755</i>&nbsp;     * @return {@code true} if the {@link #calendar} is lenient;</b>
<i>756</i>&nbsp;     *         {@code false} otherwise.
<i>757</i>&nbsp;     * @see java.util.Calendar#isLenient()
<i>758</i>&nbsp;     */
<i>759</i>&nbsp;    public boolean isLenient()
<i>760</i>&nbsp;    {
<i>761</i>&nbsp;        return calendar.isLenient();
<i>762</i>&nbsp;    }
<b class="nc"><i>763</i>&nbsp;</b>
<b class="nc"><i>764</i>&nbsp;    /**</b>
<b class="nc"><i>765</i>&nbsp;     * Overrides hashCode</b>
<b class="nc"><i>766</i>&nbsp;     */</b>
<i>767</i>&nbsp;    public int hashCode() {
<i>768</i>&nbsp;        return numberFormat.hashCode();
<i>769</i>&nbsp;        // just enough fields for a reasonable distribution
<i>770</i>&nbsp;    }
<i>771</i>&nbsp;
<i>772</i>&nbsp;    /**
<i>773</i>&nbsp;     * Overrides equals
<i>774</i>&nbsp;     */
<i>775</i>&nbsp;    public boolean equals(Object obj) {
<i>776</i>&nbsp;        if (this == obj) return true;
<i>777</i>&nbsp;        if (obj == null || getClass() != obj.getClass()) return false;
<i>778</i>&nbsp;        DateFormat other = (DateFormat) obj;
<i>779</i>&nbsp;        return (// calendar.equivalentTo(other.calendar) // THIS API DOESN&#39;T EXIST YET!
<i>780</i>&nbsp;                calendar.getFirstDayOfWeek() == other.calendar.getFirstDayOfWeek() &amp;&amp;
<i>781</i>&nbsp;                calendar.getMinimalDaysInFirstWeek() == other.calendar.getMinimalDaysInFirstWeek() &amp;&amp;
<b class="nc"><i>782</i>&nbsp;                calendar.isLenient() == other.calendar.isLenient() &amp;&amp;</b>
<b class="nc"><i>783</i>&nbsp;                calendar.getTimeZone().equals(other.calendar.getTimeZone()) &amp;&amp;</b>
<b class="nc"><i>784</i>&nbsp;                numberFormat.equals(other.numberFormat));</b>
<i>785</i>&nbsp;    }
<i>786</i>&nbsp;
<b class="nc"><i>787</i>&nbsp;    /**</b>
<i>788</i>&nbsp;     * Overrides Cloneable
<b class="nc"><i>789</i>&nbsp;     */</b>
<b class="nc"><i>790</i>&nbsp;    public Object clone()</b>
<b class="nc"><i>791</i>&nbsp;    {</b>
<i>792</i>&nbsp;        DateFormat other = (DateFormat) super.clone();
<i>793</i>&nbsp;        other.calendar = (Calendar) calendar.clone();
<b class="nc"><i>794</i>&nbsp;        other.numberFormat = (NumberFormat) numberFormat.clone();</b>
<i>795</i>&nbsp;        return other;
<i>796</i>&nbsp;    }
<b class="nc"><i>797</i>&nbsp;</b>
<b class="nc"><i>798</i>&nbsp;    /**</b>
<b class="nc"><i>799</i>&nbsp;     * Creates a DateFormat with the given time and/or date style in the given</b>
<b class="nc"><i>800</i>&nbsp;     * locale.</b>
<i>801</i>&nbsp;     * @param timeStyle a value from 0 to 3 indicating the time format,
<b class="nc"><i>802</i>&nbsp;     * ignored if flags is 2</b>
<i>803</i>&nbsp;     * @param dateStyle a value from 0 to 3 indicating the time format,
<i>804</i>&nbsp;     * ignored if flags is 1
<i>805</i>&nbsp;     * @param flags either 1 for a time format, 2 for a date format,
<b class="nc"><i>806</i>&nbsp;     * or 3 for a date/time format</b>
<i>807</i>&nbsp;     * @param loc the locale for the format
<b class="nc"><i>808</i>&nbsp;     */</b>
<b class="nc"><i>809</i>&nbsp;    private static DateFormat get(int timeStyle, int dateStyle,</b>
<i>810</i>&nbsp;                                  int flags, Locale loc) {
<b class="nc"><i>811</i>&nbsp;        if ((flags &amp; 1) != 0) {</b>
<b class="nc"><i>812</i>&nbsp;            if (timeStyle &lt; 0 || timeStyle &gt; 3) {</b>
<i>813</i>&nbsp;                throw new IllegalArgumentException(&quot;Illegal time style &quot; + timeStyle);
<b class="nc"><i>814</i>&nbsp;            }</b>
<i>815</i>&nbsp;        } else {
<i>816</i>&nbsp;            timeStyle = -1;
<b class="nc"><i>817</i>&nbsp;        }</b>
<i>818</i>&nbsp;        if ((flags &amp; 2) != 0) {
<i>819</i>&nbsp;            if (dateStyle &lt; 0 || dateStyle &gt; 3) {
<i>820</i>&nbsp;                throw new IllegalArgumentException(&quot;Illegal date style &quot; + dateStyle);
<i>821</i>&nbsp;            }
<i>822</i>&nbsp;        } else {
<b class="nc"><i>823</i>&nbsp;            dateStyle = -1;</b>
<i>824</i>&nbsp;        }
<i>825</i>&nbsp;
<i>826</i>&nbsp;        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DateFormatProvider.class, loc);
<i>827</i>&nbsp;        DateFormat dateFormat = get(adapter, timeStyle, dateStyle, loc);
<i>828</i>&nbsp;        if (dateFormat == null) {
<i>829</i>&nbsp;            dateFormat = get(LocaleProviderAdapter.forJRE(), timeStyle, dateStyle, loc);
<i>830</i>&nbsp;        }
<i>831</i>&nbsp;        return dateFormat;
<i>832</i>&nbsp;    }
<i>833</i>&nbsp;
<i>834</i>&nbsp;    private static DateFormat get(LocaleProviderAdapter adapter, int timeStyle, int dateStyle, Locale loc) {
<i>835</i>&nbsp;        DateFormatProvider provider = adapter.getDateFormatProvider();
<i>836</i>&nbsp;        DateFormat dateFormat;
<i>837</i>&nbsp;        if (timeStyle == -1) {
<i>838</i>&nbsp;            dateFormat = provider.getDateInstance(dateStyle, loc);
<i>839</i>&nbsp;        } else {
<i>840</i>&nbsp;            if (dateStyle == -1) {
<i>841</i>&nbsp;                dateFormat = provider.getTimeInstance(timeStyle, loc);
<i>842</i>&nbsp;            } else {
<b class="nc"><i>843</i>&nbsp;                dateFormat = provider.getDateTimeInstance(dateStyle, timeStyle, loc);</b>
<i>844</i>&nbsp;            }
<i>845</i>&nbsp;        }
<b class="nc"><i>846</i>&nbsp;        return dateFormat;</b>
<i>847</i>&nbsp;    }
<i>848</i>&nbsp;
<i>849</i>&nbsp;    /**
<i>850</i>&nbsp;     * Create a new date format.
<i>851</i>&nbsp;     */
<i>852</i>&nbsp;    protected DateFormat() {}
<i>853</i>&nbsp;
<i>854</i>&nbsp;    /**
<i>855</i>&nbsp;     * Defines constants that are used as attribute keys in the
<i>856</i>&nbsp;     * &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; returned
<i>857</i>&nbsp;     * from &lt;code&gt;DateFormat.formatToCharacterIterator&lt;/code&gt; and as
<i>858</i>&nbsp;     * field identifiers in &lt;code&gt;FieldPosition&lt;/code&gt;.
<i>859</i>&nbsp;     * &lt;p&gt;
<i>860</i>&nbsp;     * The class also provides two methods to map
<i>861</i>&nbsp;     * between its constants and the corresponding Calendar constants.
<i>862</i>&nbsp;     *
<i>863</i>&nbsp;     * @since 1.4
<i>864</i>&nbsp;     * @see java.util.Calendar
<b class="nc"><i>865</i>&nbsp;     */</b>
<i>866</i>&nbsp;    public static class Field extends Format.Field {
<b class="nc"><i>867</i>&nbsp;</b>
<i>868</i>&nbsp;        // Proclaim serial compatibility with 1.4 FCS
<i>869</i>&nbsp;        private static final long serialVersionUID = 7441350119349544720L;
<b class="nc"><i>870</i>&nbsp;</b>
<i>871</i>&nbsp;        // table of all instances in this class, used by readResolve
<i>872</i>&nbsp;        private static final Map&lt;String, Field&gt; instanceMap = new HashMap&lt;&gt;(18);
<i>873</i>&nbsp;        // Maps from Calendar constant (such as Calendar.ERA) to Field
<i>874</i>&nbsp;        // constant (such as Field.ERA).
<i>875</i>&nbsp;        private static final Field[] calendarToFieldMapping =
<i>876</i>&nbsp;                                             new Field[Calendar.FIELD_COUNT];
<i>877</i>&nbsp;
<i>878</i>&nbsp;        /** Calendar field. */
<i>879</i>&nbsp;        private int calendarField;
<i>880</i>&nbsp;
<i>881</i>&nbsp;        /**
<i>882</i>&nbsp;         * Returns the &lt;code&gt;Field&lt;/code&gt; constant that corresponds to
<i>883</i>&nbsp;         * the &lt;code&gt;Calendar&lt;/code&gt; constant &lt;code&gt;calendarField&lt;/code&gt;.
<b class="nc"><i>884</i>&nbsp;         * If there is no direct mapping between the &lt;code&gt;Calendar&lt;/code&gt;</b>
<b class="nc"><i>885</i>&nbsp;         * constant and a &lt;code&gt;Field&lt;/code&gt;, null is returned.</b>
<b class="nc"><i>886</i>&nbsp;         *</b>
<b class="nc"><i>887</i>&nbsp;         * @throws IllegalArgumentException if &lt;code&gt;calendarField&lt;/code&gt; is</b>
<b class="nc"><i>888</i>&nbsp;         *         not the value of a &lt;code&gt;Calendar&lt;/code&gt; field constant.</b>
<i>889</i>&nbsp;         * @param calendarField Calendar field constant
<b class="nc"><i>890</i>&nbsp;         * @return Field instance representing calendarField.</b>
<i>891</i>&nbsp;         * @see java.util.Calendar
<i>892</i>&nbsp;         */
<i>893</i>&nbsp;        public static Field ofCalendarField(int calendarField) {
<i>894</i>&nbsp;            if (calendarField &lt; 0 || calendarField &gt;=
<i>895</i>&nbsp;                        calendarToFieldMapping.length) {
<i>896</i>&nbsp;                throw new IllegalArgumentException(&quot;Unknown Calendar constant &quot;
<i>897</i>&nbsp;                                                   + calendarField);
<i>898</i>&nbsp;            }
<i>899</i>&nbsp;            return calendarToFieldMapping[calendarField];
<i>900</i>&nbsp;        }
<i>901</i>&nbsp;
<i>902</i>&nbsp;        /**
<i>903</i>&nbsp;         * Creates a &lt;code&gt;Field&lt;/code&gt;.
<i>904</i>&nbsp;         *
<i>905</i>&nbsp;         * @param name the name of the &lt;code&gt;Field&lt;/code&gt;
<b class="nc"><i>906</i>&nbsp;         * @param calendarField the &lt;code&gt;Calendar&lt;/code&gt; constant this</b>
<i>907</i>&nbsp;         *        &lt;code&gt;Field&lt;/code&gt; corresponds to; any value, even one
<i>908</i>&nbsp;         *        outside the range of legal &lt;code&gt;Calendar&lt;/code&gt; values may
<i>909</i>&nbsp;         *        be used, but &lt;code&gt;-1&lt;/code&gt; should be used for values
<i>910</i>&nbsp;         *        that don&#39;t correspond to legal &lt;code&gt;Calendar&lt;/code&gt; values
<i>911</i>&nbsp;         */
<i>912</i>&nbsp;        protected Field(String name, int calendarField) {
<i>913</i>&nbsp;            super(name);
<i>914</i>&nbsp;            this.calendarField = calendarField;
<i>915</i>&nbsp;            if (this.getClass() == DateFormat.Field.class) {
<i>916</i>&nbsp;                instanceMap.put(name, this);
<i>917</i>&nbsp;                if (calendarField &gt;= 0) {
<b class="nc"><i>918</i>&nbsp;                    // assert(calendarField &lt; Calendar.FIELD_COUNT);</b>
<b class="nc"><i>919</i>&nbsp;                    calendarToFieldMapping[calendarField] = this;</b>
<i>920</i>&nbsp;                }
<i>921</i>&nbsp;            }
<b class="nc"><i>922</i>&nbsp;        }</b>
<b class="nc"><i>923</i>&nbsp;</b>
<b class="nc"><i>924</i>&nbsp;        /**</b>
<i>925</i>&nbsp;         * Returns the &lt;code&gt;Calendar&lt;/code&gt; field associated with this
<b class="nc"><i>926</i>&nbsp;         * attribute. For example, if this represents the hours field of</b>
<i>927</i>&nbsp;         * a &lt;code&gt;Calendar&lt;/code&gt;, this would return
<i>928</i>&nbsp;         * &lt;code&gt;Calendar.HOUR&lt;/code&gt;. If there is no corresponding
<i>929</i>&nbsp;         * &lt;code&gt;Calendar&lt;/code&gt; constant, this will return -1.
<i>930</i>&nbsp;         *
<i>931</i>&nbsp;         * @return Calendar constant for this field
<i>932</i>&nbsp;         * @see java.util.Calendar
<i>933</i>&nbsp;         */
<i>934</i>&nbsp;        public int getCalendarField() {
<i>935</i>&nbsp;            return calendarField;
<i>936</i>&nbsp;        }
<b class="nc"><i>937</i>&nbsp;</b>
<i>938</i>&nbsp;        /**
<i>939</i>&nbsp;         * Resolves instances being deserialized to the predefined constants.
<i>940</i>&nbsp;         *
<i>941</i>&nbsp;         * @throws InvalidObjectException if the constant could not be
<b class="nc"><i>942</i>&nbsp;         *         resolved.</b>
<i>943</i>&nbsp;         * @return resolved DateFormat.Field constant
<i>944</i>&nbsp;         */
<i>945</i>&nbsp;        @Override
<i>946</i>&nbsp;        protected Object readResolve() throws InvalidObjectException {
<b class="nc"><i>947</i>&nbsp;            if (this.getClass() != DateFormat.Field.class) {</b>
<i>948</i>&nbsp;                throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
<i>949</i>&nbsp;            }
<i>950</i>&nbsp;
<i>951</i>&nbsp;            Object instance = instanceMap.get(getName());
<b class="nc"><i>952</i>&nbsp;            if (instance != null) {</b>
<i>953</i>&nbsp;                return instance;
<i>954</i>&nbsp;            } else {
<i>955</i>&nbsp;                throw new InvalidObjectException(&quot;unknown attribute name&quot;);
<i>956</i>&nbsp;            }
<i>957</i>&nbsp;        }
<i>958</i>&nbsp;
<b class="nc"><i>959</i>&nbsp;        //</b>
<i>960</i>&nbsp;        // The constants
<i>961</i>&nbsp;        //
<i>962</i>&nbsp;
<i>963</i>&nbsp;        /**
<i>964</i>&nbsp;         * Constant identifying the era field.
<b class="nc"><i>965</i>&nbsp;         */</b>
<i>966</i>&nbsp;        public static final Field ERA = new Field(&quot;era&quot;, Calendar.ERA);
<i>967</i>&nbsp;
<i>968</i>&nbsp;        /**
<i>969</i>&nbsp;         * Constant identifying the year field.
<i>970</i>&nbsp;         */
<b class="nc"><i>971</i>&nbsp;        public static final Field YEAR = new Field(&quot;year&quot;, Calendar.YEAR);</b>
<i>972</i>&nbsp;
<i>973</i>&nbsp;        /**
<i>974</i>&nbsp;         * Constant identifying the month field.
<i>975</i>&nbsp;         */
<b class="nc"><i>976</i>&nbsp;        public static final Field MONTH = new Field(&quot;month&quot;, Calendar.MONTH);</b>
<i>977</i>&nbsp;
<i>978</i>&nbsp;        /**
<i>979</i>&nbsp;         * Constant identifying the day of month field.
<i>980</i>&nbsp;         */
<b class="nc"><i>981</i>&nbsp;        public static final Field DAY_OF_MONTH = new</b>
<i>982</i>&nbsp;                            Field(&quot;day of month&quot;, Calendar.DAY_OF_MONTH);
<i>983</i>&nbsp;
<i>984</i>&nbsp;        /**
<i>985</i>&nbsp;         * Constant identifying the hour of day field, where the legal values
<i>986</i>&nbsp;         * are 1 to 24.
<b class="nc"><i>987</i>&nbsp;         */</b>
<i>988</i>&nbsp;        public static final Field HOUR_OF_DAY1 = new Field(&quot;hour of day 1&quot;,-1);
<i>989</i>&nbsp;
<i>990</i>&nbsp;        /**
<i>991</i>&nbsp;         * Constant identifying the hour of day field, where the legal values
<i>992</i>&nbsp;         * are 0 to 23.
<b class="nc"><i>993</i>&nbsp;         */</b>
<i>994</i>&nbsp;        public static final Field HOUR_OF_DAY0 = new
<i>995</i>&nbsp;               Field(&quot;hour of day&quot;, Calendar.HOUR_OF_DAY);
<i>996</i>&nbsp;
<i>997</i>&nbsp;        /**
<i>998</i>&nbsp;         * Constant identifying the minute field.
<b class="nc"><i>999</i>&nbsp;         */</b>
<i>1000</i>&nbsp;        public static final Field MINUTE =new Field(&quot;minute&quot;, Calendar.MINUTE);
<i>1001</i>&nbsp;
<i>1002</i>&nbsp;        /**
<i>1003</i>&nbsp;         * Constant identifying the second field.
<i>1004</i>&nbsp;         */
<i>1005</i>&nbsp;        public static final Field SECOND =new Field(&quot;second&quot;, Calendar.SECOND);
<b class="nc"><i>1006</i>&nbsp;</b>
<i>1007</i>&nbsp;        /**
<i>1008</i>&nbsp;         * Constant identifying the millisecond field.
<i>1009</i>&nbsp;         */
<i>1010</i>&nbsp;        public static final Field MILLISECOND = new
<i>1011</i>&nbsp;                Field(&quot;millisecond&quot;, Calendar.MILLISECOND);
<b class="nc"><i>1012</i>&nbsp;</b>
<i>1013</i>&nbsp;        /**
<i>1014</i>&nbsp;         * Constant identifying the day of week field.
<i>1015</i>&nbsp;         */
<i>1016</i>&nbsp;        public static final Field DAY_OF_WEEK = new
<i>1017</i>&nbsp;                Field(&quot;day of week&quot;, Calendar.DAY_OF_WEEK);
<i>1018</i>&nbsp;
<b class="nc"><i>1019</i>&nbsp;        /**</b>
<i>1020</i>&nbsp;         * Constant identifying the day of year field.
<i>1021</i>&nbsp;         */
<i>1022</i>&nbsp;        public static final Field DAY_OF_YEAR = new
<i>1023</i>&nbsp;                Field(&quot;day of year&quot;, Calendar.DAY_OF_YEAR);
<i>1024</i>&nbsp;
<i>1025</i>&nbsp;        /**
<b class="nc"><i>1026</i>&nbsp;         * Constant identifying the day of week field.</b>
<i>1027</i>&nbsp;         */
<i>1028</i>&nbsp;        public static final Field DAY_OF_WEEK_IN_MONTH =
<i>1029</i>&nbsp;                     new Field(&quot;day of week in month&quot;,
<i>1030</i>&nbsp;                                            Calendar.DAY_OF_WEEK_IN_MONTH);
<i>1031</i>&nbsp;
<b class="nc"><i>1032</i>&nbsp;        /**</b>
<i>1033</i>&nbsp;         * Constant identifying the week of year field.
<i>1034</i>&nbsp;         */
<i>1035</i>&nbsp;        public static final Field WEEK_OF_YEAR = new
<i>1036</i>&nbsp;              Field(&quot;week of year&quot;, Calendar.WEEK_OF_YEAR);
<i>1037</i>&nbsp;
<b class="nc"><i>1038</i>&nbsp;        /**</b>
<i>1039</i>&nbsp;         * Constant identifying the week of month field.
<i>1040</i>&nbsp;         */
<i>1041</i>&nbsp;        public static final Field WEEK_OF_MONTH = new
<i>1042</i>&nbsp;            Field(&quot;week of month&quot;, Calendar.WEEK_OF_MONTH);
<i>1043</i>&nbsp;
<i>1044</i>&nbsp;        /**
<i>1045</i>&nbsp;         * Constant identifying the time of day indicator
<i>1046</i>&nbsp;         * (e.g. &quot;a.m.&quot; or &quot;p.m.&quot;) field.
<i>1047</i>&nbsp;         */
<i>1048</i>&nbsp;        public static final Field AM_PM = new
<i>1049</i>&nbsp;                            Field(&quot;am pm&quot;, Calendar.AM_PM);
<i>1050</i>&nbsp;
<i>1051</i>&nbsp;        /**
<i>1052</i>&nbsp;         * Constant identifying the hour field, where the legal values are
<i>1053</i>&nbsp;         * 1 to 12.
<i>1054</i>&nbsp;         */
<i>1055</i>&nbsp;        public static final Field HOUR1 = new Field(&quot;hour 1&quot;, -1);
<i>1056</i>&nbsp;
<i>1057</i>&nbsp;        /**
<i>1058</i>&nbsp;         * Constant identifying the hour field, where the legal values are
<i>1059</i>&nbsp;         * 0 to 11.
<i>1060</i>&nbsp;         */
<i>1061</i>&nbsp;        public static final Field HOUR0 = new
<i>1062</i>&nbsp;                            Field(&quot;hour&quot;, Calendar.HOUR);
<i>1063</i>&nbsp;
<i>1064</i>&nbsp;        /**
<i>1065</i>&nbsp;         * Constant identifying the time zone field.
<i>1066</i>&nbsp;         */
<i>1067</i>&nbsp;        public static final Field TIME_ZONE = new Field(&quot;time zone&quot;, -1);
<i>1068</i>&nbsp;    }
<i>1069</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
