


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DecimalFormat</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">java.text</a> ]
</div>

<h1>Coverage Summary for Class: DecimalFormat (java.text)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DecimalFormat</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 80)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1174)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DecimalFormat$DigitArrays</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DecimalFormat$FastPathData</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 84)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1201)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.
<i>3</i>&nbsp; * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
<i>4</i>&nbsp; *
<i>5</i>&nbsp; *
<i>6</i>&nbsp; *
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *
<i>11</i>&nbsp; *
<i>12</i>&nbsp; *
<i>13</i>&nbsp; *
<i>14</i>&nbsp; *
<i>15</i>&nbsp; *
<i>16</i>&nbsp; *
<i>17</i>&nbsp; *
<i>18</i>&nbsp; *
<i>19</i>&nbsp; *
<i>20</i>&nbsp; *
<i>21</i>&nbsp; *
<i>22</i>&nbsp; *
<i>23</i>&nbsp; *
<i>24</i>&nbsp; */
<i>25</i>&nbsp;
<i>26</i>&nbsp;/*
<i>27</i>&nbsp; * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
<i>28</i>&nbsp; * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
<i>29</i>&nbsp; *
<i>30</i>&nbsp; *   The original version of this source code and documentation is copyrighted
<i>31</i>&nbsp; * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
<i>32</i>&nbsp; * materials are provided under terms of a License Agreement between Taligent
<i>33</i>&nbsp; * and Sun. This technology is protected by multiple US and International
<i>34</i>&nbsp; * patents. This notice and attribution to Taligent may not be removed.
<i>35</i>&nbsp; *   Taligent is a registered trademark of Taligent, Inc.
<i>36</i>&nbsp; *
<i>37</i>&nbsp; */
<i>38</i>&nbsp;
<i>39</i>&nbsp;package java.text;
<i>40</i>&nbsp;
<i>41</i>&nbsp;import java.io.IOException;
<i>42</i>&nbsp;import java.io.InvalidObjectException;
<i>43</i>&nbsp;import java.io.ObjectInputStream;
<i>44</i>&nbsp;import java.math.BigDecimal;
<i>45</i>&nbsp;import java.math.BigInteger;
<i>46</i>&nbsp;import java.math.RoundingMode;
<i>47</i>&nbsp;import java.text.spi.NumberFormatProvider;
<i>48</i>&nbsp;import java.util.ArrayList;
<i>49</i>&nbsp;import java.util.Currency;
<i>50</i>&nbsp;import java.util.Locale;
<i>51</i>&nbsp;import java.util.ResourceBundle;
<i>52</i>&nbsp;import java.util.concurrent.ConcurrentHashMap;
<i>53</i>&nbsp;import java.util.concurrent.ConcurrentMap;
<i>54</i>&nbsp;import java.util.concurrent.atomic.AtomicInteger;
<i>55</i>&nbsp;import java.util.concurrent.atomic.AtomicLong;
<i>56</i>&nbsp;import sun.util.locale.provider.LocaleProviderAdapter;
<i>57</i>&nbsp;import sun.util.locale.provider.ResourceBundleBasedAdapter;
<i>58</i>&nbsp;
<i>59</i>&nbsp;/**
<i>60</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; is a concrete subclass of
<i>61</i>&nbsp; * &lt;code&gt;NumberFormat&lt;/code&gt; that formats decimal numbers. It has a variety of
<i>62</i>&nbsp; * features designed to make it possible to parse and format numbers in any
<i>63</i>&nbsp; * locale, including support for Western, Arabic, and Indic digits.  It also
<i>64</i>&nbsp; * supports different kinds of numbers, including integers (123), fixed-point
<i>65</i>&nbsp; * numbers (123.4), scientific notation (1.23E4), percentages (12%), and
<i>66</i>&nbsp; * currency amounts ($123).  All of these can be localized.
<i>67</i>&nbsp; *
<i>68</i>&nbsp; * &lt;p&gt;To obtain a &lt;code&gt;NumberFormat&lt;/code&gt; for a specific locale, including the
<i>69</i>&nbsp; * default locale, call one of &lt;code&gt;NumberFormat&lt;/code&gt;&#39;s factory methods, such
<i>70</i>&nbsp; * as &lt;code&gt;getInstance()&lt;/code&gt;.  In general, do not call the
<i>71</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; constructors directly, since the
<i>72</i>&nbsp; * &lt;code&gt;NumberFormat&lt;/code&gt; factory methods may return subclasses other than
<i>73</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt;. If you need to customize the format object, do
<i>74</i>&nbsp; * something like this:
<i>75</i>&nbsp; *
<i>76</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>77</i>&nbsp; * NumberFormat f = NumberFormat.getInstance(loc);
<i>78</i>&nbsp; * if (f instanceof DecimalFormat) {
<i>79</i>&nbsp; *     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
<i>80</i>&nbsp; * }
<i>81</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>82</i>&nbsp; *
<i>83</i>&nbsp; * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; comprises a &lt;em&gt;pattern&lt;/em&gt; and a set of
<i>84</i>&nbsp; * &lt;em&gt;symbols&lt;/em&gt;.  The pattern may be set directly using
<i>85</i>&nbsp; * &lt;code&gt;applyPattern()&lt;/code&gt;, or indirectly using the API methods.  The
<i>86</i>&nbsp; * symbols are stored in a &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  When using
<i>87</i>&nbsp; * the &lt;code&gt;NumberFormat&lt;/code&gt; factory methods, the pattern and symbols are
<i>88</i>&nbsp; * read from localized &lt;code&gt;ResourceBundle&lt;/code&gt;s.
<i>89</i>&nbsp; *
<i>90</i>&nbsp; * &lt;h3&gt;Patterns&lt;/h3&gt;
<i>91</i>&nbsp; *
<i>92</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; patterns have the following syntax:
<i>93</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;
<i>94</i>&nbsp; * &lt;i&gt;Pattern:&lt;/i&gt;
<i>95</i>&nbsp; *         &lt;i&gt;PositivePattern&lt;/i&gt;
<i>96</i>&nbsp; *         &lt;i&gt;PositivePattern&lt;/i&gt; ; &lt;i&gt;NegativePattern&lt;/i&gt;
<i>97</i>&nbsp; * &lt;i&gt;PositivePattern:&lt;/i&gt;
<i>98</i>&nbsp; *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>99</i>&nbsp; * &lt;i&gt;NegativePattern:&lt;/i&gt;
<i>100</i>&nbsp; *         &lt;i&gt;Prefix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;Number&lt;/i&gt; &lt;i&gt;Suffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>101</i>&nbsp; * &lt;i&gt;Prefix:&lt;/i&gt;
<i>102</i>&nbsp; *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
<i>103</i>&nbsp; * &lt;i&gt;Suffix:&lt;/i&gt;
<i>104</i>&nbsp; *         any Unicode characters except &amp;#92;uFFFE, &amp;#92;uFFFF, and special characters
<i>105</i>&nbsp; * &lt;i&gt;Number:&lt;/i&gt;
<i>106</i>&nbsp; *         &lt;i&gt;Integer&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>107</i>&nbsp; *         &lt;i&gt;Integer&lt;/i&gt; . &lt;i&gt;Fraction&lt;/i&gt; &lt;i&gt;Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>108</i>&nbsp; * &lt;i&gt;Integer:&lt;/i&gt;
<i>109</i>&nbsp; *         &lt;i&gt;MinimumInteger&lt;/i&gt;
<i>110</i>&nbsp; *         #
<i>111</i>&nbsp; *         # &lt;i&gt;Integer&lt;/i&gt;
<i>112</i>&nbsp; *         # , &lt;i&gt;Integer&lt;/i&gt;
<i>113</i>&nbsp; * &lt;i&gt;MinimumInteger:&lt;/i&gt;
<i>114</i>&nbsp; *         0
<i>115</i>&nbsp; *         0 &lt;i&gt;MinimumInteger&lt;/i&gt;
<i>116</i>&nbsp; *         0 , &lt;i&gt;MinimumInteger&lt;/i&gt;
<i>117</i>&nbsp; * &lt;i&gt;Fraction:&lt;/i&gt;
<i>118</i>&nbsp; *         &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>119</i>&nbsp; * &lt;i&gt;MinimumFraction:&lt;/i&gt;
<i>120</i>&nbsp; *         0 &lt;i&gt;MinimumFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>121</i>&nbsp; * &lt;i&gt;OptionalFraction:&lt;/i&gt;
<i>122</i>&nbsp; *         # &lt;i&gt;OptionalFraction&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>123</i>&nbsp; * &lt;i&gt;Exponent:&lt;/i&gt;
<i>124</i>&nbsp; *         E &lt;i&gt;MinimumExponent&lt;/i&gt;
<i>125</i>&nbsp; * &lt;i&gt;MinimumExponent:&lt;/i&gt;
<i>126</i>&nbsp; *         0 &lt;i&gt;MinimumExponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
<i>127</i>&nbsp; * &lt;/pre&gt;&lt;/blockquote&gt;
<i>128</i>&nbsp; *
<i>129</i>&nbsp; * &lt;p&gt;A &lt;code&gt;DecimalFormat&lt;/code&gt; pattern contains a positive and negative
<i>130</i>&nbsp; * subpattern, for example, &lt;code&gt;&quot;#,##0.00;(#,##0.00)&quot;&lt;/code&gt;.  Each
<i>131</i>&nbsp; * subpattern has a prefix, numeric part, and suffix. The negative subpattern
<i>132</i>&nbsp; * is optional; if absent, then the positive subpattern prefixed with the
<i>133</i>&nbsp; * localized minus sign (&lt;code&gt;&#39;-&#39;&lt;/code&gt; in most locales) is used as the
<i>134</i>&nbsp; * negative subpattern. That is, &lt;code&gt;&quot;0.00&quot;&lt;/code&gt; alone is equivalent to
<i>135</i>&nbsp; * &lt;code&gt;&quot;0.00;-0.00&quot;&lt;/code&gt;.  If there is an explicit negative subpattern, it
<i>136</i>&nbsp; * serves only to specify the negative prefix and suffix; the number of digits,
<i>137</i>&nbsp; * minimal digits, and other characteristics are all the same as the positive
<i>138</i>&nbsp; * pattern. That means that &lt;code&gt;&quot;#,##0.0#;(#)&quot;&lt;/code&gt; produces precisely
<i>139</i>&nbsp; * the same behavior as &lt;code&gt;&quot;#,##0.0#;(#,##0.0#)&quot;&lt;/code&gt;.
<i>140</i>&nbsp; *
<i>141</i>&nbsp; * &lt;p&gt;The prefixes, suffixes, and various symbols used for infinity, digits,
<i>142</i>&nbsp; * thousands separators, decimal separators, etc. may be set to arbitrary
<i>143</i>&nbsp; * values, and they will appear properly during formatting.  However, care must
<i>144</i>&nbsp; * be taken that the symbols and strings do not conflict, or parsing will be
<i>145</i>&nbsp; * unreliable.  For example, either the positive and negative prefixes or the
<i>146</i>&nbsp; * suffixes must be distinct for &lt;code&gt;DecimalFormat.parse()&lt;/code&gt; to be able
<i>147</i>&nbsp; * to distinguish positive from negative values.  (If they are identical, then
<i>148</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; will behave as if no negative subpattern was
<i>149</i>&nbsp; * specified.)  Another example is that the decimal separator and thousands
<i>150</i>&nbsp; * separator should be distinct characters, or parsing will be impossible.
<i>151</i>&nbsp; *
<i>152</i>&nbsp; * &lt;p&gt;The grouping separator is commonly used for thousands, but in some
<i>153</i>&nbsp; * countries it separates ten-thousands. The grouping size is a constant number
<i>154</i>&nbsp; * of digits between the grouping characters, such as 3 for 100,000,000 or 4 for
<i>155</i>&nbsp; * 1,0000,0000.  If you supply a pattern with multiple grouping characters, the
<i>156</i>&nbsp; * interval between the last one and the end of the integer is the one that is
<i>157</i>&nbsp; * used. So &lt;code&gt;&quot;#,##,###,####&quot;&lt;/code&gt; == &lt;code&gt;&quot;######,####&quot;&lt;/code&gt; ==
<i>158</i>&nbsp; * &lt;code&gt;&quot;##,####,####&quot;&lt;/code&gt;.
<i>159</i>&nbsp; *
<i>160</i>&nbsp; * &lt;h4&gt;Special Pattern Characters&lt;/h4&gt;
<i>161</i>&nbsp; *
<i>162</i>&nbsp; * &lt;p&gt;Many characters in a pattern are taken literally; they are matched during
<i>163</i>&nbsp; * parsing and output unchanged during formatting.  Special characters, on the
<i>164</i>&nbsp; * other hand, stand for other characters, strings, or classes of characters.
<i>165</i>&nbsp; * They must be quoted, unless noted otherwise, if they are to appear in the
<i>166</i>&nbsp; * prefix or suffix as literals.
<i>167</i>&nbsp; *
<i>168</i>&nbsp; * &lt;p&gt;The characters listed here are used in non-localized patterns.  Localized
<i>169</i>&nbsp; * patterns use the corresponding characters taken from this formatter&#39;s
<i>170</i>&nbsp; * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object instead, and these characters lose
<i>171</i>&nbsp; * their special status.  Two exceptions are the currency sign and quote, which
<i>172</i>&nbsp; * are not localized.
<i>173</i>&nbsp; *
<i>174</i>&nbsp; * &lt;blockquote&gt;
<i>175</i>&nbsp; * &lt;table class=&quot;striped&quot;&gt;
<i>176</i>&nbsp; * &lt;caption style=&quot;display:none&quot;&gt;Chart showing symbol, location, localized, and meaning.&lt;/caption&gt;
<i>177</i>&nbsp; * &lt;thead&gt;
<i>178</i>&nbsp; *     &lt;tr&gt;
<i>179</i>&nbsp; *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Symbol
<i>180</i>&nbsp; *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Location
<i>181</i>&nbsp; *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Localized?
<i>182</i>&nbsp; *          &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Meaning
<i>183</i>&nbsp; * &lt;/thead&gt;
<i>184</i>&nbsp; * &lt;tbody&gt;
<i>185</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>186</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;0&lt;/code&gt;
<i>187</i>&nbsp; *          &lt;td&gt;Number
<i>188</i>&nbsp; *          &lt;td&gt;Yes
<i>189</i>&nbsp; *          &lt;td&gt;Digit
<i>190</i>&nbsp; *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<i>191</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;#&lt;/code&gt;
<i>192</i>&nbsp; *          &lt;td&gt;Number
<i>193</i>&nbsp; *          &lt;td&gt;Yes
<i>194</i>&nbsp; *          &lt;td&gt;Digit, zero shows as absent
<i>195</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>196</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;.&lt;/code&gt;
<i>197</i>&nbsp; *          &lt;td&gt;Number
<i>198</i>&nbsp; *          &lt;td&gt;Yes
<i>199</i>&nbsp; *          &lt;td&gt;Decimal separator or monetary decimal separator
<i>200</i>&nbsp; *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<i>201</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;-&lt;/code&gt;
<i>202</i>&nbsp; *          &lt;td&gt;Number
<i>203</i>&nbsp; *          &lt;td&gt;Yes
<i>204</i>&nbsp; *          &lt;td&gt;Minus sign
<i>205</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>206</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;,&lt;/code&gt;
<i>207</i>&nbsp; *          &lt;td&gt;Number
<i>208</i>&nbsp; *          &lt;td&gt;Yes
<i>209</i>&nbsp; *          &lt;td&gt;Grouping separator
<i>210</i>&nbsp; *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<i>211</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;E&lt;/code&gt;
<i>212</i>&nbsp; *          &lt;td&gt;Number
<i>213</i>&nbsp; *          &lt;td&gt;Yes
<i>214</i>&nbsp; *          &lt;td&gt;Separates mantissa and exponent in scientific notation.
<i>215</i>&nbsp; *              &lt;em&gt;Need not be quoted in prefix or suffix.&lt;/em&gt;
<i>216</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>217</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;;&lt;/code&gt;
<i>218</i>&nbsp; *          &lt;td&gt;Subpattern boundary
<i>219</i>&nbsp; *          &lt;td&gt;Yes
<i>220</i>&nbsp; *          &lt;td&gt;Separates positive and negative subpatterns
<i>221</i>&nbsp; *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<i>222</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;%&lt;/code&gt;
<i>223</i>&nbsp; *          &lt;td&gt;Prefix or suffix
<i>224</i>&nbsp; *          &lt;td&gt;Yes
<i>225</i>&nbsp; *          &lt;td&gt;Multiply by 100 and show as percentage
<i>226</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>227</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&amp;#92;u2030&lt;/code&gt;
<i>228</i>&nbsp; *          &lt;td&gt;Prefix or suffix
<i>229</i>&nbsp; *          &lt;td&gt;Yes
<i>230</i>&nbsp; *          &lt;td&gt;Multiply by 1000 and show as per mille value
<i>231</i>&nbsp; *     &lt;tr style=&quot;vertical-align: top&quot;&gt;
<i>232</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&amp;#164;&lt;/code&gt; (&lt;code&gt;&amp;#92;u00A4&lt;/code&gt;)
<i>233</i>&nbsp; *          &lt;td&gt;Prefix or suffix
<i>234</i>&nbsp; *          &lt;td&gt;No
<i>235</i>&nbsp; *          &lt;td&gt;Currency sign, replaced by currency symbol.  If
<i>236</i>&nbsp; *              doubled, replaced by international currency symbol.
<i>237</i>&nbsp; *              If present in a pattern, the monetary decimal separator
<i>238</i>&nbsp; *              is used instead of the decimal separator.
<i>239</i>&nbsp; *     &lt;tr style=&quot;vertical-align:top&quot;&gt;
<i>240</i>&nbsp; *          &lt;th scope=&quot;row&quot;&gt;&lt;code&gt;&#39;&lt;/code&gt;
<i>241</i>&nbsp; *          &lt;td&gt;Prefix or suffix
<i>242</i>&nbsp; *          &lt;td&gt;No
<i>243</i>&nbsp; *          &lt;td&gt;Used to quote special characters in a prefix or suffix,
<i>244</i>&nbsp; *              for example, &lt;code&gt;&quot;&#39;#&#39;#&quot;&lt;/code&gt; formats 123 to
<i>245</i>&nbsp; *              &lt;code&gt;&quot;#123&quot;&lt;/code&gt;.  To create a single quote
<i>246</i>&nbsp; *              itself, use two in a row: &lt;code&gt;&quot;# o&#39;&#39;clock&quot;&lt;/code&gt;.
<i>247</i>&nbsp; * &lt;/tbody&gt;
<i>248</i>&nbsp; * &lt;/table&gt;
<i>249</i>&nbsp; * &lt;/blockquote&gt;
<i>250</i>&nbsp; *
<i>251</i>&nbsp; * &lt;h4&gt;Scientific Notation&lt;/h4&gt;
<i>252</i>&nbsp; *
<i>253</i>&nbsp; * &lt;p&gt;Numbers in scientific notation are expressed as the product of a mantissa
<i>254</i>&nbsp; * and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The
<i>255</i>&nbsp; * mantissa is often in the range 1.0 &amp;le; x {@literal &lt;} 10.0, but it need not
<i>256</i>&nbsp; * be.
<i>257</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; can be instructed to format and parse scientific
<i>258</i>&nbsp; * notation &lt;em&gt;only via a pattern&lt;/em&gt;; there is currently no factory method
<i>259</i>&nbsp; * that creates a scientific notation format.  In a pattern, the exponent
<i>260</i>&nbsp; * character immediately followed by one or more digit characters indicates
<i>261</i>&nbsp; * scientific notation.  Example: &lt;code&gt;&quot;0.###E0&quot;&lt;/code&gt; formats the number
<i>262</i>&nbsp; * 1234 as &lt;code&gt;&quot;1.234E3&quot;&lt;/code&gt;.
<i>263</i>&nbsp; *
<i>264</i>&nbsp; * &lt;ul&gt;
<i>265</i>&nbsp; * &lt;li&gt;The number of digit characters after the exponent character gives the
<i>266</i>&nbsp; * minimum exponent digit count.  There is no maximum.  Negative exponents are
<i>267</i>&nbsp; * formatted using the localized minus sign, &lt;em&gt;not&lt;/em&gt; the prefix and suffix
<i>268</i>&nbsp; * from the pattern.  This allows patterns such as &lt;code&gt;&quot;0.###E0 m/s&quot;&lt;/code&gt;.
<i>269</i>&nbsp; *
<i>270</i>&nbsp; * &lt;li&gt;The minimum and maximum number of integer digits are interpreted
<i>271</i>&nbsp; * together:
<i>272</i>&nbsp; *
<i>273</i>&nbsp; * &lt;ul&gt;
<i>274</i>&nbsp; * &lt;li&gt;If the maximum number of integer digits is greater than their minimum number
<i>275</i>&nbsp; * and greater than 1, it forces the exponent to be a multiple of the maximum
<i>276</i>&nbsp; * number of integer digits, and the minimum number of integer digits to be
<i>277</i>&nbsp; * interpreted as 1.  The most common use of this is to generate
<i>278</i>&nbsp; * &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three,
<i>279</i>&nbsp; * e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345
<i>280</i>&nbsp; * formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to
<i>281</i>&nbsp; * &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.
<i>282</i>&nbsp; *
<i>283</i>&nbsp; * &lt;li&gt;Otherwise, the minimum number of integer digits is achieved by adjusting the
<i>284</i>&nbsp; * exponent.  Example: 0.00123 formatted with &lt;code&gt;&quot;00.###E0&quot;&lt;/code&gt; yields
<i>285</i>&nbsp; * &lt;code&gt;&quot;12.3E-4&quot;&lt;/code&gt;.
<i>286</i>&nbsp; * &lt;/ul&gt;
<i>287</i>&nbsp; *
<i>288</i>&nbsp; * &lt;li&gt;The number of significant digits in the mantissa is the sum of the
<i>289</i>&nbsp; * &lt;em&gt;minimum integer&lt;/em&gt; and &lt;em&gt;maximum fraction&lt;/em&gt; digits, and is
<i>290</i>&nbsp; * unaffected by the maximum integer digits.  For example, 12345 formatted with
<i>291</i>&nbsp; * &lt;code&gt;&quot;##0.##E0&quot;&lt;/code&gt; is &lt;code&gt;&quot;12.3E3&quot;&lt;/code&gt;. To show all digits, set
<i>292</i>&nbsp; * the significant digits count to zero.  The number of significant digits
<i>293</i>&nbsp; * does not affect parsing.
<i>294</i>&nbsp; *
<i>295</i>&nbsp; * &lt;li&gt;Exponential patterns may not contain grouping separators.
<i>296</i>&nbsp; * &lt;/ul&gt;
<i>297</i>&nbsp; *
<i>298</i>&nbsp; * &lt;h4&gt;Rounding&lt;/h4&gt;
<i>299</i>&nbsp; *
<i>300</i>&nbsp; * &lt;code&gt;DecimalFormat&lt;/code&gt; provides rounding modes defined in
<i>301</i>&nbsp; * {@link java.math.RoundingMode} for formatting.  By default, it uses
<i>302</i>&nbsp; * {@link java.math.RoundingMode#HALF_EVEN RoundingMode.HALF_EVEN}.
<i>303</i>&nbsp; *
<i>304</i>&nbsp; * &lt;h4&gt;Digits&lt;/h4&gt;
<i>305</i>&nbsp; *
<i>306</i>&nbsp; * For formatting, &lt;code&gt;DecimalFormat&lt;/code&gt; uses the ten consecutive
<i>307</i>&nbsp; * characters starting with the localized zero digit defined in the
<i>308</i>&nbsp; * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object as digits. For parsing, these
<i>309</i>&nbsp; * digits as well as all Unicode decimal digits, as defined by
<i>310</i>&nbsp; * {@link Character#digit Character.digit}, are recognized.
<i>311</i>&nbsp; *
<i>312</i>&nbsp; * &lt;h4&gt;Special Values&lt;/h4&gt;
<i>313</i>&nbsp; *
<i>314</i>&nbsp; * &lt;p&gt;&lt;code&gt;NaN&lt;/code&gt; is formatted as a string, which typically has a single character
<i>315</i>&nbsp; * &lt;code&gt;&amp;#92;uFFFD&lt;/code&gt;.  This string is determined by the
<i>316</i>&nbsp; * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.  This is the only value for which
<i>317</i>&nbsp; * the prefixes and suffixes are not used.
<i>318</i>&nbsp; *
<i>319</i>&nbsp; * &lt;p&gt;Infinity is formatted as a string, which typically has a single character
<i>320</i>&nbsp; * &lt;code&gt;&amp;#92;u221E&lt;/code&gt;, with the positive or negative prefixes and suffixes
<i>321</i>&nbsp; * applied.  The infinity string is determined by the
<i>322</i>&nbsp; * &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
<i>323</i>&nbsp; *
<i>324</i>&nbsp; * &lt;p&gt;Negative zero (&lt;code&gt;&quot;-0&quot;&lt;/code&gt;) parses to
<i>325</i>&nbsp; * &lt;ul&gt;
<i>326</i>&nbsp; * &lt;li&gt;&lt;code&gt;BigDecimal(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is
<i>327</i>&nbsp; * true,
<i>328</i>&nbsp; * &lt;li&gt;&lt;code&gt;Long(0)&lt;/code&gt; if &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false
<i>329</i>&nbsp; *     and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; is true,
<i>330</i>&nbsp; * &lt;li&gt;&lt;code&gt;Double(-0.0)&lt;/code&gt; if both &lt;code&gt;isParseBigDecimal()&lt;/code&gt;
<i>331</i>&nbsp; * and &lt;code&gt;isParseIntegerOnly()&lt;/code&gt; are false.
<i>332</i>&nbsp; * &lt;/ul&gt;
<i>333</i>&nbsp; *
<i>334</i>&nbsp; * &lt;h4&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h4&gt;
<i>335</i>&nbsp; *
<i>336</i>&nbsp; * &lt;p&gt;
<i>337</i>&nbsp; * Decimal formats are generally not synchronized.
<i>338</i>&nbsp; * It is recommended to create separate format instances for each thread.
<i>339</i>&nbsp; * If multiple threads access a format concurrently, it must be synchronized
<i>340</i>&nbsp; * externally.
<i>341</i>&nbsp; *
<i>342</i>&nbsp; * &lt;h4&gt;Example&lt;/h4&gt;
<i>343</i>&nbsp; *
<i>344</i>&nbsp; * &lt;blockquote&gt;&lt;pre&gt;{@code
<i>345</i>&nbsp; * &lt;strong&gt;// Print out a number using the localized number, integer, currency,
<i>346</i>&nbsp; * // and percent format for each locale&lt;/strong&gt;
<i>347</i>&nbsp; * Locale[] locales = NumberFormat.getAvailableLocales();
<i>348</i>&nbsp; * double myNumber = -1234.56;
<i>349</i>&nbsp; * NumberFormat form;
<i>350</i>&nbsp; * for (int j = 0; j &lt; 4; ++j) {
<i>351</i>&nbsp; *     System.out.println(&quot;FORMAT&quot;);
<i>352</i>&nbsp; *     for (int i = 0; i &lt; locales.length; ++i) {
<i>353</i>&nbsp; *         if (locales[i].getCountry().length() == 0) {
<i>354</i>&nbsp; *            continue; // Skip language-only locales
<i>355</i>&nbsp; *         }
<i>356</i>&nbsp; *         System.out.print(locales[i].getDisplayName());
<i>357</i>&nbsp; *         switch (j) {
<i>358</i>&nbsp; *         case 0:
<i>359</i>&nbsp; *             form = NumberFormat.getInstance(locales[i]); break;
<i>360</i>&nbsp; *         case 1:
<i>361</i>&nbsp; *             form = NumberFormat.getIntegerInstance(locales[i]); break;
<i>362</i>&nbsp; *         case 2:
<i>363</i>&nbsp; *             form = NumberFormat.getCurrencyInstance(locales[i]); break;
<i>364</i>&nbsp; *         default:
<i>365</i>&nbsp; *             form = NumberFormat.getPercentInstance(locales[i]); break;
<i>366</i>&nbsp; *         }
<i>367</i>&nbsp; *         if (form instanceof DecimalFormat) {
<i>368</i>&nbsp; *             System.out.print(&quot;: &quot; + ((DecimalFormat) form).toPattern());
<i>369</i>&nbsp; *         }
<i>370</i>&nbsp; *         System.out.print(&quot; -&gt; &quot; + form.format(myNumber));
<i>371</i>&nbsp; *         try {
<i>372</i>&nbsp; *             System.out.println(&quot; -&gt; &quot; + form.parse(form.format(myNumber)));
<i>373</i>&nbsp; *         } catch (ParseException e) {}
<i>374</i>&nbsp; *     }
<i>375</i>&nbsp; * }
<i>376</i>&nbsp; * }&lt;/pre&gt;&lt;/blockquote&gt;
<i>377</i>&nbsp; *
<i>378</i>&nbsp; * @see          &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/i18n/format/decimalFormat.html&quot;&gt;Java Tutorial&lt;/a&gt;
<i>379</i>&nbsp; * @see          NumberFormat
<i>380</i>&nbsp; * @see          DecimalFormatSymbols
<b class="nc"><i>381</i>&nbsp; * @see          ParsePosition</b>
<i>382</i>&nbsp; * @author       Mark Davis
<i>383</i>&nbsp; * @author       Alan Liu
<i>384</i>&nbsp; * @since 1.1
<i>385</i>&nbsp; */
<i>386</i>&nbsp;public class DecimalFormat extends NumberFormat {
<i>387</i>&nbsp;
<i>388</i>&nbsp;    /**
<i>389</i>&nbsp;     * Creates a DecimalFormat using the default pattern and symbols
<i>390</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>391</i>&nbsp;     * This is a convenient way to obtain a
<i>392</i>&nbsp;     * DecimalFormat when internationalization is not the main concern.
<i>393</i>&nbsp;     * &lt;p&gt;
<i>394</i>&nbsp;     * To obtain standard formats for a given locale, use the factory methods
<i>395</i>&nbsp;     * on NumberFormat such as getNumberInstance. These factories will
<i>396</i>&nbsp;     * return the most appropriate sub-class of NumberFormat for a given
<i>397</i>&nbsp;     * locale.
<i>398</i>&nbsp;     *
<b class="nc"><i>399</i>&nbsp;     * @see java.text.NumberFormat#getInstance</b>
<i>400</i>&nbsp;     * @see java.text.NumberFormat#getNumberInstance
<b class="nc"><i>401</i>&nbsp;     * @see java.text.NumberFormat#getCurrencyInstance</b>
<b class="nc"><i>402</i>&nbsp;     * @see java.text.NumberFormat#getPercentInstance</b>
<b class="nc"><i>403</i>&nbsp;     */</b>
<b class="nc"><i>404</i>&nbsp;    public DecimalFormat() {</b>
<i>405</i>&nbsp;        // Get the pattern for the default locale.
<b class="nc"><i>406</i>&nbsp;        Locale def = Locale.getDefault(Locale.Category.FORMAT);</b>
<i>407</i>&nbsp;        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(NumberFormatProvider.class, def);
<i>408</i>&nbsp;        if (!(adapter instanceof ResourceBundleBasedAdapter)) {
<b class="nc"><i>409</i>&nbsp;            adapter = LocaleProviderAdapter.getResourceBundleBased();</b>
<b class="nc"><i>410</i>&nbsp;        }</b>
<i>411</i>&nbsp;        String[] all = adapter.getLocaleResources(def).getNumberPatterns();
<i>412</i>&nbsp;
<i>413</i>&nbsp;        // Always applyPattern after the symbols are set
<i>414</i>&nbsp;        this.symbols = DecimalFormatSymbols.getInstance(def);
<i>415</i>&nbsp;        applyPattern(all[0], false);
<i>416</i>&nbsp;    }
<i>417</i>&nbsp;
<i>418</i>&nbsp;
<i>419</i>&nbsp;    /**
<i>420</i>&nbsp;     * Creates a DecimalFormat using the given pattern and the symbols
<i>421</i>&nbsp;     * for the default {@link java.util.Locale.Category#FORMAT FORMAT} locale.
<i>422</i>&nbsp;     * This is a convenient way to obtain a
<i>423</i>&nbsp;     * DecimalFormat when internationalization is not the main concern.
<i>424</i>&nbsp;     * &lt;p&gt;
<i>425</i>&nbsp;     * To obtain standard formats for a given locale, use the factory methods
<i>426</i>&nbsp;     * on NumberFormat such as getNumberInstance. These factories will
<i>427</i>&nbsp;     * return the most appropriate sub-class of NumberFormat for a given
<i>428</i>&nbsp;     * locale.
<i>429</i>&nbsp;     *
<i>430</i>&nbsp;     * @param pattern a non-localized pattern string.
<i>431</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null
<i>432</i>&nbsp;     * @exception IllegalArgumentException if the given pattern is invalid.
<b class="nc"><i>433</i>&nbsp;     * @see java.text.NumberFormat#getInstance</b>
<i>434</i>&nbsp;     * @see java.text.NumberFormat#getNumberInstance
<b class="nc"><i>435</i>&nbsp;     * @see java.text.NumberFormat#getCurrencyInstance</b>
<b class="nc"><i>436</i>&nbsp;     * @see java.text.NumberFormat#getPercentInstance</b>
<i>437</i>&nbsp;     */
<i>438</i>&nbsp;    public DecimalFormat(String pattern) {
<i>439</i>&nbsp;        // Always applyPattern after the symbols are set
<i>440</i>&nbsp;        this.symbols = DecimalFormatSymbols.getInstance(Locale.getDefault(Locale.Category.FORMAT));
<i>441</i>&nbsp;        applyPattern(pattern, false);
<i>442</i>&nbsp;    }
<i>443</i>&nbsp;
<i>444</i>&nbsp;
<i>445</i>&nbsp;    /**
<i>446</i>&nbsp;     * Creates a DecimalFormat using the given pattern and symbols.
<i>447</i>&nbsp;     * Use this constructor when you need to completely customize the
<i>448</i>&nbsp;     * behavior of the format.
<i>449</i>&nbsp;     * &lt;p&gt;
<i>450</i>&nbsp;     * To obtain standard formats for a given
<i>451</i>&nbsp;     * locale, use the factory methods on NumberFormat such as
<i>452</i>&nbsp;     * getInstance or getCurrencyInstance. If you need only minor adjustments
<i>453</i>&nbsp;     * to a standard format, you can modify the format returned by
<i>454</i>&nbsp;     * a NumberFormat factory method.
<i>455</i>&nbsp;     *
<i>456</i>&nbsp;     * @param pattern a non-localized pattern string
<i>457</i>&nbsp;     * @param symbols the set of symbols to be used
<i>458</i>&nbsp;     * @exception NullPointerException if any of the given arguments is null
<i>459</i>&nbsp;     * @exception IllegalArgumentException if the given pattern is invalid
<i>460</i>&nbsp;     * @see java.text.NumberFormat#getInstance
<b class="nc"><i>461</i>&nbsp;     * @see java.text.NumberFormat#getNumberInstance</b>
<i>462</i>&nbsp;     * @see java.text.NumberFormat#getCurrencyInstance
<b class="nc"><i>463</i>&nbsp;     * @see java.text.NumberFormat#getPercentInstance</b>
<b class="nc"><i>464</i>&nbsp;     * @see java.text.DecimalFormatSymbols</b>
<i>465</i>&nbsp;     */
<i>466</i>&nbsp;    public DecimalFormat (String pattern, DecimalFormatSymbols symbols) {
<i>467</i>&nbsp;        // Always applyPattern after the symbols are set
<i>468</i>&nbsp;        this.symbols = (DecimalFormatSymbols)symbols.clone();
<i>469</i>&nbsp;        applyPattern(pattern, false);
<i>470</i>&nbsp;    }
<i>471</i>&nbsp;
<i>472</i>&nbsp;
<i>473</i>&nbsp;    // Overrides
<i>474</i>&nbsp;    /**
<i>475</i>&nbsp;     * Formats a number and appends the resulting text to the given string
<i>476</i>&nbsp;     * buffer.
<i>477</i>&nbsp;     * The number can be of any subclass of {@link java.lang.Number}.
<i>478</i>&nbsp;     * &lt;p&gt;
<i>479</i>&nbsp;     * This implementation uses the maximum precision permitted.
<i>480</i>&nbsp;     * @param number     the number to format
<i>481</i>&nbsp;     * @param toAppendTo the &lt;code&gt;StringBuffer&lt;/code&gt; to which the formatted
<i>482</i>&nbsp;     *                   text is to be appended
<i>483</i>&nbsp;     * @param pos        keeps track on the position of the field within the
<i>484</i>&nbsp;     *                   returned string. For example, for formatting a number
<i>485</i>&nbsp;     *                   {@code 1234567.89} in {@code Locale.US} locale,
<i>486</i>&nbsp;     *                   if the given {@code fieldPosition} is
<i>487</i>&nbsp;     *                   {@link NumberFormat#INTEGER_FIELD}, the begin index
<i>488</i>&nbsp;     *                   and end index of {@code fieldPosition} will be set
<i>489</i>&nbsp;     *                   to 0 and 9, respectively for the output string
<i>490</i>&nbsp;     *                   {@code 1,234,567.89}.
<i>491</i>&nbsp;     * @return           the value passed in as &lt;code&gt;toAppendTo&lt;/code&gt;
<i>492</i>&nbsp;     * @exception        IllegalArgumentException if &lt;code&gt;number&lt;/code&gt; is
<b class="nc"><i>493</i>&nbsp;     *                   null or not an instance of &lt;code&gt;Number&lt;/code&gt;.</b>
<i>494</i>&nbsp;     * @exception        NullPointerException if &lt;code&gt;toAppendTo&lt;/code&gt; or
<i>495</i>&nbsp;     *                   &lt;code&gt;pos&lt;/code&gt; is null
<i>496</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding
<i>497</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<b class="nc"><i>498</i>&nbsp;     * @see              java.text.FieldPosition</b>
<b class="nc"><i>499</i>&nbsp;     */</b>
<b class="nc"><i>500</i>&nbsp;    @Override</b>
<b class="nc"><i>501</i>&nbsp;    public final StringBuffer format(Object number,</b>
<b class="nc"><i>502</i>&nbsp;                                     StringBuffer toAppendTo,</b>
<b class="nc"><i>503</i>&nbsp;                                     FieldPosition pos) {</b>
<b class="nc"><i>504</i>&nbsp;        if (number instanceof Long || number instanceof Integer ||</b>
<b class="nc"><i>505</i>&nbsp;                   number instanceof Short || number instanceof Byte ||</b>
<i>506</i>&nbsp;                   number instanceof AtomicInteger ||
<b class="nc"><i>507</i>&nbsp;                   number instanceof AtomicLong ||</b>
<i>508</i>&nbsp;                   (number instanceof BigInteger &amp;&amp;
<i>509</i>&nbsp;                    ((BigInteger)number).bitLength () &lt; 64)) {
<i>510</i>&nbsp;            return format(((Number)number).longValue(), toAppendTo, pos);
<i>511</i>&nbsp;        } else if (number instanceof BigDecimal) {
<i>512</i>&nbsp;            return format((BigDecimal)number, toAppendTo, pos);
<i>513</i>&nbsp;        } else if (number instanceof BigInteger) {
<i>514</i>&nbsp;            return format((BigInteger)number, toAppendTo, pos);
<i>515</i>&nbsp;        } else if (number instanceof Number) {
<i>516</i>&nbsp;            return format(((Number)number).doubleValue(), toAppendTo, pos);
<i>517</i>&nbsp;        } else {
<i>518</i>&nbsp;            throw new IllegalArgumentException(&quot;Cannot format given Object as a Number&quot;);
<i>519</i>&nbsp;        }
<i>520</i>&nbsp;    }
<i>521</i>&nbsp;
<i>522</i>&nbsp;    /**
<i>523</i>&nbsp;     * Formats a double to produce a string.
<i>524</i>&nbsp;     * @param number    The double to format
<i>525</i>&nbsp;     * @param result    where the text is to be appended
<i>526</i>&nbsp;     * @param fieldPosition    keeps track on the position of the field within
<b class="nc"><i>527</i>&nbsp;     *                         the returned string. For example, for formatting</b>
<b class="nc"><i>528</i>&nbsp;     *                         a number {@code 1234567.89} in {@code Locale.US}</b>
<b class="nc"><i>529</i>&nbsp;     *                         locale, if the given {@code fieldPosition} is</b>
<i>530</i>&nbsp;     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
<b class="nc"><i>531</i>&nbsp;     *                         and end index of {@code fieldPosition} will be set</b>
<b class="nc"><i>532</i>&nbsp;     *                         to 0 and 9, respectively for the output string</b>
<i>533</i>&nbsp;     *                         {@code 1,234,567.89}.
<i>534</i>&nbsp;     * @exception NullPointerException if {@code result} or
<b class="nc"><i>535</i>&nbsp;     *            {@code fieldPosition} is {@code null}</b>
<b class="nc"><i>536</i>&nbsp;     * @exception ArithmeticException if rounding is needed with rounding</b>
<b class="nc"><i>537</i>&nbsp;     *            mode being set to RoundingMode.UNNECESSARY</b>
<b class="nc"><i>538</i>&nbsp;     * @return The formatted number string</b>
<b class="nc"><i>539</i>&nbsp;     * @see java.text.FieldPosition</b>
<i>540</i>&nbsp;     */
<i>541</i>&nbsp;    @Override
<i>542</i>&nbsp;    public StringBuffer format(double number, StringBuffer result,
<i>543</i>&nbsp;                               FieldPosition fieldPosition) {
<b class="nc"><i>544</i>&nbsp;        // If fieldPosition is a DontCareFieldPosition instance we can</b>
<i>545</i>&nbsp;        // try to go to fast-path code.
<i>546</i>&nbsp;        boolean tryFastPath = false;
<i>547</i>&nbsp;        if (fieldPosition == DontCareFieldPosition.INSTANCE)
<i>548</i>&nbsp;            tryFastPath = true;
<i>549</i>&nbsp;        else {
<i>550</i>&nbsp;            fieldPosition.setBeginIndex(0);
<i>551</i>&nbsp;            fieldPosition.setEndIndex(0);
<i>552</i>&nbsp;        }
<i>553</i>&nbsp;
<i>554</i>&nbsp;        if (tryFastPath) {
<i>555</i>&nbsp;            String tempResult = fastFormat(number);
<i>556</i>&nbsp;            if (tempResult != null) {
<i>557</i>&nbsp;                result.append(tempResult);
<b class="nc"><i>558</i>&nbsp;                return result;</b>
<b class="nc"><i>559</i>&nbsp;            }</b>
<b class="nc"><i>560</i>&nbsp;        }</b>
<b class="nc"><i>561</i>&nbsp;</b>
<b class="nc"><i>562</i>&nbsp;        // if fast-path could not work, we fallback to standard code.</b>
<b class="nc"><i>563</i>&nbsp;        return format(number, result, fieldPosition.getFieldDelegate());</b>
<b class="nc"><i>564</i>&nbsp;    }</b>
<i>565</i>&nbsp;
<i>566</i>&nbsp;    /**
<i>567</i>&nbsp;     * Formats a double to produce a string.
<i>568</i>&nbsp;     * @param number    The double to format
<i>569</i>&nbsp;     * @param result    where the text is to be appended
<i>570</i>&nbsp;     * @param delegate notified of locations of sub fields
<i>571</i>&nbsp;     * @exception       ArithmeticException if rounding is needed with rounding
<i>572</i>&nbsp;     *                  mode being set to RoundingMode.UNNECESSARY
<i>573</i>&nbsp;     * @return The formatted number string
<i>574</i>&nbsp;     */
<i>575</i>&nbsp;    private StringBuffer format(double number, StringBuffer result,
<i>576</i>&nbsp;                                FieldDelegate delegate) {
<b class="nc"><i>577</i>&nbsp;        if (Double.isNaN(number) ||</b>
<i>578</i>&nbsp;           (Double.isInfinite(number) &amp;&amp; multiplier == 0)) {
<b class="nc"><i>579</i>&nbsp;            int iFieldStart = result.length();</b>
<b class="nc"><i>580</i>&nbsp;            result.append(symbols.getNaN());</b>
<i>581</i>&nbsp;            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
<i>582</i>&nbsp;                               iFieldStart, result.length(), result);
<b class="nc"><i>583</i>&nbsp;            return result;</b>
<b class="nc"><i>584</i>&nbsp;        }</b>
<b class="nc"><i>585</i>&nbsp;</b>
<b class="nc"><i>586</i>&nbsp;        /* Detecting whether a double is negative is easy with the exception of</b>
<i>587</i>&nbsp;         * the value -0.0.  This is a double which has a zero mantissa (and
<b class="nc"><i>588</i>&nbsp;         * exponent), but a negative sign bit.  It is semantically distinct from</b>
<b class="nc"><i>589</i>&nbsp;         * a zero with a positive sign bit, and this distinction is important</b>
<i>590</i>&nbsp;         * to certain kinds of computations.  However, it&#39;s a little tricky to
<i>591</i>&nbsp;         * detect, since (-0.0 == 0.0) and !(-0.0 &lt; 0.0).  How then, you may
<b class="nc"><i>592</i>&nbsp;         * ask, does it behave distinctly from +0.0?  Well, 1/(-0.0) ==</b>
<b class="nc"><i>593</i>&nbsp;         * -Infinity.  Proper detection of -0.0 is needed to deal with the</b>
<b class="nc"><i>594</i>&nbsp;         * issues raised by bugs 4106658, 4106667, and 4147706.  Liu 7/6/98.</b>
<b class="nc"><i>595</i>&nbsp;         */</b>
<i>596</i>&nbsp;        boolean isNegative = ((number &lt; 0.0) || (number == 0.0 &amp;&amp; 1/number &lt; 0.0)) ^ (multiplier &lt; 0);
<b class="nc"><i>597</i>&nbsp;</b>
<b class="nc"><i>598</i>&nbsp;        if (multiplier != 1) {</b>
<b class="nc"><i>599</i>&nbsp;            number *= multiplier;</b>
<i>600</i>&nbsp;        }
<b class="nc"><i>601</i>&nbsp;</b>
<b class="nc"><i>602</i>&nbsp;        if (Double.isInfinite(number)) {</b>
<i>603</i>&nbsp;            if (isNegative) {
<i>604</i>&nbsp;                append(result, negativePrefix, delegate,
<b class="nc"><i>605</i>&nbsp;                       getNegativePrefixFieldPositions(), Field.SIGN);</b>
<i>606</i>&nbsp;            } else {
<i>607</i>&nbsp;                append(result, positivePrefix, delegate,
<b class="nc"><i>608</i>&nbsp;                       getPositivePrefixFieldPositions(), Field.SIGN);</b>
<b class="nc"><i>609</i>&nbsp;            }</b>
<i>610</i>&nbsp;
<i>611</i>&nbsp;            int iFieldStart = result.length();
<i>612</i>&nbsp;            result.append(symbols.getInfinity());
<b class="nc"><i>613</i>&nbsp;            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,</b>
<i>614</i>&nbsp;                               iFieldStart, result.length(), result);
<b class="nc"><i>615</i>&nbsp;</b>
<b class="nc"><i>616</i>&nbsp;            if (isNegative) {</b>
<b class="nc"><i>617</i>&nbsp;                append(result, negativeSuffix, delegate,</b>
<b class="nc"><i>618</i>&nbsp;                       getNegativeSuffixFieldPositions(), Field.SIGN);</b>
<b class="nc"><i>619</i>&nbsp;            } else {</b>
<i>620</i>&nbsp;                append(result, positiveSuffix, delegate,
<b class="nc"><i>621</i>&nbsp;                       getPositiveSuffixFieldPositions(), Field.SIGN);</b>
<i>622</i>&nbsp;            }
<i>623</i>&nbsp;
<b class="nc"><i>624</i>&nbsp;            return result;</b>
<i>625</i>&nbsp;        }
<b class="nc"><i>626</i>&nbsp;</b>
<i>627</i>&nbsp;        if (isNegative) {
<i>628</i>&nbsp;            number = -number;
<i>629</i>&nbsp;        }
<i>630</i>&nbsp;
<i>631</i>&nbsp;        // at this point we are guaranteed a nonnegative finite number.
<i>632</i>&nbsp;        assert(number &gt;= 0 &amp;&amp; !Double.isInfinite(number));
<i>633</i>&nbsp;
<i>634</i>&nbsp;        synchronized(digitList) {
<i>635</i>&nbsp;            int maxIntDigits = super.getMaximumIntegerDigits();
<i>636</i>&nbsp;            int minIntDigits = super.getMinimumIntegerDigits();
<i>637</i>&nbsp;            int maxFraDigits = super.getMaximumFractionDigits();
<i>638</i>&nbsp;            int minFraDigits = super.getMinimumFractionDigits();
<i>639</i>&nbsp;
<i>640</i>&nbsp;            digitList.set(isNegative, number, useExponentialNotation ?
<i>641</i>&nbsp;                          maxIntDigits + maxFraDigits : maxFraDigits,
<i>642</i>&nbsp;                          !useExponentialNotation);
<b class="nc"><i>643</i>&nbsp;            return subformat(result, delegate, isNegative, false,</b>
<b class="nc"><i>644</i>&nbsp;                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);</b>
<i>645</i>&nbsp;        }
<b class="nc"><i>646</i>&nbsp;    }</b>
<i>647</i>&nbsp;
<i>648</i>&nbsp;    /**
<i>649</i>&nbsp;     * Format a long to produce a string.
<i>650</i>&nbsp;     * @param number    The long to format
<i>651</i>&nbsp;     * @param result    where the text is to be appended
<i>652</i>&nbsp;     * @param fieldPosition    keeps track on the position of the field within
<i>653</i>&nbsp;     *                         the returned string. For example, for formatting
<i>654</i>&nbsp;     *                         a number {@code 123456789} in {@code Locale.US}
<i>655</i>&nbsp;     *                         locale, if the given {@code fieldPosition} is
<i>656</i>&nbsp;     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
<i>657</i>&nbsp;     *                         and end index of {@code fieldPosition} will be set
<i>658</i>&nbsp;     *                         to 0 and 11, respectively for the output string
<i>659</i>&nbsp;     *                         {@code 123,456,789}.
<i>660</i>&nbsp;     * @exception       NullPointerException if {@code result} or
<b class="nc"><i>661</i>&nbsp;     *                  {@code fieldPosition} is {@code null}</b>
<b class="nc"><i>662</i>&nbsp;     * @exception       ArithmeticException if rounding is needed with rounding</b>
<b class="nc"><i>663</i>&nbsp;     *                  mode being set to RoundingMode.UNNECESSARY</b>
<i>664</i>&nbsp;     * @return The formatted number string
<i>665</i>&nbsp;     * @see java.text.FieldPosition
<i>666</i>&nbsp;     */
<i>667</i>&nbsp;    @Override
<i>668</i>&nbsp;    public StringBuffer format(long number, StringBuffer result,
<i>669</i>&nbsp;                               FieldPosition fieldPosition) {
<i>670</i>&nbsp;        fieldPosition.setBeginIndex(0);
<i>671</i>&nbsp;        fieldPosition.setEndIndex(0);
<b class="nc"><i>672</i>&nbsp;</b>
<b class="nc"><i>673</i>&nbsp;        return format(number, result, fieldPosition.getFieldDelegate());</b>
<b class="nc"><i>674</i>&nbsp;    }</b>
<b class="nc"><i>675</i>&nbsp;</b>
<i>676</i>&nbsp;    /**
<b class="nc"><i>677</i>&nbsp;     * Format a long to produce a string.</b>
<b class="nc"><i>678</i>&nbsp;     * @param number    The long to format</b>
<b class="nc"><i>679</i>&nbsp;     * @param result    where the text is to be appended</b>
<b class="nc"><i>680</i>&nbsp;     * @param delegate notified of locations of sub fields</b>
<i>681</i>&nbsp;     * @return The formatted number string
<b class="nc"><i>682</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding</b>
<i>683</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<i>684</i>&nbsp;     * @see java.text.FieldPosition
<b class="nc"><i>685</i>&nbsp;     */</b>
<b class="nc"><i>686</i>&nbsp;    private StringBuffer format(long number, StringBuffer result,</b>
<b class="nc"><i>687</i>&nbsp;                               FieldDelegate delegate) {</b>
<i>688</i>&nbsp;        boolean isNegative = (number &lt; 0);
<b class="nc"><i>689</i>&nbsp;        if (isNegative) {</b>
<b class="nc"><i>690</i>&nbsp;            number = -number;</b>
<i>691</i>&nbsp;        }
<i>692</i>&nbsp;
<b class="nc"><i>693</i>&nbsp;        // In general, long values always represent real finite numbers, so</b>
<b class="nc"><i>694</i>&nbsp;        // we don&#39;t have to check for +/- Infinity or NaN.  However, there</b>
<b class="nc"><i>695</i>&nbsp;        // is one case we have to be careful of:  The multiplier can push</b>
<i>696</i>&nbsp;        // a number near MIN_VALUE or MAX_VALUE outside the legal range.  We
<b class="nc"><i>697</i>&nbsp;        // check for this before multiplying, and if it happens we use</b>
<b class="nc"><i>698</i>&nbsp;        // BigInteger instead.</b>
<b class="nc"><i>699</i>&nbsp;        boolean useBigInteger = false;</b>
<i>700</i>&nbsp;        if (number &lt; 0) { // This can only happen if number == Long.MIN_VALUE.
<i>701</i>&nbsp;            if (multiplier != 0) {
<i>702</i>&nbsp;                useBigInteger = true;
<b class="nc"><i>703</i>&nbsp;            }</b>
<b class="nc"><i>704</i>&nbsp;        } else if (multiplier != 1 &amp;&amp; multiplier != 0) {</b>
<b class="nc"><i>705</i>&nbsp;            long cutoff = Long.MAX_VALUE / multiplier;</b>
<b class="nc"><i>706</i>&nbsp;            if (cutoff &lt; 0) {</b>
<b class="nc"><i>707</i>&nbsp;                cutoff = -cutoff;</b>
<i>708</i>&nbsp;            }
<b class="nc"><i>709</i>&nbsp;            useBigInteger = (number &gt; cutoff);</b>
<i>710</i>&nbsp;        }
<i>711</i>&nbsp;
<b class="nc"><i>712</i>&nbsp;        if (useBigInteger) {</b>
<i>713</i>&nbsp;            if (isNegative) {
<b class="nc"><i>714</i>&nbsp;                number = -number;</b>
<i>715</i>&nbsp;            }
<i>716</i>&nbsp;            BigInteger bigIntegerValue = BigInteger.valueOf(number);
<i>717</i>&nbsp;            return format(bigIntegerValue, result, delegate, true);
<i>718</i>&nbsp;        }
<i>719</i>&nbsp;
<i>720</i>&nbsp;        number *= multiplier;
<i>721</i>&nbsp;        if (number == 0) {
<i>722</i>&nbsp;            isNegative = false;
<i>723</i>&nbsp;        } else {
<i>724</i>&nbsp;            if (multiplier &lt; 0) {
<i>725</i>&nbsp;                number = -number;
<i>726</i>&nbsp;                isNegative = !isNegative;
<i>727</i>&nbsp;            }
<i>728</i>&nbsp;        }
<i>729</i>&nbsp;
<b class="nc"><i>730</i>&nbsp;        synchronized(digitList) {</b>
<b class="nc"><i>731</i>&nbsp;            int maxIntDigits = super.getMaximumIntegerDigits();</b>
<b class="nc"><i>732</i>&nbsp;            int minIntDigits = super.getMinimumIntegerDigits();</b>
<i>733</i>&nbsp;            int maxFraDigits = super.getMaximumFractionDigits();
<i>734</i>&nbsp;            int minFraDigits = super.getMinimumFractionDigits();
<i>735</i>&nbsp;
<i>736</i>&nbsp;            digitList.set(isNegative, number,
<i>737</i>&nbsp;                     useExponentialNotation ? maxIntDigits + maxFraDigits : 0);
<i>738</i>&nbsp;
<i>739</i>&nbsp;            return subformat(result, delegate, isNegative, true,
<i>740</i>&nbsp;                       maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<i>741</i>&nbsp;        }
<i>742</i>&nbsp;    }
<i>743</i>&nbsp;
<i>744</i>&nbsp;    /**
<i>745</i>&nbsp;     * Formats a BigDecimal to produce a string.
<b class="nc"><i>746</i>&nbsp;     * @param number    The BigDecimal to format</b>
<b class="nc"><i>747</i>&nbsp;     * @param result    where the text is to be appended</b>
<i>748</i>&nbsp;     * @param fieldPosition    keeps track on the position of the field within
<b class="nc"><i>749</i>&nbsp;     *                         the returned string. For example, for formatting</b>
<b class="nc"><i>750</i>&nbsp;     *                         a number {@code 1234567.89} in {@code Locale.US}</b>
<b class="nc"><i>751</i>&nbsp;     *                         locale, if the given {@code fieldPosition} is</b>
<i>752</i>&nbsp;     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index
<i>753</i>&nbsp;     *                         and end index of {@code fieldPosition} will be set
<b class="nc"><i>754</i>&nbsp;     *                         to 0 and 9, respectively for the output string</b>
<b class="nc"><i>755</i>&nbsp;     *                         {@code 1,234,567.89}.</b>
<b class="nc"><i>756</i>&nbsp;     * @return The formatted number string</b>
<b class="nc"><i>757</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding</b>
<b class="nc"><i>758</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY</b>
<b class="nc"><i>759</i>&nbsp;     * @see java.text.FieldPosition</b>
<i>760</i>&nbsp;     */
<b class="nc"><i>761</i>&nbsp;    private StringBuffer format(BigDecimal number, StringBuffer result,</b>
<i>762</i>&nbsp;                                FieldPosition fieldPosition) {
<i>763</i>&nbsp;        fieldPosition.setBeginIndex(0);
<i>764</i>&nbsp;        fieldPosition.setEndIndex(0);
<b class="nc"><i>765</i>&nbsp;        return format(number, result, fieldPosition.getFieldDelegate());</b>
<i>766</i>&nbsp;    }
<b class="nc"><i>767</i>&nbsp;</b>
<i>768</i>&nbsp;    /**
<i>769</i>&nbsp;     * Formats a BigDecimal to produce a string.
<i>770</i>&nbsp;     * @param number    The BigDecimal to format
<i>771</i>&nbsp;     * @param result    where the text is to be appended
<i>772</i>&nbsp;     * @param delegate notified of locations of sub fields
<i>773</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding
<i>774</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<i>775</i>&nbsp;     * @return The formatted number string
<i>776</i>&nbsp;     */
<i>777</i>&nbsp;    private StringBuffer format(BigDecimal number, StringBuffer result,
<i>778</i>&nbsp;                                FieldDelegate delegate) {
<i>779</i>&nbsp;        if (multiplier != 1) {
<i>780</i>&nbsp;            number = number.multiply(getBigDecimalMultiplier());
<i>781</i>&nbsp;        }
<i>782</i>&nbsp;        boolean isNegative = number.signum() == -1;
<b class="nc"><i>783</i>&nbsp;        if (isNegative) {</b>
<b class="nc"><i>784</i>&nbsp;            number = number.negate();</b>
<i>785</i>&nbsp;        }
<b class="nc"><i>786</i>&nbsp;</b>
<i>787</i>&nbsp;        synchronized(digitList) {
<i>788</i>&nbsp;            int maxIntDigits = getMaximumIntegerDigits();
<i>789</i>&nbsp;            int minIntDigits = getMinimumIntegerDigits();
<i>790</i>&nbsp;            int maxFraDigits = getMaximumFractionDigits();
<i>791</i>&nbsp;            int minFraDigits = getMinimumFractionDigits();
<i>792</i>&nbsp;            int maximumDigits = maxIntDigits + maxFraDigits;
<i>793</i>&nbsp;
<i>794</i>&nbsp;            digitList.set(isNegative, number, useExponentialNotation ?
<i>795</i>&nbsp;                ((maximumDigits &lt; 0) ? Integer.MAX_VALUE : maximumDigits) :
<i>796</i>&nbsp;                maxFraDigits, !useExponentialNotation);
<i>797</i>&nbsp;
<i>798</i>&nbsp;            return subformat(result, delegate, isNegative, false,
<i>799</i>&nbsp;                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);
<i>800</i>&nbsp;        }
<b class="nc"><i>801</i>&nbsp;    }</b>
<b class="nc"><i>802</i>&nbsp;</b>
<i>803</i>&nbsp;    /**
<b class="nc"><i>804</i>&nbsp;     * Format a BigInteger to produce a string.</b>
<b class="nc"><i>805</i>&nbsp;     * @param number    The BigInteger to format</b>
<b class="nc"><i>806</i>&nbsp;     * @param result    where the text is to be appended</b>
<i>807</i>&nbsp;     * @param fieldPosition    keeps track on the position of the field within
<i>808</i>&nbsp;     *                         the returned string. For example, for formatting
<b class="nc"><i>809</i>&nbsp;     *                         a number {@code 123456789} in {@code Locale.US}</b>
<i>810</i>&nbsp;     *                         locale, if the given {@code fieldPosition} is
<b class="nc"><i>811</i>&nbsp;     *                         {@link NumberFormat#INTEGER_FIELD}, the begin index</b>
<b class="nc"><i>812</i>&nbsp;     *                         and end index of {@code fieldPosition} will be set</b>
<b class="nc"><i>813</i>&nbsp;     *                         to 0 and 11, respectively for the output string</b>
<b class="nc"><i>814</i>&nbsp;     *                         {@code 123,456,789}.</b>
<b class="nc"><i>815</i>&nbsp;     * @return The formatted number string</b>
<b class="nc"><i>816</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding</b>
<i>817</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<b class="nc"><i>818</i>&nbsp;     * @see java.text.FieldPosition</b>
<b class="nc"><i>819</i>&nbsp;     */</b>
<b class="nc"><i>820</i>&nbsp;    private StringBuffer format(BigInteger number, StringBuffer result,</b>
<b class="nc"><i>821</i>&nbsp;                               FieldPosition fieldPosition) {</b>
<b class="nc"><i>822</i>&nbsp;        fieldPosition.setBeginIndex(0);</b>
<b class="nc"><i>823</i>&nbsp;        fieldPosition.setEndIndex(0);</b>
<b class="nc"><i>824</i>&nbsp;</b>
<i>825</i>&nbsp;        return format(number, result, fieldPosition.getFieldDelegate(), false);
<i>826</i>&nbsp;    }
<i>827</i>&nbsp;
<b class="nc"><i>828</i>&nbsp;    /**</b>
<i>829</i>&nbsp;     * Format a BigInteger to produce a string.
<i>830</i>&nbsp;     * @param number    The BigInteger to format
<b class="nc"><i>831</i>&nbsp;     * @param result    where the text is to be appended</b>
<i>832</i>&nbsp;     * @param delegate notified of locations of sub fields
<b class="nc"><i>833</i>&nbsp;     * @return The formatted number string</b>
<i>834</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding
<i>835</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<i>836</i>&nbsp;     * @see java.text.FieldPosition
<i>837</i>&nbsp;     */
<i>838</i>&nbsp;    private StringBuffer format(BigInteger number, StringBuffer result,
<i>839</i>&nbsp;                               FieldDelegate delegate, boolean formatLong) {
<i>840</i>&nbsp;        if (multiplier != 1) {
<i>841</i>&nbsp;            number = number.multiply(getBigIntegerMultiplier());
<i>842</i>&nbsp;        }
<i>843</i>&nbsp;        boolean isNegative = number.signum() == -1;
<i>844</i>&nbsp;        if (isNegative) {
<i>845</i>&nbsp;            number = number.negate();
<i>846</i>&nbsp;        }
<i>847</i>&nbsp;
<i>848</i>&nbsp;        synchronized(digitList) {
<i>849</i>&nbsp;            int maxIntDigits, minIntDigits, maxFraDigits, minFraDigits, maximumDigits;
<i>850</i>&nbsp;            if (formatLong) {
<i>851</i>&nbsp;                maxIntDigits = super.getMaximumIntegerDigits();
<i>852</i>&nbsp;                minIntDigits = super.getMinimumIntegerDigits();
<i>853</i>&nbsp;                maxFraDigits = super.getMaximumFractionDigits();
<i>854</i>&nbsp;                minFraDigits = super.getMinimumFractionDigits();
<i>855</i>&nbsp;                maximumDigits = maxIntDigits + maxFraDigits;
<i>856</i>&nbsp;            } else {
<b class="nc"><i>857</i>&nbsp;                maxIntDigits = getMaximumIntegerDigits();</b>
<i>858</i>&nbsp;                minIntDigits = getMinimumIntegerDigits();
<b class="nc"><i>859</i>&nbsp;                maxFraDigits = getMaximumFractionDigits();</b>
<i>860</i>&nbsp;                minFraDigits = getMinimumFractionDigits();
<b class="nc"><i>861</i>&nbsp;                maximumDigits = maxIntDigits + maxFraDigits;</b>
<b class="nc"><i>862</i>&nbsp;                if (maximumDigits &lt; 0) {</b>
<b class="nc"><i>863</i>&nbsp;                    maximumDigits = Integer.MAX_VALUE;</b>
<i>864</i>&nbsp;                }
<i>865</i>&nbsp;            }
<b class="nc"><i>866</i>&nbsp;</b>
<b class="nc"><i>867</i>&nbsp;            digitList.set(isNegative, number,</b>
<b class="nc"><i>868</i>&nbsp;                          useExponentialNotation ? maximumDigits : 0);</b>
<b class="nc"><i>869</i>&nbsp;</b>
<b class="nc"><i>870</i>&nbsp;            return subformat(result, delegate, isNegative, true,</b>
<b class="nc"><i>871</i>&nbsp;                maxIntDigits, minIntDigits, maxFraDigits, minFraDigits);</b>
<b class="nc"><i>872</i>&nbsp;        }</b>
<i>873</i>&nbsp;    }
<i>874</i>&nbsp;
<b class="nc"><i>875</i>&nbsp;    /**</b>
<i>876</i>&nbsp;     * Formats an Object producing an &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;.
<i>877</i>&nbsp;     * You can use the returned &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;
<b class="nc"><i>878</i>&nbsp;     * to build the resulting String, as well as to determine information</b>
<i>879</i>&nbsp;     * about the resulting String.
<i>880</i>&nbsp;     * &lt;p&gt;
<i>881</i>&nbsp;     * Each attribute key of the AttributedCharacterIterator will be of type
<i>882</i>&nbsp;     * &lt;code&gt;NumberFormat.Field&lt;/code&gt;, with the attribute value being the
<i>883</i>&nbsp;     * same as the attribute key.
<i>884</i>&nbsp;     *
<i>885</i>&nbsp;     * @exception NullPointerException if obj is null.
<i>886</i>&nbsp;     * @exception IllegalArgumentException when the Format cannot format the
<i>887</i>&nbsp;     *            given object.
<i>888</i>&nbsp;     * @exception        ArithmeticException if rounding is needed with rounding
<i>889</i>&nbsp;     *                   mode being set to RoundingMode.UNNECESSARY
<i>890</i>&nbsp;     * @param obj The object to format
<i>891</i>&nbsp;     * @return AttributedCharacterIterator describing the formatted value.
<i>892</i>&nbsp;     * @since 1.4
<i>893</i>&nbsp;     */
<i>894</i>&nbsp;    @Override
<i>895</i>&nbsp;    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
<i>896</i>&nbsp;        CharacterIteratorFieldDelegate delegate =
<i>897</i>&nbsp;                         new CharacterIteratorFieldDelegate();
<i>898</i>&nbsp;        StringBuffer sb = new StringBuffer();
<i>899</i>&nbsp;
<i>900</i>&nbsp;        if (obj instanceof Double || obj instanceof Float) {
<i>901</i>&nbsp;            format(((Number)obj).doubleValue(), sb, delegate);
<i>902</i>&nbsp;        } else if (obj instanceof Long || obj instanceof Integer ||
<i>903</i>&nbsp;                   obj instanceof Short || obj instanceof Byte ||
<i>904</i>&nbsp;                   obj instanceof AtomicInteger || obj instanceof AtomicLong) {
<i>905</i>&nbsp;            format(((Number)obj).longValue(), sb, delegate);
<i>906</i>&nbsp;        } else if (obj instanceof BigDecimal) {
<i>907</i>&nbsp;            format((BigDecimal)obj, sb, delegate);
<i>908</i>&nbsp;        } else if (obj instanceof BigInteger) {
<i>909</i>&nbsp;            format((BigInteger)obj, sb, delegate, false);
<i>910</i>&nbsp;        } else if (obj == null) {
<i>911</i>&nbsp;            throw new NullPointerException(
<i>912</i>&nbsp;                &quot;formatToCharacterIterator must be passed non-null object&quot;);
<i>913</i>&nbsp;        } else {
<i>914</i>&nbsp;            throw new IllegalArgumentException(
<i>915</i>&nbsp;                &quot;Cannot format given Object as a Number&quot;);
<i>916</i>&nbsp;        }
<i>917</i>&nbsp;        return delegate.getIterator(sb.toString());
<i>918</i>&nbsp;    }
<i>919</i>&nbsp;
<i>920</i>&nbsp;    // ==== Begin fast-path formating logic for double =========================
<i>921</i>&nbsp;
<i>922</i>&nbsp;    /* Fast-path formatting will be used for format(double ...) methods iff a
<i>923</i>&nbsp;     * number of conditions are met (see checkAndSetFastPathStatus()):
<i>924</i>&nbsp;     * - Only if instance properties meet the right predefined conditions.
<i>925</i>&nbsp;     * - The abs value of the double to format is &lt;= Integer.MAX_VALUE.
<i>926</i>&nbsp;     *
<i>927</i>&nbsp;     * The basic approach is to split the binary to decimal conversion of a
<i>928</i>&nbsp;     * double value into two phases:
<i>929</i>&nbsp;     * * The conversion of the integer portion of the double.
<i>930</i>&nbsp;     * * The conversion of the fractional portion of the double
<i>931</i>&nbsp;     *   (limited to two or three digits).
<i>932</i>&nbsp;     *
<i>933</i>&nbsp;     * The isolation and conversion of the integer portion of the double is
<i>934</i>&nbsp;     * straightforward. The conversion of the fraction is more subtle and relies
<i>935</i>&nbsp;     * on some rounding properties of double to the decimal precisions in
<i>936</i>&nbsp;     * question.  Using the terminology of BigDecimal, this fast-path algorithm
<i>937</i>&nbsp;     * is applied when a double value has a magnitude less than Integer.MAX_VALUE
<i>938</i>&nbsp;     * and rounding is to nearest even and the destination format has two or
<i>939</i>&nbsp;     * three digits of *scale* (digits after the decimal point).
<i>940</i>&nbsp;     *
<i>941</i>&nbsp;     * Under a rounding to nearest even policy, the returned result is a digit
<i>942</i>&nbsp;     * string of a number in the (in this case decimal) destination format
<i>943</i>&nbsp;     * closest to the exact numerical value of the (in this case binary) input
<i>944</i>&nbsp;     * value.  If two destination format numbers are equally distant, the one
<i>945</i>&nbsp;     * with the last digit even is returned.  To compute such a correctly rounded
<i>946</i>&nbsp;     * value, some information about digits beyond the smallest returned digit
<i>947</i>&nbsp;     * position needs to be consulted.
<i>948</i>&nbsp;     *
<i>949</i>&nbsp;     * In general, a guard digit, a round digit, and a sticky *bit* are needed
<i>950</i>&nbsp;     * beyond the returned digit position.  If the discarded portion of the input
<i>951</i>&nbsp;     * is sufficiently large, the returned digit string is incremented.  In round
<i>952</i>&nbsp;     * to nearest even, this threshold to increment occurs near the half-way
<i>953</i>&nbsp;     * point between digits.  The sticky bit records if there are any remaining
<i>954</i>&nbsp;     * trailing digits of the exact input value in the new format; the sticky bit
<i>955</i>&nbsp;     * is consulted only in close to half-way rounding cases.
<i>956</i>&nbsp;     *
<i>957</i>&nbsp;     * Given the computation of the digit and bit values, rounding is then
<i>958</i>&nbsp;     * reduced to a table lookup problem.  For decimal, the even/odd cases look
<i>959</i>&nbsp;     * like this:
<i>960</i>&nbsp;     *
<i>961</i>&nbsp;     * Last   Round   Sticky
<i>962</i>&nbsp;     * 6      5       0      =&gt; 6   // exactly halfway, return even digit.
<i>963</i>&nbsp;     * 6      5       1      =&gt; 7   // a little bit more than halfway, round up.
<i>964</i>&nbsp;     * 7      5       0      =&gt; 8   // exactly halfway, round up to even.
<i>965</i>&nbsp;     * 7      5       1      =&gt; 8   // a little bit more than halfway, round up.
<i>966</i>&nbsp;     * With analogous entries for other even and odd last-returned digits.
<i>967</i>&nbsp;     *
<i>968</i>&nbsp;     * However, decimal negative powers of 5 smaller than 0.5 are *not* exactly
<i>969</i>&nbsp;     * representable as binary fraction.  In particular, 0.005 (the round limit
<i>970</i>&nbsp;     * for a two-digit scale) and 0.0005 (the round limit for a three-digit
<i>971</i>&nbsp;     * scale) are not representable. Therefore, for input values near these cases
<i>972</i>&nbsp;     * the sticky bit is known to be set which reduces the rounding logic to:
<b class="nc"><i>973</i>&nbsp;     *</b>
<i>974</i>&nbsp;     * Last   Round   Sticky
<b class="nc"><i>975</i>&nbsp;     * 6      5       1      =&gt; 7   // a little bit more than halfway, round up.</b>
<b class="nc"><i>976</i>&nbsp;     * 7      5       1      =&gt; 8   // a little bit more than halfway, round up.</b>
<i>977</i>&nbsp;     *
<i>978</i>&nbsp;     * In other words, if the round digit is 5, the sticky bit is known to be
<i>979</i>&nbsp;     * set.  If the round digit is something other than 5, the sticky bit is not
<i>980</i>&nbsp;     * relevant.  Therefore, some of the logic about whether or not to increment
<i>981</i>&nbsp;     * the destination *decimal* value can occur based on tests of *binary*
<i>982</i>&nbsp;     * computations of the binary input number.
<i>983</i>&nbsp;     */
<b class="nc"><i>984</i>&nbsp;</b>
<i>985</i>&nbsp;    /**
<i>986</i>&nbsp;     * Check validity of using fast-path for this instance. If fast-path is valid
<i>987</i>&nbsp;     * for this instance, sets fast-path state as true and initializes fast-path
<i>988</i>&nbsp;     * utility fields as needed.
<b class="nc"><i>989</i>&nbsp;     *</b>
<b class="nc"><i>990</i>&nbsp;     * This method is supposed to be called rarely, otherwise that will break the</b>
<b class="nc"><i>991</i>&nbsp;     * fast-path performance. That means avoiding frequent changes of the</b>
<i>992</i>&nbsp;     * properties of the instance, since for most properties, each time a change
<b class="nc"><i>993</i>&nbsp;     * happens, a call to this method is needed at the next format call.</b>
<b class="nc"><i>994</i>&nbsp;     *</b>
<i>995</i>&nbsp;     * FAST-PATH RULES:
<b class="nc"><i>996</i>&nbsp;     *  Similar to the default DecimalFormat instantiation case.</b>
<i>997</i>&nbsp;     *  More precisely:
<i>998</i>&nbsp;     *  - HALF_EVEN rounding mode,
<b class="nc"><i>999</i>&nbsp;     *  - isGroupingUsed() is true,</b>
<i>1000</i>&nbsp;     *  - groupingSize of 3,
<i>1001</i>&nbsp;     *  - multiplier is 1,
<i>1002</i>&nbsp;     *  - Decimal separator not mandatory,
<b class="nc"><i>1003</i>&nbsp;     *  - No use of exponential notation,</b>
<i>1004</i>&nbsp;     *  - minimumIntegerDigits is exactly 1 and maximumIntegerDigits at least 10
<b class="nc"><i>1005</i>&nbsp;     *  - For number of fractional digits, the exact values found in the default case:</b>
<b class="nc"><i>1006</i>&nbsp;     *     Currency : min = max = 2.</b>
<i>1007</i>&nbsp;     *     Decimal  : min = 0. max = 3.
<i>1008</i>&nbsp;     *
<i>1009</i>&nbsp;     */
<b class="nc"><i>1010</i>&nbsp;    private boolean checkAndSetFastPathStatus() {</b>
<b class="nc"><i>1011</i>&nbsp;</b>
<i>1012</i>&nbsp;        boolean fastPathWasOn = isFastPath;
<i>1013</i>&nbsp;
<b class="nc"><i>1014</i>&nbsp;        if ((roundingMode == RoundingMode.HALF_EVEN) &amp;&amp;</b>
<b class="nc"><i>1015</i>&nbsp;            (isGroupingUsed()) &amp;&amp;</b>
<i>1016</i>&nbsp;            (groupingSize == 3) &amp;&amp;
<i>1017</i>&nbsp;            (multiplier == 1) &amp;&amp;
<b class="nc"><i>1018</i>&nbsp;            (!decimalSeparatorAlwaysShown) &amp;&amp;</b>
<b class="nc"><i>1019</i>&nbsp;            (!useExponentialNotation)) {</b>
<b class="nc"><i>1020</i>&nbsp;</b>
<b class="nc"><i>1021</i>&nbsp;            // The fast-path algorithm is semi-hardcoded against</b>
<i>1022</i>&nbsp;            //  minimumIntegerDigits and maximumIntegerDigits.
<i>1023</i>&nbsp;            isFastPath = ((minimumIntegerDigits == 1) &amp;&amp;
<b class="nc"><i>1024</i>&nbsp;                          (maximumIntegerDigits &gt;= 10));</b>
<b class="nc"><i>1025</i>&nbsp;</b>
<b class="nc"><i>1026</i>&nbsp;            // The fast-path algorithm is hardcoded against</b>
<b class="nc"><i>1027</i>&nbsp;            //  minimumFractionDigits and maximumFractionDigits.</b>
<i>1028</i>&nbsp;            if (isFastPath) {
<b class="nc"><i>1029</i>&nbsp;                if (isCurrencyFormat) {</b>
<i>1030</i>&nbsp;                    if ((minimumFractionDigits != 2) ||
<b class="nc"><i>1031</i>&nbsp;                        (maximumFractionDigits != 2))</b>
<i>1032</i>&nbsp;                        isFastPath = false;
<i>1033</i>&nbsp;                } else if ((minimumFractionDigits != 0) ||
<b class="nc"><i>1034</i>&nbsp;                           (maximumFractionDigits != 3))</b>
<b class="nc"><i>1035</i>&nbsp;                    isFastPath = false;</b>
<b class="nc"><i>1036</i>&nbsp;            }</b>
<b class="nc"><i>1037</i>&nbsp;        } else</b>
<i>1038</i>&nbsp;            isFastPath = false;
<i>1039</i>&nbsp;
<i>1040</i>&nbsp;        resetFastPathData(fastPathWasOn);
<b class="nc"><i>1041</i>&nbsp;        fastPathCheckNeeded = false;</b>
<b class="nc"><i>1042</i>&nbsp;</b>
<b class="nc"><i>1043</i>&nbsp;        /*</b>
<i>1044</i>&nbsp;         * Returns true after successfully checking the fast path condition and
<i>1045</i>&nbsp;         * setting the fast path data. The return value is used by the
<b class="nc"><i>1046</i>&nbsp;         * fastFormat() method to decide whether to call the resetFastPathData</b>
<b class="nc"><i>1047</i>&nbsp;         * method to reinitialize fast path data or is it already initialized</b>
<b class="nc"><i>1048</i>&nbsp;         * in this method.</b>
<i>1049</i>&nbsp;         */
<b class="nc"><i>1050</i>&nbsp;        return true;</b>
<b class="nc"><i>1051</i>&nbsp;    }</b>
<i>1052</i>&nbsp;
<b class="nc"><i>1053</i>&nbsp;    private void resetFastPathData(boolean fastPathWasOn) {</b>
<i>1054</i>&nbsp;        // Since some instance properties may have changed while still falling
<i>1055</i>&nbsp;        // in the fast-path case, we need to reinitialize fastPathData anyway.
<b class="nc"><i>1056</i>&nbsp;        if (isFastPath) {</b>
<b class="nc"><i>1057</i>&nbsp;            // We need to instantiate fastPathData if not already done.</b>
<b class="nc"><i>1058</i>&nbsp;            if (fastPathData == null) {</b>
<b class="nc"><i>1059</i>&nbsp;                fastPathData = new FastPathData();</b>
<b class="nc"><i>1060</i>&nbsp;            }</b>
<i>1061</i>&nbsp;
<i>1062</i>&nbsp;            // Sets up the locale specific constants used when formatting.
<b class="nc"><i>1063</i>&nbsp;            // &#39;0&#39; is our default representation of zero.</b>
<i>1064</i>&nbsp;            fastPathData.zeroDelta = symbols.getZeroDigit() - &#39;0&#39;;
<i>1065</i>&nbsp;            fastPathData.groupingChar = symbols.getGroupingSeparator();
<i>1066</i>&nbsp;
<i>1067</i>&nbsp;            // Sets up fractional constants related to currency/decimal pattern.
<i>1068</i>&nbsp;            fastPathData.fractionalMaxIntBound = (isCurrencyFormat)
<i>1069</i>&nbsp;                    ? 99 : 999;
<i>1070</i>&nbsp;            fastPathData.fractionalScaleFactor = (isCurrencyFormat)
<i>1071</i>&nbsp;                    ? 100.0d : 1000.0d;
<i>1072</i>&nbsp;
<i>1073</i>&nbsp;            // Records the need for adding prefix or suffix
<i>1074</i>&nbsp;            fastPathData.positiveAffixesRequired
<i>1075</i>&nbsp;                    = (positivePrefix.length() != 0)
<i>1076</i>&nbsp;                        || (positiveSuffix.length() != 0);
<i>1077</i>&nbsp;            fastPathData.negativeAffixesRequired
<i>1078</i>&nbsp;                    = (negativePrefix.length() != 0)
<i>1079</i>&nbsp;                        || (negativeSuffix.length() != 0);
<i>1080</i>&nbsp;
<i>1081</i>&nbsp;            // Creates a cached char container for result, with max possible size.
<i>1082</i>&nbsp;            int maxNbIntegralDigits = 10;
<i>1083</i>&nbsp;            int maxNbGroups = 3;
<i>1084</i>&nbsp;            int containerSize
<i>1085</i>&nbsp;                    = Math.max(positivePrefix.length(), negativePrefix.length())
<i>1086</i>&nbsp;                    + maxNbIntegralDigits + maxNbGroups + 1
<i>1087</i>&nbsp;                    + maximumFractionDigits
<i>1088</i>&nbsp;                    + Math.max(positiveSuffix.length(), negativeSuffix.length());
<i>1089</i>&nbsp;
<i>1090</i>&nbsp;            fastPathData.fastPathContainer = new char[containerSize];
<i>1091</i>&nbsp;
<i>1092</i>&nbsp;            // Sets up prefix and suffix char arrays constants.
<i>1093</i>&nbsp;            fastPathData.charsPositiveSuffix = positiveSuffix.toCharArray();
<i>1094</i>&nbsp;            fastPathData.charsNegativeSuffix = negativeSuffix.toCharArray();
<i>1095</i>&nbsp;            fastPathData.charsPositivePrefix = positivePrefix.toCharArray();
<i>1096</i>&nbsp;            fastPathData.charsNegativePrefix = negativePrefix.toCharArray();
<i>1097</i>&nbsp;
<i>1098</i>&nbsp;            // Sets up fixed index positions for integral and fractional digits.
<i>1099</i>&nbsp;            // Sets up decimal point in cached result container.
<i>1100</i>&nbsp;            int longestPrefixLength
<i>1101</i>&nbsp;                    = Math.max(positivePrefix.length(),
<i>1102</i>&nbsp;                            negativePrefix.length());
<i>1103</i>&nbsp;            int decimalPointIndex
<i>1104</i>&nbsp;                    = maxNbIntegralDigits + maxNbGroups + longestPrefixLength;
<i>1105</i>&nbsp;
<i>1106</i>&nbsp;            fastPathData.integralLastIndex = decimalPointIndex - 1;
<i>1107</i>&nbsp;            fastPathData.fractionalFirstIndex = decimalPointIndex + 1;
<i>1108</i>&nbsp;            fastPathData.fastPathContainer[decimalPointIndex]
<i>1109</i>&nbsp;                    = isCurrencyFormat
<i>1110</i>&nbsp;                            ? symbols.getMonetaryDecimalSeparator()
<i>1111</i>&nbsp;                            : symbols.getDecimalSeparator();
<i>1112</i>&nbsp;
<i>1113</i>&nbsp;        } else if (fastPathWasOn) {
<i>1114</i>&nbsp;            // Previous state was fast-path and is no more.
<i>1115</i>&nbsp;            // Resets cached array constants.
<i>1116</i>&nbsp;            fastPathData.fastPathContainer = null;
<i>1117</i>&nbsp;            fastPathData.charsPositiveSuffix = null;
<i>1118</i>&nbsp;            fastPathData.charsNegativeSuffix = null;
<i>1119</i>&nbsp;            fastPathData.charsPositivePrefix = null;
<i>1120</i>&nbsp;            fastPathData.charsNegativePrefix = null;
<i>1121</i>&nbsp;        }
<i>1122</i>&nbsp;    }
<i>1123</i>&nbsp;
<i>1124</i>&nbsp;    /**
<i>1125</i>&nbsp;     * Returns true if rounding-up must be done on {@code scaledFractionalPartAsInt},
<i>1126</i>&nbsp;     * false otherwise.
<i>1127</i>&nbsp;     *
<i>1128</i>&nbsp;     * This is a utility method that takes correct half-even rounding decision on
<i>1129</i>&nbsp;     * passed fractional value at the scaled decimal point (2 digits for currency
<i>1130</i>&nbsp;     * case and 3 for decimal case), when the approximated fractional part after
<i>1131</i>&nbsp;     * scaled decimal point is exactly 0.5d.  This is done by means of exact
<i>1132</i>&nbsp;     * calculations on the {@code fractionalPart} floating-point value.
<i>1133</i>&nbsp;     *
<i>1134</i>&nbsp;     * This method is supposed to be called by private {@code fastDoubleFormat}
<i>1135</i>&nbsp;     * method only.
<i>1136</i>&nbsp;     *
<i>1137</i>&nbsp;     * The algorithms used for the exact calculations are :
<i>1138</i>&nbsp;     *
<i>1139</i>&nbsp;     * The &lt;b&gt;&lt;i&gt;FastTwoSum&lt;/i&gt;&lt;/b&gt; algorithm, from T.J.Dekker, described in the
<i>1140</i>&nbsp;     * papers  &quot;&lt;i&gt;A  Floating-Point   Technique  for  Extending  the  Available
<i>1141</i>&nbsp;     * Precision&lt;/i&gt;&quot;  by Dekker, and  in &quot;&lt;i&gt;Adaptive  Precision Floating-Point
<i>1142</i>&nbsp;     * Arithmetic and Fast Robust Geometric Predicates&lt;/i&gt;&quot; from J.Shewchuk.
<i>1143</i>&nbsp;     *
<i>1144</i>&nbsp;     * A modified version of &lt;b&gt;&lt;i&gt;Sum2S&lt;/i&gt;&lt;/b&gt; cascaded summation described in
<i>1145</i>&nbsp;     * &quot;&lt;i&gt;Accurate Sum and Dot Product&lt;/i&gt;&quot; from Takeshi Ogita and All.  As
<b class="nc"><i>1146</i>&nbsp;     * Ogita says in this paper this is an equivalent of the Kahan-Babuska&#39;s</b>
<b class="nc"><i>1147</i>&nbsp;     * summation algorithm because we order the terms by magnitude before summing</b>
<b class="nc"><i>1148</i>&nbsp;     * them. For this reason we can use the &lt;i&gt;FastTwoSum&lt;/i&gt; algorithm rather</b>
<i>1149</i>&nbsp;     * than the more expensive Knuth&#39;s &lt;i&gt;TwoSum&lt;/i&gt;.
<b class="nc"><i>1150</i>&nbsp;     *</b>
<i>1151</i>&nbsp;     * We do this to avoid a more expensive exact &quot;&lt;i&gt;TwoProduct&lt;/i&gt;&quot; algorithm,
<i>1152</i>&nbsp;     * like those described in Shewchuk&#39;s paper above. See comments in the code
<b class="nc"><i>1153</i>&nbsp;     * below.</b>
<b class="nc"><i>1154</i>&nbsp;     *</b>
<b class="nc"><i>1155</i>&nbsp;     * @param  fractionalPart The  fractional value  on which  we  take rounding</b>
<i>1156</i>&nbsp;     * decision.
<i>1157</i>&nbsp;     * @param scaledFractionalPartAsInt The integral part of the scaled
<i>1158</i>&nbsp;     * fractional value.
<b class="nc"><i>1159</i>&nbsp;     *</b>
<b class="nc"><i>1160</i>&nbsp;     * @return the decision that must be taken regarding half-even rounding.</b>
<b class="nc"><i>1161</i>&nbsp;     */</b>
<i>1162</i>&nbsp;    private boolean exactRoundUp(double fractionalPart,
<i>1163</i>&nbsp;                                 int scaledFractionalPartAsInt) {
<i>1164</i>&nbsp;
<b class="nc"><i>1165</i>&nbsp;        /* exactRoundUp() method is called by fastDoubleFormat() only.</b>
<b class="nc"><i>1166</i>&nbsp;         * The precondition expected to be verified by the passed parameters is :</b>
<b class="nc"><i>1167</i>&nbsp;         * scaledFractionalPartAsInt ==</b>
<b class="nc"><i>1168</i>&nbsp;         *     (int) (fractionalPart * fastPathData.fractionalScaleFactor).</b>
<b class="nc"><i>1169</i>&nbsp;         * This is ensured by fastDoubleFormat() code.</b>
<b class="nc"><i>1170</i>&nbsp;         */</b>
<i>1171</i>&nbsp;
<i>1172</i>&nbsp;        /* We first calculate roundoff error made by fastDoubleFormat() on
<b class="nc"><i>1173</i>&nbsp;         * the scaled fractional part. We do this with exact calculation on the</b>
<b class="nc"><i>1174</i>&nbsp;         * passed fractionalPart. Rounding decision will then be taken from roundoff.</b>
<b class="nc"><i>1175</i>&nbsp;         */</b>
<b class="nc"><i>1176</i>&nbsp;</b>
<b class="nc"><i>1177</i>&nbsp;        /* ---- TwoProduct(fractionalPart, scale factor (i.e. 1000.0d or 100.0d)).</b>
<b class="nc"><i>1178</i>&nbsp;         *</b>
<b class="nc"><i>1179</i>&nbsp;         * The below is an optimized exact &quot;TwoProduct&quot; calculation of passed</b>
<i>1180</i>&nbsp;         * fractional part with scale factor, using Ogita&#39;s Sum2S cascaded
<i>1181</i>&nbsp;         * summation adapted as Kahan-Babuska equivalent by using FastTwoSum
<b class="nc"><i>1182</i>&nbsp;         * (much faster) rather than Knuth&#39;s TwoSum.</b>
<b class="nc"><i>1183</i>&nbsp;         *</b>
<b class="nc"><i>1184</i>&nbsp;         * We can do this because we order the summation from smallest to</b>
<i>1185</i>&nbsp;         * greatest, so that FastTwoSum can be used without any additional error.
<i>1186</i>&nbsp;         *
<b class="nc"><i>1187</i>&nbsp;         * The &quot;TwoProduct&quot; exact calculation needs 17 flops. We replace this by</b>
<i>1188</i>&nbsp;         * a cascaded summation of FastTwoSum calculations, each involving an
<i>1189</i>&nbsp;         * exact multiply by a power of 2.
<i>1190</i>&nbsp;         *
<i>1191</i>&nbsp;         * Doing so saves overall 4 multiplications and 1 addition compared to
<i>1192</i>&nbsp;         * using traditional &quot;TwoProduct&quot;.
<i>1193</i>&nbsp;         *
<i>1194</i>&nbsp;         * The scale factor is either 100 (currency case) or 1000 (decimal case).
<i>1195</i>&nbsp;         * - when 1000, we replace it by (1024 - 16 - 8) = 1000.
<i>1196</i>&nbsp;         * - when 100,  we replace it by (128  - 32 + 4) =  100.
<i>1197</i>&nbsp;         * Every multiplication by a power of 2 (1024, 128, 32, 16, 8, 4) is exact.
<i>1198</i>&nbsp;         *
<i>1199</i>&nbsp;         */
<i>1200</i>&nbsp;        double approxMax;    // Will always be positive.
<i>1201</i>&nbsp;        double approxMedium; // Will always be negative.
<i>1202</i>&nbsp;        double approxMin;
<i>1203</i>&nbsp;
<i>1204</i>&nbsp;        double fastTwoSumApproximation = 0.0d;
<i>1205</i>&nbsp;        double fastTwoSumRoundOff = 0.0d;
<i>1206</i>&nbsp;        double bVirtual = 0.0d;
<i>1207</i>&nbsp;
<i>1208</i>&nbsp;        if (isCurrencyFormat) {
<i>1209</i>&nbsp;            // Scale is 100 = 128 - 32 + 4.
<i>1210</i>&nbsp;            // Multiply by 2**n is a shift. No roundoff. No error.
<b class="nc"><i>1211</i>&nbsp;            approxMax    = fractionalPart * 128.00d;</b>
<b class="nc"><i>1212</i>&nbsp;            approxMedium = - (fractionalPart * 32.00d);</b>
<b class="nc"><i>1213</i>&nbsp;            approxMin    = fractionalPart * 4.00d;</b>
<b class="nc"><i>1214</i>&nbsp;        } else {</b>
<b class="nc"><i>1215</i>&nbsp;            // Scale is 1000 = 1024 - 16 - 8.</b>
<b class="nc"><i>1216</i>&nbsp;            // Multiply by 2**n is a shift. No roundoff. No error.</b>
<i>1217</i>&nbsp;            approxMax    = fractionalPart * 1024.00d;
<i>1218</i>&nbsp;            approxMedium = - (fractionalPart * 16.00d);
<b class="nc"><i>1219</i>&nbsp;            approxMin    = - (fractionalPart * 8.00d);</b>
<i>1220</i>&nbsp;        }
<i>1221</i>&nbsp;
<i>1222</i>&nbsp;        // Shewchuk/Dekker&#39;s FastTwoSum(approxMedium, approxMin).
<i>1223</i>&nbsp;        assert(-approxMedium &gt;= Math.abs(approxMin));
<i>1224</i>&nbsp;        fastTwoSumApproximation = approxMedium + approxMin;
<i>1225</i>&nbsp;        bVirtual = fastTwoSumApproximation - approxMedium;
<i>1226</i>&nbsp;        fastTwoSumRoundOff = approxMin - bVirtual;
<i>1227</i>&nbsp;        double approxS1 = fastTwoSumApproximation;
<i>1228</i>&nbsp;        double roundoffS1 = fastTwoSumRoundOff;
<i>1229</i>&nbsp;
<i>1230</i>&nbsp;        // Shewchuk/Dekker&#39;s FastTwoSum(approxMax, approxS1);
<i>1231</i>&nbsp;        assert(approxMax &gt;= Math.abs(approxS1));
<i>1232</i>&nbsp;        fastTwoSumApproximation = approxMax + approxS1;
<i>1233</i>&nbsp;        bVirtual = fastTwoSumApproximation - approxMax;
<i>1234</i>&nbsp;        fastTwoSumRoundOff = approxS1 - bVirtual;
<i>1235</i>&nbsp;        double roundoff1000 = fastTwoSumRoundOff;
<i>1236</i>&nbsp;        double approx1000 = fastTwoSumApproximation;
<i>1237</i>&nbsp;        double roundoffTotal = roundoffS1 + roundoff1000;
<i>1238</i>&nbsp;
<i>1239</i>&nbsp;        // Shewchuk/Dekker&#39;s FastTwoSum(approx1000, roundoffTotal);
<b class="nc"><i>1240</i>&nbsp;        assert(approx1000 &gt;= Math.abs(roundoffTotal));</b>
<i>1241</i>&nbsp;        fastTwoSumApproximation = approx1000 + roundoffTotal;
<i>1242</i>&nbsp;        bVirtual = fastTwoSumApproximation - approx1000;
<b class="nc"><i>1243</i>&nbsp;</b>
<i>1244</i>&nbsp;        // Now we have got the roundoff for the scaled fractional
<b class="nc"><i>1245</i>&nbsp;        double scaledFractionalRoundoff = roundoffTotal - bVirtual;</b>
<b class="nc"><i>1246</i>&nbsp;</b>
<b class="nc"><i>1247</i>&nbsp;        // ---- TwoProduct(fractionalPart, scale (i.e. 1000.0d or 100.0d)) end.</b>
<i>1248</i>&nbsp;
<b class="nc"><i>1249</i>&nbsp;        /* ---- Taking the rounding decision</b>
<b class="nc"><i>1250</i>&nbsp;         *</b>
<b class="nc"><i>1251</i>&nbsp;         * We take rounding decision based on roundoff and half-even rounding</b>
<b class="nc"><i>1252</i>&nbsp;         * rule.</b>
<i>1253</i>&nbsp;         *
<i>1254</i>&nbsp;         * The above TwoProduct gives us the exact roundoff on the approximated
<i>1255</i>&nbsp;         * scaled fractional, and we know that this approximation is exactly
<b class="nc"><i>1256</i>&nbsp;         * 0.5d, since that has already been tested by the caller</b>
<b class="nc"><i>1257</i>&nbsp;         * (fastDoubleFormat).</b>
<b class="nc"><i>1258</i>&nbsp;         *</b>
<b class="nc"><i>1259</i>&nbsp;         * Decision comes first from the sign of the calculated exact roundoff.</b>
<b class="nc"><i>1260</i>&nbsp;         * - Since being exact roundoff, it cannot be positive with a scaled</b>
<i>1261</i>&nbsp;         *   fractional less than 0.5d, as well as negative with a scaled
<i>1262</i>&nbsp;         *   fractional greater than 0.5d. That leaves us with following 3 cases.
<b class="nc"><i>1263</i>&nbsp;         * - positive, thus scaled fractional == 0.500....0fff ==&gt; round-up.</b>
<i>1264</i>&nbsp;         * - negative, thus scaled fractional == 0.499....9fff ==&gt; don&#39;t round-up.
<i>1265</i>&nbsp;         * - is zero,  thus scaled fractioanl == 0.5 ==&gt; half-even rounding applies :
<i>1266</i>&nbsp;         *    we round-up only if the integral part of the scaled fractional is odd.
<i>1267</i>&nbsp;         *
<i>1268</i>&nbsp;         */
<i>1269</i>&nbsp;        if (scaledFractionalRoundoff &gt; 0.0) {
<i>1270</i>&nbsp;            return true;
<i>1271</i>&nbsp;        } else if (scaledFractionalRoundoff &lt; 0.0) {
<i>1272</i>&nbsp;            return false;
<i>1273</i>&nbsp;        } else if ((scaledFractionalPartAsInt &amp; 1) != 0) {
<i>1274</i>&nbsp;            return true;
<i>1275</i>&nbsp;        }
<i>1276</i>&nbsp;
<i>1277</i>&nbsp;        return false;
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;        // ---- Taking the rounding decision end
<i>1280</i>&nbsp;    }
<i>1281</i>&nbsp;
<b class="nc"><i>1282</i>&nbsp;    /**</b>
<i>1283</i>&nbsp;     * Collects integral digits from passed {@code number}, while setting
<b class="nc"><i>1284</i>&nbsp;     * grouping chars as needed. Updates {@code firstUsedIndex} accordingly.</b>
<b class="nc"><i>1285</i>&nbsp;     *</b>
<i>1286</i>&nbsp;     * Loops downward starting from {@code backwardIndex} position (inclusive).
<b class="nc"><i>1287</i>&nbsp;     *</b>
<i>1288</i>&nbsp;     * @param number  The int value from which we collect digits.
<b class="nc"><i>1289</i>&nbsp;     * @param digitsBuffer The char array container where digits and grouping chars</b>
<b class="nc"><i>1290</i>&nbsp;     *  are stored.</b>
<b class="nc"><i>1291</i>&nbsp;     * @param backwardIndex the position from which we start storing digits in</b>
<i>1292</i>&nbsp;     *  digitsBuffer.
<b class="nc"><i>1293</i>&nbsp;     *</b>
<i>1294</i>&nbsp;     */
<i>1295</i>&nbsp;    private void collectIntegralDigits(int number,
<b class="nc"><i>1296</i>&nbsp;                                       char[] digitsBuffer,</b>
<b class="nc"><i>1297</i>&nbsp;                                       int backwardIndex) {</b>
<b class="nc"><i>1298</i>&nbsp;        int index = backwardIndex;</b>
<b class="nc"><i>1299</i>&nbsp;        int q;</b>
<b class="nc"><i>1300</i>&nbsp;        int r;</b>
<i>1301</i>&nbsp;        while (number &gt; 999) {
<i>1302</i>&nbsp;            // Generates 3 digits per iteration.
<i>1303</i>&nbsp;            q = number / 1000;
<i>1304</i>&nbsp;            r = number - (q &lt;&lt; 10) + (q &lt;&lt; 4) + (q &lt;&lt; 3); // -1024 +16 +8 = 1000.
<b class="nc"><i>1305</i>&nbsp;            number = q;</b>
<i>1306</i>&nbsp;
<b class="nc"><i>1307</i>&nbsp;            digitsBuffer[index--] = DigitArrays.DigitOnes1000[r];</b>
<i>1308</i>&nbsp;            digitsBuffer[index--] = DigitArrays.DigitTens1000[r];
<i>1309</i>&nbsp;            digitsBuffer[index--] = DigitArrays.DigitHundreds1000[r];
<i>1310</i>&nbsp;            digitsBuffer[index--] = fastPathData.groupingChar;
<i>1311</i>&nbsp;        }
<i>1312</i>&nbsp;
<i>1313</i>&nbsp;        // Collects last 3 or less digits.
<i>1314</i>&nbsp;        digitsBuffer[index] = DigitArrays.DigitOnes1000[number];
<i>1315</i>&nbsp;        if (number &gt; 9) {
<i>1316</i>&nbsp;            digitsBuffer[--index]  = DigitArrays.DigitTens1000[number];
<i>1317</i>&nbsp;            if (number &gt; 99)
<i>1318</i>&nbsp;                digitsBuffer[--index]   = DigitArrays.DigitHundreds1000[number];
<i>1319</i>&nbsp;        }
<i>1320</i>&nbsp;
<i>1321</i>&nbsp;        fastPathData.firstUsedIndex = index;
<i>1322</i>&nbsp;    }
<i>1323</i>&nbsp;
<b class="nc"><i>1324</i>&nbsp;    /**</b>
<b class="nc"><i>1325</i>&nbsp;     * Collects the 2 (currency) or 3 (decimal) fractional digits from passed</b>
<b class="nc"><i>1326</i>&nbsp;     * {@code number}, starting at {@code startIndex} position</b>
<b class="nc"><i>1327</i>&nbsp;     * inclusive.  There is no punctuation to set here (no grouping chars).</b>
<i>1328</i>&nbsp;     * Updates {@code fastPathData.lastFreeIndex} accordingly.
<i>1329</i>&nbsp;     *
<i>1330</i>&nbsp;     *
<i>1331</i>&nbsp;     * @param number  The int value from which we collect digits.
<i>1332</i>&nbsp;     * @param digitsBuffer The char array container where digits are stored.
<i>1333</i>&nbsp;     * @param startIndex the position from which we start storing digits in
<i>1334</i>&nbsp;     *  digitsBuffer.
<i>1335</i>&nbsp;     *
<i>1336</i>&nbsp;     */
<i>1337</i>&nbsp;    private void collectFractionalDigits(int number,
<i>1338</i>&nbsp;                                         char[] digitsBuffer,
<i>1339</i>&nbsp;                                         int startIndex) {
<i>1340</i>&nbsp;        int index = startIndex;
<i>1341</i>&nbsp;
<i>1342</i>&nbsp;        char digitOnes = DigitArrays.DigitOnes1000[number];
<i>1343</i>&nbsp;        char digitTens = DigitArrays.DigitTens1000[number];
<b class="nc"><i>1344</i>&nbsp;</b>
<b class="nc"><i>1345</i>&nbsp;        if (isCurrencyFormat) {</b>
<i>1346</i>&nbsp;            // Currency case. Always collects fractional digits.
<i>1347</i>&nbsp;            digitsBuffer[index++] = digitTens;
<i>1348</i>&nbsp;            digitsBuffer[index++] = digitOnes;
<i>1349</i>&nbsp;        } else if (number != 0) {
<i>1350</i>&nbsp;            // Decimal case. Hundreds will always be collected
<b class="nc"><i>1351</i>&nbsp;            digitsBuffer[index++] = DigitArrays.DigitHundreds1000[number];</b>
<b class="nc"><i>1352</i>&nbsp;</b>
<b class="nc"><i>1353</i>&nbsp;            // Ending zeros won&#39;t be collected.</b>
<b class="nc"><i>1354</i>&nbsp;            if (digitOnes != &#39;0&#39;) {</b>
<b class="nc"><i>1355</i>&nbsp;                digitsBuffer[index++] = digitTens;</b>
<b class="nc"><i>1356</i>&nbsp;                digitsBuffer[index++] = digitOnes;</b>
<b class="nc"><i>1357</i>&nbsp;            } else if (digitTens != &#39;0&#39;)</b>
<b class="nc"><i>1358</i>&nbsp;                digitsBuffer[index++] = digitTens;</b>
<i>1359</i>&nbsp;
<b class="nc"><i>1360</i>&nbsp;        } else</b>
<b class="nc"><i>1361</i>&nbsp;            // This is decimal pattern and fractional part is zero.</b>
<b class="nc"><i>1362</i>&nbsp;            // We must remove decimal point from result.</b>
<b class="nc"><i>1363</i>&nbsp;            index--;</b>
<b class="nc"><i>1364</i>&nbsp;</b>
<b class="nc"><i>1365</i>&nbsp;        fastPathData.lastFreeIndex = index;</b>
<i>1366</i>&nbsp;    }
<i>1367</i>&nbsp;
<i>1368</i>&nbsp;    /**
<i>1369</i>&nbsp;     * Internal utility.
<i>1370</i>&nbsp;     * Adds the passed {@code prefix} and {@code suffix} to {@code container}.
<i>1371</i>&nbsp;     *
<i>1372</i>&nbsp;     * @param container  Char array container which to prepend/append the
<i>1373</i>&nbsp;     *  prefix/suffix.
<i>1374</i>&nbsp;     * @param prefix     Char sequence to prepend as a prefix.
<i>1375</i>&nbsp;     * @param suffix     Char sequence to append as a suffix.
<i>1376</i>&nbsp;     *
<i>1377</i>&nbsp;     */
<i>1378</i>&nbsp;    //    private void addAffixes(boolean isNegative, char[] container) {
<i>1379</i>&nbsp;    private void addAffixes(char[] container, char[] prefix, char[] suffix) {
<i>1380</i>&nbsp;
<b class="nc"><i>1381</i>&nbsp;        // We add affixes only if needed (affix length &gt; 0).</b>
<i>1382</i>&nbsp;        int pl = prefix.length;
<i>1383</i>&nbsp;        int sl = suffix.length;
<i>1384</i>&nbsp;        if (pl != 0) prependPrefix(prefix, pl, container);
<i>1385</i>&nbsp;        if (sl != 0) appendSuffix(suffix, sl, container);
<i>1386</i>&nbsp;
<b class="nc"><i>1387</i>&nbsp;    }</b>
<b class="nc"><i>1388</i>&nbsp;</b>
<b class="nc"><i>1389</i>&nbsp;    /**</b>
<b class="nc"><i>1390</i>&nbsp;     * Prepends the passed {@code prefix} chars to given result</b>
<b class="nc"><i>1391</i>&nbsp;     * {@code container}.  Updates {@code fastPathData.firstUsedIndex}</b>
<b class="nc"><i>1392</i>&nbsp;     * accordingly.</b>
<b class="nc"><i>1393</i>&nbsp;     *</b>
<b class="nc"><i>1394</i>&nbsp;     * @param prefix The prefix characters to prepend to result.</b>
<i>1395</i>&nbsp;     * @param len The number of chars to prepend.
<b class="nc"><i>1396</i>&nbsp;     * @param container Char array container which to prepend the prefix</b>
<b class="nc"><i>1397</i>&nbsp;     */</b>
<b class="nc"><i>1398</i>&nbsp;    private void prependPrefix(char[] prefix,</b>
<b class="nc"><i>1399</i>&nbsp;                               int len,</b>
<b class="nc"><i>1400</i>&nbsp;                               char[] container) {</b>
<b class="nc"><i>1401</i>&nbsp;</b>
<i>1402</i>&nbsp;        fastPathData.firstUsedIndex -= len;
<b class="nc"><i>1403</i>&nbsp;        int startIndex = fastPathData.firstUsedIndex;</b>
<i>1404</i>&nbsp;
<i>1405</i>&nbsp;        // If prefix to prepend is only 1 char long, just assigns this char.
<i>1406</i>&nbsp;        // If prefix is less or equal 4, we use a dedicated algorithm that
<i>1407</i>&nbsp;        //  has shown to run faster than System.arraycopy.
<i>1408</i>&nbsp;        // If more than 4, we use System.arraycopy.
<i>1409</i>&nbsp;        if (len == 1)
<i>1410</i>&nbsp;            container[startIndex] = prefix[0];
<i>1411</i>&nbsp;        else if (len &lt;= 4) {
<i>1412</i>&nbsp;            int dstLower = startIndex;
<i>1413</i>&nbsp;            int dstUpper = dstLower + len - 1;
<i>1414</i>&nbsp;            int srcUpper = len - 1;
<i>1415</i>&nbsp;            container[dstLower] = prefix[0];
<i>1416</i>&nbsp;            container[dstUpper] = prefix[srcUpper];
<i>1417</i>&nbsp;
<i>1418</i>&nbsp;            if (len &gt; 2)
<i>1419</i>&nbsp;                container[++dstLower] = prefix[1];
<i>1420</i>&nbsp;            if (len == 4)
<i>1421</i>&nbsp;                container[--dstUpper] = prefix[2];
<i>1422</i>&nbsp;        } else
<b class="nc"><i>1423</i>&nbsp;            System.arraycopy(prefix, 0, container, startIndex, len);</b>
<i>1424</i>&nbsp;    }
<i>1425</i>&nbsp;
<i>1426</i>&nbsp;    /**
<b class="nc"><i>1427</i>&nbsp;     * Appends the passed {@code suffix} chars to given result</b>
<b class="nc"><i>1428</i>&nbsp;     * {@code container}.  Updates {@code fastPathData.lastFreeIndex}</b>
<i>1429</i>&nbsp;     * accordingly.
<i>1430</i>&nbsp;     *
<b class="nc"><i>1431</i>&nbsp;     * @param suffix The suffix characters to append to result.</b>
<b class="nc"><i>1432</i>&nbsp;     * @param len The number of chars to append.</b>
<b class="nc"><i>1433</i>&nbsp;     * @param container Char array container which to append the suffix</b>
<b class="nc"><i>1434</i>&nbsp;     */</b>
<i>1435</i>&nbsp;    private void appendSuffix(char[] suffix,
<b class="nc"><i>1436</i>&nbsp;                              int len,</b>
<b class="nc"><i>1437</i>&nbsp;                              char[] container) {</b>
<i>1438</i>&nbsp;
<i>1439</i>&nbsp;        int startIndex = fastPathData.lastFreeIndex;
<b class="nc"><i>1440</i>&nbsp;</b>
<i>1441</i>&nbsp;        // If suffix to append is only 1 char long, just assigns this char.
<i>1442</i>&nbsp;        // If suffix is less or equal 4, we use a dedicated algorithm that
<i>1443</i>&nbsp;        //  has shown to run faster than System.arraycopy.
<i>1444</i>&nbsp;        // If more than 4, we use System.arraycopy.
<i>1445</i>&nbsp;        if (len == 1)
<i>1446</i>&nbsp;            container[startIndex] = suffix[0];
<i>1447</i>&nbsp;        else if (len &lt;= 4) {
<i>1448</i>&nbsp;            int dstLower = startIndex;
<i>1449</i>&nbsp;            int dstUpper = dstLower + len - 1;
<i>1450</i>&nbsp;            int srcUpper = len - 1;
<i>1451</i>&nbsp;            container[dstLower] = suffix[0];
<i>1452</i>&nbsp;            container[dstUpper] = suffix[srcUpper];
<i>1453</i>&nbsp;
<i>1454</i>&nbsp;            if (len &gt; 2)
<i>1455</i>&nbsp;                container[++dstLower] = suffix[1];
<i>1456</i>&nbsp;            if (len == 4)
<i>1457</i>&nbsp;                container[--dstUpper] = suffix[2];
<b class="nc"><i>1458</i>&nbsp;        } else</b>
<i>1459</i>&nbsp;            System.arraycopy(suffix, 0, container, startIndex, len);
<i>1460</i>&nbsp;
<i>1461</i>&nbsp;        fastPathData.lastFreeIndex += len;
<i>1462</i>&nbsp;    }
<i>1463</i>&nbsp;
<i>1464</i>&nbsp;    /**
<i>1465</i>&nbsp;     * Converts digit chars from {@code digitsBuffer} to current locale.
<i>1466</i>&nbsp;     *
<i>1467</i>&nbsp;     * Must be called before adding affixes since we refer to
<i>1468</i>&nbsp;     * {@code fastPathData.firstUsedIndex} and {@code fastPathData.lastFreeIndex},
<i>1469</i>&nbsp;     * and do not support affixes (for speed reason).
<i>1470</i>&nbsp;     *
<i>1471</i>&nbsp;     * We loop backward starting from last used index in {@code fastPathData}.
<i>1472</i>&nbsp;     *
<i>1473</i>&nbsp;     * @param digitsBuffer The char array container where the digits are stored.
<i>1474</i>&nbsp;     */
<i>1475</i>&nbsp;    private void localizeDigits(char[] digitsBuffer) {
<i>1476</i>&nbsp;
<i>1477</i>&nbsp;        // We will localize only the digits, using the groupingSize,
<i>1478</i>&nbsp;        // and taking into account fractional part.
<i>1479</i>&nbsp;
<i>1480</i>&nbsp;        // First take into account fractional part.
<b class="nc"><i>1481</i>&nbsp;        int digitsCounter =</b>
<i>1482</i>&nbsp;            fastPathData.lastFreeIndex - fastPathData.fractionalFirstIndex;
<i>1483</i>&nbsp;
<b class="nc"><i>1484</i>&nbsp;        // The case when there is no fractional digits.</b>
<i>1485</i>&nbsp;        if (digitsCounter &lt; 0)
<i>1486</i>&nbsp;            digitsCounter = groupingSize;
<b class="nc"><i>1487</i>&nbsp;</b>
<i>1488</i>&nbsp;        // Only the digits remains to localize.
<i>1489</i>&nbsp;        for (int cursor = fastPathData.lastFreeIndex - 1;
<i>1490</i>&nbsp;             cursor &gt;= fastPathData.firstUsedIndex;
<b class="nc"><i>1491</i>&nbsp;             cursor--) {</b>
<i>1492</i>&nbsp;            if (digitsCounter != 0) {
<i>1493</i>&nbsp;                // This is a digit char, we must localize it.
<b class="nc"><i>1494</i>&nbsp;                digitsBuffer[cursor] += fastPathData.zeroDelta;</b>
<i>1495</i>&nbsp;                digitsCounter--;
<i>1496</i>&nbsp;            } else {
<i>1497</i>&nbsp;                // Decimal separator or grouping char. Reinit counter only.
<i>1498</i>&nbsp;                digitsCounter = groupingSize;
<i>1499</i>&nbsp;            }
<b class="nc"><i>1500</i>&nbsp;        }</b>
<b class="nc"><i>1501</i>&nbsp;    }</b>
<b class="nc"><i>1502</i>&nbsp;</b>
<i>1503</i>&nbsp;    /**
<b class="nc"><i>1504</i>&nbsp;     * This is the main entry point for the fast-path format algorithm.</b>
<i>1505</i>&nbsp;     *
<b class="nc"><i>1506</i>&nbsp;     * At this point we are sure to be in the expected conditions to run it.</b>
<i>1507</i>&nbsp;     * This algorithm builds the formatted result and puts it in the dedicated
<b class="nc"><i>1508</i>&nbsp;     * {@code fastPathData.fastPathContainer}.</b>
<i>1509</i>&nbsp;     *
<b class="nc"><i>1510</i>&nbsp;     * @param d the double value to be formatted.</b>
<b class="nc"><i>1511</i>&nbsp;     * @param negative Flag precising if {@code d} is negative.</b>
<i>1512</i>&nbsp;     */
<i>1513</i>&nbsp;    private void fastDoubleFormat(double d,
<b class="nc"><i>1514</i>&nbsp;                                  boolean negative) {</b>
<b class="nc"><i>1515</i>&nbsp;</b>
<i>1516</i>&nbsp;        char[] container = fastPathData.fastPathContainer;
<i>1517</i>&nbsp;
<i>1518</i>&nbsp;        /*
<i>1519</i>&nbsp;         * The principle of the algorithm is to :
<i>1520</i>&nbsp;         * - Break the passed double into its integral and fractional parts
<b class="nc"><i>1521</i>&nbsp;         *    converted into integers.</b>
<i>1522</i>&nbsp;         * - Then decide if rounding up must be applied or not by following
<b class="nc"><i>1523</i>&nbsp;         *    the half-even rounding rule, first using approximated scaled</b>
<i>1524</i>&nbsp;         *    fractional part.
<i>1525</i>&nbsp;         * - For the difficult cases (approximated scaled fractional part
<i>1526</i>&nbsp;         *    being exactly 0.5d), we refine the rounding decision by calling
<b class="nc"><i>1527</i>&nbsp;         *    exactRoundUp utility method that both calculates the exact roundoff</b>
<b class="nc"><i>1528</i>&nbsp;         *    on the approximation and takes correct rounding decision.</b>
<i>1529</i>&nbsp;         * - We round-up the fractional part if needed, possibly propagating the
<i>1530</i>&nbsp;         *    rounding to integral part if we meet a &quot;all-nine&quot; case for the
<b class="nc"><i>1531</i>&nbsp;         *    scaled fractional part.</b>
<b class="nc"><i>1532</i>&nbsp;         * - We then collect digits from the resulting integral and fractional</b>
<b class="nc"><i>1533</i>&nbsp;         *   parts, also setting the required grouping chars on the fly.</b>
<i>1534</i>&nbsp;         * - Then we localize the collected digits if needed, and
<i>1535</i>&nbsp;         * - Finally prepend/append prefix/suffix if any is needed.
<b class="nc"><i>1536</i>&nbsp;         */</b>
<b class="nc"><i>1537</i>&nbsp;</b>
<i>1538</i>&nbsp;        // Exact integral part of d.
<i>1539</i>&nbsp;        int integralPartAsInt = (int) d;
<i>1540</i>&nbsp;
<i>1541</i>&nbsp;        // Exact fractional part of d (since we subtract it&#39;s integral part).
<i>1542</i>&nbsp;        double exactFractionalPart = d - (double) integralPartAsInt;
<i>1543</i>&nbsp;
<i>1544</i>&nbsp;        // Approximated scaled fractional part of d (due to multiplication).
<i>1545</i>&nbsp;        double scaledFractional =
<i>1546</i>&nbsp;            exactFractionalPart * fastPathData.fractionalScaleFactor;
<i>1547</i>&nbsp;
<i>1548</i>&nbsp;        // Exact integral part of scaled fractional above.
<i>1549</i>&nbsp;        int fractionalPartAsInt = (int) scaledFractional;
<i>1550</i>&nbsp;
<i>1551</i>&nbsp;        // Exact fractional part of scaled fractional above.
<i>1552</i>&nbsp;        scaledFractional = scaledFractional - (double) fractionalPartAsInt;
<i>1553</i>&nbsp;
<i>1554</i>&nbsp;        // Only when scaledFractional is exactly 0.5d do we have to do exact
<i>1555</i>&nbsp;        // calculations and take fine-grained rounding decision, since
<i>1556</i>&nbsp;        // approximated results above may lead to incorrect decision.
<i>1557</i>&nbsp;        // Otherwise comparing against 0.5d (strictly greater or less) is ok.
<b class="nc"><i>1558</i>&nbsp;        boolean roundItUp = false;</b>
<b class="nc"><i>1559</i>&nbsp;        if (scaledFractional &gt;= 0.5d) {</b>
<i>1560</i>&nbsp;            if (scaledFractional == 0.5d)
<b class="nc"><i>1561</i>&nbsp;                // Rounding need fine-grained decision.</b>
<i>1562</i>&nbsp;                roundItUp = exactRoundUp(exactFractionalPart, fractionalPartAsInt);
<b class="nc"><i>1563</i>&nbsp;            else</b>
<i>1564</i>&nbsp;                roundItUp = true;
<b class="nc"><i>1565</i>&nbsp;</b>
<i>1566</i>&nbsp;            if (roundItUp) {
<b class="nc"><i>1567</i>&nbsp;                // Rounds up both fractional part (and also integral if needed).</b>
<i>1568</i>&nbsp;                if (fractionalPartAsInt &lt; fastPathData.fractionalMaxIntBound) {
<i>1569</i>&nbsp;                    fractionalPartAsInt++;
<i>1570</i>&nbsp;                } else {
<b class="nc"><i>1571</i>&nbsp;                    // Propagates rounding to integral part since &quot;all nines&quot; case.</b>
<b class="nc"><i>1572</i>&nbsp;                    fractionalPartAsInt = 0;</b>
<b class="nc"><i>1573</i>&nbsp;                    integralPartAsInt++;</b>
<b class="nc"><i>1574</i>&nbsp;                }</b>
<b class="nc"><i>1575</i>&nbsp;            }</b>
<b class="nc"><i>1576</i>&nbsp;        }</b>
<b class="nc"><i>1577</i>&nbsp;</b>
<i>1578</i>&nbsp;        // Collecting digits.
<i>1579</i>&nbsp;        collectFractionalDigits(fractionalPartAsInt, container,
<b class="nc"><i>1580</i>&nbsp;                                fastPathData.fractionalFirstIndex);</b>
<i>1581</i>&nbsp;        collectIntegralDigits(integralPartAsInt, container,
<b class="nc"><i>1582</i>&nbsp;                              fastPathData.integralLastIndex);</b>
<i>1583</i>&nbsp;
<b class="nc"><i>1584</i>&nbsp;        // Localizing digits.</b>
<i>1585</i>&nbsp;        if (fastPathData.zeroDelta != 0)
<i>1586</i>&nbsp;            localizeDigits(container);
<b class="nc"><i>1587</i>&nbsp;</b>
<i>1588</i>&nbsp;        // Adding prefix and suffix.
<i>1589</i>&nbsp;        if (negative) {
<i>1590</i>&nbsp;            if (fastPathData.negativeAffixesRequired)
<i>1591</i>&nbsp;                addAffixes(container,
<i>1592</i>&nbsp;                           fastPathData.charsNegativePrefix,
<i>1593</i>&nbsp;                           fastPathData.charsNegativeSuffix);
<i>1594</i>&nbsp;        } else if (fastPathData.positiveAffixesRequired)
<i>1595</i>&nbsp;            addAffixes(container,
<i>1596</i>&nbsp;                       fastPathData.charsPositivePrefix,
<i>1597</i>&nbsp;                       fastPathData.charsPositiveSuffix);
<i>1598</i>&nbsp;    }
<i>1599</i>&nbsp;
<i>1600</i>&nbsp;    /**
<i>1601</i>&nbsp;     * A fast-path shortcut of format(double) to be called by NumberFormat, or by
<i>1602</i>&nbsp;     * format(double, ...) public methods.
<i>1603</i>&nbsp;     *
<i>1604</i>&nbsp;     * If instance can be applied fast-path and passed double is not NaN or
<i>1605</i>&nbsp;     * Infinity, is in the integer range, we call {@code fastDoubleFormat}
<i>1606</i>&nbsp;     * after changing {@code d} to its positive value if necessary.
<i>1607</i>&nbsp;     *
<i>1608</i>&nbsp;     * Otherwise returns null by convention since fast-path can&#39;t be exercized.
<i>1609</i>&nbsp;     *
<i>1610</i>&nbsp;     * @param d The double value to be formatted
<i>1611</i>&nbsp;     *
<i>1612</i>&nbsp;     * @return the formatted result for {@code d} as a string.
<i>1613</i>&nbsp;     */
<i>1614</i>&nbsp;    String fastFormat(double d) {
<i>1615</i>&nbsp;        boolean isDataSet = false;
<i>1616</i>&nbsp;        // (Re-)Evaluates fast-path status if needed.
<b class="nc"><i>1617</i>&nbsp;        if (fastPathCheckNeeded) {</b>
<b class="nc"><i>1618</i>&nbsp;            isDataSet = checkAndSetFastPathStatus();</b>
<b class="nc"><i>1619</i>&nbsp;        }</b>
<b class="nc"><i>1620</i>&nbsp;</b>
<b class="nc"><i>1621</i>&nbsp;        if (!isFastPath )</b>
<b class="nc"><i>1622</i>&nbsp;            // DecimalFormat instance is not in a fast-path state.</b>
<i>1623</i>&nbsp;            return null;
<i>1624</i>&nbsp;
<i>1625</i>&nbsp;        if (!Double.isFinite(d))
<i>1626</i>&nbsp;            // Should not use fast-path for Infinity and NaN.
<i>1627</i>&nbsp;            return null;
<i>1628</i>&nbsp;
<i>1629</i>&nbsp;        // Extracts and records sign of double value, possibly changing it
<b class="nc"><i>1630</i>&nbsp;        // to a positive one, before calling fastDoubleFormat().</b>
<b class="nc"><i>1631</i>&nbsp;        boolean negative = false;</b>
<i>1632</i>&nbsp;        if (d &lt; 0.0d) {
<i>1633</i>&nbsp;            negative = true;
<b class="nc"><i>1634</i>&nbsp;            d = -d;</b>
<b class="nc"><i>1635</i>&nbsp;        } else if (d == 0.0d) {</b>
<b class="nc"><i>1636</i>&nbsp;            negative = (Math.copySign(1.0d, d) == -1.0d);</b>
<i>1637</i>&nbsp;            d = +0.0d;
<b class="nc"><i>1638</i>&nbsp;        }</b>
<b class="nc"><i>1639</i>&nbsp;</b>
<i>1640</i>&nbsp;        if (d &gt; MAX_INT_AS_DOUBLE)
<i>1641</i>&nbsp;            // Filters out values that are outside expected fast-path range
<b class="nc"><i>1642</i>&nbsp;            return null;</b>
<b class="nc"><i>1643</i>&nbsp;        else {</b>
<b class="nc"><i>1644</i>&nbsp;            if (!isDataSet) {</b>
<b class="nc"><i>1645</i>&nbsp;                /*</b>
<i>1646</i>&nbsp;                 * If the fast path data is not set through
<i>1647</i>&nbsp;                 * checkAndSetFastPathStatus() and fulfil the
<i>1648</i>&nbsp;                 * fast path conditions then reset the data
<i>1649</i>&nbsp;                 * directly through resetFastPathData()
<i>1650</i>&nbsp;                 */
<i>1651</i>&nbsp;                resetFastPathData(isFastPath);
<i>1652</i>&nbsp;            }
<i>1653</i>&nbsp;            fastDoubleFormat(d, negative);
<i>1654</i>&nbsp;
<i>1655</i>&nbsp;        }
<i>1656</i>&nbsp;
<i>1657</i>&nbsp;
<b class="nc"><i>1658</i>&nbsp;        // Returns a new string from updated fastPathContainer.</b>
<b class="nc"><i>1659</i>&nbsp;        return new String(fastPathData.fastPathContainer,</b>
<b class="nc"><i>1660</i>&nbsp;                          fastPathData.firstUsedIndex,</b>
<b class="nc"><i>1661</i>&nbsp;                          fastPathData.lastFreeIndex - fastPathData.firstUsedIndex);</b>
<i>1662</i>&nbsp;
<i>1663</i>&nbsp;    }
<i>1664</i>&nbsp;
<i>1665</i>&nbsp;    // ======== End fast-path formating logic for double =========================
<i>1666</i>&nbsp;
<b class="nc"><i>1667</i>&nbsp;    /**</b>
<b class="nc"><i>1668</i>&nbsp;     * Complete the formatting of a finite number.  On entry, the digitList must</b>
<i>1669</i>&nbsp;     * be filled in with the correct digits.
<i>1670</i>&nbsp;     */
<b class="nc"><i>1671</i>&nbsp;    private StringBuffer subformat(StringBuffer result, FieldDelegate delegate,</b>
<i>1672</i>&nbsp;                                   boolean isNegative, boolean isInteger,
<b class="nc"><i>1673</i>&nbsp;                                   int maxIntDigits, int minIntDigits,</b>
<i>1674</i>&nbsp;                                   int maxFraDigits, int minFraDigits) {
<i>1675</i>&nbsp;        // NOTE: This isn&#39;t required anymore because DigitList takes care of this.
<b class="nc"><i>1676</i>&nbsp;        //</b>
<i>1677</i>&nbsp;        //  // The negative of the exponent represents the number of leading
<i>1678</i>&nbsp;        //  // zeros between the decimal and the first non-zero digit, for
<i>1679</i>&nbsp;        //  // a value &lt; 0.1 (e.g., for 0.00123, -fExponent == 2).  If this
<i>1680</i>&nbsp;        //  // is more than the maximum fraction digits, then we have an underflow
<i>1681</i>&nbsp;        //  // for the printed representation.  We recognize this here and set
<i>1682</i>&nbsp;        //  // the DigitList representation to zero in this situation.
<b class="nc"><i>1683</i>&nbsp;        //</b>
<b class="nc"><i>1684</i>&nbsp;        //  if (-digitList.decimalAt &gt;= getMaximumFractionDigits())</b>
<b class="nc"><i>1685</i>&nbsp;        //  {</b>
<i>1686</i>&nbsp;        //      digitList.count = 0;
<i>1687</i>&nbsp;        //  }
<i>1688</i>&nbsp;
<i>1689</i>&nbsp;        char zero = symbols.getZeroDigit();
<b class="nc"><i>1690</i>&nbsp;        int zeroDelta = zero - &#39;0&#39;; // &#39;0&#39; is the DigitList representation of zero</b>
<i>1691</i>&nbsp;        char grouping = symbols.getGroupingSeparator();
<b class="nc"><i>1692</i>&nbsp;        char decimal = isCurrencyFormat ?</b>
<b class="nc"><i>1693</i>&nbsp;            symbols.getMonetaryDecimalSeparator() :</b>
<i>1694</i>&nbsp;            symbols.getDecimalSeparator();
<b class="nc"><i>1695</i>&nbsp;</b>
<b class="nc"><i>1696</i>&nbsp;        /* Per bug 4147706, DecimalFormat must respect the sign of numbers which</b>
<b class="nc"><i>1697</i>&nbsp;         * format as zero.  This allows sensible computations and preserves</b>
<i>1698</i>&nbsp;         * relations such as signum(1/x) = signum(x), where x is +Infinity or
<b class="nc"><i>1699</i>&nbsp;         * -Infinity.  Prior to this fix, we always formatted zero values as if</b>
<i>1700</i>&nbsp;         * they were positive.  Liu 7/6/98.
<b class="nc"><i>1701</i>&nbsp;         */</b>
<b class="nc"><i>1702</i>&nbsp;        if (digitList.isZero()) {</b>
<i>1703</i>&nbsp;            digitList.decimalAt = 0; // Normalize
<b class="nc"><i>1704</i>&nbsp;        }</b>
<i>1705</i>&nbsp;
<b class="nc"><i>1706</i>&nbsp;        if (isNegative) {</b>
<b class="nc"><i>1707</i>&nbsp;            append(result, negativePrefix, delegate,</b>
<i>1708</i>&nbsp;                   getNegativePrefixFieldPositions(), Field.SIGN);
<i>1709</i>&nbsp;        } else {
<b class="nc"><i>1710</i>&nbsp;            append(result, positivePrefix, delegate,</b>
<i>1711</i>&nbsp;                   getPositivePrefixFieldPositions(), Field.SIGN);
<b class="nc"><i>1712</i>&nbsp;        }</b>
<i>1713</i>&nbsp;
<i>1714</i>&nbsp;        if (useExponentialNotation) {
<i>1715</i>&nbsp;            int iFieldStart = result.length();
<i>1716</i>&nbsp;            int iFieldEnd = -1;
<b class="nc"><i>1717</i>&nbsp;            int fFieldStart = -1;</b>
<i>1718</i>&nbsp;
<b class="nc"><i>1719</i>&nbsp;            // Minimum integer digits are handled in exponential format by</b>
<i>1720</i>&nbsp;            // adjusting the exponent.  For example, 0.01234 with 3 minimum
<b class="nc"><i>1721</i>&nbsp;            // integer digits is &quot;123.4E-4&quot;.</b>
<b class="nc"><i>1722</i>&nbsp;</b>
<i>1723</i>&nbsp;            // Maximum integer digits are interpreted as indicating the
<i>1724</i>&nbsp;            // repeating range.  This is useful for engineering notation, in
<b class="nc"><i>1725</i>&nbsp;            // which the exponent is restricted to a multiple of 3.  For</b>
<i>1726</i>&nbsp;            // example, 0.01234 with 3 maximum integer digits is &quot;12.34e-3&quot;.
<i>1727</i>&nbsp;            // If maximum integer digits are &gt; 1 and are larger than
<i>1728</i>&nbsp;            // minimum integer digits, then minimum integer digits are
<b class="nc"><i>1729</i>&nbsp;            // ignored.</b>
<b class="nc"><i>1730</i>&nbsp;            int exponent = digitList.decimalAt;</b>
<i>1731</i>&nbsp;            int repeat = maxIntDigits;
<b class="nc"><i>1732</i>&nbsp;            int minimumIntegerDigits = minIntDigits;</b>
<i>1733</i>&nbsp;            if (repeat &gt; 1 &amp;&amp; repeat &gt; minIntDigits) {
<b class="nc"><i>1734</i>&nbsp;                // A repeating range is defined; adjust to it as follows.</b>
<b class="nc"><i>1735</i>&nbsp;                // If repeat == 3, we have 6,5,4=&gt;3; 3,2,1=&gt;0; 0,-1,-2=&gt;-3;</b>
<i>1736</i>&nbsp;                // -3,-4,-5=&gt;-6, etc. This takes into account that the
<i>1737</i>&nbsp;                // exponent we have here is off by one from what we expect;
<i>1738</i>&nbsp;                // it is for the format 0.MMMMMx10^n.
<b class="nc"><i>1739</i>&nbsp;                if (exponent &gt;= 1) {</b>
<b class="nc"><i>1740</i>&nbsp;                    exponent = ((exponent - 1) / repeat) * repeat;</b>
<i>1741</i>&nbsp;                } else {
<b class="nc"><i>1742</i>&nbsp;                    // integer division rounds towards 0</b>
<b class="nc"><i>1743</i>&nbsp;                    exponent = ((exponent - repeat) / repeat) * repeat;</b>
<i>1744</i>&nbsp;                }
<i>1745</i>&nbsp;                minimumIntegerDigits = 1;
<i>1746</i>&nbsp;            } else {
<i>1747</i>&nbsp;                // No repeating range is defined; use minimum integer digits.
<i>1748</i>&nbsp;                exponent -= minimumIntegerDigits;
<b class="nc"><i>1749</i>&nbsp;            }</b>
<i>1750</i>&nbsp;
<b class="nc"><i>1751</i>&nbsp;            // We now output a minimum number of digits, and more if there</b>
<i>1752</i>&nbsp;            // are more digits, up to the maximum number of digits.  We
<b class="nc"><i>1753</i>&nbsp;            // place the decimal point after the &quot;integer&quot; digits, which</b>
<b class="nc"><i>1754</i>&nbsp;            // are the first (decimalAt - exponent) digits.</b>
<i>1755</i>&nbsp;            int minimumDigits = minIntDigits + minFraDigits;
<i>1756</i>&nbsp;            if (minimumDigits &lt; 0) {    // overflow?
<i>1757</i>&nbsp;                minimumDigits = Integer.MAX_VALUE;
<i>1758</i>&nbsp;            }
<b class="nc"><i>1759</i>&nbsp;</b>
<b class="nc"><i>1760</i>&nbsp;            // The number of integer digits is handled specially if the number</b>
<i>1761</i>&nbsp;            // is zero, since then there may be no digits.
<i>1762</i>&nbsp;            int integerDigits = digitList.isZero() ? minimumIntegerDigits :
<b class="nc"><i>1763</i>&nbsp;                    digitList.decimalAt - exponent;</b>
<b class="nc"><i>1764</i>&nbsp;            if (minimumDigits &lt; integerDigits) {</b>
<b class="nc"><i>1765</i>&nbsp;                minimumDigits = integerDigits;</b>
<b class="nc"><i>1766</i>&nbsp;            }</b>
<b class="nc"><i>1767</i>&nbsp;            int totalDigits = digitList.count;</b>
<b class="nc"><i>1768</i>&nbsp;            if (minimumDigits &gt; totalDigits) {</b>
<b class="nc"><i>1769</i>&nbsp;                totalDigits = minimumDigits;</b>
<i>1770</i>&nbsp;            }
<b class="nc"><i>1771</i>&nbsp;            boolean addedDecimalSeparator = false;</b>
<i>1772</i>&nbsp;
<b class="nc"><i>1773</i>&nbsp;            for (int i=0; i&lt;totalDigits; ++i) {</b>
<i>1774</i>&nbsp;                if (i == integerDigits) {
<b class="nc"><i>1775</i>&nbsp;                    // Record field information for caller.</b>
<b class="nc"><i>1776</i>&nbsp;                    iFieldEnd = result.length();</b>
<i>1777</i>&nbsp;
<b class="nc"><i>1778</i>&nbsp;                    result.append(decimal);</b>
<b class="nc"><i>1779</i>&nbsp;                    addedDecimalSeparator = true;</b>
<i>1780</i>&nbsp;
<i>1781</i>&nbsp;                    // Record field information for caller.
<b class="nc"><i>1782</i>&nbsp;                    fFieldStart = result.length();</b>
<b class="nc"><i>1783</i>&nbsp;                }</b>
<b class="nc"><i>1784</i>&nbsp;                result.append((i &lt; digitList.count) ?</b>
<b class="nc"><i>1785</i>&nbsp;                              (char)(digitList.digits[i] + zeroDelta) :</b>
<i>1786</i>&nbsp;                              zero);
<i>1787</i>&nbsp;            }
<i>1788</i>&nbsp;
<i>1789</i>&nbsp;            if (decimalSeparatorAlwaysShown &amp;&amp; totalDigits == integerDigits) {
<i>1790</i>&nbsp;                // Record field information for caller.
<b class="nc"><i>1791</i>&nbsp;                iFieldEnd = result.length();</b>
<b class="nc"><i>1792</i>&nbsp;</b>
<b class="nc"><i>1793</i>&nbsp;                result.append(decimal);</b>
<b class="nc"><i>1794</i>&nbsp;                addedDecimalSeparator = true;</b>
<i>1795</i>&nbsp;
<i>1796</i>&nbsp;                // Record field information for caller.
<i>1797</i>&nbsp;                fFieldStart = result.length();
<i>1798</i>&nbsp;            }
<i>1799</i>&nbsp;
<i>1800</i>&nbsp;            // Record field information
<b class="nc"><i>1801</i>&nbsp;            if (iFieldEnd == -1) {</b>
<b class="nc"><i>1802</i>&nbsp;                iFieldEnd = result.length();</b>
<b class="nc"><i>1803</i>&nbsp;            }</b>
<i>1804</i>&nbsp;            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
<i>1805</i>&nbsp;                               iFieldStart, iFieldEnd, result);
<b class="nc"><i>1806</i>&nbsp;            if (addedDecimalSeparator) {</b>
<b class="nc"><i>1807</i>&nbsp;                delegate.formatted(Field.DECIMAL_SEPARATOR,</b>
<b class="nc"><i>1808</i>&nbsp;                                   Field.DECIMAL_SEPARATOR,</b>
<i>1809</i>&nbsp;                                   iFieldEnd, fFieldStart, result);
<b class="nc"><i>1810</i>&nbsp;            }</b>
<i>1811</i>&nbsp;            if (fFieldStart == -1) {
<i>1812</i>&nbsp;                fFieldStart = result.length();
<b class="nc"><i>1813</i>&nbsp;            }</b>
<i>1814</i>&nbsp;            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
<i>1815</i>&nbsp;                               fFieldStart, result.length(), result);
<i>1816</i>&nbsp;
<i>1817</i>&nbsp;            // The exponent is output using the pattern-specified minimum
<i>1818</i>&nbsp;            // exponent digits.  There is no maximum limit to the exponent
<b class="nc"><i>1819</i>&nbsp;            // digits, since truncating the exponent would result in an</b>
<i>1820</i>&nbsp;            // unacceptable inaccuracy.
<b class="nc"><i>1821</i>&nbsp;            int fieldStart = result.length();</b>
<b class="nc"><i>1822</i>&nbsp;</b>
<b class="nc"><i>1823</i>&nbsp;            result.append(symbols.getExponentSeparator());</b>
<i>1824</i>&nbsp;
<b class="nc"><i>1825</i>&nbsp;            delegate.formatted(Field.EXPONENT_SYMBOL, Field.EXPONENT_SYMBOL,</b>
<i>1826</i>&nbsp;                               fieldStart, result.length(), result);
<i>1827</i>&nbsp;
<i>1828</i>&nbsp;            // For zero values, we force the exponent to zero.  We
<i>1829</i>&nbsp;            // must do this here, and not earlier, because the value
<i>1830</i>&nbsp;            // is used to determine integer digit count above.
<b class="nc"><i>1831</i>&nbsp;            if (digitList.isZero()) {</b>
<i>1832</i>&nbsp;                exponent = 0;
<i>1833</i>&nbsp;            }
<i>1834</i>&nbsp;
<i>1835</i>&nbsp;            boolean negativeExponent = exponent &lt; 0;
<i>1836</i>&nbsp;            if (negativeExponent) {
<b class="nc"><i>1837</i>&nbsp;                exponent = -exponent;</b>
<b class="nc"><i>1838</i>&nbsp;                fieldStart = result.length();</b>
<i>1839</i>&nbsp;                result.append(symbols.getMinusSign());
<i>1840</i>&nbsp;                delegate.formatted(Field.EXPONENT_SIGN, Field.EXPONENT_SIGN,
<b class="nc"><i>1841</i>&nbsp;                                   fieldStart, result.length(), result);</b>
<b class="nc"><i>1842</i>&nbsp;            }</b>
<i>1843</i>&nbsp;            digitList.set(negativeExponent, exponent);
<i>1844</i>&nbsp;
<b class="nc"><i>1845</i>&nbsp;            int eFieldStart = result.length();</b>
<b class="nc"><i>1846</i>&nbsp;</b>
<b class="nc"><i>1847</i>&nbsp;            for (int i=digitList.decimalAt; i&lt;minExponentDigits; ++i) {</b>
<i>1848</i>&nbsp;                result.append(zero);
<i>1849</i>&nbsp;            }
<b class="nc"><i>1850</i>&nbsp;            for (int i=0; i&lt;digitList.decimalAt; ++i) {</b>
<b class="nc"><i>1851</i>&nbsp;                result.append((i &lt; digitList.count) ?</b>
<i>1852</i>&nbsp;                          (char)(digitList.digits[i] + zeroDelta) : zero);
<b class="nc"><i>1853</i>&nbsp;            }</b>
<i>1854</i>&nbsp;            delegate.formatted(Field.EXPONENT, Field.EXPONENT, eFieldStart,
<b class="nc"><i>1855</i>&nbsp;                               result.length(), result);</b>
<i>1856</i>&nbsp;        } else {
<b class="nc"><i>1857</i>&nbsp;            int iFieldStart = result.length();</b>
<i>1858</i>&nbsp;
<i>1859</i>&nbsp;            // Output the integer portion.  Here &#39;count&#39; is the total
<i>1860</i>&nbsp;            // number of integer digits we will display, including both
<i>1861</i>&nbsp;            // leading zeros required to satisfy getMinimumIntegerDigits,
<i>1862</i>&nbsp;            // and actual digits present in the number.
<i>1863</i>&nbsp;            int count = minIntDigits;
<b class="nc"><i>1864</i>&nbsp;            int digitIndex = 0; // Index into digitList.fDigits[]</b>
<i>1865</i>&nbsp;            if (digitList.decimalAt &gt; 0 &amp;&amp; count &lt; digitList.decimalAt) {
<b class="nc"><i>1866</i>&nbsp;                count = digitList.decimalAt;</b>
<i>1867</i>&nbsp;            }
<i>1868</i>&nbsp;
<i>1869</i>&nbsp;            // Handle the case where getMaximumIntegerDigits() is smaller
<i>1870</i>&nbsp;            // than the real number of integer digits.  If this is so, we
<i>1871</i>&nbsp;            // output the least significant max integer digits.  For example,
<b class="nc"><i>1872</i>&nbsp;            // the value 1997 printed with 2 max integer digits is just &quot;97&quot;.</b>
<b class="nc"><i>1873</i>&nbsp;            if (count &gt; maxIntDigits) {</b>
<b class="nc"><i>1874</i>&nbsp;                count = maxIntDigits;</b>
<i>1875</i>&nbsp;                digitIndex = digitList.decimalAt - count;
<i>1876</i>&nbsp;            }
<i>1877</i>&nbsp;
<i>1878</i>&nbsp;            int sizeBeforeIntegerPart = result.length();
<b class="nc"><i>1879</i>&nbsp;            for (int i=count-1; i&gt;=0; --i) {</b>
<b class="nc"><i>1880</i>&nbsp;                if (i &lt; digitList.decimalAt &amp;&amp; digitIndex &lt; digitList.count) {</b>
<i>1881</i>&nbsp;                    // Output a real digit
<b class="nc"><i>1882</i>&nbsp;                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));</b>
<i>1883</i>&nbsp;                } else {
<i>1884</i>&nbsp;                    // Output a leading zero
<i>1885</i>&nbsp;                    result.append(zero);
<i>1886</i>&nbsp;                }
<b class="nc"><i>1887</i>&nbsp;</b>
<b class="nc"><i>1888</i>&nbsp;                // Output grouping separator if necessary.  Don&#39;t output a</b>
<i>1889</i>&nbsp;                // grouping separator if i==0 though; that&#39;s at the end of
<i>1890</i>&nbsp;                // the integer part.
<b class="nc"><i>1891</i>&nbsp;                if (isGroupingUsed() &amp;&amp; i&gt;0 &amp;&amp; (groupingSize != 0) &amp;&amp;</b>
<b class="nc"><i>1892</i>&nbsp;                    (i % groupingSize == 0)) {</b>
<b class="nc"><i>1893</i>&nbsp;                    int gStart = result.length();</b>
<i>1894</i>&nbsp;                    result.append(grouping);
<b class="nc"><i>1895</i>&nbsp;                    delegate.formatted(Field.GROUPING_SEPARATOR,</b>
<b class="nc"><i>1896</i>&nbsp;                                       Field.GROUPING_SEPARATOR, gStart,</b>
<i>1897</i>&nbsp;                                       result.length(), result);
<i>1898</i>&nbsp;                }
<b class="nc"><i>1899</i>&nbsp;            }</b>
<i>1900</i>&nbsp;
<i>1901</i>&nbsp;            // Determine whether or not there are any printable fractional
<i>1902</i>&nbsp;            // digits.  If we&#39;ve used up the digits we know there aren&#39;t.
<i>1903</i>&nbsp;            boolean fractionPresent = (minFraDigits &gt; 0) ||
<i>1904</i>&nbsp;                (!isInteger &amp;&amp; digitIndex &lt; digitList.count);
<i>1905</i>&nbsp;
<i>1906</i>&nbsp;            // If there is no fraction present, and we haven&#39;t printed any
<i>1907</i>&nbsp;            // integer digits, then print a zero.  Otherwise we won&#39;t print
<i>1908</i>&nbsp;            // _any_ digits, and we won&#39;t be able to parse this string.
<i>1909</i>&nbsp;            if (!fractionPresent &amp;&amp; result.length() == sizeBeforeIntegerPart) {
<i>1910</i>&nbsp;                result.append(zero);
<i>1911</i>&nbsp;            }
<i>1912</i>&nbsp;
<i>1913</i>&nbsp;            delegate.formatted(INTEGER_FIELD, Field.INTEGER, Field.INTEGER,
<i>1914</i>&nbsp;                               iFieldStart, result.length(), result);
<i>1915</i>&nbsp;
<i>1916</i>&nbsp;            // Output the decimal separator if we always do so.
<i>1917</i>&nbsp;            int sStart = result.length();
<i>1918</i>&nbsp;            if (decimalSeparatorAlwaysShown || fractionPresent) {
<b class="nc"><i>1919</i>&nbsp;                result.append(decimal);</b>
<i>1920</i>&nbsp;            }
<b class="nc"><i>1921</i>&nbsp;</b>
<b class="nc"><i>1922</i>&nbsp;            if (sStart != result.length()) {</b>
<b class="nc"><i>1923</i>&nbsp;                delegate.formatted(Field.DECIMAL_SEPARATOR,</b>
<b class="nc"><i>1924</i>&nbsp;                                   Field.DECIMAL_SEPARATOR,</b>
<b class="nc"><i>1925</i>&nbsp;                                   sStart, result.length(), result);</b>
<b class="nc"><i>1926</i>&nbsp;            }</b>
<i>1927</i>&nbsp;            int fFieldStart = result.length();
<b class="nc"><i>1928</i>&nbsp;</b>
<b class="nc"><i>1929</i>&nbsp;            for (int i=0; i &lt; maxFraDigits; ++i) {</b>
<i>1930</i>&nbsp;                // Here is where we escape from the loop.  We escape if we&#39;ve
<b class="nc"><i>1931</i>&nbsp;                // output the maximum fraction digits (specified in the for</b>
<b class="nc"><i>1932</i>&nbsp;                // expression above).</b>
<b class="nc"><i>1933</i>&nbsp;                // We also stop when we&#39;ve output the minimum digits and either:</b>
<i>1934</i>&nbsp;                // we have an integer, so there is no fractional stuff to
<i>1935</i>&nbsp;                // display, or we&#39;re out of significant digits.
<i>1936</i>&nbsp;                if (i &gt;= minFraDigits &amp;&amp;
<i>1937</i>&nbsp;                    (isInteger || digitIndex &gt;= digitList.count)) {
<i>1938</i>&nbsp;                    break;
<i>1939</i>&nbsp;                }
<i>1940</i>&nbsp;
<i>1941</i>&nbsp;                // Output leading fractional zeros. These are zeros that come
<i>1942</i>&nbsp;                // after the decimal but before any significant digits. These
<i>1943</i>&nbsp;                // are only output if abs(number being formatted) &lt; 1.0.
<i>1944</i>&nbsp;                if (-1-i &gt; (digitList.decimalAt-1)) {
<i>1945</i>&nbsp;                    result.append(zero);
<i>1946</i>&nbsp;                    continue;
<i>1947</i>&nbsp;                }
<i>1948</i>&nbsp;
<i>1949</i>&nbsp;                // Output a digit, if we have any precision left, or a
<i>1950</i>&nbsp;                // zero if we don&#39;t.  We don&#39;t want to output noise digits.
<i>1951</i>&nbsp;                if (!isInteger &amp;&amp; digitIndex &lt; digitList.count) {
<i>1952</i>&nbsp;                    result.append((char)(digitList.digits[digitIndex++] + zeroDelta));
<i>1953</i>&nbsp;                } else {
<i>1954</i>&nbsp;                    result.append(zero);
<i>1955</i>&nbsp;                }
<i>1956</i>&nbsp;            }
<i>1957</i>&nbsp;
<i>1958</i>&nbsp;            // Record field information for caller.
<i>1959</i>&nbsp;            delegate.formatted(FRACTION_FIELD, Field.FRACTION, Field.FRACTION,
<i>1960</i>&nbsp;                               fFieldStart, result.length(), result);
<i>1961</i>&nbsp;        }
<i>1962</i>&nbsp;
<i>1963</i>&nbsp;        if (isNegative) {
<i>1964</i>&nbsp;            append(result, negativeSuffix, delegate,
<i>1965</i>&nbsp;                   getNegativeSuffixFieldPositions(), Field.SIGN);
<i>1966</i>&nbsp;        } else {
<i>1967</i>&nbsp;            append(result, positiveSuffix, delegate,
<i>1968</i>&nbsp;                   getPositiveSuffixFieldPositions(), Field.SIGN);
<i>1969</i>&nbsp;        }
<i>1970</i>&nbsp;
<i>1971</i>&nbsp;        return result;
<i>1972</i>&nbsp;    }
<i>1973</i>&nbsp;
<i>1974</i>&nbsp;    /**
<i>1975</i>&nbsp;     * Appends the String &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;result&lt;/code&gt;.
<i>1976</i>&nbsp;     * &lt;code&gt;delegate&lt;/code&gt; is notified of all  the
<i>1977</i>&nbsp;     * &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;.
<i>1978</i>&nbsp;     * &lt;p&gt;
<i>1979</i>&nbsp;     * If one of the &lt;code&gt;FieldPosition&lt;/code&gt;s in &lt;code&gt;positions&lt;/code&gt;
<i>1980</i>&nbsp;     * identifies a &lt;code&gt;SIGN&lt;/code&gt; attribute, it is mapped to
<i>1981</i>&nbsp;     * &lt;code&gt;signAttribute&lt;/code&gt;. This is used
<i>1982</i>&nbsp;     * to map the &lt;code&gt;SIGN&lt;/code&gt; attribute to the &lt;code&gt;EXPONENT&lt;/code&gt;
<i>1983</i>&nbsp;     * attribute as necessary.
<i>1984</i>&nbsp;     * &lt;p&gt;
<i>1985</i>&nbsp;     * This is used by &lt;code&gt;subformat&lt;/code&gt; to add the prefix/suffix.
<i>1986</i>&nbsp;     */
<i>1987</i>&nbsp;    private void append(StringBuffer result, String string,
<i>1988</i>&nbsp;                        FieldDelegate delegate,
<i>1989</i>&nbsp;                        FieldPosition[] positions,
<i>1990</i>&nbsp;                        Format.Field signAttribute) {
<i>1991</i>&nbsp;        int start = result.length();
<i>1992</i>&nbsp;
<i>1993</i>&nbsp;        if (string.length() &gt; 0) {
<i>1994</i>&nbsp;            result.append(string);
<i>1995</i>&nbsp;            for (int counter = 0, max = positions.length; counter &lt; max;
<i>1996</i>&nbsp;                 counter++) {
<b class="nc"><i>1997</i>&nbsp;                FieldPosition fp = positions[counter];</b>
<b class="nc"><i>1998</i>&nbsp;                Format.Field attribute = fp.getFieldAttribute();</b>
<b class="nc"><i>1999</i>&nbsp;</b>
<i>2000</i>&nbsp;                if (attribute == Field.SIGN) {
<i>2001</i>&nbsp;                    attribute = signAttribute;
<b class="nc"><i>2002</i>&nbsp;                }</b>
<b class="nc"><i>2003</i>&nbsp;                delegate.formatted(attribute, attribute,</b>
<b class="nc"><i>2004</i>&nbsp;                                   start + fp.getBeginIndex(),</b>
<i>2005</i>&nbsp;                                   start + fp.getEndIndex(), result);
<i>2006</i>&nbsp;            }
<i>2007</i>&nbsp;        }
<b class="nc"><i>2008</i>&nbsp;    }</b>
<b class="nc"><i>2009</i>&nbsp;</b>
<b class="nc"><i>2010</i>&nbsp;    /**</b>
<i>2011</i>&nbsp;     * Parses text from a string to produce a &lt;code&gt;Number&lt;/code&gt;.
<b class="nc"><i>2012</i>&nbsp;     * &lt;p&gt;</b>
<i>2013</i>&nbsp;     * The method attempts to parse text starting at the index given by
<i>2014</i>&nbsp;     * &lt;code&gt;pos&lt;/code&gt;.
<i>2015</i>&nbsp;     * If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated
<b class="nc"><i>2016</i>&nbsp;     * to the index after the last character used (parsing does not necessarily</b>
<b class="nc"><i>2017</i>&nbsp;     * use all characters up to the end of the string), and the parsed</b>
<b class="nc"><i>2018</i>&nbsp;     * number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to</b>
<b class="nc"><i>2019</i>&nbsp;     * indicate the starting point for the next call to this method.</b>
<b class="nc"><i>2020</i>&nbsp;     * If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not</b>
<i>2021</i>&nbsp;     * changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of
<b class="nc"><i>2022</i>&nbsp;     * the character where the error occurred, and null is returned.</b>
<i>2023</i>&nbsp;     * &lt;p&gt;
<i>2024</i>&nbsp;     * The subclass returned depends on the value of {@link #isParseBigDecimal}
<i>2025</i>&nbsp;     * as well as on the string being parsed.
<b class="nc"><i>2026</i>&nbsp;     * &lt;ul&gt;</b>
<b class="nc"><i>2027</i>&nbsp;     *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is false (the default),</b>
<i>2028</i>&nbsp;     *       most integer values are returned as &lt;code&gt;Long&lt;/code&gt;
<b class="nc"><i>2029</i>&nbsp;     *       objects, no matter how they are written: &lt;code&gt;&quot;17&quot;&lt;/code&gt; and</b>
<i>2030</i>&nbsp;     *       &lt;code&gt;&quot;17.000&quot;&lt;/code&gt; both parse to &lt;code&gt;Long(17)&lt;/code&gt;.
<b class="nc"><i>2031</i>&nbsp;     *       Values that cannot fit into a &lt;code&gt;Long&lt;/code&gt; are returned as</b>
<i>2032</i>&nbsp;     *       &lt;code&gt;Double&lt;/code&gt;s. This includes values with a fractional part,
<b class="nc"><i>2033</i>&nbsp;     *       infinite values, &lt;code&gt;NaN&lt;/code&gt;, and the value -0.0.</b>
<b class="nc"><i>2034</i>&nbsp;     *       &lt;code&gt;DecimalFormat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; decide whether to</b>
<b class="nc"><i>2035</i>&nbsp;     *       return a &lt;code&gt;Double&lt;/code&gt; or a &lt;code&gt;Long&lt;/code&gt; based on the</b>
<i>2036</i>&nbsp;     *       presence of a decimal separator in the source string. Doing so
<i>2037</i>&nbsp;     *       would prevent integers that overflow the mantissa of a double,
<b class="nc"><i>2038</i>&nbsp;     *       such as &lt;code&gt;&quot;-9,223,372,036,854,775,808.00&quot;&lt;/code&gt;, from being</b>
<b class="nc"><i>2039</i>&nbsp;     *       parsed accurately.</b>
<i>2040</i>&nbsp;     *       &lt;p&gt;
<b class="nc"><i>2041</i>&nbsp;     *       Callers may use the &lt;code&gt;Number&lt;/code&gt; methods</b>
<i>2042</i>&nbsp;     *       &lt;code&gt;doubleValue&lt;/code&gt;, &lt;code&gt;longValue&lt;/code&gt;, etc., to obtain
<b class="nc"><i>2043</i>&nbsp;     *       the type they want.</b>
<b class="nc"><i>2044</i>&nbsp;     *   &lt;li&gt;If &lt;code&gt;isParseBigDecimal()&lt;/code&gt; is true, values are returned</b>
<b class="nc"><i>2045</i>&nbsp;     *       as &lt;code&gt;BigDecimal&lt;/code&gt; objects. The values are the ones</b>
<b class="nc"><i>2046</i>&nbsp;     *       constructed by {@link java.math.BigDecimal#BigDecimal(String)}</b>
<i>2047</i>&nbsp;     *       for corresponding strings in locale-independent format. The
<i>2048</i>&nbsp;     *       special cases negative and positive infinity and NaN are returned
<b class="nc"><i>2049</i>&nbsp;     *       as &lt;code&gt;Double&lt;/code&gt; instances holding the values of the</b>
<b class="nc"><i>2050</i>&nbsp;     *       corresponding &lt;code&gt;Double&lt;/code&gt; constants.</b>
<b class="nc"><i>2051</i>&nbsp;     * &lt;/ul&gt;</b>
<b class="nc"><i>2052</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>2053</i>&nbsp;     * &lt;code&gt;DecimalFormat&lt;/code&gt; parses all Unicode characters that represent</b>
<i>2054</i>&nbsp;     * decimal digits, as defined by &lt;code&gt;Character.digit()&lt;/code&gt;. In
<i>2055</i>&nbsp;     * addition, &lt;code&gt;DecimalFormat&lt;/code&gt; also recognizes as digits the ten
<b class="nc"><i>2056</i>&nbsp;     * consecutive characters starting with the localized zero digit defined in</b>
<i>2057</i>&nbsp;     * the &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object.
<i>2058</i>&nbsp;     *
<i>2059</i>&nbsp;     * @param text the string to be parsed
<i>2060</i>&nbsp;     * @param pos  A &lt;code&gt;ParsePosition&lt;/code&gt; object with index and error
<b class="nc"><i>2061</i>&nbsp;     *             index information as described above.</b>
<b class="nc"><i>2062</i>&nbsp;     * @return     the parsed value, or &lt;code&gt;null&lt;/code&gt; if the parse fails</b>
<b class="nc"><i>2063</i>&nbsp;     * @exception  NullPointerException if &lt;code&gt;text&lt;/code&gt; or</b>
<i>2064</i>&nbsp;     *             &lt;code&gt;pos&lt;/code&gt; is null.
<i>2065</i>&nbsp;     */
<b class="nc"><i>2066</i>&nbsp;    @Override</b>
<b class="nc"><i>2067</i>&nbsp;    public Number parse(String text, ParsePosition pos) {</b>
<i>2068</i>&nbsp;        // special case NaN
<b class="nc"><i>2069</i>&nbsp;        if (text.regionMatches(pos.index, symbols.getNaN(), 0, symbols.getNaN().length())) {</b>
<b class="nc"><i>2070</i>&nbsp;            pos.index = pos.index + symbols.getNaN().length();</b>
<i>2071</i>&nbsp;            return Double.valueOf(Double.NaN);
<i>2072</i>&nbsp;        }
<i>2073</i>&nbsp;
<i>2074</i>&nbsp;        boolean[] status = new boolean[STATUS_LENGTH];
<b class="nc"><i>2075</i>&nbsp;        if (!subparse(text, pos, positivePrefix, negativePrefix, digitList, false, status)) {</b>
<b class="nc"><i>2076</i>&nbsp;            return null;</b>
<b class="nc"><i>2077</i>&nbsp;        }</b>
<i>2078</i>&nbsp;
<i>2079</i>&nbsp;        // special case INFINITY
<i>2080</i>&nbsp;        if (status[STATUS_INFINITE]) {
<i>2081</i>&nbsp;            if (status[STATUS_POSITIVE] == (multiplier &gt;= 0)) {
<i>2082</i>&nbsp;                return Double.valueOf(Double.POSITIVE_INFINITY);
<i>2083</i>&nbsp;            } else {
<i>2084</i>&nbsp;                return Double.valueOf(Double.NEGATIVE_INFINITY);
<i>2085</i>&nbsp;            }
<i>2086</i>&nbsp;        }
<i>2087</i>&nbsp;
<i>2088</i>&nbsp;        if (multiplier == 0) {
<b class="nc"><i>2089</i>&nbsp;            if (digitList.isZero()) {</b>
<b class="nc"><i>2090</i>&nbsp;                return Double.valueOf(Double.NaN);</b>
<b class="nc"><i>2091</i>&nbsp;            } else if (status[STATUS_POSITIVE]) {</b>
<i>2092</i>&nbsp;                return Double.valueOf(Double.POSITIVE_INFINITY);
<b class="nc"><i>2093</i>&nbsp;            } else {</b>
<i>2094</i>&nbsp;                return Double.valueOf(Double.NEGATIVE_INFINITY);
<i>2095</i>&nbsp;            }
<b class="nc"><i>2096</i>&nbsp;        }</b>
<i>2097</i>&nbsp;
<i>2098</i>&nbsp;        if (isParseBigDecimal()) {
<i>2099</i>&nbsp;            BigDecimal bigDecimalResult = digitList.getBigDecimal();
<i>2100</i>&nbsp;
<i>2101</i>&nbsp;            if (multiplier != 1) {
<i>2102</i>&nbsp;                try {
<i>2103</i>&nbsp;                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier());
<i>2104</i>&nbsp;                }
<b class="nc"><i>2105</i>&nbsp;                catch (ArithmeticException e) {  // non-terminating decimal expansion</b>
<b class="nc"><i>2106</i>&nbsp;                    bigDecimalResult = bigDecimalResult.divide(getBigDecimalMultiplier(), roundingMode);</b>
<i>2107</i>&nbsp;                }
<b class="nc"><i>2108</i>&nbsp;            }</b>
<i>2109</i>&nbsp;
<i>2110</i>&nbsp;            if (!status[STATUS_POSITIVE]) {
<i>2111</i>&nbsp;                bigDecimalResult = bigDecimalResult.negate();
<i>2112</i>&nbsp;            }
<i>2113</i>&nbsp;            return bigDecimalResult;
<i>2114</i>&nbsp;        } else {
<i>2115</i>&nbsp;            boolean gotDouble = true;
<b class="nc"><i>2116</i>&nbsp;            boolean gotLongMinimum = false;</b>
<b class="nc"><i>2117</i>&nbsp;            double  doubleResult = 0.0;</b>
<i>2118</i>&nbsp;            long    longResult = 0;
<b class="nc"><i>2119</i>&nbsp;</b>
<i>2120</i>&nbsp;            // Finally, have DigitList parse the digits into a value.
<i>2121</i>&nbsp;            if (digitList.fitsIntoLong(status[STATUS_POSITIVE], isParseIntegerOnly())) {
<i>2122</i>&nbsp;                gotDouble = false;
<i>2123</i>&nbsp;                longResult = digitList.getLong();
<i>2124</i>&nbsp;                if (longResult &lt; 0) {  // got Long.MIN_VALUE
<i>2125</i>&nbsp;                    gotLongMinimum = true;
<i>2126</i>&nbsp;                }
<i>2127</i>&nbsp;            } else {
<i>2128</i>&nbsp;                doubleResult = digitList.getDouble();
<i>2129</i>&nbsp;            }
<i>2130</i>&nbsp;
<i>2131</i>&nbsp;            // Divide by multiplier. We have to be careful here not to do
<i>2132</i>&nbsp;            // unneeded conversions between double and long.
<i>2133</i>&nbsp;            if (multiplier != 1) {
<i>2134</i>&nbsp;                if (gotDouble) {
<i>2135</i>&nbsp;                    doubleResult /= multiplier;
<i>2136</i>&nbsp;                } else {
<i>2137</i>&nbsp;                    // Avoid converting to double if we can
<i>2138</i>&nbsp;                    if (longResult % multiplier == 0) {
<i>2139</i>&nbsp;                        longResult /= multiplier;
<i>2140</i>&nbsp;                    } else {
<i>2141</i>&nbsp;                        doubleResult = ((double)longResult) / multiplier;
<i>2142</i>&nbsp;                        gotDouble = true;
<b class="nc"><i>2143</i>&nbsp;                    }</b>
<b class="nc"><i>2144</i>&nbsp;                }</b>
<i>2145</i>&nbsp;            }
<i>2146</i>&nbsp;
<i>2147</i>&nbsp;            if (!status[STATUS_POSITIVE] &amp;&amp; !gotLongMinimum) {
<i>2148</i>&nbsp;                doubleResult = -doubleResult;
<b class="nc"><i>2149</i>&nbsp;                longResult = -longResult;</b>
<b class="nc"><i>2150</i>&nbsp;            }</b>
<b class="nc"><i>2151</i>&nbsp;</b>
<b class="nc"><i>2152</i>&nbsp;            // At this point, if we divided the result by the multiplier, the</b>
<i>2153</i>&nbsp;            // result may fit into a long.  We check for this case and return
<b class="nc"><i>2154</i>&nbsp;            // a long if possible.</b>
<b class="nc"><i>2155</i>&nbsp;            // We must do this AFTER applying the negative (if appropriate)</b>
<b class="nc"><i>2156</i>&nbsp;            // in order to handle the case of LONG_MIN; otherwise, if we do</b>
<b class="nc"><i>2157</i>&nbsp;            // this with a positive value -LONG_MIN, the double is &gt; 0, but</b>
<b class="nc"><i>2158</i>&nbsp;            // the long is &lt; 0. We also must retain a double in the case of</b>
<i>2159</i>&nbsp;            // -0.0, which will compare as == to a long 0 cast to a double
<i>2160</i>&nbsp;            // (bug 4162852).
<i>2161</i>&nbsp;            if (multiplier != 1 &amp;&amp; gotDouble) {
<b class="nc"><i>2162</i>&nbsp;                longResult = (long)doubleResult;</b>
<b class="nc"><i>2163</i>&nbsp;                gotDouble = ((doubleResult != (double)longResult) ||</b>
<b class="nc"><i>2164</i>&nbsp;                            (doubleResult == 0.0 &amp;&amp; 1/doubleResult &lt; 0.0)) &amp;&amp;</b>
<b class="nc"><i>2165</i>&nbsp;                            !isParseIntegerOnly();</b>
<i>2166</i>&nbsp;            }
<b class="nc"><i>2167</i>&nbsp;</b>
<b class="nc"><i>2168</i>&nbsp;            // cast inside of ?: because of binary numeric promotion, JLS 15.25</b>
<i>2169</i>&nbsp;            return gotDouble ? (Number)doubleResult : (Number)longResult;
<i>2170</i>&nbsp;        }
<i>2171</i>&nbsp;    }
<b class="nc"><i>2172</i>&nbsp;</b>
<b class="nc"><i>2173</i>&nbsp;    /**</b>
<b class="nc"><i>2174</i>&nbsp;     * Return a BigInteger multiplier.</b>
<b class="nc"><i>2175</i>&nbsp;     */</b>
<b class="nc"><i>2176</i>&nbsp;    private BigInteger getBigIntegerMultiplier() {</b>
<i>2177</i>&nbsp;        if (bigIntegerMultiplier == null) {
<i>2178</i>&nbsp;            bigIntegerMultiplier = BigInteger.valueOf(multiplier);
<i>2179</i>&nbsp;        }
<i>2180</i>&nbsp;        return bigIntegerMultiplier;
<i>2181</i>&nbsp;    }
<i>2182</i>&nbsp;    private transient BigInteger bigIntegerMultiplier;
<i>2183</i>&nbsp;
<i>2184</i>&nbsp;    /**
<b class="nc"><i>2185</i>&nbsp;     * Return a BigDecimal multiplier.</b>
<b class="nc"><i>2186</i>&nbsp;     */</b>
<b class="nc"><i>2187</i>&nbsp;    private BigDecimal getBigDecimalMultiplier() {</b>
<b class="nc"><i>2188</i>&nbsp;        if (bigDecimalMultiplier == null) {</b>
<b class="nc"><i>2189</i>&nbsp;            bigDecimalMultiplier = new BigDecimal(multiplier);</b>
<b class="nc"><i>2190</i>&nbsp;        }</b>
<b class="nc"><i>2191</i>&nbsp;        return bigDecimalMultiplier;</b>
<b class="nc"><i>2192</i>&nbsp;    }</b>
<b class="nc"><i>2193</i>&nbsp;    private transient BigDecimal bigDecimalMultiplier;</b>
<b class="nc"><i>2194</i>&nbsp;</b>
<b class="nc"><i>2195</i>&nbsp;    private static final int STATUS_INFINITE = 0;</b>
<i>2196</i>&nbsp;    private static final int STATUS_POSITIVE = 1;
<i>2197</i>&nbsp;    private static final int STATUS_LENGTH   = 2;
<i>2198</i>&nbsp;
<b class="nc"><i>2199</i>&nbsp;    /**</b>
<i>2200</i>&nbsp;     * Parse the given text into a number.  The text is parsed beginning at
<b class="nc"><i>2201</i>&nbsp;     * parsePosition, until an unparseable character is seen.</b>
<b class="nc"><i>2202</i>&nbsp;     * @param text The string to parse.</b>
<b class="nc"><i>2203</i>&nbsp;     * @param parsePosition The position at which to being parsing.  Upon</b>
<i>2204</i>&nbsp;     * return, the first unparseable character.
<i>2205</i>&nbsp;     * @param digits The DigitList to set to the parsed value.
<i>2206</i>&nbsp;     * @param isExponent If true, parse an exponent.  This means no
<i>2207</i>&nbsp;     * infinite values and integer only.
<i>2208</i>&nbsp;     * @param status Upon return contains boolean status flags indicating
<i>2209</i>&nbsp;     * whether the value was infinite and whether it was positive.
<i>2210</i>&nbsp;     */
<i>2211</i>&nbsp;    private final boolean subparse(String text, ParsePosition parsePosition,
<i>2212</i>&nbsp;                   String positivePrefix, String negativePrefix,
<i>2213</i>&nbsp;                   DigitList digits, boolean isExponent,
<i>2214</i>&nbsp;                   boolean status[]) {
<i>2215</i>&nbsp;        int position = parsePosition.index;
<b class="nc"><i>2216</i>&nbsp;        int oldStart = parsePosition.index;</b>
<b class="nc"><i>2217</i>&nbsp;        int backup;</b>
<b class="nc"><i>2218</i>&nbsp;        boolean gotPositive, gotNegative;</b>
<i>2219</i>&nbsp;
<i>2220</i>&nbsp;        // check for positivePrefix; take longest
<b class="nc"><i>2221</i>&nbsp;        gotPositive = text.regionMatches(position, positivePrefix, 0,</b>
<i>2222</i>&nbsp;                                         positivePrefix.length());
<b class="nc"><i>2223</i>&nbsp;        gotNegative = text.regionMatches(position, negativePrefix, 0,</b>
<b class="nc"><i>2224</i>&nbsp;                                         negativePrefix.length());</b>
<i>2225</i>&nbsp;
<i>2226</i>&nbsp;        if (gotPositive &amp;&amp; gotNegative) {
<b class="nc"><i>2227</i>&nbsp;            if (positivePrefix.length() &gt; negativePrefix.length()) {</b>
<i>2228</i>&nbsp;                gotNegative = false;
<b class="nc"><i>2229</i>&nbsp;            } else if (positivePrefix.length() &lt; negativePrefix.length()) {</b>
<b class="nc"><i>2230</i>&nbsp;                gotPositive = false;</b>
<i>2231</i>&nbsp;            }
<i>2232</i>&nbsp;        }
<i>2233</i>&nbsp;
<i>2234</i>&nbsp;        if (gotPositive) {
<i>2235</i>&nbsp;            position += positivePrefix.length();
<i>2236</i>&nbsp;        } else if (gotNegative) {
<b class="nc"><i>2237</i>&nbsp;            position += negativePrefix.length();</b>
<i>2238</i>&nbsp;        } else {
<b class="nc"><i>2239</i>&nbsp;            parsePosition.errorIndex = position;</b>
<b class="nc"><i>2240</i>&nbsp;            return false;</b>
<i>2241</i>&nbsp;        }
<b class="nc"><i>2242</i>&nbsp;</b>
<b class="nc"><i>2243</i>&nbsp;        // process digits or Inf, find decimal position</b>
<b class="nc"><i>2244</i>&nbsp;        status[STATUS_INFINITE] = false;</b>
<b class="nc"><i>2245</i>&nbsp;        if (!isExponent &amp;&amp; text.regionMatches(position,symbols.getInfinity(),0,</b>
<i>2246</i>&nbsp;                          symbols.getInfinity().length())) {
<i>2247</i>&nbsp;            position += symbols.getInfinity().length();
<b class="nc"><i>2248</i>&nbsp;            status[STATUS_INFINITE] = true;</b>
<b class="nc"><i>2249</i>&nbsp;        } else {</b>
<i>2250</i>&nbsp;            // We now have a string of digits, possibly with grouping symbols,
<i>2251</i>&nbsp;            // and decimal points.  We want to process these into a DigitList.
<b class="nc"><i>2252</i>&nbsp;            // We don&#39;t want to put a bunch of leading zeros into the DigitList</b>
<b class="nc"><i>2253</i>&nbsp;            // though, so we keep track of the location of the decimal point,</b>
<i>2254</i>&nbsp;            // put only significant digits into the DigitList, and adjust the
<b class="nc"><i>2255</i>&nbsp;            // exponent as needed.</b>
<b class="nc"><i>2256</i>&nbsp;</b>
<b class="nc"><i>2257</i>&nbsp;            digits.decimalAt = digits.count = 0;</b>
<b class="nc"><i>2258</i>&nbsp;            char zero = symbols.getZeroDigit();</b>
<b class="nc"><i>2259</i>&nbsp;            char decimal = isCurrencyFormat ?</b>
<i>2260</i>&nbsp;                symbols.getMonetaryDecimalSeparator() :
<i>2261</i>&nbsp;                symbols.getDecimalSeparator();
<i>2262</i>&nbsp;            char grouping = symbols.getGroupingSeparator();
<i>2263</i>&nbsp;            String exponentString = symbols.getExponentSeparator();
<b class="nc"><i>2264</i>&nbsp;            boolean sawDecimal = false;</b>
<b class="nc"><i>2265</i>&nbsp;            boolean sawExponent = false;</b>
<i>2266</i>&nbsp;            boolean sawDigit = false;
<i>2267</i>&nbsp;            int exponent = 0; // Set to the exponent value, if any
<b class="nc"><i>2268</i>&nbsp;</b>
<b class="nc"><i>2269</i>&nbsp;            // We have to track digitCount ourselves, because digits.count will</b>
<b class="nc"><i>2270</i>&nbsp;            // pin when the maximum allowable digits is reached.</b>
<i>2271</i>&nbsp;            int digitCount = 0;
<b class="nc"><i>2272</i>&nbsp;</b>
<b class="nc"><i>2273</i>&nbsp;            backup = -1;</b>
<b class="nc"><i>2274</i>&nbsp;            for (; position &lt; text.length(); ++position) {</b>
<b class="nc"><i>2275</i>&nbsp;                char ch = text.charAt(position);</b>
<b class="nc"><i>2276</i>&nbsp;</b>
<b class="nc"><i>2277</i>&nbsp;                /* We recognize all digit ranges, not only the Latin digit range</b>
<i>2278</i>&nbsp;                 * &#39;0&#39;..&#39;9&#39;.  We do so by using the Character.digit() method,
<b class="nc"><i>2279</i>&nbsp;                 * which converts a valid Unicode digit to the range 0..9.</b>
<i>2280</i>&nbsp;                 *
<i>2281</i>&nbsp;                 * The character &#39;ch&#39; may be a digit.  If so, place its value
<i>2282</i>&nbsp;                 * from 0 to 9 in &#39;digit&#39;.  First try using the locale digit,
<i>2283</i>&nbsp;                 * which may or MAY NOT be a standard Unicode digit range.  If
<i>2284</i>&nbsp;                 * this fails, try using the standard Unicode digit ranges by
<i>2285</i>&nbsp;                 * calling Character.digit().  If this also fails, digit will
<i>2286</i>&nbsp;                 * have a value outside the range 0..9.
<b class="nc"><i>2287</i>&nbsp;                 */</b>
<b class="nc"><i>2288</i>&nbsp;                int digit = ch - zero;</b>
<i>2289</i>&nbsp;                if (digit &lt; 0 || digit &gt; 9) {
<i>2290</i>&nbsp;                    digit = Character.digit(ch, 10);
<i>2291</i>&nbsp;                }
<b class="nc"><i>2292</i>&nbsp;</b>
<b class="nc"><i>2293</i>&nbsp;                if (digit == 0) {</b>
<i>2294</i>&nbsp;                    // Cancel out backup setting (see grouping handler below)
<i>2295</i>&nbsp;                    backup = -1; // Do this BEFORE continue statement below!!!
<i>2296</i>&nbsp;                    sawDigit = true;
<b class="nc"><i>2297</i>&nbsp;</b>
<i>2298</i>&nbsp;                    // Handle leading zeros
<i>2299</i>&nbsp;                    if (digits.count == 0) {
<i>2300</i>&nbsp;                        // Ignore leading zeros in integer part of number.
<i>2301</i>&nbsp;                        if (!sawDecimal) {
<i>2302</i>&nbsp;                            continue;
<b class="nc"><i>2303</i>&nbsp;                        }</b>
<b class="nc"><i>2304</i>&nbsp;</b>
<b class="nc"><i>2305</i>&nbsp;                        // If we have seen the decimal, but no significant</b>
<b class="nc"><i>2306</i>&nbsp;                        // digits yet, then we account for leading zeros by</b>
<i>2307</i>&nbsp;                        // decrementing the digits.decimalAt into negative
<i>2308</i>&nbsp;                        // values.
<i>2309</i>&nbsp;                        --digits.decimalAt;
<i>2310</i>&nbsp;                    } else {
<b class="nc"><i>2311</i>&nbsp;                        ++digitCount;</b>
<b class="nc"><i>2312</i>&nbsp;                        digits.append((char)(digit + &#39;0&#39;));</b>
<b class="nc"><i>2313</i>&nbsp;                    }</b>
<b class="nc"><i>2314</i>&nbsp;                } else if (digit &gt; 0 &amp;&amp; digit &lt;= 9) { // [sic] digit==0 handled above</b>
<i>2315</i>&nbsp;                    sawDigit = true;
<b class="nc"><i>2316</i>&nbsp;                    ++digitCount;</b>
<b class="nc"><i>2317</i>&nbsp;                    digits.append((char)(digit + &#39;0&#39;));</b>
<b class="nc"><i>2318</i>&nbsp;</b>
<i>2319</i>&nbsp;                    // Cancel out backup setting (see grouping handler below)
<i>2320</i>&nbsp;                    backup = -1;
<i>2321</i>&nbsp;                } else if (!isExponent &amp;&amp; ch == decimal) {
<b class="nc"><i>2322</i>&nbsp;                    // If we&#39;re only parsing integers, or if we ALREADY saw the</b>
<b class="nc"><i>2323</i>&nbsp;                    // decimal, then don&#39;t parse this one.</b>
<b class="nc"><i>2324</i>&nbsp;                    if (isParseIntegerOnly() || sawDecimal) {</b>
<b class="nc"><i>2325</i>&nbsp;                        break;</b>
<b class="nc"><i>2326</i>&nbsp;                    }</b>
<i>2327</i>&nbsp;                    digits.decimalAt = digitCount; // Not digits.count!
<i>2328</i>&nbsp;                    sawDecimal = true;
<i>2329</i>&nbsp;                } else if (!isExponent &amp;&amp; ch == grouping &amp;&amp; isGroupingUsed()) {
<i>2330</i>&nbsp;                    if (sawDecimal) {
<b class="nc"><i>2331</i>&nbsp;                        break;</b>
<b class="nc"><i>2332</i>&nbsp;                    }</b>
<b class="nc"><i>2333</i>&nbsp;                    // Ignore grouping characters, if we are using them, but</b>
<i>2334</i>&nbsp;                    // require that they be followed by a digit.  Otherwise
<i>2335</i>&nbsp;                    // we backup and reprocess them.
<b class="nc"><i>2336</i>&nbsp;                    backup = position;</b>
<b class="nc"><i>2337</i>&nbsp;                } else if (!isExponent &amp;&amp; text.regionMatches(position, exponentString, 0, exponentString.length())</b>
<i>2338</i>&nbsp;                             &amp;&amp; !sawExponent) {
<b class="nc"><i>2339</i>&nbsp;                    // Process the exponent by recursively calling this method.</b>
<i>2340</i>&nbsp;                     ParsePosition pos = new ParsePosition(position + exponentString.length());
<i>2341</i>&nbsp;                    boolean[] stat = new boolean[STATUS_LENGTH];
<b class="nc"><i>2342</i>&nbsp;                    DigitList exponentDigits = new DigitList();</b>
<b class="nc"><i>2343</i>&nbsp;</b>
<b class="nc"><i>2344</i>&nbsp;                    if (subparse(text, pos, &quot;&quot;, Character.toString(symbols.getMinusSign()), exponentDigits, true, stat) &amp;&amp;</b>
<b class="nc"><i>2345</i>&nbsp;                        exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {</b>
<i>2346</i>&nbsp;                        position = pos.index; // Advance past the exponent
<b class="nc"><i>2347</i>&nbsp;                        exponent = (int)exponentDigits.getLong();</b>
<i>2348</i>&nbsp;                        if (!stat[STATUS_POSITIVE]) {
<i>2349</i>&nbsp;                            exponent = -exponent;
<i>2350</i>&nbsp;                        }
<i>2351</i>&nbsp;                        sawExponent = true;
<i>2352</i>&nbsp;                    }
<i>2353</i>&nbsp;                    break; // Whether we fail or succeed, we exit this loop
<i>2354</i>&nbsp;                } else {
<i>2355</i>&nbsp;                    break;
<i>2356</i>&nbsp;                }
<i>2357</i>&nbsp;            }
<i>2358</i>&nbsp;
<b class="nc"><i>2359</i>&nbsp;            if (backup != -1) {</b>
<b class="nc"><i>2360</i>&nbsp;                position = backup;</b>
<b class="nc"><i>2361</i>&nbsp;            }</b>
<i>2362</i>&nbsp;
<i>2363</i>&nbsp;            // If there was no decimal point we have an integer
<i>2364</i>&nbsp;            if (!sawDecimal) {
<i>2365</i>&nbsp;                digits.decimalAt = digitCount; // Not digits.count!
<i>2366</i>&nbsp;            }
<i>2367</i>&nbsp;
<i>2368</i>&nbsp;            // Adjust for exponent, if any
<i>2369</i>&nbsp;            digits.decimalAt += exponent;
<i>2370</i>&nbsp;
<i>2371</i>&nbsp;            // If none of the text string was recognized.  For example, parse
<i>2372</i>&nbsp;            // &quot;x&quot; with pattern &quot;#0.00&quot; (return index and error index both 0)
<i>2373</i>&nbsp;            // parse &quot;$&quot; with pattern &quot;$#0.00&quot;. (return index 0 and error
<i>2374</i>&nbsp;            // index 1).
<b class="nc"><i>2375</i>&nbsp;            if (!sawDigit &amp;&amp; digitCount == 0) {</b>
<b class="nc"><i>2376</i>&nbsp;                parsePosition.index = oldStart;</b>
<b class="nc"><i>2377</i>&nbsp;                parsePosition.errorIndex = oldStart;</b>
<b class="nc"><i>2378</i>&nbsp;                return false;</b>
<i>2379</i>&nbsp;            }
<b class="nc"><i>2380</i>&nbsp;        }</b>
<i>2381</i>&nbsp;
<i>2382</i>&nbsp;        // check for suffix
<i>2383</i>&nbsp;        if (!isExponent) {
<i>2384</i>&nbsp;            if (gotPositive) {
<i>2385</i>&nbsp;                gotPositive = text.regionMatches(position,positiveSuffix,0,
<i>2386</i>&nbsp;                                                 positiveSuffix.length());
<i>2387</i>&nbsp;            }
<i>2388</i>&nbsp;            if (gotNegative) {
<i>2389</i>&nbsp;                gotNegative = text.regionMatches(position,negativeSuffix,0,
<b class="nc"><i>2390</i>&nbsp;                                                 negativeSuffix.length());</b>
<i>2391</i>&nbsp;            }
<i>2392</i>&nbsp;
<i>2393</i>&nbsp;        // if both match, take longest
<i>2394</i>&nbsp;        if (gotPositive &amp;&amp; gotNegative) {
<i>2395</i>&nbsp;            if (positiveSuffix.length() &gt; negativeSuffix.length()) {
<i>2396</i>&nbsp;                gotNegative = false;
<i>2397</i>&nbsp;            } else if (positiveSuffix.length() &lt; negativeSuffix.length()) {
<i>2398</i>&nbsp;                gotPositive = false;
<i>2399</i>&nbsp;            }
<b class="nc"><i>2400</i>&nbsp;        }</b>
<b class="nc"><i>2401</i>&nbsp;</b>
<b class="nc"><i>2402</i>&nbsp;        // fail if neither or both</b>
<b class="nc"><i>2403</i>&nbsp;        if (gotPositive == gotNegative) {</b>
<i>2404</i>&nbsp;            parsePosition.errorIndex = position;
<i>2405</i>&nbsp;            return false;
<i>2406</i>&nbsp;        }
<i>2407</i>&nbsp;
<i>2408</i>&nbsp;        parsePosition.index = position +
<i>2409</i>&nbsp;            (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); // mark success!
<i>2410</i>&nbsp;        } else {
<i>2411</i>&nbsp;            parsePosition.index = position;
<i>2412</i>&nbsp;        }
<i>2413</i>&nbsp;
<i>2414</i>&nbsp;        status[STATUS_POSITIVE] = gotPositive;
<b class="nc"><i>2415</i>&nbsp;        if (parsePosition.index == oldStart) {</b>
<b class="nc"><i>2416</i>&nbsp;            parsePosition.errorIndex = position;</b>
<b class="nc"><i>2417</i>&nbsp;            return false;</b>
<i>2418</i>&nbsp;        }
<b class="nc"><i>2419</i>&nbsp;        return true;</b>
<i>2420</i>&nbsp;    }
<i>2421</i>&nbsp;
<b class="nc"><i>2422</i>&nbsp;    /**</b>
<i>2423</i>&nbsp;     * Returns a copy of the decimal format symbols, which is generally not
<i>2424</i>&nbsp;     * changed by the programmer or user.
<i>2425</i>&nbsp;     * @return a copy of the desired DecimalFormatSymbols
<i>2426</i>&nbsp;     * @see java.text.DecimalFormatSymbols
<i>2427</i>&nbsp;     */
<i>2428</i>&nbsp;    public DecimalFormatSymbols getDecimalFormatSymbols() {
<i>2429</i>&nbsp;        try {
<i>2430</i>&nbsp;            // don&#39;t allow multiple references
<i>2431</i>&nbsp;            return (DecimalFormatSymbols) symbols.clone();
<b class="nc"><i>2432</i>&nbsp;        } catch (Exception foo) {</b>
<i>2433</i>&nbsp;            return null; // should never happen
<i>2434</i>&nbsp;        }
<i>2435</i>&nbsp;    }
<i>2436</i>&nbsp;
<i>2437</i>&nbsp;
<i>2438</i>&nbsp;    /**
<i>2439</i>&nbsp;     * Sets the decimal format symbols, which is generally not changed
<i>2440</i>&nbsp;     * by the programmer or user.
<i>2441</i>&nbsp;     * @param newSymbols desired DecimalFormatSymbols
<b class="nc"><i>2442</i>&nbsp;     * @see java.text.DecimalFormatSymbols</b>
<b class="nc"><i>2443</i>&nbsp;     */</b>
<b class="nc"><i>2444</i>&nbsp;    public void setDecimalFormatSymbols(DecimalFormatSymbols newSymbols) {</b>
<i>2445</i>&nbsp;        try {
<i>2446</i>&nbsp;            // don&#39;t allow multiple references
<i>2447</i>&nbsp;            symbols = (DecimalFormatSymbols) newSymbols.clone();
<i>2448</i>&nbsp;            expandAffixes();
<i>2449</i>&nbsp;            fastPathCheckNeeded = true;
<i>2450</i>&nbsp;        } catch (Exception foo) {
<i>2451</i>&nbsp;            // should never happen
<i>2452</i>&nbsp;        }
<i>2453</i>&nbsp;    }
<i>2454</i>&nbsp;
<i>2455</i>&nbsp;    /**
<b class="nc"><i>2456</i>&nbsp;     * Get the positive prefix.</b>
<b class="nc"><i>2457</i>&nbsp;     * &lt;P&gt;Examples: +123, $123, sFr123</b>
<b class="nc"><i>2458</i>&nbsp;     *</b>
<i>2459</i>&nbsp;     * @return the positive prefix
<b class="nc"><i>2460</i>&nbsp;     */</b>
<i>2461</i>&nbsp;    public String getPositivePrefix () {
<i>2462</i>&nbsp;        return positivePrefix;
<b class="nc"><i>2463</i>&nbsp;    }</b>
<i>2464</i>&nbsp;
<i>2465</i>&nbsp;    /**
<i>2466</i>&nbsp;     * Set the positive prefix.
<i>2467</i>&nbsp;     * &lt;P&gt;Examples: +123, $123, sFr123
<i>2468</i>&nbsp;     *
<i>2469</i>&nbsp;     * @param newValue the new positive prefix
<i>2470</i>&nbsp;     */
<i>2471</i>&nbsp;    public void setPositivePrefix (String newValue) {
<i>2472</i>&nbsp;        positivePrefix = newValue;
<b class="nc"><i>2473</i>&nbsp;        posPrefixPattern = null;</b>
<i>2474</i>&nbsp;        positivePrefixFieldPositions = null;
<i>2475</i>&nbsp;        fastPathCheckNeeded = true;
<i>2476</i>&nbsp;    }
<i>2477</i>&nbsp;
<i>2478</i>&nbsp;    /**
<i>2479</i>&nbsp;     * Returns the FieldPositions of the fields in the prefix used for
<i>2480</i>&nbsp;     * positive numbers. This is not used if the user has explicitly set
<i>2481</i>&nbsp;     * a positive prefix via &lt;code&gt;setPositivePrefix&lt;/code&gt;. This is
<i>2482</i>&nbsp;     * lazily created.
<b class="nc"><i>2483</i>&nbsp;     *</b>
<b class="nc"><i>2484</i>&nbsp;     * @return FieldPositions in positive prefix</b>
<b class="nc"><i>2485</i>&nbsp;     */</b>
<i>2486</i>&nbsp;    private FieldPosition[] getPositivePrefixFieldPositions() {
<i>2487</i>&nbsp;        if (positivePrefixFieldPositions == null) {
<i>2488</i>&nbsp;            if (posPrefixPattern != null) {
<i>2489</i>&nbsp;                positivePrefixFieldPositions = expandAffix(posPrefixPattern);
<i>2490</i>&nbsp;            } else {
<i>2491</i>&nbsp;                positivePrefixFieldPositions = EmptyFieldPositionArray;
<i>2492</i>&nbsp;            }
<i>2493</i>&nbsp;        }
<i>2494</i>&nbsp;        return positivePrefixFieldPositions;
<i>2495</i>&nbsp;    }
<i>2496</i>&nbsp;
<b class="nc"><i>2497</i>&nbsp;    /**</b>
<b class="nc"><i>2498</i>&nbsp;     * Get the negative prefix.</b>
<b class="nc"><i>2499</i>&nbsp;     * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123</b>
<i>2500</i>&nbsp;     *
<b class="nc"><i>2501</i>&nbsp;     * @return the negative prefix</b>
<i>2502</i>&nbsp;     */
<i>2503</i>&nbsp;    public String getNegativePrefix () {
<b class="nc"><i>2504</i>&nbsp;        return negativePrefix;</b>
<i>2505</i>&nbsp;    }
<i>2506</i>&nbsp;
<i>2507</i>&nbsp;    /**
<i>2508</i>&nbsp;     * Set the negative prefix.
<i>2509</i>&nbsp;     * &lt;P&gt;Examples: -123, ($123) (with negative suffix), sFr-123
<i>2510</i>&nbsp;     *
<i>2511</i>&nbsp;     * @param newValue the new negative prefix
<i>2512</i>&nbsp;     */
<i>2513</i>&nbsp;    public void setNegativePrefix (String newValue) {
<b class="nc"><i>2514</i>&nbsp;        negativePrefix = newValue;</b>
<i>2515</i>&nbsp;        negPrefixPattern = null;
<i>2516</i>&nbsp;        fastPathCheckNeeded = true;
<i>2517</i>&nbsp;    }
<i>2518</i>&nbsp;
<i>2519</i>&nbsp;    /**
<i>2520</i>&nbsp;     * Returns the FieldPositions of the fields in the prefix used for
<i>2521</i>&nbsp;     * negative numbers. This is not used if the user has explicitly set
<i>2522</i>&nbsp;     * a negative prefix via &lt;code&gt;setNegativePrefix&lt;/code&gt;. This is
<i>2523</i>&nbsp;     * lazily created.
<b class="nc"><i>2524</i>&nbsp;     *</b>
<b class="nc"><i>2525</i>&nbsp;     * @return FieldPositions in positive prefix</b>
<b class="nc"><i>2526</i>&nbsp;     */</b>
<i>2527</i>&nbsp;    private FieldPosition[] getNegativePrefixFieldPositions() {
<i>2528</i>&nbsp;        if (negativePrefixFieldPositions == null) {
<i>2529</i>&nbsp;            if (negPrefixPattern != null) {
<i>2530</i>&nbsp;                negativePrefixFieldPositions = expandAffix(negPrefixPattern);
<i>2531</i>&nbsp;            } else {
<i>2532</i>&nbsp;                negativePrefixFieldPositions = EmptyFieldPositionArray;
<i>2533</i>&nbsp;            }
<i>2534</i>&nbsp;        }
<i>2535</i>&nbsp;        return negativePrefixFieldPositions;
<i>2536</i>&nbsp;    }
<i>2537</i>&nbsp;
<b class="nc"><i>2538</i>&nbsp;    /**</b>
<b class="nc"><i>2539</i>&nbsp;     * Get the positive suffix.</b>
<b class="nc"><i>2540</i>&nbsp;     * &lt;P&gt;Example: 123%</b>
<i>2541</i>&nbsp;     *
<b class="nc"><i>2542</i>&nbsp;     * @return the positive suffix</b>
<i>2543</i>&nbsp;     */
<i>2544</i>&nbsp;    public String getPositiveSuffix () {
<b class="nc"><i>2545</i>&nbsp;        return positiveSuffix;</b>
<i>2546</i>&nbsp;    }
<i>2547</i>&nbsp;
<i>2548</i>&nbsp;    /**
<i>2549</i>&nbsp;     * Set the positive suffix.
<i>2550</i>&nbsp;     * &lt;P&gt;Example: 123%
<i>2551</i>&nbsp;     *
<i>2552</i>&nbsp;     * @param newValue the new positive suffix
<i>2553</i>&nbsp;     */
<i>2554</i>&nbsp;    public void setPositiveSuffix (String newValue) {
<i>2555</i>&nbsp;        positiveSuffix = newValue;
<b class="nc"><i>2556</i>&nbsp;        posSuffixPattern = null;</b>
<i>2557</i>&nbsp;        fastPathCheckNeeded = true;
<i>2558</i>&nbsp;    }
<i>2559</i>&nbsp;
<i>2560</i>&nbsp;    /**
<i>2561</i>&nbsp;     * Returns the FieldPositions of the fields in the suffix used for
<i>2562</i>&nbsp;     * positive numbers. This is not used if the user has explicitly set
<i>2563</i>&nbsp;     * a positive suffix via &lt;code&gt;setPositiveSuffix&lt;/code&gt;. This is
<i>2564</i>&nbsp;     * lazily created.
<i>2565</i>&nbsp;     *
<i>2566</i>&nbsp;     * @return FieldPositions in positive prefix
<i>2567</i>&nbsp;     */
<i>2568</i>&nbsp;    private FieldPosition[] getPositiveSuffixFieldPositions() {
<i>2569</i>&nbsp;        if (positiveSuffixFieldPositions == null) {
<i>2570</i>&nbsp;            if (posSuffixPattern != null) {
<i>2571</i>&nbsp;                positiveSuffixFieldPositions = expandAffix(posSuffixPattern);
<i>2572</i>&nbsp;            } else {
<i>2573</i>&nbsp;                positiveSuffixFieldPositions = EmptyFieldPositionArray;
<b class="nc"><i>2574</i>&nbsp;            }</b>
<b class="nc"><i>2575</i>&nbsp;        }</b>
<b class="nc"><i>2576</i>&nbsp;        return positiveSuffixFieldPositions;</b>
<b class="nc"><i>2577</i>&nbsp;    }</b>
<i>2578</i>&nbsp;
<i>2579</i>&nbsp;    /**
<i>2580</i>&nbsp;     * Get the negative suffix.
<i>2581</i>&nbsp;     * &lt;P&gt;Examples: -123%, ($123) (with positive suffixes)
<i>2582</i>&nbsp;     *
<i>2583</i>&nbsp;     * @return the negative suffix
<i>2584</i>&nbsp;     */
<b class="nc"><i>2585</i>&nbsp;    public String getNegativeSuffix () {</b>
<b class="nc"><i>2586</i>&nbsp;        return negativeSuffix;</b>
<i>2587</i>&nbsp;    }
<i>2588</i>&nbsp;
<i>2589</i>&nbsp;    /**
<i>2590</i>&nbsp;     * Set the negative suffix.
<i>2591</i>&nbsp;     * &lt;P&gt;Examples: 123%
<i>2592</i>&nbsp;     *
<i>2593</i>&nbsp;     * @param newValue the new negative suffix
<i>2594</i>&nbsp;     */
<i>2595</i>&nbsp;    public void setNegativeSuffix (String newValue) {
<i>2596</i>&nbsp;        negativeSuffix = newValue;
<i>2597</i>&nbsp;        negSuffixPattern = null;
<i>2598</i>&nbsp;        fastPathCheckNeeded = true;
<i>2599</i>&nbsp;    }
<b class="nc"><i>2600</i>&nbsp;</b>
<i>2601</i>&nbsp;    /**
<i>2602</i>&nbsp;     * Returns the FieldPositions of the fields in the suffix used for
<i>2603</i>&nbsp;     * negative numbers. This is not used if the user has explicitly set
<i>2604</i>&nbsp;     * a negative suffix via &lt;code&gt;setNegativeSuffix&lt;/code&gt;. This is
<i>2605</i>&nbsp;     * lazily created.
<i>2606</i>&nbsp;     *
<i>2607</i>&nbsp;     * @return FieldPositions in positive prefix
<i>2608</i>&nbsp;     */
<i>2609</i>&nbsp;    private FieldPosition[] getNegativeSuffixFieldPositions() {
<i>2610</i>&nbsp;        if (negativeSuffixFieldPositions == null) {
<i>2611</i>&nbsp;            if (negSuffixPattern != null) {
<i>2612</i>&nbsp;                negativeSuffixFieldPositions = expandAffix(negSuffixPattern);
<i>2613</i>&nbsp;            } else {
<i>2614</i>&nbsp;                negativeSuffixFieldPositions = EmptyFieldPositionArray;
<i>2615</i>&nbsp;            }
<b class="nc"><i>2616</i>&nbsp;        }</b>
<b class="nc"><i>2617</i>&nbsp;        return negativeSuffixFieldPositions;</b>
<i>2618</i>&nbsp;    }
<i>2619</i>&nbsp;
<i>2620</i>&nbsp;    /**
<i>2621</i>&nbsp;     * Gets the multiplier for use in percent, per mille, and similar
<i>2622</i>&nbsp;     * formats.
<i>2623</i>&nbsp;     *
<i>2624</i>&nbsp;     * @return the multiplier
<i>2625</i>&nbsp;     * @see #setMultiplier(int)
<i>2626</i>&nbsp;     */
<i>2627</i>&nbsp;    public int getMultiplier () {
<i>2628</i>&nbsp;        return multiplier;
<b class="nc"><i>2629</i>&nbsp;    }</b>
<i>2630</i>&nbsp;
<i>2631</i>&nbsp;    /**
<i>2632</i>&nbsp;     * Sets the multiplier for use in percent, per mille, and similar
<i>2633</i>&nbsp;     * formats.
<i>2634</i>&nbsp;     * For a percent format, set the multiplier to 100 and the suffixes to
<i>2635</i>&nbsp;     * have &#39;%&#39; (for Arabic, use the Arabic percent sign).
<i>2636</i>&nbsp;     * For a per mille format, set the multiplier to 1000 and the suffixes to
<i>2637</i>&nbsp;     * have &#39;&amp;#92;u2030&#39;.
<i>2638</i>&nbsp;     *
<i>2639</i>&nbsp;     * &lt;P&gt;Example: with multiplier 100, 1.23 is formatted as &quot;123&quot;, and
<i>2640</i>&nbsp;     * &quot;123&quot; is parsed into 1.23.
<b class="nc"><i>2641</i>&nbsp;     *</b>
<b class="nc"><i>2642</i>&nbsp;     * @param newValue the new multiplier</b>
<i>2643</i>&nbsp;     * @see #getMultiplier
<i>2644</i>&nbsp;     */
<i>2645</i>&nbsp;    public void setMultiplier (int newValue) {
<i>2646</i>&nbsp;        multiplier = newValue;
<i>2647</i>&nbsp;        bigDecimalMultiplier = null;
<i>2648</i>&nbsp;        bigIntegerMultiplier = null;
<i>2649</i>&nbsp;        fastPathCheckNeeded = true;
<i>2650</i>&nbsp;    }
<i>2651</i>&nbsp;
<i>2652</i>&nbsp;    /**
<i>2653</i>&nbsp;     * {@inheritDoc}
<i>2654</i>&nbsp;     */
<b class="nc"><i>2655</i>&nbsp;    @Override</b>
<i>2656</i>&nbsp;    public void setGroupingUsed(boolean newValue) {
<i>2657</i>&nbsp;        super.setGroupingUsed(newValue);
<i>2658</i>&nbsp;        fastPathCheckNeeded = true;
<i>2659</i>&nbsp;    }
<i>2660</i>&nbsp;
<i>2661</i>&nbsp;    /**
<i>2662</i>&nbsp;     * Return the grouping size. Grouping size is the number of digits between
<i>2663</i>&nbsp;     * grouping separators in the integer portion of a number.  For example,
<i>2664</i>&nbsp;     * in the number &quot;123,456.78&quot;, the grouping size is 3.
<i>2665</i>&nbsp;     *
<i>2666</i>&nbsp;     * @return the grouping size
<i>2667</i>&nbsp;     * @see #setGroupingSize
<b class="nc"><i>2668</i>&nbsp;     * @see java.text.NumberFormat#isGroupingUsed</b>
<i>2669</i>&nbsp;     * @see java.text.DecimalFormatSymbols#getGroupingSeparator
<i>2670</i>&nbsp;     */
<i>2671</i>&nbsp;    public int getGroupingSize () {
<i>2672</i>&nbsp;        return groupingSize;
<i>2673</i>&nbsp;    }
<i>2674</i>&nbsp;
<i>2675</i>&nbsp;    /**
<b class="nc"><i>2676</i>&nbsp;     * Set the grouping size. Grouping size is the number of digits between</b>
<b class="nc"><i>2677</i>&nbsp;     * grouping separators in the integer portion of a number.  For example,</b>
<b class="nc"><i>2678</i>&nbsp;     * in the number &quot;123,456.78&quot;, the grouping size is 3.</b>
<i>2679</i>&nbsp;     * &lt;br&gt;
<i>2680</i>&nbsp;     * The value passed in is converted to a byte, which may lose information.
<i>2681</i>&nbsp;     *
<i>2682</i>&nbsp;     * @param newValue the new grouping size
<i>2683</i>&nbsp;     * @see #getGroupingSize
<i>2684</i>&nbsp;     * @see java.text.NumberFormat#setGroupingUsed
<i>2685</i>&nbsp;     * @see java.text.DecimalFormatSymbols#setGroupingSeparator
<i>2686</i>&nbsp;     */
<i>2687</i>&nbsp;    public void setGroupingSize (int newValue) {
<i>2688</i>&nbsp;        groupingSize = (byte)newValue;
<b class="nc"><i>2689</i>&nbsp;        fastPathCheckNeeded = true;</b>
<b class="nc"><i>2690</i>&nbsp;    }</b>
<b class="nc"><i>2691</i>&nbsp;</b>
<i>2692</i>&nbsp;    /**
<b class="nc"><i>2693</i>&nbsp;     * Allows you to get the behavior of the decimal separator with integers.</b>
<i>2694</i>&nbsp;     * (The decimal separator will always appear with decimals.)
<i>2695</i>&nbsp;     * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345
<i>2696</i>&nbsp;     *
<i>2697</i>&nbsp;     * @return {@code true} if the decimal separator is always shown;
<i>2698</i>&nbsp;     *         {@code false} otherwise
<i>2699</i>&nbsp;     */
<i>2700</i>&nbsp;    public boolean isDecimalSeparatorAlwaysShown() {
<i>2701</i>&nbsp;        return decimalSeparatorAlwaysShown;
<b class="nc"><i>2702</i>&nbsp;    }</b>
<b class="nc"><i>2703</i>&nbsp;</b>
<b class="nc"><i>2704</i>&nbsp;    /**</b>
<b class="nc"><i>2705</i>&nbsp;     * Allows you to set the behavior of the decimal separator with integers.</b>
<b class="nc"><i>2706</i>&nbsp;     * (The decimal separator will always appear with decimals.)</b>
<b class="nc"><i>2707</i>&nbsp;     * &lt;P&gt;Example: Decimal ON: 12345 &amp;rarr; 12345.; OFF: 12345 &amp;rarr; 12345</b>
<b class="nc"><i>2708</i>&nbsp;     *</b>
<i>2709</i>&nbsp;     * @param newValue {@code true} if the decimal separator is always shown;
<b class="nc"><i>2710</i>&nbsp;     *                 {@code false} otherwise</b>
<i>2711</i>&nbsp;     */
<b class="nc"><i>2712</i>&nbsp;    public void setDecimalSeparatorAlwaysShown(boolean newValue) {</b>
<i>2713</i>&nbsp;        decimalSeparatorAlwaysShown = newValue;
<b class="nc"><i>2714</i>&nbsp;        fastPathCheckNeeded = true;</b>
<i>2715</i>&nbsp;    }
<b class="nc"><i>2716</i>&nbsp;</b>
<i>2717</i>&nbsp;    /**
<b class="nc"><i>2718</i>&nbsp;     * Returns whether the {@link #parse(java.lang.String, java.text.ParsePosition)}</b>
<i>2719</i>&nbsp;     * method returns &lt;code&gt;BigDecimal&lt;/code&gt;. The default value is false.
<b class="nc"><i>2720</i>&nbsp;     *</b>
<i>2721</i>&nbsp;     * @return {@code true} if the parse method returns BigDecimal;
<b class="nc"><i>2722</i>&nbsp;     *         {@code false} otherwise</b>
<i>2723</i>&nbsp;     * @see #setParseBigDecimal
<i>2724</i>&nbsp;     * @since 1.5
<i>2725</i>&nbsp;     */
<i>2726</i>&nbsp;    public boolean isParseBigDecimal() {
<i>2727</i>&nbsp;        return parseBigDecimal;
<i>2728</i>&nbsp;    }
<i>2729</i>&nbsp;
<i>2730</i>&nbsp;    /**
<i>2731</i>&nbsp;     * Sets whether the {@link #parse(java.lang.String, java.text.ParsePosition)}
<i>2732</i>&nbsp;     * method returns &lt;code&gt;BigDecimal&lt;/code&gt;.
<i>2733</i>&nbsp;     *
<i>2734</i>&nbsp;     * @param newValue {@code true} if the parse method returns BigDecimal;
<b class="nc"><i>2735</i>&nbsp;     *                 {@code false} otherwise</b>
<i>2736</i>&nbsp;     * @see #isParseBigDecimal
<i>2737</i>&nbsp;     * @since 1.5
<i>2738</i>&nbsp;     */
<i>2739</i>&nbsp;    public void setParseBigDecimal(boolean newValue) {
<i>2740</i>&nbsp;        parseBigDecimal = newValue;
<i>2741</i>&nbsp;    }
<i>2742</i>&nbsp;
<b class="nc"><i>2743</i>&nbsp;    /**</b>
<i>2744</i>&nbsp;     * Standard override; no change in semantics.
<i>2745</i>&nbsp;     */
<i>2746</i>&nbsp;    @Override
<i>2747</i>&nbsp;    public Object clone() {
<i>2748</i>&nbsp;        DecimalFormat other = (DecimalFormat) super.clone();
<i>2749</i>&nbsp;        other.symbols = (DecimalFormatSymbols) symbols.clone();
<i>2750</i>&nbsp;        other.digitList = (DigitList) digitList.clone();
<i>2751</i>&nbsp;
<i>2752</i>&nbsp;        // Fast-path is almost stateless algorithm. The only logical state is the
<i>2753</i>&nbsp;        // isFastPath flag. In addition fastPathCheckNeeded is a sentinel flag
<i>2754</i>&nbsp;        // that forces recalculation of all fast-path fields when set to true.
<b class="nc"><i>2755</i>&nbsp;        //</b>
<i>2756</i>&nbsp;        // There is thus no need to clone all the fast-path fields.
<i>2757</i>&nbsp;        // We just only need to set fastPathCheckNeeded to true when cloning,
<i>2758</i>&nbsp;        // and init fastPathData to null as if it were a truly new instance.
<i>2759</i>&nbsp;        // Every fast-path field will be recalculated (only once) at next usage of
<i>2760</i>&nbsp;        // fast-path algorithm.
<i>2761</i>&nbsp;        other.fastPathCheckNeeded = true;
<i>2762</i>&nbsp;        other.isFastPath = false;
<i>2763</i>&nbsp;        other.fastPathData = null;
<i>2764</i>&nbsp;
<i>2765</i>&nbsp;        return other;
<b class="nc"><i>2766</i>&nbsp;    }</b>
<i>2767</i>&nbsp;
<i>2768</i>&nbsp;    /**
<i>2769</i>&nbsp;     * Overrides equals
<i>2770</i>&nbsp;     */
<i>2771</i>&nbsp;    @Override
<i>2772</i>&nbsp;    public boolean equals(Object obj)
<i>2773</i>&nbsp;    {
<i>2774</i>&nbsp;        if (obj == null)
<i>2775</i>&nbsp;            return false;
<i>2776</i>&nbsp;        if (!super.equals(obj))
<b class="nc"><i>2777</i>&nbsp;            return false; // super does class check</b>
<b class="nc"><i>2778</i>&nbsp;        DecimalFormat other = (DecimalFormat) obj;</b>
<b class="nc"><i>2779</i>&nbsp;        return ((posPrefixPattern == other.posPrefixPattern &amp;&amp;</b>
<b class="nc"><i>2780</i>&nbsp;                 positivePrefix.equals(other.positivePrefix))</b>
<i>2781</i>&nbsp;                || (posPrefixPattern != null &amp;&amp;
<b class="nc"><i>2782</i>&nbsp;                    posPrefixPattern.equals(other.posPrefixPattern)))</b>
<b class="nc"><i>2783</i>&nbsp;            &amp;&amp; ((posSuffixPattern == other.posSuffixPattern &amp;&amp;</b>
<b class="nc"><i>2784</i>&nbsp;                 positiveSuffix.equals(other.positiveSuffix))</b>
<i>2785</i>&nbsp;                || (posSuffixPattern != null &amp;&amp;
<b class="nc"><i>2786</i>&nbsp;                    posSuffixPattern.equals(other.posSuffixPattern)))</b>
<b class="nc"><i>2787</i>&nbsp;            &amp;&amp; ((negPrefixPattern == other.negPrefixPattern &amp;&amp;</b>
<b class="nc"><i>2788</i>&nbsp;                 negativePrefix.equals(other.negativePrefix))</b>
<i>2789</i>&nbsp;                || (negPrefixPattern != null &amp;&amp;
<b class="nc"><i>2790</i>&nbsp;                    negPrefixPattern.equals(other.negPrefixPattern)))</b>
<b class="nc"><i>2791</i>&nbsp;            &amp;&amp; ((negSuffixPattern == other.negSuffixPattern &amp;&amp;</b>
<b class="nc"><i>2792</i>&nbsp;                 negativeSuffix.equals(other.negativeSuffix))</b>
<i>2793</i>&nbsp;                || (negSuffixPattern != null &amp;&amp;
<i>2794</i>&nbsp;                    negSuffixPattern.equals(other.negSuffixPattern)))
<i>2795</i>&nbsp;            &amp;&amp; multiplier == other.multiplier
<i>2796</i>&nbsp;            &amp;&amp; groupingSize == other.groupingSize
<i>2797</i>&nbsp;            &amp;&amp; decimalSeparatorAlwaysShown == other.decimalSeparatorAlwaysShown
<i>2798</i>&nbsp;            &amp;&amp; parseBigDecimal == other.parseBigDecimal
<i>2799</i>&nbsp;            &amp;&amp; useExponentialNotation == other.useExponentialNotation
<i>2800</i>&nbsp;            &amp;&amp; (!useExponentialNotation ||
<i>2801</i>&nbsp;                minExponentDigits == other.minExponentDigits)
<i>2802</i>&nbsp;            &amp;&amp; maximumIntegerDigits == other.maximumIntegerDigits
<i>2803</i>&nbsp;            &amp;&amp; minimumIntegerDigits == other.minimumIntegerDigits
<i>2804</i>&nbsp;            &amp;&amp; maximumFractionDigits == other.maximumFractionDigits
<i>2805</i>&nbsp;            &amp;&amp; minimumFractionDigits == other.minimumFractionDigits
<i>2806</i>&nbsp;            &amp;&amp; roundingMode == other.roundingMode
<i>2807</i>&nbsp;            &amp;&amp; symbols.equals(other.symbols);
<i>2808</i>&nbsp;    }
<i>2809</i>&nbsp;
<i>2810</i>&nbsp;    /**
<b class="nc"><i>2811</i>&nbsp;     * Overrides hashCode</b>
<b class="nc"><i>2812</i>&nbsp;     */</b>
<b class="nc"><i>2813</i>&nbsp;    @Override</b>
<b class="nc"><i>2814</i>&nbsp;    public int hashCode() {</b>
<b class="nc"><i>2815</i>&nbsp;        return super.hashCode() * 37 + positivePrefix.hashCode();</b>
<b class="nc"><i>2816</i>&nbsp;        // just enough fields for a reasonable distribution</b>
<i>2817</i>&nbsp;    }
<b class="nc"><i>2818</i>&nbsp;</b>
<b class="nc"><i>2819</i>&nbsp;    /**</b>
<b class="nc"><i>2820</i>&nbsp;     * Synthesizes a pattern string that represents the current state</b>
<b class="nc"><i>2821</i>&nbsp;     * of this Format object.</b>
<i>2822</i>&nbsp;     *
<b class="nc"><i>2823</i>&nbsp;     * @return a pattern string</b>
<i>2824</i>&nbsp;     * @see #applyPattern
<b class="nc"><i>2825</i>&nbsp;     */</b>
<i>2826</i>&nbsp;    public String toPattern() {
<b class="nc"><i>2827</i>&nbsp;        return toPattern( false );</b>
<b class="nc"><i>2828</i>&nbsp;    }</b>
<i>2829</i>&nbsp;
<b class="nc"><i>2830</i>&nbsp;    /**</b>
<b class="nc"><i>2831</i>&nbsp;     * Synthesizes a localized pattern string that represents the current</b>
<i>2832</i>&nbsp;     * state of this Format object.
<b class="nc"><i>2833</i>&nbsp;     *</b>
<i>2834</i>&nbsp;     * @return a localized pattern string
<i>2835</i>&nbsp;     * @see #applyPattern
<i>2836</i>&nbsp;     */
<b class="nc"><i>2837</i>&nbsp;    public String toLocalizedPattern() {</b>
<b class="nc"><i>2838</i>&nbsp;        return toPattern( true );</b>
<b class="nc"><i>2839</i>&nbsp;    }</b>
<i>2840</i>&nbsp;
<i>2841</i>&nbsp;    /**
<i>2842</i>&nbsp;     * Expand the affix pattern strings into the expanded affix strings.  If any
<i>2843</i>&nbsp;     * affix pattern string is null, do not expand it.  This method should be
<i>2844</i>&nbsp;     * called any time the symbols or the affix patterns change in order to keep
<i>2845</i>&nbsp;     * the expanded affix strings up to date.
<i>2846</i>&nbsp;     */
<i>2847</i>&nbsp;    private void expandAffixes() {
<i>2848</i>&nbsp;        // Reuse one StringBuffer for better performance
<i>2849</i>&nbsp;        StringBuffer buffer = new StringBuffer();
<i>2850</i>&nbsp;        if (posPrefixPattern != null) {
<i>2851</i>&nbsp;            positivePrefix = expandAffix(posPrefixPattern, buffer);
<i>2852</i>&nbsp;            positivePrefixFieldPositions = null;
<i>2853</i>&nbsp;        }
<i>2854</i>&nbsp;        if (posSuffixPattern != null) {
<i>2855</i>&nbsp;            positiveSuffix = expandAffix(posSuffixPattern, buffer);
<i>2856</i>&nbsp;            positiveSuffixFieldPositions = null;
<i>2857</i>&nbsp;        }
<b class="nc"><i>2858</i>&nbsp;        if (negPrefixPattern != null) {</b>
<b class="nc"><i>2859</i>&nbsp;            negativePrefix = expandAffix(negPrefixPattern, buffer);</b>
<b class="nc"><i>2860</i>&nbsp;            negativePrefixFieldPositions = null;</b>
<b class="nc"><i>2861</i>&nbsp;        }</b>
<b class="nc"><i>2862</i>&nbsp;        if (negSuffixPattern != null) {</b>
<b class="nc"><i>2863</i>&nbsp;            negativeSuffix = expandAffix(negSuffixPattern, buffer);</b>
<b class="nc"><i>2864</i>&nbsp;            negativeSuffixFieldPositions = null;</b>
<b class="nc"><i>2865</i>&nbsp;        }</b>
<b class="nc"><i>2866</i>&nbsp;    }</b>
<i>2867</i>&nbsp;
<i>2868</i>&nbsp;    /**
<b class="nc"><i>2869</i>&nbsp;     * Expand an affix pattern into an affix string.  All characters in the</b>
<b class="nc"><i>2870</i>&nbsp;     * pattern are literal unless prefixed by QUOTE.  The following characters</b>
<b class="nc"><i>2871</i>&nbsp;     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,</b>
<b class="nc"><i>2872</i>&nbsp;     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +</b>
<i>2873</i>&nbsp;     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
<b class="nc"><i>2874</i>&nbsp;     * currency code.  Any other character after a QUOTE represents itself.</b>
<i>2875</i>&nbsp;     * QUOTE must be followed by another character; QUOTE may not occur by
<b class="nc"><i>2876</i>&nbsp;     * itself at the end of the pattern.</b>
<b class="nc"><i>2877</i>&nbsp;     *</b>
<b class="nc"><i>2878</i>&nbsp;     * @param pattern the non-null, possibly empty pattern</b>
<i>2879</i>&nbsp;     * @param buffer a scratch StringBuffer; its contents will be lost
<b class="nc"><i>2880</i>&nbsp;     * @return the expanded equivalent of pattern</b>
<b class="nc"><i>2881</i>&nbsp;     */</b>
<b class="nc"><i>2882</i>&nbsp;    private String expandAffix(String pattern, StringBuffer buffer) {</b>
<b class="nc"><i>2883</i>&nbsp;        buffer.setLength(0);</b>
<b class="nc"><i>2884</i>&nbsp;        for (int i=0; i&lt;pattern.length(); ) {</b>
<b class="nc"><i>2885</i>&nbsp;            char c = pattern.charAt(i++);</b>
<i>2886</i>&nbsp;            if (c == QUOTE) {
<i>2887</i>&nbsp;                c = pattern.charAt(i++);
<b class="nc"><i>2888</i>&nbsp;                switch (c) {</b>
<b class="nc"><i>2889</i>&nbsp;                case CURRENCY_SIGN:</b>
<b class="nc"><i>2890</i>&nbsp;                    if (i&lt;pattern.length() &amp;&amp;</b>
<b class="nc"><i>2891</i>&nbsp;                        pattern.charAt(i) == CURRENCY_SIGN) {</b>
<i>2892</i>&nbsp;                        ++i;
<b class="nc"><i>2893</i>&nbsp;                        buffer.append(symbols.getInternationalCurrencySymbol());</b>
<b class="nc"><i>2894</i>&nbsp;                    } else {</b>
<b class="nc"><i>2895</i>&nbsp;                        buffer.append(symbols.getCurrencySymbol());</b>
<b class="nc"><i>2896</i>&nbsp;                    }</b>
<i>2897</i>&nbsp;                    continue;
<b class="nc"><i>2898</i>&nbsp;                case PATTERN_PERCENT:</b>
<b class="nc"><i>2899</i>&nbsp;                    c = symbols.getPercent();</b>
<b class="nc"><i>2900</i>&nbsp;                    break;</b>
<i>2901</i>&nbsp;                case PATTERN_PER_MILLE:
<i>2902</i>&nbsp;                    c = symbols.getPerMill();
<b class="nc"><i>2903</i>&nbsp;                    break;</b>
<b class="nc"><i>2904</i>&nbsp;                case PATTERN_MINUS:</b>
<b class="nc"><i>2905</i>&nbsp;                    c = symbols.getMinusSign();</b>
<i>2906</i>&nbsp;                    break;
<b class="nc"><i>2907</i>&nbsp;                }</b>
<b class="nc"><i>2908</i>&nbsp;            }</b>
<b class="nc"><i>2909</i>&nbsp;            buffer.append(c);</b>
<b class="nc"><i>2910</i>&nbsp;        }</b>
<i>2911</i>&nbsp;        return buffer.toString();
<i>2912</i>&nbsp;    }
<b class="nc"><i>2913</i>&nbsp;</b>
<b class="nc"><i>2914</i>&nbsp;    /**</b>
<b class="nc"><i>2915</i>&nbsp;     * Expand an affix pattern into an array of FieldPositions describing</b>
<b class="nc"><i>2916</i>&nbsp;     * how the pattern would be expanded.</b>
<i>2917</i>&nbsp;     * All characters in the
<b class="nc"><i>2918</i>&nbsp;     * pattern are literal unless prefixed by QUOTE.  The following characters</b>
<i>2919</i>&nbsp;     * after QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
<i>2920</i>&nbsp;     * PATTERN_MINUS, and CURRENCY_SIGN.  If CURRENCY_SIGN is doubled (QUOTE +
<i>2921</i>&nbsp;     * CURRENCY_SIGN + CURRENCY_SIGN), it is interpreted as an ISO 4217
<i>2922</i>&nbsp;     * currency code.  Any other character after a QUOTE represents itself.
<i>2923</i>&nbsp;     * QUOTE must be followed by another character; QUOTE may not occur by
<i>2924</i>&nbsp;     * itself at the end of the pattern.
<i>2925</i>&nbsp;     *
<i>2926</i>&nbsp;     * @param pattern the non-null, possibly empty pattern
<i>2927</i>&nbsp;     * @return FieldPosition array of the resulting fields.
<i>2928</i>&nbsp;     */
<i>2929</i>&nbsp;    private FieldPosition[] expandAffix(String pattern) {
<i>2930</i>&nbsp;        ArrayList&lt;FieldPosition&gt; positions = null;
<i>2931</i>&nbsp;        int stringIndex = 0;
<i>2932</i>&nbsp;        for (int i=0; i&lt;pattern.length(); ) {
<i>2933</i>&nbsp;            char c = pattern.charAt(i++);
<i>2934</i>&nbsp;            if (c == QUOTE) {
<i>2935</i>&nbsp;                int field = -1;
<i>2936</i>&nbsp;                Format.Field fieldID = null;
<i>2937</i>&nbsp;                c = pattern.charAt(i++);
<b class="nc"><i>2938</i>&nbsp;                switch (c) {</b>
<b class="nc"><i>2939</i>&nbsp;                case CURRENCY_SIGN:</b>
<i>2940</i>&nbsp;                    String string;
<i>2941</i>&nbsp;                    if (i&lt;pattern.length() &amp;&amp;
<b class="nc"><i>2942</i>&nbsp;                        pattern.charAt(i) == CURRENCY_SIGN) {</b>
<b class="nc"><i>2943</i>&nbsp;                        ++i;</b>
<b class="nc"><i>2944</i>&nbsp;                        string = symbols.getInternationalCurrencySymbol();</b>
<b class="nc"><i>2945</i>&nbsp;                    } else {</b>
<b class="nc"><i>2946</i>&nbsp;                        string = symbols.getCurrencySymbol();</b>
<i>2947</i>&nbsp;                    }
<b class="nc"><i>2948</i>&nbsp;                    if (string.length() &gt; 0) {</b>
<b class="nc"><i>2949</i>&nbsp;                        if (positions == null) {</b>
<i>2950</i>&nbsp;                            positions = new ArrayList&lt;&gt;(2);
<b class="nc"><i>2951</i>&nbsp;                        }</b>
<b class="nc"><i>2952</i>&nbsp;                        FieldPosition fp = new FieldPosition(Field.CURRENCY);</b>
<b class="nc"><i>2953</i>&nbsp;                        fp.setBeginIndex(stringIndex);</b>
<b class="nc"><i>2954</i>&nbsp;                        fp.setEndIndex(stringIndex + string.length());</b>
<i>2955</i>&nbsp;                        positions.add(fp);
<b class="nc"><i>2956</i>&nbsp;                        stringIndex += string.length();</b>
<b class="nc"><i>2957</i>&nbsp;                    }</b>
<b class="nc"><i>2958</i>&nbsp;                    continue;</b>
<b class="nc"><i>2959</i>&nbsp;                case PATTERN_PERCENT:</b>
<b class="nc"><i>2960</i>&nbsp;                    c = symbols.getPercent();</b>
<i>2961</i>&nbsp;                    field = -1;
<b class="nc"><i>2962</i>&nbsp;                    fieldID = Field.PERCENT;</b>
<b class="nc"><i>2963</i>&nbsp;                    break;</b>
<i>2964</i>&nbsp;                case PATTERN_PER_MILLE:
<b class="nc"><i>2965</i>&nbsp;                    c = symbols.getPerMill();</b>
<b class="nc"><i>2966</i>&nbsp;                    field = -1;</b>
<i>2967</i>&nbsp;                    fieldID = Field.PERMILLE;
<b class="nc"><i>2968</i>&nbsp;                    break;</b>
<b class="nc"><i>2969</i>&nbsp;                case PATTERN_MINUS:</b>
<i>2970</i>&nbsp;                    c = symbols.getMinusSign();
<b class="nc"><i>2971</i>&nbsp;                    field = -1;</b>
<i>2972</i>&nbsp;                    fieldID = Field.SIGN;
<i>2973</i>&nbsp;                    break;
<i>2974</i>&nbsp;                }
<b class="nc"><i>2975</i>&nbsp;                if (fieldID != null) {</b>
<i>2976</i>&nbsp;                    if (positions == null) {
<i>2977</i>&nbsp;                        positions = new ArrayList&lt;&gt;(2);
<i>2978</i>&nbsp;                    }
<i>2979</i>&nbsp;                    FieldPosition fp = new FieldPosition(fieldID, field);
<i>2980</i>&nbsp;                    fp.setBeginIndex(stringIndex);
<i>2981</i>&nbsp;                    fp.setEndIndex(stringIndex + 1);
<i>2982</i>&nbsp;                    positions.add(fp);
<i>2983</i>&nbsp;                }
<i>2984</i>&nbsp;            }
<i>2985</i>&nbsp;            stringIndex++;
<i>2986</i>&nbsp;        }
<b class="nc"><i>2987</i>&nbsp;        if (positions != null) {</b>
<b class="nc"><i>2988</i>&nbsp;            return positions.toArray(EmptyFieldPositionArray);</b>
<b class="nc"><i>2989</i>&nbsp;        }</b>
<b class="nc"><i>2990</i>&nbsp;        return EmptyFieldPositionArray;</b>
<b class="nc"><i>2991</i>&nbsp;    }</b>
<b class="nc"><i>2992</i>&nbsp;</b>
<b class="nc"><i>2993</i>&nbsp;    /**</b>
<b class="nc"><i>2994</i>&nbsp;     * Appends an affix pattern to the given StringBuffer, quoting special</b>
<b class="nc"><i>2995</i>&nbsp;     * characters as needed.  Uses the internal affix pattern, if that exists,</b>
<b class="nc"><i>2996</i>&nbsp;     * or the literal affix, if the internal affix pattern is null.  The</b>
<i>2997</i>&nbsp;     * appended string will generate the same affix pattern (or literal affix)
<b class="nc"><i>2998</i>&nbsp;     * when passed to toPattern().</b>
<b class="nc"><i>2999</i>&nbsp;     *</b>
<b class="nc"><i>3000</i>&nbsp;     * @param buffer the affix string is appended to this</b>
<b class="nc"><i>3001</i>&nbsp;     * @param affixPattern a pattern such as posPrefixPattern; may be null</b>
<b class="nc"><i>3002</i>&nbsp;     * @param expAffix a corresponding expanded affix, such as positivePrefix.</b>
<b class="nc"><i>3003</i>&nbsp;     * Ignored unless affixPattern is null.  If affixPattern is null, then</b>
<b class="nc"><i>3004</i>&nbsp;     * expAffix is appended as a literal affix.</b>
<b class="nc"><i>3005</i>&nbsp;     * @param localized true if the appended pattern should contain localized</b>
<b class="nc"><i>3006</i>&nbsp;     * pattern characters; otherwise, non-localized pattern chars are appended</b>
<i>3007</i>&nbsp;     */
<b class="nc"><i>3008</i>&nbsp;    private void appendAffix(StringBuffer buffer, String affixPattern,</b>
<b class="nc"><i>3009</i>&nbsp;                             String expAffix, boolean localized) {</b>
<i>3010</i>&nbsp;        if (affixPattern == null) {
<b class="nc"><i>3011</i>&nbsp;            appendAffix(buffer, expAffix, localized);</b>
<b class="nc"><i>3012</i>&nbsp;        } else {</b>
<b class="nc"><i>3013</i>&nbsp;            int i;</b>
<b class="nc"><i>3014</i>&nbsp;            for (int pos=0; pos&lt;affixPattern.length(); pos=i) {</b>
<i>3015</i>&nbsp;                i = affixPattern.indexOf(QUOTE, pos);
<i>3016</i>&nbsp;                if (i &lt; 0) {
<b class="nc"><i>3017</i>&nbsp;                    appendAffix(buffer, affixPattern.substring(pos), localized);</b>
<i>3018</i>&nbsp;                    break;
<i>3019</i>&nbsp;                }
<i>3020</i>&nbsp;                if (i &gt; pos) {
<i>3021</i>&nbsp;                    appendAffix(buffer, affixPattern.substring(pos, i), localized);
<i>3022</i>&nbsp;                }
<b class="nc"><i>3023</i>&nbsp;                char c = affixPattern.charAt(++i);</b>
<b class="nc"><i>3024</i>&nbsp;                ++i;</b>
<b class="nc"><i>3025</i>&nbsp;                if (c == QUOTE) {</b>
<b class="nc"><i>3026</i>&nbsp;                    buffer.append(c);</b>
<b class="nc"><i>3027</i>&nbsp;                    // Fall through and append another QUOTE below</b>
<i>3028</i>&nbsp;                } else if (c == CURRENCY_SIGN &amp;&amp;
<b class="nc"><i>3029</i>&nbsp;                           i&lt;affixPattern.length() &amp;&amp;</b>
<b class="nc"><i>3030</i>&nbsp;                           affixPattern.charAt(i) == CURRENCY_SIGN) {</b>
<b class="nc"><i>3031</i>&nbsp;                    ++i;</b>
<b class="nc"><i>3032</i>&nbsp;                    buffer.append(c);</b>
<b class="nc"><i>3033</i>&nbsp;                    // Fall through and append another CURRENCY_SIGN below</b>
<i>3034</i>&nbsp;                } else if (localized) {
<b class="nc"><i>3035</i>&nbsp;                    switch (c) {</b>
<i>3036</i>&nbsp;                    case PATTERN_PERCENT:
<i>3037</i>&nbsp;                        c = symbols.getPercent();
<b class="nc"><i>3038</i>&nbsp;                        break;</b>
<b class="nc"><i>3039</i>&nbsp;                    case PATTERN_PER_MILLE:</b>
<b class="nc"><i>3040</i>&nbsp;                        c = symbols.getPerMill();</b>
<i>3041</i>&nbsp;                        break;
<b class="nc"><i>3042</i>&nbsp;                    case PATTERN_MINUS:</b>
<b class="nc"><i>3043</i>&nbsp;                        c = symbols.getMinusSign();</b>
<i>3044</i>&nbsp;                        break;
<b class="nc"><i>3045</i>&nbsp;                    }</b>
<b class="nc"><i>3046</i>&nbsp;                }</b>
<b class="nc"><i>3047</i>&nbsp;                buffer.append(c);</b>
<i>3048</i>&nbsp;            }
<i>3049</i>&nbsp;        }
<b class="nc"><i>3050</i>&nbsp;    }</b>
<i>3051</i>&nbsp;
<i>3052</i>&nbsp;    /**
<i>3053</i>&nbsp;     * Append an affix to the given StringBuffer, using quotes if
<b class="nc"><i>3054</i>&nbsp;     * there are special characters.  Single quotes themselves must be</b>
<i>3055</i>&nbsp;     * escaped in either case.
<b class="nc"><i>3056</i>&nbsp;     */</b>
<i>3057</i>&nbsp;    private void appendAffix(StringBuffer buffer, String affix, boolean localized) {
<b class="nc"><i>3058</i>&nbsp;        boolean needQuote;</b>
<b class="nc"><i>3059</i>&nbsp;        if (localized) {</b>
<i>3060</i>&nbsp;            needQuote = affix.indexOf(symbols.getZeroDigit()) &gt;= 0
<i>3061</i>&nbsp;                || affix.indexOf(symbols.getGroupingSeparator()) &gt;= 0
<b class="nc"><i>3062</i>&nbsp;                || affix.indexOf(symbols.getDecimalSeparator()) &gt;= 0</b>
<b class="nc"><i>3063</i>&nbsp;                || affix.indexOf(symbols.getPercent()) &gt;= 0</b>
<b class="nc"><i>3064</i>&nbsp;                || affix.indexOf(symbols.getPerMill()) &gt;= 0</b>
<b class="nc"><i>3065</i>&nbsp;                || affix.indexOf(symbols.getDigit()) &gt;= 0</b>
<i>3066</i>&nbsp;                || affix.indexOf(symbols.getPatternSeparator()) &gt;= 0
<b class="nc"><i>3067</i>&nbsp;                || affix.indexOf(symbols.getMinusSign()) &gt;= 0</b>
<b class="nc"><i>3068</i>&nbsp;                || affix.indexOf(CURRENCY_SIGN) &gt;= 0;</b>
<b class="nc"><i>3069</i>&nbsp;        } else {</b>
<i>3070</i>&nbsp;            needQuote = affix.indexOf(PATTERN_ZERO_DIGIT) &gt;= 0
<b class="nc"><i>3071</i>&nbsp;                || affix.indexOf(PATTERN_GROUPING_SEPARATOR) &gt;= 0</b>
<b class="nc"><i>3072</i>&nbsp;                || affix.indexOf(PATTERN_DECIMAL_SEPARATOR) &gt;= 0</b>
<i>3073</i>&nbsp;                || affix.indexOf(PATTERN_PERCENT) &gt;= 0
<b class="nc"><i>3074</i>&nbsp;                || affix.indexOf(PATTERN_PER_MILLE) &gt;= 0</b>
<i>3075</i>&nbsp;                || affix.indexOf(PATTERN_DIGIT) &gt;= 0
<b class="nc"><i>3076</i>&nbsp;                || affix.indexOf(PATTERN_SEPARATOR) &gt;= 0</b>
<i>3077</i>&nbsp;                || affix.indexOf(PATTERN_MINUS) &gt;= 0
<b class="nc"><i>3078</i>&nbsp;                || affix.indexOf(CURRENCY_SIGN) &gt;= 0;</b>
<i>3079</i>&nbsp;        }
<i>3080</i>&nbsp;        if (needQuote) buffer.append(&#39;\&#39;&#39;);
<i>3081</i>&nbsp;        if (affix.indexOf(&#39;\&#39;&#39;) &lt; 0) buffer.append(affix);
<i>3082</i>&nbsp;        else {
<i>3083</i>&nbsp;            for (int j=0; j&lt;affix.length(); ++j) {
<i>3084</i>&nbsp;                char c = affix.charAt(j);
<i>3085</i>&nbsp;                buffer.append(c);
<i>3086</i>&nbsp;                if (c == &#39;\&#39;&#39;) buffer.append(c);
<i>3087</i>&nbsp;            }
<i>3088</i>&nbsp;        }
<i>3089</i>&nbsp;        if (needQuote) buffer.append(&#39;\&#39;&#39;);
<i>3090</i>&nbsp;    }
<i>3091</i>&nbsp;
<i>3092</i>&nbsp;    /**
<i>3093</i>&nbsp;     * Does the real work of generating a pattern.  */
<i>3094</i>&nbsp;    private String toPattern(boolean localized) {
<i>3095</i>&nbsp;        StringBuffer result = new StringBuffer();
<i>3096</i>&nbsp;        for (int j = 1; j &gt;= 0; --j) {
<i>3097</i>&nbsp;            if (j == 1)
<i>3098</i>&nbsp;                appendAffix(result, posPrefixPattern, positivePrefix, localized);
<i>3099</i>&nbsp;            else appendAffix(result, negPrefixPattern, negativePrefix, localized);
<i>3100</i>&nbsp;            int i;
<i>3101</i>&nbsp;            int digitCount = useExponentialNotation
<i>3102</i>&nbsp;                        ? getMaximumIntegerDigits()
<i>3103</i>&nbsp;                        : Math.max(groupingSize, getMinimumIntegerDigits())+1;
<b class="nc"><i>3104</i>&nbsp;            for (i = digitCount; i &gt; 0; --i) {</b>
<i>3105</i>&nbsp;                if (i != digitCount &amp;&amp; isGroupingUsed() &amp;&amp; groupingSize != 0 &amp;&amp;
<i>3106</i>&nbsp;                    i % groupingSize == 0) {
<i>3107</i>&nbsp;                    result.append(localized ? symbols.getGroupingSeparator() :
<i>3108</i>&nbsp;                                  PATTERN_GROUPING_SEPARATOR);
<i>3109</i>&nbsp;                }
<i>3110</i>&nbsp;                result.append(i &lt;= getMinimumIntegerDigits()
<i>3111</i>&nbsp;                    ? (localized ? symbols.getZeroDigit() : PATTERN_ZERO_DIGIT)
<i>3112</i>&nbsp;                    : (localized ? symbols.getDigit() : PATTERN_DIGIT));
<i>3113</i>&nbsp;            }
<i>3114</i>&nbsp;            if (getMaximumFractionDigits() &gt; 0 || decimalSeparatorAlwaysShown)
<i>3115</i>&nbsp;                result.append(localized ? symbols.getDecimalSeparator() :
<i>3116</i>&nbsp;                              PATTERN_DECIMAL_SEPARATOR);
<i>3117</i>&nbsp;            for (i = 0; i &lt; getMaximumFractionDigits(); ++i) {
<i>3118</i>&nbsp;                if (i &lt; getMinimumFractionDigits()) {
<i>3119</i>&nbsp;                    result.append(localized ? symbols.getZeroDigit() :
<i>3120</i>&nbsp;                                  PATTERN_ZERO_DIGIT);
<i>3121</i>&nbsp;                } else {
<i>3122</i>&nbsp;                    result.append(localized ? symbols.getDigit() :
<i>3123</i>&nbsp;                                  PATTERN_DIGIT);
<i>3124</i>&nbsp;                }
<i>3125</i>&nbsp;            }
<i>3126</i>&nbsp;        if (useExponentialNotation)
<i>3127</i>&nbsp;        {
<i>3128</i>&nbsp;            result.append(localized ? symbols.getExponentSeparator() :
<i>3129</i>&nbsp;                  PATTERN_EXPONENT);
<i>3130</i>&nbsp;        for (i=0; i&lt;minExponentDigits; ++i)
<b class="nc"><i>3131</i>&nbsp;                    result.append(localized ? symbols.getZeroDigit() :</b>
<i>3132</i>&nbsp;                                  PATTERN_ZERO_DIGIT);
<i>3133</i>&nbsp;        }
<i>3134</i>&nbsp;            if (j == 1) {
<i>3135</i>&nbsp;                appendAffix(result, posSuffixPattern, positiveSuffix, localized);
<i>3136</i>&nbsp;                if ((negSuffixPattern == posSuffixPattern &amp;&amp; // n == p == null
<i>3137</i>&nbsp;                     negativeSuffix.equals(positiveSuffix))
<b class="nc"><i>3138</i>&nbsp;                    || (negSuffixPattern != null &amp;&amp;</b>
<b class="nc"><i>3139</i>&nbsp;                        negSuffixPattern.equals(posSuffixPattern))) {</b>
<b class="nc"><i>3140</i>&nbsp;                    if ((negPrefixPattern != null &amp;&amp; posPrefixPattern != null &amp;&amp;</b>
<b class="nc"><i>3141</i>&nbsp;                         negPrefixPattern.equals(&quot;&#39;-&quot; + posPrefixPattern)) ||</b>
<b class="nc"><i>3142</i>&nbsp;                        (negPrefixPattern == posPrefixPattern &amp;&amp; // n == p == null</b>
<b class="nc"><i>3143</i>&nbsp;                         negativePrefix.equals(symbols.getMinusSign() + positivePrefix)))</b>
<b class="nc"><i>3144</i>&nbsp;                        break;</b>
<b class="nc"><i>3145</i>&nbsp;                }</b>
<b class="nc"><i>3146</i>&nbsp;                result.append(localized ? symbols.getPatternSeparator() :</b>
<b class="nc"><i>3147</i>&nbsp;                              PATTERN_SEPARATOR);</b>
<b class="nc"><i>3148</i>&nbsp;            } else appendAffix(result, negSuffixPattern, negativeSuffix, localized);</b>
<b class="nc"><i>3149</i>&nbsp;        }</b>
<b class="nc"><i>3150</i>&nbsp;        return result.toString();</b>
<b class="nc"><i>3151</i>&nbsp;    }</b>
<b class="nc"><i>3152</i>&nbsp;</b>
<b class="nc"><i>3153</i>&nbsp;    /**</b>
<b class="nc"><i>3154</i>&nbsp;     * Apply the given pattern to this Format object.  A pattern is a</b>
<b class="nc"><i>3155</i>&nbsp;     * short-hand specification for the various formatting properties.</b>
<b class="nc"><i>3156</i>&nbsp;     * These properties can also be changed individually through the</b>
<i>3157</i>&nbsp;     * various setter methods.
<b class="nc"><i>3158</i>&nbsp;     * &lt;p&gt;</b>
<b class="nc"><i>3159</i>&nbsp;     * There is no limit to integer digits set</b>
<b class="nc"><i>3160</i>&nbsp;     * by this routine, since that is the typical end-user desire;</b>
<b class="nc"><i>3161</i>&nbsp;     * use setMaximumInteger if you want to set a real value.</b>
<i>3162</i>&nbsp;     * For negative numbers, use a second pattern, separated by a semicolon
<i>3163</i>&nbsp;     * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56
<i>3164</i>&nbsp;     * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
<i>3165</i>&nbsp;     * a maximum of 2 fraction digits.
<i>3166</i>&nbsp;     * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in
<b class="nc"><i>3167</i>&nbsp;     * parentheses.</b>
<b class="nc"><i>3168</i>&nbsp;     * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;</b>
<i>3169</i>&nbsp;     * these are presumed to be set in the positive pattern.
<b class="nc"><i>3170</i>&nbsp;     *</b>
<b class="nc"><i>3171</i>&nbsp;     * @param pattern a new pattern</b>
<b class="nc"><i>3172</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null</b>
<b class="nc"><i>3173</i>&nbsp;     * @exception IllegalArgumentException if the given pattern is invalid.</b>
<b class="nc"><i>3174</i>&nbsp;     */</b>
<b class="nc"><i>3175</i>&nbsp;    public void applyPattern(String pattern) {</b>
<b class="nc"><i>3176</i>&nbsp;        applyPattern(pattern, false);</b>
<b class="nc"><i>3177</i>&nbsp;    }</b>
<b class="nc"><i>3178</i>&nbsp;</b>
<i>3179</i>&nbsp;    /**
<i>3180</i>&nbsp;     * Apply the given pattern to this Format object.  The pattern
<i>3181</i>&nbsp;     * is assumed to be in a localized notation. A pattern is a
<i>3182</i>&nbsp;     * short-hand specification for the various formatting properties.
<i>3183</i>&nbsp;     * These properties can also be changed individually through the
<i>3184</i>&nbsp;     * various setter methods.
<i>3185</i>&nbsp;     * &lt;p&gt;
<i>3186</i>&nbsp;     * There is no limit to integer digits set
<b class="nc"><i>3187</i>&nbsp;     * by this routine, since that is the typical end-user desire;</b>
<i>3188</i>&nbsp;     * use setMaximumInteger if you want to set a real value.
<i>3189</i>&nbsp;     * For negative numbers, use a second pattern, separated by a semicolon
<b class="nc"><i>3190</i>&nbsp;     * &lt;P&gt;Example &lt;code&gt;&quot;#,#00.0#&quot;&lt;/code&gt; &amp;rarr; 1,234.56</b>
<i>3191</i>&nbsp;     * &lt;P&gt;This means a minimum of 2 integer digits, 1 fraction digit, and
<b class="nc"><i>3192</i>&nbsp;     * a maximum of 2 fraction digits.</b>
<b class="nc"><i>3193</i>&nbsp;     * &lt;p&gt;Example: &lt;code&gt;&quot;#,#00.0#;(#,#00.0#)&quot;&lt;/code&gt; for negatives in</b>
<b class="nc"><i>3194</i>&nbsp;     * parentheses.</b>
<i>3195</i>&nbsp;     * &lt;p&gt;In negative patterns, the minimum and maximum counts are ignored;
<i>3196</i>&nbsp;     * these are presumed to be set in the positive pattern.
<i>3197</i>&nbsp;     *
<b class="nc"><i>3198</i>&nbsp;     * @param pattern a new pattern</b>
<i>3199</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;pattern&lt;/code&gt; is null
<i>3200</i>&nbsp;     * @exception IllegalArgumentException if the given pattern is invalid.
<i>3201</i>&nbsp;     */
<b class="nc"><i>3202</i>&nbsp;    public void applyLocalizedPattern(String pattern) {</b>
<b class="nc"><i>3203</i>&nbsp;        applyPattern(pattern, true);</b>
<b class="nc"><i>3204</i>&nbsp;    }</b>
<b class="nc"><i>3205</i>&nbsp;</b>
<b class="nc"><i>3206</i>&nbsp;    /**</b>
<i>3207</i>&nbsp;     * Does the real work of applying a pattern.
<b class="nc"><i>3208</i>&nbsp;     */</b>
<i>3209</i>&nbsp;    private void applyPattern(String pattern, boolean localized) {
<b class="nc"><i>3210</i>&nbsp;        char zeroDigit         = PATTERN_ZERO_DIGIT;</b>
<i>3211</i>&nbsp;        char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
<i>3212</i>&nbsp;        char decimalSeparator  = PATTERN_DECIMAL_SEPARATOR;
<i>3213</i>&nbsp;        char percent           = PATTERN_PERCENT;
<i>3214</i>&nbsp;        char perMill           = PATTERN_PER_MILLE;
<b class="nc"><i>3215</i>&nbsp;        char digit             = PATTERN_DIGIT;</b>
<i>3216</i>&nbsp;        char separator         = PATTERN_SEPARATOR;
<i>3217</i>&nbsp;        String exponent          = PATTERN_EXPONENT;
<i>3218</i>&nbsp;        char minus             = PATTERN_MINUS;
<b class="nc"><i>3219</i>&nbsp;        if (localized) {</b>
<b class="nc"><i>3220</i>&nbsp;            zeroDigit         = symbols.getZeroDigit();</b>
<b class="nc"><i>3221</i>&nbsp;            groupingSeparator = symbols.getGroupingSeparator();</b>
<i>3222</i>&nbsp;            decimalSeparator  = symbols.getDecimalSeparator();
<b class="nc"><i>3223</i>&nbsp;            percent           = symbols.getPercent();</b>
<b class="nc"><i>3224</i>&nbsp;            perMill           = symbols.getPerMill();</b>
<b class="nc"><i>3225</i>&nbsp;            digit             = symbols.getDigit();</b>
<i>3226</i>&nbsp;            separator         = symbols.getPatternSeparator();
<i>3227</i>&nbsp;            exponent          = symbols.getExponentSeparator();
<b class="nc"><i>3228</i>&nbsp;            minus             = symbols.getMinusSign();</b>
<b class="nc"><i>3229</i>&nbsp;        }</b>
<b class="nc"><i>3230</i>&nbsp;        boolean gotNegative = false;</b>
<b class="nc"><i>3231</i>&nbsp;        decimalSeparatorAlwaysShown = false;</b>
<i>3232</i>&nbsp;        isCurrencyFormat = false;
<b class="nc"><i>3233</i>&nbsp;        useExponentialNotation = false;</b>
<b class="nc"><i>3234</i>&nbsp;</b>
<b class="nc"><i>3235</i>&nbsp;        int start = 0;</b>
<b class="nc"><i>3236</i>&nbsp;        for (int j = 1; j &gt;= 0 &amp;&amp; start &lt; pattern.length(); --j) {</b>
<i>3237</i>&nbsp;            boolean inQuote = false;
<i>3238</i>&nbsp;            StringBuffer prefix = new StringBuffer();
<i>3239</i>&nbsp;            StringBuffer suffix = new StringBuffer();
<i>3240</i>&nbsp;            int decimalPos = -1;
<b class="nc"><i>3241</i>&nbsp;            int multiplier = 1;</b>
<b class="nc"><i>3242</i>&nbsp;            int digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0;</b>
<b class="nc"><i>3243</i>&nbsp;            byte groupingCount = -1;</b>
<b class="nc"><i>3244</i>&nbsp;</b>
<b class="nc"><i>3245</i>&nbsp;            // The phase ranges from 0 to 2.  Phase 0 is the prefix.  Phase 1 is</b>
<i>3246</i>&nbsp;            // the section of the pattern with digits, decimal separator,
<b class="nc"><i>3247</i>&nbsp;            // grouping characters.  Phase 2 is the suffix.  In phases 0 and 2,</b>
<i>3248</i>&nbsp;            // percent, per mille, and currency symbols are recognized and
<b class="nc"><i>3249</i>&nbsp;            // translated.  The separation of the characters into phases is</b>
<i>3250</i>&nbsp;            // strictly enforced; if phase 1 characters are to appear in the
<b class="nc"><i>3251</i>&nbsp;            // suffix, for example, they must be quoted.</b>
<i>3252</i>&nbsp;            int phase = 0;
<i>3253</i>&nbsp;
<i>3254</i>&nbsp;            // The affix is either the prefix or the suffix.
<b class="nc"><i>3255</i>&nbsp;            StringBuffer affix = prefix;</b>
<b class="nc"><i>3256</i>&nbsp;</b>
<i>3257</i>&nbsp;            for (int pos = start; pos &lt; pattern.length(); ++pos) {
<i>3258</i>&nbsp;                char ch = pattern.charAt(pos);
<b class="nc"><i>3259</i>&nbsp;                switch (phase) {</b>
<b class="nc"><i>3260</i>&nbsp;                case 0:</b>
<b class="nc"><i>3261</i>&nbsp;                case 2:</b>
<i>3262</i>&nbsp;                    // Process the prefix / suffix characters
<i>3263</i>&nbsp;                    if (inQuote) {
<i>3264</i>&nbsp;                        // A quote within quotes indicates either the closing
<b class="nc"><i>3265</i>&nbsp;                        // quote or two quotes, which is a quote literal. That</b>
<b class="nc"><i>3266</i>&nbsp;                        // is, we have the second quote in &#39;do&#39; or &#39;don&#39;&#39;t&#39;.</b>
<b class="nc"><i>3267</i>&nbsp;                        if (ch == QUOTE) {</b>
<i>3268</i>&nbsp;                            if ((pos+1) &lt; pattern.length() &amp;&amp;
<i>3269</i>&nbsp;                                pattern.charAt(pos+1) == QUOTE) {
<b class="nc"><i>3270</i>&nbsp;                                ++pos;</b>
<b class="nc"><i>3271</i>&nbsp;                                affix.append(&quot;&#39;&#39;&quot;); // &#39;don&#39;&#39;t&#39;</b>
<b class="nc"><i>3272</i>&nbsp;                            } else {</b>
<b class="nc"><i>3273</i>&nbsp;                                inQuote = false; // &#39;do&#39;</b>
<b class="nc"><i>3274</i>&nbsp;                            }</b>
<b class="nc"><i>3275</i>&nbsp;                            continue;</b>
<i>3276</i>&nbsp;                        }
<i>3277</i>&nbsp;                    } else {
<b class="nc"><i>3278</i>&nbsp;                        // Process unquoted characters seen in prefix or suffix</b>
<b class="nc"><i>3279</i>&nbsp;                        // phase.</b>
<b class="nc"><i>3280</i>&nbsp;                        if (ch == digit ||</b>
<b class="nc"><i>3281</i>&nbsp;                            ch == zeroDigit ||</b>
<b class="nc"><i>3282</i>&nbsp;                            ch == groupingSeparator ||</b>
<b class="nc"><i>3283</i>&nbsp;                            ch == decimalSeparator) {</b>
<i>3284</i>&nbsp;                            phase = 1;
<i>3285</i>&nbsp;                            --pos; // Reprocess this character
<i>3286</i>&nbsp;                            continue;
<i>3287</i>&nbsp;                        } else if (ch == CURRENCY_SIGN) {
<i>3288</i>&nbsp;                            // Use lookahead to determine if the currency sign
<b class="nc"><i>3289</i>&nbsp;                            // is doubled or not.</b>
<b class="nc"><i>3290</i>&nbsp;                            boolean doubled = (pos + 1) &lt; pattern.length() &amp;&amp;</b>
<i>3291</i>&nbsp;                                pattern.charAt(pos + 1) == CURRENCY_SIGN;
<i>3292</i>&nbsp;                            if (doubled) { // Skip over the doubled character
<i>3293</i>&nbsp;                             ++pos;
<i>3294</i>&nbsp;                            }
<i>3295</i>&nbsp;                            isCurrencyFormat = true;
<i>3296</i>&nbsp;                            affix.append(doubled ? &quot;&#39;\u00A4\u00A4&quot; : &quot;&#39;\u00A4&quot;);
<i>3297</i>&nbsp;                            continue;
<b class="nc"><i>3298</i>&nbsp;                        } else if (ch == QUOTE) {</b>
<b class="nc"><i>3299</i>&nbsp;                            // A quote outside quotes indicates either the</b>
<i>3300</i>&nbsp;                            // opening quote or two quotes, which is a quote
<b class="nc"><i>3301</i>&nbsp;                            // literal. That is, we have the first quote in &#39;do&#39;</b>
<b class="nc"><i>3302</i>&nbsp;                            // or o&#39;&#39;clock.</b>
<b class="nc"><i>3303</i>&nbsp;                            if (ch == QUOTE) {</b>
<i>3304</i>&nbsp;                                if ((pos+1) &lt; pattern.length() &amp;&amp;
<i>3305</i>&nbsp;                                    pattern.charAt(pos+1) == QUOTE) {
<i>3306</i>&nbsp;                                    ++pos;
<i>3307</i>&nbsp;                                    affix.append(&quot;&#39;&#39;&quot;); // o&#39;&#39;clock
<i>3308</i>&nbsp;                                } else {
<i>3309</i>&nbsp;                                    inQuote = true; // &#39;do&#39;
<i>3310</i>&nbsp;                                }
<i>3311</i>&nbsp;                                continue;
<i>3312</i>&nbsp;                            }
<i>3313</i>&nbsp;                        } else if (ch == separator) {
<i>3314</i>&nbsp;                            // Don&#39;t allow separators before we see digit
<i>3315</i>&nbsp;                            // characters of phase 1, and don&#39;t allow separators
<i>3316</i>&nbsp;                            // in the second pattern (j == 0).
<b class="nc"><i>3317</i>&nbsp;                            if (phase == 0 || j == 0) {</b>
<b class="nc"><i>3318</i>&nbsp;                                throw new IllegalArgumentException(&quot;Unquoted special character &#39;&quot; +</b>
<b class="nc"><i>3319</i>&nbsp;                                    ch + &quot;&#39; in pattern \&quot;&quot; + pattern + &#39;&quot;&#39;);</b>
<i>3320</i>&nbsp;                            }
<b class="nc"><i>3321</i>&nbsp;                            start = pos + 1;</b>
<i>3322</i>&nbsp;                            pos = pattern.length();
<b class="nc"><i>3323</i>&nbsp;                            continue;</b>
<b class="nc"><i>3324</i>&nbsp;                        }</b>
<i>3325</i>&nbsp;
<b class="nc"><i>3326</i>&nbsp;                        // Next handle characters which are appended directly.</b>
<b class="nc"><i>3327</i>&nbsp;                        else if (ch == percent) {</b>
<b class="nc"><i>3328</i>&nbsp;                            if (multiplier != 1) {</b>
<i>3329</i>&nbsp;                                throw new IllegalArgumentException(&quot;Too many percent/per mille characters in pattern \&quot;&quot; +
<i>3330</i>&nbsp;                                    pattern + &#39;&quot;&#39;);
<b class="nc"><i>3331</i>&nbsp;                            }</b>
<b class="nc"><i>3332</i>&nbsp;                            multiplier = 100;</b>
<b class="nc"><i>3333</i>&nbsp;                            affix.append(&quot;&#39;%&quot;);</b>
<i>3334</i>&nbsp;                            continue;
<b class="nc"><i>3335</i>&nbsp;                        } else if (ch == perMill) {</b>
<b class="nc"><i>3336</i>&nbsp;                            if (multiplier != 1) {</b>
<b class="nc"><i>3337</i>&nbsp;                                throw new IllegalArgumentException(&quot;Too many percent/per mille characters in pattern \&quot;&quot; +</b>
<b class="nc"><i>3338</i>&nbsp;                                    pattern + &#39;&quot;&#39;);</b>
<b class="nc"><i>3339</i>&nbsp;                            }</b>
<i>3340</i>&nbsp;                            multiplier = 1000;
<i>3341</i>&nbsp;                            affix.append(&quot;&#39;\u2030&quot;);
<b class="nc"><i>3342</i>&nbsp;                            continue;</b>
<b class="nc"><i>3343</i>&nbsp;                        } else if (ch == minus) {</b>
<b class="nc"><i>3344</i>&nbsp;                            affix.append(&quot;&#39;-&quot;);</b>
<b class="nc"><i>3345</i>&nbsp;                            continue;</b>
<i>3346</i>&nbsp;                        }
<i>3347</i>&nbsp;                    }
<b class="nc"><i>3348</i>&nbsp;                    // Note that if we are within quotes, or if this is an</b>
<b class="nc"><i>3349</i>&nbsp;                    // unquoted, non-special character, then we usually fall</b>
<i>3350</i>&nbsp;                    // through to here.
<i>3351</i>&nbsp;                    affix.append(ch);
<i>3352</i>&nbsp;                    break;
<b class="nc"><i>3353</i>&nbsp;</b>
<b class="nc"><i>3354</i>&nbsp;                case 1:</b>
<b class="nc"><i>3355</i>&nbsp;                    // The negative subpattern (j = 0) serves only to specify the</b>
<b class="nc"><i>3356</i>&nbsp;                    // negative prefix and suffix, so all the phase 1 characters</b>
<b class="nc"><i>3357</i>&nbsp;                    // e.g. digits, zeroDigit, groupingSeparator,</b>
<b class="nc"><i>3358</i>&nbsp;                    // decimalSeparator, exponent are ignored</b>
<i>3359</i>&nbsp;                    if (j == 0) {
<i>3360</i>&nbsp;                        while (pos &lt; pattern.length()) {
<b class="nc"><i>3361</i>&nbsp;                            char negPatternChar = pattern.charAt(pos);</b>
<i>3362</i>&nbsp;                            if (negPatternChar == digit
<b class="nc"><i>3363</i>&nbsp;                                    || negPatternChar == zeroDigit</b>
<i>3364</i>&nbsp;                                    || negPatternChar == groupingSeparator
<i>3365</i>&nbsp;                                    || negPatternChar == decimalSeparator) {
<i>3366</i>&nbsp;                                ++pos;
<i>3367</i>&nbsp;                            } else if (pattern.regionMatches(pos, exponent,
<b class="nc"><i>3368</i>&nbsp;                                    0, exponent.length())) {</b>
<b class="nc"><i>3369</i>&nbsp;                                pos = pos + exponent.length();</b>
<b class="nc"><i>3370</i>&nbsp;                            } else {</b>
<b class="nc"><i>3371</i>&nbsp;                                // Not a phase 1 character, consider it as</b>
<i>3372</i>&nbsp;                                // suffix and parse it in phase 2
<b class="nc"><i>3373</i>&nbsp;                                --pos; //process it again in outer loop</b>
<b class="nc"><i>3374</i>&nbsp;                                phase = 2;</b>
<b class="nc"><i>3375</i>&nbsp;                                affix = suffix;</b>
<b class="nc"><i>3376</i>&nbsp;                                break;</b>
<b class="nc"><i>3377</i>&nbsp;                            }</b>
<i>3378</i>&nbsp;                        }
<i>3379</i>&nbsp;                        continue;
<i>3380</i>&nbsp;                    }
<i>3381</i>&nbsp;
<i>3382</i>&nbsp;                    // Process the digits, decimal, and grouping characters. We
<i>3383</i>&nbsp;                    // record five pieces of information. We expect the digits
<i>3384</i>&nbsp;                    // to occur in the pattern ####0000.####, and we record the
<i>3385</i>&nbsp;                    // number of left digits, zero (central) digits, and right
<i>3386</i>&nbsp;                    // digits. The position of the last grouping character is
<i>3387</i>&nbsp;                    // recorded (should be somewhere within the first two blocks
<i>3388</i>&nbsp;                    // of characters), as is the position of the decimal point,
<i>3389</i>&nbsp;                    // if any (should be in the zero digits). If there is no
<i>3390</i>&nbsp;                    // decimal point, then there should be no right digits.
<i>3391</i>&nbsp;                    if (ch == digit) {
<i>3392</i>&nbsp;                        if (zeroDigitCount &gt; 0) {
<i>3393</i>&nbsp;                            ++digitRightCount;
<i>3394</i>&nbsp;                        } else {
<b class="nc"><i>3395</i>&nbsp;                            ++digitLeftCount;</b>
<i>3396</i>&nbsp;                        }
<b class="nc"><i>3397</i>&nbsp;                        if (groupingCount &gt;= 0 &amp;&amp; decimalPos &lt; 0) {</b>
<b class="nc"><i>3398</i>&nbsp;                            ++groupingCount;</b>
<b class="nc"><i>3399</i>&nbsp;                        }</b>
<i>3400</i>&nbsp;                    } else if (ch == zeroDigit) {
<b class="nc"><i>3401</i>&nbsp;                        if (digitRightCount &gt; 0) {</b>
<b class="nc"><i>3402</i>&nbsp;                            throw new IllegalArgumentException(&quot;Unexpected &#39;0&#39; in pattern \&quot;&quot; +</b>
<b class="nc"><i>3403</i>&nbsp;                                pattern + &#39;&quot;&#39;);</b>
<i>3404</i>&nbsp;                        }
<i>3405</i>&nbsp;                        ++zeroDigitCount;
<i>3406</i>&nbsp;                        if (groupingCount &gt;= 0 &amp;&amp; decimalPos &lt; 0) {
<b class="nc"><i>3407</i>&nbsp;                            ++groupingCount;</b>
<i>3408</i>&nbsp;                        }
<i>3409</i>&nbsp;                    } else if (ch == groupingSeparator) {
<i>3410</i>&nbsp;                        groupingCount = 0;
<b class="nc"><i>3411</i>&nbsp;                    } else if (ch == decimalSeparator) {</b>
<i>3412</i>&nbsp;                        if (decimalPos &gt;= 0) {
<i>3413</i>&nbsp;                            throw new IllegalArgumentException(&quot;Multiple decimal separators in pattern \&quot;&quot; +
<i>3414</i>&nbsp;                                pattern + &#39;&quot;&#39;);
<b class="nc"><i>3415</i>&nbsp;                        }</b>
<b class="nc"><i>3416</i>&nbsp;                        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;</b>
<b class="nc"><i>3417</i>&nbsp;                    } else if (pattern.regionMatches(pos, exponent, 0, exponent.length())){</b>
<b class="nc"><i>3418</i>&nbsp;                        if (useExponentialNotation) {</b>
<b class="nc"><i>3419</i>&nbsp;                            throw new IllegalArgumentException(&quot;Multiple exponential &quot; +</b>
<b class="nc"><i>3420</i>&nbsp;                                &quot;symbols in pattern \&quot;&quot; + pattern + &#39;&quot;&#39;);</b>
<i>3421</i>&nbsp;                        }
<i>3422</i>&nbsp;                        useExponentialNotation = true;
<i>3423</i>&nbsp;                        minExponentDigits = 0;
<i>3424</i>&nbsp;
<b class="nc"><i>3425</i>&nbsp;                        // Use lookahead to parse out the exponential part</b>
<i>3426</i>&nbsp;                        // of the pattern, then jump into phase 2.
<b class="nc"><i>3427</i>&nbsp;                        pos = pos+exponent.length();</b>
<b class="nc"><i>3428</i>&nbsp;                         while (pos &lt; pattern.length() &amp;&amp;</b>
<b class="nc"><i>3429</i>&nbsp;                               pattern.charAt(pos) == zeroDigit) {</b>
<i>3430</i>&nbsp;                            ++minExponentDigits;
<b class="nc"><i>3431</i>&nbsp;                            ++pos;</b>
<i>3432</i>&nbsp;                        }
<b class="nc"><i>3433</i>&nbsp;</b>
<i>3434</i>&nbsp;                        if ((digitLeftCount + zeroDigitCount) &lt; 1 ||
<b class="nc"><i>3435</i>&nbsp;                            minExponentDigits &lt; 1) {</b>
<b class="nc"><i>3436</i>&nbsp;                            throw new IllegalArgumentException(&quot;Malformed exponential &quot; +</b>
<b class="nc"><i>3437</i>&nbsp;                                &quot;pattern \&quot;&quot; + pattern + &#39;&quot;&#39;);</b>
<b class="nc"><i>3438</i>&nbsp;                        }</b>
<i>3439</i>&nbsp;
<b class="nc"><i>3440</i>&nbsp;                        // Transition to phase 2</b>
<b class="nc"><i>3441</i>&nbsp;                        phase = 2;</b>
<b class="nc"><i>3442</i>&nbsp;                        affix = suffix;</b>
<b class="nc"><i>3443</i>&nbsp;                        --pos;</b>
<i>3444</i>&nbsp;                        continue;
<i>3445</i>&nbsp;                    } else {
<i>3446</i>&nbsp;                        phase = 2;
<b class="nc"><i>3447</i>&nbsp;                        affix = suffix;</b>
<b class="nc"><i>3448</i>&nbsp;                        --pos;</b>
<b class="nc"><i>3449</i>&nbsp;                        continue;</b>
<b class="nc"><i>3450</i>&nbsp;                    }</b>
<b class="nc"><i>3451</i>&nbsp;                    break;</b>
<b class="nc"><i>3452</i>&nbsp;                }</b>
<i>3453</i>&nbsp;            }
<i>3454</i>&nbsp;
<i>3455</i>&nbsp;            // Handle patterns with no &#39;0&#39; pattern character. These patterns
<i>3456</i>&nbsp;            // are legal, but must be interpreted.  &quot;##.###&quot; -&gt; &quot;#0.###&quot;.
<i>3457</i>&nbsp;            // &quot;.###&quot; -&gt; &quot;.0##&quot;.
<b class="nc"><i>3458</i>&nbsp;            /* We allow patterns of the form &quot;####&quot; to produce a zeroDigitCount</b>
<b class="nc"><i>3459</i>&nbsp;             * of zero (got that?); although this seems like it might make it</b>
<b class="nc"><i>3460</i>&nbsp;             * possible for format() to produce empty strings, format() checks</b>
<b class="nc"><i>3461</i>&nbsp;             * for this condition and outputs a zero digit in this situation.</b>
<b class="nc"><i>3462</i>&nbsp;             * Having a zeroDigitCount of zero yields a minimum integer digits</b>
<i>3463</i>&nbsp;             * of zero, which allows proper round-trip patterns.  That is, we
<i>3464</i>&nbsp;             * don&#39;t want &quot;#&quot; to become &quot;#0&quot; when toPattern() is called (even
<b class="nc"><i>3465</i>&nbsp;             * though that&#39;s what it really is, semantically).</b>
<i>3466</i>&nbsp;             */
<i>3467</i>&nbsp;            if (zeroDigitCount == 0 &amp;&amp; digitLeftCount &gt; 0 &amp;&amp; decimalPos &gt;= 0) {
<i>3468</i>&nbsp;                // Handle &quot;###.###&quot; and &quot;###.&quot; and &quot;.###&quot;
<i>3469</i>&nbsp;                int n = decimalPos;
<i>3470</i>&nbsp;                if (n == 0) { // Handle &quot;.###&quot;
<i>3471</i>&nbsp;                    ++n;
<i>3472</i>&nbsp;                }
<i>3473</i>&nbsp;                digitRightCount = digitLeftCount - n;
<i>3474</i>&nbsp;                digitLeftCount = n - 1;
<i>3475</i>&nbsp;                zeroDigitCount = 1;
<i>3476</i>&nbsp;            }
<i>3477</i>&nbsp;
<b class="nc"><i>3478</i>&nbsp;            // Do syntax checking on the digits.</b>
<b class="nc"><i>3479</i>&nbsp;            if ((decimalPos &lt; 0 &amp;&amp; digitRightCount &gt; 0) ||</b>
<i>3480</i>&nbsp;                (decimalPos &gt;= 0 &amp;&amp; (decimalPos &lt; digitLeftCount ||
<b class="nc"><i>3481</i>&nbsp;                 decimalPos &gt; (digitLeftCount + zeroDigitCount))) ||</b>
<b class="nc"><i>3482</i>&nbsp;                 groupingCount == 0 || inQuote) {</b>
<b class="nc"><i>3483</i>&nbsp;                throw new IllegalArgumentException(&quot;Malformed pattern \&quot;&quot; +</b>
<i>3484</i>&nbsp;                    pattern + &#39;&quot;&#39;);
<i>3485</i>&nbsp;            }
<b class="nc"><i>3486</i>&nbsp;</b>
<i>3487</i>&nbsp;            if (j == 1) {
<i>3488</i>&nbsp;                posPrefixPattern = prefix.toString();
<i>3489</i>&nbsp;                posSuffixPattern = suffix.toString();
<i>3490</i>&nbsp;                negPrefixPattern = posPrefixPattern;   // assume these for now
<i>3491</i>&nbsp;                negSuffixPattern = posSuffixPattern;
<i>3492</i>&nbsp;                int digitTotalCount = digitLeftCount + zeroDigitCount + digitRightCount;
<i>3493</i>&nbsp;                /* The effectiveDecimalPos is the position the decimal is at or
<i>3494</i>&nbsp;                 * would be at if there is no decimal. Note that if decimalPos&lt;0,
<i>3495</i>&nbsp;                 * then digitTotalCount == digitLeftCount + zeroDigitCount.
<i>3496</i>&nbsp;                 */
<i>3497</i>&nbsp;                int effectiveDecimalPos = decimalPos &gt;= 0 ?
<i>3498</i>&nbsp;                    decimalPos : digitTotalCount;
<b class="nc"><i>3499</i>&nbsp;                setMinimumIntegerDigits(effectiveDecimalPos - digitLeftCount);</b>
<b class="nc"><i>3500</i>&nbsp;                setMaximumIntegerDigits(useExponentialNotation ?</b>
<i>3501</i>&nbsp;                    digitLeftCount + getMinimumIntegerDigits() :
<b class="nc"><i>3502</i>&nbsp;                    MAXIMUM_INTEGER_DIGITS);</b>
<b class="nc"><i>3503</i>&nbsp;                setMaximumFractionDigits(decimalPos &gt;= 0 ?</b>
<b class="nc"><i>3504</i>&nbsp;                    (digitTotalCount - decimalPos) : 0);</b>
<i>3505</i>&nbsp;                setMinimumFractionDigits(decimalPos &gt;= 0 ?
<i>3506</i>&nbsp;                    (digitLeftCount + zeroDigitCount - decimalPos) : 0);
<b class="nc"><i>3507</i>&nbsp;                setGroupingUsed(groupingCount &gt; 0);</b>
<i>3508</i>&nbsp;                this.groupingSize = (groupingCount &gt; 0) ? groupingCount : 0;
<i>3509</i>&nbsp;                this.multiplier = multiplier;
<i>3510</i>&nbsp;                setDecimalSeparatorAlwaysShown(decimalPos == 0 ||
<i>3511</i>&nbsp;                    decimalPos == digitTotalCount);
<i>3512</i>&nbsp;            } else {
<i>3513</i>&nbsp;                negPrefixPattern = prefix.toString();
<i>3514</i>&nbsp;                negSuffixPattern = suffix.toString();
<i>3515</i>&nbsp;                gotNegative = true;
<i>3516</i>&nbsp;            }
<i>3517</i>&nbsp;        }
<i>3518</i>&nbsp;
<i>3519</i>&nbsp;        if (pattern.length() == 0) {
<b class="nc"><i>3520</i>&nbsp;            posPrefixPattern = posSuffixPattern = &quot;&quot;;</b>
<b class="nc"><i>3521</i>&nbsp;            setMinimumIntegerDigits(0);</b>
<i>3522</i>&nbsp;            setMaximumIntegerDigits(MAXIMUM_INTEGER_DIGITS);
<b class="nc"><i>3523</i>&nbsp;            setMinimumFractionDigits(0);</b>
<b class="nc"><i>3524</i>&nbsp;            setMaximumFractionDigits(MAXIMUM_FRACTION_DIGITS);</b>
<b class="nc"><i>3525</i>&nbsp;        }</b>
<i>3526</i>&nbsp;
<i>3527</i>&nbsp;        // If there was no negative pattern, or if the negative pattern is
<b class="nc"><i>3528</i>&nbsp;        // identical to the positive pattern, then prepend the minus sign to</b>
<i>3529</i>&nbsp;        // the positive pattern to form the negative pattern.
<i>3530</i>&nbsp;        if (!gotNegative ||
<i>3531</i>&nbsp;            (negPrefixPattern.equals(posPrefixPattern)
<i>3532</i>&nbsp;             &amp;&amp; negSuffixPattern.equals(posSuffixPattern))) {
<i>3533</i>&nbsp;            negSuffixPattern = posSuffixPattern;
<i>3534</i>&nbsp;            negPrefixPattern = &quot;&#39;-&quot; + posPrefixPattern;
<i>3535</i>&nbsp;        }
<i>3536</i>&nbsp;
<i>3537</i>&nbsp;        expandAffixes();
<i>3538</i>&nbsp;    }
<i>3539</i>&nbsp;
<i>3540</i>&nbsp;    /**
<b class="nc"><i>3541</i>&nbsp;     * Sets the maximum number of digits allowed in the integer portion of a</b>
<b class="nc"><i>3542</i>&nbsp;     * number.</b>
<i>3543</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<b class="nc"><i>3544</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and</b>
<b class="nc"><i>3545</i>&nbsp;     * 309 is used. Negative input values are replaced with 0.</b>
<b class="nc"><i>3546</i>&nbsp;     * @see NumberFormat#setMaximumIntegerDigits</b>
<i>3547</i>&nbsp;     */
<i>3548</i>&nbsp;    @Override
<b class="nc"><i>3549</i>&nbsp;    public void setMaximumIntegerDigits(int newValue) {</b>
<i>3550</i>&nbsp;        maximumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
<i>3551</i>&nbsp;        super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
<i>3552</i>&nbsp;            DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
<i>3553</i>&nbsp;        if (minimumIntegerDigits &gt; maximumIntegerDigits) {
<i>3554</i>&nbsp;            minimumIntegerDigits = maximumIntegerDigits;
<i>3555</i>&nbsp;            super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
<i>3556</i>&nbsp;                DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
<i>3557</i>&nbsp;        }
<i>3558</i>&nbsp;        fastPathCheckNeeded = true;
<i>3559</i>&nbsp;    }
<i>3560</i>&nbsp;
<i>3561</i>&nbsp;    /**
<b class="nc"><i>3562</i>&nbsp;     * Sets the minimum number of digits allowed in the integer portion of a</b>
<i>3563</i>&nbsp;     * number.
<i>3564</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3565</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
<i>3566</i>&nbsp;     * 309 is used. Negative input values are replaced with 0.
<i>3567</i>&nbsp;     * @see NumberFormat#setMinimumIntegerDigits
<i>3568</i>&nbsp;     */
<i>3569</i>&nbsp;    @Override
<i>3570</i>&nbsp;    public void setMinimumIntegerDigits(int newValue) {
<i>3571</i>&nbsp;        minimumIntegerDigits = Math.min(Math.max(0, newValue), MAXIMUM_INTEGER_DIGITS);
<i>3572</i>&nbsp;        super.setMinimumIntegerDigits((minimumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
<i>3573</i>&nbsp;            DOUBLE_INTEGER_DIGITS : minimumIntegerDigits);
<i>3574</i>&nbsp;        if (minimumIntegerDigits &gt; maximumIntegerDigits) {
<b class="nc"><i>3575</i>&nbsp;            maximumIntegerDigits = minimumIntegerDigits;</b>
<i>3576</i>&nbsp;            super.setMaximumIntegerDigits((maximumIntegerDigits &gt; DOUBLE_INTEGER_DIGITS) ?
<i>3577</i>&nbsp;                DOUBLE_INTEGER_DIGITS : maximumIntegerDigits);
<i>3578</i>&nbsp;        }
<i>3579</i>&nbsp;        fastPathCheckNeeded = true;
<i>3580</i>&nbsp;    }
<i>3581</i>&nbsp;
<i>3582</i>&nbsp;    /**
<i>3583</i>&nbsp;     * Sets the maximum number of digits allowed in the fraction portion of a
<i>3584</i>&nbsp;     * number.
<i>3585</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3586</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
<i>3587</i>&nbsp;     * 340 is used. Negative input values are replaced with 0.
<b class="nc"><i>3588</i>&nbsp;     * @see NumberFormat#setMaximumFractionDigits</b>
<i>3589</i>&nbsp;     */
<i>3590</i>&nbsp;    @Override
<i>3591</i>&nbsp;    public void setMaximumFractionDigits(int newValue) {
<i>3592</i>&nbsp;        maximumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
<i>3593</i>&nbsp;        super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
<i>3594</i>&nbsp;            DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
<i>3595</i>&nbsp;        if (minimumFractionDigits &gt; maximumFractionDigits) {
<i>3596</i>&nbsp;            minimumFractionDigits = maximumFractionDigits;
<i>3597</i>&nbsp;            super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
<i>3598</i>&nbsp;                DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
<i>3599</i>&nbsp;        }
<i>3600</i>&nbsp;        fastPathCheckNeeded = true;
<b class="nc"><i>3601</i>&nbsp;    }</b>
<i>3602</i>&nbsp;
<i>3603</i>&nbsp;    /**
<i>3604</i>&nbsp;     * Sets the minimum number of digits allowed in the fraction portion of a
<i>3605</i>&nbsp;     * number.
<i>3606</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3607</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of &lt;code&gt;newValue&lt;/code&gt; and
<i>3608</i>&nbsp;     * 340 is used. Negative input values are replaced with 0.
<i>3609</i>&nbsp;     * @see NumberFormat#setMinimumFractionDigits
<i>3610</i>&nbsp;     */
<i>3611</i>&nbsp;    @Override
<i>3612</i>&nbsp;    public void setMinimumFractionDigits(int newValue) {
<i>3613</i>&nbsp;        minimumFractionDigits = Math.min(Math.max(0, newValue), MAXIMUM_FRACTION_DIGITS);
<i>3614</i>&nbsp;        super.setMinimumFractionDigits((minimumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
<i>3615</i>&nbsp;            DOUBLE_FRACTION_DIGITS : minimumFractionDigits);
<b class="nc"><i>3616</i>&nbsp;        if (minimumFractionDigits &gt; maximumFractionDigits) {</b>
<i>3617</i>&nbsp;            maximumFractionDigits = minimumFractionDigits;
<i>3618</i>&nbsp;            super.setMaximumFractionDigits((maximumFractionDigits &gt; DOUBLE_FRACTION_DIGITS) ?
<i>3619</i>&nbsp;                DOUBLE_FRACTION_DIGITS : maximumFractionDigits);
<i>3620</i>&nbsp;        }
<i>3621</i>&nbsp;        fastPathCheckNeeded = true;
<i>3622</i>&nbsp;    }
<i>3623</i>&nbsp;
<i>3624</i>&nbsp;    /**
<i>3625</i>&nbsp;     * Gets the maximum number of digits allowed in the integer portion of a
<i>3626</i>&nbsp;     * number.
<i>3627</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3628</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
<i>3629</i>&nbsp;     * 309 is used.
<i>3630</i>&nbsp;     * @see #setMaximumIntegerDigits
<i>3631</i>&nbsp;     */
<i>3632</i>&nbsp;    @Override
<b class="nc"><i>3633</i>&nbsp;    public int getMaximumIntegerDigits() {</b>
<b class="nc"><i>3634</i>&nbsp;        return maximumIntegerDigits;</b>
<b class="nc"><i>3635</i>&nbsp;    }</b>
<b class="nc"><i>3636</i>&nbsp;</b>
<i>3637</i>&nbsp;    /**
<i>3638</i>&nbsp;     * Gets the minimum number of digits allowed in the integer portion of a
<b class="nc"><i>3639</i>&nbsp;     * number.</b>
<i>3640</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3641</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
<i>3642</i>&nbsp;     * 309 is used.
<i>3643</i>&nbsp;     * @see #setMinimumIntegerDigits
<i>3644</i>&nbsp;     */
<i>3645</i>&nbsp;    @Override
<i>3646</i>&nbsp;    public int getMinimumIntegerDigits() {
<i>3647</i>&nbsp;        return minimumIntegerDigits;
<i>3648</i>&nbsp;    }
<i>3649</i>&nbsp;
<i>3650</i>&nbsp;    /**
<b class="nc"><i>3651</i>&nbsp;     * Gets the maximum number of digits allowed in the fraction portion of a</b>
<i>3652</i>&nbsp;     * number.
<i>3653</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3654</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
<i>3655</i>&nbsp;     * 340 is used.
<i>3656</i>&nbsp;     * @see #setMaximumFractionDigits
<i>3657</i>&nbsp;     */
<i>3658</i>&nbsp;    @Override
<i>3659</i>&nbsp;    public int getMaximumFractionDigits() {
<i>3660</i>&nbsp;        return maximumFractionDigits;
<i>3661</i>&nbsp;    }
<i>3662</i>&nbsp;
<i>3663</i>&nbsp;    /**
<b class="nc"><i>3664</i>&nbsp;     * Gets the minimum number of digits allowed in the fraction portion of a</b>
<b class="nc"><i>3665</i>&nbsp;     * number.</b>
<i>3666</i>&nbsp;     * For formatting numbers other than &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3667</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects, the lower of the return value and
<b class="nc"><i>3668</i>&nbsp;     * 340 is used.</b>
<b class="nc"><i>3669</i>&nbsp;     * @see #setMinimumFractionDigits</b>
<b class="nc"><i>3670</i>&nbsp;     */</b>
<i>3671</i>&nbsp;    @Override
<i>3672</i>&nbsp;    public int getMinimumFractionDigits() {
<i>3673</i>&nbsp;        return minimumFractionDigits;
<i>3674</i>&nbsp;    }
<i>3675</i>&nbsp;
<i>3676</i>&nbsp;    /**
<i>3677</i>&nbsp;     * Gets the currency used by this decimal format when formatting
<i>3678</i>&nbsp;     * currency values.
<i>3679</i>&nbsp;     * The currency is obtained by calling
<i>3680</i>&nbsp;     * {@link DecimalFormatSymbols#getCurrency DecimalFormatSymbols.getCurrency}
<i>3681</i>&nbsp;     * on this number format&#39;s symbols.
<i>3682</i>&nbsp;     *
<i>3683</i>&nbsp;     * @return the currency used by this decimal format, or &lt;code&gt;null&lt;/code&gt;
<i>3684</i>&nbsp;     * @since 1.4
<i>3685</i>&nbsp;     */
<i>3686</i>&nbsp;    @Override
<i>3687</i>&nbsp;    public Currency getCurrency() {
<i>3688</i>&nbsp;        return symbols.getCurrency();
<i>3689</i>&nbsp;    }
<i>3690</i>&nbsp;
<i>3691</i>&nbsp;    /**
<i>3692</i>&nbsp;     * Sets the currency used by this number format when formatting
<i>3693</i>&nbsp;     * currency values. This does not update the minimum or maximum
<i>3694</i>&nbsp;     * number of fraction digits used by the number format.
<i>3695</i>&nbsp;     * The currency is set by calling
<i>3696</i>&nbsp;     * {@link DecimalFormatSymbols#setCurrency DecimalFormatSymbols.setCurrency}
<i>3697</i>&nbsp;     * on this number format&#39;s symbols.
<i>3698</i>&nbsp;     *
<i>3699</i>&nbsp;     * @param currency the new currency to be used by this decimal format
<i>3700</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;currency&lt;/code&gt; is null
<i>3701</i>&nbsp;     * @since 1.4
<i>3702</i>&nbsp;     */
<i>3703</i>&nbsp;    @Override
<i>3704</i>&nbsp;    public void setCurrency(Currency currency) {
<i>3705</i>&nbsp;        if (currency != symbols.getCurrency()) {
<i>3706</i>&nbsp;            symbols.setCurrency(currency);
<i>3707</i>&nbsp;            if (isCurrencyFormat) {
<i>3708</i>&nbsp;                expandAffixes();
<i>3709</i>&nbsp;            }
<i>3710</i>&nbsp;        }
<i>3711</i>&nbsp;        fastPathCheckNeeded = true;
<i>3712</i>&nbsp;    }
<i>3713</i>&nbsp;
<i>3714</i>&nbsp;    /**
<i>3715</i>&nbsp;     * Gets the {@link java.math.RoundingMode} used in this DecimalFormat.
<i>3716</i>&nbsp;     *
<i>3717</i>&nbsp;     * @return The &lt;code&gt;RoundingMode&lt;/code&gt; used for this DecimalFormat.
<i>3718</i>&nbsp;     * @see #setRoundingMode(RoundingMode)
<b class="nc"><i>3719</i>&nbsp;     * @since 1.6</b>
<b class="nc"><i>3720</i>&nbsp;     */</b>
<i>3721</i>&nbsp;    @Override
<i>3722</i>&nbsp;    public RoundingMode getRoundingMode() {
<i>3723</i>&nbsp;        return roundingMode;
<b class="nc"><i>3724</i>&nbsp;    }</b>
<b class="nc"><i>3725</i>&nbsp;</b>
<b class="nc"><i>3726</i>&nbsp;    /**</b>
<i>3727</i>&nbsp;     * Sets the {@link java.math.RoundingMode} used in this DecimalFormat.
<b class="nc"><i>3728</i>&nbsp;     *</b>
<b class="nc"><i>3729</i>&nbsp;     * @param roundingMode The &lt;code&gt;RoundingMode&lt;/code&gt; to be used</b>
<i>3730</i>&nbsp;     * @see #getRoundingMode()
<b class="nc"><i>3731</i>&nbsp;     * @exception NullPointerException if &lt;code&gt;roundingMode&lt;/code&gt; is null.</b>
<i>3732</i>&nbsp;     * @since 1.6
<i>3733</i>&nbsp;     */
<i>3734</i>&nbsp;    @Override
<i>3735</i>&nbsp;    public void setRoundingMode(RoundingMode roundingMode) {
<i>3736</i>&nbsp;        if (roundingMode == null) {
<b class="nc"><i>3737</i>&nbsp;            throw new NullPointerException();</b>
<b class="nc"><i>3738</i>&nbsp;        }</b>
<b class="nc"><i>3739</i>&nbsp;</b>
<i>3740</i>&nbsp;        this.roundingMode = roundingMode;
<b class="nc"><i>3741</i>&nbsp;        digitList.setRoundingMode(roundingMode);</b>
<b class="nc"><i>3742</i>&nbsp;        fastPathCheckNeeded = true;</b>
<b class="nc"><i>3743</i>&nbsp;    }</b>
<b class="nc"><i>3744</i>&nbsp;</b>
<b class="nc"><i>3745</i>&nbsp;    /**</b>
<i>3746</i>&nbsp;     * Reads the default serializable fields from the stream and performs
<b class="nc"><i>3747</i>&nbsp;     * validations and adjustments for older serialized versions. The</b>
<i>3748</i>&nbsp;     * validations and adjustments are:
<b class="nc"><i>3749</i>&nbsp;     * &lt;ol&gt;</b>
<i>3750</i>&nbsp;     * &lt;li&gt;
<b class="nc"><i>3751</i>&nbsp;     * Verify that the superclass&#39;s digit count fields correctly reflect</b>
<i>3752</i>&nbsp;     * the limits imposed on formatting numbers other than
<i>3753</i>&nbsp;     * &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; objects. These
<i>3754</i>&nbsp;     * limits are stored in the superclass for serialization compatibility
<i>3755</i>&nbsp;     * with older versions, while the limits for &lt;code&gt;BigInteger&lt;/code&gt; and
<i>3756</i>&nbsp;     * &lt;code&gt;BigDecimal&lt;/code&gt; objects are kept in this class.
<i>3757</i>&nbsp;     * If, in the superclass, the minimum or maximum integer digit count is
<b class="nc"><i>3758</i>&nbsp;     * larger than &lt;code&gt;DOUBLE_INTEGER_DIGITS&lt;/code&gt; or if the minimum or</b>
<i>3759</i>&nbsp;     * maximum fraction digit count is larger than
<i>3760</i>&nbsp;     * &lt;code&gt;DOUBLE_FRACTION_DIGITS&lt;/code&gt;, then the stream data is invalid
<i>3761</i>&nbsp;     * and this method throws an &lt;code&gt;InvalidObjectException&lt;/code&gt;.
<i>3762</i>&nbsp;     * &lt;li&gt;
<i>3763</i>&nbsp;     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 4, initialize
<i>3764</i>&nbsp;     * &lt;code&gt;roundingMode&lt;/code&gt; to {@link java.math.RoundingMode#HALF_EVEN
<i>3765</i>&nbsp;     * RoundingMode.HALF_EVEN}.  This field is new with version 4.
<b class="nc"><i>3766</i>&nbsp;     * &lt;li&gt;</b>
<i>3767</i>&nbsp;     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 3, then call
<i>3768</i>&nbsp;     * the setters for the minimum and maximum integer and fraction digits with
<i>3769</i>&nbsp;     * the values of the corresponding superclass getters to initialize the
<i>3770</i>&nbsp;     * fields in this class. The fields in this class are new with version 3.
<i>3771</i>&nbsp;     * &lt;li&gt;
<i>3772</i>&nbsp;     * If &lt;code&gt;serialVersionOnStream&lt;/code&gt; is less than 1, indicating that
<i>3773</i>&nbsp;     * the stream was written by JDK 1.1, initialize
<i>3774</i>&nbsp;     * &lt;code&gt;useExponentialNotation&lt;/code&gt;
<b class="nc"><i>3775</i>&nbsp;     * to false, since it was not present in JDK 1.1.</b>
<i>3776</i>&nbsp;     * &lt;li&gt;
<i>3777</i>&nbsp;     * Set &lt;code&gt;serialVersionOnStream&lt;/code&gt; to the maximum allowed value so
<i>3778</i>&nbsp;     * that default serialization will work properly if this object is streamed
<i>3779</i>&nbsp;     * out again.
<i>3780</i>&nbsp;     * &lt;/ol&gt;
<i>3781</i>&nbsp;     *
<i>3782</i>&nbsp;     * &lt;p&gt;Stream versions older than 2 will not have the affix pattern variables
<b class="nc"><i>3783</i>&nbsp;     * &lt;code&gt;posPrefixPattern&lt;/code&gt; etc.  As a result, they will be initialized</b>
<i>3784</i>&nbsp;     * to &lt;code&gt;null&lt;/code&gt;, which means the affix strings will be taken as
<i>3785</i>&nbsp;     * literal values.  This is exactly what we want, since that corresponds to
<i>3786</i>&nbsp;     * the pre-version-2 behavior.
<i>3787</i>&nbsp;     */
<i>3788</i>&nbsp;    private void readObject(ObjectInputStream stream)
<i>3789</i>&nbsp;         throws IOException, ClassNotFoundException
<i>3790</i>&nbsp;    {
<i>3791</i>&nbsp;        stream.defaultReadObject();
<b class="nc"><i>3792</i>&nbsp;        digitList = new DigitList();</b>
<i>3793</i>&nbsp;
<i>3794</i>&nbsp;        // We force complete fast-path reinitialization when the instance is
<i>3795</i>&nbsp;        // deserialized. See clone() comment on fastPathCheckNeeded.
<i>3796</i>&nbsp;        fastPathCheckNeeded = true;
<i>3797</i>&nbsp;        isFastPath = false;
<i>3798</i>&nbsp;        fastPathData = null;
<i>3799</i>&nbsp;
<i>3800</i>&nbsp;        if (serialVersionOnStream &lt; 4) {
<i>3801</i>&nbsp;            setRoundingMode(RoundingMode.HALF_EVEN);
<i>3802</i>&nbsp;        } else {
<i>3803</i>&nbsp;            setRoundingMode(getRoundingMode());
<i>3804</i>&nbsp;        }
<i>3805</i>&nbsp;
<i>3806</i>&nbsp;        // We only need to check the maximum counts because NumberFormat
<i>3807</i>&nbsp;        // .readObject has already ensured that the maximum is greater than the
<i>3808</i>&nbsp;        // minimum count.
<i>3809</i>&nbsp;        if (super.getMaximumIntegerDigits() &gt; DOUBLE_INTEGER_DIGITS ||
<i>3810</i>&nbsp;            super.getMaximumFractionDigits() &gt; DOUBLE_FRACTION_DIGITS) {
<i>3811</i>&nbsp;            throw new InvalidObjectException(&quot;Digit count out of range&quot;);
<i>3812</i>&nbsp;        }
<i>3813</i>&nbsp;        if (serialVersionOnStream &lt; 3) {
<i>3814</i>&nbsp;            setMaximumIntegerDigits(super.getMaximumIntegerDigits());
<i>3815</i>&nbsp;            setMinimumIntegerDigits(super.getMinimumIntegerDigits());
<i>3816</i>&nbsp;            setMaximumFractionDigits(super.getMaximumFractionDigits());
<i>3817</i>&nbsp;            setMinimumFractionDigits(super.getMinimumFractionDigits());
<i>3818</i>&nbsp;        }
<i>3819</i>&nbsp;        if (serialVersionOnStream &lt; 1) {
<i>3820</i>&nbsp;            // Didn&#39;t have exponential fields
<i>3821</i>&nbsp;            useExponentialNotation = false;
<i>3822</i>&nbsp;        }
<i>3823</i>&nbsp;        serialVersionOnStream = currentSerialVersion;
<i>3824</i>&nbsp;    }
<i>3825</i>&nbsp;
<i>3826</i>&nbsp;    //----------------------------------------------------------------------
<i>3827</i>&nbsp;    // INSTANCE VARIABLES
<i>3828</i>&nbsp;    //----------------------------------------------------------------------
<i>3829</i>&nbsp;
<i>3830</i>&nbsp;    private transient DigitList digitList = new DigitList();
<i>3831</i>&nbsp;
<i>3832</i>&nbsp;    /**
<i>3833</i>&nbsp;     * The symbol used as a prefix when formatting positive numbers, e.g. &quot;+&quot;.
<i>3834</i>&nbsp;     *
<i>3835</i>&nbsp;     * @serial
<i>3836</i>&nbsp;     * @see #getPositivePrefix
<i>3837</i>&nbsp;     */
<i>3838</i>&nbsp;    private String  positivePrefix = &quot;&quot;;
<i>3839</i>&nbsp;
<i>3840</i>&nbsp;    /**
<i>3841</i>&nbsp;     * The symbol used as a suffix when formatting positive numbers.
<i>3842</i>&nbsp;     * This is often an empty string.
<i>3843</i>&nbsp;     *
<i>3844</i>&nbsp;     * @serial
<i>3845</i>&nbsp;     * @see #getPositiveSuffix
<i>3846</i>&nbsp;     */
<i>3847</i>&nbsp;    private String  positiveSuffix = &quot;&quot;;
<i>3848</i>&nbsp;
<i>3849</i>&nbsp;    /**
<b class="nc"><i>3850</i>&nbsp;     * The symbol used as a prefix when formatting negative numbers, e.g. &quot;-&quot;.</b>
<i>3851</i>&nbsp;     *
<i>3852</i>&nbsp;     * @serial
<i>3853</i>&nbsp;     * @see #getNegativePrefix
<i>3854</i>&nbsp;     */
<i>3855</i>&nbsp;    private String  negativePrefix = &quot;-&quot;;
<i>3856</i>&nbsp;
<i>3857</i>&nbsp;    /**
<i>3858</i>&nbsp;     * The symbol used as a suffix when formatting negative numbers.
<i>3859</i>&nbsp;     * This is often an empty string.
<i>3860</i>&nbsp;     *
<b class="nc"><i>3861</i>&nbsp;     * @serial</b>
<i>3862</i>&nbsp;     * @see #getNegativeSuffix
<i>3863</i>&nbsp;     */
<i>3864</i>&nbsp;    private String  negativeSuffix = &quot;&quot;;
<i>3865</i>&nbsp;
<i>3866</i>&nbsp;    /**
<i>3867</i>&nbsp;     * The prefix pattern for non-negative numbers.  This variable corresponds
<i>3868</i>&nbsp;     * to &lt;code&gt;positivePrefix&lt;/code&gt;.
<i>3869</i>&nbsp;     *
<b class="nc"><i>3870</i>&nbsp;     * &lt;p&gt;This pattern is expanded by the method &lt;code&gt;expandAffix()&lt;/code&gt; to</b>
<i>3871</i>&nbsp;     * &lt;code&gt;positivePrefix&lt;/code&gt; to update the latter to reflect changes in
<i>3872</i>&nbsp;     * &lt;code&gt;symbols&lt;/code&gt;.  If this variable is &lt;code&gt;null&lt;/code&gt; then
<i>3873</i>&nbsp;     * &lt;code&gt;positivePrefix&lt;/code&gt; is taken as a literal value that does not
<i>3874</i>&nbsp;     * change when &lt;code&gt;symbols&lt;/code&gt; changes.  This variable is always
<i>3875</i>&nbsp;     * &lt;code&gt;null&lt;/code&gt; for &lt;code&gt;DecimalFormat&lt;/code&gt; objects older than
<i>3876</i>&nbsp;     * stream version 2 restored from stream.
<i>3877</i>&nbsp;     *
<i>3878</i>&nbsp;     * @serial
<b class="nc"><i>3879</i>&nbsp;     * @since 1.3</b>
<i>3880</i>&nbsp;     */
<i>3881</i>&nbsp;    private String posPrefixPattern;
<i>3882</i>&nbsp;
<i>3883</i>&nbsp;    /**
<i>3884</i>&nbsp;     * The suffix pattern for non-negative numbers.  This variable corresponds
<i>3885</i>&nbsp;     * to &lt;code&gt;positiveSuffix&lt;/code&gt;.  This variable is analogous to
<b class="nc"><i>3886</i>&nbsp;     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further</b>
<i>3887</i>&nbsp;     * documentation.
<i>3888</i>&nbsp;     *
<i>3889</i>&nbsp;     * @serial
<i>3890</i>&nbsp;     * @since 1.3
<i>3891</i>&nbsp;     */
<i>3892</i>&nbsp;    private String posSuffixPattern;
<i>3893</i>&nbsp;
<i>3894</i>&nbsp;    /**
<i>3895</i>&nbsp;     * The prefix pattern for negative numbers.  This variable corresponds
<i>3896</i>&nbsp;     * to &lt;code&gt;negativePrefix&lt;/code&gt;.  This variable is analogous to
<b class="nc"><i>3897</i>&nbsp;     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further</b>
<i>3898</i>&nbsp;     * documentation.
<i>3899</i>&nbsp;     *
<i>3900</i>&nbsp;     * @serial
<i>3901</i>&nbsp;     * @since 1.3
<i>3902</i>&nbsp;     */
<i>3903</i>&nbsp;    private String negPrefixPattern;
<i>3904</i>&nbsp;
<i>3905</i>&nbsp;    /**
<i>3906</i>&nbsp;     * The suffix pattern for negative numbers.  This variable corresponds
<i>3907</i>&nbsp;     * to &lt;code&gt;negativeSuffix&lt;/code&gt;.  This variable is analogous to
<i>3908</i>&nbsp;     * &lt;code&gt;posPrefixPattern&lt;/code&gt;; see that variable for further
<i>3909</i>&nbsp;     * documentation.
<i>3910</i>&nbsp;     *
<i>3911</i>&nbsp;     * @serial
<i>3912</i>&nbsp;     * @since 1.3
<i>3913</i>&nbsp;     */
<i>3914</i>&nbsp;    private String negSuffixPattern;
<i>3915</i>&nbsp;
<i>3916</i>&nbsp;    /**
<i>3917</i>&nbsp;     * The multiplier for use in percent, per mille, etc.
<i>3918</i>&nbsp;     *
<i>3919</i>&nbsp;     * @serial
<i>3920</i>&nbsp;     * @see #getMultiplier
<i>3921</i>&nbsp;     */
<i>3922</i>&nbsp;    private int     multiplier = 1;
<i>3923</i>&nbsp;
<i>3924</i>&nbsp;    /**
<i>3925</i>&nbsp;     * The number of digits between grouping separators in the integer
<i>3926</i>&nbsp;     * portion of a number.  Must be greater than 0 if
<i>3927</i>&nbsp;     * &lt;code&gt;NumberFormat.groupingUsed&lt;/code&gt; is true.
<i>3928</i>&nbsp;     *
<i>3929</i>&nbsp;     * @serial
<i>3930</i>&nbsp;     * @see #getGroupingSize
<i>3931</i>&nbsp;     * @see java.text.NumberFormat#isGroupingUsed
<i>3932</i>&nbsp;     */
<i>3933</i>&nbsp;    private byte    groupingSize = 3;  // invariant, &gt; 0 if useThousands
<i>3934</i>&nbsp;
<i>3935</i>&nbsp;    /**
<i>3936</i>&nbsp;     * If true, forces the decimal separator to always appear in a formatted
<i>3937</i>&nbsp;     * number, even if the fractional part of the number is zero.
<i>3938</i>&nbsp;     *
<i>3939</i>&nbsp;     * @serial
<i>3940</i>&nbsp;     * @see #isDecimalSeparatorAlwaysShown
<i>3941</i>&nbsp;     */
<i>3942</i>&nbsp;    private boolean decimalSeparatorAlwaysShown = false;
<i>3943</i>&nbsp;
<i>3944</i>&nbsp;    /**
<i>3945</i>&nbsp;     * If true, parse returns BigDecimal wherever possible.
<i>3946</i>&nbsp;     *
<i>3947</i>&nbsp;     * @serial
<i>3948</i>&nbsp;     * @see #isParseBigDecimal
<i>3949</i>&nbsp;     * @since 1.5
<i>3950</i>&nbsp;     */
<i>3951</i>&nbsp;    private boolean parseBigDecimal = false;
<i>3952</i>&nbsp;
<i>3953</i>&nbsp;
<i>3954</i>&nbsp;    /**
<i>3955</i>&nbsp;     * True if this object represents a currency format.  This determines
<b class="nc"><i>3956</i>&nbsp;     * whether the monetary decimal separator is used instead of the normal one.</b>
<i>3957</i>&nbsp;     */
<i>3958</i>&nbsp;    private transient boolean isCurrencyFormat = false;
<i>3959</i>&nbsp;
<i>3960</i>&nbsp;    /**
<i>3961</i>&nbsp;     * The &lt;code&gt;DecimalFormatSymbols&lt;/code&gt; object used by this format.
<i>3962</i>&nbsp;     * It contains the symbols used to format numbers, e.g. the grouping separator,
<i>3963</i>&nbsp;     * decimal separator, and so on.
<i>3964</i>&nbsp;     *
<i>3965</i>&nbsp;     * @serial
<i>3966</i>&nbsp;     * @see #setDecimalFormatSymbols
<i>3967</i>&nbsp;     * @see java.text.DecimalFormatSymbols
<b class="nc"><i>3968</i>&nbsp;     */</b>
<i>3969</i>&nbsp;    private DecimalFormatSymbols symbols = null; // LIU new DecimalFormatSymbols();
<i>3970</i>&nbsp;
<i>3971</i>&nbsp;    /**
<i>3972</i>&nbsp;     * True to force the use of exponential (i.e. scientific) notation when formatting
<i>3973</i>&nbsp;     * numbers.
<i>3974</i>&nbsp;     *
<i>3975</i>&nbsp;     * @serial
<i>3976</i>&nbsp;     * @since 1.2
<i>3977</i>&nbsp;     */
<i>3978</i>&nbsp;    private boolean useExponentialNotation;  // Newly persistent in the Java 2 platform v.1.2
<i>3979</i>&nbsp;
<b class="nc"><i>3980</i>&nbsp;    /**</b>
<i>3981</i>&nbsp;     * FieldPositions describing the positive prefix String. This is
<i>3982</i>&nbsp;     * lazily created. Use &lt;code&gt;getPositivePrefixFieldPositions&lt;/code&gt;
<i>3983</i>&nbsp;     * when needed.
<i>3984</i>&nbsp;     */
<i>3985</i>&nbsp;    private transient FieldPosition[] positivePrefixFieldPositions;
<i>3986</i>&nbsp;
<i>3987</i>&nbsp;    /**
<i>3988</i>&nbsp;     * FieldPositions describing the positive suffix String. This is
<i>3989</i>&nbsp;     * lazily created. Use &lt;code&gt;getPositiveSuffixFieldPositions&lt;/code&gt;
<i>3990</i>&nbsp;     * when needed.
<i>3991</i>&nbsp;     */
<b class="nc"><i>3992</i>&nbsp;    private transient FieldPosition[] positiveSuffixFieldPositions;</b>
<i>3993</i>&nbsp;
<i>3994</i>&nbsp;    /**
<i>3995</i>&nbsp;     * FieldPositions describing the negative prefix String. This is
<i>3996</i>&nbsp;     * lazily created. Use &lt;code&gt;getNegativePrefixFieldPositions&lt;/code&gt;
<i>3997</i>&nbsp;     * when needed.
<i>3998</i>&nbsp;     */
<i>3999</i>&nbsp;    private transient FieldPosition[] negativePrefixFieldPositions;
<b class="nc"><i>4000</i>&nbsp;</b>
<i>4001</i>&nbsp;    /**
<i>4002</i>&nbsp;     * FieldPositions describing the negative suffix String. This is
<i>4003</i>&nbsp;     * lazily created. Use &lt;code&gt;getNegativeSuffixFieldPositions&lt;/code&gt;
<i>4004</i>&nbsp;     * when needed.
<i>4005</i>&nbsp;     */
<i>4006</i>&nbsp;    private transient FieldPosition[] negativeSuffixFieldPositions;
<i>4007</i>&nbsp;
<i>4008</i>&nbsp;    /**
<i>4009</i>&nbsp;     * The minimum number of digits used to display the exponent when a number is
<i>4010</i>&nbsp;     * formatted in exponential notation.  This field is ignored if
<i>4011</i>&nbsp;     * &lt;code&gt;useExponentialNotation&lt;/code&gt; is not true.
<i>4012</i>&nbsp;     *
<i>4013</i>&nbsp;     * @serial
<i>4014</i>&nbsp;     * @since 1.2
<i>4015</i>&nbsp;     */
<i>4016</i>&nbsp;    private byte    minExponentDigits;       // Newly persistent in the Java 2 platform v.1.2
<i>4017</i>&nbsp;
<i>4018</i>&nbsp;    /**
<i>4019</i>&nbsp;     * The maximum number of digits allowed in the integer portion of a
<i>4020</i>&nbsp;     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
<i>4021</i>&nbsp;     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt; must be greater than or equal to
<b class="nc"><i>4022</i>&nbsp;     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt;.</b>
<i>4023</i>&nbsp;     *
<i>4024</i>&nbsp;     * @serial
<i>4025</i>&nbsp;     * @see #getMaximumIntegerDigits
<i>4026</i>&nbsp;     * @since 1.5
<i>4027</i>&nbsp;     */
<i>4028</i>&nbsp;    private int    maximumIntegerDigits = super.getMaximumIntegerDigits();
<i>4029</i>&nbsp;
<i>4030</i>&nbsp;    /**
<i>4031</i>&nbsp;     * The minimum number of digits allowed in the integer portion of a
<i>4032</i>&nbsp;     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
<i>4033</i>&nbsp;     * &lt;code&gt;minimumIntegerDigits&lt;/code&gt; must be less than or equal to
<i>4034</i>&nbsp;     * &lt;code&gt;maximumIntegerDigits&lt;/code&gt;.
<i>4035</i>&nbsp;     *
<i>4036</i>&nbsp;     * @serial
<i>4037</i>&nbsp;     * @see #getMinimumIntegerDigits
<i>4038</i>&nbsp;     * @since 1.5
<i>4039</i>&nbsp;     */
<i>4040</i>&nbsp;    private int    minimumIntegerDigits = super.getMinimumIntegerDigits();
<i>4041</i>&nbsp;
<i>4042</i>&nbsp;    /**
<i>4043</i>&nbsp;     * The maximum number of digits allowed in the fractional portion of a
<i>4044</i>&nbsp;     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
<i>4045</i>&nbsp;     * &lt;code&gt;maximumFractionDigits&lt;/code&gt; must be greater than or equal to
<i>4046</i>&nbsp;     * &lt;code&gt;minimumFractionDigits&lt;/code&gt;.
<i>4047</i>&nbsp;     *
<i>4048</i>&nbsp;     * @serial
<i>4049</i>&nbsp;     * @see #getMaximumFractionDigits
<i>4050</i>&nbsp;     * @since 1.5
<i>4051</i>&nbsp;     */
<i>4052</i>&nbsp;    private int    maximumFractionDigits = super.getMaximumFractionDigits();
<i>4053</i>&nbsp;
<i>4054</i>&nbsp;    /**
<i>4055</i>&nbsp;     * The minimum number of digits allowed in the fractional portion of a
<i>4056</i>&nbsp;     * &lt;code&gt;BigInteger&lt;/code&gt; or &lt;code&gt;BigDecimal&lt;/code&gt; number.
<i>4057</i>&nbsp;     * &lt;code&gt;minimumFractionDigits&lt;/code&gt; must be less than or equal to
<i>4058</i>&nbsp;     * &lt;code&gt;maximumFractionDigits&lt;/code&gt;.
<b class="nc"><i>4059</i>&nbsp;     *</b>
<b class="nc"><i>4060</i>&nbsp;     * @serial</b>
<i>4061</i>&nbsp;     * @see #getMinimumFractionDigits
<i>4062</i>&nbsp;     * @since 1.5
<i>4063</i>&nbsp;     */
<b class="nc"><i>4064</i>&nbsp;    private int    minimumFractionDigits = super.getMinimumFractionDigits();</b>
<i>4065</i>&nbsp;
<i>4066</i>&nbsp;    /**
<b class="nc"><i>4067</i>&nbsp;     * The {@link java.math.RoundingMode} used in this DecimalFormat.</b>
<i>4068</i>&nbsp;     *
<i>4069</i>&nbsp;     * @serial
<i>4070</i>&nbsp;     * @since 1.6
<i>4071</i>&nbsp;     */
<i>4072</i>&nbsp;    private RoundingMode roundingMode = RoundingMode.HALF_EVEN;
<i>4073</i>&nbsp;
<i>4074</i>&nbsp;    // ------ DecimalFormat fields for fast-path for double algorithm  ------
<i>4075</i>&nbsp;
<i>4076</i>&nbsp;    /**
<i>4077</i>&nbsp;     * Helper inner utility class for storing the data used in the fast-path
<i>4078</i>&nbsp;     * algorithm. Almost all fields related to fast-path are encapsulated in
<i>4079</i>&nbsp;     * this class.
<i>4080</i>&nbsp;     *
<i>4081</i>&nbsp;     * Any {@code DecimalFormat} instance has a {@code fastPathData}
<i>4082</i>&nbsp;     * reference field that is null unless both the properties of the instance
<i>4083</i>&nbsp;     * are such that the instance is in the &quot;fast-path&quot; state, and a format call
<i>4084</i>&nbsp;     * has been done at least once while in this state.
<i>4085</i>&nbsp;     *
<i>4086</i>&nbsp;     * Almost all fields are related to the &quot;fast-path&quot; state only and don&#39;t
<i>4087</i>&nbsp;     * change until one of the instance properties is changed.
<i>4088</i>&nbsp;     *
<i>4089</i>&nbsp;     * {@code firstUsedIndex} and {@code lastFreeIndex} are the only
<i>4090</i>&nbsp;     * two fields that are used and modified while inside a call to
<i>4091</i>&nbsp;     * {@code fastDoubleFormat}.
<i>4092</i>&nbsp;     *
<i>4093</i>&nbsp;     */
<i>4094</i>&nbsp;    private static class FastPathData {
<i>4095</i>&nbsp;        // --- Temporary fields used in fast-path, shared by several methods.
<i>4096</i>&nbsp;
<i>4097</i>&nbsp;        /** The first unused index at the end of the formatted result. */
<i>4098</i>&nbsp;        int lastFreeIndex;
<i>4099</i>&nbsp;
<b class="nc"><i>4100</i>&nbsp;        /** The first used index at the beginning of the formatted result */</b>
<i>4101</i>&nbsp;        int firstUsedIndex;
<i>4102</i>&nbsp;
<i>4103</i>&nbsp;        // --- State fields related to fast-path status. Changes due to a
<i>4104</i>&nbsp;        //     property change only. Set by checkAndSetFastPathStatus() only.
<i>4105</i>&nbsp;
<i>4106</i>&nbsp;        /** Difference between locale zero and default zero representation. */
<i>4107</i>&nbsp;        int  zeroDelta;
<i>4108</i>&nbsp;
<i>4109</i>&nbsp;        /** Locale char for grouping separator. */
<i>4110</i>&nbsp;        char groupingChar;
<i>4111</i>&nbsp;
<i>4112</i>&nbsp;        /**  Fixed index position of last integral digit of formatted result */
<i>4113</i>&nbsp;        int integralLastIndex;
<i>4114</i>&nbsp;
<b class="nc"><i>4115</i>&nbsp;        /**  Fixed index position of first fractional digit of formatted result */</b>
<b class="nc"><i>4116</i>&nbsp;        int fractionalFirstIndex;</b>
<b class="nc"><i>4117</i>&nbsp;</b>
<b class="nc"><i>4118</i>&nbsp;        /** Fractional constants depending on decimal|currency state */</b>
<i>4119</i>&nbsp;        double fractionalScaleFactor;
<i>4120</i>&nbsp;        int fractionalMaxIntBound;
<i>4121</i>&nbsp;
<b class="nc"><i>4122</i>&nbsp;</b>
<b class="nc"><i>4123</i>&nbsp;        /** The char array buffer that will contain the formatted result */</b>
<b class="nc"><i>4124</i>&nbsp;        char[] fastPathContainer;</b>
<b class="nc"><i>4125</i>&nbsp;</b>
<b class="nc"><i>4126</i>&nbsp;        /** Suffixes recorded as char array for efficiency. */</b>
<b class="nc"><i>4127</i>&nbsp;        char[] charsPositivePrefix;</b>
<i>4128</i>&nbsp;        char[] charsNegativePrefix;
<b class="nc"><i>4129</i>&nbsp;        char[] charsPositiveSuffix;</b>
<b class="nc"><i>4130</i>&nbsp;        char[] charsNegativeSuffix;</b>
<b class="nc"><i>4131</i>&nbsp;        boolean positiveAffixesRequired = true;</b>
<i>4132</i>&nbsp;        boolean negativeAffixesRequired = true;
<b class="nc"><i>4133</i>&nbsp;    }</b>
<i>4134</i>&nbsp;
<b class="nc"><i>4135</i>&nbsp;    /** The format fast-path status of the instance. Logical state. */</b>
<b class="nc"><i>4136</i>&nbsp;    private transient boolean isFastPath = false;</b>
<b class="nc"><i>4137</i>&nbsp;</b>
<b class="nc"><i>4138</i>&nbsp;    /** Flag stating need of check and reinit fast-path status on next format call. */</b>
<b class="nc"><i>4139</i>&nbsp;    private transient boolean fastPathCheckNeeded = true;</b>
<i>4140</i>&nbsp;
<b class="nc"><i>4141</i>&nbsp;    /** DecimalFormat reference to its FastPathData */</b>
<i>4142</i>&nbsp;    private transient FastPathData fastPathData;
<i>4143</i>&nbsp;
<b class="nc"><i>4144</i>&nbsp;</b>
<b class="nc"><i>4145</i>&nbsp;    //----------------------------------------------------------------------</b>
<b class="nc"><i>4146</i>&nbsp;</b>
<b class="nc"><i>4147</i>&nbsp;    static final int currentSerialVersion = 4;</b>
<i>4148</i>&nbsp;
<i>4149</i>&nbsp;    /**
<i>4150</i>&nbsp;     * The internal serial version which says which version was written.
<i>4151</i>&nbsp;     * Possible values are:
<i>4152</i>&nbsp;     * &lt;ul&gt;
<i>4153</i>&nbsp;     * &lt;li&gt;&lt;b&gt;0&lt;/b&gt; (default): versions before the Java 2 platform v1.2
<i>4154</i>&nbsp;     * &lt;li&gt;&lt;b&gt;1&lt;/b&gt;: version for 1.2, which includes the two new fields
<i>4155</i>&nbsp;     *      &lt;code&gt;useExponentialNotation&lt;/code&gt; and
<i>4156</i>&nbsp;     *      &lt;code&gt;minExponentDigits&lt;/code&gt;.
<i>4157</i>&nbsp;     * &lt;li&gt;&lt;b&gt;2&lt;/b&gt;: version for 1.3 and later, which adds four new fields:
<i>4158</i>&nbsp;     *      &lt;code&gt;posPrefixPattern&lt;/code&gt;, &lt;code&gt;posSuffixPattern&lt;/code&gt;,
<i>4159</i>&nbsp;     *      &lt;code&gt;negPrefixPattern&lt;/code&gt;, and &lt;code&gt;negSuffixPattern&lt;/code&gt;.
<i>4160</i>&nbsp;     * &lt;li&gt;&lt;b&gt;3&lt;/b&gt;: version for 1.5 and later, which adds five new fields:
<i>4161</i>&nbsp;     *      &lt;code&gt;maximumIntegerDigits&lt;/code&gt;,
<i>4162</i>&nbsp;     *      &lt;code&gt;minimumIntegerDigits&lt;/code&gt;,
<i>4163</i>&nbsp;     *      &lt;code&gt;maximumFractionDigits&lt;/code&gt;,
<i>4164</i>&nbsp;     *      &lt;code&gt;minimumFractionDigits&lt;/code&gt;, and
<i>4165</i>&nbsp;     *      &lt;code&gt;parseBigDecimal&lt;/code&gt;.
<i>4166</i>&nbsp;     * &lt;li&gt;&lt;b&gt;4&lt;/b&gt;: version for 1.6 and later, which adds one new field:
<i>4167</i>&nbsp;     *      &lt;code&gt;roundingMode&lt;/code&gt;.
<i>4168</i>&nbsp;     * &lt;/ul&gt;
<i>4169</i>&nbsp;     * @since 1.2
<i>4170</i>&nbsp;     * @serial
<i>4171</i>&nbsp;     */
<i>4172</i>&nbsp;    private int serialVersionOnStream = currentSerialVersion;
<i>4173</i>&nbsp;
<i>4174</i>&nbsp;    //----------------------------------------------------------------------
<i>4175</i>&nbsp;    // CONSTANTS
<i>4176</i>&nbsp;    //----------------------------------------------------------------------
<i>4177</i>&nbsp;
<b class="nc"><i>4178</i>&nbsp;    // ------ Fast-Path for double Constants ------</b>
<i>4179</i>&nbsp;
<i>4180</i>&nbsp;    /** Maximum valid integer value for applying fast-path algorithm */
<i>4181</i>&nbsp;    private static final double MAX_INT_AS_DOUBLE = (double) Integer.MAX_VALUE;
<i>4182</i>&nbsp;
<i>4183</i>&nbsp;    /**
<i>4184</i>&nbsp;     * The digit arrays used in the fast-path methods for collecting digits.
<i>4185</i>&nbsp;     * Using 3 constants arrays of chars ensures a very fast collection of digits
<i>4186</i>&nbsp;     */
<i>4187</i>&nbsp;    private static class DigitArrays {
<i>4188</i>&nbsp;        static final char[] DigitOnes1000 = new char[1000];
<i>4189</i>&nbsp;        static final char[] DigitTens1000 = new char[1000];
<i>4190</i>&nbsp;        static final char[] DigitHundreds1000 = new char[1000];
<i>4191</i>&nbsp;
<i>4192</i>&nbsp;        // initialize on demand holder class idiom for arrays of digits
<i>4193</i>&nbsp;        static {
<i>4194</i>&nbsp;            int tenIndex = 0;
<i>4195</i>&nbsp;            int hundredIndex = 0;
<i>4196</i>&nbsp;            char digitOne = &#39;0&#39;;
<i>4197</i>&nbsp;            char digitTen = &#39;0&#39;;
<i>4198</i>&nbsp;            char digitHundred = &#39;0&#39;;
<i>4199</i>&nbsp;            for (int i = 0;  i &lt; 1000; i++ ) {
<i>4200</i>&nbsp;
<i>4201</i>&nbsp;                DigitOnes1000[i] = digitOne;
<i>4202</i>&nbsp;                if (digitOne == &#39;9&#39;)
<i>4203</i>&nbsp;                    digitOne = &#39;0&#39;;
<i>4204</i>&nbsp;                else
<i>4205</i>&nbsp;                    digitOne++;
<i>4206</i>&nbsp;
<i>4207</i>&nbsp;                DigitTens1000[i] = digitTen;
<i>4208</i>&nbsp;                if (i == (tenIndex + 9)) {
<i>4209</i>&nbsp;                    tenIndex += 10;
<i>4210</i>&nbsp;                    if (digitTen == &#39;9&#39;)
<i>4211</i>&nbsp;                        digitTen = &#39;0&#39;;
<i>4212</i>&nbsp;                    else
<i>4213</i>&nbsp;                        digitTen++;
<i>4214</i>&nbsp;                }
<i>4215</i>&nbsp;
<i>4216</i>&nbsp;                DigitHundreds1000[i] = digitHundred;
<i>4217</i>&nbsp;                if (i == (hundredIndex + 99)) {
<i>4218</i>&nbsp;                    digitHundred++;
<i>4219</i>&nbsp;                    hundredIndex += 100;
<i>4220</i>&nbsp;                }
<i>4221</i>&nbsp;            }
<i>4222</i>&nbsp;        }
<i>4223</i>&nbsp;    }
<i>4224</i>&nbsp;    // ------ Fast-Path for double Constants end ------
<i>4225</i>&nbsp;
<i>4226</i>&nbsp;    // Constants for characters used in programmatic (unlocalized) patterns.
<i>4227</i>&nbsp;    private static final char       PATTERN_ZERO_DIGIT         = &#39;0&#39;;
<i>4228</i>&nbsp;    private static final char       PATTERN_GROUPING_SEPARATOR = &#39;,&#39;;
<i>4229</i>&nbsp;    private static final char       PATTERN_DECIMAL_SEPARATOR  = &#39;.&#39;;
<i>4230</i>&nbsp;    private static final char       PATTERN_PER_MILLE          = &#39;\u2030&#39;;
<i>4231</i>&nbsp;    private static final char       PATTERN_PERCENT            = &#39;%&#39;;
<i>4232</i>&nbsp;    private static final char       PATTERN_DIGIT              = &#39;#&#39;;
<i>4233</i>&nbsp;    private static final char       PATTERN_SEPARATOR          = &#39;;&#39;;
<i>4234</i>&nbsp;    private static final String     PATTERN_EXPONENT           = &quot;E&quot;;
<i>4235</i>&nbsp;    private static final char       PATTERN_MINUS              = &#39;-&#39;;
<i>4236</i>&nbsp;
<i>4237</i>&nbsp;    /**
<i>4238</i>&nbsp;     * The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
<i>4239</i>&nbsp;     * is used in patterns and substituted with either the currency symbol,
<i>4240</i>&nbsp;     * or if it is doubled, with the international currency symbol.  If the
<i>4241</i>&nbsp;     * CURRENCY_SIGN is seen in a pattern, then the decimal separator is
<i>4242</i>&nbsp;     * replaced with the monetary decimal separator.
<i>4243</i>&nbsp;     *
<i>4244</i>&nbsp;     * The CURRENCY_SIGN is not localized.
<i>4245</i>&nbsp;     */
<i>4246</i>&nbsp;    private static final char       CURRENCY_SIGN = &#39;\u00A4&#39;;
<i>4247</i>&nbsp;
<i>4248</i>&nbsp;    private static final char       QUOTE = &#39;\&#39;&#39;;
<i>4249</i>&nbsp;
<i>4250</i>&nbsp;    private static FieldPosition[] EmptyFieldPositionArray = new FieldPosition[0];
<i>4251</i>&nbsp;
<i>4252</i>&nbsp;    // Upper limit on integer and fraction digits for a Java double
<i>4253</i>&nbsp;    static final int DOUBLE_INTEGER_DIGITS  = 309;
<i>4254</i>&nbsp;    static final int DOUBLE_FRACTION_DIGITS = 340;
<i>4255</i>&nbsp;
<i>4256</i>&nbsp;    // Upper limit on integer and fraction digits for BigDecimal and BigInteger
<i>4257</i>&nbsp;    static final int MAXIMUM_INTEGER_DIGITS  = Integer.MAX_VALUE;
<i>4258</i>&nbsp;    static final int MAXIMUM_FRACTION_DIGITS = Integer.MAX_VALUE;
<i>4259</i>&nbsp;
<i>4260</i>&nbsp;    // Proclaim JDK 1.1 serial compatibility.
<i>4261</i>&nbsp;    static final long serialVersionUID = 864413376551465018L;
<i>4262</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2018-11-19 23:12</div>
</div>
</body>
</html>
